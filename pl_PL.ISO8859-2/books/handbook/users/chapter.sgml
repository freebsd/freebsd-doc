<!--
     The FreeBSD Polish Documentation Project

     $FreeBSD$
     Original revision: 1.55

-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Neil</firstname>
	<surname>Blakey-Milner</surname>
	<contrib>Napisa³ </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
    <!-- translator -->
    <authorgroup>
      <author>
	<firstname>Cezary</firstname>
	<surname>Morga</surname>
	<contrib>Przet³umaczy³ </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>U¿ytkownicy i podstawy zarz±dzania kontami</title>
  
  <sect1 id="users-synopsis">
    <title>Streszczenie</title>
    
    <para>FreeBSD umo¿liwia pracê z komputerem wielu u¿ytkownikom
      w tym samym czasie.  Oczywi¶cie, tylko jedna osoba mo¿e w danej
      chwili siedzieæ przed monitorem i klawiatur±
      <footnote>
	<para>Chyba, ¿e podepniemy kilka terminali, co omawia
          <xref linkend="serialcomms">.</para>
      </footnote>, lecz dowolna liczba u¿ytkowników mo¿e byæ zalogowana
      przez sieæ.  By móc korzystaæ z systemu, ka¿dy u¿ytkownik musi
      posiadaæ konto.</para>
    
    <para>Po przeczytaniu tego rozdzia³u, bêdziemy wiedzieæ:</para>

    <itemizedlist>
      <listitem>
	<para>Jakie s± ró¿nice pomiêdzy ró¿nymi kontami u¿ytkowników
          w systemie FreeBSD.</para>
      </listitem>

      <listitem>
	<para>Jak dodawaæ konta u¿ytkowników.</para>
      </listitem>

      <listitem>
	<para>Jak usuwaæ konta u¿ytkowników.</para>
      </listitem>

      <listitem>
	<para>Jak modyfikowaæ szczegó³y konta, np. pe³n± nazwê
          u¿ytkownika czy preferowan± pow³okê.</para>
      </listitem>

      <listitem>
	<para>Jak ograniczaæ dostêp do zasobów takich jak pamiêæ i czas
          procesora w oparciu o konta i grupy u¿ytkowników.</para>
      </listitem>

      <listitem>
	<para>Jak korzystaæ z grup by u³atwiæ zarz±dzanie kontami.</para>
      </listitem>
    </itemizedlist>

    <para>Przed przeczytaniem tego rozdzia³u, powinni¶my:</para>

    <itemizedlist>
      <listitem>
	<para>Znaæ podstawy obs³ugi systemów &unix; i FreeBSD (<xref
	    linkend="basics">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>Wprowadzenie</title>

    <para>Konta umo¿liwiaj± dostêp do systemu.  Natomiast
      procesy uruchamiane s± przez u¿ytkowników.  St±d te¿ zarz±dzanie
      kontami systemowymi i u¿ytkowników stanowi integralny element
      systemów FreeBSD.</para>

    <para>Z ka¿dym kontem w systemie FreeBSD skojarzone s± pewne informacje
      s³u¿±ce do jego identyfikacji.</para>

    <variablelist>
      <varlistentry>
	<term>Nazwa u¿ytkownika</term>

	<listitem>
	  <para>Nazwa u¿ytkownika, jaka by³aby podana w zg³oszeniu
	    <prompt>login:</prompt>.  Nazwy u¿ytkowników musz± byæ unikalne
            w danym komputerze; nie mo¿emy posiadaæ dwóch u¿ytkowników
            o tej samej nazwie.  Kilka regu³ tworzenia poprawnych
            nazw u¿ytkowników opisuje podrêcznik &man.passwd.5;.  Z regu³y
            stosuje siê nazwy sk³adaj±ce siê z o¶miu b±d¼ mniejszej
            ilo¶ci znaków pisanych ma³± liter±.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Has³o</term>

	<listitem>
	  <para>Ka¿de konto posiada has³o.  Has³o mo¿e byæ puste, w tej sytuacji
            nie bêdzie wymagane ¿adne has³o by uzyskaæ dostêp do systemu.
            Z regu³y jest to bardzo z³ym pomys³em; ka¿de konto powinno zabezpieczone
            has³o.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Identyfikator u¿ytkownika (UID)</term>

	<listitem>
	  <para>UID jest numerem, tradycyjnie z przedzia³u od 0 do
            65535<footnote id="users-largeuidgid"> 
	      <para>Mo¿liwe jest równie¿ wykorzystanie identyfikatorów UID/GID do
		4294967295, jednak¿e takie identyfikatory mog± byæ przyczyn± powa¿nych
		problemów z oprogramowaniem, które dokonuje pewnych za³o¿eñ co do warto¶ci
		identyfikatorów.</para>
	    </footnote>, wykorzystywanym do jednoznacznej identyfikacji u¿ytkownika
	    w systemie.  Do identyfikacji u¿ytkowników &os; wewnêtrznie wykorzystuje
            UID &mdash; ka¿de polecenie FreeBSD przyjmuj±ce nazwê u¿ytkownika jako
	    argument zamieni j± na identyfikator UID przed rozpoczêciem.  Oznacza
	    to, ¿e mo¿emy posiadaæ kilka kont o ró¿nych nazwach u¿ytkowników ale
            o tym samym UID.  Z punktu widzenia FreeBSD konta te s± jednym i tym samym
            u¿ytkownikiem.  Tym nie mniej jest ma³o prawdopodobne by¶my kiedykolwiek
	    tego potrzebowali.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Identyfikator grupy (GID)</term>

	<listitem>
	  <para>GID jest numerem, tradycyjnie z przedzia³u od 0 do 65535<footnoteref linkend="users-largeuidgid">,
            wykorzystywanym do jednoznacznej identyfikacji podstawowej grupy, do której
	    nale¿y u¿ytkownik.  Grupy stanowi± mechanizm kontroli dostêpu do zasobów
            na podstawie identyfikatora GID u¿ytkownika w miejsce jego UID.  Pozwala to znacznie
            zredukowaæ rozmiar niektórych plików konfiguracyjnych.  U¿ytkownik mo¿e nale¿eæ
            do wiêcej ni¿ jednej grupy.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Klasa logowania</term>

	<listitem>
	  <para>Klasy logowania stanowi± rozszerzenie mechanizmu grup, dostarczaj±c
            dodatkowej elastyczno¶ci w procesie dopasowywania systemu do ró¿nych
            u¿ytkowników.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Czas zmiany has³a</term>

	<listitem>
	  <para>Domy¶lnie &os; nie zmusza u¿ytkowników do regularnego zmieniania
            hase³.  Mo¿emy jednak wymusiæ takie zachowanie narzucaj±c niektórym
            b±d¼ wszystkim u¿ytkownikom zmianê ich hase³ w okre¶lonych odstêpach
            czasowych.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Czas wyga¶niêcia konta</term>

	<listitem>
	  <para>Domy¶lnie &os; nie stosuje wygasania kont.  Je¶li
            tworzymy konta, o których wiemy, ¿e bêd± mia³y ograniczon±
            ¿ywotno¶æ, np. w szkole, gdzie zarz±dzamy kontami studentów,
            mo¿emy okre¶liæ kiedy konto wyga¶nie.  Po up³ywie terminu
            wyga¶niêcia konto nie bêdzie mog³o byæ wykorzystane do logowania
            siê do systemu, chocia¿ katalogi i pliki u¿ytkownika pozostan±
            w systemie.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Pe³na nazwa u¿ytkownika</term>

	<listitem>
	  <para>Nazwa u¿ytkownika w sposób jednoznaczny identyfikuje konta
            we &os;, jednak¿e do¶æ czêsto nie odzwierciedla prawdziwych
            nazwisk u¿ytkowników.  Informacja ta mo¿e zostaæ do³±czona
	    do konta.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Katalog macierzysty</term>

	<listitem>
	  <para>Katalog macierzysty okre¶la pe³n± ¶cie¿kê dostêpu do katalogu
            w systemie, w którym dany u¿ytkownik bêdzie rozpoczyna³ pracê po
            ka¿dym zalogowaniu siê do systemu.  Z regu³y katalogi macierzyste
            wszystkich u¿ytkowników umieszczane s± w katalogach
	    <filename>/home/<replaceable>nazwa_u¿ytkownika</replaceable></filename>
	    lub <filename>/usr/home/<replaceable>nazwa_u¿ytkownika</replaceable></filename>.
	    W swoich katalogach macierzystych u¿ytkownicy przechowuj± pliki
            i katalogi, które mog± tworzyæ, modyfikowaæ i usuwaæ wed³ug w³asnego
            uznania.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Pow³oka u¿ytkownika</term>

	<listitem>
	  <para>Pow³oka udostêpnia u¿ytkownikowi domy¶lne ¶rodowisko
            wykorzystywane do interakcji z systemem.  Istnieje wiele
            ró¿nych rodzajów pow³ok.  Do¶wiadczeni u¿ytkownicy
            z pewno¶ci± posiadaj± w³asne upodobania, które mog± mieæ
	    odwzorowanie w ustawieniach ich kont.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Istniej± trzy podstawowe typy kont: konto <link
	linkend="users-superuser">Superu¿ytkownika</link>, <link
	linkend="users-system">konta systemowe</link> i <link
	linkend="users-user">konta u¿ytkowników</link>.  Konto Superu¿ytkownika,
      z regu³y nazywane <username>root</username>, wykorzystywane
      jest do zarz±dzania systemem z nieograniczonymi uprawnieniami.  Konta systemowe
      wykorzystywane s± do uruchamiania us³ug.  Konta u¿ytkowników natomiast
      wykorzystywane s± przez prawdziwych ludzi, którzy loguj± siê,
      czytaj± pocztê itp.</para>
  </sect1>
    
  <sect1 id="users-superuser">
    <title>Konto superu¿ytkownika</title>
    
    <indexterm>
      <primary>konta</primary>
      <secondary>superu¿ytkownik (root)</secondary>
    </indexterm>
    <para>Konto superu¿ytkownika, z regu³y nazywane kontem
      <username>root</username>, domy¶lnie jest tak skonfigurowane,
      by u³atwiæ administracjê systemem i jako takie nie powinno byæ
      wykorzystywane do codziennych zajêæ, jak np. wysy³anie i odbiór
      poczty, ogólne zg³êbianie systemu czy programowanie.</para>
      
    <para>Powodem tego jest fakt, i¿ superu¿ytkownik - w przeciwieñstwie
      do zwyk³ego u¿ytkownika - mo¿e dzia³aæ bez ¿adnych ograniczeñ.  St±d
      te¿ niew³a¶ciwe u¿ycie tego konta mo¿e skoñczyæ siê spektakularn±
      katastrof±.  Konta u¿ytkowników nie s± zdolne przez pomy³kê uszkodziæ
      systemu.  Tak wiêc najlepszym rozwi±zaniem jest korzystanie
      z konta zwyk³ego u¿ytkownika kiedy tylko to mo¿liwe, chyba ¿e szczególnie
      potrzebujemy dodatkowych uprawnieñ.</para>

    <para>Skoro dodatkowa spacja b±d¼ brak znaku mog± doprowadziæ do
      nieodwracalnej utraty danych, zawsze powinni¶my sprawdzaæ polecenie
      wydawane jako superu¿ytkownik dwu- lub nawet trzykrotnie.</para>

    <para>Tak wiêc pierwsz± rzecz±, któr± powinni¶my zrobiæ po przeczytaniu
      tego rozdzia³u - je¶li jeszcze tego nie zrobili¶my - jest stworzenie dla
      siebie konta nieuprzywilejowanego u¿ytkownika do ogólnego zastosowania.
      Dotyczy to zarówno sytuacji gdy korzystamy z systemu o wielu u¿ytkownikach
      jak i gdy pracujemy na maszynie sami.  W dalszej czê¶ci tego rozdzia³u
      omówiony zostanie proces tworzenia dodatkowego konta oraz zmiany
      trybu pracy pomiêdzy zwyk³ym u¿ytkownikiem a superu¿ytkownikiem.</para>
  </sect1>
    
  <sect1 id="users-system">
    <title>Konta systemowe</title>

    <indexterm>
      <primary>konta</primary>
      <secondary>systemowe</secondary>
    </indexterm>
    <para>Konta systemowe wykorzystywane s± do uruchamiania us³ug, takich
      jak np. DNS, poczta, serwery WWW itd.  Powodem takiego wykorzystania
      kont jest bezpieczeñstwo; je¶li wszystkie us³ugi pracowa³yby jako
      superu¿ytkownik, mog³yby dzia³aæ bez ¿adnych ograniczeñ.</para>

    <indexterm>
      <primary>konta</primary>
      <secondary><username>daemon</username></secondary>
    </indexterm>
    <indexterm>
      <primary>konta</primary>
      <secondary><username>operator</username></secondary>
    </indexterm>
    <para>Przyk³adami kont systemowych s± <username>daemon</username>,
      <username>operator</username>, <username>bind</username> (dla
      serwera DNS), <username>news</username> oraz
      <username>www</username>.</para>

    <indexterm>
      <primary>konta</primary>
      <secondary><username>nobody</username></secondary>
    </indexterm>
    <para><username>nobody</username> jest standardowym nieuprzywilejowanym
      kontem systemowym.  Tym nie mniej nale¿y pamiêtaæ, ¿e im wiêcej
      us³ug bêdzie pracowa³o jako u¿ytkownik <username>nobody</username>,
      z tym wiêksz± ilo¶ci± plików i procesów bêdzie on zwi±zany i tym samym
      uzyska wiêksze przywileje.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Konta u¿ytkowników</title>

    <indexterm>
      <primary>konta</primary>
      <secondary>u¿ytkownik</secondary>
    </indexterm>
    <para>Konta u¿ytkowników s± dla rzeczywistych osób podstawowym ¶rodkiem
      dostêpu do systemu.  Izoluj± one u¿ytkowników od otoczenia, uniemo¿liwiaj±c
      im uszkodzenie systemu b±d¼ danych innych u¿ytkowników, pozwalaj±c im przy
      tym dostosowaæ do w³asnych potrzeb ¶rodowisko pracy.</para>

    <para>Ka¿da osoba korzystaj±ca z naszego systemu powinna posiadaæ unikalne
      konto u¿ytkownika.  Pozwala to nam sprawdziæ co kto robi, a tak¿e
      uniemo¿liwiæ u¿ytkownikom ingerencjê w ustawienia innych u¿ytkowników,
      czytaæ sobie na wzajem pocztê itd.</para>

    <para>Ka¿dy u¿ytkownik mo¿e dostosowaæ w³asne ¶rodowisko pracy wykorzystuj±c
      alternatywne pow³oki, edytory, skróty klawiszone czy jêzyk.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Modyfikacja ustawieñ kont</title>

    <indexterm>
      <primary>konta</primary>
      <secondary>modyfikacja</secondary>
    </indexterm>

    <para>W ¶rodowisku systemów &unix; dostêpnych jest szeroka gama ró¿norodnych
      poleceñ do manipulacji kontami u¿ytkowników.  Najczê¶ciej wykorzystywane
      zosta³y omówione poni¿ej, wraz z przyk³adami zastosowania.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*">
	<colspec colwidth="2*">

	<thead>
	  <row>
	    <entry>Polecenie</entry>
	    <entry>Opis</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>
	    <entry>Zalecane pogram wiersza poleceñdo dodawania
              nowych u¿ytkowników.</entry>
	  </row>
	  <row>
	    <entry>&man.rmuser.8;</entry>
	    <entry>Zalecany program wiersza poleceñ do usuwania
              u¿ytkowników.</entry>
	  </row>
	  <row>
	    <entry>&man.chpass.1;</entry>
	    <entry>Elastyczne narzêdzie do zmiany informacji w bazie
              danych u¿ytkowników.</entry>
	  </row>
	  <row>
	    <entry>&man.passwd.1;</entry>
	    <entry>Proste polecenie wiersza poleceñ do zmiany hase³
              u¿ytkowników.</entry>
	  </row>
	  <row>
	    <entry>&man.pw.8;</entry>
	    <entry>Potê¿ne i elastyczne narzêdzie do zmiany wszystkich
              parametrów kont u¿ytkowników.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
        <primary>konta</primary>
        <secondary>dodawanie</secondary>
      </indexterm>
      <indexterm>
        <primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
        <primary><filename class="directory">/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>katalog szkieletowy</primary></indexterm>
      <para>&man.adduser.8; jest prostym programem s³u¿±cym do dodawania
	nowych u¿ytkowników.  Tworzy ono odpowiednie wpisy w plikach systemowych
	<filename>passwd</filename> i <filename>group</filename>,
	tworzy katalog macierzysty nowego u¿ytkownika oraz kopiuje
	z <filename>/usr/share/skel</filename> domy¶lne pliki
        konfiguracyjne (<quote>dotfiles</quote>).  Potrafi równie¿
        wys³aæ nowemu u¿ytkownikowi wiadomo¶æ powitaln±.</para>

      <note>
	<para>Przy wprowadzaniu has³a na ekranie nie s± wy¶wietlane
          ¿adne znaki, nawet gwiazdki.  Dlatego w³a¶nie w tym momencie
          nale¿y zwróciæ szczególn± uwagê, by siê nie pomyliæ.</para>
      </note>
<!-- Zupe³nie nie pasuje mi do kontekstu...
      <note>
        <para>Just use &man.adduser.8; without arguments from now on, and you will
          not have to go through changing the defaults. If the program asks you to
          change the defaults, exit the program, and try the <option>-s</option>
          option..</para>
      </note>
-->
      <example>
	<title>Dodawanie u¿ytkownika we &os;</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
        <primary>konta</primary>
        <secondary>usuwanie</secondary>
      </indexterm>

      <para>By ca³kowicie usun±æ u¿ytkownika z systemu, mo¿emy
        skorzystaæ z &man.rmuser.8;.  Narzêdzie te wykonuje
        nastêpuj±ce czynno¶ci:</para>

      <procedure>
	<step>
	  <para>Usuwa wpisy u¿ytkownika w &man.crontab.1; (je¶li
	    jakie¶ s±).</para>
	</step>
	<step>
	  <para>Usuwa wszystkie prace &man.at.1; nale¿±ce do
            u¿ytkownika.</para>
	</step>
	<step>
	  <para>Niszczy wszystkie procesy u¿ytkownika.</para>
	</step>
	<step>
	  <para>Usuwa u¿ytkownika z lokalnego pliku hase³ w systemie.</para>
	</step>
	<step>
	  <para>Usuwa katalog macierzysty u¿ytkownika (je¶li jego w³a¶cicielem
	    jest dany u¿ytkownik).</para>
	</step>
	<step>
	  <para>Usuwa pocztê nale¿±c± do u¿ytkownika
	    z <filename>/var/mail</filename>.</para>
	</step>
	<step>
	  <para>Usuwa wszystkie pliki z systemów tymczasowych,
            np. <filename>/tmp</filename>, których w³a¶cicielem jest u¿ytkownik.</para>
	</step>
	<step>
	  <para>Ostatecznie, usuwa u¿ytkownika z wszystkich grup
            w <filename>/etc/group</filename>, do których nale¿y.
	    
	    <note>
	      <para>Je¶li po usuniêciu u¿ytkownika grupa pozostanie pusta
                a nazwa tej grupy jest taka sama jak nazwa u¿ytkownika,
                grupa jest równie¿ usuwana; dotyczy to przede wszystkim
		grup u¿ytkowników stworzonych przez &man.adduser.8;.</para>
	    </note>
	  </para>
	</step>
      </procedure>

      <para>Nie mo¿na wykorzystaæ &man.rmuser.8; do usuniêcia konta
        superu¿ytkownika, gdy¿ prawie zawsze wskazuje to na masow±
        destrukcjê.</para>

      <para>Domy¶lnie wykorzystywany jest tryb interaktywny, który stara
        upewniæ siê, ¿e wiemy co robimy.</para>

      <example>
	<title>Tryb interaktywny <command>rmuser</command></title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para>&man.chpass.1; zmienia w bazie danych u¿ytkowników parametry konta,
	jak np. has³o, pow³okê czy inne szczegó³owe informacje.</para>

      <para>Jedynie administrator systemu, jako superu¿ytkownik, mo¿e zmieniaæ
        parametry kont i has³a innych u¿ytkowników za pomoc±
	&man.chpass.1;.</para>

      <para>Je¶li nie podamy ¿adnych opcji b±d¼ jedynie nazwê u¿ytkownika,
	&man.chpass.1; uruchomi edytor informacji o u¿ytkowniku.
	Po wyj¶ciu z edytora, baza danych u¿ytkowników zostanie aktualizowana.</para>

      <note>
	<para>Je¶li nie jeste¶my superu¿ytkownikiem, przed opuszczeniem edytora
          zostaniemy zapytani o has³o.</para>
      </note>

      <example>
	<title>Tryb interaktywny <command>chpass</command> superu¿ytkownika</title>

	<screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Zwykli u¿ytkownicy mog± zmieniæ jedynie czê¶æ tych informacji i jedynie
        w³asnych kont.</para>

      <example>
	<title>Tryb interaktywny <command>chpass</command> zwyk³ego u¿ytkownika</title>

	<screen>#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
	<para>&man.chfn.1; i &man.chsh.1; s± jedynie dowi±zaniami do
	  &man.chpass.1;, podobnie jak
	  &man.ypchpass.1;,
	  &man.ypchfn.1; i
	  &man.ypchsh.1;.  Obs³uga NIS jest automatyczna, tak wiêc
	  dopisywanie <literal>yp</literal> przed poleceniem nie jest
	  potrzebne.  Je¶li jest to dla nas niezrozumia³e, nie martwmy siê,
	  <xref linkend="network-servers"> opisuje NIS szczegó³owo.</para>
      </note>
    </sect2>
    <sect2 id="users-passwd">
      <title><command>passwd</command></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
        <primary>konta</primary>
        <secondary>zmiana has³a</secondary>
      </indexterm>
      <para>U¿ycie polecenia &man.passwd.1; jest typowym sposobem zmiany w³asnego
	has³a, b±d¼ has³a innego u¿ytkownika jako superu¿ytkownik.</para>

      <note>
	<para>By unikn±æ przypadkowych b±d¼ nieuprawnionych zmian, nim bêdziemy
          mogli podaæ nowe has³o, musimy wpierw wpisaæ dotychczasowe.</para>
      </note>

      <example>
	<title>Zmiana w³asnego has³a</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>Zmiana has³a innego u¿ytkownika jako superu¿ytkownik</title>

        <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
	<para>Podobnie jak w przypadku &man.chpass.1;,
	  &man.yppasswd.1; jest jedynie dowi±zaniem do
	  &man.passwd.1;.  Tak wiêc NIS dzia³a poprawnie
	  z obydwoma poleceniami.</para>
      </note>
    </sect2>


    <sect2 id="users-pw">
      <title><command>pw</command></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; jest programem wiersza poleceñ s³u¿±cym do
        tworzenia, usuwania, modyfikowania i wy¶wietlania u¿ytkowników
        i grup.  Dzia³a jako po¶rednik do systemowych
        plików u¿ytkowników i grup.  &man.pw.8; dysponuje bardzo
        potê¿nym zestawem opcji, które umo¿liwiaj± wykorzystanie
        go w skryptach pow³oki.  Jednak¿e, nowym u¿ytkownikom mo¿e
        wydaæ siê zbyt skomplikowany w porównaniu z innymi
        przedstawionych tu poleceniami.</para>
    </sect2>


  </sect1>

  <sect1 id="users-limiting">
    <title>Ograniczanie u¿ytkowników</title>

    <indexterm><primary>ograniczanie u¿ytkowników</primary></indexterm>
    <indexterm>
      <primary>konta</primary>
      <secondary>ograniczanie</secondary>
    </indexterm>
    <para>Je¶li w naszym systemie mamy wielu u¿ytkowników konieczne
      mo¿e siê okazaæ ograniczenie ich mo¿liwo¶ci.  &os; posiada kilka
      sposobów na ograniczenie ilo¶æ zasobów systemowych, które dana
      osoba mo¿e wykorzystaæ.  Ograniczenia te s± podzielone na dwie
      grupy: udzia³y dyskowe i limity innych zasobów.</para>

    <indexterm><primary>udzia³y dyskowe</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>udzia³y dyskowe</secondary>
    </indexterm>
    <indexterm><primary>udzia³y dyskowe</primary></indexterm>
    <para>Udzia³y dyskowe (ang. quota) ograniczaj± dostêpn±
      u¿ytkownikowi przestrzeñ na dysku.  Umo¿liwiaj± równie¿
      szybkie sprawdzenie stopnia jej wykorzystania bez konieczno¶ci
      ka¿dorazowego przeliczania.  Udzia³y dyskowe szczegó³owo
      omawia <xref linkend="quotas">.</para>

    <para>Pozosta³e limity daj± mo¿liwo¶æ ograniczenia
      wykorzystania czasu procesora, pamiêci i innych zasobów,
      z których mo¿e korzystaæ u¿ytkownik.  Definiuje siê je
      przy wykorzystaniu klas logowania i to w³a¶nie one
      zosta³y tutaj opisane.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Klasy logowania okre¶lane s± w pliku
      <filename>/etc/login.conf</filename>.  Szczegó³owa semantyka wykracza
      dalece poza ramy tej sekcji.  Jej pe³en opis znale¼æ mo¿na
      w podrêczniku systemowym &man.login.conf.5;.  W tym momencie
      wystarczy powiedzieæ, ¿e ka¿dy u¿ytkownik posiada przypisan±
      klasê logowania (domy¶lnie jest to klasa <literal>default</literal>)
      przy czym ka¿da klasa logowania dysponuje zestawem uprawnieñ.
      Uprawnieniami logowania s± pary
      <literal><replaceable>nazwa</replaceable>=<replaceable>warto¶æ</replaceable></literal>,
      gdzie <replaceable>nazwa</replaceable> jest identyfikatorem
      a <replaceable>warto¶æ</replaceable> dowolnym ci±giem przetwarzanym
      w sposób zale¿ny od nazwy.  Konfiguracja klas logowania i uprawnieñ
      jest stosunkowo prostym zadaniem i równie¿ zosta³a opisana na stronach
      podrêcznika systemowego &man.login.conf.5;.</para>

    <note>
      <para>Normalnie system nie odczytuje konfiguracji bezpo¶rednio z pliku
	<filename>/etc/login.conf</filename>, lecz odczytuje plik bazy danych
	<filename>/etc/login.conf.db</filename>, który umo¿liwia szybsze
	przeszukiwanie.  By wygenerowaæ plik <filename>/etc/login.conf.db</filename>
	z <filename>/etc/login.conf</filename> nale¿y uruchomiæ nastêpuj±ce
	polecenie:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
    </note>

    <para>Limity zasobów ró¿ni± siê od typowych uprawnieñ logowania.
      Po pierwsze, dla ka¿dego limitu istnieje tzw. miêkki (aktualny)
      i twardy limit.  Limit miêkki mo¿e byæ zmieniany przez u¿ytkownika
      b±d¼ aplikacjê, lecz nie mo¿e byæ wiêkszy od twardego.  Twardy natomiast
      mo¿e byæ zmniejszony przez u¿ytkownika, lecz nie podwy¿szony.
      Po drugie, wiêkszo¶æ limitów zasobów dotyczy procesów danego
      u¿ytkownika, nie u¿ytkownika jako ca³o¶ci.  Przy czym zauwa¿yæ nale¿y,
      ¿e ró¿nice te wynikaj± ze wzglêdu na odmienne metody zarz±dzania
      limitami, nie za¶ na implementacjê struktury uprawnieñ logowania
      (np. nie s± one <emphasis>na prawdê</emphasis> specjalnym przypadkiem
      uprawnieñ logowania).</para>

    <para>Zatem, bez dalszych wstêpów, zestawione poni¿ej zosta³y
      najczê¶ciej wykorzystywane limity zasobów (opis pozosta³ych,
      razem z innymi uprawnieniami logowania, odnale¼æ mo¿na
      w podrêczniku &man.login.conf.5;).</para>

    <variablelist>
      <varlistentry>
        <term><literal>coredumpsize</literal></term>

	<listitem>
    <indexterm><primary>coredumpsize</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>coredumpsize</secondary>
    </indexterm>
	  <para>Ograniczenie rozmiaru pliku rdzenia generowanego
          przez program.  Jest ono - z oczywistych powodów - podrzêdne
          w stosunku do innych limitów wykorzystania przestrzeni dysku
	  (np. <literal>filesize</literal> b±d¼ udzia³ów dyskowych).
	  Niemniej, limit ten jest powszechnie stosowany jako mniej
          surowa metoda kontroli wykorzystania przestrzeni na dysku:
          skoro u¿ytkownicy sami nie generuj± plików rdzenia i czêsto ich
          nie usuwaj±, ustawienie tego limitu mo¿e uchroniæ ich od utraty
          wolnej przestrzeni na dysku gdy du¿y program (np.
	  <application>emacs</application>) ulegnie awarii.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

	<listitem>
    <indexterm><primary>cputime</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>cputime</secondary>
    </indexterm>
	  <para>Jest to maksymalny czas procesora jaki mo¿e poch³aniaæ
            proces u¿ytkownika.  Procesy przekraczaj±ce zostan± zniszczone przez j±dro.

	    <note>
	      <para>Jest to ograniczenie ilo¶ci wykorzystywanego <emphasis>czasu</emphasis>
	        procesora, nie procent wykorzystania jaki wy¶wietlany jest w niektórych
	        polach &man.top.1; i &man.ps.1;.  Ograniczenie tego drugiego, na chwilê
	        pisania tego tekstu, nie jest mo¿liwe i by³oby raczej bezu¿yteczne:
	        przyk³adowo kompilator &mdash; pracuj±cy jako prawdopodobnie uzasadnione zadanie &mdash;
	        mo¿e bardzo ³atwo przez pewien czas zaj±æ prawie 100% procesora.</para>
	    </note>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

	<listitem>
    <indexterm><primary>filesize</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>filesize</secondary>
    </indexterm>
	  <para>Jest to maksymalny rozmiar pliku, który mo¿e posiadaæ u¿ytkownik.
	    W przeciwieñstwie do <link linkend="quotas">udzia³ów dyskowych</link>, limit
	    ten rzutuje na wielko¶æ poszczególnych plików, których w³a¶cicielem jest
            u¿ytkownik, nie za¶ na wszystkie jako ca³o¶æ.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

	<listitem>
    <indexterm><primary>maxproc</primary></indexterm>
        <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>maxproc</secondary>
    </indexterm>
	  <para>Jest to maksymalna liczba procesów, które u¿ytkownik mo¿e
            uruchomiæ.  Dotyczy to zarówno procesy pierwszoplanowe jak i
            pracuj±ce w tle.  Z oczywistych wzglêdów, warto¶æ ta nie mo¿e
            byæ wiêksza ni¿ ograniczenia systemowe parametru &man.sysctl.8;
            <varname>kern.maxproc</varname>.  Warto równie¿ zwróciæ uwagê,
            i¿ zbyt niska warto¶æ mo¿e utrudniæ codzienn± pracê: do¶æ czêsto
            okazuje siê byæ przydatn± mo¿liwo¶æ zalogowania siê w wielu
            sesjach b±d¼ wykonywania poleceñ potokowo.  Niektóre zadania,
            jak np. kompilacja du¿ego programu, równie¿ tworz± wiele procesów
            (np. &man.make.1;, &man.cc.1; i inne preprocesory po¶rednie).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

	<listitem>
    <indexterm><primary>memorylocked</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>memorylocked</secondary>
    </indexterm>
	  <para>Jest to maksymalna wielko¶æ pamiêci jakiej proces
            u¿ytkownika mo¿e zablokowaæ w pamiêci g³ównej
            (np. patrz &man.mlock.2;).  Niektóre bardzo istotne
            dla poprawnego funkcjonowania systemu programy, jak np.
            &man.amd.8;, blokuj± siê w g³ównej pamiêci w taki sposób,
            ¿e w przypadku problemów nie przyk³adaj± siê do zniszczenia
            systemu.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memoryuse</literal></term>

	<listitem>
    <indexterm><primary>memoryuse</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>memoryuse</secondary>
    </indexterm>
	  <para>Jest to maksymalna wielko¶æ pamiêci, któr± proces
            mo¿e w danym czasie wykorzystaæ.  Dotyczy to zarówno pamiêci
            g³ównej jak i przestrzeni wymiany.  Limit ten nie
            wy³apuje wszystkich potencjalnych sytuacji wymagaj±cych
            ograniczania wykorzystania pamiêci, lecz stanowi
            dobry pocz±tek.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>openfiles</literal></term>

	<listitem>
    <indexterm><primary>openfiles</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>openfiles</secondary>
    </indexterm>
	  <para>Jest to maksymalna liczba plików, które proces mo¿e otworzyæ.
            We &os; pliki wykorzystywane s± równie¿ do reprezentacji gniazd
            i kana³ów IPC.  Tym samym nale¿y zachowaæ ostro¿no¶æ przy doborze
            w³a¶ciwej warto¶ci, by nie ustawiæ jej na zbyt nisk±.  Ogólne
            ograniczenie tej warto¶ci dla ca³ego systemu definiowane jest
            przez zmienn± &man.sysctl.8; <varname>kern.maxfiles</varname>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>sbsize</literal></term>

	<listitem>
    <indexterm><primary>sbsize</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>sbsize</secondary>
    </indexterm>
	  <para>Jest to ograniczenie pamiêci sieciowej, w tym
            równie¿ mbufs, któr± mo¿e wykorzystaæ u¿ytkownik.  Limit ten
            zosta³ wprowadzony jako odpowied¼ na stary atak DoS polegaj±cy
            na stworzeniu wielu gniazd sieciowych, lecz mo¿e równie¿
            byæ wykorzystywany jako metoda ograniczenia komunikacji
            sieciowej.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>stacksize</literal></term>

	<listitem>
    <indexterm><primary>stacksize</primary></indexterm>
    <indexterm>
      <primary>ograniczanie u¿ytkowników</primary>
      <secondary>stacksize</secondary>
    </indexterm>
	  <para>Jest to maksymalny rozmiar, do którego mo¿e urosn±æ stos procesu.
            w pamiêci. Sam z siebie nie jest on wystarczaj±cy by ograniczyæ ilo¶æ
            pamiêci wykorzystywanej przez program.  Powinien byæ stosowany
            w parze z innymi limitami.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Jest jeszcze kilka innych kwestii wartych pamiêtania przy konfiguracji
      limitów zasobów.  Poni¿ej zamieszczonych jest kilka ogólnych porad, sugestii
      i rozmaitych komentarzy.</para>

    <itemizedlist>
      <listitem>
        <para>Procesy uruchomione w trakcie uruchamiania systemu przez
          <filename>/etc/rc</filename> s± przypisane do klasy logowania
          <literal>daemon</literal>.</para>
      </listitem>

      <listitem>
        <para>Chocia¿ plik <filename>/etc/login.conf</filename> dostarczany wraz
          z systemem jest dobrym ¼ród³em rozs±dnych warto¶ci dla wiêkszo¶ci ograniczeñ,
          jedynie my - administratorzy - mo¿emy wiedzieæ, co jest odpowiednie dla
          naszego systemu.  Ustawienie zbyt wysokich limitów mo¿e otworzyæ nasz
          system na nadu¿ycia, podczas gdy ustawienie za niskich mo¿e utrudniæ
          codzienn± pracê.</para>
      </listitem>

      <listitem>
        <para>U¿ytkownikom Systemu okien X (X11) powinno prawdopodobnie
          przyznaæ siê wiêcej zasobów ni¿ innym u¿ytkownikom.  X11 samo
          z siebie wykorzystuje du¿o zasobów systemowych, lecz równie¿
          zachêca u¿ytkowników do jednoczesnego uruchamiania wiêkszej
          ilo¶ci programów.</para>
      </listitem>

      <listitem>
        <para>Pamiêtajmy, ¿e wiele limitów ma zastosowanie do indywidualnych
          procesów, nie u¿ytkownika jako ca³o¶ci.  Przyk³adowo, ustawienie
          <varname>openfiles</varname> na 50 oznacza, ¿e ka¿dy proces
          u¿ytkownika mo¿e otworzyæ do 50 plików. Tym samym ca³kowita liczba plików,
          które mo¿e otworzyæ u¿ytkownik wynosi warto¶æ <literal>openfiles</literal>
          pomno¿ona o warto¶æ <literal>maxproc</literal>.  To samo dotyczy
          konsumpcji pamiêci.</para>
      </listitem>
    </itemizedlist>

    <para>Wiêcej informacji o limitach zasobów, klasach logowania i ogólnych
      uprawnieniach znale¼æ mo¿na w odpowiednich podrêcznikach systemowych:
      &man.cap.mkdb.1;, &man.getrlimit.2;, &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-groups">
    <title>Grupy</title>

    <indexterm><primary>grupy</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>konta</primary>
      <secondary>grupy</secondary>
    </indexterm>
    <para>Grupa jest po prostu list± u¿ytkowników. Grupy identyfikowane s± na podstawie
      nazwy grupy oraz numeru GID (ang. Group ID).  We &os; (i w wiêkszo¶ci innych
      systemów &unix;), dwoma czynnikami wykorzystywanymi przez j±dro do okre¶lenia
      czy dany proces jest uprawniony do danej czynno¶ci jest identyfikator u¿ytkownika (UID)
      oraz lista grup, do których u¿ytkownik nale¿y.  W przeciwieñstwie do UID, proces
      dysponuje list± grup powi±zanych z nim.  W ró¿nych ¼ród³ach mo¿emy przeczytaæ,
      ¿e pewne rzeczy odnosz± siê do <quote>identyfikatora grupy</quote> u¿ytkownika b±d¼
      procesu; w wiêkszo¶ci przypadków oznacza to po prostu pierwsz± grupê na li¶cie.</para>

    <para>Odwzorowanie nazwy grupy na identyfikator grupy znajduje siê w pliku
      <filename>/etc/group</filename>.  Jest to prosty plik tekstowy z czterema
      polami oddzielonymi dwukropkiem.  Pierwsze pole zawiera nazwê grupy, drugie
      zaszyfrowane has³o, trzecie identyfikator grupy a czwarte listê cz³onków
      grupy oddzielonych przecinkami.  Plik ten mo¿na ¶mia³o edytowaæ rêcznie
      (zak³adaj±c oczywi¶cie, ¿e nie pope³nimy ¿adnych b³êdów sk³adniowych!).
      Szczegó³owy opis sk³adni pliku znale¼æ mo¿na na stronie podrêcznika
      systemowego &man.group.5;.</para>

    <para>Je¶li nie chcemy rêcznie edytowaæ pliku <filename>/etc/group</filename>,
      by dodawaæ i usuwaæ grupy, mo¿emy wykorzystaæ polecenie &man.pw.8;.
      Przyk³adowo, by dodaæ grupê o nazwie <groupname>teamtwo</groupname>
      a nastêpnie potwierdziæ, ¿e zosta³a dodana mo¿emy u¿yæ:</para>

    <example>
      <title>Dodawanie grupy za pomoc± &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>Numer <literal>1100</literal> powy¿ej jest identyfikatorem grupy
      <groupname>teamtwo</groupname>.  W chwili obecnej grupa ta
      nie zawiera ¿adnych cz³onków i tym samym jest raczej bezu¿yteczna.
      Zmieñmy to zapraszaj±c do grupy u¿ytkownika <username>jru</username>.</para>

    <example>
      <title>Dodawanie u¿ytkownika do grupy za pomoc± &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>Parametrem opcji <option>-M</option> jest lista u¿ytkowników
      oddzielonych przecinkami, którzy s± cz³onkami grupy.  Z poprzednich
      sekcji wiemy, ¿e plik hase³ równie¿ zawiera przypisan± grupê dla
      ka¿dego u¿ytkownika.  Jest to grupa, do której u¿ytkownik zosta³
      automatycznie dodany przez system.  Taki u¿ytkownik nie zostanie
      wy¶wietlony jako cz³onek grupy gdy wykorzystamy polecenie &man.pw.8;
      <option>groupshow</option>, jednak¿e wci±¿ bêdzie wy¶wietlany
      przy u¿yciu polecenia &man.id.1; b±d¼ innego podobnego narzêdzia.
      Innymi s³owy, &man.pw.8; manipuluje jedynie plikiem
      <filename>/etc/group</filename> i nigdy nie spróbuje odczytaæ
      dodatkowych informacji z pliku <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Wykorzystanie &man.id.1; do okre¶lenia cz³onkostwa w grupach</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Jak widzimy, <username>jru</username> jest cz³onkiem grup
      <groupname>jru</groupname> i <groupname>teamtwo</groupname>.</para>

    <para>Wiêcej informacji o poleceniu &man.pw.8; znale¼æ mo¿na w jego
      podrêczniku systemowym.  Natomiast szczegó³owe informacje o formacie
      pliku <filename>/etc/group</filename> znajduj± siê w podrêcznik
      &man.group.5;.</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
