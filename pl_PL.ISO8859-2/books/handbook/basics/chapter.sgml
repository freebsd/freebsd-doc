<!--
     The FreeBSD Polish Documentation Project

     $FreeBSD$
     Original revision: 1.145
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
        <contrib>Rozdzia³ na nowo napisa³ </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
    <authorgroup>
      <author>
        <firstname>Micha³</firstname>
        <surname>Wojciechowski</surname>
        <contrib>T³umaczy³ </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Podstawy Uniksa</title>
  
  <sect1 id="basics-synopsis">
    <title>Streszczenie</title>

    <para>W niniejszym rozdziale omówione zostan± podstawowe polecenia
      i mo¿liwo¶ci systemu operacyjnego FreeBSD. Wiele informacji dotyczyæ
      bêdzie ogó³em systemów typu &unix;. Czytelnikom zaznajomionym z t±
      tematyk± w zupe³no¶ci wystarczy pobie¿ne przejrzenie rozdzia³u.
      Natomiast ci, którzy dopiero rozpoczynaj± swoj± przygodê z FreeBSD,
      powinni przeczytaæ go bardzo uwa¿nie.</para>

    <para>Po przeczytaniu tego rozdzia³u bêdziemy wiedzieæ:</para>

    <itemizedlist>
      <listitem>
        <para>Jak korzystaæ z <quote>konsol wirtualnych</quote> FreeBSD.</para>
      </listitem>
      <listitem>
        <para>Jak dzia³aj± prawa dostêpu do plików i flagi plików we &os;.</para>
      </listitem>
      <listitem>
        <para>Jaki jest domy¶lny uk³ad systemu plików &os;.</para>
      </listitem>
      <listitem>
        <para>Jaka jest organizacja dysku we &os;.</para>
      </listitem>
      <listitem>
        <para>Jak montowaæ i odmontowywaæ systemy plików.</para>
      </listitem>
      <listitem>
        <para>Czym s± procesy, demony i sygna³y.</para>
      </listitem>
      <listitem>
        <para>Co to jest pow³oka, oraz jak mo¿na zmieniæ w³asne ¶rodowisko pracy.</para>
      </listitem>
      <listitem>
        <para>Jak pos³ugiwaæ siê prostymi edytorami tekstu.</para>
      </listitem>
      <listitem>
        <para>Jaki jest zwi±zek pomiêdzy urz±dzeniami i plikami wêz³owymi urz±dzeñ.</para>
      </listitem>
      <listitem>
        <para>Jaki format binarny jest wykorzystywany we &os;.</para>
      </listitem>
      <listitem>
        <para>W jaki sposób korzystaæ z dokumentacji systemowej w poszukiwaniu dodatkowych informacji.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Konsole wirtualne i terminale</title>
    <indexterm><primary>konsole wirtualne</primary></indexterm>
    <indexterm><primary>terminale</primary></indexterm>

    <para>Z systemu FreeBSD korzystaæ mo¿na na ró¿ne sposoby; jednym z
      nich jest wpisywanie poleceñ w terminalu tekstowym. Wiêkszo¶æ
      systemów operacyjnych typu &unix; dostêpna jest w³a¶nie poprzez polecenia.
      W niniejszej czê¶ci dowiemy siê, czym s± <quote>terminale</quote> i
      <quote>konsole</quote>, oraz jak siê nimi pos³ugiwaæ we FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>Konsola</title>
      <indexterm><primary>konsola</primary></indexterm>

      <para>Je¶li konfiguruj±c FreeBSD nie wybrali¶my, by przy
        uruchamianiu systemu by³o automatycznie ³adowane ¶rodowisko
        graficzne, to po uruchomieniu i wykonaniu skryptów startowych
        system przywita nas komunikatem logowania siê do systemu.
        Zobaczymy mniej wiêcej co¶ takiego:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Na ró¿nych komputerach komunikat ten mo¿e wygl±daæ nieco inaczej,
        jednak z pewno¶ci± bêdzie podobny. W tej chwili interesuj± nas jego dwa
        ostatnie wiersze. Wiersz drugi od koñca ma postaæ:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Widaæ tu kilka informacji o systemie, który w³a¶nie zosta³
        uruchomiony. Mamy przed oczami konsolê <quote>FreeBSD</quote>,
        dzia³aj±c± na komputerze z procesorem firmy Intel (lub kompatybilnym)
        z rodziny x86<footnote>
          <para>Takie jest znaczenie symbolu <literal>i386</literal>. Zwróæmy
            uwagê, ¿e nawet wówczas, gdy FreeBSD dzia³a na procesorze Intela
            innym ni¿ 386, w tym miejscu znajdzie siê napis <literal>i386</literal>.
            Nie okre¶la on bowiem typu u¿ywanego procesora, lecz jego
            <quote>architekturê</quote>.</para>
        </footnote>.  Komputer ten zosta³ nazwany (ka¿dy komputer uniksowy
        ma nazwê) <hostid>pc3.example.org</hostid> i w tej chwili widoczna
        jest jego konsola systemowa &mdash; terminal
        <devicename>ttyv0</devicename>.</para>

      <para>Ostatni wiersz ma zawsze tak± postaæ:</para>

      <programlisting>login:</programlisting>

      <para>Tu wpisujemy <quote>nazwê u¿ytkownika</quote>, by zalogowaæ
        siê do systemu.  Opis tej czynno¶ci przedstawiony jest w kolejnej
        czê¶ci.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Logowanie siê do FreeBSD</title>

      <para>FreeBSD jest systemem wielou¿ytkownikowym i wielozadaniowym.
        Tak oficjalnie okre¶la siê system, z którego na jednym komputerze
        mo¿e korzystaæ wiele ró¿nych osób, uruchamiaj±c jednocze¶nie wiele
        programów.</para>

      <para>Ka¿dy system wielou¿ytkownikowy musi mieæ mo¿liwo¶æ
        odró¿nienia jednego <quote>u¿ytkownika</quote> od pozosta³ych.
        FreeBSD (i wszystkie systemy uniksopodobne) wymaga, aby u¿ytkownik
        <quote>zalogowa³ siê</quote> do systemu, zanim bêdzie móg³
        uruchamiaæ programy. Ka¿dy u¿ytkownik ma niepowtarzaln± nazwê
        (<quote>nazwê u¿ytkownika</quote>) oraz sobie tylko znany klucz
        (<quote>has³o</quote>). FreeBSD wymaga wpisania jednego i drugiego,
        zanim zezwoli u¿ytkownikowi na uruchamianie jakichkolwiek
        programów.</para>

      <indexterm><primary>skrypty startowe</primary></indexterm>
      <para>Zaraz po za³adowaniu systemu i zakoñczeniu uruchamiania
        skryptów startowych<footnote>
          <para>Skrypty startowe to programy uruchamiane automatycznie
            podczas ³adowania FreeBSD. Ich podstawowym zadaniem jest
            przygotowanie ¶rodowiska pracy dla innych programów, oraz
            uruchomienie wybranych us³ug dzia³aj±cych w tle, pe³ni±cych
            ró¿ne przydatne funkcje.</para>
        </footnote>, FreeBSD wy¶wietli komunikat z pro¶b± o podanie nazwy
        u¿ytkownika:</para>

      <screen>login:</screen>

      <para>Dla przyk³adu za³ó¿my, ¿e nasz u¿ytkownik nazywa siê
        <username>janek</username>. Wpisujemy tutaj <literal>janek</literal>
        i naciskamy <keycap>Enter</keycap>. Powinni¶my zostaæ poproszeni
        o podanie <quote>has³a</quote>:</para>

      <screen>login: <userinput>janek</userinput>
Password:</screen>

      <para>Nastêpnie wpisujemy has³o <username>janka</username>, i naciskamy
        <keycap>Enter</keycap>. Has³o <emphasis>nie pojawia siê!</emphasis>
        Na razie nie bêdziemy siê tym zajmowaæ. Wystarczy wiedzieæ, ¿e dzieje
        siê tak ze wzglêdów bezpieczeñstwa.</para>

      <para>Je¶li podali¶my prawid³owe has³o, powinni¶my byæ ju¿ zalogowani
        do FreeBSD, i gotowi do eksperymentowania z dostêpnymi poleceniami.</para>

      <para>Powinni¶my zobaczyæ wiadomo¶æ dnia (ang. message of the day
        <acronym>MOTD</acronym>) oraz znak zachêty (<literal>#</literal>,
        <literal>$</literal> b±d¼ <literal>%</literal>). Oznacza to, ¿e
        uda³o nam siê zalogowaæ do FreeBSD.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Konsole wirtualne</title>

      <para>Polecenia uniksowe mo¿na z powodzeniem wpisywaæ na jednej konsoli,
        jednak FreeBSD potrafi wykonywaæ wiele programów jednocze¶nie.
        Korzystanie z jednej konsoli do wydawania poleceñ zakrawa na marnotrawstwo,
        poniewa¿ system zdolny jest obs³u¿yæ w jednej chwili ca³e mnóstwo programów.
        W wykorzystaniu tej mo¿liwo¶ci bardzo pomocne s± <quote>konsole
        wirtualne</quote>.</para>

      <para>Konfiguruj±c FreeBSD mo¿emy uaktywniæ wiele konsol wirtualnych.
        Z dowolnej z nich mo¿emy siê prze³±czyæ na inn± naciskaj±c odpowiedni±
        kombinacjê klawiszy. Ka¿da konsola ma w³asny kana³ wyj¶ciowy, FreeBSD
        zajmuje siê odpowiednim przekazywaniem informacji wprowadzanych z
        klawiatury i wypisywanych na ekranie, gdy dochodzi do prze³±czenia
        konsoli na inn±.</para>

      <para>Pewne kombinacje klawiszy u¿ywane s± do przechodzenia miêdzy
        konsolami<footnote>
          <para>Szczegó³owy opis obecnych we FreeBSD sterowników konsoli
            i klawiatury mo¿na znale¼æ w dokumentacji systemowej
            &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; i &man.kbdcontrol.1;.
            Nie bêdziemy tutaj zajmowaæ siê szczegó³ami, zainteresowani
            czytelnicy s± jak najbardziej zachêcani do zapoznania siê z
            dokumentacj± systemow±, w której omawiane teraz zagadnienia opisane
            s± dok³adniej.</para>
        </footnote>.  Kombinacje
        <keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
        <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, a¿ do
        <keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> s³u¿± do
        prze³±czania na kolejn± konsolê wirtualn±.</para>

      <para>Przechodz±c z jednej konsoli na inn±, FreeBSD zajmuje siê
        zachowaniem i odtworzeniem wygl±du ekranu. W efekcie otrzymujemy
        <quote>z³udzenie</quote> posiadania wielu <quote>wirtualnych</quote>
        ekranów i klawiatur, które mog± s³u¿yæ do wydawania poleceñ systemowi
        FreeBSD. Programy uruchomione na jednej z konsol nie przerywaj± swej
        pracy, gdy ta konsola przestaje byæ widoczna &mdash; po przej¶ciu na
        inn± konsolê wirtualn± programy kontynuuj± swoje dzia³anie.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>Plik <filename>/etc/ttys</filename></title>

      <para>Zgodnie z domy¶ln± konfiguracj± FreeBSD uruchamia osiem konsol
        wirtualnych. Nie jest to jednak permanentne ustawienie, i mo¿e
        byæ w ³atwy sposób zmienione, aby konsol wirtualnych by³o wiêcej
        lub mniej. Plik <filename>/etc/ttys</filename> odpowiedzialny jest
        za liczbê konsol wirtualnych i ich konfiguracjê.</para>

      <para>Modyfikuj±c plik <filename>/etc/ttys</filename> mo¿emy zmieniaæ
        konfiguracjê konsol wirtualnych FreeBSD. Ka¿dy nie bêd±cy komentarzem
        wiersz tego pliku (czyli wiersz nie rozpoczynaj±cy siê znakiem
        <literal>#</literal>) zawiera ustawienia jednego z terminali lub
        konsoli wirtualnej. W domy¶lnej wersji tego pliku wystêpuj±cej
        we FreeBSD skonfigurowanych jest 9 konsol wirtualnych, przy czym 8
        z nich jest w³±czonych. Za ich konfiguracjê odpowiadaj± wiersze
        rozpoczynaj±ce siê symbolem <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Dok³adny opis poszczególnych kolumn tego pliku i opcji,
        za pomoc± których konfiguruje siê konsole wirtualne, znale¼æ
        mo¿na w dokumentacji systemowej &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Konsola trybu jednego u¿ytkownika</title>

      <para><quote>Tryb jednego u¿ytkownika</quote> szczegó³owo
        opisuje <xref linkend="boot-singleuser">. Istotne jest, ¿e w trybie
          jednego u¿ytkownika dostêpna jest tylko jedna konsola. Nie jest
          mo¿liwe korzystanie z konsol wirtualnych. Konfiguracja konsoli
          trybu jednego u¿ytkownika równie¿ znajduje siê w pliku
          <filename>/etc/ttys</filename>. Odpowiada jej wiersz rozpoczynaj±cy
          siê s³owem <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para>Zgodnie z informacj± zawart± w komentarzu nad wierszem
          <literal>console</literal>, wiersz ten mo¿na zmodyfikowaæ,
          zmieniaj±c parametr <literal>secure</literal> na
          <literal>insecure</literal>. Je¶li tak zrobimy, FreeBSD
          po uruchomieniu w trybie jednego u¿ytkownika bêdzie pytaæ
          o has³o u¿ytkownika <username>root</username>.</para>

        <para><emphasis>Zachowajmy jednak ostro¿no¶æ, je¶li wpisujemy tu
          <literal>insecure</literal></emphasis>. Je¿eli zdarzy siê nam
          zapomnieæ has³a u¿ytkownika <username>root</username>, mo¿e
          okazaæ siê potrzebne uruchomienie trybu jednego u¿ytkownika.
          Bêdzie to nadal mo¿liwe, mo¿e jednak byæ nieco trudne dla osób
          nie orientuj±cych siê w procesie uruchamiania FreeBSD i
          uczestnicz±cych w nim programach.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Prawa dostêpu</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, bêd±c bezpo¶rednim potomkiem systemu &unix; BSD,
      oparte jest na kilku kluczowych za³o¿eniach Uniksa. Najbardziej
      widocznym z nich jest fakt, ¿e FreeBSD jest systemem wielou¿ytkownikowym
      &mdash; potrafi jednocze¶nie obs³ugiwaæ wielu u¿ytkowników pracuj±cych
      niezale¿nie od siebie. System jest odpowiedzialny za w³a¶ciwe zarz±dzanie
      odwo³aniami do sprzêtu, pamiêci i czasu procesora, po równo dla ka¿dego
      z u¿ytkowników.</para>

    <para>Ze wzglêdu na obs³ugê wielu u¿ytkowników, zasoby, którymi
      zarz±dza system, maj± przypisane prawa dostêpu okre¶laj±ce, kto
      mo¿e czytaæ, zapisywaæ i uruchamiaæ dany zasób. Prawa dostêpu
      przechowywane s± w postaci dwóch oktetów podzielonych na trzy czê¶ci,
      z których pierwsza odnosi sie do w³a¶ciciela pliku, druga do
      grupy posiadaj±cej plik, a trzecia do innych u¿ytkowników.
      W postaci numerycznej zapisuje siê to nastêpuj±co:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>file permissions</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Warto¶æ</entry>
	    <entry>Uprawnienia</entry>
	    <entry>Symbol</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
            <entry>Odczyt: nie, zapis: nie, wykonywanie: nie</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
            <entry>Odczyt: nie, zapis: nie, wykonywanie: tak</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
            <entry>Odczyt: nie, zapis: tak, wykonywanie: nie</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
            <entry>Odczyt: nie, zapis: tak, wykonywanie: tak</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
            <entry>Odczyt: tak, zapis: nie, wykonywanie: nie</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
            <entry>Odczyt: tak, zapis: nie, wykonywanie: tak</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
            <entry>Odczyt: tak, zapis: tak, wykonywanie: nie</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
            <entry>Odczyt: tak, zapis: tak, wykonywanie: tak</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>katalogi</primary></indexterm>

    <para>Korzystaj±c z polecenia &man.ls.1; mo¿emy pos³u¿yæ siê opcj±
      <option>-l</option>, by zawarto¶æ katalogu zosta³a pokazana
      w formie szczegó³owej, z uwzglêdnieniem kolumny zawieraj±cej
      informacjê o prawach dostêpu do pliku dla jego w³a¶ciciela,
      grupy, oraz wszystkich innych. Przyk³adowy wynik polecenia
      <command>ls -l</command>:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Pierwsza kolumna listy plików po wykonaniu polecenia
      <command>ls -l</command> ma nastêpuj±c± postaæ:</para>

    <screen>-rw-r--r--</screen>

    <para>Pierwszy znak (od lewej) okre¶la, czy plik jest
      zwyczajnym plikiem, katalogiem, urz±dzeniem znakowym,
      gniazdem, czy jakimkolwiek innym urz±dzeniem pseudo-plikowym.
      Widoczny w przyk³adzie znak <literal>-</literal> oznacza
      zwyk³y plik. Kolejne trzy znaki, w przyk³adzie s± to
      <literal>rw-</literal>, reprezentuj± prawa dostêpu, którymi
      dysponuje w³a¶ciciel pliku. Nastêpne trzy znaki <literal>r--</literal>,
      okre¶laj± prawa dostêpu grupy, do której nale¿y plik. Ostatnia trójka
      <literal>r--</literal>, oznacza prawa dostêpu dla innych. Minus
      oznacza brak jednego z praw dostêpu. Plik przedstawiony w
      przyk³adzie mo¿e byæ wiêc odczytywany i zapisywany przez swojego
      w³a¶ciciela, oraz jedynie odczytywany przez grupê i innych.
      Zgodnie z powy¿sz± tabel±, prawa dostêpu do tego pliku maj±
      warto¶æ <literal>644</literal>, przy czym ka¿da cyfra reprezentuje
      trzy czê¶ci uprawnieñ.</para>

    <para>W porz±dku, ale w jaki sposób system kontroluje dostêp
      do urz±dzeñ? Zasadniczo wiêkszo¶æ urz±dzeñ jest traktowana
      przez FreeBSD jak pliki, które mog± byæ otwierane, odczytywane
      i zapisywane podobnie jak wszystkie inne pliki. Specjalne pliki
      urz±dzeñ przechowywane s± w katalogu
      <filename>/dev</filename>.</para>

    <para>Równie¿ katalogi traktowane s± jak pliki &mdash; te¿ s±
      im przypisywane prawa odczytu, zapisu i wykonania. Bit wykonania
      katalogu ma nieco inne znaczenie ni¿ w przypadku pliku.
      Posiadanie prawa wykonania katalogu oznacza, ¿e mo¿na do niego
      wej¶æ, czyli pos³u¿yæ siê poleceniem <quote>cd</quote>.
      Ponadto umo¿liwia to dostêp do zawartych w katalogu plików
      o znanych nazwach (oczywi¶cie obowi±zuj± tak¿e indywidualne
      prawa dostêpu do ka¿dego z plików).</para>

    <para>W szczególno¶ci, wy¶wietlenie listy plików katalogu wymaga
      posiadania prawa do jego odczytu, natomiast do usuniêcia pliku
      o znanej nazwie potrzebne bêd± prawa do zapisu <emphasis>i</emphasis>
      wykonania dla katalogu, w którym ów plik siê znajduje.</para>

    <para>Jest jeszcze kilka innych bitów uprawnieñ, jednak s± one
      stosowane w specjalnych przypadkach, np. do w³±czenia atrybutu
      SUID, lub <quote>lepkiego</quote> bitu dla katlogu. Wiêcej
      informacji o prawach dostêpu i o ich przydzielaniu mo¿na
      znale¼æ w dokumentacji systemowej polecenia &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Napisa³ </contrib>
	  </author>
	</authorgroup>
        <authorgroup>
          <author>
            <firstname>Cezary</firstname>
            <surname>Morga</surname>
            <contrib>T³umaczy³ </contrib>
          </author>
	</authorgroup>
      </sect2info>

      <title>Uprawnienia symboliczne</title>
      <indexterm><primary>uprawnienia</primary><secondary>symboliczne</secondary></indexterm>

      <para>Uprawnienia symboliczne, okre¶lane równie¿ jako wyra¿enia symboliczne,
        przy okre¶laniu praw dostêpu do plików lub katalogów wykorzystuj±
        litery w miejsce warto¶ci liczbowych. Wyra¿enia symboliczne wykorzystuj±
        sk³adniê: (kto) (akcja) (uprawnienia), przy czym dostêpne s± nastêpuj±ce
        warto¶ci:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Opcja</entry>
	      <entry>Litera</entry>
              <entry>Znaczenie</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(kto)</entry>
	    <entry>u</entry>
            <entry>U¿ytkownik (w³a¶ciciel)</entry>
	  </row>

	  <row>
	    <entry>(kto)</entry>
	    <entry>g</entry>
            <entry>Grupa</entry>
	  </row>

	  <row>
	    <entry>(kto)</entry>
	    <entry>o</entry>
	    <entry>Inni</entry>
	  </row>

	  <row>
	    <entry>(kto)</entry>
	    <entry>a</entry>
            <entry>Wszyscy (<quote>¶wiat</quote>)</entry>
	  </row>

	  <row>
	    <entry>(akcja)</entry>
	    <entry>+</entry>
            <entry>Dodanie uprawnieñ</entry>
	  </row>

	  <row>
	    <entry>(akcja)</entry>
	    <entry>-</entry>
            <entry>Usuniêcie uprawnieñ</entry>
	  </row>

	  <row>
	    <entry>(akcja)</entry>
	    <entry>=</entry>
            <entry>Ustawienie uprawnieñ</entry>
	  </row>

	  <row>
	    <entry>(uprawnienia)</entry>
	    <entry>r</entry>
            <entry>Odczyt</entry>
	  </row>

	  <row>
	    <entry>(uprawnienia)</entry>
	    <entry>w</entry>
            <entry>Zapis</entry>
	  </row>

	  <row>
	    <entry>(uprawnienia)</entry>
	    <entry>x</entry>
            <entry>Wykonywanie</entry>
	  </row>

	  <row>
	    <entry>(uprawnienia)</entry>
	    <entry>t</entry>
            <entry>Bit <quote>lepki</quote></entry>
	  </row>

	  <row>
	    <entry>(uprawnienia)</entry>
	    <entry>s</entry>
            <entry>Ustawienie UID lub GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Do ustawienia tych warto¶ci, podobnie jak w przypadku
      warto¶ci liczbowych, wykorzystywane jest polecenie
      &man.chmod.1;. Przyk³adowo, by zablokowaæ dostêp
      innych u¿ytkowników do <replaceable>PLIKU</replaceable>
      nale¿y wpisaæ:</para>

    <screen>&prompt.user; <userinput>chmod go= PLIK</userinput></screen>

    <para>Gdy musimy wykonaæ wiêcej ni¿ jedn± zmianê uprawnieñ
      parametry nale¿y oddzieliæ przecinkami. Na przyk³ad,
      poni¿sze polecenie usunie prawa zapisu do
      <replaceable>PLIKU</replaceable> grupie i innym.
      Nastêpnie doda wszystkim prawo wykonywania:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>PLIK</replaceable></userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Napisa³ </contrib>
	  </author>
	</authorgroup>
        <authorgroup>
          <author>
            <firstname>Cezary</firstname>
            <surname>Morga</surname>
            <contrib>T³umaczy³ </contrib>
          </author>
	</authorgroup>
      </sect2info>

      <title>Flagi plików we &os;</title>

      <para>Dodatkowo, oprócz opisanych wy¿ej praw dostêpu,
        &os; wykorzystuje równie¿ <quote>flagi plików</quote>.
        Flagi te umo¿liwiaj± wprowadzenie dodatkowego poziomu
        ochrony i kontroli plików. Nie dotycz± natomiast
        katalogów.</para>

      <para>Dziêki zwiêkszonemu poziomowi kontroli plików
        system mo¿e zagwarantowaæ, ¿e w niektórych sytuacjach
        nawet u¿ytkownik <username>root</username>  nie bêdzie
        móg³ usun±æ b±d¼ zmodyfikowaæ plików.</para>

      <para>Zmiany flag plików dokonuje siê poleceniem &man.chflags.1;.
        Przyk³adowo, by plikowi <filename>plik1</filename> nadaæ flagê
        nieusuwalno¶ci nale¿y wydaæ poni¿sze polecenie:</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>plik1</filename></userinput></screen>

      <para>Natomiast, by usun±æ flagê nieusuwalno¶ci
        wystarczy wprowadziæ takie samo polecenie dodaj±c
        <quote>no</quote> przed <option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>plik1</filename></userinput></screen>

      <para>By wy¶wietliæ flagi danego pliku wystarczy wpisaæ
        polecenie &man.ls.1; z parametrem <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>plik1</filename>
	</userinput></screen>

      <para>Wynik powinien byæ zbli¿ony do poni¿szego:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 plik1</programlisting>

      <para>Niektóre z flag mog± byæ dodawane i usuwane jedynie przez
        u¿ytkownika <username>root</username>, podczas gdy inne mog±
        byæ ustawiane równie¿ przez w³a¶ciciela pliku. Zaleca siê aby
        administratorzy przeczytali strony podrêcznika systemowego
        &man.chflags.1; oraz &man.chflags.2;.</para>
    </sect2>
  </sect1>
  
  <sect1 id="dirstructure">
    <title>Struktura katalogów</title>
    <indexterm><primary>hierarchia katalogów</primary></indexterm>

    <para>Poznanie hierarchii katalogów FreeBSD jest podstaw±
      ogólnego zrozumienia dzia³ania systemu. Najwa¿niejszym
      zagadnieniem jest koncepcja katalogu g³ównego, <quote>/</quote>.
      Jest on montowany jako pierwszy podczas uruchamiania systemu
      i zawiera podstawowe pliki niezbêdne do przygotowania
      systemu do pracy w trybie wielou¿ytkownikowym. Ponadto
      w katalogu g³ównym znajduj± siê punkty montowania innych
      systemów plików, które mo¿emy montowaæ.</para>

    <para>Punktem montowania nazywany jest katalog, poprzez
      który inny system plików mo¿e byæ do³±czony do g³ównego
      systemu plików. <xref linkend="disk-organization">
      zawiera wiêcej informacji. Przyk³adem typowego punktu
      montowania mo¿e byæ
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>, <filename>/mnt</filename>
      oraz <filename>/cdrom</filename>. Najczê¶ciej ka¿demu
      z takich katalogów odpowiada wpis w pliku
      <filename>/etc/fstab</filename>. Plik ten zawiera tabelê
      systemów plików i ich punktów montowania, z której korzysta
      system. Wiêkszo¶æ systemów plików wymienionych w
      <filename>/etc/fstab</filename> jest montowana automatycznie
      przez skrypt &man.rc.8; podczas uruchamiania systemu,
      wyj±tkiem s± te wpisy, które maj± opcjê <option>noauto</option>.
      <xref linkend="disks-fstab"> zawiera wiêcej informacji.</para>

    <para>Pe³ny opis struktury systemu plików znajduje siê w dokumentacji
      systemowej &man.hier.7;. Tu ograniczymy siê do pobie¿nego
      zapoznania siê z najwa¿niejszymi katalogami.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Katalog</entry>
	      <entry>Opis</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename class="directory">/</filename></entry>
              <entry>G³ówny katalog systemu plików.</entry>
            </row>
	    
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
              <entry>Programy u¿ytkowe wykorzystywane zarówno w trybie
              jednego u¿ytkownika, jak i w trybie wielu u¿ytkowników.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
              <entry>	Programy i pliki konfiguracyjne u¿ywane podczas
              uruchamiania systemu.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
              <entry>Pliki z domy¶ln± konfiguracj± uruchamiania systemu; patrz
	      &man.loader.conf.5;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
              <entry>Pliki urz±dzeñ; patrz &man.intro.4;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
              <entry>Pliki i skrypty konfiguracyjne.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
              <entry>Pliki z domy¶ln± konfiguracj± systemu; patrz &man.rc.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
              <entry>Pliki konfiguracyjne dla serwerów poczty, na przyk³ad
              &man.sendmail.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
              <entry>Pliki konfiguracyjne programu <command>named</command>; patrz
	      &man.named.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
              <entry>Skrypty uruchamiane raz dziennie, raz na tydzieñ i raz na miesi±c
              za po¶rednictwem &man.cron.8;; patrz &man.periodic.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
              <entry>Pliki konfiguracyjne <command>ppp</command>; patrz
	      &man.ppp.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
              <entry>Pusty katalog, najczê¶ciej wykorzystywany przez administratorów
              jako tymczasowy punkt montowania..</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
              <entry>System plików procesów, patrz &man.procfs.5;,
	      &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
              <entry>Katalog zawieraj±cy programy przydatne w przypadku awarii; patrz
		&man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
              <entry>Katalog domowy u¿ytkownika <username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
              <entry>Programy i narzêdzia administracyjne wykorzystywane zarówno
              w trybie jednego u¿ytkownika, jak i w trybie wielu u¿ytkowników.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
              <entry>Programy u¿ywane w samodzielnym ¶rodowisku.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
              <entry>Pliki tymczasowe. Zawarto¶æ katalogu
                <filename class="directory">/tmp</filename> NIE JEST zachowywana
                przy ponownym uruchamianiu systemu. Równie¿ pamiêciowy system
                plików jest czêsto montowany w katalogu
                <filename class="directory">/tmp</filename>. Proces ten mo¿e
                zostaæ zautomatyzowany wykorzystuj±c zmienne &man.rc.conf.5;
                zwi±zane z tmpmfs (b±d¼ za pomoc± wpisu w
                <filename>/etc/fstab</filename>; patrz &man.mdmfs.8;).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
              <entry>Wiêkszo¶æ programów i aplikacji wykorzystywanych przez u¿ytkowników.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
              <entry>Najczê¶ciej u¿ywane programy, narzêdzia programistyczne, aplikacje.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
              <entry>Pliki nag³ówkowe C.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
              <entry>Biblioteki.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
              <entry>Pliki danych ró¿nych programów u¿ytkowych.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
              <entry>Demony i programy systemowe (uruchamiane przez inne programy).</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

              <entry>Lokalne programy, biblioteki, itp. Ponadto jest
                to domy¶lny katalog dla instalowanych portów. Ogólna
                struktura katalogów wewn±trz <filename>/usr/local</filename>
                powinna odpowiadaæ strukturze <filename>/usr</filename>
                opisanej w dokumentacji &man.hier.7;. Wyj±tkiem jest katalog
                man, umieszczony bezpo¶rednio w <filename>/usr/local</filename>,
                a nie w <filename>/usr/local/share</filename>, oraz dokumentacja
                portów, znajduj±ca siê w
	        <filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
              <entry>Pliki zale¿ne od architektury komputera, tworzone w procesie
              budowania drzewa <filename>/usr/src</filename>.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
              <entry>Kolekcja portów FreeBSD (opcjonalna).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
              <entry>Demony i programy systemowe (dostêpne dla u¿ytkowników).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
              <entry>Pliki niezale¿ne od architektury systemu.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
              <entry>Pliki ¼ród³owe BSD, lokalne pliki ¼ród³owe.</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
              <entry>Pliki wykonywalne, biblioteki, i inne pliki dystrybucji
              X11R6 (opcjonalnie).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
              <entry>Rozmaite pliki dzienników systemowych, pliki tymczasowe,
                pliki kolejek. Równie¿ pamiêciowy system plików jest czêsto
                montowany w tym katalogu. Proces ten mo¿e zostaæ
                zautomatyzowany wykorzystuj±c zmienne &man.rc.conf.5; zwi±zane
                z varmfs (b±d¼ za pomoc± wpisu w <filename>/etc/fstab</filename>;
                patrz &man.mdmfs.8;).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
              <entry>Pliki dzienników systemowych.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
              <entry>Skrzynki pocztowe u¿ytkowników.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
              <entry>Katalogi kolejek systemu drukowania i poczty.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
              <entry>Pliki tymczasowe nie usuwane przy ponownym uruchamianiu
              systemu.</entry>
	    </row>
	    
	    <row>
	      <entry><filename>/var/yp</filename></entry>
              <entry>Mapy us³ugi NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Organizacja dysku</title>

      <para>Najmniejsz± jednostk± organizacji dysku u¿ywan± przez FreeBSD
        do odnajdywania plików jest nazwa pliku. W nazwach plików rozró¿niane
        s± du¿e i ma³e litery, tak wiêc <filename>readme.txt</filename>
        i <filename>README.TXT</filename> to dwa ró¿ne pliki. FreeBSD
        nie wykorzystuje rozszerzeñ nazw plików (<filename>.txt</filename>)
        do okre¶lenia, czy plik jest programem, dokumentem, czy innym
        zbiorem danych.</para>

      <para>Pliki przechowywane s± w katalogach. Katalog mo¿e byæ pusty,
        lub mo¿e zawieraæ setki plików. Mo¿e równie¿ zawieraæ inne katalogi,
        dziêki czemu mamy mo¿liwo¶æ zbudowania hierarchicznej struktury
        katalogów. Pozwala to na ³atw± organizacjê danych.</para>

      <para>Dostêp do plików i katalogów uzyskuje siê podaj±c nazwê pliku
        lub katalogu, poprzedzon± uko¶nikiem <literal>/</literal> i innymi
        wymaganymi nazwami katalogów. Je¶li mamy katalog <filename>foo</filename>,
        a w nim katalog <filename>bar</filename>, w którym znajduje siê plik
        <filename>readme.txt</filename>, wówczas pe³n± nazw±, b±d¼ ¶cie¿k±
        dostêpu do pliku jest <filename>foo/bar/readme.txt</filename>.</para>

      <para>Katalogi i pliki przechowywane s± w systemie plików. Ka¿dy
        system plików ma jeden katalog najwy¿szego poziomu, zwany <firstterm>katalogiem
        g³ównym</firstterm> systemu plików. W katalogu g³ównym mog± byæ umieszczone
        nastêpne katalogi.</para>

      <para>To, o czym mówimy, jest zapewne podobne do innych systemów operacyjnych,
        z którymi byæ mo¿e zetknêli¶my siê wcze¶niej. S± jednak ró¿nice; na przyk³ad
        w systemie &ms-dos; nazwy plików i katalogów oddzielane s± znakiem
        <literal>\</literal>, w &macos; natomiast znakiem <literal>:</literal>.</para>

      <para>We FreeBSD nie s± u¿ywane litery dysków, lub inne nazwy dysków w
        ¶cie¿ce. Nie spotkamy siê w FreeBSD z czym¶ takim jak
        <filename>c:/foo/bar/readme.txt</filename>.</para>

      <para>Jest natomiast jeden system plików pe³ni±cy rolê <firstterm>g³ównego
        systemu plików</firstterm>. Zawiera on katalog g³ówny dostêpny jako
        <literal>/</literal>. Ka¿dy inny system plików jest <firstterm>montowany</firstterm>
        w g³ównym systemie plików. Niezale¿nie od tego, ile dysków mamy w komputerze,
        we FreeBSD ka¿dy katalog wydaje siê byæ czê¶ci± tego samego dysku.</para>

      <para>Za³ó¿my, ¿e mamy trzy systemy plików, nazwane <literal>A</literal>,
	<literal>B</literal> i <literal>C</literal>. Ka¿dy z nich ma katalog
        g³ówny, zawieraj±cy dwa katalogi o nazwach <literal>A1</literal>,
        <literal>A2</literal> (oraz odpowiednio
	<literal>B1</literal>, <literal>B2</literal> i
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para>Niech <literal>A</literal> bêdzie g³ównym systemem plików.
        Gdyby¶my sprawdzili jego zawarto¶æ poleceniem <command>ls</command>,
        zobaczyliby¶my dwa podkatalogi <literal>A1</literal> i
	<literal>A2</literal>. Drzewo katalogów wygl±da nastêpuj±co:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>System plików musi byæ montowany w katalogu innego systemu
        plików. Przyjmijmy teraz, ¿e montujemy system plików <literal>B</literal>
        w katalogu <literal>A1</literal>. G³ówny katalog <literal>B</literal>
        zast±pi <literal>A1</literal>, a podkatalogi <literal>B</literal>
        pojawi± siê w odpowiednim miejscu:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 | 
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Do plików znajduj±cych siê w katalogach <literal>B1</literal>
        i <literal>B2</literal> mo¿na siê dostaæ pos³uguj±c siê ¶cie¿k±
        <filename>/A1/B1</filename> lub <filename>/A1/B2</filename>.
        Pliki poprzednio obecne w katalogu <filename>/A1</filename>
        s± tymczasowo ukryte. Pojawi± siê ponownie po
        <firstterm>odmontowaniu</firstterm>
        <filename>B</filename> z <filename>A</filename>.</para>

      <para>Gdyby zamontowaæ <literal>B</literal> w <literal>A2</literal>,
        drzewo katalogów wygl±da³oby tak:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>¶cie¿ki natomiast mia³yby postaæ <filename>/A2/B1</filename>
        i <filename>/A2/B2</filename>.</para>

      <para>Systemy plików mog± byæ montowane jeden na drugim. Rozwijaj±c
        poprzedni przyk³ad, mo¿emy zamontowaæ system plików <literal>C</literal>
        w katalogu <literal>B1</literal> systemu plików <literal>B</literal>,
        otrzymuj±c nastêpuj±c± postaæ drzewa katalogów:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Mo¿na równie dobrze zamontowaæ <literal>C</literal>
        bezpo¶rednio w systemie plików <literal>A</literal>,
        w katalogu <literal>A1</literal>:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Znaj±cym system &ms-dos; mo¿e to przypominaæ polecenie
        <command>join</command>, choæ nie jest to to samo.</para>

      <para>Zwykle nie trzeba zajmowaæ siê opisanymi powy¿ej rzeczami.
        Najczê¶ciej tworzymy systemy plików podczas instalacji FreeBSD,
        wybieramy miejsce ich zamontowania i nie wprowadzamy pó¼niej
        ¿adnych zmian, chyba, ¿e zainstalujemy nowy dysk.</para>

      <para>Mo¿na utworzyæ jeden obszerny g³ówny system plików
        i nie tworzyæ ¿adnych innych. Takie podej¶cie ma kilka wad
        i jedn± zaletê.</para>

      <itemizedlist>
        <title>Korzy¶ci z kilku systemów plików</title>
      
	<listitem>
          <para>Odrêbne systemy plików mog± mieæ ró¿ne <firstterm>opcje
            montowania</firstterm> (mount options). Na przyk³ad, przy
            odpowiednim przygotowaniu, g³ówny system plików mo¿e byæ
            zamontowany tylko do odczytu, przez co niemo¿liwe bêdzie
            przypadkowe usuniêcie lub zmiana wa¿nego pliku. Oddzielenie
            systemów plików dostêpnych do zapisu dla u¿ytkowników, jak
            np. <filename>/home</filename>, od innych pozwala równie¿
            na montowanie ich z opcj± <firstterm>nosuid</firstterm>;
            co z kolei pozwala zwiêkszyæ bezpieczeñstwo systemu
            uniemo¿liwiaj±c wykorzystanie bitów
            <firstterm>suid</firstterm>/<firstterm>guid</firstterm>.</para>
	</listitem>

	<listitem>
          <para>FreeBSD automatycznie optymalizuje uk³ad plików w systemie
            plików, w zale¿no¶ci od tego, jak ów system jest wykorzystywany.
            System plików zawieraj±cy wiele czêsto zapisywanych ma³ych plików
            bêdzie optymalizowany inaczej ni¿ taki, w którym przechowywane
            jest mniej plików o du¿ych rozmiarach. W przypadku jednego du¿ego
            systemu plików taka optymalizacja nie zadzia³a.</para>
	</listitem>
	
	<listitem>
          <para>Systemy plików FreeBSD s± odporne na awarie zasilania.
            W niesprzyjaj±cych okoliczno¶ciach mo¿e siê jednak zdarzyæ,
            ¿e przerwa w dostawie pr±du w krytycznym momencie spowoduje
            uszkodzenie struktury systemu plików. Przechowywanie danych
            w kilku systemach plików zwiêksza szansê, ¿e system uruchomi
            siê ponownie, dziêki czemu ³atwiej bêdzie odzyskaæ dane
            z kopii zapasowej.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
        <title>Korzy¶æ z pojedynczego systemu plików</title>

	<listitem>
          <para>Systemy plików maj± sta³y rozmiar. Podczas instalacji
            FreeBSD tworzymy system plików o zadanym rozmiarze; pó¼niej
            mo¿e siê okazaæ, ¿e trzeba powiêkszyæ partycjê. Nie³atwo
            jest to zrobiæ inaczej, ni¿ przez przygotowanie zapasowej
            kopii danych, utworzenie na nowo systemu plików o wiêkszych
            rozmiarach, oraz skopiowanie danych z powrotem.</para>

	  <important>
            <para>We &os; dostêpne jest polecenie &man.growfs.8;,
              które pozwala na zwiêkszenie rozmiaru systemu plików
              w locie, pomijaj±c wspomniane ograniczenie.</para>
	  </important>
	</listitem>
      </itemizedlist>
    
      <para>Systemy plików przechowywane s± na partycjach. Pojêcie
        partycji ma tu inne znaczenie ni¿ popularnie stosowane (np.
        partycja systemu &ms-dos;), ze wzglêdu na uniksowy rodowód
        &os;. Ka¿da z partycji oznaczana jest liter±, od <literal>a</literal>
        do <literal>h</literal>. Pojedyncza partycja mo¿e zawieraæ
        jeden system plików, dlatego te¿ do systemów plików czêsto
        odwo³uje siê albo poprzez miejsce ich zamontowania w g³ównym
        systemie plików, albo przez literowe oznaczenie partycji, na
        której dany system plików siê znajduje.</para>

      <para>Przestrzeñ dyskowa jest równie¿ u¿ywana we FreeBSD
        jako <firstterm>przestrzeñ wymiany</firstterm>, pe³ni±c w
        ten sposób rolê <firstterm>pamiêci wirtualnej</firstterm>.
        Komputer mo¿e dziêki temu dysponowaæ wiêksz± ilo¶ci± pamiêci,
        ni¿ ma w rzeczywisto¶ci. Kiedy pamiêci zaczyna brakowaæ,
        FreeBSD odsy³a niektóre nieu¿ywane dane do przestrzeni
        wymiany, a gdy znów oka¿± siê potrzebne, przenosi je z powrotem
        (odsy³aj±c jednocze¶nie inne dane).</para>

      <para>Z niektórymi partycjami zwi±zane s± pewne konwencje
        dotycz±ce ich zastosowania./para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Patrycja</entry>

	      <entry>Konwencja</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

              <entry>Zwykle zawiera g³ówny system plików</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

              <entry>Zwykle zawiera przestrzeñ wymiany</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

              <entry>Zwykle jest tego samego rozmiaru, co obejmuj±cy
                j± segment. Dziêki temu programy dzia³aj±ce na ca³ym
                segmencie (na przyk³ad wykrywaj±ce uszkodzone obszary
                dysku) mog± dzia³aæ na partycji <literal>c</literal>.
                Zwykle nie tworzy siê na tej partycji systemu plików.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

              <entry>Swego czasu partycja <literal>d</literal> mia³a specjalne znaczenie,
                obecnie ju¿ go nie ma. Do dzi¶ jednak niektóre programy
                mog± dziwnie siê zachowywaæ, je¶li ka¿e im siê pracowaæ
                na partycji <literal>d</literal>, dlatego te¿
                <application>sysinstall</application>
                zwykle w ogóle jej nie tworzy.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Ka¿da partycja zawieraj±ca system plików przechowywana jest na czym¶,
        co we FreeBSD nosi nazwê <firstterm>segmentu</firstterm>. Jest to okre¶lenie
        tego, co wcze¶niej zwane by³o partycj±, i ponownie jest to konsekwencj±
        uniksowych korzeni FreeBSD. Segmenty s± oznaczane liczbami od 1 do 4.</para>

	<indexterm><primary>segmenty</primary></indexterm>
	<indexterm><primary>partycje</primary></indexterm>
        <indexterm><primary>niebezpiecznie dedykowane</primary></indexterm>

      <para>Numery segmentów, wraz z przedrostkiem <literal>s</literal>,
        poprzedzone s± nazw± urz±dzenia. Tak wiêc
        <quote>da0<emphasis>s1</emphasis></quote>
        jest pierwszym segmentem na pierwszym dysku SCSI. Na dysku mog±
        byæ najwy¿ej cztery fizyczne segmenty, mo¿na jednak tworzyæ segmenty
        logiczne wewn±trz segmentów fizycznych specjalnego typu. Powsta³e
        w ten sposób segmenty rozszerzone maj± numery od 5 wzwy¿, zatem
        <quote>ad0<emphasis>s5</emphasis></quote> odpowiada pierwszemu
        rozszerzonemu segmentowi na dysku IDE. Urz±dzenia te s± wykorzystywane
        przez systemy plików, które zajmuj± ca³y segment.</para> 

      <para>Segmenty, dyski <quote>niebezpiecznie dedykowane</quote>
        i inne dyski zawieraj± <firstterm>partycje</firstterm>,
        oznaczane literami od <literal>a</literal> do <literal>h</literal>.
        Litera dopisywana jest do nazwy urz±dzenia, wiêc
        <quote>da0<emphasis>a</emphasis></quote> odpowiadaæ bêdzie
        partycji a na pierwszym dysku da, <quote>niebezpiecznie
        dedykowanym</quote>. Z kolei <quote>ad1s3<emphasis>e</emphasis></quote>
        oznacza pi±t± partycjê w trzecim segmencie drugiego dysku IDE.</para>
	
      <para>W³asne oznaczenie ma tak¿e ka¿dy dysk. Nazwa dysku sk³ada siê
        z symbolu okre¶laj±cego typ dysku, oraz numeru, okre¶laj±cego
        który to dysk. Dyski, inaczej ni¿ segmenty, numerowane s± od zera.
        <xref linkend="basics-dev-codes"> zawiera najczê¶ciej spotykane zwykle
        oznaczenia.</para>

      <para>Gdy odwo³ujemy siê do partycji, FreeBSD wymaga, by¶my podali
        równie¿ nazwê obejmuj±cego j± segmentu i dysku. Z kolei gdy odwo³ujemy
        siê do segmentu, podajemy równie¿ nazwê dysku. Kolejno podajemy wiêc
        nazwê dysku, <literal>s</literal>, numer segmentu, a na koniec
        literê partycji; patrz <xref linkend="basics-disk-slice-part">.</para>

      <para><xref linkend="basics-concept-disk-model"> pokazuje schematyczny
        model dysku, z pomoc± którego ³atwiej bêdzie zrozumieæ pewne rzeczy.</para>

      <para>Gdy instalujemy FreeBSD, w pierwszej kolejno¶ci musimy przygotowaæ
        segmenty na dysku, nastêpnie w segmencie przeznaczonym dla FreeBSD
        utworzyæ partycje, nastêpnie wewn±trz partycji stworzyæ system plików
        (lub przestrzeñ wymiany) i okre¶liæ miejsce jego montowania.</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
        <title>Oznaczenia dysków</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
              <entry>Oznaczenie</entry>
	    
	      <entry>Znaczenie</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

              <entry>Dysk ATAPI (IDE)</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>
	      
              <entry>Dysk SCSI o dostêpie bezpo¶rednim</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>acd</devicename></entry>
	      
              <entry>CDROM ATAPI (IDE)</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>cd</devicename></entry>
	      
              <entry>CDROM SCSI</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>fd</devicename></entry>
	      
              <entry>Stacja dyskietek</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      
      <example id="basics-disk-slice-part">
        <title>Przyk³adowe nazwy dysków, segmentów i partycji</title>
	
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Nazwa</entry>
		
		<entry>Znaczenie</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
                <entry>Pierwsza partycja (<literal>a</literal>)
                  w pierwszym segmencie (<literal>s1</literal>)
                  na pierwszym dysku IDE (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		
                <entry>Pi±ta partycja <literal>e</literal> w drugim
                  segmencie (<literal>s2</literal>) na drugim dysku
                  SCSI (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
        <title>Schematyczny model dysku</title>

        <para>Rysunek przedstawia pierwszy dysk IDE z punktu widzenia
          FreeBSD. Zak³adamy, ¿e dysk ma rozmiar 4&nbsp;GB i jest podzielony
          na dwa segmenty (partycje w &ms-dos;) o rozmiarze po 2&nbsp;GB.
          Pierwszy segment zawiera DOS-owy dysk <devicename>C:</devicename>,
          natomiast w drugim segmencie znajduje siê przyk³adowa instalacja
          FreeBSD, z trzema partycjami oraz partycj± wymiany.</para>

        <para>Ka¿da z trzech partycji przechowuje system plików. Na
          partycji <literal>a</literal> umieszczony jest g³ówny system plików,
          na <literal>e</literal> znajduje siê katalog <filename>/var</filename>,
          a na <literal>f</literal> katalog <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>
 
          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all 
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>Montowanie i odmontowywanie systemów plików</title>

    <para>System plików mo¿na sobie wyobraziæ jako drzewo, którego
      korzeniem jest <filename>/</filename>. <filename>/dev</filename>,
      <filename>/usr</filename> i inne podkatalogi katalogu g³ównego
      s± ga³êziami, z których mog± wyrastaæ kolejne ga³êzie, na
      przyk³ad <filename>/usr/local</filename>, itd.</para>

    <indexterm><primary>g³ówny system plików</primary></indexterm>
    <para>Jest kilka powodów, dla których warto jest trzymaæ niektóre
      katalogi w oddzielnych systemach plików. W katalogu
      <filename>/var</filename> znajduj± siê podkatalogi
      <filename>log/</filename> i <filename>spool/</filename> oraz rozmaite
      pliki tymczasowe, z tego powodu mo¿e siê on zape³niæ. Zape³nienie
      g³ównego systemu plików jest raczej niepo¿±dane, wiêc czêsto zaleca
      siê oddzielenie <filename>/var</filename> od <filename>/</filename>.</para>

    <para>Czêsto niektóre katalogi umieszczane s± na odrêbnych systemach
      plików ze wzglêdu na to, ¿e znajduj± siê na osobnych dyskach fizycznych
      lub dyskach wirtualnych, jak na przyk³ad pliki udostêpniane poprzez
      <link linkend="network-nfs">Network File System</link>
      lub napêdy CDROM.</para>

    <sect2 id="disks-fstab">
      <title>Plik <filename>fstab</filename></title>
      <indexterm>
	<primary>file systems</primary>
	<secondary>mounted with fstab</secondary>
      </indexterm>

      <para>Systemy plików wymienione w pliku <filename>/etc/fstab</filename>
        s± automatycznie montowane podczas <link linkend="boot">³adowania
          systemu</link> (prócz oznaczonych opcj± <option>noauto</option>)./para>

      <para>Wpisy w pliku <filename>/etc/fstab</filename> s± nastêpuj±cej postaci:</para>

      <programlisting><replaceable>urz±dzenie</replaceable>       <replaceable>/punkt-montowania</replaceable> <replaceable>typ</replaceable>     <replaceable>opcje</replaceable>      <replaceable>archiwizacja</replaceable>     <replaceable>nr-przebiegu</replaceable></programlisting>

      <variablelist>
	<varlistentry>
          <term><literal>urz±dzenie</literal></term>
	  <listitem>
            <para>Nazwa pliku urz±dzenia (istniej±cego), zgodnie z opisem w
	      <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><literal>punkt-montowania</literal></term>
            
          <listitem><para>Katalog (istniej±cy), w którym system
              plików ma byæ zamontowany.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>typ</literal></term>
            
          <listitem><para>Typ systemu plików przekazywany poleceniu
		&man.mount.8;. We FreeBSD domy¶lnie jest to
	      <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><literal>opcje</literal></term>
            
          <listitem><para>Pierwsz± opcj± jest <option>rw</option>, je¶li
              w systemie plików ma byæ mo¿liwy odczyt i zapis, albo
              <option>ro</option>, je¿eli dozwolony ma byæ tylko odczyt.
              W nastêpnej kolejno¶ci podawane s± inne opcje. Czêsto stosowana
              jest opcja <option>noauto</option>, która zapobiega automatycznemu
              montowaniu systemu plików podczas uruchamiania systemu.
              Pozosta³e opcje opisane s± w dokumentacji systemowej &man.mount.8;.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><literal>archiwizacja</literal></term>
          
          <listitem><para>Na podstawie tej informacji program &man.dump.8;
              stwierdza, które systemy plików maj± byæ archiwizowane. Je¶li pole
              to zostanie pominiête, domy¶lnie przyjmowana jest warto¶æ zero.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>nr-przebiegu</literal></term>

         <listitem>
           <para>Na podstawie tego pola wyznaczana jest kolejno¶æ, w jakiej
             systemy plików poddawane s± sprawdzaniu. Systemy plików, które
             nie maj± byæ sprawdzane, powinny mieæ <literal>nr-przebiegu</literal>
             ustawiony na zero. G³ówny system plików (powinien byæ sprawdzony
             jako pierwszy) powinien mieæ <literal>nr-przebiegu</literal> o warto¶ci
             jeden, a inne systemy plików powinny mieæ wpisan± warto¶æ wiêksz± od
             jednego. Je¶li dwa lub wiêcej systemów plików bêdzie mia³o taki sam
             <literal>nr-przebiegu</literal>, wówczas &man.fsck.8;, o ile bêdzie
             to mo¿liwe, podejmie próbê równoleg³ego sprawdzenia tych systemów
             plików.</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>Wiêcej informacji o formacie pliku <filename>/etc/fstab</filename>
        oraz definiowanych w nim opcji dostêpnych w podrêczniku systemowym &man.fstab.5;</para>
    </sect2>

    <sect2 id="disks-mount">
      <title>Polecenie <command>mount</command></title>
      <indexterm>
	<primary>systemy plików</primary>
	<secondary>montowanie</secondary>
      </indexterm>
        
      <para>Polecenie &man.mount.8; jest g³ównym poleceniem u¿ywanym
        do montowania systemów plików.</para>
        
      <para>W najprostszej postaci, u¿ywa siê go nastêpuj±co:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>urz±dzenie</replaceable> <replaceable>punkt-montowania</replaceable></userinput></screen>
      </informalexample>

      <para>Polecenie to ma mnóstwo opcji wymienionych w dokumentacji
        systemowej &man.mount.8;. Do najczê¶ciej stosowanych nale¿±:</para>

      <variablelist>
        <title>Opcje montowania</title>

	<varlistentry>
	  <term><option>-a</option></term>
            
	  <listitem>
            <para>Montowanie wszystkich systemów plików
              wymienionych w <filename>/etc/fstab</filename>.
              Nie s± montowane systemy plików z opcj± <quote>noauto</quote>
              oraz wykluczone przez opcjê <option>-t</option>,
              jak równie¿ systemy plików ju¿ zamontowane.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-d</option></term>
            
	  <listitem>
            <para>Wykonanie wszystkiego, oprócz faktycznego wywo³ania
              funkcji systemowej montowania. W po³±czeniu z opcj±
              <option>-v</option> mo¿na w ten sposób sprawdziæ, co
              tak naprawdê &man.mount.8; stara siê zrobiæ.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
            <para>Wymuszenie montowania nieuporz±dkowanego systemu
              plików (niebezpieczne), lub wymuszenie odebrania prawa
              do zapisu przy zmianie trybu montowania systemu plików
              z trybu <quote>odczyt i zapis</quote> na
              <quote>tylko do odczytu</quote>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><option>-r</option></term>
            
	  <listitem>
            <para>Montowanie systemu plików w trybie tylko do odczytu.
              Taki sam efekt ma zastosowanie opcji  <option>-o</option>
              z argumentem <option>ro</option> (b±d¼ <option>rdonly</option>
              w wersjach FreeBSD wcze¶niejszych ni¿ 5.2).</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>typ</replaceable></term>

	  <listitem>
            <para>Montowanie systemu plików o okre¶lonym typie.
              Przy zastosowaniu opcji <option>-a</option> montowane
              s± tylko systemy plików podanego typu.</para>
              
            <para>Domy¶lnym typem systemu plików jest <quote>ufs</quote>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-u</option></term>
            
	  <listitem>
            <para>Uaktualnienie opcji montowania systemu plików.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-v</option></term>
            
	  <listitem>
            <para>Pokazywanie dodatkowych komunikatów.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-w</option></term>
            
	  <listitem>
            <para>Montowanie w trybie odczytu i zapisu.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
        
      <para>Opcji <option>-o</option> towarzyszy lista oddzielonych
        przecinkami parametrów, oto niektóre z nich:</para>
        
      <variablelist>
	<varlistentry>
	  <term>nodev</term>
            
	  <listitem>
            <para>Ignorowanie obecnych w systemie plików urz±dzeñ
              specjalnych. Przydatna opcja, je¶li chodzi
              o bezpieczeñstwo.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>noexec</term>
            
	  <listitem>
            <para>Wy³±czenie uruchamiania programów wykonywalnych
              na systemie plików. Równie¿ s³u¿y bezpieczeñstwu.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>nosuid</term>
            
	  <listitem>
            <para>Ignorowanie bitów setuid i setgid w systemie
              plików. Kolejna opcja s³u¿±ca bezpieczeñstwu.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>Polecenie <command>umount</command> Command</title>
      <indexterm>
	<primary>systemy plików</primary>
	<secondary>odmontowywanie</secondary>
      </indexterm>
        
      <para>Poleceniu &man.umount.8; nale¿y podaæ jako parametr
        punkt montowania, nazwê urz±dzenia b±d¼ opcjê <option>-a</option> lub
	<option>-A</option>.</para>
        
      <para>Ka¿dej z form wywo³ania polecenia mo¿na podaæ opcjê
        <option>-f</option>, która nakazuje dokonaæ bezwarunkowego
        odmontowania, oraz opcjê <option>-v</option>, powoduj±c±
        wypisywanie dodatkowych komunikatów. Nale¿y mieæ na uwadze,
        ¿e raczej nie zaleca siê korzystania z <option>-f</option>.
        Bezwarunkowe odmontowywanie systemu plików mo¿e doprowadziæ
        do awarii systemu lub uszkodzenia danych znajduj±cych siê
        w danym systemie plików.</para>
        
      <para>Opcje <option>-a</option> oraz <option>-A</option> s³u¿±
        do odmontowania wszystkich zamontowanych systemów plików,
        lub systemów plików wybranych typów, okre¶lonych w opcji
        <option>-t</option>. Opcja <option>-A</option> nie dokonuje
        próby odmontowania g³ównego systemu plików.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Procesy</title>

    <para>FreeBSD jest wielozadaniowym systemem operacyjnym. Oznacza
      to, ¿e korzystaj±c z systemu mamy wra¿enie, ¿e wiele programów
      dzia³a jednocze¶nie. Dzia³aj±cy w danej chwili program nazywany
      jest <firstterm>procesem</firstterm>. Po wydaniu dowolnego
      polecenia uruchamiany jest przynajmniej jeden proces. S± równie¿
      procesy systemowe, które dzia³aj± nieprzerwanie, zapewniaj±c
      prawid³owe funkcjonowanie systemu.</para>

    <para>Ka¿demu procesowi przypisany jest jednoznaczny numer zwany
      <firstterm>identyfikatorem procesu</firstterm>, lub po prostu
      <firstterm>PID</firstterm>. Podobnie jak plik, równie¿ ka¿dy
      proces ma swojego w³a¶ciciela i grupê. Na podstawie informacji
      o w³a¶cicielu i grupie system operacyjny przydziela procesowi
      prawa do otwierania plików i urz±dzeñ, przy zastosowaniu opisanych
      wcze¶niej praw dostêpu. Wiêkszo¶æ procesów ma swój proces macierzysty;
      jest to proces, który uruchomi³ dany proces. Przyk³adowo, kiedy wydajemy
      polecenia w pow³oce, to zarówno pow³oka jest procesem, jak i ka¿de
      z wykonanych poleceñ. Procesem macierzystym ka¿dego uruchomionego
      w ten sposób procesu bêdzie pow³oka. Wyj±tkiem jest specjalny proces
      zwany &man.init.8;. <command>init</command> jest pierwszym procesem,
      wiêc jego PID jest zawsze równy 1. Proces <command>init</command>
      uruchamiany jest przez j±dro systemu podczas ³adowania FreeBSD.</para>

    <para>S± dwa bardzo przydatne polecenia, które pozwalaj± zobaczyæ,
      jakie procesy s± uruchomione: &man.ps.1; i &man.top.1;. Polecenie
      <command>ps</command> pokazuje statyczn± listê dzia³aj±cych w danej
      chwili procesów, uwzglêdniaj±c informacje takie jak PID-y procesów,
      zu¿ywan± pamiêæ, wydane do uruchomienia procesów polecenia, itd.
      Polecenie <command>top</command> wy¶wietla listê uruchomionych
      procesów, która jest co kilka sekund uaktualniana, dziêki czemu mo¿emy
      na bie¿±co ¶ledziæ, czym zajmuje siê komputer.</para>

    <para>Domy¶lnie <command>ps</command> pokazuje tylko dzia³aj±ce procesy
      nale¿±ce do u¿ytkownika wydaj±cego polecenie. Na przyk³ad:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Jak widzimy, &man.ps.1; wy¶wietla informacje w kilku kolumnach.
      W kolumnie <literal>PID</literal> pokazywany jest omówiony wcze¶niej
      identyfikator procesu. PID-y s± przydzielane po kolei od 1 do 99999
      i znów od pocz±tku, gdy siê skoñcz±. Kolumna <literal>TT</literal>
      pokazuje terminal, na którym dzia³a program &mdash; na razie nie bêdziemy
      siê tym zajmowaæ. W kolumnie <literal>STAT</literal> przedstawiony jest
      stan procesu, jego tak¿e na razie nie bêdziemy omawiaæ. <literal>TIME</literal>
      pokazuje czas wykorzystywania procesora przez dany proces, niekoniecznie
      odpowiada on czasowi, jaki up³yn±³ od uruchomienia programu, poniewa¿ wiele
      programów przez d³ugi czas oczekuje na jakie¶ zdarzenie, a dopiero potem
      wykorzystuje procesor. Ostatnia kolumna, <literal>COMMAND</literal>, pokazuje
      polecenie, którym uruchomiony zosta³ program.</para>

    <para>&man.ps.1; ma wiele rozmaitych opcji, które maj± wp³yw na wy¶wietlane
      informacje. Jedn± z najbardziej przydatnych kombinacji opcji jest
      <literal>auxww</literal>. Opcja a pokazuje informacje o wszystkich
      dzia³aj±cych procesach, równie¿ nie nale¿±cych do nas. <option>u</option>
      pokazuje nazwê u¿ytkownika, do którego nale¿y proces, jak równie¿ wykorzystanie pamiêci.
      <option>x</option> pokazuje informacje o procesach &mdash; demonach.
      Opcja <option>ww</option> nakazuje, by polecenie &man.ps.1; wy¶wietla³o
      pe³n± liniê polecenia, nie obcinaj±c jej, by zmie¶ci³a siê na ekranie.</para>

    <para>Informacje pokazywane przez &man.top.1; wygl±daj± podobnie. Oto przyk³ad:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Informacje podzielone s± na dwie czê¶ci. Nag³ówek (pierwsze piêæ
      wierszy) zawiera PID ostatnio uruchomionego procesu, ¶rednie obci±¿enie
      systemu (miara zapracowania systemu), czas dzia³ania systemu (od ostatniego
      uruchomienia) oraz aktualny czas. Inne liczby w nag³ówku informuj± o liczbie
      dzia³aj±cych procesów (w przyk³adzie 47), jak du¿o pamiêci i przestrzeni
      wymiany jest zajête, oraz ile czasu system przebywa w ró¿nych stanach
      procesora.</para>

    <para>Pod nag³ówkiem w kilku kolumnach pokazane s± informacje zbli¿one
      do przedstawianych przez &man.ps.1;. Podobnie mo¿na tu znale¼æ PID
      procesu, nazwê u¿ytkownika, czas zajmowania procesora, oraz polecenie,
      którym uruchomiono proces. &man.top.1; pokazuje domy¶lnie tak¿e rozmiar
      pamiêci zajmowanej przez proces. Ta ostatnia informacja podzielona jest
      na dwie kolumny; jedna odpowiada ca³kowitemu rozmiarowi, druga rozmiarowi
      rezydentnemu. Ca³kowity rozmiar oznacza, ile pamiêci by³o potrzebne programowi,
      z kolei rozmiar rezydentny informuje, ile pamiêci wykorzystuje program w danej
      chwili. W przyk³adzie widaæ, ¿e <application>&netscape;</application>
      potrzebowa³ prawie 30&nbsp;MB pamiêci RAM, jednak obecnie wykorzystuje tylko
      9&nbsp;MB.</para>

    <para>&man.top.1; automatycznie aktualizuje wy¶wietlane informacje co dwie
      sekundy; mo¿na to zmieniæ opcj± <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Demony, sygna³y i unicestwianie procesów</title>

    <para>Kiedy korzystamy z edytora tekstu, mo¿emy go w prosty sposób
      obs³ugiwaæ, wczytywaæ pliki, itp. Jest to mo¿liwe dziêki cechom
      samego edytora oraz dziêki temu, ¿e edytor jest pod³±czony do
      <firstterm>terminala</firstterm>. Jednak¿e, niektóre programy
      pracuj± bez ci±g³ej komunikacji z u¿ytkownikiem, s± wiêc od³±czone
      od terminala. Przyk³adem takiego programu mo¿e byæ serwer WWW,
      nieustannie odpowiadaj±cy na ¿±dania pochodz±ce z sieci, bez potrzeby
      komunikacji z u¿ytkownikiem. Inny przyk³ad to programy przesy³aj±ce
      emaile pomiêdzy komputerami.</para>

    <para>Takie programy nazywane s± <firstterm>demonami</firstterm> (ang. daemons).
      Demony to postaci z mitologii greckiej &mdash; niewielkie us³u¿ne istoty,
      ani dobre, ani z³e, które w rozmaity sposób pomaga³y ludziom. Podobnie
      pomagaj± dzisiejsze serwery pocztowe i serwery WWW. Dlatego w³a¶nie od
      d³ugiego czasu maskotk± BSD jest weso³y demon z wid³ami i w</para>

    <para>Przyjêto, i¿ programy uruchamiane jako demony maj± nazwy zakoñczone
      liter± <quote>d</quote>. <application>BIND</application> (Berkeley Internet
      Name Daemon) jest serwerem nazw uruchamianym przez program
      <command>named</command>, serwer WWW <application>Apache</application>
      nosi nazwê <command>httpd</command>, demon kolejkowania drukarki (line printer
      spooling daemon) to <command>lpd</command>, itd. Nie jest to sztywna regu³a,
      lecz przyjêta konwencja; na przyk³ad g³ówny demon pocztowy programu
      <application>Sendmail</application> nazywa siê <command>sendmail</command>,
      a nie jak mo¿na by przypuszczaæ <command>maild</command>.</para>

    <para>Niekiedy istnieje potrzeba komunikacji z procesem &mdash; demonem.
      Odbywa siê ona poprzez <firstterm>sygna³y</firstterm>, to znaczy mo¿emy
      porozumieæ siê z demonem (lub jakimkolwiek dzia³aj±cym procesem) wysy³aj±c
      mu sygna³. S± ró¿ne rodzaje sygna³ów, które mo¿emy wys³aæ &mdash; niektóre
      z nich maj± okre¶lone znaczenie, inne s± odpowiednio interpretowane przez
      aplikacjê, co powinno byæ opisane w dokumentacji aplikacji. Sygna³ mo¿emy
      wys³aæ tylko do procesu, którego jeste¶my w³a¶cicielem. Wys³anie sygna³u
      do procesu nale¿±cego do kogo¶ innego za po¶rednictwem &man.kill.1; lub
      &man.kill.2; spowoduje odmowê dostêpu. Wyj±tkiem jest u¿ytkownik
      <username>root</username>, który mo¿e wysy³aæ sygna³y do dowolnego
      procesu, niezale¿nie od jego w³a¶ciciela.</para>

    <para>Zdarza siê, ¿e samo FreeBSD równie¿ wysy³a aplikacjom sygna³y.
      Je¿eli niew³a¶ciwie napisany program próbuje dostaæ siê do niedostêpnego
      dla niego obszaru pamiêci, FreeBSD wysy³a procesowi sygna³ <firstterm>Segmentation
        Violation</firstterm> (<literal>SIGSEGV</literal>). Aplikacja mo¿e skorzystaæ
      z funkcji systemowej &man.alarm.3;, wówczas po up³yniêciu pewnego czasu
      zostanie do niej wys³any sygna³ Alarm (<literal>SIGALRM</literal>).
      I tak dalej.</para>

    <para>Do zatrzymania procesu mo¿na wykorzystaæ dwa sygna³y: <literal>SIGTERM</literal>
      i <literal>SIGKILL</literal>. Pierwszy z nich jest ³agodnym sposobem
      unicestwienia procesu; proces mo¿e <emphasis>przechwyciæ</emphasis>
      ten sygna³, nastêpnie zakoñczyæ swoj± pracê, np. zamykaj±c pliki,
      które otworzy³. Czasami proces mo¿e zignorowaæ sygna³ <literal>SIGTERM</literal>,
      je¶li akurat zajmuje siê czym¶, co nie powinno byæ przerywane.</para>

    <para>Sygna³ <literal>SIGKILL</literal> nie mo¿e zostaæ zignorowany.
      Dzia³a wed³ug zasady <quote>Nie obchodzi mnie, co robisz, w tej
      chwili przestañ</quote>. Wys³anie procesowi sygna³u <literal>SIGKILL</literal>
      powoduje, i¿ FreeBSD natychmiast go wstrzymuje<footnote>
        <para>Nie do koñca jest to prawd± &mdash; w kilku przypadkach nie
          mo¿na przerwaæ procesu. Na przyk³ad gdy proces stara siê przeczytaæ
          plik znajduj±cy siê na innym komputerze w sieci, a ów inny komputer
          z jakiego¶ powodu bêdzie niedostêpny (na skutek awarii sieci,
          lub po prostu zostanie wy³±czony), to proces stanie siê
          <quote>nieprzerywalny</quote>. Po chwili (zwykle po dwóch
          minutach) proces przekroczy czas oczekiwania, wówczas
          zostanie unicestwiony.</para>
      </footnote>.</para>

    <para>Inne u¿yteczne sygna³y to
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> i
      <literal>SIGUSR2</literal>. S± to sygna³y ogólnego przeznaczenia,
      ró¿ne aplikacje reaguj± na nie w ró¿ny sposób.</para>

    <para>Powiedzmy, ¿e dokonali¶my zmiany w pliku konfiguracji
      serwera WWW, i chcemy nakazaæ serwerowi, aby konfiguracja zosta³a
      ponownie wczytana. Mogliby¶my zatrzymaæ i ponownie uruchomiæ
      <command>httpd</command>, ale ubocznym efektem takiego postêpowania
      by³aby chwilowa przerwa w pracy serwera, co jest raczej niepo¿±dane.
      Wiêkszo¶æ demonów dzia³a w taki sposób, i¿ po otrzymaniu sygna³u
      <literal>SIGHUP</literal> dokonuj± ponownego przeczytania swojego
      pliku konfiguracyjnego. Dziêki temu zamiast unicestwiania i ponownego
      uruchamiania <command>httpd</command> mo¿emy wys³aæ mu sygna³
      <literal>SIGHUP</literal>. Nie jest jednoznacznie okre¶lone,
      jak procesy reaguj± na sygna³ <literal>SIGHUP</literal>, dlatego
      ró¿ne demony mog± zachowywaæ siê w ró¿ny sposób &mdash; w razie
      niepewno¶ci warto zapoznaæ siê z dokumentacj± konkretnego demona.</para>
    
    <para>Sygna³y wysy³ane s± przy u¿yciu polecenia &man.kill.1;, jak
      w poni¿szym przyk³adzie.</para>

    <procedure>
      <title>Wysy³anie sygna³u do procesu</title>

      <para>W tym przyk³adzie zaprezentowano wysy³anie sygna³u do &man.inetd.8;.
        Plik konfiguracyjny dla <command>inetd</command> to
        <filename>/etc/inetd.conf</filename>. Wys³anie sygna³u
        <literal>SIGHUP</literal> spowoduje ponowne przeczytanie tego pliku.</para>

      <step>
        <para>Trzeba ustaliæ PID procesu, do którego wysy³aæ bêdziemy sygna³
          &mdash; do tego celu pos³u¿± polecenia &man.ps.1; i &man.grep.1;.
          Polecenia &man.grep.1; u¿ywamy do odnalezienia podanego ci±gu
          znaków. Poniewa¿ polecenia wydajemy jako zwyk³y u¿ytkownik,
          a &man.inetd.8; dzia³a jako <username>root</username>, polecenie
          &man.ps.1; musimy wywo³aæ z opcj± <option>ax</option>.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Jak widaæ, &man.inetd.8; ma PID o warto¶ci 198. Niekiedy w
          przedstawionym powy¿ej przyk³adzie mo¿e siê tak¿e pojawiæ proces
          <literal>grep inetd</literal>, wynika to ze sposobu, w jaki
          &man.ps.1; odnajduje dzia³aj±ce procesy.</para>
      </step>

      <step>
        <para>Sygna³ wysy³amy przy pomocy polecenia &man.kill.1;.
          Najpierw skorzystamy jednak z polecenia &man.su.1; by staæ siê
          rootem, gdy¿ &man.inetd.8; dzia³a jako
          <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Podobnie jak wiele poleceñ w systemach &unix;, &man.kill.1;
          nie wy¶wietla ¿adnego komunikatu w przypadku powodzenia. Je¿eli
          natomiast sygna³ zosta³ wys³any do procesu, którego nie jest siê
          w³a¶cicielem, pojawi siê informacja: <errorname>kill:
            <replaceable>PID</replaceable>: Operation not
	    permitted</errorname> (niedozwolona operacja). B³êdne wpisanie
          PID-u spowoduje albo wys³anie sygna³u do niew³a¶ciwego procesu,
          co mo¿e skoñczyæ siê ¼le, albo te¿ wys³anie sygna³u do PID-u,
          który nie jest w danej chwili wykorzystywany &mdash; pojawi siê
          wówczas komunikat <errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>
          (nie ma takiego procesu).</para>

	<note>
          <title>Dlaczego warto korzystaæ z <command>/bin/kill</command>?</title>

          <para>W wielu pow³okach polecenie <command>kill</command> jest wbudowane;
            oznacza to, ¿e sama pow³oka zajmuje siê wysy³aniem sygna³u, nie
            wywo³uj±c <filename>/bin/kill</filename>. Mo¿e to byæ u¿yteczne,
            jednak¿e w ró¿nych pow³okach stosowana jest ró¿na sk³adnia do
            okre¶lenia nazwy sygna³u, który ma byæ wys³any. Zamiast wiêc
            zapamiêtywania wszystkich mo¿liwych sk³adni, ³atwiej jest po
            prostu korzystaæ z polecenia
            <command>/bin/kill <replaceable>...</replaceable></command></para>
	</note>
      </step>
    </procedure>

    <para>Inne sygna³y wysy³a siê t± sam± metod±, wystarczy zast±piæ
      <literal>TERM</literal> lub <literal>KILL</literal> w odpowiedni
      sposób.</para>

    <important>
      <para> Unicestwianie losowo wybranego procesu jest raczej z³ym pomys³em.
        Szczególne znaczenie ma &man.init.8;, proces o PID równym 1.
        Wydanie polecenia <command>/bin/kill -s KILL 1</command> jest szybk±
        metod± wy³±czenia systemu. Nale¿y zawsze sprawdzaæ poprawno¶æ
        argumentów polecenia &man.kill.1;  przed naci¶niêciem klawisza
        <keycap>Return</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Pow³oki</title>
    <indexterm><primary>pow³oki</primary></indexterm>
    <indexterm><primary>linia poleceñ</primary></indexterm>

    <para>W codziennej pracy z FreeBSD bardzo czêsto wykorzystywany jest
      interfejs linii poleceñ, zwany pow³ok± (ang. shell). Podstawowym
      zadaniem pow³oki jest przyjmowanie poleceñ i wykonywanie ich.
      Wiele pow³ok wyposa¿onych jest tak¿e w dodatkowe funkcje u³atwiaj±ce
      pracê, np. usprawnienia zarz±dzania plikami, dopasowywanie nazw plików,
      u³atwienia korzystania z linii poleceñ, makropolecenia i zmienne ¶rodowiskowe.
      We FreeBSD dostêpnych jest kilka pow³ok, np. Bourne Shell <command>sh</command>
      i ulepszony C-shell <command>tcsh</command>. Wiele innych pow³ok, jak choæby
      <command>zsh</command> czy <command>bash</command>, mo¿na znale¼æ w kolekcji
      portów FreeBSD.</para>

    <para>Której z pow³ok najlepiej jest u¿ywaæ? To w³a¶ciwie kwestia gustu.
      Dla programistów C najwygodniejsze mog± byæ pow³oki o sk³adni wzorowanej
      na jêzyku C, np. <command>tcsh</command>. U¿ytkownikom Linuksa i tym,
      dla których interfejs linii poleceñ systemów 8unix; jest nowo¶ci±, mo¿na
      poleciæ <command>bash</command>. Do wyboru jest wiele pow³ok, ka¿da z nich
      ma pewne charakterystyczne tylko dla niej w³a¶ciwo¶ci, które niekoniecznie
      bêd± dzia³aæ w ka¿dych warunkach.</para>

    <para>Czêsto spotykanym udogodnieniem pow³oki jest uzupe³nianie nazw plików.
      Po wpisaniu kilku pierwszych liter polecenia lub nazwy pliku pow³oka potrafi
      zwykle uzupe³niæ dalszy ci±g polecenia lub nazwy, dzieje siê to po wci¶niêciu
      klawisza <keycap>Tab</keycap>. Przyjmijmy przyk³adowo, ¿e istniej± dwa pliki
      o nazwach <filename>foobar</filename> i <filename>foo.bar</filename>.
      Chcemy usun±æ plik <filename>foo.bar</filename>. Mo¿emy wiêc wydaæ polecenie:
      <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>Pow³oka wy¶wietli: <command>rm foo[BIIP].bar</command>.</para>

    <para>Napis [BIIP] oznacza sygna³ d¼wiêkowy, bêd±cy informacj± od pow³oki,
      ¿e uzupe³nienie nazwy pliku nie by³o mo¿liwe, poniewa¿ mo¿na dopasowaæ
      wiêcej ni¿ jedn± nazwê. Zarówno <filename>foobar</filename> jak i
      <filename>foo.bar</filename>zaczynaj± siê od <literal>fo</literal>.
      Pow³oka mog³a jednak¿e uzupe³niæ pocz±tek, czyli <literal>foo</literal>.
      Teraz mo¿na wpisaæ kropkê <literal>.</literal> i ponownie wcisn±æ
      <keycap>Tab</keycap>, tym razem pow³oka uzupe³ni nazwê do koñca.</para>
    <indexterm><primary>zmienne ¶rodowiskowe</primary></indexterm>

    <para>Inn± cech± pow³oki s± zmienne ¶rodowiskowe. Przechowywane s± one
      w przestrzeni ¶rodowiska pow³oki w postaci par <quote>nazwa =
        warto¶æ</quote>. Przestrzeñ ¶rodowiska jest widoczna dla ka¿dego
      programu uruchamianego przez pow³okê, dlatego te¿ przechowuje siê tam
      wiele parametrów konfiguracyjnych dla programów. Oto najczê¶ciej
      spotykane zmienne ¶rodowiskowe wraz z krótkim opisem:</para>
    <indexterm><primary>zmienne ¶rodowiskowe</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Zmienna</entry>
	    <entry>Opis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
            <entry>Nazwa aktualnie zalogowanego u¿ytkownika.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
            <entry>Lista katalogów zawieraj±cych pliki wykonywalne
              oddzielona przecinkami.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
            <entry>Nazwa ekranu X11, je¶li takowy jest dostêpny.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
            <entry>Wykorzystywana pow³oka.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
            <entry>Nazwa terminala u¿ytkownika, wykorzystywana do
              okre¶lenia w³a¶ciwo¶ci terminala.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
            <entry>Zapis z bazy termcap zawieraj±cy sekwencje kodów
              odpowiadaj±cych ró¿nym funkcjom terminala.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
            <entry>Typ systemu operacyjnego, np. FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
            <entry>Architektura sprzêtowa, na jakiej dzia³a system.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
            <entry>Preferowany przez u¿ytkownika edytor tekstu.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
            <entry>Preferowany przez u¿ytkownika program wy¶wietlaj±cy
              pliki tekstowe.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
            <entry>Lista katalogów zawieraj±cych dokumentacjê systemow±
              oddzielona przecinkami.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Sposób odczytywania i ustawiania zmiennych ¶rodowiskowych
      zale¿y od rodzaju u¿ywanej pow³oki. Na przyk³ad w pow³okach
      wzorowanych na C, jak <command>tcsh</command> i <command>csh</command>,
      do ustawiania i przegl±dania zmiennych ¶rodowiskowych s³u¿y polecenie
      <command>setenv</command>, natomiast w pow³okach Bourne'a, czyli
      <command>sh</command> i <command>bash</command>, do tych celów
      wykorzystywane jest polecenie <command>export</command>. Przyk³adowo,
      aby zmieniæ zmienn± ¶rodowiskow± <envar>EDITOR</envar> na
      <filename>/usr/local/bin/emacs</filename> w pow³oce <command>csh</command>
      lub <command>tcsh</command>, nale¿y wydaæ polecenie:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>A w pow³okach Bourne'a:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>W wiêkszo¶ci pow³ok mo¿na wy¶wietliæ warto¶æ zmiennej
      ¶rodowiskowej przez poprzedzenie jej nazwy znakiem <literal>$</literal>.
      Dla przyk³adu, polecenie <command>echo $TERM</command> poka¿e warto¶æ
      zmiennej <envar>$TERM</envar>, poniewa¿ pow³oka zastêpuje wyra¿enie
      <envar>$TERM</envar> warto¶ci± zmiennej i przekazuje j± do
      <command>echo</command>.</para>

    <para>Wiele znaków, zwanych meta-znakami, traktowanych jest przez
      pow³oki w specjalny sposób. Najczê¶ciej wykorzystywanym jest
      <literal>*</literal>, oznaczaj±cy dowolny ci±g znaków w nazwie pliku,
      umo¿liwiaj±cy wykonywanie operacji na wielu plikach. Przyk³adowo,
      wywo³anie <command>echo *</command> jest prawie identyczne z wywo³aniem
      <command>ls</command>, poniewa¿ pow³oka przekazuje do <command>echo</command>
      nazwy wszystkich plików pasuj±cych <literal>*</literal>.</para>

    <para>Je¶li potrzeba, by pow³oka nie interpretowa³a znaku jako znak
      specjalny, nale¿y go poprzedziæ znakiem uko¶nika (<literal>\</literal>).
      Wywo³anie <command>echo $TERM</command> powoduje wypisanie ustawionego
      typu terminala, podczas gdy efektem polecenia <command>echo \$TERM</command>
      jest po prostu napis <envar>$TERM</envar>.</para>

    <sect2 id="changing-shells">
      <title>Zmiana pow³oki</title>

      <para>Naj³atwiej jest zmieniæ pow³okê przy u¿yciu polecenia <command>chsh</command>.
        Wywo³anie tego polecenia uruchomi edytor wskazany przez zmienn±
        <envar>EDITOR</envar>, lub edytor <command>vi</command>, je¶li nie jest ona
        zdefiniowana. Nastêpnie nale¿y zmieniæ nazwê pow³oki w wierszu
        <quote>Shell:</quote>.</para>

      <para>Mo¿na te¿ skorzystaæ z <command>chsh</command> z opcj± <option>-s</option>,
        która automatycznie zmieni pow³okê, bez uruchamiania edytora. Poni¿ej
        przedstawiono wywo³anie zmieniaj±ce pow³okê na <command>bash</command>:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
        <para>Wybrana pow³oka <emphasis>musi</emphasis> byæ wymieniona w pliku
          <filename>/etc/shells</filename>. Je¶li pow³okê zainstalowano z
          <link linkend="ports">kolekcji portów</link> powinna zostaæ dopisana
          automatycznie. Je¶li natomiast przeprowadzono rêczn± instalacjê
          pow³oki, trzeba to zrobiæ samemu.</para>
     
      <para>Dla przyk³adu, je¶li pow³oka <command>bash</command> zosta³a zainstalowana
        i umieszczona w <filename>/usr/local/bin</filename>, trzeba bêdzie wydaæ
        polecenie:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Oraz uruchomiæ <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Aleksander</firstname>
          <surname>Fafu³a</surname>
          <contrib>T³umaczy³ </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Edytory tekstu</title>
    <indexterm><primary>edytory tekstu</primary></indexterm>
    <indexterm><primary>edytory</primary></indexterm>

    <para>Konfiguracja FreeBSD polega g³ównie na edytowaniu plików
      tekstowych. Z tego w³a¶nie powodu, dobrze by³oby zapoznaæ
      siê z edytorami tekstu. FreeBSD posiada ich kilka, a kolejne
      mo¿na doinstalowaæ z drzewa portów.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>edytory</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>Naj³atwiejszym do nauki i w u¿yciu jest edytor
      <application>ee</application>, co jest skrótem od Easy Editor
      (ang. £atwy Edytor). Aby uruchomiæ <application>ee</application>,
      nale¿y u¿yæ polecenia <command>ee <replaceable>plik</replaceable></command>,
      gdzie <replaceable>plik</replaceable> jest to, co chcemy edytowaæ.
      Na przyk³ad, aby wyedytowaæ plik <filename>/etc/rc.conf</filename>,
      napiszemy <command>ee /etc/rc.conf</command>. Gdy ju¿ jeste¶my w
      <command>ee</command>, mo¿emy zauwa¿yæ, ¿e wszystkie niezbêdne
      komendy s± wypisane u góry ekranu. Znak <literal>^</literal> oznacza
      wci¶niêty klawisz <keycap>Ctrl</keycap>. Innymi s³owy <literal>^e</literal>
      oznacza, ¿e nale¿y trzymaæ <keycap>Ctrl</keycap> i wcisn±æ klawisz
      <keycap>e</keycap>. Aby wyj¶æ z <application>ee</application>, wci¶nij
      <keycap>Esc</keycap>, nastêpnie wybierz leave editor (opu¶æ edytor).
      Edytor zapyta, czy zachowaæ zmiany, je¶li plik zosta³ zmodyfikowany.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>edytory</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>edytory</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD w swoich zasobach ma tak¿e potê¿ny edytor tekstu, jakim jest
      <application>vi</application>. W kolekcji portów dostêpny jest tak¿e
      <application>Emacs</application>, czy <application>vim</application>
      (<filename role="package">editors/emacs</filename> i
      <filename role="package">editors/vim</filename>). Edytory te oferuj±
      du¿o wiêksz± funkcjonalno¶æ, ale oczekuj± w zamian wiêkszego obeznania
      u¿ytkownika z zasadami ich dzia³ania, ponadto ich obs³uga jest trudniejsza
      do nauki. Jednak¿e, je¶li planujesz edytowaæ wiele tekstu, nauka
      <application>Emacs</application> lub <application>vim</application> zwróci
      siê w d³ugim okresie w postaci zaoszczêdzonego czasu.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Urz±dzenia i pliki urz±dzeñ</title>

    <para>Mianem urz±dzeñ okre¶la siê komponenty komputera, takie jak dysk,
      drukarka, karta graficzna czy klawiatura. Podczas ³adowania systemu
      FreeBSD wiêkszo¶æ wy¶wietlanych komunikatów dotyczy wykrywanych urz±dzeñ.
      Komunikaty startowe dostêpne s± do pó¼niejszego przegl±dania w pliku
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Przyk³adowo, <devicename>acd0</devicename> odpowiada pierwszemu
      napêdowi CDROM IDE, natomiast <devicename>kbd0</devicename> oznacza
      klawiaturê.</para>

    <para>Dostêp do wiêkszo¶ci urz±dzeñ w systemie operacyjnym &unix;
      odbywa siê poprzez specjalne pliki, zwane plikami urz±dzeñ,
      znajduj±ce siê w katalogu <filename>/dev</filename>.</para>

    <sect2>
      <title>Tworzenie plików urz±dzeñ</title>
      <para>Kiedy wyposa¿amy komputer w nowe urz±dzenie, lub kompilujemy
        j±dro z obs³ug± dodatkowych urz±dzeñ, konieczne mo¿e okazaæ siê
        utworzenie nowych plików urz±dzeñ.</para>

      <sect3>
        <title><literal>DEVFS</literal> (DEVice File System)</title>

        <para>System plików urz±dzeñ, zwany <literal>DEVFS</literal>,
          udostêpnia przestrzeñ nazw urz±dzeñ j±dra jako czê¶æ przestrzeni
          nazw g³ównego systemu plików. <literal>DEVFS</literal> zajmuje siê
          obs³ug± systemu plików urz±dzeñ, dziêki czemu nie trzeba samodzielnie
          tworzyæ b±d¼ modyfikowaæ plików urz±dzeñ.</para>

        <para>Wiêcej informacji znale¼æ mo¿na w dokumentacji systemowej &man.devfs.5;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Cezary</firstname>
          <surname>Morga</surname>
          <contrib>T³umaczy³ </contrib>
        </author>
      </authorgroup>
    </sect1info>
    
    <title>Formaty binarne</title>

    <para>By zrozumieæ czemu FreeBSD u¿ywa formatu &man.elf.5;, musimy wpierw
      poznaæ trzy obecnie <quote>dominujace</quote> formaty plików wykonywalnych
      w systemach &unix;:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>Najstarszy i najbardziej <quote>klasyczny</quote> format w Uniksie.
          Wykorzystuje krótki nag³ówek z magicznym numerem na samym pocz±tku,
          czêsto wykorzystywanym do okre¶lenia rodzaju pliku (szczegó³owy opis
          dostêpny jest w &man.a.out.5;). Na plik sk³adaj± siê trzy segmenty:
          .text, .data i .bss oraz tablice symboli i ci±gów tekstowych.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Format obiektowy pochodz±cy z SVR3. W tym formacie sekcja tablic
          w wchodzi ju¿ w sk³ad nag³ówka, tak wiêc mo¿liwe jest zawarcie w pliku
          wiêcej sekcji ni¿ tylko .text, .data i .bss.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Nastêpca <acronym>COFF</acronym> zawieraj±cy wiele dodatkowych
          sekcji o 32- b±d¼ nawet 64-bitowych warto¶ciach. Jednym, acz wielkim
          minusem jest fakt, i¿ przy projektowaniu formatu <acronym>ELF</acronym>
          równie¿ za³o¿ono, ¿e na ka¿d± architekturê sprzêtow± bêdzie istnia³
          tylko jeden interfejs ABI. Okaza³o siê natomiast, i¿ takie za³o¿enie
          jest b³êdne nawet w ¶wiecie komercyjnych SYSV (z którego pochodz±
          przynajmniej trzy ABI: SVR4, Solaris i SCO).</para>

        <para>Sposobem na rozwi±zanie tego problemu we FreeBSD s± narzêdzia
          do <emphasis>metkowania</emphasis> plików wykonywalnych
          <acronym>ELF</acronym> informacjami, z którymi ABI jest on zgodny.
          Wiêcej informacji dostêpnych jest w podrêczniku systemowym
          &man.brandelf.1;.</para>
      </listitem>
    </itemizedlist>

    <para>System FreeBSD pochodzi z <quote>klasycznego</quote> obozu.
      Wykorzystywa³ on zatem format &man.a.out.5; &mdash; technologiê
      wypróbowan± w wielu pokoleniach systemów BSD i z powodzeniem
      stosowan± a¿ do ga³êzi 3.X. Mimo, ¿e skompilowanie i uruchomienie
      w sposób natywny plików binarnych <acronym>ELF</acronym> (a tak¿e
      j±dra) by³o mo¿liwe we FreeBSD ju¿ od pewnego czasu, Projekt
      oficjalnie opiera³ siê przed migracj± do formatu <acronym>ELF</acronym>
      jako podstawowego. Dlaczego? Otó¿, gdy obóz linuksowy wykona³ ten
      bolesny krok ku <acronym>ELF</acronym> nie uda³o siê tak ³atwo uciec
      od formatu <filename>a.out</filename>. Wynika³o to przede wszystkim
      z faktu, i¿ niezbyt elastyczny plan migracji bazowa³ na mechanizmie
      wspó³dzielonych bibliotek, których modyfikacja nastrêcza³a wielu
      trudno¶ci zarówno producentom sprzêtu jak i projektantom. Dopiero od
      momentu gdy narzêdzia dostêpne dla <acronym>ELF</acronym> zaoferowa³y
      sposób rozwi±zania problemu ze wspó³dzielonymi bibliotekami, zaczê³y
      byæ postrzegane ogólnie jako <quote>droga do przodu</quote>, a tym
      samym koszty migracji mog³y zostaæ uznane za niezbêdne do poniesienia.
      Mechanizm wspó³dzielonych bibliotek FreeBSD w du¿ej mierze przypomina
      mechanizm z &sunos; Sun'a i jako taki jest bardzo ³atwy w u¿yciu.</para>

    <para>Sk±d wiêc tyle ró¿nych formatów?</para>

    <para>W zamierzch³ych czasach do dyspozycji by³ prosty sprzêt komputerowy.
      Ów prosty sprzêt obs³ugiwa³ ma³y, prosty system. St±d te¿ format
      <filename>a.out</filename>by³ ca³kowicie odpowiednim do prezentacji
      plików binarnych w tym prostym systemie (PDP-11). Gdy &unix; zosta³
      przeniesiony z tego prostego systemu na platformy typu Motorola 68k czy
      VAXen, zachowany zosta³ format <filename>a.out</filename>, zdecydowanie
      wystarcz±jacy dla wczesnych wersji Uniksa.</para>

    <para>Pewien czas pó¼niej, jaki¶ bystry in¿ynier sprzêtowy stwierdzi³
      ¿e gdyby potrafi³ zmusiæ oprogramowanie do robienia kilku obskurnych
      sztuczek, wówczas móg³by pozbyæ siê kilku bramek z uk³adu scalonego
      i zmusiæ CPU do szybszej pracy. Pomimo, ¿e format <filename>a.out</filename>
      potrafi³ wspó³pracowaæ z tym nowym rodzajem sprzêtu (zwanego wówczas
      <acronym>RISC</acronym>) to mimo wszystko nie by³ najlepszym do tego
      formatem. Dlatego te¿ rozpoczêto prace nad innymi formatami binarnymi,
      które mia³y osi±gn±æ lepsze wyniki ni¿ ograniczony, prosty <filename>a.out</filename>
      móg³ zaoferowaæ. Stworzone zosta³y <acronym>COFF</acronym>,
      <acronym>ECOFF</acronym> oraz kilka mniej znanych formatów, nim powsta³
      <acronym>ELF</acronym>.</para>

    <para>Kolejnym problemem okaza³ siê wzrost rozmiarów programów przy
      wzglêdnie ma³ej pojemno¶ci dysków oraz pamiêci fizycznych, a tak¿e
      zwiêkszeniu stopnia skomplikowania pamiêci wirtualnej VM. Tak te¿
      narodzi³a siê koncepcja wspó³dzielonych bibliotek. Mimo, ¿e ów postêp
      osi±gniêty by³ przy pomocy formatu <filename>a.out</filename> zakres
      jego przydatno¶ci by³ stale rozci±gany, wraz z ka¿d± now± funkcj±.
      Pojawi³a siê konieczno¶æ dynamicznego wczytywanie pewnych rzeczy ju¿
      w trakcie uruchamiania programu czy zapisywania czê¶ci programu zaraz
      po wykonaniu kodu init w pamiêci lub przestrzeni wymiany. Równie¿ jêzyki
      programowania stawa³y siê coraz bardziej wyrafinowane. Wiele poprawek
      wprowadzonych do formatu <filename>a.out</filename> umo¿liwia³y realizacjê
      kolejnych funkcji, przy czym z regu³y dzia³a³y one tylko przez pewien czas.
      Niestety, format a.out sta³ siê z czasem niezdolny do rozwi±zywania wszystkich
      problemów bez wci±¿ rozrastaj±cego siê narzutu w kodzie i poziomu skomplikowania.
      Mimo, ¿e <acronym>ELF</acronym> potrafi³ rozwi±zaæ wiele z ówczesnych problemów,
      zmiana formatu binarnego, który generalnie dzia³a³, wci±¿ by³a wielk± uci±¿liwo¶ci±.
      Dlatego te¿ <acronym>ELF</acronym> musia³ poczekaæ a¿ bardziej bolesnym okaza³o
      siê pozostanie przy <filename>a.out</filename> ni¿ przej¶cie
      do <acronym>ELF</acronym>.</para>

    <para>Wraz z up³ywem czasu, narzêdzia kompilacyjne, z których FreeBSD wywodzi
      w³asne narzêdzia (przede wszystkim assembler i loader), wyewoluowa³y w dwa
      równoleg³e projekty. Odmiana FreeBSD da³a wspó³dzielone biblioteki oraz poprawki
      kilku b³êdów. Ludzie z GNU, którzy oryginalnie napisali te programy,
      przepisali je na nowo i dodali proste kompilatory wskro¶ne, pozwalaj±ce na
      pracê w ró¿nych formatach. Nowy pakiet narzêdzi GNU
      (<application>binutils</application>) wspiera kompilowanie wskro¶ne,
      format <acronym>ELF</acronym>, wspó³dzielone biblioteki, rozszerzenia
      C++, itp. Dodatkowo, wielu producentów sprzêtu przygotowuje binaria
      <acronym>ELF</acronym>. Jest to zatem dobra rzecz dla FreeBSD, ¿e
      je obs³uguje.</para>

    <para>Format <acronym>ELF</acronym> oferuje wiêksz± rozszerzalno¶æ niz
      <filename>a.out</filename>. Narzêdzia <acronym>ELF</acronym> s± lepiej
      przygotowywane i oferuj± kompilacjê wskro¶n±, co jest istotne dla wielu
      programistów. Co prawda <acronym>ELF</acronym> mo¿e byæ trochê wolniejszy
      ni¿ <filename>a.out</filename>, jednak¿e próba pomiaru mo¿e byæ trudna.
      Istnieje równie¿ wiele innych szczegó³ów ró¿nych dla obydwu formatów,
      m.in. sposób mapowania stron, obs³ugi kodu init itp. Co prawda,
      ¿adne z nich nie jest istotne, jednak¿e ró¿nice istniej±. Z czasem,
      wsparcie dla <filename>a.out</filename> zostanie wstrzymane z jadra
      <filename>GENERIC</filename> i ostatecznie usuniête z j±dra gdy tylko
      zniknie potrzeba obs³ugi programów <filename>a.out</filename>.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Wiêcej informacji</title>

    <sect2 id="basics-man">
      <title>Dokumentacja systemowa</title>
      <indexterm><primary>podrêcznik systemowy</primary></indexterm>

      <para>Najdok³adniejsz± dokumentacj± we FreeBSD jest dokumentacja
        systemowa. Dla prawie ka¿dego dostêpnego w systemie programu
        przygotowana jest krótka instrukcja obs³ugi, omawiaj±ca podstawy
        jego dzia³ania i rozmaite opcje. Dokumentacjê mo¿emy przegl±daæ
        przy pomocy polecenia <command>man</command>. Korzystanie z tego
        polecenia jest bardzo proste:</para>

      <screen>&prompt.user; <userinput>man <replaceable>polecenie</replaceable></userinput></screen>

      <para><literal>polecenie</literal> jest nazw± polecenia, o którym chcemy
        uzyskaæ informacje. Na przyk³ad, aby dowiedzieæ siê czego¶ na temat
        polecenia <command>ls</command> wpisujemy:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Dokumentacja systemowa podzielona jest na ponumerowane czê¶ci:</para>

      <orderedlist>
	<listitem>
          <para>Polecenia dostêpne dla u¿ytkowników.</para>
	</listitem>

	<listitem>
          <para>Funkcje systemowe i kody b³êdów.</para>
	</listitem>

	<listitem>
          <para>Funkcje z bibliotek jêzyka C.</para>
	</listitem>

	<listitem>
          <para>Sterowniki urz±dzeñ.</para>
	</listitem>

	<listitem>
          <para>Formaty plików.</para>
	</listitem>

	<listitem>
          <para>Gry i inne rozrywki.</para>
	</listitem>

	<listitem>
          <para>Ró¿ne informacje.</para>
	</listitem>

	<listitem>
          <para>Polecenia s³u¿±ce do zarz±dzania systemem.</para>
	</listitem>

	<listitem>
          <para>Informacje dla programistów j±dra.</para>
	</listitem>
      </orderedlist>

      <para>Niekiedy takie samo zagadnienie mo¿e pojawiæ siê w kilku
        czê¶ciach dokumentacji. Na przyk³ad istnieje polecenie
        <command>chmod</command>, oraz funkcja systemowa
        <function>chmod()</function>. W taki wypadku mo¿emy wybraæ
        interesuj±c± nas czê¶æ dokumentacji, podaj±c jej numer jako
        parametr polecenia <command>man</command>:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>W efekcie pokazana zostanie dokumentacja polecenia <command>chmod</command>.
        Zgodnie z przyjêt± konwencj±, numer odpowiedniej czê¶ci dokumentacji
        podawany jest w nawiasach, tak wiêc &man.chmod.1; odpowiada poleceniu
        <command>chmod</command>, natomiast &man.chmod.2; odpowiada funkcji
        systemowej.</para>

      <para>W opisany powy¿ej sposób mo¿emy dowiedzieæ siê, jak korzystaæ
        z danego polecenia, je¶li znamy jego nazwê. Co zrobiæ, je¶li nie
        mo¿emy sobie przypomnieæ nazwy polecenia? Otó¿, <command>man</command>
        potrafi równie¿ wyszukiwaæ wybranych s³ów kluczowych w opisach
        poleceñ, s³u¿y do tego opcja <option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Wpisanie takiego polecenia spowoduje wy¶wietlenie listy
        poleceñ, których opisy zawieraj± s³owo kluczowe <quote>mail</quote>.
        Takie dzia³anie jest równowa¿ne skorzystaniu z polecenia
        <command>apropos</command>.</para>

      <para>Je¶li wiêc, przegl±daj±c zawarto¶æ katalogu
        <filename>/usr/bin</filename>, zastanawiamy siê, do czego
        w³a¶ciwie s³u¿± znajduj±ce siê tam polecenia, mo¿emy wpisaæ:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>lub</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>W obu przypadkach efekt bêdzie taki sam.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>Pliki GNU Info</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>Do FreeBSD do³±czonych jest wiele programów i narzêdzi
        stworzonych przez Free Software Foundation (FSF). Prócz
        dokumentacji systemowej, do tych programów do³±czone s±
        bardziej rozbudowane dokumenty hipertekstowe, zwane plikami
        <literal>info</literal>. Mo¿na je przegl±daæ poleceniem
        <command>info</command>, lub trybem info <application>emacs</application>a,
        o ile <application>emacs</application> zosta³ zainstalowany.</para>

      <para>By skorzystaæ z polecenia &man.info.1;, wpisujemy:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Krótkie wprowadzenie pojawia siê po wpisaniu <literal>h</literal>.
        Spis poleceñ jest dostêpny po wpisaniu <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
