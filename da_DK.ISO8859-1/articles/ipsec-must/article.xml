<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd">
<!--
    The FreeBSD Documentation Project
    The FreeBSD Danish Documentation Project

    $FreeBSD$
    Original revision: 1.13
-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="da">
  <info><title>Uafhængig Verifikation af IPsec Funktionalitet i
      &os;</title>
    

    <author><personname><firstname>David</firstname><surname>Honig</surname></personname><affiliation>
	<address><email>honig@sprynet.com</email></address>
      </affiliation></author>

    <pubdate>3 Maj 1999</pubdate>

    <legalnotice xml:id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.opengroup;
      &tm-attrib.general;
    </legalnotice>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <abstract>
      &trans.da.jespersen;

      <para>Du installerede IPsec og det ser ud til at virke.  Men
	hvordan ved du det?  Jeg beskriver en metode til
	eksperimentalt at verificere at IPsec virker.</para>
    </abstract>
  </info>

  <sect1 xml:id="problem">
    <title>Problemet</title>

    <para>Lad os antage, at du har <link linkend="ipsec-install">
      installeret <emphasis>IPsec</emphasis></link>.  Hvordan ved du
      at det <link linkend="caveat">virker</link>?
      Selvfølgelig virker din forbindelse ikke hvis den er
      miskonfigureret, og den vil virke når du endelig laver det
      rigtigt.  &man.netstat.1; lister den.  Men kan du verificere det
      uafhængigt?</para>
  </sect1>

  <sect1 xml:id="solution">
    <title>Løsningen</title>

    <para>Først, noget krypto-relevant teoretisk
      information:</para>

    <orderedlist>
      <listitem>
	<para>krypterede data er uniformt distribueret, som f.eks. har
	  maksimal entropi pr. symbol;</para>
      </listitem>

      <listitem>
	<para>rå, ukomprimerede data er typisk redundant,
	  f.eks., har sub-maksimal entropi.</para>
      </listitem>
    </orderedlist>

    <para>Hvis du kunne måle entropien af dataene til og fra dit
      netværks interface.  Så kunne du se forskellen
      mellem ukrypterede og krypterede data.  Det ville være
      tilfældet selvom nogle af dataene i <quote>krypteret
      mode</quote> ikke var krypterede, som f.eks. den yderste IP
      header skal være, hvis pakken skal kunne routes.</para>

    <sect2 xml:id="MUST">
      <title>MUST</title>

      <para>Ueli Maurers <quote>Universal Statistical Test for Random
	Bit Generators</quote> (<link xlink:href="http://www.geocities.com/SiliconValley/Code/4704/universal.pdf">
	<acronym>MUST</acronym></link>) måler hurtigt entropien
	af en stikprøve.  Den bruger en kompressionsagtig
	algoritme.  <link linkend="code">Forneden angives
	kildekoden</link> til en variant der måler successive
	(~kvart megabyte) store bidder af en fil.</para>
    </sect2>

    <sect2 xml:id="tcpdump">
      <title>Tcpdump</title>

      <para>Vi har også brug for en måde at opsamle de
	rå netværksdata.  Et program kaldet
	&man.tcpdump.1; lader dig gøre dette, hvis du har slået
	<emphasis>Berkeley Packet Filter</emphasis> interfacet til i
	din <link linkend="kernel">kerne konfig fil</link>.</para>

      <para>Kommandoen</para>

      <screen><userinput>tcpdump -c 4000 -s 10000 -w dumpfile.bin</userinput></screen>

      <para>vil opfange 4000 rå pakker til
	<replaceable>dumpfile.bin</replaceable>.  Op til 10.000 bytes
	per pakke bliver opfanget i dette eksempel.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="experiment">
    <title>Eksperimentet</title>

    <para>Her er eksperimentet:</para>

    <procedure>
      <step>
	<para>Åbn et vindue til en IPsec vært og et andet
	  vindue til en usikker vært.</para>
      </step>

      <step>
	<para>Start nu med at <link linkend="tcpdump">opfange
	  pakker</link>.</para>
      </step>

      <step>
	<para>I det <quote>sikre</quote> vindue, køres &unix;
	  kommandoen &man.yes.1;, hvilket vil streame
	  <literal>y</literal> karakteren.  Stop dette efter et stykke
	  tid.  Skift til det usikre vindue, og gentag.  Stop igen efter
	  et stykke tid.</para>
      </step>

      <step>
	<para>Kør nu <link linkend="code">MUST</link> på de
	  opfangede pakker.  Du skulle se noget lignende det
	  følgende.  Det vigtige at notere sig er, at den sikre
	  forbindelse har 93% (6,7) af den ventede værdi (7.18),
	  og den <quote>normale</quote> forbindelse har 29% (2.1) af den
	  ventede værdi.</para>

    <screen>&prompt.user; <userinput>tcpdump -c 4000 -s 10000 -w ipsecdemo.bin</userinput>
&prompt.user; <userinput>uliscan ipsecdemo.bin</userinput>

Uliscan 21 Dec 98
L=8 256 258560
Measuring file ipsecdemo.bin
Init done
Expected value for L=8 is 7.1836656
6.9396 --------------------------------------------------------
6.6177 -----------------------------------------------------
6.4100 ---------------------------------------------------
2.1101 -----------------
2.0838 -----------------
2.0983 -----------------</screen>
      </step>
    </procedure>
  </sect1>

  <sect1 xml:id="caveat">
    <title>Undtagelse</title>

    <para>Dette eksperiment viser at, IPsec <emphasis>kan</emphasis>
      se ud til at distribuere payload data
      <emphasis>uniformt</emphasis>, som kryptering skal.  Men det
      eksperiment der er beskrevet her <emphasis>kan ikke</emphasis>
      detektere mange mulige fejl i et system (ingen af hvilke jeg har
      nogle beviser for).  Disse inkluderer dårlig nøgle
      generering eller udveksling, data eller nøgler der kan
      ses af andre, brug af svage algoritmer, kernel undergravning,
      osv.  Studér kildekoden; kend kildekoden.</para>
  </sect1>

  <sect1 xml:id="IPsec">
    <title>IPsec---Definition</title>

    <para>Internet Protokol sikkerheds udvidelser til IPv4;
      krævet for IPv6.  En protokol til at forhandle kryptering
      og autentifikation på IP (vært-til-vært)
      niveau.  SSL sikrer kun en applikationssocket;
      <application>SSH</application> sikrer kun et login;
      <application>PGP</application> sikrer kun en specifik fil eller
      besked.  IPsec krypterer alting mellem to værter.</para>
  </sect1>

  <sect1 xml:id="ipsec-install">
    <title>Installering af IPsec</title>

    <para>De fleste af de moderne versioner af &os; har IPsec
      support i deres base kildekode.  Så du er sikkert
      nødt til at inkludere <option>IPSEC</option> optionen i
      din kernel konfig og, efter genbygning og reinstallation af
      kernel, konfigurere IPsec forbindelser ved hjælp af
      &man.setkey.8; kommandoen.</para>

    <para>En udførlig guide om at køre IPsec på
      &os; er tilrådighed i <link xlink:href="../../books/handbook/ipsec.html">FreeBSD
      Håndbogen</link>.</para>
  </sect1>

  <sect1 xml:id="kernel">
    <title>src/sys/i386/conf/KERNELNAME</title>

    <para>Dette skal være til stede i kernel konfig filen for at
      være i stand til at opfange netværksdata med
      &man.tcpdump.1;.  Vær sikker på at køre
      &man.config.8; efter at tilføje dette, og genbygge og
      reinstallere.</para>

    <programlisting>device	bpf</programlisting>
  </sect1>

  <sect1 xml:id="code">
    <title>Maurers universelle statistiske test (for blok
      størrelse=8 bits)</title>

    <para>Du kan finde samme kode på <link xlink:href="http://www.geocities.com/SiliconValley/Code/4704/uliscanc.txt">
      dette link</link>.</para>

<programlisting>/*
  ULISCAN.c   ---blocksize of 8

  1 Oct 98
  1 Dec 98
  21 Dec 98       uliscan.c derived from ueli8.c

  This version has // comments removed for Sun cc

  This implements Ueli M Maurer's "Universal Statistical Test for Random
  Bit Generators" using L=8

  Accepts a filename on the command line; writes its results, with other
  info, to stdout.

  Handles input file exhaustion gracefully.

  Ref: J. Cryptology v 5 no 2, 1992 pp 89-105
  also on the web somewhere, which is where I found it.

  -David Honig
  honig@sprynet.com

  Usage:
  ULISCAN filename
  outputs to stdout
*/

#define L 8
#define V (1&lt;&lt;L)
#define Q (10*V)
#define K (100   *Q)
#define MAXSAMP (Q + K)

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fptr;
  int i,j;
  int b, c;
  int table[V];
  double sum = 0.0;
  int iproduct = 1;
  int run;

  extern double   log(/* double x */);

  printf("Uliscan 21 Dec 98 \nL=%d %d %d \n", L, V, MAXSAMP);

  if (argc &lt; 2) {
    printf("Usage: Uliscan filename\n");
    exit(-1);
  } else {
    printf("Measuring file %s\n", argv[1]);
  }

  fptr = fopen(argv[1],"rb");

  if (fptr == NULL) {
    printf("Can't find %s\n", argv[1]);
    exit(-1);
  }

  for (i = 0; i &lt; V; i++) {
    table[i] = 0;
  }

  for (i = 0; i &lt; Q; i++) {
    b = fgetc(fptr);
    table[b] = i;
  }

  printf("Init done\n");

  printf("Expected value for L=8 is 7.1836656\n");

  run = 1;

  while (run) {
    sum = 0.0;
    iproduct = 1;

    if (run)
      for (i = Q; run &amp;&amp; i &lt; Q + K; i++) {
        j = i;
        b = fgetc(fptr);

        if (b &lt; 0)
          run = 0;

        if (run) {
          if (table[b] &gt; j)
            j += K;

          sum += log((double)(j-table[b]));

          table[b] = i;
        }
      }

    if (!run)
      printf("Premature end of file; read %d blocks.\n", i - Q);

    sum = (sum/((double)(i - Q))) /  log(2.0);
    printf("%4.4f ", sum);

    for (i = 0; i &lt; (int)(sum*8.0 + 0.50); i++)
      printf("-");

    printf("\n");

    /* refill initial table */
    if (0) {
      for (i = 0; i &lt; Q; i++) {
        b = fgetc(fptr);
        if (b &lt; 0) {
          run = 0;
        } else {
          table[b] = i;
        }
      }
    }
  }
}</programlisting>
  </sect1>
</article>
