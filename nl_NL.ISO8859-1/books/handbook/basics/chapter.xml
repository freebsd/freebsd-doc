<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$

     %SOURCE%	en_US.ISO8859-1/books/handbook/basics/chapter.xml
     %SRCID%	40588
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <info><title>&unix; beginselen</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Herschreven door </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Remko</firstname><surname>Lodder</surname></personname><contrib>Vertaald door </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="basics-synopsis">
    <title>Overzicht</title>

    <para>Het volgende hoofdstuk behandelt de basiscommando's en
      functionaliteit van het &os; besturingssysteem.  Veel van dit
      materiaal is relevant voor elk &unix; achtig besturingssysteem.
      Als de lezer reeds bekend is met het materiaal, hoeft dit
      hoofdstuk niet gelezen te worden.  Lezer die nog niet eerder
      met &os; te maken hebben gehad wordt aangeraden door te
      lezen.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>Hoe <quote>virtuele consoles</quote> in &os; gebruikt
	  kunnen worden;</para>
      </listitem>

      <listitem>
	<para>Hoe &unix; bestandspermissies werken en hoe
	  bestandsvlaggen in &os; werken;</para>
      </listitem>

      <listitem>
	<para>Hoe het standaard &os; bestandssysteem eruit ziet;</para>
      </listitem>

      <listitem>
	<para>Hoe een &os; harde schijf is ingedeeld;</para>
      </listitem>

      <listitem>
	<para>Hoe bestandssystemen gekoppeld en ontkoppeld
	  worden;</para>
      </listitem>

      <listitem>
	<para>Wat processen, daemons en signalen zijn;</para>
      </listitem>

      <listitem>
	<para>Wat een shell is en hoe de standaard omgevingsvariabelen
	  veranderd kunnen worden;</para>
      </listitem>

      <listitem>
	<para>Hoe elementaire tekstverwerkers te gebruiken;</para>
      </listitem>

      <listitem>
	<para>Wat apparaten en apparaatkoppelpunten zijn;</para>
      </listitem>

      <listitem>
	<para>Welk binair formaat &os; gebruikt;</para>
      </listitem>

      <listitem>
	<para>Hoe handleidingen te gebruiken meer informatie.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Virtuele consoles en terminals</title>

    <indexterm><primary>Virtuele consoles</primary></indexterm>

    <indexterm><primary>terminals</primary></indexterm>

    <para>&os; kan op diverse manieren gebruikt worden.
      Één van deze manieren is het typen van commando's
      in een tekstterminal.  Veel van de flexibiliteit en kracht van
      een &unix; besturingssysteem is gemakkelijk beschikbaar als je
      &os; op deze manier gebruikt.  Dit onderdeel beschrijft wat
      <quote>terminals </quote> en <quote>consoles</quote> zijn en hoe
      je deze kan gebruiken in &os;.</para>

    <sect2 xml:id="consoles-intro">
      <title>De console</title>

      <indexterm><primary>console</primary></indexterm>

      <para>Als &os; niet is ingesteld om automatisch een grafische
	omgeving te starten tijdens het opstarten, geeft het systeem
	een login prompt als het gestart is.  Dit gebeurt direct nadat
	de startscripts klaar zijn.  Er wordt iets als het volgende
	getoond:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

&os;/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>De meldingen op het scherm kunnen wellicht iets anders zijn
	op een systeem, maar het zal iets soortgelijks zijn.  De
	laatste twee regels zijn de regels waar het nu over gaat.
	De voorlaatste regel toont:</para>

      <programlisting>&os;/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Deze regel bevat enkele informatie over het systeem dat
	net gestart is: dit is een <quote>&os;</quote> console,
	draaiend op een Intel of soortgelijke processor op de x86
	architectuur.

	<footnote>
	  <para>Dit betekent <literal>i386</literal>.  Let op: ook al
	    draait &os; niet op een Intel 386 processor, toch is dit
	    een <literal>i386</literal>.  Het is niet het type
	    processor, maar de processor
	    <quote>architectuur</quote>.</para></footnote>

	De naam van de machine (elke &unix; machine heeft een
	naam) is <systemitem>pc3.example.org</systemitem> en dit is de console
	van het systeem, de <filename>ttyv0</filename>
	terminal.</para>

      <para>De laatste regel is altijd:</para>

      <programlisting>login:</programlisting>

      <para>Dit is het deel waar een <quote>gebruikersnaam</quote>
	ingevuld moet worden om aan te melden op &os;.  Het volgende
	deel beschrijft hoe dat werkt.</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>Aanmelden op &os;</title>

      <para>&os; is een multi-user en multi-processing systeem.  Dit is
	de formele beschrijving die meestal gegeven wordt aan een
	systeem dat gebruikt wordt door meerdere personen die
	gelijktijdig verschillende programma's draaien op
	één enkele machine.</para>

      <para>Elk multi-user systeem heeft een manier nodig om een
	<quote>gebruiker</quote> van alle andere gebruikers te kunnen
	onderscheiden.  In &os; (en alle andere &unix; achtige
	besturingssystemen), wordt dit bereikt door te eisen dat
	elke gebruiker moet <quote>aanmelden</quote> op het systeem
	voordat hij/zij programma's kan draaien.  Elke gebruiker heeft
	een unieke naam (de <quote>gebruikersnaam</quote>) en een
	persoonlijke, geheime sleutel (het <quote>wachtwoord</quote>).
	&os; vraagt om deze twee gegevens voordat het een gebruiker
	toegestaat om programma's te draaien.</para>

      <indexterm><primary>startup scripts</primary></indexterm>

      <para>Direct nadat &os; is opgestart en de opstartscripts
	<footnote>
	  <para>Opstart scripts zijn programma's die automatisch gestart
	    worden tijdens het opstarten.  Het hoofddoel van deze
	    programma's is om dingen goed te zetten zodat alle andere
	    programma's ook kunnen draaien, en om services te starten
	    die je geconfigureerd hebt om bruikbare zaken in de
	    achtergrond te doen.</para></footnote>
	afgerond zijn, wordt een prompt getoond dat vraagt om een
	geldige aanmeldnaam op te geven.</para>

      <screen>login:</screen>

      <para>In dit voorbeeld wordt aangenomen de gebruikersnaam
	<systemitem class="username">john</systemitem> is.  Als na deze prompt
	<literal>john</literal> wordt getype en op
	<keycap>Enter</keycap> wordt gedrukt, verschijnt hierna
	een prompt om het <quote> wachtwoord</quote> in te
	voeren:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Nu kan <systemitem class="username">john</systemitem>'s wachtwoord ingevoerd
	worden en op <keycap>Enter</keycap> gedrukt worden.  Het
	wachtwoord wordt <emphasis>niet getoond</emphasis>!  Daarover
	hoeft geen zorg te bestaan.  Het is voldoende om te zeggen dat
	dit om veiligheidsredenen gedaan wordt.</para>

      <para>Als het juiste wachtwoord is ingegeven, is er aangemeld bij
	op &os; en in het systeem klaar om alle beschikbare commando's
	uit te voeren.</para>

      <para>Na het aanmelden is de <acronym>MOTD</acronym> of het
	bericht van de dag zichtbaar, gevolgd door een commandoprompt
	(een <literal>#</literal>, <literal>$</literal> of een
	<literal>%</literal> karakter).  Dit geeft aan dat er succesvol
	is aangemeld op &os;.</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>Meerdere consoles</title>

      <para>&unix; programma's draaien in één console is
	prima, maar &os; kan veel programma's tegelijk draaien.  Om
	maar één console te hebben waar commando's
	ingetypt kunnen worden zou zonde zijn van een besturingssysteem
	als &os; waar meerdere programma's tegelijkertijd op kunnen
	draaien.  Hier kunnen <quote>virtuele consoles</quote> van pas
	komen.</para>

      <para>&os; kan ingesteld worden om verschillende virtuele
	consoles te tonen.  Met toetscombinaties kan van de ene console
	naar de gewisseld worden.  Elke console heeft zijn eigen
	uitvoerkanaal, en &os; zorgt ervoor dat alle toetsenbordinvoer
	en monitoruitvoer goed wordt gezet als er van de ene console
	naar de volgende wordt gewisseld.</para>

      <para>In &os; kunnen speciale toetscombinaties gebruikt worden om
	te wisselen naar een ander virtueel console.
	<footnote>
	  <para>Een redelijk technische en accurate beschrijving van
	    alle details over de &os; console en toetsenborddrivers
	    staan in de hulppagina's van &man.syscons.4;,
	    &man.atkbd.4;, &man.vidcontrol.1; en &man.kbdcontrol.1;.
	    Hier wordt niet verder op ingegaan, maar de
	    geïnteresseerde lezer kan altijd de hulppagina's
	    raadplegen voor meer details en een grondige uitleg over
	    hoe alles werkt.</para></footnote>
	In &os; kan
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	tot en met
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	gebruikt worden om te wisselen naar een ander virtueel
	console.</para>

      <para>Als wordt gewisseld van de ene naar de andere console zorgt
	&os; dat de uitvoer bewaard blijft.  Het resultaat is een
	<quote>illusie</quote> van het hebben van meerdere schermen en
	toetsenborden die gebruikt kunnen worden om commando's in te
	voeren om &os; te laten draaien.  De programma's die in de ene
	virtuele console draaien, stoppen niet als de console niet
	zichtbaar is.  Ze blijven doordraaien als naar een andere
	virtuele console wordt gewisseld.</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title>Het bestand <filename>/etc/ttys</filename></title>

      <para>De standaardinstelling van &os; start op met acht virtuele
	consoles.  Dit is echter geen vaste waarde en een installatie
	kan eenvoudig aangepast worden, zodat het systeem gestart
	wordt met meer of minder virtuele consoles.  De hoeveelheid en
	instellingen van de virtuele consoles worden ingesteld in
	<filename>/etc/ttys</filename>.</para>

      <para><filename>/etc/ttys</filename> kan gebruikt worden om
	virtuele consoles in te stellen.  Elke niet-commentaar
	regel in dit bestand (regels die niet beginnen met een
	<literal>#</literal> karakter) bevat instellingen voor een
	terminal of virtuele console.  De standaardversie van dit
	bestand die meegeleverd wordt met &os; stelt negen virtuele
	consoles in en activeert er acht.  Dit zijn de regels die
	beginnen met <literal>ttyv</literal>:</para>

      <programlisting># naam  getty                             type    status           commentaar
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Een uitgebreide beschrijving van elke kolom in dit
	bestand en alle mogelijke opties voor virtuele consoles staan
	in de &man.ttys.5; hulppagina
	gebruiken.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Single-user console</title>

      <para>In <xref linkend="boot-singleuser"/> staat een
	gedetailleerde beschrijving van de <quote>single-user
	  modus</quote>.  Het is belanrijk te melden dat er in
	single-user modus maar één console is.  Er zijn
	geen virtuele consoles beschikbaar.  De instellingen van de
	single-user modus console staan ook in
	<filename>/etc/ttys </filename>.  De regel begint met
	<literal>console</literal>:</para>

      <programlisting># name  getty                             type    status           commentaar
#
# Als een console gemarkeerd is als "insecure", zal het init script om het root-wachtwoord
# vragen wanneer het in single-user mode komt.
console none                              unknown off secure</programlisting>

      <note>
	<para>Zoals het commentaar boven de <literal>console</literal>
	  regel aangeeft, kan in deze regel het woord
	  <literal>secure</literal> gewijzigd worden in
	  <literal>insecure</literal>.  In dat geval vraagt &os; bij
	  het opstarten in single-user modus nog steeds om een
	  <systemitem class="username">root</systemitem>-wachtwoord.</para>

	<para><emphasis>Pas op als dit wordt veranderd in
	    <literal>insecure</literal></emphasis>.  Als het wachtwoord
	  van de gebruiker <systemitem class="username">root</systemitem> zoek is,
	  wordt het opstarten in single-user modus lastig.  Het is nog
	  steeds mogelijk, maar het kan vrij moeilijk zijn voor iemand
	  die &os; niet zo goed kent met betrekking tot het opstarten
	  en de programma's die daarbij gebruikt worden.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Het wijzigen van de console video mode</title>

      <para>De &os; standaard video mode kan worden gewijzigd in
	1024x768, 1280x1024, of een van de vele andere formaten die
	ondersteund worden door de grafische kaart en monitor.  Laad de
	module <literal>VESA</literal> om gebruik te maken van de verschillende
	video modes:</para>

      <screen>&prompt.root; <userinput>kldload vesa</userinput></screen>

      <para>Kijk daarna welke video modes er ondersteund worden door
	de hardware door gebruik te maken van de &man.vidcontrol.1;
	applicatie.  Om een overzicht te krijgen van de ondersteunde
	video modes moet het volgende ingevoerd worden:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Het resultaat van dit commando is een lijst van video modes
	welke ondersteund worden door de hardware.  Hierna kan de nieuwe
	video mode gekozen worden door dit aan te geven aan
	&man.vidcontrol.1;:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Als de nieuwe video mode acceptabel is, kan dit permanent
	ingesteld worden door het volgende in
	<filename>/etc/rc.conf</filename> te zetten:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Rechten</title>

    <indexterm><primary>UNIX</primary></indexterm>

    <para>&os;, direct afgeleid van BSD &unix;, is gebaseerd op
      verschillende belangrijke &unix; concepten.  Het meest bekende is
      dat &os; een multi-user systeem is.  Het systeem kan meerdere
      gebruikers behandelen die tegelijkertijd totaal verschillende
      dingen doen.  Het systeem is verantwoordelijk voor het netjes
      delen en beheren voor aanvragen voor hardware, randapparatuur,
      geheugen en cpu tijd tussen elke gebruiker.</para>

    <para>Omdat het systeem in staat is om meerdere gebruikers te
      ondersteunen, heeft alles wat door het systeem beheerd wordt een
      set van rechten die aangeeft wie mag lezen, schrijven en de
      bron mag uitvoeren.  Deze rechten zijn opgeslagen in drie
      octetten, die weer in drie stukjes onderverdeeld zijn:
      één voor de eigenaar van het bestand,
      één voor de groep waar het bestand toe behoort en
      één voor de overigen.  De numerieke weergave werkt
      als volgt:</para>

    <indexterm><primary>Rechten</primary></indexterm>

    <indexterm><primary>Bestandsrechten</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Waarde</entry>

	    <entry>Recht</entry>

	    <entry>Maprecht</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>

	    <entry>Niet lezen, niet schrijven, niet uitvoeren</entry>

	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>

	    <entry>Niet lezen, niet schrijven,  uitvoeren</entry>

	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>

	    <entry>Niet lezen, schrijven, niet uitvoeren</entry>

	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>

	    <entry>Niet lezen, schrijven, uitvoeren</entry>

	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>

	    <entry>Lezen, niet schrijven, niet uitvoeren</entry>

	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>

	    <entry>Lezen, niet schrijven, uitvoeren</entry>

	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>

	    <entry>Lezen, schrijven, niet uitvoeren</entry>

	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>

	    <entry>Lezen, schrijven, uitvoeren</entry>

	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary><command>ls</command></primary></indexterm>

    <indexterm><primary>mappen</primary></indexterm>

    <para>De <option>-l</option> optie kan gebruikt worden met
      &man.ls.1; om een lange lijst met de inhoud van een map te zien
      die een kolom heeft met informatie over bestandsrechten voor de
      eigenaar, groep en de rest.  <command>ls -l</command> in een
      willekeurige map kan het volgende laten zien:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Zo ziet de eerste kolom van <command>ls -l</command>
      eruit:</para>

    <screen>-rw-r--r--</screen>

    <para>Het eerste (meest linkse) karakter geeft aan of dit een
      reguliere bestand is, een map, een speciaal karakter
      component(!), een socket of een andere pseudo-file component(!).
      In dit geval betekent de <literal>-</literal> dat het een
      regulier bestand is.  De volgende drie karakters,
      <literal>rw-</literal> in dit voorbeeld, geven de rechten voor de
      eigenaar van het bestand.  De drie karakters
      <literal>r--</literal> erna geven de rechten van voor de groep van
      het bestand.  De overige drie karakters <literal>r--</literal>
      tonen de rechten voor alle overige gebruikers.  Een streepje betekent dat
      de rechten uitgeschakeld zijn.  In het geval van dit bestand zijn de
      rechten zo ingesteld dat de eigenaar kan lezen en schrijven naar
      het bestand, de groep het bestand kan lezen, en alle overige
      gebruikers kunnen ook het bestand lezen.  Volgens de tabel hierboven
      worden de rechten <literal>644</literal>, waar de cijfers de drie
      stukjes van de rechten aangeven.</para>

    <para>Dit is allemaal leuk en aardig, maar hoe controleert het
      systeem dan rechten voor apparaten?  &os; behandelt de meeste
      hardware apparaten als bestanden die door programma's kunnen
      worden geopend en gelezen, en waar data naar toe kan worden
      geschreven, net zoals elk ander bestand.  Deze speciale apparaat
      bestanden worden bewaard in de map
      <filename>/dev</filename>.</para>

    <para>Mappen worden ook behandeld als bestanden.  Ze hebben lees,
      schrijf en uitvoerbare rechten.  De uitvoerbare vlag voor een map
      heeft een klein verschil qua betekenis dan die voor gewone
      bestanden.  Als een map als uitvoerbaar gemarkeerd is, betekent
      het dat erin gekeken mag worden.  Het is dus mogelijk om te
      wisselen naar de map met <command>cd</command> (wissel van map).
      Dit betekent ook dat in de map bestanden benaderd kunnen worden
      waarvan de naam bekend is.  Dit is natuurlijk afhankelijk van de
      rechten op het bestand zelf.</para>

    <para>In het bijzonder, om een lijst van de map te kunnen maken,
      moet een gebruiker leesrechten op de map hebben.  Om een bestand
      te verwijderen zijn de naam van het bestand en schrijf
      <emphasis>en</emphasis> uitvoerrechten op de map nodig waarin het
      bestand zich bevindt.</para>

    <para>Er zijn meer rechtenvlaggen, maar die worden slechts gebruikt
      in speciale gevallen, zoals bij setuid binaries en sticky mappen.
      Meer informatie over bestandsrechten en hoe die aangepast kunnen
      worden staat in &man.chmod.1;.</para>

    <sect2>
      <info><title>Symbolische rechten</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Bijgedragen door </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>rechten</primary>

	<secondary>symbolisch</secondary>
      </indexterm>

      <para>Symbolische rechten, soms ook wel symbolische expressies,
	gebruiken karakters in plaats van octale getallen om rechten
	aan bestanden en mappen te geven.  Symbolische expressies
	gebruiken de volgende opbouw: (wie) (actie) (permissies), waar
	de volgende waardes beschikbaar zijn:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Optie</entry>

	      <entry>Letter</entry>

	      <entry>Vertegenwoordigt</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>(wie)</entry>

	      <entry>u</entry>

	      <entry>Gebruiker</entry>
	    </row>

	    <row>
	      <entry>(wie)</entry>

	      <entry>g</entry>

	      <entry>Groepseigenaar</entry>
	    </row>

	    <row>
	      <entry>(wie)</entry>

	      <entry>o</entry>

	      <entry>Overigen</entry>
	    </row>

	    <row>
	      <entry>(wie)</entry>

	      <entry>a</entry>

	      <entry>Iedereen (<quote>wereld</quote>)</entry>
	    </row>

	    <row>
	      <entry>(actie)</entry>

	      <entry>+</entry>

	      <entry>Rechten toevoegen</entry>
	    </row>

	    <row>
	      <entry>(actie)</entry>

	      <entry>-</entry>

	      <entry>Rechten verwijderen</entry>
	    </row>

	    <row>
	      <entry>(actie)</entry>

	      <entry>=</entry>

	      <entry>Stel deze rechten in</entry>
	    </row>

	    <row>
	      <entry>(recht)</entry>

	      <entry>r</entry>

	      <entry>Lezen</entry>
	    </row>

	    <row>
	      <entry>(recht)</entry>

	      <entry>w</entry>

	      <entry>Schrijven</entry>
	    </row>

	    <row>
	      <entry>(recht)</entry>

	      <entry>x</entry>

	      <entry>Uitvoeren</entry>
	    </row>

	    <row>
	      <entry>(recht)</entry>

	      <entry>t</entry>

	      <entry>Sticky bit</entry>
	    </row>

	    <row>
	      <entry>(recht)</entry>

	      <entry>s</entry>

	      <entry>Verander UID of GID</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Deze waardes worden gebruikt met &man.chmod.1;, net zoals
	eerder, alleen nu met letters.  Het volgende commando kan
	gebruikt worden om de overige gebruikers toegang tot
	<replaceable>BESTAND</replaceable> te ontzeggen:</para>

      <screen>&prompt.user; <userinput>chmod go= BESTAND</userinput></screen>

      <para>Er kan een door komma's gescheiden lijst geleverd worden als
	meer dan één wijziging aan een bestand moet worden
	uitgevoerd.  Het volgende commando past de rechten voor de groep
	en de <quote>wereld</quote> aan door de schrijfrechten te
	ontnemen om daarna iedereen uitvoerrechten te geven:</para>

      <screen>&prompt.user; <userinput>chmod go-w,a+x BESTAND</userinput></screen>
    </sect2>

    <sect2>
      <info><title>&os; bestandsvlaggen</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschreven door </contrib></author>
	</authorgroup>
      </info>

      

      <para>Naast de bestandsrechten die hiervoor zijn besproken,
	biedt &os; ondersteuning voor <quote>bestandsvlaggen.</quote>
	Deze vlaggen bieden een aanvullend beveiligingsniveau en
	controle over bestanden, maar niet over mappen.</para>

      <para>Bestandsvlaggen voegen een extra niveau van controle over
	bestanden, waardoor verzekerd kan worden dat in sommige
	gevallen zelfs <systemitem class="username">root</systemitem> een bestand niet kan
	verwijderen of wijzigen.</para>

      <para>Bestandsvlaggen worden gewijzigd met het hulpprogramma
	&man.chflags.1;, dat een eenvoudige interface heeft.  Om
	bijvoorbeeld de systeemvlag niet verwijderdbaar in te stellen
	op het bestand <filename>file1</filename>:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>Om de vlag niet verwijderbaar weer te verwijderen kan het
	voorgaande commando met <quote>no</quote> voor
	<option>sunlink</option> worden uitgevoerd:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Om de vlaggen op een bestand te bekijken, kan het &man.ls.1;
	commando met de vlaggen <option>-lo</option> gebruikt worden:</para>

      <screen>&prompt.root; <userinput>ls -lo file1</userinput></screen>

      <para>De uitvoer hoort er ongeveer als volgt uit te zien:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Een aantal vlaggen kan alleen ingesteld of verwijderd
	worden door de gebruiker <systemitem class="username">root</systemitem>.  In andere
	gevallen kan de eigenaar van een bestand vlaggen instellen.
	Meer informatie voor beheerders staat in &man.chflags.1; en
	&man.chflags.2;.</para>
    </sect2>

    <sect2>
      <info><title>De <literal>setuid</literal>-, <literal>setgid</literal>-, en <literal>klevende</literal> toestemmingen</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Bijgedragen door </contrib></author>
	</authorgroup>
      </info>

      

      <para>Buiten de toestemmingen die reeds besproken zijn, zijn er
	nog drie specifieke instellingen waarvan alle beheerders kennis
	dienen te hebben.  Dit zijn de <literal>setuid</literal>-,
	<literal>setgid</literal>-, en <literal>sticky</literal>
	toestemmingen.</para>

      <para>Deze instellingen zijn belangrijk voor sommige
	&unix;-bewerkingen omdat ze functionaliteit bieden die
	normaliter niet aan normale gebruikers wordt gegeven.  Om ze te
	begrijpen, dient ook het verschil tussen de echte gebruikers-ID
	en de effectieve gebruikers-ID opgemerkt te worden.</para>

      <para>De echte gebruikers-ID is de <acronym>UID</acronym> die het
	proces start of bezit.  De effectieve <acronym>UID</acronym> is
	de gebruikers-ID waaronder het proces draait.  Bijvoorbeeld, het
	gereedschap &man.passwd.1; draait met de echte gebruikers-ID van
	de gebruiker die het wachtwoord verandert; echter, om de
	database met wachtwoorden te manipuleren, draait het met de
	effectieve ID van de gebruiker <systemitem class="username">root</systemitem>.  Dit
	is wat normale gebruikers in staat stelt om hun wachtwoorden te
	veranderen zonder een fout <errorname>Permission
	  Denied</errorname> te zien.</para>

      <note>
	<para>De &man.mount.8;-optie <literal>nosuid</literal> zorgt
	  ervoor dat deze binairen zwijgend falen.  Dit houdt in dat ze
	  niet worden uitgevoerd zonder ooit de gebruiker op de hoogte
	  te stellen.  Deze optie is ook niet geheel betrouwbaar
	  aangezien een <literal>nosuid</literal>-wrapper dit volgens de
	  handleidingpagina &man.mount.8; kan omzeilen.</para>
      </note>

      <para>De setuid-toestemming kan aangezet worden door het cijfer
	vier (4) voor een toestemmingenverzameling te plaatsen zoals te
	zien is in het volgende voorbeeld:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidvoorbeeld.sh</userinput></screen>

      <para>De toestemmingen op het bestand
	<filename>suidvoorbeeld.sh</filename> dienen er nu als volgt uit
	te zien:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidvoorbeeld.sh</programlisting>

      <para>Het zou in dit voorbeeld te zien moeten zijn dat een
	<literal>s</literal> nu deel is van de toestemmingenverzameling
	bestemd voor de bestandseigenaar, en de uitvoerbare bit
	vervangt.  Dit staat gereedschappen toe die verhoogde
	toestemmingen nodig hebben, zoals <command>passwd</command>.</para>

      <para>Open twee terminals om dit in real-time te zien.  Start op
	het ene het proces <command>passwd</command> als een normale
	gebruiker.  Controleer de procestabel terwijl het op een nieuw
	wachtwoord wacht en kijk naar de gebruikersinformatie van het
	commando <command>passwd</command>.</para>

      <para>In terminal A:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>In terminal B:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01</screen>

      <para>Zoals boven vermeld, wordt <command>passwd</command> door
	een normale gebruiker gedraaid, maar gebruikt het de effectieve
	<acronym>UID</acronym> van <systemitem class="username">root</systemitem>.</para>

      <para>De <literal>setgid</literal>-toestemming voert dezelfde
	functie uit als de <literal>setuid</literal>-toestemming;
	behalve dat het de groepsinstellingen verandert.  Wanneer een
	applicatie of gereedschap met deze instelling wordt gedraaid,
	krijgt het de toestemmingen gebaseerd op de groep die het
	bestand bezit, niet op de gebruiker die het proces startte.</para>

      <para>Om de <literal>setgid</literal>-toestemming op een bestand
	aan te zetten, dient een voorlopende twee (2) aan het commando
	<command>chmod</command> gegeven te worden zoals in het volgende
	voorbeeld:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidvoorbeeld.sh</userinput></screen>

      <para>De nieuwe instelling kan zoals hierboven bekeken worden,
	merk op dat de <literal>s</literal> nu in het veld bestemd voor
	de instellingen van de  groepstoestemmingen staat:</para>

      <programlisting>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidvoorbeeld.sh</programlisting>

      <note>
	<para>In deze voorbeelden zal het shellscript niet met een
	  andere <acronym>EUID</acronym> of effectief gebruikers-ID
	  draaien, zelfs al is het shellscript uitvoerbaar.  Dit is
	  omdat shellscripts geen toegang hebben tot de
	  &man.setuid.2;-systeemaanroepen.</para>
      </note>

      <para>De eerste twee speciale toestemmingsbits die we besproken
	hebben (de toestemmingsbits <literal>setuid</literal> en
	<literal>setgid</literal>) kunnen de systeemveiligheid verlagen,
	door verhoogde toestemmingen toe te staan.  Er is een derde bit
	voor speciale toestemmingen die de veiligheid van een systeem
	kan verhogen: de <literal>klevende bit</literal>.</para>

      <para>De <literal>klevende bit</literal>, wanneer deze op een map
	is ingesteld, staat alleen het verwijderen van bestanden toe
	door de eigenaar van die bestanden.  Deze
	toestemmingenverzameling is nuttig om het verwijderen van
	bestanden in publieke mappen, zoals <filename>/tmp</filename>, door gebruikers die het
	bestand niet bezitten te voorkomen.  Zet een één
	(1) voor de toestemming om deze toestemming te gebruiken.
	Bijvoorbeeld:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Het effect kan nu met het commando <command>ls</command>
	bekeken worden:</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

      <para>De toestemming <literal>klevende bit</literal> is te
	onderscheiden met de <literal>t</literal> aan het einde van de
	verzameling.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Mappenstructuur</title>

    <indexterm><primary>mappenstructuur</primary></indexterm>

    <para>De &os; mappenstructuur is erg belangrijk om het systeem
      goed te leren kennen.  Het belangrijkste concept om greep op te
      krijgen is die van de rootmap, <quote>/</quote>.  Deze map is de
      eerste die gekoppeld wordt tijdens het opstarten en bevat het
      basissysteem dat nodig is om het besturingssysteem gereed te
      maken voor multi-user taken.  De rootmap bevat ook koppelpunten
      voor elk ander bestandssysteem dat misschien gekoppeld
      wordt.</para>

    <para>Een koppelpunt is een map waar extra bestandssystemen aan het
      een bestandssysteem gekoppeld kunnen worden (meestal het root
      bestandssysteem).  Dit wordt beschreven
      in <xref linkend="disk-organization"/>.  Standaard koppelpunten
      zijn <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>, <filename>/mnt</filename> en
      <filename>/cdrom</filename>.  Naar deze mappen wordt meestal
      verwezen in <filename>/etc/fstab</filename>, een tabel met
      bestandssystemen en koppelpunten ter referentie voor het systeem.
      De meeste bestandssystemen in <filename>/etc/fstab</filename>
      worden automatisch gekoppeld tijdens het opstarten door het script
      &man.rc.8;, behalve als de optie <option>noauto</option>
      gedefinieerd is.  Details staan beschreven in <xref linkend="disks-fstab"/>.</para>

    <para>Een complete beschrijving over het bestandssysteem staat in
      &man.hier.7;.  Hier wordt volstaan met een overzicht van de
      voorkomende mappen.</para>

    <para>
      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Map</entry>

	      <entry>Omschrijving</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><filename>/</filename></entry>

	      <entry>Rootmap van het bestandssysteem.</entry>
	    </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>

	      <entry>Gebruikersapplicaties, belangrijk voor zowel
		single user als multi-user omgevingen.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>

	      <entry>Programma's en instellingenbestanden die
		gebruikt worden tijdens het opstarten van het
		besturingssysteem.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>

	      <entry>Bestanden met standaardinstellingen voor
		opstarten;, zie &man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>

	      <entry>Apparaatnodes;, zie &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>

	      <entry>Bestanden met systeeminstellingen en
		scripts.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>

	      <entry>Bestanden met standaard systeeminstellingen;, zie
		&man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>

	      <entry>Instellingenbestanden voor mail transport
		programma's zoals &man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>

	      <entry>Instellingenbestanden voor
		<command>named</command>, zie &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>

	      <entry>Scripts die dagelijks, wekelijks en maandelijks
		via &man.cron.8; worden uitgevoerd,
		zie &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>

	      <entry>Instellingenbestanden voor <command>ppp</command>,
		zie &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>

	      <entry>Lege map, veel gebruikt door systeembeheerders als
		tijdelijk koppelpunt voor opslagruimtes.</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>

	      <entry>Process bestandssysteem;, zie &man.procfs.5; en
		&man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>Statisch gelinkte programma's voor noodherstel,
		zie &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>

	      <entry>Thuismap van de gebruiker
		<systemitem class="username">root</systemitem>.</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>

	      <entry>Systeemprogramma's en administratieprogramma's
		belangrijk voor zowel single-user en multi-user
		omgevingen.</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>

	      <entry>Tijdelijke bestanden.  De inhoud van <filename>/tmp</filename> blijft meestal NIET
		bewaard na een herstart.  Er wordt vaak een
		geheugengebaseerd bestandssysteem gekoppeld op <filename>/tmp</filename>.  Dit kan
		geautomatiseerd worden met de tmpmfs-gerelateerde
		variabelen van &man.rc.conf.5; (of met een regel in
		<filename>/etc/fstab</filename>).  Zie &man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/</filename></entry>

	      <entry>Hier bevindt zich het leeuwendeel van alle
		hulpprogramma's en gewone programma's.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>

	      <entry>Standaard programma's, programmeertools.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>

	      <entry>Standaard C invoegbestanden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>

	      <entry>Functiebibliotheken.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>

	      <entry>Diverse databestanden voor hulpprogramma's.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>

	      <entry>Systeemdaemons en systeemhulpprogramma's
		(uitgevoerd door andere programma's).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>Lokale programma's, bibliotheken, etc.  Wordt ook
		gebruikt als standaard locatie voor de &os; ports.
		Binnen <filename>/usr/local</filename>, wordt de
		algemene layout bepaald door &man.hier.7;, dat ook voor
		<filename>/usr</filename> wordt gebruikt.
		Uitzonderingen is de map man, die direct onder
		<filename>/usr/local</filename> ligt in plaats van
		onder <filename>/usr/local/share</filename>, en de
		documentatie voor ports is te vinden in
		<filename>share/doc/port</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>

	      <entry>Architectuur afhankelijke doelstructuur voor
		resultaten van de bouw van
		<filename>/usr/src</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports/</filename></entry>

	      <entry>De &os; Portscollectie (optioneel).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>

	      <entry>Systeemdaemons en systeemhulpprogramma's
		(uitgevoerd door gebruikers).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>

	      <entry>Architectuur onafhankelijke bestanden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>

	      <entry>BSD en/of lokale broncodebestanden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/X11R6/</filename></entry>

	      <entry>Uitvoerbare bestanden en bibliotheken, etc, voor
		de X11R6 distributie (optioneel).</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>

	      <entry>Multifunctionele logboek-, tijdelijke,
		transparante en spool bestanden.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/log/</filename></entry>

	      <entry>Diverse logboekbestanden van het systeem.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>

	      <entry>Postbusbestanden van gebruikers.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>

	      <entry>Diverse printer- en
		mailsysteemspoolingmappen.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>

	      <entry>Tijdelijke bestanden die bewaard worden bij een
		herstart van het systeem.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp/</filename></entry>

	      <entry>NIS maps.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable></para>
  </sect1>

  <sect1 xml:id="disk-organization">
    <title>Organisatie van schijven</title>

    <para>De kleinste vorm van organisatie die &os; gebruikt om
      bestanden te vinden is de bestandsnaam.  Bestandsnamen zijn
      hoofdlettergevoelig, wat betekent dat
      <filename>readme.txt</filename> en
      <filename>README.TXT</filename> twee verschillende bestanden
      zijn.  &os; gebruikt de extensie niet (<filename>.txt</filename>)
      van een bestand om te bepalen of het bestand een programma, een
      document of een vorm van data is.</para>

    <para>Bestanden worden bewaard in mappen.  Een map kan leeg zijn of
      honderden bestanden bevatten.  Een map kan ook andere mappen
      bevatten, wat het mogelijk maakt om een hiërarchie van
      mappen te maken.  Dit maakt het veel makkelijker om data te
      organiseren.</para>

    <para>Bestanden en mappen worden aangegeven door het bestand
      of de map aan te geven, gevolgd door een voorwaardse slash,
      <literal>/</literal>, gevolgd door andere mapnamen die nodig
      zijn.  Als map <filename>foo</filename> de map
      <filename>bar</filename> bevat, die op zijn beurt het bestand
      <filename>readme.txt</filename> bevat, dan wordt de volledige
      naam of <firstterm>pad</firstterm> naar het bestand
      <filename>foo/bar/readme.txt</filename>.</para>

    <para>Mappen en bestanden worden bewaard op een bestandssysteem.
      Elk bestandssysteem bevat precies één map op het
      hoogste niveau die <firstterm>de rootmap</firstterm> van het
      bestandssysteem heet.  Deze rootmap kan op zijn beurt andere
      mappen bevatten.</para>

    <para>Tot zover is dit waarschijnlijk hetzelfde als voor elk ander
      besturingssysteem.  Er zijn een paar verschillen.  &ms-dos;
      gebruikt bijvoorbeeld een <literal>\</literal> om bestanden en
      mappen te scheiden, terwijl &macos; gebruik maakt van
      <literal>:</literal>.</para>

    <para>&os; gebruikt geen schijfletters, of andere schijfnamen in
      het pad.  &os; gebruikt geen
      <filename>c:/foo/bar/readme.txt</filename>.</para>

    <para>Eén bestandssysteem wordt aangewezen als
      <firstterm>root</firstterm> bestandssysteem, waar naar wordt
      verwezen met <literal>/</literal>.  Elk ander bestandssysteem
      wordt daarna <firstterm>gekoppeld</firstterm> onder het root
      bestandssysteem.  Hoeveel schijven er ook aan een &os; systeem
      hangen, het lijkt alsof elke map zich op dezelfde schijf
      bevindt.</para>

    <para>Stel er zijn drie bestandssystemen met de namen
      <literal>A</literal>,<literal>B</literal> en
      <literal>C</literal>.  Elk bestandssysteem heeft
      één root map die twee andere mappen bevat,
      <literal>A1</literal> en <literal>A2</literal> (zo ook voor de
      andere twee: <literal>B1</literal>, <literal>B2</literal>,
      <literal>C1</literal> en <literal>C2</literal>).</para>

    <para><literal>A</literal> wordt het root besturingsysteem.  Met
      <command>ls</command>, dat de inhoud van de map kan tonen, zijn
      de twee mappen <literal>A1</literal> en <literal>A2</literal> te
      zien.  De mappenstructuur ziet er als volgend uit:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir1"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Een bestandssysteem moet gekoppeld worden in een map op een
      ander bestandssysteem.  Als nu bestandssysteem
      <literal>B</literal> wordt gekoppeld onder de map
      <literal>A1</literal> vervangt <literal>B</literal>
      <literal>A1</literal> en zien de koppelingen in
      <literal>B</literal> er als volgt uit:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir2"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Elk bestand dat in de mappen <literal>B1</literal> en
      <literal>B2</literal> aanwezig is, kan benaderd worden met het
      pad <filename>/A1/B1</filename> of <filename>/A1/B2</filename>.
      Elk bestand dat in <filename>/A1</filename> stond is tijdelijk
      verborgen en komt tevoorschijn als <literal>B</literal>is
      <firstterm>ontkoppeld</firstterm>van A.</para>

    <para>Als <literal>B</literal> gekoppeld is onder
      <literal>A2</literal> ziet de diagram er als volgt uit:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir3"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
        |
        +--- B1
        |
        `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>en de paden zouden dan respectievelijk
      <filename>/A2/B1</filename> en <filename>/A2/B2</filename>
      zijn.</para>

    <para>Bestandssystemen kunnen op elkaar worden gekoppeld.  Doorgaand
      op het vorige voorbeeld kan het bestandssysteem
      <literal>C</literal> gekoppeld worden bovenop de map
      <literal>B1</literal> in het bestandssysteem
      <literal>B</literal>.  Dit resulteert in:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir4"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
        |
        +--- B1
        |     |
        |     +--- C1
        |     |
        |     `--- C2
        |
        `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Of <literal>C</literal> kan direct onder het bestandssysteem
      <literal>A</literal> gekoppeld worden, onder de map
      <literal>A1</literal>:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir5"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
        |
        +--- B1
        |
        `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Hoewel het niet gelijk is, lijkt het op het gebruik van
      <command>join</command> in &ms-dos;.</para>

    <para>Beginnende gebruikers hoeven zich hier gewoonlijk niet mee
      bezig te houden.  Normaal gesproken worden bestandssystemen
      gemaakt als &os; wordt geïnstalleerd en er wordt
      besloten waar ze gekoppeld worden.  Meestal worden ze ook niet
      gewijzigd tot er een nieuwe schijf aan een systeem wordt
      toegevoegd.</para>

    <para>Het is mogelijk om één groot root
      bestandssysteem te hebben en geen andere.  Deze benadering
      heeft voordelen en nadelen.</para>

    <itemizedlist>
      <title>Voordelen van meerdere bestandssystemen</title>

      <listitem>
	<para>Verschillende bestandssystemen kunnen verschillende
	  <firstterm>mount opties</firstterm> hebben.  Met een goede
	  voorbereiding kan het root bestandssysteem bijvoorbeeld als
	  alleen-lezen gekoppeld worden, waardoor het onmogelijk wordt
	  om per ongeluk kritische bestanden te verwijderen of te
	  bewerken.  Het scheiden van andere bestandssystemen die
	  beschrijfbaar zijn door gebruikers, zoals
	  <filename>/home</filename> van andere bestandssystemen stelt
	  de beheerder in staat om ze <firstterm>nosuid</firstterm> te
	  koppelen.  Deze optie voorkomt dat
	  <firstterm>suid</firstterm>/<firstterm>guid</firstterm> bits
	  op uitvoerbare bestanden effectief gebruikt kunnen worden,
	  waardoor de beveiliging mogelijk beter wordt.</para>
      </listitem>

      <listitem>
	<para>&os; optimaliseert automatisch de layout van bestanden
	  op een bestandssysteem, afhankelijk van hoe het
	  bestandssysteem wordt gebruikt.  Een bestandsysteem dat veel
	  bestanden bevat waar regelmatig naar geschreven wordt, wordt
	  anders geoptimaliseerd dan een bestandssysteem dat minder
	  maar grotere bestanden bevat.  Door het gebruik van
	  één groot bestandssysteem werkt deze
	  optimalisatie niet.</para>
      </listitem>

      <listitem>
	<para>&os;'s bestandssystemen zijn erg robuust als er
	  bijvoorbeeld een stroomstoring is, hoewel een stroomstoring
	  op een kritiek moment nog steeds kan leiden tot schade aan de
	  structuur van het bestandssysteem.  Door het verdelen van
	  data over meerdere bestandssystemen, is de kans groter dat
	  het systeem nog opstart, wat terugzetten van een back-up
	  makkelijker maakt als dat nodig is.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Voordeel van één bestandssysteem</title>

      <listitem>
	<para>Bestandssystemen hebben een vaste grootte.  Als bij de
	  installatie van &os; een bestandssysteem wordt gemaakt, is
	  het later mogelijk dat de partitie groter gemaakt moet
	  worden.  Dit is niet zo makkelijk zonder een back-up, het
	  opnieuw maken van het bestandssysteem met gewijzigde grootte
	  en het terugzetten van de geback-upte gegevens.</para>

	<important>
	  <para>&os; heeft &man.growfs.8; waarmee de grootte van het
	    bestandssysteem is aan te passen terwijl het draait.</para>
	</important>
      </listitem>
    </itemizedlist>

    <para>Bestandssystemen worden opgeslagen in partities.  Dit
      betekent niet hetzelfde als de algemene betekenis van de term
      partitie (bijvoorbeeld, &ms-dos; partitie), vanwege &os;'s &unix;
      achtergrond.  Elke partitie wordt geïdentificeerd door een
      letter van <literal>a</literal> tot en met <literal>h</literal>.
      Elke partitie kan slechts één bestandssysteem
      hebben, wat betekent dat bestandssystem vaak omschreven worden
      aan de hand van hun koppelpunt in de bestandssysteem
      hiërarchie of de letter van de partitie waar ze in
      opgeslagen zijn.</para>

    <para>&os; gebruikt ook schijfruimte voor
      <firstterm>wisselbestanden</firstterm>.  Wisselbestanden geven
      &os; <firstterm>virtueel geheugen</firstterm>.  Dit geeft de
      computer de mogelijkheid om net te doen alsof er veel meer
      geheugen in de machine aanwezig is dan werkelijk het geval is.
      Als &os; geen geheugen meer heeft, verplaatst het data die op dat
      moment niet gebruikt wordt naar de wisselbestanden en plaatst het
      terug als het wel nodig is (en zet iets anders in ruil daarvoor
      terug).</para>

    <para>Aan sommige partities zijn bepaalde conventies
      gekoppeld.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*"/>

	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Partitie</entry>

	    <entry>Conventie</entry>
	  </row>
	</thead>

	<tbody valign="top">
	  <row>
	    <entry><literal>a</literal></entry>

	    <entry>Bevat meestal het root bestandssysteem</entry>
	  </row>

	  <row>
	    <entry><literal>b</literal></entry>

	    <entry>Bevat meestal de swapruimte</entry>
	  </row>

	  <row>
	    <entry><literal>c</literal></entry>

	    <entry>Heeft meestal dezelfde grootte als de hele harde
	      schijf.  Dit geeft hulpprogramma's de mogelijkheid
	      om op een complete schijf te werken (voor bijvoorbeeld een
	      bad block scanner) om te werken op de
	      <literal>c</literal> partitie.  Meest wordt hierop dan
	      ook geen bestandssysteem gecreeërd.</entry>
	  </row>

	  <row>
	    <entry><literal>d</literal></entry>

	    <entry>Partitie <literal>d</literal> had vroeger een
	      speciale betekenis, maar die is verdwenen.
	      <literal>d</literal> zou nu kunnen werken als een normale
	      partitie.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Elke partitie die een bestandssysteem bevat is opgeslagen
      in wat &os; noemt een <firstterm>slice</firstterm>.  Slice is
      &os;'s term voor wat meeste mensen partities noemen.  Dit komt
      wederom door &os;'s &unix; achtergrond.  Slices zijn genummerd
      van 1 tot en met 4.</para>

    <indexterm><primary>slices</primary></indexterm>

    <indexterm><primary>partities</primary></indexterm>

    <indexterm><primary>gevaarlijk toegewijd</primary></indexterm>

    <para>Slicenummers volgen de apparaatnamen, voorafgegaan door een
      <literal>s</literal> die begint bij 1.  Dus
      <quote>da0<emphasis>s1</emphasis></quote> is de eerste slice op
      de eerste SCSI drive.  Er kunnen maximaal vier fysieke slices op
      een schijf staan, maar er kunnen logische slices in fysieke
      slices van het correcte type staan.  Deze uitgebreide slices zijn
      genummerd vanaf 5.  Dus <quote>ad0<emphasis>s5</emphasis></quote>
      is de eerste uitgebreide slice op de eerste IDE schijf.  Deze
      apparaten worden gebruikt door bestandssystemen waarvan verwacht
      wordt dat ze een slice in beslag nemen.</para>

    <para>Slices, <quote>gevaarlijk toegewijde</quote> (dangerously
      dedicated) fysieke drivers en andere drives bevatten
      <firstterm>partities</firstterm>, die worden weergegeven door
      letters vanaf <literal>a</literal> tot <literal>h</literal>.
      Deze letter wordt achter de apparaatnaam geplakt.  Dus
      <quote>da0<emphasis>a</emphasis></quote> is de a partitie op de
      eerste da drive, die <quote>gevaarlijk toegewijd</quote> is.
      <quote>ad1s3<emphasis>e</emphasis></quote> is de vijfde partitie
      op de derde slice van de tweede IDE schijf.</para>

    <para>Elke schijf op het systeem wordt geïdentificeerd.  Een
      schijfnaam start met een code die het type aangeeft en dan een
      nummer dat aangeeft welke schijf het is.  In tegenstelling tot
      bij slices, start het nummeren van schijven bij 0.
      Standaardcodes staan beschreven in <xref linkend="basics-dev-codes"/>.</para>

    <para>Bij een referentie aan een partitie verwacht &os; ook dat
      de slice en schijf refereert naar die partitie en als naar een
      slice wordt verwezen moet ook de schijfnaam genoemd worden.  Dit
      kan door de schijfnaam, <literal>s</literal>, het slice nummer
      en de partitieletter aan te geven.  Voorbeelden staan in <xref linkend="basics-disk-slice-part"/>.</para>

    <para>In <xref linkend="basics-concept-disk-model"/> staat een
      conceptmodel van een schijflayout die een en ander
      verduidelijkt.</para>

    <para>Voordat &os; geïnstalleerd kan worden moeten eerst de
      schijfslices gemaakt worden en daarna moeten de partities op de
      slices voor &os; gemaakt worden.  Daarna wordt op elke
      partitie het bestandssysteem (of wisselbestand) gemaakt en als
      laatste wordt besloten waar het filesysteem gekoppeld wordt.</para>

    <table frame="none" pgwide="1" xml:id="basics-dev-codes">
      <title>Schijf apparaatcodes</title>

      <tgroup cols="2">
	<colspec colwidth="1*"/>

	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Code</entry>

	    <entry>Betekenis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><filename>ad</filename></entry>

	    <entry>ATAPI (IDE) schijf</entry>
	  </row>

	  <row>
	    <entry><filename>da</filename></entry>

	    <entry>SCSI directe toegang schijf</entry>
	  </row>

	  <row>
	    <entry><filename>acd</filename></entry>

	    <entry>ATAPI (IDE) CDROM</entry>
	  </row>

	  <row>
	    <entry><filename>cd</filename></entry>

	    <entry>SCSI CDROM</entry>
	  </row>

	  <row>
	    <entry><filename>fd</filename></entry>

	    <entry>Floppydisk</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <example xml:id="basics-disk-slice-part">
      <title>Voorbeeld schijf-, slice- en partitienamen</title>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>

	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Name</entry>

	      <entry>Betekenis</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>ad0s1a</literal></entry>

	      <entry>De eerste partitie (<literal>a</literal>) op de
		eerste slice (<literal>s1</literal>) op de eerste IDE
		schijf (<literal>ad0</literal>).</entry>
	    </row>

	    <row>
	      <entry><literal>da1s2e</literal></entry>

	      <entry>De vijfde partitie (<literal>e</literal>) op de
		tweede slice (<literal>s1</literal>) op de tweede SCSI
		schijf (<literal>da1</literal>).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </example>

    <example xml:id="basics-concept-disk-model">
      <title>Conceptmodel van een schijf</title>

      <para>Het onderstaande diagram geeft aan hoe &os; de eerste IDE
	schijf in het systeem ziet.  Stel dat de schijf 4&nbsp;GB groot
	is en dat deze twee 2&nbsp;GB slices (&ms-dos; partities)
	bevat.  De eerste slice bevat een &ms-dos; schijf,
	<filename>C:</filename> en de tweede slice bevat een &os;
	installatie.  Deze &os; installatie heeft drie partities en
	een partitie met een wisselbestand.</para>

      <para>De drie partities hebben elk een bestandssysteem.  Partitie
	<literal>a</literal> wordt gebruikt voor het root
	bestandssysteem, <literal>e</literal> voor de map
	<filename>/var</filename> en <literal>f</literal> voor de map
	<filename>/usr</filename>.</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/disk-layout"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">.-----------------.  --.
|                  |    |
|  DOS / Windows  |    |
:                  :     &gt;  Eerste slice, ad0s1
:                  :    |
|                  |    |
:=================:  ==:                                  --.
|                  |    |  Partitie a, gekoppeld als /    |
|                  |     &gt; gerefereerd als  ad0s2a         |
|                  |    |                                     |
:-----------------:  ==:                                    |
|                  |    |  Partitie b,  gebruikt als swap |
|                  |     &gt; gerefereerd als ad0s2b          |
|                  |    |                                     |
:-----------------:  ==:                                    |  Partitie c, geen
|                  |    |  Partition e, gebruikt als /var  &gt; bestandssysteem, bevat
|                  |     &gt; gerefereerd als ad0s2e          |  alle &os; slices,
|                  |    |                                     |  ad0s2c
:-----------------:  ==:                                    |
|                  |    |                                     |
:                  :    |  Partitie f, gebruikt als /usr  |
:                  :     &gt; gerefereerd als ad0s2f          |
:                  :    |                                     |
|                  |    |                                     |
|                  |  --'                                     |
`-----------------'                                        --'</literallayout>
	</textobject>
      </mediaobject>
    </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Het koppelen en ontkoppelen van bestandssystemen</title>

    <para>Het bestandssysteem wordt het best weergegeven als een boom,
      met de stam als <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename> en de andere
      map in root zijn takken die weer hun eigen takken kunnen hebben,
      zoals <filename>/usr/local</filename>, etc.</para>

    <indexterm><primary>root bestandssysteem</primary></indexterm>

    <para>Er zijn verschillende redenen om sommige van deze mappen
      op aparte bestandssystemen te plaatsen.
      <filename>/var</filename> bevat de mappen
      <filename>log/</filename>, <filename>spool/</filename> en
      verschillende types tijdelijke bestanden en kan volraken.  Het
      laten vollopen van het root bestandssysteem is geen goed idee,
      dus het splitsen van <filename>/var</filename> van
      <filename>/</filename>is vaak de favoriet.</para>

    <para>Een andere vaak voorkomende reden om bepaalde mapbomen
      op aparte bestandssystemen te plaatsen, is om ze op verschillende
      fysieke schrijven te zetten of gescheiden virtuele schijven zoals
      gemounte <link linkend="network-nfs">Netwerk bestandssystemen</link> of cd-rom
      drives.</para>

    <sect2 xml:id="disks-fstab">
      <title>Het bestand <filename>fstab</filename></title>

      <indexterm>
	<primary>bestandssystemen</primary>

	<secondary>gekoppeld met fstab</secondary>
      </indexterm>

      <para>Tijdens het <link linkend="boot">opstartproces</link>,
	worden bestandssystemen die vermeld staan in
	<filename>/etc/fstab</filename> automatisch gekoppeld
	(tenzij ze vermeld staan met <option>noauto</option>).</para>

      <para><filename>/etc/fstab</filename> bevat een lijst van regels
	die aan het volgende formaat voldoen:</para>

      <programlisting><replaceable>apparaat</replaceable>        <replaceable>/koppelpunt</replaceable> <replaceable>fstype</replaceable>     <replaceable>opties</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>apparaat</literal></term>

	  <listitem>
	    <para>Een apparaatnaam (die moet bestaan) zoals uitgelegd
	      in <xref linkend="disks-naming"/>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>koppelpunt</literal></term>

	  <listitem>
	    <para>Een map (die moet bestaan) waarop het bestandssysteem
	      gekoppeld moet worden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
	    <para>Het bestandssysteem type dat aan &man.mount.8;
	      gegeven wordt.  Het standaard &os; bestandssysteem is
	      <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>opties</literal></term>

	  <listitem>
	    <para>Dit is of <option>rw</option> voor lezen en
	      schrijven bestandssytemen, of <option>ro</option> voor
	      alleen lezen, gevolgd door elke andere optie die mogelijk
	      nodig is.  Een standaard optie is <option>noauto</option>
	      voor bestandssystemen die niet automatisch gekoppeld
	      worden tijdens het opstarten.  Andere opties staan in
	      &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem>
	    <para>Dit wordt gebruikt door &man.dump.8; om te bepalen
	      welke bestandssystemen gedumpt moeten worden.  Als het
	      veld niet is ingevuld, wordt aangenomen dat er een nul
	      staat.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem>
	    <para>Dit bepaalt in welke volgorde bestandssystemen
	      gecontroleerd moeten worden.  Bestandssystemen die
	      overgeslagen moeten worden moeten hun
	      <literal>passno</literal> waarde op nul hebben staan.
	      Voor het root bestandssysteem (dat voor alle andere
	      gecontroleerd moet worden) moet <literal>passno</literal>
	      op één staan en <literal>passno</literal>
	      waarden voor andere bestandssystemen moeten een waarde
	      hebben groter dan één.  Als bestandssysteem
	      dezelfde <literal>passno</literal> waarde hebben probeert
	      &man.fsck.8; deze bestandssystemen tegelijkertijd
	      te controleren.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>In &man.fstab.5; staat meer informatie over de opmaak van
	<filename>/etc/fstab</filename> en de mogelijke opties.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>Het commando <command>mount</command></title>

      <indexterm>
	<primary>bestandssystemen</primary>

	<secondary>koppelen</secondary>
      </indexterm>

      <para>&man.mount.8; wordt gebruikt om bestandsystemen te
	koppelen.</para>

      <para>De meest eenvoudige vorm is:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount apparaat koppelpunt</userinput></screen>
      </informalexample>

      <para>Alle opties voor het commando staat in &man.mount.8;, maar
	de meest voorkomende zijn:</para>

      <variablelist>
	<title>Mountopties</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Mount alle bestandssystemen die in
	      <filename>/etc/fstab</filename> staan, behalve die
	      gemarkeerd staan als <quote>noauto</quote>, uitgesloten
	      zijn door de optie <option>-t</option> of die al
	      gekoppeld zijn.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Doe alles behalve het echt aanroepen van de systeemopdracht
	      <command>mount</command>.  Deze optie is handig in samen met de
	      optie <option>-v</option> om te bepalen wat &man.mount.8;
	      eigenlijk probeert te doen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Forceert het koppelen van een niet schoon
	      bestandssysteem (gevaarlijk) of forceert het innemen van
	      schrijftoegang als de koppelstatus van een bestandssysteem
	      wijzigt van lezen en schrijven naar alleen lezen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Mount het bestandssysteem alleen lezen.  Dit is
	      identiek aan de optie <option>ro</option>
	      voor de optie <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Mount het opgegeven bestandssysteem als het opgegeven
	      type bestandssysteem of koppelt alleen bestandssystemen
	      van het aangegeven type als ook de optie
	      <option>-a</option> is opgegeven.</para>

	    <para><quote>ufs</quote> is het standaard
	      bestandssysteem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Werk koppel opties van het bestandssysteem bij.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geef uitgebreide informatie (verbose).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Mount het bestandssysteem lezen en schrijven.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>De optie <option>-o</option> accepteert een door komma's
	gescheiden lijst van opties, waaronder de volgende:</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Sta geen uitvoerbare bestanden toe op dit
	      bestandssysteem.  Ook dit is een nuttige
	      veiligheidsoptie.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Interpreteer geen setuid of setgid opties op het
	      bestandssysteem.  Ook dit is een nuttige
	      veiligheidsoptie.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Het commando <command>umount</command></title>

      <indexterm>
	<primary>bestandssystemen</primary>

	<secondary>ontkoppelen</secondary>
      </indexterm>

      <para>&man.umount.8; heeft een koppelpunt, een apparaatnaam,
	<option>-a</option> of <option>-A</option> als
	parameter.</para>

      <para>Alle vormen kunnen de optie <option>-f</option> hebben om
	een bestandsysteem te forceren te ontkoppelen en de optie
	<option>-v</option> voor uitgebreide informatie.  De optie
	<option>-f</option> is meestal geen goed idee.  Forceren dat
	een bestandssysteem ontkoppeld wordt kan de computer laten
	crashen of data op het bestandssysteem beschadigen.</para>

      <para>De opties <option>-a</option> en <option>-A</option>
	worden gebruikt om alle bestandssystemen te unmounten,
	mogelijk nader gespecificeerd door de optie <option>-t</option>
	met daarachter op welke typen bestandssystemen het betrekking
	heeft.  Voor de optie <option>-A</option> geldt dat deze niet
	probeert het root bestandssysteem te ontkoppelen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Processen</title>

    <para>&os; is een multi-tasking besturingssysteem.  Dit betekent
      dat het lijkt alsof er meer dan één proces
      tegelijkertijd draait.  Elk programma dat draait wordt een
      <firstterm>proces</firstterm> genoemd.  Elk commando dat wordt
      uitgevoerd start op zijn minst één nieuw proces en
      er zijn systeemprocessen die continu draaien om het systeem
      functioneel te houden.</para>

    <para>Elk proces wordt geïdentificeerd door een nummer dat
      <firstterm>process ID</firstterm> of <firstterm>PID</firstterm>
      heet, en net zoals bij bestanden heeft elk proces
      één eigenaar en groep.  De eigenaars- en
      groepsinformatie wordt gebruikt om te bepalen welke bestanden en
      apparaten het proces mag openen, waarbij gebruik wordt gemaakt
      van de bestandsrechten die eerder zijn behandeld.  Veel processen
      hebben ook een ouderproces (parent process).  Een ouderproces is
      een proces dat het nieuwe proces heeft gestart.  Als commando's
      in een shell worden ingevoerd, start de shell een proces en elk
      commando dat draait is ook een proces.  De uitzondering hierop is
      het speciale proces &man.init.8;.  <command>init</command> is
      altijd het eerste proces, dus het PID is altijd 1.
      <command>init</command> wordt automatisch gestart door de kernel
      als &os; opstart.</para>

    <para>Twee commando's die erg handig zijn om te zien welke
      processen er draaien zijn &man.ps.1; en &man.top.1;.
      <command>ps</command> wordt gebruikt om een statische lijst op te
      vragen van de processen die op het moment van uitvoeren draaien
      en kan hun PID, geheugengebruik, de startende commandoregel,
      enzovoort, tonen.  <command>top</command> geeft alle draaiende
      processen weer en werkt de status elke paar seconden bij zodat
      interactief wordt weergegeven wat een computer aan het doen
      is.</para>

    <para>Standaard laat <command>ps</command> alleen zien welke
      commando's draaien waarvan de gebruiker die het uitvoert de
      eigenaar is:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>In het bovenstaande voorbeeld is de uitvoer van &man.ps.1;
      georganiseerd in een aantal kolommen.  <literal>PID</literal>
      is het proces ID.  PIDs worden toegekend vanaf 1 en lopen op tot
      99999.  Als ze allemaal zijn gebruikt, worden ze hergebruikt.
      (een PID wordt niet hergebruikt als deze reeds in gebruik is).  De
      <literal>TT</literal> kolom toont de tty vanwaar het programma
      draait en wordt nu buiten beschouwing gelaten.
      <literal>STAT</literal> toont de huidige staat van het programma
      en ook deze kolom wordt buiten beschouwing gelaten.
      <literal>TIME</literal> is de hoeveelheid tijd die het programma
      gedraaid heeft op de CPU.  Dit is meestal niet de verstreken
      tijd vanaf het moment dat het programma is gestart.  Veel
      programma's wachten omdat er alleen gebruik wordt gemaakt van de
      CPU als er iets voor het programma te doen is.  Als laatste is
      <literal>COMMAND</literal> de commandoregel die gebruikt is
      om het programma te starten.</para>

    <para>&man.ps.1; ondersteunt een aantal opties die de informatie
      wijzigen die wordt weergegeven.  Één van de meest
      nuttige combinaties is <literal>auxww</literal>.  De optie
      <option>a</option> toont informatie over alle draaiende
      processen, niet alleen die van de gebruiker die is aangemeld.  De
      optie <option>u</option> toont de gebruikersnaam van de
      proceseigenaar, evenals geheugengebruik.  De optie
      <option>x</option> toont informatie over daemonprocessen en met
      de optie <option>ww</option> laat &man.ps.1; de volledige
      commandoregel zien voor elk proces, in plaats van een mogelijk
      afgekorte regel omdat die te lang is om op het scherm te
      passsen.</para>

    <para>De uitvoer van &man.top.1; is hetzelfde:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik	28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik	2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik	2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik	2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik	2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root	2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik	2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>De uitvoer is gesplitst in twee secties.  De kop (de eerste
      vijf regels) toont het laatst uitgegeven PID, de gemiddelde
      systeembelasting (hoe druk is een systeem), de uptime van het
      systeem (tijd verstreken sinds laatste reboot) en de huidige
      tijd.  De andere cijfers in de kop tonen hoeveel processen er
      draaien (in dit geval 47) , hoeveel geheugen en swap er gebruikt
      wordt en hoeveel processortijd het systeem besteed aan
      verschillende taakgroepen.</para>

    <para>Daaronder staat een serie van kolommen die soortgelijke
      informatie bevatten als de uitvoer van &man.ps.1;.  Zo zijn het
      PID, de gebruikersnaam, de hoeveelheid processortijd en het
      commando dat gebruikt is om het proces te starten te zien.
      &man.top.1; laat standaard ook zien hoeveel geheugen er gebruikt
      wordt door een proces.  Dit staat in twee kolommen waarbij in de
      eerste kolom het maximale geheugengebruik wordt getoond en in de
      tweede kolom het huidige geheugengebruik.  Maximale gebruik is
      de hoeveelheid geheugen die het proces nodig had in de tijd dat
      het bestaat en het residente gebruik is hoeveel er op het moment
      van weergeven gebruikt wordt.  In dit voorbeeld is zichtbaar dat
      <application>&netscape;</application> bijna 30&nbsp;MB RAM nodig
      had, maar op het moment van uitvoeren 9&nbsp;MB verbruikt.</para>

    <para>&man.top.1; werkt het beeld automatisch iedere twee seconden
      bij.  Dat kan gewijzigd worden met de optie
      <option>s</option>.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Daemons, signalen en het stoppen van processen</title>

    <para>Als een gebruiker een editor draait is het makkelijk om de
      editor te besturen, te vertellen om bestanden te openen, etc.
      Dit kan omdat de editor de mogelijkheden geeft om dat te doen en
      omdat de editor gekoppeld is aan een
      <firstterm>terminal</firstterm>.  Sommige programma's zijn niet
      ontworpen om te draaien met continue gebruikersinvoer, dus
      als zij de kans krijgen ontkoppelen zij zich van de terminal.
      Een webserver reageert bijvoorbeeld de hele dag op webaanvragen
      en heeft eigenlijk geen input van een lokale gebruiker nodig.
      Programma's die email van locatie naar locatie transporteren zijn
      een ander voorbeeld.</para>

    <para>Deze programma's heten <firstterm>daemons</firstterm>.
      Daemons waren karakters in de Griekste mythologie, goed noch
      slecht, ze waren dienende geesten die op grote schaal nuttige
      dingen deden voor de mensheid.  Net zoals de huidige webservers
      en mailservers nuttige dingen doen.  Dit is waarom de mascotte
      voor BSD al lang een vrolijk kijkende daemon met puntoren en een
      drietand is.</para>

    <para>Er is een overeenkomst om programma's die meestal draaien als
      daemon te voorzien van het achtervoegsel <quote>d</quote>.
      <application>BIND</application> is de Berkeley Internet Name
      Domain (het echte programma heet <command>named</command>), de
      <application>Apache</application> webserver heet
      <command>httpd</command>, de printerspooldriver heet
      <command>lpd</command>, etc.  Deze overeenkomst geldt niet
      altijd.  De hoofd maildaemon voor
      <application>Sendmail</application> heet bijvoorbeeld
      <command>sendmail</command> en niet
      <command>maild</command>.</para>

    <para>Soms is communicatie met een daemon nodig.  Een manier om dit te
      doen is het versturen van een signaal (<firstterm>signals</firstterm>).
      Er zijn een verschillende signalen.  Sommige hebben een specifieke
      bedoeling, andere worden geïntrepeteerd door de applicatie.
      In de documentatie van de applicatie staat hoe de applicatie
      signalen intrepeteert.  Er kan alleen een signaal naar een proces
      gezonden worden waar de uitvoerende gebruiker eigenaar van is.
      Als met &man.kill.1; of &man.kill.2; een signaal naar een proces
      van een andere gebruiker wordt gestuurd, wordt de toegang
      geweigerd.  De enige uitzondering hierop is de
      <systemitem class="username">root</systemitem> gebruiker, die signalen naar processen
      van alle gebruikers kan sturen.</para>

    <para>&os; stuurt soms ook signalen naar applicaties.  Als een
      applicatie slecht geschreven is en hij probeert geheugen te
      benaderen waar hij niet naartoe mag, stuurt &os; het proces een
      <firstterm>Segmentation Violation</firstterm> signaal
      (<literal>SIGSEGV</literal>).  Als een applicatie de
      systeemaanroep &man.alarm.3; heeft gebruikt om na een bepaalde
      periode een alarm te ontvangen, wordt er een Alarm signaal
      heen gestuurd (<literal>SIGALRM</literal>), etc.</para>

    <para>Twee signalen kunnen gebruikt worden om een proces te
      stoppen: <literal>SIGTERM</literal> en
      <literal>SIGKILL</literal>.  <literal>SIGTERM</literal> is de
      nette manier om een proces te killen.  Het proces kan het signaal
      <emphasis>afvangen</emphasis>, begrijpen dat de eigenaar wil dat
      het wordt afgesloten, wellicht logboekbestanden sluiten die
      geopend zijn en alle onderhanden activiteiten afhandelen.  In een
      aantal gevallen kan een proces <literal>SIGTERM</literal>
      negeren: als het midden in een taak zit die niet beëindigd
      kan worden.</para>

    <para><literal>SIGKILL</literal> mag niet worden genegeerd door een
      proces.  Dit is het <quote>Wat je ook aan het doen bent, stop er
	nu mee</quote> signaal.  Na een <literal>SIGKILL</literal>
      stopt &os; het proces meteen.
      <footnote>
	<para>Dit is niet geheel waar.  Er zijn een aantal dingen
	  die niet onderbroken kunnen worden.  Als het proces
	  bijvoorbeeld een bestand probeert uit te lezen dat op een
	  andere computer in het netwerk staat en de andere computer
	  is verdwenen (uitgezet of het netwerk heeft een fout), dan
	  wordt er gezegd dat het proces niet
	  <quote>onderbroken</quote> kan worden.  Uiteindelijk loopt
	  het proces uit de tijd, meestal na twee minuten.  Zodra het
	  uit de tijd loopt, wordt het proces alsnog
	  gestopt.</para></footnote></para>

    <para>Andere veelgebruikte signalen zijn <literal>SIGHUP</literal>,
      <literal>SIGUSR1</literal> en <literal>SIGUSR2</literal>.  Dit
      zijn algemeen bruikbare signalen en verschillende applicaties
      zullen verschillend reageren als ze verstuurd worden.</para>

    <para>Stel dat het bestand met instellingen voor de webserver is
      aangepast.  Dan moet aan de webserver verteld worden dat die de
      instellingen opnieuw moet lezen.  Hiervoor zou
      <command>httpd</command> gestopt en gestart kunnen worden, maar
      dit resulteert in een korte onderbreking van de webserverdienst,
      wat ongewenst kan zijn.  De meeste daemons zijn geschreven om te
      reageren op het <literal>SIGHUP</literal> signaal door het
      opnieuw inlezen van het instellingenbestand.  Dus in plaats van
      het stoppen en herstarten van <command>httpd</command> kan het
      <literal>SIGHUP</literal> signaal gezonden worden.  Omdat er geen
      standaard manier is om op deze signalen te reageren, reageren
      verschillende daemons anders.  Het is verstandig eerst de
      documentatie van de daemon in kwestie te lezen.</para>

    <para>Zoals onderstaand voorbeeld laat zien, worden signalen door
      &man.kill.1; verzonden.</para>

    <procedure>
      <title>Het versturen van een signaal naar een proces</title>

      <para>Dit voorbeeld toont hoe een signaal naar &man.inetd.8;
	wordt verstuurd.  Het bestand met instellingen voor
	<command>inetd</command> is
	<filename>/etc/inetd.conf</filename> en
	<command>inetd</command> leest dit bestand opnieuw in als er
	een <literal>SIGHUP</literal> wordt verstuurd.</para>

      <step>
	<para>Eerst moet het proces ID worden opgezocht van het proces
	  waar een signaal naar verzonden moeten worden.  Dit kan door
	  &man.pgrep.1; te gebruiken.</para>

	<screen>&prompt.user; <userinput>pgrep -l inetd</userinput>
198  inetd -wW</screen>

	<para>Dus het PID van &man.inetd.8; is 198.</para>
      </step>

      <step>
	<para>Met &man.kill.1; kan het signaal verzonden worden.  Omdat
	  &man.inetd.8; wordt gedraaid door <systemitem class="username">root</systemitem>
	  moet &man.su.1; gebruikt worden om <systemitem class="username">root</systemitem>
	  te worden.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Zoals zovaak met &unix; commando's, geeft &man.kill.1;
	  geen uitvoer als het succesvol uitgevoerd is.  Als een
	  signaal wordt verzonden naar een proces waarvan de gebruiker
	  niet zelf de eigenaar is, dan is de melding: <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname>.  Als het PID verkeerd wordt
	  ingevuld, wordt het signaal naar het verkeerde proces
	  verzonden, wat slecht kan zijn, of, als de gebruiker geluk
	  heeft, wordt het verzonden naar een PID dat momenteel niet in
	  gebruik is, waarop de foutmelding <errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>
	  verschijnt.</para>

	<note>
	  <title>Waarom <command>/bin/kill</command> gebruiken?</title>

	  <para>Veel shells leveren <command>kill</command> als
	    ingebouwd commando.  Dat betekent dat de shell het
	    signaal direct verstuurt in plaats van door het starten van
	    <filename>/bin/kill</filename>.  Dit kan erg nuttig zijn,
	    maar verschillende shells hebben een verschillende
	    opdrachtregel voor het specificeren van de naam van het
	    signaal dat verstuurd moet worden.  In plaats van ze
	    allemaal te leren, is het eenvoudiger om gewoon
	    <command>/bin/kill PID</command>
	    te gebruiken.</para>
	</note>
      </step>
    </procedure>

    <para>Andere signalen versturen werkt bijna hetzelfde door
      <literal>TERM</literal> of <literal>KILL</literal> op de
      commandoregel te vervangen door wat nodig is.</para>

    <important>
      <para>Het stoppen van willekeurige processen op een systeem is
	meestal een slecht idee.  In het bijzonder bij &man.init.8; met
	proces ID 1.  Het draaien van <command>/bin/kill -s KILL
	  1</command> is een snelle manier om een systeem uit te
	zetten.  Argumenten die aan &man.kill.1; worden meegegeven
	moeten <emphasis>altijd</emphasis> twee keer gecontroleerd
	worden <emphasis>voordat</emphasis> op <keycap>Enter</keycap>
	gedrukt wordt.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells</title>

    <indexterm><primary>shells</primary></indexterm>

    <indexterm><primary>commandoregel</primary></indexterm>

    <para>In &os; wordt een groot deel van het alledaagse werk
      gedaan vanuit een omgeving met een commandoregel die shell heet.
      De grootste taak van een shell is om commando's van het
      invoerkanaal op te vangen en deze uit te voeren.  Veel shells
      hebben ook functies ingebouwd om mee te helpen om alledaagse
      taken zoals bestandsbeheer, bestandsglobbing, bestanden wijzigen
      vanaf de commandoregel, commandomacro's schrijven en uitvoeren en
      omgevingsvariabelen instellen en wijzigen.  &os; heeft een aantal
      shells bijgeleverd zoals <command>sh</command>, de Bourne Shell
      en <command>tcsh</command>, de verbeterde C-shell.  Er zijn veel
      andere shells beschikbaar in de &os; Portscollectie zoals
      <command>zsh</command> en <command>bash</command>.</para>

    <para>Welke shell gebruiken? Dit is een kwestie van smaak.  Een
      C&ndash;programmeur voelt zich misschien prettiger bij een
      C&ndash;achtige shell, zoals <command>tcsh</command>.  Een
      voormalig &linux; gebruiker of iemand die niet veel ervaring
      heeft met een &unix; commandoregel interface wil misschien
      <command>bash</command> proberen.  Elke shell heeft zijn eigen
      unieke eigenschappen die wel of niet werken voor een bepaalde
      gebruiker.</para>

    <para>Een standaard optie in een shell is bestandsnaam completie.
      Door het intikken van de eerste paar letters van een commando of
      bestandsnaam, kan de shell opdracht gegeven worden om automatisch
      de rest het commando of bestandsnaam toe te voegen met de
      <keycap>Tab</keycap> toets op het toetsenbord.  Stel dat er twee
      bestanden zijn met de namen <filename>foobar</filename> en
      <filename>foo.bar</filename> en <filename>foo.bar</filename> moet
      verwijderd worden.  Dan kan op het toetsenbord
      <command>rm fo[Tab].[Tab]</command>
      ingevoerd worden.</para>

    <para>De shell geeft <command>rm foo[BEEP].bar</command>
      weer.</para>

    <para>De [BEEP] geeft aan dat de shell in staat was om de
      bestandsnaam te completeren omdat er meer dan één
      soortgelijk bestand was.  <filename>foobar</filename> en
      <filename>foo.bar</filename> beginnen met <literal>fo</literal>,
      maar het was in staat om het af te maken tot
      <literal>foo</literal>.  Na het invoeren van een
      <literal>.</literal> en daarna <keycap>Tab</keycap>, is de shell
      in staat om de rest van de bestandsnaam aan te vullen.</para>

    <indexterm><primary>omgevingsvariabelen</primary></indexterm>

    <para>Een andere optie van de shell is het gebruik van
      omgevingsvariabelen.  Omgevingsvariabelen zijn variabele
      sleutelparen die opgeslagen zijn in de omgevingsruimte van een
      shell.  Deze ruimte kan uitgelezen worden door elk programma
      dat door de shell wordt uitgevoerd en bevat dus veel
      programmainstellingen.  Hieronder staat een lijst van standaard
      omgevingsvariabelen en wat ze betekenen:</para>

    <indexterm><primary>omgevingsvariabelen</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variabele</entry>

	    <entry>Omschrijving</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>

	    <entry>Gebruikersnaam van de gebruiker die is
	      aangemeld.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>

	    <entry>Een lijst van mappen, gescheiden door een
	      <literal>:</literal> voor het zoeken naar binaire
	      bestanden.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>

	    <entry>Netwerknaam van het X11 scherm om verbinding mee
	      te maken, indien beschikbaar.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>

	    <entry>De huidige shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>

	    <entry>De naam van de huidige gebruikersterminal.
	      Gebruikt om de mogelijkheden van de terminal te
	      bepalen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>

	    <entry>Databaseregel met terminal escape codes voor het
	      uitvoeren van diverse terminalfuncties.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>

	    <entry>Type besturingssysteem, bijvoorbeeld &os;.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>

	    <entry>De CPU architectuur waar het systeem op
	      draait.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>

	    <entry>De teksteditor waar de gebruiker de voorkeur aan
	      geeft.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>

	    <entry>De tekstpager waar de gebruiker de voorkeur aan
	      geeft.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>

	    <entry>Lijst van mappen gescheiden door een
	      <literal>:</literal> voor het zoeken naar
	      handleidingen.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>

    <para>Het instellen van omgevingsvariabelen verschilt van shell tot
      shell.  In de C&ndash;achtige shells zoals
      <command>tcsh</command> en <command>csh</command> moet
      <command>setenv</command> gebruikt worden om omgevingsvariabelen
      in te stellen.  In Bourne-shells zoals <command>sh</command> en
      <command>bash</command> moet <command>export</command> gebruikt
      worden om de omgevingsvariabelen in te stellen.  Om bijvoorbeeld
      de omgevingsvariabele <envar>EDITOR</envar> te wijzigen naar
      <filename>/usr/local/bin/emacs</filename> onder
      <command>csh</command> of <command>tcsh</command> moet het
      volgende gedaan worden:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>In Bourne shells is dat:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Met de meeste shells kunnen de omgevingsvariabelen ook
      weergegeven worden door een <literal>$</literal> karakter voor
      de variabelenaam te plaatsen op de commandoregel.
      <command>echo $TERM</command> zou weergeven wat er in
      <envar>$TERM</envar> gezet is, omdat de shell
      <envar>$TERM</envar> uitbreid en het resultaat doorgeeft aan
      <command>echo</command>.</para>

    <para>Shells kennen veel speciale karakters, die meta-karakters
      heten, als speciale weergaves van data.  De meest voorkomende is
      het karakter <literal>*</literal> karakter, dat elk
      karakter in een bestandsnaam voorstelt.  Deze speciale
      meta-karakters kunnen gebruikt worden om bestandsnaamglobbing te
      doen.  Door bijvoorbeeld <command>echo *</command> in te voeren,
      is het resultaat bijna hetzelfde als door het uitvoeren van
      <command>ls</command>, omdat de shell alle bestanden die
      van toepassing zijn aan echo geeft om ze daarna te tonen.</para>

    <para>Om te voorkomen dat de shell deze speciale tekens
      verwerkt, kunnen ze uitgeschakeld worden door er het backslash
      karakter (<literal>\</literal>) voor te plaatsen.
      <command>echo $TERM</command> print de inhoud van TERM naar het
      scherm.  <command>echo \$TERM</command> print $TERM zoals het
      geschreven is.</para>

    <sect2 xml:id="changing-shells">
      <title>Shell wijzigen</title>

      <para>De makkelijkste manier om de shell te wijzigen is
	door het <command>chsh</command> commando te gebruiken.
	Door <command>chsh</command> te starten wordt de editor gestart
	die in de <envar>EDITOR</envar> omgevingsvariable staat.  Als
	deze niet is ingesteld, wordt <application>vi</application>
	gestart.  In de editor kan de regel waarop
	<quote>Shell:</quote> staat gewijzigd worden.</para>

      <para>Aan <command>chsh</command> kan ook de optie
	<option>-s</option> meegegeven worden.  Dit stelt de shell in,
	zonder dat een editor gebruikt hoeft te worden.  Als de shell
	bijvoorbeeld gewijzigd moet worden in <command>bash</command>,
	kan dat als volgt:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>De te gebruiken shell <emphasis>moet</emphasis>
	  geregistreerd zijn in <filename>/etc/shells</filename>.  Als
	  een shell uit de <link linkend="ports">Portscollectie</link>
	  is geïnstalleerd, is dit meestal automatisch gebeurd.
	  Als de shell met de hand is geïnstalleerd moet het
	  onderstaande gedaan worden.</para>

	<para>Als bijvoorbeeld <command>bash</command> met de hand
	  geïnstalleerd is in <filename>/usr/local/bin</filename>,
	  dient het onderstaande te gebeuren:</para>

	<screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

	<para>Hierna kan <command>chsh</command> weer gedraaid
	  worden.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Teksteditors</title>

    <indexterm><primary>teksteditors</primary></indexterm>

    <indexterm><primary>editors</primary></indexterm>

    <para>Een groot deel van de instellingen in &os; wordt gemaakt door
      het bewerken van tekstbestanden.  Hierdoor is het een goed
      idee om bekend te zijn met een tekstverwerker.  &os; heeft er een
      paar in het basissysteem en veel anderen zijn beschikbaar via de
      Portscollectie.</para>

    <indexterm><primary><command>ee</command></primary></indexterm>

    <indexterm>
      <primary>editors</primary>

      <secondary>ee</secondary>
    </indexterm>

    <para>De makkelijkste en simpelste editor om te leren is de editor
      <application>ee</application>, wat <quote>easy editor</quote>
      betekent.  Om <application>ee</application> te starten, moet op
      de commandoregel <command>ee
	bestandsnaam</command> ingevoerd
      worden, waar <replaceable>bestandsnaam</replaceable> de naam is
      van het bestand dat bewerkt moet worden.  Om bijvoorbeeld
      <filename>/etc/rc.conf</filename> te bewerken, wordt
      <command> ee /etc/rc.conf</command> ingegeven.  Eenmaal in
      <command>ee</command> worden alle manipulatie commando's die de
      editor heeft weergegeven aan de bovenkant van het scherm.  Het
      karakter dakje <literal>^</literal> staat voor de toets
      <keycap>CTRL</keycap> op het toetsenbord, dus
      <literal>^e</literal> vormt de toetscombinatie <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap>
	</keycombo>.
      Om uit <application>ee</application> te komen wordt op de toets
      <keycap>Esc</keycap> gedrukt en daar kan gekozen worden om de
      editor te verlaten.  De editor vraagt dan of de wijzigingen
      bewaard moeten worden als het bestand veranderd is.</para>

    <indexterm><primary><application>vi</application></primary></indexterm>

    <indexterm>
      <primary>editors</primary>

      <secondary><application>vi</application></secondary>
    </indexterm>

    <indexterm><primary><application>Emacs</application></primary></indexterm>

    <indexterm>
      <primary>editors</primary>

      <secondary><application>Emacs</application></secondary>
    </indexterm>

    <para>&os; heeft ook uitgebreidere tekstverwerkers, zoals
      <application>vi</application>, in het basissysteem en andere
      editors als <application>Emacs</application> en
      <application>vim</application> maken onderdeel uit van de &os;
      Portscollectie (<package>editors/emacs</package>
      en <package>editors/vim</package>).  Deze
      editors leveren veel meer functionaliteit en kracht maar zijn
      lastiger om te leren.  Als echter veel met tekstverwerking gedaan
      wordt, is het leren van een krachtige editor als
      <application>vim</application> of
      <application>Emacs</application> verstandig omdat deze
      uiteindelijk veel tijd kan besparen.</para>

    <para>Veel applicaties die bestanden wijzigen of getypte invoer
      nodig hebben zullen automatisch een tekstverwerker openen.  Om de
      tekstverwerker te wijzigen die standaard wordt gebruikt, stelt u
      de omgevingsvariabele <envar>EDITOR</envar> in.  Zie de sectie
      <link linkend="shells">shells</link> voor meer details.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Apparaten en apparaatnodes</title>

    <para>Apparaat is een term die meestal wordt gebruikt
      voor hardwareonderdelen in een systeem, zoals schijven, printers
      grafische kaarten en toetsenborden.  Als &os; opstart laat het
      vooral zien welke apparaten gedetecteerd worden.  Deze
      opstartmeldingen kunnen nagekeken worden door het bestand
      <filename>/var/run/dmesg.boot</filename> te bekijken.</para>

    <para><filename>acd0</filename> is bijvoorbeeld de eerste IDE
      cd-rom drive, terwijl <filename>kbd0</filename> staat voor
      het toetsenbord.</para>

    <para>Veel van deze apparaten moeten in een &unix;
      besturingssysteem benaderd worden via speciale bestanden die
      apparaatnodes heten en te vinden zijn in de map
      <filename>/dev</filename>.</para>

    <sect2>
      <title>Apparaatnodes maken</title>

      <para>Als een nieuw apparaat wordt toegevoegd aan een systeem of
	als ondersteuning voor extra apparaten wordt gecompileerd, dan
	moeten er misschien nieuwe apparaat nodes aangemaakt worden.</para>

      <sect3>
	<title><literal>DEVFS</literal> (apparaatbestandssysteem -
	  DEVice File System)</title>

	<para> Het apparaatbestandssysteem of <literal>DEVFS</literal>,
	  levert toegang tot de apparaatruimte van de kernel in het
	  globale bestandssysteem.  In plaats van dat het nodig is om
	  apparaatnodes te maken en te wijzigen, doet
	  <literal>DEVFS</literal> dit.</para>

	<para>In &man.devfs.5; staat meer informatie.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">
    <title>Binaire formaten</title>

    <para>Om te kunnen begrijpen waarom &os; gebruik maakt van
      het &man.elf.5; formaat, is het belangrijk op de hoogte zijn
      van de drie <quote>dominante</quote> uitvoerbare formaten voor
      &unix;:</para>

    <itemizedlist>
      <listitem>
	<para>&man.a.out.5;</para>

	<para>Het oudste en <quote>klassieke</quote> &unix; object
	  formaat.  Het gebruikt een korte en compacte kop met een
	  magisch nummer aan het begin dat veel gebruikt wordt
	  om het formaat aan te geven (&man.a.out.5; geeft meer
	  details).  Het bevat drie laadbare segmenten: .tekst, .data
	  en .bss, een symbolentabel en een stringtabel.</para>
      </listitem>

      <listitem>
	<para><acronym>COFF</acronym></para>

	<para>Het SVR3 object formaat.  De kop bestaat uit een
	  sectietabel, dus er kunnen meer dan alleen .tekst, .data,
	  en .bss secties zijn.</para>
      </listitem>

      <listitem>
	<para>&man.elf.5;</para>

	<para>De opvolger van <acronym>COFF</acronym>, heeft
	  meerdere secties en 32-bit of 64-bit als mogelijke waarden.
	  Één nadeel: <acronym>ELF</acronym> was ook
	  ontworpen met de aanname dat er maar één
	  ABI per systeemarchitectuur zou zijn.  Deze aanname is
	  eigenlijk redelijk incorrect, zelfs niet in de
	  commerciële SYSV wereld (die op zijn minst drie ABIs
	  heeft: SRV4, Solaris en SCO).</para>

	<para>&os; probeert om dit probleem heen te werken door
	  een hulpprogramma te leveren voor het
	  <emphasis>brandmerken</emphasis> van een bekend
	  <acronym>ELF</acronym> uitvoerbaar bestand met informatie
	  over de ABI waar hij mee kan werken.  In &man.brandelf.1;
	  staat meer informatie.</para>
      </listitem>
    </itemizedlist>

    <para>&os; komt uit het <quote>klassieke</quote> kamp en gebruikt
      het &man.a.out.5; formaat, een technologie die zich bewezen heeft
      door meerdere generaties van BSD versies heen, tot het begin van
      de 3.X versies.  Alhoewel het al mogelijk was om
      <acronym>ELF</acronym> programma's en kernels te bouwen en te
      draaien op een &os; systeem , verzette &os; zich eerst tegen de
      druk om over te schakelen naar <acronym>ELF</acronym> als
      standaard formaat.  Waarom?  Toen het &linux; kamp hun pijnlijke
      wissel maakte naar <acronym>ELF</acronym>, was dat niet zozeer
      om van het <filename>a.out</filename> formaat af te komen, maar
      meer omdat van het op de inflexibele jump-tabel gebaseerde
      gedeelde bibliotheekmechanisme af te komen, die het maken van
      gedeelde bibliotheken erg moeilijk maakte voor bedrijven en
      ontwikkelaars.  Omdat de <acronym>ELF</acronym> hulprogramma's
      een oplossing voor het gedeelde bibliotheek probleem waren en
      algemeen gezien werden als een <quote>stap vooruit</quote>,
      werd de migratie geaccepteerd als noodzakelijk kwaad en werd de
      wissel uitgevoerd.  Het gedeelde bibliotheek mechanisme van &os;
      is meer gebaseerd op het gedeelde bibliotheek mechanisme van
      Sun's &sunos; en daardoor erg makkelijk te gebruiken.</para>

    <para>Waarom zijn er zoveel verschillende formaten?</para>

    <para>In het duistere donkere verleden was er simpele hardware.
      Deze simpele hardware ondersteunde een simpel klein systeem.
      <filename>a.out</filename> was volledig adequaat voor de taak om
      binaire bestanden op dat simpele systeem te vertegenwoordigen
      (een PDP-11).  Toen mensen &unix; van deze machine gingen porten,
      behielden ze het <filename>a.out</filename> formaat omdat het
      voldeed voor de vroege ports van &unix; naar architecturen
      als Motorola 68k, VAXen, enzovoort.</para>

    <para>Toen besloot een slimme hardware engineer dat als hij de
      software kon forceren om wat simpele truckjes te doen, hij in
      staat was om een paar onderdelen van het ontwerp af te schaven,
      waardoor zijn processorcore sneller kon draaien.  Terwijl men
      probeerde om het met deze nieuwe vorm van hardware te laten
      werken (vandaag de dag beter bekend als <acronym>RISC</acronym>),
      was <filename>a.out</filename> te beperkt voor deze hardware.
      Dus werden er vele formaten ontworpen om betere prestaties te
      krijgen uit deze hardware dan het simpele formaat
      <filename>a.out</filename> kon leveren.  Toen werden
      <acronym>COFF</acronym>, <acronym>ECOFF</acronym> en een paar
      andere duistere formaten uitgevonden en werden de limieten
      verkend, waarna men besloot om zich te richten op
      <acronym>ELF</acronym>.</para>

    <para>Daarnaast werden programma's groter en bleven schijven (en
      fysiek geheugen) relatief klein, zodat het concept van een
      gedeelde bibliotheek werd geboren.  Het VM systeem werd ook meer
      verfijnd.  Terwijl al deze verbeteringen bereikt werden door het
      <filename>a.out</filename> formaat, werd het nut met elke nieuwe
      eigenschap verder uitgerekt.  Daarnaast wilde men dingen
      dynamisch laden tijdens het starten of delen weggooien nadat het
      programma zijn intiële code had gedraaid om te blijven
      hangen in het hoofdgeheugen en in de wisselbestanden.  Talen
      werden verder verfijnd en men wilde dat code automatisch werd
      aangeroepen voor main.  Er werden veel hacks gedaan in het
      <filename>a.out</filename> formaat om alles mogelijk te maken en
      dit werkte ook enige tijd.  Na verloop van tijd was
      <filename>a.out</filename> niet meer in staat om alle problemen
      te adresseren zonder toenemende overhead in code en
      complexibiliteit.  Hoewel <acronym>ELF</acronym> veel van deze
      problemem verhielp, was het moeilijk om te wisselen naar een
      systeem dat compleet anders werkte.  Dus moest
      <acronym>ELF</acronym> wachten totdat het pijnlijker was om
      <filename>a.out</filename> te behouden dan het te migreren naar
      <acronym>ELF</acronym>.</para>

    <para>Met het verstrijken van de tijd, werden de bouwprogramma's
      die &os; heeft afgeleid van hun bouwprogramma's (vooral de
      assembler en de loader) ontwikkeld in twee parallel lopende
      takken.  De &os; tree voegde gedeelde bibliotheken toe en heeft
      wat bugs opgelost.  De mensen van GNU die deze programma's hebben
      geschreven, hebben ze herschreven en simpelere ondersteuning
      toegevoegd voor het bouwen van cross-compilers, waarbij
      verschillende formaten zo nodig ingevoegd konden worden,
      enzovoort.  Omdat veel mensen cross-compilers wilden bouwen die
      gericht waren op &os;, hadden die pech, omdat de oudere broncode
      van &os; voor <application>as</application> en
      <application>ld</application> niet opgewassen was tegen deze
      taak.  De nieuwe GNU programmaketen
      (<application>binutils</application>) ondersteunt
      cross-compiling, <acronym>ELF</acronym>, gedeelde bibliotheken,
      C++&nbsp;extensies, enzovoort.  Daarnaast leveren veel
      leverancierds <acronym>ELF</acronym> binaire bestanden en is het
      goed voor &os; om het te draaien.</para>

    <para><acronym>ELF</acronym> heeft meer expressiemogelijkheden dan
      <filename>a.out</filename> en geeft meer
      uitbreidingsmogelijkheden aan het basissysteem.  De
      <acronym>ELF</acronym> hulpprogramma's worden beter onderhouden
      en geven de mogelijkheid tot ondersteuning voor cross compilatie,
      wat voor veel mensen belangrijk is.  <acronym>ELF</acronym> is
      misschien iets trager dan <filename>a.out</filename>, maar
      het meten daarvan kan vrij lastig zijn.  Er zijn ook ontelbare
      verschillen tussen de twee in hoe ze pages opslaan,
      initiële code verwerken, enzovoort.  Geen van allen zijn ze
      erg belangrijk, maar er zijn verschillen.  Na verloop van tijd
      verdwijnt de ondersteuning voor <filename>a.out</filename> uit de
      <filename>GENERIC</filename> kernel en uiteindelijk ook helemaal
      uit de kernel als de noodzaak voor <filename>a.out</filename>
      gebaseerde programma's voorbij is.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Meer informatie</title>

    <sect2 xml:id="basics-man">
      <title>Handleidingen</title>

      <indexterm><primary>handleidingen</primary></indexterm>

      <para>De meest uitvoerige documentatie van &os; is geschreven
	in de vorm van handleidingen.  Bijna elk programma op het
	systeem heeft een kleine handleiding die uitlegt wat de
	basisopties en verschillende argumenten doen.  Deze
	handleidingen bekeken worden met <command>man</command>.  Het
	gebruik van <command>man</command> gaat als volgt:</para>

      <screen>&prompt.user; <userinput>man commando</userinput></screen>

      <para><literal>commando</literal> is de naam van het commando
	waar meer informatie over getoond moet worden.  Om bijvoorbeeld
	meer informatie weer te geven over <command>ls</command> kan
	het volgende uitgevoerd worden:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>De handleidingen zijn opgedeeld in genummerde
	onderdelen:</para>

      <orderedlist>
	<listitem>
	  <para>Gebruikerscommando's.</para>
	</listitem>

	<listitem>
	  <para>Systeemaanroepen en foutnummernummers.</para>
	</listitem>

	<listitem>
	  <para>Functies in de C bibliotheken.</para>
	</listitem>

	<listitem>
	  <para>Apparaatdrivers.</para>
	</listitem>

	<listitem>
	  <para>Bestandsindelingen.</para>
	</listitem>

	<listitem>
	  <para>Spelletjes en andere afleidingen.</para>
	</listitem>

	<listitem>
	  <para>Diverse informatie.</para>
	</listitem>

	<listitem>
	  <para>Systeemonderhoud en commando's</para>
	</listitem>

	<listitem>
	  <para>Kernelontwikkelaars.</para>
	</listitem>
      </orderedlist>

      <para>In sommige gevallen kan een bepaald onderwerp vaker
	voorkomen in een onderdeel van de handleidingen.  Er is
	bijvoorbeeld een gebruikerscommando <command>chmod</command>
	en een systeemaanroep <function>chmod()</function>.  In deze
	gevallen kan <command>man</command> aangegeven worden welke
	documentatie weer te geven door het specificeren van het
	onderdeel:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dit geeft de handleiding van het gebruikerscommando
	<command>chmod</command> weer.  Verwijzingen naar een bepaald
	onderdeel van de handleiding worden traditioneel tussen haakjes
	geplaatst: &man.chmod.1; verwijst naar het commando
	<command>chmod</command> en &man.chmod.2; verwijst naar de
	systeemaanroep.</para>

      <para>Dit werkt prima als de naam van het commando bekend is en
	alleen informatie nodig is over hoe het commando gebruikt kan
	worden, maar wat als de naam van het commando niet bekend is?
	Dan kan <command>man</command> gebruikt worden om naar
	trefwoorden te zoeken in de commandobeschrijvingen door de
	optie <option>-k</option> te gebruiken:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Met dit commando wordt een overzicht getoond met commando's
	die het trefwoord <quote>mail</quote> in hun omschrijving
	hebben.  Dit is gelijk aan het commando
	<command>apropos</command>.</para>

      <para>Dus om meer informatie over spannende commando's met een
	onbekende functie in <filename>/usr/bin</filename> te krijgen
	is het volgende commando voldoende:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>Het onderstaande commando resulteert in hetzelfde:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>
    </sect2>

    <sect2 xml:id="basics-info">
      <title>Gnu infobestanden</title>

      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>&os; heeft veel applicaties en hulpmiddelen die gemaakt
	zijn door de Free Software Foundation (FSF).  Als extraatje
	voor de documentatie hebben deze programma's uitgebreidere
	html&nbsp;bestanden die <literal>info</literal>bestanden heten,
	die uitgelezen kunnen worden met <command>info</command> of,
	als <application>emacs</application> is geïnstalleerd, de
	infomodus van <application>emacs</application>.</para>

      <para>&man.info.1; wordt als volgt gebruikt:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para><literal>h</literal> geeft een korte beschrijving en
	<literal>?</literal> toont een kort
	commando&ndash;overzicht.</para>
    </sect2>
  </sect1>
</chapter>
