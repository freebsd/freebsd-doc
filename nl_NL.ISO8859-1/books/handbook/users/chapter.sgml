<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$

     %SOURCE%	en_US.ISO8859-1/books/handbook/users/chapter.sgml
     %SRCID%	38826
-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Neil</firstname>
	<surname>Blakey-Milner</surname>
	<contrib>Geschreven door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Siebrand</firstname>
	<surname>Mazeland</surname>
	<contrib>Vertaald door </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
  </chapterinfo>

  <title>Gebruikers en basis accountbeheer</title>

  <sect1 id="users-synopsis">
    <title>Overzicht</title>

    <para>Met &os; is het mogelijk een computer met meerdere gebruikers
      tegelijkertijd te gebruiken.  Natuurlijk kan er op een zeker
      moment maar &eacute;&eacute;n gebruiker achter het scherm en
      toetsenbord zitten

      <footnote>
	<para>Tenzij er natuurlijk meerdere terminals worden aangesloten, maar
	  dat wordt behandeld in <xref linkend="serialcomms">.</para></footnote>

      , maar er kan een groot aantal gebruikers zijn aangemeld via het
      netwerk om dingen met de computer te doen.  Om een systeem te
      gebruiken moet een gebruiker een account hebben.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>De verschillen tussen de gebruikersaccounts op een &os;
	  systeem;</para>
      </listitem>

      <listitem>
	<para>Hoe gebruikersaccounts toe te voegen;</para>
      </listitem>

      <listitem>
	<para>Hoe gebruikersaccounts te verwijderen;</para>
      </listitem>

      <listitem>
	<para>Hoe eigenschappen van accounts te wijzigen, zoals de
	  volledige naam van de gebruiker of de voorkeursshell;</para>
      </listitem>

      <listitem>
	<para>Hoe op een per account basis limieten in te stellen om
	  het bronnengebruik van bijvoorbeeld geheugen en processortijd
	  te reguleren voor accounts en accountgroepen;</para>
      </listitem>

      <listitem>
	<para>Hoe groepen te gebruiken om accountbeheer te
	  vereenvoudigen.</para>
      </listitem>
    </itemizedlist>

    <para>Aangeraden voorkennis:</para>

    <itemizedlist>
      <listitem>
	<para>Basisbegrip van &unix; en &os; (<xref
	    linkend="basics">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>Inleiding</title>

    <para>Via accounts wordt alle toegang tot een systeem gegeven en
      alle processen worden door gebruikers gedraaid.  Dus gebruikers
      en accountbeheer zijn van integraal belang op &os;
      systemen.</para>

    <para>Elke account op een &os; systeem heeft een aantal
      informatievelden waarmee de account ge&iuml;dentificeerd kan
      worden.</para>

    <variablelist>
      <varlistentry>
	<term>Gebruikersnaam</term>

	<listitem>
	  <para>De gebruikersnaam, zoals die ingevoerd wordt bij het
	    prompt <prompt>login:</prompt>.  Gebruikersnamen moeten
	    uniek zijn op een computer.  Er mogen geen twee
	    gebruikers zijn met dezelfde gebruikersnaam.  Er horen een
	    aantal regels bij het maken van geldige gebruikersnamen,
	    die in &man.passwd.5; staan beschreven.  Gebruikersnamen
	    bestaan gewoonlijk uit acht of minder karakters (geen
	    hoofdletters).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Wachtwoord</term>

	<listitem>
	  <para>Bij ieder account hoort een wachtwoord.  Het wachtwoord
	    kan leeg zijn.  Er is dan geen wachtwoord nodig om toegang
	    te krijgen tot een systeem.  Dit is meestal een slecht
	    idee.  Ieder account hoort een wachtwoord te
	    hebben.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Gebruikers ID (UID)</term>

	<listitem>
	  <para>Het UID is een nummer, traditioneel van 0 tot 65535

	    <footnote id="users-largeuidgid">
	      <para>Het is mogelijk om UID/GID's te gebruiken tot
		4294967295, maar die ID's kunnen tot serieuze
		problemen leiden met software die aannames maakt over
		de waarde van ID's.</para></footnote>

	    , dat wordt gebruikt om een gebruiker op een systeem uniek
	    te identificeren.  Intern gebruikt &os; het UID om
	    gebruikers te identificeren.  Voor alle &os; commando's
	    waarin een gebruikersnaam wordt opgegeven, wordt eerst
	    geconverteerd naar het UID voordat ermee gewerkt wordt.
	    Dit betekent dat er verschillende accounts kunnen zijn met
	    andere gebruikersnamen maar met hetzelfde UID.  Wat &os;
	    betreft zijn al die accounts &eacute;&eacute;n gebruiker.
	    Het is onwaarschijnlijk dat het ooit nodig is deze
	    eigenschap te gebruiken.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Groep ID (GID)</term>

	<listitem>
	  <para>Het GID is een nummer, traditioneel van 0 tot 65535
	    <footnoteref linkend="users-largeuidgid">, gebruikt om de
	    primaire groep waartoe een gebruiker behoort, uniek te
	    identificeren.  Groepen zijn een methode waarmee toegang
	    tot bronnen beheerst kan worden, gebaseerd op het GID van
	    een gebruiker in plaats van op een UID.  Hiermee kan het
	    aantal instellingen in bepaalde bestanden aanzienlijk
	    verkleind worden.  Een gebruiker kan lid zijn van meer dan
	    &eacute;&eacute;n groep.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Aanmeldklasse</term>

	<listitem>
	  <para>Aanmeldklassen zijn een uitbreiding op het
	    groepenmechanisme waarmee additionele flexibiliteit wordt
	    geboden bij het aanpassen van een systeem op verschillende
	    gebruikers.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Wijzigingstijd wachtwoord</term>

	<listitem>
	  <para>Standaard dwingt &os; gebruikers niet tot het periodiek
	    wijzigen van hun wachtwoord.  Dit kan wel per gebruiker
	    afgedwongen worden, zodat sommige of alle gebruikers hun
	    wachtwoord na een bepaalde periode moeten wijzigen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Verloopdatum account</term>

	<listitem>
	  <para>Standaard verlopen accounts op &os; niet.  Als er
	    accounts gemaakt worden waarvan bekend is dat ze maar een
	    beperkte tijd nodig zijn, bijvoorbeeld op een school waar
	    accounts bestaan voor studenten, dan kan er aangegeven
	    worden wanneer een account verloopt.  Nadat de verloopdatum
	    is verstreken kan de account niet meer gebruikt worden om
	    aan te melden op een systeem, hoewel de mappen en bestanden
	    van de account nog wel blijven bestaan.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Volledige gebruikersnaam</term>

	<listitem>
	  <para>De gebruikersnaam identificeert de account uniek voor
	    &os;, maar die geeft niet zonder meer de echte naam van de
	    gebruiker weer.  Deze informatie kan aan de account
	    gekoppeld worden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Thuismap</term>

	<listitem>
	  <para>De thuismap is het volledige pad naar een map op een
	    systeem waar de gebruiker start als die aanmeldt op een
	    systeem.  Het is de gewoonte dat alle thuismappen voor
	    gebruikers onder
	    <filename>/home/<replaceable>gebruikersnaam</replaceable></filename>
	    of
	    <filename>/usr/home/<replaceable>gebruikersnaam</replaceable></filename>
	    staan.  Gebruikers slaan hun persoonlijke bestanden op in
	    hun thuismap en in mappen die daaronder worden
	    gemaakt.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Gebruikersshell</term>

	<listitem>
	  <para>De shell biedt een standaardomgeving waarmee gebruikers
	    met een systeem werken.  Er zijn vele shells en ervaren
	    gebruikers hebben hun eigen voorkeuren, die hun weerslag
	    kunnen hebben in hun accountinstellingen.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Er zijn drie hoofdtypen accounts: de <link
	linkend="users-superuser">Superuser</link>, <link
	linkend="users-system">systeemgebruikers</link> en <link
	linkend="users-user">gebruikersaccounts</link>.  De Superuser
      account, die meestal <username>root</username> heet, wordt
      gebruikt om een systeem te beheren zonder beperkingen.
      Systeemgebruikers kunnen diensten draaien.  Tenslotte kunnen
      gebruikersaccounts gebruikt worden door echte personen, die
      aanmelden, email lezen, enzovoort.</para>
  </sect1>

  <sect1 id="users-superuser">
    <title>De superuser account</title>

    <indexterm>
      <primary>accounts</primary>

      <secondary>superuser (root)</secondary>
    </indexterm>

    <para>De superuser account, die meestal
      <username>root</username> heet, is al ingesteld om gebruikt te
      worden voor systeembeheer en hoort niet gebruikt te worden voor
      dagelijkse werkzaamheden, zoals het sturen en ontvangen van
      email, het verkennen van het systeem of programmeren.</para>

    <para>Dit omdat de Superuser, anders dan gewone gebruikersaccounts,
      zonder beperkingen kan opereren en misbruik van een Superuser
      account kan resulteren in spectaculaire problemen.
      Gebruikersaccounts kunnen niet per ongeluk een systeem vernielen,
      dus het is aan te raden om wanneer maar mogelijk gewone
      gebruikersaccounts te gebruiken, tenzij de extra privileges
      noodzakelijk zijn.</para>

    <para>Commando's die als superuser worden uitgevoerd dienen altijd
      twee of drie keer gecontroleerd te worden voordat ze worden
      uitgevoerd, omdat een extra spatie of een missend karakter kan
      leiden tot niet terug te draaien dataverlies.</para>

    <para>Als het niet al geregeld is, is het dus na het lezen van dit
      hoofdstuk aan te raden als eerste een gebruikersaccount zonder
      bijzondere rechten te maken voor de dagelijkse bezigheden.  Dit
      geldt zowel als het gaat over een machine voor &eacute;&eacute;n
      gebruiker als wanneer het gaat over een machine voor meerdere
      gebruikers.  Later in dit hoofdstuk wordt beschreven hoe
      additionele accounts gemaakt kunnen worden en hoe er tussen de
      normale gebruiker en de Superuser gewisseld kan worden.</para>
  </sect1>

  <sect1 id="users-system">
    <title>Systeemaccounts</title>

    <indexterm>
      <primary>accounts</primary>

      <secondary>systeem</secondary>
    </indexterm>

    <para>Systeemgebruikers draaien diensten, zoals DNS, mailservers,
      webservers, enzovoort.  De reden hiervoor is beveiliging.  Als
      alle diensten als Superuser zouden draaien, dan zouden ze zonder
      beperkingen kunnen opereren.</para>

    <indexterm>
      <primary>accounts</primary>

      <secondary><username>daemon</username></secondary>
    </indexterm>

    <indexterm>
      <primary>accounts</primary>

      <secondary><username>operator</username></secondary>
    </indexterm>

    <para>Voorbeelden van systeemgebruikers zijn
      <username>daemon</username>, <username>operator</username>,
      <username>bind</username> (voor de Domain Name Service),
      <username>news</username> en <username>www</username>.</para>

    <indexterm>
      <primary>accounts</primary>

      <secondary><username>nobody</username></secondary>
    </indexterm>

    <para><username>nobody</username> is de generieke systeemgebruiker
      zonder bijzondere privileges.  Het is wel belangrijk om ervan
      bewust te zijn dat hoe meer diensten <username>nobody</username>
      gebruiken, hoe meer bestanden en processen er bij die gebruiker
      horen en dat de gebruiker daardoor meer privileges kan
      krijgen.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Gebruikersaccounts</title>

    <indexterm>
      <primary>accounts</primary>

      <secondary>gebruiker</secondary>
    </indexterm>

    <para>Gebruikersaccounts zijn het primaire middel dat echte
      gebruikers gebruiken om toegang te krijgen tot een systeem en die
      account schermen de gebruiker en de omgeving af, waardoor die
      gebruikers het systeem of andere gebruikers niet kunnen
      beschadigen en waardoor gebruikers hun omgeving kunnen aanpassen
      zonder invloed te hebben op anderen.</para>

    <para>Iedereen die toegang heeft tot een systeem hoort een unieke
      gebruikersaccount te hebben.  Hierdoor is het mogelijk uit te
      vinden wie wat aan het doen is, te voorkomen dat mensen elkaars
      instellingen kunnen verpesten of elkaars email kunnen lezen,
      enzovoort.</para>

    <para>Iedere gebruiker kan zijn eigen omgeving instellen op een
      systeem, door andere shells, editors, toetsenbordinstellingen en
      taal te kiezen.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Accounts wijzigen</title>

    <indexterm>
      <primary>accounts</primary>

      <secondary>wijzigen</secondary>
    </indexterm>

    <para>Er zijn vele commando's beschikbaar in de &unix; omgeving om
      gebruikersaccounts te manipuleren.  De meest gebruikte commando's
      worden hieronder beschreven, gevolgd door meer gedetailleerde
      voorbeelden van gebruik.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*">

	<colspec colwidth="2*">

	<thead>
	  <row>
	    <entry>Commando</entry>

	    <entry>Samenvatting</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>

	    <entry>Het aanbevolen commandoregelprogramma voor het
	      aanmaken van nieuwe gebruikers.</entry>
	  </row>

	  <row>
	    <entry>&man.rmuser.8;</entry>

	    <entry>Het aanbevolen commandoregelprogramma voor het
	      verwijderen van gebruikers.</entry>
	  </row>

	  <row>
	    <entry>&man.chpass.1;</entry>

	    <entry>Een flexibel hulpprogramma voor het wijzigen van
	      informatie in de gebruikersdatabase.</entry>
	  </row>

	  <row>
	    <entry>&man.passwd.1;</entry>

	    <entry>Een eenvoudig commandoregelprogramma voor het
	      wijzigen van wachtwoorden van gebruikers.</entry>
	  </row>

	  <row>
	    <entry>&man.pw.8;</entry>

	    <entry>Een krachtig en flexibel hulpprogramma voor het
	      wijzigen van alle aspecten van
	      gebruikersaccounts.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
	<primary>accounts</primary>

	<secondary>toevoegen</secondary>
      </indexterm>

      <indexterm><primary><command>adduser</command></primary></indexterm>

      <indexterm><primary><filename
	    class="directory">/usr/share/skel</filename></primary></indexterm>

      <indexterm><primary>skeleton map</primary></indexterm>

      <para>&man.adduser.8; is een eenvoudig programma voor het
	aanmaken van nieuwe gebruikers.  Er worden regels mee
	toegevoegd aan de systeembestanden <filename>passwd</filename>
	en <filename>group</filename>.  Het maakt ook een thuismap voor
	de nieuwe gebruiker, kopieert de standaard
	instellingenbestanden (<quote>dotfiles</quote>) uit
	<filename>/usr/share/skel</filename> en kan, optioneel, de
	nieuwe gebruiker een welkomstbericht mailen.</para>

      <example>
	<title>Een gebruiker toevoegen aan &os;</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <note>
	<para>Het wachtwoord wat ingegeven wordt, wordt niet getoond,
	  er worden ook geen sterretjes getoond.  Zorg ervoor dat het
	  wachtwoord correct ingevuld wordt.</para>
      </note>
    </sect2>

    <sect2 id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>

      <indexterm>
	<primary>accounts</primary>

	<secondary>verwijderen</secondary>
      </indexterm>

      <para>Met &man.rmuser.8; kan een gebruiker volledig van een
	systeem verwijderd worden.  &man.rmuser.8; voert de volgende
	stappen uit:</para>

      <procedure>
	<step>
	  <para>Verwijdert de &man.crontab.1; van de gebruiker (als die
	    bestaat).</para>
	</step>

	<step>
	  <para>Verwijdert bestaande &man.at.1; taken van de
	    gebruiker.</para>
	</step>

	<step>
	  <para>Stopt alle processen van de gebruiker.</para>
	</step>

	<step>
	  <para>Verwijdert de gebruiker uit het lokale
	    wachtwoordbestand van een systeem.</para>
	</step>

	<step>
	  <para>Verwijdert de thuismap van de gebruiker (als de
	    gebruiker daar eigenaar van is).</para>
	</step>

	<step>
	  <para>Verwijdert de inkomende email voor de gebruiker uit
	    <filename>/var/mail</filename>.</para>
	</step>

	<step>
	  <para>Verwijdert alle bestanden waar de gebruiker eigenaar
	    van is uit opslaggebieden voor tijdelijke bestanden als
	    <filename>/tmp</filename>.</para>
	</step>

	<step>
	  <para>Als laatste wordt de gebruikersnaam uit alle groepen
	    in <filename>/etc/group</filename> waar die lid van was
	    verwijderd.</para>

	  <note>
	    <para>Als een groep leeg raakt en de groepsnaam is
	      hetzelfde als de gebruikersnaam, dan wordt de groep
	      verwijderd.  Dit is het tegenovergestelde van wat
	      &man.adduser.8; met een unieke groep per gebruiker.</para>
	  </note>
	</step>
      </procedure>

      <para>&man.rmuser.8; kan niet gebruikt worden om superuser
	accounts te verwijderen, omdat dat vrijwel altijd leidt tot
	vreselijke verwoesting.</para>

      <para>Standaard wordt een interactieve modus gebruikt, die ervoor
	zorgt dat alle stappen bewust worden genomen.</para>

      <example>
	<title>Interactief accounts verwijderen met
	  <command>rmuser</command></title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>

      <para>&man.chpass.1; wijzigt informatie in de gebruikersdatabase,
	zoals wachtwoorden, shells en persoonlijke informatie.</para>

      <para>Alleen systeembeheerders, zoals de Superuser, mogen de
	informatie en wachtwoorden voor andere gebruikers
	wijzigen met &man.chpass.1;.</para>

      <para>Als er geen opties worden meegegeven, buiten de optionele
	gebruikersnaam, dan toont &man.chpass.1; een editor waarin de
	gebruikersinformatie wordt weergegeven.  Als de gebruiker de
	editor verlaat, dan wordt de gebruikersdatabase bijgewerkt met
	de nieuwe informatie.</para>

      <note>
	<para>Er zal om uw wachtwoord gevraagd worden na het verlaten
	  van de tekstverwerker, als de huidige gebruiker niet de
	  superuser is.</para>
      </note>

      <example>
	<title>Interactieve <command>chpass</command> door
	  superuser</title>

	<screen>#Informatie in de gebruikersdatabase wijzigen voor jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Een normale gebruiker kan slechts een deel van de
	bovenstaande informatie wijzen en alleen voor zijn eigen
	account.</para>

      <example>
	<title>Interactieve <command>chpass</command> door een gewone
	  gebruiker</title>

	<screen>#Informatie in de gebruikersdatabase wijzigen voor jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
	<para>&man.chfn.1; en &man.chsh.1; zijn gewoon links naar
	  &man.chpass.1;.  Dat geldt ook voor &man.ypchpass.1;,
	  &man.ypchfn.1; en &man.ypchsh.1;.  Ondersteuning voor NIS
	  gaat automatisch; er hoeft dus geen <literal>yp</literal>
	  voor het commando aangegeven te worden.  NIS wordt behandeld
	  in <xref linkend="network-servers">.</para>
      </note>
    </sect2>

    <sect2 id="users-passwd">
      <title><command>passwd</command></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>

      <indexterm>
	<primary>accounts</primary>

	<secondary>wachtwoord wijzigen</secondary>
      </indexterm>

      <para>Met &man.passwd.1; wijzigt een gebruiker gewoonlijk zijn
	eigen wachtwoord of dat van een andere gebruiker als het door
	de Superuser wordt uitgevoerd.</para>

      <note>
	<para>Om onbedoelde of ongeautoriseerde wijzigen te voorkomen
	  moet het originele wachtwoord worden ingegeven voordat een
	  nieuw wachtwoord kan worden ingesteld.</para>
      </note>

      <example>
	<title>Wachtwoord wijzigen</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>Als superuser het wachtwoord van een andere gebruiker
	  wijzigen</title>

	<screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
	<para>Net als bij &man.chpass.1; is &man.yppasswd.1; gewoon een
	  link naar &man.passwd.1;, dus NIS werkt met beide
	  commando's.</para>
      </note>
    </sect2>

    <sect2 id="users-pw">
      <title><command>pw</command></title>

      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; is een commandoregelhulpprogramma om gebruikers
	en groepen te maken, verwijderen, aan te passen en weer te
	geven.  Het werkt als een voorkant voor de systeembestanden met
	gebruikers en groepen.  &man.pw.8; heeft een zeer krachtige set
	commandoregelopties, waardoor het erg geschikt is om in shell
	scripts gebruikt te worden.  Nieuwe gebruikers vinden het
	wellicht gecompliceerder dan de andere commando's die hier
	beschreven worden.</para>
    </sect2>
  </sect1>

  <sect1 id="users-limiting">
    <title>Gebruikers beperken</title>

    <indexterm><primary>gebruikers beperken</primary></indexterm>

    <indexterm>
      <primary>accounts</primary>

      <secondary>beperken</secondary>
    </indexterm>

    <para>Bij het hebben van gebruikers komt wellicht ook de gedachte
      aan het beperken van de mogelijkheden op een systeem.  &os;
      biedt een aantal mogelijkheden waarmee een beheerder de
      hoeveelheid systeembronnen die een gebruiker kan aanwenden kan
      beperken.  Die beperkingen zijn onderverdeeld in twee onderdelen:
      schijfquota en andere beperkingen voor bronnen.</para>

    <indexterm><primary>quota</primary></indexterm>

    <indexterm>
      <primary>gebruikers beperken</primary>

      <secondary>quota</secondary>
    </indexterm>

    <indexterm><primary>schijfquota</primary></indexterm>

    <para>Schijfquota beperken het schijfgebruik voor gebruikers en ze
      bieden een mogelijkheid om dat gebruik snel te controleren zonder
      het iedere keer te hoeven berekenen.  Quota worden besproken in
      <xref linkend="quotas">.</para>

    <para>De overige beperking van bronnen omvat het beperken van het
      gebruik van CPU, geheugen en andere bronnen die gebruikers tot
      hun beschikking hebben.  Die worden ingesteld in aanmeldklassen
      en worden hieronder beschreven.</para>

    <indexterm><primary><filename>/etc/login.conf</filename></primary></indexterm>

    <para>Aanmeldklassen worden ingesteld in
      <filename>/etc/login.conf</filename>.  De precieze semantiek
      wordt niet behandeld in dit handboek, maar die staat beschreven
      in &man.login.conf.5;.  Hier is het voldoende aan te geven dat
      iedere gebruiker wordt toegewezen aan een aanmeldklasse
      (standaard <literal>default</literal>) en dat iedere
      aanmeldklasse verbonden is met een groep aanmeldmogelijkheden
      (login capability).  Een aanmeldmogelijkheid is een
      <literal><replaceable>naam</replaceable>=<replaceable>waarde</replaceable></literal>
      paar, waar <replaceable>naam</replaceable> een bekende eigenschap
      is en <replaceable>waarde</replaceable> een arbitraire string is
      die wordt verwerkt afhankelijk van de naam.  Het instellen van
      aanmeldklassen en -mogelijkheden is een redelijk eenvoudig proces
      en wordt ook beschreven in &man.login.conf.5;.</para>

    <note>
      <para>Een systeem leest de instellingen uit normaal gesproken
	<filename>/etc/login.conf</filename> niet direct, maar leest
	het databasebestand <filename>/etc/login.conf.db</filename>
	welke snellere opzoekmogelijkheden biedt.
	<filename>/etc/login.conf.db</filename> kan met het volgende
	commando gemaakt worden uit
	<filename>/etc/login.conf</filename>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
    </note>

    <para>Beperkingen van bronnen verschillen van standaard
      aanmeldmogelijkheden op twee manieren.  Ten eerste is er voor
      iedere beperking een zachte en een harde limiet.  Een zachte
      (huidige) limiet kan door een gebruiker of applicatie aangepast
      worden, maar mag niet hoger zijn dan de harde limiet.  De laatste
      kan door een gebruiker verlaagd worden, maar nooit verhoogd.
      Deze verschillen worden veroorzaakt door de specifieke
      behandeling van de beperkingen, niet door de implementatie van
      het aanmeldmogelijkheden raamwerk, dat wil zeggen dat ze niet
      <emphasis>echt</emphasis> bijzondere aanmeldmogelijkheden
      zijn.</para>

    <para>Hieronder worden de meest gebruikte beperkingen op bronnen
      beschreven.  De overige mogelijkheden, samen met alle andere
      aanmeldmogelijkheden, staat beschreven in
      &man.login.conf.5;.</para>

    <variablelist>
      <varlistentry>
	<term><literal>coredumpsize</literal></term>

	<listitem>
	  <indexterm><primary>coredumpsize</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>coredumpsize</secondary>
	  </indexterm>

	  <para>De limiet op de grootte van een corebestand dat wordt
	    gemaakt door een programma is, om verschillende redenen,
	    ondergeschikt aan andere beperkingen op het gebied van
	    schijfgebruik (bijvoorbeeld <literal>filesize</literal> of
	    schijfquota).  Desalniettemin wordt deze instelling vaak
	    gebruikt als een minder zware methode voor het beheersen
	    van het gebruik van schijfruimte.  Omdat gebruikers niet
	    hun eigen corebestanden maken en ze vaak niet verwijderen,
	    kan deze instelling helpen te voorkomen dat een schijf vol
	    loopt in het geval een groot programma (bijvoorbeeld
	    <application>emacs</application>) zou crashen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>cputime</literal></term>

	<listitem>
	  <indexterm><primary>cputime</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>processortijd</secondary>
	  </indexterm>

	  <para>Dit is de maximale hoeveelheid processortijd die een
	    proces van een gebruiker mag gebruiken.  Processen die meer
	    bronnen gebruiken worden afgeschoten door de kernel.</para>

	  <note>
	    <para>Dit is een beperking op de CPU
	      <emphasis>tijd</emphasis> die wordt gebruikt, niet op
	      een percentage van de CPU, zoals wordt getoond in
	      sommige velden door &man.top.1; en &man.ps.1;.  Een
	      limiet op de laatste is op het moment van schrijven
	      niet mogelijk en zou ook redelijk waardeloos zijn:
	      een compiler &ndash; waarschijnlijk een legitieme taak
	      &ndash; kan makkelijk gedurende enige tijd bij 100% van
	      een CPU gebruiken.</para>
	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>filesize</literal></term>

	<listitem>
	  <indexterm><primary>filesize</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>filesize</secondary>
	  </indexterm>

	  <para>Dit is de maximale grootte voor een bestand waar een
	    gebruiker eigenaar van kan zijn.  Anders dan bij <link
	      linkend="quotas">schijfquota</link> is deze limiet van
	    toepassing op individuele bestanden en niet op alle
	    bestanden samen waarvan een gebruiker eigenaar is.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>maxproc</literal></term>

	<listitem>
	  <indexterm><primary>maxproc</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>maxproc</secondary>
	  </indexterm>

	  <para>Dit is het maximale aantal processen dat een gebruiker
	    mag draaien.  Hieronder vallen zowel processen die op de
	    voorgrond draaien als op de achtergrond.  Om duidelijke
	    reden kan deze waarde niet groter zijn dan de ingestelde
	    systeemlimiet voor <varname>kern.maxproc</varname> met
	    &man.sysctl.8;.  Het te laag zetten van deze instelling kan
	    de productiviteit van een gebruiker schaden: vaak is het
	    zinvol om meerdere keren aangemeld te zijn of om pipelines
	    uit te voeren.  Sommige taken, zoals het compileren van een
	    groot programma, brengen ook meerdere processen voort
	    (bijvoorbeeld &man.make.1;, &man.cc.1; en andere
	    tussentijdse preprocessors).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memorylocked</literal></term>

	<listitem>
	  <indexterm><primary>memorylocked</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>memorylocked</secondary>
	  </indexterm>

	  <para>Dit is de maximale hoeveelheid geheugen die een proces
	    mag claimen om te locken in het hoofdgeheugen (zie
	    bijvoorbeeld &man.mlock.2;).  Sommige systeemkritische
	    programma's, zoals &man.amd.8;, locken in het
	    hoofdgeheugen, zodat zij, in het geval het wisselbestand
	    gebruikt moet worden, niet hoeven bij te dragen aan dat
	    proces als het nodig is.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memoryuse</literal></term>

	<listitem>
	  <indexterm><primary>memoryuse</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>memoryuse</secondary>
	  </indexterm>

	  <para>Dit is de maximale hoeveelheid geheugen die een proces
	    op enig moment mag gebruiken.  Hieronder vallen zowel
	    hoofdgeheugen als het gebruik van het wisselbestand.  Deze
	    limiet vangt niet al het geheugengebruik af, maar het is
	    een prima begin.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>openfiles</literal></term>

	<listitem>
	  <indexterm><primary>openfiles</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>openfiles</secondary>
	  </indexterm>

	  <para>Dit is het maximale aantal bestanden dat een proces
	    open mag hebben.  In &os; representeren bestanden ook
	    sockets en IPC kanalen.  Deze limiet mag dus niet te laag
	    gezet worden.  De limiet voor het systeem staat ingesteld
	    in <varname>kern.maxfiles</varname> van
	    &man.sysctl.8;.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>sbsize</literal></term>

	<listitem>
	  <indexterm><primary>sbsize</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>sbsize</secondary>
	  </indexterm>

	  <para>Dit is de limiet op de hoeveelheid netwerkgeheugen, en
	    dus mbufs, die een gebruiker ter beschikking staan.  Deze
	    waarde komt voort uit het antwoord op een DoS aanval
	    waarmee veel sockets werden gemaakt, maar het kan in het
	    algemeen gebruikt worden om de hoeveelheid
	    netwerkcommunicatie te limiteren.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>stacksize</literal></term>

	<listitem>
	  <indexterm><primary>stacksize</primary></indexterm>

	  <indexterm>
	    <primary>gebruikers beperken</primary>

	    <secondary>stacksize</secondary>
	  </indexterm>

	  <para>Dit is de maximale grootte voor een stack van een
	    proces.  Deze instelling alleen is niet genoeg om de
	    hoeveelheid geheugen die een programma mag gebruiken te
	    beperken.  Daarom moet deze limiet samen met andere
	    limieten gebruikt worden.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Er zijn nog een aantal dingen belangrijk bij het instellen
      bronbeperkingen.  Hierna worden een aantal algemene tips,
      suggesties en commentaren gegeven.</para>

    <itemizedlist>
      <listitem>
	<para>Processen die bij het opstarten van een systeem gestart
	  worden vanuit <filename>/etc/rc</filename> worden toegewezen
	  aan de aanmeldklasse <literal>daemon</literal>.</para>
      </listitem>

      <listitem>
	<para>Hoewel de <filename>/etc/login.conf</filename> die bij
	  een systeem zit een goede bron is voor redelijke waardes voor
	  de meeste limieten, kan alleen de beheerder van een machine
	  de echt juiste waarden kennen.  Het te hoog instellen van een
	  limiet kan een systeem kwetsbaar maken voor misbruik, terwijl
	  het te laag instellen van limieten de productiviteit te veel
	  kan hinderen.</para>
      </listitem>

      <listitem>
	<para>Gebruikers van het X Window systeem (X11) horen
	  waarschijnlijk meer bronnen toegewezen te krijgen dan andere
	  gebruikers.  X11 gebruikt zelf al meer bronnen, maar het
	  moedigt gebruikers ook aan om meerdere programma's
	  tegelijkertijd te draaien.</para>
      </listitem>

      <listitem>
	<para>Het is belangrijk niet te vergeten dat veel limieten
	  betrekking hebben op individuele processen en niet op een
	  hele gebruiker.  Het instellen van bijvoorbeeld
	  <varname>openfiles</varname> op 50, betekent dat ieder proces
	  dat een gebruiker draait 50 open bestanden mag hebben.  Het
	  totale aantal bestanden dat een gebruiker dus open kan hebben
	  is het product van de waarde van <literal>openfiles</literal>
	  en de waarde van <literal>maxproc</literal>.  Dit geldt ook
	  voor het gebruik van geheugen.</para>
      </listitem>
    </itemizedlist>

    <para>Meer informatie over bronbeperkingen en aanmeldklassen in het
      algemeen staan in de relevante hulppagina's: &man.cap.mkdb.1;,
      &man.getrlimit.2;, &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-groups">
    <title>Groepen</title>

    <indexterm><primary>groepen</primary></indexterm>

    <indexterm><primary><filename>/etc/groups</filename></primary></indexterm>

    <indexterm>
      <primary>accounts</primary>

      <secondary>groepen</secondary>
    </indexterm>

    <para>Een groep is eenvoudigweg een lijst gebruikers.  Groepen
      kunnen ge&iuml;dentificeerd worden aan de hand van hun naam en
      GID (Groep ID).  In &os; (en de meeste andere &unix; achtige
      systemen), worden besluiten door de kernel over of een proces
      iets wel of niet mag doen genomen op basis van het bijbehorende
      gebruikers ID en een lijst van groepen waar dat bij hoort.
      Anders dan bij een gebruikers ID, heeft een proces een lijst met
      bijbehorende groepen.  Sommige programma's refereren wel eens aan
      het <quote>groep ID</quote> van een gebruiker of een proces.
      Meestal is dit gewoon de eerste groep in de hiervoor genoemde
      lijst.</para>

    <para>De vertaling van groep ID naar groepsnaam staat in
      <filename>/etc/group</filename>.  Dit is een tekstbestand met
      vier velden die door het karakter <literal>:</literal> (dubbele
      punt) worden gescheiden.  Het eerste veld is de groepsnaam, het
      tweede veld is het versleutelde wachtwoord, het derde het groep
      ID, het vierde een door komma's gescheiden lijst van leden van de
      groep.  Het bestand kan zonder gevaar met de hand aangepast
      worden (aangenomen dat er geen fouten in de syntaxis worden
      gemaakt, natuurlijk).  Een volledige beschrijving van de syntaxis
      staat in &man.group.5;.</para>

    <para>Als het onwenselijk is om <filename>/etc/group</filename> met
      de hand aan te passen, dan kan &man.pw.8; gebruikt worden voor
      het toevoegen en wijzigen van groepen.  Om bijvoorbeeld een groep
      met de naam <groupname>teamtwo</groupname> toe te voegen en
      daarna het bestaan van die groep te bevestigen:</para>

    <example>
      <title>Groepen toevoegen met &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>Het getal <literal>1100</literal> hierboven is het groep ID
      van de groep <groupname>teamtwo</groupname>.  Met de huidige
      instelling heeft <groupname>teamtwo</groupname> geen leden en is
      die redelijk waardeloos.  Dat kan veranderen door
      <username>jru</username> aan de groep
      <groupname>teamtwo</groupname> toe te voegen.</para>

    <example>
      <title>De lijst van groepsleden instellen met &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>Het argument voor de optie <option>-M</option> is een door
      komma's gescheiden lijst van gebruikers die in de aangegeven groep
      moeten komen.  In de voorgaande paragrafen is al aangegeven dat
      het wachtwoordbestand ook voor iedere gebruiker een groep bevat.
      Een gebruiker wordt automatisch toegevoegd aan de groepenlijst
      door een systeem.  De gebruiker wordt niet als lid getoond van die
      groep bij het gebruik van de optie <option>groupshow</option> van
      &man.pw.8;, maar wordt wel getoond als de informatie wordt
      opgevraagd via &man.id.1; of met een soortgelijk programma.  Met
      andere woorden: &man.pw.8; wijzigt alleen het bestand
      <filename>/etc/group</filename> en probeert nooit extra informatie
      te lezen uit <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Een nieuw lid aan een groep toevoegen met &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -m db</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru,db</screen>
    </example>

    <para>Het argument voor de optie <option>-m</option> is een door
      komma's gescheiden lijst van gebruikers die aan de groep worden
      toegevoegd.  In tegenstelling tot het vorige voorbeeld, worden
      deze gebruikers aan de groep toegevoegd en vervangen ze de lijst
      van gebruikers in de groep niet.</para>

    <example>
      <title>&man.id.1; gebruiken om groepslidmaatschap te
	bepalen</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Hierboven is te zien dat <username>jru</username> lid is van
      de groepen <groupname>jru</groupname> en
      <groupname>teamtwo</groupname>.</para>

    <para>Meer informatie over &man.pw.8; staat in de hulppagina en
      meer informatie over de opmaak van
      <filename>/etc/group</filename> staat in &man.group.5;.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
