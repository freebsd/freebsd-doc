<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$

     %SOURCE%  en_US.ISO8859-1/books/handbook/advanced-networking/chapter.xml
     %SRCID%   41645
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="advanced-networking">
  <info><title>Geavanceerde netwerken</title>
    <authorgroup>
      <author><personname><firstname>René</firstname><surname>Ladan</surname></personname><contrib>Vertaald door </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="advanced-networking-synopsis">
    <title>Samenvatting</title>

    <para>Dit hoofdstuk zal een aantal onderwerpen over geavanceerde
      netwerken behandelen.</para>

    <para>Na het lezen van dit hoofdstuk is bekend:</para>

    <itemizedlist>
      <listitem>
	<para>De beginselen van gateways en routes.</para>
      </listitem>

      <listitem>
	<para>Hoe &ieee; 802.11- en &bluetooth;-apparaten te
	  installeren.</para>
      </listitem>

      <listitem>
	<para>Hoe &os; als een bridge te laten werken.</para>
      </listitem>

      <listitem>
	<para>Hoe een schijfloze machine vanaf het netwerk op te
	  starten.</para>
      </listitem>

      <listitem>
	<para>Hoe opstarten met netwerk-PXE en een NFS-root-bestandssysteem te
	  installeren.</para>
      </listitem>

      <listitem>
	<para>Hoe Network Address Translation te installeren.</para>
      </listitem>

      <listitem>
	<para>Hoe IPv6 op een &os;-machine te installeren.</para>
      </listitem>

      <listitem>
	<para>Hoe ATM in te stellen.</para>
      </listitem>

      <listitem>
	<para>Hoe de mogelijkheden van CARP, het Common Address
	  Redundancy Protocol, aan te zetten en te benutten.</para>
      </listitem>
    </itemizedlist>

    <para>Voordat dit hoofdstuk gelezen wordt, dient de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>De beginselen van de scripts in
	  <filename>/etc/rc</filename> te begrijpen.</para>
      </listitem>

      <listitem>
	<para>Bekend te zijn met basisnetwerktermen.</para>
      </listitem>

      <listitem>
	<para>Te weten hoe een nieuwe &os;-kernel in te stellen en te
	  installeren (<xref linkend="kernelconfig"/>).</para>
      </listitem>

      <listitem>
	<para>Te weten hoe aanvullende software van derde partijen te
	  installeren (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="network-routing">
    <info><title>Gateways en routes</title>
      <authorgroup>
	<author><personname><firstname>Coranth</firstname><surname>Gryphon</surname></personname><contrib>Bijgedragen door </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>routing</primary></indexterm>

    <indexterm><primary>gateway</primary></indexterm>

    <indexterm><primary>subnet</primary></indexterm>

    <para>Indien een machine een andere machine over een netwerk wil
      vinden, dient er een mechanisme te zijn dat beschrijft hoe van de
      ene naar de andere machine te gaan.  Dit wordt
      <firstterm>routen</firstterm> genoemd.  Een <quote>route</quote>
      is een gedefinieerd adressenpaar: een <quote>bestemming</quote> en
      een <quote>gateway</quote>.  Het paar geeft aan dat door deze
      <emphasis>gateway</emphasis> gecommuniceerd moet worden om bij
      deze <emphasis>bestemming</emphasis> aan te komen.  Er zijn drie
      soorten bestemmingen: individuele host, subnetten en
      <quote>standaard</quote>.  De <quote>standaardroute</quote> wordt
      gebruikt indien geen van de andere routes van toepassing zijn.
      Verderop wordt verder op standaardroutes ingegaan.  Er zijn ook
      drie soorten gateways: individuele hosts, interfaces (ook wel
      <quote>verbindingen </quote> genoemd), en
      Ethernet-hardware-adressen (MAC-adressen).</para>

    <sect2>
      <title>Een voorbeeld</title>

      <para>Om de verschillende aspecten van routen te illustreren,
	wordt het volgende voorbeeld van <command>netstat</command>
	gebruikt:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.example.com link#1             UC          0        0
224              link#1             UC          0        0</screen>

      <indexterm><primary>standaardroute</primary></indexterm>

      <para>De eerste twee regels geven de standaardroute (die behandeld
	wordt in de <link linkend="network-routing-default">volgende
	  sectie</link>) en de <systemitem>localhost</systemitem>-route aan.</para>

      <indexterm><primary>teruglusapparaat</primary></indexterm>

      <para>De interface (kolom <literal>Netif</literal>) dat deze
	routeertabel aangeeft om voor <literal>localhost</literal> te
	gebruiken is <filename>lo0</filename>, ook bekend als het
	teruglusapparaat.  Dit geeft aan dat alle verkeer voor deze
	bestemming intern gehouden moet worden, in plaats van het over
	het LAN te sturen, aangezien het alleen aankomt op de plaats
	waar het verzonden werd.</para>

      <indexterm>
	<primary>Ethernet</primary>

	<secondary>MAC-adres</secondary>
      </indexterm>

      <para>Het volgende dat opvalt zijn de adressen die beginnen met
	<systemitem class="etheraddress">0:e0:</systemitem>.  Dit zijn Ethernet-hardware
	adressen, ook bekend als MAC-adressen.  &os; zal automatisch
	elke host (<systemitem>test0</systemitem> in het voorbeeld) op het
	lokale Ethernet identificeren en een route voor die host
	toevoegen, direct van deze host over de Ethernet-interface,
	<filename>ed0</filename>.  Er is ook een timeout (kolom
	<literal>Expire</literal>) met deze routesoort geassocieerd,
	die gebruikt wordt indien er binnen een bepaalde tijd geen
	bericht komt van de host.  Indien dit gebeurt, wordt de route
	naar deze host automatisch verwijderd.  Deze hosts worden
	geïdentificeerd door middel van een mechanisme dat bekend
	staat als RIP (Routing Information Protocol), dat routes naar
	lokale hosts bepaald door middel van een kortste-pad
	algoritme.</para>

      <indexterm><primary>subnet</primary></indexterm>

      <para>&os; zal ook subnetroutes voor het lokale subnet toevoegen
	(<systemitem class="ipaddress">10.20.30.255</systemitem> is het
	broadcast-adres voor het subnet
	<systemitem class="ipaddress">10.20.30</systemitem>, en
	<systemitem class="fqdomainname">example.com</systemitem> is de
	domeinnaam die bij dat subnet hoort).  De aanduiding
	<literal>link#1</literal> verwijst naar de eerste Ethernetkaart
	in de machine.  Merk op dat voor hen geen aanvullende interface
	is gespecificeerd.</para>

      <para>Voor beide groepen (lokale netwerkhosts en lokale subnetten)
	worden de routes automatisch ingesteld door een daemon genaamd
	<application>routed</application>.  Indien dit niet draait,
	zullen alleen routes die statisch gedefinieerd (i.e., expliciet
	vermeld zijn) bestaan.</para>

      <para>De regel met <literal>host1</literal> verwijst naar deze
	host, het kent deze door het Ethernetadres.  Aangezien het de
	zendende host is, weet &os; dat het de teruglus-interface
	(<filename>lo0</filename>) moet gebruiken, in plaats van het
	over de Ethernet-interface te verzenden.</para>

      <para>De twee regels met <literal>host2</literal> geven een
	voorbeeld van wat er gebeurt als een alias met &man.ifconfig.8;
	gebruikt wordt (in de sectie over Ethernet staan redenen waarom
	dit gedaan wordt).  Het symbool <literal>=&gt;</literal> na de
	interface <filename>lo0</filename> zegt dat niet alleen de
	teruglus gebruikt wordt (aangezien dit adres ook verwijst naar
	de lokale host), maar specifiek dat dit een alias is.  Zulke
	routes verschijnen alleen op de hosts die de alias ondersteunen;
	alle andere hosts op het lokale netwerk vermelden simpelweg een
	regel met <literal>link#1</literal> voor zulke routes.</para>

      <para>De laatste regel (bestemming subnet
	<systemitem class="ipaddress">224</systemitem>) heeft te maken met
	multicasten, wat in een andere sectie besproken wordt.</para>

      <para>Als laatste staan in de kolom <literal>Flags</literal>
	verschillende attributen.  Hieronder staat een korte tabel met
	enkele van deze vlaggen en hun betekenis:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>

	  <colspec colwidth="4*"/>

	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Up: De route is actief.</entry>
	    </row>

	    <row>
	      <entry>H</entry>

	      <entry>Host: De bestemming van de route is een enkele
		host.</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Gateway: Stuur alles voor deze bestemming door naar
		dit verre systeem, dat zoekt daar uit waar het verder
		naar te sturen.</entry>
	    </row>

	    <row>
	      <entry>S</entry>

	      <entry>Statisch: Deze route was handmatig ingesteld, dus
		niet automatisch door het systeem aangemaakt.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Kloon: Maakt op basis van deze route een nieuwe
		route aan voor machines waarmee verbinding wordt
		gemaakt.  Dit soort routes wordt gewoonlijk in lokale
		netwerken gebruikt.</entry>
	    </row>

	    <row>
	      <entry>W</entry>

	      <entry>WasGekloond: Geeft aan dat een route automatisch
		was ingesteld gebaseerd op een LAN (kloon)-route.</entry>
	    </row>

	    <row>
	      <entry>L</entry>

	      <entry>Verbinding: De route maakt gebruik van verwijzingen
		naar Ethernet-hardware.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 xml:id="network-routing-default">
      <title>Standaardroutes</title>

      <indexterm><primary>standaardroute</primary></indexterm>

      <para>Wanneer het lokale systeem een verbinding met een verre host
	moet maken, controleert het de routeertabel op reeds bekende
	paden.  Indien de verre host binnen een subnet valt waarvan
	bekend is hoe het bereikt kan worden (gekloonde routes),
	controleert het systeem of het met de daarbij behorende
	interface verbinding kan maken.</para>

      <para>Indien alle bekende paden falen, heeft het systeem
	één laatste mogelijkheid: de
	<quote>standaardroute</quote>.  Deze route is een speciaal soort
	gateway-route (gewoonlijk de enig aanwezige in het systeem) en
	is altijd gemarkeerd met een <literal>c</literal> in het
	vlaggenveld.  Voor hosts op een LAN staat deze gateway ingesteld
	op de machine die een directe verbinding met de buitenwereld
	heeft (via een PPP-verbinding, DSL, kabelmodem, T1, of een ander
	netwerkinterface).</para>

      <para>Indien de standaardroute wordt ingesteld voor een machine
	die zelf als gateway naar de buitenwereld werkt, zal de
	standaardroute de gateway-machine van de internetprovider
	zijn.</para>

      <para>Hieronder volgt een voorbeeld van standaardroutes.  Dit is
	een veelgebruikte opstelling:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Lokaal2]  &lt;--ether--&gt;  [Lokaal1]  &lt;--PPP--&gt; [IP-Serv]  &lt;--ether--&gt;  [T1-GW]</literallayout>
	</textobject>
      </mediaobject>

      <para>De hosts <systemitem>Lokaal1</systemitem> en
	<systemitem>Lokaal2</systemitem> staan op deze site.
	<systemitem>Lokaal1</systemitem> is verbonden met een internetprovider
	via een inbel-PPP-verbinding.  Deze PPP-server is door een LAN
	verbonden met een andere gateway-computer door een externe
	interface naar de Internet-feed van de internetprovider.</para>

      <para>De standaardroutes voor de machines zijn:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standaard gateway</entry>

	      <entry>Interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Lokaal2</entry>

	      <entry>Lokaal1</entry>

	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Lokaal1</entry>

	      <entry>T1-GW</entry>

	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Een veelvoorkomende vraag is <quote>Waarom (of hoe) moet
	  worden ingesteld dat <systemitem>T1-GW</systemitem> de standaard gateway
	  is voor <systemitem>Lokaal1</systemitem>, in plaats van de server van
	  de internetprovider waarmee het verbonden is?</quote>.</para>

      <para>Onthoud dat, aangezien de PPP-interface een adres gebruikt
	op het lokale netwerk van de internetprovider voor deze kant van
	de verbinding, routes voor alle andere machines op het lokale
	netwerk van de internetprovider automatisch aangemaakt worden.
	Daarom is het al bekend hoe de machine <systemitem>T1-GW</systemitem>
	bereikt kan worden, dus is de tussenstap dat het verkeer eerst
	naar de server van de internetprovider gestuurd wordt niet
	nodig.</para>

      <para>Het is gebruikelijk om het adres <systemitem class="ipaddress">X.X.X.1</systemitem> te gebruiken als het
	gateway-adres voor het lokale netwerk.  Dus (gebruikmakend van
	hetzelfde voorbeeld), indien de lokale klasse-C adresruimte
	<systemitem class="ipaddress">10.20.30</systemitem> was en de
	internetprovider <systemitem class="ipaddress">10.9.9</systemitem>
	gebruikte, zouden de standaardroutes als volgt zijn:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standaardroute</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Lokaal2 (10.20.30.2)</entry>

	      <entry>Lokaal1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Lokaal1 (10.20.30.1, 10.9.9.30)</entry>

	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>De standaardroute kan eenvoudig in <filename>/etc/rc.conf</filename>
	gedefinieerd worden.  In dit voorbeeld werd de volgende regel aan
	<filename>/etc/rc.conf</filename> van <systemitem>Lokaal2</systemitem>
	toegevoegd:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Het is ook mogelijk dit met het commando &man.route.8;
	direct vanaf de opdrachtregel te doen:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Voor meer informatie over het handmatig manipuleren van
	netwerkrouteertabellen kan de hulppagina &man.route.8;
	geraadpleegd worden.</para>
    </sect2>

    <sect2 xml:id="network-dual-homed-hosts">
      <title>Dual Homed machines</title>

      <indexterm><primary>dual homed hosts</primary></indexterm>

      <para>Er is nog één andere soort opstelling die
	behandeld dient te worden, en dat is een host die in twee
	verschillende netwerken zit.  Technisch gezien telt elke machine
	die als gateway dienst doet (in bovenstaand voorbeeld door een
	PPP-verbinding te gebruiken) als een dual-homed host.  Maar de
	term wordt echt alleen gebruikt om naar een machine te verwijzen
	die in twee LAN's zit.</para>

      <para>In het ene geval heeft de machine twee Ethernetkaarten,
	waarbij elke kaart een adres op de gescheiden subnetten heeft.
	Een alternatief is dat de machine slechts één
	Ethernetkaart heeft en gebruikt maakt van &man.ifconfig.8;
	aliasing.  Het eerste wordt gebruikt indien er twee fysiek
	gescheiden Ethernet-netwerken in gebruik zijn, het laatste
	indien er één fysiek netwerksegment is, maar er
	twee logisch gescheiden subnetten zijn.</para>

      <para>In beide gevallen worden er routeertabellen aangemaakt zodat
	elk subnet weet dat deze machine de gedefinieerde gateway
	(ingaande route) naar het andere subnet is.  Deze opstelling,
	waarbij de machine dienst doet als router tussen de twee
	subnetten, wordt vaak gebruikt voor het implementeren van
	pakketfilters of firewall-beveiliging in één of
	beide richtingen.</para>

      <para>Om deze machine daadwerkelijk pakketten te laten forwarden
	tussen de twee interfaces, moet aan &os; verteld worden dat het
	deze mogelijkheid aan moet zetten.  In de volgende sectie staan
	meer details over hoe dit te doen.</para>
    </sect2>

    <sect2 xml:id="network-dedicated-router">
      <title>Een router bouwen</title>

      <indexterm><primary>router</primary></indexterm>

      <para>Een netwerkrouter is simpelweg een systeem dat pakketten van
	de ene naar de andere interface doorstuurt.
	Internetstandaarden en goede ontwerppraktijken verhinderen het
	&os; Project dit standaard in &os; aan te zetten.  Deze
	mogelijkheid kan worden aangezet door de volgende variabele in
	&man.rc.conf.5; op <literal>YES</literal> in te stellen:</para>

      <programlisting>gateway_enable="YES"	# Op YES instellen indien deze host een gateway is</programlisting>

      <para>Deze optie stelt de &man.sysctl.8; variabele
	<varname>net.inet.ip.forwarding</varname> in op
	<literal>1</literal>.  Indien het nodig is om het routen
	tijdelijk te stoppen, kan deze variabele tijdelijk op
	<literal>0</literal> worden teruggezet.</para>

      <indexterm><primary>BGP</primary></indexterm>

      <indexterm><primary>RIP</primary></indexterm>

      <indexterm><primary>OSPF</primary></indexterm>

      <para>De nieuwe router heeft routes nodig om te weten waar het
	het verkeer naar toe moet sturen.  Voor een eenvoudig netwerk
	kunnen statische routes gebruikt worden.  &os; wordt met het
	standaard BSD routeer-daemon &man.routed.8; geleverd, dat
	RIP (zowel versie 1 en versie 2) en IRDP spreekt.  Ondersteuning
	voor BGP v4, OSPF v2, en andere slimme routeerprotocollen is
	beschikbaar via het pakket <package>net/zebra</package>.  Ook zijn
	commerciële producten als
	<application>&gated;</application> beschikbaar voor complexere
	netwerkrouteer-oplossingen.</para>
    </sect2>

    <sect2 xml:id="network-static-routes">
      <info><title>Statische routes opzetten</title>
	<authorgroup>
	  <author><personname><firstname>Al</firstname><surname>Hoang</surname></personname><contrib>Bijgedragen door </contrib></author>
	</authorgroup>
      </info>
      <!-- Feb 2004 -->

      

      <sect3>
	<title>Handmatige configuratie</title>

	<para>Er wordt van het volgende netwerk uitgegaan:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/static-routes"/>
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Standaardrouter naar Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Intern Net 1        | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Intern Net 2</literallayout>
	  </textobject>
	</mediaobject>

	<para>In dit scenario is <systemitem>RouterA</systemitem> een
	  &os;-machine die dienst doet als router naar de rest van het
	  Internet.  Het heeft een standaardroute ingesteld op <systemitem class="ipaddress">10.0.0.1</systemitem>, dat het in staat stelt om
	  verbindingen met de buitenwereld te maken.  Er wordt
	  aangenomen dat <systemitem>RouterB</systemitem> reeds juist is
	  ingesteld en dat het weet hoe het waar naar toe moet gaan.  (In
	  dit plaatje is dit simpel.  Voeg een standaardroute op
	  <systemitem>RouterB</systemitem> toe door <systemitem class="ipaddress">192.168.1.1</systemitem> als gateway te
	  gebruiken.)</para>

	<para>De routeertabel voor <systemitem>RouterA</systemitem> zou er
	  ongeveer als volgt uitzien:</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24          link#1             UC          0        0    xl0
192.168.1.0/24       link#2             UC          0        0    xl1</screen>

	<para>Met de huidige routeertabel is <systemitem>RouterA</systemitem>
	  niet in staat om Intern Net 2 te bereiken.  Het heeft geen
	  route voor <systemitem class="ipaddress">192.168.2.0/24</systemitem>.  Een
	  manier om dit te verhelpen is om de route handmatig toe te
	  voegen.  Het volgende commando voegt het netwerk Intern Net 2
	  toe aan de routeertabel van <systemitem>RouterA</systemitem> door
	  <systemitem class="ipaddress">192.168.1.2</systemitem> als de volgende hop
	  te gebruiken:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Nu kan <systemitem>RouterA</systemitem> elke host op het netwerk
	  <systemitem class="ipaddress">192.168.2.0/24</systemitem> bereiken.</para>
      </sect3>

      <sect3>
	<title>Persistente configuratie</title>

	<para>Bovenstaand voorbeeld is perfect voor het instellen van
	  een statische route op een draaiend systeem.  Een probleem is
	  dat de routeerinformatie verdwijnt indien de &os;-machine
	  opnieuw wordt opgestart.  Aanvullende statische routes kunnen in
	  <filename>/etc/rc.conf</filename> opgenomen worden:</para>

	<programlisting># Voeg Intern Net 2 als een statische route toe
static_routes="internnet2"
route_internnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>De instellingsvariabele <literal>static_routes</literal>
	  is een lijst van strings gescheiden door een spatie.  Elke
	  string verwijst naar een routenaam.  Bovenstaand voorbeeld
	  heeft slechts één string in
	  <literal>static_routes</literal>.  Dit is de string
	  <replaceable>internnet2</replaceable>.  Vervolgens wordt een
	  instellingsvariabele
	  <literal>route_internnet2</literal>
	  toegevoegd waarin alle instellingsparameters staan die aan
	  het commando &man.route.8; moeten worden doorgegeven.  Voor
	  bovenstaand voorbeeld zou het volgende commando zijn
	  gebruikt:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Dus is <literal>"-net 192.168.2.0/24 192.168.1.2"</literal>
	  nodig.</para>

	<para>Zoals hierboven is vermeld is het mogelijk om meerdere
	  strings in <literal>static_routes</literal> te hebben.  Dit
	  maakt het mogelijk om meerdere statische routes aan te maken.
	  De volgende regels geven een voorbeeld van het toevoegen van
	  statische routes voor de netwerken <systemitem class="ipaddress">192.168.0.0/24</systemitem> en <systemitem class="ipaddress">192.168.1.0/24</systemitem> op een denkbeeldige
	  router:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="network-routing-propagation">
      <title>Routes propageren</title>

      <indexterm><primary>routes propageren</primary></indexterm>

      <para>Er is al gesproken over hoe routes naar de buitenwereld te
	definiëren, maar niet over hoe de buitenwereld ons kan
	vinden.</para>

      <para>Het is al bekend dat routeertabellen aangemaakt kunnen
	worden zodat al het verkeer voor een bepaalde adresruimte (in
	ons voorbeeld een klasse-C subnet) naar een bepaalde host op dat
	netwerk gezonden kan worden, dat de ingaande pakketten
	doorgeeft.</para>

      <para>Wanneer een adresruimte aan een site wordt toegewezen, stelt
	de serviceprovider al hun routeertabellen zodanig in dat al het
	verkeer voor het bijhorende subnet naar de PPP-verbinding van de
	site gezonden wordt.  Maar hoe weten sites door het land heen
	hoe naar de internetprovider van deze site te versturen?</para>

      <para>Er bestaat een systeem (dat veel lijkt op de gedistribueerde
	DNS-informatie) dat alle toegewezen adresruimtes bijhoudt, en
	hun verbindingspunt met de Internet Backbone definieert.  De
	<quote>Backbone</quote> zijn de grote kabels die Internetverkeer
	door het land en over de wereld sturen.  Elke backbone-machine
	heeft een kopie van een master-verzameling van tabellen, die
	verkeer voor een bepaald netwerk naar een bepaalde
	backbone-carrier sturen, en van daaruit naar een keten van
	serviceproviders totdat het netwerk van de site
	bereikt is.</para>

      <para>Het is de taak van de serviceprovider om bij de
	backbone-sites aan te geven dat zij het verbindingspunt (en dus
	het ingaande pad) zijn voor de site.  Dit staat bekend als
	routepropagatie.</para>
    </sect2>

    <sect2 xml:id="network-routing-troubleshooting">
      <title>Problemen oplossen</title>

      <indexterm><primary><command>traceroute</command></primary></indexterm>

      <para>Soms is er een probleem met routepropagatie en kunnen
	sommige sites geen verbinding maken.  Misschien is het nuttigste
	commando om proberen uit te zoeken waar het routen misgaat
	&man.traceroute.8;.  Het is ook nuttig als er geen verbinding
	mogelijk lijkt met een verre machine (dus als &man.ping.8;
	faalt).</para>

      <para>Het commando &man.traceroute.8; wordt gedraaid met de naam
	van de verre host waarmee geprobeerd wordt te verbinden.  Het
	laat de gateway-hosts zien langs het gepoogde pad, dat
	uiteindelijk de doelhost bereikt, of wegens een gebrek aan
	verbinding afgebroken wordt.</para>

      <para>Raadpleeg voor meer informatie de hulppagina voor
	&man.traceroute.8;.</para>
    </sect2>

    <sect2 xml:id="network-routing-multicast">
      <title>Multicast routen</title>

      <indexterm><primary>multicast routen</primary></indexterm>

      <indexterm>
	<primary>kernelopties</primary>

	<secondary>MROUTING</secondary>
      </indexterm>

      <para>&os; ondersteunt zowel multicast-applicaties als multicast
	routen van huis uit.  Voor multicast-applicaties is geen
	speciale configuratie van &os; nodig; applicaties draaien over
	het algemeen als geleverd.  Voor multicast routen dient
	ondersteuning in de kernel gecompileerd te worden:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Ook dient de multicast-routeer-daemon &man.mrouted.8;
	ingesteld worden zodat het tunnels en <acronym>DVMRP</acronym>
	via <filename>/etc/mrouted.conf</filename> aanmaakt.  Kijk voor
	meer details over multicast-instellingen in de hulppagina voor
	&man.mrouted.8;.</para>

      <note>
	<para>De &man.mrouted.8; multicast-routeer-daemon implementeert
	  het multicast-routeer-protocol <acronym>DVRMP</acronym> welke
	  in veel multicast-installaties grotendeels is vervangen door
	  &man.pim.4;.  &man.mrouted.8; en de gerelateerde
	  &man.map-mbone.8; en &man.mrinfo.8; gereedschappen zijn
	  beschikbaar in de &os; Ports&nbsp;Collectie als
	  <package>net/mrouted</package>.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="network-wireless">
    <info><title>Draadloze netwerken</title>
      <authorgroup>
	<author><personname><othername>Loader</othername></personname></author>

	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname></author>

	<author><personname><firstname>Murray</firstname><surname>Stokely</surname></personname></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>draadloze netwerken</primary></indexterm>

    <indexterm>
      <primary>802.11</primary>

      <see>draadloze netwerken</see>
    </indexterm>

    <sect2>
      <title>De beginselen van draadloos netwerken</title>

      <para>De meeste draadloze netwerken zijn op de &ieee; 802.11
	standaarden gebaseerd.  Een eenvoudig draadloos netwerk bestaat
	uit meerdere stations die met radio's communiceren die in de
	2,4GHz of de 5GHz band uitzenden (alhoewel dit regionaal
	varieert en het ook verandert om communicatie in de 2,3GHz en
	de 4,9GHz banden mogelijk te maken).</para>

      <para>802.11-netwerken zijn op twee manieren georganiseerd: in
	<emphasis>infrastructuurmodus</emphasis> treedt
	één station als meester op, alle andere stations
	associëren met dit station; dit netwerk staat bekend als
	een BSS en het meesterstation heet een toegangspunt (AP).  In
	een BSS gaat alle communicatie via het AP; zelfs als een station
	met een ander draadloos station wil communiceren gaan de
	boodschappen door het AP.  In de tweede netwerkvorm is er geen
	meester en communiceren de stations direct.  Deze netwerkvorm is
	een IBSS en staat gewoonlijk bekend als een <emphasis>ad-hoc
	  netwerk</emphasis>.</para>

      <para>802.11 netwerken begonnen in de 2,4GHz band waarbij gebruik
	werd gemaakt van protocollen die door de &ieee; 802.11 en
	802.11b standaarden worden gedefinieerd.  Deze specificaties
	omvatten de werkfrequenties, karakteristieken van de MAC-lagen
	waaronder frame- en zendsnelheden (communicatie kan met
	verschillende snelheden plaatsvinden).  Later definieerde de
	802.11a-standaard het werken in de 5GHz band, inclusief andere
	mechanismen voor signalering en hogere zendsnelheden.  Nog later
	werd de 802.11g-standaard gedefinieerd om gebruik te kunnen
	maken van de signalerings- en zendmechanismen van 802.11a in de
	2,4GHz band zodanig dat het met terugwerkende kracht werkt op
	802.11b-netwerken.</para>

      <para>Afgezien van de onderliggende zendtechnieken beschikken
	802.11-netwerken over een verscheidenheid aan
	beveiligingstechnieken.  De originele 802.11-specificaties
	definieerden een eenvoudig beveiligingsprotocol genaamd WEP.
	Dit protocol maakt gebruik van een vaste, van te voren gedeelde
	sleutel en het cryptografische algoritme RC4 om de gegevens die
	over het netwerk verstuurd worden te coderen.  Alle stations
	dienen dezelfde sleutel te gebruiken om te kunnen communiceren.
	Het is bewezen dat dit mechanisme eenvoudig te kraken is en
	wordt nu, afgezien om voorbijgaande gebruikers te ontmoedigen
	het netwerk te gebruiken, nog zelden gebruikt.  De huidige
	beveiligingsmethoden worden gegeven door de &ieee; 802.11i
	specificatie dat nieuwe cryptografische algoritmen en een
	aanvullend protocol om stations aan een toegangspunt te
	authenticeren en om sleutels voor gegevenscommunicatie uit te
	wisselen definieert.  Verder worden cryptografische sleutels
	periodiek ververst en zijn er mechanismen om indringpogingen
	te detecteren (en om indringpogingen tegen te gaan).  Een andere
	specificatie van een veelgebruikt beveiligingsprotocol in
	draadloze netwerken is WPA.  Dit was een voorloper op 802.11i
	en gedefinieerd door een industriegroep als een tussenmaatregel
	terwijl er gewacht werd op de ratificatie van 802.11i.  WPA
	specificeert een deel van de eisen van 802.11i en is ontworpen
	voor implementatie op verouderde hardware.  In het bijzonder
	vereist WPA alleen de TKIP-sleutel die van de originele
	WEP-sleutel is afgeleid.  802.11i staat het gebruik van TKIP toe
	maar vereist ook ondersteuning voor een sterkere sleutel,
	AES-CCM, om gegevens te versleutelen.  (De AES-sleutel was niet
	nodig in WPA omdat het rekenkundig te kostbaar werd geacht voor
	implementatie op verouderde hardware.)</para>

      <para>Afgezien van de bovenstaande protocolstandaarden is de
	andere belangrijke standaard waarvan bewustzijn belangrijk is
	802.11e.  Deze standaard definieert het opstellen van
	multimediatoepassingen zoals gestroomde video en voice over IP
	(VoIP) binnen een 802.11-netwerk.  Net als 802.11i heeft ook
	802.11e een voorgaande specificatie genaamd WME (later hernoemd
	tot WMM) die door een industriegroep is gedefinieerd als een
	deelverzameling van 802.11e die nu kan worden gebruikt om
	multimediatoepassingen mogelijk te maken terwijl er gewacht
	wordt op de uiteindelijke ratificatie van 802.11e.  Het
	belangrijkste om over 802.11e en WME/WMM te weten is dat ze
	gepriotiseerd verkeersgebruik van een draadloos netwerk mogelijk
	maken door middel van Quality of Service (QoS) protocollen en
	protocollen voor verbeterde mediatoegang.  Een juiste
	implementatie van deze protocollen maken snelle gegevensbursts
	en gepriotiseerde verkeersstromen mogelijk.</para>

      <para>&os; ondersteunt netwerken die met 802.11a,
	802.11b, en 802.11g werken.  Ook worden de
	veiligheidsprotocollen WPA en 802.11i ondersteund (samen met
	11a, 11b, of 11g) en QoS en de verkeerspriorisatieprotocollen
	die nodig zijn voor de protocollen WME/WMM worden voor een
	beperkte verzameling draadloze apparatuur ondersteund.</para>
    </sect2>

    <sect2 xml:id="network-wireless-basic">
      <title>Basisinstallatie</title>

      <sect3>
	<title>Kernelinstellingen</title>

	<para>Om van een draadloos netwerk gebruik te maken is het nodig
	  om een draadloze netwerkkaart te hebben en om de kernel met de
	  juiste ondersteuning voor draadloze netwerken in te stellen.
	  Het laatste is verdeeld in meerdere modulen zodat alleen de
	  software ingesteld hoeft te worden die daadwerkelijk gebruikt
	  zal worden.</para>

	<para>Ten eerste is een draadloos netwerkapparaat nodig.  De
	  meestgebruikte apparaten zijn degenen die onderdelen van
	  Atheros gebruiken.  Deze apparaten worden ondersteund door het
	  stuurprogramma &man.ath.4; en voor hen dient de volgende regel
	  aan <filename>/boot/loader.conf</filename>
	  toegevoegd te worden:</para>

	<programlisting>if_ath_load="YES"</programlisting>

	<para>Het stuurprogramma voor Atheros is opgedeeld in drie
	  verschillende delen: het eigenlijke stuurprogramma
	  (&man.ath.4;), de ondersteuningslaag voor de hardware die
	  chip-specifieke functies afhandelt (&man.ath.hal.4;), en een
	  algoritme om de snelheid om frames te verzenden te kiezen uit
	  een reeks mogelijke waarden (hier ath_rate_sample).  Indien
	  deze ondersteuning als kernelmodules wordt geladen, zullen de
	  afhankelijkheden automatisch afgehandeld worden.  Voor andere
	  apparaten dan die van Atheros dient de module voor dat
	  stuurprogramma geladen te worden; bijvoorbeeld:</para>

	<programlisting>if_wi_load="YES"</programlisting>

	<para>voor apparaten die op onderdelen van Intersil Prism zijn
	  gebaseerd (stuurprogramma &man.wi.4;).</para>

	<note>
	  <para>In de rest van dit document zal een &man.ath.4; apparaat
	    gebruikt worden, de naam van het apparaat in de voorbeelden
	    dient aangepast te worden aan de lokale installatie.  Een
	    lijst van beschikbare draadloze stuurprogramma's en ondersteunde
	    adapters staat in de &os; Hardware Notes.  Kopieën hiervan
	    voor verschillende uitgaven en architecturen zijn beschikbaar op
	    de <link xlink:href="http://www.FreeBSD.org/releases/index.html">Uitgave
	      Informatie</link> pagina van de &os; website.  Indien er geen
	    origineel stuurprogramma voor het draadloze apparaat
	    bestaat, is het mogelijk om te proberen om direct het
	    stuurprogramma van &windows; proberen te gebruiken met
	    behulp van de stuurprogramma-wrapper <link linkend="config-network-ndis">NDIS</link>.</para>
	</note>

	<para>Daarvoor zijn ook de modules nodig die cryptografische
	  ondersteuning implementeren voor de te gebruiken
	  veiligheidsprotocollen.  Het is de bedoeling dat ze dynamisch
	  door de module &man.wlan.4; worden geladen maar momenteel
	  dienen ze handmatig ingesteld te worden.  De volgende modules
	  zijn beschikbaar: &man.wlan.wep.4;, &man.wlan.ccmp.4;, en
	  &man.wlan.tkip.4;.  Zowel de stuurprogramma's
	  &man.wlan.ccmp.4; en &man.wlan.tkip.4; zijn alleen nodig
	  indien het veiligheidsprotocol WPA en/of 802.11i gebruikt
	  wordt.  Indien het netwerk encryptieloos dient te zijn, is de
	  ondersteuning van &man.wlan.wep.4; niet nodig.  Om deze modules
	  tijdens het opstarten te laden, dienen de volgende regels aan
	  <filename>/boot/loader.conf</filename> toegevoegd te worden:</para>

	<programlisting>wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"</programlisting>

	<para>Nadat deze informatie aan het instellingenbestand om het
	  systeem op te starten (i.e.,
	  <filename>/boot/loader.conf</filename>) is toegevoegd, is het
	  noodzakelijk om de &os;-computer opnieuw op te starten.
	  Indien het ongewenst is om de computer nu opnieuw op te
	  starten, kunnen de modules ook handmatig worden geladen door
	  &man.kldload.8; te gebruiken.</para>

	<note>
	  <para>Indien het gebruik van modules ongewenst is, kunnen deze
	    stuurprogramma's in de kernel worden gecompileerd door de
	    volgende regels aan het kernelinstellingenbestand toe te
	    voegen:</para>

	  <programlisting>device wlan              # 802.11 ondersteuning
device wlan_wep          # 802.11 WEP-ondersteuning
device wlan_ccmp         # 802.11 CCMP-ondersteuning
device wlan_tkip         # 802.11 TKIP-ondersteuning
device wlan_amrr	 # AMRR controle-algoritme voor zendsnelheid
device ath	         # Atheros PCI/Cardbus netwerkkaarten
device ath_hal		 # Ondersteuning voor PCI/cardbus chips
options AH_SUPPORT_AR5146 # zet AR5146 tx/rx descriptors aan
device ath_rate_sample   # SampleRate verzendsnelheid-controle voor ath</programlisting>

	  <para>Met deze informatie in het kernelinstellingenbestand kan
	    de kernel opnieuw gecompileerd en de &os;-computer opnieuw
	    opgestart worden.</para>
	</note>

	<para>Wanneer het systeem draait, is het mogelijk om enige
	  informatie over de draadloze apparaten in de
	  opstartboodschappen te vinden, zoals:</para>

	<screen>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Infrastructuurmodus</title>

      <para>De infrastructuur- of BSS-modus is de modus die normaliter
	gebruikt wordt.  In deze modus zijn een aantal draadloze
	toegangspunten verbonden met een bedraad netwerk.  Elk draadloos
	netwerk heeft een eigen naam, deze naam wordt de SSID van het
	netwerk genoemd.  Draadloze cliënten verbinden zich met de
	draadloze toegangspunten.</para>

      <sect3>
	<title>&os; cliënten</title>

	<sect4>
	  <title>Hoe toegangspunten te vinden</title>

	  <para>Voor het scannen van netwerken wordt het commando
	    <command>ifconfig</command> gebruikt.  Het kan even duren
	    voordat dit verzoek is afgehandeld aangezien het systeem op
	    elke beschikbare draadloze frequentie naar toegangspunten
	    moet zoeken.  Alleen de super-gebruiker kan zo'n scan
	    opzetten:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID  BSSID              CHAN RATE   S:N     INT CAPS
dlinkap       00:13:46:49:41:76   11   54M -90:96 100 EPS  WPA WME
freebsdap     00:11:95:c3:0d:ac    1   54M -83:96 100 EPS  WPA</screen>

	  <note>
	    <para>De interface dient als up te worden gemarkeerd
	      voordat het scannen begint.  Voor verdere scans is het
	      niet nodig om de interface als up te markeren.</para>
	  </note>

	  <para>De uitvoer van een scanverzoek vermeld elk gevonden
	    BSS/IBSS-netwerk.  Naast de naam van het netwerk,
	    <literal>SSID</literal>, staat het <literal>BSSID</literal>,
	    wat het MAC-adres van het toegangspunt is.  Het veld
	    <literal>CAPS</literal> identificeert het type van elk
	    netwerk en de mogelijkheden van de stations die daar
	    werkzaam zijn:</para>

	  <table frame="none" pgwide="0">
	    <title>Station Capability Codes</title>

	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Capability Code</entry>
		  <entry>Betekenis</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry><literal>E</literal></entry>

		  <entry>Uitgebreide dienstenverzameling (ESS).  Geeft aan
		    dat het station deel uitmaakt van een
		    infrastructuurnetwerk (in tegenstelling tot een IBSS-/
		    ad-hoc-netwerk).</entry>
		</row>

		<row>
		  <entry><literal>I</literal></entry>

		  <entry>IBSS-/ad-hoc-netwerk.  Geeft aan dat het station
		    deel uitmaakt van een ad-hoc-netwerk (in tegenstelling
		    tot een ESS-netwerk).</entry>
		</row>

		<row>
		  <entry><literal>P</literal></entry>

		  <entry>Privacy.  Vertrouwelijkheid is vereist voor alle
		    gegevensframes die binnen het BSS worden uitgewisseld.
		    Dit betekent dat dit BSS eist dat het station
		    cryptografische middelen als WEP, TKIP of AES-CCMP
		    dient te gebruiken om de gegevensframes die met
		    anderen worden uitgewisseld te versleutelen en te
		    ontsleutelen.</entry>
		</row>

		<row>
		  <entry><literal>S</literal></entry>

		  <entry>Korte preambule.  Geeft aan dat het netwerk korte
		    preambules gebruikt (gedefinieerd in 802.11b Hoge
		    Snelheid/DSSS PHY, korte preambule gebruikt een
		    56-bits synchronisatieveld in tegenstelling tot een
		    128-bits dat bij lange preambules wordt
		    gebruikt).</entry>
		</row>

		<row>
		  <entry><literal>s</literal></entry>

		  <entry>Korte slottijd.  Geeft aan dat het 802.11g-netwerk
		    een korte slottijd gebruikt omdat er geen verouderde
		    (802.11b) stations aanwezig zijn.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Het is ook mogelijk om de huidige lijst van bekende
	    netwerken weer te geven met:</para>

	  <screen>&prompt.root; <userinput>ifconfig scan0 list scan</userinput></screen>

	  <para>Deze informatie kan automatisch bijgewerkt worden door
	    de adapter of handmatig met een <option>scan</option>
	    verzoek.  Oude gegevens worden automatisch uit de cache
	    verwijderd, dus kan deze lijst na verloop van tijd korter
	    worden tenzij er meer scanverzoeken gedaan worden.</para>
	</sect4>

	<sect4>
	  <title>Basisinstellingen</title>

	  <para>Deze sectie geeft een eenvoudig voorbeeld hoe de
	    draadloze netwerkadapter in &os; zonder encryptie aan de
	    praat te krijgen.  Nadat deze concepten bekend zijn, wordt
	    het sterk aangeraden om <link linkend="network-wireless-wpa">WPA</link> te gebruiken om
	    de draadloze netwerken op te zetten.</para>

	  <para>Er zijn drie basisstappen om een draadloos netwerk in te
	    stellen: een toegangspunt kiezen, het station authenticeren,
	    en een IP-adres instellen.  De volgende secties behandelen
	    elk een stap.</para>

	  <sect5>
	    <title>Een toegangspunt kiezen</title>

	    <para>In de meeste gevallen is het voldoende om het systeem
	      een toegangspunt gebaseerd op de ingebouwde heuristieken
	      te laten kiezen.  Dit is het standaardgedrag wanneer een
	      interface als up wordt gemarkeerd of als een interface
	      wordt ingesteld door het te noemen in
	      <filename>/etc/rc.conf</filename>, bijvoorbeeld:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Indien er meerdere toegangspunten zijn en het gewenst
	      is om een specifieke te kiezen, kan dit met het SSID:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>uw_ssid_hier</replaceable> DHCP"</programlisting>

	    <para>In een omgeving waar meerdere toegangspunten hetzelfde
	      SSID hebben (vaak gedaan om roamen eenvoudiger te maken)
	      kan het nodig zijn om met één specifiek
	      apparaat te associëren.  In dit geval kan ook het
	      BSSID van het toegangspunt gespecificeerd worden (het SSID
	      kan ook weggelaten worden):</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>uw_ssid_hier</replaceable> bssid <replaceable>xx:xx:xx:xx:xx:xx</replaceable> DHCP</programlisting>

	    <para>Er zijn andere manieren om de keuze van een
	      toegangspunt te beperken zoals het beperken van het aantal
	      frequenties waarop het systeem scant.  Dit kan handig zijn
	      bij multi-band-netwerkkaarten aangezien het scannen van
	      alle mogelijke kanalen tijdrovend kan zijn.  Om de werking
	      tot een specifieke band te beperken kan de parameter
	      <option>mode</option> gebruikt worden; bijvoorbeeld:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="mode <replaceable>11g</replaceable> ssid <replaceable>uw_ssid_hier</replaceable> DHCP"</programlisting>

	    <para>zal de kaart forceren om te werken in 802.11g welke
	      alleen voor 2,4GHz frequenties is gedefinieerd dus de 5GHz
	      kanalen blijven buiten beschouwing.  Andere manieren om
	      dit te doen zijn de parameter <option>channel</option>,
	      om bewerkingen op één specifieke frequentie
	      vast te zetten, en de parameter <option>chanlist</option>,
	      om een lijst van te scannen kanalen te specificeren.  Meer
	      informatie over deze parameters kan in de hulppagina
	      &man.ifconfig.8; gevonden worden.</para>
	  </sect5>

	  <sect5>
	    <title>Authenticatie</title>

	    <para>Nadat er een toegangspunt is gekozen moet het station
	      zich authenticeren voordat het gegevens kan versturen.
	      Authenticatie kan op verschillende manieren gebeuren.  Het
	      meest gebruikte schema wordt open authenticatie genoemd en
	      staat doe dat elk station aan het netwerk deelneemt en
	      communiceert.  Deze manier van authenticatie dient
	      gebruikt te worden voor testdoeleinden tijdens het voor de
	      eerste keer opzetten van een draadloos netwerk.  Andere
	      schema's vereisen dat cryptografische overeenkomsten
	      voltooid worden voordat gegevensverkeer kan stromen; ofwel
	      door vooraf gedeelde sleutels of geheimen te gebruiken, of
	      door complexere schema's te gebruiken welke achterliggende
	      diensten zoals RADIUS betrekken.  De meeste gebruikers
	      zullen open authenticatie gebruiken welke de
	      standaardinstelling is.  De dan meest voorkomende
	      opstelling is WPA-PSK, ook bekend als WPA Personal, welke
	      <link linkend="network-wireless-wpa-wpa-psk">hieronder</link>
	      beschreven is.</para>

	    <note>
	      <para>Indien er een &apple; &airport; Extreme basisstation
		als toegangspunt wordt gebruikt kan het nodig zijn om
		gedeelde-sleutel-authenticatie samen met een WEP-sleutel
		in te stellen.  Dit kan gedaan worden in het bestand
		<filename>/etc/rc.conf</filename> of door het programma
		&man.wpa.supplicant.8; te gebruiken.  Indien er een
		enkel &airport; basisstation wordt gebruikt kan de
		toegang met zoiets als het volgende worden
		ingesteld:</para>

	      <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey <replaceable>1</replaceable> wepkey <replaceable>01234567</replaceable> DHCP"</programlisting>

	      <para>Over het algemeen dient authenticatie via gedeelde
		sleutels worden voorkomen omdat het materiaal van de
		WEP-sleutel op een zeer afgedwongen manier gebruikt wordt wat
		het zelfs gemakkelijker maakt om de sleutel te kraken.
		Indien WEP gebruikt moet worden (bijvoorbeeld voor
		compatibiliteit met verouderde apparaten) is het beter
		om WEP met <literal>open</literal> authenticatie te
		gebruiken.  Meer informatie met betrekking tot WEP kan
		gevonden worden in <xref linkend="network-wireless-wep"/>.</para>
	    </note>
	  </sect5>

	  <sect5>
	    <title>Een IP-adres verkrijgen met DHCP</title>

	    <para>Nadat het toegangspunt is gekozen en de parameters
	      voor de authenticatie zijn ingesteld, dient er een
	      IP-adres ter communicatie verkregen worden.  In de meeste
	      gevallen wordt het draadloze IP-adres verkregen via DHCP.
	      Om dat te bereiken, dient
	      <filename>/etc/rc.conf</filename> bewerkt te worden en
	      <literal>DHCP</literal> aan de instellingen voor het
	      apparaat toegevoegd te worden zoals in de verschillende
	      bovenstaande voorbeelden is laten zien:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Op dit moment kan de draadloze interface geactiveerd
	      worden:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput></screen>

	    <para>Wanneer de interface draait, kan
	      <command>ifconfig</command> gebruikt worden om de status
	      van de interface <filename>ath0</filename> te
	      zien:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
	inet 192.168.1.00 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
	country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	roam:rate 5 protmode CTS wme burst</screen>

	    <para>Het <literal>status: associated</literal> betekent
	      dat er verbinding is met een draadloos netwerk (in dit
	      geval met het netwerk <literal>dlinkap</literal>).  Het
	      gedeelte <literal>bssid 00:13:46:49:41:76</literal> is het
	      MAC-adres van het toegangspunt; de gedeelte met
	      <literal>authmode</literal> vertelt dat de communicatie
	      niet versleuteld is.</para>
	  </sect5>

	  <sect5>
	    <title>Statisch IP-adres</title>

	    <para>In het geval dat het niet mogelijk is om een IP-adres
	      van een DHCP-server te krijgen, kan er een vast IP-adres
	      worden ingesteld.  Vervang het sleutelwoord
	      <literal>DHCP</literal> van hierboven met de
	      adresinformatie.  Zorg ervoor dat de andere parameters
	      voor het selecteren van een toegangspunt behouden
	      blijven:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>uw_ssid_hier</replaceable>"</programlisting>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wpa">
	  <title>WPA</title>

	  <para>WPA (Wi-Fi Protected Access) is een beveiligingsprotocol
	    dat samen met 802.11-netwerken wordt gebruikt om het gebrek
	    aan degelijke authenticatie en de zwakte van <link linkend="network-wireless-wep">WEP</link> te benadrukken.
	    WPA verbetert het 802.1X-authenticatieprotocol en gebruikt
	    een sleutel gekozen uit meerdere in plaats van WEP voor
	    gegevensintegriteit.  De enige sleutel welke WPA vereist is
	    TKIP (Temporary Key Integrity Protocol).  TKIP is een sleutel dat de
	    basis-RC4-sleutel welke door WEP wordt gebruikt uitbreidt
	    door integriteitscontroles, knoeidetectie, en maatregelen om
	    op elke gedetecteerde inbraak te reageren toe te voegen.
	    TKIP is ontworpen om op verouderde hardware met enkel
	    wijzigingen in software te draaien; het representeert een
	    compromis dat de veiligheid verbetert maar nog steeds niet
	    geheel immuun is tegen aanvallen.  WPA specificeert ook de
	    sleutel AES-CCMP als een alternatief voor TKIP welke te
	    verkiezen is indien mogelijk; voor deze specificatie wordt
	    gewoonlijk de term WPA2 (of RSN) gebruikt.</para>

	  <para>WPA definieert protocollen voor authenticatie en
	    versleuteling.  Authenticatie gebeurt het meeste door
	    één van deze twee technieken te gebruiken:
	    door 802.1X en een achterliggende authenticatiedienst zoals
	    RADIUS, of door een minimale overeenkomst tussen het station
	    en het toegangspunt door een van te voren gedeeld geheim te
	    gebruiken.  Het eerste wordt vaak WPA Enterprise genoemd en
	    het laatste staat bekend als WPA Personal.  Aangezien de
	    meeste mensen geen achterliggende RADIUS-server voor hun
	    draadloos netwerk zullen opzetten, is WPA-PSK veruit de
	    meest gebruikte configuratie voor WPA.</para>

	  <para>Het beheer van de draadloze verbinding en de
	    authenticatie (sleutelonderhandeling of authenticatie met
	    een server) gebeurt met het gereedschap
	    &man.wpa.supplicant.8;.  Dit programma vereist dat er een
	    instellingenbestand,
	    <filename>/etc/wpa_supplicant.conf</filename>, draait.
	    Meer informatie over dit bestand kan in de hulppagina
	    &man.wpa.supplicant.conf.5; worden gevonden.</para>

	  <sect5 xml:id="network-wireless-wpa-wpa-psk">
	    <title>WPA-PSK</title>

	    <para>WPA-PSK, ook bekend als WPA-Personal, is gebaseerd op
	      een vooraf gedeelde sleutel (PSK) gegenereerd vanuit een
	      gegeven wachtwoord die gebruikt zal worden als de
	      hoofdsleutel in het draadloze netwerk.  Dit betekent dat
	      alle draadloze gebruikers dezelfde sleutel zullen delen.
	      WPA-PSK is bedoeld voor kleine netwerken waar het gebruik
	      van een authenticatieserver niet mogelijk of gewenst
	      is.</para>

	    <warning>
	      <para>Gebruik altijd sterke wachtwoorden welke voldoende
		lang zijn en opgebouwd zijn uit een grote
		tekenverzameling zodat ze niet gemakkelijk worden
		geraden of aangevallen.</para>
	    </warning>

	    <para>De eerste stap is het instellen van het bestand
	      <filename>/etc/wpa_supplicant.conf</filename> met het SSID
	      en de vooraf gedeelde sleutel van het netwerk:</para>

	    <programlisting>network={
  ssid="freebsdap"
  psk="freebsdmall"
}</programlisting>

	    <para>Daarna zal in <filename>/etc/rc.conf</filename> worden
	      aangegeven dat de draadloze configuratie met WPA zal
	      gebeuren en dat het IP-adres met DHCP zal worden
	      verkregen:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Hierna kan de interface geactiveerd worden:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Ook kan gepoogd worden dit handmatig in te stellen
	      door hetzelfde
	      <filename>/etc/wpa_supplicant.conf</filename> als <link linkend="network-wireless-wpa-wpa-psk">hierboven</link>
	      te gebruiken, en dit te draaien:</para>

	    <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 idstr=]</screen>

	    <para>De volgende stap is het lanceren van het commando
	      <command>dhclient</command> om een IP-adres van de
	      DHCP-server te krijgen:</para>

	    <screen>&prompt.root; <userinput>dhclient wlan0</userinput>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON defxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <note>
	      <para><filename>/etc/rc.conf</filename> heeft een regel
		<literal>ifconfig_wlan0</literal> met de tekst
		<literal>DHCP</literal> (zoals
		<literal>ifconfig_wlan0="DHCP"</literal>),
		<command>dhclient</command> zal automatisch gestart worden nadat
		<command>wpa_supplicant</command> geassocieerd is met het
		toegangspunt.</para>
	    </note>

	    <para>Als DHCP niet mogelijk of gewenst is, kan een statisch
	      IP-adres worden ingesteld nadat <command>wpa_supplicant</command>
	      het station heeft geauthenticeerd:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Indien DHCP niet wordt gebruikt, dienen ook de
	      standaard gateway en de naamserver handmatig ingesteld te
	      worden:</para>

	    <screen>&prompt.root; <userinput>route add default uw_standaard_router</userinput>
&prompt.root; <userinput>echo "nameserver uw_DNS_server" &gt;&gt; /etc/resolv.conf</userinput></screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-tls">
	    <title>WPA met EAP-TLS</title>

	    <para>De tweede manier om WPA te gebruiken is met een
	      achterliggende 802.1X-authenticatieserver.  In dit geval
	      wordt het WPA-Enterprise genoemd om het verschil met het
	      minder veilige WPA-Personal met de vooraf gedeelde sleutel
	      aan te duiden.  Authenticatie is in WPA-Enterprise gebaseerd op
	      EAP (Extensible Authentication Protocol).</para>

	    <para>EAP wordt niet met een encryptiemethode geleverd.  In plaats
	      daarvan was het besloten om EAP in een versleutelde tunnel te
	      omsluiten.  Er bestaan vele EAP-authenticatiemethodes, de meest
	      voorkomende zijn EAP-TLS, EAP-TTLS, en EAP-PEAP.</para>

	    <para>EAP-TLS (EAP met Transport Layer Security) is een zeer
	      goed ondersteund authenticatieprotocol in de draadloze
	      wereld aangezien het de eerste EAP-methode was die
	      gecertificeerd werd door de <link xlink:href="http://www.wi-fi.org">Wi-Fi alliantie</link>.
	      EAP-TLS vereist dat er drie certificaten draaien: het
	      CA-certificaat (geïnstalleerd op alle machines), het
	      servercertificaat voor de authenticatieserver, en een
	      cliëntcertificaat voor elke draadloze cliënt.
	      Bij deze EAP-methode authenticeren zowel de
	      authenticatieserver als de draadloze cliënt elkaar
	      door hun respectievelijke certificaten te laten zien, en
	      ze controleren dat deze certificaten zijn getekend door de
	      certificatenauthoriteit (CA) van de organisatie.</para>

	    <para>Zoals voorheen gebeurt het instellen via
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap" <co xml:id="co-tls-ssid"/>
  proto=RSN  <co xml:id="co-tls-proto"/>
  key_mgmt=WPA-EAP <co xml:id="co-tls-kmgmt"/>
  eap=TLS <co xml:id="co-tls-eap"/>
  identity="loader" <co xml:id="co-tls-id"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-tls-cacert"/>
  client_cert="/etc/certs/clientcert.pem" <co xml:id="co-tls-clientcert"/>
  private_key="/etc/certs/clientkey.pem" <co xml:id="co-tls-pkey"/>
  private_key_passwd="freebsdmallclient" <co xml:id="co-tls-pwd"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-tls-ssid">
		<para>Dit veld geeft de naam van het netwerk (SSID) aan.</para>
	      </callout>

	      <callout arearefs="co-tls-proto">
		<para>Hier wordt het RSN (&ieee; 802.11i) protocol
		  gebruikt, ofwel WPA2.</para>
	      </callout>

	      <callout arearefs="co-tls-kmgmt">
		<para>De regel <literal>key_mgmt</literal> verwijst naar
		  het gebruikte sleutelbeheerprotocol.  In dit geval is
		  het WPA dat EAP-authenticatie gebruikt:
		  <literal>WPA-EAP</literal>.</para>
	      </callout>

	      <callout arearefs="co-tls-eap">
		<para>In dit veld wordt de EAP-methode voor de
		  verbinding genoemd.</para>
	      </callout>

	      <callout arearefs="co-tls-id">
		<para>Het veld <literal>identity</literal> bevat de
		  identiteitsstring voor EAP.</para>
	      </callout>

	      <callout arearefs="co-tls-cacert">
		<para>Het veld <literal>ca_cert</literal> geeft de
		  padnaam van het CA-certificaatbestand aan.  Dit
		  bestand is nodig om het servercertificaat te
		  controleren.</para>
	      </callout>

	      <callout arearefs="co-tls-clientcert">
		<para>De regel <literal>client_cert</literal> geeft de
		  padnaam van het cliëntcertificaatbestand aan.
		  Dit certificaat is uniek voor elke draadloze
		  cliënt van het netwerk.</para>
	      </callout>

	      <callout arearefs="co-tls-pkey">
		<para>Het veld <literal>private_key</literal> is de
		  padnaam naar het bestand dat de privésleutel
		  van het cliëntcertificaat bevat.</para>
	      </callout>

	      <callout arearefs="co-tls-pwd">
		<para>Het veld <literal>private_key_passwd</literal>
		  bevat het wachtwoord voor de privésleutel.</para>
	      </callout>
	    </calloutlist>

	    <para>Voeg vervolgens de volgende regels toe aan
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>De volgende stap is het activeren van de interface:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Zoals eerder is laten zien, is het ook mogelijk om de
	      interface handmatig te activeren met zowel de commando's
	      <command>wpa_supplicant</command> en
	      <command>ifconfig</command>.</para>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-ttls">
	    <title>WPA met EAP-TTLS</title>

	    <para>Bij EAP-TLS hebben zowel de authenticatieserver als de
	      cliënt een certificaat nodig, met EAP-TTLS
	      (EAP-Tunneled Transport Layer Security) is een
	      cliëntcertificaat optioneel.  Deze methode komt in de
	      buurt van wat sommige beveiligde websites doen, waar de
	      webserver een veilige SSL-tunnel kan aanmaken zelfs als de
	      bezoekers geen certificaten aan de cliëntkant hebben.
	      EAP-TTLS zal de versleutelde TLS-tunnel gebruiken voor het
	      veilig transporteren van de authenticatiegegevens.</para>

	    <para>De instellingen worden gedaan via het bestand
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <co xml:id="co-ttls-eap"/>
  identity="test" <co xml:id="co-ttls-id"/>
  password="test" <co xml:id="co-ttls-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-ttls-cacert"/>
  phase2="auth=MD5" <co xml:id="co-ttls-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-ttls-eap">
		<para>Dit veld noemt de EAP-methode voor de
		  verbinding.</para>
	      </callout>

	      <callout arearefs="co-ttls-id">
		<para>Het veld <literal>identity</literal> bevat de
		  identiteitsstring voor EAP-authenticatie binnen de
		  versleutelde TLS-tunnel.</para>
	      </callout>

	      <callout arearefs="co-ttls-passwd">
		<para>Het veld <literal>password</literal> bevat het
		  wachtwoord voor de EAP-authenticatie.</para>
	      </callout>

	      <callout arearefs="co-ttls-cacert">
		<para>Het veld <literal>ca_cert</literal> wijst naar de
		  padnaam van het CA-certificaatbestand.  Dit bestand is
		  nodig om het servercertificaat te controleren.</para>
	      </callout>

	      <callout arearefs="co-ttls-pha2">
		<para>Dit veld noemt de gebruikte authenticatiemethode
		  in de versleutelde TLS-tunnel.  In dit geval is EAP
		  met MD5-Challenge gebruikt.  De <quote>binnenste
		    authenticatie</quote>-fase wordt vaak
		  <quote>phase2</quote> genoemd.</para>
	      </callout>
	    </calloutlist>

	    <para>Ook dienen de volgende regels toegevoegd te worden aan
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_ath0="WPA DHCP"</programlisting>

	    <para>De volgende stap is het activeren van de interface:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-peap">
	    <title>WPA met EAP-PEAP</title>

	    <note>
	      <para>PEAPv0/EAP-MSCHAPv2 is de meest gebruikelijke PEAP-methode.
		In de rest van dit document wordt de term PEAP gebruikt om naar
		die methode te verwijzen.</para>
	    </note>

	    <para>PEAP (Beveiligd EAP) is ontworpen als een alternatief
	      voor EAP-TTLS, en is de meest gebruikte EAP-standaard na EAP-TLS.
	      Met andere woorden, als u een netwerk met verschillende
	      besturingssystemen heeft, zou PEAP de meest ondersteunde standaard
	      moeten zijn na EAP-TLS.</para>

	    <para>PEAP is soortgelijk aan EAP-TTLS:  het gebruikt een
	      server-side certificaat om de cliënten te
	      authenticeren door een beveiligde TLS-tunnel tussen de
	      cliënt en de authenticatieserver aan te maken, welke
	      de uitwisseling van de authenticatie-informatie beschermt.
	      Vanuit een beveiligingsoogpunt gezien is het verschil
	      tussen EAP-TTLS en PEAP dat PEAP-authenticatie de
	      gebruikersnaam onversleuteld uitzendt, alleen het
	      wachtwoord wordt in de beveiligde TLS-tunnel verzonden.
	      EAP-TTLS gebruikt de TLS-tunnel voor zowel de
	      gebruikersnaam als het wachtwoord.</para>

	    <para>Het bestand
	      <filename>/etc/wpa_supplicant.conf</filename> dient
	      gewijzigd te worden om de EAP-PEAP-gerelateerde
	      instellingen toe te voegen:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <co xml:id="co-peap-eap"/>
  identity="test" <co xml:id="co-peap-id"/>
  password="test" <co xml:id="co-peap-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-peap-cacert"/>
  phase1="peaplabel=0" <co xml:id="co-peap-pha1"/>
  phase2="auth=MSCHAPV2" <co xml:id="co-peap-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-peap-eap">
		<para>Dit veld noemt de EAP-methode voor de
		  verbinding.</para>
	      </callout>

	      <callout arearefs="co-peap-id">
		<para>Het veld <literal>identity</literal> bevat de
		  identiteitsstring voor EAP-authenticatie binnen de
		  versleutelde TLS-tunnel.</para>
	      </callout>

	      <callout arearefs="co-peap-passwd">
		<para>Het veld <literal>password</literal> bevat het
		  wachtwoord voor de EAP-authenticatie.</para>
	      </callout>

	      <callout arearefs="co-peap-cacert">
		<para>Het veld <literal>ca_cert</literal> wijst naar de
		  padnaam van het CA-certificaatbestand.  Dit bestand is
		  nodig om het servercertificaat te controleren.</para>
	      </callout>

	      <callout arearefs="co-peap-pha1">
		<para>Dit veld bevat de parameters voor de eerste fase
		  van authenticatie (de TLS-tunnel).  Afhankelijk van
		  de gebruikte authenticatieserver moet er een specifiek
		  label voor authenticatie worden opgegeven.  In de
		  meeste gevallen zal het label <quote>client EAP
		    encryption</quote> zijn welke ingesteld is door
		  <literal>peaplabel=0</literal> te gebruiken.  Meer
		  informatie kan in de hulppagina
		  &man.wpa.supplicant.conf.5; gevonden worden.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>Dit veld noemt het authenticatieprotocol dat in de
		  versleutelde TLS-tunnel gebruikt wordt.  In het geval
		  van PEAP is dit <literal>auth=MSCHAPV2</literal>.</para>
	      </callout>
	    </calloutlist>

	    <para>Het volgende dient te worden toegevoegd aan
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Hierna kan de interface worden geactiveerd:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wep">
	  <title>WEP</title>

	  <para>WEP (Wired Equivalent Privacy) maakt deel uit van de
	    oorspronkelijke 802.11 standaard.  Er is geen
	    authenticatiemechanisme, slechts een zwakke vorm van
	    toegangscontrole, en het is gemakkelijk te kraken.</para>

	  <para>WEP kan worden opgezet met
	    <command>ifconfig</command>:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \
	    ssid mijn_net wepmode on weptxkey 3 wepkey 3:0x3456789012</userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para>De <literal>weptxkey</literal> geeft aan welke
		WEP-sleutel zal worden gebruikt tijdens het verzenden.
		Hier wordt de derde sleutel gebruikt.  Dit dient
		overeen te komen met de instelling in het toegangspunt.
		Probeer, indien onbekend is welke sleutel door het toegangspunt
		wordt gebruikt, <literal>1</literal> (i.e., de eerste sleutel)
		voor deze waarde te gebruiken.</para>
	    </listitem>

	    <listitem>
	      <para>De <literal>wepkey</literal> selecteert één
		van de WEP-sleutels in.  Het dient in het formaat
		<replaceable>index:sleutel</replaceable> te zijn.  Sleutel
		<literal>1</literal> wordt als standaard gebruikt; de index
		hoeft alleen ingesteld te worden als we een andere dan de
		eerste sleutel gebruiken.</para>

	      <note>
		<para>De <literal>0x3456789012</literal> dient vervangen
		  te worden door de sleutel die ingesteld is voor
		  gebruik met het toegangspunt.</para>
	      </note>
	    </listitem>
	  </itemizedlist>

	  <para>Het wordt aangeraden om de hulppagina &man.ifconfig.8;
	    te lezen voor verdere informatie.</para>

	  <para>De faciliteit <command>wpa_supplicant</command> kan ook
	    gebruikt worden om de draadloze interface in te stellen voor
	    WEP.  Het bovenstaande voorbeeld kan worden ingesteld door
	    de volgende regels toe te voegen aan
	    <filename>/etc/wpa_supplicant.conf</filename>:</para>

	  <programlisting>network={
  ssid="mijn_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</programlisting>

	  <para>Daarna:</para>

	  <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76</screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Ad-hoc-modus</title>

      <para>IBSS-modus, ook ad-hoc-modus genoemd, is ontworpen voor
	point-to-point-verbindingen.  Om bijvoorbeeld een ad-hoc-netwerk
	tussen de machine <systemitem>A</systemitem> en de machine
	<systemitem>B</systemitem> op te zetten, is het slechts nodig om twee
	IP-adressen en een SSID te kiezen.</para>

      <para>Op machine <systemitem>A</systemitem>:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</screen>

      <para>De parameter <literal>adhoc</literal> geeft aan dat de
	interface in de IBSS-modus draait.</para>

      <para>Op <systemitem>B</systemitem> zal het mogelijk moeten zijn om
	<systemitem>A</systemitem> te detecteren:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  reebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</screen>

      <para>De <literal>I</literal> in de uitvoer bevestigt dat machine
	<systemitem>A</systemitem> in ad-hoc-modus verkeert.  Het is slechts
	nodig om <systemitem>B</systemitem> met een ander IP-adres in te
	stellen:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0 ssid freebsdap mediaopt adhoc inet 192.168.0.2 netmask 255.255.255.0</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</screen>

      <para>Zowel <systemitem>A</systemitem> als <systemitem>B</systemitem> zijn nu
	klaar om informatie uit te wisselen.</para>
    </sect2>

    <sect2 xml:id="network-wireless-ap">
      <title>&os; Host Toegangspunten</title>

      <para>&os; kan als toegangspunt (AP) functioneren wat de noodzaak
	om een hardwarematig AP te kopen of een ad-hoc-netwerk te
	draaien wegneemt.  Dit kan bijzonder nuttig zijn indien de
	&os;-machine als gateway naar een ander netwerk (bijvoorbeeld
	het Internet) functioneert.</para>

      <sect3 xml:id="network-wireless-ap-basic">
	<title>Basisinstellingen</title>

	<para>Voordat de &os;-machine als een AP wordt ingesteld, dient
	  de kernel te worden ingesteld met de juiste ondersteuning voor
	  draadloos netwerken voor de draadloze kaart.  Ook dient er
	  ondersteuning voor de te gebruiken beveiligingsprotocollen te
	  worden toegevoegd.  Meer details staan in <xref linkend="network-wireless-basic"/>.</para>

	<note>
	  <para>Momenteel staan de NDIS-stuurprogrammawrapper en de
	    stuurprogramma's van &windows; het werken als AP niet toe.
	    Alleen originele draadloze &os;-stuurprogramma's
	    ondersteunen AP-modus.</para>
	</note>

	<para>Wanneer de ondersteuning voor draadloos netwerken is
	  geladen, kan gecontroleerd worden of het draadloze apparaat
	  de hostgebaseerde toegangspuntmodus ondersteunt (ook bekend
	  als hostap-modus):</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 list caps</userinput>
drivercaps=6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</screen>

	<para>Deze uitvoer geeft de mogelijkheden van de kaart weer, het
	  woord <literal>HOSTAP</literal> bevestigt dat deze draadloze
	  kaart als toegangspunt kan functioneren.  Ook worden
	  verschillende ondersteunde versleutelmethoden genoemd: WEP,
	  TKIP, AES, enzovoorts.  Deze informatie is belangrijk om te weten
	  welke beveiligingsprotocollen gebruikt kunnen worden op het
	  toegangspunt.</para>

	<para>Het draadloze apparaat kan enkel in hostap-modus worden
	  gezet tijdens het creeëren van het netwerk pseudo-device
	  dus een vooraf aangemaakt apparaat moet eerst verwijderd
	  worden:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 destroy</userinput></screen>

	<para>waarna deze opnieuw aangemaakt kan worden met de juiste
	  parameters:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</userinput></screen>

	<para>Gebruik nogmaals <command>ifconfig</command> om de status van
	  de interface <filename>wlan0</filename> te zien:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  status: running
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>De parameter <literal>hostap</literal> geeft aan dat de
	  interface in hostgebaseerde toegangspuntmodus draait.</para>

	<para>Het instellen van de interface kan automatisch tijdens het
	  opstarten gedaan worden door de volgende regels aan
	  <filename>/etc/rc.conf</filename> toe te voegen:</para>

	<programlisting>wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel <replaceable>1</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>Hostgebaseerde toegangspunt zonder authenticatie of
	  versleuteling</title>

	<para>Hoewel het niet aangeraden wordt om een AP zonder enige
	  vorm van authenticatie of encryptie te draaien, is dit een
	  eenvoudige manier om te controleren of het AP werkt.  Deze
	  configuratie is ook belangrijk voor het debuggen van problemen
	  met cliënten.</para>

	<para>Nadat het AP is ingesteld als eerder is laten zien, is het
	  mogelijk om van een andere draadloze machine een scan te
	  beginnen om het AP te vinden:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</screen>

	<para>De cliëntmachine heeft het AP gevonden en kan ermee
	  geassocieerd worden:</para>

	<screen>&prompt.root; <userinput>ifconfig ath0 ssid freebsdap inet 192.168.0.2 netmask 255.255.255.0</userinput>
  <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</screen>
      </sect3>

      <sect3>
	<title>WPA hostgebaseerde toegangspunt</title>

	<para>Deze sectie zal zich richten op opzetten van een &os;
	  toegangspunt dat het beveiligingsprotocol WPA gebruikt.  Meer
	  details over WPA en het instellen van op WPA gebaseerde
	  draadloze cliënten kan gevonden worden in <xref linkend="network-wireless-wpa"/>.</para>

	<para>De daemon <application>hostapd</application> wordt
	  gebruikt om cliëntauthenticatie en sleutelbeheer op het
	  toegangspunt met WPA af te handelen.</para>

	<para>In het volgende zullen alle instellingsbewerkingen worden
	  uitgevoerd op de &os;-machine die als AP dienst doet.  Wanneer
	  het AP correct werkt, zou <application>hostapd</application>
	  automatisch tijdens het opstarten aangezet moeten worden met
	  de volgende regel in <filename>/etc/rc.conf</filename>:</para>

	<programlisting>hostapd_enable="YES"</programlisting>

	<para>Zorg ervoor dat voordat geprobeerd wordt om
	  <application>hostapd</application> in te stellen, de
	  basisinstellingen die in <xref linkend="network-wireless-ap-basic"/> zijn geïntroduceerd
	  zijn uitgevoerd.</para>

	<sect4>
	  <title>WPA-PSK</title>

	  <para>WPA-PSK is bedoeld voor kleine netwerken waar het
	    gebruik van een achterliggende authenticatieserver niet
	    mogelijk of gewenst is.</para>

	  <para>Het instellen wordt gedaan in het bestand
	    <filename>/etc/hostapd.conf</filename>:</para>

	  <programlisting>interface=wlan0 <co xml:id="co-ap-wpapsk-iface"/>
debug=1 <co xml:id="co-ap-wpapsk-dbug"/>
ctrl_interface=/var/run/hostapd <co xml:id="co-ap-wpapsk-ciface"/>
ctrl_interface_group=wheel <co xml:id="co-ap-wpapsk-cifacegrp"/>
ssid=freebsdap <co xml:id="co-ap-wpapsk-ssid"/>
wpa=1 <co xml:id="co-ap-wpapsk-wpa"/>
wpa_passphrase=freebsdmall <co xml:id="co-ap-wpapsk-pass"/>
wpa_key_mgmt=WPA-PSK <co xml:id="co-ap-wpapsk-kmgmt"/>
wpa_pairwise=CCMP TKIP <co xml:id="co-ap-wpapsk-pwise"/></programlisting>

	  <calloutlist>
	    <callout arearefs="co-ap-wpapsk-iface">
	      <para>Dit veld geeft aan welke draadloze interface voor
		het toegangspunt wordt gebruikt.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-dbug">
	      <para>Dit veld stelt het verbositeitsniveau in dat tijdens
		het draaien van <application>hostapd</application> wordt
		gebruikt.  Een waarde van <literal>1</literal>
		vertegenwoordigt het minimale niveau.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ciface">
	      <para>Het veld <literal>ctrl_interface</literal> geeft de
		padnaam van de door <application>hostapd</application>
		gebruikte map om de domeinsocketbestanden voor
		communicatie met externe programma's zoals
		&man.hostapd.cli.8; in op te slaan.  Hier wordt de
		standaardwaarde gebruikt.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-cifacegrp">
	      <para>De regel <literal>ctrl_interface_group</literal>
		stelt de groep in (hier is het de groep
		<systemitem class="groupname">wheel</systemitem>) die toegang heeft tot de
		controle interfacebestanden.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-wpa">
	      <para>Het veld <literal>wpa</literal> maakt WPA mogelijk
		en specificeert welk WPA-authenticatieprotocol nodig zal
		zijn.  De waarde <literal>1</literal> stelt het AP in op
		WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pass">
	      <para>Het veld <literal>wpa_passphrase</literal> bevat het
		ASCII-wachtwoord voor de WPA-authenticatie.</para>

	      <warning>
		<para>Gebruik altijd sterke wachtwoorden welke voldoende
		  lang zijn en opgebouwd zijn uit een grote
		  tekenverzameling zodat ze niet gemakkelijk worden
		  geraden of aangevallen.</para>
	      </warning>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-kmgmt">
	      <para>De regel <literal>wpa_key_mgmt</literal> verwijst
		naar het gebruikte sleutelbeheerprotocol.  In dit geval
		is dat WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pwise">
	      <para>Het veld <literal>wpa_pairwise</literal> geeft aan
		welke versleutelingsalgoritmes door het toegangspunt
		worden geaccepteerd.  Hier worden zowel de versleuteling
		TKIP (WPA) en CCMP (WPA2) geaccepteerd.  De
		versleuteling CCMP is een alternatief voor TKIP en wordt
		sterk aangeraden indien mogelijk; TKIP dient alleen
		gebruikt te worden voor stations die geen CCMP
		aankunnen.</para>
	    </callout>
	  </calloutlist>

	  <para>De volgende stap is het starten van
	    <application>hostapd</application>:</para>

	  <screen>&prompt.root; <userinput>service hostapd forcestart</userinput></screen>

	  <screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2290
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255dddd
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: associated
	  ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
	  authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100</screen>

	  <para>Het toegangspunt draait nu, de cliënten kunnen er
	    nu mee worden geassocieerd, zie <xref linkend="network-wireless-wpa"/> voor meer details.  Het is
	    mogelijk om de stations die met het AP geassocieerd zijn te
	    zien door het commando <command>ifconfig
	      wlan0 list</command> te
	    gebruiken.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>WEP hostgebaseerd toegangspunt</title>

	<para>Het wordt niet aangeraden om WEP te gebruiken om een
	  toegangspunt op te zetten aangezien er geen
	  authenticatiemechanisme is en het gemakkelijk is te kraken.
	  Sommige verouderde draadloze kaarten ondersteunen alleen WEP
	  als een beveiligingsprotocol, met deze kaarten is het alleen
	  mogelijk om een AP zonder authenticatie of encryptie of een AP
	  dat het WEP-protocol gebruikt op te zetten.</para>

	<para>Het draadloze apparaat kan nu in hostap-modus worden
	  gezet en ingesteld worden met het juiste SSID en
	  IP-adres:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \
  ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</userinput></screen>

	<itemizedlist>
	  <listitem>
	    <para>Het <literal>weptxkey</literal> geeft aan welke
	      WEP-sleutel tijdens het zenden zal worden gebruikt.  Hier
	      wordt de derde sleutel gebruikt (merk op dat de nummering
	      van de sleutels bij <literal>1</literal> begint).  Deze
	      parameter moet gespecificeerd worden om de gegevens
	      daadwerkelijk te versleutelen.</para>
	  </listitem>

	  <listitem>
	    <para>Het <literal>wepkey</literal> geeft aan dat de
	      geselecteerde WEP-sleutel wordt ingesteld.  Het dient in
	      het formaat <replaceable>index:key</replaceable> te zijn,
	      indien de index niet is gegeven, wordt sleutel
	      <literal>1</literal> gebruikt.  Dus indien een andere
	      sleutel dan de eerste wordt gebruikt dient de index te
	      worden ingesteld.</para>
	  </listitem>
	</itemizedlist>

	<para>Weer wordt <command>ifconfig</command> gebruikt om de
	  status van de interface <filename>wlan0</filename> te
	  zien:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>Vanaf een andere draadloze machine is het mogelijk om een
	  scan te beginnen om het AP te vinden:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</screen>

	<para>De cliëntmachine heeft het toegangspunt gevonden en
	  kan ermee geassocieerd worden door de juiste parameters
	  (sleutel, enz.) te gebruiken, zie <xref linkend="network-wireless-wep"/> voor meer details.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Zowel de bekabelde als de draadloze verbinding gebruiken</title>

      <para>Een bekabelde verbinding biedt betere prestaties en betrouwbaarheid,
	terwijl een draadloze verbinding meer flexibiliteit en mobiliteit
	biedt; laptop-gebruikers zullen dit willen combineren en naadloos tussen
	de twee overschakelen.</para>

      <para>In &os; is het mogelijk om twee of meer netwerkinterfaces te
	combineren in een <quote>failover</quote>-opstelling, dit houdt in dat
	de meest geprefereerde en best beschikbare verbinding van een groep van
	netwerkinterfaces wordt gebruikt, en het besturingssysteem automatisch
	te laten overschakelen wanneer de status van de verbinding
	verandert.</para>

      <para>Link-aggregatie en failover worden behandeld in <xref linkend="network-aggregation"/>, een voorbeeld voor het gebruik van
	zowel een bekabelde als een draadloze verbinding wordt gegeven in
	<xref linkend="networking-lagg-wired-and-wireless"/>.</para>
    </sect2>

    <sect2>
      <title>Problemen verhelpen</title>

      <para>Indien er problemen met het draadloos netwerk zijn, zijn er
	een aantal stappen die genomen kunnen worden om het probleem te
	helpen verhelpen.</para>

      <itemizedlist>
	<listitem>
	  <para>Indien het toegangspunt niet vermeld wordt tijdens het
	    scannen, controleer dan of het draadloze apparaat niet is
	    ingesteld op een beperkt aantal kanalen.</para>
	</listitem>

	<listitem>
	  <para>Indien het niet mogelijk is om met een toegangspunt te
	    associëren, controleer dan of de instellingen van het
	    station overeenkomen met die van het toegangspunt.  Dit
	    omvat het authenticatieschema en de beveiligingsprotocollen.
	    Versimpel de configuratie zoveel mogelijk.  Indien een
	    beveiligingsprotocol als WPA of WEP wordt gebruikt, stel het
	    toegangspunt dan in voor open authenticatie en geen
	    beveiliging en kijk of er verkeer door kan.</para>
	</listitem>

	<listitem>
	  <para>Wanneer er met het toegangspunt geassocieerd kan worden,
	    stel dan een diagnose over alle beveiligingsinstellingen met
	    eenvoudige gereedschappen zoals &man.ping.8;.</para>

	  <para><command>wpa_supplicant</command> biedt veel
	    ondersteuning voor debuggen;  probeer het handmatig te
	    draaien met de optie <option>-dd</option> en controleer de
	    systeemlogs.</para>
	</listitem>

	<listitem>
	  <para>Er zijn ook veel debug-gereedschappen op lagere niveaus.
	    Het is mogelijk om debugberichten in de laag die het 802.11
	    protocol ondersteunt aan te zetten door het programma
	    <command>wlandebug</command> te gebruiken dat gevonden wordt
	    in <filename>/usr/src/tools/tools/net80211</filename>.
	    Bijvoorbeeld:</para>

	  <screen>&prompt.root; <userinput>wlandebug -i ath0 +scan+auth+debug+assoc</userinput>
  net.wlan.0.debug: 0 =&gt; 0xc80000&lt;assoc,auth,scan&gt;</screen>

	  <para>kan worden gebruikt om consoleberichten aan te zetten
	    die te maken hebben met het scannen van toegangspunten en
	    het uitvoeren van 802.11 handshakes die nodig zijn om
	    communicatie te regelen.</para>

	  <para>Er worden ook veel nuttige statistieken door de 802.11
	    laag bijgehouden; het gereedschap
	    <command>wlanstats</command> geeft deze informatie weer.
	    Deze statistieken zouden alle fouten die door de 802.11 laag
	    zijn geïdentificeerd moeten identificeren.  Let erop
	    dat sommige fouten worden geïdentificeerd in de
	    apparaatstuurprogramma's die onder de 802.11 laag liggen
	    zodat ze niet verschijnen.  Voor het diagnosticeren van
	    apparaatspecifieke problemen dient de documentatie van het
	    stuurprogramma geraadpleegd te worden.</para>
	</listitem>
      </itemizedlist>

      <para>Indien de bovenstaande informatie niet helpt om het probleem
	te verhelderen, stuur dan een probleemrapport op inclusief de
	uitvoer van de bovenstaande gereedschappen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bluetooth">
    <info><title>Bluetooth</title>
      <authorgroup>
	<author><personname><firstname>Pav</firstname><surname>Lucistnik</surname></personname><contrib>Geschreven door </contrib><affiliation>
	    <address><email>pav@FreeBSD.org</email></address>
	  </affiliation></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>Bluetooth</primary></indexterm>

    <sect2>
      <title>Introductie</title>

      <para>Bluetooth is een draadloze technologie om persoonlijke
	netwerken aan te maken die in de vrije 2,4GHz-band werken binnen
	een straal van 10 meter.  Deze netwerken worden gewoonlijk
	ad-hoc gevormd en bestaan uit draagbare apparaten zoals mobiele
	telefoons, handhelds en laptops.  In tegenstelling tot die
	andere populaire draadloze techniek, Wi-Fi, biedt Bluetooth een
	hoger niveau van serviceprofielen, zoals FTP-achtige
	bestandsservers, pushing van bestanden, stemtransport, emulatie
	van seriële lijnen, en meer.</para>

      <para>De Bluetooth stack is in &os; geïmplementeerd door
	gebruik te maken van het Netgraph-raamwerk (zie
	&man.netgraph.4;).  Veel van de Bluetooth USB-dongles worden
	ondersteund door het stuurprogramma &man.ng.ubt.4;.  Apparaten
	gebaseerd op de Broadcom BCM2033 chip worden ondersteund door de
	stuurprogramma's &man.ubtbcmfw.4; en &man.ng.ubt.4;.  De 3Com
	Bluetooth PC Card 3CRWB60-A wordt ondersteund door het
	stuurprogramma &man.ng.bt3c.4;.  Seriële en op UART
	gebaseerde Bluetooth-apparaten worden ondersteund via
	&man.sio.4;, &man.ng.h4.4;, en &man.hcseriald.8;.  Deze sectie
	beschrijft het gebruik van de USB Bluetooth-dongle.</para>
    </sect2>

    <sect2>
      <title>Het apparaat inprikken</title>

      <para>Standaard zijn stuurprogramma's voor Bluetooth-apparaten
	beschikbaar als kernelmodules.  Voordat een apparaat wordt
	aangekoppeld, dient het stuurprogramma in de kernel geladen te
	worden:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Indien het Bluetooth-apparaat tijdens het opstarten van het
	systeem in het systeem aanwezig is, kan de module vanuit
	<filename>/boot/loader.conf</filename> geladen worden:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Prik de USB-dongle in.  Uitvoer vergelijkbaar aan de
	onderstaande zal op de console (of in syslog) verschijnen:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>&man.service.8; wordt
	gebruikt om de Bluetooth-stack te starten en te stoppen.  Het is
	een goed idee om de stack te stoppen voordat het apparaat wordt
	losgekoppeld, maar het is (gewoonlijk) niet fataal.  Tijdens het
	starten van de stack verschijnt er uitvoer vergelijkbaar met de
	onderstaande:</para>

      <screen>&prompt.root; <userinput>service bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>
    </sect2>

    <sect2>
      <title>Host Controller Interface (HCI)</title>

      <indexterm><primary>HCI</primary></indexterm>

      <para>Het Host Controller Interface (HCI) biedt een
	opdrachtinterface naar de controller van de basisband en de
	verbindingsbeheerder, en toegang tot hardwarestatus en
	controleregisters.  Deze interface biedt een uniforme manier
	om de mogelijkheden van de basisband van Bluetooth te benaderen.
	De HCI-laag op de gastheer wisselt gegevens en opdrachten uit
	met de HCI-firmware in de Bluetooth-hardware.  Het
	stuurprogramma voor de Host Controller Transport Layer (i.e., de
	fysieke bus) biedt aan beide HCI-lagen de mogelijkheid om
	informatie met elkaar uit te wisselen.</para>

      <para>Voor een enkel Bluetooth-apparaat wordt een enkele Netgraph
	knoop van het type <emphasis>hci</emphasis> aangemaakt.  De
	HCI-knoop is normaliter verbonden met de knoop van het
	Bluetooth-apparaatstuurprogramma (naar beneden toe) en de
	L2CAP-knoop (naar boven toe).  Alle HCI-bewerkingen dienen te
	worden uitgevoerd op de HCI-knoop en niet op de knoop van het
	apparaatstuurprogramma.  De standaardnaam voor de HCI-knoop is
	<quote>devicehci</quote>.  Kijk voor meer details in de
	hulppagina &man.ng.hci.4;.</para>

      <para>Eén van de meest voorkomende taken is het ontdekken
	van Bluetooth-apparaten binnen radiobereik.  Deze bewerking
	wordt <emphasis>ondervragen</emphasis> genoemd.  Ondervragen en
	andere HCI-gerelateerde bewerkingen worden uitgevoerd met het
	programma &man.hccontrol.8;.  Het onderstaande voorbeeld laat
	zien hoe kan worden uitgezocht welke Bluetooth-apparaten zich
	binnen het bereik bevinden.  De lijst met apparaten zou binnen
	enkele seconden moeten binnenkomen.  Bedenk dat een apparaat op
	afstand alleen antwoord op de ondervraging zal geven indien het
	in <emphasis>ontdekbare</emphasis> modus staat.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> is een uniek adres van een
	Bluetooth-apparaat, vergelijkbaar met een MAC-adres van een
	netwerkkaart.  Dit adres is nodig voor verdere communicatie met
	een apparaat.  Het is mogelijk om een menselijk leesbare naam
	aan een BD_ADDR toe te kennen.  Het bestand
	<filename>/etc/bluetooth/hosts</filename> bevat informatie over
	de bekende Bluetooth-gastheren.  Het volgende voorbeeld laat
	zien hoe de menselijk leesbare naam dat aan het apparaat op
	afstand was toegekend te verkrijgen is:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Tijdens het uitvoeren van een ondervraging op een
	Bluetooth-apparaat op afstand zal het de computer als
	<quote>uw.gastheer.naam (ubt0)</quote> vinden.  De naam die aan
	het lokale apparaat is toegekend, kan altijd gewijzigd
	worden.</para>

      <para>Het Bluetooth-systeem biedt een punt-naar-punt-verbinding
	(slechts twee Bluetooth-eenheden betrokken), of een
	punt-naar-veelpunt-verbinding.  Bij een
	punt-naar-veelpunt-verbinding wordt de verbinding met meerdere
	Bluetooth-apparaten gedeeld.  Het volgende voorbeeld laat zien
	hoe de lijst met actieve basisbandverbindingen voor het lokale
	apparaat te verkrijgen is:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Een <emphasis>verbindingshandvat</emphasis> is nuttig indien
	het beëindigen van de basisbandverbinding noodzakelijk is.
	Normaalgesproken is het niet nodig om dit handmatig te doen.  De
	stack zal automatisch niet-actieve basisbandverbindingen
	beëindigen.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Raadpleeg <command>hccontrol help</command> voor een
	volledige lijst van beschikbare HCI-opdrachten.  Voor de meeste
	HCI-opdrachten zijn geen beheerdersrechten nodig.</para>
    </sect2>

    <sect2>
      <title>Logical Link Control and Adaptation
	Protocol (L2CAP)</title>

      <indexterm><primary>L2CAP</primary></indexterm>

      <para>Het Logical Link Control and Adaptation Protocol (L2CAP)
	biedt verbindingsgeoriënteerde en verbindingsloze
	gegevensdiensten met mogelijkheden om protocollen te multiplexen
	en mogelijkheden voor segmentatie/herassemblage voor protocollen
	in hogere lagen.  L2CAP staat toe dat protocollen en
	toepassingen in hogere lagen L2CAP-gegevenspakketten met een
	maximale lengte van 64 kB te verzenden en ontvangen.</para>

      <para>L2CAP is op het concept van <emphasis>kanalen</emphasis>
	gebaseerd.  Een kanaal is een logische verbinding bovenop een
	basisbandverbinding.  Elk kanaal is op een
	veel-op-één manier aan een enkel protocol
	gebonden.  Aan hetzelfde protocol kunnen meerdere kanalen worden
	gebonden, maar één kanaal kan niet aan meerdere
	protocollen worden gebonden.  Elk L2CAP-pakket dat op een kanaal
	wordt ontvangen, wordt naar het juiste hogere protocol
	doorgestuurd.  Meerdere kanalen kunnen dezelfde
	basisbandverbinding delen.</para>

      <para>Voor elk Bluetooth-apparaat wordt een enkele Netgraph-knoop
	van het soort <emphasis>l2cap</emphasis> aangemaakt.  De
	L2CAP-knoop is normaalgesproken verbonden met de Bluetooth
	HCI-knoop (naar beneden toe) en de knopen van de stopcontacten
	voor Bluetooth (naar boven toe).  De standaardnaam voor de
	L2CAP-knoop is <quote>devicel2cap</quote>.  Zie voor meer
	details de hulppagina &man.ng.l2cap.4;.</para>

      <para>Een nuttig commando is &man.l2ping.8;, dat gebruikt kan
	worden om andere apparaten te pingen.  Sommige
	Bluetooth-implementaties geven niet alle verzonden gegevens
	terug, dus is <literal>0 bytes</literal> normaal in het volgende
	voorbeeld.</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>Met het programma &man.l2control.8; kunnen verschillende
	bewerkingen op L2CAP-knopen worden uitgevoerd.  Dit voorbeeld
	laat zien hoe de lijst met logische verbindingen (kanalen)
	en de lijst met basisbandverbindingen voor het lokale apparaat
	verkregen kunnen worden:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>Een ander diagnostisch programma is &man.btsockstat.1;.  Het
	heeft ongeveer hetzelfde doel als &man.netstat.1;, maar dan voor
	Bluetooth-netwerkgerelateerde gegevensstructuren.  Het
	onderstaande voorbeeld laat dezelfde logische verbinding zien
	als die van &man.l2control.8; hierboven.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>
    </sect2>

    <sect2>
      <title>Het RFCOMM-protocol</title>

      <indexterm><primary>RFCOMM</primary></indexterm>

      <para>Het RFCOMM-protocol biedt emulatie van seriële poorten
	over het L2CAP-protocol.  Het protocol is gebaseerd op de
	ETSI-standaard TS 07.10.  RFCOMM is een eenvoudig
	transportprotocol, met aanvullende voorzieningen om de 9
	circuits van RS-232- (EIATIA-232-E-) seriële poorten te
	emuleren.  Het RFCOMM-protocol ondersteunt tot 60 gelijktijdige
	verbindingen (RFCOMM-kanalen) tussen twee
	Bluetooth-apparaten.</para>

      <para>Het is de bedoeling van RFCOMM dat in een volledig
	communicatiepad twee toepassingen op verschillende apparaten
	draaien (de eindpunten van de communicatie) met daartussen een
	communicatiesegment.  RFCOMM is bedoeld om de toepassingen te
	beheren die gebruik maken van de seriële poorten van de
	apparaten waarop ze zijn geïnstalleerd.  Het
	communicatiesegment is een directe Bluetooth-verbinding van het
	ene apparaat naar het andere.</para>

      <para>RFCOMM houdt zich alleen bezig met de verbinding tussen twee
	apparaten bij directe verbindingen, of tussen het apparaat en
	een modem in het geval van een netwerk.  RFCOMM kan andere
	opstellingen ondersteunen, zoals modules die via draadloze
	Bluetooth-technologie communiceren aan de ene kant, en een
	draadinterface aanbieden aan de andere kant.</para>

      <para>In &os; is het RFCOMM-protocol in de laag van de
	Bluetooth-stopcontacten geïmplementeerd.</para>
    </sect2>

    <sect2>
      <title>Het paren van apparaten</title>

      <indexterm><primary>paren</primary></indexterm>

      <para>Standaard is Bluetooth-communicatie niet geauthenticeerd en
	kan elk apparaat met elk ander apparaat praten.  Een
	Bluetooth-apparaat (bijvoorbeeld een mobiele telefoon) kan
	ervoor kiezen dat voor bepaalde diensten authenticatie nodig is
	(bijvoorbeeld voor de inbeldienst).  Bluetooth-authenticatie
	geschied normaalgesproken met <emphasis>PIN-codes</emphasis>.
	Een PIN-code is een ACII-reeks van maximaal 16 tekens lang.  De
	gebruiker dient dezelfde PIN-code op beide apparaten in te
	voeren.  Nadat de gebruiker de PIN-code heeft ingevoerd, zullen
	beide apparaten een <emphasis>verbindingssleutel</emphasis>
	aanmaken.  Hierna kan de verbindingssleutel òfwel in de
	apparaten zelf, òfwel in een permanente opslag  worden
	opgeslagen.  De volgende keer zullen beide apparaten de van
	tevoren aangemaakte verbindingssleutel gebruiken.  Bovenstaande
	procedure wordt <emphasis>paren</emphasis> genoemd.  Merk op dat
	indien een apparaat de verbindingssleutel verliest, het paren
	moet worden herhaald.</para>

      <para>De daemon &man.hcsecd.8; is verantwoordelijk voor het
	behandelen van alle verzoeken voor Bluetooth-authenticatie.  Het
	standaard instellingenbestand is
	<filename>/etc/bluetooth/hcsecd.conf</filename>.  Een
	voorbeeldsectie voor een mobiele telefoon waarvan de PIN-code
	willekeurig op <quote>1234</quote> is hieronder
	beschreven:</para>

      <programlisting>device {
	bgaddr	00:80:37:29:19:a4;
	name	"Pav's T39";
	key	nokey;
	pin	"1234";
      }</programlisting>

      <para>Er is geen limiet voor PIN-codes (behalve de lengte).  Voor
	sommige apparaten (bijvoorbeeld Bluetooth-headsets) kan de
	PIN-code vast zijn ingebouwd.  De schakelaar <option>-d</option>
	dwingt de daemon &man.hcsecd.8; om op de voorgrond te blijven,
	zodat het gemakkelijk is om te zien wat er gebeurt.  Stel het
	andere apparaat in om paarverzoeken te ontvangen en initialiseer
	de Bluetooth-verbinding naar het andere apparaat.  Het apparaat
	moet zeggen dat het paarverzoek geaccepteerd is en om de
	PIN-code vragen.  Geef dezelfde PIN-code op als in
	<filename>hcsecd.conf</filename>.  Nu zijn de PC en het andere
	apparaat gepaard.  Als alternatief kan paren op het andere
	apparaat worden geïnitialiseerd.</para>

      <para>De volgende regel kan aan
	het bestand <filename>/etc/rc.conf</filename> worden toegevoegd
	om <application>hcsecd</application> automatisch met het
	systeem op te starten:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Het volgende is een voorbeeld van de uitvoer van de daemon
	<application>hcsecd</application>:</para>

      <programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>
    </sect2>

    <sect2>
      <title>Service Discovery Protocol (SDP)</title>

      <indexterm><primary>SDP</primary></indexterm>

      <para>Het Service Discovery Protocol (SDP) biedt voor
	cliënttoepassingen de mogelijkheid om diensten te ontdekken
	die door servertoepassingen worden aangeboden alsook de
	kenmerken van deze diensten.  De kenmerken van een dienst
	omvatten de soort of klasse van de aangeboden dienst en de
	informatie over het mechanisme of protocol dat nodig is om de
	dienst te gebruiken.</para>

      <para>SDP omvat communicatie tussen een SDP-server en een
	SDP-cliënt.  De server houdt een lijst van
	dienstenregistraties bij die de eigenschappen van de diensten
	beschrijven die met de server geassocieerd zijn.  Elke
	dienstregistratie bevat informatie over een enkele dienst.  Een
	cliënt kan informatie over een dienstregistratie opvragen
	die door de SDP-server wordt bijgehouden door een SDP-verzoek in
	te dienen.  Indien de cliënt, of een toepassing die met de
	cliënt geassocieerd is, besluit om de dienst te gebruiken,
	moet het een aparte verbinding naar de aanbieder van de dienst
	openen om de dienst te gebruiken.  SDP biedt een mechanisme om
	diensten en hun attributen te ontdekken, maar het biedt geen
	mechanisme om die diensten te gebruiken.</para>

      <para>Normaalgesproken zoekt een SDP-cliënt naar diensten
	naar aanleiding van enkele gewenste eigenschappen van die
	diensten.  Soms is het echter wenselijk om te ontdekken welke
	soorten diensten door de dienstregistraties van een SDP-server
	worden beschreven zonder enige voorkennis van deze diensten.
	Dit kijken naar alle aangeboden diensten wordt
	<emphasis>browsen</emphasis> genoemd.</para>

      <para>De Bluetooth SDP-server &man.sdpd.8; en de
	opdrachtregelcliënt &man.sdpcontrol.8; zitten in de
	standaard &os;-installatie.  Het volgende voorbeeld laat zien
	hoe een SDP-browse query uit te voeren.</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0</screen>

      <para>... enzovoorts.  Merk op dat elke dienst een lijst met
	attributen heeft (bijvoorbeeld een RFCOMM-kanaal).  Afhankelijk
	van de dienst kan het nodig zijn om een aantekening van sommige
	attributen te maken.  Sommige Bluetooth-implementaties
	ondersteunen dienst-browsen niet en zullen een lege lijst
	teruggeven.  In dit geval is het mogelijk om naar de specifieke
	dienst te zoeken.  Het onderstaande voorbeeld laat zien hoe naar
	de dienst OBEX Object Push (OPUSH) gezocht kan worden:</para>

      <screen>&prompt.user;  <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>Het aanbieden van diensten op &os; aan
	Bluetooth-cliënten wordt gedaan met de server &man.sdpd.8;.
	De volgende regel kan aan het
	bestand <filename>/etc/rc.conf</filename> worden
	toegevoegd:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Het daemon <application>sdpd</application> kan worden
	gestart met:</para>

      <screen>&prompt.root; <userinput>service sdpd start</userinput></screen>

      <para>De plaatselijke servertoepassing die Bluetooth-diensten wil
	aanbieden aan verre cliënten zal de dienst registreren bij
	de plaatselijke SDP-daemon.  Een voorbeeld van zo'n toepassing
	is &man.rfcomm.pppd.8;.  Nadat het gestart is zal het de
	Bluetooth LAN-dienst bij de plaatselijke SDP-daemon
	registreren.</para>

      <para>De lijst met diensten die bij de plaatselijke SDP-server
	zijn geregistreerd kan worden opgevraagd door te SDP-browsen
	via het plaatselijke controlekanaal:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>
    </sect2>

    <sect2>
      <title>Dial-Up Networking (DUN) en netwerktoegang met PPP (LAN)
	profielen</title>

      <para>Het inbelnetwerk (DUN) profiel wordt het meeste gebruikt met
	modems en mobiele telefoons.  De volgende scenario's worden in
	dit profiel behandeld:</para>

      <itemizedlist>
	<listitem>
	  <para>het gebruik van een mobiele telefoon of modem door een
	    computer als een draadloze modem voor het verbinden met een
	    inbelserver voor Internet-toegang, of voor andere
	    inbeldiensten;</para>
	</listitem>

	<listitem>
	  <para>het gebruik van een mobiele telefoon of modem door een
	    computer om gegevensoproepen te ontvangen.</para>
	</listitem>
      </itemizedlist>

      <para>Het profiel voor netwerktoegang met PPP (LAN) kan in de
	volgende situaties gebruikt worden:</para>

      <itemizedlist>
	<listitem>
	  <para>LAN-toegang voor een enkel Bluetooth-apparaat;</para>
	</listitem>

	<listitem>
	  <para>LAN-toegang voor meerdere Bluetooth-apparaten;</para>
	</listitem>

	<listitem>
	  <para>PC naar PC (door PPP-netwerken over een seriële
	    kabel te emuleren).</para>
	</listitem>
      </itemizedlist>

      <para>Op &os; zijn beide profielen geïmplementeerd met
	&man.ppp.8; en &man.rfcomm.pppd.8; - een wrapper die een RFCOMM
	Bluetooth-verbinding omzet in iets waar PPP mee overweg kan.
	Voordat een profiel gebruikt kan worden, dient een nieuw
	PPP-label in het bestand <filename>/etc/ppp/ppp.conf</filename>
	te worden aangemaakt.  Raadpleeg de hulppagina
	&man.rfcomm.pppd.8; voor voorbeelden.</para>

      <para>In het volgende voorbeeld zal &man.rfcomm.pppd.8; gebruikt
	worden om RFCOMM-verbinding met een ver apparaat met BD_ADDR
	00:80:37:29:19:a4 op een DUN RFCOMM-kanaal te maken.  Het
	eigenlijke RFCOMM-kanaalnummer wordt via SDP van het verre
	apparaat verkregen.  Het is mogelijk om het RFCOMM-kanaal
	handmatig op te geven, en in dat geval zal &man.rfcomm.pppd.8;
	het SDP-verzoek niet uitvoeren.  Gebruik &man.sdpcontrol.8; om
	het RFCOMM-kanaal op het verre apparaat te achterhalen.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Om netwerktoegang met PPP (LAN) aan te bieden moet de server
	&man.sdpd.8; draaien.  Er dient een nieuwe regel voor
	LAN-cliënten in het bestand
	<filename>/etc/ppp/ppp.conf</filename> aangemaakt te worden.
	Raadpleeg de hulppagina &man.rfcomm.pppd.8; voor voorbeelden.
	Tenslotte dient de RFCOMM PPP-server op een geldig RFCOMM-kanaal
	gestart te worden.  De RFCOMM PPP-server zal automatisch de
	Bluetooth LAN-dienst bij de plaatselijke SDP-daemon registreren.
	Het volgende voorbeeld laat zien hoe een RFCOMM PPP-server te
	starten:</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>
    </sect2>

    <sect2>
      <title>Het OBEX Object Push (OPUSH) profiel</title>

      <indexterm><primary>OBEX</primary></indexterm>

      <para>OBEX is een veelgebruikt protocol voor eenvoudige
	bestandsoverdrachten tussen mobiele apparaten.  Het primaire
	gebruik is infraroodcommunicatie, waar het wordt gebruikt voor
	generieke bestandsoverdrachten tussen notebooks of PDA's, en
	om visitekaarten en kalenderregels tussen mobiele telefoons en
	andere apparaten met PIM-toepassingen over te dragen.</para>

      <para>De OBEX-server en clieënt zijn geïmplenteerd als
	een pakket van derde partij, <application>obexapp</application>,
	dat beschikbaar is als de port
	<package>comms/obexapp</package>.</para>

      <para>De OBEX-cliënt wordt gebruikt om objecten naar en/of
	van de OBEX-server te duwen/trekken.  Een object kan
	bijvoorbeeld een visitekaart of een afspraak zijn.  De
	OBEX-cliënt kan het RFCOMM-kanaalnummer van het verre
	apparaat via SDP opvragen.  Dit kan gedaan worden door de
	dienstnaam in plaats van het RFCOMM-kanaalnummer op te geven.
	De ondersteunde dienstnamen zijn: IrMC, FTRN, en OPUSH.  Het is
	mogelijk om het RFCOMM-kanaal als een nummer op te geven.  Het
	onderstaande is een voorbeeld van een OBEX-sessie, waar een
	apparaatinformatie-object van de mobiele telefoon wordt
	getrokken, en een nieuw object (een visitekaart) in de gids van
	de telefoon wordt geduwd:</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Om de dienst OBEX Object Push aan te bieden, moet de server
	&man.sdpd.8; draaien.  Er moet een hoofdmap worden aangemaakt
	waarin alle binnenkomende objecten worden opgeslagen.  Het
	standaardpad naar de hoofdmap is <filename>/var/spool/obex</filename>.  Tenslotte moet de
	OBEX-server op een geldig RFCOMM-kanaal worden gestart.  De
	OBEX-server zal automatisch de dienst OBEX Object Push bij de
	plaatselijke SDP-daemon registeren.  Het onderstaande voorbeeld
	laat zien hoe de OBEX-server gestart wordt:</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
    </sect2>

    <sect2>
      <title>Serial Port Profile (SPP)</title>

      <para>Het Seriële Poort Profiel (SPP) zorgt ervoor dat
	Bluetooth-apparaten RS232 (of gelijkwaardige) seriële
	kabels kunnen emuleren.  Het scenario dat dit profiel behandelt
	zorgt ervoor dat oude toepassingen Bluetooth kunnen gebruiken
	als vervanging van kabels, door gebruik te maken van een
	virtuele seriële poort.</para>

      <para>Het programma &man.rfcomm.sppd.1; implementeert het
	Seriële Poort profiel.  Een pseudo-tty wordt gebruikt als
	abstractie voor een virtuele seriële poort.  Onderstaand
	voorbeeld laat zien hoe met een Seriële Poortdienst voor
	verre apparaten te verbinden.  Merk op dat het niet nodig is om
	een RFCOMM-kanaal te kiezen - &man.rfcomm.sppd.1; kan het via
	SDP van het verre apparaat verkrijgen.  Dit kan worden overruled
	door een RFCOMM-kanaal op de opdrachtregel te specificeren.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Als er een verbinding is, kan de pseudo-tty als seriële
	poort worden gebruikt:</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>Problemen oplossen</title>

      <sect3>
	<title>Een apparaat op afstand kan geen verbinding maken</title>

	<para>Sommige oudere Bluetooth-apparaten ondersteunen het
	  wisselen van rol niet.  Standaard probeert &os;, wanneer het
	  een nieuwe verbinding accepteert, een rolwisseling uit te
	  voeren en meester te worden.  Apparaten die dit niet
	  ondersteunen zullen niet kunnen verbinden.  Merk op dat van
	  rol wordt gewisseld wanneer een nieuwe verbinding wordt
	  gemaakt, dus het is niet mogelijk om het verre apparaat te
	  vragen of het rolwisseling ondersteunt.  Er is een HCI-optie
	  om rolwisselen aan de plaatselijke kant uit te zetten:</para>

	<screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>
      </sect3>

      <sect3>
	<title>Er gaat iets mis, kan ik precies zien wat er gebeurt?</title>

	<para>Ja, dit is mogelijk.  Gebruik het pakket
	  <application>hcidump</application>, dat beschikbaar is als de
	  port <package>comms/hcidump</package>.  Het
	  gereedschap <application>hcidump</application> is
	  vergelijkbaar met &man.tcpdump.1;.  Het kan gebruikt worden om
	  de inhoud van Bluetooth-pakketten op de terminal te laten zien
	  en om de Bluetooth-pakketten naar een bestand te schrijven.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bridging">
    <info><title>Bridging</title>
      <authorgroup>
	<author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Geschreven door </contrib></author>
      </authorgroup>
    </info>

    

    <sect2>
      <title>Introductie</title>

      <indexterm><primary>IP-subnet</primary></indexterm>

      <indexterm><primary>bridge</primary></indexterm>

      <para>Soms is het handig om één fysiek netwerk
	(zoals een Ethernet-segment) in twee gescheiden netwerksegmenten
	te verdelen zonder de noodzaak om een IP-subnet aan te maken en
	een router te gebruiken om de segmenten met elkaar te verbinden.
	Een apparaat dat twee netwerken op deze manier met elkaar
	verbindt wordt een <quote>bridge (brug)</quote> genoemd.  Een
	&os;-systeem met twee netwerkkaarten kan als bridge
	dienen.</para>

      <para>De bridge werkt door de adressen van de MAC-laag
	(Ethernetadressen) van de apparaten op elke netwerkinterface
	te leren.  Het stuurt alleen verkeer tussen twee netwerken door
	indien de bron en het doel zich op verschillende netwerken
	bevinden.</para>

      <para>In vele opzichten is een bridge als een Ethernet-switch met
	erg weinig poorten.</para>
    </sect2>

    <sect2>
      <title>Situaties waarin bridging juist is</title>

      <para>Er zijn vandaag de dag veel situaties waarin een bridge
	gebruikt wordt.</para>

      <sect3>
	<title>Netwerken verbinden</title>

	<para>Het basisgebruik van een bridge is het met elkaar
	  verbinden van twee of meer netwerksegmenten.  Er zijn vele
	  redenen om een hostgebaseerde bridge te gebruiken in plaats
	  van simpele netwerkapparaten zoals kabelbeperkingen,
	  firewalling of het verbinden van pseudonetwerken zoals een
	  interface van een virtuële machine.  Een bridge kan ook
	  een draadloze interface die in hostap-modus draait met een
	  bedraad netwerk verbinden en als een toegangspunt
	  dienen.</para>
      </sect3>

      <sect3>
	<title>Filtering/Bandbreedtebeheersende firewall</title>

	<indexterm><primary>firewall</primary></indexterm>

	<indexterm><primary>NAT</primary></indexterm>

	<para>Een gebruikelijke situatie dient zich voor wanneer de
	  functionaliteit van een firewall nodig is zonder routing of
	  network address translation (NAT).</para>

	<para>Een voorbeeld is een klein bedrijf dat via DSL of ISDN met
	  hun internetprovider verbonden is.  Dit bedrijf heeft 13
	  wereldwijd bereikbare IP-adressen van de internetprovider en
	  10 PC's op hun netwerk.  In deze situatie is een firewall die
	  op een router gebaseerd is lastig wegens
	  subnet-problemen.</para>

	<indexterm><primary>router</primary></indexterm>

	<indexterm><primary>DSL</primary></indexterm>

	<indexterm><primary>ISDN</primary></indexterm>

	<para>Een firewall die op een bridge gebaseerd is kan ingesteld
	  en net na de DSL- of ISDN-router geplaatst worden zonder dat
	  er problemen met IP-nummers optreden.</para>
      </sect3>

      <sect3>
	<title>Netwerktap</title>

	<para>Een bridge kan twee netwerksegmenten verbinden en kan
	  gebruikt worden om alle Ethernetframes die tussen dezen
	  voorbijkomen te inspecteren.  Dit kan òfwel vanuit het
	  gebruik van &man.bpf.4;/&man.tcpdump.1; op de bridge-interface
	  òfwel door een kopie van alle frames naar een extra
	  interface (overspanpoort) te versturen.</para>
      </sect3>

      <sect3>
	<title>Laag 2 VPN</title>

	<para>Twee Ethernetnetwerken kunnen over een IP-verbinding
	  verbonden worden door de netwerken naar een EtherIP-tunnel te
	  bridgen of met een oplossing gebaseerd po &man.tap.4; zoals
	  OpenVPN.</para>
      </sect3>

      <sect3>
	<title>Laag 2 Redundancy</title>

	<para>Een netwerk kan met meerdere verbindingen verbonden worden
	  en het Spanning Tree Protocol gebruiken om overbodige paden te
	  blokkeren.  Een Ethernetnetwerk kan alleen juist functioneren
	  indien er slechts één actief pad bestaat tussen
	  twee apparaten, Spanning Tree zal lussen detecteren en de
	  overbodige verbindingen in een geblokkeerde toestand zetten.
	  Indien een van de actieve verbindingen faalt zal het protocol
	  een andere boom berekenen en een van de geblokkeerde paden
	  weer activeren om de verbindingen naar alle punten in het
	  netwerk te herstellen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>De kernel instellen</title>

      <para>Deze sectie behandelt de bridges geïmplementeerd met
	&man.if.bridge.4;, een stuurprogramma dat bridges met netgraph
	implementeert is ook beschikbaar, zie voor meer informatie de
	hulppagina &man.ng.bridge.4;.</para>

      <para>Het bridge-stuurprogramma is een kernelmodule en zal
	automatisch door &man.ifconfig.8; worden geladen wanneer er een
	bridge-interface wordt aangemaakt.  Het is mogelijk om de bridge
	in de kernel te compileren door
	<literal>device if_bridge</literal> aan het
	kernelinstellingenbestand toe te voegen.</para>

      <para>Pakketfiltering kan met elk firewall-pakket worden gebruikt
	dat via het raamwerk &man.pfil.9; aankoppelt.  De firewall kan
	als een module worden geladen of in de kernel worden
	gecompileerd.</para>

      <para>De bridge kan als met &man.altq.4; of &man.dummynet.4; als
	een verkeersregelaar worden gebruikt.</para>
    </sect2>

    <sect2>
      <title>De bridge inschakelen</title>

      <para>De bridge wordt aangemaakt door interfaces te klonen.  Om
	een bridge aan te maken wordt &man.ifconfig.8; gebruikt, indien
	het bridge-stuurprogramma niet in de kernel aanwezig is zal het
	automatisch worden geladen.</para>

      <screen>&prompt.root; <userinput>ifconfig bridge create</userinput>
&prompt.root; <userinput>ifconfig bridge0</userinput>
bridge0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</screen>

      <para>Een bridge-interface is aangemaakt en er is automatisch een
	random gegenereerd Ethernetadres aan toegekend.  De parameters
	<literal>maxaddr</literal> en <literal>timeout</literal> bepalen
	hoeveel MAC-adressen de bridge in de doorstuurtabel houdt en
	hoeveel seconden voordat elke regel wordt verwijderd nadat het
	voor het laatst gezien is.  De andere parameters bepalen hoe
	Spanning Tree werkt.</para>

      <para>Voeg de netwerkinterfaces die lid zijn aan de bridge toe.
	Om de bridge pakketten te laten doorsturen dienen alle
	lidinterfaces en de bridge actief te zijn:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 up</userinput>
&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput></screen>

      <para>De bridge stuurt nu Ethernet-frames door tussen
	<filename>fxp0</filename> en <filename>fxp1</filename>.
	De overeenkomstige configuratie in
	<filename>/etc/rc.conf</filename> zodat de bridge tijdens het
	opstarten wordt aangemaakt is:</para>

      <programlisting>cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"</programlisting>

      <para>Indien de bridge-gastheer een IP-adres nodig heeft dan is de
	juiste plaats om dit in te stellen op de bridge-interface zelf
	in plaats van op een van de lidinterfaces.  Dit kan statisch of
	via DHCP worden ingesteld:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

      <para>Het is ook mogelijk om een IPv6-adres aan een
	bridge-interface toe te kennen.</para>
    </sect2>

    <sect2>
      <title>Firewalls gebruiken</title>

      <indexterm><primary>firewall</primary></indexterm>

      <para>Wanneer pakketten worden gefilterd, zullen gebridgede
	pakketten het filter inbound op de vertrekkende interface
	passeren, op de bridge-interface en outbound op de bestemde
	interface.  Elke stap kan uitgezet worden.  Wanneer de richting
	van het pakketverkeer belangrijk is, kan de firewall het beste
	op de lidinterfaces draaien en niet op de bridge zelf.</para>

      <para>De bridge heeft verschillende aanpasbare instellingen voor
	het doorlaten van non-IP- en ARP-pakketten, en een laag 2
	firewall met IPFW.  Zie &man.if.bridge.4; voor meer
	informatie.</para>
    </sect2>

    <sect2>
      <title>Opspannende boom</title>

      <para>Het bridge-stuurprogramma implementeert het Rapid Spanning
	Tree Protocol (RSTP of 802.1w) met terugwaartse compatibiliteit
	met het verouderde Spanning Tree Protocol (STP).  Spanning Tree
	wordt gebruikt om lussen in een netwerktopologie te detecteren
	en verwijderen.  RSTP biedt snellere convergentie naar een
	opspannende boom dan het verouderde STP, het protocol wisselt
	informatie met naburige switches uit om snel naar forwarding
	over te gaan zonder lussen te creëren.  &os; ondersteunt
	RSTP en STP als opties, waarbij RSTP de standaard is.</para>

      <para>Spanning Tree kan op lidinterfaces worden geactiveerd met
	het commando <literal>stp</literal>.  Voor een bridge met
	<filename>fxp0</filename> en <filename>fxp1</filename>
	alle huidige interfaces, wordt STP met het volgende
	geactiveerd:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 stp fxp0 stp fxp1</userinput>
bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>De bridge heeft spanning tree ID
	<literal>00:01:02:4b:d4:50</literal> en prioriteit
	<literal>32768</literal>.  Aangezien het
	<literal>root id</literal> hetzelfde is geeft dit aan dat dit de
	hoofdbridge voor de boom is.</para>

      <para>Een andere bridge in het netwerk heeft spanning tree ook
	geactiveerd:</para>

      <screen>bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>De reegl <literal>root id 00:01:02:4b:d4:50 priority 32768
	  ifcost 400000 port 4</literal> geeft aan dat de hoofdbridge
	<literal>00:01:02:4b:d4:50</literal> is zoals boven en dat de
	padkosten <literal>400000</literal> zijn vanaf deze bridge, het
	pad naar de hoofdbridge gaat via <literal>port 4</literal>
	welke <filename>fxp0</filename> is.</para>
    </sect2>

    <sect2>
      <title>Geavanceerd bridgen</title>

      <sect3>
	<title>Verkeersstromen reconstrueren</title>

	<para>De bridge ondersteunt monitormodus, waarin de pakketten
	  worden verwijderd nadat ze door &man.bpf.4; zijn verwerkt,
	  en ze niet verder verwerkt of doorgestuurd worden.  Dit kan
	  worden gebruikt om de invoer van twee of meer interfaces naar
	  een enkele &man.bpf.4;-stroom te multiplexen.  Dit is nuttig
	  voor het reconstrueren van het verkeer voor netwerktaps welke
	  de RX/TX-signalen over twee verschillende interfaces
	  uitzenden.</para>

	<para>Om de invoer van vier netwerkinterfaces als
	  één stroom te lezen:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addmfxp1 addm fxp2 addm fxp3 monitor up</userinput>
&prompt.root; <userinput>tcpdump -i bridge0</userinput></screen>
      </sect3>

      <sect3>
	<title>SPAN poorten</title>

	<para>Van elk Ethernet-frame dat door de bridge wordt ontvangen
	  wordt er een kopie naar de aangewezen SPAN-poort verstuurd.
	  Het aantal geconfigureerde SPAN-poorten op een bridge is
	  onbeperkt, indien een interface aangewezen is als SPAN-poort
	  kan het niet ook als gewone bridgepoort gebruikt worden.  Dit
	  is het nuttigste voor het passief afluisteren van een
	  gebridged netwerk op een andere host die met een van de
	  SPAN-poorten van de bridge verbonden is.</para>

	<para>Om een kopie van alle frames naar de interface
	  <filename>fxp4</filename> te versturen:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 span fxp4</userinput></screen>
      </sect3>

      <sect3>
	<title>Privé-interfaces</title>

	<para>Een privé-interface stuurt geen verkeer door naar
	  poorten die niet ook een privé-interface zijn.  Het
	  verkeer wordt onvoorwaardelijk geblokkeerd, dus worden er
	  geen Ethernetframes doorgestuurd, inclusief ARP.  Indien
	  verkeer selectief dient te worden geblokkeerd dient er in
	  plaats hiervan een firewall gebruikt te worden.</para>
      </sect3>

      <sect3>
	<title>Klevende interfaces</title>

	<para>Indien een lidinterface van een bridge als klevend is
	  gemarkeerd worden dynamisch geleerde adresregels als statisch
	  behandelt wanneer ze in de doorstuurcache komen.  Klevende
	  interfaces vallen nooit uit de cache en worden nooit vervangen,
	  zelfs niet als het adres op een andere interface wordt gezien.
	  Dit biedt het voordeel van statische adresregels zonder dat de
	  doorstuurtabel van te voren gevuld hoeft te worden,
	  cliënten die geleerd zijn op een bepaald segment van de
	  bridge kunnen niet roamen naar een ander segment.</para>

	<para>Een ander voorbeeld voor het gebruik van klevende adressen
	  zou het combineren van de bridge met VLANs zijn om een router
	  te creëren waar klantnetwerken geïsoleerd zijn
	  zonder dat IP-adresruimte verspild wordt.  Neem aan dat
	  <systemitem class="fqdomainname">KlantA</systemitem> op
	  <literal>vlan100</literal> zit en <systemitem class="fqdomainname">KlantB</systemitem> op
	  <literal>vlan101</literal>.  De bridge heeft het adres
	  <systemitem class="ipaddress">192.168.0.1</systemitem> en is tevens een
	  internet-router.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</userinput>
&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

	<para>Beide cliënten zien <systemitem class="ipaddress">192.168.0.1</systemitem> als hun standaard gateway
	  en aangezien de bridge-cache kleverig is kunnen ze niet het
	  MAC-adres van de andere klant spoofen om hun verkeer op te
	  vangen.</para>

	<para>Alle communicatie tussen de VLANs kan geblokkeerd worden
	  door het gebruik van privé-interfaces (of een firewall):</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 private vlan100 private vlan101</userinput></screen>

	<para>De klanten zijn compleet geïsoleerd van elkaar, het
	  volledige <systemitem class="netmask">/24</systemitem> adresruimte kan
	  zonder subnetten toegewezen worden.</para>
      </sect3>

      <sect3>
	<title>Adresbeperkingen</title>

	<para>Het aantal unieke bron-MAC-adressen achter een interface
	  kan beperkt zijn.  Wanneer de limiet bereikt is worden
	  pakketten met een onbekend bronadres gedropt totdat een
	  bestaande ingang in de host-cache vervalt of wordt
	  verwijderd.</para>

	<para>Het volgende voorbeeld stelt het maximum aantal
	  Ethernetapparaten voor <systemitem class="fqdomainname">KlantA</systemitem> op
	  <literal>vlan100</literal> in op 10.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 ifmaxaddr vlan100 10</userinput></screen>
      </sect3>

      <sect3>
	<title>SNMP-monitoring</title>

	<para>De bridge-interface en STP-parameters kunnen gemonitord
	  worden via het SNMP-daemon dat met het basis &os;-systeem
	  wordt meegeleverd.  De geëxporteerde bridge-MIBs houden
	  zich aan de standaarden van de IETF zodat elke
	  SNMP-cliënt of monitorpakket kan worden gebruikt om de
	  gegevens te verzamelen.</para>

	<para>Op de bridge-machine dient de regel
	  <literal>begemotSnmpdModulePath."bridge" =
	  "/usr/lib/snmp_bridge.so"</literal> van
	  <filename>/etc/snmp.config</filename> geactiveerd te worden en
	  het daemon <application>bsnmpd</application> gestart te worden.
	  Andere instellingen zoals gemeenschapsnamen en toegangslijsten
	  dienen eventueel aangepast te worden.  Zie &man.bsnmpd.1; en
	  &man.snmp.bridge.3; voor meer informatie.</para>

	<para>Het volgende voorbeeld gebruikt de software
	  <application>Net-SNMP</application> (<package>net-mgmt/net-snmp</package> om een bridge te
	  ondervragen, de port <package>net-mgmt/bsnmptools</package> kan ook worden
	  gebruikt.  Voeg de volgende regels toe aan
	  <filename>$HOME/.snmp/snmp.conf</filename> op de
	  SNMP-cliënt-host om de MIB-definities van de bridge in
	  <application>Net-SNMP</application> te importeren:</para>

	<programlisting>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</programlisting>

	<para>Om een enkele bridge via de IETF BRIDGE-MIB (RFC4188) te
	  monitoren:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge</userinput>
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)</screen>

	<para>De waarde <literal>dot1dStpTopChanges.0</literal> is twee
	  wat betekent dat de topologie van de STP-bridge twee maal
	  veranderd is, een topologieverandering houdt in dat
	  één of meerdere links in het netwerk zijn
	  veranderd of hebben gefaald en dat er een nieuwe boom is
	  berekend.  De waarde
	  <literal>dot1dStpTimeSinceTopologyChange.0</literal> laat zien
	  wanneer dit gebeurde.</para>

	<para>Om meerdere bridge-interfaces te monitoren kan men het
	  privé BEGEMOT-BRIDGE-MIB gebruiken:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com</userinput>
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9</screen>

	<para>Om de bridge-interface die via de subboom
	  <literal>mib-2.dot1dBridge</literal> wordt gemonitord te
	  veranderen:</para>

	<screen>&prompt.user; <userinput>snmpset -v 2c -c private bridge1.example.com</userinput>
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-aggregation">
    <info><title>Verbindingsaggregatie en failover</title>
      <authorgroup>
	<author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Geschreven door </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>lagg</primary></indexterm>

    <indexterm><primary>failover</primary></indexterm>

    <indexterm><primary>fec</primary></indexterm>

    <indexterm><primary>lacp</primary></indexterm>

    <indexterm><primary>loadbalance</primary></indexterm>

    <indexterm><primary>roundrobin</primary></indexterm>

    <sect2>
      <title>Introductie</title>

      <para>De interface &man.lagg.4; maakt het mogelijk om meerdere
	netwerkinterfaces te aggregeren in één virtueel
	interface voor het bieden van fout-tolerante en zeer snelle
	verbindingen.</para>
    </sect2>

    <sect2>
      <title>Werkmodi</title>

      <variablelist>
	<varlistentry>
	  <term>Failover</term>

	  <listitem>
	    <para>Zendt en ontvangt verkeer alleen door de meesterpoort.
	      Wanneer de meesterpoort niet beschikbaar is, wordt de
	      volgende actieve poort gebruikt.  De eerste toegevoegde
	      interface is de meesterpoort; alle interfaces die hierna
	      zijn toegevoegd worden gebruikt als failover-apparaten.  Als
	      failover naar een niet-meesterpoort plaatsvindt, dan wordt de
	      originele poort de meester wanneer deze weer beschikbaar
	      wordt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>&cisco; Fast &etherchannel;</term>

	  <listitem>
	    <para>&cisco; Fast &etherchannel; (FEC), is een statische
	      installatie en onderhandelt niet over aggregatie met de
	      peer noch wisselt het frames uit om de verbinding te
	      monitoren.  Indien de switch LACP ondersteunt dient dat
	      gebruikt te worden.</para>

	    <para><acronym>FEC</acronym> balanceert uitgaand verkeer
	      over de actieve poorten gebaseerd op gehashde informatie
	      over protocolheaders en accepteert inkomend verkeer van
	      elke actieve poort.  De hash bevat het Ethernet bron- en
	      doeladres, en indien beschikbaar, de VLAN-tag, en de
	      IPv4/IPv6 bron- en doeladressen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>LACP</term>

	  <listitem>
	    <para>Het &ieee; 802.3ad Link Aggregation Control Protocol
	      (LACP) en het Marker Protocol.  LACP onderhandelt met de
	      peer over een verzameling aggregeerbare verbindingen in
	      één of meerdere Link Aggregated Groups
	      (LAG).  Elke LAG is opgebouwd uit poorten die dezelfde
	      snelheid hebben, ingesteld op full-duplex werking.  Het
	      verkeer zal over de poorten in de LAG gebalanceerd worden
	      met de hoogste totaalsnelheid, in de meeste gevallen zal
	      er slechts één LAG zijn die alle poorten
	      bevat.  Wanneer er fysieke verbindingen veranderen, zal
	      Link Aggregation snel naar een nieuwe opstelling
	      convergeren.</para>

	    <para><acronym>LACP</acronym> balanceert uitgaand verkeer
	      over de actieve poorten gebaseerd op gehashde informatie
	      over protocolheaders en accepteert inkomend verkeer van
	      elke actieve poort.  De hash bevat het Ethernet bron- en
	      doeladres, en indien beschikbaar, de VLAN-tag, en de
	      IPv4/IPv6 bron- en doeladressen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Loadbalance</term>

	  <listitem>
	    <para>Dit is een alias van de <emphasis>FEC</emphasis>
	      modus.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Round-Robin</term>

	  <listitem>
	    <para>Distribueert uitgaand verkeer door middel van een
	      round-robin scheduler over alle actieve poorten en
	      accepteert inkomend verkeer van elke actieve poort.  Deze
	      modus schendt Ethernet frame-ordering en dient met zorg
	      gebruikt te worden.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Voorbeelden</title>

      <example xml:id="networking-lacp-aggregation-cisco">
	<title>LACP-aggregatie met een &cisco; switch</title>

	<para>Dit voorbeeld verbindt twee interfaces op een &os;-machine
	  met de switch als een enkele loadgebalanceerde en
	  fout-tolerante verbinding.  Er kunnen meer interfaces worden
	  toegevoegd om de doorvoer en fouttolerantie te verhogen.
	  Aangezien frame-ordering verplicht is op Ethernetverbindingen
	  stroomt al het verkeer tussen twee stations altijd over
	  dezelfde fysieke verbinding zodat de maximum snelheid beperkt
	  wordt tot die van één interface.  Het
	  verzendalgoritme probeert zoveel mogelijk informatie te
	  gebruiken voor het onderscheiden van verschillende
	  verkeersstromen en deze over de beschikbare interfaces te
	  balanceren.</para>

	<para>Voeg op de &cisco; switch de interfaces
	  <replaceable>FastEthernet0/1</replaceable> en
	  <replaceable>FastEthernet0/2</replaceable> aan de kanaalgroep
	  <replaceable>1</replaceable> toe:</para>

	<screen><userinput>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp</userinput>
!
<userinput>interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</userinput></screen>

	<para>Maak de &man.lagg.4;-interface aan met
	  <replaceable>fxp0</replaceable> en <replaceable>fxp1</replaceable> en
	  activeer de interface met IP-adres
	  <replaceable>10.0.0.3/24</replaceable>:</para>

	<screen>&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</userinput></screen>

	<para>Bekijk de interfacestatus van ifconfig:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput></screen>

	<para>Poorten die als <emphasis>ACTIVE</emphasis> zijn
	  gemarkeerd zijn lid van de actieve aggregatiegroep waarover
	  onderhandeld is met de verre switch en waarover verkeer zal
	  worden verzonden en ontvangen.  Gebruik de uitgebreide uitvoer
	  van &man.ifconfig.8; om de LAG-identifiers te bekijken.</para>

	<screen>lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</screen>

	<para>Gebruik, om de toestand van de poorten op de switch te
	  bekijken, <userinput>show lacp neighbor</userinput>.</para>

	<screen>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</screen>

	<para>Gebruik voor meer detail het commando <userinput>show lacp
	    neighbor detail</userinput>.</para>

	<para>Voeg de volgende regels aan <filename>/etc/rc.conf</filename> toe
	  om deze informatie na het opnieuw starten te behouden:</para>

	<programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg0</literal>"
ifconfig_<literal>lagg0</literal>="laggproto lacp laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.3/24</replaceable>"</programlisting>

      </example>

      <example xml:id="networking-lagg-failover">
	<title>Failover-modus</title>

	<para>Failover-modus kan worden gebruikt om op een secondaire
	  interface over te schakelen wanneer de verbinding op de
	  meesterinterface verloren is.  Activeer de onderliggende fysieke
	  interface.  Creëer de
	  interface <literal>lagg0</literal>, met
	  <replaceable>fxp0</replaceable> als de meesterinterface en
	  <replaceable>fxp1</replaceable> als de secondaire
	  interface en ken er IP-adres <replaceable>10.0.0.15/24</replaceable>
	  aan toe:</para>

	<screen>&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</userinput></screen>

	<para>De interface zal er ongeveer als volgt uitzien, de grote
	  verschillen zullen het <acronym>MAC</acronym>-adres en de
	  apparaatnamen zijn:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0&lt;&gt;
        laggport: fxp0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Het verkeer zal worden verzonden en ontvangen op
	  <replaceable>fxp0</replaceable>.  Indien de verbinding op
	  <replaceable>fxp0</replaceable> verloren is, zal
	  <replaceable>fxp1</replaceable> de actieve verbinding worden.
	  Indien de verbinding op de meesterinterface hersteld is, zal
	  het weer de actieve verbinding worden.</para>

	<para>Voeg de volgende regels aan <filename>/etc/rc.conf</filename> toe
	  om deze informatie na het opnieuw starten te behouden:</para>

	<programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg0</literal>"
ifconfig_<literal>lagg0</literal>="laggproto lacp laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.15/24</replaceable>"</programlisting>
      </example>

      <example xml:id="networking-lagg-wired-and-wireless">
	<title>Failover-modus tussen bekabelde en draadloze interfaces</title>

	<para>Voor laptop-gebruikers is het normaliter wenselijk om het
	  draadloze interface als secundair interface te gebruiken indien het
	  bekabelde interface niet beschikbaar is.  Met &man.lagg.4; is het
	  mogelijk om één IP-adres te gebruiken en het bekabelde
	  interface voor zowel prestatie als veiligheid te prefereren terwijl de
	  mogelijkheid behouden blijft om de draadloze verbinding te
	  gebruiken.</para>

	<para>In deze opstelling dient het MAC-adres van het onderliggende
	  draadloze interface overschreven te worden om met dat van &man.lagg.4;
	  overeen te komen, welke afkomstig is van het primaire interface dat
	  wordt gebruikt, het bekabelde interface.</para>

	<para>In deze opstelling wordt het bekabelde interface,
	  <replaceable>bge0</replaceable> als meester gebruikt, en het draadloze
	  interface, <replaceable>wlan0</replaceable>, als het
	  failover-interface.  <replaceable>wlan0</replaceable> was aangemaakt
	  vanuit <replaceable>iwn0</replaceable> voor welke het
	  <acronym>MAC</acronym>-adres van de bekabelde verbinding zal worden
	  gebruikt.  De eerste stap is om het <acronym>MAC</acronym>-adres van
	  het bekabelde interface te verkrijgen:</para>

	<screen>&prompt.root;  <userinput>ifconfig bge0</userinput>
bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
      ether 00:21:70:da:ae:37
      inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
      nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
      media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
      status: active</screen>

	<para><replaceable>bge0</replaceable> kan vervangen worden door het
	  eigenlijke interface, er zal een andere regel met
	  <literal>ether</literal> verschijnen, dit is het
	  <acronym>MAC</acronym>-adres van het bekabelde interface.  Om het
	  onderliggende draadloze interface, <replaceable>iwn0</replaceable> te
	  wijzigen:</para>

	<screen>&prompt.root; <userinput>ifconfig iwn0 ether 00:21:70:da:ae:37</userinput></screen>

	<para>Activeer het draadloze interface maar geef er nog geen IP-adres
	  aan:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev iwn0 ssid mijn_router up</userinput></screen>

	<para>Activeer de interface <replaceable>bge0</replaceable>.  Maak het
	  &man.lagg.4;-interface aan met <replaceable>bge0</replaceable> als
	  meester, en met failover naar <replaceable>wlan0</replaceable> indien
	  nodig:</para>

	<screen>&prompt.root; <userinput>ifconfig bge0 up</userinput>
&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0</userinput></screen>

	<para>Het interface zal er ongeveer als volgt uitzien, de grootste
	  verschillen zullen het <acronym>MAC</acronym>-adres en de
	  apparaatnamen zijn:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      options=8&lt;VLAN_MTU&gt;
      ether 00:21:70:da:ae:37
      media: Ethernet autoselect
      status: active
      laggproto failover
      laggport: wlan0 flags=0&lt;&gt;
      laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Start vervolgens de DHCP-cliënt om een IP-adres te
	  verkrijgen:</para>

	<screen>&prompt.root; <userinput>dhclient lagg0</userinput></screen>

	<para>Om deze configuratie bij het opstarten te behouden, kan het
	  volgende aan <filename>/etc/rc.conf</filename> worden
	  toegevoegd:</para>

	<programlisting>ifconfig_bge0="up"
ifconfig_iwn0="ether 00:21:70:da:ae:37"
wlans_iwn0="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="<literal>lagg0</literal>"
ifconfig_<literal>lagg0</literal>="laggproto failover laggport bge0 laggport wlan0 DHCP"</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="network-diskless">
    <info><title>Schijfloos werken</title>
      <authorgroup>
	<author><personname><firstname>Jean-Fran&ccedil;ois</firstname><surname>Dockès</surname></personname><contrib>Bijgewerkt door </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Alex</firstname><surname>Dupre</surname></personname><contrib>Gereorganiseerd en uitgebreid door </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>schijfloos werkstation</primary></indexterm>

    <indexterm><primary>schijfloos werken</primary></indexterm>

    <para>Een &os;-machine kan over het netwerk opstarten en zonder een
      plaatselijke schijf werken, door gebruik te maken van
      bestandssystemen die van een <acronym>NFS</acronym>-server
      aangekoppeld worden.  Er zijn geen systeemwijzigingen nodig anders
      dan de standaard instellingenbestanden.  Dit soort systemen is
      relatief eenvoudig op te zetten omdat alle noodzakelijke elementen
      al aanwezig zijn:</para>

    <itemizedlist>
      <listitem>
	<para>Er zijn minstens twee manieren om de kernel over het
	  netwerk te laden:</para>

	<itemizedlist>
	  <listitem>
	    <para><acronym>PXE</acronym>: De &intel; Preboot eXecution
	      Environment is een vorm een smart boot ROM dat in sommige
	      netwerkkaarten en moederborden is ingebouwd.  Bekijk de
	      hulppagina &man.pxeboot.8; voor meer informatie.</para>
	  </listitem>

	  <listitem>
	    <para>De poort <application>Etherboot</application>
	      (<package>net/etherboot</package>) maakt
	      code aan dat naar een ROM geschreven kan worden en dat
	      kernels over het netwerk opstart.  De code kan
	      òfwel naar een opstart-PROM op een netwerkkaart
	      geflashed worden, òfwel van een floppy (of harde)
	      schijf geladen worden, òfwel van een draaiend
	      &ms-dos; systeem geladen worden.  Vele netwerkkaarten
	      worden ondersteund.</para>
	  </listitem>
	</itemizedlist>
      </listitem>

      <listitem>
	<para>Een voorbeeldscript
	  (<filename>/usr/share/examples/diskless/clone_root</filename>)
	  vergemakkelijkt het aanmaken en beheren van het root
	  bestandssysteem van het werkstation op de server.  Het kan
	  nodig zijn dat het script wat aangepast moet worden, maar het
	  zorgt voor een snelle start.</para>
      </listitem>

      <listitem>
	<para>Er bestaan standaardbestanden voor het opstarten van het systeem
	  in <filename>/etc</filename> om een systeemstart
	  zonder schijf te detecteren en te ondersteunen.</para>
      </listitem>

      <listitem>
	<para>Het gebruik van een wisselbestand, indien nodig, kan
	  worden gedaan naar òfwel een <acronym>NFS</acronym>
	  bestand òfwel naar een plaatselijke schijf.</para>
      </listitem>
    </itemizedlist>

    <para>Er zijn vele manieren om een schijfloos werkstation op te
      zetten.  Hierbij zijn veel elementen betrokken, en vele kunnen aan
      de eigen smaak worden aangepast.  Het volgende beschrijft
      variaties met betrekking tot het installeren van een compleet
      systeem, waarbij de nadruk ligt op de eenvoud en de
      compatibiliteit met de standaard opstartscripts van &os;.  Het
      beschreven systeem heeft de volgende eigenschappen:</para>

    <itemizedlist>
      <listitem>
	<para>De schijfloze werkstations gebruiken een gedeeld bestandssysteem
	  voor <filename>/</filename>, dat alleen
	  gelezen kan worden, en een gedeeld bestandssysteem voor <filename>/usr</filename>, dat eveneens alleen gelezen kan
	  worden.</para>

	<para>Het root-bestandssysteem is een kopie van een standaard
	  root-bestandssysteem voor &os; (typisch van een server),
	  waarbij enkele instellingenbestanden zijn overschreven door
	  versies die specifiek zijn voor een schijfloos systeem of,
	  mogelijk, door het werkstation horen waar ze bij horen.</para>

	<para>De delen van het root-bestandssysteem die beschrijfbaar
	  moeten zijn, zijn overdekt met &man.md.4; bestandssystemen.
	  Alle veranderingen gaan verloren indien het systeem opnieuw
	  wordt opgestart.</para>
      </listitem>

      <listitem>
	<para>De kernel is overgedragen en òfwel met
	  <application>Etherboot</application> òfwel met
	  <acronym>PXE</acronym> geladen, aangezien sommige situaties
	  het gebruik van één van de methodes kan eisen.</para>
      </listitem>
    </itemizedlist>

    <caution>
      <para>Het systeem zoals hierboven beschreven is onveilig.  Het
	dient in een beschermd gebied van een netwerk te functioneren, en
	niet vertrouwd te worden door andere hosts.</para>
    </caution>

    <para>Alle informatie in deze sectie is getest met
      &os;&nbsp;5.2.1-RELEASE.</para>

    <sect2>
      <title>Achtergrondinformatie</title>

      <para>Het installeren van schijfloze werkstations is zowel vrij
	rechttoe-rechtaan als foutgevoelig.  Deze fouten zijn soms
	moeilijk vast te stellen wegens een aantal redenen.
	Bijvoorbeeld:</para>

      <itemizedlist>
	<listitem>
	  <para>Opties die tijdens het compileren zijn opgegeven kunnen
	    verschillend gedrag tonen tijdens het draaien.</para>
	</listitem>

	<listitem>
	  <para>Foutmeldingen zijn vaak cryptisch of geheel afwezig.</para>
	</listitem>
      </itemizedlist>

      <para>Op dit gebied is het bezit van wat achtergrondkennis over de
	gebruikte mechanismen zeer nuttig om mogelijke problemen op te
	lossen.</para>

      <para>Voor een succesvol opstarten dienen verschillende
	handelingen uitgevoerd te worden:</para>

      <itemizedlist>
	<listitem>
	  <para>De machine moet een aantal initiële parameters
	    zoals het IP-adres, de bestandsnaam van de executable, de
	    naam van de server, en het root-pad verkrijgen.  Dit wordt
	    gedaan door gebruik te maken van de <acronym>DHCP</acronym>
	    of BOOTP protocollen.  <acronym>DHCP</acronym> is een
	    compatible uitbreiding van BOOTP, het gebruikt dezelfde
	    poorten en het pakketformaat heeft dezelfde basis.</para>

	  <para>Het is mogelijk om een systeem in te stellen zodat het
	    alleen BOOTP gebruikt.  Het serverprogramma &man.bootpd.8;
	    wordt met het basissysteem van &os; meegeleverd.</para>

	  <para><acronym>DHCP</acronym> biedt echter een aantal
	    voordelen boven BOOTP (fijnere instellingenbestanden,
	    mogelijkheid om <acronym>PXE</acronym> te gebruiken, en vele
	    anderen die niet direct verband houden met schijfloos
	    werken), er zal hoofdzakelijk een opstelling met
	    <acronym>DHCP</acronym> worden beschreven, met analoge
	    voorbeelden voor &man.bootpd.8; indien mogelijk.  De
	    voorbeeldopstelling zal het softwarepakket van
	    <application>ISC DHCP</application> gebruiken (versie
	    3.0.1.r12 was geïnstalleerd op de testserver).</para>
	</listitem>

	<listitem>
	  <para>De machine moet één of meerdere
	    programma's naar het plaatselijke geheugen versturen.
	    Eén van <acronym>TFTP</acronym> of
	    <acronym>NFS</acronym> wordt gebruikt.  De keuze tussen
	    <acronym>TFTP</acronym> en <acronym>NFS</acronym> is op
	    verschillende plaatsen een optie tijdens het compileren.
	    Een veelgemaakte fout is het opgeven van bestandsnamen voor
	    het verkeerde protocol: <acronym>TFTP</acronym> verstuurd
	    typisch alle bestanden vanuit één map op de
	    server, en verwacht dat alle bestandsnamen relatief aan
	    deze map zijn; <acronym>NFS</acronym> verwacht absolute
	    bestandspaden.</para>
	</listitem>

	<listitem>
	  <para>De mogelijke tussentijdse opstartprogramma's en de
	    kernel dienen geïnitialiseerd en uitgevoerd te worden.
	    Er zijn enkele belangrijke variaties op dit gebied:</para>

	  <itemizedlist>
	    <listitem>
	      <para><acronym>PXE</acronym> zal &man.pxeboot.8; laden,
		wat een aangepaste versie is van de lader voor stage
		drie van &os;.  &man.loader.8; zal de meeste parameters
		verkrijgen die noodzakelijk zijn om het systeem op te
		starten, en zal ze in de kernelomgeving laten staan
		voordat het de controle overdraagt.  Het is in dit geval
		mogelijk om een <filename>GENERIC</filename> kernel te
		gebruiken.</para>
	    </listitem>

	    <listitem>
	      <para><application>Etherboot</application> zal met minder
		voorbereiding direct de kernel laden.  Hiervoor is het
		noodzakelijk om een kernel met specifieke opties te
		bouwen.</para>
	    </listitem>
	  </itemizedlist>

	  <para><acronym>PXE</acronym> en
	    <application>Etherboot</application> werken beide even goed;
	    echter, omdat kernels normaalgesproken meer werk overlaten
	    aan &man.loader.8;, is <acronym>PXE</acronym> de te
	    verkiezen methode.</para>

	  <para>Indien het <acronym>BIOS</acronym> en de netwerkkaarten
	    <acronym>PXE</acronym> ondersteunen, dient dat
	    waarschijnlijk gebruikt te worden.</para>
	</listitem>

	<listitem>
	  <para>Tenslotte: de machine heeft toegang tot de
	    bestandssystemen nodig.  <acronym>NFS</acronym> wordt in
	    alle gevallen gebruikt.</para>
	</listitem>
      </itemizedlist>

      <para>Zie ook de hulppagina &man.diskless.8;.</para>
    </sect2>

    <sect2>
      <title>Installatie-instructies</title>

      <sect3>
	<title>Instellen met behulp van
	  <application>ISC DHCP</application></title>

	<indexterm>
	  <primary>DHCP</primary>

	  <secondary>schijfloos werken</secondary>
	</indexterm>

	<para>De <application>ISC DHCP</application> server kan zowel
	  verzoeken voor BOOTP als <acronym>DHCP</acronym>
	  beantwoorden.</para>

	<para><application>ISC DHCP 4.2</application> maakt geen deel
	  uit van het basissysteem.  Eerst dient de poort <package>net/isc-dhcp42-server</package> of het
	  corresponderende pakket geïnstalleerd te worden.</para>

	<para>Wanneer <application>ISC DHCP</application> is
	  geïnstalleerd, heeft het een instellingenbestand nodig om
	  te draaien (normaliter
	  <filename>/usr/local/etc/dhcpd.conf</filename> genoemd).
	  Hieronder volgt een voorbeeld met commentaar, waarbij host
	  <systemitem>margaux</systemitem> gebruik maakt van
	  <application>Etherboot</application> en
	  <systemitem>corbieres</systemitem> gebruik maakt van
	  <acronym>PXE</acronym>:</para>

	<programlisting>default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "example.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <co xml:id="co-dhcp-host-name"/>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <co xml:id="co-dhcp-next-server"/>
    filename "/data/misc/kernel.diskless"; <co xml:id="co-dhcp-filename"/>
    option root-path "192.168.4.4:/data/misc/diskless"; <co xml:id="co-dhcp-root-path"/>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename "pxeboot";
    option root-path "192.168.4.4:/data/misc/diskless";
  }
}</programlisting>

	<calloutlist>
	  <callout arearefs="co-dhcp-host-name">
	    <para>Deze optie vertelt <application>dhcpd</application>
	      om de waarde die in de verklaringen voor
	      <literal>host</literal> staan te versturen als de hostnaam
	      voor de schijfloze host.  Een andere mogelijkheid is om
	      <literal>option
		host-name margaux</literal>
	      binnen de verklaringen voor <literal>host</literal> op te
	      nemen.</para>
	  </callout>

	  <callout arearefs="co-dhcp-next-server">
	    <para>De aanwijzing <literal>next-server</literal> bepaalt
	      de <acronym>TFTP</acronym> of <acronym>NFS</acronym>
	      server die gebruikt moet worden voor het laden van het
	      lader- of kernelbestand (standaard wordt dezelfde host als
	      voor de <acronym>DHCP</acronym>-server gebruikt).</para>
	  </callout>

	  <callout arearefs="co-dhcp-filename">
	    <para>De aanwijzing <literal>filename</literal> bepaalt het
	      bestand dat <application>Etherboot</application> of
	      <acronym>PXE</acronym> gebruikt voor de volgende
	      uitvoerstap.  Het dient gespecificeerd te worden volgens
	      de gebruikte verzendmethode.  Voor
	      <application>Etherboot</application> kan tijdens het
	      compileren worden opgegeven of het <acronym>NFS</acronym>
	      of <acronym>TFTP</acronym> moet gebruiken.  De &os;-poort
	      stelt standaard <acronym>NFS</acronym> in.
	      <acronym>PXE</acronym> gebruikt <acronym>TFTP</acronym>,
	      vandaar dat hier een relatieve bestandsnaam wordt gebruikt
	      (dit kan afhangen van de instellingen van de
	      <acronym>TFTP</acronym>-server, maar het is de gewoonte).
	      Verder geldt dat <acronym>PXE</acronym>
	      <filename>pxeboot</filename> en niet de kernel laadt.  Er
	      zijn andere interessante mogelijkheden, zoals het laden
	      van <filename>pxeboot</filename> vanuit de map <filename>/boot</filename> van een &os; CD-ROM
	      (aangezien &man.pxeboot.8; de <filename>GENERIC</filename>
	      kernel kan laden, bestaat de mogelijkheid om
	      <acronym>PXE</acronym> te gebruiken om van een CDROM op
	      afstand op te starten.</para>
	  </callout>

	  <callout arearefs="co-dhcp-root-path">
	    <para>De optie <literal>root-path</literal> definieert het
	      pad naar het root-bestandssysteem, in de gebruikelijke
	      notatie van <acronym>NFS</acronym>.  Indien
	      <acronym>PXE</acronym> gebruikt wordt, is het mogelijk om
	      het IP-adres van de host weg te laten zolang de
	      kerneloptie BOOTP niet geactiveerd is.  De
	      <acronym>NFS</acronym>-server is dan dezelfde als die van
	      <acronym>TFTP</acronym>.</para>
	  </callout>
	</calloutlist>
      </sect3>

      <sect3>
	<title>Configuratie door gebruik van BOOTP</title>

	<indexterm>
	  <primary>BOOTP</primary>

	  <secondary>schijfloos werken</secondary>
	</indexterm>

	<para>Hieronder staan de equivalente instellingen voor
	  <application>bootpd</application> (gereduceerd tot
	  één cliënt).  Dit staat in
	  <filename>/etc/bootptab</filename>.</para>

	<para>Merk op dat <application>Etherboot</application>
	  gecompileerd dient te worden met de afwijkende optie
	  <literal>NO_DHCP_SUPPORT</literal> om BOOTP te gebruiken, en
	  dat <acronym>PXE</acronym> <acronym>DHCP</acronym>
	  <emphasis>nodig heeft</emphasis>.  Het enige duidelijke
	  voordeel van <application>bootpd</application> is dat het in
	  het basissysteem zit.</para>

	<programlisting>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100</programlisting>
      </sect3>

      <sect3>
	<title>Een opstartprogramma voorbereiden met
	  <application>Etherboot</application></title>

	<indexterm><primary>Etherboot</primary></indexterm>

	<para>De <link xlink:href="http://etherboot.sourceforge.net">website
	    van Etherboot</link> bevat <link xlink:href="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
	    uitgebreide documentatie</link> die over het algemeen is
	  bedoeld voor Linux-systemen, maar die desalniettemin bruikbare
	  informatie bevat.  Het volgende geeft een samenvatting over
	  hoe <application>Etherboot</application> op een &os;-systeem
	  te gebruiken.</para>

	<para>Ten eerste dient het pakket of de poort <package>net/etherboot</package> geïnstalleerd
	  te worden.</para>

	<para>De instellingen van <application>Etherboot</application>
	  (i.e., om <acronym>TFTP</acronym> in plaats van
	  <acronym>NFS</acronym> te gebruiken) kunnen gewijzigd worden
	  door het bestand <filename>Config</filename> in de bronmap van
	  <application>Etherboot</application> te bewerken.</para>

	<para>Hieronder zal een opstartdiskette gebruikt worden.
	  Raadpleeg voor andere methoden (PROM, of een
	  &ms-dos;-programma) de documentatie van
	  <application>Etherboot</application>.</para>

	<para>Om een opstartdiskette te maken, dient er een diskette in
	  het diskettestation van de machine aanwezig te zijn waarop
	  <application>Etherboot</application> is geïnstalleerd, daarna dient
	  er naar de map <filename>src</filename> in de
	  mapboom van <application>Etherboot</application> gegaan te
	  worden, en het volgende ingetypt te worden:</para>

	<screen>&prompt.root; <userinput>gmake bin32/apparaatsoort.fd0</userinput></screen>

	<para><replaceable>apparaatsoort</replaceable> hangt af van het
	  soort Ethernetkaart dat in het schijfloze werkstation
	  aanwezig is.  Raadpleeg het bestand <filename>NIC</filename>
	  in dezelfde map om het juiste
	  <replaceable>apparaatsoort</replaceable> te bepalen.</para>
      </sect3>

      <sect3>
	<title>Opstarten met <acronym>PXE</acronym></title>

	<para>Standaard laadt de lader &man.pxeboot.8; de kernel via
	  <acronym>NFS</acronym>.  Het kan zodanig gecompileerd worden
	  dat het <acronym>TFTP</acronym> gebruikt door de optie
	  <literal>LOADER_TFTP_SUPPORT</literal> in
	  <filename>/etc/make.conf</filename> te specificeren.
	  Raadpleeg het commentaar in
	  <filename>/usr/share/examples/etc/make.conf</filename>
	  voor instructies.</para>

	<para>Er zijn nog twee andere opties voor
	  <filename>make.conf</filename> die nuttig kunnen zijn bij het
	  opzetten van een schijfloze machine die als seriële
	  console gebruikt wordt:
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, en
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal>.</para>

	<para>Om <acronym>PXE</acronym> bij het opstarten van de machine
	  te gebruiken, is het gewoonlijk nodig om de optie
	  <literal>Boot from network</literal> in het
	  <acronym>BIOS</acronym> te selecteren, of om een functietoets
	  tijdens de initialisatie van de PC in te typen.</para>
      </sect3>

      <sect3>
	<title>De <acronym>TFTP</acronym> en <acronym>NFS</acronym>
	  servers instellen</title>

	<indexterm>
	  <primary>TFTP</primary>

	  <secondary>schijfloos werken</secondary>
	</indexterm>

	<indexterm>
	  <primary>NFS</primary>

	  <secondary>schijfloos werken</secondary>
	</indexterm>

	<para>Indien <acronym>PXE</acronym> of
	  <acronym>Etherboot</acronym> gebruikt wordt, welke is
	  ingesteld om <acronym>TFTP</acronym> te gebruiken, is het
	  nodig om <application>tftpd</application> op de
	  bestandsserver aan te zetten:</para>

	<procedure>
	  <step>
	    <para>Maak een map aan van waaruit <application>tftpd</application>
	      de bestanden serveert, bijvoorbeeld <filename>/tftpboot</filename>.</para>
	  </step>

	  <step>
	    <para>Voeg deze regel toe aan
	      <filename>/etc/inetd.conf</filename>:</para>

	    <programlisting>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</programlisting>

	    <note>
	      <para>Het schijnt dat sommige versies van
		<acronym>PXE</acronym> de <acronym>TCP</acronym>-versie
		van <acronym>TFTP</acronym> vereisen.  In dit geval
		dient een tweede regel toegevoegd te worden, waarbij
		<literal>dgram udp</literal> door
		<literal>stream tcp</literal> vervangen wordt.</para>
	    </note>
	  </step>

	  <step>
	    <para><application>inetd</application> dient de
	      instellingenbestanden opnieuw te lezen.  De regel
	      <option>inetd_enable="YES"</option> dient in het bestand
	      <filename>/etc/rc.conf</filename> aanwezig te zijn voor de
	      juiste werking van deze opdracht:</para>

	    <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
	  </step>
	</procedure>

	<para>De map <filename>tftpboot</filename> kan overal
	  op de server geplaatst worden.  De plaats dient zowel in
	  <filename>inetd.conf</filename> als in
	  <filename>dhcpd.conf</filename> ingesteld te worden.</para>

	<para>In alle gevallen dient er ook voor gezorgd te worden dat
	  <acronym>NFS</acronym> aanstaat en dat het juiste
	  bestandssysteem op de <acronym>NFS</acronym>-server
	  geëxporteerd wordt.</para>

	<procedure>
	  <step>
	    <para>Voeg het volgende toe aan
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>nfs_server_enable="YES"</programlisting>
	  </step>

	  <step>
	    <para>Exporteer het bestandssysteem waar de schijfloze
	      root-map zich bevindt door het volgende aan
	      <filename>/etc/exports</filename> toe te voegen (pas het
	      aankoppelpunt van het volume aan en vervang
	      <replaceable>margaux corbieres</replaceable> door de namen
	      van de schijfloze werkstations):</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux corbieres</replaceable></programlisting>
	  </step>

	  <step>
	    <para><application>mountd</application> dient het
	      instellingenbestand opnieuw te lezen.  Indien het nodig
	      was om <acronym>NFS</acronym> in
	      <filename>/etc/rc.conf</filename>
	      tijdens de eerste stap aan te zetten, is het
	      waarschijnlijk gewenst om in plaats hiervan opnieuw op te
	      starten.</para>

	    <screen>&prompt.root; <userinput>service mountd restart</userinput></screen>
	  </step>
	</procedure>
      </sect3>

      <sect3>
	<title>Een schijfloze kernel bouwen</title>

	<indexterm>
	  <primary>schijfloos werken</primary>

	  <secondary>kernelinstellingen</secondary>
	</indexterm>

	<para>Indien <application>Etherboot</application> gebruikt wordt,
	  is het nodig om een kernelinstellingenbestand voor de
	  schijfloze cliënt met de volgende opties (naast de
	  gebruikelijke) aan te maken:</para>

	<programlisting>options	BOOTP		# Gebruik BOOTP om het IP-adres en de hostnaam te verkrijgen
options	BOOTP_NFSROOT	# NFS-mount het root-bestandssysteem door gebruik te maken van de informatie van BOOTP</programlisting>

	<para>Het kan ook gewenst zijn om <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal>, en
	  <literal>BOOTP_WIRED_TO</literal> te gebruiken (raadpleeg
	  hiervoor <filename>NOTES</filename>).</para>

	<para>De namen van deze opties zijn historisch en enigszins
	  misleidend aangezien ze eigenlijk onverschillig gebruik van
	  <acronym>DHCP</acronym> en BOOTP in de kernel mogelijk maken
	  (het is ook mogelijk om strikt gebruik van BOOTP of
	  <acronym>DHCP</acronym> te forceren).</para>

	<para>De kernel dient gebouwd te worden (zie <xref linkend="kernelconfig"/>) en gekopieerd te worden naar de
	  plaats die in <filename>dhcpd.conf</filename> is
	  aangegeven.</para>

	<note>
	  <para>Indien <acronym>PXE</acronym> gebruikt wordt, is het
	    bouwen van een kernel met bovenstaande opties niet strikt
	    noodzakelijk (maar wel aangeraden).  Door deze opties aan te
	    zetten zullen er meer verzoeken voor <acronym>DHCP</acronym>
	    tijdens het opstarten van de kernel verstuurd worden, met in
	    sommige speciale gevallen een klein risico op inconsistentie
	    tussen de nieuwe waarden en degenen die door &man.pxeboot.8;
	    zijn ontvangen.  Het voordeel van het gebruik van deze
	    opties is dat de hostnaam als een bijverschijnsel wordt
	    ingesteld.  In de andere gevallen dient de hostnaam op een
	    andere manier ingesteld te worden, bijvoorbeeld in een
	    cliënt-specifiek bestand
	    <filename>rc.conf</filename>.</para>
	</note>

	<note>
	  <para>Om laadbaar te zijn met
	    <application>Etherboot</application>, dienen de
	    apparaataanwijzingen in de kernel gecompileerd te worden.
	    Normaalgesproken wordt hiervoor de volgende optie in het
	    instellingenbestand gebruikt (zie het
	    instellingencommentaarbestand
	    <filename>NOTES</filename>):</para>

	  <programlisting>hints		"GENERIC.hints"</programlisting>
	</note>
      </sect3>

      <sect3>
	<title>Het root-bestandssysteem voorbereiden</title>

	<indexterm>
	  <primary>root-bestandssysteem</primary>

	  <secondary>schijfloos werken</secondary>
	</indexterm>

	<para>Er dient een root-bestandssysteem voor de schijfloze
	  werkstations op de plaats die als <literal>root-path</literal>
	  in <filename>dhcpd.conf</filename> staat aangegeven aangemaakt
	  te worden.</para>

	<sect4>
	  <title><command>make world</command> gebruiken om het
	    root-bestandssysteem te bevolken</title>

	  <para>Deze methode is snel en installeert een compleet
	    maagdelijk systeem (niet alleen het root-bestandssysteem) in
	    <envar>DESTDIR</envar>.  Hiervoor dient slechts het volgende
	    script uitgevoerd te worden:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Nadat dit gedaan is, kunnen
	    <filename>/etc/rc.conf</filename> en
	    <filename>/etc/fstab</filename> die in
	    <envar>DESTDIR</envar> geplaatst zijn naar behoefte worden
	    aangepast.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Swapruimte instellen</title>

	<para>Indien nodig kan een wisselbestand dat zich op de server
	  bevindt via <acronym>NFS</acronym> worden benaderd.</para>

	<sect4>
	  <title>Swapruimte via <acronym>NFS</acronym></title>

	  <para>De kernel biedt geen ondersteuning om swapruimte via
	    <acronym>NFS</acronym> tijdens het opstarten aan te zetten.
	    De swapruimte moet door de opstartscripts worden aangezet,
	    door een beschrijfbaar bestandssysteem aan te koppelen en
	    een wisselbestand aan te maken en aan te zetten.  De
	    volgende opdracht maakt een wisselbestand van de juiste
	    grootte aan:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/pad/naar/wisselbestand bs=1k count=1 oseek=100000</userinput></screen>

	  <para>Om het aan te zetten dient de volgende regel aan
	    <filename>/etc/rc.conf</filename> te worden
	    toegevoegd:</para>

	  <programlisting>swapfile=<replaceable>/pad/naar/wisselbestand</replaceable></programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title>Diverse problemen</title>

	<sect4>
	  <title>Draaien met een alleen-lezen
	    <filename>/usr</filename></title>

	  <indexterm>
	    <primary>schijfloos werken</primary>

	    <secondary>/usr alleen-lezen</secondary>
	  </indexterm>

	  <para>Indien het schijfloze werkstation is ingesteld om X te
	    draaien, is het nodig om het instellingenbestand van
	    <application>XDM</application> te wijzigen, dat standaard
	    het foutenlogboek in <filename>/usr</filename>
	    plaatst.</para>
	</sect4>

	<sect4>
	  <title>Gebruik maken van een niet-&os;-server</title>

	  <para>Indien de server voor het root-bestandssysteem geen &os;
	    draait, is het nodig om het root-bestandssysteem op een
	    &os;-machine aan te maken, en het daarna naar de bestemming
	    te kopiëren, door gebruik te maken van
	    <command>tar</command> of <command>cpio</command>.</para>

	  <para>In deze situatie zijn er af en toe problemen met de
	    speciale bestanden in <filename>/dev</filename>,
	    vanwege verschillen in de groottes van grote/kleine integers.  Een
	    oplossing voor dit probleem is om een map van de
	    niet-&os;-server te exporteren, deze map op een &os;-machine
	    aan te koppelen, en &man.devfs.5; te gebruiken om de
	    apparaatknooppunten transparant voor de gebruiker toe te
	    wijzen.</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-pxe-nfs">
    <info><title>Met PXE en een NFS-root-bestandssysteem opstarten</title>
      <authorgroup>
	<author><personname><firstname>Craig</firstname><surname>Rodrigues</surname></personname><affiliation>
	    <address>rodrigc@FreeBSD.org</address>
	  </affiliation><contrib>Geschreven door </contrib></author>
      </authorgroup>
    </info>

    

    <para>Het Preboot eXecution Environment (<acronym>PXE</acronym>) van &intel;
      maakt het mogelijk om het besturingssysteem over het netwerk op te
      starten.  Ondersteuning voor <acronym>PXE</acronym> wordt normaliter
      aangeboden in het <acronym>BIOS</acronym> van moderne moederborden, waar
      het kan worden aangezet in de instellingen van het <acronym>BIOS</acronym>
      wat opstarten over het netwerk mogelijk maakt.  Een volledig werkende
      <acronym>PXE</acronym>-opstelling vereist ook correct geconfigureerde
      <acronym>DHCP</acronym>- en <acronym>TFTP</acronym>-servers.</para>

    <para>Wanneer de gastheercomputer opstart, krijgt het informatie over
      <acronym>DHCP</acronym> over waar de intiële bootloader staat via
      TFTP.  Nadat de gastheercomputer deze informatie heeft ontvangen,
      downloadt het de bootloader via <acronym>TFTP</acronym> en voert
      het vervolgens de bootloader uit.  Dit is gedocumenteerd in sectie 2.2.1
      van de <link xlink:href="http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf">Preboot
	Execution Environment (PXE) Specification</link>.  In &os; is de
      bootloader die tijdens het <acronym>PXE</acronym>-proces wordt opgehaald
      <filename>/boot/pxeboot</filename>.  Terwijl
      <filename>/boot/pxeboot</filename> wordt uitgevoerd, wordt de kernel van
      &os; geladen en wordt er verder gegaan met de rest van de opstartprocedure
      van &os;.  Kijk voor meer informatie over het opstartproces van &os; in
      <xref linkend="boot"/>.</para>

    <sect2>
      <title>De <command>chroot</command>-omgeving voor het
	NFS-root-bestandssysteem instellen</title>

      <procedure>
	<step>
	  <para>Kies een map uit voor een installatie van &os; die over NFS
	    aangekoppeld kan worden.  Bijvoorbeeld een map als <filename>/b/tftpboot/FreeBSD/install</filename>.</para>

	  <screen>&prompt.root; <userinput>export NFSROOTDIR=/b/tftpboot/FreeBSD/install</userinput>
&prompt.root; <userinput>mkdir -p ${NFSROOTDIR}</userinput></screen>
	</step>

	<step>
	  <para>Stel de NFS-server in door de instructies in <xref linkend="network-configuring-nfs"/> op te volgen.</para>
	</step>

	<step>
	  <para>Exporteer de map via NFS door het volgende aan
	    <filename>/etc/exports</filename> toe te voegen:</para>

	  <programlisting>/b -ro -alldirs</programlisting>
	</step>

	<step>
	  <para>Herstart de NFS-server:</para>

	  <screen>&prompt.root; <userinput>service nfsd restart</userinput></screen>
	</step>

	<step>
	  <para>Stel &man.inetd.8; in door de stappen zoals in <xref linkend="network-inetd-settings"/> beschreven op te volgen.</para>
	</step>

	<step>
	  <para>Voeg de volgende regel toe aan
	    <filename>/etc/inetd.conf</filename>:</para>

	  <programlisting>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</programlisting>
	</step>

	<step>
	  <para>Herstart inetd:</para>

	  <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
	</step>

	<step>
	  <para><link linkend="makeworld">Herbouw de kernel en userland van
	      &os;</link>:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput></screen>
	</step>

	<step>
	  <para>Installeer &os; in de map die over <acronym>NFS</acronym> is
	    aangekoppeld:</para>

	  <screen>&prompt.root; <userinput>make installworld DESTDIR=${NFSROOTDIR}</userinput>
&prompt.root; <userinput>make installkernel DESTDIR=${NFSROOTDIR}</userinput>
&prompt.root; <userinput>make distribution DESTDIR=${NFSROOTDIR}</userinput></screen>
	</step>

	<step>
	  <para>Test dat de <acronym>TFTP</acronym>-server werkt en dat het de
	    bootloader dat via PXE verkregen zal worden kan downloaden:</para>

	  <screen>&prompt.root; <userinput>tftp localhost</userinput>
tftp&gt; <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds</screen>
	</step>

	<step>
	  <para>Voeg een regel aan <filename>${NFSROOTDIR}/etc/fstab</filename>
	    toe om het root-bestandssysteem over NFS aan te koppelen:</para>

	  <programlisting># Device                                            Mountpoint    FSType   Options  Dump Pass
mijnhost.example.com:/b/tftpboot/FreeBSD/install      /         nfs      ro        0    0</programlisting>

	  <para>Vervang <replaceable>mijnhost.example.com</replaceable> door
	    de hostnaam of het IP-adres van uw <acronym>NFS</acronym>-server.
	    In dit voorbeeld wordt het root-bestandssysteem als alleen-lezen
	    aangekoppeld om te voorkomen dat
	    <acronym>NFS</acronym>-cliënten per ongeluk de inhoud van het
	    root-bestandssysteem wissen.</para>
	</step>

	<step>
	  <para>Stel het root-wachtwoord in voor de
	    &man.chroot.8;-omgeving.</para>

	  <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>passwd</userinput></screen>

	  <para>Dit stelt het root-wachtwoord in voor cliëntmachines die
	    over <acronym>PXE</acronym> opstarten.</para>
	</step>

	<step>
	  <para>Maak root-logins over SSH mogelijk voor cliëntmachines die
	    met <acronym>PXE</acronym> opstarten door
	    <filename>${NFSROOTDIR}/etc/ssh/sshd_config</filename> te bewerken
	    en de optie <literal>PermitRootLogin</literal> aan te zetten.  Dit
	    is gedocumenteerd in &man.sshd.config.5;.</para>
	</step>

	<step>
	  <para>Pas andere wijzigingen toe aan de &man.chroot.8;-omgeving in
	    ${NFSROOTDIR}.  Deze wijzigingen zouden het toevoegen van pakketten
	    met &man.pkg.add.1;, het bewerken van het wachtwoordbestand met
	    &man.vipw.8; of het bewerken van &man.amd.conf.5;-projecties voor
	    automatisch aankoppelen kunnen zijn.  Bijvoorbeeld:</para>

	  <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>pkg_add -r bash</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Geheugenbestandssystemen die gebruikt worden door
	<filename>/etc/rc.initdiskless</filename> configureren</title>

      <para>Als u vanaf een NFS-rootvolume opstart, detecteert
	<filename>/etc/rc</filename> dat u over NFS opstartte en draait het het
	script <filename>/etc/rc.initdiskless</filename>.  Lees het commentaar
	in dit script om te begrijpen wat er gebeurt.  Het is nodig om
	<filename>/etc</filename> en <filename>/var</filename> geheugen-backed
	te maken omdat deze mappen schrijfbaar moeten zijn, maar de NFS-rootmap
	is alleen-lezen.</para>

      <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>mkdir -p conf/base</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</userinput></screen>

      <para>Wanneer het systeem opstart, zullen er geheugen-bestandssystemen
	voor <filename>/etc</filename> en <filename>/var</filename> worden aangemaakt en aangekoppeld,
	en zal de inhoud van de <filename>cpio.gz</filename>-bestanden er
	naartoe worden gekopieerd.</para>
    </sect2>

    <sect2 xml:id="network-pxe-setting-up-dhcp">
      <title>Een DHCP-server prepareren</title>

      <para>PXE heeft een geprepareerde <acronym>TFTP</acronym>-server en
	<acronym>DHCP</acronym>-server nodig.  De <acronym>DHCP</acronym>-server
	hoeft niet per së dezelfde machine te zijn als de
	<acronym>TFTP</acronym>-server, maar het dient bereikbaar te zijn in uw
	netwerk.</para>

      <procedure>
	<step>
	  <para>Installeer de <acronym>DHCP</acronym>-server door de instructies
	    op te volgen zoals beschreven in <xref linkend="network-dhcp-server"/>.  Zorg ervoor dat
	    <filename>/etc/rc.conf</filename> en
	    <filename>/usr/local/etc/dhcpd.conf</filename> correct zijn
	    geconfigureerd.</para>
	</step>

	<step>
	  <para>Stel in <filename>/usr/local/etc/dhcpd.conf</filename>
	    <literal>next-server</literal>, <literal>filename</literal> en
	    <literal>option root-path</literal> in om het IP-adres van uw
	    <acronym>TFTP</acronym>-server, het pad naar
	    <filename>/boot/pxeboot</filename> en het pad naar het
	    <acronym>NFS</acronym>-root-bestandssysteem op te geven.  Hier is
	    een voorbeeld van de instellingen voor
	    <filename>dhcpd.conf</filename>:</para>

	  <programlisting>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-server 192.168.35.35, 192.168.35.36 ;
   option domain-name "example.com";

   # IP-adres van TFTP server
   next-server 192.168.0.1 ;

   # pad van bootloader verkregen via TFTP
   filename "FreeBSD/install/boot/pxeboot" ;

   # pxeboot bootloader zal proberen om deze map te NFS-mounten voor root-FS
   option root-path "192.168.0.1:/b/tftpboot/FreeBSD/install/" ;
}</programlisting>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>De PXE-cliënt configureren en verbindingsproblemen
	opsporen</title>

      <procedure>
	<step>
	  <para>Ga naar het <acronym>BIOS</acronym>-configuratiemenu wanneer de
	    cliëntmachine opstart.  Stel het <acronym>BIOS</acronym> zo in
	    dat het van het netwerk opstart.  Indien alle vorige
	    configuratiestappen correct zijn, zou alles &quot;gewoon&quot;
	    moeten werken.</para>
	</step>

	<step>
	  <para>Gebruik de poort <package>net/wireshark</package> om netwerkverkeer met
	    betrekking tot het <acronym>PXE</acronym>-opstartproces te
	    debuggen, wat geïllustreerd is in onderstaand diagram.  In
	    <xref linkend="network-pxe-setting-up-dhcp"/> is een
	    voorbeeldconfiguratie gegeven waarbij de <acronym>DHCP</acronym>-,
	    <acronym>TFTP</acronym>- en <acronym>NFS</acronym>-servers op
	    dezelfde machine staan.  Deze servers kunnen echter op verschillende
	    machines staan.</para>

	  <figure>
	    <title>PXE-opstartproces met NFS-root-mount</title>

	    <mediaobject>
	      <imageobjectco>
		<areaspec units="calspair">
		  <area xml:id="co-pxenfs1" coords="2873,8133,3318,7266"/>
		  <area xml:id="co-pxenfs2" coords="3519,6333,3885,5500"/>
		  <area xml:id="co-pxenfs3" coords="4780,5866,5102,5200"/>
		  <area xml:id="co-pxenfs4" coords="4794,4333,5102,3600"/>
		  <area xml:id="co-pxenfs5" coords="3108,2666,3519,1800"/>
		</areaspec>
		<imageobject>
		  <imagedata fileref="advanced-networking/pxe-nfs"/>
		</imageobject>
		<calloutlist>
		  <callout arearefs="co-pxenfs1">
		    <para>Cliënt zendt DHCPDISCOVER uit.</para>
		  </callout>
		  <callout arearefs="co-pxenfs2">
		    <para>DHCP-server antwoordt met IP-adres,
		      <literal>next-server</literal>,
		      <literal>filename</literal> en
		      <literal>root-path</literal>.</para>
		  </callout>
		  <callout arearefs="co-pxenfs3">
		    <para>Cliënt verstuurt <acronym>TFTP</acronym>-verzoek
		      naar <literal>next-server</literal> om
		      <literal>filename</literal> op te vragen.</para>
		  </callout>
		  <callout arearefs="co-pxenfs4">
		    <para>TFTP-server antwoordt en verstuurt
		      <literal>filename</literal> naar cliënt.</para>
		  </callout>
		  <callout arearefs="co-pxenfs5">
		    <para>Cliënt voert <literal>filename</literal> uit
		      welke &man.pxeboot.8; is.  &man.pxeboot.8; laadt de
		      kernel.  Wanneer de kernel draait, wordt het
		      root-bestandssysteem gespecificeerd door
		      <literal>root-path</literal> over
		      <acronym>NFS</acronym> aangekoppeld.</para>
		  </callout>
		</calloutlist>
	      </imageobjectco>
	    </mediaobject>
	  </figure>
	</step>

	<step>
	  <para>Controleer dat het bestand <filename>pxeboot</filename> via
	    <acronym>TFTP</acronym> kan worden verkregen.  Kijk op uw
	    <acronym>TFTP</acronym>-server in
	    <filename>/var/log/xferlog</filename> om er zeker van de zijn dat
	    het bestand <filename>pxeboot</filename> van de juiste locatie is
	    opgehaald.  Om de configuratie met bovenstaande
	    <filename>dhcpd.conf</filename> te testen:</para>

	  <screen>&prompt.root; <userinput>tftp 192.168.0.1</userinput>
tftp&gt; <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds</screen>

	  <para>Lees &man.tftpd.8; en &man.tftp.1;.  De <literal>BUGS</literal>
	    secties in deze pagina's documenteren enkele beperkingen van
	    <acronym>TFTP</acronym>.</para>
	</step>

	<step>
	  <para>Controleer dat het root-bestandssysteem via
	    <acronym>NFS</acronym> kan worden aangekoppeld.  Om de configuratie
	    met bovenstaande <filename>dhcpd.conf</filename> te testen:</para>

	  <screen>&prompt.root; <userinput>mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</userinput></screen>
	</step>

	<step>
	  <para>Lees de code in
	    <filename>src/sys/boot/i386/libi386/pxe.c</filename>
	    om te begrijpen hoe de <filename>pxeboot</filename>-lader variabelen
	    als <literal>boot.nfsroot.server</literal> en
	    <literal>boot.nfsroot.path</literal> instelt.  Deze variabelen
	    worden vervolgens gebruikt in de root-aankoppelcode voor diskvrij
	    NFS in <filename>src/sys/nfsclient/nfs_diskless.c</filename>.</para>
	</step>

	<step>
	  <para>Lees &man.pxeboot.8; en &man.loader.8;.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="network-isdn">
    <title>ISDN</title>

    <indexterm><primary>ISDN</primary></indexterm>

    <para>Een goede bron voor informatie over de technologie van en
      hardware over ISDN is
      <link xlink:href="http://www.alumni.caltech.edu/~dank/isdn/">Dan Kegel's
	ISDN Page</link>.</para>

    <para>Hieronder staat een snelle eenvoudige handleiding voor
      ISDN:</para>

    <itemizedlist>
      <listitem>
	<para>Indien u in Europa leeft is het raadzaam om de sectie over
	  ISDN-kaarten te bestuderen.</para>
      </listitem>

      <listitem>
	<para>Indien het plan is om ISDN hoofdzakelijk te gebruiken om
	  via een niet-toegewijde inbellijn een verbinding met het
	  Internet te maken, zijn Terminal Adapters wellicht een optie.
	  Dit biedt de meeste flexibiliteit, en de minste problemen bij
	  het wisselen van providers.</para>
      </listitem>

      <listitem>
	<para>Indien twee LANs met elkaar verbonden worden, of indien er
	  een toegewijde ISDN-verbinding wordt gebruikt om met het
	  Internet te verbinden, is het gebruik van een zelfstandige
	  router/bridge te overwegen.</para>
      </listitem>
    </itemizedlist>

    <para>Financiële kosten zijn een belangrijke factor in de
      uiteindelijke oplossing.  De volgende opties zijn gesorteerd in
      volgorde van oplopende kosten.</para>

    <sect2 xml:id="network-isdn-cards">
      <info><title>ISDN-kaarten</title>
	<authorgroup>
	  <author><personname><firstname>Hellmuth</firstname><surname>Michaelis</surname></personname><contrib>Bijgedragen door </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>ISDN</primary>

	<secondary>kaarten</secondary>
      </indexterm>

      <para>De ISDN-implementatie in &os; biedt alleen ondersteuning
	voor de DSS1/Q.931 (of Euro-ISDN) standaard indien passieve
	kaarten gebruikt worden.  Sommige actieve kaarten worden
	ondersteund indien de firmware ook ondersteuning voor andere
	signaleringsprotocollen biedt; dit omvat ook de eerst
	ondersteunde Primary Rate (PRI) ISDN-kaart.</para>

      <para>De <application>isdn4bsd</application>-software biedt de
	mogelijkheid om met andere ISDN-routers te verbinden door
	òfwel IP over rauwe HDLC òfwel synchrone PPP te
	gebruiken: òfwel via kernel-PPP met
	<literal>isppp</literal>, een aangepast stuurprogramma voor
	&man.sppp.4;, òfwel via het gebruikersprogramma
	&man.ppp.8;.  Door het gebruikersprogramma &man.ppp.8; te
	gebruiken, is het combineren van twee of meer ISDN B-kanalen
	mogelijk.  Ook zijn een toepassing die de telefoon beantwoordt
	en vele gereedschappen zoals een 300 Baud-modem in software
	beschikbaar.</para>

      <para>Een groeiend aantal ISDN-kaarten voor de PC wordt door &os;
	ondersteund en volgens de rapportages wordt het succesvol in
	heel Europa en in vele andere delen van de wereld
	gebruikt.</para>

      <para>De ondersteunde passieve ISDN-kaarten zijn meestal uitgerust
	met de Infineon (voormalig Siemens) ISAC/HSCX/IPAC ISDN-chipsets,
	maar ook worden ISDN-kaarten ondersteund met chips van Cologne
	Chip (alleen ISA-bus), PCI-kaarten met Winbond W6692-chips,
	enkele kaarten met combinaties van Tiger300/320/ISAC chipsets en
	enkele kaarten die gebaseerd zijn op fabrikantspecifieke
	chipsets zoals de AVM Fritz!Card PCI V.1.0 en de AVM Fritz!Card
	PnP.</para>

      <para>Momenteel zijn de actieve ISDN-kaarten die ondersteund
	worden de AVM B1 (ISA en PCI) BRI-kaarten en de AVM T1 PCI
	PRI-kaarten.</para>

      <para>Kijk voor documentatie over
	<application>isdn4bsd</application> op de <link xlink:href="http://www.freebsd-support.de/i4b/">homepage van
	isdn4bsd</link>, welke ook verwijzingen naar tips, errata, en
	veel meer documentatie zoals het <link xlink:href="http://people.FreeBSD.org/~hm/">isdn4bsd handboek</link>
	bevat.</para>

      <para>Indien er interesse is om ondersteuning voor een ander
	ISDN-protocol, een momenteel niet-ondersteunde ISDN-kaart voor
	de PC, of een andere verbetering voor
	<application>isdn4bsd</application> toe te voegen, dient er
	contact opgenomen te worden met &a.hm;.</para>

      <para>Voor vragen over het installeren, instellen, en problemen
	met <application>isdn4bsd</application> oplossen is er een
	mailinglijst, &a.isdn.name;, beschikbaar.</para>
    </sect2>

    <sect2>
      <title>ISDN Terminal Adapters</title>

      <para>Terminal adapters (TA) zijn voor ISDN wat modems voor gewone
	telefoonlijnen zijn.</para>

      <indexterm><primary>modem</primary></indexterm>

      <para>De meeste TA's gebruiken de standaard opdrachtenverzameling
	van de Hayes-modem, en kunnen direct als vervanging van een
	modem gebruikt worden.</para>

      <para>Een TA zal als een gewoon modem werken behalve dat de
	verbindings- en doorvoersnelheden veel hoger zullen zijn dan van
	het oude modem.  Het is noodzakelijk om <link linkend="ppp">PPP</link> precies hetzelfde als voor het modem
	in te stellen.  Zorg ervoor dat de seriële snelheid zo hoog
	mogelijk wordt ingesteld.</para>

      <indexterm><primary>PPP</primary></indexterm>

      <para>Het grootste voordeel van met een TA met een
	internetprovider te verbinden is de mogelijkheid tot dynamisch
	PPP.  Aangezien IP-adresruimte steeds schaarser wordt, zijn de
	meeste providers niet meer bereid om een statisch IP te geven.
	De meeste zelfstandige routers zijn niet in staat tot dynamische
	IP-toewijzing.</para>

      <para>TA's zijn geheel afhankelijk van het PPP-daemon dat gedraaid
	wordt voor hun mogelijkheden en stabiliteit van de verbinding.
	Dit maakt het mogelijk om gemakkelijk om op een &os;-machine van
	een modem naar ISDN over te gaan, indien PPP reeds is ingesteld.
	Echter, dezelfde problemen die er waren met het PPP-programma
	zullen blijven voorkomen.</para>

      <para>Indien maximale stabiliteit gewenst is, dient de kernel
	<link linkend="ppp">PPP</link>-, niet de <link linkend="userppp">gebruikers-PPP</link>-optie gebruikt te
	worden.</para>

      <para>Van de volgende TA's is bekend dat ze met &os; werken:</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola BitSurfer en BitSurfer Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>De meeste andere TA's zullen waarschijnlijk ook werken,
	TA-verkopers proberen er zeker van te zijn dat hun product het
	meeste van de AT-opdrachtverzameling van het standaardmodem
	accepteert.</para>

      <para>Het echte probleem met externe TA's is dat, net zoals bij
	modems, een goede seriële kaart in de computer nodig
	is.</para>

      <para>Voor een goed begrip van seriële apparaten dient de
	tutorial <link xlink:href="&url.articles.serial-uart;/index.html">&os;
	  Serial Hardware</link> en de verschillen tussen asynchrone en
	synchrone seriële poorten gelezen te worden.</para>

      <para>Een TA die op een standaard seriële poort (asynchroon)
	van een PC draait beperkt de snelheid tot 115.2&nbsp;Kbps, zelfs
	als er een 128&nbsp;Kbps-verbinding beschikbaar is.  Om de
	volledige 128&nbsp;Kbps waartoe ISDN in staat is te gebruiken,
	dient de TA op een synchrone seriële kaart overgeplaatst te
	worden.</para>

      <para>Het kopen van een interne TA voorkomt het probleem van
	synchroon/asynchroon niet.  Interne TA's hebben simpelweg een
	seriële poortchip van een standaard PC ingebouwd.  Dit
	ontlast de gebruiker alleen van het kopen van nog een
	seriële kabel en het vinden van nog een leeg elektronisch
	uitbreidingsslot.</para>

      <para>Een synchrone kaart met een TA is minstens zo snel als een
	zelfstandige router, en wanneer het door een eenvoudige
	386 met &os; erop wordt aangestuurd, waarschijnlijk
	flexibeler.</para>

      <para>De keuze tussen synchrone kaart/TA en zelfstandige router is
	grotendeels religieus.  Hierover zijn wat discussies in de
	mailinglijsten gevoerd.  Het wordt aangeraden om de <link xlink:href="&url.base;/search/index.html">archieven</link> te
	doorzoeken voor de volledige discussie.</para>
    </sect2>

    <sect2>
      <title>Zelfstandige ISDN bridges/routers</title>

      <indexterm>
	<primary>ISDN</primary>

	<secondary>zelfstandige bridges/routers</secondary>
      </indexterm>

      <para>ISDN-bridges of -routers zijn in het geheel niet specifiek
	voor &os; of enig ander besturingssysteem.  Raadpleeg voor een
	volledigere beschrijving van de technologie van routing en
	bridging een referentieboek over netwerken.</para>

      <para>In deze sectie zullen de termen router en bridge door elkaar
	worden gebruikt.</para>

      <para>Aangezien de prijzen van eenvoudige ISDN-routers/-bridges
	zakken, zal dit waarschijnlijk een steeds populairdere keuze
	worden.  Een ISDN-router is en kleine doos die direct in het
	plaatselijke Ethernetnetwerk geprikt wordt, en zijn eigen
	verbinding met de andere bridge/router beheert.  Het heeft
	ingebouwde software om via PPP en andere populaire protocollen
	te communiceren.</para>

      <para>Een router staat veel snellere doorvoer dan een standaard-TA
	toe, aangezien het een volledig synchrone ISDN-verbinding zal
	gebruiken.</para>

      <para>Het grootste probleem met ISDN-routers en -bridges is dat
	samenwerking tussen fabrikanten nog steeds een probleem kan zijn.
	Indien er plannen zijn om met een internetprovider te verbinden,
	is het raadzaam de wensen met hen te bespreken.</para>

      <para>Indien er gepland is om twee LAN-segmenten met elkaar te
	verbinden, zoals het thuis-LAN en het kantoor-LAN, is dit de
	eenvoudigste en onderhoudarmste oplossing.  Aangezien de
	apparatuur voor beide kanten van de verbinding wordt gekocht is
	het zeker dat de verbinding zal werken.</para>

      <para>De volgende installatie kan worden gebruikt om bijvoorbeeld
	een thuiscomputer of een netwerk van een afdelingskantoor met
	een netwerk van het hoofdkantoor te verbinden:</para>

      <example>
	<title>Netwerk van afdelingskantoor of thuis</title>

	<indexterm><primary>10 base 2</primary></indexterm>

	<para>Het netwerk gebruikt een topologie gebaseerd op een bus
	  met een 10 base 2 Ethernet (<quote>thinnet</quote>).  Verbind
	  indien nodig de router met de netwerkkabel met een AUI/10BT
	  transceiver.</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-bus"/>
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">---Sun werkstation
|
---FreeBSD computer
|
---Windows 95
|
Zelfstandige router
   |
ISDN BRI lijn</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>10 Base 2 Ethernet</phrase>
	  </textobject>
	</mediaobject>

	<para>Wanneer het thuis-/afdelingskantoornetwerk uit slechts
	  één computer bestaat kan een twisted-pair
	  crossover-kabel gebruikt worden om direct met de zelfstandige
	  router te verbinden.</para>
      </example>

      <example>
	<title>Hoofdkantoor- of ander LAN</title>

	<indexterm><primary>10 base T</primary></indexterm>

	<para>Het netwerk gebruikt een stertopologie met 10 base T
	  Ethernet (<quote>Twisted Pair</quote>).</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-twisted-pair"/>
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">    -------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Zelfstandige router
                |
        ISDN BRI lijn</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>ISDN Netwerkdiagram</phrase>
	  </textobject>
	</mediaobject>
      </example>

      <para>Een groot voordeel van de meeste routers/bridges is dat ze
	<emphasis>gelijktijdig</emphasis> 2 <emphasis>gescheiden
	  onafhankelijke</emphasis> PPP-verbindingen met 2 gescheiden
	sites toestaan.  Dit wordt door de meeste TA's niet ondersteund,
	behalve voor specifieke (gewoonlijk dure) modellen die twee
	seriële poorten hebben.  Dit dient niet met kanaalbinding,
	MPP, etcetera verward te worden.</para>

      <para>Dit kan een erg handige eigenschap zijn indien, bijvoorbeeld,
	er een toegewijde ISDN-verbinding op kantoor is en het gewenst
	is om deze af te tappen, maar een andere ISDN-lijn op het werk
	ongewenst is.  Een router op kantoor kan een toegewijde B-kanaal
	verbinding (64&nbsp;Kbps) met het Internet beheren en het andere
	B-kanaal voor een gescheiden gegevensverbinding gebruiken.  Het
	tweede B-kanaal kan voor inbellen, uitbellen, of dynamisch
	binden (MPP, etcetera) gebruikt worden met het eerste B-kanaal voor
	meer bandbreedte.</para>

      <indexterm><primary>IPX/SPX</primary></indexterm>

      <para>Een Ethernet-bridge staat ook toe om meer dan alleen
	IP-verkeer te verzenden.  Het is ook mogelijk om IPX/SPX of
	enig ander protocol te gebruiken.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-natd">
    <info><title>Network Address Translation</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Bijgedragen door </contrib></author>
      </authorgroup>
    </info>

    

    <sect2 xml:id="network-natoverview">
      <title>Overzicht</title>

      <indexterm><primary><application>natd</application></primary></indexterm>

      <para>Het Network Address Translation daemon van &os;, in het
	algemeen bekend als &man.natd.8;, is een daemon dat rauwe
	binnenkomende IP-pakketten accepteert, de bron naar die van de
	plaatselijke machine verandert en de pakketten terug in de
	uitgaande IP-pakketstroom injecteert.  &man.natd.8; doet dit
	door het IP-adres en de poort van de bron zo te veranderen dat
	wanneer de gegevens weer ontvangen worden, het in staat is om
	de originele plaats van de gegevens te achterhalen en ze door
	te sturen naar de originele aanvrager.</para>

      <indexterm><primary>Internetverbinding delen</primary></indexterm>

      <indexterm><primary>NAT</primary></indexterm>

      <para>NAT wordt het meest gebruikt wat in het algemeen bekend is
	als het delen van een Internetverbinding.</para>
    </sect2>

    <sect2 xml:id="network-natsetup">
      <title>Installatie</title>

      <para>Wegens de krimpende IP-ruimte in IPv4, en het groeiend
	aantal gebruikers van consumentenlijnen op hoge snelheid zoals
	kabel of DSL, hebben steeds meer mensen een oplossing als het
	delen van een Internetverbinding nodig.  Vanwege de mogelijkheid
	om meerdere computers online te verbinden door één
	verbinding en IP-adres is &man.natd.8; een redelijke keuze.</para>

      <para>In de meeste gevallen heeft een gebruiker een machine
	verbonden met een kabel- of DSL-lijn met één
	IP-adres en is het gewenst om deze ene verbonden computer te
	gebruiken om Internettoegang aan meerdere computers over een LAN
	te geven.</para>

      <para>Hiervoor dient de &os;-machine op het Internet dienst doen
	als gateway.  Deze gateway-machine heeft twee NICs nodig &mdash;
	één voor de verbinding met de Internetrouter, de
	andere voor de verbinding met het LAN.  Alle machines op het LAN
	zijn verbonden door een hub of switch.</para>

      <note>
	<para>Er zijn vele manieren om een LAN via een &os;-gateway met
	  het Internet te verbinden.  Dit voorbeeld behandelt slechts
	  een gateway met tenminste twee NICs.</para>
      </note>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/natd"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|          |
| Client A |
|__________|</literallayout>
	</textobject>

	<textobject>
	  <phrase>Netwerkschema</phrase>
	</textobject>
      </mediaobject>

      <para>Dit soort installaties wordt in het algemeen gebruikt om een
	Internetverbinding te delen.  Eén van de
	<acronym>LAN</acronym>-machines is verbonden met het Internet.
	De rest van de machines hebben internettoegang via die
	<quote>gateway</quote>-machine.</para>
    </sect2>

    <sect2 xml:id="network-natdloaderconfiguration">
      <title>Bootloader-configuratie</title>

      <indexterm>
	<primary>bootloader</primary>

	<secondary>configuratie</secondary>
      </indexterm>

      <para>De mogelijkheden van de kernel voor network address translation met
	&man.natd.8; staan niet aan in <filename>GENERIC</filename>, maar ze
	kunnen worden voorgeladen tijdens het opstarten door enkele opties aan
	<filename>/boot/loader.conf</filename> toe te voegen:</para>

      <programlisting>ipfw_load="YES"
ipdivert_load="YES"</programlisting>

      <para>Ook moet de tunable
	<literal>net.inet.ip.fw.default_to_accept</literal> op
	<literal>1</literal> worden gezet:</para>

      <programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

      <note>
	<para>Het is een goed idee om deze optie aan te zetten tijdens de
	  eerste pogingen om een firewall en NAT gateway te installeren.  Op
	  deze manier zal het standaardbeleid van &man.ipfw.8;
	  <literal>allow ip from any to any</literal> zijn in plaats van het
	  minder vrije <literal>deny ip from any to any</literal>, en zal het
	  iets moeilijker zijn om buitengesloten te worden net na het opnieuw
	  opstarten van het systeem.</para>
      </note>
    </sect2>

    <sect2 xml:id="network-natdkernconfiguration">
      <title>Kernelconfiguratie</title>

      <indexterm>
	<primary>kernel</primary>

	<secondary>instellingen</secondary>
      </indexterm>

      <para>Wanneer modules geen optie zijn of wanneer het gewenst is om alle
	benodigde mogelijkheden in de draaiende kernel te bouwen, dienen de
	volgende opties in het kernelinstellingenbestand aanwezig te
	zijn:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>De volgende opties kunnen ook van pas komen:</para>

      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>
    </sect2>

    <sect2 xml:id="network-natdsystemconfiguration">
      <title>Systeeminstellingen voor het opstarten</title>

      <para>Om de firewall en NAT tijdens het opstarten aan te zetten, moet
	het volgende in <filename>/etc/rc.conf</filename> staan:</para>

      <programlisting>gateway_enable="YES" <co xml:id="co-natd-gateway-enable"/>
firewall_enable="YES" <co xml:id="co-natd-firewall-enable"/>
firewall_type="OPEN" <co xml:id="co-natd-firewall-type"/>
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>" <co xml:id="co-natd-natd-interface"/>
natd_flags="" <co xml:id="co-natd-natd-flags"/></programlisting>

      <calloutlist>
	<callout arearefs="co-natd-gateway-enable">
	  <para>Stelt de machine in om dienst te doen als gateway.  Het
	    draaien van
	    <command>sysctl net.inet.ip.forwarding=1</command> heeft
	    hetzelfde effect.</para>
	</callout>

	<callout arearefs="co-natd-firewall-enable">
	  <para>Activeert de firewall-regels in
	    <filename>/etc/rc.firewall</filename> tijdens het opstarten.</para>
	</callout>

	<callout arearefs="co-natd-firewall-type">
	  <para>Dit specificeert een vooraf gedefinieerde verzameling
	    van firewall-regels die alles binnenlaat.  Raadpleeg
	    <filename>/etc/rc.firewall</filename> voor aanvullende
	    types.</para>
	</callout>

	<callout arearefs="co-natd-natd-interface">
	  <para>Geeft aan welke interface te gebruiken om pakketten naar
	    door te sturen (de interface die met het Internet verbonden
	    is).</para>
	</callout>

	<callout arearefs="co-natd-natd-flags">
	  <para>Alle aanvullende instelopties die tijdens het opstarten
	    aan &man.natd.8; worden doorgegeven.</para>
	</callout>
      </calloutlist>

      <para>Het gedefinieerd hebben van de bovenstaande opties in
	<filename>/etc/rc.conf</filename> zal <command>natd -interface
	  fxp0</command> draaien tijdens het opstarten.  Dit kan ook
	handmatig worden gedraaid.</para>

      <note>
	<para>Het is ook mogelijk om een instellingenbestand voor
	  &man.natd.8; te gebruiken als er teveel opties zijn om door te
	  geven.  In dit geval dient het instellingenbestand te worden
	  gedefinieerd door de volgende regel aan
	  <filename>/etc/rc.conf</filename> toe te voegen:</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<para>Het bestand <filename>/etc/natd.conf</filename> zal een
	  lijst met instelopties bevatten, één per regel.
	  Het geval in de volgende sectie bijvoorbeeld zal het volgende
	  bestand gebruiken:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcpc 192.168.0.3:80 80</programlisting>

	<para>Raadpleeg voor meer informatie over het
	  instellingenbestand het gedeelte over de optie
	  <option>-f</option> van de hulppagina &man.natd.8;.</para>
      </note>

      <para>Elke machine en interface achter het LAN dient een IP-adres
	in de privé-netwerkruimte toegewezen te krijgen zoals
	gedefinieerd in <link xlink:href="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</link>
	en een standaard gateway van het interne IP-adres van de
	<application>natd</application>-machine hebben.</para>

      <para>Bijvoorbeeld, cliënt <systemitem>A</systemitem> en
	<systemitem>B</systemitem> achter het LAN hebben IP-adressen <systemitem class="ipaddress">192.168.0.2</systemitem> en <systemitem class="ipaddress">192.168.0.3</systemitem>, terwijl de LAN-interface
	van de natd-machine IP-adres <systemitem class="ipaddress">192.168.0.1</systemitem> heeft.  De standaard
	gateway van cliënt <systemitem>A</systemitem> en
	<systemitem>B</systemitem> dient ingesteld te worden op die van de
	<application>natd</application>-machine, <systemitem class="ipaddress">192.168.0.1</systemitem>.  Voor de externe, of
	Internet-interface van de
	<application>natd</application>-machine zijn geen speciale
	wijzigingen nodig om &man.natd.8; te laten werken.</para>
    </sect2>

    <sect2 xml:id="network-natdport-redirection">
      <title>Poorten omleiden</title>

      <para>Het nadeel van &man.natd.8; is dat de LAN-cliënten
	niet vanaf het Internet toegankelijk zijn.  Cliënten op het
	LAN kunnen uitgaande verbinden naar de wereld maken maar kunnen
	geen inkomende verbindingen ontvangen.  Dit vormt een probleem
	wanneer geprobeerd wordt om Internetdiensten op een van de
	LAN-cliëntmachines te draaien.  Een eenvoudige om dit te
	omzeilen is om bepaalde Internetpoorten op de
	<application>natd</application>-machine om te leiden naar een
	LAN-cliënt.</para>

      <para>Bijvoorbeeld, er draait een IRC-server op cliënt
	<systemitem>A</systemitem>, en er draait een webserver op cliënt
	<systemitem>B</systemitem>.  Om dit goed te laten werken, dienen
	verbindingen die worden ontvangen op poorten 6667 (IRC) en 80
	(web) te worden omgeleid naar de respectievelijke
	machines.</para>

      <para>De optie <option>-redirect_port</option> dient aan
	&man.natd.8; met de juiste opties te worden doorgegeven.  De
	syntaxis is als volgt:</para>

      <programlisting>     -redirect_port proto doelIP:doelPOORT[-doelPOORT]
                 [aliasIP:]aliasPOORT[-aliasPOORT]
                 [verIP[:verrePOORT[-verrePOORT]]]</programlisting>

      <para>In het bovenstaand voorbeeld dienen de argumenten te
	zijn:</para>

      <programlisting>     -redirect_port tcp 192.168.0.2:6667 6667
-redirectport tcp 192.168.0.3:80 80</programlisting>

      <para>Dit zal de juiste <emphasis>tcp</emphasis>-poorten naar de
	LAN-cliënt-machines omleiden.</para>

      <para>Het argument <option>-redirect_port</option> kan worden
	gebruikt om poortbereiken over individuele poorten aan te geven.
	Bijvoorbeeld, <replaceable>tcp 192.168.0.2:2000-3000
	  2000-3000</replaceable> zal alle verbindingen die op poorten
	2000 tot 3000 worden ontvangen omleiden naar poorten 2000 tot
	3000 op cliënt <systemitem>A</systemitem>.</para>

      <para>Deze opties kunnen worden gebruikt wanneer &man.natd.8;
	direct wordt gedraaid, wanneer ze zijn geplaatst in de optie
	<literal>natd_flags=""</literal> van
	<filename>/etc/rc.conf</filename>, of wanneer ze via een
	instellingenbestand worden doorgegeven.</para>

      <para>Raadpleeg voor meer instelopties &man.natd.8;.</para>
    </sect2>

    <sect2 xml:id="network-natdaddress-redirection">
      <title>Adressen omleiden</title>

      <indexterm><primary>adressen omleiden</primary></indexterm>

      <para>Adressen omleiden is handig wanneer er verschillende
	IP-adressen beschikbaar zijn, maar ze op één
	machine moeten zitten.  Hiermee kan &man.natd.8; aan elke
	LAN-cliënt een eigen extern IP-adres toewijzen.  Vervolgens
	overschrijft &man.natd.8; de uitgaande pakketten van de
	LAN-cliënten met het juiste IP-adres en leidt het al het
	binnenkomende verkeer op dat ene IP-adres terug naar de
	specifieke LAN-cliënt.  Dit staat ook bekend als statisch
	NAT.  Bijvoorbeeld, de IP-adressen <systemitem class="ipaddress">128.1.1.1</systemitem>, <systemitem class="ipaddress">128.1.1.2</systemitem>, en <systemitem class="ipaddress">1281.2..3</systemitem> behoren toe aan de
	<application>natd</application> gateway-machine.  <systemitem class="ipaddress">128.1.1.1</systemitem> kan gebruikt worden als het
	externe IP-adres van de <application>natd</application>
	gateway-machine, terwijl <systemitem class="ipaddress">128.1.1.2</systemitem> en <systemitem class="ipaddress">128.1.1.3</systemitem> terug worden gestuurd naar
	de LAN-cliënten <systemitem>A</systemitem> en
	<systemitem>B</systemitem>.</para>

      <para>De syntaxis van <option>-redirect_address</option> is als
	volgt:</para>

      <programlisting>-redirect_address lokaalIP publiekIP</programlisting>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>lokaalIP</entry>

	      <entry>Het interne IP-adres van de LAN-cliënt.</entry>
	    </row>

	    <row>
	      <entry>publiekIP</entry>

	      <entry>Het externe IP-adres overeenkomend met de
		LAN-cliënt.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>In het voorbeeld zou dit argument zijn:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Net zoals <option>-redirect_port</option> worden ook deze
	argumenten geplaatst in de optie
	<literal>natd_flags=""</literal> van
	<filename>/etc/rc.conf</filename>, of doorgegeven via een
	instellingenbestand.  Met adresomleiding is het omleiden van
	poorten niet nodig aangezien alle gegevens die op een bepaald
	IP-adres worden ontvangen worden omgeleidt.</para>

      <para>Het externe IP-adres op de <application>natd</application>
	machine dient actief en naar een externe interface gealiased te
	zijn.  In &man.rc.conf.5; staat hoe dit te doen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-ipv6">
    <info><title>IPv6</title>
      <authorgroup>
	<author><personname><firstname>Aaron</firstname><surname>Kaplan</surname></personname><contrib>Origineel geschreven door </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geherstructureerd en toegevoegd door </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Brad</firstname><surname>Davis</surname></personname><contrib>Uitgebreid door </contrib></author>
      </authorgroup>
    </info>

    

    <para>IPv6 (ook bekend als IPng <quote>IP next generation</quote>)
      is de nieuwe versie van het welbekende IP-protocol (ook bekend als
      <acronym>IPv4</acronym>).  Net zoals de andere huidige
      *BSD-systemen, bevat &os; de referentie-implementatie van KAME
      IPv6.  Het &os;-systeem wordt dus geleverd met alles wat nodig is
      om met IPv6 te experimenteren.  Deze sectie richt zich op het
      ingesteld en draaiend krijgen van IPv6.</para>

    <para>In de vroege jaren 1990 werden mensen zich bewust van de snel
      krimpende adresruimte van IPv4.  De uitbreidingssnelheid van het
      Internet baarde twee grote zorgen:</para>

    <itemizedlist>
      <listitem>
	<para>Geen adresruimte meer.  Tegenwoordig is dit niet zo'n
	  probleem meer aangezien RFC1918 voor privé-adresruimte
	  (<systemitem class="ipaddress">10.0.0.0/8</systemitem>,
	  <systemitem class="ipaddress">172.16.0.0/12</systemitem>, en
	  <systemitem class="ipaddress">192.168.0.0/16</systemitem>) en Network
	  Address Translation (NAT) worden gebruikt.</para>
      </listitem>

      <listitem>
	<para>De regels in de routeertabellen werden te groot.  Dit is
	  tegenwoordig nog steeds een probleem.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 behandelt deze en vele andere zaken:</para>

    <itemizedlist>
      <listitem>
	<para>128-bits adresruimte.  Met andere woorden, er zijn
	  theoretisch
	  340.282.366.920.938.463.463.374.607.431.768.211.456 adressen
	  beschikbaar.  Dit betekent dat er ongeveer 6,67 * 10^27
	  IPv6-adressen per vierkante meter op onze planeet beschikbaar
	  zijn.</para>
      </listitem>

      <listitem>
	<para>Routers zullen alleen netwerkaggregatie-adressen in hun
	  routeertabellen opslaan en dus de gemiddelde ruimte van een
	  routeertabel verkleinen tot 8192 regels.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 heeft ook vele andere nuttige eigenschappen zoals:</para>

    <itemizedlist>
      <listitem>
	<para>Automatische adresconfiguratie (<link xlink:href="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</link>)</para>
      </listitem>

      <listitem>
	<para>Anycast-adressen
	  (<quote>ééen-van-velen</quote>)</para>
      </listitem>

      <listitem>
	<para>Verplichte multicast-adressen</para>
      </listitem>

      <listitem>
	<para>IPsec (IP security)</para>
      </listitem>

      <listitem>
	<para>Versimpelde structuur van de headers</para>
      </listitem>

      <listitem>
	<para>Mobiele <acronym>IP</acronym></para>
      </listitem>

      <listitem>
	<para>Overgangsmechanismen voor IPv6 naar IPv4</para>
      </listitem>
    </itemizedlist>

    <para>Bekijk voor meer informatie:</para>

    <itemizedlist>
      <listitem>
	<para>IPv6-overzicht op <link xlink:href="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</link></para>
      </listitem>

      <listitem>
	<para><link xlink:href="http://www.kame.net">KAME.net</link></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Achtergrond over IPv6 adressen</title>

      <para>Er zijn verschillende soorten IPv6-adressen: unicast,
	anycast, en multicast.</para>

      <para>Unicast-adressen zijn de bekende adressen.  Een pakket dat
	naar een unicast-adres wordt verzonden arriveert precies op de
	interface dat bij dat adres hoort.</para>

      <para>Anycast-adressen zijn syntactisch niet van unicast-adressen
	te onderscheiden maar ze adresseren een groep interfaces.  Een
	pakket dat bestemd is voor een anycast-adres zal bij de
	dichtstbijzijnde interface arriveren (in router-metrieken).
	Anycast-adressen mogen alleen door routers worden
	gebruikt.</para>

      <para>Multicast-adressen identificeren een groep interfaces.  Een
	pakket dat bestemd is voor en multicast-adres zal bij alle
	interfaces die bij de multicast-groep horen arriveren.</para>

      <note>
	<para>Het broadcast-adres van IPv4 (gewoonlijk <systemitem class="ipaddress">xxx.xxx.xxx.255</systemitem>) wordt in IPv6 met
	  multicast-adressen uitgedrukt.</para>
      </note>

      <table frame="none">
	<title>Gereserveerde IPv6-adressen</title>

	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry>IPv6-adres</entry>

	      <entry>Prefixlengte (bits)</entry>

	      <entry>Beschrijving</entry>

	      <entry>Opmerkingen</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><systemitem>::</systemitem></entry>

	      <entry>128 bits</entry>

	      <entry>niet gespecificeerd</entry>

	      <entry>cf. <systemitem class="ipaddress">0.0.0.0</systemitem> in IPv4</entry>
	    </row>

	    <row>
	      <entry><systemitem>::1</systemitem></entry>

	      <entry>128 bits</entry>

	      <entry>teruglusadres</entry>

	      <entry>cf. <systemitem class="ipaddress">127.0.0.1</systemitem> in
		IPv4</entry>
	    </row>

	    <row>
	      <entry><systemitem>::00:xx:xx:xx:xx</systemitem></entry>

	      <entry>96 bits</entry>

	      <entry>ingebouwd IPv4</entry>

	      <entry>De laagste 32 bits zijn het IPv4-adres.  Ook
		<quote>IPv4 compatibel IPv6-adres</quote> genoemd.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::ff:xx:xx:xx:xx</systemitem></entry>

	      <entry>96 bits</entry>

	      <entry>IPv4-afgebeeld IPv6-adres</entry>

	      <entry>De laagste 32 bits zijn het IPv4-adres.  Voor hosts
		die geen IPv6 ondersteunen.</entry>
	    </row>

	    <row>
	      <entry><systemitem>fe80::</systemitem> -
		<systemitem>feb::</systemitem></entry>

	      <entry>10 bits</entry>

	      <entry>link-lokaal</entry>

	      <entry>cf. teruglusadres in IPv4</entry>
	    </row>

	    <row>
	      <entry><systemitem>fec0::</systemitem> -
		<systemitem>fef::</systemitem></entry>

	      <entry>10 bits</entry>

	      <entry>site-lokaal</entry>

	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><systemitem>ff::</systemitem></entry>

	      <entry>8 bits</entry>

	      <entry>multicast</entry>

	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><systemitem>001</systemitem> (base 2)</entry>

	      <entry>3 bits</entry>

	      <entry>globale unicast</entry>

	      <entry>Alle globale unicast-adressen worden vanuit deze
		pool toegewezen.  De eerste 3 bits zijn
		<quote>001</quote>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2>
      <title>IPv6-adressen lezen</title>

      <para>De canonieke vorm wordt weergegeven als: <systemitem>x:x:x:x:x:x:x:x</systemitem>, waarbij elke
	<quote>x</quote> een 16-bits hexadecimale waarde is.
	Bijvoorbeeld <systemitem>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</systemitem></para>

      <para>Vaak bevat een adres lange deelstrings van allen nullen,
	daarom kan per adres één zo'n deelstring worden
	afgekort als <quote>::</quote>.  Ook kunnen maximaal drie
	voorlopende <quote>0</quote>'s per hexadecimaal viertal worden
	weggelaten.  Bijvoorbeeld, <systemitem>fe80::1</systemitem> komt overeen met de canonieke
	vorm <systemitem>fe80:0000:0000:0000:0000:0000:0000:0001</systemitem>.</para>

      <para>Een derde vorm is het schrijven van de laatste 32 bits in de
	bekende (decimale) IPv4-stijl met punten <quote>.</quote> als
	scheidingstekens.  Bijvoorbeeld, <systemitem>2002::10.0.0.1</systemitem> komt overeen met de
	(hexadecimale) canonieke representatie <systemitem>2002:0000:0000:0000:0000:0000:0a00:0001</systemitem>
	wat weer hetzelfde is als <systemitem>2002::a00:1</systemitem>.</para>

      <para>Op dit punt dient de lezer het volgende te begrijpen:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
        ether 00:00:21:03:08:e1
	media: Ethernet autoselect (100baseTX )
        status: active</programlisting>

      <para><systemitem>fe80::200:21ff:fe03:8e1%rl0</systemitem>
	is een automatisch ingesteld link-lokaal adres.  Het is als deel
	van de automatische instelling vanuit het MAC-adres
	aangemaakt.</para>

      <para>Kijk voor verdere informatie over de structuur van
	IPv6-adressen op <link xlink:href="http://www.ietf.org/rfc/rfc3513.txt">RFC3513</link>.</para>
    </sect2>

    <sect2>
      <title>Verbinding krijgen</title>

      <para>Er zijn momenteel vier manieren om met andere IPv6-hosts en
	-netwerken te verbinden:</para>

      <itemizedlist>
	<listitem>
	  <para>Neem contact op met de Internetprovider om te zien of ze
	    al IPv6 aanbieden.</para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.sixxs.net">SixXS</link> biedt
	    wereldwijd tunnels met eindpunten aan.</para>
	</listitem>

	<listitem>
	  <para>Tunnelen via 6-naar-4 (<link xlink:href="http:///www.ietf.org/rfc/rfc3608.txt">RFC3068</link>)</para>
	</listitem>

	<listitem>
	  <para>Gebruik de poort <package>net/freenet6</package> indien er een
	    inbelverbinding wordt gebruikt.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>DNS in de IPv6-wereld</title>

      <para>Er waren twee soorten DNS-records voor IPv6.  De IETF heeft
	A6-records overbodig verklaard.  AAAA-records zijn nu de
	standaard.</para>

      <para>AAAA-records gebruiken gaat rechttoe-rechtaan.  Wijs de
	hostnaam toe aan het nieuwe IPv6-adres dat net ontvangen is door
	het volgende aan de DNS-bestand voor primaire zones toe te
	voegen:</para>

      <programlisting>MIJNHOSTNAAM          AAAA    MIJNIPv6ADRES</programlisting>

      <para>Vraag het aan de <acronym>DNS</acronym>-provider indien de
	<acronym>DNS</acronym>-zones niet zelf worden geserveerd.  De
	huidige versies van <application>bind</application> (versie 8.3
	en 9) en <package>dns/djbdns</package> (met de
	IPv6-patch) ondersteunen AAAA-records.</para>
    </sect2>

    <sect2>
      <title>De benodigde wijzigingen doorvoeren in
	<filename>/etc/rc.conf</filename></title>

      <sect3>
	<title>IPv6-cliëntinstellingen</title>

	<para>Deze instellingen helpen bij het configureren van een
	  machine in het LAN die als cliënt in plaats van router
	  dienst zal doen.  Om &man.rtsol.8; automatisch de interface
	  tijdens het opstarten te laten configureren op
	  &os;&nbsp;9.<replaceable>X</replaceable> en nieuwer dient het volgende
	  aan <filename>rc.conf</filename> toegevoegd te worden:</para>

	<programlisting>ipv6_prefer="YES"</programlisting>

	<para>Voeg voor &os;&nbsp;8.<replaceable>X</replaceable> en ouder het
	  volgende toe:</para>

	<programlisting>ipv6_enable="YES"</programlisting>

	<para>Voeg het volgende toe om statisch een IP-adres zoals
	  <systemitem>2001:471:1f11:251:290:27ff:fee0:2093</systemitem>
	  aan de interface <filename>fxp0</filename> toe te
	  voegen voor &os;&nbsp;9.<replaceable>X</replaceable>:</para>

	<programlisting>ifconfig_fxp0_ipv6="2001:471:1f11:251:290:27ff:fee0:2093 prefixlen <replaceable>64</replaceable>"</programlisting>

	<note>
	  <para>Zorg ervoor dat <replaceable>prefixlen 64</replaceable> wordt
	    vervangen door de juiste waarde voor het subnet van de
	    computer.</para>
	</note>

	<para>Voeg voor &os;&nbsp;8.<replaceable>X</replaceable> het volgende
	  toe:</para>

	<programlisting>ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"</programlisting>

	<para>Voeg het volgende aan <filename>/etc/rc.conf</filename>
	  toe om een standaardrouter <systemitem>2001:471:1f11:251::1</systemitem> toe te
	  wijzen:</para>

	<programlisting>ipv6_defaultrouter="2001:471:1f11:251::1"</programlisting>
      </sect3>

      <sect3>
	<title>IPv6 router/gateway instellingen</title>

	<para>Deze paragraaf helpt bij het opvolgen van de aanwijzingen
	  die de tunnelprovider heeft gegeven en ze om te zetten in
	  instellingen die blijven na een herstart.  Om de tunnel
	  tijdens het opstarten te herstellen kan het volgende in
	  <filename>/etc/rc.conf</filename> gebruikt worden:</para>

	<para>Noem de generieke tunnelinterfaces die zullen worden
	  ingesteld, bijvoorbeeld <filename>gif0</filename>:</para>

	<programlisting>gif_interfaces="gif0"</programlisting>

	<para>Om de interface met een lokaal eindpunt
	  <replaceable>MIJN_IPv4_ADRES</replaceable> in te stellen naar
	  een ver eindpunt
	  <replaceable>VER_IPv4_ADRES</replaceable>:</para>

	<programlisting>gifconfig_gif0="<replaceable>MIJN_IPv4_ADRES VER_IPv4_ADRES</replaceable>"</programlisting>

	<para>Voeg het volgende toe om het IPv6-adres dat is toegewezen
	  als het eindpunt van de IPv6-tunnel te gebruiken voor
	  &os;&nbsp;9.<replaceable>X</replaceable> en nieuwer:</para>

	<programlisting>ifconfig_gif0_ipv6="inet6 <replaceable>MIJN_TOEGEWEZEN_IPv6_TUNNEL_EINDPUNT_ADRES</replaceable>"</programlisting>

	<para>Voeg voor &os;&nbsp;8.<replaceable>X</replaceable> en eerder het
	  volgende toe:</para>

	<programlisting>ipv6_ifconfig_gif0="<replaceable>MIJN_TOEGEWEZEN_IPv6_TUNNEL_EINDPUNT_ADRES</replaceable>"</programlisting>

	<para>Nu hoeft alleen de standaardroute voor IPv6 ingesteld te
	  worden.  Dit is de andere kant van de IPv6-tunnel:</para>

	<programlisting>ipv6_defaultrouter="<replaceable>MIJN_IPv6_VER_TUNNEL_EINDPUNT_ADRES</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>IPv6-tunnelinstellingen</title>

	<para>Indien de server gebruikt wordt om IPv6 tussen de rest van
	  het netwerk en de wereld te routen, is ook de volgende
	  instelling in <filename>/etc/rc.conf</filename> nodig:</para>

	<programlisting>ipv6_gateway_enable="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Routeradvertentie en automatische hostconfiguratie</title>

      <para>Deze sectie helpt bij het instellen van &man.rtadvd.8; om de
	standaard IPv6-route te adverteren.</para>

      <para>Het volgende is nodig in <filename>/etc/rc.conf</filename>
	om &man.rtadvd.8; aan te zetten:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Het is belangrijk om de interface te specificeren waarop het
	IPv6-routerverzoek plaatsvindt.  Om bijvoorbeeld &man.rtadvd.8;
	te vertellen om <filename>fxp0</filename> te
	gebruiken:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Nu dient het instellingenbestand
	<filename>/etc/rtadvd.conf</filename> aangemaakt te worden.
	Hier is een voorbeeld:</para>

      <programlisting>fxp0:\
	:addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Vervang <filename>fxp0</filename> door de interface die
	gebruikt gaat worden.</para>

      <para>Vervang vervolgens <systemitem>2001:471:1f11:246::</systemitem> met de prefix van uw
	toewijzing.</para>

      <para>Indien een <systemitem class="netmask">/64</systemitem> subnet is
	toegewezen, hoeft er verder niets veranderd te worden.  In
	andere gevallen dient de juiste waarde voor
	<literal>prefixlen#</literal> gebruikt te worden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-atm">
    <info><title>Asynchronous Transfer Mode (ATM)</title>
      <authorgroup>
	<author><personname><firstname>Harti</firstname><surname>Brandt</surname></personname><contrib>Bijgedragen door </contrib></author>
      </authorgroup>
    </info>

    

    <sect2>
      <title>Klassiek IP configureren over ATM (PVCs)</title>

      <para>Klassiek IP over ATM (<acronym>CLIP</acronym>) is de
	eenvoudigste methode om Asynchronous Transfer Mode (ATM) met IP
	te gebruiken.  Het kan met geswitchte verbindingen (SVCs) en met
	permanente verbindingen (PVCs) gebruikt worden.  Deze sectie
	beschrijft hoe een netwerk gebaseerd op PVCs op te zetten.</para>

      <sect3>
	<title>Volledig geschakelde configuraties</title>

	<para>De eerste methode om een <acronym>CLIP</acronym> met PVCs
	  op te zetten is om elke machine met elke andere machine in het
	  netwerk te verbinden via een toegewijde PVC.  Hoewel dit
	  eenvoudig te configureren is, wordt het onpraktisch voor een
	  groter aantal machines.  Dit netwerk gaat ervan uit dat er
	  vier machines in het netwerk zijn, allen verbonden met het
	  <acronym role="Asynchronous Transfer Mode">ATM</acronym>
	  netwerk met een
	  <acronym role="Asynchronous Transfer Network">ATM</acronym>
	  adapterkaart.  De eerste stap is het plannen van de
	  IP-adressen en de
	  <acronym role="Asynchronous Transfer Network">ATM</acronym>
	  verbindingen tussen de machines.  Het volgende wordt
	  gebruikt:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>

	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Host</entry>

		<entry>IP-adres</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem></entry>

		<entry><systemitem class="ipaddress">192.168.173.1</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem></entry>

		<entry><systemitem class="ipaddress">192.168.173.2</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem></entry>

		<entry><systemitem class="ipaddress">192.168.173.3</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostD</systemitem></entry>

		<entry><systemitem class="ipaddress">192.168.173.4</systemitem></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Om een volledig geschakeld net te bouwen is er een
	  ATM-verbinding nodig tussen elk paar machines:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>

	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Machines</entry>

		<entry>VPI.VCI koppel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostB</systemitem></entry>

		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostC</systemitem></entry>

		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostD</systemitem></entry>

		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostC</systemitem></entry>

		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostD</systemitem></entry>

		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem> - <systemitem>hostD</systemitem></entry>

		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>De VPI- en VCI-waarde kunnen aan beide kanten van de
	  verbinding verschillen, maar voor de eenvoud wordt aangenomen
	  dat ze hetzelfde zijn.  Vervolgens dienen de ATM-interfaces op
	  elke host geconfigureerd te worden:</para>

	<screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

	<para>aannemende dat de ATM-interface op alle hosts
	  <filename>hatm0</filename> is.  Nu dienen de PVCs op
	  <systemitem>hostA</systemitem> geconfigureerd te worden (er wordt
	  aangenomen dat ze reeds op de ATM-switches zijn geconfigureerd,
	  raadpleeg de handleiding van de switch hoe dit te doen).</para>

	<screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

	<para>Uiteraard kunnen ook andere verkeerscontracten dan UBR
	  worden gebruikt indien de ATM-adapter die ondersteunt.  In dit
	  geval wordt de naam van het verkeerscontract gevolgd door de
	  parameters van het verkeer.  Hulp voor het gereedschap
	  &man.atmconfig.8; kan verkregen worden met:</para>

	<screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

	<para>of in de hulppagina &man.atmconfig.8;.</para>

	<para>Dezelfde configuratie kan ook bereikt worden via
	  <filename>/etc/rc.conf</filename>.  Voor
	  <systemitem>hostA</systemitem> wordt dit:</para>

<programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

	<para>De huidige toestand van alle <acronym>CLIP</acronym>
	  routes kan worden verkregen met:</para>

	<screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="carp">
    <info><title>Common Address Redundancy Protocol (CARP)</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Bijgedragen door </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>CARP</primary></indexterm>

    <indexterm><primary>Common Address Redundancy Protocol</primary></indexterm>

    <para>Het Common Address Redundancy Protocol, of
      <acronym>CARP</acronym>, staat toe dat meerdere hosts hetzelfde
      <acronym>IP</acronym>-adres gebruiken.  In sommige opstellingen
      wordt dit gebruikt voor beschikbaarheid of loadbalancing.  Hosts
      kunnen ook gescheiden <acronym>IP</acronym>-adressen gebruiken,
      zoals in het voorbeeld dat hier is gegeven.</para>

    <para>Om ondersteuning voor <acronym>CARP</acronym> aan te zetten,
      dient de &os;-kernel herbouwd zoals beschreven in
      <xref linkend="kernelconfig"/> met de volgende
      optie:</para>

    <programlisting>device	carp</programlisting>

    <para>Als alternatief kan de <filename>if_carp.ko</filename>
      module geladen worden tijdens het opstarten.  Voeg de volgende
      regel toe aan <filename>/boot/loader.conf</filename>:</para>

    <programlisting>if_carp_load="YES"</programlisting>

    <para>De functionaliteit van <acronym>CARP</acronym> zou nu
      beschikbaar moeten zijn en kan met verschillende
      <command>sysctl</command>-<acronym>OID</acronym>s worden
      bijgesteld:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>OID</entry>

	    <entry>Beschrijving</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><varname>net.inet.carp.allow</varname></entry>

	    <entry>Accepteer inkomende <acronym>CARP</acronym> pakketten.
	      Staat standaard aan.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.preempt</varname></entry>

	    <entry>Deze optie zet alle <acronym>CARP</acronym>
	      interfaces down op de host wanneer er een down gaat.
	      Staat standaard uit.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.log</varname></entry>

	    <entry>De waarde <literal>0</literal> zet alle logging uit.
	      De waarde <literal>1</literal> zet het loggen van slechte
	      <acronym>CARP</acronym>-pakketten aan.  Waardes hoger dan
	      <literal>1</literal> zet het loggen van
	      toestandsveranderingen van de <acronym>CARP</acronym>
	      interfaces aan.  De standaardwaarde is
	      <literal>1</literal>.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.arpbalance</varname></entry>

	    <entry>Balanceer lokaal netwerkverkeer met
	      <acronym>ARP</acronym>.  Staat standaard uit.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.suppress_preempt</varname></entry>

	    <entry>Een alleen-lezen <acronym>OID</acronym> die de
	      toestand van preëmptie-onderdrukking weergeeft.
	      Preëmptie kan worden onderdrukt wanneer de verbinding
	      op een interface afwezig is.  De waarde
	      <literal>0</literal> betekent dat preëmptie niet
	      onderdrukt is.  Elk probleem verhoogt deze
	      <acronym>OID</acronym>.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>De <acronym>CARP</acronym>-apparaten zelf kunnen met het
      commando <command>ifconfig</command> worden aangemaakt:</para>

    <screen>&prompt.root; <userinput>ifconfig carp0 create</userinput></screen>

    <para>In een echte omgeving hebben deze interfaces unieke
      identificatienummers, bekend als een <acronym>VHID</acronym>,
      nodig.  Dit <acronym>VHID</acronym> of Virtual Host Identification
      zal worden gebruikt om de hosts op het netwerk te
      onderscheiden.</para>

    <sect2>
      <title>CARP gebruiken voor serverbeschikbaarheid</title>

      <para>Eén gebruik van <acronym>CARP</acronym>, zoals boven
	aangegeven, is serverbeschikbaarheid.  Dit voorbeeld geeft
	failover-ondersteuning voor drie hosts, met allemaal een uniek
	<acronym>IP</acronym>-adres en dezelfde webinhoud.  Deze
	machines zullen samen met een Round Robin <acronym>DNS</acronym>
	configuratie dienst doen.  De failover-machine zal twee
	aanvullende <acronym>CARP</acronym>-interfaces hebben,
	één voor elk van de <acronym>IP</acronym>'s van de
	contentservers.  Wanneer er een storing optreedt, zou de
	failover-server het <acronym>IP</acronym>-adres van de falende
	machine moeten oppikken.  Dit betekent dat de storing geheel
	onmerkbaar zou moeten zijn voor de gebruiker.  De
	failover-server heeft dezelfde inhoud en diensten nodig als de
	andere contentservers waarvoor het moet invallen.</para>

      <para>De twee machines dienen identiek geconfigureerd te worden
	op de gegeven hostnamen en <acronym>VHID</acronym>s na.  Dit
	voorbeeld noemt deze machines respectievelijk
	<systemitem>hosta.example.org</systemitem> en
	<systemitem>hostb.example.org</systemitem>.  Ten eerste dienen de
	benodigde regels voor een <acronym>CARP</acronym>-configuratie
	aan <filename>rc.conf</filename> te worden toegevoegd.  Voor
	<systemitem>hosta.example.org</systemitem> dient het bestand
	<filename>rc.conf</filename> de volgende regels te bevatten:</para>

      <programlisting>hostname="hosta.example.org"
ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"</programlisting>

      <para>Op <systemitem>hostb.example.org</systemitem> dienen de volgende
	regels in <filename>rc.conf</filename> te staan:</para>

      <programlisting>hostname="hostb.example.org"
ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"</programlisting>

      <note>
	<para>Het is erg belangrijk dat de wachtwoorden die met de optie
	  <option>pass</option> aan <command>ifconfig</command> gegeven
	  zijn, identiek zijn.  De <filename>carp</filename>
	  apparaten zullen alleen luisteren naar en advertenties
	  accepteren van machines met het juiste wachtwoord.  Het
	  <acronym>VHID</acronym> dient ook verschillend te zijn voor
	  elke machine.</para>
      </note>

      <para>De derde machine,
	<systemitem>provider.example.org</systemitem>, dient voorbereidt te
	worden op het afhandelen van failover van beide hosts.  Deze
	machine heeft twee <filename>carp</filename> apparaten nodig,
	één om elke host af te handelen.  De juiste
	instelregels voor <filename>rc.conf</filename> zullen ongeveer
	gelijk zijn aan de volgende:</para>

      <programlisting>hostname="provider.example.org"
ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"</programlisting>

      <para>Met twee <filename>carp</filename> apparaten is
	<systemitem>provider.example.org</systemitem> in staat om het
	<acronym>IP</acronym>-adres van de andere machine op te pikken
	wanneer de ene niet meer antwoordt.</para>

      <note>
	<para>De standaard &os;-kernel <emphasis>kan</emphasis>
	  preëmptie geactiveerd hebben.  In dat geval hoeft
	  <systemitem>provider.example.org</systemitem> het
	  <acronym>IP</acronym>-adres niet terug te geven aan de
	  originele contentserver.  In dit geval kan het nodig zijn dat
	  een beheerder handmatig het IP terug aan de meester moet geven.
	  Het volgende commando dient op
	  <systemitem>provider.example.org</systemitem> gegeven te worden:</para>

	<screen>&prompt.root; <userinput>ifconfig carp0 down &amp;&amp; ifconfig carp0 up</userinput></screen>

	<para>Dit dient gedaan te worden op de
	  <filename>carp</filename> interface die met de juiste
	  host overeenkomt.</para>
      </note>

      <para>Op dit moment dient <acronym>CARP</acronym> volledig actief
	en beschikbaar voor testen te zijn.  Voor het testen dienen
	òfwel het netwerken herstart te worden, òf de
	machines dienen opnieuw opgestart te worden.</para>

      <para>Meer informatie is altijd beschikbaar in de hulppagina
	&man.carp.4;</para>
    </sect2>
  </sect1>
</chapter>
