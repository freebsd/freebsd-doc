<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$

     %SOURCE%	en_US.ISO8859-1/books/handbook/config/chapter.sgml
     %SRCID%	1.244
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschreven door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Naar een tutorial van </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Tevens gebaseerd op tuning(7) door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Danny</firstname>
	<surname>Pansters</surname>
	<contrib>Vertaald door </contrib>
      </author>
      <author>
	<firstname>Ren&eacute;</firstname>
	<surname>Ladan</surname>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Instellingen en optimalisatie</title>

  <sect1 id="config-synopsis">
    <title>Overzicht</title>

    <indexterm><primary>systeeminstellingen</primary></indexterm>

    <indexterm><primary>systeemoptimalisatie</primary></indexterm>

    <para>Systeeminstellingen zijn een belangrijk aspect van &os;.
      Correcte instellingen helpen moeilijkheden bij toekomstige
      upgrades te voorkomen.  In dit hoofdstuk wordt het instellen van
      &os; beschreven, alsmede een aantal prestatiebevorderende
      maatregelen waarmee een &os; systeem geoptimaliseerd kan
      worden.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>Hoe effici&euml;nt om te gaan met bestandssystemen en
	  wisselpartities;</para>
      </listitem>

      <listitem>
	<para>De grondbeginselen van het <filename>rc.conf</filename>
	  instellingensysteem en van het opstarten van toepassingen
	  (diensten) met
	  <filename class="directory">/usr/local/etc/rc.d</filename>;</para>
      </listitem>

      <listitem>
	<para>Hoe een netwerkkaart ingesteld en getest wordt;</para>
      </listitem>

      <listitem>
	<para>Hoe virtuele hosts op netwerkapparatuur ingesteld
	  worden;</para>
      </listitem>

      <listitem>
	<para>Hoe de instellingenbestanden in <filename
	    class="directory">/etc</filename> gebruikt worden;</para>
      </listitem>

      <listitem>
	<para>Hoe &os; geoptimaliseerd kan worden met
	  <command>sysctl</command>-variabelen;</para>
      </listitem>

      <listitem>
	<para>Hoe schijfprestaties te verbeteren en hoe
	  kernelbeperkingen gewijzigd kunnen worden.</para>
      </listitem>
    </itemizedlist>

    <para>Veronderstelde voorkennis:</para>

    <itemizedlist>
      <listitem>
	<para>De grondbeginselen van &unix; en &os; (<xref
	    linkend="basics">) begrijpen;</para>
      </listitem>

      <listitem>
	<para>Bekend zijn met de grondbeginselen van kernelinstellingen
	  en compilatie (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Initi&euml;le instellingen</title>

    <sect2>
      <title>Partitioneren</title>

      <indexterm><primary>partitioneren</primary></indexterm>

      <indexterm><primary><filename class="directory">/etc</filename></primary></indexterm>

      <indexterm><primary><filename class="directory">/var</filename></primary></indexterm>

      <indexterm><primary><filename class="directory">/usr</filename></primary></indexterm>

      <sect3>
	<title>Basispartities</title>

	<para>Bij het aanmaken van bestandssystemen met &man.bsdlabel.8;
	  of &man.sysinstall.8; is het van belang dat op een harde
	  schijf de gegevensoverdracht het snelst is aan de buitenste
	  sporen en het langzaamst aan de binnenste.  Kleinere en
	  veelgebruikte bestandssystemen kunnen daarom het beste aan de
	  buitenkant van de schijf geplaatst worden, terwijl grotere
	  partities als <filename class="directory">/usr</filename> meer naar de
	  binnenkant van de schijf geplaatst kunnen worden.  Het is een
	  goed idee om partities aan te maken in deze of gelijksoortige
	  volgorde: root, swap, <filename class="directory">/var</filename>,
	  <filename class="directory">/usr</filename>.</para>

	<para>De grootte van de partitie <filename
	   class="directory">/var</filename> hangt
	  af van de wijze waarop de machine gebruikt gaat worden.  Het
	  bestandssysteem <filename class="directory">/var</filename> wordt
	  gebruikt voor onder meer postbussen, logbestanden en printergegevens
	  en -wachtrijen.  Postbussen en logbestanden kunnen onverwacht
	  groot worden, afhankelijk van het aantal systeemgebruikers en
	  de bewaarduur van logbestanden.  De meeste gebruikers zullen
	  zelden meer dan ongeveer een gigabyte aan vrije schijfruimte
	  op <filename class="directory">/var</filename> nodig hebben.</para>

	<note>
	  <para>Er zijn een aantal gevallen waar een grote hoeveelheid
	    ruimte in <filename class="directory">/var/tmp</filename> nodig is.
	    Wanneer er nieuwe software wordt ge&iuml;nstalleerd met
	    &man.pkg.add.1; pakken de pakketprogramma's een tijdelijke
	    kopie van de pakketten uit in <filename
	      class="directory">/var/tmp</filename>.  Grote softwarepakketten,
	    zoals <application>Firefox</application> of
	    <application>OpenOffice</application> kunnen lastig zijn om
	    te installeren wanneer er onvoldoende vrije schijfruimte
	    beschikbaar is onder <filename
	      class="directory">/var/tmp</filename>.</para>
	</note>

	<para>De partitie <filename class="directory">/usr</filename> bevat veel
	  van de benodigde systeembestanden, waaronder de &man.ports.7;
	  collectie (aanbevolen) en de broncode (optioneel).  Beide zijn
	  optioneel tijdens de installatie, maar we raden voor deze
	  partitie tenminste 2 gigabyte aan.</para>

	<para>Het is verstandig rekening te houden met de vereiste
	  schijfruimte bij het kiezen van partitiegroottes.  Als in een
	  partitie onvoldoende vrije schijfruimte is, terwijl een andere
	  vrijwel niet gebruikt wordt, is dat een vervelend en niet
	  optimaal oplosbaar probleem.</para>

	<note>
	  <para>&man.sysinstall.8;'s <literal>Auto-defaults</literal>
	    partitiekeuze kan in de ervaring van sommige gebruikers
	    mogelijk te kleine <filename class="directory">/var</filename> en
	    <filename class="directory">/</filename> partities opleveren.
	    Partitioneren moet verstandig en niet te zuinig gebeuren.</para>
	</note>
      </sect3>

      <sect3 id="swap-design">
	<title>Wisselpartities (swap)</title>

	<indexterm><primary>swap grootte</primary></indexterm>

	<indexterm><primary>wisselpartitie</primary></indexterm>

	<indexterm><primary>wisselpartitiegrootte</primary></indexterm>

	<para>De vuistregel is dat het wisselbestand ongeveer het
	  dubbele van de grootte van het systeemgeheugen (RAM) moet
	  zijn.  Als de machine bijvoorbeeld 128&nbsp;megabytes geheugen
	  heeft, kan het beste een wisselbestand van (tenminste)
	  256&nbsp;megabytes gebruikt worden.  Minder dan
	  256&nbsp;megabytes swap is in dit geval af te raden.  Systemen
	  met weinig geheugen kunnen overigens beter functioneren met
	  meer swap.  Ook is het verstandig rekening te houden met
	  eventuele geheugenuitbreiding in de toekomst.  Bovendien zijn
	  de VM paging-algoritmen van de kernel zo afgestemd dat ze het
	  beste presteren bij een wisselbestand van tenminste tweemaal
	  de grootte van het geheugen.  Een te kleine swap kan dus
	  ineffici&euml;nties in de VM-code tot gevolg hebben en
	  mogelijk problemen veroorzaken als het systeemgeheugen
	  uitgebreid wordt.</para>

	<para>Op grotere systemen met meerdere SCSI-schijven (of
	  meerdere IDE-schijven op verschillende controllers) is het aan
	  te raden om op elke schijf een wisselpartitie in te stellen
	  (dit kan tot en met vier schijven), elk met ongeveer dezelfde
	  grootte.  De kernel kan met arbitraire groottes werken, maar
	  interne datastructuren schalen tot viermaal de grootste
	  swappartitie.  De kernel kan de beschikbare ruimte voor het
	  wisselbestand het meest optimaal indelen als de partities
	  ongeveer even groot zijn.  Een grote swap is prima, ook als ze
	  zelden gebruikt wordt.  Zo kan het gemakkelijker zijn om een
	  (uit de hand gelopen) proces dat het systeem grotendeels bezet
	  houdt te be&euml;indigen, voordat er opnieuw opgestart moet
	  worden.</para>
      </sect3>

      <sect3>
	<title>Waarom partitioneren?</title>

	<para>Waarom niet &eacute;&eacute;n enkele grote partitie
	  gebruiken?  Er zijn verscheidene redenen waarom dit niet zo'n
	  goed idee is.  De verschillende partities hebben hun eigen
	  karakteristieke operationele gedrag en vereisten.  Door ze te
	  scheiden zijn er betere mogelijkheden om het systeem te
	  optimaliseren.  Vanaf de <filename class="directory">/</filename> en
	  <filename class="directory">/usr</filename> partities wordt
	  bijvoorbeeld vooral gelezen en er wordt weinig naar geschreven,
	  terwijl er in <filename class="directory">/var</filename> en
	  <filename class="directory">/var/tmp</filename> zowel veel gelezen
	  als geschreven wordt.</para>

	<para>Door een systeem goed te partitioneren wordt vermeden dat
	  fragmentatie die optreedt in de kleinere partities met veel
	  schrijfactiviteit doorsijpelt naar partities die vooral
	  lees-intensief zijn.  Door schrijf-intensieve partities aan
	  het begin van de schijf te plaatsen, zijn de prestaties wat
	  betreft invoer/uitvoer het beste is daar waar het het meest
	  nodig is.  Ofschoon er natuurlijk ook de best mogelijke
	  in/uit prestaties wenselijk zijn in de grotere partities,
	  weegt het plaatsen van deze bestandssystemen aan het begin van
	  de schijf niet tegen de voordelen van het plaatsen van
	  <filename class="directory">/var</filename> aan het begin van de
	  schijf (na root en swap) voor de totale snelheid van het systeem.
	  Tenslotte zijn er veiligheidsoverwegingen.  Een compacte en nette
	  rootpartitie die vrijwel alleen-lezen is, heeft een betere
	  kans om een nare crash te overleven.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Hoofdinstellingen</title>

    <indexterm>
      <primary>rc bestanden</primary>

      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>De voornaamste lokatie voor systeeminstellingen is
      <filename>/etc/rc.conf</filename>.  Dit bestand bevat een scala
      aan instellingen, die gebruikt wordt om het systeem in te stellen
      bij het opstarten.  De naam impliceert dit al.  Het is informatie
      voor de <filename>rc*</filename> bestanden (rc staat voor
      <quote>resource configuration</quote> of broninstellingen).</para>

    <para>De systeembeheerder wordt geacht regels toe te voegen aan
      <filename>rc.conf</filename> om de standaardinstellingen uit
      <filename>/etc/defaults/rc.conf</filename> aan te passen.  Het
      standaardbestand moet niet letterlijk gekopi&euml;erd worden naar
      <filename class="directory">/etc</filename>.  Het bevat standaardwaardes
      en is niet bedoeld als voorbeeld.  Alle wijzigingen die specifiek zijn
      voor een systeem horen in <filename>/etc/rc.conf</filename>
      thuis.</para>

    <para>In een clusterscenario is het nuttig om systeemspecifieke
      instellingen te scheiden van algemene instellingen die voor het
      hele cluster gelden.  Hiervoor kunnen een aantal strategie&euml;n
      worden gebruikt.  De aanbevolen benadering is om gedeelde
      instellingen in een ander bestand te plaatsen, zoals
      <filename>/etc/rc.conf.site</filename> en dit in te voegen in
      <filename>/etc/rc.conf</filename>, wat verder alleen
      systeemspecifieke informatie bevat.</para>

    <para>Aangezien <filename>rc.conf</filename> gelezen wordt door
      &man.sh.1; is dit eenvoudig te bereiken:</para>

    <itemizedlist>
      <listitem>
	<para>rc.conf:</para>

	<programlisting>. /etc/rc.conf.site
 hostname="node15.example.com"
 network_interfaces="fxp0 lo0"
 ifconfig_fxp0="inet 10.1.1.1"</programlisting>
      </listitem>

      <listitem>
	<para>rc.conf.site:</para>

	<programlisting>defaultrouter="10.1.1.254"
saver="daemon"
blanktime="100"</programlisting>
      </listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> kan dan naar elk systeem
      gedistribueerd worden met <command>rsync</command> of een
      gelijksoortig programma, terwijl <filename>rc.conf</filename>
      uniek blijft.</para>

    <para>Het actualiseren van het systeem met &man.sysinstall.8; of
      <command>make world</command> overschrijft
      <filename>rc.conf</filename> niet, zodat de bestaande
      systeeminstellingen niet verloren gaan.</para>
  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Toepassingen instellen</title>

    <para>Ge&iuml;nstalleerde toepassingen hebben meestal hun eigen
      instellingenbestanden, met hun eigen syntaxis, etc.  Het is van
      belang deze bestanden apart te houden van het basissysteem, zodat
      ze makkelijk gelokaliseerd kunnen worden en beheerd kunnen worden
      met de hulpmiddelen voor pakketbeheer.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Deze bestanden worden meestal ge&iuml;nstalleerd in
      <filename class="directory">/usr/local/etc</filename>.  Als een toepassing
      een uitgebreide verzameling bestanden voor instellingen heeft, wordt
      er een submap voor aangemaakt.</para>

    <para>Bij de installatie van een port of pakket, worden normaliter
      ook voorbeeldbestanden met instellingen ge&iuml;nstalleerd.  Deze
      zijn doorgaans te herkennen aan een toevoegsel
      <filename>.default</filename>.  Als er geen bestaande
      instellingenbestanden voor de toepassing zijn, kunnen ze gemaakt
      worden door de <filename>.default</filename>-bestanden te
      kopi&euml;ren.</para>

    <para>Een voorbeeld is de map
      <filename class="directory">/usr/local/etc/apache</filename>:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Aan de grootte van de bestanden is te zien dat alleen
      <filename>srm.conf</filename> gewijzigd is.  Als later de port
      <application>Apache</application> wordt vernieuwd, wordt dit
      bestand niet overschreven.</para>
  </sect1>

  <sect1 id="configtuning-starting-services">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Bijgedragen door </contrib>
	</author>
      </authorgroup>
    </sect1info>

      <title>Diensten starten</title>

      <indexterm><primary>diensten</primary></indexterm>

      <para>Veel gebruikers kiezen ervoor om software van derden te
	installeren op &os; vanuit de Portscollectie.  In veel gevallen
	is het noodzakelijk om de software dusdanig in te stellen dat
	het opstart tijdens het opstarten van de computer.  Diensten
	zoals <filename role="package">mail/postfix</filename> of
	<filename role="package">www/apache13</filename> zijn slechts
	twee voorbeelden van softwarepakketten die gestart kunnen worden
	tijdens de systeemstart.  In deze paragraaf wordt toegelicht hoe
	software van derde partijen kan worden gestart.</para>

      <para>In &os; worden de meeste diensten, zoals &man.cron.8;, door
	de opstartscripts van het systeem gestart.  Deze scripts kunnen
	verschillen tussen &os; en leverancierversies, echter het meest
	belangrijke aspect om in gedachten te houden is dat hun
	opstartinstellingen verwerkt kunnen worden door simpele
	opstartscripts.</para>

      <sect2>
	<title>Uitgebreide applicatieinstellingen</title>

	<para>Nu &os; <filename>rc.d</filename> heeft, zijn de
	  instellingen van applicaties die mee moeten opstarten
	  versimpeld en rijker aan mogelijkheden.  Door gebruik te maken
	  van de sleutelwoorden die in de paragraaf <link
	    linkend="configtuning-rcd"><filename>rc.d</filename></link>
	  behandeld worden, kunnen applicaties nu starten na andere
	  diensten.  <acronym>DNS</acronym> kan bijvoorbeeld extra
	  opties meekrijgen van <filename>/etc/rc.conf</filename> in
	  plaats van hard ingestelde opties in het opstartscript.  Een
	  basisscript ziet er ongeveer als volgt uit:</para>

	<programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name="utility"
rcvar=`set_rcvar`
command="/usr/local/sbin/utility"

load_rc_config $name

#
# VERANDER DE STANDAARDWAARDEN HIER NIET
# STEL ZE IN IN HET BESTAND /etc/rc.conf
#
utility_enable=${utility_enable-"NO"}
utility_pidfile=${utility_pidfile-"/var/run/utility.pid"}

pidfile="${utility_pidfile}"

run_rc_command "$1"</programlisting>

	<para>Dit script zorgt ervoor dat
	  <application>utility</application> wordt gestart na de pseudodienst
	  <literal>DAEMON</literal>.  Het biedt ook de mogelijkheid voor
	  het instellingen en volgen van het <acronym>PID</acronym> of
	  het proces-<acronym>ID</acronym> bestand.</para>

	<para>Voor deze applicatie kan dan de volgende regel in
	  <filename>/etc/rc.conf</filename> geplaatst worden:</para>

	<programlisting>utility_enable="YES"</programlisting>

	<para>Deze methode maakt het volgende mogelijk: makkelijker
	  commandoregelopties manipuleren, importeren van
	  standaardfuncties uit <filename>/etc/rc.subr</filename>,
	  compatibiliteit met het gereedschap &man.rcorder.8; en het
	  levert makkelijkere configuratie via het bestand
	  <filename>rc.conf</filename>.</para>
    </sect2>

    <sect2>
      <title>Diensten met diensten starten</title>

      <para>Andere diensten, zoals <acronym>POP</acronym>3-server
	daemons, <acronym>IMAP</acronym>, enzovoort, kunnen gestart
	worden door gebruik te maken van &man.inetd.8;.  Daaraan is
	voorafgegaan dat die dienst uit de Portscollectie is
	ge&iuml;stalleerd en dat er een regel met instellingen is
	toegevoegd aan <filename>/etc/inetd.conf</filename> of
	&eacute;&eacute;n van de bestaande niet-actieve regels is
	geactiveerd.  Werken met <application>inetd</application> en
	zijn instellingen wordt uitgebreid toegelicht in de paragraaf
	over <link linkend="network-inetd">inetd</link>.</para>

      <para>In sommige gevallen is het handiger om &man.cron.8; te
	gebruiken om diensten te starten.  Deze aanpak heeft een aantal
	voordelen omdat <command>cron</command> start als de eigenaar
	van <filename>crontab</filename>.  Dit stelt reguliere
	gebruikers in staat om sommige applicaties te starten en te
	onderhouden.</para>

      <para><command>cron</command> levert een unieke optie: in plaats
	van een tijdsspecificatie kan <literal>@reboot</literal>
	gebruikt worden.  Dit zorgt ervoor dat de taak gestart wordt als
	&man.cron.8; gestart wordt, meestal tijdens een
	systeemstart.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><command>cron</command> instellen</title>

    <indexterm>
      <primary>cron</primary>

      <secondary>instellen</secondary>
    </indexterm>

    <para>Een zeer nuttig hulpprogramma in &os; is &man.cron.8;.  De
      daemon <command>cron</command> draait op de achtergrond en
      controleert voortdurend <filename>/etc/crontab</filename>.  Ook
      controleert <command>cron</command> de map
      <filename class="directory">/var/cron/tabs</filename>, op zoek naar nieuwe
      <filename>crontab</filename> bestanden.  Deze
      <filename>crontab</filename> bestanden bevatten informatie over
      specifieke taken die <command>cron</command> moet verrichten op
      gezette tijden.</para>

    <para><command>cron</command> gebruikt twee verschillende soorten
      instellingenbestanden: de systeemcrontab en gebruikerscrontabs.
      Het enige verschil tussen deze twee formaten is het zesde veld.
      In de systeemcrontab is dit de gebruikersnaam die het commando
      uitvoert.  Hierdoor kunnen met de systeemcrontab commando's als
      iedere gebruiker uitgevoerd worden.  In een gebruikerscrontab is
      het zesde veld het uit te voeren commando en alle commando's
      worden uitgevoerd als de gebruiker die de crontab heeft
      aangemaakt.  Dit is een belangrijke veiligheidsmaatregel.</para>

    <note>
      <para>Gebruikerscrontabs geven individuele gebruikers de
	mogelijkheid om bepaalde terugkerende taken automatisch te laten
	uitvoeren zonder dat <username>root</username>-rechten noodig
	zijn.  Commando's in de crontab van een gebruiker worden
	uitgevoerd met de rechten van de eigenaar.</para>

      <para><username>root</username> kan ook een gebruikerscrontab
	aanleggen.  Dit is niet dezelfde als
	<filename>/etc/crontab</filename> (de systeemcrontab).  Omdat er
	al een systeemcrontab is, is het doorgaans niet nodig om een
	gebruikerscrontab voor <username>root</username> te
	maken.</para>
    </note>

    <para><filename>/etc/crontab</filename> (de systeemcrontab) ziet er
      uit als volgt:</para>

    <programlisting># /etc/crontab - root's crontab for &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minuut uur     mdag    maand   wdag    wie     commando <co id="co-field-descr">
#
#
*/5     *       *       *       *       root    /usr/libexec/atrun <co id="co-main">

</programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Zoals in de meeste &os; instellingenbestanden gaat het
	  karakter <literal>#</literal> vooraf aan commentaar.
	  Commentaar wordt gebruikt als uitleg en geheugensteun.
	  Commentaar dient niet vermengd te worden met commando's,
	  anders wordt het commentaar opgevat als deel van het commando.
	  Blanco regels worden genegeerd.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Eerst worden omgevingsvariabelen gedefini&euml;erd.
	  Hoervoor wordt het is-gelijk karakter (<literal>=</literal>)
	  gebruikt.  In het bovenstaande voorbeeld wordt het gebruikt
	  voor de variabelen <envar>SHELL</envar>, <envar>PATH</envar>
	  en <envar>HOME</envar>.  Als de regel <envar>SHELL</envar>
	  ontbreekt, gebruikt <command>cron</command> standaard
	  <command>sh</command> als shell.  Voor de omgevingsvariabele
	  <envar>PATH</envar> bestaat geen standaardwaarde.  Als
	  <envar>PATH</envar> ontbreekt moeten absolute paden gebruikt
	  worden.  Als <envar>HOME</envar> ontbreekt, gebruikt
	  <command>cron</command> de thuismap van de de gebruiker die
	  <command>cron</command> aanroept.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>In deze commentaarregel staan de zeven velden van een
	  crontabdefinitie.  Dit zijn <literal>minuut</literal>,
	  <literal>uur</literal>, <literal>mdag</literal>,
	  <literal>maand</literal>, <literal>wdag</literal>,
	  <literal>wie</literal> en <literal>commando</literal>.  De
	  betekenissen liggen voor de hand: <literal>minuut</literal>
	  is het aantal minuten van het tijdstip waarop het commando
	  moet worden uitgevoerd; <literal>uur</literal> geeft het uur
	  aan; <literal>mdag</literal> staat voor de dag van de maand;
	  <literal>maand</literal> staat voor het maandnummer en
	  <literal>wdag</literal> geeft de dag van de week aan.  Het
	  veld <literal>wie</literal> is bijzonder en bestaat alleen in
	  <filename>/etc/crontab</filename>.  Het geeft aan als welke
	  gebruiker het commando uitgevoerd moet worden.  Een gebruiker
	  die zijn eigen <filename>crontab</filename> installeert,
	  heeft deze optie niet.  Het veld <literal>commando</literal>
	  bevat het uit te voeren commando.</para>
      </callout>

      <callout arearefs="co-main">
	<para>In deze regel worden aan de hierboven besproken opties
	  waarden toegekend.  Er wordt gebruik gemaakt van
	  <literal>*/5</literal> en <literal>*</literal> karakters.
	  Deze betekenen <quote>eerst-laatst</quote> en kunnen gezien
	  worden als <emphasis>telkens</emphasis>.  In deze regel staat
	  dus dat het commando <command>atrun</command> elke vijf
	  minuten moet worden uitgevoerd door <username>root</username>,	  ongeacht welke dag of maand het is.  Meer informatie over
	  <command>atrun</command> staat in &man.atrun.8;.</para>

	<para>Commando's kunnen een willekeurig aantal opties of
	  argumenten meekrijgen.  Als commando's echter meerdere regels
	  nodig hebben moeten deze regels afgebroken worden met een
	  backslash <quote>\</quote> karakter, om aan te geven dat ze op
	  de volgende regel vervolgd worden.</para>
      </callout>
    </calloutlist>

    <para>Dit is de basisopzet voor elk <filename>crontab</filename>
      bestand.  De enige uitzondering is de aanwezigheid van veld zes,
      waar de gebruikersnaam wordt aangegeven.  Dit veld bestaat alleen
      in het systeembestand <filename>/etc/crontab</filename>.  Voor
      <filename>crontab</filename>bestanden van individuele gebruikers
      moet dit veld worden weggelaten.</para>

    <sect2 id="configtuning-installcrontab">
      <title>Een crontab installeren</title>

      <important>
	<para>De onderstaande procedure moet niet gebruikt worden om de
	  systeemcrontab te wijzigen of te installeren.  Er kan een
	  gewone editor gebruikt worden.  <command>cron</command>
	  ziet dat het bestand veranderd is en begint direct met het
	  gebruiken van de nieuwe versie.  <ulink
	    url="&url.books.faq;/admin.html#ROOT-NOT-FOUND-CRON-ERRORS">Deze
	  FAQ vraag</ulink> geeft verdere uitleg.</para>
      </important>

      <para>Om een nieuwe <filename>crontab</filename> te installeren
	moet eerst een bestand in het juiste formaat gemaakt worden en
	daarna moet het geiuml;nstalleerd worden met commando
	<command>crontab</command>:</para>

      <screen>&prompt.root; <userinput>crontab crontabbestand</userinput></screen>

      <para>In dit voorbeeld is <filename>crontabbestand</filename> de
	naam van een eerder gemaakt
	<filename>crontab</filename>-bestand.</para>

      <para>Er bestaat ook een optie om een lijst van
	ge&iuml;nstalleerde <filename>crontab</filename>-bestanden op te
	vragen, namelijk de optie <option>-l</option> van
	<command>crontab</command>.</para>

      <para>Gebruikers die hun eigen crontabbestand willen schrijven
	zonder het gebruik van een sjabloon, kunnen gebruik maken van
	<command>crontab -e</command>.  Dit opent de
	<envar>EDITOR</envar> met een leeg bestand.  Als het bestand
	wordt opgeslagen en de editor wordt afgesloten, wordt het
	bestand automatisch als <filename>crontab</filename>
	ge&iuml;nstalleerd.</para>

      <para>Een gebruikers<filename>crontab</filename> kan verwijderd
	worden door de met <command>crontab</command> de optie
	<option>-r</option> te gebruiken.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-rcd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Gebruik van rc met &os;</title>

    <indexterm><primary>rc.d</primary></indexterm>

    <para>Sinds 2002 gebruikt &os; het NetBSD <filename>rc.d</filename>
      systeem bij het opstarten van het systeem.  Veel van de bestanden
      in <filename class="directory">/etc/rc.d</filename> zijn scripts voor
      basisdiensten die werken met de opties <option>start</option>,
      <option>stop</option> en <option>restart</option>, analoog aan
      hoe diensten die via een port of pakket zijn ge&iuml;nstalleerd
      gestart worden met de scripts in
      <filename>/usr/local/etc/rc.d</filename>.  &man.sshd.8; kan
      bijvoorbeeld als volgt herstart worden:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>Deze procedure is vrijwel gelijk voor andere diensten.
      Uiteraard worden diensten meestal automatisch tijdens het
      opstarten van de computer gestart zoals in &man.rc.conf.5; staat.
      Om de Network Address Translation daemon bij het opstarten te
      laten starten is de volgende regel in
      <filename>/etc/rc.conf</filename> bijvoorbeeld voldoende:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Als er reeds een <literal>natd_enable="NO"</literal> regel is,
      kan <literal>NO</literal> gewoon in <literal>YES</literal>
      veranderd worden.  De rc scripts starten, voor zover nodig,
      automatisch andere afhankelijke diensten.</para>

    <para>Omdat het <filename>rc.d</filename> systeem in eerste
      instantie bedoeld is om diensten te starten en stoppen bij het
      opstarten en afsluiten van het systeem, werken de standaardopties
      <option>start</option>, <option>stop</option> en
      <option>restart</option> alleen als de juiste variabelen in
      <filename>/etc/rc.conf</filename> zijn ingesteld.  Het commando
      <command>sshd restart</command> alleen dan als
      <varname>sshd_enable</varname> de waarde <literal>YES</literal>
      heeft in <filename>/etc/rc.conf</filename>.  Als er een dienst
      gestart, gestopt of herstart moet worden, ongeacht de definities
      in <filename>/etc/rc.conf</filename>, moet het commando
      voorafgegaan worden door <quote>one</quote>.  Dus om
      <command>sshd</command> te herstarten ongeacht
      de instellingen in <filename>/etc/rc.conf</filename>, voldoet het
      volgende commando:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd onerestart</userinput></screen>

    <para>Het is eenvoudig te controleren of een dienst is ingeschakeld
      is in <filename>/etc/rc.conf</filename> door het bijpassende
      <filename>rc.d</filename>-script uit te voeren met de optie
      <option>rcvar</option>.  Voor <command>sshd</command>:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note><para>De tweede regel (<literal># sshd</literal>) is de
	uitvoer van <command>sshd</command>, geen
	<username>root</username>-console.</para></note>

    <para>De optie <option>status</option> wordt gebruikt om vast te
      stellen of een dienst gestart is.  Om bijvoorbeeld te controleren
      of <command>sshd</command> gestart is:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>In sommige gevallen is het ook mogelijk om een dienst te
      herstarten met de optie <option>reload</option>.  Dan wordt er
      getracht een signaal te sturen aan een individuele dienst, waarbij
      de dienst de bestanden met instellingen opnieuw in moet lezen.
      Meestal komt dit neer op het verzenden van het signaal
      <literal>SIGHUP</literal>.  Deze optie wordt niet door alle
      diensten ondersteund.</para>

    <para>Het <application>rc.d</application>-systeem wordt niet alleen
      gebruikt voor netwerkdiensten, maar ook voor het merendeel van de
      systeemstart.  In dit kader is bijvoorbeeld het bestand
      <filename>bgfsck</filename> interessant.  Als dit script wordt
      uitgevoerd, wordt de volgende boodschap getoond:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Dit script wordt dus gebruikt voor bestandssysteemcontrole in
      de achtergrond, hetgeen alleen tijdens de systeemstart
      gebeurt.</para>

    <para>Veel systeemdiensten zijn afhankelijk van andere diensten om
      correct te kunnen functioneren.  Zo starten NIS en andere
      RPC-gebaseerde diensten niet als de dienst
      <command>rpcbind</command> (portmapper) nog niet draait.  Om dit
      te stroomlijnen wordt informatie over afhankelijkheden en andere
      metagegevens ingevoegd in het commentaar bovenaan het
      opstartscript.  Deze commentaarregels worden vervolgens tijdens de
      systeemstart met &man.rcorder.8; verwerkt om zo vast te stellen in
      welke volgorde de systeemdiensten gestart moeten worden.</para>

    <para>De volgende woorden moeten in alle opstartscripts staan (ze
      zijn benodigd door &man.rc.subr.8; om het opstartscript te
      activeren):</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: geeft aan in welke diensten
	  dit bestand voorziet.</para>
      </listitem>

      <listitem>
	<para><literal>REQUIRE</literal>: geeft aan welke andere
	  diensten vereist zijn voor deze dienst.  Dit script wordt
	  uitgevoerd <emphasis>na</emphasis> de aangegeven
	  diensten.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: geeft diensten aan die
	  afhankelijk zijn van deze dienst.  Dit bestand wordt
	  uitgevoerd <emphasis>v&oacute;&oacute;r</emphasis> de
	  aangegeven diensten.</para>
      </listitem>
    </itemizedlist>

    <para>Met deze methode kan een systeembeheerder gemakkelijk
      systeemdiensten besturen, zonder gedoe met
      <quote>runlevels</quote> zoals bij sommige andere &unix;
      systemen.</para>

    <para>Meer informatie over het <filename>rc.d</filename>-systeem
      staat in &man.rc.8; en &man.rc.subr.8;.  Als u ge&iuml;nteresseerd
      bent in het schrijven van uw eigen
      <filename>rc.d</filename>-script of om de huidige scripts te
      verbeteren is wellicht <ulink url="&url.articles.rc-scripting">dit
	artikel</ulink> interessant.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
	 <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Geschreven door </contrib>
	 </author>
      </authorgroup>
    </sect1info>

    <title>Netwerkkaarten instellen</title>

    <indexterm>
      <primary>netwerkkaarten</primary>

      <secondary>instellen</secondary>
    </indexterm>

    <para>Het is tegenwoordig nauwelijks voorstelbaar dat een computer
      geen netwerkverbinding heeft.  Het toevoegen en instellen van een
      netwerkkaart is een gebruikelijke taak voor een
      &os;-beheerder.</para>

    <sect2>
      <title>Het juiste stuurprogramma vinden</title>

      <indexterm>
	<primary>netwerkkaarten</primary>

	<secondary>stuurprogramma</secondary>
      </indexterm>

      <para>Voor het zoeken begint, moet duidelijk zijn om welke kaart
	het gaat, welke chip erop zit en of het een PCI- of ISA-kaart
	is.  &os; ondersteunt vele kaarten.  Op de Hardware
	Compatibiliteitslijst voor de betreffende uitgave staan de
	kaarten die ondersteund worden.</para>

      <para>Als duidelijk is dat een kaart ondersteund wordt, moet
	vastgesteld worden wat het geschikte stuurprogramma is.  In het
	bestand <filename>/usr/src/sys/conf/NOTES</filename> staat een
	lijst van stuurprogramma's voor netwerkinterfaces met wat
	informatie over de ondersteunde chipsets of kaarten.  In geval
	van twijfel biedt de hulppagina voor het stuurprogramma
	(<command>man</command>) vaak uitkomst.  In het algemeen bevat
	deze meer informatie over de ondersteunde hardware en mogelijke
	problemen die kunnen optreden.</para>

      <para>Als een veelgebruikte kaart gebruikt wordt, hoeft meestal
	niet ver gezocht te worden.  Stuurprogramma's voor
	veelvoorkomende netwerkinterfaces zijn al aanwezig in de
	algemene kernel <filename>GENERIC</filename>.  In dat geval
	wordt zo'n kaart al gevonden bij het opstarten, bijvoorbeeld met
	het volgende bericht:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]</screen>

      <para>In dit voorbeeld zitten er twee kaarten in het systeem die
	het stuurprogramma &man.dc.4; gebruiken.</para>

      <para>Als het stuurprogramma voor een NIC geen onderdeel is van de
	kernel <filename>GENERIC</filename>, dan dient het juiste
	stuurprogramma voor die NIC geladen te worden.  Dit kan op twee
	manieren:</para>

      <itemizedlist>
	<listitem>
	  <para>De meest eenvoudige manier is het laden van een
	    kernelmodule voor een netwerkkaart met &man.kldload.8; of
	    automatisch tijdens het opstarten van het systeem door de
	    benodigde regel toe te voegen aan
	    <filename>/boot/loader.conf</filename>.  Niet alle
	    NIC-stuurprogramma's zijn als module beschikbaar.  Zo zijn
	    er bijvoorbeeld geen modules beschikbaar voor
	    ISA-kaarten.</para>
	</listitem>

	<listitem>
	  <para>Ondersteuning voor een kaart kan ook in de kernel
	    gecompileerd worden.  In
	    <filename>/usr/src/sys/conf/NOTES</filename>,
	    <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
	    en de hulppagina van het stuurprogramma is na te lezen wat
	    er in het kernelinstellingenbestand moet staan.  In <xref
	      linkend="kernelconfig"> staat meer informatie over het
	    compileren van een eigen kernel.  Als een netwerkkaart al
	    bij het opstarten wordt herkend door de kernel
	    <filename>GENERIC</filename>, is er geen reden om een andere
	    kernel te bouwen.</para>
	</listitem>
      </itemizedlist>

      <sect3 id="config-network-ndis">
	<title>Gebruik maken van &windows;
	  NDIS-stuurprogramma's</title>

	<indexterm><primary>NDIS</primary></indexterm>

	<indexterm><primary>NDISulator</primary></indexterm>

	<indexterm><primary>&windows; drivers</primary></indexterm>

	<indexterm><primary>Microsoft Windows</primary></indexterm>

	<indexterm>
	  <primary>Microsoft Windows</primary>

	  <secondary>device drivers</secondary></indexterm>

	<indexterm><primary>KLD (kernel loadable object)</primary></indexterm>

	<para>Helaas zijn er nog steeds veel leveranciers die geen
	  schema's leveren voor stuurprogramma's aan de open-source
	  gemeenschap, omdat ze deze informatie beschouwen als
	  handelsgeheimen.  Als gevolg daarvan hebben de ontwikkelaars
	  van &os; en andere projecten twee keuzes: zelf de
	  stuurprogramma's ontwikkelen door een langdurig en pijnlijk
	  proces van de huidige stuurprogramma's te ontcijferen, of door
	  gebruik te maken van de huidige binaire bestanden voor het
	  &microsoft.windows; platform.  De meeste ontwikkelaars,
	  inclusief diegeen die gekoppeld zijn aan &os;, hebben voor het
	  laatste gekozen.</para>

	<para>Dankzij de bijdragen van Bill Paul (wpaul) is er vanaf
	  &os;&nbsp;5.3-RELEASE <quote>native</quote> ondersteuning
	  voor de Network Driver Interface Specification (NDIS).  De
	  &os; NDISulator (ook wel bekend als Project Evil) neemt een
	  binair &windows; stuurprogramma en doet net alsof deze in een
	  &windows; systeem draait.  Omdat het stuurprogramma
	  &man.ndis.4; een &windows; binary gebruikt; is het alleen
	  bruikbaar op &i386;- en amd64-systemen.</para>

	<note>
	  <para>Het stuurprogramma &man.ndis.4; is ontwikkeld om
	    ondersteuning te geven aan PCI-, CardBus- en
	    PCMCIA-apparaten, USB-apparaten worden nog niet
	    ondersteund.</para>
	</note>

	<para>Om gebruik te kunnen maken van de NDISulator heeft u drie
	  dingen nodig:</para>

	<orderedlist>
	  <listitem>
	    <para>De bronbestanden van de kernel</para>
	  </listitem>

	  <listitem>
	    <para>Een &windowsxp; stuurprogramma (met de extensie
	      <filename>.SYS</filename>)</para>

	  <listitem>
	    <para>Een instellingenbestand van het &windowsxp;
	      stuurprogramma (met de extensie
	      <filename>.INF</filename>)</para>
	  </listitem>
	</orderedlist>

	<para>Lokaliseer de bestanden voor uw specifieke kaart.  Over
	  het algemeen kunnen deze gevonden worden op de bijgeleverde
	  CD's of op de website van de leverancier.  In de volgende
	  voorbeelden maken we gebruik van
	  <filename>W32DRIVER.SYS</filename> en
	  <filename>W32DRIVER.INF</filename>.</para>

	<note>
	  <para>Let op, u kunt geen gebruik maken van een &windows;/i386
	    stuurprogramma op &os;/amd64, hiervoor zult u een
	    &windows;/amd64 stuurprogramma moeten gebruiken om het
	    werkend te krijgen.</para>
	</note>

	<para>De volgende stap is het compileren van het binaire
	  stuurprogramma in een laadbare kernelmodule.  Om dit voor
	  elkaar te krijgen moet &man.ndisgen.8; gebruikt worden als
	  <username>root</username>.</para>

	<screen>&prompt.root; <userinput>ndisgen <replaceable>/pad/naar/W32DRIVER.INF</replaceable>
<replaceable>/pad/naar/W32DRIVER.SYS</replaceable></userinput></screen>

	<para>Het gereedschap &man.ndisgen.8; is interactief en zal
	  vragen om extra informatie als dat nodig is; het zal een
	  kernelmodule produceren in de huidige map die als volgt
	  gebruikt kan worden:</para>

	<screen>&prompt.root; <userinput>kldload <replaceable>./W32DRIVER_SYS.ko</replaceable></userinput></screen>

	<para>Naast de gegenereerde kernelmodule, moeten ook de modules
	  <filename>ndis.ko</filename> en
	  <filename>if_ndis.ko</filename> geladen worden.  Dit zou
	  automatisch moeten gebeuren als er een module geladen wordt
	  dit afhankelijk is van &man.ndis.4;.  Als ze handmatig
	  ingeladen moeten worden gebruik dan de volgende
	  commando's:</para>

	<screen>&prompt.root; <userinput>kldload ndis</userinput>
&prompt.root; <userinput>kldload if_ndis</userinput></screen>

	<para>Het eerste commando laadt de stuurprogrammawrapper voor de
	  NDIS miniport, de tweede laadt de daadwerkelijke
	  netwerkinterface.</para>

	<para>Controleer nu &man.dmesg.8; om te zien of er ergens fouten
	  voorkomen.  Als alles goed gegaan is ziet u ongeveer het
	  volgende:</para>

	<screen>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</screen>

	<para>Vanaf dit moment kan de <devicename>ndis0</devicename>
	  net zo gebruikt worden als elke andere netwerkkaart (bv.
	  <devicename>dc0</devicename>).</para>

	<para>Het systeem kan geconfigureerd worden zodat de
	  NDIS-modules automatisch gestart worden tijdens het opstarten
	  van het systeem, net zoals bij andere modules.  Kopieer eerst
	  de gegenereerde module <filename>W32DRIVER_SYS.ko</filename> naar
	  de map <filename class="directory">/boot/modules</filename>.
	  Voeg daarna de volgende regel toe aan
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>W32DRIVER_SYS_load="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>De netwerkkaart instellen</title>

      <indexterm>
	<primary>netwerkkaarten</primary>

	<secondary>instellen</secondary>
      </indexterm>

      <para>Nadat een geschikt stuurprogramma geladen is, moet de kaart
	nog ingesteld worden.  Mogelijk is dit al gebeurd door
	<application>sysinstall</application> tijdens de
	installatie.</para>

      <para>Om de instellen van de netwerkkaarten weer te geven:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        options=3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        nd6 options=3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</screen>

      <para>In dit voorbeeld werden de volgende apparaten
	weergegeven:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: de eerste
	    Ethernet-interface;</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: de tweede
	    Ethernet-interface;</para>
	</listitem>

	<listitem>
	  <para><devicename>plip0</devicename>: De parallele poort
	  interface (mits er een parallele poort aanwezig is op de
	  machine)</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: het
	    loopback-apparaat;</para>
	</listitem>
      </itemizedlist>

      <para>&os; gebruikt de naam van het stuurprogramma gevolgd door
	een nummer voor de volgorde waarop de kaarten gedetecteerd zijn
	bij het opstarten.  <devicename>sis2</devicename> is de derde
	netwerkkaart in het systeem die het stuurprogramma &man.sis.4;
	gebruikt.</para>

      <para>In het vorige voorbeeld is het apparaat
	<devicename>dc0</devicename> volledig operationeel.  Dit blijkt
	uit de volgende indicatoren:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> betekent dat de kaart ingesteld is
	    en klaar is voor gebruik;</para>
	</listitem>

	<listitem>
	  <para>De kaart heeft een Internet (<literal>inet</literal>)
	    adres (in dit geval <hostid
	    role="ipaddr">192.168.1.3</hostid>);</para>
	</listitem>

	<listitem>
	  <para>Het heeft een geldig subnetmasker
	    (<literal>netmask</literal>; <hostid
	      role="netmask">0xffffff00</hostid> is hetzelfde als
	    <hostid role="netmask">255.255.255.0</hostid>);</para>
	</listitem>

	<listitem>
	  <para>Het heeft een geldig broadcastadres (in dit geval
	    <hostid role="ipaddr">192.168.1.255</hostid>);</para>
	</listitem>

	<listitem>
	  <para>Het MAC-adres van de kaart (<literal>ether</literal>) is
	    <hostid role="mac">00:a0:cc:da:da:da</hostid>;</para>
	</listitem>

	<listitem>
	  <para>De fysieke mediaselectie staat in autoselectiemodus
	    (<literal>media: Ethernet autoselect (100baseTX
	      &lt;full-duplex&gt;)</literal>).
	    <devicename>dc1</devicename> is ingesteld om met
	    <literal>10baseT/UTP</literal>-media te werken.  Meer
	    informatie over de mogelijke mediatypes staan in de
	    hulppagina's voor het betreffende stuurprogramma.</para>
	</listitem>

	<listitem>
	  <para>De status van de verbinding (<literal>status</literal>)
	    is <literal>active</literal>, dat wil zeggen dat de drager
	    is gevonden.  Bij <devicename>dc1</devicename>staat echter
	    <literal>status: no carrier</literal>.  Dit is normaal als
	    er geen Ethernetkabel in de kaart gestoken is.</para>
	</listitem>
      </orderedlist>

      <para>Als de uitvoer &man.ifconfig.8; er ongeveer zoals hieronder
	uitziet, dan is de netwerkkaart nog niet ingesteld:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active</screen>

      <para>Om de kaart in te stellen zijn
	<username>root</username>-rechten nodig.  De netwerkkaart kan
	vanaf de console worden ingesteld met &man.ifconfig.8;, maar dan
	moet dat na elke herstart herhaald worden.  Daarom wordt het
	vrijwel altijd in <filename>/etc/rc.conf</filename>
	gezet.</para>

      <para>In <filename>/etc/rc.conf</filename> moet voor elke
	netwerkkaart in een systeem een regel toegevoegd worden.  In het
	huidige voorbeeld zou dat het volgende kunnen zijn:</para>

      <programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para><devicename>dc0</devicename>, <devicename>dc1</devicename>,
	enzovoort, moeten vervangen worden door de correcte
	stuurprogramma's voor de netwerkkaarten, zo ook de
	<acronym>IP</acronym>-adressen.  In de handleiding van het
	stuurprogramma en van &man.ifconfig.8; staan meer details over
	de mogelijke opties en in &man.rc.conf.5; staat meer informatie
	over <filename>/etc/rc.conf</filename>.</para>

      <para>Als het netwerk al is ingesteld tijdens het installeren van
	&os; staan er al enkele regels met betrekking tot de
	netwerkkaart(en) in <filename>/etc/rc.conf</filename>.  Het is
	dus handig <filename>/etc/rc.conf</filename> te controleren
	voordat er regels toegevoegd worden.</para>

      <para>Ook <filename>/etc/hosts</filename> moet worden gewijzigd om
	de namen en <acronym>IP</acronym> adressen van verschillende
	machines op het lokale netwerk, als ze er nog niet in staan.
	Meer informatie staat in &man.hosts.5; en
	<filename>/usr/share/examples/etc/hosts</filename>.</para>

      <note>
	<para>Als internettoegang nodig is met dit apparaat, kan
	  het zijn dat de default gateway en de naamserver handmatig
	  moeten worden ingesteld:</para>

	<screen>&prompt.root; <userinput>echo 'defaultrouter="<replaceable>your_default_router</replaceable>"' &gt;&gt; /etc/rc.conf</userinput>
&prompt.root; <userinput>echo 'nameserver <replaceable>your_DNS_server</replaceable>' &gt;&gt; /etc/resolv.conf</userinput></screen>
      </note>
    </sect2>

    <sect2>
      <title>Testen en problemen oplossen</title>

      <para>Als de veranderingen in <filename>/etc/rc.conf</filename>
	zijn gemaakt, moet het systeem opnieuw gestarten worden (of
	moeten nauwkeurig alle daemons gestart of herstart worden).
	Veranderingen aan de interface(s) worden dan toegepast en dan
	kan er controleerd worden of herstarten goed werkt zonder
	foutmeldingen.  Als alternatief kan ook het netwerk systeem
	herstart worden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/netif restart</userinput></screen>

      <note>
	<para>Als er ook een default gateway ingesteld is in het
	  <filename>/etc/rc.conf</filename> bestand, moet ook onderstaand
	  command worden gegeven:</para>

	<screen>&prompt.root; <userinput>/etc/rc.d/routing restart</userinput></screen>
      </note>

      <para>Zodra het netwerk systeem is herstart, moeten de netwerk
	interfaces opnieuw getest worden.</para>

      <sect3>
	<title>Testen van de netwerkkaart</title>

	<indexterm>
	  <primary>netwerk kaarten</primary>
	  <secondary>testen</secondary>
	</indexterm>

	<para>Om te controleren of een ethernet kaart goed geconfigureerd
	  is, moeten er twee dingen gedaan worden.  Allereerst, ping de
	  interface zelf, en daarna een andere machine op het LAN.</para>

	<para>Test eerst de lokale interface:</para>

	<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>Nu kan er een andere machine op het LAN gepinged worden:</para>

	<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

      <para>Dit kan ook worden geprobeerd met de machine naam in plaats
	van met <hostid role="ipaddr">192.168.1.2</hostid> als dit
	geconfigureerd is in het <filename>/etc/hosts</filename>
	bestand.</para>
      </sect3>

      <sect3>
	<title>Problemen oplossen</title>

	<indexterm>
	  <primary>netwerk kaarten</primary>
	  <secondary>probleem oplossing</secondary>
	</indexterm>

       <para>Het testen en zoeken van problemen is altijd een
	  pijnpunt, welke verminderd kan worden door een aantal
	  simpele dingen eerst te controleren.  Is de netwerkkabel
	  ingestoken?  Zijn de netwerk instellingen correct opgegeven?
	  Is de firewall goed geconfigureerd?  Is de netwerkkaart
	  ondersteund door &os;?  Controleer altijd de hardware notities
	  voordat er een probleem rapport wordt verstuurd.  Update naar
	  de laatste -STABLE versie, en controleer de mailing lijsten en
	  misschien zelfs het internet.</para>

	<para>Als de kaart werkt, maar de prestaties zijn slecht, dan kan
	  het de moeite waard zijn om &man.tuning.7; door te nemen.
	  Incorrecte netwerkinstellingen kunnen ook tot langzame
	  verbindingen leiden.</para>

	<para>Soms kunnen enkele <errorname>device timeouts</errorname>
	  optreden.  Met sommige kaarten is dit normaal gedrag.  Maar als
	  dit continu gebeurt of storend is, is het verstandig uit te
	  zoeken of er geen sprake is van een hardwareconfict tussen de
	  netwerkkaart en een ander apparaat.  Ook dient nogmaals de
	  bekabeling gecontroleerd te worden.  Misschien zit er niets
	  anders op dan een andere netwerkkaart te gebruiken.</para>

	<para>Het is ook mogelijk dat er <errorname>watchdog
	    timeout</errorname> foutmeldingen optreden.  Als eerste moet
	  dan de netwerkkabel gecontroleerd worden.  Veel kaarten hebben
	  een PCI-slot nodig dat Bus Mastering ondersteunt.  Sommige
	  oudere moederborden hebben maar &eacute;&eacute;n PCI-slot
	  waarmee dit kan (meestal slot 0).  In de documentatie van de
	  netwerkkaart en het moederbord is na te gaan of dit het
	  probleem is.</para>

	<para><errorname>No route to host</errorname> meldingen treden op
	  als het systeem niet in staat is om een pakket naar de
	  eindbestemming te routeren.  Dit kan gebeuren als er geen
	  standaardroute aangegeven is of als er een kabel niet verbonden
	  is.  De uitvoer van <command>netstat -rn</command> moet
	  gecontroleerd worden of er een geldige route is naar de
	  bestemming.  Mocht dit niet het geval zijn, dan staat er meer
	  informatie in <xref linkend="advanced-networking">.</para>

	<para><errorname>ping: sendto: Permission denied</errorname>
	  foutmeldingen worden vaak veroorzaakt door een verkeerd
	  ingestelde firewall.  Als de kernel <command>ipfw</command>
	  activeert bij het opstarten zonder dat er firewallregels zijn
	  gedefini&euml;erd, is het standaardbeleid om alle verkeer te
	  weigeren, zelfs pings!  In <xref linkend="firewalls"> staat meer
	  informatie.</para>

	<para>Er kan ook sprake zijn van onvoldoende prestaties doordat de
	  instelling van de mediaselectie niet optimaal is.  In dergelijke
	  gevallen is het mogelijk om de mediaselectie niet als
	  <literal>autoselect</literal> in te stellen, maar expliciet aan
	  te geven wat de mediaselectie moet zijn, bijvoorbeeld
	  10baseT/UTP voor twisted pair.  Hoewel dit voor de meeste
	  hardware helpt, kan het zijn dat de problemen blijven.  Dan
	  moeten nogmaals de netwerkinstellingen gecontroleerd worden en
	  geeft de &man.tuning.7; handleiding wellicht meer
	  informatie.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtuele hosts</title>

    <indexterm><primary>virtuele hosts</primary></indexterm>

    <indexterm><primary>IP-aliassen</primary></indexterm>

    <para>&os; wordt veel gebruikt voor virtuele sitehosting, waarbij
      &eacute;&eacute;n fysieke server er op het netwerk uitziet alsof
      het meerdere servers zijn.  Dit kan bereikt worden door meerdere
      <acronym>IP</acronym>-adressen toe te kennen aan dezelfde
      interface.</para>

    <para>Een bepaalde netwerkinterface heeft een <quote>echt</quote>
      adres en kan daarnaast een willekeurig aantal
      <quote>alias</quote>-adressen hebben.  Normaliter worden
      dergelijke aliassen toegevoegd door aliasregels toe te voegen aan
      <filename>/etc/rc.conf</filename>.</para>

    <para>Een aliasregel voor de interface
      <devicename>fxp0</devicename> ziet er zo uit:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>De aliasregels moeten beginnen met <literal>alias0</literal>
      en moete elkaar dan opvolgen (bijvoorbeeld
      <literal>_alias1,</literal>, <literal>_alias2</literal>,
      enzovoort).  Het instelproces stopt als er een nummer
      ontbreekt.</para>

    <para>Het is belangrijk dat aliassen het juiste netmasker hebben.
      Dit is eenvoudig: Een bepaalde interface moet altijd
      &eacute;&eacute;n adres hebben dat het netmasker van het netwerk
      correct representeert.  Elk ander adres binnen dit netwerk op deze
      interface (alias) moet een netmasker van allemaal
      <literal>1</literal>'en (bits) hebben (getoond als <hostid
	role="netmask">255.255.255.255</hostid> of <hostid
	role="netmask">0xffffffff</hostid>).</para>

    <para>Een voorbeeld.  Stel de interface
      <devicename>fxp0</devicename> is verbonden met twee netwerken, het
      netwerk <hostid role="ipaddr">10.1.1.0</hostid> met masker
      <hostid role="netmask">255.255.255.0</hostid> en het netwerk
      <hostid role="ipaddr">202.0.75.16</hostid> met netmasker
      <hostid role="netmask">255.255.255.240</hostid>.  Het systeem
      moet ook de adressen <hostid role="ipaddr">10.1.1.1</hostid> tot
      en met <hostid role="ipaddr">10.1.1.5</hostid> en <hostid
	role="ipaddr">202.0.75.17</hostid> tot en met <hostid
	role="ipaddr">202.0.75.20</hostid> krijgen.  Zoals hierboven
      vermeld, heeft alleen het eerste adres in een netwerkreeks (in dit
      geval <hostid role="ipaddr">10.0.1.1</hostid> en <hostid
	role="ipaddr">202.0.75.17</hostid>) een geldig netmasker.  Alle
      overige (<hostid role="ipaddr">10.1.1.2</hostid> tot en met
      <hostid role="ipaddr">10.1.1.5</hostid> en <hostid
	role="ipaddr">202.0.75.18</hostid> tot en met <hostid
	role="ipaddr">202.0.75.20</hostid>) moeten ingesteld worden met
      het netmasker <hostid
	role="netmask">255.255.255.255</hostid>.</para>

    <para>De volgende regels voor <filename>/etc/rc.conf</filename>
      stellen een adapter in voor het bovenstaande scenario:</para>

<programlisting>ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>
  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Instellingenbestanden</title>

    <sect2>
      <title><filename class="directory">/etc</filename> layout</title>

      <para>Instellingengegevens wordt in een aantal mappen bewaard.
	Daar zijn onder andere:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">

	  <colspec colwidth="2*">

	  <tbody>
	    <row>
	      <entry><filename class="directory">/etc</filename></entry>

	      <entry>Generieke systeeminstellingenbestanden, specifiek
		voor het systeem.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults</filename></entry>

	      <entry>De standaardversies van systeeminstellingenbestanden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail</filename></entry>

	      <entry>Extra &man.sendmail.8; instellingenbestanden of
		instellingenbestanden voor andere MTAs.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp</filename></entry>

	      <entry>Instellingen voor zowel gebruiker- als kernel-ppp
		programma's.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb</filename></entry>

	      <entry>Standaardlocatie voor &man.named.8; gegevens.
		Normaal gesproken bevinden zich hier
		<filename>named.conf</filename> en zonebestanden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/local/etc</filename></entry>

	      <entry>Instellingenbestanden voor ge&iuml;nstalleerde
		software.  Kan submappen hebben waarin bij elkaar
		horende instellingengegevens van een applicatie
		gegroepeerd zijn.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/local/etc/rc.d</filename></entry>

	      <entry>Start- en stopscripts voor ge&iuml;nstalleerde
		diensten.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/db</filename></entry>

	      <entry>Automatisch gemaakte systeemspecifieke
		databasebestanden, zoals de pakketdatabase, de
		&man.locate.1; database, enzovoort.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostnaam</primary></indexterm>

      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>In <filename>/etc/resolv.conf</filename> wordt
	  voorgeschreven op welke wijze &os; het Domain Name System
	  (DNS) moet gebruiken.</para>

	<para>De meest voorkomende termen in
	  <filename>resolv.conf</filename> zijn:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">

	    <colspec colwidth="2*">

	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>

		<entry>Het <acronym>IP</acronym>-adres van een
		  naamserver die ondervraagd moet worden voor
		  naam/<acronym>IP</acronym>-conversie.  De servers
		  worden in volgorde geprobeerd en het maximale aantal
		  is drie.</entry>
	      </row>

	      <row>
		<entry><literal>search</literal></entry>

		<entry>Zoeklijst voor het opzoeken van hostnamen.
		  Meestal wordt deze bepaald door het domein waarop de
		  lokale hostnaam zich bevindt.</entry>
	      </row>

	      <row>
		<entry><literal>domain</literal></entry>

		<entry>De lokale domeinnaam.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Een typisch <filename>resolv.conf</filename>
	  bestand:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note>
	  <para><literal>search</literal> en <literal>domain</literal>
	    dienen niet tegelijk gebruikt te worden.</para>
	</note>

	<para>Als DHCP wordt gebruikt: &man.dhclient.8; overschrijft
	  meestal <filename>resolv.conf</filename> met informatie
	  ontvangen van de DHCP-server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> is een eenvoudige
	  tekstdatabase uit de dagen van het oude Internet.  Het werkt
	  samen met DNS en NIS om namen en <acronym>IP</acronym>
	  adressen over en weer te vertalen.  Lokale computers,
	  verbonden via een LAN, kunnen hier het beste in opgenomen
	  worden om zo op simpele wijze naam/<acronym>IP</acronym>
	  conversie voor een LAN te hebben, zonder noodzaak voor een
	  &man.named.8; server.  Ook kunnen naamaliassen toegekend
	  worden (vergelijkbaar met CNAMES bij DNS).  Op soortgelijke
	  wijze kan <filename>/etc/hosts</filename> gebruikt worden als
	  een (zeer beperkte) lokale DNS cache.</para>

	<programlisting># &dollar;&os;&dollar;
#
# Host Database
# Dit bestand hoort de adressen en aliassen te bevatten
# voor de lokale hosts die dit bestand gebruiken.
# Bij gebruik van DNS of NIS hoeft dit bestand helemaal niet gebruikt
# te worden.  Zie /etc/nsswitch.conf voor de volgorde van resolutie.
#
#
::1                      localhost localhost.my.domain myname.my.domain
127.0.0.1                localhost localhost.my.domain myname.my.domain

#
# Verzonnen netwerk.
#10.0.0.2                myname.my.domain myname
#10.0.0.3                myfriend.my.domain myfriend
#
# Volgens RFC 1918 mogen de volgende IP netwerken gebruikt worden
# als private netwerken die niet met Internet verbonden zijn:
#
#        10.0.0.0        -   10.255.255.255
#        172.16.0.0      -   172.31.255.255
#        192.168.0.0     -   192.168.255.255
#
# Als er toch verbinding moet zijn met Internet, zijn echte
# officieel toegewezen nummers nodig.  Probeer ECHT GEEN eigen
# netwerknummers te verzinnen, maar vraag ze op bij de provider
# (als die er is) of bij de Internet Registry (ftp naar
# rs.internic.net, map `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> heeft als formaat:</para>

	<programlisting>[Internet address] [official hostname] [alias1] [alias2] ...</programlisting>

	<para>Bijvoorbeeld:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>In &man.hosts.5; staat meer informatie.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Logboekbestanden instellen</title>

      <indexterm><primary>logboekbestanden</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> is het
	  instellingenbestand voor het programma &man.syslogd.8;.  Het
	  geeft aan welke soorten <command>syslog</command>-berichten
	  er gelogd moeten worden en naar welke logboekbestanden,
	  apparaten, gebruikers of machines.</para>

	<programlisting># &dollar;&os;&dollar;
#
#        Spaties zijn TOEGESTAAN als veldscheiding in dit bestand.
#        Maar andere *nix-achtige systemen eisen nog steeds het gebruik
#        van tabs als veldscheiding.  Als dit bestand gedeeld wordt met
#        andere systemen, is het verstandig alle tabs als veldscheiding
#        te gebruiken.
#        Zie ook de handleding van syslog.conf(5).
*.err;kern.debug;auth.notice;mail.crit           /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err  /var/log/messages
security.*                                       /var/log/security
mail.info                                        /var/log/maillog
lpr.info                                         /var/log/lpd-errs
cron.*                                           /var/log/cron
*.err                                            root
*.notice;news.err                                root
*.alert                                          root
*.emerg                                          *
# verwijder het commentaarkarakter om alle schrijfacties naar
# /dev/console naar /var/log/console.log te schrijven.
#console.info                                    /var/log/console.log
# verwijder het commentaarkarakter om alle berichten naar
# /var/log/all.log te schrijven.
#*.*                                             /var/log/all.log
# # verwijder het commentaarkarakter om alle logs naar een andere
# host in te schakelen met de naam loghost.
#*.*                                             @loghost
# # verwijder het commentaarkarakter als inn draait.
# news.crit                                      /var/log/news/news.crit
# news.err                                       /var/log/news/news.err
# news.notice                                    /var/log/news/news.notice
!startslip
*.*                                              /var/log/slip.log
!ppp
*.*                                              /var/log/ppp.log</programlisting>

	<para>In &man.syslog.conf.5; staat meer informatie.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para><filename>newsyslog.conf</filename> is het
	  instellingenbestand voor &man.newsyslog.8;, een programma dat
	  op gezette tijden via &man.cron.8; wordt uitgevoerd.
	  &man.newsyslog.8; stelt vast wanneer logboekbestanden
	  gearchiveerd moeten worden of anderszins opnieuw gerangschikt
	  moeten worden.  <filename>logfile</filename> wordt hernoemd
	  naar <filename>logfile.0</filename>,
	  <filename>logfile.0</filename>
	  naar <filename>logfile.1</filename>, enzovoort.</para>

	<para><filename>newsyslog.conf</filename> geeft aan welke
	  logboekbestanden beheerd moeten worden, hoeveel er in
	  archieven bewaard moeten worden en wanneer ze aangemaakt
	  moeten worden.  Logboekbestanden kunnen gereorganiseerd en/of
	  gearchiveerd worden als ze een bepaalde grootte bereikt
	  hebben of op een bepaald periodiek tijdstip of een bepaalde
	  datum.</para>

	<programlisting># instellingenbestand voor newsyslog
# &dollar;&os;&dollar;
#
# filename           [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                            600  3     100  *     Z
/var/log/amd.log                         644  7     100  *     Z
/var/log/kerberos.log                    644  7     100  *     Z
/var/log/lpd-errs                        644  7     100  *     Z
/var/log/maillog                         644  7     *    @T00  Z
/var/log/sendmail.st                     644  10    *    168   B
/var/log/messages                        644  5     100  *     Z
/var/log/all.log                         600  7     *    @T00  Z
/var/log/slip.log                        600  3     100  *     Z
/var/log/ppp.log                         600  3     100  *     Z
/var/log/security                        600  10    100  *     Z
/var/log/wtmp                            644  3     *    @01T05 B
/var/log/daily.log                       640  7     *    @T00  Z
/var/log/weekly.log                      640  5     1    $W6D0 Z
/var/log/monthly.log                     640  12    *    $M1D0 Z
/var/log/console.log                     640  5     100  *     Z</programlisting>

	<para>In &man.newsyslog.8; staat meer informatie.</para>
      </sect3>
    </sect2>

    <sect2 id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>

      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> lijkt veel op
	<filename>rc.conf</filename>.  Waardetoekenning heeft weer de
	vorm <literal>variable=value</literal>.  De ingestelde
	&man.sysctl.8;-waarden worden doorgevoerd op het moment dat het
	systeem naar multi-user modus gaat.  Niet alle variabelen kunnen
	in deze modus gewijzigd worden.</para>

      <para>Om te voorkomen dat er logregels geplaatst worden als
	processen crashen en om te voorkomen dat andere gebruikers
	kunnen zien welke processen er gestart zijn door een andere
	gebruiker, kunnen de volgende instellingen worden gezet in
	<filename>sysctl.conf</filename>:</para>

      <programlisting>#Log exits met fatale signalen niet (bv. sig 11)
kern.logsigexit=0

# Voorkom dat gebruikers informatie zien over processen die
# worden gedraaid onder een ander UID.
security.bsd.see_other_uids=0</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Optimaliseren met sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>

    <indexterm>
      <primary>optimalisering</primary>

      <secondary>met sysctl</secondary>
    </indexterm>

    <para>&man.sysctl.8; is een interface waarmee veranderingen gemaakt
      kunnen worden aan een draaiend &os;-systeem.  Er zijn onder meer
      vele geavanceerde opties voor de TCP/<acronym>IP</acronym>-stack
      en het virtuele geheugensysteem, waarmee een ervaren
      systeembeheerder de systeemprestaties drastisch kan verbeteren.
      Met &man.sysctl.8; kunnen meer dan vijfhonderd systeemvariabelen
      opgevraagd en ingesteld worden.</para>

    <para>In essentie heeft &man.sysctl.8; twee functies: het lezen en
      wijzigen van systeeminstellingen.</para>

    <para>Om alle leesbare variabelen te tonen:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Om een bepaalde variabele op te vragen, bijvoorbeeld
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Om een bepaalde variabele toe te kennen (te wijzigen), is de
      syntaxis
      <replaceable>variable</replaceable>=<replaceable>value</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -&gt; 5000</screen>

    <para>Waarden van sysctl-variabelen zijn doorgaans strings (tekst),
      getallen of booleans (<literal>1</literal> als waar,
      <literal>0</literal> als onwaar).</para>

    <para>Om automatisch variabelen in te stellen als de machine start,
      kunnen ze toegevoegd worden aan
      <filename>/etc/sysctl.conf</filename>.  Meer informatie staat in
      &man.sysctl.conf.5; en <xref
	linkend="configtuning-sysctlconf">.</para>

  <sect2 id="sysctl-readonly">
    <sect2info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect2info>

    <title>&man.sysctl.8; alleen-lezen</title>

    <para>In sommige gevallen is het wenselijk om &man.sysctl.8;-waarden
      die alleen-lezen zijn toch te wijzigen.  Hoewel dit soms
      onontkoombaar is, kan het alleen bij een (her)start gedaan
      worden.</para>

    <para>Op sommige laptops is bijvoorbeeld het apparaat
      &man.cardbus.4; niet in staat om geheugenregio's af te tasten, met
      als gevolg foutmeldingen als:</para>

    <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

    <para>In dergelijke gevallen moeten er meestal enkele
      &man.sysctl.8;-instellingen gewijzigd worden die alleen-lezen zijn
      en een standaardwaarde hebben.  Dit kan bereikt worden door
      &man.sysctl.8; <quote>OIDs</quote> in de lokale
      <filename>/boot/loader.conf</filename> te zetten.
      Standaardinstellingen staan in
      <filename>/boot/defaults/loader.conf</filename>.</para>

    <para>Om het bovenstaande probleem op te lossen moet in
      <filename>/boot/loader.conf</filename>
      <literal>hw.pci.allow_unsupported_io_range=1</literal> ingesteld
      worden.  Dan werkt &man.cardbus.4; wel goed.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Harde schijven optimaliseren</title>

    <sect2>
      <title>Sysctl-variabelen</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm><primary><varname>vfs.vmiodirenable</varname></primary></indexterm>

	<para>De sysctl-variabele <varname>vfs.vmiodirenable</varname>
	  kan de waarde 0 (uit) of 1 (aan) hebben.  De standaardwaarde
	  is 1.  Deze variabele bepaalt hoe mappen door het systeem in
	  een cache bewaard worden.  De meeste mappen zijn klein en
	  gebruiken slechts een klein fragment (typisch 1&nbsp;K) in het
	  bestandssysteem en nog minder (typisch 512&nbsp;bytes) in de
	  buffercache.  Als deze variabele uit staat (op 0) bewaart de
	  buffercache slechts een bepaald aantal mappen in de cache, ook
	  al is er een overvloed aan geheugen beschikbaar.  Wanneer deze
	  aan staat (op 1), wordt de VM paginacache gebruikt, waardoor
	  voor het cachen van mappen al het geheugen kan worden
	  gebruikt.  Het is echter wel zo dat het minimale in-core
	  geheugen dat gebruikt wordt om een map te cachen in dat geval
	  de fysieke paginagrootte is (typisch 4&nbsp;K) in plaats van
	  512&nbsp; bytes.  Het is aan te raden deze optie aan te laten
	  staan als gebruik gemaakt wordt van diensten die met grote
	  aantallen bestanden werken, zoals webcaches, grote
	  mailsystemen en newsservers.  Als deze optie aan blijft staan,
	  verlaagt die de prestaties niet, ook al kost het meer
	  geheugen.  Door experimenteren is dit voor een systeem na te
	  gaan.</para>
      </sect3>

     <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm><primary><varname>vfs.write_behind</varname></primary></indexterm>

	<para>De sysctl-variabele <varname>vfs.write_behind</varname>
	  staat standaard aan (<literal>1</literal>).  Dit betekent dat
	  het bestandssysteem gegevens naar het medium gaat schrijven op
	  het moment dat er een volledig cluster aan gegevens verzameld
	  is.  Dit is meestal het geval bij het schrijven van grote
	  sequenti&euml;le bestanden.  Het idee is om te voorkomen dat
	  de buffercache verzadigd raakt met vuile buffers zonder dat
	  dit bijdraagt aan de I/O-prestaties.  Dit kan echter processen
	  ophouden en onder sommige omstandigheden is het wellicht beter
	  deze sysctl uit te zetten.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm><primary><varname>vfs.hirunningspace</varname></primary></indexterm>

	<para>De sysctl-variabele <varname>vfs.hirunningspace</varname>
	  bepaalt hoeveel nog te schrijven gegevens er in het complete
	  systeem op elk moment in de wachtrij naar schijfcontrollers
	  mag staan.  De standaardwaarde is meestal voldoende, maar op
	  machines met veel schijven, is het beter deze te verhogen naar
	  vier of vijf <emphasis>megabyte</emphasis>.  Het instellen van
	  een te hoge waarde (groter dan de schrijfdrempel van de
	  buffercache) kan leiden tot zeer slechte prestaties bij
	  clustering.  Stel deze waarde niet arbitrair hoog in!  Hogere
	  schrijfwaarden kunnen vertraging veroorzaken in het lezen, als
	  dit tegelijk plaatsvindt.</para>

	<para>Er zijn verscheidene andere sysctl's voor buffercache en
	  VM-pagecache.  Het wordt afgeraden deze te wijzigen.  Het
	  VM-systeem is zeer goed in staat zichzelf automatisch te
	  optimaliseren.</para>
      </sect3>

      <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm><primary><varname>vm.swap_idle_enabled</varname></primary></indexterm>

	<para>De sysctl-variabele
	  <varname>vm.swap_idle_enabled</varname> is nuttig in grote
	  meergebruikersystemen met veel gebruikers die af- en aanmelden
	  en veel onbenutte processen.  Dergelijke systemen hebben de
	  neiging om voortdurend de vrije geheugenreserves onder druk
	  te zetten.  Het is mogelijk om de prioriteit van
	  geheugenpagina's die verband houden met onbenutte processen
	  sneller te laten dalen dan met het normale pageout-algoritme,
	  door deze sysctl aan te zetten en via
	  <varname>vm.swap_idle_threshold1</varname> en
	  <varname>vm.swap_idle_threshold2</varname> de swapout
	  hysterese (in seconden onbenut) af te stemmen.  Deze optie
	  dient alleen gebruikt te worden als ze echt nodig is, want de
	  andere kant van de medaille is dat dit eerder pre-page
	  geheugen inhoudt in plaats van later, waardoor het meer
	  wisselbestand- en schijfbandbreedte kost.  In een klein
	  systeem heeft deze optie een voorspelbaar effect, maar in
	  grote systemen waar al sprake is van een matige paging kan
	  deze optie het mogelijk maken voor het VM-systeem om hele
	  processen gemakkelijk in en uit het geheugen te halen.</para>
      </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm><primary><varname>hw.ata.wc</varname></primary></indexterm>

	<para>Ten tijde van &os;&nbsp;4.3 is er geflirt met het
	  uitzetten van IDE-schrijfcaching.  Hierdoor neemt de
	  bandbraadte naar IDE-schijven af, maar het werd als
	  noodzakelijk beschouwd vanwege ernstige problemen met
	  gegevensinconsistentie die door harde schijfproducenten
	  ge&euml;introduceerd waren.  Het probleem is dat IDE-schijven
	  niet de waarheid vertellen over wanneer een schrijfactie
	  klaar is.  Door IDE-schrijfcaching wordt data niet alleen
	  ongeordend geschreven, maar soms kan zelfs het schrijven van
	  sommige blokken voortdurend uitgesteld worden als er sprake is
	  van een hoge schijfbelasting.  Een crash of stroomstoring kan
	  dan ernstige corruptie aan het bestandssysteem veroorzaken.
	  Daarom werd de standaardinstelling van &os; voor alle
	  zekerheid gewijzigd.  Helaas was het resultaat een groot
	  verlies aan prestaties en na die uitgave is de
	  standaardwaarde weer terug veranderd.  Met de sysctl-variabele
	  <varname>hw.ata.wc</varname> kan gecontroleerd worden of
	  schrijfcaching aan of uit staat.  Als schrijfcaching uit
	  staat, kan het die weer aangezet worden door
	  <varname>hw.ata.wc</varname> op 1 te zetten.  Aangezien dit
	  een kernelvariabele is, moet deze ingesteld worden vanuit de
	  bootloader tijdens het opstarten.  Nadat de kernel eenmaal
	  opgestart is, heeft het wijzigen van deze sysctl geen
	  effect.</para>

	<para>Meer informatie staat in &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	  (<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm><primary><varname>kern.cam.scsi.delay</varname></primary></indexterm>

	<indexterm>
	  <primary>kernelopties</primary>

	  <secondary><literal>SCSI_DELAY</literal></secondary>
	</indexterm>

	<para>De kernelinstelling <literal>SCSI_DELAY</literal> kan
	  gebruikt worden om de opstarttijd te versnellen.  De
	  standaardwaarde is nogal hoog en kan <literal>15</literal>
	  seconden vertraging veroorzaken.  Met modernere SCSI-systemen
	  is <literal>5</literal> seconden al voldoende.  Nieuwere
	  versies van &os; (5.0 en hoger) gebruiken de opstartvariabele
	  <varname>kern.cam.scsi_delay</varname>.  Zowel deze als de
	  optie <literal>SCSI_DELAY</literal> gebruiken waarden
	  uitgedrukt in <emphasis>milliseconden</emphasis> en
	  <emphasis>niet</emphasis> in
	  <emphasis>seconden</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Softupdates</title>

      <indexterm><primary>Softupdates</primary></indexterm>

      <indexterm><primary>tunefs</primary></indexterm>

      <para>&man.tunefs.8; kan gebruikt worden om een bestandsysteem
	nauwkeurig af te stellen.  Het heeft veel opties, maar nu wordt
	alleen het aan- en uitzetten van softupdates besproken.  Dat
	gaat als volgt:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Een bestandssysteem kan niet met &man.tunefs.8; gewijzigd
	worden als het aangekoppeld is.  Softupdates aanzetten wordt dus
	in het algemeen gedaan vanuit enkelegebruikermodus, voordat
	partities aangekoppeld zijn.</para>

      <para>Softupdates zorgen voor een drastische verbetering van de
	prestaties met betrekking tot metagegevens, met name het
	aanmaken en verwijderen van bestanden, door gebruik van een
	geheugencache.  Het wordt dan ook aangeraden om op alle
	bestandssystemen softupdates te gebruiken.  Er zijn twee nadelen
	aan softupdates: softupdates garanderen een consistent
	bestandssysteem in geval van een crash, maar het kan makkelijk
	enkele seconden (zelfs een minuut) achter liggen met het
	daadwerkelijk bijwerken op de fysieke harde schijf.  Als een
	systeem crasht gaat wellicht meer werk verloren dan anders het
	geval zou zijn.  Daarnaast vertragen softupdates het vrijgeven
	van bestandssysteemblokken.  Als een bestandssysteem (zoals de
	rootpartitie) bijna vol is, dan kan het verrichten van een grote
	update, zoals <command>make installworld</command>, ertoe leiden
	dat het bestandssysteem ruimtegebrek krijgt en dat daardoor de
	operatie mislukt.</para>

      <sect3>
	<title>Meer over softupdates</title>

	<indexterm>
	  <primary>Softupdates</primary>

	  <secondary>details</secondary>
	</indexterm>

	<para>Er zijn traditioneel twee methodes om de metagegevens van
	  een bestandssysteem terug naar de schijf te schrijven.  Het
	  bijwerken van metagegevens houdt het bijwerken van van
	  niet-inhoudelijke gegevens zoals inodes of mappen in.</para>

	<para>Historisch gezien was het gebruikelijk om updates aan
	  metagegevens synchroon weg te schrijven.  Als een map
	  bijvoorbeeld gewijzigd was, wachtte het systeem totdat de
	  verandering daadwerkelijk naar de schijf geschreven was.  De
	  gegevensbuffers (de inhoud van een bestand) werden
	  doorgeschoven naar de buffercache en op een later moment
	  asynchroon op de schijf opgeslagen.  Het voordeel van deze
	  benadering is dat ze altijd veilig is.  Als het systeem faalt
	  tijdens het bijwerken, zijn de metagegevens nog altijd
	  consistent.  Een bestand kan volledig gecre&euml;erd zijn of
	  helemaal niet.  Als de gegevensblokken van een bestand nog
	  niet van de buffercache naar de schijf geschreven zijn ten
	  tijde van de crash, is &man.fsck.8; in staat om dit te
	  herkennen en het bestandssysteem te repareren door de lengte
	  van het bestand nul te maken.  Deze implementatie is ook
	  helder en eenvoudig.  Het nadeel is echter dat het wijzigen
	  van metagegevens een traag proces is.  Een
	  <command>rm -r</command> benadert bijvoorbeeld alle bestanden
	  in een map sequenti&euml;el, maar elke mapverandering
	  (verwijderen van een bestand) wordt synchroon naar de schijf
	  geschreven.  Dit omvat ook het bijwerken van de map zelf, van
	  de inodetabel en mogelijk ook van indirecte blokken die voor
	  het bestand in kwestie zijn gealloceerd.  Gelijksoortige
	  processen spelen zich af bij een commando als
	  <command>tar -x</command>, waarbij een grote
	  bestandshi&euml;earchie wordt uitgepakt.</para>

	<para>De tweede mogelijkheid is om het bijwerken van
	  metagegevens asynchroon weg te schrijven.  Dit is standaard in
	  &linux;/ext2fs en als een *BSD UFS-bestandssysteem met
	  <command>mount -o async</command> aangekoppeld is, is de
	  werking hetzelfde.  Alle bijwerkingen aan metagegevens worden
	  eenvoudigweg doorgegeven aan de buffercache en vermengd met
	  inhoudelijke updates van de bestandsgegevens.  Het voordeel
	  is een grote winst aan snelheid, omdat er niet telkens gewacht
	  hoeft te worden op het bijwerken van metagegevens tot deze
	  daadwerkelijk naar de schijf geschreven zijn.  De
	  implementatie is ook in dit geval helder en eenvoudig.  Het
	  grote nadeel is uiteraard dat er geen enkele garantie is voor
	  de consistentie van het bestandssysteem.  Als het systeem
	  faalt tijdens een operatie waarbij veel metagegevens worden
	  bijgewerkt (bijvoorbeeld door een stroomstoring of iemand
	  drukt op de resetknop), blijft het bestandssysteem in een
	  onvoorspelbare toestand achter.  Er is geen mogelijkheid om de
	  toestand van het bestandssysteem te onderzoeken als het
	  systeem weer opstart, want de gegevensblokken van een bestand
	  kunnen al weggeschreven zijn geweest terwijl het wegschrijven
	  van bijwerkingen aan de inodetabel of de bijhorende map nog
	  niet plaats heeft gevonden.  Het is zelfs onmogelijk om een
	  <command>fsck</command> te implementeren die de overgebleven
	  chaos kan opruimen: de benodigde informatie is gewoon niet
	  volledig aanwezig op de schijf.  Als een bestandssysteem op
	  deze manier onherstelbaar beschadigd is, is de enige optie
	  &man.newfs.8; te gebruiken en vervolgens te herstellen van
	  een backup.</para>

	<para>De gebruikelijke oplossing voor dit probleem is het
	  implementeren van <emphasis>dirty region logging</emphasis>,
	  ook wel <emphasis>journaling</emphasis> genoemd, hoewel deze
	  term niet consistent gebruikt wordt en soms ook wordt gebruikt
	  voor andere vormen van transactielogging.  Het bijwerken van
	  metagegevens wordt nog steeds synchroon geschreven, maar
	  slechts naar een klein gebied van de schijf.  Later worden ze
	  dan naar de juiste locatie verplaatst.  Omdat het loggebied
	  klein is, hoeven de koppen van de schijf zelfs tijdens
	  schrijfintensieve operaties nog maar over een kleine fysieke
	  afstand te bewegen en door deze snellere respons zijn dit
	  soort operaties sneller dan op de traditionele manier.  De
	  extra complexiteit van de implementatie is nogal beperkt, dus
	  het risico van introductie van extra bugs valt mee.  Een
	  nadeel is dat alle metagegevens tweemaal geschreven worden
	  (eerst naar het loggebied en later nog eens naar de
	  definitieve locatie).  Dus bij normaal gebruik kan er sprake
	  zijn van wat men wel noemt een <quote>performance
	    pessimization</quote>.  Anderzijds kunnen in geval van een
	  crash alle nog uitstaande metagegevensoperaties snel worden
	  teruggedraaid of vanuit het loggebied alsnog worden afgemaakt
	  wanneer de machine weer opstart.  Het bestandssysteem start
	  dan snel op.</para>

	<para>Kirk McKusick, de vader van het Berkeley FFS, loste dit
	  probleem op met softupdates, wat betekent dat alle uitstaande
	  acties voor het bijwerken van metagegevens in het geheugen
	  bewaard worden en dan geordend naar de schijf geschreven
	  worden.  Dit heeft het gevolg dat in geval van intensieve
	  operaties met betrekking tot metagegevens, latere bijwerkingen
	  aan een item eerdere bewerkingen opvangen
	  (<quote>catch</quote>) als deze nog in het geheugen zitten en
	  nog niet weggeschreven waren.  Dus alle operaties, op
	  bijvoorbeeld een map, worden in het algemeen eerst in het
	  geheugen uitgevoerd voordat er wordt bijgewerkt naar schijf.
	  De gegevensblokken worden geordend conform hun positie, zodat
	  ze nooit weggeschreven worden voordat hun metagegevens
	  geschreven zijn.  Als het systeem een crash ondervindt,
	  veroorzaakt dat impliciet het terugdraaien van uitstaande
	  operaties (<quote>log rewind</quote>): alle operaties die nog
	  niet weggeschreven waren lijken nooit gebeurd te zijn.  Zo
	  wordt een consistent bestandssysteem in stand gehouden dat
	  eruit ziet alsof het 30 tot 60 seconden eerder was.  Het
	  gebruikte algoritme garandeert dat alle bronnen die in gebruik
	  zijn als zodanig gemarkeerd worden in hun daarvoor geschikte
	  bitmaps: blokken en inodes.  Na een crash is de enige
	  allocatiefout die kan optreden dat bronnen gemarkeerd kunnen
	  zijn als in gebruik (<quote>used</quote>), terwijl ze
	  feitelijk alweer beschikbaar (<quote>free</quote>) zijn.
	  &man.fsck.8; herkent deze situatie en stelt dergelijke vrij
	  te maken bronnen opnieuw beschikbaar.  Het is volkomen veilig
	  om na een crash te negeren dat het bestandssysteem niet schoon
	  is en het tot aankoppelen te dwingen met
	  <command>mount&nbsp;-f</command>.  Om niet langer gebruikte
	  bronnen vrij te maken moet later &man.fsck.8; uitgevoerd
	  worden.  Dit is dan ook het idee achter <emphasis>background
	    fsck</emphasis>: op het moment dat het systeem aan het
	  opstarten is, wordt er alleen een
	  <emphasis>snapshot</emphasis> van het systeem bewaard.
	  <command>fsck</command> kan later uitgevoerd worden.  Alle
	  bestandssystemen kunnen <quote>dirty</quote> aangekoppeld
	  worden en het systeem kan gewoon verder opstarten naar
	  meergebruikermodus.  Vervolgens zijn er
	  <command>fsck</command>s gepland die in de achtergrond draaien
	  voor elk bestandssysteem dat niet schoon is en waarmee
	  bezette bronnen vrijgegeven worden.  Bestandssystemen die geen
	  gebruik maken van softupdates moeten echter nog steeds gebruik
	  maken van de normale <command>fsck</command> in de
	  voorgrond.</para>

	 <para>Het voordeel van softupdates is dat operaties op
	   metagegevens bijna net zo snel zijn als asynchrone updates
	   (dat wil zeggen sneller dan met <emphasis>logging</emphasis>,
	   waarbij de metagegevens keer op keer geschreven worden).
	   Nadelen zijn de complexiteit van de code (wat een groter
	   risico op bugs impliceert in een gebied dat bijzonder
	   gevoelig is voor verlies van gebruikersgegevens) en een
	   groter geheugenverbruik.  Tevens moet de gebruiker wennen aan
	   enkele eigenaardigheden.  Na een crash lijkt de toestand van
	   het bestandssysteem wat <quote>ouder</quote>.  In situaties
	   waar de standaard synchrone benadering een aantal lege
	   bestanden zou hebben achtergelaten na
	   <command>fsck</command>, is het met softupdates juist zo dat
	   dergelijke bestanden er helemaal niet zijn, omdat de
	   metagegevens of de bestandsinhoud nooit naar de schijf zijn
	   geschreven.  Schijfruimte wordt pas vrijgegeven als de
	   bijwerkingen aan metagegevens en inhoudelijke
	   bestandsgegevens weggeschreven zijn, wat mogelijk pas enige
	   tijd na het uitvoeren van <command>rm</command> plaatsvindt.
	   Dit kan problemen veroorzaken als er grote hoeveelheden
	   gegevens naar een bestandssysteem geschreven worden dat
	   onvoldoende vrije ruimte heeft om alle bestanden twee keer te
	   kunnen bevatten (bijvoorbeeld in <filename>/tmp</filename>).</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Fijnafstemming van kernellimieten</title>

    <indexterm>
      <primary>fijnafstemming</primary>

      <secondary>kernellimieten</secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Bestandsproceslimieten</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm><primary><varname>kern.maxfiles</varname></primary></indexterm>

	<para><varname>kern.maxfiles</varname> kan worden verhoogd of
	  verlaagd, afhankelijk van de systeembehoeften.  Deze variabele
	  geeft het maximale aantal bestandsdescriptors op een systeem.
	  Als de bestandsdescriptortabel vol is, toont de systeembuffer
	  meerdere malen <errorname>file: table is full</errorname>, het
	 geen achteraf te zien is met <command>dmesg</command>.</para>

	<para>Elk geopend bestand, socket of fifo heeft een
	  bestandsdescriptor.  Een grote produktieserver kan makkelijk
	  enige duizenden bestandsdescriptors nodig hebben, afhankelijk
	  van het soort en aantal diensten die tegelijk draaien.</para>

	<para>In oudere versies van &os; werd de standaard waarde van
	  <varname>kern.maxfiles</varname> afgeleid van de optie
	  <option>maxusers</option> in het kernelconfiguratiebestand.
	  <varname>kern.maxfiles</varname> groeit evenredig met de
	  waarde van <literal>maxusers</literal>.  Als een aangepaste
	  kernel wordt gebouwd, is het een goed idee om deze kerneloptie
	  in te stellen afhankelijk van het gebruikt van een systeem
	  (maar niet te laag).  Hoewel een produktieserver misschien
	  niet 256 gelijktijdige gebruikers heeft, kunnen de benodigde
	  systeembronnen het beste vergeleken worden met een
	  grootschalige webserver.</para>

	<para>De optie <literal>maxusers</literal> stelt de grootte van
	  een aantal belangrijke systeemtabellen in.  Dit aantal moet
	  ruwweg gelijk zijn aan het aantal gebruikers dat verwacht
	  wordt gelijktijdig van de machine gebruik te maken.</para>

	<para>Vanaf &os;&nbsp;4.5 wordt <varname>kern.maxusers</varname>
	  automatisch ingesteld tijdens het opstarten gebaseerd op de
	  hoeveelheid beschikbare geheugen in het systeem en kan worden
	  vastgesteld tijdens het draaien door te kijken naar de
	  alleen-lezen sysctl <varname>kern.maxusers</varname>.  Sommige
	  configuraties hebben grotere of kleinere waarden nodig van
	  <varname>kern.maxusers</varname>, deze kunnen worden gezet
	  als een opstartvariabele.  Waardes van 64, 128 en 256 zijn
	  daarin niet ongewoon.  We raden aan om niet boven de 256 te
	  gaan tenzij er heel veel bestandsdescriptors benodigd zijn;
	  veel van de aanpasbaare waarden die standaard worden bepaald
	  door <varname>kern.maxusers</varname> kunnen individueel
	  worden overschreven tijdens het opstarten en/of tijdens het
	  draaien van het systeem in
	  <filename>/boot/loader.conf</filename> (zie de handleiding
	  &man.loader.conf.5; of het bestand
	  <filename>/boot/defaults/loader.conf</filename> voor een paar
	  aanwijzingen) of zoals elders beschreven in dit document.
	  <!--(rene) kill next sentence-->
	  Systemen die ouder zijn dan &os;&nbsp;4.4 moeten deze waarden
	  instellen via de kerneloptie &man.config.8;
	  <option>maxusers</option>.</para>

	<!--(rene) kill next sentence-->
	<para>Voor oudere versies stelt het systeem deze waarde zelf in
	  als deze uitdrukkelijk op <literal>0</literal> is gezet.

	  <footnote>
	    <para>Het auto-tuning-algoritme stelt
	      <literal>maxusers</literal> in afhankelijk van de
	      hoeveelheid geheugen in het systeem, met een minimum van
	      32 en een maximum van 384.</para>
	  </footnote></para>

	<para>Als het gewenst is om deze waarde zelf aan te geven, wordt
	  aangeraden om <literal>maxusers</literal> minstens op 4 te
	  zetten, met name als het X Window systeem in gebruik is of als
	  er software gecompileerd wordt.  De reden hiervoor is dat de
	  belangrijkste tabel die door <literal>maxusers</literal>
	  ingesteld wordt, het maximum aantal processen is, dat
	  ingesteld wordt op <literal>20 + 16 * maxusers</literal>, dus
	  als <literal>maxusers</literal> op 1 ingesteld wordt, zijn er
	  maar 36 gelijktijdige processen mogelijk, inclusief de
	  ongeveer achttien processen die door het systeem tijdens het
	  opstarten start en de ongeveer vijftien processen die
	  waarschijnlijk aangemaakt worden door het opstarten van het X
	  Window systeem.  Zelfs een eenvoudige taak als het afbeelden
	  van een hulppagina start negen processen op om de pagina te
	  filteren, te decomprimeren en af te beelden.  Als
	  <literal>maxusers</literal> op 64 ingesteld wordt, zijn er
	  1044 gelijktijdige processen mogelijk, wat genoeg moet zijn
	  voor bijna alle soorten gebruik.  Als echter de gevreesde
	  fout <errortype>proc table full</errortype> verschijnt als er
	  geprobeerd wordt om een programma op te starten of als er een
	  server gedraaid wordt met een groot aantal gelijktijdige
	  gebruikers, zoals <hostid
	    role="fqdn">ftp.FreeBSD.org</hostid>, kan het getal altijd
	  verhoogd worden en kan de kernel opnieuw gebouwd
	  worden.</para>

	<note>
	  <para><literal>maxusers</literal> stelt
	    <emphasis>geen</emphasis> grens aan het aantal gebruikers
	    dat zich op de machine kan aanmelden.  Het stelt gewoon
	    verschillende tabelgroottes in op redelijke waardes,
	    uitgaande van het maximum aantal gebruikers dat
	    waarschijnlijk de machine gebruikt en van het aantal
	    processen dat elk van deze gebruikers zal draaien.  Een
	    sleutelwoord dat <emphasis>wel</emphasis> het aantal
	    gelijktijdige aanmeldingen op afstand en X-terminalvensters
	    begrensd is <link
	      linkend="kernelconfig-ptys"><literal>pseudo-device pty
		16</literal></link>.  In &os;&nbsp;5.X kan dit getal
	    genegeerd worden omdat daar het stuurprogramma &man.pty.4;
	    <quote>auto-cloning</quote> is.  Er kan eenvoudig gebruik
	    worden gemaakt van de regel <literal>device pty</literal>
	    in het instellingenbestand.</para>
	</note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm><primary><varname>kern.ipc.somaxconn</varname></primary></indexterm>

	<para>De sysctl-variabele <varname>kern.ipc.somaxconn</varname>
	  beparkt de grootte van de luisterwachtrij voor het accepteren
	  van nieuwe TCP-verbindingen.  De standaardwaarde van
	  <literal>128</literal> is meestal te laag voor robuuste
	  behandeling van nieuwe verbindingen in een zwaarbeladen
	  webserveromgeving.  Voor zulke omgevingen wordt aangeraden
	  deze waarde te verhogen tot <literal>1024</literal> of hoger.
	  De dienstdaemon beperkt misschien zelf de luisterwachtrij
	  (bijvoorbeeld &man.sendmail.8; of
	  <application>Apache</application>), maar heeft vaak een
	  mogelijkheid in een configuratiebestand de wachtrijgrootte
	  aan te passen.  Grote luisterwachtrijen zijn ook beter in het
	  ontwijken van Ontzegging van Dienst (<abbrev>DoS</abbrev>)
	  aanvallen.</para>
      </sect3>
    </sect2>

    <sect2 id="nmbclusters">
      <title>Netwerkbeperkingen</title>

      <para>De kerneloptie <literal>NMBCLUSTERS</literal> bepaalt het
	aantal netwerk-Mbufs dat beschikbaar is voor een systeem.  Een
	veel bezochte server met een laag aantal Mbufs beperkt de
	mogelijkheden van &os;.  Elk cluster staat voor ongeveer
	2&nbsp;K geheugen, dus een waarde van 1024 stelt 2 megabyte
	aan kernelgeheugen voor, dat is gereserveerd voor
	netwerkbuffers.  Een simpele berekening geeft aan hoeveel er
	nodig is.  Stel dat een webserver met een maximum van 1000
	simultane verbindingen voor elke verbinding 16&nbsp;K aan
	ontvangstnetwerkbuffers en 16&nbsp;K aan zendbuffers kost, dan
	is ongeveer 32&nbsp;MB aan netbuffers nodig voor de webserver.
	Een goede vuistregel is te vermeniguldigen met twee, dus
	2x32&nbsp;MB&nbsp;/ 2&nbsp;KB&nbsp;= 64&nbsp;MB&nbsp;/
	2&nbsp;kB&nbsp;= 32768.  Voor machines met veel geheugen wordt
	4096 tot 32768 aangeraden.  Er moet in geen geval een arbitrair
	hoge waarde voor deze sysctl opgegeven worden, want dat kan
	leiden tot een crash tijdens het opstarten.  Met de optie
	<option>-m</option> van &man.netstat.1; kan het clustergebruik
	van het netwerk bekeken worden.</para>

      <para>De loaderparameter <varname>kern.ipc.nmbclusters</varname>
	moet gebruikt worden om dit tijdens het opstarten toe te passen.
	Alleen voor oudere versies van &os; is het nodig om de
	kerneloptie <literal>NMBCLUSTERS</literal> te gebruiken.</para>

      <para>Voor drukke servers die extensief gebruik maken van de
	systeemaanroep &man.sendfile.2;, kan het nodig zijn het aantal
	&man.sendfile.2;-buffers te verhogen via de kerneloptie
	<literal>NSFBUFS</literal> of door de waarde in te stellen in
	<filename>/boot/loader.conf</filename> (in &man.loader.8; staan
	details).  Als er in de procestabel processen staan met een
	status <literal>sfbufa</literal> is dat een algemene indicator
	dat deze parameter aangepast moet worden.  De sysctl-variabele
	<varname>kern.ipc.nsfbufs</varname> is alleen-lezen en laat zien
	op welke waarde deze kernelvariabele is ingesteld.  Deze
	parameter schaalt engiszins met de variabele
	<varname>kern.maxusers</varname>, maar het kan nodig zijn om
	deze bij te stellen.</para>

      <important>
	<para>Zelfs als een socket als non-blocking gemarkeerd is, dan
	  nog kan het aanroepen van &man.sendfile.2; op de non-blocking
	  socket ertoe leiden dat er toch blokkade optreedt totdat er
	  voldoende <literal>struct sf_buf</literal>'s vrijgemaakt
	  zijn.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm><primary>net.inet.ip.portrange.*</primary></indexterm>

	<para>De sysctl-variabelen
	  <varname>net.inet.ip.portrange.*</varname> bepalen welke reeks
	  poortnummers automatisch gebonden wordt aan TCP- en
	  UDP-sockets.  Er zijn drie gebieden: een laag gebied, een
	  (standaard) middengebied en een hoog gebied.  De meeste
	  netwerkprogramma's gebruiken het standaardbereik, wat
	  begrensd wordt door
	  <varname>net.inet.ip.portrange.first</varname> en
	  <varname>net.inet.ip.portrange.last</varname> met
	  standaardwaarden van respectievelijk 1024 en 5000.  Gebonden
	  poortreeksen worden gebruikt voor uitgaande verbindingen en
	  het is onder bepaalde omstandigheden mogelijk dat poorten op
	  raken.  Dit gebeurt meestal in het geval van een zwaar belaste
	  webproxy.  Poortbereik is niet van belang als vooral diensten
	  draaien die zich bezighouden met inkomende verbindingen, zoals
	  een normale webserver, of als het aantal uitgaande
	  verbindingen beperkt is, zoals bij een mailrelay.  Voor
	  situaties waarin een tekort aan poorten dreigt, wordt
	  aangeraden om <varname>net.inet.ip.portrange.last</varname>
	  bescheiden op te hogen.  Een waarde van
	  <literal>10000</literal>, <literal>20000</literal> of
	  <literal>30000</literal> is redelijk.  Er moet ook rekening
	  met effecten op firewalls gehouden worden als de poortreeks
	  gewijzigd wordt.  Sommige firewalls kunnen grote poortreeksen
	  blokkeren, meestal de lagere poorten, en verwachten dat andere
	  systemen hogere poorten gebruiken voor uitgaande verbindingen.
	  Om deze reden wordt het niet aanbevolen om
	  <varname>net.inet.ip.portrange.first</varname> te
	  verlagen.</para>
      </sect3>

      <sect3>
	<title>TCP Bandbreedtevertragingsproduct (TCP Bandwidth Delay
	  Product)</title>

	<indexterm>
	  <primary>TCP bandbreedtevertragingsproduct</primary>

	  <secondary><varname>net.inet.tcp.inflight.enable</varname></secondary>
	</indexterm>

	<para>De TCP-bandbreedtevertragingsproductlimitatie lijkt op
	  TCP/Vegas in NetBSD.  Het kan aangezet worden door de
	  sysctl-variabele
	  <varname>net.inet.tcp.inflight.enable</varname> de waarde
	  <literal>1</literal> te geven.  Het systeem tracht dan het
	  bandbreedtevertragingssprodukt te berekenen voor elke
	  verbinding en beperkt dan de hoeveelheid gegevens in de
	  wachtrij naar het netwerk tot de hoeveelheid die vereist is om
	  maximale doorvoer te kunnen handhaven.</para>

	<para>Dit is nuttig bij gebruik van modems, Gigabit Ethernet of
	  zelfs bij WAN-verbindingen met hoge snelheid (of elke andere
	  verbinding met een groot bandbreedtevertragingsprodukt), in
	  het bijzonder als ook windowschaling of een groot
	  verzendwindow gebruikt wordt.  Als deze optie aangezet wordt,
	  dient ook <varname>net.inet.tcp.inflight.debug</varname> de
	  waarde <literal>0</literal> te krijgen (geen debugging) en
	  voor produktiegebruik kan het instellen van
	  <varname>net.inet.tcp.inflight.min</varname> naar minstens
	  <literal>6144</literal> voordeel opleveren.  Het instellen van
	  hoge minima kan effectief het beperken van bandbreedte
	  ondermijnen, afhankelijk van de verbinding.  De mogelijkheid
	  tot limitering zorgt ervoor dat de hoeveelheid gegevens die
	  opgebouwd wordt, in tussentijdse route- en switchwachtrijen
	  verlaagd kan worden en tevens kan de hoeveelheid gegevens die
	  opgebouwd wordt in de interfacewachtrij van de lokale host
	  verlaagd worden.  Met minder pakketten in wachtrijen kunnen
	  interactieve verbindingen opereren met lagere
	  <emphasis>Round Trip</emphasis> tijden, met name over langzame
	  modems.  Deze optie gaat alleen over datatransmissie (upload /
	  serverkant) en heeft geen effect gegevensontvangst (download /
	  cli&euml;ntkant).</para>

	<para>Aanpassen van
	  <varname>net.inet.tcp.inflight.stab</varname> wordt
	  <emphasis>niet</emphasis> aangeraden.  Deze parameter krijgt
	  standaard een waarde van 20, wat 2 maximale pakketten opgeteld
	  bij de bandbreedtevensterberekening representeert.  Het extra
	  venster is nodig om het algoritme stabiel te houden en om de
	  reactietijd bij veranderende omstandigheden te verbeteren,
	  maar het kan ook leiden tot langere pingtijden over langzame
	  verbindingen (zonder het inflight-algoritme kan dit echter nog
	  erger zijn).  In dergelijke gevallen kan deze parameter
	  misschien verlaagd worden naar 15, 10 of 5 en misschien moet
	  voor het gewenste effect ook
	  <varname>net.inet.tcp.inflight.min</varname> verlaagd worden
	  (bijvoorbeeld naar 3500).  Het verlagen van deze parameters
	  moet pas in laatste instantie overwogen worden.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Virtueel Geheugen</title>

      <sect3>
	<title><varname>kern.maxvnodes</varname></title>

	<para>Een vnode is de interne representatie van een bestand of
	  een map.  Het verlagen van het aantal beschikbare vnodes voor
	  het besturingssysteem leidt dus tot een daling van schijf-I/O.
	  Normaliter wordt dit door het besturingssysteem afgehandeld en
	  hoeft de instelling niet gewijzigd te worden.  Im sommige
	  gevallen kan schijf-I/O de beperkende factor zijn en kan het
	  systeem alle beschikbare vnodes in gebruik hebben.  Dan dient
	  deze instelling gewijzigd te worden.  De hoeveelheid inactief
	  en beschikbaar RAM dient meegenomen te worden in de
	  beslissing.</para>

	<para>Het huidige aantal gebruikte vnodes kan als volgt bekeken
	  worden:</para>

	<screen>&prompt.root; <userinput>sysctl vfs.numvnodes</userinput>
vfs.numvnodes: 91349</screen>

	<para>Om het maximale aantal vnodes weer te geven:</para>

	<screen>&prompt.root; <userinput>sysctl kern.maxvnodes</userinput>
kern.maxvnodes: 100000</screen>

	<para>Als het huidige aantal gebruikte vnodes dicht bij het
	  maximale aantal ligt, is het verstandig om
	  <varname>kern.maxvnodes</varname> op te hogen met 1.000.
	  Ook <varname>vfs.numvnodes</varname> dient in de gaten
	  gehouden te worden.  Als de waarde weer tot aan het maximum
	  stijgt, dan moet <varname>kern.maxvnodes</varname> verder
	  opgehoogd worden.  Er dient een verschuiving op te treden in
	  het door &man.top.1; gerapporteerde geheugengebruik.  Er hoort
	  meer geheugen actief te zijn.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Wisselbestandruimte toevoegen</title>

    <para>Hoe goed er ook gepland wordt, soms draait een systeem gewoon
      niet zoals verwacht.  Een oorzaak hiervoor kan een tekort aan
      wisselbestandruimte zijn.  Als blijkt dat er meer
      wisselbestandruimte nodig is, kan dat eenvoudig.  Er zijn drie
      manieren om de totale ruimte beschikbaar als wisselbestand te
      vergroten: een nieuwe harde schijf toevoegen, swappen over NFS of
      een wisselbestand maken op een bestaande (UFS of andere)
      partitie.</para>

    <para>Kijk voor informatie over het beveiligen van het
      wisselbestand, welke opties hiervoor bestaan, en waarom dit gedaan
      zou moeten worden in <xref linkend="swap-encrypting"> van het
      handboek.</para>

    <sect2 id="new-drive-swap">
      <title>Wisselbestand (partitie) op een nieuwe harde schijf</title>

      <para>Dit is natuurlijk de beste manier om de wisselbestandsruimte
	te vergroten en een goed excuus om een extra harde schijf toe te
	voegen.  Die komt immers altijd wel van pas.  In dat geval kan
	het beste de discussie over wisselbestandruimte in <xref
	  linkend="configtuning-initial"> nog eens herlezen worden om
	wat suggesties op te doen over hoe wisselbestandpartitie(s) het
	beste ingedeeld kunnen worden.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swappen over NFS</title>

      <para>In het algemeen wordt swappen over NFS niet aangeraden
	behalve als het onmogelijk is om naar een lokale schijf te
	swappen.  NFS-swappen wordt gelimiteerd door de hoeveelheid
	beschikbare bandbreedte en belast het de NFS-server.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Wisselbestanden</title>

      <para>Het is mogelijk om een bestand aan te maken van een bepaalde
	grootte en dit als swap te gebruiken.  In dit voorbeeld wordt
	een bestand van 64&nbsp;MB gebruikt,
	<filename>/usr/swap0</filename>.  Uiteraard kan een willekeurige
	naam gebruikt worden.</para>

      <example>
	<title>Een wisselbestand aanmaken op &os;</title>

	<orderedlist>
	  <listitem>
	    <para>De kernel moet het stuurprogramma voor de
	      geheugenschijf (&man.md.4;) bevatten.  Dat zit standaard
	      in de kernel <filename>GENERIC</filename>.</para>

	    <programlisting>device md   # Memory "disks"</programlisting>
	  </listitem>

	  <listitem>
	    <para>Het wisselbestand <filename>/usr/swap0</filename>
	      aanmaken:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>De correcte rechten op <filename>/usr/swap0</filename>
	      instellen:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Het wisselbestand opnemen in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Instellen op naam van wisselbestand als hulpwisselbestand gewenst is</programlisting>
	  </listitem>

	  <listitem>
	    <para>De machine moet herstart worden of om het
	      wisselbestand direct in te schakelen:</para>

	    <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</userinput></screen>
	  </listitem>
	</orderedlist>
      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Geschreven door </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Energie- en bronnenbeheer</title>

    <para>Het is belangrijk om hardwarebronnen op een effici&euml;nte
      wijze te benutten.  Voordat <acronym>ACPI</acronym>
      ge&iuml;ntroduceerd werd was het lastig en onflexibel om het
      energieverbruik en de thermische eigenschappen van een systeem te
      beheersen.  De hardware werd beheerst de <acronym>BIOS</acronym>
      en dus had de gebruiker minder controle en zichtbaarheid in de
      energiebeheerinstellingen.  Enige gelimiteerde configuratie was
      mogelijk via <emphasis>Advanced Power Management (APM)</emphasis>.
      Energie- en bronnenbeheer is een belangrijk onderdeel van moderne
      machines.  Het besturingssysteem moet bijvoorbeeld systeemlimieten
      in de gaten houdt (en mogelijk een SMS sturen of iets dergelijks)
      als de systeemtemperatuur onverwacht toeneemt.</para>

    <para>In dit deel van het &os; handboek wordt uitgebreide informatie
      verschaft over <acronym>ACPI</acronym>.  Aan het einde worden
      referenties geleverd naar meer leesmateriaal.</para>

    <sect2 id="acpi-intro">
      <title>Wat is ACPI?</title>

      <indexterm><primary>ACPI</primary></indexterm>

      <indexterm><primary>APM</primary></indexterm>

      <para>Advanced Configuration and Power Interface
	(<acronym>ACPI</acronym>) is een standaard die door een
	alliantie van producenten geschreven is, met als doel te
	voorzien in een een standaardinterface voor hardwarebronnen- en
	energiebeheer.  Een belangrijk element is dat het meer
	flexibiliteit en beheersmogelijkheden biedt aan het
	besturingssysteem (<acronym>OS</acronym>).  Moderne systemen
	hebben de limieten van de huidige PNP-interfaces verder opgerekt
	dan wenselijk en misschien wel mogelijk was.
	<acronym>ACPI</acronym> is de directe opvolger van
	<acronym>APM</acronym> (Advanced Power Management).  Centraal is
	het verleggen van hardwarebeheer en -monitoring naar de OS-laag
	in plaats van de zeer beperkte BIOS-laag.</para>
    </sect2>

    <sect2 id="acpi-old-spec">
      <title>Tekortkomingen van APM</title>

      <para>Met de <emphasis>Advanced Power Management (APM)</emphasis>
	faciliteit kan het energieverbruik van een systeem geregeld
	worden op basis van de systeemactiviteit.  Het APM-BIOS wordt
	geleverd door de systeemproducent of -verkoper en het is
	specifiek voor dat betreffende hardwareplatform.  Een
	APM-stuurprogramma in het besturingssysteem regelt vervolgens de
	toegang tot de <emphasis>APM Software Interface</emphasis>, die
	het besturen van vermogensniveau mogelijk maakt.  APM dient nog
	steeds gebruikt te worden met systemen die gefabriceerd zijn
	voor het jaar 2000.</para>

      <para>Er zijn vier hoofdproblemen met APM te onderscheiden: ten
	eerste wordt het energiebeheer verricht door een BIOS
	(afhankelijk van producent) en het besturingssysteem heeft daar
	geen kennis van.  De gebruiker die idle-time waarden instelt
	voor een harde schijf in het APM-BIOS is hier een voorbeeld van.
	Dan zal het BIOS de harde schijf langzamer kunnen laten draaien
	zonder dat het besturingssysteem de noodzaak ziet of het
	goedkeurt.  Ten tweede: de APM-logica is ingebed in de BIOS,
	waardoor het buiten het besturingssysteem om opereert.  Dit
	houdt in dat gebruikers problemen met hun APM-BIOS alleen kunnen
	verhelpen door een nieuw BIOS in het ROM te flashen, wat een
	gevaarlijke en mogelijk onherstelbare operatie is.  Ten derde is
	APM een producent-specifieke technologie, in de zin dat er
	altijd een hoge mate van duplicatie zal zijn van al dan niet
	geslaagde pogingen om het wiel opnieuw uit te vinden en
	uiteraard ook van bugs.  Er is geen enkele garantie dat het
	wegnemen van een bug door een producent ook een zelfde bug
	wegneemt bij een concurrent.  Tenslotte is het van belang te
	weten dat de APM-BIOS in het algemeen gewoon te weing geheugen
	kon gebruiken om een ingewikkeld energiebeheer te kunnen
	implementeren.  Laat staan dat deze goed aanpasbaar was aan
	veranderlijke doelstellingen voor de betreffende machine.</para>

      <para><emphasis>Plug-n-play BIOS (PNPBIOS)</emphasis> was in veel
	situaties onbetrouwbaar.  PNPBIOS is 16-bitstechnologie, dus het
	besturingssysteem moet 16-bit emulatie gebruiken om met
	PNPBIOS-methoden te kunnen samenwerken.</para>

      <para>Het &os;-stuurprogramma <acronym>APM</acronym> is
	gedocumenteerd in &man.apm.4;.</para>
    </sect2>

    <sect2 id="acpi-config">
      <title><acronym>ACPI</acronym> instellen</title>

      <para>Het stuurprogramma <filename>acpi.ko</filename> wordt
	standaard geladen bij het opstarten door de &man.loader.8; en
	hoeft <emphasis>niet</emphasis> gecompileerd te worden.  De
	redenatie is dat er met modules gemakkelijker gewerkt kan
	worden, bijvoorbeeld een andere <filename>acpi.ko</filename>
	gebruiken zonder dat er een nieuwe kernel gebouwd moet worden.
	Dit heeft het voordeel dat testen eenvoudiger is.  Een andere
	reden is dat het opstarten van <acronym>ACPI</acronym> nadat
	een systeem eenmaal volledig opgestart is meestal niet goed
	werkt.  Mocht er hinder ondervonden worden, dan kan
	<acronym>ACPI</acronym> beter uitgeschakeld worden.  Dit
	stuurprogramma kan niet gestopt worden als het eenmaal geladen
	is, omdat de systeembus het gebruikt voor allerlei interacties
	met hardware.  <acronym>ACPI</acronym> kan uitgezet worden door
	het instellen van <literal>hint.acpi.0.disabled="1"</literal> in
	<filename>/boot/loader.conf</filename> of in de &man.loader.8;
	prompt.</para>

      <note>
	<para><acronym>ACPI</acronym> en <acronym>APM</acronym>
	  kunnen niet samenleven en moeten afzonderlijk en exclusief
	  gebruikt worden.  De laatste die gestart wordt bepaalt of het
	  stuurprogramma de ander wel of niet ziet.</para>
      </note>

      <para>In haar eenvoudigste vorm kan <acronym>ACPI</acronym>
	gebruikt worden om het systeem in slaapmodus te zetten met
	&man.acpiconf.8; met de vlag <option>-s</option> en een optie
	<literal>1-5</literal>.  De meeste gebruikers hebben alleen
	<literal>1</literal> of <literal>3</literal> nodig.  De optie
	<literal>5</literal> verricht een <quote>soft-off</quote>, wat
	hetzelfde is als:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Andere opties zijn mogelijk via &man.sysctl.8;.  Zie de
	handleidingen van &man.acpi.4; en &man.acpiconf.8; voor meer
	informatie.</para>
    </sect2>
  </sect1>

  <sect1 id="ACPI-debug">
    <sect1info>
      <authorgroup>
	 <author>
	   <firstname>Nate</firstname>
	   <surname>Lawson</surname>
	   <contrib>Geschreven door </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	 <author>
	   <firstname>Peter</firstname>
	   <surname>Schultz</surname>
	   <contrib>Met medewerking van </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	 <author>
	   <firstname>Tom</firstname>
	   <surname>Rhodes</surname>
	 </author>
      </authorgroup>
    </sect1info>

    <title>&os; <acronym>ACPI</acronym> gebruiken en debuggen</title>

    <para><acronym>ACPI</acronym> is een totaal nieuwe manier om
      apparaten te ontdekken, om energieverbruik te beheren en om een
      gestandaardiseerde toegang te bieden tot allerlei apparaten die
      eerder via het <acronym>BIOS</acronym> beheerd werden.  Er wordt
      voortdurend vooruitgang geboekt om <acronym>ACPI</acronym> op alle
      systemen te laten werken, maar bugs in de
      <firstterm><acronym>ACPI</acronym>Machine Language</firstterm>
      (<acronym>AML</acronym>) bytecode van sommige moederborden,
      onvolledigheden in de subsystemen van de kernel van &os; en bugs
      in de &intel; <acronym>ACPI-CA</acronym> interpreter blijven
      opduiken.</para>

    <para>Deze tekst is bedoeld om u te helpen met het bijstaan van de
      &os; <acronym>ACPI</acronym> beheerders met het vinden van de
      hoofdoorzaken van problemen die u opmerkt en met het debuggen en
      het vinden van een oplossing.</para>

    <sect2 id="ACPI-submitdebug">
      <title>Debuginformatie aanleveren</title>

      <note>
	<para>Voordat een probleem wordt gemeld, moet het zeker zijn dat
	  de laatste <acronym>BIOS</acronym> versie draait en indien
	  beschikbaar de ge&iuml;ntregeerde controller firmware
	  versie.</para>
      </note>

      <para>Diegenen die meteen een probleem willen indienen, sturen de
	volgende informatie naar <ulink
	  url="mailto:freebsd-acpi@FreeBSD.org">
	  freebsd-acpi@FreeBSD.org</ulink>:</para>

      <itemizedlist>
	<listitem>
	  <para>Omschrijving van het foutieve gedrag, inclusief
	    systeemtype en -model en alles wat de fout kan veroorzaken.
	    Als het een nieuw fenomeen is, dan dient ook zo accuraat
	    mogelijk aangegeven te worden wanneer de fout het eerst
	    optrad.</para>
	</listitem>

	<listitem>
	  <para>De uitvoer van &man.dmesg.8; van <command>boot
	      -v</command>, inclusief foutmeldingen die gegenereerd
	    worden als de fout optreedt.</para>
	</listitem>

	<listitem>
	  <para>De uitvoer van &man.dmesg.8; van <command>boot
	      -v</command> met <acronym>ACPI</acronym> uitgeschakeld,
	    indien het uitzetten van <acronym>ACPI</acronym> het
	    probleem oplost.</para>
	</listitem>

	<listitem>
	  <para>Uitvoer van <command>sysctl hw.acpi</command>.  Dit is
	    tevens een goede manier om uit te vinden welke
	    <acronym>ACPI</acronym>-mogelijkheden een systeem
	    heeft.</para>
	</listitem>

	<listitem>
	  <para>Een <acronym>URL</acronym> waar de
	    <firstterm><acronym>ACPI</acronym>Source
	      Language</firstterm> (<acronym>ASL</acronym>) gevonden
	    kan worden.  De <acronym>ASL</acronym> dient
	    <emphasis>niet</emphasis> rechtstreeks naar de lijst
	    gezonden te worden, omdat deze nogal groot kan zijn.  Een
	    kopie van een ASL kan gemaakt worden met het volgende
	    commando:</para>

	  <screen>&prompt.root; <userinput>acpidump -dt &gt; <replaceable>naam</replaceable>-<replaceable>systeem</replaceable>.asl</userinput></screen>

	  <para>(Vervang uw aanmeldnaam door
	    <filename>$NAME</filename> en producent/model door
	    <filename>$SYSTEM</filename>.  Bijvoorbeeld:
	    <filename>njl-FooCo6000.asl</filename>)</para>
	</listitem>
      </itemizedlist>

      <para>De meeste &os;-programmeurs lezen de &a.current;, maar
	problemen gaan bij voorkeur ook naar &a.acpi.name; zodat ze
	zeker gezien worden.  Het kan enige tijd duren voordat er
	antwoord komt, omdat deze mensen elders ook nog volledige banen
	hebben.  Als de bug niet meteen duidelijk is, komt er
	waarschijnlijk en verzoek om een <acronym>PR</acronym> in te
	dienen via &man.send-pr.1;.  Als er een <acronym>PR</acronym>
	moet worden opgesteld, dan dient alle hierboven gevraagde
	informatie vermeld te worden.  Dit helpt om het probleem te
	kunnen volgen en oplossen.  Het sturen van een
	<acronym>PR</acronym> zonder eerst &a.acpi.name; te mailen is
	niet wenselijk, aangezien men <acronym>PR</acronym>s gebruikt
	als herinnering van bestaande problemen, niet als
	rapportagesysteem.  Mogelijk is een probleem al eens door iemand
	anders gemeld.</para>
    </sect2>

    <sect2 id="ACPI-background">
      <title>Achtergrond</title>

      <para><acronym>ACPI</acronym> is aanwezig op alle moderne
	computers die voldoen aan de ia32 (x86), ia64 (Itanium) of amd64
	(AMD) architecturen.  De volledige standaard heeft vele
	mogelijkheden zoals <acronym>CPU</acronym>-prestatiebeheer,
	energiebeheer, thermische zones, diverse batterijsystemen,
	ingebedde controllers en busnummering.  De meeste systemen
	implementeren minder dan de volledige standaard.  Een
	desktopsysteem implementeert bijvoorbeeld meestal alleen
	busnummering, terwijl laptops mogelijk ook koeling- en
	batterijbeheer ondersteunen.  Laptops hebben ook suspend en
	resume (slapen en wakker worden) met hun eigen aanverwante
	comlexiteit.</para>

      <para>Een <acronym>ACPI</acronym>-compliant systeem heeft
	verscheidene componenten.  Het <acronym>BIOS</acronym>- en
	chipsetverkopers bieden verscheidene vaste tabellen aan zoals
	<acronym>FADT</acronym> in het geheugen die zaken als de
	<acronym>APIC</acronym>-afbeelding (gebruikt voor
	<acronym>SMP</acronym>), configuratieregisters, en eenvoudige
	configuratiewaarden specificeren.  Ook wordt er een tabel van
	bytecode (de <firstterm>Differentiated System
	  Description Table</firstterm> of <acronym>DSDT</acronym>)
	geleverd die een op een boomstructuur lijkende namespace biedt
	voor apparaten en methoden.</para>

      <para>Het stuurprogramma <acronym>ACPI</acronym> moet de
	voorgedefinieerde tabellen verwerken, een interpreter voor de
	bytecode implementeren en apparaatstuurprogramma's en de kernel
	aanpassen om informatie van het
	<acronym>ACPI</acronym>-subsysteem te accepteren.  &intel; heeft
	een interpreter beschikbaar gesteld (<acronym>ACPI-CA</acronym>)
	die door &os; en ook door &linux; en NetBSD gebruikt wordt.  De
	<acronym>ACPI-CA</acronym>-broncode staat in <filename
	  class="directory">src/sys/contrib/dev/acpica</filename>.  De
	lijmcode die <acronym>ACPI-CA</acronym> laat werken met &os;
	staat in <filename class="directory">src/sys/dev/acpica/Osd</filename>.
	Stuurprogramma's die verscheidene
	<acronym>ACPI</acronym>-apparaten implementeren staan in
	<filename class="directory">src/sys/dev/acpica</filename>.</para>
    </sect2>

    <sect2 id="ACPI-comprob">
      <title>Algemene problemen</title>

      <para>Wil <acronym>ACPI</acronym> goed werken, dan moeten alle
	onderdelen goed werken.  Hieronder staan enkele algemene
	problemen in volgorde van hoe vaak ze optreden en enkele
	mogelijke oplossingen of manieren om de problemen te
	vermijden.</para>

      <sect3>
	<title>Muisproblemen</title>

	<para>Soms doet een muis het niet bij het opstarten uit de
	  slaapstand.  Een bekend lapmiddel is het toevoegen van
	  <literal>hint.psm.0.flags="0x3000"</literal> aan het bestand
	  <filename>/boot/loader.conf</filename>.  Als dat niet werkt,
	  dan wordt aangeraden een bugrapport in te sturen, zoals
	  eerder is beschreven.</para>
      </sect3>

      <sect3>
	<title>Suspend/resume</title>

	<para><acronym>ACPI</acronym> heeft drie slaapstanden waarbij
	  het geheugen (<acronym>RAM</acronym>) wordt ingezet.  Dit
	  zijn de <acronym>STR</acronym>-toestanden
	  <literal>S1</literal>-<literal>S3</literal>, en nog een
	  slaap-met-gebruik-van-harde-schijf toestand
	  (<literal>STD</literal>) die <literal>S4</literal> heet.
	  <literal>S5</literal> is <quote>zacht uit</quote> en is de
	  normale status van een systeem als het is aangesloten maar
	  niet is aangezet.  <literal>S4</literal> kan feitelijk op twee
	  manieren ge&iuml;mplementeerd worden:
	  <literal>S4</literal><acronym>BIOS</acronym> is een slaapstand
	  naar schijf met behulp van het <acronym>BIOS</acronym> en
	  <literal>S4</literal><acronym>OS</acronym> wordt volledig door
	  het besturingssysteem ge&iuml;mplenteerd.</para>

	<para>als eerste dienen de <command>sysctl hw.acpi</command>
	  items die iets met de slaapstand te maken hebben gecontroleerd
	  te worden.  Hieronder staan de resultaten voor een
	  Thinkpad:</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</screen>

	<para>Dit betekent dat hier <command>acpiconf -s</command>
	  gebruikt kan worden om <literal>S3</literal>,
	  <literal>S4</literal><acronym>OS</acronym> en
	  <literal>S5</literal> te testen.  Als <option>s4bios</option>
	  gelijk was aan (<literal>1</literal>), dan zou er
	  <literal>S4</literal><acronym>BIOS</acronym> ondersteuning
	  zijn in plaats van <literal>S4</literal>
	  <acronym>OS</acronym>.</para>

	<para>Als suspend/resume getest moet worden, dient, indien
	  ondersteund, bij <literal>S1</literal> begonnen te worden.
	  Deze toestand heeft de grootste kans om te werken, omdat deze
	  niet veel stuurprogrammaondersteuning vereist.  Niemand heeft
	  nog <literal>S2</literal> ge&iuml;mplementeerd, maar het is
	  ongeveer hetzelfde als <literal>S1</literal>.  Daarna wordt
	  <literal>S3</literal> getest.  Dit is het diepste
	  <acronym>STR</acronym>-niveau en heeft uitgebreide
	  ondersteuning van stuurprogramma's nodig om hardware goed
	  opnieuw te kunnen starten.  Mochten er blokkades optreden,
	  dan kan naar de &a.acpi.name; lijst gemaild worden.  Er kan
	  echter geen snelle oplossing verwacht worden, omdat er nog de
	  nodige stuurprogramma's/hardware liggen om getest en bewerkt
	  te worden.</para>

	<para>Een veelvoorkomend probleem met suspend/resume is dat veel
	  apparaatstuurprogramma's hun firmware, registers of apparaatgeheugen
	  niet fatsoenlijk opslaan, herstellen, of herinitialiseren.  Een
	  eerste poging om het probleem te vinden omvat:</para>

	<screen>&prompt.root; <userinput>sysctl debug.bootverbose=1</userinput>
&prompt.root; <userinput>sysctl debug.acpi.suspend_bounce=1</userinput>
&prompt.root; <userinput>acpiconf -s 3</userinput></screen>

	<para>Deze test emuleert de suspend/resume-cyclus van alle
	  apparaten zonder daadwerkelijk naar de toestand <literal>S3</literal>
	  te gaan.  In sommige gevallen kunt u zo eenvoudig problemen
	  vaststellen (bijvoorbeeld het verliezen van de firmware-toestand,
	  timeout van de apparaatwaakhond, en steeds opnieuw iets proberen).
	  Merk op dat het systeem niet werkelijk naar de toestand
	  <literal>S3</literal> gaat, wat inhoudt dat apparaten geen spanning
	  verliezen waardoor velen prima zullen werken zelfs als de
	  suspend/resume-methoden geheel ontbreken, dit in tegenstelling tot de
	  echte toestand <literal>S3</literal>.</para>

	<para>Moeilijkere gevallen vereisen aanvullende hardware, dat is een
	  serie&euml;le poort/kabel voor de serie&euml;le console of een
	  Firewire poort/kabel voor &man.dcons.4;, en vaardigheden in het
	  debuggen van de kernel.</para>

	<para>Om een probleem te kunnen isoleren helpt het om zoveel
	  mogelijk stuurprogramma's uit de kernel te halen.  Als dit
	  werkt, kan er teruggewerkt worden naar het stuurprogramma dat
	  schuldig is aan het falen.  Meestal vertonen binaire
	  stuurprogramma's als <filename>nvidia.ko</filename>, X11
	  beeldschermstuurprogramma's en <acronym>USB</acronym> de
	  meeste problemen, terwijl bijvoorbeeld Ethernet-interfaces
	  meestal meteen goed werken.  Als de stuurprogramma's zonder
	  problemen geladen en verwijderd kunnen worden, dan is dit te
	  automatiseren door de juiste commando's in
	  <filename>/etc/rc.suspend</filename> en
	  <filename>/etc/rc.resume</filename> te zetten.  Er staat een
	  voorbeeld (achter commentaartekens) voor het laden en
	  verwijderen van een stuurprogramma.  Als het beeldscherm er na
	  wakker worden vreemd uitziet, kan geprobeerd worden
	  <option>hw.acpi.reset_video</option> op nul te zetten.  Met
	  langere of kortere waarden voor
	  <option>hw.acpi.sleep_delay</option> kan bekeken worden of dat
	  helpt.</para>

	<para>In geval van problemen is het ook een optie om een recente
	  &linux; distibutie met ondersteuning voor
	  <acronym>ACPI</acronym> support te starten en daarvan de
	  suspend/resume ondersteuning op dezelfde hardware uit te
	  proberen.  Als het werkt met &linux;, dan is het
	  waarschijnlijk een &os; stuurprogrammaprobleem en als het
	  mogelijk is uit te vinden over welk stuurprogramma het gaat,
	  kan dat bijdragen aan het oplossen van het probleem.
	  <acronym>ACPI</acronym> houdt zich in het algemeen niet bezig
	  met andere stuurprogramma's zoals geluid,
	  <acronym>ATA</acronym>, enzovoort.  Als er dus een echt
	  probleem met een stuurprogramma is, dan is waarchijnlijk
	  uiteindelijk ook nodig naar de &a.current.name; lijst te
	  posten en naar de beheerder van het stuurprogramma.  Voor
	  degenen met moed is het vooral aan te raden een paar
	  &man.printf.3;s in problematische stukken van een
	  stuurprogramma te plaatsen voor debugging om na te gaan waar
	  de resumefunctie precies hangt.</para>

	<para>Tot slot kan geprobeerd worden om <acronym>ACPI</acronym>
	  uit te zetten en in plaats daarvan <acronym>APM</acronym> aan
	  te zetten.  Als suspend/resume werkt met
	  <acronym>APM</acronym>, is het wellicht verstandig het daarbij
	  te houden, vooral met wat oudere apparatuur (voor 2000).
	  Producenten hebben nogal wat tijd nodig gehad om
	  <acronym>ACPI</acronym> ondersteuning goed te krijgen en voor
	  oudere hardware is het waarschijnlijker dat er
	  <acronym>BIOS</acronym>-problemen zijn met
	  <acronym>ACPI</acronym>.</para>
      </sect3>

      <sect3>
	<title>Systeem hangt (tijdelijk of permanent)</title>

	<para>Meestal is het hangen van het systeem het gevolg van
	  verloren interrupts of een interruptstorm.  Chipsets kunnen
	  een heleboel problemen hebben, afhankelijk van hoe het
	  <acronym>BIOS</acronym> interrupts instelt voor het opstarten,
	  of de <acronym>APIC</acronym> (<acronym>MADT</acronym>) tabel
	  correct is en de routering van het <firstterm>System Control
	    Interrupt</firstterm> (<acronym>SCI</acronym>).</para>

	<indexterm><primary>interruptstorms</primary></indexterm>

	<para>Interruptstorms kunnen onderscheiden worden van verloren
	  geraakte interrupts door de uitvoer van <command>vmstat
	    -i</command> te controleren en de regel met
	  <literal>acpi0</literal> goed te lezen.  Als de teller in
	  toenemende mate hoger staat dan enkele per seconde, dan is
	  sprake van een interruptstorm.  Als het systeem lijkt te
	  hangen, is het wellicht nog mogelijk door te dringen tot
	  de <acronym>DDB</acronym> (<keycombo
	    action="simul"><keycap>CTRL</keycap>
	    <keycap>ALT</keycap><keycap>ESC</keycap></keycombo>) en
	  <literal>show interrupts</literal> uit te voeren.</para>

	<indexterm>
	  <primary>APIC</primary>

	  <secondary>uitschakelen</secondary>
	</indexterm>

	<para>De beste hoop in geval van interruptproblemen is om
	  <acronym>APIC</acronym>-ondersteuning uit te zetten met
	  <literal>hint.apic.0.disabled="1"</literal> in
	  <filename>loader.conf</filename>.</para>
      </sect3>

      <sect3>
	<title>Panics</title>

	<para>Panics zijn relatief zeldzaam met <acronym>ACPI</acronym>
	  en krijgen de hoogste prioriteit bij het oplossen.  Eerst
	  moeten de verschillende gebeurtenissen waarmee de panic (als
	  mogelijk) te reproduceren is ge&iuml;soleerd worden en moet
	  een backtrace gemaakt worden.  <literal>options DDB</literal>
	  dient aangezet te worden en er dient een een seri&euml;le
	  console (<xref linkend="serialconsole-ddb">) of een
	  &man.dump.8; partitie te komen.  In <acronym>DDB</acronym> is
	  een backtrace te maken met <literal>tr</literal>.  Als de
	  backtrace handmatig opgeschreven moet worden, is het
	  belangrijk dat in ieder geval de bovenste en onderste vijf (5)
	  regels van de backtrace genoteerd worden.</para>

	<para>Daarna dient getracht te worden het systeem te starten
	  zonder <acronym>ACPI</acronym>.  Als dat werkt, is het
	  <acronym>ACPI</acronym>-subsysteem ge&iuml;soleerd en kunnen
	  de verschillende <option>debug.acpi.disable</option>-waarden
	  uitgeprobeerd worden.  In &man.acpi.4; staan enkele
	  voorbeelden.</para>
      </sect3>

      <sect3>
	<title>Systeem slaat aan na slaapstand of stop</title>

	<para><literal>hw.acpi.disable_on_poweroff="0"</literal> kan
	  uitgezet worden in &man.loader.conf.5;.  Hierdoor schakelt
	  <acronym>ACPI</acronym> bepaalde gebeurtenissen tijdens het
	  afsluitproces niet uit.  Om dezelfde redenen moeten sommige
	  systemen deze waarde altijd op <literal>1</literal>
	  (standaard) hebben staan.  In het algemeen lost dit een
	  probleem op waarbij een systeem spontaan weer opkomt nadat het
	  in slaapstand is gezet of geheel gestopt is.</para>
      </sect3>

      <sect3>
	<title>Overige problemen</title>

	<para>Als er nog andere problemen zijn met
	  <acronym>ACPI</acronym> (met een docking station of
	  apparaten niet gedetecteerd, enzovoort), dan kan een mail met
	  beschijving naar de mailinglijst gezonden worden.  Sommige
	  zaken kunnen echter gerelateerd zijn aan delen van het
	  <acronym>ACPI</acronym>-subsysteem die nog niet af zijn,
	  dus het kan in sommige gevallen een tijd duren.  Gebruikers
	  moeten soms geduld en de bereidheid om eventuele
	  patches uit te proberen hebben.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>, <command>acpidump</command> en
	<acronym>IASL</acronym></title>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>ASL</secondary>
      </indexterm>

      <para>Het grootste probleem is dat
	<acronym>BIOS</acronym>-producenten vaak incorrecte (of gewoon
	foutieve) bytecode leveren.  Dit blijkt doorgaans uit
	kernelboodschappen als:</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>Vaak kunnen dergelijke problemen geoplost worden door de
	<acronym>BIOS</acronym> bij te werken tot de laatste revisie.
	De meeste consoleberichten zijn onschuldig, maar als er andere
	problemen zijn, zoals batterijstatus die niet werkt, dan ligt
	het voor de hand te zoeken naar problemen in de
	<acronym>AML</acronym>-code.  De bytecode die
	<acronym>AML</acronym> genoemd wordt, wordt gecompileerd van een
	broncodetaal <acronym>ASL</acronym>.  Deze staat weer in een
	tabel <acronym>DSDT</acronym>.  Met &man.acpidump.8; kan een
	kopie van de <acronym>ASL</acronym> gemaakt worden.  Dan moeten
	zowel de opties <option>-t</option> (laat inhoud van vaste
	tabellen zien) als <option>-d</option> (disassembleer
	<acronym>AML</acronym> naar <acronym>ASL</acronym>) gebruikt
	worden.  In <link linkend="ACPI-submitdebug">Debuginformatie
	  aanleveren</link> staat een voorbeeld.</para>

      <para>De eenvoudigste eerste controle is de
	<acronym>ASL</acronym>-code opnieuw compileren en kijken of er
	foutmeldingen optreden.  Waarschuwingen kunnen doorgaans
	genegeerd worden, maar fouten zijn bugs die er meestal toe
	leiden dat <acronym>ACPI</acronym> niet correct werkt.  Om
	<acronym>ASL</acronym> te hercompileren:</para>

      <screen>&prompt.root; <userinput>iasl eigen.asl</userinput></screen>
    </sect2>

    <sect2 id="ACPI-fixasl">
      <title><acronym>ASL</acronym> repareren</title>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>ASL</secondary>
      </indexterm>

      <para>Op langere termijn is het de bedoeling dat voor vrijwel elke
	machine <acronym>ACPI</acronym> werkt zonder enig ingrijpen van
	de gebruiker.  Op dit moment wordt er echter nog gewerkt aan
	oplossingen voor veel voorkomende vergissingen die
	<acronym>BIOS</acronym>-producenten maken.  De &microsoft;
	interpreter (<filename>acpi.sys</filename> en
	<filename>acpiec.sys</filename>) controleert niet strikt of het
	<acronym>BIOS</acronym> volledig aan de standaard voldoet,
	waardoor het voorkomt dat <acronym>BIOS</acronym>-makers die
	alleen testen onder &windows; bepaalde fouten in hun
	<acronym>ASL</acronym> nooit correct repareren.  &os; hoopt door
	te gaan met de identificatie en documentatie van welk
	niet-standaard gedrag precies wordt toegelaten door
	&microsoft;'s interpreter en te dit te repliceren zodat &os;
	kan werken zonder dat gebruikers zich gedwongen zien om de
	<acronym>ASL</acronym> te repareren.  Als een tijdelijke
	oplossing en om te helpen met het in kaart brengen van bepaald
	gedrag, kan de <acronym>ASL</acronym> handmatig gerepareerd
	worden.  Mocht dit lukken, dan wordt erop aangedrongen een
	&man.diff.1; van de oude en de nieuwe <acronym>ASL</acronym> te
	mailen, zodat het foutieve gedrag mogelijk in
	<acronym>ACPI-CA</acronym> kan worden verwerkt, waardoor andere
	gebruikers niet meer handmatig met hun <acronym>ASL</acronym>
	aan de gang hoeven.</para>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>foutmeldingen</secondary>
      </indexterm>

      <para>Hieronder staat een lijst algemene foutmeldingen, hun
	oorzaken en hoe ze op te lossen:</para>

      <sect3>
	<title>_OS afhankelijkheden</title>

	<para>Sommige <acronym>AML</acronym>s gaan ervan uit dat de
	  wereld enkel bestaat uit &windows; versies.  &os; kan zich
	  voordoen als elk <acronym>OS</acronym> om te kijken of dit
	  problemen oplost.  Een gemakkelijke manier om dit te doen is
	  <literal>hw.acpi.osname="Windows 2001"</literal> in te stellen
	  in <filename>/boot/loader.conf</filename> of andere
	  gelijksoortige strings die in een <acronym>ASL</acronym>
	  staan.</para>
      </sect3>

      <sect3>
	<title>Ontbrekende return-opdrachten</title>

	<para>Sommige methoden hebben geen specifieke returnwaarde,
	  zoals wel vereist wordt door de standaard.  Hoewel
	  <acronym>ACPI-CA</acronym> hier niets mee doet, heeft &os;
	  de mogelijkheid tot impliciete returns.  Er kunnen ook
	  expliciete return-opdrachten toegevoegd worden waar vereist,
	  als het bekend is welke waarden teruggevoerd moeten worden.
	  Om <command>iasl</command> te dwingen tot compilatie van
	  <acronym>ASL</acronym> kan de schakeloptie
	  <option>-f</option> gebruikt worden.</para>
      </sect3>

      <sect3>
	<title>De standaard <acronym>AML</acronym> aanpassen</title>

	<para>Nadat <filename>eigen.asl</filename> aangepast is, kan
	  deze als volgt gecompileerd worden:</para>

	<screen>&prompt.root; <userinput>iasl eigen.asl</userinput></screen>

	<para>Met de optie <option>-f</option> is af te dwingen dat de
	  <acronym>AML</acronym> gemaakt wordt, zelfs als er
	  compileerfouten optreden.  Sommige fouten (zoals ontbrekende
	  return-opdrachten) worden automatisch opgelost door de
	  interpreter.</para>

	<para><filename>DSDT.aml</filename> is de standaardnaam voor het
	  bestand dat door <command>iasl</command> wordt geproduceerd.
	  Dit is in plaats van de foutieve versie uit het
	  <acronym>BIOS</acronym> (die nog steeds aanwezig is in het
	  flashgeneugen) te laden door
	  <filename>/boot/loader.conf</filename> als volgt te
	  wijzigen:</para>

	<programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

	<para><filename>DSDT.aml</filename> moet in de map <filename
	    class="directory">/boot</filename> staan.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-debugoutput">
      <title>Debuguitvoer van <acronym>ACPI</acronym> verkrijgen</title>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>problemen</secondary>
      </indexterm>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>debuggen</secondary>
      </indexterm>

      <para>Het stuurprogramma <acronym>ACPI</acronym> heeft een zeer
	flexibele debugfaciliteit.  Er kan zowel een verzameling van
	subsystemen aangegeven worden als het niveau van uitvoerigheid.
	De te debuggen subsystemen worden aangegeven als lagen
	(<quote>layers</quote>) en zijn opgedeeld in
	<acronym>ACPI-CA</acronym>-componenten (ACPI_ALL_COMPONENTS) en
	<acronym>ACPI</acronym>-hardware-ondersteuning
	(ACPI_ALL_DRIVERS).  De uitvoerigheid van debuguitvoer wordt
	aangegeven als het niveau (<quote>level</quote>) en gaat van
	CPI_LV_ERROR (alleen fouten rapporteren) tot ACPI_LV_VERBOSE
	(alles).  Het niveau is een bitmasker en dus kunnen er meerdere
	opties tegelijk ingeschakeld worden (gescheiden door spaties).
	In de praktijk wordt wellicht een seri&euml;le console gebruikt
	om de uitvoer te loggen als deze zo omvangrijk is dat de
	console berichtbuffer vol loopt (misschien wel meerdere keren).
	Een complete lijst van de individuele lagen en niveaus staat in
	&man.acpi.4;.</para>

      <para>Debuguitvoer staat standaard niet aan.  Door
	<literal>options ACPI_DEBUG</literal> toe te voegen aan het
	bestand met kernelinstellingen als <acronym>ACPI</acronym> als
	de kernel is gebouwd, wordt het ingeschakeld.  Door
	<literal>ACPI_DEBUG=1</literal> toe te voegen aan
	<filename>/etc/make.conf</filename> wordt het systeembreed
	ingeschakeld.  Als <acronym>ACPI</acronym> als module wordt
	gebruikt (de normale situatie), dan hoeft slechts de module
	<filename>acpi.ko</filename> opnieuw gecompileerd te
	worden:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp;
make ACPI_DEBUG=1</userinput></screen>

      <para><filename>acpi.ko</filename> moet in
	<filename class="directory">/boot/kernel</filename> komen te
	staan en de gewenste debuglaag en het gewenste niveau van
	uitvoerigheid dienen toegevoegd te worden aan
	<filename>loader.conf</filename>.  Hieronder een voorbeeld
	waarmee debuguitvoer wordt aangezet voor alle
	<acronym>ACPI-CA</acronym>-componenten en alle
	<acronym>ACPI</acronym>-hardware-stuurprogramma's
	(<acronym>CPU</acronym>, <acronym>LID</acronym>, enzovoort.
	Het niveau van uitvoerigheid is het laagst mogelijke.  Er
	worden alleen fouten gemeld.</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Als de gezochte informatie wordt veroorzaakt door een
	specifieke gebeurtenis (bijvoorbeeld in en uit slaapstand gaan),
	dan kunnen wijzigingen aan <filename>loader.conf</filename>
	achterwege blijven en in plaats daarvan kan
	<command>sysctl</command> gebruikt worden om laag en niveau in
	te stellen na het opstarten en zo het systeem voor te bereiden
	op die specifieke gebeurtenis.  De <command>sysctl</command>s
	hebben dezelfde namen als de parameters in
	<filename>loader.conf</filename>.</para>
    </sect2>

    <sect2 id="ACPI-References">
      <title>Verwijzingen</title>

      <para>Meer informatie over <acronym>ACPI</acronym> staat op de
	volgende locaties:</para>

      <itemizedlist>
	<listitem>
	  <para>De &a.acpi;</para>
	</listitem>

	<listitem>
	  <para>De <acronym>ACPI</acronym> mailinglijst archieven
	    <ulink
	      url="http://lists.freebsd.org/pipermail/freebsd-acpi/">
	    </ulink></para>
	</listitem>

	<listitem>
	  <para>De oude <acronym>ACPI</acronym> mailinglijst archieven
	    <ulink url="http://home.jp.FreeBSD.org/mail-list/acpi-jp/">
	    </ulink></para>
	</listitem>

	<listitem>
	  <para>De <acronym>ACPI</acronym> 2.0 specificatie
	    <ulink url="http://acpi.info/spec.htm">
	    </ulink></para>
	</listitem>

	<listitem>
	  <para>&os; Handleidingen: &man.acpi.4;,
	    &man.acpi.thermal.4;, &man.acpidump.8;, &man.iasl.8;,
	    &man.acpidb.8;</para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
	      <acronym>DSDT</acronym> debugging informatie</ulink>.
	    (Gebruikt Compaq als voorbeeld, maar van algemeen
	    nut).</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
