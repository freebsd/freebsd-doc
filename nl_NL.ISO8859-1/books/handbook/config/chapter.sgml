<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$
     $FreeBSDnl: nl_NL.ISO8859-1/books/handbook/config/chapter.sgml,v 1.81 2005/08/15 20:54:56 siebrand Exp $
     Gebaseerd op: 1.211
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschreven door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Naar een tutorial van </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Tevens gebaseerd op tuning(7) door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Danny</firstname>
	<surname>Pansters</surname>
	<contrib>Vertaald door </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Instellingen en optimalisatie</title>

  <sect1 id="config-synopsis">
    <title>Overzicht</title>

    <indexterm><primary>systeeminstellingen</primary></indexterm>

    <indexterm><primary>systeemoptimalisatie</primary></indexterm>

    <para>Systeeminstellingen zijn een belangrijk aspect van &os;.
      Correcte instellingen helpen moeilijkheden bij toekomstige
      upgrades te voorkomen.  In dit hoofdstuk wordt het instellen van
      &os; beschreven, alsmede een aantal prestatiebevorderende
      maatregelen waarmee een &os; systeem geoptimaliseerd kan
      worden.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>Hoe effici&euml;nt om te gaan met bestandssystemen en
	  wisselpartities;</para>
      </listitem>

      <listitem>
	<para>De grondbeginselen van het <filename>rc.conf</filename>
	  instellingensysteem en van het opstarten van toepassingen
	  (diensten) met
	  <filename>/usr/local/etc/rc.d</filename>;</para>
      </listitem>

      <listitem>
	<para>Hoe een netwerkkaart ingesteld en getest wordt;</para>
      </listitem>

      <listitem>
	<para>Hoe virtuele hosts op netwerkapparatuur ingesteld
	  worden;</para>
      </listitem>

      <listitem>
	<para>Hoe de instellingenbestanden in
	  <filename>/etc</filename> gebruikt worden;</para>
      </listitem>

      <listitem>
	<para>Hoe &os; geoptimaliseerd kan worden met
	  <command>sysctl</command> variabelen;</para>
      </listitem>

      <listitem>
	<para>Hoe schijfprestaties te verbeteren en hoe
	  kernelbeperkingen gewijzigd kunnen worden.</para>
      </listitem>
    </itemizedlist>

    <para>Veronderstelde voorkennis:</para>

    <itemizedlist>
      <listitem>
	<para>De &unix; en &os; grondbeginselen (<xref
	    linkend="basics">) begrijpen;</para>
      </listitem>

      <listitem>
	<para>Bekend zijn met de grondbeginselen van kernelinstellingen
	  en compilatie (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Initi&euml;le instellingen</title>

    <sect2>
      <title>Partitioneren</title>

      <indexterm><primary>partitioneren</primary></indexterm>

      <indexterm><primary><filename>/etc</filename></primary></indexterm>

      <indexterm><primary><filename>/var</filename></primary></indexterm>

      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
	<title>Basispartities</title>

	<para>Bij het aanmaken van bestandssystemen met
	  &man.disklabel.8; of &man.sysinstall.8; is het van belang
	  dat op een harde schijf de data-overdracht het snelst is aan
	  de buitenste sporen en het langzaamst aan de binnenste.
	  Kleinere en veelgebruikte bestandssystemen kunnen daarom het
	  beste aan het begin van de schijf geplaatst worden, terwijl
	  grotere partities als <filename>/usr</filename> meer naar het
	  einde van de schijf geplaatst kunnen worden.  Het is een goed
	  idee om partities aan te maken in deze of gelijksoortige
	  volgorde: root, swap, <filename>/var</filename>,
	  <filename>/usr</filename>.</para>

	<para>De grootte van <filename>/var</filename>
	  hangt af van de wijze waarop de machine gebruikt gaat worden.
	  <filename>/var</filename> wordt gebruikt voor onder meer
	  mailboxen, logbestanden en printerdata en -wachtrijen.
	  Mailboxen en logbestanden kunnen onverwacht groot worden,
	  afhankelijk van het aantal systeemgebruikers en de bewaarduur
	  van logbestanden.  Meestal is minder dan een gigabyte
	  voldoende.  <filename>/var/tmp</filename> moet wel groot
	  genoeg moet zijn om packages te kunnen bevatten.</para>

	<para>De partitie <filename>/usr</filename> bevat veel van de
	  benodigde systeembestanden.  Die bevat tevens de
	  &man.ports.7;collectie (aanbevolen) en de broncode
	  (optioneel).  Beide zijn optioneel tijdens de installatie.
	  Voor deze partitie wordt tenminste 2 gigabyte
	  aanbevolen.</para>

	<para>Het is verstandig rekening te houden met de vereiste
	  schijfruimte bij het kiezen van partitiegroottes.  Als in een
	  partitie onvoldoende vrije schijfruimte is, terwijl een
	  andere vrijwel niet gebruikt wordt, is dat een vervelend
	  en niet optimaal oplosbaar probleem.</para>

	<note>
	  <para>&man.sysinstall.8;'s <literal>Auto-defaults</literal>
	    partitiekeuze kan in de ervaring van sommige gebruikers
	    mogelijk te kleine <filename>/var</filename> en
	    <filename>/</filename> partities opleveren.  Partitioneren
	    moet verstandig en niet te zuinig gebeuren.</para>
	</note>
      </sect3>

      <sect3 id="swap-design">
	<title>Wisselpartities (swap)</title>

	<indexterm><primary>swap grootte</primary></indexterm>

	<indexterm><primary>wisselpartitie</primary></indexterm>

	<indexterm><primary>wisselpartitiegrootte</primary></indexterm>

	<para>De vuistregel is dat het wisselbestand ongeveer het
	  dubbele van de grootte van het systeemgeheugen (RAM) moet
	  zijn.  Als de machine bijvoorbeeld 128&nbsp;megabytes
	  geheugen heeft, kan het beste een wisselbestand van
	  (tenminste) 256&nbsp;megabytes gebruikt worden.  Minder
	  dan 256&nbsp;megabytes swap is in dit geval af te raden.
	  Systemen met weinig geheugen kunnen overigens beter
	  functioneren met meer swap.  Ook is het verstandig rekening
	  te houden met eventuele geheugenuitbreiding in de toekomst.
	  Bovendien zijn de VM paging algoritmen van de kernel zo
	  afgestemd dat ze het beste presteren bij een wisselbestand
	  van tenminste tweemaal de grootte van het geheugen.  Een te
	  kleine swap kan dus ineffici&euml;nties in de VM code tot
	  gevolg hebben en mogelijk problemen veroorzaken als het
	  systeemgeheugen uitgebreid wordt.</para>

	<para>Op grotere systemen met meerdere SCSI schijven (of
	  meerdere IDE schijven op verschillende controllers) is het
	  aan te raden om op elke schijf een wisselpartitie in te
	  stellen (dit kan tot en met vier schijven), elk met ongeveer
	  dezelfde grootte.  De kernel kan met arbitraire groottes
	  werken, maar interne datastructuren schalen tot viermaal de
	  grootste swappartitie.  De kernel kan de beschikbare ruimte
	  voor het wisselbestand het meest optimaal indelen als de
	  partities ongeveer even groot zijn.  Een grote swap is prima,
	  ook als ze zelden gebruikt wordt.  Zo kan het gemakkelijker
	  zijn om een (uit de hand gelopen) proces dat het systeem
	  grotendeels bezet houdt te be&euml;indigen, voordat er
	  opnieuw opgestart moet worden.</para>
      </sect3>

      <sect3>
	<title>Waarom partitioneren?</title>

	<para>Waarom niet &eacute;&eacute;n enkele grote partitie
	  gebruiken?  Er zijn verscheidene redenen waarom dit niet zo'n
	  goed idee is.  De verschillende partities hebben hun eigen
	  karakteristieke operationele gedrag en vereisten.  Door ze te
	  scheiden zijn er betere mogelijkheden om het systeem te
	  optimaliseren.  Vanaf de <filename>/</filename> en
	  <filename>/usr</filename> partities wordt bijvoorbeeld vooral
	  gelezen en er wordt weinig naar geschreven, terwijl er in
	  <filename>/var</filename> en <filename>/var/tmp</filename>
	  zowel veel gelezen als geschreven wordt.</para>

	<para>Door een systeem goed te partitioneren wordt vermeden dat
	  fragmentatie die optreedt in de kleinere partities met veel
	  schrijfactiviteit doorsijpelt naar partities die vooral
	  lees-intensief zijn.  Door schrijf-intensieve partities aan
	  het begin van de schijf te plaatsen, zijn de prestaties wat
	  betreft invoer/uitvoer het beste is daar waar het het
	  meest nodig is.  Ofschoon er natuurlijk ook de best mogelijke
	  in/uit prestaties wenselijk zijn in de grotere partities,
	  weegt het plaatsen van deze bestandssystemen aan het begin
	  van de schijf niet tegen de voordelen van het plaatsen van
	  <filename>/var</filename> aan het begin van de schijf (na
	  root en swap) voor de totale snelheid van het systeem.
	  Tenslotte zijn er veiligheidsoverwegingen.  Een compacte en
	  nette rootpartitie die vrijwel alleen-lezen is, heeft een
	  betere kans om een nare crash te overleven.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Hoofdinstellingen</title>

    <indexterm>
      <primary>rc bestanden</primary>

      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>De voornaamste lokatie voor systeeminstellingen is
      <filename>/etc/rc.conf</filename>.  Dit bestand bevat een scala
      aan instellingen, die gebruikt wordt om het systeem in te stellen
      bij het opstarten.  De naam impliceert dit al.  Het is informatie
      voor de <filename>rc*</filename> bestanden (rc staat voor
      <quote>resource configuration</quote> of
      broninstellingen).</para>

    <para>De systeembeheerder wordt geacht regels toe te voegen aan
      <filename>rc.conf</filename> om de standaardinstellingen uit
      <filename>/etc/defaults/rc.conf</filename> aan te passen.  Het
      standaardbestand moet niet letterlijk gekopi&euml;erd worden
      naar <filename>/etc</filename>.  Het bevat standaardwaardes en is
      niet bedoeld als voorbeeld.  Alle wijzigingen die specifiek
      zijn voor een systeem horen in <filename>/etc/rc.conf</filename>
      thuis.</para>

    <para>In een clusterscenario is het nuttig om systeemspecifieke
      instellingen te scheiden van algemene instellingen die voor het
      hele cluster gelden.  Hiervoor kunnen een aantal strategie&euml;n
      worden gebruikt.  De aanbevolen benadering is om gedeelde
      instellingen in een ander bestand te plaatsen, zoals
      <filename>/etc/rc.conf.site</filename> en dit invoegen in
      <filename>/etc/rc.conf</filename>, wat verder alleen
      systeemspecifieke informatie bevat.</para>

    <para>Aangezien <filename>rc.conf</filename> gelezen wordt door
      &man.sh.1; is dit eenvoudig te bereiken:</para>

    <itemizedlist>
      <listitem>
	<para>rc.conf:</para>

	<programlisting>. /etc/rc.conf.site
 hostname="node15.example.com"
 network_interfaces="fxp0 lo0"
 ifconfig_fxp0="inet 10.1.1.1"</programlisting>
      </listitem>

      <listitem>
	<para>rc.conf.site:</para>

	<programlisting>defaultrouter="10.1.1.254"
saver="daemon"
blanktime="100"</programlisting>
      </listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> kan dan naar elk systeem
      gedistribueerd worden met <command>rsync</command> of een
      gelijksoortig programma, terwijl <filename>rc.conf</filename>
      uniek blijft.</para>

    <para>Het actualiseren van het systeem met &man.sysinstall.8;
      of <command>make world</command> overschrijft
      <filename>rc.conf</filename> niet, zodat de bestaande
      systeeminstellingen niet verloren gaan.</para>
  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Toepassingen instellen</title>

    <para>Ge&iuml;nstalleerde toepassingen hebben meestal hun eigen
      instellingenbestanden, met hun eigen syntaxis, etc.  Het is van
      belang deze bestanden apart te houden van het basissysteem,
      zodat ze makkelijk gelokaliseerd kunnen worden en beheerd kunnen
      worden met de hulpmiddelen voor pakketbeheer.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Deze bestanden worden meestal ge&iuml;nstalleerd in
      <filename>/usr/local/etc</filename>.  Als een toepassing een
      uitgebreide set bestanden voor instellingen heeft, wordt er een
      submap voor aangemaakt.</para>

    <para>Bij de installatie van een port of package, worden normaliter
      ook voorbeeldbestanden met instellingen ge&iuml;nstalleerd.  Deze
      zijn doorgaans te herkennen aan een toevoegsel
      <filename>.default</filename>.  Als er geen bestaande
      instellingenbestanden voor de toepassing zijn, kunnen ze gemaakt
      worden door de <filename>.default</filename> bestanden te
      kopi&euml;ren.</para>

    <para>Een voorbeeld is de map
      <filename>/usr/local/etc/apache</filename>:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Aan de grootte van de bestanden is te zien dat alleen
      <filename>srm.conf</filename> gewijzigd is.  Als later de
      <application>Apache</application> port wordt vernieuwd, wordt dit
      bestand niet overschreven.</para>
  </sect1>

  <sect1 id="configtuning-starting-services">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Bijgedragen door </contrib>
	</author>
      </authorgroup>
    </sect1info>

      <title>Diensten starten</title>

      <indexterm><primary>diensten</primary></indexterm>

      <para>Veel gebruikers kiezen ervoor om software van derden te
	installeren op &os; vanuit de Portscollectie.  In veel gevallen
	is het noodzakelijk om de software dusdanig in te stellen dat
	het opstart tijdens het booten.  Diensten zoals <filename
	  role="package">mail/postfix</filename> of <filename
	  role="package">www/apache13</filename> zijn slechts twee
	voorbeelden van softwarepakketten die gestart kunnen worden
	tijdens de systeemstart.  In deze paragraaf wordt toegelicht
	hoe software van derde partijen kan worden gestart.</para>

      <para>In &os; worden de meeste diensten, zoals &man.cron.8;, door
	de opstartscripts van het systeem gestart.  Deze scripts kunnen
	verschillen tussen &os; en leverancierversies, echter het meest
	belangrijke aspect om in gedachten te houden is dat hun
	opstartinstellingen verwerkt kunnen worden door simpele
	opstartscripts.</para>

      <para>Voor de komst van rcNG zetten applicaties simpelweg een
	opstartscript in de map <filename
	  class="directory">/usr/local/etc/rc.d</filename> dat dan
	uitgelezen werd door de opstartscripts van het systeem.  Deze
	scripts werden dan uitgevoerd tijdens de laatste stappen van
	een systeemstart.</para>

      <para>Terwijl veel individuen bezig waren om de oude stijl van
	instellen naar de nieuwe stijl over te zetten, bleef sommige
	software nog steeds een script nodig hebben in de genoemde map.
	De subtiele verschillen in de scripts hangen af van het wel of
	niet gebruiken van rcNG.  V&oacute;&oacute;r &os;&nbsp;5.1
	werden scripts <quote>oude stijl</quote> gebruikt en in bijna
	alle gevallen voldoet een script <quote>nieuwe
	  stijl</quote>.</para>

      <para>Elk script moet een <filename>.sh</filename> toegevoegd
	hebben aan het einde en elk script moet opstartbaar zijn door
	het systeem.  Het laatstgenoemde kan bereikt worden met
	<command>chmod</command> en door het zetten van de rechten
	<literal>755</literal>.  Er zouden ook minimaal de opties
	<literal>start</literal> en <literal>stop</literal> moeten zijn
	voor de applicatie.</para>

      <para>Het simpelste opstartscript ziet er waarschijnlijk als
	volgt uit:</para>

      <programlisting>#!/bin/sh
echo -n ' utility'

case "$1" in
start)
        /usr/local/bin/utility
        ;;
stop)
        kill -9 `cat /var/run/utility.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0</programlisting>

      <para>Dit script levert de opties <literal>stop</literal> en
	<literal>start</literal> voor de applicatie met de naam
	<literal>utility</literal>.<para>

      <para>Dit kan handmatig gestart worden met:</para>

      <screen>&prompt.root; <userinput><filename>/usr/local/etc/rc.d/utility.sh</filename> start</userinput></screen>

      <para>Hoewel niet alle software van derden een regel nodig heeft
	in <filename>/etc/rc.conf</filename>, wordt er bijna elke
	dag een wel een port veranderd om deze instellingen te
	ondersteunen.  De meldingen tijdens de installatie van de port
	bevatten vaak meer informatie.  Sommige software
	van derden levert opstartscripts die de applicatie kunnen laten
	werken met rcNG.  Dit wordt in de volgende paragraaf
	behandeld.</para>

      <sect2>
	<title>Uitgebreide applicatieinstellingen</title>

	<para>Nu &os; rcNG heeft, zijn de instellingen van
	  applicaties die mee moeten opstarten verbeterd.  Er is meer
	  diepgang in gekomen.  Door gebruik te maken van de
	  sleutelwoorden die in de paragraaf <link
	    linkend="configtuning-rcNG">rcNG</link> behandeld worden,
	  kunnen applicaties nu starten na andere diensten.
	  <acronym>DNS</acronym> kan bijvoorbeeld extra opties
	  meekrijgen van <filename>/etc/rc.conf</filename> in plaats
	  van hard ingestelde opties in het opstartscript.  Een
	  basisscript ziet er ongeveer als volgt uit:</para>

	<programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# BEFORE: LOGIN
# KEYWORD: FreeBSD shutdown

#
# WIJZIG DEZE WAARDEN NIET HIER
# MAAR IN HET BESTAND /etc/rc.conf
#
utility_enable=${utility_enable-"NO"}
utility_flags=${utility_flags-""}
utility_pidfile=${utility_pidfile-"/var/run/utility.pid"}

. /etc/rc.subr

name="utility"
rcvar=`set_rcvar`
command="/usr/local/sbin/utility"

load_rc_config $name

pidfile="${utility_pidfile}"

start_cmd="echo \"Starting ${name}.\"; /usr/bin/nice -5 ${command} ${utility_flags} ${command_args}"

run_rc_command "$1"</programlisting>

	<para>Dit script zorgt ervoor dat
	  <application>utility</application> wordt gestart voor
	  de dienst <literal>login</literal>, maar na de dienst
	  <literal>daemon</literal>.  Het biedt ook de mogelijkheid
	  voor het instellingen en volgen van het
	  <acronym>PID</acronym> of het process <acronym>ID</acronym>
	  bestand.</para>

	<para>Voor deze applicatie kan dan de volgende regel in
	  <filename>/etc/rc.conf</filename> geplaatst worden:</para>

	<programlisting>utility_enable="YES"</programlisting>

	<para>Deze nieuwe methode maakt het volgende mogelijk:
	  makkelijker commandoregelopties manipuleren, importeren van
	  standaardfuncties uit <filename>/etc/rc.subr</filename>,
	  compatibiliteit met het &man.rcorder.8; programma en het
	  eenvoudiger instellingen via
	  <filename>/etc/rc.conf</filename>.  In essentie kan dit
	  script zelfs geplaatst worden in de map <filename
	    class="directory">/etc/rc.d</filename>.  Dat kan in
	  potentie wel het &man.mergemaster.8; programma van de wijs
	  brengen als dat gebruikt wordt voor het bijwerken van
	  software.</para>
    </sect2>

    <sect2>
      <title>Diensten met diensten starten</title>

      <para>Andere diensten, zoals <acronym>POP</acronym>3 server
	daemons, <acronym>IMAP</acronym>, enzovoort, kunnen gestart
	worden door gebruik te maken van &man.inetd.8;.  Daaraan is
	voorafgegaan dat die dienst uit de Portscollectie is
	ge&iuml;stalleerd en dat er een regel met instellingen is
	toegevoegd aan <filename>/etc/inetd.conf</filename> of
	&eacute;&eacute;n van de bestaande niet actieve regels is
	geactiveerd.  Werken met <application>inetd</application>
	en zijn instellingen wordt uitgebreid toegelicht in de
	paragraaf over <link
	  linkend="network-inetd">inetd</link>.</para>

      <para>In sommige gevallen is het handiger om &man.cron.8; te
	gebruiken om diensten te starten.  Deze aanpak heeft een aantal
	voordelen omdat <command>cron</command> start als de eigenaar
	van <filename>crontab</filename>.  Dit stelt reguliere
	gebruikers in staat om sommige applicaties te starten en te
	onderhouden.</para>

      <para><command>cron</command> levert een unieke optie: plaats van
	een tijdsspecificatie kan <literal>@reboot</literal> gebruikt
	worden.  Dit zorgt ervoor dat de taak gestart wordt als
	&man.cron.8; gestart wordt, meestal tijdens een
	systeemstart.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><command>cron</command> instellen</title>

    <indexterm>
      <primary>cron</primary>

      <secondary>instellen</secondary>
    </indexterm>

    <para>Een zeer nuttig hulpprogramma in &os; is &man.cron.8;.  De
      <command>cron</command> daemon draait op de achtergrond en
      controleert voortdurend <filename>/etc/crontab</filename>.  Ook
      controleert <command>cron</command> de map
      <filename>/var/cron/tabs</filename>, op zoek naar nieuwe
      <filename>crontab</filename> bestanden.  Deze
      <filename>crontab</filename> bestanden bevatten informatie over
      specifieke taken die <command>cron</command> moet verrichten op
      gezette tijden.</para>

    <para><command>cron</command> gebruikt twee verschillende soorten
      instellingenbestanden: de systeemcrontab en gebruikerscrontabs.
      Het enige verschil tussen deze twee formaten is het zesde veld.
      In de systeemcrontab is dit de gebruikersnaam die het commando
      uitvoert.  Hierdoor kunnen met de systeemcrontab commando's als
      iedere gebruiker uitgevoerd worden.  In een gebruikerscrontab is
      het zesde veld het uit te voeren commando en alle commando's
      worden uitgevoerd als de gebruiker die de crontab heeft
      aangemaakt.  Dit is een belangrijke veiligheidsmaatregel.</para>

    <note>
      <para>Gebruikerscrontabs geven individuele gebruikers de
	mogelijkheid om bepaalde terugkerende taken automatisch te
	laten uitvoeren zonder dat <username>root</username> rechten
	noodig zijn.  Commando's in de crontab van een gebruiker
	worden uitgevoerd met de rechten van de eigenaar.</para>

      <para><username>root</username> kan ook een gebruikerscrontab
	aanleggen.  Dit is niet dezelfde als
	<filename>/etc/crontab</filename> (de systeemcrontab).  Omdat
	er al een systeemcrontab is, is het doorgaans niet nodig om een
	gebruikerscrontab voor <username>root</username> te
	maken.</para>
    </note>

    <para><filename>/etc/crontab</filename> (de systeemcrontab) ziet er
      uit als volgt:</para>

    <programlisting># /etc/crontab - root's crontab for &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minuut uur     mdag    maand   wdag    wie     commando <co id="co-field-descr">
#
#
*/5     *       *       *       *       root    /usr/libexec/atrun <co id="co-main">

</programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Zoals in de meeste &os; instellingenbestanden gaat het
	  karakter <literal>#</literal> vooraf aan commentaar.
	  Commentaar wordt gebruikt als uitleg en geheugensteun.
	  Commentaar dient niet vermengd te worden met commando's,
	  anders wordt het commentaar opgevat als deel van het
	  commando.  Blanco regels worden genegeerd.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Eerst worden omgevingsvariabelen gedefini&euml;erd.
	  Hoervoor wordt het is-gelijk karakter (<literal>=</literal>)
	  gebruikt.  In het bovenstaande voorbeeld wordt het gebruikt
	  voor de variabelen <envar>SHELL</envar>, <envar>PATH</envar>
	  en <envar>HOME</envar>.  Als de regel <envar>SHELL</envar>
	  ontbreekt, gebruikt <command>cron</command> standaard
	  <command>sh</command> als shell.  Voor de omgevingsvariabele
	  <envar>PATH</envar> bestaat geen standaardwaarde.  Als
	  <envar>PATH</envar> ontbreekt moeten absolute paden
	  gebruikt worden.  Als <envar>HOME</envar> ontbreekt, gebruikt
	  <command>cron</command> de thuismap van de de gebruiker die
	  <command>cron</command> aanroept.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>In deze commentaarregel staan de zeven velden van een
	  crontabdefinitie.  Dit zijn <literal>minuut</literal>,
	  <literal>uur</literal>, <literal>mdag</literal>,
	  <literal>maand</literal>, <literal>wdag</literal>,
	  <literal>wie</literal> en <literal>commando</literal>.  De
	  betekenissen liggen voor de hand: <literal>minute</literal>
	  is het aantal minuten van het tijdstip waarop het commando
	  moet worden uitgevoerd; <literal>hour</literal> geeft het uur
	  aan; <literal>mdag</literal> staat voor de dag van de maand;
	  <literal>maand</literal> staat voor het maandnummer en
	  <literal>wdag</literal> geeft de dag van de week aan.  Het
	  veld <literal>wie</literal> is bijzonder en bestaat alleen in
	  <filename>/etc/crontab</filename>.  Het geeft aan als welke
	  gebruiker het commando uitgevoerd moet worden.  Een gebruiker
	  die zijn eigen <filename>crontab</filename> installeert,
	  heeft deze optie niet.  Het veld <literal>command</literal>
	  bevat het uit te voeren commando.</para>
      </callout>

      <callout arearefs="co-main">
	<para>In deze regel worden aan de hierboven besproken opties
	  waarden toegekend.  Er wordt gebruik gemaakt van
	  <literal>*/5</literal> en <literal>*</literal> karakters.
	  Deze betekenen <quote>eerst-laatst</quote> en kunnen gezien
	  worden als <emphasis>telkens</emphasis>.  In deze regel staat
	  dus dat het commando <command>atrun</command> elke vijf
	  minuten moet worden uitgevoerd door
	  <username>root</username>, ongeacht welke dag of maand het
	  is.  Meer informatie over <command>atrun</command> staat in
	  &man.atrun.8;.</para>

	<para>Commando's kunnen een willekeurig aantal opties of
	  argumenten meekrijgen.  Als commando's echter meerdere regels
	  nodig hebben moeten deze regels afgebroken worden met een
	  backslash <quote>\</quote> karakter, om aan te geven dat ze
	  op de volgende regel vervolgd worden.</para>
      </callout>
    </calloutlist>

    <para>Dit is de basisopzet voor elk <filename>crontab</filename>
      bestand.  De enige uitzondering is de aanwezigheid van veld zes,
      waar de gebruikersnaam wordt aangegeven.  Dit veld bestaat alleen
      in het systeembestand <filename>/etc/crontab</filename>.  Voor
      <filename>crontab</filename>bestanden van individuele gebruikers
      moet dit veld worden weggelaten.</para>

    <sect2 id="configtuning-installcrontab">
      <title>Een crontab installeren</title>

      <important>
	<para>De onderstaande procedure moet niet gebruikt worden om de
	  systeemcrontab te wijzigen of te installeren.  Er kan een
	  gewone editor gebruikt worden.  <command>cron</command>
	  ziet dat het bestand veranderd is en begint direct met het
	  gebruiken van de nieuwe versie.  <ulink
	    url="&url.books.faq;/admin.html#ROOT-NOT-FOUND-CRON-ERRORS">Deze
	  FAQ vraag</ulink> geeft verdere uitleg.</para>
      </important>

      <para>Om een nieuwe <filename>crontab</filename> te installeren
	moet eerst een bestand in het juiste formaat gemaakt worden en
	daarna moet het geiuml;nstalleerd worden met
	<command>crontab</command> commando:</para>

      <screen>&prompt.root; <userinput>crontab crontabbestand</userinput></screen>

      <para>In dit voorbeeld is <filename>crontabbestand</filename> de
	naam van een eerder gemaakt
	<filename>crontab</filename>bestand.</para>

      <para>Er bestaat ook een optie om een lijst van
	ge&iuml;nstalleerde <filename>crontab</filename> bestanden op
	te vragen, namelijk de optie <option>-l</option> van
	<command>crontab</command>.</para>

      <para>Gebruikers die hun eigen crontabbestand willen schrijven
	zonder het gebruik van een sjabloon, kunnen gebruik maken van
	<command>crontab -e</command>.  Dit opent de
	<envar>EDITOR</envar> met een leeg bestand.  Als het bestand
	wordt opgeslagen en de editor wordt afgesloten, wordt het
	bestand automatisch als <filename>crontab</filename>
	ge&iuml;nstalleerd.</para>

      <para>Een gebruikers<filename>crontab</filename> kan verwijderd
	worden door de met <command>crontab</command> de optie
	<option>-r</option> te gebruiken.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-rcNG">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Gebruik van rc met &os;&nbsp;5.X en later</title>

    <indexterm><primary>rcNG</primary></indexterm>

    <para>&os; gebruikt inmiddels het NetBSD <filename>rc.d</filename>
      systeem bij het opstarten van het systeem.  Veel van de bestanden
      in <filename>/etc/rc.d</filename> zijn scripts voor basisdiensten
      die werken met de opties <option>start</option>,
      <option>stop</option> en <option>restart</option>, analoog aan
      hoe diensten die via een port of package zijn ge&iuml;nstalleerd
      gestart worden met de scripts in
      <filename>/usr/local/etc/rc.d</filename>.  &man.sshd.8; kan
      bijvoorbeeld als volgt herstart worden:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>Deze procedure is vrijwel gelijk voor andere diensten.
      Uiteraard worden diensten meestal automatisch gestart zoals
      in &man.rc.conf.5; staat.  Om de Network Address Translation
      daemon bij het opstarten te laten starten is de volgende regel in
      <filename>/etc/rc.conf</filename> bijvoorbeeld voldoende:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Als er reeds een <literal>natd_enable="NO"</literal> regel
      is, kan <literal>NO</literal> gewoon in <literal>YES</literal>
      veranderd worden.  De rc scripts starten, voor zover nodig,
      automatisch andere afhankelijke diensten.</para>

    <para>Omdat het <filename>rc.d</filename> systeem in eerste
      instantie bedoeld is om diensten te starten en stoppen bij het
      opstarten en afsluiten van het systeem, werken de standaardopties
      <option>start</option>, <option>stop</option> en
      <option>restart</option> alleen als de juiste variabelen in
      <filename>/etc/rc.conf</filename> zijn ingesteld.  Het commando
      <command>sshd restart</command> alleen dan als
      <varname>sshd_enable</varname> de waarde <literal>YES</literal>
      heeft in <filename>/etc/rc.conf</filename>.  Als er een service
      gestart, gestopt of herstart moet worden, ongeacht de definities
      in <filename>/etc/rc.conf</filename>, moet het commando
      voorafgegaan worden door <quote>force</quote>.  Dus om
      <command>sshd</command> te herstarten ongeacht
      <filename>/etc/rc.conf</filename> setting, voldoet het volgende
      commando:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd forcerestart</userinput></screen>

    <para>Het is eenvoudig te controleren of een dienst is ingeschakeld
      is in <filename>/etc/rc.conf</filename> door het bijpassende
      <filename>rc.d</filename> script uit te voeren met de optie
      <option>rcvar</option>.  Voor <command>sshd</command>:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note><para>De tweede regel (<literal># sshd</literal>) is de
	uitvoer van <command>sshd</command>, geen
	<username>root</username> console.</para></note>

    <para>De optie <option>status</option> wordt gebruikt om vast te
      stellen of een dienst gestart is.  Om bijvoorbeeld te controleren
      of <command>sshd</command> gestart is:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Het is ook mogelijk om een dienst te herladen met de optie
      <option>reload</option>.  Dan wordt er getracht een signaal te
      sturen aan een individuele dienst, waarbij de dienst de bestanden
      met instellingen opnieuw in moet lezen.  Meestal komt dit neer
      op het verzenden van het signaal
      <literal>SIGHUP</literal> signaal.</para>

    <para>Het <application>rc.d</application>-systeem wordt niet alleen
      gebruikt voor netwerkdiensten, maar ook voor het merendeel van de
      systeemstart.  In dit kader is bijvoorbeeld het bestand
      <filename>bgfsck</filename> interessant.  Als dit script wordt
      uitgevoerd, wordt de volgende boodschap getoond:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Dit script wordt dus gebruikt voor bestandssysteemcontrole
      in de achtergrond, hetgeen alleen tijdens de systeemstart
      gebeurt.</para>

    <para>Veel systeemdiensten zijn afhankelijk van andere diensten om
      correct te kunnen functioneren.  Zo starten NIS en andere
      RPC-gebaseerde diensten niet als de <command>rpcbind</command>
      (portmapper) dienst nog niet draait.  Om dit te stroomlijnen
      wordt informatie over afhankelijkheden en andere meta-data
      ingevoegd in het commentaar bovenaan het opstartscript.  Deze
      commentaarregels worden vervolgens tijdens de systeemstart
      met &man.rcorder.8; verwerkt om zo vast te stellen in welke
      volgorde de systeemdiensten gestart moeten worden.  De volgende
      sleutelwoorden kunnen worden opgenomen aan het begin van elk
      opstartscript:</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: geeft aan in welke diensten
	  dit bestand voorziet.</para>
      </listitem>

      <listitem>
	<para><literal>REQUIRE</literal>: geeft aan welke andere
	  diensten vereist zijn voor deze dienst.  Dit script wordt
	  uitgevoerd <emphasis>na</emphasis> de aangegeven
	  diensten.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: geeft diensten aan die
	  afhankelijk zijn van deze dienst.  Dit bestand wordt
	  uitgevoerd <emphasis>v&oacute;&oacute;r</emphasis> de
	  aangegeven diensten.</para>
      </listitem>

      <listitem>
	<para>KEYWORD: &os; of NetBSD.  Dit wordt gebruikt voor
	  speciale eigenschappen van &eacute;&eacute;n van de
	  *BSD's.</para>
      </listitem>
    </itemizedlist>

    <para>Met deze methode kan een systeembeheerder gemakkelijk
      systeemdiensten besturen, zonder gedoe met
      <quote>runlevels</quote> zoals bij sommige andere &unix;
      systemen.</para>

    <para>Meer informatie over het <filename>rc.d</filename>-systeem
      staat in &man.rc.8; en &man.rc.subr.8;.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
	 <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Geschreven door </contrib>
	 </author>
      </authorgroup>
    </sect1info>

    <title>Netwerkkaarten instellen</title>

    <indexterm>
      <primary>netwerkkaarten</primary>

      <secondary>instellen</secondary>
    </indexterm>

    <para>Het is tegenwoordig nauwelijks voorstelbaar dat een computer
      geen netwerkverbinding heeft.  Het toevoegen en instellen van
      een netwerkkaart is een gebruikelijke taak voor een &os;
      beheerder.</para>

    <sect2>
      <title>Het juiste stuurprogramma vinden</title>

      <indexterm>
	<primary>netwerkkaarten</primary>

	<secondary>stuurprogramma</secondary>
      </indexterm>

      <para>Voor het zoeken begint, moet duidelijk zijn om welke kaart
	het gaat, welke chip erop zit en of het een PCI of ISA kaart
	is.  &os; ondersteunt vele kaarten.  Op de Hardware
	Compatibiliteitslijst voor de betreffende release om staan de
	kaarten die ondersteund worden.</para>

      <para>Als duidelijk is dat een kaart ondersteund wordt, moet
	vastgesteld worden wat het geschikte stuurprogramma is.
	In het bestand <filename>/usr/src/sys/conf/NOTES</filename>
	(<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/LINT</filename>
	voor &os;&nbsp;4.X) staat een lijst van stuurprogramma's voor
	netwerkinterfaces met wat informatie over de ondersteunde
	chipsets of kaarten.  In geval van twijfel biedt de hulppagina
	voor het stuurprogramma (<command>man</command>) vaak uitkomst.
	In het algemeen bevat deze meer informatie over de ondersteunde
	hardware en mogelijke problemen die kunnen optreden.</para>

      <note>
	<para><filename>NOTES</filename> bestaat niet op &os;&nbsp;4.X.
	  In plaats daarvan kan in het bestand
	  <filename>LINT</filename> informatie gevonden worden over een
	  groot aantal netwerkkaarten.  In <xref
	    linkend="kernelconfig-config"> staan meer details over
	  <filename>NOTES</filename> versus
	  <filename>LINT</filename>.</para>
      </note>

      <para>Als een veelgebruikte kaart gebruikt wordt, hoeft meestal
	niet ver gezocht te worden.  Stuurprogramma's voor
	veelvoorkomende netwerkinterfaces al aanwezig in de algemene
	<filename>GENERIC</filename> kernel.  In dat geval wordt zo'n
	al gevonden worden bij het opstarten, bijvoorbeeld met het
	volgende bericht:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>In dit voorbeeld zitten er twee kaarten in het systeem die
	het stuurprogramma &man.dc.4; gebruiken.</para>

      <para>Als het stuurprogramma voor een NIC geen onderdeel is van
	de <filename>GENERIC</filename> kernel, dan dient het juiste
	stuurprogramma voor die NIC geladen te worden.  Dit kan op twee
	manieren:</para>

      <itemizedlist>
	<listitem>
	  <para>De meest eenvoudige manier is het laden van een
	    kernelmodule voor een netwerkkaart met &man.kldload.8;.
	  Niet alle NIC stuurprogramma's zijn als module beschikbaar.
	  Zo zijn er bijvoorbeeld geen modules beschikbaar voor ISA
	  kaarten.</para>
	</listitem>

	<listitem>
	  <para>Ondersteuning voor een kaart kan ook in de kernel
	    gecompileerd worden.  In
	    <filename>/usr/src/sys/conf/NOTES</filename>,
	    <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
	    en de hulppagina van het stuurprogramma is na te lezen wat
	    er in het kernelinstellingenbestand moet staan.  In <xref
	      linkend="kernelconfig"> staat meer informatie over het
	    compileren van een eigen kernel.  Als een netwerkkaart al
	    bij het opstarten wordt herkend door de
	    <filename>GENERIC</filename> kernel, is er geen reden om
	    een andere kernel te bouwen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>De netwerkkaart instellen</title>

      <indexterm>
	<primary>netwerkkaarten</primary>

	<secondary>instellen</secondary>
      </indexterm>

      <para>Nadat een geschikt stuurprogramma geladen is, moet de kaart
	nog ingestelt worden.  Mogelijk is dit al gebeurd door
	<application>sysinstall</application> tijdens de
	installatie.</para>

      <para>Om de instellen van de netwerkkaarten weer te geven
	zien:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
	<para>Op oudere versies van of &os; moet volgens
	  &man.ifconfig.8; misschien de optie <option>-a</option>
	  gebruikt worden.  In &man.ifconfig.8;zijn meer details over
	  de syntaxis te lezen.  In dit voorbeeld is de uitvoer over
	  IPv6 (<literal>inet6</literal> etc.) achterwege
	  gelaten.</para>
      </note>

      <para>In dit voorbeeld werden de volgende apparaten
	weergegeven:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: de eerste Ethernet
	    interface;</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: de tweede Ethernet
	    interface;</para>
	</listitem>

	<listitem>
	  <para><devicename>lp0</devicename>: de parallelle poort
	    interface;</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: het loopback
	    apparaat;</para>
	</listitem>

	<listitem>
	  <para><devicename>tun0</devicename>: het tunnelapparaat
	    gebruikt door <application>ppp</application>.</para>
	</listitem>
      </itemizedlist>

      <para>&os; gebruikt de naam van het stuurprogramma gevolgd door
	een nummer voor de volgorde waarop de kaarten gedetecteerd zijn
	bij het opstarten.  <devicename>sis2</devicename> is de derde
	netwerkkaart in het systeem die het stuurprogramma &man.sis.4;
	gebruikt.</para>

      <para>In het vorige voorbeeld is het apparaat
	<devicename>dc0</devicename> volledig operationeel.  Dit blijkt
	uit de volgende indicatoren:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> betekent dat de kaart
	    ingesteld is en klaar voor gebruik;</para>
	</listitem>

	<listitem>
	  <para>De kaart heeft een Internet (<literal>inet</literal>)
	    adres (in dit geval <hostid
	    role="ipaddr">192.168.1.3</hostid>);</para>
	</listitem>

	<listitem>
	  <para>Het heeft een geldig subnetmasker
	    (<literal>netmask</literal>; <hostid
	      role="netmask">0xffffff00</hostid> is hetzelfde als
	    <hostid role="netmask">255.255.255.0</hostid>);</para>
	</listitem>

	<listitem>
	  <para>Het heeft een geldig broadcastadres (in dit geval,
	    <hostid role="ipaddr">192.168.1.255</hostid>);</para>
	</listitem>

	<listitem>
	  <para>Het MAC adres van de kaart (<literal>ether</literal>)
	    is <hostid role="mac">00:a0:cc:da:da:da</hostid>;</para>
	</listitem>

	<listitem>
	  <para>De fysieke mediaselectie staat in autoselectiemodus
	    (<literal>media: Ethernet autoselect (100baseTX
	      &lt;full-duplex&gt;)</literal>).
	    <devicename>dc1</devicename> is ingesteld om met
	    <literal>10baseT/UTP</literal> media te werken.  Meet
	    informatie over de mogelijke media types staan in de
	    hulppagina's voor het betreffende stuurprogramma.</para>
	</listitem>

	<listitem>
	  <para>De status van de link (<literal>status</literal>)
	    is <literal>active</literal>, dat wil zeggen dat de drager
	    is gevonden.  Bij <devicename>dc1</devicename>staat echter
	    <literal>status: no carrier</literal>.  Dit is normaal als
	    er geen ethernet kabel in de kaart gestoken is.</para>
	</listitem>
      </orderedlist>

      <para>Als de uitvoer &man.ifconfig.8; uitvoer er ongeveer zoals
	hieronder uitziet, dan is de netwerkkaart nog niet
	ingesteld:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
                ether 00:a0:cc:da:da:da</screen>

      <para>Om de kaart te instellen zijn <username>root</username>
	rechten nodig.  De netwerkkaart van vanaf de console worden
	ingesteld met &man.ifconfig.8;, maar dan moet dat na elke
	herstart herhaald worden.  Daarom wordt het vrijwel altijd in
	<filename>/etc/rc.conf</filename> gezet.</para>

      <para>In <filename>/etc/rc.conf</filename> moet voor elke
	netwerkkaart in een systeem een regel toegevoegd worden.  In
	het huidige voorbeeld zou dat het volgende kunnen zijn:</para>

      <programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para><devicename>dc0</devicename>, <devicename>dc1</devicename>,
	enzovoort, moeten vervangen worden door de correcte
	stuurprogramma's voor de netwerkkaarten, zo ook de
	<acronym>IP</acronym> adressen.  In de handleiding van het
	stuurprogramma en van &man.ifconfig.8; staan meer details over
	de mogelijke opties en in &man.rc.conf.5; staat meer informatie
	over <filename>/etc/rc.conf</filename>.</para>

      <para>Als het netwerk al is ingesteld tijdens het installeren van
	&os; staan er al enkele regels met betrekking tot de
	netwerkkaart(en) in <filename>/etc/rc.conf</filename>.  Het is
	dus handig <filename>/etc/rc.conf</filename> te controleren
	voordat er regels toegevoegd worden.</para>

      <para>Ook <filename>/etc/hosts</filename> moet worden gewijzigd
	om de namen en <acronym>IP</acronym> adressen van
	verschillende machines op het lokale netwerk, als ze er nog
	niet in staan.  Meer informatie staat in &man.hosts.5; en
	<filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Testen en problemen oplossen</title>

      <para>Als de veranderingen in <filename>/etc/rc.conf</filename>
	zijn gemaakt, moet het systeem opnieuw gestarten worden (of
	moeten nauwkeurig alle daemons gestart of herstart worden).
	Veranderingen aan de interface(s) worden dan toegepast en dan
	kan er controleerd worden of herstarten goed werkt zonder
	foutmeldingen.</para>

      <para>Als de kaart werkt, maar de performance is slecht, dan kan
	het de moeite waard zijn om &man.tuning.7; door te nemen.
	Incorrecte netwerkinstellingen kunnen ook tot langzame
	verbindingen leiden.</para>

      <para>Soms kunnen enkele <errorname>device timeouts</errorname>
	optreden.  Met sommige kaarten is dit normaal gedrag.  Maar als
	dit continu gebeurd of storend is, is het verstandig uit te
	zoeken of er geen sprake is van een hardwareconfict tussen de
	netwerkkaart en een ander apparaat.  Ook dient nogmaals de
	bekabeling gecontroleer te worden.  Misschien zit er niets
	anders op dan een andere netwerkkaart te gebruiken.</para>

      <para>Het is ook mogelijk dat er <errorname>watchdog
	timeout</errorname> foutmeldingen optreden.  Als eerste moet
	dan de netwerkkabel fecontroleerd worden.  Veel kaarten hebben
	een PCI slot nodig dat Bus Mastering ondersteunt.  Sommige
	oudere moederborden hebben maar &eacute;&eacute;n PCI slot
	waarmee dit kan (meestal slot 0).  In de documentatie van de
	netwerkkaart en het moederbord is na te gaan of dit het
	probleem is.</para>

      <para><errorname>No route to host</errorname> meldingen treden op
	als het systeem niet in staat is om een pakket naar de
	eindbestemming te routeren.  Dit kan gebeuren als er geen
	standaardroute aangegeven is of als er een kabel niet verbonden
	is.  De uitvoer van <command>netstat -rn</command> moet
	gecontroleerd worden en of er een geldige route is naar de
	bestemming.  Mocht dit niet het geval zijn, dan staat er meer
	informatie in <xref linkend="advanced-networking">.</para>

      <para><errorname>ping: sendto: Permission denied</errorname>
	foutmeldingen worden vaak veroorzaakt door een verkeerd
	ingestelde firewall.  Als de kernel <command>ipfw</command>
	activeert bij het opstarten zonder dat er firewallregels zijn
	gedefini&euml;erd, is het standaardbeleid om alle verkeer te
	weigeren, zelfs pings!  In <xref linkend="firewalls"> staat
	meer informatie.</para>

      <para>Er kan ook sprake zijn van onvoldoende prestaties doordat
	de mediaselectie instelling niet optimaal is.  In dergelijke
	gevallen is het mogelijk om de mediaselectie niet als
	<literal>autoselect</literal> in te stellen, maar expliciet
	aan te geven wat de mediaselectie moet zijn, bijvoorbeeld
	10baseT/UTP voor twisted pair.  Hoewel dit voor de meeste
	hardware helpt, kan het zijn dat de problemen blijven.
	Dan moeten nogmaals de netwerkinstellingen gecontroleerd worden
	en geeft de &man.tuning.7; handleiding wellicht meer
	informatie.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtuele hosts</title>

    <indexterm><primary>virtuele hosts</primary></indexterm>

    <indexterm><primary>IP aliassen</primary></indexterm>

    <para>&os; wordt veel gebruikt voor virtuele sitehosting, waarbij
      &eacute;&eacute;n fysieke server er op het netwerk uitziet alsof
      het meerdere servers zijn.  Dit kan bereikt worden door meerdere
      <acronym>IP</acronym> adressen toe te kennen aan dezelfde
      interface.</para>

    <para>Een bepaalde netwerkinterface heeft een <quote>echt</quote>
      adres en kan daarnaast een willekeurig aantal
      <quote>alias</quote> adressen hebben.  Normaliter worden
      dergelijke aliassen toegevoegd door aliasregels toe te voegen aan
      <filename>/etc/rc.conf</filename>.</para>

    <para>Een aliasregel voor de interface
      <devicename>fxp0</devicename> ziet er zo uit:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>De aliasregels moeten beginnen met <literal>alias0</literal>
      en moete elkaar dan opvolgen (bijvoorbeeld
      <literal>_alias1,</literal>, <literal>_alias2</literal>,
      enzovoort).  Het instelproces stopt als er een nummer
      ontbreekt.</para>

    <para>Het is belangrijk dat aliassen het juiste netmasker hebben.
      Dit is eenvoudig: Een bepaalde interface moet altijd
      &eacute;&eacute;n adres hebben dat het netmasker van het netwerk
      correct representeert.  Elk ander adres binnen dit netwerk op
      deze interface (alias) moet een netmasker van allemaal
      <literal>1</literal>'en (bits) hebben (getoond als <hostid
	role="netmask">255.255.255.255</hostid> of <hostid
	role="netmask">0xffffffff</hostid>).</para>

    <para>Een voorbeeld.  Stel de <devicename>fxp0</devicename>
      interface is verbonden met twee netwerken, het <hostid
	role="ipaddr">10.1.1.0</hostid> netwerk met masker <hostid
	role="netmask">255.255.255.0</hostid> en het <hostid
	role="ipaddr">202.0.75.16</hostid> met netmasker <hostid
	role="netmask">255.255.255.240</hostid>.  Het systeem moet ook
      de adressen <hostid role="ipaddr">10.1.1.1</hostid> tot en met
      <hostid role="ipaddr">10.1.1.5</hostid> en <hostid
	role="ipaddr">202.0.75.17</hostid> tot en met <hostid
	role="ipaddr">202.0.75.20</hostid> krijgen.  Zoals hierboven
      vermeld, heeft alleen het eerste adres in een netwerkreeks (in
      dit geval <hostid role="ipaddr">10.0.1.1</hostid> en <hostid
	role="ipaddr">202.0.75.17</hostid>) een geldig netmasker.  Alle
      overige (<hostid role="ipaddr">10.1.1.2</hostid> tot en met
      <hostid role="ipaddr">10.1.1.5</hostid> en <hostid
	role="ipaddr">202.0.75.18</hostid> tot en met <hostid
	role="ipaddr">202.0.75.20</hostid>) moeten ingesteld worden met
      het netmasker <hostid
	role="netmask">255.255.255.255</hostid>.</para>

    <para>De volgende regels voor <filename>/etc/rc.conf</filename>
      stellen een adapter in voor het bovenstaande scenario:</para>

<programlisting>ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>
  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Instellingenbestanden</title>

    <sect2>
      <title><filename>/etc</filename> layout</title>

      <para>Instellingengegevens wordt in een aantal mappen bewaard.
	Daar zijn onder andere:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">

	  <colspec colwidth="2*">

	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>

	      <entry>Generieke systeeminstellingenbestanden, specifiek
		voor het systeem.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults</filename></entry>

	      <entry>De standaardversies van
		systeeminstellingenbestanden die gebruikt worden als er
		geen in <filename>/etc</filename> staat.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail</filename></entry>

	      <entry>Extra &man.sendmail.8; instellingenbestanden of
		instellingenbestanden voor andere MTAs.
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp</filename></entry>

	      <entry>Instellingen voor zowel user- als kernel-ppp
		programma's.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>

	      <entry>Standaardlocatie voor &man.named.8; gegevens.
		Normaal gesproken bevinden zich hier
		<filename>named.conf</filename> en
		zonebestanden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>

	      <entry>Instellingenbestanden voor ge&iuml;nstalleerde
		software.  Kan submappen hebben waarin bij elkaar
		horende instellingengegevens van een applicatie
		gegroepeerd zijn.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>

	      <entry>Start en stop scripts voor ge&iuml;nstalleerde
		diensten.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/db</filename></entry>

	      <entry>Automatisch gemaakte systeemspecifieke
		databasebestanden, zoals de packagedatabase, de
		&man.locate.1; database, enzovoort.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostnaam</primary></indexterm>

      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>In <filename>/etc/resolv.conf</filename> wordt
	  voorgeschreven op welke wijze &os; het Domain Name System
	  (DNS) moet gebruiken.</para>

	<para>De meest voorkomende termen in
	  <filename>resolv.conf</filename> zijn:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">

	    <colspec colwidth="2*">

	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>

		<entry>Het <acronym>IP</acronym> adres van een
		  naamserver die ondervraagd moet worden voor
		  naam/<acronym>IP</acronym> conversie.  De servers
		  worden in volgorde geprobeerd en het maximale aantal
		  is drie.</entry>
	      </row>

	      <row>
		<entry><literal>search</literal></entry>

		<entry>Zoeklijst voor het opzoeken van hostnamen.
		  Meestal wordt deze bepaald door het domein waarop de
		  lokale hostnaam zich bevindt.</entry>
	      </row>

	      <row>
		<entry><literal>domain</literal></entry>

		<entry>De lokale domeinnaam.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Een typisch <filename>resolv.conf</filename>
	  bestand:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note>
	  <para><literal>search</literal> en <literal>domain</literal>
	    dienen niet tegelijk gebruikt te worden.</para>
	</note>

	<para>Als DHCP wordt gebruikt: &man.dhclient.8; overschrijft
	  meestal <filename>resolv.conf</filename> met informatie
	  ontvangen van de DHCP server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> is een eenvoudige
	  tekstdatabase uit de dagen van het oude internet.  Het werkt
	  samen met DNS en NIS om namen en <acronym>IP</acronym>
	  adressen over en weer te vertalen.  Lokale computers,
	  verbonden via een LAN, kunnen hier het beste in opgenomen
	  worden om zo op simpele wijze naam/<acronym>IP</acronym>
	  conversie voor een LAN te hebben, zonder noodzaak voor een
	  &man.named.8; server.  Ook kunnen naamaliassen toegekend
	  worden (vergelijkbaar met CNAMES bij DNS).  Op soortgelijke
	  wijze kan <filename>/etc/hosts</filename> gebruikt worden als
	  een (zeer beperkte) lokale DNS cache.
	</para>

	<programlisting># &dollar;&os;&dollar;
#
# Host Database
# Dit bestand hoort de adressen en aliassen te bevatten
# voor de lokale hosts die dit bestand gebruiken.
# Bij gebruik van DNS of NIS hoeft dit bestand helemaal niet gebruikt
# te worden.  Zie /etc/nsswitch.conf voor de volgorde van resolutie.
#
#
::1                      localhost localhost.my.domain myname.my.domain
127.0.0.1                localhost localhost.my.domain myname.my.domain

#
# Verzonnen netwerk.
#10.0.0.2                myname.my.domain myname
#10.0.0.3                myfriend.my.domain myfriend
#
# Volgens RFC 1918 mogen de volgende IP netwerken gebruikt worden
# als private netwerken die niet met internet verbonden zijn:
#
#        10.0.0.0        -   10.255.255.255
#        172.16.0.0      -   172.31.255.255
#        192.168.0.0     -   192.168.255.255
#
# Als er toch verbinding moet zijn met internet, zijn echte
# officieel toegewezen nummers nodig.  Probeer ECHT GEEN eigen
# netwerknummers te verzinnen, maar vraag ze op bij de provider
# (als die er is) of bij de Internet Registry (ftp naar
# rs.internic.net, map `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> heeft als formaat:</para>

	<programlisting>[Internet address] [official hostname] [alias1] [alias2] ...</programlisting>

	<para>Bijvoorbeeld:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>In &man.hosts.5; staat meer informatie.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Logboekbestanden instellen</title>

      <indexterm><primary>logboekbestanden</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> is het
	  instellingenbestand voor het programma &man.syslogd.8;.  Het
	  geeft aan welke soorten <command>syslog</command> berichten
	  er gelogd moeten worden en naar welke logboekbestanden,
	  apparaten, gebruikers of machines.</para>

	<programlisting># &dollar;&os;&dollar;
#
#        Spaties zijn TOEGESTAAN als veldscheiding in dit bestand.
#        Maar andere *nix-achtige systemen eisen nog steeds het gebruik
#        van tabs als veldscheiding.  Als dit bestand gedeeld wordt met
#        andere systemen, is het verstandig alle tabs als veldscheiding
#        te gebruiken.
#        Zie ook de handleding van syslog.conf(5).
*.err;kern.debug;auth.notice;mail.crit           /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err  /var/log/messages
security.*                                       /var/log/security
mail.info                                        /var/log/maillog
lpr.info                                         /var/log/lpd-errs
cron.*                                           /var/log/cron
*.err                                            root
*.notice;news.err                                root
*.alert                                          root
*.emerg                                          *
# verwijder het commentaarkarakter om alle schrijfacties naar
# /dev/console naar /var/log/console.log te schrijven.
#console.info                                    /var/log/console.log
# verwijder het commentaarkarakter om alle berichten naar
# /var/log/all.log te schrijven.
#*.*                                             /var/log/all.log
# # verwijder het commentaarkarakter om alle liggen naar een andere
# host in te schakelen met de naam loghost.
#*.*                                             @loghost
# # verwijder het commentaarkarakter als inn draait.
# news.crit                                      /var/log/news/news.crit
# news.err                                       /var/log/news/news.err
# news.notice                                    /var/log/news/news.notice
!startslip
*.*                                              /var/log/slip.log
!ppp
*.*                                              /var/log/ppp.log</programlisting>

	<para>In &man.syslog.conf.5; staat meer informatie.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para><filename>newsyslog.conf</filename> is het
	  instellingenbestand voor &man.newsyslog.8;, een programma
	  dat op gezette tijden via &man.cron.8; wordt uitgevoerd.
	  &man.newsyslog.8; stelt vast wanneer logboekbestanden
	  gearchiveerd moeten worden of anderszins opnieuw gerangschikt
	  moeten worden.  <filename>logfile</filename> wordt hernoemd
	  naar <filename>logfile.0</filename>,
	  <filename>logfile.0</filename>
	  naar <filename>logfile.1</filename>, enzovoort.</para>

	<para><filename>newsyslog.conf</filename> geeft aan welke
	  logboekbestanden beheerd moeten worden, hoeveel er in
	  archieven bewaard moeten worden en wanneer ze aangemaakt
	  moeten worden.  Logboekbestanden kunnen gereorganiseerd en/of
	  gearchiveerd worden als ze een bepaalde grootte bereikt
	  hebben of op een bepaald periodiek tijdstip of een bepaalde
	  datum.</para>

	<programlisting># configuration file for newsyslog
# &dollar;&os;&dollar;
#
# filename           [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                            600  3     100  *     Z
/var/log/amd.log                         644  7     100  *     Z
/var/log/kerberos.log                    644  7     100  *     Z
/var/log/lpd-errs                        644  7     100  *     Z
/var/log/maillog                         644  7     *    @T00  Z
/var/log/sendmail.st                     644  10    *    168   B
/var/log/messages                        644  5     100  *     Z
/var/log/all.log                         600  7     *    @T00  Z
/var/log/slip.log                        600  3     100  *     Z
/var/log/ppp.log                         600  3     100  *     Z
/var/log/security                        600  10    100  *     Z
/var/log/wtmp                            644  3     *    @01T05 B
/var/log/daily.log                       640  7     *    @T00  Z
/var/log/weekly.log                      640  5     1    $W6D0 Z
/var/log/monthly.log                     640  12    *    $M1D0 Z
/var/log/console.log                     640  5     100  *     Z</programlisting>

	<para>In &man.newsyslog.8; staat meer informatie.</para>
      </sect3>
    </sect2>

    <sect2 id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>

      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> lijkt veel op
	<filename>rc.conf</filename>.  Waardetoekenning heeft weer de
	vorm <literal>variable=value</literal>.  De ingestelde
	&man.sysctl.8; waarden worden doorgevoerd op het moment dat het
	systeem naar multi-user modus gaat.  Niet alle variabelen
	kunnen in deze modus gewijzigd worden.</para>

      <para>Hieronder staat een voorbeeld van
	<filename>sysctl.conf</filename> waarin het loggen van gevallen
	waarin een proces be&euml;indigd wordt ten gevolge van een
	fataal signaal (bijvoorbeeld een TERM signaal of een exitcode
	van een programma dat crasht) wordt uitgezet en waarin de
	&linux; emulatielaag zodanig wordt ingesteld dat een &linux;
	programma ook echt rapporteert dat het onder &os;
	draait:</para>

      <programlisting>kern.logsigexit=0	# Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=&os;
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Optimaliseren met sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>

    <indexterm>
      <primary>optimalisering</primary>

      <secondary>met sysctl</secondary>
    </indexterm>

    <para>&man.sysctl.8; is een interface waarmee veranderingen gemaakt
      kunnen worden aan een draaiend &os; systeem.  Er zijn onder meer
      vele geavanceerde opties voor de TCP/<acronym>IP</acronym> stack
      en het virtuele geheugensysteem, waarmee een ervaren
      systeembeheerder de systeemprestaties drastisch kan verbeteren.
      Met &man.sysctl.8; kunnen meer dan vijfhonderd ststeemvariabelen
      opgevraagd en ingesteld worden.</para>

    <para>In essentie heeft &man.sysctl.8; twee funkties: het lezen en
      wijzigen van systeeminstellingen.</para>

    <para>Om alle leesbare variabelen te tonen:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Om een bepaalde variabele op te vragen, bijvoorbeeld
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Om een bepaalde variabele toe te kennen (te wijzigen), is de
      syntaxis
      <replaceable>variable</replaceable>=<replaceable>value</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Waarden van sysctl variabelen zijn doorgaans strings (tekst),
      getallen of booleans (<literal>1</literal> als waar,
      <literal>0</literal> als onwaar).</para>

    <para>Om automatisch variabelen in te stellen als de machine start,
      kunnen ze toegevoegd worden aan
      <filename>/etc/sysctl.conf</filename>.  Meer informatie staat in
      &man.sysctl.conf.5; en <xref
	linkend="configtuning-sysctlconf">.</para>

  <sect2 id="sysctl-readonly">
    <sect2info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect2info>

    <title>&man.sysctl.8; alleen-lezen</title>

    <para>In sommige gevallen is het wenselijk zijn om &man.sysctl.8;
      waarden die alleen-lezen zijn toch te wijzigen.  Hoewel dit soms
      onontkoombaar is, kan het alleen bij een (her)start gedaan
      worden.</para>

    <para>Op sommige laptops is bijvoorbeeld het apparaat
      &man.cardbus.4; niet in staat om geheugenregio's af te tasten,
      met als gevolg foutmeldingen als:</para>

    <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

    <para>In dergelijke gevallen moeten er meestal enkele
      &man.sysctl.8; instellingen gewijzigd worden die alleen-lezen
      zijn en een standaardwaarde hebben.  Dit kan bereikt worden door
      &man.sysctl.8; <quote>OIDs</quote> in de lokale
      <filename>/boot/loader.conf</filename> te zetten.
      Standaardinstellingen staan in
      <filename>/boot/defaults/loader.conf</filename>.</para>

    <para>Om het bovenstaande probleem op te lossen moet in
      in <filename>/boot/loader.conf</filename
      <literal>hw.pci.allow_unsupported_io_range=1</literal> ingesteld
      worden.  Dan werkt &man.cardbus.4; wel goed.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Harde schijven optimaliseren</title>

    <sect2>
      <title>Sysctl variabelen</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm><primary><varname>vfs.vmiodirenable</varname></primary></indexterm>

	<para>De sysctl variabele <varname>vfs.vmiodirenable</varname>
	  kan de waarde 0 (uit) of 1 (aan) hebben.  De standaardwaarde
	  is 1.  Deze variabele bepaalt hoe mappen door het systeem
	  in een cache bewaard worden.  De meeste mappen zijn
	  klein en gebruiken slechts een klein fragment (typisch
	  1&nbsp;K) in het bestandssysteem en nog minder (typisch
	  512&nbsp;bytes) in de buffercache.  Als deze variabele
	  uit staat (op 0) bewaart de buffercache slechts een bepaald
	  aantal mappen in de cache, ook al is er een overvloed aan
	  geheugen beschikbaar.  Wanneer deze aan staat (op 1), wordt
	  de VM pagecache gebruikt, waardoor voor het cachen van mappen
	  al het geheugen kan worden gebruikt.  Het is echter wel zo
	  dat het minimale in-core geheugen dat gebruikt wordt om een
	  map te cachen in dat geval de fysieke pagegrootte is
	  (typisch 4&nbsp;K) in plaats van 512&nbsp; bytes.  Het is aan
	  te raden deze optie aan te laten staat als gebruik gemaakt
	  worden van diensten die met grote aantallen bestanden werken,
	  zoals webcaches, grote mailsystemen en newsservers.  Als deze
	  optie aan blijft staan, verlaagt die de prestaties niet, ook
	  al kost het meer geheugen.  Door experimenteren is dit voor
	  een systeem na te gaan.</para>
      </sect3>

     <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm><primary><varname>vfs.write_behind</varname></primary></indexterm>

	<para>De sysctl variabele <varname>vfs.write_behind</varname>
	  staat standaard aan (<literal>1</literal>).  Dit betekent dat
	  het bestandssysteem gegevens naar het medium gaat schrijven
	  op het moment dat er een volledig cluster aan data verzameld
	  is.  Dit is meestal het geval bij het schrijven van grote
	  sequenti&euml;le bestanden.  Het idee is om te voorkomen dat
	  de buffercache verzadigd raakt met vuile buffers zonder dat
	  dit bijdraagt aan de I/O prestaties.  Dit kan echter
	  processen ophouden en onder sommige omstandigheden is het
	  wellicht beter deze sysctl uit te zetten.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm><primary><varname>vfs.hirunningspace</varname></primary></indexterm>

	<para>De sysctl variabele <varname>vfs.hirunningspace</varname>
	  bepaalt hoeveel nog te schrijven gegevens er in het complete
	  systeem op elk moment in de wachtrij naar schijfcontrollers
	  mag staan.  De standaardwaarde is meestal voldoende, maar op
	  machines met veel schijven, is het beter deze te verhogen
	  naar vier of vijf <emphasis>megabyte</emphasis>.  Het
	  instellen van een te hoge waarde (groter dan de
	  schrijfdrempel van de buffercache) kan leiden tot zeer
	  slechte prestaties bij clustering.  Stel deze waarde niet
	  arbitrair hoog in!  Hogere schrijfwaarden kunnen vertraging
	  veroorzaken in het lezen, als dit tegelijk
	  plaatsvindt.</para>

	<para>Er zijn verscheidene andere sysctls voor buffercache en
	  VM pagecache.  Het wordt afgeraden deze te wijzigen.  Sinds
	  &os;&nbsp;4.3 is het VM systeem zeer goed in staat zichzelf
	  automatisch te optimaliseren.</para>
      </sect3>

      <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm><primary><varname>vm.swap_idle_enabled</varname></primary></indexterm>

	<para>De sysctl variabele
	  <varname>vm.swap_idle_enabled</varname> is nuttig in grote
	  multi-user systemen met veel gebruikers die af- en aanmelden
	  en veel onbenutte processen.  Dergelijke systemen hebben de
	  neiging om voortdurend de vrije geheugenreserves onder druk
	  te zetten.  Het is mogelijk om de prioriteit van
	  geheugenpages die verband houden met onbenutte processen
	  sneller te laten dalen dan met het normale pageout algoritme,
	  door deze sysctl aan te zetten en via
	  <varname>vm.swap_idle_threshold1</varname> en
	  <varname>vm.swap_idle_threshold2</varname> de swapout
	  hysterese (in seconden onbenut) af te stemmen.  Deze optie
	  dient alleen gebruikt te worden als ze echt nodig is, want de
	  andere kant van de medaille is dat dit eerder pre-page
	  geheugen inhoudt in plaats van later, waardoor het meer
	  wisselbestand- en schijfbandbreedte kost.  In een klein
	  systeem heeft deze optie een voorspelbaar effect, maar in
	  grote systemen waar al sprake is van een matige paging kan
	  deze optie het mogelijk maken voor het VM systeem om hele
	  processen gemakkelijk in en uit het geheugen te halen.</para>
      </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm><primary><varname>hw.ata.wc</varname></primary></indexterm>

	<para>Ten tijde van &os;&nbsp;4.3 is er geflirt met het
	  uitzetten van IDE schrijfcaching.  Hierdoor neemt de
	  bandbraadte naar IDE schijven af, maar het werd als
	  noodzakelijk beschouwd vanwege ernstige problemen met
	  gegevensinconsistentie die door harde schijfproducenten
	  ge&euml;introduceerd waren.  Het probleem is dat IDE schijven
	  niet de waarheid vertellen over wanneer een schrijfactie
	  klaar is.  Door IDE schrijfcaching wordt data niet alleen
	  ongeordend geschreven, maar soms kan zelfs het schrijven van
	  sommige blokken voortdurend uitgesteld worden als er sprake
	  is van een hoge schijfbelasting.  Een crash of stroomstoring
	  kan dan ernstige corruptie van het bestandssysteem
	  veroorzaken.  Daarom werd de standaardinstelling van &os;
	  voor alle zekerheid gewijzigd.  Helaas was het resultaat een
	  groot verlies aan prestaties en na die release is de
	  standaardwaarde weer terug veranderd.  Met de sysctl
	  variabele <varname>hw.ata.wc</varname> kan gecontroleerd
	  worden of schrijfcaching aan of uit staat.  Als
	  schrijfcaching uit staat, het die weer aangezet worden door
	  <varname>hw.ata.wc</varname> naar 1 te zetten.  Aangezien dit
	  een kernelvariabele is, moet deze ingesteld worden vanuit de
	  bootloader tijdens het opstarten.  Nadat de kernel eenmaal
	  opgestart is, heeft het wijzigen van deze sysctl geen
	  effect.</para>

	<para>Meer informatie staat in &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	  (<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm><primary><varname>kern.cam.scsi.delay</varname></primary></indexterm>

	<indexterm>
	  <primary>kernelopties</primary>

	  <secondary><literal>SCSI_DELAY</literal></secondary>
	</indexterm>

	<para>De <literal>SCSI_DELAY</literal> kernelinstelling kan
	  gebruikt worden om de opstarttijd te versnellen.  De
	  standaardwaarde is nogal hoog en kan <literal>15</literal>
	  seconden vertraging veroorzaken.  Met modernere SCSI systemen
	  is <literal>5</literal> seconden al voldoende.  Nieuwere
	  versies van &os; (5.0 en hoger) gebruiken de opstartvariabele
	  <varname>kern.cam.scsi_delay</varname>.  Zowel deze als de
	  optie <literal>SCSI_DELAY</literal> gebruiken waarden
	  uitgedrukt in <emphasis>milliseconden</emphasis> en
	  <emphasis>niet</emphasis> in
	  <emphasis>seconden</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Softupdates</title>

      <indexterm><primary>Softupdates</primary></indexterm>

      <indexterm><primary>tunefs</primary></indexterm>

      <para>&man.tunefs.8; kan gebruikt worden om een bestandsysteem
	nauwkeurig af te stellen.  Het heeft veel opties, maar nu wordt
	alleen het aan- en uitzetten van softupdates besproken.  Dat
	gaat als volgt:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Een bestandssysteem kan niet met &man.tunefs.8; gewijzigd
	worden als het gemount is.  Softupdates aanzetten wordt dus in
	het algemeen gedaan vanuit single-user modus, voordat partities
	gemount zijn.</para>

      <note><para>Vanaf &os;&nbsp;4.5, is het mogelijk om softupdates
	aan te zetten op het moment dat de bestandssystemen aangemaakt
	worden, door middel van de <literal>-U</literal> optie van
	&man.newfs.8;.</para></note>

      <para>Softupdates zorgen voor een drastische verbetering van de
	meta-data prestaties, met name het aanmaken en verwijderen van
	bestanden, door gebruik van een geheugencache.  Het wordt dan
	ook aangeraden om op alle bestandssystemen softupdates te
	gebruiken.  Er zijn twee nadelen aan softupdates: softupdates
	garandeert een consistent bestandssysteem in geval van een
	crash, maar het kan makkelijk enkele seconden (zelfs een
	minuut) achter liggen met het daadwerkelijk bijwerken op de
	fysieke harde schijf.  Als een systeem crasht wordt wellicht
	meer werk verloren dan anders het geval zou zijn.  Daarnaast
	vertraagt softupdates het vrijgeven van bestandssysteemblokken.
	Als een bestandssysteem (zoals de root partitie) bijna vol is,
	dan kan het verrichten van een grote update, zoals
	<command>make installworld</command>, ertoe leiden dat het
	bestandssysteem ruimtegebrek krijgt en dat daardoor de operatie
	mislukt.</para>

      <sect3>
	<title>Meer over softupdates</title>

	<indexterm>
	  <primary>Softupdates</primary>

	  <secondary>details</secondary>
	</indexterm>

	<para>Er zijn traditioneel twee methodes om de metadata van een
	  bestandssysteem terug naar de schijf te schrijven.  Het
	  bijwerken van metadata houdt het bijwerken van van
	  niet-inhoudelijke data zoals inodes of mappen in.</para>

	<para>Historisch gezien was het gebruikelijk om metadataupdates
	  synchroon weg te schrijven.  Als een map bijvoorbeeld
	  gewijzigd was, wachtte het systeem totdat de verandering
	  daadwerkelijk naar de schijf geschreven was.  De databuffers
	  (de inhoud van een bestand) werden doorgeschoven naar de
	  buffercache en op een later moment asynchroon op de schijf
	  opgeslagen.  Het voordeel van deze benadering is dat ze
	  altijd veilig is.  Als het systeem faalt tijdens het
	  bijwerken, is de metadata nog altijd consistent.  Een bestand
	  kan volledig gecre&euml;erd zijn of helemaal niet.  Als de
	  datablokken van een bestand nog niet van de buffercache naar
	  de schijf geschreven zijn ten tijde van de crash, is
	  &man.fsck.8; in staat om dit te herkennen en het
	  bestandssysteem te repareren door de lengte van het bestand
	  nul te maken.  Deze implementatie is ook helder en eenvoudig.
	  Het nadeel is echter dat het wijzigen van metadata een traag
	  proces is.  Een <command>rm -r</command> commando benadert
	  bijvoorbeeld alle bestanden in een map sequenti&euml;el, maar
	  elke mapverandering (verwijderen van een bestand) wordt
	  synchroon naar de schijf geschreven.  Dit omvat ook het
	  bijwerken van de map zelf, van de inodetabel en mogelijk ook
	  van indirecte blokken die voor het bestand in kwestie
	  zijn gealloceerd.  Gelijksoortige processen spelen zich af
	  bij een commando als <command>tar -x</command>, waarbij een
	  grote bestandshi&euml;earchie wordt uitgepakt.</para>

	<para>De tweede mogelijkheid is om het bijwerken van metadata
	  asynchroon weg te schrijven.  Dit is standaard in
	  &linux;/ext2fs en als een *BSD ufs bestandssysteem met
	  <command>mount -o async</command> gemount is, is de werking
	  hetzelfde.  Alle bijwerkingen aan metagegevens worden
	  eenvoudigweg doorgegeven aan de buffercache en vermengd met
	  inhoudelijke updates van de bestandsgegevens.  Het voordeel
	  is een grote winst aan snelheid, omdat er niet telkens
	  gewacht hoeft te worden op het bijwerken van metagegevens tot
	  deze daadwerkelijk naar de schijf geschreven zijn.  De
	  implementatie is ook in dit geval helder en eenvoudig.  Het
	  grote nadeel is uiteraard dat er geen enkele garantie is voor
	  de consistentie van het bestandssysteem.  Als het systeem
	  faalt tijdens een operatie waarbij veel metagegevens worden
	  bijgewerkt (bijvoorbeeld door een stroomstoring of iemand
	  drukt op de resetknop), blijft het bestandssysteem in een
	  onvoorspelbare toestand achter.  Er is geen mogelijkheid om
	  de toestand van het bestandssysteem te onderzoeken als het
	  systeem weer opstart, want de datablokken van een bestand
	  kunnen al weggeschreven zijn geweest terwijl het wegschrijven
	  van bijwerkingen aan de inodetabel of de bijhorende map nog
	  niet plaats heeft gevonden.  Het is zelfs onmogelijk om een
	  <command>fsck</command> te implementeren die de overgebleven
	  chaos kan opruimen: de benodigde informatie is gewoon niet
	  volledig aanwezig op de schijf.  Als een bestandssysteem op
	  deze manier onherstelbaar beschadigd is, is de enige optie
	  &man.newfs.8; te gebruiken en vervolgens te herstellen van
	  een backup.</para>

	<para>De gebruikelijke oplossing voor dit probleem is het
	  implementeren van <emphasis>dirty region logging</emphasis>,
	  ook wel <emphasis>journaling</emphasis> genoemd, hoewel deze
	  term niet consistent gebruikt wordt en soms ook wordt
	  gebruikt voor andere vormen van transactielogging.  Het
	  bijwerken van metagegevens wordt nog steeds synchroon
	  geschreven, maar slechts naar een klein gebied van de schijf.
	  Later worden ze dan naar de juiste locatie verplaatst.  Omdat
	  het loggebied klein is, hoeven de koppen van de schijf zelfs
	  tijdens schrijfintensieve operaties nog maar over een kleine
	  fysieke afstand te bewegen en door deze snellere respons zijn
	  dit soort operaties sneller dan op de traditionele manier.
	  De extra complexiteit van de implementatie is nogal beperkt,
	  dus het risico van introductie van extra bugs valt mee.  Een
	  nadeel is dat alle metagegevens tweemaal geschreven worden
	  (eerst naar het loggebied en later nog eens naar de
	  definitieve locatie).  Dus bij normaal gebruik kan er sprake
	  zijn van wat men wel noemt een <quote>performance
	    pessimization</quote>.  Anderzijds kunnen in geval van een
	  crash alle nog uitstaande metagegevensoperaties snel worden
	  teruggedraaid of vanuit het loggebied alsnog worden
	  afgemaakt, wanneer de machine weer opstart.  Het
	  bestandssysteem start dan snel op.</para>

	<para>Kirk McKusick, de vader van het Berkeley FFS, loste dit
	  probleem op met softupdates, wat betekent dat alle uitstaande
	  acties voor het bijwerken van metagegevens in het geheugen
	  bewaard worden en dan geordend naar de schijf geschreven
	  worden.  Dit heeft het gevolg dat in geval van intensieve
	  operaties met betrekking tot metagegevens, latere
	  bijwerkingen aan een item eerdere bewerkingen opvangen
	  (<quote>catch</quote>) als deze nog in het geheugen zitten en
	  nog niet weggeschreven waren.  Dus alle operaties,
	  op bijvoorbeeld een map, worden in het algemeen eerst in het
	  geheugen uitgevoerd voordat er wordt bijgewerkt naar schijf.
	  De datablokken worden geordend conform hun positie, zodat ze
	  nooit weggeschreven worden voordat hun metagegevens
	  geschreven zijn.  Als het systeem een crash ondervindt,
	  veroorzaakt dat impliciet het terugdraaien van uitstaande
	  operaties (<quote>log rewind</quote>): alle operaties die nog
	  niet weggeschreven waren lijken nooit gebeurd te zijn.  Zo
	  wordt een consistent bestandssysteem in stand gehouden dat
	  eruit ziet alsof het 30 tot 60 seconden eerder was.  Het
	  gebruikte algoritme garandeert dat alle bronnen die in
	  gebruik zijn als zodanig gemarkeerd worden in hun daarvoor
	  geschikte bitmaps: blokken en inodes.  Na een crash is de
	  enige allocatiefout die kan optreden dat bronnen gemarkeerd
	  kunnen zijn als in gebruik (<quote>used</quote>), terwijl ze
	  feitelijk alweer beschikbaar (<quote>free</quote>) zijn.
	  &man.fsck.8; herkent deze situatie en stelt dergelijke vrij
	  te maken bronnen opnieuw beschikbaar.  Het is volkomen veilig
	  om na een crash te negeren dat het bestandssysteem niet
	  schoon is en het tot mounten te dwingen met
	  <command>mount&nbsp;-f</command>.  Om niet langer gebruikte
	  bronnen vrij te maken moet later &man.fsck.8; uitgevoerd
	  worden.  Dit is dan ook het idee achter <emphasis>background
	    fsck</emphasis>: op het moment dat het systeem aan het
	  opstarten is, wordt er alleen een
	  <emphasis>snapshot</emphasis> van het systeem bewaard.
	  <command>fsck</command> kan later uitgevoerd worden.  Alle
	  bestandssystemen kunnen <quote>dirty</quote> gemount worden
	  en het systeem kan gewoon verder opstarten naar multi-user
	  modus.  Vervolgens zijn er <command>fsck</command>s
	  gepland die in de achtergrond draaien voor elk
	  bestandssysteem dat niet schoon is en waarmee bezette bronnen
	  vrijgegeven worden.  Bestandssystemen die geen gebruik maken
	  van softupdates moeten echter nog steeds gebruik maken van de
	  normale <command>fsck</command> in de voorgrond.</para>

	 <para>Het voordeel van softupdates is dat operaties op
	   metagegevens bijna net zo snel zijn als asynchrone updates
	   (dat wil zeggen sneller dan met
	   <emphasis>logging</emphasis>, waarbij de metagegevens keer
	   keer geschreven worden).  Nadelen zijn de complexiteit van
	   de code (wat een groter risico op bugs impliceert in een
	   gebied dat bijzonder gevoelig is voor verlies van
	   gebruikersgegevens) en een groter geheugenverbruik.  Tevens
	   moet de gebruiker wennen aan enkele eigenaardigheden.  Na
	   een crash lijkt de toestand van het bestandssysteem wat
	   <quote>ouder</quote>.  In situaties waar de standaard
	   synchrone benadering een aantal lege bestanden zou hebben
	   achtergelaten na <command>fsck</command>, is het met
	   softupdates juist zo dat dergelijke bestanden er helemaal
	   niet zijn, omdat de metadata of de bestandsinhoud nooit naar
	   de schijf is geschreven.  Schijfruimte wordt pas vrijgegeven
	   als de bijwerkingen aan metagegevens en inhoudelijke
	   bestandsdata weggeschreven zijn, wat mogelijk pas enige tijd
	   na het uitvoeren van <command>rm</command> plaatsvindt.  Dit
	   kan problemen veroorzaken als er grote hoeveelheden data
	   naar een bestandssysteem geschreven worden dat onvoldoende
	   vrije ruimte heeft om alle bestanden twee keer te kunnen
	   bevatten (bijvoorbeeld in <filename>/tmp</filename>).</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Fijnafstemming van kernellimieten</title>

    <indexterm>
      <primary>fijnafstemming</primary>

      <secondary>kernellimieten</secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Bestandsproceslimieten</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm><primary><varname>kern.maxfiles</varname></primary></indexterm>

	<para><varname>kern.maxfiles</varname> kan worden verhoogd of
	  verlaagd, afhankelijk van de systeembehoeften.  Deze
	  variabele geeft het maximale aantal bestandsdescriptors op
	  een systeem.  Als de bestandsdescriptortabel vol is,.toont de
	  systeembuffer meerdere malen <errorname>file: table is
	  full</errorname>, hetgeen achteraf te zien is net
	  <command>dmesg</command>.</para>

	<para>Elk geopend bestand, socket of fifo heeft een
	  bestandsdescriptor.  Een grote produktieserver kan makkelijk
	  enige duizenden bestandsdescriptors nodig hebben, afhankelijk
	  van het soort en aantal diensten die tegelijk draaien.</para>

	<para>De standaardwaarde voor <varname>kern.maxfiles</varname>
	  wordt bepaald door de optie <literal>MAXUSERS</literal> in
	  het bestand met kernelinstellingen.
	  <varname>kern.maxfiles</varname> groeit evenredig met de
	  waarde van <literal>MAXUSERS</literal>.  Als een aangepaste
	  kernel wordt gebouwd, is het een goed idee om deze
	  kerneloptie in te stellen afhankelijk van het gebruikt van
	  een systeemhet (maar niet te laag).  Hoewel een
	  produktieserver misschien niet 256 gebruikers gelijktijdige
	  gebruikers heeft, kunnen de benodigde systeembronnen best
	  vergelijkbaar zijn met een grootschalige webserver.</para>

	<note>
	  <para>Vanaf &os;&nbsp;4.5 kan meestal het beste
	    <literal>MAXUSERS</literal> op <literal>0</literal> gezet
	    worden in het bestand met kernelinstellingen.  Er wordt dan
	    een redelijke waarde gekozen, die gebaseerd is op de
	    hoeveelheid RAM in een systeem.</para>
	</note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm><primary><varname>kern.ipc.somaxconn</varname></primary></indexterm>

	<para>De sysctl variabele <varname>kern.ipc.somaxconn</varname>
	  beparkt de grootte van de luisterwachtrij voor het accepteren
	  van nieuwe TCP verbindingen.  De standaardwaarde van
	  <literal>128</literal> is meestal te laag voor robuuste
	  behandeling van nieuwe verbindingen in een zwaarbeladen
	  webserver omgeving.  Voor zulke omgevingen wordt aangeraden
	  deze waarde te verhogen tot <literal>1024</literal> of hoger.
	  De dienstdaemon beperkt misschien zelf de luisterwachtrij
	  (bijvoorbeeld &man.sendmail.8; of
	  <application>Apache</application>), maar heeft vaak een
	  mogelijkheid in een configuratiebestand de wachtrijgrootte
	  aan te passen.  Grote luisterwachtrijen zijn
	  ook beter in het ontwijken van Ontzegging van Dienst
	  (<abbrev>DoS</abbrev>) aanvallen.</para>
      </sect3>
    </sect2>

    <sect2 id="nmbclusters">
      <title>Netwerkbeperkingen</title>

      <para>De kerneloptie <literal>NMBCLUSTERS</literal> bepaalt het
	aantal netwerk Mbufs dat beschikbaar is voor een systeem.  Een
	veel bezochte server met een laag aantal Mbufs beperkt de
	mogelijkheden van &os;.  Elk cluster staat voor ongeveer
	2&nbsp;K geheugen, dus een waarde van 1024 stelt 2 megabyte
	aan kernelgeheugen voor, dat is gereserveerd voor
	netwerkbuffers.  Een simpele berekening geeft aan hoeveel er
	nodig is.  Stel dat een webserver met een maximum van 1000
	simultane verbindingen voor elke verbinding 16&nbsp;K aan
	ontvangst netwerkbuffers en 16&nbsp;K aan zendbuffers kost, dan
	is ongeveer 32&nbsp;MB aan netbuffers nodig voor de webserver.
	Een goede vuistregel is te vermeniguldigen met twee,
	dus 2x32&nbsp;MB&nbsp;/ 2&nbsp;KB&nbsp;= 64&nbsp;MB&nbsp;/
	2&nbsp;kB&nbsp;= 32768.  Voor machines met veel geheugen wordt
	4096 tot 32768 aangeraden.  Er moet in geen geval een arbitrair
	hoge waarde voor deze sysctl opgegeven worden, want dat kan
	leiden tot een crash tijdens het opstarten.  Met de optie
	<option>-m</option> van &man.netstat.1; kan clustergebruik
	van het netwerk bekeken worden.</para>

      <para>De loaderparameter <varname>kern.ipc.nmbclusters</varname>
	moet gebruikt worden om dit tijdens het opstarten toe te
	passen.  Alleen voor oudere versies van &os; is het nodig om de
	kerneloptie <literal>NMBCLUSTERS</literal> te gebruiken.</para>

      <para>Voor drukke servers die extensief gebruik maken van de
	systeemaanroep &man.sendfile.2;, kan het nodig zijn het aantal
	&man.sendfile.2; buffers te verhogen via de kerneloptie
	<literal>NSFBUFS</literal> of door de waarde in te stellen in
	<filename>/boot/loader.conf</filename> (in &man.loader.8; staan
	details).  Als er in de procestabel processen staan met een
	status <literal>sfbufa</literal> is dat een algemene indicator
	dat deze parameter aangepast moet worden.  De sysctl variabele
	<varname>kern.ipc.nsfbufs</varname> is alleen-lezen en
	laat zien op welke waarde deze kernelvariabele is ingesteld.
	Deze parameter schaalt engiszins met de variabele
	<varname>kern.maxusers</varname>, maar het kan nodig zijn om
	deze bij te stellen.</para>

      <important>
	<para>Zelfs als een socket als non-blocking gemarkeerd is, dan
	  nog kan het aanroepen van &man.sendfile.2; op de non-blocking
	  socket ertoe leiden dat er toch blokkade optreedt totdat er
	  voldoende <literal>struct sf_buf</literal>'s vrijgemaakt
	  zijn.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm><primary>net.inet.ip.portrange.*</primary></indexterm>

	<para>De sysctle variabelelen
	  <varname>net.inet.ip.portrange.*</varname> bepalen welke
	  reeks poortnummers automatisch gebonden wordt aan TCP en UDP
	  sockets.  Er zijn drie gebieden: een laag gebied, een
	  (standaard) middengebied en een hoog gebied.  De meeste
	  netwerkprogramma's gebruiken het standaardbereik, wat
	  begrensd wordt door
	  <varname>net.inet.ip.portrange.first</varname> en
	  <varname>net.inet.ip.portrange.last</varname> met
	  standaardwaarden van respectievelijk 1024 en 5000.  Gebonden
	  poortreeksen worden gebruikt voor uitgaande verbindingen en
	  het is onder bepaalde omstandigheden mogelijk dat poorten
	  op raken.  Dit gebeurt meestal in het geval van een zwaar
	  belaste webproxy.  Poortbereik is niet van belang als vooral
	  diensten draaien die zich bezighouden met inkomende
	  verbindingen, zoals een normale webserver, of als het aantal
	  uitgaande verbindingen beperkt is, zoals bij een mailrelay.
	  Voor situaties waarin een tekort aan poorten dreigt, wordt
	  aangeraden om <varname>net.inet.ip.portrange.last</varname>
	  bescheiden op te hogen.  Een waarde van
	  <literal>10000</literal>, <literal>20000</literal> of
	  <literal>30000</literal> is redelijk.  Er moet ook rekening
	  met effecten op firewalls gehouden worden als de poortreeks
	  gewijzigd wordt.  Sommige firewalls kunnen grote
	  poortreeksen blokkeren, meestal de lagere poorten, en
	  verwachten dat andere systemen hogere poorten gebruiken voor
	  uitgaande verbindingen.  Om deze reden wordt het aanbevolen
	  om <varname>net.inet.ip.portrange.first</varname> te
	  verlagen.</para>
      </sect3>

      <sect3>
	<title>TCP Bandbreedtevertragingsproduct (TCP Bandwidth Delay
	  Product)</title>

	<indexterm>
	  <primary>TCP bandbreedtevertragingsproduct</primary>

	  <secondary><varname>net.inet.tcp.inflight.enable</varname></secondary>
	</indexterm>

	<para>De TCP bandbreedtevertragingsproduct limitatie lijkt op
	  TCP/Vegas in NetBSD.  Het kan aangezet worden door de sysctl
	  variabelel <varname>net.inet.tcp.inflight.enable</varname>
	  de waarde <literal>1</literal> te geven.  Het systeem
	  tracht dan het bandbreedtevertragingssprodukt te berekenen
	  voor elke verbinding en beperkt dan de hoeveelheid gegevens
	  in de wachtrij naar het netwerk tot de hoeveelheid die
	  vereist is om maximale doorvoer te kunnen handhaven.</para>

	<para>Dit is nuttig bij gebruik van modems, Gigabit Ethernet of
	  zelfs bij hoge snelheid WAN links (of elke andere link met
	  een groot bandbreedtevertragingsprodukt), in het bijzonder
	  als ook windowschaling of een groot verzendwindow gebruikt
	  wordt.  Als deze optie aangezet wordt, dient ook
	  <varname>net.inet.tcp.inflight.debug</varname> de waarde
	  <literal>0</literal> te krijgen (geen debugging) en voor
	  produktiegebruik kan het instellen van
	  <varname>net.inet.tcp.inflight.min</varname> naar minstens
	  <literal>6144</literal> voordeel opleveren.  Het instellen
	  van hoge minima kan effectief het beperken van bandbreedte
	  ondermijnen, afhankelijk van de link.  De mogelijkheid tot
	  limitering zorgt ervoor dat de hoeveelheid data die opgebouwd
	  wordt, in tussentijdse route- en switchwachtrijen verlaagd
	  kan worden en tevens kan de hoeveelheid gegevens die
	  opgebouwd wordt in de interfacewachtrij van de lokale host
	  verlaagd worden.  Met minder pakketten in wachtrijen, kunnen
	  interactieve verbindingen opereren met lagere
	  <emphasis>Round Trip</emphasis> tijden, met name over
	  langzame modems.  Deze optie gaat alleen over datatransmissie
	  (upload / serverkant) en heeft geen effect gegevensontvangst
	  (download / clientkant).</para>

	<para>Aanpassen van
	  <varname>net.inet.tcp.inflight.stab</varname> wordt
	  <emphasis>niet</emphasis> aangeraden.  Deze parameter krijgt
	  standaard een waarde van 20, wat 2 maximale pakketten
	  opgeteld bij de bandbreedtevensterberekening representeert.
	  Het extra venster is nodig om het algoritme stabiel te houden
	  en om de reactietijd bij veranderende omstandigheden te
	  verbeteren, maar het kan ook leiden tot langere pingtijden
	  over langzame verbindingen (zonder het inflight algoritme kan
	  dit echter nog erger zijn).  In dergelijke gevallen kan deze
	  parameter misschien verlaagd worden naar 15, 10 of 5 en
	  misschien moet voor het gewenste effect ook
	  <varname>net.inet.tcp.inflight.min</varname> verlaagd worden
	  (bijvoorbeeld naar 3500).  Het verlagen van deze parameters
	  moet pas in laatste instantie overwogen worden.</para>

	<note>
	  <para>In 4.X en eerdere releases van &os; staan de sysctl
	    variabelen <literal>inflight</literal> direct onder
            <varname>net.inet.tcp</varname>.  Hun namen waren (in
            alfabetische volgorde):
            <varname>net.inet.tcp.inflight_debug</varname>,
            <varname>net.inet.tcp.inflight_enable</varname>,
            <varname>net.inet.tcp.inflight_max</varname>,
            <varname>net.inet.tcp.inflight_min</varname>,
            <varname>net.inet.tcp.inflight_stab</varname>.</para>
        </note>
      </sect3>
    </sect2>

    <sect2>
      <title>Virtueel Geheugen</title>

      <sect3>
	<title><varname>kern.maxvnodes</varname></title>

	<para>Een vnode is de interne representatie van een bestand of
	  een map.  Het verlagen van het aantal beschikbare vnodes
	  voor het besturingssysteem leidt dus tot een daling van disk
	  I/O.  Normaliter wordt dit door het besturingssysteem
	  afgehandeld en hoeft de instelling niet gewijzigd te worden.
	  Im sommige gevallen kan disk I/O de beperkende factor zijn en
	  kan het systeem alle beschikbare vnodes in gebruik hebben.
	  Dan dient deze instelling gewijzigd te worden.  De
	  hoeveelheid inactief en beschikbaar RAM dient meegenomen te
	  worden in de beslissing.</para>

	<para>Het huidige aantal gebruikte vnodes kan als volgt bekeken
	  worden:</para>

	<programlisting>&prompt.root; sysctl vfs.numvnodes
vfs.numvnodes: 91349</programlisting>

	<para>Om het maximale aantal vnodes weer te geven:</para>

	<programlisting>&prompt.root; sysctl kern.maxvnodes
kern.maxvnodes: 100000</programlisting>

	<para>Als het huidige aantal gebruikte vnodes dicht bij het
	  maximale aantal ligt, is het verstandig om
	  <varname>kern.maxvnodes</varname> op te hogen met 1.000.
	  Ook <varname>vfs.numvnodes</varname> dient in de gaten
	  gehouden te worden.  Als de waarde weer tot aan het maximum
	  stijgt, dan moet <varname>kern.maxvnodes</varname> verder
	  opgehoogd worden.  Er dient een verschuiving op te treden in
	  het door &man.top.1; gerapporteerde geheugengebruik.  Er
	  hoort meer geheugen actief te zijn.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Wisselbestandruimte toevoegen</title>

    <para>Hoe goed er ook gepland wordt, soms draait een systeem gewoon
      niet zoals verwacht.  Een oorzaak hiervoor kan een tekort aan
      wisselbestandruimte zijn.  Als blijkt dat er meer
      wisselbestandruimte nodig is, kan dat eenvoudig.  Er zijn drie
      manieren om de totale ruimte beschikbaar als wisselbestand te
      vergroten: een nieuwe harde schijf toevoegen, swappen over NFS of
      een wisselbestand maken op een bestaande (UFS of andere)
      partitie.</para>

    <sect2 id="new-drive-swap">
      <title>Wisselbestand (partitie) op een nieuwe harde
	schijf</title>

      <para>Dit is natuurlijk de beste manier om de
	wisselbestandsruimte te vergroten en een goed excuus om een
	extra harde schijf toe te voegen.  Die komt immers altijd wel
	van pas.  In dat geval kan het beste de discussie over
	wisselbestandruimte in <xref linkend="configtuning-initial">
	nog eens herlezen worden om wat suggesties te krijgen over hoe
	wisselbestandpartitie(s) het beste ingedeeld kunnen
	worden.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swappen over NFS</title>

      <para>In het algemeen wordt swappen over NFS niet aangeraden
	omdat het langzaam is.  Dit dient alleen gebruikt te worden als
	het onmogelijk om naar een lokale schijf te swappen.  In &os;
	versies voor 4.X was het hanteren van een wisselbestand over
	NFS erg langzaam en ineffici&euml;nt.  Nieuwere versies werken
	beter, maar dan nog wordt swappen over NFS sterk gelimiteerd
	door de aanwezige netwerkbandbreedte en belast het de NFS
	server.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Wisselbestanden</title>

      <para>Het is mogelijk om een bestand aan te maken van een
	bepaalde grootte en dit als swap te gebruiken.  In dit
	voorbeeld wordt een 64&nbsp;MB bestand gebruikt,
	<filename>/usr/swap0</filename>.  Uiteraard kan een
	willekeurige naam gebruikt worden.</para>

      <example>
	<title>Een wisselbestand aanmaken met &os;&nbsp;4.X</title>

	<orderedlist>
	  <listitem>
	    <para>De kernel moet het vnode stuurprogramma bevatten.  In
	      recente versies van <filename>GENERIC</filename>
	      is vnode <emphasis>niet</emphasis> opgenomen.</para>

	    <programlisting>pseudo-device vn   #Vnode driver (turns a file into a device)</programlisting>
	  </listitem>

	  <listitem>
	    <para>Een vn-apparaat aanmaken:</para>

	    <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Een wisselbestand aanmaken
	      (<filename>/usr/swap0</filename>):</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Correcte rechten op (<filename>/usr/swap0</filename>)
	      instellen:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Wisselbestand opnemen in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>Nu kan de machine herstart worden of het
	      wisselbestand meteen te gebruiken:</para>

	    <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
	  </listitem>
	</orderedlist>
      </example>

      <example>
	<title>Een wisselbestand aanmaken met &os;&nbsp;5.X</title>

	<orderedlist>
	  <listitem>
	    <para>De kernel moet het stuurprogramma voor de
	      geheugenschijf (&man.md.4;) bevatten.  Dat zit standaard
	      in de <filename>GENERIC</filename> kernel.</para>

	    <programlisting>device md   # Memory "disks"</programlisting>
	  </listitem>

	  <listitem>
	    <para>Het wisselbestand <filename>/usr/swap0</filename>
	      aanmaken:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>De correctie rechten op
	      <filename>/usr/swap0</filename> instellen:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Het wisselbestand opnemen in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>De machine moet herstart worden of om het
	      wisselbestand direct in te schakelen:</para>

	    <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0</userinput></screen>
	  </listitem>
	</orderedlist>
      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Geschreven door </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Energie- en bronnenbeheer</title>

    <para>Het is belangrijk om hardwarebronnen op een effici&euml;nte
      wijze te benutten.  Voordat <acronym>ACPI</acronym>
      ge&iuml;ntroduceerd werd was het erg lastig en onflexibel
      om het energieverbruik en de thermische eigenschappen van een
      systeem te beheersen.  De hardware werd beheerst door deze of
      gene interface, ingebed in het <acronym>BIOS</acronym>, zoals de
      <emphasis>Plug-n-play BIOS (PNPBIOS)</emphasis> of
      <emphasis>Advanced Power Management (APM)</emphasis>, enzovoort.
      Energie- en bronnenbeheer is een kerntaak van moderne
      besturingssystemen.  Het besturingssysteem moet bijvoorbeeld
      systeemlimieten in de gaten houdt (en mogelijk een SMS sturen of
      iets dergelijks) als de systeemtemperatuur onverwacht
      toeneemt.</para>

    <para>In dit deel van het &os; handboek wordt uitgebreide
      informatie verschaft over <acronym>ACPI</acronym>.  Aan het einde
      staan referenties naar meer leesmateriaal.
      <acronym>ACPI</acronym> is op &os;&nbsp;5.X en nieuwere systemen
      als een standaard ingeladen kernelmodule aanwezig.  In
      &os;&nbsp;4.9 kan <acronym>ACPI</acronym> aangezet worden door de
      regel <literal>device acpica</literal> toe te voegen aan het
      bestand met kernelinstellingen en een nieuwe kernel te bouwen en
      te installeren.</para>

    <sect2 id="acpi-intro">
      <title>Wat is ACPI?</title>

      <indexterm><primary>ACPI</primary></indexterm>

      <indexterm><primary>APM</primary></indexterm>

      <para>Advanced Configuration and Power Interface
	(<acronym>ACPI</acronym>) is een standaard die door een
	alliantie van producenten geschreven is, met als doel te
	voorzien in een een standaardinterface voor hardware bronnen-
	en energiebeheer.  Een belangrijk element is dat het meer
	flexibiliteit en beheersmogelijkheden biedt aan het
	besturingssysteem (<acronym>OS</acronym>).  Moderne systemen
	hebben de limieten van de huidige PNP interfaces verder
	opgerekt dan wenselijk en misschien wel mogelijk was.
	<acronym>ACPI</acronym> is de directe opvolger van
	<acronym>APM</acronym> (Advanced Power Management).  Centraal
	is het verleggen van hardwarebeheer en -monitoring naar de OS
	laag in plaats van de zeer beperkte BIOS laag.</para>
    </sect2>

    <sect2 id="acpi-old-spec">
      <title>Tekortkomingen van APM</title>

      <para>Met de <emphasis>Advanced Power Management (APM)</emphasis>
	faciliteit kan het energieverbruik van een systeem geregeld
	worden op basis van de systeemactiviteit.  Het APM BIOS wordt
	geleverd door de systeemproducent of -verkoper en het is
	specifiek voor dat betreffende hardware platform.  Een APM
	stuurprogramma in het besturingssysteem regelt vervolgens de
	toegang tot de <emphasis>APM Software Interface</emphasis>, die
	het besturen van vermogensniveau mogelijk maakt.</para>

      <para>Er zijn vier hoofdproblemen met APM te onderscheiden: ten
	eerste wordt het energiebeheer verricht door een BIOS
	(afhankelijk van producent) en het besturingssysteem heeft daar
	geen kennis van.  De gebruiker die idle-time waarden instelt
	voor een harde schijf in het APM BIOS is hier een voorbeeld
	van.  Dan zal het BIOS de harde schijf langzamer kunnen laten
	draaien zonder dat het besturingssysteem de noodzaak ziet of
	het goedkeurt.  Ten tweede: de APM logica is ingebed in de
	BIOS, waardoor het buiten het besturingssysteem om opereert.
	Dit houdt in dat gebruikers problemen met hun APM BIOS alleen
	kunnen verhelpen door een nieuw BIOS in het ROM te flashen,
	wat een gevaarlijke en mogelijk onherstelbare operatie is.
	Ten derde is APM een producent-specifieke technologie, in de
	zin dat er altijd een hoge mate van duplicatie zal zijn van al
	dan niet geslaagde pogingen om het wiel opnieuw uit te vinden
	en uiteraard ook van bugs.  Er is geen enkele garantie dat het
	wegnemen van een bug door een producent ook een zelfde bug
	wegneemt bij een concurrent.  Tenslotte is het van belang te
	weten dat de APM BIOS in het algemeen gewoon te weing geheugen
	kon gebruiken om een ingewikkeld energiebeheer te kunnen
	implementeren.  Laat staan dat deze goed aanpasbaar was aan
	veranderlijke doelstellingen voor de betreffende
	machine.</para>

      <para><emphasis>Plug-n-play BIOS (PNPBIOS)</emphasis> was
	in veel situations onbetrouwbaar.  PNPBIOS is 16-bit
	technologie, dus het besturingssysteem moet 16-bit emulatie
	gebruiken om met PNPBIOS methoden te kunnen samenwerken.</para>

      <para>Het &os; stuurprogramma <acronym>APM</acronym> is
	gedocumenteerd in &man.apm.4;.</para>
    </sect2>

    <sect2 id="acpi-config">
      <title><acronym>ACPI</acronym> instellen</title>

      <para>Het stuurprogramma <filename>acpi.ko</filename> wordt
	standaard geladen bij het opstarten door de &man.loader.8;
	en hoeft <emphasis>niet</emphasis> gecompileerd te worden.
	De redenatie is dat er met modules gemakkelijker gewerkt kan
	worden, bijvoorbeeld een andere <filename>acpi.ko</filename>
	gebruiken zonder dat er een nieuwe kernel gebouwd moet worden.
	Dit heeft het voordeel dat testen eenvoudiger is.  Een andere
	reden is dat het opstarten van <acronym>ACPI</acronym> nadat
	een systeem eenmaal volledig opgestart is, weinig nuttig is en
	in sommige gevallen fataal kan zijn.  In geval van tijfel kan
	<acronym>ACPI</acronym> beter uitgeschakeld worden.  Dit
	stuurprogramma kan niet gestopt worden als het eenmaal geladen
	is, omdat de systeembus het gebruikt voor allerlei interacties
	met hardware.  <acronym>ACPI</acronym> kan uitgezet worden met
	het hulpprogramma &man.acpiconf.8;.  In feite kan de meeste
	interactie met het <acronym>ACPI</acronym> systeem gedaan
	worden via &man.acpiconf.8;.  In wezen betekent dit dat als er
	iets over <acronym>ACPI</acronym> in &man.dmesg.8; staat, het
	hoogstwaarschijnlijk al draait.</para>

      <note>
	<para><acronym>ACPI</acronym> en <acronym>APM</acronym>
	  kunnen niet samenleven en moeten afzonderlijk en exclusief
	  gebruikt worden.  De laatste die gestart wordt bepaalt of het
	  stuurprogramma de ander wel of niet ziet.</para>
      </note>

      <para>In haar eenvoudigste vorm kan <acronym>ACPI</acronym>
	gebruikt worden om het systeem in slaapmodus te zetten met de
	vlag <option>-s</option> en een <literal>1-5</literal> optie
	met &man.acpiconf.8;.  De meeste gebruikers hebben alleen
	<literal>1</literal> nodig.  De optie <literal>5</literal>
	verricht een <quote>soft-off</quote>, wat hetzelfde is
	als:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Andere opties zijn mogelijk.  In &man.acpiconf.8; staat
	meer informatie.</para>
    </sect2>
  </sect1>

  <sect1 id="ACPI-debug">
    <sect1info>
      <authorgroup>
	 <author>
	   <firstname>Nate</firstname>
	   <surname>Lawson</surname>
	   <contrib>Geschreven door </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	 <author>
	   <firstname>Peter</firstname>
	   <surname>Schultz</surname>
	   <contrib>Met medewerking van </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	 <author>
	   <firstname>Tom</firstname>
	   <surname>Rhodes</surname>
	 </author>
      </authorgroup>
    </sect1info>

    <title>&os; <acronym>ACPI</acronym> gebruiken en debuggen</title>

    <para><acronym>ACPI</acronym> is een totaal nieuwe manier om
      apparaten te ontdekken, om energieverbruik te beheren en om een
      gestandaardiseerde toegang te bieden tot allerlei apparaten die
      eerder via het <acronym>BIOS</acronym> beheerd werden.  Er wordt
      voortdurend vooruitgang geboekt om <acronym>ACPI</acronym> op
      alle systemen te laten werken, maar bugs in de
      <firstterm><acronym>ACPI</acronym>Machine Language</firstterm>
      (<acronym>AML</acronym>) bytecode van sommige moederborden,
      onvolledigheden in &os;'s kernel subsystemen en bugs in de
      &intel; <acronym>ACPI-CA</acronym> interpreter blijven
      opduiken.</para>

    <para>Deze tekst is bedoeld om de &os; <acronym>ACPI</acronym>
      beheerders (<quote>maintainers</quote>) te helpen met het vinden
      van de hoofdoorzaken van problemen die voorkomen en met het
      debuggen en het vinden van een oplossing.</para>

    <sect2 id="ACPI-submitdebug">
      <title>Debuginformatie aanleveren</title>

      <note>
	<para>Voordat een probleem wordt aanmeld, moet het zeker zijn
	  dat de laatste <acronym>BIOS</acronym> versie draait en
	  indien beschikbaar de ge&iuml;ntregeerde controller
	  firmware versie.</para>
      </note>

      <para>Diegenen die meteen een probleem willen indienen, sturen
	de volgende informatie naar <ulink
	  url="mailto:freebsd-acpi@FreeBSD.org">
	  freebsd-acpi@FreeBSD.org</ulink>:</para>

      <itemizedlist>
	<listitem>
	  <para>Omschrijving van het foutieve gedrag, inclusief
	    systeemtype en model en alles wat de fout kan veroorzaken.
	    Als het een nieuw fenomeen is, dan dient ook zo accuraat
	    mogelijk aangegeven te worden wanneer de fout het eerst
	    optrad.</para>
	</listitem>

	<listitem>
	  <para>De &man.dmesg.8; uitvoer van <command>boot
	      -v</command>, inclusief foutmeldingen die gegenereerd
	    worden als de fout optreedt.</para>
	</listitem>

	<listitem>
	  <para>De &man.dmesg.8; uitvoer van <command>boot
	      -v</command> met <acronym>ACPI</acronym> uitgeschakeld,
	    indien het uitzetten van <acronym>ACPI</acronym> het
	    probleem oplost.</para>
	</listitem>

	<listitem>
	  <para>Uitvoer van <command>sysctl hw.acpi</command>.  Dit is
	    tevens een goede manier om uit te vinden welke
	    <acronym>ACPI</acronym> mogelijkheden een systeem
	    heeft.</para>
	</listitem>

	<listitem>
	  <para>Een <acronym>URL</acronym> waar de
	    <firstterm><acronym>ACPI</acronym>Source
	      Language</firstterm> (<acronym>ASL</acronym>) gevonden
	    kan worden.  De <acronym>ASL</acronym> dient
	    <emphasis>niet</emphasis> rechtstreeks naar de lijst
	    gezonden te worden, omdat deze nogal groot kan zijn.  Een
	    kopie van een ASL kan gemaakt worden met het volgende
	    commando:</para>

	  <screen>&prompt.root; <userinput>acpidump -t -d &gt; <replaceable>name</replaceable>-<replaceable>system</replaceable>.asl</userinput></screen>

	  <para>(Vervang een aanmeldnaam door
	    <filename>$NAME</filename> en producent/model door
	    <filename>$SYSTEM</filename>.  Bijvoorbeeld:
	    <filename>njl-FooCo6000.asl</filename>)</para>
	</listitem>
      </itemizedlist>

      <para>De meeste &os; programmeurs lezen de &a.current;
	mailinglijst, maar problemen gaan bij voorkeur ook naar
	&a.acpi.name; zodat ze zeker gezien worden.  Het kan enige tijd
	duren voordat er antwoord komt, omdat deze mensen elders ook
	nog fulltime banen hebben.  Als de bug niet meteen duidelijk
	is, komt er waarschijnlijk en verzoek om een
	<acronym>PR</acronym> in te dienen via &man.send-pr.1;.  Als er
	een <acronym>PR</acronym> moet worden opgesteld, dan dient alle
	hierboven gevraagde informatie vermeld te worden.  Dit helpt om
	het probleem te kunnen volgen en oplossen.  Het sturen van een
	<acronym>PR</acronym> zonder eerst &a.acpi.name; te mailen is
	niet wenselijk, aangezien men <acronym>PR</acronym>s gebruikt
	als herinnering, niet als rapportagesysteem.  Mogelijk is een
	probleem al eens door iemand anders aangemeld.</para>
    </sect2>

    <sect2 id="ACPI-background">
      <title>Achtergrond</title>

      <para><acronym>ACPI</acronym> is aanwezig op alle moderne
	computers die voldoen aan de ia32 (x86), ia64 (Itanium) of
	amd64 (AMD) architecturen.  De volledige standaard heeft vele
	mogelijkheden zoals <acronym>CPU</acronym> prestatiebeheer,
	energiebeheer, thermische zones, diverse batterijsystemen,
	ingebedde controllers en busnummering.  De meeste systemen
	implementeren minder dan de volledige standaard.  Een
	desktopsysteem implementeert bijvoorbeeld meestal alleen
	busnummering, terwijl laptops mogelijk ook koeling- en
	batterijbeheer ondersteunen.  Laptops hebben ook suspend en
	resume (slapen en wakker worden) met hun eigen aanverwante
	comlexiteit.</para>

      <para>Een <acronym>ACPI</acronym>-compliant systeem heeft
	verscheidene componenten.  Het <acronym>BIOS</acronym> is de
	eerste en dan zijn er verscheidene tabellen in het geheugen
	zoals <acronym>FADT</acronym> die zaken als de
	<acronym>APIC</acronym> map (gebruikt voor
	<acronym>SMP</acronym>) specificeren, beschikbaar gesteld door
	verschillende producenten/verkopers.  Daarnaast zijn er
	specifieke eenvoudige instellingen en instellingenregisters,
	ook allen specifiek voor de leverancier.  Ook wordt er een
	tabel van bytecode (de <firstterm>Differentiated System
	  Description Table</firstterm> <acronym>DSDT</acronym>)
	geleverd die een op een boomstructuur lijkende namespace biedt
	voor apparaten en apparaatobjectfuncties.</para>

      <para>Het stuurprogramma <acronym>ACPI</acronym> moet de
	voorgedefinieerde tabellen verwerken, een interpreter voor
	de bytecode implementeren en apparaatstuurprogramma's en de
	kernel aanpassen om alleen al informatie van het
	<acronym>ACPI</acronym> subsysteem te kunnen accepteren.
	&intel; heeft een interpreter beschikbaar gesteld
	(<acronym>ACPI-CA</acronym>) die door &os; en ook door &linux;
	en NetBSD gebruikt wordt.  De <acronym>ACPI-CA</acronym>
	broncode staat in <filename
	  class="directory">src/sys/contrib/dev/acpica</filename>.  De
	lijmcode (<quote>glue code</quote>) die
	<acronym>ACPI-CA</acronym> laat werken met &os; staat in
	<filename>src/sys/dev/acpica/Osd</filename>.  Stuurprogramma's
	die verscheidene <acronym>ACPI</acronym> apparaten
	implementeren staan in <filename
	  class="directory">src/sys/dev/acpica</filename>.</para>
    </sect2>

    <sect2 id="ACPI-comprob">
      <title>Algemene problemen</title>

      <para>Wil <acronym>ACPI</acronym> goed werken, dan moeten alle
	onderdelen goed werken.  Hieronder staan enkele algemene
	problemen in volgorde van hoe vaak ze optreden en enkele
	mogelijke oplossingen of manieren om de problemen te
	vermijden.</para>

      <sect3>
	<title>Muisproblemen</title>

	<para>Soms doet een muis het niet bij het opstarten uit de
	  slaapstand.  Een bekend lapmiddel is het toevoegen van
	  <literal>hint.psm.0.flags="0x3000"</literal> aan het bestand
	  <filename>/boot/loader.conf</filename>.  Als dat niet werkt,
	  dan wordt aangeraden een bugrapport in te sturen, zoals
	  eerder is beschreven.</para>
      </sect3>

      <sect3>
	<title>Suspend/resume</title>

	<para><acronym>ACPI</acronym> heeft drie slaapstanden waarbij
	  het geheugen (<acronym>RAM</acronym>) wordt ingezet.  Dit
	  zijn de <acronym>STR</acronym> toestanden
	  <literal>S1</literal>-<literal>S3</literal>,en nog een
	  slaap-met-gebruik-van-harde-schijf toestand
	  (<literal>STD</literal>) die <literal>S4</literal> heet.
	  <literal>S5</literal> is <quote>zacht uit</quote> en is de
	  normale status van een systeem als het is aangesloten maar
	  niet is aangezet.  <literal>S4</literal> kan feitelijk op
	  twee manieren ge&iuml;mplementeerd worden:
	  <literal>S4</literal><acronym>BIOS</acronym> is een
	  slaapstand naar schijf met behulp van het
	  <acronym>BIOS</acronym> en
	  <literal>S4</literal><acronym>OS</acronym> wordt volledig
	  door het besturingssysteem beheerd.</para>

	<para>als eerste dienen de <command>sysctl</command>
	  <option>hw.acpi</option> items die iets met de slaapstand
	  te maken hebben gecontroleerd te worden.  Hieronder staan de
	  resultaten voor een Thinkpad:</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</screen>

	<para>Dit betekent dat hier <command>acpiconf -s</command>
	  gebruikt kan worden om <literal>S3</literal>,
	  <literal>S4</literal> <acronym>OS</acronym> en
	  <literal>S5</literal> te testen.  Als <option>s4bios</option>
	  gelijk was aan (<literal>1</literal>), dan zou er
	  <literal>S4</literal><acronym>BIOS</acronym> ondersteuning
	  zijn in plaats van <literal>S4</literal>
	  <acronym>OS</acronym>.</para>

	<para>Als suspend/resume getest moet worden, dient, indien
	  ondersteund, bij <literal>S1</literal> begonnen te worden.
	  Deze toestand heeft de grootste kans om te werken, omdat deze
	  niet veel stuurprogrammaondersteuning vereist.  Niemand heeft
	  nog <literal>S2</literal> ge&iuml;mplementeerd, maar het is
	  ongeveer hetzelfde als <literal>S1</literal>.  Daarna wordt
	  <literal>S3</literal> getest.  Dit is het diepste
	  <acronym>STR</acronym> niveau en heeft uitgebreide
	  ondersteuning van stuurprogramma's nodig om hardware goed
	  opnieuw te kunnen starten.  Mochten er blokkades optreden,
	  dan kan naar de &a.acpi.name; lijst gemaild worden.  Er kan
	  echter geen snelle oplossing verwacht worden, omdat er nog de
	  nodige stuurprogramma's/hardware liggen om getest en bewerkt
	  te worden.</para>

	<para>Om een probleem te kunnen isoleren helpt het om zoveel
	  mogelijk stuurprogramma's uit de kernel te halen.  Als dit
	  werkt, kan er teruggewerkt worden naar de driver die schuldig
	  is aan het falen.  Meestal vertonen binaire stuurprogramma's
	  als <filename>nvidia.ko</filename>, X11
	  beeldschermstuurprogramma's en <acronym>USB</acronym> de
	  meeste problemen, terwijl bijvoorbeeld Ethernet
	  interfaces meestal meteen goed werken.  Als de
	  stuurprogramma's zonder problemen geladen en verwijderd
	  kunnen worden, dan is dit te automatiseren door de juiste
	  commando's in <filename>/etc/rc.suspend</filename> en
	  <filename>/etc/rc.resume</filename> te zetten.  Er staat een
	  voorbeeld (achter commentaartekens) voor het laden en
	  verwijderen van een driver.  Als het beeldscherm er na
	  wakker worden vreemd uitziet, kan geprobeerd worden
	   <option>hw.acpi.reset_video</option> naar nul
	   (<literal>0</literal>) te zetten.  Met langere of kortere
	   waarden voor <option>hw.acpi.sleep_delay</option> kan
	   bekeken worden of dat helpt.</para>

	<para>In geval van problemen is het ook een optie om een
	  recente &linux; distibutie met ondersteuning voor
	  <acronym>ACPI</acronym> support te starten en daarvan de
	  suspend/resume ondersteuning op dezelfde hardware uit te
	  proberen.  Als het werkt met &linux;, dan is het
	  waarschijnlijk een &os; stuurprogrammaprobleem en als het
	  mogelijk is uit te vinden over welke driver het gaat, kan dat
	  bijdragen aan het oplossen van het probleem.
	  <acronym>ACPI</acronym> houdt zich in het algemeen niet bezig
	  met andere stuurprogramma's bijvoorbeeld geluid,
	  <acronym>ATA</acronym>, enzovoort.  Als er dus een echt
	  driverprobleem is, dan is waarchijnlijk uiteindelijk
	  ook nodig naar de &a.current.name; lijst te posten en naar de
	  beheerder van het stuurprogramma.  Voor degenen met moed is
	  het vooral aan te raden een paar &man.printf.3;s in
	  problematische stukken van een stuurprogramma te plaatsen
	  voor debugging om na te gaan waar de resumefunctie precies
	  hangt.</para>

	<para>Tot slot kan geprobeerd worden om <acronym>ACPI</acronym>
	  uit te zetten en in plaats daarvan <acronym>APM</acronym> aan
	  te zetten.  Als suspend/resume werkt met
	  <acronym>APM</acronym>, is het wellicht verstandig het
	  daarbij te houden, vooral met wat oudere apparatuur (voor
	  2000).  Producenten hebben nogal wat tijd nodig gehad om
	  <acronym>ACPI</acronym> ondersteuning goed te krijgen en
	  voor oudere hardware is het waarschijnlijker dat er
	  <acronym>BIOS</acronym> problemen zijn met
	  <acronym>ACPI</acronym>.</para>
      </sect3>

      <sect3>
	<title>Systeem hangt (tijdelijk of permanent)</title>

	<para>Meestal is het hangen van het systeem het gevolg van
	  verloren interrupts of een interruptstorm.  Chipsets kunnen
	  een heleboel problemen hebben, afhankelijk van hoe het
	  <acronym>BIOS</acronym> interrupts instelt voor het
	  opstarten, of de <acronym>APIC</acronym>
	  (<acronym>MADT</acronym>) tabel correct is en de routering
	  van het <firstterm>System Control Interrupt</firstterm>
	  (<acronym>SCI</acronym>).</para>

	<indexterm><primary>interrupt storms</primary></indexterm>

	<para>Interruptstorms kunnen onderscheiden worden van verloren
	  geraakte interrupts door de uitvoer van <command>vmstat
	    -i</command> te controleren en de regel met
	  <literal>acpi0</literal> goed te lezen.  Als de teller in
	  toenemende mate hoger staat dan enkele per seconde, dan is
	  sprake van een interruptstorm.  Als het systeem lijkt te
	  hangen, is het wellicht nog mogelijk door te dringen tot
	  de <acronym>DDB</acronym> (<keycombo
	    action="simul"><keycap>CTRL</keycap>
	    <keycap>ALT</keycap><keycap>ESC</keycap></keycombo>)
	  <literal>show interrupts</literal> uit te voeren.</para>

	<indexterm>
	  <primary>APIC</primary>

	  <secondary>uitschakelen</secondary>
	</indexterm>

	<para>De beste hoop in geval van interruptproblemen
	  is om <acronym>APIC</acronym> ondersteuning uit te zetten met
	  <literal>hint.apic.0.disabled="1"</literal> in
	  <filename>loader.conf</filename>.</para>
      </sect3>

      <sect3>
	<title>Panics</title>

	<para>Panics zijn relatief zeldzaam met <acronym>ACPI</acronym>
	  en krijgen de hoogste prioriteit bij het oplossen.  Eerst
	  moeten de verschillende gebeurtenissen waarmee de
	  panic (als mogelijk) te reproduceren is ge&iuml;soleerd
	  worden en moet een backtrace gemaakt worden.
	  <literal>options DDB</literal> dient aangezet te worden en er
	  dient een een seri&euml;le console (<xref
	    linkend="serialconsole-ddb">) of een &man.dump.8; partitie
	  te komen..  In <acronym>DDB</acronym> is een backtrace te
	  maken met <literal>tr</literal>.  Als de backtrace handmatig
	  opgeschreven moet worden, is het belangrijk dat in ieder
	  geval de bovenste en onderste vijf (5) regels van de
	  backtrace genoteerd worden.</para>

	<para>Daarna dient getracht te worden het systeem te starten
	  zonder <acronym>ACPI</acronym>.  Als dat werkt, is het
	  <acronym>ACPI</acronym> subsysteem ge&iuml;soleerd en kunnen
	  de verschillende <option>debug.acpi.disable</option> waarden
	  uitgeprobeerd worden.  In &man.acpi.4; staan enkele
	  voorbeelden.</para>
      </sect3>

      <sect3>
	<title>Systeem slaat aan na slaapstand of stop</title>
	<para><literal>hw.acpi.disable_on_poweroff="0"</literal> kan
	  uitgezet worden in &man.loader.conf.5;.  Hierdoor schakelt
	  <acronym>ACPI</acronym> bepaalde gebeurtenissen tijdens het
	  afsluitproces niet uit.  Om dezelfde redenen moeten sommige
	  systemen deze waarde altijd op <literal>1</literal>
	  (standaard) hebben staan.  In het algemeen lost dit een
	  probleem op waarbij een systeem spontaan weer opkomt
	  nadat het in slaapstand is gezet of geheel gestopt is.</para>
      </sect3>

      <sect3>
	<title>Overige problemen</title>

	<para>Als er nog andere problemen zijn met
	  <acronym>ACPI</acronym> (met een docking station of
	  apparaten niet gedetecteerd, enzovoort), dan kan een mail
	  met beschijving naar de mailinglijst gezonden worden.
	  Sommige zaken kunnen echter gerelateerd zijn aan delen van
	  het <acronym>ACPI</acronym> subsysteem die nog niet af zijn,
	  dus het kan in sommige gevallen een tijd duren.  Gebruikers
	  moeten soms geduld hebben en de bereidheid om eventuele
	  patches uit te proberen.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>, <command>acpidump</command> en
	<acronym>IASL</acronym></title>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>ASL</secondary>
      </indexterm>

      <para>Het grootste probleem is dat <acronym>BIOS</acronym>
	producenten vaak incorrecte (of gewoon foutieve) bytecode
	leveren.  Dit blijkt doorgaans uit kernelboodschappen
	als:</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>Vaak kunnen dergelijke problemen geoplost worden door de
	<acronym>BIOS</acronym> bij te werken tot de laatste revisie.
	De meeste consoleberichten zijn onschuldig, maar als er andere
	problemen zijn, zoals batterijstatus die niet werkt, dan ligt
	het voor de hand te zoeken naar problemen in de
	<acronym>AML</acronym> code.  De bytecode die
	<acronym>AML</acronym> genoemd wordt, wordt gecompileerd van
	een broncodetaal <acronym>ASL</acronym>.  Deze staat weer in
	een tabel <acronym>DSDT</acronym>.  Met &man.acpidump.8; kan
	een kopie van de <acronym>ASL</acronym> gemaakt worden.  Dan
	moeten zowel de opties <option>-t</option> (laat inhoud van
	vaste tabellen zien) als <option>-d</option> (disassembleer
	<acronym>AML</acronym> naar <acronym>ASL</acronym>) gebruikt
	worden.  In <link linkend="ACPI-submitdebug">Debuginformatie
	  aanleveren</link> staat een voorbeeld.</para>

      <para>De eenvoudigste eerste controle is de
	<acronym>ASL</acronym> code opnieuw compileren en kijken of
	er foutmeldingen optreden.  Waarschuwingen kunnen doorgaans
	genegeerd worden, maar fouten zijn bugs die er meestal toe
	leiden dat <acronym>ACPI</acronym> niet correct werkt.  Om
	<acronym>ASL</acronym> te hercompileren:</para>

      <screen>&prompt.root; <userinput>iasl eigen.asl</userinput></screen>
    </sect2>

    <sect2 id="ACPI-fixasl">
      <title><acronym>ASL</acronym> repareren</title>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>ASL</secondary>
      </indexterm>

      <para>Op langere termijn is het de bedoeling dat voor vrijwel
	elke machine <acronym>ACPI</acronym> werkt zonder enig
	ingrijpen van de gebruiker.  Op dit moment wordt er echter nog
	gewerkt aan oplossingen voor veel voorkomende vergissingen die
	<acronym>BIOS</acronym> producenten maken.  De &microsoft;
	interpreter (<filename>acpi.sys</filename> en
	<filename>acpiec.sys</filename>) controleert niet strikt of het
	<acronym>BIOS</acronym> volledig aan de standaard voldoet,
	waardoor het voorkomt dat <acronym>BIOS</acronym> makers die
	alleen testen onder &windows; bepaalde fouten in hun
	<acronym>ASL</acronym> nooit correct repareren.  &os; hoopt
	door te gaan met de identificatie en documentatie van welk
	niet-standaard gedrag precies wordt toegelaten door
	&microsoft;'s interpreter en te dit te repliceren zodat &os;
	kan werken zonder dat gebruikers zich gedwongen zien om de
	<acronym>ASL</acronym> te repareren.  Als een tijdelijke
	oplossing en om te helpen met het in kaart brengen van bepaald
	gedrag, kan de <acronym>ASL</acronym> handmatig gerepareerd
	worden.  Mocht dit lukken, dan wordt erop aangedrongen een
	&man.diff.1; van de oude en de nieuwe <acronym>ASL</acronym>
	te mailen, zodat het foutieve gedrag mogelijk in
	<acronym>ACPI-CA</acronym> kan worden verwerkt, waardoor
	andere gebruikers niet meer handmatig met hun
	<acronym>ASL</acronym> aan de gang hoeven.</para>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>error messages</secondary>
      </indexterm>

      <para>Hieronder staat een lijst algemene foutmeldingen, hun
	oorzaken en hoe ze op te lossen:</para>

      <sect3>
	<title>_OS afhankelijkheden</title>

	<para>Sommige <acronym>AML</acronym>s gaan ervan uit dat de
	  wereld enkel bestaat uit &windows; versies.  &os; kan zich
	  voordoen als elk <acronym>OS</acronym> om te kijken of dit
	  problemen oplost.  Een gemakkelijke manier om dit te doen is
	  <literal>hw.acpi.osname="Windows 2001"</literal> in te
	  stellen in <filename>/boot/loader.conf</filename> of andere
	  gelijksoortige strings die in een <acronym>ASL</acronym>
	  staan.</para>
      </sect3>

      <sect3>
	<title>Ontbrekende return opdrachten</title>

	<para>Sommige methoden hebben geen specifieke returnwaarde,
	  zoals wel vereist wordt door de standaard.  Hoewel
	  <acronym>ACPI-CA</acronym> hier niets mee doet, heeft &os;
	  de mogelijkheid tot impliciete returns.  Er kunnen ook
	  expliciet return opdrachten toegevoegd worden waar vereist,
	   als het bekend is welke waarden teruggevoerd moeten worden.
	   Om <command>iasl</command> te dwingen tot compilatie van
	   <acronym>ASL</acronym> kan de schakeloptie
	   <option>-f</option> gebruikt worden.</para>
      </sect3>

      <sect3>
	<title>De standaard <acronym>AML</acronym> aanpassen</title>

	<para>Nadat <filename>eigen.asl</filename> aangepast is, kan
	  deze als volgt gecompileerd wordent:</para>

	<screen>&prompt.root; <userinput>iasl eigen.asl</userinput></screen>

	<para>Met de optie <option>-f</option> is af te dwingen dat de
	  <acronym>AML</acronym> gemaakt wordt, zelfs als er
	  compileerfouten optreden.  Sommige fouten (zoals ontbrekende
	  return opdrachten) worden automatisch opgelost door de
	  interpreter.</para>

	<para><filename>DSDT.aml</filename> is de standaardnaam voor
	  het bestand dat door <command>iasl</command> wordt
	  geproduceerd.  Dit is in plaats van de foutieve versie uit
	  het <acronym>BIOS</acronym> (die nog steeds
	  aanwezig is in het flashgeneugen) te laden door
	  <filename>/boot/loader.conf</filename> als volgt te
	  wijzigen:</para>

	<programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

	<para><filename>DSDT.aml</filename> moet in de map <filename
	    class="directory">/boot</filename> staan.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-debugoutput">
      <title>Debuguitvoer van <acronym>ACPI</acronym>
	verkrijgen</title>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>problemen</secondary>
      </indexterm>

      <indexterm>
	<primary>ACPI</primary>

	<secondary>debuggen</secondary>
      </indexterm>

      <para>Het stuurprogramma <acronym>ACPI</acronym> heeft een zeer
	flexibele debugfaciliteit.  Er kan zowel een set van
	subsystemen aangegeven worden als het niveau van uitvoerigheid.
	De te debuggen subsystemen worden aangegeven als lagen
	(<quote>layers</quote>) en zijn opgedeeld in
	<acronym>ACPI-CA</acronym> componenten (ACPI_ALL_COMPONENTS)
	en <acronym>ACPI</acronym> hardware ondersteuning
	(ACPI_ALL_DRIVERS).  De uitvoerigheid van debuguitvoer wordt
	aangegeven als het niveau (<quote>level</quote>) en gaat van
	CPI_LV_ERROR (alleen fouten rapporteren) tot ACPI_LV_VERBOSE
	(alles).  Het niveau is een bitmasker en dus kunnen er meerdere
	opties tegelijk ingeschakeld worden (gescheiden door spaties).
	In de praktijk wordt wellicht een seri&euml;le console gebruikt
	om de uitvoer te loggen als deze zo omvangrijk is dat de
	console berichtbuffer vol loopt (misschien wel meerdere keren).
	Een complete lijst van de individuele lagen en niveaus staat
	in &man.acpi.4;.</para>

      <para>Debuguitvoer staat staandaard niet aan.  Door
	<literal>options ACPI_DEBUG</literal> toe te voegen aan het
	bestand met kernelinstellingen als <acronym>ACPI</acronym> als
	de kernel is gebouwd, wordt het ingeschakeld.  Door
	<literal>ACPI_DEBUG=1</literal> toe te voegen aan
	<filename>/etc/make.conf</filename> wordt het systeembreed
	ingeschakeld.  Als <acronym>ACPI</acronym> als module wordt
	gebruikt (de normale situatie), dan hoeft slechts de
	<filename>acpi.ko</filename> module opnieuw gecompileerd te
	worden:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp;
make ACPI_DEBUG=1</userinput></screen>

      <para><filename>acpi.ko</filename> moet in
	<filename class="directory">/boot/kernel</filename> komen te
	staan en de gewenste debuglaag en het gewenste
	niveau van uitvoerigheid dienen toegevoegd te worden aan
	<filename>loader.conf</filename>.  Hieronder een voorbeeld
	waarmee debuguitvoer wordt aangezet voor alle
	<acronym>ACPI-CA</acronym> componenten en alle
	<acronym>ACPI</acronym> hardware stuurprogramma's
	(<acronym>CPU</acronym>, <acronym>LID</acronym>, enzovoort.
	Het niveau van uitvoerigheid is het laagst mogelijke.  Er
	worden alleen fouten gemeld.</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Als de gezochte informatie wordt veroorzaakt door een
	specifieke gebeurtenis (bijvoorbeeld in en uit slaapstand
	gaan), dan kunnen wijzigingen aan
	<filename>loader.conf</filename> achterwege blijven en in
	plaats daarvan kan <command>sysctl</command> gebruikt worden om
	laag en niveau in te stellen na het opstarten en zo het systeem
	voor te bereiden op die specifieke gebeurtenis.  De
	<command>sysctl</command>s hebben dezelfde namen als de
	parameters in <filename>loader.conf</filename>.</para>
    </sect2>

    <sect2 id="ACPI-References">
      <title>Verwijzingen</title>

      <para>Meer informatie over <acronym>ACPI</acronym> staat op de
	volgende locaties:</para>

      <itemizedlist>
	<listitem>
	  <para>De &a.acpi;</para>
	</listitem>

	<listitem>
	  <para>De <acronym>ACPI</acronym> mailinglijst archieven
	    <ulink
	      url="http://lists.freebsd.org/pipermail/freebsd-acpi/">
	    </ulink></para>
	</listitem>

	<listitem>
	  <para>De oude <acronym>ACPI</acronym> mailinglijst archieven
	    <ulink url="http://home.jp.FreeBSD.org/mail-list/acpi-jp/">
	    </ulink></para>
	</listitem>

	<listitem>
	  <para>De <acronym>ACPI</acronym> 2.0 specificatie
	    <ulink url="http://acpi.info/spec.htm">
	    </ulink></para>
	</listitem>

	<listitem>
	  <para>&os; Handleidingen: &man.acpi.4;,
	    &man.acpi.thermal.4;, &man.acpidump.8;, &man.iasl.8;,
	    &man.acpidb.8;</para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
	      <acronym>DSDT</acronym> debugging informatie</ulink>.
	    (Gebruikt Compaq als voorbeeld, maar van algemeen
	    nut).</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
