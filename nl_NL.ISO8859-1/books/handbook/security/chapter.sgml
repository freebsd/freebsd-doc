<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$

     %SOURCE%	en_US.ISO8859-1/books/handbook/security/chapter.sgml
     %SRCID%	39016
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Matthew</firstname>
	<surname>Dillon</surname>
	<contrib>Veel uit dit hoofdstuk is overgenomen uit de
	  security(7) handleiding van </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Siebrand</firstname>
	<surname>Mazeland</surname>
	<contrib>Vertaald door </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Beveiliging</title>

  <indexterm><primary>beveiliging</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>Overzicht</title>

    <para>Dit hoofdstuk biedt een basisinleiding in
      systeembeveiligingsconcepten, een aantal goede basisregels en
      een paar gevorderde onderwerpen binnen &os;.  Veel van de
      onderwerpen die worden behandeld kunnen ook worden toegepast op
      systemen en Internet in het algemeen.  Het Internet is niet
      langer een <quote>vriendelijke</quote> omgeving waar iedereen
      een goede buur wil zijn.  Het beveiligen van een systeem is
      onontbeerlijk als gegevens, intellectueel eigendom, tijd en wat
      dan ook uit de handen van hackers en dergelijke gehouden moeten
      worden.</para>

    <para>&os; biedt veel hulpmiddelen en mechanismen om te zorgen
      voor de integriteit en veiligheid van een systeem en
      netwerk.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>Van basis systeembeveiligingsconcepten in relatie tot
	  &os;.</para>
      </listitem>

      <listitem>
	<para>Meer over verschillende versleutelingsmechanismen die
	  beschikbaar zijn in &os; zoals <acronym>DES</acronym> en
	  <acronym>MD5</acronym>.</para>
      </listitem>

      <listitem>
	<para>Hoe eenmalige wachtwoordautenticatie opgezet kan
	  worden.</para>
      </listitem>

      <listitem>
	<para>Hoe <acronym>TCP</acronym> Wrappers in te stellen voor
	  gebruik met <application>inetd</application>.</para>
      </listitem>

      <listitem>
	<para>Hoe <application>Kerberos5</application> op &os; opgezet
	  kan worden.</para>
      </listitem>

      <listitem>
	<para>Hoe IPsec wordt ingesteld en hoe een
	  <acronym>VPN</acronym> op te zetten tussen &os; en
	  &microsoft.windows; machines.</para>
      </listitem>

      <listitem>
	<para>Hoe <application>OpenSSH</application>, &os;'s
	  <acronym>SSH</acronym> implementatie, in te stellen en te
	  gebruiken.</para>
      </listitem>

      <listitem>
	<para>Wat bestandssysteem-<acronym>ACL</acronym>s zijn en hoe
	  die te gebruiken;</para>
      </listitem>

      <listitem>
	<para>Hoe het hulpprogramma
	  <application>Portaudit</application> gebruikt kan worden om
	  softwarepakketten uit de Portscollectie te auditen.</para>
      </listitem>

      <listitem>
	<para>Hoe om te gaan met publicaties van &os;
	  beveiligingswaarschuwingen.</para>
      </listitem>

      <listitem>
	<para>Iets van procesaccounting en hoe dat is in te schakelen
	  in &os;.</para>
      </listitem>
    </itemizedlist>

    <para>Er wordt aangenomen dat de lezer van dit hoofdstuk:</para>

    <itemizedlist>
      <listitem>
	<para>Basisbegrip heeft van &os; en Internetconcepten.</para>
      </listitem>
    </itemizedlist>

    <para>In dit boek worden nog meer onderwerpen met betrekking tot
      beveiliging beschreven.  Zo wordt bijvoorbeeld Verplichte
      Toegangscontrole (Mandatory Access Control) besproken in <xref
	linkend="mac"> en Internet Firewalls in <xref
	linkend="firewalls">.</para>
  </sect1>

  <sect1 id="security-intro">
    <title>Introductie</title>

    <para>Beveiliging is een taak die begint en eindigt bij de
      systeembeheerder.  Hoewel alle BSD &unix; meergebruikerssystemen
      enige inherente beveiliging kennen, is het bouwen en onderhouden
      van additionele beveiligingsmechanismen om de gebruikers
      <quote>eerlijk</quote> te houden waarschijnlijk een van de
      zwaarste taken voor de systeembeheerder.  Machines zijn zo veilig
      als ze gemaakt worden en beveiligingsoverwegingen staan altijd op
      gespannen voet met de wens om gebruiksvriendelijkheid.  &unix;
      systemen zijn in het algemeen in staat tot het tegelijkertijd
      uitvoeren van een enorm aantal processen en veel van die
      processen acteren als server - daarmee wordt bedoeld dat externe
      entiteiten er verbindingen mee kunnen maken en ertegen kunnen
      praten.  Nu de minicomputers en mainframes van gisteren de
      desktops van vandaag zijn en computers onderdeel zijn van
      netwerken en internetwerken, wordt beveiliging nog
      belangrijker.</para>

    <para>Systeembeveiliging heeft ook te maken met het omgaan met
      verschillende vormen van aanvallen, zoals een poging om een
      systeem te crashen of op een andere manier onstabiel te maken,
      zonder te proberen de <username>root</username> account aan te
      vallen (<quote>break root</quote>).  Aandachtspunten voor
      beveiliging kunnen opgesplitst worden in categorie&euml;n:</para>

    <orderedlist>
      <listitem>
	<para>Ontzeggen van dienst aanvallen (<quote>Denial of
	    Service</quote>).</para>
      </listitem>

      <listitem>
	<para>Gebruikersaccounts compromitteren.</para>
      </listitem>

      <listitem>
	<para><username>root</username> compromitteren via
	  toegankelijke servers.</para>
      </listitem>

      <listitem>
	<para><username>root</username> compromitteren via
	  gebruikersaccounts.</para>
      </listitem>

      <listitem>
	<para>Achterdeur cre&euml;ren (<quote>Backdoor</quote>).</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS aanvallen</primary>

      <see>Ontzegging van Dienst (DoS)</see>
    </indexterm>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>Ontzegging van Dienst DoS aanvallen</secondary>

      <see>(DoS)</see>
    </indexterm>

    <indexterm><primary>Ontzegging van Dienst (DoS)</primary></indexterm>

    <para>Een ontzegging van dienst (DoS) aanval is een techniek die
      de machine middelen ontneemt.  In het algemeen zijn DoS aanvallen
      brute kracht mechanismen die proberen de machine te crashen of op
      een andere manier onbruikbaar te maken door de machine of de
      netwerkcode te overvragen.  Sommige DoS aanvallen proberen
      misbruik te maken van bugs in de netwerkcode om een machine met
      een enkel pakket te crashen.  Zoiets kan alleen gerepareerd
      worden door een aanpassing aan de kernel te maken.  Aanvallen op
      servers kunnen vaak hersteld worden door op de juiste wijze
      opties in stellen om de belasting van servers te limiteren in
      ongunstige omstandigheden.  Omgaan met brute kracht aanvallen is
      lastiger.  Zo is een aanval met gefingeerde pakketten
      (<quote>spoofed-packet</quote>) vrijwel niet te stoppen, behalve
      dan door het systeem van Internet los te koppelen.  Misschien
      gaat de machine er niet door plat, maar het kan wel een volledige
      Internetverbinding verzadigen.</para>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>account compromitteren</secondary>
    </indexterm>

    <para>Een gecompromitteerde gebruikersaccount komt nog veel vaker
      voor dan een DoS aanval.  Veel systeembeheerders draaien nog
      steeds standaard <application>telnetd</application>,
      <application>rlogind</application>,
      <application>rshd</application> en
      <application>ftpd</application> servers op hun machines.  Deze
      servers communiceren standaard niet over beveiligde verbindingen.
      Het resultaat is dat als er een redelijk grote gebruikersgroep
      is, er altijd wel van een of meer van de gebruikers die van
      afstand op dat systeem aanmelden (wat toch de meest normale en
      makkelijke manier is om op een systeem aan te melden) het
      wachtwoord is afgeluisterd (<quote>sniffed</quote>).  Een
      oplettende systeembeheerder analyseert zijn logboekbestanden om
      te zoeken naar verdachte bronadressen, zelfs als het om
      succesvolle aanmeldpogingen gaat.</para>

    <para>Uitgangspunt moet altijd zijn dat als een aanvaller toegang
      heeft tot een gebruikersaccount, de aanvaller de
      <username>root</username> account kan compromitteren.  In
      werkelijkheid is het wel zo dat voor een systeem dat goed
      beveiligd is en goed wordt onderhouden, toegang tot een
      gebruikersaccount niet automatisch betekent dat de aanvaller ook
      <username>root</username> privileges kan krijgen.  Het is van
      belang dit onderscheid te maken, omdat een aanvaller zonder
      toegang tot <username>root</username> in het algemeen zijn sporen
      niet kan wissen en op z'n best wat kan rommelen met bestanden van
      de gebruiker of de machine kan crashen.  Gecompromitteerde
      gebruikersaccounts zijn vrij normaal omdat gebruikers normaliter
      niet de voorzorgsmaatregelen nemen die systeembeheerders
      nemen.</para>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>achterdeuren</secondary>
    </indexterm>

    <para>Systeembeheerders moeten onthouden dat er in potentie heel
      veel manieren zijn om toegang tot <username>root</username> te
      krijgen.  Een aanvaller zou het
      <username>root</username> wachtwoord kunnen kennen, een bug kunnen
      ontdekken in een dienst die onder <username>root</username>
      draait en daar via een netwerkverbinding op in kunnen breken of
      een aanvaller zou een probleem kennen met een suid-root programma
      dat de aanvaller in staat stelt <username>root</username> te
      worden als hij eenmaal toegang heeft tot een gebruikersaccount.
      Als een aanvaller een manier heeft gevonden om
      <username>root</username> te worden op een machine, dan hoeft
      hij misschien geen achterdeur (<quote>backdoor</quote>) te
      installeren.  Veel bekende manieren die zijn gevonden om
      <username>root</username> te worden, en weer zijn afgesloten,
      vereisen veel werk van de aanvaller om zijn rommel achter zich op
      te ruimen, dus de meeste aanvallers installeren een achterdeur.
      Een achterdeur biedt de aanvaller een manier om makkelijk opnieuw
      <username>root</username> toegang tot het systeem te krijgen, maar
      dit geeft de slimme systeembeheerder ook een makkelijke manier om
      de inbraak te ontdekken.  Het onmogelijk maken een achterdeur te
      installeren zou best wel eens nadelig kunnen zijn voor
      beveiliging, omdat hiermee nog niet het gat gedicht is waardoor
      er in eerste instantie is ingebroken.</para>

    <para>Beveiligingsmaatregelen moeten altijd ge&iuml;mplementeerd
      worden in een meerlagenmodel en worden als volgt
      gecategoriseerd:</para>

    <orderedlist>
      <listitem>
	<para>Beveiligen van <username>root</username> en
	  medewerkersaccounts.</para>
      </listitem>

      <listitem>
	<para>Beveiligen van <username>root</username> &ndash; servers
	  onder <username>root</username> en suid-/sgid-binaire
	  bestanden.</para>
      </listitem>

      <listitem>
	<para>Beveiligen van gebruikersaccounts.</para>
      </listitem>

      <listitem>
	<para>Beveiligen van het wachtwoordbestand.</para>
      </listitem>

      <listitem>
	<para>Beveiligen van de kern van de kernel, ruwe apparaten
	  en bestandssystemen.</para>
      </listitem>

      <listitem>
	<para>Snel detecteren van ongeoorloofde wijzigingen aan het
	  systeem.</para>
      </listitem>

      <listitem>
	<para>Paranoia.</para>
      </listitem>
    </orderedlist>

    <para>In het volgende onderdeel van dit hoofdstuk gaan we dieper in
      op de bovenstaande punten.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>&os; beveiligen</title>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>&os; beveiligen</secondary>
    </indexterm>

    <note>
      <title>Commando versus protocol</title>

      <para>In dit hele document gebruiken we
	<application>vette</application> tekst om te verwijzen naar een
	commando of applicatie en een <command>monospaced</command>
	lettertype om te verwijzen naar specifieke commando's.
	Protocollen staan vermeld in een normaal lettertype.  Dit
	typografische onderscheid is zinvol omdat bijvoorbeeld ssh
	zowel een protocol als een commando is.</para>
    </note>

    <para>In de volgende onderdelen behandelen we de methodes uit de
      <link linkend="security-intro">vorige paragraaf</link> om een
      &os;-systeem te beveiligen.</para>

    <sect2 id="securing-root-and-staff">
      <title>Beveiligen van <username>root</username> en
	medewerkersaccounts.</title>

      <indexterm><primary><command>su</command></primary></indexterm>

      <para>Om te beginnen: doe geen moeite om medewerkersaccounts
	te beveiligen als de <username>root</username> account niet
	beveiligd is.  Op de meeste systemen heeft de
	<username>root</username> account een wachtwoord.  Als eerste
	moet aangenomen worden dat dit wachtwoord
	<emphasis>altijd</emphasis> gecompromitteerd is.  Dit betekent
	niet dat het wachtwoord verwijderd moet worden.  Het wachtwoord
	is namelijk bijna altijd nodig voor toegang via het console van
	de machine.  Het betekent wel dat het niet mogelijk gemaakt
	moet worden om het wachtwoord te gebruiken buiten het console
	om en mogelijk zelfs niet via het &man.su.1; commando.  Pty's
	moeten bijvoorbeeld gemarkeerd staan als onveilig
	(<quote>insecure</quote>) in het bestand
	<filename>/etc/ttys</filename> zodat direct aanmelden met
	<username>root</username> via <command>telnet</command>
	of <command>rlogin</command> niet wordt toegestaan.  Als andere
	aanmelddiensten zoals <application>sshd</application> gebruikt
	worden, dan hoort direct aanmelden via
	<username>root</username> uitgeschakeld staat.  Dit kan door
	het bestand <filename>/etc/ssh/sshd_config</filename> te
	bewerken en ervoor te zorgen dat
	<literal>PermitRootLogin</literal> op <literal>no</literal>
	staat.  Dit moet gebeuren voor iedere methode van toegang
	&ndash; diensten zoals FTP worden vaak over het hoofd gezien.
	Het direct aanmelden van <username>root</username> hoort alleen
	te mogen via het systeemconsole.</para>

      <indexterm><primary><groupname>wheel</groupname></primary></indexterm>

      <para>Natuurlijk moet een systeembeheerder de mogelijkheid hebben
	om <username>root</username> te worden.  Daarvoor kunnen een
	paar gaatjes geprikt worden.  Maar dan moet ervoor gezorgd
	worden dat er voor deze gaatjes extra aanmelden met een
	wachtwoord nodig is.  E&eacute;n manier om
	<username>root</username> toegankelijk te maken is door het
	toevoegen van de juiste medewerkersaccounts aan de
	<groupname>wheel</groupname> groep (in
	<filename>/etc/group</filename>).  De medewerkers die lid zijn
	van de groep <groupname>wheel</groupname> mogen
	<command>su</command>&ndash;en naar <username>root</username>.
	Maak medewerkers nooit <quote>native</quote> lid van de groep
	<groupname>wheel</groupname> door ze in de groep
	<groupname>wheel</groupname> te plaatsen in
	<filename>/etc/group</filename>.  Medewerkersaccounts horen lid
	te zijn van de groep <groupname>staff</groupname> en horen dan
	pas toegevoegd te worden aan de groep
	<groupname>wheel</groupname> in het bestand
	<filename>/etc/group</filename>.  Alleen medewerkers die ook
	echt toegang tot <username>root</username> nodig hebben horen
	in de groep <groupname>wheel</groupname> geplaatst te worden.
	Het is ook mogelijk, door een autenticatiemethode als Kerberos
	te gebruiken, om het bestand <filename>.k5login</filename> van
	Kerberos in de <username>root</username> account te gebruiken
	om een &man.ksu.1; naar <username>root</username> toe te staan
	zonder ook maar iemand lid te maken van de groep
	<groupname>wheel</groupname>.  Dit is misschien wel een
	betere oplossing, omdat het
	<groupname>wheel</groupname>-mechanisme het nog steeds mogelijk
	maakt voor een inbreker <username>root</username> te breken als
	de inbreker een wachtwoordbestand te pakken heeft gekregen en
	toegang kan krijgen tot &eacute;&eacute;n van de
	medewerkersaccounts.  Hoewel het instellen van het
	<groupname>wheel</groupname>-mechanisme beter is dan niets, is
	het niet per se de meest veilige optie.</para>

      <para>Om een account volledig op slot te zetten, dient het
	commando &man.pw.8; gebruikt te worden:</para>

      <screen>&prompt.root; <userinput>pw lock <replaceable>staff</replaceable></userinput></screen>

      <para>Dit voorkomt dat de gebruiker zich aanmeldt via enig
	mechanisme, inclusief &man.ssh.1;.</para>

      <para>Een andere manier om toegang tot accounts te blokkeren is om
	het versleutelde wachtwoord door een enkel
	<quote><literal>*</literal></quote>-karakter te vervangen.  Dit
	karakter zal nooit overeenkomen met het versleutelde wachtwoord
	en dus gebruikerstoegang blokkeren.  Het volgende
	medewerkersaccount bijvoorbeeld:</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>zou veranderd moeten worden in:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Dit voorkomt dat de gebruiker <username>foobar</username>
	zich aanmeldt met conventionele methoden.  Deze methode om
	toegang te beperken werkt niet op sites die
	<application>Kerberos</application> gebruiken of in situaties
	waarin de gebruiker met &man.ssh.1; sleutels heeft
	ge&iuml;nstalleerd.</para>

      <para>Deze beveiligingsmechanismen hebben ook als uitgangspunt dat
	vanaf een zwaarder beveiligde machine wordt aangemeld op een
	minder beveiligd systeem.  Als een hoofdserver bijvoorbeeld
	allerlei servers draait, zou het werkstation er geen moeten
	draaien.  Om een werkstation redelijk veilig te laten zijn,
	dienen er zo min mogelijk servers op te draaien, bij voorkeur
	zelfs geen en er zou een schermbeveiliging met
	wachtwoordbeveiliging op moeten draaien.  Maar als een aanvaller
	fysieke toegang heeft tot een werkstation, dan kan hij elke
	beveiliging die erop is aangebracht omzeilen.  Dit probleem
	dient echt overwogen te worden, net als het feit dat de meeste
	aanvallen van een afstand plaatsvinden, via het netwerk, door
	mensen die geen fysieke toegang hebben tot werkstations of
	servers.</para>

      <para>Het gebruik van iets als Kerberos geeft de mogelijkheid
	om het wachtwoord van de account van een medewerker buiten
	gebruik te stellen of te wijzigen op &eacute;&eacute;n plaats,
	waarbij het meteen actief is op alle machines waarop die
	medewerker een account heeft.  Als de account van een
	medewerker gecompromitteerd raakt, moet vooral de mogelijkheid
	om per direct het wachtwoord voor machines te kunnen aanpassen
	niet onderschat worden.  Met afzonderlijke wachtwoorden kan het
	veranderen van wachtwoorden op N systemen een puinhoop worden.
	Met Kerberos kunnen ook wachtwoordrestricties opgelegd worden:
	het is niet alleen mogelijk om een Kerberos
	<quote>ticket</quote> na een bepaalde tijd te laten verlopen,
	maar het Kerberos systeem kan afdwingen dat de gebruiker na een
	bepaalde tijd een nieuw wachtwoord kiest (na bijvoorbeeld een
	maand).</para>
    </sect2>

    <sect2>
      <title>Beveiligen van <username>root</username> &ndash; servers
	onder <username>root</username> en suid-/sgid-binaire
	bestanden</title>

      <indexterm><primary><command>ntalk</command></primary></indexterm>

      <indexterm><primary><command>comsat</command></primary></indexterm>

      <indexterm><primary><command>finger</command></primary></indexterm>

      <indexterm><primary>zandbakken</primary></indexterm>

      <indexterm><primary><application>sshd</application></primary></indexterm>

      <indexterm><primary><application>telnetd</application></primary></indexterm>

      <indexterm><primary><application>rshd</application></primary></indexterm>

      <indexterm><primary><application>rlogind</application></primary></indexterm>

      <para>Een voorzichtige systeembeheerder draait alleen die servers
	die nodig zijn, niets meer, niets minder.  Bedenk dat
	servers van derde partijen vaak de meeste neiging hebben tot
	het vertonen van bugs.  Zo staat bijvoorbeeld het draaien van
	een oude versie van <application>imapd</application> of
	<application>popper</application> gelijk aan het weggeven van
	de <username>root</username> account aan de hele wereld.  Draai
	nooit een server die niet zorgvuldig is onderzocht.  Veel
	servers hoeven niet te draaien als <username>root</username>.
	Zo kunnen de <application>ntalk</application>,
	<application>comsat</application> en
	<application>finger</application> daemons bijvoorbeeld draaien
	in speciale gebruikerszandbakken
	(<quote><firstterm>sandboxes</firstterm></quote>).  Een zandbak
	is niet perfect, tenzij er heel veel moeite gedaan wordt, maar
	de meerlagenbenadering blijft bestaan: als iemand via een
	server die in een zandbak draait weet in te breken, dan moeten
	ze eerst nog uit de zandbak komen.  Hoe groter het aantal lagen
	is waar een inbreker doorheen moet, hoe kleiner de kans op
	succes is.  <username>root</username> gaten zijn historisch
	gezien aanwezig geweest in vrijwel iedere server die ooit als
	<username>root</username> gedraaid heeft, inclusief de
	basisservers van een systeem.  Op een machine waarop mensen
	alleen aanmelden via <application>sshd</application> en nooit
	via <application>telnetd</application> of
	<application>rshd</application> of
	<application>rlogind</application> dienen die servers
	uitgeschakeld te worden!</para>

      <para>&os; draait <application>ntalkd</application>,
	<application>comsat</application> en
	<application>finger</application> tegenwoordig standaard in een
	zandbak.  Een ander programma dat misschien beter in een
	zandbak kan draaien is &man.named.8;.  In
	<filename>/etc/defaults/rc.conf</filename> staat als commentaar
	welke parameters er nodig zijn om
	<application>named</application> in een zandbak te draaien.
	Afhankelijk van of het een nieuwe systeeminstallatie of het
	bijwerken van een bestaand systeem betreft, worden de speciale
	gebruikersaccounts die bij die zandbakken horen misschien niet
	ge&iuml;nstalleerd.  Een voorzichtige systeembeheerder
	onderzoekt en implementeert zandbakken voor servers waar dat
	ook maar mogelijk is.</para>

      <indexterm><primary><application>sendmail</application></primary></indexterm>

      <para>Er zijn een aantal diensten die vooral niet in een zandbak
	draaien: <application>sendmail</application>,
	<application>popper</application>,
	<application>imapd</application>,
	<application>ftpd</application> en andere.  Voor sommige
	servers zijn alternatieven, maar dat kost misschien meer tijd
	dan er te besteden is (gemak dient de mens).  Het kan voorkomen
	dat deze servers als <username>root</username> moeten draaien
	en dat er vertrouwd moet worden op andere mechanismen om een
	inbraak via die servers te detecteren.</para>

      <para>De andere grote mogelijkheid voor <username>root</username>
	gaten in een systeem zijn de suid-root en sgid-binaire
	bestanden die ge&iuml;nstalleerd zijn op een systeem.  Veel van
	die bestanden, zoals <application>rlogin</application>, staan in
	<filename class="directory">/bin</filename>,
	<filename class="directory">/sbin</filename>,
	<filename class="directory">/usr/bin</filename> of
	<filename class="directory">/usr/sbin</filename>.  Hoewel het niet 100%
	veilig is, mag aangenomen worden dat de suid- en sgid-binaire bestanden
	van een standaardsysteem redelijk veilig zijn.  Toch worden er
	nog wel eens <username>root</username> gaten gevonden in deze
	bestanden.  Zo is er in 1998 een <username>root</username> gat
	gevonden in <literal>Xlib</literal> waardoor
	<application>xterm</application> (die normaliter suid is)
	kwetsbaar bleek.  Een voorzichtige systeembeheerder kiest voor
	<quote>better to be safe than sorry</quote> door de
	suid-bestanden die alleen medewerkers hoeven uit te voeren aan
	een speciale groep toe te wijzen en de suid-bestanden die
	niemand gebruikt te lozen (<command>chmod 000</command>).  Een
	server zonder monitor heeft normaal gezien
	<application>xterm</application> niet nodig.  Sgid-bestanden
	kunnen bijna net zo gevaarlijk zijn.  Als een inbreker een
	sgid-kmem stuk kan krijgen, dan kan hij wellicht
	<filename>/dev/kmem</filename> lezen en dus het gecodeerde
	wachtwoordbestand, waardoor mogelijk ieder account met
	een wachtwoord besmet is.  Een inbreker toegang tot de groep
	<literal>kmem</literal> kan krijgen, zou bijvoorbeeld mee
	kunnen kijken met de toetsaanslagen die ingegeven worden via de
	pty's, inclusief die pty's die gebruikt worden door gebruikers
	die via beveiligde methodes aanmelden.  Een inbreker die
	toegang krijgt tot de groep <groupname>tty</groupname> kan naar
	bijna alle tty's van gebruikers schrijven.  Als een gebruiker
	een terminalprogramma of een terminalemulator met een
	toetsenbordsimulatieoptie draait, dan kan de inbreker in
	potentie een gegevensstroom genereren die ervoor zorgt dat de
	terminal van de gebruiker een commando echot, dat dan wordt
	uitgevoerd door die gebruiker.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Beveiligen van gebruikersaccounts</title>

      <para>Gebruikersaccounts zijn gewoonlijk het meest lastig om te
	beveiligen.  Hoewel er allerlei draconische maatregelen genomen
	kunnen worden met betrekking tot de medewerkers en hun
	wachtwoorden <quote>weggesterd</quote> kunnen worden, gaat dat
	waarschijnlijk niet lukken met de gewone gebruikersaccounts.
	Als er toch voldoende vrijheid is, dan prijst de beheerder zich
	gelukkig en is het misschien toch mogelijk de accounts
	voldoende te beveiligen.  Als die vrijheid er niet is, dan
	moeten die accounts gewoon netter gemonitord worden.  Het
	gebruik van <application>ssh</application> en
	<application>Kerberos</application> voor gebruikersaccounts is
	problematischer vanwege het extra beheer en de ondersteuning,
	maar nog steeds een prima oplossing in vergelijking met een
	versleuteld wachtwoordbestand.</para>
    </sect2>

    <sect2>
      <title>Beveiligen van het wachtwoordbestand</title>

      <para>De enige echte oplossing is zoveel mogelijk wachtwoorden
	wegsterren en <application>ssh</application>
	of <application>Kerberos</application> gebruiken voor toegang
	tot die accounts.  Hoewel een gecodeerd wachtwoordbestand
	(<filename>/etc/spwd.db</filename>) alleen gelezen kan worden
	door <username>root</username>, is het wel mogelijk dat een
	inbreker leestoegang krijgt tot dat bestand zonder dat de
	aanvaller root-schrijftoegang krijgt.</para>

      <para>Beveiligingsscripts moeten altijd controleren op en
	rapporteren over wijzigingen in het wachtwoordbestand (zie ook
	<link linkend="security-integrity">Bestandsintegriteit
	  Controleren</link> hieronder).</para>
    </sect2>

    <sect2>
      <title>Beveiligen van de kern van de kernel, ruwe apparaten en
	bestandssystemen</title>

      <para>Als een aanvaller toegang krijgt tot
	<username>root</username> dan kan hij ongeveer alles, maar er
	zijn een paar slimmigheidjes.  Zo hebben bijvoorbeeld de meeste
	moderne kernels een ingebouwd pakketsnuffelstuurprogramma
	(<quote>packet sniffing</quote>).  Bij &os; is dat het
	<devicename>bpf</devicename> apparaat.  Een inbreker zal in het
	algemeen proberen een pakketsnuffelaar te draaien op een
	gecompromitteerde machine.  De inbreker hoeft deze mogelijkheid
	niet te hebben en bij de meeste systemen is het niet verplicht
	het <devicename>bpf</devicename> apparaat mee te
	compileren.</para>

      <indexterm><primary><command>sysctl</command></primary></indexterm>

      <para>Maar zelfs als het <devicename>bpf</devicename>
	apparaat is uitgeschakeld, dan zijn er nog
	<filename>/dev/mem</filename> en
	<filename>/dev/kmem</filename>.  De inbreker kan namelijk nog
	schrijven naar ruwe schrijfapparaten.  En er is ook nog een
	optie in de kernel die modulelader (<quote>module
	loader</quote>) heet, &man.kldload.8;.  Een ondernemende
	inbreker kan een KLD-module gebruiken om zijn eigen
	<devicename>bpf</devicename>-apparaat of een ander
	snuffelapparaat te installeren in een draaiende kernel.  Om
	deze problemen te voorkomen, moet de kernel op een hoger
	veiligheidsniveau draaien, ten minste securelevel 1.</para>

      <para>Het veiligheidsniveau van de kernel kan op een aantal
	manieren worden ingesteld.  De eenvoudigste manier om het
	veiligheidsniveau van een draaiende kernel te verhogen is met
	<command>sysctl</command> op de kernelvariabele
	<varname>kern.securelevel</varname>:</para>

      <screen>&prompt.root; <userinput>sysctl kern.securelevel=<replaceable>1</replaceable></userinput></screen>

      <para>Standaard start de kernel van &os; op met een
	veiligheidsniveau van -1.  Het veiligheidsniveau blijft -1
	tenzij het is veranderd, &ograve;fwel door de beheerder
	&ograve;fwel door &man.init.8; vanwege een instelling in de
	opstartscripts.  Het veiligheidsniveau kan tijdens het opstarten
	van het systeem verhoogd worden door de variabele
	<varname>kern_securelevel_enable</varname> op
	<literal>YES</literal> te zetten in het bestand
	<filename>/etc/rc.conf</filename>, en de waarde van de variabele
	<varname>kern_securelevel</varname> op het gewenste
	veiligheidsniveau in te stellen.</para>

      <para>Het standaard veiligheidsniveau van een &os;-systeem direct
	nadat de opstartscripts zijn uitgevoerd is -1.  Dit wordt
	<quote>onveilige modus</quote> genoemd omdat de onveranderlijke
	bestandsvlag uitgezet kan worden, er van/naar alle apparaten mag
	worden gelezen en geschreven, enzovoorts.</para>

      <para>Als eenmaal het veiligheidsniveau op 1 of een hogere waarde
	is ingesteld, worden de alleen-toevoegen en onveranderlijke
	bestanden gehonoreerd, deze kunnen niet worden uitgezet, en
	wordt toegang tot rauwe apparaten ontzegd.  Hogere niveaus
	beperken nog meer bewerkingen.  Lees, voor een volledige
	beschrijving van het effect van de verschillende
	veiligheidsniveaus, de handleidingpagina &man.security.7; (of de
	handleidingpagina van &man.init.8; voor uitgaven ouder dan &os;
	7.0).</para>

      <note>
	<para>Het ophogen van het veiligheidsniveau naar 1 of hoger kan
	  enkele problemen met X11 (toegang tot
	  <filename>/dev/io</filename> zal worden geblokkeerd), of met
	  de installatie van &os; wanneer die vanaf de broncode is
	  gebouwd (het gedeelte <maketarget>installword</maketarget> van
	  het proces moet tijdelijk de alleen-toevoegen en
	  onveranderlijke vlaggen van sommige bestanden uitzetten), en
	  met enkele andere gevallen veroorzaken.  Soms, zoals het geval
	  is met X11, is het mogelijk om dit te omzeilen door
	  &man.xdm.1; behoorlijk vroeg in het opstartproces te starten,
	  wanneer het veiligheidsniveau nog laag genoeg is.
	  Omzeilmethoden zoals deze zijn misschien niet voor alle
	  veiligheidsniveaus of voor alle beperkingen die ze opleggen
	  mogelijk.  Wat vooruit plannen is een goed idee.  Het is
	  belangrijk om de beperkingen die door elk veiligheidsniveau
	  worden opgelegd te begrijpen omdat ze het gebruiksgemak van
	  het systeem sterk verminderen.  Het vergemakkelijkt ook het
	  kiezen van eens standaardinstelling en voorkomt allerlei
	  verassingen.</para>
      </note>

      <para>Als het veiligheidsniveau van de kernel naar 1 of hoger
	wordt verhoogd, kan het nuttig zijn om de vlag
	<literal>schg</literal> aan te zetten voor kritieke
	opstartprogramma's, mappen, en scriptbestanden (i.e., alles dat
	gedraaid wordt tot het punt waar het veiligheidsniveau wordt
	ingesteld).  Dit kan overdreven zijn, en het bijwerken van het
	systeem is veel moeilijker wanneer het op een hoog
	veiligheidsniveau werkt.  Een minder beperkend compromis is om
	het systeem op een hoger veiligheidsniveau te draaien maar het
	aanzetten van de vlag <literal>schg</literal> voor elk
	systeembestand en -map onder de zon over te slaan.  Een andere
	mogelijkheid is om <filename class="directory">/</filename> en
	<filename class="directory">/usr</filename> simpelweg als alleen-lezen
	aan te koppelen.  Het dient opgemerkt te worden dat het te draconisch
	zijn over wat is toegestaan het belangrijke detecteren van een
	inbraak kan verhinderen.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>Bestandsintegriteit controleren: binaire bestanden,
	instellingenbestanden, enzovoort</title>

      <para>Als puntje bij paaltje komt kan de kern van een systeem
	maar tot een bepaald punt beveiligd worden zonder dat het
	minder prettig werken wordt.  Zo werk het zetten van de
	<literal>schg</literal> bit met <command>chflags</command> op
	de meeste bestanden in <filename class="directory">/</filename> en
	<filename class="directory">/usr</filename> waarschijnlijk averechts,
	omdat, hoewel de bestanden beschermd zijn, ook het venster waarin
	detectie plaats kan vinden is gesloten.  De laatste laag van
	beveiliging is waarschijnlijk de meest belangrijke: detectie.
	Alle overige beveiliging is vrijwel waardeloos (of nog erger:
	geeft een vals gevoel van beveiliging) als een mogelijke inbraak
	niet gedetecteerd kan worden.  Een belangrijk doel van het
	meerlagenmodel is het vertragen van een aanvaller, nog meer dan
	hem te stoppen, om hem op heterdaad te kunnen betrappen.</para>

      <para>De beste manier om te zoeken naar een inbraak is zoeken
	naar gewijzigde, ontbrekende of onverwachte bestanden.  De beste
	manier om te zoeken naar gewijzigde bestanden is vanaf een
	ander (vaak gecentraliseerd) systeem met beperkte toegang.
	Met zelfgeschreven scripts op dat extra beveiligde systeem met
	beperkte toegang is een beheerder vrijwel onzichtbaar voor
	mogelijke aanvallers en dat is belangrijk.  Om het nut te
	maximaliseren moeten in het algemeen dat systeem met beperkte
	toegang best veel rechten gegeven worden op de andere machines
	in het netwerk, vaak via een alleen-lezen NFS-export van de
	andere machines naar het systeem met beperkte toegang of door
	<application>ssh</application> sleutelparen in te stellen om
	het systeem met beperkte toegang een
	<application>ssh</application> verbinding te laten maken met de
	andere machines.  Buiten het netwerkverkeer, is NFS de minst
	zichtbare methode.  Hierdoor kunnen de bestandssystemen
	op alle cli&euml;ntmachines vrijwel ongezien gemonitord worden.
	Als de server met beperkte toegang verbonden is met de
	cli&euml;ntmachines via een switch, dan is de NFS-methode vaak
	de beste keus.  Als de server met beperkte toegang met de andere
	machines is verbonden via een hub of door meerdere routers, dan
	is de NFS-methode wellicht niet veilig genoeg (vanuit een
	netwerk standpunt) en kan beter <application>ssh</application>
	gebruikt worden, ondanks de audit-sporen die
	<application>ssh</application> achterlaat.</para>

      <para>Als de machine met beperkte toegang eenmaal minstens
	leestoegang heeft tot een cli&euml;ntsysteem dat het moet gaan
	monitoren, dan moeten scripts gemaakt worden om dat monitoren
	ook echt uit te voeren.  Uitgaande van een NFS-koppeling, kunnen
	de scripts gebruik maken van eenvoudige systeem hulpprogramma's
	als &man.find.1; en &man.md5.1;.  We adviseren minstens
	&eacute;&eacute;n keer per dag een md5 te maken van alle
	bestanden op de cli&euml;ntmachine en van instellingenbestanden
	als in <filename class="directory">/etc</filename> en
	<filename class="directory">/usr/local/etc</filename> zelfs vaker.
	Als er verschillen worden aangetroffen ten opzichte van de basis md5
	informatie op het systeem met beperkte toegang, dan hoort het
	script te gillen om een beheerder die het moet gaan uitzoeken.
	Een goed beveiligingsscript controleert ook op onverwachte
	suid-bestanden en op nieuwe en verwijderde bestanden op
	systeempartities als <filename class="directory">/</filename> en
	<filename class="directory">/usr</filename>.</para>

      <para>Als <application>ssh</application> in plaats van NFS wordt
	gebruikt, dan is het schrijven van het script lastiger.  Dan
	moeten de scripts met <command>scp</command> naar de cli&euml;nt
	verplaatst worden om ze uit te voeren, waardoor ze zichtbaar
	worden.  Voor de veiligheid dienen ook de binaire bestanden die
	het script gebruikt, zoals &man.find.1;, gekopieerd te
	worden.  De <application>ssh</application>-cli&euml;nt op de
	cli&euml;nt zou al gecompromitteerd kunnen zijn.  Het is
	misschien noodzakelijk ssh te gebruiken over onveilige
	verbindingen, maar dat maakt alles een stuk lastiger.</para>

      <para>Een goed beveiligingsscript voert ook controles uit op de
	instellingenbestanden van gebruikers en medewerkers:
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename>, enzovoort.
	Dat zijn bestanden die buiten het bereik van de
	<literal>MD5</literal>-controle vallen.</para>

      <para>Als gebruikers veel schijfruimte hebben, dan kan het te lang
	duren om alle bestanden op deze partitie te controleren.  In dat
	geval is het verstandig de koppelvlaggen zo in te stellen dat
	suid-binaire bestanden op die partities niet zijn toegestaan.
	Zie daarvoor de optie <literal>nosuid</literal> (zie
	&man.mount.8;).  Die partities moeten wel toch nog minstens eens
	per week doorzocht worden, omdat het doel van deze
	beveiligingslaag het ontdekken van een inbraakpoging is, of die
	nu succesvol is of niet.</para>

      <para>Procesverantwoording (zie &man.accton.8;) kost relatief
	gezien weinig en kan bijdragen aan een evaluatie mechanisme
	voor na inbraken.  Het is erg handig om uit te zoeken hoe
	iemand precies heeft ingebroken op het systeem, mits het
	bestand nog onbeschadigd is na de inbraak.</para>

      <para>Tenslotte horen beveiligingsscripts de logboekbestanden te
	verwerken en de logboekbestanden zelf horen zo veilig mogelijk
	tot stand te komen.  <quote>remote syslog</quote> kan erg
	zinvol zijn.  Een aanvaller zal proberen zijn sporen uit te
	wissen en logboekbestanden zijn van groot belang voor een
	systeembeheerder als het gaat om uitzoeken wanneer en hoe er is
	ingebroken.  Een manier om logboekbestanden veilig te stellen
	is door het systeemconsole via een seri&euml;le poort aan te
	sluiten op een veilige machine en zo informatie te
	verzamelen.</para>
    </sect2>

    <sect2>
      <title>Paranoia</title>

      <para>Een beetje paranoia is niet verkeerd.  Eigenlijk kan de
	systeembeheerder zoveel beveiligingsopties inschakelen als hij
	wil, als deze maar geen impact hebben op het gebruiksgemak en
	de beveiligingsopties die <emphasis>wel</emphasis> impact
	hebben op het gebruiksgemak kunnen ingeschakeld worden als daar
	zorgvuldig mee wordt omgegaan.  Nog belangrijker is misschien
	dat er een juiste combinatie wordt gevonden.  Als de
	aanbevelingen uit dit document woord voor woord worden
	opgevolgd, dan worden daarmee de methodes aan een toekomstige
	aanvaller verraden, die ook toegang heeft tot dit
	document.</para>
    </sect2>

    <sect2>
      <title>Ontzeggen van Dienst aanvallen</title>

      <indexterm><primary>Ontzegging van Dienst (DoS)</primary></indexterm>

      <para>In deze paragraaf worden Ontzeggen van Dienst aanvallen
	(<quote>Denial of Service</quote> of DoS) behandeld.  Een
	DoS-aanval wordt meestal uitgevoerd als pakketaanval.  Hoewel er
	weinig gedaan kan worden tegen de huidige aanvallen met
	gefingeerde pakketten die een netwerk kunnen verzadigen, kan
	de schade geminimaliseerd worden door ervoor te zorgen dat
	servers er niet door plat gaan door:</para>

      <orderedlist>
	<listitem>
	  <para>Limiteren van server forks.</para>
	</listitem>

	<listitem>
	  <para>Limiteren van springplank (<quote>springboard</quote>)
	    aanvallen (ICMP response aanvallen, ping broadcast, etc.).</para>
	</listitem>

	<listitem>
	  <para>De Kernel Route Cache overloaden.</para>
	</listitem>
      </orderedlist>

      <para>Een veelvoorkomende DoS-aanval is om een server aan te
	vallen door het zoveel kindprocessen aan te laten maken dat het
	hostsysteem uiteindelijk geen bestandsdescriptors, geheugen
	enzovoort meer heeft en het dan opgeeft.
	<application>inetd</application> (zie &man.inetd.8;) kent een
	aantal instellingen om dit type aanval af te zwakken.  Hoewel
	het mogelijk is ervoor te zorgen dat een machine niet plat
	gaat, is het in het algemeen niet mogelijk te voorkomen dat de
	dienstverlening door de aanval wordt verstoord.  Meer is te
	lezen in de handleiding van <application>inetd</application>
	en het advies is in het bijzonder aandacht aan de
	<option>-c</option>, <option>-C</option> en <option>-R</option>
	opties te besteden.  Aanvallen met gefingeerde
	<acronym>IP</acronym> adressen omzeilen de <option>-C</option>
	optie naar <application>inetd</application>, dus in het
	algemeen moet een combinatie van opties gebruikt worden.
	Sommige op zichzelf staande servers hebben parameters waarmee
	het aantal forks gelimiteerd kan worden.</para>

      <para><application>Sendmail</application> heeft de optie
	<option>-OMaxDaemonChildren</option> die veel beter blijkt te
	werken dan het gebruik van de opties van
	<application>Sendmail</application> waarmee de werklast
	gelimiteerd kan worden.  De parameter
	<literal>MaxDaemonChildren</literal> moet zodanig ingesteld
	worden dat als <application>sendmail</application> start; deze
	hoog genoeg is om de te verwachten belasting aan te kunnen,
	maar niet zo hoog is dat de computer het aantal instanties van
	<application>Sendmail</application>s niet aankan zonder plat te
	gaan.  Het is ook verstandig om
	<application>Sendmail</application> in de wachtrijmodus
	(<option>-ODeliveryMode=queued</option>) te draaien en de
	daemon (<command>sendmail -bd</command>) los te koppelen van de
	verwerking van de wachtrij (<command>sendmail -q15m</command>).
	Als de verwerking van wachtrij real-time moet, kunnen de
	tussenpozen voor verwerking verkort worden door deze
	bijvoorbeeld op <option>-q1m</option> in te stellen, maar dan
	is een redelijke instelling van
	<literal>MaxDaemonChildren</literal> van belang om
	<emphasis>die</emphasis> <application>Sendmail</application> te
	beschermen tegen trapsgewijze fouten.</para>

      <para><application>Syslogd</application> kan direct aangevallen
	worden en het is sterk aan te raden de <option>-s</option>
	optie te gebruiken waar dat ook maar mogelijk is en anders de
	<option>-a</option> optie.</para>

      <para>Er dient voorzichtig omgesprongen te worden met diensten
	die terugverbinden zoals
	<application>TCP Wrapper</application>'s reverse-identd die
	direct aangevallen kan worden.  In het algemeen is het hierom
	onverstandig gebruik te maken van de reverse-ident optie van
	<application>TCP Wrapper</application>.</para>

      <para>Het is een goed idee om interne diensten af te schermen
	voor toegang van buitenaf door ze te firewallen op de routers
	aan de rand van een netwerk (<quote>border routers</quote>).
	Dit heeft als achtergrond dat verzadigingsaanvallen voorkomen
	van buiten het LAN voorkomen kunnen worden.  Daarmee wordt geen
	aanval op <username>root</username> via het netwerk en die
	diensten daaraan voorkomen.  Er dient altijd een exclusieve
	firewall te zijn, dat wil zeggen <quote>firewall alles
	<emphasis>behalve</emphasis> poorten A, B, C, D en M-Z</quote>.
	Zo worden alle lage poorten gefirewalled behalve die voor
	specifieke diensten als <application>named</application> (als
	er een primary is voor een zone),
	<application>ntalkd</application>,
	<application>sendmail</application> en andere diensten die
	vanaf Internet toegankelijk moeten zijn.  Als de firewall
	andersom wordt ingesteld, als een inclusieve of tolerante
	firewall, dan is de kans groot dat er wordt vergeten een aantal
	diensten af te <quote>sluiten</quote> of dat er een nieuwe
	interne dienst wordt toegevoegd en de firewall niet wordt
	bijgewerkt.  Er kan nog steeds voor gekozen worden de hoge
	poorten open te zetten, zodat een tolerante situatie ontstaat,
	zonder de lage poorten open te stellen.  &os; biedt ook de
	mogelijkheid een reeks poortnummers die gebruikt worden voor
	dynamische verbindingen in te stellen via de verscheidene
	<varname>net.inet.ip.portrange</varname>
	<command>sysctl</command>s (<command>sysctl -a | fgrep
	portrange</command>), waardoor ook de complexiteit van de
	firewall instellingen kan vereenvoudigen.  Zo kan bijvoorbeeld
	een normaal begin tot eindbereik ingesteld worden van 4000 tot
	5000 en een hoog poortbereik van 49152 tot 65535.  Daarna kan
	alles onder 4000 op de firewall geblokkeerd worden (met
	uitzondering van bepaalde poorten die vanaf Internet bereikbaar
	moeten zijn natuurlijk).</para>

      <para>Een andere veelvoorkomende DoS-aanval is de
	springplankaanval: een server zo aanvallen dat de respons van
	die server de server zelf, het lokale netwerk of een andere
	machine overbelast.  De meest voorkomende aanval van dit type is
	de <emphasis>ICMP ping broadcast aanval</emphasis>.  De
	aanvaller fingeert ping-pakketten die naar het broadcast-adres
	van het LAN worden gezonden met als bron het
	<acronym>IP</acronym>-adres van de machine die hij eigenlijk aan
	wil vallen.  Als de routers aan de rand van het netwerk niet
	zijn ingesteld om een ping-pakketten aan een broadcast-adres te
	blokkeren, dan kan het LAN genoeg antwoorden produceren om de
	verbinding van het slachtoffer (het gefingeerde bronadres) te
	verzadigen, zeker als de aanvaller hetzelfde doet met tientallen
	andere netwerken.  Broadcastaanvallen met een volume van meer
	dan 120 megabit zijn al voorgekomen.  Een tweede
	springplankaanval is er een tegen het ICMP-foutmeldingssysteem.
	Door een pakket te maken waarop een ICMP-foutmelding komt, kan
	een aanvaller de inkomende verbinding van een server verzadigen
	en de uitgaande verbinding laten verzadigen met
	ICMP-foutmeldingen.  Dit type aanval kan een server ook laten
	crashen door te zorgen dat het geheugen ervan vol zit, zeker als
	de server de ICMP-antwoorden niet zo snel kwijt kan als dat het
	ze genereert.  Gebruik de
	<application>sysctl</application>-variabele
	<literal>net.inet.icmp.icmplim</literal> om deze aanvallen te
	beperken.  De laatste belangrijke klasse springplankaanvallen
	hangt samen met een aantal interne diensten van
	<application>inetd</application> zoals de UDP-echodienst.  Een
	aanvaller fingeert eenvoudigweg een UDP-pakket met als
	bronadres de echopoort van Server A en als bestemming de
	echopoort van Server B, waar Server A en B allebei op een LAN
	staan.  Die twee servers gaan dat pakket dan heen en weer
	kaatsen.  Een aanvaller kan beide servers overbelasten door een
	aantal van deze pakketten te injecteren.  Soortgelijke problemen
	kunnen ontstaan met de poort <application>chargen</application>.
	Een competente systeembeheerder zal al deze interne
	<application>inetd</application> testdiensten
	uitschakelen.</para>

      <para>Gefingeerde pakketten kunnen ook gebruikt worden om de
	kernel route cache te overbelasten.  Raadpleeg daarvoor de
	<varname>net.inet.ip.rtexpire</varname>,
	<varname>rtminexpire</varname> en <varname>rtmaxcache</varname>
	<command>sysctl</command> parameters.  Een aanval met
	gefingeerde pakketten met een willekeurig bron-IP zorgt ervoor
	dat de kernel een tijdelijke gecachede route maakt in de
	routetabel, die uitgelezen kan worden met <command>netstat -rna
	| fgrep W3</command>.  Deze routes hebben een levensduur van
	ongeveer 1600 seconden.  Als de kernel merkt dat de gecachede
	routetabel te groot is geworden, dan wordt
	<varname>rtexpire</varname> dynamisch verkleind, maar deze
	waarde wordt nooit lager dan <varname>rtminexpire</varname>.
	Er zijn twee problemen:</para>

      <orderedlist>
	<listitem>
	  <para>De kernel reageert niet snel genoeg als een laag
	    belaste server wordt aangevallen.</para>
	</listitem>

	<listitem>
	  <para><varname>rtminexpire</varname> is niet laag genoeg om
	    de kernel de aanval te laten overleven.</para>
	</listitem>
      </orderedlist>

      <para>Als servers verbonden zijn met het Internet via een E3
	of sneller, dan is het verstandig om handmatig
	<varname>rtexpire</varname> en <varname>rtminexpire</varname>
	aan te passen via &man.sysctl.8;.  Als de een van de parameters
	op nul wordt gezet, dan crasht de machine.  Het instellen van
	beide waarden op 2 seconden is voldoende om de routetabel
	tegen een aanval te beschermen.</para>
    </sect2>

    <sect2>
      <title>Aandachtspunten voor toegang met
	<application>Kerberos</application> en
	<application>SSH</application></title>

      <indexterm><primary><command>ssh</command></primary></indexterm>

      <para>Er zijn een aantal aandachtspunten die in acht genomen
	moeten worden als Kerberos of ssh gebruikt worden.  Kerberos 5
	is een prima autenticatieprotocol, maar er zitten bugs in de
	Kerberos-versies van <application>telnet</application> en
	<application>rlogin</application> waardoor ze niet geschikt
	zijn voor binair verkeer.  Kerberos codeert standaard de sessie
	niet, tenzij de optie <option>-x</option> wordt gebruikt.
	<application>ssh</application> codeert standaard wel
	alles.</para>

      <para>Ssh werkt prima, maar het stuurt coderingssleutels
	standaard door.  Dit betekent dat als gegeven een veilig
	werkstation met sleutels die toegang geven tot de rest van het
	systeem en ssh wordt gebruikt om verbinding te maken met een
	onveilige machine, die sleutels gebruikt kunnen worden.  De
	sleutels zelf zijn niet bekend, maar ssh stelt een
	doorstuurpoort in zolang als een gebruikers aangemeld blijft.
	Als de aanvaller <username>root</username>toegang heeft op de
	onveilige machine, dan kan hij die poort gebruiken om toegang
	te krijgen tot alle machines waar de sleutels van de gebruiker
	toegang toe geven.</para>

      <para>Het advies is ssh in combinatie met Kerberos te gebruiken
	voor het aanmelden door medewerkers wanneer dat ook maar
	mogelijk is.  <application>Ssh</application> kan gecompileerd
	worden met Kerberos-ondersteuning.  Dit vermindert de kans op
	blootstelling van ssh-sleutels en beschermt tegelijkertijd
	de wachtwoorden met Kerberos.  Ssh-sleutels zouden alleen
	gebruikt moeten worden voor geautomatiseerde taken vanaf
	veilige machines (iets waar Kerberos ongeschikt voor is).  Het
	advies is om het doorsturen van sleutels uit te schakelen in de
	ssh-instellingen of om de <literal>from=IP/DOMAIN</literal>
	optie te gebruiken die ssh in staat stelt het bestand
	<filename>authorized_keys</filename> te gebruiken om de
	sleutel alleen bruikbaar te maken voor entiteiten die zich
	aanmelden vanaf vooraf aangewezen machines.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Delen geschreven en herschreven door </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, Blowfish, MD5, SHA256, SHA512 en crypt</title>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>crypt</secondary>
    </indexterm>

    <indexterm><primary>crypt</primary></indexterm>

    <indexterm><primary>Blowfish</primary></indexterm>

    <indexterm><primary>DES</primary></indexterm>

    <indexterm><primary>MD5</primary></indexterm>

    <indexterm><primary>SHA256</primary></indexterm>

    <indexterm><primary>SHA512</primary></indexterm>

    <para>Iedere gebruiker op een &unix; systeem heeft een wachtwoord
      bij zijn account.  Het lijkt voor de hand liggend dat deze
      wachtwoorden alleen bekend horen te zijn bij de gebruiker en het
      eigenlijke besturingssysteem.  Om deze wachtwoorden geheim te
      houden, zijn ze gecodeerd in een <quote>eenweg hash</quote>
      (<quote>one-way hash</quote>), wat betekent dat ze eenvoudig
      gecodeerd kunnen worden maar niet gedecodeerd.  Met andere
      woorden, wat net gesteld werd is helemaal niet waar: het
      besturingssysteem kent het <emphasis>echte</emphasis> wachtwoord
      niet.  De enige manier om een wachtwoord in <quote>platte
      tekst</quote> te verkrijgen, is door er met brute kracht naar
      te zoeken in alle mogelijke wachtwoorden.</para>

    <para>Helaas was DES, de Data Encryption Standard, de enige
      manier om wachtwoorden veilig te coderen toen &unix; ontstond.
      Dit was geen probleem voor gebruikers in de VS, maar omdat
      de broncode van DES niet ge&euml;xporteerd mocht worden moest
      &os; een manier vinden om zowel te gehoorzamen aan de wetten van
      de Verenigde Staten als aansluiting te houden bij alle andere varianten
      van &unix; die nog steeds DES gebruikten.</para>

    <para>De oplossing werd gevonden in het splitsen van de
      coderingsbibliotheken zodat gebruikers in de Verenigde Staten de
      DES-bibliotheken konden installeren en gebruiken en internationale
      gebruikers een coderingsmethode konden gebruiken die
      ge&euml;xporteerd mocht worden.  Zo is het gekomen dat &os; MD5
      is gaan gebruiken als coderingsmethode.  Van MD5 wordt aangenomen
      dat het veiliger is dan DES, dus de mogelijkheid om DES te
      installeren is vooral beschikbaar om aansluiting te kunnen
      houden.</para>

    <sect2>
      <title>Het crypt-mechanisme herkennen</title>

      <para>Op dit moment ondersteunt de bibliotheek DES, MD5, Blowfish,
	SHA256 en SHA512 hashfuncties.  Standaard gebruikt &os; MD5 om
	wachtwoorden te coderen.</para>

      <para>Het is vrij makkelijk om uit te vinden welke
	coderingsmethode &os; op een bepaald moment gebruikt.  De
	gecodeerde wachtwoorden in
	<filename>/etc/master.passwd</filename> bekijken is een manier.
	Wachtwoorden die gecodeerd zijn met MD5 zijn langer dan wanneer
	ze gecodeerd zijn met DES-hash.  Daarnaast beginnen ze met de
	karakters <literal>&dollar;1&dollar;</literal>.  Wachtwoorden
	die beginnen met <literal>&dollar;2a&dollar;</literal> zijn
	gecodeerd met de Blowfish hashfunctie.  DES-wachtwoordstrings
	hebben geen bijzondere kenmerken, maar ze zijn korter dan MD5
	wachtwoorden en gecodeerd in een 64-karakter alfabet waar geen
	<literal>&dollar;</literal> karakter in zit.  Een relatief korte
	string die niet begint met een dollar teken is dus
	waarschijnlijk een DES-wachtwoord.  Zowel SHA256 als SHA512 beginnen
	met de tekens <literal>&dollar;6&dollar;</literal>.</para>

      <para>Het wachtwoordformaat voor nieuwe wachtwoorden wordt
	ingesteld met de <literal>passwd_format</literal>
	aanmeldinstelling in <filename>/etc/login.conf</filename> waar
	<literal>des</literal>, <literal>md5</literal>,
	<literal>blf</literal>, <literal>sha256</literal> of
	<literal>sha512</literal> in mag staan.  Zie de &man.login.conf.5;
	handleiding voor meer informatie over
	aanmeldinstellingen.</para>
    </sect2>
  </sect1>

  <sect1 id="one-time-passwords">
    <title>Eenmalige wachtwoorden</title>

    <indexterm><primary>eenmalige wachtwoorden</primary></indexterm>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>eenmalige wachtwoorden</secondary>
    </indexterm>

    <para>Standaard biedt &os; ondersteuning voor OPIE (Eenmalige
      Wachtwoorden in Alles - <quote>One-time Passwords In
	Everything</quote>), wat standaard een MD5-hash gebruikt.</para>

    <para>Hier worden drie verschillende soorten wachtwoorden
      besproken.  De eerste is het normale &unix; of Kerberos
      wachtwoord.  Dit heet het <quote>&unix; wachtwoord</quote>.  Het
      tweede type is een eenmalig wachtwoord dat wordt gemaakt met het
      OPIE-programma &man.opiekey.1; en dat wordt geaccepteerd door
      &man.opiepasswd.1; en de aanmeldprocedure.  Dit heet het
      <quote>eenmalige wachtwoord</quote>.  Het laatste type wachtwoord
      is het wachtwoord dat wordt opgegeven aan het programma
      <command>opiekey</command> (en soms aan het programma
      <command>opiepasswd</command>) dat gebruikt wordt om eenmalige
      wachtwoorden te maken.  Dit type heet <quote>geheim
      wachtwoord</quote> of gewoon een <quote>wachtwoord</quote> zonder
      toevoeging.</para>

    <para>Het geheime wachtwoord heeft niets te maken met het &unix;
      wachtwoord; ze kunnen hetzelfde zijn, dat wordt afgeraden.
      OPIE geheime wachtwoorden kennen niet de beperking van 8
      karakters zoals de oude &unix; wachtwoorden.

      <footnote>
	<para>Bij &os; mag het wachtwoord voor aanmelden tot 128
	  karakters lang zijn.</para></footnote>

      Ze mogen onbeperkt lang zijn.  Wachtwoorden van een zes of zeven
      woorden lange zin zijn niet ongewoon.  Voor het overgrote deel
      werkt het OPIE-systeem volledig onafhankelijk van het &unix;
      wachtwoordsysteem.</para>

    <para>Buiten het wachtwoord zijn er nog twee stukjes gegevens die
      van belang zijn voor OPIE.  Het eerste wordt <quote>zaad</quote>
      (<quote>seed</quote>) of <quote>sleutel</quote>
      (<quote>key</quote>) genoemd en bestaat uit twee letters en vijf
      cijfers.  Het tweede stukje gegevens heet de
      <quote>iteratieteller</quote>, een nummer tussen 1 en 100.  OPIE
      maakt een eenmalig wachtwoord door het zaad en het geheime
      wachtwoord aaneen te schakelen en daarop het door de
      iteratieteller aangegeven keren MD5-hash toe te passen.  Daarna
      wordt het resultaat omgezet in zes korte Engelse woorden.  Deze
      zes woorden zijn een eenmalige wachtwoord.  Het
      autenticatiesysteem (hoofdzakelijk PAM) houdt bij welk
      eenmalig wachtwoord het laatst is gebruikt en de gebruiker wordt
      geautenticeerd als de hash van het door de gebruiker ingegeven
      wachtwoord gelijk is aan het vorige wachtwoord.  Omdat er een
      eenweg hash wordt gebruikt, is het onmogelijk om toekomstige
      eenmalige wachtwoorden te maken als iemand toch een eenmalig
      wachtwoord heeft afgevangen.  De iteratieteller wordt verlaagd na
      iedere succesvolle aanmelding om de gebruiker en het
      aanmeldprogramma synchroon te houden.  Als de iteratieteller op 1
      staat, moet OPIE opnieuw ingesteld worden.</para>

    <para>Er zijn enkele programma's bij ieder systeem betrokken die
      hieronder worden besproken.  Het programma
      <command>opiekey</command> heeft een iteratieteller,
      zaad en een geheim wachtwoord nodig en maakt dan een eenmalig
      wachtwoord of een lijst van opeenvolgende eenmalige wachtwoorden.
      Het programma <command>opiepasswd</command> wordt gebruikt om OPIE
      te initialiseren en om wachtwoorden, iteratietellers en zaad te
      wijzigen.  Het accepteert zowel wachtwoordzinnen als een
      iteratieteller, zaad en een eenmalig wachtwoord.  Het programma
      <command>opieinfo</command> bekijkt de relevante bestanden waarin
      de eigenschappen staan (<filename>/etc/opiekeys</filename>) en
      toont de huidige iteratieteller en zaad van de gebruiker die het
      commando uitvoert.</para>

    <para>Nu worden vier verschillende acties besproken.  Bij de eerste
      wordt <command>opiepasswd</command> gebruikt in een beveiligde
      verbinding om voor het eerst eenmalige wachtwoorden in te stellen
      of om een wachtwoord of zaad aan te passen.  Bij de tweede wordt
      <command>opiepasswd</command> gebruikt over een onbeveiligde
      verbinding samen met <command>opiekey</command> over een
      beveiligde verbinding om hetzelfde te bereiken.  In een derde
      scenario wordt <command>opiekey</command> gebruikt om aan te
      melden over een onveilige verbinding.  Het vierde
      scenario behandelt het gebruik van <command>opiekey</command> om
      een aantal sleutels aan te maken die opgeschreven of afgedrukt
      kunnen worden, zodat ze meegenomen kunnen worden naar een plaats
      van waar geen enkele veilige verbinding opgezet kan worden.</para>

    <sect2>
      <title>Veilige verbinding initialiseren</title>

      <para>Gebruik het commando <command>opiepasswd</command> om OPIE
	voor de eerste keer te initialiseren:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</screen>

      <para>Als <prompt>Enter new secret pass phrase:</prompt> of
	<prompt>Enter secret password:</prompt> op het scherm
	verschijnt, dient een wachtwoord of wachtwoordzin ingevoerd te
	worden.  Dit is dus niet het aanmeldwachtwoord is, maar dit
	wordt gebruikt om eenmalige wachtwoorden te maken.  De
	<quote>ID</quote> regel geeft de parameters van het verzoek
	weer: de aanmeldnaam, de iteratieteller en zaad.  Bij het
	aanmelden kent het systeem deze parameters en worden deze
	weergegeven zodat ze niet onthouden hoeven te worden.  Op de
	laatste regel staat het eenmalige wachtwoord dat overeenkomt met
	die parameters en het geheime wachtwoord.  Als de gebruiker
	direct opnieuw zou aanmelden, zou hij dat eenmalige wachtwoord
	moeten gebruiken.</para>
    </sect2>

    <sect2>
      <title>Onveilige verbinding initialiseren</title>

      <para>Om een wachtwoord te initialiseren of te wijzigen over een
	onveilige verbinding, moet er al ergens een veilige verbinding
	bestaan waar de gebruiker <command>opiekey</command> kan
	uitvoeren.  Dit kan een shellprompt zijn op een machine die
	vertrouwd wordt.  De gebruiker moet ook een iteratieteller
	verzinnen (100 is wellicht een prima getal) en een eigen zaad
	bedenken of er een laten fabriceren.  Over de onveilige
	verbinding (naar de machine die de gebruiker wil initialiseren)
	wordt het commando <command>opiepasswd</command> gebruikt:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
	otp-md5 498 to4268 ext
	Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
	otp-md5 499 to4269
	Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</screen>

      <para>Druk op <keycap>Return</keycap> om het standaardzaad te
	accepteren.  Voor een toegangswachtwoord wordt ingevoerd, dient
	eerst gewisseld te worden naar de veilige verbinding en dienen
	dezelfde parameters ingegeven te worden:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>In de onveilige verbinding wordt nu het eenmalige wachtwoord
	in het relevante programma gekopieerd.</para>
    </sect2>

    <sect2>
      <title>Een enkel eenmalig wachtwoord maken</title>

      <para>Als OPIE eenmaal is ingesteld staat er bij het
	aanmelden iets als het volgende:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;gebruikersnaam&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>NB: de OPIE-prompt heeft een handige optie (die hier niet te
	zien is): als er op <keycap>Return</keycap> wordt gedrukt bij de
	wachtwoordregel, wordt de echo aangezet, zodat de invoer
	zichtbaar is.  Dit is erg handig als er met de hand een
	wachtwoord wordt ingegeven, zoals wanneer het wordt ingevoerd
	vanaf een afdruk.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>

      <indexterm><primary>Windows</primary></indexterm>

      <indexterm><primary>MacOS</primary></indexterm>

      <para>Nu moet het eenmalige wachtwoord gemaakt worden om het
	aanmeldprompt mee te antwoorden.  Dit moet gedaan worden op een
	vertrouwd systeem waarop <command>opiekey</command> beschikbaar
	is.  Er zijn ook versies voor &ms-dos;, &windows; en &macos;.
	Voor het commando moet zowel de iteratieteller als het zaad
	ingeven worden op de commandoregel.  Deze kan zo overgenomen
	worden vanaf het aanmeldprompt op de machine waarop de gebruiker
	zich wil aanmelden.</para>

      <para>Op het vertrouwde systeem:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Nu het eenmalige wachtwoord er is, kan het aanmelden
	doorgang vinden.</para>
    </sect2>

    <sect2>
      <title>Meerdere eenmalige wachtwoorden maken</title>

      <para>Soms moet een gebruiker ergens naar toe gaan waar er geen
	toegang is tot een vertrouwde machine of een beveiligde
	verbinding.  In dat geval is het mogelijk om met het commando
	<command>opiekey</command> een aantal eenmalige wachtwoorden te
	maken om uit te printen en mee te nemen:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;geheim wachtwoord&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>Met <option>-n 5</option> worden vijf opeenvolgende
	sleutels aangevraagd, <option>30</option> geeft aan wat het
	laatste iteratiegetal moet zijn.  Deze wachtwoorden worden
	weergegeven in <emphasis>omgekeerde</emphasis> volgorde voor
	gebruik.  Als de gebruiker echt parano&iuml;de bent kan hij ze
	opschrijven of hij kan er ook voor kiezen ze af te drukken met
	<command>lpr</command>.  Op iedere regel staat dus de
	iteratieteller en het eenmalige wachtwoord, maar misschien is
	het toch handig om ze na gebruik af te strepen.</para>
    </sect2>

    <sect2>
      <title>Gebruik van &unix; wachtwoorden beperken</title>

      <para>Met OPIE kan paal en perk gesteld worden aan het gebruik van
	&unix; wachtwoorden op basis van het <acronym>IP</acronym>-adres
	van een aanmeldsessie.  Dat kan met het bestand
	<filename>/etc/opieaccess</filename> dat standaard aanwezig is.
	Bij &man.opieaccess.5; staat meer informatie over dit bestand en
	welke beveiligingsoverwegingen bestaan bij het gebruik.</para>

      <para>Hieronder een voorbeeld voor een
	<filename>opieaccess</filename> bestand:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>In deze regel (<literal>permit Internet</literal>) staat
	dat gebruikers met een bron <acronym>IP</acronym> adres (wat
	gefingeerd kan worden) dat past binnen de aangegeven waarde en
	masker altijd &unix; wachtwoorden mogen gebruiken.</para>

      <para>Als geen van de regels uit <filename>opieaccess</filename>
	van toepassing is, worden standaard pogingen zonder OPIE
	geweigerd.</para>
    </sect2>
  </sect1>

  <sect1 id="tcpwrappers">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>TCP Wrapper</primary></indexterm>

    <title>TCP Wrappers</title>

    <para>Iedereen die bekend is met &man.inetd.8; heeft waarschijnlijk
      wel eens van <acronym>TCP</acronym> Wrappers gehoord.  Maar
      slechts weinigen lijken volledig te begrijpen hoe ze in een
      netwerkomgeving toegepast kunnen worden.  Het schijnt dat
      iedereen een firewall wil hebben om netwerkverbindingen af te
      handelen.  Ondanks dat een firewall veel kan, zijn er toch dingen
      die het niet kan, zoals tekst terugsturen naar de bron van een
      verbinding.  De <acronym>TCP</acronym> Wrappers software kan dat
      en nog veel meer.  In dit onderdeel worden de mogelijkheden van
      <acronym>TCP</acronym> Wrappers besproken en, waar dat van
      toepassing is, worden ook voorbeelden voor implementatie
      gegeven.</para>

    <para>De <acronym>TCP</acronym> Wrappers software vergroot de
      mogelijkheden van <application>inetd</application> door de
      mogelijkheid al zijn serverdaemons te controleren.  Met deze
      methode is het mogelijk om te loggen, berichten te zenden naar
      verbindingen, een daemon toe te staan alleen interne verbindingen
      te accepteren, etc.  Hoewel een aantal van deze mogelijkheden ook
      ingesteld kunnen worden met een firewall, geeft deze manier niet
      alleen een extra laag beveiliging, maar gaat dit ook verder dan
      wat een firewall kan bieden.</para>

    <para>De toegevoegde waarde van <acronym>TCP</acronym> Wrappers
      is niet dat het een goede firewall vervangt.
      <acronym>TCP</acronym> Wrappers kunnen samen met een firewall en
      andere beveiligingsinstellingen gebruikt worden om een extra laag
      van beveiliging voor het systeem te bieden.</para>

    <para>Omdat dit een uitbreiding is op de instellingen van
      <application>inetd</application>, wordt aangenomen dat de lezer
      het onderdeel <link
	linkend="network-inetd">inetd configuratie</link> heeft
      gelezen.</para>

    <note>
      <para>Hoewel programma's die onder &man.inetd.8; draaien niet
	echt <quote>daemons</quote> zijn, heten ze traditioneel wel zo.
	Deze term wordt hier dus ook gebruikt.</para>
    </note>

    <sect2>
      <title>Voor het eerst instellen</title>

      <para>De enige voorwaarde voor het gebruiken van
	<acronym>TCP</acronym> Wrappers in &os; is ervoor te zorgen
	dat de server <application>inetd</application> gestart wordt
	vanuit <filename>rc.conf</filename> met de optie
	<option>-Ww</option>; dit is de standaardinstelling.  Er wordt
	vanuit gegaan dat <filename>/etc/hosts.allow</filename> juist is
	ingesteld, maar als dat niet zo is, dan zal &man.syslogd.8; dat
	melden.</para>

      <note>
	<para>In tegenstelling tot bij andere implementaties van
	  <acronym>TCP</acronym> Wrappers is het gebruik van
	  <filename>hosts.deny</filename> niet langer mogelijk.  Alle
	  instellingen moeten in <filename>/etc/hosts.allow</filename>
	  staan.</para>
      </note>

      <para>In de meest eenvoudige instelling worden verbindingen naar
	daemons toegestaan of geweigerd afhankelijk van de opties in
	<filename>/etc/hosts.allow</filename>.  De standaardinstelling
	in &os; is verbindingen toe te staan naar iedere daemon die met
	<application>inetd</application> is gestart.  Na de
	basisinstelling wordt aangegeven hoe dit gewijzigd kan worden.</para>

      <para>De basisinstelling heeft meestal de vorm
	<literal>daemon : adres : actie</literal>.
	<literal>daemon</literal> is de daemonnaam die
	<command>inetd</command> heeft gestart.  Het
	<literal>adres</literal> kan een geldige hostnaam, een
	<acronym>IP</acronym>-adres of een IPv6-adres tussen
	blokhaken ([&nbsp;]) zijn.  Het veld <literal>actie</literal>
	kan <literal>allow</literal> of <literal>deny</literal> zijn,
	afhankelijk van of toegang toegestaan of geweigerd moet worden.
	De instellingen werken zo dat ze worden doorlopen van onder naar
	boven om te kijken welke regel als eerste van toepassing is.
	Als een regel van toepassing is gevonden, dan stop het
	zoekproces.</para>

      <para>Er zijn nog andere mogelijkheden, maar die worden elders
	toegelicht.  Een eenvoudige instelling kan al van met deze
	informatie worden gemaakt.  Om bijvoorbeeld
	<acronym>POP</acronym>3 verbindingen toe te staan via de
	<filename role="package">mail/qpopper</filename> daemon,
	zouden de volgende instellingen moeten worden toegevoegd aan
	<filename>hosts.allow</filename>:</para>

      <programlisting># Deze regel is nodig voor POP3-verbindingen
qpopper : ALL : allow</programlisting>

      <para>Nadat deze regel is toegevoegd moet
	<application>inetd</application> herstart worden.  Dit gaat met
	het commando &man.kill.1; of met de parameter
	<parameter>restart</parameter> met
	<filename>/etc/rc.d/inetd</filename>.</para>
    </sect2>

    <sect2>
      <title>Gevorderde instellingen</title>

      <para><acronym>TCP</acronym> Wrappers hebben ook gevorderde
	instellingen.  Daarmee komt meer controle over de wijze waarop
	er met verbindingen wordt omgegaan.  Soms is het een goed idee
	om commentaar te sturen naar bepaalde hosts of
	daemonverbindingen.  In andere gevallen moet misschien iets
	in een logboekbestand geschreven worden of een email naar de
	beheerder gestuurd worden.  Dit kan allemaal met instellingen
	die <literal>wildcards</literal>, uitbreidingskarakters
	(expansion characters) en het uitvoeren van externe commando's
	heten.  De volgende twee paragrafen beschrijven deze
	mogelijkheden.</para>

      <sect3>
	<title>Externe commando's</title>

	<para>Stel dat zich de situatie voordoet waar een verbinding
	  geweigerd moet worden, maar er een reden gestuurd moet
	  worden naar het individu dat die verbinding probeerde op te
	  zetten.  Hoe gaat dat?  Dat is mogelijk door gebruik te
	  maken van de optie <option>twist</option>.  Als er een
	  poging tot verbinding wordt gedaan, wordt er met
	  <option>twist</option> een shellcommando of script
	  uitgevoerd.  Er staat al een voorbeeld in
	  <filename>hosts.allow</filename>:</para>

	<programlisting># De andere daemons zijn beschermd.
ALL : ALL \
	: severity auth.info \
	: twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>Dit voorbeeld geeft aan dat het bericht <quote>You are
	    not allowed to use <literal>daemon</literal> from
	  <literal>hostname</literal>.</quote> wordt teruggestuurd
	  voor iedere daemon die niet al is ingesteld in het
	  toegangsbestand.  Het is erg handig om een antwoord terug
	  te sturen naar degene die een verbinding op heeft willen
	  zetten meteen nadat een tot stand gekomen verbinding is
	  verbroken.  Let wel dat alle berichten die gezonden worden
	  <emphasis>moeten</emphasis> staan tussen <literal>"</literal>
	  karakters.  Hier zijn geen uitzonderingen op.</para>

	<warning>
	  <para> Het is mogelijk een ontzegging van dienst aanval uit
	    te voeren op de server als een aanvaller, of een groep
	    aanvallers, deze daemons kan overstromen met verzoeken om
	    verbindingen te maken.</para>
	</warning>

	<para>Het is ook mogelijk hier de optie <option>spawn</option>
	  te gebruiken.  Net als <option>twist</option> weigert
	  de optie <option>spawn</option> impliciet de verbinding en kan
	  het gebruikt worden om shellcommando's of scripts uit te
	  voeren.  Anders dan bij <option>twist</option> stuurt
	  <option>spawn</option> geen bericht aan degene die de
	  verbinding wilde maken.  Zie bijvoorbeeld de volgende
	  instelling:</para>

	<programlisting># Geen verbindingen van example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>Hiermee worden alle verbindingen van het domein
	  <hostid role="fqdn">*.example.com</hostid> geweigerd.
	  Tegelijkertijd worden ook hostnaam, <acronym>IP</acronym>
	  adres en de daemon waarmee verbinding werd gemaakt naar
	  <filename>/var/log/connections.log</filename>
	  geschreven.</para>

	<para>Naast de vervangingskarakters die al zijn toegelicht,
	  zoals <literal>%a</literal>, bestaan er nog een paar andere.
	  In de handleiding van &man.hosts.access.5; staat een volledige
	  lijst.</para>
      </sect3>

      <sect3>
	<title>Wildcardopties</title>

	<para>Tot nu toe is in ieder voorbeeld <literal>ALL</literal>
	  gebruikt.  Er bestaan nog andere opties waarmee de
	  mogelijkheden nog verder gaan.  Zo kan <literal>ALL</literal>
	  gebruikt worden om van toepassing te zijn op iedere instantie
	  van een daemon, domein of een <acronym>IP</acronym> adres.
	  Een andere wildcard die gebruikt kan worden is
	  <literal>PARANOID</literal>.  Daarmee wordt iedere host die
	  een <acronym>IP</acronym>-adres geeft dat gefingeerd kan zijn
	  aangeduid.  Met andere woorden: <literal>PARANOID</literal>
	  kan gebruikt worden om een actie aan te geven als er een
	  <acronym>IP</acronym>-adres gebruikt wordt dat verschilt van
	  de hostnaam.  Het volgende voorbeeld kan wat verheldering
	  brengen:</para>

	<programlisting># Weiger mogelijke gespoofte verzoeken aan sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>In het voorgaande voorbeeld worden alle
	  verbindingsverzoeken aan <command>sendmail</command> met een
	  <acronym>IP</acronym>-adres dat verschilt van de hostnaam
	  geweigerd.</para>

	<caution>
	  <para>Het gebruik van de wildcard <literal>PARANOID</literal>
	    kan nogal wat schade aanrichten als de cli&euml;nt of de
	    server kapotte <acronym>DNS</acronym>-instellingen heeft.
	    Voorzichtigheid van de beheerder is geboden.</para>
	</caution>

	<para>De handleiding van &man.hosts.access.5; geeft meer
	  uitleg over wildcards en de mogelijkheden die ze
	  bieden.</para>

	<para>Voordat de bovenstaande instellingen werken, dient de
	  eerste regels in <filename>hosts.allow</filename> als
	  commentaar gemarkeerd te worden.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="kerberos5">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tillman</firstname>
	  <surname>Hodgson</surname>
	  <contrib>Bijgedragen door </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Gebaseerd op een bijdrage van </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>Kerberos5</application></title>

    <para><application>Kerberos</application> is een netwerkdienst,
      protocol en systeem waarmee gebruikers zich kunnen aanmelden
      met behulp van een dienst op een veilige server.  Diensten als
      op een andere server aanmelden, op afstand kopi&euml;ren, veilig
      tussen systemen kopi&euml;ren en andere taken met een hoog risico
      worden aanmerkelijk veiliger en beter controleerbaar.</para>

    <para><application>Kerberos</application> kan omschrijven worden
      als identiteitbevestigend proxy systeem.  Het kan ook
      omschreven worden als een vertrouwd autenticatiesysteem van een
      derde partij.  <application>Kerberos</application> vervult maar
      &eacute;&eacute;n taak: het veilig autenticeren van gebruikers
      op het netwerk.  Het vervult geen autorisatietaken (wat
      gebruikers mogen) en controleert ook niets (wat gebruikers hebben
      gedaan).  Nadat een cli&euml;nt en server
      <application>Kerberos</application> hebben gebruikt om hun
      identiteit vast te stellen kunnen ze ook al hun communicatie
      coderen om hun privacy en gegevensintegriteit te garanderen.</para>

    <para>Daarom wordt het sterk aangeraden om
      <application>Kerberos</application> samen met andere
      beveiligingsmechanismen te gebruiken die autorisatie en
      controlemogelijkheden bieden.</para>

    <para>De aanwijzingen die nu volgen kunnen gebruikt worden als
      werkinstructie om <application>Kerberos</application> in te
      stellen zoals dat wordt meegeleverd met &os;.  Een complete
      beschrijving staat in de handleiding.</para>

    <para>Voor demonstratie van de installatie van
      <application>Kerberos</application> wordt gebruik gemaakt van de
      volgende naamgeving:</para>

    <itemizedlist>
      <listitem>
	<para>Het <acronym>DNS</acronym> domein (<quote>zone</quote>)
	  is example.org.</para>
      </listitem>

      <listitem>
	<para>De <application>Kerberos</application> wereld is
	  EXAMPLE.ORG.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Het advies is voor installaties van
	<application>Kerberos</application> echte domeinnamen te
	gebruiken, zelfs als het alleen intern wordt gebruikt.  Hiermee
	worden <acronym>DNS</acronym> problemen voorkomen is een
	goede samenwerking met andere
	<application>Kerberos</application> werelden verzekerd.</para>
    </note>

    <sect2>
      <title>Geschiedenis</title>

      <indexterm>
	<primary>Kerberos5</primary>

	<secondary>geschiedenis</secondary>
      </indexterm>

      <para><application>Kerberos</application> is ontworpen door
	<acronym>MIT</acronym> als oplossing voor
	netwerkbeveiligingsproblemen.  Het
	<application>Kerberos</application> protocol gebruikt sterke
	codering zodat een cli&euml;nt zijn identiteit kan bewijzen aan
	een server (en andersom) over een onveilige
	netwerkverbinding.</para>

      <para><application>Kerberos</application> is zowel de naam van
	een netwerkautorisatieprotocol als een bijvoeglijk naamwoord om
	de programma's te beschrijven die gebruik maken van het
	programma (zoals <application>Kerberos</application> telnet).
	De huidige versie van het protocol is versie 5 en is beschreven
	in <acronym>RFC</acronym>&nbsp;1510.</para>

      <para>Er zijn een aantal vrij beschikbare implementaties van dit
	protocol beschikbaar voor veel systemen.  Het Massachusetts
	Institute of Technology (<acronym>MIT</acronym>), waar
	<application>Kerberos</application> ooit is ontwikkeld,
	ontwikkelt nog steeds door aan hun
	<application>Kerberos</application> pakket.  Het wordt in de
	<acronym>VS</acronym> veel gebruikt als coderingspakket en
	daarom wordt het ook geraakt door de exportwetgeving van de
	<acronym>VS</acronym>.  <application>Kerberos</application>
	van <acronym>MIT</acronym> is beschikbaar als port
	(<filename role="package">security/krb5</filename>).  Heimdal
	<application>Kerberos</application> is een andere implementatie
	van versie 5 die expliciet buiten de <acronym>VS</acronym> is
	ontwikkeld om de exportwetgeving de omzeilen (en wordt daarom
	vaak gebruikt in niet-commerci&euml;le &unix; varianten).  De
	Heimdal <application>Kerberos</application> distributie is
	beschikbaar als port (<filename
	  role="package">security/heimdal</filename>) en er zit een
	minimale installatie in de basisinstallatie van &os;.</para>

      <para>Om het grootst mogelijke publiek te bereiken gaan deze
	instructies ervan uit dat de Heimdal distributie die bij &os;
	zit wordt gebruikt.</para>
    </sect2>

    <sect2>
      <title>Opzetten van een Heimdal <acronym>KDC</acronym></title>

      <indexterm>
	<primary>Kerberos5</primary>

	<secondary>sleutel distributie centrum instellingen</secondary>
      </indexterm>

      <para>Het Sleutel Distributie Centrum (<acronym>KDC</acronym>,
	voluit <quote>Key Distribution Center</quote>) is de
	gecentraliseerde autenticatiedienst die
	<application>Kerberos</application> levert.  Het is de computer
	die <application>Kerberos</application> tickets uitgeeft.  Het
	<acronym>KDC</acronym> wordt <quote>vertrouwd</quote> door
	alle andere computer in de <application>Kerberos</application>
	wereld en daarom dient er een strenger beveiligingsregime op
	van kracht te zijn.</para>

      <para>Hoewel het draaien van de
	<application>Kerberos</application> dienst erg weinig van een
	systeem vraagt, wordt het wel aangeraden om een machine in te
	richten exclusief voor het <acronym>KDC</acronym> om
	beveiligingsredenen.</para>

      <para>Het opzetten van een <acronym>KDC</acronym> begint met de
	controle of de instellingen in
	<filename>/etc/rc.conf</filename> juist zijn om te functioneren
	als <acronym>KDC</acronym> (misschien moeten paden veranderd
	worden voor een eigen systeem):</para>

      <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Daarna wordt het
	<application>Kerberos</application>-instellingenbestand
	<filename>/etc/krb5.conf</filename> aangemaakt:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para><filename>/etc/krb5.conf</filename> gaat ervan uit dat de
	<acronym>KDC</acronym> de volledig gekwalificeerde hostnaam <hostid
	  role="fqdn">kerberos.example.org</hostid> heeft.  Als de
	<acronym>KDC</acronym> een andere hostnaam heeft, moet er nog
	een CNAME (alias) toegevoegd aan de zonefile.</para>

      <note>
	<para>Voor grotere netwerken met een juist ingestelde
	  <acronym>BIND</acronym> <acronym>DNS</acronym> server kan
	  het bovenstaande voorbeeld ingekort worden tot:</para>

	<programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	  <para>Door de volgende regels toe te voegen aan het
	    zonebestand voor <hostid role="fqdn">example.org</hostid>:</para>

	  <programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</programlisting>
      </note>

      <note>
	<para>Om cli&euml;nten de
	  <application>Kerberos</application>-diensten te kunnen laten
	  vinden, <emphasis>moet</emphasis> er een volledig ingestelde
	  <filename>/etc/krb5.conf</filename> zijn of een minimaal
	  ingestelde <filename>/etc/krb5.conf</filename>
	  <emphasis>en</emphasis> een correct ingestelde DNS-server.</para>
      </note>

      <para>Nu wordt de <application>Kerberos</application>
	database aangemaakt.  Deze database bevat de sleutels voor
	alle principals en zijn versleuteld met een hoofdwachtwoord.
	Dit wachtwoord hoeft niet onthouden te worden omdat het wordt
	opgeslagen in (<filename>/var/heimdal/m-key</filename>).  De
	hoofdsleutel wordt aangemaakt door <command>kstash</command>
	te starten en een wachtwoord in te voeren.</para>

      <para>Als de hoofdsleutel is gemaakt, kan de database
	ingeschakeld worden met <command>kadmin</command>
	met de optie <literal>-l</literal> (die staat voor
	<quote>local</quote>).  Deze optie geeft
	<command>kadmin</command> de opdracht om de databasebestanden
	direct te wijzigingen in plaats van via de
	<command>kadmind</command> netwerkdienst.  Hiermee wordt het
	kip-ei-probleem opgelost waarbij een verbinding wordt gemaakt
	met de database voordat hij bestaat.  Op het prompt van
	<command>kadmin</command> kan met <command>init</command>
	de database met de werelden aangemaakt worden.</para>

      <para>Tenslotte, nog steeds in <command>kadmin</command>, kan
	de eerste principal gemaakt worden met
	<command>add</command>.  De standaardopties voor de principal
	worden nu aangehouden.  Deze kunnen later altijd
	nog gewijzigd worden met <command>modify</command>.  Met
	het commando <literal>?</literal> kunnen alle beschikbare
	mogelijkheden getoond worden.</para>

      <para>Hieronder een sessie waarin een voorbeelddatabase wordt
	aangemaakt:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin> <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin> <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Nu kan de <acronym>KDC</acronym> dienst gestart worden
	met <command>/etc/rc.d/kerberos start</command> en
	<command>/etc/rc.d/kadmind start</command>.  Op dit moment
	draait er nog geen enkele daemon die gebruik maakt van
	<application>Kerberos</application>.  Bevestiging dat
	<acronym>KDC</acronym> draait is te krijgen door een ticket te
	vragen en dat uit te lezen voor de principal (gebruiker)
	die zojuist is aangemaakt vanaf de commandoregel van het
	<acronym>KDC</acronym> zelf:</para>

      <screen>&prompt.user; <userinput>kinit <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>klist</userinput>
Credentials cache: FILE:<filename>/tmp/krb5cc_500</filename>
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

      <para>Het ticket kan worden ingenomen wanneer u klaar bent:</para>

      <screen>&prompt.user; <userinput>kdestroy</userinput></screen>
    </sect2>

    <sect2>
      <title><application>Kerberos</application> inschakelen op een
	server met Heimdal diensten</title>

      <indexterm>
	<primary>Kerberos5</primary>

	<secondary>diensten inschakelen</secondary>
      </indexterm>

      <para>Als eerste is een kopie van het instellingenbestand van
	<application>Kerberos</application> nodig,
	<filename>/etc/krb5.conf</filename>.  Dit bestand kan
	eenvoudigweg op een veilige manier (met netwerkprogramma's
	als &man.scp.1;, of fysiek via een floppy) naar de
	cli&euml;ntcomputer gekopieerd worden vanaf de
	<acronym>KDC</acronym>.</para>

      <para>Hierna is het <filename>/etc/krb5.keytab</filename>
	nodig.  Dit is het belangrijkste verschil tussen een server
	die een daemons met <application>Kerberos</application>
	aanbiedt en een werkstation: de server heeft het bestand
	<filename>keytab</filename> nodig.  Dit bestand bevat de
	hostsleutel van de server waardoor het werkstation en de
	<acronym>KDC</acronym> elkaars identiteit kunnen bevestigen.
	Dit bestand dient veilig overgebracht te worden omdat de
	beveiliging van de server doorbroken kan worden als de
	sleutel openbaar wordt gemaakt.  Dit betekent expliciet dat
	overdracht via een protocol dat platte tekst gebruikt,
	bijvoorbeeld <acronym>FTP</acronym>, een slecht idee is.</para>

      <para>Meestal wordt <filename>keytab</filename> naar de
	server gebracht met <command>kadmin</command>.  Dat
	werkt handig omdat ook de host principal (het
	<acronym>KDC</acronym> onderdeel van
	<filename>krb5.keytab</filename>) aangemaakt moet
	worden met <command>kadmin</command>.</para>

      <para>Let wel op dat er al een ticket moet zijn en dat dit
	ticket de <command>kadmin</command> interface moet mogen
	gebruiken in <filename>kadmind.acl</filename>.  Zie
	<quote>Beheer op Afstand</quote> in de Heimdal
	informatiepagina's (<command>info heimdal</command>) voor
	details over het ontwerpen van toegangscontrole.  Als
	<command>kadmin</command> via het netwerk geen toegang mag
	hebben, dan kan ook op een veilige verbinding gemaakt worden
	met de <acronym>KDC</acronym> (via het lokale console,
	&man.ssh.1; of <application>Kerberos</application>
	&man.telnet.1;) zodat alles lokaal uitgevoerd kan worden met
	<command>kadmin -l</command>.</para>

      <para>Na het installeren van
	<filename>/etc/krb5.conf</filename> kan
	<command>kadmin</command> van de
	<application>Kerberos</application> server gebruikt worden.
	Met <command>add --random-key</command> kan de host
	principal toegevoegd worden en met <command>ext</command> kan
	de host principal van de server naar zijn eigen keytab
	getrokken worden.  Bijvoorbeeld:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin><userinput> ext host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

      <para>Let op: <command>ext</command> slaat de sleutel standaard
	op in <filename>/etc/krb5.keytab</filename>.</para>

      <para>Als <command>kadmind</command> niet beschikbaar is op de
	<acronym>KDC</acronym> (wellicht om beveiligingsredenen) en
	er via het netwerk dus geen toegang is tot
	<command>kadmin</command>, dan kan de host principal
	(<username>host/myserver.EXAMPLE.ORG</username>) ook direct
	aan de <acronym>KDC</acronym> toegevoegd worden en daarna in
	een tijdelijk bestand gezet worden.  Het volgende kan
	gebruikt worden om te voorkomen dat
	<filename>/etc/krb5.keytab</filename> op de
	<acronym>KDC</acronym>) wordt overschreven:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

      <para>Hierna kan de keytab veilig gekopieerd worden naar de
	server (met <command>scp</command> of een floppy).  Geef
	een niet-standaard naam op voor de keytab om te voorkomen
	dat de keytab op de <acronym>KDC</acronym> wordt
	overschreven.</para>

      <para>Nu kan de server communiceren met de
	<acronym>KDC</acronym> (vanweg
	<filename>krb5.conf</filename>) en zijn identiteit bewijzen
	(vanwege <filename>krb5.keytab</filename>).  Nu is de server
	klaar om er een aantal <application>Kerberos</application>
	diensten op te activeren.  In dit voorbeeld wordt de dienst
	<command>telnet</command> geactiveerd door de volgende regel
	in <filename>/etc/inetd.conf</filename> te zetten en dan
	&man.inetd.8; te herstarten met
	<command>/etc/rc.d/inetd restart</command>:</para>

      <programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

      <para>Het belangrijkste is dat de typering
	<command>-a</command> (van autenticatie) op user staat.  Meer
	details zijn in &man.telnetd.8; te vinden.</para>
    </sect2>

    <sect2>
      <title><application>Kerberos</application> activeren op een
	cli&euml;nt met Heimdal</title>

      <indexterm>
	<primary>Kerberos5</primary>

	<secondary>cli&euml;ntinstellingen</secondary>
      </indexterm>

      <para>Het opzetten van een cli&euml;ntcomputer is eigenlijk
	kinderlijk eenvoudig.  Wat betreft de
	<application>Kerberos</application> instelling is alleen het
	<application>Kerberos</application> instellingenbestand
	(<filename>/etc/krb5.conf</filename>) nodig.  Dat kan
	eenvoudigweg naar de cli&euml;ntcomputer gekopieerd worden
	vanaf de <acronym>KDC</acronym>.</para>

      <para>Test de cli&euml;nt met <command>kinit</command>,
	<command>klist</command> en <command>kdestroy</command>
	vanaf de cli&euml;nt om een ticket te krijgen, te bekijken en
	daarna te verwijderen voor de principal die hierboven is
	aangemaakt.  Nu moeten ook
	<application>Kerberos</application> applicaties gebruikt
	kunnen worden om verbindingen te maken met servers waarop
	<application>Kerberos</application> is geactiveerd.  Als dat
	niet lukt en het verkrijgen van een ticket is wel mogelijk,
	dan ligt dat hoogstwaarschijnlijk aan de server en niet aan
	de cli&euml;nt of de <acronym>KDC</acronym>.</para>

      <para>Bij het testen van een applicatie als
	<command>telnet</command> kan het beste een pakketsnuffelaar
	(bijvoorbeeld &man.tcpdump.1;) gebruikt worden om te bevestigen dat
	een wachtwoord niet als tekst wordt verzonden.  Gebruik
	<command>telnet</command> met de optie <literal>-x</literal>.
	Dan wordt de complete gegevensstroom versleuteld (vergelijkbaar
	met <command>ssh</command>).</para>

      <para>Er worden standaard ook andere
	<application>Kerberos</application> applicaties op de
	cli&euml;nt ge&iuml;nstalleerd.  Hier komt de
	<quote>minimalistische</quote> natuur van de basisinstallatie
	van Heimdal boven drijven: <command>telnet</command> is
	de enige dienst waarvoor <application>Kerberos</application>
	geactiveerd is.</para>

      <para>De port Heimdal voegt een aantal ontbrekende
	cli&euml;ntapplicaties toe: versies met ondersteuning voor
	<application>Kerberos</application> van
	<command>ftp</command>, <command>rsh</command>,
	<command>rcp</command>, <command>rlogin</command> en een paar
	minder gebruikelijke programma's.  De <acronym>MIT</acronym>
	port bevat ook een volledig gamma aan
	<application>Kerberos</application> cli&euml;ntapplicaties.</para>
    </sect2>

    <sect2>
      <title>Instellingenbestanden voor gebruikers:
	<filename>.k5login</filename> en
	<filename>.k5users</filename></title>

      <indexterm><primary><filename>.k5login</filename></primary></indexterm>

      <indexterm><primary><filename>.k5users</filename></primary></indexterm>

      <para>Voor gebruikers binnen een wereld wijst hun
	<application>Kerberos</application> principal (bv.
	<username>tillman@EXAMPLE.ORG</username>) gewoonlijk naar
	een lokale gebruikersaccount (bijvoorbeeld een lokale account
	met de naam <username>tillman</username>).  Voor
	cli&euml;ntapplicaties als <command>telnet</command> is
	gewoonlijk geen gebruikersnaam of principal nodig.</para>

      <para>Soms moet iemand zonder bijpassende
	<application>Kerberos</application> principal toch toegang
	hebben tot een lokale gebruikersaccount.
	<username>tillman@EXAMPLE.ORG</username> zou bijvoorbeeld
	toegang nodig kunnen hebben tot de lokale gebruikersaccount
	<username>webdevelopers</username>.  Andere principals zouden
	die toegang wellicht ook nodig kunnen hebben.</para>

      <para>De bestanden <filename>.k5login</filename> en
	<filename>.k5users</filename> uit de gebruikersmap kunnen op
	eenzelfde manier gebruikt worden als
	<filename>.hosts</filename> en <filename>.rhosts</filename>.
	Zo wordt het voorgaande probleem opgelost.  Als bijvoorbeeld
	een <filename>.k5login</filename> met de volgende
	inhoud:</para>

      <screen>tillman@example.org
jdoe@example.org</screen>

      <para>in de thuismap van de lokale gebruiker
	<username>webdevelopers</username> gezet wordt dan zouden
	beide principals toegang hebben tot die account zonder dat
	ze een wachtwoord hoeven te delen.</para>

      <para>We raden aan de handleidingen voor deze commando's
	te lezen.  Let op dat de <command>ksu</command> handleiding
	<filename>.k5users</filename> behandelt.</para>
    </sect2>

    <sect2>
      <title><application>Kerberos</application> tips, trucs en
	problemen oplossen</title>

      <indexterm>
	<primary>Kerberos5</primary>

	<secondary>problemen oplossen</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>Als de Heimdal of <acronym>MIT</acronym>
	    <application>Kerberos</application> port wordt gebruikt
	    dan dient de <envar>PATH</envar> omgevingsvariabele
	    de <application>Kerberos</application> versies van de
	    cli&euml;ntapplicaties te tonen voor de systeemversies.</para>
	</listitem>

	<listitem>
	  <para>Hebben alle computers in de wereld hun tijd
	    gesynchroniseerd?  Als dat niet zo is, dan slaagt de
	    autenticatie wellicht niet.
	    <xref linkend="network-ntp"> beschrijft hoe klokken
	    met <acronym>NTP</acronym> gesynchroniseerd kunnen
	    worden.</para>
	</listitem>

	<listitem>
	  <para><acronym>MIT</acronym> en Heimdal werken prima samen.
	    Dit geldt niet voor <command>kadmin</command> omdat
	    daarvoor geen protocolstandaard is.</para>
	</listitem>

	<listitem>
	  <para>Als een hostnaam wordt gewijzigd, dan moet ook de
	    <username>host/</username> principal aangepast en de
	    keytab.  Dit geldt ook voor bijzondere instellingen
	    in de keytab zoals de <username>www/</username> principal
	    voor <filename
	      role="package">www/mod_auth_kerb</filename> van
	    Apache.</para>
	</listitem>

	<listitem>
	  <para>Alle hosts in een wereld moeten oplosbaar
	    (resolvable) zijn (zowel vooruit als achteruit) in de
	    <acronym>DNS</acronym> (of tenminste in
	    <filename>/etc/hosts</filename>).  CNAMEs werken wel,
	    maar de A en PTR records moeten juist en actief zijn.  De
	    foutmelding is niet erg duidelijk: <errorname>Kerberos5
	      refuses authentication because Read req failed: Key table
	      entry not found</errorname>.</para>
	</listitem>

	<listitem>
	  <para>Sommige besturingssystemen van cli&euml;nten voor een
	    <acronym>KDC</acronym> zetten wellicht geen setuid
	    <username>root</username> voor <command>ksu</command>.
	    Dit betekent dat <command>ksu</command> niet werkt.  Dat
	    is vanuit beveiligingsoogpunt een prima idee, maar wel
	    lastig.  Dit is dus geen <acronym>KDC</acronym>-fout.</para>
	</listitem>

	<listitem>
	  <para>Als met <acronym>MIT</acronym>
	    <application>Kerberos</application> een principal een
	    ticket moet krijgen dat langer geldig is dan de standaard
	    van tien uur, dan moet
	    <command>modify_principal</command> in
	    <command>kadmin</command> gebruikt worden om de maximale
	    geldigheidsduur (maxlife) van zowel de principal waar het
	    om gaat als de <username>krbtgt</username> principal aan
	    te passen.  Dan kan de principal <command>kinit</command>
	    <literal>-l</literal> gebruiken om een ticket met een
	    langere levensduur aan te vragen.</para>
	</listitem>

	<listitem>
	  <note>
	    <para>Als een pakketsnuffelaar op de
	      <acronym>KDC</acronym> draait bij om te helpen bij het
	      oplossen van problemen en dan <command>kinit</command>
	      vanaf een werkstation wordt gestart, dan wordt zichtbaar
	      dat de <acronym>TGT</acronym> meteen wordt verstuurd als
	      <command>kinit</command> start, zelfs nog voor het
	      wachtwoord!  De reden hiervoor is dat de
	      <application>Kerberos</application> server vrijelijk een
	      <acronym>TGT</acronym> (Ticket Granting
	      Ticket) verstuurt op iedere niet geautoriseerd verzoek.
	      Maar iedere <acronym>TGT</acronym> is versleuteld met een
	      sleutel die is afgeleid van het wachtwoord van de
	      gebruiker.  Als een gebruiker zijn wachtwoord ingeeft,
	      wordt dat dus niet naar de <acronym>KDC</acronym>
	      gezonden, maar ontcijfert het de <acronym>TGT</acronym>
	      die <command>kinit</command> al heeft ontvangen.  Als de
	      ontcijfering resulteert in een geldige ticket met een
	      geldige tijdstempel, dan heeft de gebruiker geldige
	      <application>Kerberos</application> rechten.  Deze
	      rechten bevatten ook een sessiesleutel voor het opzetten
	      van beveiligde communicatie met de
	      <application>Kerberos</application> server in de toekomst
	      en de eigenlijke ticket-granting ticket, die is
	      versleuteld met de sleutel van de
	      <application>Kerberos</application> server zelf.  Deze
	      tweede laag van versleuteling is niet bekend voor de
	      gebruiker, maar het stelt de
	      <application>Kerberos</application> server in staat om de
	      juistheid van iedere <acronym>TGT</acronym> te
	      bevestigen.</para>
	  </note>
	</listitem>

	<listitem>
	  <para>Als tickets worden gebruik die lang geldig zijn (bv.
	    een week) en <application>OpenSSH</application> wordt
	    gebruikt om een verbinding te maken met de machine waarop
	    het ticket staat, zorg er dan voor dat de
	    <application>Kerberos</application> optie
	    <option>TicketCleanup</option> op <literal>no</literal>
	    staat in <filename>sshd_config</filename> want anders
	    worden tickets verwijderd bij afmelden.</para>
	</listitem>

	<listitem>
	  <para>Hostprincipals kunnen ook een langere levensduur
	    hebben.  Als een gebruikers principal een levensduur van
	    een week heeft, maar de host waar de verbinding mee
	    gemaakt wordt heeft een levensduur van negen uur,
	    dan heb staat er een verlopen host principal in de cache
	    en dan werkt een en ander niet zoals verwacht.</para>
	</listitem>

	<listitem>
	  <para>Een <filename>krb5.dict</filename> bestand om het
	    gebruik van bepaalde slechte wachtwoorden te voorkomen
	    (dit wordt kort behandeld in de handleiding voor
	    <command>kadmind</command>) heeft alleen betrekking op
	    principals waar een wachtwoordbeleid voor geldt.  De
	    opmaak van <filename>krb5.dict</filename> is eenvoudig:
	    een rij tekens per regel.  Een symbolische link maken naar
	    <filename>/usr/share/dict/words</filename> is misschien
	    handig.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Verschillen met de <acronym>MIT</acronym> port</title>

      <para>Het belangrijkste verschil tussen de
	<acronym>MIT</acronym> en Heimdal installatie heeft
	betrekking op <command>kadmin</command>, dat een andere (maar
	gelijkwaardige) set commando's kent en een andere protocol
	gebruikt.  Dit betekent nogal wat als een
	<acronym>KDC</acronym> <acronym>MIT</acronym> is, omdat
	dan de <command>kadmin</command> van Heimdal niet gebruikt
	kan worden om de <acronym>KDC</acronym> vanaf afstand te
	beheren (dat geldt trouwens ook vice versa).</para>

      <para>De cli&euml;ntapplicaties kunnen ook commandoregelopties
	gebruiken die een beetje verschillen, maar waarmee wel
	hetzelfde wordt bereikt.  We raden aan de instructies op de
	<acronym>MIT</acronym> <application>Kerberos</application>
	website (<ulink
	  url="http://web.mit.edu/Kerberos/www/"></ulink>) te volgen.
	Wees voorzichtig met paden: de <acronym>MIT</acronym>-port
	installeert standaard in
	<filename class="directory">/usr/local/</filename> en dus kunnen de
	<quote>normale</quote> systeemapplicaties gestart worden in
	plaats van die van <acronym>MIT</acronym> als de
	<envar>PATH</envar> omgevingsvariabele de systeemmappen als
	eerste weergeeft.</para>

      <note>
	<para>Als de <acronym>MIT</acronym>
	  <filename role="package">security/krb5</filename> port die
	  bij &os; zit wordt gebruikt, dan zorgt het lezen van
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>
	  dat bij de port wordt ge&iuml;nstalleerd voor een beter
	  begrip over waarom het aanmelden via
	  <command>telnetd</command> en <command>klogind</command>
	  soms wat vreemd verloopt.  Als belangrijkste wijzen we erop
	  dat het bij het corrigeren van
	  <quote>onjuiste rechten op het cachebestand</quote>
	  noodzakelijk is dat het binaire bestand
	  <command>login.krb5</command> wordt gebruikt voor
	  autenticatie zodat het op de juiste wijze eigenaarschap kan
	  wijzigen voor de doorgegeven rechten.</para>
      </note>

      <para>Het bestand <filename>rc.conf</filename> moet ook gewijzigd
	worden zodat het de volgende configuratie bevat:</para>

      <programlisting>kerberos5_server="/usr/local/sbin/krb5kdc"
kadmind5_server="/usr/local/sbin/kadmind"
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Dit is gedaan omdat de applicaties voor
	<acronym>MIT</acronym>-Kerberos binairen in de hi&euml;rarchie
	<filename class="directory">/usr/local</filename> installeren.</para>
    </sect2>

    <sect2>
      <title>Beperkingen in
	<application>Kerberos</application></title>

      <indexterm>
	<primary>Kerberos5</primary>

	<secondary>beperkingen en tekortkomingen</secondary>
      </indexterm>

      <sect3>
	<title><application>Kerberos</application> is een alles of
	  niets aanpak</title>

	<para>Iedere ingeschakelde dienst op het netwerk moet
	  aangepast worden om met <application>Kerberos</application>
	  te werken (of op een andere manier beschermd zijn tegen
	  netwerkaanvallen), want anders kunnen gebruikersrechten
	  worden gestolen en herbruikt.  Een voorbeeld hier van is
	  het inschakelen van <application>Kerberos</application>
	  voor alle shells op afstand (via <command>rsh</command> en
	  <command>telnet</command> bijvoorbeeld), maar de
	  <acronym>POP3</acronym> mailserver die wachtwoorden als
	  platte tekst verzend ongemoeid laten.</para>
      </sect3>

      <sect3>
	<title><application>Kerberos</application> is bedoeld voor
	  werkstations met een gebruiker</title>

	<para>In een meergebruikersomgeving is
	  <application>Kerberos</application> minder veilig.  Dit
	  komt doordat de tickets worden opgeslagen in de map
	  <filename class="directory">/tmp</filename>, waar gelezen kan worden
	  door alle gebruikers.  Als een gebruiker een computer deelt met
	  andere gebruikers op hetzelfde moment (dus multi-user), dan
	  is het mogelijk dat een ticket van een gebruiker wordt
	  gestolen (gekopieerd) door een andere gebruiker.</para>

	<para>Dit kan voorkomen worden met de commandoregeloptie
	  <quote><literal>-c</literal> bestandsnaam</quote> of (bij
	  voorkeur) de omgevingsvariabele <envar>KRB5CCNAME</envar>,
	  maar dat wordt zelden gedaan.  In principe kan het opslaan
	  van een ticket in de thuismap van een gebruiker in
	  combinatie met eenvoudige bestandsrechten dit probleem
	  verhelpen.</para>
      </sect3>

      <sect3>
	<title>De KDC is een single point of failure</title>

	<para>Zoals het is ontworpen, moet de <acronym>KDC</acronym>
	  zo goed mogelijk beveiligd zijn, omdat de
	  hoofdwachtwoorddatabase erop staat.  De <acronym>KDC</acronym>
	  hoort geen enkele andere dienst aan te bieden en moet ook
	  fysiek afgeschermd worden.  Het gevaar is groot, omdat
	  <application>Kerberos</application> alle wachtwoorden
	  versleutelt met dezelfde sleutel (de <quote>master</quote>
	  sleutel) die als een bestand op de <acronym>KDC</acronym>
	  staat.</para>

	<para>Toch is een gecompromitteerde mastersleutel niet zo'n
	  groot probleem als wellicht wordt verondersteld.  De
	  mastersleutel wordt alleen gebruikt om de
	  <application>Kerberos</application> database te
	  versleutelen en als zaad voor de generator van willekeurige
	  nummers.  Zo lang als de toegang tot de
	  <acronym>KDC</acronym> is beveiligd, kan een aanvaller niet
	  echt iets doen met de mastersleutel.</para>

	<para>Als de <acronym>KDC</acronym> niet beschikbaar is
	  (misschien door een ontzeggen van dienst aanval of
	  netwerkproblemen) kunnen de netwerkdiensten niet gebruikt
	  worden omdat er geen autenticatie uitgevoerd kan worden;
	  een recept voor een ontzeggen van dienst aanval.  Dit
	  risico kan omzeild worden door meerdere
	  <acronym>KDC</acronym>'s (&eacute;&eacute;n master en
	  &eacute;&eacute;n of meer slaven) en een zorgvuldige
	  implementatie van secundaire of fall-back autenticatie.
	  <acronym>PAM</acronym> is hier uitermate geschikt
	  voor.</para>
      </sect3>

      <sect3>
	<title>Tekortkomingen van
	  <application>Kerberos</application></title>

	<para><application>Kerberos</application> stelt gebruikers,
	  hosts en diensten in staat om elkaar te autenticeren.
	  Maar het heeft geen mechanisme om de <acronym>KDC</acronym>
	  te autenticeren aan de gebruikers, hosts of diensten.  Dit
	  betekent dat bijvoorbeeld een vervalste
	  <command>kinit</command> alle gebruikersnamen en
	  wachtwoorden zou kunnen afluisteren.  Iets als
	  <filename role="package">security/tripwire</filename> of
	  andere controle-instrumenten voor de integriteit van
	  bestandssystemen kunnen hier verlichting brengen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Bronnen en verdere informatie</title>

      <indexterm>
	<primary>Kerberos5</primary>

	<secondary>externe bronnen</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para><ulink
	      url="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	      De <application>Kerberos</application> FAQ</ulink> (Engels)</para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="http://web.mit.edu/Kerberos/www/dialogue.html">Een
	      Autenticatiesysteem Ontwerpen: een Dialoog in Vier Scenes</ulink>
	    (Engels)</para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="http://www.ietf.org/rfc/rfc1510.txt?number=1510">
	      RFC 1510, De <application>Kerberos</application> Netwerk
	      Authenticatie Dienst (V5)</ulink> (Engels)</para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	      <application>Kerberos</application> homepage</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.pdc.kth.se/heimdal/">Heimdal
	      <application>Kerberos</application> homepage</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>OpenSSL</title>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>OpenSSL</secondary>
    </indexterm>

    <indexterm><primary>OpenSSL</primary></indexterm>

    <para>Een toepassing die bij &os; zit die veel gebruikers over het
      hoofd zien is <application>OpenSSL</application>.
      <application>OpenSSL</application> biedt een versleutelde
      transportlaag bovenop de normale communicatielaag.  Daardoor
      biedt het de mogelijkheid met veel netwerktoepassingen en
      diensten verweven te raken.</para>

    <para>Een aantal toepassingen van
      <application>OpenSSL</application> zijn versleutelde
      autenticatie van mailcli&euml;nten, webgebaseerde transacties als
      creditcardbetalingen en nog veel meer.   Veel ports zoals
      <filename role="package">www/apache22</filename> en
      <filename role="package">mail/claws-mail</filename>
      bieden tijdens het compileren ondersteuning om
      <application>OpenSSL</application> in te bouwen.</para>

    <note>
      <para>In de meeste gevallen zal de Portscollectie proberen de
	port <filename role="package">security/openssl</filename> te
	bouwen, tenzij de make variabele
	<makevar>WITH_OPENSSL_BASE</makevar> expliciet naar
	<quote>yes</quote> is gezet.</para>
    </note>

    <para>De versie van <application>OpenSSL</application> die bij &os;
      zit ondersteunt Secure Sockets Layer v2/v3 (SSLv2/SSLv3),
      Transport Layer Security v1 (TLSv1) netwerkbeveiligingsprotocollen
      en kan gebruikt worden als generieke versleutelingsbibliotheek.</para>

    <note>
      <para>Hoewel <application>OpenSSL</application> ondersteuning
	biedt voor het <acronym>IDEA</acronym> algoritme, is dat
	standaard uitgeschakeld in verband met patenten in de Verenigde Staten.
	Om het te gebruiken dient de licentie gelezen te worden en, als
	de restricties aanvaardbaar zijn, dient de make-variabele
	<makevar>MAKE_IDEA</makevar> ingesteld te worden in
	<filename>make.conf</filename>.</para>
    </note>

    <para>Een van de meest gebruikte toepassingen van
      <application>OpenSSL</application> is het leveren van
      certificaten voor gebruik met softwaretoepassingen.  Deze
      certificaten verzekeren dat de eigenschappen van een bedrijf
      of individu geldig zijn en niet vervalst.  Als het certificaat
      in kwestie niet geldig verklaard is door een van de
      <quote>Certificate Authorities</quote> of
      <acronym>CA</acronym>'s, dan komt er een waarschuwing.  Een
      Certificate Authority is een bedrijf, zoals <ulink
	url="http://www.verisign.com">VeriSign</ulink>, dat
      certificaten ondertekent zodat de eigenschappen van een bedrijf
      of individu geldig verklaard kunnen worden.  Dit proces kost geld
      en het is zeker geen voorwaarde voor het gebruik van
      certificaten.  Het stelt wel de meer parano&iuml;de gebruikers
      gerust.</para>

    <sect2>
      <title>Certificaten maken</title>

      <indexterm>
	<primary>OpenSSL</primary>

	<secondary>certificaten maken</secondary>
      </indexterm>

      <para>Voor het maken van certificaten is het volgende commando
	beschikbaar:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................
.......................................
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput><replaceable>SOME PASSWORD</replaceable></userinput>
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para>Let op dat het antwoord direct na <quote>Common
	  Name</quote> een domeinnaam weergeeft.  De prompt wil
	dat er een servernaam wordt ingegeven voor het
	verificatieproces.  Het plaatsen van iets anders dan een
	domeinnaam zorgt ervoor dat het certificaat waardeloos wordt.
	Er zijn ook andere opties als verloopdatum, andere
	versleutelingsalgoritmes, etc, beschikbaar.  Een volledige
	lijst is na te lezen in de handleiding van
	&man.openssl.1;.</para>

      <para>Er horen nu twee bestanden te staan in de map waarin het
	voorgaande commando is uitgevoerd.  Het certificaatverzoek,
	<filename>req.pem</filename>, kan naar een certificaat
	autoriteit gestuurd worden die de bijgevoegde gegevens kan
	valideren, het verzoek kan tekenen en het certificaat kan
	retourneren.  Het tweede bestand heet
	<filename>cert.pem</filename> en is de geheime sleutel voor het
	certificaat.  Deze dient zorgvuldig beschermd te worden.  Als
	de geheime sleutel in de handen van anderen valt kan die
	gebruikt worden om de identiteit van de eigenaar (of server)
	aan te nemen.</para>

      <para>In gevallen waar ondertekening door een
	<acronym>CA</acronym> niet vereist is, kan een zelfondertekend
	certificaat gemaakt worden.  Maak als eerste de
	<acronym>RSA</acronym> sleutel:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out <filename>myRSA.key</filename> 1024</userinput></screen>

      <para>Hierna kan de <acronym>CA</acronym> sleutel gemaakt
	worden:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out <filename>myca.key</filename> <filename>myRSA.key</filename></userinput></screen>

      <para>Deze sleutel kan gebruikt worden om een certificaat te
	maken:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key <filename>myca.key</filename> -out <filename>new.crt</filename></userinput></screen>

      <para>Er zouden nu twee bestanden bijgekomen moeten zijn in de
	map: een certificaatautoriteit ondertekeningsbestand
	<filename>myca.key</filename> en <filename>new.crt</filename>,
	het certificaat zelf.  Deze moeten in een map geplaatst worden,
	bij voorkeur onder <filename class="directory">/etc</filename>
	waar alleen <username>root</username> kan lezen.  De rechten
	0700 zijn hier prima en die kunnen ingesteld worden met
	<command>chmod</command>.</para>
    </sect2>

    <sect2>
      <title>Certificaten gebruiken: een voorbeeld</title>

      <para>En wat kunnen deze bestanden?  Een prima toepassing zou
	het versleutelen van verbindingen naar de
	<application>Sendmail</application> <acronym>MTA</acronym>
	kunnen zijn.  Daardoor zouden gebruikers niet langer platte
	tekst hoeven te autenticeren om mail te sturen via de lokale
	<acronym>MTA</acronym>.</para>

      <note>
	<para>Dit is niet de best denkbare toepassing omdat sommige
	  <acronym>MUA</acronym>'s de gebruiker een foutmelding geven
	  als ze het certificaat niet lokaal ge&iuml;nstalleerd hebben.
	  De documentatie bij de software geeft meer informatie over
	  het installeren van certificaten.</para>
      </note>

      <para>De volgende regels moeten opgenomen worden in het lokale
	<filename>.mc</filename> bestand:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para><filename class="directory">/etc/certs/</filename> is de
	map die gebruikt wordt voor het lokaal opslaan van certificaten
	en sleutels.  De laatste voorwaarde het is opnieuw aanmaken van
	het lokale <filename>.cf</filename> bestand.  Dit gaat door
	eenvoudigweg <command>make
	<maketarget>install</maketarget></command> te typen in de map
	<filename class="directory">/etc/mail</filename>.  Laat dat
	volgen door <command>make
	<maketarget>install</maketarget></command> waardoor de daemon
	<application>Sendmail</application> herstart zou moeten
	worden.</para>

      <para>Als alles goed is gegaan, dan staan er geen foutmeldingen
	<filename>/var/log/maillog</filename> en is
	<application>Sendmail</application> zichtbaar in de
	proceslijst.</para>

      <para>Maak als eenvoudige test een verbinding met de mailserver
	met &man.telnet.1;:</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to <hostid role="fqdn">example.com</hostid>.
Escape character is '^]'.
220 <hostid role="fqdn">example.com</hostid> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <hostid role="fqdn">example.com</hostid> closing connection
Connection closed by foreign host.</screen>

      <para>Als de regel <quote>STARTTLS</quote> verschijnt in de
	uitvoer dan werkt alles correct.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
	  </affiliation>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>IPsec</primary></indexterm>

    <title>VPN via IPsec</title>

    <para>Een VPN opzetten met &os; gateways tussen twee netwerken die
      gescheiden zijn door Internet.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Hiten M.</firstname>
	    <surname>Pandya</surname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Geschreven door </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>IPsec begrijpen</title>

      <para>Deze paragraaf is een gids in het proces van het opzetten
	van IPsec.  Voordat IPsec opgezet kan worden dient de lezer
	bekend te zijn met de concepten die nodig zijn om een aangepaste
	kernel te bouwen (zie <xref linkend="kernelconfig">).</para>

      <para><emphasis>IPsec</emphasis> is een protocol dat bovenop de
	Internet Protocol (IP) laag ligt.  Hiermee kunnen twee of meer
	host op een veilige manier communiceren (vandaar de naam).  De
	&os; IPsec <quote>netwerk wachtrij (stack)</quote> is gebaseerd
	op de
	<ulink url="http://www.kame.net/">KAME</ulink>-implementatie,
	die zowel de protocolfamilies IPv4 als de IPv6 ondersteunt.</para>

      <indexterm>
	<primary>IPsec</primary>

	<secondary>ESP</secondary>
      </indexterm>

      <indexterm>
	<primary>IPsec</primary>

	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec bestaat uit twee subprotocollen:</para>

      <itemizedlist>
	<listitem>
	  <para><emphasis>Encapsulated Security Payload
	      (ESP)</emphasis> beschermt de IP-pakketdata tegen
	    inmenging door een derde partij door de inhoud te
	    versleutelen met symmetrische
	    versleutelingsalgoritmes (zoals Blowfish en 3DES).</para>
	</listitem>

	<listitem>
	  <para><emphasis>Authentication Header (AH)</emphasis>
	    beschermt de IP-pakketkop tegen inmenging door een derde
	    partij en spoofing door een cryptografische checksum te
	    berekenen en de IP-pakketkopvelden te hashen met een
	    veilige hashfunctie.  Hierna wordt een extra kop ingevoegd
	    die de hash bevat zodat de informatie in het pakket
	    geautenticeerd kan worden.</para>
	</listitem>
      </itemizedlist>

      <para><acronym>ESP</acronym> en <acronym>AH</acronym> kunnen
	samen of apart gebruikt worden, afhankelijk van de
	omgeving.</para>

      <indexterm><primary>VPN</primary></indexterm>

      <indexterm>
	<primary>virtual private network</primary>

	<see>VPN</see>
      </indexterm>

      <indexterm>
	<primary>virtueel privaat netwerk</primary>

	<see>VPN</see>
      </indexterm>

      <para>IPsec kan gebruikt worden om het verkeer tussen twee hosts
	direct te versleutelen (dat heet <emphasis>Transport
	Mode</emphasis>) of door <quote>virtuele tunnels</quote> te
	bouwen tussen twee subnetten die gebruikt kunnen worden voor
	veilige communicatie tussen twee bedrijfsnetwerken (dat heet
	<emphasis>Tunnel Mode</emphasis>).  De laatste versie staat
	beter bekend als <emphasis>Virtual Private Network
	(VPN)</emphasis>.  In &man.ipsec.4; staat gedetailleerde
	informatie over het IPsec subsysteem in &os;.</para>

      <para>Voor ondersteuning voor IPsec in de kernel zijn de
	volgende opties nodig in het
	kernelinstellingenbestand:</para>

      <indexterm>
	<primary>kernelopties</primary>

	<secondary>IPSEC</secondary>
      </indexterm>

      <screen>options   IPSEC        #IP-beveiliging
device    crypto</screen>

      <indexterm>
	<primary>kernelopties</primary>

	<secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>Als er ook fouten in IPsec (debugging) verwijderd moeten
	kunnen worden, dan is de volgende optie ook nodig:</para>

      <screen>options   IPSEC_DEBUG  #debug voor IP-beveiliging</screen>
    </sect2>

    <sect2>
      <title>Het probleem</title>

      <para>Er bestaat geen standaard voor wat een VPN is.  VPN's
	kunnen opgezet worden met behulp van een aantal verschillende
	technologie&euml;n die allemaal hun eigen voor- en nadelen
	hebben.  Dit onderdeel bevat een scenario en de
	strategie&euml;n die gebruikt kunnen worden voor het
	implementeren van een VPN in iedere situatie.</para>
    </sect2>

    <sect2>
      <title>Het scenario: twee netwerken, de ene thuisgebaseerd en de
	andere bedrijfgebaseerd.  Beide zijn verbonden met het Internet,
	en er wordt van verwacht dat ze zich via dit
	<acronym>VPN</acronym> als &eacute;&eacute;n gedragen.</title>

      <indexterm>
	<primary>VPN</primary>

	<secondary>maken</secondary>
      </indexterm>

      <para>Dit is het uitgangspunt:</para>

      <itemizedlist>
	<listitem>
	  <para>Er zijn tenminste twee locaties</para>
	</listitem>

	<listitem>
	  <para>Beide locaties gebruiken IP</para>
	</listitem>

	<listitem>
	  <para>Beide locaties hebben een Internetverbinding via een
	    gateway waarop &os; draait.</para>
	</listitem>

	<listitem>
	  <para>De gateway op ieder netwerk heeft tenminste
	    &eacute;&eacute;n publiek <acronym>IP</acronym>-adres.</para>
	</listitem>

	<listitem>
	  <para>De interne adressen van de twee netwerken mogen
	    publieke of private <acronym>IP</acronym>-adressen zijn,
	    dat maakt niet uit.  Ze mogen alleen niet botsen;
	    bijvoorbeeld: ze mogen niet beide <hostid
	      role="ipaddr">192.168.1.x</hostid> gebruiken.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <affiliation>
	      <address><email>trhodes@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Geschreven door </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>IPsec configureren op &os;</title>

      <para>Om te beginnen moet de port <filename
	  role="package">security/ipsec-tools</filename>
	ge&iuml;nstalleerd zijn vanuit de Portscollectie.  Dit
	softwarepakket van een derde partij biedt een aantal applicaties
	die helpen de configuratie te ondersteunen.</para>

      <para>De volgende benodigdheid is om twee &man.gif.4;
	pseudo-apparaten aan te maken om de pakketten te tunnelen en
	beide netwerken in staat stellen om op een juiste wijze te
	communiceren.  Draai als <username>root</username> de volgende
	commando's, waarbij de items <replaceable>intern</replaceable>
	en <replaceable>extern</replaceable> met de echte interne en
	externe gateways:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput></screen>

      <screen>&prompt.root; <userinput>ifconfig gif0 <replaceable>intern1 intern2</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>extern1 extern2</replaceable></userinput></screen>

      <para>Het publieke <acronym>IP</acronym> van het
	<acronym>LAN</acronym> van de onderneming is bijvoorbeeld
	<hostid role="ipaddr">172.16.5.4</hostid> en het heeft een
	privaat <acronym>IP</acronym> <hostid
	  role="ipaddr">10.246.38.1</hostid>.  Het publieke
	<acronym>IP</acronym> van het <acronym>LAN</acronym> van huis is
	<hostid role="ipaddr">192.168.1.12</hostid> met een intern
	privaat <acronym>IP</acronym> <hostid
	  role="ipaddr">10.0.0.5</hostid>.</para>

      <para>Dit kan verwarrend lijken, dus bekijk de volgende
	voorbeeld van het commando &man.ifconfig.8;:</para>

      <programlisting>Gateway 1:

gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00

Gateway 2:

gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</programlisting>

      <para>Eenmaal compleet zouden beide private
	<acronym>IP</acronym>'s bereikbaar moeten zijn met het commando
	&man.ping.8; zoals de volgende uitvoer suggereert:</para>

      <programlisting>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</programlisting>

      <para>Zoals verwacht hebben beide kanten de mogelijkheid om
	<acronym>ICMP</acronym>-pakketten te verzenden en te ontvangen
	van de privaat geconfigureerde adressen.  Vervolgens dient aan
	beide gateways verteld te worden hoe pakketten te routeren om op
	de juiste wijze verkeer van een van de netwerken te versturen.
	Het volgende commando doet dit:</para>

      <screen>&prompt.root; <userinput>corp-net# route add <replaceable>10.0.0.0 10.0.0.5 255.255.255.0</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>corp-net# route add net <replaceable>10.0.0.0: gateway 10.0.0.5</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>priv-net# route add <replaceable>10.246.38.0 10.246.38.1 255.255.255.0</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>priv-net# route add host <replaceable>10.246.38.0: gateway 10.246.38.1</replaceable></userinput></screen>

      <para>Op dit moment dienen interne machines bereikbaar te zijn
	vanuit elke gateway alsook als vanuit machines achter de
	gateways.  Dit is eenvoudig te zien aan het volgende
	voorbeeld:</para>

      <programlisting>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</programlisting>

      <para>De tunnels opzetten is het eenvoudige deel.  Het
	configureren van een veilige verbinding is een veel diepgaander
	proces.  De volgende configuratie gebruikt vooraf gedeelde
	(<acronym>PSK</acronym>) <acronym>RSA</acronym>-sleutels.
	Afgezien van de <acronym>IP</acronym>-adressen zijn beide
	bestanden <filename>/usr/local/etc/racoon/racoon.conf</filename>
	identiek en zien ze er ongeveer als volgt uit:</para>

      <programlisting>path    pre_shared_key  "/usr/lcoal/etc/racoon/psk.txt"; # plaats van bestand vooraf gedeelde sleutels
log     debug;  # verbositeitsinstelling van loggen: op 'notify' zetten als testen en debuggen klaar is

padding # opties moeten niet veranderd worden
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer   # timingopties, veranderen indien nodig
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen  # adres [poort] waarop racoon luistert
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)   # adres $netwerk/$netmasker $type adres $netwerk/$netmasker $type ( $type is any of esp)
{
        pfs_group       1;
        lifetime        time    3600 sec;
        encryption_algorithm    blowfish,3des,des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</programlisting>

      <para>Het uitleggen van elke beschikbare optie, samen met diegenen
	in deze voorbeelden valt buiten het bereik van dit document.
	De configuratiehandleiding van <application>racoon</application>
	staat vol relevante informatie.</para>

      <para>De <acronym>SPD</acronym>-beleiden moeten geconfigureerd
	worden zodat &os; en <application>racoon</application> in staat
	zijn om netwerkverkeer tussen hosts te versleutelen en te
	ontsleutelen.</para>

      <para>Deze taak kan met een eenvoudig shellscript zoals het
	volgende dat op de gateway van de onderneming staat worden
	uitgevoerd.  Dit bestand wordt gebruikt tijdens de
	systeeminitialisatie en dient bewaard te worden als
	<filename>/usr/local/etc/racoon/setkey.conf</filename>.</para>

      <programlisting>flush;
spdflush;
# Naar het thuisnetwerk
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in esp/tunnel/192.168.1.12-172.16.5.4/use;</programlisting>

      <para>Eenmaal aanwezig kan <application>racoon</application> op
	beide gateways gestart worden met het volgende commando:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</userinput></screen>

      <para>De uitvoer moet ongeveer gelijk zijn aan de volgende:</para>

      <programlisting>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.2[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</programlisting>

      <para>Om er zeker van te zijn dat de tunnel correct werkt, dient
	naar een ander console geschakeld te worden en &man.tcpdump.1;
	gebruikt te worden om hiermee het netwerkverkeer te bekijken.
	Vervang <literal>em0</literal> door de netwerkinterfacekaart
	indien nodig.</para>

      <screen>&prompt.root; <userinput>tcpdump -i em0 host <replaceable>172.16.5.4 and dst 192.168.1.12</replaceable></userinput></screen>

      <para>Gegevens lijkend op de volgende zouden op het console moeten
	verschijnen.  Indien niet, dan is er iets aan de hand, en is het
	nodig om de teruggegeven gegevens te debuggen.</para>

      <programlisting>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</programlisting>

      <para>Op dit punt zouden beide netwerken beschikbaar moeten zijn en
	deel lijken van hetzelfde netwerk.  Waarschijnlijk zijn beide
	netwerken beschermt door een firewall, zoals het hoort.  Om
	verkeer tussen hen toe te staan, moeten er regels worden
	toegevoegd om pakketten heen en terug door te laten.  Voeg voor
	de firewall &man.ipfw.8; de volgende regels toe aan het
	instellingenbestand van de firewall:</para>

      <programlisting>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</programlisting>

      <note>
	<para>Afhankelijk van de huidige hostconfiguratie dienen de
	  regelnummers gewijzigd te worden.</para>
      </note>

      <para>Voor gebruikers van &man.pf.4; of &man.ipf.8; zouden de
	volgende regels moeten volstaan:</para>

      <programlisting>pass in quick proto esp form any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp form any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick ptoto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</programlisting>

      <para>Ter afsluiting, voeg de volgende regels toe aan
	<filename>/etc/rc.conf</filename> om de machine toe te staan om
	ondersteuning voor het <acronym>VPN</acronym> te starten tijdens
	de systeeminitialisatie:</para>

      <programlisting>ipsec_enable="YES"
ipsec_program="/usr/local/sbin/setkey"
ipsec_file="/usr/local/etc/racoon/setkey.conf" # staat toe om spd-beleiden tijdens het opstarten op te zetten
racoon_enable="yes"</programlisting>
    </sect2>
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Bijgedragen door </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>

    <indexterm><primary>OpenSSH</primary></indexterm>

    <indexterm>
      <primary>beveiliging</primary>

      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> is een groep
      netwerkverbindingsprogramma's waarmee computers via het netwerk
      veilig benaderd kunnen worden.  Het kan ingezet worden als een
      directe vervanger van <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command> en
      <command>telnet</command>.  Daarnaast kunnen
      <acronym>TCP</acronym>/<acronym>IP</acronym>-verbindingen veilig
      getunneld of geforward worden door SSH.
      <application>OpenSSH</application> versleutelt al het verkeer om
      afluisteren, het stelen van een verbinding en andere
      netwerkaanvallen effectief te voorkomen.</para>

    <para><application>OpenSSH</application> wordt onderhouden door het
      OpenBSD project en is gebaseerd op SSH v1.2.12 met alle recente
      bugfixes en updates.  Het is compatibel met beide protocollen SSH
      1 en 2.</para>

    <sect2>
      <title>Voordelen van gebruik van OpenSSH</title>

      <para>Als gewoonlijk &man.telnet.1; of &man.rlogin.1; wordt
	gebruikt, wordt de data in platte tekst en niet versleuteld
	verzonden.  Netwerksnuffelaars die ergens tussen de cli&euml;nt
	en de server meeluisteren, kunnen een gebruikersnaam en
	wachtwoord stelen en zien welke gegevens er worden overgezonden
	tijdens een sessie.  <application>OpenSSH</application> biedt
	een verscheidenheid aan autenticatie en versleutelingsmethoden
	die het voorgaande voorkomen.</para>
    </sect2>

    <sect2>
      <title><application>sshd</application> inschakelen</title>

      <indexterm>
	<primary>OpenSSH</primary>

	<secondary>inschakelen</secondary>
      </indexterm>

      <para>De <application>sshd</application> is een optie die wordt
	aangeboden tijdens een <literal>Standard</literal>-installatie
	van &os;.  <application>sshd</application> is ingeschakeld als
	de volgende regel voorkomt in <filename>rc.conf</filename>:</para>

      <programlisting>sshd_enable="YES"</programlisting>

      <para>Hierdoor wordt &man.sshd.8; geladen, het daemonprogramma
	voor <application>OpenSSH</application>, als het systeem de
	volgende keer opstart.  Als alternatief is het mogelijk om het
	&man.rc.8;-script <filename>/etc/rc.d/sshd</filename> te
	gebruiken om <application>OpenSSH</application> te starten:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd start</userinput></screen>
    </sect2>

    <sect2>
      <title>SSH-cli&euml;nt</title>

      <indexterm>
	<primary>OpenSSH</primary>

	<secondary>cli&euml;nt</secondary>
      </indexterm>

      <para>&man.ssh.1; werkt net zoals &man.rlogin.1;.</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>Het aanmelden gaat nu net zoals het zou gaan als wanneer
	er een sessie gestart zou worden met <command>rlogin</command>
	of <command>telnet</command>.  SSH maakt gebruik van een
	systeem met vingerafdrukken als sleutels voor het vaststellen
	met welke server verbinding wordt gemaakt op het moment
	dat de cli&euml;nt verbinding zoekt.  De gebruiker krijgt alleen
	de eerste keer dat verbinding wordt gezocht met de server een
	vraag waarop <literal>yes</literal> geantwoord dient te worden.
	Bij volgende pogingen om aan te melden wordt de
	vingerafdruksleutel vergeleken met de sleutel die is
	opgeslagen.  De SSH-cli&euml;nt alarmeert de gebruiker als de
	opgeslagen vingerafdruk sleutel anders is dan de sleutel die
	de server meldt.  De vingerafdrukken worden opgeslagen in
	<filename>~/.ssh/known_hosts</filename> of in
	<filename>~/.ssh/known_hosts2</filename> voor SSH v2
	vingerafdrukken.</para>

      <para>Recente <application>OpenSSH</application> servers staan
	standaard ingesteld om alleen SSH v2 connecties toe te staan.
	De cli&euml;nt gebruikt versie 2 als dat mogelijk is en valt
	anders terug op versie 1.  De cli&euml;nt kan ook gedwongen
	worden om een van de twee protocollen te gebruiken door de optie
	<option>-1</option> of <option>-2</option> voor respectievelijk
	versie 1 en versie 2 aan te geven.  De mogelijkheid versie 1 te
	gebruiken blijft in de cli&euml;nt bestaan om compatibiliteit
	met oudere versies te behouden.</para>
    </sect2>

    <sect2>
      <title>Veilig kopi&euml;ren</title>

      <indexterm>
	<primary>OpenSSH</primary>

	<secondary>veilig kopi&euml;ren</secondary>
      </indexterm>

      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>Het commando &man.scp.1; (secure copy) werkt gelijk aan
	&man.rcp.1;.  Het kopieert een bestand van of naar een andere
	machine, maar doet dat veilig.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>

      <para>Omdat de vingerafdruk al is opgeslagen voor deze host in
	het vorige voorbeeld, is die al geverifieerd als &man.scp.1;
	gebruik wordt.</para>

      <para>De argumenten die aan &man.scp.1; gegeven worden zijn
	vrijwel gelijk aan die voor &man.cp.1; met het bestand of
	de bestanden als het eerste argument en de bestemming als het
	tweede.  Omdat het bestand over het netwerk gaat, door SSH,
	hebben een of meer van de bestandsargumenten de vorm
	<option>user@host:&lt;path_to_remote_file&gt;</option>.</para>
    </sect2>

    <sect2>
      <title>Instellen</title>

      <indexterm>
	<primary>OpenSSH</primary>

	<secondary>instellen</secondary>
      </indexterm>

      <para>Het instellingenbestand dat voor het hele systeem geldt
	voor zowel de <application>OpenSSH</application> daemon als
	cli&euml;nt staat in de map <filename
	  class="directory">/etc/ssh</filename>.</para>

      <para><filename>ssh_config</filename> bevat de instellingen voor
	de cli&euml;nt en <filename>sshd_config</filename> bevat ze voor
	de daemon.</para>

      <para>Daarnaast bieden het <option>sshd_program</option>
	(standaard <filename>/usr/sbin/sshd</filename>) en
	<option>sshd_flags</option> <filename>rc.conf</filename>
	opties nog meer mogelijkheden voor instellingen.</para>
    </sect2>

    <sect2 id="security-ssh-keygen">
      <title><application>ssh-keygen</application></title>

      <para>In plaats van het gebruik van wachtwoorden kan
	&man.ssh-keygen.1; gebruikt worden om DSA en RSA sleutels te
	maken om een gebruiker te autenticeren:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>dsa</replaceable></userinput>
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com</screen>

      <para>&man.ssh-keygen.1; maakt een publiek en privaat sleutelpaar
	aan dat gebruikt kan worden voor autenticatie.  De private
	sleutel staat opgeslagen in
	<filename>~/.ssh/id_dsa</filename> of
	<filename>~/.ssh/id_rsa</filename> en de publieke sleutel
	staat in <filename>~/.ssh/id_dsa.pub</filename> of
	<filename>~/.ssh/id_rsa.pub</filename> voor respectievelijk
	sleuteltypen <acronym>DSA</acronym> en <acronym>RSA</acronym>.
	De publieke sleutel moet voor beide <acronym>RSA</acronym>- of
	<acronym>DSA</acronym>-sleutels in het bestand
	<filename>~/.ssh/authorized_keys</filename> van de andere
	machine staan om dit te laten werken.</para>

      <para>Nu is het mogelijk een verbinding te maken met een andere
	machine die gebaseerd is op SSH sleutels in plaats van op
	wachtwoorden.</para>

      <para>Als er een wachtwoordzin is gebruikt bij &man.ssh-keygen.1;
	dan wordt de gebruiker iedere keer dat de private sleutel wordt
	gebruikt een wachtwoord gevraagd.  &man.ssh-agent.1; kan het
	ongemak van steeds opnieuw een lange wachtwoordzin moeten
	ingeven verlichten en wordt beschreven in het onderdeel <xref
	  linkend="security-ssh-agent">.</para>

      <warning>
	<para>Afhankelijk van de gebruikte versie van
	  <application>OpenSSH</application> kunnen opties en bestanden
	  verschillen.  Het is verstandig de handleiding
	  &man.ssh-keygen.1; te raadplegen.</para>
      </warning>
    </sect2>

    <sect2 id="security-ssh-agent">
      <title><application>ssh-agent</application> en
	<application>ssh-add</application></title>

      <para>De hulpprogramma's &man.ssh-agent.1; en &man.ssh-add.1;
	bieden de mogelijkheid om <application>SSH</application>
	in het geheugen te laden zodat niet iedere keer de
	wachtwoordzin ingegeven hoeft te worden.</para>

      <para>Het hulpprogramma &man.ssh-agent.1; handelt de
	autenticatie af voor de geheime sleutels die erin geladen
	zijn.  &man.ssh-agent.1; wordt gebruikt om andere programma's
	te starten.  Bij eenvoudig gebruik kan er een shell mee
	gestart worden of meer complex een schermbeheerprogramma.</para>

      <para>Voordat &man.ssh-agent.1; in een shell gebruikt kan worden
	dient het eerst gestart te worden met een shell als argument.
	Daarna kan de identiteit toegevoegd worden daar &man.ssh-add.1;
	aan te roepen en de wachtwoordzin voor de geheime sleutel op te
	geven.  Als deze stappen zijn voltooid kan een gebruiker met
	&man.ssh.1; naar iedere host waar de corresponderende publieke
	sleutel is ge&iuml;nstalleerd:</para>

      <screen>&prompt.user; ssh-agent <replaceable>csh</replaceable>
&prompt.user; ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
&prompt.user;</screen>

      <para>Om &man.ssh-agent.1; te gebruiken in X11 dient er een
	verwijzing naar &man.ssh-agent.1; in
	<filename>~/.xinitrc</filename> te staan.  Dan zijn de diensten
	van &man.ssh-agent.1; beschikbaar voor alle programma's die in
	X11 gestart worden.  Een <filename>~/.xinitrc</filename> zou er
	als volgt uit kunnen zien:</para>

      <programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

      <para>Hiermee wordt &man.ssh-agent.1; gestart die op zijn beurt
	<application>XFCE</application> start, iedere keer dat X11
	start.  Als dat is gebeurd en X11 is herstart zodat de
	wijzigingen actief zijn, dan kan eenvoudigweg &man.ssh-add.1;
	gestart worden om alle beschikbare SSH sleutels te
	laden.</para>
    </sect2>

    <sect2 id="security-ssh-tunneling">
      <title>SSH tunnels</title>

      <indexterm>
	<primary>OpenSSH</primary>

	<secondary>tunnels</secondary>
      </indexterm>

      <para><application>OpenSSH</application> kan een tunnel maken
	waarin een ander protocol ingepakt kan worden zodat er een
	versleutelde sessie ontstaat.</para>

      <para>Het volgende commando geeft &man.ssh.1; aan dat er een
	tunnel voor <application>telnet</application> gemaakt moet
	worden:</para>

      <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>Aan het <command>ssh</command> commando worden de volgende
	opties meegegeven:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Dit dwingt <command>ssh</command> om versie 2 van het
	      protocol te gebruiken.  Gebruik van deze optie wordt
	      afgeraden als er verbinding wordt gemaakt met oudere SSH
	      servers.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Dit geeft aan dat er geen commando volgt, maar dat er
	      een tunnel opgezet moet worden.  Als deze optie niet
	      aanwezig was, zou <command>ssh</command> een normale
	      sessie starten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Dit dwingt <command>ssh</command> om in de
	      achtergrond te draaien.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Dit geeft aan dat de lokaal een tunnel wordt gemaakt
	      in de vorm
	      <replaceable>lokale_poort:netwerk_host:netwerk_poort</replaceable>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Wijst naar een gebruiker op de SSH server op het
	      netwerk.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Een SSH tunnel werkt doordat een luistersocket wordt
	gemaakt op <hostid>localhost</hostid> op de aangegeven poort.
	Die stuurt dan iedere ontvangen verbinding op de lokale
	host/poort via de SSH verbinding door naar de aangegeven host
	en poort op het netwerk.</para>

      <para>In het voorbeeld wordt poort
	<replaceable>5023</replaceable> op <hostid>localhost</hostid>
	doorgestuurd naar poort <replaceable>23</replaceable> op
	<hostid>localhost</hostid> van de machine op het netwerk.
	Omdat <replaceable>23</replaceable>
	<application>telnet</application> is, zou dit een veilige
	<application>telnet</application> verbinding opleveren door
	een SSH tunnel.</para>

      <para>Dit kan gebruikt worden om ieder willekeurig onveilig
	TCP protocol in te pakken als <acronym>SMTP</acronym>,
	<acronym>POP</acronym>3, <acronym>FTP</acronym>, etc.</para>

      <example>
	<title>SSH gebruiken om een veilige tunnel te maken voor
	  SMTP</title>

	<screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

	<para>Dit kan samen met een &man.ssh-keygen.1; en extra
	  gebruikersaccounts gebruikt worden om een min of meer
	  naadloze en eenvoudige SSH tunnelomgeving te maken.  In
	  plaats van wachtwoorden kunnen sleutels gebruikt worden en de
	  tunnels kunnen in de omgeving van een aparte gebruiker
	  draaien.</para>
      </example>

      <sect3>
	<title>Praktische voorbeelden van een SSH tunnel</title>

	<sect4>
	  <title>Veilige toegang tot een POP3 server</title>

	  <para>Op het werk staat een SSH server die verbindingen van
	    buitenaf toestaat.  Op hetzelfde netwerk op kantoor staat
	    een mailserver waarop POP3 draait.  Het netwerk of het
	    netwerkpad tussen de locatie op Internet en kantoor is
	    wellicht niet helemaal te vertrouwen.  Om deze reden dient
	    de mailserver op een veilige manier benaderd te worden.  De
	    oplossing is een SSH verbinding opzetten naar de SSH server
	    op kantoor en dan door de tunnel heen een verbinding
	    opzetten met de mailserver.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Als de tunnel eenmaal draait, dan kan de mailcli&euml;nt
	    naar <hostid>localhost</hostid> poort 2110 gewezen worden.
	    Alle verbinding naar die poort worden veilig doorgestuurd
	    door de tunnel naar
	    <hostid>mail.example.com</hostid>.</para>
	</sect4>

	<sect4>
	  <title>Een draconische firewall omzeilen</title>

	  <para>Sommige netwerkbeheerders stellen draconische
	    firewallregels op en filteren niet alleen inkomende
	    verbindingen, maar ook uitgaande.  Meestal mag dan alleen
	    maar verbinding gemaakt worden met andere machines op
	    poorten 22 en 80 voor SSH en websurfen.</para>

	  <para>Soms wil een gebruiker dan toch toegang krijgen tot
	    andere (wellicht niet netwerkgerelateerde) diensten, zoals
	    een Ogg Vorbis server om muziek te streamen.  Als die Ogg
	    Vorbis server streamt op een andere poort dan 22 of 80, dan
	    kan deze niet bereikt worden.</para>

	  <para>De oplossing ligt in het opzetten van een SSH
	    verbinding naar een machine buiten de firewall en die
	    tunnel te gebruiken om bij de Ogg Vorbis server te
	    komen.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>De streamingcli&euml;nt kan nu gewezen worden naar
	    <hostid>localhost</hostid> poort 8888 vanwaar er wordt
	    doorverwezen naar <hostid>music.example.com</hostid> poort
	    8000 en zo wordt de firewall succesvol ontwerken.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>De gebruikersoptie <varname>AllowUsers</varname></title>

      <para>Vaak is het verstandig om beperkingen aan te brengen op het
	gebied van welke gebruikers kunnen aanmelden en van waar.  De
	optie <literal>AllowUsers</literal> biedt deze mogelijkheid.
	Om bijvoorbeeld alleen <username>root</username> toe te staan
	zich aan te melden van <hostid
	  role="ipaddr">192.168.1.32</hostid>, kan iets als de volgende
	regel worden opgenomen in het bestand
	<filename>/etc/ssh/sshd_config</filename>:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para>Om de gebruiker <username>admin</username> het recht te
	geven zich van overal aan te melden hoeft alleen de
	gebruikersnaam vermeld te worden:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Meerdere gebruikers met rechten of beperkingen horen op
	dezelfde regel te staan:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
	<para>Het is van belang dat iedere gebruiker die zich moet
	  kunnen aanmelden wordt genoemd.  De overige gebruikers
	  worden buitengesloten.</para>
      </note>

      <para>Nadat er wijzigingen zijn gemaakt aan
	<filename>/etc/ssh/sshd_config</filename> dienen de bestanden
	in &man.sshd.8; geladen te worden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>Meer informatie</title>

      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>

      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
	&man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5;</para>

      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5;</para>
    </sect2>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Bijgedragen door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>ACL</primary></indexterm>

    <title>Bestandssysteem toegangscontrolelijsten</title>

    <para>In combinatie met verbeteringen als snapshots, biedt
      &os;&nbsp; de veiligheid van
      Toegangscontrolelijsten voor Bestandssystemen (Access Control
      Lists, <acronym>ACL</acronym>s).</para>

    <para>Met toegangscontrolelijsten wordt het standaard &unix;
      rechtenmodel uitgebreid op een zeer verenigbare (&posix;.1e)
      manier.  Deze methodes stellen een beheerder in staat om gebruik
      te maken en voordeel te halen uit een geraffineerder
      beveiligingsmodel.</para>

    <para>Om ondersteuning voor <acronym>ACL</acronym>s voor
      bestandssystemen in te schakelen dient het volgende in de kernel
      gecompileerd te worden:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>Als deze optie niet aanwezig is, dan wordt er een
      waarschuwing weergegeven als er wordt geprobeerd een
      bestandssysteem aan te koppelen dat gebruik maakt van
      <acronym>ACL</acronym>s.  Deze optie is al geactiveerd in de
      <filename>GENERIC</filename> kernel.  <acronym>ACL</acronym>s
      zijn afhankelijk van uitgebreide attributen die zijn ingeschakeld
      op het bestandssysteem.  Uitgebreide attributen worden standaard
      ondersteund in het volgende generatie &unix; bestandssysteem
      <acronym>UFS2</acronym>.</para>

    <note>
      <para>Er is meer administratieve rompslomp nodig om uitgebreide
	attributen in te stellen op <acronym>UFS1</acronym> dan op
	<acronym>UFS2</acronym>.  De prestaties van uitgebreide
	attributen zijn op <acronym>UFS2</acronym> ook veel beter.
	Daarom wordt <acronym>UFS2</acronym> ook meestal aangeraden
	boven <acronym>UFS1</acronym> bij het gebruik van
	toegangscontrolelijsten.</para>
    </note>

    <para><acronym>ACL</acronym>s worden ingeschakeld door de
      beheersvlag <option>acls</option> op het moment van aankoppelen.
      Dit kan ook in <filename>/etc/fstab</filename> staan.  De vlag op
      het moment van aankoppelen kan ook automatisch gezet worden op een
      persistente wijze met &man.tunefs.8; door een superblok in de
      bestandssysteemkop te wijzigen.  In het algemeen wordt de
      voorkeur gegeven aan de vlag in het superblok om een aantal
      redenen:</para>

    <itemizedlist>
      <listitem>
	<para>De <acronym>ACL</acronym>s vlag op het moment van
	  aankoppelen kan niet gewijzigd worden bij opnieuw aankoppelen
	  (&man.mount.8; <option>-u</option>), maar alleen door een
	  volledige &man.umount.8; en een verse &man.mount.8;.  Dit
	  betekent dat <acronym>ACL</acronym>s niet ingeschakeld kunnen
	  worden op root-bestandssysteem na het opstarten.  Het betekent
	  ook dat de aard van een bestandssysteem niet veranderd kan
	  worden als het eenmaal in gebruik is.</para>
      </listitem>

      <listitem>
	<para>Het inschakelen van de superblokvlag zorgt ervoor dat
	  het bestandssysteem altijd wordt aangekoppeld met de
	  <acronym>ACL</acronym>s ingeschakeld, zelfs als het niet in
	  <filename>fstab</filename> staat of als de apparaten van
	  plaats veranderen.  Hiermee wordt voorkomen dat het
	  bestandssysteem wordt gebruikt zonder dat
	  <acronym>ACL</acronym>s ingeschakeld zijn, wat ervoor zou
	  kunnen zorgen dat <acronym>ACL</acronym>s onjuist worden
	  toegepast wat weer kan zorgen voor
	  beveiligingsproblemen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Wellicht wordt het mogelijk om de
	<acronym>ACL</acronym>s via de vlag in te schakelen zonder een
	compleet verse &man.mount.8;, maar de ontwikkelaars vinden het
	wenselijk om het per ongeluk zonder <acronym>ACL</acronym>s
	aankoppelen te ontmoedigen, omdat er bijzonder vervelende
	gevolgen kunnen zijn als <acronym>ACL</acronym>s worden
	ingeschakeld,
	daarna worden uitgezet en weer worden ingeschakeld zonder dat
	de uitgebreide attributen worden geschoond.  In het algemeen
	geldt dat als <acronym>ACL</acronym>s eenmaal zijn ingeschakeld
	voor een bestandssysteem, ze niet meer uitgeschakeld moeten
	worden, omdat de resulterende bestandsbescherming wellicht niet
	compatibel is met dat wat gebruikers van het systeem nodig
	hebben en het opnieuw aanzetten van <acronym>ACL</acronym>s kan
	leiden tot het opnieuw koppelen van voorheen bestaande
	<acronym>ACL</acronym>s aan bestanden waarvoor de
	toegangsrechten sindsdien zijn aangepast, wat kan leiden tot
	onverwachte situaties.</para>
    </note>

    <para>Bestandssystemen waarvoor <acronym>ACL</acronym>s zijn
      ingeschakeld worden weergegeven met een <literal>+</literal>
      (plus) teken als de toegangsrechten worden bekeken:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Hierboven is te zien dat mappen
      <filename class="directory">directory1</filename>,
      <filename class="directory">directory2</filename> en
      <filename class="directory">directory3</filename> allemaal gebruik maken
      van <acronym>ACL</acronym>s.  De map
      <filename class="directory">public_html</filename> doet dat niet.</para>

    <sect2>
      <title>Gebruik maken van <acronym>ACL</acronym>s</title>

      <para>De <acronym>ACL</acronym>s van het bestandssysteem kunnen
	bekeken worden met het hulpprogramma &man.getfacl.1;.  Om de
	<acronym>ACL</acronym> op het bestand <filename>test</filename>
	te bekijken zou het volgende commando nodig zijn:</para>

      <screen>&prompt.user; <userinput>getfacl <filename>test</filename></userinput>
#file:test
#owner:1001
#group:1001
user::rw-
group::r--
other::r--</screen>

      <para>Om de <acronym>ACL</acronym> op dit bestand te wijzigen
	wordt het hulpprogramma &man.setfacl.1; als volgt
	gebruikt:</para>

      <screen>&prompt.user; <userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para>De vlag <option>-k</option> verwijdert alle bestaande
	<acronym>ACL</acronym>s van een bestand of bestandssysteem.  De
	methode die de voorkeur geniet is <option>-b</option> gebruiken
	omdat die optie de basisvelden die nodig zijn voor het laten
	werken van de <acronym>ACL</acronym>s laat staan.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,group:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>Bij het commando hierboven, werd de optie
	<option>-m</option> gebruikt om de standaard
	<acronym>ACL</acronym> aan te passen.  Omdat er geen
	voorgedefinieerde instellingen waren, die waren verwijderd door
	het commando daarvoor, werden nu de standaardinstellingen
	hersteld en de rechten die werden aangegeven toegevoegd.  Let
	op dat bij het toevoegen van een gebruiker of een groep die
	niet bekend is op het systeem een foutmelding
	<errorname>Invalid argument</errorname> wordt geschreven naar
	<devicename>stdout</devicename>.</para>
    </sect2>
  </sect1>

  <sect1 id="security-portaudit">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>Portaudit</primary></indexterm>

    <title>Monitoren van beveiligingsproblemen met andere
      software</title>

    <para>In de afgelopen jaren zijn er in de beveiligingswereld veel
      vorderingen gemaakt op het gebied van inzicht in kwetsbaarheden.
      Als er software naast het besturingssysteem wordt
      ge&iuml;nstalleerd en ingesteld neemt op vrijwel ieder
      besturingssysteem het risico op inbraak toe.</para>

    <para>Inzicht in kwetsbaarheid is een vitale factor in beveiliging
      en hoewel &os; waarschuwingen publiceert voor het basissysteem,
      gaat het publiceren van waarschuwingen voor alle overige software
      de scope van het &os; Project te buiten.  Er is een manier om
      inzicht te krijgen in de kwetsbaarheden voor additionele software
      en als beheerder gewaarschuwd te worden.  Voor dit doel bestaat
      het &os; hulpprogramma
      <application>Portaudit</application>.</para>

    <para>De port <filename
	role="package">ports-mgmt/portaudit</filename> zoekt naar
      bekende beveiligingsproblemen in een database die wordt bijgewerkt
      en onderhouden door het &os; Security Team en
      portontwikkelaars.</para>

    <para>Voordat <application>Portaudit</application> gebruikt kan
      worden dient het ge&iuml;nstalleerd te worden uit de
      Portscollectie:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>Tijdens het installatieproces worden de instellingenbestanden
      voor &man.periodic.8; bijgewerkt, waardoor
      <application>Portaudit</application> uitvoer in de dagelijkse
      security runs meekomt.  Het is van belang dat de emails die
      aan de emailaccount van <username>root</username> worden
      gezonden en uit de dagelijkse beveiligingsronde komen ook echt
      worden gelezen.  Er zijn geen verdere instellingen nodig.</para>

    <para>Na de installatie kan de beheerder de database bijwerken en
      bekende kwetsbaarheden in ge&iuml;nstalleerde pakketten bekijken
      met het volgende commando:</para>

    <screen>&prompt.root; <userinput>portaudit -Fda</userinput></screen>

    <note>
      <para>De database wordt automatisch bijgewerkt tijdens de
	&man.periodic.8; run; dus het voorgaande commando is volledig
	optioneel.  Het is alleen nodig om de volgende voorbeelden na
	te kunnen doen.</para>
    </note>

    <para>De software de uit de Portscollectie is ge&iuml;nstalleerd
      kan op elk moment door een beheerder ge-audit worden met:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para><application>Portaudit</application> zal iets als het volgende
      produceren voor kwetsbare pakketten:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Door met een webbrowser naar de aangegeven
      <acronym>URL</acronym> te gaan kan een beheerder meer informatie
      over de bewust kwetsbaarheid krijgen, waaronder de versies die
      het betreft, volgens de &os; Port versie en andere websites
      waarop beveiligingswaarschuwingen te lezen zijn.</para>

    <para>In het kort is <application>Portaudit</application> een
      krachtig hulpprogramma dat bijzonder handig is als het wordt
      gekoppeld aan het gebruik van de port
      <application>Portupgrade</application>.</para>
  </sect1>

  <sect1 id="security-advisories">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Bijgedragen door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>&os; Beveiligingswaarschuwingen</primary></indexterm>

    <title>&os; beveiligingswaarschuwingen</title>

    <para>Net als veel andere kwalitatief goede
      productiebesturingssystemen publiceert &os;
      <quote>Beveiligingswaarschuwingen</quote>.  Deze waarschuwingen
      worden meestal pas naar de beveiligingslijst gemaild en
      gedocumenteerd in de Errata als de van toepassing zijnde
      uitgaven gepatcht zijn.  In deze paragraaf wordt toegelicht wat
      een waarschuwing is, hoe die te begrijpen en welke maatregelen
      er genomen moeten worden om een systeem bij te werken.</para>

    <sect2>
      <title>Hoe ziet een waarschuwing eruit?</title>

      <para>De &os; beveiligingswaarschuwingen zien er ongeveer uit als
	die hieronder die van de &a.security-notifications.name;
	mailinglijst komt.</para>

      <programlisting>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem <co id="co-topic">

Category:       core <co id="co-category">
Module:         sys <co id="co-module">
Announced:      2003-09-23 <co id="co-announce">
Credits:        Person <co id="co-credit">
Affects:        All releases of &os; <co id="co-affects">
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39) <co id="co-corrected">
<acronym>CVE</acronym> Name:   CVE-XXXX-XXXX <co id="co-cve">

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background <co id="co-backround">


II.  Problem Description <co id="co-descript">


III. Impact <co id="co-impact">


IV.  Workaround <co id="co-workaround">


V.   Solution <co id="co-solution">


VI.  Correction details <co id="co-details">


VII. References <co id="co-ref"></programlisting>

      <calloutlist>
	<callout arearefs="co-topic">
	  <para>Het veld <literal>Topic</literal> geeft aan wat precies
	    het probleem is.  Het is eigenlijk een inleiding op de
	    beveiligingswaarschuwing en geeft aan welke programma
	    kwetsbaar is.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>Het veld <literal>Category</literal> geeft aan welk
	    onderdeel van het systeem kwetsbaar is.  Dat kan een van de
	    onderdelen <literal>core</literal>,
	    <literal>contrib</literal> of <literal>ports</literal>
	    zijn.  De categorie <literal>core</literal> betekent dat
	    de een kerncomponent van het &os; besturingssysteem
	    kwetsbaar is.  De categorie <literal>contrib</literal>
	    betekent dat software die toegevoegd is aan het &os;
	    Project kwetsbaar is, zoals
	    <application>sendmail</application>.  Tenslotte geeft de
	    categorie <literal>ports</literal> aan dat een optionele
	    component uit de Portscollectie kwetsbaar is.</para>
	</callout>

	<callout arearefs="co-module">
	  <para>Het veld <literal>Module</literal> geeft aan waar de
	    component zich bevindt, bijvoorbeeld
	    <literal>sys</literal>.  In dit voorbeeld wordt het
	    duidelijk dat de module <literal>sys</literal> kwetsbaar
	    is.  Hier gaat het dus om een kwetsbaar component die
	    gebruikt wordt in de kernel.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para>Het veld <literal>Announced</literal> geeft aan wanneer
	    de beveiligingswaarschuwing gepubliceerd of aangekondigd
	    is.  Dit betekent dat het beveiligingsteam heeft bevestigd
	    dat het probleem bestaat en dat er een patch is gecommit in
	    het depot met de broncode van &os;.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para>In het veld <literal>Credits</literal> wordt iemand of
	    een organisatie bedankt die de kwetsbaarheid heeft ontdekt
	    en gerapporteerd.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para>Het veld <literal>Affects</literal> geeft aan welke
	    uitgaven van &os; door deze kwetsbaarheid worden getroffen.
	    Voor de kernel kan snel gekeken worden naar de uitvoer van
	    <command>ident</command> voor de betreffende bestanden om
	    te bepalen welke revisie ze hebben.  Voor ports is het versienummer
	    te zien in <filename class="directory">/var/db/pkg</filename>.
	    Als het systeem niet gelijk op loopt met het &os;
	    <acronym>CVS</acronym> depot en dagelijks herbouwd wordt,
	    dan is de kans groot dat het systeem kwetsbaar is.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para>Het veld <literal>Corrected</literal> geeft de datum,
	    tijd en tijdzone aan en de uitgave die is aangepast.</para>
	</callout>

	<callout arearefs="co-cve">
	  <para>Gereserveerd voor de identificatie-informatie die
	    gebruikt wordt om kwetsbaarheden in het Common
	    Vulnerabilities Database System op te zoeken.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para>Het veld <literal>Background</literal> geeft meer
	    informatie over wat er precies aan de hand is.  Meestal
	    staat hier waarom het programma aanwezig is in &os;, waar
	    het voor gebruikt wordt en hoe het programma is
	    ontstaan.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para>Het veld <literal>Problem Description</literal> geeft
	    gedetailleerde toelichting op het beveiligingsprobleem.
	    Hier kan informatie bij staat over programmacode die
	    fouten bevat of zelfs hoe het programma gebruikt kan worden
	    om een beveiligingsgat te openen.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para>Het veld <literal>Impact</literal> beschrijft welke
	    invloed het probleem kan hebben op het systeem.  Dit kan
	    bijvoorbeeld een ontzegging van dienst aanval zijn,
	    gebruikers extra rechten geven of het verkrijgen van
	    supergebruiker toegang voor de aanvaller zijn.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para>Het veld <literal>Workaround</literal> geeft aan hoe
	    het mogelijk is het probleem te omzeilen (workaround) in
	    het geval systeembeheerders niet in staat zijn om het
	    systeem bij te werken.  Dit zou te maken kunnen hebben
	    met de tijd, beschikbaarheid van het netwerk en een hele
	    lijst met andere redenen.  Hoe dan ook, beveiliging
	    dient serieus genomen te worden en een systeem dat
	    kwetsbaar is moet bijgewerkt worden of het gat in de
	    beveiliging moet gedicht worden met de alternatieve
	    oplossing.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para>Het veld <literal>Solution</literal> geeft instructies
	    over hoe een systeem aangepast kan worden.  Dit is een
	    werkinstructie die getest en gecontroleerd is om een
	    systeem aan te passen en weer veilig werkend te
	    krijgen.</para>
	</callout>

	<callout arearefs="co-details">
	  <para>In het veld <literal>Correction Details</literal> staan
	    de <acronym>CVS</acronym> takken of uitgavenamen, met de
	    punten veranderd in een liggend streepje.  Er staat ook
	    welke revisienummer de aangetaste bestanden binnen een tak
	    hebben.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para>In het veld <literal>References</literal> wordt
	    gewoonlijk verwezen naar andere bronnen.  Dit kunnen
	    web-<acronym>URL</acronym>s, boeken, mailinglijsten en
	    nieuwsgroepen zijn.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 id="security-accounting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>Procesaccounting</primary></indexterm>

    <title>Procesaccounting</title>

    <para>Procesaccounting is een beveiligingsmethode die een beheerder
      in staat stelt om in de gaten te houden welke systeembronnen
      worden gebruikt, hoe ze over gebruikers verdeeld zijn,
      systeemmonitoring biedt en op minimalistische wijze het gebruik
      van commando's door gebruikers volgt.</para>

    <para>Deze methode heeft voordelen en nadelen.  E&eacute;n van de
      positieve punten is dat een inbraak gevolgd kan worden tot het
      moment waarop die zich voordeed.  Nadelen zijn de grootte van de
      logboeken die door procesaccounting worden gegenereerd en de
      schijfruimte die dat kost.  In dit onderdeel wordt een beheerder
      de basis van procesaccounting getoond.</para>

    <sect2>
      <title>Procesaccounting inschakelen en gebruiken</title>

      <para>Voordat procesaccounting gebruikt kan worden dient het te
	worden ingeschakeld met de volgende commando's:</para>

      <screen>&prompt.root; <userinput>touch <filename>/var/account/acct</filename></userinput>
&prompt.root; <userinput>accton <filename>/var/account/acct</filename></userinput>
&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; <filename>/etc/rc.conf</filename></userinput></screen>

      <para>Eenmaal ingeschakeld begint accounting met het bijhouden
	van <acronym>CPU</acronym> statistieken, commando's, enzovoort.
	Alle accounting logboeken worden in een niet leesbaar formaat
	bijgehouden en zijn uit te lezen met &man.sa.8;.  Bij het
	uitvoeren zonder opties, toont <command>sa</command> informatie
	gerelateerd aan het aantal aanroepen per gebruiker, de totale
	tijd in minuten die is verstreken, de totale
	<acronym>CPU</acronym>- en gebruikerstijd in minuten, gemiddeld
	aantal I/O operaties, enzovoort.</para>

      <para>Informatie over uitgevoerde commando's kan bekeken worden
	met &man.lastcomm.1;.  Zo kan met <command>lastcomm</command>
	bijvoorbeeld weergegeven worden welke commando's door
	gebruikers op een specifieke &man.ttys.5; zijn
	uitgevoerd:</para>

      <screen>&prompt.root; <userinput>lastcomm ls <username>trhodes</username> ttyp1</userinput></screen>

      <para>Het bovenstaande commando toont ieder bekend gebruikt van
	<command>ls</command> door de gebruiker
	<username>trhodes</username> op terminal
	<literal>ttyp1</literal>.</para>

      <para>Veel andere handige opties staan beschreven in
	&man.lastcomm.1;, &man.acct.5; en &man.sa.8;.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

