<!--
     The FreeBSD Documentation Project

     $FreeBSD$
	 Original revision: 1.126
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Rewritten by </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
        <firstname>Aasmund</firstname>
      <surname>Eikli</surname>
      <contrib>Translated by </contrib>
        </author>
      </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>UNIX Basis</title>

  <sect1 id="basics-synopsis">
    <title>Introduksjon</title>
    <indexterm><primary>basics</primary></indexterm>

    <para>Følgende kapitel vil gå over en rekke enkle kommandoer og
   funksjonalitet i &os;-operativsystemet. Mye av dette materiellet
   er relevant for alle varianter av &unix;. Om du har
   erfaring med slikt fra før kan du skumme dette kapitellet.
   Om du aldri har brukt &os; før, så er det en god ide å lese igjennom
   materiellet. Du vil stå bedre utrustet etterpå. </para>

    <para>Etter at du har lest dette kapitellet vil du vite følgende:</para>

    <itemizedlist>
      <listitem>
        <para>Hvordan bruke <quote>virtual consoles</quote> of
	  &os;.</para>
      </listitem>
      <listitem>
	<para>Hvordan &unix; filrettigheter fungerer.</para>
      </listitem>
      <listitem>
	<para>&os; filsystemlayout.</para>
      </listitem>
      <listitem>
	<para>&os; diskorganisering.</para>
      </listitem>
      <listitem>
	<para>Hvordan montere og demontere filsystemer.</para>
      </listitem>
      <listitem>
	<para>Hva prosesser, daemons og signaler er.</para>
      </listitem>
      <listitem>
	<para>Hva et shell er og hvordan du kan forandre standard loginmiljø.</para>
    </listitem>
      <listitem>
	<para>Hvordan bruke teksteditorer</para>
      </listitem>
      <listitem>
	<para>Hva devices og device nodes er.</para>
      </listitem>
      <listitem>
	<para>Hva slags binært format som blir brukt i &os;.</para>
      </listitem>
      <listitem>
	<para>Hvordan lese manualsider for mer informasjon.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Virtuelle konsoller og terminaler</title>
    <indexterm><primary>virtual consoles</primary></indexterm>
    <indexterm><primary>terminals</primary></indexterm>

    <para>&os; kan bli brukt på mange forskjellige måter. En av dem er å
	gi kommandoer til en tekstterminal. Mye av fleksibiliteten og kraften i
	et &unix; operativsystem når du bruker &os; på denne måten. Denne seksjonen
	gir informasjon om hva <quote>terminaler</quote> og <quote>konsoller</quote> er,
	og hvordan du kan bruke dem i &os;.</para>

	<sect2 id="consoles-intro">
      <title>Konsollet</title>
      <indexterm><primary>console</primary></indexterm>

	  <para>Om du ikke har konfigurert &os; til å starte et grafisk miljø
	  når systemet starter opp, vil du få en login prompt etter at oppstartsskriptene
	  er ferdige med sine oppgaver. Du vil se noe som likner på:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

&os;/i386 (pc3.eksempel.no) (ttyv0)

login:</screen>

     <para>Beskjedene kan variere noe fra system til system, men mesteparten er likt.
 	 De to siste linjene er hva vi er interessert i. Den nest siste ser omtrent
 	 slik ut:</para>

      <programlisting>&os;/i386 (pc3.eksempel.no) (ttyv0)</programlisting>

      <para>Denne linja inneholder litt informasjon om systemet. Du ser på
	  et <quote>&os;</quote> konsoll som kjører på en Intel prosessor av
	  typen x86-arkitektur
	<footnote>
	  <para>Dette er hva <literal>i386</literal> betyr. Selv om du ikke kjører
	  &os; på en Intel 386 CPU, vil det fremdeles være <literal>i386</literal>.
	  Det er ikke typen prosessor, men hva slags <quote>prosessorarkitektur</quote>
	  som er vist her.</para>

	</footnote>.
	Navnet på denne maskinen (hver &unix; maskin har et
		navn) er <hostid>pc3.eksempel.no</hostid>, og du ser nå på
		dets system console&mdash; 's<devicename>ttyv0</devicename>
	terminal.</para>

	  <para>Den siste linjen er alltid:</para>

      <programlisting>login:</programlisting>

	<para>Dette er stedet hvor du må skrive inn ditt
	<quote>ubrukernavn</quote> for å logge inn på systemet. Den neste
	delen viser hvordan.</para>

    </sect2>

    <sect2 id="consoles-login">
      <title>Innlogging</title>

      <para>&os; er et multibruker/multiprosessystem. Dette er det
	  vanlige navnet på et system som kan brukes av mange samtidig, som
	  igjen kan kjøre mange programmer samtidig på en enkelt maskin.</para>

	<para>Hvert eneste multibruker-system trenger en måte å skille
	mellom <quote>brukere</quote> på. I &os; (og alle andre
	&unix; operativsystemer) er dette løst på den måten at alle
	brukere må <quote>logge inn</quote> på systemet før de kan faktisk
	bruke det. Hver enkelt bruker har ett unikt navn (<quote>brukernavn</quote>)
	og en personlig nøkkel (<quote>passord</quote>. &os; vil spørre om
	begge før en bruker får lov til å gjøre noe som helst.
	</para>

      <indexterm><primary>startup scripts</primary></indexterm>

      <para>Etter at &os; har startet opp og gjort seg ferdig med sine oppstarts-
      skript<footnote>
      <para>Oppstartsskrip er programmer som kjøres automatisk av &os;
      når det starter. Deres normale funksjon er å konfigurere et miljø for alt
      annet, samt starte tjenester som du har konfigurert til å kjøre i
      bakgrunnen. </para>
      </footnote>, vil systemet presentere deg med en prompt som spør om et
      gyldig brukernavn:</para>

      <screen>login:</screen>

	<para>La oss i dette eksempelet gå utifra at vårt brukernavn er <username>aasmund</username>.
	Skriv <literal>aasmund</literal> ved prompten og trykk <keycap>Enter</keycap>. Når
	det er gjort får du en ny prompt som spør om et <quote>passord</quote>:</para>

      <screen>login: <userinput>aasmund</userinput>
Password:</screen>

      <para>Skriv inn <username>aasmund</username>'s passord og trykk
      <keycap>Enter</keycap>. Passordet blir <emphasis>ikke vist!</emphasis>
      Dette er gjort av sikkerhetsgrunner.</para>

	<para>Om du skrev passordet ditt riktig, skal du nå være logget inn
	i &os; og være klar til å prøve ut alle tilgjengelige kommandoer.</para>

      <para>Du skal nå se <acronym>MOTD</acronym> eller "message of the
      day" etterfulgt av en kommandoprompt (en <literal>#</literal>,
      <literal>$</literal> eller <literal>%</literal>). Dette indikerer
      at du har logget inn i &os; riktig.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Flere konsoller</title>

	<para>Å kjøre &unix; kommandoer i ett konsoll er greit, men &os;
	kan kjøre mange programmer på en gang. Å ha ett konsoll hvor kommandoer
	kan skrives er litt lite når &os; kan kjøre dusinvis av dem på en
	gang. Derfor finnes noe som heter <quote>virtuelle konsoller</quote>.</para>

	<para>&os; kan konfigureres til å presentere deg med mange forskjellige
	virtuelle konsoller. Du kan gå ett til hvilket som helst annet virtuelt
	konsoll ved å trykke et par taster på ditt keyboard. Hvert konsoll har
	sin egen output-kanal og &os; sørger for at keyboard og monitor output
	går der de skal mens du går imellom ett virtuelt konsoll til et annet.</para>

	<para>Spesielle tastekombinasjoner har blitt reservert av &os; for
	å svitsje mellom konsoller<footnote>
	  <para>En rimelig teknisk og detaljert oversikt over &os; konsoll
	  og keyboarddrivere finnes på manualsidene &man.syscons.4;, &man.atkbd.4;,
	  &man.vidcontrol.1; og &man.kbdcontrol.1;. Disse vil ikke bli forklart her,
	  men om leseren er interessert, kan han/hun alltid ta en titt på manualsidene
	  for en mer detaljert forklaring av hvordan ting fungerer.</para>
	  </footnote>. Du kan bruke
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, til
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> for å svitsje
	til et annet virtuelt konsoll i &os;.</para>

	<para>Mens du svitsjer fra ett konsoll til et annet tar &os; seg av
	å lagre og gjenopprette skjermoutput. Resultatet er en <quote>illusjon</quote>
	av at du har flere <quote>virtuelle</quote> skjermbilder og keyboards
	som du kan bruke. Programmene du starter på ett virtuelt konsoll
	stopper ikke å kjøre når det konsollet ikke er synlig. De fortsetter å kjøre
	når du har svitsjet til et annet konsoll.</para>

    </sect2>

    <sect2 id="consoles-ttys">
      <title><filename>/etc/ttys</filename> Filen</title>


      <para>En standard konfigurasjon av &os; vil starte med åtte
      virtuelle konsoller. Dette er ikke en endelig innstilling og du kan
      enkelt forandre din installasjon til å starte med flere eller færre.
      Numrene og innstillingene til virtuelle konsoller finnes i
      <filename>/etc/ttys</filename> filen.</para>


      <para>Du kan bruke <filename>/etc/ttys</filename> filen til å konfigurere
      virtuelle konsoller på &os;. Hver ukommenterte linje i denne filen
      (linjer som ikke starter med en <literal>#</literal>) inneholder
      innstillinger for en enkelt terminal eller virtuelt konsoll. Standard
      versjon av denne filen som shippes med &os; inneholder ni virtuelle
      konsoller og gjør åtte av dem tilgjengelige. Disse linjene starter med
      <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

    <para>For en detaljert forklaring på denne fila og alle innstillingene du kan bruke
    vedrørende virtuelle konsoller, se &man.ttys.5; manualsiden.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Single User Mode Konsoll</title>

	<para>En detaljert forklaring på hva <quote>single user mode</quote> er
	finnes i <xref linkend="boot-singleuser">. Det er viktig å huske på at
	det kun er ett konsoll når du kjører &os; i single user mode. Det er ingen
	virtuelle konsoller tilgjengelig. Innstillingene for single user mode konsollet
	finnes også i <filename>/etc/ttys</filename> filen. Se etter linjen som starter
	med <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

	  <note>
        <para>Som kommentarene over <literal>console</literal> linja
        indikerer, kan du editere denne linjen og forandre <literal>secure</literal>
         til <literal>insecure</literal>. Om du gjør det vil &os; spørre om
         <username>root</username> passordet når du starter i single user mode.</para>

	<para><emphasis>Vær forsiktig hvis du forandrer til
	  <literal>insecure</literal></emphasis>. Hvis du noegang glemmer
	  <username>root</username> passordet kan å starte i single user mode
	  bli interessant. Det er fremdeles mulig men kan være vanskelig
	  for noen som ikke er komfortabel med &os;'s oppstartsprosess og
	  hvilke programmer involvert i den.</para>
      </note>
	</sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Rettigheter</title>
    <indexterm><primary>UNIX</primary></indexterm>

	  <para>Siden &os; er en direkte arving til BSD &unix; er det basert
	  på en del nøkkelkonsepter. Det første og viktigste er at &os; er
	  et multibruker operativsystem. Systemet kan håndtere flere brukere
	  som alle jobber samtidig på helt forskjellige ting. Systemet har
	  ansvaret for at alle brukerne har ca den samme tilgangen til CPU,
	  komponenter, minne og mye annet.


	<para>Siden systemet kan imøtekomme mange brukere har den et sett
	med rettigheter på alt den har ansvar for. Dette inkluderer rettigheter
	som hvem kan lese, skrive eller eksekvere en ressurs. Disse rettighetene
	er lagret som tre oktetter, som igjen er brutt ned i tre biter: en for
	eieren av filen, en for gruppa som fila tilhører og en for alle andre.
	Nummerne ser slik ut:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>file permissions</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Verdi</entry>
	    <entry>Rettighet</entry>
	    <entry>Katalogliste</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Ingen les, ingen skriv, ingen eksekver</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Ingen les, ingen skriv, eksekver</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Ingen les, skriv, ingen eksekver</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Ingen les, skriv, eksekver</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Les, ingen skriv, ingen eksekver</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Les, ingen skriv, eksekver</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Les, skriv, ingen eksekver</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Les, skriv, eksekver</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directories</primary></indexterm>

	<para>Du kan bruke <option>-l</option> kommandolinjeargumentet
	til &man.ls.1; for å se en lang katalogliste som inkluderer en kolonne
	med informasjon om en fil's rettigheter for eier, gruppe og alle andre.
	For eksempel, en <command>ls -l</command> i en arbitrær katalog kan vise:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 minfil
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 annenfil
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 epost.txt
...</screen>

    <para>Det neste bildet viser hvordan den første kolonnen av <command>ls -l</command>
    er brutt ned:</para>

    <screen>-rw-r--r--</screen>

	<para>Den første (venstre> bokstaven forteller om denne filen er en vanlig fil,
	en katalog, en spesiell "character device", en "socket", eller en annen pseuo-fil
	komponent. I dette tilfellet indikerer <literal>-</literal> en vanlig fil.
	De neste tre bokstavene i dette eksempelet, <literal>rw-</literal>, gir
	rettigheter for eieren av fila. De neste tre bokstavene, <literal>r--</literal>,
	gir rettigheter for gruppa fila hører til. De siste tre bokstavene, <literal>r--</literal>,
	gir rettigheter for resten av verden. En strek betyr at rettigheten er skrudd av.
	For denne fila er rettighetene satt så eieren kan lese og skrive til fila, gruppa
	kan lese fila og resten av verden kan bare lese fila. Ifølge tabellen over vil
	rettighetene for denne fila bli <literal>644</literal> hvor hvert nummer representerer
	de tre delene av fila's rettigheter.</para>

	<para>Dette er vel og bra men hvordan kontrollerer systemet rettigheter
	på komponenter? &os; ser på de fleste komponenter som en fil som programmer
	kan åpne, lese og skrive til akkurat som en hvilken som helst annen fil. Disse
	spesielle komponentfilene er lagret i <filename>/dev</filename> katalogen,</para>

    <para>Kataloger blir også sett på som filer. De har les, skriv og eksekver-
    rettigheter. Eksekverbiten på en katalog har en litt annen mening enn
    på filer. Når en katalog er merket eksekverbar betyr det at man kan gå inn
    i den, dvs at det er mulig å <quote>cd</quote> (forandre katalog) inn i den.
    Dette betyr også at inne i katalogen er det nå tilgang til filer (om rettighetene
    på selve filene tillater det).</para>

    <para>Om man ønsker å liste filer i en katalog, må man ha leserettighet
    på katalogen. Oom man ønsker å slette en fil som man vet navnet på, trenger
    man å ha skriv <emphasis>og</emphasis> eksekverrettigheter på katalogen hvor
    fila ligger.</para>

    <para>Det er flere rettighetsbiter enn rwx, men de er primært brukt i spesielle
    tilfeller slik som "setuid" binærfiler og "sticky" kataloger.
    Om du ønsker mer informasjon om filrettigheter og hvordan sette dem, les
    &man.chmod.1; manualsiden.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
	  </sect2info>

      <title>Symbolske Rettigheter</title>
      <indexterm><primary>Permissions</primary><secondary>symbolic</secondary></indexterm>

	<para>Symbolske rettigheter er avogtil referert til som symbolske utrykk. Disse
	bruker bokstaver istedet for oktale verdier for å gi rettigheter til filer
	eller kataloger. Symbolske utrykk bruker (hvem) (handling) (rettighet) og følgende
	verdier er tilgjengelige:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Opsjon</entry>
	      <entry>Bokstav</entry>
	      <entry>Representerer</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(hvem)</entry>
	    <entry>u</entry>
	    <entry>Bruker</entry>
	  </row>

	  <row>
	    <entry>(hvem)</entry>
	    <entry>g</entry>
	    <entry>Eier av gruppe</entry>
	  </row>

	  <row>
	    <entry>(hvem)</entry>
	    <entry>o</entry>
	    <entry>Andre</entry>
	  </row>

	  <row>
	    <entry>(hvem)</entry>
	    <entry>a</entry>
	    <entry>Alle (<quote>verden</quote>)</entry>
	  </row>

	  <row>
	    <entry>(handling)</entry>
	    <entry>+</entry>
	    <entry>Legge til rettighet</entry>
	  </row>

	  <row>
	    <entry>(handling)</entry>
	    <entry>-</entry>
	    <entry>Ta bort rettighet</entry>
	  </row>

	  <row>
	    <entry>(handling)</entry>
	    <entry>=</entry>
	    <entry>Sette rettighet</entry>
	  </row>

	  <row>
	    <entry>(rettighet)</entry>
	    <entry>r</entry>
	    <entry>Les</entry>
	  </row>

	  <row>
	    <entry>(rettighet)</entry>
	    <entry>w</entry>
	    <entry>Skriv</entry>
	  </row>

	  <row>
	    <entry>(rettighet)</entry>
	    <entry>x</entry>
	    <entry>Eksekver</entry>
	  </row>

	  <row>
	    <entry>(rettighet)</entry>
	    <entry>t</entry>
	    <entry>"Sticky bit"</entry>
	  </row>

	  <row>
	    <entry>(rettighet)</entry>
	    <entry>s</entry>
	    <entry>Sett UID eller GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

	<para>Disse verdiene blir brukt med &man.chmod.1; kommandoen
	akkurat som før, men med bokstaver istedet for nummer. For eksempel
	kan du bruke følgende kommando til å blokkere andre brukere fra å
	ha tilgang til <replaceable>FIL</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= FIL</userinput></screen>

	<para>En kommaseparert liste kan brukes når mer enn en forandring på
	en fil gjøres. For eksempel, følgende kommando vil ta vekk gruppe og
	<quote>verden</quote> skriverettighet på <replaceable>FIL</replaceable>,
	og deretter legger den til eksekverrettighet for alle:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FIL</replaceable></userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>Katalogstruktur</title>
    <indexterm><primary>directory hierarchy</primary></indexterm>

	<para>&os; katalogstrukturen er fundamental for å forstå
	hvordan systemet fungerer i praksis. Den viktigste konseptet
	er rotkatalogen, <quote>/</quote>. Denne katalogen er den første
	monterte katalogen ved oppstart og den inneholder basesystemet
	som trengs for å klargjøre operativsystemet for multibruker.
	Rotkatalogen inneholder også monteringspunkter for alle andre
	filsystemer du tenker på å montere.</para>

    <para>Et monterinspunkt er en katalog hvor andre filsystemer kan bli
    "satt på" rotfilsystemet. Vanlige monteringspunkter inkluderer
     <filename>/usr</filename>, <filename>/var</filename>,
     <filename>/mnt</filename>, og <filename>/cdrom</filename>.
     Disse katalogene er som regel referert til linjer i <filename>/etc/fstab</filename>
     fila. <filename>/etc/fstab</filename> er en tabell over forskjellige
     filsystemer og monteringspunkter systemet har til rådighet.
     Mesteparten av filsystemene i <filename>/etc/fstab</filename> er
     montert automatisk ved oppstart fra skriptet &man.rc.8;. Om et filsystem
     har opsjonen <option>noauto</option>, vil det ikke bli montert automatisk.
     Se &man.fstab.5; manualsiden for mer informasjon om formatet på
     <filename>/etc/fstab</filename> filen og hvilke innstillinger tilgjengelige.</para>

	<para>En komplett beskrivelse av filsystem-hierakiet finnes i
	  &man.hier.7;. Her følger en liten oversikt over de mest
	  vanlige katalogene.</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Katalog</entry>
	      <entry>Beskrivelse</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Rotkatalogen på filsystemet.</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Brukerprogrammer for både singelbruker og multibruker-
	      miljøer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Programmer og konfigurasjonsfiler brukt under
	      oppstart av operativsystemet.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Standard "bootstrapping" konfigurasjonsfiler; se
	      &man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Komponentnoder; se &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Systemkonfigurasjonsfiler og skript.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Standard systemkonfigurasjonsfiler; se &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Konfigurasjonsfiler for mail transport agents slik som
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry><command>named</command> konfigurasjonsfiler; se
	      &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>Skript som kjøres daglig, ukentlig, og månedtlig,
		via &man.cron.8;; se &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry><command>ppp</command> konfigurasjonsfiler; se
	      &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Tom katalog som normalt blir brukt av administratorer for
	      å montere temporære filsystemer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Process file system; se &man.procfs.5;,
	      &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Hjemmekatalog for <username>root</username>
	      kontoen.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	    <entry>Systemprogrammer og administrasjonsprogrammer for både
	    enbruker og flerbrukermiljøer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>Programmer brukt i enbrukermiljø, "standalone".</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Temporære filer, som regel et &man.mfs.8;
		minnebasert filsystem (innholdet av <filename
		class="directory">/tmp</filename> er som regel IKKE
		beholdt om systemet restarter).</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>De fleste brukerprogrammer og applikasjoner.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Vanlige programmer, programmeringsverktøy og applikasjoner.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Vanlige C include filer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Arkiveringsbiblioteker.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Forskjellige applikasjonsdatafiler.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>System daemons & systemprogrammer (eksekvert av andre
		programmer).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/local/</filename></entry>

		  <entry>Lokale eksekverbare filer, biblioteker, osv. Også
		  brukt som standard destinasjon for &os; portstreet.
		  Inne i <filename>/usr/local</filename> skal den generelle
		  layout'en i &man.hier.7; for <filename>/usr</filename> bli
		  brukt. Et par unntak er man katalogen, som ligger under
		  <filename>/usr/local</filename> istedetfor under
		  <filename>/usr/local/share</filename> og ports-
		  dokumentasjonen som er i <filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Arkitekturspesifikkt tre som blir opprettet ved bygging av
		<filename>/usr/src</filename> treet.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>&os; ports collection (om installert).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>System daemons & systemprogrammer (eksekvert av brukere).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Arkitekturløse filer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>BSD og/eller lokale kodefiler.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>X11R6 eksekverbare filer, biblioteker, osv
	      (om installert).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Logging, temporære filer, spool-filer, osv.
	      </entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Forskjellige typer systemloggfiler.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Mailboksfiler for brukere.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Forskjellige printer og postspooling-kataloger.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Temporære filer som blir beholdt ved systemrestart.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Diskorganisering</title>

	      <para>Den minste organiseringen som &os; bruker for å finne filer
   er filnavnet. Det skilles mellom store og små bokstaver i filnavn, noe
   som betyr at <filename>readme.txt</filename> og <filename>README.TXT
   </filename> er to forskjellige filer. &os; bruker ikke etternavnet
	(<filename>.txt</filename> på en fil for å finne ut om filen er et
	 program, et dokument eller noen annen form for data.</para>

   <para>Filer er lagret i kataloger. En katalog kan inneholde ingen filer
	 eller mange hundre av dem. En katalog kan også inneholde andre kataloger
	 noe som lar deg bygge opp et hieraki av kataloger inni hverandre.
	 Dette gjør det mye lettere å organisere data.</para>

   <para>Filer og kataloger er referert til ved å gi filen eller katalogen
	 et navn, fulgt av en slash, <literal>/</literal>,
	 som igjen er fulgt av et annet katalognavn om nødvendig. Hvis du har
 	katalog <filename>foo</filename>, som inneholder katalog
 	<filename>bar</filename>, som igjen inneholder filen
 	<filename>readme.txt</filename>, så blir det fulle navnet, eller
 	<firstterm>stien</firstterm> til filen:
	<filename>foo/bar/readme.txt</filename>.</para>

   <para>Kataloger og filer er lagret i et filsystem. Hvert filsystem
   	inneholder en katalog øverst i treet som kalles <firstterm>
   	rotkatalogen</firstterm> for det filsystemet. Denne rotkatalogen kan
   	så inneholde andre kataloger.</para>

    <para>Så langt er dette antakeligvis likt andre operativsystemer du har
   	brukt. Det er et par forskjeller, for eksempel, DOS bruker
   	<literal>\</literal> for å skille mellom filer og katalognavn, mens MacOS
   	bruker <literal>:</literal>.</para>

    <para>&os; bruker ikke bokstaver for å angi <firstterm>drev</firstterm>
   	eller andre drevnavn i stien. Du kan ikke skrive
   	<filename>c:/foo/bar/readme.txt</filename> på &os;.</para>

    <para>Istedenfor er ett filsystem markert som <firstterm>rotfilsystem</firstterm>.
	Rotfilsystemet's rootkatalog er referert til som <literal>/</literal>.
	Hvilket som helst annet filsystem er så <firstterm>montert (mountet)</firstterm>
	under rotfilsystemet. Uansett hvor mange disker du har på ditt &os;
	system så ser hver katalog ut som at den er en del av samme disk.</para>

    <para>Si at du har tre filsystemer kalt <literal>A</literal>,
	<literal>B</literal>, og <literal>C</literal>.  Hvert filsystem har
	en rotkatalog som inneholder to andre kataloger. Disse er kalt
	<literal>A1</literal>, <literal>A2</literal> (og det samme for de andre:
	<literal>B1</literal>, <literal>B2</literal> og
	<literal>C1</literal>, <literal>C2</literal>).</para>

    <para>Kall <literal>A</literal> for rotfilsystemet.  Hvis du brukte kommandoen
	<command>ls</command> for å se på innholdet til denne katalogen
	ville du se to underkataloger, <literal>A1</literal> og
	<literal>A2</literal>.  <firstterm>Katalogtreet</firstterm>
	ser ut som dette:</para>

      <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>

    <para>Et filsystem må bli montert på en katalog i ett annet filsystem.
	Så si nå at du monterer filsystemet <literal>B</literal> på katalogen
	<literal>A1</literal>.  Rotkatalogen til <literal>B</literal> erstatter
	<literal>A1</literal>, og katalogene i <literal>B</literal> kommer opp
	som følger:</para>

      <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>

    <para>Filer som er i katalogene <literal>B1</literal> eller
	<literal>B2</literal> kan nåes ved å følge stien
	<filename>/A1/B1</filename> eller <filename>/A1/B2</filename>
	Filer som var i <filename>/A1</filename> har blitt gjemt.
	De vil dukke opp hvis <literal>B</literal> er
	<firstterm>avmontert (unmounted)</firstterm> fra A.</para>

    <para>Hvis <literal>B</literal> hadde blitt montert på <literal>A2</literal>
	ville diagrammet sett slik ut:</para>

      <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>

    <para>og stiene ville blitt <filename>/A2/B1</filename> og
	<filename>/A2/B2</filename>.</para>

    <para>Filsystemer kan bli montert på toppen av hverandre. Hvis vi
	fortsetter med det forrige eksempelet: <literal>C</literal>
	filsystemet kunne bli montert på toppen av <literal>B1</literal>
	katalogen i <literal>B</literal> filsystemet.
	Diagrammet ser da slik ut:</para>

      <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>

    <para>Eller <literal>C</literal> kunne bli montert direkte på
	<literal>A</literal> filsystemet, under <literal>A1</literal>
	katalogen:</para>

      <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>

    <para>Hvis du kjenner DOS så er dette ganske likt, men ikke identisk
   	til, kommandoen <command>join</command>.</para>

    <para>Dette er ikke noe du vanligvis trenger å bekymre deg noe om.
   	Når du installerer &os; lager du filsystemer og bestemmer hvor du
   	skal montere dem. Deretter forandres de aldri hvis du ikke legger til
   	en ny disk.</para>

    <para>Det er mulig å ha ett stort rotfilsystem og ikke lage noen andre.
   	Det er noen bakdeler ved dette og en fordel.</para>

         <itemizedlist>
   	<title>Fordelene Ved Flere Filsystemer</title>

   	<listitem>
   	  <para>Forskjellige filsystemer kan ha forskjellige <firstterm>
   	  monteringsinnstillinger</firstterm>. For eksempel, hvis du planlegger nøye så
   	  kan rotfilsystemet bli montert read-only slik at du ikke ved en feiltagelse
   	  sletter eller editerer en kritisk fil.</para>
   	</listitem>

   	<listitem>
   	  <para>&os; optimaliserer automatisk filene på et filsystem i forhold
   	  til hvordan filsystemet blir brukt. Så for eksempel et filsystem som inneholder
   	  mange små filer og er brukt mye har en annen optimalisering enn et filsystem
   	  som inneholder få men store filer. Ved å ha ett stort filsystem vil
   	  denne optimaliseringen ikke fungere.</para>
   	</listitem>

   	<listitem>
   	  <para>&os;'s filsystemer er svært robuste hvis du mot formodning skulle
   	  miste strømmen. Et strømbrudd på et kritisk punkt kan likevel skade strukturen
   	  på filsystemet. Ved å splitte opp data over flere filsystemer er det mer
   	  sannsynlig at systemet vil komme opp. Deretter er det lettere å hente data
   	  fra backup om nødvendig.</para>
   	</listitem>
         </itemizedlist>

         <itemizedlist>
   	<title>Fordelen Med Et Enkelt Filsystem</title>

   	<listitem>
   	  <para>Filsystemer har en konstant størrelse. Hvis du lager et
   	  filsystem når du installerer &os; og gir det en størrelse
   	  kan du senere oppdage at du trenger å utvide partisjonen.
   	  Dette er vanskelig å få til uten å ta backup, utvide filsystemet
   	  til størrelsen du ønsker, og så laste tilbake data fra backupen.</para>

   	<listitem>
   	  <para></para>

   	  <important>
   	    <para>&os; 4.4 og oppover har en spesiell kommando,
   	    &man.growfs.8;. Denne kommandoen gjør det mulig å
   	    utvide størrelsen på et filsystem uten å først ta backup.
   	    Problemet er derfor borte.</para>
   	  </important>
   	</listitem>
         </itemizedlist>


    <para>Filesystems are contained in partitions.  This does not have the
	same meaning as the common usage of the term partition (for example, &ms-dos;
	partition), because of &os;'s &unix; heritage.  Each partition is
	identified by a letter from <literal>a</literal> through to
	<literal>h</literal>.  Each partition can contain only one filesystem,
	which means that filesystems are often described by either their
	typical mount point in the filesystem hierarchy, or the letter of the
	partition they are contained in.</para>

      <para>&os; also uses disk space for <firstterm>swap
	  space</firstterm>.  Swap space provides &os; with
	<firstterm>virtual memory</firstterm>.  This allows your computer to
	behave as though it has much more memory than it actually does.  When
	&os; runs out of memory it moves some of the data that is not
	currently being used to the swap space, and moves it back in (moving
	something else out) when it needs it.</para>

      <para>Filsystemer finnes i partisjoner. Dette har ikke den samme meningen
	som den tidligere bruken av ordet i dette kapitellet på grunn av
	&os;'s Unixarv. Hver partisjon er identifisert av en bokstav,
	<literal>a</literal> til <literal>h</literal>. Hver partisjon kan bare
	inneholde ett filsystem, noe som betyr at filsystemer ofte blir
	beskrevet som enten deres typiske monteringspunkt på rotfilsystemet, eller
	bokstaven på partisjonen de finnes i.</para>

      <para>&os; bruker også diskplass for <firstterm>swap</firstterm>. Swap
	er &os;'s versjon av <firstterm>virtuelt minne</firstterm>. Dette gjør
	at din datamaskin kan oppføre seg som om den har mer minne enn den faktisk
	har. Når &os; går tom for minne, flytter den en del av data'en som
	i øyeblikket ikke er i bruk over til swap. Den flytter data tilbake
	(og derfor flytter noe annet ut) når den trenger det.</para>

      <para>Noen partisjoner har noen spesielle navn assosiert.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Partisjon</entry>

	      <entry>Navn</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Vanligvis inneholder rotfilsystemet</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Vanligvis inneholder swap</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Vanligvis den samme størrelsen som delen rundt. Dette gjør
	        at programmer som trenger å jobbe på hele delen (for eksempel en
	        bad block skanner) kan jobbe på <literal>c</literal> partisjonen.
	        Du vil ikke vanligvis lage et filsystem på denne partisjonen.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Partisjon <literal>d</literal> pleide å ha en spesiell
		mening assosiert, men den er nå borte. Til denne dag kan noen
	        programmer oppføre seg rart om de blir fortalt at de skal jobbe
		på partisjon <literal>d</literal>, så <application>Sysinstall</application>
		vil vanligvis ikke lage partisjon <literal>d</literal>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Hver partisjon som inneholder et filsystem er lagret i hva &os;
	kaller en <firstterm>slice</firstterm> (del). En del er hva &os;
	kaller en partisjon og dette er igjen på grunn av &os;'s Unixbakgrunn.
	Deler er nummerert fra 1 til 4.</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>partisjoner</primary></indexterm>
	<indexterm><primary>farlig dedikering</primary></indexterm>

      <para>Delnummre følger komponentnavnet, putter en <literal>
	s</literal> foran og starter med 1. Så <quote>da0<emphasis>
	s1</emphasis></quote> er den første delen på den første
	SCSIdisken. Det kan bare være fire fysiske deler på en disk
	men du kan ha logiske deler inni de fysiske delene av korrekt
	type. Disse utvidete delene er nummerert fra 5 og utover, så
	<quote>ad0<emphasis>s5</emphasis></quote> er den første
	utvidete delen på en disk. Disse komponentene blir brukt av
	filsystemer som forventer å okkupere en del.</para>

      <para>Deler som er <quote>farlig dedikerte</quote> fysiske
	drev og andre drev inneholder
	<firstterm>partisjoner</firstterm>, som er representert som
	bokstaver fra <literal>a</literal> til <literal>h</literal>.
	Denne bokstaven er lagt til komponentnavnet, så
	<quote>da0<emphasis>a</emphasis></quote> er a-partisjonen på det
	første da drevet, noe som er <quote>farlig dedikert</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> er den femte partisjonen
	i den tredje delen av den andre IDE disken.</para>

      <para>Hver disk på systemet blir identifisert. Et disknavn starter med en
	kode som indikerer typen disk og så et nummer som indikerer hvilken
	disk det er. Disknummerering starter med 0 og ikke 1 som i del-nummerering.
	Vanlige koder som du vil se er listet i
	<xref linkend="basics-dev-codes">.</para>

      <para>Når du refererer til en partisjon så krever &os; at du også
	navngir delen og disken som inneholder partisjonen. Så når du referer
	til en del burde du også referere til disk-navnet. Gjør dette ved å
	liste opp disknavnet <literal>s</literal>, delnummeret og så
	partisjonsbokstaven. Eksempler er vist i
	<xref linkend="basics-disk-slice-part">.</para>

      <para><xref linkend="basics-concept-disk-model"> viser en konseptuell
	modell av diskorganisering som burde hjelpe deg til å se ting klarere.</para>

      <para>For å kunne installere &os; må du først konfigurere disk-delene.
	Deretter må du lage partisjoner inni delene du vil bruke for &os;, og til
	slutt lage et filsystem (eller swap) i hver partisjon. Tilslutt må du velge
	hvor filsystemet skal bli montert.</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>Vanlige Disk-koder</title>

		<tgroup cols="2">
		  <thead>
		    <row>
		      <entry>Kode</entry>

		      <entry>Mening</entry>
		    </row>
		  </thead>

		  <tbody>
		    <row>
		      <entry><devicename>ad</devicename></entry>

		      <entry>ATAPI (IDE) disk</entry>
		    </row>

		    <row>
		      <entry><devicename>da</devicename></entry>

		      <entry>SCSI direct access disk</entry>
		    </row>

		    <row>
		      <entry><devicename>acd</devicename></entry>

		      <entry>ATAPI (IDE) CDROM</entry>
		    </row>

		    <row>
		      <entry><devicename>cd</devicename></entry>

		      <entry>SCSI CDROM</entry>
		    </row>

		    <row>
		      <entry><devicename>fd</devicename></entry>

		      <entry>Diskett</entry>
		    </row>
		  </tbody>
		</tgroup>
	      </table>

      <example id="basics-disk-slice-part">
		<title>Eksempel på Disk, Del, og Partisjonnavn</title>

		<informaltable frame="none">
		  <tgroup cols="2">
		    <thead>
		      <row>
			<entry>Navn</entry>

			<entry>Mening</entry>
		      </row>
		    </thead>

		    <tbody>
		      <row>
			<entry><literal>ad0s1a</literal></entry>

			<entry>Den første partisjonen (<literal>a</literal>) på den første
			  delen (<literal>s1</literal>) på den første IDE disken
			  (<literal>ad0</literal>).</entry>
		      </row>

		      <row>
			<entry><literal>da1s2e</literal></entry>

			<entry>Den femte partisjonen (<literal>e</literal>) på den
			  andre delen (<literal>s2</literal>) på den andre SCSI disken
			  (<literal>da1</literal>).</entry>
		      </row>
		    </tbody>
		  </tgroup>
		</informaltable>
	      </example>

      <example id="basics-concept-disk-model">
	<title>Konseptuell Modell av en Disk</title>

	<para>Dette diagrammet viser &os;'s syn på den første IDE-disken
	  på systemet. Gå utifra at disken er 4GB stor og inneholder to
	  2GB deler (DOS-partisjoner). Den første delen inneholder en DOS-disk,
	  <devicename>C:</devicename> og den andre delen inneholder en
	  &os; installasjon. Denne eksempelinstallasjonen av &os; har tre
	  partisjoner og en swap-partisjon.</para>

	<para>De tre partisjonene vil inneholde ett filsystem hver.  Partisjon
	  <literal>a</literal> vil bil bruk som rotfilsystem,
	  <literal>e</literal> for <filename>/var</filename> katalog-
	  hierarkiet, og <literal>f</literal> for
	  <filename>/usr</filename> kataloghierakiet.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     >  Første del, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partisjon a, montert som /     |
|                 |     > referert til som ad0s2a        |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partisjon b, brukt som swap    |
|                 |     > referert til som ad0s2b        |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partisjon c, intet
|                 |    |  Partisjon e, brukt som /var     > filsystem, hele
|                 |     > referert til som ad0s2e        |  &os; delen,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partisjon f, brukt som /usr    |
:                 :     > referert til som ad0s2f        |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>Montering og Demontering av Filsystemer</title>

	<para>Det er best å se for seg et filsystem som et tre
      med sin rot <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename>, og de
      andre katalogene i rotkatalogen er grener, som kan
      ha sine egne grener, slik som
      <filename>/usr/local</filename>, osv.</para>

    <indexterm><primary>root file system</primary></indexterm>

	<para>Det er forskjellige grunner til å ha disse katalogene på
      forskjellige filsystemer.  <filename>/var</filename>
      inneholder katalogene <filename>log/</filename>,
      <filename>spool/</filename>,
      og andre typer av temporære filer, og kan bli fulle.
      Å fylle opp rotfilsystemet er en dårlig ide, så å splitte
	  <filename>/var</filename> fra
      <filename>/</filename> er som regel en mye bedre ide.</para>

    <para>En annen vanlig grunn til at det er smart å ha en del katalogtrær
    på andre filsystemer er om de skal legges på separate fysiske disker,
    eller er sparate virtuelle disker slik som <link linkend="network-nfs">
    Network File System</link> monteringer eller CDROM drev.</para>

    <sect2 id="disks-fstab">
      <title><filename>fstab</filename> Filen</title>
      <indexterm>
	<primary>file systems</primary>
	<secondary>mounted with fstab</secondary>
      </indexterm>

	<para>I <link linkend="boot">oppstartsprosessen</link> blir
	filsystemene listet i <filename>/etc/fstab</filename> automatisk
	montert (så lenge de ikke er listet med
	<option>noauto</option> opsjonen).</para>

      <para><filename>/etc/fstab</filename> fila inneholder en liste
	av linjer som ser slik ut:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>Et "device"-navn (som skal eksistere), blir forklart i
	      <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem><para>En katalog (som skal eksistere), som
	  	filsystemet monteres i.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem><para>Filsystemtype som
		&man.mount.8; skal bruke.  Standard &os; filsystemnavn er
	      <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	<listitem><para>Enten <option>rw</option> for les-skriv-
	      filsystemer, eller <option>ro</option> for kun-les-
	      filsystemer, fulgt av andre innstillinger som kanskje trengs.
	      En vanlig innstilling er <option>noauto</option> for
	      filsystemer som ikke blir automatisk montert ved oppstart.
	      Andre innstillinger er listet i &man.mount.8; manualsiden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

         <listitem><para>Dette blir brukt av &man.dump.8; for å finne ut av
	             hvilke filsystemer som trenger å dumpes. Om ikke feltet finnes,
	             gåes det utifra en verdi av null.</para>
	         </listitem>
	       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

     <listitem>
           <para>Denne innstillingen indikerer hvilken rekkefølge
           filsystemer blir sjekket på. Filsystemer som ikke trenger
           eller ikke skal bli sjekket må ha <literal>passno</literal> satt til
           null. Rotfilsystemet (som må sjekkes før alt annet) må ha
           <literal>passno</literal> satt til større enn 1. Hvis flere
           enn ett filsystem har det samme <literal>passno</literal> så vil
           &man.fsck.8; prøve å sjekke filsystemene paralellt om mulig.</para>
         </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>Kommandoen <command>mount</command></title>
      <indexterm>
	<primary>file systems</primary>
	<secondary>mounting</secondary>
      </indexterm>

      <para>&man.mount.8; kommandoen brukes til å montere filsystemer.</para>

	  <para>I sin basiske form, bruker du:</para>

	<informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Det er mange innstillinger, som forklart i
      &man.mount.8; manualsiden, men de mest vanlige er:</para>

      <variablelist>
	<title>Monteringsinnstillinger</title>

	<varlistentry>
	  <term><option>-a</option></term>

	<listitem>
	    <para>Monter alle filsystemer listet i <filename>/etc/fstab</filename>,
	    bortsett fra dem merket <quote>noauto</quote>, ekskludert av <option>
	    -t</option> flagget, eller de som allerede er montert.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

  <listitem>
	    <para>Gjør alt bortsett fra det faktiske monter-systemkallet.
	    Denne innstillingen er fin å ha når den brukes sammen med
	    <option>-v</option> for å finne ut hva &man.mount.8; faktisk
	    prøver å gjøre.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	<listitem>
	    <para>Monter et urent filsystem uansett (kan være
	    farlig), eller tar bort skrivetilgangen når man nedgraderer
	    et filsystem's monteringsstatus fra les-skriv til kun-les.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	<listitem>
	    <para>Monter et filsystem kun-les. Dette er det samme som
	    å bruke <option>rdonly</option> argumentet til
	    <option>-o</option> innstillingen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	<listitem>
	    <para>Monter gitte filsystem som den gitte filsystemtypen
	    eller monter bare filsystemer av gitte type, om
	    <option>-a</option> innstillingen er tatt med.</para>

	    <para><quote>ufs</quote> ufs er standard filsystemtype.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Oppdater monteringsinnstillinger på filsystemet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Ekstra informasjon.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Monter filsystemet skriv-les.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

	<para><option>-o</option> innstillingen tar en kommaseparert liste
	av innstillinger, inkludert følgende:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	<listitem>
	    <para>Ikke aktiver spesielle "devices" på filsystemet.
	    Dette er en god sikkerhetsinnstilling.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
              <para>Ikke tillat eksekvering av binærfiler på dette
              filsystemet. Dette er også en god sikkerhetsinnstilling.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Ikke aktiver setuid eller setgid flagg på filsystemet.
	    Dette er en god sikkerhetsinnstilling.</para>
	  </listitem>
	</varlistentry>
	</variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title><command>umount</command> Kommandoen</title>
      <indexterm>
	<primary>file systems</primary>
	<secondary>unmounting</secondary>
      </indexterm>

      <para>&man.umount.8; kommandoen tar, som et parameter, ett av et
	monteringspunkt, ett "device"-navn, eller <option>-a</option> eller
	<option>-A</option> innstillingene.</para>

      <para>Alle former tar <option>-f</option> for å tvinge demontering,
        og <option>-v</option> for ekstra informasjon.  Vær klar over at
        <option>-f</option> som regel ikke er noen god ide.  Å tvinge
        demontering av filsystemer kan krasje datamaskinen eller
        skade data på filsystemet.</para>

	<para><option>-a</option> og <option>-A</option> brukes til å
	demontere alle monterte filsystemer, men antakeligvis modifisert av
	filsystemtypene listet etter <option>-t</option>.
	<option>-A</option> prøver ikke å demontere rotfilsystemet.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Prosesser</title>

	<para>&os; er et multi-tasking operativsystem. Dette betyr at det kan se
	ut som at mer enn ett program kjører samtidig. Hvert enkelt program som kjører
	til enhver tid blir kalt en <firstterm>prosess</firstterm> og det er en god
	del systemprosesser som kjører hele tiden og som har som oppgave å sørge for
	at systemet er funksjonelt.</para>

	<para>Hver prosess har et unikt nummer kalt <firstterm>prosess-ID</firstterm>,
	eller <firstterm>PID</firstterm> og som filer har hver enkelt prosess
	en eier og ei gruppe. Eier og gruppeinformasjon blir brukt til å finne ut
	hva slags filer og devices prosessen kan åpne ved å bruke filrettigheter
	som forklart tidligere. De fleste prosesser har en foreldreprosess.
	Foreldreprosessen er prosessen som startet dem. For eksempel, hvis du
	skriver kommandoer til shellet, er shellet en prosess og alle kommandoer
	du kjører også prosesser. Hver enkelt prosess du kjører på denne måten vil
	ha shellet som sin foreldreprosess. Unntaket til denne regelen er en spesiell
	prosess kalt &man.init.8;. <command>init</command> er alltid den første
	prosessen, så dens PID er alltid 1. <command>init</command> blir startet
	automatisk av kjernen når &os; starter opp.</para>

	<para>To kommandoer er svært hendige for å se prosessene på systemet, &man.ps.1;
	og &man.top.1;. <command>ps</command> kommandoen blir brukt til å vise en
	statisk liste over alle prosesser som kjører i det øyeblikket og kan vise deres PID,
	hvor mye minne de bruker, kommandolinjen de ble startet med, osv. <command>top</command>
	viser alle prosesser som kjører og oppdaterer skjermen etter et par sekunder så du
	kan se hva datamaskinen din gjør hele tiden.</para>

	<para>Ved å skrive <command>ps</command> viser deg kun kommandoene som kjører og
	er eid av deg selv:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Som du kan se i dette eksempelet er output fra &man.ps.1; organisert
    i flere kolonner. <literal>PID</literal> er prosess-ID'en forklart tidligere.
    Alle PIDs starter fra 1, går opp til 99999 og går ned til begynnelsen når du
    går tom. <literal>TT</literal> kolonnen viser hvilken tty programmet kjører på
    og kan sees bortifra for øyeblikket. <literal>STAT</literal> viser programmets
    status og kan også ignoreres. <literal>TIME</literal> er hvor lenge programmet
    har kjørt på CPU&mdash;'en. Dette er som regel ikke helt korrekt siden de fleste
    programmer bruker mye tid på å vente på at ting skal skje før de trenger å bruke tid
    på CPU'en.Til sist har vi <literal>COMMAND</literal> som er den faktiske kommandolinjen
    brukt til å kjøre programmet.</para>

	<para>&man.ps.1; supporterer mange forskjellige innstillinger for å forandre
      informasjonen som blir vist.  En av de aller mest brukbare er
      <literal>auxww</literal>.  <option>a</option> viser informasjon
      om alle kjørende prosesser, ikke bare dine egne.  <option>u</option>
      viser brukernavnet til eieren av prosessen samt minnebruk.
      <option>x</option> viser informasjon om daemon-prosesser og
      <option>ww</option> gjør at &man.ps.1; viser den fulle kommandolinjen
      istedetfor å kutte den om den blir for lang til å passe til skjermen.</para>

    <para>Informasjon fra &man.top.1; er ganske lik. Det kan se noe slikt ut:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

	<para>Informasjonen kommer i to seksjoner. De første fem linjene viser
	PID fra siste prosess som kjørte, gjennomsnittet av systembelastning
	(hvor opptatt systemet er), oppetiden til systemet (tid siden siste
	restart) og hva klokka er akkurat nå. De andre tingene i de øverste linjene
	referer til hvor mange prosesser som faktisk kjører (47 i dette eksempelet),
	hvor mye minne og swap som er brukt og hvor mye tid systemet bruker i
	forskjellige CPU-tilstander.</para>

	<para>Under er en serie med kolonner som inneholder liknende informasjon
	som du kan få fra &man.ps.1;. Som før kan du se PID, brukernavn, hvor mye
	CPU tid brukt og kommandoen som ble kjørt. &man.top.1; viser deg også
	hvor mye minne prosessen bruker. Dette er vist i to kolonner, en for total
	plass og en for resident plass&mdash;total plass er hvor mye minne
	applikasjonen har trengt og resident plass er hvor mye den faktisk bruker
	i øyeblikket. I dette eksempelet kan du se at <application>&netscape;</application> har
	spurt etter nesten 30&nbsp;MB RAM, men for øyeblikket bruker 9&nbsp;MB.</para>

    <para>&man.top.1; oppdaterer skjermbildet hvert andre sekund;
      dette kan bli forandret med <option>s</option> innstillingen.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Daemons, Signaler, og Dreping av Prosesser</title>

    <para>Når du starter en editor er det enkelt å kontrollere den, for eksempel
    fortelle den at den skal åpne en fil osv. Du kan gjøre dette fordi editoren
    gir deg en grunnlag å gjøre det på samt at den er koblet til en <firstterm>
    terminal</firstterm>. Noen programmer er ikke designet til å kjøre med
    kontinuerlig brukerinput så de kobler seg fra terminalen med en gang
    de får sjangsen. For eksempel, en webserver responderer til webforespørsler
    hele dagen og trenger normalt ingen hjelp fra deg. Programmer som transporterer
    e-post fra sted til sted er et annet eksempel på en slik applikasjonsklasse.</para>

    <para>Vi kaller disse programmene <firstterm>daemons</firstterm>. Daemons
    var karakterer i gresk mytologi, de var ikke gode og ikke onde men var som
    noen små hjelpere som gjorde ting for menneskeheten nå og da. Akkurat som
    webservere og postservere nå til dags gjør det samme. Det er derfor
    BSD-maskoten har vært en glad daemon med sneakers og høygaffel.</para>

	<para>Det er en konvensjon for å gi navn til programmer som vanligvis kjører
	som daemons med en <quote>d</quote> på slutten. <application>BIND</application> er
	Berkeley Internet Name Daemon (mens det faktiske programmet som kjøres kalles
	<command>named</command>), applikasjonen <application>Apache</application> er
	webserverprogrammet og kalles <command>httpd</command>, linjeprinterspooling
	daemon kalles <command>lpd</command> osv. Dette er en konvensjon, ikke en regel.
	For eksempel, den vanlige mail daemon for <application>Sendmail</application>
	applikasjonen kalles <command>sendmail</command> og ikke <command>maild</command>.</para>

    <para>Noen ganger trenger du å kommunisere med en daemonprosess.
    Disse måtene å kommunisere på kalles <firstterm>signaler</firstterm> og du kan
    kommunisere med en daemon (eller med andre kjørende prosesser) ved å sende den
    et signal. Det er mange forskjellige typer signaler du kan sende&mdash;noen av
    dem har en spesifikk mening mens andre blir lest av applikasjonen og applikasjonens
    dokumentasjon kan fortelle deg hvordan den applikasjonen leser signaler. Du kan bare
    sende et signal til en prosess som du eier. Om du sender et signal til noen
    andres prosess med &man.kill.1; eller &man.kill.2; vil du ikke ha rettigheter
    til å gjøre det. Unntaket til dette er <username>root</username> brukeren som
    kan sende signaler til hvem som helst sine prosesser.</para>

    <para>&os; vil også sende signaler til applikasjoner i noen tilfeller. Hvis
    en applikasjon er dårlig skrevet og prøver å få tilgang til minne den ikke får lov
    til å ha vil &os; sende signalet <firstterm>Segmentation Violation</firstterm>
    til applikasjonen (<literal>SIGSEGV</literal>). Om en applikasjon har brukt
    &man.alarm.3; systemkallet for å bli påminnet etter en viss tid har gått vil
    den sende et Alarmsignal (<literal>SIGALRM</literal>) osv.</para>

	<para>To signaler kan brukes til å stoppe en prosess,
      <literal>SIGTERM</literal> og <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> er den høflige måten å drepe en prosess på;
      processen kan <emphasis>få tak i</emphasis> signalet, finne ut at du ønsker
      å stenge den, lukke eventualle loggfiler den kan ha åpent, og generelt
      avslutte det den holder på med før den stenger ned.  I noen tilfeller
      kan en prosess fullstendig ignorere et <literal>SIGTERM</literal> signal
      om den er i midten av en ting som ikke kan bli stoppet.</para>

    <para><literal>SIGKILL</literal>blir ikke ignorert av en prosess.
    Dette er <quote>Jeg bryr meg ikke om hva du gjør, stopp med en gang</quote>
    signalet. Hvis du sender <literal>SIGKILL</literal> til en prosess, vil
      &os; stoppe prosessen der og da<footnote>
	<para>Dette er ikke helt riktig&mdash;det er en del ting som ikke kan bli forstyrret.
	For eksempel, om prosessen prøver å lese fra ei fil som er på en annen
	maskin på nettverket og den andre maskinen ikke svarer (den har blitt skrudd
	av eller nettverket har feil) så vil prosessen være <quote>uforstyrrbar</quote>.
	Etterhvert vil prosessen gå tom for tid, som regel etter to minutter. Når dette
	skjer vil prosessen bli drept.</para>
      </footnote>.</para>

    <para>Andre signaler du kan bruke inkluderer
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, og
      <literal>SIGUSR2</literal>.  Dette er generelle signaler og
      forskjellige applikasjoner vil gjøre forskjellige ting om de mottar
      disse signalene.</para>

    <para>Si at du har forandret din webservers konfigurasjonsfil&mdash;du vil
    at webserveren skal lese fila på nytt. Du kan stoppe og restarte <command>
    httpd</command>, men dette vil resultere i en kort perdiode hvor webserveren
    din vil være nede. Dette er kanskje ikke hva du vil. De fleste daemons er skrevet
    slik at om de mottar et <literal>SIGHUP</literal> signal så vil de lese sin
    konfigurasjonsfil på nytt. Så istedet for å drepe og restarte <command>httpd</command>
    kan du sende den <literal>SIGHUP</literal> signalet. Fordi det ikke er noen standard
    måte å respondere til disse signalene på kan forskjellige daemons oppføre
    seg forskjellig, så les dokumentasjonen de kommer med så du er helt sikker.</para>

    <para>Signals are sent using the &man.kill.1; command, as this example
      shows.</para>

    <procedure>
      <title>Sende et Signal Til en Prosess</title>

      <para>Dette eksempelet viser hvordan sende et signal til &man.inetd.8;.
	  	 <command>inetd</command> konfigurasjonsfilen er
	  	<filename>/etc/inetd.conf</filename>, og <command>inetd</command> vil lese
	  	denne konfigurasjonsfilen på nytt når
	  	<literal>SIGHUP</literal> blir sendt.</para>

       <step>
	<para>Finn prosessID'en til prosessen du ønsker å sende signalet til.
	Gjør dette ved å bruke &man.ps.1; og &man.grep.1;. &man.grep.1;
	kommandoen blir brukt til å søke gjennom output for en streng du
	spesifiserer. Denne kommandoen blir kjørt som en vanlig bruker og
	&man.inetd.8; er kjørt som <username>root</username>, så <option>ax</option>
	innstillingen må bli gitt til &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Så &man.inetd.8; PID er 198.  I noen tilfeller vil
		  <literal>grep inetd</literal> kommandoen selv også dukke opp i
		  output.  Dette er fordi hvordan &man.ps.1; må finne listen over
		  prosessene som kjøres.</para>
	      </step>

      <step>
	<para>Bruk &man.kill.1; for å sende signalet.  Fordi &man.inetd.8; er
	  kjørt av <username>root</username> må du bruke &man.su.1; først for å
	  bli <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Slik som det er vanlig med de fleste &unix; kommandoer, vil ikke
	&man.kill.1; vise noen informasjon om den lykkes. Hvis du sender et signal til
	en prosess som du ikke eier så vil du se <errorname>kill: <replaceable>PID</replaceable>
	: Operation not permitted</errorname>. Om du skriver PID feil vil du enten
	sende signalet til en gal prosess, noe som kan være ille, eller om du er heldig
	har du sendt signalet til en PID som ikke er i bruk for øyeblikket. Om det skjer
	vil du se <errorname>kill: <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>Hvorfor Bruke <command>/bin/kill</command>?</title>

	  <para>Mange shell har <command>kill</command> kommandoen bygd inn i seg.
	  Shellet vil sende signalet direkte istedet for å kjøre <filename>/bin/kill</filename>.
	  Dette kan være hendig men forskjellige shells har forskjellige syntakser
	  for å spesifisere navnet på signalet som skal sendes. Istedet for å prøve
	  å lære navnene på alle sammen, kan det være enklere å bare bruke
	  <command>/bin/kill <replaceable>...</replaceable></command>
	  kommandoen direkte.</para>
	</note>
      </step>
    </procedure>

    <para>Å sende andre signaler er stort sett det samme, bare bytt ut
    <literal>TERM</literal> eller <literal>KILL</literal> på kommandolinjen
    etter behov.</para>

    <important>
	      <para>Å drepe vilkårlige prosesser på systemet kan være en
	      dårlig ide. For eksempel, &man.init.8; med prosess-ID 1
	      er veldig spesiell. Å kjøre kommandoen
	      <command>/bin/kill -s KILL 1</command> er en kjapp måte
	      å stenge systemet ditt på. <emphasis>Alltid</emphasis>
	      sjekk argumentene du kjører &man.kill.1; med
	      <emphasis>før</emphasis> du trykker <keycap>Enter</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shell</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>command line</primary></indexterm>

	<para>I &os; er mye av hverdagslig arbeid gjort på en kommandolinje
	kalt et shell. Et shell's primære oppgave er å ta kommandoer
	fra input-kanalen og eksekvere dem. Mange shells har innebygde
	funksjoner for å hjelpe deg med typiske oppgaver som filbehandling,
	kommandolinjeeditering, makroer, og miljøvariabler. &os; kommer
	med flere forskjellige shells, slik som <command>sh</command>,
	Bourne Shell, og <command>tcsh</command>, et bedre C-shell. Mange
	andre shells er tilgjengelige fra &os; Portskolleksjonen slik som
	<command>zsh</command> og <command>bash</command>.</para>

    <para>Hvilket shell bruker du? Det er et spørsmål om smak og behag.
    Om du er en C-programmerer er kanskje et C-shell slik som <command>tcsh</command>
    det beste. Om du har kommet fra Linux eller har akkurat begynt å bli kjent
    med &unix; sin kommandolinje er kanskje <command>bash</command> et godt valg.
    Hvert enkelt shell har sine unike innstillinger, og noen av dem passer deg
    kanskje bedre enn andre, så du har en mulighet til å velge hva slags shell
    du ønsker å jobbe med.</para>

    <para>En vanlig ting i et shell er å vise et filnavn automatisk. Ved å
    skrive inn de første to-tre bokstavene i en kommando eller filnavn kan
    shellet automatisk gjøre ferdig resten av kommandoen eller filnavnet
    ved å trykke <keycap>Tab</keycap> på keyboardet. Her er et eksempel.
    Si at du har to filer kalt <filename>foobar</filename> og
    <filename>foo.bar</filename>. Du vil slette <filename>foo.bar</filename>.
    Så hva du kan skrive på keyboardet er: <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>Shellet vil printe <command>rm
	      foo[BEEP].bar</command>.</para>

    <para>[BEEP] er konsollbjellen. Det er shellets måte å fortelle meg
    at det ikke klarte å fullføre hele filnavnet fordi det er mer enn en
    match. Begge <filename>foobar</filename> og <filename>foo.bar</filename>
    starter med <literal>fo</literal>, men shellet klarte å fullføre navnet
    opp til <literal>foo</literal>. Hvis du skriver <literal>.</literal> og
    så trykker <keycap>Tab</keycap> igjen vil shellet klare å fylle inn resten
    av filnavnet for deg. </para>
    <indexterm><primary>environment variables</primary></indexterm>

    <para>En annen ting shells har er bruken av miljøvariabler.
    Miljøvariabler er variabler som blir lagret i shellets miljøplass.
    Denne plassen kan bli lest av hvilket som helst program som blir startet
    av shellet og kan derfor inneholde mye programkonfigurasjon. Her
    er en liste over vanlige miljøvariabler og hva de betyr:</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variabel</entry>
	    <entry>Forklaring</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Innlogget bruker's navn.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
		<entry>Kolonseparert liste over kataloger som kan søkes for
		binærfiler.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Nettverksnavn som skjermbildet fra X11 kan koble seg til
	    , om det finnes.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Shellet som kjører for øyeblikket.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Navnet på brukeren's terminal. Brukt til å finne ut
	    hva terminalen kan gjøre.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Database over terminal escape koder for å gjøre
	    forskjellige typer terminalfunksjoner.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Hva slags operativsystem, f.eks &os;.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Hva slags arkitektur systemet kjører på.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Hva slags editor brukeren vil ha.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Hva slags tekst-pager brukeren vil ha.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Kolonseparert liste over kataloger som kan søkes
	    igjennom for manualsider.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Å sette en miljøvariabel varierer fra shell til shell.
	      For eksempel, i C-baserte shells slik som
	      <command>tcsh</command> og <command>csh</command>, vil du bruke
	      <command>setenv</command> for å sette miljøvariabler.
	      I Bourne shells slik som <command>sh</command> og
	      <command>bash</command> vil du bruke
	      <command>export</command> for å sette dem.
	      For eksempel, å sette eller modifisere
	      <envar>EDITOR</envar> miljøvariabelen under <command>csh</command> eller
	      <command>tcsh</command> til
	      <filename>/usr/local/bin/emacs</filename> vil se slik ut:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Under Bourne shells vil det se slik ut istedet:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Du kan også få de fleste shells til å ekspandere en miljøvariabel ved
    å sette en <literal>$</literal> foran variabelen på kommandolinjen. For eksempel,
    <command>echo $TERM</command> vil printe ut hva <envar>$TERM</envar> inneholder
    fordi shellet ekspanderer <envar>$TERM</envar> og gir den til <command>echo</command> kommandoen.</para>

    <para>Shellet har mange spesielle tegn, kalt metategn som representerer
    spesielle typer data. Den mest vanlige av disse tegnene er <literal>*</literal>
    tegnet. Dette tegnet representerer hvilket som helst nummer av tegn i et
    filnavn. For eksempel, å skrive <command>echo *</command> er nesten det samme
    som å skrive <command>ls</command> fordi shellet tar alle filene som matcher
    <literal>*</literal> og putter dem på kommandolinjen slik at <command>echo</command>
    kan lese dem. </para>

    <para>For å hindre at shellet skal behandle disse spesielle tegnene som
    metategn kan man putte et backslash (<literal>\</literal>)-tegn foran.
    <command>echo $TERM</command> printer hva terminalen din er satt til, mens
    <command>echo \$TERM</command> printer <envar>$TERM</envar> akkurat som skrevet.</para>

    <sect2 id="changing-shells">
      <title>Å Forandre Shell</title>

      <para>Den enkleste måten å forandre et shell på er å bruke kommandoen
      <command>chsh</command>. Kjører du <command>chsh</command> vil den
      plassere deg inne i editoren du har satt i <envar>EDITOR</envar>
      miljøvariabelen. Om denne variabelen ikke er satt, vil du bli plassert
      i <command>vi</command>. Her kan du forandre <quote>Shell:</quote>
      linjen til hva du ønsker.</para>

	<para>Du kan også gi <command>chsh</command> innstillingen
	<option>-s</option>. Dette vil sette shellet for deg direkte, uten at
	du trenger å gå inn i editoren. For eksempel, om du ønsker å sette shellet
	ditt til <command>bash</command> bør følgende gjøre susen:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Å kjøre <command>chsh</command> uten parametre og editere shellet derfra
      fungerer like bra.</para>

      <note>
	<para>Shellet som du ønsker å bruke <emphasis>må</emphasis> befinne
	seg i <filename>/etc/shells</filename> filen. Om du har installert
	et shelkl fra <link linkend="ports">portskolleksjonen</link> bør
	dette ha blitt gjort for deg allerede. Om du har installert et shell
	for hånd, må du gjøre dette.</para>

      <para>For eksempel, om du installerte <command>bash</command> for hånd
	og plasserte det i <filename>/usr/local/bin</filename>, trenger du å gjøre
	følgende:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Deretter kjøre <command>chsh</command> en gang.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Teksteditorer</title>
    <indexterm><primary>text editors</primary></indexterm>
    <indexterm><primary>editors</primary></indexterm>

    <para>Mye av konfigureringsarbeid i &os; blir gjort ved å editere
    tekstfiler. På grunn av dette vil det være en god ide å sette seg inn
    i hvordan en tekstedit fungerer. &os; kommer med et par som en del
    av basissystemet og mange andre er tilgjengelige i portskolleksjonen.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>Den enkleste editoren du kan lære deg er en editor kalt <application>ee</application>
    som står for easy editor. For å starte <application>ee</application>, skriv
    <command>ee <replaceable>filnavn</replaceable></command> på kommandolinjen, og hvor
    <replaceable>filnavn</replaceable> er navnet på filen du vil editere.
    For eksempel, for å editere <filename>/etc/rc.conf</filename> skriver
    du <command>ee /etc/rc.conf</command>. Når du så er inne i <command>ee</command>
    er alle kommandoene for å manipulere editorens funksjoner listet på toppen
    av skjermen. Tegnet <literal>^</literal> representerer <keycap>Ctrl</keycap> på
    keyboardet, så <literal>^e</literal> ekspanderer til tastekombinasjonen
    <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>. For
    å gå ut av <application>ee</application> trykker du <keycap>Esc</keycap>-tasten og velg
    leave editor. Editoren vil spørre om du vil lagre endringer om filen har blitt
    modifisert.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>&os; kommer også med andre kraftigere teksteditorer slik som
    <application>vi</application> som en del av basissystemet, mens andre editorer slik som
    <application>Emacs</application> og <application>vim</application> er en del
    av &os; portskolleksjonen (<filename role="package">editors/emacs</filename> og <filename role="package">editors/vim</filename>).
    Disse editorene har mye mer funksjonalitet og er mye kraftigere, men kan ta lengre
    tid å lære. Om du planlegger å gjøre mye tekstbehandling er det en god ide
    å lære seg en kraftigere editor slik som <application>vim</application> eller
    <application>Emacs</application>. Dette vil spare deg tid i det lange løp.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Komponenter og Komponentnoder</title>

	<para>En komponent er en terminologi som blir brukt for det meste
	om hardware-relaterte ting på systemet slik som disker, printere,
	grafikkort og keyboards. Når &os; starter opp vil majoriteten
	av hva &os; viser på skjermen være komponenter som blir funnet.
	Du kan se gjennom oppstartsbeskjedene igjen ved å lese
	<filename>/var/run/dmesg.boot</filename>.</para>

	<para>For eksempel, <devicename>acd0</devicename> er det
      første IDE CDROM drevet, mens <devicename>kbd0</devicename>
      er keyboardet.</para>

    <para>De fleste av disse komponentene i et &unix; operativsystem
    kan bare bli brukt gjennom spesielle filer kalt komponentnoder. Disse
    finnes i <filename>/dev</filename>-katalogen.</para>

    <sect2>
      <title>Opprettelse av Komponentnoder</title>
      <para>Når du legger til en ny komponent i systemet ditt
      eller kompilerer inn support for nye komponenter må du
      kanskje lage en eller flere komponentnoder for de nye komponentene.</para>

      <sect3>
	<title>MAKEDEV-skriptet</title>
	<para>På systemer uten <literal>DEVFS</literal> (alle versjoner av &os; før 5.0) blir komponentnoder
	laget bed å bruke &man.MAKEDEV.8; skriptet, som vist under:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

	<para>Dette eksempelet vil lage komponentnoder for det andre
	IDE-drevet.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System)</title>

	<para>Komponentfilsystemet (device file system) eller <literal>DEVFS</literal> gjør
	tilgjengelig kjernens komponentnavneplass i den globale filsystemnavneplassen.
	Hva dette betyr er at istedet for å måtte lage og modifisere komponentnoder manuelt
	vil <literal>DEVFS</literal> holde orden på dette filsystemet for deg.</para>

	<para>Se &man.devfs.5; manualsiden for mer
	  informasjon.</para>

	<para><literal>DEVFS</literal> blir brukt som standard i &os;&nbsp;5.0 og oppover.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Binære Formater</title>

    <para>For å forstå hvorfor &os; bruker &man.elf.5; formatet må
    du først vite litt om de tre eksekverbare formatene som dominerer
    i &unix;:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>Det eldste og mest <quote>klassiske</quote> &unix;
        objektformatet. Det bruker en kort og kompakt "header" med et
        magisk nummer på begynnelsen som ofte blir brukt til å
        karakterisere formatet (se &man.a.out.5; for mer informasjon).
        Det inneholder tre segmenter: .tekst, .data og .bss pluss
        en symboltabell og en strengtabell.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>SVR3 objektformatet. "Headeren" består nå av en seksjonstabell,
        så du kan ha mer enn bare .tekst, .data og .bss seksjoner.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Det som tok over for <acronym>COFF</acronym>.
        &man.elf.5; har flere seksjoner og 32-bit eller 64-bit mulige
        verdier. En stor ulempe: <acronym>ELF</acronym> var også designet
        med det i minnet at det ville bare finnes en ABI per
        systemarkitektur. Dette er ikke lenger korrekt og ikke en gang
        i den kommersielle SYSV-verdenen (som har minst tre ABIs: SVR4,
        Solaris, SCO) er dette sant lengre.</para>

        <para>&os; prøver å jobbe seg rundt dette problemet ved
        å inneholde et program for å definere en <acronym>ELF</acronym>
        eksekverbar fil med informasjon om hvilken ABI den støtter, kalt
        <emphasis>branding</emphasis>. Se manualsiden for
        &man.brandelf.1; for mer informasjon.</para>
      </listitem>
    </itemizedlist>

    <para>&os; kommer fra det <quote>klassiske</quote> depotet og brukte
    &man.a.out.5; formatet, en teknologi som er velbrukt og testet gjennom
    mange generasjoner av BSD, helt til begynnelsen av 3.X treet. Det var
    likevel mulighet for å bygge og kjøre <acronym>ELF</acronym> binærfiler
    (og kernels) på et &os;-system en god stund før det. I første omgang
    var ikke &os; villige til å bytte til <acronym>ELF</acronym> som det
    standard formatet. Hvorfor? Vel, når Linux omstilte seg til <acronym>ELF</acronym>
    var det ikke så mye å komme seg vekk fra <filename>a.out</filename> formatet
    men heller det at det var deres ufleksible tabellbaserte delte bibliotek-
    mekanisme. Dette gjorde at konstruksjonen av delte biblioteker ble veldig
    vanskelig for selskaper og programmerere. Siden <acronym>ELF</acronym>
    verktøy hadde en løsning på delte bibliotekproblemer og ble generelt
    sett på som <quote>veien videre</quote> ble migrasjonskostnadene
    akseptert som nødvendig og migreringen var et faktum. &os; sin
    delte bibliotekmekanisme er basert tettere på Sun's &sunos; type
    delte bibliotekmekanisme og er derfor enkel å bruke.</para>

    <para>Så, hvorfor er det så mange forskjellige formater?</para>

    <para>I den mørke fortid var det simple komponenter. Disse simple
    komponentene supporterte et simpelt lite system. <filename>a.out</filename>
    var helt greit for jobben å representere binærfiler på dette simple
    systemet (en PDP-11). Etterhvert som folk portet &unix; fra dette
    simple systemet beholdt dem <filename>a.out</filename> formatet fordi
    det var godt nok for tidlige ports av &unix; til arkitekturer som
    f.eks Motorola 68k, VAXen, osv.</para>

    <para>Men så kom en smart komponentingeniør på at hvis han kunne
    tvinge software til å gjøre noen ekle triks, hadde han mulighet til
    å barbere av litt design og derfor gi muligheten for CPU'en å kjøre
    litt raskere. Selv om det ble lagd for å virke sammen med denne nye
    typen komponenter (kjent i disse dager som <acronym>RISC</acronym>),
    var <filename>a.out</filename> ikke egnet for denne typen komponenter
    så mange formater ble laget for å få en bedre ytelse fra dem. Ting
    som <acronym>COFF</acronym>, <acronym>ECOFF</acronym> og et par andre
    mer obskure formater ble laget og deres limitasjoner ble utforsket
    før man slo seg til ro med <acronym>ELF</acronym>.</para>

    <para>I tillegg begynte programstørrelser å bli store og disker
    (og fysisk minne) var fremdeles rimelig små så konseptet med et
    delt bibliotek var født. VM systemet ble også mer komplisert
    etterhvert. Selv om hvert av disse fremskrittene ble gjort ved
    å bruke <filename>a.out</filename> formatet, var dets brukbarhet
    strukket mer og mer hver gang en ny funksjon ble lagt til. I
    tillegg ønsket folk å kunne dynamisk laste inn ting når
    et program ble kjørt eller å kutte av deler av programmet
    etter at init-koden hadde kjørt for å spare minne og swap-plass.
    Språk ble mer sofistikerte og folk ville ha kode som ble kalt
    før primærkode automatisk. Masse såkalte "hacks" ble lagt til
    <filename>a.out</filename> formatet for å tillate alle disse
    tingene å fungere og de virket også en stund. Men det viste
    seg snart at <filename>a.out</filename> ikke var godt nok for
    å håndtere jobben, det kunne ikke ta seg av alle disse problemene uten at
    det ble mer komplisert og mer overhead. Selv om <acronym>ELF</acronym>
    løste mange problemer ville det bli vanskelig å gå vekk fra et
    system som generelt fungerte. Så <acronym>ELF</acronym> måtte vente
    til det var enda værre å ha <filename>a.out</filename> enn å måtte
    migrere til <acronym>ELF</acronym>.</para>

    <para>Etterhvert som tiden gikk begynte byggingsverktøyene som
    &os; arvet deres byggingsverktøy fra (spesielt assembler
    og loader) å utvikle seg i to paralelle retninger.
    &os;-treet la til delte biblioteker og fikset en del bugs.
    GNU-folka som originalt skrev disse programmene skrev dem om
    og la til enklere support for bygging av kompilatorer som kan
    gå på tvers av formater osv. Mange folk ville bygge disse
    typer kompilatorer for &os;, men støtte på en hindring
    siden de gamle kildene som &os; hadde for <application>as</application>
    og <application>ld</application> ikke klarte å håndtere noe slikt.
    De nye GNU-verktøyene (<application>binutils</application>) supporterer
    slike typer kompilatorer, <acronym>ELF</acronym>, delte biblioteker,
    C++ kompilering, osv. I tillegg slipper mange selskaper
    <acronym>ELF</acronym> binærfiler så det er en god ting at
    &os; kan kjøre dem.</para>

    <para><acronym>ELF</acronym> er mer ekspressivt enn <filename>a.out</filename> og
    gjør at basesystemet kan utvides lettere. <acronym>ELF</acronym> verktøyene
    er bedre opprettholdt og fornyet, tverskompilatorer er supportert, noe
    som er viktig for mange folk. <acronym>ELF</acronym> er muligens litt
    tregere enn <filename>a.out</filename>, men å teste det
    kan være vanskelig. Det er mange detaljer som er forskjellig
    mellom de to iht hvordan de håndterer initkode, mapper sider, osv.
    Ingen av disse er veldig viktige men forskjellene er der. Over tid vil
    support for <filename>a.out</filename> bli flyttet ut av
    <filename>GENERIC</filename> kjernen og til slutt bli fjernet helt.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>For Mer Informasjon</title>

    <sect2 id="basics-man">
      <title>Manualsider</title>
      <indexterm><primary>manual pages</primary></indexterm>

      <para>Den mest komplette dokumentasjonen av &os; finnes i manualsidene.
      Nesten alle programmer på systemet kommer med en liten referansemanual
      som forteller deg hva programmet gjør og hvilke innstillinger du kan gi det.
      Disse manualene kan bli lest med kommandoen <command>man</command>.
      Bruken av <command>man</command> er enkelt:</para>

      <screen>&prompt.user; <userinput>man <replaceable>kommando</replaceable></userinput></screen>

      <para><literal>kommando</literal> er navnet på kommandoen
      du ønsker å lære noe som. For eksempel, å lære mer om
      <command>ls</command> kommandoen, skriv:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Onlinemanualen er delt opp i nummererte seksjoner:</para>

	  <orderedlist>
	<listitem>
	  <para>Brukerkommandoer.</para>
	</listitem>

	<listitem>
	  <para>Systemkall og feilnumre.</para>
	</listitem>

	<listitem>
	  <para>Funksjoner i C-bibliotekene.</para>
	</listitem>

	<listitem>
	  <para>Komponentdrivere.</para>
	</listitem>

	<listitem>
	  <para>Filformater.</para>
	</listitem>

	<listitem>
	  <para>Spill.</para>
	</listitem>

	<listitem>
	  <para>Forskjellige typer informasjon.</para>
	</listitem>

	<listitem>
	  <para>Systemopprettholdelse og operasjonelle kommandoer.</para>
	</listitem>

	<listitem>
	  <para>Kernelutviklere.</para>
	</listitem>
      </orderedlist>

    <para>I noen tilfeller kan det samme subjektet dukke opp i mer enn
    en seksjon av manualen. For eksempel, det er en <command>chmod</command>
    brukerkommando og et <function>chmod()</function> systemkall.
    I dette tilfellet kan du fortelle <command>man</command> kommandoen
    hvilken av disse du vil ha ved å spesifisere seksjonen:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dette vil vise manualsiden for brukerkommandoen
      <command>chmod</command>. Referanser til en spesiell seksjon
      av manualen er tradisjonelt plassert i parantes i dokumentasjonen,
      så &man.chmod.1; refererer til <command>chmod</command> brukerkommandoen
      og &man.chmod.2; refererer til systemkallet.</para>

	<para>Dette er greit nok hvis du vet navnet på kommandoen og vil bare
	vite hvordan du kan bruke den. Men hva om du ikke husker kommandonavnet?
	Du kan bruke <command>man</command> for a søke for stikkord i kommandooversikten
	ved å bruke <option>-k</option> innstillingen:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Med denne kommandoen vil du bli presentert med en liste
      av kommandoer som har stikkordet <quote>mail</quote> i deres
      forklaringer. Dette er akkurat det samme som å bruke
      <command>apropos</command> kommandoen.</para>

      <para>Så du kikker på alle disse fancy kommandoene i
      <filename>/usr/bin</filename> men har ingen anelse hva
      mesteparten av dem gjør? Prøv:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>eller</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>som gjør den samme tingen.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Infofiler</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>&os; inneholder mange applikasjoner og programmer
      produsert av Free Software Foundation (FSF). I tillegg til
      manualsider kommer disse programmene med mer ekstensive hypertekstdokumenter
      kalt <literal>info</literal> filer som kan leses med
      <command>info</command> kommandoen eller om du installerte
      <application>emacs</application>, infomodusen til
      nevnte applikasjon.</para>

      <para>For å bruke &man.info.1; kommandoen, skriv følgende:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>For en liten introduksjon, skriv <literal>h</literal>.
      For en rask kommandoreferanse, skriv <literal>?</literal>.</para>
     </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->


