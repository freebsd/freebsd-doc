<!--
     The FreeBSD Documentation Project

     The FreeBSD Spanish Documentation Project

     %SOURCE% en_US.ISO8859-1/books/handbook/kernelconfig/chapter.sgml
     %SRCID%    1.186


     $FreeBSD$
     $FreeBSDes: doc/es_ES.ISO8859-1/books/handbook/kernelconfig/chapter.sgml,v 1.2 2004/10/08 22:14:25 jesusr Exp $
-->

<chapter id="kernelconfig">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Actualizado y reestructurado por </contrib>
	<!-- Mar 2000 -->
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jake</firstname>
	<surname>Hamby</surname>
	<contrib>Texto original por </contrib>
	<!-- 6 Oct 1995 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configuraci&oacute;n del kernel de &os;</title>

  <sect1>
    <title>Sinopsis</title>

    <indexterm>
      <primary>kernel</primary>
      <secondary>Compilar un kernel a medida</secondary>
    </indexterm>

    <para>El kernel de &os; es el coraz&oacute;n del sistema
      operativo.  Es el responsable de la gesti&oacute;n y control de la 
      memoria, reforzamiento de los controles de seguridad, gesti&oacute;n 
      de redes, acceso a dispositivos y muchas cosas m&aacute;s.  &os; 
      es un sistema din&aacute;mico y configurable, pero a veces 
      sigue siendo necesario reconfigurar y recompilar
      un kernel hecho a la medida de nuestras necesidades.</para>

    <para>Una vez leido este cap&iacute;tulo sabr&aacute; usted:</para>

    <itemizedlist>
      <listitem>
	<para>Por qu&eacute; puede ser necesario que compile un kernel 
	  personalizado.</para>
      </listitem>

      <listitem>
	<para>C&oacute;mo crear un fichero de configuraci&oacute;n del kernel, 
	  o bien editar un fichero existente.</para>
      </listitem>

      <listitem>
	<para>C&oacute;mo utilizar el fichero de configuraci&oacute;n 
	  para crear 
	  y compilar un nuevo kernel.</para>
      </listitem>

      <listitem>
	<para>C&oacute;mo instalar su nuevo kernel.</para>
      </listitem>

      <listitem>
	<para>C&oacute;mo resolver algunos problemas si algo sale mal.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>&iquest;Qu&eacute; razones hay para compilar un kernel personalizado?</title>

    <para>Tradicionalmente &os; ha contado con lo que se conoce como
      un kernel <quote>monol&iacute;tico</quote>.  Esto quiere decir que
      el kernel era un gran y &uacute;nico programa que se comunicaba con una lista
      previa de dispositivos, y que si se deseaba modificar el comportamiento
      del kernel se deb&iacute;a compilar un nuevo kernel y reiniciar el sistema
      con el nuevo kernel.</para>

    <para>Hoy en d&iacute;a &os; evoluciona muy r&aacute;pidamente
      hacia un modelo donde la funcionalidad del kernel se
      basa en m&oacute;dulos, los cuales pueden cargarse y
      descargarse din&aacute;micamente de acuerdo a las necesidades del
      kernel. Esto permite al kernel adaptarse al nuevo hardware que
      sale al mercado (como las tarjetas PCMCIA en sistemas
      port&aacute;tiles), o bien
      a&ntilde;adir nuevas funcionalidades al kernel que no eran
      al compilarlo la vez anterior.  Esto es lo que conocemos como
      kernel modular.</para>
      
    <para>A pesar de lo dicho a&uacute;n es necesario llevar a cabo cierta
      configuraci&oacute;n est&aacute;tica en la configuraci&oacute;n
      del kernel.  A veces se debe a que la funcionalidad del
      sistema est&aacute; tan ligada al kernel que no puede hacerse
      mediante carga din&aacute;mica de m&oacute;dulos.  En otros casos puede
      tratarse simplemente de que nadie ha programado un m&oacute;dulo
      para esa funcionalidad concreta que pueda cargarse
      din&aacute;micamente en el kernel.</para>

    <para>Compilar un kernel personalizado es uno de los ritos de
      iniciaci&oacute;n m&aacute;s importantes a los que los usuarios de
      casi todos los BSD han de enfrentarse.  Este proceso lleva su
      tiempo, pero le aportar&aacute; grandes beneficios a su
      sistema &os;.  A diferencia del kernel
      <filename>GENERIC</filename>, con el que puede funcionar una cantidad
      apabullante de hardware disponible en el mercado, un kernel personalizado
      contiene &uacute;nicamente lo necesario para que funcione el hardware de
      <emphasis>su</emphasis> sistema.  Obviamente esto tiene sus
      ventajas:</para>
    
    <itemizedlist>
      <listitem>
	<para>Mayor rapidez en el arranque del sistema.  Dado que el
	  kernel s&oacute;lo tiene que probar el hardware que realmente est&aacute;
	  en el sistema el tiempo que necesitar&aacute; para arrancar se
	  reducir&aacute; visiblemente.</para>
      </listitem>

      <listitem>
	<para>Menor uso de memoria.  Generalmente un kernel personalizado
	  utiliza menos memoria que un kernel
	  <literal>GENERIC</literal>,  lo cual es importante ya que el
	  kernel debe encontrarse siempre en memoria real.  Por &eacute;sta
	  raz&oacute;n un kernel personalizado puede ser de gran utilidad
	  en sistemas con una cantidad limitada de memoria RAM.</para>
      </listitem>

      <listitem>
	<para>Hacer funcionar hardware espec&iacute;fico.  Un kernel personalizado
	  le permite a&ntilde;adir al sistema dispositivos como tarjetas de sonido,
	  que no est&aacute;n incluidas en el kernel <literal>GENERIC</literal>.
	  </para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="kernelconfig-devices">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Inventario de hardware del sistema</title>
    
    <para>Antes de aventurarnos en la configuraci&oacute;n del kernel
      nunca est&aacute; de m&aacute;s disponer de un inventario
      completo del hardware que hay en
      la m&aacute;quina.  En los casos en los que &os; no es el
      sistema operativo principal de la m&aacute;quina puede
      conseguir el inventario consultando la configuraci&oacute;n
      de otro sistema operativo.  Por ejemplo, el
      <application>Gestor de dispositivos</application> de &microsoft;
      suele contener informaci&oacute;n importante sobre los
      dispositivos que haya en la m&aacute;quina.  El
      <application>Gestor de dispositivos</application> est&aacute;
      en el panel de control.</para>

    <note>
      <para>Algunas versiones de &microsoft.windows; tienen un icono
	de <application>Sistema</application> con forma de pantalla
	desde el que se puede acceder al <application>Gestor de
	dispositivos</application>.</para>
    </note>

    <para>Si no hay otro sistema operativo en la m&aacute;quina el
      administrador tendr&aacute; que conseguir la informaci&oacute;n
      por su cuenta.  Una forma de hacerlo es mediante &man.dmesg.8; y
      &man.man.1;.  La mayor&iacute;a de los controladores de dispositivo
      que hay en &os; tienen una p&aacute;gina de manual, que suele
      incluir una lista del hardware que puede hacer funcionar.  En
      la prueba del sistema durante el arranque va apareciendo una
      lista del harware que hay en la m&aacute;quina.  Por ejemplo,
      las siguientes l&iacute;neas indican que el controlador
      <devicename>psm</devicename> ha encontrado un rat&oacute;n:</para>

    <programlisting>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: [GIANT-LOCKED]
psm0: [ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</programlisting>

    <para>Puede a&ntilde;adir este controlador al fichero de
      configuraci&oacute;n de su kernel personalizado o cargarlo
      utilizando &man.loader.conf.5;.</para>

    <para>A veces los datos que muestra <command>dmesg</command>
      solamente muestran mensajes del sistema en lugar de la
      salida de la prueba de arranque.  En esos casos puede
      ver la verdadera salida de <command>dmesg</command> en el
      fichero <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Otro m&eacute;todo para identificar el hardware del sistema
      es usar &man.pciconf.8;, que tiene una salida mucho m&aacute;s
      verbosa.  Veamos un ejemplo:</para>

    <programlisting>ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
    vendor     = 'Atheros Communications Inc.'
    device     = 'AR5212 Atheros AR5212 802.11abg wireless'
    class      = network
    subclass   = ethernet</programlisting>

    <para>Este fragmento, obtenido con
      <command>pciconf <option>-lv</option></command> muestra c&oacute;mo
      el controlador <devicename>ath</devicename> ha encontrado un
      dispositivo Ethernet inal&aacute;mbrico.  Escriba
      <command>man <replaceable>ath</replaceable></command> para
      consultar la p&aacute;gina de manual de &man.ath.4;.</para>

    <para>La opci&oacute;n <option>-k</option> de &man.man.1; le
      suministrar&aacute; valiosa informaci&oacute;n.  Sigamos
      con el ejemplo anterior:</para>

    <screen>&prompt.root; man -k <replaceable>Atheros</replaceable></screen>

    <para>Con esto obtendremos una lista de p&aacute;ginas de manual que
      contienen esa palabra en particular:</para>

    <programlisting>ath(4)                   - Atheros IEEE 802.11 wireless network driver
ath_hal(4)               - Atheros Hardware Access Layer (HAL)</programlisting>

    <para>Una vez que tenemos nuestra flamante lista de hardware del sistema
      el proceso de compilar un kernel personalizado deber&iacute;a parecer
      un poco menos inquietante.</para>
  </sect1>


  <sect1 id="kernelconfig-modules">
    <title>Controladores del kernel, subsistemas y m&oacute;dulos</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>drivers / modules / subsystems</secondary>
    </indexterm>

    <para>Antes de compilar un kernel personalizado conviene
      pensar antes los motivos.  Si lo que se necesita es
      a&ntilde;adir hardware espec&iacute;fico al sistema es
      posible que sea posible utilizarlo mediante un
      m&oacute;dulo.</para>

    <para>Los m&oacute;dulos del kernel est&aacute;n en el directorio
      <filename class="directory">/boot/kernel</filename> y se
      pueden cargar din&aacute;micamente en un kernel en funcionamiento
      con &man.kldload.8;.  La mayor&iacute;a, por no decir todos, los
      controladores del kernel tienen un m&oacute;dulo espec&iacute;fico
      y una p&aacute;gina de manual.  Por ejemplo, en la secci&oacute;n
      anterior habl&aacute;bamos del controlador Ethernet inal&aacute;mbrico
      <devicename>ath</devicename>.  La p&aacute;gina de manual
      de este dispositivo contiene la siguiente
      informaci&oacute;n:</para>

    <programlisting>Alternatively, to load the driver as a module at boot time, place the
     following line in &man.loader.conf.5:

           if_ath_load="YES"</programlisting>

    <para>Si hace lo que dice ah&iacute;, es decir, a&ntilde;adir
      la l&iacute;nea <literal>if_ath_load="YES"</literal> al fichero
      <filename>/boot/loader.conf</filename> har&aacute; que el
      m&oacute;dulo se cargue din&aacute;micamente cada vez
      que el sistema arranque.</para>

    <para>Hay casos, no obstante, en los que no existe el m&oacute;dulo
      correspondiente.  Esto sucede con ciertos subsistemas y con
      controladores muy importantes, como por ejemplo el de
      <acronym>FFS</acronym>, que necesita el kernel.  Igual sucede con
      la posibilidad de utilizar redes (INET).  Por desgracia, en estos
      casos la &uacute;nica forma de saber si hace falta un controlador
      es buscar el m&oacute;dulo.</para>

    <warning>
      <para>Es sumamente f&aacute;cil quitar un dispositivo o una
        opci&oacute;n del kernel y encontrarse de manos a boca con
	un kernel que no funciona.  Por ejemplo, si elimina el
        controlador &man.ata.4; del fichero de configuraci&oacute;n
	del kernel un sistema que utilice unidades de disco
        <acronym>ATA</acronym> no podr&aacute; arrancar a menos que
	se a&ntilde;ada la l&iacute;nea correspondiente al fichero
        <filename>loader.conf</filename>.  Si tiene dudas busque el
	m&oacute;dulo y deje el kernel como est&aacute;.</para>
    </warning>
  </sect1>

  <sect1 id="kernelconfig-building">
    <title>Compilaci&oacute;n e instalaci&oacute;n de un kernel personalizado</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>compilaci&oacute;n / instalaci&oacute;n</secondary>
    </indexterm>

    <para>En primer lugar, hagamos un breve recorrido por el directorio
      donde se lleva a cabo la compilaci&oacute;n del kernel.  Todos los
      directorios mencionados hacen referencia al directorio principal,
      que es <filename>/usr/src/sys</filename>, al que tambi&eacute;n
      podemos acceder desde <filename>/sys</filename>.  Existen gran
      cantidad de subdirectorios que representan diferentes partes del
      kernel, pero el m&aacute;s importante para lo que deseamos hacer son
      <filename><replaceable>arch</replaceable></filename> y
      <filename>/conf</filename>, que es donde se llevara a cabo la
      edici&oacute;n del fichero de configuraci&oacute;n y la
      compilaci&oacute;n propiamente dicha del mismo,
      el punto de partida para la personalizaci&oacute;n del kernel. El
      directorio <filename><replaceable>arch</replaceable></filename>
      representa la arquitectura del sistema, por lo que puede ser
      <filename>i386</filename>, <filename>alpha</filename>,
      <filename>amd64</filename>, <filename>ia64</filename>,
      <filename>powerpc</filename>, <filename>sparc64</filename> o
      <filename>pc98</filename> (una arquitectura alternativa, similar a PC
      y muy popular en Jap&oacute;n).  Todo lo que existe dentro de un
      directorio de una arquitectura en particular, es espec&iacute;fico
      para dicha arquitectura; el resto del c&oacute;digo es com&uacute;n
      para todas las plataformas en las que &os; puede funcionar.  
      Observe la organizaci&oacute;n l&oacute;gica de la estructura
      de los directorios, con cada dispositivo utilizable en el sistema,
      sistema de ficheros y opciones, cada cosa en su propio
      subdirectorio.</para>
      
    <para>A lo largo de este cap&iacute;tulo asumiremos que est&aacute;
       utilizando la arquitectura i386, puesto que sobre ella son los
       ejemplos que vamos a ir exponiendo.  Si no es este su caso debe
       hacer los cambios adecuados a su arquitectura de hardware en las
       rutas que vayamos utilizando.</para>


    <note>
      <para>Si <emphasis>no existe</emphasis> el directorio
        <filename>/usr/src/sys</filename> en su sistema quiere
        decir que no est&aacute;n instaladas las fuentes del
	kernel.  La forma m&aacute;s sencilla de tenerlas es
        mediante <command>/stand/sysinstall</command>.  Como
        usuario <username>root</username> seleccione
        <literal>Configure</literal>, luego
        <literal>Distributions</literal>, despu&eacute;s
        <literal>src</literal> y finalmente <literal>sys</literal>.  
        Si no le gusta mucho
        <application>sysinstall</application> y tiene acceso a un
        CDROM <quote>oficial</quote> de &os; puede
        instalar las fuentes por medio de la siguiente l&iacute;nea
        de &oacute;rdenes:</para>

      <screen>&prompt.root; <userinput>mount</userinput> /cdrom
&prompt.root; <userinput>mkdir -p</userinput> <filename>/usr/src/sys</filename>
&prompt.root; <userinput>ln -s</userinput> /usr/src/sys /sys
&prompt.root; <userinput>cat /cdrom/sys/ssys.[a-d]* | tar -xzvf</userinput></screen>
    </note>

    <para>Ahora vaya al al directorio
      <filename><replaceable>arch</replaceable>/conf</filename>
      y copie el fichero de configuraci&oacute;n <filename>GENERIC</filename>
      con el nombre que desee.  Por ejemplo:</para>

    <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>cp GENERIC MIKERNEL</userinput></screen>

    <para>Por tradici&oacute;n el nombre se escribe con may&uacute;suculas y
      si tiene varias maquinas &os, con diferente hardware es recomendable
      darle a cada kernel el mismo nombre que la m&aacute;quina en la que va
      a ejecutarse.  En este ejemplo usaremos el nombre de
      <filename>MIKERNEL</filename> .</para>
      
    <tip>
      <para>Guardar su fichero de configuraci&oacute;n directamente bajo
        el directorio <filename>/usr/src</filename>, puede que no sea una
        idea muy astuta.  Si empieza a tener problemas puede ser muy tentador
        borrar <filename>/usr/src</filename> y comenzar desde cero.  
        Cinco segundos despu&eacute;s de haber hecho esto se dar&aacute;
        cuenta de que ha eliminado el fichero de configuraci&oacute;n de
        su kernel, en el que quiz&aacute;s llevaba horas trabajando.</para>
      
      <para>Le proponemos una alternativa: guardar su fichero de configuraci&oacute;n
        cualquier otro sitio y crear un enlace simb&oacute;lico al fichero
        que hay en el directorio <filename>i386</filename>.</para>

      <para>Por ejemplo:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/<replaceable>MIKERNEL</replaceable></userinput>	
&prompt.root; <userinput>ln -s /root/kernels/<replaceable>MIKERNEL</replaceable></userinput></screen>
    </tip>


    <para>Ahora edite el fichero de configuraci&oacute;n
      <filename>MIKERNEL</filename> con su editor de textos favorito.  
      Si se trata de una instalaci&oacute;n reciente probablemente el
      &uacute;nico editor disponible sea <application>vi</application>,
      del cual es complicado explicar su uso detallado en este
      documento, pero existen bastantes libros que detallan su uso; puede
      ver algunos en la <link
      linkend="bibliography">bibliograf&iacute;a</link>.  
      &os; dispone de un editor de uso muy sencillo, llamado
      <application>ee</application>; si es usted principiante le ser&aacute;
      de mucha ayuda.  Cambie los comentarios al principio del fichero
      con algo que refleje los cambios realizados o al menos para
      diferenciarlo del fichero <filename>GENERIC</filename>.</para>
      
    <para>Si ha compilado un kernel en &sunos; o alg&uacute;n otro sistema operativo
      BSD seguramente la mayor parte de fichero le ser&aacute; muy
      familiar.  Si viene usted de otros sistemas
      operativos como DOS, el fichero <filename>GENERIC</filename> puede
      parecerle intimidante, as&iacute; que siga las instrucciones descritas
      en <link linkend="kernelconfig-config">El Fichero de Configuraci&oacute;n
      </link> detenidamente y con sumo cuidado.</para>
      
    <note>
      <para>Aseg&uacute;rese siempre de verificar el fichero
        <filename>/usr/src/UPDATING</filename> antes de realizar cualquier
        actualizaci&oacute;n del sistema si ha
        <link linkend="cutting-edge">sincronizado sus fuentes</link>
        para disponer de la &uacute;ltima versi&oacute;n de los mismos.  
        En el fichero <filename>/usr/src/UPDATING</filename> est&aacute; toda
        la informaci&oacute;n importante sobre las actualizaciones.  
        Al distribuirse con &os; dicha informaci&oacute;n deber&aacute;
        estar m&aacute;s actualizada que la que hay en este mismo
	texto.</para>
    </note>

    <para>Ahora es momento de llevar a cabo la compilaci&oacute;n del
      c&oacute;digo fuente del kernel.</para>

    <procedure>
      <title>Compilaci&oacute;n del kernel</title>

      <step>
	<para>Vaya al directorio <filename
	  class="directory">/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>Compile el kernel:</para>

	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MIKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>Instale el nuevo kernel:</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MIKERNEL</replaceable></userinput></screen>
      </step>
    </procedure>

    <note>
      <para>Es imprescindible que disponga del c&oacute;digo fuente completo de &os;
        para poder compilar el kernel.</para>
    </note>


    <tip>
      <para>Por omisi&oacute;n, si compila un kernel personalizado 
	<emphasis>todos</emphasis> los m&oacute;dulos del kernel
	ser&aacute;n recompilados tambi&eacute;n.  Si quiere
	que la actualizaci&oacute;n de su kernel sea mucho m&aacute;s
	r&aacute;pida o compilar solamente ciertos m&oacute;dulos
	personalizados, edite kernel modules will be rebuilt as well.
	<filename>/etc/make.conf</filename> antes de compilar el
	kernel:</para>

      <programlisting>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Esta variable crea una lista de m&oacute;dulos listos para
      ser compilados, sin tocar los dem&aacute;s.</para>

      <programlisting>WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Esta variable crea una lista de m&oacute;dulos que ser&aacute;n
        excluidos del proceso de compilaci&oacute;n.  Hay otras variables que
	pueden resultarle &uacute;tiles durante este proceso; consulte la
	p&aacute;gina de manual de &man.make.conf.5;.</para>
    </tip>

    <indexterm>
      <primary><filename class="directory">/boot/kernel.old</filename></primary>
    </indexterm>


    <para>El nuevo kernel se copiar&aacute; al directorio ra&iacute;z
      como <filename>/kernel</filename> y el kernel viejo tendr&aacute;
      el nombre de <filename>/kernel.old</filename>.  Ahora
      reinicie su sistema para poder probar su nuevo kernel.  En caso de que se
      presente algun problema hay algunos consejos para la <link
      linkend="kernelconfig-trouble">resoluci&oacute;n de problemas</link> al
      final de este cap&iacute;tulo.  Aseg&uacute;rese de leer la secci&oacute;n
      que explica c&oacute;mo recuperar el sistema en caso de que su kernel <link
      linkend="kernelconfig-noboot">no quiera arrancar</link>.</para>
    

    <note>
      <para>Ciertos ficheros relacionados con el proceso de
	arranque, como &man.loader.8;y su configuraci&oacute;n,
	se guardan en <filename>/boot</filename>.  Los m&oacute;dulos
	personalizados o de terceros se suelen guardar en
	<filename class="directory">/boot/kernel</filename>,
	aunque debe tener presente que es muy importante que
	los m&oacute;dulos y el kernel est&eacute;n
	sincronizados.  Si intenta usar m&oacute;dulos con un
	kernel para el que no est&aacute;n destinados puede
	haber errores o incluso producirse intesatabilidades.</para>
    </note>

  </sect1>
<!-- hemendik -->


  <sect1 id="kernelconfig-config">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Joel</firstname>
	  <surname>Dahl</surname>
	  <contrib>Actualizado a &os; 6.X por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>El fichero de configuraci&oacute;n</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm><primary>NOTES</primary></indexterm>
    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration file</secondary>
    </indexterm>

    <para>El formato de un fichero de configuraci&oacute;n es
      bastante simple.  Cada l&iacute;nea contiene una palabra
      clave con uno o m&aacute;s argumentos.  Para simplificar,
      hay muchas l&iacute;neas que solamente contienen un
      argumento.  Cualquier cosa detr&aacute;s de un
      <literal>#</literal> se considerar&aacute; un comentario y
      en consecuencia ser&aacute; ignorado.  Las siguientes
      secciones describen todas las palabras clave en el orden
      en el que aparecen en
      <filename>GENERIC</filename>.  
      <anchor
      id="kernelconfig-options"> Si quiere una lista exhaustiva de
      de opciones dependientes de arquitectura y de dispositivos
      puede consultar el fichero <filename>NOTES</filename>
      en el mismo directorio donde est&aacute; el fichero
      <filename>GENERIC</filename>.  Si quiere ver las
      opciones independientes de arquitectura consulte
      <filename>/usr/src/sys/conf/NOTES</filename>.</para>

    <note>
      <para>Puede generar un fichero que contenga todas las opciones
        disponibles en un kernel.  Esto es algo que solamente se
	usa para hacer pruebas.  Si quiere generarlo ejecute, como
	<username>root</username>, lo siguiente:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf &amp;&amp; make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration file</secondary>
    </indexterm>

    <para>A continuaci&oacute;n veremos un ejemplo de fichero de
      configuraci&oacute;n de un kernel <filename>GENERIC</filename>
      al que se han a&ntilde;adido comentarios adicionales donde se
      ha visto que era necesario abundar un poco para mayor
      claridad.  Este ejemplo es igual (o, en el
      peor de los casos, casi igual) que la copia del mismo
      que tiene usted en
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/GENERIC</filename>.
      </para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>machine</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>Esta es la arquitectura de la m&aacute;quina.  Debe ser
      <literal>alpha</literal>, <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal> o
      <literal>sparc64</literal>.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>cpu</secondary>
    </indexterm>
    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>Las opciones anteriores definen el tipo de CPU que
      haya en su sistema.  Puede dejar varias l&iacute;neas
      de CPU (si, por ejemplo, no est&aacute; seguro de usar
      <literal>I586_CPU</literal> o <literal>I686_CPU</literal>),
      pero si est&aacute; personalizando su kernel es mucho mejor
      que solamente ponga la CPU que tenga.  Si no est&aacute;
      seguro de la CPU que tiene busque en los mensajes de arranque
      que se guardan en 
      <filename>/var/run/dmesg.boot</filename>.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>Este es el identificador del kernel.  Modif&iacute;quelo
      para que cuadre con el nombre que le haya dado a su kernel,
      es decir, <literal><replaceable>MIKERNEL</replaceable></literal>
      si ha seguido los ejemplos anteriores.  El valor que asigne
      a la cadena <literal>ident</literal> ser&aacute; el que
      se muestre cuando arranque con su kernel, as&iacute; que
      es &uacute;til darle a su kernel un nombre distintivo que
      permita distinguirlo f&aacute;cilmente de otros, por ejemplo,
      si est&aacute; compilando un kernel experimental.</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>&man.device.hints.5; se usa para configurar opciones
      de controladores de dispositivo.  La ubicaci&oacute;n por
      defecto en la que &man.loader.8; buscar&aacute; durante
      el arranque es <filename>/boot/device.hints</filename>.  Si usa
      la opci&oacute;n <literal>hints</literal> puede compilar el
      contenido de <filename>device.hints</filename> en su kernel,
      lo que har&aacute; innecesario crear ese fichero en
      <filename>/boot</filename>.</para>

    <!-- XXX: Add a comment here that explains when compiling hints into
      the kernel is a good idea and why. -->

    <programlisting>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>El proceso normal de compilaci&oacute;n en &os;
      incluye informaci&oacute;n de depuraci&oacute;n de
      errores si se compila un kernel con la opci&oacute;n
      <option>-g</option>, que activa la informaci&oacute;n
      de depuraci&oacute;n de errores al pasar a
      &man.gcc.1;.</para>

    <programlisting>options          SCHED_4BSD         # 4BSD scheduler</programlisting>

    <para>El planificador de tareas tradicional y por omisi&oacute;n
      de &os;.  D&eacute;jelo como est&aacute;.</para>

    <programlisting>options          PREEMPTION         # Enable kernel thread preemption</programlisting>

    <para>Permite que hilos que est&aacute;n en el kernel
      puedan asociarse con hilos cuya prioridad sea m&aacute;s
      alta.  Ayuda con la interactividad y permite que los hilos
      interrumpidos puedan ejecutarse antes en lugar de tener
      que esperar.</para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>Networking.  Deje esto como est&aacute;, incluso si no
      tiene en mente conectar la m&aacute;quina a una red.  Muchos
      programas necesitan al menos disponer de lo que se llama
      &laquo;loopback networking&raquo; (esto es, poder efectuar
      conexiones de red con su propia m&aacute;quina) as&iacute;
      que tener esto es obligatorio.</para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>Activa los protocolos de comunicaci&oacute;n IPv6.</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>El sistema de ficheros b&aacute;sico para discos
      duros.  Debe dejarlo como est&aacute; si pretende
      poder arrancar desde disco duro.</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>Activa Soft Updates en el kernel, lo que acelerar&aacute;
      los accesos de escritura a sus discos.  Esta funcionalidad
      la facilita el kernel, pero debe activarse para cada disco
      de forma espec&iacute;fica.  Revise la salida de
      &man.mount.8; y ver&aacute; si Soft Updates est&aacute;
      activado en los discos de su sistema.  Si no aparece la
      opci&oacute;n <literal>soft-updates</literal> act&iacute;vela
      mediante &man.tunefs.8; (para sistemas de ficheros ya
      existentes) o &man.newfs.8; (en el caso de sistemas
      de ficheros nuevos).</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>Esta opci&oacute;n activa en el kernel las listas
      de control de acceso.  Consiste en el uso de atributos
      extendidos y <acronym>UFS2</acronym> junto con las
      caracter&iacute;sticas que se describen detalladamente
      en la <xref linkend="fs-acl">.  Las <acronym>ACL</acronym>
      por omisi&oacute;n est&aacute;n activadas, y no deben
      desactivarse del kernel una vez que hayan sido usadas
      en un sistema de ficheros puesto que eliminar&aacute;
      las listas de control de acceso y el modo en el que
      se protegen esos ficheros de un modo totalmente
      fuera de control.</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>This option includes functionality to speed up disk
      operations on large directories, at the expense of using
      additional memory.  You would normally keep this for a large
      server, or interactive workstation, and remove it if you are
      using &os; on a smaller system where memory is at a premium and
      disk access speed is less important, such as a firewall.</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>Esta opci&oacute;n permite que la partici&oacute;n
      ra&iacute;z est&eacute; en un disco virtual basado en
      memoria.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>kernel options</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>
    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>NFS, el sistema de ficheros en red.  Salvo que tenga
      intenci&oacute;n de montar particiones de sistemas de ficheros
      &unix; de un servidor a trav&eacute;s de TCP/IP puede
      comentar estas opciones.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>
    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>El sistema de ficheros &ms-dos;.  Salvo que tenga en mente
      montar particiones de disco duro con formato DOS durante el
      arranque puede comentar esta opci&oacute;n.  En caso de
      necesidad esta funcionalidad se cargar&aacute;
      autom&aacute;ticamente.  Tambi&eacute;n tiene a su
      <filename role="package">emulators/mtools</filename>,
      que le permitir&aacute; acceder a disquetes DOS sin tener
      que montarlos y desmontarlos (y ni siquiera requiere
      <literal>MSDOSFS</literal>).</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>El sistema de ficheros ISO 9660 para CDROM.  Com&eacute;ntelo
      si no tiene unidad CDROM o solamente monta CD muy de
      vez en cuando; cuando lo necesite el sistema lo cargar&aacute;
      din&aacute;micamente.  Los CD de sonido no utilizan este
      sistema de ficheros.</para>

    <programlisting>options          PROCFS            # Process filesystem (requires PSEUDOFS)</programlisting>

    <para>El sistema de ficheros de procesos.  Es un sistema
      de ficheros <quote>simulado</quote> que se monta en
      <filename>/proc</filename> y permite a programas como
      &man.ps.1; suministrar m&aacute;s informaci&oacute;n
      sobre qu&eacute; procesos est&aacute;n
      ejecut&aacute;ndose.  En la mayoar&iacute;a de los casos
      no es necesario usar <literal>PROCFS</literal>,
      puesto que la mayor&iacute;a de las herramientas de
      monitorizaci&oacute;n y depuraci&oacute;n han sido
      adaptadas para que funcionen sin
      <literal>PROCFS</literal>.  De hecho aunque lo instale
      el sistema no lo montar&aacute; por omisi&oacute;n.</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

      <para>Los kernel 6.X pueden usar <literal>PSEUDOFS</literal>
        al utilizar <literal>PROCFS</literal>.</para>

    <programlisting>options          GEOM_GPT          # GUID Partition Tables.</programlisting>

    <para>Con esta opci&oacute;n se puede tener una gran cantidad
      de particiones en un &uacute;nico disco.</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>Compatibilidad con 4.3BSD.  D&eacute;jelo como est&aacute;;
      ciertos programas pueden comportarse de formas muy
      extra&ntilde;as si comenta esta opci&oacute;n.</para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with &os;4</programlisting>

    <para>&os;&nbsp;5.X en sistemas &i386; y Alpha necesita
      esta opci&oacute;n para poder usar aplicaciones compiladas
      en versiones antiguas de &os; que utilizan, por tanto,
      llamadas al sistema m&aacute;s antiguas.  Esta opci&oacute;n
      no es necesaria en plataformas en las que funciona &os;
      desde 5.X, como ia64 y &sparc64;.</para>

    <programlisting>options          COMPAT_FREEBSD5   # Compatible with &os;5</programlisting>

    <para>Esta opci&oacute;n hace falta en sistemas &os;&nbsp;6.X
      y versiones posteriores para poder ejecutar aplicaciones
      compiladas en &os;&nbsp;5.X, que usan interfaces de llamada
      al sistema &os;&nbsp;5.X.</para>

    <programlisting>options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI</programlisting>

    <para>Hace que el kernel haga una pausa de 5 segundos antes de
      probar los dispositivos SCSI del sistema.  Si solamente tiene
      discos IDE puede ignorar esta opci&oacute;n, o tambi&eacute;n
      puede asignarle un valor menos para evitar el retardo en el
      arranque.  Si lo hace y &os; tiene problemas para reconocer
      dispositivos SCSI en el sistema es obvio que tendr&aacute;
      que incrementar el valor.</para>
      
    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>Activa las trazas en el kernel, algo muy &uacute;til para
      la depuraci&oacute;n de errores.</para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>Facilita memoria compartida System&nbsp;V.  El uso
      m&aacute;s habitual es la extensi&oacute;n XSHM de X, que
      utiliza la mayor&iacute;a de programas que hacen uso
      intensivo de los gr&aacute;ficos para incrementar la
      velocidad.  Si usa X es casi seguro que le vendr&aacute; bien
      esta opci&oacute;n.</para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>Mensajes System&nbsp;V.  Esta opci&oacute;n a&ntilde;ade
      solamente unos cuantos bytes al kernel.</para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>Sem&aacute;foros System&nbsp;V.  No es demasiado frecuente
      que se utilicen, pero solamente a&ntilde;aden unos
      cuantos cientos de bytes al kernel.</para>

    <note>
      <para>La opci&oacute;n <option>-p</option> de &man.ipcs.1;
        le mostrar&aacute; una lista de procesos que est&eacute;n
	utilizando caracter&iacute;sticas
	System&nbsp;V.</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>Extensiones en tiempo real a&ntilde;adidas en 1993
      &posix;.  Ciertas aplicaciones de la Colecci&oacute;n de
      Ports las utilizan, por ejemplo
      <application>&staroffice;</application>.</para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>This option is required to allow the creation of keyboard device
      nodes in <filename>/dev</filename>.</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>Giant es un mecanismo de exclusi&oacute;n mutua
      (&laquo;sleep mutex&raquo;) que protege un gran conjunto
      de recursos del kernel.  Hoy en dia no es asumible tener
      un cuello de botella as&iacute; por el impacto que tiene
      en el rendimiento, as&iacute; que est&aacute; siendo
      reemplazado por bloqueos que protegen los recursos de
      manera individual.  <literal>ADAPTIVE_GIANT</literal>
      hace que Giant sea incluido en un conjunto de 
      &laquo;mutextes&raquo; que va rotando
      Esto es, cuando un hilo quiere
      bloquear el Giant mutex (pero ya est&aacute; bloqueado
      por un hilo de otra CPU) el primer hilo seguir&aacute;
      ejecut&aacute;ndose a la espera de que se libere el
      bloqueo.  Generalmente el hilo volver&aacute; al estado
      de reposo y esperar&aacute; hasta que aparezca otra
      oportunidad de ejecutarse.  Si no est&aacute; seguro de
      lo que est&aacute; haciendo es mejor que deje esta
      opci&oacute;n tal y como est&aacute;.</para>

    <note>

      <para>Tenga en cuenta que en &os;&nbsp;8.0-CURRENT y
        versiones siguientes todos los &laquo;mutexes&raquo;
	son adaptables por omisi&oacute;n, salvo que se use
	la opci&oacute;n
	<literal>NO_ADAPTIVE_MUTEXES</literal>.  El resultado
	evidente que es Giant es adaptable por omisi&oacute;n,
	as&iacute; que la opci&oacute;n
	<literal>ADAPTIVE_GIANT</literal> ha sido eliminada de
	la configuraci&oacute;n.</para>
    </note>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>SMP</secondary>
    </indexterm>
    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>El dispositivo apic activa la E/S APIC en la entrega
      de interrupciones.  El dispositivo apic puede usarse tanto en
      kernels para un procesador (UP) como para sistemas
      multiprocesador (SMP).  Si a&ntilde;ada
      <literal>options SMP</literal> funcionar&aacute; en
      sistemas multiprocesador.</para>

    <note>
      <para>El dispositivo apic existe solamente en la
        arquitectura i386, de modo que no debe usarse
	esta l&iacute;nea en otras arquitecturas.</para>
    </note>

    <programlisting>device          eisa</programlisting>

    <para>Use esta opci&oacute;n si tiene una placa base
      EISA.  Activa la detecci&oacute;n autom&aacute;tica y
      permite la configuraci&oacute;n de todos los dispositivos
      que est&eacute;n en el bus EISA.</para>

    <programlisting>device          pci</programlisting>

    <para>Use esta opci&oacute;n si tiene una placa PCI.  Permite
      la detecci&oacute;n autom&aacute;tica de tarjetas PCI y
      permite la configuraci&oacute;n entre el bus ISA y el
      PCI.</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>Este dispositivo es el controlador de la unidad de
      disquetes.</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>Este controlador permite utilizar dispositivos ATA
      y ATAPI.  Si a&ntilde;ade al kernel
      one <literal>device ata</literal> &eacute;ste detectar&aacute;
      cualquier dispositivo ATA/ATAPI PCI que conecte a una
      m&aacute;quina moderna.</para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>Si usa <literal>device ata</literal> tendr&aacute; que
      a&ntilde;adir tambi&eacute;n esto para poder usar unidades
      de disco ATA.</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>Si usa <literal>device ata</literal> tendr&aacute; que
      a&ntilde;adir tambi&eacute;n esto para poder usar unidades
      de disco ATA RAID.</para>

    <programlisting><anchor id="kernelconfig-atapi">
device          atapicd                 # ATAPI CDROM drives</programlisting>

     <para>Si usa <literal>device ata</literal> tendr&aacute; que
      a&ntilde;adir tambi&eacute;n esto para poder usar unidades
      ATAPI CDROM.</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

     <para>Si usa <literal>device ata</literal> tendr&aacute; que
      a&ntilde;adir tambi&eacute;n esto para poder usar unidades
      de disquete ATAPI.</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>Si usa <literal>device ata</literal> tendr&aacute; que
      a&ntilde;adir tambi&eacute;n esto para poder usar unidades
      de cinta ATAPI.</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>Con esta opci&oacute;n hace que el n&uacute;mero de
      controladores sea est&aacute;tico; si no se usa los
      n&uacute;meros de dispositivo se asignan
      din&aacute;micamente.</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>Controladoras SCSI.  Com&eacute;ntelas si no las tiene
      en su sistema.  Si en su sistema tiene solamente unidades IDE
      puede borrarlas todas.  
      Las l&iacute;neas <literal>*_REG_PRETTY_PRINT</literal> son
      opciones de depuraci&oacute;n de errores de sus
      respectivos controladores de dispositivo.</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>Perif&eacute;ricos SCSI.  Estos tambi&eacute;n puede
      borrarlos sin problemas si no los tiene en su sistema o
      si solamente tiene hardware IDE.</para>

    <note>
      <para>El controlador USB &man.umass.4; (y unos cuantos
        controladores m&aacute;s) utilizan el subsistema
	SCSI aunque no sean dispositivos SCSI reales.  No elimine
	el subsistema SCSI del kernel si va a utilizar cualquiera
	de estos controladores.</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>Controladoras RAID que pueden utilizarse en &os;.  Si no las
      tiene en su sistema puede borrarlas.</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>El controlador de teclado (<literal>atkbdc</literal>)
      ofrece servicios de E/S con teclados AT y ratones PS/2.  El
      controlador de teclado
      (<literal>atkbd</literal>) y el controlador de rat&oacute;n PS/2
      (<literal>psm</literal>) necesitan este dispositivo.</para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para>El controlador <literal>atkbd</literal>, junto con el
      controlador <literal>atkbdc</literal>, permiten utilizar el
      teclado AT 84 u otros tipos de teclados AT mejorados que se
      conecten mediante el controlador de teclado AT.</para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>Utilice este dispositivo si conecta su rat&oacute;n en el
      puerto PS/2.</para>

    <programlisting>device          kbdmux        # keyboard multiplexer</programlisting>

    <para>Funcionalidad b&aacute;sica para m&uacute;ltiples
      teclados.  Si no tiene en mente usar m&aacute;s de un
      teclado en el sistema puede borrar esta l&iacute;nea
      sin mayor problema.</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>El controlador de la tarjeta gr&aacute;fica.</para>

    <programlisting>
device          splash     # Splash screen and screen saver support</programlisting>

    <para>&laquo;Splash screen&raquo; en el arranque.  Los salvapantallas
      necesitan este dispositivo.</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> por omisi&oacute;n es el controlador
      de dispositivo de la consola; se parece mucho a una consola de
      SCO.  Dado que muchos programas de pantalla completa acceden
      a la consola a trav&eacute;s de la biblioteca de bases de datos
      de terminal
      <filename>termcap</filename> no tiene demasiada importancia si
      usa <literal>vt</literal>, el controlador de consola compatible
      <literal>VT220</literal>.  Cuando acceda al sistema asigne a
      su variable <envar>TERM</envar> el valor
      <literal>scoansi</literal>si los programas a pantalla completa
      tienen alg&uacute;n problema para acceder a la consola.</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>El controlador de dispositivo VT220-compatible;
      es compatible con VT100/102, anterior a &eacute;l.  Funciona
      bien en ciertos sistemas port&aacute;tiles que adolecen de
      incompatibilidad de harware con 
      <literal>sc</literal>.  Asigne a su variable de entorno
      <envar>TERM</envar> el valor <literal>vt100</literal> o
      <literal>vt220</literal> cuando acceda al sistema.  Este
      controlador le puede ser de utilidad si tiene que acceder
      a gran cantidad de m&aacute;quinas a trav&eacute;s de una
      red, una situaci&oacute;n en la que suele suceder que
      <filename>termcap</filename> o
      <filename>terminfo</filename> no est&aacute;n ah&iacute;
      para que las use <literal>sc</literal>.  
      <literal>vt100</literal>, por el contrario, deber&iacute;a
      aparecer en pr&aacute;ticamente cualquier
      plataforma.</para>

    <programlisting>device          agp</programlisting>

    <para>Utilice esta opci&oacute;n si tiene en el sistema una
      tarjeta AGP.  Activar&aacute; AGP y tambi&eacute;n AGP GART
      si su tarjeta puede usarla.</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># Power management support (see NOTES for more options)
#device          apm</programlisting>

    <para>Gesti&oacute;n avanzada de la energ&iacute;a.  Muy
      &uacute;til en sistemas port&aacute;tiles.  Viene
      desactivada por omisi&oacute;n en el kernel
      <filename>GENERIC</filename> .</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>Controlador del reloj para eventos de gesti&oacute;n de la
      energ&iacute;a, como APM y ACPI.</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>Dispositivos PCMCIA.  Si el sistema es port&aacute;til
      necesita tener esto activado.</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>Estos son los puertos serie a los que se conoce como
      puertos <devicename>COM</devicename> en entornos
      &ms-dos;/&windows;.</para>

    <note>
      <para>Si tiene un m&oacute;dem interno en
        <devicename>COM4</devicename> un puerto serie en
	<devicename>COM2</devicename> tendr&aacute; que
	asignar a la IRQ del m&oacute;dem el 2 (por razones
	t&eacute;cnicas ignotas IRQ2 = IRQ 9) para que pueda
	acceder al dispositivo desde &os;.  Si tiene una tarjeta
	serie multipuerto consulte la p&aacute;gina de manual de
	&man.sio.4; si quiere m&aacute;s detalles sobre los
	valores que debe a&ntilde;adir a
	<filename>/boot/device.hints</filename>.  Algunas tarjetas
	gr&aacute;ficas (sobre todo las que usan chips S3) utilizan
	direcciones IO del tipo
	<literal>0x*2e8</literal> y dado que muchas tarjetas serie
	de baja calidad no decodifican correctamente el espacio de
	direcciones de 16 bits chocan con estas tarjetas, haciendo
	que el puerto <devicename>COM4</devicename> sea
	pr&aacute;cticamente in&uacute;til.</para>

      <para>Es necesario que cada puerto serie tenga una IRQ
        &uacute;nica (salvo que use una tarjeta multipuerto que
	permita compartir interrupciones), as&iacute; que las
	IRQ de <devicename>COM3</devicename> y de
	<devicename>COM4</devicename> no se pueden
	utilizar.</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>El interfaz del puerto paralelo de bus ISA.</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>El bus del puerto paralelo.</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>Permite usar el puerto paralelo para conectar impresoras.</para>

    <note>
      <para>Necesitar&aacute; disponer de los tres anteriores para
        poder utilizar impresoras mediante el puerto paralelo.</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>Este controlador es para la interfaz de red a trav&eacute;s
      del puerto paralelo.</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>La E/S de prop&oacute;sito general (conocida
      tambi&eacute;n como <quote>puerto geek</quote>) + E/S
      IEEE1284.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>zip drive</primary></indexterm>
    <para>Este dispositivo se usa con unidades Iomega Zip.  Necesita
      <literal>scbus</literal> y <literal>da</literal> .  El mejor
      rendimiento se alcanza con el uso de los puertos en modo
      EPP 1.9.</para>

    <programlisting>#device         puc</programlisting>

    <para>Puede utilizar este dispositivo si tiene una tarjeta
      PCI <quote>tonta</quote> (por puerto serie o paralelo)
      que funcione mediante el controlador &man.puc.4;.</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>Diversos controladores para tarjetas de red PCI.  Puede borrar
      todas las que no est&eacute;n en su sistema.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>El poder utilizar bus MII es necesario para ciertas tarjetas
      Ethernet PCI 10/100, m&aacute;s concretamente las que usan
      transceptores compatibles con MII o implementan interfaces
      de control de transceptores que funcionan como si fueran
      MII.  Si incluye <literal>device miibus</literal> al kernel
      dispondr&aacute; de la API miibus gen&eacute;rica  y todos los
      controladores PHY, incluyendo uno que har&aacute; funcionar
      hardware que, siendo del tipo PHY, no est&aacute; bajo ninguno
      de los controladores PHY espec&iacute;ficos.</para>

    <programlisting>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>Controladores que utilizan el c&oacute;digo del controlador
      de bus MII.</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>Controladores Ethernet ISA.  Consulte
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>
      para m&aacute;s detalles sobre qu&eacute; tarjetas hace funcionar
      qu&eacute; controlador.</para>

    <programlisting># Wireless NIC cards
device          wlan            # 802.11 support</programlisting>

    <para>802.11 gen&eacute;rico.  Necesitar&aacute; esta l&iacute;nea
      si va a usar redes inal&aacute;mbricas.</para>

    <programlisting>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</programlisting>

    <para>Criptograf&iacute;a en dispositivos 802.11.  Necesita
      estas l&iacute;neas si quiere utilizar criptograf&iacute;a
      y protocolos de seguridad 802.11.</para>

    <programlisting>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>Diversas tarjetas inal&aacute;mbricas.</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>El dispositivo de &laquo;loopback&raquo; para
      TCP/IP.  Si accede por telnet o FTP
      or FTP to <hostid>localhost</hostid> tambi&eacute;n
      conocido como <hostid
      role="ipaddr">127.0.0.1</hostid>) lo har&aacute; a
      trav&eacute;s de este dispositivo.  Es
      <emphasis>imprescindible</emphasis> tenerlo en el
      sistema.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Generador de n&uacute;meros criptogr&aacute;ficamente
      seguro.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> solo es necesario si tiene
      alguna tarjeta Ethernet.  Incluye c&oacute;digo
      gen&eacute;rico del protocolo Ethernet.</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> permite utilizar SLIP.  Ha sido
      sustituido casi totalmente por PPP, que es m&aacute;s
      f&aacute;cil de usar, est&aacute; mejor capacitado para
      la conexi&oacute;n de m&oacute;dem a m&oacute;dem y es,
      en general, claramente mejor.</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>Este dispositivo incluye en el kernel la capacidad de
      gestionar conexiones de llamada entrante
      &laquo;dial-up&raquo;.  Hay tambi&eacute;n una versi&oacute;n
      de PPP implementada como aplicaci&oacute;n de usuario; utiliza
      <literal>tun</literal> y ofrece m&aacute;s flexibilidad y
      caracter&iacute;sticas como la llamada bajo
      petici&oacute;n.</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>Este dispositivo lo usa el software PPP de usuario.  
      Consulte la secci&oacute;n sobre
      <link linkend="userppp">PPP</link> de este mismo libro.</para>

    <programlisting><anchor id="kernelconfig-ptys">
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>Este dispositivo es una <quote>pseudoterminal</quote>,
      o un puerto de entrada al sistema simulado.  Se usa en
      sesiones entrantes de <command>telnet</command> y
      <command>rlogin</command>; tambi&eacute;n lo usan
      <application>xterm</application> y otras aplicaciones, entre
      las que encontramos a <application>Emacs</application>.</para>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>Pseudodispositivos de disco basados en memoria.</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>Este dispositivo implementa t&uacute;neles de IPv6
      sobre IPv4, IPv4 sobre IPv6, IPv4 sobre IPv4 e
      IPv6 sobre IPv6.  El dispositivo
      <literal>gif</literal> se puede clonar a s&iacute; mismo,
      as&iacute; que los nodos de dispositivo se van creando a
      medida que van haciendo falta.</para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>Este pseudodispositivo captura paquetes que se le
      hayan enviado y los dirige hacia el d&aelig;mon de
      traducci&oacute;n IPv4/IPv6.</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>El filtro de paquetes de Berkeley. Este pseudodispositivo
      permite poner interfaces de red en modo prom&iacute;scuo, lo que
      significa que capturan todos los paquetes que circulen por una
      red broadcast (por ejemplo una Ethernet).  Dichos paquetes
      pueden guardarse en disco para su posterior examen mediante
      &man.tcpdump.1; (el an&aacute;lisis con &man.tcpdump.1; no
      puede hacerse directamente tambi&eacute;n).</para>

    <note>
      <para>El dispositivo &man.bpf.4; tambi&eacute;n lo usa
	&man.dhclient.8; para obtener direcciones IP del
	encaminador (gateway) por omisi&oacute;n.  Si usa
	DHCP deje esta opci&oacute;n como est&aacute;.</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>Diversos dispositivos USB.</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>Diversos dispositivos Firewire.</para>

    <para>Tiene m&aacute;s informaci&oacute;n y una lista
      con m&aacute;s dispositivos que funcionan en &os;
      consulte
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>.</para>

      <sect2>
        <title>Configuraciones con grandes cantidades de memoria
	  (<acronym>PAE</acronym>)</title>
	<indexterm>
	  <primary>Physical Address Extensions
	    (<acronym>PAE</acronym>)</primary>
	  <secondary>large memory</secondary>
	</indexterm>

	<para>Las m&aacute;quinas que tienen configuraciones
	  con grandes cantidades de memoria necesitan acceder
	  a m&aacute;s de 4 gigabytes de espacio de direcciones
	  <acronym>KVA</acronym> (User+Kernel Virtual
	  Address).  Debido a esta limitaci&oacute;n Intel
	  a&ntilde;adi&oacute; a las CPU &pentium; Pro y modelos
	  posteriores la posibilidad de acceso al espacio de
	  direcciones f&iacute;sicas de 36 bits.</para>
	
	<para><acronym>PAE</acronym> (Physical Address Extension)
	  a las CPU &intel; &pentium; Pro y los modelos posteriores
	  configuraciones de memoria de hasta 64 gigabytes.  
	  Para poder aprovechar esto en &os; existe la
	  opci&oacute;n del kernel
	  <option>PAE</option>, disponible en todas las versiones
	  modernas de &os;.  A causa de esta limitaci&oacute;n de
	  memoria en los Intel no hay nada que distinga de
	  alg&uacute;n modo la memoria situada por debajo del
	  l&iacute;mite de los 4 gigabytes.  La memoria que
	  est&eacute; por encima de los 4 gigabytes se coloca
	  en el &laquo;pool&raquo; de memoria disponible.</para>

	<para>Si quiere activar <acronym>PAE</acronym> en el kernel
	  tiene que a&ntilde;adir la siguiente li&iacute;nea al
	  fichero de configuraci&oacute;n del kernel:</para>
	
	<programlisting>options		    PAE</programlisting>

	<note>
	  <para>En &os; <acronym>PAE</acronym> solamente existe
	    en procesadores &intel; IA-32.  Hemos de advertirle
	    de que <acronym>PAE</acronym> no ha sido probado
	    todo lo necesario, as&iacute; que debe considerarse
	    de calidad beta, sobre todo si se le compara con
	    otras caracter&iacute;sticas de &os;.</para>
	</note>

	<para><acronym>PAE</acronym> en &os; tiene varias
	  limitaciones:</para>
	
	<itemizedlist>
	  <listitem>
	    <para>Un solo proceso no puede acceder a m&aacute;s
	      de 4 gigabytes de espacio VM.</para>
	  </listitem>

	  <listitem>
	    <para>No puede cargar m&oacute;dulos
	      <acronym>KLD</acronym> en un kernel que tenga
	      <acronym>PAE</acronym> activado debido a las diferencias
	      existentes entre el &laquo;framework&raquo; de
	      compilaci&oacute;n del m&oacute;dulo y el del
	      kernel mismo.</para>
	  </listitem>

	  <listitem>
	    <para>Los controladores de dispositivo que utilizan
	      el interfaz &man.bus.dma.9; pueden provocar
	      corrupci&oacute;n de datos en un kernel con
	      <acronym>PAE</acronym> activado, una excelente
	      raz&oacute;n para no utilizarlos.  Esta es
	      la raz&oacute;n de que &os; incorpore un fichero
	      de configuraci&oacute;n de un kernel
	      <filename>PAE</filename> del que se han
	      extra&iacute;do todos los m&oacute;dulos que
	      se sabe que no funcionan en un kernel con
	      <acronym>PAE</acronym> activado.</para>
	  </listitem>

	  <listitem>
	    <para>Algunos &laquo;system tunables&raquo; determinan el
	      uso de recursos de memoria bas&aacute;ndose en la
	      memoria f&iacute;sica disponible.  Estos &laquo;tunables&raquo;
	      pueden asignar m&aacute;s memoria de la que realmente
	      debieran debido a que el sistema <acronym>PAE</acronym>
	      est&aacute; &iacute;ntimamente ligado a cantidades
	      bastante importantes de memoria.  Un ejemplo de esto
	      es la sysctl <option>kern.maxvnodes</option>, que
	      controla el n&uacute;mero m&aacute;ximo de vnodes
	      permitidos en el kernel.  Le recomendamos que
	      ajuste este y otros tunables dentro valores
	      razonables.</para>
	  </listitem>

	  <listitem>
	    <para>Es posible que tenga que aumentar el espacio virtual
	      de direcciones del kernel (el <acronym>KVA</acronym>)
	      o reducir la cantidad de recursos exclusivos del kernel
	      que se utilicen exhaustivamente (ver m&aacute;s
	      arriba) para evitar que <acronym>KVA</acronym> literalmente
	      se ahogue.  La opci&oacute;n del kernel
	      <option>KVA_PAGES</option> permite incrementar el
	      espacio <acronym>KVA</acronym>.</para>
	  </listitem>
	</itemizedlist>

	<para>Si quiere saber m&aacute;s sobre la estabilidad
	  del sistema consulte la p&aacute;gina de manual de
	  &man.tuning.7;.  La p&aacute;gina de manual de &man.pae.4;
	  contiene informaci&oacute;n actualizada sobre
	  <acronym>PAE</acronym> y &os;.</para>
    </sect2>
  </sect1>

  <sect1 id="kernelconfig-trouble">
    <title>Qu&eacute; hacer si algo va mal</title>

    <para>Hay cuatro categor&iacute;as de problemas que
      podemos encontrarnos en el proceso de compilaci&oacute;n
      de un kernel personalizado:</para>

    <variablelist>
      <varlistentry>
	<term>Fallo de <command>config</command>:</term>

	<listitem>
	  <para>Si &man.config.8; falla cuando le pasa la
	    descripci&oacute;n de su kernel seguramente ha
	    cometido alg&uacute;n peque&ntilde;o error.  Por
	    suerte &man.config.8; les mostrar&aacute; el
	    n&uacute;mero de la l&iacute;nea que le est&aacute;
	    dando problemas, as&iacute; que no tendr&aacute;
	    mayor problema para localizarla. Veamos un
	    ejemplo:</para>

	  <screen>config: line 17: syntax error</screen>

	  <para>Si ve algo as&iacute; aseg&uacute;rese de que
	     ha tecleado la palabra clave que hay en esa
	     l&iacute;na.  Compare la de su fichero de
	     configuraci&oacute;n del kernel con la de
	    <filename>GENERIC</filename>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Fallo de <command>make</command>:</term>

	<listitem>
	  <para>If the <command>make</command> command fails, it usually
	    signals an error in your kernel description which is not severe
	    enough for &man.config.8; to catch.  Again, look
	    over your configuration, and if you still cannot resolve the
	    problem, send mail to the &a.questions; with your kernel
	    configuration, and it should be diagnosed quickly.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>El kernel no arranca:<anchor
	  id="kernelconfig-noboot"></term>

	<listitem>
	  <para>Si su nuevo kernel no arranca o no reconoce sus
	    dispositivos de hardware no desespere.  &os;
	    dispone de excelentes mecanismos de
	    recuperaci&oacute;n ante kernels defectuosos.  Elija
	    el kernel con el que quiere arrancar en el gestor
	    de arranque de &os;.  Puede acceder al gestor de
	    arranque en el momento en el que aparece el
	    men&uacute; de arranque.  Elija la opci&oacute;n
	    n&uacute;mero seis, <quote>Escape to a loader
	    prompt</quote> option, Escriba en el prompt
	    <command>unload kernel</command>
            y despu&eacute;s escriba
	    <command>boot /boot/<replaceable>kernel.old</replaceable>/kernel</command>,
            o el nombre de cualquier otro kernel que tenga en el sistema
	    y del que sepa que puede fiarse.  Si va a reconfigurar un
	    kernel es una buen&iacute;sima idea guardar un kernel
	    que sepa que funciona.</para>

	  <para>Tras arrancar con un kernel de fiar verifique el
	    fichero de configuraci&oacute;n e intente de nuevo
	    una compilaci&oacute;n.  El fichero
	    <filename>/var/log/messages</filename> es una fuente de
	    informaci&oacute;n muy valiosa puesto que registra, entre
	    otras cosas, todos los mensajes que deja el kernel cada
	    vez que hay un arranque satisfactorio.  &man.dmesg.8;
	    le mostrar&aacute; los mensajes que el kernel ha
	    generado durante el &uacute;ltimo arranque.</para>

	  <note>
	    <para>Si tiene problemas compilando un kernel recuerde que
	      es de vital importancia que guarde una copia de un kernel
	      <filename>GENERIC</filename> u otro del que pueda fiarse
	      y que (esto es muy importante) tenga un nombre distinto de
	      <filename>kernel.old</filename> para evitar que el sistema
	      lo borre una vez que termine una nueva
	      compilaci&oacute;n.  No puede confiar en su kernel
	      <filename>kernel.old</filename> porque al instalar un nuevo
	      kernel (que a&uacute;n no sabe si ser&aacute; el que
	      funcione tal y como espera de &eacute;l) el kernel
	      <filename>kernel.old</filename> se sobreescribe con el
	      kernel que instale.  Otra cosa importante es que copie
	      ese kernel de fiar a 
	      <filename class="directory">/boot/kernel</filename>, o
	      ciertas herramientas como &man.ps.1; no
	      funcionar&aacute;n.  Basta con que haga lo
	      siguiente:</para>

	    <screen>&prompt.root; <userinput>mv /boot/kernel <replaceable>/boot/kernel.malo</replaceable></userinput>
&prompt.root; <userinput>mv /boot/<replaceable>kernel.bueno</replaceable> /boot/kernel</userinput></screen>

	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>El kernel funciona, pero &man.ps.1; no:</term>

	<listitem>
	  <para>Si el kernel que tiene instalado es de una
	    versi&oacute;n de &os; y las utilidades del sistema
	    son de otra, por ejemplo un kernel -CURRENT en una
	    -RELEASE, hay muchas herramientas de monitorizaci&oacute;n
	    del sistema como &man.ps.1; y &man.vmstat.8; no
	    funcionar&aacute;n.  
	    Ejecute un <link linkend="makeworld">make buildworld y un
	    make install world</link> con la misma versi&oacute;n de
	    c&oacute;digo fuente con la que ha compilado su
	    kernel.  Esta es una de las razones por las que no
	    es una idea demasiado buena utilizar versiones
	    diferentes de kernel y de sistema operativo.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

