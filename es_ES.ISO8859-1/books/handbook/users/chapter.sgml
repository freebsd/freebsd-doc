<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Neil</firstname>
        <surname>Blakey-Milner</surname>
        <contrib>Contributed by </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
  </chapterinfo>

  <title>Usuarios y administraci&oacute;n b&aacute;sica de cuentas</title>
  
  <sect1 id="users-synopsis">
    <title>Sin&oacute;psis</title>

    <para>FreeBSD permite que varios usuarios usen el mismo ordenador.
      Obviamente, s&oacute;lo uno de estos usuarios puede sentarse frente al
      monitor y al teclado en un momento dado
      <footnote>
        <para>Bueno, a menos que conectes m&uacute;ltiples terminales, pero
          dejaremos ese tema para el <xref
          linkend="serialcomms">.</para>
      </footnote>
      , pero cualquier n&uacute;mero de usuarios puede entrar por la red para
      hacer su trabajo.  Para usar el sistema cada usuario ha de tener
      una cuenta.</para>
    
    <para>Despu&eacute;s de leer este cap&iacute;tulo sabr&aacute;s:</para>

    <itemizedlist>
      <listitem>
        <para>Cu&aacute;les son las diferencias entre las distintas cuentas de
          usuario en sistemas FreeBSD.</para>
      </listitem>

      <listitem>
        <para>C&oacute;mo añadir cuentas.</para>
      </listitem>

      <listitem>
        <para>C&oacute;mo eliminar cuentas.</para>
      </listitem>

      <listitem>
        <para>C&oacute;mo cambiar detalles de las cuentas, como el nombre
          completo del usuario, o su shell preferida.</para>
      </listitem>

      <listitem>
        <para>C&oacute;mo establecer l&iacute;mites por cuenta, para controlar los
          recursos como memoria o tiempo de CPU que las cuentas y grupos
          de cuentas pueden emplear.</para>
      </listitem>

      <listitem>
        <para>C&oacute;mo usar grupos para facilitar la administraci&oacute;n de
          cuentas.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de leer este cap&iacute;tulo deber&iacute;as:</para>

    <itemizedlist>
      <listitem>
        <para>Entender los conceptos b&aacute;sicos de Unix y FreeBSD (<xref
          linkend="basics">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>Introducci&oacute;n</title>

    <para>Todos los accesos al sistema se consiguen v&iacute;a cuentas, y todos
      los procesos son ejecutados por usuarios, por ello la
      administraci&oacute;n de usuarios y cuentas es de una gran importancia
      en sistemas FreeBSD.</para>

    <para>Cada cuenta en un sistema FreeBSD tiene cierta informaci&oacute;n
      asociada que la identifica.</para>

    <variablelist>
      <varlistentry>
        <term>Nombre de usuario</term>

        <listitem>
          <para>El nombre de usuario como se le entrar&iacute;a al prompt
            <prompt>login:</prompt>.  Los nombres de usuario han de ser
            &uacute;nicos en la computadora; no puede haber dos usuarios con el
            mismo nombre de usuario.  Existen algunas reglas para la
            creaci&oacute;n de nombres de usuario v&aacute;lidos documentadas en
            &man.passwd.5;; t&iacute;picamente se usar&iacute;an nombres de usuario de
            a lo sumo ocho caracteres, todos ellos en min&uacute;scula.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Contraseña</term>

        <listitem>
          <para>Cada cuenta tiene una contraseña asociada.  La
            contraseña puede ser vac&iacute;a, en cuyo caso no se requerir&aacute;
            ninguna para acceder al sistema.  Esto normalmente es una
            mala idea; cada cuenta deber&iacute;a tener una constraseña no
            vac&iacute;a.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Identificador de usuario (UID)</term>

        <listitem>
          <para>El UID es un numero entre 0 y 65536 que sirve para
            identificar un&iacute;vocamente al usuario en el sistema.
            Internamente, FreeBSD usa el UID para identificar usuarios y
            cualquier comando de FreeBSD que permita especificar un
            nombre de usuario convertir&aacute; &eacute;ste al UID antes de trabajar
            con &eacute;l.  Esto significa que puedes tener varias cuentas con
            nombres de usuario distintos pero con el mismo UID.  En lo
            que a FreeBSD respecta, tales cuentas son un solo usuario.
            Es improbable que alguna vez tengas que hacer algo
            as&iacute;.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Identificador de grupo (GID)</term>

        <listitem>
          <para>El GID es un n&uacute;mero entre 0 y 65536 que sirve para
            identificar un&iacute;vocamente el grupo principal al cual
            pertenece un usuario.  Los grupos son un mecanismo para
            controlar el acceso a recursos del sistema en base al GID,
            en vez del UID.  Esto puede reducir significativamente el
            tamaño de algunos ficheros de configuraci&oacute;n.  Un usuario
            puede pertencer a m&aacute;s de un grupo.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Clase de login</term>

        <listitem>
          <para>Las clases de login son una extensi&oacute;n al mecanismo de
            grupos que ofrecen una mayor flexibilidad a la hora de
            adaptar el sistema a distintos usuarios.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Tiempo de cambio de contraseña</term>

        <listitem>
          <para>Por defecto FreeBSD no obliga a los usuarios a cambiar
            su contraseña peri&oacute;dicamente.  Se puede requerir esto a
            determinados usuarios, haciendo que algunos o todos deban
            cambiar sus contraseñas al cabo de cierto periodo de
            tiempo.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Tiempo de expiraci&oacute;n de cuentas</term>

        <listitem>
          <para>Por defecto las cuentas en FreeBSD no expiran.  Si est&aacute;s
            creando cuentas que sabes que van a tener un tiempo limitado
            de vida, por ejemplo, las cuentas de los estudiantes de una
            escuela, entonces puedes especificar cu&aacute;ndo expiran.  Una
            vez vencido su tiempo de expiraci&oacute;n una cuenta no puede ser
            usada para entrar en el sistema, si bien sus directorios y
            archivos ser&aacute;n conservados.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Nombre completo de usuario</term>

        <listitem>
          <para>El nombre de usuario identifica un&iacute;vocamente a una
            cuenta para FreeBSD, pero no refleja su verdadero nombre
            necesariamente.  Esta informaci&oacute;n puede ser asociada a la
            cuenta. </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Directorio home</term>

        <listitem>
          <para>El directorio home es el camino completo de un
            directorio en el sistema en el que el usuario se hallar&aacute;
            cuando entre.  Una convenci&oacute;n usual consiste en poner todos
            los directorios home en
            <filename>/home/<replaceable>nombre_de_usuario</replaceable></filename>
            o en
            <filename>/usr/home/<replaceable>nombre_de_usuario</replaceable></filename>.
            Los usuarios guardar&iacute;an sus archivos personales en sus
            directorios home, y en cualquier directorio que creasen
            all&iacute;.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Shell de usuario</term>

        <listitem>
          <para>La shell provee el entorno por defecto mediante el cual
            los usuarios interact&uacute;an con el sistema.  Existen varios
            tipos de shell y los usuarios experimentados tendr&aacute;n sus
            propias preferencias, que pueden expresarse en la
            configuraci&oacute;n de su cuenta.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Existen principalmente tres tipos de cuentas; la cuenta de
      <link linkend="users-superuser">superusuario</link>, las cuentas
      de <link linkend="users-system">usuarios del sistema</link>, y las
      de <link linkend="users-user">usuarios</link>.  La cuenta de
      superusuario, normalmente llamada <username>root</username>, se
      usa para administrar el sistema sin limitaciones en los
      privilegios.  Los usuarios del sistema utilizan servicios del
      mismo.  Finalmente, las cuentas de usuarios son usadas por gente
      real, aquellos que entran, leen correo, etc&eacute;tera.</para>
  </sect1>
    
  <sect1 id="users-superuser">
    <title>La cuenta superusuario</title>
    
    <indexterm>
      <primary>cuentas</primary>
      <secondary>superusuario (root)</secondary>
    </indexterm>
    <para>La cuenta superusuario, normalmente llamada
      <username>root</username>, viene preconfigurada para facilitar la
      administraci&oacute;n del sistema, y no deber&iacute;a ser utilizada para tareas
      cotidianas como enviar o recibir correo, exploraci&oacute;n general del
      sistema, o programaci&oacute;n.</para>
      
    <para>Esto es as&iacute; porque el superusuario, a diferencia de las
      cuentas de usuario, puede operar sin l&iacute;mites, y un mal uso de la
      cuenta de superusuario puede conllevar desastres espectaculares.
      Las cuentas de usuario no pueden destruir el sistema por un error,
      por ello es generalmente mejor utilizar cuentas de usuario
      normales cuando sea posible, a no ser que especialmente necesites
      privilegios extra.</para>

    <para>Deber&iacute;as comprobar siempre un par o tres de veces los comandos
      que ejecutas como superusuario, ya que un espacio de m&aacute;s o un
      car&aacute;cter omitido pueden significar una p&eacute;rdida de datos
      irreparable.</para>

    <para>As&iacute; pues, lo primero que deber&iacute;as hacer despu&eacute;s de leer este
      cap&iacute;tulo es crear una cuenta sin privilegios de uso general para
      ti si a&uacute;n no la tienes.  Esto aplica tanto si trabajas en una
      m&aacute;quina con varios usuarios como si trabajas en una m&aacute;quina con un
      solo usuario.  M&aacute;s adelante, en este mismo cap&iacute;tulo, explicamos
      c&oacute;mo crear cuentas adicionales, y c&oacute;mo cambiar de usuario normal a
      superusuario.</para>
  </sect1>
    
  <sect1 id="users-system">
    <title>Cuentas de sistema</title>

    <indexterm>
      <primary>cuentas</primary>
      <secondary>sistema</secondary>
    </indexterm>
    <para>Los usuarios de sistema son aqu&eacute;llos que corren servicios como
      DNS, correo, servidores web, etc.  Esto es as&iacute; por seguridad; si
      todos los servicios corrieran como superusuario podr&iacute;an actuar sin
      ninguna restricci&oacute;n.</para>

    <indexterm>
      <primary>cuentas</primary>
      <secondary><username>daemon</username></secondary>
    </indexterm>
    <indexterm>
      <primary>cuentas</primary>
      <secondary><username>operator</username></secondary>
    </indexterm>
    <para>Algunos ejemplos de usuarios de sistema son
      <username>daemon</username>, <username>operator</username>,
      <username>bind</username> (para el DNS), y
      <username>news</username>.  Con frecuencia, los administradores de
      sistemas crean el usuario <username>httpd</username> para que
      ejecute los servidores web que instalan.</para>

    <indexterm>
      <primary>cuentas</primary>
      <secondary><username>nobody</username></secondary>
    </indexterm>
    <para><username>nobody</username> es el usuario de sistema sin
      privelegios gen&eacute;rico.  No obstante, es importante tener en cuenta
      que cuantos m&aacute;s servicios use <username>nobody</username>, m&aacute;s
      ficheros y procesos estar&aacute;n asociados con dicho usuario, y en
      consecuencia m&aacute;s privilegiado ser&aacute;.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Cuentas de usuario</title>

    <indexterm>
      <primary>cuentas</primary>
      <secondary>usuario</secondary>
    </indexterm>
    <para>Las cuentas de usuario constituyen la principal v&iacute;a de acceso
      al sistema para la gente real.  Estas cuentas a&iacute;slan al usuario
      del entorno, impidiendo que pueda dañar al sistema o a otros
      usuarios, y permitiendo a su vez que pueda personalizar su entorno
      sin que esto afecte a otros.</para>

    <para>Cada persona que acceda a tu sistema deber&iacute;a tener una sola
      cuenta de usuario.  Esto te permite averiguar qui&eacute;n est&aacute; haciendo
      qu&eacute;, evita que interfieran las configuraciones de distintos
      usuarios, que unos puedan leer el correo de otros,
      etc&eacute;tera.</para>

    <para>Cada usuario puede configurar su entorno para acomodarlo al
      uso que hace del sistema, utilizando shells, editores, atajos de
      teclado e idioma alternativos.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Modificaci&oacute;n de cuentas</title>

    <indexterm>
      <primary>cuentas</primary>
      <secondary>modificar</secondary>
    </indexterm>

    <para>Existe una variedad de comandos disponible en el entorno Unix
      para modificar cuentas de usuario.  Los comandos m&aacute;s comunes se
      hallan resumidos a continuaci&oacute;n, seguidos de ejemplos m&aacute;s
      detallados de su uso.</para>

    <informaltable>
      <tgroup cols="2">
    <thead>
      <row>
        <entry>Comando</entry>
        <entry>Resumen</entry>
      </row>
    </thead>
    <tbody>
      <row>
        <entry><command>adduser</command></entry>
        <entry>La aplicaci&oacute;n de l&iacute;nea de comandos recomendada para
          añadir nuevos usuarios.</entry>
      </row>
      <row>
        <entry><command>rmuser</command></entry>
        <entry>La aplicaci&oacute;n de l&iacute;nea de comandos recomendada para
          eliminar usuarios.</entry>
      </row>
      <row>
        <entry><command>chpass</command></entry>
        <entry>Una herramienta flexible para modificar la base de datos
          de usuarios.</entry>
      </row>
      <row>
        <entry><command>passwd</command></entry>
        <entry>Una herramienta de l&iacute;nea de comandos simple para cambiar
          contraseñas de usuario.</entry>
      </row>
      <row>
        <entry><command>pw</command></entry>
        <entry>Una herramienta potente y flexible para modificar
          cualquier aspecto de las cuentas de usuario.</entry>
      </row>
    </tbody>
      </tgroup>
    </informaltable>

    <sect2 id="users-adduser">
      <title>adduser</title>

      <indexterm>
        <primary>cuentas</primary>
        <secondary>añadir</secondary>
      </indexterm>
      <indexterm>
        <primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
        <primary><filename class=directory>/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>directorio esqueleto</primary></indexterm>
      <para><command>adduser</command> es un programa simple para añadir
        usuarios.  Crea entradas en los archivos de sistema
        <filename>passwd</filename> y <filename>group</filename>.
        Tambi&eacute;n crea un directorio home para el nuevo usuario, copia
        all&iacute; ficheros de configuraci&oacute;n por defecto
        (<quote>dotfiles</quote>) de
        <filename>/usr/share/skel</filename>, y opcionalmente puede
        enviar al usuario un mensaje de bienvenida.</para>

      <para>Para crear el fichero inicial de configuraci&oacute;n usa
        <command>adduser -s -config_create</command>.
        <footnote>
          <para>La <option>-s</option> hace que <command>adduser</command>
            sea silencioso por defecto.  M&aacute;s tarde usamos <option>-v</option>
            cuando queremos cambiar valores por defecto.</para>
        </footnote>
        A continuaci&oacute;n configuramos valores por defecto para
        <application>adduser</application> y creamos nuestra primera
        cuenta de usuario, dado que utilizar <username>root</username>
        para uso normal del sistema es pernicioso y peligroso.</para>

      <example>
        <title>Configuraci&oacute;n de adduser</title>

        <screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh zsh [sh]: <userinput>zsh</userinput>
Your default shell is: zsh -&gt; /usr/local/bin/zsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]: 
Send message from file: /etc/adduser.message no 
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh zsh [zsh]: 
Enter home directory (full path) [/home/jru]: 
Uid [1001]: 
Enter login class: default []: 
Login group jru [jru]: 
Login group is ``jru''. Invite jru into other groups: guest no 
[no]: <userinput>wheel</userinput>
Enter password []: 
Enter password again []: 

Name:     jru
Password: ****
Fullname: J. Random User
Uid:      1001
Gid:      1001 (jru)
Class:    
Groups:   jru wheel
HOME:     /home/jru
Shell:    /usr/local/bin/zsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>En resumen, cambiamos la shell por defecto a
        <application>zsh</application> (una shell alternativa incluida
        en la colecci&oacute;n de ports), y deshabilitamos el env&iacute;o de un
        mensaje de bienvenida a nuevos usuarios.  Luego grabamos la
        configuraci&oacute;n, creamos una cuenta para <username>jru</username>,
        y nos aseguramos de que <username>jru</username> est&eacute; en el
        grupo <username>wheel</username> (de modo que puede asumir el
        papel de <username>root</username> v&iacute;a el comando
        <command>su</command>).</para>

      <note>
        <para>La contraseña que escribes no se muestra, tampoco se
          muestran asteriscos.  Aseg&uacute;rate de no entrar dos veces una
          contraseña equivocada.</para>
      </note>

      <note>
        <para>Usa <command>adduser</command> sin argumentos en adelante,
          no necesitar&aacute;s cambiar las opciones por defecto.  Si el
          programa te pide modificarlas sal y prueba con la opci&oacute;n
          <option>-s</option>.</para>
      </note>
    </sect2>

    <sect2 id="users-rmuser">
      <title><application>rmuser</application></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
        <primary>cuentas</primary>
        <secondary>eliminar</secondary>
      </indexterm>

      <para>Puedes usar <command>rmuser</command> para eliminar
        completamente del sistema a un usuario.
        <command>rmuser</command> efect&uacute;a los siguientes pasos:</para>

      <procedure>
        <step>
          <para>Elimina la entrada del usuario en &man.crontab.1; (si
            tiene alguna).</para>
        </step>
        <step>
          <para>Elimina las tareas &man.at.1; pertenecientes al
            usuario.</para>
        </step>
        <step>
          <para>Mata todos los procesos pertenecientes al
            usuario.</para>
        </step>
        <step>
          <para>Elimina al usuario del fichero local de contraseñas del
            sistema.</para>
        </step>
        <step>
          <para>Borra el directorio home del usuario (si le
            pertenece).</para>
        </step>
        <step>
          <para>Elimina los archivos de correo entrante del usuario de
            <filename>/var/mail</filename>.</para>
        </step>
        <step>
          <para>Borra todos los ficheros del usuario de &aacute;reas en las que
            se guardan archivos temporales como
            <filename>/tmp</filename>.</para>
        </step>
        <step>
          <para>Finalmente, elimina el nombre de usuario de todos
            aquellos grupos a los que pertenece en
            <filename>/etc/group</filename>.
        
            <note>
              <para>Si un grupo queda vac&iacute;o y el nombre del grupo
                coincide con el del usuario, el grupo es eliminado; esto
                complementa la creaci&oacute;n de grupos por usuario de
                &man.adduser.8;.</para>
            </note>
          </para>
        </step>
      </procedure>

      <para><command>rmuser</command> no puede ser usado para eliminar
        cuentas de superusuario, dado que algo as&iacute; es casi siempre señal
        de masiva destrucci&oacute;n.</para>

      <para>Por defecto existe un modo interactivo que intenta asegurar
        que uno sabe lo que hace.</para>

      <example>
        <title>Eliminaci&oacute;n interactiva de cuenta con rmuser</title>

        <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/tcsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-chpass">
      <title><application>chpass</application></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para><command>chpass</command> cambia informaci&oacute;n de los usuarios
        en base de datos como contraseñas, shells y datos
        personales.</para>

      <para>Los administradores del sistema, como el superusuario, son
        los &uacute;nicos que pueden modificar la informaci&oacute;n y contraseñas de
        otros usuarios con <command>chpass</command>.</para>

      <para>Cuando no le pasamos m&aacute;s opciones, salvo un nombre de
        usuario opcional, <command>chpass</command> muestra un editor
        con informaci&oacute;n de usuario.  Cuando se sale del editor la base
        de datos de usuarios se actualiza con la nueva
        informaci&oacute;n.</para>

      <example>
        <title>chpass interactivo ejecutado por el superusuario</title>

        <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1000
Gid [# or name]: 1000
Change [month day year]:

Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Un usuario normal puede modificar un pequeño subconjunto de
        esta informaci&oacute;n, y s&oacute;lo para s&iacute; mismo.</para>

      <example>
        <title>chpass interactivo ejecutado por un usuario normal</title>

      <screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
        <para><command>chfn</command> y <command>chsh</command> son
          enlaces a <command>chpass</command>, como tambi&eacute;n lo son
          <command>ypchpass</command>, <command>ypchfn</command>, e
          <command>ypchsh</command>.  El soporte para NIS es autom&aacute;tico,
          por lo que no es necesario especificar el
          <literal>yp</literal> antes del comando.  Si esto te resulta
          algo confuso no te preocupes, NIS ser&aacute; tratado en el <xref
          linkend="advanced-networking">.</para>
      </note>
    </sect2>

    <sect2 id="users-passwd">
      <title>passwd</title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
        <primary>cuentas</primary>
        <secondary>cambiar contraseña</secondary>
      </indexterm>
      <para><command>passwd</command> es el comando que se usa
        normalmente para cambiar tu propia contraseña como usuario o,
        como superusuario, la de otros usuarios.</para>

      <note>
        <para>Los usuarios han de introducir su contraseña original
          antes de cambiarla para prevenir que gente no autorizada pueda
          hacerlo cuando no se encuentren en la consola.</para>
      </note>

      <example>
        <title>Cambio de tu contraseña</title>

        <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
        <title>Cambio de la contraseña de otro usuario como superusuario</title>

        <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
        <para>Como ocurre con <command>chpass</command>,
          <command>yppasswd</command> es un enlace a
          <command>passwd</command>, de manera que NIS funciona con
          ambos comandos.</para>
      </note>
    </sect2>

    <sect2 id="users-pw">
      <title><application>pw</application></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; es una utilidad de l&iacute;nea de comandos para crear,
        eliminar, modificar, y mostrar usuarios y grupos.  Hace de
        interfaz a los archivos del sistema de usuarios y grupos.
        <command>pw</command> tiene un conjunto de opciones de l&iacute;nea de
        comandos bastante potente que lo hacen adecuado para su uso en
        scripts de shell, aunque los nuevos usuarios puede que lo
        encuentren algo m&aacute;s complicado que el resto de comandos que
        presentamos aqu&iacute;.</para>
    </sect2>

  </sect1>

  <sect1 id="users-limiting">
    <title>Limitar a los usuarios</title>

    <indexterm><primary>limitar a los usuarios</primary></indexterm>
    <indexterm>
      <primary>cuentas</primary>
      <secondary>limitar</secondary>
    </indexterm>
    <para>En un sistema multiusuario es probable que no conf&iacute;es en que
      el sistema no vaya a ser dañado por ning&uacute;n usuario.</para>

    <indexterm><primary>cuotas</primary></indexterm>
    <indexterm>
      <primary>limitar a los usuarios</primary>
      <secondary>cuotas</secondary>
    </indexterm>
    <indexterm><primary>cuotas de disco</primary></indexterm>
    <para>Las cuotas de disco permiten al administrador decirle al
      sistema de ficheros qu&eacute; cantidad de espacio de disco puede
      utilizar un usuario; adem&aacute;s, ofrecen una manera r&aacute;pida de
      comprobar el uso de disco de un usuario sin tener que calcularlo
      cada vez.  Las cuotas se estudian en el cap&iacute;tulo de quotas.</para>

    <para>El resto de l&iacute;mites de recursos incluyen cantidad de CPU,
      memoria, y otros recursos que el usuario puede utilizar.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Las clases de login se definen en
      <filename>/etc/login.conf</filename>.  La sem&aacute;ntica precisa est&aacute;
      fuera del alcance de esta secci&oacute;n, pero se describe con detalle en
      la p&aacute;gina de manual &man.login.conf.5;.  Es suficiente decir que
      cada usuario es asignado a una clase de login
      (<literal>default</literal> por defecto), y que cada clase de
      login tiene un conjunto de capacidades asociado.  Una capacidad
      de login es un par
      <literal><replaceable>nombre</replaceable>=<replaceable>valor</replaceable></literal>,
      donde <replaceable>nombre</replaceable> es un identificador
      conocido y <replaceable>valor</replaceable> una cadena de texto
      arbitraria que se procesa en funci&oacute;n del nombre.  Establecer
      clases y capacidades de login es bastante sencillo y tambi&eacute;n se
      describe en &man.login.conf.5;.</para>

    <para>Los l&iacute;mites de recursos son diferentes de las capacidades de
      login en dos sentidos.  En primer lugar, para cada l&iacute;mite existe
      un l&iacute;mite blando (actual) y uno duro.  Un l&iacute;mite blando puede ser
      ajustado por el usuario o una aplicaci&oacute;n, pero no puede ser m&aacute;s
      alto que el l&iacute;mite duro.  Éste &uacute;ltimo puede ser disminuido por el
      usuario pero nunca aumentado.  En segundo lugar, la mayor&iacute;a de los
      l&iacute;mites de recursos aplican a un usuario concreto por proceso, no
      globalmente.  N&oacute;tese, no obstante, que estas diferencias vienen
      impuestas por c&oacute;mo se tratan los l&iacute;mites espec&iacute;ficamente, no por
      la implementaci&oacute;n del marco de capacidades de login (es decir, en
      realidad no constituyen un caso especial de capacidades de
      login).</para>

    <para>Sin m&aacute;s, a continuaci&oacute;n veremos los l&iacute;mites de recursos m&aacute;s
      com&uacute;nmente usados (el resto, junto con el resto de capacidades de
      login, puede encontrarse en &man.login.conf.5;).</para>

    <variablelist>
      <varlistentry>
        <term><literal>coredumpsize</literal></term>

        <listitem>
          <indexterm><primary>coredumpsize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>coredumpsize</secondary>
          </indexterm>
          <para>El tamaño de un fichero core generado por un programa
            est&aacute;, por razones obvias, subordinado a otros l&iacute;mites sobre
            uso de disco (p. ej., <literal>filesize</literal>, o cuotas
            de disco).  Aun y as&iacute;, se usa frecuentemente como un m&eacute;todo
            menos severo de controlar consumo de espacio de disco, dado
            que los usuarios no generan ficheros core por ellos mismos,
            y a menudo no los borran, activar este l&iacute;mite puede evitar
            que agoten el espacio de disco de que disponen si alg&uacute;n
            programa grande (p. ej., <application>emacs</application>)
            deja de funcionar abruptamente.</para>
          </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

        <listitem>
          <indexterm><primary>cputime</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>cputime</secondary>
          </indexterm>
          <para>Ésta es la m&aacute;xima cantidad de tiempo de CPU que los
            procesos de un usuario pueden consumir.

            <note>
              <para>Éste es un l&iacute;mite sobre el
                <emphasis>tiempo</emphasis> de CPU consumido, no el
                porcentaje de uso de CPU que se muestra en algunos
                campos de &man.top.1; y &man.ps.1;.  Un l&iacute;mite de ese
                tipo no es posible a d&iacute;a de hoy, y ser&iacute;a bastante
                in&uacute;til: un compilador &mdash;probablemente una tarea
                leg&iacute;tima&mdash; puede usar pr&aacute;cticamente el 100% de la
                CPU durante alg&uacute;n tiempo con facilidad.</para>
            </note>
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

        <listitem>
          <indexterm><primary>filesize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>filesize</secondary>
          </indexterm>
          <para>Éste es el tamaño m&aacute;ximo que puede llegar a tener un
            fichero del usuario.  A diferencia de las cuotas de disco, este 
            l&iacute;mite se especifica para ficheros individuales, no para 
            el conjunto de todos los archivos que posee.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

        <listitem>
          <indexterm><primary>maxproc</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>maxproc</secondary>
          </indexterm>
          <para>Éste es el m&aacute;ximo n&uacute;mero de procesos que un usuario
            puede ejecutar a la vez, incluidos tanto los procesos en
            primer plano como los procesos en segundo plano.  Por
            razones obvias, este l&iacute;mite no puede ser mayor que el l&iacute;mite
            de sistema especificado por <varname>kern.maxproc</varname>
            <command>sysctl</command>.  Obs&eacute;rvese tambi&eacute;n que si
            asignamos un valor demasiado bajo a este l&iacute;mite podemos
            mermar la productividad de un usuario: frecuentemente es
            &uacute;til entrar m&uacute;ltiples veces en el sistema o ejecutar
            pipelines.  Algunas tareas, como compilar largos programas,
            lanzan m&uacute;ltiples procesos (p. ej., &man.make.1;, &man.cc.1;,
            y dem&aacute;s preprocesadores intermedios).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

        <listitem>
          <indexterm><primary>memorylocked</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>memorylocked</secondary>
          </indexterm>
          <para>Ésta es la m&aacute;xima cantidad de memoria que un proceso
            puede haber solicitado tener bloqueada en memoria principal
            (p. ej., ver &man.mlock.2;).  Algunos programas cr&iacute;ticos
            para el sistema, como &man.amd.8;, se quedan bloqueados en
            la memoria principal de manera que en caso de ser llevados a
            swap no contribuyan a la basura del sistema si hay alg&uacute;n
            problema.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memoryuse</literal></term>

        <listitem>
          <indexterm><primary>memoryuse</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>memoryuse</secondary>
          </indexterm>
          <para>Ésta es la mayor cantidad de memoria que un proceso
            puede consumir en todo momento.  Incluye tanto memoria
            normal como uso de swap.  No se trata de un l&iacute;mite para
            restringir el consumo de memoria en general, pero es un buen
            comienzo.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>openfiles</literal></term>

        <listitem>
          <indexterm><primary>openfiles</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>openfiles</secondary>
          </indexterm>
          <para>Ésta es la m&aacute;xima cantidad de archivos que un proceso
            puede tener abiertos.  En FreeBSD, los archivos se usan
            tambien para representar sockets y canales IPC; as&iacute;, cuida
            de no poner este l&iacute;mite demasiado bajo.  A nivel de sistema,
            el l&iacute;mite para esto lo define
            <varname>kern.maxfiles</varname>
            <command>sysctl</command>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>sbsize</literal></term>

        <listitem>
          <indexterm><primary>sbsize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>sbsize</secondary>
          </indexterm>
          <para>Éste es el l&iacute;mite de cantidad de memoria de red, y por
            lo tanto mbufs, que un usuario puede consumir.  Se origin&oacute;
            como respuesta a un viejo ataque DoS que creaba muchos
            sockets, pero puede ser usado en general para limitar las
            comunicaciones por red.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>stacksize</literal></term>

        <listitem>
          <indexterm><primary>stacksize</primary></indexterm>
          <indexterm>
            <primary>limitar a los usuarios</primary>
            <secondary>stacksize</secondary>
          </indexterm>
            <para>Éste es el tamaño m&aacute;ximo que puede alcanzar la pila de
              un proceso.  Por s&iacute; solo no es suficiente para limitar la
              cantidad de memoria que puede usar un programa; en
              consecuencia, deber&iacute;a ser usado junto con otros
              l&iacute;mites.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Hay unas pocas cosas m&aacute;s a recordar cuando establecemos
      l&iacute;mites de recursos.  A continuaci&oacute;n vienen algunas
      recomendaciones, sugerencias, y comentarios varios.</para>

    <itemizedlist>
      <listitem>
        <para>Los procesos que se ponen en marcha cuando arranca el
          sistema por <filename>/etc/rc</filename> est&aacute;n asignados a la
          clase de login <literal>daemon</literal>.</para>
      </listitem>

      <listitem>
        <para>Aunque el <filename>/etc/login.conf</filename> que viene
          con el sistema tiene valores razonables para la mayor&iacute;a de los
          l&iacute;mites, s&oacute;lo t&uacute;, el administrador, puedes saber lo que es
          apropiado para tu sistema.</para>
      </listitem>

      <listitem>
        <para>A los usuarios del X Window System (X11) probablemente se
          les deber&iacute;a conceder m&aacute;s recursos que al resto.  X11 de por s&iacute;
          consume muchos recursos, pero adem&aacute;s contribuye a que los
          usuarios ejecuten m&aacute;s programas simult&aacute;neamente.</para>
      </listitem>

      <listitem>
        <para>Recuerda que hay muchos l&iacute;mites que aplican a procesos
          individuales, no al usuario en general.  Por ejemplo, poner
          <varname>openfiles</varname> a 50 significa que cada uno de
          los procesos que ejecute un usuario puede abrir a lo m&aacute;ximo 50
          ficheros.  As&iacute;, la cantidad de ficheros que un usuario puede
          abrir es el valor de <literal>openfiles</literal> multiplicado
          por el valor de <literal>maxproc</literal>.  Esto tambi&eacute;n
          aplica al uso de memoria.</para>
      </listitem>
    </itemizedlist>

    <para>Para m&aacute;s informaci&oacute;n acerca de l&iacute;mites de recursos y clases y
      capacidades de login en general, consulta las p&aacute;ginas de manual
      relevantes: &man.cap.mkdb.1;, &man.getrlimit.2;,
      &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-personalizing">
    <title>Personalizar a los usuarios</title>

    <para>La localizaci&oacute;n es un entorno establecido por el administrador
      o el usuario para dar soporte a distintos lenguajes, juegos de
      caracteres, est&aacute;ndares sobre fechas y horas, etc&eacute;tera.  Éste tema
      se trata en el cap&iacute;tulo <link
      linkend="l10n">Localizaci&oacute;n</link>.</para>
  </sect1>

  <sect1 id="users-groups">
    <title>Grupos</title>

    <indexterm><primary>grupos</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/group</filename></primary>
    </indexterm>
    <indexterm>
      <primary>cuentas</primary>
      <secondary>grupos</secondary>
    </indexterm>
    <para>Un grupo es simplemente una lista de usuarios.  Los grupos se
      identifican por su nombre de grupo y gid (ID de grupo).  En
      FreeBSD (y en la mayor&iacute;a de sistemas Unix), los dos factores que
      tiene en cuenta el n&uacute;cleo para decidir si un proceso puede hacer
      algo es su ID de usuario y la lista de grupos a los que pertenece.
      A diferencia del ID de usuario, un proceso tiene una lista de
      grupos asociados.  En ocasiones encontrar&aacute;s menciones al "ID de
      grupo" de un usuario o de un proceso; la mayor&iacute;a de las veces
      referir&aacute;n simplemente al primero de los grupos de la lista.</para>

    <para>La correspondencia entre nombres e IDs de grupo est&aacute; en
      <filename>/etc/group</filename>.  Se trata de un fichero de texto
      plano con cuatro campos separados por el signo dos puntos.  El
      primer campo es el nombre de grupo, el segundo la contraseña
      encriptada, el tercero el ID de grupo, y el cuarto la lista de
      miembros separados por comas.  Puede ser editado a mano sin
      peligro (¡suponiendo, por supuesto, que no se cometan errores de
      sintaxis!).  Para una descripci&oacute;n m&aacute;s completa de la sintaxis, ver
      la p&aacute;gina de manual &man.group.5;.</para>

    <para>Si no quieres editar <filename>/etc/group</filename>
      manualmente, puedes usar el comando &man.pw.8; para añadir y
      modificar grupos.  Por ejemplo, para añadir un grupo llamado
      <groupname>teamtwo</groupname> y luego confirmar que existe puedes
      usar:</para>

    <example>
      <title>Añadir un grupo usando &man.pw.8;</title>

      <screen>&prompt.root; <userinput><command>pw</command> groupadd <groupname>teamtwo</groupname></userinput>
&prompt.root; <userinput><command>pw</command> groupshow <groupname>teamtwo</groupname></userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>El n&uacute;mero <literal>1100</literal> en el ejemplo anterior es el
      ID de grupo del grupo <groupname>teamtwo</groupname>.  Ahora mismo
      <groupname>teamtwo</groupname> no tiene miembros, y es por tanto
      bastante in&uacute;til.  Cambiemos eso invitando a
      <username>jru</username> a formar parte del grupo
      <groupname>teamtwo</groupname>.</para>

    <example>
      <title>Añadir a alguien a un grupo usando &man.pw.8;</title>

      <screen>&prompt.root; <userinput><command>pw</command> groupmod <groupname>teamtwo</groupname> <option>-M</option> <username>jru</username></userinput>
&prompt.root; <userinput><command>pw</command> groupshow <groupname>teamtwo</groupname></userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>El argumento de la opci&oacute;n <option>-M</option> es una lista con
      los usuarios que son miembros del grupo separados por comas.
      Sabemos de secciones anteriores que el fichero de contraseñas
      tambi&eacute;n contiene un grupo para cada usuario.  El usuario es
      autom&aacute;ticamente añadido a la lista de grupos por el sistema; no
      constar&aacute; como miembro cuando usemos el comando
      <command>groupshow</command> con &man.pw.8;, pero s&iacute; cuando la
      informaci&oacute;n se consulte con &man.id.1; u otra herramienta similar.
      En otras palabras, &man.pw.8; s&oacute;lo manipula el fichero
      <filename>/etc/group</filename>; nunca tratar&aacute; de leer datos
      adicionales de <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Determinar pertenencia a grupos con &man.id.1;</title>

      <screen>&prompt.user; <userinput><command>id</command> <username>jru</username></userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Como puedes ver, <username>jru</username> es miembro de los
      grupos <groupname>jru</groupname> y
      <groupname>teamtwo</groupname>.</para>

    <para>Para m&aacute;s informaci&oacute;n acerca de &man.pw.8;, consulta su p&aacute;gina
      de manual, y para m&aacute;s informaci&oacute;n acerca del formato de
      <filename>/etc/group</filename>, consulta la p&aacute;gina de manual de
      &man.group.5;.</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
