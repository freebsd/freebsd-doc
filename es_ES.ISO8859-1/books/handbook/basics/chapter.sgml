<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Reescrito por </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>Conceptos b&aacute;sicos de Unix</title>
  
  <sect1 id="basics-synopsis">
    <title>Sinopsis</title>

  <para>El siguiente cap&iacute;tulo comprende la funcionalidad y
    &oacute;rdenes b&aacute;sicas del sistema operativo &os;.  
    Gran parte de este material es relevante para cualquier sistema
    operativo tipo &unix;.
    Puede saltarse este cap&iacute;tulo si considera que ya conoce 
    el funcionamiento de &unix;.  
    Si no tiene experiencia previa con &os; deber&iacute;a leer este 
    cap&iacute;tulo con mucha atenci&oacute;n.</para>

    <para>Despu&eacute;s de leer este cap&iacute;tulo, usted
      sabr&aacute;:</para>

    <itemizedlist>
      <listitem>
        <para>C&oacute;mo usar las <quote>consolas virtuales</quote> de
            FreeBSD.</para>
      </listitem>
      <listitem>
        <para>C&oacute;mo funcionan los permisos de fichero &unix; en 
          relaci&oacute;n con las banderas de fichero en &os;.</para>
      </listitem>
      <listitem>
	<para>La disposici&oacute;n de sistemas de ficheros por defecto 
	  en &os;.</para>
      </listitem>
      <listitem>
	<para>La organizaci&oacute;n de disco de &os;.</para>
      </listitem>
      <listitem>
	<para>C&oacute;mo montar y desmontar sistemas de ficheros.</para>
      </listitem>
      <listitem>
	<para>Qu&eacute; son los procesos, d&aelig;mons y se&ntilde;ales.</para>
      </listitem>
      <listitem>
	<para>Qu&eacute; es una shell, c&oacute;mo modificar sus variables
	  de ambiente de login por defecto.</para>
      </listitem>
      <listitem>
	<para>C&oacute;mo utilizar editores de texto b&aacute;sicos.</para>
      </listitem>
      <listitem>
	<para>Qu&eacute; son los dispositivos y nodos de dispositivos.</para>
      </listitem>
      <listitem>
	<para>Qu&eacute; formato binario se usa en &os;.</para>
      </listitem>
      <listitem>
	<para>C&oacute;mo buscar informaci&oacute;n en las  p&aacute;ginas 
	  de manual.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Consolas virtuales y terminales</title>
    <indexterm><primary>consola virtual</primary></indexterm>
    <indexterm><primary>terminales</primary></indexterm>

    <para>&os; puede utilizarse de muchas maneras.  Una de ellas es
      tecleando &oacute;rdenes en una terminal de texto.  De este modo, mucha 
      de la flexibilidad y poder de un sistema operativo &unix; est&aacute; 
      inmediatamente en sus manos cuando usa &os;.  Esta secci&oacute;n 
      describe qu&eacute; son <quote>terminales</quote> y 
      <quote>consolas</quote>, y c&oacute;mo puede usarlas en &os;.</para>

    <sect2 id="consoles-intro">
      <title>La consola</title>
      <indexterm><primary>consola</primary></indexterm>

      <para>Si no ha configurado FreeBSD para iniciar autom&aacute;ticamente  
        un entorno gr&aacute;fico en el arranque, el sistema le
        presentar&aacute; un <quote>prompt</quote> de entrada despu&eacute;s 
        del arranque, inmediatamente despu&eacute;s de que los 
        <quote>scripts</quote> de inicio terminen de ejecutarse.  
        Ver&aacute; algo similar a esto:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.ejemplo.org) (ttyv0)

login:</screen>

      <para>Los mensajes pueden ser un poco diferentes en su sistema, pero
        ver&aacute; algo similar. Las &uacute;ltimas dos l&iacute;neas son
        las que nos interesan por el momento. La pen&uacute;ltima l&iacute;nea
        dice:</para>

      <programlisting>FreeBSD/i386 (pc3.ejemplo.org) (ttyv0)</programlisting>

      <para>Esta l&iacute;nea contiene informaci&oacute;n
        acerca del sistema que acaba de arrancar.  Esta usted ante una
        consola <quote>FreeBSD</quote> que se ejecuta en un procesador Intel
        o compatible de la arquitectura x86<footnote>
          <para>Esto es lo que <literal>i386</literal> significa.  Tenga en 
            cuenta que incluso si no est&aacute; ejecutando &os; en una CPU 
            Intel 386, &eacute;ste va a ser <literal>i386</literal>.  
            No es el tipo de su procesador, sino la 
            <quote>arquitectura</quote> la que se muestra aqu&iacute;.</para>
	</footnote>.
        El nombre de esta m&aacute;quina (cada m&aacute;quina &unix;
        tiene un nombre) es <hostid>pc3.ejemplo.org</hostid>, y usted
        est&aacute; ahora ante su consola de sistema (la
        terminal <devicename>ttyv0</devicename>).</para>

      <para>Finalmente, la &uacute;ltima l&iacute;nea siempre es:</para>

      <programlisting>login:</programlisting>

      <para>Esta es la parte donde se supone que usted tecl&eacute;e
        su <quote>nombre de usuario</quote> para entrar en &os;.  
        La siguiente secci&oacute;n describe c&oacute;mo hacerlo.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>La entrada a &os;</title>

      <para>&os; es un sistema multiusuario multiprocesador. Esta 
        es la descripci&oacute;n formal que se suele dar a un
        sistema que puede ser utilizado por muchas personas diferentes,
        que simult&aacute;neamente ejecutan muchos programas en un sola
        m&aacute;quina.</para>

      <para>Cada sistema multiusuario necesita alg&uacute;n modo de 
        distinguir a un <quote>usuario</quote> del resto. En &os; 
        (y en todos los sistemas operativos tipo &unix;) esto se
        logra requiriendo que cada usuario debe <quote>acceder</quote>
        al sistema antes de poder ejecutar programas.  Cada usuario
        tiene un nombre &uacute;nico (el <quote>nombre de usuario</quote>)
        y una clave secreta, personal (la <quote>contrase&ntilde;a</quote>).  
        &os; preguntar&aacute; por ambos antes de permitirle a
        un usuario ejecutar cualquier programa.</para>

      <indexterm><primary>scripts de inicio</primary></indexterm>
      <para>Justo despu&eacute;s de que &os; arranque y termine de 
        ejecutar sus <quote>scripts</quote> de inicio 
        <footnote>
          <para>Los <quote>scripts</quote> de inicio son programas que &os;
            ejecuta autom&aacute;ticamente cuando arranca.  Su funci&oacute;n
            principal es preparar las cosas para que todo lo dem&aacute;s
            se ejecute, e iniciar cualquier servicio que tenga configurado
            para ejecutarse en segundo plano haciendo cosas 
            &uacute;tiles.</para>
        </footnote>, le presentar&aacute; un <quote>prompt</quote> y 
        solicitar&aacute; un nombre v&aacute;lido de usuario:</para>

      <screen>login:</screen>

      <para>En este ejemplo vamos a asumir que su nombre de
        usuario es <username>john</username>.  Tecl&eacute;e 
        <literal>john</literal> en el <quote>prompt</quote> y pulse 
        <keycap>Enter</keycap>.  Deber&iacute;a present&aacute;rsele un 
        <quote>prompt</quote> donde introducir una 
        <quote>contrase&ntilde;a</quote>:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Tecl&eacute;e ahora la contrase&ntilde;a de <username>john</username>
        y pulse <keycap>Enter</keycap>. La contrase&ntilde;a 
        <emphasis>no se muestra en pantalla</emphasis>, pero no debe 
        preocuparse por ello.  Esto se hace as&iacute; por motivos de 
        seguridad.</para>

      <para>Si ha tecleado su contrase&ntilde;a correctamente ya est&aacute; 
        usted en un sistema &os;, listo para probar todas las 
        &oacute;rdenes disponibles.</para>

      <para>Ver&aacute; el <acronym>MOTD</acronym> (mensaje del d&iacute;a) 
        seguido por un <quote>prompt</quote> (un caracter <literal>#</literal>,
        <literal>$</literal> o <literal>%</literal>).  Esto confirma 
        que ha validado con &eacute;xito su usuario en &os;.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Consolas m&uacute;ltiples</title>

      <para>Ejecutar &oacute;rdenes &unix; en una consola est&aacute; bien, 
        pero &os; puede ejecutar muchos programas a la vez.  Tener una consola
        donde se pueden teclear &oacute;rdenes puede ser un poco de desperdicio 
        cuando un sistema operativo como &os; puede ejecutar docenas de 
        programas al mismo tiempo.  Aqu&iacute; es donde las
        <quote>consolas virtuales</quote> pueden ser de mucha ayuda.</para>

      <para>&os; puede ser configurado para presentarle diferentes
        consolas virtuales.  Puede cambiar de una de ellas a cualquier
        otra consola virtual pulsando un par de teclas en su teclado.  
        Cada consola tiene su propio canal de salida, y &os; 
        se ocupa de redireccionar correctamente la entrada del teclado y
        la salida al monitor cuando cambia de una consola virtual a la
        siguiente.</para>

      <para>Se han reservado ciertas combinaciones especiales de teclas 
        para pasar de unas consolas virtuales a otras en &os; <footnote>
        <para>Tiene una descripci&oacute;n bastante t&eacute;cnica y correcta
          de todos los detalles de la consola &os; y los controladores de
          teclado pueden encontrarse en las p&aacute;ginas de manual de
          &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; y
          &man.kbdcontrol.1;. No nos extenderemos en los detalles aqu&iacute;,
          pero el lector interesado siempre puede consultar dichas 
          p&aacute;ginas de manual si quiere una explicaci&oacute;n 
          m&aacute;s detallada y profunda de c&oacute;mo funcionan 
          estas cosas.</para>
	</footnote>. Puede utilizar
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> y 
         as&iacute; sucesivamente hasta 
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> para 
         cambiar a una consola virtual diferente en &os;.</para>

      <para>Mientras est&aacute; cambiando de una consola a la siguiente, 
        FreeBSD se ocupa de guardar y restaurar la salida de pantalla. El 
        resultado es la <quote>ilusi&oacute;n</quote> de tener varias 
        pantallas y teclados <quote>virtuales</quote> que puede utilizar 
        para teclear &oacute;rdenes para que los ejecute &os;.  El programa que 
        usted lanza en una consola virtual no deja de ejecutarse cuando la 
        consola no est&aacute; visible.  Contin&uacute;an ejecut&aacute;ndose 
        cuando se cambia a una consola virtual diferente.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>El fichero <filename>/etc/ttys</filename></title>

      <para>La configuraci&oacute;n por defecto de &os; iniciar&aacute;
        con ocho consolas virtuales.  Esta no es una configuraci&oacute;n
        est&aacute;tica por hardware y usted puede personalizar 
        f&aacute;cilmente su sistema para arrancar con m&aacute;s o menos 
        consolas virtuales.  El n&uacute;mero y propiedades de las consolas
        virtuales est&aacute;n detallados en 
        <filename>/etc/ttys</filename>.</para>

      <para>Use <filename>/etc/ttys</filename> para
        configurar las consolas virtuales de &os;.  Cada l&iacute;nea no
        comentada de este fichero (l&iacute;neas que no comienzan con un
        caracter <literal>#</literal>) contiene propiedades para una sola
        terminal o consola virtual.  La versi&oacute;n por defecto de
        este fichero en FreeBSD configura nueve consolas
        virtuales y habilita ocho de ellas.  Son las l&iacute;neas que 
        comienzan con <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Consulte &man.ttys.5; si quiere una descripci&oacute;n detallada 
        de cada columna en este fichero y todas las opciones que puede usar 
        para configurar las consolas virtuales.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Consola en modo monousuario</title>

      <para>En la <xref linkend="boot-singleuser"> encontrar&aacute; una 
        descripci&oacute;n detallada de lo que es <quote>modo
        monousuario</quote>
        No importa que solo exista una consola cuando ejecuta &os; en
        modo monousuario.  No existen consolas virtuales disponibles.  Las
        configuraciones de la consola en modo monousuario se pueden encontrar
        tambi&eacute;n en <filename>/etc/ttys</filename>.  Busque la
        l&iacute;nea que comienza con <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# Si la consola est&aacute; marcada como "insecure", entonces init 
# le pedir&aacute; la contrase&ntilde;a de root al entrar a modo monousuario.
console none                            unknown off secure</programlisting>

      <note>
        <para>Tal y como indican los comentarios por encima de la 
          l&iacute;nea <literal>console</literal>, puede editar esta 
          l&iacute;nea y cambiar <literal>secure</literal> por 
          <literal>insecure</literal>.  Si lo hace, cuando &os; arranque 
          en modo monousuario el sistema le pedir&aacute; la 
          contrase&ntilde;a de <username>root</username>.
          <para>

        <para><emphasis>Tenga cuidado si cambia esto a 
          <literal>insecure</literal></emphasis>.  Si olvida la
          contrase&ntilde;a de <username>root</username> arrancar
          en modo monousuario ser&aacute; con seguridad m&aacute;s 
          complicado.  Sigue siendo posible, pero ser&aacute; un poco 
          dif&iacute;cil para alguien que no est&eacute; familiarizado 
          con le proceso de arranque de &os; y los programas involucrados 
          en dicho proceso.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Permisos</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>&os;, cuya ra&iacute;z hist&oacute;rica es el UNIX BSD, 
      se fundamenta en varios conceptos clave de UNIX. El primero y
      m&aacute;s importante es que &os; es un sistema operativo
      multi-usuario.  El sistema puede gestionar varios usuarios trabajando
      simult&aacute;neamente y en tareas que no guardan relaci&oacute;n
      entre s&iacute;.  El sistema se encarga de compartir y administrar
      peticiones de dispositivos de hardware, perif&eacute;ricos, memoria y
      tiempo de Unidad Central de Proceso (CPU) de manera equitativa para cada
      usuario.</para>

    <para>Debido a que el sistema es capaz de soportar m&uacute;ltiples
      usuarios, todo lo que el sistema administra tiene un conjunto de
      permisos que usa para decidir qui&eacute;n puede leer, escribir y 
      ejecutar un recurso.  Estos permisos se guardan como octetos 
      divididos en tres partes: una para el propietario del fichero, otra 
      para el grupo al que el fichero pertenece, y otra para todos los 
      dem&aacute;s grupos y usuarios.  Veamos una 
      representaci&oacute;n num&eacute;rica de esto:</para>

    <indexterm><primary>permisos</primary></indexterm>
    <indexterm>
      <primary>permisos de fichero</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valor</entry>
	    <entry>Permiso</entry>
	    <entry>Listado de directorio</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>No leer, no escribir, no ejecutar</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>No leer, no escribir, ejecutar</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>No leer, escribir, no ejecutar</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>No leer, escribir, ejecutar</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Leer, no escribir, no ejecutar</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Leer, no escribir, ejecutar</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Leer, escribir, no ejecutar</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Leer, escribir, ejecutar</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directorios</primary></indexterm>

    <para>Puede utilizar el par&aacute;metro de l&iacute;nea de &oacute;rdenes 
      <option>-l</option> de &man.ls.1; para ver un listado 
      largo que incluya una columna con informaci&oacute;n acerca 
      de los permisos de fichero para el propietario, grupo y 
      los dem&aacute;s.  Por ejemplo, un <command>ls -l</command> en 
      un directorio arbitrario puede mostrar algo como esto:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 mifichero
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otrofichero
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Aqu&iacute; est&aacute; como se divide la primera columna
      de <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>El primer caracter (m&aacute;s a la izquierda) indica si
      este fichero es un fichero regular, un directorio, un
      dispositivo especial de caracter, un socket o cualquier otro
      dispositivo especial pseudo-ficheroa . En este caso, el 
      <literal>-</literal> un fichero regular.  Los siguientes tres 
      caracteres, <literal>rw-</literal> en este ejemplo, dan los permisos
      para el propietario del fichero.  Los siguientes tres caracteres,
      <literal>r--</literal>, dan los permisos para el grupo al que
      el fichero pertenece.  Los &uacute;ltimos tres caracteres,
      <literal>r--</literal>, dan los permisos para el resto del
      mundo.  Un gui&oacute;n indica que el permiso est&aacute; desactivado.  
      En el caso de este fichero, los permisos est&aacute;n 
      asignados de tal manera que el propietario puede leer y escribir
      en el fichero, el grupo puede leer el fichero, y el resto del
      mundo s&oacute;lo puede leer el fichero.  De acuerdo con la tabla
      de arriba, los permisos para este fichero ser&iacute;an 
      <literal>644</literal>,
      donde cada d&iacute;gito representa las tres partes de los 
      permisos del fichero.</para>

    <para>Todo &eacute;sto est&aacute; muy bien, pero &iquest;c&oacute;mo
      controla el sistema los permisos de los dispositivos? &os; en
      realidad trata la mayor&iacute;a de los dispositivos hardware como un
      fichero que los programas pueden abrir, leer y en los que pueden
      escribir datos como si de cualquier otro fichero se tratara.  Estos
      ficheros especiales de dispositivo se encuentran en el directorio
      <filename>/dev</filename>.</para>

    <para>Los directorios tambi&eacute;n son tratados como ficheros.  Tienen
      permisos de lectura, escritura y ejecuci&oacute;n.  El bit de
      ejecuci&oacute;n en un directorio tiene un significado
      ligeramente distinto que para los ficheros.  Cuando un directorio
      est&aacute; marcado como ejecutable significa que se puede mirar dentro,
      se puede hacer un <quote>cd</quote> (cambiar directorio) a &eacute;l.  
      Esto tambi&eacute;n significa que dentro del directorio es posible 
      acceder a ficheros cuyos nombres son conocidos (sujeto, claro est&aacute;,
      a los permisos de los ficheros mismos).</para>

    <para>En particular, para poder realizar un listado de directorio,
      el permiso de lectura debe ser activado en el directorio,
      mientras que para borrar un fichero del que se conoce el
      nombre es necesario tener permisos de escritura <emphasis>y</emphasis>
      ejecuci&oacute;n en el directorio que contiene el fichero.</para>

    <para>Existen m&aacute;s permisos, pero se usan principalmente en
      circunstancias especiales como los binarios ejecutables de tipo setuid
      y los los directorios de tipo <quote>sticky</quote>.  Si desea m&aacute;s
      informaci&oacute;n acerca de los permisos de ficheros y c&oacute;mo 
      establecerlos, consulte &man.chmod.1;.
      </para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Escrito por </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Permisos simb&oacute;licos</title>
      <indexterm><primary>permisos</primary><secondary>symbolic</secondary></indexterm>

      <para>Los permisos simb&oacute;licos, tambi&eacute;n conocidos como 
        expresiones simb&oacute;licas, utilizan caracteres en lugar de valores
        octales para asignar permisos a ficheros o directorios.  Las expresiones
        simb&oacute;licas utilizan la sintaxis de (qui&eacute;n) (acci&oacute;n)
        (permisos) mediante los siguientes valores:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Opci&oacute;n</entry>
	      <entry>Letra</entry>
	      <entry>Representa</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>u</entry>
	    <entry>Usuario</entry>
	  </row>

	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>g</entry>
	    <entry>Grupo propietario</entry>
	  </row>

	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>o</entry>
	    <entry>Otro</entry>
	  </row>

	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>a</entry>
	    <entry>Todos (<quote>todo el mundo</quote>)</entry>
	  </row>

	  <row>
	    <entry>(acci&oacute;n)</entry>
	    <entry>+</entry>
	    <entry>A&ntilde;adir permisos</entry>
	  </row>

	  <row>
	    <entry>(acci&oacute;n)</entry>
	    <entry>-</entry>
	    <entry>Quitar permisos</entry>
	  </row>

	  <row>
	    <entry>(acci&oacute;n)</entry>
	    <entry>=</entry>
	    <entry>Activar permisos explicitamente</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>r</entry>
	    <entry>Lectura</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>w</entry>
	    <entry>Escritura</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>x</entry>
	    <entry>Ejecuci&oacute;n</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>t</entry>
	    <entry>Bit Sticky (<quote>pegajoso</quote>)</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>s</entry>
	    <entry>Activar UID o GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Estos valores se aplican con &man.chmod.1;
      de la misma manera que los anteriores, pero con letras.  Por 
      ejemplo, podr&iacute;a usar la siguiente orden para 
      bloquear a otros usuarios el acceso a <replaceable>FICHERO</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= FICHERO</userinput></screen>

    <para>Puede usarse una lista separada por comas cuando 
      se quiera aplicar m&aacute;s de un conjunto de cambios a un fichero.  
      Por ejemplo la siguiente orden eliminar&aacute; los permisos de 
      escritura de grupo y <quote>mundo</quote> a 
      <replaceable>FICHERO</replaceable>, y a&ntilde;ade permisos de 
      ejecuci&oacute;n para todos:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Escrito por </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Banderas de fichero en &os;</title>

      <para>Adem&aacute;s de los permisos de fichero previamente 
        expuestos, &os; permite el uso de <quote>banderas de
        fichero</quote>. Estas banderas a&ntilde;aden un nivel de seguridad
        y control adicional sobre ficheros, pero no sobre directorios.</para>

      <para>Estas banderas de fichero a&ntilde;aden un nivel adicional 
        de control sobre ficheros, ayudando a asegurar que en algunos
        casos ni siquiera <username>root</username> pueda eliminar
        o alterar ficheros.</para>

      <para>Las banderas de fichero se modifican mediante 
        &man.chflags.1;, gracias a una interfaz muy sencilla. Por ejemplo,
        para habilitar la bandera imborrable de sistema en 
        <filename>fichero1</filename>, escriba lo siguiente:</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>fichero1</filename></userinput></screen>

      <para>Y para dehabilitar la bandera imborrable de sistema, 
        simplemente escriba la orden previa con <quote>no</quote>
        antes de <option>sunlink</option>. Observe:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>fichero1</filename></userinput></screen>

      <para>Para ver las banderas de este fichero, utilice
        &man.ls.1; con las opciones <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>fichero1</filename>
	</userinput></screen>

      <para>La salida deber&iacute;a ser como esta:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 fichero1</programlisting>

      <para>Varias banderas solo pueden ser a&ntilde;adidas o retiradas 
        de ficheros por el usuario <username>root</username>. En
        otros casos, el propietario del fichero puede activar estas
        banderas. Se recomienda que para m&aacute;s informaci&oacute;n 
        la persona encargada de la administraci&oacute;n del sistema 
        consulte las  p&aacute;ginas de manual &man.chflags.1; y 
        &man.chflags.2;.
        </para>
    </sect2>
  </sect1>
  
  <sect1 id="dirstructure">
    <title>Estructura de directorios</title>
    <indexterm><primary>jerarqu&iacute;a de directorios</primary></indexterm>

    <para>La jerarqu&iacute;a del sistema de ficheros de &os; es
      fundamental para obtener una compresi&oacute;n completa del
      sistema.  El concepto m&aacute;s importante a entender es el
      del directorio ra&iacute;z, <quote>/</quote>.  Este directorio
      es el primero en ser montado en el arranque y contiene
      el sistema b&aacute;sico necesario para preparar el sistema
      operativo para su funcionamiento en modo multiusuario.  
      El directorio ra&iacute;z tambi&eacute;n contiene puntos de montaje
      para cualquier otro sistema de ficheros que se pretenda montar.</para>

    <para>Un punto de montaje es un directorio donde se pueden insertar 
      sistemas de ficheros al sistema de archivos ra&iacute;z.  
      Esto se explica con detalle en la <xref linkend="disk-organization">.  
      Los puntos de montaje est&aacute;ndar incluyen 
      <filename>/usr</filename>, <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> y <filename>/cdrom</filename>.  Estos
      directorios suelen corresponderse con entradas en 
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename>
      es una tabla que sirve de referencia al sistema y contiene
      los diferentes sistemas de ficheros y sus respectivos
      puntos de montaje.  La mayor&iacute;a de los sistemas de ficheros
      en <filename>/etc/fstab</filename> se montan autom&aacute;ticamente 
      en el arranque gracias al <quote>script</quote> &man.rc.8;, 
      a menos que contengan la opci&oacute;n <option>noauto</option>.
      Si quiere m&aacute;s informaci&oacute;n consulte la <xref linkend="disks-fstab">.</para>

    <para>Veremos ahora una descripci&oacute;n de los directorios 
      m&aacute;s comunes.  Si desea informaci&oacute;n m&aacute;s 
      completa consulte &man.hier.7;.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Directorio</entry>
	      <entry>Descripci&oacute;n</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Directorio ra&iacute;z del sistema de ficheros.</entry>
            </row>
	    
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
              <entry>Utilidades de usuario fundamentales tanto para el
                ambiente monousuario como para el multiusuario.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
              <entry>Programas y ficheros de configuraci&oacute;n utilizados
                durante el arranque del sistema operativo.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
              <entry>Ficheros de configuraci&oacute;n por defecto del 
                arranque; ver &man.loader.conf.5;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Nodos de dispositivo; ver &man.intro.4;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Ficheros de configuraci&oacute;n y 
               <quote>scripts</quote> del sistema.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Ficheros de configuraci&oacute;n por defecto del sistema; 
                ver &man.rc.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
              <entry>Ficheros de configuraci&oacute;n para agentes de
                transporte de correo como &man.sendmail.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
              <entry>Ficheros de configuraci&oacute;n de <command>named</command>;
                ver &man.named.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
              <entry><quote>Scripts</quote> que se ejecutan diariamente, 
                semanalmente y mensualmente mediante &man.cron.8;;
                ver &man.periodic.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
              <entry>Ficheros de configuraci&oacute;n de <command>ppp</command>;
                ver &man.ppp.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
              <entry>Directorio vac&iacute;o utilizado de forma habitual por 
                administradores de sistemas como punto de montaje 
                temporal.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
              <entry>Sistema de ficheros de procesos; ver &man.procfs.5;,
	      &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
              <entry>Programas enlazados est&aacute;ticamente para 
                restauraciones de emergencia; ver &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
              <entry>Directorio local para la cuenta <username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
              <entry>Programas del sistema y utilidades fundamentales de
                administraci&oacute;n para ambientes monousuario y
                multiusuario.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
              <entry>Programas utilizados en un ambiente autocontenido (standalone).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
              <entry>Ficheros temporales. El contenido de
                <filename class="directory">/tmp</filename> 
                <emphasis>NO</emphasis> suelen conservarse despu&eacute;s 
                de un reinicio del sistema.  
                Los sistemas de ficheros basados en memoria suelen montarse 
                en <filename class="directory">/tmp</filename>.
                Puede automatizarse mediante variables de 
                tmpmfs en &man.rc.conf.5; (o con una entrada en
                <filename>/etc/fstab</filename>; ver &man.mdmfs.8;,
                o para FreeBSD&nbsp;4.X, &man.mfs.8;).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
              <entry>La mayor&iacute;a de utilidades y aplicaciones de usuario.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
              <entry>Aplicaciones comunes, herramientas de programaci&oacute;n y
                otras aplicaciones.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
              <entry>Ficheros <quote>include</quote> est&aacute;ndar de C.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
              <entry>Bibliotecas.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Ficheros de datos con diversas funciones.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
              <entry>D&aelig;mons del sistema y utilidades del sistema 
                (ejecutados por otros programas).</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

              <entry>Ejecutables locales, bibliotecas, etc.
                tambi&eacute;n se usa como destino por defecto 
                de la infraestructura de ports de FreeBSD. Dentro de
                <filename>/usr/local</filename> debe seguirse el esquema
                general definido por &man.hier.7; para
                <filename>/usr</filename>. Las
                excepciones son el directorio man, el cual est&aacute;
                directamente bajo <filename>/usr/local</filename> en
                lugar de debajo de <filename>/usr/local/share</filename>, 
                y la documentaci&oacute;n de los ports est&aacute; en
                <filename>share/doc/<replaceable>port</replaceable></filename>.
 	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
              <entry>Arbol destino dependiente de arquitectura fruto de 
                la compilaci&oacute;n del &aacute;rbol
                <filename>/usr/src</filename>.</entry>	
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
              <entry>La colecci&oacute;n de Ports de FreeBSD (opcional).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
              <entry>D&aelig;mons del sistema y utilidades del sistema 
                (ejecutados por usuarios del sistema).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
              <entry>Ficheros independientes de arquitectura.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
              <entry>Ficheros fuente BSD y/o local.</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
              <entry>Ejecutables de la distribuci&oacute;n X11R6,
                bibliotecas, etc (opcional).</entry> 
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
              <entry>Ficheros multiprop&oacute;sito de log, temporales, en
                tr&aacute;nsito y de <quote>spool</quote>. 
                En ocasiones se monta en 
                <filename class="directory">/var</filename> un sistema de 
                ficheros basado en memoria.  
                Puede automatizarse el proceso mediante variables 
                de varmfs en &man.rc.conf.5; (o con una entrada en
                <filename>/etc/fstab</filename>; ver &man.mdmfs.8;,
                o para FreeBSD&nbsp;4.X, &man.mfs.8;).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
              <entry>Diversos ficheros de log del sistema.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
              <entry>Ficheros de buzones de correo de usuarios.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
              <entry>Directorios diversos del sistema de spool de impresora
                y correo</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
              <entry>Ficheros temporales.
                Estos ficheros suelen conservarse tras un reinicio del 
                sistema, a menos que
                <filename class="directory">/var</filename> sea un
                sistema de ficheros basado en memoria.</entry>
	    </row>
	    
	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Mapas NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Organizaci&oacute;n de disco</title>

      <para>La unidad m&aacute;s peque&ntilde;a que FreeBSD utiliza para
        ubicar ficheros es el nombre de fichero.  Los nombres de fichero
        son sensibles a las may&uacute;sculas, lo que significa que
        <filename>readme.txt</filename> y <filename>README.TXT</filename>
        son dos ficheros distintos. &os; no utiliza la extensi&oacute;n
        (<filename>.txt</filename>) de un fichero para determinar si el
        es un programa, o un documento o alguna otra forma de datos.</para>

      <para>Los ficheros se almacenan en directorios. Un directorio puede
        estar vac&iacute;o, o puede contener cientos de ficheros.  Un
        directorio tambi&eacute;n puede contener otros directorios,
        permiti&eacute;ndole contruir una jerarqu&iacute;a de directorios
        dentro de otro.  Esto hace mucho m&aacute;s f&aacute;cil la
        organizaci&oacute;n de sus datos.</para>

      <para>Para referirse a ficheros o directorios se usa el nombre 
        de archivo o de directorio, seguido por una barra,
        <literal>/</literal>, seguido por cualquier otro nombre de
        directorio que sea necesario. Si tiene un directorio
        <filename>tal</filename>, el cual contiene el directorio
        <filename>cual</filename>, el cual contiene el fichero
        <filename>readme.txt</filename>, entonces el nombre completo
        o <firstterm>ruta</firstterm> al fichero es
        <filename>tal/cual/readme.txt</filename>.</para>

      <para>Los directorios y ficheros se almacenan en un sistema de ficheros.  
        Cada sistema de ficheros contiene un s&oacute;lo directorio en el nivel
        m&aacute;s elevado, que es el 
        <firstterm>directorio ra&iacute;z</firstterm>
        de ese sistema de ficheros.  Este directorio ra&iacute;z puede
        contener otros directorios.</para>

      <para>Lo visto hasta ahora probablemente sea similar a cualquier otro 
        sistema operativo que pueda haber utilizado, pero hay unas cuantas 
        diferencias; por ejemplo, &ms-dos; utiliza <literal>\</literal> para 
        separar nombres de fichero y directorio, mientras que &macos; usa 
        <literal>:</literal>.</para>
        
      <para>&os; no utiliza letras de unidades, u otro nombre de unidad
        en la ruta. Por tanto, no podr&aacute; escribir 
        <filename>c:/tal/cual/readme.txt</filename>
        en &os;.</para>

      <para>En &os;, en cambio, un sistema de ficheros recibe el nombre de 
        <firstterm>sistema de ficheros ra&iacute;z</firstterm>.  El
        directorio ra&iacute;z del sistema de ficheros ra&iacute;z se 
        representa como <literal>/</literal>. Cualquier otro sistema
        de ficheros, por tanto, se <firstterm>monta</firstterm> bajo el
        sistema de ficheros ra&iacute;z.  No importa cu&aacute;ntos discos 
        tenga en su sistema &os;, cada directorio parecer&aacute; ser parte del
        mismo disco.</para>

      <para>Suponga que tiene tres sistemas de ficheros, denominados 
        <literal>A</literal>,
        <literal>B</literal> y <literal>C</literal>. Cada sistema de
        ficheros tiene un directorio ra&iacute;z, el cual contiene
        otros dos directorios, llamados
        <literal>A1</literal>, <literal>A2</literal> (y de la misma manera
        <literal>B1</literal>, <literal>B2</literal> y
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para>Usaremos <literal>A</literal> como sistema de ficheros 
        ra&iacute;z.  Si usara <command>ls</command> para ver el contenido de 
        este directorio ver&iacute;a dos subdirectorios, <literal>A1</literal>
        y <literal>A2</literal>.  El &aacute;rbol de directorios ser&iacute;a 
        como este:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Un sistema de ficheros debe montarse en un directorio
        de otro sistema de ficheros.  Ahora suponga que monta el
        sistema de ficheros <literal>B</literal> en el directorio
        <literal>A1</literal>.  El directorio ra&iacute;z de
        <literal>B</literal> reemplaza a <literal>A1</literal>,
        y los directorios en <literal>B</literal> aparecen de
        esta manera:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 | 
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Cualquier fichero que est&eacute; en el directorio
        <literal>B1</literal> o <literal>B2</literal> puede 
        encontrarse con la ruta <filename>/A1/B1</filename> o
        <filename>/A1/B2</filename> seg&uacute;n sea necesario.  
        Cualquier fichero que est&eacute; en <filename>/A1</filename>
        ha desaparecido temporalmente.  Aparecer&aacute;n de nuevo
        si <literal>B</literal> se <firstterm>desmonta</firstterm>
        de A.</para>

      <para>Si <literal>B</literal> se monta en <literal>A2</literal>
        entonces el diagrama se ver&iacute;a as&iacute;:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>y las rutas ser&iacute;an <filename>/A2/B1</filename> y
        <filename>/A2/B2</filename> respectivamente.</para>

      <para>Pueden montarse sistemas de ficheros uno sobre otro.  Continuando
        el ejemplo anterior, el sistema de ficheros <literal>C</literal>
        podr&iacute;a montarse en el directorio <literal>B1</literal>
        en el sistema de ficheros <literal>B</literal>, lo que nos 
        llevar&iacute;a a esto:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>O <literal>C</literal> podr&iacute;a montarse directamente
        en el sistema de ficheros <literal>A</literal>, bajo el directorio
        <literal>A1</literal>:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Si est&aacute; familiarizado con &ms-dos; esto es similar, 
        aunque no id&eacute;ntico, a utilizar <command>join</command>.</para>

      <para>Esto no es algo de lo que necesite preocuparse de forma habitual.  
        Normalmente crear&aacute; sistemas de ficheros al instalar &os; 
        y decidir&aacute; d&oacute;nde montarlos; lo m&aacute;s habitual es que 
        no los cambie de sitio a menos que agregue un disco nuevo.
        </para>

      <para>Es perfectamente posible tener un sistema de ficheros ra&iacute;z
        extenso y no necesitar crear otros.  Este esquema tiene unos cuantos 
        inconvenientes y una ventaja: 
        </para>

      <itemizedlist>
	<title>Ventajas de disponer de m&uacute;ltiples sistemas de 
         ficheros</title>
      
	<listitem>
          <para>Si dispone de varios sistemas de ficheros puede optar por 
            usar distintas <firstterm>opciones de montaje</firstterm>.  
            Por ejemplo, gracias a una planificaci&oacute;n cuidadosa, el 
            sistema de ficheros ra&iacute;z puede montarse como 
            s&oacute;lo-lectura, haciendo imposible borrar sin querer o 
            editar un fichero cr&iacute;tico.  Al mantener separados 
            sistemas de ficheros en los que los usuarios pueden escribir, 
            como <filename>/home</filename>, de otros sistemas de ficheros 
            tambi&eacute;n le permite montar con la opci&oacute;n 
            <firstterm>nosuid</firstterm>; dicha opci&oacute;n previene
            que los bits <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
            en los ejecutables almacenados en el sistema de ficheros
            tengan efecto, mejorando en cierto modo la seguridad.</para>
	</listitem>

	<listitem>
          <para>FreeBSD optimiza autom&aacute;ticamente el esquema de ficheros 
            en un sistema de ficheros, dependiendo de c&oacute;mo el sistema
            de ficheros est&eacute; siendo utilizado.  
            Un sistema de archivos que contiene muchos ficheros peque&ntilde;os
            en los que se escribe frecuentemente tendr&aacute; una 
            optimizaci&oacute;n de uno que contenga menos ficheros y m&aacute;s 
            grandes.  Si s&oacute;lo tiene un gran sistema de ficheros esta 
            optimizaci&oacute;n no tiene opci&oacute;n de actuar.</para>
	</listitem>
	
	<listitem>
          <para>Los sistemas de ficheros de &os; son muy robustos en caso 
            de sufrir un fallo de electricidad.  De todas maneras, un fallo 
            el&eacute;ctrico en un momento cr&iacute;tico puede
            da&ntilde;ar la estructura del sistema de ficheros.  Si reparte 
            sus datos en m&uacute;ltiples sistemas de ficheros har&aacute; 
            que sea m&aacute;s probable que el sistema arranque despu&eacute;s 
            de uno de esos fallos, haci&eacute;ndole adem&aacute;s 
            m&aacute;s f&aacute;cil la tarea de restaurarlo desde
            un respaldo si fuera necesario.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Ventajas de un s&oacute;lo sistema de ficheros</title>

	<listitem>
          <para>Los sistemas de ficheros son de un tama&ntilde;o fijo. Si crea
            un sistema de ficheros cuando instala &os; y le da un tama&ntilde;o
            espec&iacute;fico, tal vez descubra m&aacute;s tarde que necesita 
            hacer la partici&oacute;n m&aacute;s grande.  Esto no es 
            f&aacute;cil de realizar sin hacer una copia de seguridad, crear 
            de nuevo el sistema de ficheros con el nuevo 
            tama&ntilde;o y entonces restaurar los datos respaldados.</para>

	  <important>
            <para>FreeBSD&nbsp;4.4 y sus versiones posteriores disponen de 
              &man.growfs.8;, que hace posible incrementar
              el tama&ntilde;o del sistema de ficheros 
              <quote>al vuelo</quote>, eliminando
              esta limitaci&oacute;n.</para>
	  </important>
	</listitem>
      </itemizedlist>
    
      <para>Los sistemas de ficheros est&aacute;n alojados en particiones.  
        Este es un detalle muy importante, puesto que el 
        t&eacute;rmino <emphasis>partici&oacute;n</emphasis> no significa 
        aqu&iacute; lo mismo que en otros entornos  
        (por ejemplo, partici&oacute;n &ms-dos;),
        debido a la herencia &unix; de &os;. Cada partici&oacute;n se 
        identifica con una letra desde <literal>a</literal> hasta
        <literal>h</literal>.  Cada partici&oacute;n puede contener solamente
        un sistema de ficheros, lo que significa que los sistemas de
        ficheros suelen definirse mediante su punto de montaje en la
        jerarqu&iacute;a del sistema de ficheros o por la letra de la
        partici&oacute;n en la que est&aacute;n alojados.</para>

      <para>&os; tambi&eacute;n utiliza espacio de disco
        como <firstterm>espacio de intercambio (swap)</firstterm>.
        El espacio de intercambio le brinda a &os;
        <firstterm>memoria virtual</firstterm>.  Esto le permite a
        su sistema comportarse como si tuviera m&aacute;s
        memoria de la que realmente tiene.  Cuando a &os; se le
        agota la memoria mueve algunos de los datos que no est&aacute;n
        siendo utilizandos en ese momento al espacio de intercambio,
        y los mueve de regreso (desplazando alguna otra cosa) cuando
        los necesita.</para>

      <para>Algunas particiones tienen ciertas representaciones
        asociadas con ellas.</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Partici&oacute;n</entry>

	      <entry>Representaci&oacute;n</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Normalmente contiene el sistema de ficheros ra&iacute;z</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Normalmente contiene el espacio de intercambio (swap)</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

              <entry>Normalmente el mismo tama&ntilde;o de la slice 
                (<quote>porci&oacute;n</quote> o <quote>rebanada</quote>) 
                que lo encierra.  Esto permite a las utilidades que
                necesitan trabajar en la slice entera (por ejemplo,
                un explorador de bloques da&ntilde;ados) trabajar en
                la partici&oacute;n <literal>c</literal>. Normalmente no
                debe usted crear un sistema de ficheros en esta 
                partici&oacute;n.</entry> 
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

              <entry>La partici&oacute;n <literal>d</literal> sol&iacute;a
                tener un significado especial asociado, aunque
                ahora ya no lo tiene.  En la actualidad algunas
                herramientas pueden comportarse de forma extra&ntilde;a si se
                les pide trabajar en la partici&oacute;n <literal>d</literal>,
                as&iacute; que <application>sysinstall</application> no
                crear&acute; normalmente una partici&oacute;n <literal>d</literal>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Cada partici&oacute;n-que-contiene-un-sistema-de-ficheros 
        se almacena en lo que &os; llama una <firstterm>slice</firstterm>.
        Porci&oacute;n es el t&eacute;rmino de &os; para lo que 
        com&uacute;nmente se conoce como partici&oacute;n, y de nuevo, 
        conoce como partici&oacute;n, y de nuevo, esto se debe a la 
        herencia  &unix; de &os;.  Las slices est&aacute;n numeradas,
        empezando con 1, hasta 4.</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>particiones</primary></indexterm>
	<indexterm><primary>peligrosamente dedicadas</primary></indexterm>

      <para>Los n&uacute;meros de slice siguen al
        nombre de dispositivo, a los que se antepone una
        <literal>s</literal>, comenzando desde 1. As&iacute;, 
        <quote>da0<emphasis>s1</emphasis></quote> es la
        primera slice en la primera unidad SCSI.  S&oacute;lo 
        puede haber cuatro slices f&iacute;sicas en un disco,
        pero puede haber slices l&oacute;gicas dentro de
        slices  f&iacute;sicas del tipo apropiado.  Estas
        slices extendidas se numeran a partir de 5,
        as&iacute; que <quote>ad0<emphasis>s5</emphasis></quote>
        es la primera slice extendida en el primer
        disco IDE. Estos dispositivos se usan en sistemas de ficheros 
        que se espera que ocupen una slice.</para>

      <para>Tanto las slices y las unidades f&iacute;sicas 
        <quote>peligrosamente dedicadas</quote>, como otras unidades 
        contienen <firstterm>particiones</firstterm>, que se designan 
        mediante letras desde <literal>a</literal>
        hasta <literal>h</literal>.  Esta letra se a&ntilde;ade al nombre
        del dispositivo, as&iacute; que 
        <quote>da0<emphasis>a</emphasis></quote> es la partici&oacute;n
        a en la primera unidad da, la cual est&aacute;
        <quote>peligrosamente dedicada</quote>.  
        <quote>ad1s3<emphasis>e</emphasis></quote> es la quinta
        partici&oacute;n en la tercera slice de la segunda
        unidad de disco IDE.</para>
        
      <para>Finalmente, cada disco en el sistema tiene tambi&eacute;n su 
        designaci&oacute;n.  
        El nombre de disco comienza por un c&oacute;digo que indica
        el tipo de disco, luego un n&uacute;mero, indicando qu&eacute; disco
        es.  A diferencia de las slices, la numeraci&oacute;n de
        discos comienza desde 0.  Los c&oacute;digos comunes que usted
        ver&aacute; se muestran en la 
	<xref linkend="basics-dev-codes">.</para>

      <para>Cuando se hace referencia a una partici&oacute;n, &os; requiere que
        que tambi&eacute;n se nombre la slice y el disco que
        contiene la partici&oacute;n, y al referirse a una slice 
        tambi&eacute;n debe referirse al nombre del disco.  Esto se hace 
        listando el nombre de disco, <literal>s</literal> (slice), el 
        n&uacute;mero de slice y por &uacute;ltimo la letra de la 
        de slice y por &uacute;ltimo la letra de la partici&oacute;n.
        partici&oacute;n.  Puede consultar varios ejemplos en la 
	<xref linkend="basics-disk-slice-part">.</para>

      <para>La <xref linkend="basics-concept-disk-model"> muestra un modelo
        conceptual del esquema de un disco que deber&iacute;a ayudarle a 
        aclarar las cosas.
        </para>

      <para>Para poder instalar &os; debe primero configurar las
        particiones del disco, luego crear particiones dentro de la
        slice que utilizar&aacute; para &os; y luego crear
        un sistema de ficheros (o espacio de intercambio, swap) en
        cada partici&oacute;n, y decidir d&oacute;nde se van a montar esos
        sistemas de ficheros.</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>C&oacute;digos de dispositivos de disco</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>C&oacute;digo</entry>
	    
	      <entry>Significado</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>Disco ATAPI (IDE)</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>
	      
	      <entry>Disco de acceso directo SCSI</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>acd</devicename></entry>
	      
	      <entry>CDROM ATAPI (IDE)</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>cd</devicename></entry>
	      
	      <entry>CDROM SCSI</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>fd</devicename></entry>
	      
	      <entry>Disquete (floppy)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      
      <example id="basics-disk-slice-part">
	<title>Ejemplo de nombres de disco, slices y partici&oacute;n</title>
	
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Nombre</entry>
		
		<entry>Significado</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
                <entry>La primera partici&oacute;n (<literal>a</literal>) en
                  la primera slice (<literal>s1</literal>) en el
                  primer disco IDE (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		
                <entry>La quinta partici&oacute;n (<literal>e</literal>) en
                  la segunda slice (<literal>s2</literal>) en el
                  segundo disco SCSI (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>Modelo conceptual de un disco</title>

        <para>Este diagrama muestra c&oacute;mo ve &os; el primer disco IDE
          en el sistema.  Se asume que el disco es de 4&nbsp;GB, 
          y contiene dos particiones de 2&nbsp;GB (particiones &ms-dos;).  La
          primera partici&oacute;n contiene un disco &ms-dos;, 
          <devicename>C:</devicename>,
          y la segunda partici&oacute;n contiene una instalaci&oacute;n &os;.  
          Esta instalaci&oacute;n de ejemplo tiene tres particiones, y una
          partici&oacute;n swap.</para>

        <para>Cada una de las tres particiones tiene un sistema de ficheros.  
          La partici&oacute;n <literal>a</literal> se utilizar&aacute; 
          para el sistema de ficheros ra&iacute;z, <literal>e</literal>
          para la jerarqu&iacute;a del directorio <filename>/var</filename>, 
          y <literal>f</literal> para la jerarqu&iacute;a del directorio
          <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>
 
          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     >  Primera porci&oacute;n, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partici&oacute;n a, montada como /      |
|                 |     > referida como ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partici&oacute;n b, usada como swap      |
|                 |     > referida como ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partici&oacute;n c, sin
|                 |    |  Partici&oacute;n e, usada como /var       > sistema de archivos, la 
|                 |     > referida como ad0s2e          |  porci&oacute;n completa de FreeBSD,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partici&oacute;n f, usada como /usr      |
:                 :     > referida como ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>Montaje y desmontaje de sistemas de ficheros</title>

    <para>El sistema de archivos se visualiza mejor como 
      un &aacute;rbol, enraizado, como
      lo est&aacute;, en <filename>/</filename>.  
      <filename>/dev</filename>, <filename>/usr</filename> y los
      dem&aacute;s directorios en el directorio ra&iacute;z son ramas, las
      cuales pueden tener sus propias ramas, como
      <filename>/usr/local</filename>, y as&iacute; sucesivamente.</para>

    <indexterm><primary>sistema de ficheros ra&iacute;z</primary></indexterm>
    <para>Existen varias razones para albergar algunos de
      estos directorios en sistemas de ficheros separados.  
      <filename>/var</filename> contiene los directorios 
      <filename>log/</filename>, <filename>spool/</filename> y
      varios tipos de ficheros temporales y como tal, puede
      llenarse.  Agotar el espacio del sistema de ficheros ra&iacute;z
      no es una buena idea, as&iacute; que separar <filename>/var</filename>
      de <filename>/</filename> suele ser muy recomendable.</para>

    <para>Otra raz&oacute;n com&uacute;n para meter ciertos &aacute;rboles
      de directorios en otros sistemas de ficheros es si van a estar
      albergados en discos f&iacute;sicos separados, o si son discos
      virtuales separados, como un montaje de 
      <link linkend="network-nfs">sistema de ficheros de red</link>,
      o unidades de CDROM.</para>

    <sect2 id="disks-fstab">
      <title>El fichero <filename>fstab</filename></title>
      <indexterm>
	<primary>sistemas de ficheros</primary>
	<secondary>montaje con fstab</secondary>
      </indexterm>

      <para>Durante el <link linkend="boot">proceso de arranque</link>,
        los sistemas de ficheros listados en <filename>/etc/fstab</filename>
        se montan autom&aacute;ticamente (a menos que est&eacute;n
        listados con la opci&oacute;n <option>noauto</option>).</para>

      <para><filename>/etc/fstab</filename> contiene una
        lista de l&iacute;neas con el siguiente formato:</para>

      <programlisting><replaceable>dispositivo</replaceable>       <replaceable>/punto-de-montaje</replaceable> <replaceable>fstype</replaceable>     <replaceable>opciones</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>dispositivo</literal></term>
	  <listitem>
            <para>Un nombre de dispositivo (<emphasis>debe existir</emphasis>).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>punto-de-montaje</literal></term>
            
	  <listitem><para>Un directorio (el cual debe existir), en
              donde montar el sistema de ficheros.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>fstype</literal></term>
            
          <listitem><para>El tipo de sistema de ficheros para
                pasarle a &man.mount.8;.  El tipo de sistema de
                ficheros por omisi&oacute;n de &os; es
                <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>opciones</literal></term>
            
          <listitem><para>Ya sea <option>rw</option> para sistemas
              de ficheros de lectura-escritura, o <option>ro</option>
              para sistemas de ficheros de solo-lectura, seguido
              de cualquier otra opci&oacute;n que sea necesaria.  
              Una opci&oacute;n com&uacute;n es <option>noauto</option>
              para sistemas de ficheros que no se montan normalmente 
              durante la secuencia de arranque.  Hay otras 
              opciones en la p&aacute;gina de manual
              &man.mount.8;.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>dumpfreq</literal></term>
          
         <listitem><para>&man.dump.8; la usa para determinar qu&eacute; 
             sistema de ficheros requiere volcado.  Si
             el campo no est&aacute; declarado se asume un valor
             de cero.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Determina el orden en el cual los sistemas de
             ficheros deben revisarse.  Los sistemas de ficheros 
             que deben saltarse deben tener su <literal>passno</literal>
             a cero.  El sistema de ficheros ra&iacute;z (que, obviamente, 
             necesita ser revisado antes que cualquier otro) debe tener
             su <literal>passno</literal> puesto a uno, y otros 
             sistemas de ficheros deben tener valores mayores que uno. 
             Si m&aacute;s de un sistema de ficheros tiene el mismo
             <literal>passno</literal> entonces &man.fsck.8; tratar&aacute;
             de revisarlos en paralelo de ser posible.
             </para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>Consulte la p&aacute;gina de manual de &man.fstab.5; para
        mayor informaci&oacute;n sobre el formato del fichero 
        <filename>/etc/fstab</filename> y las opciones que contiene.</para>
    </sect2>

    <sect2 id="disks-mount">
      <title>La orden <command>mount</command></title>
      <indexterm>
	<primary>sistemas de ficheros</primary>
	<secondary>montaje</secondary>
      </indexterm>
        
      <para>&man.mount.8; es lo que se utiliza en &uacute;ltima
        instancia para montar sistemas de ficheros.</para>
        
      <para>En su forma m&aacute;s b&aacute;sica, se usa lo siguiente:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>dispositivo</replaceable> <replaceable>punto-de-montaje</replaceable></userinput></screen>
      </informalexample>

      <para>Existe una gran cantidad de opciones, tal y como consta en 
        &man.mount.8;, pero las m&aacute;s comunes son:</para>

      <variablelist>
	<title>Opciones de montaje</title>

	<varlistentry>
	  <term><option>-a</option></term>
            
	  <listitem>
            <para>Montar todos los sistemas de ficheros
              listados en <filename>/etc/fstab</filename>.  
              Excepto aquellos marcados como <quote>noauto</quote>,
              excluidos por la bandera <option>-t</option>, o
              aquellos que ya est&aacute;n montados.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-d</option></term>
            
	  <listitem>
            <para>Realizar todo excepto la llamada real de montaje del
              sistema.  Esta opci&oacute;n es &uacute;til junto
              con la bandera <option>-v</option> para determinar
              lo que &man.mount.8; est&aacute; tratando de
              hacer en realidad.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
            <para>Forzar el montaje de un sistema de ficheros 
              sucio (es decir, <emphasis>peligroso</emphasis>), o forzar 
              la revocaci&oacute;n de accesos de escritura cuando se cambia 
              el est&aacute;tus de un sistema de archivos de lectura-escritura
              a s&oacute;-lectura.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><option>-r</option></term>
            
	  <listitem>
            <para>Montar el sistema de ficheros como s&oacute;lo-lectura.  
              Esto es id&eacute;ntico a utilizar el argumento 
              <option>ro</option>
              (<option>rdonly</option> para versiones m&aacute;s
              antiguas que &os; 5.2) en la opci&oacute;n <option>-o</option>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>Montar el sistema de ficheros dado con el tipo de
              sistema de ficheros, o montar solamente sistemas
              de ficheros del tipo dado, si se proporciona la
              opci&oacute;n <option>-a</option>.</para>
              
            <para><quote>ufs</quote> es el sistema de ficheros 
              ra&iacute;z por omisi&oacute;n.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-u</option></term>
            
	  <listitem>
            <para>Actualizar puntos de montaje en el sistema
              de ficheros.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-v</option></term>
            
	  <listitem>
	    <para>Mostrar mayor informaci&oacute;n.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-w</option></term>
            
	  <listitem>
	    <para>Montar el sistema de ficheros como lectura-escritura.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
        
      <para>La opci&oacute;n <option>-o</option> toma una lista de opciones
        separada por comas, incluyendo las siguientes:</para>
        
      <variablelist>
	<varlistentry>
	  <term>nodev</term>
            
	  <listitem>
            <para>No interpretar dispositivos especiales en el sistema 
              ficheros.  Es una opci&oacute;n
              de seguridad que puede ser muy &uacute;til.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>noexec</term>
            
	  <listitem>
              <para>No permitir la ejecuci&oacute;n de binarios
                en este sistema de ficheros.  Esta tambi&eacute;n
                es una opci&oacute;n de seguridad &uacute;til.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>nosuid</term>
            
	  <listitem>
            <para>No interpretar banderas setuid o setgid en el
              sistema de ficheros.  Esta tambi&eacute;n es una
              opci&oacute;n de seguridad &uacute;til.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>La orden <command>umount</command></title>
      <indexterm>
	<primary>sistemas de ficheros</primary>
	<secondary>desmontar</secondary>
      </indexterm>
        
      <para>&man.umount.8; toma, como par&aacute;metro, un
        punto de montaje, un nombre de dispositivo, o la opci&oacute;n
        <option>-a</option> o <option>-A</option>.</para>
        
      <para>Todas las formas toman <option>-f</option> para forzar
        el desmontaje, y <option>-v</option> para mostrar m&aacute;s
        informaci&oacute;n.  Tenga muy en cuenta que usar <option>-f</option>
        no suele ser una forma recomendable de proceder.  Desmontar a la 
        fuerza los sistemas de ficheros puede acarrear el congelar la 
        m&aacute;quina o da&ntilde;ar los datos en el sistema de 
        ficheros.</para>
        
      <para><option>-a</option> y <option>-A</option> se usan para 
        desmontar todos los sistemas de ficheros montados,
        con la ventaja de poder elegir el tipo de sistema de ficheros 
        que se use tras <option>-t</option>.  De todas maneras
        <option>-A</option> no trata de desmontar el sistema de
        ficheros ra&iacute;z.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Procesos</title>

    <para>&os; es un sistema operativo multitarea.  Esto significa que
      parece como si m&aacute;s de un programa se estuviera ejecutando al
      mismo tiempo.  Cada programa que se ejecuta en cualquier momento dado 
      se denomina <firstterm>proceso</firstterm>.  Cada orden que 
      ejecuta iniciar&aacute; al menos un proceso nuevo, y hay 
      muchos procesos que se est&aacute;n ejecutando en todo momento, 
      manteniendo el sistema en funcionamiento.</para>

    <para>Cada proceso tiene un identificador individual consistente en 
      un n&uacute;mero llamado <firstterm>ID del proceso</firstterm>, 
      o <firstterm>PID</firstterm>,
      y, como fichero, cada proceso tambi&eacute;n tiene un propietario
      y un grupo.  La informaci&oacute;n de propietario y grupo se usa 
      para determinar qu&eacute; ficheros y dispositivos puede abrir el 
      proceso mediante los permisos de fichero explicados anteriormente.  
      La mayor&iacute;a de los procesos tambi&eacute;n tiene un proceso
      padre.  El proceso padre es el proceso que los inici&oacute;.  Por
      ejemplo, si est&aacute; tecleando &oacute;rdenes en la shell,  
      la shell es un proceso, y cualquier orden que usted ejecute 
      tambi&eacute;n lo ser&aacute;.  De este modo, cada proceso que ejecute 
      tendr&aacute; como proceso padre a su shell.   La excepci&oacute;n 
      es un proceso especial llamado &man.init.8;.  <command>init</command> es
      siempre el primer proceso, as&iacute; que su PID siempre es 1.  
      <command>init</command> es arrancado autom&aacute;ticamente por el 
      kernel cuando arranca &os;.</para>

    <para>Hay dos &oacute;rdenes particularmente &uacute;tiles para ver los 
      procesos en el sistema, &man.ps.1; y &man.top.1;.  
      <command>ps</command> se usa para mostrar una lista
      est&aacute;tica de los procesos que se ejecutan en el sistema en 
      ese momento, y puede mostrar sus PID, cu&aacute;nta memoria 
      est&aacute;n usando, la l&iacute;nea de &oacute;rdenes con la que fueron 
      iniciados, y mucho m&aacute;s.  
      <command>top</command> despliega todos
      los procesos que se est&aacute;n ejecutando, y actualiza la
      pantalla cada pocos segundos para que pueda ver lo que 
      est&aacute; haciendo su sistema.</para>

    <para>Por defecto <command>ps</command> solo le muestra las &oacute;rdenes 
      que se est&aacute;n ejecutando y que sean propiedad de su usuario.  
      Por ejemplo:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Como puede ver en este ejemplo, la salida de &man.ps.1; est&aacute;
      organizada en columnas.  <literal>PID</literal>
      es el ID de proceso anteriormente expuesto.  Los PIDs se asignan 
      partiendo de 1, hasta 99999, y dan la vuelta de regreso al
      principio cuando se terminan los n&uacute;meros.  La columna
      <literal>TT</literal> muestra el tty en el que el programa se est&aacute;
      ejecutando, y podemos ignorarlo tranquilamente por el momento.  
      <literal>STAT</literal> muestra el estado del programa, y 
      tambi&eacute;n podemos ignorarlo.  <literal>TIME</literal> es la
      cantidad de tiempo que el programa ha se ha estado ejecutando en la 
      CPU (generalmente no es el tiempo transcurrido desde que se 
      inici&oacute; el programa, ya que la mayor&iacute;a de los
      programas pasan mucho tiempo esperando antes
      de que necesiten gastar tiempo en la CPU.  Finalmente,
      <literal>COMMAND</literal> es la l&iacute;nea de &oacute;rdenes que 
      se emple&oacute; para ejecutar el programa.</para>

    <para>&man.ps.1; admite muchas opciones diferentes acerca de la 
      informaci&oacute;n que se desea ver.  Uno de los conjuntos
      m&aacute;s &uacute;tiles es <literal>auxww</literal>.  <option>a</option>
      despliega informaci&oacute;n acerca de todos los procesos
      ejecut&aacute;ndose, no solamente los suyos.  <option>u</option>
      despliega el nombre de usuario del propietario del proceso, as&iacute;
      como el uso de memoria.  <option>x</option> despliega informaci&oacute;n
      acerca de los procesos d&aelig;mon y <option>ww</option> hace que
      &man.ps.1; despliegue la l&iacute;nea de &oacute;rdenes completa, en lugar
      de truncarla cuando es demasiado larga para caber en la pantalla.</para>

    <para>La salida de &man.top.1; es similar.  Veamos un ejemplo:
      </para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>La salida est&aacute; dividida en dos secciones. La cabecera (las
      primeras cinco l&iacute;neas) muestra el PID del &uacute;ltimo proceso
      en ejecutarse, la carga promedio del sistema (una medida de la carga 
      del sistema), el <quote>uptime</quote> del sistema (tiempo
      desde el &uacute;ltimo reinicio) y la hora actual.  Las otras cifras
      en la cabecera se relacionan con cu&aacute;ntos procesos hay en 
      ejecuci&oacute;n en el sistema (47 en este caso), cu&aacute;nta 
      memoria y espacio de intercambio (swap) est&aacute; en uso, y 
      cu&aacute;nto tiempo est&aacute; el sistema en diferentes estados de 
      CPU.</para>

    <para>M&aacute;s abajo hay una serie de columnas con informaci&oacute;n
      similar a la salida de &man.ps.1;. Igual que antes, puede usted 
      ver el PID, el nombre de usuario, la cantidad de tiempo de CPU
      en uso y la orden que se ejecut&oacute;.  &man.top.1;
      tambi&eacute;n mostrar&aacute; por defecto la cantidad de espacio
      de memoria que emplea cada proceso.  Esto est&aacute; dividido en dos
      columnas, una para el tama&ntilde;o total y otra para el tama&ntilde;o
      residente (el tama&ntilde;o total es cu&aacute;nta memoria 
      ha necesitado la aplicaci&oacute;n y el tama&ntilde;o residente 
      es cu&aacute;nta se est&aacute; usando en ese momento concreto).  
      En este ejemplo puede verse que <application>&netscape;</application> 
      requerido casi 30&nbsp;MB de RAM, pero actualmente solo est&aacute; usando
      9&nbsp;MB.</para>

    <para>&man.top.1; actualiza autom&aacute;ticamente el listado cada
      dos segundos, pero este lapso puede cambiarse mediante la 
      opci&oacute;n <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>D&aelig;mons, se&ntilde;ales y c&oacute;mo matar procesos</title>

    <para>cuando ejecuta un editor es f&aacute;cil controlarlo, 
      decirle que cargue ficheros y dem&aacute;s.  Puede hacerse 
      porque el editor permite ese control, y porque el editor 
      depende de una <firstterm>terminal</firstterm>.  Algunos
      programas no est&aacute;n dise&ntilde;ados para ser ejecutados con
      entradas continuas por parte del usuario, as&iacute; que se desconectan
      de la terminal a la primera oportunidad.  Por ejemplo, un servidor
      web pasa todo el d&iacute;a respondiendo peticiones web, y normalmente
      no necesita ninguna entrada de su parte.  Los programas que transportan
      correo electr&oacute;nico de un sitio a otro son otro ejemplo de
      esta clase de aplicaci&oacute;n.</para>

    <para>Llamamos a estos programas <firstterm>d&aelig;mons</firstterm>.  
      Los D&aelig;mons eran personajes de la mitolog&iacute;a griega; 
      no eran ni buenos ni malos, eran peque&ntilde;os esp&iacute;ritus 
      sirvientes que, en gran medida, hac&iacute;an cosas &uacute;tiles por 
      la humanidad. Algo muy parecido a c&oacute;mo los servidores web y 
      los servidores de correo hacen hoy d&iacute;a tantas cosas 
      &uacute;tiles para nosotros.  Por eso, desde hace mucho tiempo, la 
      mascota de BSD es ese d&aelig;mon de aspecto tan ufano con su tridente 
      y su c&oacute;modo calzado deportivo.</para>

    <para>Hay una norma seg&uacute;n la cual se da nombre a los programas que 
      suelen ejecutarse como d&aelig;mons con una <quote>d</quote> final.  
      <application>BIND</application> es el d&aelig;mon de nombres de 
      Berkeley (y el programa que en realidad se ejecuta se llama 
      <command>named</command>); el servidor web 
      <application>Apache</application> se llama 
      <command>httpd</command>, el d&aelig;mon de <quote>spool</quote> de 
      impresora de l&iacute;nea es <command>lpd</command> y as&iacute;  
      sucesivamente.  Se trata de un acuerdo,  no una ley f&eacute;rrea; por 
      ejemplo el d&aelig;mon principal de correo de 
      <application>Sendmail</application> se llama 
      <command>sendmail</command>, y no <command>maild</command>,
      como podr&iacute;a suponerse visto lo precedente.</para>

    <para>Algunas veces necesitar&aacute; comunicarse con un d&aelig;mon.  
      Estas comunicaciones se denominan <firstterm>se&ntilde;ales</firstterm>;
      es posible comunicarse con un d&aelig;mon (o con cualquier otro proceso
      ejecut&aacute;ndose) mand&aacute;ndole una se&ntilde;al.  Existen 
      diversos tipos de se&ntilde;ales diferentes que puede mandar (algunas
      de ellas tienen un significado especial, otras son interpretadas por
      la aplicaci&oacute;n, y la documentaci&oacute;n de la aplicaci&oacute;n
      le dir&aacute; como interpreta la se&ntilde;al esa aplicaci&oacute;n).  
      Solo puede enviar una se&ntilde;al a un proceso del que sea usted 
      propietario.  Si manda una se&ntilde;al a un proceso de otro usuario 
      con &man.kill.1; o &man.kill.2; ver&aacute; un mensaje del sistema en 
      el que se le comunica que no tiene permiso para hacer tal cosa.  
      La excepci&oacute;n a esto es el usuario <username>root</username>,
      que puede mandar se&ntilde;ales a los procesos de cualquier usuario del 
      sistema.</para>

    <para>FreeBSD tambi&eacute;n enviar&aacute; se&ntilde;ales de
      aplicaci&oacute;n en determinados casos.  Si una aplicaci&oacute;n
      est&aacute; mal escrita, y trata de acceder a  memoria a la que no 
      est&aacute; previsto que acceda, &os; manda al proceso la se&ntilde;al
      <firstterm>Violaci&oacute;n de segmento</firstterm>
      (<literal>SIGSEGV</literal>).  Si una aplicaci&oacute;n ha utilizado
      la llamada de sistema &man.alarm.3; para ser avisada despu&eacute;s 
      de que un periodo de tiempo haya transcurrido, se le
      mandar&aacute; la se&ntilde;al de alarma (<literal>SIGALRM</literal>),
      y as&iacute; sucesivamente.</para>

    <para>Hay dos se&ntilde;ales que pueden usarse para detener un proceso, 
      <literal>SIGTERM</literal> y <literal>SIGKILL</literal>.  
      <literal>SIGTERM</literal> es la manera amable de matar un proceso;
      el proceso puede <emphasis>recibir</emphasis> la se&ntilde;al,
      darse cuenta que usted quiere que se apague, cerrar cualquier
      fichero de log que pueda tener abierto y generalmente terminar
      cualquier tarea que est&eacute; realizando en ese momento antes
      de apagarse.  En algunos casos un proceso puede incluso ignorar
      <literal>SIGTERM</literal> si se encuentra inmerso en una
      tarea que no puede ser interrumpida.</para> 

    <para>Por el contrario, un proceso no puede ignorar una se&ntilde;al 
    <para><literal>SIGKILL</literal>.  
      Esta es la se&ntilde;al <quote>No me importa lo que est&aacute;s
      haciendo, detente ahora mismo</quote>.  Si manda un 
      <literal>SIGKILL</literal> a un proceso &os; detendr&aacute; ese 
      proceso inmediatamente.<footnote>
      <para>Esto no es del todo cierto (ciertas cosas no pueden
        ser interrumpidas.  Por ejemplo, si el proceso est&aacute; tratando
        de leer desde un fichero que est&aacute; en otro sistema de
        la red, y el otro sistema no est&aacute; disponible por
        alguna raz&oacute;n (por estar apagada, o que la red tenga un fallo),
        tenemos un caso de lo que llamamos 
        <quote>proceso ininterrumpible</quote>.  
        M&aacute;s tarde, al proceso se le acabar&aacute; el tiempo de
        espera, generalmente pasados dos minutos.  Tan pronto como esto
        ocurra el proceso ser&aacute; liquidado.</para>
      </footnote>.</para>

    <para>Otras se&ntilde;ales que puede usar: 
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> y
      <literal>SIGUSR2</literal>.  Son se&ntilde;ales de prop&oacute;sito
      general, y aplicaciones diferentes pueden hacer cosas diferentes
      cuando se utilicen.</para>

    <para>Suponga que ha cambiado el fichero de configuraci&oacute;n de su 
      servidor web; parece un buen momento para decirle al servidor
      web que lea y aplique la  configuraci&oacute;n.  Podr&iacute;a detener y
      reiniciar <command>httpd</command>, pero esto implicar&iacute;a 
      un per&iacute;odo breve de suspensi&oacute;n del servicio de su
      servidor web, lo cual puede no ser asumible.  La mayor&iacute;a de
      los d&aelig;mons fueron creados pensando que fueran capaces de 
      responder a la se&ntilde;al
      <literal>SIGHUP</literal> releyendo su fichero de configuraci&oacute;n.  
      En lugar de matar y reiniciar <command>httpd</command>
      le podr&iacute;a mandar la  se&ntilde;al <literal>SIGHUP</literal>.  
      Dado que no hay una manera est&aacute;ndar para responder a estas
      se&ntilde;ales, diferentes d&aelig;mons tendr&aacute;n diferente 
      comportamiento, as&iacute; que aseg&uacute;rese de leer la 
      documentaci&oacute;n del d&aelig;mon en cuesti&oacute;n.</para>
    
    <para>Las se&ntilde;ales se envian mediante &man.kill.1;,
      como puede verse en el siguiente ejemplo.</para>

    <procedure>
      <title>Env&iacute;o de una se&ntilde;al a un proceso</title>

      <para>Este ejemplo muestra como enviar una se&ntilde;al a
        &man.inetd.8;.  El fichero de configuraci&oacute;n de
        <command>inetd</command> es 
        <filename>/etc/inetd.conf</filename> e <command>inetd</command>
        releer&aacute; dicho fichero de configuraci&oacute;n cuando
        se le env&iacute;e un <literal>SIGHUP</literal>.</para>

      <step>
        <para>Identifique el ID de proceso del proceso al que quiere
          enviarle la se&ntilde;al mediante &man.ps.1; y 
          &man.grep.1;.  &man.grep.1; se usa para buscar cadenas de 
          texto de su elecci&oacute;n en la salida est&aacute;ndar.  
          Puede ejecutarse como un usuario normal, mientras que 
          &man.inetd.8; se ejecuta como <username>root</username>, 
          as&iacute; que debe pasarle los par&aacute;metros 
          <option>ax</option> a &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

        <para>Vemos que el PID de &man.inetd.8; es 198.  En algunos casos 
          <literal>grep inetd</literal> tambi&eacute;n 
          puede aparecer en esta salida.  Esto se debe a la manera en que 
          &man.ps.1; tiene que encontrar la lista de procesos 
          ejecut&aacute;ndose.</para>
      </step>

      <step>
        <para>Utilice &man.kill.1; para enviar la se&ntilde;al.  Debido a que
          &man.inetd.8; est&aacute; siendo ejecutado por 
          <username>root</username> tendr&aacute; que usar primero 
          &man.su.1; para volverse <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

        <para>Del mismo modo que la mayor&iacute;a de &oacute;rdenes &unix; 
          &man.kill.1; no imprimir&aacute; ninguna salida si ha funcionado 
          bien.  
          Si env&iacute;a una se&ntilde;al a un proceso del que no es
          el propietario entonces ver&aacute; <errorname>kill:
          <replaceable>PID</replaceable>: Operation not permitted</errorname>.
          Si usted no teclea bien el PID puede enviar la se&ntilde;al a un
          proceso distinto, lo cual puede ser malo, o, si tiene suerte,
          habr&aacute; enviado la se&ntilde;al a un proceso que no est&aacute;
          en uso, y ver&aacute; <errorname>kill:
          <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>Por qu&eacute; utilizar <command>/bin/kill</command>?</title>

          <para>Muchos shells incorporan su propio  <command>kill</command>;
            esto es, el shell mandar&aacute;
            la se&ntilde;al directamente, en lugar de ejecutar
            <filename>/bin/kill</filename>.  Esto puede ser muy &uacute;til,
            pero diferentes shells tienen diferentes sintaxis para
            especificar el nombre de la se&ntilde;al que env&iacute;a.  En
            lugar de tratar de aprederse todas ellas, es m&aacute;s
            f&aacute;cil usar 
            <command>/bin/kill <replaceable>...</replaceable></command>
            sea la que sea la shell que prefiera usar.</para>
	</note>
      </step>
    </procedure>

    <para>El env&iacute;o de otras se&ntilde;ales es muy similar,
      solamente sustituya <literal>TERM</literal> o <literal>KILL</literal>
      en la l&iacute;nea de &oacute;rdenes seg&uacute;n sea necesario.</para>
         
    <important>
      <para>Matar procesos aleatorios en el sistema es una mala
        idea.  En particular, &man.init.8;, ID de proceso 1, es muy
        especial. Ejecutar <command>/bin/kill -s KILL 1</command> es
        una manera r&aacute;pida de apagar su sistema. 
        <emphasis>Siempre</emphasis>
        revise dos veces los argumentos con los que ejecuta &man.kill.1;
        <emphasis>antes</emphasis> de pulsar <keycap>Enter</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>l&iacute;nea de &oacute;rdenes</primary></indexterm>

    <para>En &os; gran parte del trabajo diario se hace en una 
      interfaz de l&iacute;nea de &oacute;rdenes llamada shell.  El trabajo 
      principal de la shell es ir recibiendo &oacute;rdenes mediante un 
      canal de entrada y ejecutarlos.  
      Muchas shells tambi&eacute;n tienen funciones 
      integradas para ayudar con las tareas diarias como manipulaci&oacute;n 
      de ficheros, gesti&oacute;n de archivos con expresiones regulares,
      edici&oacute;n en la propia l&iacute;nea de &oacute;rdenes, macros de 
      &oacute;rdenes y variables de entorno.  
      &os; incluye diversas shells, como <command>sh</command>,
      el shell Bourne y <command>tcsh</command>, el shell C mejorado.  
      Hay muchas otras shells disponibles en la colecci&oacute;n de
      ports de FreeBSD, como <command>zsh</command> y
      <command>bash</command>.</para>

    <para>&iquest;Qu&eacute; shell usar? es realmente una cuesti&oacute;n
      de gustos.  Si va a programar en C puede preferir usar una shell 
      tipo C, como <command>tcsh</command>.  
      Si viene del mundo Linux o si es nuevo en la interfaz de l&iacute;nea
      de &oacute;rdenes de &unix; puede probar con <command>bash</command>.  
      Tenga en cuenta que cada shell posee unas propiedades &uacute;nicas que
      pueden o no funcionar con su entorno de trabajo preferido, y que
      puede usted elegir qu&eacute; shell usar.</para>

    <para>Una de las propiedades comunes de las shell es que completan los 
      nombres de fichero.  Una vez que ha introducido las primeras letras 
      de una orden o del nombre de un fichero, se puede hacer que la shell 
      complete autom&aacute;ticamente el resto de la orden o nombre de fichero 
      pulsando la tecla <keycap>Tab</keycap>.  
      Veamos un ejemplo.  Suponga que tiene dos ficheros 
      llamados <filename>talcual</filename> y <filename>tal.cual</filename>.  
      Usted quiere borrar <filename>tal.cual</filename>.  Lo que
      habr&iacute;a que teclear es:
      <command>rm ta[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>La shell mostrar&iacute;a en pantalla <command>rm
      fo[BIP].cual</command>.</para>

    <para>El [BIP] es la campana de la consola, es decir, la shell
      est&aacute; dici&eacute;ndome que no pudo completar totalmente el nombre
      de fichero porque hay m&aacute;s de una coincidencia.  
      Tanto <filename>talcual</filename> como <filename>tal.cual</filename>
      comienzan por <literal>ta</literal>, pero solo se pudo completar
      hasta <literal>tal</literal>.  Si se teclea <literal>.</literal>,
      y de nuevo <keycap>Tab</keycap>, entonces la shell es capaz de
      a&ntilde;adir el resto del nombre de fichero.</para>
    <indexterm><primary>variables de entorno</primary></indexterm>

    <para>Otra funci&oacute;n de  la shell son las variables de entorno.  
      Las variables de entorno son parejas de valores clave almacenados
      en el espacio de entorno del shell.  Este espacio puede ser le&iacute;do
      por cualquier programa invocado por la shell y, por lo tanto,
      contiene mucha configuraci&oacute;n de programas. Esta es una lista 
      de las variables de entorno m&aacute;s comunes y su
      significado:</para>
    <indexterm><primary>variables de entorno</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Descripci&oacute;n</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
            <entry>Nombre de usuario en el sistema.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
            <entry>Lista de directorios, separados por punto y coma, en los que
              se buscan ejecutables.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
            <entry>Nombre de red de la pantalla X11 a la que conectarse,
              si est&aacute; disponible.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
            <entry>La shell actual.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
            <entry>El nombre de la terminal del usuario. Se usa para determinar
              las caracter&iacute;sticas de la terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
            <entry>Base de datos donde encontrar los c&oacute;digos de
              escape necesarios para realizar diferentes funciones en la
              terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
            <entry>Tipo de sistema operativo.  Por ejemplo, &os;.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
            <entry>Arquitectura de CPU en la que se est&aacute; ejecutando
              el sistema.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
            <entry>El editor de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
            <entry>El paginador de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
            <entry>Lista de directorios separados por punto y coma
              en los que se buscan p&aacute;ginas de manual.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Shells Bourne</primary></indexterm>
    <para>Establecer una variable de entorno difiere ligeramente
      de shell a shell. Por ejemplo, en las shells al estilo C
      como <command>tcsh</command> y <command>csh</command>,
      se usar&iacute;a <command>setenv</command> para establecer
      las variables de entorno.  Bajo shells Bourne como
      <command>sh</command> y <command>bash</command>, se
      usar&iacute;a <command>export</command> para establecer
      las variables de entorno actuales.  Por ejemplo, para
      establecer o modificar la variable de entorno
      <envar>EDITOR</envar> (bajo <command>csh</command> o
      <command>tcsh</command>) la siguiente orden establece 
      <envar>EDITOR</envar> como 
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Bajo shells Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Tambi&eacute;n se puede hacer que la mayor&iacute;a de las shells 
      muestren el contenido de una variable de entorno situando el 
      car&aacute;cter <literal>$</literal> delante del nombre de la variable 
      en la l&iacute;nea de &oacute;rdenes.  Por ejemplo, 
      <command>echo $TERM</command>
      mostrar&aacute; cualquiera que sea el valor que 
      haya establecido para <envar>$TERM</envar>, porque la shell 
      expande el valor  de <envar>$TERM</envar> y se lo pasa al 
      programa <command>echo</command>.</para>

    <para>Las shells manejan muchos caracteres especiales, llamados
      metacaracteres, como representaciones especiales de datos.  El m&aacute;s
      com&uacute;n es el caracter <literal>*</literal>, que representa
      cualquier n&uacute;mero de caracteres en un nombre de fichero.  Estos
      metacaracteres especiales se pueden usar para la expansi&oacute;n de
      nombres de fichero.  Por ejemplo, teclear <command>echo *</command> es
      casi lo mismo que introducir <command>ls</command> porque el shell
      toma todos los ficheros que coinciden con <command>*</command> y se
      los pone en la l&iacute;nea de &oacute;rdenes para que 
      <command>echo</command> los vea.</para>

    <para><para>Para evitar que la shell interprete estos caracteres especiales 
      se pueden escapar de la shell anteponi&eacute;ndoles una contrabarra 
      (<literal>\</literal>).  <command>echo $TERM</command> imprime
      el nombre de terminal que est&eacute; usando.  
      <command>echo \$TERM</command> imprime <envar>$TERM</envar>, 
      literalmente.</para>

    <sect2 id="changing-shells">
      <title>C&oacute;mo cambiar su shell</title>

      <para>La manera m&aacute;s f&aacute;cil de cambiar de shell es 
        mediante <command>chsh</command>.  <command>chsh</command>
        le colocar&aacute; dentro del editor que est&eacute; configurado en
        la variable de entorno <envar>EDITOR</envar>; si no la ha modificado, 
        el sistema ejecutar&aacute; <command>vi</command>, el editor por 
        defecto.  Cambie la l&iacute;nea <quote>Shell:</quote> seg&uacute;n 
        prefiera.</para>
        
      <para>Tambi&eacute;n se le puede suministrar a <command>chsh</command>
        la opci&oacute;n <option>-s</option>; &eacute;sto establecer&aacute; la 
        shell sin necesidad de entrar en el editor de texto.  
        Si por ejemplo quiere que <command>bash</command> sea su shell por 
        defecto puede configurarlo del siguiente modo:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Ejecutar <command>chsh</command> sin par&aacute;metros y
        editar la shell desde ah&iacute; tambi&eacute;n funciona.</para>

      <note>
        <para>La shell que se desee usar <emphasis>debe</emphasis> estar
          incluida en <filename>/etc/shells</filename>.  
          Si se ha instalado una shell desde la 
          <link linkend="ports">colecci&oacute;n de ports</link> 
          esto deber&iacute; estar hecho autom&aacute;ticamente.  Si ha 
          instalado la shell manualmente, tendr&aacute; usted que 
          realizar dicha modificaci&oacute;n de 
          <filename>/etc/shells</filename>.</para>
     
      <para>Por ejemplo, si instal&oacute; manualmente <command>bash</command>
        y lo ubic&oacute; en <filename>/usr/local/bin</filename>,
        deber&iacute;a hacer lo siguiente:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Y volver a ejecutar <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Editores de texto</title>
    <indexterm><primary>editores de texto</primary></indexterm>
    <indexterm><primary>editores</primary></indexterm>

    <para>Gran parte de la configuraci&oacute;n de &os; se realiza
      modificando ficheros de texto.  Por esta raz&oacute;n le conviene 
      familiarizarse con un editor de texto.  &os; viene con unos cuantos
      como parte del sistema base y encontrar&aacute; muchos m&aacute;s 
      en la colecci&oacute;n de ports.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>El editor de textos m&aacute;s sencillo y f&aacute;cil de
      aprender es uno llamado <application>ee</application>, cuyo nombre
      proviene del ingl&eacute;s "easy editor" (editor f&aacute;cil).  
      Para iniciar <application>ee</application> se debe teclear en la
      l&iacute;nea de &oacute;rdenes 
      <command>ee <replaceable>nombre-de-fichero</replaceable></command>, 
      donde <replaceable>nombre-de-fichero</replaceable> es el nombre
      del fichero que se quiere editar.  Por ejemplo, para editar 
      <filename>/etc/rc.conf</filename> 
      tecl&eacute;e <command>ee /etc/rc.conf</command>.  Una vez dentro
      de <command>ee</command> todas las &oacute;rdenes para manipular 
      las funciones del editor est&aacute;n listadas en la parte 
      superior de la pantalla.  El caracter <literal>^</literal> representa 
      la tecla <keycap>Ctrl</keycap> del teclado, por lo tanto 
      <literal>^e</literal> se expande a la combinaci&oacute;n de teclas 
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
      Para salir de <application>ee</application>, pulse la tecla
      <keycap>Esc</keycap> y elija abandonar (leave) el editor.  
      El editor preguntar&aacute; entonces si se desean conservar los
      cambios si el fichero hubiera sido modificado.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD viene tambi&eacute;n con editores de texto mucho m&aacute;s
      potentes, como <application>vi</application>, como parte del
      sistema base, mientras que otros editores, como 
      <application>Emacs</application>
      y <application>vim</application>, son parte de la colecci&oacute;n
      de ports de &os; 
      (<filename role="package">editors/emacs</filename> y <filename role="package">editors/vim</filename>).  
      Estos editores ofrecen mucha m&aacute;s funcionalidad y poder
      con la desventaja de ser un poco m&aacute;s complicados de aprender a 
      manejar.  
      De cualquier manera si planea hacer mucho trabajo de edici&oacute;n
      de texto, aprender a usar un editor de texto m&aacute;s poderoso
      como <application>vim</application> o <application>Emacs</application>
      le ahorrar&aacute; m&aacute;s tiempo a la larga.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Dispositivos y nodos de dispositivos</title>

    <para>Un dispositivo es un t&eacute;rmino utilizado
      la mayor&iacute;a de las veces para actividades relacionadas 
      con hardware del sistema, como discos, impresoras, tarjetas 
      gr&aacute;ficas y teclados.  Cuando &os; arranca, la
      mayor&iacute;a de lo que &os; despliega son dispositivos
      en el momento de ser detectados.  Si lo desea, puede volver a 
      ver todos los mensajes que el sistema emite durante el arranque 
      consultando 
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Por ejemplo, <devicename>acd0</devicename> es la
      primera unidad CDROM IDE, mientras que <devicename>kbd0</devicename>
      representa el teclado.</para>

    <para>En un sistema operativo &unix;, debe accederse a la mayor&iacute;a 
      de estos dispositivos a trav&eacute;s de ficheros especiales llamados 
      nodos de dispositivo, que se encuentran en el directorio 
      <filename>/dev</filename>.</para>

    <sect2>
      <title>Creaci&oacute;n de nodos de dispositivo</title>
      <para>Cuando agregue un nuevo dispositivo a su sistema, o
        compile soporte para dispositivos adicionales, puede que
        necesite crear uno o m&aacute;s nodos de dispositivo.
        </para>

      <sect3>
	<title>Script MAKEDEV</title>
        <para>En sistemas sin <literal>DEVFS</literal> (esto concierne
          a todas las versiones anteriores a FreeBSD 5.0), los
          nodos de dispositivo son creados utilizando 
          &man.MAKEDEV.8; como puede verse en el siguiente 
          ejemplo:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

        <para>Este ejemplo debe crear el nodo de dispositivo
          apropiado para la segunda unidad IDE instalada.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> Dispositivo de sistema de ficheros (DEVice File System)</title>

        <para>El dispositivo de sistema de ficheros, o <literal>DEVFS</literal>,
          ofrece acceso a dispositivos del espacio de nombres del kernel en el
          espacio de nombres del sistema de ficheros global.  
          En lugar de tener que crear y modificar nodos de dispositivo,
          <literal>DEVFS</literal> se encarga del mantenimiento 
          din&aacute;mico de este sistema de fichero.</para>

        <para>Consulte  &man.devfs.5; si quiere m&aacute;s 
          informaci&oacute;n.</para>

        <para><literal>DEVFS</literal> se utiliza por defecto en 
          FreeBSD&nbsp;5.0 y siguientes.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">

    <title>Formatos binarios</title>

    <para>Para entender por qu&eacute; &os; utiliza el formato &man.elf.5;,
      primero debe saber unas cuantas cosas sobre los tres formatos
      de ejecutables <quote>dominantes</quote> en &unix;:</para> 

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>El formato objeto de &unix; m&aacute;s antiguo y
          <quote>cl&aacute;sico</quote>. Utiliza una cabecera
          corta y compacta con un n&uacute;mero m&aacute;gico al
          inicio que es usado frecuentemente para identificar el
          formato (vea &man.a.out.5; para m&aacute;s informaci&oacute;n).  
          Contiene tres segmentos cargados: .text, .data, y .bss
          adem&aacute;s de una tabla de s&iacute;mbolos y una tabla
          de cadena (<quote>strings</quote>).</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>El formato objeto de SVR3.  La cabecera consiste 
          en una tabla de secci&oacute;n, para que pueda ntener m&aacute;s
          contenido adem&aacute;s de las secciones .text, .data, 
          y .bss.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>El sucesor de <acronym>COFF</acronym>; dispone de 
          secciones m&uacute;ltiples y valores posibles de 32-bits
          o 64-bits.  Una gran desventaja: <acronym>ELF</acronym>
          fu&eacute; tambi&eacute;n dise&ntilde;ado asumiendo que
          solamente existir&iacute;a una ABI por cada arquitectura
          de sistema.  Esa suposici&oacute;n es en realidad bastante
          incorrecta y siquiera en el mundo comercial SYSV (el
          cual tiene al menos tres ABIs:  SVR4, Solaris y SCO) se
          puede dar por buena.</para>

        <para>&os; trata de solucionar este problema de alguna
          manera ofreciendo una herramienta para <emphasis>marcar</emphasis>
          un ejecutable <acronym>ELF</acronym> conocido con
          informaci&oacute;n acerca de la ABI con la que funciona.  
          Si quiere m&aacute;s informaci&oacute;n consulte 
          la p&aacute;gina de manual de &man.brandelf.1;. 
          </para>
      </listitem>
    </itemizedlist>

    <para>&os; viene del campo <quote>cl&aacute;sico</quote> y ha
      utilizado el formato &man.a.out.5;, una tecnolog&iacute;a usada
      y probada en muchas de muchas generaciones de versiones de 
      BSD hasta el inicio de la rama 3.X.  Aunque era posible
      compilar y ejecutar binarios nativos <acronym>ELF</acronym>
      (y kernels) en un sistema &os; desde alg&uacute;n tiempo
      antes de esto, &os; al principio se mantuvo 
      <quote>contra corriente</quote> y no cambi&oacute; a 
      <acronym>ELF</acronym> como formato por defecto.  
      &iquest;Por qu&eacute;?  Bueno, cuando el mundo Linux 
      efectu&oacute; su dolorosa transici&oacute;n a 
      <acronym>ELF</acronym> no fu&eacute; tanto por huir del formato 
      <filename>a.out</filename> como por su inflexible mecanismo de 
      bibliotecas compartidas basado en tablas de saltos, que 
      hac&iacute;a igual de dif&iacute;cil la construcci&oacute;n de 
      bibliotecas compartidas tanto para los desarrolladores como para 
      los proveedores.  
      Ya que las herramientas <acronym>ELF</acronym>
      disponibles ofrec&iacute;an una soluci&oacute;n al problema de
      las bibliotecas compartidas y eran vistas por mucha gente como
      <quote>la manera de avanzar</quote>, el costo
      de migraci&oacute;n fu&eacute; aceptado como necesario y se
      realiz&oacute; la transici&oacute;n.  El mecanismo de
      bibliotecas compartidas de &os; est&aacute; dise&ntilde;ado de
      manera m&aacute;s cercana al estilo del sistema de 
      bibliotecas compartidas de &sunos; de Sun y, como tal, es
      muy sencillo de utilizar.</para>

    <para>Entonces, &iquest;por qu&eacute; existen tantos formatos 
      diferentes?</para>

    <para>En un tiempo muy, muy lejano, exist&iacute;a hardware simple.  
      Este hardware tan simple soportaba un sistema peque&ntilde;o, simple.  
      <filename>a.out</filename> era id&oacute;neo para el trabajo
      de representar binarios en este sistema tan simple (un PDP-11). A
      medida que la gente portaba &unix; desde este sistema simple,
      retuvieron el formato <filename>a.out</filename> debido a que
      era suficiente para los primeros portes de &unix; a arquitecturas
      como 68k de Motorola, VAXen, etc.</para>

    <para>Entonces alg&uacute;n brillante ingeniero de hardware decidi&oacute;
      que si pod&iacute;a forzar al software a hacer algunos trucos
      sucios podr&iacute;a sortear ciertos obst&aacute;culos del 
      dise&ntilde;o y permitir al n&uacute;cleo de su CPU correr m&aacute;s
      r&aacute;pidamente.  Aunque estaba hecho para trabajar con este nuevo
      tipo de hardware (conocido entonces como <acronym>RISC</acronym>),
      <filename>a.out</filename> no estaba bien adaptado para este
      hardware, as&iacute; que varios formatos fueron desarrollados
      para obtener un mejor rendimiento de este hardware que el
      limitado, simple formato <filename>a.out</filename> podr&iacute;a
      ofrecer. As&iacute; fu&eacute; c&oacute;mo <acronym>COFF</acronym>, 
      <acronym>ECOFF</acronym> y algunos otros formatos m&aacute;s 
      extra&ntilde;os fueron inventados y sus limitaciones exploradas hasta 
      que se fu&eacute; llegando a la elecci&oacute;n en favor de 
      <acronym>ELF</acronym>.</para> 

    <para>Adem&aacute;s, el tama&ntilde;o de los programas estaba 
      volviendose gigantes y los discos (y la memoria f&iacute;sica)
      eran relativamente peque&ntilde;os,  as&iacute; que el concepto
      de una biblioteca compartida naci&oacute;.  El sistema
      VM tambi&eacute;n se volvi&oacute; m&aacute;s sofisticado.  
      Mientras cada uno de estos avances fu&eacute; hecho utilizando
      el formato <filename>a.out</filename>, su utilidad se iba reduciendo 
      paulatinamente con cada nueva opci&oacute;n.  Adem&aacute;s,
      la gente quer&iacute;a cargar cosas din&aacute;micamente en el momento 
      de ejecuci&oacute;n, o descartar partes de su programa despu&eacute;s de 
      que el c&oacute;digo de inicio se ejecutara para ahorrar memoria
      principal y espacio de swap.  Al volverse m&aacute;s sofisticados los 
      lenguajes, la gente empez&oacute; a ver la necesidad de introducir 
      c&oacute;digo antes del inicio del programa de forma autom&aacute;tica.  
      Se hicieron muchos hacks al formato <filename>a.out</filename> para
      permitir que todas estas cosas sucedieran, y lo cierto es que por un 
      tiempo funcionaron.  Pero <filename>a.out</filename> no estaba 
      no estaba para solucionar todos estos problemas sin incrementar
      la carga y complejidad del c&oacute;digo.  Aunque <acronym>ELF</acronym>
      resolv&iacute;a muchos de estos problemas, en ese momento hubiera sido 
      terrible dejar de lado un sistema que sencillamente funcionaba, 
      as&iacute; que
      <acronym>ELF</acronym> tuvo que esperar hasta que fu&eacute; m&aacute;s
      doloroso permanecer con <filename>a.out</filename> que migrar a
      <acronym>ELF</acronym>.</para>

    <para>De todas maneras, con el paso del tiempo, las herramientas
      de construcci&oacute;n de las que FreeBSD deriv&oacute;
      las suyas propias (el ensamblador y el cargador, sobre todo) 
      evolucionaron en dos &aacute;rboles
      paralelos.  El &aacute;rbol &os; a&ntilde;adi&oacute; bibliotecas 
      compartidas y corrigi&oacute; algunos errores.  La gente de GNU 
      que originalmente escribi&oacute; estos programas los
      reescribi&oacute; y a&ntilde;adieron una forma m&aacute;s simple para
      disponer de compiladores cruzados (<quote>cross compilers</quote>), 
      usando diferentes formatos a voluntad, etc.  
      Aunque mucha gente quer&iacute;a compiladores
      cruzados con FreeBSD como blanco no estaban de suerte, porque 
      los fuentes que &os; ten&iacute;a
      para <application>as</application> y <application>ld</application>
      no estaban listos para cumplir esa tarea.  La nueva cadena de herramientas
      GNU (<application>binutils</application>) soporta compilaci&oacute;n 
      cruzada, <acronym>ELF</acronym>, bibliotecas compartidas,
      extensiones C++, etc.  Adem&aacute;s, muchos proveedores est&aacute;n
      liberando binarios <acronym>ELF</acronym>, y es algo muy bueno 
      que FreeBSD los pueda ejecutar.</para>

    <para><acronym>ELF</acronym> es m&aacute;s expresivo que 
      <filename>a.out</filename>
      y permite un sistema base m&aacute;s extensible.  
      Las herramientas <acronym>ELF</acronym> est&aacute;n mejor
      mantenidas y ofrecen soporte de compilaci&oacute;n cruzada, 
      muy importante para mucha gente.  
      <acronym>ELF</acronym> puede ser un poco m&aacute;s lento que
      <filename>a.out</filename>, pero tratar de medirlo puede ser
      dif&iacute;cil. Tambi&eacute;n existen numerosos detalles
      que son diferentes entre los dos en c&oacute;mo mapean p&aacute;ginas,
      c&oacute;mo gestionan c&oacute;digo de inicio, etc. Ninguno de estos es
      muy importante, pero existen diferencias. Con el tiempo, el
      soporte para <filename>a.out</filename> ser&aacute; eliminado
      del kernel <filename>GENERIC</filename>, y es muy posible que 
      se elimine del kernel la posibilidad de ejecutar tales binarios 
      una vez que la necesidad de usar programas 
      <filename>a.out</filename> haya pasado.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Para m&aacute;s informaci&oacute;n</title>

    <sect2 id="basics-man">
      <title>P&aacute;ginas de manual</title>
      <indexterm><primary>p&aacute;ginas de manual</primary></indexterm>

      <para>La documentaci&oacute;n m&aacute;s exhaustiva de &os; 
        est&aacute; en las p&aacute;ginas de manual. Casi todos los 
        programas del sistema vienen con un breve manual de referencia 
        explicando el funcionamiento b&aacute;sico y sus diferentes argumentos.  
        Estos manuales pueden revisarse mediante <command>man</command>.  
        El uso de <command>man</command> es simple:</para>

      <screen>&prompt.user; <userinput>man <replaceable>orden</replaceable></userinput></screen>

      <para><literal>orden</literal> es el nombre de la orden sobre la que 
        que desea saber. Por ejemplo, para m&aacute;s informaci&oacute;n 
        sobre <command>ls</command> escriba:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>El manual en l&iacute;nea est&aacute; dividido en secciones
        numeradas:</para>

      <orderedlist>
	<listitem>
	  <para>Comandos de usuario.</para>
	</listitem>

	<listitem>
	  <para>Llamadas al sistema y n&uacute;meros de error.</para>
	</listitem>

	<listitem>
	  <para>Funciones en las bibliotecas de C.</para>
	</listitem>

	<listitem>
	  <para>Controladores de dispositivo.</para>
	</listitem>

	<listitem>
	  <para>Formatos de fichero.</para>
	</listitem>

	<listitem>
	  <para>Juegos y dem&aacute;s pasatiempos.</para>
	</listitem>

	<listitem>
	  <para>Informaci&oacute;n sobre temas diversos.</para>
	</listitem>

	<listitem>
	  <para>Comandos relacionados con el mantenimiento del sistema y 
           su funcionamiento.</para>
	</listitem>

	<listitem>
	  <para>Desarrolladores del Kernel.</para>
	</listitem>
      </orderedlist>

      <para>En algunos casos, el mismo tema puede aparecer en m&aacute;s de
        una secci&oacute;n del manual en l&iacute;nea.  Por ejemplo,
        existe una orden de usuario <command>chmod</command> y una 
        llamada del sistema <function>chmod()</function>.  En este caso 
        se le puede decir a <command>man</command> 
        cu&aacute;l  desea consultar especificando la secci&oacute;n:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Esto desplegar&aacute; la p&aacute;gina de manual de la 
        orden de usuario <command>chmod</command>. Las referencias 
        a una secci&oacute;n concreta del manual en l&iacute;nea
        tradicionalmente suelen colocarse entre par&eacute;ntesis
        en la documentaci&oacute;n escrita, por lo tanto &man.chmod.1;
        se refiere a la orden de usuario <command>chmod</command> y 
        &man.chmod.2; se refiere a la llamada de sistema.</para>

      <para>Esto est&aacute; muy bien si se conoce el nombre del programa y 
        simplemente se quiere saber como usarlo.  Pero, &iquest;y si no 
        puede recordar el nombre de la orden? Se puede usar man para que 
        realice una b&uacute;squeda mediante palabras clave en las descripciones 
        de programas utilizando el argumento <option>-k</option>:</para>
        
      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Dicha orden mostrar&aacute; una lista de 
        &oacute;rdenes que contengan la palabra clave <quote>mail</quote> 
        en sus descripciones.  Esto es funcionalmente 
        equivalente a usar <command>apropos</command>.</para>

      <para>As&iacute; que, est&aacute; viendo todos esos programas 
        tan atractivos en <filename>/usr/bin</filename> pero no tiene 
        ni la menor idea de lo que la mayor&iacute;a de ellos hace? 
        Haga lo siguiente:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>o</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>que hace exactamente lo mismo.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>Ficheros de informaci&oacute;n GNU</title>
      <indexterm><primary>Fundaci&oacute;n de software libre</primary></indexterm>

      <para>&os; incluye muchas aplicaciones y utilidades producidas 
        por la FSF (Free Software
        Foundation).  Adem&aacute;s de con las correspondientes 
        p&aacute;ginas de manual, 
        estos programas vienen con documentos de hipertexto m&aacute;s
        detallados, llamados ficheros <literal>info</literal>, los
        cuales pueden ser visualizados con <command>info</command>, 
        o si tiene instalado <application>emacs</application>, con
        el modo info de <application>emacs</application>.</para>

      <para>Si quiere utilizar la orden &man.info.1; simplemente 
        tecl&eacute;e:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Para una breve introducci&oacute;n, tecl&eacute;e <literal>h</literal>.
        Para una referencia r&aacute;pida, tecl&eacute;e <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

