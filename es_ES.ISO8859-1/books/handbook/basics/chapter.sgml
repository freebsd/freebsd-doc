<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Reescrito por </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>Conceptos b&aacute;sicos de Unix</title>
  
  <sect1 id="basics-synopsis">
    <title>Sinopsis</title>

  <para>El siguiente cap&iacute;tulo cubrir&aacute; la funcionalidad y
    comandos b&aacute;sicos del sistema operativo FreeBSD.
    Mucho de este material es relevante para cualquier sistema
    operativo tipo &unix;.
    Si&eacute;ntase libre de hojear este capitulo si est&aacute;
    familiarizado con el material. Si es nuevo en FreeBSD, seguramente
    querr&aacute; leer este cap&iacute;tulo cuidadosamente.</para>

    <para>Despu&eacute;s de leer este cap&iacute;tulo, usted
      sabr&aacute;:</para>

    <itemizedlist>
      <listitem>
        <para>C&oacute;mo usar las <quote>consolas virtuales</quote> de
            FreeBSD.</para>
      </listitem>
      <listitem>
        <para>Como trabajan los permisos de archivo &unix; junto
          con el entendimiento de las banderas de archvo en &os;.</para>
      </listitem>
      <listitem>
	<para>La disposici&oacute;n de archivos de sistema en &os; por
          defecto.</para>
      </listitem>
      <listitem>
	<para>La organizaci&oacute;n de disco de &os;.</para>
      </listitem>
      <listitem>
	<para>Como montar y desmontar sistemas de archivos.</para>
      </listitem>
      <listitem>
	<para>Qu&eacute; son los procesos, daemons y se&ntilde;ales.</para>
      </listitem>
      <listitem>
	<para>Que es un shell, como cambiar su ambiente de login por defecto.</para>
      </listitem>
      <listitem>
	<para>Como utilizar editores de texto b&aacute;sicos.</para>
      </listitem>
      <listitem>
	<para>Que son los dispositivos y nodos de dispositivos.</para>
      </listitem>
      <listitem>
	<para>Que formato binario es utilizado bajo &os;.</para>
      </listitem>
      <listitem>
	<para>Como leer p&aacute;ginas de manual para m&aacute;s informaci&oacute;n.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Consolas virtuales y terminales</title>
    <indexterm><primary>consola virtual</primary></indexterm>
    <indexterm><primary>terminales</primary></indexterm>

    <para>FreeBSD puede ser utilizado de varias maneras. Una de ellas es
      tecleando comandos en una terminal de texto. Mucha de la flexibilidad
      y poder de un sistema operativo &unix; est&aacute; inmediatamente
      disponible al alcance de sus manos cuando usa FreeBSD de esta
      manera. Esta secci&oacute;n describe que son <quote>terminales</quote>
      y <quote>consolas</quote>, y como puede usarlas en FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>La consola</title>
      <indexterm><primary>consola</primary></indexterm>

      <para>Si no ha configurado FreeBSD para iniciar automaticamente un
        entorno gr&aacute;fico durante el arranque, el sistema le
        presentar&aacute; con un prompt de entrada despues del arranque,
        justo despues que los scripts de inicio terminen de ejecutarse.
        Usted ver&aacute; algo similar a:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Los mensajes pueden ser un poco diferentes en su sistema, pero
        ver&aacute; algo similar. Las &uacute;ltima dos l&iacute;neas son
        las que nos interesan por el momento. La pen&uacute;ltima l&iacute;nea
        dice:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Esta l&iacute;nea contiene algunas partes de informaci&oacute;n
        acerca del sistema que acaba de arrancar. Esta usted mirando una
        consola <quote>FreeBSD</quote>, corriendo en un procesador Intel
        o compatible de la arquitectura x86<footnote>
          <para>Esto es lo que <literal>i386</literal> significa. Note que
            incluso si no est&aacute; ejecutando FreeBSD en un CPU Intel 386,
            este va a ser <literal>i386</literal>. No es el tipo de su
            procesador, sino la <quote>arquitectura</quote> la que es
            mostrada aqu&iacute;.</para> 
	</footnote>.
        El nombre de esta m&aacute;quina (cada m&aacute;quina &unix;
        tiene un nombre) es <hostid>pc3.example.org</hostid>, y usted
        est&aacute; ahora mirando su consola de sistema &mdash; la
        terminal <devicename>ttyv0</devicename>.</para>

      <para>Finalmente, la &uacute;ltima l&iacute;nea siempre es:</para>

      <programlisting>login:</programlisting>

      <para>Esta es la parte donde se supone que usted tecl&eacute;e
        su <quote>nombre de usuario</quote> para entrar en FreeBSD.
        La siguiente secci&oacute;n describe como puede hacer esto.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Entrando a FreeBSD</title>

      <para>FreeBSD es un sistema multiusuario, multiprocesador. Esta
        es la descripci&oacute;n formal que es dada usualmente a un
        sistema que puede ser utilizado por muchas personas diferentes,
        que simultaneamente corren muchos programas en un sola
        m&aacute;quina.</para>

      <para>Cada sistema multiusuario necesita alguna manera para
        distinguir a un <quote>usuario</quote> del resto. En FreeBSD
        (y en todos los sistemas operativos tipo &unix;), esto se
        logra requiriendo que cada usuario debe <quote>firmarse</quote>
        en el sistema antes de poder correr programas. Cada usuario
        tiene un nombre &uacute;nico (el <quote>nombre de usuario</quote>)
        y una llave secreta, personal (la <quote>contrase&ntilde;a</quote>).
        FreeBSD preguntar&aacute; por estos dos antes de permitirle a
        un usuario correr cualquier programa.</para>

      <indexterm><primary>scripts de inicio</primary></indexterm>
      <para>Justo despues que FreeBSD arranca y termina de correr sus
        scripts de inicio
        <footnote>
          <para>Scripts de inicio son programas que son ejecutados
            automaticamente por FreeBSD cuando arranca. Su funci&oacute;n
            principal es preparar las cosas para que todo lo dem&aacute;s
            se ejecute, e iniciar cualquier servicio que tenga configurado
            para correr en segundo plano haciendo cosas &uacute;tiles.</para>
        </footnote>, le presentar&aacute; un prompt y solicitar&aacute;
        un nombre de usuario v&aacute;lido:</para>

      <screen>login:</screen>

      <para>Para efectos de este ejemplo, vamos a asumir que su nombre de
        usuario es <username>john</username>. Tecl&eacute;e <literal>john</literal>
        en este prompt y presione <keycap>Enter</keycap>. Se le debe presentar
        un prompt para entrar una <quote>contrase&ntilde;a</quote>:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Tecl&eacute;e ahora la contrase&ntilde;a de <username>john</username>
        y presione <keycap>Enter</keycap>. !La contrase&ntilde;a <emphasis>no
        produce eco!</emphasis> no necesita preocuparse por eso en este
        momento. Es suficiente decir que esto es hecho por razones de
        seguridad.</para>

      <para>Si ha tecleado su contrase&ntilde;a correctamente, ya debe estar
        firmado en FreeBSD en este momento y listo para probar todos los
        comandos disponibles.</para>

      <para>Debe de ver el <acronym>MOTD</acronym> o mensaje del d&iacute;a
        seguido por un prompt de comandos (un caracter <literal>#</literal>,
        <literal>$</literal> o <literal>%</literal>). Esto indica
        que se ha firmado exitosamente en FreeBSD.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Consolas m&uacute;ltiples</title>

      <para>Ejecutar comandos &unix; en una consola est&aacute; bien, pero
        FreeBSD puede correr muchos programas a la vez. Tener una consola
        donde se pueden teclear comandos puede ser un poco de desperdicio
        cuando un sistema operativo como FreeBSD puede correr docenas de
        programas al mismo tiempo. Aqu&iacute; es donde las
        <quote>consolas virtuales</quote> pueden ser de mucha ayuda.</para>

      <para>FreeBSD puede ser configurado para presentarle diferentes
        consolas virtuales. Puede cambiar de una de ellas a cualquier
        otra consola virtual presionando un par de teclas en su teclado.
        Cada consola tiene su propio canal de salida diferente, y FreeBSD
        se ocupa de redireccionar correctamente la entrada del teclado y
        la salida al monitor cuando cambia de una consola virtual a la
        siguiente.</para>

      <para>Combinaciones especiales de teclas han sido reservadas por
        FreeBSD para cambiar consolas<footnote>
        <para>Una descripci&oacute;n bastante t&eacute;cnica y correcta
          de todos los detalles de la consola FreeBSD y los controladores de
          teclado pueden encontrarse en las p&aacute;ginas de manual de
          &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; y
          &man.kbdcontrol.1;. No nos explayaremos en los detalles aqu&iacute;,
          pero el lector interesado siempre puede consultar las p&aacute;ginas
          de manual para una explicaci&oacute;n m&aacute;s detallada y
          profunda de como funcionan estas cosas.</para>
	</footnote>. Puede utilizar
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> hasta
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> para cambiar
        a una consola virtual diferente en FreeBSD.</para>

      <para>Mientras est&aacute; cambiando de una consola a la siguiente,
        FreeBSD se ocupa de salvar y restaurar la salida de pantalla. El
        resultado es una <quote>ilusi&oacute;n</quote> de tener varias
        pantallas y teclados <quote>virtuales</quote> que puede utilizar
        para teclear comandos para que los corra FreeBSD. El programa que
        usted lanza en una consola virtual no termina de correr cuando la
        consola no est&aacute; visible. Contin&uacute;an ejecut&aacute;ndose
        cuando se cambia a una consola virtual diferente.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>El archivo <filename>/etc/ttys</filename></title>

      <para>La configuraci&oacute;n por omisi&oacute;n de FreeBSD iniciar&aacute;
        con ocho consolas virtuales. Esta no es una configuraci&oacute;n
        est&aacute;tica por hardware y usted puede facilmente personalizar
        su instalaci&oacute;n para arrancar con m&aacute;s o menos consolas
        virtuales. El n&uacute;mero y propiedades de las consolas
        virtuales est&aacute;n configurados en el archivo
        <filename>/etc/ttys</filename>.</para>

      <para>Puede utilizar el archivo <filename>/etc/ttys</filename> para
        configurar las consolas virtuales de FreeBSD. Cada l&iacute;nea no
        comentada en este archivo (l&iacute;neas que no inician con un
        caracter <literal>#</literal>) contiene propiedades para una sola
        terminal o consola virtual. La versi&oacute;n por omisi&oacute;n de
        este archivo que se encuentra en FreeBSD configura nueve consolas
        virtuales y habilita ocho de ellas. Son las l&iacute;neas que inician
        con <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Para una descripci&oacute;n detallada de cada columna en este
        archivo y todas las opciones que puede usar para configurar las
        consolas virtuales, consulte la p&aacute;gina de manual &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Consola en modo monousuario</title>

      <para>Una descripci&oacute;n detallada de lo que es <quote>modo
        monousuario</quote> puede encontrarse en <xref linkend="boot-singleuser">.
        No importa que solo exista una consola cuando ejecuta FreeBSD en
        modo monousuario. No existen consolas virtuales disponibles. Las
        configuraciones de la consola en modo monousuario se pueden encontrar
        tambi&eacute;n en el archivo <filename>/etc/ttys</filename>. Busque la
        l&iacute;nea que inicia con <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# Si la consola est&aacute; marcada como "insecure", entonces init preguntar&aacute;
# por la contrase&ntilde;a de root al entrar a modo monousuario.
console none                            unknown off secure</programlisting>

      <note>
        <para>Como los comentarios arriba de la l&iacute;nea <literal>console</literal>
          indican, usted puede editar esta l&iacute;nea y cambiar
          <literal>secure</literal> a <literal>insecure</literal>. Si hace
          eso, cuando FreeBSD arranque en modo monousuario, todav&iacute;a
          preguntar&aacute; por la contrase&ntilde;a de
          <username>root</username>.</para>

        <para><emphasis>Tenga cuidado al cambiar esto a
          <literal>insecure</literal></emphasis>. Si olvida la
          contrase&ntilde;a de <username>root</username>, arrancar
          en modo monousuario est&aacute; un poco involucrado. Todav&iacute;a
          es posible, pero puede ser un poco dif&iacute;cil para alguien
          que no se encuentra muy c&oacute;modo con le proceso de
          arranque de FreeBSD y los programas involucrados.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Permisos</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, cuya raiz hist&oacute;rica es el UNIX BSD, tiene
      sus fundamentos basados en varios conceptos clave de UNIX. El primero, y
      m&aacute;s remarcado, es que FreeBSD es un sistema operativo
      multi-usuario.  El sistema puede manejar varios usuarios trabajando
      todos simult&aacute;neamente y en tareas que no guardan relaci&oacute;n
      entre sí. El sistema es el responsable de compartir y administrar
      peticiones de dispositivos de hardware, perif&eacute;ricos, memoria y
      tiempo de Unidad Central de Proceso (CPU) de manera equitativa para cada
      usuario.</para>

    <para>Debido a que el sistema es capaz de soportar m&uacute;ltiples
      usuarios, todo lo que el sistema administra tiene un conjunto de
      permisos que gobiernan qui&eacute;n puede leer, escribir y ejecutar el
      elemento. Estos permisos se guardan como octetos divididos en tres
      partes: una para el propietario del archivo, otra para el grupo al que
      el archivo pertenece, y otra para cualquier otro. Esta
      representaci&oacute;n num&eacute;rica funciona as&iacute;:</para>

    <indexterm><primary>permisos</primary></indexterm>
    <indexterm>
      <primary>permisos de archivo</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valor</entry>
	    <entry>Permiso</entry>
	    <entry>Listado de directorio</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>No leer, no escribir, no ejecutar</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>No leer, no escribir, ejecutar</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>No leer, escribir, no ejecutar</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>No leer, escribir, ejecutar</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Leer, no escribir, no ejecutar</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Leer, no escribir, ejecutar</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Leer, escribir, no ejecutar</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Leer, escribir, ejecutar</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directorios</primary></indexterm>

    <para>Puede utilizar el argumento de l&iacute;nea de comando
      <option>-l</option> en &man.ls.1; para ver un listado
      largo que incluye una columna con informaci&oacute;n acerca
      de los permisos de archivo para el propietario, grupo y
      los dem&aacute;s. Por ejemplo, un <command>ls -l</command> en
      un directorio arbitrario puede mostrar:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Aqu&iacute; est&aacute; como se divide la primera columna
      de <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>El primer caracter (m&aacute;s a la izquierda) indica si
      este archivo es un archivo regular, un directorio, un
      dispositivo especial de caracter, un socket o cualquier otro
      dispositivo especial pseudo-archivo. En este caso, el <literal>-</literal>
      indica un archivo regular. Los siguientes tres caracteres,
      <literal>rw-</literal> en este ejemplo, dan los permisos
      para el propietario del archivo. Los siguientes tres caracteres,
      <literal>r--</literal>, dan los permisos para el grupo al que
      el archivo pertenece. Los &uacute;ltimos tres caracteres,
      <literal>r--</literal>, dan los permisos para el resto del
      mundo. Un gui&oacute;n indica que el permiso est&aacute; desactivado.
      En el caso de este archivo, los permisos est&aacute;n 
      asignados de tal manera que el propietario puede leer y escribir
      en el archivo, el grupo puede leer el archivo, y el resto del
      mundo s&oacute;lo puede leer el archivo. De acuerdo con la tabla
      de arriba, los permisos para este archivo ser&iacute;an <literal>644</literal>,
      donde cada d&iacute;gito representa las tres partes de los 
      permisos del archivo.</para>

    <para>Todo &eacute;sto est&aacute; muy bien, pero &iquest;c&oacute;mo
      controla el sistema los permisos de los dispositivos? FreeBSD en
      realidad trata la mayor&iacute;a de los dispositivos hardware como un
      archivo que los programas pueden abrir, leer y en los que pueden
      escribir datos como si de cualquier otro archivo se tratara. Estos
      archivos especiales de dispositivos se encuentran en el directorio
      <filename>/dev</filename>.</para>

    <para>Los directorios tambi&eacute;n son tratados como archivos. Tienen
      permisos de lectura, escritura y ejecuci&oacute;n. El bit de
      ejecuci&oacute;n en un directorio tiene un significado
      lig&eacute;ramente distinto que para los archivos. Cuando un directorio
      est&aacute; marcado como ejecutable significa que se puede mirar dentro,
      se puede hacer un <quote>cd</quote> (cambiar directorio) a &eacute;l.
      Esto tambi&eacute;n significa que dentro del directorio es posible
      accesar archivos cuyos nombres son conocidos (sujeto, claro est&aacute;,
      a los permisos en los archivos mismos).</para>

    <para>En particular, para poder realizar un listado de directorio,
      el permiso de lectura debe ser activado en el directorio,
      mientras que para borrar un archivo del que se conoce el
      nombre, es necesario tener permisos de escritura <emphasis>y</emphasis>
      ejecuci&oacute;n en el directorio que contiene el archivo.</para>

    <para>Existen m&aacute;s permisos, pero se usan principalmente en
      circunstancias especiales como los binarios ejecutables de tipo setuid
      y los los directorios de tipo sticky. Si desea m&aacute;s
      informaci&oacute;n acerca de los permisos de archivos y como
      establecerlos, aseg&uacute;rese de mirar la p&aacute;gina de manual de
      &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribuido por </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Permisos simb&oacute;licos</title>
      <indexterm><primary>permisos</primary><secondary>symbolic</secondary></indexterm>

      <para>Los permisos simb&oacute;licos, algunas veces referidos como
        expresiones simb&oacute;licas, utilizan caracteres en lugar de valores
        octales para asignar permisos a archivos o directorios. Las expresiones
        simb&oacute;licas utilizan la sintaxis de (qui&eacute;n) (acci&oacute;n)
        (permisos), donde los valores siguientes est&aacute;n disponibles:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Opci&oacute;n</entry>
	      <entry>Letra</entry>
	      <entry>Representa</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>u</entry>
	    <entry>Usuario</entry>
	  </row>

	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>g</entry>
	    <entry>Propietario de grupo</entry>
	  </row>

	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>o</entry>
	    <entry>Otro</entry>
	  </row>

	  <row>
	    <entry>(qui&eacute;n)</entry>
	    <entry>a</entry>
	    <entry>Todos (<quote>mundo</quote>)</entry>
	  </row>

	  <row>
	    <entry>(acci&oacute;n)</entry>
	    <entry>+</entry>
	    <entry>Agregar permisos</entry>
	  </row>

	  <row>
	    <entry>(acci&oacute;n)</entry>
	    <entry>-</entry>
	    <entry>Remover permisos</entry>
	  </row>

	  <row>
	    <entry>(acci&oacute;n)</entry>
	    <entry>=</entry>
	    <entry>Activar permisos explicitamente</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>r</entry>
	    <entry>Lectura</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>w</entry>
	    <entry>Escritura</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>x</entry>
	    <entry>Ejecuci&oacute;n</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>t</entry>
	    <entry>Bit Sticky</entry>
	  </row>

	  <row>
	    <entry>(permisos)</entry>
	    <entry>s</entry>
	    <entry>Activar UID o GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Estos valores son utilizados con el comando &man.chmod.1;
      de la misma manera que los anteriores, pero con letras. Por
      ejemplo, usted podr&iacute;a usar el siguiente comando para
      bloquear a otros usuarios el acceso a <replaceable>FILE</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Una lista separada por comas puede brindarse cuando m&aacute;s
      de un conjunto de cambios se debe realizar a un archivo. Por
      ejemplo el siguiente comando eliminar&aacute; los permisos de
      escritura de grupo y <quote>mundo</quote> en <replaceable>FILE</replaceable>,
      y entonces agrega permisos de ejecuci&oacute;n para todos:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribuido por </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Banderas de archivo de &os;</title>

      <para>Adem&aacute;s de los permisos de archivo discutidos
        previamente, &os; soporta el uso de <quote>banderas de
        archivo</quote>. Estas banderas agregan un nivel de seguridad
        y control adicional sobre archivos, pero no sobre directorios.</para>

      <para>Estas banderas de archivo agregan un nivel de control
        adicional sobre archivos, ayudando a asegurar que en algunos
        casos ni siquiera <username>root</username> pueda eliminar
        o alterar archivos.</para>

      <para>Las banderas de archivo son alteradas usando la utilidad
        &man.chflags.1;, mediante una interfaz simple. Por ejemplo,
        para habilitar la bandera imborrable de sistema en el archivo
        <filename>file1</filename>, escriba el siguiente comando:</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>file1</filename></userinput></screen>

      <para>Y para dehabilitar la bandera imborrable de sistema,
        simplemente escriba el comando previo con <quote>no</quote>
        al frente de <option>sunlink</option>. Observe:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>file1</filename></userinput></screen>

      <para>Para ver las banderas en este archivo, utilice
        &man.ls.1; con las opciones <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>file1</filename>
	</userinput></screen>

      <para>La salida debe verse como la siguiente:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Varias banderas solo pueden ser agregadas o removidas
        de archivos por el usuario <username>root</username>. En
        otros casos, el propietario del archivo puede activar estas
        banderas. Se recomienda que un administrador lea las
        p&aacute;ginas de manual &man.chflags.1; y &man.chflags.2;
        para m&aacute;s informaci&oacute;n.</para>
    </sect2>
  </sect1>
  
  <sect1 id="dirstructure">
    <title>Estructura de directorios</title>
    <indexterm><primary>jerarqu&iacute;a de directorios</primary></indexterm>

    <para>La jerarqu&iacute;a del sistema de archivos de FreeBSD es
      fundamental para obtener una compresi&oacute;n completa del
      sistema. El concepto m&aacute;s importante de entender es el
      del directorio ra&iacute;z, <quote>/</quote>. Este directorio
      es el primero en ser montado al momento de arranque y contiene
      el sistema b&aacute;sico necesario para preparar al sistema
      operativo para la operaci&oacute;n en modo multiusuario.
      El directorio raiz tambi&eacute;n contiene puntos de montaje
      para cualquier otro sistema de archivos que se desee montar.</para>

    <para>Un punto de montaje es un directorio donde se pueden injertar
      sistemas de archivos al sistema de archivos ra&iacute;z.
      Esto es explicado con mas detalle en <xref linkend="disk-organization">.
      Los puntos de montaje est&aacute;ndar inlcuyen
      <filename>/usr</filename>, <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> y <filename>/cdrom</filename>. Estos
      directorios est&aacute;n usualmente referenciados a entradas en
      el archivo <filename>/etc/fstab</filename>. <filename>/etc/fstab</filename>
      es una tabla que sirve como referencias al sistema y contiene
      los diferentes sistemas de archivos y sus respectivos
      puntos de montaje. La mayor&iacute;a de los sistemas de archivos
      en <filename>/etc/fstab</filename> son montados automaticamente
      al momento de arranque desde el script &man.rc.8;
      a menos que contengan la opci&oacute;n <option>noauto</option>.
      Se pueden encontrar detalles en <xref linkend="disks-fstab">.</para>

    <para>Una descripci&oacute;n completa de la jerarqu&iacute;a del
      sistema de archivos est&aacute; disponible en &man.hier.7;.
      Por ahora, una breve revisi&oacute;n de los directorios
      m&aacute;s comunes ser&aacute; suficiente.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Directorio</entry>
	      <entry>Descripci&oacute;n</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Directorio ra&iacute;z del sistema de archivos.</entry>
            </row>
	    
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
              <entry>Utilidades de usuario fundamentales tanto para el
                ambiente monousuario como para el multiusuario.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
              <entry>Programas y archivos de configuraci&oacute;n utilizados
                durante el arranque del sistema operativo.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
              <entry>Archivos de configuraci&oacute;n por defecto de
                arranque; ver &man.loader.conf.5;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Nodos de dispositivo; ver &man.intro.4;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Archivos de configuraci&oacute;n y scripts del sistema.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Archivos de configuraci&oacute;n por omisi&oacute;n del sistema;
                ver &man.rc.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
              <entry>Archivos de configuraci&oacute;n para agentes de
                transporte de correo como &man.sendmail.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
              <entry>Archivos de configuraci&oacute;n de <command>named</command>;
                ver &man.named.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
              <entry>Scripts que son ejecutados diariamente, semanalmente y
                mensualmente v&iacute;a &man.cron.8;; ver &man.periodic.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
              <entry>Archivos de configuraci&oacute;n de <command>ppp</command>;
                ver &man.ppp.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
              <entry>Directorio vacio comunmente utilizado por administradores
                de sistemas como un punto de montaje temporal.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
              <entry>Sistema de archivos de procesos; ver &man.procfs.5;,
	      &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
              <entry>Programas enlazados estaticamente para recuperaciones
                de emergencia; ver &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
              <entry>Directorio home para la cuenta <username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
              <entry>Programas del sistema y utilidades fundamentales de
                administraci&oacute;n para ambientes monousuario y
                multiusuario.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
              <entry>Programas utilizados en un ambiente autocontenido (standalone).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
              <entry>Archivos temporales. Los contenidos de
                <filename class="directory">/tmp</filename> usualmente NO
                son preservados despues de un rearranque del sistema.
                Un sistema de archivos basado en memoria es frecuentemente
                montado en <filename class="directory">/tmp</filename>.
                Esto puede automatizarse usando variables relacionadas a
                tmpmfs de &man.rc.conf.5 (o con una entrada en
                <filename>/etc/fstab</filename>; ver &man.mdmfs.8;,
                o para FreeBSD&nbsp;4.X, &man.mfs.8;).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
              <entry>La mayor&iacute;a de utilidades y aplicaciones de usuario.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
              <entry>Utilidades comunes, herramientas de programaci&oacute;n y
                aplicaciones.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
              <entry>Archivos incluidos est&aacute;ndar de C.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
              <entry>Librer&iacute;as de archivos.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
              <entry>Utilidades miscelaneas de archivos de datos.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
              <entry>Daemons de sistema y utilidades de sistema (ejecutados
                por otros programas).</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

              <entry>Ejecutables locales, librer&iacute;as, etc.
                tambi&eacute;n usado como el destino por omisi&oacute;n
                de la infraestructura de ports de FreeBSD. Dentro de
                <filename>/usr/local</filename>, el esquema
                general delineado por &man.hier.7; para
                <filename>/usr</filename> debe ser utilizado. Las
                excepciones son el directorio man, el cual est&aacute;
                directamente bajo <filename>/usr/local</filename> en
                lugar de debajo de <filename>/usr/local/share</filename>
                y la documentaci&oacute;n de los ports est&aacute; en
                <filename>share/doc/<replaceable>port</replaceable></filename>.
 	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
              <entry>Arbol destino de arquitectura espec&iacute;fica producido por
                la construcci&oacute;n del &aacute;rbol
                <filename>/usr/src</filename>.</entry>	
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
              <entry>La colecci&oacute;n de Ports de FreeBSD (opcional).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
              <entry>Daemons del sistema y utilidades del sistema (ejecutados por
                usuarios).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
              <entry>Archivos independientes de arquitectura.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
              <entry>Archivos fuente BSD y/o local.</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
              <entry>Ejecutables de la distribuci&oacute;n X11R6,
                librer&iacute;as, etc (opcional).</entry> 
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
              <entry>Archivos multiprop&oacute;sito de log, temporales, en
                tr&aacute;nsito y de spool. Un sistema de archivos basado
                en memoria es montado algunas veces en
                <filename class="directory">/var</filename>.
                Esto puede automatizarse utilizando variables relacionadas
                a varmfs de &man.rc.conf.5 (o con una entrada en
                <filename>/etc/fstab</filename>; ver &man.mdmfs.8;,
                o para FreeBSD&nbsp;4.X, &man.mfs.8;).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
              <entry>Archivos de log miscelaneos del sistema.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
              <entry>Archivos de buzones de correo de usuarios.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
              <entry>Directorios miscelaneos del sistema de spool de impresora
                y correo</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
              <entry>Archivos temporales.
                Los archivos son usualmente preservados despues de un
                rearranque del sistema, a menos que
                <filename class="directory">/var</filename> sea un
                sistema de archivos basado en memoria.</entry>
	    </row>
	    
	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Mapas NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Organizaci&oacute;n de disco</title>

      <para>La unidad m&aacute;s peque&ntilde;a que FreeBSD utiliza para
        encontrar archivos es el nombre de archivo. Los nombres de archivo
        son sensibles a las may&uacute;sculas, lo que significa que
        <filename>readme.txt</filename> y <filename>README.TXT</filename>
        son dos archivos separados. FreeBSD no utiliza la extensi&oacute;n
        (<filename>.txt</filename>) de un archivo para determinar si el
        archivo es un programa, o un documento o alguna otra forma de datos.</para>

      <para>Los archivos son almacenados en directorios. Un directorio puede
        estar vac&iacute;o, o puede contener cientos de archivos. Un
        directorio tambi&eacute;n puede contener otros directorios,
        permiti&eacute;ndole contruir una jerarqu&iacute;a de directorios
        dentro de otro. Esto hace mucho m&aacute;s f&aacute;cil la
        organizaci&oacute;n de sus datos.</para>

      <para>Archivos y directorios son referenciados dando el
        nombre de archivo o de directorio, seguido por una diagonal,
        <literal>/</literal>, seguido por cualquier otro nombre de
        directorio que sea necesario. Si tiene un directorio
        <filename>foo</filename>, el cual contiene el directorio
        <filename>bar</filename>, el cual contiene el archivo
        <filename>readme.txt</filename>, entonces el nombre completo
        o <firstterm>ruta</firstterm> al archivo es
        <filename>foo/bar/readme.txt</filename>.</para>

      <para>Los directorios y archivos son almacenados en un sistema de archivos.
        Cada sistema de archivos contiene exactamente un directorio en el nivel
        m&aacute;s elevado, llamado el <firstterm>directorio ra&iacute;z</firstterm>
        para ese sistema de archivos. Este directorio ra&iacute;z puede
        entonces contener otros directorios.</para>

      <para>Hasta ahora esto es probablemente similar a cualquier otro sistema
        operativo que pueda haber utilizado. Existen unas cuantas diferencias;
        por ejemplo, &ms-dos; utiliza <literal>\</literal> para separar nombres
        de archivo y directorio, mientras que &macos; utiliza <literal>:</literal>.</para>
        
      <para>FreeBSD no utiliza letras de unidades, o otro nombre de unidad
        en la ruta. No podr&iacute;a escribir <filename>c:/foo/bar/readme.txt</filename>
        en FreeBSD.</para>

      <para>En cambio, un sistema de archivos es designado el
        <firstterm>sistema de archivos ra&iacute;z</firstterm>. El
        directorio ra&iacute;z del sistema de archivos ra&iacute;z est&aacute;
        referenciado como <literal>/</literal>. Cualquier otro sistema
        de archivos es entonces <firstterm>montado</firstterm> bajo el
        sistema de archivos ra&iacute;z. No importa cuantos discos tenga
        en su sistema FreeBSD, cada directorio parece ser parte del
        mismo disco.</para>

      <para>Suponga que tiene tres sistemas de archivos, llamdos <literal>A</literal>,
        <literal>B</literal> y <literal>C</literal>. Cada sistema de
        archivos tiene un directorio ra&iacute;z, el cual contiene
        otros dos directorios, llamados
        <literal>A1</literal>, <literal>A2</literal> (y de la misma manera
        <literal>B1</literal>, <literal>B2</literal> y
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para>Llame a <literal>A</literal> el sistema de archivos ra&iacute;z.
        Si usara el comando <command>ls</command> para ver el contenido de
        este directorio ver&iacute;a dos subdirectorios, <literal>A1</literal>
        y <literal>A2</literal>. El &aacute;rbol de directorios se ve como
        esto:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Un sistema de archivos debe ser montado en un directorio
        en otro sistema de archivos. Ahora suponga que monta el
        sistema de archivos <literal>B</literal> en el directorio
        <literal>A1</literal>. El directorio ra&iacute;z de
        <literal>B</literal> reemplaza a <literal>A1</literal>,
        y los directorios en <literal>B</literal> aparecen de
        esta manera:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 | 
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Cualquier archivo que est&eacute; en el directorio
        <literal>B1</literal> o <literal>B2</literal> puede ser
        alcanzado con la ruta <filename>/A1/B1</filename> o
        <filename>/A1/B2</filename> seg&uacute;n sea necesario.
        Cualquier archivo que est&eacute; en <filename>/A1</filename>
        ha sido temporalmente escondido. Aparecer&aacute;n de nuevo
        si <literal>B</literal> es <firstterm>desmontado</firstterm>
        de A.</para>

      <para>Si <literal>B</literal> ha sido montado en <literal>A2</literal>
        entonces el diagrama se ver&iacute;a como este:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>y las rutas ser&iacute;an <filename>/A2/B1</filename> y
        <filename>/A2/B2</filename> respectivamente.</para>

      <para>Sistemas de archivos pueden ser montados uno sobre otro. Continuando
        el ejemplo anterior, el sistema de archivos <literal>C</literal>
        podr&iacute;a ser montado sobre el directorio <literal>B1</literal>
        en el sistema de archivos <literal>B</literal>, llevando a este
        arreglo:</para> 

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>O <literal>C</literal> podr&iacute;a ser montado directamente
        en el sistema de archivos <literal>A</literal>, bajo el directorio
        <literal>A1</literal>:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Si est&aacute; familiarizado con &ms-dos;, esto es similar,
        aunque no id&eacute;ntico, al comando <command>join</command>.</para>

      <para>Esto normalmente no es algo de lo que necesite preocuparse.
        Tipicamente usted crea sistemas de archivos cuando instala FreeBSD
        y decide donde montarlos, y entonces nunca los cambie a menos que
        agregue un disco nuevo.</para>

      <para>Es enteramente posible tener un sistema de archivos ra&iacute;z
        extenso, y no necesitar crear otros. Existen alguas inconveniencias de
        esta aproximaci&oacute;n, y una ventaja.</para>

      <itemizedlist>
	<title>Beneficios de m&uacute;ltiples sistemas de archivos</title>
      
	<listitem>
          <para>Diferentes sistemas de archivos pueden tener diferentes
            <firstterm>opciones de montaje</firstterm>. Por ejemplo, con
            una planeaci&oacute;n cuidadosa, el sistema de archivos
            ra&iacute;z puede ser montado de solo-lectura, haciendole
            a usted imposible borrar inadvertidamente o editar un archivo
            cr&iacute;tico. Separando los sistemas de archivos escribibles
            por usuarios, como <filename>/home</filename>, de otros
            sistemas de archivos tambi&eacute;n les permite ser montados
            <firstterm>nosuid</firstterm>; esta opci&oacute;n previene
            que los bits <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
            en los ejecutables almacenados en el sistema de archivos
            tengan efecto, mejorando posiblemente la seguridad.</para>
	</listitem>

	<listitem>
          <para>FreeBSD automaticamente optimiza el esquema de archivos
            en un sistema de archivos, dependiendo de como el sistema
            de archivos est&aacute; siendo utilizado. As&iacute; que
            un sistema de archivos que contiene muchos archivos peque&ntilde;os
            que son escritos frecuentemente tendr&aacute; una optimizaci&oacute;n
            diferente de uno que contenga menos y m&aacute;s grandes archivos.
            Teniendo un sistema de archivos grande esta optimizaci&oacute;n
            se desmorona.</para> 
	</listitem>
	
	<listitem>
          <para>Los sistemas de archivos de FreeBSD son muy robustos si
            sufre una falla de electricidad. De todas maneras, una falla
            el&eacute;ctrica en un momento cr&iacute;tico todav&iacute;a puede
            da&ntilde;ar la estructura del sistema de archivos. Dividiendo
            sus datos a trav&eacute;s de m&uacute;ltiples sistemas de
            archivos hace que sea m&aacute;s probable que el sistema se
            levante, haciendole m&aacute;s f&aacute;cil restaurar desde
            un respaldo si fuera necesario.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Beneficios de un solo sistema de archivos</title>

	<listitem>
          <para>Los sistemas de archivos son de un tama&ntilde;o fijo. Si crea
            un sistema de archivos cuando instala FreeBSD y le da un tama&ntilde;o
            espec&iacute;fico, tal vez descubra mas tarde que necesita hacer
            la partici&oacute;n m&aacute;s grande. Esto no se logra facilmente
            sin respaldar, recrear el sistema de archivos con el nuevo
            tama&ntilde;o y entonces restaurar los datos respaldados.</para>

	  <important>
            <para>FreeBSD&nbsp;4.4 y versiones posteriores presentan el
              comando &man.growfs.8;, el cual hace posible incrementar
              el tama&ntilde;o del sistema de archivos al vuelo, eliminando
              esta limitaci&oacute;n.</para>
	  </important>
	</listitem>
      </itemizedlist>
    
      <para>Los sistemas de archivos est&aacute;n contenidos en particiones.
        Esto no tiene el mismo significado del uso com&uacute;n del
        t&eacute;rmino partici&oacute;n (por ejemplo, partici&oacute;n &ms-dos;),
        debido a la herencia &unix; de &os;. Cada partici&oacute;n es
        identificada por una letra desde <literal>a</literal> hasta
        <literal>h</literal>. Cada partici&oacute;n puede contener solamente
        un sistema de archivos, lo que significa que los sistemas de
        archivos son usualmente descritos por su punto de montaje en la
        jerarqu&iacute;a del sistema de archivos o por la letra de la
        partici&oacute;n en la que est&aacute;n contenidos.</para>

      <para>FreeBSD tambi&eacute;n utiliza espacio de disco
        como <firstterm>espacio de intercambio (swap)</firstterm>.
        El espacio de intercambio le brinda a FreeBSD
        <firstterm>memoria virtual</firstterm>. Esto le permite a
        su computadora comportarse como si tuviera m&aacute;s
        memoria de la que realmente tiene. Cuando a FreeBSD se le
        agota la memoria mueve algunos de los datos que no est&aacute;n
        siendo utilizandos en ese momento al espacio de intercambio,
        y los mueve de regreso (moviendo alguna otra cosa) cuando
        los necesita.</para>

      <para>Algunas particiones tienen ciertas representaciones
        asociadas con ellas.</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Partici&oacute;n</entry>

	      <entry>Representaci&oacute;n</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Normalmente contiene el sistema de archivos ra&iacute;z</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Normalmente contiene el espacio de intercambio (swap)</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

              <entry>Normalmente el mismo tama&ntilde;o de la porci&oacute;n
                (slice) que lo encierra. Esto le permite a utilidades que
                necesitan trabajar en la porci&oacute;n entera (por ejemplo,
                un explorador de bloques da&ntilde;ados) trabajar en
                la partici&oacute;n <literal>c</literal>. Usted normalmente no
                debe crear un sistema de archivos en esta partici&oacute;n.</entry> 
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

              <entry>La partici&oacute;n <literal>d</literal> sol&iacute;a
                tener un significado especial asociado con ella, aunque
                ahora ya no lo tiene. Hasta este d&iacute;a, algunas
                herramientas pueden operar extra&ntilde;amente si se
                les pide trabajar en la partici&oacute;n <literal>d</literal>,
                as&iacute; que <application>sysinstall</application> no
                crear&acute; normalmente una partici&oacute;n <literal>d</literal>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Cada partici&oacute;n-que-contiene-un-sistema-de-archivos
        es almacenada en lo que FreeBSD llama una <firstterm>porci&oacute;n (slice)</firstterm>.
        Porci&oacute;n es el t&eacute;rmino de FreeBSD para lo que comunmente se
        conoce como partici&oacute;n, y de nuevo, esto se debe al
        pasado &unix; de FreeBSD. Las porciones est&aacute;n numeradas,
        empezando con 1, hasta 4.</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>particiones</primary></indexterm>
	<indexterm><primary>peligrosamente dedicadas</primary></indexterm>

      <para>Los n&uacute;meros de porci&oacute;n siguen al
        nombre de dispositivo, a los que se les antepone una
        <literal>s</literal>, iniciando en 1. As&iacute; que
        <quote>da0<emphasis>s1</emphasis></quote> es la
        primera porci&oacute;n en la primera unidad SCSI. Solo
        pueden haber cuatro porciones f&iacute;sicas en un disco,
        pero puede tener porciones l&oacute;gicas dentro de
        porciones f&iacute;sicas del tipo apropiado. Estas
        porciones extendidas son numeradas iniciando con 5,
        as&iacute; que <quote>ad0<emphasis>s5</emphasis></quote>
        es la primera porci&oacute;n extendida en el primer
        disco IDE. Estos dispositivos son utilizados por
        sistemas de archivos que esperan ocupar una porci&oacute;n.</para>

      <para>Prociones, unidades f&iacute;sicas <quote>peligrosamente
        dedicadas</quote>, y otras unidades contienen <firstterm>particiones</firstterm>,
        las cuales son representadas como letras desde <literal>a</literal>
        hasta <literal>h</literal>. Esta letra es agregada al nombre
        del dispositivo, as&iacute; que
        <quote>da0<emphasis>a</emphasis></quote> es la partici&oacute;n
        a en la primera unidad da, la cual est&aacute;
        <quote>peligrosamente dedicada</quote>.
        <quote>ad1s3<emphasis>e</emphasis></quote> es la quinta
        partici&oacute;n en la tercera porci&oacute;n de la segunda
        unidad de disco IDE.</para>
        
      <para>Finalmente, cada disco en el sistema es identificado.
        El nombre de disco inicia con un c&oacute;digo que indica
        el tipo de disco, luego un n&uacute;mero, indicando que disco
        es. A diferencia de las porciones, la numeraci&oacute;n de
        discos inicia en 0. Los c&oacute;digos comunes que usted
        ver&aacute; est&aacute;n listados en	
	<xref linkend="basics-dev-codes">.</para>

      <para>Cuando se refiere a una partici&oacute;n, FreeBSD requiere que
        que tambi&eacute;n se nombre la porci&oacute;n y el disco que
        contiene la partici&oacute;n, y al referirse a una porci&oacute;n
        tambi&eacute;n debe referirse al nombre del disco. Haga esto
        listando el nombre de disco, <literal>s</literal> (slice), el n&uacute;mero
        de porci&oacute;n y por &uacute;ltimo la letra de la partici&oacute;n.
        Ejemplos se muestran en
	<xref linkend="basics-disk-slice-part">.</para>

      <para><xref linkend="basics-concept-disk-model"> muestra un modelo
        conceptual del esquema de un disco que debe ayudar a aclarar las
        cosas.</para>

      <para>Para poder instalar FreeBSD debe primero configurar las
        porciones del disco, luego crear particiones dentro de la
        porci&oacute;n que utilizar&aacute; para FreeBSD y luego crear
        un sistema de archivos (o espacio de intercambio, swap) en
        cada partici&oacute;n y decidir donde se van a montar esos
        sistemas de archivos.</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>C&oacute;digos de dispositivos de disco</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>C&oacute;digo</entry>
	    
	      <entry>Significado</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>Disco ATAPI (IDE)</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>
	      
	      <entry>Disco de acceso directo SCSI</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>acd</devicename></entry>
	      
	      <entry>CDROM ATAPI (IDE)</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>cd</devicename></entry>
	      
	      <entry>CDROM SCSI</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>fd</devicename></entry>
	      
	      <entry>Disco flexible</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      
      <example id="basics-disk-slice-part">
	<title>Muestra de nombres de disco, porci&oacute;n y partici&oacute;n</title>
	
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Nombre</entry>
		
		<entry>Significado</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
                <entry>La primera partici&oacute;n (<literal>a</literal>) en
                  la primera porci&oacute;n (<literal>s1</literal>) en el
                  primer disco IDE (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		
                <entry>La quinta partici&oacute;n (<literal>e</literal>) en
                  la segunda porci&oacute;n (<literal>s2</literal>) en el
                  segundo disco SCSI (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>Modelo conceptual de un disco</title>

        <para>Este diagrama muestra como ve FreeBSD el primer disco IDE
          en el sistema. Se asume que el disco es de 4&nbsp;GB de tama&ntilde;o,
          y contiene dos porciones de 2&nbsp;GB (particiones &ms-dos;). La
          primera porci&oacute;n contiene un disco &ms-dos;, <devicename>C:</devicename>,
          y la segunda porci&oacute;n contiene una instalaci&oacute;n FreeBSD.
          Esta instalaci&oacute;n de ejemplo tiene tres particiones, y una
          partici&oacute;n swap.</para>

        <para>Cada una de las tres particiones tiene un sistema de archivos.
          La partici&oacute;n <literal>a</literal> ser&aacute; utilizada
          para el sistema de archivos ra&iacute;z, <literal>e</literal>
          para la jerarqu&iacute;a del directorio <filename>/var</filename>
          y <literal>f</literal> para la jerarqu&iacute;a del directorio
          <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>
 
          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     >  Primera porci&oacute;n, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partici&oacute;n a, montada como /      |
|                 |     > referida como ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partici&oacute;n b, usada como swap      |
|                 |     > referida como ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partici&oacute;n c, sin
|                 |    |  Partici&oacute;n e, usada como /var       > sistema de archivos, la 
|                 |     > referida como ad0s2e          |  porci&oacute;n completa de FreeBSD,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partici&oacute;n f, usada como /usr      |
:                 :     > referida como ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>Montando y desmontando sistemas de archivos</title>

    <para>El sistema de archivos es visualizado de una
      mejor manera como un &aacute;rbol, enraizado, como
      lo est&aacute;, en <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename> y los
      otros directorios en el directorio ra&iacute;z son ramas, las
      cuales pueden tener sus propias ramas, como
      <filename>/usr/local</filename>, y as&iacute; sucesivamente.</para>

    <indexterm><primary>sistema de archivos ra&iacute;z</primary></indexterm>
    <para>Existen varias razones para albergar algunos de
      estos directorios en sistemas de archivos separados.
      <filename>/var</filename> contiene los directorios
      <filename>log/</filename>, <filename>spool/</filename> y
      varios tipos de archivos temporales, y como tal, puede
      llenarse. Agotar el espacio del sistema de archivos ra&iacute;z
      no es una buena idea, as&iacute; que dividiendo a <filename>/var</filename>
      de <filename>/</filename> es frecuentemente favorable.</para>

    <para>Otra raz&oacute;n com&uacute;n para meter ciertos &aacute;rboles
      de directorios en otros sistemas de archivos es si van a estar
      albergados en discos f&iacute;sicos separados, o si son discos
      virtuales separados, como un montaje de
      <link linkend="network-nfs">sistema de archivos de red</link>,
      o unidades de CDROM.</para>

    <sect2 id="disks-fstab">
      <title>El archivo <filename>fstab</filename></title>
      <indexterm>
	<primary>sistemas de archivos</primary>
	<secondary>montado con fstab</secondary>
      </indexterm>

      <para>Durante el <link linkend="boot">proceso de arranque</link>,
        los sistemas de archivos listados en <filename>/etc/fstab</filename>
        son montados automaticamente (a menos que est&eacute;n
        listados con la opci&oacute;n <option>noauto</option>).</para>

      <para>el archivo <filename>/etc/fstab</filename> contiene una
        lista de l&iacute;neas del siguiente formato:</para>

      <programlisting><replaceable>dispositivo</replaceable>       <replaceable>/punto-de-montaje</replaceable> <replaceable>fstype</replaceable>     <replaceable>opciones</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>dispositivo</literal></term>
	  <listitem>
            <para>Un nombre de dispositivo (el cual debe existir).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>punto-de-montaje</literal></term>
            
	  <listitem><para>Un directorio (el cual debe existir), en
              donde montar el sistema de archivos.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>fstype</literal></term>
            
          <listitem><para>El tipo de sistema de archivos para
                pasarle a &man.mount.8;. El tipo de sistema de
                archivos por omisi&oacute;n de FreeBSD es
                <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>opciones</literal></term>
            
          <listitem><para>Ya sea <option>rw</option> para sistemas
              de archivos de lectura-escritura, o <option>ro</option>
              para sistemas de archivos de solo-lectura, seguido
              de cualquier otra opci&oacute;n que sea necesaria.
              Una opci&oacute;n com&uacute;n es <option>noauto</option>
              para sistemas de archivos que no son normalmente
              montados durante la secuencia de arranque. Otras
              opciones son listadas en la p&aacute;gina de manual
              &man.mount.8;.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>dumpfreq</literal></term>
          
         <listitem><para>Esto es utilizado por &man.dump.8; para
             determinar que sistema de archivos requiere volcado. Si
             el campo no est&aacute; declarado, se asume un valor
             de cero.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Esto determina el orden en el cual los sistemas de
             archivos deben ser revisados. Los sistemas de archivos
             que deben ser saltados deben tener su <literal>passno</literal>
             en cero. El sistema de archivos ra&iacute;z (el cual
             necesita ser revisado antes que cualquier otro) debe tener
             su <literal>passno</literal> puesto a uno, y otros
             sistemas de archivos deben tener valores mayores a uno.
             Si m&aacute;s de un sistema de archivos tiene el mismo
             <literal>passno</literal> entonces &man.fsck.8; tratar&aacute;
             de revisar los sistemas de archivo en paralelo de ser
             posible.</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>Consulte la p&aacute;gina de manual de &man.fstab.5; para
        mayor informaci&oacute;n del formato del archivo
        <filename>/etc/fstab</filename> y las opciones que contiene.</para>
    </sect2>

    <sect2 id="disks-mount">
      <title>El comando <command>mount</command></title>
      <indexterm>
	<primary>sistemas de archivos</primary>
	<secondary>montaje</secondary>
      </indexterm>
        
      <para>El comando &man.mount.8; es lo que se utiliza en &uacute;ltima
        instancia para montar sistemas de archivos.</para>
        
      <para>En su forma m&aacute;s b&aacute;sica, usted usa:</para>
      <para>In its most basic form, you use:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>dispositivo</replaceable> <replaceable>punto-de-montaje</replaceable></userinput></screen>
      </informalexample>

      <para>Existen cantidad de opciones, como se mencion&oacute;
        en la  p&aacute;gina de manual &man.mount.8;, pero las
        m&aacute;s comunes son:</para>

      <variablelist>
	<title>Opciones de montaje</title>

	<varlistentry>
	  <term><option>-a</option></term>
            
	  <listitem>
            <para>Montar todos los sistemas de archivos
              listados en <filename>/etc/fstab</filename>.
              Excepto aquellos marcados como <quote>noauto</quote>,
              excluidos por la bandera <option>-t</option>, o
              aquellos que ya est&aacute;n montados.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-d</option></term>
            
	  <listitem>
            <para>Realizar todo excepto la llamada real de montaje del
              sistema. Esta opci&oacute;n es &uacute;til junto
              con la bandera <option>-v</option> para determinar
              lo que &man.mount.8; est&aacute; tratando de
              hacer en realidad.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
            <para>Forzar el montaje de un sistema de archivos
              sucio (peligroso), o forzar la revocaci&oacute;n
              de accesos de escritura cuando se cambia el estatus
              de un sistema de archivos de lectura-escritura
              a solo-lectura.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><option>-r</option></term>
            
	  <listitem>
            <para>Montar el sistema de archivos de solo-lectura.
              Esto es id&eacute;ntico a utilizar el argumento <option>ro</option>
              (<option>rdonly</option> para versiones m&aacute;s
              antiguas que &os; 5.2) en la opci&oacute;n <option>-o</option>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>Montar el sistema de archivos dado con el tipo de
              sistema de archivos dado, o montar solamente sistemas
              de archivos del tipo dado, si se proporciona la
              opci&oacute;n <option>-a</option>.</para>
              
            <para><quote>ufs</quote> es el sistema de archivos
              ra&iacute;z por omisi&oacute;n.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-u</option></term>
            
	  <listitem>
            <para>Actualizar puntos de montaje en el sistema
              de archivos.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-v</option></term>
            
	  <listitem>
	    <para>Arrojar mayor informaci&oacute;n.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-w</option></term>
            
	  <listitem>
	    <para>Montar el sistema de archivos como lectura-escritura.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
        
      <para>La opci&oacute;n <option>-o</option> toma una lista de opciones
        separada por comas, incluyendo las siguientes:</para>
        
      <variablelist>
	<varlistentry>
	  <term>nodev</term>
            
	  <listitem>
            <para>No interpretar dispositivos especiales
              en el sistema de archivos. Esto es una opci&oacute;n
              de seguridad &uacute;til.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>noexec</term>
            
	  <listitem>
              <para>No permitir la ejecuci&oacute;n de binarios
                en este sistema de archivos. Esta tambi&eacute;n
                es una opci&oacute;n de seguridad &uacute;til.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>nosuid</term>
            
	  <listitem>
            <para>No interpretar banderas setuid o setgid en el
              sistema de archivos. Esta tambi&eacute;n es una
              opci&oacute;n de seguridad &uacute;til.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>El comando <command>umount</command></title>
      <indexterm>
	<primary>sistemas de archivos</primary>
	<secondary>desmontar</secondary>
      </indexterm>
        
      <para>El comando &man.umount.8; toma, como par&aacute;metro, un
        punto de montaje, un nombre de dispositivo, o la opci&oacute;n
        <option>-a</option> o <option>-A</option>.</para>
        
      <para>Todas las formas toman <option>-f</option> para forzar
        el desmontaje, y <option>-v</option> para arrojar m&aacute;s
        informaci&oacute;n. Considerese advertido que usar <option>-f</option>
        no es una buena idea generalmente. Desmontar a la fuerza
        distemas de archivos puede congelar la computadora o da&ntilde;ar
        los datos en el sistema de archivos.</para>
        
      <para><option>-a</option> y <option>-A</option> son utilizadas
        para desmontar todos los sistemas de archivos montados,
        posiblemente modificado por el tipo de sistema de archivos
        listado despues de <option>-t</option>. De todas maneras
        <option>-A</option> no trata de desmontar el sistema de
        archivos ra&iacute;z.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Procesos</title>

    <para>FreeBSD es un sistema operativo multi-tarea. Esto significa que
      parece como si m&aacute;s de un programa estuviera corriendo al
      mismo tiempo. Cada programa corriendo en cualquier momento dado es
      llamado <firstterm>proceso</firstterm>. Cada comando que usted
      ejecuta iniciar&aacute; al menos un proceso nuevo, y hay un
      n&uacute;mero de procesos que corren todo el tiempo, manteniendo
      el sistema de manera funcional.</para>

    <para>Cada proceso es individualmente identificado por un n&uacute;mero
      llamado <firstterm>ID de proceso</firstterm>, o <firstterm>PID</firstterm>,
      y, como archivos, cada proceso tambi&eacute;n tiene un propietario
      y un grupo. La informaci&oacute;n de propietario y grupo es utilizada
      para determinar que archivos y dispositivos el proceso puede abrir,
      usando los permisos de archivo discutidos anteriormente. La
      mayor&iacute;a de los procesos tambi&eacute;n tienen un proceso
      padre. El proceso padre es el proceso que los inici&oacute;. Por
      ejemplo, si usted est&aacute; tecleando comandos en el shell, entonces
      el shell es un proceso,  y cualquier comando que usted corre tambi&eacute;n
      es un proceso. Cada proceso que usted corre de esta manera tendr&aacute;
      como proceso padre a su shell. La excepci&oacute;n a esto es un
      proceso especial llamado &man.init.8;. <command>init</command> es
      siempre el primer proceso, as&iacute; que su PID siempre es 1.
      <command>init</command> es iniciado automaticamente por el kernel
      cuando FreeBSD arranca.</para>

    <para>Dos comandos son particularmente &uacute;tiles para ver los
      procesos en el sistema, &man.ps.1; y &man.top.1;. el comando
      <command>ps</command> es utilizado para mostrar una lista
      est&aacute;tica de los procesos corriendo en ese momento, y
      puede mostrar sus PID, cuanta memoria est&aacute;n usando, la
      l&iacute;nea de comando con la que fueron iniciados, y mucho
      m&aacute;s. El comando <command>top</command> despliega todos
      los procesos que se est&aacute;n ejecutando, y actualiza la
      pantalla cada vez que transcurren un par de segundos, para
      que pueda ver lo que est&aacute; haciendo su computadora.</para>

    <para>Por omisi&oacute;n, <command>ps</command> solo le muestra los comandos
      que est&aacute;n corriendo y que son propiedad de usted. Por ejemplo:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Como puede ver en este ejemplo, la salida de &man.ps.1; est&aacute;
      organizada en un n&uacute;mero de columnas. <literal>PID</literal>
      es el ID de proceso discutido anteriormente. Los PIDs son asignados
      iniciando desde 1, hasta 99999, y dan la vuelta de regreso al
      principio cuando se terminan los n&uacute;meros. La columna
      <literal>TT</literal> muestra el tty en el que el programa est&aacute;
      corriendo, y puede ser ignorado con seguridad por el momento.
      <literal>STAT</literal> muestra el estado del programa, y de nuevo,
      puede ser ignorado con seguridad. <literal>TIME</literal> es la
      cantidad de tiempo que el programa ha estado corriendo en el
      CPU&mdash;esto no es usualmente el tiempo transcurrido desde que
      inici&oacute; el programa, ya que la mayor&iacute;a de los
      programas pasan mucho tiempo esperando que sucedan cosas antes
      de que necesiten gastar tiempo en el CPU. Finalmente,
      <literal>COMMAND</literal> es la l&iacute;nea de comando que fu&eacute;
      utilizada para ejecutar el programa.</para>

    <para>&man.ps.1; soporta un n&uacute;mero de opciones diferentes para
      cambiar la informaci&oacute;n que es desplegada. Uno de los conjuntos
      m&aacute;s &uacute;tiles es <literal>auxww</literal>. <option>a</option>
      despliega informaci&oacute;n acerca de todos los procesos
      ejecut&aacute;ndose, no solamente los suyos. <option>u</option>
      despliega el nombre de usuario del propietario del proceso, as&iacute;
      como el uso de memoria. <option>x</option> despliega informaci&oacute;n
      acerca de los procesos daemon y <option>ww</option> provoca que
      &man.ps.1; despliegue la l&iacute;nea de comando completa, en lugar
      de truncarla cuando es muy larga para caber en la pantalla.</para>

    <para>La salida de &man.top.1; es similar. Una sesi&oacute;n de ejemplo
      se ve como esta:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>La salida est&aacute; dividida en dos secciones. La cabecera (las
      primeras cinco l&iacute;neas) muestra el PID del &uacute;ltimo proceso
      en correr, la carga promedio del sistema (la cual es una medida de que
      tan ocupado est&aacute; el sistema), el uptime del sistema (tiempo
      desde el &uacute;ltimo reinicio) y la hora actual. Las otras cifras
      en la cabecera se relacionan con cuantos procesos hay en ejecuci&oacute;n
      (47 en este caso), cuanto se est&aacute; utilizando de memoria y espacio
      de intercambio (swap), y cuando tiempo el sistema est&aacute; gastando
      en diferentes estados de CPU.</para>

    <para>Abajo hay una serie de columnas conteniendo informaci&oacute;n
      similar a la salida de &man.ps.1;. De manera similar usted puede
      ver el PID, el nombre de usuario, la cantidad de tiempo de CPU
      tomada y el comando que fu&eacute; ejecutado. &man.top.1;
      tambi&eacute;n muestra por omisi&oacute;n la cantidad de espacio
      de memoria tomada por el proceso. Esto est&aacute; dividido en dos
      columnas, una para el tama&ntilde;o total y una para tama&ntilde;o
      residente&mdash;tama&ntilde;o total es cuanta memoria la aplicaci&oacute;n
      ha necesitado y el tama&ntilde;o residente es cuanto est&aacute;
      siendo utilizado realmente en ese momento. En este ejemplo puede ver
      que <application>&netscape;</application> ha requerido casi
      30&nbsp;MB de RAM, pero actualmente solo est&aacute; usando
      9&nbsp;MB.</para>

    <para>&man.top.1; automaticamente actualiza este desplegado cada
      dos segundos; esto puede cambiarse con la opci&oacute;n <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Daemons, se&ntilde;ales y matar procesos</title>

    <para>cuando usted corre un editor es f&aacute;cil controlar el editor,
      decirle que cargue archivos y dem&aacute;s. Usted puede hacer esto
      porque el editor brinda facilidades para hacerlo, y porque el editor 
      est&aacute; pegado a una <firstterm>terminal</firstterm>. Algunos
      programas no est&aacute;n dise&ntilde;ados para ser ejecutados con
      entradas continuas por parte del usuario, as&iacute; que se desconectan
      de la terminal a la primera oportunidad. Por ejemplo, un servidor
      web pasa todo el d&iacute;a respondiendo peticiones web, normalmente
      no necesita ninguna entrada de su parte. Los programas que transportan
      correo electr&oacute;nico de un sitio a otro son otro ejemplo de
      esta clase de aplicaci&oacute;n.</para>

    <para>Llamamos a estos programas <firstterm>daemons</firstterm>.  Daemons
      eran personajes de la mitolog&iacute;a griega; no eran ni buenos ni
      malos, eran peque&ntilde;os esp&iacute;ritus sirvientes que, en gran
      medida, hicieron cosas &uacute;tiles por la humanidad. Muy parecido
      a como los servidores web y servidores de correo de hoy hacen cosas
      &uacute;tiles. Este es el por qu&eacute; la mascota BSD ha sido, desde
      hace mucho tiempo, el demonio de imagen alegre con tenis y un tridente.</para>

    <para>Existe un acuerdo de nombrar programas que normalmente corren
      como daemons con una <quote>d</quote> al final. <application>BIND</application>
      es el daemon de nombres de internet de  Berkeley (y el programa
      que en realidad ejecuta es llamado <command>named</command>), el
      programa servidor de web <application>Apache</application> es
      llamado <command>httpd</command>, el daemon de spool de impresora de
      l&iacute;nea es <command>lpd</command> y as&iacute; sucesivamente.
      Este es un acuerdo, no una regla pura y dura; por ejemplo, el
      daemon principal de correo para la aplicaci&oacute;n <application>Sendmail</application>
      es llamdo <command>sendmail</command>, y no <command>maild</command>,
      como podr&iacute;a imaginarse.</para>

    <para>Algunas veces necesitar&aacute; comunicarse con un proceso daemon.
      Estas comunicaciones son llamadas <firstterm>se&ntilde;ales</firstterm>,
      y se puede comunicar con un daemon (o con cualquier otro proceso
      ejecut&aacute;ndose) mand&aacute;ndole una se&ntilde;al. Existe un
      n&uacute;mero de se&ntilde;ales diferentes que puede mandar&mdash;algunas
      de ellas tienen un significado especial, otras son interpretadas por
      la aplicaci&oacute;n, y la documentaci&oacute;n de la aplicaci&oacute;n
      le dir&aacute; como interpreta la se&ntilde;al esa aplicaci&oacute;n.
      Solo puede enviar una se&ntilde;al a un proceso del que usted es el
      propietario. Si manda una se&ntilde;al a un proceso de alguien m&aacute;s
      con &man.kill.1; o &man.kill.2; el permiso ser&aacute; denegado.
      La excepci&oacute;n a esto es el usuario <username>root</username>,
      que puede mandar se&ntilde;ales a los procesos de todos.</para>

    <para>FreeBSD tambi&eacute;n enviar&aacute; se&ntilde;ales de
      aplicaci&oacute;n en algunos casos. Si una aplicaci&oacute;n
      est&aacute; mal escrita, y trata de accesar memoria que no se
      supone que accese, FreeBSD manda al proceso la se&ntilde;al
      <firstterm>Violaci&oacute;n de segmento</firstterm>
      (<literal>SIGSEGV</literal>). Si una aplicaci&oacute;n ha utilizado
      la llamada de sistema &man.alarm.3; para ser alertada despues
      de que un periodo de tiempo haya transcurrido entonces se le
      mandar&aacute; la se&ntilde;al de alarma (<literal>SIGALRM</literal>),
      y as&iacute; sucesivamente.</para>

    <para>Dos se&ntilde;ales pueden usarse para detener un proceso,
      <literal>SIGTERM</literal> y <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> es la manera amable de matar un proceso;
      el proceso puede <emphasis>recibir</emphasis> la se&ntilde;al,
      darse cuenta que usted quiere que se apague, cerrar cualquier
      archivo de log que pueda tener abierto y generalmente terminar
      cualquier cosas que est&eacute; realizando en ese momento antes
      de apagarse. En algunos casos un proceso puede incluso ignorar
      a <literal>SIGTERM</literal> si se encuentra en medio de una
      tarea que no puede ser interrumpida.</para> 

    <para><literal>SIGKILL</literal> no puede ser ignorada por un proceso.
      Esta es la se&ntilde;al <quote>No me importa lo que est&aacute;s
      haciendo, detente ahora mismo</quote>. Si manda un <literal>SIGKILL</literal>
      a un proceso, entonces FreeBSD detendr&aacute; ese proceso ah&iacute;
      y en ese momento<footnote>
      <para>No del todo cierto&mdash;existen algunas cosas que no pueden
        ser interrumpidas. Por ejemplo, si el proceso est&aacute; tratando
        de leer desde un archivo que est&aacute; en otra computadora de
        la red, y la otra computadora no est&aacute; disponible por
        alguna raz&oacute;n (por estar apagada, o que la red tenga un fallo),
        entonces el proceso se dice que es <quote>ininterrumpible</quote>.
        Eventualmente al proceso se le acabar&aacute; el tiempo de
        espera, tipicamente despues de dos minutos. Tan pronto como esto
        ocurra el proceso ser&aacute; terminado.</para>
      </footnote>.</para>

    <para>Las otras se&ntilde;ales que tal vez quiera utilizar son
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> y
      <literal>SIGUSR2</literal>. Estas son se&ntilde;ales de prop&oacute;sito
      general, y aplicaciones diferentes pueden hacer cosas diferentes
      cuando se les env&iacute;a.</para>

    <para>Suponga que ha cambiado su archivo de configuraci&oacute;n de su 
      servidor web&mdash;tal vez le gustar&iacute;a decirle al servidor
      web que re-lea su configuraci&oacute;n. Podr&iacute;a detener y
      reiniciar <command>httpd</command>, pero esto resultar&iacute;a en
      un per&iacute;odo breve de suspensi&oacute;n del servicio de su
      servidor web, lo cual puede ser indeseable. La mayor&iacute;a de
      los daemons est&aacute;n escritos para responder a la se&ntilde;al
      <literal>SIGHUP</literal> releyendo su archivo de configuraci&oacute;n.
      As&iacute; que en lugar de matar y reiniciar <command>httpd</command>
      le podr&iacute;a mandar la  se&ntilde;al <literal>SIGHUP</literal>.
      Debido a que no hay una manera est&aacute;ndar para responder a estas
      se&ntilde;ales, diferentes daemons tendr&aacute;n diferente comportamiento,
      as&iacute; que aseg&uacute;rese de leer la documentaci&oacute;n para
      el daemon en cuesti&oacute;n.</para>
    
    <para>Las se&ntilde;ales son enviadas utilizando el comando &man.kill.1;,
      como lo muestra este ejemplo.</para>

    <procedure>
      <title>Enviando una se&ntilde;al a un proceso</title>

      <para>Este ejemplo muestra como enviar una se&ntilde;al a
        &man.inetd.8;. El archivo de configuraci&oacute;n de
        <command>inetd</command> es
        <filename>/etc/inetd.conf</filename> e <command>inetd</command>
        re-leer&aacute; este archivo de configuraci&oacute;n cuando
        se le env&iacute;e un <literal>SIGHUP</literal>.</para>

      <step>
        <para>Encuentre el ID de proceso del proceso al que quiere
          enviarle la se&ntilde;al. Haga esto usando &man.ps.1; y
          &man.grep.1;. El comando &man.grep.1; es utilizado para buscar
          a trav&eacute;s de la salida, buscando la cadena que se
          especifique. Este comando es ejecutado como un usuario
          normal y &man.inetd.8; es ejecutado como <username>root</username>,
          as&iacute; que las opciones <option>ax</option> se le deben
          proporcionar a &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

        <para>Entonces el PID de &man.inetd.8; es 198. En algunos casos
          el comando <literal>grep inetd</literal> tambi&eacute;n
          puede salir en esta salida. Esto se debe a la manera en que
          &man.ps.1; tiene que encontrar la lista de procesos
          ejecut&aacute;ndose.</para>
      </step>

      <step>
        <para>Utilice &man.kill.1; para enviar la se&ntilde;al. Debido a que
          &man.inetd.8; est&aacute; siendo ejecutado por <username>root</username>
          usted debe usar primero &man.su.1; para volverse <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

        <para>En concordancia con la mayor&iacute;a de los comandos &unix;,
          &man.kill.1; no imprimir&aacute; ninguna salida si es exitoso.
          Si env&iacute;a una se&ntilde;al a un proceso del que no es
          el propietario entonces ver&aacute; <errorname>kill:
          <replaceable>PID</replaceable>: Operation not permitted</errorname>.
          Si usted no teclea bien el PID puede enviar la se&ntilde;al a un
          proceso distinto, lo cual puede ser malo, o, si tiene suerte,
          habr&aacute; enviado la se&ntilde;al a un proceso que no est6aacute;
          en uso actualmente, y ver&aacute; <errorname>kill:
          <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>¿Por qu&eacute; utilizar <command>/bin/kill</command>?</title>

          <para>Muchos shells brindan el comando <command>kill</command>
            como un comando incluido; esto es, el shell mandar&aacute;
            la se&ntilde;al directamente, en lugar de ejecutar
            <filename>/bin/kill</filename>. Esto puede ser muy &uacute;til,
            pero diferentes shells tienen diferentes sintaxis para
            especificar el nombre de la se&ntilde;al que env&iacute;a. En
            lugar de tratar de aprederse todas ellas, puede ser m&aacute;s
            simple solamente usar el comando
            <command>/bin/kill <replaceable>...</replaceable></command>
            directamente.</para>
	</note>
      </step>
    </procedure>

    <para>El env&iacute;o de otras se&ntilde;ales es muy similar,
      solamente sustituya <literal>TERM</literal> o <literal>KILL</literal>
      en la l&iacute;nea de comando seg&uacute;n sea necesario.</para>
         
    <important>
      <para>Matar procesos aleatorios en el sistema puede ser una mala
        idea. En particular, &man.init.8;, ID de proceso 1, es muy
        especial. Ejecutar <command>/bin/kill -s KILL 1</command> es
        una manera r&aacute;pida de apagar su sistema. <emphasis>Siempre</emphasis>
        revise doblemente los argumentos con los que ejecuta &man.kill.1;
        <emphasis>antes</emphasis> de presionar <keycap>Enter</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>l&iacute;nea de comando</primary></indexterm>

    <para>En FreeBSD, mucho del trabajo diario es realizado en una
      interfaz de l&iacute;nea de comandos llamada shell. El trabajo
      principal del shell es tomar comandos de un canal de entrada
      y ejecutarlos. Muchos shells tambi&eacute;n tienen funciones
      integradas para ayudar con las tareas diarias como manipulaci&oacute;n
      de archivos, manejo de archivos con expresiones regulares,
      edici&oacute;n de l&iacute;nea de comando, macros de comandos y
      variables de entorno.
      FreeBSD viene con un conjunto de shells, como <command>sh</command>,
      el shell Bourne y <command>tcsh</command>, el shell C mejorado.
      Hay muchos otros shells disponibles desde la colecci&oacute;n de
      ports de FreeBSD, tales como <command>zsh</command> y
      <command>bash</command>.</para>

    <para>&iquest;Qu&eacute; shell usar? es realmente una cuesti&oacute;n
      de gustos. Si es un programador de C se puede sentir m&aacute;s
      c&oacute;modo con un shell tipo C, como <command>tcsh</command>.
      Si viene del mundo Linux o si es nuevo en la interfaz de l&iacute;nea
      de comandos de &unix; puede probar con <command>bash</command>.
      El punto es que cada shell posee unas propiedades &uacute;nicas que
      pueden o no funcionar con su entorno de trabajo preferido, y que
      tiene una opci&oacute;n sobre el shell a usar.</para>

    <para>Una de las propiedades comunes de un shell es que completa los
      nombres de archivo. Dada la introducci&oacute;n de las primeras letras
      de un comando o del nombre de un archivo, se puede hacer que el shell
      complete automaticamente el resto del comando o nombre de archivo
      pulsando la tecla <keycap>Tab</keycap> en el teclado.
      Aqu&iacute; est&aacute; un ejemplo. Suponga que tiene dos archivos
      llamados <filename>foobar</filename> y <filename>foo.bar</filename>.
      Usted quiere borrar <filename>foo.bar</filename>. Lo que
      habr&iacute;a que teclear es:
      <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>El shell imprimir&iacute;a <command>rm
      foo[BEEP].bar</command>.</para>

    <para>El [BEEP] es la campana de la consola, la cual es el shell
      dici&eacute;ndome que no pudo completar totalmente el nombre
      de archivo porque hay m&aacute;s de una coincidencia.
      Tanto <filename>foobar</filename> como <filename>foo.bar</filename>
      inician con <literal>fo</literal>, pero solo se pudo completar
      hasta <literal>foo</literal>. Si se teclea <literal>.</literal>,
      y de nuevo <keycap>Tab</keycap>, entonces el shell es capaz de
      introducir el resto del nombre de archivo por usted.</para>
    <indexterm><primary>variables de entorno</primary></indexterm>

    <para>Otra funci&oacute;n del shell son las variables de entorno.
      Las variables de entorno son parejas de valores clave almacenados
      en el espacio de entorno del shell. Este espacio puede ser le&iacute;do
      por cualquier programa invocado por el shell y, por lo tanto,
      contiene mucha configuraci&oacute;n de programas. Aqu&iacute; hay
      una lista de las variables de entorno m&aacute;s comunes y su
      significado:</para>
    <indexterm><primary>variables de entorno</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Descripci&oacute;n</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
            <entry>Nombre de usuario actual en el sistema.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
            <entry>Lista de directorios, separados por punto y coma, en los que
              se busca ejecutables.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
            <entry>Nombre de red de la pantalla X11 a la que conectarse,
              si est&aacute; disponible.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
            <entry>El shell actual.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
            <entry>El nombre de la terminal del usuario. Se usa para determinar
              las capacidades de la terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
            <entry>Base de datos donde encontrar los c&oacute;digos de
              escape necesarios para realizar diferentes funciones en la
              terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
            <entry>Tipo de sistema operativo. Por ejemplo, FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
            <entry>Arquitectura del CPU en el que se est&aacute; ejecutando
              el sistema.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
            <entry>El editor de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
            <entry>El paginador de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
            <entry>Lista de directorios separados por punto y coma
              en los que se busca p&aacute;ginas de manual.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Establecer una variable de entorno difiere ligeramente
      de shell a shell. Por ejemplo, en los shells al estilo C
      como <command>tcsh</command> y <command>csh</command>,
      se usar&iacute;a <command>setenv</command> para establecer
      las variables de entorno. Bajo shells Bourne como
      <command>sh</command> y <command>bash</command>, se
      usar&iacute;a <command>export</command> para establecer
      las variables de entorno actuales. Por ejemplo, para
      establecer o modificar la variable de entorno
      <envar>EDITOR</envar>, bajo <command>csh</command> o
      <command>tcsh</command> un comando como este establece
      <envar>EDITOR</envar> a
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Bajo shells Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Tambi&eacute;n se puede hacer que la mayor&iacute;a de los shells
      muestren el contenido de una variable de entorno situando el
      car&aacute;cter <literal>$</literal> delante del nombre de la variable
      desde la l&iacute;nea de comandos. Por ejemplo, <command>echo $TERM</command>
      mostrar&aacute; cualquiera que sea el valor que se le
      haya establecido a <envar>$TERM</envar>, porque el shell expande el valor
      de <envar>$TERM</envar> y se lo pasa al programa <command>echo</command>.</para>

    <para>Los shells manejan muchos caracteres especiales, llamados
      meta-caracteres, como representaciones especiales de datos. El m&aacute;s
      com&uacute;n es el caracter <literal>*</literal>, que representa
      cualquier n&uacute;mero de caracteres en un nombre de archivo. Estos
      meta-caracteres especiales se pueden usar para la expansi&oacute;n de
      nombres de archivos. Por ejemplo, teclear <command>echo *</command> es
      casi lo mismo que introducir <command>ls</command> porque el shell
      toma todos los archivos que coinciden con <command>*</command> y se
      los pone en la l&iacute;nea de comandos para que <command>echo</command>
      los vea.</para>

    <para><para>Para evitar que el shell interprete estos caracteres especiales,
      se pueden escapar del shell anteponi&eacute;ndoles un caracter
      diagonal (<literal>\</literal>). <command>echo $TERM</command> imprime
      a qu&eacute; est&aacute; configurada su terminal.
      <command>echo \$TERM</command> imprime <envar>$TERM</envar> como
      es.</para>

    <sect2 id="changing-shells">
      <title>Cambiando su shell</title>

      <para>La manera m&aacute;s f&aacute;cil de cambiar de shell es usando
        el comando <command>chsh</command>. Ejecutando <command>chsh</command>
        le colocar&aacute; dentro del editor que est&eacute; configurado en
        la variable de entorno <envar>EDITOR</envar>; no est&aacute;
        configurada, se&aacute; colocado en <command>vi</command>. Cambie
        la l&iacute;nea <quote>Shell:</quote> para que concuerde.</para>
        
      <para>Tambi&eacute;n se le puede suministrar a <command>chsh</command>
        la opci&oacute;n <option>-s</option>; &eacute;sto establecer&aacute; el
        shell por usted, sin necesidad de entrar en el editor de texto.
        Por ejemplo, si se desea cambiar el shell a <command>bash</command>,
        lo siguiente realizar&aacute; el ajuste:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Ejecutar <command>chsh</command> sin par&aacute;metros y
        editar el shell desde ah&iacute; tambi&eacute;n funciona.</para>

      <note>
        <para>El shell que se desee usar <emphasis>debe</emphasis> estar
          presente en el archivo <filename>/etc/shells</filename>.
          Si se ha instalado un shell desde la 
          <link linkend="ports">colecci&oacute;n de ports</link>, entonces
          esto ya debi&oacute; hacerse por usted. Si ha instalado
          el shell manualmente, se debe realizar el cambio.</para>
     
      <para>Por ejemplo, si se instal&oacute; manualmente <command>bash</command>
        y lo coloc&oacute; en <filename>/usr/local/bin</filename>,
        deber&iacute;a hacer:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Y entonces volver a ejecutar <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Editores de texto</title>
    <indexterm><primary>editores de texto</primary></indexterm>
    <indexterm><primary>editores</primary></indexterm>

    <para>Gran parte de la configuraci&oacute;n de FreeBSD se realiza
      modificando archivos de texto. A causa de esto, es una buena idea
      familiarizarse con un editor de texto. FreeBSD viene con unos cuantos
      como parte del sistema base y muchos m&aacute;s se encuentran
      disponibles en la colecci&oacute;n de ports.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>El editor de textos m&aacute;s sencillo y f&aacute;cil de
      aprender es uno llamado <application>ee</application>, cuyo nombre
      proviene del ingl&eacute;s "easy editor" (editor f&aacute;cil).
      Para iniciar <application>ee</application> se debe teclear en la
      l&iacute;nea de comandos
      <command>ee <replaceable>nombre-de-archivo</replaceable></command>
      donde <replaceable>nombre-de-archivo</replaceable> es el nombre
      del archivo a ser editado. Por ejemplo, para editar <filename>/etc/rc.conf</filename>,
      tecl&eacute;e <command>ee /etc/rc.conf</command>. Una vez dentro
      de <command>ee</command>, todos los comandos para manipular
      las funciones del editor est&aacute;n listadas en la parte
      superior de la pantalla. El caracter <literal>^</literal> representa
      la tecla <keycap>Ctrl</keycap> del teclado, por lo tanto
      <literal>^e</literal> se expande a la combinaci&oacute;n de teclas
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
      Para abandonar <application>ee</application>, presione la tecla
      <keycap>Esc</keycap>, elegir abandonar (leave) el editor.
      El editor preguntar&aacute; entonces si se desean conservar los
      cambios si el archivo hubiera sido modificado.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD viene tambi&eacute;n con editores de texto mucho m&aacute;s
      potentes, como <application>vi</application>, como parte del
      sistema base, mientras que otros editores, como <application>Emacs</application>
      y <application>vim</application>, son parte de la colecci&oacute;n
      de ports de FreeBSD
      (<filename role="package">editors/emacs</filename> y <filename role="package">editors/vim</filename>).
      Estos editores ofrecen mucha m&aacute;s funcionalidad y poder
      a la expensa de ser un poco m&aacute;s complicados de aprender.
      De cualquier manera si planea hacer mucho trabajo de edici&oacute;n
      de texto, aprender un editor de texto m&aacute;s poderoso
      como <application>vim</application> o <application>Emacs</application>
      le ahorrar&aacute; m&aacute;s tiempo a la larga.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Dispositivos y nodos de dispositivos</title>

    <para>Un dispositivo es un t&eacute;rmino utilizado
      mayormente para actividades relacionadas con hardware
      en un sistema, incluyendo discos, impresoras, tarjetas
      gr&aacute;ficas y teclados. Cuando FreeBSD arranca, la
      mayor&iacute;a de lo que FreeBSD despliega son dispositivos
      siendo detectados. Puede mirar a trav&eacute;s de los
      mensajes de arranque de nuevo visualizando
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Por ejemplo, <devicename>acd0</devicename> es la
      primera unidad CDROM IDE, mientras que <devicename>kbd0</devicename>
      representa el teclado.</para>

    <para>La mayor&iacute;a de estos dispositivos en un sistema
      operativo &unix; deben ser accesados a trav&eacute;s de
      archivos especiales llamados nodos de dispositivo, los
      cuales se encuentran localizados en el directorio
      <filename>/dev</filename>.</para>

    <sect2>
      <title>Creando nodos de dispositivo</title>
      <para>Cuando agregue un nuevo dispositivo a su sistema, o
        compile soporte para dispositivos adicionales, puede que
        necesite crear uno o m&aacute;s nodos de dispositivo para
        los nuevos dispositivos.</para>

      <sect3>
	<title>Script MAKEDEV</title>
        <para>En sistemas sin <literal>DEVFS</literal> (esto concierne
          a todas las versiones anteriores a FreeBSD 5.0), los
          nodos de dispositivo son creados utilizando el script
          &man.MAKEDEV.8; como se muestra abajo:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

        <para>Este ejemplo debe crear el nodo de dispositivo
          apropiado para la segunda unidad IDE instalada.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> Dispositivo de sistema de archivos (DEVice File System)</title>

        <para>El dispositivo de sistema de archivos, o <literal>DEVFS</literal>,
          brinda acceso a dispositivos del espacio de nombres del kernel en el
          espacio de nombres del sistema de archivos global.
          En lugar de tener que crear y modificar nodos de dispositivo,
          <literal>DEVFS</literal> mantiene este sistema de archivos en
          particular por usted.</para>

        <para>Vea la p&aacute;gina de manual &man.devfs.5;
          para mayor informaci&oacute;n.</para>

        <para><literal>DEVFS</literal> es utilizado por defecto en FreeBSD&nbsp;5.0 y
          posteriores.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">

    <title>Formatos binarios</title>

    <para>Para entender porque &os; utiliza el formato &man.elf.5;,
      primero debe conocer un poco acerca de los tres formatos
      de ejecutables <quote>dominantes</quote> para &unix;:</para> 

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>El formato objeto de &unix; m&aacute;s antiguo y
          <quote>cl&aacute;sico</quote>. Utiliza una cabecera
          corta y compacta con un n&uacute;mero m&aacute;gico al
          inicio que es usado frecuentemente para caracterizar el
          formato (vea &man.a.out.5; para m&aacute;s detalles).
          Contiene tres segmentos cargados: .text, .data, y .bss
          adem&aacute;s de una tabla de s&iacute;mbolos y una tabla
          de cadena.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>El formato objeto de SVR3. La cabecera ahora consiste
          de una secci&oacute;n de tabla, para que pueda tener m&aacute;s
          y no solo las secciones .text, .data, y .bss.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>El sucesor de <acronym>COFF</acronym>, presentando
          secciones m&uacute;ltiples y posibles valores de 32-bits
          o 64-bits. Una gran desventaja: <acronym>ELF</acronym>
          fu&eacute; tambi&eacute;n dise&ntilde;ado asumiendo que
          solamente existir&iacute;a una ABI por cada arquitectura
          de sistema. Esa asumci&oacute;n es en realidad bastante
          incorrecta, e incluso ni en el mundo comercial SYSV (el
          cual tiene al menos tres ABIs:  SVR4, Solaris, SCO) se
          mantiene como verdadera.</para>

        <para>FreeBSD trata de solucionar este problema de alguna
          manera brindando una utilidad para <emphasis>marcar</emphasis>
          un ejecutable <acronym>ELF</acronym> conocido con
          informaci&oacute;n acerca de con que ABI cumple. Vea la
          p&aacute;gina de manual de &man.brandelf.1; para mayor
          informaci&oacute;n.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD viene del campo <quote>cl&aacute;sico</quote> y ha
      utilizado el formato &man.a.out.5;, una tecnolog&iacute;a usada
      y probada a trav&eacute;s demuchas generaciones de liberaciones
      BSD, hasta el inicio de la rama 3.X. Aunque era posible
      construir y ejecutar binarios nativos <acronym>ELF</acronym>
      (y kernels) en un sistema FreeBSD desde alg&uacute;n tiempo
      antes de eso, FreeBSD inicialmente resisti&oacute; el
      <quote>empuj&oacute;n</quote> para cambiar a <acronym>ELF</acronym>
      como el formato por omisi&oacute;n. ¿Por qu&eacute;? bueno, cuando
      el campo Linux realiz&oacute; su dolorosa transici&oacute;n a
      <acronym>ELF</acronym>, no fu&eacute; tanto para escapar del
      formato ejecutable <filename>a.out</filename> como lo fu&eacute; de
      su mecanismo de librer&iacute;as compartidas inflexible basado en salto-tabla,
      el cual hac&iacute;a la construcci&oacute;n de librer&iacute;as
      compartidas muy dif&iacute;cil para proveedores y desarrolladores
      por igual. Ya que las herramientas <acronym>ELF</acronym>
      disponibles ofrec&iacute;an una soluci&oacute;n al problema de
      librer&iacute;as compartidas y eran vistas generalmente como
      <quote>la manera de avanzar</quote> de todas maneras, el costo
      de migraci&oacute;n fu&eacute; aceptado como necesario y se
      realiz&oacute; la transici&oacute;n. El mecanismo de
      librer&iacute;as compartidas de FreeBSD est&aacute; basado de
      manera m&aacute;s cercana al estilo de mecanismo de
      librer&iacute;as compartidas de &sunos; de Sun y, como tal, es
      muy sencillo de utilizar.</para>

    <para>Entonces, ¿por qu&eacute; existen tantos formatos diferentes?</para>

    <para>En el tenue, oscuro pasado, exist&iacute;a hardware simple.
      Este hardware simple soportaba un sistema peque&ntilde;o, simple.
      <filename>a.out</filename> era completamente adecuado para el trabajo
      de representar binarios en este sistema simple (un PDP-11). A
      medida que la gente portaba &unix; desde este sistema simple,
      retuvieron el formato <filename>a.out</filename> debido a que
      era suficiente para los primeros portes de &unix; a arquitecturas
      como 68k de Motorola, VAXen, etc.</para>

    <para>Entonces alg&uacute;n brillante ingeniero de hardware decidi&oacute;
      que si el pod&iacute;a forzar al software a realizar algunos trucos
      sucios, entonces podr&iacute;a rasurar algunas puertas del
      dise&ntilde;o y permitirle al centro de su CPU correr m&aacute;s
      rapidamente. Aunque estaba hecho para trabajar con este nuevo
      tipo de hardware (conocido estos d&iacute;as como <acronym>RISC</acronym>),
      <filename>a.out</filename> no estaba bien adaptado para este
      hardware, as&iacute; que varios formatos fueron desarrollados
      para obtener un mejor desempe&ntilde;o de este hardware que el
      limitado, simple formato <filename>a.out</filename> podr&iacute;a
      ofrecer. Cosas como <acronym>COFF</acronym>, <acronym>ECOFF</acronym>
      y algunos otros oscuros fueron inventados y sus limitaciones
      fueron exploradas antes de que las cosas parecieran decidirse en
      <acronym>ELF</acronym>.</para> 

    <para>Adem&aacute;s, el tama&ntilde;o de los programas estaban
      volviendose gigantes y los discos (y la memoria f&iacute;sica)
      eran relativamente peque&ntilde;os as&iacute; que el concepto
      de una librer&iacute;a compartida naci&oacute;. El sistema
      VM tambi&eacute;n se volvi&oacute; m&aacute;s sofisticado.
      Mientras cada uno de estos avances fu&eacute; hecho utilizando
      el formato <filename>a.out</filename>, su utilidad era reducida
      m&aacute;s y m&aacute;s con cada opci&oacute;n nueva. Adem&aacute;s,
      la gente quer&iacute;a cargar dinamicamente cosas al momento
      de ejecuci&oacute;n, o descartar partes de su programa despues
      que el c&oacute;digo de inicio se ejecutara para salvar memoria
      del n&uacute;cleo y espacio de swap. Los lenguajes se volvieron
      m&aacute;s sofisticados y la gente quer&iacute;a que el c&oacute;digo
      fuera llamado antes que main de manera autom&aacute;tica. Muchos
      hacks fueron hechos al formato <filename>a.out</filename> para
      permitir que todas estas cosas sucedieran, y basicamente
      funcionaron por un tiempo. Con el tiempo, <filename>a.out</filename>
      no estaba para manejar todos estos problemas sin incrementar
      la carga y complejidad en el c&oacute;digo. Mientras <acronym>ELF</acronym>
      resolv&iacute;a muchos de estos problemas, hubiera sido doloroso
      cambiar del sistema que basicamente funcionaba. As&iacute; que
      <acronym>ELF</acronym> tuvo que esperar hasta que fu&eacute; m&aacute;s
      doloroso permanecer con <filename>a.out</filename> que migrar a
      <acronym>ELF</acronym>.</para>

    <para>De todas maneras, al paso del tiempo, las herramientas
      de construcci&oacute;n de las que FreeBSD deriv&oacute;
      sus herramientas de construcci&oacute;n (el ensamblador y
      cargador especialmente) evolucionaron en dos &aacute;rboles
      paralelos. El &aacute;rbol FreeBSD agreg&oacute; librer&iacute;as
      compartidas y arregl&oacute; algunos errores. Las personas de
      GNU que originalmente escribieron estos programas los
      reescribieron y agregaron soporte m&aacute;s simple para
      construir compiladores cruzados (cross compilers), enchufando
      diferentes formatos a voluntad, y as&iacute; sucesivamente.
      Ya que mucha gente quer&iacute;a construir compiladores
      cruzados con FreeBSD como blanco, estaban de mala suerte
      debido a que las fuentes antiguas que FreeBSD ten&iacute;a
      para <application>as</application> y <application>ld</application>
      no estaban listas para esa tarea. La nueva cadena de herramientas
      GNU (<application>binutils</application>) soporta compilamiento
      cruzado, <acronym>ELF</acronym>, librer&iacute;as compartidas,
      extensiones C++, etc. Adem&aacute;s, muchos proveedores est&aacute;n
      liberando binarios <acronym>ELF</acronym>, y es una buena
      cosa que FreeBSD los ejecute.</para>

    <para><acronym>ELF</acronym> es m&aacute;s expresivo que <filename>a.out</filename>
      y permite m&aacute;s extensibilidad en el sistema base.
      Las herramientas <acronym>ELF</acronym> est&aacute;n mejor
      mantenidas y ofrecen soporte de compilamiento cruzado, el
      cual es importante para muchas personas.
      <acronym>ELF</acronym> puede ser un poco m&aacute;s lento que
      <filename>a.out</filename>, pero tratar de medirlo puede ser
      dif&iacute;cil. Tambi&eacute;n existen numerosos detalles
      que son diferentes entre los dos en como mapean p&aacute;ginas,
      manejan c&oacute;digo de inicio, etc. Ninguno de estos es
      muy importante, pero existen diferencias. Con el tiempo, el
      soporte para <filename>a.out</filename> ser&aacute; eliminado
      del kernel <filename>GENERIC</filename>, y eventualmente
      eliminado del kernel una vez que la necesidad de ejecutar
      programas <filename>a.out</filename> legados haya pasado.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Para m&aacute;s informaci&oacute;n</title>

    <sect2 id="basics-man">
      <title>P&aacute;ginas de manual</title>
      <indexterm><primary>p&aacute;ginas de manual</primary></indexterm>

      <para>La documentaci&oacute;n m&aacute;s exhaustiva de FreeBSD se
        encuentra en la forma de p&aacute;ginas de manual. Casi todos los
        programas del sistema vienen con un breve manual de referencia
        explicando el funcionamiento b&aacute;sico y sus diferentes argumentos.
        Estos manuales pueden ser revisados con el comando <command>man</command>.
        El uso del comando <command>man</command> es simple:</para>

      <screen>&prompt.user; <userinput>man <replaceable>comando</replaceable></userinput></screen>

      <para><literal>comando</literal> es el nombre del comando del
        que desea aprender. Por ejemplo, para saber algo acerca del
        comando <command>ls</command> escriba:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>El manual en l&iacute;nea est&aacute; dividido en secciones
        numeradas:</para>

      <orderedlist>
	<listitem>
	  <para>Comandos de usuario.</para>
	</listitem>

	<listitem>
	  <para>Llamadas al sistema y n&uacute;meros de error.</para>
	</listitem>

	<listitem>
	  <para>Funciones en las librer&iacute;as de C.</para>
	</listitem>

	<listitem>
	  <para>Controladores de dispositivo.</para>
	</listitem>

	<listitem>
	  <para>Formatos de archivo.</para>
	</listitem>

	<listitem>
	  <para>Juegos y otras diversiones.</para>
	</listitem>

	<listitem>
	  <para>Informaci&oacute;n miscelanea.</para>
	</listitem>

	<listitem>
	  <para>Comandos de mantenimiento y operaci&oacute;n del sistema.</para>
	</listitem>

	<listitem>
	  <para>Desarrolladores del Kernel.</para>
	</listitem>
      </orderedlist>

      <para>En algunos casos, el mismo tema puede aparecer en  m&aacute;s de
        una secci&oacute;n del manual en l&iacute;nea. Por ejemplo,
        existe un comando de usuario <command>chmod</command> y una
        llamada del sistema <function>chmod()</function>. En este caso,
        se le puede decir al comando <command>man</command>
        cual desea especificando la secci&oacute;n:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Esto desplegar&aacute; la p&aacute;gina de manual para
        el comando de usuario <command>chmod</command>. Las referencias
        a una secci&oacute;n concreta del manual en l&iacute;nea
        son colocadas tracicionalmente entre par&eacute;ntesis
        en la documentaci&oacute;n escrita, por lo tanto &man.chmod.1;
        se refiere al comando de usuario <command>chmod</command> y
        &man.chmod.2; se refiere a la llamada de sistema.</para>

      <para>Esto est&aacute; muy bien si se conoce el nombre del programa y
        simplemente se quiere saber como usarlo. Pero, &iquest;y si no
        puede recordar el nombre del comando? Se puede usar man para que
        realice una b&uacute;squeda mediante palabras clave en las descripciones
        de programas utilizando el argumento <option>-k</option>:</para>
        
      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Con este comando se mostrar&aacute; una lista de
        comandos que tienen la palabra clave <quote>mail</quote>
        en sus descripciones. Esto en realidad es funcionalmente
        equivalente a usar el comando <command>apropos</command>.</para>

      <para>As&iacute; que , ¿est&aacute; viendo todos esos comandos
        elegantes en <filename>/usr/bin</filename> pero no tiene
        ni la menor idea de lo que la mayor&iacute;a de ellos hace?
        simplemente haga:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>o</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>que hace exactamente lo mismo.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>Archivos de informaci&oacute;n GNU</title>
      <indexterm><primary>Fundaci&oacute;n de software libre</primary></indexterm>

      <para>FreeBSD incluye muchas aplicaciones y utilidades producidas 
        por la Fundaci&oacute;n de software libre (FSF, Free Software
        Foundation). De manera adicional a las p&aacute;ginas de manual
        estos programas vienen con documentos de hipertexto m&aacute;s
        detallados, llamados archivos <literal>info</literal>, los
        cuales pueden ser viualizados con el comando <command>info</command>
        o, si tiene instalado <application>emacs</application>, con
        el modo info de <application>emacs</application>.</para>

      <para>Para utilizar el comando &man.info.1;, simplemente
        tecl&eacute;e:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Para una breve introducci&oacute;n, tecl&eacute;e <literal>h</literal>.
        Para una referencia r&aacute;pida, tecl&eacute;e <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

