<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     $FreeBSDes: doc/es_ES.ISO8859-1/books/handbook/advanced-networking/chapter.sgml,v 1.3 2004/08/26 10:03:24 carvay Exp $
-->


<chapter id="advanced-networking">
  <title>Networking Avanzado</title>

  <para>Networking Avanzado</para>

  <sect1 id="advanced-networking-synopsis">
    <title>Resumen</title>      
 
        <para>Este cap&iacute;tulo cubre algunos de los servicios de red 
          que se usan con m&aacute;s frecuencia en sistemas 
          &unix;. Para ser m&aacute;s concretos este cap&iacute;tulo 
	  explica c&oacute;mo definir, ejecutar, probar 
          y  mantener todos los servicios de red que utiliza 
          &os;.  Se muestran adem&aacute;s ejemplos de ficheros de 
          configuraci&oacute;n que podr&aacute; utilizar para sus  
          propios quehaceres.</para> 

    <para>Despu&eacute;s de leer este cap&iacute;tulo habremos
      aprendido:</para> 

    <itemizedlist>
      <listitem>
	<para>Los conceptos b&aacute;sicos de pasarelas y 
          encaminadores (gateways y routers).</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo poner en funcionamiento dispositivos IEEE 
          802.11 y &bluetooth;.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo configurar &os; para que act&uacute;e 
          como un <quote>bridge</quote>.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo poner en funcionamiento un sistema de 
          ficheros en red con NFS.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo realizar un arranque del sistema por red en 
          m&aacute;quinas sin disco duro.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo ejecutar un servidor de informaci&oacute;n 
          en red para compartir cuentas de usuario mediante NIS.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo especificar par&aacute;metros de 
          configuraci&oacute;n autom&aacute;tica de red utilizando 
          DHCP.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo ejecutar un servidor de nombres de dominio.</para>
      </listitem>

      <listitem>
	<para>C&oacute;mo sincronizar la hora y la fecha y ejecutar
          un servidor horario utilizando el protocolo NTP.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo ejecutar un servicio de traducci&oacute;n de 
          direcciones de red.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo gestionar el d&aelig;mon 
          <application>inetd</application>.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo conectar dos computadoras a trav&eacute;s de 
          PLIP.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo habilitar IPv6 en una m&aacute;quina 
          FreeBSD.</para> 
      </listitem>

      <listitem>
	<para>C&oacute;mo configurar ATM sobre &os;&nbsp;5.X.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de leer este cap&iacute;tulo deber&iacute;a usted:</para>

    <itemizedlist>
      <listitem>
	<para>Intentar comprender los conceptos b&aacute;sicos de los 
          scripts de <filename>/etc/rc</filename>.</para> 
      </listitem>

      <listitem>
	<para>Familiarizarse con la terminolog&iacute;a b&aacute;sica 
          de redes.</para> 
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Coranth</firstname>
      	  <surname>Gryphon</surname>
	  <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>Pasarelas y Encaminadores</title>

    <indexterm><primary>routing</primary></indexterm>
    <indexterm><primary>gateway</primary></indexterm>
    <indexterm><primary>subnet</primary></indexterm>
    <para>Para que una m&aacute;quina sea capaz de encontrar otra 
      m&aacute;quina remota a trav&eacute;s de la red debe existir 
      mecanismo que describa c&oacute;mo llegar del origen al destino.  
      Este mecanismo se demonina <firstterm>routing</firstterm> o
      <firstterm>encaminamiento</firstterm>.  Una <quote>ruta</quote> 
      es un par definido de direcciones: una direcci&oacute;n de
      <quote>destino</quote> y una direcci&oacute;n  
      de <quote>pasarela</quote>.  &Eacute;ste par indica que para llegar a 
      dicho <emphasis>destino</emphasis> debe efectuarse  una 
      comunicaci&oacute;n previa con dicha  
      <emphasis>pasarela</emphasis>.  Exiten tres tipos distintos  
      de destinos: m&aacute;quinas individuales, subredes y
      <quote>por defecto</quote>.  La <quote>ruta por defecto</quote>  
      se utiliza s&oacute;lamente cuando no se puede aplicar ninguna 
      de las otras rutas existentes.  El tema de las 
      rutas por defecto se tratar&aacute; m&aacute;s adelante con 
      m&aacute;s detalle.  Tambi&eacute;n existen tres tipos de 
      pasarelas distintas: m&aacute;quinas individuales, interfaces 
      (tambi&eacute;n llamados <quote>enlaces</quote>) y direcciones 
      hardware de ethernet (direcciones MAC).</para>

    <sect2>
      <title>Ejemplo</title>

      <para>Para ilustrar diferentes aspectos del sistema de 
        encaminamiento veamos el siguiente ejemplo obtenido mediante el 
        comando <command>netstat</command>.</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
ejemplo.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.ejemplo.com link#1            UC          0        0
224              link#1             UC          0        0</screen>

      <indexterm><primary>default route</primary></indexterm>
      <para>Las primeras dos l&iacute;neas especifican la ruta por 
        defecto (la cual se comenta en la 
	<link linkend="network-routing-default">siguiente 
          secci&oacute;n</link>) y la ruta de <hostid>m&aacute;quina 
          local</hostid>.</para> 

      <indexterm><primary>loopback device</primary></indexterm>
      <para>La interfaz (columna <literal>Netif</literal>) que 
        especifica esta tabla de rutas 
	para el destino <literal>localhost</literal> se denomina 
        <devicename>lo0</devicename>, 
	y tambi&eacute;n se conoce como el dispositivo de <quote>
	loopback</quote> a de bucle de retorno. Esto viene a decir que 
        el tr&aacute;fico no debe entregarse a la red puesto que
        dicho tr&aacute;fico va destinado a la misma m&aacute;quina
        que lo origin&oacute;.</para>

      <indexterm>
        <primary>Ethernet</primary>
        <secondary>MAC address</secondary>
      </indexterm>
      <para>Lo siguiente que podemos observar son las direcciones 
        que comienzan por 
        <hostid role="mac">0:e0:</hostid>.  Son direcciones hardware de 
	Ethernet, llamadas tambi&eacute;n se direcciones MAC.  
        FreeBSD identifica autom&aacute;ticamente cualquier 
        m&aacute;quina (<hostid>test0</hostid> en el ejemplo anterior) 
        que se encuentre en la red local y 
        crea una ruta del estilo que estamos comentando, para entregar 
        el tr&aacute;fico directamente a trav&eacute;s del 
        correspondiente interfaz Ethernet, en este caso 
        <devicename>ed0</devicename>.  Existe tambi&eacute;n 
        un contador (<literal>Expire</literal>) asociado con este tipo 
        de rutas que se usa para borrarlas cuando dicho contador expira.  
        Las rutas para las m&aacute;quinas de nuestra propia red de 
        de &aacute;rea local se crean din&aacute;micamente 
        utilizando el protocolo ARP (Address Resolution Protocol o 
        Protocolo de Resoluci&oacute;n de Direcciones),  
        que se encarga de averiguar la direcci&oacute;n MAC que se 
        corresponde con la direcci&oacute;n IP de la m&aacute;quina 
        destino.</para>

      <indexterm><primary>subnet</primary></indexterm>
      <para>FreeBSD tamb&iacute;en utiliza rutas de subred para 
        direccionar la subred local (<hostid 
	  role="ipaddr">10.20.30.255</hostid> es la direcci&oacute;n 
        de broadcast para la subred 
	 <hostid role="ipaddr">10.20.30</hostid>, y 
	  <hostid role="domainname">ejemplo.com</hostid> es el nombre de 
        dominio asociado con dicha subred.)     
        La notaci&oacute;n <literal>link#1</literal> se refiere a la 
        primera tarjeta Ethernet de la m&aacute;quina.   
        En este tipo de redes no se especifica ning&uacute;n interfaz 
        en el campo de <literal>Netif</literal>.</para> 

      <para>Las rutas de subredes aparecen cuando se asigna una 
        direcci&oacute;n IP a una interfaz, utilizando una 
        m&aacute;scara de red.  Tambi&eacute;n se pueden aprender  
        din&aacute;micamente utilizando demonios de encaminamiento,
        como <application>routed</application>.  Por &uacute;ltimo estas  
        rutas pueden crearse manualmente de forma expl&iacute;cita;   
         es lo que se conoce con el nombre de rutas est&aacute;ticas.</para>

      <para>La l&iacute;nea de <literal>host1</literal> se refiere a 
        nuestra m&aacute;quina, que el sistema identifica por la 
        correspondiente direcci&oacute;n Ethernet de la tarjeta de red.  
        FreeBSD sabe que debe utilizar la interfaz de loopback
        (<devicename>lo0</devicename>) en vez de enviar los paquetes a  
        a trav&eacute;s de red.</para>

      <para>Las dos l&iacute;neas que comienzan por 
        <literal>host2</literal> son ejemplos del uso de alias de 
        &man.ifconfig.8; alias (consultar la secci&oacute;n sobre 
        Ethernet para averiguar por qu&eacute; nos podr&iacute;a 
        interesar hacer esto.)  El s&iacute;mbolo 
        <literal>=&gt;</literal> despu&eacute;s de la interfaz 
	<devicename>lo0</devicename> especifica que no s&oacute;lo 
        estamos utilizando la interfaz de loopback, si no que 
        adem&aacute;s especifica que se trata de un alias.  Estas rutas 
        s&oacute;lo aparecen en las m&aacute;quinas que implementan el 
        alias, el resto de las m&aacute;quinas de la subred local 
        solamente poseer&aacute;n una l&iacute;nea 
	<literal>link#1</literal> para dichas rutas.</para>

      <para>La &uacute;ltima l&iacute;nea (destino de subred <hostid
          role="ipaddr">224</hostid>) trata sobre encaminamiento 
        multicast, que cubriremos en otra secci&oacute;n.</para>

      <para>Finalmente, se pueden observar varios atributos 
        relacionados con las rutas en la columna de 
        <literal>Flags</literal>. A continuaci&oacute;n se muestra una 
        peque&ntilde;a tabla con el significado de algunos de esos  
        de los atributos o <quote>flags</quote>.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Up: La ruta est&aacute; activa.</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Host: El destino de la ruta es una &uacute;nica 
                m&aacute;quina.</entry> 
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Gateway: Env&iacute;a cualquier cosa para &eacute;ste 
                destino a trav&eacute;s de la pasarela especificada, 
                la cual decidir&aacute; c&oacute;mo encaminar el paquete 
                hasta que eventualmente se alcance el destino.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Static: Esta ruta se configur&oacute; 
                manualmente, y no se ha generado de forma 
                autom&aacute;tica por el sistema.</entry> 
	    </row>

	    <row>
	      <entry>C</entry> 
	      <entry>Clone: Genera una nueva ruta para la 
                m&aacute;quina a la que nos queremos conectar 
                bas&aacute;ndose en la ruta actual.  Este tipo de ruta se 
                utiliza normalmente en redes locales.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>WasCloned: Indica una ruta que se auto-configur&oacute; 
                bas&aacute;ndose en una ruta de red de &aacute;rea local con 
                etiqueta Clone.</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Link: Esta ruta pos&eacute;e referencias a hardware de 
	        Ethernet.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Rutas por Defecto</title>

      <indexterm><primary>default route</primary></indexterm>
      <para>Cuando el sistema local necesita realizar una conexi&oacute;n con 
        una m&aacute;quina remota se examina la tabla de rutas para determinar 
	si se conoce alg&uacute;n camino para llegar al destino.  
        Si la m&aacute;quina remota pertenece a una subred que sabemos 
        c&oacute;mo alcanzar (rutas clonadas) entonces el sistema comprueba si 
	se puede conectar utilizando dicho camino.</para>

      <para>Si todos los caminos conocidos fallan al sistema le queda una 
         &uacute;nica opci&oacute;n: la <quote>ruta por defecto</quote>.  
         Esta ruta est&aacute; constitu&iacute;da por un tipo especial de 
         pasarela (normalmente el &uacute;nico encaminador presente en la red 
         &aacute;rea local) y siempre pos&eacute;e el <quote>flag</quote> 
         <literal>c</literal> en el campo de <quote>flags</quote>.   
	 En una LAN, la pasarela es la m&aacute;quina que pos&eacute;e 
         conectividad con el resto de las redes (sea a trav&eacute;s de un 
         enlace PPP, DSL, cable modem, T1 u otra interfaz de red.)</para>

      <para>Si se configura la ruta por defecto en una m&aacute;quina que 
        est&aacute; actuando como pasarela hacia el mundo exterior 
        la ruta por defecto ser&aacute; el encaminador que se encuentre en 
        posesi&oacute;n del proveedor de servicios de internet (ISP).</para>

      <para>Vamos a examinar un ejemplo que utiliza rutas por defecto.  
        A continuaci&oacute;n se muestra una configuraci&oacute;n bastante 
        com&uacute;n:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
      </literallayout>
	</textobject>
      </mediaobject>

      <para>Las m&aacute;quinas <hostid>Local1</hostid> y
	<hostid>Local2</hostid> se encuentran en nuestro sitio u
        organizaci&oacute;n.  <hostid>Local1</hostid> se conecta con un ISP 
        a trav&eacute;s de una conexi&oacute;n de modem PPP.  
        El servidor PPP del ISP se conecta a trav&eacute;s de una red de 
        &aacute;rea local a otra pasarela utilizando una interfaz 
        externa.</para>

      <para>Las rutas por defecto para cada una de las m&aacute;quinas son 
        las siguientes:</para> 

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>
	      <entry>Default Gateway</entry>
	      <entry>Interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Una pregunta bastante frecuente es <quote>&iquest;Por 
         qu&eacute; (o c&oacute;mo) hacer que la m&aacute;quina 
 	 <hostid>T1-GW</hostid> sea el encaminador por defecto para 
	<hostid>Local1</hostid> en vez de que sea el servidor del ISP 
          al cual se est&aacute; conectando?</quote>.</para> 

      <para>Recordemos que, como la interfaz PPP est&aacute; utilizando una 
        direcci&oacute;n de la red local del ISP en nuestro lado de la  
        las rutas para cualquier otra m&aacute;quina en la red local del  
        proveedor se generar&aacute;n de forma autom&aacute;tica. De este 
        ya sabemos el modo de alcanzar la m&aacute;quina 
        <hostid>T1-GW</hostid>, de tal forma que no se necesita un paso 
        intermedio para enviar tr&aacute;fico al servidor del ISP.</para>

      <para>Es frecuente utilizar la direcci&oacute;n <hostid
	  role="ipaddr">X.X.X.1</hostid> como la direcci&oacute;n de 
        la pasarela en la red local.  Siguiendo con el ejemplo anterior, si 
        nuestro espacio de direccionamiento local fuera la clase C  
        <hostid role="ipaddr">10.20.30</hostid> y nuestro ISP estuviera 
	utilizando <hostid role="ipaddr">10.9.9</hostid> las rutas por 
        defecto ser&iacute;an:</para> 

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Host</entry>
	      <entry>Default Route</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>
	      <entry>Local1 (10.20.30.1)</entry>
	    </row>
	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>
	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Se puede especificar f&aacute;cilmente la entrada de la
        ruta por defecto utilizando el fichero 
        <filename>/etc/rc.conf</filename>.  En nuestro ejemplo 
        en la m&aacute;quina <hostid>Local2</hostid>, se a&ntilde;adi&oacute;   
        la siguiente l&iacute;nea en dicho fichero:</para> 

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Tambi&eacute;n se puede hacer directamente desde la l&iacute;nea 
        de comandos mediante &man.route.8;:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Para obtener m&aacute;s informaci&oacute;n sobre la 
        manipulaci&oacute;n de tablas de rutas se ruega consultar 
         la p&aacute;gina de manual &man.route.8;.</para>
    </sect2>

    <sect2>
      <title>M&aacute;quinas con Doble Pertenencia (Dual Homed Hosts)</title>
      <indexterm><primary>dual homed hosts</primary></indexterm> 
      <para>Existe otro tipo de configuraci&oacute;n que debemos describir 
        y que se produce cuando una m&aacute;quina se sit&uacute;a en dos 
        redes distintas al mismo tiempo.  T&eacute;cnicamente hablando 
        cualquier m&aacute;quina que act&uacute;a como pasarela (en el 
        caso anterior utilizando un enlace de PPP) pertenece al tipo 
        de m&aacute;quinas con doble pertenencia, pero normalmente el 
        t&eacute;rmino s&oacute;lo se aplica para describir m&aacute;quinas 
        que se encuentran directamente conectadas con dos redes de &aacute;rea 
	local.</para>

      <para>En un caso la m&aacute;quina pos&eacute;e dos tarjetas de red 
        Ethernet, cada una de ellas con una direcci&oacute;n de red
        independiente.  En otro caso la m&aacute;quina puede tener 
        s&oacute;lo una tarjeta de red, pero utilizar <quote>
	aliasing</quote> (&man.ifconfig.8;).  El primer caso se utiliza cuando 
        se necesita usar dos redes Ethernet al mismo tiempo mientras que el 
	segundo caso se utiliza cuando se dispone de un &uacute;nico segmento  
        de red f&iacute;sico pero se han definido dos redes l&oacute;gicas 
        distintas</para>

      <para>En cualquier caso la tabla de rutas se construye de tal forma 
        que cada subred sepa que la m&aacute;quina es la pasarela definida 
        definida (<quote>inbound route</quote>) para la otra subred.  
	&Eacute;sta configuraci&oacute;n en la que la m&aacute;quina 
        act&uacute;a como encaminador entre las dos subredes se usa a menudo 
        cuando queremos implementar filtrado de paquetes o cortafuegos 
	seguridad en un sentido o en ambos.</para>

      <para>Si queremos que dicha m&aacute;quina encamine paquetes entre las 
        dos interfaces es necesario decirle a FreeBSD que active dicha 
        funcionalidad.  En la siguiente secci&oacute;n se explica c&oacute;mo 
        hacerlo.</para> 
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Construcci&oacute;n de un Encaminador</title>

      <indexterm><primary>router</primary></indexterm>

      <para>Un encaminador de red, tambi&eacute;n llamado pasarela o
        <quote>router</quote>, es simplemente un sistema que reenv&iacute;a 
	paquetes desde un interfaz hacia otro interfaz.  Los est&aacute;ndares 
        Internet y el sentido com&uacute;n aplicado a la ingenier&iacute;a de 
        redes impiden que FreeBSD incluya por defecto &eacute;sta 
	caracter&iacute;stica. Se puede activar cambiando a 
        <literal>YES</literal> el valor de la siguiente variable en el fichero 
        &man.rc.conf.5;:</para> 

      <programlisting>gateway_enable=YES          # Set to YES if this host will be a gateway</programlisting>

      <para>Esta opci&oacute;n modificar&aacute; la variable de 
        &man.sysctl.8; <varname>net.inet.ip.forwarding</varname> al valor 
	<literal>1</literal>.  Si en alg&uacute;n momento se necesita
        detener el encaminador de forma temporal basta con asignar a dicha 
        variable el valor <literal>0</literal>. Consulte &man.sysctl.8; para 
        m&aacute;s detalles.</para> 

      <para>Nuestro reci&eacute;n activado encaminador necesita rutas para 
        saber a d&oacute;nde debe enviar el tr&aacute;fico recibido.  
        Si nuestra red es &ntilde;a se pueden definir rutas est&aacute;ticas. 
        FreeBSD incluye por defecto el d&aelig;mon de encaminamiento BSD, 
        &man.routed.8;, que admite RIP (versi&oacute;n 1 y versi&oacute;n 2) 
	e IRDP.  El paquete <filename role="package">net/zebra</filename> le 
	permitir&aacute; usar otros protocolos de encaminamiento 
	din&aacute;mico como BGP v4, OSPF v2 y muchos otros.  
        En caso de necesitar caracter&iacute;sticas avanzadas de 
	gesti&oacute;n puede usted recurrir a productos comerciales como 
        <application>&gated;</application>.</para> 

<indexterm><primary>BGP</primary></indexterm>
<indexterm><primary>RIP</primary></indexterm>
<indexterm><primary>OSPF</primary></indexterm>

      <para>Incluso cuando FreeBSD se configura del modo descrito no se 
        cumple completamente con los est&aacute;ndares de Internet 
        respecto a los encaminadores de red.  Bastar&aacute; no obstante 
	para poder usarse.</para>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Al</firstname>
	    <surname>Hoang</surname>
	    <contrib>Escrito por</contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <!-- Feb 2004 -->
      <title>Configuraci&oacute;n de Rutas Est&aacute;ticas</title>

      <sect3>
	<title>Configuraci&oacute;n Manual</title>

	<para>Vamos a suponer que tenemos la siguiente topolog&iacute;a de 
	  red:</para>

	<literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Router por defecto para Internet
      |
      |Interfaz xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (pasarela FreeBSD)
   +------+
      | Interfaz xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Red Interna 1       | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Red Interna 2
	</literallayout>

	<para>En este escenario <hostid>RouterA</hostid> es nuestra 
          m&aacute;quina &os; que act&uacute;a como pasarela para acceder al 
          resto de internet.  Tiene una ruta por defecto que apunta a   
	  <hostid role="ipaddr">10.0.0.1</hostid> que le permite conectarse 
          con el mundo exterior.  Vamos a suponer tambi&eacute;n que 
          <hostid>RouterB</hostid> se encuentra configurado de forma adecuada 
          que sabe c&oacute;mo llegar a cualquier sitio que necesite.    
          Esto es sencillo viendo nuestra topolog&iacute;a de red, basta 
          con a&ntilde;adir una ruta por defecto en la m&aacute;quina
          <hostid>RouterB</hostid> utilizando 
          <hostid role="ipaddr">192.168.1.1</hostid> como encaminador.</para>

	<para>Si observamos la tabla de rutas de
	  <hostid>RouterA</hostid> veremos algo como lo siguiente:</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Con la tabla de rutas actual <hostid>RouterA</hostid> 
	  no es capaz de alcanzar la red interna 2.  Esto es as&iacute; 
          porque no posee ninguna ruta para la red 
          <hostid  role="ipaddr">192.168.2.0/24</hostid>.  Una forma de 
          mitigar esto es a&ntilde;adir de forma manual la ruta que falta.  El 
          siguiente comando a&ntilde;ade la red interna 2 a la tabla  de rutas 
          de la m&aacute;quina <hostid>RouterA</hostid> 
          utilizando <hostid 
	  role="ipaddr">192.168.1.2</hostid> como siguiente salto:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Ahora <hostid>RouterA</hostid> puede alcanzar cualquier
          m&aacute;quina en la red  
	  <hostid role="ipaddr">192.168.2.0/24</hostid>.</para>	 
      </sect3>

      <sect3>
	<title>C&oacute;mo Hacer la Configuraci&oacute;n Persistente</title>

	<para>El ejemplo anterior es perfecto en tanto que resuelve el 
          problema de encaminamiento entre redes pero existe un problema.  
          La informaci&oacute;n de encaminamiento desaparecer&aacute; si se 
          reinicia la m&aacute;quina.  La forma de evitarlo es 
          a&ntilde;adir las rutas est&aacute;ticas a 
          <filename>/etc/rc.conf</filename>:</para> 

	<programlisting># A&ntilde;ade la red interna 2 como una ruta est&aacute;tica
static_routes="redinterna2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>
 
	<para>La variable de configuraci&oacute;n
          <literal>static_routes</literal> es una lista de cadenas
          separadas por espacios.  Cada cadena identifica un nombre para la 
          ruta que se desea definir.  En el ejemplo anterior s&oacute;lamente 
          se dispone de una cadena dentro de la variable 
	  <literal>static_routes</literal>.  
          Esta cadena es <replaceable>redinterna2</replaceable>.  A 
          continuaci&oacute;n se a&ntilde;ade otra variable de 
          configuraci&oacute;n denominada 
          <literal>route_<replaceable>redinterna2</replaceable></literal> 
	  donde se escriben todos los par&aacute;metros de 
	  configuraci&oacute;n que normalmente utilizar&iacute;amos 
          normalmente utilizar&iacute;amos con &man.route.8;.  
          En el ejemplo que estamos comentando se utilizar&iacute;a el 
          siguiente comando:</para> 

	  <screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen> 

	  <para>De tal forma que la variable deber&iacute;a contener
          <literal>"-net 192.168.2.0/24 192.168.1.2"</literal>.</para>
        

	<para>Como ya se ha comentado anteriormente podemos especificar 
	  m&aacute;s de una cadena en la variable 
	  <literal>static_routes</literal>.  Esto nos permite crear varias 
          rutas est&aacute;ticas. Las siguientes l&iacute;nas muestran 
          un ejemplo donde se a&ntilde;aden rutas est&aacute;ticas para las 
          redes <hostid role="ipaddr">192.168.0.0/24</hostid> 
          y <hostid role="ipaddr">192.168.1.0/24</hostid> en un 
          <quote>router</quote>imaginario:</para> 

        <programlisting>static_routes="red1 red2"
route_red1="-net 192.168.0.0/24 192.168.0.1"
route_red2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Propagaci&oacute;n del Encaminamiento</title>
      <indexterm><primary>routing propagation</primary></indexterm>
      <para>Ya hemos comentado c&oacute;mo se definen las rutas para 
        el mundo exterior pero no hemos comentado nada sobre c&oacute;mo 
        haremos que el mundo exterior nos encuentre a nosotros.</para>

      <para>Tambi&eacute;n hemos aprendido que las tablas de rutas se
        pueden constru&iacute;r de tal forma que un grupo de tr&aacute;fico 
        (perteneciente a un espacio de direcciones determinado) se 
        reenv&iacute;e a una m&aacute;quina espec&iacute;fica de la red, 
        que se encargar&aacute; de reenviar los paquetes hacia adentro.</para>

      <para>Cuando se obtiene un espacio de direcciones para la 
        organizaci&oacute;n el proveedor de servicios modifica sus tablas de  
        rutas para que todo el tr&aacute;fico para nuestra subred se encamine 
        a trav&eacute;s del enlace PPP hasta alcanzarnos.  
        Pero &iquest;c&oacute;mo conocen las organizaciones dispersas 
        a trav&eacute;s del pa&iacute;s que deben enviar los paquetes 
        dirigidos a nosotros hacia nuestro ISP?</para>

      <para>Existe un sistema (muy similar al sistema de nombres de
        dominio, DNS) que se encarga de controlar todos los espacios de 
        direcciones que se encuentran actualmente repartidos y que 
        adem&aacute;s define sus puntos de conexi&oacute;n con el  
        <quote>backbone</quote> de internet.  El <quote>backbone</quote> 
	est&aacute; formado por las principales l&iacute;neas de 
        de comunicacion que se encargan de transportar el tr&aacute;fico de 
        internet a trav&eacute;s del pa&iacute;s y del mundo entero.  
	Cada m&aacute;quina del <quote>backbone</quote> dispone de una copia 
        de un conjunto maestro de tablas de rutas gracias a las cuales pueden 
        dirigir el tr&aacute;fico para una red particular hacia una 
        determinada red de transporte de dicho <quote>backbone</quote>.  
	Una vez en la red de transporte adecuada el tr&aacute;fico se encamina 
        a trav&eacute;s de un n&uacute;mero indeterminado de redes de 
	proveedores de servicio hasta que se alcanza la red de destino 
	final.</para>
 
      <para>Una de las tareas que debe realizar el proveedor de servicio 
        servicio consiste en anunciarse a las organizaciones del
        consiste en anunciarse a las organizaciones del 
	<quote>backbone</quote> como el punto de conexi&oacute;n principal   
        (y por tanto como el camino de entrada) para alcanzar las redes de 
	sus clientes.  Este proceso se denomina propagaci&oacute;n de 
	rutas.</para>

    </sect2>

    <sect2>
      <title>Depuraci&oacute;n de Problemas</title>
      <indexterm>
        <primary><command>traceroute</command></primary>
      </indexterm>
      <para>En algunas ocasiones surgen problemas con la propagaci&oacute;n 
        de las rutas y algunas organizaciones son incapaces de conectarse con 
        nuestra subred. Quiz&aacute; el comando m&aacute;s &uacute;til para 
        averiguar d&oacute;nde se est&aacute; interrumpiendo el sistema  
        de encaminamiento sea &man.traceroute.8;.  Se puede usar 
        tambi&eacute;n cuando somos nosotros los que no podemos alcanzar 
        alguna red externa (por ejemplo cuando &man.ping.8; falla).</para>

      <para>&man.traceroute.8; se ejecuta pasandole como par&aacute;metro el 
        nombre de la m&aacute;quina remota a la que nos queremos 
        conectar.  El comando muestra por pantalla l&aacute;s m&aacute;quinas 
        que act&uacute;an de pasarela a lo largo del camino.  El proceso  
        termina bien porque se alcanza el destino o bien porque alg&uacute;n 
        <quote>router</quote> intermedio no puede conectarse con el siguiente 
        salto, o lo desconoce.</para> 

      <para>Si quiere saber m&aacute;s sobre esto consulte la p&aacute;gina 
        man de &man.traceroute.8;.</para> 
    </sect2>

    <sect2>
      <title>Encaminamiento Multicast</title>
      <indexterm>
	<primary>multicast</primary>
	<secondary>options MROUTING</secondary>
      </indexterm>
      <para>FreeBSD soporta tanto aplicaciones multicast como encaminamiento 
        multicast de forma nativa.  Las aplicaciones multicast no necesitan 
        ninguna configuraci&oacute;n especial en FreeBSD;  estas aplicaciones 
        se ejecutan tal cual.  El encaminamiento multicast necesita para 
	ser usado que se compile dicho soporte en el n&uacute;cleo de 
	FreeBSD:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Se debe configurar adem&aacute;s  el d&aelig;mon de 
        encaminamiento multicast,  &man.mrouted.8;, para establecer  
	t&uacute;neles y ejecutar DVMRP utilizando  
	<filename>/etc/mrouted.conf</filename>.  Se pueden encontrar 
        m&aacute;s detalles sobre c&oacute;mo realizar una 
        configuraci&oacute;n de multicast en &man.mrouted.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Eric</firstname>
          <surname>Anderson</surname>
          <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>Redes sin cables (<quote>wireless</quote>)</title>

   <indexterm><primary>wireless networking</primary></indexterm>
   <indexterm>
     <primary>802.11</primary>
     <see>Redes sin cables</see>
   </indexterm>

   <sect2>
      <title>Introducci&oacute;n</title>
      <para>Puede resultar muy &uacute;til el ser capaz de utilizar una 
        computadora sin la molestia de tener un cable de red colgando  
      de la m&aacute;quina en todo momento.  FreeBSD puede utilizarse
        como un cliente de <quote>wireless</quote> e incluso como un 
      <quote>punto de acceso</quote>.</para> 
   </sect2>

   <sect2>
     <title>Modos de Operaci&oacute;n Wireless</title>
     <para>Existen dos formas diferentes de configurar dispositivos wireless 
        802.11: BSS e IBSS.</para> 

     <sect3>
       <title>Modo BSS</title>
       <para>El modo BSS es el que se utiliza normalmente.  Este modo 
          tambi&eacute;n se denomina modo infraestructura. En 
          esta configuraci&oacute;n se conectan un determinado  
          n&uacute;mero de puntos de acceso a una red cableada. Cada red 
          Cada red <quote>wireless</quote> pos&eacute;e su propio nombre.  
          Este nombre es el SSID de la red.</para> 

       <para>Los clientes <quote>wireless</quote> se conectan a estos puntos 
          de acceso.  El est&aacute;ndar IEEE 802.11 define el protocolo que 
          se utiliza para realizar esta conexi&oacute;n.  Un cliente 
	  <quote>wireless</quote> puede asociarse con una determinada red 
          <quote>wireless</quote> especificando el SSID.   
          Un cliente <quote>wireless</quote> tambi&eacute;n puede asociarse a 
          cualquier red que se encuentre disponible;  basta con no especificar 
          ning&uacute;n SSID.</para> 

     </sect3>

     <sect3>
       <title>Modo IBSS</title>
       <para>El modo IBSS, tambi&eacute;n conocido como modo ad-hoc, se ha 
          dise&ntilde;ado para facilitar las conexiones punto a punto.  
          En realidad existen dos tipos distintos de modos ad-hoc.  Uno es
          el modo IBSS, tambi&eacute;n conocido como modo ad-hoc o modo 
          ad-hoc del IEEE.  Este modo se encuentra especificado en el 
          est&aacute;ndar IEEE 802.11.  El segundo tipo se denomina modo
          ad-hoc de demostraci&oacute;n o modo ad-hoc de Lucent (y algunas 
          veces, tambi&eacute;n se le llama simplemente modo ad-hoc, lo cual 
          es bastante confuso).  Este es el modo de funcionamiento 
	  ant&iacute;guo, anterior al est&aacute;ndar 802.11, del modo ad-hoc 
          deber&iacute;a utilizarse s&oacute;lo en instalaciones 
          propietarias. No profundizaremos m&aacute;s sobre estos modos de 
          funcionamiento.</para> 
         
     </sect3>
   </sect2>

   <sect2>
     <title>Modo Infraestructura</title>
     <sect3>
       <title>Puntos de Acceso</title>

       <para>Los puntos de acceso son dispositivos de red 
         <quote>wireless</quote> que funcionan de forma equivalente a los 
	 <quote>hubs</quote> o concentradores, permitiendo que varios clientes 
         <quote> wireless</quote> se comuniquen entre s&iacute;.   
         A menudo se utilizan varios puntos de acceso para cubrir un 
         &aacute;rea determinada como una casa, una oficina u otro tipo de 
         localizaci&oacute;n delimitada.</para> 

       <para>Los puntos de acceso poseen t&iacute;picamente varias 
          conexiones de red: la tarjeta <quote>wireless</quote> y una o 
          m&aacute;s tarjetas Ethernet que se utilizan para comunicarse con 
          el resto de la red.</para> 

       <para>Los puntos de acceso se pueden comprar como tales 
          pero tambi&eacute;n se puede configurar un sistema FreeBSD para 
          crear nuestro propio punto de acceso <quote>wireless</quote> 
	  utilizando un determinado tipo de tarjetas <quote>wireless</quote> 
          que poseen tales capacidades de configuraci&oacute;n.   
          Existe una gran cantidad de fabricantes de hardware que distribuyen 
	  puntos de acceso y tarjetas de red <quote>wireless</quote>, aunque 
	  las capacidades de unos y otras var&iacute;n.</para>

     </sect3>

     <sect3>
       <title>Construcci&oacute;n de un Punto de Acceso basado en 
          FreeBSD</title> 
       <indexterm><primary>wireless networking</primary>
         <secondary>Punto de Acceso</secondary>
       </indexterm>

       <sect4><title>Requisitos</title>

         <para>Para crear nuestro propio punto de acceso con FreeBSD 
            debemos utilizar un determinado tipo de tarjeta 
            <quote>wireless</quote>.   Por el momento, s&oacute;lo las tarjetas 
	    con el chip Prism nos permiten hacer un punto de acceso.  
            Tambi&eacute;n vamos a necesitar una tarjeta para red cableada que 
	    sea soportada por el sistema (esto no es muy complicado dada la 
	    ingente cantidad de dispositivos de este tipo que funcionan en 
	    FreeBSD).  Para este ejemplo vamos a suponer que queremos puentear 
            (&man.bridge.4;) todo el tr&aacute;fico entre la red cableada y la 
	    red inal&aacute;mbrica.</para>

         <para>El uso como punto de acceso <quote>wireless</quote> 
            (tambi&eacute;n denominado <emphasis>hostap</emphasis>)
            funciona mejor con determinadas versiones del <quote>
	    firmware</quote>.  Las tarjetas con chip Prism2 deben disponer de 
	    la versi&oacute;n 1.3.4 (o superior) del <quote>
	    firmware</quote>.  Los chips Prism2.5 y Prism3 deben disponer de 
	    la versi&oacute;n 1.4.9 o superior del <quote>firmware</quote>.  
            Las versiones m&aacute;s ant&iacute;guas de estos <quote>
	    firmwares</quote> pueden no funcionar correctamente.  A d&iacute;a 
            de hoy la &uacute;nica forma de actualizar el <quote>
	    firmware</quote> de las tarjetas es usando las herramientas que 
	    proporciona el fabricante para &windows;.</para>
    
       </sect4>

       <sect4>
         <title>Puesta en Marcha del Sistema</title>
         <para>Primero debemos asegurarnos de que el sistema reconoce
            la tarjeta <quote>wireless</quote>:</para> 
         <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "nodo Wireless FreeBSD"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>
 
         <para>No se preocupe si no entiende algo de la configuraci&oacute;n 
            anterior, lo importante es asegurarse de que el sistema muestra 
            algo parecido, lo cual nosindicar&aacute; que la tarjeta 
            <quote>wireless</quote> ha sido correctamente reconocida por 
	    FreeBSD.  Si el interfaz inal&aacute;mbrico no es reconocido 
	    correctamente y se est&aacute; utilizando una tarjeta PC Card  
            consulte &man.pccardc.8; y &man.pccardd.8;, en las que 
	    tiene mucha informaci&oacute;n al respecto.</para>

          <para>A continuaci&oacute;n, para que podamos disponer de
            un <quote>bridge</quote> deber&aacute; cargar el m&oacute;dulo 
            del kernel &man.bridge.4; por el sencillo procedimiento de 
	    ejecutar el siguiente comando:</para>

         <screen>&prompt.root; <userinput>kldload bridge</userinput></screen>

         <para>No deber&iacute;a aparecer mensaje de error alguno al ejecutar 
	    dicho comando. Si apareciera alguno quiz&aacute;s deba compilar 
	    el kernel del sistema con &man.bridge.4; inclu&iacute;do.  La  
            secci&oacute;n  <link 
              linkend="network-bridging">Bridging</link> de &eacute;ste 
            manual incluye informaci&oacute;n abundante para llevar a buen 
	    puerto esa tarea.</para>

          <para>Una vez que tenemos el soporte de <quote>bridging</quote> 
	    cargado debemos indicar a FreeBSD qu&eacute; interfaces se desean 
	    puentear.  Para ello emplearemos &man.sysctl.8;:</para>

         <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge_cfg="wi0,xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	<para>En &os;&nbsp;5.2-RELEASE y posteriores se deben emplear las 
          siguientes opciones en lugar de las anteriormente expuestas:</para>

	<screen>&prompt.root; <userinput>sysctl net.link.ether.bridge.enable=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge.config="wi0,xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

         <para>Ahora es el momento de configurar la tarjeta de red
           inal&aacute;mbrica.   El siguiente comando convierte la tarjeta en 
	   un punto de acceso:</para>

         <screen>
&prompt.root; <userinput>ifconfig wi0 ssid <replaceable>mi_red</replaceable> channel 11 media DS/11Mbps mediaopt hostap up stationname "<replaceable>PA FreeBSD</replaceable>"</userinput>
         </screen>

         <para>La l&iacute;nea de &man.ifconfig.8; levanta el interfaz 
	   <devicename>wi0</devicename>, configura el SSID con el valor de 
	   <replaceable>mi_red</replaceable> y tambi&eacute;n  el nombre 
           de la estaci&oacute;n como  
	   <replaceable>FreeBSD</replaceable>.  La opci&oacute;n
           <option>media DS/11Mbps</option> configura la tarjeta a 11Mbps.  
	   &Eacute;sto es necesario para que cualquier valor que se necesite 
	   asignar a <option>mediaopt</option> surta efecto.  
	   La opci&oacute;n <option>mediaopt hostap</option> sit&uacute;a el 
           interfaz en modo punto de acceso.  La opci&oacute;n <option>
	   channel 11</option> configura la tarjeta para que use el canal de 
	   radio n&uacute;mero 11.  En &man.wicontrol.8; encontrar&aacute;a 
	   rangos de canales v&aacute;lidos para varios dominios 
	   regulatorios.  Por favor, tenga en cuenta que no todos los canales 
	   son legales en todos los pa&iacute;ses.</para>
        
          <para>Despues de esto deber&iacute;amos disponer de un punto de 
            acceso completamente funcional y en ejecuci&oacute;n.  
            Le animamos a consultar &man.wicontrol.8;, &man.ifconfig.8; y 
            &man.wi.4; para m&aacute;ss informaci&oacute;n.</para>

         <para>Tambi&eacute;n le recomemdamos leer la secci&oacute;n sobre 
            cifrado que econtrar&aacute; m&aacute;s adelante.</para> 
       </sect4>

       <sect4>
         <title>Informaci&oacute;n de Estado</title>
	 <para>Una vez que el punto de acceso est&aacute;configurado 
            resulta interesante poder obtener informaci&oacute;n acerca de los 
            clientes que est&eacute;n asociados.  La persona encargada de la 
	    administraci&oacute;n del punto de acceso puede ejecutar cuando 
	    estime oportuno lo siguiente:

       <screen>&prompt.root; <userinput>wicontrol -l</userinput>
1 station:
00:09:b7:7b:9d:16  asid=04c0, flags=3&lt;ASSOC,AUTH&gt;, caps=1&lt;ESS&gt;, rates=f&lt;1M,2M,5.5M,11M&gt;, sig=38/15
</screen>

         <para>Lo que aqu&iacute; se muestra indica que hay una &uacute;nica 
           estaci&oacute;n asociada y nos suministra sus par&aacute;metros.  
           Los valores de se&ntilde;al que se muestran se deben tomar 
           s&oacute;lo como indicaciones aproximadas de la fuerza de dicha 
           se&ntilde;al.  Su traducci&oacute;n a dBm u otras unidades 
	   var&iacute;a seg&uacute;n la versi&oacute;n del <quote>
	   firmware</quote> de la tarjeta que se use.</para>
       </sect4>
     </sect3>

     <sect3>
       <title>Clientes</title>

       <para>Un cliente <quote>wireless</quote> es un sistema que se comunica 
          con un punto de acceso o directamente con otro cliente 
          <quote>wireless</quote>.</para>

       <para>Generalmente los clientes <quote>wireless</quote> s&oacute;lo 
          poseen un dispositivo de red: la tarjeta de red 
          inal&aacute;mbrica.</para> 

       <para>Existen varias formas de configurar un cliente <quote> 
          wireless</quote> basadas en los distintos modos 
          inal&aacute;mbricos, normalmente reducidos a BSS (o modo 
	  infraestructura, que requiere de un punto de acceso) y el  
          modo IBSS (modo ad-hoc, o modo punto a punto).  En nuestro ejemplo 
	  usaremos el m&aacute;s famoso de ambos, el BSS, para comunicarnos 
	  con un punto de acceso.</para>

       <sect4>
       <title>Requisitos</title>
       <para>S&oacute;lamente existe un requisito real para configurar 
          un sistema FreeBSD como cliente inal&aacute;mbrico: usar una 
          tarjeta de red inal&aacute;mbrica soportada por el sistema.</para>
       </sect4>

       <sect4>
       <title>Ejecuci&oacute;n de un cliente inal&aacute;mbrico FreeBSD</title>

       <para>Para utilizar una red inal&aacute;mbrica se necesitan  
            conocer algunos conceptos b&aacute;sicos de redes 
            de redes wireless.  En nuestro ejemplo queremos conectarnos a la 
            red inal&aacute;mbrica <replaceable>mi_red</replaceable> y queremos 
	    hacerlo con el soporte de cifrado desactivado.</para>

       <note><para>En este ejemplo no se utiliza cifrado, 
              lo cual resulta ser bastante peligroso.  En la pr&oacute;xima 
              secci&oacute;n aprenderemos c&oacute;mo activar el sistema de 
              cifrado com&uacute;n el los dispositivos 
              inal&aacute;mbricos, por qu&eacute; resulta importante hacerlo 
              y por qu&eacute; algunas tecnolog&iacute;as de cifrado no son 
	      suficientes para protegernos completamente.</para></note>

       <para>Aseg&uacute;rese de que FreeBSD reconoce su tarjeta de 
            red inal&aacute;mbrica:</para> 

       <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "FreeBSD Wireless node"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>

       <para>A continuaci&oacute;n debemos especificar los 
            par&aacute;metros correctos para nuestra red:</para> 

       <screen>&prompt.root; <userinput>ifconfig wi0 inet <replaceable>192.168.0.20</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>mi_red</replaceable></userinput></screen>

       <para>Sustituya <hostid role="ipaddr">192.168.0.20</hostid> y 
         <hostid role="netmask">255.255.255.0</hostid> con una 
         direcci&oacute;n IP y m&aacute;scara de red que se 
         adec&uacute;en con el espacio de direccionamiento de la red cableada.  
         Recordemos que nuestro punto de acceso est&aacute; puenteando la red 
         inal&aacute;mbrica y la red de cable, de modo que para el resto de 
	 dispositivos de la red el cliente inal&aacute;brico se muestra como 
	 un elemento m&aacute;s de la red cableada.</para>

       <para>Llegados a este punto deber&iacute;amos poder hacer ping a las 
         m&aacute;quinas de la red cableada como si estuvi&eacute;ramos 
	 compartiendo el mismo enlace f&iacute;sico cableado.</para>

       <para>Si se presentan problemas con la conexi&oacute;n 
            inal&aacute;mbrica se puede comprobar si la tarjeta <quote>
            wireless</quote> se encuentra correctamente asociada (conectada) 
            con el punto de acceso:</para> 

       <screen>&prompt.root; <userinput>ifconfig wi0</userinput></screen>

       <para>eber&iacute;a devolver alg&uacute;n tipo de informaci&oacute;n 
         entre la que deber&iacute;amos observar la siguiente 
         l&iacute;nea:</para> 
       <screen>status: associated</screen>

       <para>Si no aparece la palabra <literal>associated</literal> puede ser 
         que nos encontremos fuera de la cobertura proporcionada por el punto 
         de acceso o puede ser que necesitemos activar el cifrado, aunque 
         &eacute;stos no son los &uacute;nicos problemas con los que nos 
	 podemos encontrar.</para>

       </sect4>
     </sect3>

     <sect3>
      <title>Cifrado</title>
      <indexterm>
        <primary>wireless networking</primary>
        <secondary>encryption</secondary>
      </indexterm>

      <para>El cifrado, tambi&eacute;n llamado codificaci&oacute;n, de una 
        red inal&aacute;mbrica es un proceso importante porque, a diferencia 
        de lo que ocurre con las redes cableadas convencionales, las redes 
        inal&aacute;mbricas no se pueden restringir a un espacio 
        f&iacute;sico determinado.  Los datos que viajan a trav&eacute;s de 
        ondas de radio se difunden a trav&eacute;s de las paredes y alcanzan 
        a los vecinos m&aacute;s cercanos.  Aqu&iacute; es donde entra en 
        en juego el sistema de cifrado.  El cifrado se emplea para evitar que 
        cualquiera pueda examinar los datos enviados a trav&eacute;s del 
	aire.</para>

     <para>Los dos m&eacute;todos m&aacute;s comunes para realizar el cifrado 
       de datos entre el cliente y el punto de acceso son WEP e 
       &man.ipsec.4;.</para>

     <sect4>
     <title>WEP</title>
      <indexterm><primary>WEP</primary></indexterm>

      <para>WEP son las siglas de Wired Equivalency Protocol.  WEP es un 
        un intento de crear redes inal&aacute;mbricas al menos tan seguras 
        omo las redes cableadas o al menos de seguridad equivalente a dichas 
        redes. Por desgracia el sistema WEP es d&eacute;bil y resulta 
        bastante sencillo de romper. Esto significa que cuando se transmite 
        informaci&oacute;n de car&aacute;cter cr&iacute;tico no se debe 
        confiar &uacute;nicamente en este sistema de cifrado.</para>

      <para>No obstante es mejor que no utilizar nada; puede activar WEP en el  
        sistema que hace de punto de acceso mediante:</para>

      <screen>&prompt.root; <userinput>ifconfig wi0 inet up ssid
              <replaceable>mi_red</replaceable> wepmode on wepkey
              <replaceable>0x1234567890</replaceable> media DS/11Mbps
              mediaopt hostap</userinput></screen> 

      <para>y en un cliente inal&aacute;mbrico mediante el siguiente 
        comando:</para> 

      <screen>&prompt.root; <userinput>ifconfig wi0 inet <replaceable>192.168.0.20</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>mi_red</replaceable> wepmode on wepkey <replaceable>0x1234567890</replaceable></userinput></screen>

      <para>Por favor, tenga un poco de sentido com&uacute;n y reemplace la 
        clave <replaceable>0x1234567890</replaceable> por otra clave 
            menos obvia.</para> 

     </sect4>

     <sect4>
     <title>IPsec</title>

     <para>&man.ipsec.4; es una herramienta m&aacute;s robusta y potente para 
       cifrar datos que se mueven a trav&eacute;s de una red. Es el 
       mecanismo m&aacute;s conveniente para asegurar los datos de una red 
       inal&aacute;mbrica.  Tiene m&aacute;s informaci&oacute;n sobre el 
       protocolo &man.ipsec.4; y c&oacute;mo utilizarlo en la secci&oacute;n 
       <link linkend="ipsec">IPsec</link> de este manual.</para>
     </sect4>
    </sect3>

    <sect3>
    <title>Herramientas</title>

    <para>No hay muchas herramientas disponibles si se quiere depurar y 
      monitorizar redes inal&aacute;mbricas pero en el siguiente apartado 
      mostraremos c&oacute;mo utilizar algunas de ellas.</para>
    <sect4>
    <title>El paquete <application>bsd-airtools</application></title>

    <para>El paquete <application>bsd-airtools</application> es un
      conjunto muy completo de herramientas <quote>wireless</quote> que se 
      pueden utilizar para multitud de tareas, entre las cuales podemos citar 
      citar el desciframiento de claves WEP, detecci&oacute;n de puntos de 
      de acceso, monitorizaci&oacute;n de la se&ntilde;al de radio, etc.</para>

    <para>El paquete <application>bsd-airtools</application> se puede instalar 
      como <quote>port</quote> desde <filename role="package">
      net/bsd-airtools</filename>.  La informaci&oacute;n relacionada con los 
      <quote>ports</quote> puede encontrarse en la secci&oacute;n 
      <xref linkend="ports"> de este 
      manual.</para>
          
    <para>El programa <command>dstumbler</command> es una herramienta que 
      permite descubrir puntos de acceso y entre otras cosas muestra de forma 
      gr&aacute;fica la relaci&oacute;n se&ntilde;al / ruido del enlace.  
      Si se experimentan problemas para acceder a un determinado punto de 
      acceso <command>dstumbler</command> puede ser muy &uacute;til.</para>

    <para>Para probar la seguridad de la red inal&aacute;mbrica se puede usar 
      <quote>dweputils</quote>, concretamente los comandos <command> 
      dwepcrack</command>, <command>dwepdump</command> y <command>
      dwepkeygen</command>.  Estos comandos permiten determinar hasta 
      qu&eacute; punto la seguridad que ofrece WEP es suficiente para nuestras 
      necesidades.</para> 

    </sect4>

    <sect4>
    <title>Las utilidades <command>wicontrol</command>,
            <command>ancontrol</command> y
            <command>raycontrol</command></title> 

    <para>Mediante estas herramientas se puede controlar el comportamiento de 
      la tarjeta de red inal&aacute;mbrica.  En los ejemplos anteriores se 
      ha utilizado &man.wicontrol.8; debido a que la tarjeta de red del 
      ejemplo utiliza el interfaz <devicename>wi0</devicename>.  Si se 
      pos&eacute;e una tarjeta <quote>wireless</quote> de Cisco dicha tarjeta 
      se mostrar&aacute; en el sistema mediante el interfaz <devicename>
      an0</devicename> y por lo tanto el comando equivalente que se debe usar 
      ser&aacute; &man.ancontrol.8;.</para>

    </sect4>

    <sect4>
    <title><command>ifconfig</command></title>
    <indexterm><primary>ifconfig</primary></indexterm>

    <para>Con &man.ifconfig.8; se puede utilizar unas cuantas de las opciones 
      que se pueden usar con &man.wicontrol.8;, pero no obstante no 
      pos&eacute;e todas las funcionalidades que proporciona 
      &man.wicontrol.8;.  Se recomienda leer &man.ifconfig.8; para conocer los 
      detalles de los par&aacute;metros y opciones que admite.</para>

    </sect4>

    </sect3>

    <sect3>
    <title>Tarjetas de Red Inal&aacute;mbricas Soportadas</title>
    <sect4>
    <title>Puntos de Acceso</title>

    <para>Las &uacute;nicas tarjetas que soportan el modo de funcionamiento 
      funcionamiento BSS (pueden funcionar como puntos de acceso) son los 
      dispositivos basados en el chip Prism 2, 2.5 &oacute; 3. Consulte 
      &man.wi.4; para ver una lista completa de ellos.</para> 
    </sect4>

    <sect4>
    <title>Clientes</title>

    <para>FreeBSD soporta casi todas las tarjetas inal&aacute;mbricas 802.11b 
      802.11b que se encuentran actualmente en el mercado.  La  
      mayor&iacute;a de las tarjetas basadas en los chips Prism, Spectrum24, 
      Spectrum24, Hermes, Aironet y Raylink tamb&iacute;en funcionan en modo 
      IBSS (modos ad-hoc, punto a punto y BSS).</para>

    </sect4>
    </sect3>

   </sect2>
  </sect1>

  <sect1 id="network-bluetooth">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Pav</firstname>
          <surname>Lucistnik</surname>
          <contrib>Escrito por </contrib>
          <affiliation>
            <address><email>pav@oook.cz</email></address>
          </affiliation>
        </author>
      </authorgroup>
    </sect1info>
    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>
    <sect2>
      <title>Introducci&oacute;n</title>
      <para>Bluetooth es una tecnolog&iacute;a inal&aacute;mbrica que opera en 
        banda de 2.4 GHz (donde no se necesita licencia).  Se trata de una 
        tecnolog&iacute;a pensada para la creaci&oacute;n de redes de 
        &aacute;mbito personal (de cobertura reducida, normalmente de unos 10 
        metros).  Las redes se suelen construir en modo <quote>ad-hoc</quote> 
        utilizando dispositivos heterog&eacute;neos como tel&eacute;fonos 
        m&oacute;viles, dispositivos manuales (<quote>handhelds</quote>) y 
	computadoras port&aacute;tiles.  A diferencia de otras 
        tecnolog&iacute;as inal&aacute;mbricas como Wi-Fi, Bluetooth ofrece 
        perfiles de servicio m&aacute;s detallados; por ejemplo un perfil para 
        actuar como un servidor de ficheros basado en FTP, para la 
        difusi&oacute;n de ficheros (<quote>file pushing</quote>), para el 
        transporte de voz, para la emulaci&oacute;n de l&iacute;nea serie y 
        muchos m&aacute;s.</para> 

      <para>La pila de Bluetooth en &os; se implementa utilizando el entorno 
        de Netgraph (v&eacute;ase &man.netgraph.4;). La mayor&iacute;a de los  
        dispositivos USB Bluetooth se pueden utilizar mediante el controlador 
        &man.ng.ubt.4;. Los dispositivos Bluetooth basados en el chip Broadcom 
        BCM2033 est&aacute;n soportados mediante los controladores 
        &man.ubtbcmfw.4; y &man.ng.bt3c.4;.  Los dispositivos Bluetooth 
        basados en la interfaz serie o de Rayos Infrarrojos (UART) se 
	controlan mediante &man.sio.4;, &man.ng.h4.4; y &man.hcseriald.8;.  
        Este cap&iacute;tulo describe el uso de dispositivos Bluetooth USB.  
        El soporte para Bluetooth se encuentra en las versiones de &os; 5.0 y 
        posteriores.</para> 
    </sect2>

    <sect2>
      <title>Instalaci&oacute;n del Dispositivo</title>
      <para>Por defecto los controladores de los dispositivos Bluetooth se 
        encuentran disponibles como m&oacute;dulos del kernel.  Antes de 
        enchufar el dispositivo Bluetooth se debe cargar el m&oacute;dulo 
        correspondiente dentro del n&uacute;cleo.</para>
      

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Si el dispositivo Bluetooth se encuentra conectado cuando el 
        sistema arranca se debe cargar el m&oacute;dulo modificando a tal 
	efecto el fichero <filename>/boot/loader.conf</filename>.</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Al conectar el dispositivo Bluetooth aparecer&aacute; en la 
        consola (o en syslog) la siguiente informaci&oacute;n:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Se debe copiar
        <filename>/usr/share/examples/netgraph/bluetooth/rc.bluetooth</filename>
        a alg&uacute;n lugar m&aacute;s conveniente, por ejemplo 
        <filename>/etc/rc.bluetooth</filename>.  Este script se usa para 
        ejecutar y detener la pila Bluetooth del sistema.  Se suele recomendar 
	quitar la pila antes de desenchufar el dispositivo pero si no se hace 
	no deber&iacute;a producirse ning&uacute;n desastre.  Cuando se 
	arranca la pila aparece un mensaje similar a este:</para>

      <screen>&prompt.root; <userinput>/etc/rc.bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>

    </sect2>

    <indexterm><primary>HCI</primary></indexterm>
    <sect2>
      <title>Interfaz de la Controladora de la M&aacute;quina (HCI)</title>

      <para>La interfaz de la Controladora de la M&aacute;quina (Host 
        Controller Interface) proporciona una interfaz de comandos 
        para la controladora de banda base y para el gestor de enlace, 
        y permite acceder al estado del hardware y a los 
        registros de control.  Esta interfaz proporciona una capa de 
        acceso homog&eacute;nea para todos los dispositivos Bluetooth  
        de banda base. La capa HCI de la m&aacute;quina intercambia 
        comandos y datos con el firmware del HCI presente en el 
        dispositivo Bluetooth. El driver de la capa de transporte de 
        la controladora de la m&aacute;quina 
        (es decir, el driver del bus f&iacute;sico) proporciona 
        ambas capas de HCI la posibilidad de intercambiar 
        informaci&oacute;n entre ellas.</para>

      <para>Se crea un nodo Netgraph de tipo <emphasis>HCI</emphasis>
        para cada dispositivo Bluetooth.  El nodo Netgraph HCI 
        se conecta normalmente con el nodo que representa el 
        controlador del dispositivo Bluetooth de la m&aacute;quina 
        (sentido de bajada) y con el nodo Netgraph L2CAP en el sentido 
        de subida. Todas las operaciones HCI se realizan sobre el 
        nodo Netgraph HCI y no  sobre el el nodo que representa al 
        dispositivo. El nombre por defecto para el nodo HCI es 
        <quote>devicehci</quote>. Para obtener m&aacute;s detalles, 
        por favor consulte la p&aacute;gina del manual de 
        &man.ng.hci.4;.</para>   

      <para>Una de las tareas m&aacute;s importantes que se deben 
        realizar es el descubrimiento autom&aacute;tico de otros 
        dispositivos Bluetooth que se encuentren dentro del radio de 
        cobertura. Esta operaci&oacute;n se denomina en ingl&eacute;s  
        <emphasis>inquiry</emphasis> (consulta). Esta operaci&oacute;n 
        o otras operaciones HCI relacionadas se realizan mediante 
        la utilidad &man.hccontrol.8;. El siguiente ejemplo muestra 
        c&oacute;mo descubrir dispositivos en pocos segundos.  
        Tenga siempre presente que un dispositivo remoto s&oacute;lo 
        contesta a la consulta si se encuentra configurado en modo 
        descubrimiento (<emphasis>discoverable mode</emphasis>).</para> 

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> es la direcci&oacute;n 
        identificativa &uacute;nica del dispositivo Bluetooth,  
        similar a las direcciones MAC de las tarjetas Ethernet. Esta 
        direcci&oacute;n se necesita para transmitir otro tipo de 
        informaci&oacute;n a otros dispositivos. Se puede asignar un nombre 
        m&aacute;s significativo para los humanos en la variable BD_ADDR.  
        El fichero <filename>/etc/bluetooth/hosts</filename> contiene 
        informaci&oacute;n relativa a los dispositivos Bluetooth conocidos.  
        El siguiente ejemplo muestra c&oacute;mo obtener un nombre 
        significativo para los humanos que fu&eacute; asignado a un 
        dispositivo remoto:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Si se realiza una consulta (inquiry) sobre el dispositivo
        Bluetooth remoto, dicho dispositivo identificar&aacute; nuestro 
        computador como <quote>nombre.de.su.sistema
          (ubt0)</quote>. El nombre asignado al dispositivo local se puede 
        modificar en cualquier momento.</para> 

      <para>El sistema Bluetooth proporciona una conexi&oacute;n punto a punto 
        (con s&oacute;lo dos unidades Bluetooth involucradas) o 
        tambi&eacute;n una conexi&oacute;n punto multipunto. En el
        &uacute;ltimo caso, la conexi&oacute;n se comparte entre varios 
        dispositivos Bluetooth.  El siguiente ejemplo muestra como obtener una 
	lista de las conexiones de banda base activas en el dispositivo 
        local:</para> 

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Resulta &uacute;til disponer de un <emphasis>manejador de
          la conexi&oacute;n</emphasis> cuando se necesita terminar la
        conexi&oacute;n de banda base. Es importante recalcar que normalmente 
        no es necesario realizar esta terminaci&oacute;n de forma manual.  
        La pila Bluetooth puede conclu&iacute;r  autom&aacute;ticamente las
        conexiones de banda base que se encuentren inactivas.</para> 

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Se ruega consultar la salida del comando
        <command>hccontrol help</command> para obtener un listado completo de 
        los comandos HCI que se encuentran disponibles. La mayor&iacute;a de 
        &eacute;stos comandos no requiren privilegios de superusuario.</para>

    </sect2>

    <indexterm><primary>L2CAP</primary></indexterm>
    <sect2>
      <title>Protocolo de Adaptaci&oacute;n y de Control de Enlace a
        nivel L&oacute;gico (L2CAP)</title> 

      <para>El protocolo L2CAP (Logical Link Control and Adaptation
        Protocol) proporciona servicios de datos tanto orientados a 
        conexi&oacute;n como no orientados a conexi&oacute;n a los protocolos 
        de las capas superiores, junto con facilidades de
        multiplexaci&oacute;n y de segmentacion y reensamblaje. L2CAP permite 
        que los protocolos de capas superiores puedan transmitir y recibir 
        paquetes de datos L2CAP de hasta 64 kilobytes de longitud.</para>

      <para>L2CAP se basa en el concepto de <emphasis>canales</emphasis>.  
        Un canal es una conexi&oacute;n l&oacute;gica que se sit&uacute;a 
        sobre la conexi&oacute;n de banda base.  Cada canal se asocia a un 
        &uacute;nico protocolo.  Cada paquete L2CAP que se recibe a un canal 
        se redirige al protocolo superior correspondiente.  Varios canales 
        pueden operar sobre la misma conexi&oacute;n de banda base, pero un 
        canal no puede tener asociados m&aacute;s de un protocolo de alto 
        nivel.</para> 

      <para>Para cada dispositivo Bluetooth se cre un &uacute;nico nodo 
        Netgraph de tipo <emphasis>l2cap</emphasis>.  El nodo L2CAP se conecta 
        normalmente conectado al nodo Netgraph HCI (hacia abajo) y con nodos 
        Bluetooth tipo <quote>sockets</quote> hacia arriba. El nombre por 
	defecto para el nodo Netgraph L2CAP es <quote>devicel2cap</quote>.  
        Para obtener m&aacute;s detalles se ruega consultar la p&aacute;gina 
        del manual &man.ng.l2cap.4;.</para> 

      <para>Un comando muy &uacute;til es el &man.l2ping.8;, el cual se puede 
        utilizar para hacer ping a otros dispositivos.  Algunas 
        implementaciones de Bluetooth no devuelven todos los datos que se 
        env&iacute;an, de tal forma que el valor <emphasis>0 bytes</emphasis>  
        que se observa a continuaci&oacute;n es normal:</para> 

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>La herramienta &man.l2control.8; se utiliza para realizar
        varias operaciones sobre los nodos L2CAP.  Este ejemplo muestra 
        c&oacute;mo obtener la lista de conexiones l&oacute;gicas (canales) y 
	la lista de conexiones de banda base (f&iacute;sica) que mantiene el  
        dispositivo local:</para>  

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>Otra herramienta de diagn&oacute;stico interesante es
        &man.btsockstat.1;.  Realiza un trabajo similar al comando 
        &man.netstat.1;, pero en este caso para las estructuras de datos 
        relacionadas con el sistema Bluetooth. A continuaci&oacute;n se 
	muestra la informaci&oacute;n relativa a la misma conexi&oacute;n 
        l&oacute;gica del ejemplo anterior.</para> 

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <indexterm><primary>RFCOMM</primary></indexterm>
    <sect2>
      <title>Protocolo RFCOMM </title>

      <para>El protocolo RFCOMM proporciona emulaci&oacute;n de puertos serie 
        a trav&eacute;s del protocolo L2CAP. Este protocolo se basa en el 
        est&aacute;ndar de la ETSI denominado TS 07.10. RFCOMM es un 
        protoclo de transporte sencillo, con soporte para hasta 9 puertos 
        serie RS-232 (EIATIA-232-E).  El protocolo RFCOMM permite hasta 60 
        conexiones simultaneas (canales RFCOMM) entre dos dispositivos 
        Bluetooth.</para> 

      <para>Para los prop&oacute;sitos de RFCOMM, un camino de
        comunicaci&oacute;n involucra siempre a dos aplicaciones que se 
        ejecutan en dos dispositivos distintos (los extremos de la 
        comunicaci&oacute;n). Entre ellos existe un segmento que los 
        comunica.  RFCOMM pretende cubrir aquellas aplicaciones que utilizan 
        los puertos serie de las m&aacute;quinas donde se ejecutan. El 
        segmento de comunicaci&oacute;n es un enlace Bluetooth desde un 
        dispositivo al otro (conexi&oacute;n directa).</para>
      

      <para>RFCOMM trata &uacute;nicamente con la conexi&oacute;n de 
        dispositivos directamente, y tambi&eacute;n con conexiones entre el 
        dispositivo y el modem para realizar conexiones de red. RFCOMM puede 
        soportar otras configuraciones, tales como m&oacute;dulos que 
        se comunican via Bluetooth por un lado y que proporcionan una interfaz 
        de red cableada por el otro.</para> 
 
      <para>En &os; el protocolo RFCOMM se implementa utilizando la
        capa de <quote>sockets</quote> de Bluetooth.</para> 
    </sect2>

    <indexterm><primary>pairing</primary></indexterm>
    <sect2>
      <title>Enparejamiento de Dispositivos</title>

      <para>Por defecto, la comunicaci&oacute;n Bluetooth no se valida, por lo 
        que cualquier dispositivo puede en principio hablar con cualquier 
        otro. Un dispositivo Bluetooth (por ejemplo un tel&eacute;fono 
        celular) puede solicitar autenticaci&oacute;n para realizar un 
        determinado servicio (por ejemplo para el servicio de
        marcaci&oacute;n por modem).  La autenticaci&oacute;n de Bluetooth 
        normalmente se realiza utilizando <emphasis>c&oacute;digos
          PIN</emphasis>.  Un c&oacute;digo PIN es una cadena ASCII de hasta 
        16 caracteres de longitud.  Los usuarios deben introducir 
        el mismo c&oacute;digo PIN en ambos dispositivos. Una vez que el 
        usuario ha introducido el PIN adecuado ambos dispositivos generan una 
        <emphasis>clave de enlace</emphasis>. Una vez generada, la clave se 
        puede almacenar en el propio dispositivo o en un dispositivo de 
        almacenamiento externo.  La siguiente vez que se comuniquen ambos 
        dispositivos se reutilizar&aacute; la misma clave. El procedimiento 
        descrito hasta este punto se denomina 
        <emphasis>emparejamiento (pairing)</emphasis>. Es importante recordar 
        que si la clave de enlace se pierde en alguno de los dispositivos 
        involucrados se debe volver a ejecutar el procedimiento de 
        emparejamiento.</para> 

      <para>El d&aelig;mon &man.hcsecd.8; se encarga de gestionar todas las
        peticiones de autenticaci&oacute;n Bluetooth. El archivo de 
        configuraci&oacute;n predeterminado se denomina 
        <filename>/etc/bluetooth/hcsecd.conf</filename>. A 
        continuaci&oacute;n se muestra una secci&oacute;n de ejemplo de un 
        tel&eacute;fono celular con el c&oacute;digo PIN arbitrariamente 
        fijado al valor <quote>1234</quote>:
       </para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>No existe ninguna limitaci&oacute;n en los c&oacute;digos PIN a 
        excepci&oacute;n de su longitud.  Algunos dispositivos (por ejemplo 
        los dispositivos de mano Bluetooth) pueden obligar a escribir un 
        n&uacute;mero predeterminado de caracteres para el c&oacute;digo 
        PIN.  La opci&oacute;n <option>-d</option> fuerza al d&aelig;mon 
	&man.hcsecd.8; a permanecer ejecut&aacute;dose en primer plano, 
        de tal forma que se puede observar f&aacute;cilmente lo que ocurre.  Si 
	se configura el dispositivo Bluetooth remoto para aceptar el 
        procedimiento de emparejamiento y se inicia la conexi&oacute;n con 
        dicho dispositivo, el dispositivo remoto deber&iacute;a decir que el 
        procedimiento de emparejamiento se ha aceptado y deber&iacute;a 
	solicitar el c&oacute;digo PIN.  Si se introduce el mismo 
        c&oacute;digo PIN que se escribi&oacute; en su momento en el fichero 
        <filename>hcsecd.conf</filename> el procedimiento de emparejamiento y 
        de generaci&oacute;n de la clave de enlace deber&iacute;a terminar 
        satisfactoriamente.  Por otra parte el procedimiento de emparejamiento 
        se puede iniciar en el dispositivo remoto. A continuaci&oacute;n
        se muestra un ejemplo de la salida del d&aelig;mon 
        <command>hcsecd</command>.</para> 
 
<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <indexterm><primary>SDP</primary></indexterm>
    <sect2>
      <title>Protocolo de Descubrimiento de Servicios (SDP)</title>
      <para>El Protocolo de Descubrimiento de Servicios (Service 
        Discovery Protocol o SDP) permite a las aplicaciones 
        cliente descubrir la existencia de diversos servicios 
        proporcionados por uno o varios servidores de aplicaciones, 
        junto con los atributos y propiedades de los servicios que se 
        ofrecen. Estos atributos de servicio incluyen 
        el tipo o clase de servicio ofrecido y el mecanismo o la 
        informaci&oacute;n necesaria para utilizar dichos servicios.</para>
        
      <para>SDP se basa en una determinada comunicaci&oacute;n entre
        un servidor SDP y un cliente SDP.  El servidor mantiene una lista de 
        registros de servicios, los cuales describen las 
        caracter&iacute;sticas de los servicios ofrecidos.  Cada registro 
        contiene informaci&oacute;n sobre un determinado servicio.  Un cliente 
        puede recuperar la informaci&oacute;n de un registro de servicio 
        almacenado en un servidor SDP lanzando una petici&oacute;n SDP.  Si el 
        cliente o la aplicaci&oacute;n asociada con el cliente decide utilizar 
	un determinado servicio, debe establecer una conexi&oacute;n 
        independiente con el servicio en cuesti&oacute;n.  SDP proporciona un 
        mecanismo para el descubrimiento de servicios y sus atributos 
	asociados, pero no proporciona ning&uacute;n mecanismo ni protocolo 
        para utilizar dichos servicios.</para> 
 
      <para>Normalmente, un cliente SDP realiza una b&uacute;squeda de
        servicios acotada por determinadas caracter&iacute;sticas. No obstante 
        hay momentos en los que resulta deseable descubrir todos los 
        servicios ofrecidos por un servidor SDP sin que pueda existir 
        ning&uacute;n conocimiento previo sobre los registros que pueda 
        contener. Este proceso de b&uacute;squeda de cualquier servicio 
        ofrecido se denomina <emphasis>navegaci&oacute;n</emphasis> o 
	<emphasis>browsing</emphasis>.</para> 
 
      <para>El servidor Bluetooth SDP denominado &man.sdpd.8; y el cliente de 
        l&iacute;nea de comando denominado &man.sdpcontrol.8; se incluyen en  
        la instalaci&oacute;n est&aacute;ndar de &os;.  El siguiente ejemplo 
        muestra c&oacute;mo realizar una consulta de navegaci&oacute;n 
        una consulta de navegaci&oacute;n SDP.</para> 

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</screen>

      <para>... y as&iacute; sucesivamente. Resulta importante resaltar una 
        vez m&aacute;s que cada servicio posee una lista de atributos (por 
        ejemplo en el canal RFCOMM). Dependiendo de los servicios que se 
        quieran utilizar puede resultar necesario anotar algunos de los 
        atributos. Algunas implementaciones de Bluetooth no soportan 
        navegaci&oacute;n de servicios y pueden devolver una lista 
        vac&iacute;a. En este caso se puede intentar buscar alg&uacute;n 
        servicio determinado. El ejemplo siguiente muestra c&oacute;mo buscar 
        el servicio OBEX Object Push (OPUSH):</para>
       
      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>En &os; los servicios a clientes Bluetooth se suministran mediante 
        el servidor &man.sdpd.8;.</para>
      <screen>&prompt.root; <userinput>sdpd</userinput></screen>

      <para>La aplicaci&oacute;n local servidora que quiere proporcionar 
        servicio Bluetooth a los clientes remotos puede registrar su servicio 
	con el d&aelig;mon SDP local.  Un ejemplo de dicha aplicaci&oacute;n 
        Un ejemplo de dicha aplicaci&oacute;n lo constituye el d&aelig;mon 
        &man.rfcomm.pppd.8;. 
        Una vez ejecutado el d&aelig;mon registra un servicio LAN de Bluetooth 
        en el d&aelig;mon SDP local.</para> 

      <para>Se puede obtener la lista de servicios registrados con el servidor 
        SDP local lanzando una consulta de navegaci&oacute;n SDP utilizando 
        el canal de control local.</para> 

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>

    </sect2>

    <sect2>
      <title>Acceso Telef&oacute;nico a Redes (DUN) y Acceso a Redes mediante 
        perfiles PPP (LAN)</title> 

      <para>El perfil de Acceso Telef&oacute;nico a Redes (Dial-Up Networking 
        o DUN) se utiliza mayoritariamente con modems y tel&eacute;fonos 
        celulares. Los escenarios cubiertos por este perfil se describen a 
        continuaci&oacute;n:</para> 

      <itemizedlist>
        <listitem><para>Utilizaci&oacute;n de un tel&eacute;fono celular o un 
            modem por una computadora para simular un modem sin cables 
            que se conecte a un servidor de acceso telef&oacute;nico a redes o 
            para otros servicios de acceso telef&oacute;nico relacionados;
          </para></listitem>

        <listitem><para>Utilizaci&oacute;n de un tel&eacute;fono celular o un 
            modem por un computador para recibir llamadas de datos.
            </para></listitem>
      </itemizedlist>

      <para>El Acceso a Redes con perfiles PPP (LAN) se puede utilizar en las 
        siguientes situaciones:</para> 

      <itemizedlist>
        <listitem><para>Acceso LAN para un &uacute;nico dispositivo Bluetooth;
           </para></listitem>

        <listitem><para>Acceso LAN para m&uacute;ltiples dispositivos 
            Bluetooth; 
          </para></listitem>

        <listitem><para>Conexi&oacute;n de PC a PC (utilizando 
            emulaci&oacute;n de PPP sobre una l&iacute;nea serie).
          </para></listitem>
      </itemizedlist>

      <para>En &os; ambos perfiles se implementan bajo los comandos 
        &man.ppp.8; y &man.rfcomm.pppd.8;, un encapsulador que convierte la 
        conexi&oacute;n RFCOMM de Bluetooth en algo que puede ser utilizado 
        por PPP.  Antes de que se puedan utilizar los perfiles se debe 
        definir una nueva etiqueta PPP en el fichero de configuraci&oacute;n 
        <filename>/etc/ppp/ppp.conf</filename>.  Consulte &man.rfcomm.pppd.8; 
        para ver algunos ejemplos.</para>
      

      <para>En el siguiente ejemplo se va a utilizar &man.rfcomm.pppd.8; para 
        abrir una conexi&oacute;n RFCOMM con un dispositivo remoto con 
        BD_ADDR 00:80:37:29:19:a4 sobre un canal RFCOMM basado en DUN (Dial-Up 
        Networking).  El n&uacute;mero de canal RFCOMM se obtiene a partir del 
        dispositivo remoto a trav&eacute;s de SDP.  Es posible especificar el 
        canal RFCOMM a mano, en cuyo caso &man.rfcomm.pppd.8; no 
        realizar&aacute; ninguna consulta SDP.  Se puede utilizar el comando 
        &man.sdpcontrol.8; para descubrir el canal RFCOMM utilizado en el 
        dispositivo remoto.</para> 

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Para proporcionar el servicio de Acceso a Redes a trav&eacute;s de 
        PPP (LAN) se debe ejecutar el servidor &man.sdpd.8;.  Se debe crear 
        una nueva entrada en <filename>/etc/ppp/ppp.conf</filename>.  Le  
        rogamos que consulte &man.rfcomm.pppd.8; y observe los ejemplos que 
        se facilitan. Por &uacute;ltimo se debe ejecutar el servidor PPP 
        RFCOMM sobre un n&uacute;mero de canal RFCOMM adecuado.  El servidor 
        PPP RFCOMM registrar&aacute; autom&aacute;ticamente el servicio LAN 
        de Bluetooth con el servidor SDP local.  El ejemplo que se muestra a 
        continuaci&oacute;n describe c&oacute;mo ejecutar el servidor PPP 
        RFCOMM.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <indexterm><primary>OBEX</primary></indexterm>
    <sect2>
      <title>Perfil OBEX Object Push (OPUSH)</title>
      <para>OBEX es un protocolo muy utilizado para transferencias de ficheros 
        sencillas entre dispositivos m&oacute;viles.  Su uso m&aacute;s 
        importante se produce en comuncaciones por infrarrojos, donde se 
        utiliza para transferencia de ficheros gen&eacute;ricos entre 
        port&aacute;tiles o dispositivos Palm y para enviar tarjetas de visita 
        o entradas de la agenda entre tel&eacute;fonos celulares y otros 
        dispositivos con aplicaciones PIM.</para>

      <para>El cliente y el servidor de OBEX se implementan como un paquete 
        denominado <application>obexapp</application> disponible como <quote>
        port</quote> en  
	<filename role="package">comms/obexapp</filename>.</para> 

      <para>El cliente OBEX se utiliza para introducir y para recuperar 
        recuperar objetos del servidor OBEX.  Un objeto puede por ejemplo ser 
        una tarjeta de visita o una cita.  El cliente OBEX puede obtener un 
        n&uacute;mero de canal RFCOMM del dispositivo remoto utilizando SDP.  
        Esto se hace especificando el nombre del servicio en lugar del 
        n&uacute;mero de canal RFCOMM.  Los nombres de servicios soportados 
        son: IrMC, FTRN y OPUSH. Es posible especificar el canal RFCOMM como 
        un n&uacute;mero. A continuaci&oacute;n se muestra un ejemplo de una 
        sesi&oacute;n OBEX donde el objeto que posee la informaci&oacute;n del 
        dispositivo se recupera del tel&eacute;fono celular y un nuevo objeto 
        (la tarjeta de visita) se introduce en el directorio de dicho 
        tel&eacute;fono.</para> 

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: local file&gt; devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put
put: local file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Para proporcionar servicio de OBEX el servidor &man.sdpd.8; debe 
        estar en funcionamiento. Adem&aacute;s se debe crear un directorio 
        ra&iacute;z donde todos los objetos van a ser almacenados.  La ruta 
	por defecto para el directorio ra&iacute;z es <filename> 
        /var/spool/obex</filename>.   Por &uacute;ltimo se debe ejecutar el 
        servidor OBEX en un n&uacute;mero de canal RFCOMM v&aacute;lido.  El 
	servidor OBEX registra autom&aacute;ticamente el servicio de Object 
	Push con el d&aelig;mon SDP local.  El ejemplo que se muestra a 
        local. El ejemplo que se muestra a continuaci&oacute;n
        continuaci&oacute;n describe c&oacute;mo ejecutar el servidor 
	OBEX.</para> 

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
    </sect2>

    <sect2>
      <title>Perfil de Puerto Serie (SP) </title>
      <para>El perfil de puerto serie (Serial Port o SP) permite que 
        dispositivos Bluetooth realicen emulaci&oacute;n de RS232 (o 
        similar).  El escenario cubierto por este perfil trata con 
        con aplicaciones comerciales que utilizan Bluetooth como un sustituto 
        sustituto del cable, utilizando una capa de abstracci&oacute;n que 
        representa un puerto serie virtual.</para> 

      <para>La aplicaci&oacute;n &man.rfcomm.sppd.1; implementa el perfil 
        Puerto Serie.  Usa una pseudo tty como abstracci&oacute;n de puerto 
	serie virtual.  El ejemplo de m&aacute;s abajo muestra c&oacute;mo 
	conectarse a un servicio de dispositivo remoto de Puerto Serie.  
	Observe que no necesita especificarse el canal RFCOMM: 
	&man.rfcomm.sppd.1; puede obtenerlo del dispotivo remoto via 
	SDP.  Si necesita especificarlo por alguna raz&oacute;n 
	h&aacute;galo en la propia l&iacute;nea de comandos.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Una vez conectado el pseudo tty se puede utilizar como un puerto 
        serie.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>

    </sect2>

    <sect2>
      <title>Depuraci&oacute;n de Problemas</title>

      <sect3>
        <title>Un dispositivo remoto no puede conectarse</title>
        <para>Algunos dispositivos Bluetooh antiguos no soportan el cambio de 
          cambio de roles. Por defecto, 
          roles.  Cuando &os; acepta una nueva conexi&oacute;n por defecto 
          intenta realizar un cambio de rol y convertirse en maestro.  
          Dispositivos que no son capaces de realizar este cambio no pueden
          conectarse.  Es interesante resaltar que el cambio de roles se 
          realiza cuando se est&aacute; estableciendo una nueva 
          conexi&oacute;n de tal forma que no es posible preguntar al 
          dispositivo si soporta intercambio de roles.  Existe una 
          opci&oacute;n HCI para desactivar el intercambio de roles en la 
          parte local.</para> 

        <screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
        <title>Algo va mal &iquest;puedo ver exactamente qu&eacute; 
          est&aacute; ocurriendo?</title> 
        <para>S&iacute;, se puede.  Utilice el paquete 
          <application>hcidump-1.5</application>, que se puede descargar de  
          <ulink 
            url="http://www.geocities.com/m_evmenkin/">aqu&iacute;</ulink>.  
          La herramienta <application>hcidump</application> es similar a la 
          herramienta &man.tcpdump.1;. Se puede utilizar para mostrar el 
          contenido de los paquetes Bluetooth sobre el terminal y para volcar 
          los paquetes Bluetooth a un fichero.</para>

      </sect3>

    </sect2>

  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Steve</firstname>
      	  <surname>Peterson</surname>
	  <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>Puenteado</title>

    <sect2>
      <title>Introducci&oacute;n</title>
      <indexterm><primary>IP subnet</primary></indexterm>
      <indexterm><primary>bridge</primary></indexterm>
      <para>Algunas veces resulta &uacute;til dividir una red f&iacute;sica 
        (como por ejemplo un segmento Ethernet) en dos segmentos de red 
        separados, sin tener que crear subredes IP y sin utilizar una pasarela 
        para comunicar ambos segmentos.  El dispositivo que realiza esta 
        funci&oacute;n se denomina <quote>bridge</quote>.  Un sistema FreeBSD 
	con dos interfaces de red puede actuar como un <quote>bridge</quote> 
        o puente entre ambas.</para> 

      <para>El <quote>bridge</quote> funciona de tal forma que aprende las 
        direcciones de la capa MAC (direcciones Ethernet) de los nodos que se 
        encuentran conectados a cada interfaz de red de tal forma que 
	s&oacute;lo se reenv&iacute;a tr&aacute;fico entre los segmentos de 
        red cuando las direcciones fuente y destino se encuentran separadas en 
        segmentos distintos.</para>

      <para>En varios aspectos se puede comparar un <quote>bridge</quote> con 
        un <quote>switch</quote> de pocos puertos.</para>
    </sect2>

    <sect2>
      <title>Situaciones donde el Puenteado resulta adecuado</title>

      <para>Existen al menos dos situaciones t&iacute;picas donde se puede 
        utilizar la funcionalidad proporcionada por los <quote>
        bridges</quote>.</para> 


      <sect3>
	<title>Tr&aacute;fico de gran volumen en un segmentos de red</title>

        <para>La primera situaci&oacute;n surge cuando nos encontramos con un 
          segmento de red congestionado pero por las razones que sean no 
          queremos subdividir la red e interconectar las nuevas subredes  
          mediante un encaminador.</para> 

        <para>Vamos a considerar un ejemplo de un peri&oacute;dico donde los 
          departamentos editoriales y de producci&oacute;n utilizan la misma 
          subred.  Los usuarios de la editorial utilizan el servidor 
          <hostid>A</hostid> como servidor de ficheros y los de  
          producci&oacute;n utilizan el servidor <hostid>B</hostid>.  Se 
          Se utiliza una red Ethernet para conectar ambos departamentos y se 
          ha detectado que la alta utilizaci&oacute;n del enlace est&aacute; 
          ralentizando el funcionamiento de la red.</para>
        

        <para>Si los usuarios de la editorial pudieran agregarse en un 
          segmento de red mientras que los usuarios de producci&oacute;n se 
          localizaran en otro se podr&iacute;an conectar ambos segmentos 
	  mediante un <quote>bridge</quote>.  S&oacute;lo se utilizar&aacute; 
          el <quote>bridge</quote> para encaminar tr&aacute;fico de red 
          destinado a interfaces que se encuentren en el <emphasis>
	  otro</emphasis> lado del <quote>bridge</quote>, reduciendo de esta 
	  forma la congesti&oacute;n en cada nuevo segmento.</para>

      </sect3>

      <sect3>
	<title>Cortafuegos de Filtrado/Conformaci&oacute;n de Tr&aacute;fico
          </title> 
	<indexterm><primary>firewall</primary></indexterm> 
	<indexterm><primary>network address
            translation</primary></indexterm> 

	<para>La segunda situaci&oacute;n t&iacute;pica se produce cuando se 
          necesita un cortafuegos pero no la Traducci&oacute;n de Direcciones 
	  de Red (NAT).</para> 

        <para>A continuaci&oacute;n se muestra un ejemplo. Una
          peque&ntilde;a compa&ntilde;&iacute;a se comunica con su ISP 
          utilizando DSL o ISDN. Dicha compa&ntilde;&iacute;a posee 13 
          13 direcciones IP globalmente accesibles delegadas por su ISP y tiene 
          10 ordenadores en funcionamiento.  En esta situaci&oacute;n un 
          un cortafuegos basado en un <quote>router</quote> resulta 
	  dif&iacute;cil debido a la distribuci&oacute;n del espacio de 
          direccionamiento disponible (subnetting).</para> 

	<indexterm><primary>router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>
	<para>Un cortafuegos implementado sobre un <quote>bridge</quote> se 
	  puede utilizar en el camino de bajado desde el ISP hasta las 
	  oficinas de la compa&ntilde;&iacute;a sin necesidad de tener en 
	  cuenta ning&uacute;n aspecto relacionado con la 
          distribuci&oacute;n de las direcciones IP.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Configuraci&oacute;n de un <quote>Bridge</quote></title>

      <sect3>
	<title>Selecci&oacute;n de la interfaz de red</title>

	<para>Un <quote>bridge</quote> necesita al menos dos tarjetas de red 
	  situadas en dos segmentos de red para su funcionamiento.  Por 
          desgracia no todas las interfaces de red pueden usarse para el 
	  puenteo.  Consulte &man.bridge.4;, ah&iacute;n encontrar&aacute; 
	  m&aacute;s informaci&oacute;n sobre qu&eacute; tarjetas puede 
	  usar.</para>

	<para>Por favor, instale y pruebe las dos tarjetas de red antes de 
          continuar.</para> 

      </sect3>

      <sect3>
	<title>Cambios en la Configuraci&oacute;n del N&uacute;cleo</title>
	<indexterm>
	  <primary>kernel options</primary>
	  <secondary>options BRIDGE</secondary>
	</indexterm>

	<para>Para activar el soporte de <quote>bridging</quote> en el 
	  n&uacute;cleo a&ntilde;ada</para>

	<programlisting>options BRIDGE</programlisting>

	<para>al fichero de configuraci&oacute;n del n&uacute;cleo y 
          recompile el kernel.</para> 
      </sect3>

      <sect3>
	<title>Soporte de Cortafuegos</title>
	<indexterm><primary>firewall</primary></indexterm>
	<para>Si se desea utilizar el <quote>bridge</quote> como un 
	  cortafuegos, se debe a&ntilde;adir adem&aacute;s la opci&oacute;n 
          <literal>IPFIREWALL</literal>.  Lea el cap&iacute;lo de
	  firewalls <!--<xref linkend="firewalls">--> para obtener
	  informaci&oacute;n general sobre c&oacute;mo configurar el 
	  bridge para que act&uacute;e adem&aacute;s como cortafuegos.</para> 

        <para>Si adem&aacute;s queremos que los paquetes que no sean IP (por 
          ejemplo paquetes ARP) puedan atravesar el <quote>bridge</quote> 
          deberemos a&ntilde;adir la opci&oacute;n 
          <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.  Tenga en cuenta 
          opci&oacute;n modifica el comportamiento del cortafuegos de tal 
          forma que por defecto aceptar&aacute; cualquier paquete.  Hay que 
	  tener cuidado para asegurarse de que el comportamiento esperado del 
          cortafuegos, que reside en el conjunto de reglas que se hayan 
          definido, no se vea afectado por este cambio.</para>

      </sect3>

      <sect3>
	<title>Soporte de Conformado de Tr&aacute;fico</title>

	<para>Si se quiere utilizar el <quote>bridge</quote> como un 
	  conformador de tr&aacute;fico, es decir, como un elemento capaz de 
          adaptar los distintos flujos seg&uacute;n determinados patrones, se
          debe a&ntilde;adir la opci&oacute;n 
          <literal>DUMMYNET</literal> a la configuraci&oacute;n del 
          n&uacute;cleo.  Se ruega consultar &man.dummynet.4; para obtener 
          m&aacute;s informaci&oacute;n al respecto.</para> 

      </sect3>
    </sect2>

    <sect2>
      <title>C&oacute;mo Activar el <quote>Bridge</quote></title>

      <para>A&ntilde;adir la l&iacute;nea:</para>

      <programlisting>net.link.ether.bridge=1</programlisting>

      <para>en <filename>/etc/sysctl.conf</filename> para habilitar el 
        soporte de <quote>bridging</quote> en tiempo de ejecuci&oacute;n y la 
        l&iacute;nea:</para>

      <programlisting>net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>Para activar el <quote>bridging</quote> en las interfaces 
        especificadas (sustituya 
	<replaceable>if1</replaceable> y 
	<replaceable>if2</replaceable> con los nombres de sus interfaces de 
        red).  Si deseamos filtrar los paquetes puenteados utilizando 
        &man.ipfw.8;, debemos a&ntilde;adir tambi&eacute;n:</para>

      <programlisting>net.link.ether.bridge_ipfw=1</programlisting>
      
      <para>En &os;&nbsp;5.2-RELEASE y posteriores, se debe utilizar las 
        siguientes l&iacute;neas en lugar de las anteriores:</para>

      <programlisting>net.link.ether.bridge.enable=1
net.link.ether.bridge.config=<replaceable>if1</replaceable>,<replaceable>if2</replaceable>
net.link.ether.bridge.ipfw=1</programlisting>

    </sect2>
    
    <sect2>
      <title>Informaci&oacute;n Adicional</title>

      <para>Si queremos ser capaces de conectarnos al <quote>bridge</quote> 
        mediante &man.telnet.1; se puede asignar una direcci&oacute;n IP a  
        una de las tarjetas de red del <quote>bridge</quote>.  Por amplio 
	consenso se considera una mala idea asignar m&aacute;s de una 
        direcci&oacute;n IP al <quote>bridge</quote>.</para> 

      <para>Si poseemos varios <quote>bridges</quote> en nuestra red 
        s&oacute;lamente puede existir un &uacute;nico camino entre 
        cualesquiera dos m&aacute;quinas de nuestra red.  
	T&eacute;cnicamente hablando esto significa que no existe soporte para 
        gesti&oacute;n de enlace mediante mecanismos basados en 
        &aacute;rboles de recubrimiento m&iacute;nimos (<quote>spanning 
        tree</quote>).</para> 

      <para>Un <quote>bridge</quote> puede a&ntilde;adir latencia a los tiempos 
        de respuesta del comando &man.ping.8;, especialmente cuando 
        el tr&aacute;fico tiene que viajar de un segmento de red al 
        otro.</para> 
      
    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>Reorganizado y ampliado por </contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>NFS</title>

    <indexterm><primary>NFS</primary></indexterm>
    <para>FreeBSD soporta diversos sistemas de ficheros, uno de los 
      cuales es el Sistema de Ficheros en Red, tamb&iacute;en conocido 
      por su acr&oacute;nimo en ingl&eacute;s <acronym>NFS</acronym>.  
      <acronym>NFS</acronym> permite compartir directorios y ficheros a 
      trav&eacute;s de la red.  Los usuarios del sistema <acronym>
      NFS</acronym> pueden acceder a ficheros que se encuentran 
      f&iacute;sicamente en m&aacute;quinas remotas de una forma 
      transparente, como si se tratara de ficheros locales.</para>
 
    <para>He aqu&iacute; algunos los beneficios m&aacute;s destacados que
      <acronym>NFS</acronym> proporciona:</para> 

    <itemizedlist>
      <listitem>
	<para>Las estaciones de trabajo locales utilizan menos espacio de 
          disco debido a que los datos se encuentran centralizados en un 
          &uacute;nico lugar pero pueden ser accedidos y modificados por 
          varios usuarios, de tal forma que no es necesario replicar la 
          informaci&oacute;n.</para> 
      </listitem>

      <listitem>
	<para>Los usuarios no necesitan disponer de un directorio <quote>
	  home</quote> en cada una de las m&aacute;quinas de la 
          organizaci&oacute;n.  Los directorios <quote>home</quote> pueden 
          crearse en el servidor de <acronym>NFS</acronym> para posteriormente 
	  poder acceder a ellos desde cualquier m&aacute;quina a trav&eacute;s 
          de la infraestrutura de red.</para> 
      </listitem>

      <listitem>
	<para>Tambi&eacute;n se pueden compartir a trav&eacute;s de la red 
          dispositivos de almacenamiento como disqueteras, CDROM y unidades 
          ZIP.  Esto puede reducir la inversi&oacute;n en dichos dispositivos 
          y mejorar el aprovechamiento del hardware existente en la 
          organizaci&oacute;n.</para> 
      </listitem>
    </itemizedlist>

    <sect2>
      <title>C&oacute;mo Funciona <acronym>NFS</acronym></title>

      <para>El sistema <acronym>NFS</acronym> est&aacute; dividido al menos en 
        dos partes principales: un servidor y uno o m&aacute;s clientes.  
        Los clientes acceden de forma remota a los datos que se encuentran 
        almacenados en el servidor.  Para que el sistema funcione 
        correctamente se deben configurar y ejecutar unos cuantos 
        procesos.</para>

      <note><para>En &os; 5.X se ha reemplazado <application>
          portmap</application> por <application>rpcbind</application>.  
          de esta forma para los ejemplos que vamos a comentar a 
          continuaci&oacute;n se recuerda que en &os; 5.X se debe reemplazar 
          cualquier instancia de <application>portmap</application> por  
          <application>rpcbind</application>.</para></note> 

      <para>El servidor de <acronym>NFS</acronym> debe ejecutar los siguientes 
        d&aelig;mones:</para> 
      <indexterm>
        <primary>NFS</primary>
        <secondary>server</secondary>
      </indexterm>
      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>mountd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>D&aelig;mon</entry>
	      <entry>Descripci&oacute;n</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><application>nfsd</application></entry>
	      <entry>El d&aelig;mon<acronym>NFS</acronym>, que atiende 
                peticiones de clientes <acronym>NFS</acronym>.</entry>
              
	    </row>
	    <row>
	      <entry><application>mountd</application></entry>
	      <entry>El d&aelig;mon de montaje de <acronym>NFS</acronym>, 
                que transporta las peticiones que &man.nfsd.8; realiza.</entry>
	    </row>
	    <row>
	      <entry><application>portmap</application></entry>
	      <entry> El d&aelig;mon portmapper permite que los clientes 
                <acronym>NFS</acronym> puedan descubrir qu&eacute; puerto  
                est&aacute; utilizando el servidor de 
                <acronym>NFS</acronym>.</entry> 
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>El cliente tambi&eacute;n puede ejecutar un d&aelig;mon conocido ,
        como <application>nfsiod</application>.  El d&aelig;mon  
        <application>nfsiod</application> atiende las peticiones provinientes 
        del servidor <acronym>NFS</acronym>.  Este d&aelig;mon  es opcional y 
	sirve para mejorar el rendimiento pero no es necesario para el 
        funcionamiento correcto del sistema.  Se recomienda consultar 
        &man.nfsiod.8; para obtener m&aacute;s informaci&oacute;n.</para>

    </sect2>

    <sect2 id="network-configuring-nfs">
      <title>Configuraci&oacute;n de  <acronym>NFS</acronym></title>
      <indexterm>
        <primary>NFS</primary>
        <secondary>configuration</secondary>
      </indexterm>

      <para>La configuraci&oacute;n de <acronym>NFS</acronym> es un proceso 
        relativamente sencillo.  Para que los procesos anteriormente descritos 
        se ejecuten en tiempo de arranque del sistema, basta con realizar 
        paque&ntilde;as modificaciones en <filename>/etc/rc.conf</filename>.
        </para> 

      <para>En <filename>/etc/rc.conf</filename> del servidor de 
        <acronym>NFS</acronym> se deben configurar las siguientes opciones:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</programlisting>

      <para><application>mountd</application> se ejecuta 
        autom&aacute;ticamente cuando se activa el servidor 
        <acronym>NFS</acronym>.</para>

      <para>En el cliente debemos asegurarnos de que se encuentra activada la 
        activada la siguiente opci&oacute;n dentro de <filename>
        /etc/rc.conf</filename>:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para>El archivo <filename>/etc/exports</filename> especifica los 
        directorios o sistemas de ficheros que <acronym>NFS</acronym> exporta 
        al exterior.  Cada l&iacute;nea dentro de <filename>
	/etc/exports/</filename> especifia un sistema de ficheros y qu&eacute;  
        m&aacute;quinas tienen derechos de acceso sobre dicho sistema.  
        Adem&aacute;s de los derechos de acceso se pueden definir otras 
        opciones de acceso, tales como solo lectura o lectura y escritura.  
        Existen multitud de opciones que pueden definirse sobre un directorio 
        exportable pero en este manual s&oacute;lo se van a comentar unas 
        pocas.  Consulte &man.exports.5; para obtener una descripci&oacute;n 
        m&aacute;s detallada.</para> 

      <para>Aqu&iacute; se muestran algunos ejemplos de entradas para 
        <filename>/etc/exports</filename>:</para> 

      <indexterm>
        <primary>NFS</primary>
        <secondary>export examples</secondary>
      </indexterm>

      <para>El siguiente ejemplo proporciona una idea de c&oacute;mo exportar 
        sistemas de ficheros, aunque los par&aacute;metros pueden diferir  
        dependiendo de su entorno y su configuraci&oacute;n de red.  En dicho 
        ejemplo, se  exporta el directorio <filename>/cdromm</filename> a tres 
        m&aacute;quinas que se encuentran en el mismo dominio que el servidor  
        (de ah&iacute; que no se especifique ning&uacute;n nombre de dominio 
        para cada m&aacute;quina) o que pueden estar dadas de alta en 
        <filename>/etc/hosts</filename>.  En cualquier caso la opci&oacute;n 
        <option>-ro</option> configura el sistema de ficheros de red como 
        <quote>s&oacute;lo lectura</quote> (<quote>read-only</quote>).  
	Con esta opci&oacute;n los sistemas remotos no ser&aacute;n capaces 
        de realizar cambios sobre el sistema de ficheros exportados.</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>La siguiente l&iacute;nea exporta el directorio 
        <filename>/home</filename> a tres m&aacute;quinas utilizando 
        direcciones IP.  Esto resulta &uacute;til cuando disponemos de una red 
        privada pero no disponemos de ning&uacute;n servidor de 
        <acronym>DNS</acronym> configurado.  Tambi&eacute;n se podr&iacute;a 
        configurar <filename>/etc/hosts</filename> para que resolviera 
        nombres de m&aacute;quinas internos; consulte &man.hosts.5; para 
        obtener m&aacute;s informaci&oacute;n al respecto.  La opci&oacute;n 
        <option>-alldirs</option> permite que los subdirectorios del 
        directorio <filename>/home</filename> tamb&iacute;en se puedan utilizar 
        como puntos de montaje.  En otras palabras, esto permite que los 
        clientes puedan trabajar sobre los subdirectorios en los que 
        est&eacute;n realmente interesados.</para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>La siguiente l&iacute;nea exporta el directorio 
        <filename>/a</filename> de tal forma que puedan acceder a dicho 
        directorio dos m&aacute;quinas situadas en distintos dominios.  La 
        opci&oacute;n  <option>-maproot=root</option> permite que el usuario 
        <username>root</username> de la m&aacute;quina cliente modifique los 
        datos del sistema de ficheros en red como si fuera el usuario 
        <username>root</username> del servidor.  Si no se especifica la 
        opci&oacute;n <option>-maproot=root</option> el usuario 
        <username>root</username> del cliente puede no poseer los permisos  
        necesarios para realizar modificaciones en el sistema de 
	ficheros.</para>

      <programlisting>/a  -maproot=root  host.example.com box.example.org</programlisting>

      <para>Para que un cliente pueda acceder al sistema de ficheros exportado 
        debe poseer permisos para ello.  Debemos asegurarnos de que el cliente 
        se encuentra listado en <filename>/etc/exports</filename>.</para>

      <para>Dentro de <filename>/etc/exports</filename> cada l&iacute;nea 
        representa informaci&oacute;n de exportaci&oacute;n de un sistema de 
        ficheros para un determinado conjunto de m&aacute;quinas.  Una 
        m&aacute;quina s&oacute;lo  puede aparecer una vez dentro de un 
        sistema de ficheros exportable y el archivo s&oacute;lo puede tener 
        una &uacute;nica entrada por defecto.  Por ejemplo, si suponemos que 
        <filename>/usr</filename> es un &uacute;nico sistema de ficheros la 
        siguiente configuraci&oacute;n de <filename>/etc/exports</filename> 
        ser&iacute;a incorrecta:</para> 

      <programlisting>/usr/src   client
/usr/ports client</programlisting>

      <para>Existe un sistema de ficheros, concretamente
        <filename>/usr</filename>, que posee dos l&iacute;neas con reglas de 
        exportaci&oacute;n para la misma m&aacute;quina, 
        <hostid>client</hostid>. El formato correcto para esta 
        situaci&oacute;n ser&iacute;a el siguiente:</para>  

      <programlisting>/usr/src /usr/ports  client</programlisting>

      <para>Las propiedades de un sistemas de ficheros que se exporta al 
        exterior deben aparecer agrupadas bajo la misma l&iacute;nea.  
        L&iacute;neas que no poseen ning&uacute;n cliente se tratan como si 
        tuvieran una &uacute;nica m&aacute;quina.  Esto limita la forma en que 
        pueden configurarse la exportaciones de sistemas de ficheros pero para  
        la mayor&iacute;a de la gente no suele ser un problema.</para>

      <para>El ejemplo que se muestra a continuaci&oacute;n es una muestra de 
        una lista de exportaci&oacute;n correcta, donde <filename>
        /usr</filename> y <filename>/exports</filename> son sistemas de 
        ficheros locales:</para>	 

      <programlisting># Exportar src y ports a cliente01 y cliente02, pero 
# solo el cliente01 tiene acceso root
/usr/src /usr/ports -maproot=root    cliente01
/usr/src /usr/ports               cliente02
# Las maquinas cliente tienen acceso root y pueden montar todo lo que aparezca 
# en /exports.  Cualquier sistema puede montar /exports/obj en modo
# solo lectura
/exports -alldirs -maproot=root      cliente01 cliente02
/exports/obj -ro</programlisting>

      <para>Se debe reiniciar el d&aelig;mon <application>mountd</application>  
        siempre que se modifique el contenido del archivo 
        <filename>/etc/exports</filename> para que los cambios surtan efecto.  
        Esto se realiza enviando la se&ntilde;al HUP al proceso 
        <command>mountd</command>:</para> 

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>Tambi&eacute;n se puede reiniciar FreeBSD para que se cargue la 
        nueva configuraci&oacute;n pero este mecanismo no resulta necesario 
        si se ejecutan los siguientes comandos como 
        <username>root</username>, los cuales ponen el servidor de 
        <acronym>NFS</acronym> de nuevo en funcionamiento.</para>
      
      <para>En el servidor de <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>En el cliente de <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>En este punto todo deber&iacute;a estar preparado para 
        poder anclar el sistema de ficheros remoto en la m&aacute;quina 
        cliente.  En los siguientes ejemplos el nombre del servidor es 
        <hostid>server</hostid> y el punto de montaje temporal utilizado 
        por el cliente es <hostid>client</hostid>.  Si se desea montar el 
        sistema de ficheros de forma temporal o simplemente comprobar que la 
        configuraci&oacute;n funciona sin problemas se puede ejecutar un 
        comando como el que se muestra a continuaci&oacute;n con permisos 
        de <username>root</username> en la m&aacute;quina cliente:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>mounting</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>Este comando ancla el directorio 
        <filename>/home</filename> del servidor en el directorio  
        <filename>/mnt</filename> del cliente.  Si todo funciona correctamente 
        deber&iacute;a poder entrar en el directorio 
        <filename>/mnt</filename> del cliente y ver todos los ficheros que se 
        encuentran en el directorio <filename>/home</filename> del servidor.
        </para> 

      <para>Si queremos anclar autom&aacute;ticamente un sistema de ficheros 
        remoto cuando la m&aacute;quina est&aacute; arrancando se puede 
        a&ntilde;adir una l&iacute;nea como la siguiente dentro de 
        <filename>/etc/fstab</filename>:</para> 

      <programlisting>servidor:/home	/mnt	nfs	rw	0	0</programlisting>

      <para>&man.fstab.5; comenta todas las opciones disponibles.</para>
    </sect2>

    <sect2>
      <title>Usos Pr&aacute;cticos</title>
 
      <para>El protocolo <acronym>NFS</acronym> tiene m&uacute;ltiples  usos 
        pr&aacute;cticos.  Los m&aacute;s t&iacute;picos se enumeran a 
        continuaci&oacute;n:</para> 

      <indexterm>
        <primary>NFS</primary>
        <secondary>uses</secondary>
      </indexterm>
      <itemizedlist>
        <listitem>
	  <para>Compartici&oacute;n de la unidad de CDROM entre varias 
            m&aacute;quinas.  Esto resulta ser m&aacute;s barato y una forma 
            m&aacute;s conveniente para instalar software en varias 
            m&aacute;quinas.</para>
	</listitem>

	<listitem>
	  <para>En grandes redes puede ser m&aacute;s adecuado configurar un 
            servidor central de <acronym>NFS</acronym> en el cual se 
            almacenen todos los <quote>homes</quote> de los distintos 
            usuarios.  Estos directorios se pueden exportar a trav&eacute;s de 
            la red de tal forma que los usuarios pueden trabajar con el mismo 
            directorio independientemente de la m&aacute;quina que utilicen.
            </para>
	</listitem>

	<listitem>
	  <para>Varias m&aacute;quinas pueden poseer el directorio 
            <filename>/usr/ports/distfiles</filename> compartido.  De 
            este modo cuando necesitemos instalar un port en varias 
            m&aacute;quinas, se puede acceder r&aacute;pidamente a las fuentes 
            sin necesidad de bajarlas una vez para cada m&aacute;quina.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Escrito por </contrib>
	  </author>
	</authorgroup>
	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>Reescrito por </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Anclajes Autom&aacute;ticos usando <application>amd</application></title>

      <indexterm><primary>amd</primary></indexterm>
      <indexterm><primary>automatic mounter daemon</primary></indexterm>

      <para>El d&aelig;mon &man.amd.8; (<quote>the automatic mounter 
        daemon</quote>, o d&aelig;mon de montaje autom&aacute;tico) 
	autom&aacute;ticamente ancla un sistema de ficheros remoto cuando se 
        tiene que acceder a un fichero perteneciente a dicho sistema. Los 
	sistemas de ficheros que permanecen inactivos durante un determinado 
        periodo de tiempo son autom&aacute;ticamente desmontados por el mismo 
        d&aelig;mon.  Este d&aelig;mon proporciona una alternativa sencilla a 
        la utilizaci&oacute;n de los montajes permanentes que normalmente se 
        especifican a trav&eacute;s del fichero <filename>
        /etc/fstab</filename>.</para> 
  
       <para><application>amd</application> trabaja actuando como un servidor 
        servidor de NFS para los directorios 
        <filename>/host</filename> y <filename>/net</filename>.  Cuando se 
        accede a alg&uacute;n fichero ubicado bajo estos directorios  
        <application>amd</application> busca el punto de montaje remoto y 
        autom&aacute;ticamente lo monta.  El directorio <filename>
        /net</filename> se utiliza para anclar sistemas de ficheros remotos 
        especificados mediante direcciones IP, mientras que el directorio 
        <filename>/host</filename> almacena aquellos sistemas de ficheros 
        remotos que han sido especificados mediante un nombre de 
        m&aacute;quina.</para> 

      <para><application>amd</application> detecta cualquier intento
        de acceder a un fichero dentro del directorio  
	<filename>/host/foobar/usr</filename> y se encarga de montar
        el sistema de ficheros remoto (<filename>/usr</filename>) 
        en la m&aacute;quina, en caso de que no estuviera ya
        anclado.</para> 

      <example>
	<title>Anclaje de una Exportaci&oacute;n utilizando
          <application>amd</application></title> 

	<para>El comando <command>showmount</command> muestra los 
          puntos de montaje que posee una m&aacute;quina remota. Por ejemplo 
          para conocer los montajes de un m&aacute;quina llamada 
          <hostid>foobar</hostid>, se puede utilizar:</para> 

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>Como se observa en el ejemplo, el comando
        <command>showmount</command> muestra el directorio
        <filename>/usr</filename> 
        como una exportaci&oacute;n.  Cuando se cambia el directorio actual 
        al directorio <filename>/host/foobar/usr</filename> el d&aelig;mon 
        <application>amd</application> intenta resolver el nombre 
        <hostid>foobar</hostid> y autom&aacute;ticamente ancla el sistema 
        de ficheros remoto.</para>

      <para>El d&aelig;mon <application>amd</application> se puede ejecutar 
        a partir de los scripts de inicio, utilizando la siguiente 
        l&iacute;nea del archivo de configuraci&oacute;n 
        <filename>/etc/rc.conf</filename>:</para> 

      <programlisting>amd_enable="YES"</programlisting>

      <para>Adem&aacute;s, <application>amd</application> soporta opciones 
        adicionales que pueden definirse mediante la variable 
      <varname>amd_flags</varname>. Por defecto, la variable 
        <varname>amd_flags</varname> posee las siguientes opciones:</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para>El archivo <filename>/etc/amd.map</filename> define las opciones 
        por defecto con las cuales se anclan los sistemas de ficheros  
        remotos. El archivo <filename>/etc/amd.conf</filename> define algunas 
        caracter&iacute;sticas avanzadas para el d&aelig;mon 
        <application>amd</application>.</para> 

      <para>Se ruega consultar las p&aacute;ginas del manual de &man.amd.8; y 
        de &man.amd.conf.5; para obtener m&aacute;s informaci&oacute;n.</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>John</firstname>
            <surname>Lind</surname>
            <contrib>Escrito por  </contrib>
          </author>
        </authorgroup>
      </sect2info>
      <title>Problemas de Integraci&oacute;n con Otras Plataformas</title>

      <para>Determinados adaptadores Ethernet para sistemas basados en 
        el bus ISA poseen restricciones que pueden producir serios problemas 
        de red, en particular con el protocolo NFS.  Estos problemas no son 
        espec&iacute;ficos de FreeBSD, pero los sistemas &os; se ven 
        afectados por ellos.</para> 

      <para>El problema surge casi siempre cuando el sistema (&os;) 
        est&aacute; empotrado dentro de una red compuesta por estaciones de 
        trabajo de alto rendimiento, como por ejemplo estaciones de Silicon 
        Graphics y de Sun Microsystems.  El montaje del sistema de ficheros 
        remoto suele funcionar perfectamente y algunas operaciones sobre el 
        el sistema de ficheros pueden tener &eacute,xito pero de repente el 
        el servidor que no responde a las peticiones del cliente, aunque 
        peticiones y respuestas de otros clientes funcionan con normalidad y 
        se contin&uacute;an procesando.  Esto sucede en los sistemas clientes, 
        tanto en sistemas FreeBSD como en otras estaciones de trabajo.  
        En muchos sistemas, lo &uacute;nico que se puede hacer es resetear 
        la m&aacute;quina de forma abrupta, ya que el bloqueo producido por el 
        protocolo NFS no se puede solucionar.</para> 

      <para>Aunque la soluci&oacute;n <quote>correcta</quote> consiste en 
        obtener un adaptador Ethernet con mayor rendimiento y capacidad, 
        todav&iacute;a se puede aplicar un parche sencillo que puede llegar a 
        permitir un funcionamiento sin problemas. Si el sistema FreeBSD 
        act&uacute;a como servidor de <emphasis>NFS</emphasis> se puede 
        inclu&iacute;r la opci&oacute;n <option>w=1024</option> cuando el 
        ejecute una petici&oacute;n de montaje sobre dicho servidor.  Si &os; 
        dicho servidor. Si &os; act&uacute;a como cliente de  
        <emphasis>NFS</emphasis>, se puede ejecutar &man.mount.8; con el 
        par&aacute;metro <option>-r=1024</option>.  Estas opciones se pueden 
        especificar en el <filename>/etc/fstab</filename> del cliente para que 
	entren en funcionamiento cuando se realicen montajes 
        autom&aacute;ticos y tambi&eacute;n se puede utilizar el 
	par&aacute;metro <option>-o</option> de &man.mount.8; cuando se 
        realicen montajes manuales.</para>        

      <para>Resulta apropiado resaltar que existe un problema totalmente 
        distinto que algunas veces se confunde con el que acabamos de 
        describir, que aparece cuando el servidor y los clientes se encuentran 
        en redes diferentes. Si nos encontramos en esta situaci&oacute;n 
        debemos <emphasis>asegurarnos</emphasis> de que nuestros <quote>
	routers</quote> est&aacute;n encaminando correctamente los paquetes 
        UDP que genera el protocolo <acronym>NFS</acronym> pues en caso 
	contrario el sistema no funcionar&aacute;, independientemente de los 
        ajustes que se realicen en el cliente o en el servidor.</para> 

      <para>En los siguientes ejemplos <hostid>fastws</hostid> es el nombre de 
        una estaci&oacute;n de trabajo de altas prestaciones y <hostid>
	freebox</hostid> es el nombre de un sistema &os; con un adaptador 
        Ethernet de bajas prestaciones.  Se pretende adem&aacute;s exportar el 
        directorio <filename>/sfcompartido</filename> (ver &man.exports.5;) y 
        el directorio <filename>/projecto</filename>.  Tenga en cuenta que en 
        cualquier caso puede resultar &uacute;til definir opciones adicionales 
        a las que que se muestran en el siguiente ejemplo, como pueden ser 
        <option>hard</option>, <option>soft</option> o
        <option>bg</option>.  Esto depender&aacute; de la aplicaci&oacute;n 
        que utilice el sistema de ficheros remoto.</para> 

      <para>Ejemplos de configuraci&oacute;n para el sistema &os; 
        (<hostid>freebox</hostid>) que act&uacute;a como cliente. 
        Configuraci&oacute;n del archivo
        <filename>/etc/fstab</filename> de
        <hostid>freebox</hostid>:</para> 

      <programlisting>fastws:/sfcompartido /projecto nfs rw,-r=1024 0 0</programlisting>

      <para>Comando de ejecuci&oacute;n manual para
        <hostid>freebox</hostid>:</para> 

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sfcompartido /projecto</userinput></screen>

      <para>Ejemplos de configuraci&oacute;n para el sistema &os; que 
        act&uacute;a como servidor. Configuraci&oacute;n de 
        <filename>/etc/fstab</filename> de <hostid>fastws</hostid>:</para>

      <programlisting>freebox:/sfcompartido /projecto nfs rw,-w=1024 0 0</programlisting>

      <para>Comando de ejecuci&oacute;n manual para
        <hostid>fastws</hostid>:</para> 

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sfcompartido /projecto</userinput></screen>

      <para>Casi cualquier adaptador Ethernet de 16 bits permite operar sin 
        operar sin las restricciones anteriores sobre el tama&ntilde;o de 
        lectura o escritura especificado por defecto.</para>

      <para>Por si alguien estuviera interesado a continuaci&oacute;n se 
        muestra el error que aparece en estos casos, lo cual explica por 
        qu&eacute; decimos que el error resulta irrecuperable.  NFS trabaja 
        t&iacute;picamente con un tama&ntilde;o de <quote>bloque</quote> 
        de 8&nbsp;K (aunque se pueden producir fragmentos de menor 
        tama&ntilde;o).  Debido a que el m&aacute;ximo tama&ntilde;o de los 
        paquetes Ethernet se encuentra alrededor de los 1500&nbsp;bytes el 
        <quote>bloque</quote> de NFS se trocea en varios paquetes Ethernet 
        aunque desde el punto de vista del protocolo NFS se trata como si 
        fuese un &uacute;nico paquete.  Los trozos deben reensamblarse en el 
        destino y se debe enviar una <emphasis>confirmaci&oacute;n</emphasis> 
        para el bloque recibido.  Las estaciones de trabajo de altas 
	prestaciones pueden soltar paquetes NFS de forma cont&iacute;nua uno 
        despu&eacute;s de otro, lo m&aacute;s juntos posible.  Por otro lado 
        en las tarjetas de red m&aacute;s peque&ntilde;as y de menor 
        capacidad puede ocurrir que un paquete recien llegado a la tarjeta 
        sobreescriba informaci&oacute;n perteneciente a un paquete anterior  
        antes de que llegue a ser transmitido completamente, de tal forma que 
	al recibirse el bloque NFS no puede ser ni reconstruido ni 
        ni reconocido.  Como resultado de este proceso la m&aacute;quina 
        tratar&aacute; de enviar el mismo paquete transcurridos unos instantes 
        de espera, pero se tratar&aacute;n de enviar de nuevo los 8&nbsp;K 
        que constituyen un bloque NFS, y de esta forma se repetir&aacute; el 
        el proceso, as&iacute; hasta el infinito.</para>

      <para>Si se mantiene el tama&ntilde;o del bloque por debajo del
        tama&ntilde;o de paquete m&aacute;ximo de Ethernet, podemos asegurar 
        que cualquier paquete Ethernet transporta un bloque NFS, el cual 
        puede asentirse individualmente, evitando as&iacute; la 
        explosi&oacute;n de paquetes y el eventual bloqueo del sistema.</para>

      <para>Desbordamientos circulares del <quote>buffer</quote> (<quote>
        overruns</quote>) pueden producirse si nos encontramos con una 
        estaci&oacute;n de trabajo de altas prestaciones que env&iacute;a 
        cont&iacute;nuamente mucho tr&aacute;fico a un sistema convencional, 
	pero con tarjetas Ethernet de buena calidad, estos desbordamientos 
        resultan altamente improbables para el caso de los tama&ntilde;os de 
	bloque por defecto generados por el sistema NFS.  Cuando se produce un 
        desbordamiento, las unidades afectadas se retransmiten, y 
        existe una gran probabilidad de que se reciban, se reensamblen 
        y se confirmen.</para> 
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Jean-Fran&ccedil;ois</firstname>
          <surname>Dock&egrave;s</surname>
          <contrib>Actualizado por </contrib>
        </author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Dupre</surname>
	  <contrib>Reorganizado y ampliado por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Ejecuci&oacute;n sin Disco Duro</title>

    <indexterm><primary>diskless workstation</primary></indexterm>
    <indexterm><primary>diskless operation</primary></indexterm>

    <para>Una m&aacute;quina &os; se puede arrancar a trav&eacute;s 
      de la red y operar sin que necesite poseer ning&uacute;n disco, 
      utilizando sistemas de ficheros de un servidor de 
      <acronym>NFS</acronym>. No se necesita realizar ninguna 
      modificaci&oacute;n al sistema, salvo configurar determinados ficheros.  
      Este tipo de sistemas se pueden configurar f&aacute;cilmente puesto 
      que &os; dispone de todos los elementos necesarios:</para>

    <itemizedlist>
      <listitem>
	<para>Existen al menos dos formas de cargar el n&uacute;cleo 
          del sistema operativo a trav&eacute;s de la red:</para> 
	<itemizedlist> 
	  <listitem>
	    <para><acronym>PXE</acronym>: El sistema de &intel; conocido como 
              Preboot Execution Environment.  Se trata de una especie de 
              arranque inteligente a partir de una memoria de s&oacute;lo 
              lectura (ROM) que se encuentra en algunas placas bases y 
              tarjetas de red.  Se puede obtener m&aacute;s informaci&oacute;n 
	      en &man.pxeboot.8;.</para>
	  </listitem>
	  <listitem>
	    <para>El port <application>etherboot</application>
	      (<filename role="package">net/etherboot</filename>)
              genera c&oacute;digo de s&oacute;lo lectura (c&oacute;digo ROM) 
              que se puede utilizar para arrancar m&aacute;quinas a 
	      trav&eacute;s de la red.  Dicho c&oacute;digo se puede instalar 
              en una memoria de arranque tipo PROM en algunas tarjetas de red 
              o se puede cargar en una disquetera (o disco duro), y 
              tambi&eacute;n en un sistema de ficheros &ms-dos; que 
              est&eacute; en ejecuci&oacute;n.  Varias tarjetas de red soportan
	      este mecanismo.</para>
	  </listitem>
	</itemizedlist>
	</listitem>

      <listitem>
	<para>Existe un script de ejemplo 
	  (<filename>/usr/share/examples/diskless/clone_root</filename>) que 
          facilita la creaci&oacute;n y el mantenimiento del sistema de 
          ficheros ra&iacute;z de la estaci&oacute;n de trabajo en el 
          servidor.  La configuraci&oacute;n de este <quote>script</quote> se 
          debe retocar ligeramente pero sirve como punto de partida para 
          comenzar r&aacute;pidamente.</para> 
      </listitem>

      <listitem>
        <para>Existen ficheros est&aacute;ndar de arranque bajo 
          <filename>/etc</filename> que dan soporte al arranque de 
          m&aacute;quinas sin disco.</para> 
      </listitem>

      <listitem>
	<para>El <quote>swapping</quote>, en caso de ser necesario, se puede 
          realizar usando <acronym>NFS</acronym> y tamb&iacute;en 
          usando un disco duro local.</para>
      </listitem>
    </itemizedlist>

    <para>Existen varias formas de ejecutar una estaci&oacute;n de trabajo sin 
      discos.  En el proceso se involucran distintos elementos y la 
      mayor&iacute;a se pueden adaptar a las necesidades del usuario.  
      A continuaci&oacute;n se describen variaciones sobre la 
      configuraci&oacute;n de un sistema sin discos, haciendo incapi&eacute; 
      en la simplicidad y compatibilidad con los <quote>scripts</quote> de 
      arranque de &os;.  El sistema que vamos a describir tiene las 
      siguientes caracter&iacute;sticas.</para> 
 
    <itemizedlist>
      <listitem>
        <para>Las estaciones de trabajo sin disco utilizan un sistema 
          de ficheros <filename>ra&iacute;z</filename> de s&oacute;lo lectura 
          y un sistema de ficheros compartido, tambi&eacute;n de 
          s&oacute;lo lectura, bajo <filename>/usr</filename>.</para> 


        <para>El sistema de ficheros <filename>ra&iacute;z</filename>
          es una copia del sistema ra&iacute;z estandar de &os; (normalmente 
          del sistema ra&iacute;z del servidor), donde se sobreescriben 
          algunos archivos de configuraci&oacute;n necesarios para la 
          ejecuci&oacute;n sin discos y para la configuraci&oacute;n local 
          espec&iacute;fica de la m&aacute;quina objetivo.</para> 
 
        <para>Las partes del sistema de ficheros 
          <filename>ra&iacute;z</filename> que tiene que tener permisos de 
          lectura y escritura se superponen con los sistemas de ficheros 
          &man.mfs.8; (&os;&nbsp;4.X) o &man.md.4;.  Cualquier cambio que se 
          produzca en dichas partes se perder&aacute; cuando se reinicie el 
          sistema.</para> 
      </listitem>
      <listitem>
	<para>El n&uacute;cleo se transmite y se carga utilizando 
	  <application>etherboot</application> o bien 
          <acronym>PXE</acronym>, dependiendo del hardware y los mecanismos 
          que se soporten.</para>
      </listitem>
    </itemizedlist>

    <caution><para>Como se ha comentado con anterioridad estos sistemas son 
        inseguros.  Se debe confinar dentro de una red protegida y el resto 
        de las m&aacute;quinas por defecto no deben confiar en estos 
	m&eacute;todos.</para> 
    </caution>

    <para>Toda la informaci&oacute;n que se presenta en esta 
      secci&oacute;n se ha probado utilizando &os; 4.9-RELEASE y 
      5.2.1-RELEASE.  El texto se encuentra estructurado principalmente para 
      utilizaci&oacute;n en sistemas 4.X.  Se insertan notas para indicar 
      cambios producidos en las versiones 5.X.</para>

    <sect2>
      <title>Conocimientos Previos</title>

      <para>Configurar estaciones de trabajo sin discos es una 
        operaci&oacute;n relativamente sencilla pero en la que pueden 
        cometerse errores.  Estos errores resultan algunas veces  
        dif&iacute;ciles de diagnosticar debido a razones que vamos a 
        exponer a continuaci&oacute;n. Por ejemplo:</para> 

      <itemizedlist>
	<listitem>
	  <para>Diferentes opciones de tiempo de compilaci&oacute;n pueden 
            determinar comportamientos distintos en tiempo de 
            ejecuci&oacute;n.</para> 
	</listitem> 

	<listitem>
	  <para>Los mensajes de error a menudo resultan cr&iacute;pticos o 
            incluso no existen.</para> 
	</listitem>
      </itemizedlist>

      <para>Se se quieren resolver los posibles problemas que puedan surgir 
        resulta muy &uacute;til conocer el funcionamiento conceptual del 
        mecanismo.</para> 

      <para>Para que el arranque se produzca exitosamente se deben realizar 
        varias operaciones:</para> 
        
      <itemizedlist>
	<listitem>
          <para>La m&aacute;quina necesita obtener algunos 
            par&aacute;metros iniciales, tales como su direcci&oacute;n IP, 
            el fichero ejecutable, el nombre del servidor y la ruta 
            ra&iacute;z.  Esto se realiza utilizando los protocolos 
            <acronym>DHCP</acronym> o <acronym>BOOTP</acronym>.  
            <acronym>DHCP</acronym> es una extensi&oacute;n compatible del 
            protocolo <acronym>BOOTP</acronym> y utiliza los mismos 
            n&uacute;meros de puertos y los mismos formatos de paquete 
            b&aacute;sicos.</para> 
           
          <para>Es posible configurar un sistema de tal forma que utilice 
            s&oacute;lamente <acronym>BOOTP</acronym>.  En el sistema base de 
            &os; se incluye el programa servidor &man.bootpd.8;.</para>

          <para>No obstante <acronym>DHCP</acronym> posee varias ventajas sobre 
            BOOTP (archivos de configuraci&oacute;n m&aacute;s limpios, 
            posibilidad de ejecutar <acronym>PXE</acronym>, junto con otras 
	    caracter&iacute;sticas  que no se relacionan directamente con el  
            tema que estamos tratando tratando) por lo que principalmente se 
            va a describir la configuraci&oacute;n de <acronym>DHCP</acronym>, 
            proporcionando ejemplos equivalentes en &man.bootpd.8; siempre que 
            sea posible.  La configuraci&oacute;n de ejemplo se basa en el 
            paquete software de <application>ISC DHCP</application> (en el 
            servidor de prueba se instal&oacute; la versi&oacute;n 
            3.0.1.r12).</para> 
	</listitem> 

	<listitem>
          <para>La m&aacute;quina sin disco necesita transferir uno o varios 
            programas a la memoria local.  Para ello se usa 
            <acronym>TFTP</acronym> o bien <acronym>NFS</acronym>.  
            La elecci&oacute;n entre ambos se produce mediante la  
            configuraci&oacute;n de la compilaci&oacute;n que se produce en 
            varios lugares.  Una fuente de error t&iacute;pica aparece cuando 
            se especifican ficheros con el protocolo incorrecto:  
            <acronym>TFTP</acronym> normalmente transfiere todos los ficheros 
            desde un &uacute;nico directorio del servidor, de modo que espera 
            nombres de ficheros relativos a dicho directorio.  Por otro lado 
            <acronym>NFS</acronym> necesita recibir rutas de fichero 
            absolutas.</para> 

	</listitem>

	<listitem>
	  <para>El kernel y los programas de arranque intermedios deben ser 
	    inicializados y ejecutados.  Existen diferencias importantes en 
	    este &aacute;rea:</para>

	  <itemizedlist>
	    <listitem>
	      <para><acronym>PXE</acronym> carga &man.pxeboot.8;, una 
                versi&oacute;n modificada de la tercera fase del cargador de 
                arranque de &os;.  &man.loader.8; obtiene la mayor&iacute;a de 
                los par&aacute;metros necesarios para arrancar el sistema 
                y los deposita en variables de entorno del kernel antes de 
                tranferir el control. En este caso es posible utilizar un 
                un n&uacute;cleo <filename>GENERIC</filename>
                .</para>            
	    </listitem>

	    <listitem>
	      <para><application>etherboot</application> carga directamente el 
                directamente el n&uacute;cleo con menos trabajo previo que 
                el m&eacute;todo anterior.  Para ello se debe compilar un 
                n&uacute;cleo con ciertas opciones.</para>
	    </listitem>
	  </itemizedlist>

	  <para><acronym>PXE</acronym> y <application>etherboot</application> 
	    funcionan muy bien en los sistemas 4.X.  Dado que los 
            n&uacute;cleos de los sistemas 5.X permiten que el &man.loader.8; 
            realice m&aacute;s tareas, se prefiere usar <acronym>
	    PXE</acronym>.</para> 

	  <para>Si su <acronym>BIOS</acronym> y su tarjeta de red soportan 
	    <acronym>PXE</acronym> lo normal es utilizarlo.  No obstante se 
            puede arrancar un sistema 5.X utilizando <application>
	    etherboot</application>.</para>
	</listitem>

	<listitem>
	  <para>Para acabar la tarea la m&aacute;quina necesita acceder al 
            sistema de ficheros.  En todos los casos se utiliza 
            <acronym>NFS</acronym>.</para> 
	</listitem>
      </itemizedlist>

      <para>No olvide consultar &man.diskless.8;.</para>
    </sect2>

    <sect2>
      <title>Instrucciones de Configuraci&oacute;n</title>

      <sect3>
	  <title>Configuraci&oacute;n Utilizando <application>ISC
            DHCP</application></title> 
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>diskless operation</secondary>
	  </indexterm>

	  <para>El servidor <application>ISC DHCP</application> puede 
          responder tanto a peticiones de BOOTP como a peticiones de 
            <acronym>DHCP</acronym>.</para> 

	  <para><application>ISC DHCP</application> no forma parte de
          la versi&oacute;n 4.9 de &os; por lo que se debe instalar el port 
            <filename role="package">net/isc-dhcp3-server</filename> o el 
          paquete correspondiente.  Por favor, consulte <xref 
          linkend="ports"> para obtener
          m&aacute;s informaci&oacute;n sobre los ports y los 
          paquetes.</para> 
 
          <para>Una vez que <application>ISC DHCP</application> se encuentra 
          instalado necesita un fichero de configuraci&oacute;n para poder 
            ejecutarse 
          <filename>/usr/local/etc/dhcpd.conf</filename>).  A 
          continuaci&oacute;n se muestra un ejemplo comentado, donde la 
          m&aacute;quina <hostid>margaux</hostid> utiliza 
          <application>etherboot</application> y 
            la m&aacute;quina <hostid>corbieres</hostid> utiliza 
          <acronym>PXE</acronym>:</para> 

          <programlisting>
default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "example.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <co id="co-dhcp-host-name">
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <co id="co-dhcp-next-server">
    filename "/data/misc/kernel.diskless"; <co id="co-dhcp-filename">
    option root-path "192.168.4.4:/data/misc/diskless"; <co id="co-dhcp-root-path">
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename "pxeboot";
    option root-path "192.168.4.4:/data/misc/diskless";
  }
}
          </programlisting>

	  <calloutlist>
	    <callout arearefs="co-dhcp-host-name"><para>Esta 
              opci&oacute;n indica a 
		<application>dhcpd</application> que env&iacute;e el 
              valor que se encuentra en las declaraciones 
                de <literal>host</literal> como el nombre de 
              m&aacute;quina para la m&aacute;quina sin disco.  Otra forma 
              de hacer esto ser&iacute;a a&ntilde;adiendo una opci&oacute;n 
		<literal>option host-name
                <replaceable>margaux</replaceable></literal> dentro de las 
              declaraciones de m&aacute;quina.</para>
	    </callout>

	    <callout arearefs="co-dhcp-next-server"><para>La directiva 
               <literal>next-server</literal> selecciona el servidor 
              de <acronym>TFTP</acronym> o de <acronym>NFS</acronym> 
              que se debe utilizar para cargar el n&uacute;cleo 
              o el fichero cargador del n&uacute;cleo (por defecto se 
              utiliza la misma m&aacute;quina que act&uacute;a como servidor 
              de <acronym>DHCP</acronym>).</para>
	    </callout>

	    <callout arearefs="co-dhcp-filename"><para>La directiva 
		<literal>filename</literal> define el archivo que 
		<application>etherboot</application> o <acronym>PXE</acronym> 
                cargar&aacute; en el siguiente paso de ejecuci&oacute;n.  
                Debe especificarse de acuerdo con el m&eacute;todo de 
                transferencia seleccionado.   
		<application>Etherboot</application> se puede compilar para 
		que use <acronym>NFS</acronym> o <acronym>TFTP</acronym>.  El 
                sistema &os; se configura por defecto para <acronym>
                NFS</acronym>.  
		<acronym>PXE</acronym> utiliza <acronym>TFTP</acronym> por lo 
                que se utiliza una ruta relativa para especificar el nombre del 
                fichero (esto puede depender de la configuraci&oacute;n del 
                servidor de <acronym>TFTP</acronym> pero suele ser lo 
                normal).  Adem&aacute;s <acronym>PXE</acronym> no carga el 
                n&uacute;cleo, lo hace <filename>pxeboot</filename>.  
                Existen otras posibilidades interesantes, como cargar 
		<filename>pxeboot</filename> desde el directorio 
              <filename role="directory">/boot</filename> 
                de una unidad de CD-ROM de &os; (ya que &man.pxeboot.8; puede 
               cargar un n&uacute;cleo 
              <filename>GENERIC</filename> surge la posibilidad de utilizar 
              <acronym>PXE</acronym> para arrancar desde una unidad de 
              CD-ROM remota).</para> 
	    </callout>

	    <callout arearefs="co-dhcp-root-path"><para>La opci&oacute;n 
		<literal>root-path</literal> define la ruta para el 
              sistema de ficheros ra&iacute;z utilizando la notaci&oacute;n 
              t&iacute;pica de <acronym>NFS</acronym>.  Cuando se utiliza 
              <acronym>PXE</acronym>, es posible dejar la 
               direcci&oacute;n IP siempre y cuando no se active la 
              opci&oacute;n del n&uacute;cleo de BOOTP.  El servidor 
              <acronym>NFS</acronym> ser&aacute; en este caso el mismo que el 
              servidor de <acronym>TFTP</acronym>.</para>            
	    </callout>
	  </calloutlist>

      </sect3>
      <sect3>
	  <title>Configuraci&oacute;n utilizando BOOTP</title>
	  <indexterm>
	    <primary>BOOTP</primary>
	    <secondary>diskless operation</secondary>
	  </indexterm>

	  <para>A continuaci&oacute;n se muestra la configuraci&oacute;n 
          equivalente utilizando <application>bootpd</application> 
	    (reducida a un &uacute;nico cliente).  Esta configuraci&oacute;n 
	    se debe situar en <filename>/etc/bootptab</filename>.</para>

	  <para>Por favor, recuerde que  <application>etherboot</application> 
            se debe compilar con la opci&oacute;n espec&iacute;fica de  
	    <literal>NO_DHCP_SUPPORT</literal> para que pueda utilizar BOOTP 
	    y que <acronym>PXE</acronym> <emphasis>requiere</emphasis> 
          <acronym>DHCP</acronym>.  La &uacute;nica ventaja obvia de 
            <application>bootpd</application> es que se encuentra disponible en 
           el sistema base.</para>	     

          <programlisting>
.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100
          </programlisting>
      </sect3>

      <sect3>
	<title>Preparaci&oacute;n de un Programa de Arranque con 
	  <application>Etherboot</application></title>

	<indexterm>
	  <primary>Etherboot</primary>
	</indexterm>

	<para><ulink url="http://etherboot.sourceforge.net">La
            p&aacute;gina web de Etherboot 
	  </ulink> contiene
	  <ulink
            url="http://etherboot.sourceforge.net/doc/html/userman/t1.html"> 
	  una amplia documentaci&oacute;n</ulink> enfocada
          principalmente a los sistemas Linux pero en cualquier caso contiene  
          informaci&oacute;n que puede resultar &uacute;til.  En los siguientes 
          p&aacute;rrafos se describe brevemente como se puede utilizar 
          <application>etherboot</application> en un sistema &os;.</para>

        <para>Lo primero es instalar el port o paquete <filename 
	  role="package">net/etherboot</filename>.  El port de 
          <application>etherboot</application> est&aacute; en 
          <filename>/usr/ports/net/etherboot</filename>.  Si el &aacute;rbol 
          de ports est&aacute; instalado en el sistema basta con ejecutar 
	  <literal>make</literal> en dicho directorio.  Por favor, 
          lea  <xref linkend="ports"> para saber m&aacute;s sobre los ports y  
          los paquetes.</para> 

	<para>Se puede modificar la configuraci&oacute;n de 
          <application>etherboot</application> (por ejemplo, para que use 
	  <acronym>TFTP</acronym> en lugar de <acronym>NFS</acronym>) editando 
          el fichero <filename>Config</filename> que se encuentra en el  
          directorio fuente de <application>etherboot</application>.</para> 

	<para>Para nuestros prop&oacute;sitos se utilizar&aacute; un disquete 
          de arranque.  Para utilizar otros m&eacute;todos (PROM o un 
	  programa &ms-dos;) por favor consulte la documentaci&oacute;n de 
	  <application>etherboot</application>.</para>

	<para>Para crear un disco de arranque se debe insertar un disco en la 
          unidad de disquetes de la m&aacute;quina donde se ha instalado 
          <application>etherboot</application>, cambiar al directorio 
	  <filename>src</filename> dentro del &aacute;rbol de directorios de 
          <application>etherboot</application> y teclear:</para>

	<screen>
&prompt.root; <userinput>gmake bin32/<replaceable>tipo_de_dispositivo</replaceable>.fd0</userinput>
	</screen>

	<para><replaceable>tipo_de_dispositivo</replaceable> depende del tipo 
          de tarjeta Ethernet que se encuentre instalada en la estaci&oacute;n 
          de trabajo sin disco.  Consulte el fichero  
	  <filename>NIC</filename> en el mismo directorio para determinar 
          c&uacute;al es el <replaceable>tipo_de_dispositivo</replaceable> que 
	  debe usted usar.</para>

      </sect3>

      <sect3>
	<title>Arrancar con <acronym>PXE</acronym></title>

	<para>Por defecto el cargador &man.pxeboot.8; carga, valga la 
          redundancia, el kernel v&iacute;a <acronym>NFS</acronym>.  El 
	  El cargador se puede compilar para que utilice <acronym>
          TFTP</acronym> en lugar de <acronym>NFS</acronym> especificando la  
	  opci&oacute;n <literal>LOADER_TFTP_SUPPORT</literal> dentro de 
	  <filename>/etc/make.conf</filename>.  Observe los comentarios de 
	  <filename>/etc/defaults/make.conf</filename> (o de 
	  <filename>/usr/share/examples/etc/make.conf</filename> para 
          sistemas 5.X) para saber m&aacute;s detalles.</para> 

        <para>Existen otras dos opciones de 
          <filename>make.conf</filename> no documentadas que pueden 
          ser &uacute;tiles para arrancar una m&aacute;quina sin disco a 
          trav&eacute;s del puerto serie: 
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal> y 
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal> (esta 
          &uacute;ltima s&oacute;lo existe en &os;&nbsp;5.X).</para> 

	<para>Para utilizar <acronym>PXE</acronym> cuando arranca la 
          m&aacute;quina normalmente el usuario tiene que seleccionar la  
          opci&oacute;n <literal>Boot from network</literal> dentro del  
          men&uacute; de opciones de la <acronym>BIOS</acronym> o pulsar un 
	  tecla de funci&oacute;n cuando la m&aacute;quina se est&aacute; 
          inicializando.</para> 
      </sect3>

      <sect3>
	<title>Configuraci&oacute;n de Servidores de
          <acronym>TFTP</acronym> y de <acronym>NFS</acronym></title> 

	<indexterm>
	  <primary>TFTP</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>
	<indexterm>
	  <primary>NFS</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>Si <acronym>PXE</acronym> o 
	  <application>etherboot</application> se encuentran configurados para 
	  utilizar <acronym>TFTP</acronym> se necesita activar 
	  <application>tftpd</application> en el servidor de ficheros:
          </para> 
        <procedure>
          <step>
            <para>Crear un directorio desde el cual el d&aelig;mon 
              <application>tftpd</application> servir&aacute; los 
            ficheros, por ejemplo <filename>/tftpboot</filename>.</para>          
          </step>

          <step>
            <para>A&ntilde;adir la siguiente l&iacute;nea a 
	      <filename>/etc/inetd.conf</filename>:</para>

	    <programlisting>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</programlisting>

	    <note><para>Parece que al menos algunas versiones de 
                <acronym>PXE</acronym> utilizan la versi&oacute;n 
                <acronym>TCP</acronym> 
                de <acronym>TFTP</acronym>.  En este caso se puede 
                a&ntilde;adir una segunda l&iacute;nea, donde se reemplace 
                <literal>dgram udp</literal> por <literal>stream 
                tcp</literal>.</para> 
	    </note>
          </step>
	  <step>
	    <para>Indicar a <application>inetd</application> que 
              vuelva a leer su fichero de configuraci&oacute;n:</para>
            
	    <screen>&prompt.root; <userinput>kill -HUP `cat
                /var/run/inetd.pid`</userinput></screen> 
	  </step>
        </procedure>

	<para>Se puede situar el directorio 
          <filename>tftpboot</filename> en cualquier parte del servidor.  
          Debe asegurarse de que la localizaci&oacute;n se encuentra 
          correctamente configurada tanto en 
          <filename>inetd.conf</filename> como en 
          <filename>dhcpd.conf</filename>.</para> 

	<para>En todos los casos tambi&eacute;n resulta necesario activar el 
          sistema de <acronym>NFS</acronym> y exportar los sistemas de 
          ficheros adecuados, todo ello en el servidor de 
          <acronym>NFS</acronym>.</para> 

        <procedure>
          <step>
            <para>A&ntilde;adir lo siguiente a 
              <filename>/etc/rc.conf</filename>:</para> 
	    <programlisting>nfs_server_enable="YES"</programlisting> 
          </step>

          <step>
            <para>Exportar el sistema de ficheros donde el directorio 
              ra&iacute;z sin disco se encuentra localizado a&ntilde;adiendo 
              lo siguiente a <filename>/etc/exports</filename> (ajuste el 
              punto de montaje de la unidad y sustituya 
              <replaceable>margaux corbieres</replaceable> por el 
              nombre de las estaciones de trabajo sin disco, seg&uacute;n 
              corresponda):</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux corbieres</replaceable></programlisting>
          </step>
	  <step>
	    <para>Indicar a <application>mountd</application> que vuelva a leer 
	      su archivo de configuraci&oacute;n.  Si en un primer paso se ha 
              configurado la activaci&oacute;n autom&aacute;tica del sistema de 
              <acronym>NFS</acronym> en 
              <filename>/etc/rc.conf</filename> lo mejor es reiniciar para que 
              los cambios surtan efecto.</para>

	    <screen>&prompt.root; <userinput>kill -HUP `cat
                /var/run/mountd.pid`</userinput></screen> 
	  </step>
        </procedure>

      </sect3>

      <sect3>
	<title>Construcci&oacute;n de un N&uacute;cleo Sin
          Disco</title> 

	<indexterm>
	  <primary>diskless operation</primary>
	  <secondary>kernel configuration</secondary>
	</indexterm>

	<para>Si se utiliza <application>etherboot</application>, se necesita 
          crear un archivo de configuraci&oacute;n para el kernel de la 
          m&aacute;quina sin disco que posea las siguientes opciones 
          (adem&aacute;s de las opciones del n&uacute;cleo habituales):</para>

	<programlisting>
options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
	</programlisting>

	<para>Puede resultar interesante utilizar adem&aacute;s 
          <literal>BOOTP_NFSV3</literal>, 
	  <literal>BOOT_COMPAT</literal> y 
          <literal>BOOTP_WIRED_TO</literal>  
	  (consultar <filename>LINT</filename> en 4.X o 
	  <filename>NOTES</filename> en sistemas 5.X).</para> 

	<para>Los nombres de estas opciones son nombres 
          hist&oacute;ricos y ligeramente confusos ya que permiten un uso 
          indistinto tanto de <acronym>DHCP</acronym> como de BOOTP dentro del 
          n&uacute;cleo (tambi&eacute;n resulta posible forzar la 
          utilizaci&oacute;n &uacute;nica de o bien BOOTP o bien de 
          <acronym>DHCP</acronym>).</para> 
 
	<para>Contruir el n&uacute;cleo (vea <xref 
            linkend="kernelconfig">) y copiarlo al lugar especificado 
          en el archivo <filename>dhcpd.conf</filename>.</para> 

	<note>
	  <para>Cuando se utiliza <acronym>PXE</acronym>, la 
            construcci&oacute;n del n&uacute;cleo con las opciones anteriores  
            no resulta ser algo estrictamente necesario (aunque se 
            recomienda).  Activar dichas opciones provoca un mayor 
            tr&aacute;fico de peticiones de <acronym>DHCP</acronym> durante el 
            arranque del n&uacute;cleo, lo que puede dar lugar a 
            peque&ntilde;as inconsistencias entre los nuevos valores y los 
            los valores recuperados por &man.pxeboot.8; en casos muy   
            espec&iacute;ficos. La ventaja de utilizarlas consiste en que como 
            un efecto colateral se configurar&aacute; el nombre de la 
            m&aacute;quina. De otro modo tendr&iacute;amos que configurar dicho 
            nombre mediante otro m&eacute;todo por ejemplo mediante la 
            configuraci&oacute;n espec&iacute;fica de la m&aacute;quina cliente 
            a trav&eacute;s del archivo <filename>rc.conf</filename>.</para>
	</note>

	<note>
	  <para>Para que el n&uacute;cleo se pueda cargar sin problemas con 
	    <application>etherboot</application> en sistemas 5.X dicho 
            n&uacute;cleo tiene que tener compilado el soporte para 
            <emphasis>device hints</emphasis>.  Para ello normalmente se 
            especifica la siguiente opci&oacute;n dentro del fichero 
            de configuraci&oacute;n del n&uacute;cleo (consulte los comentarios 
            del fichero <filename>NOTES</filename>):</para> 

	  <programlisting>hints		"GENERIC.hints"</programlisting>
	</note>

      </sect3>

      <sect3>
	  <title>Preparaci&oacute;n del Sistema de Ficheros
          Ra&iacute;z</title> 

	<indexterm>
	  <primary>root file system</primary>
	  <secondary>diskless operation</secondary>
	</indexterm>

	<para>Se debe crear un sistema de ficheros ra&iacute;z en las 
          estaciones de trabajo sin disco, concretamente en la 
          localizaci&oacute;n especificada por <literal>root-path</literal> 
	  dentro de <filename>dhcpd.conf</filename>.  Las siguientes secciones 
          describen dos formas de hacer esto.</para> 
	<sect4>
	  <title>Utilizaci&oacute;n del <quote>script</quote> 
            <filename>clone_root</filename></title> 

	<para>Este es el modo m&aacute;s r&aacute;pido de crear un sistema de 
          ficheros ra&iacute;z, pero actulamente s&oacute;lo se encuentra 
          soportado en &os;&nbsp;4.X.  El <quote>script</quote> de shell se 
	  encuentra en <filename>/usr/share/examples/diskless/clone_root</filename>
	  y debe ser configurado al menos para ajustar el lugar donde se 
          construir&aacute; el sistema de ficheros (concretamente la 
          variable <literal>DEST</literal>).</para>

	<para>Consulte los comentarios que se encuentran al comienzo del 
            <quote>script</quote> para conocer cuales son las instrucciones que 
            debe seguir.  All&iacute; se explica c&oacute;mo se construye el 
            sistema de ficheros base y como determinados ficheros se pueden 
            sobreescribir de manera selectiva por versiones 
            espec&iacute;ficas para funcionar sin discos, para toda una subred 
            o para una m&aacute;quina individual.  Tambi&eacute;n all&iacute; 
            se muestran ejemplos de los ficheros  
	    <filename>/etc/fstab</filename> y 
            <filename>/etc/rc.conf</filename> para m&aacute;quinas sin 
            disco.</para> 

	  <para>Los archivos <filename>README</filename> que se encuentran 
	    dentro de <filename>/usr/share/examples/diskless</filename> 
            contienen mucha informaci&oacute;n de base, que junto con 
            el resto de ejemplos dentro del directorio 
            <filename>diskless</filename> sirven para documentar un 
            m&eacute;todo de configuraci&oacute;n distinto del que se 
            utiliza en <filename>clone_root</filename> y en los <quote>
	    scripts</quote> del sistema de <filename 
	    role="directory">/etc</filename>, que resultan ser un tanto 
            confusos.  No obstante se pueden utilizar a modo de referencia,
            excepto si se prefiere utilizar el m&eacute;todo que se describe 
            en ellos, en cuyo caso se necesitar&aacute; modificar y 
            adaptar los <quote>scripts</quote> de forma adecuada.</para> 
	</sect4>

	<sect4>
	  <title>Utilizaci&oacute;n del Procedimiento Est&aacute;ndar de 
            <command>make world</command>  
	    </title>

	  <para>Este m&eacute;todo se puede utilizar tanto en 
            &os;&nbsp;4.X o 5.X y se instalar&aacute; un sistema completamente 
            nuevo (no s&oacute;lo el sistema de ficheros ra&iacute;z) dentro de 
            <envar>DESTDIR</envar>.  Basta con ejecutar el siguiente <quote>
            script</quote>:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make world && make kernel
cd /usr/src/etc; make distribution</programlisting>
 
	  <para>Una vez ejecutado puede ser necesario ajustar los ficheros 
	    <filename>/etc/rc.conf</filename> y 
	    <filename>/etc/fstab</filename> que se encuentran en 
	    <envar>DESTDIR</envar> de acuerdo con nuestras necesidades.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Configuraci&oacute;n de la Partici&oacute;n de 
          Intercambio</title> 

	<para>En caso de ser necesario se puede acceder a un fichero 
          de intercambio (swap) a trav&eacute;s del sistema 
	  <acronym>NFS</acronym>.  Uno de los m&eacute;todos 
          t&iacute;picamente utilizados para realizar esta tarea ha sido 
          retirado de la distribuci&oacute;n 5.X.</para> 
	<sect4>
	  <title><acronym>NFS</acronym> Swap en sistemas &os;&nbsp;4.X</title>

	  <para>La ubicaci&oacute;n del fichero de intercambio y su 
            tama&ntilde;o se puede especificar con las opciones 
	    &os;-specific 128 y 129 de BOOTP/<acronym>DHCP</acronym>.  
            A continuaci&oacute;n se muestran varios ejemplos de ficheros de 
	    de configuraci&oacute;n para <application>
	    ISC DHCP 3.0</application> o 
            <application>bootpd</application>:</para> 

	<procedure>
	  <step><para>A&ntilde;adir las siguientes l&iacute;neas al fichero 
                <filename>dhcpd.conf</filename>:</para> 
	    <programlisting>
# Global section
option swap-path code 128 = string;
option swap-size code 129 = integer 32;

host margaux {
  ... # Standard lines, see above
  option swap-path <replaceable>"192.168.4.4:/netswapvolume/netswap"</replaceable>;
  option swap-size <replaceable>64000</replaceable>;
}
	    </programlisting>

	    <para><literal>swap-path</literal> es la ruta al directorio donde 
              se instalar&aacute;n los archivos de intercambio.  Cada 
              Cada fichero se denomina 
                <filename>swap.<replaceable>direccion-ip-del-cliente</replaceable></filename>.</para> 
 
	    <para>Versiones m&aacute;s antiguas de 
              <application>dhcpd</application> usaban una sint&aacute;xis del 
	      estilo de <literal>option option-128 "...</literal>, lo cual ya 
	      no est&aacute; soportado.</para>
	     
	    <para><filename>/etc/bootptab</filename> normalmente
                utiliza la siguiente sintaxis:</para> 
 
	    <programlisting>T128="192.168.4.4:/netswapvolume/netswap":T129=0000fa00</programlisting> 
 
	    <note><para>El tama&ntilde;o del fichero dedicado a intercambio 
	            se debe expresar en <filename>/etc/bootptab</filename> 
		    en formato hexadecimal.</para></note>
	  </step>

	  <step>
	    <para>En el servidor de ficheros <acronym>NFS</acronym>
                donde va a residir el fichero de <quote>swap</quote> se debe(n) 
		crear dicho(s) fichero(s)</para>
            <screen>
&prompt.root; <userinput>mkdir <replaceable>/volumenintercambiored/intercambiored</replaceable></userinput>
&prompt.root; <userinput>cd <replaceable>/volumenintercambiored/intercambiored</replaceable></userinput>
&prompt.root; <userinput>dd if=/dev/zero bs=1024 count=<replaceable>64000</replaceable> of=swap.<replaceable>192.168.4.6</replaceable></userinput>
&prompt.root; <userinput>chmod 0600 swap.<replaceable>192.168.4.6</replaceable></userinput>
            </screen>
	    <para><replaceable>192.168.4.6</replaceable> es la direcci&oacute;n IP del cliente sin disco.</para>
	  </step>

	  <step>
	    <para>En el servidor <acronym>NFS</acronym> a&ntilde;adir a 
                <filename>/etc/exports</filename> la siguiente l&iacute;nea:
                </para> 
	    <programlisting>
<replaceable>/volumenintercambiored</replaceable>  -maproot=0:10 -alldirs <replaceable>margaux corbieres</replaceable>
	    </programlisting>
	    <para>A continuaci&oacute;n indicar a 
                <application>mountd</application> que vuelva a leer el fichero 
                <filename>/etc/exports</filename> como se ha indicado 
                anteriormente.</para>	 
	  </step>
	</procedure>
	</sect4>

	<sect4>
	  <title><acronym>NFS</acronym> Swap en &os&nbsp;5.X</title>

	  <para>El n&uacute;cleo no soporta la activaci&oacute;n del 
            intercambio a trav&eacute;s de <acronym>NFS</acronym> en tiempo de 
            arranque.  De esta forma la <quote>swap</quote> se debe activar 
	    mediante los <quote>scripts</quote> montando un sistema de ficheros 
            de lectura-escritura y creando y activando el fichero de 
            intercambio.  Para crear un fichero de intercambio de un 
            determinado tama&ntilde;o se puede ejecutar lo siguiente:</para> 
 
	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/ruta/al/fichero/de/intercambio</replaceable> bs=1k count=1 oseek=<replaceable>100000</replaceable></userinput></screen>

	  <para>Para activar el intercambio se tiene que a&ntilde;adir 
            la siguiente l&iacute;nea al fichero de configuraci&oacute;n 
	    <filename>rc.conf</filename>:</para>

	  <programlisting>swapfile=<replaceable>/ruta/al/fichero/de/intercambio</replaceable></programlisting>
        </sect4>
      </sect3>

      <sect3>
	<title>Cuestiones Variadas</title>


	<sect4>
	  <title>Ejecuci&oacute;n con un <filename>/usr</filename> de
            s&oacute;lo lectura</title> 

	  <indexterm>
	    <primary>diskless operation</primary>
	    <secondary>/usr read-only</secondary>
	  </indexterm>

	    <para>Si la estaci&oacute;n de trabajo sin disco se configura para 
            utilizar el sistema X-Window se tiene que ajustar el fichero de 
            configuraci&oacute;n de xdm debido a que dicho fichero 
            sit&uacute;a por defecto el fichero de <quote>logs</quote> de 
            errores en el directorio <filename>/usr</filename>.</para> 
	</sect4>
	<sect4>
	  <title>Utilizaci&oacute;n de un Servidor No-&os;</title>

	  <para>Cuando el servidor del sistema de ficheros ra&iacute;z no 
            ejecuta &os; se tiene que crear un sistema de ficheros 
            ra&iacute;z sobre una m&aacute;quina &os; para despu&eacute;s 
            copiarlo al servidor original mediante los comandos 
	    <command>tar</command> o <command>cpio</command>.</para> 


	  <para>En esta situaci&oacute;n algunas veces surgen varios 
            problemas relacionados con los dispositivos especiales que 
            se encuentran en el directorio 
            <filename>/dev</filename> debido a los diferentes 
            tama&ntilde;os de los enteros mayor/menor.  Una soluci&oacute;n 
            para este problema consiste en exportar un directorio del servidor 
            no-&os;, montar este directorio en la m&aacute;quina &os; anterior 
            y ejecutar <command>MAKEDEV</command> en dicha m&aacute;quina para 
            crear las entradas de dispositivo correctas (&os; 5.0 y 
            posteriores utilizan &man.devfs.5; para ubicar nodos de 
            dispositivos de forma transparente para el usuario de tal modo que 
            la ejecuci&oacute;n de <command>MAKEDEV</command>  en estos 
            sistemas no sirve para nada).</para> 

	</sect4>

      </sect3>

    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>RDSI</title>

    <indexterm>
      <primary>RDSI</primary>
    </indexterm>

    <para><ulink url="http://www.alumni.caltech.edu/~dank/isdn/">la 
      p&aacute;gina de RDSI de Dan Kegel</ulink> constituye un recurso de  
      informaci&oacute;n bastante bueno sobre la tecnolog&iacute;a RDSI 
      (ISDN en ingl&eacute;s) y sobre el hardware relacionado.</para>

    <para>A continuaci&oacute;n se comenta un esquema r&aacute;pido sobre 
      RDSI:</para> 

    <itemizedlist>
      <listitem>
        <para>Si usted vive en Europa le puede resultar &uacute;til leer la 
          secci&oacute;n sobre tarjetas RDSI.</para> 
      </listitem>

      <listitem> 
	<para>Si se prevee utilizar RDSI principalmente para conectarse a 
          Internet a trav&eacute;s de un Proveedor de Servicios utilizando 
          un mecanismo de marcaci&oacute;n autom&aacute;tica no dedicado 
          (dial-up), se puede echar un vistazo a los Adaptadores de 
          Terminal.  Dichos adaptadores proporciona la mayor flexibilidad y 
          garantiza los m&iacute;nimos problemas en caso de cambio de 
          cambio de proveedor.</para> 
      </listitem>

      <listitem>
        <para>Si estamos conectados a dos LAN o conectando a Internet con una 
          conexi&oacute;n RDSI dedicada puede ser interesante considerar la 
          opci&oacute;n de usar un <quote>router/bridge</quote>  
	  &uacute;nico.</para> 
      </listitem>
    </itemizedlist>

    <para>El coste es un factor importante a la hora de determinar 
      qu&eacute; soluci&oacute;n se debe escoger.  Las siguientes opciones se  
      encuentran ordenadas desde las m&aacute;s baratas hasta las 
      m&aacute;s caras.</para> 

    <sect2 id="network-isdn-cards">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hellmuth</firstname>
            <surname>Michaelis</surname>
            <contrib>Escrito por  </contrib>
          </author>
        </authorgroup>
      </sect2info>
      <title>Tarjetas RDSI</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>cards</secondary>
      </indexterm>

      <para>La implementaci&oacute;n de RDSI que posee &os; soporta 
        s&oacute;lamente el estandar DSS1/Q.931 (tambi&eacute;n conocido como 
        Euro-RDSI) utilizando tarjetas pasivas.  A partir de &os; 4.4 se 
        soportan tambi&eacute;n algunas tarjetas activas usando firmware que 
        adem&aacute;s soporta otros protocolos de se&ntilde;alizaci&oacute;n; 
        esto tambi&eacute;n sucede con la primera tarjeta RDSI de 
        acceso primario (PRI) soportada.</para> 

      <para>El software <application>isdn4bsd</application> permite conectar 
        con otras pasarelas RDSI utilizando IP sobre HDLC o bien PPP 
        PPP s&iacute;ncrono: ambos mediante el uso del PPP del n&uacute;cleo 
        con <literal>isppp</literal>, una versi&oacute;n modificada del   
        controlador &man.sppp.4; o mediante la utilizaci&oacute;n del PPP de 
	entorno de usuario, &man.ppp.8;.  Si se utiliza &man.ppp.8; de entorno 
        de usuario se pueden agrupar dos o mas canales B de RDSI (channel 
	bonding).  Existe tambi&eacute;n software que permite a una 
        m&aacute;quina responder a llamadas de tel&eacute;fono y algunas 
	cosas m&aacute;s como un modem de 300 baudios.</para>

      <para>Cada vez se soportan m&aacute;s tarjetas RDSI bajo &os; y los 
        informes existentes muestra que &os; se utiliza con dichas tarjetas de 
	forma satisfactoria en toda Europa y tambi&eacute;n en otras partes del 
        mundo.</para> 

      <para>Las tarjetas RDSI pasivas soportadas en &os; son principalmente las 
        que poseen el chip Infineon (antiguamente Siemens) ISAC/HSCX/IPAC.  
        Tambi&eacute;n las tarjetas RDSI con los chips de Cologne (en bus ISA 
        exclusivamente), tarjetas PCI con el chip Winbond W6692, algunas 
        tarjetas con combinaciones de los chips Tiger 300/320/ISAC y 
        tambi&eacute;n algunas tarjetas basadas en chips propietarios como 
        las AVM Fritz! PCI V.1.0 y AVM Fritz! PnP.</para>

      <para>Actualmente las tarjetas RDSI activas soportadas son las 
        AVM B1 (ISA y PCI) BRI, y las AVM T1 PCI PRI.</para> 

      <para>Se puede consultar 
        <filename>/usr/share/examples/isdn/</filename> para 
        obtener documentaci&oacute;n sobre 
        <application>isdn4bsd</application> y tambi&eacute;n 
        en <ulink url="http://www.freebsd-support.de/i4b/">la 
        p&aacute;gina principal de isdn4bsd</ulink>, donde hay enlaces de
	ayuda, erratas y mucha m&aacute;s informaci&oacute;n &uacute;til, 
        como por ejemplo el <ulink 
	url="http://people.FreeBSD.org/~hm/">manual de isdn4bsd</ulink>.</para>

      <para>Si se quiere a&ntilde;adir soporte para un protoclo RDSI distinto 
        para una tarjeta RDSI que no se encuentra soportada o para mejorar 
        <application>isdn4bsd</application> en alg&uacute;n aspecto por favor 
	p&oacute;ngase en contacto con &a.hm;.</para>

      <para>Para realizar consultas referentes a la instalaci&oacute;n, 
        configuraci&oacute;n y depuraci&oacute;n de problemas relacionados con 
        <application>isdn4bsd</application> le recomendamos recurrir a la lista 
        de correo &a.isdn.name;.</para> 
    </sect2>

    <sect2>
      <title>Adaptadores de Terminal RDSI</title>

      <para>Los Adaptadores de Terminal (TA), son para RDSI lo que los modems 
        son para las l&iacute;neas de tel&eacute;fono convencionales.</para>
       
      <indexterm><primary>modem</primary></indexterm> 
      <para>La mayor parte de los TAs utilizan el conjunto de instrucciones AT 
        de los modem Hayes y se pueden utilizar en lugar del modem.</para>

      <para>Un TA opera b&aacute;sicamente de igual forma que un modem, 
        diferenci&aacute;ndose en que las velocidades de conexi&oacute;n y 
        <quote>throughput</quote> son mucho m&aacute;s grandes.  La 
        configuraci&oacute;n de <link 
        linkend="ppp">PPP</link> se realiza exactamente igual que para una 
        configuraci&oacute;n de modem convencional.</para>

      <indexterm><primary>PPP</primary></indexterm>

      <para>La ventaja principal de utilizar un TA para conectarse a un 
        proveedor de servicios de internet consiste en que se puede usar PPP 
        din&aacute;mico.  Ya que el espacio de direcciones de IP se est&aacute; 
        direcciones de IP se est&aacute; convirtiendo cada vez
        convirtiendo en un recurso cada d&iacute; m&aacute;s limitado y escaso 
        los proveedores ya no desean proporcionar direcciones IP 
        est&aacute;ticas a sus clientes.  No obstante la mayor&iacute;a de los  
        <quote>routers standalone</quote> no son capaces de adquirir 
        direcciones IP din&aacute;micas.</para> 

      <para>Los TAs conf&iacute;an completamente en el d&aelig;mon de PPP 
        que se est&aacute; ejecutando para proporcionar fiabilidad y 
        estabilidad en la conexi&oacute;n.  De esta forma si se tiene 
        configurado PPP se puede migrar f&aacute;cilmente de la 
        utilizaci&oacute;n de modems anal&oacute;gicos al uso de RDSI.  No 
        obstante si exist&iacute;a alg&uacute;n problema con PPP antes de 
        efectuar la migraci&oacute;n dichos problemas persistir&aacute;n en 
        RDSI.</para>
      
      <para>Si se desea m&aacute;xima estabilidad se puede utilizar la 
        opci&oacute;n <link linkend="ppp">PPP</link>, no el 
	<link linkend="userppp">PPP a nivel de usuario</link>.</para>

      <para>Se sabe que los siguientes TAs funcionan con &os;:</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola BitSurfer y Bitsurfer Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>La mayor&iacute;a de los dem&aacute;s TAs probablemente 
        tambi&eacute;n funcionen puesto que los fabricantes siempre tratan de 
        que sus productos puedan aceptar la mayor&iacute;a de los comandos 
        AT.</para> 

      <para>El problema que existe con los TAs es que, como sucede con los 
        modems, se necesita tener una buena tarjeta serie instalada en el 
        sistema.</para> 

      <para>Se recomienda consultar el tutorial <ulink
          url="../../articles/serial-uart/index.html">FreeBSD Serial 
	Hardware</ulink> para obtener una comprensi&oacute;n detallada del 
        funcionamiento de los dispositivos serie en &os; y para comprender las 
        diferencias entre puertos serie s&iacute;ncronos y 
        as&iacute;ncronos.</para> 

      <para>Un TA que se ejecuta a trav&eacute;s de un puerto serie 
        (as&iacute;ncrono) est&aacute; limitado a 115.2&nbsp;Kbs, aunque la 
        conexi&oacute;n RDSI sea de 128&nbsp;Kbs. Para utilizar completamente 
        el ancho de banda que RDSI proporciona, se debe conectar el TA a una 
        tarjeta serie s&iacute;ncrona.</para> 

      <para>No se enga&ntilde;e creyendo que comprando un TA interno 
        har&aacute; desaparecer los problemas 
	s&iacute;ncronos/as&iacute;ncronos. Los TA internos simplemente  
        disponen de un chip de puerto serie instalado de f&aacute;brica.  
        Lo &uacute;nico que se consigue con estos dispositivos es no tener 
        que enchufarlos a la red el&eacute;trica ahorrando as&iacute; un 
	enchufe y no tener que comprar un cable serie, pero los problemas 
	dichos anteriormente permanecen.</para>

      <para>Una tarjeta as&iacute;ncrona con un TA resulta ser al menos tan 
        r&aacute;pida como un <quote>router standalone</quote> y si &os; 
        controla dicha tarjeta se puede adaptar m&aacute;s 
        f&aacute;cilmente.</para> 

      <para>La elecci&oacute;n de una tarjeta s&iacute;ncrona/TA
        versus un <quote>router standalone</quote> se trata en la 
	mayor&iacute;a de los casos de una cuesti&oacute;n cuasi-religiosa.  
        Han existido diversas discusiones sobre este tema en varias listas de 
        correo. Nosotros recomendamos que busque informaci&oacute;n en los 
	<ulink 
          url="http://www.freebsd.org/search/index.html">
        hist&oacute;ricos</ulink> para para poder sopesar los pros y los 
        contras que se han esgrimido en tales discusiones.</para>
    </sect2>

    <sect2>
      <title><quote>Bridges/Routers</quote> RDSI <quote>Stand-alone</quote></title>
      <indexterm>
        <primary>ISDN</primary>
	<secondary>stand-alone bridges/routers</secondary>
      </indexterm>
      <para>Los <quote>bridges</quote> o <quote>routers</quote> RDSI no son 
      espec&iacute;ficos de &os; o de cualquier otro sistema operativo.  
        Para una descripci&oacute;n completa de la tecnolog&iacute;a de 
        <quote>bridge</quote> y de pasarela de red por favor consulte 
        cualquier libro sobre redes.</para> 

      <para>En el contexto de esta secci&oacute;n los t&eacute;rminos 
        <quote>router</quote>, pasarela y <quote>bridge</quote> se 
	utilizar&aacute;n indistintamente.</para>

      <para>Seg&uacute;n va bajando el coste de los <quote>
        routers/bridges</quote> RDSI su utilizaci&oacute;n entre el 
        p&uacute;blico en general va en aumento.  
        Un <quote>router</quote> RDSI es una peque&ntilde;a caja que se 
        conecta directamente a la red Ethernet local y que gestiona sus propias 
        conexiones con el <quote>bridge/router</quote> remoto.  Posee un 
        software preconfigurado para comunicarse v&iacute;a PPP y 
        tamb&iacute;en utilizando otros protocolos de uso com&uacute;n.</para>
 
      <para>Un router sopota una mayor tasa de paquetes (throughput) que un 
        <quote>standalone TA</quote>, ya que utiliza una conexi&oacute;n RDSI  
        s&iacute;ncrona de forma completa.</para>

      <para>El problema principal que surge con los <quote>routers</quote> y 
        los <quote>bridges</quote> RDSI es que la interoperatibilidad entre 
        fabricantes muchas veces causa problemas.  Si se est&aacute; 
	planificando conectarse a un proveedor de servicios resulta conveniente 
        discutir previamente con ellos las necesidades y requisitos.</para> 

      <para>Si se tiene en mente conectar dos segmentos LAN tales como su LAN 
        de casa y la LAN de su oficina RDSI proporciona la soluci&oacute;n 
        m&aacute;s simple y menos costosa de gestionar.  Esto es as&iacute; 
        porque al comprar usted mismo el equipamiento necesario para ambos 
        extremos de la conexi&oacute;n tiene usted el control sobre el enlace 
        y puede asegurar su correcto funcionamiento.</para>

      <para>Por ejemplo, si queremos conecar una computadora casera o una 
        sucursal de la red de oficinas con la oficinal central, se puede 
        utilizar una configuraci&oacute;n como la que se muestra a 
        continuaci&oacute;n.</para> 

      <example>
	<title>Sucursal o Red Hogar</title>

	<indexterm><primary>10 base 2</primary></indexterm>
	<para>La red utiliza una topolog&iacute;a basada en bus con
          Ethernet tipo 10 base 2 (<quote>thinnet</quote>).  Se conecta, en 
          caso de ser necesario, el <quote>router</quote> a la red cableada 
	  mediante un <quote>transceiver</quote> AUI/10BT.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-bus">
          </imageobject>

	  <textobject>
	    <literallayout class="monospaced">---Estacion Sun 
|
---Sistema FreeBSD
|
---Windows 95
|
Router Stand-alone
   |
ISDN BRI line</literallayout>
          </textobject>

	  <textobject>
	    <phrase>10 Base 2 Ethernet</phrase>
	  </textobject>
	</mediaobject>

	<para>Si nuestra sucursal o red hogar est&aacute; compuesta 
          &uacute;nicamente por una computadora se puede utilizar un cable 
          cruzado de par trenzado para conectar con el <quote>router 
	  standalone</quote> de forma directa.</para>
      </example>

      <example>
	<title>Oficina Central u Otra LAN</title>

	<indexterm><primary>10 base T</primary></indexterm>
	<para>La red utiliza una topolog&iacute;a en estrella basada en 
          Ethernet de 10 base T (<quote>Par Trenzado</quote>).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-twisted-pair">
          </imageobject>

	  <textobject>
	    <literallayout class="monospaced">    -------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Stand-alone router
                |
        ISDN BRI line</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>ISDN Network Diagram</phrase>
	  </textobject>
	</mediaobject>
      </example>

      <para>Una gran ventaja que poseen la mayor&iacute;a de los
        <quote>routers/bridges</quote> es que pueden gestionar al mismo tiempo 
        dos conexiones PPP <emphasis>independientes</emphasis> destinadas a dos 
        organizaciones distintas.  Esta funcionalidad no se proporciona en la 
        mayor&iacute;a de los TAs, excepto para determinados modelos 
        (normalmente m&aacute;s caros) que se fabrican con dos puertos serie.  
        No confunda esto con la agrupaci&oacute;n de canales, MPP, etc.</para>

      <para>Esta caracter&iacute;stica puede resultar muy &uacute;til si, por 
        ejemplo, se dispone de una conexi&oacute;n RDSI dedicada con la 
        oficina y queremos introducirnos en ella pero no queremos utilizar 
        otra l&iacute;nea RDSI en el trabajo.  Un <quote>router</quote> situado 
        en las instalaciones de la oficina puede gestionar una 
        conexi&oacute;n de canal B dedicada (64&nbsp;Kpbs) hacia internet y 
        utilizar el otro canal B como una conexi&oacute;n de datos 
        independiente.  El segundo canal B se puede utilizar para 
        marcaci&oacute;n remota (<quote>dial-in</quote> y <quote>
        dial-out</quote>) o para agrupaci&oacute;n din&aacute;mica de canales 
        (MPP, etc) en conjunci&oacute;n con el primer canal B con el objetivo  
        de obtener un mayor ancho de banda.</para>

       <indexterm><primary>IPX/SPX</primary></indexterm>
      <para>Un <quote>bridge</quote> Ethernet permite transmitir m&aacute;s 
        tr&aacute;fico aparte del tr&aacute;fico IP.  Se puede transmitir 
        IPX/SPX o cualquier otro protocolo que se est&eacute; utilizando.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Escrito por </contrib>
         </author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Ogren</surname>
	  <contrib>Ampliado por </contrib>
	</author>
	<author>
	  <firstname>Udo</firstname>
	  <surname>Erdelhoff</surname>
	</author>
      </authorgroup>
    </sect1info>
    <title>NIS/YP</title>

    <sect2>
      <title>&iquest;Qu&eacute; es esto?</title>
      <indexterm><primary>NIS</primary></indexterm>
      <indexterm><primary>Solaris</primary></indexterm>
      <indexterm><primary>HP-UX</primary></indexterm>
      <indexterm><primary>AIX</primary></indexterm>
      <indexterm><primary>Linux</primary></indexterm>
      <indexterm><primary>NetBSD</primary></indexterm>
      <indexterm><primary>OpenBSD</primary></indexterm>
      <para>NIS, siglas de Network Information Services (Servicios de 
        Informaci&oacute;n de Red), fu&eacute; un servicio desarrollado por 
        Sun Microsystems para centralizar la administraci&oacute;n de sistemas 
        &unix; (originalmente &sunos;).  Actualmente se considera como un 
        est&aacute;ndar de la industria; los principales sistemas tipo &unix; 
        (&solaris;, HP-UX, &aix;, Linux, NetBSD, OpenBSD, &os;, etc) 
        implementan NIS.</para> 

      <indexterm><primary>yellow pages</primary><see>NIS</see></indexterm>
      <para>NIS tambi&eacute;n se conoc&iacute;a como el servicio de 
        p&aacute;ginas amarillas pero debido a problemas legales debidos a 
        la propiedad de marcas comerciales, Sun tuvo que cambiar el nombre.  
        El ant&iacute;guo t&eacute;rmino (<quote>Yellow Pages</quote> o yp) 
	todav&iacute;a se ve y se utiliza con frecuencia.</para>

      <indexterm>
        <primary>NIS</primary>
        <secondary>domains</secondary>
      </indexterm>
      <para>Se trata de un sistema cliente servidor basado en llamadas RPC que 
        permite a un grupo de m&aacute;quinas que se encuentran definidas 
        dentro de un dominio administrativo NIS compartir un conjunto de 
        ficheros de configuraci&oacute;n.  Esto permite al administrador de 
        sistemas por un lado configurar clientes NIS de forma minimalista y 
	por otro lado centralizar la gesti&oacute;n de los ficheros de 
        configuraci&oacute;n en una &uacute;nica ubicaci&oacute;n (una sola 
        m&aacute;quina).</para> 

      <indexterm><primary>Windows NT</primary></indexterm>
      <para>Se trata de algo similar al sistema de dominio de &windowsnt; 
        aunque la implementaci&oacute;n interna no se puede comparar, la 
        funcionalidad y el servicio obtenido son similares.</para>
    </sect2>

    <sect2>
      <title>T&eacute;rminos/Procesos que Usted Debe Conocer</title>

      <para>Existen varios conceptos y varios procesos de usuario que el 
        usuario no versado en estos temas suele encontrarse la primera vez que 
        se intenta implantar un servicio de NIS en &os;, tanto si se intenta 
        configurar un servidor como si se intenta configurar un cliente:</para>

      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>

      <informaltable>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Term</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>NIS domainname</entry>
	      <entry>Un servidor maestro de NIS y todos sus clientes 
                (incluyendo a sus servidores esclavos) poseen el mismo nombre 
                dominio NIS.  Al igual que ocurre con el nombre de dominio de 
                &windowsnt;, el nombre de dominio de NIS no tiene nada que ver 
                con el nombre de dominio de DNS.</entry>
	    </row>
	    <row>
	      <entry><application>portmap</application></entry>
	      <entry>Debe ejecutarse para que se activen las llamadas a 
                procedimientos remotos (Remote Procedure Call o RPC) 
		que son utilizadas por NIS.  Si 
		<application>portmap</application> no se est&aacute; ejecutando 
                no se podr&aacute; ejecutar ni clientes ni servidores de 
		NIS.</entry>
	    </row>
	    <row>
	      <entry><application>ypbind</application></entry>

	      <entry><quote>Asocia</quote> un cliente con un servidor NIS.  
                Primeramente se lee el nombre de dominio NIS del sistema y 
                utilizando RPC se conecta con el servidor.  
                <application>ypbind</application> es la parte central de la 
                comunicaci&oacute;n cliente servidor del sistema NIS; 
                si <application>ypbind</application> muere en una 
                m&aacute;quina cliente, dicha m&aacute;quina no podr&aacute; 
                acceder al servidor NIS.</entry>
	    </row>
	    <row>
	      <entry><application>ypserv</application></entry>
	      <entry>Debe ejecutarse s&oacute;lamente en los servidores NIS; 
                se trata del proceso servidor de NIS.  Si &man.ypserv.8; 
                muere, el servidor no ser&aacute; capaz de responder a 
                peticiones NIS (no obstante, si se definen servidores NIS 
                esclavos la situaci&oacute;n puede recuperarse).  Existen 
                algunas implementaciones de NIS (no es el caso de &os;) 
                que no intentan conectarse con otro servidor si el servidor 
                con otro servidor si el servidor que se estaba
                que se estaba utilizando muere.  A menudo lo &uacute;nico que 
		se puede hacer en estos casos es reiniciar el servidor (el 
                proceso o la propia m&aacute;quina) o el proceso 
                <application>ypbind</application> del cliente.</entry>
	    </row>
	    <row>
	      <entry><application>rpc.yppasswdd</application></entry>
	      <entry>Otro proceso que s&oacute;lo debe ejecutarse en el 
                servidor maestro de NIS; se trata de un d&aelig;mon que permite 
                a los clientes de NIS modificar las contrase&ntilde;as de los 
                usuarios.  Si no se ejecuta este d&aelig;mon los usuarios 
                tendr&aacute;n que entrar en el servidor maestro de NIS para 
                cambiar sus contrase&ntilde;as all&iacute;.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      <!-- XXX Missing: rpc.ypxfrd (not important, though) May only run
      on the master -->

    </sect2>

    <sect2>
      <title>&iquest;C&oacute;mo Funciona?</title>

       <para>Existen tres tipos de m&aacute;quinas dentro del entorno 
        NIS: los servidores maestros, los servidores esclavos y los clientes 
        de NIS.  Los servidores act&uacute;an como repositorios centrales para 
        almacenamiento de informaci&oacute;n de configuraci&oacute;n.  
        Los servidores maestros mantienen una copia maestra de dicha 
        informaci&oacute;n, mientras que los servidores esclavos mantienen 
        copias de la informaci&oacute;n maestra por motivos de redundancia.  
        Los servidores se encargan de transmitir la informaci&oacute;n 
        necesaria a los clientes a petici&oacute;n de estos 
        &uacute;ltimos.</para> 

      <para>De esta forma se pueden compatir mucha informaci&oacute;n 
        contenida en varios archivos.  Los ficheros <filename>      
	master.passwd</filename>, <filename>group</filename> y <filename>
	hosts</filename> normalmente se comparten a trav&eacute;s de NIS.  
        Siempre que un proceso en un cliente necesita informaci&oacute;n que, 
        en caso de no utilizar NIS, se podr&iacute;a recuperar de ficheros 
        locales, en este caso se env&iacute;a una solicitud al servidor NIS con 
        el que nos encontramos asociados.</para> 

      <sect3>
        <title>Clases de M&aacute;quinas</title>

        <itemizedlist>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>master server</secondary>
	  </indexterm>
          <listitem>
            <para><emphasis>Servidor de NIS maestro</emphasis>.
              Este servidor, semejante a un controlador de dominio primario de 
              &windowsnt; mantiene todos los archivos que utilizan los 
              clientes.  Los ficheros <filename>passwd</filename>, 
              <filename>group</filename> y algunos otros se encuentran 
              ubicados en el servidor maestro.</para> 

            <note><para>Resulta posible configurar una m&aacute;quina para que 
              act&uacute;e como servidor NIS maestro para m&aacute;s de un 
              dominio NIS.  No obstante esta configuraci&oacute;n no se va a 
              tratar en esta introducci&oacute;n, en la cual asumimos un 
              entorno NIS de tama&ntilde;o relativamente 
              peque&ntilde;o.</para></note> 
          </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>slave server</secondary>
	  </indexterm>
          <listitem>
            <para><emphasis>Servidores de NIS esclavos</emphasis>.
              Semejantes a los controladores de backup de &windowsnt;, 
              los servidores NIS esclavos se utilizan para proporcionar 
              redundancia en entornos de trabajo donde la disponibilidad del 
              servicio resulta muy importante.  Adem&aacute;s se utilizan para 
              distribuir la carga que normalmente soporta un servidor 
              maestro: los clientes de NIS siempre se asocian con el servidor 
              de NIS que posee mejor tiempo de respuesta, y esto 
              y esto tambi&eacute;n incluye a los servidores de NIS 
              esclavos.</para> 
          </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>client</secondary>
	  </indexterm>
          <listitem>
            <para><emphasis>Clientes NIS</emphasis>.  Los clientes NIS, de 
              forma semejante a las estaciones de trabajo de &windowsnt;, se 
              validan contra un servidor NIS (en el caso de &windowsnt; se 
              validan contra un controlador de dominio) para acceder al 
	      sistema.</para>            
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>Utilizaci&oacute;n de NIS/YP</title>

      <para>Esta secci&oacute;n trata sobre c&oacute;mo configurar y poner en 
        funcionamiento un entorno de NIS sencillo.</para> 

      <note><para>Esta secci&oacute;n supone que se est&aacute; utilizando 
        utilizando &os;&nbsp;3.3 o posteriores.  Las instrucciones dadas 
        aqu&iacute; <emphasis>probablemente</emphasis> funcionen 
        tambi&eacute;n en cualquier versi&oacute;n de &os; superior a la 3.0 
        pero no podemos garantizar que esto sea as&iacute;.</para></note>

      <sect3>
        <title>Planificaci&oacute;n</title>
 
        <para>Vamos a suponer que somos el administrador de un peque&ntilde;o 
          laboratorio de una universidad.  En este laboratorio, compuesto por 
          15 m&aacute;quinas &os;, actualmente no existe ning&uacute;n punto 
          de administraci&oacute;n centralizada; cada m&aacute;quina posee sus 
          sus propios <filename>/etc/passwd</filename> y <filename>
          /etc/master.passwd</filename>.  Estos ficheros se encuentran  
          sincronizados el uno con el otro mediante intervenci&oacute;n 
          manual; por tanto, cuando queramos a&ntilde;adir un usuario a 
          nuestro laboratorio tendremos que ejecutar 
          <command>adduser</command> en todas las m&aacute;quinas.  
          Claramente esta situaci&oacute;n tiene que cambiar, de tal forma que 
          hemos decidido crear un dominio NIS en el laboratorio usando dos 
          m&aacute;quinas como servidores NIS.</para>

        <para>La configuraci&oacute;n de nuestro laboratorio deber&iacute;a ser 
          algo parecido a lo  siguiente:</para> 

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Nombre de m&aacute;quina</entry>
                <entry>Direcci&oacute;n IP</entry>
                <entry>Papel</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><hostid>ellington</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
                <entry>servidor NIS maestro</entry>
              </row>
              <row>
                <entry><hostid>coltrane</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
                <entry>Servidor NIS esclavo</entry>
              </row>
              <row>
                <entry><hostid>basie</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
                <entry>Estaci&oacute;n de trabajo del profesorado</entry>
              </row>
              <row>
                <entry><hostid>bird</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
                <entry>m&aacute;quina cliente</entry>
              </row>
              <row>
                <entry><hostid>cli[1-11]</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
                <entry>Resto de m&aacute;quinas clientes</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Si se est&aacute; configurando un esquema de NIS por primera vez 
          es una buena idea detenerse a pensar c&oacute;mo queremos implantar 
          el sistema.  Existen varias decisiones que se deben tomar 
          independientemente del tama&ntilde;o de nuestra red.</para>

        <sect4>
          <title>Elecci&oacute;n del nombre de dominio NIS</title> 

	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>domainname</secondary>
	  </indexterm>
          <para>Este nombre puede no ser el <quote>nombre de
            dominio</quote> al que estamos acostumbrados.  Resulta m&aacute;s 
            preciso llamarlo <quote>nombre de dominio NIS</quote>.  
            Cuando un cliente genera peticiones de NIS que llegan a todas las 
            m&aacute;quinas (broadcast) solicitando informaci&oacute;n se 
            incluye el nombre de dominio NIS que tiene configurado.  
            De esta forma, varios servidores de dominios distintos situados en 
            la misma red pueden discriminar las peticiones recibidas.  Se puede 
            pensar en el nombre de dominio NIS como un identificador de grupos 
            de m&aacute;quinas que se encuentran relacionados 
            administrativamente de alguna forma.</para>
         
          <para>Algunas organizaciones eligen utilizar su nombre de dominio de 
            Internet como nombre de dominio NIS.  Esto no se recomienda ya que 
	    puede causar confusi&oacute;n cuando se intentan depurar problemas 
            de red.  El nombre de dominio NIS deber&iacute;a ser un nombre 
            &uacute;nico dentro de nuestra red y resulta m&aacute;s 
            &uacute;til a&uacute;n si el nombre elegido puede describir de 
            alguna forma al conjunto de m&aacute;quinas que representa.  
            Por ejemplo el departamento de arte de la empresa Acme puede 
            utilizar como nombre de dominio <quote>acme-art</quote>.  
            En nuestro ejemplo hemos utilizado el nombre 
            <literal>test-domain</literal>.</para> 

	  <indexterm><primary>SunOS</primary></indexterm>
          <para>No obstante algunos sistemas operativos (de forma
            notable &sunos;) utilizan como nombres de dominio nombres de 
            Internet.  Si se poseen m&aacute;quinas con esta 
	    restricci&oacute;n no queda m&aacute;s remedio que 
            <emphasis>utilizar</emphasis> los nombres de dominio de Internet 
            como nombres de dominio NIS.</para>
        </sect4>

        <sect4>
          <title>Requisitos F&iacute;sicos de los Servidores</title>

	  <para>Existen varias cosas que debemos tener en cuenta cuando se 
            selecciona una m&aacute;quina para actuar como servidor NIS.  
            Una de las caracter&iacute;sticas desafortunadas del servicio de 
            p&aacute;ginas amarillas es el alto nivel de dependencia que llegan 
            a tener los clientes respecto del servidor de NIS.  Si el cliente 
	    no puede contactar con el servidor NIS normalmente la 
            m&aacute;quina se queda en un estado totalmente inutilizable.  
            La carencia de informaci&oacute;n de usuarios y grupos provoca que 
            las m&aacute;quinas se bloqueen.  Con esto en mente debemos 
            debemos asegurarnos de escoger un servidor de NIS que no se 
            reinicie de forma habitual o uno que no se utilice para 
            para desarrollar.  Si se dispone de una red con poca carga 
            puede resultar aceptable colocar el servidor de NIS en una 
            m&aacute;quina donde se ejecuten otros servicios pero en todo 
            momento se debe tener presente que si por cualquier motivo el 
            servidor de NIS quedara inutilizable afectar&iacute;a a 
            <emphasis>todas</emphasis> las m&aacute;quinas de forma 
            negativa.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Servidores NIS</title>

        <para>Las copias can&oacute;nicas de toda la informaci&oacute;n que 
          mantiene el sistema de p&aacute;ginas amarillas se almacenan en una 
          &uacute;nica m&aacute;quina denominada servidor maestro de NIS.  
          Las bases de datos utilizadas para almacenar la informaci&oacute;n 
	  se denominan mapeos NIS.  En &os; estas asociaciones o mapeos se 
          almacenan en el directorio <filename>/var/yp/[nombrededominio]</filename>
 	  donde <filename>[nombrededominio]</filename> es el nombre del dominio 
          de NIS que el servidor gestiona.  Un &uacute;nico servidor NIS puede 
          gestionar varios dominios al mismo tiempo de forma que resulta 
          posible tener varios directorios como el anterior, uno por cada 
          dominio soportado.  Cada dominio posee su conjunto de mapeos 
          independiente y propio.</para>

        <para>Los servidores maestro y esclavos manejan todas las peticiones de 
          a trav&eacute;s del d&aelig;mon <command>ypserv</command>.   
          El comando <command>ypserv</command> se responsabiliza de recibir 
          peticiones de los clientes NIS.  Estas peticiones se traducen a una 
          ruta dentro del servidor.  Esta ruta localiza un fichero de base de 
          datos determinado del servidor de NIS, y finalmente <command>
          ypserv</command> se encarga de transmitir la informaci&oacute;n de 
          dicha base de datos de vuelta al cliente que la 
          solicit&oacute;.</para>

        <sect4>
	  <title>Configuraci&oacute;n de un Servidor de NIS Maestro</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>server configuration</secondary>
	  </indexterm>
          <para>La configuraci&oacute;n de un servidor de NIS maestro puede 
            resultar relativamente sencilla dependiendo de las necesidades que 
            se tengan.  &os; viene preconfigurado por defecto con un servicio 
	    NIS.  Todo lo que necesitamos es a&ntilde;adir la siguiente 
            l&iacute;nea en <filename>/etc/rc.conf</filename> y 
            &os; se encarga del resto.</para> 

          <procedure>
            <step>
              <para><programlisting>nisdomainname="test-domain"</programlisting> 
                Esta l&iacute;nea establece el nombre de dominio NIS como 
                <literal>test-domain</literal>, cuando se realiza la 
                configuraci&oacute;n de la red (por ejemplo, despu&eacute;s  
                de un reinicio).</para>               
            </step>
            <step>
              <para><programlisting>nis_server_enable="YES"</programlisting>
                Esta variable indica a &os; que ejecute los procesos 
                necesarios para actuar como un servidor de NIS la 
                pr&oacute;xima vez que se configure el subsistema de 
                red.</para>    
            </step>
            <step>
              <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
                Esto permite activar el d&aelig;mon 
                <command>rpc.yppasswdd</command> el cual, como se ha 
                mencionado anteriormente, permite a los usuarios realizar 
                cambios de contrase&ntilde;a desde las m&aacute;quinas clientes 
                de NIS.</para>     
            </step>
          </procedure>

          <note>
            <para>Dependiendo de la configuraci&oacute;n de NIS podemos 
              necesitar a&ntilde;adir algunas entradas m&aacute;s.  Consulte 
              la <link 
              linkend="network-nis-server-is-client">secci&oacute;n sobre 
                servidores NIS que tambi&eacute;n act&uacute;an como 
                clientes</link>, m&aacute;s adelante en el texto, para saber  
              m&aacute;s sobre esto.</para>
          </note>

          <para>Una vez hecho esto todo lo que tenemos que hacer es ejecutar el 
            comando <command>/etc/netstart</command> como superusuario.  Este 
            comando realiza los pasos de configuraci&oacute;n necesarios 
            utilizando los valores de las variables definidas en 
            <filename>/etc/rc.conf</filename>.</para> 
        </sect4>

        <sect4>
          <title>Inicializaci&oacute;n de los mapeos de NIS</title>
          <indexterm>
            <primary>NIS</primary>
            <secondary>maps</secondary>
          </indexterm>
          <para>Las <emphasis>asociaciones o mapeos de NIS</emphasis> 
            no son m&aacute;s que ficheros de base de datos.  
            Estos ficheros se generan a partir de los ficheros de 
            configuraci&oacute;n contenidos en el directorio <filename> 
            etc/</filename> excepto para el caso del fichero <filename>
            etc/master.passwd</filename>.  Esto es as&iacute; por una buena 
            raz&oacute;n ya que no suele ser buena idea propagar las 
            contrase&ntilde;as de <username>root</username> y de otras cuentas 
            de administraci&oacute;n a todos los servidores NIS del dominio.  
            servidores NIS del dominio. As&iacute;, antes de inicializar los 
            mapeos se debe ejecutar:</para>

          <screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

          <para>Se deben borrar todas las entradas que hagan referencia a 
            cuentas del sistema 
            (<username>bin</username>, <username>tty</username>, 
	    <username>kmem</username>, <username>games</username>, 
            etc), junto con cualquier cuenta que no deseemos que se transmita 
            a los clientes NIS (por ejemplo la cuenta de <username>
            root</username> y cualquier otra cuenta con UID 0 (el del 
            superusuario)).</para> 

          <note><para>Aseg&uacute;rese de que 
            <filename>/var/yp/master.passwd</filename> no se puede leer ni por 
            grupos ni por el resto de usuarios (modo 600).  Utilice el 
            comando <command>chmod</command> en caso de necesidad.</para></note>

	  <indexterm><primary>Tru64 UNIX</primary></indexterm>
          <para>Una vez hecho esto es hora de inicializar las asociaciones de 
            NIS.  &os; incluye un <quote>script</quote> denominado 
            <command>ypinit</command> para realizar esta tarea (consulte su 
            p&aacute;gina del manual para obtener m&aacute;s 
            informaci&oacute;n).   Recuerde que este <quote>script</quote> se 
            encuentra disponible en la mayor&iacute;a de los sistemas &unix;, 
            pero no en todos.  En sistemas Digital UNIX/Compaq Tru64 UNIX se 
            denomina <command>ypsetup</command>.  Debido a que se pretende 
            generar asociaciones para un servidor NIS maestro vamos a 
            ejecutar <command>ypinit</command> con la opci&oacute;n 
            <option>-m</option>.  A modo de ejemplo, suponiendo que todos los 
            pasos comentados anteriormente se han realizado con &eacute;xito, 
            ejecute:</para>

          <screen>ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..salida de la generacion de mapeos..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

          <para><command>ypinit</command> deber&iacute;a haber creado el 
            fichero <filename>/var/yp/Makefile</filename> a partir de 
            <filename>/var/yp/Makefile.dist</filename>.  
            Una vez creado este archivo presupone que se est&aacute; usando un 
            entorno NIS con un &uacute;nico servidor utilizando 
            s&oacute;lamente m&aacute;quinas &os;.  Debido a que 
            <literal>test-domain</literal> posee tambi&eacute;n un servidor 
            NIS esclavo se debe editar el fichero <filename>
            var/yp/Makefile</filename>:</para>

          <screen>ellington&prompt.root; <userinput>vi
              /var/yp/Makefile</userinput></screen> 

	  <para>Se debe comentar la l&iacute;nea que dice:</para> 

	  <programlisting>NOPUSH = "True"</programlisting>

	  <para>(si es que no se encuentra ya comentada).</para>
        </sect4>

        <sect4>
	  <title>Configuraci&oacute;n de un Servidor NIS
            Esclavo</title> 
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>slave server</secondary>
	  </indexterm>
	  <para>La configuraci&oacute;n de un servidor NIS esclavo resulta ser 
            incluso m&aacute;s sencilla que la del maestro.  Basta con entrar 
            en el servidor esclavo y editar <filename>/etc/rc.conf</filename> 
            de foma semejante a como se realiz&oacute; en el apartado 
            anterior.  La &uacute;nica diferencia consiste en que ahora debemos 
            utilizar la opci&oacute;n <option>-s</option> cuando ejecutemos 
            ejecutemos <command>ypinit</command>.  A continuaci&oacute;n del 
            par&aacute;metro <option>-s</option> se debe especificar el nombre 
	    del servidor maestro de modo que el comando tendr&iacute;a que ser 
            algo parecido a esto:</para>

  <screen>coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.</screen>

	  <para>En estos momentos debemos tener un nuevo directorio llamado 
	    <filename>/var/yp/test-domain</filename>.  Las copias de los 
            mapeos del servidor maestro se almacenan en dicho directorio.  
            Es nuestra responsabilidad como administradores asegurar que dichas 
            copias permanecen actualizadas en todo momento.  La siguiente 
            entrada en el archivo <filename>/etc/crontab</filename> del 
            servidor esclavo se encarga de realizar esta tarea:</para>

	  <programlisting>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	  <para>Estas dos l&iacute;neas obligan al servidor esclavo a 
            sincronizar los mapeos con el servidor maestro.  Estas entradas no 
            son obligatorias ya que el servidor maestro siempre intenta 
            comunicar cualquier cambio que se produzca en sus asociaciones 
            a todos los servidores esclavos ya que la informaci&oacute;n de, 
            esclavos, ya que la informaci&oacute;n de, por ejemplo, 
            contrase&ntilde;as es de vital importancia para el funcionamiento 
            de los sistemas que dependen del servidor.  No obstante es una 
            buena idea obligar a que se realicen estos cambios mediante las 
            entradas anteriores.  Esto resulta ser incluso m&aacute;s 
            importante en redes de sobrecargadas donde las actualizaciones de 
            asociaciones pueden algunas veces no llegar a realizarse de forma 
            completa.</para> 

          <para>A continuaci&oacute;n se ejecuta el comando 
            <command>/etc/netstart</command> en el servidor esclavo de igual 
            de igual forma que se hizo con el servidor maestro; esto relanza 
            de nuevo el servidor de NIS.</para>           
	</sect4>
      </sect3>

      <sect3>
        <title>Clientes NIS</title>

	<para>Un cliente de NIS establece lo que se conoce con el nombre de 
          asociaci&oacute;n (bind en ingl&eacute;s) con un servidor NIS 
          NIS determinado utilizando el d&aelig;mon <command>
	  ypbind</command>.  <command>ypbind</command> comprueba el dominio 
          por defecto del sistema (especificado mediante el comando 
          <command>domainname</command>) y comienza a enviar peticiones 
          RPC a todos los elementos de la red local (broadcast).  Estas 
          peticiones especifican el nombre del dominio con el que se quiere 
          establecer la asociaci&oacute;n.  Si esta petici&oacute;n alcanza una 
          petici&oacute;n alcanza un servidor NIS configurado para servir dicho 
          dominio el servidor responde a la petici&oacute;n e 
          <command>ypbind</command> almacenar&aacute; la direcci&oacute;n de 
          dicho servidor.  Si existen varios servidores disponibles (un maestro 
          y varios esclavos, por ejemplo), <command>ypbind</command> 
          utilizar&aacute; la direcci&oacute;n del primero en responder.  
          A partir de este punto el cliente dirigir&aacute; el resto de sus 
          peticiones NIS directamente a la direcci&oacute;n IP almacenada.  
          Ocasionalmente <command>ypbind</command> env&iacute;a un 
          <quote>ping</quote> sobre el servidor para comprobar que en efecto 
          se encuentra funcionando.  Si no se recibe contestaci&oacute;n al 
          ping dentro de un espacio de tiempo determinado 
          <command>ypbind</command> marca el dominio como <quote>sin 
          asociar</quote> y comienza de nuevo a inundar la red con la esperanza 
          de localizar alg&uacute;n otro servidor NIS.</para> 
         
	<sect4>
	  <title>Configuraci&oacute;n de un cliente NIS</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>client configuration</secondary>
	  </indexterm>
	  <para>La configuraci&oacute;n de un cliente &os; de NIS resulta ser 
            una operaci&oacute;n extremadamente sencilla.</para>

	  <procedure>
	    <step>
	      <para>Editar el fichero 
                <filename>/etc/rc.conf</filename> y a&ntilde;adir las 
                siguientes l&iacute;neas para establecer el nombre de dominio  
                NIS y para que se ejecute 
                <command>ypbind</command> al arranque de la red:</para>

	      <programlisting>nisdomainname="test-domain"
nis_client_enable="YES"</programlisting>
	    </step>

	    <step>
              <para>Para importar todas las entradas de contrase&ntilde;as del 
                servidor de NIS hay que eliminar todas las cuentas de usuario 
                de <filename>/etc/master.passwd</filename> y utilizar 
		<command>vipw</command> para a&ntilde;adir la siguiente 
                l&iacute;nea al final de dicho fichero:</para>

	      <programlisting>+:::::::::</programlisting>

	      <note>
                <para>Esta l&iacute;nea permite que cualquiera abra una cuenta 
                  en local, siempre que dicha cuenta se encuentre definida en 
                  las asociaciones de cuentas y contrase&ntilde;as del 
                  servidor NIS. Existen varias formas de configurar los 
                  clientes NIS modificando esta l&iacute;nea.  Consulte la 
                  <link 
                    linkend="network-netgroups">secci&oacute;n sobre 
                    netgroups</link> que se encuentra m&aacute;s adelante en 
		  este mismo texto.  Si quiere saber m&aacute;s puede consultar 
                  el libro de O'Reilly <literal>Managing NFS and 
                    NIS</literal>.</para> 
	      </note>

              <note>
                <para>Se debe mantener al menos una cuenta local (por ejemplo, 
                  una cuenta que no se importe a trav&eacute;s de NIS) en 
                  el fichero <filename>/etc/master.passwd</filename> y 
                  adem&aacute;s dicha cuenta deber&iacute;a ser miembro del 
                  grupo <groupname>wheel</groupname>.  Si algo va mal con el 
                  procedimiento descrito esta cuenta se puede utilizar 
                  para entrar en la m&aacute;quina cliente de forma remota 
                  para posteriormente convertirse en superusuario e intentar 
                  solucionar el problema.</para> 
              </note>
            </step>

	    <step>
	      <para>Para importar todas las entradas de grupo posibles del 
                servidor NIS se debe a&ntilde;adir la siguiente l&iacute;nea 
                al fichero <filename>/etc/group</filename>:</para> 

	      <programlisting>+:*::</programlisting>
	    </step>
	  </procedure>

	  <para>Despu&eacute;s de completar estos pasos deber&iacute;mos ser 
	    capaces de ejecutar <command>ypcat passwd</command> y ver la 
	    asociaci&oacute;n de contrase&ntilde;as que se encuentra en el 
            servidor de NIS</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Seguridad en NIS</title>

      <para>En general cualquier usuario remoto puede realizar peticiones de 
	RPC a &man.ypserv.8; y recuperar los contenidos de las asociaciones 
        de NIS siempre y cuando el usuario remoto conozca el nombre de 
        dominio de NIS.  Para evitar este tipo de transacciones no autorizadas, 
        &man.ypserv.8; soporta una caracter&iacute;stica denominada 
        <quote>securenets</quote> la cual se puede utilizar para limitar el 
        acceso a un determinado conjunto de m&aacute;quinas.  En el arranque 
        &man.ypserv.8; intenta cargar la informaci&oacute;n de 
        <quote>securenets</quote> a partir de un fichero denominado 
     	<filename>/var/yp/securenets</filename>.</para>

      <note>
        <para>Esta ruta de fichero var&iacute;a dependiendo del camino 
          especificado con la opci&oacute;n <option>-p</option>.  Dicho fichero 
          contiene entradas compuestas de, por un lado, un rango de red y por 
          otro una m&aacute;scara de red, separados por espacios en blanco.  
          Las l&iacute;neas que comienzan por <quote>#</quote> se consideran 
          comentarios.  A continuaci&oacute;n se muestra un ejemplo de un 
          fichero <quote>securenet</quote>:</para> 
      </note>

      <programlisting># admitir conexiones desde localhost -- obligatorio
127.0.0.1     255.255.255.255
# admitir conexiones desde cualquier host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# admitir conexiones desde cualquier host
# between 10.0.0.0 to 10.0.15.255
# esto incluye las maquinas en el 'testlab'
10.0.0.0      255.255.240.0</programlisting>

      <para>Si &man.ypserv.8; recibe una petici&oacute;n de una 
        direcci&oacute;n que coincide con alguna de las reglas especificadas 
        en el fichero se procesa la petici&oacute;n.  Si no existe ninguna 
        coincidencia la petici&oacute;n se rechaza y se graba un mensaje de 
        aviso.  Si el archivo 
        <filename>/var/yp/securnets</filename> no existe 
        <command>ypserv</command> acepta conexiones de cualquier 
        m&aacute;quina.</para>

      <para>El programa <command>ypserv</command> tambi&eacute;n posee soporte 
        para el paquete de Wietse Venema denominado <application>
	tcpwrapper</application>.  Este paquete permite utilizar los ficheros 
        de configuraci&oacute;n de <application>tcpwrapper</application> para 
        realizar control de acceso en lugar de utilizar <filename>
	var/yp/securenets</filename>.</para>

      <note>
        <para>Aunque ambos mecanismos de control de acceso proporcionan un 
          grado de seguridad mayor que no utilizar nada resultan vulnerables 
          a ataques de <quote>falsificaci&oacute;n de IPs</quote>.  El 
	  cortafuegos de la red donde se implanta el servicio de NIS 
          deber&iacute;a encargarse de bloquear el tr&aacute;fico 
          espec&iacute;fico de dicho servicio.</para> 

        <para>Los servidores que utilizan 
          <filename>/var/yp/securenets</filename> 
          pueden no prestar servicio a clientes NIS leg&iacute;timos cuando se 
          trabaja con implementaciones arcaicas de TCP/IP.   Algunas de estas 
          implementaciones ponen a cero todos los bits de m&aacute;quina 
          cuando se realizan broadcast y/o pueden fallar al especificar la 
          m&aacute;scara de red en el mismo caso, por citar algunos 
          ejemplos.  Mientras que algunos de estos problemas se pueden 
	  solucionar variando la configuraci&oacute;n del cliente en otros 
          casos podemos vernos obligados a prescindir del cliente en 
	  cuesti&oacute;n o a prescindir del fichero <filename>
          var/yp/securenets</filename>.</para>

        <para>Se desaconseja la utilizaci&oacute;n de <filename>
          var/yp/securenets</filename> en un sistema con una 
          implementaci&oacute;n arcaica de TCP/IP y puede suponer una 
          p&eacute;rdida de funcionalidad para grandes zonas de la red.</para> 
   
	<indexterm><primary>tcpwrapper</primary></indexterm>
        <para>La utilizaci&oacute;n del paquete 
          <application>tcpwrapper</application> incrementa la latencia del  
          servidor NIS.  El retardo adicional introducido puede ser lo 
          suficientemente grande como para causar la expiraci&oacute;n de 
	  ciertos temporizadores de los programas clientes, especialmente en 
          redes muy cargadas o con servidores de NIS lentos.  Si se 
          experimentan estos s&iacute;ntomas en varias m&aacute;quinas 
	  clientes, puede ser conveniente convertir dichas m&aacute;quinas 
          en servidores NIS esclavos y obligarlas a asociarse con ellas 
          mismas.</para> 
      </note>
    </sect2>

    <sect2>
      <title>Prohibir el Acceso a Determinados Usuarios</title>

      <para>En nuestro laboratorio de ejemplo existe una 
        m&aacute;quina denominada <hostid>basie</hostid> que 
        act&uacute;a s&oacute;lo como una estaci&oacute;n de trabajo para el 
        profesorado.  No queremos sacar a esta m&aacute;quina del dominio NIS 
        pero nos damos cuenta de que el fichero <filename>passwd</filename> 
        que se encuentra en el servidor de NIS posee cuentas tanto para 
        profesores como para alumnos. &iquest;Qu&eacute; podemos 
        hacer?.</para> 

      <para>Existe una forma de prohibir el acceso a determinados usuarios 
        sobre una determinada m&aacute;quina incluso aunque se encuentren dados 
        de alta en la base de datos de NIS.  Para realizar esto todo lo que 
        debemos hacer es a&ntilde;adir 
        <literal>-<replaceable>nombredeusuario</replaceable></literal> al final del 
        fichero <filename>/etc/master.passwd</filename> en la m&aacute;quina 
        cliente donde <replaceable>nombredeusuario</replaceable> es el nombre 
        de usuario del usuario al que queremos prohibirle el acceso.  
        Esto se debe realizar a poder ser mediante el comando 
        <command>vipw</command> ya que <command>vipw</command> realiza  
        comprobaciones de seguridad sobre los cambios realizados y 
        adem&aacute;s se encarga de reconstruir la base de datos de 
        contrase&ntilde;as cuando se termina la edici&oacute;n. Por ejemplo, 
        si quisi&eacute;ramos prohibir el acceso al usuario <username>
        bill</username> a la m&aacute;quina <hostid>basie</hostid> 
        har&iacute;amos:</para>
      

        <screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[a&ntilde;adimos -bill al final y salimos]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
    </sect2>

    <sect2 id="network-netgroups">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Udo</firstname>
            <surname>Erdelhoff</surname>
            <contrib>Escrito por </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Utilizaci&oacute;n de Netgroups</title>
      <indexterm><primary>netgroups</primary></indexterm>

      <para>El m&eacute;todo descrito en la secci&oacute;n anterior funciona 
        razonablemente bien si las reglas especiales se definen para un 
        conjunto peque&ntilde;o de usuarios y/o m&aacute;quinas.  En dominios 
        admnistrativos grandes puede que se nos <emphasis>olvide</emphasis> 
        prohibir el acceso a alg&uacute;n usuario en determinadas 
        m&aacute;quinas perdiendo de esta forma el principal beneficio de 
        utilizar el servicio de p&aacute;ginas amarillas:<emphasis>
	administraci&oacute;n centralizada</emphasis>.</para>
        
      <para>La soluci&oacute;n creada por los desarrolladores de NIS se 
        denomina <emphasis>netgroups</emphasis>.  Su prop&oacute;sito se 
        asemeja al concepto de grupos utilizado por los sistemas &unix;.  La 
        diferencia principal es la carencia de un identificador 
        num&eacute;rico y la habilidad para definir un <quote>netgroup</quote> 
        que incluye tanto a cuentas de usuario como a otros 
        <quote>netgroups</quote>.</para> 
         
      <para>Los netgroups se desarrollaron para gestionar redes grandes y 
        y complejas con cientos de usuarios y m&aacute;quinas.  Por un lado 
        esto es una Cosa Buena si nos encontramos en tal situaci&oacute;n 
        pero por otro lado esta complejidad a&ntilde;adida hace que sea casi 
        imposible de explicar a trav&eacute;s de ejemplos sencillos.  El 
        ejemplo que va a utilizar en lo que queda de secci&oacute;n 
        ilustrar&aacute; este hecho.</para> 
       
      <para>Vamos a suponer que la exitosa introducci&oacute;n del servicio de 
        p&aacute;ginas amarillas en nuestro laboratorio ha llamado la 
        atenci&oacute;n de nuestros jefes.  Nuestra siguiente tarea consiste en 
        extender el dominio de NIS para que cubra otras m&aacute;quinas del 
        campus.  Las tablas que se muestran a continuaci&oacute;n contienen los 
        nombres de los nuevos usuarios y m&aacute;quinas junto con una breve 
        descripci&oacute;n de ellas.</para> 

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Nombre del Usuario/usuarios</entry>
              <entry>Descripci&oacute;n</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><username>alpha</username>, <username>beta</username></entry>
              <entry>Empleados normales del departamento de IT</entry>
            </row>

            <row>
              <entry><username>charlie</username>, <username>delta</username></entry>
              <entry>Los nuevos aprendices del departamento de IT</entry>
            </row>

            <row>
              <entry><username>echo</username>, <username>foxtrott</username>, <username>golf</username>, ...</entry>
              <entry>Empleados normales</entry>
            </row>

            <row>
              <entry><username>able</username>, <username>baker</username>, ...</entry>
              <entry>Los actuales internos</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Nombre de la M&aacute;quina(s)</entry>
              <entry>Descripci&oacute;n</entry>
            </row>
          </thead>

          <tbody>
            <row>
	      <!-- Nombres provenientes de "Buenos Presagios" de Neil Gaiman y 
	           Terry Pratchett.  Muchas gracias por ese libro 
		   tan brillante. -->
	      <!-- Nota del Revisor: No era del todo necesario traducir los 
	           nombres de los hosts pero siendo el revisor fan convicto y 
		   confeso de Terry Pratchett no ha habido mas remedio -->
              <entry><hostid>guerra</hostid>, <hostid>muerte</hostid>,
                <hostid>hambre</hostid>,
                <hostid>peste</hostid></entry> 
              <entry>Los servidores m&aacute;s
                importantes. S&oacute;lo los empleados de IT pueden
                entrar en estas m&aacute;quinas</entry> 
            </row>
            <row>
	      <!-- omitimos gula porque estaba muy gorda -->
              <entry><hostid>orgullo</hostid>, <hostid>avaricia</hostid>,
                <hostid>envidia</hostid>, <hostid>ira</hostid>,
                <hostid>lujuria</hostid>, <hostid>pereza</hostid></entry> 
              <entry>Servidores de menor importancia.  Todos los miembros del 
                departamento de IT pueden entrar en ellos.</entry>
            </row>

            <row>
              <entry><hostid>uno</hostid>, <hostid>dos</hostid>,
                <hostid>tres</hostid>, <hostid>cuatro</hostid>,
                ...</entry> 
              <entry>Estaciones de trabajo ordinarias.  S&oacute;lo los 
                empleados <emphasis>actuales</emphasis> pueden utilizar estas 
                m&aacute;quinas.</entry>
            </row>

            <row>
              <entry><hostid>trashcan</hostid></entry>
              <entry>Una m&aacute;quina muy vieja sin ning&uacute;n dato 
                dato cr&iacute;tico.  Incluso los internos pueden utilizar 
                esta m&aacute;quina.</entry> 
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Si se trata de implementar estas restricciones a nivel de usuario 
        particular tendr&iacute;amos que a&ntilde;adir una l&iacute;nea 
        <literal>-<replaceable>usuario</replaceable></literal> a cada fichero 
        <filename>passwd</filename> del sistema para cada usuario que tuviera 
        prohibido el acceso a dicho sistema.  Si nos olvidamos de una sola 
        entrada podr&iacute;mos tener serios problemas.  Puede ser factible 
        realizar esta configuraci&oacute;n cuando se instala el servicio pero 
        no obstante el riesgo que corremos al mantener este sistema de 
	restricciones en el d&iacute;a d&iacute;a es muy alto.  Despu&eacute;s 
        de todo Murphy era un optimista.</para>

      <para>La gesti&oacute;n de esta situaci&oacute;n mediante netgroups 
        ofrece varias ventajas.  Cada usuario no tiene que tratarse de una 
        forma individualizada; basta con a&ntilde;adir un usuario a uno o 
        m&aacute;s netgroups y posteriormente permitir o prohibir el acceso 
        para todos los usuarios del netgroup.  Si se a&ntilde;ade una nueva 
        m&aacute;quina al servicio de NIS simplemente tendremos que definir 
        restricciones de acceso para los netgroups definidos en la 
        red.  Si se a&ntilde;ade un nuevo usuario bastar&aacute; con 
        a&ntilde;adir dicho usuario a un netgroup existente. Estos cambios son 
        independientes unos de otros: se acab&oacute; la necesidad de aplicar 
        la frase <quote>por cada combinaci&oacute;n de usuario y m&aacute;quina 
          haga esto y esto</quote>.  Si hemos planificado nuestro servicio de 
        NIS cuidadosamente, s&oacute;lo tendremos que modificar un fichero de 
        configuraci&oacute;n en un determinado servidor para permitir o denegar 
        estos accesos.</para>  
        
      <para>El primer paso consiste en la inicializaci&oacute;n de la 
        asociaci&oacute;n o mapeo del netgroup.  El comando de &os; 
       &man.ypinit.8; no crea este mapeo por defecto pero una vez creado 
        ser&aacute; tenido en cuenta por la implementaci&oacute;n de NIS.  
       Para crear una asociaci&oacute;n vac&iacute;a simplemente 
        escriba:</para> 
 
      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>y comienze a a&ntilde;adir contenido.  En nuestro ejemplo 
        necesitamos al menos cuatro netgroups: empleados de IT, 
         aprendices de IT, empleados normales e internos.</para> 

      <programlisting>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</programlisting>
     
      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal> etc.  
        son los nombres de los netgroups.  Cada conjunto delimitado por  
        par&eacute;ntesis define una o m&aacute;s cuentas como pertenecientes 
        al netgroup.  Existen tres campos definidos dentro de dichos de dichos 
        grupos:</para>

      <orderedlist>
        <listitem>
          <para>El nombre de las m&aacute;quinas donde los siguientes items 
            son aplicables.  Si no se especifica un nombre de 
            m&aacute;quina la entrada se aplica a todas las m&aacute;quinas 
            existentes.  Si se especifica una m&aacute;quina determinada 
            entraremos en un mundo lleno de horrores y confusiones as&iacute; 
            que mejor no hacerlo.</para> 
        </listitem> 

        <listitem>
          <para>El nombre de la cuenta que pertenece al netgroup que estamos 
            definiendo.</para> 
        </listitem>

        <listitem> 
          <para>El dominio NIS donde reside la cuenta.  Se pueden importar 
            cuentas de otros dominios NIS (en caso de que usted pertenezca al 
            extra&ntilde;o grupo de personas que gestionan m&aacute;s de un 
            dominio NIS.</para> 
        </listitem>
      </orderedlist>

      <para>Cada uno de estos campos puede contener comodines.  Consulte 
        &man.netgroup.5; para obtener m&aacute;s detalles.</para> 

      <note>
        <indexterm><primary>netgroups</primary></indexterm>
        <para>No se deben utilizar nombres de los netgroups superiores
          a ocho caracteres, especialmente si las m&aacute;quinas de nuestro 
          dominio utilizan sistemas operativos variados.  Los nombres son 
          sensibles a las may&uacute;sculas/min&uacute;sculas: se recomienda 
          utilizar nombres en may&uacute;sculas para distinguirlos de los 
          usuarios o m&aacute;quinas.</para> 

        <para>Algunos clientes de NIS (distintos de los clientes &os;) no 
          pueden gestionar netgroups con un gran n&uacute;mero de entradas.  
          Por ejemplo algunas versiones antiguas de &sunos; comienzan a 
          presentar problemas si un netgroup contiene m&aacute;s de 
          <emphasis>quince entradas</emphasis>.  Se puede solventar este 
          problema creando varios sub-netgroups de como mucho quince usuarios 
          y finalmente creando el verdadero netgroup compuesto por los 
          sub-netgroups:</para> 

        <programlisting>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

        <para>Se puede repetir este proceso si se tienen que definir 
          m&aacute;s de 225 usuarios dentro de un &uacute;nico netgroup.</para>
      </note> 

      <para>La activaci&oacute;n y distribuci&oacute;n de nuestro nuevo mapeo 
        NIS resulta sencillo:</para> 

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>

      <para>Esto genera las tres asociaciones NIS 
        <filename>netgroup</filename>, <filename>netgroup.byhost</filename> y 
        <filename>netgroup.byuser</filename>.  Utilice &man.ypcat.1; para 
        comprobar si el nuevo mapeo NIS se encuentra disponible:</para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>La salida del primer comando deber&iacute;a parecerse a los 
        contenidos del fichero  
        <filename>/var/yp/netgroup</filename>.  El segundo comando no 
        mostrar&aacute; ninguna salida salvo que se hayan especificado 
        netgroups espec&iacute;ficos para m&aacute;quinas.  El tercer comando 
        se puede utilizar para obtener la lista de los netgroups a los que 
        petenece un determinado usuario.</para> 

      <para>La configuraci&oacute;n del cliente es bastante simple.  Para 
        configurar el servidor <hostid>guerra</hostid> se debe ejecutar 
        &man.vipw.8; y sustitu&iacute;r la l&iacute;nea</para> 

      <programlisting>+:::::::::</programlisting>

      <para>por</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>Ahora s&oacute;lo se importan los datos para los usuarios
        que se encuentren definidos en el netgroup 
        <literal>IT_EMP</literal>; dichos datos se importan en la base de datos 
        de contrase&ntilde;as de <hostid>guerra</hostid> y s&oacute;lo se 
        permite el acceso a estos usuarios.</para> 

      <para>Por desgraciaesta informaci&oacute;n tambi&eacute;n se aplica a la 
        funci&oacute;n <literal>~</literal> del shell y a todas las rutinas que 
        traducen nombres de usuarios con los correspondientes identificadores 
        n&uacute;mericos de usuario (uid).  En otras palabras, el comando 
        <command>cd 
          ~</command> no va a funcionar, el comando <command>ls 
          -l</command> muestra el identificador num&eacute;rico en lugar del 
        nombre de usuario y el comando <command>find . -user joe 
          -print</command> produce un error de <errorname>
        No such user</errorname> (<quote>Usuario desconocido</quote>).  Para 
        solucionar esto debemos importar todas las entradas de usuario en la  
        m&aacute;quina cliente NIS pero sin permitirles el acceso.</para>

      <para>Esto se puede realizar a&ntilde;adiendo otra l&iacute;nea
        al fichero <filename>/etc/master.passwd</filename>.  Esta l&iacute;nea 
        deber&iacute;a contener lo siguiente:</para> 

      <para><literal>+:::::::::/sbin/nologin</literal>, lo que significa que se 
        <quote>importen todas las entradas pero que se reemplace el shell por 
        <filename>/sbin/nologin</filename></quote>.  Se puede sustituir 
        cualquier campo de la entrada de contrase&ntilde;as especificando un 
        valor concreto para dicho campo en el fichero local 
        local <filename>/etc/master.passwd</filename>.</para> 

      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>
        <para>Aseg&uacute;rese de que la l&iacute;nea 
        <literal>+:::::::::/sbin/nologin</literal> se sit&uacute;a 
          despu&eacute;s de 
        <literal>+@IT_EMP:::::::::</literal>.  Si esto no se cumple todas las 
          cuentas de usuario  importadas del servidor NIS poseer&aacute;n 
          <filename>/sbin/nologin</filename> como shell de acceso.</para>
      </warning>

      <para>Despu&eacute;s de este cambio si se introduce un nuevo empleado 
        en el departamento de IT basta con cambiar una asociaci&oacute;n de 
        NIS.  Se podr&iacute;a aplicar una aproximaci&oacute;n similar para los 
        servidores menos importantes sustituyendo la cadena 
        <literal>+:::::::::</literal> en las versiones locales del fichero 
        <filename>/etc/master.passwd</filename> por algo parecido a 
        esto:</para>       

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Las l&iacute;neas correspondientes para las estaciones de trabajo 
        normales podr&iacute;an ser:</para> 

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>
 
      <para>Y parece que todos nuestros problemas de gesti&oacute;n han 
        desaparecido; hasta que unas semanas m&aacute;s tarde se produce un 
        cambio en la pol&iacute;tica de gesti&oacute;n: el depatamento de IT 
        comienza a alquilar interinos.  Los interinos de IT pueden utilizar 
        las estaciones de trabajo normales y los servidores menos importantes 
        y los aprendices de IT pueden acceder a los servidores principales.  
        No nos queda m&aacute;s remedio que a&ntilde;adir un nuevo netgroup 
        denominado <literal>IT_INTERN</literal> y a&ntilde;adir los nuevos  
        interinos de IT a este nuevo grupo y comenzar a cambiar la 
        la configuraci&oacute;n de cada m&aacute;quina, una por una...  
        Como dice el antiguo proverbio: <quote>Errores en la
          planificaci&oacute;n centralizada conllevan grandes quebraderos de 
          de cabeza globales</quote>.</para>

      <para>La habilidad que posee NIS para crear netgroups a partir de otros 
        netgroups se puede utilizar para evitar la situaci&oacute;n 
        anterior.  Una posibilidad consiste en la creaci&oacute;n de netgroups 
        basados en roles.  Por ejemplo, se podr&iacute;a crear un netgroup 
        denominado <literal>BIGSRV</literal> para definir las restricciones 
        de acceso para los servidores importantes, otro grupo denominado 
        <literal>USERBOX</literal> para las estaciones de trabajo... Cada uno 
        de estos netgroups podr&iacute;a contener los netgroups que pueden 
        acceder a dichas m&aacute;quinas.  Las nuevas entradas para nuestro 
        mapeo NIS de netgroups ser&iacute;a algo as&iacute;:</para>

      <programlisting>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</programlisting>

      <para>Este m&eacute;todo de definir restricciones de acceso funciona 
        razonablemente bien si podemos definir grupos de m&aacute;quinas 
        que posean restricciones semejantes.  Por desgracia lo normal es que 
        este caso resulta ser una excepci&oacute;n m&aacute;s que una regla.  
        En la mayor parte de las ocasiones necesitaremos definir restricciones 
        de acceso en funci&oacute;n de m&aacute;quinas individuales.</para>
  
      <para>Las definiciones de netgroups espec&iacute;ficos para determinadas 
        m&aacute;quinas constituyen el segundo m&eacute;todo que se puede 
        utilizar para gestionar el cambio de pol&iacute;tica del ejemplo 
        que estamos explicando.  En nuestro caso el fichero         
        <filename>/etc/master.passwd</filename> de cada m&aacute;quina 
        contiene dos l&iacute;neas que comienzan por 
        <quote>+</quote>.  La primera de ellas a&ntilde;ade un netgroup con las 
        cuentas que pueden acceder a esa m&aacute;quina, mientras que la
        segunda a&ntilde;ade el resto de cuentas con shell 
        el resto de cuentas con shell
        <filename>/sbin/nologin</filename>.  Es una buena idea utilizar la 
        versi&oacute;n <quote>todo en may&uacute;sculas</quote> del nombre de 
        m&aacute;quina como el nombre del netgroup.  En otras palabras, las 
        l&iacute;neas deber&iacute;an ser como la siguiente:</para>

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Una vez que hemos completado esta tarea para todas las
        m&aacute;quinas nunca m&aacute;s resultar&aacute; necesario modificar 
        las versiones locales de <filename>/etc/master.passwd</filename>.  
        Los futuros cambios se pueden gestionar simplemente modificando el 
        mapeo o asociaci&oacute;n de NIS.  A continuaci&oacute;n se muestra un 
        mapeo de netgroups para el escenario que se est&aacute; explicando  
        junto con algunas buenas ideas:</para>

      <programlisting># Definimos antes que nada los grupos de usuarios
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Ahora definimos unos pocos grupos basados en roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# Y un grupo para tareas especiales
# Permitimos a echo y golf acceso a nuestra maquina-anti-virus
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# netgroups basados en maquinas
# Nuestros servidores principales
GUERRA   BIGSRV
HAMBRE   BIGSRV
# El usuario india necesita acceso a este servidor
PESTE  BIGSRV  (,india,test-domain)
#
# Este es realmente importante y necesita mas restricciones de 
# acceso
MUERTE     IT_EMP
#
# La maquina-anti-virus que mencionabamos mas arriba
ONE       SECURITY
#
# Restringimos una maquina a un solo usuario
TWO       (,hotel,test-domain)
# [...otros grupos]</programlisting>

      <para>Si estamos utilizando algun tipo de base de datos para gestionar 
        cuentas de usuario debemos ser capaces de crear la primera parte del 
        mapeo utilizando las herramientas proporcionadas por dicho sistema 
        de base de datos.   De este modo los nuevos usuarios tendr&aacute;n 
        autom&aacute;ticamente derechos de acceso sobre las m&aacute;quinas.
        </para> 

      <para>Una &uacute;ltima, por precauci&oacute;n: puede no ser siempre 
        aconsejable utilizar netgroups basados en m&aacute;quinas.  Si se 
        est&aacute;n desplegando, por ejemplo, un par de docenas o 
        incluso cientos de m&aacute;quinas id&eacute;nticas en laboratorios 
        de estudiantes, es mejor utilizar netgroups basados en roles en lugar 
        de netgroups basados en m&aacute;quinas individuales 
        para mantener el tama&ntilde;o de la asociaci&oacute;n NIS dentro de 
        unos l&iacute;mites razonables.</para> 
    </sect2>

    <sect2>
      <title>Cosas Importantes para Recordar</title>

      <para>Todav&iacute;a quedan un par de cosas que tendremos que hacer de 
        forma distinta a lo comentado hasta ahora en caso de encontrarnos 
        dentro de un entorno de NIS.</para> 

      <itemizedlist>
        <listitem>
          <para>Cada vez que deseemos a&ntilde;adir un usuario a nuestro 
            laboratorio debemos a&ntilde;adirlo al servidor NIS maestro 
            <emphasis>&uacute;nicamente</emphasis> y es tarea fundamental del 
            administrador <emphasis>acordarse de reconstruir los mapeos 
            NIS</emphasis>.  Si nos olvidamos de esto el nuevo usuario 
            ser&aacute; incapaz de acceder a ninguna m&aacute;quina excepto al 
            servidor NIS.  Por ejemplo, si necesit&aacute;ramos 
            a&ntilde;adir el nuevo usuario <username>jsmith</username> al 
            laboratorio tendr&iacute;amos que ejecutar lo siguiente:</para> 

          <screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

          <para>Se puede ejecutar tambi&eacute;n <command>adduser
              jsmith</command> en lugar de  
            <command>pw useradd jsmith</command>.</para>
        </listitem>
        <listitem>
          <para><emphasis>No introduzca las cuentas de administraci&oacute;n 
            dentro de los mapeos de NIS</emphasis>.  No es buena idea 
            propagar cuentas y contrase&ntilde;as de administraci&oacute;n a 
            m&aacute;quinas donde residen usuarios que normalmente no 
            deber&iacute;an poder acceder a dichas cuentas.</para>
        </listitem>
        <listitem>
          <para><emphasis>Mantenga el servidor maestro y esclavo de NIS 
            seguros y minimize el tiempo de interrupci&oacute;n del 
            servicio</emphasis>.  Si alguien fuera capaz de comprometer la 
            integridad de estas m&aacute;quinas o de apagarlas los usuarios 
            del dominio no podr&iacute;an acceder a sus cuentas en 
            ning&uacute;n sistema.</para>
         
          <para>Esto es la debilidad principal de cualquier sistema de 
          administraci&oacute;n centralizada.  Si no se protegen los servidores 
          NIS tendremos frente a nosotros a una horda de usuarios bastante 
          enfadados.</para> 
        </listitem>
      </itemizedlist> 
    </sect2>

    <sect2>
      <title>Compatibilidad con NIS v1</title>

      <para> El servicio <application>ypserv</application> de &os; puede servir 
        tambi&eacute;n a clientes NIS v1.  La implementaci&oacute;n de NIS de 
        &os; s&oacute;lo utiliza el protocolo NIS v2 aunque otras 
        implementaciones incluyen soporte para el protocolo v1 por razones de 
        compatibilidad con sistemas antiguos.  Los d&aelig;mones  
        <application>ypbind</application> suministrados con estos sistemas 
        tratan de establecer una asociaci&oacute;n con un servidor NIS 
        versi&oacute;n 1 aunque puede que nunca la lleguen a utilizar (y 
        pueden continuar realizando b&uacute;squedas mediante broadcast incluso 
	cuando reciben una respuesta de un servidor versi&oacute;n 2).  
        Tenga muy presente que mientras se soportan las llamadas normales de 
	clientes v1, la versi&oacute;n de <application>ypserv</application> 
        actualmente suministrada no gestiona peticiones de transferencia de 
        mapeos a trav&eacute;s de la versi&oacute;n 1; en consecuencia no se 
        puede utilizar como maestro o esclavo junto con servidores de NIS 
        antiguos que s&oacute;lo soporten el protocolo v1.  Por suerte quedan 
        muy pocos servidores de este estilo en funcionamiento hoy en 
	d&iacute;a.</para>

    </sect2>

    <sect2 id="network-nis-server-is-client">
      <title>Servidores NIS que Act&uacute;an Tambi&eacute;n Como Clientes 
        NIS</title>

          <para>Se debe tener cuidado cuando se ejecuta 
            <application>ypserv</application> en un entorno multi-servidor 
            donde las m&aacute;quinas servidoras act&uacute;an 
            tambi&eacute;n como m&aacute;quinas clientes de NIS.  Normalmente 
	    es una buena idea obligar a los servidores a que se asocien con 
            ellos mismos mejor que permitirles emitir peticiones de 
            asociaci&oacute;n en broadcast, lo que posiblemente 
	    terminar&aacute; con los servidores asociados entre s&iacute;.  
            Se pueden producir extra&ntilde;os fallos si un servidor del que 
	    dependen otros deja de funcionar.  Puede darse que los contadores 
	    de todos los clientes expiren e intenten asociarse a otro 
	    servidor, pero el retardo puede ser considerable y los fallos 
	    todav&iacute;a podr&iacute;n persistir debido a que los servidores 
            se asocian cont&iacute;nuamente los unos a los otros.</para>

          <para>Se puede obligar a una m&aacute;quina a asociarse con un 
            servidor en particular ejecutando 
            <command>ypbind</command> con la opci&oacute;n 
            <option>-S</option>.  Si no se quiere ejecutar esto manualmente 
            cada vez que se reinice el servidor NIS se puede 
            puede a&ntilde;adir la siguiente l&iacute;nea al fichero 
            <filename>/etc/rc.conf</filename>:</para>

      <programlisting>nis_client_enable="YES"	# ejecuta tambien el soft cliente 
nis_client_flags="-S <replaceable>NIS domain</replaceable>,<replaceable>server</replaceable>"</programlisting>

      <para>Consulte &man.ypbind.8; para obtener m&aacute;s informaci&oacute;n.</para>
    </sect2>

    <sect2>
      <title>Formatos de Contrase&ntilde;as</title>
      <indexterm>
        <primary>NIS</primary>
	<secondary>password formats</secondary>
      </indexterm>
      <para>Uno de los problemas m&aacute;s comunes que se encuentra la gente
            a la hora de implantar un servicio de NIS es la compatibilidad del 
            formato de las contrase&ntilde;as.  Si nuestro servidor de NIS 
            utiliza contrase&ntilde;as cifradas mediante DES s&oacute;lo 
            podr&aacute; aceptar clientes que utilicen DES.  Por ejemplo, si 
            poseemos clientes de NIS &solaris; en nuestra red casi seguro que 
            necesitaremos utilizar contrase&ntilde;as cifradas mediante 
            DES.</para>

      <para>Para comprobar qu&eacute; formato utilizan los servidores y los 
            clientes, se puede mirar en 
            <filename>/etc/login.conf</filename>.  Si la m&aacute;quina se 
            configura para utilizar cifrado de contrase&ntilde;as mediante 
            DES, entonces la clase por defecto debe poseer una entrada como la 
            siguiente:</para>

      <programlisting>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Se han omitido otras entradas]</programlisting>

      <para>Otros posibles valores para caracter&iacute;stica de 
            <literal>passwd_format</literal> pueden ser 
            <literal>blf</literal> y <literal>md5</literal> (para utilizar los 
            algoritmos Blowfish y MD5 respectivamente).</para>

      <para>Se debe reconstruir la base de datos de acceso siempre que se 
        modifique el fichero 
        <filename>/etc/login.conf</filename> mediante la ejecuci&oacute;n 
        del siguiente comando como <username>root</username>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>

      <note><para>El formato de las contrase&ntilde;as que ya se encuentran 
              definidas en <filename>/etc/master.passwd</filename> no 
              se actualizar&aacute; hasta que el usuario cambie su 
              contrase&ntilde;a, despu&eacute;s de que se haya reconstruido la 
	      base de datos de tipos de acceso.</para></note>

      <para>A continuaci&oacute;n para asegurarse de que las 
        contrase&ntilde;as se cifran con el formato seleccionado 
            tambi&eacute;n debemos comprobar que la variable 
            <literal>crypt_default</literal> dentro del fichero 
            <filename>/etc/auth.conf</filename> da preferencia al formato de 
            contrase&ntilde;a elegido.  Por ejemplo cuando se utilizan 
            contrase&ntilde;as cifradas con DES la entrada debe ser:</para>

      <programlisting>crypt_default	=	des blf md5</programlisting>

      <para>Si se realizan los pasos anteriores en cada una de las
        m&aacute;quinas clientes y servidoras de nuestro entorno NIS podemos 
        asegurar que todas utilizan el mismo formato de contrase&ntilde;a 
        dentro de nuestra red.  Si se presentan problemas de validaci&oacute;n 
        con determinados usuarios en una determinada m&aacute;quina cliente se 
        puede empezar a investigar sobre el asunto.  Recuerde: si se quiere 
        desplegar un servicio de p&aacute;ginas amarillas sobre un entorno de 
        red heterog&eacute;neo probablemente se deba utilizar DES en todos los 
        sistemas puesto que DES es el m&iacute;nimo com&uacute;n 
            denominador.</para>
    </sect2>
  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Greg</firstname>
      	  <surname>Sutter</surname>
	  <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>DHCP</title>

    <sect2>
      <title>&iquest;Qu&eacute; es DHCP?</title>
      <indexterm>
        <primary>Dynamic Host Configuration Protocol</primary>
        <see>DHCP</see>
      </indexterm>
      <indexterm>
        <primary>Internet Software Consortium (ISC)</primary>
      </indexterm>

      <para>DHCP, el Protocolo de Configuraci&oacute;n Dinamica de 
        M&aacute;quinas (<quote>Dynamic Host Configuration Protocol</quote>), 
        especifica un m&eacute;todo para configurar din&aacute;micamente los 
	par&aacute;metros de red necesarios para que un sistema pueda 
        comunicarse efectivamente.  &os; utiliza la implementaci&oacute;n de 
	DHCP proporcionada por el Internet Software Consortium (ISC) de tal 
        forma que toda la informaci&oacute;n relativa a la configuraci&oacute;n 
        de DHCP se basa en la distribuci&oacute;n proporcionada por el 
        ISC.</para>            
    </sect2>

    <sect2>
      <title>Qu&eacute; Temas Trata Esta Secci&oacute;ns</title>

      <para>Esta secci&oacute;n describe tanto los componentes de la parte 
        servidora como los componentes de la parte cliente del sistema DHCP del 
        ISC.  El programa cliente, denominado forma parte por defecto de los 
        sistemas &os; y el programa servidor se puede instalar a partir del 
        <quote>port</quote> <filename 
         role="package">net/isc-dhcp3-server</filename>.  Las principales 
        fuentes de informaci&oacute;n son las p&aacute;ginas de manual 
        &man.dhclient.8;, &man.dhcp-options.5; y &man.dhclient.conf.5; junto 
        con las referencias que se muestran a continuaci&oacute;n en esta misma 
        secci&oacute;n.</para>
    </sect2>

    <sect2>
      <title>C&oacute;mo Funciona</title>
      <indexterm><primary>UDP</primary></indexterm>
      <para>Cuando el cliente de DHCP, <command>dhclient</command>, se ejecuta 
        en una m&aacute;quina cliente, valga la redundancia, comienza a enviar 
        peticiones <quote>broadcast</quote> solicitando informaci&oacute;n de 
        configuraci&oacute;n.  Por defecto estas peticiones se realizan contra 
        el puerto UDP 68.  El servidor responde a trav&eacute;s del puerto 
        UDP 67 proporcionando al cliente una direcci&oacute;n IP junto con 
        otros par&aacute;metros relevantes para el correcto funcionamiento del 
        sistema en la red, tales como la m&aacute;scara de red, el <quote>
        router</quote> por defecto y los servidores de DNS.  Toda esta 
        informaci&oacute;n se <quote>presta</quote> y es v&aacute;lida 
        s&oacute;lo durante un determinado per&iacute;odo de tiempo 
        (configurado por el administrador del servidor de DHCP).  De esta forma 
        direcciones IP asignadas a clientes que ya no se encuentran conectados 
        a la red pueden ser reutilizadas al pasar determinado periodo de 
        tiempo.</para>

      <para>Los clientes de DHCP pueden obtener una gran cantidad de 
        informaci&oacute;n del servidor.  Se puede encontrar una lista completa 
        en &man.dhcp-options.5;.</para>
    </sect2>

    <sect2>
      <title>Integraci&oacute;n dentro de los Sistemas &os;</title>

      <para>&os; se integra totalmente con el cliente DHCP del ISC, <command>
        dhclient</command>.  Este soporte se proporciona tanto en el proceso de 
        instalaci&oacute;n como en la instalaci&oacute;n por defecto del 
        sistema base obviando la necesidad de poseer un conocimiento detallado 
        de aspectos relacionados con la configuraci&oacute;n de redes siempre y 
        cuando se disponga de servicio de DHCP en la red dada.  El comando 
        <command>dhclient</command> se incluye en todas las distribuciones de 
        &os; desde la versi&oacute;n 3.2.</para>
        <indexterm>
          <primary><application>sysinstall</application></primary>
        </indexterm>

        <para><application>sysinstall</application> soporta DHCP.  Cuando se 
          configura la interfaz de red la primera pregunta es:  <quote>
          &iquest;Quiere intentar configurar el interfaz mediante 
          DHCP?</quote>.  Si se responde afirmativamente se ejecutar&aacute; 
          el comando <command>dhclient</command> y si tiene &eacute;xito se 
          procede con los siguientes pasos de configuraci&oacute;n rellenandose 
          autom&aacute;ticamente las variables de arranque necesarias para 
          completar la configuraci&oacute;n de la red.</para>
          
        <para>Existen dos cosas que se deben realizar de tal forma que nuestro 
          sistema utilice la configuraci&oacute;n de red mediante DHCP al 
          arrancar:</para>
        <indexterm>
          <primary>DHCP</primary>
          <secondary>requirements</secondary>
        </indexterm>
	<itemizedlist>
	  <listitem>
            <para>Asegurarse de que el dispositivo <devicename>
              bpf</devicename> se encuentra compilado en el kernel.  Para ello 
              basta a&ntilde;adir <literal>device bpf</literal> 
              (<literal>pseudo-device bpf</literal> en los sistemas 
              &os;&nbsp;4.X) al fichero de configuraci&oacute;n del kernel y 
              recompilarlo e instalarlo.  Para m&aacute;s informaci&oacute;n 
              sobre la construcci&oacute;n de n&uacute;cleos consulte <xref 
               linkend="kernelconfig">.</para> 

            <para>El dispositivo <devicename>bpf</devicename> se encuentra 
              activado por defecto dentro del fichero de configuraci&oacute;n 
              del n&uacute;cleo (<filename>GENERIC</filename> que 
              encontrar&aacute; en su sistema &os; de forma que si no se 
	      est&aacute; utilizando un fichero de configuraci&oacute;n del 
              n&uacute;cleo espec&iacute;fico (hecho a medida y/o por usted) no 
              es necesario crear uno nuevo y se puede utilizar directamente 
              <filename>GENERIC</filename>.</para>
	    <note>
              <para>Para aquellas personas especialmente preocupadas por la 
                seguridad debemos advertir de que el dispositivo <devicename>
                bpf</devicename> es el dispositivo que las aplicaciones de 
                captura de paquetes utilizan para acceder a los mismos (aunque 
                dichas aplicaciones deben ser ejecutadas como 
                  <username>root</username>).  DHCP 
                  <emphasis>requiere</emphasis> la presencia de 
                  <devicename>bpf</devicename> pero si la seguridad del sistema 
                es m&aacute;s importante que la configuraci&oacute;n 
                  autom&aacute;tica de la red no se recomienda instalar 
                  <devicename>bpf</devicename> en el n&uacute;cleo.</para>
	    </note>
	  </listitem>
          <listitem>
            <para>Editar el fichero <filename>/etc/rc.conf</filename> para 
              para incluir lo siguiente:</para>

            <programlisting>ifconfig_fxp0="DHCP"</programlisting>

            <note>
              <para>Aseg&uacute;rese de sustituir <literal>fxp0</literal> con 
                el nombre de interfaz que desea que se configure 
                  din&aacute;micamente, como se describe en <xref 
                    linkend="config-network-setup">.</para> 
            </note>

            <para>Si se utiliza una ubicaci&oacute;n distinta para el comando 
              <command>dhclient</command> o si se desea a&ntilde;adir opciones 
              adicionales al comando <command>dhclient</command> se puede 
              incluir, adapt&aacute;ndolo a las condiciones particulares de 
              cada usuario, lo siguiente:</para>

            <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>
          </listitem>
        </itemizedlist>

        <indexterm>
          <primary>DHCP</primary>
          <secondary>server</secondary>
        </indexterm>
        <para>El servidor de DHCP (<application>dhcpd</application>) forma 
          parte del <quote>port</quote> <filename 
          role="package">net/isc-dhcp3-server</filename>.  Este <quote>
          port</quote> tambi&eacute;n contiene la documentaci&oacute;n de ISC 
	  DHCP.</para>
    </sect2>

    <sect2>
      <title>Ficheros</title>
      <indexterm>
        <primary>DHCP</primary>
        <secondary>configuration files</secondary>
      </indexterm>
      <itemizedlist>
        <listitem><para><filename>/etc/dhclient.conf</filename></para>
          <para><command>dhclient</command> necesita un fichero de 
                configuraci&oacute;n denominado 
                <filename>/etc/dhclient.conf</filename>.  Normalmente este 
                fichero  s&oacute;lo contiene comentarios de forma que las 
                opciones que se definen por defecto son razonablemente 
                inocuas.  Este fichero de configuraci&oacute;n se describe 
                en la p&aacute;gina de manual de 
                &man.dhclient.conf.5;.</para> 
        </listitem>

        <listitem><para><filename>/sbin/dhclient</filename></para>
          <para><command>dhclient</command> se encuentra enlazado de 
                forma est&aacute;tica y reside en <filename>/sbin</filename>.  
                La p&aacute;gina de manual de &man.dhclient.8; proporciona 
                m&aacute;s informaci&oacute;n sobre el comando 
                <command>dhclient</command>.</para> 
        </listitem>

        <listitem><para><filename>/sbin/dhclient-script</filename></para>
          <para><command>dhclient-script</command> es el <quote>
	    script</quote> de configuraci&oacute;n del cliente de DHCP 
            espec&iacute;fico de &os;.  Tiene todos los detalles en 
            &man.dhclient-script.8; pero no necesita hacer ninguna 
            modificaci&oacute;n en &eacute;l para que todo funcione 
            correctamente.</para>
        </listitem>

        <listitem><para><filename>/var/db/dhclient.leases</filename></para>
          <para>El cliente de DHCP mantiene una base de datos de 
            pr&eacute;stamos en este fichero que se escribe de forma semejante 
            a un <quote>log</quote>.  En &man.dhclient.leases.5; puede 
	    consultar una explicaci&oacute;n ligeramente m&aacute;s 
	    detallada.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Lecturas Recomendadas</title>

      <para>El protocolo DHCP se describe completamente en 
        <ulink url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>.  
        Tambi&eacute;n tiene m&aacute;s informaci&oacute;n en 
        <ulink url="http://www.dhcp.org/">dhcp.org</ulink>.</para>
    </sect2>

    <sect2 id="network-dhcp-server">
	<title>Instalaci&oacute;n y Configuraci&oacute;n de un Servidor de 
	  DHCP</title>

	<sect3>
	  <title>Qu&eacute; Temas se Tratan en Esta Secci&oacute;n</title>

          <para>Esta secci&oacute;n proporciona informaci&oacute;n sobre 
	    c&oacute;mo configurar un sistema &os; de forma que act&uacute;e 
            como un servidor de DHCP utilizando la implementaci&oacute;n 
              proporcionada por el Internet Software Consortium 
              (ISC).</para>

          <para>La parte servidora del paquete proporcionado por el ISC no 
            se instala por defecto en los sistemas &os; pero se puede 
	    intalar como <quote>port</quote> desde <filename 
	    role="package">net/isc-dhcp3-server</filename>.  Consulte <xref 
            linkend="ports"> si necesita saber m&aacute;s sobre la  
            Colecci&oacute;n de <quote>ports</quote>.</para>
	</sect3>

	<sect3>
	  <title>Instalaci&oacute;n del Servidor DHCP</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>installation</secondary>
	  </indexterm>
	  <para>Para configurar un sistema &os; como servidor de DHCP debe 
            asegurarse de que el dispositivo &man.bpf.4; est&aacute; compilado 
            dentro del n&uacute;cleo. Para ello basta a&ntilde;adir 
            <literal>device bpf</literal> (<literal>
	    pseudo-device bpf</literal> en &os;&nbsp;4.X) al fichero de 
            configuraci&oacute;n del n&uacute;cleo y reconstruir el mismo.  
            Si necesita saber m&aacute;s sobre el proceso de compilar e 
            instalar el n&uacute;cleo consulte <xref 
            linkend="kernelconfig">.</para>

          <para>El dispositivo <devicename>bpf</devicename> ya se encuentra 
            activado en el fichero de configuraci&oacute;n 
              <filename>GENERIC</filename> del n&uacute;cleo que se facilita 
            con &os; de tal forma que no resulta imprescindible crear un 
            n&uacute;cleo a medida para ejecutar DHCP.</para>

	    <note>
              <para>Para aquellas personas especialmente preocupadas por la 
                seguridad debemos advertir de que el dispositivo 
                <devicename>bpf</devicename> es el dispositivo que las 
                aplicaciones de captura de paquetes utilizan para acceder a 
                los mismos (aunque dichas aplicaciones deben ser ejecutadas 
                como <username>root</username>).  DHCP 
                  <emphasis>requiere</emphasis> la presencia de 
                  <devicename>bpf</devicename> pero si la seguridad del sistema 
                es m&aacute;s importante que la configuraci&oacute;n 
                autom&aacute;tica de la red no se recomienda instalar 
                  <devicename>bpf</devicename> en el n&uacute;cleo.</para>
	    </note>

          <para>El siguiente paso consiste en editar el fichero de ejemplo 
	    <filename>dhcpd.conf</filename> que se crea al instalar el 
            <quote>port</quote> <filename 
                role="package">net/isc-dhcp3-server</filename>. Por defecto el 
            fichero se llama 
	    <filename>/usr/local/etc/dhcpd.conf.sample</filename>, 
            as&iacute; que se debe copiar este fichero a 
	    <filename>/usr/local/etc/dhcpd.conf</filename> y a 
              continuaci&oacute;n realizar todos los cambios sobre este 
              &uacute;ltimo.</para>
	</sect3>

	<sect3>
	  <title>Configuraci&oacute;n del Servidor de DHCP</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>dhcpd.conf</secondary>
	  </indexterm>
	  <para>El fichero <filename>dhcpd.conf</filename> se compone 
              de un conjunto de declaraciones que hacen referencia a 
              m&aacute;quinas y a subredes.  Esto se entender&aacute; mejor 
              mediante el siguiente ejemplo:</para>

	  <programlisting>option domain-name "ejemplo.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.ejemplo.com;<co id="fixed-address">
}</programlisting>

	  <calloutlist>
	    <callout arearefs="domain-name">
              <para>Esta opci&oacute;n especifica el dominio que se proporciona 
                a los clientes y que dichos clientes utilizan como dominio de 
                b&uacute;squeda por defecto.  Consulte &man.resolv.conf.5; 
                si necesita m&aacute;s informaci&oacute;n sobre qu&eacute; 
		significa el dominio de b&uacute;squeda.</para>
	    </callout>

	    <callout arearefs="domain-name-servers">
	      <para>Esta opci&oacute;n especifica la lista de servidores de DNS 
                (seperados por comas) que deben utilizar los clientes.</para>
	    </callout>

	    <callout arearefs="subnet-mask">
	      <para>La m&aacute;scara de red que se proporciona a los clientes.</para>
	    </callout>

	    <callout arearefs="default-lease-time">
	      <para>Un cliente puede solicitar un determinado tiempo de vida 
                para el pr&eacute;stamo.  En caso contrario el servidor asigna 
                un tiempo de vida por defecto mediante este valor (expresado en 
                segundos).</para>
	    </callout>

	    <callout arearefs="max-lease-time">
              <para>Este es el m&aacute;ximo tiempo que el servidor puede
                utilizar para realizar pr&eacute;stamos a los clientes.  Si un 
                cliente solicita un tiempo mayor como m&aacute;ximo se 
                  responder&aacute; con el valor aqu&iacute; configurado, 
                  ignor&aacute;ndose la petici&oacute;n de tiempo del 
                  cliente.</para>
	    </callout>

	    <callout arearefs="ddns-update-style">
              <para>Esta opci&oacute;n especifica si el servidor de DHCP debe
                intentar actualizar el servidor de DNS cuando se acepta o se 
                libera un pr&eacute;stamo.  En la implementaci&oacute;n 
                  proporcionada por el ISC esta opci&oacute;n es 
                  <emphasis>obligatoria</emphasis>.</para>
	    </callout>

	    <callout arearefs="range">
              <para>Esto indica qu&eacute; direcciones IP se pueden utilizar 
                para ser prestadas a los clientes que las soliciten.  Las 
                direcciones IP pertenecientes a este rango, incluyendo los 
                extremos, se pueden entregar a los clientes.</para>
	    </callout>

	    <callout arearefs="routers">
              <para>Declara c&uacute;al es la pasarela por defecto que se 
                  proporcionar&aacute; a los clientes.</para>	     
	    </callout>

	    <callout arearefs="hardware">
	      <para>Especifica la direcci&oacute;n MAC de una m&aacute;quina, 
	        de tal forma que el servidor de DHCP pueda identificar a la 
                m&aacute;quina cuando realice una petici&oacute;n.</para>
	    </callout>

	    <callout arearefs="fixed-address">
              <para>Especifica que la m&aacute;quina cliente deber&iacute;a 
	        obtener siempre la misma direcci&oacute;n IP.  Recuerde 
                que se puede utilizar un nombre de m&aacute;quina para esto 
                ya que el servidor de DHCP resolver&aacute; el nombre por 
                s&iacute; mismo antes de devolver la informaci&oacute;n al 
                cliente.</para>
	    </callout>
	  </calloutlist>

	  <para>Una vez que se ha acabado de configurar el fichero 
	    <filename>dhcpd.conf</filename> se puede proceder con la 
              ejecuci&oacute;n del servidor mediante el siguiente 
              comando:</para>

	  <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

          <para>Si posteriormente se necesitan realizar cambios en la 
            configuraci&oacute;n anterior tenga en cuenta que el env&iacute;o 
            de la se&ntilde;&aacute;l <literal>SIGHUP</literal> a la 
              aplicaci&oacute;n <application>dhcpd</application> 
              <emphasis>no</emphasis> provoca que se lea de nuevo la 
              configuraci&oacute;n como suele ocurrir en la mayor&iacute;a de 
	      los d&aelig;mones.  Tendr&aacute; que enviar la se&ntilde;al 
              <literal>SIGTERM</literal> para parar el proceso y 
              posteriormente relanzar el d&aelig;mon utilizando el comando 
              anterior.</para>
	</sect3>

	<sect3>
	  <title>Ficheros</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>configuration files</secondary>
	  </indexterm>
	  <itemizedlist>
	    <listitem><para><filename>/usr/local/sbin/dhcpd</filename></para> 
	      <para><application>dhcpd</application> se encuentra 
                  enlazado de forma est&aacute;tica y reside en el directorio 
                  <filename>/usr/local/sbin</filename>.  La p&aacute;gina de 
		 manual &man.dhcpd.8; que se instala con el <quote>port</quote> 
                 le proporcionar&aacute; m&aacute;s informaci&oacute;n sobre 
                  <application>dhcpd</application>.</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/etc/dhcpd.conf</filename></para>
	      <para><application>dhcpd</application> necesita un fichero de 
                configuraci&oacute;n,   <filename>
		/usr/local/etc/dhcpd.conf</filename>.  Este fichero contiene 
                toda la informaci&oacute;n relevante que se quiere proporcionar 
                a los clientes que la  soliciten, junto con informaci&oacute;n 
		relacionada con el funcionamiento del servidor.  Este fichero 
                de configuraci&oacute;n se describe en la p&aacute;gina del 
                manual  &man.dhcpd.conf.5; que instala el <quote>
		port</quote>.</para>
	    </listitem>

	    <listitem><para><filename>/var/db/dhcpd.leases</filename></para>
              <para>El servidor de DHCP mantiene una base de datos de 
                  pr&eacute;stamos o alquileres dentro de este fichero, que 
                  presenta un formato de fichero de <quote>log</quote>.  La 
		  p&aacute;gina del manual &man.dhcpd.leases.5; que se 
                  instala con el <quote>port</quote> proporciona una 
		  descripci&oacute;n ligeramente m&aacute;s larga.</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/sbin/dhcrelay</filename></para>
	      <para><application>dhcrelay</application> se utiliza en 
                entornos de red avanzados donde un servidor de DHCP 
                reenv&iacute;a una petici&oacute;n de un cliente hacia otro 
                servidor de DHCP que se encuentra localizado en otra subred.  
                Si se necesita esta funcionalidad se debe instalar el 
                <quote>port</quote> <filename 
                    role="package">net/isc-dhcp3-server</filename>.  La 
                  p&aacute;gina del manual &man.dhcrelay.8; proporcionada por 
                  el <quote>port</quote> contiene m&aacute;s detalles sobre 
                  esto.</para>
	    </listitem>
	  </itemizedlist>
	</sect3>

      </sect2>

  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Enviado por  </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>DNS</title>

    <sect2>
      <title>Resumen</title>
      <indexterm><primary>BIND</primary></indexterm>

      <para>FreeBSD utiliza por defecto una versi&oacute;n de BIND (Berkeley 
        Internet Name Domain) que proporciona la implementaci&oacute;n 
	m&aacute;s com&uacute;n del protocolo de DNS.  DNS es el protocolo a 
        trav&eacute;s del cual los nombres de m&aacute;quinas se asocian con 
        direcciones IP y viceversa.  Por ejemplo una consulta preguntando por 
        <hostid>www.FreeBSD.org</hostid> recibe una respuesta con la 
        direcci&oacute;n IP del servidor web del Proyecto FreeBSD, mientras que 
        una pregunta sobre <hostid>ftp.FreeBSD.org</hostid> recibe como 
	respuesta la direcci&oacute;n IP correspondiente al servidor de FTP.  
        El proceso inverso sucede de una forma similar.  Una pregunta 
        relativa a una determinada direcci&oacute;n IP se resuelve al nombre de 
        la m&aacute;quina que la posee.  No se necesita ejecutar un servidor de 
        DNS para poder realizar consultas y b&uacute;squedas de DNS.</para>

      <indexterm><primary>DNS</primary></indexterm>
      <para>El DNS se coordina de forma distribuida a trav&eacute;s de 
        Internet utilizando un sistema en cierta forma complejo de servidores 
        de nombres ra&iacute;z autorizados y mediante otros servidores de 
        nombres de menor escala que se encargan de replicar la 
        informaci&oacute;n de dominios individuales con el objetivo de mejorar 
        los tiempos de respuesta de b&uacute;squedas reiteradas de la misma  
        informaci&oacute;n.</para>

      <para>
        Este documento hace referencia a la versi&oacute;n estable BIND 8.X.  
        BIND 9.X se puede instalar a trav&eacute;s del <quote>port</quote> 
        <filename role="package">net/bind9</filename>.</para>

      <para>
        El protocolo de DNS se encuentra definido en la RFC1034 y la RFC1035.
      </para>

      <para>
        El <ulink url="http://www.isc.org/">
        Internet Software Consortium (www.isc.org)</ulink> se encarga de 
        de mantener el software de BIND.
      </para>
    </sect2>

    <sect2>
      <title>Terminolog&iacute;a</title>

      <para>Para comprender este documento se deben definir los siguientes 
        t&eacute;rminos:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>T&eacute;rmino</entry>
	      <entry>Definici&oacute;n</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>DNS directo (Forward DNS)</entry>
	      <entry>Asociaci&oacute;n de nombres de m&aacute;quinas con 
	        direcciones IP</entry>
	    </row>

	    <row>
	      <entry>Origen</entry>
	      <entry>Se refiere al dominio cubierto por un determinado fichero 
                de zona</entry>
	    </row>

	    <row>
	      <entry><application>named</application>, BIND, servidor 
                    de nombres (name server)</entry>
	      <entry>Nombres t&iacute;picos que hacen referencia al paquete 
                    servidor de nombres de BIND de &os;</entry>
	    </row>

	    <indexterm><primary>resolver</primary></indexterm>
	    <row>
	      <entry>Resolver</entry>
	      <entry>Un proceso del sistema que utilizan las aplicaciones para 
                hacer preguntas al servidor de nombres.</entry>
	    </row>

	    <indexterm><primary>reverse DNS</primary></indexterm>
	    <row>
	      <entry>DNS inverso (Reverse DNS)</entry>
	      <entry>Lo contrario de lo que realiza el DNS directo;  
                    asocia direcciones IP con nombres de m&aacute;quinas</entry>
	    </row>

	    <indexterm><primary>root zone</primary></indexterm>
	    <row>
	      <entry>Zona Ra&iacute;z</entry>

	      <entry>El comienzo de la jerarqu&iacute;a de zonas de Internet.  
                Todas las zonas surgen a partir de una zona ra&iacute;z de 
                forma similar a como todos los directorios de un sistema de 
                ficheros se encuentran a partir de un directorio ra&iacute;z 
		inicial.</entry>
	    </row>

	    <row>
	      <entry>Zona</entry>
	      <entry>Un dominio individual, subdominio o porci&oacute;n del 
                    DNS que se encuentra administrado por la misma autoridad.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <indexterm>
	<primary>zones</primary>
	<secondary>examples</secondary>
      </indexterm>

      <para>Ejemplos de zonas:
      </para>
      <itemizedlist>
        <listitem>
          <para><hostid>.</hostid> es la zona ra&iacute;z</para>
        </listitem>
        <listitem>
          <para><hostid>org.</hostid> es una zona localizada bajo la zona 
            ra&iacute;z</para>
        </listitem>
        <listitem>
          <para><hostid>ejemplo.org</hostid> es una zona localizada bajo la 
            zona <hostid>org.</hostid></para>
        </listitem>
        <listitem>
          <para><hostid>foo.ejemplo.org.</hostid> es un subdominio o una zona 
            ubicada bajo la zona <hostid>ejemplo.org.</hostid></para>
        </listitem>
        <listitem>
          <para>
            <hostid>1.2.3.in-addr.arpa</hostid> es una zona que referencia a 
            a todas las direcciones IP que se encuentran dentro del espacio de 
            direcciones de 3.2.1.*.</para>
        </listitem>
      </itemizedlist>

      <para>Como se puede observar la parte m&aacute;s espec&iacute;fica de una 
        m&aacute;quina aparece m&aacute;s a la izquierda.  Por ejemplo 
        <hostid>ejemplo.org</hostid> es m&aacute;s espec&iacute;fico que 
            <hostid>org.</hostid> y del mismo modo <hostid>org.</hostid> es 
        m&aacute;s espec&iacute;fico que la zona ra&iacute;z.  El formato de 
        cada parte del nombre de la m&aacute;quina es muy similar al formato 
        de un sistema de ficheros: el directorio 
            <filename>/dev</filename> se encuentra dentro del directorio 
        ra&iacute;z, y as&iacute; sucesivamente.</para>
    </sect2>

    <sect2>
      <title>Razones para Ejecutar un Servidor de Nombres</title>

      <para>Los servidores de nombres normalmente son de dos tipos: 
            autoritarios y de cache.</para>

      <para>Se necesita un servidor de nombres autoritario cuando:</para>

      <itemizedlist>
	<listitem>
	  <para>uno quiere proporcionar informaci&oacute;n de DNS al resto del 
            mundo respondiendo con informaci&oacute;n autoritaria a las 
            consultas recibidas.</para>
	</listitem>
	<listitem>
	  <para>un dominio, por ejemplo 
            <hostid>ejemplo.org</hostid>, est&aacute;  registrado y se 
            necesita a&ntilde;adir nombres de m&aacute;quinas bajo dicho 
            dominio.</para> 
	</listitem>
	<listitem>
	  <para>un bloque de direcciones IP necesita entradas de DNS inversas 
            (de IP a nombre de m&aacute;quina).</para>
	</listitem>
	<listitem>
	  <para>un servidor de nombres de <quote>backup</quote>, llamado 
	    esclavo, debe responder a consultas cuando el servidor primario se 
            encuentre ca&iacute;do o inaccesible.</para>
	  </listitem>
      </itemizedlist>

      <para>Se necesita un servidor cach&eacute; cuando:</para>

      <itemizedlist>
	<listitem>
	  <para>un servidor de DNS local puede responder m&aacute;s 
            r&aacute;pidamente de lo que se har&iacute;a si se tuviera que 
            preguntar al servidor de nombres externo.</para>
	</listitem>
	<listitem>
	  <para>se desea reducir el tr&aacute;fico global de red (se ha
            llegado a comprobar que el tr&aacute;fico de DNS supone un 5% o 
            m&aacute;s del total del tr&aacute;fico que circula por 
            Internet).</para>
	</listitem>
      </itemizedlist>
 
      <para>Cuando se pregunta por <hostid>www.FreeBSD.org</hostid> el <quote>
        resolver</quote> normalmente pregunta al servidor de nombres del ISP 
        de nivel superior y se encarga de recibir la respuesta.  Si se utiliza 
        un servidor de DNS cach&eacute; local la pregunta s&oacute;lo se dirige 
        una &uacute;nica vez hacia el exterior.  Dicha pregunta la realiza el 
        servidor cach&eacute;.  Posteriores consultas sobre el mismo nombres 
        son respondidas directamente por este servidor.</para>

    </sect2>

    <sect2>
      <title>C&oacute;mo Funciona</title>
      <para>En &os; el d&aelig;mon de BIND se denomina 
	<application>named</application> por razones obvias.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Fichero</entry>
	      <entry>Descripci&oacute;n</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><application>named</application></entry>
	      <entry>El d&aelig;mon de BIND</entry>
	    </row>

	    <row>
	      <entry><command>ndc</command></entry>
	      <entry>El programa de control del d&aelig;mon</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>El directorio donde se almacena la informaci&oacute;n de 
                las zonas de BIND</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/named.conf</filename></entry>
	      <entry>El archivo de configuraci&oacute;n del d&aelig;mon</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>
        Los ficheros de zonas se encuentran normalmente bajo el directorio 
        <filename>/etc/namedb</filename> y contienen la informaci&oacute;n 
        que proporciona el servidor de nombres al resto de m&aacute;quinas de 
        Internet.
      </para>
    </sect2>

    <sect2>
      <title>Ejecuci&oacute;n de BIND</title>
      <indexterm>
        <primary>BIND</primary>
	<secondary>starting</secondary>
      </indexterm>
      <para>
        Debido a que BIND se instala por defecto la configuraci&oacute;n 
            resulta ser bastante sencilla.
      </para>
      <para>
        Para asegurarnos de que el d&aelig;mon se ejecuta al inicio del 
         sistema se deben a&ntilde;adir las siguientes modificaciones en 
        <filename>/etc/rc.conf</filename>:
      </para>
      <programlisting>named_enable="YES"</programlisting>
      <para>Para arrancar el d&aelig;mon de forma manual (una vez 
        configurado)</para>
      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>Ficheros de Configuraci&oacute;n</title>
      <indexterm>
        <primary>BIND</primary>
	<secondary>configuration files</secondary>
      </indexterm>
      <sect3>
        <title>Uso de <command>make-localhost</command></title>
        <para>Aseg&uacute;rese de hacer los siguiente
        </para>
        <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>sh make-localhost</userinput></screen>
        <para>para que se cree el archivo de zona inversa 
          <filename>/etc/namedb/localhost.rev</filename> de forma apropiada.
        </para>
      </sect3>

      <sect3>
        <title><filename>/etc/namedb/named.conf</filename></title>

        <programlisting>// &dollar;FreeBSD$
//
// Consulte la pgina man de named(8) para ms detalles.  tiene 
// alguna vez la necesidad de configurar un servidor primario 
// asegree de que entiende a la perfeccin los detalles peliagudos 
// del funcionamiento del DNS.  Si hay errores, incluso triviales,
// puede sufrir prdidas de conectividad ogenerar cantidades ingentes
// de trfico intil hacia o desde Interne

options {
        directory "/etc/namedb";

// Adems de con la lusula "forwarders" puedeobligar a su servidor 
// de nombres a que nunca lance bsquedas por su cuenta sino que 
// se las pida a sus "forwarders". Esto se hace del siguiente modo:
//
//      forward only;

// Si su proveedor de acceso tiene a su alcance un servidor DNS 
// escriba aqu su direccin IP y descomente la lneaPodr usar 
// su cach y por lo tanto reducir el trfico DNS de Internet.
//

/*
        forwarders {
                127.0.0.1;
        };
*/</programlisting>

        <para>
          Tal y como se dice en los comentarios del ejemplo para beneficiarnos 
          de la cach&eacute; se puede activar <literal>forwarders</literal>.  
          En circunstancias normales un servidor de nombres busca de forma 
          recursiva a trav&eacute;s de Internet tratando de localizar un 
          servidor de nombres que sea capaz de responder una determinada 
          pregunta.  Si se activa esta opci&oacute;n por defecto se pasa a 
          preguntar primero al servidor de nombres especificado (servidor o 
          servidores) pudiendo aprovecharse de la informaci&oacute;n de 
	  cach&eacute; que dicho servidor tuviera disponible.  Si el servidor 
          de nivel superior al nuestro se encuentra congestionado puede 
          merecer la pena la activaci&oacute;n de esta caracter&iacute;stica de 
          <quote>redirecci&oacute;n</quote> ya que se puede disminuir la carga 
          de tr&aacute;fico que dicho servidor tiene que soportar.</para>

	<warning><para>La direcci&oacute;n IP <hostid 
	  role="ipaddr">127.0.0.1</hostid> <emphasis>no</emphasis> funciona 
          a&iacute;.  Se debe cambiar esta direcci&oacute;n IP por un 
          servidor de nombres v&aacute;lido.</para>
        </warning>

        <programlisting>        /*
	 * Si hay un cortafuegos entre usted y los servidores de 
	 * nombres que quiere consultar tendr que descoentar la 
	 * siguiente directiva, "query-source".  Las versiones 
	 * anteriores de BIND siempre hacan sus consultas a travs 
	 * del puerto 53 pero BIND 8.1 utiliza por defecto un puerto no 
	 * privilegiado.
         */
        // query-source address * port 53;

        /*
	 * Si lo va a ejecutar en un "cajn de arena" (o "sandbox")
	 * tendr que declarar una uicacin diferente para el 
	 * fichero de volcado de named.
         */
        // dump-file "s/named_dump.db";
};

// Nota: lo siguiente ser includo en futuras versiones.
/*
host { any; } {
        topology {
                127.0.0.0/8;
        };
};
*/

// La configuracin de secundarios se explica de modo secillo a 
// partir de aqu.
//
// Si activa un servidor de nombres local no olvide inclur 
// 127.0.0.1 en su /etc/resolv.conf para que sea ese servidor el 
// primero al que se consulte.
// Asegrese tambin de activarlo en /etc/rc.con

zone "." {
        type hint;
        file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
        type master;
        file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
        type master;
        file "localhost.rev";
};

// Nota: No use las direcciones IP que se muestran aqu, son falsas 
// y slo se usancomo demostracin y para una mejor comprensin.
//
// Ejemplo de entradas en la configuracin de secundarios.  Puede ser 
// conveniente convertirse en secundario al menos del dominio en cuya 
// zona est su dominio.  Cnsulte con su administrador de red para 
// que le facilite la direccin IP del servidor primario.
//
// No olvide inclur la zona del bucle inverso (IN-ADDR.ARPA).  (Son 
// los primeros bytes de la direccin IP correspondiente, en orden 
// inverso, con ".IN-ADDR.ARPA" al final.)
//
// Antes de configurar una zona primara asegresede haber comprendido 
// completamente cmo funcionan DNS y BIND.  Hay errores que no son 
// visibles fcilmente.  La configuracin de un secundario es, por 
// el contrario, muchsimo ms sencilla.
//
// Nota: No se limite a copiar los ejemplos de ms arriba. :-)
// Utilice nombres y direcciones reales.
//
// ADVERTENCIA: FreeBSD ejecuta bind en un sandbok (observe los 
// parmeros de named (named_flags) en rc.conf).  El directorio que 
// contiene las zonas secundarias debe tener permisos de escritura 
// para bind.  Le sugerimos la siguiente secuencia de comandos:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

	<para>Si quiere m&aacute;s informaci&oacute;n sobre c&oacute;mo 
	  ejecutar BIND en un <quote>sandbox</quote> consulte 
	  <link linkend="network-named-sandbox">Ejecuci&oacute;n de named en 
          un sandbox</link>.
	</para>

	<programlisting>/*
zone "ejemplo.com" {
        type slave;
        file "s/ejemplo.com.bak";
        masters {
                192.168.1.1;
        };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "s/0.168.192.in-addr.arpa.bak";
        masters {
                192.168.1.1;
        };
};
*/</programlisting>
        <para>Dentro del fichero <filename>named.conf</filename> se muestran 
          ejemplos de entradas de esclavo tanto para las zonas directas como 
          para las inversas.</para>

        <para>Para cada nueva zona administrada se debe crear una entrada de 
          zona dentro del fichero 
	  <filename>named.conf</filename></para>

        <para>Por ejemplo la entrada de zona m&aacute;s simple para el dominio 
	  <hostid role="domainname">ejemplo.org</hostid> puede ser algo como 
          esto:</para>

        <programlisting>zone "ejemplo.org" {
	type master;
	file "ejemplo.org";
};</programlisting>

	<para>Esta zona es una zona maestra ( observe la l&iacute;nea de 
          <option>type</option>, y mantiene la informaci&oacute;n de la zona en 
          <filename>/etc/namedb/ejemplo.org</filename> tal como se indica en la 
          l&iacute;nea de <option>file</option>.</para>

        <programlisting>zone "ejemplo.org" {
	type slave;
	file "ejemplo.org";
};</programlisting>

        <para>En el caso del esclavo la informaci&oacute;n de la zona se 
          transmite desde el servidor de nombres maestro y se almacena en el 
          fichero especificado.  Cuando el servidor maestro <quote>
	  muere</quote> o no puede ser alcanzado el servidor de nombres esclavo 
          puede responder a las peticiones debido a que posee la 
          informaci&oacute;n de la zona.</para>
      </sect3>

      <sect3>
        <title>Ficheros de Zona</title>
        <para>
          A continuaci&oacute;n se muestra un fichero de una zona maestra para 
          el dominio <hostid>ejemplo.org</hostid>, que se encuentra ubicado en 
          <filename>/etc/namedb/ejemplo.org</filename>:</para>

        <programlisting>$TTL 3600

example.org. IN SOA ns1.ejemplo.org. admin.ejemplo.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; DNS Servers
@       IN NS           ns1.ejemplo.org.
@       IN NS           ns2.ejemplo.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30

; Aliases
www             IN CNAME        @

; MX Record
@               IN MX   10      mail.ejemplo.org.</programlisting>

        <para>
          Tenga muy en cuenta que todo nombre de m&aacute;quina que termina en 
          <quote>.</quote> es tratado como si fuera un nombre de 
          m&aacute;quina completo mientras que cualquier otro nombre sin el 
          <quote>.</quote> final se trata como una referencia relativa al 
          dominio de origen de la zona. Por ejemplo <literal>www</literal> se 
	  traduce a <literal>www + origen</literal>.  En nuestro fichero de 
          zona ficticio nuestro origen es <hostid>ejemplo.org</hostid> de forma 
          que <literal>www</literal> se convierte en <hostid>
          www.ejemplo.org</hostid>
        </para>

        <para>
          El formato de un fichero de zona es el siguiente:
        </para>
	<programlisting>nombrederegistro IN tipodeentrada valor</programlisting>

	<indexterm>
	  <primary>DNS</primary>
	  <secondary>records</secondary>
	</indexterm>
        <para>
          Los registros de DNS que m&aacute;s se utilizan son:
        </para>

	<variablelist>
	  <varlistentry>
	    <term>SOA</term>

	    <listitem><para>Comienzo de Zona con Autoridad (Start Of zone Authority)</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>NS</term>

	    <listitem><para>Un servidor de nombres con autoridad para una 
              una determinada zona</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>A</term>

	    <listitem><para>Una direcci&oacute;n IP de una m&aacute;quina</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>CNAME</term>

	    <listitem><para>El nombre can&oacute;nico de una m&aacute;quina para definir un alias</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>MX</term>

	    <listitem><para>mail exchanger</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>PTR</term>

	    <listitem><para>Un puntero a un nombre de dominio (utilizados para 
              definir el DNS inverso)
	      </para></listitem>
	  </varlistentry>
	</variablelist>

        <programlisting>
ejemplo.org. IN SOA ns1.ejemplo.org. admin.ejemplo.org. (
                        5               ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</programlisting>



	<variablelist>
	  <varlistentry>
	    <term><hostid>ejemplo.org.</hostid></term>

	    <listitem><para>el nomre de dominio, tambi&eacute;n el origen para 
              el fichero de zona</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><hostid>ns1.ejemplo.org.</hostid></term>

	    <listitem><para>el servidor de nombres 
                    primario/autoritario para esta zona</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>admin.ejemplo.org.</literal></term>

	    <listitem><para>la persona responsable de esta zona; observe que 
              la direcci&oacute;n de correo electr&oacute;nico aparece con la @ 
              sustituida por un punto.  (<email>admin@ejemplo.org</email> se 
              escribe <literal>admin.ejemplo.org</literal>)</para> 
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>5</literal></term>

	      <listitem><para>el n&uacute;mero de serie del fichero.  Este 
                n&uacute;mero se debe incrementar cada vez que se modifique 
                el fichero de zona.  Muchos administradores prefieren un 
                formato expresado del siguiente modo <literal>
		aaaammddss</literal>.  2001041002 significa (seg&uacute;n dicho 
                formato) que el fichero se modific&oacute; por &uacute;ltima 
		vez el 04/10/2001 y se indica con los dos &uacute;ltimos 
                d&iacute;gitos (02) que es la segunda vez en el d&iacute;a que 
                se ha modificado el fichero.  El n&uacute;mero de serie es 
		importante ya que para avisar a los servidores de nombres 
                esclavos de que se ha actualizado la zona.</para>
	      </listitem>
	  </varlistentry>
	</variablelist>

        <programlisting>
@       IN NS           ns1.ejemplo.org.</programlisting>

        <para>
          Esta es una entrada de tipo <varname>NS</varname>.  Cada servidor de 
          nombres que contesta de forma autoritaria a las consultas de un 
          determinado dominio debe tener una de estas entradas.  El caracter 
          <literal>@</literal> se sustituye por <hostid 
                role="domainname">ejemplo.org.</hostid>, es decir, se sustituye 
          por el origen.
        </para>

        <programlisting>
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30</programlisting>

        <para>
          El registro de tipo A hace referencia a nombres de m&aacute;quinas .  
          Como puede verse  m&aacute;s arriba <hostid>
          ns1.ejemplo.org</hostid> se resuelve a <hostid 
          role="ipaddr">3.2.1.2</hostid>.  Vemos que se utiliza otra vez el 
          origen <literal>@</literal>, que significa que <hostid>
          ejemplo.org</hostid> se resuelve a <hostid 
                role="ipaddr">3.2.1.30</hostid>.
        </para>

        <programlisting>
www             IN CNAME        @</programlisting>

        <para>
          Los registros de nombres can&oacute;nicos se utilizan normalmente 
          como alias de m&aacute;quinas.  En el ejemplo 
          <hostid>www</hostid> es un alias de <hostid>ejemplo.org</hostid> 
          (<hostid role="ipaddr">3.2.1.30</hostid>). 
          <varname>CNAME</varname>s se puede utilizar para proporcionar alias 
          de nombres de m&aacute;quinas, o tambi&eacute;n para proporcionar un 
          mecanismo de vuelta c&iacute;clica (<quote>round robin</quote>) 
          de un nombre de m&aacute;quina mapeado a un determinado conjunto de 
          m&aacute;quinas intercambiables.</para>
	<indexterm>
	  <primary>MX record</primary>
	</indexterm>

        <programlisting>
@               IN MX   10      mail.ejemplo.org.</programlisting>

        <para>
          El registro <varname>MX</varname> indica qu&eacute; servidores de 
          correo se encargan de recibir correos para esta zona.  
          <hostid role="fqdn">mail.example.org</hostid> es el nombre del 
          servidor de correo y 10 significa la prioridad de dicho 
          servidor.
        </para>

        <para>
          Se pueden especificar varios servidores de correo con prioridades de, 
          por ejemplo,3, 2 y 1.  Un servidor de correo que intenta entregar 
          correo para el dominio <hostid 
          role="domainname">ejemplo.org</hostid> primero intentar&aacute; 
          contactar con el servidor especificado en el registro MX de mayor 
          prioridad, despu&eacute;s con el siguiente y as&iacute; sucesivamente 
          hasta que lo logre entregar.
        </para>

        <para>
          Para los ficheros de zona de in-addr.arpa (DNS inverso) se utiliza 
          el mismo formato excepto que se especifican registros 
          <varname>PTR</varname> en lugar de registros 
              <varname>A</varname> o <varname>CNAME</varname>.
        </para>

        <programlisting>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.ejemplo.org. admin.ejemplo.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

@       IN NS   ns1.ejemplo.org.
@       IN NS   ns2.ejemplo.org.

2       IN PTR  ns1.ejemplo.org.
3       IN PTR  ns2.ejemplo.org.
10      IN PTR  mail.ejemplo.org.
30      IN PTR  ejemplo.org.</programlisting>
        <para>
         Este fichero proporciona las asociaciones de direcciones IP con 
         nombres de m&aacute;quinas adecuadas para nuestro dominio ficticio.
        </para>
      </sect3>
    </sect2>

    <sect2>
      <title>Servidor de Nombres de Cache</title>
      <indexterm>
        <primary>BIND</primary>
        <secondary>caching name server</secondary>
      </indexterm>
      <para>
        Un servidor de nombres de tipo cach&eacute; es un servidor de nombres 
        que no es autoritario para ninguna zona. Simplemente realiza consultas 
        por s&iacute; mismo y recuerda las respuestas para futuros usos.  
        Para configura uno de estos servidores se configura el servidor de la 
        forma habitual pero se omite la inclusi&oacute;n de zonas.
      </para>
    </sect2>

    <sect2 id="network-named-sandbox">
      <title>Ejecuci&oacute;n de <application>named</application> en un <quote>
        Sandbox</quote></title>
      <indexterm>
        <primary>BIND</primary>
        <secondary>running in a sandbox</secondary>
      </indexterm>

      <indexterm>
        <primary><command>chroot</command></primary>
      </indexterm>
      <para>Para obtener una mayor seguridad se puede ejecutar 
        &man.named.8; como un usuario sin privilegios y configurarlo mediante 
        &man.chroot.8; dentro del directorio especificado como el directorio 
        del <quote>sandbox</quote>.   Esto hace que cualquier cosa que se 
	encuentre fuera de dicho directorio resulte inaccesible para el 
        d&aelig;mon <application>named</application>.  En caso de que se 
        comprometiera la seguridad de <application>named</application> esta 
        restricci&oacute;n puede ayudar a limitar el da&ntilde;o sufrido.  
        &os; dispone por defecto de un usuario y un grupo destinado a este 
        uso: <groupname>bind</groupname>.

      <note><para>Hay quien recomienda que en lugar de configurar 
        <application>named</application> con <command>chroot</command> es mejor 
        configurarlo dentro de &man.jail.8;.  En esta secci&oacute;n no se va 
        a explicar esa alternativa.</para>
      </note>

      <para>Debido a que <application>named</application> no va a poder 
        acceder a nada que se encuentre fuera del directorio <quote>
        sandbox</quote> (y esto incluye cosas tales como bibliotecas 
        compartidas, <quote>sockets</quote> de <quote>log</quote>, etc) se 
	debe efectuar una serie de cambios para que <application>
        named</application> pueda funcionar con normalidad.  En la siguiente 
	lista se supone que la ruta del <quote>sandbox</quote> es 
        <filename>/etc/namedb</filename> y que no se ha modificado 
        anteriormente dicho directorio.  Por favor, ejecute los pasos que se 
        muestran a continuaci&oacute;n:</para>

      <itemizedlist>
	<listitem>
	  <para>Cree todos los directorios que 
            <application>named</application> espera tener a su 
	    disposici&oacute;n:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>

	  <calloutlist>
	    <callout arearefs="chown-slave">
	      <para><application>named</application> s&oacute;lamente necesita 
                escribir en estos directorios as&iacute; que eso es todo lo que 
                debemos crear.</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
          <para>Reorganizar y crear los archivos de configuraci&oacute;n de 
            zona b&aacute;sicos:</para>
	  <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- I don't like this next bit -->
&prompt.root; <userinput>sh make-localhost && mv localhost.rev localhost-v6.rev master</userinput>
&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost. postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</userinput></screen>

	  <calloutlist>
	    <callout arearefs="localtime">
	      <para>Esto permite que <application>named</application> pueda 
                escribir al archivo de log la hora correcta a trav&eacute;s 
                del &man.syslogd.8;</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>Si est&aacute; usando una versi&oacute;n de &os; anterior a 
            4.9-RELEASE se debe construir una copia est&aacute;ticamente 
            enlazada de <application>named-xfer</application> y copiarla dentro 
            del directorio del <quote>sandbox</quote>:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

	  <para>Despue&eacute;s de instalar la versi&oacute;n est&aacute;tica 
	    de <command>named-xfer</command> se deben realizar algunas tareas 
            de limpieza para evitar dejar copias de bibliotecas o de programas 
            en nuestros ficheros de fuentes:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	  <calloutlist>
	    <callout arearefs="clean-cruft">
	      <para>En algunas ocasiones este paso puede fallar.  Si es su caso 
                ejecute lo siguiente:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

	      <para>y borre su directorio <filename>/usr/obj</filename>:</para>

	      <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

		<para>Esto limpia cualquier <quote>impureza</quote> del 
		  &aacute;rbol de fuentes y si se repiten los pasos anteriores 
		  todo deber&iacute;a funcionar.</para>
	    </callout>
	  </calloutlist>

	  <para>Si se est&aacute; usando &os; version 4.9-RELEASE o posterior 
            el ejecutable de <command>named-xfer</command> del directorio 
	    <filename>/usr/libexec</filename> ya se encuentra 
            enlazado est&aacute;ticamente y se puede utilizar &man.cp.1; para 
            copiarlo directamente en nuestro <quote>sandbox</quote>.</para>
	</listitem>

	<listitem>
	  <para>Cree el fichero <devicename>dev/null</devicename> de tal forma 
            que <application>named</application> pueda verlo y pueda escribir 
            sobre &eacute;l:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
	</listitem>

	<listitem>
	  <para>Enlace simb&oacute;licamente <filename> /var/run/ndc</filename> 
	    con <filename>/etc/namedb/var/run/ndc</filename>:</para>

	  <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

	  <note>
	    <para>Esto simplemente evita el tener que especificar la 
	      opci&oacute;n <option>-c</option> de &man.ndc.8; cada vez que se 
	      ejecute.  Dado que los contenidos de /var/run se borran al 
              inicio del sistema, si se piensa que esto puede resultar 
              &uacute;til, se puede a&ntilde;adir este comando al <quote>
              crontab</quote> del usuario root utilizando la opci&oacute;n
                  <option>@reboot</option>.  Consulte &man.crontab.5; para 
              saber m&aacute;s informaci&oacute;n sobre esto.</para>
	  </note>

	</listitem>

	<listitem>
	  <para>Configure &man.syslogd.8; para que cree un <quote>socket</quote>
	     de <devicename>log</devicename> adicional de tal forma que 
	    <application>named</application> pueda escribir sobre &eacute;l.  
            A&ntilde;ada <literal>-l 
                  /etc/namedb/dev/log</literal> a la variable 
	    <varname>syslogd_flags</varname> dentro del fichero 
	    <filename>/etc/rc.conf</filename>.</para>
	</listitem>

	<listitem>
	  <para>Reorganice la ejecuci&oacute;n de las aplicaciones 
            <application>named</application> y 
            <command>chroot</command> para que se ejecuten dentro 
            del <quote>sandbox</quote> a&ntilde;adiendo lo siguiente al 
	    fichero<filename>/etc/rc.conf</filename>:</para>

	  <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

	  <note>
	    <para>Recuerde que el fichero de configuraci&oacute;n 
	      <replaceable>/etc/named.conf</replaceable> tiene una ruta 
              completa <emphasis>que comienza en el directorio del 
              <quote>sandbox</quote></emphasis>; por ejemplo, en la 
              l&iacute;nea superior el fichero que aparece es en realidad 
              <filename>/etc/namedb/etc/named.conf</filename>.</para>
	  </note>
	</listitem>
      </itemizedlist>

      <para>El siguiente paso consiste en editar el fichero 
	<filename>/etc/namedb/etc/named.conf</filename> de tal forma que 
         <application>named</application> pueda conocer qu&eacute; zonas cargar 
         y donde encontrarlas en disco.  A continuaci&oacute;n se muestra un 
         ejemplo comentado (cualquier cosa que no se comenta en el ejemplo es 
         porque resulta igual que la configuraci&oacute;n del servidor de DNS 
         del caso normal):</para>

	<programlisting>options {
        directory "/";<co id="directory">
        named-xfer "/bin/named-xfer";<co id="named-xfer">
        version "";		// No muestra la versin de BIND
        query-source address * port 53;
};
// ndc control socket
controls {
        unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// A partir de aquvan las zonas:
zone "localhost" IN {
        type master;
        file "master/named.localhost";<co id="master">
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.127.in-addr.arpa" IN {
        type master;
        file "master/localhost.rev";
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
	type master;
	file "master/localhost-v6.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "." IN {
        type hint;
        file "master/named.root";
};
zone "private.example.net" in {
        type master;
        file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
        type slave;
        masters { 192.168.10.2; };
        file "slave/192.168.10.db";<co id="slave">
};</programlisting>

      <calloutlist>
	<callout arearefs="directory">
	  <para>La l&iacute;nea que contiene 
	    <literal>directory</literal> se especifica como 
	    <filename>/</filename>, ya que todos los ficheros que 
	    <application>named</application> necesita se encuentran dentro de 
            este directorio (recuerde que esto es equivalente al fichero 
            <filename>/etc/namedb</filename> de un usuario
            <quote>normal</quote>.</para>
	</callout>

	<callout arearefs="named-xfer">
	  <para>Especifica la ruta completa para el binario 
	    <command>named-xfer</command> binary (desde el marco de referencia 
            de <application>named</application>).  Esto resulta necesario ya 
            que por defecto <application>named</application> se compila de tal 
            forma que trata de localizar el comando 
            <command>named-xfer</command> dentro de 
	    <filename>/usr/libexec</filename>.</para>
	</callout>
	<callout arearefs="master"><para>Especifica el nombre del fichero 
          (relativo a la l&iacute;nea
          (relativo a la l&iacute;nea ) <literal>directory</literal> anterior) 
	  donde <application>named</application> puede encontrar el fichero de 
          zona para esta zona.</para>
	</callout>
	<callout arearefs="slave"><para>Especifica el nombre del fichero 
	  (relativo a la l&iacute;ena <literal>directory</literal> anterior) 
          donde <application>named</application> deber&iacute;a escribir una 
          copia del archivo de zona para esta zona despu&eacute;s de 
          recuperarla exitosamente desde el servidor maestro.  Este es el 
          motivo por el que en las etapas de configuraci&oacute;n anteriores 
          necesit&aacute;bamos cambiar la propiedad del directorio 
          <filename>slave</filename> al grupo 
                <groupname>bind</groupname>.</para>
	</callout>
      </calloutlist>

      <para>Despu&eacute;s de completar los pasos anteriores reinicie el 
        servidor o reinicie &man.syslogd.8; y ejecute &man.named.8; 
        asegur&aacute;ndose de que se utilicen las nuevas opciones 
        especificadas en <varname>syslogd_flags</varname> y 
        <varname>named_flags</varname>.  En estos momentos deber&iacute;amos 
        estar ejecutando una copia de <application>named</application> dentro 
        de un <quote>sandbox</quote>.</para>
    </sect2>

    <sect2>
      <title>Seguridad</title>

       <para>Aunque BIND es la implementaci&oacute;n de DNS m&aacute;s 
         utilizada existe siempre el asunto relacionado con la seguridad.  De 
         vez en cuando se encuentran agujeros de seguridad y 
         vulnerabilidades.</para>

      <para>
        Es una buena idea suscribirse a <ulink 
        url="http://www.cert.org/">CERT</ulink> y a <ulink 
         url="../handbook/eresources.html#ERESOURCES-MAIL">freebsd-security-notifications</ulink> 
        para estar al d&iacute;a de los problemas de seguridad relacionados 
        con <application>named</application>.</para>

      <tip><para>Si surge un problema nunca est&aacute; de m&aacute;s 
        actualizar los fuentes y recompilar los ejecutables desde dichas 
        fuentes.</para></tip>

    </sect2>

    <sect2>
      <title>Lecturas Recomendadas</title>
      <para>
        Las p&aacute;ginas del manual de BIND/named: 
	&man.ndc.8; &man.named.8; &man.named.conf.5;
      </para>

      <itemizedlist>
	<listitem>
	  <para><ulink 
	     url="http://www.isc.org/products/BIND/">P&aacute;gina oficial 
            de ISC Bind</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink 
	     url="http://www.nominum.com/getOpenSourceResource.php?id=6">
	  Preguntas m&aacute;s frecuentes sobre BIND</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
                  url="http://www.oreilly.com/catalog/dns4/">Libro de O'Reilly 
            "DNS and BIND", cuarta edici&oacute;n</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	     url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034 
	    - Nombre de Dominio - Conceptos y Caracter&iacute;sticas</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	     url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035 
	      - Nombres de Domninio - Implementaci&oacute;n y 
	    Especificaci&oacute;n</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>NTP</title>

    <indexterm><primary>NTP</primary></indexterm>

    <sect2>
      <title>Resumen</title>

      <para>Seg&uacute;n pasa el tiempo el reloj de un computador est&aacute; 
        expuesto a ligeros desplazamientos.  NTP (Protocolo de Hora 
        en Red, en ingl&eacute;s <quote>Network Time Protocol</quote>) es 
        un protocolo que permite asegurar la exactitud de nuestro reloj.</para>
      
      <para>Existen varios servicios de internet que conf&iacute;an y se pueden 
        beneficiar de relojes de computadores precisos.  Por ejemplo un 
        servidor web puede recibir peticiones de un determinado fichero si ha 
        sido modificado posteriormente a una determinada fecha u hora.  
        Servicios como &man.cron.8; ejecutan comandos en determinados 
        instantes.  Si el reloj no se encuentra ajustado estos comandos pueden 
        ejecutarse fuera de la hora prevista.</para>

      <indexterm>
	<primary>NTP</primary>
	<secondary>ntpd</secondary>
      </indexterm>
      <para>&os; viene con el servidor NTP &man.ntpd.8; que se puede utilizar 
        para preguntar a otros servidores NTP, de tal forma que podemos 
        ajustar nuestro reloj seg&uacute;n la hora de otros servidores e 
        incluso proporcionar servicio de hora nosotros mismos.</para>

    </sect2>

    <sect2>
      <title>Elecci&oacute;n de los Servidores de Hora Adecuados</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>choosing servers</secondary>
      </indexterm>

       <para>Para sincronizar nuestro reloj necesitamos comunicarnos con uno o 
         m&aacute;s servidores NTP.  El administrador de nuestra red o nuestro 
         proveedor de servicios de Internet muy posiblemente hayan configurado 
         alg&uacute;n servidor NTP para estos prop&oacute;sitos.  Consulte la 
         documentaci&oacute;n de que disponga.  Existe una <ulink 
	  url="http://www.eecis.udel.edu/~mills/ntp/servers.html">lista de 
         servidores NTP p&uacute;blicamente accesibles</ulink> que se pueden 
         utilizar para buscar un servidor NTP que se encuentre 
         geogr&aacute;ficamente pr&oacute;ximo.  Aseg&uacute;rese de que conoce 
         la pol&iacute;tica de uso de estos servidores p&uacute;blicos ya que 
	 en algunos casos es necesario pedir permiso al administrador antes de 
         de poder utilizarlos, principalmente por motivos 
         estad&iacute;sticos.</para>

      <para>Le recomendamos seleccionar servidores NTP que no se encuentren 
        conectados entre s&iacute; por si alguno de los servidores que use 
	sea inaccesible o su reloj se aver&iacute;e. &man.ntpd.8; utiliza las 
        respuestas que recibe de otros servidores de una forma inteligente.  
        servidores de una forma inteligente (Tiene a hacer m&aacute;s caso a 
        los m&aacute;s fiables.</para>

    </sect2>

    <sect2>
      <title>Configuraci&oacute;n de la M&aacute;quina</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <sect3>
	<title>Configuraci&oacute;n B&aacute;sica</title>
	<indexterm><primary>ntpdate</primary></indexterm>

        <para>Si s&oacute;lamente deseamos sincronizar nuestro reloj cuando 
          se arranca la m&aacute;quina se puede utilizar &man.ntpdate.8;.  
          Esto puede ser adecuado en algunas m&aacute;quinas de escritorio que 
          se reinician frecuentemente y donde la sincronizaci&oacute;n no suele 
          ser un objetivo prioritario pero normalmente la mayor&iacute;a de las 
          m&aacute;quinas deber&iacute;an ejecutar &man.ntpd.8;.</para>

        <para>La utilizaci&oacute;n de &man.ntpdate.8; en tiempo de arranque 
          es tambi&eacute;n una buena idea incluso para las m&aacute;quinas que 
          ejecutan &man.ntpd.8;.  El programa &man.ntpd.8; modifica el reloj de 
          forma gradual, mientras que &man.ntpdate.8; ajusta directamente el 
          reloj sin importar que tama&ntilde;o tenga la diferencia de tiempo 
          existente entre la m&aacute;quina y el servidor de tiempo de 
          referencia.</para>

        <para>Para activar &man.ntpdate.8; en tiempo de arranque, a&ntilde;ada 
	  <literal>ntpdate_enable="YES"</literal> al fichero 
	  <filename>/etc/rc.conf</filename>.  Tambi&eacute;n es necesario 
          especificar todos los servidores que deseamos utilizar para 
          realizar el proceso de sincronizaci&oacute;n y cualquier 
          par&aacute;metro que deseemos pasar al comando &man.ntpdate.8; 
          utilizando la variable <varname>ntpdate_flags</varname>.</para>

      </sect3>

      <sect3>
	<indexterm>
	  <primary>NTP</primary>
	  <secondary>ntp.conf</secondary>
	</indexterm>

	<title>Configuraci&oacute;n General</title>

	<para>NTP se configura mediante el archivo 
	  <filename>/etc/ntp.conf</filename> utilizando el formato descrito en 
          &man.ntp.conf.5;.  A continuaci&oacute;n se muestra un sencillo 
          ejemplo:</para>

	<programlisting>server ntplocal.ejemplo.com prefer
server timeserver.ejemplo.org
server ntp2a.ejemplo.net

driftfile /var/db/ntp.drift</programlisting>

        <para>La opci&oacute;n <literal>server</literal> especifica qu&eacute; 
          servidores se van a utilizar, especificando un servidor por 
          l&iacute;nea.  Si se especifica un servidor con el argumento 
          <literal>prefer</literal>, como en <hostid 
	  role="fqdn">ntplocal.ejemplo.com</hostid> dicho servidor se prefiere 
          sobre los dem&aacute;s.  No obstante la respuesta de su servidor 
          preferido se descartar&aacute; si difiere sustancialmente de la 
          respuesta recibida por parte del resto de los servidores 
          especificados; en caso contrario s&oacute;lo se tendr&aacute; en 
          cuenta la respuesta del servidor preferido sin importar la 
	  informaci&oacute;n suministrada por el resto.  El argumento 
          <literal>prefer</literal> se utiliza normalmente en servidores NTP 
          altamente precisos, como aquellos que poseen hardware de tiempo 
          espec&iacute;fico.</para>

        <para>La opci&oacute;n <literal>driftfile</literal> especifica 
	  qu&eacute; fichero se utiliza para almacenar el desplazamiento de 
          la fracuencia de reloj de la m&aacute;quina.  El programa 
          &man.ntpd.8; utiliza este valor para autom&aacute;ticamente 
          compensar el desv&iacute;o que experimenta de forma natural el reloj 
          de la m&aacute;quina, permitiendo mantener una precisi&oacute;n 
          acotada incluso cuando se pierde la comunicaci&oacute;n con el resto 
          de referencias externas.</para>

        <para>La opci&oacute;n <literal>driftfile</literal> especifica 
	  qu&eacute; fichero se utiliza para almacenar la informaci&oacute;n 
          sobre espuestas anteriores de servidores NTP.  Este fichero  
          contiene informaci&oacute;n &uacute;til para la implementaci&oacute;n 
          de NTP.  No deber&iacute;a ser modificada por ning&uacute;n otro 
          proceso.</para>

      </sect3>

      <sect3>
	<title>Control de Acceso al Servidor NTP</title>

        <para>Por defecto nuestro servidor de NTP puede ser accedido por 
          cualquier m&aacute;quina de Internet.  La opci&oacute;n 
          <literal>restrict</literal> se puede utilizar para controlar 
          controlar qu&eacute; m&aacute;quinas pueden acceder al 
          servicio.</para>

        <para>Si queremos denegar el acceso a todas las m&aacute;quinas 
          existentes basta con a&ntilde;adir la siguiente l&iacute;nea a 
	  <filename>/etc/ntp.conf</filename>:</para>

        <programlisting>restrict default ignore</programlisting>

        <para>Si s&oacute;lo queremos permitir el acceso al servicio de hora 
          a las m&aacute;quinas de nuestra red y al menos tiempo nos queremos 
          asegurar de que dichos clientes no pueden a su vez configurar la 
          hora del servidor o utilizarse ellos mismos como nuevos servidores 
          de hora basta con a&ntilde;adir lo siguiente en lugar de lo 
          anterior:</para>

        <programlisting>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</programlisting>

	<para>donde <hostid role="ipaddr">192.168.1.0</hostid> es la 
          direcci&oacute;n IP de nuestra red y <hostid 
	  role="netmask">255.255.255.0</hostid> es la m&aacute;scara de 
	  red.</para>

	<para><filename>/etc/ntp.conf</filename> puede contener varias 
          opciones de tipo <literal>restrict</literal>.  Para m&aacute;s 
          detalles consulte la secci&oacute;n <literal>Soporte de Control de 
          Acceso</literal> de &man.ntp.conf.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Ejecuci&oacute;n del Servidor de NTP</title>

      <para>Para asegurarnos de que el servidor de NTP se ejecuta en tiempo de 
        arranque se debe a&ntilde;adir la l&iacute;nea <literal>
        xntpd_enable="YES"</literal> al fichero 
	<filename>/etc/rc.conf</filename>.  Si deseamos pasar opciones 
        adicionales a &man.ntpd.8; se puede modificar la variable 
        <varname>xntpd_flags</varname> del fichero 
	<filename>/etc/rc.conf</filename>.</para>

      <para>Para ejecutar el servidor sin reiniciar la m&aacute;quina ejecute 
	<command>ntpd</command> junto con todos aquellos par&aacute;metros que 
        haya especificado en la variable de arranque 
        <varname>xntpd_flags</varname> del fichero 
	<filename>/etc/rc.conf</filename>.  Por ejemplo:</para>

      <screen>&prompt.root; <userinput>ntpd -p /var/run/ntpd.pid</userinput></screen>

      <note>
	<para>Bajo &os;&nbsp;5.X se han renombrado algunas opciones del 
          fichero <filename>/etc/rc.conf</filename>.  Se debe reemplazar 
          cualquier aparici&oacute;n <literal>xntpd</literal> por 
          por <literal>ntpd</literal>.</para></note>
    </sect2>

    <sect2>
      <title>Utilizaci&oacute;n de ntpd junto con una Conexi&oacute;n Temporal 
        a Internet</title>

      <para>El programa &man.ntpd.8; no necesita una conexi&oacute;n 
        permanente a Internet para poder funcionar correctamente.  No obstante 
        si la conexi&oacute;n a Internet se encuentra configurada con 
        marcaci&oacute;n bajo demanda es una buena idea impedir que el 
        tr&aacute;fico de NTP lance una marcaci&oacute;n autom&aacute;tica o 
        que mantenga la conexi&oacute;n viva.  Si se utiliza el PPP de 
        entorno de usuario se pueden utilizar las directivas 
        <literal>filter</literal> dentro del fichero 
        <filename>/etc/ppp/ppp.conf</filename> para evitar esto. Por  
        ejemplo:</para>

      <programlisting> set filter dial 0 deny udp src eq 123
 # Evita que el trfico NTP inice una llamada saliente
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 Evita que el trficoNTP entrante mantenga abierta la conexin
 set filter alive 1 deny udp dst eq 123
 Evita que el trfico NTP saliente mantenga abierta la conexin
 set filter alive 2 permit 0/0 0/0</programlisting>

      <para>Para &aacute;s detalles consulte la secci&oacute;n 
        <literal>PACKET FILTERING</literal> de &man.ppp.8; y los ejemplos que 
        se encuentran en 
	<filename>/usr/share/examples/ppp/</filename>.</para>

      <note>
        <para>Algunos proveedores de acceso a Internet bloquean paquetes que 
          utilizan n&uacute;meros de puertos bajos impidiendo que los paquetes 
          de vuelta alcancen nuestra m&aacute;quina.</para>
      </note>
    </sect2>

    <sect2>
      <title>Informaci&oacute;n Adicional</title>

      <para>Hay documentaci&oacute;n sobre el servidor NTP en formato HTML en 
        <filename>/usr/share/doc/ntp/</filename>.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>Traducci&oacute;n de Direcciones de Red</title>

    <sect2 id="network-natoverview">
      <title>Overview</title>
      <indexterm>
        <primary><application>natd</application></primary>
      </indexterm>
      <para>El d&aelig;mon de &os; que se encarga de traducir direcciones de 
        red,  m&aacute;s conocido como &man.natd.8;, es un d&aelig;mon que 
        acepta paquetes IP, modifica la direcci&oacute;n IP fuente de dichos 
        paquetes y los reinyecta en el flujo de paquetes IP de salida.  
        &man.natd.8; ejecuta este proceso modificando la direcci&oacute;n de 
        origen y el puerto de tal forma que cuando se reciben paquetes de 
        contestaci&oacute;n &man.natd.8; es capaz de determinar el destino 
        real y reenviar el paquete a dicho destino.</para>

      <indexterm><primary>Internet connection sharing</primary></indexterm>
      <indexterm><primary>IP masquerading</primary></indexterm>
      <para>El uso m&aacute;s com&uacute;n de NAT es para Compartir la 
        Conexi&oacute;n a Internet.</para>
    </sect2>

    <sect2 id="network-natsetup">
      <title>Configuraci&oacute;n</title>
      <para>Debido al peque&ntilde;o espacio de direccionamiento que se 
        encuentra actualmente disponible en IPv4 y debido tambi&eacute;n al 
        gran aumento que se est&aacute; produciendo en cuanto a n&uacute;mero 
        de usuarios de l&iacute;neas de conexi&oacute;n a Internet de alta 
        velocidad como cable o DSL la gente necesita utilizar cada vez 
        m&aacute;s la salida de Compartici&oacute;n de 
        Conexi&oacute;n a Internet.  La caracter&iacute;stica de poder conectar 
        varios computadores a trav&eacute;s de una &uacute;nica conexi&oacute;n 
        y una &uacute;nica direcci&oacute;n IP hacen de &man.natd.8; una 
	elecci&oacute;n razonable.</para>

      <para>Cada vez con m&aacute;s frecuencia un usuario t&iacute;pico 
        dispone de una m&aacute;quina conectada mediante cable o DSL pero 
        desear&iacute;a utilizar dicha m&aacute;quina como un <quote>
	router</quote> de acceso para el resto de los ordenadores de su red 
        de &aacute;rea local.</para>

       <para>Para poder hacerlo la m&aacute;quina (&os; por supuesto) debe 
         configurarse para actuar como pasarela.  Debe tener al menos dos 
         tarjetas de red, una para conectarse a la red de &aacute;rea local y 
         la otra para conectarse con el <quote>router</quote> de acceso a 
         Internet.  Todas las m&aacute;quinas de la LAN se conectan entre 
         s&iacute; mediante un <quote>hub</quote> o un <quote>
	 switch</quote>.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/natd">
        </imageobject>

	<textobject>
	  <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|______
|           |
| Cliente A |
|___________|</literallayout>
        </textobject>

	<textobject>
	  <phrase>Topolog&iacute;a de la Red</phrase>
	</textobject>
      </mediaobject>

      <para>Una configuraci&oacute;n como esta se utiliza frecuentemente para 
        compartir el acceso a Internet.  Una de las m&aacute;quinas de la 
        <acronym>LAN</acronym> est&aacute; realmente conectada a Internet.  
        El resto de las m&aacute;quinas acceden a Internet utilizando como 
        <quote>pasarela</quote> la m&aacute;quina inicial.</para>

    </sect2>

    <sect2 id="network-natdkernconfiguration">
      <indexterm>
        <primary>kernel</primary>
	<secondary>configuration</secondary>
      </indexterm>
      <title>Configuraci&oacute;n</title>
      <para>Se deben a&ntilde;adir las siguientes opciones al fichero de 
        configuraci&oacute;n del n&uacute;cleo:</para>
      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Adem&aacute;s, seg&uacute;n se prefiera, se pueden a&ntilde;adir 
        tambi&eacute;n las siguientes:</para>
      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>

      <para>Lo que viene a continuaci&oacute;n se tiene que definir en 
        <filename>/etc/rc.conf</filename>:</para>

      <programlisting>gateway_enable="YES"
firewall_enable="YES"
firewall_type="OPEN"
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>"
natd_flags=""</programlisting>

      <informaltable frame="none">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>gateway_enable="YES"</entry>
              <entry>Configura la m&aacute;quina para que act&uacute;e como 
	        <quote>router</quote> o pasarela de red.  Se puede conseguir 
                  lo mismo ejecutando 
                <command>sysctl net.inet.ip.forwarding=1</command>.</entry>
            </row>
            <row><entry>firewall_enable="YES"</entry>
             <entry>Activa las reglas de cortafuegos que se encuentran 
               definidas por defecto en 
               <filename>/etc/rc.firewall</filename> y que entran en 
               funcionamiento en el arranque del sistema.</entry>
            </row>
            <row><entry>firewall_type="OPEN"</entry>
              <entry>Especifica un conjunto de reglas de cortafuegos que 
                permite el acceso a todos los paquetes que se reciban.  
                Consulte <filename>/etc/rc.firewall</filename> para obtener 
                informaci&oacute;n sobre el resto de tipos de reglas que se 
                pueden configurar.</entry>
            </row>
            <row>
              <entry>natd_interface="fxp0"</entry>
              <entry>Indica qu&eacute; interfaz se utiliza para reenviar 
                paquetes (la interfaz que se conecta a Internet).</entry>
            </row>
            <row>
              <entry>natd_flags=""</entry>
              <entry>Define cualesquiera otras opciones que se deseen 
                proporcionar a &man.natd.8; en tiempo de arranque.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Si se definen las opciones anteriores, en el arranque del sistema 
        el fichero <filename>/etc/rc.conf</filename> configurar&aacute; las 
        variables de tal forma que se ejecutar&iacute;a el comando 
        <command>natd -interface fxp0</command>.  Evidentemente este comando 
        tambi&eacute;n se puede ejecutar de forma manual.</para>

      <note>
        <para>Tambi&eacute;n es posible utilizar un fichero de 
	  configuraci&oacute;n para &man.natd.8; en caso de que deseemos 
          especificar muchos par&aacute;metros de arranque. Tendremos que 
          declarar la ubicaci&oacute;n del fichero de configuraci&oacute;n 
	  mediante la inclusi&oacute;n de lo siguiente en 
          <filename>/etc/rc.conf</filename>:</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<para>El fichero <filename>/etc/natd.conf</filename> debe contener una 
          lista de opciones de configuraci&oacute;n una opci&oacute;n por 
          l&iacute;nea.  Por ejemplo, en el caso que se comenta en la siguiente 
          secci&oacute;n se utilizar&iacute;a un fichero de 
          configuraci&oacute;n con la siguiente informaci&oacute;n:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Para obtener m&aacute;s informaci&oacute;n sobre el fichero de 
          configuraci&oacute;n se puede consultar la opci&oacute;n 
          <option>-f</option> que se describe en la p&aacute;gina del manual de 
          &man.natd.8;.</para>
      </note>

      <para>Cada m&aacute;quina (y cada interfaz) que se encuentra conectada 
        a la LAN debe poseer una direcci&oacute;n IP perteneciente al espacio 
        de direcciones IP privado tal y como se define en <ulink 
         url="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</ulink> y debe 
        poseer como pasarela por defecto la direcci&oacute;n IP de la 
        interfaz interna (la interfaz que se conecta a la LAN) de la 
        m&aacute;quina que ejecuta 
            <application>natd</application>.</para>

      <para>Por ejemplo los clientes <hostid>A</hostid> y 
        <hostid>B</hostid> se encuentran en la LAN utilizando las direcciones 
        IP <hostid role="ipaddr">192.168.0.2</hostid> y  
        <hostid role="ipaddr">192.168.0.3</hostid>, respectivamente.  La 
        m&aacute;quina que ejecuta <application>natd</application> posee la 
        direcci&oacute;n IP <hostid 
        role="ipaddr">192.168.0.1</hostid> en la interfaz que se conecta a la 
        LAN.  El <quote>router</quote> por defecto tanto de <hostid>A</hostid> 
        omo de <hostid>B</hostid> se establece al valor 
        <hostid role="ipaddr">192.168.0.1</hostid>.  La interfaz externa de la 
	m&aacute;quina que ejecuta <application>natd</application>, la interfaz 
        que se conecta con Internet, no necesita de ninguna 
        especial en relaci&oacute;n con el tema que estamos tratando en esta 
        secci&oacute;n.</para>
    </sect2>

    <sect2 id="network-natdport-redirection">
      <title>Redirecci&oacute;n de Puertos</title>

      <para>El incoveniente que se presenta con la utilizaci&oacute;n de 
        &man.natd.8; es que los clientes de la LAN no son accesibles desde 
        Internet.  Dichos clientes pueden establecer conexiones con el 
        exterior pero no pueden recibir intentos de conexi&oacute;n desde 
        pueden recibir intentos de conexion desde Internet.  Esto supone un 
        gran problema cuando se quieren ejecutar servicios de acceso global 
        en una o varias m&aacute;quinas de la red LAN.  Una forma sencilla de 
        solucionar parcialmente este problemma consiste en redirigir 
        determinados puertos en el servidor <application>natd</application> 
	hacia determinadas m&aacute;quinas de la LAN.</para>

      <para>Supongamos por ejemplo que en <hostid>A</hostid> se ejecuta un 
        servidor de IRC y que en <hostid>B</hostid> se ejecuta un servidor 
        web.  Para que funcione lo que hemos comentado anteriormente se tienen 
        que redirigir las conexiones recibidas en los puertos 6667 (IRC) y 
        80 (web) a dichas m&aacute;quinas, respectivamente.</para>

      <para>Se debe pasar la opci&oacute;n <option>-redirect_port</option> a 
        &man.natd.8; con los valores apropiados.  La sintaxis es como 
        sigue:</para>
      <programlisting>  -redirect_port proto IPdestino:PUERTOdestino[-PUERTOdestino]
                 [aliasIP:]aliasPUERTO[-aliasPUERTO]
		 [IPremota[:PUERTOremoto[-PUERTOremoto]]]</programlisting>

      <para>Continuando con el ejemplo anterior los valores ser&iacute;an:</para>

        <programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>
        Esto redirigir&aacute; los puertos <emphasis>tcp</emphasis> adecuados 
            a las m&aacute;quinas situadas en la LAN.</para>

      <para>La opci&oacute;n <option>-redirect_port</option> se puede 
        utilizar para indicar rangos de puertos en vez de puertos 
        individuales.  Por ejemplo, <replaceable>tcp 
        192.168.0.2:2000-3000 2000-3000</replaceable> redirige todas las 
        conexiones recibidas desde los puertos 2000 al 3000 a los puertos 
        puertos 2000 a 3000 de la m&aacute;quina 
            <hostid>A</hostid>.</para>

      <para>Estas opciones se pueden utilizar cuando se ejecute 
        directamente el comando &man.natd.8; se pueden situar en la variable 
        <literal>natd_flags=""</literal> en 
        <filename>/etc/rc.conf</filename> y tambi&eacute;n se pueden pasar 
        mediante un archivo de configuraci&oacute;n.</para>

      <para>Para obtener m&aacute;s informaci&oacute;n sobre opciones de 
        configuraci&oacute;n por favor consulte &man.natd.8;</para>
    </sect2>

    <sect2 id="network-natdaddress-redirection">
      <title>Redirecci&oacute;n de Direcciones</title>
      <indexterm><primary>address redirection</primary></indexterm>
   
      <para>La redirecci&oacute;n de direcciones es una caracter&iacute;stica 
        &uacute;til si se dispone de varias direcciones IP pero todas ellas se 
        ubican en una &uacute;nica m&aacute;quina.  Gracias a esto 
        &man.natd.8; puede asignar a cada cliente de la red LAN su propia 
        direcci&oacute;n IP externa.  &man.natd.8; reescribe los paquetes que 
        salen de la red LAN con la direcci&oacute;n IP externa adecuada y 
        redirige todo el tr&aacute;fico recibido de vuelta al cliente en 
        funci&oacute;n de la direcci&oacute;n IP de destino: esto se conoce 
        como NAT est&aacute;tico.  Por ejemplo las direcciones IP 
        <hostid role="ipaddr">128.1.1.1</hostid>, 
        <hostid role="ipaddr">128.1.1.2</hostid> y 
        <hostid role="ipaddr">128.1.1.3</hostid> pertenecen al <quote>
        router</quote> <application>natd</application>.  
        <hostid role="ipaddr">128.1.1.1</hostid> se puede utilizar como la 
        direcci&oacute;n IP externa del 
        <application>natd</application>, mientras que 
        <hostid role="ipaddr">128.1.1.2</hostid> y 
        <hostid role="ipaddr">128.1.1.3</hostid> se redirigen a los 
            clientes <hostid>A</hostid> y <hostid>B</hostid>, respectivamente.</para>

      <para>La sintaxis de la opci&oacute;n
            <option>-redirect_address</option> es la siguiente:</para>

      <programlisting>-redirect_address IPlocal IPp&uacute;blica</programlisting>


      <informaltable frame="none">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>IPlocal</entry>
              <entry>La direcci&oacute;n IP interna del cliente de la LAN.</entry>
            </row>
            <row>
              <entry>IPp&uacute;blica</entry>
              <entry>La direcci&oacute;n IP externa que se corresponde con un 
                determinado cliente de la LAN.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>En nuestro ejemplo esta opci&oacute;n se especificar&iacute;a de la 
        siguiente forma:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>De forma semejante a la opci&oacute;n 
        <option>-redirect_port</option> estos argumentos se pueden especificar 
        directamente sobre la variable 
        <literal>natd_flags=""</literal> del fichero 
        <filename>/etc/rc.conf</filename> o tambi&eacute;n se pueden pasar 
        v&iacute;a archivo de configuraci&oacute;n de 
        <application>natd</application>.  Si se utiliza redirecci&oacute;n 
        de direcciones ya no es necesario utilizar redirecci&oacute;n de 
        puertos ya que todos los paquetes que se reciben en una determinada 
        direcci&oacute;n IP son redirigidos a la m&aacute;quina 
        especificada.</para>

      <para>Las direcciones IP externas de la m&aacute;quina que ejecuta 
        <application>natd</application> se deben activar y deben formar 
        parte de un alias configurado sobre la interfaz externa que se conecta 
        a Internet.  Consulte &man.rc.conf.5; para aprender a 
        hacerlo.</para>
    </sect2>
  </sect1>

  <sect1 id="network-inetd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Escrito por </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>El <quote>Super Servidor</quote> <application>
      inetd</application></title>

    <sect2 id="network-inetd-overview">
      <title>Resumen</title>

      <para>&man.inetd.8; se conoce como el <quote>Super Servidor de 
        Internet</quote> debido a que gestiona las conexiones de 
        varios d&aelig;mones.  Los d&aelig;mones son programas que 
	proporcionan servicios de red.  
        <application>inetd</application> act&uacute;a como un servidor de 
        servidor de gesti&oacute;n de otros d&aelig;mones.  Cuando 
        &man.inetd.8; recibe una conexi&oacute;n se determina qu&eacute; 
        d&aelig;mon deber&iacute;a responder a dicha conexi&oacute;n, se lanza 
	un proceso que ejecuta dicho d&aelig;mon y se le entrega el <quote>
	socket</quote>.  La ejecuci&oacute;n de una &uacute;nica instancia de 
        <application>inetd</application> reduce la carga del sistema en 
        comparaci&oacute;n con lo que significar&iacute;a ejecutar cada uno de 
        los d&aelig;mones que gestiona de forma individual.</para>

       <para><application>inetd</application> se utiliza principalmente para 
         lanzar procesos que albergan a otros d&aelig;mones pero 
         <application>inetd</application> tambi&eacute;n se utiliza para 
         gestionar determinados protocolos triviales como 
         <application>chargen</application>, 
            <application>auth</application> y 
            <application>daytime</application>.</para> 

      <para>Esta secci&oacute;n trata la configuraci&oacute;n b&aacute;sica de 
        <application>inetd</application> a trav&eacute;s de sus opciones de 
        l&iacute;nea de comandos y utilizando su fichero de 
            configuraci&oacute;n, denominado 
            <filename>/etc/inetd.conf</filename>.</para>

    </sect2>

    <sect2 id="network-inetd-settings">
      <title>Configuraciones</title>

      <para><application>inetd</application> se inicializa a trav&eacute;s 
        del fichero <filename>/etc/rc.conf</filename> en tiempo de 
        arranque.  La opci&oacute;n <literal>inetd_enable</literal> posee el 
        valor <literal>NO</literal> por defecto, pero a menudo la 
        aplicaci&oacute;n <application>sysinstall</application> la activa 
        cuando se utiliza la configuraci&oacute;n de perfil de seguridad 
        medio.  
	Estableciendo <programlisting>inetd_enable="YES"</programlisting> o 
	<programlisting>inetd_enable="NO"</programlisting> dentro de 
	<filename>/etc/rc.conf</filename> se puede activar o desactivar la 
        la ejecuci&oacute;n de 
        <application>inetd</application> en el arranque del 
	sistema.</para>

      <para>Se pueden adem&aacute;s aplicar distintas opciones de 
        l&iacute;nea de comandos mediante la opci&oacute;n 
        <literal>inetd_flags</literal>.</para>

    </sect2>

    <sect2 id="network-inetd-cmdline">
      <title>Opciones de L&iacute;nea de Comandos</title>

      <para><application>sinopsis de inetd</application>:</para>

      <para><option>     inetd [-d] [-l] [-w] [-W] [-c m&aacute;ximo] [-C tasa] [-a direcci&oacute;n | nombre_de_host]
           [-p nombre_de_fichero] [-R tasa] [fichero de configuraci&oacute;n ]</option></para>

      <variablelist>
	<varlistentry>
	  <term>-d</term>

	  <listitem>
	    <para>Activa la depuraci&oacute;n.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-l</term>

	  <listitem>
	    <para>Activa el <quote>logging</quote> de las conexiones 
	      efectuadas con &eacute;cute.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-w</term>

	  <listitem>
	    <para>Activa el recubrimiento de TCP para servicios
                  externos (activado por defecto).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-W</term>

	  <listitem>
	    <para>Activa el recubrimiento de TCP para los servicios
              internos, ejecutados directamente por el d&aelig;mon 
              <application>inetd</application> (activado por defecto).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-c m&aacute;ximo</term>

	  <listitem>
	    <para>Especifica el m&aacute;ximo n&uacute;mero de invocaciones 
              simult&aacute;neas de cada servicio; el valor por defecto es 
              ilimitado.  Se puede sobreescribir para cada servicio utilizando 
              la opci&oacute;n <option>max-child</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-C tasa</term>

	  <listitem>
            <para>Especifica el m&aacute;ximo n&uacute;mero de veces que se 
              puede llamar a un servicio desde un direcci&oacute;n IP 
              determinada por minuto; el valor por defecto es ilimitado.  Se 
              puede redefinir para cada servicio utilizando la opci&oacute;n 
	      <option>max-connections-per-ip-per-minute</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-R tasa</term>

	  <listitem>
	    <para>Especifica el m&aacute;ximo n&uacute;mero de veces que se 
              puede invocar un servicio en un minuto; el valor por defecto es 
              256.  Un valor de 0 permite un n&uacute;mero ilimitado de 
              llamadas.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-a</term>

	  <listitem>
            <para>Especifica una direcci&oacute;n IP a la cual se asocia y 
              sobre la cual se queda esperando recibir conexiones.  Puede 
              declararse tambi&eacute;n un nombre de m&aacute;quina, en cuyo 
              caso se utilizar&aacute; la direcci&oacute;n (o direcciones si 
	      hay m&aacute;s de una) IPv4 o IPv6 que est&eacute;n tras dicho 
              nombre.  Normalmente se usa un nombre de 
              m&aacute;quina cuando <application>inetd</application> se 
              ejecuta dentro de un &man.jail.8;, en cuyo caso el nombre de 
              m&aacute;quina se corresponde con el entorno 
              &man.jail.8;.</para>

            <para>Cuando se desea asociarse tanto a direcciones IPv4 como a 
              direcciones IPv6 y se utiliza un nombre de m&aacute;quina se 
              necesita una entrada para cada protocolo (IPv4 o IPv6) para cada 
              servicio que se active a trav&eacute;s de <filename>
              /etc/inetd.conf</filename>.  Por ejemplo un servicio basado en 
              TCP necesitar&iacute;a dos entradas, una utilizando 
              <literal>tcp4</literal> para el protocolo IPv4 y otra con 
              <literal>tcp6</literal> para las conexiones a trav&eacute;s del 
              procolo de red IPv6.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-p</term>

	  <listitem>
	    <para>Especifica un fichero alternativo en el cual se guarda el 
              ID del proceso.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Estas opciones se pueden declarar dentro de las variables 
	<literal>inetd_flags</literal> del fichero 
	<filename>/etc/rc.conf</filename>.  Por defecto 
	<literal>inetd_flags</literal> tiene el valor <literal>-wW</literal>, 
	lo que activa el recubrimiento de TCP para los servicios internos y 
        externos de <application>inetd</application>.  Los usuarios inexpertos 
        no suelen introducir estos par&aacute;metros y por ello ni siquiera 
        necesitan especificarse dentro de <filename>
        /etc/rc.conf</filename>.</para>

      <note>
        <para>Un servicio externo es un d&aelig;mon que se ejecuta fuera de 
          <application>inetd</application> y que se lanza cuando se recibe 
          un intento de conexi&oacute;n.  Un servicio interno es un servicio 
          que <application>inetd</application> puede servir directamente sin 
          necesidad de lanzar nuevos procesos.</para>
      </note>

    </sect2>

    <sect2 id="network-inetd-conf">
      <title><filename>inetd.conf</filename></title>

      <para>La configuraci&oacute;n de 
        <application>inetd</application> se realiza a trav&eacute;s del 
        ficherode configuraci&oacute;n <filename>
	/etc/inetd.conf</filename>.</para>

      <para>Cuando se realiza una modificaci&oacute;n en el fichero 
	<filename>/etc/inetd.conf</filename> se debe obligar a 
        <application>inetd</application> a releer dicho fichero de 
        configuraci&oacute;n, lo cual se realiza enviando una se&ntilde;al 
        <quote>HANGUP</quote> al proceso <application>inetd</application> 
        como se muestra a continuaci&oacute;n:</para>

      <example id="network-inetd-hangup">
	<title>Env&iacute;o de una se&ntilde;al de tipo HANGUP a <application>inetd</application></title>

	<screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
      </example>

      <para>Cada l&iacute;nea del fichero de configuraci&oacute;n especifica un 
        d&aelig;mon individual.  Los comentarios se preceden por el 
        caracter <quote>#</quote>.  El formato del fichero de 
        configuraci&oacute;n <filename>/etc/inetd.conf</filename> es el 
	siguiente:</para>

      <programlisting>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</programlisting>

      <para>A continuaci&oacute;n se muestra una entrada de ejemplo para el 
        d&aelig;mon <application>ftpd</application> para IPv4:</para>

      <programlisting>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</programlisting>

      <variablelist>
	<varlistentry>
	  <term>service-name</term>

	  <listitem>
	    <para>Este es el nombre del servicio que proporciona un
              determinado d&aelig;mon.  Se debe corresponder con el nombre del 
              nombre de servicio que se declara en el fichero 
	      <filename>/etc/services</filename>.  Este fichero determina sobre 
              qu&eacute; puerto debe ponerse a escuchar 
              <application>inetd</application>.  Si se crea un nuevo servicio 
              se debe especificar primero en 
              <filename>/etc/services</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>socket-type</term>

	  <listitem>
	    <para>Puede ser <literal>stream</literal>,
	      <literal>dgram</literal>, <literal>raw</literal> o 
	      <literal>seqpacket</literal>.  <literal>stream</literal> 
	      se debe utilizar obligatoriamente para d&aelig;mones orientados 
              a conexi&oacute;n (d&aelig;mones TCP) mientras que 
	      <literal>dgram</literal> se utiliza en d&aelig;mones basados en 
              el protocolo de transporte UDP.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>protocol</term>

	  <listitem>
	    <para>Uno de los siguientes:</para>

	    <informaltable>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>Protocolo</entry>
		    <entry>Explicaci&oacute;n</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>tcp, tcp4</entry>
		    <entry>TCP IPv4</entry>
		  </row>
		  <row>
		    <entry>udp, udp4</entry>
		    <entry>UDP IPv4</entry>
		  </row>
		  <row>
		    <entry>tcp6</entry>
		    <entry>TCP IPv6</entry>
		  </row>
		  <row>
		    <entry>udp6</entry>
		    <entry>UDP IPv6</entry>
		  </row>
		  <row>
		    <entry>tcp46</entry>
		    <entry>TCP IPv4 e IPv6 al mismo tiempo</entry>
		  </row>
		  <row>
		    <entry>udp46</entry>
		    <entry>UDP IPv4 e IPv6 al mismo tiempo</entry>
		  </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</term>

	  <listitem>
	    <para><option>wait|nowait</option> indica si el d&aelig;mon puede 
              gestionar su propio <quote>socket</quote> o no.  Los <quote>
              sockets</quote> de tipo <option>dgram</option> deben utilizar 
              obigatoriamente la opci&oacute;n <option>wait</option> mientras 
	      que los d&aelig;mones basados en <quote>sockets</quote> de tipo 
              <quote>stream</quote>, los cuales se implementan normalmente 
              mediante hilos, deber&iacute;a utilizar la opci&oacute;n 
              <option>nowait</option>. La opci&oacute;n 
              <option>wait</option> normalmente entrega varios <quote>
              sockets</quote> a un &uacute;nico d&aelig;mon, mientras que la 
	      opci&oacute;n <option>nowait</option> lanza un d&aelig;mon 
              <quote>hijo</quote> por cada nuevo <quote>
	      socket</quote>.</para>

            <para>El n&uacute;mero m&aacute;ximo de d&aelig;mones <quote>
	      hijo</quote> que puede lanzar 
	      <application>inetd</application> se puede especificar mediante 
              la opci&oacute;n <option>max-child</option>.  Si se necesita por 
              ejemplo un l&iacute;mite de diez instancias para un d&aelig;mon 
              en particular se puede especificar el valor 
              <literal>10</literal> justo despu&eacute;s de la opci&oacute;n 
              <option>nowait</option>.</para>
             
            <para>Adem&aacute;s de <option>max-child</option> se puede activar 
              otra opci&oacute;n para limitar en n&uacute;mero m&aacute;ximo de 
              conexiones que se aceptan desde un determinado lugar mediante la 
              opci&oacute;n
              <option>max-connections-per-ip-per-minute</option>.  
              Esta opci&oacute;n hace justo lo que su nombre indica.  Un 
              valor de, por ejemplo, diez en esta opci&oacute;n 
	      limitar&iacute;a cualquier m&aacute;quina remota a un 
              m&aacute;ximo de diez intentos de conexi&oacute;n por 
              minuto.  Esto resulta &uacute;til para prevenir un consumo 
              incontrolado de recursos y ataques de Denegaci&oacute;n de 
              Servicio (<quote>Denial of Service</quote> o DoS) sobre nuestra 
              m&aacute;quina.</para>

            <para>Cuando se especifica este campo las opciones 
              <option>wait</option> o <option>nowait</option> son 
	      obligatorias  <option>max-child</option> y 
	      <option>max-connections-per-ip-per-minute</option> son 
	      opcionales.</para>

	    <para>Un d&aelig;mon de tipo <quote>stream</quote> sin la 
              opci&oacute;n <option>max-child</option> y sin la opci&oacute;n 
              <option>max-connections-per-ip-per-minute</option> 
              simplemente especificar&iacute;a la opci&oacute;n 
	      <literal>nowait</literal>.</para>

            <para>El mismo d&aelig;mon con el l&iacute;mite m&aacute;ximo de 
              diez d&aelig;mones <quote>hijos</quote> ser&iacute;a: 
	      <literal>nowait/10</literal>.</para>

            <para>La misma configuraci&oacute;n con un l&iacute;mite 
              de veinte conexiones por direcci&oacute;n IP por minuto y un 
              m&aacute;ximo total de diez d&aelig;mones <quote>hijos</quote> 
	      ser&iacute;a: 
	      <literal>nowait/10/20</literal>.</para>

            <para>Todas estas opciones son utilizadas por el d&aelig;mon 
                  <application>fingerd</application> que se muestra a 
                  continuaci&oacute;n a modo de ejemplo:</para>

	    <programlisting>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</programlisting>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>user</term>

	  <listitem>
            <para>Este es el nombre de usuario con el que deber&iacute;a 
              ejecutarse un determinado d&aelig;mon.  Normalmente los 
              d&aelig;mones se suelen ejectar con permisos de 
              <username>root</username>.  Por motivos de seguridad, resulta 
              bastante com&uacute;n encontrarse con algunos servidores que se 
              ejecutan bajo el usuario <username>daemon</username> o incluso 
              por el usuario menos privilegiado de todos que es el usuario 
              <username>nobody</username>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program</term>

	  <listitem>
	    <para>La ruta completa de la localizaci&oacute;n del d&aelig;mon  
              que se quiere ejecutar cuando se recibe un intento de 
              conexi&oacute;n.  Si el d&aelig;mon  es un servicio 
              proporcionado por el propio <application>inetd</application> se 
              debe utilizar la opcion <option>internal</option> en su 
              lugar.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program-arguments</term>

	  <listitem>
	    <para>Esto funciona en conjunci&oacute;n con 
	      <option>server-program</option>, ya que especifica los 
               argumentos, comenzando por 
               <literal>argv[0]</literal>, que se pasan al d&aelig;mon 
               cuando se le invoca.  Si la l&iacute;nea de comandos es
               <command>mydaemon -d</command>, <literal>mid&aelig;mon 
                -d</literal> deber&iacute;a ser el valor de la opci&oacute;n
                <option>server-program-arguments</option>. Si el 
               d&aelig;mon es un servicio interno se debe utilizar la 
               utilizar la opci&oacute;n <option>internal</option> en lugar de 
               la que estamos comentando.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="network-inetd-security">
      <title>Security</title>

      <para>Dependiendo del perfil de seguridad establecido cuando se 
        instal&oacute; el sistema &os;  varios d&aelig;mones de 
        <application>inetd</application> pueden estar desactivados o 
        activados.  Si no se necesita un d&aelig;mon determinado, <emphasis>
        no lo active</emphasis>.  Especifique un <quote>#</quote> al 
	comienzo de la l&iacute;nea del d&aelig;mon que quiere desactivar y 
        env&iacute;e una se&ntilde;al <link
         linkend="network-inetd-hangup">hangup</link> a 
        <application>inetd</application>.  No se aconseja ejecutar algunos 
        d&aelig;mones determinados (un caso t&iacute;pico es 
        <application>fingerd</application>) porque pueden proporcionar 
        informaci&oacute;n valiosa para un atacante.</para>

      <para>Algunos d&aelig;mones no presentan ninguna caracter&iacute;stica de 
        seguridad y poseen grandes o incluso no poseen tiempos de 
        expiraci&oacute;n para los intentos de conexi&oacute;n.  Esto permite 
        que un atacante sature los recursos de nuestra m&aacute;quina 
        realizando intentos de conexi&oacute;n a una tasa relativamente baja 
        contra uno de estos ingenuos d&aelig;mones.  Pueder ser una buena 
        idea protegerse de esto utilizando las opciones 
   	<option>max-connections-per-ip-per-minute</option> y <option>
	max-child</option> para este tipo de d&aelig;mones.</para>

      <para>El recubrimiento de TCP est&aacute; activado por defecto tal y como 
        ya se ha comentado anteriormente.  Consulte la p&aacute;gina 
        del manual de &man.hosts.access.5; para obtener m&aacute;s 
        informaci&oacute;n sobre c&oacute;mo aplicar restricciones 
        relacionadas con TCP a los d&aelig;mones invocados por 
        <application>inetd</application>.</para>
    </sect2>

    <sect2 id="network-inetd-misc">
      <title>Varios</title>

      <para><application>daytime</application>,
	<application>time</application>,
	<application>echo</application>,
	<application>discard</application>,
	<application>chargen</application> y
	<application>auth</application> son servicios que 
        <application>inetd</application> proporciona de forma 
        interna y propia.</para>

      <para>El servicio <application>auth</application> proporciona 
        servicios de identificaci&oacute;n a trav&eacute;s de la red 
	(<application>ident</application>, 
            <application>identd</application>) y se puede configurar 
            hasta en cierto grado.</para>

      <para>Consulte la p&aacute;gina del manual de &man.inetd.8; si quiere 
        conocer todos los detalles.</para>
    </sect2>
  </sect1>

  <sect1 id="network-plip">
    <title>L&iacute;nea IP Paralela (PLIP)</title>

    <indexterm><primary>PLIP</primary></indexterm>
    <indexterm><primary>Parallel Line IP</primary></indexterm>

    <para>PLIP nos permite configurar TCP/IP a trav&eacute;s del puerto 
      paralelo.  Es &uacute;til para conectar m&aacute;quinas que no poseen 
      tarjetas de red, o para instalar &os; en ciertos viejos modelos de 
      port&aacute;tiles.  En esta secci&oacute;n se explica lo 
      siguiente:</para>

    <itemizedlist>
      <listitem>
	<para>Construcci&oacute;n de un cable paralelo (laplink).</para>
      </listitem>

      <listitem>
	<para>Conexi&oacute;n de dos computadores utilizando PLIP.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Construcci&oacute;n de un Cable Paralelo</title>

      <para>Se puede comprar un cable paralelo en cualquier tienda de 
         componentes inform&aacute;ticos. No obstante si no es posible 
         comprarlo o simplemente queremos saber c&oacute;mo hacerlo 
         nosotros mismos, en la siguiente tabla mostramos como hacer un cable 
         de impresora paralelo.</para>

      <table>
	<title>Cableado de una Conexi&oacute;n de Cable Paralelo para Redes</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Nombre-A</entry>

	      <entry>Extremo-A</entry>

	      <entry>Extremo-B</entry>

	      <entry>Descr.</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>Configuraci&oacute;n de PLIP</title>

       <para>En primer lugar debemos tener en nuesras manos un cable <quote>
         laplink</quote>.  A continuaci&oacute;n se debe comprobar que ambos 
         sistemas poseen n&uacute;cleos con soporte para el controlador 
	 &man.lpt.4;:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>El puerto paralelo debe ser un puerto controlado por alguna <quote>
        irq</quote>.  En &os;&nbsp;4.X se deber&iacute;a tener un l&iacute;nea 
        como la siguiente en el fichero de configuraci&oacute;n del 
        kernel:</para>

      <programlisting>device ppc0 at isa? irq 7</programlisting>

      <para>En &os;&nbsp;5.X el fichero 
	<filename>/boot/device.hints</filename> debe contener las siguientes 
        l&iacute;neas:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>A continuaci&oacute;n se debe comprobar que el fichero de 
        configuraci&oacute;n del n&uacute;cleo posee una l&iacute;nea con 
        <literal>device plip</literal> o tambi&eacute;n puede 
        comprobar si se ha cargado el m&oacute;dulo del n&uacute;cleo 
        <filename>plip.ko</filename>.  Tanto en un caso como en el otro, cuando 
        se ejecute &man.ifconfig.8; deber&iacute;a aparecer el interfaz de 
        red paralelo.  En &os;&nbsp;4.X se muestra algo parecido a 
        lo siguiente:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>y en &os;&nbsp;5.X:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <note><para>El nombre del dispositivo utilizado para la interfaz 
        paralela es distinto en &os;&nbsp;4.X 
	(<devicename>lp<replaceable>X</replaceable></devicename>)
	y en &os;&nbsp;5.X 
	(<devicename>plip<replaceable>X</replaceable></devicename>).</para></note>

      <para>Enchufe el cable <quote>laplink</quote> en los interfaces de ambos 
        computadores.</para>

      <para>Configure los par&aacute;metros de la interfaz de red en ambas 
        m&aacute;quinas como <username>root</username>.  Por ejemplo, si 
        queremos conectar la m&aacute;quina <hostid>host1</hostid> 
            ejecutando &os;&nbsp;4.X con la m&aacute;quina 
            <hostid>host2</hostid> que ejecuta &os;&nbsp;5.X:</para>

      <programlisting>                 host1 &lt;-----&gt; host2
Direcci&oacute;n IP 10.0.0.1      10.0.0.2</programlisting>

      <para>Configure la interfaz de <hostid>host1</hostid> as&iacute;:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Configure la interfaz de <hostid>host2</hostid> por medio de:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>


      <para>Tras esto deber&iacute;a disponerse de una conexi&oacute;n 
        totalmente funcional.  Por favor, consulte &man.lp.4; y &man.lpt.4; 
        si quiere saber m&aacute;s.</para>

      <para>Adem&aacute;s se debe a&ntilde;adir ambas m&aacute;quinas al 
	fichero <filename>/etc/hosts</filename>:</para>

      <programlisting>127.0.0.1               localhost.mi.dominio localhost
10.0.0.1                host1.mi.dominio host1
10.0.0.2                host2.mi.dominio</programlisting>

      <para>Para comprobar que efectivamente la conexi&oacute;n funciona se 
            puede probar a hacer un ping desde cada m&aacute;quina.  Por 
            ejemplo en la m&aacute;quina <hostid>host1</hostid>:</para>

          <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       lp0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>

    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Aaron</firstname>
	  <surname>Kaplan</surname>
	  <contrib>Texto original de </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Reestructurado y ampliado por </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>IPv6</title>
    <para>IPv6 (tambi&eacute;n conocido como IPng o <quote>IP de nueva 
      generaci&oacute;n</quote>) es la nueva versi&oacute;n del conocido 
      protocolo de red IP, tamb&iacute;en llamado IPv4.  Como sucede con el 
      resto de los sistemas *BSD &os; proporciona una implementaci&oacute;n 
      de referencia que desarrolla el proyecto japon&eacute;s 
      <acronym>KAME</acronym>.  &os; dispone de todo lo necesario para 
      experimentar con el nuevo protocolo de red.  Esta secci&oacute;n se 
      centra en conseguir configurar y ejecutar correctamente el protocolo 
      IPv6.</para>

    <para>Al comienzo de los a&ntilde;os 90 la gente comenz&oacute; a 
      preocuparse por el r&aacute;pido consumo del espacio de direcciones 
      de IPv4.  Dada la expansi&oacute;n actual de Internet existen dos 
      preocupaciones principales:</para>

    <itemizedlist>
      <listitem>
	<para>Agotamiento de las direcciones disponibles.  Actualmente 
          no se trata del principal problema debido al uso generalizado del 
          del espacio de direccionamiento privado 
          (<hostid role="ipaddr">10.0.0.0/8</hostid>, 
          <hostid role="ipaddr">192.168.0.0/24</hostid>, etc.) junto con 
	  <acronym>NAT</acronym>.
      </listitem>

      <listitem>
	<para>El n&uacute;mero de entradas de las tablas de rutas comenzaba a 
          ser imposible de manejar.  Esto todavia es un problema 
          prioritario.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 trata de resolver estos problemas y algunos m&aacute;s de la 
      siguiente forma:</para>

    <itemizedlist>
      <listitem>
	<para>IPv6 posee un espacio de direccionamiento de 128 bits.  En otras 
          palabras, en teor&iacute;a existen  
	  340,282,366,920,938,463,463,374,607,431,768,211,456 
          direcciones disponibles.  Esto significa que existen 
	  aproximadamente 6.67 * 10^27 direcciones IPv6 por metro cuadrado 
	  disponibles para todo el planeta Tierra.</para>
      </listitem>

      <listitem>
        <para>Los <quote>routers</quote> s&oacute;lo almacenan direcciones de 
	  red agregadas as&iacute; que se reduce el n&uacute;mero de entradas 
          para cada tabla de rutas a un promedio de 8192.</para>
      </listitem>
    </itemizedlist>

    <para>Existen adem&aacute;s muchas otras caracter&iacute;siticas 
      interesantes que IPv6 proporciona, como:</para>

    <itemizedlist>
      <listitem>
	<para>Autoconfiguraci&oacute;n de direcciones (<ulink 
	  url="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</ulink>)</para>
      </listitem>

      <listitem>
	<para>Direcciones anycast (<quote>una-de-varias</quote>)</para>
      </listitem>

      <listitem>
	<para>Soporte de direcciones multicast predefinido</para>
      </listitem>

      <listitem>
	<para>IPsec (Seguridad en IP)</para>
      </listitem>

      <listitem>
	<para>Estructura de la cabecera simplificada</para>
      </listitem>

      <listitem>
	<para>IP m&oacute;vil</para>
      </listitem>

      <listitem>
	<para>Mecanismos de traducci&oacute;n de IPv6 a IPv4 (y viceversa)</para>
      </listitem>
    </itemizedlist>


    <para>Si quiere saber m&aacute;s sobre IPv6 le recomendamos que 
      consulte:</para>

    <itemizedlist>
      <listitem>
	<para>Resumen de IPv6 en <ulink url="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.6bone.net">6bone.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Conceptos B&aacute;sicos sobre las Direcciones IPv6</title>

      <para>Existen varios tipos distintos de direcciones IPv6: Unicast, 
        Anycast y Multicast.</para>

      <para>Las direcciones unicast son direcciones bien conocidas.  Un 
        paquete que se env&iacute;a a una direcci&oacute;n unicast 
        deber&iacute;n llega a la interfaz identificada por dicha 
        direcci&oacute;n.</para>

      <para>Las direcciones anycast son sint&aacute;cticamente indistinguibles 
        de las direcciones unicast pero sirven para identificar a un 
        <emphasis>conjunto</emphasis> de interfaces.  Un paquete destinado a 
        una direcci&oacute;n anycast llega a la interfaz 
        <quote>m&aacute;s cercana</quote> (en t&eacute;rminos de 
        m&eacute;trica de <quote>routers</quote>).  Las direcciones anycast 
        s&oacute;lo se pueden utilizar en <quote>routers</quote>.</para>

      <para>Las direcciones multicast identifican un grupo de interfaces.  
        Un paquete destinado a una direcci&oacute;n multicast llega a todos los 
        los interfaces que se encuentran agrupados bajo dicha 
        direcci&oacute;n.</para>

	<note><para>Las direcciones IPv4 de tipo broadcast 
          (normalmente <hostid 
          role="ipaddr">xxx.xxx.xxx.255</hostid>) se expresan en 
          IPv6 mediante direcciones multicast.</para></note>

      <table>
	<title>Direcciones IPv6 Reservadas</title>

	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry>Direcci&oacute;n IPv6</entry>
	      <entry>Longitud del Prefijo (Bits)</entry>
	      <entry>Descripci&oacute;n</entry>
	      <entry>Notas</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><hostid role="ip6addr">::</hostid></entry>
	      <entry>128 bits</entry>
	      <entry>sin especificar</entry>
	      <entry>como <hostid role="ipaddr">0.0.0.0</hostid> en Pv4</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">::1</hostid></entry>
	      <entry>128 bits</entry>
	      <entry>direcci&oacute;n de bucle local (loopback)</entry>
	      <entry>como las <hostid role="ipaddr">127.0.0.1</hostid> en
		IPv4</entry>
	    </row>

	    <row>
	      <entry><hostid
		role="ip6addr">::00:xx:xx:xx:xx</hostid></entry>
	      <entry>96 bits</entry>
	      <entry>direcci&oacute;nes IPv6 compatibles con IPv4</entry>
	      <entry>Los 32 bits m&aacute;s bajos contienen una 
	        direcci&oacute;n IPv4.  Tambi&eacute;n se denominan direcciones 
                <quote>empotradas.</quote></entry>
	    </row>

	    <row>
	      <entry><hostid
		role="ip6addr">::ff:xx:xx:xx:xx</hostid></entry>
	      <entry>96 bits</entry>
	      <entry>direcciones IPv6 mapeadas a IPv4</entry>
	      <entry>Los 32 bits m&aacute;s bajos contienen una 
	        direcci&oacute;n IPv4.  Se usan para representar direcciones 
                IPv4 mediante direcciones IPv6.</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">fe80::</hostid> - 
		<hostid role="ip6addr">feb::</hostid></entry>
	      <entry>10 bits</entry>
	      <entry>direcciones link-local</entry>
	      <entry>equivalentes a la direcci&oacute;n de loopback de 
	        IPv4</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">fec0::</hostid> - 
		<hostid role="ip6addr">fef::</hostid></entry>
	      <entry>10 bits</entry>
	      <entry>direcciones site-local</entry>
	      <entry>Equivalentes al direccionamiento privado de IPv4</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">ff::</hostid></entry>
	      <entry>8 bits</entry>
	      <entry>multicast</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">001</hostid> (base
		2)</entry>
	      <entry>3 bits</entry>
	      <entry>direcciones unicast globales</entry>
	      <entry>Todas las direcciones IPv6 globales se asignan a partir de 
                este espacio. Los primeros tres bits siempre son 
                <quote>001</quote>.</entry>

	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2>
      <title>Lectura de las Direcciones IPv6</title>
      <para>La forma can&oacute;nica que se utiliza para representar 
        direcciones IPv6 es: <hostid 
         role="ip6addr">x:x:x:x:x:x:x:x</hostid>, donde cada 
	<quote>x</quote> se considera un valor hexadecimal de 16 Bit.  
        Por ejemplo 
	<hostid 
	 role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid></para>

      <para>A menudo una direcci&oacute;n posee alguna subcadena de varios 
        ceros consecutivos de forma que se puede abreviar dicha cadena 
        (s&oacute;lo una vez, para evitar ambig&uacute;edades) mediante 
        <quote>::</quote>.  Tambi&eacute;n se pueden omitir los ceros a la 
        ceros a la izquierda dentro de un valor 
        <quote>x</quote>. Por ejemplo 
	<hostid role="ip6addr">fe80::1</hostid> se corresponde con la forma 
	can&oacute;nica 
	<hostid role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid>.</para>

      <para>Una tercera forma de escribir direciones IPv6 es utilizando la 
        ya tradicional notaci&oacute;n decimal de IPv4 pero 
        s&oacute;lamente para los 32 bits m&aacute;s bajos de la 
        direcci&oacute;n IPv6.  Por ejemplo 
	<hostid role="ip6addr">2002::10.0.0.1</hostid> se corresponder&iacute;a 
	con la  representation hexadecimal can&oacute;nica  
	<hostid role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>
	la cual es equivalente tambi&eacute;n a escribir <hostid 
         role="ip6addr">2002::a00:1</hostid>.</para>


      <para>A estas alturas el lector deber&iacute;a ser capaz de comprender 
            lo siguiente:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</programlisting>

      <para><hostid role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid>
	es una direcci&oacute;n link-local autoconfigurada.  Se construye a 
        partir de la direcci&oacute;n MAC de la tarjeta de red.</para>

      <para>Si quiere saber m&aacute;s sobre la estructura de las 
            direcciones IPv6 puede consultar <ulink 
	url="http://www.ietf.org/rfc/rfc3513.txt">RFC3513</ulink>.</para>
    </sect2>

    <sect2>
      <title>Establecimiento de Conectividad</title>

      <para>Actualmente existen cuatro formas distintas de conectarse 
        con otras m&aacute;quinas y redes IPv6:</para>

      <itemizedlist>
	<listitem>
	  <para>Unirse a la red experimental denominada 6bone</para>
	</listitem>

	<listitem>
	  <para>Obtener una red IPv6 a trav&eacute;s de nuestro proveedor de 
            acceso a Internet.  Consulte a su proveedor de servicios para 
            para m&aacute;s informaci&oacute;n.</para>
	</listitem>

	<listitem>
	  <para>Encapsulaci&oacute;n de IPv6 sobre IPv4 (<ulink 
	     url="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</ulink>)</para>
	</listitem>

	<listitem>
	  <para>Utilizaci&oacute;n del <quote>port</quote> <filename 
             role="package">net/freenet6</filename> si se dispone de una 
            de una conexi&oacute;n de marcaci&oacute;n por modem.</para>
	</listitem>
      </itemizedlist>

      <para>Vamos a explicar c&oacute;mo conectarse al 6bone ya que parece ser 
        la forma m&aacute;s utilizada en la actualidad.</para>

      <para>En primer lugar se recomienda consultar el sitio web de 
        <ulink url="http://www.6bone.net/">6bone</ulink> para saber 
        cu&aacute;l es la conexi&oacute;n del 6bone (f&iacute;sicamente) 
	m&aacute;s pr&oacute;xima.  Se debe escribir a la persona responsable 
        de ese nodo y con un poco de suerte dicha persona responder&aacute; con 
        con un conjunto de instrucciones y pasos a seguir para establecer la 
        la conexi&oacute;n con ellos y a trav&eacute;s de ellos con el resto 
        de los nodos IPv6 que forman parte del 6bone.  Normalmente esta 
        conexi&oacute;n se establece usando t&uacute;neles GRE (gif).</para>

      <para>Veamos un ejemplo t&iacute;pico de configuraci&oacute;n de un 
        de un t&uacute;nel &man.gif.4;:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>MI_DIRECCI&Oacute;n_IPV4</replaceable>  <replaceable>SU_DIRECCI&Oacute;n_IPV4</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 inet6 alias <replaceable>DIRECCI&Oacute;n_DE-SALIDA_IPv6_DEL_T&Uacute;NEL_ASIGNADO</replaceable></userinput></screen>

      <para>Sustituya las palabras en may&uacute;sculas por la 
        informaci&oacute;n recibida del nodo 6bone al que nos queremos 
        conectar.</para>

      <para>El comando anterior establece el t&uacute;nel.  Compruebe que el 
        t&uacute;nel funciona correctamente mediante &man.ping.8;.  
        Haga un &man.ping6.8; a <hostid 
         role="ip6addr">ff02::1%gif0</hostid>.  Deber&iacute;amos recibir 
        recibir <quote>dos</quote> respuestas.</para>

	<note><para>Para que el lector no se quede pensando en el significado 
          significado de la direcci&oacute;n <hostid 
          role="ip6addr">ff02:1%gif0</hostid> le podemos decir que se trata de 
          de una direcci&oacute;n IPv6 multicast de tipo link-local.  
          <literal>%gif0</literal> no forma parte del protocolo IPv6 como tal 
          sino que se trata de un detalle de implementaci&oacute;n relacionado 
          con las direcciones link-local y se a&ntilde;ade para especificar la 
          interfaz de salida que se debe utilizar para enviar los paquetes de 
          &man.ping6.8;.  Como estamos haciendo ping a una direcci&oacute;n 
          multicast a la que se unen todos los interfaces pertenecientes al 
          mismo enlace deber&iacute;a responder al ping tanto nuestro propio 
          interfaz como el interfaz remoto.</para></note>
 
      <para>A continuaci&oacute;n se configura la ruta por defecto hacia 
        nuestro enlace 6bone; observe que es muy semejante a lo que hay que
        hacer en IPv4:</para>

      <screen>&prompt.root; <userinput>route add -inet6 default -interface gif0</userinput>
&prompt.root; <userinput>ping6 -n <replaceable>MI_UPLINK</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>traceroute6 www.jp.FreeBSD.org</userinput>
(3ffe:505:2008:1:2a0:24ff:fe57:e561) from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms *
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</screen>

      <para>Esta captura de pantalla variar&aacute; dependiendo de la 
        localizaci&oacute;n de la m&aacute;quina.  Tras seguir estos pasos 
	deber&iacute;amos poder alcanzar el sitio IPv6 de <ulink 
         url="http://www.kame.net">www.kame.net</ulink> y ver la tortuga 
         bailarina, que es una imagen animada que s&oacute;lo se muestra cuando 
         se accede al servidor web utilizando el protocolo IPv6 (para
         ellos se encesita utilizar un navegador web que soporte IPv6, 
         IPv6, por ejemplo <filename 
          role="package">www/mozilla</filename> o 
         <application>Konqueror</application>, que forma parte de 
	 <filename role="package">x11/kdebase3</filename>, o tambi&eacute;n 
	 con <filename role="package">www/epiphany</filename>.</para>

    </sect2>

    <sect2>
      <title>DNS en el Mundo IPv6</title>

      <para>Existen dos tipos de registros de DNS para IPv6.  No 
        obstante el IETF ha declarado los registros A6 y CNAME como registros 
        para uso experimental.  Los registros de tipo AAAA son los 
        &uacute;nicos estandar a d&iacute;a de hoy.</para>

      <para>La utilizaci&oacute;n de registros de tipo AAAA es muy 
        sencilla.  Se asocia el nombre de la m&aacute;quina con la 
            direcci&oacute;n IPv6 de la siguiente forma:</para>

      <programlisting>NOMBREDEMIM&Aacute;QUINA AAAA   MIDIRECCI&Oacute;NIPv6</programlisting>

      <para>De igual forma que en IPv4 se utilizan los registros de tipo 
        A.  En caso de no poder administrar su propia zona de 
        <acronym>DNS</acronym> se puede pedir esta configuraci&oacute;n  a su 
        proveedor de servicios.  Las versiones actuales de 
        <application>bind</application> (versiones 8.3 y 9) y el 
        <quote>port</quote> <filename role="package">dns/djbdns</filename> 
        (con el parche de IPv6 correspondiente) soportan los registros de tipo 
        AAAA.</para>

    </sect2>
  </sect1>

  <sect1 id="network-atm">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Harti</firstname>
	  <surname>Brandt</surname>
	  <contrib>Escrito por </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>ATM en &os;&nbsp;5.X</title>

    <sect2>
      <title>Configuraci&oacute;n de IP cl&aacute;sico sobre ATM (PVCs)</title>

      <para>IP cl&aacute;sico sobre ATM (<acronym>CLIP</acronym>) es el 
        m&eacute;todo m&aacute;s sencillo de utilizar ATM con IP.  Se puede 
        utilizar con conexiones conmutadas (SVC) y con conexiones 
        permanentes (PVCs).  En esta secci&oacute;n se describe c&oacute;mo 
        configurar una red basada en PVCs.</para>

      <sect3>
	<title>Configuraciones en Red Mallada Completa</title>

        <para>El primer m&eacute;todo para configurar <acronym>CLIP</acronym> 
          con PVCs consiste en conectar unas m&aacute;quinas con otras mediante 
          circuitos PVC dedicados.  Aunque la configuraci&oacute;n parece 
          sencilla llega a resultar imposible de manejar cuando se posee un 
          n&uacute;mero grande de m&aacute;quinas.  El ejemplo que se muestra 
          a continuaci&oacute;n supone que nuestra red posee cuatro 
          m&aacute;quinas y que cada una se conecta a la red ATM mediante una 
          tarjeta de red ATM.  El primer paso consiste en planificar las 
          direcciones IP y las conexiones ATM que se van a configurar en las 
          m&aacute;quinas.</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>M&aacute;quina</entry>
		<entry>Direcci&oacute;n IP</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.1</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.2</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.3</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostD</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.4</hostid></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Para construir una red completamente mallada necesitamos una 
          conexi&oacute;n ATM entre cada par de m&aacute;quinas:</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>M&aacute;quinas</entry>
		<entry>Pareja VPI.VCI</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostB</hostid></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Los valores VPI y VCI en cada extremo de la conexi&oacute;n 
          pueden ser diferentes pero por simplicidad suponemos que son 
          iguales.  A continuaci&oacute;n necesitamos configurar las 
          interfaces ATM en cada m&aacute;quina:</para>

	<screen>hostA&prompt.root; ifconfig hatm0 192.168.173.1 up
hostB&prompt.root; ifconfig hatm0 192.168.173.2 up
hostC&prompt.root; ifconfig hatm0 192.168.173.3 up
hostD&prompt.root; ifconfig hatm0 192.168.173.4 up</screen>

        <para>Suponiendo que la interfaz ATM es 
	  <devicename>hatm0</devicename> en todas las m&aacute;quinas.  Ahora 
          necesitamos configurar los PVCs en las m&aacute;quinas (suponemos que 
          ya se han configurado de forma correcta en el <quote>switch</quote> 
          ATM, para lo cual puede ser necesario consultar el manual del 
          <quote>switch</quote>).</para>

	<screen>hostA&prompt.root; atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA&prompt.root; atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA&prompt.root; atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB&prompt.root; atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB&prompt.root; atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB&prompt.root; atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC&prompt.root; atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC&prompt.root; atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC&prompt.root; atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD&prompt.root; atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD&prompt.root; atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD&prompt.root; atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</screen>

        <para>Por supuesto que se pueden utilizar otras especificaciones 
          de tr&aacute;fico siempre y cuando las tarjetas de red las 
          soporten.  En este caso la especificaci&oacute;n del tipo de 
          tr&aacute;fico se completa con los par&aacute;metros del 
	  tr&aacute;fico.  Puede acceder a la ayuda de &man.atmconfig.8; 
          as&iacute;:</para>

	<screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

	<para>y por supuesto en la p&aacute;gina de manual de 
	  &man.atmconfig.8;.</para>

        <para>Se puede crear la misma configuraci&oacute;n utilizando el 
	  fichero <filename>/etc/rc.conf</filename>. Para la m&aacute;quina 
	  <hostid>hostA</hostid> ser&iacute;a algo as&iacute;:</para>

<programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

        <para>El estado de todas las rutas
          <acronym>CLIP</acronym> se puede obtener en todo momento 
	  con:</para>

	<screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

<!--  LocalWords:  config mnt www -->
