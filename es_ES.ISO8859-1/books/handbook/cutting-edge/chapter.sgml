<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Restructured, reorganized, and parts updated by </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Original work by </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
  </chapterinfo>

  <title>Lo &uacute;ltimo de lo &uacute;ltimo</title>

  <sect1>
    <title>Sin&oacute;psis</title>

    <para>&os; est&aacute; en desarrollo continuo entre versiones. Para los 
      que quieran estar en lo &uacute;ltimo de lo &uacute;ltimo, hay varias 
      formas de sincronizar tu sistema con el &uacute;ltimo desarrollo 
      f&aacute;cilmente.  &#161;Est&aacute;s advertido&mdash; lo &uacute;ltimo 
      de lo &uacute;ltimo no es para cualquiera!
      Este cap&iacute;tulo te ayudar&aacute; a decidir si quieres seguir el 
      sistema de desarrollo o quedarte en algunas  de las  versiones publicadas.</para>

    <para>Despu&eacute;s de leer este cap&iacute;tulo sabr&aacute;s:</para>

    <itemizedlist>
      <listitem><para>La diferencia entre las dos ramas de desarrollo; 
        &os.stable; y &os.current;.</para>
      </listitem>
      <listitem><para>C&oacute;mo mantener tu sistema al d&iacute;a con
	  <application>CVSup</application>,
	  <application>CVS</application>, o
	  <application>CTM</application>.</para>
      </listitem>
      <listitem><para>C&oacute;mo reconstruir y reinstalar el sistema base 
        entero con <command>make world</command>.</para>
      </listitem>
    </itemizedlist>

    <para>Antes de leer este cap&iacute;tulo, deber&iacute;as:</para>

    <itemizedlist>
      <listitem><para>Disponer correctamente tu conexi&oacute;n de red (<xref
      linkend="advanced-networking">).</para>
      </listitem>
      <listitem><para>Saber c&oacute;mo instalar programas adicionales de 
        terceros. (<xref linkend="ports">).</para></listitem>
    </itemizedlist>
  </sect1>
  
  <sect1 id="current-stable">
    <title>&os.current; vs. &os.stable;</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Hay dos ramas de desarrollo de FreeBSD; &os.current; y &os.stable;. Esta 
      secci&oacute;n explicar&aacute; un poco sobre cada una y describir&aacute; 
      c&oacute;mo mantener tu sistema al d&iacute;a entre cada &aacute;rbol respectivo.
      &os.current; ser&aacute; discutida  primero, luego &os.stable;.</para>

    <sect2 id="current">
      <title>Manteniendo la versi&oacute;n Current.</title>

      <para>Al leer esto, ten en cuenta que &os.current; es el 
        <quote>lo m&aacute;s reciente</quote> del desarrollo y que si t&uacute; 
        eres nuevo en &os;, deber&iacute;as pensartelo muy mucho antes de ejecutarlo.</para>

      <sect3>
	<title>&#191;Qu&eacute; es &os.current;?</title>
	<indexterm><primary>Instant&aacute;nea</primary></indexterm>

	<para>&os.current; es,  literalmente, nada m&aacute;s que una instant&aacute;nea 
          diaria sobre el trabajo en el c&oacute;digo fuente para el &os;. Esto incluye 
          trabajo cambiante, cambios experimentales y mecanismos transitorios que 
          podr&iacute;an estar o no presentes en la pr&oacute;xima versi&oacute;n del 
          programa. Mientras la mayor&iacute;a de nosotros compilamos casi a diario el 
          &os.current; las fuentes, Hay per&iacute;odos de tiempo en que las fuentes son 
          literalmente incompilables. Estos problemas son solucionados tan pronto como es 
          posible, pero si las fuentes del &os.current; son un desastre o una bendici&oacute;n 
          su utilidad puede ser literalmente una cuesti&oacute;n de en que momento del 
          per&iacute;odo de 24 horas dado las grabaste.</para>
      </sect3>

      <sect3>
	<title>&#191;Qui&eacute;n necesita&os.current;?</title>

	<para>&os.current; est&aacute; disponible generalmente para tres grupos de 
          inter&eacute;s principales:</para>

	<orderedlist>
	  <listitem>
	    <para>Miembros del grupo &os; que est&aacute;n activamente trabajando en 
              alguna parte del c&oacute;digo fuente del &aacute;rbol y para los que 
              mantenerse <quote>current</quote> es un requisito absoluto.</para>
	  </listitem>

	  <listitem>
	    <para>Miembros del &os; grupo que son activos probadores, con el prop&oacute;sito 
              de pasar tiempo trabajando en los problemas para asegurarse de que 
              &os.current; se mantiene tan cuerdo  como sea posible. Tambi&eacute;n 
              hay gente que desea hacer sugerencias t&iacute;picas en cambios y en la 
              direcci&oacute;n principal  del  &os;.</para>
	  </listitem>

	  <listitem>
	    <para>Miembros externos &os; o alg&uacute;n grupo que  desea mantener un 
              ojo en las cosas y usa las fuentes del  "current" por motivos de referencia
	      (reference) (Ej. para <emphasis>leer</emphasis>, no ejecutar). Estas personas 
              tambi&eacute;n hacen comentarios ocasionales o contribuyen al c&oacute;digo.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>&#191;Qu&eacute;  <emphasis>No</emphasis>  es    &os.current;?</title>

	<orderedlist>
	  <listitem>
	    <para>Un r&aacute;pido sistema de seguimiento para conseguir pre-distribuciones porque has oido que hay alguna nueva funcionalidad interesante dentro y quieres ser el primero del barrio en tenerla.</para>
	  </listitem>

	  <listitem>
	    <para>Un sistema r&aacute;pido de tener los fallos solucionados.</para>
	  </listitem>

	  <listitem>
	    <para>En ning&uacute;n caso  <quote>asistencia  oficial</quote> por nuestra parte.
	      Nosotros nos esforzamos sinceramente  en ayudar a la gente en alguna de las tres situaciones.

	    Nosotros  <quote>habilitamos</quote> &os.current; pero simplemente <emphasis>no tenemos tiempo</emphasis> para dar asistencia t&eacute;cnica.  Esto no es porque seamos de alguna forma mala gente que no quiere ayudar a los dem&aacute;s (ni siquiera estar&iacute;amos haciendo &os; si lo fueramos), es simplemente  porque no podemos responder 400 mensajes al d&iacute;a
	      <emphasis>y</emphasis> en realidad trabajamos en FreeBSD!  Si nos dan a escoger entre mejorar el &os; y responder montones de preguntas, la mayor&iacute;a de los desarrolladores y usuarios, problamente opten por lo primero.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Usando &os.current;</title>
      
	<orderedlist>
	  <listitem>
	    <para>Unirse a  &a.current; y al &a.cvsall; .  No es s&oacute;lo una buena idea, es <emphasis>esencial</emphasis>.  Si no est&aacute;s en el  <emphasis>&a.current;</emphasis>,
	       no ver&aacute;s los comentarios que la gente hace sobre la situaci&oacute;n del sistema current  y por esto probablemente terminar&aacute;s  tropezando con  un mont&oacute;n de problemas que otros ya han encontrado y solucionado.  Casi m&aacute;s importante, te perder&aacute;s importantes boletines que podr&iacute;an ser fundamentales para la continuidad de la salud de tu sistema.</para>

	    <para>La lista de correo&a.cvsall;  te permitir&aacute; ver el apunte en el registro de "commits"
	      por cada cambio que se realice junto con informaci&oacute;n pertinente sobre posibles efectos secundarios.</para>

	    <para>Para unirte a estas listas, env&iacute;a un correo a &a.majordomo; and
	      indicando lo siguiente en el cuerpo  del mensaje:</para>

	    <programlisting>subscribe freebsd-current
subscribe cvs-all</programlisting>
            <indexterm>
              <primary><application>majordomo</application></primary>
            </indexterm>

	    <para>Opcionalmente,puedes tambi&eacute;n poner<literal>help</literal>
	      y Majordomo te enviar&aacute; ayuda completa sobre como suscribirse o desuscribirse a las varias listas de correo que asistimos.</para>
	  </listitem>

	  <listitem>
	    <para>Graba las fuentes desde <hostid
	      role="fqdn">ftp.FreeBSD.org</hostid>.  Puedes hacer esto de varias maneras:</para>

	    <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>
              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>
              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>Syncing with CVSup</secondary>
	      </indexterm>

	      <listitem>
		<para>Usa el programa cvsup con este  <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/share/examples/cvsup/standard-supfile">
		  supfile</ulink>.  Este es el  m&eacute;todo m&aacute;s recomendable, ya que te permite grabar la colecci&oacute;n entera una vez y a partir de entonces s&oacute;lo lo que cambie desde entonces.Mucha gente ejecuta   <command>cvsup</command> from 
		  <command>cron</command> y mantiene actualizadas sus fuentes autom&aacute;ticamente. Tienes que adaptar la muestra de supfile de arriba y configurar 
cvsup a tu entorno.Si quieres ayuda para hacer esta configuraci&oacute;n, teclea: </para>
<screen>&prompt.root; <userinput>pkg_add -f
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/All/cvupit-3.0.tgz</userinput></screen>
	      </listitem>
              <indexterm>
	        <primary>-CURRENT</primary>
	        <secondary>Bajarlo con FTP</secondary>
	      </indexterm>

	      <listitem>
		<para>Usa <command>ftp</command>.  El c&oacute;digo fuente del &aacute;rbol del
		  &os.current; est&aacute; siempre <quote>exportado</quote> en:
		  <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/">ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/</ulink>.
		  Algunos de nuestros servidores FTP tambi&eacute;n permiten  grabar los &aacute;rboles enteros comprimidos/tarred.  ej. Mira:</para>

		<screen>usr.bin/lex</screen>

		<para>Puedes hacer lo siguiente para conseguir el directorio completo como un archivo tar:</para>

		<screen><prompt>ftp&gt;</prompt> <userinput>cd usr.bin</userinput>
<prompt>ftp&gt;</prompt> <userinput>get lex.tar</userinput></screen>
	      </listitem>



              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>Syncing with CTM</secondary>
	      </indexterm>
	      <listitem>
		<para>Usa  la aplicaci&oacute;<application>
		  CTM</application>. Si tienes muy mala conexi&oacute;n (conexiones caras o s&oacute;lo acceso para correo electr&oacute;nico) <application>CTM</application>es una opci&oacute;n.
		  Sin embargo es muy complicado y puede darte archivos  rotos.
		  Por eso se usa raramente, lo que incrementa la posibilidad de que no funcione durante largos periodos de tiempo.  Te recomendamos usar 
		  <application>CVSup</application>
		  para cualquiera con un modem de 9600bps modem o una conexi&oacute;n m&aacute;s rapida.
		</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Si est&aacute;s grabando las fuentes para ejecutarlas y no s&oacute;lo  leerlas, entonces graba <emphasis>todo</emphasis> el &os.current;, no s&oacute;lo algunos trozos.  La raz&oacute;n es que varias partes de las fuentes dependen de actualizaciones de otros sitios, y tratar de compilar s&oacute;lo una proci&oacute; casi te garantiza meterte en problemas.</para>

	    <para>Antes de compilar &os.current;, lee con cuidado
	      <filename>Makefile</filename> en <filename>/usr/src</filename>
	     Deber&iacute;as al menos ejecutar un <link
	      linkend="makeworld">make world</link> la primera vez como parte del proceso de actualizaci&oacute;n.  Leer el  &a.current;
	      te mantendr&aacute; al d&iacute;a en otros procedimientos de arranque que a veces se convierten en necesarios cuando nos acercamos a la siguiente versi&oacute;n.</para>
	  </listitem>
	      
	  <listitem>
	    <para>&#161;Participa! Si estas usando &os.current;, queremos saber lo que tienes que decir sobre &eacute;l, especialmente si tienes sugerencias para mejoras o arreglos de fallos. Recibimos tus sugerencias con m&aacute;s entusiasmo si incluyes el c&oacute;digo correspondiente!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  
    <sect2 id="stable">
      <title>Manteniendo Stable con &os;</title>

      <sect3>
	<title>&#191;Qu&eacute; es  &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; es nuestra rama de desarrollo con la que hacemos las versiones principales.  Los cambios van a esta rama con un ritmo diferente, asumiendo que han ido primero a 
	  &os.current; para probarse.  Esta es <emphasis>aun</emphasis>
	  una rama de desarrolllo, aunque, y esto significa en cualquier momento, las fuentes de&os.stable; pueden o no ser adecuadas para un prop&oacute;sito determinado.  Es simplemente otro camino  en la ingenier&iacute;a del desarrollo, no un recurso para usuarios finales.</para>
      </sect3>

      <sect3>
	<title>&#191;Qui&eacute;n necesita &os.stable;?</title>

	<para>Si est&aacute;s interesado en seguir o en contribuir al proceso de desarrollo de FreeBSD, especialmente en lo relativo a la pr&oacute;xima<quote>point</quote> release de FreeBSD, entonces deber&iacute;as considerar seguir &os.stable;.</para>

	<para>Aunque es verdad que algunos arreglos de seguridad van tambien a la rama
	  &os.stable; , t&uacute; no <emphasis>necesitas</emphasis> seguir  &os.stable; para hacerlo. Cada notificaci&oacute;n  de seguridad de
	  FreeBSD explica como solucionar el problema en la versi&oacute;n que afecta.
	  <footnote><para>Esto no es del todo cierto.  No podemos continuar prestando asistencia para las viejas versiones de FreeBSD nunca m&aacute;s, aunque lo hayamos hecho durante a&ntilde;os.
  Para conocer la pol&iacute;tica de seguridad  de las viejas versiones de FreeBSD, por favor mira <ulink
  	    url="../../../../security/index.html">http://www.FreeBSD.org/security</ulink></para>
	  </footnote>
	  seguir una rama de desarrollo s&oacute;lo por razones de seguridad es seguramente tambi&eacute;n traer una gran cantidad de cambios no deseados.</para>

	<para>Aunque nosotros nos esforzamos para asegurar que la rama &os.stable; compila y funciona en cualquier ocasi&oacute;n, esto no puede garantizarse, ya que el c&oacute;digo es desarrollado en &os.current; antes de incluirlo en &os.stable;, m&aacute;s gente usa &os.stable; que &os.current;, asi que es inevitable que algunos errores se encuentren alguna vez en &os.stable; que no eran evidentes en &os.current;.</para>

	<para>Por estas razones, nosotros <emphasis>no</emphasis> recomendamos que sigas ciegamenteme &os.stable;, y  es especialmente importante que no actualices  algun servidor importante  a  &os.stable; sin probar primero el c&oacute;digo en tu entorno de desarrollo.</para>

	<para>Si no tienes los recursos para hacer esto entonces te aconsejamos que ejecutes la m&aacute;s reciente distribuci&oacute;n  de FreeBSD, y uses el mecanismo de actualizaci&oacute;n binaria entre distribuci&oacute;n y distribuci&oacute;n.</para>
      </sect3>

      <sect3>
	<title>Usando &os.stable;</title>
      
	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>&Uacute;nete a  &a.stable;.  Esto te mantendr&aacute; informado de las
	      dependencias de construcci&oacute;n que puedan aparecer en &os.stable;
	      o cualquier otra cuesti&oacute;n que requiera especial atenci&oacute;n.  Los desarrolladores har&aacute;n los anuncios en esta lista de correo cuando est&eacute;n contemplando  algun arreglo pol&eacute;mico o actualizaci&oacute;n, dando a los usuarios la oportunidad de responder  si tienen alguna cuesti&oacute;n que plantear respecto al cambio propuesto.</para>

	    <para>La lista de correo &a.cvsall; te permitir&aacute; ver el
	      apunte del commit log  para cada cambio tal como se hace junto con la posible informaci&oacute;n sobre los efectos secundarios.</para>

	    <para>Para apuntarse a estas listas, env&iacute;a un correo a &a.majordomo; y especifica lo siguiente en el cuerpo del mensaje:</para>

	    <programlisting>subscribe freebsd-stable
subscribe cvs-all</programlisting>

	    <indexterm>
        <primary><application>majordomo</application></primary>
      </indexterm>
	    <para>Opcionalmente, puedes indicar <literal>help</literal>
	      y  Majordomo te enviar&aacute; ayuda completa sobre como suscribirte y desuscribirte a las otras listas que mantenemos.</para>
	  </listitem>

	  <listitem>
	    <para>Si est&aacute;s instalando un nuevo sistema y quieres que sea lo m&aacute;s estable posible, puedes grabar simplemente la &uacute;ltima rama con la instant&aacute;nea m&aacute;s antigua de <ulink
	      url="ftp://releng4.FreeBSD.org/pub/FreeBSD/">ftp://releng4.FreeBSD.org/pub/FreeBSD/</ulink>
	      and install it like any other release.</para>

	    <para>Si ya estas usando una versi&oacute;n previa de &os;
	      y quieres actualizar via fuentes entonces puedes hacerlo f&aacute;cilmente desde <hostid role="fqdn">ftp.FreeBSD.org</hostid>.  Esto puede hacerse de tres maneras:</para>

	    <orderedlist>
	      <indexterm>

	        <primary>-STABLE</primary>
		<secondary>syncing with CVSup</secondary>
	      </indexterm>
	      <listitem>
		<para>Usa el programa cvsup con <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/share/examples/cvsup/stable-supfile">this
		  supfile</ulink>.  Este es el sistema recomendado, ya que te permite grabar la colecci&oacute;n entera una vez y a partir de entonces s&oacute;lo lo que cambie.  Algunos usan <command>cvsup</command> from 
		  <command>cron</command> para mantener las fuentes al d&iacute;a autom&acute;ticamente. 
Para una interface bastante sencilla para esto, simplemente teclea:</para>
	      
		<blockquote><screen>&prompt.root; <userinput>pkg_add -f ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CVSup/cvsupit.tgz</userinput></screen></blockquote>
	      </listitem>

	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>Bajandolo con FTP</secondary>
	      </indexterm>
	      <listitem>
		<para>Usa <command>ftp</command>.  Las fuentes de &aacute;rbol para el 
		  &os.stable; est&aacute;n siempre <quote>exported</quote> en:
		  <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-stable/">ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-stable/</ulink></para>

		<para>Algunos de nuestros servidores de FTP permiten tambien grabar los &aacute;rboles completos compressed/tarred.  ej. Mira:</para>

		<screen>usr.bin/lex</screen>

		<para>Puedes hacer lo siguiente para conseguir el directorio como archivo  tar:</para>

		<screen><prompt>ftp&gt;</prompt> <userinput>cd usr.bin</userinput>
<prompt>ftp&gt;</prompt> <userinput>get lex.tar</userinput></screen>
	      </listitem>
	    <indexterm>
<primary>-STABLE</primary>
<secondary>Sincronizaci&oacute;n mediante CTM</secondary>
</indexterm>
<listitem>
<para>Usa <application>
CTM</application>.
Si no tienes una conexi&oacute; r&aacute;pida y barata a Internet,este es el m&eacute;todo que deber&iacute;a considerar usar.
</para>
</listitem>
 </orderedlist>
	  </listitem>

	  <listitem>
	    <para>B&aacute;sicamente, si necesitas acceso r&aacute;pido bajo demanda  a la fuente y el ancho de banda no es una consideraci&oacute;n , usa
	 <command>cvsup</command> o <command>ftp</command>.
	      De otro modo, usa <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>compiling</secondary>
	  </indexterm>
	  <listitem>
	    <para>Antes de compilar&os.stable;, lee el
	    <filename>Makefile</filename> en <filename>/usr/src</filename>
	    con cuidado.  Deber&iacute;as al menos ejecutar un <link
	    linkend="makeworld">make world</link> la primera vez como parte del proceso de instalaci&acute;n.Leyendo el&a.stable; te mantendr&aacute; al d&iacute;a en los otros procedimientos de arranque que alguna vez pueden llegar a ser necesarios cuando nos acercamos a la siguiente versi&oacute;n.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Sincronizaci&oacute;n de su c&oacute;digo fuente</title>
    
    <para>Hay varias formas de usar una conexi&oacute;n de Internet (o de correo) para estar al d&iacute;a en cualquier area dada de las fuentes del proyecto &os;, o en todas las areas, dependiendo de lo que te interese.  Los servicios primarios que ofrecemos son Anonymous
      CVS, CVSup, y 
      CTM.</para>

    <warning>
      <para>Aunque es posible actualizar s&oacute;lo partes del c&oacute;digo fuente del arbol, el &uacute;nico procedimiento de actualizaci&oacute;n que prestamos es actualizar el arbol entero y recompilarlo a la vez junto al espacio del usuario (ej., todos los programas que se ejecutan en el espacio del usuario, tales como los que est&aacute;n en <filename>/bin</filename> y
        <filename>/sbin</filename>) y las fuentes del kernel.  Actualizar s&oacute;lo parte del c&oacute;digo fuente del arbol, s&oacute;lo el kernel, o s&oacute;lo el area de usuario trae a menudo problemas.Estos problemas pueden ir desde errores de compilaci&oacute;n hasta  kernel panics o corrupci&oacute;n de datos.</para>
    </warning>

    <indexterm><primary>anonymous CVS</primary></indexterm>
    <para><application>Anonymous CVS</application> and
      <application>CVSup</application> usa el modelo <emphasis>pull</emphasis>
      para actualizar las fuentes.  En caso de
      <application>CVSup</application> el usuario (o un
      <command>cron</command> script) invoca el programa
       <command>cvsup</command>, y este interactua con el servidor
      <command>cvsupd</command> en alg&uacute;n lugar para traer los archivos actualizados.  
Las actualizaciones que recibes lo est&aacute;n al minuto y t&uacute; las consigues cuando, y s&oacute;lo cuando, las quieras.
 Puedes f&aacute;cilmente restringir tus actualizaciones a los archivos o directorios que te interesen.
Las actualizaciones se crean sobre la marcha   por el servidor seg&uacute;n lo que tienes o quieras tener. 
 <application>Anonymous CVS</application> es bastante mas simple que CVSup que es s&oacute;lo una extensi&oacute;n de <application>CVS</application> que permite retirar  los cambios directamente desde un repositorio (repository) CVS remoto.
      <application>CVSup</application> puede hacer esto mucho m&aacute;s eficientemente, pero
      <application>Anonymous CVS</application> es m&aacute;s f&aacute;cil de usar.</para>

    <indexterm>
      <primary><command>CTM</command></primary>
    </indexterm>
    <para><application>CTM</application>, por otro lado, no compara las fuentes que tienes interactivamente con las del archivo master o de otro que retires..En vez de eso, un script que identifica los cambios en los archivos  se ejecuta varias veces al d&iacute;a en la maquina maestra CTM, cualquier cambio detectado, sellado  con una secuencia de n&uacute;meros y codificado para transmitirlo en correo ( s&oacute;lo en ASCII imprimible).
Una vez recibido, estos<quote>CTM deltas</quote> pueden ser  manipulados por  la utilidad
      &man.ctm.rmail.1; que autom&aacute;ticamente decodifica, verifica y aplica los cambios a la copia de las fuentes del usuario.
Este proceso es m&aacute;s eficiente que <application>CVSup</application>,
      y pone menos presi&oacute;n en nuestros recursos de servidor ya que es un modelo de 
      <emphasis>empujar</emphasis> en vez de  <emphasis>tirar </emphasis>.</para>

    <para>Hay otros  aspectos a tener en cuenta, por supuesto.  Si descuidadamente barres trozos de tu archivo, <application>CVSup</application>
      te detectar&aacute; y reconstruir&aacute; las porciones da&ntilde;adas.
      <application>CTM</application> no hace esto, y si borras alg&uacute;n trozo de las fuentes del &aacute;rbol
 (y no has hecho una copia de respaldo) entonces tendr&aacute;s que partir de cero
 ( desde el m&aacute;s reciente CVS
      <quote>base delta</quote>) y reconstruirlo todo con CTM o, con anoncvs, simplemente borrar&aacute; los malos bits (bad bits) y resincronizar&aacute;s</para>

    
  </sect1>

  <sect1 id="makeworld">
    <title>Uso de <command>make world</command></title>

    <indexterm>
      <primary><command>make world</command></primary>
    </indexterm>
    <para>Una vez que has sincronizado las fuentes de tu &aacute;rbol local con alguna versi&oacute;n determinada de&os; (&os.stable;, &os.current;, y asi)
      puedes usar las fuentes del &aacute;rbol para reconstruir el sistema.</para>

    <warning>
      <title>Haciendo una copia de respaldo</title>

      <para>Nunca se hace suficiente hincapi&eacute; sobre lo importante que es hacer una copia de respaldo de tu sistema <emphasis>antes</emphasis> de hacer esto.
	Aunque reconstruir  world  es (siempre que sigas estas instrucciones) una tarea f&aacute;cil de hacer, habr&aacute; veces que inevitablemente cometas errores, o cuando errores hechos por otros en las fuentes del  &aacute;rbol inutilice tu sistema haciendolo inarrancable.</para>

      <para>Aseg&uacute;rate de haber hecho una copia de respaldo.  Y ten un diskette de reparaci&oacute;n a mano. &#161;Probablemente no tengas nunca que usarlo, pero es mejor asegurarse que lamentarlo!</para>
    </warning>

    <warning>
      <title>Suscribete a la lista de correo correcta </title>

      <indexterm><primary>lista de correo</primary></indexterm>
      <para>Las ramas  &os.stable; and &os.current; son , por naturaleza,   <emphasis>en desarrollo </emphasis>.  La gente que contribuye a &os; son humanos, y los errores ocasionalmente ocurren.</para>

      <para>Algunos de estos errores pueden ser poco da&ntilde;inos, que s&oacute;lo causan que tu sistema imprima una nueva  se&ntilde;al de diagnostico.  O el cambio puede ser catastr&oacute;fico, e inutilizar tu sistema inarrancable o destruir tu sistema de archivos ( o algo peor).</para>

      <para>Si un problema como este ocurre, un <quote>heads up</quote> es enviado a la lista de correo apropiada, explicando la naturaleza del problema y a que sistema afecta.  Y un <quote>all
	clear</quote> anuncio  es enviado cuando el problema ha sido resuelto.</para>

      <para>Si intentas seguir &os.stable; o &os.current; y no lees la &a.stable; o la
	&a.current; respectivamente, entonces est&aacute;s buscando problemas.</para>
    </warning>

    <sect2>
      <title>Lee <filename>/usr/src/UPDATING</filename></title>

      <para>Antes de hacer nada mas, lee
	<filename>/usr/src/UPDATING</filename> (o el archivo equivalente dondequiera que tengas una copia del c&oacute;digo fuente).  Este archivo puede contener importante informaci&oacute;n sobre problemas que puedes encontrarte, o indicar el orden en que debes ejecutar ciertas ordenes.)
	Si <filename>UPDATING</filename> contradice algo que leas aqui, 
	<filename>UPDATING</filename> tiene preferencia.</para>

      <important>
	<para>Leer  <filename>UPDATING</filename> no es un sustituto aceptable a la suscripcion a la lista adecuada, como se describi&oacute; antes. Los dos requisitos son complementarios no exclusivos.</para>
      </important>
    </sect2>

    <sect2>
      <title>Comprueba <filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Examina los archivos 
	<filename>/etc/defaults/make.conf</filename> y
	<filename>/etc/make.conf</filename>.  El primero contiene algunas definiciones  por defecto &ndash; la mayor&iacute;a de las cuales ya se han comentado.  Para hacer uso de ellas cuando reconstruyas tu sistema desde las fuentes, a&ntilde;adelas a <filename>/etc/make.conf</filename>. Ten en cuenta que cualquier cosa que a&ntilde;adas a <filename>/etc/make.conf</filename> se usa cada vez que ejecutas <command>make</command>, as&iacute; que es una buena idea colocarles algo sensato para tu sistema.</para>

      <para>Un usario t&iacute;pico querr&aacute; probablemente copiar las l&iacute;neas 
	<makevar>CFLAGS</makevar> y
	<makevar>NOPROFILE</makevar> encontradas en
	<filename>/etc/defaults/make.conf</filename> a 
	<filename>/etc/make.conf</filename> y ponerles un comentario.</para>

      <para>Examina las otras definiciones (<makevar>COPTFLAGS</makevar>, 
	<makevar>NOPORTDOCS</makevar> y sucesivamente) y decide si son importantes para ti.</para>
    </sect2>

    <sect2>
      <title>Actualiza <filename>/etc/group</filename></title>

      <para>Este directorio <filename>/etc</filename> contiene una gran parte de la informaci&oacute;n sobre la configuraci&oacute;n de tu sistema ,asi como scripts que se ejecutan al iniciarse el sistema. Algunos de estos scripts cambian de versi&oacute;n en versi&oacute;n de FreeBSD.</para>

      <para>Algunos de estos archivos de configuraci&oacute;n son usados en el funcionamiento del d&iacute;a a d&iacute;a del sistema. En particular,
	<filename>/etc/group</filename>.</para>

      <para>Ha habido ocasiones durante la instalaci&oacute;n de
        <quote>make world</quote> que se ha supuesto la existencia de ciertos nombres de usuario  o grupos.
  Cuando se lleva a cabo una actualizacion es probable  que alguno de estos grupos no existan.
Esto causa problemas cuando actualizas. para>

      <para>El ejemplo m&aacute;s reciente de esto es cuando el grupo <quote/ppp/ 
	(llamado despues <quote/network/) fue a&ntilde;adido.  A los usarios les fall&oacute; el proceso de instalaci&oacute;n cuando part&iacute;an del subsistema
	<filename>ppp</filename> fueron instaladas usando un nombre de grupo inexistente (para ellas).</para>

      <para>La soluci&oacute;n es examinar 
	<filename>/usr/src/etc/group</filename> y  comparar su lista con la tuya.Si hay alg&uacute;n grupo en el nuevo archivo que no est&aacute;n en tu archivo entonces c&oacute;pialos encima.
 De la misma forma, deber&iacute;as renombrar cualquier grupo en <filename>/etc/group</filename> que tenga la misma GID pero un nombre diferente para aquellas en 
	<filename>/usr/src/etc/group</filename>.</para>

      <tip>
	<para>Si te sientes particularmente paranoico, puedes comprobar tu sistema para ver que archivos pertenecen al grupo que estas renombrando o borrando.</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>mostrar&aacute; todos los ficheros que pertenecen al grupo 
	  <replaceable>GID</replaceable> (que puede ser o un nombre de grupo o una ID num&eacute;rica de grupo).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Cambiando a modo Monousuario</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Puede que quieras compilar el sistema en modo monousuario.Aparte del beneficio obvio de hacer que las cosas vayan m&aacute;s  rapido ,
	reinstalar el sistema tocar&aacute; un mont&oacute;n de archivos importantes del sistema, todos los binarios standard del sistema, bibliotecas incluso  archivos y dem&aacute;s.

Cambiar estas cosas en un sistema en funcionamiento (especialmente si en ese momento hay usuarios activos en el sistema) es ganas de meterse en lios.</para>

      <indexterm><primary>modo multiusuario</primary></indexterm>
      <para>Otro m&eacute;todo es compilar el sistema en modo multiusuario y luego cambiar a modo monousuario para la instalaci&oacute;n.Si te gustar&iacute;a hacerlo de esta forma, simplemente retrasa los siguientes pasos hasta que hayas completado la construcci&oacute;n.</para>

      <para>Como superusuario, ejecuta </para>

      <screen>&prompt.root; <userinput/shutdown now/</screen>

      <para>desde un sistema en funcionamiento, al que cambiar&aacute; a modo monousuario.</para>

      <para>Alternativamente, reinicia el sistema, y en el boot promt, introduce la <option>-s</option> flag.  El sistema se reiniciar&aacute;  en modo monousuario.En el promt de la shell deber&iacute;as ejecutar:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Esto comprueba los  sistemas de archivos, remounts <filename>/</filename>
	lectura/escritura, mounts, todos los sistemas de archivos UFS referenciados en
	<filename>/etc/fstab</filename> y entonces hace los cambios indicados.</para>
    </sect2>

    <sect2>
      <title>Quita <filename>/usr/obj</filename></title>

      <para>Mientras algunas partes son reconstruidas ellas se colocan en directorios que (por defecto) estan bajo	<filename>/usr/obj</filename>.  Los directorios  shadow estos bajo 
	<filename>/usr/src</filename>.</para>

      <para>Puedes acelerar el proceso <quote>make world</quote> y posiblemente ahorrarte dolores de cabeza por las dependencias quitando este directorio tambi&eacute;n.</para>

      <para>Algunos archivos  bajo <filename>/usr/obj</filename> pueden tener colocada la se&ntilde;al inmutable (immutable flag set) (mira &man.chflags.1; para mas informaci&oacute;n)
	que deber&aacute; ser quitada primero.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2>
      <title>Recompilar la fuente</title>

      <sect3>
	<title>Guardando la salida (Output)</title>

	<para>Es una buena idea guardar la salida que obtienes cuando se ejecuta 
	  &man.make.1; en otro archivo. Si algo sale mal tendr&aacute;s una copia del mensaje de error.Aunque esto puede no ayudarte en el diagn&oacute;stico de que ha salido mal, puede ser &uacute;til si mandas tu problema a una de las listas de &os; .</para>

	<para>La forma m&aacute;s f&aacute;cil de hacer esto es usar la orden   &man.script.1;
	  , con un par&aacute;metro que indique el nombre del archivo donde guardar los datos de salida.Podr&iacute;as hacer esto inmediatamente antes de reconstruir  world, y luego teclear  <userinput>exit</userinput>
	  cuando el proceso ha terminado.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out	 
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>	  
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Si haces esto, <emphasis>no</emphasis> guardes el output en  <filename>/tmp</filename>.  Este directorio podria ser vaciado en el proximo arranque.
 Un lugar mejor para almacenarlo es en
	  <filename>/var/tmp</filename> (como en el ejemplo anterior) o
	  en  el directorio home de <username>root</username>.</para>
      </sect3>

      <sect3>
	<title>Compilar e instalar el Sistema Base (Base System)</title>

	<para>Debes estar en <filename>/usr/src</filename>
	  directory...</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(a menos que, por supuesto, tu c&oacute;digo fuente este en otra parte, en ese caso cambia a ese directorio).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Para reconstruir world utiliza el &man.make.1; command.  Esta orden  lee las instrucciones desde el <filename>Makefile</filename>,
          que describe como el programa que comprende el &os; debe ser reconstruido.</para>

	<para>El formato general de la l&iacute;nea de ordenes que teclear&aacute;s es como sigue: </para>

	<screen>&prompt.root; <userinput>make <option>-<replaceable/x/</option> <option>-D<replaceable>VARIABLE</replaceable></option> <replaceable>target</replaceable></userinput></screen>

	<para>En este ejemplo, <option>-<replaceable>x</replaceable></option>
	  es una opci&oacute;n que pasar&iacute;as a  &man.make.1;. Mira la pagina del manual de 
	  &man.make.1; para un ejemplo de las opciones que puedes pasar.</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  pasa una variable a el <filename>Makefile</filename>.  El comportamiento de  <filename>Makefile</filename> esta controlado por esas variables.Estas son  las mismas variables   como estan colocadas en
	  <filename>/etc/make.conf</filename>, y esto proporciona otra forma de disponerlas.</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE=true <replaceable>target</replaceable></userinput></screen>

	<para>es otra forma de indicar que las bibliotecas  indicadas no se construyan, y corresponde con el </para>

	<programlisting>NOPROFILE=    true
#    Avoid compiling profiled libraries</programlisting>

	<para>Las l&iacute;neas en  <filename>/etc/make.conf</filename>.</para>

	<para><replaceable>target</replaceable> dicen a  &man.make.1; que quieres hacer. Cada <filename>Makefile</filename> define un n&uacute;mero de diferentes <quote>objetivos</quote>, y la elecci&oacute;n de esos objetivos determina lo que ocurre.</para>

	<para>Algunos objetivos estan listados en
	  <filename>Makefile</filename>, pero no significa que puedas ejecutarlos
	 En vez de eso, se usan por el proceso de consrucci&oacute;n para romper los pasos necesarios para reconstruir el sistema en un n&uacute;mero de sub-pasos.</para>

	<para>La mayor&iacute;a de las veces, no necesitas pasar ningun parametro a
	    &man.make.1;, y asi tu orden se parecer&aacute; a esto:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para>A partir de la versi&oacute;n 2.2.5 de &os; (en realidad, se cre&oacute; por primera vez en la &os.current; branch, y luego posteriormente colocado en
	  &os.stable; a mitad de camino entre 2.2.2 y  2.2.5) el objetivo (target)
	  <maketarget>world</maketarget> se ha dividido en dos.
	  <maketarget>buildworld</maketarget> y
	  <maketarget>installworld</maketarget>.</para>

	<para>Como el nombre implica, <maketarget>buildworld</maketarget>
	  construye un nuevo &aacute;rbol bajo <filename>/usr/obj</filename>,
	  y  <maketarget>installworld</maketarget>instala este &aacute;rbol  en una m&aacute;quina con la versi&oacute;n current.</para>

	<para>Esto es muy &uacute;til por dos motivos.Primero, te permite construir de forma segura, sabiendo que ning&uacute;n componente del sistema current ser&aacute; afectado.
	 La construcci&oacute;n es <quote>self hosted</quote>.  Por esto puedes con seguridad ejecutar <maketarget>buildworld</maketarget> en una m6aacute;quina funcionado en modo multiusuario sin miedo a efectos indeseados.Aunque aun es recomendable que ejecutes 
	
	  <maketarget>installworld</maketarget> en modo monousuario.</para>

	<para>En segundo lugar, permite usar NFS mounts para actualizar multiples m6aacute;quinas en tu red. Si tienes tres m&aacute;quinas, A, B y  C que quieres actualizar, ejecuta <command>make
	  buildworld</command> y <command>make installworld</command> en 
	  A.  B y  C deben luego mount NFS <filename>/usr/src</filename>
	  y <filename>/usr/obj</filename> desde  A, y puedes luego ejecutar
	  <command>make installworld</command> para instalar los resultados de
la construcci&oacute;n en B y C.</para>

	<para>Aunque el <maketarget>world</maketarget> target a&uacute;n exista,
	 se recomienda firmemente que no lo uses.</para>

	<para>Ejecutar</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>
 
        <para>Ahora es posible especificar un opci&oacute;n -j 
          <command>make</command> lo que provocar&aacute;  varios procesos simultaneos.
Esto es lo mas &uacute;til en m&aacute;quinas con multiples CPU.
Sin embargo, ya que el proceso de compilaci&oacute;n es IO bound 
          mas que CPU bound es tambi&eacute;n &uacute;til en m&aacute;quinas con una  s&oacute;la CPU.</para>

	<para>En una t&iacute;pica m&aacute;quina mono-CPU ejecutar&iacute;as:</para>
	  
	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; tendr&iacute;as mas de 4 procesos ejecutandose en cada momento.
La evidencia emp&iacute;rica comentada en las listas de correo muestran que esto da el mejor resultado.</para>

	<para>Si tienes una m&aacute;quina multi-CPU y estas usando  un kernel configurado SMP
	  prueba valores entre 6 y 10 y mira como se aceleran las cosas.</para>

	<para>Estas advertido de que esto es a&uacute;n experimental y que hacer commits al c&oacute;digo fuente del &aacute;rbol  puede ocasionalmente romper esta posibilidad.
Si world falla al compilar usando este par&aacute;metro intentalo de nuevo sin &eacute;l, antes de informar de los problemas. </para>
      </sect3>
      
      <sect3>
	<title>Momento (Timings)</title>
	<indexterm>
	  <primary><command>make world</command></primary>
	  <secondary>timings</secondary>
	</indexterm>

        <para>Muchos factores influyen en el tiempo de construcci&oacute;n, pero generalmente un Pentium 3 500 Mhz con 128 MB de RAM tardara 2 horas en construir el &aacute;rbol 
 &os.stable; , sin trucos  o cortes durante el proceso.
Un &aacute;rbol  &os.current;  tardar&aacute; algo mas.</para>
      </sect3>
    </sect2>
    
    <sect2>
      <title>Compilar e instalar un nuevo Kernel</title>
      <indexterm>
        <primary>kernel</primary>
	<secondary>compiling</secondary>
      </indexterm>

      <para>Para sacar el m&aacute;ximo provecho de nuestro sistema debemos recompilar el kernel.
Esto es pr&aacute;cticamente una necesidad, ya que ciertas estructuras de memoria podr&iacute;an haber cambiado y ciertos programas como &man.ps.1; y &man.top.1; fallar&aacute;n hasta que el kernel y la versiones del c&oacute;digo fuente sean la misma. </para>

      <para>El modo m&aacute;s simple y seguro de hacer esto es construir e instalar un kernel basado en <filename>GENERIC</filename>.  Mientras
	<filename>GENERIC</filename> puede no teer todos los dispositivos  necesarios para tu sistema, debe tener todo lo necesario para arrancar tu sistema de nuevo en modo monousuario.
  Esta es una buena prueba de que el nuevo sistema funciona correctamente.
Despu&eacute;s de hacer el arranque desde
	<filename>GENERIC</filename> y verificar que el sistema funciona puedes luego construir un nuevo kernel basado en el archivo de configuraci&oacute;n de tu kernel normal.</para>

      <para>Si estas actualizando de  &os; 4.0 a superior  entonces el procedimiento standard de construcci&oacute;n de kernel  (descrito <xref linkend="kernelconfig">)
	es desaconsejable.En vez de eso deber&iacute;as, ejecutar estas ordenes</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput></screen>

      <para>Si est&aacute;s actualizando a una versi&oacute;n de &os; por debajo de  4.0 usa el procedimiento de construcci&oacute;n standard del kernel.
 Sin embargo, se recomienda que uses una nueva versi&oacute;n de &man.config.8;, usando una l&iacute;nea de ordenes como esta.</para>
      
      <screen>&prompt.root; <userinput>/usr/obj/usr/src/usr.sbin/config/config <replaceable>KERNELNAME</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Arranca en Modo Usuario &Uacute;nico </title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Deber&iacute;as arrancar en modo usuario &uacute;nico para probar como funciona el nuevo kernel.Haz esto siguiendo las instrucciones en 
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2>
      <title>Instalar los Nuevos Binarios del Sistema </title>

      <para>Si estuvieses construyendo una version de &os; suficientemente reciente como para haber usado  <command>make buildworld</command> entonces deber&iacute;as usar ahora el 

	<maketarget>installworld</maketarget>para instalar el nuevo sistema de binarios.
 </para>

      <para>Ejecuta</para>

      <screen>&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Si especificaste variables en la l&iacute;nea de orden	  <command>make
	    buildworld</command> deber&iacute;as poner las mismas variables en la l&iacute;nea de orden de 
	 <command>make installworld</command> .
Esto no es necesariamente cierto para otras opciones; por ejemplo,
, <option>-j</option> nunca debe ser usada con 
	  <maketarget>installworld</maketarget>.</para>
	
	<para>Por ejemplo, si ejecutaste:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE=true buildworld</userinput></screen>

	<para>debes instalar los resultados con:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE=true installworld</userinput></screen>

	<para>de otro modo, instalar&iacute;a bibliotecas seleccionadas  que no hab&iacute;an sido construidas durante la fase <command>make buildworld</command>
	  .</para>
      </note>
    </sect2>

    <sect2>
      <title>Actualizaci&oacute;n de archivos no actualizados por <command>make world</command></title>
      
      <para>Rehacer el world no actualizar&aacute; ciertos directorios (en 
	particular, <filename>/etc</filename>, <filename>/var</filename> y
	<filename>/usr</filename>) con los archivos de configuraci&oacute;n nuevos o cambiados.</para>
      <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>El medio m&aacute;s simple para actualizar estos archivos es usar
        &man.mergemaster.8;, aunque es posible hacerlo manualmente si lo prefieres. Nosotros te recomendamos fervientemente usar &man.mergemaster.8;, aunque, si lo haces entonces puedes saltar a la siguiente secci&oacute;n <link linkend="update-dev"> </link>, puesto que &man.mergemaster.8; es muy simple de usar. 
Deber&iacute;as leer la p&aacute;gina del manual primero, y hacer una copia de respaldo de
        <filename>/etc</filename> por si algo va mal.</para>

      <para>Si deseas hacer la actualizaci&oacute;n manualmente no basta con que copies los archivos de
	<filename>/usr/src/etc</filename> a <filename>/etc</filename> y que funcione. Algunos de estos archivos deben ser <quote>instalados</quote>
	primero.  Esto es porque el  directorio<filename>/usr/src/etc</filename>
	<emphasis>no es </emphasis> una copia de lo que tu directorio 
	<filename>/etc</filename> deber&iacute;a parecer.  Adem&aacute;s, hay archivos que deber&iacute;an estar en <filename>/etc</filename> que no est&aacute;n en <filename>/usr/src/etc</filename>.</para>

      <para>El medio m&aacute;s sencillo de hacer esto a mano es instalar los archivos en un nuevo directorio y luego trabajar con ellos buscando las diferencias.</para>
    
      <warning>
	<title>Haz una copia de tu  existente <filename>/etc</filename></title>

	<para>Aunque en teor&iacute;a nada va a tocar este directorio autom&aacute;ticamente, es mejor estar seguros.  As&iacute; que copia tu existente <filename>/etc</filename> en lugar seguro.
	  Algo como:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para><option>-R</option> hace una copia recursiva , <option>-p</option>
	 almacena los tiempos, propiedad de los archivos y cosas as&iacute;.</para>
      </warning>
      
      <para>Necesitas construir el grupo de directorios que hagan el papel de / para instalar el nuevo 
	<filename>/etc</filename> y otros archivos dentro.
	<filename>/var/tmp/root</filename> es una elecci&oacute;n razonable, y tambi&eacute;n se requiere un n&uacute;mero de subdirectorios debajo de este.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Esto construir&aacute; la necesaria estructura de directorio e intalar&aacute; los archivos.Un mont&oacute;n de directorios que habr&aacute;n sido creados bajo
	<filename>/var/tmp/root</filename> estan vacios y deberan ser borrados.
	Una forma muy f6aacute;cil de hacerlo es:</para>
      
      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>
      
      <para>As&iacute; quitamos todos los directorios vacios.  (El error standard es redirigido a  <filename>/dev/null</filename> para prevenir las advertencias sobre directorios que no est&aacute;n vacios.) </para>

      <para><filename>/var/tmp/root</filename> ahora contiene todos los archivos que deber&iacute;an estar colocados en lugares adecuados bajo
	<filename>/</filename>.  Ahora tienes que ir a cada archivo y determinar cu&aacute;nto difieren de tus archivos exiting.
	</para>
    
      <para>Date centa que algunos de los archivos que se habr&aacute;n instalado en
	<filename>/var/tmp/root</filename> tienen un  leading <quote/./.  En el momento de escribir esta documentaci&oacute;n los &uacute;nicos archivos como estos son los archivos de inicio de la shell en 
	<filename>/var/tmp/root/</filename> y 
	<filename>/var/tmp/root/root/</filename>, aunque podr&iacute;a haber otros
	(dependiendo de cuando leas  esto.Asegurate de usar
	<command/ls -a/ para  capturarlos.</para>
    
      <para>El sistema m&aacute;s f&aacute;cil para hacerlo es usar &man.diff.1; para comparar los dos ficheros.</para>
    
      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>
      
      <para>Esto te mostrar&aacute; las diferencias entre tu archivo 
	<filename>/etc/shells</filename>y el nuevo archivo
	<filename>/etc/shells</filename> .  &Uacute;salos  para decidir si  fusionas con los cambios que hayas hecho o si lo copias encima de tu viejo archivo.</para>
    
      <tip>
	<title>Nombra el Nuevo Directorio de Root
	  (<filename>/var/tmp/root</filename>) con un  Sello temporal (time stamp), de esta forma puedes comparar f&aacute;cilmente las diferencias entre versiones </title>

	<para>Reconstruir frecuentemente el world significa que actualizas
	<filename>/etc</filename> tambien frecuentemente, lo que puede ser un poco pesado.</para>

	<para>Puedes acelerar este proceso manteniendo una copia del &uacute;ltimo grupo de archivos cambiados que hayas fusionado en <filename>/etc</filename>.
	  El siguiente metodo te da una idea de como hacer esto.</para>

	<procedure>
	  <step>
	    <para>Make the world como normal.  Cuando quieras actualizar 
	      <filename>/etc</filename>y los otros directorios, d&aacute;le al directorio de destino  un nombre basado en la fecha actual. Si estuvieses haciendo esto el 14 de Febrero de 1998 har&iacute;as lo siguiente.</para>
	  
	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>
	  
	  <step>
	    <para>A&ntilde;ade los cambios del directorio seg&uacute;n lo explicado arriba.</para>
	    
	    <para><emphasis>No</emphasis> quites el directorio 
	      <filename>/var/tmp/root-19980214</filename> cuando hayas acabado.</para>
	  </step>
	  
	  <step>
	    <para>Cuando hayas descargado la ultima versi&oacute;n de las fuentes y las hayas rehecho, sigue el paso 1.Esto te dar&aacute; un nuevo directorio, que podr&iacute;a llamarse
	      <filename>/var/tmp/root-19980221</filename> (si esperas una semana entre las actualizaciones).</para>
	  </step>
	  
	  <step>
	    <para>Tu puedes ahora ver las diferencias que se han hecho en esa semana intermedia usando &man.diff.1; puedes usar  diff para buscar recursivamente las diferencias entre los dos directorios.</para>
	      
	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>
	  
	    <para>T&iacute;picamente, este conjunto de diferencias ser&aacute;n m&aacute;s peque&ntilde;as que las que hay entre
	      <filename>/var/tmp/root-19980221/etc</filename> y 
	      <filename>/etc</filename>.  Como las diferencias son menores, es m&aacute;s f&aacute;cil enviar esos cambios  hasta tu directorio
	      <filename>/etc</filename> .</para>
	  </step>
	  
	  <step>
	    <para>Ahora puedes quitar el m&aacute;s viejo de los dos directorios
	      <filename>/var/tmp/root-*</filename>.</para>
	      
	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>
	  
	  <step>
	    <para>Repite el proceso cada vez que necesites a&ntilde;adir un cambio  a 
 <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>Puedes usar  &man.date.1; para automatizar la generaci&oacute;n de los nombres de directorio.</para>
	  
	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
    </sect2>
  
    <sect2 id="update-dev">
      <title>Actualiza <filename>/dev</filename></title>
      
      <note>
	<title>DEVFS</title>
        <indexterm><primary>DEVFS</primary></indexterm>
	<para>Si est&aacute;s usando DEVFS esto no ser&iacute;a necesario.</para>
      </note>

      <para>En la mayor&iacute;a de los casos, la herramienta  &man.mergemaster.8 se dar6aacute; cuenta cuando es necesario actualizar dispositivos y se ofrecer&aacute; a hacerlo autom&aacute;ticamente.
Estas instrucciones te dir&aacute;n como hacerlo manualmente.</para>
      
      <para>Por motivos de seguridad, este es un proceso con varios pasos.</para>

      <procedure>
	<step>
	  <para>Copia <filename>/var/tmp/root/dev/MAKEDEV</filename> en
	    <filename>/dev</filename>.</para>

	  <screen>&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>
	  <indexterm>
	    <primary><filename>MAKEDEV</filename></primary>
	  </indexterm>

          <para>Si usaste  &man.mergemaster.8; para actualizar <filename>/etc</filename>, entonces tu script
            <filename>MAKEDEV</filename> deber&iacute;a haberse actualizado ya, aunque no hace da&ntilde;o si lo compruebas  (con &man.diff.1;)y lo copias manualmente si fuese necesario.</para>
	</step>

	<step>
	  <para>Ahora, toma una instant&aacute;nea  de tu actual
	    <filename>/dev</filename>.  Esta instant&aacute;nea  necesita contener los permisos, propiedades, n&uacute;meros mayores y menores de cada archivo, pero no deber&iacute;a contener un sello temporal (time stamp) La forma m&aacute;s f&aacute;cil de hacerlo es usar  &man.awk.1; para sacar alguna informaci&oacute;n.</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
	</step>

	<step>
	  <para>Rehacer todos los dispositivos.</para>
	    
	    <screen>&prompt.root; <userinput/sh MAKEDEV all/</screen>
	</step>

	<step>
	  <para>Copia otra instant&aacute;nea  del directorio , esta vez en
	    <filename>/var/tmp/dev2.out</filename>.  Ahora mira entre esos dos archivos por si se te olvido crear algun dispositivo.  No deber&iacute;a haber ninguno, pero es mejor estar seguro que lamentarlo.</para>

	  <screen>&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>

	  <para>Podr&aacute;s detectar m&aacute;s f&aacute;cilmente discrepancias en las cuotas del disco que tienen que ver con mandatos  tales como
	  
	    <screen>&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput></screen>

	    Para recrear las entradas a las cuotas.  Tus circunstancias especificas pueden variar.</para>
	</step>
      </procedure>
    </sect2>
    
    <sect2>
      <title>Actualiza <filename>/stand</filename></title>
      
      <note>
	<para>Este paso se incluye para completar. Puede omitirse sin miedo.</para>
      </note>
      
      <para>Para terminar completamente , podr&iacute;as querer actualizar los archivos en
	<filename>/stand</filename> tan bien.  Estos archivos consisten en enlaces sostenidos (hard
	links) a el binario  <filename>/stand/sysinstall</filename>.  Este binario
	deber&iacute;a estar enlazado est&aacute;ticamente, para que pueda funcionar  cuando ning&uacute;n otro sistema de archivos (y en particular <filename>/usr</filename>)haya sido montado.</para>

      <screen>&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>
    
    <sect2>
      <title>Reinicio</title>
      
      <para>Ya esta hecho.  Despues de que hayas verificado que todo parece estar en el lugar adecuado puedes reiniciar el sistema.
Un simple&man.fastboot.8; lo har&aacute;.</para>

      <screen>&prompt.root; <userinput>fastboot</userinput></screen>
    </sect2>

    <sect2>
      <title>Finalizado</title>
      
      <para>Deber&iacute;as tener ahora tu sistema operativo actualizado con exito.
	Felicidades.</para>
      
      <para>Si las cosas fueron ligeramente mal, es facil reconstruir una parte del sistema. Por ejemplo, si accidentalmente borraste
        <filename>/etc/magic</filename> como parte de la actualizaci&oacute;n o al a&ntilde;adir algo a
        <filename>/etc</filename>, la orden (command) &man.file.1; dejara de funcionar.
En ese caso, el arreglo ser&iacute;a ejecutar:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput/make all install/</screen>
    </sect2>    
    
    <sect2>
      <title>Preguntas</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>&#191;Es necesario rehacer  world en cada cambio?</para>
	  </question>

	  <answer>
            <para>No hay una respuesta f&aacute;cil para esto, depende de la naturaleza del cambio.
	  Por ejemplo, si s&oacute;lo ejecutaste  CVSup, y mostr&oacute; las siguientes l&iacute;neas mientras se actualizaba ,</para>
      
	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>Probablemente no merezca la pena reconstruir world entero.
	      Puedes ir a los subdirectorios apropiados y 
	      <command>make all install</command>, y ya esta.  Pero si el cambio fue mayor, por ejemplo 
	      <filename>src/lib/libc/stdlib</filename> entonces deber&iacute;as o rehacer  world, o al menos aquellas de sus partes que estan est&aacute;ticamente unidas (asi como cualquier otra cosa que hayas a&ntilde;adido y que est&eacute; unida est&aacute;ticamente).</para>
      
	    <para>Es cuesti&oacute;n de que elijas.  Podr&iacute;as estar contento ejecutando  make world digamos cada quincena , y dejar que los cambios se acumulen hasta ese d&iacute;a.
	O quiz&aacute; quieras hacerlo s&oacute;lo a aquellas que hayan cambiado, y tengas confianza en haber comprobado todas las dependencias.</para>
      
	    <para>Y, por supuesto, todo esto depende de cada cu&aacute;nto tiempo actualices y si estas usando la versi&oacute;n stable o current.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>&#191;Cuando compilo falla con montones de se&ntilde;ales de error 11 (u otro n&uacute;mero de se&ntilde;al). &#191;Qu&eacute; ha ocurrido?</para>
	  </question>
    <indexterm><primary>senal 11</primary></indexterm>

	  <answer>

	    <para>Esto normalmente es una indicaci&oacute;n de problemas de m&aacute;quina.
Al ejecutar make world ((Re)making  world) se produce una sobrecarga del ordenador, que frecuentemente desencadena problemas de memoria.Esto se manifiesta cuando el compilador agoniza recibiendo se&ntilde;ales extra&ntilde;as.</para>
      
	    <para>Un indicador seguro de esto, es si puedes repetir el make y muere en un punto diferente del proceso. </para>
      
	    <para>En este cambio hay poco que puedas hacer excepto comenzar a probar los compenentes de tu m&aacute;quina para saber cual es el que falla.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>&#191;Puedo quitar  <filename>/usr/obj</filename> cuando he terminado?
</para>
	  </question>
	  
	  <answer>
	    <para>La respuesta corta es si.</para>
      
	    <para><filename>/usr/obj</filename> contiene todos los archivos binarios (object files)
que se produjeron durante la fase de compilaci&oacute;n.Normalmente, uno de los primeros pasos en el proceso  <quote/make world/ es quitar este directorio y hacer uno nuevo. En este caso, mantener
	      <filename>/usr/obj</filename> despu&eacute;s de haber terminado no tiene mucho sentido, y liberar&aacute;s un buen mont&oacute;n de espacio de disco (alrededor de 340MB).</para>
      
	    <para>Aunque, si sabes lo que haces puedes hacer que
	      <quote/make world/ se salte este paso.
Esto har&aacute; que la consiguiente construcci&oacute;n vaya m&aacute;s r&aacute;pido, ya que la mayor parte de las fuentes no necesitar&aacute;n recompilarse.
La parte molesta de esto es que pueden provocarse problemas de dependencias, haciendo que la construcci&oacute;n  falle de forma rara.
Esto genera alboroto en las listas de correo, cuando una persona se queja de que su construcci&oacute;n  ha fallado, sin darse cuenta de que es porque ha intentado acortar demasiado.</para>
      
	    <para>Si quieres vivir peligrosamente entonces haz make  world, pasando la definici&oacute;n   <makevar>NOCLEAN</makevar> , como esto:</para>

	    <screen>&prompt.root; <userinput>make -DNOCLEAN world</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>&#191;Puede continuarse una construcci&oacute;n interrumpida? </para>
	  </question>

	  <answer>
	    <para>Esto depende de como de lejos llegaste hasta encontar el problema.</para>

	    <para><emphasis>En general</emphasis> (y esto no es una regla fija)

	      El proceso <quote>make world</quote> construye nuevas copias de herramientas esenciales (como  &man.gcc.1;, y &man.make.1;) y el sistema de bibliotecas.
Estas herramientas y bibliotecas estan entonces instaladas.Las nuevas herramientas y bibliotecas son usadas para reconstruirse a si mismas, y son instaladas de nuevo.El sistema entero (incluyendo ahora programas normales como &man.ls.1; or &man.grep.1;)es entonces reconstruido con el nuevo sistema de archivos. </para>

	    <para>Si estas al final del proceso, y lo sabes (porque has mirado los resultados que estuviste guardando) entonces puedes (bastante seguramente) hacer </para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput></screen>

	    <para>Esto no deshar&aacute; el trabajo de los previos 
	      <quote>make world</quote>.</para>

	    <para>Si ves el mensaje 

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>
 en la salida <quote>make world</quote> entonces es probablemente bastante seguro hacer eso.</para>
	    
	    <para>Si tu no ves ese mensaje, o no estas seguro, entonces es siempre mejor estar seguro que lamentarse, y comenzar otra vez desde el principio.</para>
	  </answer>
	</qandaentry>

	<indexterm><primary>NFS</primary></indexterm>
	<qandaentry>
	  <question>
	    <para>&#191;Puedo usar una m&aacute;quina como<emphasis/master/ para actualizar montones de maquinas  (NFS)?</para>
	  </question>

	  <answer>
	    <para>Esto es una tarea bastante sencilla, y puede ahorrar horas de compilacion en muchas m&aacute;quinas.Simplemente ejecuta
	      <makevar>buildworld</makevar> en una m&aacute;quina central, y entonces NFS monta
               <filename>/usr/src</filename> y
	      <filename>/usr/obj</filename> en la m&aacute;quina remota y 
	      <makevar>installworld</makevar> alli.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>&#191;C&oacute;mo acelero  making the world?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Ejecuta en modo monousuario.</para>
	      </listitem>
	      
	      <listitem>
		<para>Pon <filename>/usr/src</filename> y
		  <filename>/usr/obj</filename> en sistemas de archivos diferentes en discos separados. Si es posible, pon esos discos en controladoras de discos separadas.</para>
	      </listitem>
	      
	      <listitem>
		<para>A&uacute;n mejor, pon esos sistemas de archivos a trav&eacute;s de multiples discos usando &man.ccd.4 </para>
	      </listitem>
	      
	      <listitem>
		<para>Desactiva el perfil (coloca <quote>NOPROFILE=true</quote> en <filename>/etc/make.conf</filename>).  Casi seguro que no lo necesitas.</para>
	      </listitem>
	      
	      <listitem>
		<para>Tambi&eacute;n en <filename>/etc/make.conf</filename>, coloca
		  <makevar>CFLAGS</makevar> a algo como <quote>-O
		  -pipe</quote>.  La optimizaci&oacute;n <quote>-O2</quote> es mucho m&aacute;s lenta y la diferencia de optimizaci&oacute;n entre <quote>-O</quote> y <quote>-O2</quote> es normalmente poco importante.
  <quote>-pipe</quote> permite que el compilador utilice tuberias (pipes) antes que archivos temporales lo que ahorra accesos al disco (a expensas de memoria). </para>
	      </listitem>
	      
	      <listitem>
		<para>Pon la opci&oacute;n  <option>-j&lt;n&gt;</option> para hacer que se ejecuten multiples procesos en paralelo.Esto ayuda se tenga un procesador o varios.</para>
	      </listitem>
	      
	      <listitem><para>El sistema de archivos que contiene
		  <filename>/usr/src</filename> puede ser montado ( o vuelto a montar)
con la opci&oacute;n 
<option>noatime</option> .  Esto evita al sistema de archivos el grabar la hora de acceso al archivo.
Probablemente no te haga falta esta informaci&oacute;n para nada.

		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>
		  
		  <warning>
		    <para>Este ejemplo supone que  <filename>/usr/src</filename> esta en su propio sistema de archivo.Si no est&aacute; (Por ejemplo, si es parte de <filename>/usr</filename> ) Entonces necesitar&aacute;s  el punto de montaje  de ese sistema de archivos, y no
		      <filename>/usr/src</filename>.</para>
		  </warning>
		</para>
	      </listitem>
	      
	      <listitem>
		<para>El sistema de archivos que contiene<filename>/usr/obj</filename> puede montarse (o volverse a montar) con la opci&oacute;n 
 <quote>async</quote>.
Esto hace que el disco escriba de modo as&iacute;ncrono.

		 En otras palabras,  el grabar se completa inmediatamente, y el dato es escrito en el  disco unos pocos segundos despu&eacute;s.Esto hace que las grabaciones se agrupen juntas  y puede ser una gran aceleraci&oacute;n  del funcionamiento.</para>

		<warning>
		  <para>Ten en cuenta que esta opci&oacute;n hace el sistema de archivos m&aacute;s fragil.Con esta opci&oacute;n hay un incremento de posibilidades, si la corriente falla, de que el sistemas de archivos sea irrecuperable cuando la m6aacute;quina se reinicie.</para>
	   
		  <para>Si <filename>/usr/obj</filename> es lo &uacute;nico en  este sistema de archivos entonces no hay problema.Si tienes otros datos valiosos entonces aseg&uacute;rate de tener copias recientes antes de habilitar esta opci&oacute;n.</para>
		</warning>
		
		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>
		
		<warning>
		  <para>Como arriba, si<filename>/usr/obj</filename>no est&aacute; en su propio sistema de archivos, reemplazalo en el ejemplo con el nombre del apropiado punto de montaje.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

     <qandaentry>
<question>
<para>&#191;Que&eacute; hago si algo sale mal?</para>
</question>
<answer>
<para>Asegurate de que tu entorno no tiene extra&ntilde;as cruft de construcciones anteriores.Esto es suficiente.</para>
<screen>
&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root;<userinput>rm -rf  /usr/obj/usr</userinput>
&prompt.root;<userinput>cd  /usr/src</userinput>
&prompt.root;<userinput> make cleandir</userinput>
&prompt.root;<userinput>make cleandir</userinput></screen>
<para>S&iacute; , <command>make cleandir</command> realmente deber&iacute;a ejecutarse dos veces.</para>
<para>Entonces comienza el proceso de nuevo, empezando con <command>make buildworld</command>.</para>
<para>Si a&uacute;n tienes problemas, env&iacute;a el error y la salida de <command>uname -a</command>a &a.questions;.
&#161;Prep&aacute;rate para contestar preguntas sobre tu setup</para>
</answer>
</qandaentry>
      </qandaset>
    </sect2>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->


