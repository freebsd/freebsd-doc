<!-- $Id: admin.sgml,v 1.3 1998-11-26 22:33:32 nik Exp $ -->
<!-- The FreeBSD Documentation Spanish Project -->
  <sect>
    <heading>Administracion de sistema<label id="admin"></heading>

    <sect1>
      <heading>Donde estan los ficheros de configuracion de arranque del sistema</heading>

      <p>De la version 2.0.5R a la 2.2.1R, el fichero principal de
      configuracion es <tt>/etc/sysconfig</tt>. Todas las opciones son
      especificadas en este fichero y otros como <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc" name="/etc/rc"> y
      <tt>/etc/netstart</tt>.

      <p>Mira en el fichero <tt>/etc/sysconfig</tt> y cambia los valores
      para tu sistema. Este fichero esta comentado para ayudar en la
      configuracion

      <p>En versiones posteriores a la 2.2.1 y 3.0 el fichero
      <tt>/etc/sysconfig</tt> fue renombrado como <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)" name="rc.conf">.
      La sintaxis tambien fue retocada para ser mas descriptiva. El fichero
      <tt>/etc/netstart</tt> tambien fue renombrado como
      <tt>/etc/rc.network</tt> para que todos los ficheros de configuracion
      puedan ser copiados con el comando <tt><htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?cp" name="cp"> /usr/src/etc/rc*
      /etc</tt>.

      <p><tt>/etc/rc.local</tt> existe como siempre y deberia ser usado
      para arrancar servicios locales adicionales como <htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^inn" name="INN"> o
      programas propios.

      <p>El fichero <tt>/etc/rc.serial</tt> es para la inicializacion
      de puertos serie.

      <p>El fichero <tt>/etc/rc.i386</tt> es para especificaciones propias
      de Intel, como la emulacion iBCS2 o la configuracion de la
      consola del sistema.

      <p>A partir de la version 2.1.0R, tambien puedes tener un directorio
      en el que instalar ficheros de arranque locales especificado en
      <tt>/etc/sysconfig</tt> (o <tt>/etc/rc.conf</tt>):

      <verb>
        # Location of local startup files.
        local_startup=/usr/local/etc/rc.local.d
      </verb>

      <p>Cada fichero acabado en <tt/.sh/ sera ejecutado en orden
      alfabetico.

      <p>Si quieres asegurarte de un cierto orden en la ejecucion sin tener
      que cambiar todos los nombres de los ficheros, puedes usar un esquema
      similar al siguiente con digitos al principio del nombre de cada
      fichero:

      <verb>
        10news.sh
        15httpd.sh
        20ssh.sh
      </verb>

      <p>Puede ser visto como "malo" (o SysV :-)) pero nos provee de un
      esquema regular para programas anyadidos localmente sin tener que
      hacer ediciones complicadas del fichero <tt>/etc/rc.local</tt>.
      Muchos de los ports/packages asumen que <tt>/usr/local/etc/rc.d</tt>
      es un directorio de arranque local.

    <sect1>
      <heading>Como anyado un usuario facilmente?</heading>

      <p>Usa el comando <htmlurl url="http://www.freebsd.org/cgi/man.cgi?adduser"
      name="adduser">.

      <p>Hay otro package llamado <tt/new-account/ escrito en Perl por
      Ollivier Robert. Pregunta a <tt>&lt;roberto@FreeBSD.ORG&gt;</tt>
      sobre el. En estos momentos esta en desarrollo.

      <p>Para borrar a un usuario, usa el comando <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rmuser" name="rmuser">.

    <sect1>
      <heading>Como puedo anyadir mi nuevo disco a FreeBSD?</heading>

      <p>La manera mas facil de hacer esto es desde el programa de
      instalacion. Puedes arrancar el programa de instalacion ejecutando
      <tt>/stand/sysinstall</tt> como root.

      <p>Alternativamente, si todavia tienes el floppy de instalacion,
      pueder arrancar desde el y usar el editor de etiquetas y
      particiones.

      <p><label id="2_1-disklabel-fix">Si lo anterior no te funciona o
      si eres masoquista total a quien le gustan los interfaces arcanos
      asi es como usar el programa
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel"> manualmente:

      <p><em>CUIDADO: Debes leer y entender perfectamente lo que estas
      haciendo!. Los comandos aqui descritos pueden BORRAR tu sistema.
      Procede con precaucion!. Recuerda, un BACKUP es tu amigo</em>.

      <p><tt/sysinstall/ insistira en montar algo en / en el editor de
      etiquetas de disco. Tendras que ejecutar manualmente
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel" name="disklabel"> antes
      de poder ejecutar
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?newfs" name="newfs">/.
      Esto significa que tendras que hacer tu mismo los calculos para las
      particiones. Mira si puedes obtener informacion del disco con
      <tt>disklabel -r &lt;diskname&gt;</tt> por ejemplo
      <tt>disklabel -r /dev/rwd0s2</tt> asumiendo que tu nuevo disco es
      wd0, el primer disco IDE, y FreeBSD es el segundo slice (s2). Deberias
      ver algo como esto:-


      <verb>
        # /dev/rwd0s2:
        type: ESDI
        disk: wd0s2
        label:
        flags:
        bytes/sector: 512
        sectors/track: 63
        tracks/cylinder: 64
        sectors/cylinder: 4032
        cylinders: 610
        sectors/unit: 2459520
        rpm: 3600
        interleave: 1
        trackskew: 0
        cylinderskew: 0
        headswitch: 0           # milliseconds
        track-to-track seek: 0  # milliseconds
        drivedata: 0

        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
          c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
          e:  2459520        0    4.2BSD        0     0     0   # (Cyl. 0 - 609)
      </verb>

      <p>Aegurate que el tamanyo es correcto, en este caso, 2459520
      sectores x 512 bytes/sector / 2**20 (1 Megabyte) = 1200 MB. El resto
      de datos (b/s, t/c, s/c, interleave, etc.) deberian funcionar con
      los que salen por defecto con <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel">, pero mira <ref id="ESDI" name="esta nota"> para
      discos antiguos. fsize es el <ref id="fsize" name="tamanyo de
      fragmento"> del sistema de ficheros y bsize es el
      <ref id="bsize" name="tamanyo de bloque">. 'c' es la particion que
      ocupa FreeBSD (o el disco completo en caso de una unica particion
      para FreeBSD), y debe quedar como esta. <em>No deberia ser usada
      para un sistema de ficheros</em>. La particion 'c' es magica en que
      es reconocida y usada por el kernel aunque no exista ninguna
      etiqueta en ella.

      <p>En el caso trivial de querer usar todo el sistema de ficheros
      para FreeBSD, la entrada para el campo "e" tiene que ser corregida
      poniendo fsize a 1023 y bsize a 8192 (8 fragmentos/bloque), los
      cuales son razonables. La entrada correcta para "e" seria:

      <verb>
        e:  2459520        0    4.2BSD     1024  8192
      </verb>

      <p>Ahora el caso mas complicado, donde queremos 2 particiones para
      2 sistemas de ficheros. Siguiendo la <ref id="fsname"
      name="convencion de nombres BSD">, las particiones seran
      <tt /wd0s2e/ y <tt /wd0s2f/. Supon que asignamos tenemos 1200MB y
      asignamos 300 para "e" y los restantes 900 para "f". Los datos de
      las particiones serian:

      <verb>
        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
        c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
        e:   614400        0    4.2BSD     1024  8192
        f:  1843200   614400    4.2BSD     1024  8192
      </verb>

      <p><bf /Nota:/ Puedes editar directamente el "disklabel" con
      ''<tt>disklabel -e wd0s2</tt>''. Para mas informacion mira en
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel">.

      <p>Si tienes la version 2.1.5 o superior, y quieres dedicar
      enteramente el disco para FreeBSD sin compartirlo con otros
      sistemas operativos, se pueden reducir las operaciones a
      realizar de la siguiente manera:

      <verb>
        # dd if=/dev/zero of=/dev/rwd0 count=100
        # disklabel -Brw wd0 auto
        # disklabel -e wd0
      </verb>

      <p>El primer comando <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?dd" name="dd"> asegura que
      no hay basura en el inicio del disco que pueda confundir al kernel.
      Lo siguiente a realizar es una generacion automatica de etiqueta
      usando los procesos por defecto ejecutados en el arranque del
      sistema. La edicion de la etiqueta continua de la manera descrita
      anteriormente.

      <p>Has acabado!. Ahora debes inicializar el sistema de ficheros
      con algo como:

      <verb>
        newfs -d0 /dev/rwd0s2e
        newfs -d0 /dev/rwd0s2f
      </verb>

      <p>Dependiendo del nombre del disco y la particion, quizas sea
      requerida la ejecucion del script <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?MAKEDEV" name="/dev/MAKEDEV">
      para la creacion de los dispositivos.

      <p>Y montar tus nuevos discos/particiones (mira el comando
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?mount" name="mount">)

      <verb>
        mount /dev/wd0s2e /mnt/foo
        mount /dev/wd0s2f /mnt/bar
      </verb>

      <p>Deberias editar el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fstab(5)" name="/etc/fstab">
      para montar automaticamente los discos/particiones al arrancar el
      sistema.

      <p><bf /Glosario:/

      <descrip>
        <tag><label id="fsize"><bf>Fragment Size (fsize)</bf></tag>
        Unidad basica de almacenamiento para <tt /ffs/.
        M. McKusick, W. Joy, S. Leffler, and R. Fabry,
        "A Fast File System for  UNIX",
        ACM Transactions on Computer Systems 2, 3, pp 181-197, August
        1984, (reprinted in the BSD System Manager's Manual, SMM:5) o
        <url url="file:/usr/share/doc/smm/05.fastfs/paper.ascii.gz"
        name="/usr/share/doc/smm/05.fastfs/paper.ascii.gz"> en tu sistema.

        <tag><label id="bsize"><bf>Block Size (bsize)</bf></tag>
        Un bloque se compone de uno o mas fragmentos. Mira la referencia
        correspondiente en:
        <url url="file:/usr/include/sys/disklabel.h"
        name="&lt;sys/disklabel.h&gt;">

        <tag><label id="ESDI">
        <bf>Disklabel Characteristics for Older Disks (ESDI)</bf></tag>
        Necesitaras dar mas informacion a<htmlurl 
        url="http://www.freebsd.org/cgi/man.cgi?disklabel"
        name="disklabel"> 
        si quieres usar un "disco verdadero". Necesitaras saber la
        geometria uniforme, cabezales reales, sectores y cilindros, como
        en los discos ESDI antiguos. Toda esta informacion deberia ser
        facilmente localizable en la cubierta del propio disco, manual, etc.

        <tag><label id="fsname">
        <bf>BSD Filesystem Naming Conventions</bf></tag>
        La particion 'a', por convencion, esta reservada para particiones
        'bootables' y la particion 'b' para swap. Las particiones regulares
        deben empezar en la 'd'. La particion 'e' corresponde a la primera
        particion no bootable y a usar como sistema de ficheros.

        <tag><label id="swap">
        <bf>Warning about swap space</bf></tag>
        El espacio requerido por la tabla de particion de BSD esta
        permitido en el sistema de ficheros. No empieces la particion
        swap en el cilindro 0.
      </descrip>

    <sect1>
      <heading>Tengo un nuevo disco removible, como lo uso?</heading>

      <p>Se trate de un disco removible como un ZIP o EA (o un floppy,
      si quieres usarlo de esta manera), o un nuevo disco duro, una vez
      instalado y reconocido por el sistema, y tengas tu
      cartridge/floppy/etc en su interior, las cosas son como para la
      mayoria de dispositivos.

      <p><label id="disklabel">(esta seccion esta basada en <url
      url="http://vinyl.quickweb.com/mark/FreeBSD/ZIP-FAQ.html"
      name="Mark Mayo's ZIP FAQ">)

      <p>Si es un disco ZIP o floppy, y esta formateado en DOS, puedes
      usar el comando:

      <verb>
        mount -t msdos /dev/fd0c /floppy
      </verb>

      <p>Si es un floppy, o este:

      <verb>
        mount -t msdos /dev/sd2s4 /zip
      </verb>

      <p>para un disco ZIP con la configuracion de fabrica.

      <p>Para otros discos, mira como configurados usando <tt/fdisk/ o
      <tt>/stand/sysinstall</tt>.

      <p>El resto de ejemplos seran para un disco ZIP en sd2, el tercer
      disco SCSI.

      <p>A no ser que se trate de un floppy o disco removible, lo que
      planeas compartir con otros usuarios, es aconsejable convertir
      el formato de ficheros a BSD. Obtendras nombre de ficheros largos,
      como minimo doblaras la velocidad de acceso del disco, y mucha mas
      estabilidad. Antes, necesitas rehacer las particiones. Puedes usar
      el comando <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fdisk"
      name="fdisk"> o la utilidad <tt>/stand/sysinstall</tt>. Si es un
      disco peque¤o que quieres dedicar enteramente a FreeBSD, solo
      tienes que eliminar la FAT y tabla de particiones, y usar el sistema
      de particiones de FreeBSD:

      <verb>
        dd if=/dev/zero of=/dev/rsd2 count=2
        disklabel -Brw sd2 auto
      </verb>

      <p>Puedes usar el comando disklabel (mas informacion en
      <ref id="2_1-disklabel-fix" name="esta nota">) o
      <tt>/stand/sysinstall</tt> para crear multiples particiones BSD.

      <p>Finalmente, crea un nuevo sistema de ficheros:

      <verb>
        newfs /dev/rsd2c
      </verb>

      <p>y montalo:

      <verb>
        mount /dev/sd2c /zip
      </verb>

      <p>Seria una buena idea anyadir una linea como esta en el fichero
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fstab"
      name="/etc/fstab"> para que solo tengas que teclear "mount /zip"
      las siguientes veces.

      <verb>
        /dev/sd2c /zip ffs rw,noauto 0 0
      </verb>

    <sect1>
      <heading>Como monto una particion secundaria DOS?</heading>

      <p>Las particiones DOS secundarias se encuentran despues de TODAS
      las particiones primarias. Por ejemplo, si tienes una particion
      "E" como la segunda particion DOS en el segundo disco SCSI, necesitas
      crear los ficheros especiales para el dispositivo 5 en /dev, y despues
      montar /dev/sd1s5:

      <verb>
        # cd /dev
        # ./MAKEDEV sd1s5
        # mount -t msdos /dev/sd1s5 /dos/e
      </verb>

    <sect1>
      <heading>Puedo montar otros sistemas de ficheros bajo FreeBSD?</heading>

      <p><bf/Digital UNIX/ UFS CDROMs pueden ser montados directamente
      en FreeBSD. Montar particiones de disco de Digital UNIX y otros
      sistemas que soportan UFS puede ser mas complejo, dependiendo de los
      detalles de la particion de disco del sistema operativo en cuestion.

      <p><bf/ Linux/: 2.2 y posteriores soportan particiones <bf/ext2fs/.
      Mira <htmlurl url="http://www.freebsd.org/cgi/man.cgi?mount_ext2fs"
      name="mount_ext2fs"> para mas informacion.

    <sect1>
      <heading>Como puedo usar el "NT loader" para arrancar FreeBSD?</heading>

      <p>La idea general es que copies el primer sector de la particion
      root nativa de FreeBSD en un fichero en la particion DOS/NT.
      Asumiento que nombras a ese fichero como <tt>c:&bsol;bootsect.bsd</tt>
      puedes editar el fichero <tt>c:&bsol;boot.ini</tt> para conseguir
      algo como esto:

      <verb>
        [boot loader]
        timeout=30
        default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
        [operating systems]
        multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
        C:\BOOTSECT.BSD="FreeBSD"
        C:\="DOS"
      </verb>

      <p>Este proceso asume que DOS, NT, FreeBSD o cualquier otro sistema
      ha sido instalado en sus respectivas particiones en el mismo disco.
      En nuestro caso, DOS y NT estan en la primera particion y FreeBSD
      en la segunda. Instalamos FreeBSD para arrancarlo desde su particion
      nativa y no desde el disco MBR.

      <p>Monta un floppy formateado en DOS bajo la particion <tt>/mnt</tt>.

      <verb>
        dd if=/dev/rsd0a of=/mnt/bootsect.bsd bs=512 count=1
      </verb>

      <p>Rearranca en DOS o NT. Copia el fichero <tt/bootsect.bsd/ y/o el
      fichero <tt/bootsect.lnx/ del floppy a <tt/C:&bsol;/. Modifica los
      atributos a <tt/boot.ini/ con:

      <verb>
        attrib -s -r c:\boot.ini
      </verb>

      <p>Edita y anyade las lineas apropiadas del boot.ini mostrado
      enteriormente de ejemplo, y vuelve a poner los atributos originales:

      <verb>
        attrib -r -s c:\boot.ini
      </verb>

      <p>Si FreeBSD esta arrancando desde el MBR, restauralo desde el
      comando <tt/fdisk/ despues de reconfigurarlos para arrancar desde
      sus particiones nativas.

    <sect1>
      <heading>
        Como arranco FreeBSD y Linux desde LILO?
      </heading>
      
      <p>Si tienes FreeBSD y Linux en el mismo disco, solo tienes que seguir
      las instrucciones de instalacion de LILO para arrancar un sistema
      operativo no Linux. Brevemente, son estas:

      <p>Arranca Linux, y anyade las siguientes lineas en el fichero
      <tt>/etc/lilo.conf</tt>:
      <verb>
      other=/dev/hda2
              table=/dev/hda
              label=FreeBSD
      </verb> 
      (Asumiendo que tu particion FreeBSD es conocida por Linux como
      <tt>/dev/hda2</tt>). A continuacion, ejecuta <tt>lilo</tt> como root
      y ya deberia estar.

      <p>Si FreeBSD esta en otro disco, necesitas anyadir 
      ``<tt>loader=/boot/chain.b</tt>'' al fichero <tt>lilo.conf</tt>. Por
      ejemplo:
      <verb>
      other=/dev/sdb4
              table=/dev/sdb
              loader=/boot/chain.b
              label=FreeBSD
      </verb> 

      <p>En algunos casos necesitaras especificar el numero de disco en BIOS
      para que el cargador del boot funcione correctamente desde el segundo
      disco. Por ejemplo, si tu disco SCSI con FreeBSD es visto por la BIOS
      como disco 1, en el prompt del cargador de arranque necesitaras
      especificar:
      <verb>
      Boot: 1:sd(0,a)/kernel
      </verb>

      <p>En FreeBSD 2.2.5 y posteriores, puedes configurar <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?boot(8)" name="boot(8)">
      para que haga esto automaticamente.

     <p>El <htmlurl
     url="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html"
      name="Linux+FreeBSD mini-HOWTO"> es una buena referencia para
      las opciones de interoperabilidad entre FreeBSD y Linux.

    <sect1>
      <heading>
        Como arranco FreeBSD y Linux usando BootEasy?
      </heading>
  
      <p>Instala el LILO al inicio de la particion de arranque del Linux en
      lugar de hacerlo en el "Master Boot Record". Asi podras arrancar el
      LILO desde BootEasy.

      <p>Si estas usando Windows-95 y Linux, tambien es recomendable hacer
      esto para simplificar el arranque de Linux en caso de que sea necesaria
      una reinstalacion del Windows-95 (ya que no quiere convivir con otros
      sistemas operativos en el mismo Master Boot Record).

    <sect1>
      <heading>
        Puede un disco "dedicado" provocar problemas?
      </heading>

      <p><label id="dedicate">El proceso de instalacion nos permite elegir
      dos metodos diferentes de particionar un disco. El sistema por defecto
      hace que el disco sea compatible con otros sistemas operativos en
      la misma maquina, usando las tablas de entrada de fdisk (llamadas
      "slices" en FreeBSD). Opcionalmente, podemos instalar un
      boot-selector que nos permite seleccionar el sistema operativo con
      el que queremos arrancar.

      <p>Mientras este es el caso mas comun para gente proveniente del
      mundo de PC, para la gente proveniente del mundo Unix y quienes
      quieren instalar una maquina para funcionar con FreeBSD y solo
      FreeBSD, es mas habitual usar el sistema de reservar todo el
      espacio del disco para un solo sistema operativo.
      Si seleccionas "A)ll FreeBSD" en el editor de fdisk de la utilidad
      sysinstall, y respondes la siguiente pregunta con "No", usaras
      este ultimo sistema. Ten en cuenta que usando este sistema no te
      permitira la instalacion de ningun otro sistema operativo o
      selector de arranque (boot manager).

      <p>Entonces, por que se llama "peligroso"?. Un disco en este modo
      no contiene lo que las utilidades normales de un PC considerarian
      una tabla de particion de ficheros valida. Dependiendo del disenyo
      de estas aplicaciones, puede que danyen el sector de arranque una
      vez entren en contacto con el disco. Por lo menos una BIOS Award
      usada en por maquinas HP Netservers (pero no solo por ellos) es
      concocida por ignorar los disco duros que no contengan lo que la
      BIOS entiende por una tabla de ficheros valida.

      <p>Para volver un disco "peligrosamente dedicado" a formato
      estandard de PC, hay basicamente dos opciones. La primera es,
      escribes suficientes bytes NULL sobre el MBR para hacer que
      las siguientes instalaciones crean que estan en un disco sin
      usar. Puedes hacer esto asi:

      <verb>
        dd if=/dev/zero of=/dev/rsd0 count=15
      </verb>

      <p>Alternativamente, puedes hacer:

      <verb>
        fdisk /mbr
      </verb>

      <p>que instalara un nuevo master boot record.

    <sect1>
      <heading>Como puedo anyadir mas espacio de swap?</heading>

      <p>La mejor manera es incrementar el tamanyo de tu particion de
      swap, o usar esta excusa para anyadir un otro disco nuevo (mira
      <ref id="swap" name="esta nota"> si lo haces).

      <p>Anyadir swap en discos separados hace las cosas mas rapidas
      que simplemente anyadir swap en el mismo disco. Como ejemplo,
      si estas compilando codigo fuente en un disco, y el swap esta
      en otro disco, es mucho mas rapido que si el swap y la
      compilacion se realizaran en el mismo disco. Esto es cierto
      especificamente para disco SCSI.

      <p>Disco IDE no son capaces de permitir el acceso a ambos discos
      en el mismo canal al mismo tiempo (FreeBSD no soporta el modo 4, ya
      que todas las I/O de discos IDE con "programadas").

      <p>Es realmente muy mala idea instalar el swap sobre NFS a no ser que
      trabajes en una red muy rapida con un muy buen servidor.

      <p>Aqui hay un ejemplo para un fichero de swap de 64Mb
      <tt>/usr/swap0</tt>, piensa que puedes usar el nombre que quieras).

      <p>Asegurate que el kernel esta compilado con la linea

      <verb>
        pseudo-device   vn 1   #Vnode driver (turns a file into a device)
      </verb>

      <p>en tu fichero de configuracion. El kernel GENERIC la contiene. 

      <enum>
        <item>crea un vn-device

        <verb>
          cd /dev
          sh ./MAKEDEV vn0
        </verb>

        <item>crea un swapfile (<tt>/usr/swap0</tt>)

        <verb>
          dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
        </verb>

        <item>activa el fichero de swap en <tt>/etc/rc.conf</tt>

        <verb>
          swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </verb>

        <item>rebota la maquina.
      </enum>

      <p>Para activar el fichero de swap inmediatamente teclea

      <verb>
        vnconfig -ce /dev/vn0c /usr/swap0 swap
      </verb>

    <sect1>
      <heading>Tengo problemas para poner en marcha mi impresora.</heading>

      <p>Por favor, revisa la seccion de impresoras del manual. Cubre la
      mayoria de posibles problemas. Pasate por
      <url url="../../handbook/printing.html" name="esta seccion.">

    <sect1>
      <heading>Mi teclado no coincide con los caracteres de pantalla.</heading>

      <p>El programa de control de teclado tiene una opcion para cargar
      el mapa de teclado. En el directorio <tt>/usr/share/syscons/keymaps</tt>
      hay diferentes ficheros de mapas de teclado. Selecciona el que
      corresponde a tu sistema y cargalo.

      <verb>
        kbdcontrol -l uk.iso
      </verb>

      <p>Tanto el directorio <tt>/usr/share/syscons/keymaps</tt> como la
      extension <tt/.kbd/ son asumidas por la orden
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?kbdcontrol"
      name="kbdcontrol">.

      <p>Esto puede ser configurado en <tt>/etc/sysconfig</tt> (o <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)" name="rc.conf">).
      Mira los comentarios correspondientes en el propio fichero.

      <p>En la version 2.0.5R y posteriores, todo lo referente a fuentes,
      teclado, etc esta en <tt>/usr/share/examples/syscons</tt>.

      <p>Actualmente se soportan los siguientes mapas de teclado:

      <itemize>
        <!-- generate by `kbdmap -p' -->
        <item>Belgian ISO-8859-1 
        <item>Brazilian 275 keyboard Codepage 850 
        <item>Brazilian 275 keyboard ISO-8859-1 
        <item>Danish Codepage 865 
        <item>Danish ISO-8859-1 
        <item>French ISO-8859-1 
        <item>German Codepage 850 
        <item>German ISO-8859-1 
        <item>Italian ISO-8859-1 
        <item>Japanese 106 
        <item>Japanese 106x 
        <item>Latin American 
        <item>Norwegian ISO-8859-1 
        <item>Polish ISO-8859-2 (programmer's) 
        <item>Russian Codepage 866 (alternative) 
        <item>Russian koi8-r (shift) 
        <item>Russian koi8-r 
        <item>Spanish ISO-8859-1 
        <item>Swedish Codepage 850 
        <item>Swedish ISO-8859-1 
        <item>Swiss-German ISO-8859-1 
        <item>United Kingdom Codepage 850 
        <item>United Kingdom ISO-8859-1 
        <item>United States of America ISO-8859-1 
        <item>United States of America dvorak 
        <item>United States of America dvorakx 
      </itemize>

    <sect1>
      <heading>Las cuotas de usuario no funcionan correctamente.</heading>

      <p>
      <enum>
        <item>No actives las cuotas en '/',

        <item>Pon el fichero de cuotas en el sistema de ficheros en el que
        se vayan a forzar las cuotas de usuario:

        <verb>
          FS      QUOTA FILE
          /usr    /usr/admin/quotas
          /home   /home/admin/quotas
          ...
        </verb>
      </enum>

    <sect1>
      <heading>Que es incorrecto en mi ccd?</heading>

      <p>El sintoma es:

      <verb>
        # ccdconfig -C
        ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
        #
      </verb>

      <p>Esto actualmente ocurre cuando estas intentando concatenar las
      particiones c'. El driver ccd requiere que la particion sea del
      tipo FS_BSDFFS. Edita la etiqueta del disco (disklabel) que estas
      intentando concatenar y cambia el tipo de particion a '4.2BSD'.

    <sect1>
      <heading>Por que no puedo editar el disklabel en mi ccd?</heading>

      <p>El sintoma es:

      <verb>
        # disklabel ccd0
        (it prints something sensible here, so let's try to edit it)
        # disklabel -e ccd0
        (edit, save, quit)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
        #
      </verb>

      <p>Esto es porque el disklabel retornado por el ccd es actualmente
      uno que no corresponde con el real. Puedes resolver este problema
      escribiendo explicitamente:

      <verb>
        # disklabel ccd0 > /tmp/disklabel.tmp
        # disklabel -Rr ccd0 /tmp/disklabel.tmp
        # disklabel -e ccd0
        (this will work now)
      </verb>

    <sect1>
      <heading>Soporta FreeBSD primitivas IPC System V?</heading>

      <p>Si, FreeBSD las soporta. Estas incluyen memoria compartida,
      mensajes y semaforos. Necesitas anyadir las siguientes lineas
      en la configuracion de tu kernel para activarlas.

      <verb>
        options    SYSVSHM
        options    "SHMMAXPGS=64"   # 256Kb of sharable memory
        options    SYSVSEM          # enable for semaphores
        options    SYSVMSG          # enable for messaging
      </verb>

      <p>Recompila e instala.

      <p><bf/NOTA:/ Quizas necesites incrementar SHMMAXPGS a numero como
      4096 (16M) si quieres usar GIMP. 256K es suficiente para la
      memoria compartida en X11R6.

    <sect1>
      <heading>
        Como uso sendmail para envio de mail via UUCP?<label id="uucpmail">
      </heading>

      <p>La configuracion de sendmail incluida en FreeBSD esta preparada
      para sistemas que conectan directamente con Internet. Los sistemas
      que quieran usar UUCP para el envio de mail deben utilizar otro
      fichero de configuracion.

      <p>Retocar <tt>/etc/sendmail.cf</tt> manualmente esta considerado
      algo para puristas. La version 8 de sendmail incluye un nuevo
      sistema de configuracion llamado
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?m4" name="m4">, en
      el cual la configuracion se realiza en un nivel mas alto. Deberias
      usar los ficheros de configuracion situados en

      <verb>
        /usr/src/usr.sbin/sendmail/cf
      </verb>

      <p>Si no instalaste tu sistema con el codigo fuente completo, el
      paquete de configuracion de sendmail esta en una distribucion
      aparte. Asumiendo que tienes tu CD-ROM montado, haz:

      <verb>
        cd /usr/src
        tar -xvzf /cdrom/dists/src/ssmailcf.aa
      </verb>

      <p>No te preocupes, solo son unos cientos de kilobytes de tamanyo.
      El fichero <tt>README</tt> en el directorio <tt>cf</tt> puede
      servir como introduccion a la configuracion del m4.

      <p>Para envio y recepcion via UUCP, te aconsejamos usar la
      opcion <em>mailertable</em>. Se basa en una base de datos
      que sendmail puede usar como base para tomar las decisiones
      de enrutado del mail.

      <p>Primero tienes que crear tu fichero <tt>.mc</tt>. Estos ficheros
      se encuentran en el directorio
      <tt>/usr/src/usr.sbin/sendmail/cf/cf</tt>. Si miras, encontraras
      algunos ejemplos. Asumiendo que tu fichero se llama <tt>foo.com</tt>,
      todo lo que necesitas hacer para convertirlo en un fichero
      <tt>sendmail.cf</tt> valido es:


      <verb>
        cd /usr/src/usr.sbin/sendmail/cf/cf
        make foo.cf
        cp foo.cf /etc/sendmail.cf
      </verb>

      <p>Un fichero tipico <tt>.mc</tt> seria algo como:

      <verb>
        include(`../m4/cf.m4')
        VERSIONID(`Your version number')
        OSTYPE(bsd4.4)

        FEATURE(nodns)
        FEATURE(nocanonify)
        FEATURE(mailertable)

        define(`UUCP_RELAY', your.uucp.relay)
        define(`UUCP_MAX_SIZE', 200000)

        MAILER(local)
        MAILER(smtp)
        MAILER(uucp)

        Cw    your.alias.host.name
        Cw    youruucpnodename.UUCP
      </verb>

      <p>Las opciones <em>nodns</em> y <em>nocanonify</em> previenen
      del uso del DNS durante el trafico de correo. La clausula
      <em>UUCP_RELAY</em> se necesita por razones imperiosas, no
      preguntes :). Simplemente pon un nombre de maquina de Internet que
      sea capaz de gestionar pseudo-dominios .UUCP; mas sencillo,
      entraras el mail relay de tu ISP.

      <p>Una vez hayas hecho esto, necesitas el fichero llamado
      <tt>/etc/mailtertable</tt>. Un ejemplo tipico seria:

      <verb>
        #
        # makemap hash /etc/mailertable.db < /etc/mailertable
        #
        horus.interface-business.de   uucp-dom:horus
        .interface-business.de        uucp-dom:if-bus
        interface-business.de         uucp-dom:if-bus
        .heep.sax.de                  smtp8:%1
        horus.UUCP                    uucp-dom:horus
        if-bus.UUCP                   uucp-dom:if-bus
        .                             uucp-dom:sax
      </verb>

      <p>Como puedes ver, esto es parte de un fichero real. Las tres
      primeras lineas manejan casos especiales donde el correo dirigido
      a un dominio no debe ser enviado a traves de la ruta por defecto,
      si no a traves de un UUCP vecino para acortar el path de envio.
      La siguiente linea gestiona el mail del dominio local para que sea
      enviado via SMTP. Finalmente, los vecinos UUCP son anotados en la
      parte .UUCP pseudo-domains, para poder sobreescribir las reglas
      por defecto. La ultima linea es siempre un punto, que indica el
      mail gateway hacia el resto del mundo. Todos los nombres de nodos
      detras de <tt>uucp-dom:</tt> deben ser vecinos validos UUCP.

      <p>Como recordatorio de que este fichero debe ser convertido a
      una base de datos DBM antes de ser usada, la linea de comandos
      para realizar esta operacion esta puesta como un comentario al
      inicio del fichero. Siempre tienes que ejecutar este comando
      cada vez que realices algun cambio en tu mailtertable.

      <p>Si no tienes la seguridad de que una ruta de correo vaya a
      funcionar correctamente, recuerda la opcion <tt>-bt</tt> de
      sendmail. Esta opcion arranca el sendmail en <em>modo test</em>;
      simplemente entra 0, seguido por la direccion de mail sobre la que
      quieres testear la ruta. La ultima linea te indica el agente
      interno, el host de destino y la direccion (posiblemente
      traducido). Sal de este modo tecleando Control-D.

      <verb>
        j@uriah 191% sendmail -bt
        ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
        Enter <ruleset> <address>
        > 0 foo@interface-business.de
        rewrite: ruleset  0   input: foo @ interface-business . de
        ...
        rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
        < @ interface-business . de >
        > ^D
        j@uriah 192%
      </verb>

    <sect1>
      <heading>Como configuro el correo para conexiones NO permanentes a Internet?<label id="ispmail"></heading>

      <p>Si tienes una direccion IP fija en la conexion, no necesitaras
      ajustar nada de lo que ya viene por defecto. Configura tu host name
      como el nombre asignado a tu IP de Internet y sendmail hara el
      resto.

      <p>Si tienes direcciones IP asignadas dinamicamente y usas una
      conexion <bf/ppp/ a Internet, probablemente tendras un buzon en
      el servidor de correo de tu proveedor. Supongamos que el dominio
      de tu proveedor es <tt/myisp.com/, y tu nombre de usuario es
      <tt/user/. Supongamos tambien que has llamado a tu maquina
      <tt/bsd.home/ y que tu proveedor te ha indicado que uses la
      maquina <tt/relay.myISP.com/ como mail realy (gateway).

      <p>Para poder recoger el correo de tu buzon necesitaras instalar
      un agente de recogida de correo. <bf/Fetchmail/ es una buena opcion
      ya que soporta diferentes protocolos. Normalmente se usa POP3.
      Puedes recoger automaticamente tu correo al realizar la
      conexion anyadiendo la siguiente linea en el fichero
      <tt>/etc/ppp/ppp.linkup</tt>:

      <verb>
        MYADDR:
          !bg su user -c fetchmail
      </verb>

      <p>Asumimos que tienes una cuenta para <tt/user/ en <tt/bsd.home/.
      En el home directory de <tt/user/ en <tt/bsd.home/, crea el fichero
      <tt/.fetchmailrc/:

      <verb>
        poll myISP.com protocol pop3 fetchall pass MySecret;
      </verb>

      <p>No hace falta decir que este fichero no debe ser "leible" por nadie
      excepto <tt/user/ ya que contiene el password <tt/MySecret/.

      <p>Para enviar el correo con la cabecera <bf/from:/ correcta, debes
      decirle al sendmail que use <tt/user@myISP.com/ en lugar de
      <tt/user@bsd.home/. Tambien deberias decirle al sendmail que envie
      todo el correo saliente a traves de <tt/relay.myISP.com/, para una
      transmision mucho mas rapida.

      <p>El siguiente fichero <tt/.mc/ debe ser suficiente:

      <verb>
        VERSIONID(`bsd.home.mc version 1.0')
        OSTYPE(bsd4.4)dnl
        FEATURE(nouucp)dnl
        MAILER(local)dnl
        MAILER(smtp)dnl
        Cwlocalhost
        Cwbsd.home
        CwmyISP.com
        MASQUERADE_AS(`myISP.com')dnl
        FEATURE(allmasquerade)dnl
        FEATURE(masquerade_envelope)dnl
        FEATURE(nocanonify)dnl
        FEATURE(nodns)dnl
        define(SMART_HOST, `relay.myISP.com')
        DmmyISP.com
        define(`confDOMAIN_NAME',`myISP.com')dnl
        define(`confDELIVERY_MODE',`deferred')dnl
      </verb>

      <p>Mira en la seccion anterior para los detalles de como convertir
      este fichero <tt/.mc/ en un <tt/sendmail.cf/. No te olvides de
      rearrancar sendmail despues de cada actualizacion del fichero
      sendmail.cf.

    <sect1>
       <heading>Olvide el password de Root!!</heading>
       
       <p>Tranquilo!!!. Simplemenre rearranca tu sistema, teclea -s en el 
       prompt de arranque para entrar en modo monousuario. En la pregunta
       sobre el shell a usar, pulsa ENTER. Aparecera un prompt #. Teclea
       <tt>mount -u /</tt> para remontar tu sistema de ficheros en modo
       de lectura/escritura y a continuacion teclea <tt/mount -a/ para 
       montar todos los sistemas de ficheros. Ejecura <tt/passwd root/
       para cambiar el password de root. Teclea <tt/exit/ para continuar
       normalmente con el arranque.

    <sect1>
      <heading>Como mantengo el control sobre Control-Alt-Delete?</heading>

      <p>Edita el mapa de teclado que estas usando para la consola y
      reemplaza las palabras <tt/boot/ por <tt/nop/. El mapa de teclado por
      defecto es <tt>/usr/share/syscons/keymaps/us.iso.kbd</tt>. Por supuesto
      si usas otro mapa de teclado adecuado a tu pais, tendrias que editarlo.

    <sect1>
      <heading>Como reformateo ficheros de texto DOS a UNIX?</heading>

      <p>Simplemente usando este comando de perl:

<verb>
perl -i.bak -pe 's/\r\n/\n/g' file ...
</verb>
  
      <p>file es el fichero a procesar. La modificacion se hace en el propio
      fichero dejando el original grabado con extension .bak.

    <sect1>
      <heading>Como puedo hace "kill" de procesos por nombre?</heading>

      <p>Usa <url url="/cgi/cvsweb.cgi/man.cgi?killall" name="killall(1)">.

    <sect1>
      <heading>Porque el su no me dejar ser root al no estar en el ACL?</heading>

      <p>El error proviene de sistema del autentificacion distribuida Kerberos.
      El problema no es fatal pero si molesto. Puedes ejecutar el comando
      su con la opcion -K, o desinstalar Kerberos como se describe en la+
      siguiente seccion.

    <sect1>
      <heading>Como desinstalo Kerberois?</heading>

      <p>Para eliminar Kerberos del sistema, reinstala la distribucion bin
      de la release que estes usando. Si tienes el CDROM, puedes montar el
      cd (asumiremos que esta en /cdrom) y ejecutar:

<verb>
cd /cdrom/bin
./install.sh
</verb>

  </sect>

