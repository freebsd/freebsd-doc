<?xml version="1.0" encoding="utf-8"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Traditional Chinese Project

     $FreeBSD$
     Original revision: 46272
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="updating-upgrading">

  <info>
    <title>更新、升級 &os;</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jim</firstname>
	  <surname>Mock</surname>
	</personname>
	<contrib>Restructured, reorganized, and parts updated
	  by </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jordan</firstname>
	  <surname>Hubbard</surname>
	</personname>
	<contrib>Original work by </contrib>
      </author>

      <author>
	<personname>
	  <firstname>Poul-Henning</firstname>
	  <surname>Kamp</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>John</firstname>
	  <surname>Polstra</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	</personname>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>概述</title>

    <para>&os; 是個持續發展的作業系統。有些人喜歡官方釋出的版本，
有些人則喜歡和官方最新的開發版本保持同步。然而即使是官方釋出的版本仍然時常有安全性更新或和其他緊急修復。無論使用哪種版本，&os;都提供所有必須的工具來讓系統保持最新，而且可以輕易升級不同版本。本章將描述如何追蹤開發版本，和保持&os;系統維持最新的基本工具。</para>

    <para>讀完這章，您將了解︰</para>

    <itemizedlist>
      <listitem>
	<para>如何使用
	  <application>freebsd-update</application>,
	  <application>Subversion</application>, 或
	  <application>CTM</application> 讓 &os; 系統保持在最新的版本。</para>
      </listitem>

      <listitem>
	<para>如何比較安裝系統和原始複製的狀態。</para>
      </listitem>

      <listitem>
	<para>如何使用
	  <application>Subversion</application>或是documentation
	  ports<!--, and <application>Docsnap</application>-->來使已安裝的文件保持最新。</para>
      </listitem>

      <listitem>
	<para>兩個開發分支的差異：&os.stable; 和 &os.current;。</para>
      </listitem>

      <listitem>
	<para>如何重新編譯和重新安裝整個基礎系統。</para>
      </listitem>
    </itemizedlist>

    <para>在開始閱讀這章之前，您需要︰</para>

    <itemizedlist>
      <listitem>
	<para>設定好你的網路
	  (<xref linkend="advanced-networking"/>)。</para>
      </listitem>

      <listitem>
	<para>知道如何安裝第三方軟體
	  (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>本章中，使用 <command>svn</command> 來獲得和更新 &os; 原始碼。
        為了能使用他，首先要安裝 <package>devel/subversion</package>
        port 或 package。</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info>
      <title>&os; Update</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Written by </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Colin</firstname>
	    <surname>Percival</surname>
	  </personname>
	  <contrib>Based on notes provided by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Updating and Upgrading</primary>
    </indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>即時應用安全性更新與升級作業系統到新的發行版本對一個持續運作的系統是重要的。&os; 包括一個叫 <command>freebsd-update</command> 的工具程式可以執行這兩項任務。</para>
    <para>這個工具程式支援 &os; 二進制安全性與和錯誤更新，
不需要手動編譯和安裝修復或新核心。
安全性團隊目前支援的所有架構和發行版都可以取得二進制更新。
目前支援的發行版列表和他們的支援期限都列於
      <uri
	xlink:href="http://www.FreeBSD.org/security/">http://www.FreeBSD.org/security/</uri>。</para>

    <para>這個工具程式也支援作業系統升級到次要的發行版本和升級到令一個發行版分支升級到新的發行版本前，要檢查他的發行宣告，因為他包含發行版本相關的重要資訊。發行公告可以由<uri
	xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri>取得。</para>

    <note>
      <para>如果有使用<command>crontab</command>來執行
	&man.freebsd-update.8;，那必須在升級作業系統前先停用。</para>
    </note>

    <para>這節描述 <command>freebsd-update</command> 使用的設定檔，
示範如何運用安全性修補和如何升級到主要或次要的作業系統發行版，
以及討論某些升級作業系統的考量。 </para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>設定檔</title>

      <para>
	<command>freebsd-update</command>預設的設定檔不需變更即可運作。
有些使用者可能想要調校預設的設定檔 <filename>/etc/freebsd-update.conf</filename>
來對程序有更好的控制。這個設定檔的註解說明了可以使用的選項，
但以下可能需要更多一些的解釋：
	</para>

      <programlisting># Components of the base system which should be kept updated.
Components world kernel</programlisting>

      <para>這個參數控制 &os; 的哪個部份將保持最新。
	預設是將更新整個 base system 和核心。
個別元件可以被指定，
例如：<literal>src/base</literal> 或 <literal>src/sys</literal>。
然而最好的選項是維持預設設定，
因為改變設定去包括特定項目，則每個需要的項目都必須要列出。
時間一久可能會因為原始碼和二進制檔案沒有更新而造成慘重的後果。</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</programlisting>

      <para>保持特定的目錄，例如
	<filename>/bin</filename> 或 <filename>/sbin</filename>,
	在更新過程不被更動，可以將他們的路徑加到此敘述中。
	這個選項可以防止 <command>freebsd-update</command>覆蓋本機的修改。</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>這個選項只會更新特定目錄中未修改的設定檔。
	任何使用者修改的檔案都不會自動更新。
	有另一個選項──
	<literal>KeepModifiedMetadata</literal>會指示
	<command>freebsd-update</command> 在合併時將改變儲存下來</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</programlisting>

      <para>列出 <command>freebsd-update</command>應嘗試合併的設定檔目錄。
	檔案合併過程是一系列類似&man.mergemaster.8;的&man.diff.1;修補，
但是選項比較少。
	合併可以接受，開啟編輯器，或是令<command>freebsd-update</command>中止。
如果有疑慮，備份 <filename>/etc</filename>，然後同意合併。
	更多關於<command>mergemaster</command>的資訊，
參見 <xref linkend="mergemaster"/>。
	</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>這個目錄是所有修補檔和暫存檔放置處。
	當使用者進行版本升級時，這個位置應該要有至少1GB的可用磁碟空間。</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>當這個選項設定為<literal>yes</literal>，
	<command>freebsd-update</command> 將會假設
	<literal>Components</literal> 列表已完成，將不會嘗試做列表外的改變。
	實際上 <command>freebsd-update</command>將嘗試更新每一個屬於
	<literal>Components</literal> 列表的檔案。</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>運用安全性修補</title>

      <para>運用 &os; 安全性修補的過程已經被簡化，
	允許系統管理員使用<command>freebsd-update</command>保持系統更新。
	更多關於&os; 安全性報告的資訊可以參考
	<xref linkend="security-advisories"/>。</para>

      <para>&os; 安全性修補可以使用以下指令下載與安裝。
	第一個指令將決定是否有尚未完成的修補，如果有，將列出執行修補將會變更的檔案清單。第二個指令將會執行修補。
	</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>如果更新執行任何核心修補，系統將會重新開機以使用修補過的核心。
如果在任何執行中的二進位檔進行修補，被影響的應用程式將會重新啟動來使用修補過的二進位檔。</para>

      <para>將以下項目加入 <filename>/etc/crontab</filename> 系統可以每天自動檢查是否有更新:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>如果有新的修補，它們將會自動下載，但是還不會執行。
	管理者<systemitem
	  class="username">root</systemitem> 將會收到email來檢視修補然後手動執行
	<command>freebsd-update install</command> 來安裝</para>

      <para>如果有發生任何錯誤，<command>freebsd-update</command>
	可以使用以下指令回溯最後的變更：</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput>
Uninstalling updates... done.</screen>

      <para>再次，如果核心或任何核心模組有變更，系統將重新開機，受影響的二進位檔會重新執行。
	</para>

      <para>只有 <filename>GENERIC</filename> 核心可以自動被
	<command>freebsd-update</command> 更新。
	如果有安裝自訂的核心，在<command>freebsd-update</command>
	完成安裝更新後，將會被重新編譯和重新安裝。
	然而，如果 <filename>/boot/GENERIC</filename> 存在，
	<command>freebsd-update</command>將會偵測和更新 <filename>GENERIC</filename> 核心，
	即使他並非目前系統正在執行的核心。</para>

      <note>
	<para>永遠在 <filename>/boot/GENERIC</filename> 保留一份 <filename>GENERIC</filename>
	  核心的備份。這對於診斷不同的問題與版本的升級有幫助。
	  參考<xref
	    linkend="freebsd-update-custom-kernel-9x"/> 或 <xref
	    linkend="freebsd-update-custom-kernel-8x"/> 關於如何備份
	  <filename>GENERIC</filename> 核心的說明</para>
      </note>

      <para>除非 <filename>/etc/freebsd-update.conf</filename> 的預設設定被改變，
	<command>freebsd-update</command>將安裝更新過的核心原始碼和其餘的更新
	然後就可以照平常的方式重新編譯和重新安裝新的自訂核心。</para>

      <para>以 <command>freebsd-update</command> 發行的更新並非總是包含核心。
	如果核心的原始碼沒有被 <command>freebsd-update install</command> 變更，並不需要重新編譯自訂核心。
	然而 <command>freebsd-update</command> 總是會更新
	<filename>/usr/src/sys/conf/newvers.sh</filename>。目前修補的程度，
	如同執行 <command>uname -r</command> 顯示的 <literal>-p</literal>
	數字是由這個檔案取得。
	即使沒有做任何改變，重新編譯核心會讓 <command>uname</command> 正確地報告目前系統修補的程度。
	這對於維護多個系統特別有幫助，可以讓你快速評估每個系統安裝的更新。</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>執行主要和次要的版本升級</title>

      <para>從&os;的次要版本升級到另一個版本，例如從
	&os;&nbsp;9.0 到 &os;&nbsp;9.1, 叫作
	<firstterm>次要版本</firstterm>更新。
	<firstterm>主要版本</firstterm>更新發生在當 &os;
	從一個主要版本升級到主要版本升級到另一個主要版本時
，例如從 &os;&nbsp;9.X 到 &os;&nbsp;10.X。
兩種更新都可以透過提供 <command>freebsd-update</command> 發行版本來執行。</para>

      <note>
	<para>如果系統正在執行自訂的核心，開始升級前，
	確定 <filename>GENERIC</filename> 核心的副本在
	  <filename>/boot/GENERIC</filename>。
	   參考<xref
	    linkend="freebsd-update-custom-kernel-9x"/> 或 <xref
	    linkend="freebsd-update-custom-kernel-8x"/> 關於如何製作
	  <filename>GENERIC</filename>核心副本的說明。</para>
      </note>

      <para>以下的指令執行在 &os;&nbsp;9.0 系統時，
	將會把系統升級至 &os;&nbsp;9.1：</para>

       <screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

      <para>當收到這個指令後，
	<command>freebsd-update</command> 將會評估設定檔和目前的系統來收集升級需要的資訊。
	螢幕上的清單會顯示偵測到或沒偵測到哪些元件。例如： </para>
      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? <userinput>y</userinput></screen>

      <para>此時，<command>freebsd-update</command> 將嘗試下載所有升級需要的檔案。
在某些案例，使用者會被提示一些關於安裝什麼或是如何進行的問題。</para>

      <para>當使用自訂核心，上述的步驟將會產生如下列的警告：</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>這個警告可以安全地忽略，升級過程將會立即使用更新過的
	 <filename>GENERIC</filename> 核心</para>

      <para>一旦所有的修補都被下載到本地的系統，
	它們將會被運用。這個過程可能會花點時間，取決於機器的速度和工作量
	設定檔將會被合併。
	合併的過程中當檔案被合併或是手動合併螢幕上出現編輯器時需要使用者介入。
	每一個成功合併的結果將會顯示給使用者。
	失敗或是被忽略的合併將會使程序中斷。使用者稍候可能想要備份
	<filename>/etc</filename> 和手動合併重要的檔案，例如：
	<filename>master.passwd</filename> 或
	<filename>group</filename> 。</para>

      <note>
	<para>當所有修補和合併在另一個目錄進行時，系統還不會被警告。
	  一旦所有修補都成功運用，所有設定檔都被合併，而且過程順利，使用者可以以下指令來將這些改變付諸於磁碟上：</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>
      </note>

      <para>核心和核心模組將會先被修補。如果系統正在執行自訂核心，使用
	&man.nextboot.8; 指令設定下次開機的核心為更新過的
	<filename>/boot/GENERIC</filename>：</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>如果機器以遠端遙控來更新，
	  使用<filename>GENERIC</filename>核心重新開機前，
	  確定他包含所有系統開機需要的驅動程式而且連接網路，
	  特別是當執行的自訂核心包含核心模組提供內建功能時，
	  確定暫時地使用 <filename>/boot/loader.conf</filename> 工具載入這些模組到 <filename>GENERIC</filename> 核心。
	  建議停用非必須的服務和磁碟與網路掛載直到升級程序完成。
	  </para>
      </warning>

      <para>機器現在應該更新過的核心重新開機：
	</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>一旦系統重新上線，使用以下指令重新開始
	<command>freebsd-update</command>。
	因為程序的狀態已被儲存，
	<command>freebsd-update</command> 將不會重頭開始，他會進行到下一個階段
	，移除所有舊的共用程式庫和目標檔。</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>根據程式庫版本編號， 可能有兩個而不是三個安裝階段。</para>
      </note>

      <para>升級程序現在完成了。如果這是主要的版本升級，參考
	<xref linkend="freebsdupdate-portsrebuild"/>
	的描述重新安裝所有的ports和套件。</para>

      <sect3 xml:id="freebsd-update-custom-kernel-9x">
	<title> &os;&nbsp;9.X 以上自訂核心</title>

	<para>使用 <command>freebsd-update</command> 前，確定有一份核心的副本, ensure
	  that a copy of the <filename>GENERIC</filename> kernel
	  exists in <filename>/boot/GENERIC</filename>.  If a custom
	  kernel has only been built once, the kernel in
	  <filename>/boot/kernel.old</filename> is the
	  <literal>GENERIC</literal> kernel.  Simply rename this
	  directory to <filename>/boot/kernel</filename>.</para>

	<para>If a custom kernel has been built more than once or if
	  it is unknown how many times the custom kernel has been
	  built, obtain a copy of the <literal>GENERIC</literal>
	  kernel that matches the current version of the operating
	  system.  If physical access to the system is available, a
	  copy of the <literal>GENERIC</literal> kernel can be
	  installed from the installation media:</para>

	<screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>

	<para>Alternately, the <literal>GENERIC</literal> kernel may
	  be rebuilt and installed from source:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

	<para>For this kernel to be identified as the
	  <literal>GENERIC</literal> kernel by
	  <command>freebsd-update</command>, the
	  <filename>GENERIC</filename> configuration file must not
	  have been modified in any way.  It is also suggested that
	  the kernel is built without any other special
	  options.</para>

	<para>Rebooting into the <filename>GENERIC</filename> kernel
	  is not required as <command>freebsd-update</command> only
	  needs <filename>/boot/GENERIC</filename> to exist.</para>
      </sect3>

      <sect3 xml:id="freebsd-update-custom-kernel-8x">
	<title>&os;&nbsp;8.X 自訂核心</title>

	<para>On an &os;&nbsp;8.X system, the instructions for
	  obtaining or building a <filename>GENERIC</filename> kernel
	  differ slightly.</para>

	<para>Assuming physical access to the machine is possible, a
	  copy of the <filename>GENERIC</filename> kernel can be
	  installed from the installation media using the following
	  commands:</para>

	<screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/<replaceable>X.Y-RELEASE</replaceable>/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	<para>Replace <filename
	    ><replaceable>X.Y-RELEASE</replaceable></filename>
	  with the version of the release being used.  The
	  <filename>GENERIC</filename> kernel will be installed in
	  <filename>/boot/GENERIC</filename> by default.</para>

	<para>To instead build the <filename>GENERIC</filename> kernel
	  from source:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	<para>For this kernel to be picked up as
	  <filename>GENERIC</filename> by
	  <command>freebsd-update</command>, the
	  <filename>GENERIC</filename> configuration file must not
	  have been modified in any way.  It is also suggested that it
	  is built without any other special options.</para>

	<para>Rebooting into the <filename>GENERIC</filename> kernel
	  is not required.</para>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>主要版本更新後更新 Packages</title>

	<para>一般來說，次要版本更新後安裝的應用程式可以沒有問題地繼續執行。
	  主要版本間使用不同的應用程式二進位介面 Application Binary Interfaces
	  (<acronym>ABI</acronym>s)，會破壞大部份第三方應用程式。
	  主要版本更新後，所有安裝的套件和 ports 需要使用應用程式來升級，例如
	  <package>ports-mgmt/portmaster</package>
	  重新編譯所有應用程式，可以使用以下指令完成：</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para>這個指令將會顯示每個程式的設定選項設定畫面，等待使用者的互動。
	  如果要使用預設的選項，可以在上述指令使用<option>-G</option>選項。
	  </para>

	<para>一旦軟體升級完成, 執行
	  <command>freebsd-update</command> 來完成所有升級過程的零碎事情 ：</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<para>如果是暫時使用 <filename>GENERIC</filename> 核心，
	  現在請使用
	<xref linkend="kernelconfig"/>的說明編譯和安裝新的自訂核心。</para>

	<para>重新開機進入新版的 &os;。現在已經完成升級過程了。
	  </para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>系統狀態比較</title>

      <para>已安裝的 &os; 版本可以使用 <command>freebsd-update IDS</command>
來跟另一個已知好的複製版本來做測試。
這個指令評估系統應用程式，程式庫和設定檔案目前的版本，
可以被當成內建的入侵偵測系統來使用 (<acronym>IDS</acronym>)。</para>

      <warning>
	<para>這個指令不是取代真正的
	  <acronym>IDS</acronym> ，例如
	  <package>security/snort</package>。當
	  <command>freebsd-update</command> 儲存資料在磁碟裡，是有被竄改的可能性
	  可以使用 <varname>kern.securelevel</varname>
	  或是將沒有在使用的 <command>freebsd-update</command>
	  的資料儲存在唯讀檔案系統來減少這樣的可能性，
	  比較好的解決方法是將系統和安全的磁碟，例如
	  <acronym>DVD</acronym> 或是安全的外接
	  <acronym>USB</acronym> 磁碟裝置做比較。
	  另類的方法是使用在 <xref linkend="security-ids"/> 描述的內建應用程式提供的
	  <acronym>IDS</acronym> 功能</para>
      </warning>

      <para>為了開始比較，先指定特定的輸出檔案來儲存結果：</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <para>現在系統將會被檢查，
	而包含已知發行版和現在安裝版的<acronym>SHA256</acronym>雜湊值
	的冗長檔案清單將會被送至指定的輸出檔。</para>

      <para>清單的項目相當長，但是輸出格式很容易被分析。
	例如，要獲得一個和發行版不同的檔案清單，可以下以下指令：</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>這個輸出範例已經被截短，原來有更多的檔案存在。
	有些檔案自然會有修改。例如，如果有使用者被加入系統，
	<filename>/etc/passwd</filename> 會被修改
	如果 <command>freebsd-update</command> 有更新過，核心模組可能會不同
	 為了要排除特定的檔案或目錄，把它們加到<filename>/etc/freebsd-update.conf</filename> 裡的 <literal>IDSIgnorePaths</literal> 選項。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <title>更新文件組</title>

    <indexterm><primary>更新和升級</primary></indexterm>

    <indexterm>
      <primary>文件</primary>
      <see>更新和升級</see>
    </indexterm>

    <para>文件是&os;作業系統不可或缺的一部份。
      最新版本的 &os; 文件可以在
      &os; 網站取得(<link
	xlink:href="&url.base;/doc/">http://www.freebsd.org/doc/</link>),
      很方便有一份最新的&os;
      網站，使用手冊， <acronym>常見問答</acronym>和文章的本地端副本。</para>

    <para>這一節描述如何使用原始碼或是
	&os; Ports 管理機制將
	本地端&os;文件保持最新。</para>

    <para>編輯和發佈文件更正的資訊
     請參考 &os; 文件計劃新貢獻者入門書
      (<link
	  xlink:href="&url.books.fdp-primer;">http://www.freebsd.org/doc/en_US.ISO8859-1/books/fdp-primer/</link>).</para>

    <sect2 xml:id="updating-installed-documentation">
      <title>從原始碼更新文件</title>

      <para>重新從原始碼編譯&os; 文件需要一些不是屬於
	&os; 基礎系統的工具
	這些需要的工具包括
	<application>svn</application> 可以從
	<package>textproc/docproj</package> 套件安裝或是
	&os; 文件計劃的開發的port</para>

      <para>一旦安裝好，請使用 <application>svn</application>
	來取得乾淨的文件原始碼副本。
	將 <replaceable>https://svn0.us-west.FreeBSD.org</replaceable>
	置換成 <xref linkend="svn-mirrors"/> 裡地理位置和你最近的鏡像站：</para>

      <screen>&prompt.root; <userinput>svn checkout <replaceable>https://svn0.us-west.FreeBSD.org</replaceable>/doc/head /usr/doc</userinput></screen>

      <para>第一次下載文件原始碼需要花點時間，請讓他執行完畢</para>

      <para>將來文件原始碼更新的取得可以執行：</para>

      <screen>&prompt.root; <userinput>svn update /usr/doc</userinput></screen>

      <para>當最新的文件原始碼快照已經抓取到
	<filename>/usr/doc</filename>，一切都已就緒可以對已安裝的文件進行更新。</para>

      <para>要完整更新所有語言，可以執行:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>如果只要更新一個特定的語言，可以在 <filename>/usr/doc</filename>
中特定語言的子目錄執行 <command>make</command>:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>另一個更新文件的方法是在 <filename>/usr/doc</filename>
或特定語言的子目錄執行:</para>

      <screen>&prompt.root; <userinput>make update</userinput></screen>

      <para>輸出格式可以經由設定 <varname>FORMATS</varname> 來指：</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>有幾個選項可以使得只要更新部份文件或是建立特定翻譯的過程更加簡易。
這些選項可以在 <filename>/etc/make.conf</filename> 中設定成整個系統的選項，
或是經由命令列傳送給 <command>make</command>。</para>

      <para>這些選項包括:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>要建立或是安裝的語言和編碼清單，例如英文文件用
	      <literal>en_US.ISO8859-1</literal>。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>單一格式或是要建立的輸出格式清單。目前支援 <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, 和 <literal>pdf</literal>。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>安裝文件的位置。預設裝在
	      <filename>/usr/share/doc</filename>。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>更多關於&os;全系統的<command>make</command> 變數，
	請參考&man.make.conf.5;。</para>
    </sect2>

    <sect2 xml:id="doc-ports-install-package">
      <info>
	<title>從 Ports 更新文件</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Marc</firstname>
	      <surname>Fonvieille</surname>
	    </personname>
	    <contrib>Based on the work of </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>Updating and Upgrading</primary>
      </indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>前一節說明了從原始碼更新 &os; 文件的方法。本節敘述使用 Ports Collection 的另一種方法：</para>

      <itemizedlist>
	<listitem>
	  <para>Install pre-built packages of the documentation,
	    without having to locally build anything or install the
	    documentation toolchain.</para>
	</listitem>

	<listitem>
	  <para>Build the documentation sources through the ports
	    framework, making the checkout and build steps a bit
	    easier.</para>
	</listitem>
      </itemizedlist>

      <para>This method of updating the &os; documentation is
	supported by a set of documentation ports and packages which
	are updated by the &a.doceng; on a monthly basis.  These are
	listed in the &os; Ports&nbsp;Collection, under the docs
	category (<link
	  xlink:href="http://www.freshports.org/docs/">http://www.freshports.org/docs/</link>).</para>

      <para>Organization of the documentation ports is as
	follows:</para>

      <itemizedlist>
	<listitem>
	  <para>The <package>misc/freebsd-doc-en</package> package or
	    port installs all of the English documentation.</para>
	</listitem>

	<listitem>
	  <para>The <package>misc/freebsd-doc-all</package>
	    meta-package or port installs all documentation in all
	    available languages.</para>
	</listitem>

	<listitem>
	  <para>There is a package and port for each translation, such
	    as <package>misc/freebsd-doc-hu</package> for the
	    Hungarian documentation.</para>
	</listitem>
      </itemizedlist>

      <para>When binary packages are used, the &os; documentation will
	be installed in all available formats for the given language.
	For example, the following command will install the latest
	package of the Hungarian documentation:</para>

      <screen>&prompt.root; <userinput>pkg install hu-freebsd-doc</userinput></screen>

      <note>
	<para>Packages use a format that differs from the
	  corresponding port's name:
	  <literal><replaceable>lang</replaceable>-freebsd-doc</literal>,
	  where <replaceable>lang</replaceable> is the short format of
	  the language code, such as <literal>hu</literal> for
	  Hungarian, or <literal>zh_cn</literal> for Simplified
	  Chinese.</para>
      </note>

      <para>To specify the format of the documentation, build the port
	instead of installing the package.  For example, to build and
	install the English documentation:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>The port provides a configuration menu where the format to
	build and install can be specified.  By default, split
	<acronym>HTML</acronym>, similar to the format used on <uri
	  xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri>,
	and <acronym>PDF</acronym> are selected.</para>

      <para>Alternately, several <command>make</command> options can
	be specified when building a documentation port,
	including:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>WITH_HTML</varname></term>

	  <listitem>
	    <para>Builds the HTML format with a single HTML file per
	      document.  The formatted documentation is saved to a
	      file called <filename>article.html</filename>, or
	      <filename>book.html</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>WITH_PDF</varname></term>

	  <listitem>
	    <para>The formatted documentation is saved to a file
	      called <filename>article.pdf</filename> or
	      <filename>book.pdf</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCBASE</varname></term>

	  <listitem>
	    <para>Specifies where to install the documentation.  It
	      defaults to
	      <filename>/usr/local/share/doc/freebsd</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>This example uses variables to install the Hungarian
	documentation as a <acronym>PDF</acronym> in the specified
	directory:</para>

      <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>

      <para>Documentation packages or ports can be updated using the
	instructions in <xref linkend="ports"/>.  For example, the
	following command updates the installed Hungarian
	documentation using <package>ports-mgmt/portmaster</package>
	by using packages only:</para>

      <screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>追蹤發展分支</title>

    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>&os; 有兩個發展分支： &os.current; and
      &os.stable;.</para>

    <para>本節將將解釋每個分支和他的預設的使用者，以及如何保持每個分支系統在最新。</para>

    <sect2 xml:id="current">
      <title>使用 &os.current;</title>

      <para>&os.current; 是 &os; 開發的<quote>最前線</quote>，&os.current;的使用者應有較強的技術能力。
	技術能力較弱的使用者想追蹤發展分支應該追蹤 &os.stable;。</para>

      <para>&os.current; 是 &os; 最新的原始碼，包括正在進行的工作，
	實驗性的改變，以及可能會或可能不會在下一個官方發行版出現的過渡時期機制。
	而許多 &os; 開發者每天編譯
	&os.current; 原始碼，可能有一段短暫的時間原始碼無法編譯成功。
	這些問題會儘快被解決，但是無論
	&os.current; 帶來災難或是新功能，在同步原始碼時都要考量的問題。</para>

      <para>&os.current; 適合下列三類人：</para>

      <orderedlist>
	<listitem>
	  <para>積極致力於某一部份原始碼樹的 &os; 社群成員。</para>
	</listitem>

	<listitem>
	  <para>擔任積極測試者的 &os; 社群成員。
	    他們願意花時間解決問題，提出 &os; 改變的建議和的大方向，並發布修補。</para>
	</listitem>

	<listitem>
	  <para>關注某些事物，或是想參考目前的原始碼，或是偶爾提供註解或貢獻原始碼的使用者。</para>
	</listitem>
      </orderedlist>

      <para>&os.current; <emphasis>不應該</emphasis>被認為是在下一版發行前
	取得最新功能的快速途徑，因為尚未發行的功能並未被完整測試，很可能有bug。
	他也不是一個取得bug修補的快速方式，
	因為任何已知bug的修補有可能產生新的bug。
	&os.current; 沒有任何
	<quote>官方支援</quote>。</para>

      <indexterm>
	<primary>-CURRENT</primary>
	<secondary>using</secondary>
      </indexterm>

      <para>追蹤 &os.current;：</para>

      <orderedlist>
	<listitem>
	  <para>加入 &a.current.name; 和
	    &a.svn-src-head.name; 郵件論壇。這是<emphasis>必須的</emphasis>
	    以查看人們關於系統目前狀態的評論並接收 &os.current; 目前狀態的重要公告。</para>

	  <para> &a.svn-src-head.name; 論壇紀錄每一次修改的紀錄，
	    和可能產生的副作用的相關資訊 </para>

	  <para>前往 &a.mailman.lists.link;，點選論壇來訂閱，照網頁指示的步驟作，
	    為了追蹤整個原始碼樹，不是只有 &os.current; 的改變，請訂閱
	    &a.svn-src-all.name;論壇。</para>
	</listitem>

	<listitem>
	  <para>同步 &os.current; 原始碼。
	    通常使用 <link linkend="svn">svn</link> 來檢查<xref linkend="svn-mirrors"/>
	    列出的 Subversion 鏡像站 <literal>head</literal> 分支的-CURRENT 原始碼。</para>

	  <para>網路很慢或是受到限制的使用者可以如<xref linkend="ctm"/>
	    所描述的，使用 CTM 來替代，但是他並不如 <application>svn</application>
	    一樣值得信賴， <application>svn</application> 是建議的同步原始碼的方法。</para>
	</listitem>

	<listitem>
	  <para> 由於程式碼庫的大小的，
	    有些使用者選擇只同步部份他們有興趣或提供修補貢獻的部份原始碼。然而，
	    計劃從原始碼編譯整個作業系統的使用者必須下載 <emphasis>全部</emphasis>
	    的&os.current;，而不是只有選擇的部份。</para>

	  <para>編譯 &os.current; 前
	    <indexterm>
	      <primary>-CURRENT</primary>
		<secondary>compiling</secondary>
	    </indexterm>，請非常仔細地閱讀 <filename>/usr/src/Makefile</filename>
	    並遵從 <xref linkend="makeworld"/>的指示。
	    閱讀 &a.current; 和 <filename>/usr/src/UPDATING</filename>
	    來掌握下一發行版的最新狀態。</para>
	</listitem>

	<listitem>
	  <para>熱血！很鼓勵 &os.current; 使用者
	    發表他們對加強哪些功能或是修復哪些錯誤的建議。
	    如果您在建議時能附上相關程式碼的話， 那真是太棒了！</para>
	</listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="stable">
      <title>使用 &os.stable;</title>

      <para>主要發行版就是由 &os.stable; 這個開發分支而來。
	修改進入這個分支的速度比較慢，
	並且假設這些修改已經先在 &os.current; 測試過。
	這<emphasis>仍然</emphasis>是一個開發分支，而且在任何時候，&os.stable; 的原始碼都可能適合或不適合一般的使用。他就只是另一個開發分支，不是給終端使用者用的。
	沒有要進行測試的使用者應該執行最新的 &os; 發行版。</para>

      <para>若有興趣去追蹤、貢獻 &os; 開發過程，尤其是會跟
	&os;接下來的發行版有關的人,應該考慮採用 &os.stable;。</para>

      <para>儘管 &os.stable; 應該在任何時候均能正確編譯、運作，但是沒有人能擔保一定如此。因為使用 &os.stable; 的人比 &os.current;多，無可避免地，
	有時候會在 &os.stable; 發現錯誤和極端的狀況，而這在 &os.current; 並非顯而易見。
	由於上述這些理由，我們並不建議盲目追隨 &os.stable;。
	特別重要的是
	<emphasis>不要</emphasis>在沒有於開發或測試環境完整測試程式碼之前，
	升級任何上線的伺服器到 &os.stable;。</para>

      <para>追蹤 &os.stable;:</para>

      <indexterm>
	<primary>-STABLE</primary>
	  <secondary>using</secondary>
      </indexterm>
      <orderedlist>
	<listitem>
	  <para>訂閱&a.stable.name;論壇來隨時瞭解 &os.stable; 編譯時的相依關係
	    或是其他特別需要注意的議題。
	    開發者在考慮一些有爭議的修正或更新時，就會先在這裡發信說明， 給使用者有機會可以反應， 看他們對所提的更改是否有什麼建議或問題。</para>

	  <para>訂閱要追蹤分支的 <application>svn</application>相關論壇。
	    例如，追蹤9-STABLE分支的使用者應該訂閱&a.svn-src-stable-9.name;論壇。
	    這個論壇紀錄每一次修改的紀錄，和可能產生的副作用的相關資訊。</para>

	  <para>前往&a.mailman.lists.link;，點選論壇來訂閱，照網頁指示的步驟作，
	    為了追蹤整個原始碼樹，請訂閱&a.svn-src-all.name;論壇。</para>
	</listitem>

	<listitem>
	  <para>要安裝一個新的 &os.stable; 系統，
	    從<link linkend="mirrors"> &os; 鏡像站</link>安裝最新的 &os.stable; 發行版
	    或使用從 &os.stable;每個月的 snapshot built來安裝。更多關於快照的資訊，
	    請參考<link xlink:href="&url.base;/snapshots/">www.freebsd.org/snapshots</link>。</para>

	  <para>要編譯或升級已經安裝的 &os; 系統至 &os.stable;，
	    請使用<link linkend="svn">svn</link>
	      <indexterm>
		<primary>Subversion</primary>
	      </indexterm> 來檢查要安裝分支的原始碼。
	    分支的名稱，例如
	    <literal>stable/9</literal>，列在<link
	      xlink:href="&url.base;/releng/">www.freebsd.org/releng</link>。
	    如果沒有可靠的網際網路連線可以使用CTM (<xref linkend="ctm"/>) 。
</para>
	</listitem>

	<listitem>
	  <para>在編譯或升級到 &os.stable; 之前
	    <indexterm>
	      <primary>-STABLE</primary>
		<secondary>compiling</secondary>
	    </indexterm>， 請仔細閱讀 <filename>/usr/src/Makefile</filename>
	    並遵照<xref
	      linkend="makeworld"/>的指示。閱讀 &a.stable; 和
	    <filename>/usr/src/UPDATING</filename>下一發行版的最新狀態。</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>同步原始碼</title>

    <para>有幾種不同的方法保持 &os; 原始碼在最新狀態。
	這節比較這兩個主要的方法： <application>Subversion</application> 和 <application>CTM</application>。</para>

    <warning>
      <para>雖然有可能只更新部份原始碼樹，但是唯一支援的更新步驟是更新整個樹併重新編譯所有在使用者空間的程式，
	例如在<filename>/bin</filename> 和
	<filename>/sbin</filename>，以及核心原始碼。
	只更新部份原始碼樹，只更新核心，或只更新使用者空間的程式時常會導致編譯錯誤，核心錯誤或是資料惡化等問題。</para>
    </warning>

    <indexterm>
      <primary>Subversion</primary>
    </indexterm>

    <para><application>Subversion</application>使用更新原始碼的
      <emphasis>pull</emphasis> 模型。使用者，或是
      <command>cron</command> 手稿語言, 呼叫更新本地端原始碼的
      <command>svn</command> 程式。
      <application>Subversion</application> is the
      preferred method for updating local source trees as updates are
      up-to-the-minute and the user controls when updates are
      downloaded.  It is easy to restrict updates to specific files or
      directories and the requested updates are generated on the fly
      by the server.  如何使用How to synchronize source using
      <application>Subversion</application>同步原始碼，描述於<xref
	linkend="svn"/>。</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application> does not interactively
      compare the local sources with those on the master archive or
      otherwise pull them across.  Instead, a script which identifies
      changes in files since its previous run is executed several
      times a day on the master CTM machine.  Any detected changes are
      compressed, stamped with a sequence-number, and encoded for
      transmission over email in printable <acronym>ASCII</acronym>
      only.  Once downloaded, these <firstterm>deltas</firstterm> can
      be run through <command>ctm.rmail</command> which will
      automatically decode, verify, and apply the changes to the
      user's copy of the sources.  This process is more efficient than
      <application>Subversion</application> and places less strain on
      server resources since it is a <emphasis>push</emphasis>, rather
      than a <emphasis>pull</emphasis>, model.  Instructions for using
      <application>CTM</application> to synchronize source can be
      found at <xref linkend="ctm"/>.</para>

    <para>If a user inadvertently wipes out portions of the local
      archive, <application>Subversion</application> will detect and
      rebuild the damaged portions.  <application>CTM</application>
      will not, and if a user deletes some portion of the source tree
      and does not have a backup, they will have to start from scratch
      from the most recent <firstterm>base delta</firstterm> and
      rebuild it all with <application>CTM</application>.</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>重新編譯 World</title>

    <indexterm>
      <primary>Rebuilding <quote>world</quote></primary>
    </indexterm>
    <para>一旦本地端的原始碼樹和 &os; 的特定版本同步後，
      例如 &os.stable; or &os.current;，原始碼樹就可以用來重新編譯系統。
      這個過程叫重新編譯 world。</para>

    <para>重新編譯 world <emphasis>之前</emphasis> ，請確定執行以下任務:</para>

    <procedure>
      <title>編譯 world <emphasis>之前</emphasis> 執行這些任務</title>

      <step>
	<para>備份所有重要資料到另一個系統或是可攜式媒體，
	  檢查備份的完整性，手邊準備一個可以開機的安裝媒體。
	  再次強調在重新編譯系統
	  <emphasis>之前</emphasis>，製作系統的備份是非常重要的。 While
	  rebuilding world is an easy task, there will inevitably be
	  times when mistakes in the source tree render the system
	  unbootable.  You will probably never have to use the backup,
	  but it is better to be safe than sorry!</para>
      </step>

      <step>
	<indexterm><primary>mailing list</primary></indexterm>
	<para>Review the recent &a.stable.name; or &a.current.name;
	  entries, depending upon the branch being tracked.  Be aware
	  of any known problems and which systems are affected.  If a
	  known issue affects the version of synchronized code, wait
	  for an <quote>all clear</quote> announcement to be posted
	  stating that the problem has been solved.  Resynchronize the
	  sources to ensure that the local version of source has the
	  needed fix.</para>
      </step>

      <step>
	<para>Read <filename>/usr/src/UPDATING</filename> for any
	  extra steps necessary for that version of the source.  This
	  file contains important information about potential problems
	  and may specify the order to run certain commands.  Many
	  upgrades require specific additional steps such as renaming
	  or deleting specific files prior to installing the new
	  world.  These will be listed at the end of this file where
	  the currently recommended upgrade sequence is explicitly
	  spelled out.  If <filename>UPDATING</filename> contradicts
	  any steps in this chapter, the instructions in
	  <filename>UPDATING</filename> take precedence and should be
	  followed.</para>
      </step>
    </procedure>

    <warning>
      <title>不要使用 <command>make world</command></title>

      <para>某些比較老的文件建議使用 <command>make
	  world</command>。然而，這個指令掠略過某些重要的步驟，只適合專家使用。
	大部分的情況，使用 <command>make world</command>都是錯誤的，應該用這裡描述的步驟代替。
	</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>程序概要</title>

      <para>The build world process assumes an upgrade from an older
	&os; version using the source of a newer version that was
	obtained using the instructions in <xref
	  linkend="synching"/>.</para>

      <para>In &os;, the term <quote>world</quote> includes the
	kernel, core system binaries, libraries, programming files,
	and built-in compiler.  The order in which these components
	are built and installed is important.</para>

      <para>For example, the old compiler might have a bug and not be
	able to compile the new kernel.  Since the new kernel should
	be built with the new compiler, the new compiler must be
	built, but not necessarily installed, before the new kernel is
	built.</para>

      <para>The new world might rely on new kernel features, so the
	new kernel must be installed before the new world is
	installed.  The old world might not run correctly on the new
	kernel, so the new world must be installed immediately upon
	installing the new kernel.</para>

      <para>Some configuration changes must be made before the new
	world is installed, but others might break the old world.
	Hence, two different configuration upgrade steps are used.
	For the most part, the update process only replaces or adds
	files and existing old files are not deleted.  Since this can
	cause problems, <filename>/usr/src/UPDATING</filename> will
	indicate if any files need to be manually deleted and at which
	step to do so.</para>

      <para>These concerns have led to the recommended upgrade
	sequence described in the following procedure.</para>

      <note>
	<para>It is a good idea to save the output from running
	  <command>make</command> to a file.  If something goes wrong,
	  a copy of the error message can be posted to one of the &os;
	  mailing lists.</para>

	<para>The easiest way to do this is to use
	  <command>script</command> with a parameter that specifies
	  the name of the file to save all output to.  Do not save the
	  output to <filename>/tmp</filename> as this directory may be
	  cleared at next reboot.  A better place to save the file is
	  <filename>/var/tmp</filename>.  Run this command immediately
	  before rebuilding the world, and then type
	  <userinput>exit</userinput> when the process has
	  finished:</para>

	<screen>&prompt.root; <userinput>script <replaceable>/var/tmp/mw.out</replaceable></userinput>
Script started, output file is /var/tmp/mw.out</screen>
      </note>

      <procedure>
	<title>Overview of Build World Process</title>

	<para>The commands used in the build world process should be
	  run in the order specified here.  This section summarizes
	  the function of each command.</para>

	<step>
	  <para>If the build world process has previously been run on
	    this system, a copy of the previous build may still exist
	    in <filename>/usr/obj</filename>.  To
	    speed up the new build world process, and possibly save
	    some dependency headaches, remove this directory if it
	    already exists:</para>

	  <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/*</userinput>
&prompt.root; <userinput>rm -rf /usr/obj</userinput></screen>
	</step>

	<step>
	  <para>Compile the new compiler and a few related tools, then
	    use the new compiler to compile the rest of the new world.
	    The result is saved to <filename
	      >/usr/obj</filename>.</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput></screen>
	</step>

	<step>
	  <para>Use the new compiler residing in <filename
	      >/usr/obj</filename> to build the new
	    kernel, in order to protect against compiler-kernel
	    mismatches.  This is necessary, as certain memory
	    structures may have changed, and programs like
	    <command>ps</command> and <command>top</command> will fail
	    to work if the kernel and source code versions are not the
	    same.</para>

	  <screen>&prompt.root; <userinput>make buildkernel</userinput></screen>
	</step>

	<step>
	  <para>Install the new kernel and kernel modules, making it
	    possible to boot with the newly updated kernel.  If
	    <varname>kern.securelevel</varname> has been raised above
	    <literal>1</literal> <emphasis>and</emphasis>
	    <literal>noschg</literal> or similar flags have been set
	    on the kernel binary, drop the system into single-user
	    mode first.  Otherwise, this command can be run from
	    multi-user mode without problems.  See &man.init.8; for
	    details about <varname>kern.securelevel</varname> and
	    &man.chflags.1; for details about the various file
	    flags.</para>

	  <screen>&prompt.root; <userinput>make installkernel</userinput></screen>
	</step>

	<step>
	  <para>Drop the system into single-user mode in order to
	    minimize problems from updating any binaries that are
	    already running.  It also minimizes any problems from
	    running the old world on a new kernel.</para>

	  <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

	  <para>Once in single-user mode, run these commands if the
	    system is formatted with UFS:</para>

	  <screen>&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

	  <para>If the system is instead formatted with ZFS, run these
	    two commands.  This example assumes a zpool name of
	    <literal>zroot</literal>:</para>

	  <screen>&prompt.root; <userinput>zfs set readonly=off zroot</userinput>
&prompt.root; <userinput>zfs mount -a</userinput></screen>
	</step>

	<step>
	  <para>Optional: If a keyboard mapping other than the default
	    US English is desired, it can be changed with
	    &man.kbdmap.1;:</para>

	  <screen>&prompt.root; <userinput>kbdmap</userinput></screen>
	</step>

	<step>
	  <para>Then, for either file system, if the
	    <acronym>CMOS</acronym> clock is set to local time (this
	    is true if the output of &man.date.1; does not show the
	    correct time and zone), run:</para>

	  <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>
	</step>

	<step>
	  <para>Remaking the world will not update certain
	    directories, such as <filename>/etc</filename>,
	    <filename>/var</filename> and <filename>/usr</filename>,
	    with new or changed configuration files.  The next step is
	    to perform some initial configuration file updates
	    to <filename>/etc</filename> in
	    preparation for the new world.  The following command
	    compares only those files that are essential for the
	    success of <buildtarget>installworld</buildtarget>.  For
	    instance, this step may add new groups, system accounts,
	    or startup scripts which have been added to &os; since the
	    last update.  This is necessary so that the
	    <buildtarget>installworld</buildtarget> step will be able
	    to use any new system accounts, groups, and scripts.
	    Refer to <xref linkend="mergemaster"/> for more detailed
	    instructions about this command:</para>

	  <screen>&prompt.root; <userinput>mergemaster -p</userinput></screen>
	</step>

	<step>
	  <para>Install the new world and system binaries from
	    <filename>/usr/obj</filename>.</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>
	</step>

	<step>
	  <para>Update any remaining configuration files.</para>

	  <screen>&prompt.root; <userinput>mergemaster -iF</userinput></screen>
	</step>

	<step>
	  <para>Delete any obsolete files.  This is important as they
	    may cause problems if left on the disk.</para>

	  <screen>&prompt.root; <userinput>make delete-old</userinput></screen>
	</step>

	<step>
	  <para>A full reboot is now needed to load the new kernel and
	    new world with the new configuration files.</para>

	  <screen>&prompt.root; <userinput>reboot</userinput></screen>
	</step>

	<step>
	  <para>Make sure that all installed ports have first been
	    rebuilt before old libraries are removed using the
	    instructions in  <xref linkend="ports-upgrading"/>.  When
	    finished, remove any obsolete libraries to avoid conflicts
	    with newer ones.  For a more detailed description of this
	    step, refer to <xref linkend="make-delete-old"/>.</para>

	  <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
	</step>
      </procedure>

      <indexterm><primary>single-user mode</primary></indexterm>

      <para>If the system can have a window of down-time, consider
	compiling the system in single-user mode instead of compiling
	the system in multi-user mode, and then dropping into
	single-user mode for the installation.  Reinstalling the
	system touches a lot of important system files, all the
	standard system binaries, libraries, and include files.
	Changing these on a running system, particularly one with
	active users, is asking for trouble.</para>
    </sect2>

    <sect2 xml:id="src-updating">
      <title>Configuration Files</title>

      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>This build world process uses several configuration
	files.</para>

      <para>The <filename>Makefile</filename> located in
	<filename>/usr/src</filename> describes how the programs that
	comprise &os; should be built and the order in which they
	should be built.</para>

      <para>The options available to <command>make</command> are
	described in &man.make.conf.5; and some common examples are
	included in
	<filename>/usr/share/examples/etc/make.conf</filename>.  Any
	options which are added to <filename>/etc/make.conf</filename>
	will control the how <command>make</command> runs and builds
	programs.  These options take effect every time
	<command>make</command> is used, including compiling
	applications from the Ports Collection, compiling custom C
	programs, or building the &os; operating system.  Changes to
	some settings can have far-reaching and potentially surprising
	effects.  Read the comments in both locations and keep in mind
	that the defaults have been chosen for a combination of
	performance and safety.</para>

      <indexterm>
	<primary><filename>src.conf</filename></primary>
      </indexterm>

      <para>How the operating system is built from source code is
	controlled by <filename>/etc/src.conf</filename>.  Unlike
	<filename>/etc/make.conf</filename>, the contents of
	<filename>/etc/src.conf</filename> only take effect when the
	&os; operating system itself is being built.  Descriptions of
	the many options available for this file are shown in
	&man.src.conf.5;.  Be cautious about disabling seemingly
	unneeded kernel modules and build options.  Sometimes there
	are unexpected or subtle interactions.</para>
    </sect2>

    <sect2 xml:id="make-buildworld">
      <title>Variables and Targets</title>

      <para>The general format for using <command>make</command> is as
	follows:</para>

      <screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

      <para>In this example,
	<option>-<replaceable>x</replaceable></option> is an option
	passed to <command>make</command>.  Refer to &man.make.1; for
	examples of the available options.</para>

      <para>To pass a variable, specify the variable name with
	<option>-D<replaceable>VARIABLE</replaceable></option>.  The
	behavior of the <filename>Makefile</filename> is controlled by
	variables.  These can either be set in
	<filename>/etc/make.conf</filename> or they can be specified
	when using <command>make</command>.  For example, this
	variable specifies that profiled libraries should not be
	built:</para>

      <screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

      <para>It corresponds with this setting in
	<filename>/etc/make.conf</filename>:</para>

      <programlisting>NO_PROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

      <para>The <replaceable>target</replaceable> tells
	<command>make</command> what to do and the
	<filename>Makefile</filename> defines the available targets.
	Some targets are used by the build process to break out the
	steps necessary to rebuild the system into a number of
	sub-steps.</para>

      <para>Having separate options is useful for two reasons.  First,
	it allows for a build that does not affect any components of a
	running system.  Because of this,
	<buildtarget>buildworld</buildtarget> can be safely run on a
	machine running in multi-user mode.  It is still recommended
	that <buildtarget>installworld</buildtarget> be run in part in
	single-user mode, though.</para>

      <para>Secondly, it allows <acronym>NFS</acronym> mounts to be
	used to upgrade multiple machines on a network, as described
	in <xref linkend="small-lan"/>.</para>

      <para>It is possible to specify <option>-j</option> which will
	cause <command>make</command> to spawn several simultaneous
	processes.  Since much of the compiling process is
	<acronym>I/O</acronym>-bound rather than
	<acronym>CPU</acronym>-bound, this is useful on both single
	<acronym>CPU</acronym> and multi-<acronym>CPU</acronym>
	machines.</para>

      <para>On a single-<acronym>CPU</acronym> machine, run the
	following command to have up to 4 processes running at any one
	time.  Empirical evidence posted to the mailing lists shows
	this generally gives the best performance benefit.</para>

      <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

      <para>On a multi-<acronym>CPU</acronym> machine, try values
	between <literal>6</literal> and <literal>10</literal> to see
	how they speed things up.</para>

      <indexterm>
	<primary>rebuilding <quote>world</quote></primary>
	<secondary>timings</secondary>
      </indexterm>

      <note>
	<para>If any variables were specified to <command>make
	    buildworld</command>, specify the same variables to
	  <command>make installworld</command>.  However,
	  <option>-j</option> must <emphasis>never</emphasis> be used
	  with <buildtarget>installworld</buildtarget>.</para>

	<para>For example, if this command was used:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>Install the results with:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>Otherwise, the second command will try to install
	  profiled libraries that were not built during the
	  <command>make buildworld</command> phase.</para>
      </note>
    </sect2>

    <sect2 xml:id="mergemaster">
      <info>
      <title>Merging Configuration Files</title>

	  <authorgroup>
	    <author>
	      <personname>
		<firstname>Tom</firstname>
		<surname>Rhodes</surname>
	      </personname>
	      <contrib>Contributed by </contrib>
	    </author>
	  </authorgroup>
	</info>

	<indexterm>
	  <primary>
	    <command>mergemaster</command>
	  </primary>
	</indexterm>

      <para>&os; provides the &man.mergemaster.8; Bourne script to aid
	in determining the differences between the configuration files
	in <filename>/etc</filename>, and the configuration files in
	<filename>/usr/src/etc</filename>.  This is the recommended
	solution for keeping the system configuration files up to date
	with those located in the source tree.</para>

      <para>Before using <command>mergemaster</command>, it is
	recommended to first copy the existing
	<filename>/etc</filename> somewhere safe.  Include
	<option>-R</option> which does a recursive copy and
	<option>-p</option> which preserves times and the ownerships
	on files:</para>

      <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

      <para>When run, <command>mergemaster</command> builds a
	temporary root environment, from <filename>/</filename> down,
	and populates it with various system configuration files.
	Those files are then compared to the ones currently installed
	in the system.  Files that differ will be shown in
	&man.diff.1; format, with the <option>+</option> sign
	representing added or modified lines, and <option>-</option>
	representing lines that will be either removed completely or
	replaced with a new file.  Refer to &man.diff.1; for more
	information about how file differences are shown.</para>

      <para>Next, <command>mergemaster</command> will display each
	file that differs, and present options to: delete the new
	file, referred to as the temporary file, install the temporary
	file in its unmodified state, merge the temporary file with
	the currently installed file, or view the results
	again.</para>

      <para>Choosing to delete the temporary file will tell
	<command>mergemaster</command> to keep the current file
	unchanged and to delete the new version.  This option is not
	recommended.  To get help at any time, type
	<keycap>?</keycap> at the <command>mergemaster</command>
	prompt.  If the user chooses to skip a file, it will be
	presented again after all other files have been dealt
	with.</para>

      <para>Choosing to install the unmodified temporary file will
	replace the current file with the new one.  For most
	unmodified files, this is the best option.</para>

      <para>Choosing to merge the file will present a text editor, and
	the contents of both files.  The files can be merged by
	reviewing both files side by side on the screen, and choosing
	parts from both to create a finished product.  When the files
	are compared side by side, <keycap>l</keycap> selects the left
	contents and <keycap>r</keycap> selects contents from the
	right.  The final output will be a file consisting of both
	parts, which can then be installed.  This option is
	customarily used for files where settings have been modified
	by the user.</para>

      <para>Choosing to view the results again will redisplay the file
	differences.</para>

      <para>After <command>mergemaster</command> is done with the
	system files, it will prompt for other options.  It may prompt
	to rebuild the password file and will finish up with an option
	to remove left-over temporary files.</para>
<!--
Probably not needed as changes should be minimal and mergemaster does
a good job of merging.
	<tip>
	  <title>Name the New Root Directory
	    (<filename>/var/tmp/root</filename>)
	    with a Time Stamp, so You Can Easily Compare Differences
	    Between Versions</title>

	  <para>Frequently rebuilding world entails frequently
	    updating <filename>/etc</filename>
	    as well, which can be a bit of a chore.</para>

	  <para>To speed up this process, use the following
	    procedure to keep a copy of the last set of changed files
	    that were merged into <filename>/etc</filename>.</para>

	  <procedure>
	    <step>
	      <para>Make the world as normal.  When updating
		<filename>/etc</filename> and the
		other directories, give the target directory a name
		based on the current date:</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-20130214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-20130214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Merge in the changes from this directory as
		outlined above.  <emphasis>Do not</emphasis> remove
		the <filename>/var/tmp/root-20130214</filename>
		directory when you have finished.</para>
	    </step>

	    <step>
	      <para>After downloading the latest version of the
		source and remaking it, follow step 1.  Create a new
		directory, which reflects the new date.  This example
		uses
		<filename>/var/tmp/root-20130221</filename>.</para>
	    </step>

	    <step>
	      <para>Use &man.diff.1; to see the differences that have
		been made in the intervening week by creating a
		recursive diff between the two directories:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-20130214 root-20130221</userinput></screen>

	      <para>Typically, this will be a much smaller set of
		differences than those between
		<filename>/var/tmp/root-20130221/etc</filename> and
		<filename>/etc</filename>.  Because the set of
		differences is smaller, it is easier to migrate those
		changes across into <filename>/etc</filename>.</para>
	    </step>

	    <step>
	      <para>When finished, remove the older of the two
		<filename>/var/tmp/root-*</filename>
		directories:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-20130214</userinput></screen>
	    </step>

	    <step>
	      <para>Repeat this process whenever merging
		in changes to <filename>/etc</filename>.</para>
	    </step>
	  </procedure>

	  <para>Use &man.date.1; to automate the generation of the
	    directory names:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
	-->
    </sect2>

    <sect2 xml:id="make-delete-old">
      <info>
	<title>Deleting Obsolete Files and Libraries</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Anton</firstname>
	      <surname>Shterenlikht</surname>
	    </personname>
	    <contrib>Based on notes provided by </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>Deleting obsolete files and directories</primary>
      </indexterm>

      <para>As a part of the &os; development lifecycle, files and
	their contents occasionally become obsolete.  This may be
	because functionality is implemented elsewhere, the version
	number of the library has changed, or it was removed from the
	system entirely.  These obsoleted files, libraries, and
	directories should be removed when updating the system.
	This ensures that the system is not cluttered with old files
	which take up unnecessary space on the storage and backup
	media.  Additionally, if the old library has a security or
	stability issue, the system should be updated to the newer
	library to keep it safe and to prevent crashes caused by the
	old library.  Files, directories, and libraries which are
	considered obsolete are listed in
	<filename>/usr/src/ObsoleteFiles.inc</filename>.  The
	following instructions should be used to remove obsolete files
	during the system upgrade process.</para>

      <para>After the <command>make installworld</command> and the
	subsequent <command>mergemaster</command> have finished
	successfully, check for obsolete files and libraries:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

      <para>If any obsolete files are found, they can be deleted using
	the following command:</para>

      <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

      <para>A prompt is displayed before deleting each obsolete file.
	To skip the prompt and let the system remove these files
	automatically, use
	<varname>BATCH_DELETE_OLD_FILES</varname>:</para>

      <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

      <para>The same goal can be achieved by piping these commands
	through <command>yes</command>:</para>

      <screen>&prompt.root; <userinput>yes|make delete-old</userinput></screen>

      <warning>
	<title>Warning</title>

	<para>Deleting obsolete files will break applications that
	  still depend on those obsolete files.  This is especially
	  true for old libraries.  In most cases, the programs, ports,
	  or libraries that used the old library need to be recompiled
	  before <command>make delete-old-libs</command> is
	  executed.</para>
      </warning>

      <para>Utilities for checking shared library dependencies include
	<package>sysutils/libchk</package> and
	<package>sysutils/bsdadminscripts</package>.</para>

      <para>Obsolete shared libraries can conflict with newer
	libraries, causing messages like these:</para>

      <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

      <para>To solve these problems, determine which port installed
	the library:</para>

      <screen>&prompt.root; <userinput>pkg which /usr/local/lib/libtiff.so</userinput>
  /usr/local/lib/libtiff.so was installed by package tiff-3.9.4
&prompt.root; <userinput>pkg which /usr/local/lib/libXext.so</userinput>
  /usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

      <para>Then deinstall, rebuild, and reinstall the port.  To
	automate this process,
	<package>ports-mgmt/portmaster</package> can be used.  After
	all ports are rebuilt and no longer use the old libraries,
	delete the old libraries using the following command:</para>

      <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>

      <para>If something goes wrong, it is easy to rebuild a
	particular piece of the system.  For example, if
	<filename>/etc/magic</filename> was accidentally deleted as
	part of the upgrade or merge of <filename>/etc</filename>,
	<command>file</command> will stop working.  To fix this,
	run:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>Common Questions</title>

      <variablelist>
	<varlistentry>
	  <term>Do I need to re-make the world for every
	      change?</term>

	  <listitem>
	    <para>It depends upon the nature of the change.  For
	      example, if <application>svn</application> only shows
	      the following files as being updated:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>it probably is not worth rebuilding the entire
	      world.  Instead, go into the appropriate sub-directories
	      and run <command>make all install</command>.  But if
	      something major changes, such as
	      <filename>src/lib/libc/stdlib</filename>, consider
	      rebuilding world.</para>

	    <para>Some users rebuild world every fortnight and let
	      changes accumulate over that fortnight.  Others only
	      re-make those things that have changed and are careful
	      to spot all the dependencies.  It all depends on how
	      often a user wants to upgrade and whether they are
	      tracking &os.stable; or &os.current;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>What would cause a compile to fail with lots of
	    signal 11<indexterm>
	      <primary>signal 11</primary>
	    </indexterm>
	    (or other signal number) errors?</term>

	  <listitem>
	    <para>This normally indicates a hardware problem.
	      Building world is an effective way to stress test
	      hardware, especially memory.  A sure indicator of a
	      hardware issue is when <application>make</application>
	      is restarted and it dies at a different point in the
	      process.</para>

	    <para>To resolve this error, swap out the components in
	      the machine, starting with RAM, to determine which
	      component is failing.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Can <filename>/usr/obj</filename>
	      be removed when finished?</term>

	  <listitem>
	    <para>This directory contains all the object files that
	      were produced during the compilation phase.  Normally,
	      one of the first steps in the <command>make
		buildworld</command> process is to remove this
	      directory and start afresh.  Keeping
	      <filename>/usr/obj</filename> around when finished makes
	      little sense, and its removal frees up a approximately
	      2GB of disk space.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Can interrupted builds be resumed?</term>

	  <listitem>
	    <para>This depends on how far into the process the
	      problem occurs.  In general, <command>make
		buildworld</command> builds new copies of essential
	      tools and the system libraries.  These tools and
	      libraries are then installed, used to rebuild
	      themselves, and are installed again.  The rest of the
	      system is then rebuilt with the new system
	      tools.</para>

	    <para>During the last stage, it is fairly safe to run
	      these commands as they will not undo the work of the
	      previous <command>make buildworld</command>:</para>

	    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>If this message appears:</para>

	    <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>in the <command>make buildworld</command> output,
	      it is probably fairly safe to do so.</para>

	    <para>If that message is not displayed, it is always
	      better to be safe than sorry and to restart the build
	      from scratch.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Is it possible to speed up making the world?</term>

	  <listitem>
	    <para>Several actions can speed up the build world
	      process.  For example, the entire process can be run
	      from single-user mode.  However, this will prevent users
	      from having access to the system until the process is
	      complete.</para>

	    <para>Careful file system design or the use of ZFS
	      datasets can make a difference.  Consider putting
	      <filename>/usr/src</filename> and
	      <filename>/usr/obj</filename> on
	      separate file systems.  If possible, place the file
	      systems on separate disks on separate disk controllers.
	      When mounting <filename
		>/usr/src</filename>, use
	      <option>noatime</option> which prevents the file system
	      from recording the file access time.  If <filename
		>/usr/src</filename> is not on its
	      own file system, consider remounting <filename
		>/usr</filename> with
	      <option>noatime</option>.</para>

	    <para>The file system holding <filename
		>/usr/obj</filename> can be mounted
	      or remounted with <option>async</option> so that disk
	      writes happen asynchronously.  The write completes
	      immediately, and the data is written to the disk a few
	      seconds later.  This allows writes to be clustered
	      together, and can provide a dramatic performance
	      boost.</para>

	    <warning>
	      <para>Keep in mind that this option makes the file
		system more fragile.  With this option, there is an
		increased chance that, should power fail, the file
		system will be in an unrecoverable state when the
		machine restarts.</para>

	      <para>If <filename>/usr/obj</filename> is the only
		directory on this file system, this is not a problem.
		If you have other, valuable data on the same file
		system, ensure that there are verified backups before
		enabling this option.</para>
	    </warning>

	    <para>Turn off profiling by setting
	      <quote>NO_PROFILE=true</quote> in
	      <filename>/etc/make.conf</filename>.</para>

	    <para>Pass <option>-j<replaceable>n</replaceable></option>
	      to &man.make.1; to run multiple processes in parallel.
	      This usually helps on both single- and multi-processor
	      machines.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>What if something goes wrong?</term>

	  <listitem>
	    <para>First, make absolutely sure that the environment has
	      no extraneous cruft from earlier builds:</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Yes, <command>make cleandir</command> really should
	      be run twice.</para>

	    <para>Then, restart the whole process, starting with
	      <command>make buildworld</command>.</para>

	    <para>If problems persist, send the error and the output
	      of <command>uname -a</command> to &a.questions;.  Be
	      prepared to answer other questions about the
	      setup!</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info>
      <title>追蹤多追蹤多部機器</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mike</firstname>
	    <surname>Meyer</surname>
	  </personname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>NFS</primary>
      <secondary>安裝多部機器</secondary>
    </indexterm>

    <para>當有多部機器需要追蹤同一個原始碼樹，
      會浪費磁碟空間，網路頻寬，和
      <acronym>中央處理器</acronym>周期來讓每個系統下載原始碼和編譯所有東西。
      解決方法是有解決方法是有一台機器做大部份的工作，剩下的機器經由
      <acronym>NFS</acronym>來掛載這個工作。這一節概述了一個如此做的方法。
      更多關於使用 <acronym>NFS</acronym>的資訊，請參考<xref
	linkend="network-nfs"/>。</para>

    <para>First, identify a set of machines which will run the same
      set of binaries, known as a <firstterm>build set</firstterm>.
      Each machine can have a custom kernel, but will run the same
      userland binaries.  From that set, choose a machine to be the
      <firstterm>build machine</firstterm> that the world and kernel
      are built on.  Ideally, this is a fast machine that has
      sufficient spare <acronym>CPU</acronym> to run <command>make
	buildworld</command> and <command>make
	buildkernel</command>.</para>

    <para>Select a machine to be the <firstterm>test
	machine</firstterm>, which will test software updates before
      they are put into production.  This <emphasis>must</emphasis> be
      a machine that can afford to be down for an extended period of
      time.  It can be the build machine, but need not be.</para>

    <para>All the machines in this build set need to mount
      <filename>/usr/obj</filename> and <filename>/usr/src</filename>
      from the build machine via <acronym>NFS</acronym>.  For multiple
      build sets, <filename>/usr/src</filename> should be on one build
      machine, and <acronym>NFS</acronym> mounted on the rest.</para>

    <para>Ensure that <filename>/etc/make.conf</filename> and
      <filename>/etc/src.conf</filename> on all the machines in the
      build set agree with the build machine.  That means that the
      build machine must build all the parts of the base system that
      any machine in the build set is going to install.  Also, each
      build machine should have its kernel name set with
      <varname>KERNCONF</varname> in
      <filename>/etc/make.conf</filename>, and the build machine
      should list them all in its <varname>KERNCONF</varname>,
      listing its own kernel first.  The build machine must have the
      kernel configuration files for each machine in its <filename
	>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>.</para>

    <para>On the build machine, build the kernel and world as
      described in <xref linkend="makeworld"/>, but do not install
      anything on the build machine.  Instead, install the built
      kernel on the test machine.  On the test machine, mount
      <filename>/usr/src</filename> and
      <filename>/usr/obj</filename> via <acronym>NFS</acronym>.  Then,
      run <command>shutdown now</command> to go to single-user mode in
      order to install the new kernel and world and run
      <command>mergemaster</command> as usual.  When done, reboot to
      return to normal multi-user operations.</para>

    <para>After verifying that everything on the test machine is
      working properly, use the same procedure to install the new
      software on each of the other machines in the build set.</para>

    <para>The same methodology can be used for the ports tree.  The
      first step is to share <filename>/usr/ports</filename> via
      <acronym>NFS</acronym> to all the machines in the build set.  To
      configure <filename>/etc/make.conf</filename> to share
      distfiles, set <varname>DISTDIR</varname> to a common shared
      directory that is writable by whichever user <systemitem
	class="username">root</systemitem> is mapped to by the
      <acronym>NFS</acronym> mount.  Each machine should set
      <varname>WRKDIRPREFIX</varname> to a local build directory, if
      ports are to be built locally.  Alternately, if the build system
      is to build and distribute packages to the machines in the build
      set, set <varname>PACKAGES</varname> on the build system to a
      directory similar to <varname>DISTDIR</varname>.</para>
  </sect1>
</chapter>
