<?xml version="1.0" encoding="big5"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     Original revision: 1.113
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="multimedia">
 <info><title>多媒體影音娛樂(Multimedia)</title>
  <authorgroup>
   <author><personname><firstname>Ross</firstname><surname>Lippert</surname></personname><contrib>Edited by </contrib></author>
  </authorgroup>
 </info>

 
  <sect1 xml:id="multimedia-synopsis">
  <title>概述</title>

    <para>FreeBSD 廣泛地支援各種音效卡， 讓您可以享受來自電腦上的高傳真音質(Hi-Fi)，
	此外還包括了錄製和播放 MPEG Audio Layer 3 (MP3)、 WAV、 以及 Ogg Vorbis
	等許多種格式聲音的能力。同時 FreeBSD Ports Collection 也包括了許多的應用程式，
	讓您可以錄音、編修音效以及控制 MIDI 配備。</para>

    <para>要是喜歡動手嘗試不同的體驗， FreeBSD 也能播放一般的視訊檔和 DVD。
	編碼、轉換和播放視訊的程式比起處理聲音的程式略少一些。例如， 在撰寫這章時，
	FreeBSD Ports Collection 中還沒有類似 <package>audio/sox</package> 那樣好用的編碼工具，能夠用來轉換不同的格式。
	不過，這個領域的軟體研發進展是相當迅速的。</para>

    <para>本章將介紹設定音效卡的必要步驟。先前介紹到的 X11
      (<xref linkend="x11"/>) 安裝和設定裡，已經講到了顯示卡的部份，
	但要想有更好的播放效果， 仍需要一些細部調整。</para>

    <para>讀完這章，您將了解：</para>

    <itemizedlist>
      <listitem>
        <para>如何設定系統，以正確識別音效卡。</para>
      </listitem>

      <listitem>
        <para>如何運用樣本程式，以測試音效卡是否正常運作。</para>
      </listitem>

      <listitem>
        <para>如何解決音效卡的設定問題。</para>
      </listitem>

      <listitem>
        <para>如何播放、錄製 MP3 及其他聲音檔案格式。</para>
      </listitem>

      <listitem>
        <para>X server 是如何支援顯示卡。</para>
      </listitem>

      <listitem>
        <para>Ports Collections 內有哪些好用的影像播放、錄製軟體。</para>
      </listitem>

      <listitem>
        <para>如何播放 DVD 的 <filename>.mpg</filename> 及
          <filename>.avi</filename> 檔</para>
      </listitem>

      <listitem>
        <para>如何從 CD 和 DVD 中擷取(rip)檔案。</para>
      </listitem>

      <listitem>
	<para>如何設定電視卡</para>
      </listitem>

      <listitem>
	<para>如何設定掃描器</para>
      </listitem>
    </itemizedlist>

    <para>在閱讀這章之前，您應當了解：</para>

    <itemizedlist>
      <listitem><para>知道如何設定、安裝新的 kernel (<xref linkend="kernelconfig"/>)。</para></listitem>
    </itemizedlist>

    <warning>
      <para>如果要用 &man.mount.8; 指令來 mount 音樂光碟的話，通常會發生錯誤，
        甚至導致 <emphasis>kernel panic</emphasis>。 這是因為音樂光碟是特殊編碼，而非一般的 ISO 檔案系統之故。</para>
    </warning>

  </sect1>

  <sect1 xml:id="sound-setup">
    <info><title>設定音效卡</title>
      <authorgroup>
        <author><personname><firstname>Moses</firstname><surname>Moore</surname></personname><contrib>Contributed by </contrib></author>
      </authorgroup>
      <authorgroup>
        <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>加強 &os;&nbsp;5.X 的內容：</contrib></author>
      </authorgroup>
    </info>

    

  <sect2 xml:id="sound-device">
    <title>設定系統</title>

    <indexterm><primary>PCI</primary></indexterm>
    <indexterm><primary>ISA</primary></indexterm>
    <indexterm><primary>sound cards</primary></indexterm>
    <para>開始設定之前，必須先知道你的音效卡型號、晶片為何，以及是 PCI 或 ISA 規格。
      FreeBSD 有支援許多種的 PCI、ISA 音效卡，請檢查支援的音效硬體表 <link xlink:href="&rel.current.hardware;">Hardware Notes</link>，以確認你的音效卡是否支援。
      本文也會提到相對應該卡的驅動程式。</para>

    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration</secondary>
    </indexterm>

    <para>要使用音效卡，必須要載入正確的驅動程式才行。有兩種方式都可以完成這動作，
      最簡單方式就是以 &man.kldload.8; 來輕鬆載入 kernel 動態模組(module)，
      像是下列指令：</para>

    <screen>&prompt.root; <userinput>kldload snd_emu10k1</userinput></screen>

    <para>或者把相關驅動程式加到
      <filename>/boot/loader.conf</filename> 檔，像是：</para>

    <programlisting>snd_emu10k1_load="YES"</programlisting>

    <para>上面例子是給 Creative &soundblaster; Live! 音效卡使用的。
      其他可用的音效卡驅動程式模組，可參考
      <filename>/boot/defaults/loader.conf</filename> 範例。
      若不確定到底該用哪一種驅動程式，那麼可以試試載入 <filename>snd_driver</filename>
      模組看看：</para>

    <screen>&prompt.root; <userinput>kldload snd_driver</userinput></screen>

    <para>This is a metadriver loading the most common device drivers
      at once.  This speeds up the search for the correct driver.  It
      is also possible to load all sound drivers via the
      <filename>/boot/loader.conf</filename> facility.</para>

    <para>If you wish to find out the driver selected for your
      soundcard after loading the <filename>snd_driver</filename>
      metadriver, you may check the <filename>/dev/sndstat</filename>
      file with the <command>cat /dev/sndstat</command>
      command.</para>

    <note>
      <para>Under &os;&nbsp;4.X, to load all sound drivers, you have
	to load the <filename>snd</filename> module instead of
	<filename>snd_driver</filename>.</para>
    </note>

    <para>A second method is to statically
      compile in support for your sound card in your kernel.  The
      section below provides the information you need to add support
      for your hardware in this manner.  For more information about
      recompiling your kernel, please see <xref linkend="kernelconfig"/>.</para>

    <sect3>
      <title>Configuring a Custom Kernel with Sound Support</title>

      <para>The first thing to do is adding the generic audio driver
	&man.sound.4; to the kernel, for that you will need to
	add the following line to the kernel configuration file:</para>

      <programlisting>device sound</programlisting>

      <para>Under &os;&nbsp;4.X, you would use the following
	line:</para>

      <programlisting>device pcm</programlisting>

      <para>Then we have to add the support for our sound card.
	Therefore, we need to know which driver supports the card.
	Check the supported audio devices list of the <link xlink:href="&rel.current.hardware;">Hardware Notes</link>, to
	determine the correct driver for your sound card.  For
	example, a Creative &soundblaster; Live! sound card is
	supported by the &man.snd.emu10k1.4; driver.  To add the support
	for this card, use the following:</para>

      <programlisting>device snd_emu10k1</programlisting>

      <para>Be sure to read the manual page of the driver for the
	syntax to use.  Information regarding the syntax of sound
	drivers in the kernel configuration can also be found in the
	<filename>/usr/src/sys/conf/NOTES</filename> file
	(<filename>/usr/src/sys/i386/conf/LINT</filename> for
	&os;&nbsp;4.X).</para>

      <para>Non-PnP ISA cards may require you to provide the kernel
	with information on the sound card settings (IRQ, I/O port,
	etc).  This is done via the
	<filename>/boot/device.hints</filename> file.  At system boot,
	the &man.loader.8; will read this file and pass the settings
	to the kernel.  For example, an old
	Creative &soundblaster; 16 ISA non-PnP card will use the
	&man.snd.sbc.4; driver in conjunction with snd_sb16(4).  For this card the following lines have to be added to
	the kernel configuration file:</para>

      <programlisting>device snd_sbc
device snd_sb16</programlisting>

      <para>as well as the following in
	<filename>/boot/device.hints</filename>:</para>

      <programlisting>hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"</programlisting>

      <para>In this case, the card uses the <literal>0x220</literal>
	I/O port and the IRQ <literal>5</literal>.</para>

      <para>The syntax used in the
	<filename>/boot/device.hints</filename> file is covered in the
	sound driver manual page.  On &os;&nbsp;4.X, these settings
	are directly written in the kernel configuration file.  In the
	case of our ISA card, we would only use this line:</para>

      <programlisting>device sbc0 at isa? port 0x220 irq 5 drq 1 flags 0x15</programlisting>

      <para>The settings shown above are the defaults.  In some
	cases, you may need to change the IRQ or the other settings to
	match your card.  See the &man.snd.sbc.4; manual page for more
	information.</para>

      <note>
	<para>Under &os;&nbsp;4.X, some systems with built-in
	  motherboard sound devices may require the following option in
	  the kernel configuration:</para>

	<programlisting>options PNPBIOS</programlisting>
      </note>
    </sect3>
  </sect2>

  <sect2 xml:id="sound-testing">
    <title>Testing the Sound Card</title>

    <para>After rebooting with the modified kernel, or after loading
      the required module, the sound card should appear in your system
      message buffer (&man.dmesg.8;) as something like:</para>

    <screen>pcm0: &lt;Intel ICH3 (82801CA)&gt; port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</screen>

    <para>The status of the sound card may be checked via the
      <filename>/dev/sndstat</filename> file:</para>

    <screen>&prompt.root; <userinput>cat /dev/sndstat</userinput>
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: &lt;Intel ICH3 (82801CA)&gt; at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)</screen>

    <para>The output from your system may vary.  If no
      <filename>pcm</filename> devices show up, go back and review
      what was done earlier.  Go through your kernel
      configuration file again and make sure the correct
      device is chosen.  Common problems are listed in <xref linkend="troubleshooting"/>.</para>

    <para>If all goes well, you should now have a functioning sound
      card.  If your CD-ROM or DVD-ROM drive is properly coupled to
      your sound card, you can put a CD in the drive and play it
      with &man.cdcontrol.1;:</para>

      <screen>&prompt.user; <userinput>cdcontrol -f /dev/acd0 play 1</userinput></screen>

    <para>Various applications, such as <package>audio/workman</package> can provide a friendlier
      interface.  You may want to install an application such as
      <package>audio/mpg123</package> to listen to
      MP3 audio files.  A quick way to test the card is sending data
      to the <filename>/dev/dsp</filename>, like this:</para>

    <screen>&prompt.user; <userinput>cat filename &gt; /dev/dsp</userinput></screen>

    <para>where <replaceable>filename</replaceable> can be any file.
      This command line should produce some noise, confirming the
      sound card is actually working.</para>

    <note>
      <para>&os;&nbsp;4.X users need to create the sound card device
	nodes before being able to use it.  If the card showed up in
	message buffer as <filename>pcm0</filename>, you will have
	to run the following as <systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV snd0</userinput></screen>

      <para>If the card detection returned <filename>pcm1</filename>,
	follow the same steps as shown above, replacing
	<filename>snd0</filename> with
	<filename>snd1</filename>.</para>

      <para><command>MAKEDEV</command> will create a group of device
	nodes that will be used by the different sound related
	applications.</para>
    </note>

    <para>Sound card mixer levels can be changed via the &man.mixer.8;
      command.  More details can be found in the &man.mixer.8; manual
      page.</para>

    <sect3 xml:id="troubleshooting">
      <title>Common Problems</title>

      <indexterm><primary>device nodes</primary></indexterm>
      <indexterm><primary>I/O port</primary></indexterm>
      <indexterm><primary>IRQ</primary></indexterm>
      <indexterm><primary>DSP</primary></indexterm>

      <informaltable frame="none" pgwide="1">
         <tgroup cols="2">
  	  <thead>
	    <row>
	     <entry>Error</entry>
	      <entry>Solution</entry>
	    </row>
          </thead>

	  <tbody>
	    <row>
	      <entry><errorname>unsupported subdevice XX</errorname></entry>
	      <entry><para>One or more of the device nodes was not created
	        correctly.  Repeat the steps above.</para></entry>
            </row>

            <row>
              <entry><errorname>sb_dspwr(XX) timed out</errorname></entry>
              <entry><para>The I/O port is not set correctly.</para></entry>
            </row>

            <row>
              <entry><errorname>bad irq XX</errorname></entry>
	      <entry><para>The IRQ is set incorrectly.  Make sure that
  	        the set IRQ and the sound IRQ are the same.</para></entry>
            </row>

            <row>
              <entry><errorname>xxx: gus pcm not attached, out of memory</errorname></entry>
              <entry><para>There is not enough available memory to use
                the device.</para></entry>
            </row>

            <row>
              <entry><errorname>xxx: can't open /dev/dsp!</errorname></entry>
              <entry><para>Check with <command>fstat | grep dsp</command>
                if another application is holding the device open.
                Noteworthy troublemakers are <application>esound</application> and <application>KDE</application>'s sound
                support.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect3>
  </sect2>

  <sect2 xml:id="sound-multiple-sources">
    <info><title>Utilizing Multiple Sound Sources</title>
     <authorgroup>
      <author><personname><firstname>Munish</firstname><surname>Chopra</surname></personname><contrib>Contributed by </contrib></author>
     </authorgroup>
    </info>
    

    <para>It is often desirable to have multiple sources of sound that
      are able to play simultaneously, such as when
      <application>esound</application> or
      <application>artsd</application> do not support sharing of the
      sound device with a certain application.</para>

    <para>FreeBSD lets you do this through <emphasis>Virtual Sound
      Channels</emphasis>, which can be set with the &man.sysctl.8;
      facility.  Virtual channels allow you to multiplex your sound
      card's playback channels by mixing sound in the kernel.</para>

    <para>To set the number of virtual channels, there are two sysctl
      knobs which, if you are the <systemitem class="username">root</systemitem> user, can
      be set like this:</para>
    <screen>&prompt.root; <userinput>sysctl hw.snd.pcm0.vchans=4</userinput>
&prompt.root; <userinput>sysctl hw.snd.maxautovchans=4</userinput></screen>

    <para>The above example allocates four virtual channels, which is a
      practical number for everyday use.  <varname>hw.snd.pcm0.vchans</varname>
      is the number of virtual channels <filename>pcm0</filename> has, and is configurable
      once a device has been attached.
      <literal>hw.snd.maxautovchans</literal> is the number of virtual channels
      a new audio device is given when it is attached using
      &man.kldload.8;.  Since the <filename>pcm</filename> module
      can be loaded independently of the hardware drivers,
      <varname>hw.snd.maxautovchans</varname> can store how many
      virtual channels any devices which are attached later will be
      given.</para>

    <note>
      <para>You cannot change the number of virtual channels for a
	device while it is in use.  First close any programs using the
	device, such as music players or sound daemons.</para>
    </note>

    <para>If you are not using &man.devfs.5;, you will have to point
      your applications at
      <filename>/dev/dsp0</filename>.<replaceable>x</replaceable>,
      where <replaceable>x</replaceable> is 0 to 3 if
      <varname>hw.snd.pcm.0.vchans</varname> is set to 4 as in the
      above example.  On a system using &man.devfs.5;, the above will
      automatically be allocated transparently to the user.</para>
   </sect2>

  <sect2>
    <info><title>設定預設(Mixer Channel)的音量大小</title>
      <authorgroup>
	<author><personname><firstname>Josef</firstname><surname>El-Rayes</surname></personname><contrib>Contributed by </contrib></author>
      </authorgroup>
    </info>

    

    <note>
      <para>本功能只有在 &os; 5.3-RELEASE 及之後版本才有支援。</para>
    </note>

    <para>The default values for the different mixer channels are
      hardcoded in the sourcecode of the &man.pcm.4; driver.  There are
      a lot of different applications and daemons that allow
      you to set values for the mixer they remember and set
      each time they are started, but this is not a clean
      solution, we want to have default values at the driver
      level.  This is accomplished by defining the appropriate
      values in <filename>/boot/device.hints</filename>. E.g.:</para>
<programlisting>hint.pcm.0.vol="100"</programlisting>

    <para>This will set the volume channel to a default value of
      100, when the &man.pcm.4; module is loaded.</para>
  </sect2>
</sect1>

  <sect1 xml:id="sound-mp3">
    <info><title>MP3 音樂</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Contributed by </contrib></author>
      </authorgroup>
      
    </info>

    

    <para>MP3 (MPEG Layer 3 Audio) accomplishes near CD-quality sound,
      leaving no reason to let your FreeBSD workstation fall short of
      its offerings.</para>

    <sect2 xml:id="mp3-players">
      <title>MP3 Players</title>

      <para>By far, the most popular X11 MP3 player is
	<application>XMMS</application> (X Multimedia System).
	<application>Winamp</application>
	skins can be used with <application>XMMS</application> since the
	GUI is almost identical to that of Nullsoft's
	<application>Winamp</application>.
	<application>XMMS</application> also has native plug-in
	support.</para>

      <para><application>XMMS</application> can be installed from the
	<package>multimedia/xmms</package> port or package.</para>

      <para><application>XMMS'</application> interface is intuitive,
	with a playlist, graphic equalizer, and more.  Those familiar
	with <application>Winamp</application> will find
	<application>XMMS</application> simple to use.</para>

      <para>The <package>audio/mpg123</package> port is an alternative,
	command-line MP3 player.</para>

      <para><application>mpg123</application> can be run by specifying
	the sound device and the MP3 file on the command line, as
	shown below:</para>

      <screen>&prompt.root; <userinput>mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3</userinput>
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!





Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
</screen>

      <para><literal>/dev/dsp1.0</literal> should be replaced with the
	<filename>dsp</filename> device entry on your system.</para>

    </sect2>

    <sect2 xml:id="rip-cd">
      <title>Ripping CD Audio Tracks</title>

      <para>Before encoding a CD or CD track to MP3, the audio data on
	the CD must be ripped onto the hard drive.  This is done by
	copying the raw CDDA (CD Digital Audio) data to WAV
	files.</para>

      <para>The <command>cdda2wav</command> tool, which is a part of
	the <package>sysutils/cdrtools</package>
	suite, is used for ripping audio information from CDs and the
	information associated with them.</para>

      <para>With the audio CD in the drive, the following command can
	be issued (as <systemitem class="username">root</systemitem>) to rip an entire CD
	into individual (per track) WAV files:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -B</userinput></screen>

      <para><application>cdda2wav</application> will support
	ATAPI (IDE) CDROM drives.  To rip from an IDE drive, specify
	the device name in place of the SCSI unit numbers.  For
	example, to rip track 7 from an IDE drive:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D /dev/acd0a -t 7</userinput></screen>

      <para>The <option>-D <replaceable>0,1,0</replaceable></option>
	indicates the SCSI device <filename>0,1,0</filename>,
	which corresponds to the output of <command>cdrecord
	-scanbus</command>.</para>

      <para>To rip individual tracks, make use of the
	<option>-t</option> option as shown:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -t 7</userinput></screen>

      <para>This example rips track seven of the audio CDROM.  To rip
	a range of tracks, for example, track one to seven, specify a
	range:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D 0,1,0 -t 1+7</userinput></screen>

      <para>The utility &man.dd.1; can also be used to extract audio tracks
	on ATAPI drives, read <xref linkend="duplicating-audiocds"/>
	for more information on that possibility.</para>

    </sect2>

    <sect2 xml:id="mp3-encoding">
      <title>Encoding MP3s</title>

      <para>Nowadays, the mp3 encoder of choice is
	<application>lame</application>.
	<application>Lame</application> can be found at
	<package>audio/lame</package> in the ports tree.</para>

      <para>Using the ripped WAV files, the following command will
	convert <filename>audio01.wav</filename> to
	<filename>audio01.mp3</filename>:</para>

      <screen>&prompt.root; <userinput>lame -h -b 128 \
--tt "Foo Song Title" \
--ta "FooBar Artist" \
--tl "FooBar Album" \
--ty "2001" \
--tc "Ripped and encoded by Foo" \
--tg "Genre" \
audio01.wav audio01.mp3</userinput></screen>

      <para>128&nbsp;kbits seems to be the standard MP3 bitrate in use.
	Many enjoy the higher quality 160, or 192.  The higher the
	bitrate, the more disk space the resulting MP3 will
	consume--but the quality will be higher.  The
	<option>-h</option> option turns on the <quote>higher quality
	but a little slower</quote> mode.  The options beginning with
	<option>--t</option> indicate ID3 tags, which usually contain
	song information, to be embedded within the MP3 file.
	Additional encoding options can be found by consulting the
	lame man page.</para>
    </sect2>

    <sect2 xml:id="mp3-decoding">
      <title>Decoding MP3s</title>

      <para>In order to burn an audio CD from MP3s, they must be
	converted to a non-compressed WAV format.  Both
	<application>XMMS</application> and
	<application>mpg123</application> support the output of MP3 to
	an uncompressed file format.</para>

      <para>Writing to Disk in <application>XMMS</application>:</para>

      <procedure>
	<step>
	  <para>Launch <application>XMMS</application>.</para>
	</step>

	<step>
	  <para>Right-click on the window to bring up the
	    <application>XMMS</application> menu.</para>
	</step>

	<step>
	  <para>Select <literal>Preference</literal> under
	    <literal>Options</literal>.</para>
	</step>

	<step>
	  <para>Change the Output Plugin to <quote>Disk Writer
	      Plugin</quote>.</para>
	</step>

	<step>
	  <para>Press <literal>Configure</literal>.</para>
	</step>

	<step>
	  <para>Enter (or choose browse) a directory to write the
	    uncompressed files to.</para>
	</step>

	<step>
	  <para>Load the MP3 file into <application>XMMS</application>
	    as usual, with volume at 100% and EQ settings turned
	    off.</para>
	</step>

	<step>
	  <para>Press <literal>Play</literal> &mdash;
	    <application>XMMS</application> will appear as if it is
	    playing the MP3, but no music will be heard.  It is
	    actually playing the MP3 to a file.</para>
	</step>

	<step>
	  <para>Be sure to set the default Output Plugin back to what
	    it was before in order to listen to MP3s again.</para>
	</step>
      </procedure>

      <para>Writing to stdout in <application>mpg123</application>:</para>

      <procedure>
	<step>
	  <para>Run <command>mpg123 -s audio01.mp3
	    &gt; audio01.pcm</command></para>
	</step>
      </procedure>

      <para><application>XMMS</application> writes a file in the WAV
	format, while <application>mpg123</application> converts the
	MP3 into raw PCM audio data.  Both of these formats can be
	used with <application>cdrecord</application> to create audio CDs.
	You have to use raw PCM with &man.burncd.8;.
	If you use WAV files, you will notice a small tick sound at the
	beginning of each track, this sound is the header of the WAV
	file.  You can simply remove the header of a WAV file with the
	utility <application>SoX</application> (it can be installed from
	the <package>audio/sox</package> port or
	package):</para>

      <screen>&prompt.user; <userinput>sox -t wav -r 44100 -s -w -c 2 track.wav track.raw</userinput></screen>

      <para>Read <xref linkend="creating-cds"/> for more information on using a
	  CD burner in FreeBSD.</para>
    </sect2>
 </sect1>

 <sect1 xml:id="video-playback">
  <info><title>播放影片</title>
    <authorgroup>
      <author><personname><firstname>Ross</firstname><surname>Lippert</surname></personname><contrib>Contributed by </contrib></author>
    </authorgroup>
    
  </info>

  

    <para>Video playback is a very new and rapidly developing application
      area.  Be patient.  Not everything is going to work as smoothly as
      it did with sound.</para>

    <para>Before you begin, you should know the model of the video
      card you have and the chip it uses.  While <application>&xorg;</application> and <application>&xfree86;</application> support a
      wide variety of video cards, fewer give good playback
      performance.  To obtain a list of extensions supported by the
      X server using your card use the command &man.xdpyinfo.1; while
      X11 is running.</para>

    <para>It is a good idea to have a short MPEG file which can be
      treated as a test file for evaluating various players and
      options.  Since some DVD players will look for DVD media in
      <filename>/dev/dvd</filename> by default, or have this device
      name hardcoded in them, you might find it useful to make
      symbolic links to the proper devices:</para>

      <screen>&prompt.root; <userinput>ln -sf /dev/acd0c /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/racd0c /dev/rdvd</userinput></screen>

    <para>On FreeBSD&nbsp;5.X, which uses &man.devfs.5; there
        is a slightly different set of recommended links:</para>

      <screen>&prompt.root; <userinput>ln -sf /dev/acd0 /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/acd0 /dev/rdvd</userinput></screen>

    <para>Note that due to the nature of &man.devfs.5;,
      manually created links like these will not persist if you reboot
      your system.  In order to create the symbolic links
      automatically whenever you boot your system, add the following
      lines to <filename>/etc/devfs.conf</filename>:</para>

    <programlisting>link acd0 dvd
link acd0 rdvd</programlisting>

    <para>Additionally, DVD decryption, which requires invoking
      special DVD-ROM functions, requires write permission on the DVD
      devices.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>CPU_ENABLE_SSE</secondary>
    </indexterm>
    <indexterm>
      <primary>kernel options</primary>
      <secondary>USER_LDT</secondary>
    </indexterm>

    <para>Some of the ports discussed rely on the following kernel
      options to build correctly.  Before attempting to build, add
      this option to the kernel configuration file, build a new kernel, and reboot:</para>

      <programlisting>options CPU_ENABLE_SSE</programlisting>

    <note>
      <para>On &os;&nbsp;4.X <literal>options USER_LDT</literal> should
	be added to the kernel configuration file.  This option is not
	available on &os;&nbsp;5.X and later version.</para>
    </note>

    <para>To enhance the shared memory X11 interface, it is
      recommended that the values of some &man.sysctl.8; variables
      should be increased:</para>

      <programlisting>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</programlisting>

  <sect2 xml:id="video-interface">
    <title>Determining Video Capabilities</title>

    <indexterm><primary>XVideo</primary></indexterm>
    <indexterm><primary>SDL</primary></indexterm>
    <indexterm><primary>DGA</primary></indexterm>

    <para>There are several possible ways to display video under X11.
      What will really work is largely hardware dependent.  Each
      method described below will have varying quality across
      different hardware.  Secondly, the rendering of video in X11 is
      a topic receiving a lot of attention lately, and with each
      version of <application>&xorg;</application>, or of <application>&xfree86;</application>, there may be significant improvement.</para>

    <para>A list of common video interfaces:</para>

    <orderedlist>
    <listitem>
      <para>X11: normal X11 output using shared memory.</para>
    </listitem>
    <listitem>
      <para>XVideo: an extension to the X11
      interface which supports video in any X11 drawable.</para>
    </listitem>
    <listitem>
      <para>SDL: the Simple Directmedia Layer.</para>
    </listitem>
    <listitem>
      <para>DGA: the Direct Graphics Access.</para>
    </listitem>
    <listitem>
      <para>SVGAlib: low level console graphics layer.</para>
    </listitem>
    </orderedlist>

    <sect3 xml:id="video-interface-xvideo">
    <title>XVideo</title>

      <para><application>&xorg;</application> and <application>&xfree86; 4.X</application> have an extension called
        <emphasis>XVideo</emphasis> (aka Xvideo, aka Xv, aka xv) which
        allows video to be directly displayed in drawable objects
        through a special acceleration.  This extension provides very
        good quality playback even on low-end machines.</para>

      <para>To check whether the extension is running,
      use <command>xvinfo</command>:</para>

        <screen>&prompt.user; <userinput>xvinfo</userinput></screen>

      <para>XVideo is supported for your card if the result looks like:</para>
<screen>X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</screen>

    <para>Also note that the formats listed (YUV2, YUV12, etc) are not
     present with every implementation of XVideo and their absence may
     hinder some players.</para>

    <para>If the result looks like:</para>
<screen>X-Video Extension version 2.2
screen #0
no adaptors present</screen>

    <para>Then XVideo is probably not supported for your card.</para>

    <para>If XVideo is not supported for your card, this only means
      that it will be more difficult for your display to meet the
      computational demands of rendering video.  Depending on your
      video card and processor, though, you might still be able to
      have a satisfying experience.  You should probably read about
      ways of improving performance in the advanced reading <xref linkend="video-further-reading"/>.</para>

    </sect3>

    <sect3 xml:id="video-interface-SDL">
    <title>Simple Directmedia Layer</title>

    <para>The Simple Directmedia Layer, SDL, was intended to be a
      porting layer between &microsoft.windows;, BeOS, and &unix;,
      allowing cross-platform applications to be developed which made
      efficient use of sound and graphics.  The SDL layer provides a
      low-level abstraction to the hardware which can sometimes be
      more efficient than the X11 interface.</para>

    <para>The SDL can be found at <package>devel/sdl12</package>.</para>

    </sect3>

    <sect3 xml:id="video-interface-DGA">
    <title>Direct Graphics Access</title>

    <para>Direct Graphics Access is an X11 extension which allows
      a program to bypass the X server and directly alter the
      framebuffer.  Because it relies on a low level memory mapping to
      effect this sharing, programs using it must be run as
      <systemitem class="username">root</systemitem>.</para>

    <para>The DGA extension can be tested and benchmarked by
      &man.dga.1;.  When <command>dga</command> is running, it
      changes the colors of the display whenever a key is pressed.  To
      quit, use <keycap>q</keycap>.</para>

    </sect3>

  </sect2>

  <sect2 xml:id="video-ports">
    <title>Ports and Packages Dealing with Video</title>

    <indexterm><primary>video ports</primary></indexterm>
    <indexterm><primary>video packages</primary></indexterm>

    <para>This section discusses the software available from the
      FreeBSD Ports Collection which can be used for video playback.
      Video playback is a very active area of software development,
      and the capabilities of various applications are bound to
      diverge somewhat from the descriptions given here.</para>

    <para>Firstly, it is important to know that many of the video
      applications which run on FreeBSD were developed as Linux
      applications.  Many of these applications are still
      beta-quality.  Some of the problems that you may encounter with
      video packages on FreeBSD include:</para>

      <orderedlist>

      <listitem>
        <para>An application cannot playback a file which another
          application produced.</para>
      </listitem>

      <listitem>
        <para>An application cannot playback a file which the
          application itself produced.</para>
      </listitem>

      <listitem>
        <para>The same application on two different machines,
          rebuilt on each machine for that machine, plays back the same
          file differently.</para>
      </listitem>

      <listitem>
        <para>A seemingly trivial filter like rescaling of the image
          size results in very bad artifacts from a buggy rescaling
          routine.</para>
      </listitem>

      <listitem>
        <para>An application frequently dumps core.</para>
      </listitem>

      <listitem>
        <para>Documentation is not installed with the port and can be
          found either on the web or under the port's <filename>work</filename>
          directory.</para>
      </listitem>

      </orderedlist>

    <para>Many of these applications may also exhibit
      <quote>Linux-isms</quote>.  That is, there may be
      issues resulting from the way some standard libraries are
      implemented in the Linux distributions, or some features of the
      Linux kernel which have been assumed by the authors of the
      applications.  These issues are not always noticed and worked around
      by the port maintainers, which can lead to problems like
      these:</para>

      <orderedlist>

      <listitem>
        <para>The use of <filename>/proc/cpuinfo</filename> to detect
          processor characteristics.</para>
      </listitem>

      <listitem>
        <para>A misuse of threads which causes a program to hang upon
          completion instead of truly terminating.</para>
      </listitem>

      <listitem>
        <para>Software not yet in the FreeBSD Ports Collection
	  which is commonly used in conjunction with the application.</para>
      </listitem>

      </orderedlist>

      <para>So far, these application developers have been cooperative with
        port maintainers to minimize the work-arounds needed for
        port-ing.</para>

    <sect3 xml:id="video-mplayer">
      <title>MPlayer</title>

      <para><application>MPlayer</application> is a recently developed and rapidly developing
        video player.  The goals of the <application>MPlayer</application> team are speed and
        flexibility on Linux and other Unices.  The project was
        started when the team founder got fed up with bad playback
        performance on then available players.  Some would say that
        the graphical interface has been sacrificed for a streamlined
        design.  However, once
        you get used to the command line options and the key-stroke
        controls, it works very well.</para>

      <sect4 xml:id="video-mplayer-building">
        <title>Building MPlayer</title>
        <indexterm><primary>MPlayer</primary>
	           <secondary>making</secondary></indexterm>

	<para><application>MPlayer</application> resides in <package>multimedia/mplayer</package>.
	  <application>MPlayer</application> performs a variety of
	  hardware checks during the build process, resulting in a
	  binary which will not be portable from one system to
	  another.  Therefore, it is important to build it from
	  ports and not to use a binary package.  Additionally, a
	  number of options can be specified in the <command>make</command>
	  command line, as described in the <filename>Makefile</filename> and at the start of the build:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.root; <userinput>make</userinput>
N - O - T - E

Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html
</screen>

	<para>The default port options should be sufficient for most
	  users.  However, if you need the XviD codec, you have to
	  specify the <varname>WITH_XVID</varname> option in the
	  command line.  The default DVD device can also be defined
	  with the <varname>WITH_DVD_DEVICE</varname> option, by
	  default <filename>/dev/acd0</filename> will be used.</para>

        <para>As of this writing, the <application>MPlayer</application> port will build its HTML
          documentation and two executables,
          <command>mplayer</command>, and
          <command>mencoder</command>, which is a tool for
          re-encoding video.</para>

        <para>The HTML documentation for <application>MPlayer</application> is very informative.
          If the reader finds the information on video hardware and
          interfaces in this chapter lacking, the <application>MPlayer</application> documentation
          is a very thorough supplement.  You should definitely take
          the time to read the <application>MPlayer</application>
          documentation if you are looking for information about video
          support in &unix;.</para>

      </sect4>

      <sect4 xml:id="video-mplayer-using">
        <title>Using MPlayer</title>
        <indexterm><primary>MPlayer</primary>
	           <secondary>use</secondary></indexterm>

        <para>Any user of <application>MPlayer</application> must set up a
          <filename>.mplayer</filename> subdirectory of her
          home directory.  To create this necessary subdirectory,
	  you can type the following:</para>

<screen>&prompt.user; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.user; <userinput>make install-user</userinput></screen>

	<para>The command options for <command>mplayer</command> are
	  listed in the manual page.  For even more detail there is HTML
	  documentation.  In this section, we will describe only a few
	  common uses.</para>

	<para>To play a file, such as
	  <filename>testfile.avi</filename>,
	  through one of the various video interfaces set the
	  <option>-vo</option> option:</para>

	  <screen>&prompt.user; <userinput>mplayer -vo xv testfile.avi</userinput></screen>
	  <screen>&prompt.user; <userinput>mplayer -vo sdl testfile.avi</userinput></screen>
	  <screen>&prompt.user; <userinput>mplayer -vo x11 testfile.avi</userinput></screen>
	  <screen>&prompt.root; <userinput>mplayer -vo dga testfile.avi</userinput></screen>
	  <screen>&prompt.root; <userinput>mplayer -vo 'sdl:dga' testfile.avi</userinput></screen>

	<para>It is worth trying all of these options, as their relative
	  performance depends on many factors and will vary significantly
	  with hardware.</para>

	<para>To play from a DVD, replace the
	 <filename>testfile.avi</filename> with <option>dvd://<replaceable>N</replaceable> -dvd-device
	 <replaceable>DEVICE</replaceable></option> where <replaceable>N</replaceable> is
	 the title number to play and
	 <filename>DEVICE</filename> is the
	 device node for the DVD-ROM.  For example, to play title 3
	 from <filename>/dev/dvd</filename>:</para>

	<screen>&prompt.root; <userinput>mplayer -vo xv dvd://3 -dvd-device /dev/dvd</userinput></screen>

	<note>
	  <para>The default DVD device can be defined during the build
	    of the <application>MPlayer</application> port via the
	    <varname>WITH_DVD_DEVICE</varname> option.  By default,
	    this device is <filename>/dev/acd0</filename>.  More
	    details can be found in the port
	    <filename>Makefile</filename>.</para>
	</note>

	<para>To stop, pause, advance and so on, consult the
	  keybindings, which are output by running <command>mplayer
	  -h</command> or read the manual page.</para>

        <para>Additional important options for playback are:
          <option>-fs -zoom</option> which engages the fullscreen mode
          and <option>-framedrop</option> which helps performance.</para>

	<para>In order for the mplayer command line to not become too
	  large, the user can create a file
	  <filename>.mplayer/config</filename> and set default options
	  there:</para>
<programlisting>vo=xv
fs=yes
zoom=yes</programlisting>

	<para>Finally, <command>mplayer</command> can be used to rip a
	  DVD title into a <filename>.vob</filename> file.  To dump
	  out the second title from a DVD, type this:</para>

	  <screen>&prompt.root; <userinput>mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</userinput></screen>

        <para>The output file, <filename>out.vob</filename>, will be
	  MPEG and can be manipulated by the other packages described
	  in this section.</para>

      </sect4>
      <sect4 xml:id="video-mencoder">
        <title>mencoder</title>
        <indexterm>
	  <primary>mencoder</primary>
	</indexterm>

	<para>Before using
         <command>mencoder</command> it is a good idea to
	 familiarize yourself with the options from the HTML
	 documentation.  There is a manual page, but it is not very
	 useful without the HTML documentation.  There are innumerable ways to
	 improve quality, lower bitrate, and change formats, and some
	 of these tricks may make the difference between good
	 or bad performance.  Here are a couple of examples to get
	 you going.  First a simple copy:</para>

	 <screen>&prompt.user; <userinput>mencoder input.avi -oac copy -ovc copy -o output.avi</userinput></screen>

         <para>Improper combinations of command line options can yield
	 output files that are
	 unplayable even by <command>mplayer</command>.  Thus, if you
	 just want to rip to a file, stick to the <option>-dumpfile</option>
	 in <command>mplayer</command>.</para>

	 <para>To convert <filename>input.avi</filename> to the MPEG4
	 codec with MPEG3 audio encoding (<package>audio/lame</package> is required):</para>

	 <screen>&prompt.user; <userinput>mencoder input.avi -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi</userinput></screen>

	 <para>This has produced output playable by <command>mplayer</command>
	 and <command>xine</command>.</para>

	 <para><filename>input.avi</filename> can be replaced with
	   <option>dvd://1 -dvd-device /dev/dvd</option> and run as
	   <systemitem class="username">root</systemitem> to re-encode a DVD title
	   directly.  Since you are likely to be dissatisfied with
	   your results the first time around, it is recommended you
	   dump the title to a file and work on the file.</para>
      </sect4>

    </sect3>

    <sect3 xml:id="video-xine">
    <title>The xine Video Player</title>

    <para>The <application>xine</application> video player is a project of wide scope aiming not only at being an
     all in one video solution, but also in producing a reusable base
     library and a modular executable which can be extended with
     plugins.  It comes both as a package and as a port, <package>multimedia/xine</package>.</para>

    <para>The <application>xine</application> player
     is still very rough around the edges, but it is clearly off to a
     good start.  In practice, <application>xine</application> requires either a fast CPU with a
     fast video card, or support for the XVideo extension.  The GUI is
     usable, but a bit clumsy.</para>

    <para>As of this writing, there is no input module shipped with
     <application>xine</application> which will play CSS encoded DVD's.  There are third party
     builds which do have modules for this built in them, but none
     of these are in the FreeBSD Ports Collection.</para>

    <para>Compared to <application>MPlayer</application>, <application>xine</application> does more for the user, but at the
      same time, takes some of the more fine-grained control away from
      the user.  The <application>xine</application> video player
      performs best on XVideo interfaces.</para>

    <para>By default, <application>xine</application> player will
    start up in a graphical user interface.  The menus can then be
    used to open a specific file:</para>

      <screen>&prompt.user; <userinput>xine</userinput></screen>

    <para>Alternatively, it may be invoked to play a file immediately
      without the GUI with the command:</para>

      <screen>&prompt.user; <userinput>xine -g -p mymovie.avi</userinput></screen>

    </sect3>

    <sect3 xml:id="video-ports-transcode">
    <title>The transcode Utilities</title>

    <para>The software <application>transcode</application> is not a player, but a suite of tools for
      re-encoding video and audio files.  With <application>transcode</application>, one has the
      ability to merge video files, repair broken files, using command
      line tools with <filename>stdin/stdout</filename> stream
      interfaces.</para>

    <para>A great number of options can be specified during
      the build from the <package>multimedia/transcode</package> port, we recommend the
      following command line to build
      <application>transcode</application>:</para>

    <screen>&prompt.root; <userinput>make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes</userinput></screen>

    <para>The proposed settings should be sufficient for most users.</para>

    <para>To illustrate <command>transcode</command> capacities, one
      example to show how to convert a DivX file into a PAL MPEG-1
      file (PAL VCD):</para>

      <screen>&prompt.user; <userinput>transcode -i input.avi -V --export_prof vcd-pal -o output_vcd</userinput>
&prompt.user; <userinput>mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa</userinput></screen>

    <para>The resulting MPEG file,
      <filename>output_vcd.mpg</filename>, is ready to be played with
      <application>MPlayer</application>.  You could even burn the
      file on a CD-R media to create a Video CD, in this case you will
      need to install and use both <package>multimedia/vcdimager</package> and <package>sysutils/cdrdao</package> programs.</para>

    <para>There is a manual page for <command>transcode</command>, but
      you should also consult the <link xlink:href="http://www.transcoding.org/cgi-bin/transcode">transcode
      wiki</link> for further information and examples.</para>
    </sect3>

  </sect2>

  <sect2 xml:id="video-further-reading">
    <title>Further Reading</title>

    <para>The various video software packages for FreeBSD are
      developing rapidly.  It is quite possible that in the near
      future many of the problems discussed here will have been
      resolved.  In the mean time, those who
     want to get the very most out of FreeBSD's A/V capabilities will
     have to cobble together knowledge from several FAQs and tutorials
     and use a few different applications.  This section exists to
      give the reader pointers to such additional information.</para>

    <para>The
      <link xlink:href="http://www.mplayerhq.hu/DOCS/">MPlayer documentation</link>
      is very technically informative.
      These documents should probably be consulted by anyone wishing
      to obtain a high level of expertise with &unix; video.  The
      <application>MPlayer</application> mailing list is hostile to anyone who has not bothered
      to read the documentation, so if you plan on making bug reports
      to them, RTFM.</para>

    <para>The
      <link xlink:href="http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html">      xine HOWTO</link>
      contains a chapter on performance improvement
      which is general to all players.</para>

    <para>Finally, there are some other promising applications which
    the reader may try:</para>

    <itemizedlist>

       <listitem>
         <para><link xlink:href="http://avifile.sourceforge.net/">Avifile</link> which
	   is also a port <package>multimedia/avifile</package>.</para>
       </listitem>

       <listitem>
         <para><link xlink:href="http://www.dtek.chalmers.se/groups/dvd/">Ogle</link>
	   which is also a port <package>multimedia/ogle</package>.</para>
       </listitem>

       <listitem>
         <para><link xlink:href="http://xtheater.sourceforge.net/">Xtheater</link></para>
       </listitem>

	<listitem>
         <para><package>multimedia/dvdauthor</package>, an open
           source package for authoring DVD content.</para>
        </listitem>

    </itemizedlist>

  </sect2>
 </sect1>

  <sect1 xml:id="tvcard">
    <info><title>設定電視卡(TV Cards)</title>
      <authorgroup>
	<author><personname><firstname>Josef</firstname><surname>El-Rayes</surname></personname><contrib>Original contribution by </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Enhanced and adapted by </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>TV cards</primary>
    </indexterm>

    <sect2>
      <title>介紹</title>

      <para>電視卡(TV card)可以讓您用電腦來看無線、有線電視節目。許多卡都是透過 RCA 或 S-video
        輸入端子來接收視訊，而且有些卡還可接收 FM 廣播的功能。</para>

      <para>&os; 可透過 &man.bktr.4; 驅動程式，來支援 PCI 介面的電視卡，只要這些卡使用的是 Brooktree Bt848/849/878/879
        或 Conexant CN-878/Fusion 878a 視訊擷取晶片。此外，要再確認哪些卡上所附的選台功能是否有支援，可以參考 &man.bktr.4;
        說明，以查看所支援的硬體清單。</para>
    </sect2>

    <sect2>
      <title>設定相關驅動程式</title>

      <para>要用電視卡的話，就要載入 &man.bktr.4; 驅動程式，這個可以透過在 <filename>/boot/loader.conf</filename>
        檔加上下面這一行就可以了：</para>

      <programlisting>bktr_load="YES"</programlisting>

      <para>此外，也可以把該 kernel module 直接與 kernel 編譯在一起，作法就是在你的 kernel 設定檔內，加上下面這幾行：</para>

      <programlisting>device	 bktr
device	iicbus
device	iicbb
device	smbus</programlisting>

      <para>之所以要加上這些額外的驅動程式，是因為卡的各組成部分都是透過 I2C 匯流排而相互連接的。接下來，請重新編譯、安裝新的 kernel 。</para>

      <para>安裝好新的 kernel 之後，要重開機才會生效。開機時，應該會看到類似下面的正確偵測到 TV card 訊息：</para>

      <programlisting>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</programlisting>

      <para>當然，這些訊息可能因您的硬體不同而有所不同。However you should check if the tuner is correctly
	detected; it is still possible to override some of the
	detected parameters with &man.sysctl.8; MIBs and kernel
	configuration file options.  For example, if you want to force
	the tuner to a Philips SECAM tuner, you should add the
	following line to your kernel configuration file:</para>

      <programlisting>options OVERRIDE_TUNER=6</programlisting>

      <para>or you can directly use &man.sysctl.8;:</para>

      <screen>&prompt.root; <userinput>sysctl hw.bt848.tuner=6</userinput></screen>

      <para>See the &man.bktr.4; manual page and the
	<filename>/usr/src/sys/conf/NOTES</filename> file for more
	details on the available options. (If you are under
	&os;&nbsp;4.X, <filename>/usr/src/sys/conf/NOTES</filename> is
	replaced with
	<filename>/usr/src/sys/i386/conf/LINT</filename>.)</para>
    </sect2>

    <sect2>
      <title>好用的程式</title>

      <para>要用電視卡，可以視需要安裝下列應用程式之一︰</para>

      <itemizedlist>
	<listitem>
	  <para><package>multimedia/fxtv</package>
	    provides TV-in-a-window and image/audio/video capture
	    capabilities.</para>
	</listitem>
	<listitem>
	  <para><package>multimedia/xawtv</package>
	    is also a TV application, with the same features as
	    <application>fxtv</application>.</para>
	</listitem>
	<listitem>
	  <para><package>misc/alevt</package> decodes
	    and displays Videotext/Teletext.</para>
	</listitem>
	<listitem>
	  <para><package>audio/xmradio</package>, an
	    application to use the FM radio tuner coming with some
	    TV cards.</para>
	</listitem>
	<listitem>
	  <para><package>audio/wmtune</package>, a handy
	    desktop application for radio tuners.</para>
	</listitem>
      </itemizedlist>

      <para>More applications are available in the &os; Ports
	Collection.</para>
    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <para>If you encounter any problem with your TV card, you should
	check at first if the video capture chip and the tuner are
	really supported by the &man.bktr.4; driver and if you used the right
	configuration options.  For more support and various questions
	about your TV card you may want to contact and use the
	archives of the &a.multimedia.name; mailing list.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="scanners">
    <info><title>掃描器</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Written by </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>image scanners</primary>
    </indexterm>

    <sect2>
      <title>介紹</title>

      <para>&os; 就像任何現代作業系統一樣，都可以使用掃描器。
	在 &os; 是透過 Ports Collection 內的 <application>SANE</application>(Scanner Access Now Easy)
	所提供的 <acronym role="Application Programming Interface">API</acronym> 來操作掃描器。
	<application>SANE</application> 也會使用一些 &os; 的驅動程式來控制掃描器硬體。</para>

      <para>&os; 同時支援 SCSI 和 USB 兩種介面的掃描器。在做任何設定之前，請確保
        <application>SANE</application> 有支援您的掃描器。
	<application>SANE</application> 有張 <link xlink:href="http://sane-project.org/sane-supported-devices.html">支援硬體</link>
	的清單，這裡有介紹掃描器的支援情況和狀態訊息。
	在 &man.uscanner.4; 內也有提供一份 USB 掃描器的支援列表。</para>
    </sect2>

    <sect2>
      <title>Kernel 的設定</title>

      <para>如同上述所提的 SCSI 和 USB 界面都有支援。這要取決於您的掃描器界面，而需要不同的設備驅動程式。</para>

      <sect3 xml:id="scanners-kernel-usb">
	<title>USB 介面</title>

	<para>The <filename>GENERIC</filename> kernel by default
	  includes the device drivers needed to support USB scanners.
	  Should you decide to use a custom kernel, be sure that the
	  following lines are present in your kernel configuration
	  file:</para>

	<programlisting>device usb
device uhci
device ohci
device uscanner</programlisting>

	<para>Depending upon the USB chipset on your motherboard, you
	  will only need either <literal>device uhci</literal> or
	  <literal>device ohci</literal>, however having both in the
	  kernel configuration file is harmless.</para>

	<para>If you do not want to rebuild your kernel and your
	  kernel is not the <filename>GENERIC</filename> one, you can
	  directly load the &man.uscanner.4; device driver module with
	  the &man.kldload.8; command:</para>

	<screen>&prompt.root; <userinput>kldload uscanner</userinput></screen>

	<para>To load this module at each system startup, add the
	  following line to
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>uscanner_load="YES"</programlisting>

	<para>After rebooting with the correct kernel, or after
	  loading the required module, plug in your USB scanner.  The
	  scanner should appear in your system message buffer
	  (&man.dmesg.8;) as something like:</para>

	<screen>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</screen>

	<para>This shows that our scanner is using the
	  <filename>/dev/uscanner0</filename> device node.</para>

	<note>
	  <para>On &os;&nbsp;4.X, the USB daemon (&man.usbd.8;) must
	    be running to be able to see some USB devices.  To enable
	    this, add <literal>usbd_enable="YES"</literal> to your
	    <filename>/etc/rc.conf</filename> file and reboot the
	    machine.</para>
	  </note>
      </sect3>

      <sect3>
	<title>SCSI 介面</title>

	<para>If your scanner comes with a SCSI interface, it is
	  important to know which SCSI controller board you will use.
	  According to the SCSI chipset used, you will have to tune
	  your kernel configuration file.  The
	  <filename>GENERIC</filename> kernel supports the most common
	  SCSI controllers.  Be sure to read the
	  <filename>NOTES</filename> file (<filename>LINT</filename>
	  under &os;&nbsp;4.X) and add the correct line to your kernel
	  configuration file.  In addition to the SCSI adapter driver,
	  you need to have the following lines in your kernel
	  configuration file:</para>

	<programlisting>device scbus
device pass</programlisting>

	<para>Once your kernel has been properly compiled, you should
	  be able to see the devices in your system message buffer,
	  when booting:</para>

	<screen>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</screen>

	<para>If your scanner was not powered-on at system boot, it is
	  still possible to manually force the detection by performing
	  a SCSI bus scan with the &man.camcontrol.8; command:</para>

	<screen>&prompt.root; <userinput>camcontrol rescan all</userinput>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</screen>

	<para>Then the scanner will appear in the SCSI devices
	  list:</para>

	<screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 (pass0,da0)
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 (pass1,da1)
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 (pass3)
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 (pass2,cd0)</screen>

	<para>More details about SCSI devices, are available in the
	  &man.scsi.4; and &man.camcontrol.8; manual pages.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>設定 SANE</title>

      <para>The <application>SANE</application> system has been
	splitted in two parts: the backends (<package>graphics/sane-backends</package>) and the
	frontends (<package>graphics/sane-frontends</package>).  The
	backends part provides access to the scanner itself.  The
	<application>SANE</application>'s <link xlink:href="http://sane-project.org/sane-supported-devices.html">supported
	devices</link> list specifies which backend will support your
	image scanner.  It is mandatory to determine the correct
	backend for your scanner if you want to be able to use your
	device.  The frontends part provides the graphical scanning
	interface (<application>xscanimage</application>).</para>

      <para>The first thing to do is install the <package>graphics/sane-backends</package> port or
	package.  Then, use the <command>sane-find-scanner</command>
	command to check the scanner detection by the
	<application>SANE</application> system:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3</screen>

      <para>The output will show the interface type of the scanner and
	the device node used to attach the scanner to the system.  The
	vendor and the product model may not appear, it is not
	important.</para>

      <note>
	<para>Some USB scanners require you to load a firmware, this
	  is explained in the backend manual page.  You should also read
	  &man.sane-find-scanner.1; and &man.sane.7; manual
	  pages.</para>
      </note>

      <para>Now we have to check if the scanner will be identified by
	a scanning frontend.  By default, the
	<application>SANE</application> backends comes with a command
	line tool called &man.scanimage.1;.  This command allows you
	to list the devices and to perform an image acquisition from
	the command line.  The <option>-L</option> option is used to
	list the scanner device:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner</screen>

      <para>No output or a message saying that no scanners were
	identified indicates that &man.scanimage.1; is unable to
	identify the scanner.  If this happens, you will need to edit
	the backend configuration file and define the scanner device
	used.  The <filename>/usr/local/etc/sane.d/</filename> directory
	contains all backends configuration files.  This
	identification problem does appear with certain USB
	scanners.</para>

      <para>For example, with the USB scanner used in the <xref linkend="scanners-kernel-usb"/>,
	<command>sane-find-scanner</command> gives us the following
	information:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found USB scanner (UNKNOWN vendor and product) at device /dev/uscanner0</screen>
      <para>The scanner is correctly detected, it uses the USB
	interface and is attached to the
	<filename>/dev/uscanner0</filename> device node.  We can now
	check if the scanner is correctly identified:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).</screen>

      <para>Since the scanner is not identified, we will need to edit
	the <filename>/usr/local/etc/sane.d/epson.conf</filename>
	file.  The scanner model used was the &epson.perfection; 1650,
	so we know the scanner will use the <literal>epson</literal>
	backend.  Be sure to read the help comments in the backends
	configuration files.  Line changes are quite simple: comment
	out all lines that have the wrong interface for your scanner
	(in our case, we will comment out all lines starting with the
	word <literal>scsi</literal> as our scanner uses the USB
	interface), then add at the end of the file a line specifying
	the interface and the device node used.  In this case, we add
	the following line:</para>

      <programlisting>usb /dev/uscanner0</programlisting>

      <para>Please be sure to read the comments provided in the
	backend configuration file as well as the backend manual page
	for more details and correct syntax to use.  We can now verify
	if the scanner is identified:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner</screen>

      <para>Our USB scanner has been identified.  It is not important
	if the brand and the model do not match.  The key item to be
	concerned with is the
	<literal>`epson:/dev/uscanner0'</literal> field, which give us
	the right backend name and the right device node.</para>

      <para>Once the <command>scanimage -L</command> command is able
	to see the scanner, the configuration is complete.  The device
	is now ready to scan.</para>

      <para>While &man.scanimage.1; does allow us to perform an
	image acquisition from the command line, it is preferable to
	use a graphical user interface to perform image scanning.
	<application>SANE</application> offers a simple but efficient
	graphical interface: <application>xscanimage</application>
	(<package>graphics/sane-frontends</package>).</para>

      <para><application>Xsane</application> (<package>graphics/xsane</package>) is another popular
	graphical scanning frontend.  This frontend offers advanced
	features such as various scanning mode (photocopy, fax, etc.),
	color correction, batch scans, etc.  Both of these applications
	are useable as a <application>GIMP</application>
	plugin.</para>
    </sect2>

    <sect2>
      <title>Allowing Scanner Access to Other Users</title>

      <para>All previous operations have been done with
	<systemitem class="username">root</systemitem> privileges.  You may however, need
	other users to have access
	to the scanner.  The user will need read and write
	permissions to the device node used by the scanner.  As an
	example, our USB scanner uses the device node
	<filename>/dev/uscanner0</filename> which is owned by the
	<systemitem class="groupname">operator</systemitem> group.  Adding the user
	<systemitem class="username">joe</systemitem> to the
	<systemitem class="groupname">operator</systemitem> group will allow him to use
	the scanner:</para>

      <screen>&prompt.root; <userinput>pw groupmod operator -m joe</userinput></screen>

      <para>For more details read the &man.pw.8; manual page.  You
	also have to set the correct write permissions (0660 or 0664)
	on the <filename>/dev/uscanner0</filename> device node, by
	default the <systemitem class="groupname">operator</systemitem> group can only
	read the device node.  This is done by adding the following
	lines to the <filename>/etc/devfs.rules</filename> file:</para>

      <programlisting>[system=5]
add path uscanner0 mode 660</programlisting>

      <para>Then add the following to
	<filename>/etc/rc.conf</filename> and reboot the
	machine:</para>

      <programlisting>devfs_system_ruleset="system"</programlisting>

      <para>More information regarding these lines can be found in the
	&man.devfs.8; manual page.  Under &os;&nbsp;4.X, the
	<systemitem class="groupname">operator</systemitem> group has, by default, read
	and write permissions to
	<filename>/dev/uscanner0</filename>.</para>

      <note>
	<para>Of course, for security reasons, you should think twice
	  before adding a user to any group, especially the
	  <systemitem class="groupname">operator</systemitem> group.</para>
      </note>
    </sect2>
  </sect1>
</chapter>
