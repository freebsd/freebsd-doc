<?xml version="1.0" encoding="big5"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     Original revision: 1.225
-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Restructured, reorganized, and parts updated by </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Original work by </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
  </chapterinfo>

  <title>更新、升級 FreeBSD</title>

  <sect1 id="cutting-edge-synopsis">
    <title>概述</title>

    <para>&os; 是個持續發展的作業系統。對於喜歡追求新鮮、刺激的使用者而言，
      有很多方法可以使您的系統輕鬆更新為最新版。
      注意：並非每個人都適合這麼做！　本章主要是協助您決定到底要跟開發版本，
      或是要使用較穩定的釋出版。
      </para>

    <para>讀完這章，您將了解︰</para>

    <itemizedlist>
      <listitem><para>&os.stable; 與 &os.current;　這兩分支的不同之處；</para>
      </listitem>
      <listitem><para>如何以
	  <application>CSup</application>,
	  <application>CVSup</application>,
	  <application>CVS</application> 或
	  <application>CTM</application> 來更新你的系統</para>
      </listitem>
      <listitem><para>如何以 <command>make buildworld</command>
      等指令來重新編譯、安裝整個 base system。</para>
      </listitem>

    </itemizedlist>

    <para>在開始閱讀這章之前，您需要︰</para>

    <itemizedlist>
      <listitem><para>先設好你的網路(<xref linkend="advanced-networking"/>)。
	</para>
      </listitem>
      <listitem><para>知道如何透過 port/package 安裝軟體(<xref
	linkend="ports"/>)。</para></listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="current-stable">
    <title>&os.current; vs. &os.stable;</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>FreeBSD 有兩個發展分支：&os.current; 及
      &os.stable;。本節將會陸續介紹，並介紹它們分別又是如何更新。
      首先，先介紹 &os.current;，接著再介紹 &os.stable;。</para>

    <sect2 id="current">
      <title>使用最新的 &os; CURRENT</title>

      <para>這裡再次強調，&os.current; 是 &os; 開發的 <quote>最前線</quote>。
	&os.current; 使用者須有較強的技術能力，
	而且應該要有能力自己解決困難的系統問題。  若您是 &os; 新手，
	那麼請在安裝前最好先三思。</para>

      <sect3>
	<title>什麼是 &os.current;？</title>
	<indexterm><primary>snapshot</primary></indexterm>

	<para>&os.current; 是 &os; 的最新版。它包含：
	  仍在研發階段、實驗性質的修改、過渡時期的機制，
	  這些東西在下一次正式 relase 的版本可能會有，也可能不會有的。
	  儘管有許多 &os; 開發者每天都會編譯 &os.current; source code，
	  但有時這些原始碼是無法編譯成功。  雖然，這些問題通常會儘快解決，
	  但 &os.current; 到底是帶來浩劫或是多了想要用的新功能、改善，
	  這點主要取決於您更新原始碼的時機為何而定！</para>
      </sect3>

      <sect3>
	<title>誰需要 &os.current;？</title>

	<para>&os.current; 適合下列這三類人：</para>

	<orderedlist>
	  <listitem>
	    <para>&os; 社群成員：積極專注於 source tree 的某一部份，
	      以及認為保持為 <quote>current(最新狀態)</quote>
	      為絕對需求的人。</para>
	  </listitem>

	  <listitem>
	    <para>&os; 社群成員：為了確保 &os.current;
	      能夠儘可能地維持在最穩定的狀態，
	      而主動花時間解決問題的測試者。  此外，還有對 &os;
	      能提出具體建議以及改善方向，並提出 patch 修正檔的人。</para>
	  </listitem>

	  <listitem>
	    <para>只是關心或者想參考(比如，只是<emphasis>閱讀</emphasis>，
	      而非執行)的人。
	      這些人有時也會做些註解，或貢獻原始碼。</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>&os.current; <emphasis>並不是</emphasis> 什麼？</title>

	<orderedlist>
	  <listitem>
	    <para>追求最新功能。  聽說裡面有些很酷的新功能，
	      並希望成為您周圍的人中第一個嘗試的人，
	      因此將 &os.current; 視為取得搶鮮版的捷徑。
	      儘管，您能夠因此首先瞭解到最新的功能，
	      但這也意味著若出現新的 bug 時，您也是首當其衝。</para>
	  </listitem>

	  <listitem>
	    <para>修復 bug 的速成法。  因為 &os.current;
	      的任何版本在修復已知 bug 的同時，又可能會產生新的 bug。
	      </para>
	  </listitem>

	  <listitem>
	    <para>無所不在的 <quote>officially supported</quote>。
	      我們會盡力協助上述 &os.current; 的那三種類別的
	      <quote>legitimate</quote> 使用者，
	      但我們<emphasis>沒時間</emphasis>為他們提供技術支援。
	      這不代表我們很惡劣，或是不想幫助人(若是的話，
	      我們也不會為 &os; 努力了)
	      ，實在是因為我們分身乏術，無法每天回答數百個問題，
	      <emphasis>而同時</emphasis>繼續開發 &os;。
	      可以確定的一點就是，
	      在改善 &os; 或是回答大量有關實驗碼的問題之間，
	      若要做個選擇的話，開發者會選擇前者。</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>使用 &os.current;</title>

	<orderedlist>
	  <listitem>
	    <para>加入 &a.current.name;<indexterm><primary>-CURRENT</primary><secondary>using</secondary></indexterm> 及 &a.cvsall.name; 論壇。
	      這不單只是個建議，也是 <emphasis>必須</emphasis> 作的。
	      若您沒訂閱 <emphasis>&a.current.name;</emphasis>
	      ，那麼就會錯過別人對目前系統狀態的說明，而枯耗在別人已解的問題。
	      更重要的是，可能會錯失一些對己身所管系統安危相當重要的公告。
	      </para>

	    <para>在 &a.cvsall.name; 上則可以看到每個 commit 紀錄，
	      因為這些記錄會連帶影響其他相關資訊。</para>

	    <para>要訂閱這些論壇或其他論壇，請參考 &a.mailman.lists.link;
	      並點選想訂閱的部分即可。  至於其他後續步驟如何進行，
	      在那裡會有說明。</para>
	  </listitem>

	  <listitem>
	    <para>從 &os; <link linkend="mirrors">mirror 站</link>
	      取得原始碼。  有兩種方式可以達成：</para>

	    <orderedlist>
	      <listitem>
		<para>以 <link linkend="cvsup">csup</link><indexterm><primary><command>cvsup</command></primary></indexterm> 或
		  <link linkend="cvsup">cvsup</link> 程式搭配位於
		  <filename>/usr/share/examples/cvsup</filename> 檔名為
		  <filename>standard-supfile</filename> 的
		  <filename>supfile</filename>。
		  這是大家最常推薦的方式，因為它可以讓您把整個 tree 都抓回來，
		  之後就只取有更新的部分即可。
		  此外，許多人會把 <command>csup</command> 或
		  <command>cvsup</command> 放到
		  <command>cron</command><indexterm><primary><command>cron</command></primary></indexterm> 以定期自動更新。
 		  您須要自訂前述的 <filename>supfile</filename> 範例檔，
		  並針對自身網路環境以調整 <link linkend="cvsup">csup</link>
		  或 <link linkend="cvsup">cvsup</link><indexterm><primary>-CURRENT</primary><secondary>Syncing with <application>CVSup</application></secondary></indexterm> 相關設定。</para>
	      </listitem>

	      <listitem>
		<para>使用 <application><link
		  linkend="ctm">CTM</link></application><indexterm><primary>-CURRENT</primary><secondary>Syncing with CTM</secondary></indexterm> 工具。  若網路環境不佳
		  (上網費用貴，或只能用 email 而已)
		  <application>CTM</application> 會比較適合您的需求。
		  然而，這也有一些爭議並且常抓到一些有問題的檔案。  因此，
		  很少人會用它。  這也註定了不能長期依賴這個更新方式。
		  若是使用 9600&nbsp;bps modem 或頻寬更大的上網者，建議使用
		  <application><link linkend="cvsup">CVSup</link></application>
		  。</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>若抓 source code 是要用來跑的，而不僅只是看看而已，
	      那麼就抓 <emphasis>整個</emphasis> &os.current;，而不要只抓部分。
	      因為大部分的 source code 都會相依到其他 source code 環節部分，
	      若是您只編譯其中一部份，保證會很麻煩。</para>

	    <para>在編譯 &os.current;<indexterm><primary>-CURRENT</primary><secondary>compiling</secondary></indexterm> 之前，請仔細閱讀
	      <filename>/usr/src</filename> 內的 <filename>Makefile</filename>。
	      儘管只是升級部分東西而已，您至少也要先 <link linkend="makeworld">
	      裝新的 kernel 以及重新編譯 world</link>。  此外，多多閱讀
	      &a.current; 以及 <filename>/usr/src/UPDATING</filename>
	      也是必須的，
	      才能知道目前進度是怎樣以及下一版會有什麼新東西。</para>
	  </listitem>

	  <listitem>
	    <para>熱血！若您正在跑 &os.current;，
	      我們很想知道您對於它的想法是什麼，尤其是加強哪些功能，
	      或該修正哪些錯誤的建議。  如果您在建議時能附上相關程式碼的話，
	      那真是太棒了！</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>使用最新的 &os; STABLE</title>

      <sect3>
	<title>什麼是 &os.stable;？</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; 是我們的開發分支，主要的發行版就由此而來。
	  這個分支會以不同速度作修改變化，並且假設這些是第一次進入 &os.current;
	  進行測試。  然而，這 <emphasis>仍然</emphasis> 屬於開發中的分支，
	  也就是說在某些時候，&os.stable; 可能會、也可能不會符合一些特殊需求。
	  它只不過是另一個開發分支而已，可能不太適合一般使用者。</para>
      </sect3>

      <sect3>
	<title>誰需要 &os.stable;？</title>

	<para>若您有興趣去追蹤、貢獻 FreeBSD 開發過程或作些貢獻，
	  尤其是會跟 FreeBSD 接下來的 <quote>關鍵性</quote> 發行有關，
	  應該考慮採用 &os.stable;。</para>

	<para>雖然安全漏洞的修補也會進入 &os.stable; 分支，
	  但不必僅僅因此而 <emphasis>需要</emphasis> 去用 &os.stable;。
	  FreeBSD 每項 security advisory(安全公告)
	  都會解說如何去修復有受到影響的版本
	  <footnote><para>然而，這也不一定是正確，我們不可能永遠支援 FreeBSD
	    昔日的各種發行版本，儘管每個發行版發佈之後，都仍會持續支援數年之久。
	    若欲瞭解 FreeBSD 目前對於舊版的支援政策細節，請參閱 <ulink
  	    url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>
	    。</para>
	  </footnote>
	  ，若僅因為安全因素而去採用開發分支，雖然會解決現有已知問題，
	  但也可能帶來一些潛藏的問題。</para>

	<para>儘管我們盡力確保 &os.stable; 分支在任何時候均能正確編譯、運作，
	  但沒人能夠擔保它隨時都可以符合上述目的。  此外，雖然原始碼在進入
	  &os.stable; 之前，都會先在 &os.current; 開發完畢，但使用 &os.current;
	  的人畢竟遠比 &os.stable; 使用者來的少，所以通常有些問題，可能在
	  &os.current; 比較沒人注意到，隨著 &os.stable;
	  使用者的廣泛使用才會浮現。</para>

	<para>由於上述這些理由，我們<emphasis>並不推薦</emphasis> 盲目追隨
	  &os.stable;，而且更重要的是，別在原始碼尚未經完整測試之前，
	  就衝動把 production server 轉移到 &os.stable; 環境。</para>

	<para>若您沒有這些多的時間、精神的話，那推薦您使用最新的 FreeBSD
	  發行版即可，並採用其所提供的 binary 更新機制來完成升級轉移。</para>
      </sect3>

      <sect3>
	<title>使用 &os.stable;</title>

	<orderedlist>
	  <listitem>
	    <para>訂閱 &a.stable.name;<indexterm><primary>-STABLE</primary><secondary>using</secondary></indexterm> list。  可以讓您隨時瞭解 &os.stable;
	      的軟體編譯時的相依關係，以及其他需特別注意的問題。
	      開發者在考慮一些有爭議的修正或更新時，就會先在這裡發信說明，
	      給使用者有機會可以反應，
	      看他們對所提的更改是否有什麼建議或問題。</para>

	    <para>而 &a.cvsall.name; list 這邊可以看到每個 commit log，
	      其中包括了許多中肯的資訊，例如一些可能發生的邊際效應等等。</para>

	    <para>想要加入這些通信論壇的話，只要到 &a.mailman.lists.link;
	      點下想訂閱的 list 即可。  其餘的步驟在網頁上會有說明。</para>
	  </listitem>

	  <listitem>
	    <para>若打算要安裝一個全新的系統，並且希望裝  &os.stable;
	      每月定期的 snapshot，那麼請參閱 <ulink
	      url="&url.base;/snapshots/">Snapshots</ulink> 網頁以瞭解相關細節。
	      此外，也可從 <link linkend="mirrors">mirror 站</link>
	      來安裝最新的 &os.stable; 發行版，並透過下列的的說明來更新到最新的
	      &os.stable; 原始碼。</para>

	    <para>若已裝的是 &os; 以前的版本，而想透過原始碼方式來升級，
	      那麼也是可以利用 &os; <link linkend="mirrors">mirror 站</link>
	      來完成。  以下介紹兩種方式：</para>

	    <orderedlist>
	      <listitem>
		<para>以 <link linkend="cvsup">csup</link><indexterm><primary><command>cvsup</command></primary></indexterm> 或
		  <link linkend="cvsup">cvsup</link> 程式搭配位於
		  <filename>/usr/share/examples/cvsup</filename> 檔名為
		  <filename>stable-supfile</filename> 的
		  <filename>supfile</filename>。  這是大家最常推薦的方式，
		  因為它可以讓你把整個 tree 都抓回來，
		  之後就只取有更新的部分即可。
		  此外，許多人會把 <command>csup</command> 或
		  <command>cvsup</command> 放到 <command>cron</command><indexterm><primary><command>cron</command></primary></indexterm>
		  以定期自動更新。  您須要自訂前述的
		  <filename>supfile</filename> 範例檔，並針對自身網路環境以調整
		  <link linkend="cvsup">csup</link> 或
		  <link linkend="cvsup">cvsup</link><indexterm><primary>-STABLE</primary><secondary>syncing with <application>CVSup</application></secondary></indexterm> 相關設定。</para>
	      </listitem>

	      <listitem>
		<para>使用 <application><link
		  linkend="ctm">CTM</link></application><indexterm><primary>-STABLE</primary><secondary>syncing with CTM</secondary></indexterm> 更新工具。
		  若網路不快或網路費用貴，那麼可以考慮採用。</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>一般而言，若常需存取最新原始碼，而不計較網路頻寬的話，
	      可以使用 <command>csup</command> 或 <command>cvsup</command>
	      或 <command>ftp</command>。  否則，就考慮
	      <application>CTM</application>。</para>
	  </listitem>

	  <listitem>
	    <para>在編譯 &os.stable;<indexterm><primary>-STABLE</primary><secondary>compiling</secondary></indexterm> 之前，請先仔細閱讀
	      <filename>/usr/src</filename> 內的 <filename>Makefile</filename>
	      檔。  儘管只是升級部分東西而已，您至少也要先 <link
	      linkend="makeworld">裝新的 kernel 以及重新編譯 world</link>。
	      此外，多多閱讀 &a.stable; 以及
	      <filename>/usr/src/UPDATING</filename> 也是必備的，
	      這樣才能知道目前進度是怎樣，以及下一版會有哪些新東西。</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>更新你的 Source</title>

    <para>&os; 計劃原始碼有許多透過網路(或 email)的方式來更新，
      無論是更新那一塊領域，這些全由您自行決定。  我們主要提供的是 <link
      linkend="anoncvs">Anonymous CVS</link>、<link linkend="cvsup">CVSup</link>
      、<link linkend="ctm">CTM</link>。</para>

    <warning>
      <para>雖然可以只更新部分原始碼，但唯一支援的更新流程是更新整個 tree，
	並且重編 userland(比如：由使用者去執行的所有程式，像是
	<filename>/bin</filename>、<filename>/sbin</filename> 內的程式)以及
	kernel 原始碼。
        若只更新部分的 source tree、或只有 kernel 部分、或只有 userland
	部分，通常會造成一些錯誤，像是：編譯錯誤、kernel panic、資料毀損等
	。</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para><application>Anonymous CVS</application> 及
      <application>CVSup</application> 均是採 <emphasis>pull</emphasis>
      模式來更新原始碼。  以 <application>CVSup</application> 為例，
      使用者(或 <command>cron</command> script)會執行 <command>cvsup</command>
      程式，後者會與某一台 <command>cvsupd</command> 伺服器作些互動，
      以更新相關原始碼檔案。  您所收到更新會是當時最新的，
      而且只會收到需更新的部分。  此外，也可以很輕鬆去設定要更新的範圍。
      更新會由伺服器跟本機比對之後，丟出當時您所需要的更新檔案給你。
      <application>Anonymous CVS</application> 的概念相對於
      <application>CVSup</application> 來得更簡單些，因為它只是
      <application>CVS</application> 的延伸而已，一樣讓你可從遠端的
      CVS repository 取出最新原始碼。  然而 <application>CVSup</application>
      在這方面會更有效率，不過 <application>Anonymous CVS</application>
      對新手而言，是用起來比較簡單。</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>另一種方式則是 <application>CTM</application>。
      它並不是以交談式介面來比對您所擁有的 sources 和伺服器上的 sources
      或是您取得的更新部份。  相反的，會有一個 script
      檔專門用來辨識變更過的檔案，這個程式是由 CTM 伺服器來執行，
      每天會比對數次，並把兩次執行期間內變更過的檔案加以壓縮，
      並給它們一個序號，然後就加以編碼(只用 printable ASCII 字元)，
      並以 email 的方式寄出。  當您收到它的時候，這些 <quote>CTM deltas</quote>
      就可以由 &man.ctm.rmail.1; 程式來處理，該程式會自動解碼、確認、
      套用這些變更。 這程序比 <application>CVSup</application> 來說是快得多了，
      而且，這個模式對我們的伺服器來說是比較輕鬆的，因為這是一個
      <emphasis>push</emphasis> 的模式，而非 <emphasis>pull</emphasis>
      的模式。</para>

    <para>當然，這樣做也會帶來一些不便。  若不小心把您部份的程式清除掉了，
      <application>CVSup</application> 會偵測出來，並自動為您把不足的部份補齊。
      <application>CTM</application> 並不會為您做這些動作。
      若清掉了您的部份 source (而且沒備份)，您可以從頭開始(從最新的 CVS
      <quote>base delta</quote>)並用 <application>CTM</application> 來重建它們
      ，或是用 <application>Anonymous CVS</application> 來完成，
      只要把不正確的地方砍掉，再重新做同步的動作即可。</para>
  </sect1>

  <sect1 id="makeworld">
    <title>重新編譯 <quote>world</quote></title>

    <indexterm>
      <primary>Rebuilding <quote>world</quote></primary>
    </indexterm>
    <para>在更新 &os; 的 source tree 到最新之後(無論是 &os.stable;、
      &os.current; 等等)，接下來就可以用這些 source tree 來重新編譯系統
      。</para>

    <warning>
      <title>做好備份</title>

      <para>在作任何大動作 <emphasis>之前</emphasis>
	要記得先把系統作備份的重要性無須強調。 儘管重新編譯 world 是
	(只要有照文件指示去作的話)一件很簡單的事情，但出錯也是在所難免的。
	另外，別人在 source tree 不慎搞混的錯誤，也可能會造成系統無法開機
	。</para>

      <para>請確認自己已作妥相關備份，並且手邊有 fixit 磁片或開機光碟。
	您可能永遠也用不到這些東西，
	但安全第一總比事後說抱歉來得好吧！</para>
    </warning>

    <warning>
      <title>訂閱相關的 Mailing List</title>

      <indexterm><primary>mailing list</primary></indexterm>
      <para>&os.stable; 以及 &os.current; 分支，本質上就是屬於 <emphasis>
	開發階段</emphasis>。  為 &os; 作貢獻的也都是人，偶爾也會犯錯誤。</para>

      <para>有時候這些錯誤並無大礙，只是會讓系統產生新的錯誤警告而已。
	有時則是災難，可能會導致不能開機或檔案系統的毀損(或更糟)。</para>

      <para>若遇到類似問題，貼封標題為 <quote>heads up(注意)</quote>
	開頭的信到相關的 mailing list，並講清楚問題點以及會影響哪些系統。
	在問題獲解決後，再貼標題為 <quote>all clear(已解決)</quote>
	開頭的聲明信。</para>

      <para>若用的是 &os.stable; 或 &os.current;，卻又不閱讀 &a.stable; 或
	&a.current; 的討論，那麼會是自找麻煩而已。</para>
    </warning>

    <warning>
      <title>不要用 <command>make world</command></title>

      <para>一堆早期的舊文件都會建議說使用 <command>make world</command>。
	這樣做會跳過一些重要步驟，建議只有在你知道自己在作什麼，再這麼做。
	在絕大多數的情況下，請不要亂用 <command>make world</command>，
	而該改用下面介紹的方式。</para>
    </warning>

    <sect2>
      <title>更新系統的標準方式</title>

      <para>要升級系統前，一定要先查閱 <filename>/usr/src/UPDATING</filename>
	文件，以瞭解 buildworld 之前需要作哪些事情或注意事項，
	然後才用下列步驟：</para>

      <screen>&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <note>
	<para>在少數狀況，可能需要先在 <maketarget>buildworld</maketarget>
	  步驟之前先作 <command>mergemaster -p</command> 才能完成。
	  至於何時需要或不需要，請參閱 <filename>UPDATING</filename> 內的說明。
	  一般來說，只要不是進行跨版號(major)的 &os; 版本升級，
	  就可略過這步驟。</para>
      </note>

      <para>完成 <maketarget>installkernel</maketarget> 之後，需要重開機並切到
	single user 模式(舉例：也可以在 loader 提示符號後面加上
	<command>boot -s</command>)。  接下來執行：</para>

      <screen>&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Read Further Explanations</title>

	<para>上述步驟只是協助您升級的簡單說明而已，若要清楚瞭解每一步驟，
	  尤其是若欲自行打造 kernel 設定，就更該閱讀下面的內容。</para>
      </warning>
    </sect2>

    <sect2>
      <title>閱讀 <filename>/usr/src/UPDATING</filename></title>

      <para>在作任何事情之前，請務必先閱讀
	<filename>/usr/src/UPDATING</filename> (或在 source code 內類似的文件)
	。  這份文件會寫到可能遭遇的問題，或指定那些會執行的指令順序為何。
	如果你機器現在的 <filename>UPDATING</filename>
	文件與這邊的描述有衝突、矛盾之處，那麼請以機器上的
	<filename>UPDATING</filename> 為準。</para>

      <important>
	<para>然而，如同先前所述，單單只靠閱讀 <filename>UPDATING</filename>
	  並不能完全取代 mailing list。  這兩者都是互補的，而不相排斥。</para>
      </important>
    </sect2>

    <sect2>
      <title>檢查 <filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>檢查
	<filename>/usr/share/examples/etc/make.conf</filename>
	以及
	<filename>/etc/make.conf</filename>。  第一份文件乃是一些系統預設值
	&ndash; 不過，大部分都被註解起來。  為了在重新編譯時能夠使用這些，
	請把這些設定加到 <filename>/etc/make.conf</filename>。  請注意在
	<filename>/etc/make.conf</filename> 的任何設定也會影響到每次使用
	<command>make</command> 的結果，
	因此設定一些適合自己系統的選項會是不錯的作法。</para>

      <para>一般使用者通常會從
	<filename>/usr/share/examples/etc/make.conf</filename> 複製
	<makevar>CFLAGS</makevar> 以及 <makevar>NO_PROFILE</makevar>
	之類的設定到 <filename>/etc/make.conf</filename>，並解除相關註解印記
	。</para>

      <para>此外，也可以試試看其他設定 (<makevar>COPTFLAGS</makevar>、
	<makevar>NOPORTDOCS</makevar> 等等)，是否符合自己所需。</para>
    </sect2>

    <sect2>
      <title>更新 <filename>/etc</filename> 內的設定檔</title>

      <para>在 <filename>/etc</filename> 目錄會有系統的相關設定檔，
	以及開機時的各項服務啟動 script。  有些 script 隨 FreeBSD
	版本的不同而有些差異。</para>

      <para>其中有些設定檔會在每日運作的系統裡也會用到。  尤其是
	<filename>/etc/group</filename>。</para>

      <para>有時候在 <command>make installworld</command> 安裝過程中，
	會需要先建立某些特定帳號或群組。  在進行升級之前，它們可能並不存在，
	因此升級時就會造成問題。  有時候 <command>make buildworld</command>
	會先檢查這些所需的帳號或群組是否已有存在。</para>

      <para>舉個這樣的例子，像是某次升級之後必須新增 <username>smmsp</username>
	帳號。  若使用者尚未新增該帳號就要完成升級操作的話，
	會在 &man.mtree.8; 嘗試建立 <filename>/var/spool/clientmqueue</filename>
	時發生失敗。</para>

      <para>解法是在 buildworld 階段之前，先執行 &man.mergemaster.8; 並搭配
	<option>-p</option> 選項。  它會比對那些執行
	<maketarget>buildworld</maketarget> 或
	<maketarget>installworld</maketarget> 所需之關鍵設定檔。
	若你所用的是早期仍未支援 <option>-p</option> 的
	<command>mergemaster</command> 版本，那麼直接使用 source tree
	內的新版即可：</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>若您是偏執狂(paranoid)，
	  可以像下面這樣去試著檢查系統上有哪些檔案屬於已改名或被刪除的群組
	  ：</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>這會顯示所有符合要找的 <replaceable>GID</replaceable> 群組
	  (可以是群組名稱，或者是群組的數字代號)的所有檔案。</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>切換到 Single User 模式</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>您可能會想在 single user 模式下編譯系統。
	除了可以明顯更快完成之外，安裝過程中將會牽涉許多重要的系統檔案，
	包括所有系統 binaries、libraries、include 檔案等。
	若在運作中的系統(尤其有許多使用者在用的時候)內更改這些檔案，
	那簡直是自找麻煩的作法。</para>

      <indexterm><primary>multi-user mode</primary></indexterm>
      <para>另一種模式是先在 multi-user 模式下編譯好系統，然後再切到 single user
	模式去安裝。  若您比較喜歡這種方式，只需在 build(編譯過程) 完成之後，
	再去執行下面的步驟即可。  一直到可切換 single user 模式時，再去執行
	<maketarget>installkernel</maketarget> 或
	<maketarget>installworld</maketarget> 即可。</para>

      <para>切換為 root 身份打：</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>這樣就會從原本的 multi-user 模式切換到 single user 模式。</para>

      <para>除此之外也可以重開機，接著在開機選單處選擇
	<quote>single user</quote> 選項。  如此一來就會進入 single user 模式，
	然後在 shell 提示符號處輸入：</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>這樣會先檢查檔案系統，並重新將 <filename>/</filename>
	改以可讀寫的模式掛載，以及 <filename>/etc/fstab</filename>
	內所設定的其他 UFS 檔案系統，最後啟用 swap 磁區。</para>


        <note>
          <para>若 CMOS 時鐘是設為當地時間，而非 GMT 時區(若 &man.date.1;
	    指令沒顯示正確的時間、時區)，那可能需要再輸入下列指令：</para>
<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

          <para>這步驟可以確認您的當地時區設定是否正確 &mdash;
	    否則日後會造成一些問題。</para>
        </note>

    </sect2>

    <sect2>
      <title>移除 <filename>/usr/obj</filename></title>

      <para>在重新編譯系統的過程中，編譯結果會放到(預設情況)
	<filename>/usr/obj</filename> 內。  這裡面的目錄會對應到
	<filename>/usr/src</filename> 的目錄結構。</para>

      <para>砍掉這目錄，可以讓以後的 <command>make buildworld</command>
	過程更快一些，而且可避免以前編譯的東西跟現在的混淆在一起的相依錯亂
	。</para>

      <para>而有些 <filename>/usr/obj</filename> 內的檔案可能會設定不可更動的
	flag(細節請參閱 &man.chflags.1;)，而必須先拿掉這些 flag 設定才行
	。</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 id="cutting-edge-compilebase">
      <title>重新編譯 Base System</title>

      <sect3>
	<title>保留編譯的紀錄</title>

	<para>建議養成好習慣，把執行 &man.make.1; 時產生的紀錄存起來。
	  這樣若有哪邊出錯，就會有錯誤訊息的紀錄。  雖然單單這樣，
	  你可能不知道如何分析是哪邊出了岔，但若把你問題記錄貼到 &os; 相關的
	  mailing list 就可以有人可以幫忙看是怎麼一回事情。</para>

	<para>最簡單的方是就是用 &man.script.1; 指令，並加上參數
	  (你想存放記錄的檔案位置、檔名)即可。
	  這步驟應該在重新編譯系統時就要作，然後在完成編譯後輸入
	  <userinput>exit</userinput> 即可離開。</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>對了，還有一點儘量<emphasis>別把</emphasis>檔案存到
	  <filename>/tmp</filename> 目錄內。  因為重開機之後，
	  這目錄內的東西都會被清空。  比較妥善的地方是
	  <filename>/var/tmp</filename> (如上例所示) 或者是
	  <username>root</username> 的家目錄。</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>編譯 Base System</title>

	<para>首先請先切換到 <filename>/usr/src</filename> 目錄：</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(當然，除非你把 source code 放到其他地方，若真是這樣，
	  就切換到那個目錄即可)。</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>使用 &man.make.1; 指令來重新編譯 world。
	  這指令會從 <filename>Makefile</filename> 檔(這檔會寫 &os;
	  的程式該如何重新編譯、以哪些順序來編譯等等)去讀取相關指令。</para>

	<para>一般下指令的格式如下：</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>在這個例子，<option>-<replaceable>x</replaceable></option>
	  是你想傳給 &man.make.1; 的選項，細節說明請參閱 &man.make.1; 說明，
	  裡面有相關範例說明。</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  則是把變數設定傳給 <filename>Makefile</filename>。  這些變數會控制
	  <filename>Makefile</filename> 的行為。  這些設定與
	  <filename>/etc/make.conf</filename> 的變數設定是一樣，
	  只是另一種設定方式而已。</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

	<para>上面的例子則是另一種設定方式，也就是哪些不要。
	  這個例子中的意思是不去編譯 profiled libraries，效果就如同設定在
	  <filename>/etc/make.conf</filename> 的</para>

	<programlisting>NO_PROFILE=    true 	#    Avoid compiling profiled libraries</programlisting>

	<para><replaceable>target</replaceable> 則是告訴 &man.make.1;
	  該去做哪些。  每個 <filename>Makefile</filename> 都會定義不同的
	  <quote>targets</quote>，然後依您所給的 target 就會決定會做哪些動作
	  。</para>

	<para>Some targets are listed in the
	  <filename>Makefile</filename>, but are not meant for you to run.
	  Instead, they are used by the build process to break out the
	  steps necessary to rebuild the system into a number of
	  sub-steps.</para>

	<para>Most of the time you will not need to pass any parameters to
	    &man.make.1;, and so your command like will look like
	    this:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para>Where <replaceable>target</replaceable> will be one of
	  many build options.  The first target should always be
	  <makevar>buildworld</makevar>.</para>

	<para>As the names imply, <maketarget>buildworld</maketarget>
	  builds a complete new tree under <filename>/usr/obj</filename>,
	  and <maketarget>installworld</maketarget>, another target, installs this tree on
	  the current machine.</para>

	<para>Having separate options is very useful for two reasons.  First, it allows you
	  to do the build safe in the knowledge that no components of
	  your running system will be affected.  The build is
	  <quote>self hosted</quote>.  Because of this, you can safely
	  run <maketarget>buildworld</maketarget> on a machine running
	  in multi-user mode with no fear of ill-effects.  It is still
	  recommended that you run the
	  <maketarget>installworld</maketarget> part in single user
	  mode, though.</para>

	<para>Secondly, it allows you to use NFS mounts to upgrade
	  multiple machines on your network.  If you have three machines,
	  <hostid>A</hostid>, <hostid>B</hostid> and <hostid>C</hostid> that you want to upgrade, run <command>make
	  buildworld</command> and <command>make installworld</command> on
	  <hostid>A</hostid>.  <hostid>B</hostid> and <hostid>C</hostid> should then NFS mount <filename>/usr/src</filename>
	  and <filename>/usr/obj</filename> from <hostid>A</hostid>, and you can then run
	  <command>make installworld</command> to install the results of
	  the build on <hostid>B</hostid> and <hostid>C</hostid>.</para>

	<para>Although the <maketarget>world</maketarget> target still exists,
	  you are strongly encouraged not to use it.</para>

	<para>Run</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

        <para>It is possible to specify a <option>-j</option> option to
          <command>make</command> which will cause it to spawn several
          simultaneous processes.  This is most useful on multi-CPU machines.
          However, since much of the compiling process is IO bound rather
          than CPU bound it is also useful on single CPU machines.</para>

	<para>On a typical single-CPU machine you would run:</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; will then have up to 4 processes running at any one
	  time.  Empirical evidence posted to the mailing lists shows this
	  generally gives the best performance benefit.</para>

	<para>If you have a multi-CPU machine and you are using an SMP
	  configured kernel try values between 6 and 10 and see how they speed
	  things up.</para>
      </sect3>

      <sect3>
	<title>Timings</title>
	<indexterm>
	  <primary>rebuilding <quote>world</quote></primary>
	  <secondary>timings</secondary>
	</indexterm>

        <para>Many factors influence the build time, but fairly recent
          machines may only take a one or two hours to build
          the &os.stable; tree, with no tricks or shortcuts used during the
          process.  A &os.current; tree will take somewhat longer.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Compile and Install a New Kernel</title>
      <indexterm>
        <primary>kernel</primary>
	<secondary>compiling</secondary>
      </indexterm>

      <para>To take full advantage of your new system you should recompile the
	kernel.  This is practically a necessity, as certain memory structures
	may have changed, and programs like &man.ps.1; and &man.top.1; will
	fail to work until the kernel and source code versions are the
	same.</para>

      <para>The simplest, safest way to do this is to build and install a
	kernel based on <filename>GENERIC</filename>.  While
	<filename>GENERIC</filename> may not have all the necessary devices
	for your system, it should contain everything necessary to boot your
	system back to single user mode.  This is a good test that the new
	system works properly.  After booting from
	<filename>GENERIC</filename> and verifying that your system works you
	can then build a new kernel based on your normal kernel	configuration
	file.</para>

      <para>On &os; it is important to <link
        linkend="make-buildworld">build world</link> before building a
        new kernel.</para>

      <note><para>If you want to build a custom kernel, and already have a configuration
	file, just use <literal>KERNCONF=<replaceable>MYKERNEL</replaceable></literal>
	like this:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </note>

      <para>Note that if you have raised <literal>kern.securelevel</literal>
	above 1 <emphasis>and</emphasis> you have set either the
	<literal>noschg</literal> or similar flags to your kernel binary, you
	might find it necessary to drop into single user mode to use
	<maketarget>installkernel</maketarget>.  Otherwise you should be able
	to run both these commands from multi user mode without
	problems.  See &man.init.8; for details about
	<literal>kern.securelevel</literal> and &man.chflags.1; for details
	about the various file flags.</para>
    </sect2>

    <sect2>
      <title>Reboot into Single User Mode</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>You should reboot into single user mode to test the new kernel
	works.  Do this by following the instructions in
	<xref linkend="makeworld-singleuser"/>.</para>
    </sect2>

    <sect2 id="make-installworld">
      <title>Install the New System Binaries</title>

      <para>If you were building a version of &os; recent enough to have
	used <command>make buildworld</command> then you should now use
	<maketarget>installworld</maketarget> to install the new system
	binaries.</para>

      <para>Run</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>If you specified variables on the <command>make
	    buildworld</command> command line, you must specify the same
	  variables in the <command>make installworld</command> command
	  line.  This does not necessarily hold true for other options;
	  for example, <option>-j</option> must never be used with
	  <maketarget>installworld</maketarget>.</para>

	<para>For example, if you ran:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>you must install the results with:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>otherwise it would try to install profiled libraries that
	  had not been built during the <command>make buildworld</command>
	  phase.</para>
      </note>
    </sect2>

    <sect2>
      <title>Update Files Not Updated by <command>make installworld</command></title>

      <para>Remaking the world will not update certain directories (in
	particular, <filename>/etc</filename>, <filename>/var</filename> and
	<filename>/usr</filename>) with new or changed configuration files.</para>

      <para>The simplest way to update these files is to use
        &man.mergemaster.8;, though it is possible to do it manually
        if you would prefer to do that.  Regardless of which way you
	choose, be sure to make a backup of <filename>/etc</filename> in
	case anything goes wrong.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect3info>
      <title><command>mergemaster</command></title>
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>The &man.mergemaster.8; utility is a Bourne script that will
        aid you in determining the differences between your configuration files
        in <filename>/etc</filename>, and the configuration files in
        the source tree <filename>/usr/src/etc</filename>. This is
        the recommended solution for keeping the system configuration files up to date
        with those located in the source tree.</para>

      <para>To begin simply type <command>mergemaster</command> at your prompt, and
        watch it start going.  <command>mergemaster</command> will then build a
        temporary root environment, from <filename>/</filename> down, and populate
        it with various system configuration files.  Those files are then compared
        to the ones currently installed in your system.  At this point, files that
        differ will be shown in &man.diff.1; format, with the <option>+</option> sign
        representing added or modified lines, and <option>-</option> representing
        lines that will be either removed completely, or replaced with a new line.
        See the &man.diff.1; manual page for more information about the &man.diff.1;
        syntax and how file differences are shown.</para>

      <para>&man.mergemaster.8; will then show you each file that displays variances,
        and at this point you will have the option of either deleting the new file (referred
        to as the temporary file), installing the temporary file in its unmodified state,
        merging the temporary file with the currently installed file, or viewing the
        &man.diff.1; results again.</para>

      <para>Choosing to delete the temporary file will tell &man.mergemaster.8; that we
        wish to keep our current file unchanged, and to delete the new version.
        This option is not recommended, unless you see no
        reason to change the current file.  You can get help at any time by
        typing <keycap>?</keycap> at the &man.mergemaster.8; prompt.  If the user
        chooses to skip a file, it will be presented again after all other files
        have been dealt with.</para>

      <para>Choosing to install the unmodified temporary file will replace the
        current file with the new one.  For most unmodified files, this is the best
        option.</para>

      <para>Choosing to merge the file will present you with a text editor,
        and the contents of both files.  You can now merge them by
        reviewing both files side by side on the screen, and choosing parts from
        both to create a finished product.  When the files are compared side by side,
        the <keycap>l</keycap> key will select the left contents and the
        <keycap>r</keycap> key will select contents from your right.
        The final output will be a file consisting of both parts, which can then be
        installed.  This option is customarily used for files where settings have been
        modified by the user.</para>

      <para>Choosing to view the &man.diff.1; results again will show you the file differences
        just like &man.mergemaster.8; did before prompting you for an option.</para>

      <para>After &man.mergemaster.8; is done with the system files you will be
        prompted for other options.  &man.mergemaster.8; may ask if you want to rebuild
        the password file and will finish up with an option to
        remove left-over temporary files.</para>
      </sect3>

      <sect3>
	<title>Manual Update</title>

      <para>If you wish to do the update manually, however,
        you cannot just copy over the files from
	<filename>/usr/src/etc</filename> to <filename>/etc</filename> and
	have it work.  Some of these files must be <quote>installed</quote>
	first.  This is because the <filename>/usr/src/etc</filename>
	directory <emphasis>is not</emphasis> a copy of what your
	<filename>/etc</filename> directory should look like.  In addition,
	there are files that should be in <filename>/etc</filename> that are
	not in <filename>/usr/src/etc</filename>.</para>

      <para>If you are using &man.mergemaster.8; (as recommended),
        you can skip forward to the <link linkend="cutting-edge-rebooting">next
	section</link>.</para>

      <para>The simplest way to do this by hand is to install the
	files into a new directory, and then work through them looking
	for differences.</para>

      <warning>
	<title>Backup Your Existing <filename>/etc</filename></title>

	<para>Although, in theory, nothing is going to touch this directory
	  automatically, it is always better to be sure.  So copy your
	  existing <filename>/etc</filename> directory somewhere safe.
	  Something like:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para><option>-R</option> does a recursive copy, <option>-p</option>
	  preserves times, ownerships on files and suchlike.</para>
      </warning>

      <para>You need to build a dummy set of directories to install the new
	<filename>/etc</filename> and other files into.
	<filename>/var/tmp/root</filename> is a reasonable choice, and
	there are a number of subdirectories required under this as
	well.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>This will build the necessary directory structure and install the
	files.  A lot of the subdirectories that have been created under
	<filename>/var/tmp/root</filename> are empty and should be deleted.
	The simplest way to do this is to:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>This will remove all empty directories.  (Standard error is
        redirected to <filename>/dev/null</filename> to prevent the warnings
        about the directories that are not empty.)</para>

      <para><filename>/var/tmp/root</filename> now contains all the files that
	should be placed in appropriate locations below
	<filename>/</filename>.  You now have to go through each of these
	files, determining how they differ with your existing files.</para>

      <para>Note that some of the files that will have been installed in
	<filename>/var/tmp/root</filename> have a leading <quote>.</quote>.  At the
	time of writing the only files like this are shell startup files in
	<filename>/var/tmp/root/</filename> and
	<filename>/var/tmp/root/root/</filename>, although there may be others
	(depending on when you are reading this).  Make sure you use
	<command>ls -a</command> to catch them.</para>

      <para>The simplest way to do this is to use &man.diff.1; to compare the
	two files:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>This will show you the differences between your
	<filename>/etc/shells</filename> file and the new
	<filename>/var/tmp/root/etc/shells</filename> file.  Use these to decide whether to
	merge in changes that you have made or whether to copy over your old
	file.</para>

      <tip>
	<title>Name the New Root Directory
	  (<filename>/var/tmp/root</filename>) with a Time Stamp, so You Can
	  Easily Compare Differences Between Versions</title>

	<para>Frequently rebuilding the world means that you have to update
	<filename>/etc</filename> frequently as well, which can be a bit of
	  a chore.</para>

	<para>You can speed this process up by keeping a copy of the last set
	  of changed files that you merged into <filename>/etc</filename>.
	  The following procedure gives one idea of how to do this.</para>

	<procedure>
	  <step>
	    <para>Make the world as normal.  When you want to update
	      <filename>/etc</filename> and the other directories, give the
	      target directory a name based on the current date.  If you were
	      doing this on the 14th of February 1998 you could do the
	      following:</para>

	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>Merge in the changes from this directory as outlined
	      above.</para>

	    <para><emphasis>Do not</emphasis> remove the
	      <filename>/var/tmp/root-19980214</filename> directory when you
	      have finished.</para>
	  </step>

	  <step>
	    <para>When you have downloaded the latest version of the source
	      and remade it, follow step 1.  This will give you a new
	      directory, which might be called
	      <filename>/var/tmp/root-19980221</filename> (if you wait a week
	      between doing updates).</para>
	  </step>

	  <step>
	    <para>You can now see the differences that have been made in the
	      intervening week using &man.diff.1; to create a recursive diff
	      between the two directories:</para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	    <para>Typically, this will be a much smaller set of differences
	      than those between
	      <filename>/var/tmp/root-19980221/etc</filename> and
	      <filename>/etc</filename>.  Because the set of differences is
	      smaller, it is easier to migrate those changes across into your
	      <filename>/etc</filename> directory.</para>
	  </step>

	  <step>
	    <para>You can now remove the older of the two
	      <filename>/var/tmp/root-*</filename> directories:</para>

	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>

	  <step>
	    <para>Repeat this process every time you need to merge in changes
	      to <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>You can use &man.date.1; to automate the generation of the
	  directory names:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>

    <sect2 id="cutting-edge-rebooting">
      <title>Rebooting</title>

      <para>You are now done.  After you have verified that everything appears
	to be in the right place you can reboot the system.  A simple
	&man.shutdown.8; should do it:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Finished</title>

      <para>You should now have successfully upgraded your &os; system.
	Congratulations.</para>

      <para>If things went slightly wrong, it is easy to rebuild a particular
        piece of the system.  For example, if you accidentally deleted
        <filename>/etc/magic</filename> as part of the upgrade or merge of
        <filename>/etc</filename>, the &man.file.1; command will stop working.
        In this case, the fix would be to run:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Questions</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Do I need to re-make the world for every change?</para>
	  </question>

	  <answer>
            <para>There is no easy answer to this one, as it depends on the
	      nature of the change.  For example, if you just ran <application>CVSup</application>, and
	      it has shown the following files as being updated:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>it probably is not worth rebuilding the entire world.
	      You could just go to the appropriate sub-directories and
	      <command>make all install</command>, and that's about it.  But
	      if something major changed, for example
	      <filename>src/lib/libc/stdlib</filename> then you should either
	      re-make the world, or at least those parts of it that are
	      statically linked (as well as anything else you might have added
	      that is statically linked).</para>

	    <para>At the end of the day, it is your call.  You might be happy
	      re-making the world every fortnight say, and let changes
	      accumulate over that fortnight.  Or you might want to re-make
	      just those things that have changed, and be confident you can
	      spot all the dependencies.</para>

	    <para>And, of course, this all depends on how often you want to
	      upgrade, and whether you are tracking &os.stable; or
	      &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>My compile failed with lots of signal 11<indexterm>
	      <primary>signal 11</primary></indexterm> (or other signal
	      number) errors.  What has happened?</para>
	  </question>

	  <answer>
	    <para>This is normally indicative of hardware problems.
	      (Re)making the world is an effective way to stress test your
	      hardware, and will frequently throw up memory problems.  These
	      normally manifest themselves as the compiler mysteriously dying
	      on receipt of strange signals.</para>

	    <para>A sure indicator of this is if you can restart the make and
	      it dies at a different point in the process.</para>

	    <para>In this instance there is little you can do except start
	      swapping around the components in your machine to determine
	      which one is failing.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Can I remove <filename>/usr/obj</filename> when I have
	      finished?</para>
	  </question>

	  <answer>
	    <para>The short answer is yes.</para>

	    <para><filename>/usr/obj</filename> contains all the object files
	      that were produced during the compilation phase.  Normally, one
	      of the first steps in the <command>make buildworld</command> process is to
	      remove this directory and start afresh.  In this case, keeping
	      <filename>/usr/obj</filename> around after you have finished
	      makes little sense, and will free up a large chunk of disk space
	      (currently about 340&nbsp;MB).</para>

	    <para>However, if you know what you are doing you can have
	      <command>make buildworld</command> skip this step.  This will make subsequent
	      builds run much faster, since most of sources will not need to
	      be recompiled.  The flip side of this is that subtle dependency
	      problems can creep in, causing your build to fail in odd ways.
	      This frequently generates noise on the &os; mailing lists,
	      when one person complains that their build has failed, not
	      realizing that it is because they have tried to cut
	      corners.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Can interrupted builds be resumed?</para>
	  </question>

	  <answer>
	    <para>This depends on how far through the process you got before
	      you found a problem.</para>

	    <para><emphasis>In general</emphasis> (and this is not a hard and
	      fast rule) the <command>make buildworld</command> process builds new
	      copies of essential tools (such as &man.gcc.1;, and
	      &man.make.1;) and the system libraries.  These tools and
	      libraries are then installed.  The new tools and libraries are
	      then used to rebuild themselves, and are installed again. The
	      entire system (now including regular user programs, such as
		&man.ls.1; or &man.grep.1;) is then rebuilt with the new
	      system files.</para>

	    <para>If you are at the last stage, and you know it (because you
	      have looked through the output that you were storing) then you
	      can (fairly safely) do:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>This will not undo the work of the previous
	      <command>make buildworld</command>.</para>

	    <para>If you see the message:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>in the <command>make buildworld</command> output then it is
	      probably fairly safe to do so.</para>

	    <para>If you do not see that message, or you are not sure, then it
	      is always better to be safe than sorry, and restart the build
	      from scratch.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>How can I speed up making the world?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Run in single user mode.</para>
	      </listitem>

	      <listitem>
		<para>Put the <filename>/usr/src</filename> and
		  <filename>/usr/obj</filename> directories on separate
		  file systems held on separate disks.  If possible, put these
		  disks on separate disk controllers.</para>
	      </listitem>

	      <listitem>
		<para>Better still, put these file systems across multiple
		  disks using the &man.ccd.4; (concatenated disk
		  driver) device.</para>
	      </listitem>

	      <listitem>
		<para>Turn off profiling (set <quote>NO_PROFILE=true</quote> in
		  <filename>/etc/make.conf</filename>).  You almost certainly
		  do not need it.</para>
	      </listitem>

	      <listitem>
		<para>Also in <filename>/etc/make.conf</filename>, set
		  <makevar>CFLAGS</makevar> to something like <option>-O
		  -pipe</option>.  The optimization <option>-O2</option> is much
		  slower, and the optimization difference between
		  <option>-O</option> and <option>-O2</option> is normally
		  negligible.  <option>-pipe</option> lets the compiler use
		  pipes rather than temporary files for communication, which
		  saves disk access (at the expense of memory).</para>
	      </listitem>

	      <listitem>
		<para>Pass the <option>-j<replaceable>n</replaceable></option> option to &man.make.1; to
		  run multiple processes in parallel.  This usually helps
		  regardless of whether you have a single or a multi processor
		  machine.</para>
	      </listitem>

	      <listitem><para>The file system holding
		  <filename>/usr/src</filename> can be mounted (or remounted)
		  with the <option>noatime</option> option.  This prevents the
		  file system from recording the file access time.  You probably
		  do not need this information anyway.</para>

		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		  <warning>
		    <para>The example assumes <filename>/usr/src</filename> is
		      on its own file system.  If it is not (if it is a part of
		      <filename>/usr</filename> for example) then you will
		      need to use that file system mount point, and not
		      <filename>/usr/src</filename>.</para>
		  </warning>
	      </listitem>

	      <listitem>
		<para>The file system holding <filename>/usr/obj</filename> can
		  be mounted (or remounted) with the <option>async</option>
		  option.  This causes disk writes to happen asynchronously.
		  In other words, the write completes immediately, and the
		  data is written to the disk a few seconds later.  This
		  allows writes to be clustered together, and can be a
		  dramatic performance boost.</para>

		<warning>
		  <para>Keep in mind that this option makes your file system
		    more fragile.  With this option there is an increased
		    chance that, should power fail, the file system will be in
		    an unrecoverable state when the machine restarts.</para>

		  <para>If <filename>/usr/obj</filename> is the only thing on
		    this file system then it is not a problem.  If you have
		    other, valuable data on the same file system then ensure
		    your backups are fresh before you enable this
		    option.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>As above, if <filename>/usr/obj</filename> is not on
		    its own file system, replace it in the example with the
		    name of the appropriate mount point.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
            <para>What do I do if something goes wrong?</para>
          </question>

          <answer>
            <para>Make absolutely sure your environment has no
              extraneous cruft from earlier builds.  This is simple
              enough.</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

            <para>Yes, <command>make cleandir</command> really should
              be run twice.</para>

            <para>Then restart the whole process, starting
              with <command>make buildworld</command>.</para>

            <para>If you still have problems, send the error and the
              output of <command>uname -a</command> to &a.questions;.
              Be prepared to answer other questions about your
              setup!</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Tracking for Multiple Machines</title>
    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>

    <para>If you have multiple machines that you want to track the
      same source tree, then having all of them download sources and
      rebuild everything seems like a waste of resources: disk space,
      network bandwidth, and CPU cycles.  It is, and the solution is
      to have one machine do most of the work, while the rest of the
      machines mount that work via NFS.  This section outlines a
      method of doing so.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Preliminaries</title>

      <para>First, identify a set of machines that is going to run
	the same set of binaries, which we will call a
	<emphasis>build set</emphasis>.  Each machine can have a
	custom kernel, but they will be running the same userland
	binaries.  From that set, choose a machine to be the
	<emphasis>build machine</emphasis>.  It is going to be the
	machine that the world and kernel are built on. Ideally, it
	should be a fast machine that has sufficient spare CPU to
	run <command>make buildworld</command> and
	<command>make buildkernel</command>.  You will also want to
	choose a machine to be the <emphasis>test
	machine</emphasis>, which will test software updates before they
	are put into production.  This <emphasis>must</emphasis> be a
	machine that you can afford to have down for an extended
	period of time.  It can be the build machine, but need not be.</para>

      <para>All the machines in this build set need to mount
	<filename>/usr/obj</filename> and
	<filename>/usr/src</filename> from the same machine, and at
	the same point.  Ideally, those are on two different drives
	on the build machine, but they can be NFS mounted on that machine
	as well.  If you have multiple build sets,
	<filename>/usr/src</filename> should be on one build machine, and
	NFS mounted on the rest.</para>

      <para>Finally make sure that
	<filename>/etc/make.conf</filename> on all the machines in
	the build set agrees with the build machine.  That means that
	the build machine must build all the parts of the base
	system that any machine in the build set is going to
	install.  Also, each build machine should have its kernel
	name set with <makevar>KERNCONF</makevar> in
	<filename>/etc/make.conf</filename>, and the build machine
	should list them all in <makevar>KERNCONF</makevar>, listing
	its own kernel first.  The build machine must have the kernel
	configuration files for each machine in
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	if it is going to build their kernels.</para>
    </sect2>

    <sect2>
      <title>The Base System</title>

      <para>Now that all that is done, you are ready to build
	everything.  Build the kernel and world as described in <xref
	linkend="make-buildworld"/> on the build machine,
	but do not install anything.  After the build has finished, go
	to the test machine, and install the kernel you just
	built.  If this machine mounts <filename>/usr/src</filename>
	and <filename>/usr/obj</filename> via NFS, when you reboot
	to single user you will need to enable the network and mount
	them.  The easiest way to do this is to boot to multi-user,
	then run <command>shutdown now</command> to go to single user
	mode.  Once there, you can install the new kernel and world and run
	<command>mergemaster</command> just as you normally would.  When
	done, reboot to return to normal multi-user operations for this
	machine.</para>

      <para>After you are certain that everything on the test
	machine is working properly, use the same procedure to
	install the new software on each of the other machines in
	the build set.</para>
    </sect2>

    <sect2>
      <title>Ports</title>

      <para>The same ideas can be used for the ports tree.  The first
	critical step is mounting <filename>/usr/ports</filename> from
	the same machine to all the machines in the build set.  You can
	then set up <filename>/etc/make.conf</filename> properly to share
	distfiles.  You should set <makevar>DISTDIR</makevar> to a
	common shared directory that is writable by whichever user
	<username>root</username> is mapped to by your NFS mounts.  Each
	machine should set <makevar>WRKDIRPREFIX</makevar> to a
	local build directory.  Finally, if you are going to be
	building and distributing packages, you should set
	<makevar>PACKAGES</makevar> to a directory similar to
	<makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>
