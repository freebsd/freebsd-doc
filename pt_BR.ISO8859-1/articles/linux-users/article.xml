<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook XML V4.5-Based Extension//EN"
	"../../../share/xml/freebsd45.dtd">

<!--
  The FreeBSD Documentation Project
  The FreeBSD Brazilian Portuguese Documentation Project

  Original revision: r39808
-->

<article lang='pt_br'>
  <articleinfo>
    <title>Guia Rápido do FreeBSD para Usuários 
      &linux;</title>

    <authorgroup>
      <author>
	<firstname>John</firstname>
	<surname>Ferrell</surname>
      </author>
    </authorgroup>

    <copyright>
      <year>2008</year>
      <holder>The FreeBSD Documentation Project</holder>
    </copyright>

    <pubdate>$FreeBSD$</pubdate>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <legalnotice id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.linux;
      &tm-attrib.intel;
      &tm-attrib.redhat;
      &tm-attrib.unix;
      &tm-attrib.general;
    </legalnotice>

    <abstract>
      <para>O objetivo deste documento é familiarizar 
	rapidamente os usuários intermediários e 
	avançados de &linux; com o FreeBSD.</para>
    </abstract>
  </articleinfo>

  <sect1 id="intro">
    <title>Introdução</title>

    <para>Este documento irá destacar as diferenças 
      entre &os; e &linux; para que os usuários 
      intermediários e avançados possam rapidamente 
      se familiarizar com os conceitos básicos do FreeBSD.
      Esta é apenas uma rápida introdução
      técnica, ela não tenta discutir as 
      diferenças <quote>filosóficas</quote> entre os 
      dois sistemas operacionais.</para>

    <para>Este documento assume que você já tem o &os; 
      instalado.  Se você não tem o &os; instalado ou 
      precisa de ajuda com o processo de instalação, 
      por favor, consulte o capítulo <ulink
      url="&url.base;/doc/en_US.ISO8859-1/books/handbook/install.html">
      Instalando o FreeBSD</ulink> no Handbook.</para>
  </sect1>

  <sect1 id="shells">
    <title><literal>Shells</literal>: Sem Bash?</title>

    <para>Usuários vindos do &linux; são frequentemente 
      surpreendidos por não encontrarem o 
      <application>Bash</application> como o
      <literal>shell</literal> padrão no &os;.  De fato, o
      <application>Bash</application> nem mesmo está 
      presente na instalação padrão.  Em vez 
      disso, o &os; usa o &man.tcsh.1; como <literal>shell</literal> 
      padrão.  Embora o <application>Bash</application> e 
      seus outros <literal>shells</literal> favoritos estejam 
      disponíveis na <ulink url="article.html#SOFTWARE">
      Coleção&nbsp;de&nbsp;<literal>Ports</literal>
      </ulink> do &os;.</para>

    <para>Se você instalar outros <literal>shells</literal>, o
      &man.chsh.1; poderá ser usado para definir o
      <literal>shell</literal> padrão dos usuários.  
      Contudo, é recomendável que o 
      <literal>shell</literal> padrão do
      <username>root</username> permaneça inalterado.  A 
      razão para isso é que 
      <literal>shells</literal> não incluídos na 
      base do sistema são normalmente instalados em
      <filename>/usr/local/bin</filename> ou
      <filename>/usr/bin</filename>.  Caso ocorra um 
      problema no sistema de arquivos no qual estão localizados
      o <filename>/usr/local/bin</filename> e o
      <filename>/usr/bin</filename>, eles não poderão 
      ser montados.  Neste caso, o usuário 
      <username>root</username> não teria acesso ao seu 
      <literal>shell</literal> padrão, o que o impediria de
      efetuar login.  Por este motivo uma segunda conta
      <username>root</username>, a conta <username>toor</username>, 
      foi criada para uso com <literal>shells</literal> que 
      não fazem parte da base do sistema.  Leia o 
      <literal>FAQ</literal> de segurança para obter 
      informações sobre a <ulink
      url="&url.base;/doc/en_US.ISO8859-1/books/faq/security.html#TOOR-ACCOUNT">conta toor</ulink>.</para>
  </sect1>

  <sect1 id="software">
    <title>Pacotes e <literal>Ports</literal>: Adicionando programas 
      no &os;</title>

    <para>Além do tradicional método &unix; de 
      instalação de programas (baixar o código 
      fonte, extrair, editar o código fonte, e compilar),
      o &os; oferece dois outros métodos para instalar 
      aplicações: pacotes e <literal>ports</literal>.  
      Uma lista completa de todos os <literal>ports</literal> e 
      pacotes disponíveis pode ser encontrada <ulink
      url="http://www.freebsd.org/ports/master-index.html">aqui</ulink>.</para>

    <sect2 id="packages">
      <title>Pacotes</title>

      <para>Pacotes são aplicações 
	pré-compiladas, o equivalente no &os; ao 
	<filename>.deb</filename> nos sistemas baseados no 
	Debian/Ubuntu e ao <filename>.rpm</filename> nos
	sistemas baseados no Red&nbsp;Hat/Fedora.  Pacotes 
	são instalados usando &man.pkg.add.1;.  Por exemplo, 
	o seguinte comando instala o 
	<application>Apache 2.2</application>:</para>

      <screen>&prompt.root; <userinput>pkg_add <replaceable>/tmp/apache-2.2.6_2.tbz</replaceable></userinput></screen>

      <para>Usar a opção <option>-r</option> 
	dirá ao &man.pkg.add.1; para baixar automaticamente 
	o pacote e instalá-lo, juntamente com quaisquer 
	dependências que ele possua:</para>

      <screen>&prompt.root; <userinput>pkg_add -r <replaceable>apache22</replaceable></userinput>
Fetching ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6.2-release/Latest/apache22.tbz... Done.
Fetching ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6.2-release/All/expat-2.0.0_1.tbz... Done.
Fetching ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6.2-release/All/perl-5.8.8_1.tbz... Done.
[snip]

To run apache www server from startup, add apache22_enable="YES"
in your /etc/rc.conf. Extra options can be found in startup script.</screen>

      <note>
	<para>Se você está rodando uma versão de 
	  <literal>release</literal> do &os; (6.2, 6.3, 7.0, etc., 
	  geralmente instalada a partir de um CD-ROM) o 
	  <command>pkg_add -r</command> vai baixar o pacote compilado
	  especificamente para esta versão.  Este pacote
	  <emphasis>pode não</emphasis> ser a versão 
	  mais atual da aplicação.  Você pode 
	  usar a variável <envar>PACKAGESITE</envar> para 
	  sobrescrever este comportamento padrão.  Por 
	  exemplo, ajuste <envar>PACKAGESITE</envar> para <ulink
	  url="ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-6-stable/Latest/"></ulink>
	  para baixar os pacotes mais recentes compilados para a 
	  série 6.X.</para>
      </note>

      <para>Para mais informações sobre pacotes, por 
	favor, consulte a seção 4.4 do Handbook do 
	&os;: <ulink
	url="&url.base;/doc/en_US.ISO8859-1/books/handbook/packages-using.html">
	Usando o Sistema de Pacotes</ulink>.</para>
    </sect2>

    <sect2 id="ports">
      <title><literal>Ports</literal></title>

      <para>O segundo método para instalação 
	de aplicações no &os; é a 
	Coleção&nbsp;de&nbsp;<literal>Ports</literal>.  
	A Coleção&nbsp;de&nbsp;<literal>Ports</literal>
	é um <foreignphrase>framework</foreignphrase> de
	<filename>Makefiles</filename> e 
	<foreignphrase>patches</foreignphrase> especialmente
	customizados para a instalação de vários
	programas a partir do código fonte no &os;.  Ao 
	instalar um <literal>port</literal> o sistema irá 
	baixar o código fonte, aplicar qualquer
	<foreignphrase>patch</foreignphrase> necessário, 
	compilar o código, e instalar a 
	aplicação.  O mesmo processo será
	aplicado para todas as suas dependências.</para>

      <para>A Coleção de <literal>Ports</literal>, por 
	vezes designada como a árvore de 
	<literal>ports</literal>, pode ser encontrada em 
	<filename>/usr/ports</filename>.  Isto assumindo que a 
	Coleção de <literal>Ports</literal> foi 
	instalada durante o processo de instalação do 
	&os;.  Se a Coleção de <literal>Ports</literal>
	não foi instalada, ela pode ser adicionada a partir 
	dos discos de instalação usando 
	&man.sysinstall.8;, ou baixada dos servidores do &os; usando 
	&man.csup.1; ou &man.portsnap.8;.  Instruções
	detalhadas para a instalação da 
	Coleção de <literal>Ports</literal> podem ser 
	encontradas na <ulink
	url="&url.base;/doc/en_US.ISO8859-1/books/handbook/ports-using.html">
	seção 4.5.1</ulink> do Handbook.</para>

      <para>A instalação de um <literal>port</literal> 
	é tão simples (geralmente) quanto entrar no 
	diretório do <literal>port</literal> desejado e 
	iniciar o processo de compilação.  O exemplo 
	seguinte instala o <application>Apache 2.2</application> a 
	partir da Coleção de 
	<literal>Ports</literal>:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/www/apache22</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Um grande benefício do uso do 
	<literal>ports</literal> para instalar programas é a 
	possibilidade de personalizar as opções de 
	instalação.  Por exemplo, ao instalar o
	<application>Apache 2.2</application> a partir do
	<literal>ports</literal>, você poderá habilitar 
	o <application>mod_ldap</application> definindo a 
	variável <makevar>WITH_LDAP</makevar> ao executar
	&man.make.1;:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/www/apache22</userinput>
&prompt.root; <userinput>make WITH_LDAP="YES" install clean</userinput></screen>

      <para>Por favor, leia a seção 4.5 do Handbook do 
	&os;, <ulink
        url="&url.base;/doc/en_US.ISO8859-1/books/handbook/ports-using.html">
	 Usando a Coleção de 
	 <literal>Ports</literal></ulink>, para maiores 
	 informações sobre a Coleção de
	<literal>Ports</literal>.</para>
    </sect2>

    <sect2 id="which">
      <title><literal>Ports</literal> ou pacotes, qual eu devo usar?</title>

      <para>Pacotes são apenas <literal>ports</literal>
	pré-compilados, então na prática é
	uma questão de instalarmos a partir do código 
	fonte (<literal>ports</literal>) contra instalarmos de um
        pacote binário.  Cada método tem seus 
	próprios benefícios:</para>

      <itemizedlist>
	<title>Pacotes (binário)</title>

	<listitem><simpara>Instalação rápida 
	  (a compilação de grandes 
	  aplicações pode ser um tanto 
	  demorada).</simpara></listitem>

	<listitem><simpara>Você não precisar saber como 
	  compilar o programa.</simpara></listitem>

	<listitem><simpara>Não é necessário 
	  instalar compiladores no seu sistema.</simpara></listitem>
      </itemizedlist>

      <itemizedlist>
	<title><literal>Ports</literal> (código fonte)</title>

	<listitem><simpara>Possibilidade de personalizar as 
	  opções de instalação.  (Pacotes 
	  normalmente são compilados com as 
	  opções padrões.  Com  o 
	  <literal>ports</literal> você pode personalizar 
	  várias opções, como a 
	  compilação de módulos adicionais ou 
	  a mudança do <foreignphrase>path</foreignphrase> de 
	  instalação 
	  padrão.)</simpara></listitem>

	<listitem><simpara>Você pode aplicar seus 
	  próprios <foreignphrase>patches</foreignphrase> se 
	  assim desejar.</simpara></listitem>
      </itemizedlist>

      <para>Se você não tem qualquer requisito especial,
	o sistema de pacotes provavelmente vai se adequar 
	muito bem à sua situação.  Se 
	você for precisar personalizar a 
	instalação, o <literal>ports</literal> é
	a melhor opção.  (E lembre-se, se você 
	precisa personalizar a instalação, mas prefere 
	pacotes, você pode compilar um pacote personalizado a 
	partir do <literal>ports</literal> usando 
	<command>make</command> <maketarget>package</maketarget> e, 
	em seguida, copiar o pacote para outros servidores.)</para>
    </sect2>
  </sect1>

  <sect1 id="startup">
    <title>Inicialização do Sistema: Onde estão 
      os <foreignphrase>run-levels</foreignphrase>?</title>

    <para>O &linux; usa o sistema <literal>SysV init</literal>, 
      enquanto o &os; usa o tradicional <literal>BSD-style</literal>
      &man.init.8;.  Sob o <literal>BSD-style</literal> &man.init.8;
      não existem <foreignphrase>run-levels</foreignphrase> e
      nem <filename>/etc/inittab</filename>, em vez disso a 
      inicialização é controlada pelo 
      utilitário &man.rc.8;.  O <literal>script</literal> 
      <filename>/etc/rc</filename> lê
      <filename>/etc/defaults/rc.conf</filename> e
      <filename>/etc/rc.conf</filename> para determinar quais 
      serviços serão iniciados.  Os serviços 
      especificados são, então, inicializados rodando 
      os <literal>scripts</literal> de inicialização 
      correspondentes em <filename>/etc/rc.d/</filename>
      e <filename>/usr/local/etc/rc.d/</filename>.  Esses
      <literal>scripts</literal> são similares aos
      <literal>scripts</literal> localizados em
      <filename>/etc/init.d/</filename> nos sistemas &linux;.</para>

    <sidebar>
      <para><emphasis>Por que existem dois locais para
        <literal>scripts</literal> de inicialização de
        serviços?</emphasis>  Os <literal>scripts</literal> 
	encontrados em <filename>/etc/rc.d/</filename> são 
	para aplicações que são parte da 
	<quote>base</quote> do sistema.  (&man.cron.8;, &man.sshd.8;,
	&man.syslog.3;, e outros.)  Os <literal>scripts</literal> em
	<filename>/usr/local/etc/rc.d/</filename> são para 
	aplicações instaladas pelo usuário, como
	<application>Apache</application>, 
	<application>Squid</application>, etc.</para>

      <para><emphasis>Qual é a diferença entre a 
	<quote>base</quote> do sistema e as aplicações 
	instaladas pelo usuário?</emphasis> O &os; é 
	desenvolvido como um sistema operacional completo.
	Em outras palavras, o <literal>kernel</literal>, bibliotecas
	do sistema, e utilitários de nível de 
	usuário (como &man.ls.1;, &man.cat.1;, &man.cp.1;, 
	etc.) são desenvolvidos juntos e lançados como 
	um só.  Isso é designado como 
	<quote>base</quote> do sistema.  As aplicações 
	instaladas pelo usuário são 
	aplicações que não fazem parte da
	<quote>base</quote> do sistema, como
	<application>Apache</application>, 
	<application>X11</application>,
	<application>Mozilla&nbsp;Firefox</application>, etc.  Estas
	aplicações instaladas pelo usuário 
	são geralmente instaladas usando os <ulink 
	url="article.html#SOFTWARE">Pacotes e a Coleção
	de <literal>Ports</literal></ulink>.  A fim de mantê-las
	separadas da <quote>base</quote> do sistema, as
	aplicações dos usuário são 
	normalmente instaladas sob <filename>/usr/local/</filename>.  
	Portanto, os binários instalados pelo usuário 
	residem em <filename>/usr/local/bin/</filename>, arquivos de 
	configuração em 
	<filename>/usr/local/etc/</filename>, e assim por 
	diante.</para>
    </sidebar>

    <para>Os Serviços são ativados espeficificando
      <literal><replaceable>NomeDoServiço</replaceable>_enable="YES"</literal>
      em <filename>/etc/rc.conf</filename> (&man.rc.conf.5;).  
      Dê uma olhada em 
      <filename>/etc/defaults/rc.conf</filename> para visualizar os 
      padrões do sistema, essas configurações 
      padrões podem ser sobrescritas por 
      configurações em 
      <filename>/etc/rc.conf</filename>.  Quando instalar 
      aplicações adicionais não deixe de 
      analisar a documentação para determinar
      como ativar qualquer serviço associado.</para>

    <para>O seguinte trecho do <filename>/etc/rc.conf</filename> ativa
      o &man.sshd.8; e o <application>Apache 2.2</application>.  Ele
      também determina que o <application>Apache</application>
      deve ser iniciado com SSL.</para>

    <programlisting># enable SSHD
sshd_enable="YES"
# enable Apache with SSL
apache22_enable="YES"
apache22_flags="-DSSL"</programlisting>

    <para>Uma vez que o serviço foi ativado em
      <filename>/etc/rc.conf</filename>, ele pode ser inicializado
      pela linha de comando (sem precisar reinicializar o
      sistema):</para>

    <screen>&prompt.root; <userinput><replaceable>/etc/rc.d/sshd</replaceable> start</userinput></screen>

    <para>Se o serviço não foi ativado, ele pode ser 
      inicializado pela linha de comando usando 
      <option>forcestart</option>:</para>

    <screen>&prompt.root; <userinput><replaceable>/etc/rc.d/sshd</replaceable> forcestart</userinput></screen>
  </sect1>

  <sect1 id="network">
    <title>Configuração da rede</title>

    <sect2 id="interfaces">
      <title>Interfaces de Rede</title>

      <para>Em vez do identificador genérico
        <emphasis>ethX</emphasis>, que o &linux; usa para identificar
        uma interface de rede, o &os; usa o nome do driver do 
	dispositivo de rede seguido por um número como 
	identificador.  A seguinte saída do &man.ifconfig.8; 
	mostra duas interfaces de rede &intel;&nbsp;Pro&nbsp;1000 
	(<devicename>em0</devicename> e <devicename>em1</devicename>):
	</para>

      <screen>&prompt.user; <userinput>ifconfig</userinput>
em0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        options=b&lt;RXCSUM,TXCSUM,VLAN_MTU&gt;
        inet 10.10.10.100 netmask 0xffffff00 broadcast 10.10.10.255
        ether 00:50:56:a7:70:b2
        media: Ethernet autoselect (1000baseTX &lt;full-duplex&gt;)
        status: active
em1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        options=b&lt;RXCSUM,TXCSUM,VLAN_MTU&gt;
        inet 192.168.10.222 netmask 0xffffff00 broadcast 192.168.10.255
        ether 00:50:56:a7:03:2b
        media: Ethernet autoselect (1000baseTX &lt;full-duplex&gt;)
        status: active</screen>
    </sect2>

    <sect2 id="ipaddress">
      <title>Configuração IP</title>

      <para>Um endereço IP pode ser atribuído a uma 
	interface de rede usando &man.ifconfig.8;.  No entanto, para 
	mantê-lo persistente entre as 
	reinicializações, a configuração 
	deve ser incluída em <filename>/etc/rc.conf</filename>.
	O seguinte exemplo configura o <literal>hostname</literal>, o 
	endereço IP, e o <literal>gateway</literal> 
	padrão:</para>

      <programlisting>hostname="server1.example.com"
ifconfig_em0="inet 10.10.10.100  netmask 255.255.255.0"
defaultrouter="10.10.10.1"</programlisting>

      <para>Use a seguinte sintaxe para configurar a interface para
        DHCP:</para>

      <programlisting>hostname="server1.example.com"
ifconfig_em0="DHCP"</programlisting>

    </sect2>
  </sect1>

  <sect1 id="firewall">
    <title><literal>Firewall</literal></title>

    <para>Como o <application>IPTABLES</application> no &linux;, o 
      &os; também oferece um <literal>firewall</literal> ao 
      nível de <literal>kernel</literal>; atualmente o &os; 
      oferece três opções de 
      <literal>firewalls</literal>:</para>

    <itemizedlist>
      <listitem><simpara><ulink url="&url.base;/doc/en_US.ISO8859-1/books/handbook/firewalls-ipfw.html">IPFIREWALL</ulink></simpara></listitem>
      <listitem><simpara><ulink url="&url.base;/doc/en_US.ISO8859-1/books/handbook/firewalls-ipf.html">IPFILTER</ulink></simpara></listitem>
      <listitem><simpara><ulink url="&url.base;/doc/en_US.ISO8859-1/books/handbook/firewalls-pf.html">PF</ulink></simpara></listitem>
    </itemizedlist>

    <para>O <application>IPFIREWALL</application>, ou
      <application>IPFW</application> (o comando para gerenciar um
      conjunto de regras <application>IPFW</application> é 
      &man.ipfw.8;), é o <literal>firewall</literal> 
      desenvolvido e mantido pelos desenvolvedores do &os;.  O 
      <application>IPFW</application> pode ser integrado com 
      &man.dummynet.4; para prover a capacidade de controle de 
      tráfego e simular diferentes tipos de conexões de
      rede.</para>

    <para>Amostra de uma regra do <application>IPFW</application> para
      permitir uma conexão de entrada do 
      <application>SSH</application>:</para>

    <programlisting>ipfw add allow tcp from any to me 22 in via $ext_if</programlisting>

    <para><application>IPFILTER</application> é um aplicativo 
      de <literal>firewall</literal> desenvolvido por 
      Darren&nbsp;Reed.  Ele não é específico 
      para o &os; e foi portado para vários sistemas 
      operacionais, incluindo NetBSD, OpenBSD, SunOS, HP/UX, e 
      Solaris.</para>

    <para>Amostra do comando <application>IPFILTER</application> para
      permitir uma conexão de entrada do 
      <application>SSH</application>:</para>

    <programlisting>pass in on $ext_if proto tcp from any to any port = 22</programlisting>

    <para>O último aplicativo de <literal>firewall</literal>,
      <application>PF</application>, é desenvolvido pelo 
      projeto OpenBSD.  O <application>PF</application> foi criado 
      como um substituto para o <application>IPFILTER</application>. 
      Como tal, a sintaxe do <application>PF</application> é 
      muito similar à do <application>IPFILTER</application>.
      O <application>PF</application> pode ser integrado com
      &man.altq.4; para prover recursos de QoS.</para>

    <para>Amostra do comando <application>PF</application> para
      permitir uma conexão de entrada do 
      <application>SSH</application>:</para>

     <programlisting>pass in on $ext_if inet proto tcp from any to ($ext_if) port 22</programlisting>
  </sect1>

  <sect1 id="updates">
    <title>Atualizando o &os;</title>

    <para>Existem três métodos para atualizar um 
      sistema &os;: a partir do código fonte, 
      atualização binária, e a partir dos 
      discos de instalação.</para>

    <para>A atualização a partir do código 
      fonte é a mais demorada, mas por outro lado é 
      a que oferece a maior flexibilidade.  O processo envolve a
      sincronização de uma cópia local do 
      código fonte do sistema a partir dos servidores 
      <application>Subversion</application> do &os;.  Uma vez que o
      código fonte local está atualizado, você pode compilar a nova
      versão do <literal>kernel</literal> e dos aplicativos de nível
      de usuário.  Para maiores informações sobre atualizações a
      partir do código fonte veja <ulink
      url="&url.base;/doc/en_US.ISO8859-1/books/handbook/updating-upgrading.html">
      o capítulo sobre atualização</ulink> no 
      Handbook do &os;.</para>

    <para>As atualizações binárias são 
      similares ao uso do <command>yum</command> ou 
      <command>apt-get</command> para atualizar sistemas &linux;.  O 
      comando &man.freebsd-update.8; vai baixar e instalar as novas 
      atualizações.  As atualizações 
      podem ser agendadas usando &man.cron.8;.</para>

    <note>
      <para>Se você utilizar o &man.cron.8; para agendar as 
	atualizações, por favor, certifique-se de 
	usar <command>freebsd-update cron</command> em seu 
	&man.crontab.1; para reduzir a possibilidade de que um 
	grande número de máquinas busquem as
	atualizações todas ao mesmo tempo.</para>

      <programlisting>0 3 * * * root /usr/sbin/freebsd-update cron</programlisting>
    </note>

    <para>O último método de atualização,
      a partir dos discos de instalação, é um 
      processo bastante simples.  Efetue o <literal>boot</literal> 
      a partir dos discos de instalação e selecione a 
      opção para atualizar.</para>
  </sect1>

  <sect1 id="procfs">
    <title>procfs: Morto, mas vivo na memória</title>

    <para>No &linux;, para determinar se o encaminhamento IP 
      está ativado, você pode olhar em
      <filename>/proc/sys/net/ipv4/ip_forward</filename>.  No &os;
      você precisa usar o &man.sysctl.8; para ver esta e 
      outras opções do sistema, pois o &man.procfs.5; 
      tornou-se obsoleto nas versões mais recentes do &os;.  
      (Embora <command>sysctl</command> também esteja 
      disponível no &linux;.)</para>

    <para>No exemplo do encaminhamento IP, você poderia usar o
      seguinte comando para determinar se ele está ativado no
      seu sistema FreeBSD:</para>

    <screen>&prompt.user; <userinput>sysctl net.inet.ip.forwarding</userinput>
net.inet.ip.forwarding: 0</screen>

    <para>A opção <option>-a</option> é 
      utilizada para listar todas as configurações 
      do sistema:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput>
kern.ostype: FreeBSD
kern.osrelease: 6.2-RELEASE-p9
kern.osrevision: 199506
kern.version: FreeBSD 6.2-RELEASE-p9 #0: Thu Nov 29 04:07:33 UTC 2007
    root@i386-builder.daemonology.net:/usr/obj/usr/src/sys/GENERIC

kern.maxvnodes: 17517
kern.maxproc: 1988
kern.maxfiles: 3976
kern.argmax: 262144
kern.securelevel: -1
kern.hostname: server1
kern.hostid: 0
kern.clockrate: { hz = 1000, tick = 1000, profhz = 666, stathz = 133 }
kern.posix1version: 200112
...</screen>

    <note>
      <para>Alguns dos valores do <command>sysctl</command>
      estão disponíveis somente para 
      leitura.</para></note>

    <para>Existem ocasiões nas quais o <literal>procfs</literal> 
      é necessário, como na execução de 
      programas antigos, no uso do &man.truss.1; para rastrear 
      chamadas de sistema, e para possibilitar a <ulink
      url="&url.base;/doc/en_US.ISO8859-1/books/handbook/linuxemu.html">
      Compatibilidade Binária com Linux</ulink>.  
      (Embora a Compatibilidade Binária com Linux use seu 
      próprio <literal>procfs</literal>, &man.linprocfs.5;.)  
      Se você precisar montar o <literal>procfs</literal>, 
      você pode adicionar a seguinte entrada no 
      <filename>/etc/fstab</filename>:</para>

    <screen>proc                /proc           procfs  rw,noauto       0       0</screen>

    <note>
      <para><option>noauto</option> vai prevenir
        <filename>/proc</filename> de ser montado automaticamente
	durante o <literal>boot</literal>.</para></note>

    <para>E então monte o <literal>procfs</literal> com:</para>

    <screen>&prompt.root; <userinput>mount /proc</userinput></screen>
  </sect1>

  <sect1 id="commands">
    <title>Comandos Comuns</title>

    <sect2 id="packageCommands">
      <title>Gerenciamento de Pacotes</title>

      <para>
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Comando no &linux; (Red&nbsp;Hat/Debian)</entry>
		<entry>Equivalente no &os;</entry>
		<entry>propósito</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><command>yum install <replaceable>pacote</replaceable></command> / <command>apt-get install <replaceable>pacote</replaceable></command></entry>
		<entry><command>pkg_add -r <replaceable>pacote</replaceable></command></entry>
		<entry>Instala o <replaceable>pacote</replaceable> a partir do repositório remoto</entry>
	      </row>

	      <row>
		<entry><command>rpm -ivh <replaceable>pacote</replaceable></command> / <command>dpkg -i <replaceable>pacote</replaceable></command></entry>
		<entry><command>pkg_add -v <replaceable>pacote</replaceable></command></entry>
		<entry>Instala um pacote</entry>
	      </row>

	      <row>
		<entry><command>rpm -qa</command> / <command>dpkg -l</command></entry>
		<entry><command>pkg_info</command></entry>
		<entry>Lista de pacotes instalados</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect2>

    <sect2 id="systemCommands">
      <title>Gerenciamento do Sistema</title>

      <para>
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Comando no &linux;</entry>
		<entry>Equivalente no &os;</entry>
		<entry>Propósito</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><command>lspci</command></entry>
		<entry><command>pciconf</command></entry>
		<entry>Lista de dispositivos PCI</entry>
	      </row>

	      <row>
		<entry><command>lsmod</command></entry>
		<entry><command>kldstat</command></entry>
		<entry>Lista de módulos do <literal>kernel</literal>
		  carregados</entry>
	      </row>

	      <row>
		<entry><command>modprobe</command></entry>
		<entry><command>kldload</command> / <command>kldunload</command></entry>
		<entry>Carrega/descarrega módulos do
		<literal>kernel</literal></entry>
	      </row>

	      <row>
		<entry><command>strace</command></entry>
		<entry><command>truss</command></entry>
		<entry>Rastrear chamadas de sistema</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
    </sect2>
  </sect1>

  <sect1 id="conclusion">
    <title>Conclusão</title>

    <para>Esperamos que este documento tenha fornecido para 
      você o suficiente para começar a utilizar o 
      &os;.  Certifique-se de dar uma olhada no <ulink
        url="&url.base;/doc/en_US.ISO8859-1/books/handbook/index.html">
	Handbook do &os;</ulink> para se aprofundar nos 
	tópicos abordados, assim como nos muitos 
	tópicos não mencionados neste documento.</para>
  </sect1>
</article>
