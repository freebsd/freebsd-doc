<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook XML V5.0-Based Extension//EN"
	"http://www.FreeBSD.org/XML/share/xml/freebsd50.dtd">
<!--
  The FreeBSD Documentation Project
  The FreeBSD Brazilian Portuguese Documentation Project

  $FreeBSD$

  Original revision: r39544

-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="pt_br">
  <info><title>Para os novatos em FreeBSD e &unix;</title>
    

    <authorgroup>
      <author><personname><firstname>Annelise</firstname><surname>Anderson</surname></personname><affiliation>
	  <address><email>andrsn@andrsn.stanford.edu</email></address>
	</affiliation></author>
    </authorgroup>

    <pubdate>15 de agosto de 1997</pubdate>

    <legalnotice xml:id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.ibm;
      &tm-attrib.microsoft;
      &tm-attrib.netscape;
      &tm-attrib.opengroup;
      &tm-attrib.general;
    </legalnotice>

    <releaseinfo>$FreeBSD$</releaseinfo>

    <abstract>
      <para>Parabéns pela instalação do FreeBSD!
	Esta introdução é para os novatos no
	FreeBSD <emphasis>e</emphasis> no &unix;&mdash;, então
	ela começa com o básico.  Este artigo assume que
	você está usando a versão 2.0.5, ou mais
	atual, do &os; distribuído pela &os;.org, seu sistema,
	por agora, tem um único usuário (você) e
	você provavelmente está muito bem com o
	DOS/&windows; ou &os2;.</para>
    </abstract>
  </info>

  <sect1 xml:id="in-and-out">
    <title>Entrando e saindo do sistema</title>

    <para>Entre no sistema (quando você vê
      <prompt>login:</prompt>) como o usuário que você
      criou durante a instalação ou como
      <systemitem class="username">root</systemitem>.  (Sua instalação do
      FreeBSD já terá uma conta
      <systemitem class="username">root</systemitem>; que pode ir para qualquer lugar e
      fazer qualquer coisa, incluindo remover arquivos essenciais,
      então seja muito cuidadoso!)  Os símbolos
      &prompt.user; e &prompt.root; nos exemplos a seguir representam
      o <literal>prompt</literal> (o seu pode ser diferente), com o
      &prompt.user; indicando o <literal>prompt</literal> de um
      usuário comum e o &prompt.root; indicando o
      <literal>prompt</literal> do <systemitem class="username">root</systemitem>.</para>

    <para>Para sair do sistema (e obter uma novo
      <literal>prompt</literal> de <prompt>login:</prompt>)
      escreva:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>exit</userinput></screen>
    </informalexample>

    <para>quantas vezes forem necessárias.  Você precisa
      pressionar <keysym>enter</keysym> após os comandos, e
      lembre-se que &unix; é sensível a letras
      maiúsculas e minúsculas &mdash;
      <command>exit</command> não é o mesmo que
      <command>EXIT</command>.</para>

    <para>Para desligar a máquina escreva:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -h now</userinput></screen>
    </informalexample>

    <para>Ou para reinicializar, escreva:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -r now</userinput></screen>
    </informalexample>

    <para>ou</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/reboot</userinput></screen>
    </informalexample>

    <para>Você também pode reiniciar com
      <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Delete</keycap></keycombo>.
      Dê-lhe um pouco de tempo para trabalhar.  Isso é o
      equivalente ao <command>/sbin/reboot</command> nas
      versões recentes do FreeBSD e é muito, muito
      melhor do que pressionar o botão de
      <literal>reset</literal>.  Você não quer ter que
      instalar tudo de novo, não é?</para>
  </sect1>

  <sect1 xml:id="adding-a-user">
    <title>Adicionando um Usuário com Privilégios de
      Root</title>

    <para>Se você não criou nenhum usuário
      durante a instalação do sistema e, portanto,
      está logado como <systemitem class="username">root</systemitem>, você
      provavelmente precisa criar um usuário agora com:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>adduser</userinput></screen>
    </informalexample>

    <para>Na primeira vez que você usar o
      <command>adduser</command>, ele pode pedir por valores
      padrões para salvar.  Você pode querer definir o
      <literal>shell</literal> padrão como &man.csh.1; ao
      invés do &man.sh.1;, se ele sugerir o
      <command>sh</command> como padrão.  Do contrário,
      apenas pressione <keysym>enter</keysym> para aceitar os valores
      padrões.  Os valores padrões serão
      salvos em <filename>/etc/adduser.conf</filename>, o qual 
      pode ser editado.</para>

    <para>Suponha que você criou um usuário
      <systemitem class="username">jack</systemitem>, cujo nome completo seja
      <emphasis>Jack Benimble</emphasis>.  Dê a
      <systemitem class="username">jack</systemitem> uma senha se segurança (mesmo
      crianças ao redor que possam por as mãos no
      teclado) é um problema.  Quando for questionado se
      você deseja incluir <systemitem class="username">jack</systemitem> em outros
      grupos, escreva <systemitem class="groupname">wheel</systemitem>:</para>

    <informalexample>
      <screen>Login group is ``jack''. Invite jack into other groups: <userinput>wheel</userinput></screen>
    </informalexample>

    <para>Isso tornará possível entrar no sistema como
      <systemitem class="username">jack</systemitem> e usar o comando &man.su.1; para
      tornar-se <systemitem class="username">root</systemitem>.  Então você
      não será mais repreendido por logar como
      <systemitem class="username">root</systemitem>.</para>

    <para>Você pode interromper o <command>adduser</command>
      à qualquer momento apenas pressionando
      <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>, e
      no fim você poderá aprovar o novo usuário
      ou simplesmente escrever <keycap>n</keycap> para não.
      Você pode querer criar um segundo usuário para o
      caso de algo sair errado na edição dos arquivos de
      <literal>login</literal> do usuário
      <systemitem class="username">jack</systemitem>.</para>

    <para>Uma vez que você tenha concluído, use
      <command>exit</command> para voltar ao <literal>prompt</literal>
      de <literal>login</literal> e entrar como o usuário
      <systemitem class="username">jack</systemitem>.  Em geral, é uma boa
      idéia fazer tudo quanto for possível como um
      usuário comum, que não tem o poder &mdash; e o
      risco &mdash; do <systemitem class="username">root</systemitem>.</para>

    <para>Se você já criou o usuário e quer que
      ele tenha permissão de utilizar o <command>su</command>
      para tornar-se <systemitem class="username">root</systemitem>, você pode entrar
      como <systemitem class="username">root</systemitem> e editar o arquivo
      <filename>/etc/group</filename>, adicionando
      <systemitem class="username">jack</systemitem> ao grupo presente na primeira
      linha (o grupo <systemitem class="groupname">wheel</systemitem>).  Mas primeiro
      você precisa praticar com &man.vi.1;, o editor de texto
      instalado nas versões mais recentes do FreeBSD &mdash; ou
      usar um editor de texto mais simples, como o &man.ee.1;.</para>

    <para>Para remover um usuário, use o comando
      <command>rmuser</command>.</para>
  </sect1>

  <sect1 xml:id="looking-around">
    <title>Explorando</title>

    <para>Ao entrar como um usuário comum, explore e tente
      alguns comandos que irão acessar as fontes de ajuda e
      informação do FreeBSD.</para>

    <para>Aqui estão alguns comandos e o que eles fazem:</para>

    <variablelist>
      <varlistentry>
	<term><command>id</command></term>

	<listitem>
	  <para>Diz quem você é!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>pwd</command></term>

	<listitem>
	  <para>Mostra onde você está &mdash; o
	    diretório corrente de trabalho</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls</command></term>

	<listitem>
	  <para>Lista os arquivos no diretório corrente.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -F</command></term>

	<listitem>
	  <para>Lista os arquivos no diretório corrente com um
	    <literal>*</literal> depois de arquivos
	    executáveis, um <literal>/</literal> depois de
	    diretórios, e um <literal>@</literal> depois de
	    <literal>links</literal> simbólicos.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -l</command></term>

	<listitem>
	  <para>Lista os arquivos com detalhes &mdash; tamanho, data,
	    e permissões.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -a</command></term>

	<listitem>
	  <para>Lista os arquivos ocultos, que iniciam com
	    <quote>ponto</quote>, com os outros.  Se você
	    está como <systemitem class="username">root</systemitem>, os arquivos
	    ocultos, que iniciam com <quote>ponto</quote>, são
	    mostrados sem a necessidade da opção
	    <option>-a</option>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>cd</command></term>

	<listitem>
	  <para>Muda o diretório corrente.  <command>cd
	    ..</command> sobe um nível
	    com relação ao diretório atual; note
	    o espaço depois do <command>cd</command>.
	    <command>cd /usr/local</command>
	    entra no diretório especificado.  <command>cd
	    ~</command> entra no
	    diretório <literal>home</literal> do usuário
	    logado &mdash; e.g., <filename>/usr/home/jack</filename>.
	    Tente <command>cd /cdrom</command>,
	    e execute <command>ls</command>, para descobrir se seu
	    CDROM está montado e funcionando.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>view
	    filename</command></term>

	<listitem>
	  <para>Permite que você visualize um arquivo (chamado
	    <replaceable>filename</replaceable>) sem modificar
	    seu conteúdo.  Tente <command>view
	    /etc/fstab</command>.  Escreva
	    <command>:q</command> para sair.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>cat
	    filename</command></term>

	<listitem>
	  <para>Mostra o conteúdo de
	    <replaceable>filename</replaceable> na tela.  Se ele
	    é muito longo e você só consegue ver o
	    final do arquivo, pressione <keycap>ScrollLock</keycap> e
	    use <keycap>up-arrow</keycap> para navegar até o
	    topo do arquivo; você pode usar
	    <keycap>ScrollLock</keycap> também com
	    páginas de manual.  Pressione
	    <keycap>ScrollLock</keycap> novamente para interromper o
	    rolamento de conteúdo.  Você pode querer
	    experimentar o <command>cat</command> em alguns arquivos
	    ocultos no seu diretório <literal>home</literal>
	    &mdash; <command>cat
	    .cshrc</command>, <command>cat
	    .login</command>, <command>cat
	    .profile</command>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Você vai encontrar <literal>aliases</literal> em seu
      <filename>.cshrc</filename> para alguns comandos
      <command>ls</command> (estes são muito convenientes).
      Você pode criar outros <literal>aliases</literal>
      editando <filename>.cshrc</filename>.  Você pode criar
      <literal>aliases</literal> disponíveis para todos os
      usuários colocando-os no arquivo de
      configuração principal do <command>csh</command>
      o qual afeta todo o sistema, o
      <filename>/etc/csh.cshrc</filename>.</para>
  </sect1>

  <sect1 xml:id="getting-help">
    <title>Obtendo Ajuda e Informação</title>

    <para>Aqui estão algumas fontes de ajuda úteis.
      <replaceable>Text</replaceable> representa um termo de sua
      escolha, para o qual você precisa de
      informação ou ajuda &mdash; usualmente um comando
      ou arquivo.</para>

    <variablelist>
      <varlistentry>
	<term><command>apropos
	    text</command></term>

	<listitem>
	  <para>Tudo que contiver o texto
	    <replaceable>text</replaceable> na <database>whatis
	    database</database>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>man
	    text</command></term>

	<listitem>
	  <para>Exibe a página de manual do
	    <replaceable>text</replaceable>.  A maior fonte de
	    documentação para sistemas &unix;.
	    <command>man ls</command> vai lhe
	    mostrar todos os detalhes de como usar o comando
	    <command>ls</command>.  Pressione <keycap>Enter</keycap>
	    para navegar através do texto,
	    <keycombo><keycap>Ctrl</keycap><keycap>B</keycap></keycombo>
	    para voltar uma página,
	    <keycombo><keycap>Ctrl</keycap><keycap>F</keycap></keycombo>
	    para avançar uma página,
	    <keycap>q</keycap> ou
	    <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>
	    para sair.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>which
	    text</command></term>

	<listitem>
	  <para>Informa onde, no <literal>path</literal> do
	    usuário, o comando <replaceable>text</replaceable>
	    é encontrado.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>locate
	    text</command></term>

	<listitem>
	  <para>Informa todos os caminhos onde o termo
	    <replaceable>text</replaceable> é
	    encontrado.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>whatis
	    text</command></term>

	<listitem>
	  <para>Informa o que o comando
	  <replaceable>text</replaceable> faz e qual sua
	    página de manual.  Executar <command>whatis
	    *</command> vai lhe informar sobre todos os
	    binários no diretório corrente.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>whereis
	    text</command></term>

	<listitem>
	  <para>Encontra o arquivo <replaceable>text</replaceable>,
	    informando seu caminho completo.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Você pode querer experimentar usar
      <command>whatis</command> em alguns comandos comuns, como
      <command>cat</command>, <command>more</command>,
      <command>grep</command>, <command>mv</command>,
      <command>find</command>, <command>tar</command>,
      <command>chmod</command>, <command>chown</command>,
      <command>date</command>, e <command>script</command>.
      <command>more</command> permite que você leia uma
      página de cada vez, do mesmo modo como no DOS, e.g.,
      <command>ls -l | more</command> ou <command>more
      filename</command>.  O
      <literal>*</literal> funciona como curinga &mdash; e.g.,
      <command>ls w*</command> vai mostrar os arquivos que
      começam com <literal>w</literal>.</para>

    <para>Algum desses programas não está trabalhando
      muito bem?  Ambos, &man.locate.1; e &man.whatis.1;, dependem de
      uma base de dados recompilada semanalmente.  Se sua
      máquina não vai permanecer ligada (e rodando o
      &os;) durante o final de semana, convém executar 
      manualmente os comandos de manutenção 
      diários, semanais, e mensais de vez em quando.
      Execute-os como <systemitem class="username">root</systemitem> e,
      por agora, dê a cada um deles um tempo para finalizar
      antes de você iniciar o próximo.</para>

    <informalexample>
      <screen>&prompt.root; <userinput>periodic daily</userinput>
<lineannotation>output omitted</lineannotation>
&prompt.root; <userinput>periodic weekly</userinput>
<lineannotation>output omitted</lineannotation>
&prompt.root; <userinput>periodic monthly</userinput>
<lineannotation>output omitted</lineannotation></screen>
    </informalexample>

    <para>Se você cansar de esperar, pressione
      <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
      para acessar outro <firstterm>virtual console</firstterm>, e
      entre no sistema novamente.  Afinal, ele é um sistema
      multiusuário e multitarefa.  No entanto, é
      provável que esses comandos exibam mensagens na sua tela
      enquanto eles estão rodando; você pode executar
      <command>clear</command> em seu <literal>prompt</literal> para
      limpar a tela.  Uma vez que eles tenham executado, você
      pode querer olhar em <filename>/var/mail/root</filename> e
      <filename>/var/log/messages</filename>.</para>

    <para>Executar tais comandos é parte da
      administração do sistema &mdash; e como o
      único usuário do sistema &unix;, você
      é seu próprio administrador de sistemas.
      Praticamente tudo que você precisa fazer como
      <systemitem class="username">root</systemitem> será para
      administração de sistemas.  Tais responsabilidades
      não são muito bem exploradas, mesmo nos grossos
      livros sobre &unix;, que parecem dedicar um grande espaço
      para opções de menus em gerenciadores de janelas.
      Você pode querer obter um dos dois livros principais sobre
      administração de sistemas, ou Evi Nemeth et.al.'s
      <citetitle>UNIX System Administration Handbook</citetitle>
      (Prentice-Hall, 1995, ISBN 0-13-15051-7) &mdash; a segunda
      edição da capa vermelha; ou &AElig;leen Frisch's
      <citetitle>Essential System Administration</citetitle> (O'Reilly
      &amp; Associates, 2002, ISBN 0-596-00343-9).  Eu uso
      Nemeth.</para>
  </sect1>

  <sect1 xml:id="editing-text">
    <title>Editando Texto</title>

    <para>Para configurar seu sistema, você precisará
      editar arquivos de texto.  Muitos deles estarão no
      diretório <filename>/etc</filename>; e você
      precisará do <command>su</command> para tornar-se
      <systemitem class="username">root</systemitem> e poder modificá-los.
      Você pode utilizar o <command>ee</command>, por ser
      fácil de usar, mas à longo prazo vale a pena
      aprender o editor de texto <command>vi</command>.  Um excelente
      tutorial sobre o <command>vi</command> pode ser encontrado em
      <filename>/usr/src/contrib/nvi/docs/tutorial</filename>, se
      você tiver os fontes do sistema instalado.</para>

    <para>Antes de editar um arquivo, você provavelmente
      deveria fazer um backup dele.  Suponha que você queira
      editar o <filename>/etc/rc.conf</filename>.  Você pode
      simplesmente usar <command>cd /etc</command> para ir até
      o diretório <filename>/etc</filename> e fazer:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp rc.conf rc.conf.orig</userinput></screen>
    </informalexample>

    <para>Isso vai copiar o <filename>rc.conf</filename> para
      <filename>rc.conf.orig</filename>, e depois você
      poderá copiar o <filename>rc.conf.orig</filename> para
      <filename>rc.conf</filename> para recuperar o original.  Mas o
      melhor mesmo seria mover (renomear) e copiar novamente:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf rc.conf.orig</userinput>
&prompt.root; <userinput>cp rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>pelo fato do comando <command>mv</command> preservar a data
      e o dono originais do arquivo.  Você pode agora editar o
      <filename>rc.conf</filename>.  Se você quiser o original
      de volta, você faria <userinput>mv rc.conf
      rc.conf.myedit</userinput> (assumindo que você queira
      preservar a versão modificada) e então:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>para voltar as coisas do jeito que estavam.</para>

    <para>Para editar um arquivo, faça:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>vi filename</userinput></screen>
    </informalexample>

    <para>Mova-se através do texto com as setas do teclado.
      <keycap>Esc</keycap> (a tecla de escape) coloca o
      <command>vi</command> em modo de comando.  Aqui estão
      alguns comandos:</para>

    <variablelist>
      <varlistentry>
	<term><command>x</command></term>

	<listitem>
	  <para>Remove o caractere onde está o cursor</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>dd</command></term>

	<listitem>
	  <para>remove a linha inteira (mesmo que ela quebre na
	    tela)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>i</command></term>

	<listitem>
	  <para>para inserir texto a partir do cursor</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>a</command></term>

	<listitem>
	  <para>para inserir texto após o cursor</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Uma vez que você digite <command>i</command> ou
      <command>a</command>, você pode inserir o texto.
      <command>Esc</command> coloca você de volta no modo de
      comando</para>

    <variablelist>
      <varlistentry>
	<term><command>:w</command></term>

	<listitem>
	  <para>para salvar suas modificações no disco
	    e continuar editando</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>:wq</command></term>

	<listitem>
	  <para>para salvar as modificações e
	    sair</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>:q!</command></term>

	<listitem>
	  <para>para sair sem salvar as
	    modificações</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>/text</command></term>

	<listitem>
	  <para>para mover o curso para
	    <replaceable>text</replaceable>;
	    <command>/Enter</command> (a tecla enter)
	    para encontrar a próxima ocorrência de
	    <replaceable>text</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>G</command></term>

	<listitem>
	  <para>vai para o final do arquivo</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>nG</command></term>

	<listitem>
	  <para> vai para a linha <replaceable>n</replaceable> no
	    arquivo, onde <replaceable>n</replaceable> é o
	    número.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><keycombo><keycap>Ctrl</keycap><keycap>L</keycap></keycombo></term>

	<listitem>
	  <para>para redesenhar a tela</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><keycombo><keycap>Ctrl</keycap><keycap>b</keycap></keycombo> e
	  <keycombo><keycap>Ctrl</keycap><keycap>f</keycap></keycombo></term>

	<listitem>
	  <para>volta e avança na tela, respectivamente, assim
	    como fazem no <command>more</command> e
	    <command>view</command>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Pratique com o <command>vi</command> em seu diretório
      <literal>home</literal>, criando um novo arquivo com <command>vi
      filename</command>, adicionando e
      removendo texto, salvando o arquivo, e chamando-o de novo.
      <command>vi</command> oferece muitas surpresas, pois ele
      é realmente bastante complexo, e algumas vezes você
      vai inadvertidamente executar um comando que vai fazer alguma
      coisa que você não espera.  (Algumas pessoas
      realmente gostam do <command>vi</command> &mdash; ele é
      mais poderoso que o DOS EDIT &mdash; procure sobre o comando
      <command>:r</command>.) Use <keycap>Esc</keycap> uma ou mais
      vezes para estar seguro de que você está no modo de
      comando e continuar a partir daí se você tiver
      problemas, salve frequentemente com <command>:w</command>, e use
      <command>:q!</command> para sair e começar novamente (a
      partir do seu último <command>:w</command>) quando
      você precisar.</para>

    <para>Agora você pode entrar no diretório
      <filename>/etc</filename> com o <command>cd</command>, usar o
      <command>su</command> para tornar-se <systemitem class="username">root</systemitem>,
      usar o <command>vi</command> para editar o arquivo
      <filename>/etc/group</filename>, e adicionar um usuário
      no grupo <systemitem class="groupname">wheel</systemitem> para que ele tenha
      privilégios de <systemitem class="username">root</systemitem>.  Só
      adicione uma vírgula e o <literal>login</literal> do
      usuário no fim da primeira linha do arquivo, pressione
      <keycap>Esc</keycap>, e use <command>:wq</command> para escrever
      suas alterações no disco e sair.  Efeito
      instantâneo.  (Você não colocou um
      espaço depois da vírgula, colocou?)</para>
  </sect1>

  <sect1 xml:id="printing-files-from-dos">
    <title>Imprimindo Arquivos no DOS</title>

    <para>Neste ponto você provavelmente não tem uma
      impressora funcionando, então aqui vai uma maneira de
      criar um arquivo a partir de uma página de manual,
      movê-lo para um disquete, e então imprimi-lo do
      DOS.  Suponhamos que você queira ler cuidadosamente sobre
      mudança de permissões em arquivos (muito
      importante).  Você pode usar <command>man chmod</command>
      para ler a respeito.  O comando</para>

    <informalexample>
      <screen>&prompt.user; <userinput>man chmod | col -b &gt; chmod.txt</userinput></screen>
    </informalexample>

    <para>irá remover códigos de
      formatação e enviar a página de manual para
      o arquivo <filename>chmod.txt</filename> em vez de
      mostrá-lo na tela.  Agora coloque um disquete formatado
      no DOS em seu drive de disquete <filename>a</filename>, use
      o <command>su</command> para tornar-se
      <systemitem class="username">root</systemitem>, e escreva</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/mount -t msdosfs /dev/fd0 /mnt</userinput></screen>
    </informalexample>

    <para>para montar o drive de disquete em
      <filename>/mnt</filename>.</para>

    <para>Agora (você não precisa mais estar como
      <systemitem class="username">root</systemitem>, e você pode executar
      <command>exit</command> para voltar para o usuário
      inicial <systemitem class="username">jack</systemitem>) você pode ir até
      o diretório onde você criou o
      <filename>chmod.txt</filename> e copiar o arquivo para o
      disquete com:</para>

    <informalexample>
      <screen>&prompt.user; <userinput>cp chmod.txt /mnt</userinput></screen>
    </informalexample>

    <para>e usar <command>ls /mnt</command> para obter a listagem do
      diretório <filename>/mnt</filename>, que deveria mostrar
      o arquivo <filename>chmod.txt</filename>.</para>

    <para>Você pode querer criar um arquivo a partir do
      <filename>/sbin/dmesg</filename> executando:</para>

    <informalexample>
      <screen>&prompt.user; <userinput>/sbin/dmesg &gt; dmesg.txt</userinput></screen>
    </informalexample>

    <para>e copiar o <filename>dmesg.txt</filename> para o disquete.
      <command>/sbin/dmesg</command> é o registro das
      mensagens de <literal>boot</literal>, e ele é útil
      para entender o que o FreeBSD encontra durante a
      inicialização.  Se você enviar perguntas
      para a &a.questions; ou para o grupo da USENET &mdash; como
      <quote>O FreeBSD não encontra a minha unidade de fita, o
      que eu faço?</quote> &mdash; as pessoas vão querer
      saber o que o <command>dmesg</command> diz.</para>

    <para>Você pode desmontar o drive de disquete agora (como
      <systemitem class="username">root</systemitem>) para retirá-lo com:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/umount /mnt</userinput></screen>
    </informalexample>

    <para>e reiniciar para ir para o DOS.  Copie os arquivos para um
      diretório do DOS, chame-os com o DOS EDIT, &windows;
      Notepad ou Wordpad, ou algum outro processador de texto,
      faça uma pequena alteração para o arquivo
      ser salvo, e imprima como você normalmente faz a partir do
      DOS ou Windows.  Espero que funcione!  Páginas de manual
      saem melhor se impressas com o comando <command>print</command>
      do DOS.  (Copiar arquivos do FreeBSD para uma
      partição DOS montada ainda é, em alguns
      casos, um pouco arriscado.)</para>

    <para>Obter uma impressora imprimindo do FreeBSD envolve criar uma
      entrada apropriada em <filename>/etc/printcap</filename> e criar
      um diretório de <literal>spool</literal> correspondente
      em <filename>/var/spool/output</filename>.  Se sua impressora
      está na <hardware>lpt0</hardware> (nos DOS é
      chamada de <hardware>LPT1</hardware>), você só
      precisa ir para <filename>/var/spool/output</filename> e (como
      <systemitem class="username">root</systemitem>) criar o diretório
      <filename>lpd</filename> executando: <command>mkdir
      lpd</command>, se ele ainda não existe.  Em seguida, a
      impressora deve responder se ela estiver ligada durante a
      inicialização, e <command>lp</command> ou
      <command>lpr</command> deve enviar um arquivo para a impressora.
      Se o arquivo vai ser impresso ou não, depende da
      configuração, esta é coberta no <link xlink:href="&url.books.handbook;/index.html">FreeBSD
      handbook.</link></para>
  </sect1>

  <sect1 xml:id="other-useful-commands">
    <title>Outros comando úteis</title>

    <variablelist>
      <varlistentry>
	<term><command>df</command></term>

	<listitem>
	  <para>mostra os dispositivos montados e o espaço em
	    disco.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ps aux</command></term>

	<listitem>
	  <para>mostra os processos rodando. <command>ps ax</command>
	    exibe uma lista compacta.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>rm filename</command></term>

	<listitem>
	  <para>exclui o arquivo
	    <replaceable>filename</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>rm -R dir</command></term>

	<listitem>
	  <para>remove o diretório
	    <replaceable>dir</replaceable> e todos os seus
	    subdiretórios &mdash; seja cuidadoso!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -R</command></term>

	<listitem>
	  <para>lista os arquivos no diretório corrente e
	    todos os subdiretórios; eu usei uma variante,
	    <command>ls -AFR &gt; where.txt</command>, para obter uma
	    lista de todos os arquivos de <filename>/</filename> e
	    (separadamente) <filename>/usr</filename>, antes de
	    descobrir um jeito melhor de encontrar arquivos.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>passwd</command></term>

	<listitem>
	  <para>para mudar a senha do usuário (ou a senha do
	    <systemitem class="username">root</systemitem>)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>man hier</command></term>

	<listitem>
	  <para>exibe a página de manual sobre o sistema de
	    arquivos do &unix;</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Use <command>find</command> para localizar
      <filename>filename</filename> em <filename>/usr</filename>, ou
      qualquer de seus subdiretórios, com</para>

    <informalexample>
      <screen>&prompt.user; <userinput>find /usr -name "filename"</userinput></screen>
    </informalexample>

    <para>Você pode usar <literal>*</literal> como curinga em
      <parameter>"<replaceable>filename</replaceable>"</parameter>
      (que deve estar entre aspas).  Se você diz para
      <command>find</command> procurar em <filename>/</filename>, em
      vez de <filename>/usr</filename>, ele vai procurar o arquivo em
      todos os dispositivos montados, incluindo CDROM e as
      partições DOS.</para>

    <para>Um excelente livro que explica os comandos e
      utilitários &unix; é Abrahams &amp; Larson,
      <citetitle>Unix for the Impatient</citetitle> (2nd ed.,
      Addison-Wesley, 1996).  Existe também uma grande
      quantidade de informações sobre &unix; na
      Internet.</para>
  </sect1>

  <sect1 xml:id="next-steps">
    <title>Próximos Passos</title>

    <para>Agora você deve ter as ferramentas que você
      precisa para explorar e editar arquivos, então você
      pode ter tudo ligado e funcionando.  Existe uma grande
      quantidade de informações no FreeBSD handbook (que
      provavelmente está em seu disco rígido) e no
      <link xlink:href="&url.base;/index.html">web site do FreeBSD</link>.
      Uma grande variedade de pacotes e <literal>ports</literal>
      estáo disponível no CDROM, bem como no site web. 
      O handbook diz mais sobre como usá-los (obter um pacote,
      se ele existir, com <command>pkg_add
      /cdrom/packages/All/nomepacote</command>,
      onde <replaceable>nomepacote</replaceable> é o nome do
      pacote).  O CDROM tem uma lista dos pacotes e
      <literal>ports</literal> com uma breve descrição
      em <filename>cdrom/packages/index</filename>,
      <filename>cdrom/packages/index.txt</filename>, e
      <filename>cdrom/ports/index</filename>, com as
      descrições completas em
      <filename>/cdrom/ports/*/*/pkg/DESCR</filename>, onde os
      <literal>*</literal> representam subdiretórios das
      categorias e dos nomes dos programas, respectivamente.</para>

    <para>Se você achar o handbook muito sofisticado (com
      <command>lndir</command> e tudo) sobre a
      instalação de <literal>ports</literal> a partir do
      CDROM, aqui está o que normalmente funciona:</para>

    <para>Encontre o <literal>port</literal> que você quer,
      digamos que seja o <command>kermit</command>.  Haverá um
      diretório para ele no CDROM.  Copie o subdiretório
      para <filename>/usr/local</filename> (um bom lugar para
      adicionar programas que estarão disponíveis para
      todos os usuários) com:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp -R /cdrom/ports/comm/kermit /usr/local</userinput></screen>
    </informalexample>

    <para>Isso deve resultar em um subdiretório
      <filename>/usr/local/kermit</filename> onde estarão
      todos os arquivos do subdiretório
      <command>kermit</command> do CDROM.</para>

    <para>Em seguida, crie o diretório
      <filename>/usr/ports/distfiles</filename>, se ele ainda
      não existe, usando <command>mkdir</command>.  Agora
      verifique em <filename>/cdrom/ports/distfiles</filename> por um
      arquivo com o nome que indique o <literal>port</literal> que
      você quer.  Copie o arquivo para
      <filename>/usr/ports/distfiles</filename>; nas versões
      recentes você pode pular este passo, o FreeBSD vai fazer
      isso por você.  No caso do <command>kermit</command>
      não existe <literal>distfile</literal>.</para>

    <para>Vá até o subdiretório
      <filename>/usr/local/kermit</filename>, onde estará o
      arquivo <filename>Makefile</filename>.  E execute</para>

    <informalexample>
      <screen>&prompt.root; <userinput>make all install</userinput></screen>
    </informalexample>

    <para>Durante este processo o <literal>port</literal> vai obter
      a partir do FTP quaisquer arquivos compactados que sejam
      necessários e não estejam presentes no CDROM ou em
      <filename>/usr/ports/distfiles</filename>.  Se sua rede ainda
      não está funcionando e não existe arquivo
      para o <literal>port</literal> em
      <filename>/cdrom/ports/distfiles</filename>, você vai
      precisar obter este arquivo de outra máquina e
      copiá-lo para <filename>/usr/ports/distfiles</filename> 
      de um disquete ou de sua partição DOS.  Leia o
      <filename>Makefile</filename> (com o <command>cat</command>, ou
      <command>more</command>, ou <command>view</command>) para
      descobrir aonde ir (o site de distribuição
      principal) para obter o arquivo e qual o seu nome.  O nome do
      arquivo será truncado se ele for obtido a partir do DOS,
      e depois de colocá-lo em
      <filename>/usr/ports/distfiles</filename> você precisa
      renomear o arquivo (com o comando <command>mv</command>) para
      seu nome original para que ele possa ser encontrado.  (Use o
      modo de transferência binária!) Então volte
      para <filename>/usr/local/kermit</filename>, encontre o
      diretório com o <filename>Makefile</filename>, e execute
      <command>make all install</command>.</para>

    <para>Outra coisa que pode acontecer quando da
      instalação de um <literal>port</literal> ou pacote
      é que algum outro programa seja necessário.  Se a
      instalação parar com uma mensagem <errorname>can't
      find unzip</errorname> ou algo parecido, você pode
      precisar instalar o pacote ou <literal>port</literal> do unzip
      antes de continuar.</para>

    <para>Uma vez instalado, execute <command>rehash</command> para
      fazer o FreeBSD reler os arquivos no <literal>path</literal>,
      então ele saberá o que existe lá.  (Se
      você obter uma série de mensagens <errorname>path
      not found</errorname> quando usar <command>whereis</command> ou
      <command>which</command>, você pode querer adicionar
      entradas para a lista de diretórios na
      declaração do <literal>path</literal> no
      <filename>.cshrc</filename> em seu diretório
      <literal>home</literal>.  A declaração do
      <literal>path</literal> no &unix; funciona do mesmo modo que no
      DOS, exceto pelo diretório corrente que não
      é (por padrão) incluído no
      <literal>path</literal> por razões de segurança;
      você precisa digitar <filename>./</filename> antes do
      comando para executa-lo; sem espaços depois da
      barra.</para>

    <para>Você pode querer obter a versão mais recente
      do &netscape; a partir de seu <link xlink:href="ftp://ftp.netscape.com/">site FTP</link>.  (O &netscape;
      requer o <literal>X Window System</literal>.) Agora existe uma
      versão para o &os;, então explore com
      cuidado.  Basta usar o  <command>gunzip
      filename</command> e <command>tar xvf
      filename</command> no arquivo, mover
      o binário para <filename>/usr/local/bin</filename> ou
      algum outro lugar onde os binários são mantidos,
      execute <command>rehash</command>, e então coloque as
      seguintes linhas no <filename>.cshrc</filename> de cada
      diretório <literal>home</literal> dos usuários ou
      (mais fácil) em <filename>/etc/csh.cshrc</filename>, o
      arquivo de configuração principal de
      inicialização do <command>csh</command>:</para>

    <informalexample>
      <programlisting>setenv XKEYSYMDB /usr/X11R6/lib/X11/XKeysymDB
setenv XNLSPATH /usr/X11R6/lib/X11/nls</programlisting>
    </informalexample>

    <para>Isso assume que o arquivo <filename>XKeysymDB</filename> e o
      diretório <filename>nls</filename> estão em
      <filename>/usr/X11R6/lib/X11</filename>; se eles não
      estiverem, encontre-os e coloque-os lá.</para>

    <para>Se você instalou o &netscape; originalmente a partir
      de um <literal>port</literal> usando o CDROM (ou o site FTP),
      não substitua o
      <filename>/usr/local/bin/netscape</filename> com o novo
      binário do &netscape;; isso é só um 
      <literal>shell script</literal> que define as variáveis 
      de ambiente para você.  Em vez disso, renomeie o novo 
      binário para <filename>netscape.bin</filename> 
      e mova o binário antigo
      para <filename>/usr/local/netscape/netscape</filename>.</para>
  </sect1>

  <sect1 xml:id="your-working-environment">
    <title>Seu Ambiente de Trabalho</title>

    <para>Seu <literal>shell</literal> é uma parte muito
      importante do seu ambiente de trabalho.  No DOS, o
      <literal>shell</literal> usual é o
      <literal>command.com</literal>.  O <literal>shell</literal>
      é quem interpreta os comandos que você executa na
      linha de comando, e, portanto, se comunica com o resto do
      sistema operacional.  Você também pode escrever
      <literal>shell scripts</literal>, que são como arquivos
      de lotes do DOS: uma série de comando para serem
      executados sem sua intervenção.</para>

    <para>O FreeBSD vem com dois <literal>shells</literal> instalados:
      <command>csh</command> e <command>sh</command>.
      <command>csh</command> é bom para trabalhar com a linha
      de comando, mas <literal>scripts</literal> devem ser escritos
      com <command>sh</command> (ou <command>bash</command>).
      Você pode descobrir qual <literal>shell</literal>
      você está utilizando executando <command>echo
      $SHELL</command>.</para>

    <para>O <literal>shell</literal> <command>csh</command> é
      bom, mas <command>tcsh</command> faz tudo que o
      <command>csh</command> faz e mais.  Ele aceita que você
      chame novamente os comandos, com as setas do teclado, e
      edite-os.  Ele completa nomes de arquivos através da
      tecla TAB (<command>csh</command> usa a tecla
      <keycap>Esc</keycap>), e ele permite que você mude para
      seu último diretório com <command>cd -</command>.
      É muito fácil alternar seu
      <literal>prompt</literal> com <command>tcsh</command>.  Ele
      torna sua vida muito fácil.</para>

    <para>Aqui estão os passos para a instalação
      de um novo <literal>shell</literal>:</para>

    <procedure>
      <step>
	<para>Instale o <literal>shell</literal> a partir de um
	  <literal>port</literal> ou pacote, como você faria
	  para qualquer outro <literal>port</literal> ou pacote.  Use
	  <command>rehash</command> e <command>which tcsh</command>
	  (assumindo que você instalou o
	  <command>tcsh</command>) para ter certeza que ele foi
	  instalado.</para>
      </step>

      <step>
	<para>Como <systemitem class="username">root</systemitem>, edite o
	  <filename>/etc/shells</filename>, adicionando uma linha no
	  arquivo para o novo <literal>shell</literal>, nesse caso
	  <filename>/usr/local/bin/tcsh</filename>, e salve o arquivo.
	  (Alguns <literal>ports</literal> vão fazer isso por
	  você.)</para>
      </step>

      <step>
	<para>Use o comando <command>chsh</command> para mudar seu
	  <literal>shell</literal> para o <command>tcsh</command>
	  permanentemente, ou execute <command>tcsh</command> no
	  <literal>prompt</literal> para mudar seu
	  <literal>shell</literal> sem precisar realizar o
	  <literal>login</literal> novamente.</para>
      </step>
    </procedure>

    <note>
      <para>Pode ser perigoso mudar o <literal>shell</literal> do
        <systemitem class="username">root</systemitem> para qualquer coisa diferente de
	<command>sh</command> ou <command>csh</command> nas
	versões anteriores do FreeBSD e em muitas outras
	versões do &unix;; você pode não ter um
	<literal>shell</literal> funcional quando o sistema colocar
	você em modo monousuário.  A
	solução é usar 
	<command>su -m</command> para tornar-se
	<systemitem class="username">root</systemitem>, o que lhe dará o
	<command>tcsh</command> como <systemitem class="username">root</systemitem>, pois
	o <literal>shell</literal> é parte do seu ambiente.
	Você pode tornar isso permanente adicionando para seu
	arquivo <filename>.tcshrc</filename> um
	<literal>alias</literal> com:</para>
	<programlisting>alias su su -m</programlisting>
    </note>

    <para>Quando <command>tcsh</command> inicia, ele lê os
      arquivos <filename>/etc/csh.cshrc</filename> e
      <filename>/etc/csh.login</filename>, assim como o
      <command>csh</command>.  Ele também irá ler o
      arquivo <filename>.login</filename> em seu diretório
      <literal>home</literal> e o arquivo <filename>.cshrc</filename>,
      a menos que você providencie um arquivo
      <filename>.tcshrc</filename>.  Para isso você pode
      simplesmente copiar o <filename>.cshrc</filename> para
      <filename>.tcshrc</filename>.</para>

    <para>Agora que você já instalou o
      <command>tcsh</command>, você pode ajustar o seu
      <literal>prompt</literal>.  Você encontra os detalhes na
      página de manual do <command>tcsh</command>, mas aqui
      está uma linha para você incluir em seu
      <filename>.tcshrc</filename> que vai lhe dizer quantos comandos
      você digitou, que horas são, e em que
      diretório você se encontra.  Ele também
      mostra um <literal>&gt;</literal> se você está como um
      usuário comum e um <literal>#</literal> se você
      está como <systemitem class="username">root</systemitem>, mas
      <command>tcsh</command> vai fazer isso em qualquer caso:</para>

    <para>set prompt = "%h %t %~ %# "</para>

    <para>Isso deve ser incluído no mesmo lugar do <literal>set
      prompt</literal> existente, ou sob <literal>"if($?prompt)
      then"</literal> se este não existir.  Comente a linha
      antiga; você poderá voltar para o
      <literal>prompt</literal> antigo se preferir.  Não
      esqueça o espaço e as aspas.  Você pode
      recarregar o <filename>.tcshrc</filename> executando
      <command>source .tcshrc</command>.</para>

    <para>Você pode obter uma lista de outras variáveis
      de ambiente que foram definidas executando
      <command>env</command> no <literal>prompt</literal>.  O
      resultado vai lhe mostrar seu editor padrão, paginador, e
      o tipo de terminal, e possivelmente muitos outros.  Um comando
      útil se você está logado remotamente e
      não pode executar um programa, pois o terminal não
      é compatível, é <command>setenv TERM
      vt100</command>.</para>
  </sect1>

  <sect1 xml:id="other">
    <title>Outros</title>

    <para>Como <systemitem class="username">root</systemitem> você pode desmontar
      o CDROM com <command>/sbin/umount /cdrom</command>,
      retirá-lo do <literal>drive</literal>, inserir outro, 
      e montá-lo com<command>/sbin/mount_cd9660 /dev/cd0a
      /cdrom</command>,assumindo que <hardware>cd0a</hardware>
      é o nome do seu dispositivo de CDROM.  As versões
      mais recentes do FreeBSD deixam você montar o CDROM apenas
      com <command>/sbin/mount /cdrom</command>.</para>

    <para>Usar o sistema de arquivos <literal>live</literal> &mdash;
      o segundo dos discos de CDROM do FreeBSD &mdash; é
      útil se você tem um espaço limitado.  O
      conteúdo do sistema de arquivos <literal>live</literal> 
      varia de versão para versão.  Você pode 
      tentar jogar a partir do CDROM.  Isso envolve o uso do
      <command>lndir</command>, que é instalado com o
      <literal>X Window System</literal>, para informar aos programas
      onde encontrar os arquivos necessários, pois eles
      estão no sistema de arquivos de
      <filename>/cdrom</filename>, em vez de <filename>/usr</filename>
      e seus subdiretórios, que é o local onde eles
      esperam estar.  Consulte <command>man lndir</command>.</para>
  </sect1>

  <sect1 xml:id="comments-welcome">
    <title>Comentários São Bem-vindos</title>

    <para>Se você usou este guia, eu estou interessado em
      saber onde ele não está claro, o que foi deixado
      de fora que você acha que deve ser incluído, e se
      ele foi útil.  Meus agradecimentos para Eugene W. Stark,
      professor de ciência da computação em
      SUNY-Stony Brook, e John Fieber pelos comentários
      úteis.</para>

    <para>Annelise Anderson,
	<email>andrsn@andrsn.stanford.edu</email></para>
  </sect1>
</article>
