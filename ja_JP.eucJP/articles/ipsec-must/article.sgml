<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- The FreeBSD Documentation Project -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- $FreeBSD$ -->
<!-- Original revision: 1.1 -->

<html>
  <head>
    <title>FreeBSD の IPSec 機能を独立検証するには</title>
  </head>
  
  <body text="#000000" bgcolor="#FFFFFF">
    
    <h1>FreeBSD 3.0 における IPSec 機能を独立検証するには</h1>
    
    <p align="center"><i>IPsec をインストールした時,
        それがきちんと動作しているかどうか調べるにはどうしたら良いでしょう?
        ここでは, IPsec の動作を検証する実験的な方法を紹介します.</i></p>
    
    <h2>問題</h2>
    
    <p>まず, <a href="#Installing IPsec"><i>IPsec</i>
        がインストールされていること</a>を前提に話を進めます.
      IPsec が<a href="#Caveat">きちんと動作している</a>かどうか知るにはどうしたら良いでしょう?
      もちろん設定が間違っていればネットワーク接続が行なえないでしょうし,
      接続できたということは設定が合っているからだ, という認識は間違っていません.
      接続状態は <i>Netstat</i> コマンドで確かめることができます.
      しかし, それを独立して検証することは可能なのでしょうか?</p>
    
    <h2>解</h2>
    
    <p>最初に, 暗号に関連する次のような情報理論を考えます.</p>
    
    <ol>
      <li>
	<p>暗号化されたデータは, 一様に分布している.  つまり,
          各情報源シンボルは最大のエントロピーを持っている.</p>
      </li>
      
      <li>
	<p>通常, 未処理のデータや圧縮されていないデータは冗長である.
          つまり, 各情報源シンボルのエントロピーは最大ではない.</p>
      </li>
    </ol>
    
    <p>ネットワークインターフェイスを入出力するデータのエントロピーを測定できると仮定すると,
      「暗号化されていないデータ」と「暗号化されたデータ」の両者に,
      違いを見ることができるはずです.  
      このことは, パケットのルーティングが行なわれる場合の一番外側の IP ヘッダなど, 
      データの一部が「暗号化モード」で暗号化されなかったとしても成立します.</p>
    
    <h4><a name="MUST"></a>MUST</h4>
    
    <p>Ueli Maurer 氏の "Universal Statistical Test for Random Bit Generators"
      ("MUST") は, サンプルデータのエントロピーを高速に測定します.
      これには圧縮と良く似たアルゴリズムが使われています.
      <a href="#Maurer's Universal Statistical Test">
        文末に示すのは, 一つのファイル中で連続するデータ (最大 0.25 メガバイト)
        を測定するコードです.</a></p>
    
    <h4><a NAME="Tcpdump"></a>Tcpdump</h4>
    
    <p>さて次に, 上記に加えてネットワーク上の生データを捕捉するための手段も必要になります.
      それを実現するプログラムに, "<i>tcpdump</i>" と呼ばれるものがあります.
      ただし, tcpdump を使うには,
      <a href="#usr/src/sys/i386/conf/KERNELNAME">カーネルコンフィグレーションファイル</a>において
      bpf (<i>Berkeley Packet Filter</i>)
      インターフェイスが有効化されていなければなりません.</p>
    
    <p>次のコマンド</p>

    <blockquote><b>tcpdump</b> <b>-c</b> 4000 <b>-s</b> 10000 <b>-w</b>
      <i>dumpfile.bin</i></blockquote>
    
    <p>は, 4000 個の生パケットを捕捉し, <i>dumpfile.bin</i> に記録します.
      この例のでは 10,000 バイト以下のパケットのみ記録されます.</p>
    
    <h2>実験</h2>
    
    <p>では, 実験してみましょう.
      まず, IPsec ホストと IPsec
      を使っていないホストの両方にネットワーク接続してください.</p>
    
    <p>そして<a href="#Tcpdump">パケットの捕捉</a>を開始します.</p>
    
    <p>次に, IPsec を使っている接続で "yes" という unix コマンドを実行します.
      これは, "y" という文字の連続データを出力するものです.
      しばらくしたらコマンドを停止させ, IPsec
      を使っていない接続に対して同じコマンドを実行します.
      こちらも, しばらくしたらコマンドを停止させてください.</p>
    
    <p>ここで, <a href="#Maurer's Universal Statistical Test">MUST</a>
      を捕捉したパケットに実行すると, 次のような出力が得られるはずです.
      この中で重要なのは, 期待値 (7.18) に対して,
      IPsec を使った接続が 93% (6.7),
      通常の接続が 29% (2.1)
      という結果になっていることです.</p>
    
    <pre>% tcpdump -c 4000 -s 10000 -w ipsecdemo.bin
% uliscan ipsecdemo.bin

Uliscan 21 Dec 98
L=8 256 258560
Measuring file ipsecdemo.bin
Init done
Expected value for L=8 is 7.1836656
6.9396 --------------------------------------------------------
6.6177 -----------------------------------------------------
6.4100 ---------------------------------------------------
2.1101 -----------------
2.0838 -----------------
2.0983 -----------------</pre>

    <h2><a NAME="Caveat"></a>注意</h2>
    
    <p>この実験は暗号化の理論が示すとおり, IPsec
      を使った通信では<i>確かに</i>ペイロード中のデータに含まれるシンボルの生起確率が<i>一様に</i>分布する,
      ということを示しています.
      しかし, ここで示した実験ではシステム上の欠陥 (あるのかどうか知りませんが)
      を検出することは<i>できません</i>.
      ここで言う「欠陥」とは, たとえば暗号鍵生成や交換の不備や,
      データや暗号鍵が他人に見られていないかどうかといった問題,
      あるいはアルゴリズムの強度はどうか,
      カーネルのバージョンは合っているかといったことです.
      これらはソースを調べれば確かめることができます.</p>
      
    <h2><a NAME="IPsec"></a>IPsec の定義</h2>

    <p>インターネットプロトコル セキュリティ拡張
      (Internet Protocol security extensions) は
      IP v4 と IP v6 に適用され, IP v6 への実装は必須となっています.
      このプロトコルは IP (ホスト間) レベルで暗号化と認証を実現するためのものです.
      たとえば SSL は一つのアプリケーションソケット, SSH はログイン,
      PGP は特定のファイルやメッセージのみに対してそれぞれ安全性を提供しますが,
      IPsec は 2 ホスト間のすべての通信を暗号化します.</p>
    
    <h2><a NAME="Installing IPsec"></a>IPsec のインストール</h2>

    <p>ここでは FreeBSD 3.0 stable を想定しています.</p>
    
    <ol>
      <li>
	<p>IPsec v0.04 をインストールして,
          カーネル再構築とインストールを行なう.</p>
      </li>

      <li>
	<p>管理用のツール (たとえば <i>ipsecadm</i>) を実行し,
          暗号鍵を配布 (もしくは <i>Photuris</i> を使って鍵交換) する.</p>
      </li>

      <li>
	<p>ネットワーク経路 (<i>rt</i>) を適切に設定する.</p>
      </li>
    </ol>
    
    <p><i>ipsecadm</i> および <i>rt</i> を実行して
      IPsec トンネルを確立するための "ipsec_setup"
      スクリプトを作成しても良いでしょう.
      スクリプトは, 起動時に <i>/etc/rc.local</i> から自動で実行させることができます.
      ipsec_setup でトンネルを確立するには, 少なくとも 2 つの
      <i>ipsecadm</i> コマンドと, 1 つの
      <i>rt</i> コマンドが含まれている必要があるでしょう.</p>

    <h2><a NAME="KERNELNAME"></a>usr/src/sys/i386/conf/KERNELNAME</h2>
    
    <p>IPsec を実行するには,
      カーネルコンフィグレーションファイルに以下の行が含まれていなければなりません.
      これらの行を追加して <i>config</i> を実行し,
      カーネルの再構築とインストールを行なってください.</p>

    <pre># The `bpfilter' pseudo-device enables the Berkeley Packet Filter. Be
# aware of the legal and administrative consequences of enabling this
# option. Heh heh. The number of devices determines the maximum number of
# simultaneous BPF clients programs runnable.
pseudo-device bpfilter 2 #Berkeley packet filter

# IPSEC
options IPSEC
options "MD5"
pseudo-device enc 1</pre>

    <h2><a name="Maurer's Universal Statistical Test"></a>Maurer's Universal Statistical Test
      (ブロックサイズ = 8 ビット)</h2>

    <pre><![ CDATA [/*
  ULISCAN.c   ---blocksize of 8

  1 Oct 98
  1 Dec 98
  21 Dec 98       uliscan.c derived from ueli8.c

  This version has // comments removed for Sun cc

  This implements Ueli M Maurer's "Universal Statistical Test for Random
  Bit Generators" using L=8

  Accepts a filename on the command line; writes its results, with other
  info, to stdout.

  Handles input file exhaustion gracefully.

  Ref: J. Cryptology v 5 no 2, 1992 pp 89-105
  also on the web somewhere, which is where I found it.

  -David Honig
  honig@sprynet.com

  Usage:
  ULISCAN filename
  outputs to stdout
*/

#define L 8
#define V (1<<L)
#define Q (10*V)
#define K (100   *Q)
#define MAXSAMP (Q + K)

#include <stdio.h>
#include <math.h>

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fptr;
  int i,j;
  int b, c;
  int table[V];
  double sum = 0.0;
  int iproduct = 1;
  int run;

  extern double   log(/* double x */);

  printf("Uliscan 21 Dec 98 \nL=%d %d %d \n", L, V, MAXSAMP);

  if (argc < 2) {
    printf("Usage: Uliscan filename\n");
    exit(-1);
  } else {
    printf("Measuring file %s\n", argv[1]);
  }

  fptr = fopen(argv[1],"rb");

  if (fptr == NULL) {
    printf("Can't find %s\n", argv[1]);
    exit(-1);
  }

  for (i = 0; i < V; i++) {
    table[i] = 0;
  }

  for (i = 0; i < Q; i++) {
    b = fgetc(fptr);
    table[b] = i;
  }

  printf("Init done\n");

  printf("Expected value for L=8 is 7.1836656\n");

  run = 1;

  while (run) {
    sum = 0.0;
    iproduct = 1;

    if (run)
      for (i = Q; run && i < Q + K; i++) {
        j = i;
        b = fgetc(fptr);

        if (b < 0)
          run = 0;

        if (run) {
          if (table[b] > j)
            j += K;

          sum += log((double)(j-table[b]));

          table[b] = i;
        }
      }

    if (!run)
      printf("Premature end of file; read %d blocks.\n", i - Q);

    sum = (sum/((double)(i - Q))) /  log(2.0);
    printf("%4.4f ", sum);

    for (i = 0; i < (int)(sum*8.0 + 0.50); i++)
      printf("-");

    printf("\n");

    /* refill initial table */
    if (0) {
      for (i = 0; i < Q; i++) {
        b = fgetc(fptr);
        if (b < 0) {
          run = 0;
        } else {
          table[b] = i;
        }
      }
    }
  }
}]]></pre>
  </body>
</html>


