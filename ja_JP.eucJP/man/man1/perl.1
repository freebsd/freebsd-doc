.\" $FreeBSD$
.rn '' }`
''' %RCSfile: perl.1,v %%Revision: 1.5 %%Date: 1998/06/04 21:05:33 %
''' 
''' %Log: perl.1,v %
''' Revision 1.5  1998/06/04 21:05:33  steve
''' Fix a bunch of spelling errors.
'''
''' PR:		6856
''' Submitted by:	Josh Gilliam <josh@quick.net>
'''
''' Revision 1.4  1997/08/30 12:22:46  jmg
''' fix a few spelling changes
'''
''' Submitted by: Josh Gilliam
'''
''' Closes PR's: 4429, 4431-4438
'''
''' PS: He has agreed to submit all contrib fixes back to the original author.
'''
''' Revision 1.3  1996/10/05 22:26:23  wosch
''' delete doubled words, e.g.: "the the" -> "the"
'''
''' Revision 1.2  1994/10/27 23:16:52  wollman
''' Convince Perl to that is is part of the system, as /usr/bin/perl (binary)
''' and /usr/share/perl (library).  The latter was chosen as analogous to other
''' directories already present in /usr/share, like /usr/share/groff_font and
''' (particularly) /usr/share/mk.
'''
.\" Revision 1.1.1.1  1994/09/10  06:27:36  gclarkii
.\" Initial import of Perl 4.046 bmaked
.\"
.\" Revision 1.1.1.1  1993/08/23  21:29:37  nate
.\" PERL!
.\"
''' Revision 4.0.1.6  92/06/08  15:07:29  lwall
''' patch20: documented that numbers may contain underline
''' patch20: clarified that DATA may only be read from main script
''' patch20: relaxed requirement for semicolon at the end of a block
''' patch20: added ... as variant on ..
''' patch20: documented need for 1; at the end of a required file
''' patch20: extended bracket-style quotes to two-arg operators: s()() and tr()()
''' patch20: paragraph mode now skips extra newlines automatically
''' patch20: documented PERLLIB and PERLDB
''' patch20: documented limit on size of regexp
''' 
''' Revision 4.0.1.5  91/11/11  16:42:00  lwall
''' patch19: added little-endian pack/unpack options
''' 
''' Revision 4.0.1.4  91/11/05  18:11:05  lwall
''' patch11: added sort {} LIST
''' patch11: added eval {}
''' patch11: documented meaning of scalar(%foo)
''' patch11: sprintf() now supports any length of s field
''' 
''' Revision 4.0.1.3  91/06/10  01:26:02  lwall
''' patch10: documented some newer features in addenda
''' 
''' Revision 4.0.1.2  91/06/07  11:41:23  lwall
''' patch4: added global modifier for pattern matches
''' patch4: default top-of-form format is now FILEHANDLE_TOP
''' patch4: added $^P variable to control calling of perldb routines
''' patch4: added $^F variable to specify maximum system fd, default 2
''' patch4: changed old $^P to $^X
''' 
''' Revision 4.0.1.1  91/04/11  17:50:44  lwall
''' patch1: fixed some typos
''' 
''' Revision 4.0  91/03/20  01:38:08  lwall
''' 4.0 baseline.
''' 
''' 
.de Sh
.br
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
'br\}
.TH PERL 1 "\*(RP"
.UC
.SH 名称
perl \- 実用的抽出とレポートのための言語
.SH 書式
.B perl
[options] filename args
.SH 解説
.I perl
は、任意のテキストファイルを走査し、そこから情報を取り出し、情報に基づ
いたレポートを出力するために最適化されたインタプリタ言語です。
また、多くのシステム管理作業に適した言語でもあります。
.I perl
は美しい (小さい、エレガント、最小) というよりは、むしろ実用的 
(使いやすい、効率的、完全) であることをめざしています。
.I perl
は、C, \fIsed\fR, \fIawk\fR, and \fIsh\fR, の最も良いところを
組み合わせてある (作者の意向としては、でありますが) ので、これらの言語に
なじみのある人には、容易に使えるでしょう。
(言語歴史学者なら、\fIcsh\fR, Pascal, そして BASIC-PLUS の痕跡にさえも
気がつくでしょう。)
式の書式は、C のものに極めて似ています。
他の多くの UNIX ユーティリティと異なり、
.I perl
は、データのサイズを勝手に制限するようなことはなく (メモリのある限りです)、
ファイル全体を一つの文字列として読み込んでしまえます。
再帰の深さには制限がありません。連想配列で使われるハッシュテーブルは、
パフォーマンスの低下を防ぐため、必要に応じて大きくなります。
.I perl
は、大量のデータを非常に迅速に走査する洗練されたパターンマッチ
テクニックを使います。
テキスト走査に最適化されてはいますが、
.I perl
はバイナリデータも扱うこともできて、(dbm が使えるなら) 連想配列に似た
dbm ファイルを作れます。
setuid
.I perl
スクリプトは、多くの馬鹿らしいセキュリティホールを防ぐデータフロー追跡
機構により、C のプログラムより安全です。
普通なら \fIsed\fR, \fIawk\fR, \fIsh\fR を使うような問題で、その能力を
越えていたり、もう少し速く走らせなければならなかったり、
くだらないことを C で書きたくないような場合に
.I perl
がぴったりです。
既存の
.I sed
や
.I awk
スクリプトを
.I perl
スクリプトにする変換プログラムもあります。
さあ、宣伝はこれで十分でしょう。
.PP
まず始めに、
.I perl
次の場所からスクリプトを探します。
.Ip 1. 4 2
コマンドライン上の
.B \-e
スイッチで指定された行。
.Ip 2. 4 2
コマンドライン上で、最初に指定されたファイルの内容。
(#! の表記をサポートするシステムは、インタプリタをこうして起動します)
.Ip 3. 4 2
標準入力から暗黙のうちに読み込まれます。これは、ファイル名の指定が一つ
もない場合にだけ働きます。\*(--
.I 標準入力
スクリプトに引数を渡すには、スクリプト名として明示的に \- を
指定しなければなりません。
.PP
スクリプトを見つけると、
.I perl
は内部形式にコンパイルし、スクリプトが文法的に正しければ
それを実行します。
.Sh "オプション"
注意: 最初にこのセクションを読んでも意味がわからないかもしれません。
簡単なリファレンスとして前半部分になっています。
.PP
一文字オプションは、次に続くオプションとくっつけてもかまいません。
#! 構造を使うスクリプトを起動する際には一つの引数しか許されないの
で、特に便利です。
例:
.nf

.ne 2
	#!/usr/bin/perl \-spi.bak	# \-s \-p \-i.bak と同じ
	.\|.\|.

.fi
以下のオプションがあります:
.TP 5
.BI \-0 数字
レコードセパレータ ($/) を 8 進数で指定します。
数字がないと、ヌルキャラクタがセパレータになります。
他のコマンドラインスイッチは、前に置くか、もしくは数字の後に続けます。
例えば、ヌル文字を終端としたファイル名を表示可能なバージョンの
.I find
なら、このように書けます。
.nf

    find . \-name '*.bak' \-print0 | perl \-n0e unlink

.fi
00 は特殊な値で、
.I perl
はファイルをパラグラフモードで読み込みます。
0777 という値を使うと、この値の文字はないので、ファイル全体を
読み込みます。
.TP 5
.B \-a
.B \-n
や
.BR \-p
オプションと一緒に用いて、オートスプリットモードを ON にします。
.B \-n
や
.BR \-p
オプションで自動的に生成される while ループの内側の
最初のところで、@F 配列に対して暗黙の split コマンドが行なわれます。
.nf

	perl \-ane \'print pop(@F), "\en";\'

は、次の例と同等になります。

	while (<>) {
		@F = split(\' \');
		print pop(@F), "\en";
	}

.fi
.TP 5
.B \-c
.I perl
スクリプトの文法をチェックし、実行せずに終了します。
.TP 5
.BI \-d
perl デバッガのもとでスクリプトを実行します。
デバッグのセクションを参照して下さい。
.TP 5
.BI \-D 数字
デバッグフラッグをセットします。
スクリプトがどのように実行されるかを見るには、
.BR \-D14
を使います。
(これはデバッグ機能を
.IR perl
に組み込んでコンパイルした時にのみ動作します。)
\-D1024 も有用な値で、コンパイルされた文法ツリーをリストします。
\-D512 を使うと、コンパイルされた正規表現を出力します。
.TP 5
.BI \-e " コマンドライン"
一行スクリプトを入力する場合に使えます。
複数行スクリプトを組み立てるには、複数の
.B \-e
コマンドを指定すればできます。
.B \-e
が与えられると、
.I perl
は引数のリストの中からスクリプトファイル名を探しません。
.TP 5
.BI \-i 拡張子
<> 構造で処理されるファイルをその場で修正することを指定します。
入力ファイルをリネームし、出力ファイルを元の名前でオープンし、出力ファイルを
print 文のデフォルト出力にすることで処理されます。
拡張子が与えられれば、バックアップファイルの名前として元のファイル名に
その拡張子を加えたものが使われます。
拡張子が与えられなければ、バックアップファイルは作成されません。
\*(L"perl \-p \-i.bak \-e "s/foo/bar/;" .\|.\|. \*(R" を実行することは、
次のスクリプトと同じです。
.nf

.ne 2
	#!/usr/bin/perl \-pi.bak
	s/foo/bar/;

これは以下のものとも同等になります。

.ne 14
	#!/usr/bin/perl
	while (<>) {
		if ($ARGV ne $oldargv) {
			rename($ARGV, $ARGV . \'.bak\');
			open(ARGVOUT, ">$ARGV");
			select(ARGVOUT);
			$oldargv = $ARGV;
		}
		s/foo/bar/;
	}
	continue {
	    print;	# 元の名前のファイルに出力する
	}
	select(STDOUT);

.fi
ただし、
.B \-i
を用いた方法では、ファイル名が変更された時刻を知るために $ARGV と $oldargv を
比較する必要がないという点が異なります。
実際にはファイルハンドルとして ARGVOUT がセレクトされて使われます。
.I STDOUT
がデフォルト出力のファイルハンドルとして保存され、
ループのあとで戻されることに注意して下さい。
.Sp
入力ファイルすべてに追加を行なう場合や、行番号をリセットしたりする場合、
各入力ファイルの終わりを知るために `eof' を使うことができます。
(eof の例を参照して下さい)
.TP 5
.BI \-I ディレクトリ
.B \-P
と一緒に用いて C プリプロセッサにインクルードファイルの位置を
知らせます。デフォルトでは、/usr/include と /usr/lib/perl を検索します。
.TP 5
.BI \-l 8進数
行末処理を自動的に行ないます。これには二つの効果があります。
まず、
.B \-n
や
.B \-p
と共に使われることで、行ターミネータを自動的に除きます。
二つ目は、$\e が、
.I 8進数
をセットし、print 文がすべて最後に行末文字をつけるということです。
.I 8進数
が省略された場合は、$\e に $/ の現在の値をセットします。
例えば、行を 80 桁に切り揃えるためには:
.nf

	perl -lpe \'substr($_, 80) = ""\'

.fi
$\e = $/ という代入はコマンドラインスイッチが処理される時に
行なわれるので、
.B \-l
スイッチに
.B \-0
が続くときは、入力レコードセパレータと出力レコードセパレータが
異なることもあり得るということに注意して下さい。
.nf

	gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

.fi
これは、$\e に改行をセットし、$/ にはヌル文字をセットします。
.TP 5
.B \-n
スクリプトの前後に下に示すループがあるものとして
.I perl
を起動します。こうすると、引数のファイル全部について
\*(L"sed \-n\*(R" または \fIawk\fR と同じような繰り返しが行なわれます:
.nf

.ne 3
	while (<>) {
		.\|.\|.		# ここにスクリプトが来ます
	}

.fi
デフォルトで入力行の出力はされないことに注意して下さい。
出力したければ
.B \-p
を参照して下さい。
以下は、1 週間より古いファイルすべてを削除する効率的な方法です。
.nf

	find . \-mtime +7 \-print | perl \-nle \'unlink;\'

.fi
この場合、ファイルが見つかるたびにプロセスを開始する必要がないので、
find の \-exec スイッチを使うより速くなります。
.TP 5
.B \-p
スクリプトの前後に下に示すループがあるものとして
.I perl
を起動します。こうすると、引数のファイル全部について
\fIsed\fR と同じような繰り返しが行なわれます:
.nf

.ne 5
	while (<>) {
		.\|.\|.		# ここにスクリプトが来ます
	} continue {
		print;
	}

.fi
入力行は自動的に出力されることに注意して下さい。
出力を抑制したければ、
.B \-n
スイッチを使って下さい。
.B \-p
は、
.B \-n
スイッチに優先します。
.TP 5
.B \-P
.IR perl
によるコンパイルの前に C プリプロセッサを通します。
(perl のコメントも cpp の命令も # の文字で始まるので、
コメントを C プリプロセッサが理解する単語、例えば
\*(L"if\*(R" や \*(L"else\*(R" や \*(L"define\*(R" で始めてはなりません。)
.TP 5
.B \-s
コマンドライン上で、スクリプト名とファイル名の引数
(または \-\|\-) の間にある各スイッチについて基本的な解析を行ないます。
スイッチが見つかると、@ARGV から除かれ、対応する変数を
.I perl
スクリプト内でセットします。
以下のスクリプトでは、\-xyz スイッチをつけてスクリプトを起動したとき
だけ、\*(L"true\*(R" を出力します。
.nf

.ne 2
	#!/usr/bin/perl \-s
	if ($xyz) { print "true\en"; }

.fi
.TP 5
.B \-S
スクリプトを探すのに、環境変数 PATH を用います
(スクリプト名が / で始まらないかぎり) 。
通常は、#! をサポートしないマシンにおいて #! を
エミュレートするために用いられます。
次のような使い方です:
.nf

	#!/usr/bin/perl
	eval "exec /usr/bin/perl \-S $0 $*"
		if $running_under_some_shell;

.fi
システムは 1 行目を無視し、スクリプトを /bin/sh に渡します。 /bin/sh は 
.I perl
スクリプトをシェルスクリプトとして実行しようとします。シェルは 2 行目
を通常のシェルコマンドとして実行し、perl インタプリタを起動する
ことになります。
システムによっては $0 は必ずしもフルパス名にならないので、
.B \-S
を用いて
.I perl
に必要ならばスクリプトを探すように指示します。
.I perl
がスクリプトを見つけたあと、解析を行ないますが、変数
$running_under_some_shell が真になることはないので、2 行目を無視します。
ファイル名などに含まれるスペースを正しく扱うには、$* よりも
${1+"$@"} の方がよいでしょうが、csh が解釈する場合には動作しません。
csh ではなく sh で起動するには、あるシステムでは #! 行を、perl で
無視されるコロンのみに書き換える必要があるかもしれません。その他の
システムではこの方法は使えず、次のように、csh, sh, perl のどの下で
も動作するような、とてもまわりくどい方法をとる必要があります:
.nf

.ne 3
	eval '(exit $?0)' && eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
	& eval 'exec /usr/bin/perl -S $0 $argv:q'
		if 0;

.fi
.TP 5
.B \-u
スクリプトのコンパイルの後、
.I perl
はコアダンプします。
このコアダンプから、`undump' プログラム(提供していません)を用いて
実行可能ファイルに変換できます。
こうすると、ディスク消費が増えるかわりに (実行ファイルを strip すれば
最小にできます)、スタートアップが速くなります。
(しかし、私のマシンでは "hello world" の実行形式が約 200K の大きさ
になります。)
実行形式を set-id プログラムとして走らせるのなら、通常の perl ではなく 
多分 taintperl を用いてコンパイルすべきです。
ダンプする前に実行したいスクリプトがある場合は、代わりに dump 演算子を
使って下さい。
注意 : undump が使えるかどうかはプラットフォームに依存するので、perl の 
移植によっては利用できないものもあるかもしれません。
.TP 5
.B \-U
安全でない操作を可能にします。
現在の所、\*(L"安全でない\*(R" 操作とは、スーパユーザ権限での
実行時にディレクトリを unlink すること、および汚れチェックで
警告が出るような setuid プログラムを走らせることだけです。
.TP 5
.B \-v
.I perl
のバージョンとパッチレベルを出力します。
.TP 5
.B \-w
一度だけ出てくる識別子、セットする前に使用されるスカラ変数に対して、
警告を出します。
サブルーチンが再定義されたとき、定義されていないファイルハンドルの参照
があるとき、リードオンリーでオープンしたファイルハンドルへ書き込もうと
したときにも警告を出します。数値ではなさそうな値に == を使ったときや、
サブルーチンが 100 回以上再帰したときにも警告を出します。
.TP 5
.BI \-x ディレクトリ
スクリプトがメッセージに埋め込まれていることを
.I perl
に知らせます。#! で始まり、"perl" という文字列を含む最初の行が現れる
までは、ゴミとして無視されます。
その行に指定した意味のあるスイッチはすべて適用されます
(ただし通常の #! 処理と同じく、スイッチのかたまり一つだけです)。
ディレクトリ名を指定すると、perl はスクリプトを実行する前にその
ディレクトリに移ります。
.B \-x
スイッチは、先頭のゴミを捨てるだけです。
スクリプトの後にゴミがある場合は、スクリプトは _\|_END_\|_
で終わらせなければなりません (望むなら、スクリプトで後ろのゴミの一部
または全部をファイルハンドル DATA 経由で処理することが可能です) 。
.Sh "データの型とオブジェクト"
.PP
.I perl
には 3 種類のデータ型が有ります: スカラ、スカラ配列、
および連想配列です。
通常の配列は添え字が数字ですが、連想配列の場合は文字列です。
.PP
perl における演算や値の解釈は、演算や値のコンテキスト(文脈)からの要求
にしばしば依存します。
主なコンテキストは三つ: すなわち文字列、数値、配列です。
演算の中には、配列を要求するコンテキストでは配列を、そうでなければ
スカラ値を返すものもあります。
(そのような演算子についてはドキュメント内のその演算子のところに
記載されています。)
スカラ値を返す演算子は、コンテキストが文字列あるいは
数値のどちらを要求しているかは考慮しませんが、スカラ変数および
スカラ値は文字列あるいは数値のコンテキストの適切な方に解釈されます。
スカラはそれがヌル文字列あるいは 0 でなければ論理的に真であると
解釈されます。
演算子が返す論理値は、真の場合は 1、偽の場合は 0 または \'\'
(ヌル文字列)です。
.PP
実際には、ヌル文字には二種類あります。define と undefined です。
undefined のヌル文字列は、エラー、ファイル終端、初期化されていない変数や
配列要素を参照しようとしたときなど、実際の値が存在しない場合に返ります。
undefined のヌル文字列は、最初にそれにアクセスしたときに defined となる
ことがありますが、その前に defined() 演算子を用いて値が defined かどう
かを知ることができます。
.PP
スカラ変数への参照は、それが配列の一部であっても、常に \*(L'$\*(R'
で始めます。
つまりこうです:
.nf

.ne 3
    $days	\h'|2i'# 単純なスカラ変数
    $days[28]	\h'|2i'# 配列 @days の 29 番目の要素
    $days{\'Feb\'}\h'|2i'# 連想配列の値の一つ
    $#days	\h'|2i'# 配列 @days の最後の添え字

しかし、配列全部や一部の取り出しは \*(L'@\*(R' で始めます:

    @days	\h'|2i'# ($days[0], $days[1],\|.\|.\|. $days[n])
    @days[3,4,5]\h'|2i'# @days[3.\|.5] と同じ
    @days{'a','c'}\h'|2i'# ($days{'a'},$days{'c'}) と同じ

そして、連想配列全部を扱うには \*(L'%\*(R' で始めます:

    %days	\h'|2i'# (key1, val1, key2, val2 .\|.\|.)
.fi
.PP
これら 8 つはすべて左辺値として扱うことができます。すなわち、代入可能
ということです。
(さらに、あるコンテキストでは代入操作自体も左辺値となり得ます。
\*(-- s, tr, chop のところの例を参照して下さい。)
スカラへの代入を行なうと、右辺をスカラのコンテキストで評価するのに
対し、配列や配列の一部への代入は右辺を配列のコンテキストで評価します。
.PP
配列 @days の長さを
.IR csh
のように
\*(L"$#days\*(R" で評価してもかまいません。
(実際には、通常 0 番目の要素があるので、配列の長さではなく、最後の要素
の添え字になります。)
$#days に代入すると、配列の長さが変わります。
この方法によって配列を小さくしても、実際には値は破壊されません。
すでに小さくした配列を大きくすると、もともとあった要素が元に戻ります。
大きくなりそうな配列をあらかじめ大きくしておくと、
効率をいくらか良くすることもできます。
(配列を大きくするには、配列の最後を超える要素に代
入を行なう方法もあります。この方法と、$#whatever へ代入する方法との
違いは、間の要素にヌルがセットされることです)
配列を縮めて空にするには、ヌルリスト () を代入すればできます。
次の二つは全く同等となります。
.nf

	@whatever = ();
	$#whatever = $[ \- 1;

.fi
.PP
配列をスカラのコンテキストで評価すると、配列の長さが返ります。
次の式は常に真となります:
.nf

	scalar(@whatever) == $#whatever \- $[ + 1;

.fi
連想配列をスカラのコンテキストで評価すると、配列が要素を含む場合
かつその場合に限り真の値を返します。
(要素がある場合に返る値は、使用している bucket の数およびアロケートさ
れている bucket の数から成る文字列で、/ で区切られます。)
.PP
多次元配列は直接はサポートされていませんが、連想配列を用いて複数の
添え字をエミュレートする方法については、$; 変数の項を参照して下さい。
多次元の添え字を 1 次元の添え字に変換するサブルーチンを書くことも
できます。
.PP
各々のデータ型に応じて、それぞれの名前空間があります。衝突を心配する
ことなく、同じ名前をスカラ変数、配列、連想配列、ファイルハンドル、
サブルーチン名、またはラベルにつけることができます。
変数や配列への参照は常に \*(L'$\*(R', \*(L'@\*(R', \*(L'%\*(R'
で始まるので、\*(L"予約\*(R" 語は変数名については実際には
使用可能です。
(しかし、ラベルやファイルハンドルについては予約語は使用できません。
特殊な文字で始まらないからです。
.br
ヒント: open(log,\'logfile\') より open(LOG,\'logfile\') を使った方が
良いです。大文字のファイルハンドル名を使うと、読み易さも向上し、
将来の予約語になるものとの衝突も避けることができるからです。)
大文字小文字の区別は重要です
\*(--\*(L"FOO\*(R", \*(L"Foo\*(R", \*(L"foo\*(R" はすべて異なる
名前です。アルファベットで始まる名前は数字や下線を含んでもかまいません。
アルファベットで始まらない名前は 1 文字に限られます。
例えば、\*(L"$%\*(R" や \*(L"$$\*(R" です。
(ほとんどの一文字名は
.IR perl
の予約変数として意味があります。
詳細は後ほど述べます。)
.PP
数値文字列は通常の浮動小数点や整数の形式で指定します。
.nf

.ne 6
    12345
    12345.67
    .23E-10
    0xffff	# 16 進
    0377	# 8 進
    4_294_967_296

.fi
文字列はシングルクォートまたはダブルクォートで区切られます。
動作はシェルにおけるクォートとよく似ています。
ダブルクォートで囲まれた文字列にはバックスラッシュや変数の置換が
行なわれます。シングルクォートで囲まれた文字列には行なわれません
(\e\' と \e\e を除きます)。
通常のバックスラッシュ規則が改行やタブなどの文字を表すのに使え、
更に以下のちょっと変わった形式も使えます:
.nf

	\et		タブ
	\en		改行
	\er		リターン
	\ef		フォームフィード
	\eb		バックスペース
	\ea		アラーム (ベル)
	\ee		エスケープ
	\e033		8進文字
	\ex1b		16進文字
	\ec[		コントロール文字
	\el		次の文字を小文字にします
	\eu		次の文字を大文字にします
	\eL		\eE までを小文字にします
	\eU		\eE までを大文字にします
	\eE		大小文字の修飾の終り

.fi
改行を直接文字列に書き入れることもできます。すなわち、文字列は始まった
行と異なる行で終わることができることになります。これは便利ですが、
最後にクォートを忘れると、クォートを含むかなり離れた別の行を見つけるまで
.I perl
はエラーを報告しないでしょう。
文字列内の変数置換はスカラ変数、通常の配列、配列の一部に限られます。
(言い換えると、$ や @ で始まる識別子と、それに括弧で囲まれた添え字が
ある場合だけです。)
次のコードは \*(L"The price is $100.\*(R" を出力します。
.nf

.ne 2
    $Price = \'$100\';\h'|3.5i'# 解釈されません
    print "The price is $Price.\e\|n";\h'|3.5i'# 解釈されます

.fi
後に続くアルファベットや数字と区別するために、識別子を {} で囲う
ことができることを覚えておいて下さい。
また、シングルクォートは識別子として有効な文字であるため、
シングルクォートで囲まれた文字列は、前の単語とは空白で区切られて
いなければならないことも覚えておきましょう
(パッケージの項を参照して下さい) 。
.PP
プログラムのその時点での行番号とファイル名を表す
_\|_LINE_\|_ と _\|_FILE_\|_  という二つの特殊な文字があります。
これらは独立したトークンとしてのみ使用でき、文字列中に
書き入れることはできません。
さらにトークン _\|_END_\|_ は、実際のファイルが終了する前で、スクリプト
の論理的な終了を示すために使えます。残りのテキストはすべて無視されますが、
ファイルハンドル DATA から読むことができます。
(ファイルハンドル DATA は、メインスクリプトからのみデータを
読み込めますが、require されたファイルや評価された文字列からは
読み込めません。)
^D と ^Z の二つのコントロールキャラクタは _\|_END_\|_ と同義になります。
.PP
文法的に解釈不可能な単語は、それがシングルクォートで囲まれている
かのように扱われます。このため、アルファベット、数字、下線のみからなり、
単語はアルファベットで始まらなければなりません。
ファイルハンドルやラベルと同じく、小文字のみからなる裸の単語は、
将来の予約語と衝突する危険があります。
.B \-w
スイッチを使えば、perl はそのような単語について警告してくれます。
.PP
配列値をダブルクォートで囲まれた文字列に入れた場合は、配列の全要素を 
$" 変数で指定される区切り (デフォルトは空白) で連結して一つにした
文字列になります。
(3.0 以前のバージョンの perl では、@ はダブルクォートで囲まれた文字列
の中のメタキャラクタではなかったので、@array, $array[EXPR],
@array[LIST], $array{EXPR}, @array{LIST} の文字列への挿入は、
配列がプログラムのどこかで参照されている場合、もしくは予約されている
場合にのみ起こります。)
次の二つは同等になります。
.nf

.ne 4
	$temp = join($",@ARGV);
	system "echo $temp";

	system "echo @ARGV";

.fi
検索パターン (これにもダブルクォートと同じ置換が行なわれます) に
おいては、あいまいな場合があります。 /$foo[bar]/ は /${foo}[bar]/
([bar]は正規表現の文字クラス) でしょうか、
それとも /${foo[bar]}/ ([bar]は配列 @foo の添字) なのでしょうか 。
@foo が存在しないなら、それは明らかに文字クラスです。
@foo が存在するなら、perl は [bar]について考え、大抵の場合正しい類推を
します。それが間違っていたり、あなたが単に偏執狂なら、
上記のように中括弧 {} を入れることで、正しい解釈をさせることができます。
.PP
行指向の引用法はシェルと同様の文法に基づいています。
<< の後に引用文の終わりを示す文字列を指定すると、現在行からその文字列
が現れるまでの行すべてがその値になります。終わりを示す文字列は識別子 
(単語) でも、クォートされたテキストでもかまいません。
クォートされているテキストの場合、通常クォートで囲む場合と同じく
クォートの種類がテキストの扱い方を決めます。クォートされていない識別子
はダブルクォートされている場合と同じ動作となります。
(スペースを入れた場合、それは有効なヌル識別子として扱われ、
最初の空行にマッチします。 \*(--下の Merry Christmas の例を見て下さい。) 
終わりを示す文字列はそれだけで (クォートされず、空白を前後につけずに)
書かれていなければなりません。
.nf

	print <<EOF;		# 前の例と同じです
The price is $Price.
EOF

	print <<"EOF";		# 上の例と同じです
The price is $Price.
EOF

	print << x 10;		# ヌル識別子が終わりを示します
Merry Christmas!

	print <<`EOC`;		# コマンドを実行します
echo hi there
echo lo there
EOC

	print <<foo, <<bar;	# スタックに積むことができます
I said foo.
foo
I said bar.
bar

.fi
配列のリテラルは、個々の値をコンマで区切り、リストを括弧で囲みます:
.nf

	(LIST)

.fi
配列値を要求しないコンテキストでは、C のコンマ演算子と同じく、最後の要
素の値が配列の値となります。例えば、
.nf

.ne 4
    @foo = (\'cc\', \'\-E\', $bar);

は配列 foo に全配列値を代入しますが、

    $foo = (\'cc\', \'\-E\', $bar);

.fi
は変数 bar の値を変数 foo に代入します。
変数として実際に存在する配列のスカラのコンテキストとしての値は、
配列の長さになることに注意して下さい。
次の例では $foo に 3 を代入します:
.nf

.ne 2
    @foo = (\'cc\', \'\-E\', $bar);
    $foo = @foo;		# $foo は 3 になります

.fi
配列リテラルの括弧を閉じる前に余分なコンマがあっても大丈夫で、
以下のように書けます:
.nf

    @foo = (
	1,
	2,
	3,
    );

.fi
リストが評価されるとき、リストの要素はすべて配列のコンテキストとして
評価され、結果として得られる配列値に、個々の要素がリストのメンバで
あったかのようにリストに挿入されます。
たとえば、@foo のすべての要素、@bar のすべての要素、サブルーチン
SomeSub が返すすべての要素を含むリスト\*(--以下

	(@foo,@bar,&SomeSub)

の中では、配列の識別ができなくなります。
.PP
リストの値は通常の配列と同様に添え字をつけて使えます。
例:
.nf

	$time = (stat($file))[8];	# stat は配列値を返します
	$digit = ('a','b','c','d','e','f')[$digit-10];
	return (pop(@foo),pop(@foo))[0];

.fi
.PP
配列のリストは、そのすべての要素が左辺値であるときに限り代入可能です:
.nf

    ($a, $b, $c) = (1, 2, 3);

    ($map{\'red\'}, $map{\'blue\'}, $map{\'green\'}) = (0x00f, 0x0f0, 0xf00);

最後の要素は配列や連想配列であってもかまいません:

    ($a, $b, @rest) = split;
    local($a, $b, %rest) = @_;

.fi
実際には、リストのどこに配列を入れてもいいのですが、リスト中の最初の
配列がすべての値を埋めてしまうので、その後の要素はヌルの値になります。
これは local() において便利かもしれません。
.PP
連想配列のリテラルは、キーと値として解釈される値の組を含んでいます:
.nf

.ne 2
    # 上記 map への代入と同じ
    %map = ('red',0x00f,'blue',0x0f0,'green',0xf00);

.fi
スカラのコンテキストへの配列の代入は、代入の右辺の式により生成される
要素の数を返します:
.nf

	$x = (($foo,$bar) = (3,2,1));	# $x に 2 でなく 3 をセット

.fi
.PP
知っておかなければならない幾つかの疑似リテラルがあります。
文字列を `` (低アクセント) で囲んだ場合、ちょうどダブルクォートと
同じ変数置換が行なわれます。次にシェルの中のように、コマンドであると
解釈され、そのコマンドの出力がこの擬似リテラルの値となります。
スカラのコンテキストでは、全出力から成る一つの文字列が返されます。
配列のコンテキストでは、出力の各行がそれぞれ一つの要素となった配列値
が返されます。
(行ターミネータを変えたい場合には、$/ をセットできます。)
コマンドは擬似リテラルが評価されるたびに実行されます。コマンドの戻り値
は、$? に返されます
($? の解釈については予約変数のセクションを参照して下さい) 。
\f2csh\f1 の場合と異なり、返されるデータに置換は行なわれません
\*(-- 改行は改行として残ります。
どのシェルとも違って、シングルクォートで囲んでもコマンド内の変数名は解
釈されてしまいます。
$ をシェルに渡すには、バックスラッシュが必要です。
.PP
カギ括弧 <> に囲まれたファイルハンドルを評価すると、そのファイルから次の
行を読み込みます (改行が含まれるため EOF までは決して偽に成りません。
EOF では undefined 値が返ります) 。
通常はその値を変数に代入する必要がありますが、一つだけ
自動的に代入が起こる状況があります。入力シンボルだけが while ループの
条件文の中にある場合は(そしてこの場合にかぎり)、値は変数
\*(L"$_\*(R" に自動的に代入されます。
(奇妙に思うかもしれませんが、ほとんどの
.I perl
スクリプトにおいて、この構文を使うことになるでしょう。)
とにかく、次の例はすべて同等となります。
.nf

.ne 5
    while ($_ = <STDIN>) { print; }
    while (<STDIN>) { print; }
    for (\|;\|<STDIN>;\|) { print; }
    print while $_ = <STDIN>;
    print while <STDIN>;

.fi
ファイルハンドル
.IR STDIN ,
.IR STDOUT ,
.I STDERR
は予約されています。
(ファイルハンドル
.IR stdin ,
.IR stdout ,
.I stderr
でも動作しますが、パッケージの中ではグローバルではなくローカルな識別子
として解釈されるので、働きません。)
これ以外のファイルハンドルは、
.I open
関数で作成できます。
.PP
配列を探すコンテキストの中で <FILEHANDLE> が使われると、すべての入力行
の一行が一要素である配列が返ります。この方法で*巨大*なデータ空間が簡単
に作られるので、注意して使って下さい。
.PP
ヌルファイルハンドル <> は特殊で、\fIsed\fR や \fIawk\fR の動作を
エミュレートするために使えます。
<> からの入力には、標準入力やコマンドラインに並べられた全ファイルが
入ります。動作の仕方はこうなります。 <> の最初の評価では、ARGV 配列が
チェックされ、それがヌルであると、$ARGV[0] は標準入力をオープンする \'-\'
にセットされます。
次に ARGV 配列がファイル名のリストとして処理されます。
次のループは、
.nf

.ne 3
	while (<>) {
		.\|.\|.			# 各行に対するコード
	}

.ne 10
以下の疑似コードと同等になります。

	unshift(@ARGV, \'\-\') \|if \|$#ARGV < $[;
	while ($ARGV = shift) {
		open(ARGV, $ARGV);
		while (<ARGV>) {
			.\|.\|.		# 各行に対するコード
		}
	}

.fi
前者は、書くのが面倒でないというだけで、同じように動作します。
実際には、前者でも 配列 ARGV を shift し、現在のファイル名を変数 ARGV 
に代入します。
内部では、ファイルハンドル ARGV を使います \*(--<> は、魔術的な <ARGV> 
とまったく同義です。
(上の疑似コードでは、<ARGV> を魔術的でないものとして扱うので、
動きません)
.PP
ファイル名のリストの配列が残っている限り、最初の <> の前に @ARGV を
変更することができます。
行番号 ($.) は入力が一つの大きなファイルであるかのように増えていきます。
(ファイル毎に行番号をリセットする方法については eof の例を参照して
下さい。)
.PP
.ne 5
@ARGV に自分でファイルのリストをセットしたい場合は、そうして下さい。
スクリプトにスイッチを渡したい場合、スクリプトの前の方に次のような
ループを置くことでできます:
.nf

.ne 10
	while ($_ = $ARGV[0], /\|^\-/\|) {
		shift;
	    last if /\|^\-\|\-$\|/\|;
		/\|^\-D\|(.*\|)/ \|&& \|($debug = $1);
		/\|^\-v\|/ \|&& \|$verbose++;
		.\|.\|.		# 他のスイッチ
	}
	while (<>) {
		.\|.\|.		# 各行に対するコード
	}

.fi
<> シンボルは一回だけ*偽*を返します。
その後、もう一度呼ぶと、別の @ARGV リストを処理しているとみなして、
@ARGV がセットされていない場合は
.IR STDIN
から入力されることになります。
.PP
カギ括弧の中の文字列がスカラ変数への参照であるとき (例えば <$foo>) 、
その変数の内容が読み込むべきファイルハンドル名となります。
.PP
カギ括弧の中の文字列がファイルハンドルではないとき、検索 (glob) される
ファイルパターンと解釈され、コンテキストによってファイル名の配列
またはリストの中の次のファイルが返されます。
最初に $ の解釈の一レベルが行なわれますが、<$foo> は前の段落で
説明されたような間接ファイルハンドルとなるため使えません。
強制的にファイル名検索と解釈させさければ <${foo}> のように
中括弧 {} を挿入できます。
例:
.nf

.ne 3
	while (<*.c>) {
		chmod 0644, $_;
	}

は以下と等価です。

.ne 5
	open(foo, "echo *.c | tr \-s \' \et\er\ef\' \'\e\e012\e\e012\e\e012\e\e012\'|");
	while (<foo>) {
		chop;
		chmod 0644, $_;
	}

.fi
実際、現在のところこのように実装されています。
(これは、マシン上に /bin/csh がなければ、空白を含むファイル名では
動かないことを意味します。)
もちろん、上の操作を行なう一番短い方法は、
.nf

	chmod 0644, <*.c>;

.fi
です。
.Sh "文法"
.PP
.I perl
スクリプトは、一連の宣言とコマンドからなります。
.I perl
の中で宣言されなければならないものは、レポートフォーマットと
サブルーチンです。
これらの宣言の詳しい説明は下のセクションを参照して下さい。
初期化されていないユーザが作成したオブジェクトは、それが代入のように
明示的に定義されるまでは、ヌルまたは 0 の値であるとみなされます。
コマンド列が各入力行に対して実行される
.I sed
や
.I awk
スクリプトと違って、コマンド列は一度だけ実行されます。
入力ファイル (または複数のファイル) の各行について繰り返しを行うには
明示的にループを設けなければなりませんが、
着目するファイル、行をよりよくコントロールすることができます。
(実は、正しくありません \*(-- 
.B \-n
や
.B \-p
スイッチで、暗黙のループを行なうことができます。)
.PP
宣言は、コマンドを書くことができる場所ならどこにでも書くことができますが、
コマンド実行の基本的な流れには影響を与えません \*(-- 宣言は、
コンパイル時だけにしか影響を与えません。通常、すべての宣言は
スクリプトの最初か最後のどちらかに置きます。
.PP
.I perl
は、ほとんどの部分において自由形式言語です。
(唯一の例外はフォーマット宣言で、理由は実に明白です。)
コメントは、# 文字で指示され、行末までとなります。
/* */ という C のコメントを使おうとすると、コンテキストにより
除算またはパターンマッチと解釈されるので、そういうことはしないで下さい。
.Sh "複合文"
.IR perl
では、複数のコマンド列を中括弧 {} で囲むことで、一つのコマンドとして
扱うことになり、これをブロックと呼びます。
.PP
次のような複合コマンドは、フローコントロールに使われます:
.nf

.ne 4
	if (EXPR) BLOCK
	if (EXPR) BLOCK else BLOCK
	if (EXPR) BLOCK elsif (EXPR) BLOCK .\|.\|. else BLOCK
	LABEL while (EXPR) BLOCK
	LABEL while (EXPR) BLOCK continue BLOCK
	LABEL for (EXPR; EXPR; EXPR) BLOCK
	LABEL foreach VAR (ARRAY) BLOCK
	LABEL BLOCK continue BLOCK

.fi
C や Pascal と違って、これらは文ではなく*ブロック*として定義されているこ
とに注意して下さい。
これは、中括弧 {} が、\fI必要である\fR ことを意味します \*(-- 一つの
文を置くことは許されません。
中括弧 {} なしで書きたい場合は、別の方法があります。
以下はすべて同等のことを行ないます:
.nf

.ne 5
	if (!open(foo)) { die "Can't open $foo: $!"; }
	die "Can't open $foo: $!" unless open(foo);
	open(foo) || die "Can't open $foo: $!";	# foo でなければ終わり
	open(foo) ? \'hi mom\' : die "Can't open $foo: $!";
				# 最後のものは、ちょっとエキゾチック

.fi
.PP
.I if
文は単純です。
*ブロック*は、常に中括弧 {} で囲まれるため、
.I else
が、どの
.I if
にかかるかという曖昧さは生じません。
.I unless
を
.IR if
の代わりに使うと、逆の意味となります。
.PP
.I while
文は、式が真 (ヌル文字列または 0 でない) である限り、ブロックを
実行し続けます。
識別子とコロンからなるラベルをつけることもできます。
ラベルはループ制御文
.IR next ,
.IR last ,
.I redo
(以下を参照)
によって指し示すループの名前となります。
.I continue
ブロックがあると、条件文が再評価される前に必ず実行され、C における
.I for
ループの三番目の部分と同様となります。
こうして、たとえ
.I next
文で継続された場合でもループ変数はインクリメントできることになります
(C の \*(L"continue\*(R" 文と同じ) 。
.PP
.I while
が
.IR until
に置き換えられると テストの意味は逆になりますが、条件判断は最初のループ
の前に行なわれます。
.PP
.I if
や
.I while
文では、\*(L"(EXPR)\*(R" をブロックに置き換えることができ、
ブロックの最後のコマンドの値が真なら、条件判断は真となります。
.PP
.I for
ループは、対応する
.I while
と全く同じように動作します:
.nf

.ne 12
	for ($i = 1; $i < 10; $i++) {
		.\|.\|.
	}

は、以下と同じになります。

	$i = 1;
	while ($i < 10) {
		.\|.\|.
	} continue {
		$i++;
	}
.fi
.PP
foreach ループは、通常の配列値について、配列の各要素を変数 VAR に順に
セットしながら繰り返します。
その変数は、ループに対して暗黙のうちにローカルであり、それ以前の値はルー
プを抜けると元の値に戻ります。
\*(L"foreach\*(R" キーワードは、実は \*(L"for\*(R" キーワードと同じで、
\*(L"foreach\*(R" を可読性のために、\*(L"for\*(R" を簡潔さのために
使うことができます。
VAR が省略されると、$_ が各値にセットされます。
ARRAY が実際の配列 (配列を返す式ではなく) の場合、ループ内の VAR を変
更することによって、配列の各要素を変更することができます。
例:
.nf

.ne 5
	for (@ary) { s/foo/bar/; }

	foreach $elem (@elements) {
		$elem *= 2;
	}

.ne 3
	for ((10,9,8,7,6,5,4,3,2,1,\'BOOM\')) {
		print $_, "\en"; sleep(1);
	}

	for (1..15) { print "Merry Christmas\en"; }

.ne 3
	foreach $item (split(/:[\e\e\en:]*/, $ENV{\'TERMCAP\'})) {
		print "Item: $item\en";
	}

.fi
.PP
ブロックそれ自身 (ラベルが付いていても、付いていなくても) は、一度だけ
実行されるループと等価です。
だから、ブロックを抜けたり再実行するために、すべてのループ制御文を使う
ことができます。
.I continue
ブロックも付けられます。
この構成は、case 構造を作成するには特に有用です。
.nf

.ne 6
	foo: {
		if (/^abc/) { $abc = 1; last foo; }
		if (/^def/) { $def = 1; last foo; }
		if (/^xyz/) { $xyz = 1; last foo; }
		$nothing = 1;
	}

.fi
同等のものを記述する方法が、既にいくつもあるので、perl には公式の 
switch 文がありません。
上記のものに加えて、
.nf

.ne 6
	foo: {
		$abc = 1, last foo  if /^abc/;
		$def = 1, last foo  if /^def/;
		$xyz = 1, last foo  if /^xyz/;
		$nothing = 1;
	}

または

.ne 6
	foo: {
		/^abc/ && do { $abc = 1; last foo; };
		/^def/ && do { $def = 1; last foo; };
		/^xyz/ && do { $xyz = 1; last foo; };
		$nothing = 1;
	}

または

.ne 6
	foo: {
		/^abc/ && ($abc = 1, last foo);
		/^def/ && ($def = 1, last foo);
		/^xyz/ && ($xyz = 1, last foo);
		$nothing = 1;
	}

さらに

.ne 8
	if (/^abc/)
		{ $abc = 1; }
	elsif (/^def/)
		{ $def = 1; }
	elsif (/^xyz/)
		{ $xyz = 1; }
	else
		{$nothing = 1;}

.fi
とも書けます。
これらはすべて内部で switch 構造に最適化されるため、perl は直接目的の
文にジャンプするので、同じ単純なスカラ変数を == や eq や上記のような
パターンマッチで判定する限り、50 個の elsif を使っても perl がたくさん
の不要な文を実行するのでは、という心配は不要となります。
(ある特定の case ステートメントが最適化されているかどうかに興味があるなら、
\-D1024 スイッチを付けて実行前に文法ツリーを表示することができます。)
.Sh "単文"
単文のみがその副作用を評価される式となります。
どの単文もブロックの最後の文でない限り、セミコロンで終らなければ
なりません。最後の文では、セミコロンはなくてもかまいません。
(それでも、ブロックが一行以上を含んでいるのなら、
セミコロンはあった方が望ましいです)
.PP
どの単文も、セミコロンで終る前に一つの修飾子を続けることができます。
可能な修飾子は以下の通りです:
.nf

.ne 4
	if EXPR
	unless EXPR
	while EXPR
	until EXPR

.fi
.I if
と
.I unless
修飾子は見かけ通りの意味があります。
.I while
と
.I until
修飾子も見かけ通りの意味 (条件文が始めに評価されます) ですが、
do ブロックや do サブルーチンコマンドが付けられたときには異なり、
条件式が評価される前に一度だけ実行されます。
これは、以下のようなループが記述できるようにするためです:
.nf

.ne 4
	do {
		$_ = <STDIN>;
		.\|.\|.
	} until $_ \|eq \|".\|\e\|n";

.fi
(後述の
.I do
演算子を参照のこと。修飾子は、どれもループラベルを持てないため、
後に書かれたループ制御コマンドはこの構造では動かないことに
気をつけて下さい。あしからず。)
.Sh "式"
.I perl
の式は、ほとんど C の式と同じに動作しますが、違いをここに述べます。
.PP
以下が
.I perl
にあって、C にないものです:
.Ip ** 8 2
指数演算子。
.Ip **= 8
指数代入演算子。
.Ip (\|) 8 3
配列をヌルに初期化するために使う、ヌルリスト。
.Ip . 8
2 つの文字列の結合演算子。
.Ip .= 8
結合代入演算子。
.Ip eq 8
文字列の同値性 (== は数値の同値性) 。
覚えるためには、\*(L"eq\*(R" が文字列であると考えれば良いです。
(状況に応じて、== が文字列と数値の両方の同値性を表す
.I awk
に慣れている人は、ここでは明示しなければならないことに気をつけて下さい !)
.Ip ne 8
文字列の非同値性 (!= は数値の非同値性) 。
.Ip lt 8
文字列の less than
.Ip gt 8
文字列の greater than
.Ip le 8
文字列の less than or equal
.Ip ge 8
文字列の greater than or equal
.Ip cmp 8
文字列の比較。 -1, 0, 1 を返します。
.Ip <=> 8
数値の比較。 -1, 0, 1 を返します。
.Ip =~ 8 2
演算には、検索、変更をデフォルトで文字列 \*(L"$_\*(R" に対して行うもの
があります。
この演算子を用いると、別の文字列に対してその演算が行われます。
右の引数は、検索パターン、置換、変換です。
左の引数は、デフォルトの \*(L"$_\*(R" の代わりに検索、置換、変換が
行なわれる対象となるものです。
戻り値は、演算の成否を示します。
(右の引数が検索パターン、置換、変換以外の式なら、実行時に検索パターン
として解釈されますが、パターンは式が評価される度にコンパイルされなけれ
ばならないので、明示的な検索より効率的ではありません。)
この演算子の優先度は単項マイナス演算子 (-) 、autoincrement/decrement
(++, --) より低く、他のどの演算子よりも高くなります。
.Ip !~ 8
戻り値が否定されることを除いて =~ と同じです。
.Ip x 8
繰り返し演算子。
左オペランドを右オペランドで指定した回数だけ繰り返した文字列を返します。
配列のコンテキストでは、左オペランドが括弧に入ったリストの場合、
リストを繰り返します。
.nf

	print \'\-\' x 80;		# ダッシュの列を出力します
	print \'\-\' x80;		# 不正、x80 は識別子

	print "\et" x ($tab/8), \' \' x ($tab%8);	# タブに変換

	@ones = (1) x 80;		# 80 個 1 が並んだ配列
	@ones = (5) x @ones;		# 全要素を 5 にセット

.fi
.Ip x= 8
繰り返し代入演算子。
スカラに対してのみ動作します。
.Ip .\|. 8
範囲演算子。コンテキストによって、実際は二つの異なる演算子になります。
配列のコンテキストでは、左の値から右の値まで一つずつ数を増やした配列を
返します。
これは、\*(L"for (1..10)\*(R" というループや配列の切り出し (slice) を
行なうときに便利です。
.Sp
スカラのコンテキストでは、.\|. は論理値を返します。
この演算子は、flip-flop のように二つの値を取り、
sed や awk やいろいろなエディタの行範囲 (comma) 演算子をエミュレート
します。
各 .\|. 演算子はそれ自身の論理値を保持し、左のオペランドが偽である限り
偽となります。
左のオペランドが真になると、範囲演算子は、右のオペランドが真になるまで
真となります。その後、範囲演算子が再び偽となります。
(次に範囲指定演算子が評価されるまで、偽にはなりません。
真になったのと同じ評価を行った時 (awkと同様) に右のオペランドをテスト
して、偽になることがあり得ますが、一度は真を返します。
次の評価まで右のオペランドをテストしたくなければ (sed のように) 、二つ
にするかわりに三つのドット (.\|.\|.) を使って下さい。)
右のオペランドは、演算子が \*(L"偽\*(R" の状態である間は、
評価されず、左のオペランドは演算子が \*(L"真\*(R" である間は
評価されません。
|| や && より優先度はやや低くなります。
戻り値は、偽ではヌル文字列に、真では (1で始まる) 連続した数に
なります。
この数は、範囲指定毎にリセットされます。
連続した範囲の最後の数は、文字列 \'E0\' を持っていて、数値には影響しま
せんが、終点を除きたい場合に検索のきっかけになります。
数字が 1 より大きくなるのを待つことで、始点を除くことができます。
スカラ .\|. の両方のオペランドが静的である場合、オペランドは暗黙の
うちに現在の行番号を表す $. 変数と比べられます。
例:
.nf

.ne 6
スカラ演算子としては:
    if (101 .\|. 200) { print; }	# 100行台を出力します

    next line if (1 .\|. /^$/);	# ヘッダ行を読み飛ばします

    s/^/> / if (/^$/ .\|. eof());	# 本体をクォートします

.ne 4
配列としては:
    for (101 .\|. 200) { print; }	# $_ を 100回表示します

    @foo = @foo[$[ .\|. $#foo];	# 高価なノーオペレーション
    @foo = @foo[$#foo-4 .\|. $#foo];	# 最後の 5 要素を取り出します

.fi
.Ip \-x 8
ファイルテスト。
この単項演算子は一つの引数として、ファイル名またはファイルハンドルを取
り、そのファイルについて、何かが真であるかどうかを見るものです。
引数が省略されると、$_ を調べますが、例外として \-t は
.IR STDIN
を調べます。
真の場合は 1 を、偽の場合は \'\' を返し、ファイルが存在していない場合
は、undefined の値を返します。
優先度は、論理値や関係演算子より高くなりますが、算術演算子より低くなり
ます。
演算子は以下の通りです:
.nf
	\-r	ファイルを実効 uid/gid で読み込める。
	\-w	ファイルに実効 uid/gid で書き込める。
	\-x	ファイルを実効 uid/gid で実行できる。
	\-o	ファイルの所有者が、実効 uid である。
	\-R	ファイルを実 uid/gid で読み込める。
	\-W	ファイルを実 uid/gid で書き込める。
	\-X	ファイルを実 uid/gid で実行できる。
	\-O	ファイルの所有者が、実 uid である。
	\-e	ファイルが存在する。
	\-z	ファイルサイズが 0 である。
	\-s	ファイルサイズが 0 でない (サイズを返す) 。
	\-f	ファイルはプレーンファイルである。
	\-d	ファイルはディレクトリである。
	\-l	ファイルはシンボリックリンクである。
	\-p	ファイルは名前付きパイプ (FIFO) である。
	\-S	ファイルはソケットである。
	\-b	ファイルはブロック特殊ファイルである。
	\-c	ファイルはキャラクタ特殊ファイルである。
	\-u	ファイルには setuid ビットが立っている。
	\-g	ファイルには setgid ビットが立っている。
	\-k	ファイルには sticky ビットが立っている。
	\-t	ファイルハンドルが tty にオープンされている。
	\-T	ファイルはテキストファイルである。
	\-B	ファイルはバイナリファイルである (\-T の逆) 。
	\-M	スクリプトを開始した時点でのファイルの古さ(単位は日) 。
	\-A	アクセス時刻と同じ。
	\-C	inode 変更時刻と同じ。

.fi
ファイルパーミッション演算子 \-r, \-R, \-w, \-W, \-x, \-X の解釈は、
単にファイルのモードとユーザの uid, gid に基づきます。
他の理由で、実際にファイルを読み、書き、実行ができないことがあるかも
しれません。
また、気をつけなけらばならないのは、スーパユーザにとって
\-r, \-R, \-w, \-W は常に 1 を返し、そのモードでいずれかの実行ビットが
立っていれば、\-x, \-X も常に 1 を返すというところです。
従って、スーパユーザが実行するスクリプトは、ファイルの実際のモードを決
めるために stat() を実行したり、一時的に他の uid を立てる必要があるか
もしれません。
.Sp
例:
.nf
.ne 7
	
	while (<>) {
		chop;
		next unless \-f $_;	# 特殊ファイルを無視
		.\|.\|.
	}

.fi
\-s/a/b/ としても、否定した置換をするわけではないことに注意して
下さい。
\-exp($foo) とすると、期待通りに動きますが、\*(-- マイナスの後が一文字
の場合、ファイルテストと解釈されます。
.Sp
\-T と \-B は以下のように動作します。
ファイルの先頭のブロックあたりに、変なコントロールコードや
メタキャラクタのような、おかしな文字がないかどうかを調べます。
おかしな文字が (10%以上) 見つかると、それは \-B ファイル、
でなければ \-T ファイルとなります。
最初のブロックにヌルが含まれるファイルもバイナリファイルとみなされます。
\-T や \-B がファイルハンドルに使われると、最初のブロックではなく、
そのときの標準入力バッファが調べられます。
ヌルファイル(サイズ 0 のファイル)の場合やファイルハンドルをテストしていて
、それが EOF である場合、\-T と \-B は共に真を返します。
.PP
すべてのファイルテスト (と stat 演算子)は、アンダライン一つ _ から
成る特殊ファイルハンドルを与えられると、システムコールを保存することに
よって、その直前に行なわれたファイルテスト (または stat演算子) で使わ
れた stat 構造体が使われます。
(この _ の働きは \-t では動作せず、lstat と -l が stat 構造体に
実ファイルではなく、シンボリックリンクの値を残すことを覚えて
おかなければなりません。)
例:
.nf

	print "Can do.\en" if -r $a || -w _ || -x _;

.ne 9
	stat($filename);
	print "Readable\en" if -r _;
	print "Writable\en" if -w _;
	print "Executable\en" if -x _;
	print "Setuid\en" if -u _;
	print "Setgid\en" if -g _;
	print "Sticky\en" if -k _;
	print "Text\en" if -T _;
	print "Binary\en" if -B _;

.fi
.PP
C にあって、
.I perl
にないもの:
.Ip "単項 &" 12
アドレス演算子
.Ip "単項 *" 12
"アドレスを通しての"参照演算子
.Ip "(TYPE)" 12
型変換演算子。
.PP
C のように、
.I perl
は、演算子への引数が皆、静的で、副作用がない場合だけコンパイル時にある
程度の式の評価を行なってしまいます。
特に、変数置換を行なわないリテラル間での文字列の結合は、コンパイル時に
行なわれます。
バックスラッシュの解釈もコンパイル時に起こります。
.nf

.ne 2
	\'Now is the time for all\' . "\|\e\|n" .
	\'good men to come to.\'

.fi
これは全部、内部では一つの文字列にされてしまいます。
.PP
++ 演算子にはちょっと拡張した細工が施されています。
数値変数や数値コンテキストとして使われた変数をインクリメントすると、通
常のインクリメントになりますが、変数がヌルでない文字コンテキストとして
だけ使われて来ていて、パターン /^[a\-zA\-Z]*[0\-9]*$/ にマッチする場合は、
各文字の範囲をキャリー付きで保存し、文字としてインクリメントされます:
.nf

	print ++($foo = \'99\');	# prints \*(L'100\*(R'
	print ++($foo = \'a0\');	# prints \*(L'a1\*(R'
	print ++($foo = \'Az\');	# prints \*(L'Ba\*(R'
	print ++($foo = \'zz\');	# prints \*(L'aaa\*(R'

.fi
-- 演算子には、このような細工はありません。
.PP
(配列のコンテキストにおける) 範囲演算子は、最大値と最小値が文字列の
場合に、細工した自動インクリメントアルゴリズムを使います。
すべてのアルファベット文字を得るには、

	@alphabet = (\'A\' .. \'Z\');

16 進数を得るには、

	$hexdigit = (0 .. 9, \'a\' .. \'f\')[$num & 15];

始めに 0 を付けた日付を得るには、

	@z2 = (\'01\' .. \'31\');  print @z2[$mday];

と書けます。
(最後に指定された値が、細工したインクリメントの生成するシークエンスに
含まれていない場合、次の値が最後に指定された値より長くなるまでシークエ
ンスを続けます。)
.PP
|| と && は、0 や 1 を返す C のそれとは違って、最後に評価された値を
返します。
だから、ホームディレクトリをみつける移植性の高い方法は、こうなります。
.nf

	$home = $ENV{'HOME'} || $ENV{'LOGDIR'} ||
	    (getpwuid($<))[7] || die "You're homeless!\en";

.fi
.PP
前述のリテラルや変数に合わせ、以降の節で説明する演算は
式中で項として使えます。
これらの演算の幾つかは、引数に*リスト*を取ります。
リストは、スカラや配列値からなります。
配列値がリストの中にあると、その場所に挿入されたように個々の値がリスト
の中に含まれて、長い一次元配列値を作ることになります。
*リスト* の要素はコンマで区切られていなければなりません。
引数を括弧で囲んでも囲まなくても、演算をリスト出来ます。
これは関数呼び出しと同様単項演算子として、
演算を使うことができることを意味します。
関数呼び出しとして使うには、同じ行の次のトークンは左括弧でなければなり
ません。
(空白が間にはさまってもかまいません。)
そのような関数は、予想される通り最優先となります。
左括弧を持っていないトークンが続くとすれば、それは単項演算子で、リスト
演算子かどうかによって、優先度が決まります。
リスト演算子は最も優先度が低くなります。
すべての単項演算子は、関係演算子よりも優先されますが、算術演算子よりも
優先度は低くなります。
優先度のセクションを参照して下さい。
.PP
スカラや配列のコンテキストで使われる演算子の場合、失敗すると一般に、
スカラコンテキストでは undefined 値を返し、配列のコンテキストでは
ヌルリストを返します。
しかし、*リストをスカラに変換する一般的な規則はない* ということを
忘れないで下さい。
それぞれの演算子は、どの種のスカラを返すのが最も適当であるかを決めます。
ある演算子は、配列のコンテキストとして返されるようなリストの長さを返し
ます。リストの最初の値を返す演算子、リストの最後の値を返す演算子、
操作に成功した回数を返す演算子などもあります。
一般に、一貫性を求めなければ、演算子は求めるものを返します。
.Ip "/PATTERN/" 8 4
m/PATTERN/ を参照して下さい。
.Ip "?PATTERN?" 8 4
これは、
.I reset
演算子呼び出しの間で一回しかマッチしないことを除けば、
/pattern/ 検索と全く同じです。
これは例えば、一群のファイルの中で、各ファイルに最初に何かが出現すること
を見たいとき、便利な最適化です。
そのときのパッケージにローカルな ?? パターンだけは、リセットされます。
.Ip "accept(NEWSOCKET,GENERICSOCKET)" 8 2
accept システムコールと同じことをします。
成功すると真を、失敗すると偽を返します。
プロセス間通信のセクションの例を参照して下さい。
.Ip "alarm(SECONDS)" 8 4
.Ip "alarm SECONDS" 8
指定した秒数 (実際には、1 を引いたもの) が経過したあと、自分の
プロセスに SIGALRM を伝えます。
つまり、alarm(15) なら、14 秒以上経ったある時点で SIGALRM を生じます。
一度に一つのタイマしかカウントされません。呼び出される毎にそれ以前の
タイマは無効となり、引数 0 で呼び出すと以前のタイマをキャンセルし
て、新しいタイマは始動しません。
戻り値は、直前のタイマの残り時間です。
.Ip "atan2(Y,X)" 8 2
Y/X の アークタンジェント を
.if t \-\(*p から \(*p.
.if n \-π から π
の範囲で返します。
.Ip "bind(SOCKET,NAME)" 8 2
bind システムコールと同じことをします。
成功すれば真を、失敗すれば偽を返します。
NAME は、ソケットに合った適切な型の pack されたアドレスでなければなりません。
プロセス間通信のセクションの例を参照して下さい。
.Ip "binmode(FILEHANDLE)" 8 4
.Ip "binmode FILEHANDLE" 8 4
バイナリファイルとテキストファイルを区別するオペレーティングシステム上
で、そのファイルを \*(L"バイナリ\*(R" として読み込まれるようにします。
バイナリモードで読み込まれないファイルは、CR LF が入力時に LF に変換
され、出力時には、LF が CR LF に変換されます。
binmode は、UNIX では無効です。
FILEHANDLE が式のときは、値がファイルハンドルの名前として扱われます。
.Ip "caller(EXPR)"
.Ip "caller"
現在のサブルーチン呼び出しのコンテキストを返します:
.nf

	($package,$filename,$line) = caller;

.fi
EXPRがあると、デバッガがスタックトレースに出力して使う拡張情報も
返します。
EXPRの値は、現在のサブルーチンの前にいくつの call フレームがあるかを
示します。
.Ip "chdir(EXPR)" 8 2
.Ip "chdir EXPR" 8 2
動作しているディレクトリを、もしできるなら EXPR に変更します。
EXPRが省略されると、ホームディレクトリになります。
成功すれば 1 を、失敗すれば 0 を返します。
.IR die
の例を参照して下さい。
.Ip "chmod(LIST)" 8 2
.Ip "chmod LIST" 8 2
ファイルのリストのパーミッションを変更します。
リストの最初の要素は、数値モードでなければなりません。
成功したファイルの数を返します。
.nf

.ne 2
	$cnt = chmod 0755, \'foo\', \'bar\';
	chmod 0755, @executables;

.fi
.Ip "chop(LIST)" 8 7
.Ip "chop(VARIABLE)" 8
.Ip "chop VARIABLE" 8
.Ip "chop" 8
文字列の最後の文字を削り、削られた文字を返します。
基本的には、入力されたレコードの終りから改行文字を除くために使われます
が、文字列のコピーをスキャンするわけではないので、s/\en// より
効率的です。
VARIABLE を省略すると、$_ を chop します。
例:
.nf

.ne 5
	while (<>) {
		chop;	# 最後のフィールドの \en を除く
		@array = split(/:/);
		.\|.\|.
	}

.fi
実際には、代入を含む左辺値のいかなるものも chop できます。
.nf

	chop($cwd = \`pwd\`);
	chop($answer = <STDIN>);

.fi
リストを chop するとすべての要素が chop され、
最後に chop された値が返されます。
.Ip "chown(LIST)" 8 2
.Ip "chown LIST" 8 2
ファイルのリストの所有者 (と所有グループ) を変えます。
リストの最初の二つの要素は数値で表した uid と gid がこの順で指定され
なければなりません。
変更に成功したファイルの数を返します。
.nf

.ne 2
	$cnt = chown $uid, $gid, \'foo\', \'bar\';
	chown $uid, $gid, @filenames;

.fi
.ne 23
以下は、passwd ファイルから数値でない uid を検索する例です:
.nf

	print "User: ";
	$user = <STDIN>;
	chop($user);
	print "Files: "
	$pattern = <STDIN>;
	chop($pattern);
.ie t \{\
	open(pass, \'/etc/passwd\') || die "Can't open passwd: $!\en";
'br\}
.el \{\
	open(pass, \'/etc/passwd\')
		|| die "Can't open passwd: $!\en";
'br\}
	while (<pass>) {
		($login,$pass,$uid,$gid) = split(/:/);
		$uid{$login} = $uid;
		$gid{$login} = $gid;
	}
	@ary = <${pattern}>;	# ファイルを得ます
	if ($uid{$user} eq \'\') {
		die "$user not in passwd file";
	}
	else {
		chown $uid{$user}, $gid{$user}, @ary;
	}

.fi
.Ip "chroot(FILENAME)" 8 5
.Ip "chroot FILENAME" 8
同名のシステムコールと同じことをします。
これが何をするのか知らないとしても、気にしないで下さい。
FILENAME を省略すると、$_ に chroot します。
.Ip "close(FILEHANDLE)" 8 5
.Ip "close FILEHANDLE" 8
ファイルハンドルに結びつけられたファイルやパイプをクローズします。
別のファイルをオープンしようとしている場合は、FILEHANDLE を閉じる
必要がありません。オープンした際に前のファイルをクローズしてくれる
からです。
(
.IR open
を参照して下さい)
しかし、明示的に入力ファイルのクローズをすると行カウンタ ($.) が
リセットされるのに対し、
.I open
のときに行なわれる暗黙のクローズでは、リセットされません。
また、後でパイプの出力を見たい場合は、パイプをクローズするとパイプで
起動されたプロセスの完了を待ちます。
パイプを明示的にクローズすると、コマンド情報の戻り値が $? に
入れられます。
例:
.nf

.ne 4
	open(OUTPUT, \'|sort >foo\');	# sort へパイプ
	.\|.\|.	# print stuff to output
	close OUTPUT;		# sort の終了を待ちます
	open(INPUT, \'foo\');	# sortの結果を得ます

.fi
FILEHANDLE は実際のファイルハンドル名を与える式でもかまいません。
.Ip "closedir(DIRHANDLE)" 8 5
.Ip "closedir DIRHANDLE" 8
opendir() でオープンされたディレクトリをクローズします。
.Ip "connect(SOCKET,NAME)" 8 2
connect システムコールと同じことをします。
成功すると真を、失敗すると偽を返します。
NAME はソケットに合った適当な型のパッケージアドレスでなければ
なりません。
プロセス間通信のセクションの例を参照して下さい。
.Ip "cos(EXPR)" 8 6
.Ip "cos EXPR" 8 6
EXPR (ラジアンで表現) のコサインを返します。
EXPR を省略すると $_ のコサインを取ります。
.Ip "crypt(PLAINTEXT,SALT)" 8 6
C ライブラリの crypt() 関数と正確に同じように encrypt された文字列
を返します。
パスワードファイルを調べて、粗野なパスワードを見つけるのに便利です。
白い帽子をかぶっている奴だけがこれをしなければなりません。
.Ip "dbmclose(ASSOC_ARRAY)" 8 6
.Ip "dbmclose ASSOC_ARRAY" 8
dbm ファイルと連想配列の結び付きを解除します。
連想配列に残っている値は、dbm ファイルのキャッシュに何が入っているか
を知りたいのでなければ、意味がないものとなります。
この関数は、ndbm を使う場合にのみ有用です。
.Ip "dbmopen(ASSOC,DBNAME,MODE)" 8 6
dbm や ndbm ファイルと連想配列を結び付けます。
ASSOC は連想配列の名前です。
(通常の open と違って、最初の引数はファイルハンドルのように見えても、
ファイルハンドルでは*ありません*) 。
DBNAME は、(.dir や .pag の拡張子を除いた) データベースの名前です。
データベースが存在しないと、(umaskで修飾された) MODE で指定された
プロテクションで作成します。
古い dbm 関数しかサポートしないシステムでは、プログラムの中で一つの 
dbmopen しか許されないかもしれません。
dbm も ndbm もないシステムでは、dbmopen 呼び出しは致命的なエラーを生
じます。
.Sp
それまでの dbmopen で関連付けられた連想配列の値は失われます。
dbm ファイルのうち、ある量の値はメモリにキャッシュされます。
デフォルトでその量は 64 ですが、dbmopen の前に連想配列の
ガーベッジエントリの数をあらかじめ確保しておくことで、
増やすことができます。必要なら、reset コマンドでキャッシュを
フラッシュすることができます。
.Sp
dbm ファイルへの書き込み許可を持っていない場合、連想配列変数を
読み出すだけで、それをセットすることはできません。
書き込めるかどうかをテストしたければ、ファイルテストを使うか、エラーを
トラップできる eval の中で、ダミーの配列エントリをセットしようと
してみて下さい。
.Sp
keys() や valuse() のような関数は、大きな dbm ファイルを使ったときに、
巨大な配列値を返すかもしれません。
大きな dbm ファイルで繰り返しをするときは、each() 関数を使った方が
良いかもしれません。
例:
.nf

.ne 6
	# 履歴ファイルのオフセットを表示します
	dbmopen(HIST,'/usr/lib/news/history',0666);
	while (($key,$val) = each %HIST) {
		print $key, ' = ', unpack('L',$val), "\en";
	}
	dbmclose(HIST);

.fi
.Ip "defined(EXPR)" 8 6
.Ip "defined EXPR" 8
左辺値 EXPR が、実際に値を持っているかどうかを表す論理値を返します。
多くの演算で、ファイル終端、初期化されていない変数、システムエラーなど
の例外処理条件で undefined 値が返されます。
この関数は、本当のヌル文字列を返すかもしれない操作、特に配列要素を参照
する操作の際に、未定義のヌル文字列と定義されたヌル文字列の判別を可能に
します。
配列やサブルーチンが存在するかどうかを調べることもできます。
予約済み変数を使うときは、直観的に期待するような結果になるとは保証されて
いません。
例:
.nf

.ne 7
	print if defined $switch{'D'};
	print "$val\en" while defined($val = pop(@ary));
	die "Can't readlink $sym: $!"
		unless defined($value = readlink $sym);
	eval '@foo = ()' if defined(@foo);
	die "No XYZ package defined" unless defined %_XYZ;
	sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }

.fi
undef も参照して下さい。
.Ip "delete $ASSOC{KEY}" 8 6
指定した連想配列から、指定した値を削除します。
削除された値が返りますが、何も削除されなかった場合は undefined 値が
返ります。
$ENV{} から削除すると、環境変数を変更します。
dbm ファイルに結びつけられた配列を削除すると、dbm ファイルからその項
目を削除します。
.Sp
以下の例は、連想配列のすべての値を削除します:
.nf

.ne 3
	foreach $key (keys %ARRAY) {
		delete $ARRAY{$key};
	}

.fi
(しかし、
.I reset
コマンドを使った方が速いでしょう。undef %ARRAY ならもっと速いでしょう)
.Ip "die(LIST)" 8
.Ip "die LIST" 8
eval の外で、LIST の値を
.I STDERR
に表示して、そのときの $! (errno) の値で終了 (exit) します。
$! が 0 なら、($? >> 8) (\`command\` のステータス) の値で終了します。
($? >> 8) が 0 なら、255 で終了します。
eval の中では、エラーメッセージは $@ に詰め込まれ、eval は undefined 
値で終了します。
.Sp
同等の例:
.nf

.ne 3
.ie t \{\
	die "Can't cd to spool: $!\en" unless chdir \'/usr/spool/news\';
'br\}
.el \{\
	die "Can't cd to spool: $!\en"
		unless chdir \'/usr/spool/news\';
'br\}

	chdir \'/usr/spool/news\' || die "Can't cd to spool: $!\en" 

.fi
.Sp
EXPR の値が改行で終らない場合、スクリプトの現在の行番号と (もしあれば) 
入力行番号が出力され、改行が加えられます。
ヒント: \*(L", stopped\*(R" をメッセージに加えておくと、
\*(L"at foo line 123\*(R" が加えられたときにわかり易くなるので良い
でしょう。
スクリプト \*(L"canasta\*(R" を走らせているとすると、
.nf

.ne 7
	die "/etc/games is no good";
	die "/etc/games is no good, stopped";

は、多分

	/etc/games is no good at canasta line 123.
	/etc/games is no good, stopped at canasta line 123.

.fi
と出力されます。
.IR exit
を参照して下さい。
.Ip "do BLOCK" 8 4
BLOCK 内で指定されたうち、最後のコマンドの値を返します。
ループ修飾子に修飾されたときは、ループ条件をテストする前に BLOCK が
一度実行されます。
(他の文では、ループ修飾子は、条件を始めにテストします。)
.Ip "do SUBROUTINE (LIST)" 8 3
.I sub
で宣言されたサブルーチンを実行し、SUBROUTINE で最後に評価された式の値
を返します。
その名前のサブルーチンがない場合、致命的エラーを生じます。
(サブルーチンが存在しているかどうかを判定したいなら、\*(L"defined\*(R" 
演算子を使うのが良いでしょう。)
配列をリストの一部として渡したいなら、各配列の前に配列の長さを付けて
渡すのが良いでしょう。
(後に出てくるサブルーチンのセクションを参照して下さい。)
\*(L"do EXPR\*(R" の形との混乱を避けるため、括弧は必要となります。
.Sp
SUBROUTINE は、一つのスカラ変数でもかまいません。その場合、
実行されるサブルーチン名は、変数から得られます。
.Sp
別の (好まれる) 形として、アンパサンド & を前に付ける &foo(@args) の
ように、サブルーチンを呼んでもかまいません。
引数を渡さないなら、括弧を使う必要はありません。
括弧を省略すると、サブルーチンには @_ 配列は渡されません。
& 型は、defined や undef 演算子にサブルーチンを指示するのにも
使われます:
.nf

	if (defined &$var) { &$var($parm); undef &$var; }

.fi
.Ip "do EXPR" 8 3
ファイル名として EXPR の値を使い、
.I perl
スクリプトとして、ファイルの内容を実行します。
これは基本的に
.I perl
サブルーチンライブラリからサブルーチンをインクルードするという使い方を
します。
.nf

	do \'stat.pl\';

は、

	eval \`cat stat.pl\`;

.fi
とほとんど同じです。
違うのは、より効率的で、より簡潔で、エラーメッセージ中の現在ファイル名
は正しく、カレントディレクトリに stat.pl がなければ
.B \-I
で指定されたライブラリをすべて探すということです。
(予約変数のセクション中の @INC 配列を参照して下さい) 。
しかし、呼び出しのたびにファイルを解析し直すのは同じなので、ループの
内側でこのファイルを使うなら、起動時間は少し余計にかかるとしても、
\-P と #include を使った方が良いでしょう。
(この #include を使う問題点は、cpp が # コメントを認識してくれない
ことです。\*(--逃げ道は、コメント単独として \*(L";#\*(R" を使うことです。)
次のものは等価ではないことに注意して下さい:
.nf

.ne 2
	do $foo;	# ファイルを eval します
	do $foo();	# サブルーチンを呼びます

.fi
ライブラリルーチンのインクルードとしては、
\*(L"require\*(R" 演算子の方がより良いことを覚えておいて下さい。
.Ip "dump LABEL" 8 6
ただちにコアダンプします。
もともと、これは、プログラムの始めにすべての変数を初期化した後に
ダンプされたコアを undump プログラムを使って実行バイナリを作るために
あります。
新しいバイナリが実行されるとき、"goto LABEL" を実行することから
始まります
(goto が受けるすべての制限は適用されます) 。
コアダンプで止まったところから、goto で再び始まると考えれば良いです。
LABEL が省略されると、プログラムは先頭から再スタートします。
警告: ダンプされたときに open されていたどのファイルも、プログラムが
再生したときにはもう open されておらず、perlの側では混乱する可能性が
あります。
\-u も参照して下さい。
.Sp
例:
.nf

.ne 16
	#!/usr/bin/perl
	require 'getopt.pl';
	require 'stat.pl';
	%days = (
	    'Sun',1,
	    'Mon',2,
	    'Tue',3,
	    'Wed',4,
	    'Thu',5,
	    'Fri',6,
	    'Sat',7);

	dump QUICKSTART if $ARGV[0] eq '-d';

    QUICKSTART:
	do Getopt('f');

.fi
.Ip "each(ASSOC_ARRAY)" 8 6
.Ip "each ASSOC_ARRAY" 8
連想配列の次のキーと値の 2 つの要素から成る配列を順次返し、
それを繰り返すことができます。
各エントリはランダムのように見える順序で返されます。
配列全部が読み込まれたとき、ヌル配列 (代入されると FALSE(0) 値となる)
が返されます。
その後、次の each() の呼び出しで繰り返しを再び始めます。
繰り返し情報は、配列からすべての要素を読み込むことによってのみ
リセットできます。
繰り返しの間は、配列を変更してはいけません。
各連想配列につき一つずつ繰り返し情報があり、プログラム中のすべての
each(), keys(), values() 関数呼び出しで共有されます。
次の例は、順序は異なるものの printenv プログラムのように環境変数を
表示します:
.nf

.ne 3
	while (($key,$value) = each %ENV) {
		print "$key=$value\en";
	}

.fi
keys() 関数と values() 関数も参照して下さい。
.Ip "eof(FILEHANDLE)" 8 8
.Ip "eof()" 8
.Ip "eof" 8
次に FILEHANDLE を読んだときファイル終端であるか、
または FILEHANDLE がオープンされていないとき、1 を返します。
FILEHANDLE は実際のファイルハンドル名を値に持つ式でもかまいません。
(この関数は、実際には一文字読み込んでは、ungetc するので、対話的な
コンテキストではそれほど有用ではありません。)
引数無しの eof は、最後に読んだファイルの eof 状態を返します。
空の括弧 () は、コマンドラインで指定されたファイル群からなる
擬似ファイルを指します。つまり、eof() は while (<>) の内側で最後の
ファイルの終端を検出するときに意味があります。
while (<>) ループの中で各ファイルを調べたいときは、eof(ARGV) または
括弧のない eof を使って下さい。
例:
.nf

.ne 7
	# 最後のファイルの最終行の直前にダッシュを挿入します
	while (<>) {
		if (eof()) {
			print "\-\|\-\|\-\|\-\|\-\|\-\|\-\|\-\|\-\|\-\|\-\|\-\|\-\|\-\en";
		}
		print;
	}

.ne 7
	# 各入力ファイル毎に、行番号をリセットします
	while (<>) {
		print "$.\et$_";
		if (eof) {	# Not eof().
			close(ARGV);
		}
	}

.fi
.Ip "eval(EXPR)" 8 6
.Ip "eval EXPR" 8 6
.Ip "eval BLOCK" 8 6
EXPR は解析され、一つの小さな
.I perl
プログラムであるかのように実行されます。
.I perl
プログラムのコンテキストの中で実行されるので、どの変数設定、
サブルーチン、フォーマット定義もその後に残ります。
戻り値は、丁度サブルーチンと同様に、最後に評価された式が返ります。
文法エラーや実行時エラーがあるか、die 文があれば、eval により undefined 
が返り、$@ にエラーメッセージがセットされます。
もしエラーがなければ、$@ はヌル文字列であることが保証されます。
EXPRを省略すると、$_ を評価します。
最後のセミコロンはどれも式から除かれます。
.Sp
eval はしかし、致命的エラーまでトラップするので、
(dbmopen や symlinkのような) ある機能が実装されているかどうかを
決めるには便利なことを覚えておいて下さい。
die 演算子が例外を起こすように使われるのは、perl の例外トラップ機構
でもあります。
.Sp
実行されるコードが変わらないなら、その度に再コンパイルされる時間を
費すよりは、実行時エラーをトラップする eval-BLOCK の形をとった方が良い
かもしれません。
どんなエラーも起これば $@ にメッセージが返ります。
EXPR のような、シングルクォートされた文字列を評価すると、同じ効果が
ありますが、eval-BLOCK の形ではコンパイル時に文法エラーを報告するのに
対し、eval-EXPR の形では $@ を通して実行時に文法エラーを報告する点が
異なります。
eval-EXPR の形は、最初に成功したときに eval-BLOCK に最適化されます。
(e 修飾子を使った場合、置換される側はシングルクォートされた文字列と
みなされ、同じ最適化が起こります。)
例:
.nf

.ne 11
	# 0 除算を致命的エラーにしません
	eval { $answer = $a / $b; }; warn $@ if $@;

	# 初回使用後、同じものに最適化されます。
	eval '$answer = $a / $b'; warn $@ if $@;

	# コンパイル時エラー
	eval { $answer = };

	# 実行時エラー
	eval '$answer =';	# sets $@

.fi
.Ip "exec(LIST)" 8 8
.Ip "exec LIST" 8 6
LIST の中に一つ以上の引数があるか、LIST が一つ以上の値を持つ配列ならば、
リストの引数を付けて execvp() を呼びます。
一つのスカラ引数だけなら、引数にシェルのメタキャラクタがあるかどうか
を調べます。あれば、解析のために引数を丸ごと \*(L"/bin/sh \-c\*(R" に
渡し、無ければ、引数は単語に split され、execvp() に直接渡されます。
その方が効率が良いからです。
注意: exec (と system) は出力バッファをフラッシュしないので、出力が
失われるのを避けるために $| をセットする必要があるかもしれません。
例:
.nf

	exec \'/bin/echo\', \'Your arguments are: \', @ARGV;
	exec "sort $outfile | uniq";

.fi
.Sp
もし、最初の引数を本当に実行したいのでなく、実行しようとしている
プログラムの名前を詐称したいだけなら、本当に走らせたいプログラムを変数に
割り当てて、LIST の前に変数の名前をコンマを付けずに置くように
指定できます。
(これは、たとえ単一スカラしかリストに無くても、常に多くの値を持つ
リストとして LIST の解釈を強制します。)
例:
.nf

.ne 2
	$shell = '/bin/csh';
	exec $shell '-sh';		# ログインシェルのふりをします

.fi
.Ip "exit(EXPR)" 8 6
.Ip "exit EXPR" 8
EXPR を評価し、ただちにその値で終了します。
例:
.nf

.ne 2
	$ans = <STDIN>;
	exit 0 \|if \|$ans \|=~ \|/\|^[Xx]\|/\|;

.fi
.IR die
を参照して下さい。
EXPR が省略されると、値 0 の状態で終了します。
.Ip "exp(EXPR)" 8 3
.Ip "exp EXPR" 8
.I e
の EXPR 乗を返します。 EXPR を省略すると、exp($_) を返します。
.Ip "fcntl(FILEHANDLE,FUNCTION,SCALAR)" 8 4
fcntl(2) 関数の実装です。
正しい関数定義を得るには、多分
.nf

	require "fcntl.ph";	# 多分 /usr/local/lib/perl/fcntl.ph

.fi
を始めに書いておかなければならないでしょう。
もし、fcntl.ph が存在しないか、もしくは正しい定義がされていない場合、
<sys/fcntl.h> のような C のヘッダファイルに基づいて、
自分で何とかしなければなりません。 
(perl kit から来る h2ph と呼ばれる perl スクリプトがあり、
このことを助けてくれるでしょう)
引数の処理と戻り値を返すことは、
この後に書かれている ioctl のように動作します。
fcntl は、fcntl(2) が実装されていないマシンで使われると
致命的エラーを生じます。
.Ip "fileno(FILEHANDLE)" 8 4
.Ip "fileno FILEHANDLE" 8 4
ファイルハンドルに対するファイルディスクリプタを返します。
select() のビットマップを構成するのに便利です。
FILEHANDLE が式だと、その値がファイルハンドルの名前と解釈されます。
.Ip "flock(FILEHANDLE,OPERATION)" 8 4
ファイルハンドルに対し flock(2) を呼びます。
OPERATION の定義については、flock(2) のマニュアルを参照して下さい。
成功すれば真を、失敗すれば偽を返します。
flock(2) が実装されていないマシンで使うと、致命的エラーになります。
以下は、BSD システムのメールボックスにメールを追加します。
.nf

.ne 20
	$LOCK_SH = 1;
	$LOCK_EX = 2;
	$LOCK_NB = 4;
	$LOCK_UN = 8;

	sub lock {
	    flock(MBOX,$LOCK_EX);
	    # 待っている間に、他の誰かが追加する
	    # 場合のために...
	    seek(MBOX, 0, 2);
	}

	sub unlock {
	    flock(MBOX,$LOCK_UN);
	}

	open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
		|| die "Can't open mailbox: $!";

	do lock();
	print MBOX $msg,"\en\en";
	do unlock();

.fi
.Ip "fork" 8 4
fork() システムコールを実行します。
親プロセスに子の pid を返し、子プロセスには 0 を返します。 
注意: フラッシュされていないバッファは、両方のプロセスでフラッシュ
されずに残ります。これは二重出力を避けるために、$| をセットする必要が
あるかもしれないということを意味します。
.Ip "getc(FILEHANDLE)" 8 4
.Ip "getc FILEHANDLE" 8
.Ip "getc" 8
FILEHANDLE に結びつけられた入力ファイルから、次の文字を返します。
EOF ではヌルを返します。 FILEHANDLE を省略すると、STDIN から読み込み
ます。
.Ip "getlogin" 8 3
現在のログイン状況が /etc/utmp から得られれば、それを返します。
得られなければ、getpwuid を使って下さい。

	$login = getlogin || (getpwuid($<))[0] || "Somebody";

.Ip "getpeername(SOCKET)" 8 3
SOCKET 接続の向こう側の pack された sockaddr アドレスを返します。
.nf

.ne 4
	# 内部 sockaddr
	$sockaddr = 'S n a4 x8';
	$hersockaddr = getpeername(S);
.ie t \{\
	($family, $port, $heraddr) = unpack($sockaddr,$hersockaddr);
'br\}
.el \{\
	($family, $port, $heraddr) =
			unpack($sockaddr,$hersockaddr);
'br\}

.fi
.Ip "getpgrp(PID)" 8 4
.Ip "getpgrp PID" 8
指定された PID に対する現在のプロセスグループを返します。
現在のプロセスでは 0 です。
getpgrp(2) が実装されていないマシンで使うと、致命的エラーになります。
EXPR が省略されると、現在のプロセスのプロセスグループが返ります。
.Ip "getppid" 8 4
親プロセスのプロセス ID を返します。
.Ip "getpriority(WHICH,WHO)" 8 4
プロセス、プロセスグループ、ユーザの現在のプライオリティを返します。
(getpriority(2)を参照して下さい。)
getpriority(2) を実装していないマシンで使うと致命的エラーになります。
.Ip "getpwnam(NAME)" 8
.Ip "getgrnam(NAME)" 8
.Ip "gethostbyname(NAME)" 8
.Ip "getnetbyname(NAME)" 8
.Ip "getprotobyname(NAME)" 8
.Ip "getpwuid(UID)" 8
.Ip "getgrgid(GID)" 8
.Ip "getservbyname(NAME,PROTO)" 8
.Ip "gethostbyaddr(ADDR,ADDRTYPE)" 8
.Ip "getnetbyaddr(ADDR,ADDRTYPE)" 8
.Ip "getprotobynumber(NUMBER)" 8
.Ip "getservbyport(PORT,PROTO)" 8
.Ip "getpwent" 8
.Ip "getgrent" 8
.Ip "gethostent" 8
.Ip "getnetent" 8
.Ip "getprotoent" 8
.Ip "getservent" 8
.Ip "setpwent" 8
.Ip "setgrent" 8
.Ip "sethostent(STAYOPEN)" 8
.Ip "setnetent(STAYOPEN)" 8
.Ip "setprotoent(STAYOPEN)" 8
.Ip "setservent(STAYOPEN)" 8
.Ip "endpwent" 8
.Ip "endgrent" 8
.Ip "endhostent" 8
.Ip "endnetent" 8
.Ip "endprotoent" 8
.Ip "endservent" 8
これらのルーチンは、システムライブラリ中の同名の関数を実行します。
配列のコンテキストの中では、これらの各 get ルーチンの戻り値は、
以下のようになります:
.nf

	($name,$passwd,$uid,$gid,
	   $quota,$comment,$gcos,$dir,$shell) = getpw.\|.\|.
	($name,$passwd,$gid,$members) = getgr.\|.\|.
	($name,$aliases,$addrtype,$length,@addrs) = gethost.\|.\|.
	($name,$aliases,$addrtype,$net) = getnet.\|.\|.
	($name,$aliases,$proto) = getproto.\|.\|.
	($name,$aliases,$port,$proto) = getserv.\|.\|.

.fi
(もしエントリが存在しなければ、ヌルリストになります。)
.Sp
スカラのコンテキストでは、
name による検索でない場合には name が得られ、
name による検索の場合には name 以外が得られます。
(エントリが存在しない場合は、undefined 値となります。)
例:
.nf

	$uid = getpwnam
	$name = getpwuid
	$name = getpwent
	$gid = getgrnam
	$name = getgrgid
	$name = getgrent
	他

.fi
getgr.\|.\|. の返す $menbers 値は、空白で区切られたグループメンバの
ログイン名のリストです。
.Sp
gethost.\|.\|. 関数では、h_errno 変数が C でサポートされていれば、
関数のコールが失敗したとき $? を介して返されます。
成功した関数コールの返す @addrs 値は、相当するシステムライブラリ
呼び出しに返された raw address のリストです。
インターネットドメイン (INET) では、各アドレスは 4 バイト長で
以下のように書くと unpack できます。
.nf

	($a,$b,$c,$d) = unpack('C4',$addr[0]);

.fi
.Ip "getsockname(SOCKET)" 8 3
pack された、SOCKET接続のこちら側の sockaddr アドレスを返します。
.nf

.ne 4
	# An internet sockaddr
	$sockaddr = 'S n a4 x8';
	$mysockaddr = getsockname(S);
.ie t \{\
	($family, $port, $myaddr) = unpack($sockaddr,$mysockaddr);
'br\}
.el \{\
	($family, $port, $myaddr) =
			unpack($sockaddr,$mysockaddr);
'br\}

.fi
.Ip "getsockopt(SOCKET,LEVEL,OPTNAME)" 8 3
要求したソケットのオプションを返します。エラーの場合は undefined を
返します。
.Ip "gmtime(EXPR)" 8 4
.Ip "gmtime EXPR" 8
time 関数に返された時刻を、Greenwich timezone として 9 要素の配列に
変換します。
通常は次のように使います:
.nf

.ne 3
.ie t \{\
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime(time);
'br\}
.el \{\
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
						gmtime(time);
'br\}

.fi
すべての配列要素は数値で、構造体 tm から直接得られるものです。
これにより $mon は 0.\|.11 の範囲で $wday は 0.\|.6 の範囲であることに
なります。
EXPR を省略すると、gmtime(time) を実行します。
.Ip "goto LABEL" 8 6
LABEL というラベルを付けられた文を探し、そこから実行を再開します。
現在のところ、プログラムの本体内で do {} 構造の内側が
入れ子になっていない文にしか行けません。
この文は効率的には実装されておらず、
.IR sed -to- perl
翻訳プログラムを簡単にできるようにするためだけあります。
翻訳された
.I sed
スクリプトの一貫性のサポートはしますが、このセマンティックスを私がいつ
変更するかわからないので、自らの責任で使って下さい。
全く使わない方が良いでしょう。
.Ip "grep(EXPR,LIST)" 8 4
LIST の各要素に対して (ローカルには各要素を $_ にセット) 、EXPR を
評価して、式が真であると評価された要素だけからなる配列を返します。
スカラのコンテキストでは、式が真になった回数を数値で返します。
.nf

	@foo = grep(!/^#/, @bar);    # コメントを除きます

.fi
$_ は配列値への参照なので、配列の要素を変更する場合に使えることを
覚えておきましょう。
これは便利ですが、LIST が名前のついた配列でないと、おかしな結果を
引き起こすことになります。
.Ip "hex(EXPR)" 8 4
.Ip "hex EXPR" 8
10 進値 EXPR を 16 進文字列にして返します。
(0 または 0x で始まる文字列を解釈するなら、oct() を参照して下さい。)
EXPR を省略すると $_ を使います。
.Ip "index(STR,SUBSTR,POSITION)" 8 4
.Ip "index(STR,SUBSTR)" 8 4
STR の中で、POSITION かそれ以降に最初に SUBSTR が現れる位置を返します。
POSITION を省略すると、文字列の先頭から検索します。
戻り値は、0 か $[ 変数に設定されたものがベースになります。
SUBSTR がみつからないと、ベースから 1 を引いた値を返し、通常 \-1 に
なります。
.Ip "int(EXPR)" 8 4
.Ip "int EXPR" 8
EXPR の整数部を返します。
EXPR が省略されると、$_ を使います。
.Ip "ioctl(FILEHANDLE,FUNCTION,SCALAR)" 8 4
これは、ioctl(2) 関数を実装しています。
正しい関数定義を得るには、多分始めの方で
.nf

	require "ioctl.ph";	# 多分 /usr/local/lib/perl/ioctl.ph

.fi
と書かなければならないでしょう。
ioctl.ph が存在しないか、または正しく定義されていない場合、
<sys/ioctl.h> のような C のヘッダファイルから自分自身でなんとかしな
ければなりません。
(perl キットにある h2ph というスクリプトがこの助けになるでしょう。)
SCALAR は、FUNCTIONに依存して、参照または書き込みがされます。 
FUNCTION \*(--SCALAR の文字列値へのポインタは、実際の ioctl 呼び出しの
第 3 引数に渡されます。
(SCALAR が文字列値でなく数値であった場合、文字列値へのポインタでなく
数値そのものが渡されます。これが真であることを保証するには、このスカラを
使う前に 0 を加えて下さい。)
ioctl() に使われる構造体の値を扱うには、pack() 関数と unpack() 関数が
便利です。
次の例は、DEL に erase 文字をセットします。
.nf

.ne 9
	require 'ioctl.ph';
	$sgttyb_t = "ccccs";		# chars 4 個と short 1 個
	if (ioctl(STDIN,$TIOCGETP,$sgttyb)) {
		@ary = unpack($sgttyb_t,$sgttyb);
		$ary[2] = 127;
		$sgttyb = pack($sgttyb_t,@ary);
		ioctl(STDIN,$TIOCSETP,$sgttyb)
			|| die "Can't ioctl: $!";
	}

.fi
ioctl (と fcntl) の戻り値は以下の通りです:
.nf

.ne 4
	OS の戻り値:\h'|3i'perlの戻り値:
	  -1\h'|3i'  undefined 値
	  0\h'|3i'  文字列 "0 but true"
	  それ以外\h'|3i'  その数

.fi
このように、perl は成功時に真を、失敗時に偽を返しますが、
オペレーティングシステムから返される実際の値も簡単に判定することができます:
.nf

	($retval = ioctl(...)) || ($retval = -1);
	printf "System returned %d\en", $retval;
.fi
.Ip "join(EXPR,LIST)" 8 8
.Ip "join(EXPR,ARRAY)" 8
分割されている LIST や ARRAY の文字列を、フィールドセパレータとして
値 EXPR をはさんだ一つの文字列につなげて、その文字列を返します。
例:
.nf
    
.ie t \{\
    $_ = join(\|\':\', $login,$passwd,$uid,$gid,$gcos,$home,$shell);
'br\}
.el \{\
    $_ = join(\|\':\',
		$login,$passwd,$uid,$gid,$gcos,$home,$shell);
'br\}

.fi
.IR split
を参照して下さい。
.Ip "keys(ASSOC_ARRAY)" 8 6
.Ip "keys ASSOC_ARRAY" 8
名前のついた連想配列のすべてのキーからなる普通の配列を返します。
キーは、見かけ上ランダムな順で返されますが、values() 関数や each() 関数
(これによって連想配列は変更されません) が生成するものと同じ順になります。
以下は、環境変数を表示する別の方法です:
.nf

.ne 5
	@keys = keys %ENV;
	@values = values %ENV;
	while ($#keys >= 0) {
		print pop(@keys), \'=\', pop(@values), "\en";
	}

キーでソートすると:

.ne 3
	foreach $key (sort(keys %ENV)) {
		print $key, \'=\', $ENV{$key}, "\en";
	}

.fi
.Ip "kill(LIST)" 8 8
.Ip "kill LIST" 8 2
プロセスのリストにシグナルを送ります。
リストの最初の要素は、送られるシグナルでなければなりません。
シグナル送信に成功したプロセスの数を返します。
.nf

	$cnt = kill 1, $child1, $child2;
	kill 9, @goners;

.fi
シグナルが負の場合、プロセスの代わりにプロセスグループを kill します。
(System Vでは、負の \fIプロセス\fR 番号はプロセスグループも kill
しますが、互換性はありません。)
クォートでくくられたシグナル名も使えます。
.Ip "last LABEL" 8 8
.Ip "last" 8
.I last
コマンドは、(ループ内で使われるような) C の
.I break
文に似ていて、該当するループを直ちに終了します。
LABEL が省略されると、このコマンドは最も内側のループを抜けます。
.I continue
ブロックがあったとしても、実行されません:
.nf

.ne 4
	line: while (<STDIN>) {
		last line if /\|^$/;	# ヘッダが終ったら抜けます
		.\|.\|.
	}

.fi
.Ip "length(EXPR)" 8 4
.Ip "length EXPR" 8
EXPR の値の文字列長を返します。
EXPR を省略すると、$_ の長さを返します。
.Ip "link(OLDFILE,NEWFILE)" 8 2
OLDFILE にリンクされた NEWFILE を作成します。
成功すると 1 を、失敗すると 0 を返します。
.Ip "listen(SOCKET,QUEUESIZE)" 8 2
listen システムコールと同じことを行ないます。
成功すると真を、失敗すると偽を返します。
プロセス間通信のセクションの例を参照して下さい。
.Ip "local(LIST)" 8 4
閉じたブロック、サブルーチン、eval 、\*(L"do\*(R" に局所的な
変数リストを宣言します。
リストされたすべての要素は左辺値として妥当なものでなければなりません。
この演算子は、LIST 内のその時点での変数を隠れたスタックに保存し、
ブロックやサブルーチンや eval を抜けるときに戻すように動作します。
これは、呼ばれたサブルーチンもグローバル変数でなく、ローカル変数を
参照することを意味します。
そうしたければ、LIST に代入してローカル変数を初期化してもかまいません。
(初期値が特定の値として与えられていなければ、undefined 値として
生成されます。)
普通、これはサブルーチンのパラメータに名前をつけるのに使われます。
例:
.nf

.ne 13
	sub RANGEVAL {
		local($min, $max, $thunk) = @_;
		local($result) = \'\';
		local($i);

		# 多分 $thunk は $i を参照しています

		for ($i = $min; $i < $max; $i++) {
			$result .= eval $thunk;
		}

		$result;
	}

.ne 6
	if ($sw eq \'-v\') {
	    # グローバルな配列でローカルな配列を初期化します
	    local(@ARGV) = @ARGV;
	    unshift(@ARGV,\'echo\');
	    system @ARGV;
	}
	# @ARGV が元に戻されます

.ne 6
	# 一時的に digits という連想配列に追加をしています。
	if ($base12) {
		# (注意: これが効率的と言いたいわけではありません)
		local(%digits) = (%digits,'t',10,'e',11);
		do parse_num();
	}

.fi
local() は実行時のコマンドで、ループ終了時に全部を一度に開放するまでは、
ループを通るたびに実行され、毎回スタックを消費していきます。
.Ip "localtime(EXPR)" 8 4
.Ip "localtime EXPR" 8
time 関数に返された時刻を、ローカルタイムゾーンとして解析された 9 要素の
配列に変換します。
通常次のように使われます:
.nf

.ne 3
.ie t \{\
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
'br\}
.el \{\
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
						localtime(time);
'br\}

.fi
すべての配列要素は数字で、構造体 tm から直接得られたものです。
これにより $mon は 0.\|.11 の範囲で $wday は 0.\|.6 の範囲であることに
なります。
EXPR を省略すると、localtime(time) を実行します。
.Ip "log(EXPR)" 8 4
.Ip "log EXPR" 8
EXPR の (底が
.IR e
の) 対数を返します。
EXPR を省略すると、$_ の log を返します。
.Ip "lstat(FILEHANDLE)" 8 6
.Ip "lstat FILEHANDLE" 8
.Ip "lstat(EXPR)" 8
.Ip "lstat SCALARVARIABLE" 8
stat() 関数と同じことを実行しますが、シンボリックリンクでは指している
先のファイルの代わりにシンボリックリンク自身の状態を返します。
シンボリックリンクが実装されていないシステムでは、通常の stat を
実行します。
.Ip "m/PATTERN/gio" 8 4
.Ip "/PATTERN/gio" 8
パターンマッチに合う文字列を検索し、真 (1) か偽 (\'\') を
返します。
=~ や !~ を介した文字列の指定がなければ、文字列 $_ が検索されます。
(=~ で指定された文字列は、左辺値である必要はありません。
式の評価結果でもかまいませんが、=~ はどちらかというと優先度が高いことを
覚えておいて下さい。)
正規表現のセクションを参照して下さい。
.Sp
/ が区切り文字である場合、始めの \*(L'm\*(R' は省略可能です。\*(L'm\*(R' が
あると、英数字以外のどの文字でも区切りにできます。
これは、特に \*(L'/\*(R' を含む UNIX のパス名へのマッチに便利です。
最後の区切りの後にオプション文字 \*(L'i\*(R' が続くと、マッチングが
大文字小文字の区別なく行なわれます。
PATTERN は、スカラ変数への参照を含んでいてもよく、それはパターン検索
が評価される毎に挿入されます (パターンはリコンパイルされます) 。
( $) と $| は文字列終端のテストに見えるため、挿入は行なわれません。)
パターンを一度だけコンパイルさせたい場合は、後ろの区切り文字
の後に \*(L"o\*(R" を加えて下さい。
これにより、余分な実行時再コンパイルを避けられるので、挿入したい値が
スクリプトの動いている間中、変わらないときには便利です。
PATTERN がヌル文字に評価されたときは、最後に成功した正規表現が代わりに
使われます。
.Sp
配列値が必要なコンテキストで使われると、パターンマッチはパターンの中で
マッチした subexpression を括弧でくくったものすなわち、
($1, $2, $3.\|.\|.)
からなる配列を返します。
この場合、実際には $1, $2 等をセットは*せず*、
$+,  $`, $&, $' もセットしません。
マッチが失敗すると、ヌル配列が返ります。
マッチが成功しても括弧がないと、配列値 (1) が返ります。
.Sp
例:
.nf

.ne 4
    open(tty, \'/dev/tty\');
    <tty> \|=~ \|/\|^y\|/i \|&& \|do foo(\|);	# y なら foo を実行

    if (/Version: \|*\|([0\-9.]*\|)\|/\|) { $version = $1; }

    next if m#^/usr/spool/uucp#;

.ne 5
    # 恵まれない人の grep
    $arg = shift;
    while (<>) {
	    print if /$arg/o;	# 一度だけコンパイル
    }

    if (($F1, $F2, $Etc) = ($foo =~ /^(\eS+)\es+(\eS+)\es*(.*)/))

.fi
この最後の例は、$foo を最初の二語と残りに split し、三つのフィールド
を $F1 、$F2 、$Etc に代入します。
どれかの変数が代入された場合、すなわちパターンがマッチした場合、
この条件は真となります。
.Sp
\*(L"g\*(R" 修飾子は、グローバルパターンマッチの指定です\*(--つまり、
文字列の中でできるだけ多くのマッチを行ないます。
どのように振舞うかは、コンテキストに依存します。
配列のコンテキストでは、正規表現の中ですべての括弧にマッチした文字列の
リストを返します。括弧がなければ、パターン全体を囲む括弧があるか
のようにマッチした文字列すべてのリストを返します。
スカラのコンテキストでは、文字列を通してマッチする毎に*真*を返し、
マッチしなかったとき*偽*を返します。 (言いかえると、最後にテストした
場所を覚えていて、そこから再び検索を始めるということです。)
最後のマッチから文字列が変更されていないことを仮定しています。
マッチとマッチの間で文字列を変更することは、未定義な動作を引き起こす
かもしれません。
(実際には substr()を使って、全文字列の長さを変えずにその場で変更する
なら、できます。しかし、一般にはそういう変更は s///g を使うべきです。)
例:
.nf

	# 配列のコンテキスト
	($one,$five,$fifteen) = (\`uptime\` =~ /(\ed+\e.\ed+)/g);

	# スカラのコンテキスト
	$/ = ""; $* = 1;
	while ($paragraph = <>) {
	    while ($paragraph =~ /[a-z][\'")]*[.!?]+[\'")]*\es/g) {
		$sentences++;
	    }
	}
	print "$sentences\en";

.fi
.Ip "mkdir(FILENAME,MODE)" 8 3
FILENAME で指定されたディレクトリを、(umask で修飾された) MODE で指定
されたパーミッションで作成します。
成功すると 1 を、失敗すると 0 を返し、$! (errno) をセットします。
.Ip "msgctl(ID,CMD,ARG)" 8 4
System V IPC 関数の msgctl を呼びます。 CMD が &IPC_STAT なら、ARG は
返された msqid_ds 構造を保持する変数でなければなりません。
ioctl のように、エラーのときは undefined 値を、0 のとき
には "0 but true" を、でなければ実際の戻り値を返します。
.Ip "msgget(KEY,FLAGS)" 8 4
System V IPC 関数の msgget を呼びます。成功時はメッセージキュー ID を、
エラーが起これば undefined value を返します。
.Ip "msgsnd(ID,MSG,FLAGS)" 8 4
System V IPC 関数の msgsnd を呼び、メッセージ MSGS をメッセージキュー 
ID に送信します。 MSG は、pack("L", $type) で作られる long integer 
のメッセージ型で始めなければなりません。成功すれば真を、エラーが起こる
と偽を返します。
.Ip "msgrcv(ID,VAR,SIZE,TYPE,FLAGS)" 8 4
System V IPC 関数 msgrcv を呼び、
メッセージキュー ID からメッセージを受け取り、
最大メッセージサイズ SIZE で変数 VAR に格納します。
メッセージを受け取ると、VAR に最初に格納されたものがメッセージ型
となり、VAR の最大長は、SIZE にメッセージ型のサイズを加えたものに
なることに注意して下さい。
成功すると真を、エラーでは偽を返します。
.Ip "next LABEL" 8 8
.Ip "next" 8
.I next
コマンドは、C の
.I continue
文と同様に、ループの次の繰り返しを始めます。
.nf

.ne 4
	line: while (<STDIN>) {
		next line if /\|^#/;	# コメントを捨てます
		.\|.\|.
	}

.fi
上の例で
.I continue
ブロックがあると、行が捨てられた場合でも実行されることを覚えておいて
下さい。
LABEL が省略されると、このコマンドは最も内側のループを続けます。
.Ip "oct(EXPR)" 8 4
.Ip "oct EXPR" 8
10 進数 EXPR を、8 進文字列にして返します。
(EXPRが 0x で始まる文字列なら、10 進の代わりに 16 進として変換します。)
以下は、10 進、8 進、16 進の標準的な記法を扱います。
.nf

	$val = oct($val) if $val =~ /^0/;

.fi
EXPR が省略されると、$_ を使います。
.Ip "open(FILEHANDLE,EXPR)" 8 8
.Ip "open(FILEHANDLE)" 8
.Ip "open FILEHANDLE" 8
EXPR で与えられたファイル名のファイルをオープンし、FILEHANDLE に結び
つけます。
FILEHANDLE が式の場合、その値を実際にファイルハンドルが求める名前
として使います。
EXPR が省略されると、FILEHANDLE と同名のスカラ変数が保持する値が
ファイル名となります。
ファイル名の前に \*(L"<\*(R" を付けるか、何も付けない場合、ファイルは
入力用にオープンされます。
ファイル名が \*(L">\*(R" で始まると、ファイルは出力用にオープンされます。 
ファイル名が \*(L">>\*(R" で始まると、ファイルは追加書き込み用に
オープンされます。
(\'>\' や \'<\' の前に \'+\' を付けると、ファイルを読み書き両用に
できます。)
ファイル名が \*(L"|\*(R" で始まると、ファイル名は出力がパイプされる
コマンドと解釈され、ファイル名が \*(L"|\*(R" で終ると、入力が
パイプされるコマンドと解釈されます。
(入出力共パイプするコマンドは必要がないでしょう。) \'\-\' をオープンすると
.I STDIN
を、\'>\-\' をオープンすると
.IR STDOUT
をオープンします。
open は成功したとき、0 でない値を、失敗したとき undefined 値を
返します。
open がパイプを含む場合、戻り値はサブプロセスの pid となります。
例:
.nf
    
.ne 3
	$article = 100;
	open article || die "Can't find article $article: $!\en";
	while (<article>) {\|.\|.\|.

.ie t \{\
	open(LOG, \'>>/usr/spool/news/twitlog\'\|);	# (ログ保存)
'br\}
.el \{\
	open(LOG, \'>>/usr/spool/news/twitlog\'\|);
					# (ログ保存)
'br\}

.ie t \{\
	open(article, "caesar <$article |"\|);		# 記事を decrypt
'br\}
.el \{\
	open(article, "caesar <$article |"\|);
					# 記事を decrypt
'br\}

.ie t \{\
	open(extract, "|sort >/tmp/Tmp$$"\|);		# $$ は現在のプロセス
'br\}
.el \{\
	open(extract, "|sort >/tmp/Tmp$$"\|);
					# $$ は現在のプロセス
'br\}

.ne 7
	# 引数リストのファイルを、それがインクルードするものも
	# 含めて処理します

	foreach $file (@ARGV) {
		do process($file, \'fh00\');	# no pun intended
	}

	sub process {
		local($filename, $input) = @_;
		$input++;		# 文字列インクリメント
		unless (open($input, $filename)) {
			print STDERR "Can't open $filename: $!\en";
			return;
		}
.ie t \{\
		while (<$input>) {		# 間接指定に注意
'br\}
.el \{\
		while (<$input>) {		# 間接指定に注意
'br\}
			if (/^#include "(.*)"/) {
				do process($1, $input);
				next;
			}
			.\|.\|.		# 続く
		}
	}

.fi
Bourne shell の慣習により、EXPR は \*(L">&\*(R" で始めるような指定も
できます。その場合、文字列の残りはファイルハンドル (数字なら
ファイルディスクリプタ) の名前と解釈され、dup して open します。
>>, <, +>, +>>, +< の後に & を使ってもかまいません。
指定するモードは、元のファイルハンドルのモードと一致していなくては
なりません。
以下は、
.I STDOUT
と
.IR STDERR
を保存し、リダイレクトを行なって、その後で書き戻します:
.nf

.ne 21
	#!/usr/bin/perl
	open(SAVEOUT, ">&STDOUT");
	open(SAVEERR, ">&STDERR");

	open(STDOUT, ">foo.out") || die "Can't redirect stdout";
	open(STDERR, ">&STDOUT") || die "Can't dup stdout";

	select(STDERR); $| = 1;		# バッファリングしません
	select(STDOUT); $| = 1;		# バッファリングしません

	print STDOUT "stdout 1\en";	# これもサブプロセスで
	print STDERR "stderr 1\en"; 	# 動作します

	close(STDOUT);
	close(STDERR);

	open(STDOUT, ">&SAVEOUT");
	open(STDERR, ">&SAVEERR");

	print STDOUT "stdout 2\en";
	print STDERR "stderr 2\en";

.fi
コマンド \*(L"\-\*(R" でパイプをオープンする、すなわち \*(L"|\-\*(R" 
や \*(L"\-|\*(R" をオープンすると、暗黙のうちに fork され、open の
戻り値として親プロセスには、子プロセスの pid が返され、子プロセスには 
0 が返されます。
(open が成功したかどうかは、defined($pid) を使って判断して下さい。)
ファイルハンドルは、親にとって普通の挙動をしますが、子には 
.IR STDOUT / STDIN
にパイプされたファイルハンドルの i/o となります。
子プロセスでファイルハンドルがオープンされず、\*(--新しく
ファイルハンドルは、新しい
.I STDIN
から
.IR STDOUT
へのパイプとなります。
よく使われるのは、普通のパイプのオープンと同様、パイプコマンドの
実行状態をコントロールしたいとき、setuid されたプログラムを走らせるとき、
シェルコマンドでメタキャラクタのチェックをする必要がないときです。
次の二つは、それぞれある程度同等です:
.nf

.ne 5
	open(FOO, "|tr \'[a\-z]\' \'[A\-Z]\'");
	open(FOO, "|\-") || exec \'tr\', \'[a\-z]\', \'[A\-Z]\';

	open(FOO, "cat \-n '$file'|");
	open(FOO, "\-|") || exec \'cat\', \'\-n\', $file;

.fi
パイプされたファイルハンドルを明示的に close すると、親プロセスは
子プロセスが終了するのを待つことになり、$? に状態を返します。
fork を行う操作では、両方のプロセスでフラッシュされないバッファが
そのまま残ることに注意して下さい。これは、二重出力を避けるために $| を
セットした方が良いことを意味します。
.Sp
open に渡されたファイル名は、前後の空白が除かれます。
意図的に変な文字を含むファイル名を持つファイルをオープンしたいときは、
前後の空白もこのように守ってやる必要があります:
.nf

.ne 2
        $file =~ s#^(\es)#./$1#;
        open(FOO, "< $file\e0");

.fi
.Ip "opendir(DIRHANDLE,EXPR)" 8 3
EXPR という名前のディレクトリを readdir(), telldir(), seekdir(),
rewinddir(),  closedir() で処理できるようにオープンします。
成功すると真を返します。
DIRHANDLE は、FILEHANDLE とは別個のそれ自身の名前空間を持ちます。
.Ip "ord(EXPR)" 8 4
.Ip "ord EXPR" 8
EXPR の最初の文字のアスキー値を数値で返します。
EXPR が省略されると、$_ を使います。
''' Comments on f & d by gnb@melba.bby.oz.au	22/11/89
.Ip "pack(TEMPLATE,LIST)" 8 4
配列または値のリストを引数に取り、バイナリ構造体にパックし、
構造体を含む文字列を返します。
TEMPLATE は値の順序と型を与える文字のシークエンスで、以下のように
なります:
.nf

	A	アスキー文字列(スペースが padding される)
	a	アスキー文字列(ヌルが padding される)
	c	signed char
	C	unsigned char
	s	signed short
	S	unsigned short
	i	signed integer
	I	unsigned integer
	l	signed long
	L	unsigned long
	n	short (\*(L"network\*(R" order)
	N	long (\*(L"network\*(R" order)
	f	単精度浮動小数点 (native format)
	d	倍精度浮動小数点 (native format)
	p	文字列へのポインタ
	v	short (\*(L"VAX\*(R" (little-endian) order)
	V	long (\*(L"VAX\*(R" (little-endian) order)
	x	null byte
	X	Back up a byte
	@	絶対位置にまでヌルで埋める
	u	uuencode された文字列
	b	ビット文字列 (vec()のような昇順).
	B	ビット文字列 (降順).
	h	16 進文字列 (低 nybble が先).
	H	16 進文字列 (高 nybble が先).

.fi
どの文字も繰り返し回数を表す数を続けることができます。
"a", "A", "b", "B", "h", "H" 以外の型では、pack 関数は
LIST から回数を指定された数だけ値を取ります。
繰り返し数として * を使うと、残りすべての分だけ繰り返します。
"a" と "A" の型は値一つしか取りませんが、繰り返し指定を文字列長
として pack するので、ヌルや空白での padding が必要になります。
(unpack するときは、"A" は、後に続く空白を削りますが、"a" はしません。)
同様に、"b" と "B" フィールドは、指定したビット長を pack します。
"h" と "H" フィールドは、指定した長さの nybbles をパックします。
実数 (float と double) は、そのマシンの機械語フォーマットのみです。
浮動小数点フォーマット関係の多様性と標準の \*(L"network\*(R" 表現が
無いことから、交換することはできません。これは、
あるマシンで pack された浮動小数点データは、他のマシンでは、
たとえ両方が IEEE 浮動小数点数演算を行っていても
(メモリ表現の endian は IEEE の仕様には無いから)、
読めないかもしれないということを意味します。
perl は、すべての数値計算を内部的には double を用い、
double -> float -> double という変換は精度を失うだろうということに
注意して下さい
(すなわち、unpack("f",pack("f", $foo)) は一般に $foo にはなりません) 。
.br
例:
.nf

	$foo = pack("cccc",65,66,67,68);
	# foo は "ABCD"
	$foo = pack("c4",65,66,67,68);
	# 上と同じ

	$foo = pack("ccxxcc",65,66,67,68);
	# foo は "AB\e0\e0CD"

	$foo = pack("s2",1,2);
	# little-endian の "\e1\e0\e2\e0" 
	# big-endian の "\e0\e1\e0\e2"

	$foo = pack("a4","abcd","x","y","z");
	# "abcd"

	$foo = pack("aaaa","abcd","x","y","z");
	# "axyz"

	$foo = pack("a14","abcdefg");
	# "abcdefg\e0\e0\e0\e0\e0\e0\e0"

	$foo = pack("i9pl", gmtime);
	# 実際の tm 構造体 (少なくとも私のシステムでは)

	sub bintodec {
	    unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
	}
.fi
一般に unpack 関数でも同じテンプレートが使われます。
.Ip "pipe(READHANDLE,WRITEHANDLE)" 8 3
相当するシステムコールのように一対の接続されたパイプをオープンします。
パイプでつながったプロセスのループを設定するときは、注意深くしないと
デッドロックを起こすことがあることに気をつけて下さい。
それに加えて、perl のパイプは標準入力のバッファリングを使うので、
アプリケーションに依っては、$| をセットして
コマンド毎に WRITEHANDLE をフラッシュする必要があるかもしれません。
[perl バージョン 3.0 パッチレベル 9 以上が必要]
.Ip "pop(ARRAY)" 8
.Ip "pop ARRAY" 8 6
配列の最後の値を取り出し、配列の長さを 1 だけ短くします。
.nf

	$tmp = $ARRAY[$#ARRAY\-\|\-];

.fi
同じ結果となります。
配列に要素がない場合は、undefined 値を返します。
.Ip "print(FILEHANDLE LIST)" 8 10
.Ip "print(LIST)" 8
.Ip "print FILEHANDLE LIST" 8
.Ip "print LIST" 8
.Ip "print" 8
文字列または、コンマ区切りの文字列のリストを表示します。
成功すると、0 以外を返します。
FILEHANDLE は、ファイルハンドルの名前を保持したスカラ変数名でも
かまいません。これにより 1 レベルの間接指定ができます。
(注意: FILEHANDLE が変数で次のトークンが項の場合、+ を挿入するか
引数に括弧を付けないと、演算子として解釈の間違いをするかもしれません。)
FILEHANDLE が省略されると、デフォルトで標準出力 (または最後に select
された出力チャンネル\*(-- select()を参照して下さい) に出力します。
LIST が省略されると、$_ を
.IR STDOUT
に出力します。
デフォルト出力チャンネルを
.I STDOUT
以外に設定するには、select 演算子を使って下さい。
print は LIST を取るので、LIST の中のものは何でも配列のコンテキストで
評価され、サブルーチン呼び出しなら配列のコンテキストで評価された式を
持つことになるのを覚えておきましょう。
また、print キーワードの後に左括弧を置くときは、対応する右括弧が 
print の引数の終りを示す
\*(--すなわち + を挿入するか、括弧をすべての引数に付ける
のでなければ、左括弧を置いてはいけません。
.Ip "printf(FILEHANDLE LIST)" 8 10
.Ip "printf(LIST)" 8
.Ip "printf FILEHANDLE LIST" 8
.Ip "printf LIST" 8
\*(L"print FILEHANDLE sprintf(LIST)\*(R" と同等です。
.Ip "push(ARRAY,LIST)" 8 7
ARRAY (@ は省略可能) をスタックとして扱い、LIST の値を ARRAY の終りに
追加します。
ARRAY の長さは、LIST の長さだけ増えます。
これは、以下と同じことになります。
.nf

    for $value (LIST) {
	    $ARRAY[++$#ARRAY] = $value;
    }

.fi
が、より効率的です。
.Ip "q/STRING/" 8 5
.Ip "qq/STRING/" 8
.Ip "qx/STRING/" 8
これは、実際には関数ではありませんが、クォートされた文字列に
バックスラッシュをたくさん置き過ぎるのを避けるための、単なる
簡略記法です。
q 演算子はシングルクォートを生成し、qq 演算子はダブルクォートを
生成します。
qx 演算子は、バッククォートを生成します。
英数字でない文字なら、改行を含めて何でも、/ の代わりに区切り文字
にできます。
区切りが ( か { なら、終了の区切りは、対応する ) か } になります。
(埋め込み文字としての } には通常通り \ が必要になります。)
例:
.nf

.ne 5
	$foo = q!I said, "You said, \'She said it.\'"!;
	$bar = q(\'This is it.\');
	$today = qx{ date };
	$_ .= qq
*** The previous line contains the naughty word "$&".\en
		if /(ibm|apple|awk)/;      # :-)

.fi
.Ip "rand(EXPR)" 8 8
.Ip "rand EXPR" 8
.Ip "rand" 8
ランダムな 0 から EXPR までの小数点数を返します。
(EXPR は正でなければなりません。)
EXPR が省略されると、0 から 1 の範囲の値が返されます。
srand() を参照して下さい。
.Ip "read(FILEHANDLE,SCALAR,LENGTH,OFFSET)" 8 5
.Ip "read(FILEHANDLE,SCALAR,LENGTH)" 8 5
指定された FILEHANDLE から、LENGTH バイトのデータを読み込み、変数 
SCALAR に格納します。
実際に読み込めたバイト数を返し、エラーの場合は undef を返します。
SCALAR は実際に読み込まれた長さに合わせて、伸縮します。
読んだデータを文字列の始めでなく、他の場所に格納するために、OFFSET を
指定することもできます。
これは、実際には stdio の fread コールで実装されています。
本当の read システムコールを使うには、sysread を参照して下さい。
.Ip "readdir(DIRHANDLE)" 8 3
.Ip "readdir DIRHANDLE" 8
opendir() にオープンされたディレクトリ内の、次のディレクトリエントリを
返します。
配列のコンテキストの中で使うと、残りすべてのディレクトリエントリを
返します。
エントリが残っていない場合、スカラのコンテキストでは undefined が、
配列のコンテキストではヌルリストを返します。
.Ip "readlink(EXPR)" 8 6
.Ip "readlink EXPR" 8
シンボリックリンクが実装されていれば、シンボリックリンクの値を返します。 
実装されていなければ、致命的エラーを返します。
システムエラーが起こったときは、undefined 値を返し、$! (errno) を
セットします。
EXPR を省略すると、$_ を使います。
.Ip "recv(SOCKET,SCALAR,LEN,FLAGS)" 8 4
ソケットからメッセージを受け取ります。指定した SOCKET ファイルハンドル
から、LENGTH バイトのデータを受け取り、変数 SCALAR に格納します。
sender のアドレスを返し、エラーの場合は undefined 値を返します。
SCALAR は、実際に読み込まれた長さに合わせて、伸縮します。
同名のシステムコールと同じフラグを用います。
.Ip "redo LABEL" 8 8
.Ip "redo" 8
.I redo
コマンドは、条件を再評価することなしに、ループブロックのコマンドを
再開します。
.I continue
ブロックがあっても実行されません。
LABEL が省略されると、最も内側のループを参照します。
通常このコマンドは、入力された内容について、自分自身をだますような
プログラムで使われます:
.nf

.ne 16
	# 単純化した Pascal のコメント除去
	# (警告: 文字列中には { や } はないものと仮定しています)
	line: while (<STDIN>) {
		while (s|\|({.*}.*\|){.*}|$1 \||) {}
		s|{.*}| \||;
		if (s|{.*| \||) {
			$front = $_;
			while (<STDIN>) {
				if (\|/\|}/\|) {	# コメント終了?
					s|^|$front{|;
					redo line;
				}
			}
		}
		print;
	}

.fi
.Ip "rename(OLDNAME,NEWNAME)" 8 2
ファイル名を変更します。
成功すると 1 を、失敗すると 0 を返します。
ファイルシステムの境界を越えては働きません。
.Ip "require(EXPR)" 8 6
.Ip "require EXPR" 8
.Ip "require" 8
EXPR か EXPR が与えられなければ $_ で指定された、ライブラリファイルを
インクルードします。
以下のようなサブルーチンと同じ意味になります:
.nf

	sub require {
	    local($filename) = @_;
	    return 1 if $INC{$filename};
	    local($realfilename,$result);
	    ITER: {
		foreach $prefix (@INC) {
		    $realfilename = "$prefix/$filename";
		    if (-f $realfilename) {
			$result = do $realfilename;
			last ITER;
		    }
		}
		die "Can't find $filename in \e@INC";
	    }
	    die $@ if $@;
	    die "$filename did not return true value" unless $result;
	    $INC{$filename} = $realfilename;
	    $result;
	}

.fi
同じ名前で指定されたファイルは、二度はインクルードされないことに
注意して下さい。
どの初期化コードの起動も成功したこと示すため、ファイルの最後の文で、
真を返さなければなりません。だから、慣習的にそういうファイルは、
必ず真を返すということが確かでなければ、\*(L"1;\*(R" で
終るようにします。
.Ip "reset(EXPR)" 8 6
.Ip "reset EXPR" 8
.Ip "reset" 8
一般にループの終りで変数をクリアするのに
.I continue
ブロックの中で使われ、再びそれが働くように ?? 検索をリセットします。
式は 1 文字ずつ分けてリストしたもの (ハイフンで範囲指定) として解釈されます。
それらの文字の一つで始まる変数や配列はみな初期状態にリセットされます。
式を省略すると、一度だけマッチする検索 (?pattern?) をリセットし、
再びマッチするようにします。
現パッケージ内の変数と検索のみをリセットします。
常に 1 を返します。
例:
.nf

.ne 3
    reset \'X\';	\h'|2i'# すべての X 変数をリセットします
    reset \'a\-z\';\h'|2i'# 小文字の変数すべてをリセットします。
    reset;	\h'|2i'# ?? 検索をリセットします。

.fi
注意: ARGV や ENV を消してしまうため、\*(L"A\-Z\*(R" をリセットする
のは勧められません。
.Sp
dbm 連想配列に reset を使っても、dbm ファイルを変更しません。
(しかし、perl がキャッシュしたエントリは皆フラッシュするので、
dbm ファイルを共有している場合は、便利です。便利でないかもしれませんが。)
.Ip "return LIST" 8 3
指定した値で、サブルーチンから返ります。
(サブルーチンは、自動的に最後に評価された式の値を返すことに
注意して下さい。
これは、好まれる方法です\*(--明示的な
.I return
の使用で、やや遅くなります。)
.Ip "reverse(LIST)" 8 4
.Ip "reverse LIST" 8
配列のコンテキストでは、LIST の要素を逆順に並べた配列を返します。
スカラのコンテキストでは、LIST の最初の要素のバイト列を逆順にした
文字列を返します。
.Ip "rewinddir(DIRHANDLE)" 8 5
.Ip "rewinddir DIRHANDLE" 8
DIRHANDLE に関し、readdir() で読み始める現在位置を、
ディレクトリの先頭にセットします。
.Ip "rindex(STR,SUBSTR,POSITION)" 8 6
.Ip "rindex(STR,SUBSTR)" 8 4
STR 内で、SUBSTR が最後に現れる位置を返す他は、index と全く同じに
動作します。
POSITION が指定されると、その位置の前で最後に現れた位置を返します。
.Ip "rmdir(FILENAME)" 8 4
.Ip "rmdir FILENAME" 8
FILENAME で指定されたディレクトリが空なら消去します。
成功すると 1 を、失敗すると 0 を返し、$! (errno) をセットします。
FILENAME が省略されると、$_ を使います。
.Ip "s/PATTERN/REPLACEMENT/gieo" 8 3
パターンに合う文字列を検索し、見つかると置換テキストに置き換えて、
置換が行なわれた数を返します。
でなければ、偽 (0) を返します。
\*(L"g\*(R" はオプションです。もしあれば、マッチしたパターンはすべて
置換されることを意味します。
\*(L"i\*(R" もオプションです。もしあれば、マッチングは大文字小文字の
区別なく行なわれることを意味します。
\*(L"e\*(R" もオプションです。もしあれば、置換文字列は
ダブルクォートで囲まれた文字列のようにというより、
式として評価されなければならないことを意味します。
英数字でない文字ならなんでも、/ に置き換えて区切り文字にできます。
シングルクォートが使われると、置換文字列の中で変数の挿入が
行なわれません (e 修飾子はこれに優先します)。
バッククォート ` が使われると、置換文字列はコマンドとして実行され、
その出力が実際の置換テキストとして使われることになります。
PATTERN が <>, () で区切られると、REPLACEMENT は、それ自身のクォートを
持ち、それは <>, () であっても、そうでなくても良いことになります。
例えば、s(foo)(bar) や s<foo>/bar/ のように。
=~ や !~ 演算子を介する文字列指定がされなかったときは、$_ 文字列が
検索、置換されます。
(=~ で指定された文字列は、スカラ変数、配列の要素、それらへの代入等で
なくてはなりません。すなわち左辺値ということです。)
パターンが、文字列の終りをテストする $ でなく、変数に見える $ を含む
場合は、その変数が実行時にパターンに挿入されます。
初回だけ変数が挿入されてコンパイルされるパターンを使いたいなら、
終りに \*(L"o\*(R" を付けて下さい。
PATTERN がヌル文字列に評価されたときは、代わりに最後に成功した正規表現
が使われます。
正規表現のセクションを参照して下さい。
例:
.nf

    s/\|\e\|bgreen\e\|b/mauve/g;	# wintergreen を変更しません

    $path \|=~ \|s|\|/usr/bin|\|/usr/local/bin|;

    s/Login: $foo/Login: $bar/; # 実行時パターン

    ($foo = $bar) =~ s/bar/foo/;

    $_ = \'abc123xyz\';
    s/\ed+/$&*2/e;		# \*(L'abc246xyz\*(R' になる
    s/\ed+/sprintf("%5d",$&)/e;	# \*(L'abc  246xyz\*(R' になる
    s/\ew/$& x 2/eg;		# \*(L'aabbcc  224466xxyyzz\*(R' になる

    s/\|([^ \|]*\|) *\|([^ \|]*\|)\|/\|$2 $1/;	# 始めの2フィールドを交換

.fi
(最後の例では \|\e\| の代わりに $ を使っていることに注意。
正規表現のセクションを参照して下さい。)
.Ip "scalar(EXPR)" 8 3
EXPR を強制的にスカラのコンテキストで解釈させて、EXPR の値を返します。
.Ip "seek(FILEHANDLE,POSITION,WHENCE)" 8 3
FILEHANDLE のポインタを、丁度 stdio の fseek() のように任意の
位置にします。
FILEHANDLE は、ファイルハンドルの名前を与える式でもかまいません。
成功すると 1 を、失敗すると 0 を返します。
.Ip "seekdir(DIRHANDLE,POS)" 8 3
DIRHANDLE について readdir() の読む現在位置をセットします。
POS は、telldir() の返す値でなければなりません。
相当するシステムライブラリルーチン同様、directory compaction について
は同じ注意が必要です。
.Ip "select(FILEHANDLE)" 8 3
.Ip "select" 8 3
現在 select されたファイルハンドルを返します。
FILEHANDLE を与えられると、出力用の現在のデフォルトファイルハンドルを
セットします。
これには二つの効果があります。一つは、ファイルハンドルの無い
.I write
や
.I print
が、デフォルトでこの FILEHANDLE に行なわれるということです。
二つ目は、出力に関連する変数参照が、この出力チャンネルを参照する
ということです。
例えば、form フォーマットの先頭を、一つ以上の出力チャンネルに
セットしなければならないとき、次のようにすると良いでしょう:
.nf

.ne 4
	select(REPORT1);
	$^ = \'report1_top\';
	select(REPORT2);
	$^ = \'report2_top\';

.fi
FILEHANDLE は、実際のファイルハンドルの名前を与える式でもかまいません。
このように:
.nf

	$oldfh = select(STDERR); $| = 1; select($oldfh);

.fi
.Ip "select(RBITS,WBITS,EBITS,TIMEOUT)" 8 3
これは、ビットマスクを指定して select システムコールを呼び出しします。
ビットマスクは、以下のように fileno() や vec() を使って作成されます。
.nf

	$rin = $win = $ein = '';
	vec($rin,fileno(STDIN),1) = 1;
	vec($win,fileno(STDOUT),1) = 1;
	$ein = $rin | $win;

.fi
たくさんのファイルハンドルを select したいときは、サブルーチンを書いた
方が良いかもしれません。
.nf

	sub fhbits {
	    local(@fhlist) = split(' ',$_[0]);
	    local($bits);
	    for (@fhlist) {
		vec($bits,fileno($_),1) = 1;
	    }
	    $bits;
	}
	$rin = &fhbits('STDIN TTY SOCK');

.fi
通常の使い方は、
.nf

	($nfound,$timeleft) =
	  select($rout=$rin, $wout=$win, $eout=$ein, $timeout);

また、何かが ready となるまでブロックしておくには、こうなります。

.ie t \{\
	$nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);
'br\}
.el \{\
	$nfound = select($rout=$rin, $wout=$win,
				$eout=$ein, undef);
'br\}

.fi
ビットマスクはどれも undef にもできます。
TIMEOUT は秒で指定され、小数点数でもかまいません。
注意: すべての実装で $timeleft を返せるわけではありません。
できない場合、常に与えられた $timeout に等しい値の $timeleft を
返します。
.Ip "semctl(ID,SEMNUM,CMD,ARG)" 8 4
System V IPC 関数の semctl を呼び出します。 CMD が &IPC_STAT か
&GETALL なら、ARG は返って来た semid_ds 構造体か、セマフォ値配列を
保持する変数でなければなりません。
ioctl 同様、エラーの場合 undefined 値が、0 の場合 "0 but true" が、
それ以外の場合実際の戻り値が返されます。
.Ip "semget(KEY,NSEMS,SIZE,FLAGS)" 8 4
System V IPC 関数 semget を呼び出します。セマフォ id を返し、エラーの
場合は undefined 値を返します。
.Ip "semop(KEY,OPSTRING)" 8 4
シグナルや wait のようなセマフォ操作を実行する System V IPC 関数 semop
を呼び出します。
OPSTRING は、semop 構造体に pack された配列でなければなりません。
各 semop 構造体は \&'pack("sss", $semnum, $semop, $semflag)' で
生成できます。セマフォ操作の数は、OPSTRING の長さによります。
成功すると真を、エラーでは偽を返します。例として、以下のコードでは
セマフォ id $semid のセマフォ $semnum を待ちます。
.nf

	$semop = pack("sss", $semnum, -1, 0);
	die "Semaphore trouble: $!\en" unless semop($semid, $semop);

.fi
セマフォにシグナルを送るには、"-1" を "1" にします。
.Ip "send(SOCKET,MSG,FLAGS,TO)" 8 4
.Ip "send(SOCKET,MSG,FLAGS)" 8
ソケットにメッセージを送ります。
同名のシステムコールと同じフラグを用います。
接続されていないソケットでは、送り先を TO として指定しなければ
なりません。送った文字数を返します。エラーの場合は undefined 値を
返します。
.Ip "setpgrp(PID,PGRP)" 8 4
指定した PID のカレントプロセスグループをセットします。 PID は、
カレントプロセスでは 0 です。
setpgrp(2) が実装されていないマシンでは、致命的エラーとなります。
.Ip "setpriority(WHICH,WHO,PRIORITY)" 8 4
プロセス、プロセスグループ、ユーザのカレントプライオリティを
セットします。 (setpriority(2) を参照して下さい。)
setpriority(2) が実装されていないマシンでは、致命的エラーになります。
.Ip "setsockopt(SOCKET,LEVEL,OPTNAME,OPTVAL)" 8 3
リクエストされたソケットオプションをセットします。
エラーでは undefined を返します。
引数を渡したいので無ければ、OPTVAL は undef 値を指定しても
かまいません。
.Ip "shift(ARRAY)" 8 6
.Ip "shift ARRAY" 8
.Ip "shift" 8
配列の最初の要素を配列から除き、その要素を返します。
配列は 1 だけ短くなり、他のすべての要素はずれます。
配列に要素がないときは、undefined 値を返します。
ARRAY を省略すると、メインプログラムでは @ARGV 配列を shift し、
サブルーチンでは @_ 配列を shift します。
(これは、辞書的に決められています)
unshift(), push(), pop() を参照して下さい。
shift() と unshift() は、push() と pop() が配列の右端に行なうのと
同じことを、配列の左端で行ないます。
.Ip "shmctl(ID,CMD,ARG)" 8 4
System V IPC 関数 shmctl を呼び出します。 CMD が &IPC_STAT のとき、
ARG は、返された shmid_ds 構造体を保持する変数でなくてはなりません。
ioctl 同様の戻り値を返します。エラーでは undefined 値を、0 では
"0 but true" を、それ以外では実際の値を返します。
.Ip "shmget(KEY,SIZE,FLAGS)" 8 4
System V IPC 関数 shmget を呼び出します。
共有メモリのセグメント id を返します。エラーでは、undefined 値を
返します。
.Ip "shmread(ID,VAR,POS,SIZE)" 8 4
.Ip "shmwrite(ID,STRING,POS,SIZE)" 8
Syste V の共有メモリセグメント ID を、位置 POS から始まる
サイズ SIZE にて attach し、copy in/out し、detach することで、読み込み
と書き込みを行ないます。
読み込み時、VAR は読まれたデータを保持する変数でなければ
なりません。書き込み時に、STRING が長過ぎると、SIZE バイトだけが
使われます。STRING が短過ぎると、SIZE バイトを埋めるのにヌルが
書き込まれます。成功すると真を、エラーでは偽を返します。
.Ip "shutdown(SOCKET,HOW)" 8 3
ソケット接続を HOW で指示された流儀に従ってシャットダウンします。
同名のシステムコールと同様に HOW を解釈します。
.Ip "sin(EXPR)" 8 4
.Ip "sin EXPR" 8
EXPR (ラジアンで表現) のサインを返します。
EXPR を省略すると $_ のサインを取ります。
.Ip "sleep(EXPR)" 8 6
.Ip "sleep EXPR" 8
.Ip "sleep" 8
EXPR 秒間スクリプトを止めます。 EXPR がなければ永久に止めます。
プロセスに SIGALRM を送ることで、割り込まれます。
実際に sleep した秒数を返します。
sleep() は、しばしば alarm() を使って実装されているので、おそらく
alarm() と sleep() は 混在させることはできないでしょう。
.Ip "socket(SOCKET,DOMAIN,TYPE,PROTOCOL)" 8 3
指定された種類のソケットをオープンして、ファイルハンドル SOCKET に
結びつけます。
DOMAIN, TYPE, PROTOCOL は、同名のシステムコールと同様に指定します。
perl ライブラリファイルから簡単に適当な値を得るには、h2ph を 
sys/soket.h に対して実行する必要があるかもしれません。
成功すると真を返します。
プロセス間通信のセクションの例を参照して下さい。
.Ip "socketpair(SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL)" 8 3
指定されたドメインの指定された型で、無名のソケットペアを生成します。
DOMAIN, TYPE, PROTOCOL は、同名のシステムコールと同じように指定します。 
実装されていない場合は、致命的エラーとなります。
成功すると真を返します。
.Ip "sort(SUBROUTINE LIST)" 8 9
.Ip "sort(LIST)" 8
.Ip "sort SUBROUTINE LIST" 8
.Ip "sort BLOCK LIST" 8
.Ip "sort LIST" 8
LIST をソートし、ソート済みの配列値を返します。
存在しない配列値は、削られます。
SUBROUTINE や BLOCK が省略されると、標準的な文字の比較による順でソート
します。
0 より小さい整数、0 、0 より大きい整数を返すような SUBROUTINE の名前
を指定すると、配列の要素の並べ方に従って順に並べ直します。
(<=> と cmp 演算子は、このようなルーチンでは非常に便利です)
SUBROUTINE は、スカラ変数名でもかまいません。その値として使用する
サブルーチンの名前が入っていれば良いのです。
SUBROUTINE 名の代わりに、BLOCK を指定して、
無名のインラインソートサブルーチンとして用いることもできます。
.Sp
効率を良くするため、通常のサブルーチン呼び出しコードをバイパスしています。
そのため、次のような影響があります。
サブルーチンは再帰的であってはならず、
比較される 2 要素は @_ を介してではなく、$a と $b を介して
サブルーチンに渡されます。 (以下の例を参照して下さい。)
これらは参照渡しなので、$a や $b を変更してはいけません。
.Sp
例:
.nf

.ne 2
	# 辞書順のソート
	@articles = sort @files;

.ne 2
	# 同じものだが、明示的なソートルーチン
	@articles = sort {$a cmp $b} @files;

.ne 2
	# 同じものだが逆順
	@articles = sort {$b cmp $a} @files;

.ne 2
	# 数値的に昇順でソート
	@articles = sort {$a <=> $b} @files;

.ne 2
	# 数値的に降順でソート
	@articles = sort {$b <=> $a} @files;

.ne 5
	# 明示的にサブルーチン名を使ったソート
	sub byage {
	    $age{$a} <=> $age{$b};	# 整数と仮定
	}
	@sortedclass = sort byage @class;

.ne 9
	sub reverse { $b cmp $a; }
	@harry = (\'dog\',\'cat\',\'x\',\'Cain\',\'Abel\');
	@george = (\'gone\',\'chased\',\'yz\',\'Punished\',\'Axed\');
	print sort @harry;
		# AbelCaincatdogx と出力
	print sort reverse @harry;
		# xdogcatCainAbel と出力
	print sort @george, \'to\', @harry;
		# AbelAxedCainPunishedcatchaseddoggonetoxyz と出力

.fi
.Ip "splice(ARRAY,OFFSET,LENGTH,LIST)" 8 8
.Ip "splice(ARRAY,OFFSET,LENGTH)" 8
.Ip "splice(ARRAY,OFFSET)" 8
配列から OFFSET と LENGTH で指定された要素を除き、LIST の要素と
入れ替えます。
配列から除かれた要素を返します。
配列は必要に応じて伸縮されます。
LENGTH を省略すると、OFFSET から先はすべて除かれます。
以下は皆同等となります。 ($[ == 0 であると仮定した場合)
.nf

	push(@a,$x,$y)\h'|3.5i'splice(@a,$#a+1,0,$x,$y)
	pop(@a)\h'|3.5i'splice(@a,-1)
	shift(@a)\h'|3.5i'splice(@a,0,1)
	unshift(@a,$x,$y)\h'|3.5i'splice(@a,0,0,$x,$y)
	$a[$x] = $y\h'|3.5i'splice(@a,$x,1,$y);

次の例では、配列長は配列の前に渡されると仮定しています:
	
	sub aeq {	# compare two array values
		local(@a) = splice(@_,0,shift);
		local(@b) = splice(@_,0,shift);
		return 0 unless @a == @b;	# 同じ長さ?
		while (@a) {
		    return 0 if pop(@a) ne pop(@b);
		}
		return 1;
	}
	if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }

.fi
.Ip "split(/PATTERN/,EXPR,LIMIT)" 8 8
.Ip "split(/PATTERN/,EXPR)" 8 8
.Ip "split(/PATTERN/)" 8
.Ip "split" 8
文字列を文字列の配列に分けて、その配列を返します。
(配列のコンテキストではない場合、見つかったフィールドの数を返し、
split したものは @_ 配列に入れます。
(配列のコンテキストでは、パターン区切りとして ?? を使うことで強制的に
@_ に split させられますが、それでも配列値を返します。))
EXPR を省略すると、$_ 文字列を split します。
PATTERN も省略すると、空白文字 (/[\ \et\en]+/) で split します。
PATTERN にマッチするものは何でもフィールドを分ける区切りと解釈されます。
(区切りは 1 文字より長くてもよいことに注意して下さい。)
LIMIT が指定されると、それを越えない数に split されます (少ない場合も
あります) 。
LIMIT が指定されないと、後に続くヌルフィールドは除かれます 
(pop()を使う人は良く覚えておいた方がよいでしょう) 。
ヌル文字にマッチするパターン (ヌルパターン // と混同しないで下さい。 
// はヌル文字にマッチするパターンの一つにすぎません。) は、
マッチするすべての点で EXPR を一文字ずつに split します。
例えば:
.nf

	print join(\':\', split(/ */, \'hi there\'));

.fi
は、\*(L'h:i:t:h:e:r:e\*(R' を出力します。
.Sp
LIMIT パラメータは、行を部分的に split することに使われます。
.nf

	($login, $passwd, $remainder) = split(\|/\|:\|/\|, $_, 3);

.fi
(リストに代入するとき、LIMIT が省略されていると perl は不必要な動作を
避けるためにリストの変数の数より一つ大きい LIMIT を与えます。
上記のリストでは LIMIT はデフォルトで 4 だったはずです。
時間に制限のあるアプリケーションでは、本当に必要な数以上のフィールドに
は split しないようにすべきです。)
.Sp
PATTERN が括弧を含むときは、区切りとしてマッチする文字列により、
更に配列要素が作成されます。
.Sp
	split(/([,-])/,"1-10,20");
.Sp
は以下の配列値を作ります。
.Sp
	(1,'-',10,',',20)
.Sp
パターン /PATTERN/ は、実行時に変わるパターンを指定する式で
置き換え可能です。
(実行時コンパイルを一回にしたければ、/$variable/o を使って下さい。)
特別なケースとして空白 (\'\ \') を指定すると、引数無しで split する
場合と同様ですが、先頭に空白があってもヌルフィールドは作られません。
つまり split(\'\ \') は、
.IR awk
のデフォルトの動作をエミュレートすることができるわけで、split(/\ /) 
は先頭に空白があると、最初にその数だけヌルフィールドを作ります。
.Sp
例:
.nf

.ne 5
	open(passwd, \'/etc/passwd\');
	while (<passwd>) {
.ie t \{\
		($login, $passwd, $uid, $gid, $gcos, $home, $shell) = split(\|/\|:\|/\|);
'br\}
.el \{\
		($login, $passwd, $uid, $gid, $gcos, $home, $shell)
			= split(\|/\|:\|/\|);
'br\}
		.\|.\|.
	}

.fi
(上の例の $shell は改行文字を含みます。 chop() を参照して下さい。)
.IR join
を参照して下さい。
.Ip "sprintf(FORMAT,LIST)" 8 4
通常の printf 変換でフォーマットされる文字列を返します。
* 文字はサポートされていません。
.Ip "sqrt(EXPR)" 8 4
.Ip "sqrt EXPR" 8
EXPR の平方根を返します。
EXPR を省略すると、$_ の平方根を返します。
.Ip "srand(EXPR)" 8 4
.Ip "srand EXPR" 8
.I rand
演算子のために、乱数用の seed をセットします。
EXPR を省略すると、srand(time) を実行します。
.Ip "stat(FILEHANDLE)" 8 8
.Ip "stat FILEHANDLE" 8
.Ip "stat(EXPR)" 8
.Ip "stat SCALARVARIABLE" 8
EXPR という名前のファイルや FILEHANDLE でオープンされたファイルの
情報を示す 13 要素の配列を返します。
stat が失敗するとヌルリストを返します。
普通次のように使います:
.nf

.ne 3
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
       $atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);

.fi
stat に特殊ファイルハンドル _ を渡すと、stat は実行されず最後に
行なわれた stat やファイルテストで使われた stat 構造体の内容を
返します。
例:
.nf

.ne 3
	if (-x $file && (($d) = stat(_)) && $d < 0) {
		print "$file is executable NFS file\en";
	}

.fi
(この例は、NFS 下でデバイス番号が負になるマシンでのみ動作します。)
.Ip "study(SCALAR)" 8 6
.Ip "study SCALAR" 8
.Ip "study"
SCALAR (指定しなければ $_) について、それが次に変更される前に多くの
パターンマッチを予想してあらかじめ行います。
検索をするパターンの性質や数、検索される文字列中の文字の出現頻度分布
によっては、時間を節約できるかもしれませんし、できないかもしれません。
\*(--多分これを使った場合と使わない場合で、実行時どちらが速いかを
比べてみたいでしょう。たくさんの短い定数文字列(より複雑なパターンの
定数部を含む)をスキャンするループで最も恩恵にあずかれるでしょう。
一度に一つの study しか効果がありません。\*(--別のスカラを study 
すると、先に study したものは \*(L"unstudied\*(R" となってしまいます。
(study の動作の仕方は次の通りです: 検索される文字列のすべての文字の
リンクリストを作ります。そうすると例えば、どこに \*(L'k\*(R' の文字が
あるかがすべてわかるわけです。いくつかの C のプログラムと英文から
作成された統計頻度表に基づき、各検索文字について、最も頻度が少ない
文字を選びます。この \*(L"頻度が少ない\*(R" 文字を調べるのです。)
.Sp
次の例は、あるパターンを含むすべての行の前にインデックスを含むエントリを
挿入します:
.nf

.ne 8
	while (<>) {
		study;
		print ".IX foo\en" if /\ebfoo\eb/;
		print ".IX bar\en" if /\ebbar\eb/;
		print ".IX blurfl\en" if /\ebblurfl\eb/;
		.\|.\|.
		print;
	}

.fi
/\ebfoo\eb/ を検索するとき、\*(L'f\*(R' は \*(L'o\*(R' よりも頻度が
少ないため、$_ の中で \*(L'f\*(R' を含む位置が探されます。
一般に、病的な場合を除いて、これは非常にうまくいきます。
唯一、最初の時点でリンクリストを作成するためにかかる以上の
時間を節約できるかが問題になります。
.Sp
実行するまで解らない文字列を検索しなければならない場合、全ループを
一つの文字列として解析し eval することで、すべてのパターンを毎回
再コンパイルするのを避けることができることを覚えておきましょう。
それに加えて全ファイルが 1 レコードになるように $/ を undef すると、
大変速くなり、fgrep のように特殊化したプログラムより速くなることも
多いです。
以下の例は、ファイルのリスト (@files) と単語のリスト (@words) を
検索し、マッチするファイル名を出力します:
.nf

.ne 12
	$search = \'while (<>) { study;\';
	foreach $word (@words) {
	    $search .= "++\e$seen{\e$ARGV} if /\e\eb$word\e\eb/;\en";
	}
	$search .= "}";
	@ARGV = @files;
	undef $/;
	eval $search;		# これは(メモリ不足で)泣きそう
	$/ = "\en";		# 普通の入力区切りに戻そう
	foreach $file (sort keys(%seen)) {
	    print $file, "\en";
	}

.fi
.Ip "substr(EXPR,OFFSET,LEN)" 8 2
.Ip "substr(EXPR,OFFSET)" 8 2
EXPR から部分文字列を取り出し、それを返します。
$[ をセットしない限り、最初の文字はオフセット 0 です。
OFFSET が負だと、文字列の終りから OFFSET だけ離れた位置から始めます。
LEN を省略すると、終端までのすべての文字列を返します。
substr() 関数は左辺値としても使えます。その場合 EXPR は左辺値
でなくてはなりません。
LEN より短いものを代入すると、文字列は短くなり、長いものを代入すると
それを含められるように長くなります。
文字列を同じ長さに保つためには、sprintf() を使ってパディングまたは
切り捨てをしなければならないかもしれません。
.Ip "symlink(OLDFILE,NEWFILE)" 8 2
OLDFILE へのシンボリックリンク NEWFILE を作成します。
成功すると 1 を、失敗すると 0 を返します。
シンボリックリンクをサポートしないシステムでは、実行時に致命的エラー
となります。
これをチェックするには、eval を使います:
.nf

	$symlink_exists = (eval \'symlink("","");\', $@ eq \'\');

.fi
.Ip "syscall(LIST)" 8 6
.Ip "syscall LIST" 8
リストの最初の要素で指定されたものに、残りの要素を引数として付けて、
システムコールを呼び出します。 
実装されていないと致命的エラーとなります。
引数は次のように解釈されます: 与えられた引数が数字なら、引数は
整数として渡されます。そうでなければ、文字列へのポインタが渡されます。
結果が受け取れるように、書き込まれるべき文字列を十分長くしておくのは、
あなたの責任です。
数字の引数がリテラルでなく、それまで数字のコンテキストで解釈されて
いなかったものなら、強制的に数字に見せるように、
0 を足す必要があるかもしれません。
.nf

	# h2ph を実行しておく必要があるかもしれません
	require 'syscall.ph';
	syscall(&SYS_write, fileno(STDOUT), "hi there\en", 9);

.fi
.Ip "sysread(FILEHANDLE,SCALAR,LENGTH,OFFSET)" 8 5
.Ip "sysread(FILEHANDLE,SCALAR,LENGTH)" 8 5
システムコール read(2) を使って、指定した FILEHANDLE から
LENGTH バイトのデータを読み込み、変数 SCALAR に格納します。
これは標準入出力を経由しないので、read と混在して使うと、
混乱するかもしれません。
実際に読み込まれたバイト数を返します。エラーの場合は undef を返します。
SCALAR は実際に読み込まれた長さによって伸縮します。
文字列の始めでなく途中にデータを格納するように、OFFSET を指定できます。
.Ip "system(LIST)" 8 6
.Ip "system LIST" 8
\*(L"exec LIST\*(R" と全く同じことを行ないますが、違いは最初に fork が
実行されて、親プロセスは子プロセスが終了するのを待つことです。
引数の処理は、引数の数によって変わることに注意して下さい。
戻り値は、wait() で返るプログラムの終了時ステータスになります。
実際の終了時ステータスを得るには、256 で割って下さい。
.IR exec
を参照。
.Ip "syswrite(FILEHANDLE,SCALAR,LENGTH,OFFSET)" 8 5
.Ip "syswrite(FILEHANDLE,SCALAR,LENGTH)" 8 5
システムコール write(2) を使って、指定した FILEHANDLE に
変数 SCALAR から LENGTH バイトのデータを書き込みます。
これは標準入出力を経由しないので、print と混在して使うと、
混乱するかもしれません。
実際に書き込まれたバイト数を返します。エラーの場合は undef を返します。
OFFSET で、文字列の始めでなく途中からデータを読むように指定できます。
.Ip "tell(FILEHANDLE)" 8 6
.Ip "tell FILEHANDLE" 8 6
.Ip "tell" 8
FILEHANDLE の現在のファイル位置を返します。
FILEHANDLE は、実際のファイルハンドルの名前を与える式でもかまいません。
FILEHANDLE を省略すると、最後に読んだファイルを使います。
.Ip "telldir(DIRHANDLE)" 8 5
.Ip "telldir DIRHANDLE" 8
DIRHANDLE について readdir() ルーチンの現在の位置を返します。
この値は、ディレクトリの特定の位置をアクセスするために、seekdir() の
引数に使います。
相当するシステムライブラリルーチン同様、directory compaction について
は同じ注意が必要です。
.Ip "time" 8 4
1970 年 1 月 1 日 00:00:00 (UTC) からの通算の秒数(閏秒無し)を返します。
gmtime() や localtime() に使うことができます。
.Ip "times" 8 4
現在のプロセスと子プロセスのユーザ、システム時間(秒)からなる 4 要素の
配列を返します。
.Sp
    ($user,$system,$cuser,$csystem) = times;
.Sp
.Ip "tr/SEARCHLIST/REPLACEMENTLIST/cds" 8 5
.Ip "y/SEARCHLIST/REPLACEMENTLIST/cds" 8
SEARCHLIST にある文字が出現したら、すべて REPLACEMENTLIST の相当する
文字に変換します。
変換または削除された文字の数を返します。
=~ や !~ 演算子を介した文字列の指定をしなかった場合、$_ 文字列が
変換されます。
(=~ で指定した文字列は、スカラ変数か配列の要素かそれらへの代入
でなければいけません。つまり、左辺値ということになります。)
.I sed
信者のために、
.I tr
の別名
.I y
が用意されています。
SEARCHLIST が [], <>, () で区切られていると、REPLACEMENTLIST は、
それ自身のクォートを持ち、それは [], <>, () であっても、そうでなくても
良いことになります。例えば、
tr[A-Z][a-z] または tr(+-*/)/ABCD/ のようになります。
.Sp
c 修飾子が指定されると、SEARCHLIST の文字セットは補間されます。
d 修飾子が指定されると、SEARCHLIST で指定された文字で REPLACEMENTLIST 
に対応するものがないものは皆、削除されます。
(これは、SEARCHLIST で見つかったものを何でも削除してしまう
ような
.I tr
プログラムの挙動よりも、やや柔軟です。)
s 修飾子が指定されると、変換されて同じ文字が続いたとき、
それを 1 文字に縮めます。
.Sp
d 修飾子が使われると、REPLACEMENTLIST は常に指定された通りに
解釈されます。それ以外の場合で、REPLACEMENTLIST が SEARCHLIST より
短いときは、同じ長さになるまで最後の文字が繰り返されます。
REPLACEMENTLIST がヌルだと、SEARCHLIST がコピーされます。
これは、あるクラスに含まれる文字をカウントしたり、あるクラスの文字の
重複を縮めるときに便利です。
.Sp
例:
.nf

    $ARGV[1] \|=~ \|y/A\-Z/a\-z/;	\h'|3i'# 小文字に統一します

    $cnt = tr/*/*/;		\h'|3i'# $_ の中の * を数えます

    $cnt = tr/0\-9//;		\h'|3i'# $_ の中の数字を数えます

    tr/a\-zA\-Z//s;	\h'|3i'# bookkeeper \-> bokeper

    ($HOST = $host) =~ tr/a\-z/A\-Z/;

    y/a\-zA\-Z/ /cs;	\h'|3i'# アルファベット以外を 1 文字の空白にします

    tr/\e200\-\e377/\e0\-\e177/;\h'|3i'# 8 ビット目を消します

.fi
.Ip "truncate(FILEHANDLE,LENGTH)" 8 4
.Ip "truncate(EXPR,LENGTH)" 8
FILEHANDLE や EXPR の名前のファイルを指定した長さに切り詰めます。
システムに truncate が実装されていないと、致命的エラーになります。
.Ip "umask(EXPR)" 8 4
.Ip "umask EXPR" 8
.Ip "umask" 8
プロセスに umask をセットし、変更前の値を返します。
EXPR が省略されると、単に現在の umask を返します。
.Ip "undef(EXPR)" 8 6
.Ip "undef EXPR" 8
.Ip "undef" 8
EXPR の値を undefined とします。これは左辺値でなければなりません。
スカラ値、配列全体、サブルーチン名 (& を使う) の場合でのみ使えます。
(undef は、多分ほとんどの予約変数、dbm 配列値では期待する動作となりません。)
undef は、常に undefined 値を返します。
EXPR を省略することもできます。その場合は何も undef されませんが、
それでも undefined 値を得ることができます。
例えば、サブルーチンから return するときです。
例:
.nf

.ne 6
	undef $foo;
	undef $bar{'blurfl'};
	undef @ary;
	undef %assoc;
	undef &mysub;
	return (wantarray ? () : undef) if $they_blew_it;

.fi
.Ip "unlink(LIST)" 8 4
.Ip "unlink LIST" 8
リストに含まれるファイルを削除します。
削除に成功したファイルの数を返します。
.nf

.ne 2
	$cnt = unlink \'a\', \'b\', \'c\';
	unlink @goners;
	unlink <*.bak>;

.fi
注意: unlink は、自分がスーパユーザで
.IR perl
に
.B \-U
フラグを付けている場合を除くとディレクトリを消去はしません。
これらの条件がそろったとしても、ディレクトリの unlink は
システムにダメージを与えることがあるので、気をつけて下さい。
代わりに rmdir を使って下さい。
.Ip "unpack(TEMPLATE,EXPR)" 8 4
unpack は pack の逆を行ないます: 構造体を示す文字列を引数に取り、
それを配列値に出力し、配列値を返します。
(スカラのコンテキストでは、生成された最初の値のみを返します。)
TEMPLATE は、pack 関数と全く同じフォーマットになります。
以下は、substr を実行するサブルーチンです:
.nf

.ne 4
	sub substr {
		local($what,$where,$howmuch) = @_;
		unpack("x$where a$howmuch", $what);
	}

.ne 3
そして、

	sub ord { unpack("c",$_[0]); }

.fi
というのもあります。
更に、フィールドの前に %<数字> の添字を付けることにより、
項目そのものの代わりに、項目の<数字>ビットのチェックサムが欲しいと
いう指定になります。
デフォルトは、16 ビットのチェックサムです。
次の例で、System V の sum プログラムと同じ数が計算されます:
.nf

.ne 4
	while (<>) {
	    $checksum += unpack("%16C*", $_);
	}
	$checksum %= 65536;

.fi
.Ip "unshift(ARRAY,LIST)" 8 4
視点によって、
.IR shift
の逆、または
.IR push
の逆を行ないます。
LIST を配列の前に付け加え、新しい配列の要素の数を返します。
.nf

	unshift(ARGV, \'\-e\') unless $ARGV[0] =~ /^\-/;

.fi
.Ip "utime(LIST)" 8 2
.Ip "utime LIST" 8 2
リストの各ファイルのアクセス時刻と最終変更時刻を変えます。
リストの最初の二つの要素には、*数値*で表されたアクセス時刻と変更時刻が
この順で入っていなければなりません。
変更に成功したファイルの数が返ります。
各ファイルの inode 変更時刻には現在時間がセットされます。
以下は、\*(L"touch\*(R" コマンドの例です:
.nf

.ne 3
	#!/usr/bin/perl
	$now = time;
	utime $now, $now, @ARGV;

.fi
.Ip "values(ASSOC_ARRAY)" 8 6
.Ip "values ASSOC_ARRAY" 8
名前付き連想配列のすべての値からなる普通の配列を返します。
値は、見かけ上ランダムな順で返るように見えますが、同じ連想配列に対して、
keys() 関数 や each() 関数が生成するものと同じ順になります。
keys() と each() を参照して下さい。
.Ip "vec(EXPR,OFFSET,BITS)" 8 2
文字列を unsigned integer のベクトルとして扱い、指定した
ビットフィールドの値を返します。
代入もできます。
BITSは、2 の累乗で 1 から 32 まででなければなりません。
.Sp
vec() に生成されたベクトルは、論理演算子 |, &, ^ で操作することができ、
両方のオペランドが文字列のとき、
ビットベクトル演算をするものとみなされます。
古いプログラムを守るために、プログラム中に少なくとも一つの vec() が
ないと、この解釈はなされません。
.Sp
ビットベクトルを 0 や 1 の文字列や配列に変換するには、
以下を使って下さい:
.nf

	$bits = unpack("b*", $vector);
	@bits = split(//, unpack("b*", $vector));

.fi
ビットの正確な長さがわかるならば、* の代わりに使うことができます。
.Ip "wait" 8 6
子プロセスが終了するのを待ち、死んだプロセスの pid を返します。
子プロセスがないときは、-1 を返します。
終了時ステータスは $? に返されます。
.Ip "waitpid(PID,FLAGS)" 8 6
特定の子プロセスが終了するのを待ち、死んだプロセスの pid を返します。
そのような子プロセスがなければ、-1 を返します。
終了時ステータスは $? に返されます。
次のように書くと、
.nf

	require "sys/wait.h";
	.\|.\|.
	waitpid(-1,&WNOHANG);

.fi
どのプロセスに対しても、non-blocking wait を実行できます。
non-blocking wait は、
.I waitpid (2)
か、または
.I wait4 (2)
システムコールをサポートしているマシンでのみ使えます。
しかし、FLAGS 0 での 特殊な pid の wait はどこでも実装されています。
(perl は、終了したものの perl スクリプトには採り入れられていない
プロセスのステータス値を覚えていることでシステムコールをエミュレート
します。)
.Ip "wantarray" 8 4
現在実行しているサブルーチンのコンテキストが配列値なら真を返します。
スカラのコンテキストに見えれば、偽を返します。
.nf

	return wantarray ? () : undef;

.fi
.Ip "warn(LIST)" 8 4
.Ip "warn LIST" 8
\*(L"die\*(R" と同じようなメッセージを標準エラー出力に出しますが、
終了しません。
.Ip "write(FILEHANDLE)" 8 6
.Ip "write(EXPR)" 8
.Ip "write" 8
指定したファイルに、関連付けられたフォーマットを使って、
フォーマットレコード (複数行も可) を書き込みます。
デフォルトで、フォーマットはファイルハンドルと同じ名前を持つものに
なりますが、$~ 変数にフォーマットの名前を明示的に割り当てることで、
現在の出力チャンネル (
.IR select 
を参照して下さい) に対するフォーマットをセットしてもかまいません。
.Sp
最上位の form 生成は自動的に行なわれます:
フォーマットされたレコードに対して、現在のページに十分な空きがない
場合、改頁が書き込まれて、次のページに移ります。
新しいページのヘッダには、特別なページ先頭フォーマットが使われ、
その後レコードが書き込まれます。
デフォルトでページ先頭フォーマットは、
ファイルハンドルの名前に \*(L"_TOP\*(R" を付け加えたものになりますが、
ファイルハンドルが select されているときは、$^ 変数に名前を割り当てる
ことで、好きなフォーマットを動的にセットしてもかまいません。
現在のページに残っている行数は、変数 $- に保持されていますが、0 を
セットすることがで、強制的に新しいページに移ることができます。
.Sp
FILEHANDLE が指定されないと、現在のデフォルト出力チャンネルに
出力されます。デフォルト出力は、起動時
.I STDOUT
ですが、
.I select
演算子で変更できます。
FILEHANDLE が EXPR のとき、その式が実行時に評価され、結果の文字列が
FILEHANDLE の名前として用いられます。
フォーマットについての詳細は、後述のフォーマットのセクションを
参照して下さい。
.Sp
write は read の*逆ではない*ことに注意して下さい。
.Sh "優先度"
.I perl
の演算子は次のような結合規則と優先度を持っています:
.nf

なし\h'|1i'print printf exec system sort reverse
\h'1.5i'chmod chown kill unlink utime die return
左から右\h'|1i',
右から左\h'|1i'= += \-= *= など
右から左\h'|1i'?:
なし\h'|1i'.\|.
左から右\h'|1i'||
左から右\h'|1i'&&
左から右\h'|1i'| ^
左から右\h'|1i'&
なし\h'|1i'== != <=> eq ne cmp
なし\h'|1i'< > <= >= lt gt le ge
なし\h'|1i'chdir exit eval reset sleep rand umask
なし\h'|1i'\-r \-w \-x など
左から右\h'|1i'<< >>
左から右\h'|1i'+ \- 
左から右\h'|1i'* / % x
左から右\h'|1i'=~ !~ 
右から左\h'|1i'! ~ 単項の-
右から左\h'|1i'**
なし\h'|1i'++ \-\|\-
左から右\h'|1i'\*(L'(\*(R'

.fi
始めの方で述べたように、リストを引数にする演算子 (print 他) や、
任意の単項演算子 (chdir 他) のすぐ後に同じ行の次のトークンとして
左括弧がある場合、括弧の中の演算子と引数は、丁度通常の
ファンクションコールと同様に再優先とみなされます。
例:
.nf

	chdir $foo || die;\h'|3i'# (chdir $foo) || die
	chdir($foo) || die;\h'|3i'# (chdir $foo) || die
	chdir ($foo) || die;\h'|3i'# (chdir $foo) || die
	chdir +($foo) || die;\h'|3i'# (chdir $foo) || die

しかし、* は || よりも優先度が高いので:

	chdir $foo * 20;\h'|3i'# chdir ($foo * 20)
	chdir($foo) * 20;\h'|3i'# (chdir $foo) * 20
	chdir ($foo) * 20;\h'|3i'# (chdir $foo) * 20
	chdir +($foo) * 20;\h'|3i'# chdir ($foo * 20)

	rand 10 * 20;\h'|3i'# rand (10 * 20)
	rand(10) * 20;\h'|3i'# (rand 10) * 20
	rand (10) * 20;\h'|3i'# (rand 10) * 20
	rand +(10) * 20;\h'|3i'# rand (10 * 20)

.fi
括弧がないと、print, sort, chmod といったリストを引数に持つ演算子は、
演算子の左側を見ているか右側を見ているかによって、非常に高くも
非常に低くもなります。
例えば、次の例で
.nf

	@ary = (1, 3, sort 4, 2);
	print @ary;		# 1324 を出力

.fi
sort の右側のコンマは、sort の前に評価されますが、左側のコンマは、
後で評価されます。
言い換えると、リストを引数に取る演算子は、それに続くすべての引数を
拾う傾向にあり、前の式にしたがって単一の命令語のように振舞います。
括弧に注意深くなければいけないことを覚えておいて下さい:
.nf

.ne 3
	# これらを評価すると、print を実行する前に exit します。
	print($foo, exit);	# 明らかにやりたいこととは違います
	print $foo, exit;	# これもそう

.ne 4
	# これらは、exit を評価する前に print を実行します。
	(print $foo), exit;	# これはやりたいことです
	print($foo), exit;	# これもそう
	print ($foo), exit;	# さらにこれも

また、これは

	print ($foo & 255) + 1, "\en";

.fi
多分一目見て期待する動作とは違うことを実行するでしょう。
.Sh "サブルーチン"
サブルーチンは次のように宣言されます:
.nf

    sub NAME BLOCK

.fi
.PP
ルーチンに渡されたすべての引数は、配列 @_ に入ります。
これは、($_[0], $_[1], .\|.\|.) です。
配列 @_ はローカル配列ですが、その値は実際のスカラパラメータへの参照
になります。
サブルーチンの戻り値は、最後の式が評価されたときの値で、配列値にも
スカラ値にもなり得ます。
また、リターン文は戻り値を指定してサブルーチンを抜けることにも
使われます。
ローカル変数を作成するには、
.I local
演算子を参照して下さい。
.PP
サブルーチンは、
.I do
演算子かまたは & 演算子を使って呼ばれます。
.nf

.ne 12
例:

	sub MAX {
		local($max) = pop(@_);
		foreach $foo (@_) {
			$max = $foo \|if \|$max < $foo;
		}
		$max;
	}

	.\|.\|.
	$bestday = &MAX($mon,$tue,$wed,$thu,$fri);

.ne 21
例:

	# 行を取得し、空白で始まる行は
	# 続きの行として結合されます。
	sub get_line {
		$thisline = $lookahead;
		line: while ($lookahead = <STDIN>) {
			if ($lookahead \|=~ \|/\|^[ \^\e\|t]\|/\|) {
				$thisline \|.= \|$lookahead;
			}
			else {
				last line;
			}
		}
		$thisline;
	}

	$lookahead = <STDIN>;	# 最初の行を取得します
	while ($_ = do get_line(\|)) {
		.\|.\|.
	}

.fi
.nf
.ne 6
引数に名前を付けるには、ローカルリストへの配列の代入を使います:

	sub maybeset {
		local($key, $value) = @_;
		$foo{$key} = $value unless $foo{$key};
	}

.fi
代入は値をコピーするので、これは参照呼び出しを値呼び出しに換える効果も
あります。
.Sp
サブルーチンは再帰的に呼び出せます。
サブルーチンが & の型を使って呼び出されるとき、引数リストは省略
できます。
省略されると、サブルーチンには @_ 配列がセットされません;
その代わり、呼び出し時に @_ 配列は、サブルーチンには可視となります。
.nf

	do foo(1,2,3);		# 三つの引数を渡します
	&foo(1,2,3);		# 上と同じです

	do foo();		# ヌルリストを渡します
	&foo();			# 上と同じです
	&foo;			# 引数を渡しません\*(--より効率的

.fi
.Sh "参照渡し"
サブルーチンへ配列の値を渡すのではなく、その名前を渡して、サブルーチン
がローカルなコピーに対してではなくグローバルな配列を変更できるように
したいときがあるでしょう。
perl では名前を持つすべてのオブジェクトに対して、その名前の前に * を
つけて参照できます: *foo のように。
これが評価されると、ファイルハンドル、フォーマット、サブルーチンを含む、
その名前を持つすべてのオブジェクトを表すスカラ値となります。
local() 演算子に代入されたとき、その名前がそれに代入された * 値を
参照するようになります。
例:
.nf

	sub doubleary {
	    local(*someary) = @_;
	    foreach $elem (@someary) {
		$elem *= 2;
	    }
	}
	do doubleary(*foo);
	do doubleary(*bar);

.fi
*name への代入は今のところ local() の中でしか勧められません。
実際には *name への代入はどこででもできますが、それ以前の *name への
参照が永遠に尾を引くかもしれません。
これにより困ったことになるかもしれませんし、ならないかもしれません。
.Sp
スカラはすでに参照渡しですが、このメカニズムを用いなくても、
関心のある $_[nnn] への明示的な参照を行うことで、スカラの引数を
変更することができます。
すべての要素をスカラで渡すことで、すべての配列の要素を変更することが
できますが、push や pop 、配列のサイズの変更には * メカニズムを
使わなければなりません。
どんな場合でも、* メカニズムは多分、より効率が良いはずです。
.Sp
*name 値は表示不能なバイナリデータを含むので、print の引数または printf 
や sprintf の %s 引数として使われると、表示を綺麗にするため '*name' と
いう値になります。
.Sp
通常 LIST メカニズムはすべての配列値をマージしてしまって、個々の配列を
取り出せなくなってしまうので、配列を変更したくないとしても、
このメカニズムは一つの LIST にたくさんの配列を渡すのに便利です。
.Sh "正規表現"
パターンマッチで使われるパターンは、バージョン 8 regexp ルーチンで供給
されているものと同じ正規表現です。
(実際、このルーチンは Henry Spencer の自由に再配布可能な再実装 V8 ルーチン
から抜き取って使われています。)
それに加えて、\ew は英数字 (\*(L"_\*(R" を含む) にマッチし、
\eW は非英数字にマッチします。
単語境界は \eb に、非単語境界は \eB に。
空白文字は \es に、非空白文字は \eS に。
数字は \ed に、非数字は \eD にマッチします。
\ew, \es, \ed はキャラクタクラスでも使えます。
また、\en, \er, \ef, \et, \eNNN は通常と同じ意味となります。
キャラクタクラスの中では、\eb は単語境界ではなく、
バックスペースを表します。
選択候補は、| で区切ります。
括弧構造 \|(\ .\|.\|.\ \|) を使うと、\e<数字> はその数字番目の
部分文字列にマッチします。
(パターンの外では、数字の前に \e の代わりに常に $ を用いなければ
なりません。$<数字> (と $\`, $&, $\') の有効範囲は、閉じたブロックの
終りか、eval 文字列か、次のパターンマッチまでとなります。
\e<数字> 記述は、ときに現在のパターンの外に作用しますが、それに頼って
はいけません。)
括弧は好きなだけたくさん使ってかまいません。9 個以上の部分文字列が
あると、変数 $10, $11, ... が対応する部分文字列を参照します。
後方参照の前に少なくともその数の左括弧があると、パターンの中では、
\e10, \e11 等が部分文字列を後方参照します。
そうでなければ (以前との互換性のために) \e10 は \e010 のバックスペースと
同じ、\e11 は \e011 のタブと同じというようになります。
(\e1 から \e9 は常に後方参照です。)
.PP
$+ は、最後の括弧でマッチしたものを返します。
$& は、マッチした文字列全体を返します。
($0 が同じものを返していましたが、今は違います。)
$\` はマッチした文字列の前の全文字列を返します。
$\' はマッチした文字列の後の全文字列を返します。
例:
.nf
    
	s/\|^\|([^ \|]*\|) \|*([^ \|]*\|)\|/\|$2 $1\|/;	# 最初の二語を交換

.ne 5
	if (/\|Time: \|(.\|.\|):\|(.\|.\|):\|(.\|.\|)\|/\|) {
		$hours = $1;
		$minutes = $2;
		$seconds = $3;
	}

.fi
デフォルトで、^ 文字は文字列の先頭に、$ 文字は文字列の最後
(または最後の改行文字の前) にマッチすることが保障されており、
.I perl
は文字列が一行しか含んでいないという仮定のもとで、
ある最適化を行なっています。
改行が埋め込まれた場合の ^ や $ の振舞いは、矛盾を生じるでしょう。
しかし、^ が文字列内の任意の改行の後に、$ が改行の前にマッチするよう
な、文字列を複数行バッファとして使いたい場合があるかもしれません。
少々のオーバヘッドを覚悟すれば、変数 $* に 1 をセットすることで、
それができます。
$* を 0 に設定し直せば、
.I perl
は元の動作に戻ります。
.PP
複数行の置換を用意にするために、. 文字は改行文字にはマッチしません
(たとえ $* が 0 であっても) 。
特に次の例では、改行文字が $_ 文字列に残ります:
.nf

	$_ = <STDIN>;
	s/.*(some_string).*/$1/;

改行文字が要らないなら、次のどれかを試して下さい。

	s/.*(some_string).*\en/$1/;
	s/.*(some_string)[^\e000]*/$1/;
	s/.*(some_string)(.|\en)*/$1/;
	chop; s/.*(some_string).*/$1/;
	/(some_string)/ && ($_ = $1);

.fi
正規表現のどの要素の後でも中括弧で囲んだ数字を {n,m} の形で
置くことができ、n で要素がマッチする最小の回数を、m で最大の回数を
指定します。
{n} の形は、{n,n} と同等で、正確に n 回にマッチします。
{n,} の形は、n 回以上にマッチします。
(中括弧が他のコンテキストの中に出て来た場合は、通常の文字として
扱われます。)
* 修飾子は {0,} と、+ 修飾子は {1,} と、? 修飾子は {0,1} と
同等となります。
n と m のサイズには制限がありませんが、大きい数字はより多くのメモリを
消費するでしょう。
.Sp
.I perl
では、
\eb, \ew, \en のような
バックスラッシュのつくメタキャラクタは、すべて英数字であること
に気がつかれることでしょう。
他の正規表現言語とは違って、英数字でないバックスラッシュシンボルは
ありません。
従って、\e\e, \e(, \e), \e<, \e>, \e{, \e} というようなものは皆、
メタキャラクタではなく、文字そのものとして解釈されます。
これにより、メタキャラクタに含まれるのではないかと心配になるような
文字列をパターンに使って、引用することが容易になります。
英数字でないすべての文字の引用は、このようにします:
.nf

	$pattern =~ s/(\eW)/\e\e$1/g;

.fi
.Sh "フォーマット"
.I write
演算子で使う出力レコードフォーマットは、次のように
宣言します:
.nf

.ne 3
    format NAME =
    FORMLIST
    .

.fi
NAME を省略すると、\*(L"STDOUT\*(R" フォーマットが定義されます。
FORMLIST は複数行から成り、各行は次の三つの型のいずれかとなります:
.Ip 1. 4
コメント
.Ip 2. 4
一つの出力行のフォーマットを示す \*(L"picture\*(R" 行
.Ip 3. 4
picture 行に値を与える引数行
.PP
picture 行は、その中で値が置換される特定のフィールドを除けば、
見た目そのままに出力されます。
各 picture フィールドは、@ か ^ で始まります。
@ フィールド (配列の先頭の @ と混乱しないように) は通常の場合
で、^ フィールドは基本的な複数行テキストブロックを埋めるのに
使われます。
フィールドの長さは、<, >, | の繰り返しで埋めることで指定し、それぞれ
左寄せ、右寄せ、センタリングを意味します。
右寄せの別な形として、# 文字を (それに . を付けても良い) 
数字フィールドの指定として使うこともできます。
(@ のかわりに ^ を使うと、undefined なフィールドが空白になります。)
これらのフィールドに与えられた値が改行を含むと、改行までのテキスト
のみが出力されます。
特殊フィールド @* は複数行の値の出力に使われます。
その行に書かれているのは @* だけでなくてはいけません。
.PP
値は、次の行で指定され、picture フィールドと同じ順となります。
値はコンマで区切られていなければなりません。
.PP
@ でなく ^ で始まる picture フィールドは、特別な扱いになります。
指定する値は、テキスト文字列が入っているスカラ変数名でなければ
いけません。
.I perl
は、フィールドに入れられるだけたくさんのテキストを入れ、変数が次に参照
されるときに続きが出力されるように、文字列の先頭からそのテキストを削ります。
通常、テキストのブロックを出力するには、垂直なスタックの中にフィールド
の一続きを入れて使います。
全部を入れるにはテキストが長すぎるとき、そうしたければ
最後のフィールドを .\|.\|. で終らせることもできます。
変数 $: を好きな文字のリストにすることで、テキストを分割する文字を
変えることができます。
.PP
^ フィールドを使うと、可変長のレコードを生成するので、テキストの
フォーマットを短くしたいとき、チルダ (~) 文字を行のどこかに入れて
空行を抑制することができます。
(可読性を高めるため、普通はできれば行頭に入れるべきです。)
チルダは出力時には空白に変換されます。
一つ目に続けて二つ目のチルダを書くと、行中のすべてのフィールドが
なくなるまで、その行を繰り返します。
(いろいろな @ のフィールドを使うとき、与える式はいつも同じ値ではない方が
良いでしょう。)
.PP
例:
.nf
.lg 0
.cs R 25
.ft C

.ne 10
# /etc/passwd ファイルの形式
format STDOUT_TOP =
\&                        Passwd File
Name                Login    Office   Uid   Gid Home
------------------------------------------------------------------
\&.
format STDOUT =
@<<<<<<<<<<<<<<<<<< @||||||| @<<<<<<@>>>> @>>>> @<<<<<<<<<<<<<<<<<
$name,              $login,  $office,$uid,$gid, $home
\&.

.ne 29
# バグレポート形式
format STDOUT_TOP =
\&                        Bug Reports
@<<<<<<<<<<<<<<<<<<<<<<<     @|||         @>>>>>>>>>>>>>>>>>>>>>>>
$system,                      $%,         $date
------------------------------------------------------------------
\&.
format STDOUT =
Subject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&         $subject
Index: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&       $index,                       $description
Priority: @<<<<<<<<<< Date: @<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&          $priority,        $date,   $description
From: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&      $from,                         $description
Assigned to: @<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&             $programmer,            $description
\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                     $description
\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                     $description
\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                     $description
\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                     $description
\&~                                    ^<<<<<<<<<<<<<<<<<<<<<<<...
\&                                     $description
\&.

.ft R
.cs R
.lg
.fi
同じ出力チャンネルに対して、write を使って出力を混ぜることはできます
が、$\- (ページの残り行数) を自分でいじらなければなりません。
.PP
ほとんどが空白のフィールドがたくさんあるとき、
レコード間で reset 演算子を使うことを考えるべきです。
効率的であるというだけでなく、別のフィールドを加えてしまい、0 に
し忘れてしまうというバグを防ぐことができます。
.Sh "プロセス間通信"
perl の プロセス間通信(IPC)の能力は Berkeley のソケット機構に
基づいています。
ソケットが無ければ、このセクションは無視できます。
この呼び出しは、同名のシステムコールに相当しますが、
二つの理由で大抵引数は異なります。
一つ目は、perl のファイルハンドルは C ファイルディスクリプタとは
異なる動作をするということです。
二つ目は、perl は文字列の長さを知っているので、その情報を渡さなくても
良いということです。
以下がクライアントのサンプル (未テスト) です:
.nf

	($them,$port) = @ARGV;
	$port = 2345 unless $port;
	$them = 'localhost' unless $them;

	$SIG{'INT'} = 'dokill';
	sub dokill { kill 9,$child if $child; }

	require 'sys/socket.ph';

	$sockaddr = 'S n a4 x8';
	chop($hostname = `hostname`);

	($name, $aliases, $proto) = getprotobyname('tcp');
	($name, $aliases, $port) = getservbyname($port, 'tcp')
		unless $port =~ /^\ed+$/;
.ie t \{\
	($name, $aliases, $type, $len, $thisaddr) = gethostbyname($hostname);
'br\}
.el \{\
	($name, $aliases, $type, $len, $thisaddr) =
					gethostbyname($hostname);
'br\}
	($name, $aliases, $type, $len, $thataddr) = gethostbyname($them);

	$this = pack($sockaddr, &AF_INET, 0, $thisaddr);
	$that = pack($sockaddr, &AF_INET, $port, $thataddr);

	socket(S, &PF_INET, &SOCK_STREAM, $proto) || die "socket: $!";
	bind(S, $this) || die "bind: $!";
	connect(S, $that) || die "connect: $!";

	select(S); $| = 1; select(stdout);

	if ($child = fork) {
		while (<>) {
			print S;
		}
		sleep 3;
		do dokill();
	}
	else {
		while (<S>) {
			print;
		}
	}

.fi
これがサーバ側です:
.nf

	($port) = @ARGV;
	$port = 2345 unless $port;

	require 'sys/socket.ph';

	$sockaddr = 'S n a4 x8';

	($name, $aliases, $proto) = getprotobyname('tcp');
	($name, $aliases, $port) = getservbyname($port, 'tcp')
		unless $port =~ /^\ed+$/;

	$this = pack($sockaddr, &AF_INET, $port, "\e0\e0\e0\e0");

	select(NS); $| = 1; select(stdout);

	socket(S, &PF_INET, &SOCK_STREAM, $proto) || die "socket: $!";
	bind(S, $this) || die "bind: $!";
	listen(S, 5) || die "connect: $!";

	select(S); $| = 1; select(stdout);

	for (;;) {
		print "Listening again\en";
		($addr = accept(NS,S)) || die $!;
		print "accept ok\en";

		($af,$port,$inetaddr) = unpack($sockaddr,$addr);
		@inetaddr = unpack('C4',$inetaddr);
		print "$af $port @inetaddr\en";

		while (<NS>) {
			print;
			print NS;
		}
	}

.fi
.Sh "予約変数"
次の変数名は、
.IR perl
にとって特別な意味があります。
これらのうち幾つかはアルファベットのシンボルにもしても良かったのですが、
reset \*(L"a\-zA\-Z\*(R" で予約変数まで消されてしまうようなことに
したくなかったのです。
そのため、これらのおかしなシンボル名に悩まされなければならないでしょう。
そのうち多くは筋が通ったニーモニック (記憶方法) で、シェルのものと
類似になっています。
.Ip $_ 8
入力およびパターン検索のデフォルト。
次の組はそれぞれ同等です:
.nf

.ne 2
	while (<>) {\|.\|.\|.	# while の中でのみ同等
	while ($_ = <>) {\|.\|.\|.

.ne 2
	/\|^Subject:/
	$_ \|=~ \|/\|^Subject:/

.ne 2
	y/a\-z/A\-Z/
	$_ =~ y/a\-z/A\-Z/

.ne 2
	chop
	chop($_)

.fi
(覚え方: 下線は実行されるとわかる。)
.Ip $. 8
最後に読み込まれたファイルハンドルの現在の行番号。
読み出し専用。
明示的なファイルハンドルの close でのみ行番号がリセットされることを
覚えておいて下さい。
<> は明示的な close を行なわないので、ARGV ファイル全部を通して行番号
が増えていきます (eof の例を参照して下さい) 。
(覚え方: 多くのプログラムは . を現在行番号の意味で使う。)
.Ip $/ 8
入力レコードの区切り文字。デフォルトは改行。
ヌル文字列にセットされると空行を区切りとして扱うことも含めて、
.IR awk
の RS 変数と同じ働きをします。
複数文字にセットすると複数文字区切りにマッチさせることができます。
ファイルに空行が連続してあるとき、
この変数を "\en\en" にセットすると、"" にセットする場合と
少々異なる意味を持つことに注意して下さい。
"" にセットすると、二つかそれ以上の連続した空行を一つの空行として
扱います。 "\en\en" にセットすると、空行の後にたとえ改行文字が
続いていても、次の段落に含まれているものと盲目的に解釈されます。
(覚え方: / は詩をクォートするとき行境界の区切りとして使える。)
.Ip $, 8
print 演算子のための出力フィールド区切り文字。
通常は、print 演算子は単にコンマ区切りで指定したフィールドを
出力します。より
.IR awk
に似た挙動をさせるためには、フィールド間に出力する文字を
指定する
.IR awk
の OFS 変数と同じものを、この変数をセットして下さい。
(覚え方: print文に , があるとき出力すべきもの。)
.Ip $"" 8
$, と似ていますが、この変数の異なる点は、"" で囲まれた
文字列 (または同様な挿入文字) に挿入される配列値に適用されることです。
デフォルトは空白文字です。
(覚え方: これは明白。)
.Ip $\e 8
print 演算子の出力レコードセパレータ文字。
通常 print 演算子は、後に改行やレコードセパレータ文字を続いていないと
推定して、単にコンマ区切りの指定フィールドを出力します。
より
.IR awk
に似た挙動をさせるためには、print の終りに出力する文字を指定する
.IR awk
の ORS 変数と同じものをこの変数にセットして下さい。
(覚え方: print の終りに \en を加える代わりに $\e をセット。)
/ にも似ていますが、
.IR perl
から \*(L"得る\*(R" ものです。)
.Ip $# 8
数字の出力のための出力フォーマット。
この変数は
.IR awk
の OFMT 変数を半分だけ受け継いでいます。
しかし
.I awk
と
.I perl
では、実際に何が数字であるかという概念の異なることがしばしばあります。
初期値も、%.6g でなく %.20g ですので、
.IR awk
の値を得るには、明示的に $# をセットする必要があります。
(覚え方: # は数字の記号。)
.Ip $% 8
現在 select されている出力チャンネルの現在のページ番号。
(覚え方: % は nroff におけるページ番号。)
.Ip $= 8
現在 select されている出力チャンネルの現在のページ長 (出力可能行) 。
デフォルトは 60 。
(覚え方: = は平行線。)
.Ip $\- 8
現在 select されている出力チャンネルのページの残り行数。
(覚え方: 1 ページの行数 \- 出力済み行数)
.Ip $~ 8
現在 select されている出力チャンネルの現在のレポートフォーマット名。
デフォルトは、ファイルハンドル名。
(覚え方: $^ の仲間。)
.Ip $^ 8
現在 select されている出力チャンネルの現在のページ先頭フォーマット名。
デフォルトは、ファイルハンドル名に \*(L"_TOP\*(R" を加えたもの。
(覚え方: 先頭ページを指す。)
.Ip $| 8
0 でない値をセットすると、現在 select されている出力チャンネルに
write や print が行なわれる毎にフラッシュします。
デフォルトは 0 。
通常
.I STDOUT
は、端末に出力するときは行バッファが使われ、それ以外では
ブロックバッファが使われることに注意して下さい。
この変数をセットするのは、
.I perl
スクリプトを rsh の基で走らせている時等、
パイプに出力している時に、
出力が起こる度に確認したい場合に便利です。
(覚え方: パイプを常に動かしておきたい。)
.Ip $$ 8
.I perl
が走らせているスクリプトのプロセス番号。
(覚え方: シェルと同じ。)
.Ip $? 8
最後に close したパイプや (\`\`) コマンドや
.I system
演算子の戻り値。
これは、wait() システムコールが返すステータスなので、サブプロセスの
終了値は実際は ($? >> 8) です。
プロセスを終了させたシグナルがあった場合、$? & 255 は
どのシグナルであるか、dump された core があるかどうかを返します。
(覚え方: sh や ksh と同じ。)
.Ip $& 8 4
最後に成功したパターンマッチでマッチした文字列。
(ブロック内や現在のブロックで閉じた eval でのマッチは含まれません。)
(覚え方: あるエディタの & と同じ。)
.Ip $\` 8 4
最後にパターンマッチに成功したパターンの前にある文字列。
(ブロック内や現在のブロックで閉じた eval でのマッチは含まれません。)
(覚え方: \` は大抵クォートされた文字列の前。)
.Ip $\' 8 4
最後にパターンマッチに成功したパターンの後ろにある文字列。
(ブロック内や現在のブロックで閉じた eval でのマッチは含まれません。)
(覚え方: \' は大抵クォートされた文字列の後。)
例:
.nf

.ne 3
	$_ = \'abcdefghi\';
	/def/;
	print "$\`:$&:$\'\en";  	# abc:def:ghi を出力

.fi
.Ip $+ 8 4
最後に検索したパターンの最後の括弧にマッチします。
これは、複数候補のパターンマッチでどちらにマッチするかわからない
ときに便利です。
例:
.nf

    /Version: \|(.*\|)|Revision: \|(.*\|)\|/ \|&& \|($rev = $+);

.fi
(覚え方: 正で、前方を見ること。)
.Ip $* 8 2
文字列内で、複数行のマッチを行なうとき 1 をセットし、
パターンマッチの最適化の目的で、単一行を含む文字列であると
.I perl
に決め打ちにさせるときに 0 とします。
$* が 0 のときに複数の改行を含む文字列のパターンマッチをすると、
混乱した結果となります。
デフォルトは 0 。
(覚え方: * は複数のものにマッチする。)
この変数は、^ や $ の解釈に影響するだけであるということに
注意して下さい。
改行のリテラルは、when $* == 0 としても検索できます。
.Ip $0 8
.I perl
起動したスクリプトのファイル名を保持しています。
$0 修飾子への代入は、ps(1) プログラムの引数の部分を参照して下さい。
(覚え方: sh や ksh と同じ)
.Ip $<数字> 8
最後に行なったパターンマッチで対応する数字番目の括弧のサブパターン。
入れ子になったブロック内で既に終了したパターンマッチの数は含まれません。
(覚え方: \e数字と同じ。)
.Ip $[ 8 2
配列中の最初の要素や部分文字列の最初の文字の添字。
デフォルトは 0 ですが、index() や substr() 関数の
添字のつけ方や評価に関して、
.I perl
を
.I awk
(や Fortran)
の動作にさせるには、この変数に 1 をセットすることでできます。
(覚え方: [ は添字の始まり。)
.Ip $] 8 2
\*(L"perl -v\*(R" で出力される文字列。
これは、perl インタープリタが正しいバージョンの範囲でスクリプトを
実行しているかどうかを決めるために、スクリプトの始めの方で使われます。
数値のコンテキストで使われると、バージョン + パッチレベル / 1000 を
返します。
例:
.nf

.ne 8
	# getcがつかえるかどうかを調べます
        ($version,$patchlevel) =
		 $] =~ /(\ed+\e.\ed+).*\enPatch level: (\ed+)/;
        print STDERR "(No filename completion available.)\en"
		 if $version * 1000 + $patchlevel < 2016;

また、数値で使われると、

	warn "No checksumming!\en" if $] < 3.019;

.fi
(覚え方: このバージョンの perl は right(正しい、右) 括弧に入ってるか? )
.Ip $; 8 2
多次元配列エミュレーションの際の添字の区切り。
連想配列の要素を次のように参照するとき、
.nf
	$foo{$a,$b,$c}

実際には

	$foo{join($;, $a, $b, $c)}

を意味しますが、

	@foo{$a,$b,$c}		# スライス\*(--@ に注意

と書いてはいけません。

	($foo{$a},$foo{$b},$foo{$c})

.fi
を意味することになってしまうからです。
デフォルトは "\e034" で、
.IR awk
の SUBSEP と同じです。
キーとしてバイナリデータを使うと、$; として安全な値はないだろうという
ことに気をつけて下さい。
(覚え方: コンマ (文法上添字の区切り) はセミコロンの半分。
これは、ちょっとひどいね。でも、$, は他のもっと重要なことに
取られているので。)
.Ip $! 8 2
数値のコンテキストで使うと、通常の警告の文字列と共に errono の
現在の値を返します。
(これは、システムエラーのような特別なエラーを除くと、$! の値に
依存した動作をさせてはいけないということを意味します。)
文字列のコンテキストで使うと、相当するシステムエラー文字列を返します。
errno をセットするために $! に代入することができます。
例えば、エラー番号 n に対して $! が文字列を返したいときや、
die 演算子に終了値をセットしたいときなどです。
(覚え方: 一体何が爆発したの? )
.Ip $@ 8 2
最後に評価したコマンドからくる perl の文法エラーメッセージ。
ヌルなら、最後の評価が、正常に解析、実行されたことになります
(起動された演算は普通の形で失敗したかもしれません) 。
(覚え方: 文法エラーはどこに \*(L"アット (at where)\*(R" ?)
.Ip $< 8 2
現在のプロセスの実 uid 。
(覚え方: setuid で走らせているとき、*どこから* きた uid か。)
.Ip $> 8 2
現在のプロセスの実効 uid 。
例:
.nf

.ne 2
	$< = $>;	# 実効 uid に実 uid をセットします
	($<,$>) = ($>,$<);	# 実 uid と実効 uid を取り換えます

.fi
(覚え方: setuid で走らせているとき、*行く先の* uid 。)
注意: $< と $> は setreuid() をサポートしているマシンでだけ
交換できます。
.Ip $( 8 2
現在のプロセスの実 gid 。
同時に複数グループのメンバとなることをサポートしたマシンで、
属しているグループの空白区切りのリストが得られます。
最初の数は getgid() の返すもので、残りが getgroups() の返すものです。
残りの中には最初の数値と同じものも含まれているかもしれません。
(覚え方: 括弧は GROUP に使われる。 setgid スクリプトを走らせているとき、
実 gid は LEFT(残っている、左) のグループ。)
.Ip $) 8 2
現在のプロセスの実効 gid 。
同時に複数グループのメンバとなることをサポートしたマシンで、
属しているグループの空白区切りのリストが得られます。
最初の数は getegid() の返すもので、残りが getgroups() の返すものです。
残りの中には最初の数値と同じものも含まれているかもしれません。
(覚え方: 括弧は GROUP に使われる。 setgid スクリプトを走らせているとき、
実効 gid はあなたの RIGHT(正しい、右の)グループ。)
.Sp
注意: $<, $>, $(,  $) は、相当する set[re][ug]id() ルーチンを
サポートしているマシンでだけセットできます。
$( と $) は setregid() をサポートしているマシンでだけ交換できます。
.Ip $: 8 2
format の (^ で始まる) 継続フィールドを埋めるように文字列を分ける
際の直前の文字列セット。
デフォルトは "\ \en-" で、空白やハイフンで分けられます。
(覚え方: 詩では \*(L"コロン\*(R" は行の一部)
.Ip $^D 8 2
デバッグフラグの現在の値。
(覚え方:
.B \-D
スイッチの値。)
.Ip $^F 8 2
最大システムファイルディスクリプタ数。通常は 2 。
システムファイルディスクリプタは、子プロセスに渡されますが、
それより数字が上のファイルディスクリプタは渡されません。
open する間は、たとえ open に失敗したとしても、
システムファイルディスクリプタは保存されます。
open が試みられる前に、通常のディスクリプタは close されます。
.Ip $^I 8 2
ファイルをその場で変更する場合の拡張子の値。
その場で変更できないようにするには、この変数を undef します。
(覚え方: 
.B \-i
スイッチの値)
.Ip $^L 8 2
改ページするために出力するフォーマット。デフォルトは \ef です。
.Ip $^P 8 2
デバッガが、自分自身をデバッグしないためにクリアする内部フラグ。
これをクリアしておくと、デバッグを不可能にさせられると考えられます。
.Ip $^T 8 2
スクリプトが走り始めた時刻を、epoch からの秒で保持します。
.B \-M ,
.B \-A ,
.B \-C
ファイルテストで返された値は、この変数の値に基づいています。
.Ip $^W 8 2
警告スイッチの現在の値。
(覚え方: 
.B \-w
スイッチに関係する。)
.Ip $^X 8 2
argv[0] から来る、起動された perl 自身の名前。
.Ip $ARGV 8 3
<> から読み込んでいるとき、読み込み中のファイル名を保持します。
.Ip @ARGV 8 3
配列 ARGV は、スクリプトに渡されたコマンドライン引数を保持します。
$ARGV[0] はコマンド名ではなく、最初の引数なので、$#ARGV は一般に
引数の数 -1 です。
コマンド名については、$0 を参照して下さい。
.Ip @INC 8 3
配列 INC は、
.I perl
スクリプトが \*(L"do EXPR\*(R" や \*(L"require\*(R" で評価されるときに
探されるべきディレクトリのリストを保持します。
初期値として、
.B \-I
コマンドラインスイッチの引数、
これに続きデフォルトの
.I perl
ライブラリ (おそらく \*(L"/usr/share/perl\*(R")、
これに続きカレントディレクトリを示す \*(L".\*(R" です。
.Ip %INC 8 3
連想配列 INC は、\*(L"do\*(R" や \*(L"require\*(R" を介してインクルー
ドされる各ファイル名のためのエントリを含んでいます。
キーは、指定したファイル名で、値は実際にファイルが見つかった
位置の値です。
この配列は、\*(L"require\*(R" コマンドが与えるファイルが既に
インクルード済みかどうかを決めるのに使われます。
.Ip $ENV{expr} 8 2
連想配列 ENV は、現在の環境変数を保持しています。
ENV へ値を設定すると、子プロセスの環境が変わります。
.Ip $SIG{expr} 8 2
連想配列 SIG は、各シグナルハンドラをセットするのに使われます。
例:
.nf

.ne 12
	sub handler {	# 第一引数はシグナル名
		local($sig) = @_;
		print "Caught a SIG$sig\-\|\-shutting down\en";
		close(LOG);
		exit(0);
	}

	$SIG{\'INT\'} = \'handler\';
	$SIG{\'QUIT\'} = \'handler\';
	.\|.\|.
	$SIG{\'INT\'} = \'DEFAULT\';	# デフォルト動作に戻す
	$SIG{\'QUIT\'} = \'IGNORE\';	# SIGQUIT を無視する

.fi
SIG 配列は、perl スクリプトで実際にシグナル用にセットされた値を
保持しています。
.Sh "パッケージ"
perl は、パッケージ間で異なる名前空間持つメカニズムを用意しており、
各々の変数がぶつからないように、パッケージを守っています。
デフォルトで、perl スクリプトはパッケージ \*(L"main\*(R" として
コンパイルを始めます。
.I package
宣言を使うことによって、名前空間を切り替えることができます。
パッケージ宣言の有効範囲は、宣言それ自身から、閉じたブロックの終端まで
です (local() 演算子と同じ有効範囲) 。
普通 \*(L"require\*(R" 演算子によりインクルードされたファイルの中の
最初の宣言として使われます。
複数箇所で同一パッケージに入ることが出来ます;
ブロック中でコンパイラがどのシンボルテーブルを使うかに影響するだけです。
他のパッケージの変数やファイルハンドルは、識別子の前にパッケージ名と
シングルクォートを付けることで、参照できます。
パッケージ名がヌルの場合、\*(L"main\*(R" と解釈されます。
.PP
文字で始まる識別子は、パッケージシンボルテーブルに保存されます。
それ以外のすべてのシンボルは、パッケージ \*(L"main\*(R" に保持されます。
更に、識別子 STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, SIG は、
たとえ組み込みの変数、関数と異なる目的で使われたとしても、
強制的にパッケージ \*(L"main\*(R" に属するものとして扱われます。
仮に、\*(L"m\*(R", \*(L"s\*(R", \*(L"y\*(R" と呼ばれるパッケージを
持っていたとすると、パターンマッチ、代入、変換として解釈されるので、
識別子を適した形で使うことができないことに注意しましょう。
.PP
eval された文字列は、eval がコンパイルされたパッケージ内で
コンパイルされます。
(しかし、$SIG{} への代入は、main パッケージで指定された
シグナルハンドラと解釈されます。パッケージ内でシグナルハンドラを
持ちたい場合、シグナルハンドラ名を適切に指定して下さい。)
例えば、perl ライブラリ内の perldb.pl を調べてみましょう。
これは始めに DB パッケージに切り替わり、デバッガがデバッグしようとして
いるスクリプト内の変数を変更しないようになっています。
しかし、いろいろな時点で、main パッケージのコンテキストのいろいろな
式を評価するために、これは main パッケージに一時的に戻って来ています。
.PP
パッケージのシンボルテーブルは、パッケージ名の前に下線のついた連想配列に
蓄えられることになります。
連想配列の各エントリの値は、*name 表記を使うときに参照しようと
しているものになります。
実際、次の例は同じ効果 (もちろん main パッケージの場合) がありますが、
最初のものの方がコンパイル時にシンボルテーブルを見るので、
より効率が良くなります:
.nf

.ne 2
	local(*foo) = *bar;
	local($_main{'foo'}) = $_main{'bar'};

.fi
例えば、以下によりパッケージ内のすべての変数を出力できます。
これは perl ライブラリの dumpvar.pl から取っています:
.nf
.ne 11
	package dumpvar;

	sub main'dumpvar {
	\&    ($package) = @_;
	\&    local(*stab) = eval("*_$package");
	\&    while (($key,$val) = each(%stab)) {
	\&        {
	\&            local(*entry) = $val;
	\&            if (defined $entry) {
	\&                print "\e$$key = '$entry'\en";
	\&            }
.ne 7
	\&            if (defined @entry) {
	\&                print "\e@$key = (\en";
	\&                foreach $num ($[ .. $#entry) {
	\&                    print "  $num\et'",$entry[$num],"'\en";
	\&                }
	\&                print ")\en";
	\&            }
.ne 10
	\&            if ($key ne "_$package" && defined %entry) {
	\&                print "\e%$key = (\en";
	\&                foreach $key (sort keys(%entry)) {
	\&                    print "  $key\et'",$entry{$key},"'\en";
	\&                }
	\&                print ")\en";
	\&            }
	\&        }
	\&    }
	}

.fi
たとえサブルーチンがパッケージ dumpvar でコンパイルされるとしても、
サブルーチン名がパッケージ \*(L"main\*(R" に挿入されるように、
サブルーチン名の前にパッケージ名をつけなければならないことに注意して
下さい。
.Sh "スタイル"
各々のプログラマは、フォーマットに関してもちろん自分自身の好みが
あるでしょうが、自分のプログラムを読み易くするための一般的な
ガイドラインがあります。
.Ip 1. 4 4
あることを特別な方法で*できる*からといって、そうしなければならない
ということはありません。
.I perl
は、一つのことをするときに、幾つかの方法があるように設計されている
ので、最も読み易いものを選ぶように考えて下さい。
例えば

	open(FOO,$foo) || die "Can't open $foo: $!";

は、

	die "Can't open $foo: $!" unless open(FOO,$foo);

よりも良いです。なぜなら、後者の方法は文の主題を修飾子内に隠しているからです。
一方、

	print "Starting analysis\en" if $verbose;

は

	$verbose && print "Starting analysis\en";

より良いです。主となるのは、ユーザが -v を打ったかどうかでは
ないからです。
.Sp
同様に、演算子がデフォルトの引数を仮定しているからといって、
それはデフォルトを用いなければならないということではありません。
デフォルトというものは、ちょっとしたプログラムを書く、怠け者の
システムプログラマのためにあります。
読み易いプログラムをしたければ、引数を付けるようにして下さい。
.Sp
同じようなこととして、
あちこちで括弧を省略
.I できる
ということは、以下のように書けということではありません:
.nf

	return print reverse sort num values array;
	return print(reverse(sort num (values(%array))));

.fi
疑わしいときは、括弧をつけて下さい。
もしかすると、物好きな輩が、vi で % キーを叩くかもしれません。
.Sp
たとえ疑わしくなかったとしても、自分の後でそのコードを管理する人間の
精神衛生上好ましいですし、その人が間違ったところに括弧をつける可能性も
大いにあります。
.Ip 2. 4 4
無理にこじつけて、ループの先頭や終わりで終了しようとしないで下さい。
.I perl
には、真ん中からでも抜けられるように "last" 演算子が
用意されているのですから。
少々はみ出しても、より見易くなるようにして下さい:
.nf

.ne 7
    line:
	for (;;) {
	    statements;
	last line if $foo;
	    next line if /^#/;
	    statements;
	}

.fi
.Ip 3. 4 4
ループラベルを使うのを恐がらないで下さい\*(--多重ループの抜けだしがで
きるようにするためだけでなく、可読性を高めるためにあるのですから。
最後の例を参照して下さい。
.Ip 4. 4 4
可搬性のため、すべてのマシンには実装されていない機能を使うときは、
失敗しないかどうか、eval の中で構成を確かめてみて下さい。
どのバージョンやパッチレベルで特定の仕様が実装されているかを
知っているなら、$] を調べて、実装されているかどうかを確認できます。
.Ip 5. 4 4
覚え易い識別子を選んで下さい。
.Ip 6. 4 4
一貫性を持たせましょう。
.Sh "デバッグ"
.I perl
に
.B \-d
スイッチを付けて起動すると、デバッグモニタの基でスクリプトが走ります。
最初の実行文の前で一時停止し、以下のようなコマンド入力を促します:
.Ip "h" 12 4
ヘルプメッセージを出力する。
.Ip "T" 12 4
スタックトレース。
.Ip "s" 12 4
シングルステップ。
次の文の始めに達するまでを実行します。
.Ip "n" 12 4
次。
サブルーチンコール内では止まらずに、次の文に達するまで実行します。
.Ip "f" 12 4
終了。
現在のサブルーチンが終了するまで、文を実行し続けます。
.Ip "c" 12 4
継続。
次のブレークポイントに達するまで実行します。
.Ip "c line" 12 4
指定した行まで実行します。
指定した行に、一回きりのブレークポイントを挿入します。
.Ip "<CR>" 12 4
最後に実行した n または s を繰り返します。
.Ip "l min+incr" 12 4
min 行目から incr+1 行を表示します。
min を省略すると、最後に表示した残りから始めます。
incr を省略すると、前回の incr 値が使われます。
.Ip "l min-max" 12 4
指定範囲内の行を表示します。
.Ip "l line" 12 4
指定行を表示します。
.Ip "l" 12 4
次のウィンドウを表示します。
.Ip "-" 12 4
前のウィンドウを表示します。
.Ip "w line" 12 4
その行と前後のウィンドウを表示します。
.Ip "l subname" 12 4
サブルーチンを表示します。
長いサブルーチンの場合は、始めの方だけを表示します。
それ以上表示するには、\*(L"l\*(R" を使って下さい。
.Ip "/pattern/" 12 4
正規表現の前方検索。最後の / は省略可能です。
.Ip "?pattern?" 12 4
正規表現の後方検索。最後の ? は省略可能です。
.Ip "L" 12 4
ブレークポイントまたはアクションの設定された行を表示します。
.Ip "S" 12 4
すべてのサブルーチン名を表示します。
.Ip "t" 12 4
トレースモードを on/off するトグル。
.Ip "b line condition" 12 4
ブレークポイントをセットします。
line を省略すると、実行されようとしている行にセットされます。
condition が指定されると、
ブレークポイントの文に達する毎に condition が評価され、
condition が真のときだけブレークします。
ブレークポイントは実行文の先頭にだけセットできます。
.Ip "b subname condition" 12 4
ブレークポイントをサブルーチンの最初の実行文にセットします。
.Ip "d line" 12 4
ブレークポイントを削除します。
line を省略すると、実行しようとしている行のブレークポイントが
削除されます。
.Ip "D" 12 4
すべてのブレークポイントを削除します。
.Ip "a line command" 12 4
行にアクションをセットします。
バックスラッシュの直後に改行すれば、複数行コマンドも入力できます。
.Ip "A" 12 4
すべての行のアクションを削除します。
.Ip "< command" 12 4
デバッガがプロンプトを出す前に実行するアクションをセットする。
バックスラッシュの直後に改行すれば、複数行コマンドも入力できます。
.Ip "> command" 12 4
コマンドを入力してスクリプト実行に移る時に、
プロンプトの後に実行するアクションをセットします。
バックスラッシュの直後に改行すれば、複数行コマンドも入力できます。
.Ip "V package" 12 4
パッケージ内のすべての変数をリストします。
デフォルトは、メインパッケージです。
.Ip "! number" 12 4
デバッグコマンドの再実行を行ないます。
number が省略されると、直前のコマンドを再実行します。
.Ip "! -number" 12 4
幾つか前のコマンドを再実行します。
.Ip "H -number" 12 4
最後の n 個のコマンドを表示します。
1 文字より長いコマンドをリストします。
number を省略すると、すべてをリストします。
.Ip "q or ^D" 12 4
終了します。
.Ip "command" 12 4
コマンドを perl の文として実行します。
足りないセミコロンは補われます。
.Ip "p expr" 12 4
\*(L"print DB'OUT expr\*(R" と同じことです。
DB'OUT ファイルハンドルは、どこに STDOUT がリダイレクトされているか
に関わらず、/dev/tty にオープンされます。
.PP
デバッガを変更したいときは、perldb.pl ファイルを perl のライブラリ
から、カレントディレクトリにコピーして、必要に応じて修正して下さい。
(コマンドラインに -I. を付けなければならないでしょう。)
初期化コードを含む .perldb ファイルを設定することで、カスタマイズが
できます。例えば、以下のようなエイリアスを作ることができます:
.nf

    $DB'alias{'len'} = 's/^len(.*)/p length($1)/';
    $DB'alias{'stop'} = 's/^stop (at|in)/b/';
    $DB'alias{'.'} =
      's/^\e./p "\e$DB\e'sub(\e$DB\e'line):\et",\e$DB\e'line[\e$DB\e'line]/';

.fi
.Sh "setuid スクリプト"
.I perl
は、安全な setuid スクリプトや setgid スクリプトを簡単に書けるように
デザインされています。
スクリプトの各行が何回も置換されるシェルとは違って、
.I perl
は、隠された \*(L"わけの判らないもの\*(R" を少なくして、より伝統的な
評価機構を使っています。
それに加え、この言語は組み込み機構をより多く備えていて、目的を達成する
ために外部の (すなわち信頼できない可能性がある) プログラムに
頼らなければならないことは、ほとんどありません。
.PP
パッチが当たっていない 4.2 または 4.3bsd カーネルでは、
setuid スクリプトは本質的に危険をはらんでいますが、このカーネルの
機能は無効にできます。
この場合、
perl スクリプトに (無意味な) setuid/gid ビットが付いていると、
.I perl
は setuid と setgid 機構をエミュレートできます。
カーネルの機能が無効でない場合、
.I perl
は setuid スクリプトが安全でないことをうるさく訴えるでしょう。
カーネルの setuid スクリプト機能を無効にするか、そうでなければ
スクリプトに C のラッパをかぶせる必要があるでしょう。
.PP
perl が setuid スクリプトを実行しているとき、明らかなトラップに
はまらないように特別な注意を払います。
(いくつかの点で、perl スクリプトは同等の C プログラムより安全です。)
コマンドライン引数と環境変数と入力は、\*(L"汚れ\*(R" とみなされ、
サブシェルを起動するコマンドや、ファイル、ディレクトリ、プロセスを
変更するようなコマンドの中では、直接にも間接的にも使われません。
それ以前に汚れた値を参照したような式の中でセットされた変数も、
また汚れていることなります。
(汚れた値が変数に影響することが、たとえ論理的に不可能だとしても)
.br
例えば:
.nf

.ne 5
	$foo = shift;			# $foo は汚れています
	$bar = $foo,\'bar\';		# $bar も汚れています
	$xxx = <>;			# 汚れています
	$path = $ENV{\'PATH\'};	# 汚れていますが、以下を見て下さい
	$abc = \'abc\';			# 汚れていません

.ne 4
	system "echo $foo";		# 危険です
	system "/bin/echo", $foo;	# 安全です (shを使わないので)
	system "echo $bar";		# 危険です
	system "echo $abc";		# PATH がセットされるまで、
					# 安全ではありません

.ne 5
	$ENV{\'PATH\'} = \'/bin:/usr/bin\';
	$ENV{\'IFS\'} = \'\' if $ENV{\'IFS\'} ne \'\';

	$path = $ENV{\'PATH\'};		# 汚れていません
	system "echo $abc";		# もはや汚れていません!

.ne 5
	open(FOO,"$foo");		# OK
	open(FOO,">$foo"); 		# 駄目です

	open(FOO,"echo $foo|");	# 駄目だけど..
	open(FOO,"-|") || exec \'echo\', $foo;	# OK

	$zzz = `echo $foo`;		# 危険。 zzz は汚れています。

	unlink $abc,$foo;		# 危険
	umask $foo;			# 危険

.ne 3
	exec "echo $foo";		# 危険
	exec "echo", $foo;		# 安全 (sh を使いません)
	exec "sh", \'-c\', $foo;	# 安全と見なされてしまう、嗚呼

.fi
汚れは、各スカラ値と関係するので、配列の要素は汚れているものも、
汚れていないものもあります。
.PP
何か安全でないことをしようとすると、
\*(L"Insecure dependency\*(R" とか \*(L"Insecure PATH\*(R" というような
致命的エラーになります。
それでも、危険なシステムコールや exec を書くことができますが、
上記の最後の例のようなことを明示的に行なった場合に限るということを
覚えておいて下さい。
サブパターンを参照することでも、汚れの機構を避けることが
できます \*(--\c
.I perl
は、$1, $2 などを使った部分文字列の参照では、自分のしていることを
知っているはずだと解釈します。
次のようなパターンの場合です:
.nf

	$ARGV[0] =~ /^\-P(\ew+)$/;
	$printer = $1;		# 汚れていません

.fi
これは、\ew+ がシェルのメタキャラクタにマッチしないので、
まず安全です。 .+ を使うと危険でしょうが、
.I perl
はそこまで調べないので、パターン指定には注意を払うべきです。
これは、ファイル操作をしたいときに ($> を $< と同じにしなければ) 、
ユーザが与えるファイル名を汚さないための唯一の機構です。
.PP
汚れた値を使うことを気にしないような他の操作でもトラブルを起こす場合が
あります。
ユーザが与えたファイル名を扱うファイルテストは、慎重に使って下さい。
できれば、$> = $< というようにセットした後で open して下さい。
.I perl
では、汚れたファイルをオープンして読みだすことが制限されないので、
出力する内容については注意して下さい。
汚れの機構は、ばかな間違いを防ぐように作られているのであって、
考える必要がなくなるようにするためではありません。
.SH 環境
.Ip HOME 12 4
chdir に引数がないときに使われます。
.Ip LOGDIR 12 4
chdir に引数が無く、HOME がセットされていないときに使われます。
.Ip PATH 12 4
サブプロセスを実行するとき、および \-S が使われたときは
スクリプトを探す際に使われます。
.Ip PERLLIB 12 4
標準ライブラリやカレントディレクトリを見る前に、perl ライブラリ
ファイルを探すディレクトリのコロン区切りのリストです。
.Ip PERLDB 12 4
デバッガコードを得るのに使われるコマンドのことです。セットされて
いないと、
.br

	require 'perldb.pl'

を使います。
.PP
これらを別にすると、
.I perl
は、スクリプト実行時と子プロセスに渡された環境変数しか使いません。
しかし、setuid で走っているスクリプトは、だまされないようにするために
何より先に以下の行を実行しておいた方が良いでしょう:
.nf

.ne 3
    $ENV{\'PATH\'} = \'/bin:/usr/bin\';    # 必要なパスを入れましょう
    $ENV{\'SHELL\'} = \'/bin/sh\' if $ENV{\'SHELL\'} ne \'\';
    $ENV{\'IFS\'} = \'\' if $ENV{\'IFS\'} ne \'\';

.fi
.SH 作者
Larry Wall <lwall@netlabs.com>
.br
MS-DOS への移植 Diomidis Spinellis <dds@cc.ic.ac.uk>
.SH 関連ファイル
/tmp/perl\-eXXXXXX	
.B \-e
コマンドのためのテンポラリファイル
.SH 関連項目
a2p	awk から perl への変換プログラム
.br
s2p	sed から perl への変換プログラム
.SH 診断
コンパイルエラーは、エラーの行番号と次にあるべきトークンか、または
調べられたトークンの型を教えてくれます。
(
.B \-e
スイッチで
.I perl
に渡されたスクリプトの場合、各
.B \-e
が一行に数えられます。)
.PP
setuid スクリプトには、更に \*(L"Insecure dependency\*(R" のような
エラーメッセージを生じるという制約があります。
setuid スクリプトのセクションを参照して下さい。
.SH トラップ
.IR awk
に慣れたユーザは、以下のことに特に注意を払わなければなりません:
.Ip * 4 2
.I perl
では、(ブロックの終わりを除く) すべての単文の後にセミコロンが必要です。
改行は文の区切りではありません。
.Ip * 4 2
if や while には、中括弧 {} が必要です。
.Ip * 4 2
.IR perl
では、変数は $ か @ で始まります。
.Ip * 4 2
配列の添字は、$[ をセットしなければ 0 で始まります。
substr() と index() の文字位置も同様です。
.Ip * 4 2
配列の添字が数字であるか文字列であるかを決めなければなりません。
.Ip * 4 2
連想配列は、参照するだけでは存在することになりません。
.Ip * 4 2
比較の際には、文字列比較か、数値比較かを決めなければなりません。
.Ip * 4 2
入力行を読み込んだだけでは、split は行なわれません。自分で split して、
配列に入れなければなりません。
そして、
.I split
演算子は、異なる引数を取ります。
.Ip * 4 2
現在の入力行は、通常 $0 ではなく $_ です。
一般に改行コードは除かれません。
($0 は実行されたプログラム名です。)
.Ip * 4 2
$<数字> は、フィールドの参照ではありません\*(--最後にマッチした
パターンの部分文字列を参照します。
.Ip * 4 2
.I print
文は $, と $\e を設定しなければ、フィールド区切りやレコード区切りを
出力しません。
.Ip * 4 2
ファイルに出力する前には、オープンしなければなりません。
.Ip * 4 2
範囲演算子は \*(L".\|.\*(R" であって、コンマではありません。
(コンマ演算子は、C と同じ動作です。)
.Ip * 4 2
マッチ演算子は、\*(L"~\*(R" でなく \*(L"=~\*(R" です。
(\*(L"~\*(R" は C と同じく補数の演算子です。)
.Ip * 4 2
指数演算子は、\*(L"^\*(R" でなく \*(L"**\*(R" 演算子です。
(\*(L"^\*(R" は、C と同じく XOR 演算子です。)
.Ip * 4 2
結合演算子は \*(L".\*(R" であり、ヌル文字列ではありません。
(ヌル文字列を使うと 3 番目の / が除算演算子と解釈されるため、
\*(L"/pat/ /pat/\*(R" が解析不能になります。\*(--トークン解析は、実際
のところ /, ?, < のような演算子ではコンテキストにやや敏感です。
そして、実は、. 自身は数字の始めになり得ます。)
.Ip * 4 2
.IR next ,
.IR exit,
.I continue
の動作は異なります。
.Ip * 4 2
次の変数の動作は異なります。
.nf

	  Awk	\h'|2.5i'Perl
	  ARGC	\h'|2.5i'$#ARGV
	  ARGV[0]	\h'|2.5i'$0
	  FILENAME\h'|2.5i'$ARGV
	  FNR	\h'|2.5i'$. \- 何か
	  FS	\h'|2.5i'(何でもよい)
	  NF	\h'|2.5i'$#Fld かそのようなもの
	  NR	\h'|2.5i'$.
	  OFMT	\h'|2.5i'$#
	  OFS	\h'|2.5i'$,
	  ORS	\h'|2.5i'$\e
	  RLENGTH	\h'|2.5i'length($&)
	  RS	\h'|2.5i'$/
	  RSTART	\h'|2.5i'length($\`)
	  SUBSEP	\h'|2.5i'$;

.fi
.Ip * 4 2
疑わしいときは、
.I awk
のプログラムを a2p に通して、出て来たもの見て下さい。
.PP
C に洗脳されたプログラマは、次のことを特に心に留めておかなければなりま
せん:
.Ip * 4 2
if や while には、中括弧 {} が必要です。
.Ip * 4 2
\*(L"else if\*(R" でなく、\*(L"elsif\*(R" を使わなければなりません。
.Ip * 4 2
.I break
や
.I continue
は、それぞれ
.I last
や
.IR next
になります。
.Ip * 4 2
switch 文はありません。
.Ip * 4 2
.IR perl
では、
変数は $ か @ で始まります。
.Ip * 4 2
printf には * は実装されていません。
.Ip * 4 2
コメントは、/* でなく # で始まります。
.Ip * 4 2
何者のアドレスを得ることもできません。
.Ip * 4 2
ARGV は大文字でなければなりません。
.Ip * 4 2
link, unlink, rename 等のシステムコールは、成功時に 0 でな
く、非 0 を返します。
.Ip * 4 2
シグナルハンドラは、数字ではなくシグナル名を扱います。
.PP
経験豊かな
.I sed
プログラマは、次のことを心に留めておかなければなりません:
.Ip * 4 2
置換の後方参照では、\e でなく $ を使います。
.Ip * 4 2
パターンマッチメタキャラクタ (, ), | の前にはバックスラッシュをつけません。
.Ip * 4 2
範囲演算子は、コンマでなく .\|. です。
.PP
鋭い shell プログラマは、次のことを心に留めておかなければなりません:
.Ip * 4 2
`` 演算子のコマンド内では、'' にくくられていないと変数置換が行なわれます。
.Ip * 4 2
`` 演算子は csh と違って、戻り値の変換をしません。
.Ip * 4 2
シェル (特に csh) は、各コマンド行で複数レベルの置換を行ないます。
.I perl
は、"", ``, <>, // のような決まった構造においてのみ、置換が行なわれます。
.Ip * 4 2
シェルは、スクリプトを一度に少しだけ解釈します。
.I perl
は、すべてのプログラムを実行前にコンパイルします。
.Ip * 4 2
引数は、$1, $2,.. ではなく、@ARGV を介して利用できます。
.Ip * 4 2
環境は、変数として自動的に利用可能とはなりません。
.SH 訂正と追加
perl の本、
.I Programming\0Perl
には以下のような省略と抜けがあります。
.PP
5 ページの例
.nf

	eval "/usr/bin/perl

は、以下でなければいけません。

	eval "exec /usr/bin/perl

.fi
.PP
195 ページの System V の sum 相当のプログラムは、極めて小さなファイル
でしか動作しません。大きなファイルでは、以下を使って下さい。
.nf

	undef $/;
	$checksum = unpack("%32C*",<>) % 32767;

.fi
.PP
alarm と sleep に関する記述は、シグナル SIGALARM と言っていますが、
SIGALRM でなければなりません。
.PP
$/ の初期値をセットする
.B \-0
スイッチは、この本が出版後に perl に追加されました。
.PP
.B \-l
スイッチでは、自動行末処理を行なうようになっています。
.PP
qx// 構造は バックスラッシュ `` と同義です。
.PP
$0 は、
.I ps (1)
の引数表示を変更するために、代入可能となりました。
.PP
新しい @###.## フォーマットは、フォーマットの記述から
偶然省略されました。
.PP
s///ee が置換式の多重評価を生じることが、出版時に
知られていませんでした。これは、仕様と解釈されるべきです。
.PP
(LIST) x $count は、配列の繰り返しを実行します。
.PP
正規表現には、括弧の数に制限がなくなっています。
.PP
ダブルクォート "" のコンテキストでは、更に以下のエスケープがサポート
されています:
\ee, \ea, \ex1b, \ec[, \el, \eL, \eu, \eU, \eE
最後の 5 つの制御コードは、大文字小文字の変換です。
.PP
.B $/
変数には、複数の区切り文字をセットできます。
.PP
通常のパターンマッチに g 修飾子が使えます。
これにより、文字列から複数のマッチを検索することで、
パターンマッチを繰り返します。
.PP
$^T を除いて、すべての $^X 変数が増えています。
.PP
FILEHANDLE に対するデフォルトのページ先頭フォーマットは、top でなく
FILEHANDLE_TOP になっています。
.PP
eval {} と sort {} 構造は、version 4.018 で追加されました。
.PP
pack と unpack の v と V (リトルエンディアン) テンプレートオプションは、
vertion 4.019 で追加されました。
.SH バグ
.PP
.I perl
型のキャスト、atof() 、sprintf() のようないろいろな操作は、
マシンの定義に左右されます。
.PP
あるストリームで、stdio が各 read や write の間に seek や eof を
必要とする場合、
.IR perl
はそのようにします。
(これは、sysread() と syswrite() には適用されません。)
.PP
どの組み込みデータタイプも勝手なサイズ制限は持っていません
(メモリサイズは別です) が、それでもいくらかは限界はあります:
識別子は 255 文字以上にはできませんし、
\-S を使うとき、PATH の要素は 255 を超えてはいけません。
正規表現は、内部的に 32767 バイトを超えられません。
.PP
.I perl
は、実は
病理学的折衷主義のがらくたリスター (Pathologically Eclectic Rubbish Lister)
なんですが、私がそう言ったとは誰にも話さないで下さい。
.rn }` ''
