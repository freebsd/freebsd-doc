.\" Copyright (c) 1980, 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)csh.1	8.2 (Berkeley) 1/21/94
.\" %FreeBSD: src/bin/csh/csh.1,v 1.18 2000/02/17 03:40:21 unfurl Exp %
.\"
.\" jpman %Id: csh.1,v 1.2 1997/04/08 00:35:51 h-nokubi Stab %
.\"	Japanese translation for jpman-0.2 checked by jpman project 96.12.23
.\"
.Dd January 21, 1994
.Dt CSH 1
.Os BSD 4
.Sh 名称
.Nm csh
.Nd C 言語ライクな文法を持つシェル(コマンドインタプリタ)
.Sh 書式
.Nm csh
.Op Fl bcefimnstvVxX
.Op arg ...
.Nm csh
.Op Fl l
.Sh 解説
.Nm
は、履歴(参照:
.Sx ヒストリ置換
の項)、ジョブ制御(参照: 
.Sx ジョブ
の項)、対話的なファイル名とユーザ名の補完(参照:
.Sx ファイル名補完
の項)、C 言語ライクな文法を特徴とするコマンドインタプリタです。
対話的なログイン・シェル、また
シェル・スクリプトのコマンド・プロセッサの両方の用途で使われます。
.Ss 引数リスト処理
.Ql Fl \&
で始まるプログラム名でシェルが実行された場合、
シェルはログイン・シェルとなります。
シェルを
.Ql Fl l
フラグを指定して起動することでもログイン・シェルにできます。
.Pp
残りのフラグは以下のように解釈されます:
.Bl -tag -width 5n
.It Fl b
このフラグは、オプションの処理を強制的に中断させる場合に使用します。この
フラグ以降の引数はすべて、オプションではない引数として処理されます。
これにより、シェル・スクリプトに混乱やごまかしを行わずにオプションを
渡すことが可能になります。
set-user ID スクリプトは本オプションなしでは実行できません。
.It Fl c
コマンドを本フラグの次にくる 1 つの引数から読み込みます。
この引数は省略できません。残りの引数は 
.Ar argv
に代入されます。
.It Fl e
起動したコマンドが異常終了したり、0 でない終了ステータスを返したときに、
ただちにシェルを終了します。
.It Fl f
起動したユーザのホーム・ディレクトリにある
.Pa \&.cshrc
を捜さず、また読み込まないため高速に起動します。
.It Fl i
たとえ端末上で実行されていなくても、対話的に動作しプロンプトを表示します。
入力と出力が端末である場合、本オプションなしでもシェルは対話的に動作します。
.It Fl l
ログイン・シェルとなります。(
.Fl l
が、指定された唯一のフラグの場合にのみ有効です。)
.It Fl m
シェルは、実効ユーザに属していなくても
.Pa .cshrc
をロードします。
.Xr su 1
は
.Fl m
をシェルに渡すことができます。
.It Fl n
コマンドの解析は行いますが、実行しません。シェル・スクリプトの
文法検査に役立ちます。
.It Fl s
標準入力からコマンドを読み込みます。
.It Fl t
入力から1行だけ読み込み、それを実行します。改行の直前に
.Ql \e
を置くことで、次の行への継続を行うことができます。
.It Fl v
.Ar verbose
変数を設定します。これにより、ヒストリ置換された状態のコマンド行を
表示するようになります。
.It Fl x
.Ar echo
変数を設定します。これにより、実行直前に、実行するコマンドを
表示するようになります。
.It Fl V
.Pa .cshrc
を実行するより前に
.Ar verbose
変数を設定します。
.It Fl X
.Pa .cshrc
を実行するより前に
.Ar echo
変数を設定します。
.El
.Pp
.Fl X
に対する
.Fl x
の関係は、ちょうど
.Fl V
に対する
.Fl v 
の関係に相当します。
.Pp
フラグ引数の処理のあと、もし引数が残っていて、かつ、
.Fl c ,
.Fl i ,
.Fl s ,
.Fl t
のいずれのフラグも指定されていなければ、残っている最初の引数は
コマンドファイル名であるとみなされます。シェルはこのファイルをオープンし、
`$0' による置換に備えてファイル名を保存します。多くのシステムは version 6 
または version 7 の標準のシェルを使っており、また、それらの
シェル・スクリプトは本シェルとは互換性がないので、
スクリプトの先頭の文字が `#' でない場合、
つまりスクリプトがコメントから始まらない場合、
本シェルはそれらの `標準' シェルを起動して実行します。
残りの引数は変数
.Ar argv
に初期値として設定されます。
.Pp
.Nm
は、実行開始に際し、まず、ファイル
.Pa /etc/csh.cshrc
を読み込み実行します。ログイン・シェルであれば、さらに、ファイル
.Pa \&/etc/csh.login
を読み込み実行します。
次にシェルを起動したユーザの
.Ar ホーム
・ディレクトリにあるファイル
.Pa \&.cshrc
を読み込み実行します。ログイン・シェルであるなら、
さらに、同じディレクトリのファイル
.Pa \&.login
を読み込み、実行します。
.Pa \&.login
の通常の使い方としては、ユーザが CRT 画面の設定のために 
``stty crt'' を実行したり、
.Xr tset  1
を実行したりするために用いられます。
.Pp
通常、シェルはプロンプト `% ' を表示し、端末からコマンドを読み込みます。
引数の処理やコマンド・スクリプトを含むファイルの処理については後述します。
.Pp
シェルは以下の動作を繰り返します: 読み込んだ行を
.Ar 単語
に分解します。この単語の列をコマンド履歴に格納し、解析します。
最後にその行の各コマンドを実行します。
.Pp
ログイン・シェルが終了するとき、ユーザの
.Ar ホーム
ディレクトリのファイル
.Pa .logout
と 
.Pa /etc/csh.logout
を読み込み実行します。
.Ss 字句構造
シェルは、読み込んだ行を空白とタブを区切りとして単語に分割します。ただし、
以下の例外があります。文字
`&' `\&|' `;' `<' `>' `(' `)'
は独立した単語となります。`&&', `\&|\&|', `<<', `>>' のように
2つ繰り返されている場合はペアで1単語を形成します。
これらのメタキャラクタは、直前に `\e' を置くことによって、単語の一部としたり、
特別な意味を無視させることができます。改行の直前に `\e' を置くと、
単一の空白と等価になります。
.Pp
対応したクォート記号
`'\|', `\*(ga', `"' に狭まれた文字列は、単語の一部分となります。
このような文字列中のメタキャラクタやブランク、
タブによって単語が分割されることはありません。
これらのクォートの意味はあとで説明します。
`\'' または `"' の内側で改行文字の直前に `\e' を置くと、
改行文字そのものになります。
.Pp
シェルの入力が端末からではない場合、
`#' 文字から改行まではコメントとして扱われます。
直前に `\e' を置くか `\`', `\'', `"" でクォートすることにより、
この意味を抑制することができます。
.Ss コマンド
単純コマンドは単語の列であり、最初の単語が実行すべきコマンドを示します。
`\&|' 記号で区切られた、単純コマンドあるいは単純コマンドの列は
パイプラインを形成します。パイプラインの各コマンドの出力は、次のコマンドの
入力に接続されます。パイプラインの列を `;' によって区切ることで逐次実行が
行えます。パイプラインの列に続けて `&' を置くと、そのパイプラインの終了を
待つことなく、次のパイプラインが実行されます。
.Pp
上記のいずれかを `(' と `)' で囲むことにより、単純コマンドを形成することが
できます (これはパイプライン等の構成要素として使えます)。
また、パイプラインを `\&|\&|' または `&&' で区切ることにより、C 
言語のように、第 2 のパイプラインが第 1 のパイプラインが失敗あるいは
成功したときにのみ実行させることができます(
.Em 式
の項参照)。
.Ss ジョブ
シェルはパイプラインの各々に対し
.Ar ジョブ
を 1 つづつ関連付けます。シェルは、現在実行中のジョブの一覧表を保持しており、
これは、
.Ar jobs
コマンドによって表示することができます。
ジョブには整数の番号が割り当てられます。ジョブが `&' を用いて非同期に
起動された場合、シェルは以下のような出力を行います:
.Bd -filled -offset indent
.Op 1
1234
.Ed
.Pp
これは、非同期に起動したジョブがジョブ番号 1 であり、プロセス ID が 1234 である
(トップレベルの) プロセスを 1 つ持っていることを示します。
.Pp
もし、あるジョブを実行中に他のことをしたくなった場合、
.Em ^Z
キー
(control-Z) を押すことにより実行中のジョブに STOP シグナルを
送信することができます。通常、シェルはそのジョブが停止した(Stopped)ことを
出力し、プロンプトを表示します。ここで、停止したジョブの状態を操作することが
できます。つまり、
.Ar bg
コマンドにより停止したプロセスを
.Em バックグラウンド
で走行させたり、他のコマンドを実行してから、停止していたジョブを
.Ar fg
コマンドにより
.Em フォアグラウンド
で再実行させることなどができます。
.Em ^Z
は即座に効力を発揮し、インタラプトと同様に、それまで待たされていた
出力とまだ読み込まれていない入力は捨てられます。
ほかに特殊キーとして
.Nm ^Y
があり、これを押すと、プログラムが
.Xr read  2
によって読み込もうとした時点で STOP シグナルが送信されます。
これは、実行中のジョブに対していくつかの入力を先に入力しておき、
先行入力を読み終えた時点でジョブを停止させたいときに便利です。
.Pp
バックグラウンドで実行しているジョブが端末からの入力を試みた場合、その
ジョブは停止します。通常、バックグラウンドジョブが端末に出力することは
可能ですが、これは、コマンド ``stty tostop'' により禁止することができます。
もし、この tty オプションを指定したなら、バックグラウンドで実行している
ジョブは、端末から入力を試みたときと同様に、端末に出力を試みたときに
停止します。
.Pp
シェルでジョブを参照するにはいくつかの方法があります。文字 `%' は
ジョブ名を表すのに用いられます。番号 1 のジョブを参照する場合は `%1' とします。
単にジョブ名を入力した場合、そのジョブはフォアグラウンドに移動されます。
すなわち `%1' は `fg %1' と等価で、番号 1 のジョブをフォアグラウンドで
実行させます。同様に `%1 &' は番号 1 のジョブをバックグラウンドで
走行させます。ジョブはそのジョブを起動したときにタイプされた文字列の
先頭部分によって参照することもできます。ただし、この先頭部分は
あいまいでない必要があります。すなわち、`%ex' は、`ex' という文字列で
始まる名前のサスペンドされたジョブが 1 つしかない場合に限り、サスペンドされた
.Xr ex  1
のジョブを再開します。文字列
.Ar string
を含むジョブが 1 つしかない場合、`%?string' と入力することで、
それを指定することもできます。
.Pp
シェルは現在のジョブと直前のジョブを覚えています。jobs コマンドの
出力では、`+' 記号が付加されているのが現在のジョブ、`\-' 記号が
付加されているのが直前のジョブです。`%+' は現在のジョブ、`%\-' は
直前のジョブの省略形です。後述する
.Ar ヒストリ
の文法から類推される記法として、`%%' があります。
これもまた現在のジョブの省略形です。
.Pp
ジョブ制御機構を用いるには、
.Xr stty 1
のオプション
.Ic new
を設定しておく必要があります。ジョブ制御機構は、
.Em 新型
の端末ドライバの実装の上に構築されているからです。
新型の端末ドライバにより、ジョブを停止させるためのシグナルを
キーボードから入力できるわけです。
新型の端末ドライバのオプション設定については stty(1) を参照してください。
.Ss 状態通知
シェルは、プロセスが状態の変化を起こすと、すぐにそれを検知します。通常、
プロンプトが表示される直前にのみ、あるジョブが停止し、それ以上処理が
進まなくなったことを通知します。これは、ユーザの仕事を邪魔しないように
するためです。
しかしながら、シェル変数
.Ar notify
をセットすることにより、シェルにバックグラウンド・ジョブの状態が
変化したことをただちに通知させることができます。
また、シェルコマンド
.Ar notify
により、特定のジョブの状態の変化をただちに通知させる
ようにマークすることもできます。引数なしの
.Ar notify
は現在のプロセスに対してマークをつけます。
バックグラウンド・ジョブの開始直後に単に `notify' と打つと
そのジョブをマークします。
.Pp
停止したジョブがある状態でシェルを終了しようとすると、`You have
stopped jobs.' という警告を受けます。このとき、
.Ar jobs
コマンドによりどのジョブが停止中であるのかを確認することができます。
警告を受けた直後に
.Ar jobs
コマンドで確認した場合と、
警告を受けた直後に再度シェルを終了させようとした場合には、
シェルは 2 度目の警告を行わず、停止中のジョブは終了させてから
シェルを終了します。
.Ss ファイル名補完
シェル変数
.Ar filec
がセットされてファイル名補完機能が有効になっている場合、
(
.Ic set
の項参照)
.Nm
はファイル名やユーザ名の補完を対話的に行います。文字列に続けて
エスケープ文字 (エスケープキー、または control-[) キーを端末から
入力することにより補完が行われます。
たとえば、以下のファイルがカレント・ディレクトリにあったとします。
.Bd -literal -offset indent
DSC.OLD  bin      cmd      lib      xmpl.c
DSC.NEW  chaosnet cmtest   mail     xmpl.o
bench    class    dev      mbox     xmpl.out
.Ed
.Pp
ここで、以下のように入力します。
.Pp
.Dl % vi ch<escape>
.Pp
このとき、
.Nm
は ``ch'' を補完し、それにマッチする唯一のファイル名 ``chaosnet'' 
にします。補完後の入力行は以下のようになります。
.Pp
.Dl % vi chaosnet
.Pp
以下のように入力した場合は、
.Pp
.Dl % vi D<escape>
.Pp
.Nm
は、次のように補完を行います。
.Pp
.Dl % vi DSC.
.Pp
ここで、端末ベルを鳴らし、補完が完了しなかったことをユーザに伝えます。
なぜなら、``D'' で始まるファイル名が複数あったからです。
.Pp
不完全なファイル名に続いて end-of-file 文字(通常は control-D)を入力すると、
名前の補完を行うかわりに、その名前にマッチするファイル名の一覧を出力します。
たとえば、以下のように入力すると、
.Pp
.Dl % vi D<control-D>
.Pp
``D'' で始まるファイル名の一覧が以下のように出力されます:
.Pp
.Dl DSC.NEW	DSC.OLD
.Pp
このとき、入力行は変化しません。
.Pp
エスケープ文字と、end-of-file 文字を用いる同様の機構は、
ユーザ名を補完する場合にも用いることができます。この場合、``~'' で
名前を開始します。たとえば、次のように入力すると、
.Pp
.Dl cd ~ro<escape>
.Pp
以下のように補完されます。
.Pp
.Dl cd ~root
.Pp
シェル変数
.Ar nobeep
をセットすることにより、複数の候補があったり、補完に
失敗した場合に端末ベルを鳴らすのを禁止することができます。
.Pp
通常、そのディレクトリにあるすべてのファイル名が補完の候補となります。
ある特定の拡張子を持つファイルを補完の候補から外すのに、変数
.Ar fignore
を用いる
ことができます。以下のコマンドで、変数
.Ar fignore
を設定すると、
.Pp
.Dl % set fignore = (.o .out)
.Pp
以下のように入力した場合に、
.Pp
.Dl % vi x<escape>
.Pp
次のように補完が行われます。
.Pp
.Dl % vi xmpl.c
.Pp
つまり、"xmpl.o" と "xmpl.out" が無視されて補完が行われました。もし、
.Ar fignore
で無視するように指定されたファイル名しか補完の対象になり得なかった場合、
.Ar fignore
の設定は無視されます。また、
.Ar fignore
は end-of-file 文字によるファイル名の一覧には影響を与えません。
一覧ではすべてのファイル名が出力されます。
.Ss 置換
ここからは、シェルが入力に対して行うさまざまな置換を、
処理が行われる順に記述します。
.Ss ヒストリ置換
ヒストリ置換は、以前に入力されたコマンド中の単語を、
新たなコマンドの一部として置き換えることで、
コマンドの繰り返し実行を容易にしたり、直前のコマンドの引数を次のコマンドで
再び使用したり、直前に入力した行の綴り間違いを修正する際に、
タイプ入力の手間を減らし、自信をもって修正できるようにするための機能です。
ヒストリ置換は文字 `!' により始まり、入力ストリームの
.Ar どの位置にでも
置くことができます(ただし、入れ子にすることは
.Em できません
)。`\e' を `!' の前に置くことにより、`!' の特殊な意味を打ち消すことが
できます。また、利便のために、`!' の直後に空白、タブ、改行文字、
`=', `(' が続いた場合、ヒストリ置換は行われず、入力された文字がそのまま
用いられます(ヒストリ置換は、入力行が `\*(ua' で始まっている場合にも
起こります。これについては後述します)。入力行にヒストリ置換が含まれている
場合は、実行直前にヒストリ置換を行った結果が端末に出力されます。
.Pp
端末から入力された、1 つあるいはそれ以上の単語からなるコマンドは
ヒストリ・リストに記録されます。ヒストリ置換は、この記録された
単語の列を入力ストリームに挿入することにより行われます。
ヒストリ・リストの大きさは、変数 
.Ar history
により制御されます。直前のコマンドは
.Ar history
の値に関わらず必ず
保存されます。記録されているコマンドは 1 から順にイベント番号が
割り当てられます。
.Pp
.Ar history
コマンドにより、以下の出力が得られたとします:
.Bd -literal -offset indent
\09  write michael
10  ex write.c
11  cat oldwrite.c
12  diff *write.c
.Ed
.Pp
コマンドはイベント番号とともに出力されています。必ずしもイベント番号を
用いる必要はありませんが、プロンプト文字列に `!' を埋めることにより、
現在のイベント番号を
.Ar プロンプト
中に表示させることができます。
.Pp
現在のイベント番号が 13 だとすると、以前のイベントを指定するには、
イベント番号を用いて `!11' としたり、
相対指定を用いて `!\-2' としたり(同じイベントを表します)する方法があります。
また、コマンドの単語の先頭部分を用いて指定することもできます。例えば、`!d'
でイベント番号 12 を指定したり、 `!wri' でイベント番号 9 を指定できます。また、
ある文字列を含むコマンドを指定するのに `!?mic?' (これはイベント番号 9 の
コマンドを示します)のような記法も使えます。これらの記法は、指定された
イベントの各単語を単一の空白で区切った単語列に置換します。特殊な
場合として、`!!' は直前のコマンドを参照します。すなわち、`!!' だけを
入力することは直前のコマンドの
.Ar 再実行
を意味します。
.Pp
あるイベント中のいくつかの単語だけを指定するために、イベント指定に続けて `:' 
と単語指示子を書くことができます。イベントの単語は 0 から順に番号が
振られています。最初の単語(通常はコマンドです)が 0 で、2 番目の単語
(第1引数)が 1 ということになります。基本的な単語指示子は以下のとおりです:
.Pp
.Bl -tag -width Ds -compact -offset indent
.It \&0
最初の(コマンド)単語
.It Ar n
.Ar n
番目の単語
.It \*(ua
最初の引数(すなわち 1 と同じ)
.It $
最後の引数
.It %
直前の
.No \&? Ns Ar s Ns \&?
検索でマッチした単語
.It Ar \&x\-y
.Ar x
番目から
.Ar y
番目までの単語
.It Ar \&\-y
.Ar `\&0\-y\'
の省略形
.It *
`\*(ua\-$' の省略形。イベントが1語のみからなる場合は空になる
.It Ar x*
.Ar `x\-$\'
の省略形
.It Ar x\-
.Ar `x*\'
から最後の単語を除いたもの。
.El
.Pp
イベント指定と単語指示子とを区切る `:' は、引数選択子が `\*(ua', `$', `*', 
`\-', `%' で始まっている場合には省略することができます。
単語指示子の直後に、 `:' に続けて
修飾子を複数個置くことができます。以下の修飾子が定義されています:
.Pp
.Bl -tag -width Ds -compact -offset indent
.It h
パス名の最後の要素を削除します(head)
.It r
最後の `.xxx' 要素を削除します(root)
.It e
`.xxx' 以外の部分を削除します(extension)
.It s Ns Ar /l/r/
Substitute
.Ar l
を
.Ar r
で置換します(substitution)
.It t
最後の要素を残して、それより前のパス名の要素全てを削除します。
.It \&&
直前の修飾子の作用を繰り返します。
.It g
上記の修飾子の直前に置き、変更を、各単語に 1 回だけ及ぼすことを指定します。
例) `g&'
.It a
上記の修飾子の直前に置き、1 つの単語に対して可能な限り繰り返して
変更を行います。変更が全単語に及ぶようにするには `g' と組み合わせて使います。
.It p
置換結果を表示しますが、実行はしません(print only)
.It q
さらに置換が行われないように、置換結果をクォートします(quote)
.It x
q と同様ですが、空白、タブ、改行によって単語を分割します
.El
.Pp
`g' が指定されなかった場合、適用可能な最初の単語のみが修飾子の影響を受けます。
置換については、適用可能な単語がなかった場合にはエラーとなります。
.Pp
置換(s/l/r/) における左辺 (
.Ar l
) は、エディタなどで使うような正規表現ではなく単なる文字列です。`/'
のかわりに自由な文字を区切りに指定することができます。`\e' によって、
.Ar l
または 
.Ar r
中の区切り文字をクォートすることができます。右辺 (
.Ar r
) 中の文字 `&' は
左辺の文字列に置換されます。`&' もまた `\e' によって
クォートすることができます。
空の左辺値
.Ar l
(`//') の場合、直前の左辺値
.Ar l
または、
.No \&`!? Ns Ar s Ns ?'
中のコンテキストスキャン文字列
.Ar s
から左辺値が取られます。置換指定の直後に改行がくる場合には、
最後の区切り文字を省略することができます。
コンテキストスキャンの後ろ側の文字 `?' も、直後に改行がくる場合、
同様に省略できます。
.Pp
ヒストリは、 `!$' のようにイベント指定なしで参照することができます。
同じ行においてそれ以前にヒストリ参照が行われた場合はそのイベントを、
さもなければ直前のコマンドが参照されます。`!?foo?\*(ua !$' は `?foo?' に
マッチするイベントの最初と最後の単語に置換されます。
.Pp
入力行の最初の非空白文字が `\*(ua' の場合、特殊なヒストリ参照の省略形であると
みなします。これは `!:s\*(ua' と等価で、直前に入力したコマンド行の
文字列置換を行うことができます。たとえば、`\*(ualb\*(ualib' は
直前のコマンドの `lib' の綴り間違いを修正します。
最後に、後ろに続く文字とヒストリ置換とを隔離するために、
ヒストリ置換を `{' と `}' によって囲むことができます。`ls -ld ~paul' なる
コマンドを実行した直後に`!{l}a' と
入力することで、`ls -ld ~paula' に展開されます。一方、`{}' を
使わずに `!la' とした場合は `la' で始まるイベントを検索します。
.Pp
.Ss \' と \&" によるクォート
文字列を `\'' または `"' によって
クォートすることにより、残りの置換のすべてあるいは一部を
抑制することができます。`'' によってクォートされた文字列には
本マニュアルのこれ以降に説明する置換が適用されません。`"' によって
クォートされた文字列は、後述するように一部の置換が適用されます。
.Pp
どちらのクォートの結果も単一の単語 (の全体または一部) となります。
ただし、`"' クォートされたコマンド置換は複数の単語になる特殊な場合が
1 つだけあります(後述の
.Sx コマンド置換
の項を参照)。
`\'' クォートの場合は、このようなことはありません。
.Ss エイリアス置換
シェルはエイリアス(別名定義)を管理しており、
.Ar alias
コマンドと
.Ar unalias
コマンドに
より設定、表示、修正等を行うことができます。コマンド行がスキャンされたあと、
個々のコマンドに解析され、各コマンドの最初の単語に対応するエイリアスが
あるかどうかチェックします。もし存在すれば、入力されたコマンド行の内容を
直前のコマンドとみなして、エイリアスの内容をヒストリ展開します。
コマンド行全体は展開結果と置き換えられます。エイリアスの内容が
ヒストリ参照を含まなかった場合、入力したコマンド行の引数は変更せずに
残されます。
.Pp
`ls' に対するエイリアスが `ls -l' だった場合、`ls /usr' は `ls -l
/usr' に展開されます。この場合、エイリアスにはヒストリ参照がなかったため、
引数の `/usr' は変更せずに残されました。`lookup' に対するエイリアスが
`grep !\*(ua /etc/passwd' だった場合、`lookup bill' は
`grep bill /etc/passwd' に展開されます。
.Pp
エイリアスが展開された場合、展開結果に対して単語分割とエイリアス検索が
再度行われます。展開結果の最初の単語が展開前の最初の単語と同一になった場合、
再度エイリアス検索が行われることはありません。それ以外の、エイリアスによる
ループは検出され、エラー扱いとなります。
.Pp
このメカニズムによってエイリアスでパーサのメタ記法を利用できます。
よって `alias print \'pr \e!* \&| lpr\'' とエイリアスすることで
.Ar pr
の
引数をプリンタに出力させるというようなことができます。
.Ss 変数置換
シェルは変数を管理しており、それらは 0 個またはそれ以上の単語のリストを
値として持ちます。変数のうちいくつかはシェルがセットしたり参照したりします。
たとえば、変数
.Ar argv
はシェルへの引数を保持しており、この変数の値である単語は、特殊な方法で
参照されます。
.\" #### jpman kuma 96.12.05 here checked ... TO BE CONTINUED
.Pp
変数の値は
.Ar set
および
.Ar unset
コマンドにより参照、変更することができます。シェルが
参照する変数のうちいくつかは、それがセットされているかどうかだけが重要
であり、値が何であっても意味を持たないものがあります。たとえば、変数 
.Ar verbose
は入力行がエコーされるかどうかを制御する変数であり、この変数を
セットすることは、
.Nm
に
.Fl v
オプションを指定したのと同じ意味になります。
.Pp
変数を数値として扱う操作もあります。`@' コマンドによって変数に対して数値演算
を適用し、演算結果を変数に代入することができます。しかしながら、変数の
値はつねに文字列として表現されます。数値演算の場合、空文字列は 0 と
みなし、変数の値が複数の単語からなる場合 2 番目以降の単語は無視されます。
.Pp
入力行にエイリアス置換を行い、構文解析を行ったあと、コマンドが実行される
前に文字 `$' をキーとして変数置換を行います。`$' の直前に `\e'
を置くことにより、変数置換を抑制することができます。
ただし、`"' クォート中では変数置換は
.Em 必ず
行われますが、`\'' クォート中では
.Em 決して行われません。
`\*(ga' クォートのなかはさらにあとで解釈されるため(後述の
.Sx コマンド置換
の項を参照)、ここでは変数置換は行いません。`$' の直後に空白、タブ、
改行がくる場合、`$' はそのまま残されます。
.Pp
入出力リダイレクトは変数置換より前に解釈され、別々に変数置換が行われます。
それ以外のコマンド名と引数は同時に展開されます。このため、最初の
単語(コマンド)が展開の結果、複数の単語となったり、展開された結果の
最初の単語がコマンド名、それ以外が引数の一部になることもあります。
.Pp
`"' でクォートされておらず、変数置換に `:q' 修飾子も指定されなかった
場合には、変数置換の結果にコマンドとファイル名置換が
行われます。`"' クォート内では複数の単語からなる値を持つ変数は、各単語を
1つの空白で区切った単一の単語 (の一部) に展開されます。`:q' 修飾子が
指定された場合は、各単語は 1 つの空白で区切られ、
この後のコマンドとファイル名置換を抑止するために、個々にクォートされた
単語の列に展開されます。
.Pp
変数置換には以下の形式があります。特に記述していない場合、
セットされていない変数の参照はエラーになります。
.Pp
.Bl -tag -width Ds -compact -offset indent
.It $name
.It ${name}
.\" #### modified by kuma 96.12.21 ####
変数
.Ar name
の値の各単語を 1 つの空白文字で区切ったものに展開されます。中括弧は
.Ar 変数名
と後続する文字を分離し、後続する文字が変数名の一部と解釈されないように
するために用いられます。シェル変数は 20 文字までの名前を持ちます。
変数名の先頭はアルファベットで、それ以降はアルファベット、数字、
アンダースコアを使用することができます。
.Ar name
という名前のシェル変数は存在しないが、同名のセットされた環境変数が
存在する場合には、その値に置換されます(ただし、環境変数に対しては
.Nm :
修飾子と以降に説明する書式を
用いることはできません)。
.It $name Ns Op selector
.It ${name Ns [ selector ] }
変数
.Ar name
の値のうちいくつかの単語を選択して展開します。
.Ar selector
は 1
つの数字、範囲を示す2つの数字を `\-' でつないだもの、あるいはそのような
結果になる変数置換のいずれかです。単語は 1 から順序づけられています。
範囲の最初の数字が省略された場合は 1 が用いられます。範囲の第2の数字が
省略された場合は `$#name' が用いられます。selector として `*' が用いられた
場合には、すべての単語に展開されます。範囲の第2の数字が省略されるか、
単語数より小さい場合には、範囲が空になってもエラーとはなりません。
.It $#name
.It ${#name}
変数の値の単語数に展開されます。
この機能は後述する
`$argv[selector]'
で有用です。
.It $0
コマンドを読み込んでいるファイル名に展開されます。ファイル名が不明の場合は
エラーとなります。
.It $number
.It ${number}
`$argv[number]' と等価です。
.It $*
`$argv[*]' と等価です。
.El
.Pp
修飾子 `:e', `:h', `:t', `:r', `:q', `:x' や 
`:gh', `:gt', `:gr' を適用することができます。中括弧 `{' `}' で
囲まれている場合は、中括弧内に修飾子が存在しなければなりません。
現在の csh の実装では、各 `$' 展開につき1つの修飾子のみ指定することができます。
.Pp
以下の置換を行なう場合は `:' 修飾子を指定することはできません。
.Bl -tag -width Ds -compact -offset indent
.It $?name
.It ${?name}
変数 name がセットされていれば `1' に、さもなければ `0' に展開されます。
.It $?0
現在の入力ファイル名がわかっていれば `1' に、不明ならば `0' に展開されます。
.It \&$\&$\&
親のシェルの (10進の) プロセス番号に展開されます。
.It $!
そのシェルから起動された最後のバックグラウンド・プロセスの
(10進の) プロセス番号に展開されます。
.It $<
標準入力から1行を読み込み、その内容に展開されます。読み込んだ内容の解釈は
行いません。スクリプト中でキーボードからの入力を受けるのに用いられます。
.El
.Ss コマンドとファイル名置換
残りの置換であるコマンド置換とファイル名置換は、
組み込みコマンドの引数に対しては
適用されたり、されなかったりします。
.\" #### changed by kuma 96.12.21 ####
すなわち、式の中で評価が行われない部分に関しては
以下の置換が行なわれません。組み込みコマンドではないコマンドにおいては、
コマンド名は引数とは別に置換が行なわれます。
.\" #### changed by kuma 96.12.21 ####
コマンド名に対する置換が生じるのは一連の置換処理の最後の方で、
入出力リダイレクトの設定後、メインシェルの子供の中で行われます。
.Ss コマンド置換
コマンド置換は、コマンドを `\*(ga' で囲むことによって指示します。
コマンドからの
出力は空白、タブ、改行によって単語に分割され、空の単語を削除したあとに
元の文字列と置換されます。
`"' の内部では、改行のみが単語分割の区切りとして扱われ、空白とタブは
そのまま残されます。
.Pp
どちらの場合も、コマンドの出力の最後の改行は単語の区切りとはならず、単に
削除されます。
よってコマンド置換によって、コマンドの出力が完全な 1 行であっても、
単語の一部分のみを生成することが可能です。
.Ss ファイル名置換
単語が文字 `*',  `?',  `[',  `{' を含んでいるか、単語の先頭文字が `~' の
.\" #### modified by kuma 96.12.21 ####
場合、その単語はファイル名展開(あるいはグロブ(glob)と呼ばれます)の
候補となります。
.\" #### modified by kuma 96.12.21 ####
候補となった単語はパターンとみなされ、パターンにマッチするファイル名が
アルファベット順にソートされた列に置換されます。
ファイル名置換を含む単語の列がどれもファイル名にマッチしなかった場合には
エラーとなりますが、
すべての単語パターンがマッチする必要はありません。
メタキャラクタ`*',  `?', `['
のみがパターンマッチ文字であり、`~' と `{' は省略形といったほうが近いで
しょう。
.Pp
ファイル名マッチにおいて、ファイル名先頭、または `/' の直後の `.' は、
`/' と同様に明示的にマッチさせなければなりません(`*' や `?' は
これらにマッチしません)。
`*' は、空文字列を含むどのような文字列にもマッチします。`?' は、
どのような1文字にもマッチします。
.Sq Op ...
は、括弧のなかで指定した文字のいずれかにマッチします。
.Sq Op ...
内では、文字の対を `\-' でつなぐことで、
文字の範囲を指定することができます(両側の文字も含まれます)。
.Pp
ファイル名の先頭の `~' はホーム・ディレクトリを示すのに用いられます。
単独で用いられた場合には、シェルを起動したユーザのホーム・ディレクトリ
.\" #### modified by kuma 96.12.21 ####
(変数
.Ar home
の値に反映されているとおり)に展開されます。`~' に続けてアルファベット、
数字、`-' からなる単語が続いた場合は、その単語をユーザ名とみなして、
そのユーザのホーム・ディレクトリに展開されます。たとえば、ユーザ ken の
ホーム・ディレクトリが `/usr/ken' ならば、`~ken' は 
`/usr/ken' に、 `~ken/chmach' は `/usr/ken/chmach' に展開されます。
直後にアルファベットと `/' 以外が続く`~'と、ファイル名の先頭にない `~' は
変更されずにそのまま残されます。
.Pp
メタ記法 `a{b,c,d}e' は `abe ace ade' の短縮形です。
.\" #### modified by kuma 96.12.21 ####
この記法の左から右への出現順序は保存されます。
展開結果は下位のレベルで個別にソートされ、出現順序は保存されます。
この記法は入れ子にすることができます。
source のホーム・ディレクトリが `/usr/source' ならば、
`~source/s1/{oldls,ls}.c' は `/usr/source/s1/oldls.c
/usr/source/s1/ls.c' に展開されます。このとき oldls.c や ls.c が
存在しなくともエラーにはなりません。同様に、`../{memo,*box}' は
`../memo ../box ../mbox' 等に展開されます(`memo' と `*box' の
展開結果がいっしょに
ソートされたりしていないことに注意してください)。特殊な場合として、
単独の`{' と `}', `{}' は変更されずにそのまま残されます。
.Ss 入出力
コマンドの標準入出力は、以下の方法によりリダイレクトすることができます:
.Pp
.Bl -tag -width Ds -compact -offset indent
.It < name
ファイル
.Ar name
(変数、コマンド、ファイル名展開を受けます)をオープンし、
コマンドの標準入力とします。
.It << word
.Ar word
と同一の行が出現するまで、シェルの入力を読み込みます。
.Ar word
は変数、ファイル名、コマンド置換を受けません。シェル入力の行は
読み込まれるとすぐに
.Ar word
と比較されます(置換を行う前に)。その後、
.Ar word
に 
`\e', `"', `\'', `\*(ga' クォートが出現しないなら、読み込まれた行には
変数置換と
.\" #### ^^^^^^^ `\'' だと思う(1次チェック者のコメント?jpman kuma 961205)
.\" #### kuma agree with you, changed as specified 96.12.22
コマンド置換が適用されます。この置換を抑制するために、`\e' によって
`$', `\e', `\*(ga' をクォートすることができます。コマンド置換において、
すべての空白、タブ、改行は保存されますが、最後の改行は削除されます。
読み込んだ行はすべて中間的なファイルに保存され、コマンドの標準入力として
用いられます。
.It > name
.It >! name
.It >& name
.It >&! name
ファイル
.Ar name
を標準出力として用います。ファイルが存在しなければ作成され、
すでにファイルが存在すればその内容は切り捨てられ、以前の内容は失われます。
.Pp
変数
.Ar noclobber
がセットされている場合、ファイルが存在しないか文字型特殊ファイル (端末や
`/dev/null' のような) でなければエラーになります。これは、
すでに存在するファイルを思いがけず削除してしまうことを防止します。`!' を
用いた形式を使うと、この検査を抑制することができます。
.Pp
`&' を用いた形式では、標準出力とともに標準エラー出力もファイルへ
リダイレクトされます。
.Ar name
.\" #### modified by kuma 96.12.21 ####
は、 `<' の入力ファイル名の場合と同様の展開を受けます。
.It >> name
.It >>& name
.It >>! name
.It >>&! name
`>' と同様に、ファイル
.Ar name
を標準出力として用います。ただし、コマンドの出力はファイルへ追加されます。
変数
.Ar noclobber
がセットされている場合、
ファイルが存在しなければエラーとなります(`!' を用いることで、
この検査を抑制することができます)。
他は `>' と同様です。
.El
.Pp
コマンドは、シェルが起動されたときの環境を、入出力リダイレクトと
パイプラインによって変更したもののなかで実行されます。以前のいくつかの
シェルとは異なり、
シェルコマンドファイルから起動されたコマンドは、デフォルトでは標準入力に
よってシェルコマンドファイル自体にアクセスすることはできません。
かわりに、シェルが起動した環境の標準入力をそのまま受け継いでいます。
`<<' 機構はインラインデータのために用いるべきです。
このように制限することにより、
シェルコマンドスクリプトをパイプラインの一部として用いることができます。
バックグラウンドで実行されているコマンドの標準入力も
.Pa /dev/null
等にリダイレクトされることは
.Ar なく
、シェルの標準入力をそのまま受け継いでいます。もし標準入力が端末で、
コマンドが端末から読み込もうとした場合、そのプロセスはブロックされ、
シェルはユーザにそのことを通知します(参照:
.Sx ジョブ
の項)。
.Pp
標準エラー出力もパイプにリダイレクトすることができます。単純に `\&|' の
かわりに `\&|&' を使います。
.Ss 式
.\" #### modified by kuma 96.12.21 ####
いくつかの組み込みコマンド(後述します)は、引数として式を取ります。式は C 
言語のものと類似しており、同じ優先順位を持ちます。式は
.Em @ ,
.Em exit ,
.Em if ,
.Em while
コマンド中で用います。以下の演算子が使用可能です:
.Bd -ragged -offset indent
\&|\&|  &&  \&| \*(ua  &  ==  !=  =~  !~  <=  >=
<  > <<  >>  +  \-  *  /  %  !  ~  (  )
.Ed
.Pp
上記の演算子は右にいくほど優先順位が高くなっています。
`==' `!=' `=~' `!~', `<=' `>=' `<' `>', `<<' `>>', `+' `\-', 
`*' `/' `%' の 5グループは各グループ内では同じ優先度です。
`==', `!=', `=~', `!~' は文字列の比較を行い、他の演算子は数値演算を
行います。`=~', `!~' は `!=', `==' と同様ですが、右辺を
.Ar パターン
(`*', `?', `[...]' を含んだ) とみなして、左辺とのパターンマッチが行われます。
これにより、シェル
スクリプトにおいてパターンマッチのみが必要な局面では
.Ar switch
ステートメントを使わずに済ませることができます。
.Pp
先頭が `0' の文字列は 8 進数の数値とみなされます。空または省略された引数
は `0' とみなされます。すべての演算結果は 10 進数数値の文字列となります。
式の 2 つの要素が同一の単語中に出現してはいけません。つまり、
.\" #### modified by kuma 96.12.21 ####
要素の前後が、構文解析において特殊な意味を持つ
`&', `\&|', `<', `>', `(', `)' でない場合は、
その要素は空白で囲まれていることが必要です。
.Pp
数式中では、`{' と `}' で囲んだコマンドと、
以下のファイル検査演算子を用いることができます。
ファイル検査演算子は
.Fl l
.Ar name
の形式で、
.Ic l
は以下のうちのいずれかです:
.Bd -literal -offset indent
r	読み込みアクセス
w	書き込みアクセス
x	実行アクセス
e	存在
o	所有
z	サイズがゼロ
f	通常ファイル
d	ディレクトリ
.Ed
.Pp
指定された name は、コマンド、ファイル名置換を適用したのちに
実ユーザの権限において検査されます。ファイルが存在しないか、
アクセス不可なら演算結果は false すなわち `0' になります。
コマンド実行においては、コマンドが成功したなら演算結果は true `1' に、
コマンドが 0 以外の終了ステータスを返してきたら、すなわち、
失敗なら演算結果は false `0' になります。
終了ステータスの値自体を知りたい場合は、コマンドを式以外の文脈で実行し、変数 
.Ar status
の値を調べます。
.Ss 制御構造
シェルにはコマンドファイル(シェル・スクリプト)中で、
あるいは(制限されてはいるが、便利な方法で)端末から、
制御の流れを変更するためのいくつかのコマンドがあります。
これらのコマンドはシェルに入力を読み直させたり、
スキップさせたりすることができます。実装の制限上、
これらのコマンドを書くことのできる位置に制限があります。
.Pp
.Ic foreach ,
.Ic switch , 
.Ic while ,
文、および、
.Ic if\-then\-else
の
.Ic if
ステートメントは、
後述するように入力行の単一の単純コマンドとして現れる必要があります。
.Pp
シェルの入力がシーク不可能な場合、
シェルは繰り返しが必要なときには入力をバッファに保存し、
.\" #### modified by kuma 96.12.23 ####
この内部バッファに対してシークを行います(このため、シーク不可能な入力の場合も、
後方への goto が可能です)。
.Ss 組み込みコマンド
組み込みコマンドは通常シェルのプロセス内部で実行されます。
ただし、組み込みコマンドがパイプラインの最後以外に用いられた場合は、
サブシェル上で実行されます。
.Pp
.Bl -tag -width Ds -compact -offset indent
.It Ic alias
.It Ic alias Ar name
.It Ic alias Ar name wordlist
1行目の形式はすべてのエイリアスを出力します。2 行目の形式は
.Ar name
に対応したエイリアスの値を出力します。最後の形式は
.Ar wordlist
を
.Ar name
のエイリアスとして登録します。
.Ar wordlist
にはコマンド置換、ファイル名置換が適用されます。
.Ar name
として
.Ar alias
または
.Ar unalias
を指定することはできません。
.Pp
.It Ic alloc
.Nm
が獲得したメモリのうちの使用量と空き容量を表示します。
なんらかの引数をつけると、ブロックサイズごとの使用中/空ブロック数を表示します。
ブロックサイズは 8、16、32、.. となります。
本コマンドの出力はシステムによって異なります。
VAX 以外のシステムは、異なるメモリ管理を行っているかもしれないからです。
.Pp
.It Ic bg
.It Ic bg \&% Ns Ar job ...
現在のジョブあるいは指定されたジョブをバックグラウンドに移動します。
もしそれらのジョブが停止されていたなら、実行が再開されます。
.Pp
.It Ic break
最も内側の
.Ic foreach
または
.Ic while
ループに対応する
.Ic end
の後へ脱出します。同じ行にある残りのコマンドは実行されます。複数の
.Ic break
を同一行に記述することで複数レベルの脱出が行えます。
.Pp
.It Ic breaksw
.Ic switch
から脱出し、
.Ic endsw
のあとで実行を再開します。
.Pp
.It Ic case Ar label :
.Ic switch
ステートメントのラベルを指定します。
.Pp
.It Ic cd
.It Ic cd Ar name
.It Ic chdir
.It Ic chdir Ar name
.\" #### modified by kuma 96.12.23 ####
シェルの作業ディレクトリをディレクトリ
.Ar name
に変更します。引数が指定されなかった場合には、
ユーザのホーム・ディレクトリに変更します。
カレント・ディレクトリにディレクトリ
.Ar name
がない場合(かつ
.Ar name
が `/', `./', `../' 
で始まっていない場合)、変数
.Ic cdpath
の各要素のサブディレクトリとして 
.Ar name
がないかどうかを調べます。最後に、シェル変数
.Ar name
に `/' で始まる値が設定されているなら、
その値のディレクトリが存在しないかを調べます。
.Pp
.It Ic continue
最も内側の
.Ic while
または
.Ic foreach
ループの先頭に戻ります。戻る前に、同じ行に記述されたコマンドが実行されます。
.Pp
.It Ic default :
.Ic switch
ステートメントのデフォルトを指定します。
.Ic default
は、すべての
.Ic case 
ラベルのあとに出現しなければなりません。
.Pp
.It Ic dirs
ディレクトリ・スタックを表示します。
スタックの先頭(カレント・ディレクトリ)を左端にして表示します。
.Pp
.It Ic echo Ar  wordlist
.It Ic echo Fl n Ar wordlist
指定された単語を空白で区切った文字列をシェルの標準出力に書き出します。
.Fl n
オプションが指定されなければ、最後に改行が出力されます。
.Pp
.It Ic else
.It Ic end
.It Ic endif
.It Ic endsw
.Ic foreach ,
.Ic if ,
.Ic switch ,
.Ic while
ステートメントの項を参照してください。
.Pp
.It Ic eval Ar arg ...
(
.Xr sh  1
と同様)引数をシェルへの入力であるとみなして読み込み、
現在のシェルのコンテキストで実行します。
コマンド置換や変数置換の結果として生成されたコマンド列を実行する場合に用いられます。
通常は、それらの置換に先立って文法解析が行われてしまうからです。
.Ic eval
の使い方の例が
.Xr tset  1
にあります。
.Pp
.It Ic exec Ar command
指定された command を現在のシェルと置き換えて実行します。
.Pp
.It Ic exit
.It Ic exit Ar (expr )
1行目の形式では変数
.Ic status
の値、2 行目の形式では式
.Ic expr
の値を返り値としてシェルを終了します。
.Pp
.It Ic fg
.It Ic fg % Ns Ar job ...
現在のジョブあるいは指定されたジョブをフォアグラウンドに移動します。
停止していたジョブは実行を再開します。
.Pp
.It Ic foreach Ar name (wordlist)
.It ...
.It Ic end
変数
.Ic name
に
.Ic wordlist
の各値を順次セットしながら対応する
.Ic end
までのコマンドを繰り返し実行します(
.Ic foreach
と
.Ic end
.\" #### modified by kuma 96.12.23 ####
は単独で行に置かなければなりません)。組み込みコマンド
.Ic continue
を使って中途でループの次の繰り返しを実行させたり、
.Ic break
コマンドによって中途でループを脱出させたりすることができます。
このコマンドが端末から読み込まれる場合、ループすべての内容が(プロンプト
? を表示しながら)読み込まれてから実行が開始されます。
端末からループ中でタイプ・ミスした場合は修正できます。
.Pp
.It Ic glob Ar wordlist
.Ic echo
コマンドと似ていますが、`\e' によるエスケープは解釈されず、
.\" #### modified by kuma 96.12.23 ####
単語はヌル文字によって区切られます。プログラムから、
シェルをファイル名置換のために利用する場合に便利です。
.Pp
.It Ic goto Ar word
.Ic word
にファイル名置換、およびコマンド置換が適用されたのち、それを `label'
とみなします。シェルは可能なかぎり入力を遡って読み直し、`label:' 
のある行を検索し、そこから実行を開始します。
ラベルの前には空白またはタブを置くことが可能です。
.Pp
.It Ic hashstat
コマンドを検索するのに、
内部キャッシュがどの程度効率的に働いているか
(そして
.Ic exec
をどの程度回避できているかを)を表示します。
.\" #### modified by kuma 96.12.23 ####
.Em path
の要素のうち、ハッシュ関数がヒットの可能性を示すものと、
`/' で始まらないものについて
.Ic exec
が試みられます。
.Pp
.It Ic history
.It Ic history Ar n
.It Ic history Fl r Ar n
.It Ic history Fl h Ar n
ヒストリのリストを表示します。数字
.Ar n
が指定された場合には、最近の
.Ar n
個のイベントが表示されます。
.Fl r
オプションは表示順序を逆にします。
.\" #### modified by kuma 96.12.23 ####
すなわち、最も古いものを先に表示するのではなく、
最も新しいものを先に表示します。
.Fl h
オプションを指定すればイベント番号が省略されます。これは
.Ic source
コマンドで \-h を使って読み込むためのファイルを生成する場合に用いることができます。
.Pp
.It Ic if ( Ar expr ) No command
.\" #### modified by kuma 96.12.23 ####
指定された式が true と評価されたなら、単一のコマンド
.Ar command
が実行されます。
.Ar command
.\" #### modified by kuma 96.12.23 ####
に対する変数置換は、実行に先だって
.Ic if
コマンドの残りの部分と同時に行なわれます。
.Ar command
は単純コマンドのみが許され、パイプライン、コマンドリスト、括弧でくく
られたコマンドであってはいけません。入出力リダイレクションは式
.Ar expr
が false 
と評価され、それゆえ
.Ar command
が実行
.Sy されなかった
場合にも処理されます(これはバグです)。
.Pp
.It Ic if ( Ar expr ) Ic then
.It ...
.It Ic else if ( Ar expr2 ) Ic then
.It ...
.It Ic else
.It ...
.It Ic endif
式
.Ar expr
が true なら最初の
.Ic else
までのコマンドが実行されます。さもなければ、式
.Ar expr2
が true なら次の
.Ic else
までのコマンドが実行されます。
いくつでも
.Ic else-if
の対を繰り返すことができます。最後に 1 つの
.Ic endif
が必要です。
最後の
.Ic else
部分はあってもなくてもかまいません。
(単語
.Ic else
と 
.Ic endif
は入力行の最初に置く必要があります。また、
.Ic if
は行内に単独で、または
.Ic else
のあとに置く必要があります)。
.Pp
.It Ic jobs
.It Ic jobs Fl l
アクティブなジョブの一覧を出力します。
.Fl l
.\" #### modified by kuma 96.12.23 ####
オプションを指定すると、通常の情報に加えてプロセス ID も出力します。
.Pp
.It Ic kill % Ns Ar job
.It Ic kill Ar pid
.It Ic kill Fl sig Ar pid ...
.It Ic kill Fl l
TERM(terminate) シグナルあるいは指定したシグナルを、
指定されたジョブまたはプロセスに送ります。
シグナルは番号または名前で指定できます(名前は 
.Pa /usr/include/signal.h
にある名前から `SIG' を取り除いたものです)。
シグナル名の一覧を ``kill \-l'' により表示できます。
kill にはデフォルト動作はなく、
単に `kill' を実行しても現在のジョブにシグナルが送られるようなことはありません。
送るシグナルが TERM(terminate) または HUP(hangup) の場合、
CONT(continue) シグナルも同時に送られます。
.Pp
.It Ic limit
.It Ic limit Ar resource
.It Ic limit Ar resource maximum-use
.It Ic limit Fl h
.It Ic limit Fl h Ar resource
.It Ic limit Fl h Ar resource maximum-use
現在のプロセスと、それが生成するプロセスのそれぞれについて、
.\" #### modified by kuma 96.12.23 ####
指定されたリソース
.Ar resource
を、指定された
.Ar maximum-use
を超えて使用しないように設定します。
.Ar maximum-use
が指定されなかった場合、現在の制限値が表示されます。
.Ar resource
が指定されなかった場合、すべての制限値が表示されます。
.Fl h
オプションが指定された場合、
現在の制限値のかわりにハードリミットの表示/設定を行います。
.\" #### modified by kuma 96.12.23 ####
ハードリミットは現在の制限値の上限の値です。
スーパユーザのみがハードリミットを増加させることができます。
一般ユーザは現在の制限値を可能な範囲で増減することができます。
.Pp
.\" #### modified by kuma 96.12.23 ####
現在のところ、制御可能なリソースは、
.Ar cputime
(各プロセスが使うことのできる最大の CPU 秒数)、
.Ar filesize
(1つのファイルの最大サイズ)、
.Ar datasize
(
.Xr sbrk  2
.\" #### modified by kuma 96.12.23 ####
を用いてプログラムのテキスト領域の末尾を超えて増加させることのできる
data+stack 領域の最大サイズ)、
.Ar stacksize
.\" #### modified by kuma 96.12.23 ####
(自動的に拡張されるスタックの最大サイズ)、
.Ar coredumpsize
(最大のコアファイルのサイズ)です。
.Pp
最大値
.Ar maximum-use
は、(整数あるいは浮動小数の)
数値とそれに続くスケールファクタによって指定します。
.Ar cputime
以外の制限値のデフォルトのスケールファクタは 
`k' あるいは `kilobytes'(1024 バイト)です。
.\" #### modified by kuma 96.12.23 ####
スケールファクタとして `m' あるいは `megabytes' 
を使用することもできます。
.Ar cputime
のデフォルトのスケールファクタは `seconds'(秒)です。
`m'(分)、`h'(時間) をスケールファクタとして指定したり、
`mm:ss' 形式で分秒を指定したりすることができます。
.Pp
.\" #### modified by kuma 96.12.23 ####
リソース名
.Ar resource
とスケールファクタを指定する際には、
.\" #### modified by kuma 96.12.23 ####
一意に決定できるなら、名前の先頭部分だけを指定することができます
.\" #### jpman kuma: not found in freebsd-2.1.5-RELEASE manpage (st を stacksize のかわりに用いる等)。
.Pp
.It Ic login
ログイン・シェルを終了し、
.Pa /usr/bin/login
と置き換えます。これは
.Xr sh  1
との互換性のために用意されたログオフの手段です。
.Pp
.It Ic logout
ログイン・シェルを終了します。
.Ic ignoreeof
がセットされている場合に便利です。
.Pp
.It Ic nice
.It Ic nice Ar +number
.It Ic nice Ar command
.It Ic nice Ar +number command
1 行目の形式は、シェルのスケジューリング・プライオリティを 4 に設定します。
2 行目の形式は、プライオリティを指定された値
.Ar number
に設定します。残りの 2 つの形式は、コマンド
command をプライオリティ 4 または指定した
.Ar number
で実行します。
.\" #### modified by kuma 96.12.23 ####
大きい数値を指定するとプロセスが利用できる CPU がその分少なくなります。
スーパユーザのみがプライオリティとして負の値を `nice \-number ...' 
のように指定することができます。
.Ar command
はつねにサブシェルで実行され、
単純な
.Ic if
.\" #### modified by kuma 96.12.23 ####
文のコマンドと同様の制限を受けます。
.Pp
.It Ic nohup
.It Ic nohup Ar command
1 行目の形式は、シェル・スクリプト内で使用し、
スクリプトのそれ以降で hangup シグナルを無視するように設定します。
2 行目の形式は、指定されたコマンドが、
hangup シグナルを無視するように設定して実行します。
`&' をつけて実行されたプログラムは、
.Ic nohup
を指定して実行したのと同様に hangup シグナルを無視します。
.Pp
.It Ic notify
.It Ic notify % Ns Ar job ...
現在のジョブまたは指定されたジョブの状態が変化したときに、
.\" #### modified by kuma 96.12.23 ####
コマンド待ちかどうかに関わりなく即座に通知するように指定します。
通常は、プロンプトが表示される直前に通知が行われます。
シェル変数
.Ic notify
が指定されている場合は、すべてのジョブに対して同様の設定が行われます。
.Pp
.It Ic onintr
.It Ic onintr Fl
.It Ic onintr Ar label
割り込みに対するシェルの動作を制御します。1行目の形式は、
シェルをデフォルトの動作、すなわち、スクリプトの実行が中断される、
またはコマンド入力状態に戻るように設定します。
2 行目の形式は、すべての割り込みを無視するように設定します。
3行目の形式は、シェルが割り込みを受けるか、
チャイルドプロセスが割り込みによって停止した場合に
goto label が実行されるように設定します。
.Pp
シェルがバックグラウンドで、かつ、
シグナルを無視するように設定して実行されている場合は、
.Ic onintr
は効力を持たず、
割り込みはシェルとそこから起動されるすべてのコマンドで
引続き無視されます。
最後に
.Ic onintr 
文はシステムのスタートアップ・ファイル
(/etc/csh.cshrc, /etc/csh.login) 中でも、
割り込みが禁止されているので無視されます。
.Pp
.It Ic popd
.It Ic popd Ar +n
ディレクトリ・スタックをポップし、
新たにスタックの先頭になったディレクトリにカレント・ディレクトリを変更します。
引数
.Ns \`+ Ar n Ns \'
が指定された場合、スタックの
.Ar n
番目の要素が捨てられます。ディレクトリ・スタックの要素は、
スタックの先頭から 0 から順に番号がつけられます。
.Pp
.It Ic printf Ar format-string values
.Ar format-string 
と
.Ar values
を評価した後、組み込み版の
.Ic printf 
を起動します。
詳細はマニュアルページ
.Xr printf 1
を参照してください。
.Pp
.It Ic pushd
.It Ic pushd Ar name
.It Ic pushd Ar n
引数を指定しなかった場合、
.Ic pushd
はスタックの先頭の 2 つの要素を入れ替えます。引数
.Ar name
が指定された場合、
.Ic cd
と同様にカレント・ディレクトリを変更したあと、
古いカレント・ディレクトリ
.\" cwd の typo だと思うが わからない
.\" (as in
.\" .Ic csw )
.\" #### kuma agree with you on 96.12.23 ####
をディレクトリ・スタックにプッシュします。
数字引数が指定された場合、ディレクトリ・スタックの
.Ar n
番目の要素が
スタックの先頭にくるようにローテートし、
カレント・ディレクトリをその要素が指すディレクトリに変更します。
ディレクトリ・スタックの要素は、スタックの先頭から
0 から順に番号がつけられます。
.Pp
.It Ic rehash
変数
.Ic path
に指定されているディレクトリ内の、ファイルに関するハッシュ・テーブルを
再計算させます。ログイン中に、新しいコマンドが
.Ic path
に含まれるディレクトリに追加された場合、
.\" #### modified by kuma 96.12.23 ####
rehash コマンドを実行する必要があります。
これは、あなたが個人的なディレクトリの 1 つにコマンドを追加したか、
システムの管理者がシステム・ディレクトリの内容を変更したような
場合にのみ必要です。
.Pp
.It Ic repeat Ar count command
指定されたコマンド
.Ar command
を
.Ar count
回繰り返し実行します。
.Ar command
.\" #### modified by kuma 96.12.23 ####
に指定するものは、先の 1 行
.Ic if
文で指定する
.Ar command
と同様の制限を受けます。
入出力リダイレクションは
.Ar count
が たとえ 0 であっても、必ず 1回だけ処理されます。
.Pp
.It Ic set
.It Ic set Ar name
.It Ic set Ar name Ns =word
.It Ic set Ar name[index] Ns =word
.It Ic set Ar name Ns =(wordlist)
1 行目の形式はすべてのシェル変数の値を表示します。
複数の単語からなる値を持つ変数は括弧で囲まれた値のリストで表示します。
2 行目の形式は、
.Ar name
に空文字列を設定します。3 行目の形式は
.Ar name
に単一の単語
.\" #### modified by kuma 96.12.23
.Ar word
を設定します。4 行目の形式は
.Ar name
の
.Ar index
番目の要素に
.Ar word
を設定します。
.Ar index
番目の要素はすでに存在していなければなりません。5 行目の形式は
.Ar name
に 
.Ar wordlist
で指定した単語列を設定します。すべての形式で、
値にはコマンド置換とファイル名置換が適用されます。
.Pp
複数の変数を設定するために、set コマンドへの引数を繰り返すことができます。
ただし、引数に対する変数展開処理は、代入処理に先だって行われます。
.Pp
.It Ic setenv
.It Ic setenv Ar name
.It Ic setenv Ar name value
1 行目の形式はすべての環境変数の一覧を出力します。
これは
.Xr printenv 1
と等価です。
3 行目の形式は環境変数
.Ar name
に値
.Ar value
を設定します。2 行目の形式は環境変数
.Ar name
.\" #### modified by kuma 96.12.23 ####
に空文字列を設定します。最も一般的に用いられる環境変数である
.Ev USER ,
.Ev TERM ,
.Ev PATH
は
.Nm
の起動時にシェル変数
.Ar user ,
.Ar term ,
.Ar path
にそれぞれ設定され、 
.Nm
から実行するプログラムの環境変数には、シェル変数
.Ic user ,
.Ic term ,
.Ic path
の値が反映されます。そのため、これらの変数を明示的に
.Ic setenv
する必要はありません。
.Pp
.It Ic shift
.It Ic shift Ar variable
(リスト)変数
.Ic argv
.\" #### modified by kuma 96.12.23 ####
の各要素を左にシフトし、
.Ic argv Ns Bq 1
の値を捨てます。
.Ic argv
に値が設定されていないか、
1 つ以上の要素を持たない場合にはエラーになります。
2 行目の形式は、指定された変数
.Ar variable
に対して同様の処理を行います。
.Pp
.It Ic source Ar name
.It Ic source Fl h Ar name
シェルは、指定されたファイル
.Ar name
からコマンドを読み込みます。
.Ic source
コマンドはネストすることができます。あまりに深くネストさせると、
.\" #### modified by kuma 96.12.23 ####
ファイル識別子を使い切ってしまう場合があります。いずれかのレベルの
.Ic source
コマンド中でエラーが発生すると、ネストしているすべての
.Ic source
コマンドが中断されます。通常、
.Ic source
の実行中に実行されたコマンドはヒストリに記録されませんが、
.Fl h
オプションを指定することにより、
ファイルに記述してあるコマンドを実行せずに、
ヒストリにのみ記録することができます。
.Pp
.It Ic stop
.It Ic stop % Ns Ar job ...
バックグラウンドで走行中の現在のジョブ、あるいは指定されたジョブを停止します。
.Pp
.It Ic suspend
シェル自身を停止させます。
.Em ^Z
でストップ・シグナルを送られたかのように振舞います。
.Xr su 1
によって起動したシェルを停止する場合によく用いられます。
.Pp
.It Ic switch Ar (string)
.It Ic case Ar str1 :
.It \ \ \ \ \&...
.It Ic \ \ \ \ breaksw
.It \ \ \ \ \&...
.It Ic default :
.It \ \ \ \ \&...
.It Ic \ \ \ \ breaksw
.It Ic endsw
.\" #### modified by kuma 96.12.23 ####
各
.Ic case
ラベルを順に、指定された文字列
.Ar string
でマッチングを行います。
.Ar string 
には、まず、コマンド置換とファイル名置換が行われます。
.Ic case
ラベルには変数置換が行われ、ファイル名メタキャラクタの
`*', `?', `[...]' を用いることができます。
.\" #### modified by kuma 96.12.23 ####
.Ic default
ラベルが出てくるまでにどの 
.Ic case
ラベルともマッチしなかった場合は、
.Ic default
ラベルの直後から実行が始まります。
.Ic case
ラベルと
.Ic default
ラベルは行の最初に書かれなければなりません。
.Ic breaksw
コマンドによって
.Ic endsw
以降のコマンドから実行が再開されます。
.Ic breaksw
を用いない場合は、 C 言語の場合と同様に、
.Ic case
ラベル、
.Ic default
ラベルを通過して実行が続けられます。
.Ic default
がなく、どのラベルもマッチしなかった場合には、
.Ic endsw
以降から実行が再開されます。
.Pp
.It Ic time
.It Ic time Ar command
1 行目の形式では、
シェルとそのチャイルドプロセスが使用した時間が表示されます。
.\" #### modified by kuma 96.12.23 ####
2 行目の形式では、指定された単純コマンドの実行時間が計測され、
.\" #### modified by kuma 96.12.23 ####
変数
.Ic time
の項で説明する形式で、使用時間情報の要約が表示されます。
必要ならば、コマンド終了時に時間を表示するための追加のシェルが生成されます。
.Pp
.It Ic umask
.It Ic umask Ar value
ファイル作成マスクを表示(第 1 の形式)または設定(第 2 の形式)します。
マスクは 8 進数で与えます。一般的な値としては、
グループにすべての権限を与え、
そのほかには読み込みと実行のみを許可する 002 や、
所有者以外には読み込みと実行しか許可しない 022 があります。
.Pp
.It Ic unalias Ar pattern
.Ar pattern
にマッチするすべてのエイリアスを削除します。
`unalias *' とすることですべてのエイリアスを削除することができます。
削除するものがなかった場合にもエラーにはなりません。
.Pp
.It Ic unhash
実行プログラムの位置検索を高速化する内部ハッシュ・テーブルの使用を禁止します。
.Pp
.It Ic unlimit
.It Ic unlimit Ar  resource
.It Ic unlimit Fl h
.It Ic unlimit Fl h Ar resource
リソースの制限を解除します。
.Ar resource
が指定されない場合、すべてのリソースに対する制限が解除されます。
.Fl h
が指定された場合、対応するハードリミットが解除されます。
これはスーパユーザのみが行うことができます。
.Pp
.It Ic unset Ar pattern
指定された
.Ar pattern
にマッチするすべての変数を削除します。
`unset *' と指定するとすべての変数が削除され、
悲惨な結果を生じることがあります。
.Ic unset
するものがない場合もエラーになりません。
.Pp
.It Ic unsetenv Ar pattern
指定された
.Ar pattern
にマッチするすべての環境変数を削除します。前述の 
.Ic setenv
の項と
.Xr printenv  1
を参照してください。
.Pp
.It Ic wait
すべてのバックグラウンドジョブの終了を待ちます。
対話的にシェルが実行されている場合、
インタラプトにより wait を停止することができます。
このとき、シェルはいまだに終了していないジョブの名前とジョブ番号を表示します。
.It Ic which Ar command
.\" #### modified by kuma 96.12.23 ####
.Ar command
を指定したとき、シェルが実行するコマンドの位置を表示します。
.Pp
.It Ic while Ar (expr)
.It \&...
.It Ic end
指定された式の評価結果がゼロでないかぎり、
.Ic while
と対応する
.Ic end
の間のコマンドを繰り返し実行します。
.Ic break
や
.Ic continue
によりループを終了したり、途中から繰り返しを再開させたりすることができます。
(
.Ic while
と
.Ic end
は、その行に単独で書かれなければなりません。)入力が端末の場合、
.Ic foreach
ステートメントの場合と同様に、
ループのすべてを入力するまでプロンプトが表示され、
すべての入力を終えた時点でループが実行されます。
.Pp
.It Ic % Ns Ar job
指定されたジョブをフォアグラウンドに移動します。
.Pp
.It Ic % Ns Ar job Ic &
指定されたジョブをバックグラウンドで再開実行させます。
.Pp
.It Ic @
.It Ic @ Ar name Ns = Ns expr
.It Ic @ Ar name[index] Ns = Ns expr
1 行目の形式は、すべてのシェル変数の値を表示します。2 行目の形式は、
指定された名前
.Ar name
の変数に式
.Ar expr
の値を代入します。式のなかに `<', `>', `&', `|'を含んでいる場合、
少なくともそのような部分は `(' と `)' で囲まれている必要があります。
3 行目の形式は、変数の
.Ar index
番目の要素に式
.Ar expr
の値を代入します。
.Ar name
と、その
.Ar index
番目の要素はすでに存在していなければいけません。
.El
.Pp
C 言語と同様に、演算子 `*=', `+=' 等が利用可能です。
変数名と演算子の間の空白はあってもなくてもかまいません。
しかしながら、式の各要素の間には空白が必須です。
さもなければ、単一の単語とみなされてしまいます。
.Pp
特別な後置演算子 `+\|+' と `\-\|\-' により変数の値を 1 だけ増加させたり、
減少させたりすることができます。たとえば、`@ i++' のように使います。
.Ss 定義済み変数と環境変数
以下の変数は、シェルにとって特別な意味があります。これらのうち、
.Ar argv ,
.Ar cwd ,
.Ar home ,
.Ar path ,
.Ar prompt ,
.Ar shell ,
.Ar status
はシェルが設定します。そのうち、
.Ar cwd
と
.Ar status
以外の変数の設定はシェルの起動時にのみ行われます。
そのような変数は、ユーザが明示的に変更しないかぎり、
値が変化することはありません。
.Pp
シェルは、環境変数
.Ev USER
をシェル変数
.Ar user
に、
.Ev TERM
を
.Ar term
に、
.Ev HOME
を 
.Ar home
にそれぞれコピーします。また、
これらのシェル変数が再度セットされた場合は環境変数にコピーしなおします。
環境変数
.Ev PATH
も同様に扱われます。サブシェルは環境変数によって
.Ar path
の値を得て、もしそれが変更されれば環境変数にコピーしなおすので
.Ar \&.cshrc
以外での
.Ar path
変数の設定について気をつける必要はありません。
.Bl -tag -width histchars
.It Ic argv
シェルへの引数が設定されます。位置パラメータは argv の値に展開されます。
すなわち、 `$1' は `$argv[1]' の値に置換されます。
.It Ic cdpath
.Ar chdir
.\" #### modified by kuma 96.12.23 ####
コマンドにおいてサブディレクトリを検索するためのディレクトリのリストです。
.It Ic cwd
.\" #### modified by kuma 96.12.23 ####
カレント・ディレクトリのフルパス名です。
.It Ic echo
.Fl x
オプションが指定された場合にセットされます。セットすることにより、
コマンドが実行される前にコマンド名とその引数が表示されるようになります。
.\" #### modified by kuma 96.12.23 ####
組み込みコマンド以外では、表示の前にすべての展開が行われます。
組み込みコマンドではコマンド置換とファイル名置換が行われる前に表示されます。
なぜなら、これらの置換は選択的に行われるからです。
.It Ic filec
ファイル名補完を有効にします。
.It Ic histchars
ヒストリ置換に用いる文字を文字列で指定します。
指定した文字列の最初の文字はヒストリ置換文字(デフォルトは `!')、
2 文字目は簡易置換文字(デフォルトは `\*(ua') を指定します。
.It Ic histfile
ヒストリをセーブ/リストアするパス名を指定できます。
.It Ic history
ヒストリ・リストのサイズを指定します。
このサイズを超えたコマンド履歴は削除されます。
あまりに大きな値を設定すると、シェルがメモリを使いつくすかもしれません。
最後に実行したコマンドは
.Ar history
の値にかかわらず、つねにヒストリ・リストに保存されます。
.It Ic home
.\" #### modified by kuma 96.12.23 ####
シェルを起動したユーザのホーム・ディレクトリです。
起動時に環境変数から設定されます。
ファイル名置換において
.Sq Pa ~
は本変数を参照して展開されます。
.It Ic ignoreeof
セットされると、端末のファイル終端(EOF)を無視するようになります。
間違って control-D を押してシェルを終了させてしまうのを防ぐことができます。
.It Ic mail
シェルがメールの到着をチェックするためのメールファイルを指定します。
コマンド実行が完了しプロンプトが表示されるときに、
.\" #### modified by kuma 96.12.23 ####
指定された時間が経過していればメイル到着のチェックが行われます。
最終修正時刻が最終アクセス時刻以降の場合、
シェルは `You have new mail' と出力します。
.Pp
.Ar mail
の値の最初の単語が数値の場合には、
その数値でメール検査の間隔を秒単位で指定します。
指定がなかった場合のデフォルト値は 10分です。
.Pp
複数のメールファイルが指定された場合、
メールが到着していた場合のメッセージは `New mail in
.Ar name Ns '
となります。ここで、
.Ar name
は到着したメールが あるファイル名です。
.It Ic noclobber
.Sx 入出力
の項で説明したように、
出力リダイレクトによって意図せずにファイルを削除しないように制限したり、
`>>' リダイレクトがすでに存在するファイルにしか適用できないようにします。
.It Ic noglob
セットされると、ファイル名展開が禁止されます。
ファイル名を扱わないシェルスクリプト内や、すでにファイル名展開を行ったあとで、
それ以上の展開を望まない場合に設定します。
.It Ic nonomatch
.\" #### modified by kuma 96.12.23 ####
セットされると、ファイル名展開の結果が空になってもエラーとせず、
展開前のパターンをそのまま残します。
.\" #### modified by kuma 96.12.23 ####
ただし、`echo [' のような、
展開前のパターンが文法的に正しくない場合はエラーになります。
.It Ic notify
セットされると、シェルがジョブの終了を随時報告するようになります。
通常はプロンプトの表示直前にのみ報告が行われます。
.It Ic path
.\" #### modified by kuma 96.12.23 ####
path 変数の各単語は、コマンドファイルを検索すべきディレクトリ名を表します。
空の単語はカレント・ディレクトリを示します。
.Ar path
変数が設定されて
いない場合、フルパス指定によるコマンド実行のみが可能になります。
通常の検索パスは
`.', `/bin', `/usr/bin' です。しかし、これらの値はシステムによって異なります。
スーパユーザのデフォルトの検索パスは `/etc', `/bin', `/usr/bin' です。
.Fl c
オプションも
.Fl t
オプションも指定されなかった場合、
シェルは
.Ar path
変数で指定されたディレクトリの内容をハッシュ・テーブルに保存します。
ハッシュ・テーブルは、起動時に
.Ar \&.cshrc
を読み込んだ後と
.Ar path
変数を再設定した時に再構築されます。
シェルの実行中に、
新しいコマンドがハッシュされているディレクトリに追加された場合は、
.Ic rehash
コマンドによりハッシュを再構築しなければなりません。
.\" #### modified by kuma 96.12.23 ####
さもなければ、コマンドが見付からない可能性があります。
.It Ic prompt
端末上で対話的に実行されているシェルにおいて、
.\" #### modified by kuma 96.12.23 ####
コマンド読み込み時に表示される文字列を指定します。
`!' が含まれる場合、現在のイベント番号に置換されます。
`\e' を指定することにより、この解釈を抑制することができます。
デフォルトの値は `% 'です。スーパユーザの場合は `# ' となります。
.It Ic savehist
ログアウト時にファイル ~/.history に保存されるコマンド履歴の数を指定
します。
.\" #### modified by kuma 96.12.23 ####
この値で指定される数のイベントが保存されます。
起動時に、シェルは ~/.history の内容を読み込みます。あまりに
大きな値を指定すると、シェルの起動が遅くなる場合があります。
.Ar savehist
がセットされているだけの場合は
.Ar history
に指定された値を使用します。
.It Ic shell
シェルのフルパス名を示します。実行属性が立っているが、
.\" #### modified by kuma 96.12.23 ####
システムが起動できないファイルを
実行する際に起動するシェルとして用いられます(後述の
.Sx 非組み込みコマンドの実行
の項を参照)。システム依存の値で初期化されます。
.It Ic status
最後に実行したコマンドの終了ステータス値を保持します。
異常終了した場合は、値に 0200 が加算されます。
組み込みコマンドが失敗した場合は `1' に、成功した場合は `0' になります。
.It Ic time
.\" #### modified by kuma 96.12.23 ####
コマンドの自動計時を制御します。値が設定されている場合、
コマンドがその値よりも長く CPU 秒数を消費した場合には、
コマンド終了時にユーザ時間、システム時間、実時間と、
利用率すなわちユーザ+システム時間と実時間のパーセンテージが出力されます。
.It Ic verbose
.Fl v
コマンドラインオプションが指定されていた場合にセットされます。
ヒストリ置換が行われたあと、コマンドの内容が出力されます。
.El
.Ss 非組み込みコマンドの実行
実行すべきコマンドが組み込みコマンドでなかった場合、シェルはコマンドを 
.Xr execve  2
システムコールによって起動しようとします。シェル変数
.Ar path
.\" #### modified by kuma 96.12.23 ####
の各単語は、シェルがコマンドを実行しようとするディレクトリ名を表します。
.Fl c
オプションも
.Fl t
オプションも指定されなかった場合、
.\" #### modified by kuma 96.12.23 ####
シェルはそれらのディレクトリ内にあるファイル名のハッシュ値を計算し、
シェル内部のテーブルに格納します。これは、
コマンドが存在する可能性のあるディレクトリだけで
.Ic exec
を試みるようにするためです。
この近道によって、サーチ・パスにたくさんのディレクトリが指定されている時、
コマンドの位置決定が著しく高速化されます。
この機能が(
.Ic unhash
.\" #### modified by kuma 96.12.23 ####
コマンドによって)停止されている場合、または
.Fl c
または
.Fl t
オプションが起動時に指定された場合、または
.Ar path
.\" #### modified by kuma 96.12.23 ####
中の単語で `/'
から始まらないものについては、ハッシュが用いられることはありません。
この場合は、
.Ar path
の要素にコマンドラインで指定されたコマンドを連結した名前を持つ
ファイルを実行しようと試みます。
.Pp
括弧で囲まれたコマンドは、つねにサブシェルによって実行されます。ですから、
.Pp
.Dl (cd ; pwd) ; pwd
.Pp
はホーム・ディレクトリの値を表示しますが、カレント・ディレクトリ(ホーム・
.\" #### modified by kuma 96.12.23 ####
ディレクトリの後に表示されます)は移動しません。
一方、
.Pp
.Dl cd ; pwd
.Pp
を実行すると、カレント・ディレクトリがホーム・ディレクトリに移動します。
括弧で囲まれたコマンドは、現在のシェルのカレント・ディレクトリに
影響を与えずにコマンドを実行する場合にしばしば用いられます。
.Pp
実行属性が立っているにもかかわらず、
システムによって実行可能ではないファイルは
シェルコマンドファイルであるとみなし、
サブシェルを起動してそのファイルを読み込ませます。
.Pp
.Ic shell
という名前のエイリアスが存在する場合、
エイリアスの値はシェルコマンドファイルを実行する場合の
引数リストの前に挿入されます。エイリアスの値の最初の単語は
シェルのフルパス名でなければいけません(たとえば `$shell')。
.\" #### modified by kuma 96.12.23 ####
これはエイリアス展開としては特別のもので、かなり後の時点に行われ、
引数リストを修正せずに、その前に単語を挿入するための手段を提供します。
.Ss シグナル処理
シェルは、通常
.Ar quit
シグナルを無視します。バックグラウンドのジョブ(
.Ic \&&
または
.Ic bg
または
.Ic %... &
.\" #### modified by kuma 96.12.23 ####
によるコマンド)はキーボードから入力されたシグナルに影響されません
(hangup も含みます)。他のシグナルに対する挙動は親の環境を引き継ぎます。
シェル・スクリプトでの interrupt と terminate シグナルに対する処理は
.Ic onintr
によって制御することができます。ログイン・シェルは
.Ar terminate
シグナルを捕捉します。それ以外のシェルでは、
.Ar terminate
シグナルはシェルの親の状態に従ってチャイルドプロセスに渡されます。
ログイン・シェルが
.Pa \&.logout
ファイルを読み込んでいる間は
interrupt は無視されます。
.Sh 作者
.An William Joy
。
ジョブ制御とディレクトリ・スタックは
.An J.E. Kulp ,
IIASA, Laxenburg, Austria によって、
.\" #### modified by kuma 96.12.23 ####
現在とは異なる文法のものが実装されました。
ファイル名補完は
.An Ken Greer ,
HP Labs が、
.\" #### modified by kuma 96.12.23 ####
8 bit クリーンな実装は
.An Christos S. Zoulas ,
Cornell University 
によって行われました。
.Sh 関連ファイル
.Bl -tag -width /etc/passwd -compact
.It Pa ~/.cshrc
シェルが起動されるときに読み込まれる。
.It Pa ~/.login
ログイン・シェルの場合、ログイン時に `.cshrc' の後に読み込まれる。
.It Pa ~/.logout
ログイン・シェルにおいてログアウト時に読み込まれる。
.It Pa /bin/sh
標準シェル。`#' で始まらないシェル・スクリプトの実行に用いる。
.It Pa /tmp/sh*
`<<' の処理に用いられる一時ファイル。
.It Pa /etc/passwd
`~name' 展開時に用いられるホーム・ディレクトリに関する情報を得る。
.El
.Sh 制限事項
.\" #### modified by kuma 96.12.23 ####
単語の長さは 1024 文字に制限されます。引数リストは、システムによって 10240
文字に制限されています。ファイル名展開を含む引数の数は、
引数リストの文字数の 6 分の 1 に制限されています。
コマンド置換の結果は、引数リストと同数の制限があります。
ループ検出のため、1 行に対するエイリアス展開は 20 回までに制限されています。
.Sh 関連項目
.Xr printenv 1 ,
.Xr printf 1 ,
.Xr sh 1 ,
.Xr su 1 ,
.Xr access 2 ,
.Xr execve 2 ,
.Xr fork 2 ,
.Xr killpg 2 ,
.Xr pipe 2 ,
.Xr setrlimit 2 ,
.Xr sigvec 2 ,
.Xr umask 2 ,
.Xr wait 2 ,
.Xr tty 4 ,
.Xr a.out 5 ,
.Xr environ 7
.Rs
.%T "An introduction to the C shell"
.Re
.Sh 歴史
.Nm
は
.Bx 3
で追加されました。
.\" #### modified by kuma 96.12.23 ####
コマンドインタプリタとしては、履歴(参照:
.Sx ヒストリ置換
)、ジョブ制御 (参照: 
.Sx ジョブ
.\" #### modified by kuma 96.12.23 ####
参照)、対話的なファイル名補完とユーザ名補完(参照:
.Sx ファイル名補完
.\" #### modified by kuma 96.12.23 ####
)、C言語ライクな文法を採用して実装した最初のものです。
これらの機構にいくつかの追加機能(といくらかのバグの可能性)を
持つシェルは、現在ではたくさんあります。
これらは Usenet から入手することができます。
.Sh バグ
コマンドが停止状態から復帰したとき、もしそのコマンドが起動したときの
ディレクトリとカレント・ディレクトリが異なるなら、
シェルはコマンドを起動したときのカレント・ディレクトリの値を表示します。
.\" #### modified by kuma 96.12.23 ####
これは、そのジョブが内部的にディレクトリを変更した場合は誤解(間違った情報)
を与える可能性があります。
.Pp
シェルの組み込みコマンドは中断(suspend)も再開もできません。
`a ; b ; c' のようなコマンド列も適切には中断することができません。
たとえば、 `b' の実行を中断した場合には、
すぐに `c' の実行が開始されてしまいます。これは
.Ar alias
としてコマンド列を指定している場合に特に目立ちます。
このようなコマンド列は `()'
で囲んでサブシェルで実行されるようにすることによって、
適切に停止させることが可能になります(`( a ; b ; c )'のように)。
.Pp
プロセスを起動したあとの端末出力の制御が貧弱です。おそらく、
このために、
.\" #### modified by kuma 96.12.23 ####
もっと良い仮想端末インタフェースを開発したいと考える人がいても何ら不思議はないです。
仮想端末インタフェース上なら、
もっと おもしろい端末出力の制御が可能になるでしょう。
.Pp
.\" #### modified by kuma 96.12.23 ####
シェル関数をシミュレートするために、エイリアスを不格好に用いてしまうことが
よくあります。シェル関数がサポートされるべきです。
.Pp
ループ中のコマンド入力において、
`?' プロンプトに続けて入力された内容はヒストリに残りません。
制御構造は組み込みコマンドとして解釈されるのではなく、
文法的に解釈するようにするべきです。これにより制御コマンドをどこにでも
置けるようになり、`\&|', `&', `;' との組み合わせが
自由にできるようになります。
.Pp
コマンド置換の出力にも `:' 修飾子が適用できるべきです。
.Pp
.\" #### modified by kuma 96.12.23 ####
ファイル名補完機構の実装は不細工かつ非効率的です。
