.\"
.\" dc.1 - the *roff document processor source for the dc manual
.\"
.\" This file is part of GNU dc.
.\" Copyright (C) 1994, 1997, 1998, 2000 Free Software Foundation, Inc.
.\"
.\" This program is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License , or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program; see the file COPYING.  If not, write to:
.\"   The Free Software Foundation, Inc.
.\"   59 Temple Place, Suite 330
.\"   Boston, MA 02111 USA
.\"
.\" %FreeBSD: src/contrib/bc/doc/dc.1,v 1.4 2001/02/26 07:17:03 kris Exp %
.\"
.\" $FreeBSD$
.\"
.TH DC 1 "1997-03-25" "GNU Project"
.ds dc \fIdc\fP
.ds Dc \fIDc\fP
.SH 名称
dc \- 任意精度の計算機
.SH 書式
dc [-V] [--version] [-h] [--help]
   [-e scriptexpression] [--expression=scriptexpression]
   [-f scriptfile] [--file=scriptfile]
   [file ...]
.SH 解説
.PP
\*(dc は、逆ポーランド形式の無限精度の計算が行える卓上計算機です。
この電卓は、定義やマクロ呼び出しも行えます。
普通、\*(dc は標準入力から読み込みます。
コマンドライン引数が与えられた時は、それはファイル名となり、
\*(dc はそのファイルを読み込み、ファイルの内容を実行した後で、
標準入力から入力を取ります。
通常の出力はすべて標準出力へ、エラー出力はすべて標準エラー出力へ
送られます。
.PP
逆ポーランド記法計算機は、数をスタックに保存します。
数字を入力すると、それをスタックに積み上げます。
計算操作は、引数をスタックから取り出し、結果をスタックに積み上げます。
.PP
数字を
.IR dc
に入力するためには、数字 (小数点が有っても構いません) を入力します。
指数表現はサポートされていません。
負の数字を入力するためには、``_'' で始まる数字を入力します。
``-'' は減算の二項演算子として使われているので、
このために利用することはできません。
引き続いて 2 つの数字を入力するためには、あいだに空白文字か改行文字を
入力します。
これらは、コマンドとしての意味はありません。
.SH オプション
\*(dc は、次のコマンドラインオプション付きで起動可能です:
.TP
.B -V
.TP
.B --version
実行される \*(dc のバージョンと著作権情報を表示し、終了します。
.TP
.B -h
.TP
.B --help
これらのコマンドラインオプションを短くまとめたメッセージと
バグ報告アドレスを表示し、終了します。
.TP
.B -e \fIscript\fP
.TP
.BI --expression= script
.I script
中のコマンドを、入力処理中に実行するコマンド集合に追加します。
.TP
.B -f \fIscript-file\fP
.TP

.BI --file= script-file
ファイル
.I script-file
中のコマンドを、入力処理中に実行するコマンド集合に追加します。
.PP
上記オプションの処理後にコマンドラインパラメータが残った場合、
これらのコマンドラインパラメータは処理対象の入力ファイル名として
解釈されます。
ファイル名
.B -
は、標準入力ストリームを指します。
ファイル名を指定しないと、標準入力が処理されます。
.PD
.SH
表示コマンド
.TP
.B p
スタックを変更することなく、スタックの先頭の値を表示します。
改行文字が、数値の後に表示されます。
.TP
.B n
スタックの先頭の値を表示し、スタックから取り出します。
改行文字は、後に表示されません。
.TP
.B P
スタックの先頭の値をスタックから取り出します。
値が文字列の場合、末尾の改行を付けずに、単に表示します。
そうでない場合、これは数値であり、数値の絶対値の整数部分が、
\&"基数 (UCHAR_MAX+1)" のバイトストリームとして表示されます。
ここで (UCHAR_MAX+1) は 256 を仮定すると
(ほとんどのマシンでは 8 ビットバイトなので)、文字列
\fBKSK 0k1/ [_1*]sx d0>x [256~aPd0<x]dsxx sxLKk\fP
もまたこの機能を実現しますが、
x レジスタを潰してしまう副作用が違います。
.TP
.B f
変更することなく、
.ig
すべてのレジスタの内容と
..
スタックの内容全部を表示します。
これは、忘れてしまった時に使ったり、あるコマンドがどのような効果を
もたらすのかを知りたい時には、良いコマンドです。
.PD
.SH
計算
.TP
.B +
2 つの値をスタックから取り出し、加算を行い、結果をスタックに積みます。
結果の精度は、引数の値にだけによって決まり、十分正確です。
.TP
.B -
2 つの値を取り出し、最初に取り出した値を 2 番目に取り出した値から
引きます。その後、結果をスタックに積みます。
.TP
.B *
2 つの値を取り出し、かけ算を行い、結果をスタックに積みます。
結果の小数の桁数は、
現在の精度値 (以下参照) と 2 つの引数の小数の桁数に依存します。
.TP
.B /
2 つの値を取り出し、2 番目に取り出した値を最初に取り出した値で割り、
結果をスタックに積みます。
小数の桁数は、精度値によって指定されます。
.TP
.B %
2 つの値を取り出し、
.B /
で計算された割算の余りを計算し、結果をスタックに積みます。
計算される値は、文字列 \fBSd dld/ Ld*-\fP で計算される値と同じです。
.TP
.B ~
2 つの値を取り出し、2 番目に取り出した値を最初に取り出した値で割り、
その商を先にスタックに積み、続いて余りを積みます。
割算に使われる小数の桁数は、精度値によって指定されます。
(エラーチェック機構はわずかに異なりますが、文字列 \fBSdSn lnld/ LnLd%\fP
もこの機能と同様に働くでしょう。)
.TP
.B ^
2 つの値を取り出し、最初に取り出した値を指数とし、
2 つめの値を底として指数計算します。
指数の小数点以下は無視されます。
精度値は、結果の小数の桁数を指定します。
.TP
.B |
3 つの値を取り出し、べき剰余 (modular exponentiation) を計算します。
最初に取り出した値は法 (reduction modulus) (この値は 0 以外の整数で
なくてはいけません。)、2 番目に取り出した値は指数 (この値は
非負の数字でなければならず、小数点以下は無視されます。)、
3 番目に取り出した値は累乗される底として用いられます。
これは整数であるべきです。
小さな整数に関しては、この機能は文字列 \fBSm lble^ Lm%\fP のように
働きます。しかし、\fB^\fP を使う場合と違い、このコマンドは指数が
非常に大きくても働くはずです。
.TP
.B v
1 つの値を取り出し、平方根を求め、結果をスタックに積みます。
精度値は、結果の小数の桁数を指定します。
.PP
ほとんどの演算子は、``精度値'' に影響を受けます。
精度値は、
.B k
コマンドで設定することができます。
デフォルトの精度値は 0 です。これは、足し算と引き算を除くすべての算術は
整数値の結果を出すことを意味しています。
.SH
スタックの制御
.TP
.B c
スタックを消去し、空にします。
.TP
.B d
スタック先頭の値を複製し、スタックに積みます。
したがって、``4d*p'' は 4 の自乗を計算し、表示します。
.TP
.B r
スタック先頭の値と 2 番目の値の順番を入れ換えます。(交換します。)
.SH
レジスタ
.PP
\*(dc は、少なくとも 256 個のメモリレジスタを持っています。
各レジスタは、1 文字の名前を持っています。
数字や文字列をレジスタに保存し、後で取り出すことができます。
.TP
.BI s r
スタックの先頭から値を取り出し、レジスタ
.IR r
に保存します。
.TP
.BI l r
レジスタ
.I r
の値を複製し、それをスタックに積みます。
これは、
.IR r
の内容を変更しません。
.PP
各レジスタは、それ自身のスタックを持っています。
現在のレジスタ値は、レジスタスタックの先頭です。
.TP
.BI S r
(メイン) スタックの先頭の値を取り出し、レジスタ
.IR r
のスタックにそれを積みます。
レジスタの以前の値は、アクセスできなくなります。
.TP
.BI L r
レジスタ
.IR r
のスタックの先頭の値を取り出し、それをメインスタックに積みます。
レジスタ
.IR r
のスタックにあった以前の値がもしあれば、
.BI l r
コマンドを使ってアクセス可能となります。
.ig
.PP
.B f
コマンドは、すべての内容が保存されているレジスタのリストを、
その内容ともに表示します。
各レジスタの現在の内容 (つまりレジスタスタックの先頭)
だけが表示されます。
..
.SH
パラメータ
.PP
\*(dc は、その操作を制御するための 3 つのパラメータを持っています:
精度と、入力の基数、出力の基数です。
精度は、ほとんどの算術操作の結果で保存される小数の桁数を指定します。
入力の基数は、入力された数字の解釈を制御します。
入力されたすべての数字はこの基数をつかっているとされます。
出力の基数は、表示する数字で使われます。
.PP
入力と出力の基数は、分離されたパラメータです。
等しく設定しなくてもいいですが、これは便利だったり紛らわしかったりします。
入力の基数は 2 から 16 の範囲でなければなりません。
出力の基数は最低 2 でなければなりません。
精度は 0 以上でなければなりません。
精度は、現在の入力基数や出力基数に関係なく、いつも 10 進の桁数で決められます。
.TP
.B i
スタックの先頭から値を取り出し、入力基数を設定するために使います。
.TP
.B o
スタックの先頭から値を取り出し、出力基数を設定するために使います。
.TP
.B k
スタックの先頭から値を取り出し、精度を設定するために使います。
.TP
.B I
現在の入力基数をスタックに積みます。
.TP
.B O
現在の出力基数をスタックに積みます。
.TP
.B K
現在の精度をスタックに積みます。
.SH
文字列
.PP
\*(dc は、数と同じように文字列を操作できます。
文字列に対してできる唯一のことは、それを表示し、マクロとして
実行することです。
マクロとは、\*(dc コマンドとして実行される文字列の内容のことです。
すべてのレジスタとスタックは文字列を保存できます。
そして、\*(dc はいつも、与えられたデータが文字列か数字かを
知っています。
算術操作のようないくつかのコマンドは、数を必要としており、
文字列が与えられた場合はエラーが表示されます。
他のコマンドは、数字か文字列を受け入れることができます。
例えば、
.B p
コマンドは、両方を受け付けることができ、データをその型に応じて
表示します。
.TP
.BI [ characters ]
(左右の釣合のとれた、
.B [
と
.B ]
で囲まれた
)
.I characters
という文字列を作り、それをスタックに積みます。
例えば、
.B [foo]P
は文字列
.B foo
を表示します (が、改行文字は表示しません)。
.TP
.B a
スタック先頭の値を取り出し、それが数字なら、その低位バイトを
文字列に変換し、スタックに積みます。文字列なら、その最初の文字が
スタックに積み戻されます。
.TP
.B x
スタックから値を取り出し、マクロとして実行します。
普通、これは文字列です。数の場合は、単純にその値がスタックに
積み戻されます。
例えば、
.B [1p]x
は、マクロ
.B 1p
を実行します。
.B 1p
は、
.B 1
をスタックに積み、別の行に
.B 1
を表示します。
.PP
マクロは、しばしばレジスタにも保存されます。
.B [1p]sa
は、
.B 1
を表示するためのマクロを
レジスタ
.BR a
に保存します。
.B lax
でこのマクロは実行できます。
.TP
.BI > r
スタックから 2 つの値を取り出し、それらを数と仮定して比較し、
もともとのスタックの先頭が大きい場合、レジスタ
.I r
の内容を実行します。
したがって、
.B 1 2>a
は、レジスタ
.BR a
の内容を実行しますが、
.B 2 1>a
では実行しません。
.TP
.BI !> r
似ていますが、もともとのスタックの先頭が 2 番目の値よりも大きくない場合
(2 番目の値以下である場合)、マクロを起動します。
.TP
.BI < r
似ていますが、もともとのスタックの先頭が小さい場合にマクロを実行します。
.TP
.BI !< r
似ていますが、もともとのスタックの先頭が 2 番目の値よりも小さくない場合
(2 番目の値以上である場合)、マクロを起動します。
.TP
.BI = r
似ていますが、2 つの取り出された値が等しい場合にマクロが実行されます。
.TP
.BI != r
似ていますが、2 つの取り出された値が等しくない場合にマクロが実行されます。
.ig
これは、2 つの文字列の等価性を比較するためにも使うことができます。
..
.TP
.B ?
端末から行を読み込み、実行します。
このコマンドは、ユーザからの入力を要求するためのマクロで使えます。
.TP
.B q
マクロを終了し、それを呼び出したマクロからも終了します。
一番上のレベルか、一番上のレベルから直接呼ばれたマクロから呼ばれると、
.B q
コマンドは \*(dc を終了します。
.TP
.B Q
スタックから値を取り出し、それを終了すべきマクロレベル数として、
その数のマクロを終了します。
したがって、
.B 3Q
は、3 つのレベルを終了します。
.B Q
コマンドでは、\*(dc を終了することはありません。
.SH
状態の問い合わせ
.TP
.B Z
スタックから値を取り出し、その桁数 (文字列の場合は、文字数) を計算し、
その値をスタックに積みます。
.TP
.B X
スタックから値を取り出し、その小数点以下の桁数を計算し、
その値をスタックに積みます。文字列の場合、スタックには
.\" -1.
0
が積まれます。
.TP
.B z
現在のスタックの深さを、スタックに積みます。
スタックの深さとは、
.B z
コマンドが実行される前のスタックのデータ数です。
.SH
その他のさまざまなこと
.TP
.B !
行の末尾までをシステムコマンドとして実行します (シェルエスケープ)。
.\"(訳注)シェルエスケープは、訳者が付け足しました。
.\" 2.2.1R 対象(1997/05/04) Takeshi MUTOH <mutoh@info.nara-k.ac.jp>
コマンド !<, !=, !> のパーズが優先しますので、<, =, > で開始する
コマンドを起動したい場合には、! の後に空白を加える必要があります。
.TP
.B #
行の末尾までをコメントとして取り扱います。
.TP
.BI : r
スタックから 2 つの値を取り出します。
スタックの先頭だった値で配列
.IR r
をインデックスし、スタックの先頭から 2 番目だった値をそこに保存します。
.TP
.BI ; r
スタックから値を取り出し、配列
.IR r
のインデックスとして利用します。
配列から選ばれた値は、その後でスタックに積まれます。
.P
レジスタに積まれた各インスタンスは、
それぞれが自身に関連づけられた配列を持つことに注意してください。
このため、\fB1 0:a 0Sa 2 0:a La 0;ap\fP は 1 を表示します。
2 は、後でスタックから取り出された方の 0:a の
インスタンスに保存されたからです。
.SH
バグ
.PP
バグ報告は、
.BR bug-dc@gnu.org
に電子メールでお願いします。
単語 ``dc'' を ``Subject:'' フィールドのどこかに入れておいてください。
