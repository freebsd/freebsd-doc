.\" grep man page
.\" %FreeBSD: src/gnu/usr.bin/grep/grep.1,v 1.25.2.1 2004/11/16 10:47:15 keramida Exp %
.\" $FreeBSD$
.if !\n(.g \{\
.	if !\w|\*(lq| \{\
.		ds lq ``
.		if \w'\(lq' .ds lq "\(lq
.	\}
.	if !\w|\*(rq| \{\
.		ds rq ''
.		if \w'\(rq' .ds rq "\(rq
.	\}
.\}
.de Id
.ds Dt \\$4
..
.Id $Id: grep.1,v 1.16 2005-07-11 13:09:55 metal Exp $
.TH GREP 1 \*(Dt "GNU Project"
.\"
.\" WORD: word-constituent characters	単語構成文字
.SH 名称
grep, egrep, fgrep, zgrep, zegrep, zfgrep,
bzgrep, bzegrep, bzfgrep \- パターンにマッチする行を表示する
.SH 書式
.B grep
.RI [ options ]
.I PATTERN
.RI [ FILE .\|.\|.]
.br
.B grep
.RI [ options ]
.RB [ \-e
.I PATTERN
|
.B \-f
.IR FILE ]
.RI [ FILE .\|.\|.]
.SH 解説
.B grep
は、
.IR FILE
で名前を指定された入力ファイル (ファイルが指定されてないか、
FILE
の部分に
.B \-
が指定された場合は標準入力) を読み込み、与えられた
.IR PATTERN
にマッチする部分を含む行を探します。
デフォルト動作では、
.B grep
はマッチした行を表示します。
.PP
さらに、2 つのプログラム
.B egrep
と
.B fgrep
を利用可能です。
.B egrep
は
.BR "grep\ \-E"
と同じです。
.B fgrep
は
.BR "grep\ \-F"
と同じです。
.B zgrep
は
.BR "grep\ \-Z"
と同じです。
.B zegrep
は
.BR "grep\ \-EZ"
と同じです。
.B zfgrep
は
.BR "grep\ \-FZ"
と同じです。
.SH オプション
.TP
.BI \-A " NUM" "\fR,\fP \-\^\-after-context=" NUM
.I NUM
で指定した行数だけ、パターンにマッチした行の後の行も表示します。
マッチしたグループの間には、
.B \-\^\-
を含む行を挿入します。
.TP
.BR \-a ", " \-\^\-text
バイナリファイルをテキストファイルであるかのように処理します。
これは
.B \-\^\-binary-files=text
オプションと等価です。
.TP
.BI \-B " NUM" "\fR,\fP \-\^\-before-context=" NUM
.I NUM
で指定した行数だけ、パターンにマッチした行の前の行も表示します。
マッチしたグループの間には、
.B \-\^\-
を含む行を挿入します。
.TP
.BI \-C " NUM" "\fR,\fP \-\^\-context=" NUM
.I NUM
で指定した行数だけ、パターンにマッチした行の前後の行も表示します。
マッチしたグループの間には、
.B \-\^\-
を含む行を挿入します。
.TP
.BR \-b ", " \-\^\-byte-offset
各出力行の前に、入力ファイルの先頭からのバイト単位のオフセットを表示します。
.TP
.BI \-\^\-binary-files= TYPE
ファイルの最初の数バイトが、
ファイルの内容がバイナリファイルであることを示す場合、
ファイルのタイプを
.IR TYPE
であると仮定します。
デフォルトでは
.I TYPE
は
.BR binary
であり、
.B grep
は通常、バイナリファイルの一致を示す一行メッセージを表示するか、
マッチしない場合にはなにも表示しません。
.I TYPE
が
.BR without-match
の場合、
.B grep
はバイナリファイルはマッチしないものと仮定します。
これは
.B \-I
オプションと等価です。
.I TYPE
が
.BR text
の場合、
.B grep
はバイナリファイルをテキストであるかのように扱います。
これは
.B \-a
オプションと等価です。
.I 警告:
.B "grep \-\^\-binary-files=text"
はバイナリのゴミを表示する可能性があります。
出力先が端末である場合で、
端末ドライバがこのゴミの一部をコマンドであると解釈する場合、
このゴミが悪い副作用をおよぼす可能性があります。
.TP
.BI \-\^\-colour[=\fIWHEN\fR] ", " \-\^\-color[=\fIWHEN\fR]
マッチした文字列を
.B GREP_COLOR
環境変数でで指定されたマーカで囲みます。
WHEN は、`never' または `always'、`auto' のどれかです。
.TP
.BR \-c ", " \-\^\-count
通常の出力はせず、各入力ファイルについてマッチした行数を表示します。
.BR \-v ", " \-\^\-invert-match
オプションと共に指定した場合は、
マッチしなかった行数を表示します (下記参照)。
.TP
.BI \-D " ACTION" "\fR,\fP \-\^\-devices=" ACTION
入力ファイルがデバイス、FIFO もしくはソケットの場合、
.I ACTION
を使ってその処理を行います
デフォルトでは
.I ACTION
は
.BR read
であり、デバイスが通常ファイルであるかのように読み取る事を意味します。
.I ACTION
が
.BR skip
なら、デバイスを黙って読み飛ばします。
.TP
.BI \-d " ACTION" "\fR,\fP \-\^\-directories=" ACTION
入力ファイルがディレクトリの場合に、
.I ACTION
を使ってその処理を行います。デフォルトでは
.I ACTION
は
.BR read
であり、ディレクトリを普通のファイルであるかの様に読み取る事を意味します。
.I ACTION
が
.BR skip
なら、ディレクトリを黙って読み飛ばします。
.I ACTION
が
.BR recurse
なら、
.B grep
は各ディレクトリ下のすべてのファイルを再帰的に読み取ります。
これは
.B \-r
オプションと等価です。
.TP
.BR \-E ", " \-\^\-extended-regexp
.I PATTERN
を拡張された正規表現として扱います (下記参照)。
.TP
.BI \-e " PATTERN" "\fR,\fP \-\^\-regexp=" PATTERN
.I PATTERN
をパターンとして指定します。
.BR \-
で始まるパターンを保護するために有効です。
.TP
.BR \-F ", " \-\^\-fixed-strings
.I PATTERN
を改行で区切られた固定文字列のリストとして扱います。
その文字列のどれかとマッチするかを調べます。
.TP
.BR \-P ", " \-\^\-perl-regexp
.I PATTERN
を Perl の正規表現として解釈します。
.TP
.BI \-f " FILE" "\fR,\fP \-\^\-file=" FILE
パターンを
.IR FILE
から 1 行ごとに読み込みます。
空のファイルはパターンを含まないので、何にもマッチしません。
.TP
.BR \-G ", " \-\^\-basic-regexp
.I PATTERN
を基本的な正規表現として扱います (下記参照)。デフォルトです。
.TP
.BR \-H ", " \-\^\-with-filename
各々のマッチに対してファイル名を表示します。
.TP
.BR \-h ", " \-\^\-no-filename
複数ファイルを検索した時に、出力の前にファイル名を付けることを抑制します。
.TP
.B \-\^\-help
簡単なヘルプメッセージを出力します。
.TP
.BR \-I
バイナリファイルをマッチするデータを含まないかのように処理します。これは
.B \-\^\-binary-files=without-match
オプションと等価です。
.TP
.BR \-i ", " \-\^\-ignore-case
.I PATTERN
と入力ファイルの双方で、英大文字と小文字の区別をしないようにします。
.TP
.BR \-L ", " \-\^\-files-without-match
通常の出力はせず、
このオプションを指定しなかったときに
全く出力されない入力ファイルの名前を表示します。
スキャン動作は最初のマッチで終了します。
.TP
.BR \-l ", " \-\^\-files-with-matches
通常の出力はせず、
このオプションを指定しなかったときに
出力される入力ファイルの名前を表示します。
スキャン動作は最初のマッチで終了します。
.TP
.BI \-m " NUM" "\fR,\fP \-\^\-max-count=" NUM
.I NUM
個のマッチした行のあと、ファイルの読み取りを停止します。
もし、通常ファイルから標準入力を介して入力が行われており、
.I NUM
個のマッチした行が出力だった場合、
その後に続くコンテキスト行があるかどうかに関わらず、
.B grep
は、終了する前に標準入力が最後にマッチした行の直後に位置される事を保証します。
これによって、呼び出したプロセスが検索を再開する事が可能となります。
.I NUM
個のマッチした行の後に停止した場合、
.B grep
は、その後に続くコンテキスト行を出力します。
.B \-c
や
.B \-\^\-count
オプションも指定された場合、
.B grep
は
.IR NUM
より大きな行数を出力しません。
.B \-v
や
.B \-\^\-invert-match
オプションも指定された場合、
.B grep
は
.I NUM
個のマッチしない行の出力後に停止します。
.TP
.B \-\^\-mmap
可能ならば、デフォルトの
.BR read (2)
システムコールの代わりに
.BR mmap (2)
システムコールを使って入力を読み取ります。
ある状況において、
.B \-\^\-mmap
はよりよい性能をもたらします。
しかし、
.B grep
の動作中に入力ファイルが小さくなるか、または I/O エラーが生じた場合に、
.B \-\^\-mmap
は (コアダンプを含む) 未定義の動作を引き起こす可能性があります。
.TP
.BR \-n ", " \-\^\-line-number
各出力行の前に、入力ファイルにおける行番号を表示します。
.TP
.BR \-o ", " \-\^\-only-matching
マッチした行の
.I PATTERN
にマッチした部分のみを表示します。
.TP
.BI \-\^\-label= LABEL
実際には標準入力からの入力を、ファイル
.I LABEL
からの入力として表示します。
これは zgrep などのツールに対して、特に便利です。
例:
.B "gzip -cd foo.gz |grep --label=foo something"
.TP
.BR \-\^\-line-buffered
行ごとに出力をおこないます。
これはパフォーマンスが悪くなる事があります。
.TP
.BR \-q ", " \-\^\-quiet ", " \-\^\-silent
沈黙: 標準出力には何も出力しません。
何かマッチした場合、エラーが起きた時でも直ちに返り値 0 で終了します。
.B \-s
や
.B \-\^\-no-messages
オプションも参照。
.TP
.BR \-R ", " \-r ", " \-\^\-recursive
各ディレクトリ下のすべてのファイルを再帰的に読み取ります。
これは
.B "\-d recurse"
オプションと等価です。
.TP
.BR "\fR \fP \-\^\-include=" PATTERN
.I PATTERN
にマッチするファイルのみを検索しながら、ディレクトリを再帰します。
.TP
.BR "\fR \fP \-\^\-exclude=" PATTERN
.I PATTERN
にマッチするファイルを読み飛ばしながら、ディレクトリを再帰します。
.TP
.BR \-s ", " \-\^\-no-messages
指定されたファイルが存在しないことや読み込みできないことを示す
エラーメッセージを抑止します。
移植性に関する注: \s-1GNU\s0
.BR grep
とは異なり、
伝統的な
.B grep
は \s-1POSIX.2\s0 に適合していませんでした。なぜなら、伝統的な
.B grep
には
.B \-q
オプションが無く、
.B \-s
オプションは \s-1GNU\s0
.BR grep
の
.B \-q
オプションの様に動作したからです。
伝統的な
.B grep
へ移植可能であることを意図したシェルスクリプトは、
.B \-q
と
.B \-s
を両方とも使わずに、出力を /dev/null へリダイレクトすべきです。
.TP
.BR \-U ", " \-\^\-binary
ファイルをバイナリとして扱います。デフォルトでは、MS-DOS と MS-Windows 環境下で
.BR grep
は、ファイルから読み取った最初の 32KB
の内容を見て、ファイルタイプを推測します。
.BR grep
はファイルをテキストファイルと判断した場合、オリジナルのファイル内容から
(
.B ^
と
.B $
が使われている正規表現を正しく動作させるために )
CR 文字を取り除きます。
.B \-U
を指定すると、この当て推量を抑制し、すべてのファイルを読み取って
マッチ機構へそのまま渡します。もしファイルが
各行の末尾に CR/LF の組みを持つテキストファイルなら、
このオプションは正規表現を役に立たなくさせることがあるでしょう。
このオプションは MS-DOS と MS-Windows 以外のプラットフォームでは
効果がありません。
.TP
.BR \-u ", " \-\^\-unix-byte-offsets
unix 形式のバイト単位オフセットを報告します。このスイッチを指定すると
.B grep
は、ファイルが unix 形式のテキストファイル、
すなわち、 CR 文字が取り除かれたファイルであるかのごとくに
バイト単位オフセットを報告します。
このことは
.B grep
を Unix マシンで動作させたのと同じ結果を生成します。
このオプションは
.B \-b
オプションも使用しない限り効果がありません。
MS-DOS と MS-Windows 以外のプラットフォームでは効果がありません。
.TP
.BR \-V ", " \-\^\-version
.B grep
のバージョン番号を標準エラー出力に表示します。バグレポート
には、この番号を付記してください (下記参照)。
.TP
.BR \-v ", " \-\^\-invert-match
結果を反転し、マッチしなかった行を選択します。
.TP
.BR \-w ", " \-\^\-word-regexp
完全な語にマッチする行のみを選択します。
マッチする部分文字列が行頭から始まっているか、
単語構成文字以外の文字が前にあることがテストされます。
同様に、マッチする部分文字列が行末まであるか、
単語構成文字以外の文字が後にある必要があります。
単語構成文字とは、レター・数字・アンダスコアです。
.TP
.BR \-x ", " \-\^\-line-regexp
行全体と正確にマッチする行のみを選択します。
.TP
.B \-y
.BR \-i
と同じ意味を持つ旧式のオプションです。
.TP
.B \-\^\-null
通常ファイル名の後に続く文字の代わりにバイト 0 (\s-1ASCII\s0
.B NUL
文字) を出力します。
例えば、
.B "grep \-l \-\^\-null"
は各ファイル名の後に、通常の newline ではなくバイト 0 を出力します。
このオプションを指定すると、
newline 等の例外的な文字を含むファイル名に直面した場合でも
出力が明白になります。
このオプションを
.BR "find \-print0" ,
.BR "perl \-0" ,
.BR "sort \-z" ,
.B "xargs \-0"
等のコマンドと共に使用すれば、任意のファイル名を処理できます。
ファイル名が newline 文字を含んでいても処理可能です。
.TP
.BR \-Z ", " \-\^\-decompress
検索を開始する前に入力データを伸長します。
このオプションは
.BR zlib (3)
ライブラリと共にコンパイルした場合のみ使用可能です。
.BR \-J ", " \-\^\-bz2decompress
検索を開始する前に入力データを
.BR bzip2 (1)
を使用して伸長します。
.SH "正規表現"
正規表現は、文字列の集合を表現するパターンの事です。数式表現と同様に、
より小さな表現を組み合わせるさまざまな演算子を用いる事で、
正規表現を組み立てます。
.PP
.B grep
は、「基本」正規表現と
「拡張」正規表現の 2 種類の正規表現文法を扱う事ができます。
.RB "\s-1GNU\s0\ " grep
では、どちらの正規表現文法も機能的な違いはありません。
他の実装では、基本正規表現は拡張正規表現より能力が低くなっています。
ここでは、拡張正規表現について説明します。
基本正規表現との違いは、その後に説明します。
.PP
正規表現の基本単位は、1 文字にマッチする正規表現です。
レターと数字を含む多くの文字は、それ自身にマッチする正規表現です。
また、特殊な意味を持つメタ文字も、その文字の前にバックスラッシュ
を付けると、その本来の文字にマッチするようになります。
.PP
.I "角括弧式"
は、
.B [
と
.B ]
で囲まれた文字のリストです。
これは、そのリスト中に含まれるどれか 1 文字にマッチします。
ただし、リストの先頭がキャレット
.B ^
の場合は、そのリストに含まれ
.I ない
文字にマッチします。
例えば、正規表現
.B [0123456789]
は数字 1 文字にマッチします。
.PP
角括弧式内で、
.I "範囲式"
はハイフンで分けられた 2 文字で構成されます。
これは、ロケールの照合順序や文字集合を用いて、
この 2 文字を含み、この間に並ぶ 1 文字にマッチするものです。
例えば、デフォルトの C ロケールでは、
.B [a\-d]
は
.BR [abcd]
と等価です。
多くのロケールでは文字を辞書順に並べており、そのようなロケールでは、
.B [a\-d]
は一般的に
.BR [abcd]
と等価ではなく、例えば
.BR [aBbCcDd]
と等価かもしれません。
角括弧式の古典的な解釈を使用するには、
.B LC_ALL
環境変数に値
.BR C
を設定し、C ロケールを使用してください。
.PP
最後に、特定の名前を持つ文字クラスが、角括弧式にて
以下のようにあらかじめ定義されています。
.BR [:alnum:] ,
.BR [:alpha:] ,
.BR [:cntrl:] ,
.BR [:digit:] ,
.BR [:graph:] ,
.BR [:lower:] ,
.BR [:print:] ,
.BR [:punct:] ,
.BR [:space:] ,
.BR [:upper:] ,
.BR [:xdigit:]
例えば、
.B [[:alnum:]]
は
.BR [0\-9A\-Za\-z] ,
と同じですが、後者が C ロケールや \s-1ASCII\s0 文字符号化に
依存するのに対して、前者はロケールや文字集合に依存しません。
(クラス名の中の角括弧はシンボル名の一部であり、
リストを区切る角括弧とは別に指定する必要があることに注意)
リストの中では、ほとんどのメタ文字は通常の文字として扱われます。
リテラル
.B ]
を含めるには、この文字をリストの先頭に置いてください。同様に、リテラル
.B ^
を含めるには、この文字をリストの先頭以外に置いてください。リテラル
.B \-
を含めるには、この文字をリストの最後に置いてください。
.PP
ピリオド
.B .
は、任意の 1 文字にマッチします。
シンボル
.B \ew
は
.B [[:alnum:]]
と同じ意味で、
シンボル
.B \eW
は
.BR [^[:alnum:]]
と同じ意味です。
.PP
キャレット
.B ^
と、
ドル記号
.B $
は、それぞれ行頭と行末の空文字列にマッチするメタ文字です。
シンボル
.B \e<
とシンボル
.B \e>
は、それぞれ単語の先頭と末尾の空文字列にマッチするメタ文字です。
シンボル
.B \eb
は単語の端の空文字列にマッチします。
シンボル
.B \eB
は単語の端
.I 以外
の空文字列にマッチします。
.PP
正規表現の後には、繰り返し演算子のどれかが続くことがあります。
.PD 0
.TP
.B ?
直前の項目はオプションであり、最大 1 回マッチします。
.TP
.B *
直前の項目は 0 回以上マッチします。
.TP
.B +
直前の項目は 1 回以上マッチします。
.TP
.BI { n }
直前の項目は厳密に
.I n
回マッチします。
.TP
.BI { n ,}
直前の項目は
.I n
回以上マッチします。
.TP
.BI { n , m }
直前の項目は、最低
.I n
回、最大
.I m
回マッチします。
.PD
.PP
2 つの正規表現は結合可能です。
結果としてできあがる正規表現は、
結合された 2 つの部分表現にそれぞれマッチする
2 つの部分文字列を結合した任意の文字列にマッチします。
.PP
2 つの正規表現は中置き型演算子
.BR |
で繋ぐことが可能です。
結果としてできあがる正規表現は、
どちらかの部分表現にマッチする任意の文字列にマッチします。
.PP
繰り返しは結合に優先します。また結合は選択に優先します。
これらの優先規則を無効とするために、
部分表現全体を括弧で囲むことが可能です。
.PP
.I n
が 1 つの数字であるような
後方参照
.BI \e n
は、正規表現中の括弧で囲まれた
.IR n
番目の部分表現がマッチした文字列とマッチします。
.PP
基本正規表現では、メタ文字
.BR ? ,
.BR + ,
.BR { ,
.BR | ,
.BR ( ,
.BR )
は、その特殊な意味を失います。代わりに、バックスラッシュを付けた
.BR \e? ,
.BR \e+ ,
.BR \e{ ,
.BR \e| ,
.BR \e( ,
.BR \e)
を使用してください。
.PP
伝統的な
.B egrep
は、メタ文字
.B {
をサポートしませんでした。また、このメタ文字の代わりに
.B \e{
をサポートする
.B egrep
実装もいくつか存在するので、移植可能なスクリプトでは、
リテラル
.BR {
にマッチさせるために
.B egrep
パターンで
.B {
を使うことは避けて
.B [{]
を使うべきです。
.PP
\s-1GNU\s0
.B egrep
は、
.B {
が不正な範囲指定の始まりであるなら特殊文字ではない、と想定して、
伝統的な使用法のサポートを試みます。
例えば、シェルコマンド
.B "egrep '{1'"
は正規表現の文法エラーを報告せずに、2 文字の文字列
.B {1
を検索します。
\s-1POSIX.2\s0 は、この動作を一つの拡張として許可していますが、
移植可能なスクリプトではこの使用法を避けるべきです。
.SH "環境変数"
grep の動作は、以下の環境変数によって影響を受けます。
.PP
ロケール
.BI LC_ foo
は、以下の 3 つの環境変数
.BR LC_ALL ,
.BR LC_\fIfoo\fP ,
.BR LANG
がこの順番で検査される事によって、指定されます。
これらの変数の中で最初に設定されていたものによって、ロケールが指定されます。
例えば、
.B LC_ALL
が設定されておらず、
.B LC_MESSAGES
が
.BR pt_BR
に設定されていた場合、
ブラジルのポルトガル語が
.B LC_MESSAGES
ロケールに対して使用されます。
これらの環境変数がどれも設定されていなかったり、
もしくはロケールのカタログがインストールされていなかったり、
また
.B grep
が各国語サポート (\s-1NLS\s0) なしでコンパイルされていた場合、
C ロケールが使用されます。
.TP
.B GREP_OPTIONS
この変数は明示的なオプションの前に指定されるデフォルトオプションを
指定します。例えば、もし
.B GREP_OPTIONS
が
.BR "'\-\^\-binary-files=without-match \-\^\-directories=skip'"
である場合、
.B grep
は 2 つのオプション
.B \-\^\-binary-files=without-match
と
.B \-\^\-directories=skip
が明示的なオプションの前に指定されている様に動作します。
オプションの指定は空白によって区切られます。
バックスラッシュは次の文字をエスケープします。
これは空白やバックスラッシュを含むオプションを指定するために用いられます。
.TP
.B GREP_COLOR
ハイライトするマーカを指定します。
.TP
\fBLC_ALL\fP, \fBLC_COLLATE\fP, \fBLANG\fP
これらの変数は、
.BR [a\-z]
のような範囲式を解釈する際の参照順序を決定する
.B LC_COLLATE
を指定します。
.TP
\fBLC_ALL\fP, \fBLC_CTYPE\fP, \fBLANG\fP
これらの変数は、
例えばどの文字が空白であるかなど、文字の種類を決定する
.B LC_CTYPE
を指定します。
.TP
\fBLC_ALL\fP, \fBLC_MESSAGES\fP, \fBLANG\fP
これらの変数は、
.B grep
の出すメッセージの言語を決定する
.B LC_MESSAGES
を指定します。
デフォルトの C ロケールは、アメリカ英語のメッセージを使用します。
.TP
.B POSIXLY_CORRECT
設定されている場合、
.B grep
は \s-1POSIX.2\s0 として動作し、それ以外の場合は
.B grep
は他の \s-1GNU\s0 プログラムのように動作します。
\s-1POSIX.2\s0 ではファイル名の後に続くオプションは
ファイル名として扱われます。
デフォルトでは、このようなオプションはオペランドリストの先頭に
並び変えられて、オプションとして扱われます。
また、\s-1POSIX.2\s0 では認識できないオプションは
\*(lq 不法 (illegal)\*(rq であると診断されますが、
法律に違反しているわけではないので、
デフォルトではこれらは\*(lq不正 (invalid)\*(rq であると診断されます。
.SH 診断
.PP
通常、選択された行が見つかった場合は 0 を、
見つからなかった場合は 1 を返します。
エラーが生じた場合 2 を返しますが、
.B \-q
や
.B \-\^\-quiet
、
.B \-\^\-silent
オプションが指定されており、選択された行が見つかった場合は、
その限りではありません。
.SH バグ
バグレポートは、
.BR bug-gnu-utils@gnu.org
まで Email してください。
この時、\*(lqSubject:\*(rq のどこかに
\*(lqgrep\*(rq という単語を
忘れずに入れてください。
.PP
.BI { n , m }
の表現で非常に大きな繰り返しを指定すると、非常に多くのメモリを消費します。
さらに、ある種のあいまいな正規表現を指定すると、必要となる時間とメモリ領域は
指数的に増大し、
.B grep
がメモリ不足を起こす可能性があります。
.PP
後方参照は非常に動作が遅く、必要となる時間は指数的に増大します。
.\" Work around problems with some troff -man implementations.
.br
