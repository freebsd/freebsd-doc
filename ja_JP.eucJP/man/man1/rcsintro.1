.\" $FreeBSD$
.de Id
.ds Rv \\$3
.ds Dt \\$4
..
.Id %FreeBSD: src/gnu/usr.bin/rcs/rcs/rcsintro.1,v 1.5 1999/08/27 23:36:53 peter Exp %
.ds r \&\s-1RCS\s0
.if n .ds - \%--
.if t .ds - \(em
.if !\n(.g \{\
.	if !\w|\*(lq| \{\
.		ds lq ``
.		if \w'\(lq' .ds lq "\(lq
.	\}
.	if !\w|\*(rq| \{\
.		ds rq ''
.		if \w'\(rq' .ds rq "\(rq
.	\}
.\}
.am SS
.LP
..
.TH RCSINTRO 1 \*(Dt GNU
.SH 名称
rcsintro \- RCS 入門
.SH 解説
\*r (Revision Control System) は、ファイルのリビジョンを複数管理します。
\*r は格納、取り出し、ログ、識別、リビジョンの併合を自動化します。\*r
は頻繁に更新されるテキスト、たとえば、プログラム、ドキュメント、
グラフィックス、論文、定型手紙等を扱うのに便利です。
.PP
基本的なユーザインタフェースはとても単純です。初心者は 2 つのコマンド、
.BR ci (1)
と
.BR co (1)
を覚えるだけで使用できます。
.B ci
はチェックイン
\*(lqcheck in\*(rq を省略した名前です。これは、ファイルの内容を
「\*r ファイル」と呼ばれる記録用のファイルに格納します。
\*r ファイルは、特定ファイルの全リビジョンを含んでいます。
.B co
はチェックアウト\*(lqcheck out\*(rq を省略した名前です。
これは、\*r ファイルからリビジョンを取り出します。
.SS "\*r の機能"
.IP \(bu
テキストの複数のリビジョンの保存と取り出しを行います。\*r は
すべての古いリビジョンを効率的な方法で保存します。
ファイルを変更しても
元のリビジョンが失なわれることはなく、いずれも取り出すことが
可能です。リビジョンは、リビジョン番号、シンボル名、日付、作者、
状態を指定して取り出せます。
.IP \(bu
完全な変更の履歴を管理します。\*r は、すべての変更点を自動的に
記録します。各リビジョンの内容とともに、作者、チェックインした日時、
変更点を要約したログメッセージが記録されます。
ログによって、どのような変更が行われたのかがひと目でわかります。
ソースリストを見比べたり、一緒に作業している
プログラマにたずねたりする必要はありません。
.IP \(bu
アクセス矛盾を解決します。複数のプログラマがあるファイルの
同じリビジョンに対して変更を加えようとした場合、
\*r は警告を発し、他者が行った変更を台無しにしてしまう
のを防ぎます。
.IP \(bu
リビジョンの木を管理します。\*r はモジュールごとに独立した
開発ラインを管理できます。
\*r は、リビジョンの系図を表現した木を保存します。
.IP \(bu
リビジョンを併合し、矛盾を解決します。あるモジュールの 2 つの
リビジョンを併合することができます。
併合しようとする 2 つのリビジョンが、あるコードの同じ部分に
対する変更を含んでいた場合、\*r は変更が重複していると警告します。
.IP \(bu
リリースと構成を管理します。リビジョンにはシンボル名を
つけることができます。また、「リリース版(released)」、「安定版(stable)」、
「実験版(experimental)」といった状態をつけることもできます。
これにより、単純かつ直接的にモジュールの構成を表すことができます
.IP \(bu
リビジョン番号、作成日時、作者等を自動的に識別することができます。
識別情報は、消印のようにテキストの適当な場所に埋め込むことが
できます。これにより、あるソフトウェアの構成に
どのモジュールのどのリビジョンが使用されているかを
判断することが容易になります。
.IP \(bu
必要なディスク容量を最小にします。\*r は、リビジョンのために
最小のスペース(差分のみ)しか消費しません。もし途中のリビジョンが
削除されたなら、記録されていた差分もそれに従って小さくなります。
.SS "\*r 事始め"
\*r の管理下に置きたい
.B f.c
というファイルがあるとします。もし、まだ作成していなければ、
\*r ディレクトリを以下のコマンドにより作成します。
.IP
.B "mkdir  RCS"
.LP
次に ci (チェックイン) コマンドを実行します。
.IP
.B "ci  f.c"
.LP
これにより、
.B f.c
の内容をリビジョン 1.1 として記録
した \*r ファイルが
.B RCS
ディレクトリ内に
作成され、
.B f.c
は削除されます。また、
.B ci
は
.B f.c
に
関する説明文の入力を促します。
説明文にはファイルの内容を要約して書きます。
以降
.B ci
を実行するたびに、ファイルに加えた変更の要約を入力するように促します。
.PP
\*r ディレクトリにあるファイルは \*r ファイルと呼ばれ、
それ以外のファイルはワークファイルと
呼ばれます。先の例で挙げたワークファイル
.B f.c
を取り戻す
には
.B co
(チェックアウト) コマンドを実行します。
.IP
.B "co  f.c"
.LP
このコマンドは \*r ファイル中の最新のリビジョンを取り出してファイル
.B f.c
に書き出します。
もし、
.B f.c
に変更を加えたければ、次のコマンドを使ってチェックアウトしロック
しなければいけません。
.IP
.B "co  \-l  f.c"
.LP
これで
.B f.c
を編集することができます。
.PP
ある程度編集したところで、どのような変更を加えたか
知りたくなるときがあります。
この場合は、以下のコマンドを実行します。
.IP
.B "rcsdiff  f.c"
.LP
このコマンドは、最後にチェックインしたリビジョンと
ワークファイルの違いを表示します。編集が終わったら、
以下のコマンドにより、もう一度チェックインすることができます。
.IP
.B "ci  f.c"
.LP
これにより、リビジョン番号が自動的に付け直されます。
.PP
もし
.B ci
が
.IP
.BI "ci error: no lock set by " "your name"
.LP
というエラーメッセージを出力したなら、
それは、ロックせずにチェックアウトしたファイルを
チェックインしようとしたからです。もちろん、
ここでロックしチェックアウトし直すのでは遅すぎます。
ここでチェックアウトすると、あなたが行った編集は
上書きされて失われてしまうからです。
かわりに、以下のコマンドを実行します。
.IP
.B "rcs  \-l  f.c"
.LP
これは、ほかに誰もロックしていなければ、最新のリビジョンを
ロックします。もし、すでに誰かがロックしてしまっていたなら、
その人と相談しなければなりません。
.PP
ロックすることにより、あなただけがファイルを更新(チェックイン)
できるようになり、同時に複数の人が同じファイルを編集する際の
厄介な問題を回避することができます。たとえリビジョンが
ロックされていても、そのファイルをチェックアウトして内容を見たり、
コンパイルすることは可能です。ロック機構は、ロックした人
以外が
.I チェックイン
できないようにするだけです。
.PP
もし扱う \*r ファイルが個人的なもの、すなわち
そのファイルに対して新しいリビジョンをチェックインするのが
あなただけである場合、厳格なロック機構は必要ないでしょう。
厳格なロック機構はオフにすることもできます。
もし厳格なロックモードがオフになっているなら、
\*r ファイルの所有者はロックしていないファイルをチェックイン
することができます(それ以外の人はロックが必要です)。
厳格なロックモードのオンとオフは、
それぞれ以下のコマンドにより行います。
.IP
.BR "rcs  \-L  f.c" "     及び     " "rcs  \-U  f.c"
.LP
もしワークディレクトリに \*r ファイルをまき散らしたく
ないなら、\*r という名前のディレクトリを作成し、\*r ファイルを
すべてその下に移動します。\*r コマンドは \*r ファイルを探すとき、
まず、
.B RCS
ディレクトリを検索します。この場合も、これまでに述べてきたコマンドは
引数をいっさい変更せずに実行できます(実際は \*r に \*r ファイルと
ワークファイルの対を指示する方法は 3 通りあります:
(a) 両方を指定する、(b) ワークファイルのみを指定する、
(c) \*r ファイルのみを指定する。\*r ファイルとワークファイルは
自由なパスに置くことができますが、\*r コマンドはファイルの対を
インテリジェントに探します)。
.PP
チェックインしたときにワークファイルが削除されないようにする
(編集を続けたり、コンパイルしたりする場合)には以下のコマンドを使います。
.IP
.BR "ci  \-l  f.c" "     あるいは     " "ci  \-u  f.c"
.LP
これらのコマンドは通常どおり
.B f.c
をチェックインします。しかし、自動的にチェックアウトも行います。
最初の例ではロックを行い、2 番目の例ではロックを行いません。
このようにすればチェックアウト操作を 1 回省けます。
最初の例は編集を続ける場合に、2 番目の例は単にファイルを
読みたかったりコンパイルしたりする場合に便利です。どちらの場合も、
ワークファイル中の識別用マーカ(後述)が更新されます。
.PP
.B ci
にチェックインするリビジョンの番号を指定することができます。
それまでのリビジョンが 1.1、1.2、1.3... だったときに、以下の
コマンドによりリリース2 を開始することができます。
.IP
.BR "ci  \-r2  f.c" "     あるいは     " "ci  \-r2.1  f.c"
.LP
これにより、新しいリビジョンには番号 2.1 がつけられます。以降、
.I ci
はこの
ファイルの新しいリビジョンに 2.2、2.3...と番号をつけていきます。
対応した以下の
.B co
コマンド
.IP
.BR "co  \-r2  f.c" "     及び     " "co  \-r2.1  f.c"
.PP
は、リビジョン番号が
.RI 2. x
である最新のリビジョン、リビジョン 2.1 をそれぞれ
チェックアウトします。
.B co
にリビジョン番号を指定しない場合、幹(trunk)の上の最新のリビジョン
(すなわち、x.x の形式で最大のリビジョン番号を持つリビジョン)が
チェックアウトされます。リビジョンの枝(branch)を用いるためには 3 つ
以上の番号が必要になります。
たとえば、1.3 から枝を作成するには、以下のコマンドを実行します。
.IP
.B "ci  \-r1.3.1  f.c"
.LP
これにより、リビジョン 1.3 上に番号 1 の枝を作成し、
枝上の最新リビジョンとして 1.3.1.1 を割り当てます。
枝の詳細については
.BR rcsfile (5)
を参照してください。
.SS "自動識別"
\*r は、リビジョンの識別のために特別な文字列をソースや
オブジェクトコードに埋め込むことができます。
リビジョンの識別を行うためには、以下の文字列(マーク)
.IP
.B "$\&Id$"
.LP
をコメントなどのテキスト部分に書きます。
\*r は、このマークを次の形式の文字列に置換します。
.IP
.BI $\&Id: " ファイル名 リビジョン 日付 時刻 作者 状態 " $
.LP
このようなマークをモジュールのソースコードの 1 ページ目に
置くことにより、編集しているファイルのリビジョンを
すぐに判断することができます。\*r はマークの更新を自動的に行います。
マークをオブジェクトコードに組み込むには、それをリテラルな
文字列中に含めます。C 言語では、以下のようにします。
.IP
.ft 3
static char rcsid[] = \&"$\&Id$\&";
.ft
.LP
.B ident
コマンドは、オブジェクトファイルやダンプ出力からもマークを探し表示することが
できます。従って
.B ident
コマンドを用いることにより、あるプログラムがどのモジュールの
どのリビジョンによって作成されたかを知ることができます。
.PP
マーク
.B $\&Log$
をテキストやコメント内に含めることも有用かもしれません。
このマークはチェックインのときに要求されたログを蓄えていきます。
これにより、変更の履歴を直接、ファイルに記録することができます。
\*r にはほかにもいくつかのマークがあります。詳しくは
.BR co (1)
を参照してください。
.SH 作者
Author: Walter F. Tichy.
.br
Manual Page Revision: \*(Rv; Release Date: \*(Dt.
.br
Copyright \(co 1982, 1988, 1989 Walter F. Tichy.
.br
Copyright \(co 1990, 1991, 1992, 1993 Paul Eggert.
.SH 関連項目
ci(1), co(1), ident(1), rcs(1), rcsdiff(1), rcsintro(1), rcsmerge(1), rlog(1)
.br
Walter F. Tichy,
\*r\*-A System for Version Control,
.I "Software\*-Practice & Experience"
.BR 15 ,
7 (July 1985), 637-654.
.br
