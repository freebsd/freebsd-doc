.\"	$NetBSD: timeout.9,v 1.2 1996/06/23 22:32:34 pk Exp $
.\"
.\" Copyright (c) 1996 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to The NetBSD Foundation
.\" by Paul Kranenburg.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"        This product includes software developed by the NetBSD
.\"        Foundation, Inc. and its contributors.
.\" 4. Neither the name of The NetBSD Foundation nor the names of its
.\"    contributors may be used to endorse or promote products derived
.\"    from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
.\" LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.\" %FreeBSD: src/share/man/man9/timeout.9,v 1.20 2003/10/01 21:32:42 imp Exp %
.\" $FreeBSD$
.\"
.Dd September 10, 1996
.Dt TIMEOUT 9
.Os
.Sh 名称
.Nm timeout ,
.Nm untimeout ,
.Nm callout_handle_init ,
.Nm callout_init ,
.Nm callout_stop ,
.Nm callout_reset
.Nd 明示された時間長の後の関数の実行
.Sh 書式
.In sys/types.h
.In sys/systm.h
.Pp
.Bd -literal
typedef void timeout_t (void *);
.Ed
.Ft struct callout_handle
.Fn timeout "timeout_t *func" "void *arg" "int ticks"
.Ft void
.Fn callout_handle_init "struct callout_handle *handle"
.Pp
.Bd -literal
struct callout_handle handle = CALLOUT_HANDLE_INITIALIZER(&handle)
.Ed
.Ft void
.Fn untimeout "timeout_t *func" "void *arg" "struct callout_handle handle"
.Ft void
.Fn callout_init "struct callout *c" "int mpsafe"
.Ft int
.Fn callout_stop "struct callout *c"
.Ft void
.Fn callout_reset "struct callout *c" "int ticks" "timeout_t *func" "void *arg"
.Sh 解説
関数
.Fn timeout
は
.Fa ticks Ns No /hz
秒後に実行されるための引数
.Fa func
によって与えられる関数を呼び出すためのスケジュールを行います。
正ではない値の
.Fa ticks
は沈黙のうちに値
.Sq 1
に変換されます。
.Fa func
は
.Fa void *
の引数を取る関数へのポインタであるべきです。
実行時には、
.Fa func
は
.Fa arg
をその唯一の引数として受け取ります。
.Fn timeout
からの戻り値は、スケージュールされた timeout を取り消す要求のための
.Fn untimeout
関数との接続に使用されることが可能な
.Ft struct callout_handle
です。
.Fn timeout
の呼び出しは古いスタイルで、新しいコードは callout_* 関数を使用するべきです。
.Pp
関数
.Fn callout_handle_init
はハンドルを初期化するために使用し、untimeout と共に
使用されても副作用無しに戻るようにします。
.Pp
コールアウトハンドルに
.Fn CALLOUT_HANDLE_INITIALIZER
の値を割当てることは、
.Fn callout_handle_init
と同様の機能を実行し、静的な宣言またはグローバルなコールアウトハンドルで
使用するために提供されています。
.Pp
関数
.Fn untimeout
は、そのハンドルの正当性を確認するために
.Fa func
および
.Fa arg
引数を使用して、
.Fa handle
に関連付けられた timeout を取り消します。
そのハンドルが引数
.Fa arg
を取る関数
.Fa func
を持つ timeout と一致しない場合には、何も行いません。
.Fa handle
は
.Fn untimeout
に渡される前に以前の
.Fn timeout ,
.Fn callout_handle_init
の呼び出し、または
.Fn CALLOUT_HANDLE_INITIALIZER "&handle"
の値の割当てによって初期化されなければなりません。
以前に初期化されたハンドルを伴なわない untimeout の呼び出しの振る舞いは
未定義です。
.Fn untimeout
の呼び出しは古いスタイルで、新しいコードは callout_* 関数を使用するべきです。
.Pp
ハンドルがシステムによって再利用されるので、
両方の呼び出しが同じ関数のポインタおよび引数を使用し、2 番目の呼び出しの前に
最初の timeout が終了するか取り消された場合には、1 つの
.Fn timeout
の実行からのハンドルが別の
.Fn timeout
の実行のハンドルが一致することができることが (意外ではあるが) 可能です。
timeout の設備は
.Fn timeout
および
.Fn untimeout
のための O(1) 実行時間を提供します。
timeout (訳注: および untimeout) は
.Fn splsoftclock
の状態で
.Fn softclock
から実行されます。
従って、再入から保護されます。
.Pp
関数
.Fn callout_init ,
.Fn callout_stop
および
.Fn callout_reset
は固有のコールアウト構造を割当てることを希望するクライアントのための、
低レベルのルーチンです。
.Pp
関数
.Fn callout_init
はコールアウトを初期化し、そのためそのコールアウトは何の副作用もなしに
.Fn callout_stop
または
.Fn callout_reset
に渡されることができます。
.Fa mpsafe
引数が 0 の場合には、callout 構造体は
.Dq マルチプロセッサセーフ
であるとはみなされません。
すなわち、ジャイアントロックが callout 関数の呼出し前に
獲得され、callout 関数が戻るときに解放されるようにします。
.Pp
関数
.Fn callout_stop
は、そのコールアウトが現在保留中の場合には、コールアウトを取り消します。
コールアウトが保留中の場合には、
.Fn callout_stop
は 0 でない値を返します。
コールアウトが既に実行されたか現在実行中の場合には、0 が返されます。
.Pp
関数
.Fn callout_reset
は最初にそのコールアウトを廃止するために
.Fn callout_stop
を呼び出し、それから新しいコールアウトを
.Fn timeout
と同じ流儀で確立します。
.Sh 戻り値
.Fn timeout
関数は
.Fn untimeout
に渡すことが可能な
.Ft struct callout_handle
を返します。
.Fn callout_stop
関数は呼び出された時にコールアウトが未だ保留の場合には 0 以外を、
そうでない場合には 0 を返します。
.Sh バグ
コールアウトを取り消すか、もし取り消しが遅過ぎた場合には
コールアウトが本当に完了されていることを保証することは、
この API にはできません。
.Fn callout_stop
は 0 を返した時に、コールアウトが開始されていている場合のみを保証します。
コールアウトが完了していることは保証しません。
ドライバのデタッチルーチンから戻る前に実行されるスレッドがないことを
保証したい時に、レース状態を発生させることがあります。
.Sh 歴史
現在の timeout および untimeout ルーチンは
.An Adam M. Costello
および
.An George Varghese
の
.%T "Redesigning the BSD Callout and Timer Facilities"
と名付けられた技術レポートで発表された作業に基づいています。また、
.Fx
への導入のために
.An Justin T. Gibbs
によって少し修正されています。
この実装で使用されているデータ構造の元の作業は、
.An G. Varghese
および
.An A. Lauck
によって
.%B "Proceedings of the 11th ACM Annual Symposium on Operating Systems Principles"
の
.%T "Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility"
で発表されました。
現在の実装は、長らく存在していた、挿入および削除の O(n) 実行時間を
提供するが untimeout 操作のためのハンドルを生成または要求しなかった
.Bx
リンクリストのコールアウト機構に、取って代りました。
