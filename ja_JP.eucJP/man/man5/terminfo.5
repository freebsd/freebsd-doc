'\" t
.\" DO NOT EDIT THIS FILE BY HAND!
.\" It is generated from terminfo.head, Caps, and terminfo.tail.
.\"
.\" Note: this must be run through tbl before nroff.
.\" The magic cookie on the first line triggers this under some man programs.
.\"***************************************************************************
.\" Copyright (c) 1998 Free Software Foundation, Inc.                        *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" %Id: terminfo.head,v 1.9 2000/08/13 01:56:40 tom Exp %
.\" $FreeBSD$
.TH TERMINFO 5 "" "" "File Formats"
.ds n 5
.ds d /usr/share/misc/terminfo
.SH 名称
terminfo \- 端末ケーパビリティのデータベース
.SH 書式
\*d/*/*
.SH 解説
.I terminfo
は端末の特性を記述するデータベースであり、
\fBnvi\fR(1),
\fBrogue\fR(1)
などの画面を活用したプログラムや
\fBcurses\fR(3X)
などのライブラリによって使用されます。
.I terminfo
は、端末が持つケーパビリティの集合を与え、画面操作をどのようにして行うかを
指定し、必要なパディングや初期化シーケンスを指定することで、端末の特性を
記述します。
.PP
.I terminfo
のエントリは、`,' で区切られたフィールドの列からなります (フィールド内の
コンマはバックスラッシュでエスケープするか、\e072 と書きます)。
`,' セパレータの後の空白は無視されます。
各端末を表す最初のエントリは、端末を表すものとして知られている名前を
指定します。名前を複数指定するときは `|' で区切ります。
最初の名前は、その端末のものとして最もよく知られた省略形を与えます。
最後の名前には、その端末を識別できるだけの長い名前を指定するべきです。
それら以外の名前は、同じ端末を指す別名と見なされます。
最後のもの以外の名前は、すべて英小文字からなり、空白が含まれていては
いけません。
最後の名前には、読みやすくするために大文字や空白を含めても構いません。
.PP
端末名 (最後の冗長なものは除く) は、以下の約束にしたがって付けてください。
名前の基本部分を、端末を構成するハードウェアの特徴的部分から名付けます
(``hp2621'' のように)。
この名前にはハイフンを含めてはいけません。
モードや、ユーザの設定が現れる部分については、基本名の後に、
ハイフンとモードの接尾辞つけて表してください。
例えば、vt100 の 132 桁モードは vt100-w のようになります。
使えるところがあれば、以下の接尾辞を使ってください。
.PP
.TS
center ;
l c l
l l l.
\fB接尾辞	意味	例\fP
-\fInn\fP	画面の行数	aaa-60
-\fIn\fPp	画面記憶ページ数	c100-4p
-am	自動マージン付 (通常これがデフォルト)	vt100-am
-m	白黒モード; 色を抑制            	ansi-m
-mc	魔法のクッキー; ハイライトのときの空白	wy30-mc
-na	矢印キー無し (局所的にとどめる) 	c100-na
-nam	自動マージン無し                	vt100-nam
-nl	ステータス行無し                  	att4415-nl
-ns	ステータス行無し                  	hp2626-ns
-rv	反転表示                        	c100-rv
-s	ステータス行有り                	vt100-s
-vb	ビープの代わりに可視ベルを使用  	wy370-vb
-w	幅広モード (> 80 桁、通常 132 桁)	vt100-w
.TE
.PP
端末の命名規則についてさらに知りたいときは \fBterm(7)\fR のマニュアルを
参照してください。
.SS ケーパビリティ
.\" Head of terminfo man page ends here
.ps -1
以下は terminfo の記述ブロックに含まれ、terminfo を使うコードが使用できる
ケーパビリティの完全な表です。表の各行の意味は次の通りです。

\fBvariable\fR は (terminfo レベルの) プログラマがケーパビリティを
使用するときに用いる名前です。

\fBcapname\fR は、データベースのテキストの中で用いる短縮名で、
データベースを更新する人間が用いる名前です。
可能な場合は常に、capname は ANSI X3.64-1979 標準規格 (現在 ECMA-48 に
取って代わられていますが、そこでも同一のもしくは非常に良く似た名前を
使っています) と同一もしくは類似のものを選んであります。その意味も、
その規格での規定に合致するようにしてあります。

termcap code は古典的な
.B termcap
ケーパビリティの名前です (いくつかのケーパビリティは新しいもので、
その名前は termcap に由来しません)。
.P
ケーパビリティの名前の長さには、決まった上限はありません。ただし、名前を
短くし、ソースファイルにタブを使って
.B cap
をきれいに並べられるように、非公式ながら上限 5 文字の制限が既に
採用されています。

最後に、説明ではケーパビリティの意味を伝えようとします。説明の中には
以下のようなコードがある場合があります。
.TP
(P)
パディングが指定可能であることを表します。
.TP
#[1-9]
説明の中では、文字列が (#\fIi\fP) として与えられる引数として
tparm を介して渡されることを示します。
.TP
(P*)
影響を受ける行数にパディングが比例することを表します。
.TP
(#\d\fIi\fP\u)
第 \fIi\fP 番目のパラメータを表します。

.PP
以下はブール値ケーパビリティです :

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBvariable	cap-	TCap	説明\fR
\fBブール値	name	Code\fR
auto_left_margin	bw	bw	T{
cub1 は桁 0 から最後の桁に回り込む
T}
auto_right_margin	am	am	T{
自動マージン機能を持つ
T}
back_color_erase	bce	ut	T{
画面を背景色で消去する
T}
can_change	ccc	cc	T{
既存の色を再定義可能
T}
ceol_standout_glitch	xhp	xs	T{
強調出力は上書きで消去されない (hp)
T}
col_addr_glitch	xhpa	YA	T{
hpa/mhpa では正方向のみ移動可能
T}
cpi_changes_res	cpix	YF	T{
文字ピッチを変えると解像度が変わる
T}
cr_cancels_micro_mode	crxm	YB	T{
cr を使用するとマイクロモードがオフになる
T}
dest_tabs_magic_smso	xt	xt	T{
タブは破壊的、強調文字の動作が奇妙 (t1061)
T}
eat_newline_glitch	xenl	xn	T{
80 桁より後の改行は無視される (concept)
T}
erase_overstrike	eo	eo	T{
空白の重ね打ちで消去可能
T}
generic_type	gn	gn	T{
一般的な回線タイプ
T}
hard_copy	hc	hc	T{
ハードコピー端末
T}
hard_cursor	chts	HC	T{
カーソルが見にくい
T}
has_meta_key	km	km	T{
メタキーを持つ (押すと第 8 ビットがセットされる)
T}
has_print_wheel	daisy	YC	T{
文字セットを変更するのに人手が必要なプリンタ
T}
has_status_line	hs	hs	T{
特別なステータス行を持つ
T}
hue_lightness_saturation	hls	hl	T{
端末は HLS 色表記のみ使用 (Tektronix)
T}
insert_null_glitch	in	in	T{
挿入モードでヌル文字を区別する
T}
lpi_changes_res	lpix	YG	T{
行ピッチを変えると解像度が変わる
T}
memory_above	da	da	T{
画面より上の描画が保持される
T}
memory_below	db	db	T{
画面より下の描画が保持される
T}
move_insert_mode	mir	mi	T{
挿入モードで安全にカーソル移動可能
T}
move_standout_mode	msgr	ms	T{
強調モードで安全にカーソル移動可能
T}
needs_xon_xoff	nxon	nx	T{
パディング機能が働かない。xon/xoff 制御が必要
T}
no_esc_ctlc	xsb	xb	T{
beehive 端末 (f1=escape, f2=ctrl C)
T}
no_pad_char	npc	NP	T{
パディング文字が存在しない
T}
non_dest_scroll_region	ndscr	ND	T{
スクロール領域が非破壊的
T}
non_rev_rmcup	nrrmc	NR	T{
smcup は rmcup の動作を反転しない
T}
over_strike	os	os	T{
端末は重ね打ち可能
T}
prtr_silent	mc5i	5i	T{
プリンタ出力は画面にエコーしない
T}
row_addr_glitch	xvpa	YD	T{
vpa/mvpa では正方向にのみ移動可能
T}
semi_auto_right_margin	sam	YE	T{
最終桁で出力すると cr 動作をする
T}
status_line_esc_ok	eslok	es	T{
ステータス行上でエスケープ可能
T}
tilde_glitch	hz	hz	T{
~ 表示不可 (hazeltine 端末)
T}
transparent_underline	ul	ul	T{
下線付文字は上書きする
T}
xon_xoff	xon	xo	T{
端末は xon/xoff ハンドシェークを行う
T}
.TE
.ad

以下は数値ケーパビリティです :

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBvariable	cap-	TCap	説明\fR
\fB数値 	name	Code\fR
columns	cols	co	T{
1 行の桁数
T}
init_tabs	it	it	T{
タブの初期設定は # 個の空白毎
T}
label_height	lh	lh	T{
ラベル 1 つの行数
T}
label_width	lw	lw	T{
ラベル 1 つの桁数
T}
lines	lines	li	T{
画面またはページの行数
T}
lines_of_memory	lm	lm	T{
lines の値以上の場合メモリの行数。0 は行数が可変であることを表す
T}
magic_cookie_glitch	xmc	sg	T{
smso や rmso で画面に残る空白数
T}
max_attributes	ma	ma	T{
端末が組み合わせて処理できる属性数の最大値
T}
max_colors	colors	Co	T{
画面上の最大色数
T}
max_pairs	pairs	pa	T{
画面上の色ペアの最大値
T}
maximum_windows	wnum	MW	T{
定義可能なウィンドウ数の最大値
T}
no_color_video	ncv	NC	T{
色付きでは使用できないビデオ属性
T}
num_labels	nlab	Nl	T{
画面上のラベル数
T}
padding_baud_rate	pb	pb	T{
パディングが必要な最低ボーレート
T}
virtual_terminal	vt	vt	T{
仮想画面番号 (CB/unix)
T}
width_status_line	wsl	ws	T{
ステータス行の桁数
T}
.TE
.ad

以下の数値ケーパビリティは、SVr4.0 の term 構造体に存在していますが、
マニュアルには未だに説明がありません。
SVr4 でプリンタに対応するために採り入れられました。

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBvariable	cap-	TCap	説明\fR
\fB数値 	name	Code\fR
bit_image_entwining	bitwin	Yo	T{
各ビットイメージ行に対するパスの数
T}
bit_image_type	bitype	Yp	T{
ビットイメージデバイスのタイプ
T}
buffer_capacity	bufsz	Ya	T{
印字前にバッファリング可能なバイト数
T}
buttons	btns	BT	T{
マウスのボタン数
T}
dot_horz_spacing	spinh	Yc	T{
1 インチあたりのドット数での水平方向のドット間隔
T}
dot_vert_spacing	spinv	Yb	T{
1 インチあたりのピン数での垂直方向のピン間隔
T}
max_micro_address	maddr	Yd	T{
micro_..._address での最大値
T}
max_micro_jump	mjump	Ye	T{
parm_..._micro での最大値
T}
micro_col_size	mcs	Yf	T{
マイクロモードでの文字ステップサイズ
T}
micro_line_size	mls	Yg	T{
マイクロモードでの行ステップサイズ
T}
number_of_pins	npins	Yh	T{
プリントヘッドのピン数
T}
output_res_char	orc	Yi	T{
1 行あたりのユニット数での水平解像度
T}
output_res_horz_inch	orhi	Yk	T{
1 インチあたりのユニット数での水平解像度
T}
output_res_line	orl	Yj	T{
1 行あたりのユニット数での垂直解像度
T}
output_res_vert_inch	orvi	Yl	T{
1 インチあたりのユニット数での垂直解像度
T}
print_rate	cps	Ym	T{
1 秒あたりの文字数での印字速度
T}
wide_char_size	widcs	Yn	T{
倍幅モードでの文字ステップサイズ
T}
.TE
.ad

以下は文字列ケーパビリティです :

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBvariable	cap-	TCap	説明\fR
\fB文字列	name	Code\fR
acs_chars	acsc	ac	T{
図形文字セットの組、vt100 に基づく
T}
back_tab	cbt	bt	T{
後退タブ (P)
T}
bell	bel	bl	T{
可聴シグナル (ベル) (P)
T}
carriage_return	cr	cr	T{
復帰文字 (P*) (P*)
T}
change_char_pitch	cpi	ZA	T{
1 インチあたりの文字数を # 1 に変更
T}
change_line_pitch	lpi	ZB	T{
1 インチあたりの行数を #1 に変更
T}
change_res_horz	chr	ZC	T{
水平解像度を #1 に変更
T}
change_res_vert	cvr	ZD	T{
垂直解像度を #1 に変更
T}
change_scroll_region	csr	cs	T{
領域を行 #1 から行 #2 までに変更 (P)
T}
char_padding	rmp	rP	T{
ip と同様だが挿入モード以外で使用
.\" 後で If padding is necessary between characters typed while not
.\" in  insert  mode,  give  this  as a number of milliseconds
.\" padding in rmp. という記述がある
T}
clear_all_tabs	tbc	ct	T{
タブ設定をすべてクリア (P)
T}
clear_margins	mgc	MC	T{
左右のソフトマージンをクリア
T}
clear_screen	clear	cl	T{
画面をクリアし、カーソルをホームに移動 (P*)
T}
clr_bol	el1	cb	T{
行先頭までクリア
T}
clr_eol	el	ce	T{
行末までクリア (P)
T}
clr_eos	ed	cd	T{
画面末までクリア (P*)
T}
column_address	hpa	ch	T{
水平絶対位置 #1 (P)
T}
command_character	cmdch	CC	T{
端末がプロトタイプで設定可能なコマンド文字 !?
T}
create_window	cwin	CW	T{
ウィンドウ #1 を #2,#3 から #4,#5 までと定義
T}
cursor_address	cup	cm	T{
行 #1 桁 #2 に移動
T}
cursor_down	cud1	do	T{
1 行下に移動
T}
cursor_home	home	ho	T{
カーソルをホームに移動 (cup がない場合)
T}
cursor_invisible	civis	vi	T{
カーソルを見えなくする
T}
cursor_left	cub1	le	T{
カーソルを 1 空白分左に移動
T}
cursor_mem_address	mrcup	CM	T{
メモリ相対のカーソル位置指定であり、行 #1 列 #2 へ移動
T}
cursor_normal	cnorm	ve	T{
カーソルを通常表示にする (civis/cvvis を元に戻す)
T}
cursor_right	cuf1	nd	T{
非破壊空白 (1 空白分右に移動)
T}
cursor_to_ll	ll	ll	T{
最終行の最初の桁 (cup がない場合)
T}
cursor_up	cuu1	up	T{
1 行上へ
T}
cursor_visible	cvvis	vs	T{
カーソルをより見えるようにする
T}
define_char	defc	ZE	T{
文字 #1 を幅 #2 ドット、ディセンダ #3 で定義する
T}
delete_character	dch1	dc	T{
文字を削除 (P*)
T}
delete_line	dl1	dl	T{
行を削除 (P*)
T}
dial_phone	dial	DI	T{
番号 #1 にダイアルする
T}
dis_status_line	dsl	ds	T{
ステータス行を無効にする
T}
display_clock	dclk	DK	T{
時計を表示する
T}
down_half_line	hd	hd	T{
半行下へ
T}
ena_acs	enacs	eA	T{
別の文字セットを有効にする
T}
enter_alt_charset_mode	smacs	as	T{
別の文字セットを開始 (P)
T}
enter_am_mode	smam	SA	T{
自動マージンオン
T}
enter_blink_mode	blink	mb	T{
点滅モードオン
T}
enter_bold_mode	bold	md	T{
太字 (更に明るい) モードオン
T}
enter_ca_mode	smcup	ti	T{
cup を用いたプログラムを開始する文字列
T}
enter_delete_mode	smdc	dm	T{
削除モード開始
T}
enter_dim_mode	dim	mh	T{
半輝度モード開始
T}
enter_doublewide_mode	swidm	ZF	T{
倍幅モード開始
T}
enter_draft_quality	sdrfq	ZG	T{
ドラフト印字モード開始
T}
enter_insert_mode	smir	im	T{
挿入モード開始
T}
enter_italics_mode	sitm	ZH	T{
斜体モード開始
T}
enter_leftward_mode	slm	ZI	T{
左向き移動モード開始
T}
enter_micro_mode	smicm	ZJ	T{
マイクロ移動モード開始
T}
enter_near_letter_quality	snlq	ZK	T{
NLQ 印字モード開始
T}
enter_normal_quality	snrmq	ZL	T{
通常品質印字モード開始
T}
enter_protected_mode	prot	mp	T{
保護モードオン
T}
enter_reverse_mode	rev	mr	T{
反転表示モードオン
T}
enter_secure_mode	invis	mk	T{
ブランクモードオン (文字が見えない)
T}
enter_shadow_mode	sshm	ZM	T{
シャドウプリントモード開始
T}
enter_standout_mode	smso	so	T{
強調モード開始
T}
enter_subscript_mode	ssubm	ZN	T{
下付き文字モード開始
T}
enter_superscript_mode	ssupm	ZO	T{
上付き文字モード開始
T}
enter_underline_mode	smul	us	T{
下線モード開始
T}
enter_upward_mode	sum	ZP	T{
上向き移動モード開始
T}
enter_xon_mode	smxon	SX	T{
xon/xoff ハンドシェークオン
T}
erase_chars	ech	ec	T{
#1 個の文字を消去 (P)
T}
exit_alt_charset_mode	rmacs	ae	T{
別の文字セット終了 (P)
T}
exit_am_mode	rmam	RA	T{
自動マージンオフ
T}
exit_attribute_mode	sgr0	me	T{
全属性オフ
T}
exit_ca_mode	rmcup	te	T{
cup を用いたプログラムを終了する文字列
T}
exit_delete_mode	rmdc	ed	T{
削除モード終了
T}
exit_doublewide_mode	rwidm	ZQ	T{
倍幅モード終了
T}
exit_insert_mode	rmir	ei	T{
挿入モード終了
T}
exit_italics_mode	ritm	ZR	T{
斜体モード終了
T}
exit_leftward_mode	rlm	ZS	T{
左向き移動モード終了
T}
exit_micro_mode	rmicm	ZT	T{
マイクロ移動モード終了
T}
exit_shadow_mode	rshm	ZU	T{
シャドウプリントモード終了
T}
exit_standout_mode	rmso	se	T{
強調モード終了
T}
exit_subscript_mode	rsubm	ZV	T{
下付き文字モード終了
T}
exit_superscript_mode	rsupm	ZW	T{
上付き文字モード終了
T}
exit_underline_mode	rmul	ue	T{
下線モード終了
T}
exit_upward_mode	rum	ZX	T{
 逆向き移動モード終了
T}
exit_xon_mode	rmxon	RX	T{
xon/xoff ハンドシェークオフ
T}
fixed_pause	pause	PA	T{
2-3 秒待つ
T}
flash_hook	hook	fh	T{
スイッチフックをフラッシュ
T}
flash_screen	flash	vb	T{
可視ベル (カーソルは移動しない)
T}
form_feed	ff	ff	T{
ハードコピー端末でのページ排出 (P*)
T}
from_status_line	fsl	fs	T{
ステータス行からの復帰
T}
goto_window	wingo	WG	T{
ウィンドウ #1 に移動
T}
hangup	hup	HU	T{
電話を切る
T}
init_1string	is1	i1	T{
初期化文字列
T}
init_2string	is2	is	T{
初期化文字列
T}
init_3string	is3	i3	T{
初期化文字列
T}
init_file	if	if	T{
初期化ファイルの名前
T}
init_prog	iprog	iP	T{
初期化プログラムのパス名
T}
initialize_color	initc	Ic	T{
色 #1 を (#2,#3,#4) に初期化
T}
initialize_pair	initp	Ip	T{
色ペア #1 を fg=(#2,#3,#4), bg=(#5,#6,#7) に初期化
T}
insert_character	ich1	ic	T{
文字の挿入 (P)
T}
insert_line	il1	al	T{
行の挿入 (P*)
T}
insert_padding	ip	ip	T{
文字挿入の後にパディングを挿入
T}
key_a1	ka1	K1	T{
キーパッドの左上キー
T}
key_a3	ka3	K3	T{
キーパッドの右上キー
T}
key_b2	kb2	K2	T{
キーパッドの中央キー
T}
key_backspace	kbs	kb	T{
backspace キー
T}
key_beg	kbeg	@1	T{
begin キー
T}
key_btab	kcbt	kB	T{
back-tab キー
T}
key_c1	kc1	K4	T{
キーパッドの左下キー
T}
key_c3	kc3	K5	T{
キーパッドの右下キー
T}
key_cancel	kcan	@2	T{
cancel キー
T}
key_catab	ktbc	ka	T{
clear-all-tabs キー
T}
key_clear	kclr	kC	T{
clear-screen キー、または erase キー
T}
key_close	kclo	@3	T{
close キー
T}
key_command	kcmd	@4	T{
command キー
T}
key_copy	kcpy	@5	T{
copy キー
T}
key_create	kcrt	@6	T{
create キー
T}
key_ctab	kctab	kt	T{
clear-tab キー
T}
key_dc	kdch1	kD	T{
delete-character キー
T}
key_dl	kdl1	kL	T{
delete-line キー
T}
key_down	kcud1	kd	T{
down-arrow キー
T}
key_eic	krmir	kM	T{
挿入モードで rmir や smir が送出するデータ
T}
key_end	kend	@7	T{
end キー
T}
key_enter	kent	@8	T{
enter/send キー
T}
key_eol	kel	kE	T{
clear-to-end-of-line キー
T}
key_eos	ked	kS	T{
clear-to-end-of-screen キー
T}
key_exit	kext	@9	T{
exit キー
T}
key_f0	kf0	k0	T{
F0  ファンクションキー
T}
key_f1	kf1	k1	T{
F1  ファンクションキー
T}
key_f10	kf10	k;	T{
F10 ファンクションキー
T}
key_f11	kf11	F1	T{
F11 ファンクションキー
T}
key_f12	kf12	F2	T{
F12 ファンクションキー
T}
key_f13	kf13	F3	T{
F13 ファンクションキー
T}
key_f14	kf14	F4	T{
F14 ファンクションキー
T}
key_f15	kf15	F5	T{
F15 ファンクションキー
T}
key_f16	kf16	F6	T{
F16 ファンクションキー
T}
key_f17	kf17	F7	T{
F17 ファンクションキー
T}
key_f18	kf18	F8	T{
F18 ファンクションキー
T}
key_f19	kf19	F9	T{
F19 ファンクションキー
T}
key_f2	kf2	k2	T{
F2  ファンクションキー
T}
key_f20	kf20	FA	T{
F20 ファンクションキー
T}
key_f21	kf21	FB	T{
F21 ファンクションキー
T}
key_f22	kf22	FC	T{
F22 ファンクションキー
T}
key_f23	kf23	FD	T{
F23 ファンクションキー
T}
key_f24	kf24	FE	T{
F24 ファンクションキー
T}
key_f25	kf25	FF	T{
F25 ファンクションキー
T}
key_f26	kf26	FG	T{
F26 ファンクションキー
T}
key_f27	kf27	FH	T{
F27 ファンクションキー
T}
key_f28	kf28	FI	T{
F28 ファンクションキー
T}
key_f29	kf29	FJ	T{
F29 ファンクションキー
T}
key_f3	kf3	k3	T{
F3  ファンクションキー
T}
key_f30	kf30	FK	T{
F30 ファンクションキー
T}
key_f31	kf31	FL	T{
F31 ファンクションキー
T}
key_f32	kf32	FM	T{
F32 ファンクションキー
T}
key_f33	kf33	FN	T{
F33 ファンクションキー
T}
key_f34	kf34	FO	T{
F34 ファンクションキー
T}
key_f35	kf35	FP	T{
F35 ファンクションキー
T}
key_f36	kf36	FQ	T{
F36 ファンクションキー
T}
key_f37	kf37	FR	T{
F37 ファンクションキー
T}
key_f38	kf38	FS	T{
F38 ファンクションキー
T}
key_f39	kf39	FT	T{
F39 ファンクションキー
T}
key_f4	kf4	k4	T{
F4  ファンクションキー
T}
key_f40	kf40	FU	T{
F40 ファンクションキー
T}
key_f41	kf41	FV	T{
F41 ファンクションキー
T}
key_f42	kf42	FW	T{
F42 ファンクションキー
T}
key_f43	kf43	FX	T{
F43 ファンクションキー
T}
key_f44	kf44	FY	T{
F44 ファンクションキー
T}
key_f45	kf45	FZ	T{
F45 ファンクションキー
T}
key_f46	kf46	Fa	T{
F46 ファンクションキー
T}
key_f47	kf47	Fb	T{
F47 ファンクションキー
T}
key_f48	kf48	Fc	T{
F48 ファンクションキー
T}
key_f49	kf49	Fd	T{
F49 ファンクションキー
T}
key_f5	kf5	k5	T{
F5  ファンクションキー
T}
key_f50	kf50	Fe	T{
F50 ファンクションキー
T}
key_f51	kf51	Ff	T{
F51 ファンクションキー
T}
key_f52	kf52	Fg	T{
F52 ファンクションキー
T}
key_f53	kf53	Fh	T{
F53 ファンクションキー
T}
key_f54	kf54	Fi	T{
F54 ファンクションキー
T}
key_f55	kf55	Fj	T{
F55 ファンクションキー
T}
key_f56	kf56	Fk	T{
F56 ファンクションキー
T}
key_f57	kf57	Fl	T{
F57 ファンクションキー
T}
key_f58	kf58	Fm	T{
F58 ファンクションキー
T}
key_f59	kf59	Fn	T{
F59 ファンクションキー
T}
key_f6	kf6	k6	T{
F6  ファンクションキー
T}
key_f60	kf60	Fo	T{
F60 ファンクションキー
T}
key_f61	kf61	Fp	T{
F61 ファンクションキー
T}
key_f62	kf62	Fq	T{
F62 ファンクションキー
T}
key_f63	kf63	Fr	T{
F63 ファンクションキー
T}
key_f7	kf7	k7	T{
F7  ファンクションキー
T}
key_f8	kf8	k8	T{
F8  ファンクションキー
T}
key_f9	kf9	k9	T{
F9  ファンクションキー
T}
key_find	kfnd	@0	T{
find キー
T}
key_help	khlp	%1	T{
help キー
T}
key_home	khome	kh	T{
home キー
T}
key_ic	kich1	kI	T{
insert-character キー
T}
key_il	kil1	kA	T{
insert-line キー
T}
key_left	kcub1	kl	T{
left-arrow キー
T}
key_ll	kll	kH	T{
lower-left キー (home down)
T}
key_mark	kmrk	%2	T{
mark キー
T}
key_message	kmsg	%3	T{
message キー
T}
key_move	kmov	%4	T{
move キー
T}
key_next	knxt	%5	T{
next キー
T}
key_npage	knp	kN	T{
next-page キー
T}
key_open	kopn	%6	T{
open キー
T}
key_options	kopt	%7	T{
options キー
T}
key_ppage	kpp	kP	T{
previous-page キー
T}
key_previous	kprv	%8	T{
previous キー
T}
key_print	kprt	%9	T{
print キー
T}
key_redo	krdo	%0	T{
redo キー
T}
key_reference	kref	&1	T{
reference キー
T}
key_refresh	krfr	&2	T{
refresh キー
T}
key_replace	krpl	&3	T{
replace キー
T}
key_restart	krst	&4	T{
restart キー
T}
key_resume	kres	&5	T{
resume キー
T}
key_right	kcuf1	kr	T{
right-arrow キー
T}
key_save	ksav	&6	T{
save キー
T}
key_sbeg	kBEG	&9	T{
シフト状態の begin キー
T}
key_scancel	kCAN	&0	T{
シフト状態の cancel キー
T}
key_scommand	kCMD	*1	T{
シフト状態の command キー
T}
key_scopy	kCPY	*2	T{
シフト状態の copy キー
T}
key_screate	kCRT	*3	T{
シフト状態の create キー
T}
key_sdc	kDC	*4	T{
シフト状態の delete-character キー
T}
key_sdl	kDL	*5	T{
シフト状態の delete-line キー
T}
key_select	kslt	*6	T{
select キー
T}
key_send	kEND	*7	T{
シフト状態の end キー
T}
key_seol	kEOL	*8	T{
シフト状態の clear-to-end-of-line キー
T}
key_sexit	kEXT	*9	T{
シフト状態の exit キー
T}
key_sf	kind	kF	T{
scroll-forward キー
T}
key_sfind	kFND	*0	T{
シフト状態の find キー
T}
key_shelp	kHLP	#1	T{
シフト状態の help キー
T}
key_shome	kHOM	#2	T{
シフト状態の home キー
T}
key_sic	kIC	#3	T{
シフト状態の insert-character キー
T}
key_sleft	kLFT	#4	T{
シフト状態の left-arrow キー
T}
key_smessage	kMSG	%a	T{
シフト状態の message キー
T}
key_smove	kMOV	%b	T{
シフト状態の move キー
T}
key_snext	kNXT	%c	T{
シフト状態の next キー
T}
key_soptions	kOPT	%d	T{
シフト状態の options キー
T}
key_sprevious	kPRV	%e	T{
シフト状態の previous キー
T}
key_sprint	kPRT	%f	T{
シフト状態の print キー
T}
key_sr	kri	kR	T{
scroll-backward キー
T}
key_sredo	kRDO	%g	T{
シフト状態の redo キー
T}
key_sreplace	kRPL	%h	T{
シフト状態の replace キー
T}
key_sright	kRIT	%i	T{
シフト状態の right-arrow キー
T}
key_srsume	kRES	%j	T{
シフト状態の resume キー
T}
key_ssave	kSAV	!1	T{
シフト状態の save キー
T}
key_ssuspend	kSPD	!2	T{
シフト状態の suspend キー
T}
key_stab	khts	kT	T{
set-tab キー
T}
key_sundo	kUND	!3	T{
シフト状態の undo キー
T}
key_suspend	kspd	&7	T{
suspend キー
T}
key_undo	kund	&8	T{
undo キー
T}
key_up	kcuu1	ku	T{
up-arrow キー
T}
keypad_local	rmkx	ke	T{
\&'keyboard_transmit' モードから抜ける
T}
keypad_xmit	smkx	ks	T{
\&'keyboard_transmit' モードに入る
T}
lab_f0	lf0	l0	T{
f0 でない場合、ファンクションキー f0 のラベル
T}
lab_f1	lf1	l1	T{
f1 でない場合、ファンクションキー f1 のラベル
T}
lab_f10	lf10	la	T{
f10 でない場合、ファンクションキー f10 のラベル
T}
lab_f2	lf2	l2	T{
f2 でない場合、ファンクションキー f2 のラベル
T}
lab_f3	lf3	l3	T{
f3 でない場合、ファンクションキー f3 のラベル
T}
lab_f4	lf4	l4	T{
f4 でない場合、ファンクションキー f4 のラベル
T}
lab_f5	lf5	l5	T{
f5 でない場合、ファンクションキー f5 のラベル
T}
lab_f6	lf6	l6	T{
f6 でない場合、ファンクションキー f6 のラベル
T}
lab_f7	lf7	l7	T{
f7 でない場合、ファンクションキー f7 のラベル
T}
lab_f8	lf8	l8	T{
f8 でない場合、ファンクションキー f8 のラベル
T}
lab_f9	lf9	l9	T{
f9 でない場合、ファンクションキー f9 のラベル
T}
label_format	fln	Lf	T{
ラベルフォーマット
T}
label_off	rmln	LF	T{
ソフトラベルオフ
T}
label_on	smln	LO	T{
ソフトラベルオン
T}
meta_off	rmm	mo	T{
メタモードオフ
T}
meta_on	smm	mm	T{
メタモードオン (8 番目のビットオン)
T}
micro_column_address	mhpa	ZY	T{
マイクロモードの column_address
T}
micro_down	mcud1	ZZ	T{
マイクロモードの cursor_down
T}
micro_left	mcub1	Za	T{
マイクロモードの cursor_left
T}
micro_right	mcuf1	Zb	T{
マイクロモードの cursor_right
T}
micro_row_address	mvpa	Zc	T{
マイクロモードの row_address #1
T}
micro_up	mcuu1	Zd	T{
マイクロモードの cursor_up
T}
newline	nel	nw	T{
改行 (cr の後に lf が来る)
T}
order_of_pins	porder	Ze	T{
ソフトウェアビットを印字ヘッドピンに一致させる
T}
orig_colors	oc	oc	T{
すべての色ペアを本来のものにする
T}
orig_pair	op	op	T{
デフォルトのペアを本来の値にする
T}
pad_char	pad	pc	T{
パディング文字 (ヌル以外)
T}
parm_dch	dch	DC	T{
#1 文字を削除 (P*)
T}
parm_delete_line	dl	DL	T{
#1 行を削除 (P*)
T}
parm_down_cursor	cud	DO	T{
#1 行下へ (P*)
T}
parm_down_micro	mcud	Zf	T{
マイクロモードの parm_down_cursor
T}
parm_ich	ich	IC	T{
#1 文字を挿入 (P*)
T}
parm_index	indn	SF	T{
#1 行の前進スクロール (P)
T}
parm_insert_line	il	AL	T{
#1 行を挿入 (P*)
T}
parm_left_cursor	cub	LE	T{
左へ #1 文字分移動 (P)
T}
parm_left_micro	mcub	Zg	T{
マイクロモードの parm_left_cursor
T}
parm_right_cursor	cuf	RI	T{
右へ #1 文字分移動 (P*)
T}
parm_right_micro	mcuf	Zh	T{
マイクロモードの parm_right_cursor
T}
parm_rindex	rin	SR	T{
#1 行の後退スクロール (P)
T}
parm_up_cursor	cuu	UP	T{
#1 行上へ (P*)
T}
parm_up_micro	mcuu	Zi	T{
マイクロモードの parm_up_cursor
T}
pkey_key	pfkey	pk	T{
ファンクションキー #1 の打鍵文字列を #2 にする
T}
pkey_local	pfloc	pl	T{
ファンクションキー #1 の実行文字列を #2 にする
T}
pkey_xmit	pfx	px	T{
ファンクションキー #1 の送信文字列を #2 にする
T}
plab_norm	pln	pn	T{
ラベル #1 に文字列 #2 を表示
T}
print_screen	mc0	ps	T{
画面の内容を印字する
T}
prtr_non	mc5p	pO	T{
#1 バイトだけプリンタをオンにする
T}
prtr_off	mc4	pf	T{
プリンタをオフにする
T}
prtr_on	mc5	po	T{
プリンタをオンにする
T}
pulse	pulse	PU	T{
パルスダイアルを選択
T}
quick_dial	qdial	QD	T{
確認なしで電話番号 #1 にダイアルする
T}
remove_clock	rmclk	RC	T{
時計を削除
T}
repeat_char	rep	rp	T{
文字 #1 を #2 回繰り返す (P*)
T}
req_for_input	rfi	RF	T{
(pty 用に) 次の入力文字を送る
T}
reset_1string	rs1	r1	T{
リセット文字列
T}
reset_2string	rs2	r2	T{
リセット文字列
T}
reset_3string	rs3	r3	T{
リセット文字列
T}
reset_file	rf	rf	T{
リセットファイルの名前
T}
restore_cursor	rc	rc	T{
最後の save_cursor の位置にカーソルを戻す
T}
row_address	vpa	cv	T{
垂直絶対位置 #1 (P)
T}
save_cursor	sc	sc	T{
現在のカーソル位置を保存 (P)
T}
scroll_forward	ind	sf	T{
テキストを上にスクロール (P)
T}
scroll_reverse	ri	sr	T{
テキストを下にスクロール (P)
T}
select_char_set	scs	Zj	T{
文字セット #1 の選択
T}
set_attributes	sgr	sa	T{
ビデオ属性を #1-#9 に定義 (PG9)
T}
set_background	setb	Sb	T{
背景色を #1 に設定
T}
set_bottom_margin	smgb	Zk	T{
下マージンを現在行に設定
T}
set_bottom_margin_parm	smgbp	Zl	T{
下マージンを #1 行目か (smgtp が与えられていなければ) 下から #2 行目にする
.\" Set bottom margin at line #1 or (if smgtp is not given) #2 lines from bottom
T}
set_clock	sclk	SC	T{
時計を #1 時 #2 分 #3 秒に設定
T}
set_color_pair	scp	sp	T{
現在の色ペアを #1 に設定
T}
set_foreground	setf	Sf	T{
前景色を #1 に設定
T}
set_left_margin	smgl	ML	T{
左ソフトマージンを現在桁に設定  smgl を参照 (ML は BSD の termcap とは違います)
T}
set_left_margin_parm	smglp	Zm	T{
左 (右) マージンを桁 #1 に設定
T}
set_right_margin	smgr	MR	T{
右ソフトマージンを現在桁に設定
T}
set_right_margin_parm	smgrp	Zn	T{
右マージンを桁 #1 に設定
T}
set_tab	hts	st	T{
全行のタブを現在の桁に設定
T}
set_top_margin	smgt	Zo	T{
上マージンを現在行に設定
T}
set_top_margin_parm	smgtp	Zp	T{
上 (下) マージンを行 #1 に設定
T}
set_window	wind	wi	T{
現在のウィンドウを行 #1-#2、桁 #3-#4 とする
T}
start_bit_image	sbim	Zq	T{
ビットイメージグラフィック印字の開始
T}
start_char_set_def	scsd	Zr	T{
#2 個の文字からなる文字セット #1 の定義の開始
T}
stop_bit_image	rbim	Zs	T{
ビットイメージグラフィック印字の終了
T}
stop_char_set_def	rcsd	Zt	T{
文字セット #1 の定義の終了
T}
subscript_characters	subcs	Zu	T{
下付き文字となりうる文字のリスト
T}
superscript_characters	supcs	Zv	T{
上付き文字となりうる文字のリスト
T}
tab	ht	ta	T{
次の 8 文字分のハードウェアタブストップへのタブ文字
T}
these_cause_cr	docr	Zw	T{
これらの文字のうちのいずれかの印字は CR を引き起こす
T}
to_status_line	tsl	ts	T{
ステータス行の列 #1 に移動
T}
tone	tone	TO	T{
タッチトーンダイアルを選択
T}
underline_char	uc	uc	T{
文字 1 つに下線を付け、次の文字に移動
T}
up_half_line	hu	hu	T{
半行上へ
T}
user0	u0	u0	T{
ユーザ文字列 #0
T}
user1	u1	u1	T{
ユーザ文字列 #1
T}
user2	u2	u2	T{
ユーザ文字列 #2
T}
user3	u3	u3	T{
ユーザ文字列 #3
T}
user4	u4	u4	T{
ユーザ文字列 #4
T}
user5	u5	u5	T{
ユーザ文字列 #5
T}
user6	u6	u6	T{
ユーザ文字列 #6
T}
user7	u7	u7	T{
ユーザ文字列 #7
T}
user8	u8	u8	T{
ユーザ文字列 #8
T}
user9	u9	u9	T{
ユーザ文字列 #9
T}
wait_tone	wait	WA	T{
ダイアルトーンを待つ
T}
xoff_character	xoffc	XF	T{
XOFF 文字
T}
xon_character	xonc	XN	T{
XON 文字
T}
zero_motion	zerom	Zx	T{
次の文字表示を移動無しで行う
T}
.TE
.ad

以下の文字列ケーパビリティは、SVr4.0 の term 構造体に存在していますが、
マニュアルで未だに説明がなされていません。

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw18.
\fBvariable	cap-	TCap	説明\fR
\fB文字列	name	Code\fR
alt_scancode_esc	scesa	S8	T{
スキャンコードエミュレーションのための別のエスケープ文字
T}
bit_image_carriage_return	bicr	Yv	T{
同一行の先頭へ移動
T}
bit_image_newline	binel	Zz	T{
ビットイメージの次の行に移動
T}
bit_image_repeat	birep	Xy	T{
ビットイメージセル #1 を #2 回繰り返す
T}
char_set_names	csnm	Zy	T{
文字セットの名のリストから #1 番目の item を生成する
T}
.\" 2002/12/24 oh:item の意味不明 : Produce #1'th item from list of character set names
code_set_init	csin	ci	T{
複数コードセットの初期化シーケンス
T}
color_names	colornm	Yw	T{
色 #1 に名前を与える
T}
define_bit_image_region	defbi	Yx	T{
矩形のビットイメージ領域を定義
T}
device_type	devt	dv	T{
言語/コードセットサポートの指定
T}
display_pc_char	dispc	S1	T{
PC 文字 #1 を表示
T}
end_bit_image_region	endbi	Yy	T{
ビットイメージ領域の終了
T}
enter_pc_charset_mode	smpch	S2	T{
PC 文字表示モード開始
T}
enter_scancode_mode	smsc	S4	T{
PC スキャンコードモード開始
T}
exit_pc_charset_mode	rmpch	S3	T{
PC 文字表示モード終了
T}
exit_scancode_mode	rmsc	S5	T{
PC スキャンコードモード終了
T}
get_mouse	getm	Gm	T{
curses がボタンイベントを取得すべき。パラメータ #1 は文書化されていない
T}
key_mouse	kmous	Km	T{
マウスイベントが起きた
T}
mouse_info	minfo	Mi	T{
マウス状態の情報
T}
pc_term_options	pctrm	S6	T{
PC 端末オプション
T}
pkey_plab	pfxl	xl	T{
ファンクションキー #1 に文字列 #2 を送信させ文字列 #3 を表示させる
T}
req_mouse_pos	reqmp	RQ	T{
マウス位置の要求
T}
scancode_escape	scesc	S7	T{
スキャンコードエミュレーションのためのエスケープ
T}
set0_des_seq	s0ds	s0	T{
コードセット 0 にシフト (EUC セット 0、ASCII)
T}
set1_des_seq	s1ds	s1	T{
コードセット 1 にシフト
T}
set2_des_seq	s2ds	s2	T{
コードセット 2 にシフト
T}
set3_des_seq	s3ds	s3	T{
コードセット 3 にシフト
T}
set_a_background	setab	AB	T{
ANSI エスケープシーケンスを使って背景色を #1 に設定
T}
set_a_foreground	setaf	AF	T{
ANSI エスケープシーケンスを使って前景色を #1 に設定
T}
set_color_band	setcolor	Yz	T{
リボンの色を #1 に変更
T}
set_lr_margin	smglr	ML	T{
左右両マージンを #1、#2 に設定、(ML は BSD の termcap のものと違います)
T}
set_page_length	slines	YZ	T{
ページ長を #1 行に設定
T}
set_tb_margin	smgtb	MT	T{
上下両マージンを #1、#2 に設定
T}
.TE
.ad

.in .8i
XSI Curses 規格では以下のものが追加されています。 それらは、例えば、
Solaris 2.5 や IRIX 6.x など、4.1 以降のバージョンの System V の、
curses のものです。
それらの \fBncurses\fR termcap 名はでっちあげました。XSI Curses 規格に従うと、
termcap 名はありません。コンパイルされた terminfo エントリがこれらを
使っていれば、SVr4.1 以降の System V terminfo エントリとは
バイナリ互換ではないかも知れません。用心してください!

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBvariable	cap-	TCap	説明\fR
\fB文字列	name	Code\fR
enter_horizontal_hl_mode	ehhlm	Xh	T{
水平ハイライトモードに入る
T}
enter_left_hl_mode	elhlm	Xl	T{
左ハイライトモードに入る
T}
enter_low_hl_mode	elohlm	Xo	T{
下ハイライトモードに入る
T}
enter_right_hl_mode	erhlm	Xr	T{
右ハイライトモードに入る
T}
enter_top_hl_mode	ethlm	Xt	T{
上ハイライトモードに入る
T}
enter_vertical_hl_mode	evhlm	Xv	T{
垂直ハイライトモードに入る
T}
set_a_attributes	sgr1	sA	T{
ビデオ属性の 2 番目の組を #1-#6 と定義
T}
set_pglen_inch  	slength	sL	T{
ページ長を 100分の #1 インチに設定
T}
.TE
.ad
.\" $Id: terminfo.5,v 1.10 2004-02-19 14:49:59 horikawa Exp $
.\" Beginning of terminfo.tail file
.ps +1
.PP
.SS エントリの例
.PP
以下のエントリは、ANSI 規格端末を記述したものですが、現代的な端末の
\fBterminfo\fR エントリが典型的にはどのようであるかを表しています。
.PP
.nf
.in -2
.ta .3i
.ft CW
\s-2ansi|ansi/pc-term compatible with color,
        mc5i,
        colors#8, ncv#3, pairs#64,
        cub=\\E[%p1%dD, cud=\\E[%p1%dB, cuf=\\E[%p1%dC,
        cuu=\\E[%p1%dA, dch=\\E[%p1%dP, dl=\\E[%p1%dM,
        ech=\\E[%p1%dX, el1=\\E[1K, hpa=\\E[%p1%dG, ht=\\E[I,
        ich=\\E[%p1%d@, il=\\E[%p1%dL, indn=\\E[%p1%dS, .indn=\\E[%p1%dT,
        kbs=^H, kcbt=\\E[Z, kcub1=\\E[D, kcud1=\\E[B,
        kcuf1=\\E[C, kcuu1=\\E[A, kf1=\\E[M, kf10=\\E[V,
        kf11=\\E[W, kf12=\\E[X, kf2=\\E[N, kf3=\\E[O, kf4=\\E[P,
        kf5=\\E[Q, kf6=\\E[R, kf7=\\E[S, kf8=\\E[T, kf9=\\E[U,
        kich1=\\E[L, mc4=\\E[4i, mc5=\\E[5i, nel=\\r\\E[S,
        op=\\E[37;40m, rep=%p1%c\\E[%p2%{1}%-%db,
        rin=\\E[%p1%dT, s0ds=\\E(B, s1ds=\\E)B, s2ds=\\E*B,
        s3ds=\\E+B, setab=\\E[4%p1%dm, setaf=\\E[3%p1%dm,
        setb=\\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        setf=\\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        sgr=\\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p6%t;1%;%?%p7%t;8%;%?%p8%t;11%;%?%p9%t;12%;m,
        sgr0=\\E[0;10m, tbc=\\E[2g, u6=\\E[%d;%dR, u7=\\E[6n,
        u8=\\E[?%[;0123456789]c, u9=\\E[c, vpa=\\E[%p1%dd,\s+2
.in +2
.fi
.ft R
.PP
2 行目以後の行先頭に空白類文字を置くことで、
エントリを複数行に分けて継続して書くことができます。
行先頭に ``#'' を置くことでコメントを含めることができます。
.I terminfo
のケーパビリティには、3 つの型があります。
ブール値ケーパビリティは、その端末がある特性を有しているかどうかを表します。
数値ケーパビリティは、その端末の大きさや、遅延の大きさを指定します。
文字列ケーパビリティは、端末のある機能を実行させる際に用いるシーケンスを
指定します。
.PP
.SS ケーパビリティの型
.PP
すべてのケーパビリティには名前があります。例えば、ANSI 標準端末が
.I "自動マージン"
(つまり、行の端に到達すれば自動的に復帰改行がなされること) を有することは
ケーパビリティ \fBam\fR で表されます。
よって ansi の記述は \fBam\fR を含みます。
数値ケーパビリティの後には文字 `#' が続き、そして正の値が続きます。
\fBcols\fR は、その端末の桁数を表しており、ansi では、
この値は `80' であることを示します。
数値ケーパビリティの値は、プログラミング言語 C の規約を使って 10 進数、
8 進数、16 進数で与えることができます (例えば、255、0377、0xff、0xFF)。
.PP
最後に、文字列ケーパビリティは、\fBel\fR (行末まで消去するシーケンス) などの
ように、2 文字のコードと、`=' と、その先の `,' までの間の文字列とで
表されます。
.PP
文字列ケーパビリティの中で、文字のエンコードを簡単にするために、
いくつかのエスケープシーケンスが利用できます。
\fB\eE\fR と \fB\ee\fR はともに、\s-1ESCAPE\s0 文字にマップされます。
\fB^x\fR は任意の適切な x に関して control-x にマップされます。
\fB\en \el \er \et \eb \ef \es\fR はそれぞれ、改行、ラインフィード、復帰、
タブ、バックスペース、フォームフィード、空白にマップされます。
その他に、\fB\e^\fR は \fB^\fR に、
\fB\e\e\fR は \fB\e\fR に、
\fB\e\fR, はコンマに、
\fB\e:\fR は \fB:\fR に、
\fB\e0\fR はヌル文字にマップされます。
(\fB\e0\fR は \e200 を生成します。これは文字列を終端しませんが、
ほとんどの端末では CS7 が指定されているので、ヌル文字と同様の挙動を
示すからです。stty(1) を参照してください)
最後に、\fB\e\fR の後に 8 進 3 桁の数を指定して文字を表すこともできます。
.PP
ミリ秒単位の遅延は、\fBel\fP=\eEK$<5> のように、文字列ケーパビリティの
どの場所でも $<..> のブラケットで囲んで置くことができます。
この遅延を与えるためのパディングは、関数
.I tputs
が行います。遅延は 1/10 の精度の数である必要があります。接尾辞 `*'、'/'
またはその両方がついているかもしれません。`*' はパディングをその処理で
影響を受ける行の行数に比例させる必要があること、そしてその総計は
影響を受ける 1 単位あたりの必要パディングにより決まることを表します。
(文字挿入の場合、乗数は影響を受ける
.IR 行
の数です) 通常、デバイスに \fBxon\fR ケーパビリティがあれば、パディングは
勧告的なものです。コスト計算には使われますが遅延を引き起こしません。
`/' 接尾辞はパディングが必須のものであることを示し、フロー制御を示す
\fBxon\fR があるデバイスに対しても指定されたミリ秒単位の遅延を強制します。
.PP
あるケーパビリティをコメントアウトせねばならない場合があります。
そういう場合は、ケーパビリティ名の前にピリオドを置いてください。
上の例の 2 番目の
.B ind
がその例です。
.br
.ne 5
.PP
.SS コンパイルされた記述の読み込み
.PP
環境変数 TERMINFO が設定されていれば、それは作業中の記述を
コンパイルしたものを含むディレクトリのパス名と解釈されます。
そのディレクトリだけを探します。
.PP
TERMINFO が設定されていなければ、\fBncurses\fR 版の terminfo 読み込みコードは
その代わりにディレクトリ \fB$HOME/.terminfo\fR からコンパイルされた記述を
探します。
そこで見つけるのに失敗し、環境変数 TERMINFO_DIRS が設定されていれば、
変数の内容をコロンで区切られた探すべきディレクトリのリストと解釈します
(空のエントリは \fI\*d\fR を探すコマンドとして解釈されます)。
TERMINFO_DIRS ディレクトリのいずれにも記述が見つからなければ、読み込みは
失敗します。
.PP
TERMINFO も TERMINFO_DIRS も設定されていなければ、最後に試みられる場所は
システムの terminfo ディレクトリ \fI\*d\fR です。
.PP
(\fB$HOME/.terminfo\fR 探索も TERMINFO_DIRS 拡張も
標準の System V terminfo/curses ではサポートされていません。)
.PP
.SS 端末記述の準備
.PP
ここでは、どのようにして端末の記述を準備するかの概略を説明します。
もっとも効率的なやり方は、
.I terminfo
の中にある類似の端末の記述をまねて作成することです。
.I vi
などのスクリーンエディタに書き掛けの記述を使わせてみて、その記述が
正しいかどうかをチェックしながら、記述を徐々に作り上げてゆくことです。
通常のものとあまりにもかけ離れた端末の場合、
.I terminfo
ファイルの記述能力の欠陥、もしくはテストプログラムの画面操作のコードの
バグが明らかになるかも知れないので、それには注意してください。
.PP
(端末メーカが文書に書いてくれていない場合に) 行の右挿入の際のパディングを
得るには、大きなファイルを 9600 ボーで編集し、画面の中ほどで 16 行程度を
削除してから、 `u' キーを数度すばやく連打するという厳しいテストを行
うとよいでしょう。
端末がぐちゃぐちゃになるのなら、普通は、もう少しパディングが必要だと
いうことです。文字挿入についても似たようなテストを行うことができます。
.PP
.SS 基本的なケーパビリティ
.PP
端末の各行の桁数は数値型ケーパビリティ \fBcols\fR で指定します。
端末が \s-1CRT\s0 の場合、画面の行数はケーパビリティ \fBlines\fR で
指定します。
カーソルが右マージンに達したときに次の行の左端に回り込む場合、
ケーパビリティ \fBam\fR を指定する必要があります。
端末が、画面消去後カーソルをホームポジションにもってゆくことができる場合、
その機能は文字列ケーパビリティ \fBclear\fR で指定します。
端末が (ある文字を上に出力した時にその場所を消去するのではなく)
重ね打ちする場合、ケーパビリティ \fBos\fR を指定する必要があります。
印字端末で、ソフトコピー装置を持たない場合、
.B hc
と
.BR os
とを指定します。
.RB ( os
は、ハードコピー端末や、APL 端末だけでなく、\s-1TEKTRONIX\s+1 4010
シリーズのようなストレージスコープ管端末にも適用されます。)
現在の行の左端にカーソルを移動させるコードが存在する場合、それを
.BR cr
で指定します。
(通常、これは復帰文字、つまり control M になります。)
可聴シグナル (ベル、ビープ音など) を生成するコードがある場合、それを
.BR bel
で指定します。
.PP
カーソルを (バックスペースのように) 1 ポジションだけ左へ移動させる
コードがある場合、それは
.BR cub1
で指定します。
同様に、右への移動、上への移動、下への移動はそれぞれ、
.BR cuf1 ,
.BR cuu1 ,
.BR cud1
で指定します。
これらの局所的カーソル移動機能は、通過する場所のテキストを変更するもので
あってはなりません。たとえば、空白文字はその下のテキストを消去してしまう
ため、普通は `\fBcuf1\fP=\ ' とは指定しません。
.PP
ここで極めて重要なこととして、
.I terminfo
にエンコードされた局所的カーソル移動は、\s-1CRT\s0 端末の左端および
上端では定義されないということです。
プログラムは、
.B bw
の指定がない限り、左端でバックスペースを出力しようとしてはいけません。
また、画面上端で、上に移動しようとしてはいけません。
テキストを上にスクロールするためには、プログラムは画面左下隅にカーソルを
移動させて、
.B ind
(index) 文字列を送出してください。
.PP
テキストを下にスクロールするには、プログラムは画面左上隅にカーソルを
移動させて、
.B ri
(reverse index) 文字列を送出してください。
文字列
.B ind
と
.B ri
の挙動は、それぞれ先に述べた画面隅にカーソルがない場合には
定義されていません。
.PP
スクロールシーケンスのパラメータ付きバージョンは、
.B indn
と
.B rin
で、これらは、スクロールする行数を指定するパラメータを 1 つ取ることを除いては
.B ind
や
.B ri
と、同じ挙動を示します。
これらも、カーソルが適切な画面端に存在しない場合の挙動は定義されません。
.PP
ケーパビリティ \fBam\fR は、右端でテキストが出力されてもカーソルが
右端に留まり続けるかどうかを示します。ただし、この挙動は最終桁での
.B cuf1
の挙動には必ずしも適用されません。
左端からの局所的移動で定義されたものは、
.B bw
が指定されている場合に、左端からの
.B cub1
が 1 つ前の行の右端に移動するということだけです。
.B bw
が指定されていない場合、この効果は定義されません。
これは、例えば、画面の端に沿って箱を描くときに便利なものです。
端末が自動マージン機能を切り替え可能な場合、
.I terminfo
ファイルでは、通常はその機能はオン状態、つまり \fBam\fR であると想定します。
端末が次の行の先頭桁に移動するコマンドを持つ場合、そのコマンドを
.B nel
(newline) で指定することができます。
このコマンドが、現在行の残りの部分を消去するかどうかは関係ありません。
ですから、端末が、
.B cr
や
.B lf
を持たない場合でも、動作する
.B nel
を作ることは可能でしょう。
.PP
これまで紹介したケーパビリティで、ハードコピー端末や、\*(lqガラスの tty\*(rq
端末を記述するには十分です。
ここで、model 33 teletype は、
.PP
.DT
.nf
.ft CW
.in -7
	\s-133\||\|tty33\||\|tty\||\|model 33 teletype,
	bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,\s+1
.in +7
.ft R
.PP
と記述されます。一方、Lear Siegler 社の \s-1ADM\-3\s0 は、
.PP
.DT
.nf
.ft CW
.in -7
	\s-1adm3\||\|3\||\|lsi adm3,
	am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
	ind=^J, lines#24,\s+1
.in +7
.ft R
.fi
.PP
と記述されます。
.PP
.SS パラメータ化された文字列
.PP
カーソル位置設定など、パラメータを必要とする文字列は、
.IR printf (3S)
風のエスケープ \fB%x\fR を含むパラメータ化文字列ケーパビリティを用いて
記述します。
例えば、カーソル位置を指定する
.B cup
ケーパビリティは、移動先の行と桁を指定する 2 つのパラメータを与える必要が
あります。
(行と桁は 0 から数え、ユーザに見える物理画面を参照します。目に見えない
メモリ部分は参照しません。)
端末がメモリ相対のカーソル位置指定機能を持つ場合、これは
.BR mrcup
で表します。
.PP
パラメータ渡し機構では、スタックと、それを操作する特別の \fB%\fP コードを
用います。通常は、シーケンスはパラメータを 1 つスタックにプッシュし、
それをある形式で出力します。
もっと複雑な操作が必要なこともしばしばあります。
.PP
\fB%\fR コードには以下の意味があります。
.PP
.DT
.nf
.ta .5i 1.5i
	\s-1%%	`%' を出力する
	%\fI[[\fP:\fI]flags][width[.precision]][\fPdoxXs\fI]\fP
		\fBprintf\fP でのように、フラグは [-+#] とスペース
	%c	printf() の %c のように、pop() を表示する
	%s	printf() の %s のように、pop() を表示する

	%p[1-9]	\fIi\fP 番目のパラメータをプッシュする
	%P[a-z]	pop() を動的変数 [a-z] に設定する
	%g[a-z]	動的変数 [a-z] をプッシュする
	%P[A-Z]	pop() を静的変数 [a-z] に設定する
	%g[A-Z]	静的変数 [a-z] をプッシュする
	%'\fIc\fP'	文字定数 \fIc\fP
	%{\fInn\fP}	整数定数 \fInn\fP
	%l	strlen(pop) をプッシュする

	%+ %- %* %/ %m
		算術演算 (%m は剰余): push(pop() op pop())
	%& %| %^	ビット演算: push(pop() op pop())
	%= %> %<	論理演算: push(pop() op pop())
	%A, %O	論理 and 操作と論理 or 操作 (条件節用)
	%! %~	単項演算 push(op pop())
	%i	最初の 2 パラメータに 1 を足す (ANSI 端末用)

	%? expr %t thenpart %e elsepart %;
		if-then-else, %e elsepart はオプション。
		else-if は Algol 68 風に指定可能:
		%? c\d1\u %t b\d1\u %e c\d2\u %t b\d2\u %e c\d3\u %t b\d3\u %e c\d4\u %t b\d4\u %e %;
\s+1		c\di\u は条件節、b\di\u は本体。
.fi
.PP
二項演算は、通常の順序で並べたオペランドに対して後置形式で指定します。
例えば、x-5 を得るには、"%gx%{5}%-" を指定します。
エスケープされた文字列を評価する間 %P 変数と %g 変数は存続します。
.PP
HP2645 の例を考えてみましょう。これで 3 行 12 桁に移動させるには、
\eE&a12c03Y に 6 ミリ秒のパディングを送出する必要があります。
ここで行と桁とが逆になっていることと、
行、桁とも 2 桁で出力されていることに注意してください。
この端末の \fBcup\fR ケーパビリティは、\*(lqcup=6\eE&%p2%2dc%p1%2dY\*(rq
となります。
.PP
Microterm \s-1ACT-IV\s0 は、\fB^T\fR の後に現在の行と桁を、
どちらも単にバイナリ値で送る必要がありますが、
\*(lqcup=^T%p1%c%p2%c\*(rq となります。
\*(lq%c\*(rq を使う端末は、カーソルを前方に戻すこと (\fBcub1\fR) と
画面上で 1 行上にカーソルを移動させること (\fBcuu1\fR) ができる必要があります。
これは、システムが変更したり握りつぶしたりする可能性があるため、
\fB\en\fR, \fB^D\fR, \fB\er\fR を確実に送信できるとは限らないからです。
(terminfo を扱うライブラリルーチンは、タブが決して展開されないように
端末モードを設定します。ですから \et は確実に送信できます。
これは Ann Arbor 4080 では重要なことが分っています。)
.PP
最後の例は \s-1LSI ADM\s0-3a です。これは行と桁を空白文字からのオフセットで
表します。ですから、\*(lqcup=\eE=%p1%' '%+%c%p2%' '%+%c\*(rq となります。
`\eE=' を送出した後、最初のパラメータをプッシュし、空白文字の ASCII 値 (32) を
プッシュし、それらを加えて (以前の 2 つの値の代わりにその和をスタックに
プッシュし) 得た値を文字として出力します。
その後、2 番目のパラメータについても同様の処理を行います。
スタックを使うことで、さらに複雑な計算も可能です。
.PP
.SS カーソル移動
.PP
カーソルを高速にホームポジション (画面の左上隅) に移動させる方法を持つ
端末の場合、これを \fBhome\fR で指定することができます。同様に、高速に
左下隅に移動させる方法を持つ場合も \fBll\fR で指定することができます。
端末によっては、ホームポジションから \fBcuu1\fR を使って上に移動する
ことでこの動作が可能な場合もありますが、
プログラムは (\fBll\fRでそう指定しない限り) 自分からそうしては
ならないことになっています。これは、ホームポジションから上に移動した
場合の動作について、プログラムは一切想定できないからです。
ホームポジションは位置指定 (0,0)、つまり、メモリではなく、画面の左上隅と
等しいことに注意してください。
(ですから、HP 端末の \eEH のシーケンスは
.BR home
として使用できません。)
.PP
端末が行や桁の絶対カーソル位置指定機能を持つ場合、単一パラメータを取る
ケーパビリティ
.B hpa
(水平絶対位置) と
.B vpa
(垂直絶対位置) で指定します。
(hp2645 のような) 一般的な 2 パラメータのシーケンスよりもこれらの方が
短くなる場合がときどきあり、その場合、
.BR cup
よりもそれらを使う可能性があります。
パラメータ化された局所移動機能 (例えば、
.I n
桁右へ移動する) が存在する場合、これらは、いくつ移動するかを指定する
パラメータを 1 つ持つ
.BR cud ,
.BR cub ,
.BR cuf ,
.BR cuu
を使って指定することができます。
これらは主に、\s-1TEKTRONIX\s+1 4025 のように端末が
.BR cup
を持たない場合に有益です。
.PP
これらのケーパビリティを使用するプログラムを実行する際に、端末を
特殊なモードにする必要がある場合、このモードに入るコードと出るコードをそれぞれ
\fBsmcup\fR と \fBrmcup\fR で指定することができます。
こういう事態が生じる場合として、例えば Concept のように、複数ページの
メモリを持つ端末があります。
画面相対指定を持たず、メモリ相対のカーソル位置指定機能しか持たない
この端末の場合、画面の大きさのウィンドウ 1 枚を端末に固定で割り付け、
カーソル位置指定を適切にできるようにしなければなりません。
このケーパビリティは \s-1TEKTRONIX\s+1 4025 でも使用されています。
こちらでは、
.B smcup
で、terminfo で使用するコマンド文字を設定しています。
\fBrmcup\fP シーケンス が出力された後に、\fBsmcup\fP シーケンスが画面を
(\fBrmcup\fP を出力する前の状態に) 回復しないならば、\fBnrrmc\fP を
指定してください。
.PP
.SS 領域消去
.PP
端末がカーソルを動かさずに、現在位置から行の末端まで消去可能である場合、
これを \fBel\fR で指定すべきです。
端末がカーソルを動かさずに、行の先頭から現在位置を含めて現在位置まで
消去可能である場合、これを \fBel1\fP で指定すべきです。
端末が現在位置から画面の終りまでを消去可能な場合、これを \fBed\fR で
指定すべきです。
\fBed\fR は行の第 1 桁から行う場合のみ定義されます。
(ですから、まともな
.B ed
が利用できない場合でも、大量の行削除リクエストを使ってシミュレート可能です。)
.PP
.SS 行の挿入/削除と垂直移動
.PP
カーソルのある行の前に空白行を新規につくることができる端末の場合、
これを \fBil1\fR で指定すべきです。これは、行の先頭位置でのみ行われます。
作成後、カーソルは新しくできた空白行に置かれる必要があります。
端末がカーソルのある行を削除できる場合、これを \fBdl1\fR で指定すべきです。
この機能は削除される行の先頭でのみ行われます。
.B il1
と
.B dl1
の変種で、挿入/削除する行数を表すパラメータを 1 つ取るものは、
.B il
と
.BR dl
とで指定できます。
.PP
(vt100 のように) スクロール領域を設定可能な端末の場合、
領域設定コマンドを
.B csr
ケーパビリティを用いて指定可能です。このケーパビリティは 2 つのパラメータ、
スクロール領域の先頭行と最終行、を取ります。
困ったことに、このコマンド実行後のカーソル位置は定義されません。
.PP
適切な領域に
.B csr
を用いることで行の挿入/削除の効果を得ることが可能です。
.B sc
と
.B rc
(カーソルの保存と回復) コマンドは、合成した挿入/削除文字列がカーソルを
動かさないことを保証するには有用でしょう。
(\fBncurses\fR(3X) ライブラリは自動的にこの合成を行うので、
\fBcsr\fR で挿入/削除文字列をエントリ用につくる必要はないことに
注意してください。)
.PP
挿入と削除を構成するもう 1 つの方法は、(HP-700/90 シリーズには挿入/削除は
ありますが、このシリーズのような) いくつかの端末にあるメモリロック機能と
index を組み合わせて使うことです。
.PP
まともな行挿入/削除コマンドを持たない端末で、画面の最上端もしくは
最下端で行を挿入する場合、
.B ri
もしくは
.B ind
を使って行うこともできます。まともな行挿入/削除コマンドを持つ場合でも、
これらを使う方が速い場合が多いです。
.PP
スクロールする各ウィンドウが実質的に画面大のキャンバス上のビューポートで
あるなら、ブール値 \fBnon_dest_scroll_region\fR を設定すべきです。
このケーパビリティをテストするためには、画面の中央にスクロール領域をつくり、
最下行に何かを書き、領域の一番上にカーソルを動かし、\fBri\fR を行った後
\fBdl1\fR か \fBind\fR を行ってください。
\fBri\fR で領域の下へとスクロールして消えたデータが、
再び現れるなら、スクロールは非破壊的です。System V Curses と
XSI Curses は \fBind\fR, \fBri\fR, \fBindn\fR, \fBrin\fR が破壊的スクロールを
シミュレーションすることを期待します。
これが本当でない限り \fBcsr\fR を定義しないようにと文書には注意書きがあります。
この \fBcurses\fR の実装はより寛大で、\fBndstr\fR が定義されていれば
スクロールの後に明示的に消去を行います。
.PP
メモリの一部に、すべてのコマンドが影響するウィンドウを定義することが
できる端末の場合、それは、パラメータ化文字列
.BR wind
で指定すべきです。
メモリ中での開始行、終了行、開始桁、終了桁を表す 4 パラメータは、
この順番で与えます。
.PP
上側の表示メモリを保持できる端末の場合、\fBda\fR ケーパビリティを
指定すべきです。下側の表示メモリを保持できる場合、\fBdb\fR を指定すべきです。
これらは、行削除やスクロールにより、画面最下端に非空白行が上がってくること、
および、\fBri\fR による逆スクロールにより非空白行が下がってくることを表します。
.PP
.SS 文字の挿入/削除
.PP
.I terminfo
で記述可能な文字の挿入/削除に関して、基本的には 2 種類の
インテリジェント端末があります。
もっとも標準的な文字挿入/削除機能は、現在行の文字のみが影響を受け、
シフトした文字は一体となって移動し行端で消えて行くものです。
その他の端末、例えば Concept 100 や Perkin Elmer Owl のようなものの場合、
表示出力された空白とそうでない空白との間に区別があります。挿入/削除に
ともなうシフトは画面上の表示出力されていない空白に対してのみ適用され、
それぞれ空白の消滅、もしくは表示出力されていない空白 2 つになります。自分が
持っている端末がどちらのタイプかを調べるには、画面を消去してから、カーソル
移動を用いてテキストを 2 箇所に分けて出力します。\*(lqabc\*(rq と
\*(lqdef\*(rq の間に (空白文字でなく) 局所的カーソル移動を用いて
\*(lqabc\ \ \ \ def\*(rq を出力してください。
その後、カーソルを \*(lqabc\*(rq の前に移動させ、端末を挿入モードにします。
文字を打ち込むと、行の残りが一体となってシフトして行の端で文字がこぼれ
おちてゆくならば、この端末は表示出力された空白とそうでない空白を区別しません。
\*(lqabc\*(rq がシフトして \*(lqdef\*(rq に当りその後はそれらが一緒に
行の端まで進み、次の行まで進むならば、この端末は 2 番目のタイプのもので
\*(lqinsert null\*(rq を表すケーパビリティ \fBin\fR を指定すべきです。
論理的には、これらは別の属性 (挿入モードが 1 行か複数行か、および、
表示出力されていない空白を特別扱いするか否か) ですが、挿入モードを
この属性 1 つで記述できない端末に、今までお目にかかったことはありません。
.PP
terminfo では、挿入モードを持つ端末も、現在行の上で場所を空ける短い
シーケンスを送る端末も、両方とも記述することができます。
挿入モードに入るシーケンスは \fBsmir\fR で指定してください。
挿入モードから出るシーケンスは \fBrmir\fR で指定してください。
挿入したい文字の直前に、あるシーケンスを送出する必要がある場合は
\fBich1\fR で指定してください。まともな挿入モードを持つ端末のほとんどでは、
\fBich1\fR を指定することはないでしょう。
一方、画面上で場所を空けるシーケンスを送る端末の場合は、
\fBich1\fR を指定すべきです。
.PP
両方持つ端末の場合、通常は \fBich1\fR よりも挿入モードの方が望ましいでしょう。
技術的には、実際に両方を組み合わせて使用する必要がある場合以外は、両方同時に
指定すべきではありません。よって、両方あると curses を使わない
アプリケーションの中には混乱するものがあります。その兆候は、挿入を使った
更新の時に文字が二重になることです。この要求は現在では稀です。ほとんどの
\fBich\fR シーケンスはその前に smir を必要とはせず、
ほとんどの smir 挿入モードは各文字の前に \fBich1\fR を必要とはしません。
よって、新しい \fBcurses\fR は実際にこれが真実だと仮定し、
\fBrmir\fR/\fBsmir\fR か \fBich\fR/\fBich1\fR のどちらか一方 (両方では
ありません) を適切なものとみなして利用します。もし、両方を必要とするほど
古い端末のエントリを、新しい curses で使うために書く必要があるなら、
\fBich1\fR に \fBrmir\fR/\fBsmir\fR シーケンスを含めてください。
.PP
挿入後のパディングが必要な場合、\fBip\fR (文字列オプション) に必要なミリ秒の
数を指定してください。その他のシーケンスで文字 1 文字を挿入後に送出する
必要のあるものを、いっしょに \fBip\fR で指定することもできます。
「挿入モード」に入り、かつ挿入する文字ごとにあるコードを付けて
送出する必要のある端末の場合、
.BR smir / rmir
と
.B ich1
とを両方とも指定してください。そうすることで、それらが使われるようになります。
.B ich
ケーパビリティはパラメータ
.IR n
1 つをとり、これは
.B ich1
の動作を
.I n
回繰り返します。
.PP
挿入モードでないとき、文字入力の間にパディングが必要なら、\fBrmp\fP に
ミリ秒のパディングの数を指定してください。
.PP
挿入モードの途中で同じ行の文字を削除するために、カーソルを動かす必要がある
場合があります (例えば、挿入位置の後にタブがある場合)。挿入モードに
入ったままでカーソルを移動させることができる場合、このような場合の挿入を
高速に行うために、ケーパビリティ \fBmir\fR を指定することができます。
\fBmir\fR を省略しても、影響を受けるのは速度のみです。
端末によっては (有名な Datamedia のアレとか) 挿入モードの
動作方法の違いにより \fBmir\fR を指定してはいけないものがあります。
.PP
最後に、文字 1 文字の削除用として
.B dch1
を、
.I n 文字
削除用としてパラメータ
.IR n
1 つをとる
.B dch
を、そして \fBsmdc\fR と \fBrmdc\fR をそれぞれ削除モードに入る
シーケンスとそこから出るシーケンスとして与えることで
削除モード (
.B dch1
が動作するために、端末が入っていなければならないモード) を指定することが
できます。
.PP
.I n
文字を削除する (カーソルを移動させずに空白を
.I n
個出力することと同等の処理) ためのコマンドは、パラメータを 1 つとる
.B ech
を使って指定することができます。
.PP
.SS "ハイライト・下線・可視ベル"
.PP
端末が 1 つまたはそれ以上の表示属性を持つ場合、これらを表す方法として異なった
やり方がいくつかあります。
エラーメッセージや他の種類の注意を引くメッセージに適した、十分コントラストが
高く目立つ形式から 1 つ、\f2強調モード\fR を選択すべきです。
(選ぶなら、反転表示に半輝度を加えたもの、もしくは単に反転のみがよいでしょう。)
強調モードに入るシーケンス、出るシーケンスはそれぞれ \fBsmso\fR と
\fBrmso\fR で指定します。
TVI 912 や Teleray 1061 のように、強調モードへの出入りにより画面に空白が
1 つ 2 つ残る場合、\fBxmc\fR を指定して空白がいくつ残るかを教えるべきです。
.PP
下線引きを開始するコード、終了するコードは、それぞれ \fBsmul\fR と
\fBrmul\fR で指定します。
Microterm Mime のように、現在位置の文字に下線を引き、空白 1 つ分
カーソルを右に移動するコードを持つ端末の場合、そのコードを \fBuc\fR で
指定することができます。
.PP
その他もろもろの強調モードに入るケーパビリティには、
.B blink
(点滅)
.B bold
(太字もしくは更に明るい)
.B dim
(暗いもしくは半輝度)
.B invis
(空白もしくは見えないテキスト)
.B prot
(保護状態)
.B rev
(反転表示)
.B sgr0
(
.I すべての
属性モードをオフにする)
.B smacs
(別の文字セットモードに入る)
and
.B rmacs
(別の文字セットモードから出る) が含まれます。
これらのモードのどれか 1 つをオンにした場合に、他のモードがオフになる場合も
ありますし、ならない場合もあります。
.PP
モードの任意の組み合わせを設定するシーケンスが存在する場合、それを
9 つのパラメータを持つ
.B sgr
(属性の設定) で指定します。
パラメータのそれぞれは、0 か非 0 の値を取り、対応する属性がオンかオフかを
表します。
9 つのパラメータとは、順に、強調、下線、反転表示、点滅、暗い表示、太字、
空白、保護、別の文字セットです。
必ずしもすべてのモードが
.BR sgr
によってサポートされている必要はありません。
独立した属性コマンドが存在するものだけで構いません。
.PP
例えば、DEC vt220 は以下のモードのほとんどをサポートします。
.PP
.TS
center;
l c c
l c c
lw28 lw6 lw2 lw20.
\fBtparm パラメータ	属性	エスケープシーエンス\fP

none	なし	\\E[0m
p1	強調	\\E[0;1;7m
p2	下線	\\E[0;4m
p3	反転表示	\\E[0;7m
p4	点滅	\\E[0;5m
p5	暗い表示	利用できません
p6	太字	\\E[0;1m
p7	不可視	\\E[0;8m
p8	保護	使われていません
p9	別の文字セット	^O (オフ) ^N (オン)
.TE
.PP
各モードが動作中かどうかを素早く決める方法がないので、
エスケープシーケンスを動作中のモードをすべてオフにするもので始めます。
強調は反転と太字の組合せでできています。
保護モードはホストの消去から画面の文字を保護するので、sgr では普通は
使われませんが、vt220 端末には保護モードがあります。
別の文字セットモードは、オフかオンかによって ^O または ^N であるという点で
異なります。
全モードをオンにするシーケンスは \\E[0;1;4;5;7;8m^N です。
.PP
いくつかのシーケンスは異なるモードに共通です。
例えば、;7 は、p1 か p3 が真であるとき、すなわち強調か反転モードがオンのときに
出力されます。
.PP
上のシーケンスを依存関係とあわせて余すところなく書くと次のようになります。
.PP
.TS
center;
l c c
l c c
lw28 lw6 lw2 lw20.
\fBシーケンス	出力される場合	terminfo への翻訳\fP

\\E[0	常に	\\E[0
;1	p1 または p6 のとき	%?%p1%p6%|%t;1%;
;4	p2 のとき	%?%p2%|%t;4%;
;5	p4 のとき	%?%p4%|%t;5%;
;7	p1 または p3 のとき	%?%p1%p3%|%t;7%;
;8	p7 のとき	%?%p7%|%t;8%;
m	常に	m
^N または ^O	p9 が真なら ^N そうでなければ ^O	%?%p9%t^N%e^O%;
.TE
.PP
これをすべて一緒に sgr シーケンスに詰め込むと次のようになります。
.PP
.nf
    sgr=\\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;
        %?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\\016%e\\017%;,
.fi
.PP
sgr を設定したら、sgr0 も設定する必要があることを忘れないでください。
.PP
「魔法のクッキー (magic cookie)」
.RB ( xmc )
を持つ端末では、モード設定シーケンスを受信すると特殊な「クッキー」とでも
呼ぶべきゴミを画面に残します。この端末では、モード設定シーケンスは、
各文字に余分なビットを持たせるのではなく、表示アルゴリズムそのものに
影響を与えます。
HP 2621 などのような端末では、次の行へ移動したり、カーソルの位置指定を
した際に強調モードから勝手に抜け出てしまいます。
強調モードを用いるプログラムは、強調モードでの移動が安全であることを示す
.B msgr
ケーパビリティの指定が無い場合には、カーソルを移動させたり改行文字を
送出する前に強調モードから脱出すべきです。
.PP
エラー発生を無音で (ベルの代わりに) 通知するため、画面をフラッシュさせる
方法が提供されている端末の場合、それを \fBflash\fR で指定できます。これは
カーソルを移動させてはなりません。
.PP
カーソルが最下行にないときに通常の状態以上に見易くする  (例えば、点滅しない
下線カーソルを、より見つけやすいブロックカーソルや点滅下線カーソルにする)
必要がある場合、そのシーケンスを
.BR cvvis
で指定してください。
カーソルを完全に見えないようにする方法がある場合、それを
.BR civis
で指定してください。
これらのモードの効果を打ち消すシーケンスとして、ケーパビリティ
.BR cnorm
を指定すべきです。
.PP
たとえ重ね打ちでないとしても、(特殊なコードなしで) 下線文字を正しく
生成できる端末の場合、ケーパビリティ \fBul\fR を指定すべきです。
文字を別の文字に重ね打ちすると両方の文字が画面に残るなら、ケーパビリティ
\fBos\fP を指定してください。
重ね打ちが空白文字で消去可能な場合、\fBeo\fR を指定してそのことを明らかに
しておくべきです。
.PP
.SS キーパッドとファンクションキー
.PP
キーを押すとコードを送出するキーパッドを持つ場合、
そのキーパッドに関する情報を指定することができます。
注意すべき点として、キーパッドが局所モードでしか動作しない端末
(例えば、シフト状態でない HP 2621 のキーがこれに該当します)
を扱うことはできないことがあります。
送信状態か非送信状態かを設定できるキーパッドの場合、それらのためのコードを
\fBsmkx\fR と \fBrmkx\fR とで指定することができます。
これらの指定がない場合、キーパッドは常に送信状態として扱われます。
左矢印、右矢印、上矢印、下矢印キー、home キーが送出するコードは、それぞれ
\fBkcub1, kcuf1, kcuu1, kcud1, khome\fR で指定できます。
f0, f1, ..., f10 のようなファンクションキーがある場合、これらが送出する
コードは \fBkf0, kf1, ..., kf10\fR で指定できます。
これらのキーが f0 から f10 までのデフォルトのラベル以外のラベルを持つ場合、
このラベルを \fBlf0, lf1, ..., lf10\fR で指定できます。
他の特殊キーが送出するコードは、以下のように指定できます。
.B kll
(ホームダウン (home down))、
.B kbs
(バックスペース (backspace))、
.B ktbc
(全タブクリア (clear all tabs))、
.B kctab
(この桁のタブストップをクリア)、
.B kclr
(画面消去 (clear screen) キーまたは抹消 (erase) キー)、
.B kdch1
(文字削除 (delete character))、
.B kdl1
(行削除 (delete line))、
.B krmir
(挿入モードから抜ける (exit insert mode))、
.B kel
(行末までクリア)、
.B ked
(画面の終りまでクリア)、
.B kich1
(文字挿入 (insert character) または挿入モードに入る (enter insert mode))、
.B kil1
(行挿入 (insert line))、
.B knp
(次のページ (next page))、
.B kpp
(前のページ (previous page))、
.B kind
(前進スクロール (scroll forward) / 下降スクロール (scroll down))、
.B kri
(後退スクロール (scroll backward) / 上昇スクロール (scroll up))、
.B khts
(この桁にタブストップを設定)。
.\" ×がうまく表示されないので \[mu] 使用
更に、キーパッドが 4 つの矢印を含む 3 \[mu] 3 のキー配列を持つ場合、他の 5 つの
キーを
.BR ka1 ,
.BR ka3 ,
.BR kb2 ,
.BR kc1 ,
.BR kc3 .
で指定します。
3 \[mu] 3 のカーソル移動キーパッドの効果が必要な場合、これらのキーが有用です。
.PP
ファンクションキーにプログラムする文字列は、
.BR pfkey ,
.BR pfloc ,
.BR pfx
で指定できます。
画面のラベルの文字列は \fBpln\fP で指定すべきです。
これらの文字列は、それぞれ 2 つの引数を取ります。
プログラム対象のファンクションキー番号 (0 から 10 まで) と、
そこにプログラムする文字列です。
この範囲外のファンクションキー番号を使うと未定義のキーに対してプログラムして
しまうかもしれず、これは端末依存の動作となります。
これらのケーパビリティの違いは以下の通りです。
.B pfkey
を指定すると、そのキーを押すことは、ユーザが指定した文字列をタイプするのと
同じことになります。
.B pfloc
では、端末内部で局所的にその文字列が実行されることになります。
.B pfx
では、その文字列がコンピュータに送出されることになります。
.PP
ケーパビリティ \fBnlab\fP, \fBlw\fP, \fBlh\fP はプログラム可能な画面のラベルの
数、幅、高さを定義します。
ラベルをオン、オフするコマンドがあるなら、\fBsmln\fP と \fBrmln\fP に
指定してください。
変更が見えるのを確実にするために、通常 \fBsmln\fP は 1 つ以上の
pln シーケンスの後で出力されます。
.PP
.SS タブと初期化
.PP
端末がハードウェアタブを持つ場合、次のタブストップまでカーソルを進める
コマンドを
.B ht
(通常は control I) で指定できます。
前のタブストップまで左方向に進める「後退タブ」コマンドは、
.BR cbt
で指定できます。
端末が、タブが端末に送出されずにコンピュータ内部で空白に展開されるモードに
なっている場合、プログラムは、たとえ
.B ht
や
.B cbt
が存在しても、それらを使用しないという約束になっています。これは、
ユーザがタブストップを正しく設定していない可能性があるためです。
電源投入時に、
.I n
個の空白ごとにハードウェアタブが初期化されている端末の場合、数値パラメータ
.B it
を指定します。これはタブとして設定される空白数を表します。
通常、これは
.IR tset
コマンドが、ハードウェアタブ展開を使用するモード設定と、タブストップ設定とを
行うかどうかを決定するために使用します。
タブストップ設定を不揮発性メモリに記憶できる端末の場合、terminfo での記述の
際に、タブストップは正しく設定されていることを想定して構いません。
.PP
他のケーパビリティとして、
.BR is1 ,
.BR is2 ,
.BR is3
があり、これらは端末を初期化する文字列を指定します。また、
.BR iprog
があり、これは端末初期化用として実行するプログラムのパス名を指定します。
また、\fBif\fR があり、これは初期化文字列が長い場合、それを含むファイルの
名前を指定します。
これらの文字列により、terminfo の残りの記述と矛盾なく動作するモードに
端末が設定されることが求められます。
通常、ユーザがログインするたびに、
.IR tput
プログラムの
.I init
オプションがこれらの文字列を端末に対して送出します。
送出は以下の順序で行われます。
プログラム
.BR iprog
を実行 ;
.BR is1
を出力 ;
.BR is2
を出力 ;
.BR mgc ,
.BR smgl
と
.BR smgr
でマージンを設定 ;
.B tbc
と
.BR hts
でタブを設定 ;
ファイル
.BR if
を印字 ;
最後に
.BR is3
を出力。
.PP
初期化のほとんどは
.BR is2
で行われます。
共通のシーケンスを
.B is2
に置き、特殊な場合を
.B is1
と
.BR is3
とに置くことで、文字列をそれぞれに複製して持たせなくても、
特殊な端末モードを設定することができます。
まったくわけのわからない状態から復帰するための、よりハード寄りの
リセットを行うためのシーケンスの組も同様に、
.BR rs1 ,
.BR rs2 ,
.BR rf ,
.BR rs3
で指定することができます。これらは
.B is2
と
.BR if
と良く似たシーケンスです。
端末がハマったときに使うプログラムである、
.IR reset
がこれらのシーケンスを出力します。
コマンドを
.BR rs1 ,
.BR rs2 ,
.BR rs3 ,
.B rf
に置くのは、普通、そのコマンドが画面にユーザを混乱させる効果を産み出し、
かつ、ログインの際には必要ない場合に限ります。
例えば、vt100 を 80 桁モードに設定するコマンドは、普通なら
.BR is2
に含めるはずですが、
このコマンドは画面に混乱させるゴミを作り出しますし、端末は既に 80 桁モードに
なっているのが普通ですので、このコマンドを含める必要ありません。
.PP
タブストップの設定、クリアを行うコマンドがある場合、それらを
.B tbc
(全タブストップのクリア)
と
.B hts
(各行の現在桁にタブストップを設定)
に指定できます。
タブ設定に関して、ここで説明したものより複雑なシーケンスが必要な場合、
そのシーケンスを
.B is2
や
.BR if
に置いても構いません。
.SS 遅延とパディング
.PP
ハードコピー端末と (例えば、DEC VT100 を含む) 非常に古い CRT を含む、
多くの古くて遅い端末は XON/XOFF ハンドシェークも DTR ハンドシェークも
サポートしません。特定のカーソルの移動とスクリーンの変更の後には、
パディング文字が必要かもしれません。
.PP
端末がフロー制御のための xon/xoff ハンドシェークを使用する場合 (すなわち、
入力バッファが一杯に近くなると、ホストに自動的に ^S を送り返す場合)、
.BR xon
を指定してください。
このケーパビリティはパディングの送出を抑えます。実質的に速度に制限のない
メモリマップト形式のコンソールデバイスに対しても指定できます。
ルーチンが相対的なコストに関してよりよい見積もりを立てることができるように、
この場合でもパディング情報を指定すべきです。しかし、実際はパディング文字は
送信されません。
.PP
\fBpb\fR (パディングボーレート) を指定することで、ボーレートが
\fBpb\fR の値より低い場合、パディングが抑えられます。
エントリにパディングボーレートがなければ、
パディングが送出されるかされないかは \fBxon\fR により完全に制御されます。
.PP
ヌル (0) 文字以外のパディング文字を必要とする端末の場合、それを
\fBpad\fR で指定できます。
.B pad
文字列の最初の文字のみが使用されます。
.PP
.SS ステータス行
端末には、通常のソフトウェアでは使用されない (それゆえ、端末の \fBlines\fR
ケーパビリティでは数に入らない) 余分な「ステータス行」を
持つものもあります。
.PP
最も簡単な場合には、ステータス行はカーソル位置の指定は可能ですが、
画面上のスクロール領域の一部ではないものです。
初期化のときに 23 行のスクロール領域のある 24 行の VT100 と同じように、
Heathkit H19 には、この種のステータス行があります。
この状況は \fBhs\fR ケーパビリティで指定します。
.PP
ステータス行に入るには特別なシーケンスを必要とする端末もあります。
これはパラメータを 1 つとる文字列 \fBtsl\fR で表します。
これはカーソルをステータス行の与えられた 0 桁に移動します。
ケーパビリティ \fBfsl\fR で最後の \fBtsl\fR の前の主画面のカーソル位置に
戻る必要があります。そのために \fBtsl\fR と \fBfsl\fR の中に
\fBsc\fR (save cursor) と \fBrc\fR (restore cursor) の文字列の値を含める
必要があるかもしれません。
.PP
ステータス行は通常、端末の幅と同じ幅だと仮定されています。これが
本当でないのなら、そのことを数値ケーパビリティ \fBwsl\fR で指定できます。
.PP
ステータス行を消去したり削除するコマンドは \fBdsl\fR で指定できます。
.PP
ブール値ケーパビリティ \fBeslok\fR は、ステータス行内でエスケープシーケンスや
タブ等が通常通り働くことを示します。
.PP
\fBncurses\fR の実装はこれらのケーパビリティのどれもまだ利用していません。
これらが重要になったらここに記述します。
.PP
.SS 線画
.PP
多くの端末には図を描くのに役に立つ別の文字セットがあります。
terminfo と \fBcurses\fR は VT100 でサポートされている図形文字と
AT&T 4410v1 の文字のいくつかをサポートします。
この別の文字セットは \fBacsc\fR ケーパビリティで設定されます。
.PP
.TS H
center expand;
c l l c
c l l c
lw28 lw6 lw2 lw20.
.\".TH
\fBGlyph	ACS	Ascii	VT100\fR
\fBName	Name	Default	Name\fR
UK pound sign        	ACS_STERLING	f	}
arrow pointing down	ACS_DARROW	v	.
arrow pointing left	ACS_LARROW	<	,
arrow pointing right	ACS_RARROW	>	+
arrow pointing up	ACS_UARROW	^	-
board of squares	ACS_BOARD	#	h
bullet          	ACS_BULLET	o	~
checker board (stipple)	ACS_CKBOARD	:	a
degree symbol   	ACS_DEGREE	\e	f
diamond         	ACS_DIAMOND	+	`
greater-than-or-equal-to	ACS_GEQUAL	>	z
greek pi        	ACS_PI	*	{
horizontal line 	ACS_HLINE	-	q
lantern symbol  	ACS_LANTERN	#	i
large plus or crossover	ACS_PLUS	+	n
less-than-or-equal-to	ACS_LEQUAL	<	y
lower left corner	ACS_LLCORNER	+	m
lower right corner	ACS_LRCORNER	+	j
not-equal       	ACS_NEQUAL	!	|
plus/minus      	ACS_PLMINUS	#	g
scan line 1     	ACS_S1  	~	o
scan line 3     	ACS_S3  	-	p
scan line 7     	ACS_S7  	-	r
scan line 9     	ACS_S9  	\&_	s
solid square block	ACS_BLOCK	#	0
tee pointing down	ACS_TTEE	+	w
tee pointing left	ACS_RTEE	+	u
tee pointing right	ACS_LTEE	+	t
tee pointing up 	ACS_BTEE	+	v
upper left corner	ACS_ULCORNER	+	l
upper right corner	ACS_URCORNER	+	k
vertical line   	ACS_VLINE	|	x
.TE
.PP
新しいデバイスの図形セットを定義するのに一番よい方法は、この表のその端末用の
コピーに列を追加し、対応する図形のところに (\fBsmacs\fR/\fBrmacs\fR スイッチの
間に送出される場合に) 送出される文字を与えることです。それから VT100 と
その端末の文字を右から左に順に読み上げてください。
これが ACSC 文字列になります。
.PP
.SS 色の扱い
.PP
ほとんどのカラー端末は `Tektronix 風' か `HP 風' のどちらかです。Tektronix 風
端末には、あらかじめ定義された N 色 (N は通常 8 です) の組があり、
文字セル毎に独立に前景色と背景色を設定して、N * N の色ペアにできます。
HP 風端末では、色ペアをそれぞれ別々に設定する必要があります (前景と背景は
独立には設定できません)。
2*M の異なった色からは M までの色ペアができます。ANSI-互換端末は Tektronix 風
です。
.PP
いくつかの基本的な色に関するケーパビリティは色の扱い方とは独立です。数値
ケーパビリティ \fBcolors\fR と \fBpairs\fR には、同時に表示できる色または
色ペアの最大数を指定します。\fBop\fR (original pair) 文字列は前景色と背景色を
端末の規定値にリセットします。\fBoc\fR 文字列はすべての色または色ペアを
端末の規定値にリセットします。(多くの PC 端末エミュレータを含む)
いくつかの端末では、電源投入時の背景色ではなく、現在の背景色で
画面領域を消去します。この場合にはブール値ケーパビリティ \fBbce\fR を
指定すべきです。
.PP
Tektronix 型の端末で現在の前景色と背景色を変えるためには、
\fBsetaf\fR (set ANSI foreground) と \fBsetab\fR (set ANSI background) を
使うか、\fBsetf\fR (set foreground) と \fBsetb\fR (set background) を
使ってください。
これらは 1 つのパラメータ、色番号をとります。SVr4 の文書には
\fBsetaf\fR/\fBsetab\fR だけが書かれています。XPG4 の草案には、
「端末が背景と前景を設定する ANSI エスケープシーケンスをサポートするなら、
それぞれ \fBsetaf\fR と \fBsetab\fR で指定すべきです。
端末が背景と前景を設定する別のエスケープシーケンスをサポートするなら、
それぞれ \fBsetf\fR と \fBsetb\fR で指定すべきです。\fIvidputs()\fR
関数と refresh 関数 は、定義されていれば \fBsetaf\fR と \fBsetab\fR を
使います。」と書かれています。
.PP
\fBsetaf\fR/\fBsetab\fR と \fBsetf\fR/\fBsetb\fR ケーパビリティはそれぞれ
数値引数を 1 つとります。引数値 0-7 は移植できるよう以下のように定義されて
います (中央の列は \fBcurses\fR や \fBncurses\fR ライブラリ用にヘッダで
利用できる記号の #define です)。端末のハードウェアはこれを好きなように
マップするのは自由ですが、RGB 値は色空間での通常の位置を示しています。
.PP
.TS H
center;
l c c c
l l n l.
\fB色	#define 	値	RGB\fR
黒	\fBCOLOR_BLACK\fR	0	0, 0, 0
赤	\fBCOLOR_RED\ \fR	1	max,0,0
緑	\fBCOLOR_GREEN\fR	2	0,max,0
黄	\fBCOLOR_YELLOW\fR	3	max,max,0
青	\fBCOLOR_BLUE\fR	4	0,0,max
マゼンタ	\fBCOLOR_MAGENTA\fR	5	max,0,max
シアン	\fBCOLOR_CYAN\fR	6	0,max,max
白	\fBCOLOR_WHITE\fR	7	max,max,max
.TE
.PP
HP 風の端末では、どの色ペアが現在のものかを設定する色ペア番号パラメータを
ともなった \fBscp\fR を使ってください。
.PP
Tektronix 風の端末では、色が変更できることを示すためにケーパビリティ
\fBccc\fR があります。もしそうであれば、
\fBinitc\fR ケーパビリティは色数 (0 から \fBcolors\fR - 1) と
色を記述する 3 つのパラメータをとります。この 3 つのパラメータは、デフォルトでは
RGB (Red, Green, Blue) 値と解釈されます。ブール値ケーパビリティ \fBhls\fR が
あれば、代わりに HLS (Hue, Lightness, Saturation) 指標になります。
範囲は端末に依存します。
.PP
HP 風の端末では、\fBinitp\fR が色ペア値を変更するケーパビリティを与えます。
パラメータを 7 つとります。色ペア番号 (0 から \fBmax_pairs\fR - 1 まで) と
3 つの数の組が 2 つです。最初の組で背景色を、2 番目の組で前景色を記述します。
これらのパラメータは \fBhls\fR に依存して (Red, Green, Blue) か
(Hue, Lightness, Saturation) である必要があります。
.PP
カラー端末のいくつかでは、色はハイライトと衝突します。
この衝突を \fBncv\fR ケーパビリティで登録できます。
これは、色が利用可能なときに使うことができない属性のビットマスクです。
\fBcurses\fR が理解する属性との対応は以下の通りです。
.PP
.TS
center;
l c c
lw25 lw2 lw10.
\fB属性	ビット	10 進数\fR
A_STANDOUT	0	1
A_UNDERLINE	1	2
A_REVERSE	2	4
A_BLINK   	3	8
A_DIM      	4	16
A_BOLD    	5	32
A_INVIS   	6	64
A_PROTECT	7	128
A_ALTCHARSET	8	256
.TE
.PP
例えば、多くの IBM PC コンソールで、下線の属性は前景色、青と衝突してしまい、
カラーモードでは利用できません。これは、\fBncv\fR ケーパビリティに 2 を
指定すべきです。
.PP
SVr4 curses は \fBncv\fR では何もしませんが、
ncurses はそれを認識してカラー用に出力を最適化します。
.PP
.SS その他
ヌル (0) 文字以外のパディング文字を必要とする端末の場合、それを pad で
指定することができます。
pad 文字列の最初の文字のみが使用されます。
パディング文字を持たない端末の場合、npc を指定してください。
ncurses は termcap 互換の \fBPC\fR 変数を実装していることに注意してください。
アプリケーションはこの値をナル以外のものに設定するかもしれませんが、
ncurses は最初に \fBnpc\fR をテストし、端末にパディング文字がなければ
napms を使います。
.PP
端末が半行だけ上下移動できる場合、それを
.B hu
(半行上へ)
と
.B hd
(半行下へ)
とで指定できます。
これは、主として、ハードコピー端末の上付き文字、下付き文字のために役に
立ちます。
ハードコピー端末が用紙を排出し次のページに行くこと (フォームフィード) が
できる場合、それを
.B ff
(通常は control L) で指定します。
.PP
(同じ文字を極めて多数回繰り返し送信する際の時間節約のため) 指定した文字を
指定した回数だけ繰り返すコマンドが存在する場合、パラメータ化文字列
.BR rep
を用いてそれを指定することができます。
1 番目のパラメータは繰り返される文字で、2 番目のパラメータは繰り返し回数です。
ですから、tparm(repeat_char, 'x', 10) は `xxxxxxxxxx' と同じことです。
.PP
\s-1TEKTRONIX\s+1 4025 のように、コマンド文字を設定可能な端末の場合、
.BR cmdch
を用いてそれを表すことができます。
すべてのケーパビリティで使用されるプロトタイプコマンド文字を指定できます。
この文字は
.B cmdch
ケーパビリティで指定され、それが識別されます。
いくつかの UNIX システムでは以下の約束にしたがって処理がなされます。
すなわち、まず環境変数
.B CC
を検査し、それが設定されている場合は、ケーパビリティ中にあるプロトタイプ
文字のすべてがその環境変数で指定された文字と置き換えられます。
.PP
.IR switch ,
.IR dialup ,
.IR patch ,
.IR network
などのような、特定の端末の種類を表さない端末記述には、プログラムが
その端末とどう通信すればよいかが分からないと表明できるようにするため、
.B gn
(一般的) ケーパビリティを指定すべきです。
(このケーパビリティは、エスケープシーケンスがわかっている
.I 仮想
端末の記述には適用されません。)
.PP
端末が、シフトキーとして動作し、文字すべての 8 ビット目を立てて送出する
「メタキー」を持つ場合、このことを
.BR km
により表すことができます。
この指定がない場合、ソフトウェアは、8 ビット目はパリティで、通常は
クリアされていると想定します。
この「メタモード」をオンオフする文字列が存在する場合、それを
.B smm
と
.BR rmm
とで指定できます。
.PP
端末が画面 1 枚分より多い行数のメモリを持つ場合、メモリの行数を
.BR lm
で指定できます。
値
.BR lm #0
は、行数は固定でないものの、1 画面分以上のメモリを持つことを表します。
.PP
端末が \s-1UNIX\s+1 の仮想端末プロトコルをサポートしている場合、
その端末番号を
.BR vt
で指定できます。
.PP
端末に接続された外部プリンタを制御するメディアコピー文字列は、次のように
指定できます。すなわち、
.BR mc0 :
画面内容の印字、
.BR mc4 :
プリンタオフ、
.BR mc5 :
プリンタオンです。
プリンタがオンのとき、端末に送出されたテキストはすべてプリンタに送られます。
プリンタがオンの状態でもなお端末にテキストが表示されるか否かは未定義です。
変種である
.B mc5p
はパラメータを 1 つ取り、そのパラメータの値だけの文字を送る間プリンタを
オンにし続け、そのあとオフにします。
このパラメータは 255 を越えてはなりません。
.BR mc4
を含むすべてのテキストは、
.B mc5p
が有効な間、透過的にプリンタに渡されます。
.PP
.SS ゴミ機能、困った機能 (Glitches and Braindamage)
.PP
Hazeltine 端末は `~' 文字を表示できません。これには \fBhz\fR を指定すべきです。
.PP
Concept や vt100 のように \fBam\fR 直後の改行文字を無視する端末の場合、
\fBxenl\fR を指定すべきです。
.PP
強調表示を取り除くために (単に通常のテキストを上に書くだけでは済まず)
.B el
が必要な場合、
\fBxhp\fP を指定すべきです。
.PP
Teleray 端末は、タブでカーソル移動した下にあった文字をすべて空白にして
しまうので、この端末では \fBxt\fR (破壊的なタブ) を指定すべきです。
注 : これに対応する変数は、現在は `dest_tabs_magic_smso' ですが、
以前のバージョンでは、teleray_glitch でした。
このふざけた機能は、``magic cookie''(魔法のクッキー) の
先頭にカーソルを置けないことと、
強調モードを消去するために、行削除と行挿入が必要であることも意味します。
ncurses の実装はこの glitch を無視します。
.PP
Beehive の Superbee 端末は、エスケープ文字や control C 文字を正しく
送信できません。これには
.BR xsb
を指定し、f1 キーをエスケープとし、f2 キーを control C として使用することを
表します。
(この問題が現れるのは特定の Superbee に限られ、その ROM に依存します。)
terminfo の古いバージョンでは、このケーパビリティは `beehive_glitch' と
呼ばれていましたが、現在では `no_esc_ctl_c' と呼ばれていることに
注意してください。
.PP
なにか特定の端末に固有の他の問題を解決したい場合、\fBx\fR\fIx\fR の形式で
新しいケーパビリティを追加して使っても構いません。
.PP
.SS よく似た端末
.PP
2 つの非常によく似た端末がある場合、いくつかの例外を除いて
一方 (変型種) は他方 (基本種) と似ているという定義を行うことができます。
変型種の定義においては、
文字列ケーパビリティ \fBuse\fR で、基本種の端末の名前を
指定できます。
.B use
の指定より前に与えたケーパビリティは、
.BR use
により得られる基本タイプの中のケーパビリティに優先します。
複数の \fBuse\fR ケーパビリティが存在する場合、逆の順番でマージされます。
すなわち、一番右側の \fBuse\fR の参照先が最初に処理され、
次にその左が処理されるといった順番になります。
エントリ中で明示的に指定されたケーパビリティは、
\fBuse\fR の参照先が与えるケーパビリティに優先します。
.PP
ケーパビリティ定義の左側に \fBxx@\fR を置くことにより、そのケーパビリティを
キャンセルできます。ここで xx はそのケーパビリティです。
例えば、エントリ
.PP
	2621-nl, smkx@, rmkx@, use=2621,
.PP
は \fBsmkx\fR も \fBrmkx\fR も持たない 2621-nl を定義します。
それゆえ、この端末はビジュアルモードでは
ファンクションキーラベルをオンにしません。
この機能はある端末の種々の機能や、ユーザの種々の設定を表す際に有用です。
.PP
.SS 長いエントリの落とし穴
.PP
長い terminfo のエントリは問題になりそうにありません。現在まで terminfo の
文字列表の最大値 4K に達したエントリはないのです。不幸なことに termcap への
翻訳はずっと厳しく制限されている (1K まで) ので、長い terminfo エントリの
termcap への翻訳は問題を引き起こすかも知れません。
.PP
4.3BSD および、より古いバージョンの tgetent() のマニュアルには、
termcap エントリ用に 1K のバッファを割り当てるように書いてあります。
エントリは termcap ライブラリによりヌル文字で終了させられるので、
termcap エントリとして安全な最大の長さは 1k-1 (1023) バイトです。
アプリケーションと使用する termcap ライブラリが何をするか、
また、tgetent() が探しているタイプの端末が termcap ファイルの
どこにあるかによって、悪いことがいくつか起こるかも知れません。
.PP
termcap ライブラリの中には、1023 バイトより長いエントリを見つけると
警告のメッセージを表示したり、終了したりするものもありますし、
そうでないものもあります。そうでないものはエントリを切捨てて 1023 バイトに
してしまいます。アプリケーションプログラムの中には termcap エントリに
推奨された 1K より多く割り当てるものもありますし、そうでないものもあります。
.PP
各 termcap エントリにはそれに関係する重要な大きさが 2 つあります。
"tc" 展開前と "tc" 展開後です。"tc" は、現在のエントリの最後に
他の termcap エントリを付け足し、そのケーパビリティを追加する
ケーパビリティです。termcap エントリが "tc" ケーパビリティを
使わないならば、もちろん 2 つの長さは同じです。
.PP
特殊な端末のユーザ以外にも影響するので、「tc 展開前」の長さは最も
重要なものです。これは /etc/termcap にあるエントリからバックスラッシュと
改行の組を引いたものの長さです。バックスラッシュと改行の組は tgetent() が
読み込む間に取り除きます。
termcap ライブラリの中には最後の改行を取り除くものもあります
(GNU termcap は行いません)。
次のように仮定します。
.TP 5
*
展開前の termcap エントリは 1023 バイト以上の長さです。
.TP 5
*
アプリケーションは 1k のバッファを割り当てただけです。
.TP 5
*
(BSD/OS 1.1 や GNU のもののように) termcap ライブラリは、
それが必要なエントリであれば、その長さに関わらず、
読むためにエントリをすべてバッファに読み込みます。
.TP 5
*
tgetent() は長いエントリの端末タイプか、長いエントリの後に termcap ファイルに
現れる端末タイプか、ファイルには全く現れない (そのため tgetent() は
termcap ファイル全体を探す必要があります) 端末タイプを探しています。
.PP
すると、tgetent() はメモリ、おそらくはスタックに重ね書きし、たぶんプログラムを
コアダンプさせるでしょう。telnet のようなプログラムは特に弱いです。
現代的な telnet は端末タイプのような値を自動的に通してしまいます。
SunOS 4.1.3 や Ultrix 4.4 のように、過度に長い termcap エントリを
読んだときには警告メッセージを表示する termcap ライブラリでも、結果は
望ましいものではありません。OSF/1 3.0 のように termcap ライブラリが
長いエントリを切り捨てるなら、ここで死ぬことはありませんが、
端末に対して不正確なデータを返すことになるでしょう。
.PP
「tc 展開後」の長さは上と同じように影響するでしょうが、
影響を受けるのは TERM をその端末タイプに実際に設定した人だけです。
tgetent() は探している時ではなく、探していた端末タイプを見つけた時に
一度だけ "tc" 展開を行うからです。
.PP
結局、1023 バイトより長い termcap エントリ は、termcap ライブラリと
アプリケーションのさまざまな組合せで、コアダンプや警告や不正確な操作を
引き起こすかもしれません。"tc" 展開前でも長過ぎるなら、他の端末タイプの
ユーザや termcap エントリのない TERM 変数を指定しているユーザにも
影響するでしょう。
.PP
-C (termcap へ翻訳) モードでは、\fBtic\fR(1) の \fBncurses\fR の
実装は tc 前の termcap へ翻訳する長さが長過ぎる場合、警告メッセージを出します。
-c (check) オプションは、分析された (tc 展開後の) 長さもチェックします。
.SS バイナリ互換性
商用の UNIX の間のバイナリの terminfo エントリの移植性に期待するのは
賢明ではありません。問題は terminfo に (HP-UX と AIX で) 少なくとも 2 つの
バージョンがあるからです。どちらも SVr1 の後で System V の terminfo から
分岐したもので、文字列表に System V や XSI Curses 拡張と
(バイナリフォーマットで) 衝突する拡張ケーパビリティを追加しています。
.SH 拡張
SVr4 の \fBcurses\fR の実装のいくつかと SVr4 以前のものすべては
パラメータ文字列内の %A 演算子と %O 演算子を解釈しません。
.PP
SVr4/XPG4 は、別の文字セットモードで \fBmsgr\fR がカーソルの移動を許可するか
どうかを指定しません (そのようなモードは、数ある中でも CR と NL を
局所的な移動を引き起こさない文字に写してしまうかも知れません)。
\fBncurses\fR の実装は \fBALTCHARSET\fR モードでは \fBmsgr\fR を無視します。
このため、反対の解釈をする XPG4 の実装では、\fBncurses\fR 用に作られた
terminfo エントリの \fBmsgr\fR をオフにする必要があるかも知れません。
.PP
\fBncurses\fR ライブラリは、更新の効率を上げるために少し非標準的な方法で
文字挿入と文字挿入モードを扱います。上記の \fB文字の挿入/削除\fR の副節を
参照してください。
.PP
\fBset_clock\fR と \fBdisplay_clock\fR のパラメータ置換は SVr4 でも
XSI Curses 規格でも説明されていません。AT&T 505 端末の説明書から
推測したものです。
.PP
\fBkmous\fR ケーパビリティの割り当てには注意してください。\fBncurses\fR は
\fBKEY_MOUSE\fR として解釈しようとし、xterm のような
キーボード入力ストリーム中でマウストラック情報を返すことのできる端末や
エミュレータが使用します。
.PP
異なる商用の terminfo と curses はそれぞれ異なる XSI Curses 標準の一部と
(いくつかの場合) 異なった拡張をサポートします。以下は
1995 年 10 月時点での正確な要約です。
.PP
\fBSVR4, Solaris, ncurses\fR --
SVr4 ケーパビリティをすべてサポートします。
.PP
\fBSGI\fR --
SVr4 すべてと説明のない拡張文字列ケーパビリティ 1 つ (\fBset_pglen\fR) を
サポートします。
.PP
\fBSVr1, Ultrix\fR --
terminfo ケーパビリティの制限された一部をサポートします。
ブール値は \fBxon_xoff\fR で、数値は \fBwidth_status_line\fR で、
文字列は \fBprtr_non\fR で終わりです。
.PP
\fBHP/UX\fR --
SVr1 の一部と、SVr[234] の数値 \fBnum_labels\fR, \fBlabel_height\fR,
\fBlabel_width\fR と、ファンクションキー 11 から 63 までと、
\fBplab_norm\fR, \fBlabel_on\fR, \fBlabel_off\fR と、文字列表の非互換な拡張を
いくつかサポートします。
.PP
\fBAIX\fR --
SVr1 の一部と、ファンクションキー 11 から 63 までと、たくさんの
非互換な文字列表拡張をサポートします。
.PP
\fBOSF\fR --
SVr4 全部と AIX 拡張の両方をサポートします。
.SH 関連ファイル
.TP 25
\*d/?/*
端末記述を含むファイル
.SH 関連項目
\fBtic\fR(1M), \fBcurses\fR(3X), \fBprintf\fR(3S), \fBterm\fR(\*n).
.SH 作者
Zeyd M. Ben-Halim, Eric S. Raymond, Thomas E. Dickey.
Pavel Curtis による pcurses に基づいています。
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
