'\" e
.\" The above line should force the use of eqn as a preprocessor
.ig
groff_out.5

Last update: 13 Apr 2003

This file is part of groff, the GNU roff type-setting system.

Copyright (C) 1989, 2001, 2002, 2003 Free Software Foundation, Inc.
rewritten from scrach 2001 by Bernd Warken <bwarken@mayn.de>

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being this .ig-section and AUTHORS, with no
Front-Cover Texts, and with no Back-Cover Texts.

A copy of the Free Documentation License is included as a file called
FDL in the main directory of the groff source package.
..
.\" $FreeBSD$
.\"
.\" FreeBSD jpman project 訳語表
.\" WORD: scaled point		スケールドポイント (groff_font.5 参照)
.\" WORD: print			印字
.
.\" --------------------------------------------------------------------
.\" Setup
.\" --------------------------------------------------------------------
.
.mso www.tmac
.
.if n \{\
.  mso tty-char.tmac
.  ftr CR R
.  ftr CI I
.  ftr CB B
.\}
.
.if '\*[.T]'dvi' \
.  ftr CB CW
.
.if t \{\
.EQ
delim $$
.EN
.\}
.
.\" ----------------- Document configuration
.
.\" Number register to decide whether the commands `{' and `}' are used
.\" 0: disable (actual default); 1: enable
.nr @USE_ENV_STACK 0
.
.ig
Unfortunately, old versions of groff used an illogical position change
after some D\~commands (Dp, DP, Dt).  If the number register
@STUPID_DRAWING_POSITIONING is 1 (actual default) then change position
after these commands, otherwise the position is not changed.
..
.nr @STUPID_DRAWING_POSITIONING 1
.
.\" ----------------- Syntactical definitions
.
.\" comments when escapes are switched off
.de c
..
.\" Begin of macro definitions
.eo
.
.de Text
.  nop \)\$*
..
.c follow-up line for a .TP header
.de TP+
.  br
.  ns
.  TP \$1
..
.c a bulleted paragraph
.de Topic
.  TP 2m
.  nop \[bu]
..
.de ShellCommand
.  br
.  IR "shell>" "\h'1m'\f[CB]\$*\f[]\/"
..
.ec
.\" End of macro definitions
.
.c ----------------- Semantical definitions
.
.nr @maxcolor 65536
.ds @backslash \[rs]\"
.ds @linebreak \f[R]\[la]line_break\[ra]\f[]\"
.
.\" Begin of macro definitions
.eo
.
.c format: .unit <letter> <punctuation>
.de unit
.  BR \$@
..
.c argument in italic with punctuation
.de argument
.  if (\n[.$] == 0) \
.    return
.  IR \$@
..
.c comma separated list of indexed variables
.de list1..n
.  ds @arg1 \$1\"
.  nop \c
.  ie t \
.    nop $\*[@arg1] sub 1$, $\*[@arg1] sub 2$, .\|.\|., $\*[@arg1] sub n$ \c
.  el \{\
.    IR \*[@arg1]1 ,
.    IR \*[@arg1]2 ,
.    nop \&...,
.    I \*[@arg1]n
.  \}
.  rm @arg1
..
.de offset
.  if (\n[.$] < 2) \
.    ab `.offset' needs at least 2 arguments
.  ds @arg1 \$1\"
.  ds @arg2 \$2\"
.  shift 2
.  nop (\f[I]\,\*[@arg1]\/\f[],\ \f[I]\,\*[@arg2]\/\f[])\$*
.  rm @arg1
.  rm @arg2
..
.de indexed_offset
.  if (\n[.$] < 4) \
.    ab `.indexed_offset' needs at least 4 arguments
.  ds @arg1 \$1\"
.  ds @index1 \$2\"
.  ds @arg2 \$3\"
.  ds @index2 \$4\"
.  shift 4
.  ie t \{\
.    ie \B'\*[@index1]' \{\
.      nop ($\*[@arg1] sub roman \*[@index1]$,\ \c
.    \}
.    el \{\
.      nop ($\*[@arg1] sub \*[@index1]$,\ \c
.    \}
.    ie \B'\*[@index2]' \{\
.      nop $\*[@arg2] sub roman \*[@index2]$)\$* \c
.    \}
.    el \{\
.      nop $\*[@arg2] sub \*[@index2]$)\$* \c
.    \}
.  \}
.  el \{\
.    nop (\f[I]\*[@arg1]\*[@index1]\f[],\ \c
.    nop \f[I]\*[@arg2]\*[@index2]\f[])\$* \c
.  \}
.  rm @arg1
.  rm @arg2
.  rm @index1
.  rm @index2
..
.c format: .command <name> "<arguments>" <punctuation>
.de command
.  ds @arg1 \$1\"
.  ds @arg2 \$2\"
.  shift 2
.  IP "\f[B]\*[@arg1]\f[]\ \f[I]\,\*[@arg2]\/\f[]\$*"
.  rm @arg1
.  rm @arg2
..
.c format: .command+ <name> "<arguments>" <punctuation>
.c continue previous .command heading
.de command+
.  ds @arg1 \$1\"
.  ds @arg2 \$2\"
.  shift 2
.  TP+
.  Text "\f[B]\*[@arg1]\f[]\ \f[I]\,\*[@arg2]\/\f[]\$*"
.  rm @arg1
.  rm @arg2
..
.c format: .D-command <subcommand> "<arguments>"
.de D-command
.  ds @sub \$1\"
.  shift 1
.  IP "\f[B]D\*[@sub]\f[]\ \f[I]\,\$*\/\f[]\|\*[@linebreak]"
.  rm @sub
..
.c format: .D-command+ <subcommand> "<arguments>"
.c continue previous .D-command heading
.de D-command+
.  ds @sub \$1\"
.  shift 1
.  TP+
.  Text "\f[B]D\*[@sub]\f[]\ \f[I]\,\$*\/\f[]\*[@linebreak]"
.  rm @sub
..
.de Da-command
.  shift 1
.  ie t \
.    ds @args $h sub 1$\~$v sub 1$ $h sub 2$\~$v sub 2$\"
.  el \
.    ds @args \f[I]h1\~v1 h2\~v2\f[]\"
.  IP "\f[B]Da\f[]\ \*[@args]\|\*[@linebreak]"
.  rm @args
..
.c graphics command .D with a variable number of arguments
.c format: .D-multiarg <subcommand>
.de D-multiarg
.  ds @sub \$1\"
.  shift 1
.  ie t \{\
.    ds @args "$h sub 1$\~$v sub 1$ $h sub 2$\~$v sub 2$ .\|.\|. \"
.    as @args "$h sub n$\~$v sub n$\"
.  \}
.  el \
.    ds @args \f[I]h1\~v1 h2\~v2\f[] ... \f[I]\,hn\~vn\f[]\"
.  IP "\f[B]D\*[@sub]\f[]\ \*[@args]\|\*[@linebreak]"
.  rm @args
.  rm @sub
..
.c format: .x-command <subname> "<arguments>"
.de x-command
.  ds @sub \$1\"
.  shift 1
.  ds @args
.  if (\n[.$] > 0) \
.    ds @args \ \f[I]\,\$*\/\f[]\"
.  IP "\f[B]x\*[@sub]\f[]\*[@args]\f[]\|\*[@linebreak]"
.  rm @sub
.  rm @args
..
.de xsub
.  RI "(" "\$1" " control command)"
.  br
..
.ec
.\" End of macro definitions 
.
.
.\" --------------------------------------------------------------------
.\" Title
.\" --------------------------------------------------------------------
.
.TH GROFF_OUT 5 "1 May 2003" "Groff Version 1.19"
.
.SH 名称
groff_out \- groff の中間出力フォーマット
.
.
.\" --------------------------------------------------------------------
.SH 解説
.\" --------------------------------------------------------------------
.
このマニュアルページは、GNU の
.BR roff (7)
テキスト処理システムの中間出力フォーマットについて記述しています。
.
この出力は、デバイスの後処理プログラムに渡される前に、GNU
.BR troff (1)
プログラムの実行によって生成されます。
.
.P
GNU の roff 処理系である
.BR groff (1)
は troff を包むラッパプログラムであり、
この troff は自動的に後処理プログラムを呼び出すため、
通常この出力は目には触れません。
.
そのため、これは
.I groff
.IR システム
において
.I 中間的
と呼ばれます。
.
.B groff
プログラムには後処理を行わないようにする
.B -Z
オプションがあり、このオプションをつけることで
.B troff
を手動で呼び出した時のように
生成された中間出力を標準出力に送ることができます。
.
.P
この文書において、
.I troff 出力
という用語は GNU troff プログラムによる出力を指し、
.I 中間出力
という用語は後処理プログラム用にこの出力を下ごしらえするパーサによって
受け付けられる言語を指します。
.
このパーサは空白をうまく処理し、
また旧式の要素を互換性を保つために実装しています。
それ以外は、どちらの形式も同じものです。
.
groff 以前の版の roff は、
.I 古典的な
.IR troff
と表記されます。
.
.P
中間出力のコンセプトの一番の目的は、すべてのデバイスに対して
共通のプログラミングインタフェースを提供することによって、
後処理プログラムの開発を容易にすることです。
.
これは、
.BR groff (7)
言語とはまったく異なった独自の言語です。
.
.I groff
言語は、テキスト処理用の高レベルなプログラミング言語であるのに対し、
中間出力言語は、文字表示や描画のためにページ上のすべての位置を指定する、
低レベルのアセンブリ言語のような言語です。
.
.P
.I groff
によって生成される中間出力はかなり読みやすいのですが、一方
.I 古典的な troff
の出力は、奇妙な習慣のために理解しづらいものでした。
この習慣は、まだ
.I GNU
.IR troff
でサポートされてはいますが、もう使われていません。
.
.
.\" --------------------------------------------------------------------
.SH "言語のコンセプト"
.\" --------------------------------------------------------------------
.
.BR troff
の実行中に、roff への入力は、指定されたデバイスの
どの位置に何が印字されるのかという情報へと細かく分解されます。
.
したがって、中間出力フォーマットの言語はとても小さなものです。
.
その唯一の要素は、引数あり、もしくは引数なしのコマンドです。
.
この文書中において、「コマンド」という用語は、
文書整形に使われる roff 言語ではなく、常に中間出力言語を指します。
.
これらのコマンドには、テキストの表示や図の描画、デバイスの制御を
行うものがあります。
.
.
.\" --------------------------------------------------------------------
.SS "区切り"
.\" --------------------------------------------------------------------
.
.I 古典的な troff 出力
には、空白に関して奇妙な要求事項があります。
.
しかし
.I groff
出力のパーサは、空白を最大限に省略可能とすることによって、
空白をよりうまく処理します。
.
空白文字、つまり
.IR tab ,
.IR space ,
.I newline
文字は、常に構文上の意味を持ちます。
.
これらの文字は印字可能ではありません。
なぜなら、出力に含まれる空白は、すべて位置コマンドによって
空けられるからです。
.
.P
どの
.I space
や
.I tab
の連続も、1 つの
.B 構文上の
.BR 空白
として扱われます。
.
これによってコマンドと引数とが区切られます。
しかしこれは、コマンドコードとその引数とが、空白がないために
ぶつかり合ってしまう場合のみ必要となります。
.
ほとんどの場合、これは可変長のコマンド名や引数、引数リスト、
コマンド群が一緒に出てきた時に発生します。
.
固定長の既知のコマンドと引数の場合は、
構文上の空白によって区切る必要はありません。
.
.P
改行も構文上の要素です。
.
すべてのコマンド引数の後には、空白やコメント、改行文字を続けることができます。
.
したがって
.B 構文上の改行
は、省略可能な構文上の空白の後に、省略可能なコメントが続き、
これに改行文字が続いたものから構成されると定義されます。
.
.P
位置指定やテキスト用の普通のコマンドは 1 文字から成り、
既定数の引数を取ります。
.
歴史的な理由により、パーサはそれらのコマンドを同じ行に重ねることを
許しています。
しかし幸いなことに、groff の中間出力において、
少なくとも 1 つの引数を持つすべてのコマンドの後には改行が続くので、
非常に読みやすくなっています。
.
.P
その他のコマンド \[em] 描画やデバイス制御用のもの \[em] は、
さらに複雑な構造をしています。
長いコマンド名のものもありますし、可変個の引数を取るものもあります。
.
したがって、すべての
.B D
と
.B x
コマンドには、設計上、最後の引数の後に
.I 構文上の改行
が必要です。
.
ただ 1 つのコマンド
.RB ` x\ X '
だけは、いくつかの行に渡って引数を置くことができますが、
その他のすべてのコマンドは、コマンドと同じ行にすべての引数が
なければなりません。
.
.P
空行、すなわち空白やコメントだけからなる行は、
どこにあっても構いません。
.
それらは単に無視されます。
.
.
.\" --------------------------------------------------------------------
.SS "引数の単位"
.\" --------------------------------------------------------------------
.
コマンドの中には、ある測定単位で表された値とみられるけれど、
.I スケール指示子
に対応する文字が、出力コマンド引数と一緒に書かれていない
整数引数を取るものがあります。
このトピックに関するさらなる情報は、
.BR groff (7)
と groff info ファイルを参照してください。
.
ほとんどのコマンドは、デバイスの基本単位であるスケール指示子\~\c
.unit u
を想定しており、いくつかのコマンドはデバイスの
.I スケールドポイント単位
である\~\c
.unit z
を想定していますが、色コマンドなどの他のコマンドは
単なる整数を期待しています。
.
これらのスケール指示子は、指定されたデバイスに
関連したものであることに注意してください。
.
それらは、デバイスの
.I DESC
ファイルで指定されたパラメータによって定義されています。
.BR groff_font (5)
を参照してください。
.
.P
単一文字は、8 ビット目が設定されていても構いません。
これはフォント名や特殊文字名も同じです。
.
文字名やフォント名は、任意の長さにできます。
.
印刷される文字は、常に現在のフォント中に存在するものです。
.
.P
文字列引数は常に、次に続く空白文字 (空白、タブ、改行) によって終了します。
埋め込まれた
.B #
文字は引数の一部とみなされ、コメントコマンドの始まりとは解釈されません。
.
整数引数は常に、次に続く数字以外の文字によって終了します。
そしてその文字は、次の引数またはコマンドの最初の文字とみなされます。
.
.
.\" --------------------------------------------------------------------
.SS "文書部分"
.\" --------------------------------------------------------------------
正しい中間出力の文書は、導入部と本体の 2 つの部分から構成されます。
.
.P
.I 導入部
の役割は、3 つの正確に指定されたコマンドを用いて、
一般的なデバイスパラメータを設定することです。
.
.I groff の導入部
は、以下の 3 行から (この順番で) 構成されていることが保証されています:
.RS
.P
.B x\ T
.I device
.br
.B x\ res
.I n\ h\ v
.br
.B x init
.RE
.P
この引数の組は、
.BR "デバイス制御コマンド"
の節で概略が説明されています。
.
しかし、中間出力フォーマット用のパーサは、
追加の空白やコメントも同様に受け入れることができます。
.
.P
.I 本体
は、文書データの処理を行う主要な節です。
.
構文上は、導入部で使れたコマンド以外のコマンドが連続したものとなります。
.
処理は、最初の
.B x\ stop
があるとすぐに終了します。
すべての groff 中間出力の最終行には、このコマンドが必ずあります。
.
.P
意味的には、本体はページ指向です。
.
新しいページは
.BR p \~コマンド
によって開始されます。
.
位置指定、文字出力、描画コマンドは、常に現在のページに対して行われます。
ですから、それらのコマンドは最初の
.BR p \~コマンド
の前には現れません。
.
(
.B H
と
.BR V \~コマンド
による) 絶対位置指定は、現在のページに相対的に行われ、
それ以外の位置指定は、現在のページの現在位置に相対的に行われます。
.
.
.\" --------------------------------------------------------------------
.SH "コマンドリファレンス"
.\" --------------------------------------------------------------------
.
この節では、すべての中間出力コマンドや古典的なコマンド、
.I groff
拡張について記述しています。
.
.
.\" --------------------------------------------------------------------
.SS "コメントコマンド"
.\" --------------------------------------------------------------------
.
.TP
.BI # anything \[la]end_of_line\[ra]
コメントです。
.
.BR # \~\c
文字から次の改行文字までのすべての文字を無視します。
.
.P
このコマンドは、中間出力内にコメントを記述する唯一の方法です。
.
それぞれのコメントの前には、任意個の
.I 構文上の
.IR 空白
があっても構いません。
またすべてのコマンドは、コメントによって終了できます。
.
.
.\" --------------------------------------------------------------------
.SS "単純コマンド"
.\" --------------------------------------------------------------------
.
この小節では、1 文字から成り、既定個の引数を取るコマンドを説明しています。
.
そのほとんどは、位置指定とテキスト出力のコマンドです。
.
これらのコマンドは、空白をうまく処理します。
.
状況に応じて、
.I 構文上の空白
は、コマンド文字とその引数の前にも、後にも、
その間にも挿入できます。
.
これらすべてのコマンドは、重ねることができます。
つまり、同じ行に他の単純コマンドが前にあってもいいですし、
他の任意のコマンドが後に続いても構いません。
.
区切りに使われる構文上の空白は、2 つの整数引数が衝突する時や、
前に続く引数が文字列引数で終わる時にのみ必要となります。
.
.
.if (\n[@USE_ENV_STACK] == 1) \{\
.command {
現時点のデバイス設定データを環境スタックにコピーして、
新しい環境を開始します。
.
現在の環境はデバイス仕様書によって設定され、
設定コマンドで操作されます。
.
.
.command }
(前にある
.BR { \~コマンド
で開始された) 現在の環境を終了し、環境スタックから、
以前の環境を現時点のデバイス設定データとして復帰させます。
.
\}              \" endif @USE_ENV_STACK
.
.
.command C xxx \[la]white_space\[ra]
特殊な groff 文字名
.argument xxx
を印字します。
.
任意の長さの文字名を指定可能とするために、
その後には構文上の空白または改行が必要となります。
.
文字は現在の印字位置に印字され、
文字の大きさはフォントファイルから読み込まれます。
.
印字位置は変化しません。
.
.
.command c c
現在の印字位置に、文字\~\c
.argument c
を印字します。
文字の大きさはフォントファイルから読み込まれます。
.
印字位置は変化しません。
.
.
.command f n
フォントをフォント番号\~\c
.argument n
(非負整数) に設定します。
.
.
.command H n
現在のページの左端から絶対水平位置\~\c
.argument n
(非負整数、単位は基本単位\~\c
.unit u )
に移動します。
.
.
.command h n
水平方向、右に、基本単位\~\c
.unit u
で
.argument n
(非負整数)
だけ移動します。
.
.I [54]
では
.I n
に負の値も指定できますが、
.I groff
ではこれは使用していません。
.
.
.command m "color_scheme \f[R][\f[]component .\|.\|.\f[R]]\f[]"
異なるカラースキームを用いて、テキスト (グリフ) や線図、
図形オブジェクトの輪郭の色を設定します。
これと類似した、図形オブジェクトを色で塗り潰すためのコマンドは
.BR DF
です。
.
色の成分は、0 から \n[@maxcolor] までの整数で指定します。
.
色の成分数とその意味は、カラースキームによって異なります。
.
これらのコマンドは、groff のエスケープシーケンス
.BR \*[@backslash]m
によって生成されます。
.
これによって位置は変更されません。
.
これらのコマンドは groff 拡張です。
.
.
.RS
.
.command mc "cyan magenta yellow"
シアン、マゼンタ、黄の 3 つの色の成分を持つ CMY カラースキームを用いて、
色を設定します。
.
.
.command md
デフォルトの色の値 (ほとんどの場合、黒) に設定します。
.
成分引数はありません。
.
.
.command mg "gray"
0 (黒) から \n[@maxcolor] (白) までの整数引数を指定して、
灰色の色調に設定します。
.
.
.command mk "cyan magenta yellow black"
シアン、マゼンタ、黄、黒の 4 つの色の成分を持つ CMYK カラースキームを
用いて、色を設定します。
.
.command mr "red green blue"
赤、緑、黄の 3 つの色の成分を持つ RGB カラースキームを用いて、
色を設定します。
.
.RE
.
.
.command N n
現在のフォントのインデックス\~\c
.argument n
(整数、通常は非負) を持つ文字を印字します。
.
.B \-T\~html
が使用された場合、指定された幅の改行されない空白を指示するために、
負の値も使用されます。
.
例えば
.B N\~-193
は、193u の幅を持つ改行されない空白を表します。
.
印字位置は変更しません。
.
このコマンドは groff 拡張です。
.
.
.command n b\ a
デバイスに対して改行を通知しますが、
このコマンドによって位置は指定されません。
.
古典的な troff では、何の動作も起こさせずに中間出力を
もっと人に読みやすくするために、整数引数
.argument b
と
.argument a
によって、現在行の前 (before) と後 (after) の空白を通知していました。
.
groff では、これらの引数は単に無視されます。
しかし、これらは互換性のために提供されなければなりません。
.
.
.command p n
出力において、新しいページを開始します。
.
ページ番号は、
.argument n
によって設定されます。
.
このページは、それまでに処理されたページとは完全に独立しています。
たとえそれが同じページ番号を持っていたとしてもです。
.
出力の垂直位置は、自動的に 0 に設定されます。
.
すべての位置指定やテキストの表示、図の描画は、
常にページと相対的に行われます。
したがって
.BR p
コマンドは、これらのコマンドの前に発行されなければなりません。
.
.
.command s n
ポイントの大きさを
.argument n
スケールドポイント (GNU
.BR troff
では、単位は
.unit z
) に設定します。
.
古典的な troff は、かわりに単位として
.I ポイント
(\c
.unit p )
を使っていました。
.BR 互換性
の節を参照してください。
.
.
.command t xxx \[la]white_space\[ra]
.command+ t "xxx dummy_arg" \[la]white_space\[ra]
単語、すなわち空白文字もしくは改行によって終了する連続した文字
.argument xxx
を印字します。
省略可能である 2 つ目の整数引数は無視されます
(これによってフォーマッタは、偶数個の引数を生成することができます)。
.
最初の文字は現在位置に印字され、現在の水平位置は最初の文字の幅だけ
ずらされます。
同様にして、それぞれの文字も処理されます。
.
文字幅はフォントファイルから読み込まれ、現在のポイントの大きさで
拡大された後、水平解像度の倍数に丸められます。
.
特殊文字はこのコマンドを用いて印字できません (名前付き文字の印字には
.B C
コマンドを使用してください)。
.
このコマンドは groff 拡張です。
これは
.I DESC
ファイルに
.B tcommand
キーワードを含んでいるデバイスに対してのみ使用されます。
.BR groff_font (5)
を参照してください。
.
.
.command u "n xxx" \[la]white_space\[ra]
トラックカーニングを行いながら単語を印字します。
.
これは
.B t
コマンドと同じですが、現在の水平位置が文字幅と
.argument n
(整数、単位は基本単位\~\c
.unit u )
との和だけずらされるところが異なります。
このコマンドは groff 拡張です。
これは
.I DESC
ファイルに
.B tcommand
キーワードを含んでいるデバイスに対してのみ使用されます。
.BR groff_font (5)
を参照してください。
.
.
.command V n
現在のページの上端から絶対垂直位置\~\c
.argument n
(非負整数、単位は基本単位\~\c
.unit u )
に移動します。
.
.
.command v n
下に、基本単位\~\c
.unit u
で
.argument n
(非負整数)
だけ移動します。
.
.I [54]
では
.I n
に負の値も指定できますが、
.I groff
ではこれは使用していません。
.
.
.command w
可読性を上げるためのパディングの空白について通知します。
.
字間、行間指定自体は、移動コマンドによって明示的に行われなければなりません。
.
.
.\" --------------------------------------------------------------------
.SS "図形コマンド"
.\" --------------------------------------------------------------------
.
中間出力内のそれぞれの図形コマンドまたは描画コマンドは、文字\~\c
.B D
で始まり、その後にサブコマンドを表す 1 つもしくは 2 つの
文字が続きます。
さらにその後には、単一の空白文字で区切られた既定個もしくは
可変個の整数引数が続きます。
.
.BR D \ コマンド
は、同じ行に (コメント以外の) 他のコマンドが続いてはいけません。
したがって、それぞれの
.BR D \ コマンド
は構文上の改行で終了します。
.
.P
.I troff
出力は、古典的な空白挿入の規則に従います
(コマンドとサブコマンド間には空白を入れず、
すべての引数の前には空白を入れます)。
しかしパーサは、コマンド文字間に空白を入れることを許していますし、
最初の引数の前の空白を省略可能にしています。
.
いつもと同様に、それぞれの空白は、
タブ文字と空白文字の任意の連続で構いません。
.
.P
図形コマンドには、可変個の引数を取るものがあります。
.
この場合、それらは基本単位\~\c
.unit u
を単位とした大きさを表す整数です。
.
.list1..n h
と呼ばれる引数は、水平方向の距離を表しています。
正の値は右を、負の値は左を意味しています。
.
.list1..n v
と呼ばれる引数は、垂直方向の距離を表しています。
正の値は下を、負の値は上を意味しています。
.
これらの距離はすべて、現在位置からの相対的なオフセットです。
.
.P
特に記述がなければ、それぞれの図形コマンドは、
.I groff
の同様の
.B \*[@backslash]D
エスケープシーケンスに直接対応しています。
.BR groff (7)
を参照してください。
.
.P
不明な D\~コマンドは、デバイス固有のコマンドとみなされます。
.
その引数は文字列としてパースされ、
その情報はまるごと後処理プログラムに送られます。
.
.P
以下のコマンドリファレンスでは、構文要素
.I \[la]line_break\[ra]
は、
.BR 区切り
の節で定義された
.I 構文上の改行
を意味しています。
.
.
.D-multiarg ~
現在位置からオフセット
.indexed_offset h 1 v 1
を通り、指定されていたら
.indexed_offset h 2 v 2
を通り、
.indexed_offset h n v n
までの B スプライン曲線を描画します。
このコマンドは、可変個の引数のペアを取ります。
現在位置は描画された曲線の最終点に移動します。
.
.
.Da-command
.indexed_offset h 1 v 1
を中心として、現在位置から
.indexed_offset h 1 v 1 \|+\|\c
.indexed_offset h 2 v 2
までの円弧を描画します。
現在位置は円弧の最終点に移動します。
.
.
.D-command C d
.D-command+ C d dummy_arg
現在位置を最左端とする、半径\~\c
.argument d
(整数、単位は基本単位\~\c
.unit u )
の塗り潰された円を、現在の塗り潰し色で描画します。
現在位置は円の最右端に移動します。
.
省略可能である 2 つめの整数引数は無視されます
(これによってフォーマッタは、偶数個の引数を生成することができます)。
.
このコマンドは groff 拡張です。
.
.
.D-command c d
現在位置を最左端とする、半径\~\c
.argument d
(整数、単位は基本単位\~\c
.unit u )
の円を、線で描画します。
現在位置は円の最右端に移動します。
.
.
.D-command E "h v"
現在位置を最左端とする、水平半径\~\c
.argument h
と垂直半径\~\c
.argument v
(どちらも整数、単位は基本単位\~\c
.unit u )
の塗り潰された楕円を、現在の塗り潰し色で描画します。
現在位置は楕円の最右端に移動します。
.
このコマンドは groff 拡張です。
.
.
.D-command e "h v"
現在位置を最左端とする、水平半径\~\c
.argument h
と垂直半径\~\c
.argument v
(どちらも整数、単位は基本単位\~\c
.unit u )
の楕円の輪郭を描画します。
現在位置は楕円の最右端に移動します。
.
.
.D-command F "color_scheme \f[R][\f[]component .\|.\|.\f[R]]\f[]"
異なるカラースキームを用いて、塗り潰された描画オブジェクト用の
塗り潰し色を設定します。
これと類似した、
テキストや線図、図形オブジェクトの輪郭の色を設定するコマンドは
.BR m
です。
.
色の成分は、0 から \n[@maxcolor] までの整数で指定します。
.
色の成分数とその意味は、カラースキームによって異なります。
.
これらのコマンドは、groff のエスケープシーケンス
.B \*[@backslash]D'F\ .\|.\|.'
と
.B \*[@backslash]M
(他の対応する図形コマンドがない場合)
によって生成されます。
.
これによって位置は変更されません。
.
このコマンドは groff 拡張です。
.
.
.RS
.
.D-command Fc "cyan magenta yellow"
シアン、マゼンタ、黄の 3 つの色の成分を持つ CMY カラースキームを用いて、
塗り潰された描画オブジェクト用の塗り潰し色を設定します。
.
.
.D-command Fd
塗り潰された描画オブジェクト用の塗り潰し色を、
デフォルトの色の値 (ほとんどの場合、黒) に設定します。
.
成分引数はありません。
.
.
.D-command Fg "gray"
0 (黒) から \n[@maxcolor] (白) までの整数引数を指定して、
塗り潰された描画オブジェクト用の塗り潰し色を、灰色の色調に設定します。
.
.
.D-command Fk "cyan magenta yellow black"
シアン、マゼンタ、黄、黒の 4 つの色の成分を持つ CMYK カラースキームを
用いて、塗り潰された描画オブジェクト用の塗り潰し色を設定します。
.
.D-command Fr "red green blue"
赤、緑、黄の 3 つの色の成分を持つ RGB カラースキームを用いて、
塗り潰された描画オブジェクト用の塗り潰し色を設定します。
.
.RE
.
.
.D-command f n
引数
.argument n
は、-32767 から 32767 までの整数でなければなりません。
.
.RS
.TP
.RI "0 \[<=] " n " \[<=] 1000"
塗り潰された描画オブジェクト用の塗り潰し色を、灰色の色調に設定します。
ここで 0 は塗り潰された白に対応し、1000 (デフォルト) は
塗り潰された黒に対応します。
この間の値は、中間的な灰色の色調に対応します。
これは、コマンド
.BR DFg
によって旧式のものとなっています。
.
.TP
.IR n " < 0 or " n " > 1000"
塗り潰された描画オブジェクト用の塗り潰し色を、
現在、テキストや輪郭に使われている色に設定します。
コマンド
.BR m
を参照してください。
例えば、コマンド列
.
.nf
.ft CB
.RS
.RS
mg 0 0 \n[@maxcolor]
Df -1
.RE
.ft
.fi
.
は、すべての色を青に設定します。
.RE
.
.P
これによって位置は変更されません。
.
このコマンドは groff 拡張です。
.
.RE
.
.
.D-command l "h v"
現在位置からオフセット
.offset h v
(整数、単位は基本単位\~\c
.unit u )
まで線を引きます。
現在位置は描画した線の最終点に移動します。
.
.
.D-multiarg p
現在位置からオフセット
.offset h1 v1
を通り、
.offset h2 v2
を通り、
.offset hn vn
を通って最初の点に戻るような多角形を、線で描画します。
.
.ie (\n[@STUPID_DRAWING_POSITIONING] == 1) \{\
歴史的な理由により、位置は、奇数番目の引数の和を水平位置に、
偶数番目の引数の和を垂直位置に加算したところに移動します。
.
これは理にかなったものではありませんが、
互換性のためにそのままになっています。
.
\}
.el \{\
多角形は閉じられるため、描画の最終点は開始点となります。
したがって位置は変更されません。
\}
.
このコマンドは groff 拡張です。
.
.
.D-multiarg P
対応する
.B Dp
コマンドと同じ引数を持つ同様のマクロですが、
多角形の外枠を描画するのではなく、塗り潰された多角形を描画します。
.
.ie (\n[@STUPID_DRAWING_POSITIONING] == 1) \{\
位置は
.BR Dp
と同様に変更されます。
\}
.el \
位置は変更されません。
.
このコマンドは groff 拡張です。
.
.
.D-command t n
.argument n >0
の場合、現在の線幅を\~\c
.argument n
(整数、単位は基本単位\~\c
.unit u )
に設定します。
.argument n =0
の場合、線幅を可能な最小の細さに設定します。
.argument n <0
の場合、線幅をポイントサイズに比例するようにします
(これは、最初に
.B Dt
コマンドが指定されるまでのデフォルトです)。
.
.ie (\n[@STUPID_DRAWING_POSITIONING] == 1) \{\
垂直位置は変更されませんが、歴史的な理由により水平位置は、
引数を実際の水平位置に足したところに変更されます。
.
これは理にかなったものではありませんが、
互換性のためにそのままになっています。
.
\}
.el \
位置は変更されません。
.
このコマンドは groff 拡張です。
.
.
.\" --------------------------------------------------------------------
.SS "デバイス制御コマンド"
.\" --------------------------------------------------------------------
.
各々のデバイス制御コマンドは、文字
.B x
で始まり、ひとつの空白文字
(groff では省略可能であり、任意個の空白やタブも使えます) と
サブコマンドの文字または単語が続きます。
(もし引数がある場合) それぞれの引数の前には、構文上の空白が
なければなりません。
.
すべての
.B x
コマンドは
.IR "構文上の改行"
によって終了します。
デバイス制御コマンドの後には、(コメントを除いて) 同じ行に
他のコマンドが続いてはなりません。
.
.P
サブコマンドは基本的に 1 文字ですが、
読みやすくするために 1 語で書く事もできます。
つまり次のタブ、空白、改行文字で終了する任意の文字列を
使用する事ができます。
.
サブコマンドの単語に含まれる最初の文字以外のすべての文字は、
単に無視されます。
.
例えば
.I troff
は初期化コマンド
.B x\ i
として
.B x\ init
を、解像度コマンド
.B x\ r
として
.BR "x\ res"
を出力します。
.
しかし、
.B x\ i_like_groff
や
.B x\ roff_is_groff
resp.\& のような記述も、同様に同じコマンドとして受け付けられます。
.
.P
以下では、構文要素
.I \[la]line_break\[ra]
は、
.BR 区切り
の節で定義された
.I 構文上の改行
を意味しています。
.
.x-command F name
.xsub Filename
.argument name
を、現在のファイルに対して指定した名前として、エラーレポート中で使用します。
.
これは、groff が内部的なパイプ機構を使用している場合、
元のファイル名を記憶しておくのに役に立ちます。
.
入力ファイルは、このコマンドで変更されません。
.
このコマンドは groff 拡張です。
.
.
.x-command f "n\ s"
.xsub font
フォント位置\~\c
.argument n
(非負整数) に、フォント名\~\c
.argument s
(テキストの 1 単語) のフォントを組み込みます。
.BR groff_font (5)
を参照してください。
.
.
.x-command H n
.xsub Height
文字の高さを
.argument n
(正整数、単位はスケールドポイント\~\c
.unit z ) に設定します。
.
古典的な troff は、かわりに単位としてポイント (\c
.unit p )
を使用していました。
.BR 互換性
の節を参照してください。
.
.
.x-command i
.xsub init
デバイスを初期化します。
.
これは、導入部の 3 番目のコマンドです。
.
.
.x-command p
.xsub pause
解釈されますが、無視されます。
.
古典的な文書には、「
.I デバイスを停止します。
.IR リスタート
.I できます
」とあります。
.
.
.x-command r "n\ h\ v"
.xsub resolution
.argument n
は解像度を表し、
.argument h
はそのデバイスの最小水平移動量、
.argument v
は最小垂直移動量を表します。
すべての引数は正整数で、単位は 1 インチ当たりの基本単位\~\c
.unit u
です。
.
これは、導入部の 2 番目のコマンドです。
.
.
.x-command S n
.xsub Slant
傾斜を
.argument n
度 (整数、単位は基本単位\~\c
.unit u )
に設定します。
.
.
.x-command s
.xsub stop
現在のファイルの処理を終了します。
すべての troff 中間出力の最後のコマンドとして発行されます。
.
.
.x-command t
.xsub trailer
もしあれば、トレイラ情報を生成します。
.
.IR groff
では、実際には単に無視されます。
.
.
.x-command T xxx
.xsub Typesetter
デバイスの名前を
.argument xxx
に設定します。
これは後に続く空白文字で終了する文字列です。
.
可能なデバイス名は、groff の
.B -T
オプションのものと同じです。
.
これは、導入部の最初のコマンドです。
.
.
.x-command u n
.xsub underline
スペースの下線を設定します。
.
.argument n
が 1 の場合、スペースの下線を引き始め、
.argument n
が 0 の場合、スペースの下線を終了します。
.
これは
.I nroff
モードにおける
.B cu
リクエストに必要であり、その他の場合は無視されます。
.
このコマンドは groff 拡張です。
.
.
.x-command X anything
.xsub X-escape
文字列
.argument anything
を解釈せずにデバイスに送ります。
.
後に続く行が
.B +
文字で始まっている場合、その行は継続行として以下のように解釈されます。
.
.B +
は無視され、かわりに改行文字がデバイスに送られます。
そして、行の残りは解釈されずに送られます。
.
同様にして、最初の文字が
.B +
文字でない行まで、後に続くすべての行に適用されます。
.
このコマンドは
.I groff
エスケープシーケンスである
.BR \*[@backslash]X
によって生成されます。
.
この行の継続機能は groff 拡張です。
.
.
.\" --------------------------------------------------------------------
.SS "旧式のコマンド"
.\" --------------------------------------------------------------------
.
.I 古典的な troff
の出力では、ほとんどの場合、水平移動と 1 文字の印字とが組合わさった
とても奇妙なコマンドを用いて、1 文字の出力が行われます。
.
このコマンドにはコマンドコードがなく、厳密に 2 つの数字と
1 つの文字からなる、3 文字の引数によって表現されます。
.
.TP
.argument ddc
右へ、基本単位\~\c
.unit u
で
.argument dd
(厳密に 2 桁の 10 進数) だけ移動し、
文字\~\c
.argument c
を印字します。
.
.RS
.P
groff では、このコマンドの前後や中に、任意個の構文上の空白を
入れることができます。
.
唯一、同じ行の前にあるコマンドが可変長の引数を持っている場合にのみ、
区切りの空白が必須となります。
.
.I 古典的な
.IR troff
では、これらのコマンドやその他のコマンドの大きなかたまりが、
ほとんどの場合空白なしに使用されていました。
そのためこのような出力は、ほとんど解読不能でした。
.
.RE
.
.P
現代の高解像度デバイスにとって、このコマンドは理にかなったものではありません。
というのは、文字の移動幅が 2 桁の 10 進数で表現できないほど
大きくなり得るからです。
.
groff では、これらは以下のデバイスでのみ使用されます。
.BR X75 ,
.BR X75-12 ,
.BR X100
そして
.BR X100-12
。
.
その他のデバイスには、
コマンド
.B t
と\~\c
.B u
が、より適した機能を提供します。
.
.
.\" --------------------------------------------------------------------
.SH "後処理"
.\" --------------------------------------------------------------------
.
.I roff
の後処理プログラムは、中間出力を、
デバイスに送られる「作用」に変換する働きを持つプログラムです。
.
デバイスは、プリンタのようなハードウェアでもいいですし、あるソフトウェアの、
画像またはテキスト処理に適したファイル形式でも構いません。
.
.I groff
の処理系は、これらの後処理プログラムの作成が簡単になるような、
強力な手法を提供しています。
.P
それぞれのデバイスに共通のインタフェースを持つクラスのメソッドを介して、
中間出力をパースしたり、得られた情報をデバイスに送るライブラリ関数が
あります。
.
.I groff
の後処理プログラムがしなければならないのは、
このクラスのメソッドを再定義することだけです。
.
詳細は、
.BR 関連ファイル
節のリファレンスを参照してください。
.
.
.\" --------------------------------------------------------------------
.SH "使用例"
.\" --------------------------------------------------------------------
.
この節では、同一の入力から 3 つの異なるデバイス用に生成された中間出力を
示します。
.
この入力は、コマンドラインから groff に与えた
.I hell world
という文です。
.
.Topic
高解像度デバイス
.I ps
.
.RS
.
.P
.ShellCommand echo "hell world" | groff -Z -T ps
.
.P
.nf
.ft CB
x T ps
x res 72000 1 1
x init
p1
x font 5 TR
f5
s10000
V12000
H72000
thell
wh2500
tw
H96620
torld
n12000 0
x trailer
V792000
x stop
.ft P
.fi
.RE
.
.P
この出力を後処理プログラム
.BR grops (1)
に与えることで、その PostScript ファイル形式が得られます。
.
.
.Topic
低解像度デバイス
.I latin1
.
.RS
.
.P
これは、位置指定が小さなスケールで行われることを除いて、
高解像度デバイスの時と同じです。
.
いくつかのコメント (
.IR #
で始まる行) は、意味を明確にするために追加しました。
これらはフォーマッタによって生成されたものではありません。
.
.P
.ShellCommand echo "hell world" | groff -Z -T latin1
.
.P
.nf
.I # 導入部
.ft CB
x T latin1
x res 240 24 40
x init
.I # 新しいページの開始
.ft CB
p1
.I # フォントの設定
.ft CB
x font 1 R
f1
s10
.I # ページの初期位置指定
.ft CB
V40
H0
.I # テキスト 'hell' の出力
.ft CB
thell
.I # 空白を通知し、それを水平ジャンプによって行います
.ft CB
wh24
.I # テキスト `world' の出力
.ft CB
tworld
.I # 改行を通知します。しかし何もしません。なぜなら ...
.ft CB
n40 0
.I # ... 文書の終りに達したからです。
.ft CB
x trailer
V2640
x stop
.ft P
.fi
.RE
.
.P
この出力を後処理プログラム
.BR grotty (1)
に与えることで、整形されたテキスト文書が得られます。
.
.
.Topic
古典的形式の出力
.
.RS
.
.P
現在のプリンタに比べて、コンピュータのモニタはとても解像度が低いので、
X のデバイスへの中間出力には、2 桁の数字の移動量を伴う
飛び書き (jump-and-write) コマンドが使用できます。
.
.P
.ShellCommand echo "hell world" | groff -Z -T X100
.
.P
.nf
.ft CB
x T X100
x res 100 1 1
x init
p1
x font 5 TR
f5
s10
V16
H100
.I # 旧式の飛び書きコマンドでテキストを出力
.ft CB
ch07e07l03lw06w11o07r05l03dh7
n16 0
x trailer
V1100
x stop
.ft P
.fi
.RE
.
.P
この出力を後処理プログラム
.BR xditview (1x)
や
.BR gxditview (1)
に与えることで、X に表示することができます。
.
.P
旧式の飛び書きコマンドのために、古典的な出力中のテキスト群は、
ほとんど解読不能です。
.
.
.\" --------------------------------------------------------------------
.SH "互換性"
.\" --------------------------------------------------------------------
.
.I 古典的な troff
の中間出力言語は、
.IR [97]
で初めて文書化されました。
.
.I groff
の中間出力フォーマットは、以下の特徴を除いてこの仕様書と互換性があります。
.Topic
古典的な準デバイス非依存性は、まだ実装されていません。
.
.Topic
古いハードウェアは、現在我々が使用しているものとは非常に異なっています。
.
そのため、groff のデバイスも、古典的な troff のものと基本的に異なっています。
.
例えば、古典的な PostScript デバイスは
.I post
と呼ばれており、1 インチ当たり 720 単位の解像度を持っていました。
一方 groff の
.I ps
デバイスは、1 インチ当たり 72000 単位の解像度を持っています。
.
おそらく古典的な準デバイス非依存性に似た、スケールしなおす機構を
実装すれば、これらは現代の groff に統合することができるかもしれません。
.
.Topic
B スプラインコマンド
.B D~
は中間出力のパーサによって正しく扱われますが、
いくつかの後処理プログラムには描画ルーチンが実装されていません。
.Topic
groff では、コマンド
.B s
と
.B x H
の引数の単位は、暗黙的にスケールドポイント\~\c
.unit z
ですが、古典的な troff の単位はポイント (\c
.unit p )
です。
.
これは非互換なのではなく、互換性のある拡張です。
というのも、古典的なテキストデバイスや groff のテキストデバイスを含む
すべてのデバイスにおいて、
.I sizescale
パラメータなしでどちらの単位も一致するからです。
.
sizescale パラメータを持つ数少ない groff のデバイスも、
存在しないか、違う名前をしているか、異なる解像度を持っているように見えます。
.
したがって、古典的なデバイスとの衝突はほとんど起こらないでしょう。
.
.ie (\n[@STUPID_DRAWING_POSITIONING] == 1) \{\
.Topic
コマンド
.BR Dp ,
.BR DP ,
.B Dt
の後に発生する位置の変更は非論理的ですが、古いバージョンの groff が
この機能を使用しているので、互換性のために残してあります。
.\}             \" @STUPID_DRAWING_POSITIONING
.el \{\
.Topic
groff 拡張である
.B D
コマンドの後の位置に、一時、多少の混乱がありました。
.
この混乱は、すべての groff の描画コマンドに対して古典的な規則を
確立することにより明確にされました。
.
.RS
.P
.I 図形オブジェクトが描画された後の位置は、そのオブジェクトの終端です。
.I 円や楕円の「終端」は右端です。
.RE
.
.P
この規則によって、上記の描画コマンドに対して指定される位置は、
とても自然になりました。
.\}             \" @STUPID_DRAWING_POSITIONING
.
.P
groff と古典的な troff との違いは、
.BR groff_diff (7)
に文書化されています。
.
.
.\" --------------------------------------------------------------------
.SH "関連ファイル"
.\" --------------------------------------------------------------------
.
.TP
.BI /usr/share/groff_font/dev name /DESC
デバイス
.IR name
用のデバイス記述ファイルです。
.
.TP
.IB \[la]groff_source_dir\[ra] /src/libs/libdriver/input.cpp
中間出力のパーサと後処理プログラムを定義しています。
.
このファイルは、
.I groff
ソースツリーのトップディレクトリ (例えば
.IR @GROFFSRCDIR@
) から相対的に置かれます。
.
このパーサは、
.I groff
の中間出力フォーマットの最終的な仕様書となります。
.
.
.\" --------------------------------------------------------------------
.SH "関連項目"
.\" --------------------------------------------------------------------
.
.BR groff (7)
のような表記は、マニュアルページを指しています。
これは、man-page 文書システムのセクション\~\c
.I 7
にある
.I groff
を指しています。
.
この例のマニュアルページを読む場合は、デスクトップのヘルプシステムの
セクション\~7 を探すか、シェルプロンプトから以下のように呼び出してください。
.
.RS
.P
.ShellCommand man 7 groff
.RE
.
.P
詳細は
.BR man (1)
を参照してください。
.
.TP
.BR groff (1)
オプション
.B -Z
についてと、groff のさらなる読み物。
.
.TP
.BR groff (7)
数値の単位やエスケープシーケンスのような
.I groff
言語の詳細について。
.
.TP
.BR groff_font (5)
.B DESC
ファイルのデバイススケールパラメータの詳細について。
.
.TP
.BR troff (1)
デバイス非依存の中間出力を生成します。
.
.TP
.BR roff (7)
歴史的な側面と、roff システムの一般的な構造について。
.
.TP
.BR groff_diff (7)
groff の中間出力と古典的な troff の中間出力との違いについて。
.
.P
.BR \%grodvi (1),
.BR \%grohtml (1),
.BR \%grolbp (1),
.BR \%grolj4 (1),
.BR \%grops (1),
.BR \%grotty (1)
.br
.RS
groff の後処理プログラム。
.RE
.
.P
1 つの文書で groff システムのすべての側面を扱っているものとしては、
.I groff info
.IR ファイル
を参照してください。
.
これは統合されたヘルプシステムで読むことができ、
.BR emacs (1)
の中で、もしくはシェルプロンプトから以下のようにして参照できます。
.
.RS
.ShellCommand info groff
.RE
.
.P
.I 古典的な troff の出力言語
は、AT&T ベル研究所の 2 つの CSTR 文書に記述されており、
.URL http://\:cm.bell-labs.com/\:cm/\:cs/\:cstr.html \
     "ベル研究所の CSTR のサイト"
から、オンラインで入手できます。
.
.TP
.I [CSTR #97]
.I Brian Kernighan
によって書かれた
.I A Typesetter-independent TROFF
は、出力言語に関する最初の文書であり、最も簡潔なものです。
.URL http://\:cm.bell-labs.com/\:cm/\:cs/\:cstr/\:97.ps.gz CSTR\~#97
を参照してください。
.
.TP
.I [CSTR\~#54]
.I J.\& F.\& Osanna
と
.I Brian Kernighan
によって書かれた 1992 年版の
.I Nroff/\:Troff User's Manual
は、出力言語に関しては
.I [CSTR\~#97]
ほど簡潔ではありません。
.URL http://\:cm.bell-labs.com/\:cm/\:cs/\:cstr/\:54.ps.gz CSTR\~#54
を参照してください。
.
.
.\" --------------------------------------------------------------------
.SH "作者"
.\" --------------------------------------------------------------------
.
Copyright (C) 1989, 2001, 2002, 2003 Free Software Foundation, Inc.
.P
この文書は、FDL (GNU Free Documentation License) バージョン 1.1 か
それ以降のものに基づいて配布されています。
.
あなたは、このパッケージとともに FDL のコピーを受け取っているはずですが、
これは
.URL http://\:www.gnu.org/\:copyleft/\:fdl.html "GNU のコピーレフトのサイト"
からもオンラインで入手可能です。
.
.P
この文書は GNU の roff ディストリビューションである
.IR groff
の一部です。
.
これは、出力言語の
.I groff
拡張部分のみを記述した以前の版 \- GPL にて公開 \- に基づいています。
.
これは 2002 年に
.MTO bwarken@mayn.de "Bernd Warken"
によって書き直され、
.MTO wl@gnu.org "Werner Lemberg"
によって保守されています。
.
.\" --------------------------------------------------------------------
.\" Emacs settings
.\" --------------------------------------------------------------------
.\"
.\" Local Variables:
.\" mode: nroff
.\" End:
