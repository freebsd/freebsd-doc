.\" Copyright (c) 1987, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Symmetric Computer Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgment:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)disklabel.5.5	8.1 (Berkeley) 6/5/93
.\" %FreeBSD: src/sbin/disklabel/disklabel.5,v 1.5.2.1 1999/08/29 15:12:44 peter Exp %
.\"
.\" jpman %Id: disklabel.5,v 1.3 1998/06/12 15:48:23 kumano Stab %
.\"
.\" WORD: initial bootstrap	初期ブートストラップ
.\" WORD: initial label		初期ラベル
.\" WORD: primary bootstrap	一次ブートストラップ
.\" WORD: secondary bootstrap	二次ブートストラップ
.\" WORD: ratio of physical sectors traversed per logical sector 論理セクタあたりの物理セクタ通過率
.\"
.Dd June 5, 1993
.Dt DISKLABEL 5
.Os
.Sh 名称
.Nm disklabel
.Nd ディスクパックラベル
.Sh 書式
.Fd #include <sys/disklabel.h>
.Sh 解説
システム上のそれぞれのディスクやディスクパックは、ディスクのジオメトリ
やディスクを分割しているパーティションについての詳細な情報を提供する
ディスクラベルを持っています。
ディスクラベルはディスクがフォーマットされたときに
初期化されなければならず、
後から
.Xr disklabel 8
プログラムによって変更することができます。
システムディクスドライバやブートストラッププログラムがこの情報を使って、
ドライブのプログラム方法や、ディスクパーティション上の
ファイルシステムの見つけ方を決定します。
ファイルシステムは、付加的な情報を使ってディスクを最も効果的に使い、
重要なファイルシステム情報の位置を特定します。
各パーティションの記述は、パーティションタイプ(標準ファイル、スワップ
領域等)の識別子を含みます。
ラベルのメモリ内コピーにあるファイルシステム情報が不完全な場合には、
ファイルシステムはそれを更新します。
.Pp
ラベルは、ドライブのセクタ番号
.Dv LABELSECTOR
にあります。
通常は、ディスクジオメトリについての情報がなくても見つけられる、
セクタ 0 にあります。
ラベルは、初期ブートストラップの場所を確保するために、
セクタの先頭からオフセット
.Dv LABELOFFSET
にあります。
ラベルを含むディスクセクタは、通常読み込み専用になっています。
これは、
パックからパックへの複写やスワップ操作時に
.Xr disklabel 8
プログラムによって必要に応じて行なわれる
.Dv DIOCWLABEL
.Xr ioctl 2
により不用意に上書きされないようにするためです。
.Pp
ディスクのメモリ内ラベルコピーは
.Dv DIOCGDINFO
.Xr ioctl 2
で得られます。
この操作は、ディスクの任意のパーティションに対するブロックデバイスや
キャラクタ (``raw'') デバイスへのファイル記述子に対して
行うことができます。
また、ディスクのメモリ内ラベルコピーは
.Dv DIOCSDINFO
.Xr ioctl 2
によりセットされます。
パーティションのオフセットは、一般にパーティションがオープンされている
ときには変更したり小さくしたりはできません。
ただし例外として、ディスクにラベルが見つからず、ドライバが
パーティション情報を含まない骨組みのラベルだけを構築できるときには、
どんな変更も許されます。
最後に、
.Dv DIOCWDINFO
.Xr ioctl 2
操作がメモリ内のラベルをセットし、ディスク上のラベルを更新します。
この操作が成功するためにはディスク上にラベルが存在しなければなりません。
つまり、ディスクやディスクパックの初期ラベルは生の (raw) ディスクに
対して書き込むことでインストールされなければなりません。
これらの操作はすべて、普通
.Xr disklabel 8
コマンドを使って行なわれます。
.Pp
.Pa <sys/disklabel.h>
で指定されるようにディスクラベルのフォーマットは以下のようになります。
.Bd -literal
/*
* ディスク記述テーブル, disktab(5) を参照
*/
#define	DISKTAB		"/etc/disktab"

/*
* 各ディスクはハードウェアディスクジオメトリ、ファイルシステムパーティション、
* ドライブ固有の情報についての情報を含むラベルを持っています。
* ラベルはブロック 0 か 1 、つまりブートストラップ等のための場所を空けて
* なるべく先頭のオフセットにあります。
*/

#ifndef	LABELSECTOR
#define LABELSECTOR	0			/* ラベルを含むセクタ */
#endif

#ifndef	LABELOFFSET
#define LABELOFFSET	64			/* セクタ内のラベルのオフセット */
#endif

#define DISKMAGIC	((u_long) 0x82564557)	/* ディスクのマジックナンバ */
#ifndef MAXPARTITIONS
#define	MAXPARTITIONS	8
#endif

#ifndef LOCORE
struct disklabel {
	u_long	d_magic;	/* マジックナンバ */
	short	d_type;		/* ドライブタイプ */
	short	d_subtype;	/* コントローラ/d_type に固有 */
	char	d_typename[16];	/* タイプ名、たとえば "eagle" */
	/* 
	* d_packname は、パック識別子を含み、ディスク上やメモリ内コピーの
	* ディスクラベルを読んだときに返されます。
	* d_boot0 と d_boot1 は、/boot にある一次 (block 0) または
	* 二次 (block 1-15) ブートストラップの (省略可能な) 名前です。
	* この名は、/etc/disktab から値を取り出すために getdiskbyname(3)
	* を使う場合に返されます。
	*/
#if defined(KERNEL) || defined(STANDALONE)
	char	d_packname[16];		/* パック識別子 */ 
#else
	union {
		char	un_d_packname[16];	/* パック識別子 */ 
		struct {
			char *un_d_boot0;	/* 一次ブートストラップ名 */
			char *un_d_boot1;	/* 二次ブートストラップ名 */
		} un_b; 
	} d_un; 

#define d_packname	d_un.un_d_packname
#define d_boot0		d_un.un_b.un_d_boot0
#define d_boot1		d_un.un_b.un_d_boot1
#endif	/* ! KERNEL or STANDALONE */

	/* ディスクジオメトリ */
	u_long	d_secsize;	/* セクタあたりのバイト数 */
	u_long	d_nsectors;	/* トラックあたりのデータセクタ数 */
	u_long	d_ntracks;	/* シリンダあたりのトラック数 */
	u_long	d_ncylinders;	/* ユニットあたりのデータシリンダ数 */
	u_long	d_secpercyl;	/* シリンダあたりのデータセクタ数 */
	u_long	d_secperunit;	/* ユニットあたりのデータセクタ数 */
	/*
	* 以下の予備 (不良セクタ置換) は in d_nsectors や d_secpercyl
	* には数えられません。
	* 予備セクタは、各トラックまたはシリンダの末尾の場所を占める
	* 物理セクタにあることにします。
	*/
	u_short	d_sparespertrack;	/* トラックあたりの予備セクタ */
	u_short	d_sparespercyl;	/* シリンダあたりの予備セクタ */
	/*
	* メインテナンス、置換、コンフィギュレーション記述領域等を
	* 含む交替シリンダ
	*/
	u_long	d_acylinders;	/* ユニットあたりの交替シリンダ */

		/* ハードウェア特性 */
	/*
	* d_interleave, d_trackskew, d_cylskew は、遅いコントローラの
	* 埋め合わせに使うための、メディアフォーマット中の
	* ぶれを記述します。
	* interleave は、フォーマット時にフォーマッタやコントローラに
	* よって設定される物理セクタインタリーブです。
	* インタリーブが使われているとき、論理的に隣り合ったセクタは
	* 物理的には連続ではなく、幾つかのセクタに分断されています。
	* これは論理セクタあたりの物理セクタ通過率として指定されます。
	* すなわち、1:1 のインタリーブは連続したレイアウトを意味し、
	* 2:1 は論理セクタ 0 が論理セクタ 1 から 1 セクタ離れていること
	* を意味します。
	* d_trackskew は、同一シリンダ上でトラック N-1 上のセクタ 0 から
	* トラック N のセクタ 0 の相対的なオフセットです。
	* 最後の d_cylskew は、シリンダ N-1 上のセクタ 0 からシリンダ N
	* 上のセクタ 0 の相対的なオフセットです。
	*/
	u_short	d_rpm;	/* 回転スピード */
	u_short	d_interleave;	/* ハードウェアセクタインタリーブ */
	u_short	d_trackskew;	/* トラックあたりのセクタ 0 スキュー */
	u_short	d_cylskew;	/* シリンダあたりのセクタ 0 スキュー */
	u_long	d_headswitch;	/* ハードスイッチ時間 usec */
	u_long	d_trkseek;	/* トラック間シーク usec */
	u_long	d_flags;	/* 一般フラグ */
#define NDDATA 5
	u_long	d_drivedata[NDDATA];	/* ドライブの型固有の情報 */
#define NSPARE 5
	u_long	d_spare[NSPARE];	/* 将来使うための予備 */
	u_long	d_magic2;	/* マジックナンバ (再度) */
	u_short	d_checksum;	/* データを含むパーティションの xor */

	/* ファイルシステムとパーティション情報 */
	u_short	d_npartitions;	/* 後に続くパーティション数 */
	u_long	d_bbsize;	/* sn0 のブート領域の大きさ(バイト単位) */
	u_long	d_sbsize;	/* fs スーパブロックの最大サイズ(バイト単位) */
	struct	partition {	/* パーティションテーブル */
		u_long	p_size;	/* パーティション内のセクタ数 */
		u_long	p_offset;	/* 開始セクタ */
		u_long	p_fsize;	/* ファイルシステム規定フラグメントサイズ */
		u_char	p_fstype;	/* ファイルシステムタイプ、下記参照 */
		u_char	p_frag;	/* ブロックあたりのファイルシステムフラグメント */
		union {
			u_short	cpg;	/* UFS: FS グループあたりのシリンダ数 */
			u_short	sgs;	/* LFS: FS セグメントシフト */
		} __partition_u1;
#define	p_cpg	__partition_u1.cpg
#define	p_sgs	__partition_u1.sgs
		u_short	p_cpg;	/* グループあたりのファイルシステムシリンダ数 */
	} d_partitions[MAXPARTITIONS];	/* 実際にはもっとある */
};

/* d_type values: */
#define	DTYPE_SMD	1	/* SMD, XSMD; VAX hp/up */
#define	DTYPE_MSCP	2	/* MSCP */
#define	DTYPE_DEC	3	/* その他の DEC (rk, rl) */
#define	DTYPE_SCSI	4	/* SCSI */
#define	DTYPE_ESDI	5	/* ESDI インタフェース */
#define	DTYPE_ST506	6	/* ST506 他 */
#define	DTYPE_HPIB	7	/* CS/80 on HP-IB */
#define	DTYPE_HPFL	8	/* HP ファイバリンク */
#define	DTYPE_FLOPPY	10	/* フロッピー */

#ifdef DKTYPENAMES
static char *dktypenames[] = {
	"unknown",
	"SMD",
	"MSCP",
	"old DEC",
	"SCSI",
	"ESDI",
	"ST506",
	"HP-IB",
	"HP-FL",
	"type 9",
	"floppy",
	0
};
#define DKMAXTYPES	(sizeof(dktypenames) / sizeof(dktypenames[0]) - 1)
#endif

/*
* ファイルシステムタイプとバージョン
* パーティションあたりの他のファイルシステム固有情報に使われます。
*/
#define	FS_UNUSED	0	/* 未使用 */
#define	FS_SWAP		1	/* スワップ */
#define	FS_V6		2	/* 第 6 版 */
#define	FS_V7		3	/* 第 7 版 */
#define	FS_SYSV		4	/* System V */
#define	FS_V71K		5	/* 7 版 1K ブロック (4.1, 2.9) */
#define	FS_V8		6	/* 8 版 4K ブロック */
#define	FS_BSDFFS	7	/* 4.2BSD fast ファイルシステム */
#define	FS_MSDOS	8	/* MSDOS ファイルシステム */
#define	FS_BSDLFS	9	/* 4.4BSD log-structured ファイルシステム */
#define	FS_OTHER	10	/* 使用中だが未知/未サポート */
#define	FS_HPFS		11	/* OS/2 high-performance ファイルシステム */
#define	FS_ISO9660	12	/* ISO 9660, 通常は CD-ROM */
#define	FS_BOOT		13	/* ブートストラップを含むパーティション */

#ifdef	DKTYPENAMES
static char *fstypenames[] = {
	"unused",
	"swap",
	"Version 6",
	"Version 7",
	"System V",
	"4.1BSD",
	"Eighth Edition",
	"4.2BSD",
	"MSDOS",
	"4.4LFS",
	"unknown",
	"HPFS",
	"ISO9660",
	"boot",
	0
};
#define FSMAXTYPES	(sizeof(fstypenames) / sizeof(fstypenames[0]) - 1)
#endif

/*
* 多様なドライブが共有するフラグ
*/
#define	D_REMOVABLE	0x01	/* リムーバブルメディア */
#define	D_ECC		0x02	/* ECC サポート */
#define	D_BADSECT	0x04	/* バッドセクタフォワードのサポート */
#define	D_RAMDISK	0x08	/* ディスクエミュレータ */
#define	D_CHAIN		0x10	/* back-back 転送ができる */

/*
* SMD のドライブデータ
*/

#define	d_smdflags	d_drivedata[0]
#define	D_SSE		0x1	/* セクタスキップのサポート */
#define	d_mindist	d_drivedata[1]
#define	d_maxdist	d_drivedata[2]
#define	d_sdist		d_drivedata[3]

/*
* ST506 のドライブデータ
*/
#define d_precompcyl	d_drivedata[0]
#define d_gap3		d_drivedata[1]	/* フォーマット時にのみ使われる */

/*
 * SCSI のドライブデータ
 */
#define	d_blind		d_drivedata[0]

#ifndef LOCORE
/*
* フォーマットや生の操作をする際に使われる
* 構造体で、データやレジスタ値を返します。
* レジスタの識別とフォーマットは、
* デバイス依存、ドライバ依存です。
*/
struct format_op {
	char	*df_buf;
	int	df_count;	/* 値-結果 */
	daddr_t	df_startblk;
	int	df_reg[8];	/* 結果 */
};

/*
* ディスク上のパーティションに関する情報を
* 引き出すために内部で使われる構造体
*/
struct partinfo {
	struct	disklabel *disklab;
	struct	partition *part;
};

/*
* ディスク固有の ioctl
*/
	/* ディスクラベルの取得と設定; 内部では DIOCGPART が使われる */
#define DIOCGDINFO   _IOR('d', 101, struct disklabel) /* 取得 */
#define DIOCSDINFO   _IOW('d', 102, struct disklabel) /* 設定 */
#define DIOCWDINFO   _IOW('d', 103, struct disklabel) /* 設定、ディスク更新 */
#define DIOCGPART    _IOW('d', 104, struct partinfo)  /* パーティション取得 */

/* do format operation, read or write */
#define DIOCRFORMAT	_IOWR('d', 105, struct format_op)
#define DIOCWFORMAT	_IOWR('d', 106, struct format_op)

#define DIOCSSTEP	_IOW('d', 107, int) /* ステップレート設定 */
#define DIOCSRETRIES	_IOW('d', 108, int) /* リトライ回数の設定 */
#define DIOCWLABEL	_IOW('d', 109, int) /* 書き込み可/不可のラベル */

#define DIOCSBAD	_IOW('d', 110, struct dkbad) /* カーネル dkbad の設定 */

#endif LOCORE
.Ed
.Sh 関連項目
.Xr disktab 5 ,
.Xr disklabel 8
