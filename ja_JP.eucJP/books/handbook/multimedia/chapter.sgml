<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.144
     $FreeBSD$
-->

<chapter id="multimedia">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Ross</firstname>
	<surname>Lippert</surname>
	<contrib>編集: </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>マルチメディア</title>
  <sect1 id="multimedia-synopsis">
    <title>この章では</title>

    <para>FreeBSD は数多くの種類のサウンドカードに対応しており、
      コンピュータで原音に忠実な出力を楽しむことができます。
      これには録音機能と、MPEG Layer 3 Audio (MP3) や WAV, Ogg Vorbis
      などをはじめとした多くの形式の音楽の再生機能が含まれます。
      加えて FreeBSD の Ports Collection には、録音した音楽を
      編集したり、音響効果を加えたり、接続された
      MIDI 機器を制御するためのアプリケーションがあります。</para>

    <para>多くの試みによって、&os; ではビデオファイルおよび DVD の
      再生ができるようになりました。さまざまなビデオメディアをエンコード、
      変換、再生するアプリケーションの数は、
      音声用のアプリケーションほど充実していません。
      この文書を執筆している時点では、たとえば
      <filename role="package">audio/sox</filename>
      のようなファイル形式を変換するためのすぐれたアプリケーションは
      Ports Collection にありません。しかしながら、
      この分野のソフトウェアの状況は急速に変わりつつあります。</para>

    <para>この章ではサウンドカードを設定するために必要な方法を説明します
      (ただし、高音質で再生するためには若干の微調整が必要かもしれません)。
      ビデオカードのハードウェアに関する問題は、
      X11 (<xref linkend="x11">)
      のインストールと設定においてすでに扱いましたので、
      そちらをご覧ください。</para>

    <para>この章を読むと、以下のことがわかります。</para>

    <itemizedlist>
      <listitem>
        <para>サウンドカードを認識させるためにシステムを設定する方法</para>
      </listitem>

      <listitem>
        <para>サウンドカードがうまく動作しているかどうかテストする方法</para>
      </listitem>

      <listitem>
        <para>サウンドの設定に関するトラブルシューティング</para>
      </listitem>

      <listitem>
        <para>MP3 およびその他の形式の音声を再生、エンコードする方法</para>
      </listitem>

      <listitem>
        <para>X サーバで
	  どのようにビデオに対応しているか</para>
      </listitem>

      <listitem>
        <para>ビデオを再生、エンコードするのに役に立つ ports</para>
      </listitem>

      <listitem>
        <para>DVD の <filename>.mpg</filename> ファイルおよび
          <filename>.avi</filename> ファイルを再生する方法</para>
      </listitem>

      <listitem>
        <para>CD および DVD の情報を抽出する方法</para>
      </listitem>

      <listitem>
	<para>TV カードの設定方法</para>
      </listitem>

      <listitem>
	<para>画像スキャナの設定方法</para>
      </listitem>
    </itemizedlist>

    <para>この章を読む前に、以下のことを理解しておく必要があります。</para>

    <itemizedlist>
      <listitem><para>新しいカーネルを設定してインストールする方法
	  (<xref linkend="kernelconfig">)</para></listitem>
    </itemizedlist>

    <warning>
      <para>オーディオ CD を &man.mount.8;
        でマウントしようとすると、少なくともエラーになります。
        最悪の場合、<emphasis>カーネルパニック</emphasis>が発生するでしょう。
        これらのメディアは通常の ISO ファイルシステムとは異なり、
        特別なエンコードが施されているからです。</para>
    </warning>
  </sect1>

  <sect1 id="sound-setup">
    <sect1info>
      <authorgroup>
        <author>
	  <firstname>Moses</firstname>
	  <surname>Moore</surname>
	  <contrib>寄稿: </contrib>
	  <!-- 20 November 2000 -->
        </author>
      </authorgroup>
      <authorgroup>
        <author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>再構成: </contrib>
	  <!-- 13 September 2004 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>サウンドカードの設定</title>
    <sect2 id="sound-device">
      <title>システムを設定する</title>

      <indexterm><primary>PCI</primary></indexterm>
      <indexterm><primary>ISA</primary></indexterm>
      <indexterm><primary>サウンドカード</primary></indexterm>

      <para>設定をはじめる前に、あなたが持っているカードのモデル、
	そのカードが使用しているチップ、そして PCI, ISA
	どちらのカードなのかを確認する必要があります。
	FreeBSD は PCI および ISA の両方のカードに幅広く対応しています。
	使用しているカードが対応しているかどうかは、
	<ulink url="&rel.current.hardware;">ハードウェアノート</ulink>
	の対応オーディオデバイスの一覧を調べてください。
	このハードウェアノートには、
	カードに対してどのドライバを利用すればよいかについても言及されています。</para>

      <indexterm>
	<primary>カーネル</primary>
	<secondary>設定</secondary>
      </indexterm>

      <para>サウンドデバイスを使うために、
	適切なデバイスドライバを読み込まなければいけません。
	これには二つの方法のどちらかでできるでしょう。
	もっとも簡単な方法は &man.kldload.8;
	を使ってサウンドカードのカーネルモジュールを単に読み込むことです。
	次のコマンドで実現できます。</para>

      <screen>&prompt.root; <userinput>kldload snd_emu10k1</userinput></screen>
      <para>または <filename>/boot/loader.conf</filename>
	ファイルにこのような適切な行を加えて実現することもできます。</para>

      <programlisting>snd_emu10k1_load="YES"</programlisting>

      <para>以上は Creative &soundblaster; Live! サウンドカードの例です。
	他に利用可能な読み込み可能なサウンドモジュールは
	<filename>/boot/defaults/loader.conf</filename>
	に記載されています。
	どのドライバを利用すればいいか確かでなければ、
	<filename>snd_driver</filename>
	モジュールを読み込んでみてください。</para>

      <screen>&prompt.root; <userinput>kldload snd_driver</userinput></screen>

      <para><filename>snd_driver</filename> モジュールは、
	一般に使用されるカードに対応したドライバをまとめて一度に読み込むメタドライバです。
	このドライバを使用すれば、速やかに正しいドライバを探し出すことができるでしょう。
	<filename>/boot/loader.conf</filename> ファイルを使用して、
	すべてのサウンドドライバを読み込むこともできます。</para>

    <para><filename>snd_driver</filename> メタドライバの読み込み後に、
      どのドライバがサウンドカードに選択されたのかを知りたいのなら
      <command>cat /dev/sndstat</command> コマンドで
      <filename>/dev/sndstat</filename> ファイルを調べてください。</para>

      <para>二つ目の方法は、
	サウンドカードのドライバをカーネルへ静的に組み込むことです。
	以下の節では、この方法でハードウェアを対応させる方法を説明します。
	カーネル再構築の詳細は
	<xref linkend="kernelconfig"> を参照してください。</para>

      <sect3>
	<title>サウンドに対応したカスタムカーネルを設定する</title>

	<para>はじめに、オーディオフレームワークドライバ
	  &man.sound.4; をカーネルに追加します。
	  カーネルコンフィグレーションファイルに以下の行を追加してください。</para>

	<programlisting>device sound</programlisting>

	<para>次に、サウンドカードに対応したドライバを追加します。
	  それには、どのドライバがカードに対応しているかを知る必要があります。
	  使用しているカードに対する正しいドライバを決定するために、
	  <ulink url="&rel.current.hardware;">ハードウェアノート</ulink>
	  の対応オーディオデバイスの一覧を調べてください。
	  たとえば、Creative &soundblaster; Live! サウンドカードは
	  &man.snd.emu10k1.4; ドライバが対応しています。
	  このカードを使用するためには、
	  カーネルコンフィグレーションファイルに以下の行を追加してください。</para>

	<programlisting>device snd_emu10k1</programlisting>

	<para>ドライバのマニュアルページを読んで、
	  追加すべき構文を調べてください。
	  対応しているすべてのサウンドドライバに関するカーネルコンフィグレーションの具体的な構文は、
	  <filename>/usr/src/sys/conf/NOTES</filename>
	  にもあります。</para>

	<para>すべての PnP 非対応の ISA カードに当てはまるように、
	  PnP 非対応の ISA サウンドカードでは、
	  カーネルにカードが使用する資源
	  (IRQ, I/O ポートなど) を明示的に指定する必要があるかもしれません。
	  この場合は、<filename>/boot/device.hints</filename>
	  ファイルを使用してください。
	  システムの起動時に、&man.loader.8;
	  はこのファイルを読み、設定情報をカーネルに渡します。
	  たとえば、PnP 非対応の古い Creative &soundblaster; 16 (ISA 接続)
	  には <literal>snd_sb16</literal> とともに &man.snd.sbc.4; ドライバを使用します。
	  このカードを使用する場合には、
	  カーネルコンフィグレーションファイルに以下の行を追加すると同時に、</para>

	<programlisting>device snd_sbc
device snd_sb16</programlisting>

	<para><filename>/boot/device.hints</filename>
	  ファイルに以下のエントリを追加してください。</para>

	<programlisting>hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"</programlisting>

	<para>この例では、
	  I/O ポートに <literal>0x220</literal> を、
	  IRQ に <literal>5</literal> を使用します。</para>

	<para><filename>/boot/device.hints</filename>
	  ファイルに用いるべき構文は、
	  &man.sound.4; ドライバのマニュアルページ、および、
	  各ドライバのマニュアルページに記載されています。</para>

	<para>初期設定は以上の通りです。
	  カードを使用する状況によっては、
	  IRQ やその他の設定を変更する必要があるかもしれません。
	  このカードについての詳細は、
	  &man.snd.sbc.4; マニュアルページをご覧ください。</para>
      </sect3>
    </sect2>

    <sect2 id="sound-testing">
      <title>サウンドカードのテスト</title>

      <para>カーネルを変更して再起動するか、必要となるモジュールを読み込むと、
	システムのメッセージバッファ (&man.dmesg.8;)
	にサウンドカードが認識されたことが示されます。
	たとえば、次のようなメッセージが出力されます。</para>

      <screen>pcm0: &lt;Intel ICH3 (82801CA)&gt; port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</screen>

      <para>サウンドカードの状態は、<filename>/dev/sndstat</filename>
	ファイルを使用して確認することができます。</para>

      <screen>&prompt.root; <userinput>cat /dev/sndstat</userinput>
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: &lt;Intel ICH3 (82801CA)&gt; at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)</screen>

      <para>この出力はシステムによって異なるでしょう。
	<devicename>pcm</devicename> デバイスがなければ、
	今までの手順を振り返ってみてください。
	カーネルコンフィグレーションファイルをもう一度見直して、
	正しいデバイスドライバを選択しているかどうか確認してください。
	トラブルシューティングは <xref linkend="troubleshooting">
	を参照してください。</para>

      <para>すべてうまくいけば、サウンドカードが機能するでしょう。
	CD-ROM または
	DVD-ROM ドライブのオーディオ出力端子がサウンドカードと適切に接続されていれば、
	&man.cdcontrol.1; を使ってドライブ内の CD を再生できます。</para>

      <screen>&prompt.user; <userinput>cdcontrol -f /dev/acd0 play 1</userinput></screen>

      <para><filename role="package">audio/workman</filename>
	のように、よりよいインタフェースを提供するさまざまなアプリケーションがあります。
	MP3 オーディオファイルを聴くために
	<filename role="package">audio/mpg123</filename>
	のようなアプリケーションをインストールしようと思うかもしれません。</para>

      <para>手っ取り早くカードをテストするには、
	<filename>/dev/dsp</filename> デバイスにデータを送ってみてください。
	たとえば、以下のようにします。</para>

      <screen>&prompt.user; <userinput>cat <replaceable>filename</replaceable> &gt; /dev/dsp</userinput></screen>

      <para>ここで <filename><replaceable>filename</replaceable></filename>
	はどんなファイルでも構いません。
	このコマンドラインを実行すると雑音が発生するはずです。
	これにより、サウンドカードが実際に動作していることを確認できます。</para>

    <note>
      <para>デバイスノード <filename>/dev/dsp*</filename> は、
	必要とされる時に自動的に作成されます。
	デバイスノードが使用されていない場合には存在せず、
	&man.ls.1; の出力に表示されません。</para>
    </note>

	<para>サウンドカードのミキサレベルは
	  &man.mixer.8; コマンドで変更することができます。
	  詳細は &man.mixer.8; マニュアルページをご覧ください。</para>

      <sect3 id="troubleshooting">
	<title>よくある問題</title>

	<indexterm><primary>デバイスノード</primary></indexterm>
	<indexterm><primary>I/O ポート</primary></indexterm>
	<indexterm><primary>IRQ</primary></indexterm>
	<indexterm><primary>DSP</primary></indexterm>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>エラー</entry>
		<entry>解決方法</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><errorname>sb_dspwr(XX) timed out</errorname></entry>
		<entry><para>使用する
		    I/O ポートが適切に設定されていません。</para></entry>
	      </row>

	      <row>
		<entry><errorname>bad irq XX</errorname></entry>
		<entry><para>使用する IRQ が正しく設定されていません。
		    サウンドカードの IRQ と設定した IRQ
		    が同じかどうか確かめてください。</para></entry>
	      </row>

	      <row>
		<entry><errorname>xxx: gus pcm not attached, out of memory</errorname></entry>
		<entry><para>デバイスを使用するのに十分なメモリを確保できません。</para></entry>
	      </row>

	      <row>
		<entry><errorname>xxx: can't open /dev/dsp!</errorname></entry>
		<entry><para><command>fstat | grep dsp</command> を使って、
		    他のアプリケーションがデバイスを使用しているか調べてください。
		    注目すべきトラブルメーカは
		    <application>esound</application> と
		    <application>KDE</application>
		    のサウンド機能です。</para></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

      <para>最近のグラフィックカードの中には、
	<acronym>HDMI</acronym> や類似のインタフェースを利用するため、
	グラフィックカード自身がサウンドカードを持つものがあります。
	このようなサウンドデバイスには、
	時として本当のサウンドカードより若い番号が付けられることがあり、
	そのような場合には、
	サウンドカードをデフォルトプレイバックデバイスとして利用できません。
	このことが原因かどうかを確認するには、<application>dmesg</application> を実行して
	<literal>pcm</literal> を探してください。
	以下のような出力を得るかもしれません。</para>
      
<programlisting>...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1
...</programlisting>

      <para>ここで、グラフィックカード (<literal>NVidia</literal>)
	には、サウンドカード (<literal>Realtek ALC889</literal>)
	より若い番号が付けられています。
	サウンドカードをデフォルトのプレイバックデバイスとして利用するには、
	以下のように <literal>hw.snd.default_unit</literal>
	をプレイバックで使用するユニット番号に変更してください。</para>

      <screen>&prompt.root; <userinput>sysctl hw.snd.default_unit=<replaceable>n</replaceable></userinput></screen>

      <para>ここで、<literal>n</literal> は使用するサウンドデバイスの番号です。
	この例では <literal>4</literal> です。
        <filename>/etc/sysctl.conf</filename> に以下の行を入れると、
	常に設定の変更が反映されるようになります。</para>
	    
      <programlisting>hw.snd.default_unit=<replaceable>4</replaceable></programlisting>
      </sect3>
    </sect2>

    <sect2 id="sound-multiple-sources">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Munish</firstname>
	    <surname>Chopra</surname>
	    <contrib>寄稿: </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>複数音源の利用</title>

      <para>特定のアプリケーションとのサウンドデバイスの共用に対応していない時、
	<application>esound</application> または
	<application>artsd</application> のように
	同時に再生することのできる音源を複数実装していることは、
	多くの場合望ましいことです。</para>

      <para>FreeBSD では、
	<emphasis>仮想サウンドチャネル</emphasis>
	を使ってこれを実現でき、&man.sysctl.8; で設定できます。
	仮想チャネルはカーネル内でサウンドを合成することにより、
	サウンドカードの再生を多重化することができます。</para>

      <para>仮想チャネルの数を決めるのに三つの sysctl 変数を設定できます。
	<username>root</username> ユーザで以下のようにします。</para>

      <screen>&prompt.root; <userinput>sysctl dev.pcm.0.play.vchans=4</userinput>
&prompt.root; <userinput>sysctl dev.pcm.0.rec.vchans=4</userinput>
&prompt.root; <userinput>sysctl hw.snd.maxautovchans=4</userinput></screen>

      <para>上記の例では四つの仮想チャネルを設定しています。
	これは通常利用する上で十分実用的な数です。
	<varname>dev.pcm.0.play.vchans=4</varname> と
	<varname>dev.pcm.0.rec.vchans=4</varname> は、
	<devicename>pcm0</devicename>
	が再生や録音のために持っている仮想チャネルの数で、
	一度デバイスが取り付けられると設定できます。
	<literal>hw.snd.maxautovchans</literal> は、
	&man.kldload.8;
	を用いて認識された新しいデバイスの仮想チャネル数です。
	<devicename>pcm</devicename>
	モジュールはハードウェアドライバとは独立して読み込むことができるので、
	後でどんなにデバイスを認識しても
	<varname>hw.snd.maxautovchans</varname>
	は仮想チャネルを格納できます。
	より詳細な情報については &man.pcm.4;
	のマニュアルページを参照してください。</para>

      <note>
	<para>デバイスを使用しているときに
	  仮想チャンネルの数を変更することはできません。
	  まず、ミュージックプレーヤやサウンドデーモンといった
	  デバイスを使用しているすべてのプログラムを終了してください。</para>
      </note>

      <para>
	<filename>/dev/dsp0</filename>
	を必要とするプログラムが意識しなくても、
	適切な <devicename>pcm</devicename>
	デバイスが自動的に設定されます。</para>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Josef</firstname>
	    <surname>El-Rayes</surname>
	    <contrib>寄稿: </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>ミキサチャネルの初期値を設定する</title>

      <para>各ミキサチャネルの初期値は
	&man.pcm.4; ドライバのソースにハードコーディングされています。
	起動時に記録されていた値をミキサに設定する
	さまざまなアプリケーションやデーモンがありますが、
	あまりよい解決方法ではありません。
	適切な値を <filename>/boot/device.hints</filename>
	ファイルに記述することにより、
	ドライバレベルでミキサの初期値を設定することができます。
	たとえば、以下のような行を追加します。</para>

      <programlisting>hint.pcm.0.vol="50"</programlisting>

      <para>この例では、&man.pcm.4; が読み込まれたと同時に、
	ボリュームチャネルの初期値を 50 に設定します。</para>
    </sect2>
  </sect1>

  <sect1 id="sound-mp3">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
      <!-- 11 Sept 2001 -->
    </sect1info>

    <title>MP3 オーディオ</title>

    <para>MP3 (MPEG Layer 3 Audio) は
      CD に匹敵する音質でサウンドを再生できます。あなたの FreeBSD
      ワークステーションにこのプレイヤをインストールしない理由はないでしょう。</para>

    <sect2 id="mp3-players">
      <title>MP3 プレイヤ</title>

      <para><application>XMMS</application> (X Multimedia System) は
        とても人気のある X11 ベースの MP3 プレイヤです。
	<application>XMMS</application>
        のグラフィカルインタフェースは
        Nullsoft の <application>Winamp</application>
        とほとんど同一なので、<application>Winamp</application>
        のスキンを使うことができます。
	<application>XMMS</application>
        はネイティブプラグインにも対応しています。</para>

      <para><application>XMMS</application> は
	<filename role="package">multimedia/xmms</filename> の
        port または package からインストールできます。</para>

      <para><application>XMMS</application>
        のプレイリスト、グラフィックイコライザそしてその他のインタフェースは
        直感的です。
        <application>Winamp</application> を使いなれている人は
	簡単に <application>XMMS</application> を使えるでしょう。</para>

      <para><filename role="package">audio/mpg123</filename>
        はコマンドライン上の代替となる MP3 プレイヤの port です。</para>

      <para><application>mpg123</application>
	はサウンドデバイスと MP3 ファイルを指定して実行できます。
	<devicename>/dev/dsp1.0</devicename> デバイスを使用して
	MP3 ファイル <replaceable>Foobar-GreatestHits.mp3</replaceable>
	を再生するのであれば、次のように実行してください。
      </para>

      <screen>&prompt.root; <userinput>mpg123 -a <devicename>/dev/dsp1.0</devicename> <replaceable>Foobar-GreatestHits.mp3</replaceable></userinput>
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!





Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
</screen>
    </sect2>

    <sect2 id="rip-cd">
      <title>CD 音声トラックの抽出</title>

      <para>CD 全体または CD トラックを MP3 に変換する前に、CD
        上のオーディオデータをハードディスク上に抽出する必要があります。
        これには raw CDDA (CD Digital Audio) データを WAV
        ファイルにコピーします。</para>

      <para><filename role="package">sysutils/cdrtools</filename>
        スイートの一部である <command>cdda2wav</command> ツールは
        CD からオーディオデータを抽出したり、
	情報を関係づけるのに使われます。</para>

      <para>CD をドライブにいれて次のコマンドを
        (<username>root</username>で) 実行して、
        CD 全体を (トラックごとに) 個々の WAV ファイルに抽出できます。</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -B</userinput></screen>

      <para><application>cdda2wav</application>
        は ATAPI (IDE) CDROM ドライブにも対応しています。
        IDE ドライブから抽出するには、
        SCSI ユニット番号をデバイス名に置き換えて指定します。
	たとえば IDE ドライブから七番目のトラックを抽出するには、
        次のようにします。</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>/dev/acd0</replaceable> -t 7</userinput></screen>

      <para><option>-D <replaceable>0,1,0</replaceable></option> は
	SCSI デバイス <devicename>0,1,0</devicename> を表します。
	これは <command>cdrecord -scanbus</command>
        の出力に一致します。</para>

      <para>個々のトラックを抽出するには、
	次のように <option>-t</option> オプションを使用します。</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -t 7</userinput></screen>

      <para>上記の例はオーディオ CDROM の七番目のトラックを抽出します。
        範囲を指定して、
        たとえば一番目から七番目のトラックまで抽出したい場合、
        次のようにします。</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -t 1+7</userinput></screen>

      <para>&man.dd.1; ユーティリティも ATAPI
        ドライブ上のオーディオトラックを展開するのに使われます。
        何ができるか詳しいことは
        オーディオ CD の複製について
        <xref linkend="duplicating-audiocds">
	を参照してください。</para>

    </sect2>

    <sect2 id="mp3-encoding">
      <title>MP3 のエンコード</title>

      <para>現在、一般に好まれている MP3 エンコーダは
	<application>lame</application> です。
	<application>lame</application> は Ports Collection の
	<filename role="package">audio/lame</filename>
	に収録されています。</para>

      <para>次のコマンドを実行すると、抽出した WAV ファイル
	<filename><replaceable>audio01.wav</replaceable></filename> を使って
	<filename><replaceable>audio01.mp3</replaceable></filename> に変換します。</para>

      <screen>&prompt.root; <userinput>lame -h -b <replaceable>128</replaceable> \
--tt "<replaceable>曲名</replaceable>" \
--ta "<replaceable>アーティスト名</replaceable>" \
--tl "<replaceable>アルバム名</replaceable>" \
--ty "<replaceable>年</replaceable>" \
--tc "<replaceable>コメント</replaceable>" \
--tg "<replaceable>ジャンル</replaceable>" \
<replaceable>audio01.wav audio01.mp3</replaceable></userinput></screen>

      <para>128&nbsp;kbits が標準のビットレートのようです。
	多くの人はさらに高音質の 160&nbsp;kbits または 192&nbsp;kbits
        を好むでしょう。
        ビットレートが高くなるにつれて作成される
	MP3 ファイルは多くのディスク領域を消費しますが、より高音質となります。
	<option>-h</option> オプションを指定すると
        <quote>低速高品質</quote> モードとなります。
        <option>--t</option> ではじまるオプションは ID3 タグを設定します。
        このタグにはたいてい曲の情報が含まれており、
        MP3 ファイルに格納されます。
	<application>lame</application>
	のマニュアルを参照すれば他のオプションが見つかるでしょう。</para>
    </sect2>

    <sect2 id="mp3-decoding">
      <title>MP3 のデコード</title>

      <para>MP3 からオーディオ CD を作成するには、
        MP3 形式を非圧縮 WAV 形式に変換しなければなりません。
        <application>XMMS</application> と
	<application>mpg123</application> の両方が
        MP3 から非圧縮ファイル形式への出力に対応しています。</para>

      <para><application>XMMS</application>
        でディスクへ書き出す方法は次の通りです。</para>

      <procedure>
	<step>
	  <para><application>XMMS</application> を起動します。</para>
	</step>

	<step>
	  <para>右クリックで
            <application>XMMS</application> メニューを表示します。</para>
	</step>

	<step>
	  <para><literal>Options</literal>
            から <literal>Preference</literal> を選択します。</para>
	</step>

	<step>
	  <para>Output Plugin を <quote>Disk Writer Plugin</quote>
            に変更します。</para>
	</step>

	<step>
	  <para><literal>Configure</literal> を押します。</para>
	</step>

	<step>
	  <para>非圧縮ファイルを書き出すディレクトリを入力
            (または選択) します。</para>
	</step>

	<step>
	  <para>普段通り <application>XMMS</application>
            へ MP3 ファイルを読み込みます。
            音量は 100% で イコライザの設定はオフにします。</para>
	</step>

	<step>
	  <para><literal>Play</literal> を押します&mdash;
	    <application>XMMS</application>
            は MP3 を再生しているかのように表示しますが、
            音声はきこえません。
            実際には MP3 をファイルに出力しています。</para>
	</step>

	<step>
	  <para>再び MP3 を聴けるように
	    Output Plugin を以前のように元に戻すのを忘れないでください。</para>
	</step>
      </procedure>

      <para><application>mpg123</application>
        で標準出力へ書き出す方法は次の通りです。</para>

      <procedure>
	<step>
	  <para><command>mpg123 -s <replaceable>audio01.mp3</replaceable>
	      &gt; <replaceable>audio01.pcm</replaceable></command> を実行します。</para>
	</step>
      </procedure>

      <para><application>XMMS</application>
        は WAV 形式でファイルに書き出しますが、
        <application>mpg123</application> は
	MP3 を PCM オーディオデータに変換します。
        両形式は <application>cdrecord</application>
        を使ってオーディオ CD を作成するのに利用することができます。
	&man.burncd.8; を使う場合は raw PCM データが必要です。
	WAV ファイルを使用する場合、
        それぞれのトラックの先頭に小さなノイズが入るのに気づくでしょう。
        これは WAV ファイルのヘッダ情報です。
	<application>SoX</application>
	(<filename role="package">audio/sox</filename> の port または package
        からインストールできます)
        を使うと簡単に WAV ファイルのヘッダ情報を削除できます。</para>

      <screen>&prompt.user; <userinput>sox -t wav -r 44100 -s -w -c 2 <replaceable>track.wav track.raw</replaceable></userinput></screen>

      <para>FreeBSD での CD 作成の詳しい情報は
        <xref linkend="creating-cds"> を参照してください。</para>
    </sect2>
  </sect1>

  <sect1 id="video-playback">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Ross</firstname>
	  <surname>Lippert</surname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
      <!-- 5 June 2002 -->
    </sect1info>

    <title>ビデオ再生</title>

    <para>ビデオ再生は今まさに成長中の新しいアプリケーション分野です。
      辛抱強くしてください。
      音声のようにすべてが順調にいくとは限りません。</para>

    <para>設定をはじめる前に、あなたが持っているビデオカードのモデル、
      そのカードが使用しているチップを確認する必要があります。
      <application>&xorg;</application>
      はさまざまなビデオカードに対応していますが、
      ビデオ再生に申し分のない性能を発揮できるカードはわずかです。
      あなたのビデオカードの利用している X
      サーバが対応している拡張機能のリストを得るには、
      X11 を実行中に &man.xdpyinfo.1; コマンドを実行してください。</para>

    <para>さまざまなプレイヤやオプションを試すのに、
      テストファイルとして小さな MPEG ファイルを用意しておくのはよい考えです。
      いくつかの DVD プレイヤは DVD メディアを
      <filename>/dev/dvd</filename> として
      初期設定しているか、ハードコーディングされているので、
      次のように適切なデバイスにシンボリックリンクを張っておくと便利かもしれません。</para>

    <screen>&prompt.root; <userinput>ln -sf /dev/acd0 /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/acd0 /dev/rdvd</userinput></screen>

    <para>&man.devfs.5; の仕様により、
      このように手動で作成されたリンクは再起動すると消えてしまいます。
      システムの起動時にこれらのシンボリックリンクを自動的に作成するには、
      <filename>/etc/devfs.conf</filename> に下記の設定を追加します。</para>

    <programlisting>link acd0 dvd
link acd0 rdvd</programlisting>

    <para>加えて、特別な DVD-ROM 機能を必要とする DVD 解読は、
      DVD デバイスへの書き込み権限が必要です。</para>

    <para>共有メモリ X11 インタフェースを改善するために、
      いくつかの &man.sysctl.8; 変数の値を増やすことが推奨されています。</para>

    <programlisting>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</programlisting>

    <sect2 id="video-interface">
      <title>ビデオ機能の決定</title>

      <indexterm><primary>XVideo</primary></indexterm>
      <indexterm><primary>SDL</primary></indexterm>
      <indexterm><primary>DGA</primary></indexterm>

      <para>X11 においてビデオ表示性能を改善する方法はいくつかあると思われます。
	ちゃんと動作するかどうかはハードウェアに大きく依存しています。
	下記に説明したどの方法でも、
	ハードウェアが変わると品質が変わるでしょう。
	二つ目に、X11
	でのビデオレンダリングは最近多くの注目を集めるトピックです。
	そして <application>&xorg;</application>
	のバージョンを追うごとに、著しく改良されているかもしれません。</para>

      <para>よく知られたビデオインタフェースは次の通りです。</para>

      <orderedlist>
	<listitem>
	  <para>X11: 共有メモリを用いた通常の X11 出力</para>
	</listitem>
	<listitem>
	  <para>XVideo: X11 drawable 内でのビデオ再生に対応した
	    X11 インタフェースの拡張機能</para>
	</listitem>
	<listitem>
	  <para>SDL: Simple Directmedia Layer</para>
	</listitem>
	<listitem>
	  <para>DGA: Direct Graphics Access</para>
	</listitem>
	<listitem>
	  <para>SVGAlib: 低レベルコンソールグラフィックレイヤ</para>
	</listitem>
      </orderedlist>

      <sect3 id="video-interface-xvideo">
	<title>XVideo</title>

	<para><application>&xorg;</application> には
	  <emphasis>XVideo</emphasis> (または Xvideo, Xv, xv)
	  と呼ばれる拡張機能があります。
	  これは特別なアクセラレーションによって drawable オブジェクト
	  に直接ビデオを表示することができます。
	  この拡張機能によって、
	  低速なマシンでも、とてもすぐれた品質の再生が可能となります。</para>

	<para>この拡張機能が動作しているかどうかを調べるには、
	  <command>xvinfo</command> を使います。</para>

        <screen>&prompt.user; <userinput>xvinfo</userinput></screen>

	<para>以下のような結果が得られたならば、あなたのカードは
	  XVideo に対応しています。</para>

	<screen>X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</screen>

	<para>リストにある形式 (YUV2, YUV12 など) が XVideo
	  のすべての実装で存在するとは限りません。
	  対応している形式が少ないために、あるプレイヤでは悪影響が出る
	  かもしれないことにも注意してください。</para>

	<para>出力が以下のような場合、</para>
	<screen>X-Video Extension version 2.2
screen #0
no adaptors present</screen>

	<para>あなたのカードはおそらく
	  XVideo に対応していないのでしょう。</para>

	<para>あなたのカードが XVideo に対応していないとしても、
	  このことはあなたのディスプレイでビデオを表示するのに、
	  計算上の要求を満たすことがより困難になるだけのことです。
	  しかしながら、あなたのビデオカードおよびプロセッサによっては、
	  それでも満足のいく性能が得られるかもしれません。
	  性能を向上させるには
	  <xref linkend="video-further-reading">
	  をよく読むとよいでしょう。</para>

      </sect3>

      <sect3 id="video-interface-SDL">
	<title>Simple Directmedia Layer</title>

	<para>Simple Directmedia Layer (SDL) は
	  &microsoft.windows;, BeOS そして &unix; の間で
	  サウンドとグラフィックスを効果的に利用した
	  クロスプラットホームアプリケーションを
	  開発することを目的としたレイヤです。
	  SDL レイヤはハードウェアに対する低レベルの抽象的概念を提供し、
	  時には X11 インタフェースを使用するよりも効果的なことがあります。</para>

	<para>SDL は <filename role="package">devel/sdl12</filename>
	  からインストールできます。</para>

      </sect3>

      <sect3 id="video-interface-DGA">
	<title>Direct Graphics Access</title>

	<para>Direct Graphics Access は、
	  プログラムが X サーバを介せず
	  直接フレームバッファを変更することを可能にする X11 の拡張機能です。
	  共有メモリを使用するために
	  低レベルのメモリマッピングが実行できることを期待しているので、
	  この機能を使うプログラムは <username>root</username>
	  権限で実行されなければなりません。</para>

	<para>DGA 機能拡張は &man.dga.1;
	  によってテストとベンチマークができます。
	  <command>dga</command>
	  実行中はキーボードを押せばいつでもディスプレイ色が変更されます。
	  中止するには <keycap>q</keycap> を押します。</para>

      </sect3>

    </sect2>

    <sect2 id="video-ports">
      <title>ビデオを扱う ports および packages</title>

      <indexterm><primary>ビデオ ports</primary></indexterm>
      <indexterm><primary>ビデオ packages</primary></indexterm>

      <para>この節では Ports Collection で利用可能な、
	ビデオの再生に使用できるソフトウェアについて論じます。
	ビデオ再生は大変活発なソフト開発分野で、
	さまざまなアプリケーションの機能は、
	ここでの説明から省かざるをえません。</para>

      <para>はじめに、FreeBSD で実行できるビデオアプリケーションの多くは、
	Linux アプリケーションとして開発されたということを知ることは重要です。
	これらのアプリケーションの多くはまだベータ版の品質です。
	FreeBSD でこれらのビデオアプリケーションを使用する際に、
	以下のような問題が起こるかもしれません。</para>

      <orderedlist>

	<listitem>
	  <para>あるアプリケーションが、
	    他のアプリケーションの作成したファイルを再生できない。</para>
	</listitem>

	<listitem>
	  <para>あるアプリケーションが、
	    自身の作成したファイルを再生できない。</para>
	</listitem>

	<listitem>
	  <para>二つの異なるマシンで構築した同じアプリケーションが、
	    同じファイルを再生する挙動がそれぞれ異なる。</para>
	</listitem>

	<listitem>
	  <para>イメージサイズ変更のように見たところではありふれたフィルタが、
	    バグの多いサイズ変更ルーチンによってひどい人工物を作成する。</para>
	</listitem>

	<listitem>
	  <para>アプリケーションがよくコアダンプする。</para>
	</listitem>

	<listitem>
	  <para>文書が port と一緒にインストールされない
	    (文書は web サイトにあったり、その port の
	    <filename class='directory'>work</filename> ディレクトリの中に
	    残っていることがある)。</para>
	</listitem>

      </orderedlist>

      <para>これらのアプリケーションの多くはさらに
	<quote>Linux 主義</quote> を主張するかもしれません。
	すなわち、アプリケーションの作者が仮定した、
	Linux ディストリビューションでのみ実装されている
	ある標準ライブラリの使用方法や
	Linux カーネルの特定の機能に起因する問題が生じるかもしれません。
	必ずしも port 保守担当者がこれらの問題を把握して作業しているとは限らず、
	次のような問題が発生する可能性があります。
      </para>

      <orderedlist>

	<listitem>
	  <para>プロセッサの特性を検知するための
	    <filename>/proc/cpuinfo</filename> の利用</para>
	</listitem>

	<listitem>
	  <para>本当はプログラムを終了させるはずであるのに、
	    停止させてしまうようなスレッドの誤用</para>
	</listitem>

	<listitem>
	  <para>一般的にアプリケーションとともに使用され、まだ FreeBSD の
	    Ports Collection に収録されていないソフトウェアを必要とする</para>
	</listitem>

      </orderedlist>

      <para>これまで、これらのアプリケーションの開発者は、
	移植に必要だったその場しのぎの回避方法を最小化し
	問題を解決するために port 保守担当者と協力しています。</para>

      <sect3 id="video-mplayer">
	<title>MPlayer</title>

	<para><application>MPlayer</application> は最近開発され、
	  急激に成長しつつあるビデオプレイヤです。
	  <application>MPlayer</application> チームの目的は、
	  Linux や他の Unix 系 OS 上で高速性と柔軟性をもたらすことです。
	  このプロジェクトは、
	  チーム創設者が当時利用可能だったビデオプレイヤの
	  ひどい再生能力にうんざりしたのをきっかけとして始まりました。
	  合理化された設計のために GUI が犠牲にされたと言う人もいます。
	  しかしながら、コマンドラインオプションおよびキーボード操作に
	  一度慣れれば非常によく動作します。</para>

	<sect4 id="video-mplayer-building">
	  <title>MPlayer の作成</title>

	  <indexterm>
	    <primary>MPlayer</primary>
	    <secondary>作成</secondary>
	  </indexterm>

	  <para><application>MPlayer</application> は
	    <filename role="package">multimedia/mplayer</filename>
	    にあります。
	    <application>MPlayer</application> は
	    構築の際にさまざまなハードウェアのチェックをするため、
	    あるシステムで作成されたバイナリは、
	    別のシステムで利用できないかもしれません。
	    したがって port から構築し、
	    バイナリパッケージを利用しないことが重要です。
	    さらに、<filename>Makefile</filename>
	    や構築のはじめに説明されるように、
	    <command>make</command>
	    のコマンドラインで多くのオプションを指定することができます。</para>

	  <screen>&prompt.root; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.root; <userinput>make</userinput>
N - O - T - E

Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html</screen>

	  <para>ほとんどのユーザにとっては
	    port のデフォルトオプションで十分でしょう。
	    しかしながら、XviD コーデックが必要なら、
	    <makevar>WITH_XVID</makevar>
	    オプションをコマンドラインで指定しなければなりません。
	    また、デフォルトの DVD デバイスを
	    <makevar>WITH_DVD_DEVICE</makevar>
	    オプションで定義することもできます (デフォルトでは
	    <filename>/dev/acd0</filename> が使用されます)。</para>

	  <para>この文書を執筆している時点では、
	    <application>MPlayer</application> の port は HTML
	    文書、そして <command>mplayer</command> と
	    <command>mencoder</command>
	    という二つの実行可能なバイナリを構築します。
	    <command>mencoder</command>
	    はビデオを再エンコーディングするためのツールです。</para>

	  <para><application>MPlayer</application> のための
	    HTML 文書は非常に有益です。この章で不足した
	    ビデオハードウェアおよびインタフェースに関する情報があれば、
	    <application>MPlayer</application>
	    の文書は非常に詳細な補足になります。
	    &unix; のビデオ対応情報を探しているのなら、時間を割いて
	    <application>MPlayer</application> の文書を読むべきなのは
	    明らかです。</para>

	</sect4>

	<sect4 id="video-mplayer-using">
	  <title>MPlayer の使用</title>

	  <indexterm>
	    <primary>MPlayer</primary>
	    <secondary>使用</secondary>
	  </indexterm>

	  <para><application>MPlayer</application> を使用する人はすべて、
	    各自のホームディレクトリ内に <filename>.mplayer</filename>
	    サブディレクトリを用意しなければなりません。
	    この必要となるサブディレクトリを作成するために、
	    次のコマンドを入力します。</para>

	  <screen>&prompt.user; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.user; <userinput>make install-user</userinput></screen>

	  <para><command>mplayer</command>
	    のコマンドオプションはマニュアルに記載されています。
	    さらにより詳細な説明について知りたいなら、HTML 文書をご覧ください。
	    この節では、一般的な使用法についてほんの少し説明します。</para>

	  <para>さまざまなビデオインタフェースの一つを用いて
	    <filename><replaceable>testfile.avi</replaceable></filename>
	    というファイルを再生するには、
	    <option>-vo</option> オプションを指定します。
	  </para>

	  <screen>&prompt.user; <userinput>mplayer -vo xv <replaceable>testfile.avi</replaceable></userinput></screen>
	  <screen>&prompt.user; <userinput>mplayer -vo sdl <replaceable>testfile.avi</replaceable></userinput></screen>
	  <screen>&prompt.user; <userinput>mplayer -vo x11 <replaceable>testfile.avi</replaceable></userinput></screen>
	  <screen>&prompt.root; <userinput>mplayer -vo dga <replaceable>testfile.avi</replaceable></userinput></screen>
	  <screen>&prompt.root; <userinput>mplayer -vo 'sdl:dga' <replaceable>testfile.avi</replaceable></userinput></screen>

	  <para>ビデオ再生の相対的性能は多くの要因に依存し、
	    ハードウェアに応じて著しく変わると思われるので、
	    これらのオプションをすべて試してみる価値はあるでしょう。</para>

	  <para>DVD を再生するには、
	    <filename><replaceable>testfile.avi</replaceable></filename> を
	    <option>dvd://<replaceable>N</replaceable>
	      -dvd-device <replaceable>DEVICE</replaceable></option>
	    に置き換えてください。
	    &lt;N&gt; には再生するタイトル番号を、
	    <filename><replaceable>DEVICE</replaceable></filename>
	    は DVD-ROM のデバイスノードを指定します。
	    たとえば、<filename>/dev/dvd</filename>
	    から 2 番目のタイトルを再生するには以下のようにします。</para>

	  <screen>&prompt.root; <userinput>mplayer -vo xv dvd://3 -dvd-device /dev/dvd</userinput></screen>

	  <note>
	    <para>デフォルトの DVD デバイスは、
	      <application>MPlayer</application> port の構築時に
	      <makevar>WITH_DVD_DEVICE</makevar> で定義することができます。
	      デフォルトでは <filename>/dev/acd0</filename> になります。
	      詳細はこの port の
	      <filename>Makefile</filename> をご覧ください。</para>
	  </note>

	  <para>停止、休止、再生などをするにはキーの割り当てを調べてください。
	    <command>mplayer -h</command> を実行したり、
	    マニュアルを読めばわかります。</para>

	  <para>再生に関してさらに重要なオプションがあります。
	    全画面モードにする <option>-fs -zoom</option> オプションと、
	    性能を向上させる <option>-framedrop</option> オプションです。</para>

	  <para><command>mplayer</command>
	    に指定するコマンドラインが長くなりすぎないように、
	    <filename>.mplayer/config</filename>
	    を作成してデフォルトのオプションを設定できます。</para>
	  <programlisting>vo=xv
fs=yes
zoom=yes</programlisting>

	  <para>最後に <command>mplayer</command> は DVD タイトルを
	    <filename>.vob</filename> ファイルに抽出するのに使用できます。
	    DVD から 2 番目のタイトルをダンプするには次のようにします。</para>

	  <screen>&prompt.root; <userinput>mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</userinput></screen>

	  <para>出力された <filename>out.vob</filename> ファイルは
	    MPEG 形式で、
	    この節で説明される他のアプリケーションで編集できます。</para>

	</sect4>

	<sect4 id="video-mencoder">
	  <title>mencoder</title>
	  <indexterm>
	    <primary>mencoder</primary>
	  </indexterm>

	  <para><command>mencoder</command> を使う前に、
	    HTML 文書を読んでオプションに慣れておくのはよい考えです。
	    マニュアルもありますが、HTML 文書なしではあまり有用ではありません。
	    品質向上、低ビットレート、形式変換をする方法が無数にあります。
	    これらの要素の調節具合で、性能が良かったり悪かったりするなど、
	    結果に違いが出るかもしれません。
	    ここにいくつか例を示します。
	    はじめは単純なファイルのコピーです。</para>

	 <screen>&prompt.user; <userinput>mencoder <replaceable>input.avi</replaceable> -oac copy -ovc copy -o <replaceable>output.avi</replaceable></userinput></screen>

	  <para>コマンドラインオプションを不適切に組合せると、
	    <command>mplayer</command>
	    でさえ再生できない出力ファイルを作成してしまいます。
	    したがって、単にファイルを抽出したいときには、
	    <command>mplayer</command> に <option>-dumpfile</option>
	    オプションをつけます。</para>

	  <para><filename><replaceable>input.avi</replaceable></filename>
	    を音声に MPEG3 エンコードを使用して
	    MPEG4 コーデックに変換するには次のようにします
	    (<filename role="package">audio/lame</filename> が必要です)。</para>

	 <screen>&prompt.user; <userinput>mencoder <replaceable>input.avi</replaceable> -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o <replaceable>output.avi</replaceable></userinput></screen>

	  <para>これは <command>mplayer</command> や
	    <command>xine</command> で再生可能な出力ファイルを作成します。</para>

	  <para>DVD タイトルを直接再エンコードするためには、
	    上記のコマンドラインの
	    <filename><replaceable>input.avi</replaceable></filename> を
	    <option>dvd://1 -dvd-device /dev/dvd</option> に置き換えて、
	    <username>root</username> 権限で実行します。
	    はじめの作業結果に不満をもつと思われるので、
	    タイトルをファイルにダンプして、ファイルに対して作業することを
	    おすすめします。</para>
	</sect4>

      </sect3>

      <sect3 id="video-xine">
	<title>xine ビデオプレイヤ</title>

	<para><application>xine</application> ビデオプレイヤは
	  オールインワンのビデオソリューションであるだけでなく、
	  プラグインで拡張できる再利用可能な基本ライブラリと
	  実行可能なモジュールを提供する広範囲のプロジェクトです。
	  <filename role="package">multimedia/xine</filename> の
	  port と package の両方からインストールできます。</para>

	<para><application>xine</application> プレイヤは開発途上であり
	  まだ非常に荒削りですが、通常の利用には十分安定しています。
	  実用上、<application>xine</application>
	  を使用するには高速なビデオカードとともに高速な CPU があるか、
	  またはビデオカードが XVideo 拡張に対応していることが必要です。
	  GUI も利用できますがすこし扱いにくいです。</para>

	<para>この文書を執筆している時点では、
	  <application>xine</application> と一緒に提供されている
	  CSS エンコードされた DVD を再生する入力モジュールはありません。
	  このモジュールがあるサードパーティの構築物はいくつかありますが、
	  これらのどれも FreeBSD の Ports Collection には収録されていません。</para>

	<para><application>xine</application> は
	  <application>MPlayer</application> と比べて
	  利用者にとって多くのことをしてくれますが、
	  と同時にきめの細かい制御ができません。なお、
	  <application>xine</application> ビデオプレイヤは、
	  XVideo インタフェース上で最良の性能を発揮します。</para>

	<para>デフォルトでは、<application>xine</application> プレイヤは
	  GUI 付きで起動するでしょう。
	  その後、メニューを使用して特定のファイルを開くことができます。</para>

	<screen>&prompt.user; <userinput>xine</userinput></screen>

	<para>GUI なしでファイルを直ちに再生するには、
	  次のコマンドを実行します。</para>

      <screen>&prompt.user; <userinput>xine -g -p <replaceable>mymovie.avi</replaceable></userinput></screen>

      </sect3>

      <sect3 id="video-ports-transcode">
	<title>transcode ユーティリティ</title>

	<para><application>transcode</application> というソフトウェアは、
	  プレイヤではなくビデオおよびオーディオファイルを再エンコードするためのツール一式です。
	  <application>transcode</application> を使えば、
	  <filename>stdin/stdout</filename> インタフェースとともに
	  コマンドラインツールを用いることによって、
	  ビデオファイルの統合や、壊れたファイルの修復ができます。</para>

	<para><filename role="package">multimedia/transcode</filename> port
	  では、数多くのビルドオプションを指定できますが、
	  以下のコマンドラインのように <application>transcode</application>
	  を構築することをおすすめします。</para>

	<screen>&prompt.root; <userinput>make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes</userinput></screen>

	<para>ほとんどのユーザにとっては、この設定で十分です。</para>

	<para><command>transcode</command> の能力を示す例として、DivX ファイルを
	  PAL MPEG-1 (PAL VCD) ファイルに変換する使用例を示します。</para>

      <screen>&prompt.user; <userinput>transcode -i <replaceable>input.avi</replaceable> -V --export_prof vcd-pal -o output_vcd</userinput>
&prompt.user; <userinput>mplex -f 1 -o <replaceable>output_vcd.mpg output_vcd.m1v output_vcd.mpa</replaceable></userinput></screen>

	<para>作成された MPEG ファイル、
	  <filename><replaceable>output_vcd.mpg</replaceable></filename> は、
	  <application>MPlayer</application> を使って再生できます。
	  また、ファイルを CD-R メディアに書き込むことでビデオ CD も作成できます。
	  この場合には、<filename role="package">multimedia/vcdimager</filename>
	  および <filename role="package">sysutils/cdrdao</filename>
	  プログラムをインストールする必要があるでしょう。</para>

	<para><command>transcode</command> のマニュアルもありますが、
	  <ulink url="http://www.transcoding.org/cgi-bin/transcode">transcode
	    wiki</ulink> から、更なる情報や使用例を得てください。</para>
      </sect3>

    </sect2>

    <sect2 id="video-further-reading">
      <title>さらに進んだ情報</title>

      <para>FreeBSD 用のさまざまなビデオソフトウェアは急速に成長しています。
	近い将来、ここにあげた問題の多くが解決している可能性は高いでしょう。
	それまでの間、FreeBSD の A/V 能力を最大限発揮させたい人々は、
	FAQ およびチュートリアルから得た知識を寄せ集めて、
	わずかなアプリケーションを使用しなければならないでしょう。
	この節は、読者に
	そのような付加的な情報へのポインタを提供するために存在します。</para>

      <para><ulink url="http://www.mplayerhq.hu/DOCS/">MPlayer の文書</ulink>
	は技術的に非常に有益です。
	おそらく、&unix; ビデオの高水準な専門的知識を得たい人はすべて、
	これらの文書を調べるべきです。
	<application>MPlayer</application>
	メーリングリストを購読している人たちは、
	文書を面倒がって読まない人には、それが誰であれ反感を持ちます。
	そのため、彼らにバグ報告をするときには、マニュアルを読んでください。</para>

      <para>
	<ulink url="http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html">xine HOWTO</ulink>
	にはすべてのプレイヤに一般的な性能向上についての章が含まれています。</para>

      <para>最後に、読者が試みるかもしれない
	有望なアプリケーションをいくつかあげます。</para>

      <itemizedlist>

	<listitem>
	  <para>
	    <ulink url="http://avifile.sourceforge.net/">Avifile</ulink>.
	    port が <filename role='package'>multimedia/avifile</filename>
	    にあります。</para>
	</listitem>

	<listitem>
	  <para>
	    <ulink url="http://www.dtek.chalmers.se/groups/dvd/">Ogle</ulink>.
	    port が <filename role='package'>multimedia/ogle</filename>
	    にあります。</para>
	</listitem>

	<listitem>
	  <para><ulink url="http://xtheater.sourceforge.net/">Xtheater</ulink>.</para>
	</listitem>

	<listitem>
         <para><filename role="package">multimedia/dvdauthor</filename>. DVD
	    コンテンツをオーサリングするためのオープンソースパッケージです。</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="tvcard">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Josef</firstname>
	  <surname>El-Rayes</surname>
	  <contrib>原作: </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>改訂: </contrib>
	  <!-- 02 January 2004 -->
	</author>
      </authorgroup>
    </sect1info>

    <title>TV カードの設定</title>
    <indexterm>
      <primary>TV カード</primary>
    </indexterm>

    <sect2>
      <title>はじめに</title>

      <para>TV カードを使用することで、
	TV 放送をコンピュータで見ることができます。
	これらの多くは RCA コンポジットまたは S-video 入力端子を備えており、
	FM ラジオチューナを装備したカードもあります。</para>

      <para>&os; は
	Brooktree Bt848/849/878/879 または Conexant CN-878/Fusion 878a
	をビデオキャプチャチップに採用した PCI TV カードに &man.bktr.4;
	ドライバで対応しています。
	対応しているチューナを搭載したボードかどうかを &man.bktr.4;
	マニュアルページの一覧を参照して確認してください。</para>
    </sect2>

    <sect2>
      <title>ドライバの追加</title>

      <para>TV カードを使用するために &man.bktr.4;
	ドライバを読み込む必要があります。
	<filename>/boot/loader.conf</filename>
	ファイルに以下の行を追加してください。</para>

      <programlisting>bktr_load="YES"</programlisting>

      <para>あるいは、カーネルにドライバを静的に組み込むこともできます。
	この場合、次の行をカーネルコンフィギュレーションファイルに追加します。</para>

      <programlisting>device	 bktr
device	iicbus
device	iicbb
device	smbus</programlisting>

      <para>カードコンポーネントは I2C バス経由で連結されているため、
	&man.bktr.4; ドライバに加えてこれらのデバイスドライバが必要になります。
	編集したら新しいカーネルを構築し、インストールします。</para>

      <para>システムにドライバを追加したら、計算機を再起動してください。
	起動時に TV カードは以下のように認識されるでしょう。</para>

      <programlisting>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</programlisting>

      <para>もちろん、これらのメッセージはハードウェアに応じて異なります。
	とはいえ、チューナが正しく検知されているかどうか確認するべきです。
	&man.sysctl.8; による MIB の設定や、
	カーネルコンフィギュレーションファイルオプションで、
	検知されたいくつかのパラメータを変更できます。
	たとえば、チューナを Philips SECAM チューナとして検知されるようにするには、
	カーネルコンフィギュレーションファイルに以下の行を追加します。</para>

      <programlisting>options OVERRIDE_TUNER=6</programlisting>

      <para>または、直接 &man.sysctl.8; を使用して変更します。</para>

      <screen>&prompt.root; <userinput>sysctl hw.bt848.tuner=6</userinput></screen>

      <para>利用可能なオプションの詳細については &man.bktr.4;
	マニュアルページおよび <filename>/usr/src/sys/conf/NOTES</filename>
	ファイルを参照してください。</para>
    </sect2>

    <sect2>
      <title>便利なアプリケーション</title>

      <para>TV カードを使用するためには、以下のアプリケーションの一つをインストールする必要があります。</para>

      <itemizedlist>
	<listitem>
	  <para><filename role="package">multimedia/fxtv</filename>
	    はウィンドウ内に TV 映像を映します。
	    画像/音声/ビデオを取り込むこともできます。</para>
	</listitem>
	<listitem>
	  <para><filename role="package">multimedia/xawtv</filename>
	    も TV アプリケーションです。
	    <application>fxtv</application> と同様の機能があります。</para>
	</listitem>
	<listitem>
	  <para><filename role="package">misc/alevt</filename>
	    は文字放送 (ビデオテキスト/テレテキスト) のデコードと表示をします。</para>
	</listitem>
	<listitem>
	  <para><filename role="package">audio/xmradio</filename>
	    は TV カードに搭載された FM ラジオチューナを使用するためのアプリケーションです。</para>
	</listitem>
	<listitem>
	  <para><filename role="package">audio/wmtune</filename>
	    はラジオチューナのためのお手軽なデスクトップアプリケーションです。</para>
	</listitem>
      </itemizedlist>

      <para>他にも多くのアプリケーションが &os; Ports Collection に収録されています。</para>
    </sect2>

    <sect2>
      <title>トラブルシューティング</title>

      <para>TV カードに関する問題が起きたときには、
	&man.bktr.4; ドライバが本当にビデオキャプチャチップおよびチューナに
	対応しているか、オプションが正しく設定されているかどうかをまず確認してください。
	TV カードに関するサポートやさまざまな質問に関しては、
	&a.multimedia.name; メーリングリストに参加したり、
	過去のアーカイブを検索してみてください。</para>
    </sect2>
  </sect1>

  <sect1 id="mythtv">
    <title>MythTV</title>

    <para>MythTV はオープンソースの <acronym
      role="Personal Video Recorder">PVR</acronym>
      ソフトウェアプロジェクトです。</para>

    <para>このアプリケーションは、たくさんのアプリケーションやライブラリに依存するため、
      &linux; の世界ではインストールが難しいアプリケーションとして認識されています。
      &os; ports システムは、インストールのほとんどのプロセスを自動化しますが、
      ある部分は手動で設定しなければなりません。
      この章は、MythTV の設定を助けるためのガイドです。</para>

    <sect2>
      <title>ハードウェア</title>

      <para>MythTV は、エンコーダやチューナなどのビデオ入力デバイスへのアクセスに
	<acronym role="Video for Linux">V4L</acronym> を用いるように設計されています。
	現時点では、<filename
        role="package">multimedia/webcamd</filename> によりサポートされている
	<acronym role="Universal Serial Bus">USB</acronym> DVB-S/C/T
	カードにおいて最もよく動作します。
	なぜならば、<application>webcamd</application> は、<acronym
        role="Video for Linux">V4L</acronym>
	ユーザランドアプリケーションを提供するためです。
	<application>webcamd</application> に対応している
        <acronym role="Digital Video Broadcasting">DVB</acronym>
	カードは、MythTV で動作するはずです。
	動作することが知られているカードの一覧が <ulink
        url="http://wiki.freebsd.org/WebcamCompat">ここ</ulink>
	にあります。
	Hauppauge カードもまた、
	<filename role="package">multimedia/pvr250</filename>
        および <filename role="package">multimedia/pvrxxx</filename>
	package として利用可能ですが、 
	標準的ではないドライバのインタフェースを提供しており、
	0.23 より後の MythTV では動作しません。</para>

      <para><ulink url="http://wiki.freebsd.org/HTPC">HTPC</ulink>
	は、<acronym role="Digital Video Broadcasting">DVB</acronym>
	ドライバのすべての一覧を提供しています。</para>
    </sect2>
    
    <sect2>
      <title>依存性</title>

      <para>MythTV は、柔軟で、モジュール化されており、
	異なるコンピュータでフロントエンドとバックエンドを利用できます。</para>

      <para>フロントエンドとしては <filename
        role="package">x11/xorg</filename> の X サーバとともに <filename
        role="package">multimedia/mythtv-frontend</filename> が必要です。
	フロントエンドコンピュータは、<acronym
        role="X-Video Motion Compensation">XvMC</acronym>
	に対応しているビデオカードを持ち、オプションとして、<acronym
        role="Linux Infrared Remote Control">LIRC</acronym>
	互換のリモートコントローラを持っていることが理想的です。</para>

      <para>バックエンドでは、&mysql; データベースとともに <filename
        role="package">multimedia/mythtv</filename> が必要です。
	オプションで、録音のためにはチューナ、ストレージが必要です。
        &mysql; package は、<filename
        role="package">multimedia/mythtv</filename> のインストール時に、
	依存として自動的にインストールされます。</para>
    </sect2>

    <sect2>
      <title>MythTV の設定</title>

      <para>以下のステップで、MythTV をインストールしてください。
	まず &os; Ports Collection を用いて、
	MythTV をインストールしてください。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/multimedia/mythtv</userinput>
&prompt.root; <userinput>make install</userinput></screen>

      <para>MythTV データベースを設定してください。</para>

      <screen>&prompt.root; <userinput>mysql -uroot -p < /usr/local/share/mythtv/database/mc.sql</userinput></screen>

      <para>バックエンドを設定してください。</para>

      <screen>&prompt.root; <userinput>mythtv-setup</userinput></screen>

      <para>バックエンドを起動してください。</para>

      <screen>&prompt.root; <userinput>echo 'mythbackend_enable="YES"' >> /etc/rc.conf</userinput>
&prompt.root; <userinput>/usr/local/etc/rc.d/mythbackend start</userinput></screen>
    </sect2>
  </sect1>

  <sect1 id="scanners">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>寄稿: </contrib>
	  <!-- 04 August 2004 -->
	</author>
      </authorgroup>
    </sect1info>

    <title>画像スキャナ</title>
    <indexterm>
      <primary>画像スキャナ</primary>
    </indexterm>

    <sect2>
      <title>はじめに</title>

      <para>&os; では、画像スキャナに対するアクセスは
	<application>SANE</application> (Scanner Access Now Easy)
	<acronym role="Application Programming Interface">API</acronym>
	によって実現されており、
	&os; Ports Collection でも提供されています。
	<application>SANE</application>
	はスキャナのハードウェアにアクセスするために
	&os; デバイスドライバを使用します。</para>

      <para>&os; は
	SCSI 接続および USB 接続のスキャナのどちらにも対応しています。
	設定を始める前に、
	<application>SANE</application>
	がスキャナに対応しているか確認してください。
	<application>SANE</application> には
	スキャナについての情報とその状況がまとめられている <ulink
	  url="http://www.sane-project.org/sane-supported-devices.html">対応デバイスの一覧</ulink>
	があります。&os;&nbsp;8.X より前のシステムでは、
	&os; の &man.uscanner.4;
	マニュアルページにも対応 USB スキャナの一覧が記載されています。</para>
    </sect2>

    <sect2>
      <title>カーネルのコンフィグレーション</title>

      <para>前述のように、&os はスキャナのインタフェースとして
	SCSI と	USB の両方に対応しています。
	スキャナのインタフェースによって、必要となるドライバが異なります。</para>

      <sect3 id="scanners-kernel-usb">
	<title>USB インタフェース</title>

	<para><filename>GENERIC</filename> カーネルにはデフォルトで
	  USB スキャナに対応するためのデバイスドライバが搭載されています。
	  カスタムカーネルを使用する際には、
	  以下の行がカーネルコンフィグレーションファイルにあることを
	  確認してください。</para>

	<programlisting>device usb
device uhci
device ohci
device ehci</programlisting>

	<para>&os;&nbsp;8.X
	  より前のシステムでは以下の行も必要となります。</para>

	<programlisting>device uscanner</programlisting>

	<para>このバージョンの &os; では、&man.uscanner.4;
	  デバイスドライバが USB スキャナへのアクセスを提供しています。
	  &os;&nbsp;8.0 以降では、&man.libusb.3;
	  ライブラリが直接提供します。</para>

	<para>適切なドライバを組み込んだカーネルで再起動後、
	  USB スキャナをシステムに接続します。
	  すると、メッセージバッファ (&man.dmesg.8;)
	  にスキャナが認識されたことを示すメッセージが出力されます。</para>

	<screen>ugen0.2: &lt;EPSON&gt; at usbus0</screen>

	<para>&os;&nbsp;7.X システムでは、
	  以下のようなメッセージが出力されます。</para>

	<screen>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</screen>

	<para>これらの例では、使用している &os; のバージョンに応じて、
	  スキャナが <filename>/dev/ugen0.2</filename>
	  または、<filename>/dev/uscanner0</filename>
	  デバイスノードを使用していることがわかります。
	  この例では、&epson.perfection;&nbsp;1650 USB スキャナが使われています。</para>
      </sect3>

      <sect3>
	<title>SCSI インタフェース</title>

	<para>スキャナに付属しているインタフェースが SCSI であれば、
	  重要なのはどの SCSI ボードを使用すればよいか把握することです。
	  使用する SCSI チップセットによって、
	  カーネルコンフィグレーションファイルを調整する必要があります。
	  <filename>GENERIC</filename> カーネルは
	  一般に使用される SCSI コントローラのほとんどに対応しています。
	  <filename>NOTES</filename> ファイルを読んで、
	  適切な行をカーネルコンフィグレーションファイルに追加してください。
	  また、SCSI アダプタドライバに加えて、
	  以下の行をカーネルコンフィグレーションファイルに
	  記述する必要があります。</para>

	<programlisting>device scbus
device pass</programlisting>

	<para>カーネルを適切にコンパイルしてインストールすると、
	  システムの起動時にデバイスがメッセージバッファに出力されるはずです。</para>

	<screen>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</screen>

	<para>システムを起動する際にスキャナの電源を入れてなければ、
	  &man.camcontrol.8; コマンドを使用して SCSI バスをスキャンし、
	  以下のように手動でデバイスを検出させることもできます。</para>

	<screen>&prompt.root; <userinput>camcontrol rescan all</userinput>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</screen>

	<para>すると、スキャナは SCSI デバイスの一覧に現れるでしょう。</para>

	<screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 (pass0,da0)
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 (pass1,da1)
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 (pass3)
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 (pass2,cd0)</screen>

	<para>SCSI デバイスについての詳細は、&man.scsi.4; および
	  &man.camcontrol.8; のマニュアルページをご覧ください。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>SANE の設定</title>

      <para><application>SANE</application> システムは、
	二つの部分、すなわちバックエンド
	(<filename role="package">graphics/sane-backends</filename>)
	とフロントエンド
	(<filename role="package">graphics/sane-frontends</filename>)
	に分割されています。
	バックエンドはスキャナそのものに対するアクセスを提供します。
	<application>SANE</application> の <ulink
	url="http://www.sane-project.org/sane-supported-devices.html">
	対応デバイスの一覧</ulink>
	には、どのバックエンドが画像スキャナに対応しているかが記載されています。
	デバイスを使用するためには、正しいバックエンドを決定するのは必須です。
	また、フロントエンドはグラフィカルなスキャニングインタフェース
	(<application>xscanimage</application>)
	を提供します。</para>

      <para>はじめに、
	<filename role="package">graphics/sane-backends</filename>
	の port または package をインストールしましょう。
	次に、<command>sane-find-scanner</command> コマンドを使用して、
	<application>SANE</application>
	システムで使用するバックエンドを検出します。</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3</screen>

      <para>この出力から、
	スキャナインタフェースの種類と
	システムに接続されているスキャナが使用するデバイスノードがわかります。
	ベンダ名や製品のモデル名は表示されないかも知れませんが、
	重要ではありません。</para>

      <note>
	<para>USB
	  スキャナではファームウェアを読み込む必要がある場合があります。
	  これはバックエンドのマニュアルページで説明されています。
	  &man.sane-find-scanner.1; と
	  &man.sane.7; のマニュアルページも読んでください。</para>
      </note>

      <para>スキャナがフロントエンドで認識されるか調べてみましょう。
	デフォルトでは、<application>SANE</application> のバックエンドには
	&man.scanimage.1; と呼ばれるコマンドラインツールが付属します。
	このコマンドを使用すると、
	デバイスの一覧を表示したり画像を取得することができます。
	<option>-L</option> オプションを使うと、
	スキャナデバイスの一覧が出力されます。</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner</screen>

      <para>また、<xref linkend="scanners-kernel-usb">
	で使用した USB スキャナの例では、以下の出力が得られるでしょう。</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device 'epson2:libusb:/dev/usb:/dev/ugen0.2' is a Epson GT-8200 flatbed scanner</screen>

      <para>これは、&os;&nbsp;8.X システムでの出力例であり、
	<literal>'epson2:libusb:/dev/usb:/dev/ugen0.2'</literal> から、
	使用しているスキャナのバックエンド名
	(<literal>epson2</literal>) とデバイスノード
	(<literal>/dev/ugen0.2</literal>) の情報を得ることができます。</para>

      <note>
      <para>何も出力が得られなかったり、
	スキャナが見つからなかったというメッセージが表示されたら、
	&man.scanimage.1; はスキャナを認識できなかったのでしょう。
	このような場合は、バックエンドの設定ファイルを編集し、
	使用するスキャナデバイスを定義する必要があります。
	<filename class="directory">/usr/local/etc/sane.d/</filename>
	ディレクトリには、
	バックエンドが使用するすべての設定ファイルがあります。
	このデバイスの認識による問題は、
	特定の USB スキャナで発生するものです。</para>

      <para>たとえば、
	<xref linkend="scanners-kernel-usb">
	で使用した USB スキャナは、
	&os;&nbsp;8.X において正常に認識され動作します。
	しかし、それより前のバージョンの
	(&man.uscanner.4; ドライバを利用する) &os; では、
	<command>sane-find-scanner</command>
	コマンドを実行すると、以下のような情報が得られます。</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found USB scanner (UNKNOWN vendor and product) at device /dev/uscanner0</screen>
      <para>スキャナは正しく検出されました。
	USB インタフェースを使用し、
	<filename>/dev/uscanner0</filename>
	デバイスノードに接続されていることがわかります。
	次に、スキャナが正しく認識されているかどうか確認してみましょう。</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).</screen>

      <para>スキャナが認識されなかったので、
	<filename>/usr/local/etc/sane.d/epson2.conf</filename>
	ファイルを編集する必要があります。
	このスキャナのモデルは &epson.perfection;&nbsp;1650 なので、
	<literal>epson2</literal> バックエンドを使用すればいいことがわかります。
	バックエンドの設定ファイルに書かれているコメントを必ず読んでください。
	設定ファイルを変更するのは非常に簡単です。
	使用しているスキャナには不適切なインタフェースをすべてコメントアウトし
	(今回の場合は、USB インタフェースを使用するので <literal>scsi</literal>
	という語で始まる行をすべてコメントアウトします)、
	ファイルの末尾に使用するインタフェースとデバイスノードを追加します。
	この例では、以下の行を追加しました。</para>

      <programlisting>usb /dev/uscanner0</programlisting>

      <para>詳細と使用すべき構文は、
	バックエンドのマニュアルページはもちろんのこと、
	バックエンドの設定ファイルに書かれているコメントも読んでください。
	以上の設定で、スキャナが認識されたかどうかを確認できます。</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner</screen>

      <para>USB スキャナが認識されました。
	ブランドやモデルがスキャナに一致しなかったとしても、それほど重要ではありません。
	着目すべきは <literal>`epson:/dev/uscanner0'</literal> という部分で、
	バックエンド名とデバイスノードが正しく認識されていることがわかります。</para>
      </note>

      <para><command>scanimage -L</command>
	コマンドを実行してスキャナが認識されたことがわかれば、設定は終了です。
	デバイスはスキャンする準備ができました。</para>

      <para>&man.scanimage.1; コマンドを使用すると
	コマンドラインから画像を取得することができます。その一方で、
	GUI を使用して画像を取得できると一層良いでしょう。
	<application>SANE</application>
	は、簡素ですが役に立つグラフィカルなインタフェース
	<application>xscanimage</application>
	(<filename role="package">graphics/sane-frontends</filename>)
	を提供しています。</para>

      <para><application>Xsane</application>
	(<filename role="package">graphics/xsane</filename>)
	はもう一つのグラフィカルなスキャニングフロントエンドで、
	人気があります。
	<application>Xsane</application>
	には、さまざまなスキャニングモード (写真、FAX など)、
	色補正、バッチスキャンなど先進的な機能があります。
	これらのアプリケーションの両方とも <application>GIMP</application>
	のプラグインとして使用することができます。</para>
    </sect2>

    <sect2>
      <title>他のユーザがスキャナにアクセスすることを許可する</title>

      <para>前述の操作には、
	すべて <username>root</username> 権限が必要となります。
	しかしながら、他のユーザがスキャナに
	アクセスできるようにすることも可能です。
	そのためには、スキャナが使用するデバイスノードへの
	読み込み権限と書き込み権限をユーザに与えます。
	一例として、USB スキャナが、<filename>/dev/ugen0.2</filename>
	デバイスノードを使用しているものとします。
	このデバイスノードは、
	<filename>/dev/usb/0.2.0</filename> へのシンボリックリンクです
	(<filename class="directory">/dev</filename> ディレクトリを調べると、
	簡単に確認できます)。
	シンボリックリンクとデバイスノードは、
	それぞれ <groupname>wheel</groupname> および
	<groupname>operator</groupname> グループが所有しています。
	ユーザ <username><replaceable>joe</replaceable></username> を
	これらのグループに加えると、彼はスキャナを使用できるようになります。
	もちろん、ユーザをどんなグループ
	(特にグループ <groupname>wheel</groupname>) に追加する時はいつでも、
	セキュリティ上の理由から二度は検討を行うべきです。
	良い方法は、USB デバイスを利用するためにグループを作成し、
	このグループに対してスキャナデバイスを利用できるようにすることです。</para>

      <para>例として、<groupname><replaceable>usb</replaceable></groupname>
	という名前のグループを使用します。
	まず最初に、&man.pw.8; コマンドを使ってグループを作成します。</para>

      <screen>&prompt.root; <userinput>pw groupadd usb</userinput></screen>

      <para>その後、シンボリックリンク <filename>/dev/ugen0.2</filename> 
	および、<filename>/dev/usb/0.2.0</filename> デバイスノードに対して、
	<groupname>usb</groupname> グループが利用できるように適切な許可属性
	(<literal>0660</literal> または	<literal>0664</literal>)
	を設定する必要があります。
	デフォルトでは、これらのファイルの所有者
	(<username>root</username>) のみが書き込み可能です。
	<filename>/etc/devfs.rules</filename>
	に次の行を追加してください。</para>

      <programlisting>[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb</programlisting>

      <para>&os;&nbsp;7.X のユーザは、デバイスノード
	<filename>/dev/uscanner0</filename> に対し、
	以下のような行の追加が必要となるでしょう。</para>

      <programlisting>[system=5]
add path uscanner0 mode 660 group usb</programlisting>

      <para>次に、<filename>/etc/rc.conf</filename> に以下の行を追加して
	システムを再起動します。</para>

      <programlisting>devfs_system_ruleset="system"</programlisting>

      <para><filename>/etc/devfs.rules</filename>
	で設定した内容についての詳細は、&man.devfs.8;
	のマニュアルページをご覧ください。</para>

      <para>最後に、スキャナを利用するユーザを
	<groupname><replaceable>usb</replaceable></groupname>
	グループに追加します。</para>

      <screen>&prompt.root; <userinput>pw groupmod usb -m <replaceable>joe</replaceable></userinput></screen>

      <para>詳細については、&man.pw.8; のマニュアルページをご覧ください。</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
