<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.114
     $FreeBSD$
-->

<chapter id="ports">
  <title>アプリケーションのインストール - packages と ports</title>

  <sect1>
    <title>この章では</title>

    <para>FreeBSD の基本システムだけでは、
      それほどたくさんのことを行うことはできません。
      もしあなたがオペレーティングシステムの開発者であれば、
      FreeBSD の基本システムにはあなたの望むすべてがあるでしょう。
      しかし、そのような利用を考えていなければ、
      &mdash; ウェブサーバ、メールリーダ、
      KDE または GNOME のようなグラフィカル環境、
      といったソフトウェアをインストールしようと思うでしょう。</para>

    <para>すでに Unix システムを使ったことのある人ならば、
      サードパーティ製ソフトウェアの典型的なインストール手順が
      以下のようになることをご存知でしょう。</para>

    <procedure>
      <step>
	<para>ソースコード、またはバイナリ形式で
	  配布されているソフトウェアをダウンロードする。</para>
      </step>

      <step>
        <para>配布時のフォーマット (一般的には
	  &man.compress.1; または &man.gzip.1; で圧縮された tarball)
	  からソフトウェアを取り出す。</para>
      </step>

      <step>
        <para>ドキュメントを探しだし
	  (おそらく <filename>README</filename> ファイル、あるいは
	  <filename>doc/</filename> サブディレクト中のファイル)、
	  ソフトウェアのインストール方法を調べる。</para>
      </step>

      <step>
	<para>ソース形式でソフトウェアが配布されている場合はコンパイルを行う。
	  ここでは、<filename>Makefile</filename> の編集、
	  または、<command>configure</command> スクリプトの実行、
	  あるいは他の作業を伴うことがある。 </para>
      </step>

      <step>
	<para>ソフトウェアの動作を確認し、インストールする。</para>
      </step>
    </procedure>

    <para>すべてがうまくいったならば、インストール作業は以上です。
      もしインストールしているソフトウェアパッケージが、
      FreeBSD を意識して移植されたものでなければ、
      適切に動くようコードを調べ、編集する必要があるかもしれません。</para>

    <para>あなたが望むのであれば、FreeBSD 上へのソフトウェアのインストールに
      <quote>従来</quote> の方法を使い続けることができます。
      しかしながら、FreeBSD は
      インストール時にかかるたくさんの労力を軽減する 2 つの技術、
      すなわち packages と ports を提供しています。
      この文書を書いている時点では、
      4,000 を越えるサードパーティ製アプリケーションがこれらの方法で
      利用可能となっています。</para>

    <para>FreeBSD package では、いかなるアプリケーションに対しても
      ダウンロードする必要のあるファイルはただ一つです。
      package には、コンパイル済みのアプリケーションの全コマンド、
      各種設定ファイルやドキュメントが含まれています。
      FreeBSD に用意されている
      &man.pkg.add.1;, &man.pkg.delete.1;, &man.pkg.info.1;
      といった <literal>pkg_*</literal> コマンドで、
      ダウンロードした package ファイルを扱うことができます。</para>

    <para>新しいアプリケーションをインストールするには、
      たった一つのコマンドを実行するだけです。</para>

    <para>FreeBSD port は、アプリケーションをソースコードからコンパイルする際の
      処理を自動化するように設計されたファイルの集まりです。</para>

    <para>プログラムをコンパイルする時のことを思い出して下さい。
      通常、とてもたくさんの手順
      (展開、パッチ作業、コンパイル、インストール)
      を踏まなくてはなりません。
      port を構成するファイルは、
      これらすべての作業をあなたの代わりに行うために必要な情報を含んでいます。
      いくつかの簡単なコマンドを実行すると、
      自動的にアプリケーションのソースコードがダウンロードされ、展開、
      パッチ作業、コンパイル、そして、インストール作業が行われます。</para>

    <para>さらに ports システムは、<literal>pkg_*</literal> コマンドで
      扱うことのできる packages を生成することもできます。</para>

    <para>packages と ports は<emphasis>依存関係</emphasis>を理解します。
      ある特定のライブラリに依存する
      アプリケーションをインストールするとします。
      また、アプリケーションとライブラリは FreeBSD ports や packages によって
      入手可能であるとします。
      アプリケーションを追加するために
      <command>pkg_add</command> コマンドまたは ports システムを用いると、
      インストールされていないライブラリが検出され、
      先に依存するライブラリがインストールされます。</para>

    <para>2 つの技術が非常に類似していて、
      なぜ FreeBSD がわざわざ両者を採用しているのか不思議に思うでしょう。
      packages と ports にはそれぞれ独自の特徴があり、
      どちらを使うかはあなたの好みによります。</para>

    <itemizedlist>
      <title>package の利点</title>

      <listitem>
	<para>一般的に、あるアプリケーションの package の tarball は、
          ソースコードを含む tarball より小さなサイズとなります。</para>
      </listitem>

      <listitem>
	<para>packages はコンパイル作業を必要としません。
	  このことは、<application>Mozilla</application>,
  	  <application>KDE</application>,
	  または <application>GNOME</application>
	  といった大きなアプリケーションで重要となります。
	  特にシステムが遅い場合にはなおさら重要です。</para>
      </listitem>

      <listitem>
	<para>packages を用いれば、
          ソフトウェアのコンパイルに関する知識は必要ありません。</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>ports の利点</title>

      <listitem>
	<para>packages は、通常最も多くのシステムで実行できるように、
          非常に保守的な設定で構築されています。
          port からインストールすることで、
          たとえば 686 プロセッサに特化したコードを生成するような
          コンパイルオプションを指定できます。 </para>
      </listitem>

      <listitem>
	<para>packages のなかには、コンパイル時に
	  プログラムの機能を決めるようなオプションを設定するものがあります。
	  たとえば、<application>Apache</application> は多種多様な
	  ビルトインオプションを設定できます。
	  port から構築することで、デフォルトオプションではなく、
	  自分でオプションを設定することができます。</para>

        <para>設定を区別するために、同じアプリケーションに対して
          複数の packages が存在することがあります。
          たとえば、<application>Ghostscript</application> は
          X11 サーバーがインストールされているかどうかにより、
          <filename>ghostscript</filename> package と
          <filename>ghostscript-nox11</filename> package
          が選択可能となっています。
          packages でもこのような方法が可能ですが、
          アプリケーションのコンパイルオプションが
          さらに用意されている場合は困難となります。</para>
      </listitem>

      <listitem>
        <para>ライセンス条項で、
        バイナリでの配布を禁止しているソフトウェアがあります。
        それらはソースコードで配布されなくてはいけません。</para>
      </listitem>

      <listitem>
        <para>バイナリ配布を信用していない人もいます。
         ソースコードがあれば、少なくともソースコードを読んで
	 (理論的には) 潜在的な問題点を自分で見つけ出すことができます。</para>
      </listitem>

      <listitem>
        <para>ローカルなパッチがある場合、
         それを適用するためにソースコードが必要になります。</para>
      </listitem>

      <listitem>
        <para>ソースコードを手元に置いておきたい人たちもいます。
          彼らは、退屈したときに眺めたり、あちこち解析してみたり、
          ソースコードを借用したり (もちろん、
          ライセンスが許せばの話ですが) するのです。</para>
      </listitem>
    </itemizedlist>

    <para>この章では、packages と ports を用いた FreeBSD 上での
       サードパーティ製ソフトウェアの
       インストール方法や管理方法について説明します。</para>
  </sect1>

  <sect1>
    <title>アプリケーションの探し方</title>

    <para>どんなアプリケーションをインストールするにしても、
      まずあなたが何を望んで、
      またその名前がなんというのかを理解している必要があります。</para>

    <para>FreeBSD 上で利用可能なアプリケーションのリストは常に増えています。
      現在 4,000 以上ものアプリケーションが
      packages または ports として利用可能です。
      あなたの望むものは多くの方法で探すことができます。</para>

    <itemizedlist>
      <listitem>
      <para>FreeBSD ウェブサイトは、
        利用可能なすべてのアプリケーションの検索できる最新の一覧を
        <ulink url="http://www.FreeBSD.org/ports/">http://www.FreeBSD.org/ports/</ulink>
        で公開しています。
        アプリケーションの名前はカテゴリに分類されており、
        (名前を知っているならば) 名前で検索できます。
        また、カテゴリ中の利用可能な
        すべてのアプリケーションを表示させることもできます。</para>
      </listitem>

      <listitem>
	<para>Dan Langille は
	  <ulink url="http://www.freshports.org/">http://www.freshports.org/</ulink>
          で FreshPorts を公開しています。
	  FreshPorts は ports ツリー中のアプリケーションの変更を追跡します。
	  一つまたはそれ以上の ports を <quote>監視</quote> することができ、
          変更があるとメールで更新情報を送ってくれます。</para>
      </listitem>

      <listitem>
	<para>ご希望のアプリケーションの名前がわからなければ、
	  FreshMeat
	  (<ulink url="http://www.freshmeat.net/">http://www.freshmeat.net/</ulink>)、
	  または、AppWatch
	  (<ulink url="http://www.appwatch.com/">http://www.appwatch.com/</ulink>)
	  のようなサイトでアプリケーションを探して下さい。
	  その後、そのアプリケーションが ports で利用可能かどうかを
           FreeBSD サイトで調べて下さい。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>packages システムの利用</title>

    <sect2>
      <title>package のインストール</title>

      <para>インストールするアプリケーションを決めたら、
        package ファイルをダウンロードしてインストールすることになります。</para>

      <para>これを行う方法はいくつかあります。</para>

      <example>
	<title>さまざまな方法によるダウンロードとインストール</title>

	<para></para>
      </example>
    </sect2>

    <sect2>
      <title>package の削除</title>

      <para></para>
    </sect2>

    <sect2>
      <title>package の更新</title>

      <para></para>
   </sect2>

    <sect2>
      <title></title>

      <para></para>
    </sect2>
  </sect1>

  <sect1 id="ports-using">
    <title>Ports Collection の利用</title>

    <para>このセクションでは、Ports Collection
      を利用してシステムにプログラムをインストールしたり、
      システムから削除したりする基本的な手順について説明します。</para>

    <sect2 id="ports-skeleton">
      <title>ports のインストール</title>

      <para>一番最初に知らなければならないのは、
        Ports Collection は <quote>スケルトン</quote>
        と呼ばれるもので構成されているという事実です。
        port スケルトンは簡単に言うと、アプリケーションを FreeBSD
        上でコンパイルしインストールするために必要となる最小限のファイルのセットのことです。
        それぞれの port スケルトンには、次のファイルが含まれています。
      </para>

      <itemizedlist>
	<listitem>
	  <para><filename>Makefile</filename>。
	    <filename>Makefile</filename>
            にはアプリケーションのコンパイル方法やシステムのどこにインストールするかを指定する、
            さまざまな命令文が含まれています。</para>
	</listitem>

	<listitem>
	  <para><filename>distinfo</filename> ファイル。
            このファイルには、その port を構築するために
            ダウンロードする必要があるファイルのファイル名と、
            そのファイルがダウンロードによって壊れていないか
            チェックするためのチェックサム情報が含まれています。</para>
	</listitem>

	<listitem>
	  <para><filename>files</filename> ディレクトリ。
            このディレクトリには FreeBSD
            システム上でプログラムをコンパイルし、
            インストールするための修正パッチが含まれています。
            修正パッチ (patch) とは基本的に、
            個々のファイルに対する変更点を表した小さなファイル群のことです。
            ファイルはプレインテキスト形式で、
            <quote>10 行目を削除</quote> や
            <quote>26 行目を ... に変更</quote> などと書かれています。
            修正パッチは、<quote>diff (差分)</quote> とも呼ばれます。
            これは、修正パッチが <application>diff</application>
            プログラムで作成されるからです。</para>

	  <para>このディレクトリには、その port の構築に必要な
            その他のファイルが入る場合もあります。</para>
	</listitem>

        <listitem>
          <para><filename>pkg-comment</filename> ファイル。
            これにはプログラムの一行説明文が含まれています。</para>
        </listitem>

        <listitem>
          <para><filename>pkg-descr</filename> ファイル。
            これにはプログラムの、複数行にわたる詳しい説明文が含まれます。</para>
        </listitem>

        <listitem>
          <para><filename>pkg-plist</filename> ファイル。
            これは、その port によってインストールされる全ファイルのリストです。
            これにはプログラムを削除する際に、
            どのファイルを削除すれば良いのかを ports
            システムに伝える役割もあります。</para>
        </listitem>
      </itemizedlist>

      <para>さて、Ports Collection が何を目的として使われるものなのか、
        それ理解するための基礎的な知識はこれで十分です。
        最初の port をインストールする準備ができました。
        port のインストールには二つの方法があります。
      </para>
      <!-- 2000/07/16:hrs - strange translation -->

      <para>実際の作業に入る前に、
        インストールする port を選ぶ必要があります。
        選ぶ方法はいくつかありますが、最も簡単なのは
        <ulink url="http://www.freebsd.org/ports/">FreeBSD ウェブサイトの
          ports リスト</ulink>を利用することでしょう。
        そこにリストされている ports や、
        サイトの検索機能を使って閲覧することができます。
        各々の port には説明文が含まれていますので、
        インストールを決める前にその port
        に関する説明を読むこともできます。
      </para>
        
      <para>もう一つの方法は、<command>whereis</command>
        コマンドを使うことです。
        <command>whereis</command> コマンドを使うには、
        プロンプトから単に
        <quote><command>whereis &lt;インストールしたいプログラム名&gt;</command></quote>
        と入力します。
        もし、あなたのシステム上でプログラムが見つかれば、
        それがどこにあるのかが次のように表示されます。
      </para>

      <screen>&prompt.root; <userinput>whereis xchat</userinput>
xchat: /usr/ports/irc/xchat
&prompt.root;</screen>

      <para>この表示は、xchat (irc クライアントの一つ) が
        <filename>/usr/ports/irc/xchat</filename>
        というディレクトリに見つかったことを示しています。
      </para>

      <para>また、Ports Collection の持つ検索機能を利用して
        port を検索する方法もあります。
        この検索機能を利用するには、カレントディレクトリが
        <filename>/usr/ports</filename> である必要があります。
        そのディレクトリに移動したら、
        <command>make search key=プログラム名</command>
        と入力してください。
        <quote>プログラム名</quote> の部分には検索したいプログラム名を入れます。
        たとえば、xchat を探したい場合には次のようにします。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make search key=xchat</userinput>
Port:   xchat-1.3.8
Path:   /usr/ports/irc/xchat
Info:   An X11 IRC client using the GTK+ toolkit, and optionally, GNOME
Maint:  jim@FreeBSD.org
Index:  irc
B-deps: XFree86-3.3.5 bzip2-0.9.5d gettext-0.10.35 giflib-4.1.0 glib-1.2.6 gmake-3.77 gtk-1.2.6
		imlib-1.9.8 jpeg-6b png-1.0.3 tiff-3.5.1
R-deps: XFree86-3.3.5 gettext-0.10.35 giflib-4.1.0 glib-1.2.6 gtk-1.2.6 imlib-1.9.8 jpeg-6b
		png-1.0.3 tiff-3.5.1</screen>

      <para>出力のうち特に注意して見なければならないのは
        <quote>Path</quote> という行です。
        この行は xchat がどこにあるかを示しています。
        出力される他の情報は port
        をインストールする際には直接必要となるものではありませんので、
        ここでは触れないでおきます。</para>

      <note>
        <para>ports をインストールするには、
          <username>root</username> ユーザにならなければなりません。</para>
      </note>

      <para>インストールしたい port が見つかったら、
        実際のインストールに移ることができます。</para>

      <sect3 id="ports-cd">
        <title>CD-ROM からのコンパイル</title>

        <para>タイトルから想像できると思いますが、
          このセクションで説明する内容は、FreeBSD の
          CDROM セットを持っていることを前提としています。
          もし CDROM セットを持っていなければ、
          <ulink url="http://www.freebsdmall.com/">FreeBSD Mall</ulink>
          で注文することができます。</para>

        <para>FreeBSD CDROM がドライブに挿入されていて、
          <filename>/cdrom</filename>
          (マウントポイントは<emphasis>必ず</emphasis>
          <filename>/cdrom</filename> でないといけません)
          にマウントされていれば、port をインストールすることができます。
          まず、カレントディレクトリをインストールしたい port
          のあるディレクトリに変更してください。</para>

        <screen>&prompt.root; <userinput>cd /usr/ports/irc/xchat</userinput></screen>

        <para>xchat ディレクトリに移動すると、
          port スケルトンがあるのが確認できると思います。
          次に行なうのは、port のコンパイル
          (構築、ビルド (build) とも呼ばれます)
          です。
          これは、プロンプトから単に
          <command>make</command> と入力するだけで行なえます。
          そうすると、次のような出力が現われるはずです。</para>

        <screen>&prompt.root; <userinput>make</userinput>
&gt;&gt; xchat-1.3.8.tar.bz2 doesn't seem to exist on this system.
&gt;&gt; Attempting to fetch from file:/cdrom/ports/distfiles/.
===&gt;  Extracting for xchat-1.3.8
&gt;&gt; Checksum OK for xchat-1.3.8.tar.bz2.
===&gt;   xchat-1.3.8 depends on executable: bzip2 - found
===&gt;   xchat-1.3.8 depends on executable: gmake - found
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
===&gt;  Patching for xchat-1.3.8
===&gt;  Applying FreeBSD patches for xchat-1.3.8
===&gt;  Configuring for xchat-1.3.8
...
[configure output snipped]
...
===&gt;  Building for xchat-1.3.8
...
[compilation snipped]
...
&prompt.root;</screen>

        <para>コンパイルが終了してプロンプトに戻ることを確認してください。
          次に port をインストールを行ないます。
          port をインストールするのに必要なのは、
          <command>make</command> コマンドに一つの単語、
          <command>install</command> を指定することだけです。</para>

        <screen>&prompt.root; <userinput>make install</userinput>
===&gt;  Installing for xchat-1.3.8
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
...
[install routines snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Installing xchat docs in /usr/X11R6/share/doc/xchat
===&gt;   Registering installation for xchat-1.3.8
&prompt.root;</screen>

        <para>プロンプトに戻ったら、
          インストールしたプログラムは実行できるようになっています。</para>

        <note>
          <para><command>make</command>、<command>make install</command>
            と二つに分けられた手順の代わりに、
            最初から <command>make install</command> と実行することで、
            手順の二番目の操作を省くことができます。</para>
        </note>

        <note>
          <para>port には CDROM
            への収録を許可しないライセンス条項を持つものがあることに
            注意してください。
            これにはダウンロード前に登録を必要としたり、
            再配布が禁止されているなどというさまざまな理由があります。
            CDROM に含まれていない port をインストールしたい場合には、
            ネットワークに接続する必要があります
            (<link linkend="ports-inet">次のセクション</link>をご覧ください)。</para>
        </note>
      </sect3>

      <sect3 id="ports-inet">
        <title>インターネット経由での ports のコンパイル</title>

        <para>前セクションと同じように、このセクションでは、
          インターネットへの接続が可能であることを前提としています。
          もしインターネット接続が不可能な場合は、
          <link linkend="ports-cd">CDROM
            からのインストール</link>が必要になるでしょう。</para>

        <para>インターネット経由で port をインストールする方法は、
          CDROM からインストールする場合と完全に同じです。
          唯一異なる部分はプログラムのソースコードを CDROM からではなく、
          インターネット経由でダウンロードするということです。</para>

        <para>次のように、必要な手順は同じです。</para>

        <screen>&prompt.root; <userinput>make install</userinput>
&gt;&gt; xchat-1.3.8.tar.bz2 doesn't seem to exist on this system.
&gt;&gt; Attempting to fetch from http://xchat.org/files/v1.3/.
Receiving xchat-1.3.8.tar.bz2 (305543 bytes): 100%
305543 bytes transferred in 2.9 seconds  (102.81 Kbytes/s)
===&gt;  Extracting for xchat-1.3.8
&gt;&gt; Checksum OK for xchat-1.3.8.tar.bz2.
===&gt;   xchat-1.3.8 depends on executable: bzip2 - found
===&gt;   xchat-1.3.8 depends on executable: gmake - found
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
===&gt;  Patching for xchat-1.3.8
===&gt;  Applying FreeBSD patches for xchat-1.3.8
===&gt;  Configuring for xchat-1.3.8
...
[configure output snipped]
...
===&gt;  Building for xchat-1.3.8
...
[compilation snipped]
...
===&gt;  Installing for xchat-1.3.8
===&gt;   xchat-1.3.8 depends on shared library: gtk12.2 - found
===&gt;   xchat-1.3.8 depends on shared library: Imlib.5 - found
===&gt;   xchat-1.3.8 depends on shared library: X11.6 - found
...
[install routines snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Installing xchat docs in /usr/X11R6/share/doc/xchat
===&gt;   Registering installation for xchat-1.3.8
&prompt.root;</screen>

        <para>ご覧のとおり、
          出力の違いはシステムがどこから port
          を入手したか示す行だけです。</para>

        <para>以上が、システムに ports
          をインストールするために必要な操作です。
          次のセクションでは、システムにインストールされている port
          を削除する方法について学びます。</para>
      </sect3>
    </sect2>

    <sect2 id="ports-removing">
      <title>インストールされた ports の削除</title>

      <para>ports のインストール方法について知ればおそらく、
        インストールの後になって、それが間違っていたことに気付いた時などに備えて
        それらを削除する方法はどうすれば良いのか疑問に感じることでしょう。
        ここでは、その削除の方法について扱います。</para>
      <!-- 2000/07/16:hrs - why "decide"? -->

      <para>さて、前の例 (例のまま何も変更していない人は xchat)
        を削除してみましょう。ports のインストールと同じように、
        まず最初にやらなければならないのは port のディレクトリに移動することです。
        port のディレクトリは <filename>/usr/ports/irc/xchat</filename> でしたね。
        ディレクトリを移動したら、xchat を削除するのに必要な準備は終わりです。
        削除するには、<command>make deinstall</command> コマンド
        (わかりやすいですよね?) を実行します。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/irc/xchat</userinput>
&prompt.root; <userinput>make deinstall</userinput>
===&gt;  Deinstalling for xchat-1.3.8
&prompt.root;</screen>

      <para>極めて簡単な作業です。
        これでうまく xchat をシステムから削除することができました。
        もう一度再インストールしたい場合には、
        <filename>/usr/ports/irc/xchat</filename> から        
        <command>make reinstall</command>
        を実行することで行なうことができます。
      </para>
    </sect2>
  </sect1>

  <sect1 id="ports-trouble">
    <title>トラブルシューティング</title>

    <para>このセクションでは、Ports Collection
      について良く質問される質問と、
      いくつかの基本的なトラブルシューティングテクニック、
      そして <link linkend="ports-broken">port
        がうまく動かない</link>場合にできることについて扱います。</para>

    <sect2 id="ports-questions">
      <title>質問と回答集</title>
      
      <qandaset>
        <qandaentry>
          <question>
            <para>私はモデムについての議論を
              しているのかと思っていました??!</para>
          </question>
          
          <answer>
            <para>なるほど。
              あなたはきっと、
              コンピュータの背面についているシリアルポートのことだと思ってしまったのでしょう。
              あるバージョンの Unix から、
              別のバージョンの Unix へとプログラムを移植することを
              <quote>porting</quote> というのですが、
              ここでわたしたちは <quote>porting</quote>
              の結果という意味で <quote>port</quote> を使っています。</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para id="ports-patch">パッチ (patch) とは何ですか?</para>
          </question>
          
          <answer>
            <para>パッチとは、
              あるバージョンから他のバージョンへどのように変更するかを
              示す、(通常は) 小さなファイルです。
              <quote>23 行目を削除</quote>、
              <quote>468 行目の後にこれらの 2 行を追加</quote>、
              または <quote>197
                行目をこのように変更</quote> というような内容を含んでいます。
              これは、<quote>diff</quote>
              という名前のプログラムで生成されます。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para id="ports-tarball">tarball とは一体何ですか?</para>
          </question>
          
          <answer>
            <para><filename>.tar</filename> または
              <filename>.tar.gz</filename> という拡張子を持つファイルです
              (<filename>.tar.Z</filename>
              のようなバリエーションもありますし、
              DOS のファイルシステム用に
              <filename>.tgz</filename>
              と短縮される場合もあります)。</para>

            <para>これは基本的にファイルを一つにまとめた
              (<filename>.tar</filename>) ディレクトリツリーです。
              圧縮されている (<filename>.gz</filename>) 場合もあります。
              元々 <emphasis>T</emphasis>ape
              <emphasis>AR</emphasis>chives (訳注: テープアーカイブ)
              (このため <command>tar</command> という名前なのです)
              で使われていたものなのですが、
              インターネット上でプログラムのソースコードを配布するために
              広く使われている方法です。</para>
            
            <para>これらのファイルの中身を見たり、
              展開したりすることもできます。FreeBSD
              の基本システムに付属する Unix 標準の tar
              コマンドを使ってみると 次のようになります。</para>

	  <screen>&prompt.user; <userinput>tar tvzf foobar.tar.gz</userinput>
&prompt.user; <userinput>tar xzvf foobar.tar.gz</userinput>
&prompt.user; <userinput>tar tvf foobar.tar</userinput>
&prompt.user; <userinput>tar xvf foobar.tar</userinput></screen>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para id="ports-checksum">チェックサムとは何ですか?</para>
          </question>

          <answer>
            <para>これは、
              チェックしたいファイル中のすべてのデータを加えて生成した
              数値です。何か文字が書き換わっていたら、
              チェックサムが一致しなくなります。そのため、
              単純な比較だけで違いを見つけることができるのです。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>今まで「CD-ROM からの ports のコンパイル」にあるようにして
              ports をインストールできていたのですが、
              kermit のインストールをしようとするとうまくいきません。</para>

            <screen>&prompt.root; <userinput>make install</userinput>
&gt;&gt; cku190.tar.gz doesn't seem to exist on this system.
&gt;&gt; Attempting to fetch from ftp://kermit.columbia.edu/kermit/archives/.</screen>

            <para>なぜ cku190.tar.gz が見つからないのでしょうか?
              不良品の CDROM を買ってしまったのでしょうか?</para>
          </question>

          <answer>
            <para><link linkend="ports-cd">CD-ROM からの ports
                のコンパイル</link> のセクションで説明されているとおり、
              ports の一部にライセンス上の制限から CDROM
              には収録できない種類のものが存在します。
              kermit はその一例です。
              kermit のライセンス条件は tarball を CDROM
              に収録することを禁じているため、
              申し訳ありませんが手動で tarball を取得してください。</para>

            <para>質問にあるようなエラーメッセージが表示されるのは、
              あなたがそのときにインターネットへ接続していなかったことによります。
              一度 MASTER_SITES のいずれかから (Makefile の中に書いてあります)
              ダウンロードしておけば、プロセスを再開することができます。</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>kermit の tarball を入手しましたが、
              <filename>/usr/ports/distfiles</filename> に
              ファイルを置こうとすると、
              書き込み権がないというエラーがでます。</para>
          </question>
          
          <answer>
            <para>ports は
              <filename>/usr/ports/distfiles</filename> から tarball
              を探します。しかし、これは読み出し専用の CDROM
              へのシンボリックリンクなので、
              ここにファイルを置くことはできません。
              次のようにすれば他の場所を探すよう ports
              に指示することができます。</para>

            <screen>&prompt.root; <userinput>make DISTDIR=<replaceable>/where/you/put/it</replaceable> install</userinput></screen>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>ports は、すべてを <filename>/usr/ports</filename>
              に置いたときだけ動作するのでしょうか?
              システムの管理者によると、私の個人的なファイルは
              <filename>/u/people/guests/wurzburger</filename>
              に入れなければならないのですが、
              これではうまくいかないように思います。</para>
          </question>
          
          <answer>
            <para><makevar>PORTSDIR</makevar> 変数と
              <makevar>PREFIX</makevar> 変数を変更することで、
              違うディレクトリを 使用することができます。
              たとえば、</para>

            <screen>&prompt.root; <userinput>make PORTSDIR=/u/people/guests/wurzburger/ports install</userinput></screen>

            <para>とすると、ports は
              <filename>/u/people/guests/wurzburger/ports</filename>
              でコンパイルされ、すべて <filename>/usr/local</filename>
              以下にインストールされます。</para>

            <screen>&prompt.root; <userinput>make PREFIX=/u/people/guests/wurzburger/local install</userinput></screen>

            <para>この場合、コンパイルは <filename>/usr/ports</filename>
              でおこない、
              <filename>/u/people/guests/wurzburger/local</filename>
              にインストールします。</para>

            <para>もちろん、</para>
            
            <screen>&prompt.root; <userinput>make PORTSDIR=../ports PREFIX=../local install</userinput></screen>
            
            <para>とすれば両者を組み合わせることが可能です
              (省略せずに記述したらこのページに収めるには長すぎるのですが、
              考え方は理解していただけたと思います)。</para>

            <para>(X Window System に含まれる) &man.imake.1; を使用する
              ports の場合は <makevar>PREFIX</makevar> が機能せず、
              <filename>/usr/X11R6</filename> の下へインストールしようとします。
              また、Perl 関連の ports も同様に <makevar>PREFIX</makevar> を無視して
              Perl ツリーにインストールします。
              これらの ports で <makevar>PREFIX</makevar>
              がきちんと参照されるように変更するのは、ほとんど不可能です。</para>

            <para>もし ports をインストールするたびにこれらを毎回タイプするのが気に入らないのであれば、
              これらを環境変数にセットしてしまうという手があります。
              どのようにすれば良いかについては、
              あなたの使っているシェルのマニュアルページを参照してください。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>わたしは FreeBSD の CDROM を持っていませんが、
              すべての tarball を システムに置いておきたいのです。
              そうすれば ports
              をインストール するたびに毎回ダウンロードが終わるのを待たなくてすむでしょう。
              これを一度におこなう簡単な方法はありませんか?</para>
          </question>

          <answer>
            <para>Ports Collection 全体の tarball を持ってくるには、
              次のようにします。</para>

            <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make fetch</userinput></screen>

            <para>ports の下の一つのディレクトリの tarball
              を持ってくるには、次のようにします。</para>

            <screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make fetch</userinput></screen>

            <para>ports を一つだけ持ってくる方法は、
              きっとすでにご存知だと思います。</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>近くにある FreeBSD のミラーサイトから
              tarball を持ってくる方がおそらく速いはずです。
              MASTER_SITES に書かれているサイト以外から持ってくるように
              ports に指示する方法はありませんか?</para>
          </question>
          
          <answer>
            <para>もちろんあります。たとえば
              <hostid role="fqdn">ftp.FreeBSD.org</hostid> が
              <makevar>MASTER_SITES</makevar> に書かれている
              サイトより近いとしたら、以下のようにしてください。</para>

            <screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make MASTER_SITE_OVERRIDE=ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</userinput></screen>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para><command>make</command> がダウンロードしようとする前に、
              どんなファイルが必要とするか知りたいのですが。</para>
          </question>
          
          <answer>
            <para><command>make fetch-list</command> とすると、ports
              に必要なファイルの一覧を表示できます。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>ports のコンパイルを途中で止める方法はありますか?
              私はインストールをする前に
              いろいろとソースコードを解析したいのですが、毎回 control-C
              を打たなければならないのが少し面倒です。</para>
          </question>
          
          <answer>
            <para><command>make extract</command> を実行すると、
              ファイル転送とソースコードの展開まで行なったところで停止します。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>自分で ports を作ろうとしています。
              わたしの作ったパッチが正しく処理できることを確認できるように、
              コンパイルを止めたいのです。
              パッチのための <command>make extract</command>
              のようなものはありませんか?</para>
          </question>
          
          <answer>
            <para>あります。<command>make patch</command>
              があなたの望むものです。
              おそらく
              <makevar>PATCH_DEBUG</makevar>
              オプションも同様に役に立つことでしょう。
              あなたの努力に感謝いたします!!</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>あるコンパイルオプションはバグの原因になるという話を聞きました。
              本当なのでしょうか?
              どうやったら正しい設定で ports
              をコンパイルできますか?</para>
          </question>

          <answer>
            <para>本当です。
              <command>gcc</command> の バージョン 2.6.3
              (FreeBSDの 2.1.0 と 2.1.5 に付属している バージョン) では、
              <option>-O2</option> オプションを
              <option>-fno-strength-reduce</option> オプションなしで
              使うと、バグのあるコードを出力します (ほとんどの ports は
              <option>-O2</option> オプションを使いません)。
              コンバイルオプションは次のように定義<emphasis>すべき</emphasis>です。</para>

            <screen>&prompt.root; <userinput>make CFLAGS='-O2 -fno-strength-reduce' install</userinput></screen>

            <para>これを <filename>/etc/make.conf</filename>
              に書いておくこともできますが、
              残念なことにすべての ports
              がこの指定を尊重してくれるわけではありません。
              もっとも確実なのは <command>make configure</command>
              を実行し、ソースディレクトリの <filename>Makefile</filename>
              を見て、手で修正することですが、
              ソースが多くのサブディレクトリに分かれていて、
              各々に <filename>Makefile</filename>
              がある場合は大変な仕事になります。</para>

	    <para>FreeBSD の標準コンパイルオプションは非常に保守的ですので、
              変更していなければ問題となることはないでしょう。</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>ports がたくさんありすぎて、
              わたしの欲しいものがなかなか見つけられません。
              どんな ports が使えるのか、リストはどこかにありませんか?</para>
          </question>

          <answer>
            <para><filename>/usr/ports</filename> の中にある
              <filename>INDEX</filename> ファイルを見てみましょう。
              また、あるキーワードで ports コレクションを検索することも可能です。
              たとえば以下のようにすれば、プログラミング言語 LISP に関連した
              ports を探すことができます。</para>

              <screen>&prompt.user; <userinput>cd /usr/ports</userinput>
&prompt.user; <userinput>make search key=lisp</userinput></screen>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para><literal>foo</literal> ports
              をインストールしたいのですが、それのコンパイルは
              すぐに停止して、<literal>bar</literal> ports
              のコンパイルが始まってしまいます。一体どうして?</para>
          </question>

          <answer>
            <para><literal>foo</literal> ports が、
              <literal>bar</literal> ports
              の提供する何らかの機能を必要としているからです。
              たとえば <literal>foo</literal> が画像を扱うもので
              <literal>bar</literal>
              がその画像処理に必要なライブラリを持っている場合などです。
              もしくは <literal>bar</literal> が
              <literal>foo</literal>
              をコンパイルするのに必要なツールなのかもしれません。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para id="ports-remove">ports から
              <literal>grizzle</literal>
              プログラムをインストールしましたが、まったく
              ディスクスペースの浪費です。削除したいのですが、
              すべてのファイルがどこへインストールされたのかわかりません。
              何か手がかりはありませんか?</para>
          </question>

          <answer>
            <para>大丈夫、次のようにしてください。</para>
            
            <screen>&prompt.root; <userinput>pkg_delete grizzle-6.5</userinput></screen>
            
            <para>もしくは、次のようにします。</para>
            
            <screen>&prompt.root; <userinput>cd <replaceable>/usr/ports/somewhere/grizzle</replaceable></userinput>
&prompt.root; <userinput>make deinstall</userinput></screen>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>ちょっと待ってください。
              削除しようとするコマンドのバージョン番号を
              知っていなくてはならないのでしょうか?
              あなたは、わたしがバージョン番号を
              覚えていると本気で思っているのですか?</para>
          </question>

          <answer>
            <para>そんなことはありません。
              バージョン番号は次のようにすればわかります。</para>
            
            <screen>&prompt.root; <userinput>pkg_info -a | grep grizzle</userinput>
Information for grizzle-6.5:
grizzle-6.5 - the combined piano tutorial, LOGO interpreter and shoot 'em up arcade game.</screen>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>ディスク容量のことなのですが、ports
              のディレクトリは非常に膨大な容量を使うように見えます。
              残しておいた方がよいのでしょうか?
              それとも削除してしまって構わないのでしょうか?</para>
          </question>
          
          <answer>
            <para>はい。インストールが首尾よく終わり、
              もうソースコードが必要でないと思うなら、
              それらを残しておく理由はないでしょう。
              一番良い方法は、次のとおりです。</para>

            <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make clean</userinput></screen>

            <para>これはすべての ports のサブディレクトリを調べ、
              各 ports のスケルトン以外の削除をおこないます。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>これを試してみたのですが、tarball や ports
              で使われたファイルが <filename>distfiles</filename>
              ディレクトリに残っています。
              これも削除してしまっても大丈夫ですか?</para>
          </question>

          <answer>
            <para>はい。それを使った作業が終わったのであれば、
              削除してしまっても大丈夫です。
              手動でファイルを操作するか、
              もしくは <command>make distclean</command>
              を使えば削除することができます。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>わたしはとてもとてもたくさんのプログラムを楽しみたいのです。
              一度にすべての ports
              をインストールする方法はありませんか?</para>
          </question>
          
          <answer>
            <para>次のようにしてください。</para>
            
            <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make install</userinput></screen>

	    <para>ports の中には、
              同じ名前でインストールを行なうものがあるということに注意してください。
              二つのグラフィック ports をインストールして、
              それらが両方とも
              <filename>/usr/local/bin/plot</filename>
              をインストールする場合などは明らかに問題となるでしょう。</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>やってみました。
              時間がとてもかかるだろうと思ったので、
              そのまま実行を続けさせて、わたしは寝ました。
              翌朝コンピュータを見てみると、
              三つ半の ports しか処理が終わっていませんでした。
              何か悪かったのでしょうか?</para>
          </question>

          <answer>
            <para>ports の中には、
              わたしたちの決められないこと
              (たとえば、あなたが A4 の 用紙に印刷したいのか、US
              レターサイズの用紙に印刷したいのかなど)
              について質問してくるものがあるからです。
              それらの質問には手動で答える必要があります。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>一日中モニタの前に座って過ごしたりしたくないのですが、
              何か良いアイディアはありませんか?</para>
          </question>
          
          <answer>
            <para>では、あなたが寝に / 仕事に /
              公園にいく前に以下を実行してください。</para>

            <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make -DBATCH install</userinput></screen>

            <para>これでユーザの入力を要求<emphasis>しない</emphasis>すべての ports
              をインストールします。
              そして戻ってきてから次のように実行してください。</para>

            <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make -DIS_INTERACTIVE install</userinput></screen>

            <para>そして残りの作業を実行してください。</para>
          </answer>
        </qandaentry>
        
        <qandaentry>
          <question>
            <para>わたしたちは Ports Collection にある
              <literal>frobble</literal> を使っています。
              ですが、わたしたちの必要に応じて ports
              を変更したところがあるのです。
              自分で package を作って、
              それをわたしたちのサイトのまわりに簡単に配布できるような方法がありますか?</para>
          </question>

          <answer>
            <para>もちろんあります。
              変更点をパッチにする方法は知っていますよね?</para>

            <screen>&prompt.root; <userinput>cd <replaceable>/usr/ports/somewhere/frobble</replaceable></userinput>
&prompt.root; <userinput>make extract</userinput>
&prompt.root; <userinput>cd work/frobble-2.8</userinput>
[あなたのパッチをあててください]
&prompt.root; <userinput>cd ../..</userinput>
&prompt.root; <userinput>make package</userinput></screen>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>この ports の技術は本当に賢いですね。
              わたしはこれがどのようにして動いているのか知りたいのですが、
              その秘密とは何ですか?</para>
          </question>

          <answer>
            <para>秘密なんて一切ありません。
              <ulink url="file://localhost/usr/ports/Mk/">Makefiles
                ディレクトリ</ulink> にある
              <filename>bsd.port.mk</filename> と
              <filename>bsd.port.subdir.mk</filename>
              ファイルを見てください。</para>

            <para>(複雑なシェルスクリプトを嫌う読者は、
              このリンクを追いかけないほうが良いでしょう…。)</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>

    <sect2 id="ports-broken">
      <title>たすけて! port がうまく動かない!</title>

      <para>port がうまく動作しない状況に遭遇したら、
        あなたにできることは次のようなことしかありません。</para>

      <orderedlist>
        <listitem>
	  <para>自分で直しましょう!
            <quote><link linkend="porting">port の作り方</link></quote>
            のセクションが参考になるはずです。</para>
	</listitem>

	<listitem>
	  <para>苦情を言いましょう &mdash; <emphasis>ただし電子メールで!</emphasis>
            まず port の保守担当者に電子メールを送ってください。
            <command>make maintainer</command> と入力するか、
            <filename>Makefile</filename> を直接読み、
            保守担当者の電子メールアドレスを調べます。
            メールを送る際には、port 名とバージョン番号
            (<filename>Makefile</filename> の <literal>$FreeBSD:</literal>
            行)、
            そしてエラーが出力されるまでの出力ログを忘れずに添付してください。
            保守担当者から返信がなければ、<command>send-pr</command>
            を使ってバグレポートを提出しても構いません。</para>
	</listitem>

	<listitem>
	  <para>その port のことは忘れてしまってください。
            これは最も気楽な方法です
            &mdash;
            <quote>重要</quote> な ports というのは、
            ほんの一握りしかありません。
            また、port が更新された時に問題が解決しているかも知れません。</para>
	</listitem>

	<listitem>
	  <para>近くの FTP サイトから package を入手しましょう。
            <quote>マスタ</quote> package コレクションは、
            <hostid role="fqdn">ftp.FreeBSD.org</hostid> の
            <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/"
                   >package のディレクトリ</ulink>にありますが、
            まずはあなたの地域のミラーサイトを<emphasis>最初に</emphasis>調べてください。
            ソースからコンパイルすることを試みるより確実ですし、
            時間もかかりません。
            package をシステムにインストールするには、&man.pkg.add.1; を使います。
          </para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 id="porting">
    <title>高度な話題</title>

    <para>以前ここにあった文書は、探しやすいように
      <ulink url="../porters-handbook/index.html">Porter's Handbook</ulink>
      へ移動しました。
      あなたが ports の作成や提出をしたいと考えているなら、そちらへどうぞ。
    </para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
