<?xml version="1.0" encoding="euc-jp"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r51348
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="ports">

  <title>アプリケーションのインストール - packages と ports</title>

  <sect1 xml:id="ports-synopsis">
    <title>この章では</title>

    <indexterm><primary>ports</primary></indexterm>
    <indexterm><primary>packages</primary></indexterm>
    <para>&os; の基本システムには数多くのシステムツールが含まれています。
      &os; は、サードパーティ製のソフトウェアの導入を支援するために、
      ソースコードをコンパイルしてインストールする Ports Collection と、
      コンパイル済みのバイナリをインストールする packages
      という相補的な 2 つの技術を提供しています。
      どちらのシステムを用いても、
      ローカルメディアやネットワーク上からソフトウェアをインストールできます。</para>

    <para>この章を読むと、以下のことがわかります。</para>

    <itemizedlist>
      <listitem>
	<para>packages と ports の違い</para>
      </listitem>

      <listitem>
	<para>&os; に移植されたサードパーティ製のソフトウェアの探し方</para>
      </listitem>

      <listitem>
	<para><application>pkg</application> を用いてバイナリ
	  package を管理する方法</para>
      </listitem>

      <listitem>
	<para>Ports Collection を用いてサードパーティ製のソフトウェアをソースコードから構築する方法</para>
      </listitem>

      <listitem>
	<para>インストール後の設定のために、
	  アプリケーションとともにインストールされたファイルを探す方法</para>
      </listitem>

      <listitem>
	<para>ソフトウェアのインストールに失敗した場合に、どうしたらよいか</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="ports-overview">
    <title>ソフトウェアのインストール</title>

    <para>&unix; システムでは、
      サードパーティ製ソフトウェアの典型的なインストール手順は以下のようになります。</para>

    <procedure>
      <step>
	<para>ソースコード、
	  またはバイナリ形式で配布されているソフトウェアを探し出し、
	  ダウンロードする。</para>
      </step>

      <step>
        <para>配布時のフォーマットからソフトウェアを取り出す。
	  一般的には &man.compress.1;, &man.gzip.1;, &man.bzip2.1;
	  または、&man.xz.1; といったプログラムで圧縮された
	  tarball です。</para>
      </step>

      <step>
	<para><filename>INSTALL</filename> または
	  <filename>README</filename> ファイル、あるいは
	  <filename>doc/</filename>
	  サブディレクトのファイルからドキュメントを探しだし、
	  ソフトウェアのインストール方法を調べる。</para>
      </step>

      <step>
	<para>ソース形式でソフトウェアが配布されている場合はコンパイルを行う。
	  ここでは、<filename>Makefile</filename> の編集、
	  または、<command>configure</command>
	  スクリプトの実行を伴うことがあります。 </para>
      </step>

      <step>
	<para>ソフトウェアの動作を確認し、インストールする。</para>
      </step>
    </procedure>

    <para>&os; <emphasis>port</emphasis> は、
      アプリケーションをソースコードからコンパイルする際の処理を自動化するように設計されたファイルの集まりです。
      port を構成するファイルは、
      自動的にアプリケーションをダウンロードし、展開、パッチ作業、
      コンパイル、そしてインストールを行うために必要な情報を含んでいます。</para>

    <para>ソフトウェアが、すでに &os; に移植され、
      &os; 上で試験されていなければ、
      適切にインストールが行われ、動作するように、
      編集する必要があるかもしれません。</para>

    <para>しかしながら、
      <link xlink:href="&url.base;/ja/ports/index.html">&os.numports;</link>
      を越えるサードパーティ製アプリケーションが &os; に移植されています。
      可能な場合は、これらのアプリケーションをコンパイル済みの
      <emphasis>packages</emphasis>
      としてダウンロードできます。</para>

    <para>package は、package
      管理コマンドで扱うことができます。</para>

    <para>packages と ports は依存関係を理解します。
      package または port
      を用いてアプリケーションをインストールすると、
      依存するライブラリがまだインストールされていない場合には、
      最初にライブラリが自動的にインストールされます。</para>

    <para>&os; の package は、コンパイル済みのアプリケーションの全コマンド、
      各種設定ファイルやドキュメントを含んでいます。
      <application>pkg</application>
      コマンドでは、<command>pkg install</command> といったコマンドで、
      package を扱うことができます。</para>

    <para>2 つの技術は類似していますが、
      packages と ports にはそれぞれ独自の特徴があります。
      それぞれのアプリケーションのインストールに対する必要要件に応じてどちらかを選択してください。</para>

    <itemizedlist>
      <title>package の利点</title>

      <listitem>
	<para>一般的に、あるアプリケーションの package の tarball は、
          ソースコードを含む tarball より小さなサイズとなります。</para>
      </listitem>

      <listitem>
	<para>packages はコンパイルの時間を必要としません。
	  このことは、遅いシステム上で <application>Mozilla</application>,
  	  <application>KDE</application>,
	  または <application>GNOME</application>
	  といった大きなアプリケーションを扱う場合に重要となります。</para>
      </listitem>

      <listitem>
	<para>packages を用いれば、
	  ソフトウェアのコンパイルに関する知識は必要ありません。</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>port の利点</title>

      <listitem>
	<para>packages は、通常最も多くのシステムで実行できるように、
          非常に保守的な設定で構築されています。
          port からコンパイルすることで、
          コンパイルオプションを指定できます。 </para>
      </listitem>

      <listitem>
	<para>アプリケーションのなかには、
	  どの機能をインストールするかをコンパイル時に設定するものがあります。
	  たとえば、<application>Apache</application> は多種多様な
	  ビルトインオプションを設定できます。</para>

        <para>設定を区別するために、同じアプリケーションに対して
          複数の packages が存在することがあります。
          たとえば、<application>Ghostscript</application> は
          <application>Xorg</application> がインストールされているかどうかにより、
          <filename>ghostscript</filename> package と
          <filename>ghostscript-nox11</filename> package
          が選択可能となっています。
          アプリケーションのコンパイルオプションが 1 つもしくは
	  2 つ以上になると、
          複数の packages を用意することは困難になります。</para>
      </listitem>

      <listitem>
        <para>ライセンス条項で、
	  バイナリでの配布を禁止しているソフトウェアがあります。
	  このようなソフトウェアはソースコードで配布される必要があり、
	  エンドユーザがコンパイルしなくてはなりません。</para>
      </listitem>

      <listitem>
        <para>バイナリ配布を信用していない人や、
	  潜在的な問題点を見つけ出すためにソースコードを読むことを好む人がいます。</para>
      </listitem>

      <listitem>
        <para>カスタマイズしたパッチを適用するためには、
	  ソースコードが必要になります。</para>
      </listitem>
    </itemizedlist>

    <para>ports の更新状況を把握するために、
      &a.ports; や &a.ports-bugs; を購読するとよいでしょう。</para>

    <warning>
      <para>アプリケーションをインストールする前に、
	そのアプリケーションに関連したセキュリティ上の問題がないことを <link
	  xlink:href="https://vuxml.freebsd.org/"></link>
	で確認するか、<command>pkg audit -F</command> と入力して、
	インストールされているアプリケーションに既知の脆弱性がないことを確認してください。</para>
    </warning>

    <para>この章では、packages と ports を用いた &os; 上での
      サードパーティ製ソフトウェアのインストール方法や管理方法について説明します。</para>
  </sect1>

  <sect1 xml:id="ports-finding-applications">
    <title>ソフトウェアの探し方</title>

    <para>&os; 上で利用可能なアプリケーションのリストは常に増えています。
      インストールするソフトウェアを探す方法はたくさん用意されています。</para>

    <itemizedlist>
      <listitem>
	<para>&os; ウェブサイトは、
	  利用可能なすべてのアプリケーションの最新の一覧を、検索できる形で
	  <link xlink:href="&url.base;/ja/ports/index.html">https://www.FreeBSD.org/ja/ports/</link>
	  において公開しています。
	  ports はアプリケーションの名前や、ソフトウェアのカテゴリで検索出来ます。</para>
      </listitem>

      <listitem>
	<indexterm><primary>FreshPorts</primary></indexterm>

	<para>Dan Langille は、包括的な検索ユーティリティや
	  Ports Collection にあるアプリケーションの変更点を追跡する
	  <link xlink:href="http://www.FreshPorts.org/">FreshPorts.org</link>
	  を公開しています。
	  登録したユーザは、監視している ports  がアップデートされた時に、
	  そのことを自動的にメールで知らせてくれるような、
	  カスタマイズ可能な監視リストを使うことができます。</para>
      </listitem>

      <listitem>
      <indexterm><primary>SourceForge</primary></indexterm>

	<para>アプリケーションを見つけることが難しい場合には、<link
	    xlink:href="http://www.sourceforge.net/">SourceForge.net</link>
	  または <link xlink:href="http://www.github.com/">GitHub.com</link>
	  のようなサイトで探してみてください。
	  その後、そのアプリケーションが ports で利用可能かどうかを <link
	    xlink:href="&url.base;/ja/ports/index.html">&os; サイト</link>
	  で調べて下さい。</para>
      </listitem>

      <listitem>
	<indexterm>
	  <primary>pkg</primary>
	  <secondary>search</secondary>
	</indexterm>

	<para xml:id="pkg-search">バイナリ package
	  リポジトリでアプリケーションを探すには、
	  以下のように実行してください。</para>

	<screen>&prompt.root; <userinput>pkg search <replaceable>subversion</replaceable></userinput>
git-subversion-<replaceable>1.9.2</replaceable>
java-subversion-<replaceable>1.8.8_2</replaceable>
p5-subversion-<replaceable>1.8.8_2</replaceable>
py27-hgsubversion-<replaceable>1.6</replaceable>
py27-subversion-<replaceable>1.8.8_2</replaceable>
ruby-subversion-<replaceable>1.8.8_2</replaceable>
subversion-<replaceable>1.8.8_2</replaceable>
subversion-book-<replaceable>4515</replaceable>
subversion-static-<replaceable>1.8.8_2</replaceable>
subversion16-<replaceable>1.6.23_4</replaceable>
subversion17-<replaceable>1.7.16_2</replaceable></screen>

	<para>package 名にはバージョン番号が含まれます。
	  また、python ベースの ports では、
	  共に構築された python のバージョン番号も含まれます。
	  ports によっては、複数のバージョンを利用できるものがあります。
	  <application>subversion</application> では、
	  複数のバージョンを利用できますが、
	  異なるコンパイルオプションで構築されたものも利用できます。
	  インストールする package を指定する際には、
	  アプリケーションに、port ツリーのパスである、
	  port のオリジンを指定すると良いでしょう。
	  <command>pkg search</command> に <option>-o</option>
	  オプションを付けて、実行してください。
	  各 package のオリジンの一覧が表示されます。</para>

	<screen>&prompt.root; <userinput>pkg search -o <replaceable>subversion</replaceable></userinput>
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static</screen>

	<para><command>pkg search</command> は、
	  リポジトリデータベースの説明やその他のフィールドにおいて、
	  シェルグロブ、正規表現、完全一致にも対応しています。
	  詳細については、<package>ports-mgmt/pkg</package> または
	  <package>ports-mgmt/pkg-devel</package> のインストール後、
	  &man.pkg-search.8; をご覧ください。</para>
      </listitem>

      <listitem>
	<para>Ports Collection がすでにインストールされていれば、
	  ports ツリーのローカルバージョンを調べることができます。
	  port がどのカテゴリに分類されているのかを知りたければ、
	  &man.whereis.1; コマンドで調べることができます。
	  <command>whereis <replaceable>ファイル</replaceable></command>
	  と入力してください。<replaceable>ファイル</replaceable>
	  の部分にはインストールを考えているプログラム名を入れます。</para>

	<screen>&prompt.root; <userinput>whereis lsof</userinput>
lsof: /usr/ports/sysutils/lsof</screen>

	<para>さらに、以下の例のように &man.echo.1;
	  を使って調べることもできます。</para>

	<screen>&prompt.root; <userinput>echo /usr/ports/*/*lsof*</userinput>
/usr/ports/sysutils/lsof</screen>

	<para>この方法では <filename
	    class="directory">/usr/ports/distfiles</filename>
	  以下にダウンロードされたファイル名にもマッチします。</para>
      </listitem>

      <listitem>
	<para>また、Ports Collection に備わっている検索機能を利用して
	  port を検索する方法もあります。
	  この検索機能を利用するには、
	  <application>cd</application> コマンドを用いて
	  <filename class="directory">/usr/ports</filename>
	  ディレクトリに移動し、<command>make search
	    name=プログラム名</command>
	  と入力してください。
	  <replaceable>プログラム名</replaceable>
	  の部分には検索したいソフトウェアの名前を入れてください。
	  たとえば、<command>lsof</command> を探すには次のようにします。</para>

	<screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make search name=lsof</userinput>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps: </screen>

	<tip>
	  <para>Ports Collection に用意されている検索のメカニズムでは、
	    インデックスファイルを利用して検索を行います。
	    もし <filename>INDEX</filename>
	    が必要であるというメッセージが表示されたら、
	    <command>make fetchindex</command> を実行して、
	    最新のインデックスファイルをダウンロードしてください。
	    <filename>INDEX</filename> が用意されれば、
	    <command>make search</command>
	    で検索を実行できるでしょう。</para>
	</tip>

	<para><quote>Path:</quote> という行は、
	  port がどこにあるかを示しています。</para>

	<para>より絞られた情報を得るには、
	  <command>quicksearch</command>
	  と呼ばれる機能を使ってください。</para>
	  
	<screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make quicksearch name=lsof</userinput>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))</screen>

	<para>もっと詳しく検索するには、
	  <command>make search
	  key=<replaceable>string</replaceable></command> または
	  <command>make quicksearch
	  key=<replaceable>string</replaceable></command>
	  と入力してください。
	  <replaceable>string</replaceable>
	  の部分には検索したいテキストを入れます。
	  プログラムの名前がわからない場合でも、
	  ある目的に関連した ports の検索に利用できるよう、
	  テキストの部分には、コメント、
	  説明文および依存情報を入れることができます。</para>

	<para><buildtarget>search</buildtarget>
	  および <buildtarget>quicksearch</buildtarget> を使う場合には、
	  検索文字列中の大文字と小文字を区別せずに検索が行われるので、
	  <quote>LSOF</quote> を検索した結果は、
	  <quote>lsof</quote> と同じ検索結果になります。</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 xml:id="pkgng-intro">
    <title><application>pkg</application> によるバイナリ
      package の管理</title>

    <para><application>pkg</application> は、&os; における伝統的な 
      package 管理ツールの置き換えとなる次世代の管理ツールで、
      バイナリ packages をより早く、
      より簡単に管理できるようにする数多くの機能を提供します。</para>

    <para>&os; のミラーサイトが提供する事前に構築されたバイナリ package
      のみを使いたいと考えているサイトでは、
      <application>pkg</application> を使って package
      を管理するとよいでしょう。</para>

    <para>しかしながら、
      ソースまたは自分自身で用意したリポジトリから構築したサイトでは、
      <link linkend="ports-upgrading-tools">port 管理ツール</link>
      が別に必要となります。</para>

    <para><application>pkg</application> はバイナリ
      package のみを扱うので、
      そのような管理ツールの置き換えとはなりません。
      これらのツールは、ソフトウェアをバイナリ packages と
      Ports Collection の両形式からインストールできますが、
      <application>pkg</application> はバイナリ packages
      のみをインストールします。</para>

    <sect2 xml:id="pkgng-initial-setup">
      <title><application>pkg</application> 入門</title>

      <para>&os; には、
	<application>pkg</application>
	およびマニュアルページをインストールするブートストラップユーティリティが用意されています。
	このユーティリティは、&os; 10.<replaceable>X</replaceable>
	以降で動作するように設計されています。</para>

      <note>
	<para>このブートストラッププロセスは、すべての
	  &os; バージョンおよびアーキテクチャに対応しているわけではありません。
	  現在対応している一覧は、
	  <link xlink:href="https://pkg.freebsd.org/"></link>
	  で確認することができます。
	  対応していない場合には、
	  Ports Collection またはバイナリ package から
	  <application>pkg</application>
	  をインストールする必要があります。</para>
      </note>

      <para>システムをブートストラップするには、
	以下を実行してください。</para>

      <screen>&prompt.root; <userinput>/usr/sbin/pkg</userinput></screen>

      <para>ブートストラッププロセスに成功するには、
	インターネットへの接続が必要です。</para>

      <para>port をインストールするには以下を実行してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/pkg</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>古い pkg_* ツールを用いたシステムをアップグレードする際には、
	新しいツールがすでにインストールされている package を認識するよう、
	データベースを新しいフォーマットへと変換する必要があります。    
	<application>pkg</application> をインストールしたら、
	以下のコマンドを実行して、package
	データベースをこれまでの伝統的なフォーマットから新しいフォーマットへと変換してください。</para>

      <screen>&prompt.root; <userinput>pkg2ng</userinput></screen>

      <note><para>このステップは、
	サードパーティ製ソフトウェアがまだインストールされていないような、
	新しくインストールされた直後のシステムでは必要ありません。</para></note>

      <important>
	<para>このステップは非可逆です。
	  一度 package データベースを <application>pkg</application>
	  フォーマットへと変換したら、伝統的な <application>pkg_*</application>
	  ツールを使うべきではありません。</para>
      </important>

      <note>
	<para>package データベースを変換する際には、
	  新しいバージョンへのデータ変換に伴ったエラーが出力されることがあります。
	  通常、これらのエラーは無視して構いませんが、
	  <command>pkg2ng</command> 終了後、
	  変換に失敗したソフトウェアの一覧が表示されます。
	  これらのソフトウェアを手動で再インストールする必要があります。</para>
      </note>

      <para>&os; のバージョンが
	10.<replaceable>X</replaceable> より前であれば、
	以下の行を <filename>/etc/make.conf</filename> に追加して、
	Ports Collection がソフトウェアの登録に、伝統的な
	package のデータベースではなく、<application>pkg</application>
	を用いるように設定してください。</para>

      <programlisting>WITH_PKGNG=	yes</programlisting>

      <para>デフォルトでは、<application>pkg</application> は
	&os; の package ミラー (<emphasis>リポジトリ</emphasis>)
	のバイナリ package を用います。
	カスタム package リポジトリの構築については、
	<xref linkend="ports-poudriere"/> をご覧ください。</para>

      <para>その他の <application>pkg</application>
	の設定オプションは、&man.pkg.conf.5; に記述されています。</para>

      <para><application>pkg</application> の利用情報は、
	&man.pkg.8; マニュアルページや、
	<command>pkg</command> を引数なしに実行すると表示されます。</para>

      <para>各 <application>pkg</application> コマンドの引数は、
	コマンドに固有なマニュアルページに記述されています。
	たとえば、<command>pkg install</command> のマニュアルページを読むには、
	以下のコマンドのどちらかを実行してください。</para>

      <screen>&prompt.root; <userinput>pkg help install</userinput></screen>

      <screen>&prompt.root; <userinput>man pkg-install</userinput></screen>

      <para>以下の節では、<application>pkg</application>
	を用いた通常のバイナリ package の管理について説明します。
	各コマンドでは、カスタマイズのために、
	多くのオプションが使われています。
	詳細や、他の例については、
	コマンドのヘルプやマニュアルページを参照してください。</para>
    </sect2>
 
    <sect2 xml:id="pkgng-pkg-info">
      <title>インストールされている package の情報を入手する</title>

      <para>オプションを使用しないで <command>pkg info</command>
	を実行すると、
	システムにインストールされているすべての package もしくは、
	ある特定の package の情報が得られます。</para>

      <para>たとえば、インストールされている
	<application>pkg</application> の情報を調べるには、
	以下のように実行してください。</para>

      <screen>&prompt.root; <userinput>pkg info pkg</userinput>
pkg-1.1.4_1</screen>
    </sect2>

    <sect2 xml:id="pkgng-installing-deinstalling">
      <title>package のインストールと削除</title>

      <para>バイナリ package をインストールするには、
	以下のコマンドを使ってください。
	ここで <replaceable>packagename</replaceable> は、インストールする
	package の名前です。</para>

      <screen>&prompt.root; <userinput>pkg install <replaceable>packagename</replaceable></userinput></screen>

      <para>このコマンドは、リポジトリデータを使用して、
	インストールすべきソフトウェアのバージョン、および、
	インストールされていない依存ソフトウェアがあるかどうかを調べます。
	たとえば、<application>curl</application>
	をインストールするには以下を実行してください。</para>

      <screen>&prompt.root; <userinput>pkg install curl</userinput>
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages [y/N]: <userinput>y</userinput>
Checking integrity... done
[1/2] Installing ca_root_nss-3.15.1_1... done
[2/2] Installing curl-7.31.0_1... done
Cleaning up cache files...Done</screen>

	<para>新しい package と依存関係から追加された package は、
	  インストール済み package 一覧に表示されます。</para>

	<screen>&prompt.root; <userinput>pkg info</userinput>
ca_root_nss-3.15.1_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1	Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
pkg-1.1.4_6	New generation package manager</screen>

	<para>必要のなくなった packages は、
	  <command>pkg delete</command> を使って削除できます。
	  たとえば、以下のようにして削除できます。</para>

	<screen>&prompt.root; <userinput>pkg delete curl</userinput>
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages [y/N]: <userinput>y</userinput>
[1/1] Deleting curl-7.31.0_1... done</screen>
    </sect2>

    <sect2 xml:id="pkgng-upgrading">
      <title>インストールされている package のアップグレード</title>

      <para>以下のコマンドを実行すると、
	インストールされている packages
	が最新のバージョンにアップグレードされます。</para>

      <screen>&prompt.root; <userinput>pkg upgrade</userinput></screen>

      <para>このコマンドは、インストールされているソフトウェアのバージョンと、
	リポジトリのカタログから利用できるバージョンとを比較し、
	リポジトリからアップグレードします。</para>
    </sect2>

    <sect2 xml:id="pkgng-auditing">
      <title>インストールされている package の検証</title>

      <para>サードウェア製アプリケーションに対する脆弱性は、
	定期的に見つかります。脆弱性を調べるために、
	<application>pkg</application> は、検証機能を持っています。
	システムにインストールされているソフトウェアに既知の脆弱性がないかどうかを調べるには、
	以下のように実行してください。</para>

 	<screen>&prompt.root; <userinput>pkg audit -F</userinput></screen>
    </sect2>

    <sect2 xml:id="pkgng-autoremove">
      <title>リーフ依存 ports の自動削除</title>

      <para>package を削除すると、不必要な依存 ports
	が残されることがあります。
	依存のために導入され、現在は不必要になった package は、
	以下のようにすると自動的に検出され、削除されます。</para>

      <screen>&prompt.root; <userinput>pkg autoremove</userinput>
Packages to be autoremoved:
	ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages [y/N]: <userinput>y</userinput>
Deinstalling ca_root_nss-3.15.1_1... done</screen>
    </sect2>

    <sect2 xml:id="pkgng-backup">
      <title>package データベースのリストア</title>

      <para>伝統的な package 管理システムとは異なり、
	<application>pkg</application> には package
	データベースをバックアップするメカニズムがあります。
	この機能はデフォルトで有効に設定されています。</para>
	
      <tip>
	<para>スクリプトによる定期的な
	  package データベースのバックアップを無効にするには、
	  &man.periodic.conf.5; の中で、
	  <literal>daily_backup_pkgdb_enable="NO"</literal> 
	  と設定してください。</para>
      </tip>

      <para>過去にバックアップした package
	データベースの中身をリストアするには、
	以下のコマンドを実行してください。
	以下のコマンドの <replaceable>/path/to/pkg.sql</replaceable>
	については、バックアップのある場所に置き換えて実行してください。</para>

      <screen>&prompt.root; <userinput>pkg backup -r <replaceable>/path/to/pkg.sql</replaceable></userinput></screen>

      <note>
	<para>システムの定期的なスクリプトによって取得されたバックアップをリストアする場合には、
	  リストアの前に展開しておく必要があります。</para>
      </note>

      <para>手動で <application>pkg</application>
	データベースをバックアップするには、以下のコマンドを実行してください。
	以下のコマンドの <replaceable>/path/to/pkg.sql</replaceable>
	については、適切なファイル名と場所に置き換えて下さい。</para>

      <screen>&prompt.root; <userinput>pkg backup -d <replaceable>/path/to/pkg.sql</replaceable></userinput></screen>
    </sect2>

    <sect2 xml:id="pkgng-clean">
      <title>古くなった package の削除</title>

      <para>デフォルトでは、<application>pkg</application>
	は、&man.pkg.conf.5; の	<envar>PKG_CACHEDIR</envar>
	変数で定義されるキャッシュディレクトリにバイナリ
	packages を保存します。
	インストールされている package の最新のコピーのみが保存されます。
	古いバージョンの <application>pkg</application> では、
	過去にインストールされたすべての package が保存されていました。
	これらの古くなったバイナリ package を削除するには、
	以下を実行してください。</para>

      <screen>&prompt.root; <userinput>pkg clean</userinput></screen>

      <para>キャッシュ全体を削除するには以下を実行してください。</para>

      <screen>&prompt.root; <userinput>pkg clean -a</userinput></screen>
    </sect2>

    <sect2 xml:id="pkgng-set">
      <title>package メタデータの変更</title>

      <para>&os;&nbsp;Ports Collection
	では、メジャーバージョン番号が変更になることがあります。
	これに対応するために、<application>pkg</application> には、
	package の情報をアップデートするコマンドが組み込まれています。
	たとえば、<filename role="packages">lang/php5</filename> が、
	バージョン <literal>5.4</literal> を表すようになり、
	<filename role="packages">lang/php5</filename> を
	<filename role="package">lang/php53</filename>
	と名前を変更する必要があるような場合に、有用です。</para>

      <para>上記の例の package の情報を変更するには、
	以下のように実行してください。</para>

      <screen>&prompt.root; <userinput>pkg set -o lang/php5:lang/php53</userinput></screen>

      <para>別の例として、<package>lang/ruby18</package> を
	<package>lang/ruby19</package> にアップデートするには、
	以下のようにしてください。</para>

      <screen>&prompt.root; <userinput>pkg set -o lang/ruby18:lang/ruby19</userinput></screen>

      <para>最後の例として、
	<filename>libglut</filename> 共有ライブラリの情報を
	<package>graphics/libglut</package> から
	<package>graphics/freeglut</package> へと変更するには、
	以下のように実行してください。</para>

      <screen>&prompt.root; <userinput>pkg set -o graphics/libglut:graphics/freeglut</userinput></screen>

      <note>
	<para>package の情報を変更したら、
	  情報が変更された package に依存している
	  packages を再インストールすることが重要となります。
	  依存 packages を再インストールするには、
	  以下のように実行してください。</para>

	<screen>&prompt.root; <userinput>pkg install -Rf <replaceable>graphics/freeglut</replaceable></userinput></screen>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="ports-using">
    <title>Ports Collection の利用</title>

    <para>Ports Collection は、<filename>Makefile</filename>, 修正パッチ、
      説明文などの一連のファイルのことです。
      これらのファイルの各セットは、
      個々のアプリケーションをコンパイルして &os;
      にインストールするために用いられ、<emphasis>port</emphasis>
      と呼ばれています。</para>

    <para>デフォルトでは、Ports Collection は、<filename
	class="directory">/usr/ports</filename>
      以下のサブディレクトリに置かれます。</para>

    <para>port を用いてアプリケーションをコンパイルできるようにするには、
      まず最初に Ports Collection をインストールする必要があります。
      &os; のインストール時に Ports Collection
      をインストールしていない場合には、
      以下の方法のどれかを用いてインストールしてください。</para>

    <procedure xml:id="ports-using-portsnap-method">
      <title>Portsnap を利用する方法</title>

      <para>&os; のベースシステムには、<application>Portsnap</application>
	が含まれています。
	これはは Ports Collection
	を取得するための速くて使いやすく、
	多くのユーザに推奨されるツールです。
	このユーティリティは、&os; のサイトに接続し、セキュリティキーを検証し、
	Ports Collection の最新版をダウンロードします。
	セキュリティキーは、
	ダウンロードしたすべてのファイルの検証に用いられます。</para>

      <step>
	<para>圧縮された Ports Collection のスナップショットを
	  <filename>/var/db/portsnap</filename>
	  にダウンロードするには以下を実行してください。</para>

	<screen>&prompt.root; <userinput>portsnap fetch</userinput></screen>
      </step>

      <step>
	<para>初めて <application>Portsnap</application> を使う時は、
	  スナップショットをまず <filename>/usr/ports</filename>
	  に展開してください。</para>

	<screen>&prompt.root; <userinput>portsnap extract</userinput></screen>
      </step>

      <step>
	<para>上で示した <application>Portsnap</application>
	  を初めて利用する際に行うコマンドを実行した後は、
	  以下のコマンドで
	  <filename class="directory">/usr/ports</filename>
	  をアップデートしてください。</para>

	<screen>&prompt.root; <userinput>portsnap fetch</userinput>
&prompt.root; <userinput>portsnap update</userinput></screen>

	<para><literal>fetch</literal> を使う場合には、以下のよう
	  <literal>extract</literal> または <literal>update</literal>
	  を連続して行うことができます。</para>

	<screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>
      </step>
    </procedure>

    <procedure xml:id="ports-using-subversion-method">
      <title>Subversion を用いる方法</title>

      <para>ports ツリーの管理が必要な場合や、
	ローカルで変更点をメンテナンスする必要がある場合には、
	<application>Subversion</application> を使って
	Ports Collection を取得する方法があります。
	<application>Subversion</application> のより詳細な説明については、
	<link
	  xlink:href="&url.articles.committers-guide.en;/subversion-primer.html">
	Subversion Primer</link> を参照してください。</para>

      <step>
	<para><application>Subversion</application>
	  を使って ports ツリーをチェックアウトする前に、
	  <application>Subversion</application>
	  をインストールしておく必要があります。
	  ports ツリーがすでにインストールされていれば、
	  以下のようにして <application>Subversion</application>
	  をインストールできます。</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/devel/subversion</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>ports ツリーが利用できない場合や、
	  package の管理に <application>pkg</application>
	  を使っているのであれば、package から
	  <application>Subversion</application> をインストールできます。</para>

	<screen>&prompt.root; <userinput>pkg install subversion</userinput></screen>
      </step>

      <step>
	<para>ports ツリーをチェックアウトしてください。</para>

	<screen>&prompt.root; <userinput>svn checkout https://svn.FreeBSD.org/ports/head /usr/ports</userinput></screen>
      </step>

      <step>
	<para><application>Subversion</application>
	  で最初のチェックアウトを行ったら、必要に応じて
	  <filename class="directory">/usr/ports</filename>
	  をアップデートしてください。</para>

	<screen>&prompt.root; <userinput>svn update /usr/ports</userinput></screen>
      </step>
    </procedure>

    <para>Ports Collection
      は、ソフトウェアのカテゴリを表すディレクトリを持ちます。
      各カテゴリには、各アプリケーションのサブディレクトリがあります。
      各アプリケーションのサブディレクトリには、
      プログラムを &os;
      上で正しくコンパイルしてインストールする方法を提供する、
      <emphasis>ports スケルトン</emphasis>
      と呼ばれるファイルのセットが含まれています。
      それぞれの port スケルトンには、
      次のファイルおよびディレクトリが含まれています。</para>

    <itemizedlist>
      <listitem>
	<para><filename>Makefile</filename>:
	  このファイルにはアプリケーションのコンパイル方法やシステムのどこにインストールするかを指定する命令文が含まれています。</para>
      </listitem>

      <listitem>
	<para><filename>distinfo</filename>:
	  このファイルには、その port
	  を構築するためにダウンロードする必要があるファイルのファイル名と、
	  チェックサム情報が含まれています。</para>
      </listitem>

      <listitem>
	<para><filename>files</filename>:
	  このディレクトリには &os; 上でプログラムをコンパイルし、
	  インストールするための修正パッチが含まれています。
	  このディレクトリには、その port
	  の構築に必要なその他のファイルが入る場合もあります。</para>
      </listitem>

      <listitem>
	<para><filename>pkg-descr</filename>:
	  このファイルにはプログラムに関する、
	  より詳しい説明文が含まれます。</para>
      </listitem>

      <listitem>
	<para><filename>pkg-plist</filename>:
	  これは、その port によってインストールされる全ファイルのリストです。
	  これにはプログラムを削除する際に、
	  どのファイルを削除すれば良いのかを ports
	  システムに伝える役割もあります。</para>
      </listitem>
    </itemizedlist>

    <para>これらの他に <filename>pkg-message</filename>
      や特殊な状況に対応するためのファイルを含む ports もあります。
      これらのファイルについての詳細および
      ports の一般的な説明については、
      <link xlink:href="&url.books.porters-handbook;/index.html">port
      作成者のためのハンドブック</link> をご覧下さい。</para>

    <para>port は実際のソースコード
      (<filename>distfile</filename> とも呼ばれます)
      を含んではいません。
      port の構築の展開部で、ダウンロードされたソースは自動的に <filename
	class="directory">/usr/ports/distfiles</filename>
      に保存されます。</para>

    <sect2 xml:id="ports-skeleton">
      <title>ports のインストール</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>installing</secondary>
      </indexterm>

      <para>この節では、Ports Collection
	を利用してプログラムをインストールしたり、
	システムから削除したりする基本的な手順について説明します。
	利用可能な <command>make</command>
	のターゲットや環境変数についての詳細は
	&man.ports.7; をご覧ください。</para>

      <warning>
	<para>いかなる port でも、構築する前には、
	  前節に書かれているように、Ports Collection
	  をアップデートしてください。
	  サードパーティ製のソフトウェアをインストールすると、
	  セキュリティの脆弱性を引き起こす可能性があります。
	  その port に関連したセキュリティ上の問題がないことを、まずは
	  <link xlink:href="https://vuxml.freebsd.org/"></link>
	  で確認してください。または、
	  新しい port をインストールする前に、
	  <command>pkg audit -F</command> を実行してください。
	  毎日のシステムのセキュリティ確認時に、
	  自動的にセキュリティの検査およびデータベースの更新を行うようにこのコマンドを設定できます。
	  詳しくは、&man.pkg-audit.8; および
	  &man.periodic.8; を参照してください。</para>
      </warning>

      <para>Ports Collection は、ネットワークに接続できることを想定しています。
	また、superuser の権限も必要となります。</para>

      <para>port をコンパイルしてインストールするには、
	インストールしたい port のディレクトリに移動してください。
	その後、プロンプトから
	<command>make install</command> と入力してください。
	すると、次のような出力が現われるはずです。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput>
&prompt.root; <userinput>make install</userinput>
&gt;&gt; lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.88
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.88D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.88.d,8
===&gt;  Applying FreeBSD patches for lsof-4.88.d,8
===&gt;  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===&gt;  Building for lsof-4.88.d,8
...
[compilation output snipped]
...
===&gt;  Installing for lsof-4.88.d,8

===&gt;  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.88.d,8
===&gt;   Registering installation for lsof-4.88.d,8
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
&prompt.root;</screen>

      <para><command>lsof</command> は高い権限で動作するプログラムなので、
	インストールする時にセキュリティに関する警告が表示されます。
	インストールが終わったら、プロンプトが戻ります。</para>

      <para>シェルによってはコマンドの実行ファイルを探す時間を短縮するために、
	環境変数 <envar>PATH</envar> に登録されている
	ディレクトリのコマンド一覧をキャッシュするものがあります。
	<command>tcsh</command> シェルを使っているのであれば、
	フルパスを指定することなく新しくインストールしたコマンドを利用できるように、
	<command>rehash</command> を実行してください。
	<command>sh</command> シェルを使っているのであれば
 	かわりに <command>hash -r</command> を実行してください。
	詳細については、
	あなたの使っているシェルのドキュメントをご覧ください。</para>

      <para>インストールの間に、作業用ディレクトリが作成されます。
	このディレクトリにはコンパイル時に使用されるすべての一時ファイルが含まれています。
	このディレクトリを削除することで、ディスク容量を節約でき、また port
	を新しいバージョンへアップデートする際に問題が起こる可能性を小さくします。</para>

      <screen>&prompt.root; <userinput>make clean</userinput>
===&gt;  Cleaning for lsof-88.d,8
&prompt.root;</screen>

      <note>
	<para>port を構築する際に、
	  <command>make install clean</command>
	  と実行することで、
	  これらの余分な手順を省くことができます。</para>
      </note>

      <sect3>
	<title>ports のインストールのカスタマイズ</title>

	<para>ports の中にはビルドオプションを指定できるものがあります。
	  このオプションを指定することで、
	  アプリケーションの機能の一部を有効もしくは無効にできます。
	  また、セキュリティオプションを設定したり、
	  その他のカスタマイズを行うことができます。
	  このようなアプリケーションには
	  <filename role="package">www/firefox</filename>,
	  <filename role="package">security/gpgme</filename> や
	  <filename role="package">mail/sylpheed-claws</filename>
	  などがあります。
	  port が他のカスタマイズ可能なオプションを持つ ports
	  に依存する場合には、デフォルトでは、ユーザに port
	  のオプションをメニューから選択させる設定のため、
	  何度もユーザとの対話が起こり待たされることがあります。
	  これを避けるには、まず最初に port スケルトンで
	  <command>make config-recursive</command>
	  を実行して設定を一括で行い、その後
	  <command>make install [clean]</command>
	  を実行して port を構築してインストールしてください。</para>

	<tip>
	  <para><buildtarget>config-recursive</buildtarget> を実行する際、
	    <buildtarget>all-depends-list</buildtarget>
	    を実行すると、設定すべき ports の一覧を得ることができます。
	    多くの場合は、すべての依存 ports のオプションが定義され、
	    ports オプションの画面が表示されなくなり、
	    すべてのオプションが設定されたことを確認できるまで
	    <command>make config-recursive</command>
	    を実行すると良いでしょう。</para>
	</tip>

	<para>port の構築後、
	  再びこのメニューを表示させてオプションの追加や削除、
	  設定の変更を行う方法はたくさんあります。
	  一つ目は port のディレクトリに <command>cd</command> で移動し、
	  <command>make	config</command>
	  と入力する方法です。
	  別の方法は <command>make showconfig</command>
	  を使う方法です。
	  他の方法は <command>make rmconfig</command>
	  の実行です。
	  このコマンドを実行すると選択されているすべてのオプションが削除され、
	  設定をもう一度やり直すことができます。
	  これらの方法や他の方法についての詳細は、
	  &man.ports.7; マニュアルで説明されています。</para>

	<para>ports は、いくつかの環境変数を参照する &man.fetch.1;
	  を用いてソースファイルをダウンロードします。
	  &os; システムがファイアウォールの内側であったり、
	  FTP/HTTP プロキシを使う場合には、
	  <envar>FTP_PASSIVE_MODE</envar>,
	  <envar>FTP_PROXY</envar>, <envar>FTP_PASSWORD</envar>
	  の環境変数を設定することなります。
	  対応している環境変数の一覧については
	  &man.fetch.3; をご覧ください。</para>

	<para>インターネットに常時接続できないユーザのために
	  <command>make fetch</command>
	  コマンドが用意されています。
	  このコマンドを
	  <filename class="directory">/usr/ports</filename>
	  で実行してすべての distfiles をダウンロードするか、
	  <filename class="directory">/usr/ports/net</filename>
	  といったカテゴリや、あるスケルトンにおいても実行できます。
	  ある port がライブラリやその他の ports に依存している場合には、
	  別のカテゴリの ports の distfiles
	  はダウンロードされ<emphasis>ない</emphasis>ことに注意してください。
	  port が依存しているすべての distfiles をダウンロードしたければ、
	  <command>make fetch-recursive</command>
	  を使ってください。</para>

	<para>めったにないことかもしれませんが、
	  ローカルに distfiles のリポジトリがあるような場合に、
	  <varname>MASTER_SITES</varname> 変数を変更することで
	  <filename>Makefile</filename> で指定されているダウンロードの場所を
	  変更することができます。
	  設定する場合には、変更先を以下のようにして指定してください。</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make MASTER_SITE_OVERRIDE= \
<replaceable>ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/</replaceable> fetch</userinput></screen>

	<para><varname>WRKDIRPREFIX</varname> 変数と
	  <varname>PREFIX</varname> 変数を変更することで、
	  作業ディレクトリやターゲットディレクトリをデフォルトのものから変更できます。</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=/usr/home/example/ports install</userinput></screen>

	<para>とすると、ports は <filename
	    class="directory">/usr/home/example/ports</filename>
	  でコンパイルされ、すべて <filename
	    class="directory">/usr/local</filename>
	  以下にインストールされます。</para>

	<screen>&prompt.root; <userinput>make PREFIX=/usr/home/example/local install</userinput></screen>

	<para>この場合、port のコンパイルは <filename
	    class="directory">/usr/ports</filename>
	  でおこない、<filename
	    class="directory">/usr/home/example/local</filename>
	  にインストールします。そして</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=../ports PREFIX=../local install</userinput></screen>

	<para>とすれば両者を組み合わせることが可能です。</para>

	<para>これらを環境変数に設定する方法もあります。
	  どのように環境変数を設定するかについては、
	  あなたの使っているシェルのマニュアルページを参照してください。</para>
      </sect3>
    </sect2>

    <sect2 xml:id="ports-removing">
      <title>インストールした ports の削除</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>削除</secondary>
      </indexterm>

      <para>インストールされた ports は、
	<command>pkg delete</command> コマンドで削除できます。
	このコマンドの使用例は、&man.pkg-delete.8;
	マニュアルページにあります。</para>

      <para>あるいは、port のディレクトリにて
	<command>make deinstall</command> を実行することでも削除できます。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput>
<userinput>make deinstall</userinput>
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done</screen>

      <para>port が削除されるときに表示されるメッセージを読むことをお勧めします。
	もし削除した port に依存するアプリケーションがあった場合には、
	その情報が表示されますが、port の削除は行われます。
	そのようなケースでは、依存を直すためにアプリケーションを再インストールするとよいでしょう。</para>
    </sect2>

    <sect2 xml:id="ports-upgrading">
      <title>ports のアップグレード</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>アップグレード</secondary>
      </indexterm>

      <para>ports のインストール後、時間が経過すると、Ports Collection
	で新しいバージョンのソフトウェアを利用できるようになります。
	この章では、
	どのようにしてアップグレードする必要のあるソフトウェアを判断するか、
	そしてアップグレードの方法について説明します。</para>

      <para>インストールされている ports
	の新しいバージョンを利用できるかどうかを知るには、まず、
	最新の ports ツリーがインストールされていることを確認してください。
	これには、<xref linkend="ports-using-portsnap-method"/> もしくは
	<xref linkend="ports-using-subversion-method"/>
	で書かれているアップデートのコマンドを使ってください。
	&os; 10 以降のシステム、または、<application>pkg</application>
	に変換されたシステムでは、
	以下のコマンドを実行すると、現在利用可能なバージョンよりも古い
	ports の一覧が表示されます。</para>

      <screen>&prompt.root; <userinput>pkg version -l "&lt;"</userinput></screen>

      <para>&os; 9.<replaceable>X</replaceable> より前のシステムでは、
	現在利用可能なバージョンよりも古い
	ports の一覧を表示されるには、以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>pkg_version -l "&lt;"</userinput></screen>

      <important>
	<para>アップグレードする前に
	  <filename>/usr/ports/UPDATING</filename>
	  を、ファイルの頭から、ports を最後にアップデートした日、
	  もしくはシステムをインストールをした日に最も近い日まで目を通してください
	  このファイルには
	  port をアップグレードする際にユーザが遭遇するであろう問題や、
	  追加で必要な作業などが記述されています。
	  例えば、ファイル形式の変更や設定ファイルの場所の変更、
	  前のバージョンと互換性がなくなったことなどが書かれています。
	  アップグレードする必要のある ports に関連した手順に注意し、
	  アップグレードする際にはこれらの手順に従ってください。</para>
      </important>

      <sect3 xml:id="ports-upgrading-tools">
	<title>ports のアップグレードおよび管理ツール</title>

	<indexterm>
	  <primary>ports</primary>
	  <secondary>アップグレードツール</secondary>
	</indexterm>

	<para>Ports Collection には、
	  実際にアップグレードを行うためのユーティリティがいくつか用意されています。
	  それぞれのユーティリティは長所と短所を持っています。</para>

	<para>歴史的に、最もインストールされ使われているのは、
	  <application>Portmaster</application> または
	  <application>Portupgrade</application> です。
	  <application>Synth</application> は新しいユーティリティです。</para>

	<note>
	  <para>特定のシステムにおいて、
	    どのツールを選択するとベストかについては、
	    システム管理者によります。
	    これらのどのツールでも、使う前には、
	    データのバックアップをとることが推奨されます。</para>
	</note>

      </sect3>

      <sect3 xml:id="portmaster">
	<title><application>portmaster</application>
	  を用いた ports のアップグレード</title>

	<indexterm>
	  <primary>portmaster</primary>
	</indexterm>

	<para><package>ports-mgmt/portmaster</package> は、
	  インストールされている ports のアップグレードをおこなう、
	  とても小さなユーティリティです。
	  &os; のベースシステムとしてインストールされているツールだけを使い、
	  他の ports やデータベースに依存しないように設計されています。
	  port
	  からこのユーティリティをインストールするには以下のようにしてください。</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portmaster</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para><application>Portmaster</application> は、
	  ports を 4 つのカテゴリに分類します。</para>

	<itemizedlist>
	  <listitem>
	    <para>Root ports: 他の port に依存せず、
	      他の port からも依存されない ports。</para>
	  </listitem>

	  <listitem>
	    <para>Trunk ports: 他の port には依存しないが、
	      他の port から依存されている ports。</para>
	  </listitem>

	  <listitem>
	    <para>Branch ports: 他の port に依存し、
	      他の port からも依存されている ports。</para>
	  </listitem>

	  <listitem>
	    <para>Leaf ports: 他の port に依存するが、
	      他の port からは依存されない ports。</para>
	  </listitem>
	</itemizedlist>

	<para>これらのカテゴリの一覧や、アップデート可能な
	  port の一覧を表示するには以下のようにしてください。</para>

<screen>&prompt.root; <userinput>portmaster -L</userinput>
===&gt;&gt;&gt; Root ports (No dependencies, not depended on)
===&gt;&gt;&gt; ispell-3.2.06_18
===&gt;&gt;&gt; screen-4.0.3
        ===&gt;&gt;&gt; New version available: screen-4.0.3_1
===&gt;&gt;&gt; tcpflow-0.21_1
===&gt;&gt;&gt; 7 root ports
...
===&gt;&gt;&gt; Branch ports (Have dependencies, are depended on)
===&gt;&gt;&gt; apache22-2.2.3
        ===&gt;&gt;&gt; New version available: apache22-2.2.8
...
===&gt;&gt;&gt; Leaf ports (Have dependencies, not depended on)
===&gt;&gt;&gt; automake-1.9.6_2
===&gt;&gt;&gt; bash-3.1.17
        ===&gt;&gt;&gt; New version available: bash-3.2.33
...
===&gt;&gt;&gt; 32 leaf ports

===&gt;&gt;&gt; 137 total installed ports
        ===&gt;&gt;&gt; 83 have new versions available</screen>

	<para>以下のコマンドを使うと、
	  古くなった ports をすべてアップデートします。</para>

	<screen>&prompt.root; <userinput>portmaster -a</userinput></screen>

	<note>
	  <para><application>Portmaster</application> のデフォルトの設定では、
	  インストールされている port を削除する前に、
	  バックアップ用の package が作成されます。
	  このバックアップは、
	  新しいバージョンのインストールに成功すると削除されます。
	  <option>-b</option> を使うと、
	  <application>Portmaster</application>
	  の自動的なバックアップの削除は行いません。
	  <option>-i</option> を追加すると、
	  <application>Portmaster</application>
	  をインタラクティブモードで使用できます。
	  このモードでは、各 port
	  をアップグレードするかどうかの選択を対話的に行うことがでます。
	  多くのオプションが利用可能です。
	  &man.portmaster.8; マニュアルページから、
	  それらの使用方法に関する詳細な説明を読んでください。</para>
	</note>

	<para>アップグレードの過程でエラーに遭遇した場合には、
	  <option>-f</option> を使ってすべての
	  ports のアップグレードや再構築を行なってください。</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para><application>Portmaster</application>
	  を使ってシステムに新しい ports をインストールしたり、
	  新しい port のコンパイルやインストール前に依存するすべての
	  port をアップグレードできます。この機能を使う時には、
	  Ports Collection の場所を指定してください。</para>

	<screen>&prompt.root; <userinput>portmaster <replaceable>shells/bash</replaceable></userinput></screen>

	<para><package>ports-mgmt/portmaster</package>
	  に関するより多くの情報は、<filename>pkg-descr</filename>
	  にあります。</para>
      </sect3>

      <sect3 xml:id="portupgrade">
	<title>Portupgrade を用いた ports のアップグレード</title>

	<indexterm>
	  <primary>portupgrade</primary>
	</indexterm>

	<para><package>ports-mgmt/portupgrade</package> は、
	  インストールした ports
	  のアップグレードを行なうためのもう一つのユーティリティです。
	  このユーティリティは ports
	  を管理するために用いられるアプリケーションのセットをインストールします。
	  Ruby に依存します。
	  port をインストールするには、以下を実行してください。</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portupgrade</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>このユーティリティを使ってアップグレードを行う前に、
	  <command>pkgdb -F</command> を使って、
	  インストールされている ports の一覧を調べてください。
	  矛盾が検出された場合には修復してください。</para>

	<para>システムにインストールされている port
	  の中で古くなったものをすべてアップデートするには
	  <command>portupgrade -a</command> を実行してください。
	  もし、すべての ports
	  に対して個別にアップグレードするかどうかを確認したいのであれば、
	  <option>-i</option> を追加してください。</para>

	<screen>&prompt.root; <userinput>portupgrade -ai</userinput></screen>

	<para>ports で利用可能なすべてのアプリケーションではなく、
	  ある特定のアプリケーションだけを更新したいのであれば、
	  <command>portupgrade <replaceable>pkgname</replaceable></command>
	  を実行してください。
	  アップグレードするアプリケーションが依存しているすべての
	  ports をまず先に更新したい場合には、
	  <option>-R</option> を使ってください。</para>

	<screen>&prompt.root; <userinput>portupgrade -R firefox</userinput></screen>

	<para><option>-P</option> オプションを使うと、
	  <application>portupgrade</application> は
	  <envar>PKG_PATH</envar> に登録されているローカルディレクトリから、
	  利用可能な package を探します。
	  ローカルに利用可能な packages が見つからなければ、
	  リモートサイトから package のダウンロードを試みます。
	  packages をローカルに見つけることができず、
	  リモートサイトからもダウンロードできない場合には、
	  <application>portupgrade</application>
	  は ports からインストールを行ないます。
	  ports を使用したくなければ、<option>-PP</option>
	  オプションを指定してください。
	  この最後のオプションを設定すると、
	  もし package が利用できなければ
	  <application>Portupgrade</application> は終了します。</para>

	<screen>&prompt.root; <userinput>portupgrade -PP gnome3</userinput></screen>

      <para>また、ビルドやインストールを行なわず、
	distfiles または packages だけをダウンロードしたければ、
	<option>-F</option> オプションを指定してください。
	利用可能なすべてのオプションについては、
	&man.portupgrade.1; のマニュアルを参照してください。</para>

	<para><package>ports-mgmt/portupgrade</package>
	  に関するより多くの情報は、<filename>pkg-descr</filename>
	  にあります。</para>
      </sect3>

    </sect2>

    <sect2 xml:id="ports-disk-space">
      <title>ports とディスク容量</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>ディスク容量</secondary>
      </indexterm>

      <para>Ports Collection を使い続けていると、
	そのうちディスクを食いつぶしてしまうでしょう。
	ports をビルドしてインストールした後、
	ports スケルトンで <command>make clean</command>
	を実行すると、作業用の <filename>work</filename>
	ディレクトリを削除します。
	<application>Portmaster</application> を使って port
	をインストールする場合には、<option>-K</option>
	を使わなければこのディレクトリは自動的に削除されます。
	<application>Portupgrade</application>
	がインストールされている場合には、
	以下のコマンドはローカルの Ports Collection
	に見つかったすべての <filename class="directory">work</filename>
	ディレクトリを削除します。</para>

      <screen>&prompt.root; <userinput>portsclean -C</userinput></screen>

      <para>さらに、時間が経つにつれ
	<filename class="directory">/usr/ports/distfiles</filename>
	には、古くなったソースファイルがたまっていきます。
	<application>Portupgrade</application>
	を使って、どの ports からも使われていないすべての
	distfiles を削除するには次のように実行してください。</para>

      <screen>&prompt.root; <userinput>portsclean -D</userinput></screen>

      <para><application>Portupgrade</application>
	を使って、システムにインストールされている port から使われていない
	distfiles をすべて削除することができます。</para>

      <screen>&prompt.root; <userinput>portsclean -DD</userinput></screen>

      <para>もし <application>Portmaster</application>
	がインストールされているのであれば、以下を実行してください。</para>

      <screen>&prompt.root; <userinput>portmaster --clean-distfiles</userinput></screen>

      <para>デフォルトでは、このコマンドはインタラクティブに設定されているため、
	ユーザに対して distfile
	を削除すべきかどうかを確認するプロンプトが表示されます。</para>

      <para>これらのコマンドに加え、<filename
	  role="package">ports-mgmt/pkg_cutleaves</filename> は、
	必要なくなった ports を削除する作業を自動化します。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ports-poudriere">
    <title><application>Poudriere</application> を用いた
      package の構築</title>

    <para><application>poudriere</application> は、&os; package
      を作成したり、試験に用いられる <acronym>BSD</acronym>
      ライセンスのユーティリティです。
      このユーティリティは、&os; jails を用いて、
      独立したコンパイル環境を構築します。
      これらの jail を使って、
      インストールされている &os; のバージョンとは異なるバージョンの
      package を作成したり、ホストが &arch.amd64; のシステムでは、
      i386 用の package を構築することもできます。
      構築された package のレイアウトは公式のミラーと同じです。
      これらの package は、&man.pkg.8; や他の
      package 管理ツールで利用できます。</para>

    <para><package role="port">ports-mgmt/poudriere</package> package
      または port から <application>poudriere</application>
      をインストールしてください。
      アプリケーションをインストールすると、サンプルの設定ファイルである
      <filename>/usr/local/etc/poudriere.conf.sample</filename>
      もインストールされます。
      このファイルを
      <filename>/usr/local/etc/poudriere.conf</filename> にコピーして、
      ローカルの環境に合わせて編集してください。</para>

    <para><application>poudriere</application> を実行するシステムで、
      必ずしも <acronym>ZFS</acronym> を使う必要はありませんが、
      有用です。<acronym>ZFS</acronym> を使う際には、
      <filename>/usr/local/etc/poudriere.conf</filename>
      の中で <varname>ZPOOL</varname> を指定する必要があります。
      そして、<varname>FREEBSD_HOST</varname>
      を最も近いミラーに設定してください。
      <varname>CCACHE_DIR</varname> を定義することで、
      <package role="port">devel/ccache</package>
      を使ったコンパイルのキャッシュが可能となり、
      コンパイルで頻繁に使われるコードの構築時間を短縮できます。
      <application>poudriere</application> データセットを
      <filename>/poudriere</filename>
      にマウントされた独立したツリーに置くと良いでしょう。
      他の値はデフォルトの値で十分です。</para>

    <para>同時に走らせるコンパイル数の定義には、
      認識されたコアプロセッサの数が用いられます。
      <acronym>RAM</acronym>
      もしくはスワップ空間のどちらかの仮想メモリを十分用意してください。
      もし、仮想メモリを使い切ってしまったら、jail の構築は中断し、
      異常なメッセージが表示されることでしょう。</para>

    <sect2 xml:id="poudriere-initialization">
      <title>Jails および Port ツリーの初期化</title>

      <para>設定が終わったら、<application>poudriere</application>
	を初期化して、必要とする &os; ツリーおよび jail、
	そして ports ツリーをインストールしてください。
	jail の名前を <option>-j</option>、
	&os; のバージョンを <option>-v</option> で指定してください。
	&os;/&arch.amd64; システムでは、
	<option>-a</option> を使ってアーキテクチャに
	<literal>i386</literal> または <literal>amd64</literal>
	を設定できます。
	デフォルトでは、<command>uname</command>
	で表示されるアーキテクチャに設定されます。</para>

      <screen>&prompt.root; <userinput>poudriere jail -c -j <replaceable>10amd64</replaceable> -v <replaceable>10.0-RELEASE</replaceable></userinput>
====&gt;&gt; Creating 10amd64 fs... done
====&gt;&gt; Fetching base.txz for FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/base.txz      100% of   59 MB 1470 kBps 00m42s
====&gt;&gt; Extracting base.txz... done
====&gt;&gt; Fetching src.txz for FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/src.txz       100% of  107 MB 1476 kBps 01m14s
====&gt;&gt; Extracting src.txz... done
====&gt;&gt; Fetching games.txz for FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/games.txz     100% of  865 kB  734 kBps 00m01s
====&gt;&gt; Extracting games.txz... done
====&gt;&gt; Fetching lib32.txz for FreeBSD 10.0-RELEASE amd64
/poudriere/jails/10amd64/fromftp/lib32.txz     100% of   14 MB 1316 kBps 00m12s
====&gt;&gt; Extracting lib32.txz... done
====&gt;&gt; Cleaning up... done
====&gt;&gt; Jail 10amd64 10.0-RELEASE amd64 is ready to be used</screen>

      <screen>&prompt.root; <userinput>poudriere ports -c -p <replaceable>local</replaceable></userinput>
====&gt;&gt; Creating local fs... done
====&gt;&gt; Extracting portstree "local"...
Looking up portsnap.FreeBSD.org mirrors... 7 mirrors found.
Fetching public key from ec2-eu-west-1.portsnap.freebsd.org... done.
Fetching snapshot tag from ec2-eu-west-1.portsnap.freebsd.org... done.
Fetching snapshot metadata... done.
Fetching snapshot generated at Tue Feb 11 01:07:15 CET 2014:
94a3431f0ce567f6452ffde4fd3d7d3c6e1da143efec76100% of   69 MB 1246 kBps 00m57s
Extracting snapshot... done.
Verifying snapshot integrity... done.
Fetching snapshot tag from ec2-eu-west-1.portsnap.freebsd.org... done.
Fetching snapshot metadata... done.
Updating from Tue Feb 11 01:07:15 CET 2014 to Tue Feb 11 16:05:20 CET 2014.
Fetching 4 metadata patches... done.
Applying metadata patches... done.
Fetching 0 metadata files... done.
Fetching 48 patches.
(48/48) 100.00%  done.
done.
Applying patches...
done.
Fetching 1 new ports or files... done.
/poudriere/ports/tester/CHANGES
/poudriere/ports/tester/COPYRIGHT

[...]

Building new INDEX files... done.</screen>

      <para>一つのコンピュータ上で、
	複数の設定、複数の jails、異なる port ツリーから
	<application>poudriere</application> は port をビルドできます。
	これらのコンビネーションのカスタム設定は
	<emphasis>セット</emphasis> と呼ばれます。
	詳細については、<package>ports-mgmt/poudriere</package> もしくは
	<package>ports-mgmt/poudriere-devel</package> をインストール後、
	&man.poudriere.8; の CUSTOMIZATION の章をご覧下さい。</para>

      <para>ここで示される基本設定では、jail, ports そしてセット固有の
	<filename>make.conf</filename> を
	<filename>/usr/local/etc/poudriere.d</filename> に置いてください。
	この例でのファイル名
	<filename><replaceable>10amd64-local-workstation</replaceable>-make.conf</filename>
	は、jail 名、port 名そして、セット名の組み合わせで付けられています。
	システムの <filename>make.conf</filename>
	と、この新しいファイルは、ビルド時に結合され、構築した jail
	で用いられる <filename>make.conf</filename> を作成します。</para>

      <para>ビルドする package を
	<filename><replaceable>10amd64-local-workstation</replaceable>-pkglist</filename> に記載してください。</para>

      <programlisting>editors/emacs
devel/git
ports-mgmt/pkg
...</programlisting>

      <para>特定の ports に対し、
	オプションや依存を設定してください。</para>

      <screen>&prompt.root; <userinput>poudriere options -j <replaceable>10amd64</replaceable> -p <replaceable>local</replaceable> -z <replaceable>workstation</replaceable> -f <replaceable>10amd64-local-workstation-pkglist</replaceable></userinput></screen>

      <para>最後に packages を構築し、
	package リポジトリを生成してください。</para>

      <screen>&prompt.root; <userinput>poudriere bulk -j <replaceable>10amd64</replaceable> -p <replaceable>local</replaceable> -z <replaceable>workstation</replaceable> -f <replaceable>10amd64-local-workstation-pkglist</replaceable></userinput></screen>

      <para>このコマンドの実行中に <keycombo
	  action="simul"><keycap>Ctrl</keycap><keycap>t</keycap></keycombo>
	を押すと、現在のビルド状況が表示されます。
	<application>Poudriere</application> は
	<filename>/poudriere/logs/bulk/<replaceable>jailname</replaceable>
	</filename>
	にあるファイルも構築します。
	このファイルをウェブサーバと共に使うことで、
	ビルド情報を表示できます。</para>

      <para>これが終わると、<application>poudriere</application>
	リポジトリを package
	のインストールに利用できるようになります。</para>

      <para><application>poudriere</application>
	を利用する上でのより多くの情報については、
	&man.poudriere.8; およびメインのウェブサイトである <link
	  xlink:href="https://github.com/freebsd/poudriere/wiki"></link>
	を参照してください。</para>
    </sect2>

    <sect2>
      <title>Poudriere リポジトリを使うための pkg クライアントの設定</title>

      <para>カスタムリポジトリと公式のリポジトリの両方を並行して使用することは可能ですが、
	公式リポジトリを無効にすると有用な場合があります。
	このように設定するには、設定ファイルを作成し、
	設定ファイルの中で公式リポジトリを無効にしてください。
	<filename>/usr/local/etc/pkg/repos/FreeBSD.conf</filename>
	を作成して、以下を含めてください。</para>

      <programlisting>FreeBSD: {
	enabled: no
}</programlisting>

      <para>通常は、HTTP 経由で poudriere
	リポジトリをクライアントコンピュータに公開すると簡単です。
	package ディレクトリ (たとえば、
	<filename>/usr/local/poudriere/data/packages/<replaceable>10amd64</replaceable></filename>
	) を公開するようにウェブサーバを設定してください。
	この例で <filename>10amd64</filename> は構築名です。</para>

      <para>もし、package リポジトリの URL が
	<literal>http://pkg.example.com/10amd64</literal> であれば、
	リポジトリの設定ファイルである
	<filename>/usr/local/etc/pkg/repos/custom.conf</filename> は、
	以下のようになります。</para>

      <programlisting>custom: {
	url: "<replaceable>http://pkg.example.com/10amd64</replaceable>",
	enabled: yes,
}</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="ports-nextsteps">
    <title>インストール後の作業</title>

    <para>バイナリ package もしくは port
      のどちらを用いてソフトウェアをインストールするかに関わらず、
      サードパーティ製のアプリケーションの多くは、
      インストール後にある程度の設定を必要とします。
      以下のコマンドや場所の情報は、
      アプリケーションとともに何がインストールされたかを知るための助けとなるでしょう。</para>

    <itemizedlist>
      <listitem>
	<para>多くのアプリケーションでは、
	  デフォルトの設定ファイルが、少なくとも一つは
	  <filename>/usr/local/etc</filename> にインストールされます。
	  数多くの設定ファイルを持つようなアプリケーションでは、
	  それらのファイルを格納するためにサブディレクトリを作成するものもあります。
	  サンプルの設定ファイルは、しばしば <filename>.sample</filename>
	  といった拡張子がついた名前でインストールされます。
	  設定ファイルを確認し、
	  必要に応じてシステムの要求に合うように編集してください。
	  最初にサンプルファイルを <filename>.sample</filename>
	  を外した名前のファイルにコピーしてから、編集してください。</para>
      </listitem>

      <listitem>
	<para>ドキュメントが付属しているアプリケーションは、
	  ドキュメントを <filename>/usr/local/share/doc</filename>
	  にインストールします。また、
	  多くのアプリケーションは、マニュアルページもインストールします。
	  これらのドキュメントは、
	  アプリケーションを使い続ける前に見ておくべきものです。</para>
      </listitem>

      <listitem>
	<para>ある種のアプリケーションでは、
	  サービスを実行するためには、
	  アプリケーションの起動前に、
	  <filename class="directory">/etc/rc.conf</filename>
	  に追加する必要があります。
	  これらのアプリケーションでは、通常、
	  スタートアップスクリプトが
	  <filename>/usr/local/etc/rc.d</filename>
	  にインストールされます。詳細は、
	  <link
	    linkend="configtuning-starting-services">サービスの起動</link>
	  をご覧ください。</para>

	<note>
	  <para>設計上、インストールの際に、アプリケーションは、
	    スタートアップスクリプトを実行しませんし、
	    アンインストールやアップグレードの際には、
	    停止のためのスクリプトは実行されません。
	    起動や停止の決定は、各システム管理者に任されています。</para>
	</note>

      </listitem>

      <listitem>
	<para>&man.csh.1; のユーザは、
	  <command>rehash</command> を実行して、
	  シェルの <envar>PATH</envar> のバイナリリストを再構築してください。</para>
      </listitem>

      <listitem>
	<para><command>pkg info</command>
	  を使って、アプリケーションと共にインストールされたファイル、
	  マニュアルページ、およびバイナリを調べることができます。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="ports-broken">
    <title>うまく動作しない ports に遭遇した場合には</title>

    <para>port をうまくコンパイルできなかったりインストールできない場合には、
      以下を試してください。</para>

    <orderedlist>
      <listitem>
	<para>その port に対する修正案が提出されていないかどうかを
	  <link xlink:href="&url.base;/ja/support.html">障害報告
	    (Problem Report) データベース</link> で調べてください。
	  もし提案されていれば、
	  その提案されている修正によって問題を解決できるかもしれません。</para>
      </listitem>

      <listitem>
	<para>port の保守担当者に対応してもらいましょう。
	  port スケルトンで <command>make maintainer</command> と入力するか、
	  port の <filename>Makefile</filename> を読み、
	  保守担当者の電子メールアドレスを調べてください。
	  保守担当者にメールを送る際には、port の
	  <filename>Makefile</filename> の
	  <literal>&dollar;FreeBSD:</literal> 行、
	  そしてエラーが出力されるまでの出力ログを忘れずに添付してください。</para>

	<note>
	  <para>特定の保守担当者が存在せず、かわりに <link
	      xlink:href="&url.articles.mailing-list-faq.en;/article.html">メーリングリスト
	    </link> によるグループの管理者が保守している ports があります。
	    そのような場合には、メールアドレスは
	    <email role="nolink">freebsd-<replaceable>listname</replaceable>@FreeBSD.org</email>
	    のようになります。
	    メールを送る際には、このことに気をつけてください。</para>

	  <para>特に <email role="nolink">ports@FreeBSD.org</email>
	    が保守している ports には、保守担当者がいません。
	    そのかわり、
	    そのメーリングリストを購読する人々からなるコミュニティが、
	    修正や対応をおこなっています。
	    もっとボランティアが必要です!</para>
	</note>

	<para>メールに対して返信がなければ、
	  <link xlink:href="&url.articles.problem-reports;/article.html">
	    &os; 障害報告の書き方</link> に書かれている手順にしたがい、
	  Bugzilla を使ってバグレポートを提出してください。</para>
      </listitem>

      <listitem>
	<para>自分で直しましょう!
	  ports システムに関する詳細な情報は
	  <link xlink:href="&url.books.porters-handbook;/index.html">port
	    作成者のためのハンドブック</link> にあります。
	  このセクションを読むと、壊れてしまった port を直したり、
	  自分で作った port を提出したりできるようになります!</para>
      </listitem>

      <listitem>
	<para><xref linkend="pkgng-intro"/> に書かれている手順にしたがって、
	  package をインストールしてください。</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>
