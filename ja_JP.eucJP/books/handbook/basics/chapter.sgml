<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.74
     $FreeBSD$
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>改訂</contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>Unix の基礎知識</title>

  <para><emphasis>訳: &a.jp.nakai;, 1996 年 10 月 12 日.</emphasis></para>

  <sect1>
    <title>この章では</title>
    <indexterm><primary>基礎知識(basics)</primary></indexterm>
    
    <para><emphasis>改訂: Chris Shumway
        <email>cshumway@osd.bsdi.com</email>, 2000 年 3 月 10 日.</emphasis></para>
    
    <para>この章では FreeBSD
      オペレーティングシステムの基本的なコマンドと機能について記述しています。
      ここに書かれてあることのほとんどは、
      どんな Unix オペレーティングシステムにもあてはまります。
      この章に書いてあることに馴染みがあるなら、
      この章は気軽に流し読みしてください。
      あなたが FreeBSD の初心者なら、
      何か質問する前にこの章を読んでおいた方がきっといいはずです。</para>

    <para>この章を読んで分かることは、次のようなことです。</para>

    <itemizedlist>
      <listitem>
	<para>Unix のファイルの許可属性の仕組み</para>
      </listitem>
      <listitem>
	<para>プロセス、デーモンとシグナルとはなにか</para>
      </listitem>
      <listitem>
	<para>シェルとはなにか。 また、デフォルトのログイン環境を変える方法</para>
      </listitem>
      <listitem>
	<para>テキストエディタの基本的な使い方</para>
      </listitem>
      <listitem>
	<para>さらに詳しい情報を得るためのマニュアルページの読み方</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="permissions">
    <title>許可属性</title>
    <indexterm><primary>Unix</primary></indexterm>

    <para>FreeBSD は BSD Unix の直系の子孫であり、
      いくつかの鍵となる Unix 思想にもとづいています。
      まず最も際だった特徴として最初に言えるのは、FreeBSD
      がマルチユーザのオペレーティングシステムだということです。
      FreeBSD は同時に働いている複数のユーザすべてを、
      完全に分離したタスク上で処理する能力を持っています。
      また FreeBSD は、ハードウェアデバイス、周辺装置、メモリ、
      CPU 時間等への要求を、各ユーザが平等に利用できるように適切に共有し、
      管理する役割を担っています。</para>

    <para>システムがマルチユーザをサポートしているため、
      システムが管理する資源はすべて、
      誰がその資源を読み・書き・実行できるかを支配する、
      一組の許可属性を持っています。
      これらの許可属性は 3 つの部分からなる 2 桁の 8 進数の形で格納されています。
      それはそのファイルの所有者(owner)に対するもの、
      そのファイルが所属するグループ(group)に対するもの、
      その他(others)に対するものの 3 つです。
      これを数字を使って表現すると、次のようになります。</para>

    <indexterm><primary>許可属性(permissions)</primary></indexterm>
    <indexterm>
      <primary>ファイルの許可属性(permissions)</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>値</entry>
	    <entry>許可属性</entry>
	    <entry>ディレクトリの表示</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>読み込み不可、書き込み不可、実行不可</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>読み込み不可、書き込み不可、実行可能</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>読み込み不可、書き込み可能、実行不可</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>読み込み不可、書き込み可能、実行可能</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>読み込み可能、書き込み不可、実行不可</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>読み込み可能、書き込み不可、実行可能</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>読み込み可能、書き込み可能、実行不可</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>読み込み可能、書き込み可能、実行可能</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>ディレクトリ</primary></indexterm>

    <para>&man.ls.1; に対してコマンドライン引数 <option>-l</option> を使うと、
      詳細なディレクトリリストを見ることができ、
      ファイルの所有者、グループ、その他への許可属性を示す欄があるのがわかります。
      次に示すのは、<command>ls -l</command>
      の最初の部分だけ抜き出したものです。</para>

    <screen>-rw-r--r--</screen>

    <para>最初の(一番左の)文字は、それが
      普通のファイルなのか、ディレクトリなのか、
      キャラクタ型のデバイス特殊ファイルなのか、
      ブロック型のデバイス特殊ファイルなのか、
      ソケットなのか、
      その他の特殊な疑似ファイルデバイスなのかといった種類を示す特別な文字です。
      この場合、<literal>-</literal> という文字は、
      普通のファイルであることを示します。
      この例でその次に来る <literal>rw-</literal> と書かれた 3 文字は、
      そのファイルの所有者に許可を与えるものです。
      その次の <literal>r--</literal> の 3 文字は、
      そのファイルが所属しているグループに許可を与えます。
      最後の <literal>r--</literal> の 3 文字は、
      システムに存在するその他のユーザに許可を与えます。
      <quote>-</quote> は許可が与えられていないことを示します。
      このファイルの例では、ファイルの所有者はこのファイルを読み書きでき、
      ファイルの所属しているグループに属するユーザはファイルを読むことだけでき、
      そのどちらでもないユーザは、
      このファイルを読むだけできるように許可属性が与えられています。
      上の表によれば、このファイルに与えられた許可属性は
      <literal>644</literal> となります。
      ここで各数字は、このファイルの許可属性の 3 つの部分を表しています。</para>

    <para>ファイルについてはここまでの説明で十分です。 しかし、
      デバイスの場合の許可属性はどのようにコントロールされているのでしょうか?
      FreeBSD は、大部分のハードウェアをファイルとして取り扱います。
      そのため、プログラムからは普通のファイルとまったく同じようにオープンし、
      データの読み書きができるようになっています。     
      これらのデバイス特殊ファイルは
      <filename>/dev</filename> ディレクトリに収められています。</para>

    <para>ディレクトリもまた、ファイルと同様に扱われます。
      それは読み込み/書き込み/実行の許可属性を持ちます。
      ディレクトリの実行ビットはファイルのそれとは少し違った意味を持ちます。
      ディレクトリが実行可能になっているとき、
      そのディレクトリに移動することができます。
      つまり、そのディレクトリに <quote>cd</quote> することが可能です。
      また、実行可能属性がついているディレクトリでは、
      名前が分かっているファイルにアクセスすることもできます
      (もちろんそのファイル自体の許可属性によります)。
    </para>

    <para>特に、ディレクトリの中の一覧を表示させるためには、
      そのディレクトリに読み込み属性が設定されていなければなりません。
      一方、名前が分かっているファイルを削除するためには、
      そのファイルが含まれているディレクトリに
      書き込み属性<emphasis>と</emphasis>実行属性
      の両方が必要です。</para>

    <para>この他にも許可属性ビットはありますが、いずれも
      setuid バイナリや sticky ディレクトリなどといった特殊な状況で使われます。
      ファイルの許可属性そのものについて、
      また、それらの設定のしかたに関する詳しい情報は、
        &man.chmod.1; マニュアルページを参照してください。</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>ディレクトリ構造</title>
    <indexterm><primary>ディレクトリの階層構造</primary></indexterm>

    <para>FreeBSD のディレクトリ構造は、
      システム全体を理解するに当たって重要です。
      把握しておくべき最も重要なものは、<quote>/</quote>
      ディレクトリです。 このディレクトリは起動時に一番最初にマウントされ、
      オペレーティングシステムをマルチユーザで動作させるために
      必要な基本システムが含まれています。
      また、ルートディレクトリには、
      他のファイルシステムをマウントするためのマウントポイントも含まれます。
    </para>

    <para>マウントポイントとはルートファイルシステムに存在する、
      追加のファイルシステムと接続するためのディレクトリのことです。
      標準的なマウントポイントには
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/mnt</filename>, <filename>/cdrom</filename>
      があります。 
      通常これらのディレクトリについては、
      <filename>/etc/fstab</filename> というファイル中のエントリが参照されます。
      <filename>/etc/fstab</filename>
      さまざまなファイルシステムとマウントポイントの表であり、
      システムが参照します。
      <filename>/etc/fstab</filename> に書かれたファイルシステムは
      <option>noauto</option> オプションが指定されていなければ、
      起動時に &man.rc.8; スクリプトによって自動的にマウントされます。
      <filename>/etc/fstab</filename>
      ファイルの書式やオプションに関しての詳細は
      &man.fstab.5; をご覧ください。</para>

    <para>ファイルシステム構造を網羅した説明は &man.hier.7; に書かれています。
      ここでは、もっともよく使われるディレクトリについて簡単に
      見るだけで十分でしょう。</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>ディレクトリ</entry>
	      <entry>説明</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>ファイルシステムのルートディレクトリ</entry>
            </row>
	    
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>シングルユーザ環境とマルチユーザ環境の両方で重要な
	        ユーザユーティリティ</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>オペレーティングシステムの起動時に使われるプログラムと設定ファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>デフォルトの起動設定ファイル; &man.loader.conf.5; 参照</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>デバイスノード; &man.intro.4; 参照</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>システム設定ファイルとスクリプト</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>デフォルトのシステム設定ファイル; &man.rc.8; 参照</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>&man.sendmail.8; のようなメール転送エージェントの設定ファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry><command>named</command> 設定ファイル; &man.named.8; 参照</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>&man.cron.8; 経由で毎日・毎週・毎月実行されるスクリプト;
		&man.periodic.8; 参照</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry><command>ppp</command> 設定ファイル; 
	      &man.ppp.8; 参照</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>システム管理者が一時的なマウントポイントとしてよく使う
	        空のディレクトリ</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>プロセスファイルシステム; &man.procfs.5; と
	      &man.mount.procfs.8; 参照</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry><username>root</username> アカウントのホームディレクトリ</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>シングルユーザ環境とマルチユーザ環境の両方で重要な
	        システムプログラムと管理ユーティリティ</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>スタンドアロン環境で使われるプログラム</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>一時的なファイル、&man.mfs.8; メモリファイルシステムであることが多い
	        (普通 <filename class="directory">/tmp</filename>
		の内容はシステムの再起動で失われる)</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>大部分のユーザユーティリティとアプリケーション</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>よく使うユーティリティとプログラミングツールとアプリケーション</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>C の標準ヘッダファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>ライブラリ</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>いろいろなユーティリティのデータファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>システムデーモンとシステムユーティリティ
	        (他のプログラムから実行される)</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>ローカルのプログラムやライブラリなど。
	        FreeBSD ports 構成のデフォルトインストール先としても使われます。
	        <filename>/usr/local</filename> 内では、
	        &man.hier.7; に書かれている <filename>/usr</filename>
		のための一般構造が使われます。
	        例外は man ディレクトリで、
	        <filename>/usr/local/share</filename> の下ではなく
	        <filename>/usr/local</filename> の下に直接置かれ、
	        ports 関係文書は 
	        <filename>share/doc/<replaceable>port</replaceable></filename>
		にあります。
	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry><filename>/usr/src</filename> ツリーのビルドで作られる
	        アーキテクチャ依存のターゲットツリー</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>FreeBSD ports 集 (インストールしなくてもよい)。</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>(ユーザが実行する)システムデーモンとシステムユーティリティ</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>アーキテクチャに依存しないファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>BSD のソースファイルまたはローカルのソースファイル、
	        あるいは両方</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>X11R6 のプログラム、ライブラリなど(インストールしなくてもよい)</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>ログ・一時的なファイル・スプールファイルなどいろいろな用途</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>いろいろなシステムログファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>ユーザのメールボックスファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>プリンタとメールシステムのスプールディレクトリなどなど</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>システムが再起動しても消えない一時的なファイル</entry>
	    </row>
	    
	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>NIS のマップ</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="mount-unmount">
    <title>ファイルシステムのマウントとアンマウント</title>

    <para>ファイルシステムは <filename>/</filename>
      をルート (根) とする木構造として考えると視覚的に理解しやすいでしょう。
      ルートディレクトリにある
      <filename>/dev</filename> や <filename>/usr</filename>、
      その他のディレクトリは枝に相当し、
      それらには、<filename>/usr/local</filename>
      などのように、さらに枝分かれすることができます。</para>

    <indexterm><primary>ルートファイルシステム</primary></indexterm>
    <para>さまざまな理由がありますが、
      ディレクトリをいくつかの異なるファイルシステム上に構築するのが良いでしょう。
      たとえば <filename>/var</filename> には、
      <filename>log/</filename> や <filename>spool/</filename> 
      など、さまざまな種類の一時ファイルを置くディレクトリがあるため、
      あふれてしまう可能性があります。
      ルートファイルシステムをあふれさせるのは得策ではありませんので、
      普通は <filename>/var</filename> を <filename>/</filename>
      から分離します。</para>

    <para>また、次のような場合も、ディレクトリツリーを
      別のファイルシステムに置く理由として良くあげられます。
      それは、たとえば物理的に別のディスクにディレクトリツリーを置く場合、
      <link linkend="nfs">ネットワークファイルシステム (Network File System)</link> や
      CDROM ドライブのような別の仮想ディスクに置くという場合です。</para>

    <sect2 id="disks-fstab">
      <title><filename>fstab</filename> ファイル</title>
      <indexterm>
	<primary>ファイルシステム</primary>
	<secondary>fstab を使ったマウント</secondary>
      </indexterm>

      <para><filename>/etc/fstab</filename> に書かれているファイルシステムは
        (<option>noauto</option> オプションがなければ)
        <link linkend="boot">起動プロセス</link>の途中で
	自動的にマウントされます。</para>

      <para><filename>/etc/fstab</filename> ファイルは、
        次のような書式で書かれた行のリストになっています。</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>デバイスの名前 (存在していなければなりません)。
	      <xref linkend="disks-naming"> に説明があります。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>
            
	  <listitem>
	    <para>ファイルシステムがマウントするディレクトリの名前
	      (存在していなければなりません)。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>fstype</literal></term>
            
	  <listitem>
	    <para>&man.mount.8; に渡されるファイルシステムタイプ。
	      FreeBSD ファイルシステムのデフォルトは
	      <literal>ufs</literal> です。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>options</literal></term>
            
	  <listitem>
	    <para>読み書きするファイルシステムには
	      <option>rw</option>、読み込み専用のファイルシステムには
	      <option>ro</option> を、必要な他のオプションの前に指定します。
	      よく使われるオプションは <option>noauto</option> で、
	      起動時にはマウントされないファイルシステムに使います。
	      その他のオプションは &man.mount.8;
	      マニュアルページに載っています。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>dumpfreq</literal></term>
          
         <listitem>
	   <para>これは &man.dump.8; が使うもので、
	     どのファイルシステムにダンプが必要なのかを決めます。
             この項目がなければ、0 であるものとみなされます。</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>これはファイルシステムをチェックする順番を決めます。
           ファイルシステムチェックを飛ばしたいファイルシステムには、
           <literal>passno</literal> を 0 に設定してください。
	   ルートファイルシステム
	   (どれよりも先にチェックしなければなりません)
	   は <literal>passno</literal> を 1 に設定してください。
           他のファイルシステムの <literal>passno</literal>
           は 1 以上に設定してください。
	   同じ <literal>passno</literal> のファイルシステムがあった場合、
           &man.fsck.8; は可能であれば並行してファイルシステムのチェック
	   を行なおうとします。</para>
         </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title><command>mount</command> コマンド</title>
      <indexterm>
	<primary>ファイルシステム</primary>
	<secondary>マウント</secondary>
      </indexterm>
        
      <para>&man.mount.8; コマンドは、
        ファイルシステムをマウントするために使われるものです。</para>
        
      <para>基本的には、次のように使います。</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>&man.mount.8; マニュアルページにはたくさんのオプションが書かれていますが、
        いちばんよく使われるのは次のものです。</para>

      <variablelist>
	<title>マウントオプション</title>

	<varlistentry>
	  <term><option>-a</option></term>
            
	  <listitem>
	    <para><filename>/etc/fstab</filename>
	      にある全てのファイルシステムをマウントします。
	      例外は <quote>noauto</quote> の印がついているものと、
	      <option>-t</option> フラグで除外されたものと、
	      すでにマウントされているファイルシステムです。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-d</option></term>
            
	  <listitem>
	    <para>実際にシステムコールする以外の全てのことをします。
	      このオプションは <option>-v</option>
	      フラグと組み合わせて使い、
	      &man.mount.8; が実際なにをしようとしているのか調べるのに便利です。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>クリーンでないファイルシステムを強制的にマウントします
	      (危険です)。もしくは、ファイルシステムのマウント状態を
	      読み書き可能から読み込みのみに変更するとき、
	      書き込みアクセスを強制的に取り消します。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><option>-r</option></term>
            
	  <listitem>
	    <para>ファイルシステムを読み込み専用でマウントします。
	      これは <option>rdonly</option> 引数を <option>-o</option>
	      オプションに使うのと同じです。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>ファイルシステムを指定のファイルシステムタイプでマウントします。
	      または、<option>-a</option> を使った場合、
	      指定したタイプのファイルシステムのみマウントします。</para>
              
	    <para>デフォルトのファイルシステムタイプは
	      <quote>ufs</quote> です。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-u</option></term>
            
	  <listitem>
	    <para>ファイルシステムのマウントオプションを更新します。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-v</option></term>
            
	  <listitem>
	    <para>詳細な出力にします。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-w</option></term>
            
	  <listitem>
	    <para>ファイルシステムを読み書き可能にマウントします。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
        
      <para><option>-o</option> には、
         次のようなオプションを複数カンマで区切って指定します。
         以下に挙げるのはその一部です。</para>
        
      <variablelist>
	<varlistentry>
	  <term>nodev</term>
            
	  <listitem>
	    <para>ファイルシステム上のスペシャルデバイスを解釈しません。
	      セキュリティのために有用なオプションです。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>noexec</term>
            
	  <listitem>
              <para>そのファイルシステム上のバイナリの実行を禁止します。
	        セキュリティのために有用なオプションです。</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>nosuid</term>
            
	  <listitem>
	    <para>そのファイルシステム上の setuid や setgid フラグを解釈しません。
	      これもセキュリティのために有用なオプションです。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title><command>umount</command> コマンド</title>
      <indexterm>
	<primary>ファイルシステム</primary>
	<secondary>アンマウント</secondary>
      </indexterm>
        
      <para>&man.umount.8; コマンドは、パラメータとしてマウントポイントの一つ、
	デバイス名、もしくは <option>-a</option> や <option>-A</option>
	といったオプションを取ります。</para>

      <para>いずれの形式でも <option>-f</option> で強制的なアンマウントを行ない、
        <option>-v</option> で詳細な出力を出します。
        ただしほとんどの場合、<option>-f</option> は使わないほうがよいでしょう。
	強制的にファイルシステムをアンマウントすると、
	計算機がクラッシュしたりファイルシステム上部のデータが
	破壊されたりする恐れがあるためです。</para>
        
      <para>オプション <option>-a</option> と <option>-A</option>
        はマウントされているファイルシステムすべてをアンマウントするのに使います。
	<option>-t</option> にファイルシステムタイプを指定すると、
	指定されたものだけがアンマウントされます。
	また、<option>-A</option> を使うとルートファイルシステムはアンマウントしません。</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>プロセス</title>

    <para>FreeBSD はマルチタスクのオペレーティングシステムです。
      つまり、1つ以上のプログラムがあたかも同時に動いているかのように見える、
      ということです。動作中のプログラムはそれぞれ
      <firstterm>プロセス</firstterm> と呼ばれます。
      コマンドを実行すると、最低でも1つの新しいプロセスがスタートします。
      システムを正常に機能させるために常に動作しているシステムプロセスもたくさんあります。</para>

    <para>各プロセスは<firstterm>プロセス ID</firstterm>、もしくは
      <firstterm>PID</firstterm> と呼ばれる数字でただ一つに識別されます。
      また、ファイルのように各プロセスには所有者とグループがあります。
      所有者とグループの情報は、
      これまでに見たファイル許可属性を用い、
      そのプロセスが開けるファイルやデバイスを決定するために使われます。
      多くのプロセスには親プロセスもあります。
      親プロセスとは、そのプロセスをスタートさせたプロセスのことです。
      例えば、シェルにコマンドを打ち込んでいるときはシェルがプロセスで、
      動かすコマンドもまたどれもプロセスです。
      このようにして起動するプロセスはそれぞれシェルが親プロセスになります。
      これの例外は <command>init</command> という特別なプロセスです。
      <command>init</command> は常に最初のプロセスなので、
      PID は必ず 1 になります。
      <command>init</command> は FreeBSD
      がスタートするときカーネルによって自動的に起動されます。</para>

    <para>&man.ps.1; と &man.top.1; という2つのコマンドが
      システム上のプロセスを確認するために特に便利です。
      &man.ps.1; コマンドは現在動作中のプロセスのリストを見るために使い、
      PID やプロセスが使っているメモリの量、
      どういうコマンドラインで起動されたのか、
      などを表示させることができます。
      &man.top.1; コマンドは動作中の全てのプロセスを表示し、
      数秒ごとに表示を更新するので、
      計算機がなにをしているのかインタラクティブに知ることができます。</para>

    <para>デフォルトでは、&man.ps.1; は動作中かつ所有者が自分のコマンドのみを表示します。
      例えば:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>この例で分かるとおり、
      &man.ps.1; の出力はいくつかの行に整形されています。
      <literal>PID</literal> は先ほど見たプロセス ID です。
      PID は 1 から順に 99999 まで割り当てられ、
      足りなくなると最初に戻って使い回されます。
      <literal>TT</literal> はプログラムが動いている tty を示します。
      差し当たって無視してもかまわないでしょう。
      <literal>STAT</literal> はプログラムの状態を示しますが、
      これもまた無視してよいでしょう。
      <literal>TIME</literal> はプログラムがその CPU
      上で動いている時間の長さです&mdash;これはプログラムをスタートさせたとき
      からの経過時間であるとはかぎりません。
      CPU 上で時間を使う必要があるまでかなりの時間を費すようなプログラムもあるからです。
      最後に、<literal>COMMAND</literal>
      はそのプログラムを起動するのに使われたコマンドラインとなります。</para>

    <para>&man.ps.1; は表示する情報を変えるためのオプションをたくさんサポートしています。
      いちばん便利なのは <literal>auxww</literal> でしょう。
      <option>a</option> は自分のプロセスだけではなく、
      動作中のプロセス全部についての情報を表示します。
      <option>u</option> はプロセスの所有者の名前をメモリ使用量と同様に表示します。
      <option>x</option> はデーモンプロセスについての情報を表示し、
      <option>ww</option> で、スクリーンに入りきらないほど長くなったコマンドラインでも省略せず、
      &man.ps.1; に全コマンドラインを表示させます。</para>

    <para>&man.top.1; の出力も同様です。 例は以下の通りです。</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>出力は2つのセクションに分かれています。
      ヘッダ(最初の5行です)は動作している最新のプロセスの PID、
      システムの平均負荷(システムがどれくらい忙しいかの指標)、
      システムの稼働時間(最後の再起動からの時間)
      と現在の時刻を示します。
      ヘッダの中の他の数字は動作中のプロセスの数(この場合 47 ですね)、
      使われているメモリとスワップ領域の量、
      そしてシステムが異なる CPU 状態に消費した時間と関係します。</para>

    <para>その下には &man.ps.1; の出力と同じような情報を持った行が続きます。
      前と同様 PID にユーザ名、消費 CPU 時間と実行中のコマンドを知ることができます。
      &man.top.1; を使うとデフォルトでプロセスが使っているメモリ容量も分かります。
      メモリ使用量の欄は2項目に分かれており、
      一方は合計使用量、
      そしてもう一方は実使用量です&mdash;合計使用量はアプリケーションが必要としているメモリ量で、
      実使用量はその時点で実際に使われているメモリ量です。
      この例では、<application>Netscape</application> がだいたい 30MB の RAM を必要としていますが、
      いまのところ 9MB しか使っていないことが分かります。</para>

    <para>&man.top.1; は自動的に2秒ごとに画面を更新します。
      <option>s</option> オプションを使えば更新間隔を変更することができます。</para>
  </sect1>

  <sect1>
    <title>デーモン、シグナルとプロセス終了</title>

    <para>エディタを使っている場合、エディタを操作するのは簡単です。
      ファイルを開く、などと動かせばよいのです。
      このように操作できるのは、エディタにそういった機能があり、
      かつエディタが<firstterm>端末</firstterm>に関連づけられているからです。
      一方、ユーザから始終入力があるように設計されていないプログラムもあり、
      そういったプログラムは最初から端末と切り離されます。
      例えば、ウェブサーバは一日中ウェブのリクエストばかり処理するので、
      通常全く入力を必要としません。
      サイトからサイトへとメールを転送するプログラムも、
      こういった種類のアプリケーションの一例です。</para>

    <para>このようなプログラムは、<firstterm>デーモン</firstterm>と呼ばれます。
      デーモンはギリシャ神話の登場人物で、
      善でも悪でもなく、大雑把にいうと、
      人間のために役立つことをしてくれる小さな妖精さんです。
      今日の便利なウェブサーバやメールサーバととてもよく似ていますね。
      このため、長い間 BSD のマスコットはスニーカーをはいてフォークを携えた
      かわいらしい姿のデーモンなのです。</para>

    <para>通常デーモンとして動作するプログラムには末尾に <quote>d</quote>
      を持った名前をつける慣習があります。
      <application>BIND</application> は Berkeley Internet Name Daemon ですし
      (実際実行されるプログラムは <command>named</command> という名前です)、
      <application>Apache</application> ウェブサーバのプログラムは
      <command>httpd</command> と呼ばれますし、
      ラインプリンタスプーリングデーモンは <command>lpd</command>、
      などなどです。
      これは単なる慣習で、しっかりがっちりとしたルールではありません。
      例えば、<application>Sendmail</application>
      アプリケーションの主なメールデーモンは
      <command>sendmail</command> という名前で、
      連想しそうな <command>maild</command> ではありません。</para>

    <para>時々、デーモンプロセスと通信したいときがあります。
      この通信は<firstterm>シグナル</firstterm>と呼ばれ、
      デーモンにシグナルを送ることによってデーモン
      (に限らずどんな動作中のプロセスでも)と通信することができます。
      送信可能なシグナルはたくさんあります&mdash;特別な意味があるものもあれば、
      アプリケーションによって解釈されるものもありますし、
      アプリケーションがシグナルをどう解釈するかは
      そのアプリケーションの文章を読めば分かるでしょう。
      自分が持っているプロセスにしかシグナルを送ることはできません。
      他人のプロセスに &man.kill.1; や &man.kill.2;
      を使ってシグナルを送っても、許可されないでしょう。
      これの例外は <username>root</username> ユーザで、
      ルートユーザは誰のプロセスでもシグナルを送ることができます。</para>

    <para>FreeBSD もアプリケーションにシグナルを送ることがあります。
      アプリケーションを下手に書くと、
      予想外のメモリにアクセスしようとするので、
      FreeBSD がプロセスに <firstterm>セグメンテーション違反</firstterm>
      シグナル (<literal>SIGSEGV</literal>) を送ります。
      ある程度の時間が経ったら &man.alarm.3;
      システムコールを使って警告してもらうようなアプリケーションには、
      警告シグナル (<literal>SIGALRM</literal>) が送信される、
      などです。</para>

    <para>プロセスを止めるためには2つのシグナル、
      <literal>SIGTERM</literal> か <literal>SIGKILL</literal>
      を使います。
      <literal>SIGTERM</literal> は穏かにプロセスを終了させる方法です。
      プロセスはシグナルを<emphasis>受け取る</emphasis>ことができ、
      終了させたいのだなということを理解し、
      開いているログファイルを全部を閉じ、
      一般的に終了前にしていたことを終えることができます。
      中断できない処理の途中だと、<literal>SIGTERM</literal>
      をプロセスが無視することもあるかもしれません。</para>

    <para>プロセスは <literal>SIGKILL</literal> を無視することができません。
      これは、<quote>なにをしていようが構わないから今すぐ止まれ</quote>
      というシグナルです。 プロセスに <literal>SIGKILL</literal> を送ると、
      FreeBSD はそのプロセスをそこで止めます<footnote>
	<para>正確ではありません&mdash;中断できないものはわずかながら存在します。
	  例えば、プロセスがネットワーク上の別の計算機にあるファイルを読もうとして、
	  その計算機がなんらかの理由
	  (電源を落とされたとか、ネットワークに問題があるとか)
	  でいなくなった場合、そのプロセスは<quote>中断不可能</quote>と言われます。
	  最終的にはそのプロセスはタイムアウトします。普通は2分後です。
	  タイムアウトした直後、そのプロセスは終了します。</para>
      </footnote>。</para>

    <para>使う可能性のあるシグナルは、他に
      <literal>SIGHUP</literal>、<literal>SIGUSR1</literal>、と
      <literal>SIGUSR2</literal> があります。
      これらは一般的な用途のシグナルで、
      このシグナルが送信されたときアプリケーションによって別のことをします。</para>

    <para>ウェブサーバの設定ファイルを変更したとしましょう&mdash;ウェブサーバに新しい設定を再読み込みさせたいですね。
      <command>httpd</command> を止めて再起動することもできますが、
      そうするとウェブサーバは一瞬ながら停止してしまいますし、
      ちょっとでも止まってほしくないこともあるでしょう。
      ほとんどのデーモンは <literal>SIGHUP</literal>
      シグナルに対して設定ファイルを再読み込みする反応を返すよう書かれています。
      従って、<command>httpd</command> を止めて再起動する代わりに、
      <literal>SIGHUP</literal> シグナルを送りましょう。
      これらのシグナルへの標準的な反応というものがないために、
      デーモンごとに行動が違うので、
      疑問があれば必ずそのデーモンの文書を読んでください。</para>
    
    <para>&man.kill.1; コマンドを使って送るシグナルはこの例をご覧ください。</para>

    <procedure>
      <title>プロセスにシグナルを送る</title>

      <para>この例では、&man.inetd.8; にシグナルを送る方法を示します。
	&man.inetd.8; の設定ファイルは
	<filename>/etc/inetd.conf</filename> で、
	&man.inetd.8; は <literal>SIGHUP</literal>
	が送信されるとこの設定ファイルを再読み込みします。</para>

      <step>
	<para>シグナルを送りたいプロセスのプロセス ID を探します。
	  それには &man.ps.1; と &man.grep.1; を使います。
	  &man.grep.1; コマンドは出力を検索するために使い、
	  指定した文字列を探します。
	  このコマンドは一般ユーザで実行しますが、
	  &man.inetd.8; は <username>root</username> で実行されているので、
	  &man.ps.1; には <option>ax</option>
	  オプションを与える必要があります。</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>ということで、&man.inetd.8; の PID は 198 です。
	  <literal>grep inetd</literal> コマンドがこの出力に出てくる場合もあります。
	  それは、&man.ps.1; が動作中のプロセスのリストを見つける方法によります。</para>
      </step>

      <step>
	<para>&man.kill.1; を使ってシグナルを送ります。
	  &man.inetd.8; は <username>root</username> で起動されているために、
	  まず &man.su.1; を使って <username>root</username>
	  にならなければなりません。</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>大部分の Unix コマンドと同じく、
	  成功したら &man.kill.1; は何の出力も表示しません。
	  自分のものではないプロセスにシグナルを送ると、
	  <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname> と表示されます。
	  PID を打ち間違えると、
	  悪いことに間違ったプロセスにシグナルを送ってしまうか、
	  もしくは運がよければその時点で使われていない PID
	  にシグナルを送ったことになり、<errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>
	  と表示されます。</para>

	<note>
	  <title>なぜ <command>/bin/kill</command> を使うんでしょう?</title>

	  <para>多くのシェルは <command>kill</command>
	    コマンドを組み込みコマンドとして備えています。
	    つまり、<filename>/bin/kill</filename> を実行するのではなく、
	    シェルが直接シグナルを送ります。
	    これはとても便利なのですが、
	    シェルが違うと送るシグナルの名前の指定の仕方が違います。
	    シェルによって異なるシグナルの指定の仕方を全部覚えようとはせずに、
	    <command>/bin/kill <replaceable>...</replaceable></command>
	    コマンドを直接使うほうが簡単です。</para>
	</note>
      </step>
    </procedure>

    <para>他のシグナルの送り方はほとんど同じで、
      コマンドラインの <literal>TERM</literal> や <literal>KILL</literal>
      を必要に応じて変えるだけです。</para>

    <important>
      <para>システム上のランダムプロセスを終了させるのはよくありません。
        特に、プロセス ID が 1 の &man.init.8; は特別です。
	Running
	<command>/bin/kill -s KILL 1</command>
	を使うといとも簡単にシステムをシャットダウンさせることができます。
	<keycap>Return</keycap> を押す<emphasis>前</emphasis>に
	&man.kill.1; を実行する引数を二重にチェックする<emphasis>癖</emphasis>をつけてください。</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>シェル</title>
    <indexterm><primary>シェル(shell)</primary></indexterm>
    <indexterm><primary>コマンドライン</primary></indexterm>

    <para>FreeBSD では日々の作業のほとんどは、
      「シェル」と呼ばれるコマンドラインインタフェイスを通して行われます。
      シェルの主な仕事はコマンドを入力チャンネルから受け取り、
      そしてそれらを実行することです。
      大部分のシェルはさらに組み込みの機能を持っていて、日々の作業、
      ファイル管理やファイル名の展開、コマンドライン編集、
      コマンドマクロ、環境変数などに便利です。
      FreeBSD には <command>sh</command> (Bourne Shell) や
      <command>tcsh</command> (高機能 C-shell) が含まれています。
      また、
      これ以外にも <command>zsh</command> や <command>bash</command>
      などたくさんのシェルが FreeBSD Ports Collection から利用可能です。</para>

    <para>「あなたは、どのシェルを使いますか?」という質問は、
      まったく趣味の問題です。
      あなたが C のプログラマだったとすれば、
      <command>tcsh</command> のような C 風のシェルの方が落ち着くかもしれません。
      Linux から来た人や Unix のコマンドラインインタフェイスになじみがなければ、
      <command>bash</command> を試すのも良いでしょう。
      ポイントは、それぞれのシェルは、
      あなたの好みの作業環境で利用できる(もしくはできない)独自の機能を持っているということ、
      そして、どのシェルを使うことにするかを決めるのはあなた自身だということです。</para>

    <para>シェルの一般的な機能の一つに、ファイル名の補完があります。
      コマンドやファイル名の最初の数文字を与えて <keycap>Tab</keycap> キーを押すことで、
      シェルにコマンドやファイル名の残りの部分を自動的に補完させることができます。
      例をあげましょう。 二つのファイル
      <filename>foobar</filename>, <filename>foo.bar</filename> が
      あったとします。 ここで <filename>foo.bar</filename>
      の方を削除するには、
      <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command> と入力します。</para>
    <indexterm><primary>環境変数(environment variables)</primary></indexterm>

    <para>するとシェルは <command>rm
      foo[BEEP].bar</command> と出力するでしょう。</para>

    <para>[BEEP] のところはコンソールのベル(訳注: 通常はビープ音が鳴ります)です。
      これは複数のファイルがマッチしたため、
      ファイル名の補完を完全に行なえなかったことを伝えています。
      <filename>foobar</filename> と
      <filename>foo.bar</filename> は
      両方とも <literal>fo</literal> ではじまるため、
      補完できるのは <literal>foo</literal> までです。
      ここで <literal>.</literal> を入力して <keycap>Tab</keycap> を押せば、
      シェルはファイル名の残りの部分を補完できます。</para>

    <para>もう一つあげられるシェルの特徴として、環境変数があります。
      環境変数とは、シェルの環境変数空間におけるキーと値とのペアです。
      この変数空間は、そのシェルから起動されたプログラムから参照でき、
      それを利用してプログラムの設定を保存するのに利用されます。
     下の表は、一般的な環境変数とその意味を示したものです。</para>

    <indexterm><primary>環境変数(environment variables)</primary></indexterm>
    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>変数名</entry>
	    <entry>意味</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>現在のログインユーザのユーザ名。</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>コロンで区切られた実行ファイル探索のための
	      ディレクトリのリスト。</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>接続する X11 ディスプレイのネットワーク名(存在する場合のみ)。</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>現在のシェル。</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>ユーザの端末名。
              端末のケーパビリティを決定するのに使われる。</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>種々の端末の機能を実現する端末のエスケープコードの
	      データベースのエントリ。</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>オペレーティングシステムの種別。
              たとえば FreeBSD。</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>システムが動作している CPU のアーキテクチャ。</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>ユーザの選んだテキストエディタ。</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>ユーザの選んだテキストページャ。</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>コロンで区切られたマニュアルページ探索のための
	      ディレクトリのリスト。</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne シェル(Bourne shells)</primary></indexterm>

    <para>環境変数をセットする方法は、
      それぞれのシェルごとに多少異なります。
      たとえば、<command>tcsh</command> や <command>csh</command> 等の C シェルでは
      <command>setenv</command> を使います。
      <command>sh</command> や <command>bash</command> 等の Bourne シェルでは
      <command>set</command> と <command>export</command>
      を使います。
      たとえば <command>csh</command> か <command>tcsh</command> で
      <envar>EDITOR</envar> 環境変数の値を
      <filename>/usr/local/bin/emacs</filename> に
      セットするか変更するには、次のようにします。</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Bourne シェルでは次のようになります。</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>ほとんどのシェルでは、
      コマンドライン中の変数名の前に <literal>$</literal> 文字を置くことで、
      環境変数を展開させることができます。
      たとえば、
      <command>echo $TERM</command> は <envar>$TERM</envar> が
      セットされている内容を表示します。
      それはシェルが <envar>$TERM</envar> を展開して
      <command>echo</command> に渡しているからです。</para>

    <para>シェルはさまざまな特殊文字を、特別なデータを表すものとして扱います。
      その特殊文字はメタキャラクタと呼ばれます。
      もっとも一般的なものは <literal>*</literal> で、
      これはファイル名に含まれる、あらゆる文字を表します。
      これらの特殊なメタキャラクタはファイル名の展開に使われます。
      たとえば、<command>echo *</command> と入力すると
      <command>ls</command> と入力したのとほとんど同じ結果を得られます。
      これはシェルが <literal>*</literal> とマッチするすべてのファイルを
      受け取って <command>echo</command> のコマンドラインに渡し、表示するからです。</para>

    <para>これらの特殊文字をシェルに解釈させないようにするため、
      特殊文字の前にバックスラッシュ文字 (<literal>\</literal>)
      を置くことができます。
      <command>echo $TERM</command> は、
      あなたの端末が何にセットされているかを表示します。
      <command>echo \$TERM</command> は <envar>$TERM</envar> と
      そのまま表示します。</para>

    <sect2 id="changing-shells">
      <title>シェルの変更</title>

      <para>シェルを変更する一番簡単な方法は <command>chsh</command>
	コマンドを使うことです。 <command>chsh</command> を実行すると
	環境変数 <envar>EDITOR</envar> で示されたエディタが立ち上がります。
	環境変数をセットしていなかった時は
        <command>vi</command> が立ち上がります。
	<quote>Shell:</quote> の行を適宜変更してください。</para>

      <para><command>chsh</command> に
        <option>-s</option> オプションをつけると、
        エディタを起動せずにシェルを変更することが可能です。
        たとえば、シェルを <command>bash</command> に変えたいなら、次のようにしてください。
      </para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para><command>chsh</command> をパラメータなしで実行し、
        エディタでシェルを変更しても同じことができます。</para>

      <note>
	<para>使おうと思っているシェルは<emphasis>必ず</emphasis>
	  <filename>/etc/shells</filename> 中に書かれているものでなければなりません。
	  シェルを <link linkend="ports">Ports コレクション</link>から
	  インストールしていたのであれば、すでにそれは行なわれていますが、
	  手動でインストールした場合は、それを忘れずに行ってください。</para>
     
        <para>たとえば、<command>bash</command>
          を手動で
          <filename>/usr/local/bin</filename>
          にインストールした場合
          以下のようにする必要があります。</para>

        <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

        <para>そして <command>chsh</command> を実行してください。</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="editors">
    <title>テキストエディタ</title>

    <indexterm><primary>テキストエディタ</primary></indexterm>
    <indexterm><primary>エディタ</primary></indexterm>

    <para>さまざまな FreeBSD の設定は、テキストファイルを編集することで行われます。
      そのため、テキストエディタの扱いに慣れると良いでしょう。
      FreeBSD には、基本システムの一部として二、三提供されるものと、
      Ports collection から利用できる、たくさんのテキストエディタが用意されています。
    </para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>最も学習が簡単なエディタは、
      easy editor の略で <application>ee</application> と呼ばれるものです。
      <application>ee</application> を立ち上げるには、コマンドラインから
      <command>ee filename</command> と入力します。
      ここで <literal>filename</literal> は、
      編集しようとしているファイルの名前です。
      たとえば、<filename>/etc/rc.conf</filename> を編集するには
      <command>ee /etc/rc.conf</command> と入力します。
      一旦 <command>ee</command> の中に入れば、
      エディタの機能を操作するコマンドはすべてディスプレイの上部に
      表示されています。キャレット <literal>^</literal> 文字は
      キーボードの <keycap>Ctrl</keycap> キーを意味しますので、
      <literal>^e</literal> はキーのコンビネーション
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      を押すという意味になります。
      <application>ee</application> を終了するには <keycap>Esc</keycap> キーを押し、
      そして leave editor を選びます。
      ファイルが更新されていたときは、
      エディタは変更をセーブするかどうかプロンプトを出します。</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>エディタ</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
     <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>エディタ</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD には、基本システムの一部として
      <application>vi</application>、
      一方 <command>emacs</command> や <command>vim</command>
      といった他のエディタは Ports Collection の一部として、
      より強力なテキストエディタが用意されています。
      これらのエディタはやや学習が複雑ですが、より強力で高い機能性を提供します。
      しかし、あなたが多量のテキストを編集することを考えているなら、
      <command>vim</command> や <command>emacs</command>
      といった強力なエディタを習得することは、
      より多くの時間を節約することでしょう。</para>
  </sect1>

  <sect1>
    <title>デバイスとデバイスノード</title>

    <para>デバイスとはシステム上のハードウェアに関するものに対してよく使われる用語で、
      ディスクやプリンタ、グラフィックカードやキーボードが含まれます。
      FreeBSD が起動するとき、FreeBSD
      が表示しているものの大部分は検出されたデバイスです。
      <filename>/var/run/dmesg.boot</filename>
      を眺めれば起動メッセージを読み直すことができます。</para>

    <para>例えば、<devicename>acd0</devicename> は最初の
      IDE CDROM ドライブで、<devicename>kbd0</devicename>
      はキーボードを表します。</para>

    <para>Unix オペレーティングシステムにおけるデバイスのほとんどは、
      デバイスノードと呼ばれる <filename>/dev</filename>
      ディレクトリにあるスペシャルファイルを通してアクセスしなければなりません。</para>

    <sect2>
      <title>デバイスノードを作成する</title>
      <para>新しいデバイスをシステムにつけ足したり、
        追加デバイスのサポートをコンパイルして加えたりするときは、
	デバイスノードを追加で作成しなければならない場合があります。</para>

      <sect3>
	<title>MAKEDEV スクリプト</title>
	<para><literal>DEVFS</literal> がないシステムでは、
	  以下に示すように &man.MAKEDEV.8;
	  スクリプトを使ってデバイスノードを作成します。</para>

	<screen>&prompt.root; cd /dev
&prompt.root; sh MAKEDEV ad1
	</screen>

	<para>この例では、取りつけられたとき2番目に当たる IDE
	  ドライブにとって適切なデバイスノードを作ります。</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (デバイスファイルシステム: Device File System)</title>

	<para>デバイスファイルシステム <literal>DEVFS</literal> は、
	  グローバルファイルシステム名前空間の中のカーネルデバイス名前空間へのアクセスを提供します。
	  デバイスノードを作成したり変更したりするのではなく、
	  <literal>DEVFS</literal> がこの特別なファイルシステムを管理するのです。</para>

	<para>詳しくは &man.devfs.5; マニュアルページをご覧ください。</para>

	<para>FreeBSD 5.0 では <literal>DEVFS</literal> がデフォルトで使われています。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>さらに詳しい情報を得るには...</title>

    <sect2 id="basics-man">
      <title>オンラインマニュアル</title>

      <indexterm><primary>マニュアルページ</primary></indexterm>
      
      <para>FreeBSD についてのもっとも包括的な文書は、
        マニュアルページの形式になっているものです。
        FreeBSD システム上のほとんどすべてのプログラムには、
        基本的な操作方法とさまざまな引数を説明しているリファレンスマニュアルが添付されています。
        これらのマニュアルは <command>man</command> コマンドで見ることができます。<command>man</command>
        コマンドの使い方は簡単です。</para>
      
      <screen>&prompt.user; <userinput>man <replaceable>コマンド名</replaceable></userinput></screen>
      
      <para><literal>コマンド名</literal>
        のところには、知りたいコマンドの名前を入れます。
        たとえば <command>ls</command> コマンドについて知りたい場合には、
        次のように入力します。</para>
      
      <screen>&prompt.user; <userinput>man ls</userinput></screen>
      
      <para>オンラインマニュアルは、
        セクション番号で分類されています。</para>
      
      <orderedlist>
        <listitem>
          <para>ユーザコマンド</para>
        </listitem>
        
        <listitem>
          <para>システムコールとエラー番号</para>
        </listitem>
        
        <listitem>
          <para>C のライブラリ関数</para>
        </listitem>
        
        <listitem>
          <para>デバイスドライバ</para>
        </listitem>

        <listitem>
          <para>ファイル形式</para>
        </listitem>
        
        <listitem>
          <para>ゲームや娯楽</para>
        </listitem>
        
        <listitem>
          <para>さまざまな情報</para>
        </listitem>
        
        <listitem>
          <para>システムの管理と操作のためのコマンド</para>
        </listitem>
        
        <listitem>
          <para>カーネル開発者のための情報</para>
        </listitem>
      </orderedlist>
      
      <para>時折、
        同じトピックがオンラインマニュアルの複数のセクションに記載されている場合があります。
        たとえば、<command>chmod</command> ユーザコマンドと
        <function>chmod()</function>
        システムコールの場合がそれに該当します。
        この場合、<command>man</command> コマンドにセクション番号を与えることで、
        どちらを参照したいかを指定することができます。</para>
      
      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>
      
      <para>上のようにすれば、
        ユーザコマンド <command>chmod</command>
        のマニュアルページが表示されます。
        オンラインマニュアルの特定セクションへの参照は、
        慣習的に書かれている文書で括弧の中に示されます。
        すなわち、&man.chmod.1; は <command>chmod</command>
        ユーザコマンドを、&man.chmod.2;
        はシステムコールの方を示しています。</para>
      
      <para>コマンドの名前を知っていて、
        単純にその使い方を知りたい場合はここまでの説明で十分でしょう。
        しかし、
        もしコマンドの名前を思い出せない場合にはどうしたら良いのでしょうか?
        <command>man</command> に <option>-k</option> スイッチをつければ、
        コマンド解説(description)の文章から、
        指定したキーワードを検索することができます。</para>
      
      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>
      
      <para>このコマンドにより、
        <quote>mail</quote>
        というキーワードをコマンド解説に含むコマンドの一覧が表示されます。
        実際には、これは <command>apropos</command> コマンドを使う場合と同等の機能です。</para>
      
      <para>それでは、<filename>/usr/bin</filename>
        にあるさまざまなコマンドすべてを見ていて、
        それらが実際にどう働くのかが、まったく見当もつかないときには
        どうしたら良いでしょう?
        そのときは単純に、</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>とするか、あるいは同じ働きをする</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

      <para>としてください。</para>
    </sect2>
    
    <sect2 id="basics-info">
      <title>GNU の Info ファイル</title>

      <indexterm><primary>Free Software Foundation</primary></indexterm>
      
      <para>FreeBSD には Free Software Foundation (FSF)
        によるアプリケーションや
        ユーティリティがたくさん含まれています。
        これらのプログラムには、マニュアルページに加えて
        <literal>info</literal> ファイルと呼ばれる
        ハイパーテキスト形式の文書が付属しています。
        この文書は <command>info</command> コマンド、
        あるいは <application>emacs</application> をインストールしているなら
        <application>emacs</application> の info
        モードで読むことができます。</para>
      
      <para>&man.info.1; コマンドを使うには、単に次のように入力します。</para>
      
      <screen>&prompt.user; <userinput>info</userinput></screen>
      
      <para>
        <literal>h</literal> と入力すると、
        簡単な手引きを読むことができます。
        クイックコマンドリファレンスは <literal>?</literal>
        を入力してください。</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
