<?xml version="1.0" encoding="euc-jp"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r31156
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <info><title>UNIX の基礎知識</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>改訂</contrib></author>
    </authorgroup>
    
  </info>

  

  <para><emphasis>訳: &a.jp.nakai;, 1996 年 10 月 12 日.</emphasis></para>

  <sect1 xml:id="basics-synopsis">
    <title>この章では</title>

    <para>この章では FreeBSD
      オペレーティングシステムの基本的なコマンドと機能について記述しています。
      ここに書かれてあることのほとんどは、
      どんな &unix; オペレーティングシステムにもあてはまります。
      この章に書いてあることに馴染みがあるなら、
      この章は気軽に流し読みしてください。
      あなたが FreeBSD の初心者なら、
      何か質問する前にこの章を読んでおいた方がきっといいはずです。</para>

    <para>この章を読んで分かることは、次のようなことです。</para>

    <itemizedlist>
      <listitem>
        <para>FreeBSD の <quote>仮想コンソール</quote> の使い方</para>
      </listitem>
      <listitem>
	<para>&unix; のファイルの許可属性の仕組みと
	  &os; のファイルフラグについて</para>
      </listitem>
      <listitem>
	<para>&os; のファイルシステムの構成</para>
      </listitem>
      <listitem>
	<para>&os; のディスク構成</para>
      </listitem>
      <listitem>
	<para>ファイルシステムをマウント、アンマウントする方法</para>
      </listitem>
      <listitem>
	<para>プロセス、デーモンとシグナルとはなにか</para>
      </listitem>
      <listitem>
	<para>シェルとはなにか。 また、デフォルトのログイン環境を変える方法</para>
      </listitem>
      <listitem>
	<para>テキストエディタの基本的な使い方</para>
      </listitem>
      <listitem>
	<para>デバイスおよびデバイスノードとはなにか</para>
      </listitem>
<!--      <listitem>
	<para>What binary format is used under &os;.</para>
      </listitem> -->
      <listitem>
	<para>さらに詳しい情報を得るためのマニュアルページの読み方</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 xml:id="consoles">
    <title>仮想コンソールと端末</title>
    <indexterm><primary>仮想コンソール</primary></indexterm>
    <indexterm><primary>端末</primary></indexterm>

    <para>FreeBSD は様々な使い方ができます。その中の一つが、
      テキスト端末でコマンドを入力することです。この方法で FreeBSD を使えば、
      &unix; オペレーティングシステムの能力と柔軟性を手にすることができます。
      この節では、<quote>コンソール</quote> と
      <quote>端末</quote> はどのようなもので、FreeBSD でどう使うかを
      説明します。</para>

    <sect2 xml:id="consoles-intro">
      <title>コンソール</title>
      <indexterm><primary>コンソール</primary></indexterm>

      <para>起動時に自動的にグラフィカルな環境が起動するように FreeBSD
	を設定していなければ、システムが起動してスタートアップ
	スクリプトが実行されると、すぐにログインプロンプトが出てくるでしょう。
	次のようものが表示されるはずです。</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>あなたのシステムではメッセージが多少異なるかもしれませんが、
	似たようなものが見られるはずです。
	最後の 2 行が、今関心を向けているものです。
	最後から 2 行目は、以下のようになっています。</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>この行には、
	起動したばかりのシステムについていくばくかの情報があります。
	あなたは、x86 アーキテクチャ上の Intel または
	その互換プロセッサ上で動作している <quote>FreeBSD</quote> の
	コンソールを目にしているのです<footnote>
	  <para><literal>i386</literal> が意味しているのはそういうことです。
	    FreeBSD を Intel の 386 CPU 上で動かしていなくても、
	    ここは <literal>i386</literal> になります。
	    ここで表示されるのはプロセッサの種類ではなく、プロセッサの
	    <quote>アーキテクチャ</quote>です。</para>
	</footnote>。このマシンの名称 (どの &unix; 機にも名前がついて
	  います) は <systemitem>pc3.example.org</systemitem> で、
	  あなたはそのシステムコンソール、<filename>ttyv0</filename>
	  端末に向かっています。</para>

      <para>最後の行は、常に以下のものになります。</para>

      <programlisting>login:</programlisting>

      <para>ここは、FreeBSD にログインするために <quote>ユーザ名</quote>
	を入力するところです。次の節でどうするか説明します。</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>FreeBSD にログインする</title>

      <para>FreeBSD は、マルチユーザ、マルチプロセスなシステムです。
	これは、1 台のマシンで何人もの人が交互に多くのプログラムを
	動かせるシステムに与えられる正式な説明です。</para>

      <para>あらゆるマルチユーザシステムには、ある <quote>ユーザ</quote>
	を他のユーザと区別する何がしかの手段が必要です。
	FreeBSD (とすべての &unix; like なオペレーティングシステム) では、
	すべてのユーザに対してプログラムの実行を可能にするのに、システムに
	<quote>ログイン</quote> することを義務付けてこれを実現しています。
	どのユーザにも、一意な名前 (<quote>ユーザ名</quote>)
	と個人的な秘密の鍵 (<quote>パスワード</quote>) があります。
	FreeBSD はユーザにプログラムの実行を許可する前に、
	この 2 つの入力を要求します。</para>

      <indexterm><primary>スタートアップスクリプト</primary></indexterm>
      <para>FreeBSD が起動してスタートアップスクリプトを実行し終わった
	直後に<footnote>
	  <para>スタートアップスクリプトは、
	    起動時に FreeBSD が自動的に実行するプログラムです。
	    主な機能は、全プログラムが動作するように設定を行なうことと、
	    バックグラウンドで動作するように設定した
	    有用なサービスを開始することです。</para>
	</footnote>、プロンプトを表示して有効なユーザ名の入力を促します。</para>

      <screen>login:</screen>

      <para>この例では <systemitem class="username">john</systemitem> というユーザ名を使う
	ことにしましょう。このプロンプトに対して
	<literal>john</literal> と入力して、<keycap>Enter</keycap> を
	押してください。そうすると、
	次のような<quote>パスワード</quote>の入力を要求するプロンプトが
	表示されます。</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>それでは <systemitem class="username">john</systemitem> のパスワードを入力して
	<keycap>Enter</keycap> を押してください。パスワードは
	<emphasis>表示されません</emphasis>。これについては、当面は
	気にする必要はありません。セキュリティのためといえば十分でしょう。</para>

      <para>パスワードを正確に入力したら、FreeBSD にログインして
	利用可能なすべてのコマンドを試せるようになっているはずです。</para>

      <para><acronym>MOTD</acronym>、もしくはコマンドプロンプト
	(<literal>#</literal>, <literal>$</literal>
	または <literal>%</literal>)
	に表示されるメッセージを読むようにしましょう。
        これは FreeBSD へのログインに成功したときに表示されます。</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>多数のコンソール</title>

      <para>一つのコンソールで &unix; コマンドを動かすのは結構なことですが、
	FreeBSD は多くのプログラムを一度に動かせます。
	コマンドを入力できるコンソールが一つというのは、
	FreeBSD のようにいくつものプログラムを同時に動かせる
	オペレーティングシステムの場合は少しもったいないことです。
	ここで、<quote>仮想コンソール</quote> が非常に役に立ちます。</para>

      <para>FreeBSD は、異なる仮想コンソールを複数
	表示するように設定できます。キーボード上である組合せのキーを押せば、
	その中の一つから他の仮想コンソールのどれかに切り替えられます。
	それぞれのコンソールは、個別の出力チャンネルを持っており、
	また FreeBSD はある仮想コンソールから次に切り替えるのに応じて、
	キーボード入力とモニター出力を適切につなぎ直します。</para>

      <para>FreeBSD は、コンソールを切り替えるために、
	特別なキーの組合せを予約しています<footnote>
	  <para>FreeBSD のコンソールとキーボードドライバの詳細全体に
	    ついて、それなりに技術的かつ正確な説明は &man.syscons.4;,
	    &man.atkbd.4;, &man.vidcontrol.1; および
	    &man.kbdcontrol.1; のマニュアルにあります。
	    ここではその詳細には立ち入りませんが、
	    興味をもった方は、いつでもマニュアルを参照して、
	    動作に関する詳細な説明を読むことができます。</para>

	</footnote>。FreeBSD では
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> から
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> までを、
	別の仮想コンソールに切り替えるのに使えます。</para>

      <para>あるコンソールから他に切り替えるのに応じて、FreeBSD は画面
	への出力を保存して戻します。結果として、FreeBSD で動かすコマン
	ドを入力するのに使える複数の画面とキーボードを
	<quote>仮想的に</quote> 実現できるのです。
	ある仮想コンソールで実行したプログラムは、
	そのコンソールが見えなくなっている時も実行を停止しません。
	別の仮想コンソールに切り替えても動き続けます。</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title><filename>/etc/ttys</filename> ファイル</title>

      <para>初期設定では、FreeBSD は 8 つの仮想コンソールを立ち上げます。
	この設定はもともと埋め込まれているわけではなく、
	インストールしたものが、もっと多いまたは少ない数の仮想コンソールで
	起動するように、容易にカスタマイズできます。仮想コンソールの数と
	設定は <filename>/etc/ttys</filename> ファイルに書かれています。</para>

      <para>FreeBSD の仮想コンソールを設定するには
	<filename>/etc/ttys</filename> ファイルを利用します。
	このファイルのコメントアウトされていない (<literal>#</literal>
	文字で始まっていない) 行は、一つの端末または仮想コンソールの
	設定があります。FreeBSD の初期設定では、
	仮想コンソールを 9 つ設定し、そのうち 8 つを有効にしています。
	<literal>ttyv</literal> で始まる行がそれです。</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>このファイルのそれぞれのカラムと仮想コンソールに設定可能な
	全オプションの詳しい説明は、&man.ttys.5; のマニュアルを
	参照してください。</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>シングルユーザモードのコンソール</title>

      <para><quote>シングルユーザモード</quote> とは何かという詳しい説明は、
	<xref linkend="boot-singleuser"/> にあります。FreeBSD を
	シングルユーザモードで動かしている場合は一つしかコンソールが
	ないということは注意しておくに値するでしょう。仮想コンソールは
	利用できません。シングルユーザモードのコンソールの設定は、同じく
	<filename>/etc/ttys</filename> ファイルにあります。
	<literal>console</literal> で始まる行を探してください。</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para><literal>console</literal> 行の上のコメントが示すように、
	  この行を編集して <literal>secure</literal> を
	  <literal>insecure</literal> に変更できます。そうすると、
	  FreeBSD がシングルユーザモードで起動した場合にも
	  <systemitem class="username">root</systemitem> のパスワードを要求します。</para>

	<para><emphasis>これを <literal>insecure</literal> に
	  変更する場合は十分注意してください。</emphasis>
	  <systemitem class="username">root</systemitem> のパスワードを忘れてしまったら、
	  シングルユーザモードで起動するのは少しややこしくなります。
	  できることはできますが、FreeBSD の起動の過程とそれに関わる
	  プログラムにあまり親しんでいない人には少し難しいかも知れません。</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>コンソールのビデオモードの変更</title>

      <para>FreeBSD のデフォルトのビデオモードは 1024x768 や 1280x1024 など、
	グラフィックカードとディスプレイが対応しているサイズに調整されます。
	別のビデオモードを使うには、以下の 2
	つのオプションを有効にしてカーネルを再コンパイルする必要があります。</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>1 度このオプションを有効にしてカーネルを再コンパイルしたら、
	あなたのハードウェアがどのビデオモードに対応しているか、
	&man.vidcontrol.1; を用いて知ることができます。
	以下を実行すると、どのビデオモードに対応しているかを知ることができます。</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>このコマンドの出力結果があなたのハードウェアが対応しているビデオモードです。
	その後 <systemitem class="username">root</systemitem>
	ユーザで &man.vidcontrol.1; を実行することで、
        新しくどのビデオモードを使うかを選択できます。</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>このビデオモードで良いと思ったら、起動時に自動的に設定されるように
        <filename>/etc/rc.conf</filename> ファイルに以下のように設定してください。</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>許可属性</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD は BSD &unix; の直系の子孫であり、
      いくつかの鍵となる &unix; 思想にもとづいています。
      まず最も際だった特徴として最初に言えるのは、FreeBSD
      がマルチユーザのオペレーティングシステムだということです。
      FreeBSD は同時に働いている複数のユーザすべてを、
      完全に分離したタスク上で処理する能力を持っています。
      また FreeBSD は、ハードウェアデバイス、周辺装置、メモリ、
      CPU 時間等への要求を、各ユーザが平等に利用できるように適切に共有し、
      管理する役割を担っています。</para>

    <para>システムがマルチユーザをサポートしているため、
      システムが管理する資源はすべて、
      誰がその資源を読み・書き・実行できるかを支配する、
      一組の許可属性を持っています。
      これらの許可属性は 3 つの部分からなる 3 桁の 8 進数の形で格納されています。
      それはそのファイルの所有者 (owner) に対するもの、
      そのファイルが所属するグループ (group) に対するもの、
      その他 (others) に対するものの 3 つです。
      これを数字を使って表現すると、次のようになります。</para>

    <indexterm><primary>許可属性 (permissions)</primary></indexterm>
    <indexterm>
      <primary>ファイルの許可属性 (permissions)</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>値</entry>
	    <entry>許可属性</entry>
	    <entry>ディレクトリの表示</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>読み込み不可、書き込み不可、実行不可</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>読み込み不可、書き込み不可、実行可能</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>読み込み不可、書き込み可能、実行不可</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>読み込み不可、書き込み可能、実行可能</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>読み込み可能、書き込み不可、実行不可</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>読み込み可能、書き込み不可、実行可能</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>読み込み可能、書き込み可能、実行不可</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>読み込み可能、書き込み可能、実行可能</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>ディレクトリ</primary></indexterm>

    <para>&man.ls.1; に対してコマンドライン引数 <option>-l</option> を使うと、
      詳細なディレクトリリストを見ることができ、
      ファイルの所有者、グループ、その他への許可属性を示す欄があるのがわかります。
      例えば、<command>ls -l</command> を実行して、
      適当なディレクトリを表示させると以下のようになります。</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>以下に示すのは、
      <command>ls -l</command> の最初の行を抜き出したものです。</para>

    <screen>-rw-r--r--</screen>

    <para>最初の (一番左の) 文字は、それが
      普通のファイルなのか、ディレクトリなのか、
      キャラクタ型のデバイス特殊ファイルなのか、
      ソケットなのか、
      その他の特殊な疑似ファイルデバイスなのかといった種類を示す特別な文字です。
      この場合、<literal>-</literal> という文字は、
      普通のファイルであることを示します。
      この例でその次に来る <literal>rw-</literal> と書かれた 3 文字は、
      そのファイルの所有者に許可を与えるものです。
      その次の <literal>r--</literal> の 3 文字は、
      そのファイルが所属しているグループに許可を与えます。
      最後の <literal>r--</literal> の 3 文字は、
      システムに存在するその他のユーザに許可を与えます。
      <quote>-</quote> は許可が与えられていないことを示します。
      このファイルの例では、ファイルの所有者はこのファイルを読み書きでき、
      ファイルの所属しているグループに属するユーザはファイルを読むことだけでき、
      そのどちらでもないユーザは、
      このファイルを読むだけできるように許可属性が与えられています。
      上の表によれば、このファイルに与えられた許可属性は
      <literal>644</literal> となります。
      ここで各数字は、このファイルの許可属性の 3 つの部分を表しています。</para>

    <para>ファイルについてはここまでの説明で十分です。 しかし、
      デバイスの場合の許可属性はどのようにコントロールされているのでしょうか?
      FreeBSD は、大部分のハードウェアをファイルとして取り扱います。
      そのため、プログラムからは普通のファイルとまったく同じようにオープンし、
      データの読み書きができるようになっています。
      これらのデバイス特殊ファイルは
      <filename>/dev</filename> ディレクトリに収められています。</para>

    <para>ディレクトリもまた、ファイルと同様に扱われます。
      それは読み込み/書き込み/実行の許可属性を持ちます。
      ディレクトリの実行ビットはファイルのそれとは少し違った意味を持ちます。
      ディレクトリが実行可能になっているとき、
      そのディレクトリに移動することができます。
      つまり、そのディレクトリに <quote>cd</quote> (change directory)
      することが可能です。
      また、実行可能属性がついているディレクトリでは、
      名前が分かっているファイルにアクセスすることもできます
      (もちろんそのファイル自体の許可属性によります)。
    </para>

    <para>特に、ディレクトリの中の一覧を表示するには、
      そのディレクトリに読み込み属性が設定されていなければなりません。
      一方、名前が分かっているファイルを削除するには、
      そのファイルが含まれているディレクトリに
      書き込み属性<emphasis>と</emphasis>実行属性
      の両方が必要です。</para>

    <para>この他にも許可属性ビットはありますが、いずれも
      setuid バイナリや sticky ディレクトリなどといった特殊な状況で使われます。
      ファイルの許可属性そのものについて、
      また、それらの設定のしかたに関する詳しい情報は、
      &man.chmod.1; マニュアルページを参照してください。</para>

    <sect2>
      <info><title>シンボリック表記</title>
	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>寄稿: </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm><primary>許可属性</primary><secondary>シンボル</secondary></indexterm>

      <para>シンボリック表記と呼ばれる許可属性を表す方法では、
	ファイルやディレクトリの許可属性を、
	8 進数ではなく記号を用いて設定します。
	シンボリック表記では、(who), (action), (permissions)
	という書式が用いられます。
	利用できる値は以下の通りです。</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>オプション</entry>
	      <entry>文字</entry>
	      <entry>意味</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(who)</entry>
	    <entry>u</entry>
	    <entry>ユーザ</entry>
	  </row>

	  <row>
	    <entry>(who)</entry>
	    <entry>g</entry>
	    <entry>ファイルを所持しているグループ</entry>
	  </row>

	  <row>
	    <entry>(who)</entry>
	    <entry>o</entry>
	    <entry>その他</entry>
	  </row>

	  <row>
	    <entry>(who)</entry>
	    <entry>a</entry>
	    <entry>すべて (<quote>world</quote>)</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>+</entry>
	    <entry>許可属性を与える</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>-</entry>
	    <entry>許可属性を取り除く</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>=</entry>
	    <entry>許可属性を指定したものにする</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>r</entry>
	    <entry>読み込み</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>w</entry>
	    <entry>書き込み</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>x</entry>
	    <entry>実行</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>t</entry>
	    <entry>Sticky ビット</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>s</entry>
	    <entry>UID または GID を設定する</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>これらの値は、これまでと同様に &man.chmod.1;
      コマンドで用いますが、文字で指定します。
      たとえば、<replaceable>FILE</replaceable>
      に対して自分以外のユーザからアクセスを一切受け付けたくない、
      というときには以下のコマンドを実行してください。</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>カンマ区切りで設定することで、
      ファイルの属性を一度に 2 つ以上変更できます。
      以下の例では、<replaceable>FILE</replaceable>
      に対して自分以外のユーザから書き込みの権限を取り上げ、
      かわりにすべてのユーザが <replaceable>FILE</replaceable>
      を実行できるようにします。</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>
<!--
    <para>ほとんどのユーザは気づかないかもしれませんが、
      8 進数の値を用いた属性の変更方法は、
      ファイルに対して許可属性を設定したり割り当てるだけで、
      属性を足したり取り除いたりするというものではありません。</para>
-->
    </sect2>

    <sect2>

    <info><title>&os; のファイルフラグ</title>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
    </info>

      <para>先ほど説明したファイルの許可属性に加え、
	&os; では <quote>ファイルフラグ</quote> を使えます。
	これはファイルにセキュリティや管理上の属性を追加するものですが、
	ディレクトリには追加しません。</para>

      <para>これらのファイルフラグはファイルに管理上の属性を追加し、
	<systemitem class="username">root</systemitem>
	ユーザでさえ誤ってファイルを消去、変更してしまうことを防ぎます。</para>

      <para>ファイルフラグは、&man.chflags.1;
	を使って、簡単なインタフェースで設定できます。
	例えば、<filename>file1</filename>
	というファイルにシステムレベルで消去不可のフラグを設定するには、
	以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>file1</filename></userinput></screen>

      <para>また、消去不可のフラグを削除するには、
	以下のように先ほどのコマンドの <option>sunlink</option> の前に
	<quote>no</quote> をつけるだけです。</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>file1</filename></userinput></screen>

      <para>ファイルにどのフラグが設定されているのかを見るには、&man.ls.1;
	コマンドを <option>-lo</option> オプションと一緒に使ってください。</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>file1</filename>
  </userinput></screen>

      <para>出力は以下のようになります。</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>いくつかのフラグの追加、削除は
	<systemitem class="username">root</systemitem> ユーザしかできません。
	他のフラグは、ファイルの所有者が変更できます。
	システム管理者は &man.chflags.1; と &man.chflags.2; から、
	より詳細な情報を得ることをおすすめします。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>ディレクトリ構造</title>
    <indexterm><primary>ディレクトリの階層構造</primary></indexterm>

    <para>FreeBSD のディレクトリ構造は、
      システム全体を理解するに当たって重要です。
      把握しておくべき最も重要なものは、<quote>/</quote>
      ディレクトリです。 このディレクトリは起動時に一番最初にマウントされ、
      オペレーティングシステムをマルチユーザで動作させるために
      必要な基本システムが含まれています。
      また、ルートディレクトリには、
      マルチユーザへの移行中に他のファイルシステムをマウントするためのマウントポイントも含まれます。</para>

    <para>マウントポイントとは、
      追加のファイルシステムと接続するためのディレクトリのことです
      (普通はルートファイルシステムにあります) 。
      より詳細な説明は
      <xref linkend="disk-organization"/>
      の節にあります。
      標準的なマウントポイントには
      <filename>/usr</filename>, <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename>, <filename>/cdrom</filename>
      があります。
      通常これらのディレクトリについては、
      <filename>/etc/fstab</filename> というファイル中のエントリが参照されます。
      <filename>/etc/fstab</filename>
      はさまざまなファイルシステムとマウントポイントの表であり、
      システムが参照します。
      <filename>/etc/fstab</filename> に書かれたファイルシステムは
      <option>noauto</option> オプションが指定されていなければ、
      起動時に &man.rc.8; スクリプトによって自動的にマウントされます。
      詳細は <xref linkend="disks-fstab"/> をご覧ください。</para>

    <para>ファイルシステム構造を網羅した説明は &man.hier.7; に書かれています。
      ここでは、もっともよく使われるディレクトリについて簡単に
      見るだけで十分でしょう。</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>ディレクトリ</entry>
	      <entry>説明</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename>/</filename></entry>
	      <entry>ファイルシステムのルートディレクトリ</entry>
            </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>シングルユーザ環境とマルチユーザ環境の両方で重要な
	        ユーザユーティリティ</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>オペレーティングシステムの起動時に使われるプログラムと設定ファイル</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>デフォルトの起動設定ファイル; &man.loader.conf.5; 参照</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>デバイスノード; &man.intro.4; 参照</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>システム設定ファイルとスクリプト</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>デフォルトのシステム設定ファイル; &man.rc.8; 参照</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>&man.sendmail.8; のようなメール転送エージェントの設定ファイル</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry><command>named</command> 設定ファイル; &man.named.8; 参照</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>&man.cron.8; 経由で毎日・毎週・毎月実行されるスクリプト;
		&man.periodic.8; 参照</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry><command>ppp</command> 設定ファイル;
	      &man.ppp.8; 参照</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>システム管理者が一時的なマウントポイントとしてよく使う
	        空のディレクトリ</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>プロセスファイルシステム; &man.procfs.5; と
	      &man.mount.procfs.8; 参照</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
	      <entry>緊急時のために静的にリンクされているプログラム; 詳しくは
	      &man.rescue.8; 参照</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry><systemitem class="username">root</systemitem> アカウントのホームディレクトリ</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>シングルユーザ環境とマルチユーザ環境の両方で重要な
	        システムプログラムと管理ユーティリティ</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>一時的なファイル。
		通常、<filename class="directory">/tmp</filename>
		の内容はシステムの再起動で失われます。
		メモリファイルシステムはよく
		<filename class="directory">/tmp</filename>
		にマウントされます。
		これは &man.rc.conf.5; の tmpmfs 関係の変数を使うか、
		<filename>/etc/fstab</filename>
		に設定項目を記入することで自動化できます。
		詳しくは &man.mdmfs.8; を参照して下さい。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>大部分のユーザユーティリティとアプリケーション</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>よく使うユーティリティとプログラミングツールとアプリケーション</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>C の標準ヘッダファイル</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>ライブラリ</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>いろいろなユーティリティのデータファイル</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>システムデーモンとシステムユーティリティ
	        (他のプログラムから実行される)</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>ローカルのプログラムやライブラリなど。
	        FreeBSD ports 構成のデフォルトインストール先としても使われます。
	        <filename>/usr/local</filename> 内では、
	        &man.hier.7; に書かれている <filename>/usr</filename>
		のための一般構造が使われます。
	        例外は man ディレクトリで、
	        <filename>/usr/local/share</filename> の下ではなく
	        <filename>/usr/local</filename> の下に直接置かれ、
	        ports 関係文書は
	        <filename>share/doc/port</filename>
		にあります。
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry><filename>/usr/src</filename> ツリーのビルドで作られる
	        アーキテクチャ依存のターゲットツリー</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports</filename></entry>
	      <entry>FreeBSD Ports Collection (インストールしなくてもよい)。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>(ユーザが実行する) システムデーモンとシステムユーティリティ</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>アーキテクチャに依存しないファイル</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>BSD のソースファイルまたはローカルのソースファイル、
	        あるいは両方</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/X11R6/</filename></entry>
	      <entry>X11R6 のプログラム、ライブラリなど (インストールしなくてもよい)</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>ログ・一時的なファイル・スプールファイルなどいろいろな用途。
	        メモリファイルシステムは時々
		<filename class="directory">/var</filename>
		にマウントされます。
	        これは &man.rc.conf.5; の varmfs 関係の変数を使うか、
	        <filename>/etc/fstab</filename>
		に設定項目を記入することで自動化できます。
	        詳しくは &man.mdmfs.8; を参照して下さい。</entry>
	    </row>


	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>いろいろなシステムログファイル</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>ユーザのメールボックスファイル</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>プリンタとメールシステムのスプールディレクトリなどなど</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>一時的なファイル。
	        <filename class="directory">/var</filename>
		がメモリファイルシステムでなければ、
	        ここにあるファイルはシステムが再起動しても失われません。</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>NIS のマップ</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 xml:id="disk-organization">
      <title>ディスク構成</title>

      <para>ファイルを見つけるために FreeBSD
	が使用する構成の一番小さな単位はファイル名です。
	ファイル名は、大文字と小文字を区別します。
	このことは
	<filename>readme.txt</filename> および <filename>README.TXT</filename>
	が異なる二つのファイルであることを意味します。
	FreeBSD はそのファイルがプログラム、または文書、
	あるいはその他の形式かどうかを決定するために拡張子を使用しません。</para>

      <para>ファイルはディレクトリ内に格納されます。
	ディレクトリはファイルを一つも含んでいないかもしれせんし、
	または数百のファイルを含んでいるかもしれません。
	ディレクトリはまた別のディレクトリを含むことができます。
	つまり、ディレクトリの階層構造を構築することができます。
	このことにより、データ構造がはるかに簡単になります。</para>

      <para>ファイルおよびディレクトリは、
	必要な他のディレクトリ名とスラッシュ (<literal>/</literal>) を後に続けて
	ファイル名またはディレクトリ名を与えることによって参照されます。
	
	<filename>foo</filename> ディレクトリがあって、その中に
	<filename>bar</filename> ディレクトリがあるとします。
	そして、その中に <filename>readme.txt</filename> があるとすると、
	ファイルへのフルネーム、または<firstterm>パス</firstterm>は
	<filename>foo/bar/readme.txt</filename> となります。</para>

      <para>ディレクトリおよびファイルはファイルシステム内に格納されます。
	どのファイルシステムは、そのファイルシステムのための
	<firstterm>ルートディレクトリ</firstterm> とよばれる、
	まさに頂点の位置にちょうど一つのディレクトリを含んでいます。
	このルートディレクトリは他のディレクトリを含むことができます。</para>

      <para>これまでのところ、これはあなたの使ったことのある他の OS
	とおそらく似ているかもしれません。少し違いがあります。
	たとえば、&ms-dos; ではファイル名とディレクトリ名を分けるのに
	<literal>\</literal> を使います。
	一方、&macos; では <literal>:</literal> を使います。</para>

      <para>FreeBSD はパス内にドライブレターまたは他のドライブ名を使いません。
	あなたは FreeBSD で <filename>c:/foo/bar/readme.txt</filename>
	とは書かないでしょう。</para>

      <para>その代わり、一つのファイルシステムは
	<firstterm>ルートファイルシステム</firstterm>として設計されています。
	ルートファイルシステムのルートディレクトリは <literal>/</literal>
	として参照されます。それから、他のすべてのファイルシステムは、
	ルートファイルシステム以下に <firstterm>マウント</firstterm>
	されます。
	あなたが FreeBSD システムでどんなに多くのディスクを使用しても、
	すべてのディレクトリは、
	同じディスクの一部であるように見えるので問題ありません。</para>

      <para><literal>A</literal>,<literal>B</literal> および
	<literal>C</literal>
	と呼ばれる三つのファイルシステムがあると仮定しましょう。
	それぞれのファイルファイルシステムには一つのルートディレクトリがあり、
	<literal>A1</literal>, <literal>A2</literal>
	と呼ばれている二つの他のディレクトリを含んでいます
	(同様に	<literal>B1</literal>, <literal>B2</literal> および
	<literal>C1</literal>, <literal>C2</literal> があります)。</para>

      <para><literal>A</literal> をルートファイルシステムとします。
	このディレクトリになにが含まれているか見るために
	<command>ls</command> コマンドを使うと、
	<literal>A1</literal> および <literal>A2</literal>
	の二つのサブディレクトリが現れるでしょう。
	ディレクトリツリーは以下のようになります。</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>ファイルシステムはファイルシステム内のディレクトリにマウントしなければいけません。
	それでは、<literal>A1</literal> ディレクトリに
	<literal>B</literal> ファイルシステムをマウントすると仮定します。
	<literal>B</literal> のルートディレクトリは <literal>A1</literal>
	に置き換えられ、
	そして <literal>B</literal> 内のディレクトリがそれに応じて現れます。</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 | 
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para><literal>B1</literal> または <literal>B2</literal>
	内にあるどんなファイルも、必要なときに
	<filename>/A1/B1</filename> または <filename>/A1/B2</filename>
	で到達できます。
	<filename>/A1</filename>
	にあったすべてのファイルは一時的に隠されました。
	それらは <literal>B</literal> が
	A から<firstterm>アンマウント</firstterm>されたら再び現れるでしょう。</para>

      <para>もし <literal>B</literal> が <literal>A2</literal>
	にマウントされていたら、この図のようになります。</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>そして、パスはそれぞれ <filename>/A2/B1</filename> および
	<filename>/A2/B2</filename> となるでしょう。</para>

      <para>ファイルシステムは互いのファイルシステム上にもマウントできます。
	上記の最後の例に続けて、<literal>C</literal> ファイルシステム は
	<literal>B</literal> ファイルシステム内の <literal>B1</literal>
	ディレクトリ上にマウントできます。
	次の図のようになります。</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS"/>
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>または <literal>C</literal> は <literal>A1</literal> の下の
	<literal>A</literal> ファイルシステムに直接マウントできます。</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>もしあなたが &ms-dos; を使いなれているなら、
	まったく同じではありませんが、これは <command>join</command> コマンドと
	似ています。</para>

      <para>これは、通常あなた自身が心配する必要のあるものではありません。
	一般的に、FreeBSD をインストールするときにファイルシステムを作成し、
	どこにマウントするか決定します。そして、
	新しいディスクを追加しなければそれらを変更することはありません。</para>

      <para>一つの大きなファイルシステムを用意し、
	他のファイルシステムを作成する必要としないことはまったくもって可能です。
	この方法にはいくつかの短所と一つの利点があります。</para>

      <itemizedlist>
	<title>マルチファイルシステムの利点</title>
      
	<listitem>
	  <para>異なったファイルシステムは異なった
	    <firstterm>マウントオプション</firstterm> を使用できます。
	    たとえば、注意深い考えなのですが、
	    ルートファイルシステムを読みだし専用でマウントして、
	    不注意によって重大なファイルを削除、
	    または編集できないようににすることができます。
	    また、<filename>/home</filename>
	    のようなユーザが書き込み可能なファイルシステムを他のファイルシステムと分けることによって、
	    <firstterm>nosuid</firstterm> でマウントすることも可能になります。
	    このオプションは、ファイルシステムに記録されている
	    <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
	    の実行可能ビットを有効にしないので、安全性を高めることができるでしょう。</para>
	</listitem>

	<listitem>
	  <para>FreeBSD はファイルシステムがどのように使われているかによって、
	    自動的にファイルシステム上のファイルの配置を最適化します。
	    したがって、連続的に書き込まれた多くの小さなファイルが含まれているファイルシステムは、
	    より大きく少ないファイルが含まれているファイルシステムと異なる最適化をするでしょう。
	    一つの大きなファイルシステムを作成すると、
	    この最適化は成り立たなくなります。</para>
	</listitem>
	
	<listitem>
	  <para>FreeBSD のファイルシステムはトラブルが起きてもとても強固です。
	    しかしながら臨界点でのトラブルは、
	    ファイルシステムの構造にまだ損害を与えるかもしれません。
	    マルチファイルシステムへデータを分割しておくことで、
	    必要なときにバックアップからレストアすることをより容易にして、
	    まだシステムが回復するかもしれません。</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>シングルファイルシステムの利点</title>

	<listitem>
	  <para>ファイルシステムは固定サイズです。
	    FreeBSD をインストールするときにファイルシステムを作成して、
	    固定サイズを割りあてたなら、
	    後になってそのパーティションをより大きくする必要があると気づくかもしれません。
	    パーティションのサイズを変更するには、
	    バックアップ、新しいサイズを指定したファイルシステムの再作成、
	    バックアップしたデータをリストアする作業が必要となるでしょう。</para>

	  <important>
	    <para>FreeBSD には、
	      &man.growfs.8; コマンドがあります。
	      このコマンドは、この制限を取り除いて、
	      ファイルシステムのファイルを直ちに増加させることを可能にします。
	      </para>
	  </important>
	</listitem>
      </itemizedlist>
    
      <para>ファイルシステムはパーティション内に含まれています。
	FreeBSD の &unix; 遺産のために、
	これは普段使われるパーティション (例えば &ms-dos; パーティション)
	という用語の意味とは違う意味を持っています。
	それぞれのパーティションは <literal>a</literal> から
	<literal>h</literal> までの文字で区別されます。
	それぞれのパーティションは、
	一つのファイルシステムだけを含むことができます。
	このことは、ファイルシステムがファイルシステムの階層上の典型的なマウントポイント、
	または含まれているパーティションの文字によって記述されることを意味します。</para>

      <para>FreeBSD は <firstterm>スワップ領域</firstterm>
	にもまたディスク領域を使用します。
	スワップ領域は FreeBSD に <firstterm>仮想メモリ</firstterm>
	を提供します。
	これはあなたのコンピュータが、
	実際に搭載している以上のメモリがあるかのように振舞います。
	FreeBSD がメモリを使い果たしたときに、
	現在使用されていないデータのいくつかをスワップ領域に移動し、
	そのデータが必要となったときに 
	(その他のデータをスワップ領域に移動させてから) 
	メモリ内に移動しなおします。</para>

      <para>いくつかのパーティションはある慣習と関係づけられています。</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>パーティション</entry>

	      <entry>慣習</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>通常、ルートパーティションを含みます。</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>通常、スワップ領域を含みます。</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>通常、スライス全体と同じサイズです。
		これは、スライス全体にアクセス必要のあるユーティリティ
		(たとえば、ひどいブロックスキャナ) が、
		<literal>c</literal> 
		パーティションにアクセスすることを可能にします。通常、
		このパーティション内にファイルシステムを作成しないでしょう。</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry><literal>d</literal> パーティションは、
		それに関連づけられた特別な意味を持っていましたが、
		今は無いので、普通のパーティションとして動作するでしょう。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>ファイルシステムを含んだそれぞれのパーティションは、FreeBSD
	が <firstterm>スライス</firstterm> と呼ぶものの中に格納されます。
	スライスは FreeBSD の用語で、
	普通はパーティションと呼ばれるものです。
	もう一度言及しますが、これは FreeBSD の &unix; 背景によるものです。
	スライスは 1 から 4 までの番号がつけられます。</para>

	<indexterm><primary>スライス</primary></indexterm>
	<indexterm><primary>パーティション</primary></indexterm>
	<indexterm><primary>危険な専用</primary></indexterm>

      <para>スライス番号は 1 から始まり
	<literal>s</literal> を前につけられて、デバイス名の後に続きます。
	したがって、<quote>da0<emphasis>s1</emphasis></quote>
	は一番目の SCSI ドライブ上の 一番目のスライスです。
	ディスク上に四つの物理スライスだけが存在できます。しかし、
	適切な種類の物理スライス内に論理スライスをもつことができます。
	これらの拡張されたスライス番号は 5 から始まります。したがって、
	<quote>ad0<emphasis>s5</emphasis></quote> 
	は、一番目の IDE ディスク上の一番目の拡張スライスです。
	これらのデバイスは、
	スライスを占有することを予期するファイルシステムによって使用されます。</para> 

      <para>スライスや <quote>危険な専用</quote> の物理ドライブ、
	そして他のドライブは <literal>a</literal> から <literal>h</literal>
	までの文字として表される <firstterm>パーティション</firstterm>
	を含んでいます。
	この文字はデバイス名に追加されます。したがって、
	<quote>da0<emphasis>a</emphasis></quote> 
	は一番目の <quote>危険な専用</quote> da ドライブ上の
	a パーティションです。
	<quote>ad1s3<emphasis>e</emphasis></quote> は、
	二番目の IDE ディスク上の 三番目のスライス内にある五番目のパーティションです。</para>
	
      <para>最後に、システム上のそれぞれのディスクは識別されます。
	ディスク名はどの種類のディスクであるかを示す記号ではじまり、
	どのディスクかを示す数字が続きます。
	スライスとは違いディスクの番号づけは 0 から始まります。
	共通の記号は <xref linkend="basics-dev-codes"/>
	に示されます。</para>

      <para>パーティションを参照するときには、
	FreeBSD はパーティションを含むスライスおよびパーティションも指定することを必要とします。
	そしてスライスを参照するときはディスク名も参照しないといけません。
	したがって、ディスク名、<literal>s</literal>、スライス番号、
	そしてパーティション文字を並べることによってパーティションを参照します。
	<xref linkend="basics-disk-slice-part"/>に例があります。</para>

      <para><xref linkend="basics-concept-disk-model"/>
	は理解をより明らかにすることを助けるための、
	ディスク構成の概念のモデルを示します。</para>

      <para>FreeBSD をインストールするために、
	まずはじめにディスクスライスの設定をし、
	次に FreeBSD に用いるスライス内のパーティションを作成し、
	それからそれぞれのパーティション内にファイルシステム
	(またはスワップ領域) を作成し、
	ファイルシステムがどこにマウントされるか決定しなければいけません。</para>

      <table frame="none" pgwide="1" xml:id="basics-dev-codes">
	<title>ディスクデバイス記号</title>

	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>記号</entry>
	    
	      <entry>意味</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><filename>ad</filename></entry>

	      <entry>ATAPI (IDE) ディスク</entry>
	    </row>

	    <row>
	      <entry><filename>da</filename></entry>
	      
	      <entry>SCSI ダイレクトアクセスディスク</entry>
	    </row>
	    
	    <row>
	      <entry><filename>acd</filename></entry>
	      
	      <entry>ATAPI (IDE) CDROM</entry>
	    </row>
	    
	    <row>
	      <entry><filename>cd</filename></entry>
	      
	      <entry>SCSI CDROM</entry>
	    </row>
	    
	    <row>
	      <entry><filename>fd</filename></entry>
	      
	      <entry>フロッピーディスク</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example xml:id="basics-disk-slice-part">
	<title>ディスク名、スライス名、パーティション名のサンプル</title>
	
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*"/>
            <colspec colwidth="5*"/>

	    <thead>
	      <row>
		<entry>記号</entry>
		
		<entry>意味</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
		<entry>一番目の IDE ディスク (<literal>ad0</literal>)
		  上の一番目のスライス (<literal>s1</literal>) 
		  内の一番目のパーティション (<literal>a</literal>)。</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		
		<entry>二番目の SCSI ディスク (<literal>da1</literal>)
		  上の二番目のスライス (<literal>s2</literal>)
		  内の五番目のパーティション (<literal>e</literal>)。</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example xml:id="basics-concept-disk-model">
	<title>ディスクの概念的構成</title>

	<para>これはシステムに接続された一番目の IDE 
	  ディスクの FreeBSD から見た図を示します。
	  ディスクサイズは 4&nbsp;GB と仮定し、
	  2&nbsp;GB のスライス (&ms-dos; でいうパーティション) が二つあるとします。
	  一番目のスライスは &ms-dos; ディスクの <filename>C:</filename>
	  を含んでいます。
	  そして、二番目のスライスは FreeBSD のディスクを含んでいます。
	  これは FreeBSD インストーラが三つのデータパーティションと一つのスワップパーティションを作成した例です。</para>

	<para>三つのパーティションはそれぞれファイルシステムを含んでいます。
	  <literal>a</literal> 
	  パーティションはルートファイルシステムに使用され、
	  <literal>e</literal> パーティションは <filename>/var</filename>
	  ディレクトリ階層に、 <literal>f</literal> パーティションは
	  <filename>/usr</filename> ディレクトリ階層に使用されるでしょう。</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS"/>
          </imageobject>
 
          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all 
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>ファイルシステムのマウントとアンマウント</title>

    <para>ファイルシステムは <filename>/</filename>
      をルート (根) とする木構造として考えると視覚的に理解しやすいでしょう。
      ルートディレクトリにある
      <filename>/dev</filename> や <filename>/usr</filename>、
      その他のディレクトリは枝に相当し、
      それらには、<filename>/usr/local</filename>
      などのように、さらに枝分かれすることができます。</para>

    <indexterm><primary>ルートファイルシステム</primary></indexterm>
    <para>さまざまな理由がありますが、
      ディレクトリをいくつかの異なるファイルシステム上に構築するのが良いでしょう。
      たとえば <filename>/var</filename> には、
      <filename>log/</filename> や <filename>spool/</filename>
      など、さまざまな種類の一時ファイルを置くディレクトリがあるため、
      あふれてしまう可能性があります。
      ルートファイルシステムをあふれさせるのは得策ではありませんので、
      普通は <filename>/var</filename> を <filename>/</filename>
      から分離します。</para>

    <para>また、次のような場合も、ディレクトリツリーを
      別のファイルシステムに置く理由として良くあげられます。
      それは、たとえば物理的に別のディスクにディレクトリツリーを置く場合、
      <link linkend="network-nfs">ネットワークファイルシステム (Network File System)</link> や
      CDROM ドライブのような別の仮想ディスクに置くという場合です。</para>

    <sect2 xml:id="disks-fstab">
      <title><filename>fstab</filename> ファイル</title>
      <indexterm>
	<primary>ファイルシステム</primary>
	<secondary>fstab を使ったマウント</secondary>
      </indexterm>

      <para><filename>/etc/fstab</filename> に書かれているファイルシステムは
        (<option>noauto</option> オプションがなければ)
        <link linkend="boot">起動プロセス</link>の途中で
	自動的にマウントされます。</para>

      <para><filename>/etc/fstab</filename> ファイルは、
        次のような書式で書かれた行のリストになっています。</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>デバイスの名前 (存在していなければなりません)。
	      <xref linkend="disks-naming"/> に説明があります。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
	    <para>ファイルシステムがマウントするディレクトリの名前
	      (存在していなければなりません)。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
	    <para>&man.mount.8; に渡されるファイルシステムタイプ。
	      FreeBSD ファイルシステムのデフォルトは
	      <literal>ufs</literal> です。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>読み書きするファイルシステムには
	      <option>rw</option>、読み込み専用のファイルシステムには
	      <option>ro</option> を、必要な他のオプションの前に指定します。
	      よく使われるオプションは <option>noauto</option> で、
	      起動時にはマウントされないファイルシステムに使います。
	      その他のオプションは &man.mount.8;
	      マニュアルページに載っています。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

         <listitem>
	   <para>これは &man.dump.8; が使うもので、
	     どのファイルシステムにダンプが必要なのかを決めます。
             この項目がなければ、0 であるものとみなされます。</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>これはファイルシステムをチェックする順番を決めます。
           ファイルシステムチェックを飛ばしたいファイルシステムには、
           <literal>passno</literal> を 0 に設定してください。
	   ルートファイルシステム
	   (どれよりも先にチェックしなければなりません)
	   は <literal>passno</literal> を 1 に設定してください。
           他のファイルシステムの <literal>passno</literal>
           は 1 以上に設定してください。
	   同じ <literal>passno</literal> のファイルシステムがあった場合、
           &man.fsck.8; は可能であれば並行してファイルシステムのチェック
	   を行なおうとします。</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para><filename>/etc/fstab</filename>
	ファイルの書式やオプションに関しての詳細は、
	&man.fstab.5; をご覧ください。</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title><command>mount</command> コマンド</title>
      <indexterm>
	<primary>ファイルシステム</primary>
	<secondary>マウント</secondary>
      </indexterm>

      <para>&man.mount.8; コマンドは、
        ファイルシステムをマウントするために使われるものです。</para>

      <para>基本的には、次のように使います。</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount device mountpoint</userinput></screen>
      </informalexample>

      <para>&man.mount.8; マニュアルページにはたくさんのオプションが書かれていますが、
        いちばんよく使われるのは次のものです。</para>

      <variablelist>
	<title>マウントオプション</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para><filename>/etc/fstab</filename>
	      にある全てのファイルシステムをマウントします。
	      例外は <quote>noauto</quote> の印がついているものと、
	      <option>-t</option> フラグで除外されたものと、
	      すでにマウントされているファイルシステムです。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>実際にマウントシステムコールする以外のすべてのことをします。
	      このオプションは <option>-v</option>
	      フラグと組み合わせて使い、
	      &man.mount.8; が実際なにをしようとしているのか調べるのに便利です。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>クリーンでないファイルシステムを強制的にマウントします
	      (危険です)。もしくは、ファイルシステムのマウント状態を
	      読み書き可能から読み込みのみに変更するとき、
	      書き込みアクセスを強制的に取り消します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	  <listitem>
	    <para>ファイルシステムを読み込み専用でマウントします。
	      これは <option>ro</option> (5.2 より前の
	      &os; では <option>rdonly</option> です)
	      引数を <option>-o</option>
	      オプションに使うのと同じです。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>ファイルシステムを指定のファイルシステムタイプでマウントします。
	      または、<option>-a</option> を使った場合、
	      指定したタイプのファイルシステムのみマウントします。</para>

	    <para>デフォルトのファイルシステムタイプは
	      <quote>ufs</quote> です。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>ファイルシステムのマウントオプションを更新します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>詳細な出力にします。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>ファイルシステムを読み書き可能にマウントします。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para><option>-o</option> には、
         次のようなオプションを複数カンマで区切って指定します。
         以下に挙げるのはその一部です。</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
              <para>そのファイルシステム上のバイナリの実行を禁止します。
	        セキュリティのために有用なオプションです。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>そのファイルシステム上の setuid や setgid フラグを解釈しません。
	      これもセキュリティのために有用なオプションです。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title><command>umount</command> コマンド</title>
      <indexterm>
	<primary>ファイルシステム</primary>
	<secondary>アンマウント</secondary>
      </indexterm>

      <para>&man.umount.8; コマンドは、パラメータとしてマウントポイントの一つ、
	デバイス名、もしくは <option>-a</option> や <option>-A</option>
	といったオプションを取ります。</para>

      <para>いずれの形式でも <option>-f</option> で強制的なアンマウントを行ない、
        <option>-v</option> で詳細な出力を出します。
        ただしほとんどの場合、<option>-f</option> は使わないほうがよいでしょう。
	強制的にファイルシステムをアンマウントすると、
	計算機がクラッシュしたりファイルシステム上部のデータが
	破壊されたりする恐れがあるためです。</para>

      <para>オプション <option>-a</option> と <option>-A</option>
        はマウントされているファイルシステムすべてをアンマウントするのに使います。
	<option>-t</option> にファイルシステムタイプを指定すると、
	指定されたものだけがアンマウントされます。
	また、<option>-A</option> を使うとルートファイルシステムはアンマウントしません。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>プロセス</title>

    <para>FreeBSD はマルチタスクのオペレーティングシステムです。
      つまり、1つ以上のプログラムがあたかも同時に動いているかのように見える、
      ということです。動作中のプログラムはそれぞれ
      <firstterm>プロセス</firstterm> と呼ばれます。
      コマンドを実行すると、最低でも1つの新しいプロセスがスタートします。
      システムを正常に機能させるために常に動作しているシステムプロセスもたくさんあります。</para>

    <para>各プロセスは<firstterm>プロセス ID</firstterm>、もしくは
      <firstterm>PID</firstterm> と呼ばれる数字でただ一つに識別されます。
      また、ファイルのように各プロセスには所有者とグループがあります。
      所有者とグループの情報は、
      これまでに見たファイル許可属性を用い、
      そのプロセスが開けるファイルやデバイスを決定するために使われます。
      多くのプロセスには親プロセスもあります。
      親プロセスとは、そのプロセスをスタートさせたプロセスのことです。
      例えば、シェルにコマンドを打ち込んでいるときはシェルがプロセスで、
      動かすコマンドもまたどれもプロセスです。
      このようにして起動するプロセスはそれぞれシェルが親プロセスになります。
      これの例外は &man.init.8; という特別なプロセスです。
      <command>init</command> は常に最初のプロセスなので、
      PID は必ず 1 になります。
      <command>init</command> は FreeBSD
      がスタートするときカーネルによって自動的に起動されます。</para>

    <para>&man.ps.1; と &man.top.1; という2つのコマンドが
      システム上のプロセスを確認するために特に便利です。
      <command>ps</command>
      コマンドは現在動作中のプロセスのリストを見るために使い、
      PID やプロセスが使っているメモリの量、
      どういうコマンドラインで起動されたのか、
      などを表示させることができます。
      <command>top</command> コマンドは動作中の全てのプロセスを表示し、
      数秒ごとに表示を更新するので、
      計算機がなにをしているのかインタラクティブに知ることができます。</para>

    <para>デフォルトでは、<command>ps</command>
      は動作中かつ所有者が自分のコマンドのみを表示します。
      例えば:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>この例で分かるとおり、
      &man.ps.1; の出力はいくつかの行に整形されています。
      <literal>PID</literal> は先ほど見たプロセス ID です。
      PID は 1 から順に 99999 まで割り当てられ、
      足りなくなると最初に戻って使い回されます
      (使用中の PID は割り当てられません) 。
      <literal>TT</literal> の列はプログラムが動いている tty を示します。
      差し当たって無視してもかまわないでしょう。
      <literal>STAT</literal> はプログラムの状態を示しますが、
      これもまた無視してよいでしょう。
      <literal>TIME</literal> はプログラムがその CPU
      上で動いている時間の長さです&mdash;
      通常はプログラムをスタートさせたときからの経過時間ではありません。
      CPU 上で時間を使う必要があるまでかなりの時間を費すようなプログラムもあるからです。
      最後に、<literal>COMMAND</literal>
      はそのプログラムを起動するのに使われたコマンドラインとなります。</para>

    <para>&man.ps.1; は表示する情報を変えるためのオプションをたくさんサポートしています。
      いちばん便利なのは <literal>auxww</literal> でしょう。
      <option>a</option> は自分のプロセスだけではなく、
      動作中のプロセス全部についての情報を表示します。
      <option>u</option> はプロセスの所有者の名前をメモリ使用量と同様に表示します。
      <option>x</option> はデーモンプロセスについての情報を表示し、
      <option>ww</option> で、スクリーンに入りきらないほど長くなったコマンドラインでも省略せず、
      &man.ps.1; に各プロセスの全コマンドラインを表示させます。</para>

    <para>&man.top.1; の出力も同様です。 例は以下の通りです。</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>出力は2つのセクションに分かれています。
      ヘッダ (最初の 5 行です) は動作している最新のプロセスの PID、
      システムの平均負荷 (システムがどれくらい忙しいかの指標)、
      システムの稼働時間 (最後の再起動からの時間)
      と現在の時刻を示します。
      ヘッダの中の他の数字は動作中のプロセスの数 (この場合 47 ですね)、
      使われているメモリとスワップ領域の量、
      そしてシステムが異なる CPU 状態に消費した時間と関係します。</para>

    <para>その下には &man.ps.1; の出力と同じような情報を持った行が続きます。
      前と同様 PID にユーザ名、消費 CPU 時間と実行中のコマンドを知ることができます。
      &man.top.1; を使うとデフォルトでプロセスが使っているメモリ容量も分かります。
      メモリ使用量の欄は2項目に分かれており、
      一方は合計使用量、
      そしてもう一方は実使用量です&mdash;合計使用量はアプリケーションが必要としているメモリ量で、
      実使用量はその時点で実際に使われているメモリ量です。
      この例では、<application>&netscape;</application> がだいたい
      30&nbsp;MB の RAM を必要としていますが、
      いまのところ 9&nbsp;MB しか使っていないことが分かります。</para>

    <para>&man.top.1; は自動的に2秒ごとに画面を更新します。
      <option>s</option> オプションを使えば更新間隔を変更することができます。</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>デーモン、シグナルとプロセス終了</title>

    <para>エディタを使っている場合、エディタを操作するのは簡単です。
      ファイルを開く、などと動かせばよいのです。
      このように操作できるのは、エディタにそういった機能があり、
      かつエディタが<firstterm>端末</firstterm>に関連づけられているからです。
      一方、ユーザから始終入力があるように設計されていないプログラムもあり、
      そういったプログラムは最初から端末と切り離されます。
      例えば、ウェブサーバは一日中ウェブのリクエストばかり処理するので、
      通常全く入力を必要としません。
      サイトからサイトへとメールを転送するプログラムも、
      こういった種類のアプリケーションの一例です。</para>

    <para>このようなプログラムは、<firstterm>デーモン</firstterm>と呼ばれます。
      デーモンはギリシャ神話の登場人物で、
      善でも悪でもなく、大雑把にいうと、
      人間のために役立つことをしてくれる小さな妖精さんです。
      今日の便利なウェブサーバやメールサーバととてもよく似ていますね。
      このため、長い間 BSD のマスコットはスニーカーをはいてフォークを携えた
      かわいらしい姿のデーモンなのです。</para>

    <para>通常デーモンとして動作するプログラムには末尾に <quote>d</quote>
      を持った名前をつける慣習があります。
      <application>BIND</application> は Berkeley Internet Name Domain
      ですが、
      実際実行されるプログラムは <command>named</command> という名前です。
      <application>Apache</application> ウェブサーバのプログラムは
      <command>httpd</command> と呼ばれ、
      ラインプリンタスプーリングデーモンは <command>lpd</command>、
      などなどです。
      これは単なる慣習で、しっかりがっちりとしたルールではありません。
      例えば、<application>Sendmail</application>
      アプリケーションの主なメールデーモンは
      <command>sendmail</command> という名前で、
      連想しそうな <command>maild</command> ではありません。</para>

    <para>時々、デーモンプロセスと通信したいときがあります。
      一つの方法として、それ (に限らずどんな動作中のプロセスでも) に
      <firstterm>シグナル</firstterm>と呼ばれるものを送信する方法です。
      送信可能なシグナルはたくさんあります&mdash;特別な意味があるものもあれば、
      アプリケーションによって解釈されるものもありますし、
      アプリケーションがシグナルをどう解釈するかは
      そのアプリケーションの文章を読めば分かるでしょう。
      自分が持っているプロセスにしかシグナルを送ることはできません。
      他人のプロセスに &man.kill.1; や &man.kill.2;
      を使ってシグナルを送っても、許可されないでしょう。
      これの例外は <systemitem class="username">root</systemitem> ユーザで、
      ルートユーザは誰のプロセスでもシグナルを送ることができます。</para>

    <para>FreeBSD もアプリケーションにシグナルを送ることがあります。
      アプリケーションを下手に書くと、
      予想外のメモリにアクセスしようとするので、
      FreeBSD がプロセスに <firstterm>セグメンテーション違反</firstterm>
      シグナル (<literal>SIGSEGV</literal>) を送ります。
      ある程度の時間が経ったら &man.alarm.3;
      システムコールを使って警告してもらうようなアプリケーションには、
      警告シグナル (<literal>SIGALRM</literal>) が送信される、
      などです。</para>

    <para>プロセスを止めるためには2つのシグナル、
      <literal>SIGTERM</literal> か <literal>SIGKILL</literal>
      を使います。
      <literal>SIGTERM</literal> は穏かにプロセスを終了させる方法です。
      プロセスはシグナルを<emphasis>受け取る</emphasis>ことができ、
      終了させたいのだなということを理解し、
      開いているログファイルを全部を閉じ、
      一般的に終了前にしていたことを終えることができます。
      中断できない処理の途中だと、<literal>SIGTERM</literal>
      をプロセスが無視することもあるかもしれません。</para>

    <para>プロセスは <literal>SIGKILL</literal> を無視することができません。
      これは、<quote>なにをしていようが構わないから今すぐ止まれ</quote>
      というシグナルです。 プロセスに <literal>SIGKILL</literal> を送ると、
      FreeBSD はそのプロセスをそこで止めます<footnote>
	<para>正確ではありません&mdash;中断できないものはわずかながら存在します。
	  例えば、プロセスがネットワーク上の別の計算機にあるファイルを読もうとして、
	  その計算機がなんらかの理由
	  (電源を落とされたとか、ネットワークに問題があるとか)
	  でいなくなった場合、そのプロセスは<quote>中断不可能</quote>と言われます。
	  最終的にはそのプロセスはタイムアウトします。普通は2分後です。
	  タイムアウトした直後、そのプロセスは終了します。</para>
      </footnote>。</para>

    <para>使う可能性のあるシグナルは、他に
      <literal>SIGHUP</literal>、<literal>SIGUSR1</literal>、と
      <literal>SIGUSR2</literal> があります。
      これらは一般的な用途のシグナルで、
      このシグナルが送信されたときアプリケーションによって別のことをします。</para>

    <para>ウェブサーバの設定ファイルを変更したとしましょう&mdash;ウェブサーバに新しい設定を再読み込みさせたいですね。
      <command>httpd</command> を止めて再起動することもできますが、
      そうするとウェブサーバは一瞬ながら停止してしまいますし、
      ちょっとでも止まってほしくないこともあるでしょう。
      ほとんどのデーモンは <literal>SIGHUP</literal>
      シグナルに対して設定ファイルを再読み込みする反応を返すよう書かれています。
      従って、<command>httpd</command> を止めて再起動する代わりに、
      <literal>SIGHUP</literal> シグナルを送りましょう。
      これらのシグナルへの標準的な反応というものがないために、
      デーモンごとに行動が違うので、
      疑問があれば必ずそのデーモンの文書を読んでください。</para>

    <para>&man.kill.1; コマンドを使って送るシグナルはこの例をご覧ください。</para>

    <procedure>
      <title>プロセスにシグナルを送る</title>

      <para>この例では、&man.inetd.8; にシグナルを送る方法を示します。
	<command>inetd</command> の設定ファイルは
	<filename>/etc/inetd.conf</filename> で、
	<command>inetd</command> は <literal>SIGHUP</literal>
	が送信されるとこの設定ファイルを再読み込みします。</para>

      <step>
	<para>シグナルを送りたいプロセスのプロセス ID を探します。
	  それには &man.ps.1; と &man.grep.1; を使います。
	  &man.grep.1; コマンドは出力を検索するために使い、
	  指定した文字列を探します。
	  このコマンドは一般ユーザで実行しますが、
	  &man.inetd.8; は <systemitem class="username">root</systemitem> で実行されているので、
	  &man.ps.1; には <option>ax</option>
	  オプションを与える必要があります。</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>ということで、&man.inetd.8; の PID は 198 です。
	  <literal>grep inetd</literal> コマンドがこの出力に出てくる場合もあります。
	  それは、&man.ps.1; が動作中のプロセスのリストを見つける方法によります。</para>
      </step>

      <step>
	<para>&man.kill.1; を使ってシグナルを送ります。
	  &man.inetd.8; は <systemitem class="username">root</systemitem> で起動されているために、
	  まず &man.su.1; を使って <systemitem class="username">root</systemitem>
	  にならなければなりません。</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>大部分の &unix; コマンドと同じく、
	  成功したら &man.kill.1; は何の出力も表示しません。
	  自分のものではないプロセスにシグナルを送ると、
	  <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname> と表示されます。
	  PID を打ち間違えると、
	  悪いことに間違ったプロセスにシグナルを送ってしまうか、
	  もしくは運がよければその時点で使われていない PID
	  にシグナルを送ったことになり、<errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>
	  と表示されます。</para>

	<note>
	  <title>なぜ <command>/bin/kill</command> を使うんでしょう?</title>

	  <para>多くのシェルは <command>kill</command>
	    コマンドを組み込みコマンドとして備えています。
	    つまり、<filename>/bin/kill</filename> を実行するのではなく、
	    シェルが直接シグナルを送ります。
	    これはとても便利なのですが、
	    シェルが違うと送るシグナルの名前の指定の仕方が違います。
	    シェルによって異なるシグナルの指定の仕方を全部覚えようとはせずに、
	    <command>/bin/kill ...</command>
	    コマンドを直接使うほうが簡単です。</para>
	</note>
      </step>
    </procedure>

    <para>他のシグナルの送り方はほとんど同じで、
      コマンドラインの <literal>TERM</literal> や <literal>KILL</literal>
      を必要に応じて変えるだけです。</para>

    <important>
      <para>システム上のランダムプロセスを終了させるのはよくありません。
        特に、プロセス ID が 1 の &man.init.8; は特別です。
	<command>/bin/kill -s KILL 1</command>
	を使うといとも簡単にシステムをシャットダウンさせることができます。
	<keycap>Return</keycap> を押す<emphasis>前</emphasis>に
	&man.kill.1; を実行する引数を二重にチェックする<emphasis>癖</emphasis>をつけてください。</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>シェル</title>
    <indexterm><primary>シェル (shell)</primary></indexterm>
    <indexterm><primary>コマンドライン</primary></indexterm>

    <para>FreeBSD では日々の作業のほとんどは、
      「シェル」と呼ばれるコマンドラインインタフェイスを通して行われます。
      シェルの主な仕事はコマンドを入力チャンネルから受け取り、
      そしてそれらを実行することです。
      大部分のシェルはさらに組み込みの機能を持っていて、日々の作業、
      ファイル管理やファイル名の展開、コマンドライン編集、
      コマンドマクロ、環境変数などに便利です。
      FreeBSD には <command>sh</command> (Bourne Shell) や
      <command>tcsh</command> (高機能 C-shell) が含まれています。
      また、
      これ以外にも <command>zsh</command> や <command>bash</command>
      などたくさんのシェルが FreeBSD Ports Collection から利用可能です。</para>

    <para>「あなたは、どのシェルを使いますか?」という質問は、
      まったく趣味の問題です。
      あなたが C のプログラマだったとすれば、
      <command>tcsh</command> のような C 風のシェルの方が落ち着くかもしれません。
      Linux から来た人や &unix; のコマンドラインインタフェイスになじみがなければ、
      <command>bash</command> を試すのも良いでしょう。
      ポイントは、それぞれのシェルは、
      あなたの好みの作業環境で利用できる (もしくはできない) 独自の機能を持っているということ、
      そして、どのシェルを使うことにするかを決めるのはあなた自身だということです。</para>

    <para>シェルの一般的な機能の一つに、ファイル名の補完があります。
      コマンドやファイル名の最初の数文字を与えて <keycap>Tab</keycap> キーを押すことで、
      シェルにコマンドやファイル名の残りの部分を自動的に補完させることができます。
      例をあげましょう。 二つのファイル
      <filename>foobar</filename>, <filename>foo.bar</filename> が
      あったとします。 ここで <filename>foo.bar</filename>
      の方を削除するには、
      <command>rm fo[Tab].[Tab]</command> と入力します。</para>
    <indexterm><primary>環境変数 (environment variables)</primary></indexterm>

    <para>するとシェルは <command>rm
      foo[BEEP].bar</command> と出力するでしょう。</para>

    <para>[BEEP] のところはコンソールのベル (訳注: 通常はビープ音が鳴ります) です。
      これは複数のファイルがマッチしたため、
      ファイル名の補完を完全に行なえなかったことを伝えています。
      <filename>foobar</filename> と
      <filename>foo.bar</filename> は
      両方とも <literal>fo</literal> ではじまるため、
      補完できるのは <literal>foo</literal> までです。
      ここで <literal>.</literal> を入力して <keycap>Tab</keycap> を押せば、
      シェルはファイル名の残りの部分を補完できます。</para>

    <para>もう一つあげられるシェルの特徴として、環境変数があります。
      環境変数とは、シェルの環境変数空間におけるキーと値とのペアです。
      この変数空間は、そのシェルから起動されたプログラムから参照でき、
      それを利用してプログラムの設定を保存するのに利用されます。
     下の表は、一般的な環境変数とその意味を示したものです。</para>

    <indexterm><primary>環境変数 (environment variables)</primary></indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>変数名</entry>
	    <entry>意味</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>現在のログインユーザのユーザ名。</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>コロンで区切られた実行ファイル探索のための
	      ディレクトリのリスト。</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>接続する X11 ディスプレイのネットワーク名 (存在する場合のみ)。</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>現在のシェル。</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>ユーザの端末種名。
              端末のケーパビリティを決定するのに使われる。</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>種々の端末の機能を実現する端末のエスケープコードの
	      データベースのエントリ。</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>オペレーティングシステムの種別。
              たとえば FreeBSD。</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>システムが動作している CPU のアーキテクチャ。</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>ユーザの選んだテキストエディタ。</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>ユーザの選んだテキストページャ。</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>コロンで区切られたマニュアルページ探索のための
	      ディレクトリのリスト。</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne シェル (Bourne shells)</primary></indexterm>

    <para>環境変数をセットする方法は、
      それぞれのシェルごとに多少異なります。
      たとえば、<command>tcsh</command> や <command>csh</command> 等の C シェルでは
      <command>setenv</command> を使います。
      <command>sh</command> や <command>bash</command> 等の Bourne シェルでは
      <command>set</command> と <command>export</command>
      を使います。
      たとえば <command>csh</command> か <command>tcsh</command> で
      <envar>EDITOR</envar> 環境変数の値を
      <filename>/usr/local/bin/emacs</filename> に
      セットするか変更するには、次のようにします。</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Bourne シェルでは次のようになります。</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>ほとんどのシェルでは、
      コマンドライン中の変数名の前に <literal>$</literal> 文字を置くことで、
      環境変数を展開させることができます。
      たとえば、
      <command>echo $TERM</command> は <envar>$TERM</envar> が
      セットされている内容を表示します。
      それはシェルが <envar>$TERM</envar> を展開して
      <command>echo</command> に渡しているからです。</para>

    <para>シェルはさまざまな特殊文字を、特別なデータを表すものとして扱います。
      その特殊文字はメタキャラクタと呼ばれます。
      もっとも一般的なものは <literal>*</literal> で、
      これはファイル名に含まれる、あらゆる文字を表します。
      これらの特殊なメタキャラクタはファイル名の展開に使われます。
      たとえば、<command>echo *</command> と入力すると
      <command>ls</command> と入力したのとほとんど同じ結果を得られます。
      これはシェルが <literal>*</literal> とマッチするすべてのファイルを
      受け取って <command>echo</command> のコマンドラインに渡し、表示するからです。</para>

    <para>これらの特殊文字をシェルに解釈させないようにするため、
      特殊文字の前にバックスラッシュ文字 (<literal>\</literal>)
      を置くことができます。
      <command>echo $TERM</command> は、
      あなたの端末が何にセットされているかを表示します。
      <command>echo \$TERM</command> は <envar>$TERM</envar> と
      そのまま表示します。</para>

    <sect2 xml:id="changing-shells">
      <title>シェルの変更</title>

      <para>シェルを変更する一番簡単な方法は <command>chsh</command>
	コマンドを使うことです。 <command>chsh</command> を実行すると
	環境変数 <envar>EDITOR</envar> で示されたエディタが立ち上がります。
	環境変数をセットしていなかった時は
        <command>vi</command> が立ち上がります。
	<quote>Shell:</quote> の行を適宜変更してください。</para>

      <para><command>chsh</command> に
        <option>-s</option> オプションをつけると、
        エディタを起動せずにシェルを変更することが可能です。
        たとえば、シェルを <command>bash</command> に変えたいなら、次のようにしてください。
      </para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>使おうと思っているシェルは<emphasis>必ず</emphasis>
	  <filename>/etc/shells</filename> 中に書かれているものでなければなりません。
	  シェルを <link linkend="ports">Ports Collection</link>
	  からインストールしていたのであれば、すでにそれは行なわれていますが、
	  手動でインストールした場合は、それを忘れずに行ってください。</para>

        <para>たとえば、<command>bash</command>
          を手動で
          <filename>/usr/local/bin</filename>
          にインストールした場合
          以下のようにする必要があります。</para>

        <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

        <para>そして <command>chsh</command> を実行してください。</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>テキストエディタ</title>

    <indexterm><primary>テキストエディタ</primary></indexterm>
    <indexterm><primary>エディタ</primary></indexterm>

    <para>さまざまな FreeBSD の設定は、テキストファイルを編集することで行われます。
      そのため、テキストエディタの扱いに慣れると良いでしょう。
      FreeBSD には、基本システムの一部として二、三提供されるものと、
      Ports Collection から利用できる、たくさんのテキストエディタが用意されています。
    </para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>最も学習が簡単なエディタは、
      easy editor の略で <application>ee</application> と呼ばれるものです。
      <application>ee</application> を立ち上げるには、コマンドラインから
      <command>ee <replaceable>filename</replaceable></command> と入力します。
      ここで <replaceable>filename</replaceable> は、
      編集しようとしているファイルの名前です。
      たとえば、<filename>/etc/rc.conf</filename> を編集するには
      <command>ee /etc/rc.conf</command> と入力します。
      一旦 <command>ee</command> の中に入れば、
      エディタの機能を操作するコマンドはすべてディスプレイの上部に
      表示されています。キャレット <literal>^</literal> 文字は
      キーボードの <keycap>Ctrl</keycap> キーを意味しますので、
      <literal>^e</literal> はキーのコンビネーション
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      を押すという意味になります。
      <application>ee</application> を終了するには <keycap>Esc</keycap> キーを押し、
      そして leave editor を選びます。
      ファイルが更新されていたときは、
      エディタは変更をセーブするかどうかプロンプトを出します。</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>エディタ</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
     <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>エディタ</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD には、基本システムの一部として
      <application>vi</application>、
      一方 <application>Emacs</application> や <application>vim</application>
      といった他のエディタは Ports Collection の一部として、
      より強力なテキストエディタが用意されています
      (<filename role="package">editors/emacs</filename>, <filename role="package">editors/vim</filename>)。
      これらのエディタはやや学習が複雑ですが、より強力で高い機能性を提供します。
      しかし、あなたが多量のテキストを編集することを考えているなら、
      <application>vim</application> や <application>Emacs</application>
      といった強力なエディタを習得することは、
      より多くの時間を節約することでしょう。</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>デバイスとデバイスノード</title>

    <para>デバイスとはシステム上のハードウェアに関するものに対してよく使われる用語で、
      ディスクやプリンタ、グラフィックカードやキーボードが含まれます。
      FreeBSD が起動するとき、FreeBSD
      が表示しているものの大部分は検出されたデバイスです。
      <filename>/var/run/dmesg.boot</filename>
      を眺めれば起動メッセージを読み直すことができます。</para>

    <para>例えば、<filename>acd0</filename> は最初の
      IDE CDROM ドライブで、<filename>kbd0</filename>
      はキーボードを表します。</para>

    <para>&unix; オペレーティングシステムにおけるデバイスのほとんどは、
      デバイスノードと呼ばれる <filename>/dev</filename>
      ディレクトリにあるスペシャルファイルを通してアクセスしなければなりません。</para>

    <sect2>
      <title>デバイスノードを作成する</title>
      <para>新しいデバイスをシステムにつけ足したり、
        追加デバイスのサポートをコンパイルして加えたりするときは、
	デバイスノードを作成しなければなりません。</para>

      <sect3>
	<title><literal>DEVFS</literal> (デバイスファイルシステム: Device File System)</title>

	<para>デバイスファイルシステム <literal>DEVFS</literal> は、
	  グローバルファイルシステム名前空間の中のカーネルデバイス名前空間へのアクセスを提供します。
	  デバイスノードを作成したり変更したりするのではなく、
	  <literal>DEVFS</literal> がこの特別なファイルシステムを管理するのです。</para>

	<para>詳しくは &man.devfs.5; マニュアルページをご覧ください。</para>

      </sect3>
    </sect2>
  </sect1>

<!--
  <sect1 id="binary-formats">
    <title>Binary Formats</title>

    <para>To understand why &os; uses the &man.elf.5;
      format, you must first know a little about the 3 currently
      <quote>dominant</quote> executable formats for &unix;:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>The oldest and <quote>classic</quote> &unix; object
          format.  It uses a short and compact header with a magic
          number at the beginning that is often used to characterize
          the format (see &man.a.out.5; for more details).  It
          contains three loaded segments: .text, .data, and .bss plus
          a symbol table and a string table.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>The SVR3 object format.  The header now comprises a
          section table, so you can have more than just .text, .data,
          and .bss sections.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>The successor to <acronym>COFF</acronym>, featuring
          multiple sections and 32-bit or 64-bit possible values.  One
          major drawback: <acronym>ELF</acronym> was also designed
          with the assumption that there would be only one ABI per
          system architecture.  That assumption is actually quite
          incorrect, and not even in the commercial SYSV world (which
          has at least three ABIs: SVR4, Solaris, SCO) does it hold
          true.</para>

        <para>FreeBSD tries to work around this problem somewhat by
          providing a utility for <emphasis>branding</emphasis> a
          known <acronym>ELF</acronym> executable with information
          about the ABI it is compliant with.  See the manual page for
          &man.brandelf.1; for more information.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD comes from the <quote>classic</quote> camp and used
      the &man.a.out.5; format, a technology tried and proven through
      many generations of BSD releases, until the beginning of the 3.X
      branch. Though it was possible to build and run native
      <acronym>ELF</acronym> binaries (and kernels) on a FreeBSD
      system for some time before that, FreeBSD initially resisted the
      <quote>push</quote> to switch to <acronym>ELF</acronym> as the
      default format. Why?  Well, when the Linux camp made their
      painful transition to <acronym>ELF</acronym>, it was not so much
      to flee the <filename>a.out</filename> executable format as it
      was their inflexible jump-table based shared library mechanism,
      which made the construction of shared libraries very difficult
      for vendors and developers alike. Since the
      <acronym>ELF</acronym> tools available offered a solution to the
      shared library problem and were generally seen as <quote>the way
      forward</quote> anyway, the migration cost was accepted as
      necessary and the transition made.  FreeBSD's shared library
      mechanism is based more closely on Sun's
      &sunos; style shared library mechanism
      and, as such, is very easy to use.</para>

    <para>So, why are there so many different formats?</para>

    <para>Back in the dim, dark past, there was simple hardware.  This
      simple hardware supported a simple, small system. <filename>a.out</filename> was
      completely adequate for the job of representing binaries on this
      simple system (a PDP-11). As people ported &unix; from this simple
      system, they retained the <filename>a.out</filename> format because it was sufficient
      for the early ports of &unix; to architectures like the Motorola
      68k, VAXen, etc.</para>

    <para>Then some bright hardware engineer decided that if he could
      force software to do some sleazy tricks, then he would be able
      to shave a few gates off the design and allow his CPU core to
      run faster. While it was made to work with this new kind of
      hardware (known these days as <acronym>RISC</acronym>), <filename>a.out</filename>
      was ill-suited for this hardware, so many formats were developed
      to get to a better performance from this hardware than the
      limited, simple <filename>a.out</filename> format could
      offer. Things like <acronym>COFF</acronym>,
      <acronym>ECOFF</acronym>, and a few obscure others were invented
      and their limitations explored before things seemed to settle on
      <acronym>ELF</acronym>.</para>

    <para>In addition, program sizes were getting huge and disks (and
      physical memory) were still relatively small so the concept of a
      shared library was born. The VM system also became more
      sophisticated. While each one of these advancements was done
      using the <filename>a.out</filename> format, its usefulness was
      stretched more and more with each new feature.  In addition,
      people wanted to dynamically load things at run time, or to junk
      parts of their program after the init code had run to save in
      core memory and swap space. Languages became more sophisticated
      and people wanted code called before main automatically. Lots of
      hacks were done to the <filename>a.out</filename> format to
      allow all of these things to happen, and they basically worked
      for a time. In time, <filename>a.out</filename> was not up to
      handling all these problems without an ever increasing overhead
      in code and complexity. While <acronym>ELF</acronym> solved many
      of these problems, it would be painful to switch from the system
      that basically worked. So <acronym>ELF</acronym> had to wait
      until it was more painful to remain with
      <filename>a.out</filename> than it was to migrate to
      <acronym>ELF</acronym>.</para>

    <para>However, as time passed, the build tools that FreeBSD
      derived their build tools from (the assembler and loader
      especially) evolved in two parallel trees. The FreeBSD tree
      added shared libraries and fixed some bugs. The GNU folks that
      originally write these programs rewrote them and added simpler
      support for building cross compilers, plugging in different
      formats at will, and so on. Since many people wanted to build cross
      compilers targeting FreeBSD, they were out of luck since the
      older sources that FreeBSD had for <application>as</application> and <application>ld</application> were not up to the
      task. The new GNU tools chain (<application>binutils</application>) does support cross
      compiling, <acronym>ELF</acronym>, shared libraries, C++
      extensions, etc. In addition, many vendors are releasing
      <acronym>ELF</acronym> binaries, and it is a good thing for
      FreeBSD to run them.</para>

    <para><acronym>ELF</acronym> is more expressive than <filename>a.out</filename> and
      allows more extensibility in the base system. The
      <acronym>ELF</acronym> tools are better maintained, and offer
      cross compilation support, which is important to many people.
      <acronym>ELF</acronym> may be a little slower than <filename>a.out</filename>, but
      trying to measure it can be difficult. There are also numerous
      details that are different between the two in how they map
      pages, handle init code, etc. None of these are very important,
      but they are differences. In time support for
      <filename>a.out</filename> will be moved out of the <filename>GENERIC</filename>
      kernel, and eventually removed from the kernel once the need to
      run legacy <filename>a.out</filename> programs is past.</para>
  </sect1>
-->

  <sect1 xml:id="basics-more-information">
    <title>さらに詳しい情報を得るには...</title>

    <sect2 xml:id="basics-man">
      <title>オンラインマニュアル</title>

      <indexterm><primary>マニュアルページ</primary></indexterm>

      <para>FreeBSD についてのもっとも包括的な文書は、
        マニュアルページの形式になっているものです。
        FreeBSD システム上のほとんどすべてのプログラムには、
        基本的な操作方法とさまざまな引数を説明しているリファレンスマニュアルが添付されています。
        これらのマニュアルは <command>man</command> コマンドで見ることができます。<command>man</command>
        コマンドの使い方は簡単です。</para>

      <screen>&prompt.user; <userinput>man コマンド名</userinput></screen>

      <para><literal>コマンド名</literal>
        のところには、知りたいコマンドの名前を入れます。
        たとえば <command>ls</command> コマンドについて知りたい場合には、
        次のように入力します。</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>オンラインマニュアルは、
        セクション番号で分類されています。</para>

      <orderedlist>
        <listitem>
          <para>ユーザコマンド</para>
        </listitem>

        <listitem>
          <para>システムコールとエラー番号</para>
        </listitem>

        <listitem>
          <para>C のライブラリ関数</para>
        </listitem>

        <listitem>
          <para>デバイスドライバ</para>
        </listitem>

        <listitem>
          <para>ファイル形式</para>
        </listitem>

        <listitem>
          <para>ゲームや娯楽</para>
        </listitem>

        <listitem>
          <para>さまざまな情報</para>
        </listitem>

        <listitem>
          <para>システムの管理と操作のためのコマンド</para>
        </listitem>

        <listitem>
          <para>カーネル開発者のための情報</para>
        </listitem>
      </orderedlist>

      <para>時折、
        同じトピックがオンラインマニュアルの複数のセクションに記載されている場合があります。
        たとえば、<command>chmod</command> ユーザコマンドと
        <function>chmod()</function>
        システムコールの場合がそれに該当します。
        この場合、<command>man</command> コマンドにセクション番号を与えることで、
        どちらを参照したいかを指定することができます。</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>上のようにすれば、
        ユーザコマンド <command>chmod</command>
        のマニュアルページが表示されます。
        オンラインマニュアルの特定セクションへの参照は、
        慣習的に書かれている文書で括弧の中に示されます。
        すなわち、&man.chmod.1; は <command>chmod</command>
        ユーザコマンドを、&man.chmod.2;
        はシステムコールの方を示しています。</para>

      <para>コマンドの名前を知っていて、
        単純にその使い方を知りたい場合はここまでの説明で十分でしょう。
        しかし、
        もしコマンドの名前を思い出せない場合にはどうしたら良いのでしょうか?
        <command>man</command> に <option>-k</option> スイッチをつければ、
        コマンド解説 (description) の文章から、
        指定したキーワードを検索することができます。</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>このコマンドにより、
        <quote>mail</quote>
        というキーワードをコマンド解説に含むコマンドの一覧が表示されます。
        実際には、これは <command>apropos</command> コマンドを使う場合と同等の機能です。</para>

      <para>それでは、<filename>/usr/bin</filename>
        にあるさまざまなコマンドすべてを見ていて、
        それらが実際にどう働くのかが、まったく見当もつかないときには
        どうしたら良いでしょう?
        そのときは単純に、</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>とするか、あるいは同じ働きをする</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

      <para>としてください。</para>
    </sect2>

    <sect2 xml:id="basics-info">
      <title>GNU の Info ファイル</title>

      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD には Free Software Foundation (FSF)
        によるアプリケーションや
        ユーティリティがたくさん含まれています。
        これらのプログラムには、マニュアルページに加えて
        <literal>info</literal> ファイルと呼ばれる
        ハイパーテキスト形式の文書が付属しています。
        この文書は <command>info</command> コマンド、
        あるいは <application>emacs</application> をインストールしているなら
        <application>emacs</application> の info
        モードで読むことができます。</para>

      <para>&man.info.1; コマンドを使うには、単に次のように入力します。</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>
        <literal>h</literal> と入力すると、
        簡単な手引きを読むことができます。
        クイックコマンドリファレンスは <literal>?</literal>
        を入力してください。</para>
    </sect2>
  </sect1>
</chapter>
