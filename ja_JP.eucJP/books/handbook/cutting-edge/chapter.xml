<?xml version="1.0" encoding="euc-jp"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r54686
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="updating-upgrading">

  <info>
    <title>&os; のアップデートとアップグレード</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jim</firstname>
	  <surname>Mock</surname>
	</personname>
	<contrib>再構成、再編成および改訂: </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jordan</firstname>
	  <surname>Hubbard</surname>
	</personname>
	<contrib>原作: </contrib>
      </author>

      <author>
	<personname>
	  <firstname>Poul-Henning</firstname>
	  <surname>Kamp</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>John</firstname>
	  <surname>Polstra</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	</personname>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>この章では</title>

    <para>あるリリースから次のリリースまでの期間にも、
      &os; の開発は休みなく続けられています。
      最新の開発ツリーと同期することを好む人がいれば、
      公式のリリース版を好んで使う方もいるでしょう。
      しかしながら、公式のリリースといえども、
      セキュリティや他の重要な修正のため、時にはアップデートを行う必要があります。
      使用しているバージョンに関わらず、&os;
      は手元のシステムを最新の開発ツリーと同期するために必要なツールをすべて用意しているので、
      これらのツールを使ってバージョンのアップグレードを簡単に行うことができます。
      この章では、開発ブランチを追いかける方法、および、&os;
      システムをアップデートする基本的なツールについて解説します。</para>

    <para>この章を読んで分かるのは:</para>

    <itemizedlist>
      <listitem>
	<para><application>freebsd-update</application> もしくは
	  <application>Subversion</application> 
	  を使った &os; システムの更新方法</para>
      </listitem>

      <listitem>
	<para>インストールされているシステムと、変更が行われていない状態との比較方法。</para>
      </listitem>

      <listitem>
	<para><application>Subversion</application>
	  またはドキュメント用の ports<!-- and
	  <application>Docsnap</application>--> を使って、
	  インストールされているドキュメントを最新版にアップデートする方法。</para>
      </listitem>

      <listitem>
	<para>2 つの開発ブランチ、&os.stable; と &os.current; の違い</para>
      </listitem>

      <listitem>
	<para>ベースシステム全体を再構築しインストールする方法</para>
      </listitem>

    </itemizedlist>

    <para>この章を読む前に、以下の準備をしましょう。</para>

    <itemizedlist>
      <listitem>
	<para>ネットワーク接続の適切な設定
	  (<xref linkend="advanced-networking"/>)</para>
      </listitem>
      <listitem><para>サードパーティ製のソフトウェアのインストール方法の習得
        (<xref linkend="ports"/>)</para></listitem>
    </itemizedlist>

    <note>
      <para>この章を通じて、
	&os; のソースコードをダウンロードしたりアップデートするのに
	<command>svnlite</command> が用いられます。
	必要に応じて <package>devel/subversion</package> port または package
	が使われることもあります。</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info>
      <title>&os; Update</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Colin</firstname>
	    <surname>Percival</surname>
	  </personname>
	  <contrib>ベースとなったノートの提供: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Updating and Upgrading</primary>
    </indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>すみやかにセキュリティパッチを適用し、
      オペレーティングシステムをアップグレードして、
      最新のリリースに保つことは、システム管理における重要な側面です。
      これらの処理を行うために &os; には <command>freebsd-update</command>
      と呼ばれるユーティリティが用意されています。</para>

    <para>このユーティリティを用いると、&os; のセキュリティおよび
      eratta アップデートをバイナリによって行うことができます。
      手動でパッチもしくは新しいカーネルをコンパイルし、
      インストールする必要はありません。
      バイナリアップデートは、
      セキュリティチームがサポートしているすべてのアーキテクチャとリリースで利用できます。
      <uri xlink:href="https://www.FreeBSD.org/ja/security/">https://www.FreeBSD.org/ja/security/</uri> には、
      サポートが行われているリリースや保守終了予定日の一覧があります。</para>

    <para>このユーティリティは、マイナーリリースであったり、
      他のリリースブランチへのアップグレードにも対応しています。
      新しいリリースにアップデートする前に、
      アップデートしようとしているリリースのアナウンスに目を通し、
      重要な情報がないかどうかを確認してください。
      リリースのアナウンスは <uri
	xlink:href="https://www.FreeBSD.org/ja/releases/">https://www.FreeBSD.org/ja/releases/</uri>
      で確認できます。</para>

    <note>
      <para>もし <command>crontab</command> の中に
	&man.freebsd-update.8; の機能が含まれていたら、
	オペレーティングシステムのアップグレード作業を終えるまでは無効にしてください。</para>
    </note>

    <para>この節では、<command>freebsd-update</command>
      で使われる設定ファイルの説明、
      セキュリティパッチの適応方法のデモンストレーション、
      オペレーティングシステムをアップグレードする際に考慮すべき点について説明します。</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>設定ファイル</title>

      <para><command>freebsd-update</command> のデフォルトの設定ファイルは、
	そのままでも用いることができます。      
	<filename>/etc/freebsd-update.conf</filename>
	の設定をデフォルトからきめ細かく調整して、
	アップデートプロセスを制御するユーザもいます。
	利用可能なオプションについてはこのファイルのコメントで説明されていますが、
	以下の項目については補足が必要でしょう。</para>

      <programlisting># Components of the base system which should be kept updated.
Components world kernel</programlisting>

      <para>このパラメータは、&os; のどの部分を最新に維持するかを設定します。
	デフォルトでは、ベースシステム全体、
	そしてカーネルをアップデートします。
	<literal>src/base</literal> や <literal>src/sys</literal>
	のように、個々の項目を指定することもできます。
	この部分についてはデフォルトのままにしておき、
	アップデートする項目をユーザがリストに加える形にするのがベストでしょう。
	ソースコードとバイナリが同期していないと、
	長い年月の間に悲惨な結果がもたらされる可能性があります。</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</programlisting>

      <para><filename>/bin</filename> や <filename>/sbin</filename>
	等の特定のディレクトリをアップデートで変更しないように、
	これらのパスを追加してください。
	このオプションは、ローカルの変更点を <command>freebsd-update</command>
	が上書きすることを防ぐ目的にも利用できます。</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>このオプションは、指定したディレクトリにある設定ファイルを、
	ローカルで変更されていない場合のみアップデートします。
	ユーザがこれらのファイルを変更していると、
	変更されたファイルの自動アップデートは行われません。
	他に、<literal>KeepModifiedMetadata</literal>
	という別のオプションが存在します。
	このオプションは、<command>freebsd-update</command>
	がマージ中に変更点を保存するようにします。</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</programlisting>

      <para><command>freebsd-update</command>
	がマージすべきファイルが存在するディレクトリの一覧です。
	ファイルのマージのプロセスは、
	&man.mergemaster.8; と同様 &man.diff.1; パッチの連続ですが、
	選択肢は少なく、マージを承認するか、エディタを起動するか、
	<command>freebsd-update</command>
	を中断するかどうかを選んでください。
	もし、心配な点があれば、
	<filename>/etc</filename>
	をバックアップしてからマージを承認してください。
	<command>mergemaster</command> の詳細な情報については、
	&man.mergemaster.8; で確認してください。</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>ここではすべてのパッチや一次ファイルを置くディレクトリを指定しています。
	バージョンをアップグレードするのであれば、
	この場所には少なくともギガバイトの空き容量が必要です。</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>このオプションを <literal>yes</literal> に設定すると、
	<command>freebsd-update</command> は
	<literal>Components</literal> のリストが完全に正しいと判断し、
	このリスト以外の変更点については取り扱いません。
	<command>freebsd-update</command> は、効率的に
	<literal>Components</literal>
	リストに属するファイルをアップデートします。</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>セキュリティパッチの適用</title>

      <para>&os; のセキュリティパッチを適用する過程は簡単になりました。
	管理者は <command>freebsd-update</command> を使うことで、
	システムを完全にパッチがあたった状態に保つ事ができます。
	&os; セキュリティ勧告の詳細については、
	<link xlink:href="&url.books.handbook.en;/security-advisories.html">&os; セキュリティ勧告</link>
	<!-- <xref linkend="security-advisories"/> -->
	の節で説明されています。</para>

      <para>以下のコマンドを実行すると、&os;
	のセキュリティパッチがダウンロードされ、インストールされます。
	最初のコマンドは、未対応のパッチがあるかどうかを調べます。
	もし未対応のパッチがある場合には、
	パッチが当てられた際に変更されるファイルのリストが作成されます。
	2 番目のコマンドはパッチを適用します。</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>アップデートによってカーネルにパッチが当たった場合には、
	パッチが当たったカーネルで起動するように、
	システムを再起動する必要があります。
	もし、実行中のバイナリにパッチが当てられた場合には、
	パッチの当てられたバージョンのバイナリが使われるように、
	影響のあるアプリケーションを再起動する必要があります。</para>

      <note>
	<para>通常、ユーザはシステムを再起動する必要があります。
	  カーネルアップデートで再起動が必要かどうかを知るには、
	  <command>freebsd-version -k</command> と
	  <command>uname -r</command> を実行してください。
	  これら 2 つのコマンドの結果が異なる場合には、
	  再起動が必要です。</para>
      </note>

      <para>毎日一度アップデートがないかどうかを自動的に確認するように設定するには、
	以下のエントリを <filename>/etc/crontab</filename>
	に追加してください。</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>パッチが存在すると、
	自動的にダウンロードされますが、適用はされません。
	<systemitem class="username">root</systemitem>宛てにメールで、
	ダウンロードされたパッチを確認し、
	<command>freebsd-update install</command>
	とともに手動でインストールする必要のあることが通知されます。</para>

      <para>うまく行かなかった場合には、<command>freebsd-update</command>
	を以下のように実行すると、最後の変更までロールバックできます。</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput>
Uninstalling updates... done.</screen>

      <para>カーネルまたはカーネルモジュールがアップデートされた場合には、
	完了後にもう一度システムを再起動して、
	影響のあったバイナリを再起動してください。</para>

      <para><command>freebsd-update</command>
	ユーティリティが自動的にアップデートするカーネルは
	<filename>GENERIC</filename> のみです。
	カスタムカーネルをインストールしている場合には、
	<command>freebsd-update</command> によりインストールした後、
	カーネルを再構築し、もう一度インストールする必要があります。
	デフォルトのカーネルの名前は <emphasis>GENERIC</emphasis> です。
	&man.uname.1;
	コマンドを使ってインストールされているかどうかを確認できます。</para>

      <note>
	<para><filename>GENERIC</filename> カーネルを、
	  常に <filename>/boot/GENERIC</filename> に置いておいてください。
	  さまざまな問題を解決する際や、
	  バージョンをアップグレードする際に助けとなります。
	  <filename>GENERIC</filename> カーネルを用意する方法については、
	  <xref linkend="freebsd-update-custom-kernel-9x"/>
	  を参照してください。</para>
      </note>

      <para><filename>/etc/freebsd-update.conf</filename>
	のデフォルトの設定を変更しない限り、
	<command>freebsd-update</command> は、
	他の更新と共にカーネルソースをアップデートします。
	新しいカスタムカーネルの再構築と再インストールは、
	通常通り行うことができます。</para>

      <para><command>freebsd-update</command> は、
	常にカーネルをアップデートするとは限りません。
	<command>freebsd-update install</command>
	によってカーネルソースが変更されなかった場合には、
	カスタムカーネルを再構築する必要はありません。
	しかしながら <command>freebsd-update</command> は、
	<filename>/usr/src/sys/conf/newvers.sh</filename>
	を常にアップデートします。
	これは、現在のシステムのパッチレベルを
	<command>uname -r</command> が <literal>-p</literal>
	で表示する時にこのファイルが参照されます。
	そのため、何も変更されていない場合でも、
	カスタムカーネルを再構築することにより、
	<command>uname</command> がシステムの正確なパッチレベルを報告するようになります。
	各システムにインストールされているアップデートをすばやく把握できるようになるので、
	特に複数のシステムを管理するときに助けとなります。</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>メジャーおよびマイナーバージョンのアップグレードを行う</title>

      <para>&os; のマイナーバージョン間のアップグレード、
	たとえば、&os;&nbsp;9.0 から &os;&nbsp;9.1 へのアップグレードは、
	<emphasis>マイナーバージョン</emphasis> アップグレードと呼ばれます。
	<emphasis>メジャーバージョン</emphasis> アップグレードは、
	&os;&nbsp;9.X から &os;&nbsp;10.X へのアップグレードといった、
	&os; のメジャーバージョンが変わるようなアップグレードのことです。
	どちらもアップグレードも、<command>freebsd-update</command>
	にリリース番号のターゲットを指定する事で実行できます。</para>

      <note>
	<para>カスタムカーネルを使っているシステムでは、
	  アップグレードを行う前に
	  <filename>GENERIC</filename> カーネルが、
	  <filename>/boot/GENERIC</filename>
	  に置かれている事を確認してください。
	  <filename>GENERIC</filename> カーネルを用意する方法については、
	  <xref linkend="freebsd-update-custom-kernel-9x"/>
	  を参照してください。</para>
      </note>

      <para>以下のコマンドを実行すると、&os;&nbsp;9.0
	のシステムを &os;&nbsp;9.1 にアップグレードします。</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

      <para>コマンドを実行すると、<command>freebsd-update</command>
	は設定ファイルと現在のシステムを評価し、
	アップデートするために必要な情報を収集します。
	画面には、どのコンポーネントが認識され、
	どのコンポーネントが認識されていないといったリストが表示されます。
	たとえば以下のように表示されます。</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? <userinput>y</userinput></screen>

      <para>ここで、<command>freebsd-update</command>
	はアップグレードに必要なすべてのファイルをダウンロードします。
	何をインストールし、どのように進むかといった質問をされることもあります。</para>

      <para>カスタムカーネルを使っていると、
	上記のステップで以下のような警告が表示されます。</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>この時点ではこの警告を無視してもかまいません。
	アップデートされた <filename>GENERIC</filename> カーネルは、
	アップグレードプロセスの途中で利用されます。</para>

      <para>すべてのパッチがローカルシステムへダウンロードされたら、
	次にパッチが適用されます。
	このプロセスには時間がかかります。
	この時間はコンピュータの性能とワークロードに依存します。
	その後、設定ファイルがマージされます。
	このプロセスでは、ユーザはファイルをマージするか、
	画面上にエディタを立ち上げて手動でマージするかを尋ねられます。
	プロセスが進むごとに、成功したマージのすべての結果の情報がユーザに示されます。
	マージに失敗したり、無視した場合には、プロセスが中断します。
	ユーザによっては <filename>/etc</filename>
	のバックアップを取り、
	<filename>master.passwd</filename> や <filename>group</filename>
	のような重要なファイルを後で手動でマージする方もいます。</para>

      <note>
	<para>すべてのパッチは別のディレクトリでマージされており、
	  まだ、システムには反映されていません。
	  すべてのパッチが正しく適用され、
	  すべての設定ファイルがマージされてプロセスがスムーズに進んだら、
	  ユーザは以下のコマンドを用いて、
	  変更点をディスクに反映してください。</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      </note>

      <para>パッチは最初にカーネルとカーネルモジュールに対して当てられます。
	システムがカスタムカーネルを実行している場合には、
	&man.nextboot.8; を使って次回の再起動時のカーネルを、
	アップデートされた <filename>/boot/GENERIC</filename>
	に設定してください。</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para><filename>GENERIC</filename> カーネルで再起動する前に、
	  カーネルにシステムが適切に起動するために必要なすべてのドライバが含まれていること、
	  もしアップデートしているコンピュータがリモートでアクセスしているのであれば、
	  ネットワーク接続に必要なすべてのドライバも含まれていることを確認してください。
	  特に、これまで実行しているカスタムカーネルが、
	  カーネルモジュールとして提供されているビルドインの機能を含んでいるのであれば、
	  これらのモジュールを一時的に <filename>/boot/loader.conf</filename>
	  の機能を用いて、
	  <filename>GENERIC</filename> に読み込んでください。
	  アップグレードプロセスが終わるまでは、
	  重要ではないサービスを無効にするとともに、
	  必要のないディスクやネットワークのマウントなども避けることが推奨されています。</para>
      </warning>

      <para>アップデートされたカーネルでコンピュータを再起動してください。</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>システムがオンラインに戻ったら、以下のコマンドを使って
	<command>freebsd-update</command> を再び実行してください。
	アップデートプロセスの状態は保存されているので、
	<command>freebsd-update</command> を実行すると、
	最初からではなく、次のステップに進み、
	古い共有ライブラリとオブジェクトファイルを削除します。</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>使用しているライブラリのバージョン番号の付けられ方によって、
	  3 つのインストールフェーズが 2 つになる場合もあります。</para>
      </note>

      <para>アップグレードはこれで終了です。
	もしメジャーアップグレードを行った場合には、
	<xref linkend="freebsdupdate-portsrebuild"/>
	で説明されているようにすべての ports および package
	を再構築してください。</para>

      <sect3 xml:id="freebsd-update-custom-kernel-9x">
	<title>&os;&nbsp;9.X 以降のシステムにおけるカスタムカーネル</title>

	<para><command>freebsd-update</command> を使う前に、
	  <filename>GENERIC</filename> カーネルが
	  <filename>/boot/GENERIC</filename>
	  に置かれていることを確認してください。
	  ただ一度だけカスタムカーネルを構築したのであれば、
	  <filename>/boot/kernel.old</filename>
	  は <filename>GENERIC</filename> カーネルそのものです。
	  このディレクトリの名前を
	  <filename>/boot/GENERIC</filename>
	  へと変更してください。</para>

	<para>もし、2 回以上カスタムカーネルを構築した後であったり、
	  カスタムカーネルを構築した回数がわからなければ、
	  現在のオペレーティングシステムのバージョンの
	  <filename>GENERIC</filename> カーネルを入手してください。
	  コンピュータへの物理的なアクセスが可能であれば、
	  インストールメディアから <filename>GENERIC</filename>
	  カーネルをインストールできます。</para>

	<screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>

	<para>別な方法としては、
	  <filename>GENERIC</filename> カーネルをソースから再構築して、
	  インストールしてください。</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

	<para><command>freebsd-update</command> がこのカーネルを
	  <filename>GENERIC</filename> カーネルとして認識するために、
	  <filename>GENERIC</filename> コンフィグレーションファイルは、
	  とにかく変更してはいけません。
	  また、特別なオプションを指定しないで構築してください。</para>

	<para><command>freebsd-update</command> は、
	  <filename>/boot/GENERIC</filename>
	  が存在する事だけを必要とするので、
	  <filename>GENERIC</filename>
	  カーネルで再起動する必要はありません。</para>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>メジャーバージョンアップグレード後の
	  package のアップグレード</title>

	<para>一般的に、マイナーバージョンアップグレードの後では、
	  インストールされているアプリケーションは、問題なく動作するでしょう。
	  メジャーバージョンが異なるとアプリケーションバイナリーインタフェース
	  (<acronym>ABI</acronym>) が異なるため、
	  サードパーティ製のアプリケーションの多くは動作しなくなるでしょう。
	  メジャーバージョンアップグレード後には、
	  インストールされているすべての packages, ports
	  をアップグレードする必要があります。
	  package は、<command>pkg upgrade</command>
	  を使ってアップグレードできます。
	  インストールされている ports をアップグレードする場合には、
	  <package>ports-mgmt/portmaster</package>
	  といったユーティリティを使ってください。</para>

	<para>すべての package の強制的なアップグレードでは、
	  バージョン番号が上がらない package に対しても、
	  リポジトリから最新のバージョンで、インストールされている
	  package を置き換えます。
	  &os; のメージャーバージョンが変わるようなアップグレードでは、
	  ABI のバージョンも変わるため、
	  このようなアップグレードが必要になります。
	  強制的なアップグレードを行うには、以下のように実行してください。</para>

	<screen>&prompt.root; <userinput>pkg-static upgrade -f</userinput></screen>

	<para>インストールされているすべてのアプリケーションを再構築するには、
	  以下のコマンドを実行してください。</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para>このコマンドを実行すると、
	  設定を変更するオプションを持つアプリケーションは、
	  設定変更のスクリーンを表示し、
	  ユーザからの指示待ちの状態で停止します。
	  この振る舞いをやめ、デフォルトのオプションを使用するには、
	  上記のコマンドに <option>-G</option> を含めてください。</para>

	<para>ソフトウェアのアップグレードが終わったら、最後にもう一度
	  <command>freebsd-update</command>
	  を実行して、
	  すべてのアップグレードプロセスのやり残し作業を行い、
	  アップグレードのプロセスを完了してください。</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<para><filename>GENERIC</filename>
	  カーネルを一時的に読み込んでいたのであれば、<xref
	    linkend="kernelconfig"/> に書かれている手順に従って、
	  新しいカスタムを構築し、インストールしてください。</para>

	<para>コンピュータを再起動し、新しい &os; を立ち上げてください。
	  これでアップグレードのプロセスは完了です。</para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>システムの状態の比較</title>

      <para><command>freebsd-update</command> を用いて、
	インストールされている &os; の状態と、
	正しく動作することが分かっている状態とを比較できます。
	このコマンドは、現在のシステムのユーティリティ、ライブラリ、
	設定ファイルを評価するので、
	組み込みの侵入検知システム (<acronym>IDS</acronym>)
	として使うことができます。</para>

      <warning>
	<para>このコマンドは、<package>security/snort</package>
	  のような本当の <acronym>IDS</acronym>
	  の置き換えになるものではありません。
	  <command>freebsd-update</command> はデータをディスクに保存するので、
	  不正な変更が行われる可能性があります。
	  <varname>kern.securelevel</varname> と、
	  <command>freebsd-update</command> のデータを使用しないときに、
	  読み取りのみの許可属性に設定されているファイルシステムに置くことで、
	  不正な変更の可能性を低くできますが、
	  よりよい解決方法は、
	  <acronym>DVD</acronym>
	  または安全に保存されている外部 <acronym>USB</acronym>
	  ディスクのような安全なディスクとシステムを比較することです。
	  組み込まれているユーティリティを用いた、別の方法による
	  <acronym>IDS</acronym> 機能については、
	  <link xlink:href="&url.books.handbook.en;/security-intro.html#security-ids">&os; バイナリによる検出</link>
	  <!-- <xref linkend="security-ids"/> -->
	  の節をご覧ください。</para>
      </warning>

      <para>比較を行うには、
	結果の出力先のファイル名を指定してください。</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <para>システムは検査され、リリースファイルの <acronym>SHA256</acronym>
	ハッシュ値と現在インストールされているファイルのハッシュ値がファイルの一覧と共に、
	指定した出力先のファイルに送られます。</para>

      <para>これらの行は極めて長いのですが、出力形式は簡単にすぐに解析できます。
	たとえば、これらのリリースで異なっているすべてのファイルを知りたいのであれば、
	以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>上の表示例では出力は切り捨てられており、
	実際にはもっと多くのファイルが存在します。
	これらのファイルには、運用中に変更されるファイルがあります。
	たとえば、<filename>/etc/passwd</filename>
	はユーザがシステムに追加されると変更されます。
	また、カーネルモジュールは、
	<command>freebsd-update</command>
	によりアップデートされるため、変更されます。
	このような特別なファイルやディレクトリを除外するには、
	それらを <filename>/etc/freebsd-update.conf</filename> の
	<literal>IDSIgnorePaths</literal> オプションに追加してください。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <title>ドキュメントのアップデート</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>ドキュメントは、&os; オペレーティングシステムの必須要素です。
      &os; ドキュメントの最新バージョンは、&os; ウェブサイト (<link
	xlink:href="&url.base;/doc/">https://www.freebsd.org/doc/</link>)
      から入手できますが、
      &os; ウェブサイト、ハンドブック、<acronym>FAQ</acronym>
      および文書の最新版をローカルに用意しておくと便利です。</para>

    <para>この章では、ソースまたは Ports Collection を使って、
      ローカルの &os; ドキュメントを最新に保つ方法を説明します。</para>

    <para>ドキュメントを編集したり、
      ドキュメントの誤りを報告する方法については、
      新しい貢献者のための &os; ドキュメンテーションプロジェクト入門 (<link
	xlink:href="&url.books.fdp-primer.en;">https://www.freebsd.org/doc/en_US.ISO8859-1/books/fdp-primer/</link>)
      をご覧ください。</para>

    <sect2 xml:id="updating-installed-documentation">
      <title>ソースから &os; ドキュメントをインストールする</title>

      <para>ソースから &os; ドキュメントを構築するのに必要なツールは、
	&os; のベースシステムには含まれていません。
	必要なツールは、&os; ドキュメンテーションプロジェクトが開発している
	<package>textproc/docproj</package> package または port 
	からインストールできます。</para>

      <para>インストールしたら、<application>svnlite</application>
	を使って、ドキュメントのソースをダウンロードしてください。</para>

      <screen>&prompt.root; <userinput>svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc</userinput></screen>

      <para>最初にドキュメントのソースをダウンロードするには少し時間がかかります。
	ダウンロードが終わるまでお待ちください。</para>

      <para>ダウンロードしたドキュメントのソースをアップデートするには、
	以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>svnlite update /usr/doc</userinput></screen>

      <para>最新のドキュメントのソースのスナップショットを
	<filename>/usr/doc</filename> に用意できたら、
	インストールされているドキュメントをアップデートする準備はすべて整いました。</para>

      <para>利用可能なすべての言語のドキュメントをアップデートするには、
	以下のように入力してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>もし、ある特定の言語のみをアップデートしたいのであれば、
	<filename>/usr/doc</filename>
	の下にある各言語のサブディレクトリで <command>make</command>
	を実行してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>ドキュメントをアップデートする別の方法は、
	<filename>/usr/doc</filename>
	または各言語のサブディレクトリで以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>make update</userinput></screen>

      <para><varname>FORMATS</varname> を設定して、
	以下のようにインストールする出力形式を指定できます。</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>ドキュメンテーションの一部のアップデートを簡単にするオプションや、
	特定の翻訳のビルドを行うためのオプションが用意されています。
 	これらのオプションは、システム全般のオプションである
	<filename>/etc/make.conf</filename> や、<command>make</command>
	に与えるコマンドラインオプションで設定できます。</para>

      <para>オプションには以下のようなものがあります。</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>ビルドおよびインストールの言語およびエンコーディングの一覧。
	      たとえば、英語のドキュメントを指定するには
	      <literal>en_US.ISO8859-1</literal> を設定します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>ビルドを行うフォーマット、または出力フォーマットの一覧。
	      現在は <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal> そして <literal>pdf</literal>
	      に対応しています。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>ドキュメントをインストールする場所。デフォルトは
	      <filename>/usr/share/doc</filename> です。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>&os; のシステム全般のオプションに関連するもっと多くの
	<command>make</command> 変数については、
	&man.make.conf.5; をご覧ください。</para>
    </sect2>

    <sect2 xml:id="doc-ports-install-package">
      <info>
	<title>ports を用いたドキュメンテーションのアップデート</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Marc</firstname>
	      <surname>Fonvieille</surname>
	    </personname>
	    <contrib>ベースとなった作業:</contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>Updating and Upgrading</primary>
      </indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>これまでのセクションでは、ソースコードを用いた &os;
	ドキュメントのアップデート方法について説明してきました。
	この節では、インストールされている
	&os; のドキュメントをアップデートするもう一つの方法である、
	Ports Collection を用いた方法について説明し、
	以下について説明します。</para>

      <itemizedlist>
	<listitem>
	  <para>構築済のドキュメントの packages をインストールする方法。
	    ローカルでの構築作業やドキュメンテーションツールチェインをインストールする必要はありません。</para>
	</listitem>

	<listitem>
	  <para>ports フレームワークを使ったドキュメントのソースの構築方法。
	    チェックアウトおよび構築作業が簡単になります。</para>
	</listitem>
      </itemizedlist>

      <para>&os; のドキュメントをアップデートするこれらの方法は、
	&a.doceng; が毎月アップデートしている
        ドキュメンテーション ports および packages
	によりサポートされています。
	これらの ports は、&os; Ports&nbsp;Collection の
	docs カテゴリ (<link
	  xlink:href="http://www.freshports.org/docs/">http://www.freshports.org/docs/</link>)
	にまとめられています。</para>

      <para>ドキュメンテーション ports の構成は以下の通りです。</para>

      <itemizedlist>
	<listitem>
	  <para><package>misc/freebsd-doc-en</package> package または portは、
	    すべての英語文書をインストールします。</para>
	</listitem>

	<listitem>
	  <para><package>misc/freebsd-doc-all</package> メタ package
	    もしくは port は、
	    すべての利用可能な言語のすべてのドキュメントを構築します。</para>
	</listitem>

	<listitem>
	  <para>各言語のために package または port
	    が用意されています。たとえば、
	    <package>misc/freebsd-doc-hu</package>
	    はハンガリー語のドキュメンテーション port です。</para>
	</listitem>
      </itemizedlist>

      <para>バイナリ package を使うと、
	インストールする言語に用意されているすべての形式の
	&os; ドキュメントがインストールされます。
	たとえば、以下のコマンドを実行すると、
	ハンガリー語のドキュメントの最新 package
	がインストールされます。</para>

      <screen>&prompt.root; <userinput>pkg install hu-freebsd-doc</userinput></screen>

      <note>
	<para>ドキュメントの package は、対応する port 名とは異なり、
	  <literal><replaceable>lang</replaceable>-freebsd-doc</literal>
	  の形式で名前がつけられています。
	  ここで、<replaceable>lang</replaceable> は言語コードの短縮形です。
	  ハンガリー語の場合は <literal>hu</literal>、簡体字の場合には
	  <literal>zh_cn</literal> です。</para>
      </note>

      <para>ドキュメントのフォーマットを指定する場合には、package ではなく
	port から構築してください。たとえば、
	英語のドキュメントを構築してインストールするには以下のようにして下さい。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>この port には、
	構築およびインストールするフォーマットを設定するメニューがあります。
	デフォルトでは、<uri
	  xlink:href="http://www.FreeBSD.org">http://www.FreeBSD.org</uri>
	と同じ形式である分割版の <acronym>HTML</acronym> 形式、
	<acronym>PDF</acronym> が選択されています。</para>

      <para>以下のように、ドキュメンテーション ports を構築する際の
	<command>make</command> オプションが用意されています。</para>

      <variablelist>
	<varlistentry>
	  <term><varname>WITH_HTML</varname></term>

	  <listitem>
	    <para>HTML 形式を構築します。
	      各ドキュメントに対し、単一版の HTML ファイルが構築されます。
	      整形されたドキュメントは、
	      <filename>article.html</filename> や
	      <filename>book.html</filename>
	      といった名前でインストールされます。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>WITH_PDF</varname></term>

	  <listitem>
	    <para>整形されたドキュメントは、
	      <filename>article.pdf</filename> や
	      <filename>book.pdf</filename>
	      といった名前でインストールされます。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCBASE</varname></term>

	  <listitem>
	    <para>ドキュメントのインストール先を設定します。
	      デフォルトのインストール先は
	      <filename>/usr/local/share/doc/freebsd</filename>
	      です。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>以下は、上記の変数を用いてハンガリー語のドキュメントを
	<acronym>PDF</acronym> 形式でインストールする方法です。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-hu</userinput>
&prompt.root; <userinput>make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</userinput></screen>

      <para><xref linkend="ports"/> に書かれている手順を使って、
	ドキュメンテーション package または port
	をアップデートできます。
	たとえば、以下のコマンドを実行すると、
	<package>ports-mgmt/portupgrade</package>
	から、package
	だけを使ってインストールされているハンガリー語のドキュメントをアップデートします。</para>

      <screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>開発ブランチを追いかける</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>&os; には二つの開発ブランチがあります。
      それは &os.current; と &os.stable; です。</para>

    <para>この節ではそれぞれのブランチと対象としている読者についての説明と、
      どのようにしてシステムの対応するブランチを最新の状態に保つかについて説明します。</para>

    <para><emphasis>訳: &a.hanai;、1996 年 11 月 6 日</emphasis></para>

    <sect2 xml:id="current">
      <title>&os.current; を使う</title>

      <para>&os.current; とは &os; の開発の <quote>最前線</quote> なので、
	&os.current; のユーザは高い技術力を持つことが要求されます。
	そこまでの技術力を持っていないが、
	開発ブランチを追いかけたいと考えているユーザは、
	かわりに &os.stable; を追いかけると良いでしょう。</para>

      <para>&os.current; は &os; の最新のソースコードであり、
	中には現在開発途上のソフトウェア、
	実験的な変更、あるいは過渡的な機能などが含まれています。
	また、この中に入っている機能がすべて、
	次の公式リリースに入るとは限りません。&os.current;
	をソースからほぼ毎日コンパイルしている人はたくさんいますが、
	短い期間ではコンパイルさえできない状態になっている時期もあります。
	これらの問題は可能な限り迅速に解決されますが、
	&os.current; が不幸をもたらすか、
	それとも新しい機能をもたらすかは、
	まさにソースコードを同期した瞬間によるのです!</para>

      <para>&os.current; は、
	次の 3 つの重要なグループを対象としています。</para>

      <orderedlist>
	<listitem>
	  <para>ソースツリーのある部分に関して活発に作業している
	    &os; コミュニティのメンバ。</para>
	</listitem>

	<listitem>
	  <para>活発にテストしている &os; コミュニティのメンバ。
	    彼らは、種々の問題を解決するのに時間を惜しまない人々であり、
	    さまざまな変更に関する提案や
	    &os; の大まかな方向付けを行ないたいと思っている人々でもあり、
	    パッチも提出します。</para>
	</listitem>

	<listitem>
	  <para>さまざまな事に目を向け、
	    参考のために最新のソースを使いたいと思っていたり、
	    時々コメントやコードを寄稿したいと考えているユーザ。</para>
	</listitem>
      </orderedlist>

      <para>&os.current; は、次のリリースの前に、
	最も早く新しい機能を入手する手段として、
	期待しては<emphasis>いけません</emphasis>。
	リリース前の機能は十分にテストされていないため、
	バグを含んでいる可能性が大いにあるためです。
	また、バグを修正するための素早い方法でもありません。
	いかなるコミットは、元からあるバグを修正するのと同じく、
	新しいバグを生み出すおそれがあります。
	&os.current; には <quote>公式のサポート</quote> はありません。</para>

      <indexterm>
	<primary>-CURRENT</primary>
	<secondary>using</secondary>
      </indexterm>

      <para>&os.current; を追いかけるには</para>
	
      <orderedlist>
	<listitem>
	  <para>&a.current.name; と &a.svn-src-head.name;
	    <indexterm>
	      <primary>-CURRENT</primary>
	      <secondary>使用</secondary>
	    </indexterm>
	    メーリングリストに加わってください。
	    さまざまな人がシステムの現在の状態について述べているコメントを見たり、
	    &os.current; の現在の状態に関する重要な情報を見逃さないために、
	    <emphasis>必須の</emphasis> ことです。</para>

	  <para>&a.svn-src-head.name; メーリングリストでは、
	    それぞれの変更についての commit ログが記録されています。
	    また、それに関して起こり得る副作用の情報を得ることができますので、
	    参加する価値のあるメーリングリストです。</para>

	  <para>これらのメーリングリストに入るには、
	    &a.mailman.lists.link;
	    をたどって参加したいメーリングリストをクリックし、
	    手順の説明にしたがってください。
	    &os.current; だけでなく、
	    ソースツリー全体の変更点を追いかけるのであれば、
	    &a.svn-src-all.name; メーリングリストを購読してください。</para>
	</listitem>

	<listitem>
	  <para>&os.current; のソースを同期してください。
	    特に <link linkend="svn">svnlite</link> を使って
	    <xref linkend="svn-mirrors"/> の一覧にある
	    Subversion ミラーサイトのひとつの
	    <literal>head</literal> ブランチから
	    -CURRENT コードをチェックアウトしてください。</para>
	</listitem>

	<listitem>
	  <para>リポジトリのサイズが大きいため、興味のある部分や、
	    パッチを当てる部分のソースのみを同期するユーザもいます。
	    しかしながら、
	    ソースからオペレーティングシステムをコンパイルしようと思っているユーザは、
	    一部分だけではなく、&os.current; の <emphasis>すべて</emphasis>
	    をダウンロードする必要があります。</para>

	  <para>&os.current; をコンパイル
	    <indexterm>
	      <primary>-CURRENT</primary>
	      <secondary>コンパイル</secondary>
	    </indexterm> する前に
	    <filename>/usr/src/Makefile</filename> を注意深く読み、
	    <xref linkend="makeworld"/>
	    に書かれている手順に従ってください。
	    &a.current; と <filename>/usr/src/UPDATING</filename> を読めば、
	    次のリリースへ向けて移ってゆくに当たって、
	    ときどき必要となる既存システムからの新システムの構築手順についての最新情報が得られるでしょう。</para>
	</listitem>

	<listitem>
	  <para>アクティブになってください!
	    &os.current; のユーザには、
	    拡張やバグ潰しに関して提案することが勧められています。
	    コードを伴う提案はいつでも歓迎されます!</para>
	</listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="stable">
      <title>&os.stable; を使う</title>

      <para><emphasis>訳: &a.jp.iwasaki;</emphasis></para>

      <para>&os.stable;
	とは定期的に公開されるリリースを作成するための開発ブランチです。
	このブランチに加えられる変更は &os.current; よりゆっくりで、
	原則として、事前に &os.current; で試験ずみであるという特徴があります。
	ただ<emphasis>そうであっても</emphasis>、
	これは開発用ブランチの一つであり、ある時点における &os.stable;
	のソースがどんな場合にも使えるものであるとは限りません。
	このブランチはもう一つの開発の流れというだけであって、
	エンドユーザ向けのものではありません。
	もし試験をする資源的な余裕がない場合は、代わりに最新の
	&os; リリースを使ってください。</para>

      <para>&os; の開発プロセスに興味があったり、
	それに対する貢献を考えていて、特にそれが次回の
	&os; のリリースに関係するものであるなら
	&os.stable; を追うことを考えると良いでしょう。</para>

      <para>&os.stable; ブランチはいつもコンパイルができ、
	安定に動作すべきですが、
	それが保証されているというわけではありません。
	&os.stable; のユーザは &os.current; よりも多いため、&os.current;
	で発見されなかったバグが &os.stable; で発見され、
	ときどきそれが問題となることがあるのは避けることができません。
	このような理由から、盲目的に &os.stable;
	を追いかけるべきではありません。
	特に、開発環境もしくはテスト環境でコードを十分に試験せずに、
	プロダクション品質が要求されるサーバを &os.stable;
	にアップグレードしては<emphasis>いけません</emphasis>。</para>

      <para>&os.stable; を追いかけるには</para>

      <indexterm>
	<primary>-STABLE</primary>
	<secondary>利用する</secondary>
      </indexterm>

      <orderedlist>
	<listitem>
	  <para>&os.stable; の構築に関連する事柄や、
	    その他の注意すべき点 に関する情報を得るために、
	    &a.stable.name; メーリングリストに加わってください。
	    また開発者は議論の余地がある修正や変更を考えている場合に、
	    このメーリングリストで公表し、
	    提案された変更に関して問題が生じるかどうかを返答する機会をユーザに与えます。</para>

	  <para>追いかけているブランチに関連する
	    <application>svn</application> メーリングリストに参加してください。
	    たとえば、9-STABLE ブランチを追いかけているユーザは
	    &a.svn-src-stable-9.name; メーリングリストに参加してください。
	    このリストでは、変更がなされるごとに作成される commit log
	    やそれに伴う起こりうる副作用についての情報が記録されています。</para>

	  <para>これらのメーリングリストに入るには、&a.mailman.lists.link;
	    をたどって参加したいメーリングリストをクリックし、
	    手順の説明にしたがってください。
	    ソースツリー全体の変更点を追いかけるには、
	    &a.svn-src-all.name; メーリングリストを購読してください。</para>
	</listitem>

	<listitem>
	  <para>新しい &os.stable; システムをインストールするには、
	    <link linkend="mirrors">ミラーサイト</link> から最近の
	    &os.stable; リリースをインストールするか、
	    毎月公開されている &os.stable;
	    からビルドされたスナップショットを使ってください。
	    スナップショットの詳細については、<link
	      xlink:href="&url.base;/ja/snapshots/">www.freebsd.org/ja/snapshots</link>
	    をご覧ください。</para>

	  <para>既に &os; が動いているシステムを
	    &os.stable; にアップグレードするには、
	    <link linkend="svn">svn</link>
	      <indexterm>
		<primary>Subversion</primary>
	      </indexterm> を使って、
	    希望する開発ブランチのソースをチェックアウしてください。
	    <literal>stable/9</literal> といったブランチ名は、
	    <link xlink:href="&url.base;/releng/">www.freebsd.org/releng</link>
	    で説明されています。</para>
	</listitem>

	<listitem>
	  <para>&os.stable; をコンパイルしたり &os.stable; へとアップグレード
	    <indexterm>
	      <primary>-STABLE</primary>
	      <secondary>構築、コンパイル</secondary>
	    </indexterm> する前に、
	    <filename>/usr/src/Makefile</filename> を注意深く読み、
	    <xref linkend="makeworld"/>
	    に書かれている手順に従ってください。
	    &a.stable; と <filename>/usr/src/UPDATING</filename> を読んで、
	    次のリリースへ向けて移ってゆくに当たって、
	    ときどき必要となる既存システムからの新システムの構築手順についての最新情報を得てください。</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="makeworld">
    <title xml:id="updating-src">ソースを用いた &os; のアップデート</title>

    <para>ソースをコンパイルして&os; をアップデートする方法は、
      バイナリを用いたアップデートに比べ、いくつもの利点があります。
      特定のハードウェアをうまく利用するためのオプションを設定してコードを構築できます。
      ベースシステムの特定の箇所の設定をデフォルトの設定から変更したり、
      必要がない部分を完全に削除して構築することもできます。
      システムを構築することによるアップデートは、
      バイナリアップデートをインストールするだけのアップデートに比べ時間がかかりますが、
      利用環境に合わせた &os;
      を作成するような完全なカスタマイズが可能です。</para>

    <sect2 xml:id="updating-src-quick-start">
      <title>クィックスタート</title>

      <para>以下は &os;
	をソースから構築してアップデートする典型的な方法についてのクイックリファレンスです。
	その後の節では、各プロセスをより詳細に説明します。</para>

      <procedure>
	<step>
	  <title>アップデートおよびビルド</title>

	  <screen>&prompt.root; <userinput>svnlite update /usr/src</userinput>  <co xml:id="updating-src-qs-svnup"/>
<emphasis>check <filename>/usr/src/UPDATING</filename></emphasis>  <co xml:id="updating-src-qs-review-updating"/>
&prompt.root; <userinput>cd /usr/src</userinput>          <co xml:id="updating-src-qs-cd"/>
&prompt.root; <userinput>make -j<replaceable>4</replaceable> buildworld</userinput>  <co xml:id="updating-src-qs-buildworld"/>
&prompt.root; <userinput>make -j<replaceable>4</replaceable> kernel</userinput>      <co xml:id="updating-src-qs-kernel"/>
&prompt.root; <userinput>shutdown -r now</userinput>      <co xml:id="updating-src-qs-reboot"/>
&prompt.root; <userinput>cd /usr/src</userinput>          <co xml:id="updating-src-qs-cd2"/>
&prompt.root; <userinput>make installworld</userinput>    <co xml:id="updating-src-qs-installworld"/>
&prompt.root; <userinput>mergemaster -Ui</userinput>      <co xml:id="updating-src-qs-mergemaster"/>
&prompt.root; <userinput>shutdown -r now</userinput>      <co xml:id="updating-src-qs-shutdown"/></screen>

	  <calloutlist>
	    <callout arearefs="updating-src-qs-svnup">
	      <para>最新版のソースを入手してください。
		ソースの入手およびアップデートに関する情報については
		<xref linkend="updating-src-obtaining-src"/>
		をご覧ください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-review-updating">
	      <para>ソースの構築の前後で必要となる手動の作業について、
		<filename>/usr/src/UPDATING</filename>
		を確認してください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-cd">
	      <para>ソースが置かれているディレクトリに移動してください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-buildworld">
	      <para>world (カーネルを除くすべて)
		をコンパイルしてください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-kernel">
	      <para>カーネルをコンパイルしてインストールしてください。
		ここに書かれているコマンドは、<command>make buildkernel
		  installkernel</command>
		と同じです。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-reboot">
	      <para>新しいカーネルを使うため、
		システムを再起動してください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-cd2">
	      <para>ソースが置かれているディレクトリに移動してください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-installworld">
	      <para>world をインストールしてください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-mergemaster">
	      <para><filename>/etc/</filename>
		に置かれている設定ファイルをアップデートしたりマージしてください。</para>
	    </callout>

	    <callout arearefs="updating-src-qs-shutdown">
	      <para>新しく構築された world およびカーネルを利用するため、
		システムを再起動してください。</para>
	    </callout>
	  </calloutlist>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="updating-src-preparing">
      <title>ソースを用いたアップデートのための準備</title>

      <para><filename>/usr/src/UPDATING</filename> を読んでください。
	このファイルには、
	アップデートの前後で必要となる手動の作業について書かれています。</para>
    </sect2>

    <sect2 xml:id="updating-src-obtaining-src">
      <title>ソースコードのアップデート</title>

      <para>&os; のソースコードは
	<filename>/usr/src/</filename> に置かれています。
	このソースコードのアップデートには、
	<application>Subversion</application>
	バージョン管理システムを利用する方法が推奨されています。まず、
	ソースコードがバージョン管理下にあることを確認してください。</para>

      <screen>&prompt.root; <userinput>svnlite info /usr/src</userinput>
Path: /usr/src
Working Copy Root Path: /usr/src
...</screen>

      <para>この結果は、<filename>/usr/src/</filename>
	がバージョン管理下にあり、&man.svnlite.1;
	を使ってアップデートできることを示しています。</para>

      <screen xml:id="synching">&prompt.root; <userinput>svnlite update /usr/src</userinput></screen>

      <para>このディレクトリをアップデートしていない期間が長いと、
	アップデートのプロセスには時間がかかります。
	このプロセスが終わると、ソースコードは最新となり、
	次節以降で説明する構築のプロセスを実行できます。</para>

      <note xml:id="updating-src-obtaining-src-checkout">
	<title>ソースコードの入手</title>

	<para><literal>'/usr/src' is not a working copy</literal>
	  という出力が出た場合には、
	  ファイルがなかったり、別な方法によりインストールされているので、
	  新しくソースコードをチェックアウトする必要があります。</para>

	<table xml:id="updating-src-obtaining-src-repopath">
	  <title>&os; のバージョンおよびリポジトリパス</title>

	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry><command>uname -r</command> の出力</entry>
		<entry>リポジトリパス</entry>
		<entry>説明</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal><replaceable>X.Y</replaceable>-RELEASE</literal></entry>
		<entry><literal>base/releng/</literal><replaceable>X.Y</replaceable></entry>
		<entry>このリリースバージョンに対する重大なセキュルティへの対応およびバグの修正パッチのみが適用されています。
		  このブランチは、ほとんどのユーザに推奨されます。</entry>
	      </row>

	      <row xml:id="STABLE">
		<entry><literal><replaceable>X.Y</replaceable>-STABLE</literal></entry>
		<entry><literal>base/stable/</literal><replaceable>X</replaceable></entry>
		<entry>
		  <para>リリースバージョンに対し、
		    そのブランチにおけるすべての開発の成果が反映されたものです。
		    <emphasis>STABLE</emphasis> は、
		    Applications Binary Interface
		    (<acronym>ABI</acronym>)
		    が変更されないことを意味しており、
		    このブランチの以前のバージョンでコンパイルされたソフトウェアは、
		    このバージョンでも実行できることを意味しています。
		    たとえば、&os; 10.1
		    で実行するようにコンパイルされたソフトウェアは、
		    &os; 10-STABLE においても実行できます。</para>

		  <para>STABLE ブランチは、
		    時期によってはユーザに影響するようなバグや非互換性を持つことがあります。
		    これらは通常すぐに修正されます。</para>
		</entry>
	      </row>

	      <row>
		<entry><literal><replaceable>X</replaceable>-CURRENT</literal></entry>
		<entry><literal>base/head/</literal></entry>
		<entry>リリースが行われていない最新の &os;
		  の開発バージョンです。
		  CURRENT ブランチは大きなバグや非互換があることもあるので、
		  高度な知識を持ったユーザのみ使用が推奨されます。</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>&man.uname.1; を使って &os;
	  のバージョンを確認してください。</para>

	<screen>&prompt.root; <userinput>uname -r</userinput>
10.3-RELEASE</screen>

	<para><xref linkend="updating-src-obtaining-src-repopath"/>
	  から分かるように、<literal>10.3-RELEASE</literal>
	  のアップデートのためのソースコードのパスは、
	  <literal>base/releng/10.3</literal> です。
	  このパスは、ソースコードをチェックアウトする時に使います。</para>

	<screen>&prompt.root; <userinput>mv /usr/src /usr/src.bak</userinput>  <co xml:id="updating-src-obtaining-src-mv"/>
&prompt.root; <userinput>svnlite checkout https://svn.freebsd.org/base/<replaceable>releng/10.3</replaceable> /usr/src</userinput>  <co xml:id="updating-src-obtaining-src-checkout-cmd"/></screen>

	<calloutlist>
	  <callout arearefs="updating-src-obtaining-src-mv">
	    <para>この古いディレクトリを、
	      邪魔にならないように移動してください。
	      このディレクトリ以下に対して変更を行ってなければ、
	      削除しても構わないでしょう。</para>
	  </callout>

	  <callout arearefs="updating-src-obtaining-src-checkout-cmd">
	    <para>リポジトリの <acronym>URL</acronym> に
	      <xref linkend="updating-src-obtaining-src-repopath"/>
	      に記載されているパスを追加します。
	      3 番目のパラメータには、
	      ローカルシステム上でソースコードが置かれるディレクトリを指定します。</para>
	  </callout>
	</calloutlist>
      </note>
    </sect2>

    <sect2 xml:id="updating-src-building">
      <title>ソースからの構築</title>

      <para>まず最初に <emphasis>world</emphasis>
	(カーネルを除くオペレーティングシステムのすべて) をコンパイルします。
	このステップを最初に実行するのは、
	カーネルの構築を最新のツールを使って行うようにするためです。
	このステップが終わったら、カーネルそのものを構築します。</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput></screen>

      <para>コンパイルされたコードは
	<filename>/usr/obj</filename> に書き出されます。</para>

      <para>これは基本のステップです。
	構築をコントロールする追加のオプションについては、
	以下で説明します。</para>

      <sect3 xml:id="updating-src-building-clean-build">
	<title>クリーンビルドの実行</title>

	<para>&os; ビルドシステムのいくつかのバージョンは、
	  オブジェクトが一時的に置かれるディレクトリ
	  <filename>/usr/obj</filename>
	  に前回のコンパイルされたコードを残します。
	  これにより、変更されていないコードを再コンパイルせずにすむので、
	  その後の構築時間を短縮できます。
	  すべてを再構築するには、構築を開始する前に、
	  <buildtarget>cleanworld</buildtarget> を実行してください。</para>

	<screen>&prompt.root; <userinput>make cleanworld</userinput></screen>
      </sect3>

      <sect3 xml:id="updating-src-building-jobs">
	<title>ジョブの数の設定</title>

	<para>マルチコアプロセッサを搭載するシステムでは、
	  構築のためのジョブの数を増やすことで、
	  構築にかかる時間を短縮できます。
	  <command>sysctl hw.ncpu</command> を使って、
	  コアの数を確認してください。
	  ジョブの数がどのように構築の速さに影響するかを確実に知るには、
	  プロセッサにより異なりますし、&os;
	  のバージョンにより使用されるビルドシステムも変わるため、
	  実際に試してみるしか方法はありません。
	  試してみる最初のジョブの数の候補としては、
	  コアの数の半分から倍の数の間で検討してみてください。
	  ジョブの数は、<option>-j</option> を使って指定します。</para>

	<example xml:id="updating-src-building-jobs-example">
	  <title>構築のジョブの数を増やす</title>

	  <para>以下は 4 つのジョブで world とカーネルを構築する例です。</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld buildkernel</userinput></screen>
	</example>
      </sect3>

      <sect3 xml:id="updating-src-building-only-kernel">
	<title>カーネルのみを構築する</title>

	<para>ソースコードが変更された場合には、
	  <buildtarget>buildworld</buildtarget> を完了しなければいけません。
	  その後、いつでも
	  <buildtarget>buildkernel</buildtarget> でカーネルを構築できます。
	  カーネルだけを構築するには、以下のように実行してください。</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel</userinput></screen>
      </sect3>

      <sect3 xml:id="updating-src-building-custom-kernel">
	<title>カスタムカーネルの構築</title>

	<para>&os; 標準のカーネルは、
	  <filename>GENERIC</filename> と呼ばれる
	  <emphasis>カーネルコンフィグレーションファイル</emphasis>
	  に基づいています。
	  <filename>GENERIC</filename> カーネルには、
	  最も良く使われるデバイスドライバやオプションが含まれています。
	  しかしながら、
	  特定の目的に合わせてデバイスドライバやオプションを削除したり追加するためには、
	  カスタムカーネルを構築することが有用であったり、
	  必要となることがあります。</para>

	<para>たとえば、極端に <acronym>RAM</acronym>
	  が制限されているような小さな組み込みのコンピュータを開発しているユーザであれば、
	  必要のないデバイスドライバやオプションを削除することで、
	  カーネルを少しでも小さくできるでしょう。</para>

	<para>カーネルのコンフィグレーションファイルは、
	  <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/</filename>
	  に置かれています。ここで、
	  <replaceable>arch</replaceable> は
	  <command>uname -m</command> の出力です。
	  ほとんどのコンピュータは
	  <literal>amd64</literal> であり、
	  コンフィグレーションファイルが置かれているディレクトリは
	  <filename>/usr/src/sys/<replaceable>amd64</replaceable>/conf/</filename>
	  です。</para>

	<tip>
	  <para><filename>/usr/src</filename> は、
	    削除されたり作り直されたりする可能性があるため、
	    カスタムカーネルのコンフィグレーションファイルは、
	    <filename>/root</filename>
	    のような別のディレクトリで管理することが好ましいです。
	    カーネルコンフィグレーションファイルは、
	    <filename>conf</filename> ディレクトリにリンクします。
	    このディレクトリが削除されたり、上書きされた場合には、
	    カーネルコンフィグレーションファイルを新しいディレクトリにもう一度リンクしてください。</para>
	</tip>

	<para>カスタムコンフィグレーションファイルは、
	  <filename>GENERIC</filename>
	  コンフィグレーションファイルをコピーして作成できます。
	  たとえば、
	  ストレージサーバ用の <filename>STORAGESERVER</filename>
	  という名前の新しいカスタムカーネルは、
	  以下のようにして作成できます。</para>

	<screen>&prompt.root; <userinput>cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER</userinput>
&prompt.root; <userinput>cd /usr/src/sys/amd64/conf</userinput>
&prompt.root; <userinput>ln -s /root/STORAGESERVER .</userinput></screen>

	<para>その後 <filename>/root/STORAGESERVER</filename> を編集し、
	  &man.config.5;
	  で示されるデバイスやオプションを追加したり削除してください。</para>

	<para>コマンドラインからカーネルコンフィグレーションファイルを
	  <varname>KERNCONF</varname> に指定することで、
	  カスタムカーネルを構築できます。</para>

	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=STORAGESERVER</userinput></screen>
      </sect3>
    </sect2>

    <sect2 xml:id="updating-src-installing">
      <title>コンパイルされたコードのインストール</title>

      <para><buildtarget>buildworld</buildtarget> および
	<buildtarget>buildkernel</buildtarget> が完了したら、
	新しいカーネルと world をインストールしてください。</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>カスタムカーネルを構築した場合は、
	新しいカスタムカーネルを <varname>KERNCONF</varname>
	に設定して実行してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=STORAGESERVER</userinput>
&prompt.root; <userinput>shutdown -r now</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-src-completing">
      <title>アップデートの完了</title>

      <para>アップデートの完了までに、いくつかの最終作業が残されています。
	デフォルトから変更した設定ファイルを新しいバージョンのファイルにマージし、
	古くなったライブラリを見つけて削除した後に、
	システムを再起動します。</para>

      <sect3 xml:id="updating-src-completing-merge-mergemaster">
	<title>&man.mergemaster.8; を用いた設定ファイルのマージ</title>

	<para>&man.mergemaster.8; を用いることで、
	  システムの設定ファイルに行われている変更を、
	  簡単にこれらのファイルの新しいバージョンにマージできます。</para>

	<para><option>-Ui</option> オプションを使って
	  &man.mergemaster.8; を実行すると、
	  ユーザが手を加えていないファイルのアップデートおよび新しく追加されたファイルのインストールを自動的に行います。</para>

	<screen>&prompt.root; <userinput>mergemaster -Ui</userinput></screen>

	<para>ファイルのマージを手動で行う必要がある時は、
	  ファイルの中で残す箇所の選択を対話的におこなうようなインタフェースが表示さます。
	  詳細については、&man.mergemaster.8; をご覧ください。</para>
      </sect3>

      <sect3 xml:id="updating-src-completing-check-old">
	<title>使われなくなったファイルやライブラリの確認</title>

	<para>アップデート後に、
	  使われなくなったファイルやディレクトリが残ることがあります。
	  これらのファイルは、</para>

	<screen>&prompt.root; <userinput>make check-old</userinput></screen>

	<para>で確認でき、以下のようにして削除できます。</para>

	<screen>&prompt.root; <userinput>make delete-old</userinput></screen>

	<para>同様に使われなくなったライブラリが残ることもあります。
	  これらのライブラリは、</para>

	<screen>&prompt.root; <userinput>make check-old-libs</userinput></screen>

	<para>で確認でき、以下のようにして削除できます。</para>

	<screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>

	<para>これらの古いライブラリを利用しているプログラムは、
	  ライブラリが削除されると動かなくなります。
	  これらのプログラムは、古いライブラリを削除した後に、
	  再構築もしくは置き換える必要があります。</para>

	<tip>
	  <para>古いファイルとディレクトリのすべてを削除しても問題ないことを確認したら、
	    コマンドに <varname>BATCH_DELETE_OLD_FILES</varname>
	    を設定することで、各ファイルを削除する際に
	    <keycap>y</keycap> および <keycap>Enter</keycap>
	    を押さなくても済むようにできます。以下はその例です。</para>

	  <screen>&prompt.root; <userinput>make BATCH_DELETE_OLD_FILES=yes delete-old-libs</userinput></screen>
	</tip>
      </sect3>

      <sect3 xml:id="updating-src-completing-restart">
	<title>アップデート後の再起動</title>

	<para>コンピュータを再起動して、すべての変更を反映させることが、
	  アップデートの最後におこなう作業です。</para>

	<screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info>
      <title>複数のマシンで追いかける</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mike</firstname>
	    <surname>Meyer</surname>
	  </personname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>NFS</primary>
      <secondary>複数のマシンにインストール</secondary>
    </indexterm>

    <para>複数のコンピュータで同じソースツリーを追いかけていて、
      全部のマシンにソースをダウンロードして全部を再構築するのは、
      ディスクスペース、ネットワーク帯域、
      そして <acronym>CPU</acronym> サイクルの無駄使いです。
      解決策は 1 つのマシンに仕事のほとんどをさせ、
      残りのマシンは <acronym>NFS</acronym>
      経由でそれをマウントする、というものです。
      このセクションではそのやり方を概観します。
      <acronym>NFS</acronym> の使い方の詳細については、<xref
	linkend="network-nfs"/> をご覧下さい。</para>

    <para>まず初めに、同じバイナリで動かそうとするマシンたちを決めます。
      このマシンたちのことを<firstterm>ビルドセット</firstterm>と呼びます。
      それぞれのマシンはカスタムカーネルを持っているかもしれませんが、
      同じユーザランドバイナリを動かそうというのです。
      このビルドセットから、
      <firstterm>ビルドマシン</firstterm>となるマシンを 1 台選びます。
      ベースシステムとカーネルを構築するのはこのマシンになります。
      理想的には、このマシンは <command>make buildworld</command>
      と <command>make buildkernel</command>
      を実行するのに十分な <acronym>CPU</acronym>
      を持った速いマシンであるべきです。</para>
	
    <para><firstterm>テストマシン</firstterm>
      となるべきマシンも選んでください。
      更新されたソフトウェアを使う前にそのマシンでテストするのです。
      テストマシンはかなり長い時間落ちていても
      だいじょうぶなマシン<emphasis>であったほうがいいでしょう</emphasis>。
      ビルドマシンでもかまいませんが、
      ビルドマシンである必要はありません。</para>

    <para>このビルドセットのマシンはすべて
      <filename>/usr/obj</filename> と
      <filename>/usr/src</filename>
      をビルドマシンから <acronym>FTP</acronym>
      経由でマウントする必要があります。
      ビルドセット自体が複数ある場合は、
      <filename>/usr/src</filename>
      はひとつのビルドマシン上にあるべきです。
      他のマシンからはそれを <acronym>NFS</acronym>
      マウントするようにしましょう。</para>

    <para>ビルドセットのすべてのマシン上の
      <filename>/etc/make.conf</filename> と
      <filename>/etc/src.conf</filename>
      がビルドマシンと一致していることを確認してください。つまり、
      ビルドマシンはビルドセットのどのマシンもインストールしようとしている
      ベースシステムを全部ビルドしなければならないということです。
      また、各ビルドマシンは <filename>/etc/make.conf</filename>
      にそれぞれのビルドマシンのカーネル名を
      <varname>KERNCONF</varname> で指定し、
      ビルドマシンは自分自身のカーネルから順に全部のカーネル名を
      <varname>KERNCONF</varname> にリストアップしてください。
      ビルドマシンは各マシンのカーネル設定ファイルを <filename
	>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
      に持っていなければなりません。</para>

    <para>ビルドマシンにて、
      <xref linkend="makeworld"/>
      に書いてあるようにカーネルとベースシステムを構築してください。
      でも、まだビルドマシンにはインストールしないでください。
      そのかわり、
      ビルドしたカーネルをテストマシンにインストールしてください。
      <acronym>FTP</acronym> 経由で
      <filename>/usr/src</filename> および <filename>/usr/obj</filename>
      をテストマシンにマウントしてください。
      その後、<command>shutdown now</command>
      を実行してシングルユーザモードに移行し、
      新しいカーネルとベースシステムをインストールし、
      いつもするように
      <command>mergemaster</command> を実行してください。
      終わったら、再起動して通常のマルチユーザ動作に戻します。</para>

    <para>テストマシンにあるものすべてがちゃんと動いている確信が得られたら、
      同じ手順でビルドセットの他のマシンにも新しいソフトウェアをインストールします。</para>

    <para>ports ツリーにも同じ方法が使えます。
      最初のステップは、
      ビルドセットのすべてのマシンが <acronym>NFS</acronym> 経由で
      <filename>/usr/ports</filename> をマウントすることです。
      そして、distfiles を共有するように
      <filename>/etc/make.conf</filename> を設定します。
      <acronym>NFS</acronym> マウントによってマップされる
      <systemitem class="username">root</systemitem>
      ユーザが何であれ、<varname>DISTDIR</varname>
      はそのユーザが書き込める共通の共有ディレクトリに設定する必要があります。
      ports をローカルでビルドする場合には、
      各マシンは <varname>WRKDIRPREFIX</varname>
      を自分のマシンのビルドディレクトリに設定しなければなりません。
      また、ビルドシステムが packages
      をビルドしてビルドセットのコンピュータに配布するのであれば、
      <varname>DISTDIR</varname> と同じようにビルドシステム上の
      <varname>PACKAGES</varname>
      ディレクトリも設定してください。</para>
  </sect1>
</chapter>
