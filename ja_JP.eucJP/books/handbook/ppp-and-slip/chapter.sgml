<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.12
     $FreeBSD$
-->

<chapter id="ppp-and-slip">
  <title>PPP と SLIP</title>

  <para>もしあなたがモデムを使ってインターネットに接続したり,
    他の人々に FreeBSD によるインターネットへのダイヤルアップ接続を
    提供しようとしているのでしたら, PPP または SLIP
    接続を選択することができます.  PPP 接続には, 2
    種類の方法が提供されています:  <emphasis>ユーザ</emphasis>PPP
    (<emphasis>iijppp</emphasis> とも呼ばれます)
    と<emphasis>カーネル</emphasis>PPP です.  両方の PPP の設定手順と,
    SLIP の設定方法については以下の章に書かれています.</para>

  <sect1 id="userppp">
    <title>ユーザ ppp の設定</title>

    <para>ユーザ ppp は FreeBSD 2.0.5-RELEASE において,
      既存のカーネル実装版の PPP に加えて導入されました.  それでは,
      これまでの pppd との違い, すなわち この新しい PPP
      が追加された理由とは いったい何なのでしょうか?
      マニュアルから引用してみます:</para>

    <blockquote>
      <para>これはユーザプロセス PPP ソフトウェアパッケージです.
	通常, PPP は (例えば <command>pppd</command>
	でそうなっているように) カーネルの一部として
	実装されていますので, デバッグや動作の変更が少々困難です.
	しかし, この実装では, PPP はトンネルデバイスドライバ
        (<devicename>tun</devicename>) の
	助けにより, ユーザプロセスとして実装されています.</para>
    </blockquote>

    <para>本質として, これは常に PPP デーモンを実行しておかなくても,
      必要な時に ppp プログラムを実行できるということを意味します.
      このプログラムはカーネルとのデータ送受のために
      一般のトンネルデバイスを 使うことができるため, PPP
      インターフェースをカーネルに組み込んでおく
      必要がありません.</para>

    <para>以降では, ユーザ ppp と <command>pppd</command> のような他の
      PPP クライアント/サーバ
      ソフトウェアとを区別する必要が無い場合には, ユーザ ppp を単に
      ppp とだけ 呼びます. 特に断らない限り,
      このセクションのすべてのコマンドは root 権限で
      実行する必要があります.</para>

    <para>バージョン 2 の ppp では,
      数多くの機能強化がおこなわれています. どのバージョンの ppp
      がインストールされているのかを調べるには, 引数なしで ppp
      を起動し, プロンプトが表示されたら <command>show
	version</command> とタイプしてください.  最新版の ppp
      にアップグレードするのは, (どのバージョンの FreeBSD においても)
      難しいことではありません. <ulink
	url="http://www.Awfulhak.org/ppp.html">www.Awfulhak.org</ulink>
      から最新版のアーカイブをダウンロードしてください. </para>

    <sect2>
      <title>スタートの前に</title>

      <para>このドキュメントでは, あなたが
	およそ以下のような状況にあると仮定しています:</para>

      <para>PPP 接続の使えるインターネットサービスプロバイダ (ISP)
	のアカウントを 持っている. さらに, 接続済みのモデム
	(またはその他のデバイス) があり,
	プロバイダとの接続が可能なように正しく設定されている.</para>

      <para>以下の情報を手に入れておく必要があるでしょう:</para>

      <itemizedlist>
	<listitem>
	  <para>プロバイダの電話番号.</para>
	</listitem>

	<listitem>
	  <para>ログイン名とパスワード. これは通常の unix
	    形式のログイン名と パスワードの組という場合もありますし,
	    PPP PAP または CHAP の
	    ログイン名とパスワードの組という場合もあります.</para>
	</listitem>

	<listitem>
	  <para>一つ以上のネームサーバの IP アドレス. 通常,
	    プロバイダから IP アドレスを二つ指示されている はずです.
	    自分でネームサーバを立ち上げている場合を除き, バージョン
	    1.X の <application>PPP</application>
	    を使用している場合には,
	    この情報は<emphasis>絶対に</emphasis>必要です.  バージョン
	    2 の <application>PPP</application> からは,
	    ネームサーバアドレスの 自動設定機能が追加されています.
	    この機能をプロバイダ側でもサポートしていれば,  ppp
	    の設定ファイルに <command>enable dns</command>
	    と書いておくことで  <application>PPP</application>
	    がネームサーバアドレスの設定をおこなうようになります.
	  </para>
	</listitem>
      </itemizedlist>

      <para>プロバイダからは以下の情報が提供されているはずですが,
	どうしても必要というわけではありません: </para>

      <itemizedlist>
	<listitem>
	  <para>プロバイダのゲートウェイの IP アドレス.
	    ゲートウェイとは, あなたがそこに接続をおこなって,
	    &ldquo;デフォルトルート&rdquo;
	    として設定することになるマシンです.
	    プロバイダがこのアドレスを明示していなくても, 最初は
	    適当に設定しておいて, 接続時にプロバイダの PPP サーバから
	    正しいアドレスを教えてもらうことができます.</para>

	  <para>このアドレスは, 以降 <literal>HISADDR</literal>
	    と呼ぶことにします.</para>
	</listitem>

	<listitem>
	  <para>プロバイダのネットマスク設定.
	    プロバイダが明示していないとしても,  ネットマスクとして
	    <hostid role="netmask">255.255.255.0</hostid>
	    を使用しておけば問題ありません.</para>
	</listitem>

	<listitem>
	  <para>もしプロバイダから固定の IP
	    アドレスとホスト名の割り当てを 受けていれば,
	    その情報を指定しておくこともできます.
	    割り当てを受けていなければ, 接続先から適切な IP
	    アドレスを指定してもらいます. </para>
	</listitem>
      </itemizedlist>

      <para>もし, 必要な情報が不足していれば, プロバイダに連絡を取って
	確認しておいてください.</para>
    </sect2>

    <sect2>
      <title>ppp 対応カーネルの構築</title>

      <para>説明でも述べているように, <command>ppp</command>
	はカーネルの <devicename>tun</devicename> デバイスを使います.
	そのため, このデバイスがカーネルに組み込まれているかどうかを
	確認しておかなくてはいけません.</para>

      <para>これを確認するには, カーネルコンパイルディレクトリ
	(<filename>/sys/i386/conf</filename> または
	<filename>/sys/pc98/conf</filename>) に移動して,
	カーネルコンフィグレーションファイルを調べます.
	以下の行がどこかに含まれている必要があります.

	<programlisting>
pseudo-device tun 1</programlisting>

	元々の <filename>GENERIC</filename> カーネルは
	標準でこれを含んでいますので,
	カスタムカーネルをインストールしているのではなかったり,
	<filename>/sys</filename> ディレクトリが存在しないのであれば,
	何も変更する必要はありません.</para>

      <para>この行がカーネルコンフィグレーションファイルに
	含まれていなかったり,  <devicename>tun</devicename> デバイスが
        一つでは足りない場合
	(例えば, 同時に 16 本の ダイアルアップ PPP
	接続を処理できるサーバを立ち上げるとしたら,
	<literal>1</literal> のかわりに <literal>16</literal>
	を指定する必要があるでしょう), この行を追加して
	カーネルの再コンパイルとインストールをおこなう必要があります.
	それからこの新しいカーネルを使ってブートしてください.
	カーネルコンフィグレーションの詳細については,  <link
	  linkend="kernelconfig">FreeBSD
	  カーネルのコンフィグレーション</link>
	を参照してください.</para>

      <para>以下のコマンドを実行することで,
	現在のカーネルにトンネルデバイスが
	いくつ組み込まれているかを調べることができます:</para>

      <screen>&prompt.root; <userinput>ifconfig -a</userinput>
tun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
	inet 200.10.100.1 --&gt; 203.10.100.24 netmask 0xffffffff
tun1: flags=8050&lt;POINTOPOINT,RUNNING,MULTICAST&gt; mtu 576
tun2: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
	inet 203.10.100.1 --&gt; 203.10.100.20 netmask 0xffffffff
tun3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <para>この例ではトンネルデバイスが四つ存在し, そのうち二つに
	設定がおこなわれ, 使用中であることがわかります.  上の例で
	<literal>RUNNING</literal> フラグがオンになっている
	ものがありますが, これは
	そのインターフェースが何かに使用されていることを示している
	だけであるということに注意してください. つまり,
	<literal>RUNNING</literal> になっていない
	インターフェースがあったとしても, それはエラーではありません.
      </para>

      <para>トンネルデバイスがカーネルに組み込まれておらず,
	何らかの理由で
	カーネルの再構築ができない場合でも,
	方法がないわけではありません.
	動的にデバイスをロードすることができるはずです.
	詳細については
	&man.modload.8; や &man.lkm.4; など,
	適切なマニュアルを参照してください.</para>

      <para>この機会にファイアウォールも
	設定しておきたいと思っているのであれば,  詳細については<link
	  linkend="firewalls">ファイアウォール</link>セクションを
	参照してください.</para>
    </sect2>

    <sect2>
      <title>tun デバイスの確認</title>

      <para>ほとんどのユーザは <devicename>tun</devicename> デバイス
	(<filename>/dev/tun0</filename>) が一つあれば充分でしょう.
	より多くのデバイスを使う場合 (すなわち,
	カーネルコンフィグレーション ファイルで <literal>pseudo-device
	  tun</literal> の行に <literal>1</literal>
	以外の数値を指定している場合),  以下で
	<devicename>tun0</devicename> と書かれている部分をすべて,
	あなたが使うデバイスの番号に
	あわせて読みかえてください.</para>

      <para><devicename>tun0</devicename>
	デバイスが正しく作成されていることを確認する最も簡単な方法は,
	それを作り直すことです. そのためには,
	以下のコマンドを実行します:</para>

      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV tun0</userinput></screen>

      <para>カーネルに 16 個のトンネルデバイスを組み込んだのであれば,
	<devicename>tun0</devicename> だけでなく他の tun
	デバイスも作成しておく必要があるでしょう:</para>

      <screen>&prompt.root; cd /dev
&prompt.root; ./MAKEDEV tun15</screen>

      <para>また, カーネルが正しく設定されているかどうかを調べるために
	以下のコマンドを実行して,
	このような出力が得られることを確認します:</para>

      <screen>&prompt.root; <userinput>ifconfig tun0</userinput>
tun0: flags=8050&lt;POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500</screen>

      <para>まだ <literal>RUNNING</literal>
	フラグがセットされていない場合もあります.
	その時は以下のような出力が得られるでしょう: </para>

      <screen>&prompt.root; <userinput>ifconfig tun0</userinput>
tun0: flags=8010&lt;POINTOPOINT,MULTICAST> mtu 1500</screen>
    </sect2>

    <sect2>
      <title>名前の解決に関する設定</title>

      <para>リゾルバ (resolver) はシステムの一部分で, IP
	アドレスとホスト名との 変換をおこないます. IP
	アドレスとホスト名を対応させるためのマップを,
	二つの場所のうちの一つから探すように設定できます.  一つめは
	<filename>/etc/hosts</filename> (<command>man 5
	  hosts</command>) と呼ばれるファイルです.  <!-- kuriyama -
	citerefentry? --> 二つめはインターネット
	ドメインネームサービス (DNS) と呼ばれる
	分散データベースですが, これに関する議論は
	このドキュメントで扱う範囲を 越えていますので,
	これについての説明はおこないません.</para>

      <para>このセクションではリゾルバの
	設定方法について簡単に説明します.</para>

      <para>リゾルバは名前のマッピングを
	おこなうシステムコールの集合体です. ただし
	どこからマッピング情報を見つけるのかは,
	最初に指示しておく必要があります.  これは まず
	<filename>/etc/host.conf</filename>
	ファイルを編集することでおこないます.  混乱の元になりますので,
	このファイルを <filename>/etc/hosts.conf </filename>と
	呼んだりしては<emphasis>いけません</emphasis> (余分な
	<literal>s</literal> がついていますね).</para>

      <sect3>
	<title><filename>/etc/host.conf</filename> ファイルの編集</title>

	<para>このファイルには 以下の 2 行が (この順番で)
	  書かれているはずです:</para>

	<programlisting>
hosts
bind</programlisting>

	<para>これは, 最初に <filename>/etc/hosts</filename>
	  ファイルを調べ, そこで目的の名前が 見つけられなかった場合に
	  DNS を引きにいくようリゾルバに指示します.</para>
      </sect3>

      <sect3>
	<title>/etc/hosts(5) ファイルの編集</title>
	<!-- kuriyama - man.hosts.5? -->

	<para>このファイルはローカルネットワーク上に存在するマシンの
	  IP アドレスと ホスト名を含んでいるはずです. 最低でも ppp
	  を動作させるマシンのエントリが 含まれている必要があります.
	  そのマシンのホスト名が <hostid
	    role="fqdn">foo.bar.com</hostid> で,  IP アドレスが
	  <hostid role="ipaddr">10.0.0.1</hostid> であると仮定すると,
	  <filename>/etc/hosts</filename> は
	  以下の行を含んでいなければいけません:</para>

	<programlisting>
127.0.0.1    localhost
10.0.0.1     foo.bar.com	       foo</programlisting>

	<para>一つめの行は <hostid>localhost</hostid>
	  を現在のマシンの別名として定義しています.  マシン固有の IP
	  アドレスが何であっても, この行の IP アドレスは 常に <hostid
	    role="ipaddr">127.0.0.1</hostid> でなければいけません.
	  二つめの行はホスト名 <hostid
	    role="fqdn">foo.bar.com</hostid> (と, その省略形
	  <hostid>foo</hostid>) を IP アドレス <hostid
	    role="ipaddr">10.0.0.1</hostid> にマップします.</para>

	<para>もしプロバイダから固定の IP
	  アドレスとホスト名を割り当てられて いるのであれば, それを
	  <hostid role="ipaddr">10.0.0.1</hostid>
	  エントリのかわりに使ってください.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/resolv.conf</filename> ファイルの編集</title>

	<para><filename>/etc/resolv.conf</filename>
	  はリゾルバの振舞いを指定します.  もし自前の DNS
	  サーバを走らせているのなら, このファイルは空のままに
	  しておくこともできます. 通常は,
	  以下のように書いておく必要があるでしょう:</para>

	<programlisting>
nameserver <replaceable>x.x.x.x</replaceable>
nameserver <replaceable>y.y.y.y</replaceable>
domain <replaceable>bar.com</replaceable></programlisting>

	<para><hostid
	    role="ipaddr"><replaceable>x.x.x.x</replaceable></hostid>
	  と <hostid
	    role="ipaddr"><replaceable>y.y.y.y</replaceable></hostid>
	  はプロバイダから指示されたアドレスで,
	  接続するプロバイダが提供しているネームサーバを
	  すべて書いてください.  <literal>domain</literal>
	  に指定するのは このマシンのデフォルトのドメイン名で,
	  おそらく 書かなくても問題は無いでしょう.
	  このファイルの各エントリの詳細については,
	  <filename>resolv.conf</filename>
	  のマニュアルページを参照してください.</para>

	<para>バージョン 2 以降の ppp を使用している場合には,
	  <command>enable dns</command>
	  コマンドを使用してネームサーバのアドレスを
	  プロバイダに問い合わせるように指示することができます.
	  上の指定とは異なるアドレスをプロバイダが指定してきた場合
	  (または <filename>/etc/resolv.conf</filename>
	  でネームサーバが指定されていない場合),  ppp
	  はプロバイダが指定したアドレスで
	  <filename>resolv.conf</filename> を書きかえます. </para>
      </sect3>
    </sect2>

    <sect2>
      <title><command>ppp</command> の設定</title>

      <para>ユーザ ppp と <command>pppd</command> (カーネルレベルの
	PPP 実装) は どちらも <filename>/etc/ppp</filename>
	ディレクトリに置かれた設定ファイルを使います.
	ここには設定ファイルのサンプルが用意されていて, ユーザ ppp
	の設定を おこなう際に大変参考になりますので,
	削除したりしないでください.</para>

      <para><command>ppp</command> の設定をするためには,
	必要に応じていくつかのファイルを編集する必要が あります.
	書き込む内容は, プロバイダが静的に IP アドレスを割り当てる
	(つまり, 固定の IP アドレスを一つ与えられて, 常にそれを使う)
	か,  または動的に IP アドレスを割り当てる (つまり, PPP
	セッションごとに  IP アドレスが変化する可能性がある)
	かということに ある程度依存します.</para>

      <sect3 id="userppp-staticIP">
	<title>静的 IP アドレスによる PPP 接続</title>

	<para>まず <filename>/etc/ppp/ppp.conf</filename>
	  という設定ファイルを作成する必要があります.
	  これは以下の例とほとんど同じようなものになるでしょう.</para>

	<note>
	  <para><literal>:</literal> で終る行は  1 カラム目から始め,
	    その他の行はスペースまたはタブで以下の例のように
	    段をつける (インデントする) 必要があります.</para>
	</note>

	<programlisting>
1     default:
2       set device /dev/cuaa0
3       set speed 115200
4       set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" ATE1Q0 OK-AT-OK
\\dATDT\\T TIMEOUT 40 CONNECT"
5     provider:
6       set phone "(0123) 456 7890"
7       set login "TIMEOUT 10 \"\" \"\" gin:-BREAK-gin: foo word: bar col: ppp"
8       set timeout 300
9       set ifaddr <replaceable>x.x.x.x</replaceable> <replaceable>y.y.y.y</replaceable> 255.255.255.0 0.0.0.0
10      add default HISADDR
11      enable dns</programlisting>

	<para>ファイルでは行番号を取り除いておいてください.
	  これは解説の際に参照する行を示すためにつけたものです.</para>

	<variablelist>
	  <varlistentry><term>Line 1:</term>
	    <listitem>
	      <para>デフォルトエントリを指定します.
		このエントリ中のコマンドは ppp
		が起動された際に自動的に実行されます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 2:</term>
	    <listitem>
	      <para>モデムが接続されているデバイスを指定します.
		<devicename>COM1:</devicename> は
		<filename>/dev/cuaa0</filename> に,
		<devicename>COM2:</devicename> は
		<filename>/dev/cuaa1</filename> になります.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 3:</term>
	    <listitem>
	      <para>通信速度 (DTE 速度) を指定します. もし 115200
		が使えない (最近のモデムなら大抵使えるはずですが)
		場合には,  かわりに 38400
		を指定してみてください.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 4:</term>
	    <listitem>
	      <para>ダイアルスクリプトを指定します.  ユーザ PPP は
		  &man.chat.8; 言語に似た, 受信待ち文字列と
		送信文字列の対からなるスクリプトを使用します.
		この言語の機能に関しては,
		マニュアルページを参照してください.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 5:</term>
	    <listitem>
	      <para>接続するプロバイダの名前 &ldquo;provider&rdquo; を
		エントリ名として指定します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 6:</term>
	    <listitem>
	      <para>このプロバイダの電話番号を指定します.
		複数の電話番号を  <literal>:</literal> や
		<literal>|</literal> で区切って指定することができます.
		これら区切り文字の違いについては, &man.ppp.8
		に 詳しく書かれています.
		要約すると, 毎回違う番号に かけたいのであれば
		<literal>:</literal> を使います.  常に
		まず先頭の番号にかけてみて, つながらない時にだけ  2
		番目以降の番号に かけたいのであれば
		<literal>|</literal> を使います.
		例に示されているように, 常に電話番号全体を引用符で
		くくって (クォートして) おきます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 7:</term>
	    <listitem>
	      <para>ダイアルスクリプトと同様に, ログインスクリプトも
		chat 言語風の記述をおこないます.  この例は,
		以下のようなログインセッションを使用する
		プロバイダのためのものです:</para>

	      <screen>   J. Random Provider
login: <replaceable>foo</replaceable>
password: <replaceable>bar</replaceable>
protocol: ppp</screen>

	      <para>このスクリプトは必要に応じて
		書きかえなければならないでしょう.
		初めてスクリプトを書く時には, 予想した通りに
		処理が進んだかどうかを確認するため, &ldquo;chat&rdquo;
		ログを とるようにしておいた方が良いでしょう. </para>

	      <para>PAP や CHAP を使用する場合には,
		ここでログインすることは  ありませんから,
		ログイン文字列は空白のままにしておくべきです.
		詳細については <link linkend="userppp-PAPnCHAP">PAP
		  および CHAP
		  による認証</link>を参照してください.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 8:</term>
	    <listitem>
	      <para>デフォルトの接続タイムアウト時間を (秒数で)
		指定します.  この例では, 300 秒間
		通信がおこなわれなければ
		自動的に接続を切るように指定しています.
		タイムアウトさせたくない場合には, この値を 0
		に設定します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 9:</term>
	    <listitem>
	      <para>インターフェースのアドレスを指定します. 文字列
		<replaceable>x.x.x.x</replaceable> は
		プロバイダに割り当てられた IP
		アドレスで置きかえてください.  文字列
		<replaceable>y.y.y.y</replaceable>
		はプロバイダから指示されたゲートウェイ
		(接続先となるマシン) の IP
		アドレスで置きかえてください.
		プロバイダがゲートウェイのアドレスを
		指示していない場合は,  <hostid
		  role="netmask">10.0.0.2/0</hostid>
		を使用しておいてください. もし&ldquo;仮の&rdquo;
		アドレスを使用する必要がある場合には,  <link
		  linkend="userppp-dynamicIP">動的 IP アドレスによる
		  PPP 接続</link>に関する指示に従って,
		<filename>/etc/ppp/ppp.linkup</filename>
		にエントリを作成していることを 確認してください.
		この行が省略されている場合, ppp を
		<option>-auto</option>
		モードで動作させることはできません. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 10:</term>
	    <listitem>
	      <para>プロバイダのゲートウェイへの経路を
		デフォルトルートとして 追加します. 特殊文字列
		<literal>HISADDR</literal> は, 9 行目で指定された
		ゲートウェイのアドレスで置きかえられます.
		<literal>HISADDR</literal> は 9
		行目までは初期化されていませんので,
		その行よりも後でしか使えないことに
		注意してください.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 11:</term>
	    <listitem>
	      <para>ネームサーバのアドレスが正しいか
		どうかを確認するため,
		プロバイダに問い合わせをおこなうよう ppp に指示します.
		プロバイダがこの機能をサポートしていれば, ppp は
		<filename>/etc/resolv.conf</filename>
		のネームサーバエントリを
		正しいアドレスに更新することができます. </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>静的な IP アドレスを持っていて,
	  接続が完了する前にルーティングテーブルの
	  エントリが正しく設定されているのであれば,
	  <filename>ppp.linkup</filename> に
	  エントリを追加する必要はありません.  しかし,
	  この場合でもエントリを追加して, 接続が完了した時点で
	  プログラムを呼び出したいことがあるかもしれません.
	  これについては後ほど sendmail を例として説明します.</para>

	<para>これらの設定ファイルのサンプルが
	  <filename>/etc/ppp</filename> ディレクトリに
	  置かれています.</para>
      </sect3>

      <sect3 id="userppp-dynamicIP">
	<title>動的 IP アドレスによる PPP 接続</title>

	<para>プロバイダが静的な IP
	  アドレスの割り当てをおこなっていない場合,
	  <command>ppp</command> が相手側のホスト (ゲートウェイ)
	  と交渉して, こちら側と相手側のアドレスを
	  決めるように設定することができます.  これは,
	  起動時には&ldquo;仮の&rdquo;アドレスを使っておいて,
	  接続後に IP コンフィグレーション プロトコル (IPCP)
	  を使用して <command>ppp</command> が IP
	  アドレスを正しく設定できるようにすることで実現されます.
	  <link linkend="userppp-staticIP">静的 IP アドレスによる PPP
	    接続</link>に 以下の変更を加える以外は,
	  <filename>ppp.conf</filename> の設定は同じです:</para>

	<programlisting>
9       set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0</programlisting>

	<para>繰り返しますが, 行番号は取り除いておいてください.
	  これは解説の際に参照する行を示すためにつけたものです.  なお,
	  少なくともスペース 1 個分の段づけ (インデント)
	  が必要です.</para>

	<variablelist>
	  <varlistentry><term>Line 9:</term>
	    <listitem>
	      <para><literal>/</literal> 文字の後ろの数字は,
		アドレス交渉の際に固定しておきたい ビットの数です.
		場合によっては, もっと適切な IP アドレスを
		指定しておきたいこともあるかもしれませんが,
		ほとんどの場合には 上の例の通りで問題ありません.
	      </para>

	      <para>最後の引数 (<literal>0.0.0.0</literal>) は,
		アドレスの交渉の際に <hostid
		  role="ipaddr">10.0.0.1</hostid> ではなく <hostid
		  role="ipaddr">0.0.0.0</hostid> を使用するよう ppp
		に指示するためのものです.  <command>set
		  ifaddr</command> コマンドの最初の引数として
		<literal>0.0.0.0</literal> を指定してはいけません.
		さもないと, <option>-auto</option>
		モードで動作させる際に
		初期経路を設定することができなくなります. </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>バージョン 1.X の ppp を使用する場合,
	  <filename>/etc/ppp/ppp.linkup</filename>
	  にもエントリを作成しておく必要があります.
	  <filename>ppp.linkup</filename>
	  は接続が確立された後に使用されます. この時点では,
	  <command>ppp</command> は<emphasis>実際に</emphasis>どの IP
	  アドレスを使うべきなのか わかっているはずです.
	  以下のエントリは存在する仮の経路を削除し,
	  正しい経路を作成します:</para>

	<programlisting>
1     provider:
2       delete ALL
3       add default HISADDR</programlisting>

	<variablelist>
	  <varlistentry><term>Line 1:</term>
	    <listitem>
	      <para>接続を確立する際に, <command>ppp</command>
		は以下のルールに従って
		<filename>ppp.linkup</filename>
		のエントリを検索します:  まず
		<filename>ppp.conf</filename>
		で使用されたのと同じラベルを探します.
		もし見つからなければ, ゲートウェイの IP
		アドレスのエントリを 探します. このエントリは 4
		オクテットの IP アドレス形式の ラベルです. それでも
		まだエントリが見つからなければ,
		<literal>MYADDR</literal> エントリを探します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 2:</term>
	    <listitem>
	      <para>この行は, 使用する tun
		インターフェースに関する既存の経路を
		(ダイレクトルートのエントリを除き) すべて削除するよう
		<command>ppp</command> に指示します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 3:</term>
	    <listitem>
	      <para>この行は <literal>HISADDR</literal>
		への経路をデフォルトルートとして 追加するように ppp
		に指示します. <literal>HISADDR</literal> は IPCP で
		決定されたゲートウェイの IP
		アドレスで置きかえられます.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>詳細なサンプルについては,
	  <filename>/etc/ppp/ppp.conf.sample</filename> ファイル中の
	  pmdemand エントリと
	  <filename>/etc/ppp/ppp.linkup.sample</filename>
	  を参照してください.</para>

	<para>バージョン 2 の ppp から &ldquo;sticky routes&rdquo;
	  が導入されました.  <literal>MYADDR</literal> や
	  <literal>HISADDR</literal> を含む <literal>add</literal>
	  コマンドと  <literal>delete</literal> コマンドを記憶して,
	  <literal>MYADDR</literal> や <literal>HISADDR</literal> の
	  アドレスが変化した際には経路の再設定をおこないます.
	  したがって, これらのコマンドを
	  <filename>ppp.linkup</filename> に
	  繰り返し記述する必要は無くなりました. </para>
      </sect3>

      <sect3>
	<title>かかってきた電話を <command>ppp</command>
	  で受けるには</title>

	<para>このセクションでは <command>ppp</command>
	  をサーバとして設定する方法について説明します.</para>

	<para>かかってきた電話を <command>ppp</command>
	  が受けるように設定する際に,  そのマシンが LAN
	  に接続されているのであれば,  パケットを LAN
	  に転送するかどうかを決定する必要があります.
	  転送をおこなう場合には, その LAN のサブネットから IP
	  アドレスを ppp クライアントに割り当て,
	  以下のコマンドを指定するのが良いでしょう. </para>

	<programlisting>
enable proxy</programlisting>

	<para>また, <filename>/etc/rc.conf</filename>
	  に以下のオプションが指定してあることを
	  確認しておいてください. (以前のバージョンの FreeBSD では,
	  このファイルは <filename>/etc/sysconfig</filename>
	  と呼ばれていました):
	</para>

	<programlisting>
gateway_enable=YES</programlisting>

	<sect4>
	  <title>どの getty を使いますか?</title>

	  <para>getty
	    でダイアルアップサービスをおこなう場合の優れた解説が <link
	      linkend="dialup">FreeBSD
	      でダイアルアップサービスをおこなうための設定
	    </link>にあります.</para>

	  <para><command>getty</command> に代わるものとしては,  <ulink
	      URL="http://www.leo.org/~doering/mgetty/index.html">
	      mgetty</ulink> があります. これは
	    <command>getty</command> をより柔軟にしたもので,
	    ダイアルアップ回線での使用を意図して
	    設計されています.</para>

	  <para><command>mgetty</command> を使う場合の利点は,
	    <command>mgetty</command>
	    が積極的にモデムと<emphasis>通信する</emphasis>
	    ということです. つまり, もし
	    <filename>/etc/ttys</filename> でポートを閉じている場合,
	    モデムは電話をとらなくなります.</para>

	  <para>最近のバージョンの <command>mgetty</command> (0.99beta
	    以降) では, PPP ストリームの
	    自動検出もサポートされています. これにより,
	    クライアント側で スクリプトを準備しなくてもサーバに
	    アクセスすることができます.</para>

	  <para><command>mgetty</command> に関する,
	    より詳細な情報については <link
	      linkend="userppp-mgetty">Mgetty と AutoPPP</link>
	    を参照してください.</para>
	</sect4>

	<sect4>
	  <title>ppp の実行許可</title>

	  <para><command>ppp</command> は通常, ID 0 のユーザ (root)
	    として動作しなければいけませんが,  以下で説明するように,
	    <command>ppp</command>
	    を通常のユーザとしてサーバモードで実行させたい 場合には,
	    そのユーザを <filename>/etc/group</filename> の
	    <username>network</username> グループに 追加して, ppp
	    を実行する許可を与えておかなければいけません.</para>

	  <para>また, そのユーザが設定ファイル内の目的のエントリに
	    アクセスできるように,  以下のように
	    <command>allow</command>
	    コマンドで許可を与えておく必要があります: </para>

	  <programlisting>
allow users fred mary</programlisting>

	  <para>このコマンドがデフォルトエントリに
	    書かれている場合には, 指定されたユーザは
	    すべてのエントリをアクセスできるようになります.</para>
	</sect4>

	<sect4>
	  <title>動的 IP ユーザのための ppp シェルの設定</title>

	  <para><filename>/etc/ppp/ppp-shell</filename> という名前で,
	    以下のような内容のファイルを 作成します:</para>

	  <programlisting>
#!/bin/sh
IDENT=`echo $0 | sed -e 's/^.*-\(.*\)$/\1/'`
CALLEDAS="$IDENT"
TTY=`tty`

if [ x$IDENT = xdialup ]; then
	IDENT=`basename $TTY`
fi

echo "PPP for $CALLEDAS on $TTY"
echo "Starting PPP for $IDENT"

exec /usr/sbin/ppp -direct $IDENT</programlisting>

	  <para>このスクリプトには実行可能属性をつけておきます.  次に,
	    以下のコマンドを実行し, <filename>ppp-dialup</filename>
	    という名前で このスクリプトへのリンクを作成します:</para>

	  <screen>&prompt.root; <userinput>ln -s ppp-shell /etc/ppp/ppp-dialup</userinput></screen>

	  <para>すべてのダイアルアップ ppp
	    ユーザのログイン<emphasis>シェル</emphasis>として
	    このスクリプトを使用します. 以下は
	    <username>pchilds</username> というユーザ名の
	    ダイアルアップユーザを <filename>/etc/password</filename>
	    へ登録した場合の例です.
	    (パスワードファイルを直接エディタで編集したりせず,
	    <command>vipw</command> を使ってください)</para>

	  <programlisting>
pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup</programlisting>

	  <para>任意のユーザが読むことのできる,
	    <filename>/home/ppp</filename> ディレクトリを 作成します.
	    <filename>/etc/motd</filename>
	    が表示されないようにするため,
	    このディレクトリには以下のように大きさが 0
	    バイトのファイルを 作成しておきます.</para>

	  <screen>-r--r--r--   1 root     wheel           0 May 27 02:23 .hushlogin
-r--r--r--   1 root     wheel           0 May 27 02:22 .rhosts</screen>
	</sect4>

	<sect4>
	  <title>静的 IP ユーザのための PPP シェルの設定</title>

	  <para>上記と同じように <filename>ppp-shell</filename>
	    ファイルを作成し,  静的な IP
	    アドレスを割り当てるアカウントそれぞれについて
	    <filename>ppp-shell</filename>
	    へのシンボリックリンクを作成します.</para>

	  <para>例えば, クラス C ネットワークの経路制御を必要とする,
	    三人のダイアルアップユーザ <username>fred</username>,
	    <username>sam</username>, <username>mary</username>
	    がいるとすると,
	    以下のコマンドを実行することになります:</para>

	  <screen>&prompt.root; <userinput>ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred</userinput>
&prompt.root; <userinput>ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam</userinput>
&prompt.root; <userinput>ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary</userinput></screen>

	  <para>これらのユーザのダイアルアップアカウントでは,
	    上で作成した それぞれのシンボリックリンクを
	    ログインシェルとして設定しておきます.  (つまり, ユーザ
	    <username>mary</username> のログインシェルは
	    <filename>/etc/ppp/ppp-mary</filename> に
	    なります).</para>
	</sect4>

	<sect4>
	  <title>動的 IP ユーザのための ppp.conf の設定</title>

	  <para><filename>/etc/ppp/ppp.conf</filename> ファイルは,
	    大体以下のような内容になるでしょう:</para>

	  <programlisting>
default:
  set debug phase lcp chat
  set timeout 0

ttyd0:
  set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
  enable proxy

ttyd1:
  set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
  enable proxy</programlisting>

	  <!-- kuriyama - remove Japanese "NOTE"ing -->
	  <note>
	    <para>上の例のように段をつける (インデントする)
	      必要があることに注意してください.</para>
	  </note>

	  <para><literal>default:</literal>
	    エントリはセッションごとにロードされます.
	    <filename>/etc/ttys</filename>
	    で有効にしてある各ダイアルアップ回線ごとに一つ,  上記の
	    <literal>ttyd0:</literal> のようなエントリを作成します.
	    各行の相手側アドレスとして, それぞれ別の IP アドレスを
	    動的 IP ユーザのための IP
	    アドレスのプールから割り当てておく必要があります.</para>
	</sect4>

	<sect4>
	  <title>静的 IP ユーザのための <filename>ppp.conf</filename>
	    の設定</title>

	  <para>上のサンプルの <filename>/etc/ppp/ppp.conf</filename>
	    の内容に加えて,  静的に IP
	    を割り当てられたダイアルアップユーザ
	    それぞれのためのエントリを追加する必要があります.
	    ここでも <username>fred</username>,
	    <username>sam</username>, <username>mary</username>
	    の例を使うことにしましょう.</para>

	  <programlisting>
fred:
  set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255
 
sam:
  set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255
 
mary:
  set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255</programlisting>

	  <para>必要であれば, それぞれの静的 IP
	    ユーザに対する経路制御情報も
	    <filename>/etc/ppp/ppp.linkup</filename>
	    ファイルに書いておくべきでしょう.
	    以下の例ではクライアントの PPP リンクを経由する,  クラス C
	    の <hostid role="ipaddr">203.14.101.0</hostid>
	    ネットワークへの経路を追加しています.</para>

	  <programlisting>
fred:
  add 203.14.101.0 netmask 255.255.255.0 HISADDR
 
sam:
  add 203.14.102.0 netmask 255.255.255.0 HISADDR
 
mary:
  add 203.14.103.0 netmask 255.255.255.0 HISADDR</programlisting>
	</sect4>

	<sect4>
	  <title><command>mgetty</command>, AutoPPP,
	    マイクロソフト拡張の詳細</title>

	  <sect5 id="userppp-mgetty">
	    <title><command>mgetty</command> と AutoPPP</title>

	    <para><literal>AUTO_PPP</literal>
	      オプションつきでコンパイルした <command>mgetty</command>
	      を使えば, <command>mgetty</command> が PPP 接続の LCP
	      フェーズを検出して, 自動的に PPP シェルを起動するように
	      設定することができます.  しかし この場合, デフォルトの
	      login/password シーケンスは発生しないので,
	      ユーザの認証は PAP または CHAP
	      を使っておこなう必要があります.</para>

	    <para>このセクションでは, ユーザ (あなた) が問題なく
	      <literal>AUTO_PPP</literal> オプションつきの
	      <command>mgetty</command> (v0.99beta またはそれ以降)
	      の設定,  コンパイル,
	      インストールができているものと仮定しています.</para>

	    <para><filename>
		/usr/local/etc/mgetty+sendfax/login.config</filename>
	      ファイルが
	      以下の行を含んでいることを確認してください:</para>

	    <programlisting>
/AutoPPP/ -     -       /etc/ppp/ppp-pap-dialup</programlisting>

	    <para>これにより, PPP 接続を検出したら
	      <command>mgetty</command> が
	      <filename>ppp-pap-dialup</filename>
	      スクリプトを実行するようになります.</para>

	    <para><filename>/etc/ppp/ppp-pap-dialup</filename>
	      という名前で, 以下のような内容のファイルを 作成します
	      (このファイルには実行可能属性を
	      つけておく必要があります):</para>

	    <!-- kuriyama - en and ja are different with blank line. -->
	    <programlisting>
#!/bin/sh
exec /usr/sbin/ppp -direct pap</programlisting>

	    <para>さらに, かかってきた電話すべてを自分で扱うエントリを
	      <filename>/etc/ppp/ppp.conf</filename>
	      に作成します.</para>

	    <programlisting>
pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</programlisting>

	    <para>この方法でログインする それぞれのユーザは, PAP
	      によるユーザ認証を おこなうために
	      <filename>/etc/ppp/ppp.secret</filename>
	      ファイルにユーザ名とパスワードを 書いておくか, または
	      <filename>/etc/password</filename>
	      ファイルを使うように,</para>

	    <programlisting>
enable passwdauth</programlisting>

	    <para>オプションを (/etc/ppp/ppp.conf に)
	      追加しておく必要があるでしょう.</para>

	    <para>ユーザに静的な IP アドレスを割り当てる場合には,
	      そのアドレスを  <filename>/etc/ppp/ppp.secret</filename>
	      の第三引数として指定することができます.
	      サンプルについては,
	      <filename>/etc/ppp/ppp.secret.sample</filename>
	      を参照してください.</para>
	  </sect5>

	  <sect5>
	    <title>マイクロソフト拡張</title>

	    <para>クライアントからの要求に応じて, ppp が DNS や
	      NetBIOS ネームサーバの アドレスを通知するように
	      設定をおこなうこともできます.</para>

	    <para>これらの拡張機能を
	      <filename>/etc/ppp/ppp.conf</filename>
	      ファイルで有効にした例を 以下に示します.</para>

	    <para>バージョン 1.X の ppp で
	      これらの拡張機能を有効にするには, 以下の行を
	      <filename>/etc/ppp/ppp.conf</filename>
	      の適切なセクションに追加する必要があるでしょう. </para>

	    <programlisting>
  enable msext
  set ns 203.14.100.1 203.14.100.2
  set nbns 203.14.100.5</programlisting>

	    <para>バージョン 2 以降の ppp では,
	      以下のようになります:</para>

	    <programlisting>
accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</programlisting>

	    <para>これにより, クライアントはプライマリと
	      セカンダリのネームサーバアドレス および NetBIOS
	      ネームサーバホストを知ることができます.</para>

	    <para>バージョン 2 以降の ppp では, <literal>set
		dns</literal> の行を省略した場合には
	      <filename>/etc/resolv.conf</filename>
	      に書かれているネームサーバのアドレスを使用します.
	    </para>
	  </sect5>
	</sect4>
      </sect3>

      <sect3 id="userppp-PAPnCHAP">
	<title>PAP および CHAP による認証</title>

	<para>いくつかのプロバイダでは, PAP または CHAP
	  のいずれかの認証メカニズムを
	  使用して接続時の認証をおこなうように
	  システムを設定しています.  この場合, プロバイダは接続の際に
	  <prompt>login:</prompt> プロンプトを送信せず,  最初から PPP
	  で通信を始めようとするでしょう.</para>

	<para>PAP ではパスワードがそのまま送られてしまうため, CHAP
	  に比べると安全性が 低くなりますが,
	  このパスワードはシリアル回線のみを通して送られます.
	  そのため,
	  クラッカーが&ldquo;盗み聞き&rdquo;する余地は多くないので,
	  通常ここの セキュリティは問題にはなりません.</para>

	<para><link linkend="userppp-staticIP">静的 IP アドレスによる
	    PPP 接続</link>または <link
	    linkend="userppp-dynamicIP">動的 IP アドレスによる PPP
	    接続</link>の セクションに戻って,
	  以下の変更をおこないます:</para>

	<programlisting>
7       set login
&hellip;
12      set authname <replaceable>MyUserName</replaceable>
13      set authkey <replaceable>MyPassword</replaceable></programlisting>

	<para>これまでと同様に, 行番号は取り除いておいてください.
	  これは解説の際に参照する行を示すためにつけたものです.  なお,
	  少なくともスペース 1 個分の段づけ (インデント)
	  が必要です.</para>

	<variablelist>
	  <varlistentry><term>Line 7:</term>
	    <listitem>
	      <para>PAP または CHAP を使用する場合, 通常
		プロバイダはサーバへの ログインを必要としません.
		そのため, "set login" 文字列を
		無効にしておかなければいけません.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 12:</term>
	    <listitem>
	      <para>この行は PAP/CHAP ユーザ名を指定します.
		<replaceable>MyUserName</replaceable> に
		正しい値を入れておく必要があります.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Line 13:</term>
	    <listitem>
	      <para>この行は PAP/CHAP パスワードを指定します.
		<replaceable>MyPassword</replaceable> に
		正しい値を入れておく必要があります.
		PAP と CHAP はデフォルトで両方とも
		受け付けられるようになって
		いますが, PAP や CHAP を使用するという
		意思を明示するために,

		<programlisting>
15      accept PAP</programlisting>

		または

		<programlisting>
15      accept CHAP</programlisting>

		という行を追加しておくのも良いでしょう.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>動作中の ppp の設定変更</title>

	<para>適切な診断ポートが設定されている場合には,
	  バックグラウンドで動作中の  <command>ppp</command>
	  プログラムと通信することができます.
	  この設定をおこなうためには,
	  以下の行を設定ファイルに追加しておきます: </para>

	<programlisting>
set server /var/run/ppp-tun%d DiagnosticPassword 0177</programlisting>

	<para>これにより, ppp は指定された unix ドメインの
	  ソケットをモニタして,
	  クライアントから正しいパスワードを受け取った後に
	  アクセスを許可します.  このソケット名に含まれる
	  <literal>%d</literal> は, この ppp が使用している
	  <devicename>tun</devicename>
	  デバイスの デバイス番号で置きかえられます.</para>

	<para>一旦ソケットの設定が終了したら, スクリプト中で
	  &man.pppctl.8; を 使用して, 動作中の ppp
	  を操作することができるでしょう.</para>
      </sect3>
    </sect2>

    <sect2 id="userppp-final">
      <title>システムの最終設定</title>

      <para>これで <command>ppp</command> の設定は終りました.  しかし
	<command>ppp</command> を動かす前に,
	まだ少し必要なことがあります.  それらの設定は, すべて
	<filename>/etc/rc.conf</filename> ファイルを
	編集することでおこないます.  (このファイルは以前には
	<filename>/etc/sysconfig</filename> と呼ばれていました)</para>

      <para>このファイルを上から順に設定していきます.  まずは
	<literal>hostname=</literal>
	の行が設定されていることを確認します.
	例えば以下のように:</para>

      <programlisting>
hostname=foo.bar.com</programlisting>

      <para>もしプロバイダが静的な IP
	アドレスとホスト名を割り当てているのなら,
	ホスト名としてそれを使うのが おそらくベストでしょう.</para>

      <para>次に <literal>network_interfaces</literal> 変数を調べます.
	必要に応じて (on demand)
	プロバイダにダイアルするようにシステムを設定したい場合には,
	<devicename>tun0</devicename>
	デバイスがこのリストに追加されていることを確認しておきます.
	それ以外の場合には, tun0
	デバイスをリストから削除しておきます.</para>

      <!-- kuriyama - en needs break line -->
      <programlisting>
network_interfaces="lo0 tun0"
ifconfig_tun0=</programlisting>

      <note>
	<para><literal>ifconfig_tun0</literal> 変数が空で,
	  <filename>/etc/start_if.tun0</filename> という名前の
	  ファイルが作成されていなければなりません.
	  このファイルの内容は以下のようになります.</para>

	<programlisting>
ppp -auto mysystem</programlisting>

	<para>このスクリプトはネットワークの設定時に実行され,  ppp
	  デーモンを自動モードで立ち上げます.  このマシンがもし LAN
	  のゲートウェイであれば,  <option>-alias</option>
	  スイッチも使用したいと思うかもしれません.  詳細に関しては,
	  マニュアルページを参照してください.</para>
      </note>

      <para>以下のようにルータプログラムを <literal>NO</literal>
	に設定します.</para>

      <programlisting>
router_enable=NO            (/etc/rc.conf)
router=NO                   (/etc/sysconfig)</programlisting>

      <para><command>routed</command> は, <command>ppp</command>
	が作成したデフォルトのルーティングテーブル
	エントリを削除してしまう場合がありますので,
	(初期設定では起動されるようになっている)
	<command>routed</command> デーモンが
	起動されないようにしておくことが重要です.</para>

      <para><literal>sendmail_flags</literal> 行が <option>-q</option>
	オプションを含まないように 設定しておいた方がよいでしょう.
	さもないと, <command>sendmail</command> が
	アドレスを調べようとして発信をおこなってしまう場合があります.
	以下のような設定で良いでしょう:</para>

      <programlisting>
sendmail_flags="-bd"</programlisting>

      <para>この結果, PPP リンクを立ち上げた時には
	いつでも以下のコマンドを実行して, キューにたまっているメールを
	<command>sendmail</command>
	に送信させる作業が必要になるでしょう.</para>

      <screen>&prompt.root; <userinput>/usr/sbin/sendmail -q</userinput></screen>

      <para><filename>ppp.linkup</filename> 中で
	<command>!bg</command> コマンドを使用することで,
	これを自動的に おこなうこともできます:</para>

      <programlisting>
1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</programlisting>

      <para>こうするのが嫌であれば, SMTP
	トラフィックをブロックするように &ldquo;dfilter&rdquo;
	を設定しておくこともできます.
	詳細についてはサンプルファイルを参照してください.</para>

      <para>後はマシンをリブートするだけです.</para>

      <para>リブートが終ったら,</para>

      <screen>&prompt.root; <userinput>ppp</userinput></screen>

      <para>コマンドを実行し, 続いて PPP セッションを開始させるために
	<command>dial provider</command> と入力することもできますし,
	(<filename>start_if.tun0</filename>
	スクリプトを作成していない場合に),
	外部へのトラフィックが発生した時に, <command>ppp</command>
	が自動的に セッションを確立してくれるようにしたいのであれば,
	以下のコマンドを実行することもできます.</para>

      <screen>&prompt.root; <userinput>ppp -auto provider</userinput></screen>
    </sect2>

    <sect2>
      <title>まとめ</title>

      <para>要約すると, 初めて ppp を設定する際には,
	以下のステップが不可欠です:</para>

      <para>クライアント側:</para>

      <procedure>
	<step>
	  <para>カーネルに <devicename>tun</devicename>
	    デバイスが組み込まれていることを確認.</para>
	</step>

	<step>
	  <para><filename>/dev</filename> ディレクトリに
	    <filename>tun<replaceable>X</replaceable></filename>
	    デバイスファイルが 存在することを確認.</para>
	</step>

	<step>
	  <para><filename>/etc/ppp/ppp.conf</filename>
	    にエントリを作成.  ほとんどのプロバイダでは,
	    <filename>pmdemand</filename> の例で充分でしょう.</para>
	</step>

	<step>
	  <para>動的 IP アドレスを使用するなら,
	    <filename>/etc/ppp/ppp.linkup</filename> に
	    エントリを作成.</para>
	</step>

	<step>
	  <para><filename>/etc/rc.conf</filename> (または
	    <filename>sysconfig</filename>) ファイルを更新.</para>
	</step>

	<step>
	  <para>必要に応じてダイヤル (demand dialing)
	    したいのであれば,  <filename>start_if.tun0</filename>
	    スクリプトを作成.</para>
	</step>
      </procedure>

      <para>サーバ側:</para>

      <procedure>
	<step>
	  <para>カーネルに <devicename>tun</devicename>
	    デバイスが組み込まれていることを確認.</para>
	</step>

	<step>
	  <para><filename>/dev</filename> ディレクトリに
	    <filename>tun<replaceable>X</replaceable></filename>
	    デバイスファイルが 存在することを確認.</para>
	</step>

	<step>
	  <para>(&man.vipw.8; コマンドを使って)
	    <filename>/etc/passwd</filename> にエントリを作成.</para>
	</step>

	<step>
	  <para>このユーザのホームディレクトリに <command>ppp -direct
	      direct-server</command>
	    か何かを実行するプロファイルを作成.</para>
	</step>

	<step>
	  <para><filename>/etc/ppp/ppp.conf</filename>
	    にエントリを作成.  <filename>direct-server</filename>
	    の例で充分でしょう.</para>
	</step>

	<step>
	  <para><filename>/etc/ppp/ppp.linkup</filename>
	    にエントリを作成.</para>
	</step>

	<step>
	  <para><filename>/etc/rc.conf</filename> (または <emphasis
	      remap=tt>sysconfig</emphasis>) ファイルを更新.</para>
	</step>
	<!-- kuriyama - remap=tt? -->
      </procedure>
    </sect2>

    <sect2>
      <title>謝辞</title>

      <para>ハンドブックの このセクションは, 1998 年 8 月 10 日 (月)
	に &a.brian; によって 更新されました.</para>

      <para>以下の人々による情報提供, 批評そして提案に感謝します:</para>

      <para>&a.nik;</para>

      <para>&a.dirkvangulik;</para>

      <para>&a.pjc;</para>
    </sect2>
  </sect1>

  <sect1 id="ppp">
    <title>カーネル PPP の設定</title>

    <para><emphasis>原作: &a.gena;.</emphasis></para>

    <para><emphasis>訳: &a.jp.graphite;.<!-- <br> -->
	6 September 1996.</emphasis></para>

    <para>PPP の設定を始める前に, <command>pppd</command> が
      <filename>/usr/sbin</filename> にあり, また
      <filename>/etc/ppp</filename> という
      ディレクトリが存在することを確認してください.</para>

    <para><command>pppd</command> はふたつのモードで動作します.</para>

    <orderedlist>
      <listitem>
	<para>&ldquo;クライアント&rdquo;モード.
	  シリアル接続やモデムを利用して, そのマシンを
	  外部のネットワークに PPP 接続したい場合に用います.</para>
      </listitem>

      <listitem>
	<para>&ldquo;サーバ&rdquo;モード.
	  そのマシンがネットワーク上にあるときに, PPP を使って
	  ほかのコンピュータを接続する際に用います.</para>
      </listitem>
    </orderedlist>

    <para>どちらの場合でも, オプションファイルを設定する必要があります
      (<filename>/etc/ppp/options</filename> または, そのマシン上で
      PPP を使用する人が 複数いる場合には
      <filename>~/.ppprc</filename>).</para>

    <para>また, ダイヤルとリモートホストへの接続をおこなうために,
      シリアル接続やモデムを 操作する,
      なんらかのソフトウェアが必要です (kermit
      が適しているでしょう).</para>

    <sect2>
      <title>PPP クライアントとしての動作</title>

      <para>私は, CISCO ターミナルサーバの PPP 回線に接続するために,
	下記のような <filename>/etc/ppp/options</filename>
	を使用しています.</para>

      <programlisting>
crtscts		# enable hardware flow control
modem		# modem control line
noipdefault	# remote PPP server must supply your IP address.
		# if the remote host doesn't send your IP during IPCP
		# negotiation , remove this option
passive		# wait for LCP packets
domain ppp.foo.com	# put your domain name here

:&lt;remote_ip&gt;	# put the IP of remote PPP host here
		# it will be used to route packets via PPP link
		# if you didn't specified the noipdefault option
		# change this line to &lt;local_ip&gt;:&lt;remote_ip&gt;

defaultroute	# put this if you want that PPP server will be your
		# default router</programlisting>

      <para>接続方法:</para>

      <procedure>
	<step>
	  <para>kermit (またはその他のモデム操作プログラム)
	    を使ってリモートホストに ダイヤルし, 接続してください.
	    そして, あなたのユーザ名とパスワード (必要 であれば,
	    その他にもリモートホストで PPP を有効にするための操作)
	    を入力 します.</para>
	</step>

	<step>
	  <para>kermit を抜けてください. (回線を切断せずに)</para>
	</step>

	<step>
	  <para>下記のように入力します: </para>

	  <screen>&prompt.root; <userinput>/usr/src/usr.sbin/pppd.new/pppd <replaceable>/dev/tty01</replaceable> <replaceable>19200</replaceable></userinput></screen>

	  <para>(通信速度とデバイス名には,
	    あなたの環境に適したものを入れてください)</para>
	</step>
      </procedure>

      <para>これでこのコンピュータは PPP で接続されました. もし,
	なんらかの理由で 接続に失敗したならば,
	<filename>/etc/ppp/options</filename> ファイルに
	<option>debug</option>  オプションを追加して,
	問題点を突き止めるために, コンソールに表示される
	メッセージを調べてください.</para>

      <para>下記の <filename>/etc/ppp/pppup</filename> スクリプトは,
	上記の作業を すべて自動的におこないます:</para>

      <programlisting>
#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200</programlisting>

      <para><filename>/etc/ppp/kermit.dial</filename> は kermit
	用のスクリプトで, ダイヤルして,
	リモートホストでの認証に必要なすべての処理をおこないます.
	(そのようなスクリプトの例は
	この文書の終わりに添付してあります)</para>

      <para>PPP 接続を切断するには, 下記のような
	<filename>/etc/ppp/pppdown</filename> スクリプトを
	使用します:</para>

      <programlisting>
#!/bin/sh
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ X${pid} != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill -TERM ${pid}
fi

ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

/sbin/ifconfig ppp0 down
/sbin/ifconfig ppp0 delete
kermit -y /etc/ppp/kermit.hup
/etc/ppp/ppptest</programlisting>

      <para>PPP が動作中かどうかを調べます
	(<filename>/usr/etc/ppp/ppptest</filename>):</para>

      <programlisting>
#!/bin/sh
pid=`ps ax| grep pppd |grep -v grep|awk '{print $1;}'`
if [ X${pid} != "X" ] ; then
        echo 'pppd running: PID=' ${pid-NONE}
else
        echo 'No pppd running.'
fi
set -x
netstat -n -I ppp0
ifconfig ppp0</programlisting>

      <para>モデム回線を切断します
	(<filename>/etc/ppp/kermit.hup</filename>):</para>

      <programlisting>
set line /dev/tty01	; put your modem device here
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
echo \13
exit</programlisting>

      <para>次は <command>kermit</command> の代わりに
	<command>chat</command> を使う方法です.</para>

      <para><emphasis>原作: &a.rhuff;.</emphasis></para>

      <para>pppd 接続を確立するためには,
	次の二つのファイルの設定だけで十分です.</para>

      <para><filename>/etc/ppp/options</filename>:</para>

      <programlisting>
/dev/cuaa1 115200

crtscts		# enable hardware flow control
modem		# modem control line
connect "/usr/bin/chat -f /etc/ppp/login.chat.script"
noipdefault	# remote PPP server must supply your IP address.
		# if the remote host doesn't send your IP during
		# IPCP negotiation, remove this option
passive		# wait for LCP packets
domain &lt;your.domain&gt;	# put your domain name here

:		# put the IP of remote PPP host here
		# it will be used to route packets via PPP link
		# if you didn't specified the noipdefault option
		# change this line to &lt;local_ip&gt;:&lt;remote_ip&gt;

defaultroute	# put this if you want that PPP server will be
		# your default router</programlisting>

      <para><filename>/etc/ppp/login.chat.script</filename>:</para>

      <para>(実際には一行になります.)</para>

      <programlisting>
ABORT BUSY ABORT 'NO CARRIER' "" AT OK ATDT&lt;phone.number&gt;
 CONNECT "" TIMEOUT 10 ogin:-\\r-ogin: &lt;login-id&gt;
 TIMEOUT 5 sword: &lt;password&gt;</programlisting>

      <para>正しくインストールし編集した後は,
	必要な事はこれだけです</para>

      <screen>&prompt.root; <userinput>pppd</userinput></screen>

      <para>このサンプルは主に Trev Roydhouse
	&lt;Trev.Roydhouse@f401.n711.z3.fidonet.org&gt;
	から寄せられた情報に基づいており,
	承諾を得て使用しています.</para>
    </sect2>

    <sect2>
      <title>PPP サーバとしての動作</title>

      <para><filename>/etc/ppp/options</filename>:</para>

      <programlisting>
crtscts				# Hardware flow control
netmask 255.255.255.0		# netmask ( not required )
192.114.208.20:192.114.208.165  # ip's of local and remote hosts
				# local ip must be different from one
				# you assigned to the ethernet ( or other )
				# interface on your machine.
				# remote IP is ip address that will be
				# assigned to the remote machine
domain ppp.foo.com		# your domain
passive				# wait for LCP
modem				# modem line</programlisting>

      <para>下記のような <filename>/etc/ppp/pppserv</filename>
	スクリプトで, そのマシンを PPP
	サーバにすることができます.</para>

      <programlisting>
#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

# reset ppp interface
ifconfig ppp0 down
ifconfig ppp0 delete

# enable autoanswer mode
kermit -y /etc/ppp/kermit.ans

# run ppp
pppd /dev/tty01 19200</programlisting>

      <para>PPP サーバを終了するには, この
	<filename>/etc/ppp/pppservdown</filename> スクリプト
	を使用します:</para>

      <programlisting>
#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi
ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.noans</programlisting>

      <para>下記の kermit スクリプトは, モデムの自動応答機能を有効,
	または無効にします
	(<filename>/etc/ppp/kermit.ans</filename>):</para>

      <programlisting>
set line /dev/tty01
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
inp 5 OK
echo \13
out ATS0=1\13	; change this to out ATS0=0\13 if you want to disable
		; autoanswer mode
inp 5 OK
echo \13
exit</programlisting>

      <para>この <filename>/etc/ppp/kermit.dial</filename>
	スクリプトは, リモートホストに ダイヤルし,
	認証手続きをするのに使用します. あなたは必要に応じて, これを
	変更しないといけないでしょう.
	あなたのユーザ名とパスワードをこの
	スクリプトに書かなければいけませんし,
	モデムやリモートホストからの 応答によっては,
	入力待ちの文を変更する必要もあります.</para>

      <programlisting>
;
; put the com line attached to the modem here:
;
set line /dev/tty01
;
; put the modem speed here:
;
set speed 19200
set file type binary		; full 8 bit file xfer
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none
set modem hayes
set dial hangup off
set carrier auto		; Then SET CARRIER if necessary,
set dial display on		; Then SET DIAL if necessary,
set input echo on
set input timeout proceed
set input case ignore
def \%x 0			; login prompt counter
goto slhup

:slcmd				; put the modem in command mode
echo Put the modem in command mode.
clear				; Clear unread characters from input buffer
pause 1
output +++			; hayes escape sequence
input 1 OK\13\10		; wait for OK
if success goto slhup
output \13
pause 1
output at\13
input 1 OK\13\10
if fail goto slcmd		; if modem doesn't answer OK, try again

:slhup				; hang up the phone
clear				; Clear unread characters from input buffer
pause 1
echo Hanging up the phone.
output ath0\13			; hayes command for on hook
input 2 OK\13\10
if fail goto slcmd		; if no OK answer, put modem in command mode

:sldial				; dial the number
pause 1
echo Dialing.
output atdt9,550311\13\10		; put phone number here
assign \%x 0			; zero the time counter

:look
clear				; Clear unread characters from input buffer
increment \%x			; Count the seconds
input 1 {CONNECT }
if success goto sllogin
reinput 1 {NO CARRIER\13\10}
if success goto sldial
reinput 1 {NO DIALTONE\13\10}
if success goto slnodial
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 60 goto look
else goto slhup

:sllogin			; login
assign \%x 0			; zero the time counter
pause 1
echo Looking for login prompt.

:slloop
increment \%x			; Count the seconds
clear				; Clear unread characters from input buffer
output \13
;
; put your expected login prompt here:
;
input 1 {Username: }
if success goto sluid
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if &lt; \%x 10 goto slloop		; try 10 times to get a login prompt
else goto slhup			; hang up and start again if 10 failures

:sluid
;
; put your userid here:
;
output ppp-login\13
input 1 {Password: }
;
; put your password here:
;
output ppp-password\13
input 1 {Entering SLIP mode.}
echo
quit

:slnodial
echo \7No dialtone.  Check the telephone line!\7
exit 1

; local variables:
; mode: csh
; comment-start: "; "
; comment-start-skip: "; "
; end:</programlisting>
    </sect2>
  </sect1>

  <sect1 id="slipc">
    <title>SLIPクライアントのセットアップ</title>

    <para><emphasis>原作: &a.asami;<!-- <br> -->8 Aug 1995.</emphasis></para>

    <para><emphasis>訳: &a.hanai;<!-- <br> -->8 August 1996.</emphasis></para>

    <para>ここには FreeBSD
      マシンを静的アドレスのネットワークにつなげる場合の
      SLIPのセットアップの一つの方法を書いてあります.
      ホスト名を動的に割り当てる(つまり,
      ダイヤルアップするたびにアドレスが かわる)ためには,
      おそらくもっと凝ったことが必要です.</para>

    <para>まず,
      モデムがどのシリアルポートにつながっているか決めましょう. 私は
      <filename>/dev/cuaa1</filename> から
      <filename>/dev/modem</filename>へというシンボリックリンクを張り,
      コンフィグレーションではその名前だけを使っています.
      <filename>/etc</filename> や<filename>.kermrc</filename>
      など, システム全体に散らばっているファイルを修正する
      必要がでるとまったく煩わしいのです!</para>

    <note>
      <para>ここで, <filename>/dev/cuaa0</filename>は
	<devicename>COM1</devicename>であり,
	<filename>cuaa1</filename>は<devicename>COM2</devicename>です.</para>
    </note>

    <para>カーネルのコンフィグレーションファイルに

      <programlisting>
pseudo-device   sl      1</programlisting>

      という記述があるのを確認してください.
      これは <filename>GENERIC</filename> カーネルに含まれている
      ので削除していない限り大丈夫でしょう.</para>

    <sect2>
      <title>最初の設定</title>

      <procedure>
	<step>
	  <para><filename>/etc/hosts</filename>
	    ファイルにあなたのマシンのゲートウェイとネームサーバ
	    を加えてください.  私のは以下のようになっています.</para>

	  <programlisting>
127.0.0.1               localhost loghost
136.152.64.181          silvia.HIP.Berkeley.EDU silvia.HIP silvia

136.152.64.1            inr-3.Berkeley.EDU inr-3 slip-gateway
128.32.136.9            ns1.Berkeley.edu ns1
128.32.136.12           ns2.Berkeley.edu ns2</programlisting>

	  <para>余談ですが,
	    silviaというのは私が日本にいた時に持っていた
	    車の名前です(米国では2?0SXと呼ばれています).</para>
	</step>

	<step>
	  <para><filename>/etc/host.conf</filename> ファイル中で
	    <option>hosts</option>が<option>bind</option>
	    よりも前にあること を確認してください.
	    さもないとヘンなことが起こるかもしれません.</para>
	</step>

	<step>
	  <para><filename>/etc/rc.conf</filename>
	    ファイルを編集してください. なお, お使いの  FreeBSD が
	    2.2.2 よりも前のバージョンのものの場合は,
	    <filename>/etc/sysconfig</filename>
	    を編集してください.</para>

	  <orderedlist>
	    <listitem>
	      <para>行</para>

	      <programlisting>
hostname=myname.my.domain</programlisting>

	      <para>を編集してホスト名をセットしてください.
		完全なInternetホスト名を与えるべきです.</para>
	    </listitem>

	    <listitem>
	      <para>行</para>

	      <programlisting>
network_interfaces="lo0"</programlisting>

	      <para>を</para>

	      <programlisting>
network_interfaces="lo0 sl0"</programlisting>

	      <para>へ変更することにより
		ネットワークインタフェースのリストに sl0
		を加えてください.</para>
	    </listitem>

	    <listitem>
	      <para>行</para>

	      <programlisting>
ifconfig_sl0="inet ${hostname} slip-gateway netmask 0xffffff00 up"</programlisting>

	      <para>を加えて sl0
		のスタートアップフラグをセットしてください.</para>
	    </listitem>

	    <listitem>
	      <para>行</para>

	      <programlisting>
defaultrouter=NO</programlisting>

	      <para>を</para>

	      <programlisting>
defaultrouter=slip-gateway</programlisting>

	      <para>へ変更してデフォルトのルータを
		指定してください.</para>
	    </listitem>
	  </orderedlist>
	</step>

	<step>
	  <para>次の</para>

	  <programlisting>
domain HIP.Berkeley.EDU
nameserver 128.32.136.9
nameserver 128.32.136.12</programlisting>

	  <para>という内容を含むファイル
	    <filename>/etc/resolv.conf</filename> を作ってください.
	    見ればわかるように,
	    これらはネームサーバホストを設定しています. もちろん,
	    実際のドメイン名やアドレスは
	    あなたの環境に依存します.</para>
	</step>

	<step>
	  <para>root と toor
	    (及びパスワードを持っていない他のアカウントすべて)
	    のパスワード を設定してください.
	    passwdコマンドを使いましょう.
	    <filename>/etc/passwd</filename> や
	    <filename>/etc/master.passwd</filename>
	    といったファイルを編集してはいけません!</para>
	</step>

	<step>
	  <para>マシンを再起動して正しいホスト名で
	    立ち上がることを確認してください.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>SLIP接続をおこなう</title>

      <procedure>
	<step>
	  <para>モデムを起動, つながったらプロンプトで
	    <command>slip</command>とタイプし, マシン名と
	    パスワードを入力してください.
	    入力する必要があるものは環境に よって異なります.
	    私は次のようなスクリプトでkermitを使っています.</para>

	  <programlisting>
# kermit setup
set modem hayes
set line /dev/modem
set speed 115200
set parity none
set flow rts/cts
set terminal bytesize 8
set file type binary
# The next macro will dial up and login
define slip dial 643-9600, input 10 =&gt;, if failure stop, -
output slip\x0d, input 10 Username:, if failure stop, -
output silvia\x0d, input 10 Password:, if failure stop, -
output ***\x0d, echo \x0aCONNECTED\x0a</programlisting>

	  <para>(もちろん,
	    ホスト名とパスワードは変える必要があります).
	    接続するためには kermit のプロンプトで
	    <command>slip</command>とタイプするだけです.</para>

	  <note>
	    <para>ファイルシステムのどんなところにもプレインテキスト
	      にパスワードを書いておくのは一般的にはよくありません.
	      覚悟の上で やってください.
	      私は単に不精なだけです.</para>
	  </note>
	</step>

	<step>
	  <para>ここでkermitから抜け出し
	    (<command>z</command>でkermitをサスペンドできます), root
	    で</para>

	  <screen>&prompt.root; <userinput>slattach -h -c -s 115200 /dev/modem</userinput></screen>

	  <para>と入力しましょう. もしルータの向う側のホストへ
	    <command>ping</command> できるなら接続成功です! もしうまく
	    いかなければslattachへの引数として <option>-c</option>
	    の代わりに<option>-a</option>とやってみてください.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>接続の切り方</title>

      <para>slattachを殺すためにrootで

	<screen>&prompt.root; <userinput>kill -INT `cat /var/run/slattach.modem.pid`</userinput></screen>

	とタイプしてください. そして kermit に戻り
	(もしkermitをサスペンドしていたなら
	<command>fg</command>), kermitから抜けてください
	(<command>q</command>).</para>

      <para>slattachのマニュアルページにはインタフェースを落すために
	<command>ifconfig sl0
	  down</command>をしなければいけないと書いていますが,
	私には差がないように見えます. (<command>ifconfig
	  sl0</command>とやっても同じ結果が得られる.)</para>

      <para>時にはモデムがキャリアを落すのを
	拒絶するかもしれません(私のは よくそうなります).
	その時は単にkermitをスタートしてまた終了 してください.
	普通は2回目で落ちます.</para>
    </sect2>

    <sect2>
      <title>トラブルシューティング</title>

      <para>もし動かなければ自由に私に質問してください.
	今までいろんな人がつまずいた のは次のようなことです.</para>

      <itemizedlist>
	<listitem>
	  <para>slattach で <option>-c</option> や <option>-a</option>
	    を使わなかった(私はなぜこれが致命的になり得るのか
	    わかりませんが, このフラグを付けることで少なくとも一人の
	    問題は解決しました.)</para>
	</listitem>

	<listitem>
	  <para><option>sl0</option> の代わりに <option>s10</option>
	    を使った(いくつかのフォントでは見分けるのは難しい
	    かもしれません).</para>
	</listitem>

	<listitem>
	  <para>インタフェースの状態を見るために <command>ifconfig
	      sl0</command> をやってみてください. 私は,</para>

	  <screen>&prompt.root; <userinput>ifconfig sl0</userinput>
sl0: flags=10&lt;POINTOPOINT&gt;
        inet 136.152.64.181 --&gt; 136.152.64.1 netmask ffffff00</screen>

	  <para>となります.</para>
	</listitem>

	<listitem>
	  <para>また, pingが "no route to host"
	    というメッセージを返す時には <command>netstat
	      -r</command>でルーティングテーブルを確認しましょう.
	    私のは,</para>

	  <screen>&prompt.root; <userinput>netstat -r</userinput>
Routing tables
Destination      Gateway            Flags     Refs     Use  IfaceMTU    Rtt   
Netmasks:
(root node)
(root node)

Route Tree for Protocol Family inet:
(root node) =&gt;
default          inr-3.Berkeley.EDU UG          8   224515  sl0 -      -     
localhost.Berkel localhost.Berkeley UH          5    42127  lo0 -       0.438
inr-3.Berkeley.E silvia.HIP.Berkele UH          1        0  sl0 -      -     
silvia.HIP.Berke localhost.Berkeley UGH        34 47641234  lo0 -       0.438
(root node)</screen>

	  <para>となります.
	    (これはたくさんのファイルを転送した後でのもので,
	    あなたの見る数字はもっと小さいかも
	    しれません).</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="slips">
    <title>SLIPサーバのセットアップ方法</title>

    <para><emphasis>原作: &a.ghelmer;.<!-- <br> -->
	v1.0, 15 May 1995.</emphasis></para>

    <para><emphasis>訳: &a.jp.ts;.<!-- <br> -->
	6 September 1996.</emphasis></para>

    <para>この文書の目的は, SLIPサーバ機能を
      FreeBSDシステムのもとで設定するため の助言を提供することです.
      SLIPサーバ機能を設定するということは, リモー トの
      SLIPクライアントがログインできるようにするために, 自動的に接続処
      理をおこなうようにすることです.
      この文書は著者の経験に基づいておりますが,
      実際のシステム構成や要望は異なりますから,
      すべての疑問にこの文書が答え ることはできません. なお,
      ここでの助言を試みた結果, あなたのシステムへ
      の悪影響やデータの損失が生じたとしても,
      著者が責任を持つことはできませ
      んのでご了解をお願いします.</para>

    <para>当初この文書は, FreeBSD 1.xシステムでの
      SLIPサーバ機能のために書きまし た. その後, FreeBSD
      2.xの初期バージョンでのパス名の変更や SLIPインタフェー
      ス向け圧縮フラグの削除といった変更点を反映するために,
      書き換えをおこないま した. これらが
      FreeBSDのバージョン間の主要な変更点だったからです. もし
      この文書の間違いを見つけられましたら, ぜひ,
      訂正に十分な情報とともに電
      子メールでお知らせいただければ助かります.</para>

    <sect2 id="slips-prereqs">
      <title>前提</title>

      <para>この文書の内容はテクニカルなものなので,
	前提知識が必要です. すなわち,
	TCP/IPネットワークプロトコルについての知識, 特に,
	ネットワークとノード のアドレス指定をはじめ,
	ネットワークアドレスマスク, サブネット化, ルー ティング,
	および RIPなどのルーティングプロトコルなどに関する知識を前提
	としています. ダイヤルアップサーバで
	SLIP機能を設定するためには, これ
	らの概念についての知識が必要ですから,
	もし不案内であると思われる方は, O'Reilly &amp; Associates,
	Inc.から出版されている Craig Hunt氏の  <emphasis>TCP/IP
	  Network Administration</emphasis> (ISBN 0-937175-82-X)か,
	または  Douglas Comer氏の
	TCP/IPプロトコルに関する一連の書籍をお読みください.</para>

      <para>前提知識に加え, さらに, モデムの設定が完了しており,
	そのモデムを経由し てログインできるように,
	システムファイル群が適切に記述できているものと 仮定しています.
	もしモデムの準備ができていないときには, あらかじめダイヤ
	ルアップ機能の設定についてのチュートリアルをお読みください.
	Webブラ ウザが使えるのであれば <ulink
	  url="http://www.FreeBSD.org/"> http://www.FreeBSD.org/
	</ulink> におけるチュー トリアルの一覧を調べてください.
	あるいは, この文書を見つけた場所を調べ て,
	<filename>dialup.txt</filename>
	やそれに類似した名前の文書をお読みください. 関連す
	るマニュアルページとしては,
	シリアルポート向けデバイスドライバについて
	の &man.sio.4; をはじめ, モデムからのログインを
	受理できるようにシステ
	ムを設定するための &man.ttys.5;, &man.gettytab.5;, &man.getty.8;,
	&man.init.8; など, さらには, シリアルポート関連パラメタ ( たと
	えば直接接続シリアルインタフェースの
	<literal>clocal</literal> ) についての
	&man.stty.1;  なども助けになるかもしれません.</para>
    </sect2>

    <sect2>
      <title>概要</title>

      <para>一般的な設定内容で FreeBSDを SLIPサーバとして利用すると,
	その動作は次 のようになります. まず, SLIPユーザが FreeBSD
	による SLIPサーバへ電話し て, SLIP専用IDでログインします.
	なお, このIDを持ったユーザはシェルとし て
	<filename>/usr/sbin/sliplogin</filename> を使います. この
	<command>sliplogin</command> は, ファ イル
	<filename>/etc/sliphome/slip.hosts</filename> の中から,
	ログインIDと一致する 記述行を探します. もし一致する行があれば,
	ログインしたシリアル回線を,  利用可能な
	SLIPインタフェースへ接続し, その後にシェルスクリプト
	<filename>/etc/sliphome/slip.login</filename> で
	SLIPインタフェースを設定します.</para>

      <sect3>
	<title>SLIPサーバへのログイン例</title>

	<para>仮に SLIPユーザIDが <username>Shelmerg</username>
	  とします. すると, <filename>/etc/master.passwd</filename>
	  における <username>Shelmerg</username> のエントリは次のよ
	  うなものになります (実際には一つの行に続いている) .</para>

	<programlisting>
Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/sliplogin</programlisting>

	<para><username>Shelmerg</username> がログインすると,
	  <command>sliplogin</command> は, ファイル
	  <filename>/etc/sliphome/slip.hosts</filename>
	  からユーザIDと一致する行を探しま す. いま仮に,
	  <filename>/etc/sliphome/slip.hosts</filename>
	  に次のような記述がなさ れていたとします.</para>

	<programlisting>
Shelmerg        dc-slip sl-helmer       0xfffffc00      autocomp</programlisting>

	<para><command>sliplogin</command>
	  が上記のエントリを見つけると, <emphasis
	    remap=tt>Shelmerg</emphasis> が使用して
	  いるシリアル回線を, 利用可能な
	  SLIPインタフェースのなかの最初のものへ 接続し, 次の内容の
	  <filename>/etc/sliphome/slip.login</filename>
	  を実行します.</para>

	<programlisting>
/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp</programlisting>

	    <para>もし上記の手順が正常に処理されると,
	  <filename>/etc/sliphome/slip.login</filename>  は,
	  <command>sliplogin</command> が割り当てた SLIPインタフェース
	  (この例では  <filename>slip.login</filename>
	  で与えられたパラメタのうちで最初の値である SLIP
	  インタフェース0である) に対して <command>ifconfig</command>
	  を実行し, ローカル  IPアドレス
	  (<hostid>dc-slip</hostid>)をはじめ, リモート IPアドレス
	  (<hostid>sl-helmer</hostid>),
	  SLIPインタフェースへのネットワークマスク  (<hostid
	    role="netmask">0xfffffc00</hostid>), およびその他のフラグ
	  (<literal>autocomp</literal>)を設定 します. 逆に,
	  さきほどの手順が正常に終了しなかった場合, 通常は
	  <command>sliplogin</command> は十分な情報を syslog の
	  <literal>daemon</literal> 機能経由で  <!-- kuriyama -
	  facility? -->
	  <filename>/var/log/messages</filename> へ記録します
	  ( &man.syslogd.8; や
	  &man.syslog.conf.5; のマニュアルページを参照のうえ, さらに
	  <filename>/etc/syslog.conf</filename> を調べて
	  <command>syslogd</command> がどのファイルへ記
	  録するかを確認のこと) .</para>

	<para>例はこのくらいにして,
	  さっそくシステムのセットアップを始めてみましょう.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>カーネルのコンフィグレーション</title>

      <para>FreeBSD のデフォルトのカーネルには, 通常, 二つの
	SLIPインタフェースが 準備されています
	(<devicename>sl0</devicename> と <devicename>sl1</devicename>)
	. これらのインタフェー
	スが使用中のカーネルに準備されているかどうかを調べるには,
	<command>netstat -i</command> を実行してください.</para>

      <para><command>netstat -i</command> の出力例</para>

      <screen>Name  Mtu   Network     Address            Ipkts Ierrs    Opkts Oerrs  Coll
ed0   1500  &lt;Link&gt;0.0.c0.2c.5f.4a         291311     0   174209     0   133
ed0   1500  138.247.224 ivory             291311     0   174209     0   133
lo0   65535 &lt;Link&gt;                            79     0       79     0     0
lo0   65535 loop        localhost             79     0       79     0     0
sl0*  296   &lt;Link&gt;                             0     0        0     0     0
sl1*  296   &lt;Link&gt;                             0     0        0     0     0</screen>

      <para><command>netstat -i</command> の出力に
	<devicename>sl0</devicename> と <devicename>sl1</devicename>
	のインタフェー スが含まれているということから,
	カーネルには二つの SLIPインタフェー
	スが組み込まれているということを示しています.
	(<literal>sl0</literal> と  <literal>sl1</literal>
	に付いたアスタリスクは, <command>netstat -i</command>
	の実行時点で はインタフェースが &ldquo;ダウン&rdquo;
	していることを表しています. )</para>

      <para>なお, パケットのフォワード機能は FreeBSD
	のデフォルトのカーネルでは設定 されていません
	(すなわちルータとしては動作しない) . もしインターネット
	接続ホストについての RFC要件 ( RFC 1009 [Requirements for
	Internet Gateways] と 1122 [Requirements for Internet Hosts
	&mdash; Communication Layers], おそらく 1127 [A Perspective on
	the Host Requirements RFCs] も ) に準拠して, FreeBSDによる
	SLIPサー バをルータとして動作させたいときには,
	<filename>/etc/rc.conf</filename> (バージョ ン 2.2.2 より前の
	FreeBSD では <filename>/etc/sysconfig</filename>) ファイル の
	<literal>gateway</literal> 変数を <option>YES</option>
	としてください. もし古いシステ ムで
	<filename>/etc/sysconfig</filename> ファイルすらないときには,
	次のコマン ドを <filename>/etc/rc.local</filename>
	へ追加してください.</para>

      <programlisting>
sysctl -w net.inet.ip.forwarding = 1</programlisting>

      <para>この新しい設定を有効とするには,
	リブートする必要があります.</para>

      <para>デフォルトのカーネルコンフィグレーションファイル
	(<filename>/sys/i386/conf/GENERIC</filename>) の最後の部分に,
	次のような行がありま す.</para>

      <programlisting>
pseudo-device sl 2</programlisting>

      <para>この行によって, 使用可能な SLIPデバイスの総数が決まります.
	すなわち, 行 末の数値が, 同時に動作可能な
	SLIP接続の最大数となります.</para>

      <para>カーネルの再構築については, <link
	  linkend="kernelconfig">FreeBSDカー
	  ネルのコンフィグレーション</link> を参照ください.</para>
    </sect2>

    <sect2>
      <title>Sliploginのコンフィグレーション</title>

      <para>すでにご説明したように,
	<filename>/usr/sbin/sliplogin</filename> のコンフィグレー
	ションのために,
	3種類のファイルが<filename>/etc/sliphome</filename>
	ディレクトリに あります (<command>sliplogin</command>
	についての実際のマニュアルページとしては
	&man.sliplogin.8; を参照のこと) .
	ファイル <filename>slip.hosts</filename> は
	SLIPユーザおよびその IPアドレスを決めます. 通常, ファイル
	<filename>slip.login</filename> は,
	SLIPインタフェースを設定することだけに使
	用します. <filename>slip.logout</filename>
	はオプションのファイルで,
	<filename>slip.login</filename> で設定した内容を,
	シリアル接続が終了した時点で解除
	するときに使用します.</para>

      <sect3>
	<title><filename>slip.hosts</filename>
	  のコンフィグレーション</title>

	<para><filename>/etc/sliphome/slip.hosts</filename> には,
	  少なくとも 4 つの項目をホワイ トスペース (スペースやタブ)
	  で区切って指定します.</para>

	<itemizedlist>
	  <listitem>
	    <para>SLIPユーザのログインID</para>
	  </listitem>

	  <listitem>
	    <para>SLIPリンクのローカル (SLIPサーバ側) アドレス</para>
	  </listitem>

	  <listitem>
	    <para>SLIPリンクのリモートアドレス</para>
	  </listitem>

	  <listitem>
	    <para>ネットワークマスク</para>
	  </listitem>
	</itemizedlist>

	<para>ホスト名をローカルおよびリモートのアドレスとして
	  記述できます (IPアドレ スの決定は,
	  <filename>/etc/host.conf</filename> の指定内容に応じて,
	  <filename>/etc/hosts</filename> か
	  DNSのいずれかによって決定される) . また, ネット
	  ワークマスクも <filename>/etc/networks</filename>
	  ファイルに記述された名前を参照す ることで,
	  指定することもできると思います. これまでの例としてあげたシス
	  テムでの <filename>/etc/sliphome/slip.hosts</filename>
	  は次のようになります.</para>

	<programlisting>
#
# login local-addr      remote-addr     mask            opt1    opt2 
#                                               (normal,compress,noicmp)
#
Shelmerg  dc-slip       sl-helmerg      0xfffffc00      autocomp</programlisting>

	<para>それぞれの行の最後には,
	  次に示すオプションを一つ以上指定できます.</para>

	<itemizedlist>
	  <listitem>
	    <para><option>normal</option> &mdash; ヘッダを圧縮しない</para>
	  </listitem>

	  <listitem>
	    <para><option>compress</option> &mdash; ヘッダを圧縮する</para>
	  </listitem>

	  <listitem>
	    <para><option>autocomp</option> &mdash;
	      リモートの設定に応じて, ヘッダを圧縮する</para>
	  </listitem>

	  <listitem>
	    <para><option>noicmp</option> &mdash;
	      ICMPパケットを禁止する
	      (&ldquo;ping&rdquo;パケットは送出されず,
	      バンド幅を占有しない)</para>
	  </listitem>
	</itemizedlist>

	<para>なお, FreeBSDバージョン2の初期リリースの
	  <command>sliplogin</command> は, 旧  FreeBSD
	  1.xでは有効であった上記のオプションを無視していましたので,
	  <option>normal</option>, <option>compress</option>,
	  <option>autocomp</option>, そして <option>noicmp</option>
	  などのオ プションは FreeBSD
	  2.2でサポートされるまでは効果がありませんでした (た
	  だしこれらのフラグを使うためには
	  <filename>slip.login</filename> スクリプトへ記述する
	  必要がある) .</para>

	<para>SLIPリンクでのローカルとリモート向けのアドレスの
	  選び方は, TCP/IPサブネッ トを専用に割り当てるか,
	  または&ldquo;プロキシ ARP&rdquo;を
	  SLIPサーバへ用いるかによっ て違います (プロキシ
	  ARPという用語のここでの使い方は本来のものではない が,
	  説明のためにこの用語を使う) . もし,
	  どちらの方式を選ぶべきか判らな かったり,
	  IPアドレスの割り当て方が不明のときには, 上述の <link
	    linkend="slips-prereqs">前提</link> の節で紹介した
	  TCP/IP関連書籍を参考になさるか,  またはあなたの
	  IPネットワークを管理している方に相談なさると
	  よいでしょう.</para>

	<para>独立したサブネットを SLIPクライアントへ適用するときには,
	  すでに割り当 てられている
	  IPネットワーク番号の範囲からサブネット番号を割り当て, 同
	  時にそのサブネットの範囲内で有効な IPアドレスを
	  SLIPクライアントの IP 番号として割り当てる必要があります.
	  さらに, この SLIPサブネットから SLIPサーバを経由して最も近い
	  IPルータへの経路を静的に設定するか, また は
	  <command>gated</command> を FreeBSDによる
	  SLIPサーバへインストールして, 適当
	  なルーティングプロトコルを使って,
	  SLIPサーバ経由のサブネットへの経路情
	  報をルータ群へ通知できるように設定するか,
	  のいずれかをおこなう必要がありま す.</para>

	<para>&ldquo;プロキシ ARP&rdquo; 方式を採用するときには,
	  SLIPクライアント向けの IPアドレス
	  として, SLIPサーバのサブネットの範囲から
	  選んで割り当てるとともに,
	  &man.arp.8; コマンドを使うために
	  <filename>/etc/sliphome/slip.login</filename>
	  と<filename>/etc/sliphome/slip.logout</filename>
	  のスクリプトを修正して, SLIPサー
	  バにおける ARPテーブル内のプロキシ ARPエントリへ
	  反映させる必要がありま
	  す.</para>
      </sect3>

      <sect3>
	<title><filename>slip.login</filename>
	  のコンフィグレーション</title>

	<para>ファイル <filename>/etc/sliphome/slip.login</filename>
	  の一般的な内容は次にように なります.</para>

	<programlisting>
#!/bin/sh -
#
#	@(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6</programlisting>

	<para>この <filename>slip.login</filename>
	  ファイルの役目は単に, SLIPインタフェースにつ
	  いてのローカルとリモートのアドレス,
	  およびそのネットワークマスクを  <command>ifconfig</command>
	  コマンドで設定することです.</para>

	<para>もし&ldquo;プロキシ ARP&rdquo;方式を採用する
	  (SLIPクライアントへ独立したサブネットを 使わない) ときには,
	  ファイル <filename>/etc/sliphome/slip.login</filename>
	  は次の ような内容になります.</para>

	<programlisting>
#!/bin/sh -
#
#	@(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
# Answer ARP requests for the SLIP client with our Ethernet addr
/usr/sbin/arp -s $5 00:11:22:33:44:55 pub</programlisting>

	<para>この <filename>slip.login</filename> で追加された行
	  <command>arp -s &#36;5 00:11:22:33:44:55 pub</command> は,
	  SLIPサーバにおける ARPテーブルへ新たなエントリを作ります.
	  SLIPサーバ は, この ARPエントリが作られると,
	  SLIPクライアントの IPアドレスと話し たい他の
	  IPノードが要求してきたときにはいつも, SLIPサーバ の Ethernet
	  MACアドレスを返すようになります.</para>

	<para>上記の例を実際に流用なさるときには, 例にある Ethernet
	  MACアドレス  (<hostid role="mac">00:11:22:33:44:55</hostid>)
	  を, あなたのシステムの実際のEthernetカー ドの
	  MACアドレスと置き換えなければ&ldquo;プロキシ
	  ARP&rdquo;はうまく動作しません!  SLIPサーバの Ethernet
	  MACアドレスを調べるには <command>netstat -i</command> コマ
	  ンドを利用してください.
	  実行結果の第2行は次のようなものになるはずです.</para>

	<screen>ed0   1500  &lt;Link&gt;0.2.c1.28.5f.4a         191923     0   129457     0   116</screen>

	<para>この例での Ethernet MACアドレスは
	  <hostid role="mac">00:02:c1:28:5f:4a</hostid> であると
	  読みます. なお &man.arp.8; における MAC
	  アドレスの指定に際しては,
	  コマンド <command>netstat -i</command> が付けた
	  Ethernet MACアドレスのピリオド記
	  号をコロン記号と置き換え, かつ単一桁の 16
	  進数にはゼロを先頭に加える必
	  要があります. この指定についての正確な情報は &man.arp.8;
	  を参照く
	  ださい.</para>

	<note>
	  <para><filename>/etc/sliphome/slip.login</filename> と
	    <filename>/etc/sliphome/slip.logout</filename>
	    を作成したならば, ファイル属性の&ldquo;実行&rdquo;ビット
	    (すなわち  <command>chmod 755 /etc/sliphome/slip.login
	      /etc/sliphome/slip.logout</command>) を
	    設定しなければなりません. さもなければ
	    <command>sliplogin</command> が
	    うまく実行されません.</para>
	</note>
      </sect3>

      <sect3>
	<title><filename>slip.logout</filename>
	  のコンフィグレーション</title>

	<para>ファイル <filename>/etc/sliphome/slip.logout</filename>
	  は必ずしも必要なものではあ りません (ただし&ldquo;プロキシ
	  ARP&rdquo;を利用する場合を除く) . もしこのファイルを
	  作成するときには, 次に示す標準的な
	  <filename>slip.logout</filename> スクリプト例を
	  参考にしてください.</para>

	<programlisting>
#!/bin/sh -
#
#	slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down</programlisting>

	<para>&ldquo;プロキシ ARP&rdquo;を利用する場合, この
	  <filename>/etc/sliphome/slip.logout</filename> を 使って,
	  特定の SLIPクライアント向けの
	  ARPエントリを削除したくなるよう なときがあります.</para>

	<programlisting>
#!/bin/sh -
#
#       @(#)slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
# Quit answering ARP requests for the SLIP client
/usr/sbin/arp -d $5</programlisting>

	<para>コマンド <command>arp -d &#36;5</command> は,
	  SLIPクライアントがログインした 際に, &ldquo;プロキシ
	  ARP&rdquo;を使った <filename>slip.login</filename>
	  によって追加され た ARPエントリを削除します.</para>

	<para>これによって, 繰り返して利用することができるわけです.
	  必ず, <filename>/etc/sliphome/slip.logout</filename>
	  を作成した後に, 実行ビットを設定し てください (
	  <command>chmod 755 /etc/sliphome/slip.logout</command> )
	  .</para>
      </sect3>
    </sect2>

    <sect2>
      <title>ルーティングについての考慮点</title>

      <para>&ldquo;プロキシ ARP&rdquo;方式を利用せずに
	SLIPクライアントとその他のネットワーク  (Internetも含む)
	の構成要素との間でパケットをルーティングするときには,
	SLIPサーバ経由で
	SLIPクライアントが属するサブネットまでの経路を, 最も
	近いデフォルトのルータ群へ静的な経路情報として
	追加しなければならないか,  または <command>gated</command> を
	FreeBSDによる SLIPサーバへインストールして, SLIP
	サブネットについての経路情報を,
	適当なルーティングプロトコルでルー
	タ群へ通知できるように設定するか,
	のどちらかをおこなわなければなりません.</para>

      <sect3>
	<title>静的な経路</title>

	<para>静的な経路を最も近いデフォルトの
	  ルータ群へ追加することが困難なことがあ ります
	  (経路情報を追加できる権限がなければそもそも不可能となる).
	  もし あなたの組織に複数のルータで構成された
	  ネットワークがあるならば, ある種 のルータ (たとえば Ciscoや
	  Proteonなど) は, 静的な経路を SLIPサブネッ
	  トへ使うようにルータを設定しなければならないだけでなく,
	  その静的経路を 他のどのルータへ知らせるのかもあらかじめ
	  指定しておく必要がありますから,
	  静的経路に基づくルーティングを軌道に乗せるには
	  それなりの専門的技術やト
	  ラブルシューティングやコツが必要だと思います.</para>
      </sect3>

      <sect3>
	<title><command>gated</command>の稼働</title>

	<para>静的経路についての頭痛への代替手段は,
	  <command>gated</command> を FreeBSDによる SLIPサー
	  バへインストールして, 適切なルーティングプロトコル
	  (RIP/OSPF/BGP/EGP)  を使って
	  SLIPサブネットについての経路情報を他のルータへ知らせるように
	  設定することです. <link linkend="ports">ports
	    コレクション</link>から  <command>gated</command>
	  を用いることもできますし, <ulink
	    URL="ftp://ftp.gated.merit.edu/research.and.development/gated/">
	    the GateD 匿名 FTP サイト</ulink>
	  から探して自分自身で構築することもで きます.
	  この文章を執筆時点の最新バージョンは
	  <filename>gated-R3_5Alpha_8.tar.Z</filename> であり,
	  このファイルだけで FreeBSDで 動作させることができます.
	  <command>gated</command> についてのすべての情報と文書 は
	  <ulink URL="http://www.gated.merit.edu/">
	    Merit GateD コンソーシアム</ulink> からはじまる Web
	  上で入手でき ます. <command>gated</command>
	  のコンパイルとインストールを行ったならば,
	  独自の 設定のために <filename>/etc/gated.conf</filename>
	  ファイルを記述してください. 次の 例は,
	  筆者が FreeBSDによる SLIP
	  サーバで使っている内容と類似のものです.</para>

	<programlisting>
#
# gated configuration file for dc.dsu.edu; for gated version 3.5alpha5
# Only broadcast RIP information for xxx.xxx.yy out the ed Ethernet interface
#
#
# tracing options
#
traceoptions "/var/tmp/gated.output" replace size 100k files 2 general ;

rip yes {
 interface sl noripout noripin ;
 interface ed ripin ripout version 1 ;
 traceoptions route ;
} ;

#
# Turn on a bunch of tracing info for the interface to the kernel:
kernel {
 traceoptions remnants request routes info interface ;
} ;

#
# Propagate the route to xxx.xxx.yy out the Ethernet interface via RIP
#

export proto rip interface ed {
        proto direct {
                <replaceable>xxx.xxx.yy</replaceable> mask 255.255.252.0 metric 1; # SLIP connections
        } ;
} ;

#
# Accept routes from RIP via ed Ethernet interfaces

import proto rip interface ed {
        all ;
} ;</programlisting>

	<para>この <filename>gated.conf</filename> ファイルの例では,
	  SLIPのサブネット  <replaceable>xxx.xxx.yy</replaceable>
	  についての経路情報を RIPを使って Ethernetへブロー
	  ドキャストしています. もし <devicename>ed</devicename>
	  ドライバ以外の Ethernetドライバを使 うのであれば,
	  <devicename>ed</devicename>
	  インタフェースの記述を適切なものに置き換えてくだ さい.
	  またこの例では,
	  <command>gated</command>の動作をデバッグするために,
	  <filename>/var/tmp/gated.output</filename>
	  へトレース情報を出力するように指示して います.
	  <command>gated</command> が希望通りに動作したならば,
	  このトレースオプショ ンを止めることができます. なお,
	  例における <replaceable>xxx.xxx.yy</replaceable> を, あ
	  なた自身の
	  SLIPサブネットのネットワークアドレスに換えてください (また
	  <literal>proto direct</literal>
	  部分のネットワークマスクも換えることを忘れないこ と)
	  .</para>

	<para><command>gated</command>
	  のコンパイルとインストールが終了し, コンフィグレーショ
	  ンファイルの作成も完了したら,
	  FreeBSDシステムではデフォルトの
	  <command>routed</command>に代わって <command>gated</command>
	  を起動してください. そのため には,
	  <filename>/etc/netstart</filename> の
	  <filename>routed/gated</filename> 起動パラメタを
	  適切な値に設定してください. <command>gated</command>
	  のコマンドラインパラメタにつ いての情報は,
	  <command>gated</command>
	  のマニュアルページを参照してください.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>謝辞</title>

      <para>このチュートリアルについての
	コメントやアドバイスを寄せてくれた次の方々
	に感謝します.</para>

      <variablelist>
	<varlistentry><term>&a.wilko;</term>
	  <listitem>
	    <para></para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>Piero Serini</term>
	  <listitem>
	    <para><email>Piero@Strider.Inet.IT</email></para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../handbook.sgml" "part" "chapter")
     End:
-->
