<?xml version="1.0" encoding="euc-jp"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r40979
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="linuxemu">
  <info><title>Linux バイナリ互換機能</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>再構成と一部の更新: </contrib></author>
      <!-- 22 Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Brian N.</firstname><surname>Handy</surname></personname><contrib>オリジナルの文書を執筆: </contrib></author>
      <author><personname><firstname>Rich</firstname><surname>Murphey</surname></personname></author>
    </authorgroup>
  </info>

  

  <para><emphasis>訳: &a.jp.kiroh;、1996 年 9 月 24 日</emphasis></para>

  <sect1 xml:id="linuxemu-synopsis">
    <title>この章では</title>

    <indexterm><primary>Linux
      バイナリ互換機能</primary>
    </indexterm>

    <indexterm>
      <primary>バイナリ互換機能</primary>
      <secondary>Linux</secondary>
    </indexterm>

    <para>FreeBSD は、Linux を含む &unix; like
      なオペレーティングシステムとのバイナリ互換機能を提供しています。
      現時点では、一体なぜ FreeBSD が Linux
      バイナリを実行できるようにならなければならないのか自問しているのではないでしょうか?
      答えはきわめて簡単です。Linux
      は現在コンピュータの世界では最も<quote>ホットなモノ</quote>なのでたくさんの会社や開発者たちが
      Linux のためだけに開発を行なっています。そのため、残された私たち
      FreeBSD ユーザは彼らに対して FreeBSD
      ネイティブなアプリケーションも出すように言うしかないのです。
      問題は、FreeBSD
      バージョンも出した場合にどれくらいの数のユーザーが使うのかわからない、
      ということであり、そのため Linux 版のみを開発しているということなのです。
      そこで FreeBSD では Linux バイナリ互換機能が役に立つのです。</para>

    <para>簡単に言ってしまえば、この機能により全ての Linux アプリケーションの
      90% が修正なしに FreeBSD 上で起動できます。
      この中には <application>&staroffice;</application> や Linux 版の
      <application>&adobe;&nbsp;&acrobat;</application>,
      <application>&realplayer;</application>,
      <application>&oracle;</application>,
      <application>Doom</application>,
      <application>Quake</application> などがあります。
      また、ある状況においては Linux バイナリを Linux で動かすよりも
      FreeBSD で動かすほうが良いパフォーマンスが出るという報告もあります。</para>

    <para>しかしながら、いくつかの Linux に特有な OS の機能は
      FreeBSD ではサポートされていません。
      仮想 8086 モードを有効にするような i386 特有の呼び出しを過度に使うような
      Linux バイナリは FreeBSD では動きません。</para>

    <para>この章を読むと、以下のことがわかります。</para>
    <itemizedlist>
      <listitem>
	<para>Linux バイナリ互換機能を有効にする方法。</para>
      </listitem>

      <listitem>
	<para>Linux 共有ライブラリを追加する方法。</para>
      </listitem>

      <listitem>
	<para>Linux アプリケーションを
	  FreeBSD システムにインストールする方法</para>
      </listitem>

      <listitem>
	<para>FreeBSD における Linux 互換機能の実装の詳細。</para>
      </listitem>
    </itemizedlist>

    <para>この章を読む前に、以下のことを理解しておく必要があります。</para>

    <itemizedlist>
      <listitem>
	<para>サードパーティ製ソフトウェアのインストール方法
	  (<xref linkend="ports"/>)</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="linuxemu-lbc-install">
    <title>インストール</title>

    <indexterm><primary>KLD (kernel loadable
	object)</primary></indexterm>

    <para>Linux バイナリ互換機能は、デフォルトでは有効ではありません。
      この機能を有効にする最も簡単な方法は、
      <literal>linux</literal> KLD オブジェクト
      (<quote>Kernel LoaDable object</quote>) を読み込むことです。
      <systemitem class="username">root</systemitem> 権限で、
      以下のコマンドを打つだけでモジュールを読み込むことができます。</para>

    <screen>&prompt.root; <userinput>kldload linux</userinput></screen>

    <para>Linux 互換機能を常に有効にする場合には、
      <filename>/etc/rc.conf</filename> に以下の行を追加してください。</para>

    <programlisting>linux_enable="YES"</programlisting>

    <para>望みの KLD モジュールがロードされているか確認したい時には
      &man.kldstat.8; コマンドを利用します。</para>

    <screen>&prompt.user; <userinput>kldstat</userinput>
Id Refs Address    Size     Name
 1    2 0xc0100000 16bdb8   kernel
 7    1 0xc24db000 d000     linux.ko</screen>

    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>COMPAT_LINUX</secondary>
    </indexterm>

    <para>何らかの理由で Linux KLD をロードしたくない、
      あるいはロードできないような場合には、
      <literal>options COMPAT_LINUX</literal>
      をカーネルの設定ファイルに指定して、
      Linux バイナリ互換機能をカーネルにスタティックリンクしてください。
      そして、<xref linkend="kernelconfig"/>
      の記述にしたがって新しいカーネルをインストールしてください。</para>

    <sect2>
      <title>Linux ランタイムライブラリのインストール</title>

      <indexterm>
	<primary>Linux</primary>
	<secondary>Linux ライブラリのインストール</secondary>
      </indexterm>

      <para>これは、<link linkend="linuxemu-libs-port">linux_base</link>
	port を用いるか、もしくは
	<link linkend="linuxemu-libs-manually">手動で</link>
	インストールします。</para>

    <sect3 xml:id="linuxemu-libs-port">
      <title>linux_base の port を用いたインストール</title>

      <indexterm><primary>Ports Collection</primary></indexterm>

      <para>ランタイムライブラリをインストールするには最も簡単な方法です。
	<xref linkend="ports"/> から他の port
	をインストールするのと全く同じようにできます。</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/emulators/linux_base-f10</userinput>
&prompt.root; <userinput>make install distclean</userinput></screen>

	<note>
	  <para>&os;&nbsp;8.0 よりも前の &os; システムでは、<filename
	      role="package">emulators/linux_base-f10</filename>
	    ではなく、<filename
	      role="package">emulators/linux_base-fc4</filename> port
	    を使う必要があります。</para>
	</note>

	<para>これで Linux バイナリ互換機能が使えるはずです。
	  いくつかのプログラムはシステムライブラリのマイナーバージョンが違うと文句を言うかもしれませんが一般的には大した問題ではありません。</para>

	<note><para>Linux ディストリビューションおよびバージョンに対応して、
	  複数のバージョンの <filename
	    role="package">emulators/linux_base</filename> port が用意されています。
	  インストールを考えている Linux アプリケーションが必要とする条件に近い
	  port をインストールする必要があります。</para></note>

      </sect3>

      <sect3 xml:id="linuxemu-libs-manually">
	<title>手動でのライブラリのインストール</title>

	<para><quote>ports</quote> コレクションをインストールしていない場合、
	  代わりに手動でライブラリをインストールすることができます。
	  プログラムが必要とする Linux
	  のシェアードライブラリとランタイムリンカが必要です。
	  また Linux ライブラリ用の <quote>shadow root</quote> ディレクトリ、
	  <filename>/compat/linux</filename> を作成する必要があります。
	  FreeBSD で動作する Linux プログラムが使用するシェアードライブラリは、
	  まずこのファイルツリーから検索されます。例えば、
	  Linux のプログラムが <filename>/lib/libc.so</filename>
	  をロードしようとした場合には、FreeBSD はまず
	  <filename>/compat/linux/lib/libc.so</filename>
	  を開こうとします。これが存在しなかった場合には、次に
	  <filename>/lib/libc.so</filename> を試します。
	  シェアードライブラリは、Linux の <command>ld.so</command>
	  が報告するパスではなく、
	  <filename>/compat/linux/lib</filename>
	  以下にインストールする必要があります。</para>

	<para>Linux のプログラムが必要とする
	  シェアードライブラリを探す必要があるのは、FreeBSD
	  のシステムに Linux
	  のプログラムをインストールする最初の数回だけでしょう。
	  それが過ぎれば、十分な Linux
	  のシェアードライブラリがシステムにインストールされ、
	  新しくインストールした Linux
	  のバイナリも余計な作業をせずに動作させることができるようになります。</para>
      </sect3>

      <sect3>
	<title>シェアードライブラリの追加</title>

	<indexterm><primary>共有ライブラリ</primary></indexterm>

	<para><filename>linux_base</filename> port をインストールした後に、
	  アプリケーションが必要なライブラリが存在しないというエラーを出したらどうしたらよいでしょうか?
	  Linux のバイナリがどのシェアードライブラリを必要とし、
	  そしてどこで入手できるか、どのように探したらよいでしょうか?
	  基本的には、以下の 2 種類の方法があります (以下の手順に従う場合には、
	  必要なインストール作業をおこなう FreeBSD システム上で
	  <systemitem class="username">root</systemitem>
	  として作業をおこなう必要があります)。</para>

	<para>Linux システムにアクセス可能ならば、
	  そのアプリケーションがどういうシェアードライブラリを必要としているのか調べ、
	  単に FreeBSD にそのライブラリをコピーするだけです。
	  次の例を見てみましょう。</para>

	<informalexample>
	  <para>FTP を使って <application>Doom</application>
	    の Linux バイナリを取ってきて、
	    アクセスできる Linux システムに置いたとしましょう。
	    次のように <command>ldd linuxdoom</command>
	    とするだけでどのシェアードライブラリが必要かチェックできます。</para>

	<screen>&prompt.user; <userinput>ldd linuxxdoom</userinput>
libXt.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libX11.so.3.1.0
libc.so.4 (DLL Jump 4.5pl26) =&gt; /lib/libc.so.4.6.29</screen>

	  <indexterm><primary>シンボリックリンク</primary></indexterm>
	  <para>最後のカラムに表示されているすべてのファイルを持って来て、
	    <filename>/compat/linux</filename> の下に置き、
	    最初のカラムに示されるファイル名にシンボリックリンクを張ります。
	    すなわち、FreeBSD システムでは以下のようなファイルが必要となります。</para>

	  <screen>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>

	  <blockquote>
	    <note>
	      <para>最初のカラムに表示されているファイルとメジャーバージョンが同じ
	        Linux シェアードライブラリを既にインストールしている場合は、
		新たにコピーする 必要はありません。
		既にあるライブラリで動作するはずです。
		ただ、新しいバージョンのものをコピーすることをお奨めします。
		新しいライブラリにシンボリックリンクを変更したら、
		古いライブラリは削除してかまいません。</para>

	      <screen>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</screen>

	      <para>従って、以上のようなライブラリがインストールされており、
	        新しいバイナリに対する <command>ldd</command>
	        の出力が以下のようになる場合を考えます。</para>

	      <screen>libc.so.4 (DLL Jump 4.5pl26) -&gt; libc.so.4.6.29</screen>

	      <para>このように最後の番号が 1 つか 2 つ古いだけならば、普通は
	        <filename>/lib/libc.so.4.6.29</filename>
	        をコピーする必要はありません。
		わずかに古いライブラリでもプログラムは動作するはずだからです。
	        もちろん、以下のように新しいライブラリと置き換えても構いません。</para>

	      <screen>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>
	    </note>
	  </blockquote>

	  <blockquote>
	    <note>
	      <para>シンボリックリンクのメカニズムは Linux
	      バイナリに<emphasis>のみ</emphasis>必要なことに注意してください。
	      FreeBSD
	      のランタイムリンカはメジャーリビジョン番号の一致したライブラリを検索するので、
	      ユーザが気にする必要はありません。</para>
	    </note>
	  </blockquote>
	</informalexample>
      </sect3>
    </sect2>

    <sect2>
      <title>Linux の ELF バイナリのインストール</title>

      <indexterm>
	<primary>Linux</primary>
	<secondary>ELF バイナリ</secondary>
      </indexterm>

      <para>ELF のバイナリを使うためには、
	<quote>マークをつける (branding)</quote> 作業が必要になります。
	マークのない ELF
	バイナリを実行しようとすると以下のようなエラーメッセージを受けとってしまうことでしょう。</para>

      <screen>&prompt.user; <userinput>./my-linux-elf-binary</userinput>
ELF binary type not known
Abort</screen>

      <para>カーネルが FreeBSD の ELF バイナリと Linux
	のバイナリとを見分けられるようにするためには、&man.brandelf.1;
	ユーティリティを以下のようにして使ってください。</para>

      <screen>&prompt.user; <userinput>brandelf -t Linux my-linux-elf-binary</userinput></screen>

      <indexterm><primary>GNU ツールチェイン</primary></indexterm>
      <para>今では GNU のツールたちが
	ELF バイナリに自動的に適切なマークを付加するようになったので、
	今後はこの作業もだんだんと必要なくなってゆくでしょう。</para>
    </sect2>

    <sect2>
      <title>Random Linux RPM ベースのアプリケーションのインストール</title>

      <para>FreeBSD は、(&linux; ports を含む) すべての ports の追跡に使われる独自の
	package データベースを持っています。
	そのため、&linux; RPM データベースは必要ありません (対応していません)。</para>

      <para>しかしながら、random &linux; RPM
	ベースのアプリケーションをインストールする必要があるのでしたら、
	以下のように実行してください。</para>

      <screen>&prompt.root; <userinput>cd /compat/linux</userinput>
&prompt.root; <userinput>rpm2cpio -q &lt; /path/to/linux.archive.rpm | cpio -id</userinput></screen>

      <para>その後、インストールした ELF
	(ライブラリではなく) バイナリに brandelf を実行してください。
	綺麗にアンインストールできないかもしれませんが、試験の手助けとなります。</para>
    </sect2>

    <sect2>
      <title>ホストネームリゾルバの設定</title>

      <para>DNS がうまく動作しなかったり、
	以下のようなエラーメッセージが表示され
	る場合は、<filename>/compat/linux/etc/host.conf</filename>
	ファイルを設定する必要があります。</para>

      <screen>resolv+: "bind" is an invalid keyword resolv+:
"hosts" is an invalid keyword</screen>

      <para>ファイルの内容を以下のように設定してください。</para>

	<programlisting>order hosts, bind
multi on</programlisting>

      <para>ここで、order は <filename>/etc/hosts</filename> を最初に検索し、
	次に DNS を検索するように指定します。
	<filename>/compat/linux/etc/host.conf</filename>
	がインストールされていない場合、
	Linux アプリケーションは FreeBSD の
	<filename>/etc/host.conf</filename> を使用しようとして、
	文法の違いによる警告を出力します。
	<filename>/etc/resolv.conf</filename>
	を利用してネームサーバの設定をしていない場合には、
	<literal>bind</literal> を削除してください。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="linuxemu-mathematica">
    <info><title>&mathematica; のインストール</title>
      <authorgroup>
	<author><personname>
	  <firstname>Boris</firstname>
	  <surname>Hollas</surname></personname>
	  <contrib>Mathematica 5.X 向けの改訂: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>アプリケーション</primary>
      <secondary><application>Mathematica</application></secondary>
    </indexterm>

    <para>この章では、<application>&mathematica; 5.X</application>
      Linux 版の FreeBSD へのインストールについて説明します。</para>

    <para>Linux 版の <application>&mathematica;</application> または
      <application>&mathematica; for Students</application> は、Wolfram
      (<link xlink:href="http://www.wolfram.com/">http://www.wolfram.com/</link>)
      から直接注文することができます。</para>

    <sect2>
      <title>&mathematica; インストーラの実行</title>

      <para>最初に、&os; 対して <application>&mathematica;</application>
	の Linux バイナリが、Linux ABI を使用していることを指定する必要があります。
	最も簡単な方法は、すべてのマーク付けされていないコマンドに対し、
	デフォルトの ELF ブランドを Linux に設定することです。</para>

      <screen>&prompt.root; <userinput>sysctl kern.fallback_elf_brand=3</userinput></screen>

      <para>これにより、&os; はマーク付が行われていない ELF バイナリは
	Linux ABI を使用すると見なすので、CDROM から直接インストーラを実行できます。</para>

      <para><filename>MathInstaller</filename>
	ファイルをハードディスクにコピーしてください。</para>

      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cp /cdrom/Unix/Installers/Linux/MathInstaller /localdir/</userinput></screen>

      <para>このファイルの中で、最初の行の <literal>/bin/sh</literal>
	を <literal>/compat/linux/bin/sh</literal> に置き換えてください。
	これにより、インストーラは Linux 版の &man.sh.1;
	により実行されるようになります。
	次に、テキストエディタもしくは次の節で説明するスクリプトを用いて、
	<literal>Linux)</literal> を <literal>FreeBSD)</literal>
	に置き換えてください。
	この置き換えにより、<application>&mathematica;</application>
	のインストーラ (オペレーティングシステムを決定するのに
	<command>uname -s</command> を用います) が、
	&os; を Linux like なオペレーティングシステムとして扱うようになります。
	<command>MathInstaller</command> を実行すると、
	<application>&mathematica;</application> をインストールします。</para>
    </sect2>

    <sect2>
      <title>&mathematica; 実行ファイルの変更</title>

      <para><application>&mathematica;</application>
	がインストール中に作成したシェルスクリプトは、使用する前に変更する必要があります。
	<application>&mathematica;</application> の実行ファイルが置かれているディレクトリが
	<filename class="directory">/usr/local/bin</filename> とすると、
	<filename>math</filename>, <filename>mathematica</filename>,
	<filename>Mathematica</filename> および
	<filename>MathKernel</filename>
	といったファイルへのシンボリックリンクがこのディレクトリにあります。
	どちらの場合でも、
	次に、テキストエディタもしくは以下のスクリプトを用いて、
	<literal>Linux)</literal> を <literal>FreeBSD)</literal>
	に置き換えてください。</para>

      <programlisting>#!/bin/sh
cd /usr/local/bin
for i in math mathematica Mathematica MathKernel
  do sed 's/Linux)/FreeBSD)/g' $i &gt; $i.tmp
  sed 's/\/bin\/sh/\/compat\/linux\/bin\/sh/g' $i.tmp &gt; $i
  rm $i.tmp
  chmod a+x $i
done</programlisting>
    </sect2>

    <sect2>
      <title>&mathematica; パスワードの取得</title>

      <indexterm>
	<primary>イーサネット</primary>
	<secondary>MAC アドレス</secondary>
      </indexterm>

      <para>初めて <application>&mathematica;</application> を起動すると、
	パスワードを尋ねられます。
	Wolfram からパスワードをまだ入手していないのであれば、
	インストールディレクトリにある <command>mathinfo</command>
	というプログラムを実行して、<quote>マシン ID</quote> を入手してください。
	このマシン ID は、最初に見つかったイーサネットカードの
	MAC アドレスのみをベースとして作成されるので、他のコンピュータで
	<application>&mathematica;</application> を実行することはできません。</para>

      <para>電子メールや電話、FAX などで Wolfram に登録する時にはこの
	<quote>マシン ID</quote> を渡します。
	するといくつかの数字から構成されるパスワードが返されます。</para>
    </sect2>

    <sect2>
      <title>ネットワーク経由での &mathematica; フロントエンドの起動</title>

      <para><application>&mathematica;</application>
	は標準フォントセットにない特別な記号
	(積分記号、総和記号、ギリシャ文字など)
	を表示するために特殊なフォントを使用します。
	X プロトコルは、これらのフォントが
	<emphasis>ローカルマシンに</emphasis>
	インストールされていることを要求します。
	これはつまり、ローカルマシンに (CD-ROM や
	<application>&mathematica;</application>
	がインストールされているホストマシンから)
	そのフォントをコピーしなければならないということです。
	これらのフォントは通常、CD-ROM の
	<filename>/cdrom/Unix/Files/SystemFiles/Fonts</filename>
	か、もしくはハードディスクの
	<filename>/usr/local/mathematica/SystemFiles/Fonts</filename>
	に置かれており、実際に使用されるフォントは <filename>Type1</filename> と
	<filename>X</filename> のサブディレクトリに格納されています。
	これらを利用するには次のような二つ方法があります。</para>

      <para>一つは、フォントファイルをすべて
	<filename>/usr/X11R6/lib/X11/fonts/</filename>
	以下にある既存のフォントディレクトリにコピーする方法です。
	この場合、<filename>fonts.dir</filename> にフォント名を追加し、
	先頭行のフォント総数を変更することも必要になります。
	あるいは、フォントをコピーしたディレクトリで
	&man.mkfontdir.1; を実行するだけでもかまいません。</para>

      <para>もう一つの方法は、
	<filename>/usr/X11R6/lib/X11/fonts/</filename>
	にフォントディレクトリごとコピーする方法です。</para>

      <screen>&prompt.root; <userinput>cd /usr/X11R6/lib/X11/fonts</userinput>
&prompt.root; <userinput>mkdir X</userinput>
&prompt.root; <userinput>mkdir MathType1</userinput>
&prompt.root; <userinput>cd /cdrom/Unix/Files/SystemFiles/Fonts</userinput>
&prompt.root; <userinput>cp X/* /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>cp Type1/* /usr/X11R6/lib/X11/fonts/MathType1</userinput>
&prompt.root; <userinput>cd /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>mkfontdir</userinput>
&prompt.root; <userinput>cd ../MathType1</userinput>
&prompt.root; <userinput>mkfontdir</userinput></screen>

      <para>そして、フォントパスに新しいフォントディレクトリを追加します。</para>

      <screen>&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/MathType1</userinput>
&prompt.root; <userinput>xset fp rehash</userinput></screen>

      <para><application>&xorg;</application> サーバを使用しているなら、
	<filename>xorg.conf</filename> 
	ファイルに加えることでこれらのフォントを自動的に読み込むことができます。</para>

      <indexterm><primary>フォント</primary></indexterm>

      <para>
	<filename>/usr/X11R6/lib/X11/fonts/Type1</filename> という
	ディレクトリが<emphasis>存在していない</emphasis>場合には、
	上記例の <filename>MathType1</filename> を
	<filename>Type1</filename>
	とすることができます。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="linuxemu-maple">
    <info><title>&maple; のインストール</title>
      <authorgroup>
	<author><personname>
	  <firstname>Aaron</firstname>
	  <surname>Kaplan</surname></personname>
<!--	  <address><email>aaron@lo-res.org</email></address>-->
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author><personname>
	  <firstname>Robert</firstname>
	  <surname>Getschmann</surname>
	  </personname>
<!--	  <address><email>rob@getschmann.org</email></address>-->
	  <contrib>感謝: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>applications</primary>
      <secondary><application>Maple</application></secondary>
    </indexterm>

    <para><application>&maple;</application>
      は <application>&mathematica;</application>
      に似た商用の数式処理プログラムです。
      ソフトウェアを <link
	xlink:href="http://www.maplesoft.com/">http://www.maplesoft.com/</link>
      で購入し、
      ライセンスファイルの登録手続きを行ってください。
      このソフトウェアを FreeBSD にインストールするには、
      以下のステップに従ってください。</para>

    <procedure>
      <step><para>製品の配布物から <filename>INSTALL</filename>
	シェルスクリプトを実行してください。
	インストールプログラムからの質問には、
	<quote>RedHat</quote> オプションを選択してください。
	一般的なインストールのディレクトリは、<filename
	  class="directory">/usr/local/maple</filename> です。</para></step>

      <step><para><application>&maple;</application>
	のライセンスがなければ、
	Maple Waterloo Software (<link
	  xlink:href="http://register.maplesoft.com">http://register.maplesoft.com"</link>)
	で登録し、
	<filename>/usr/local/maple/license/license.dat</filename>
	にコピーしてください。</para></step>

      <step><para><application>&maple;</application> についてくる
	<filename>INSTALL_LIC</filename>
	というインストールシェルスクリプトを実行し、
	<application>FLEXlm</application>
	ラインセンスマネージャをインストールしてください。
	ライセンスサーバに対して、
	コンピュータのホスト名を設定してください。</para></step>

      <step><para>以下のパッチを
	<filename>/usr/local/maple/bin/maple.system.type</filename>
        ファイルにあててください。</para>
      <programlisting>   ----- snip ------------------
*** maple.system.type.orig      Sun Jul  8 16:35:33 2001
--- maple.system.type   Sun Jul  8 16:35:51 2001
***************
*** 72,77 ****
--- 72,78 ----
          # the IBM RS/6000 AIX case
          MAPLE_BIN="bin.IBM_RISC_UNIX"
          ;;
+     "FreeBSD"|\
      "Linux")
          # the Linux/x86 case
        # We have two Linux implementations, one for Red Hat and
   ----- snip end of patch -----</programlisting>

	<para><literal>"FreeBSD"|\</literal>
	  の後に空白を入れてはいけません。</para>

	<para>このパッチにより <application>&maple;</application> は、
	  <quote>FreeBSD</quote> を Linux システムと認識します。
	  <filename>bin/maple</filename> シェルスクリプトは
	  <filename>bin/maple.system.type</filename> を呼び出します。
	  このスクリプトは、<command>uname -a</command> を実行し、
	  オペレーティングシステムの名前を入手します。
	  OS 名にから、どのバイナリを使用するかを判断します。</para></step>

	<step><para>ライセンスサーバを起動してください。</para>

	<para><filename>/usr/local/etc/rc.d/lmgrd</filename>
	  としてインストールされる、以下のスクリプトは、
	  <command>lmgrd</command> を起動する便利な方法です。</para>

	<programlisting>   ----- snip ------------

#! /bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bn
PATH=${PATH}:/usr/local/maple/bin:/usr/local/maple/FLEXlm/UNIX/LINUX
export PATH

LICENSE_FILE=/usr/local/maple/license/license.dat
LOG=/var/log/lmgrd.log

case "$1" in
start)
	lmgrd -c ${LICENSE_FILE} 2&gt;&gt; ${LOG} 1&gt;&amp;2
	echo -n " lmgrd"
	;;
stop)
	lmgrd -c ${LICENSE_FILE} -x lmdown 2&gt;&gt; ${LOG} 1&gt;&amp;2
	;;
*)
	echo "Usage: `basename $0` {start|stop}" 1&gt;&amp;2
	exit 64
	;;
esac

exit 0
   ----- snip ------------</programlisting></step>


      <step><para><application>&maple;</application>
	を試験的に起動してください。</para>

      <screen>&prompt.user; <userinput>cd /usr/local/maple/bin</userinput>
&prompt.user; <userinput>./xmaple</userinput></screen>

      <para>maple を使う用意はできました。
	ネイティブ FreeBSD 版を希望していることを
	Maplesoft に連絡してください!</para></step>
    </procedure>

      <sect2>
	<title>落とし穴</title>

	<itemizedlist>
	  <listitem><para><application>FLEXlm</application>
	    ライセンスマネージャは、動かすことが難しいツールでもあります。
	    <link
	      xlink:href="http://www.globetrotter.com/">http://www.globetrotter.com/</link>
	    にも文書が用意されています。</para></listitem>

	  <listitem><para><command>lmgrd</command> は、
	    ライセンスファイルに依存し、問題があると
	    core dump してしまいます。
	    正しいライセンスファイルは以下のようなものです。</para>

	  <programlisting># =======================================================
# License File for UNIX Installations ("Pointer File")
# =======================================================
SERVER chillig ANY
#USE_SERVER
VENDOR maplelmg

FEATURE Maple maplelmg 2000.0831 permanent 1 XXXXXXXXXXXX \
         PLATFORMS=i86_r ISSUER="Waterloo Maple Inc." \
         ISSUED=11-may-2000 NOTICE=" Technische Universitat Wien" \
         SN=XXXXXXXXX</programlisting>

	  <note><para>シリアル番号およびキーは 'X' に置き換えています。
	    chillig は、ホスト名です。</para></note>

	  <para>ライセンスファイルを編集する際に、
	    (ライセンスキーで保護されている) <quote>FEATURE</quote>
	    の行を書き換えてしまうと、動かなくなるでしょう。</para></listitem>
	</itemizedlist>
      </sect2>
    </sect1>

    <sect1 xml:id="linuxemu-matlab">
      <info>
	<title>&matlab; のインストール</title>
	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Dan</firstname>
	      <surname>Pelleg</surname>
	    </personname>
	    <contrib>寄稿: </contrib>
	  </author>
	  <!-- daniel+handbook@pelleg.org -->
	</authorgroup>
      </info>

    <indexterm>
      <primary>applications</primary>
      <secondary><application>MATLAB</application></secondary>
    </indexterm>

    <para>この節では、&os; システムへ、Linux 版の
      <application>&matlab; version 6.5</application>
      をインストールするプロセスについて説明します。
      <application>&java.virtual.machine;</application>
      (<xref linkend="matlab-jre"/> をご覧ください) を除けば、
      極めてよく動作します。</para>

    <para>Linux 版の <application>&matlab;</application> は、
      MathWorks (<link
	xlink:href="http://www.mathworks.com">http://www.mathworks.com</link>)
      から直接注文することができます。
      ライセンスファイルを入手するか、
      ライセンスファイルを作成する手順を確認してください。
      彼らに対して、ネイティブの &os; 版を必要としていることを伝えてください。</para>

    <sect2>
      <title>&matlab; のインストール</title>

      <para><application>&matlab;</application>
	をインストールするには、以下のようにしてください。</para>

      <procedure>
	<step>
	  <para>インストール CD を挿入して、マウントしてください。
	    インストールスクリプトで推奨されているように、
	    <systemitem class="username">root</systemitem> になってください。
	    以下のように入力して、インストールスクリプトを実行してください。</para>

	  <screen>&prompt.root; <userinput>/compat/linux/bin/sh /cdrom/install</userinput></screen>

	  <tip>
	    <para>インストーラはグラフィカルです。
	      ディスプレイを表示できないエラーが起きるようでしたら、
	      <command>setenv HOME
		~<replaceable>USER</replaceable></command>
	      と実行してください。ここで、
	      <replaceable>USER</replaceable> は、
	      &man.su.1; を実行したユーザ名です。</para>
	  </tip>
	</step>

	<step>
	  <para>
	   <application>&matlab;</application>
	    ルートディレクトリの入力を求められたら、
	    <userinput>/compat/linux/usr/local/matlab</userinput>
	    と入力してください。</para>

	  <tip>
	    <para>残りのインストールプロセスでの入力を簡単にするために、
	      シェルプロンプトで、
	      <command>set
		  MATLAB=/compat/linux/usr/local/matlab</command>
	      と実行してください。</para>
	  </tip>
	</step>

	<step>
	  <para><application>&matlab;</application>
	    ライセンスを入手時の手順に従い、
	    ライセンスファイルを編集してください。</para>

	  <tip>
	    <para>あなたがいつも使っているエディタを使って、
	      このファイルを準備してください。
	      そして、インストーラが
	      <filename>$MATLAB/license.dat</filename> を編集するように尋ねる前に、
	      <filename>$MATLAB/license.dat</filename>
	      にコピーしてください。</para>
	  </tip>
	</step>

	<step>
	  <para>インストールプロセスを完了してください。</para>
	</step>
      </procedure>

      <para>この時点で、<application>&matlab;</application>
	のインストールは終わりました。
	以下の手順は、&os; システムに結びつけるための
	<quote>glue</quote> です。</para>
    </sect2>

    <sect2>
      <title>ライセンスマネージャの起動</title>

      <procedure>
	<step>
	  <para>ライセンスマネージャのスクリプトへのシンボリックリンクを作成してください。</para>

	  <screen>&prompt.root; <userinput>ln -s $MATLAB/etc/lmboot /usr/local/etc/lmboot_TMW</userinput>
&prompt.root; <userinput>ln -s $MATLAB/etc/lmdown /usr/local/etc/lmdown_TMW</userinput></screen>
	</step>
	
	<step>
	  <para>スタートアップファイルを
	    <filename>/usr/local/etc/rc.d/flexlm</filename>
	    に作成してください。
	    以下の例は、配布されている
	    <filename>$MATLAB/etc/rc.lm.glnx86</filename>
	    の改良版です。
	    変更点はファイルの位置、Linux
	    エミュレーションでライセンスマネージャを起動する点です。</para>

	  <programlisting>#!/bin/sh
case "$1" in
  start)
        if [ -f /usr/local/etc/lmboot_TMW ]; then
              /compat/linux/bin/sh /usr/local/etc/lmboot_TMW -u <replaceable>username</replaceable> &amp;&amp; echo 'MATLAB_lmgrd'
        fi
        ;;
  stop)
	if [ -f /usr/local/etc/lmdown_TMW ]; then
            /compat/linux/bin/sh /usr/local/etc/lmdown_TMW  &gt; /dev/null 2&gt;&amp;1
	fi
        ;;
  *)
	echo "Usage: $0 {start|stop}"
	exit 1
	;;
esac

exit 0</programlisting>

	  <important>
	    <para>ファイルに対し実行の権限を指定してください。</para>

	    <screen>&prompt.root; <userinput>chmod +x /usr/local/etc/rc.d/flexlm</userinput></screen>

	    <para>ここで、上記のコマンドの中の、
	      <replaceable>username</replaceable> を
	      (<systemitem class="username">root</systemitem> ではなく)
	      システムに存在するユーザの名前に置き換えてください。</para>
	  </important>
	</step>

	<step>
	  <para>以下のコマンドでライセンスマネージャを起動してください。</para>

	  <screen>&prompt.root; <userinput>service flexlm start</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="matlab-jre">
      <title>&java; Runtime Environment のリンク</title>

      <para><application>&java;</application> Runtime
	Environment (JRE) のリンクを、&os; の作業場所に変更してください。</para>

      <screen>&prompt.root; <userinput>cd $MATLAB/sys/java/jre/glnx86/</userinput>
&prompt.root; <userinput>unlink jre; ln -s ./jre1.1.8 ./jre</userinput></screen>
    </sect2>

    <sect2>
      <title>&matlab; 起動スクリプトの作成</title>

      <procedure>
	<step>
	  <para>以下の起動スクリプトを
	    <filename>/usr/local/bin/matlab</filename>
	    に置いてください。</para>

	  <programlisting>#!/bin/sh
/compat/linux/bin/sh /compat/linux/usr/local/matlab/bin/matlab "$@"</programlisting>
	</step>

	<step>
	  <para>その後、
	    <command>chmod +x /usr/local/bin/matlab</command>
	    コマンドを実行してください。</para>
	</step>
      </procedure>

      <tip>
	<para>使用している
	  <filename role="package">emulators/linux_base</filename>
	  のバージョンによっては、
	  このスクリプトを実行するとエラーが出ることがあります。
	  これを避けるためには、
	  <filename>/compat/linux/usr/local/matlab/bin/matlab</filename>
	  ファイルを編集して、以下の行を変更してください。</para>

	<programlisting>if [ `expr "$lscmd" : '.*-&gt;.*'` -ne 0 ]; then</programlisting>

	<para>この行 (バージョン 13.0.1 では、410 行目にあります) を、
	  以下に置きかえてください。</para>

	<programlisting>if test -L $newbase; then</programlisting>
      </tip>
    </sect2>

    <sect2>
      <title>&matlab; シャットダウンスクリプトの作成</title>

      <para>以下のスクリプトは、&matlab; が正常に終了しない問題を解決します。</para>

      <procedure>
	<step>
	  <para><filename>$MATLAB/toolbox/local/finish.m</filename>
	    ファイルを作成して、以下の一行を加えてください。</para>

	  <programlisting>! $MATLAB/bin/finish.sh</programlisting>

	  <note><para>ここで <literal>$MATLAB</literal> は、
	    文字通り入力してください。</para></note>

	  <tip>
	    <para>同じディレクトリの中には、
	      <filename>finishsav.m</filename> および
	      <filename>finishdlg.m</filename> というファイルがあります。
	      それらのファイルは、終了する前にワークスペースを保存します。
	      これらのうちどちらかを使うには、
	      <literal>save</literal> コマンドのすぐ後に、
	      上記の行を挿入してください。</para></tip>
	  </step>

	  <step>
	    <para>以下の行を含む、
	      <filename>$MATLAB/bin/finish.sh</filename>
	      ファイルを作成してください。</para>

	    <programlisting>#!/compat/linux/bin/sh
(sleep 5; killall -1 matlab_helper) &amp;
exit 0</programlisting>
	</step>

	<step>
	  <para>ファイルを実行可能に設定してください。</para>

	  <screen>&prompt.root; <userinput>chmod +x $MATLAB/bin/finish.sh</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="matlab-using">
      <title>&matlab; を使用する</title>

      <para>この時点で、
	<command>matlab</command> を実行できるようになったので、
	起動して使用してください。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="linuxemu-oracle">
    <info><title>&oracle; のインストール</title>
      <authorgroup>
	<author><personname><firstname>Marcel</firstname><surname>Moolenaar</surname></personname><contrib>寄贈: </contrib></author>
	<!-- marcel@cup.hp.com -->
      </authorgroup>
    </info>
    

    <indexterm>
      <primary>アプリケーション</primary>
      <secondary><application>Oracle</application></secondary>
    </indexterm>

    <sect2>
      <title>はじめに</title>

      <para>このドキュメントでは <application>&oracle; 8.0.5</application>
	と <application>&oracle; 8.0.5.1 Enterprise Edition</application>
	の Linux 版を FreeBSD にインストールするための手順を解説します。</para>
    </sect2>

    <sect2>
      <title>Linux 環境のインストール</title>

      <para>まずは Ports Collection から <filename 
	  role='package'>emulators/linux_base</filename> と
	<filename role='package'>devel/linux_devtools</filename>
	をインストールしてください。
	もしこれらの ports がうまく動かなければ、package
	もしくは Ports Collection
	で利用可能な古いバージョンを試してみてください。</para>

      <para>もし賢いエージェント (intelligent agent) を起動したいなら
	Red Hat Tcl パッケージ <filename>tcl-8.0.3-20.i386.rpm</filename>
	もインストールする必要があるでしょう。
	公式の <application>RPM</application> port (<filename
	  role='package'>archivers/rpm</filename>)
	をインストールするには一般的に次のようにします。</para>

      <screen>&prompt.root; <userinput>rpm -i --ignoreos --root /compat/linux --dbpath /var/lib/rpm package</userinput></screen>

      <para><replaceable>package</replaceable>
	のインストール時にエラーが出てはいけません。</para>
    </sect2>

    <sect2>
      <title>&oracle; 環境の構築</title>

      <para><application>&oracle;</application> をインストールする前に、
	適切な環境を設定する必要があります。
	このドキュメントでは、<application>&oracle;</application>
	のインストールガイドに書いてあるようなことではなく
	FreeBSD で Linux 用 <application>&oracle;</application>
	を動かすために<emphasis>特別に</emphasis>必要なことのみを解説します。</para>

      <sect3 xml:id="linuxemu-kernel-tuning">
	<title>カーネルのチューニング</title>

	<indexterm><primary>カーネルのチューニング</primary></indexterm>

	<para><application>&oracle;</application> インストールガイドにあるように、
	  シェアードメモリーの最大サイズを設定しなければいけません。
	  FreeBSD では <literal>SHMMAX</literal> を使わないようにしてください。
	  <literal>SHMMAX</literal> は単に <literal>SHMMAXPGS</literal>
	  と <literal>PGSIZE</literal> から計算されるだけなのです。
	  従って、<literal>SHMMAXPGS</literal> を使うようにしましょう。
	  インストールガイドに記述されている他のオプションは使えます。
	  例えば以下のようにします。</para>

	<programlisting>options SHMMAXPGS=10000
options SHMMNI=100
options SHMSEG=10
options SEMMNS=200
options SEMMNI=70
options SEMMSL=61</programlisting>

	<para>これらのオプションを意図した <application>&oracle;</application>
	  の使い方に合わせて設定してください。</para>

	<para>また、
	  次のオプションがカーネルのコンフィギュレーションファイルにあることも確認します。</para>

	<programlisting>options SYSVSHM #SysV shared memory
options SYSVSEM #SysV semaphores
options SYSVMSG #SysV interprocess communication</programlisting>
      </sect3>

      <sect3 xml:id="linuxemu-oracle-account">

	<title>&oracle; 用アカウント</title>

	<para>他のアカウントを作るのと同じように
	  <systemitem class="username">oracle</systemitem>
	  用のアカウントを作ります。
	  <systemitem class="username">oracle</systemitem>
	  用のアカウントに特別なのは
	  Linux のシェルを割り当てるところだけです。
	  <filename>/etc/shells</filename> に
	  <literal>/compat/linux/bin/bash</literal> を加え、<systemitem
	    class="username">oracle</systemitem> 用のアカウントに設定します。</para>
      </sect3>

      <sect3 xml:id="linuxemu-environment">
	<title>環境設定</title>

	<para><envar>ORACLE_HOME</envar> や <envar>ORACLE_SID</envar>
	  といった通常の <application>&oracle;</application>
	  用の変数の他に次の変数も設定しなければなりません。</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="2*"/>
	    <thead>
	      <row>
		<entry>変数</entry>

		<entry>値</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><envar>LD_LIBRARY_PATH</envar></entry>

		<entry><literal>$ORACLE_HOME/lib</literal></entry>
	      </row>

	      <row>
		<entry><envar>CLASSPATH</envar></entry>

		<entry><literal>$ORACLE_HOME/jdbc/lib/classes111.zip</literal></entry>
	      </row>

	      <row>
		<entry><envar>PATH</envar></entry>

		<entry><literal>/compat/linux/bin
		    /compat/linux/sbin
		    /compat/linux/usr/bin
		    /compat/linux/usr/sbin
		    /bin
		    /sbin
		    /usr/bin
		    /usr/sbin
		    /usr/local/bin
		  $ORACLE_HOME/bin</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>全ての環境変数は <filename>.profile</filename>
	  で設定することをお勧めします。
	  完璧なサンプルは以下の通りです。</para>

	<programlisting>ORACLE_BASE=/oracle; export ORACLE_BASE
ORACLE_HOME=/oracle; export ORACLE_HOME
LD_LIBRARY_PATH=$ORACLE_HOME/lib
export LD_LIBRARY_PATH
ORACLE_SID=ORCL; export ORACLE_SID
ORACLE_TERM=386x; export ORACLE_TERM
CLASSPATH=$ORACLE_HOME/jdbc/lib/classes111.zip
export CLASSPATH
PATH=/compat/linux/bin:/compat/linux/sbin:/compat/linux/usr/bin
PATH=$PATH:/compat/linux/usr/sbin:/bin:/sbin:/usr/bin:/usr/sbin
PATH=$PATH:/usr/local/bin:$ORACLE_HOME/bin
export PATH</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>&oracle; のインストール</title>

      <para>インストーラーを起動する前に、<filename>/var/tmp</filename>
	に <filename>.oracle</filename>
	という名前のディレクトリを作る必要がありますが、
	これは Linux エミュレーターにおけるちょっとした不整合のためです。
	このディレクトリは <systemitem class="username">oracle</systemitem>
	ユーザーのものにしておきます。
	これで特に問題なく <application>&oracle;</application>
	がインストールできるでしょう。
	もし問題が起こったら、まずは <application>&oracle;</application>
	の配布物や設定をチェックしてください。
	<application>&oracle;</application>
	のインストールが終わったら次の二つのサブセクションで解説するパッチを当てます。</para>

      <para>よくあるトラブルは、TCP
	プロトコルアダプターが正しくインストールされていないことです。
	そのため、一切 TCP リスナーを起動することができないのです。
	次の操作はこの問題を解決するのに役立ちます。</para>

      <screen>&prompt.root; <userinput>cd $ORACLE_HOME/network/lib</userinput>
&prompt.root; <userinput>make -f ins_network.mk ntcontab.o</userinput>
&prompt.root; <userinput>cd $ORACLE_HOME/lib</userinput>
&prompt.root; <userinput>ar r libnetwork.a ntcontab.o</userinput>
&prompt.root; <userinput>cd $ORACLE_HOME/network/lib</userinput>
&prompt.root; <userinput>make -f ins_network.mk install</userinput></screen>

      <para>もう一度 <filename>root.sh</filename> を起動するのを忘れないように!</para>

    <sect3 xml:id="linuxemu-patch-root">
      <title>root.sh へのパッチ</title>

      <para><application>&oracle;</application> をインストールする時、
	<systemitem class="username">root</systemitem>
	で行なう必要のあるいくつかの操作は <filename>root.sh</filename>
	と呼ばれるシェルスクリプトに記録されます。
	このスクリプトは、<filename>orainst</filename>
	ディレクトリにあります。次のパッチを <filename>root.sh</filename> に当てて
	正しい場所にある <command>chown</command> コマンドを使うようにするか、
	代わりに Linux ネイティブなシェルのもとでスクリプトを走らせましょう。</para>

      <programlisting>*** orainst/root.sh.orig Tue Oct 6 21:57:33 1998
--- orainst/root.sh Mon Dec 28 15:58:53 1998
***************
*** 31,37 ****
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/bin/chown
#
# Define variables to be used in this script
--- 31,37 ----
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/usr/sbin/chown
#
# Define variables to be used in this script</programlisting>

	<para><application>&oracle;</application>
	  を CD-ROM からインストールしない場合は <filename>root.sh</filename>
	  のソースにパッチを当ててもいいでしょう。
	  <filename>rthd.sh</filename> という名前でソースツリーの
	  <filename>orainst</filename> というディレクトリにあります。</para>
      </sect3>

      <sect3 xml:id="linuxemu-patch-tcl">
	<title>genclntsh へのパッチ</title>

	<para><command>genclntsh</command>
	  スクリプトは一つの共有クライアントライブラリを生成するのに用いられます。
	  これはデモを作る時に使われます。<envar>PATH</envar>
	  の定義をコメントアウトするために次のパッチを当ててください。</para>

	<programlisting>*** bin/genclntsh.orig Wed Sep 30 07:37:19 1998
--- bin/genclntsh Tue Dec 22 15:36:49 1998
***************
*** 32,38 ****
#
# Explicit path to ensure that we're using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst
--- 32,38 ----
#
# Explicit path to ensure that we're using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! #PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>&oracle; の起動</title>

      <para>インストラクションに従えば、Linux でと同じように
	<application>&oracle;</application> を起動できるでしょう。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="linuxemu-advanced">
    <title>高度なトピックス</title>

    <para>Linux
      バイナリ互換機能がどのような仕組みなのか興味がある人はこのセクションを読んでください。
      以下の文章で説明されていることのほとんどは &a.chat; に投稿された
      Terry Lambert (<email>tlambert@primenet.com</email>) 氏のメール
      (Message ID: <literal>&lt;199906020108.SAA07001@usr09.primenet.com&gt;</literal>)
      をもとにしています。</para>

    <sect2>
      <title>どのように動くのでしょう?</title>

      <indexterm><primary>execution class loader</primary></indexterm>

      <para>FreeBSD は、&ldquo;実行クラスローダ (execution class loader) &rdquo;
	と呼ばれる抽象的な機構を持っています。これは &man.execve.2;
	システムコールへの楔という形で実装されています。</para>

      <para>FreeBSD は、シェルインタプリタやシェルスクリプトを実行するための
	<literal>#!</literal> ローダを持った単一のプログラムローダではなく、
	ローダのリストを持っているのです。</para>

      <para>歴史的には、&unix; プラットフォーム上の唯一のローダーがマジックナンバー
	(一般的にはファイルの先頭の 4 ないし 8 バイトの部分)
	の検査を行ないシステムで実行できるバイナリかどうかを検査し、
	もしそうならバイナリローダーを呼び出すというようになっていました。</para>

      <para>もし、そのシステム用のバイナリでない場合には、
	&man.execve.2; システムコールの呼び出しは失敗の戻り値を返し、
	シェルがシェルコマンドとして実行しようと試みていたわけです。</para>

      <para>この仮定は<quote>現在利用しているシェルがどのようなものであっても</quote>変わりません。</para>

      <para>後に &man.sh.1; に変更が加えられ、先頭の 2 バイトを検査した結果
	<literal>:\n</literal> であれば代わりに &man.csh.1; を呼び出す、
	というようになりました (この変更は SCO が最初に行なったと思われます)。</para>

      <para>現在の FreeBSD は、プログラムローダリストを走査します。
	その際、空白文字までの文字列をインタプリタとして認識する、
	通常の <literal>#!</literal> ローダを用いるため、
	該当するものが存在しなければ最終的に /bin/sh がロードされます。</para>
      <indexterm><primary>ELF</primary></indexterm>

      <para>Linux ABI をサポートするため、FreeBSD は
	ELF バイナリを示すマジックナンバを確認します。
	(ただし、この段階では FreeBSD、&solaris;, Linux、そしてその他の
	ELF イメージ形式を使っている OS を区別することはできません)。</para>
      <indexterm><primary>Solaris</primary></indexterm>

      <para>ELF ローダは、特殊な<emphasis>マーク (brand)</emphasis>
	があるかどうか探します。
	このマークとは、ELF イメージのコメントセクションのことです。
	SVR4/&solaris; の ELF バイナリには、このセクションは存在しません。</para>

    <para>Linux バイナリを実行するためには、
      ELF バイナリに &man.brandelf.1; で説明されている
      <literal>Linux</literal> のマークが<emphasis>付けられて</emphasis>いなければなりません。</para>

    <screen>&prompt.root; <userinput>brandelf -t Linux file</userinput></screen>

    <para>上のようにすることで、指定されたファイルは
	<literal>Linux</literal> のマークが付けられ、
	ELF ローダが認識できるようになります。</para>
      <indexterm>
	<primary>ELF</primary>
	<secondary>branding</secondary>
      </indexterm>

      <para>ELF ローダが <literal>Linux</literal> マークを確認すると、
	ローダは <literal>proc</literal> 構造体内の
	ある一つのポインタを置き換えます。システムコールは全て、
	このポインタ (伝統的な &unix; システムではこれは構造体の配列
	<literal>sysent[]</literal> で、システムコールが含まれています)
	を通してインデックスされます。
	さらに、そのプロセスには Linux
	カーネルモジュールに必要なシグナルトランポリンコード (訳注:
	シグナルの伝播を実現するコード) 用の特殊なトラップベクタの設定や、
	他の (細かな) 調整のための設定が行なわれます。</para>

      <para>Linux システムコールベクタは、
	さまざまなデータに加えて <literal>sysent[]</literal>
	エントリーのリストを含んでおり、
	それらのアドレスはカーネルモジュール内にあります。</para>

      <para>Linux バイナリがシステムコールを発行する際、トラップコードは
	<literal>proc</literal> 構造体を用いてシステムコール関数ポインタを
	解釈します。そして FreeBSD ではなく
	Linux 用のシステムコールエントリポイントを得るわけです。</para>

      <para>さらに、Linux
	モードは状況に応じて<emphasis>ファイルシステム本来のルートマウントポイントを置き換えて</emphasis>ファイルの参照を行ないます。
	これは、<option>union</option>
	オプションを指定してマウントされたファイルシステム
	(<literal>unionfs</literal>
	ファイルシステムでは<emphasis>ありません!</emphasis>)
	が行なっていることと同じです。
	ファイルを検索する際にはまず
	<filename>/compat/linux/original-path</filename>
	ディレクトリを、<emphasis>それから</emphasis>見つけられなかったときにのみ、
	<filename>/original-path</filename>
	を調べます。
	こうすることで、他のバイナリを要求するバイナリの実行を可能にしています
	(したがって、Linux 用プログラムツールは
	Linux ABI サポート環境下で完全に動作するわけです)。
	またこれは、もし対応する Linux バイナリが存在しない場合に
	Linux バイナリが FreeBSD バイナリをロードしたり、
	実行したりすることが可能であること、
	その Linux バイナリに自分自身が Linux 上で実行されていないことを
	気付かせないようにする目的で、&man.uname.1; コマンドを
	<filename>/compat/linux</filename> ディレクトリに置くことができる、
	ということを意味します。</para>

      <para>要するに、Linux カーネルが FreeBSD カーネルの内部に存在しているわけです。
	カーネルによって提供されるサービス全ての実装の基礎となるさまざまな関数は
	FreeBSD システムコールテーブルエントリと
	Linux システムコールテーブルエントリの両方で共通に利用されています。
	これらにはファイルシステム処理、仮想メモリ処理、シグナル伝送、
	System V IPC などが含まれますが、
	FreeBSD バイナリは FreeBSD <emphasis>グルー</emphasis> (訳注: glue;
	二者の間を仲介するという意味) 関数群、
	そして Linux バイナリは Linux <emphasis>グルー</emphasis>関数群を用いる、
	という点だけが異なります (過去に存在したほとんどの OS は、
	自分自身のための<emphasis>グルー</emphasis>関数群しか備えていません。
	前述したように、システムコールを発行する際、
	各々のプロセスの <literal>proc</literal> 構造体内にある、
	ローダによって動的に初期化されるポインタを参照してアドレスを得る代わりに、
	静的でグローバルな <literal>sysent[]</literal> 構造体の配列に
	システムコール関数のアドレスが直接格納されているのです)。</para>

      <para>さて、どちらを本来の FreeBSD ABI (訳注: Applications Binary Interface;
	同じ CPU を利用したコンピュータ間でバイナリを共有するための規約のこと)
	と呼ぶべきなのでしょうか?
	実は、どちらが本来のものであるかということを論ずることに意味はありません。
	基本的に、FreeBSD
	<emphasis>グルー</emphasis>関数群はカーネルの中に静的にリンクされていて、
	Linux <emphasis>グルー</emphasis>関数群は静的にリンクすることも、
	カーネルモジュールを介して利用することもできるようになっている、
	という違いがあるだけ (ただしこれは現時点においての話であり、
	将来のリリースで変更される可能性がありますし、
	おそらく実際に変更されるでしょう) です。</para>

      <para>あ、「でもこれは本当にエミュレーションと呼べるのか」って?
	答えは「いいえ」です。これは ABI の実装であり、
	エミュレーションとは異なります。
	エミュレータが呼び出されているわけではありません
	(シミュレータでもないことをあらかじめ断っておきましょう)。</para>

      <para>では、これがよく <quote>Linux
	エミュレーション</quote>と呼ばれるのは何故でしょうか?
	それはもちろん FreeBSD の売りにするためでもあるのですが、
	実際には、次のような理由によります。
	この機能が初めて実装された頃、
	動作原理を説明する以外にこの機能を表現する言葉はありませんでした。
	しかし、コードをコンパイルしたりモジュールをロードしない場合、
	「FreeBSD 上で Linux バイナリを実行する」という表現は、
	厳密に考えると適切ではありません。
	そこで、その際にロードされているもの自身を表現する言葉 &mdash; すなわち
	<quote>Linux エミュレータ</quote>が必要だったのです。</para>
    </sect2>
  </sect1>
</chapter>
