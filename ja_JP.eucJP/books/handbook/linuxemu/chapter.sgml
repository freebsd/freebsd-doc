<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.27
     $FreeBSD: doc/ja_JP.eucJP/books/handbook/linuxemu/chapter.sgml,v 1.11 2000/01/06 03:44:41 kuriyama Exp $
-->

<chapter id="linuxemu">
  <title>Linux モード</title>

  <para><emphasis>寄稿: &a.handy; and &a.rich;</emphasis></para>
  <para><emphasis>訳: &a.jp.kiroh;, 1996 年 9 月 24 日.</emphasis></para>

  <sect1>
    <title>Linux モードのインストール</title>

    <para>FreeBSD における Linux バイナリ互換機能は, 大部分の Linux
      バイナリ(a.out および ELF
      フォーマット)を実行できる状態になっています. 2.1-STABLE ブラン
      チでの Linux バイナリ互換機能は, Linux DOOM や Mathematica
      が実行できます. &rel.current;-RELEASE でのエミュレーションは,
      さらに強化されており, Linux 用 の Oracle8,
      WordPerfect, StarOffice, Acrobat, Quake, Abuse, IDL,
      netrek for Linux など, 多数のソフトウェアが実行できます.</para>

    <para>Linux
      オペレーティングシステムには, 特有の機能がいくつかあり, FreeBSD
      でサポートされていないものもあります. Linux の
      <filename>/proc</filename> ファイルシステムに過度に依存したバイナリは,
      FreeBSD では実行できません (FreeBSD で使用可能な
      <filename>/proc</filename>
      ファイルシステムとは仕様が異なっているためです).
      また仮想 8086モードを有効にするなど, i386
      に特有なシステムコールを使っている場合も実行できません.</para>

    <para>Linux モードの設定方法は, 使用している FreeBSD
      のバージョンによっていくらか異なっています.</para>

    <sect2>
      <title>3.0-RELEASE 以降への
      Linux バイナリ互換機能のインストール</title>

      <para><literal>options LINUX</literal> や <literal>options
	  COMPAT_LINUX</literal> を指定する必要はなくなりました.
	Linux バイナリ互換機能は
	KLD オブジェクト(&ldquo;Kernel LoaDable object&rdquo;)
        を使用しているため, インストールの際に再起動する必要はありません.
        ただし, スタートアップファイルで以下のように指定する必要があります.</para>

      <orderedlist>
	<listitem>
	  <para><filename>/etc/rc.conf</filename>
	    に以下の行が必要です.</para>

	  <programlisting>
linux_enable=YES</programlisting>
	</listitem>

	<listitem>
	  <para>これは結果的に, <filename>/etc/rc.i386</filename>
	    の以下の指定を有効にします.</para>

	  <programlisting>
# Start the Linux binary compatibility if requested.
if [ "X${linux_enable}" = X"YES" ]; then echo -n '
        linux';               linux &gt; /dev/null 2&gt;&amp;1
fi</programlisting>
	</listitem>
      </orderedlist>

      <para>KLD がきちんとロードされたかどうかを確認するには,
      <command>kldstat</command> を使用します.</para>

      <screen>&prompt.user; kldstat
Id Refs Address    Size     Name
 1    2 0xc0100000 16bdb8   kernel
 7    1 0xc24db000 d000     linux.ko</screen>

      <para>
      何らかの理由で Linux KLD をロードしたくない,
      あるいはロードできないような場合には,

	<programlisting>
options  LINUX</programlisting>

	をカーネルの設定ファイルに指定して,
	Linux バイナリ互換機能をカーネルにスタティックリンク
	してください.
	<link linkend="kernelconfig">
	  FreeBSDカーネルのコンフィグレーション</link>
	の節の記述にしたがって <command>config</command> と,
	新しいカーネルのインストールをおこ
	なってください.</para>
    </sect2>


    <sect2>
      <title>2.2.2-RELEASE およびそれ以降の 2.2.x 系列への
      Linux モードのインストール</title>

      <para><literal>options LINUX</literal> や <literal>options
	  COMPAT_LINUX</literal> を指定する必要はなくなりました.
	Linux バイナリ互換機能は
	LKM(&ldquo;Loadable Kernel Module&rdquo;)
        を使用しているため, インストールの際に再起動する必要はありません.
        ただし, スタートアップファイルで以下のように指定する必要があります.</para>

      <orderedlist>
	<listitem>
	  <para><filename>/etc/rc.conf</filename>
	    に以下の行が必要です.</para>

	  <programlisting>
linux_enable=YES</programlisting>
	</listitem>

	<listitem>
	  <para>これは結果的に, <filename>/etc/rc.i386</filename>
	    の以下の指定を有効にします.</para>

	  <programlisting>
# Start the Linux binary emulation if requested.
if [ "X${linux_enable}" = X"YES" ]; then echo -n '
        linux';               linux &gt; /dev/null 2&gt;&amp;1
fi</programlisting>
	</listitem>
      </orderedlist>

      <para>実行されたかどうかを確認するには,
      <command>modstat</command> を使用します.</para>
      <!-- kuriyama - command? -->

      <screen>&prompt.user; modstat
Type     Id Off Loadaddr Size Info     Rev Module Name
EXEC      0   4 f09e6000 001c f09ec010   1 linux_mod</screen>

      <para>2.2-RELEASE とそれ以降のシステムの中には,
	modstat の実行がうまくいかない
	ものがあるという報告もあります.
	何らかの理由で, Linux LKM がロードできな
	い場合は,

	<programlisting>
options  LINUX</programlisting>

	をカーネルの設定ファイルに指定して,
	Linux バイナリ互換機能をカーネルにスタティックリンク
	してください.
	<link linkend="kernelconfig">
	  FreeBSDカーネルのコンフィグレーション</link>
	の節の記述にしたがって <command>config</command> と,
	新しいカーネルのインストールをおこ
	なってください.</para>
    </sect2>

    <sect2>
      <title>2.1-STABLE への Linux モードのインストール</title>

      <para>2.1-STABLE の <filename>GENERIC</filename> カーネルは,
	Linux との互換性を保つように構築されていません.
	カーネルの再構築が必要です. 再構築をおこなうには, 2つの方
	法があります. 1つは,
	バイナリ互換機能をカーネル自体にスタティックリンクする方法.
	もう1つは, 動的に Linux
	ローダブルカーネルモジュール(LKM)をロー
	ドするようにする方法です.</para>

      <para>Linux バイナリ互換機能を有効にするには,
	以下をコンフィグレーションファイル
	(<filename>/sys/i386/conf/LINT</filename> など)
	に追加します.</para>

      <programlisting>
options COMPAT_LINUX</programlisting>

      <para>Linux DOOM などのアプリケーションを実行したい場合は,
	共有メモリも有効 にしておかなければなりません.
	以下を追加します.</para>

      <programlisting>
options SYSVSHM</programlisting>

      <para>Linux のシステムコールを使用するには, 4.3BSD と互換性のある
	システムコールを備えていることが必要です.
	以下の行が含まれていることを確認してください.</para>

      <programlisting>
options "COMPAT_43"</programlisting>

      <para>LKM(Loadable Kernel Module)
	を使用せず, バイナリ互換機能をカーネルに
        スタティックリンクしたい場合は, 以下の行を追加します.</para>

      <programlisting>
options  LINUX</programlisting>

      <para><link linkend="kernelconfig"> FreeBSD
	カーネルのコンフィグレーション </link> の節の記述に
	したがって <command>config</command> と,
	新しいカーネルのインストールをおこなってください.</para>

      <para>LKM を使用する場合は,
	ローダブルモジュールをインストールしなければなりません.
	カーネルとローダブルモジュールのバージョンが異なると, カーネル
	がクラッシュする場合がありますので, 安全を期すためには,
	カーネルをインストールするたびに, LKM
	も再インストールしてください.</para>

      <screen>&prompt.root; <userinput>cd /usr/src/lkm/linux</userinput>
&prompt.root; <userinput>make all install</userinput></screen>

      <para>カーネルと LKM のインストールが終了したら, root で
        <command>linux</command>
	コマンドを 実行することで LKM をロードできます.</para>

      <screen>&prompt.root; <userinput>linux</userinput>
Linux emulator installed
Module loaded as ID 0
&prompt.root; </screen>

      <para>LKM がロードされたかどうかを確認するには,
	<command>modstat</command> を実行します.</para>

      <screen>&prompt.user; modstat
Type     Id Off Loadaddr Size Info     Rev Module Name
EXEC      0   3 f0baf000 0018 f0bb4000   1 linux_emulator</screen>

      <para>システムブート時に, LKM をロードするようにするには,
	2つの方法がありま
	す. FreeBSD 2.2.1-RELEASE または 2.1-STABLE では,
	<filename>/etc/sysconfig</filename> を,

	<programlisting>
linux=YES</programlisting>

	のように, <literal>NO</literal> を <literal>YES</literal>
        に変更してください. FreeBSD 2.1-RELEASE
        およびそれ以前のバージョンでは, そのような行はありませんので,
	<filename>/etc/rc.local</filename> に以下
	の行を追加する必要があります.</para>

      <programlisting>
linux</programlisting>
    </sect2>

    <sect2>
      <title>Linux ランタイムライブラリのインストール</title>

      <sect3>
	<title>linux_base port を使用してのインストール</title>

	<para>多くの Linux
	  アプリケーションはシェアードライブラリを使用しますので,
	  シェアードライブラリのインストールが終了しなければ,
	  エミュレータのインストールは終わったことになりません.
	  手動でもインストールできますが, linux_base port
	  を使用するのが簡単です.</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/emulators/linux_base</userinput>
&prompt.root; <userinput>make all install</userinput></screen>

	<para>これで, Linux
	  バイナリ互換機能が動作するようになったはずです.
          聞くところ(とメールのアーカイブ <!-- smiley --> :-) によれば,
          Linux バイナリ互換機能は ZMAGIC ライブラリとリンクされている
	  Linux バイナリに対して, 最もうまく動作するようです.
	  Slackware V2.0 などに使われている QMAGIC ライブラリだと,
	  Linux バイナリ互換機能が胸やけするかもしれません.
	  マイナーバージョンの不一致などを
	  報告するプログラムもありますが,
	  普通は 問題にならないようです.</para>
      </sect3>

      <sect3>
	<title>手動でのライブラリのインストール</title>

	<para>&ldquo;ports&rdquo;
	  ディストリビューションが手元にない場合は, 手動でライブラ
	  リをインストールする必要があります. プログラムが必要とする
	  Linux のシェアードライブラリとランタイムリンカが必要です.
	  また Linux ライブラリ の用の``shadow root'' ディレクトリ,
	  <filename>/compat/linux</filename>, を作成する必要があ
	  ります.  FreeBSD で動作する Linux
	  のプログラムが使用するシェアードライ
	  ブラリは,まずこのファイルツリーから検索されます. 例えば,
	  Linux のプログラムが <filename>/lib/libc.so</filename>
	  をロードしようとした場合には, FreeBSD は, まず
	  <filename>/compat/linux/lib/libc.so</filename>
	  を開こうとします. 存在にしなかった場合には, 次に
	  <filename>/lib/libc.so</filename> を試します.
	  シェアードライブラリは, Linux の <command>ld.so</command>
	  が参照するライブラリではなく,
	  <filename>/compat/linux/lib</filename>
	  以下にインストールする 必要があります.</para>

	<!-- kuriyama - why command? -->
	<para>FreeBSD 2.2-RELEASE 以降では,
	  <command>/compat/linux</command>
	  にかかわる動作が多少異なっており,
	  ライブラリだけでなくすべてのファイルが,  &ldquo;shadow
	  root&rdquo; /compat/linux
	  から検索されるようになっています.</para>

	<para>Linux のプログラムが必要とする
	  シェアードライブラリを探す必要があるのは, FreeBSD
	  のシステムに Linux
	  のプログラムをインストールする最初の数回だけでしょう.
	  それが過ぎれば, 十分な Linux のシェアードライブラリがシス
	  テムにインストールされ, 新しくインストールした Linux
	  のバイナリも, 余
	  計な作業をせずに動作させることができるようになります.</para>
      </sect3>

      <sect3>
	<title>シェアードライブラリの追加</title>

	<para><filename>linux_base</filename> port をインストールした後に,
	  アプリケーションが必要なライブラリ
	  が存在しないというエラーを出したらどうしたらよいでしょうか?
	  Linux のバ イナリがどのシェアードライブラリを必要とし,
	  そしてどこで入手できるか, どのように探したらよいでしょうか?
	  基本的には, 以下の2種類の方法があり
	  ます(以下の手順にしたがう場合には,
	  必要なインストール作業をおこなう FreeBSD システム上で root
	  として作業をおこなう必要があります).</para>

	<para>Linux システムを使用でき,
	  必要なシェアードライブラリが調べられる場 合には, 単に
	  FreeBSD のシステムにそのライブラリをコピーするだけで す.
	  例えば, DOOM の Linux バイナリを ftp で持ってきたとします.
	  使用で きる Linux システムの上に転送して, <command>ldd
	    linuxxdoom</command> とやれば, 必要とす
	  るシェアードライブラリがチェックできます.</para>

	<screen>&prompt.user; <userinput>ldd linuxxdoom</userinput>
libXt.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libX11.so.3.1.0
libc.so.4 (DLL Jump 4.5pl26) =&gt; /lib/libc.so.4.6.29</screen>

	<para>最後のカラムに表示されている
	  すべてのファイルを持って来て,
	  <filename>/compat/linux</filename> の下 に置き,
	  最初のカラムに示されるファイル名から
	  シンボリックリンクを張る必 要があります. すなわち, FreeBSD
	  のシステムで, 以下のようなファイルが必要となります.</para>

	<!-- kuriyama - Here of English ver. should be checked. -->
	<screen>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>

	<note>
	  <para>最初のカラムに表示されているファイルと,
	    メジャーバージョンの同じ Linux
	    シェアードライブラリを既にインストールしている場合は,
	    新たにコピーする 必要はありません.
	    既にあるライブラリで動作するはずです. ただ, 新しいバー
	    ジョンのシェアードライブラリがある場合は,
	    新しいものをコピーすることを お奨めします.
	    新しいライブラリにシンボリックリンクを変更したら, 古いラ
	    イブラリは削除してかまいません.

	    <screen>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</screen>

	    以上のようなライブラリがインストールされており,
	    新しいバイナリに対する
	    <command>ldd</command> の出力が
	    以下のようになる場合を考えます.</para>

	  <screen>libc.so.4 (DLL Jump 4.5pl26) -&gt; libc.so.4.6.29</screen>

	  <para>このように最後の番号が1つか2つ古いだけならば, 普通は
	    <filename>/lib/libc.so.4.6.29</filename>
	    をコピーする必要はありません. わずかに古いライブラリでも,
	    プログラムは動作するはずだからです. もちろん,
	    新しいライブラリと置き換えて,
	    以下のようにしても構いません.</para>

	  <screen>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>
	</note>

	<note>
	  <para>シンボリックリンクのメカニズムは, Linux
	    バイナリに<emphasis>のみ</emphasis>必要
	    なことに注意してください. FreeBSD のランタイムリンカは,
	    メジャーリビジョ
	    ン番号の一致したライブラリを検索しますから,
	    ユーザが気にする必要はありません.</para>
	</note>
      </sect3>

      <sect3>
	<title><filename>ld.so</filename> の設定 &mdash; FreeBSD
	  2.2-RELEASE およびそれ以降</title>

	<para>このセクションは, FreeBSD 2.2-CURRENT
	  以降にのみ当てはまります. 2.1-STABLE を使用している方は,
	  飛ばしてください.</para>

	<para>最後に, FreeBSD 2.2-RELEASE を使われている場合は, Linux
	  のランタイムリンカと
	  その設定ファイルがシステムに導入されていることを
	  確認してください. これらのファイルは, FreeBSD
	  システムの適切な位置(<filename>/compat/linux</filename>
	  ツリー以 下)にコピーされている必要があります.</para>

	<screen>/compat/linux/lib/ld.so
/compat/linux/etc/ld.so.config</screen>

	<para>使用できる Linux システムがない場合は,
	  必要なファイルは近くの FTP サイ トから入手してください.
	  各種ファイルの入手先についての情報を, 後に付 けておきます.
	  ここでは, 必要なファイルの入手先がわかっているものとしま
	  す.</para>

	<para>以下のファイルを取得します
	  (バージョンの不一致を避けるために, すべて同一 の FTP
	  サイトから入手してください). 取得したファイルを
	  <filename>/compat/linux</filename>
	  以下にインストールしてください(例えば,
	  <filename>/foo/bar</filename> は,
	  <filename>/compat/linux/foo/bar</filename>
	  にインストールされます).</para>

	<screen>/sbin/ldconfig
/usr/bin/ldd
/lib/libc.so.x.y.z
/lib/ld.so</screen>

	<para><command>ldconfig</command> と <command>ldd</command>
	  は, <filename>/compat/linux</filename>
	  の下にある必要はありません. システム
	  のどこにあっても構いません. ただ, FreeBSD
	  の同名のコマンドと間違えないように 注意してください.
	  <filename>/usr/local/bin</filename> の中に,
	  <command>ldconfig-linux</command>,
	  <command>ldd-linux</command> とし
	  てインストールするのもよいアイディアでしょう.</para>

	<para><filename>/compat/linux/etc/ld.so.conf</filename>
	  ファイルを作成し, Linux ラインタイムリンカが
          シェアードライブラリを検索するディレクトリを記述してください.
          このファイルはプレインテキストファイルで,
	  それぞれの行にディレクトリ名を含みます.
	  <filename>/lib</filename> と <filename>/usr/lib</filename>
	  は標準ですから, 以下のようなディレクトリが追加できま
	  す.</para>

	<programlisting>
/usr/X11/lib
/usr/local/lib</programlisting>

	<para>Linux バイナリが, <filename>/lib/libc.so</filename>
	  というライブラリを開いた場合, Linux ABI サポートは内部で,
	  ファイル名を <filename>/compat/linux/lib/libc.so</filename>
	  にマップします. Linux ABI ローダがライブラリを検索できるよう,
	  すべての Linux のライブラリ
	  (<filename>/compat/linux/lib/libc.so</filename>,
	  <filename>/compat/linux/usr/X11/lib/libX11.so</filename>
	  など) は, /compat/linux
	  以下にインストールされていなければなりません.</para>

	<para>FreeBSD 2.2-RELEASE を使用している場合は, Linux の
	  <command>ldconfig</command> プログラム を実行する必要があります.</para>

	<screen>&prompt.root; <userinput>cd /compat/linux/lib</userinput>
&prompt.root; <userinput>/compat/linux/sbin/ldconfig</userinput></screen>

	<para><command>ldconfig</command>
	  はスタティックリンクされていますから,
	  実行するのにシェアードラ イブラリを必要としません. ldconfig
	  は, <filename>/compat/linux/etc/ld.so.cache</filename>
	  ファイルを作成し,
	  すべてのシェアードライブラリの名前を格納します. ライ
	  ブラリの追加をおこなった場合には, ldconfig を再実行して,
	  このファイルを作り 直さなければなりません.</para>

	<para>2.1-STABLE では,
	  <filename>/compat/linux/etc/ld.so.cache</filename>
	  をインストールしたり, <command>ldconfig</command>
	  を実行したりしないでください. 2.1-STABLE では, システムコー
	  ルの実装方法が異なるため, <command>ldconfig</command>
	  は使用されません.</para>

	<para>これで, libc シェアードライブラリを必要とする Linux
	  バイナリを実行する設 定が終了しました.
	  <command>ldd</command> を <command>ldd</command>
	  自身に実行してテストしてください.
	  <command>ldd-linux</command>
	  としてインストールしている場合は, 以下のような結果になるはず
	  です.</para>

	<screen>&prompt.root; <userinput>ldd-linux `which ldd-linux`</userinput>
libc.so.4 (DLL Jump 4.5pl26) =&gt; /lib/libc.so.4.6.29</screen>

	<para>ここまで終了すれば, 新しい Linux のバイナリを
	  インストールできます.
	  新しい Linux バイナリをインストールするときは,
	  それがシェアードライブ
	  ラリを必要とするかどうか確認してください. 必要とする場合は,
	  <filename>/compat/linux</filename> 以下に
	  インストールされているかどうか確認してください. こ
	  れは, Linux の <command>ldd</command> を新しいプログラムに
	  対して実行し, 出力を確認するこ
	  とによりおこなえます.
	  <command>ldd</command>
	  (&man.ldd.1; マニュアルページも参照してください)は, プ
	  ログラムが必要とするシェアードライブラリのリストを,
	  <literal><replaceable>majorname</replaceable>
	    (<replaceable>jumpversion</replaceable>) =&gt;
	    <replaceable>fullname</replaceable></literal>
	  という形式で出力します.</para>

	<para><replaceable>fullname</replaceable> のかわりに
	  <literal>not found</literal> と出力される場合は,
	  ライブラリの追加をす る必要があります.
	  必要なライブラリの名前は, majorname に <!-- kuriyama - Eng:
	  mm? --> <literal> lib<replaceable>XXXX</replaceable>
	    .so.<replaceable>N.mm</replaceable></literal>
	  という形式で示されています. Linux の FTP サイトで <filename>
	    lib<replaceable>XXXX</replaceable>.so.N.mm</filename>
	  を探し, インストールしてください. <replaceable>
	    XXXX</replaceable>(名前)と<replaceable>N</replaceable>
	  (メジャー リビジョン番号)は一致している必要があります.
	  マイナー番号 <replaceable>mm</replaceable> は, それほ
	  ど重要ではありませんが,
	  なるべく最新のものをインストールするようにして
	  ください.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Linux の ELF バイナリをインストールする</title>

      <para>ELF のバイナリを使うためには,
	&ldquo;マークをつける(branding)&rdquo;作業が必要になります.
	マークのない ELF バイナリを実行しようとすると,
	以下のようなエラーメッセージを
	うけとってしまうことでしょう.</para>

      <screen>&prompt.user; <userinput>./my-linux-elf-binary</userinput>
ELF binary type not known
Abort</screen>

      <para>カーネルが FreeBSD の ELF バイナリと Linux のバイナリとを
	見分けられるようにするためには, &man.brandelf.1;
	を以下のようにして使ってください:</para>

      <screen>&prompt.user; <userinput>brandelf -t Linux my-linux-elf-binary</userinput></screen>

      <para>今ではGNU のツールたちが,
	ELFバイナリに自動的に適切なマークを付加するようになったので,
	今後はこの作業もだんだんと必要なくなってゆくでしょう.</para>
    </sect2>

    <sect2>
      <title>ホストネームリゾルバの設定</title>

      <para>DNS がうまく動作しなかったり,
	以下のようなエラーメッセージが表示され
	る場合は, <filename>/compat/linux/etc/host.conf</filename>
	ファイルを設定する必要があります.

	<!-- kuriyama - Check English version of here -->
	<screen>resolv+: "bind" is an invalid keyword
resolv+: "hosts" is an invalid keyword</screen>

	ファイルの内容を以下のように設定してください.

	<programlisting>
order hosts, bind
multi on</programlisting>

	ここで, order は <filename>/etc/hosts</filename> を最初に検索し,
	次にDNSを検索するように指定
	します. <filename>/compat/linux/etc/host.conf</filename>
	がインストールされていない場合は,
	Linux のアプリケーションは, FreeBSD の
	<filename>/etc/host.conf</filename> を使用しようとして,
	文法の違いによる警告を表示します.
	<filename>/etc/resolv.conf</filename> を使用してネームサー
	バを設定していない場合には,
	<literal>bind</literal> を削除してください.</para>

      <para>最後になりますが, 2.1-STABLE を使用している場合は,
	<envar>RESOLV_HOST_CONF</envar> 環境変数を指定して,
	アプリケーションにホストテーブル
	の検索方法を指定する必要があります. FreeBSD 2.2-RELEASE
	かそれ以降を使用している場合 は, スキップしてください.
	<filename>/bin/csh</filename> を使っている場合は,
	以下のようにし ます.</para>

      <screen>&prompt.user; <userinput>setenv RESOLV_HOST_CONF /compat/linux/etc/host.conf</userinput></screen>

      <para><filename>/bin/sh</filename>の場合は,
	以下のようにします.</para>

      <screen>&prompt.user; <userinput>RESOLV_HOST_CONF=/compat/linux/etc/host.conf; export RESOLV_HOST_CONF</userinput></screen>
    </sect2>

    <sect2>
      <title>必要なファイルを探すには</title>

      <note>
	<para>以下の情報は, この文書が書かれた時点では有効ですが, FTP
	  サイトの 名前, ディレクトリ, 配布ファイル名などは,
	  変更されている可能性がありま す.</para>
      </note>

      <note>
	<para>訳注: ここに取り上げられている FTP サイトは,
	  日本国内にもミラーサイト が多数存在します. なるべく近くの
	  FTP サイトからファイルを入手してくだ さい.</para>
      </note>

      <para>Linux は, いくつかのグループが,
	それぞれ独自のバイナリ配布セットを作成 して配布しています.
	配布セットは, &ldquo;Slackware&rdquo; や
	&ldquo;Yggdrasil&rdquo; など の名前がつけられています.
	これらの配布セットは, 多くの FTP サイトから 入手できます.
	ファイルが展開されており, 必要なファイルのみを取得できる
	場合もありますが,
	通常は圧縮された配布セットの形で入手できます. 配布 セットは,
	いくつかのサブディレクトリに, gzip で圧縮された tar ファイル
	として格納されています. それぞれの配布セットの一次配布先は,
	以下の通り です.</para>

      <orderedlist>
	<listitem>
	  <para>sunsite.unc.edu:/pub/Linux/distributions</para>
	</listitem>

	<listitem>
	  <para>tsx-11.mit.edu:/pub/linux/distributions</para>
	</listitem>
      </orderedlist>

      <para>ヨーロッパのミラーサイトの例:</para>

      <orderedlist>
	<listitem>
	  <para>ftp.luth.se:/pub/linux/distributions</para>
	</listitem>

	<listitem>
	  <para>ftp.demon.co.uk:/pub/unix/linux</para>
	</listitem>

	<listitem>
	  <para>src.doc.ic.ac.uk:/packages/linux/distributions</para>
	</listitem>
      </orderedlist>

      <para>混乱を避けるために, ここでは Slackware だけを取り上げます.
	この配布セットは, 多くのサブディレクトリ内にある
	別々のパッケージから構成されていま す.  通常,
	パッケージはインストールプログラムにより自動的に制御されま
	すが, &ldquo;手動で&rdquo;おこなうことも可能です.
	まず配布セットの中の, <filename>contents</filename>
	サブディレクトリの内容を書くにしてください. ここには多く
	の小さなテキストファイルが含まれおり,
	それぞれのパッケージの内容が記述されています.
	必要なファイルを探している場合は, まず contents
        サブディレクトリ内のテキストファイルを取得し,
        そのファイルの中から <command>grep</command>
	を使用して検索するのが,  最も速い方法でしょう.
	以下に必要となるであろうファイルを, <command>grep</command> を使用
	して検索した例を示します.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Library</entry>
	      <entry>Package</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row><entry><filename>ld.so</filename></entry><entry>ldso </entry></row>
	    <row><entry><filename>ldconfig</filename></entry><entry>ldso </entry></row>
	    <row><entry><filename>ldd</filename></entry><entry>ldso </entry></row>
	    <row><entry><filename>libc.so.4</filename></entry><entry>shlibs </entry></row>
	    <row><entry><filename>libX11.so.6.0</filename></entry><entry>xf_lib </entry></row>
	    <row><entry><filename>libXt.so.6.0</filename></entry><entry>xf_lib </entry></row>
	    <row><entry><filename>libX11.so.3</filename></entry><entry>oldlibs </entry></row>
	    <row><entry><filename>libXt.so.3</filename></entry><entry>oldlibs </entry></row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>この場合は, ldso, shlibs, xf_lib, oldlibs
	というパッケージが必要なこと がわかります.
	それぞれのcontentsファイルの中で, <literal>PACKAGE
	  LOCATION</literal>  と書いてある行を探してください.
	その行に, パッケージが含まれている&ldquo;ディスク&rdquo;,
	今回の場合はサブディレクトリ名が書かれています. たとえば,
	以下の ようになります.</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead
	    <row>
	      <entry>Package</entry>
	      <entry>Location</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row><entry>ldso </entry><entry>diska2 </entry></row>
	    <row><entry>shlibs </entry><entry>diska2 </entry></row>
	    <row><entry>oldlibs </entry><entry>diskx6 </entry></row>
	    <row><entry>xf_lib </entry><entry>diskx9 </entry></row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>&ldquo;disk<replaceable>XX</replaceable>&rdquo;
	というのは, 配布セットの
	<filename>slackware/<replaceable>XX</replaceable></filename>
	サブディレクトリ を示します. それ以外の場合は,
	<filename>contrib</filename> サブディレクトリに格納されて
	います. 今回の場合は,
	以下のファイルを取得すればいいことがわかります (ファイル名は,
	配布セットのルートディレクトリからの相対パスで示してあ
	ります).</para>

      <itemizedlist>
	<listitem>
	  <para><filename>slakware/a2/ldso.tgz</filename></para>
	</listitem>

	<listitem>
	  <para><filename>slakware/a2/shlibs.tgz</filename></para>
	</listitem>

	<listitem>
	  <para><filename>slakware/x6/oldlibs.tgz</filename></para>
	</listitem>

	<listitem>
	  <para><filename>slakware/x9/xf_lib.tgz</filename></para>
	</listitem>
      </itemizedlist>

      <para>gzip で圧縮された tar ファイルから必要なファイルを
	<filename>/compat/linux</filename> ディ
	レクトリに格納してください(必要なファイルのみを展開するか,
	あるいは必要でないファイルを後で削除してください).
	これで作業は終了です.</para>

      <para><emphasis>参照:</emphasis>
	<filename>
	  ftp://ftp.freebsd.org:pub/FreeBSD/2.0.5-RELEASE/xperimnt/linux-emu/README
	</filename> と <filename>
	  /usr/src/sys/i386/ibcs2/README.iBCS2</filename></para>
    </sect2>
  </sect1>

  <sect1 id="mathematica">
    <title>Mathematica</title>

    <para><emphasis>寄稿: &a.rich;, &a.chuck;.</emphasis></para>
    <para><emphasis>改訂: Bojan Bistrovic <email>bojanb@physics.odu.edu</email>.</emphasis></para>
    <para><emphasis>訳: &a.jp.kiroh;.</emphasis></para>

    <para>この章では, Mathematica 2.2 の Linux
      バイナリ配布をインストールする方法について説明します.</para>

    <para>Mathematica は, そのままでは FreeBSD
      をサポートしていません. しかし, Linux は サポートしていますので,
      Linux エミュレータの設定が終わってしまえば, Mathematica
      を動作させる環境はほとんど整ったことになります.</para>

    <sect2>
      <title>Mathematica のインストール</title>

      <para>Mathematica は CDROM で配布されています.
        学生版(student edition)には, Mac, Windows95/NT, Linux 版があり,
        プロフェッショナル版(professional edition)には, それらに加えて
        Digital Unix, Solaris, IRIX, HPUX, AIX, NeXT 版があります.
        CDROM が <filename>/cdrom</filename> にマウントされている場合,
        インストーラは
        <filename>/cdrom/Unix/Installers</filename> に置かれています.
      </para>

      <note>
	<para>学生版にはすべての Unix 版のインストーラが含まれていますが,
        バイナリは Linux 用のものしか含まれていません.</para>
      </note>

      <para>Linux 版インストーラのディレクトリは二つあります.
        それは <filename>Linux</filename> (ELF 版) と
        <filename>Linux-aout</filename> (a.out 版)です.
        どちらのインストーラでも動作します(実のところ, どの Unix
        版インストーラでも動きます)が, インストールされるものが異なりますので,
        まずどの版をインストールするか決めなければなりません.
        a.out 版はそのままでも動きますが, ELF
        版の場合は, すべてのバイナリにマーク付け(branding)をする必要があります(詳細は
        &man.brandelf.1; を参照して下さい).
        もちろん, ELF 版インストーラを起動する場合には,
        そのインストーラ自身にもマーク付けしなければなりませんので,
        マークを書き込むためにインストーラをハードディスクにコピーする必要があります.
      </para>

      <para>
        インストール手順は, どの版をインストールする場合でも同様です.
        この文書では, a.out 版のインストール例を示します.
      </para>
      
      <para>インストールを開始するには, 次のように実行して下さい.</para>
      
      <screen>&prompt.root; <userinput>cd /cdrom/Unix/Installers/Linux-aout</userinput>
&prompt.root; <userinput>./MathInstaller</userinput></screen>

      <para>
        Mathematica 3.0
        ソースツリー(デフォルトは
        <filename>/usr/local/mathematica</filename>)と,
        スタートアップスクリプト(デフォルトは
        <filename>/usr/local/bin</filename>)のインストール先を選択します.
        このとき, パスワードのインストールを求められるかも知れません.
        そこでパスワードのインストールを選択した場合,
        MathInstaller はあなたの <quote>MathID</quote> を表示し,
        Mathematica の実行に必要なパスワードとライセンス ID を求めます.
      </para>

      <para>
        これらは Mathematica の最初の起動時にも再度聞かれますので,
        この段階でのパスワードのインストールは省略可能です.
        Mathematica が求める質問には, すべてヘルプメッセージがあります.
        パスワードの入手には <quote>MathID</quote> が必要になりますが,
        もし書き留めていなければ次のようにして表示させることができます.
      </para>
      
      <screen>&prompt.root; <userinput>./MathInstaller -info</userinput></screen>

      <para>あるいは次のようにします.</para>

      <screen>&prompt.root; <userinput>cd /cdrom/Unix/Files/SystemFiles/Installation/Binaries/Linux-aout</userinput>
&prompt.root; <userinput>./mathinfo</userinput></screen>


      <para>出力は,
	<literal><replaceable>ホスト名</replaceable>
	  <replaceable>####</replaceable>-<replaceable>#####</replaceable>-<replaceable>#####</replaceable></literal> のようになります.	
	<literal><replaceable>####</replaceable>-<replaceable>#####</replaceable>-<replaceable>#####</replaceable></literal> の部分が, あなたの <quote>MathID</quote> です.
        これを用いて,
        <ulink url="http://www.wolfram.com/register">http://www.wolfram.com/register</ulink>
        (サイトライセンスの場合は
        <ulink url="http://www.wolfram.com/site">http:/www.wolfram.com/site</ulink>)
        からライセンスを取得することができます.
	また, CDROM ケースにあるシールに書かれている <quote>$LicenceID</quote> も必要です.
        これは,
	<literal>L<replaceable>####</replaceable>-<replaceable>####</replaceable></literal>
        のようになっています.
        <literal><replaceable>#</replaceable></literal> は 0 から 9 までの数字です.
        サイトライセンスを持っている場合は, ライセンスの種類として
        <literal>Unix</literal> ではなく, <literal>Single User
        (Mac/Windows)</literal>(表示はおかしいですが)を選択する必要があります.
        パスワードは電子メールで送られてきます.
        もし, すでに Mathematica をライセンスなしでインストールしているなら,
        次のようにタイプすることでここで取得したライセンスをインストールできます.
      </para>

      <screen>&prompt.root; <userinput>./MathInstaller -pass</userinput></screen>

      <para>Wolfram Research からのメールは, (ヘッダを削除してから)
        <filename>/usr/local/mathematica/Configuration/Licensing/mathpass</filename>
        にコピーしておいてください. そうしていない場合には, Mathematica
        を起動(端末からは <command>math</command> コマンド,
	X のフロントエンドは <command>mathematica</command>
        コマンド)した時にパスワードが求められ,
        入力されたパスワードはパスワードファイルに記録されます.
      </para>
  </sect2>

  <sect2>
      <title>Linux ファイルシステムからの Mathematica の起動</title>

      <para>If you have multi-OS box, and you already installed Mathematica
	under Linux, you may want to run it directly from that partition. Here
	we assume that you already compiled your kernel with
	<literal>EXT2FS</literal> option and mounted your Linux partition at
	<filename>/linux</filename>.</para>
      <para>
        あなたのマシンに異なる複数の OS が入っていて,
        Linux 上ですでに Mathematica がインストールされているような場合には,
        そのインストールされたパーティションから直接起動したいと考えるかも知れません.
        以下では, オプション <literal>EXT2FS</literal> が設定された
        カーネルを構築済みで, Linux パーティションが
        <filename>/linux</filename> であるとします.
      </para>

      <procedure>
	<step>
	  <para>まず最初に, スタートアップスクリプトをコピーします.</para>

	  <screen>&prompt.root; <userinput>cp /linux/usr/local/bin/math* /usr/local/bin</userinput></screen>
	</step>

	<step>
	  <para>次に, <filename>math</filename>,
	    <filename>mathematica</filename>,
	    <filename>Mathematica</filename> および
	    <filename>MathKernel</filename>
            というスクリプトファイルを編集します.</para>

	  <para>行に <literal>topdir=/usr/local/mathematica</literal>
            が含まれていたら,
	    <literal>topdir=/linux/usr/local/mathematica</literal>
            のように置き換えて下さい.
	  </para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>ネットワーク経由での Mathematica フロントエンドの起動</title>

      <para>
        Mathematica は標準フォントにない特別な記号(積分記号, 総和記号,
        ギリシャ文字など)を表示するために, 特殊なフォントを使用します.
        X プロトコルは,
        これらのフォントが<emphasis>ローカルマシンに</emphasis>インストールされていることを要求します.
        これはつまり, ローカルマシンに(CD や Mathematica
        のインストールされているホストマシンから)そのフォントをコピーしなければならないということです.
        これらのフォントは通常, ハードディスクの
	<filename>/usr/local/mathematica/SystemFiles/Fonts</filename> か,
        CDROM の <filename>/cdrom/Unix/Files/SystemFiles/Fonts</filename> に置かれていて,
        実際に使用されるフォントは <filename>Type1</filename> と
        <filename>X</filename> のサブディレクトリに格納されています.
        これを利用するには, 次のような二つ方法があります.
        一つは, フォントファイルをすべて
        <filename>/usr/X11R6/lib/X11/fonts/</filename>
        以下にある既存のフォントディレクトリにコピーする方法です.
        この場合, <filename>fonts.dir</filename> にフォント名を追加し,
        先頭行のフォント総数を変更することも必要になります.
        もう一つの方法は, 次のように
        <filename>/usr/X11R6/lib/X11/fonts/</filename>
        にフォントディレクトリごとコピーする方法です(おそらくこちらの方が望ましいでしょう).
      </para>

      <screen>&prompt.root; <userinput>cd /usr/X11R6/lib/X11/fonts/</userinput>
&prompt.root; <userinput>mkdir X</userinput>
&prompt.root; <userinput>mkdir MathType1</userinput>
&prompt.root; <userinput>cd /usr/local/mathematica/SystemFiles/Fonts/</userinput>
&prompt.root; <userinput>cp X/* /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>cp Type1/* /usr/X11R6/lib/X11/fonts/MathType1</userinput></screen>

      <para>そして, フォントパスを追加します.</para>

      <screen>&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/MathType1</userinput>
&prompt.root; <userinput>xset fp rehash</userinput></screen>

      <para>XFree86 サーバを使用しているなら,
        <filename>/etc/XF86Config</filename> を変更することで,
        これらのフォントを自動的に読み込むことができます.</para>

      <para>
        <filename>/usr/X11R6/lib/X11/fonts/Type1</filename> という
        ディレクトリが<emphasis>存在していない</emphasis>場合には,
        上記例の <filename>MathType1</filename> を
        <filename>Type1</filename>
        とすることができます(これに限らず, どんな名前でもかまいません).
        こうすることで, ネットワーク経由で Mathematica
        フロントエンドを利用することが可能になります.
        これはあらゆる種類の X サーバに適用できる一般的な方法です.
        もし, (大部分の FreeBSD/Linux ユーザのように) XFree86 を利用しているなら,
        単に次の行を追加した方が簡単でしょう.
      </para>

      <programlisting>FontPath   "/usr/X11R6/lib/X11/fonts/MathType1"</programlisting>

   </sect2>
  </sect1>

  <sect1>
     <title>Linux モードはどのような原理で動作しているのですか?</title>

    <para>このセクションは, ほとんどが <email>freebsd-chat@FreeBSD.org</email>
      メーリングリストに投稿された
      Terry Lambert<email>tlambert@primenet.com</email> 氏のメール(Message ID:
      <literal>&lt;199906020108.SAA07001@usr09.primenet.com&gt;</literal>)
     に基づいています.
    </para>

    <para>FreeBSD は, &ldquo;実行クラスローダ(execution class loader)&rdquo;
      と呼ばれる抽象的な機構を持っています. これは &man.execve.2
      システムコールに追加される形で実装されています.
    </para>

    <para>FreeBSD は, シェルインタプリタやシェルスクリプトを実行するための
      <literal>#!</literal> ローダを持った単一のプログラムローダではなく,
      プログラムローダのリストを備えています.
    </para>

    <para>歴史的に言って, UNIX プラットフォームでマジックナンバ(一般的にファイル先頭の
      4 ないし 8 バイト部分)の検査を行なうのはプログラムローダだけです.
      プログラムローダは, それがシステムで実行できるバイナリなのか確認して,
      それが確認できればバイナリローダを呼び出します. 
    </para>

    <para>もし, それがそのシステム用のバイナリでない場合には,
      &man.execve.2; システムコールの呼び出しは失敗の戻り値を返し,
      シェルがシェルコマンドとして実行しようと試みるわけです.
    </para>

    <para>この仮定は, &ldquo;現在利用しているシェルがどのようなものであっても&rdquo;変わりません.
        </para>
    
    <para>後になって, &man.sh.1; に変更が加えられました.
        それは先頭の 2 バイトを検査し, <literal>:\n</literal> だったら
        シェルとして代わりに &man.csh.1; を呼び出す, というものです(この変更は
        SCO が最初に行なったと思われます).
    </para>

    <para>現在の FreeBSD は, プログラムローダリストを走査します.
      その際, 空白文字までの文字列をインタプリタとして認識する,
      通常の <literal>#!</literal> ローダを用いるため,
      該当するものが存在しなければ最終的に /bin/sh がロードされます.
    </para>

    <para>
      Linux ABI をサポートするため, FreeBSD は
      ELF バイナリを示すマジックナンバを確認します.
      (ただし, この段階で FreeBSD, Solaris, Linux, そしてその他にも存在する
       ELF イメージ形式を使っている OS を区別することはできません).
    </para>

    <para>ELF ローダは, 特殊な<emphasis>マーク(brand)</emphasis>があるかどうか探します.
        このマークとは, ELF イメージのコメントセクションのことです.
        SVR4/Solaris の ELF バイナリには, このセクションは存在しません.
    </para>

    <para>
      Linux バイナリを実行するためには,
      ELF バイナリに &man.brandelf.1; で説明されている
      <literal>Linux</literal> のマークが
      <emphasis>付けられて</emphasis>いなければなりません.
     </para>
                       
    <screen>&prompt.root; <userinput>brandelf -t Linux file</userinput></screen>

    <para>上のようにすることで, 指定されたファイルは
        <literal>Linux</literal> のマークが付けられ,
        ELF ローダが認識できるようになります.
    </para>

    <para>
      ELF ローダが <literal>Linux</literal> マークを確認すると,
      ローダは <literal>proc</literal> 構造体内の
      ある一つのポインタを置き換えます. システムコールは全て,
      この置き換えられたポインタ(伝統的な UNIX システムでは,
      システムコールが <literal>sysent[]</literal>
      構造体の配列として実装されています)を基準に呼び出されます.
      またそのプロセスには, Linux カーネルモジュールに必要な
      シグナルトランポリンコード(訳注:
      シグナルの伝播を実現するコード)用の特殊なトラップベクタの設定や,
      他の(細かな)調整のための設定が行なわれます.
    </para>

    <para>
      Linux システムコールベクタは, さまざまなデータに加えて
      カーネルモジュール内のアドレスを指す <literal>sysent[]</literal>
      エントリのリストを含んでいます.
    </para>

    <para>
      Linux バイナリがシステムコールを発行する際, トラップコードは
      <literal>proc</literal> 構造体を用いてシステムコール関数ポインタを 
      解釈します. そして, FreeBSD ではなく Linux 用の
      システムコールエントリポイントを得るわけです.
     </para>

    <para>
      さらに Linux モードは, 状況に応じて
      <emphasis>ファイルシステム本来のルートマウントポイントを置き換えて</emphasis>
      ファイルの参照を行ないます.
      これは, <literal>union</literal> オプションを指定して
      マウントされたファイルシステム(unionfs では<emphasis>ありません!</emphasis>)が
      行なっていることと同じです.
      ファイルを検索する際にはまず
      <filename>/compat/linux/<replaceable>original-path</replaceable></filename>
      ディレクトリを, <emphasis>それから</emphasis>見つけられなかったときにのみ, 
      <filename>/<replaceable>original-path</replaceable></filename>
      を調べます.
      こうすることで, 他のバイナリを要求するバイナリの実行を可能にしています
      (したがって, Linux 用プログラムツールは Linux ABI サポート環境下で完全に動作するわけです).
      またこれは, もし対応する Linux バイナリが存在しない場合に
      Linux バイナリが FreeBSD バイナリをロードしたり, 実行したりすることが可能であること, 
      その Linux バイナリに自分自身が Linux 上で実行されていないことを
      気付かせないようにする目的で, &man.uname.1; コマンドを
      <filename>/compat/linux</filename> ディレクトリに
      置くことができる, ということを意味します.
    </para>

    <para>
      要するに, Linux カーネルが FreeBSD カーネルの内部に存在しているわけです.
      カーネルによって提供されるサービス全ての実装の基礎となるさまざまな関数は,
      FreeBSD システムコールテーブルエントリと
      Linux システムコールテーブルエントリの
      両方で共通に利用されています.
      これらにはファイルシステム処理, 仮想メモリ処理, シグナル伝送, System V IPC
      などが含まれますが, 
      FreeBSD バイナリは, FreeBSD <emphasis>グルー</emphasis>(訳注: glue;
      二者の間を仲介するという意味)関数群,
      そして Linux バイナリは Linux <emphasis>グルー</emphasis>関数群を用いる,
      という点だけが異なります(過去に存在したほとんどの OS は,
       自分自身のための<emphasis>グルー</emphasis>関数群しか備えていません.
       前述したように, システムコールを発行する際,
       各々のプロセスの <literal>proc</literal> 構造体内にある,
       ローダによって動的に初期化されるポインタを参照してアドレスを得る代わりに,
       静的でグローバルな <literal>sysent[]</literal> 構造体の配列に
       システムコール関数のアドレスが直接格納されているのです).
      </para>

    <para>
      さて, どちらを本来の FreeBSD ABI(訳注: Applications Binary Interface;
      同じ CPU を利用したコンピュータ間でバイナリを共有するための規約のこと)
      と呼ぶべきなのでしょうか?
      実は, どちらが本来のものであるかということを論ずることに意味はありません.
      基本的に, FreeBSD <emphasis>グルー</emphasis>関数群はカーネルの中に静的にリンクされていて,
      Linux <emphasis>グルー</emphasis>関数群は静的にリンクすることも,
      カーネルモジュールを介して利用することもできるようになっている,
      という違いがあるだけ(ただしこれは現時点においての話です.
      これは将来のリリースで変更される可能性がありますし,
      おそらく実際に変更されるでしょう)です.
    </para>
                       
    <para>
      あ, 「でもこれは本当にエミュレーションと呼べるのか」って?
      答えは「いいえ」です. これは一つの ABI 実装にすぎず,
      エミュレーションとは異なります. エミュレータ(シミュレータでもないことを
      あらかじめ断っておきましょう)が呼び出されているわけではありません.
    </para>

    <para>
     では, これが良く &ldquo;Linux エミュレーション&rdquo; と呼ばれるのは何故でしょうか?
     それはもちろん FreeBSD の売りにするため <!-- smiley -->8-) でもあるのですが,
     実際には, 次のような理由によります.
     この機能が初めて実装された頃, 動作原理を説明する以外に
     この機能を表現する言葉はありませんでした.
     しかし, コードをコンパイルしたりモジュールをロードしない場合,
     「FreeBSD 上で Linux バイナリを実行する」言う表現は,
     厳密に考えると適切ではありません.
     そこで, その際にロードされているもの自身を表現する言葉&mdash;すなわち
     &ldquo;Linux エミュレータ&rdquo;が必要だったのです.
    </para>

   </sect1>
 </chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
