<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.34
     $FreeBSD$
-->

<chapter id="serialcomms">
  <title>シリアル通信</title>

  <sect1>
    <title>この章では</title>

    <indexterm><primary>シリアル通信</primary></indexterm>
    <para>
      Unix は現在に至るまで、常にシリアル通信機能をサポートしていました。
      実際、本当に初期の Unix マシンは、ユーザとの入出力にシリアル通信を使っていました。
      10 文字毎秒のシリアルプリンタ、
      キーボードから構成された <quote>端末(terminal)</quote> が広く使われていた当時とは、
      何もかもがすっかり変わっています。この章では、FreeBSD
      でシリアル通信を行なういくつかの方法について説明しています。
    </para>
  </sect1>

  <sect1 id="serial">
    <title>シリアル接続の基礎</title>

    <para><emphasis>Assembled from FAQ.</emphasis></para>

    <para>このセクションには、
      シリアルポートについての一般的な情報が書かれていま す。
      あなたが求めている情報が、もしここで見つからなかった場合には、
      ハン ドブックの端末とダイアルアップのセクションを見てください。
    </para>

    <indexterm><primary>ttyd</primary></indexterm>
    <indexterm><primary>cuaa</primary></indexterm>
    <para><filename>ttyd<replaceable>X</replaceable></filename>
      (または <filename>cuaa<replaceable>X</replaceable></filename>)
      デバイスは、アプリケーション上
      でシリアルポートをオープンする時に使用する、
      標準的なデバイスです。プロセスがデバイスをオープンする際、端末
      I/O 設定の デフォルトセットが使用されます。これらの設定内容は、
      次のコマンドで確認することができます。</para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput></screen>

    <para>このデバイスの設定を変更した場合、その設定はデバイスが
      クローズされるまで有効です。デバイスが再びオープンされる時、
      デフォルトの設定値に戻ります。
      デフォルトの設定を変更するためには、
      <quote>初期状態</quote> を設定した
      いデバイスをオープンして調節することができます。例えば、ttyd5
      というデバイスに対して、デフォルトで <acronym>CLOCAL</acronym>
      モードを ON にして、8 bits の設定をおこない、
      <emphasis>XON/XOFF</emphasis>
      フロー制御を行うように設定したい場合は、次のようにします。
    </para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</userinput></screen>

    <indexterm>
      <primary>rc ファイル</primary>
      <secondary><filename>rc.serial</filename></secondary>
    </indexterm>
    <para>このコマンドを記述するのに適しているファイルは、
      <filename>/etc/rc.serial</filename>   です。
      アプリケーションが<filename>ttyd5</filename>
      をオープンするときに、
      デフォルトでこの設定をおこなうようになります。これらの設定は、
      好きなように変更することができます。</para>

    <para>また、<quote>固定状態</quote> のデバイスに調節を行うことで、
      ある一定の設定が
      アプリケーションに変更されることを防ぐこともできます。例えば、
      <filename>ttyd5</filename> のスピードを 57600 bps
      に固定したい場合には、次のようにします。</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

	<para>これで、<filename>ttyd5</filename> をオープンして、
      シリアルポートの転送スピードを
      変更しようとするアプリケーションは 57600 bps
      に固定されるでしょう。</para>

    <indexterm>
      <primary><command>MAKEDEV</command></primary>
    </indexterm>
    <para>本来、デバイスの初期状態を変更したり設定を固定するのは、
      <username>root</username> だけが行うべきです。
      <filename>MAKEDEV</filename>
      スクリプトがデバイスエントリを作成する時は、
      これをおこない<emphasis>ません</emphasis>。</para>
  </sect1>

  <sect1 id="term">
    <title>シリアル端末</title>

    <indexterm><primary>端末</primary></indexterm>
    <para><emphasis>原作:  Sean Kelly <email>kelly@ad1440.net</email><!-- <br> -->
	28 July 1996</emphasis></para>

    <para><emphasis>訳: &a.max;</emphasis></para>

    <para>シリアル端末を利用することで、
      コンピュータのコンソールのそばにいないと きや、
      手近にネットワーク接続されているコンピュータがないときでも、
      FreeBSD の機能を便利に、かつ安価に利用することができます。
      ここでは、FreeBSD
      にシリアル端末を接続する方法を解説します。</para>

    <sect2 id="term-uses">
      <title>端末の種類と利用方法</title>

      <para>もともと Unix システムにはコンソールがありませんでした。
	ユー ザはコンピュータのシリアル
	ポートに接続された端末からログインして
	プログラムを利用していました。
	ちょうどモデムと通信ソフトを使ってリモート
	のコンピュータにログインし、テキスト
	ベースのプログラムを利用するのと よく似ています。</para>

      <para>最近の PC は、
	高品質の画像を表示できるコンソールを搭載していま すが、
	ほとんどすべての Unix 系 OS には未だにシリアル
	ポートを使ってログ インするための機能があり、FreeBSD
	でもこの機能がサポートされています。
	現在使用されていないシリアル
	ポートに端末を接続することでシステムに ログインし、
	通常はコンソールや Xウィンドウ システムの
	<command>xterm</command> のウィ ンドウ上で起動しているテキスト
	ベースのプログラムであれば何
	でも利用することができます。</para>

      <para>職場での利用ということで考えるならば、FreeBSD
	が動作しているコンピュー タに接続された何台ものシリアル端末を
	各社員の机に配置するというようなこ とが可能です。また、
	家庭での利用方法としては、余っている古い IBM PC や  Macintosh
	を FreeBSD が動いているパワフルなコンピュータの端末として利
	用することができます。普通ならシングルユーザのコンピュータを、
	パワフ
	ルなマルチユーザのシステムに変えることができるのです。</para>

      <para>FreeBSD では、以下に挙げる3種類の端末が利用できます。</para>

      <itemizedlist>
	<listitem>
	  <para><link linkend="term-dumb">ダム (dumb) 端末</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-pcs">PCを利用した端末</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-x">X 端末</link></para>
	</listitem>
      </itemizedlist>

      <para>以下は、それぞれについての解説です。</para>

      <sect3 id="term-dumb">
	<title>ダム端末</title>

	<para>ダム端末は、シリアルライン経由でのコンピュータとの接続専
	  用のハードウェアです。ダム端末は、
	  テキストの送受信および表示ができる
	  程度の計算能力しかもっていないので、<quote>dumb</quote>
	  (間抜け) というように呼ば れています。
	  この端末上でプログラムを実行することはできません。テキスト
	  エディタ、コンパイラ、E-mail、
	  ゲームなどなどのプログラムを実行するのは、
	  ダム端末を接続しているコンピュータの方です。</para>

	<para>Digital Equipment社の VT-100 や、Wyse社の WY-75
	  を初めとして、多くのメーカが何百種類もの
	  ダム端末を作っています。ほとんどどんな種 類のダム端末でも
	  FreeBSD に接続して使用できます。さらに、高性能の端
	  末の中には画像を取り扱えるものもありますが、
	  限られた数のソフトウェア
	  パッケージしかこういった機能には対応していません。</para>

	<para>ダム端末は、X ウィンドウ システムで提供されるようなグラ
	  フィックアプリケーションを必要としない
	  職場で広く用いられています。</para>
      </sect3>

      <sect3 id="term-pcs">
	<title>PC を端末として利用する</title>

	<para><link linkend="term-dumb">ダム端末</link>
	  がテキストの表示およ
	  び送受信の機能をそなえただけのものならば、言うまでもなく、
	  どんなPC もダム端末になり得ます。
	  必要なものは適切なケーブルと、そのPCの上
	  で動作する<emphasis>端末エミュレーション</emphasis>
	  を行うソフトウェアのみです。</para>

	<para>このような環境は、家庭においてよく利用されます。
	  たとえば、あなたの同居 人が FreeBSD
	  のコンソールを専有している時などに、あまりパワーのないコ
	  ンピュータを FreeBSD システムにシリアル端末として接続し、
	  その端末上で
	  テキストだけを用いる作業をおこなうことができます。</para>
      </sect3>

      <sect3 id="term-x">
	<title>X 端末</title>

	<para>X 端末は、既存のものの中で最も洗練された種類の端末といえ
	  ます。X 端末は、たいていの場合シリアル ポートではなく、
	  イーサネッ
	  トのようなネットワークを利用した接続をおこないます。また、
	  アプリケーション の利用においても、
	  テキストベースのものだけでなく、X アプリケーション
	  の利用が可能です。</para>

	<para>ここでは、参考までに  端末について紹介しただけで、X 端
	  末の設定や利用についての解説は
	  <emphasis>おこないません</emphasis>。</para>
      </sect3>
    </sect2>

    <sect2 id="term-cables-ports">
      <title>ケーブルとポート</title>

      <para>シリアル端末を FreeBSD システムに接続するためには、
	適切なケー ブルと、
	端末を接続するためのシリアルポートが必要です。ここでは、これ
	らについて説明します。もし既にあなたの利用したい端末と、
	その端末 を接続するためのケーブルについてよく理解していれば、
	<link linkend="term-config">設定</link>
	の章まで読み飛ばしてください。</para>

      <sect3 id="term-cables">
	<title>ケーブル</title>

	<para>端末の接続は、シリアルポートを利用します。そこで、端末を
	  FreeBSD システムに接続するためには、シリアルケーブル
	  (RS-232C ケーブ ルとも呼ばれています)
	  が必要となります。</para>

	<para>シリアルケーブルには2種類のケーブルがあります。
	  どちらの種類の ケーブルを使わなければいけないかは、
	  どんな端末を接続したいかによります。</para>

	<itemizedlist>
	  <listitem>
      <indexterm><primary>ヌルモデムケーブル</primary></indexterm>
	    <para>もし、PC を端末として利用したい場合は、<link
		linkend="term-null">ヌルモデム</link> ケーブル
	      (リバースケーブルもしくは
	      クロスケーブルと呼ばれることもしばしばあります)
	      を使用してください。ヌルモデムケーブルは、
	      コンピュータ同士や端末同士を接続するために用い
	      られるケーブルです。</para>
	  </listitem>

	  <listitem>
	    <para>もし、本物の端末を接続するのであれば、その端末につい
	      てきたドキュメントからどのようなケーブルを
	      使うべきか調べてください。も しドキュメントがない場合は、
	      まず <link linkend="term-null">ヌルモデム</link>
	      ケーブルを試してみて、うまくいかない場合は <link
		linkend="term-std">スタンダード</link> ケーブル
	      (しばしばストレートケーブルと呼 ばれます)
	      を試してみてください。</para>
	  </listitem>
	</itemizedlist>

	<para>また、端末側と FreeBSD 側の <emphasis>両方の</emphasis>
	  シリアルポート の形状が、
	  あなたが使用しようとしているケーブルについているコネクタの形
	  状と一致していなければなりません。</para>

	<sect4 id="term-null">
	  <title>ヌルモデムケーブル</title>

	  <para>ヌルモデムケーブル (またはリバースケーブルあるいはクロ
	    スケーブル) は、たとえば <quote>signal ground</quote>
	    信号のように、いくつかの信 号はそのまま通しますが、
	    他の信号は途中で入れ替えて通します。たとえば、<quote>send
	    data</quote> 信号のピンは、反対側のコネクタの
	    <quote>receive data</quote> 信号の
	    ピンと繋がっています。</para>

	  <para>自分で使うケーブルは自分で作りたいということであれば、
	    以下にター ミナルを接続する際に推奨される
	    ヌルモデムケーブルの結線を示しておきま す。この表では、
	    RS-232C の信号線の名前と、DB-25 コネクタ上のピンの番
	    号を示しています。</para>

	  <informaltable frame="none">
	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry>Signal</entry>
		  <entry>Pin #</entry>
		  <entry></entry>
		  <entry>Pin #</entry>
		  <entry>Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>TxD</entry>
		  <entry>2</entry>
		  <entry>connects to</entry>
		  <entry>3</entry>
		  <entry>RxD</entry>
		</row>

		<row>
		  <entry>RxD</entry>
		  <entry>3</entry>
		  <entry>connects to</entry>
		  <entry>2</entry>
		  <entry>TxD</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>connects to</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>connects to</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>connects to</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry>connects to</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry></entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>connects to</entry>
		  <entry>8</entry>
		  <entry>DCD</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <note>
	    <para>DCD と RST では、コネクタ内部でピン4を5に接続し、
	      そして逆側のコネクタのピン8と接続します。</para>
	  </note>
	</sect4>

	<sect4 id="term-std">
	  <title>スタンダード RS-232C ケーブル</title>
    <indexterm><primary>RS-232C ケーブル</primary></indexterm>

	  <para>スタンダードシリアルケーブル
	    (またはストレートケーブル)  の場合は、すべての RS-232C
	    信号をそのまま通します。つまり、片方の <quote>send
	    data</quote> 信号のピンは、逆側の <quote>send data</quote>
	    信号のピンと繋がっています。モデムを FreeBSD
	    に接続するときや、一部の端末を接続するときにこのタイプの
	    ケーブルを使用します。</para>
	</sect4>
      </sect3>

      <sect3 id="term-ports">
	<title>ポート</title>

	<para>シリアルポートは、FreeBSDが動作しているホスト
	  コンピュータと端
	  末の間でデータのやりとりを行うために用いるデバイスです。
	  ここでは、現在存在するポートの種類と FreeBSD
	  でのポートのアクセス方法について解 説します。</para>

	<sect4 id="term-portkinds">
	  <title>ポートの種類</title>

	  <para>シリアルポートには何種類かのものがあります。
	    ケーブルを購 入したり自作したりする前に、
	    そのケーブルのコネクタの形状が端末および FreeBSD
	    システムのポートの形状と一致していることを
	    確認してください。</para>

	  <para>ほとんどの端末は DB25 ポートを搭載しています。
	    FreeBSDが動作しているも のを含めて、PCは DB25 または DB9
	    ポートを搭載しています。マルチポート
	    のシリアルカードの場合は、RJ-12 や RJ-45
	    のポートを搭載しているかもし れません。</para>

	  <para>利用されているポートの種類に関しては、
	    ハードウェアについてきたドキュメ ントを参照してください。
	    また、多くの場合、ポートの形状から判断すること
	    もできるでしょう。</para>
	</sect4>

	<sect4 id="term-portnames">
	  <title>ポートの名前</title>

	  <para>FreeBSDでは、<filename>/dev</filename>
	    ディレクトリ内のエントリを介
	    してシリアルポートへのアクセスがおこなわれます。
	    2種類の異なったエン トリがあります。</para>

	  <itemizedlist>
	    <listitem>
	      <para>着信用のポートの名前は、<filename>
		  /dev/ttyd<replaceable>x</replaceable></filename> (
		<replaceable>x</replaceable> は 0から始まるポート番号)
		となっています。一般に端末の接続には
		着信用ポートを用います。着信用のポートでは、
		シリアルラインのデータ キャリア検出 (DCD)
		信号がオンになっている必要があります。</para>
	    </listitem>

	    <listitem>
	      <para>発信用のポートの名前は、<filename>
		  /dev/cuaa<replaceable>x</replaceable></filename>
		となっています。
		発信用のポートは普通モデムの接続に用い、端末の接続には
		利用しません。ただ、
		ケーブルまたは端末がキャリア検出信号を使えない
		タイプのものの場合は、
		発信用のポートを使うとよいでしょう。</para>
	    </listitem>
	  </itemizedlist>

	  <para>詳しくは、&man.sio.4;
	    のマニュアルをご覧ください。</para>

	      <para>たとえば、端末を一つ目のシリアルポート (DOS
	    でいうところの <devicename>COM1</devicename>) に接
	    続したとすると、<filename>/dev/ttyd0</filename>
	    がこの端末を指すことになります。また、
	    二つ目のシリアルポート (<devicename>COM2</devicename>)
	    ならば <filename>/dev/ttyd1</filename> となり、
	    以下この形式のデバイスエントリを使います。</para>

	      <para>各シリアルポート、
	    特にマルチポートのシリアルカードを利用する ために、kernel
	    の設定をおこなう必要がある場合がありますので、注意してくだ
	    さい。詳しくは、<link linkend="kernelconfig">FreeBSD
	      カーネルのコンフィグレーション</link>
	    をご覧ください。</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2 id="term-config">
      <title>設定</title>

      <para>ここでは、端末からのログインを可能にするために必要な
	FreeBSD  側の設定について解説します。
	既に端末を接続するポートが利用できるように  kernel
	の設定をおこない、端末が接続されているものと考えて、解説を進め
	ます。</para>

      <para>簡単に言えば、プロセス管理や初期化をおこなっている
	<command>init</command> プロセス に対して、
	ログイン名を読み込み <command>login</command>
	プログラムを起動している  <command>getty</command>
	を実行するように指示します。</para>

      <para>これをおこなうには、<filename>/etc/ttys</filename>
	の内容を編集する必要があります。まず、<command>su</command>
	コマンドで root になって、<filename>/etc/ttys</filename>
	に以下の 変更を加えてください。</para>

      <procedure>
	<step>
	  <para>端末を接続するポートの <filename>/dev</filename>
	    のエントリが含ま れている行がまだ存在しなければ、これを
	    <filename>/etc/ttys</filename> に追加してく ださい。</para>
	</step>

	<step>
	  <para><filename>/usr/libexec/getty</filename>
	    が対象となるポートに対して
	    実行されるように指定してください。また、
	    <filename>/etc/gettytab</filename> ファイ ル内の適切な
	    <replaceable>getty</replaceable>
	    タイプのエントリを指定してください。</para>
	</step>

	<step>
	  <para>デフォルトのターミナルタイプを指定してください。</para>
	</step>

	<step>
	  <para>対象となるポートを <quote>on</quote>
	    に設定してください。</para>
	</step>

	<step>
	  <para>そのポートが <quote>secure</quote>
	    であるかどうかを指定してください。</para>
	</step>

	<step>
	  <para><command>init</command> に
	    <filename>/etc/ttys</filename> を読み込みなおさせてく
	    ださい。</para>
	</step>
      </procedure>

      <para>また、必要に応じて <filename>/etc/gettytab</filename>
	を変更し、上の 2で使用する
	<replaceable>getty</replaceable> のエントリを追加してください。
	このドキュメントではこの方
	法については特に解説しませんので、&man.gettytab.5;
	および &man.getty.8; のマニュアルをご覧ください。</para>

	  <para>以下では、上のステップについて詳しく解説します。
	実例を用いて、何をす べきかを解説していきます。Wyse-50 と、
	古い IBM の 286 マシン上で通信 ソフト Procomm を使って VT-100
	エミュレーションをおこなっているものを端
	末の例として紹介します。また、Wyse は 2番目のポートに、
	286マシンは 6 番目のポート
	(マルチポートのシリアルカード上のポート) に接続します。</para>

      <para><filename>/etc/ttys</filename> について、
	より詳しくは、&man.ttys.5; のマニュアルをご覧
	ください。</para>

      <sect3 id="term-etcttys">
	<title><filename>/etc/ttys</filename> へのエントリの追加</title>

	<para>既にエントリがある場合を除いて、まず初めに
	  <filename>/etc/ttys</filename>
	  にエントリを追加しなければいけません。</para>

	<para><filename>/etc/ttys</filename> には、
	  FreeBSDシステム上のログインを許可するすべての
	  ポートを記述します。たとえば、一つ目の仮想コンソール
	  <filename>ttyv0</filename> のエン
	  トリもこのファイルにあります。このエントリのおかげで、
	  コンソールからの ログインが可能になっています。
	  このファイルには、他の仮想コンソール、シ
	  リアルポートおよび仮想端末のエントリも含まれています。
	  端末を接続する 場合は、そのポートの
	  <filename>/dev</filename> のエントリを、
	  <filename>/dev</filename> の部分
	  を省略して記述します。</para>

	<para>FreeBSD のインストール当初の状態では、
	  <filename>ttyd0</filename> から <filename>ttyd3</filename>
	  までの、初めの四つのシリアルポートのエントリが
	  <filename>/etc/ttys</filename> に記述され ています。
	  これらのポートのいずれかに端末を接続する場合は、新たなエント
	  リを追加する必要はありません。</para>

	<para>ここで紹介している例では、
	  既にファイルにエントリが存在する 2番目のシリ アルポート、
	  <filename>ttyd1</filename> に Wyse-50 を接続しています。
	  一方、6番目のシ リアルポートに接続する
	  286マシン用のエントリは、新たに追加してやらな
	  ければなりません。以下に、エントリを追加した後の
	  <filename>/etc/ttys</filename> か ら抜粋して示します。
	</para>

	<programlisting>ttyd1   "/usr/libexec/getty std.9600"   unknown off secure
ttyd5</programlisting>
      </sect3>

      <sect3 id="term-getty">
	<title><replaceable>getty</replaceable> タイプの指定</title>

	<para>次に、
	  端末からのログインを処理するプログラムの指定をおこな います。
	  FreeBSDでは、標準的には
	  <filename>/usr/libexec/getty</filename> をこの目的
	  で利用しています。<prompt>login:</prompt>
	  プロンプトを送り出しているのは、このプロ グラムです。</para>

	<para><command>getty</command> プログラムは、
	  コマンドラインパラメータとして、
	  <replaceable>getty</replaceable> タイプをとります。ただし、
	  このパラメータは必須ではあ りません。
	  <replaceable>getty</replaceable> タイプは、
	  ボーレートやパリティといった、接続され
	  た端末の特徴を表すものです。<command>getty</command>
	  プログラムは、与えられた  <replaceable>getty</replaceable>
	  タイプに対応したこれらの特徴を
	  <filename>/etc/gettytab</filename> から 読み込みます。</para>

	<para>ファイル <filename>/etc/gettytab</filename> には、
	  新旧の端末に関する多数のエントリ が記述されています。
	  ほとんどの場合、<literal>std</literal>
	  という文字列で始まる名前 のエントリを使えば、
	  接続された端末に対してログインセッションを提供す
	  ることができます。これらのエントリを利用した場合、
	  パリティは無視されま す。110 bps から 115200 bps
	  までのボーレートに対応した <literal>std</literal> のエン
	  トリがあります。当然、
	  新たなエントリを追加することも可能です。
	  &man.gettytab.5; のマニュアルに、
	  さらに詳しく解説されています。</para>

	<para><filename>/etc/ttys</filename> の <emphasis
	    remap=tt>getty</emphasis> タイプの設定をする際は、
	  端末側の通信 パラメータの設定が、<emphasis
	    remap=tt>getty</emphasis>
	  タイプのものと一致していることを確認し てください。</para>

	<para>紹介している実例では、Wyse50 はパリティなし 38400 bps
	  で接続していま す。また、286 マシンの方は、パリティなし
	  19200 bps の接続です。以下は、
	  この段階でのこの二つの端末に関する
	  <filename>/etc/ttys</filename> の設定です。</para>

	<programlisting>ttyd1   "/usr/libexec/getty std.38400"   unknown off secure
ttyd5   "/usr/libexec/getty std.19200"</programlisting>

	<para>ここで、実行するプログラムを指定している
	  2番目のフィールドが、ダブルクォー
	  テーションに囲まれていることに注意してください。
	  こうしないと、<command>getty</command> のタイプの指定が、
	  つぎのフィールドとして判断されてしまう可 能性があるので、
	  十分注意することが必要です。</para>
      </sect3>

      <sect3 id="term-deftermtype">
	<title>デフォルトのターミナルタイプの指定</title>

	<para><filename>/etc/ttys</filename> の 3番目のフィールドには、
	  そのポートのター ミナルタイプのデフォルトを指定します。
	  ダイアルアップ用のポートの場合 は、
	  ユーザがどのタイプの端末あるいは
	  通信ソフトを利用してダイアルアップ
	  してくるかは分からないので、<literal>unknown</literal> や
	  <literal>dialup</literal> を記述するの が一般的です。一方、
	  直結された端末の場合、ターミナルタイプが変わるこ
	  とはありませんから、
	  このフィールドには実際のターミナルタイプを記述し
	  ます。</para>

	<para>一般に、ユーザは <filename>.login</filename> や
	  <filename>.profile</filename> などのファイル内で
	  <command>tset</command> コマンドを使って、
	  ターミナルタイプをチェックし、必要ならば
	  ターミナルタイプの入力を求めるプロンプトを
	  表示するようにします。この とき、
	  <filename>/etc/ttys</filename>
	  の中でターミナルタイプが指定されていれば、
	  このプロンプトを表示せずに先に進むことが可能です。</para>

  <indexterm><primary>termcap</primary></indexterm>
	<para>FreeBSD 上で、どのターミナルタイプを利用できるかは、
	  <filename>/usr/share/misc/termcap</filename> をご覧ください。
	  このファイルには、お
	  よそ 600 のターミナルタイプが定義されています。
	  必要ならば、新たなエン
	  トリを追加することも可能です。詳しくは &man.termcap.5;
	  のマニュアルをご覧ください。</para>

	<para>紹介している例では、Wyse-50 のターミナルタイプは
	  Wyse-50 です (もっ
	  とも他のタイプをエミュレートすることも可能ですが、ここでは
	  Wyse-50 モー ドで使用します)。また、286マシン上では
	  Procomm が VT-100 エミュレー
	  ションをおこなうように設定されています。以下が、まだ未完成の
	  <filename>/etc/ttys</filename> の関連部分です。</para>

	<programlisting>ttyd1   "/usr/libexec/getty std.38400"   wy50  off secure
ttyd5   "/usr/libexec/getty std.19200"	 vt100</programlisting>
      </sect3>

      <sect3 id="term-enable">
	<title>ポートを利用可能にする</title>

	<para><filename>/etc/ttys</filename> のつぎのフィールド、
	  つまり 4番目のフィー ルドは、
	  そのポートをアクティブにするかどうかの設定です。
	  このフィールド に <literal>on</literal> を指定すると、
	  <command>init</command> プロセスが2番目のフィールドに書かれ
	  たプログラム、<command>getty</command> を実行し、
	  ログインのためのプロンプトを送り出 すようになります。
	  このフィールドに <literal>off</literal> を記述すると、
	  <command>getty</command>  は起動されず、
	  よってこのポートからのログインもできなくなります。</para>

	<para>ということで、当然このフィールドには
	  <literal>on</literal> を指定します。以下が
	  <filename>/etc/ttys</filename> です。それぞれのポートを
	  <literal>on</literal> にしました。</para>

	<programlisting>ttyd1   "/usr/libexec/getty std.38400"   wy50  on secure
ttyd5   "/usr/libexec/getty std.19200"	 vt100 on</programlisting>
      </sect3>

      <sect3 id="term-secure">
	<title>``secure'' なポートの指定</title>

	<para>とうとう最後のフィールドの設定です。
	  (実際にはここでは触れ ませんが、
	  オプショナルな<literal>window</literal>
	  の設定のフィールドも存在するので、
	  ほぼ最後のフィールドといった方が正確かもしれません)
	  最後のフィールド では、
	  そのポートが安全かどうかを指定します。</para>

	<para>ここで、<quote>安全</quote>
	  なポートとはどういうポートのことでしょう?</para>

	<para>これは、root のアカウント (または、ユーザ ID が 0
	  のアカウント) がロ グインしてもよいポートということです。
	  安全でないポートでは、root のロ
	  グインは許可されません。</para>

	<para>では、どのように安全なポートとそうでない
	  ポートを使えばよいでしょう?</para>

	<para>ポートを安全ではないとすることで、
	  そのポートに接続された端末からは、root
	  のログインを禁止することができます。FreeBSDシステムの root
	  のパス ワードを知っている人は、
	  まず一般ユーザとしてログインしなければなりませ ん。
	  スーパユーザの特権を得るためには、そのうえで
	  <command>su</command> コマンドを
	  利用しなければいけません。</para>

	<!-- kuriyama - Eng ver has bare login -->
	<para>これによって、root アカウントが不正に利用された場合に、
	  その経過を調査 する上で二つの記録を利用できるようになります。
	  <command>login</command> と  <command>su</command>
	  コマンドは、共にシステムのログに記録を残します (また、
	  ログイン は <filename>wtmp</filename> にも記録を残します。
	  )。</para>

	<para>ポートを安全なものとして指定すると、その端末からの root
	  のログインが可 能になります。root
	  のパスワードを知っている人は、単に root としてログ
	  インできます。この場合は、当然ログインの記録や
	  <command>su</command> コマンドのログ は残りません。</para>

	<para>では、どちらを使うべきでしょうか?</para>

	<para>単純に <quote>insecure</quote> を使うのがよいでしょう。
	  公共の場所にある訳では<emphasis>な い</emphasis>端末や、
	  鍵のかかったドアの内側にある端末<emphasis>にも</emphasis>
	  <quote>insecure</quote> を指 定する方がよいでしょう。
	  スーパユーザの特権が必要な場合でも、ログイ ンして
	  <command>su</command> を実行するのは、
	  ごく簡単なことなんですから。</para>

	<para>以下に、ようやく完成した <filename>/etc/ttys</filename>
	  のエントリに端末の場所を表
	  すコメントを追加したものを示します。</para>

	<programlisting>ttyd1   "/usr/libexec/getty std.38400"   wy50  on insecure # Kitchen
ttyd5   "/usr/libexec/getty std.19200"	 vt100 on insecure # Guest bathroom</programlisting>
      </sect3>

      <sect3 id="term-hup">
	<title><command>init</command> にファイル
	  <filename>/etc/ttys</filename> の再読み 込みをさせる</title>

	<para>FreeBSD をブートすると、最初に起動されるプロセス、
	  <command>init</command>が  <filename>/etc/ttys</filename>
	  を読み込んで、記述されているプログラムを利用可能な
	  ポートに対して実行し、
	  ログインプロンプトを送り出させます。</para>

	<para><filename>/etc/ttys</filename> の編集が終わった後、
	  <command>init</command> に変更を認識させるた めに、わざわざ
	  FreeBSD をブートしなおしたくはないでしょう。このような
	  場合のために、<command>init</command> は、
	  <literal>SIGHUP</literal> (hangup) シグナルを受信すると、
	  <filename>/etc/ttys</filename>
	  を読み込みなおすようになっています。</para>

	<para><filename>/etc/ttys</filename> の変更を保存したら、
	  以下のようなコマンドを実行して、<command>init</command>
	  に対して SIGHUP を送信します。</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<para>(<command>init</command> プロセスのプロセス ID は
	  <emphasis>常に</emphasis> 1です)</para>

	<para>すべての設定が正しくおこなわれ、
	  すべてのケーブルがただしく接続されてい て、
	  かつ端末の電源が入っていれば、
	  端末にはログインプロンプトが表示され ているはずです。これで、
	  これらの端末からの最初のログインの準備が完了で す!</para>
      </sect3>
    </sect2>

    <sect2 id="term-debug">
      <title>トラブルシューティング</title>

      <para>細心の注意を払って設定をおこなっても、
	ときには端末の接続がう まくいかない場合があるでしょう。以下に、
	よく見られる問題とその解決方法 を示します。</para>

      <variablelist>
	<varlistentry><term>ログインプロンプトが表示されない</term>
	  <listitem>
	    <para>端末の電源が接続され、
	      スイッチが入っていることを確認してください。もし、PC
	      を端末として利用している場合は、
	      通信ソフトが適切なシリアルポー
	      トを利用する設定になっているかどうか確かめてください。
	    </para>

	    <para>ケーブルがしっかりと端末と
	      FreeBSDが動作しているコンピュータの両方に接続され
	      ていることを確認してください。また、
	      正しい種類のケーブルを利用している
	      か確かめてください。</para>

	    <para>端末と FreeBSD
	      の間の通信速度とパリティの設定が一致していることを確認
	      してください。
	      出力をモニタに表示するタイプの端末の場合は、モニタ
	      のコントラストと明るさの設定を確認してください。また、
	      出力が印刷 されるタイプの端末の場合は、
	      紙とインクが十分にあるかどうかを確かめてく
	      ださい。</para>

	    <para><command>getty</command> が動いていて、
	      端末を認識していることを確認してください。以
	      下のコマンドで動作中の <command>getty</command>
	      プロセスのリストを得ることができます。</para>

	    <screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

	    <para>その端末に対する <command>getty</command>
	      の情報が表示されるはずです。たとえば、以下
	      の表示例は、<command>getty</command> は
	      2番目のシリアルポート (<literal>ttyd1</literal>) に対し
	      て <filename>/etc/gettytab</filename> 中の
	      <literal>std.38400</literal> のエントリを使って動作し
	      ているということを示しています。</para>

	    <screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1</screen>

	    <para>もし、<command>getty</command>
	      プロセスが一つも動いていないようであれば、
	      <filename>/etc/ttys</filename> の中で、
	      そのポートを利用可能にする設定をしたかどう
	      か確かめてください。また、<command>kill -HUP
		1</command> を確実に実行してください。</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>
	    ログインプロンプトの代わりにゴミが表示される</term>
	  <listitem>
	    <para>端末と FreeBSD
	      の間の通信速度およびパリティの設定が一致していることを確
	      かめてください。また、<command>getty</command>
	      プロセスの情報を調べて、適切な
	      <replaceable>getty</replaceable>
	      のタイプが使用されていることを確認してください。間違った
	      <emphasis remap=tt>getty</emphasis>
	      タイプが使用されている場合は、
	      <filename>/etc/ttys</filename> を修正し てから、
	      <command>kill -HUP 1</command>
	      を実行してください。</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>文字が重複して表示される、
	    入力したパスワードが表示される</term>
	  <listitem>
	    <para>端末または通信ソフトの設定で、<quote>半二重 (half
	      duplex)</quote> あるいは <quote>ローカ
	      ルエコー</quote> となっているところを、<quote>全二重 (full
	      duplex)</quote> に変更してください。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 id="dialup">
    <title>ダイアルインサービス</title>

    <indexterm><primary>ダイアルインサービス</primary></indexterm>
    <para><emphasis>原作: &a.ghelmer;.</emphasis></para>

    <para><emphasis>訳: &a.max;.<!-- <br> -->
	6 September 1996.</emphasis></para>

    <para>このドキュメントでは、FreeBSD
      で外部からのモデムによるアクセスを受け付
      けるための設定に関してまとめてあります。このドキュメントは筆者が
      FreeBSD 1.0、1.1 および 1.1.5.1 での経験と、他の Unix 系 OS
      での経験を 基に書いたものですが、
      必ずしも十分な内容でないかもしれませんし、掲載し
      た実例もあなたが今お使いの環境とは一致しないかもしれません。
      また、筆者 はこのドキュメントに従って行われた作業で
      データが失われたりシステムが破 壊されるようなことがあっても、
      一切責任をとれません。</para>

    <sect2 id="dialup-prereqs">
      <title>設定を始める前に</title>

      <para>筆者は、読者が FreeBSD
	に関する基本的な知識をもっていることを仮定して
	このドキュメントをまとめました。まず、FreeBSD
	が既にインストールされ ていて、Unix
	系環境においてファイルの編集の方法やシステムに付属のマニュ
	アルを参照する方法を知っている必要があります。また、
	以下に示すように、FreeBSD
	の特定のバージョンが必要となりますし、いくつかの用語に関する
	知識、
	そしてモデムや多少の配線に関する知識も必要となります。</para>

      <sect3>
	<title>FreeBSD のバージョン</title>

	<para>まず、FreeBSD のバージョンは 1.1 以上を使用してください
	  (バージョン  2.X でもかまいません)。FreeBSD 1.0 には、
	  2種類のシリアル ドライバ が含まれているので、
	  混乱の元となり得ます。また、FreeBSD のシリアル  ディバイス
	  ドライバ (<devicename>sio</devicename>) は、
	  バージョンを追う毎に改善されてき ていますので、
	  より新しいバージョンの FreeBSD を使用することで、よりよ い、
	  より効率の高いドライバを利用することができるはずです。</para>
      </sect3>

      <sect3>
	<title>用語解説</title>

	<para>以下、簡単にいくつかの用語について解説しておきます。</para>

	<variablelist>
	  <varlistentry><term>bps</term>
	    <listitem>
	      <indexterm><primary>bits-per-second</primary></indexterm>
	      <para>Bits per Second　の略で、
		データの転送速度を表す単位。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>DTE</term>
	    <listitem>
	      <indexterm><primary>DTE</primary></indexterm>
	      <para>Data Terminal Equipment の略。
		たとえばコンピュータ本体のこと。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>DCE</term>
	    <listitem>
	      <indexterm><primary>DCE</primary></indexterm>
	      <para>Data Communications Equipment の略で、
		具体的にはモデムのこと。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>RS-232</term>
	    <listitem>
	      <indexterm><primary>RS-232 ケーブル</primary></indexterm>
	      <para>EIA (米電気産業協会)
		のハードウェア間シリアル通信の標準規 格。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>これらの用語やデータ通信一般に関して、
	  より詳しい情報が必要な場合は、<emphasis>The RS-232
	    Bible</emphasis> という本 (誰か ISBN 分かる方いませんか?)
	  が参考 になると思います。</para>

	<para>通信においてのデータ転送速度に関して、
	  このドキュメントでは <quote>ボーレー ト</quote> (baud rate)
	  ではなく、<quote>bps</quote> (bits per second)
	  をその単位として 使うことにします。これは、
	  ボーというのは一定時間に生じる電気的状態の変
	  化の数を表す単位にすぎず、<quote>bps</quote>
	  という単位の方が実体に即しているか らです (少なくとも、
	  こういう表現をしておけば、意地の悪い人に怒られる
	  こともないのではないかと思います)。</para>
      </sect3>

      <sect3>
	<title>外づけモデムと内蔵モデムについて</title>

	<para>ダイアルアップのサービスに関していえば、
	  外づけのモデムの方が適している ようです。これは、
	  多くの外づけのモデムは設定を不揮発ラムに書き込んで半
	  永久的に保存することができますし、また RS-232
	  に関する重要な情報を知る
	  ための点滅するライトによるインディケータが
	  搭載されているからです。点滅 するライトは、
	  システムを見に来た訪問者に強い印象を与えるという効果だけ
	  でなく、モデムが適切に動作しているかどうかを知るためにも
	  有効です。</para>

	<para>一方、たいていの内蔵型のモデムには
	  不揮発性ラムが搭載されていないため、ディップ
	  スイッチの変更以外に設定を保存する方法がありません。また、も
	  しインディケータがついていても、おそらくコンピュータのケース
	  カバーが 外されていなければその状態を確認するのは
	  難しいでしょう。</para>
      </sect3>

      <sect3>
	<title>モデムとケーブル</title>

	<para>以下のことに関して、予め知っておく必要があります。</para>

	<itemizedlist>
	  <listitem>
	    <para>コンピュータとモデムの間での通信が
	      行えるようにするための接続方 法。
	      (内蔵型の場合は接続の必要はありません)</para>
	  </listitem>

	  <listitem>
	    <para>お使いのモデムのコマンドについての知識、
	      あるいはコマンドの解説 の在処</para>
	  </listitem>

	  <listitem>
	    <para>(通信ソフトを使っての)
	      モデムの不揮発ラムに保存可能な設定の変更 方法</para>
	  </listitem>
	</itemizedlist>

	<para>1番目のモデムの接続はたいてい簡単に行えるはずです。
	  ほとんどのストレー ト シリアル ケーブルが使えるでしょう。
	  使用すべきケーブルは、両端に適 切なコネクタ (DB-25 または
	  DB-9 の雄または雌) のついた、DCE-DTE 間接 続用のもので、
	  以下の信号線が接続されていなければなりません。</para>

  <indexterm><primary>モデムコマンド</primary></indexterm>
	<itemizedlist>
	  <listitem>
	    <para>Transmitted Data (<acronym>SD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Received Data (<acronym>RD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Request to Send (<acronym>RTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Clear to Send (<acronym>CTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Set Ready (<acronym>DSR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Terminal Ready (<acronym>DTR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Carrier Detect (<acronym>CD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Signal Ground (<acronym>SG</acronym>)</para>
	  </listitem>
	</itemizedlist>

	<para>FreeBSD で 2400bps 以上の転送速度を利用する場合には、
	  フロー制御のため に <acronym>RTS</acronym> 信号と
	  <acronym>CTS</acronym> 信号が必要です。また、
	  接続の確立と回線の切 断を検出するために
	  <acronym>CD</acronym> 信号を利用します。さらに、
	  <acronym>DTR</acronym> 信号を使っ
	  て回線切断後のモデムのリセットを行います。ケーブルの中には、
	  総ての必要 な信号線が接続されていないものもありますので、
	  たとえば、回線切断後でも ログイン
	  セッションが残ってしまうといった問題が発生した場合などには、
	  ケーブルに問題がある可能性もあります。</para>

	<para>次に、お使いのモデムにもよりますが、
	  もしモデムのコマンドをよく覚えてい ない場合は、
	  モデムのマニュアルをすぐに参照できるようにしておいてくださ
	  い。このドキュメントでは例として USR Sportstar の 14,400 bps
	  の外づけ型 モデムのコマンドを示しておきます。
	  他の種類のモデムをお使いの場合も、参
	  考になるかもしれません。</para>

	<para>最後に、FreeBSDで快適にモデムを使うためにも、
	  モデムの設定方法を知って おく必要があります。FreeBSD も他の
	  Unix 系 OS と同様、回線の接続およ
	  び切断の検出や回線の切断および回線切断後の
	  モデムの初期化にハードウェア  シグナルを利用します。FreeBSD
	  は、モデムに対するコマンドの送信やモデ
	  ムの状態の監視を行いません。パソコンで運用されている BBS
	  への接続に慣 れている方にとっては、
	  ちょっとめんどうかもしれませんね。</para>
      </sect3>

      <sect3>
	<title>シリアル インタフェースについて</title>

	<para>FreeBSD では、NS8250-、NS16450-、NS16550- および
	  NS16550A- に基づ いた EIA RS-232C (CCITT V.24)
	  規格のシリアル インタフェースをサポート しています。8250
	  および 16450 ベースのディバイスには1文字のキャラクタ
	  バッファが搭載されています。また、16550 系のディバイスには、
	  16文字分 のバッファが搭載されていて、
	  はるかによいパフォーマンスを得られます (ただし、無印の
	  16550 では、バグがあって 16 文字バッファが利用できませ
	  んので、可能であれば 16550A
	  系のディバイスを利用してください)。1文字 のバッファの物は、
	  16550 系のものと比べて OS にかける負荷が大きいので、16550A
	  系ディバイスの利用を強く推奨します。多数のシリアル
	  ポートを利 用する場合や、負荷の高いシステムにおいては、
	  16550A 系ディバイスを使う ことで、
	  エラー発生率を低く押さえることができます。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>概要</title>

      <para>FreeBSD は以下の手順でモデムからのログインを受付ます。
	<command>init</command> から起 動された
	<command>getty</command> のプロセスが、割り当てられたシリアル
	ポート (この 例では <filename>/dev/ttyd0</filename>)
	がオープンされるのを辛抱強く待ちます。<command>ps
	  ax</command> コマンドを実行すると、
	以下のような出力が得られるはずです。</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0</screen>

      <para>ユーザがモデムに電話をかけ、モデム同士が接続されると、
	モデムの <acronym>CD</acronym> が検出されます。その結果、
	kernel がキャリア信号を検出して、<command>getty</command>
	によるポートのオープンの処理が終了します。
	<command>getty</command> は、<prompt>login:</prompt>
	プロンプトを指定されている初期回線速度で送信します。
	<command>getty</command> は、
	正常に文字列を受信できるかどうか監視し、通常の設定では、
	もし以上な文字列を検出した場合 (理由としては、
	<command>getty</command> の速度とモデ
	ムの接続速度が異なっているような場合が考えられます)、
	正常に文字列が 受信できるまで、<command>getty</command>
	は速度を変え続けます。</para>

      <indexterm>
        <primary><command>/usr/bin/login</command></primary>
      </indexterm>
      <para><command>getty</command> が正しい速度を検出すれば、
	ユーザに対して <prompt>login:</prompt> プロン
	プトが表示されるはずです。ユーザがログイン名を入力すると、
	<command>getty</command>  は
	<filename>/usr/bin/login</filename> を起動して、
	パスワードの入力を要求し、その
	後ユーザのシェルを起動します。</para>

      <para>それでは、続いて設定についての解説です。</para>
    </sect2>

    <sect2>
      <title>kernel の設定</title>

      <para>通常、FreeBSD の kernel は、MS-DOS の世界で
	<devicename>COM1:</devicename>、<devicename>COM2:</devicename>
	、<devicename>COM3:</devicename> および
	<devicename>COM4:</devicename> と呼ばれる四つのシリアル ポートを
	探す
	ように設定されています。また、FreeBSD では、現在のところ
	Boca の 1008
	や 2016 のような、<quote>単純な</quote>マルチポートのシリアル
	インタフェースもサポー
	トしています (マルチポートのシリアル ボードに関しての
	kernel の設定
	については、&man.sio.4; のマニュアルを参照してください)。
	デフォルト
	の kernel は、COM ポートだけを探します。</para>

      <para>搭載されているシリアル ポートのいずれかを、kernel
	が認識しているかどう か確認したい場合は、kernel
	起動時のメッセージを注意深く見ているか、あ るいは
	<command>/sbin/dmesg</command> コマンドを使って、
	ブート時の出力メッセージ を確認してください。特に、
	<literal>sio</literal> で始まるメッセージをよく見てくださ い。
	参考までに、以下のコマンドで <literal>sio</literal>
	という文字列を含むメッセージ
	だけを表示することができます。</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'sio'</userinput></screen>

      <para>たとえば、シリアル ポートを四つ持つシステムの場合は、
	以下のようなシリ アル ポートに関するメッセージが kernel
	によって表示されます。</para>

      <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A</screen>

      <para>もし、kernel に正常に認識されないポートがある場合は、
	おそらくカスタマ イズした kernel
	を構築する必要があるでしょう。</para>

      <para>kernel 構築と構築のための設定に関しては、BSD System
	Manager's Manual の <quote>Building Berkeley Kernels with
	Config (config コマンドによる BSD kernel の構築) </quote>
	[ソース ファイルは <filename>/usr/src/share/doc/smm</filename>
	にあります]と <quote>FreeBSD Configuration Options</quote> [
	<filename>/sys/conf/options</filename> および <filename>
	  /sys/<replaceable>arch</replaceable>/conf/options.<replaceable>arch
	  </replaceable></filename> の  <emphasis>arch</emphasis>
	の部分をたとえば <filename>i386</filename> としたファイル ]
	を参照 してください。</para>

      <para>kernel の設定と構築をするためには、kernel のソース
	(FreeBSD 1.1 では <filename>srcdist/srcsys.??</filename>、
	FreeBSD 1.1.5.1 では  <filename>srcdist/sys.??</filename>、
	またFreeBSD 2.0 では総てのソース)を展開
	する必要があります。</para>

      <para>まだ自分のシステムの kernel 用のコンフィギュレーション
	ファイルを作っ ていない場合は、
	<filename>/sys/i386/conf</filename> に <command>cd</command>
	して作成してくださ い。初めてコンフィギュレーション
	ファイルを作る場合は、まず <filename>GENERICAH</filename>
	(FreeBSD 1.x で BusTek の SCSI コントローラを使っている場合は
	<filename>GENERICBT</filename>) というファイルを、
	<filename>YOURSYS</filename> にコピーしてください。ここ で、
	<filename>YOURSYS</filename> はあなたのシステム名で、
	大文字である必要があります。このファイルを編集して、
	ディバイスに関する記述を変更します。</para>

      <programlisting>device		sio0	at isa? port "IO_COM1" tty irq 4 vector siointr
device		sio1	at isa? port "IO_COM2" tty irq 3 vector siointr
device		sio2	at isa? port "IO_COM3" tty irq 5 vector siointr
device		sio3	at isa? port "IO_COM4" tty irq 9 vector siointr</programlisting>

      <para>システムに搭載されていないディバイスに関する記述は、
	コメントアウトまた
	は削除してしまってかまいません。
	Boca の BB2016 のようなマルチポートの
	シリアル ボードをお持ちの場合は、&man.sio.4;
	のマニュアルを見て、マ
	ルチポートのボードのためのコンフィギュレーション
	ファイルの記述のし方
	に関して確認してください。ディバイスのフラグの
	指定方法がバージョンによっ
	て異なりますので、別のバージョンの FreeBSD
	で利用していたコンフィギュ
	レーション ファイルを流用する場合には
	十分注意してください。</para>

      <note>
	<para>なお、<literal>port "IO_COM1"</literal>、
	  <literal>IO_COM2</literal>、<literal>IO_COM3</literal>
	  および  <literal>IO_COM4</literal> は、
	  それぞれのポートの一般的なアドレスである
	  <literal>0x3f8</literal>、<literal>0x2f8</literal>、
	  <literal>0x3e8</literal> および <literal>0x2e8</literal>
	  を表します。また、割り込 み番号 4、3、5 と 9 は、それぞれ
	  <devicename>COM1:</devicename> から
	  <devicename>COM4:</devicename> のポー トで一般的に使用される
	  IRQ です。また、ISA バスのコンピュータの場合、
	  一般的なシリアルポートは複数のポートで一つの IRQ
	  を共有することが
	  <emphasis>できません</emphasis>ので注意が必要です
	  (マルチポートのシリアル ボードの 場合は、複数の 16550A
	  ベースのポートで一つまたは二つの IRQ を共有する
	  ための機構を備えています)。</para>
      </note>

      <para>コンフィギュレーション ファイルの編集が終わったら、
	<quote>Building Berkeley Kernels with Config (config
	コマンドによる BSD kernel の構築)</quote> および
	  &man.config.8; のマニュアルにしたがって、
	<command>config</command> コマンド を使って kernel
	構築のためのディレクトリを作成した後、kernel の構築、
	インストールおよびテストを行ってください。</para>
    </sect2>

    <sect2>
      <title>ディバイス スペシャル ファイル</title>

      <para>kernel に組み込まれているほとんどのディバイスは、
	<filename>/dev</filename> ディレ クトリにある、
	<quote>ディバイス スペシャル
	ファイル</quote> を介してアクセスされ ます。
	<devicename>sio</devicename> ディバイスの場合は、着信用の
	<filename>/dev/ttyd<replaceable>?</replaceable></filename>
	およ び、発信用の
	<filename>/dev/cuaa<replaceable>?</replaceable></filename>
	が利用されます。さらに、FreeBSD の 1.1.5 以降では、
	初期化ディバイス
	(<filename>/dev/ttyi<replaceable>?</replaceable></filename> と
	<filename>/dev/cuai0<replaceable>?</replaceable></filename>)
	およびロッキング ディバイス
	(<filename>/dev/ttyld<replaceable>?</replaceable></filename>
	と
	<filename>/dev/cual0<replaceable>?</replaceable></filename>)
	も合わせて利用されます。初期化ディバイスは、通信
	ポートがオープンされる度に、
	そのポートの初期設定を行うために使われます。たとえば、
	<literal>CTS/RTS</literal>
	によるフロー制御を行うモデムが接続されてい る場合の
	<literal>crtscts</literal>
	などのパラメータの初期化が行われます。ロッキング
	ディバイスは、ポートの設定をロックし、
	他のユーザやプログラムにこれらを
	変更されることのないようにするために利用されます。
	通信ポートの設定、初 期化とロックおよび設定の変更に関しては、
	それぞれ &man.termios.4;、&man.sio.4; と &man.stty.1;
	のマニュアルをご覧ください。</para>

      <sect3>
	<title>ディバイス スペシャル ファイルの作成</title>

	<para>ディバイス スペシャル ファイルの管理は、ディレクトリ
	  <filename>/dev</filename>
	  にあるシェル スクリプト <command>MAKEDEV</command>
	  によって行います (FreeBSD
	  1.1.5 の &man.MAKEDEV.8; のマニュアルの <acronym>COM</acronym>
	  ポートに関する記述は、
	  かなりいい加減なので無視してください)。
	  <command>MAKEDEV</command> を使って、
	  <devicename>COM1:</devicename> (ポート 0)
	  をダイアルアップのポートとして利用するためのディ
	  バイス スペシャル ファイルを作るには、
	  <filename>/dev</filename> に <command>cd</command> して
	  から、<command>MAKEDEV ttyd0</command> と実行してください。
	  同様に、<command>MAKEDEV
	    ttyd1</command> とすることで、<devicename>COM2:</devicename>
	  (ポート 1)  用のディバイス スペシャル ファイル
	  を作成することができます。</para>

	<para><command>MAKEDEV</command> は、
	  <filename>/dev/ttyd<replaceable>?</replaceable></filename>
	  のディバイス ファイルだけでなく、
	  <filename>/dev/cuaa<replaceable>?</replaceable></filename>
	  (および FreeBSD 1.1.5 以降では総ての初期化ディバイ
	  スとロッキング ディバイスのスペシャル ファイル)
	  も作成します。さらに、もしシリアル端末用のスペシャル
	  ファイル
	  <filename>/dev/tty0<replaceable>?</replaceable></filename>
	  が存在すれ ば、それらの削除も行います。</para>

	<para>ディバイス スペシャル ファイルの作成後、
	  これらのファイルのパーミション が適切に設定されていて、
	  これらのディバイスを利用してもよいユーザのみが
	  読み書きできるようになっていることを確認してください (特に
	  <filename>/dev/cua*</filename>
	  のパーミションには注意を払ってください)。この確認 を怠ると、
	  一般のユーザがあなたのモデムを使うことができるようなことにな
	  りかねません。デフォルトの <filename>/dev/cua*</filename>
	  のパーミションは、以下の ようになっていて、
	  たいていの場合適切なものだと思います。</para>

	<screen>crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1</screen>

	<para>上の設定では、ユーザ <username>uucp</username> と、
	  グループ <username>dialer</username> に属するユーザ
	  が発信用のディバイスを利用できます。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>設定ファイル</title>

      <para>FreeBSD のシステムへのダイアル
	アップによるアクセスを実現するために編
	集が必要と思われる設定ファイルが、<filename>/etc</filename>
	ディレクトリに三つあ ります。まず、
	<filename>/etc/gettytab</filename> には、
	<filename>/usr/libexec/getty</filename>
	デーモンの設定を記述します。つぎに、
	<filename>/etc/ttys</filename> に保存されている情報から、
	<filename>/sbin/init</filename> はど の
	<filename>tty</filename> ディバイスに対して
	<command>getty</command> のプロセスを実行するべきか判
	断します。最後に、お使いの FreeBSD が 1.1.5.1 以降のものならば
	<filename>/etc/rc.serial</filename> スクリプトに、
	それ以前のものならば  <filename>/etc/rc.local</filename>
	スクリプトにシリアル ポートの初期化のためのコマ
	ンドを記述することができます。</para>

      <para>Unix にダイアル アップ モデムを接続する方法には、
	二つの考え方がありま す。一つの方法は、ダイアル
	インしてくるユーザの接続速度に関係なく、常
	にモデムとローカルのコンピュータの RS-232
	インタフェースの接続速度を一 定に保つように設定する方法です。
	この設定の長所は、ユーザがダイアル イ ンして接続されると、
	即座にシステムからのログイン プロンプトが送信され
	るということです。短所は、
	システムが実際のモデム間の速度を知ることがで きないために、
	Emacs のようなフル スクリーンのプログラムが、端末との接
	続速度が遅い場合でも、
	そのような場合に効果的な方法で画面出力を行わない
	点です。</para>

      <para>もう一つは、モデムの RS-232
	インタフェースとコンピュータの接続速度を、
	モデム間の接続速度に応じて変化させるような設定です。たとえば、
	モデム間 の接続が V.32bis (14.4 Kbps) ならば、
	モデムとコンピュータの間の接続を  19.2 Kbps とし、
	モデム間の接続が 2400 bps の時には、モデムとコンピュー タ間も
	2400 bps で接続するような設定をします。この場合、
	<command>getty</command> は、モデムが返すリザルト
	コードからモデムとコンピュータの接続速度を認識す
	ることができませんので、<command>getty</command> は、
	まず初期速度で <prompt>login:</prompt> とい
	う文字列を送信して、それに対する応答の文字列を監視します。
	ここで、ユー ザ側の端末に無意味な文字列が表示された場合、
	ユーザは意味のある文字列を 受信するまで
	<literal>&lt;Enter&gt;</literal>
	キーを繰り返し押さなければならない
	ということを知っていると仮定しています。
	もし接続速度が間違っている場合、<command>getty</command> は、
	ユーザから送られた文字を無意味な文字列として扱い、次の
	速度を試します。そして、ここで再度 <prompt>login:</prompt>
	プロンプトを送信します。
	この一連の動作が異常な回数繰り返されることも考えられますが、
	普通は1度 か2度のキー入力があれば、
	ユーザはまともなプロンプトを受信できます。こ
	のログインの動作が前者の固定速度による方法に
	比べて美しくないのは明らか ですが、この方法では、
	低速度で接続しているユーザに対するフル スクリー
	ンのプログラムからのレスポンスが改善されます。</para>

      <para>このドキュメントでは、両方の設定方法について解説しますが、
	どちらかとい うとモデム間の速度に応じて RS-232
	インタフェースの速度が変化するような
	設定の方に偏った説明になってしまうと思います。</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

  <indexterm>
    <primary><filename>/etc/gettytab</filename></primary>
  </indexterm>

	<para><filename>/etc/gettytab</filename> は、&man.getty.8;
	  の設定ファイルで、&man.termcap.5;
	  と同様の形式で記述されます。ファイルのフォーマットや定
	  義できる機能についての詳細については、&man.gettytab.5;
	  のマニュアルを
	  ご覧ください。</para>

	<sect4>
	  <title>固定速度の設定</title>

	  <para>モデムとコンピュータ間の通信速度を固定して使う場合、
	    おそらく  <filename>/etc/gettytab</filename>
	    に特に変更を加える必要はないはずです。</para>
	</sect4>

	<sect4>
	  <title>可変速度の設定</title>

	  <para><command>getty</command>
	    が利用するモデムとコンピュータの接続速度に関する情報を
	    <filename>/etc/gettytab</filename>
	    に記述する必要があります。もし、2400 bps のモ
	    デムをお使いになるのであれば、既存の
	    <literal>D2400</literal> のエントリがそのまま利
	    用できるでしょう。このエントリは FreeBSD の 1.1.5.1 の
	    <filename>gettytab</filename>  には既に含まれていますので、
	    あなたの FreeBSD のバージョンでこのエント
	    リが存在しているのであれば、
	    新たに追加する必要はありません。</para>

	  <programlisting>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

	  <para>高速モデムをお使いの場合は、おそらく
	    <filename>/etc/gettytab</filename> に新たなエ
	    ントリを追加する必要があります。以下の例は、14.4 Kbps
	    のモデムを、最 大インタフェース速度を 19.2 Kbps
	    として利用するためのエントリです。</para>

	  <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

	  <para>上記の例を利用した場合、FreeBSD 1.1.5
	    以降ではパリティなし、8ビットの 接続が行われます。FreeBSD
	    1.1 では、<literal>:np:</literal> パラメータをファイルの
	    先頭の
	    <literal>std.<replaceable>xxx</replaceable></literal>
	    のエントリに追加することで、パリティなし、
	    8ビットの接続が行われますが、
	    このパラメータを追加しなければ接続は偶数 パリティ、
	    7ビットになります。</para>

	  <para>上記の例では、まず 19.2 Kbps (V.32bis)
	    によるモデムとコンピュータ間の 接続を試み、続いて 9600 bps
	    (V.32)、2400 bps、1200 bps、300 bpsと順に 試み、再び 19.2
	    Kbps による接続を試みるという循環に入ります。この接続
	    速度の循環は、<literal>nx=</literal>(<quote>next
	    table</quote>) の機能で実現されています。ま た、
	    各行はそれぞれ <literal>tc=</literal>(<quote>table
	    continuation</quote>) の機能を使って、
	    その他の接続速度に依存した <quote>標準的な</quote>
	    設定を取り込んでいます。</para>

	  <para>もし、お使いのモデムが 28.8 Kbps であったり、14.4 Kbps
	    の圧縮転送の機 能を有効に利用したい場合は、19.2 Kbps
	    よりも速い速度を利用するように 設定する必要があります。
	    以下に 57.6 Kbps から接続を試みる
	    <filename>gettytab</filename>
	    の設定例を示しておきます。</para>

	  <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

	  <para>もし、お使いの CPU が低速のものであったり、CPU
	    に対する負荷が高い場合 で、16550A 系のシリアル
	    ポートをお使いでない場合、57.6 Kbps の接続に おいて、sio
	    の <quote>silo</quote>
	    エラーが発生するかもしれません。</para>
	</sect4>
      </sect3>

      <sect3 id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>
  <indexterm>
    <primary><filename>/etc/ttys</filename></primary>
  </indexterm>

	<para><filename>/etc/ttys</filename> には、
	  <command>init</command> が監視すべき <filename>tty</filename>
	  のリストを記<!-- kuriyama - filename? -->
	  述します。さらに、<filename>/etc/ttys</filename> は、
	  <command>login</command> に対してセキュリ
	  ティに関する情報を提供します。(ユーザ
	  <username>root</username> は、<literal>secure</literal> とマー
	  クされている <emphasis remap=tt>tty</emphasis>
	  のみからログインできます)。詳しくは
	  &man.ttys.5; のマニュアルをご覧ください。</para>
	<!-- kuriyama - remap=tt? -->

	<para><filename>/etc/ttys</filename> の既存の行を変更するか、
	  あるいは新しい行を追加して、<command>init</command>
	  が自動的に新しいダイアル アップ サービス用のポートに対して
	  <command>getty</command>
	  プロセスを起動するようにしてください。書式は、固定速度の設
	  定か可変速度の設定かに関わらず、以下のとおりです。</para>

	<programlisting>ttyd0   "/usr/libexec/getty xxx"   dialup on</programlisting>

	<para>1番目の項目は、このエントリで対象とするディバイス
	  スペシャル ファイル です。上の例では
	  <literal>ttyd0</literal> として、
	  <filename>/dev/ttyd0</filename> を <command>getty</command>
	  に監視させることを表しています。2番目の項目
	  <literal>"/usr/libexec/getty
	    <replaceable>xxx</replaceable>"</literal>
	  (<replaceable>xxx</replaceable> は初期段階で使われる
	  <filename>gettytab</filename> のエントリ
	  に置き換えてください) が、<command>init</command>
	  がこのディバイスに対して起動する プロセスです。3番目の
	  <literal>dialup</literal> は、デフォルトのターミナル
	  タイプで す。4番目の <literal>on</literal> は、
	  この行が有効であることを <command>init</command> に対して示
	  しています。5番目の項目に <literal>secure</literal>
	  を指定することもできますが、これ は、
	  たとえばシステムのコンソールのように、
	  物理的に安全な端末に対しての
	  み指定するようにしてください。</para>

	<para>デフォルトのターミナル タイプ (上記の例では
	  <literal>dialup</literal>) は、ローカル
	  のユーザの好みによって異なってきます。ユーザがログイン
	  スクリプトをカ スタマイズして、ターミナル タイプが
	  <literal>dialup</literal> の時には自動的に他のター ミナル
	  タイプを設定できるように、ダイアル
	  アップのポートのデフォルトの ターミナル タイプには
	  <literal>dialup</literal> が伝統的に用いられています。
	  しかし、筆者のサイトでは、ほとんどのユーザが VT102
	  エミュレイションを使ってい るので、ダイアル
	  アップのポートのデフォルト ターミナル タイプとして
	  <literal>vt102</literal> を指定しています。</para>

	<para><filename>/etc/ttys</filename> の修正がすんだら、
	  以下のようなコマンドを使って
	  <command>init</command> プロセスに <acronym>HUP</acronym>
	  シグナルを送り、<filename>/etc/ttys</filename> を
	  読み込み直させてください。

	  <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	  ただ、もし初めてシステムを設定しているのであれば、
	  モデムが適切に設定さ
	  れて接続されるまでは、<command>init</command>
	  に対してシグナルを送らない方がいいか
	  もしれません。</para>

	<sect4>
	  <title>固定速度の設定</title>

	  <para>速度を固定する設定では、<filename>/etc/ttys</filename>
	    の中で、<command>getty</command> に対し
	    て固定速度のエントリを指定する必要があります。たとえば、
	    以下の例はポー トのスピードが 19.2 Kbps
	    に固定されたモデムのための <filename>ttys</filename>
	    のエント リです。</para>

	  <programlisting>ttyd0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

	  <para>別の速度でモデムのポートのスピードを固定したい場合は、
	    <filename>/etc/gettytab</filename>
	    から適切なエントリを選んで、上の例の
	    <literal>std.19200</literal> の部分を
	    <literal>std.<replaceable>speed</replaceable></literal>
	    として、適切な速度のも のに置き換えてください。</para>
	</sect4>

	<sect4>
	  <title>可変速度の設定</title>

	  <para>可変速度の設定では、<filename>ttys</filename>
	    のエントリが、<filename>/etc/gettytab</filename>
	    の中の適切な <quote>自動速度調整</quote>
	    の初期設定のエントリを参照していなければな りません。
	    たとえば、もし前述の 19.2 Kbps
	    から接続を試みる可変速度の設 定例
	    (<literal>V19200</literal> の
	    <filename>gettytab</filename> エントリ)をそのまま
	    <emphasis remap=tt>ttys</emphasis> に追 加したのであれば、
	    <filename>ttys</filename>
	    エントリは以下のようになります。</para>

	  <programlisting>ttyd0   "/usr/libexec/getty V19200"   dialup on</programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.serial</filename> または
	  <filename>/etc/rc.local</filename></title>
  <indexterm>
    <primary>rc ファイル</primary>
    <secondary><filename>rc.local</filename></secondary>
  </indexterm>
  <indexterm>
    <primary>rc ファイル</primary>
    <secondary><filename>rc.serial</filename></secondary>
  </indexterm>

	<para>V.32、V.32bis または V.34
	  モデムのような高速モデムを利用する場合、ハー ドウェア
	  (<filename>RTS/CTS</filename>)
	  フロー制御を行う必要があります。FreeBSD kernel のモデム
	  ポートにハードウェア フロー制御のフラグを設定するため の
	  <command>stty</command> コマンドを、FreeBSD 1.1.5.1 以降では
	  <filename>/etc/rc.serial</filename> に、FreeBSD 1.1 では
	  <filename>/etc/rc.local</filename> に 記述できます。</para>

	<para>たとえば、FreeBSD 1.1.5.1 の
	  <filename>/etc/rc.serial</filename> のサンプルは以下
	  のとおりです。</para>

	<programlisting>#!/bin/sh
#
# Serial port initial configuration

stty -f /dev/ttyid1 crtscts
stty -f /dev/cuai01 crtscts</programlisting>

	<para>この例では、<literal>termio</literal> のフラグ
	  <literal>crtscts</literal> をシリアル ポート #1
	  (<devicename>COM2:</devicename>) のダイアル
	  インおよびダイアル アウトの初期化ディバイスに
	  設定しています。</para>

	<para>古い FreeBSD 1.1 では、以下のエントリが
	  <literal>crtscts</literal> フラグを設定する ために
	  <filename>/etc/rc.local</filename>
	  に追加されていました。</para>

	<programlisting># Set serial ports to use RTS/CTS flow control
stty -f /dev/ttyd0 crtscts
stty -f /dev/ttyd1 crtscts
stty -f /dev/ttyd2 crtscts
stty -f /dev/ttyd3 crtscts</programlisting>

	<para>FreeBSD 1.1 には初期化のためのディバイス スペシャル
	  ファイルがないので、ディバイス
	  ファイルそのものにフラグを設定して、その後はフラグをクリア
	  してしまうような極悪人が現れないことを願うしかありません。
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>モデムの設定</title>

      <para>もし、あなたのモデムがパラメータを不揮発ラムに
	保存できるタイプならば、MS-DOS 上の Telix や FreeBSD 上の
	<command>tip</command> などのような通信プログラム を使って、
	パラメータを設定してください。<command>getty</command>
	が利用する初期速度でモデムに接続して、以下の条件を満たすよ
	うに不揮発ラムの設定を変更してください。</para>

      <itemizedlist>
	<listitem>
	  <para>接続時に <acronym>CD</acronym> 信号がオンになる</para>
	</listitem>

	<listitem>
	  <para>接続時に <acronym>DTR</acronym> がオンになり、
	    <abbrev>DTR</abbrev> オフで回線を切断しモ
	    デムをリセットする。</para>
	</listitem>

	<listitem>
	  <para>送信時フロー制御には <acronym>CTS</acronym> を利用。</para>
	</listitem>

	<listitem>
	  <para><acronym>XON/XOFF</acronym>
	    によるフロー制御を行わない。</para>
	</listitem>

	<listitem>
	  <para>受信時のフロー制御は <acronym>RTS</acronym> を使用。</para>
	</listitem>

	<listitem>
	  <para>Quiet mode (リザルト コードを返さない)</para>
	</listitem>

	<listitem>
	  <para>コマンド エコーを返さない。</para>
	</listitem>
      </itemizedlist>

      <para>これらを実現するためのコマンドやディップ
	スイッチの設定に関しては、モ
	デムのマニュアルを参照してください。</para>

      <para>以下に、USRobotics Sportster の 14,400 bps
	の外づけモデムの設定例を示 しておきます。</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>ことのついでに、たとえば、V42.bis や MNP5
	のデータ圧縮を使用するかど
	うかなどのモデムの他の設定について確認、
	調整しておくのもよいかもしれま せん。</para>

      <para>さらに、USRobotics Sportster の 14,400 bps
	の外づけモデムでは、以下の ようなディップ
	スイッチの設定も必要です。他のモデムをお使いの方も、以
	下の例を設定の参考にしてください。</para>

      <itemizedlist>
	<listitem>
	  <para>スイッチ1: UP &mdash; DTR 標準</para>
	</listitem>

	<listitem>
	  <para>スイッチ2: 無視 (リザルト
	    コードを単語形式にするか数値形式にす るか)</para>
	</listitem>

	<listitem>
	  <para>スイッチ3: UP &mdash; リザルト コードを返さない</para>
	</listitem>

	<listitem>
	  <para>スイッチ4: DOWN &mdash; コマンド エコーを返さない</para>
	</listitem>

	<listitem>
	  <para>スイッチ5: UP &mdash; 自動着信</para>
	</listitem>

	<listitem>
	  <para>スイッチ6: UP &mdash; CD 標準</para>
	</listitem>

	<listitem>
	  <para>スイッチ7: UP &mdash;
	    不揮発ラムからデフォルト値をロードする</para>
	</listitem>

	<listitem>
	  <para>スイッチ8: 無視 (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>リザルト コードを返さないように設定しておかないと、
	<command>getty</command> が誤っ て <prompt>login:</prompt>
	プロンプトをコマンド モードのモデムに送信してしまった場 合に、
	モデムがこの入力をエコーしたり、この入力に対するリザルト
	コード を返してしまったりすることになります。この結果として、
	モデムと  <command>getty</command>
	の間で延々と無意味なやりとりが続いたというケースを聞いたこ
	とがあります。</para>

      <sect3>
	<title>固定速度の設定</title>

	<para>固定速度の設定では、
	  モデムとコンピュータ間の通信速度をモデムとモデム間
	  の接続速度に関係なく、常に一定に保つように、
	  モデムを設定する必要があり ます。USRobotics Sportster の
	  14,400 bps 外づけモデムの場合、以下のコ マンドで、
	  モデムとコンピュータ間の速度が、コマンド送信時の速度に固定さ
	  れます。</para>

	<programlisting>ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>可変速度の設定</title>

	<para>可変速度の設定では、シリアル ポートの速度が、
	  着信速度に応じて変化する ように設定しなければいけません。
	  USRobotics Sporster の 14,400 bps 外 づけモデムの場合、
	  以下のコマンドで、エラー訂正機能を利用した通信の場合 は、
	  コマンドを送信した時の通信速度にシリアル
	  ポートの速度を固定し、エ ラー訂正機能を利用しない接続では、
	  シリアル ポートの速度が変化するよう に設定されます。</para>

	<programlisting>ATZ
AT&amp;B2&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>モデムの設定の確認</title>

	<para>ほとんどの高速モデムには、
	  現在の設定をある程度人間にも理解できる形式に
	  して表示させるコマンドがあります。USRobotics Sporster の
	  14,400 bps  外づけモデムの場合は、<command>ATI5</command>
	  コマンドで、現在の不揮発ラムの設定を 表示することができます。
	  さらに、ディップ スイッチの設定も含めた現在の
	  設定を確認するためには、<command>ATZ</command>
	  コマンドを送信してから、<command>ATI4</command>
	  コマンドを送信してください。</para>

	<para>他のメーカーのモデムをお使いの場合は、
	  モデムのマニュアルで設定値の確認
	  方法を確認してください。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>トラブルシューティング</title>

      <para>以下の手順でダイアル アップ
	モデムの動作を確認することができます。</para>

      <sect3>
	<title>FreeBSD システムの動作確認</title>

	<para>モデムを FreeBSD システムに接続し、
	  システムをブートします。あなたのモ
	  デムにモデムの状態を確認するためのインジケータがあれば、
	  <acronym>DTR</acronym> のイ
	  ンジケータの状態に注目してください。もし、
	  システムのコンソールに  <prompt>login:</prompt>
	  プロンプトが表示された時に、<acronym>DTR</acronym>
	  のインジケータが点灯 すれば、FreeBSD が適切なポートに対して
	  <command>getty</command> を起動し、モデムへ
	  の着信を待っている状態であることを意味しています。</para>

	<para>もし <acronym>DTR</acronym>
	  のインジケータが点灯しない場合は、システムのコンソールか ら
	  FreeBSD にログインして、<command>ps ax</command> を実行し、
	  FreeBSD が 適切なポー トに対して<command>getty</command>
	  プロセスを起動しようとしているのかどうか確認して ください。
	  プロセスに関する情報の中に、以下のような行が表示されるはずで
	  す。</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1</screen>

	<para>モデムにまだ着信がない状態の時に、
	  以下のように上とは異なる出力があった
	  場合、<command>getty</command> は既にモデム
	  ポートのオープンを終了したということに
	  なります。

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0</screen>

	  <command>getty</command> は、<acronym>CD</acronym>
	  (carrier detect) 信号がオンの状態になるまで、
	  ポートのオープンを完了することはできませんので、
	  この場合は接続に問題が
	  あるか、あるいはモデムの設定に問題があることが考えられます。
	</para>

	<para>もし、適切なポートをオープンしようとしている
	  <command>getty</command> が見あたらない 場合は、再度
	  <filename>/etc/ttys</filename> の内容を確認し、
	  書式などに誤りがないか 調べてみてください。また、ログ
	  ファイル <filename>/var/log/messages</filename> に
	  <command>init</command> および <command>getty</command>
	  から何か出力がないかどうかも確認してみてく ださい。
	  もし何かメッセージが記録されていたら、再度
	  <filename>/etc/ttys</filename>、
	  <filename>/etc/gettytab</filename> の二つの設定ファイルと、
	  ディバイス スペシャル  <!-- kuriyama - ? to replaceble -->
	  ファイル <filename>/dev/ttyd?</filename> を確認し、
	  記述に誤りがないか、足りないエ ントリがないか、
	  足りないディバイス スペシャルファイルがないかといった
	  点について調べてみてください。</para>
      </sect3>

      <sect3>
	<title>モデムで接続してみる</title>

	<para>実際にモデムを使って別のコンピュータから
	  接続してみてください。この時、8ビット、パリティなし、
	  1ストップ ビットで接続するようにしてください。
	  接続後すぐにプロンプトが返ってこない場合や、
	  無意味な文字列が表示される 場合は、1秒に1回くらいの割合で
	  <literal>&lt;Enter&gt;</literal> キーを押してみて ください。
	  しばらくたって、なおも <prompt>login:</prompt>
	  プロンプトが現れない場合 は、<command>BREAK</command>
	  信号を送信してみてください。この時、端末側で使って
	  いるモデムが高速モデムならば、
	  このモデムのインタフェースの接続速度を固 定してから、
	  再度ダイアル インしてみてください。(たとえば、USRobotics
	  Sportster の場合は、<command>AT&amp;B1</command>)</para>

	<para>それでもまだ <prompt>login:</prompt>
	  プロンプトが表示されない場合は、
	  <filename>/etc/gettytab</filename>
	  の以下の点について再度確認してみてください。</para>

	<itemizedlist>
	  <listitem>
	    <para><filename>/etc/ttys</filename> の対応する行の
	      2番目の項目で、<filename>/etc/gettytab</filename>
	      の中で定義されているエントリが指定されているか</para>
	  </listitem>

	  <listitem>
	    <para>各 <literal>nx=</literal> で
	      <filename>/etc/gettytab</filename>
	      の中で定義されているもの が指定されているか</para>
	  </listitem>

	  <listitem>
	    <para>各 <literal>tc=</literal> で
	      <filename>/etc/gettytab</filename>
	      の中で定義されているもの が指定されているか</para>
	  </listitem>
	</itemizedlist>

	<para>もしダイアル インしても、FreeBSD
	  システム側のモデムが応答しない場合は、FreeBSD 側のモデムが
	  <acronym>DTR</acronym>
	  がオンになった時に電話にでるように設定さ
	  れているかを確認してください。
	  もしモデムの設定に問題がなさそうならば、
	  モデムのインジケータ (がもしあれば) で、
	  <acronym>DTR</acronym> がオンになっているか
	  を確認してください。</para>

	<para>この確認のステップを数回繰り返しても
	  うまくいかない場合は、一度休憩して、
	  しばらくたってから挑戦してみましょう。それでもだめなら、
	  おそらく &a.questions;
	  にあなたのモデムについての情報と問題を書いたメールを送れ ば、
	  メーリング
	  リストのメンバーが問題の解決を助けるべく努力してくれる
	  でしょう。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>謝辞</title>

      <para>以下の方々から、
	多くのコメントやアドバイスをいただきました。ここに謝意
	を表します。</para>

      <variablelist>
	<varlistentry><term>Sean Kelly</term>
	  <listitem>
	    <para>&lt;kelly@fsl.noaa.gov&gt; 多くのすばらしい助言をいた
	      だきました</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 id="dialout">
    <title>ダイアルアウトサービス</title>
    <indexterm><primary>ダイアルアウトサービス</primary></indexterm>

    <para><emphasis>原作: FAQ からの情報</emphasis></para>

    <para><emphasis>訳: &a.jp.tmaruya;.<!-- <br> -->
	31 December 1996.</emphasis></para>

    <para>以下はモデムを利用して他のコンピュータと
      接続する方法を説明しています。
      これはリモートホストとターミナル接続を確立するための
      適切な方法です。</para>

    <para>これは BBS に接続するときによく使います。</para>

    <para>この種の接続は PPP 接続に問題がある場合、Internet
      上にあるファイルを 転送するのに非常に役に立ちます。FTP
      で何らかのファイルを転送したいのに  PPP
      接続を確立できない場合は、ファイルを FTP
      転送するためにターミナルセッション を利用します。そして ZMODEM
      を利用してファイルを転送します。</para>

    <sect2>
      <title><command>tip</command> や <command>cu</command>
	が実行できないはなぜ?</title>

      <para>あなたのシステムで <command>tip</command> や
	<command>cu</command> というプログラムは
	<username>uucp</username> や <username>dialer</username>
	というグループに所属しているユーザのみが
	実行できるようになっているのでしょう。リモートホストやモデムを
	利用できる <username>dialer</username>
	のグループにあなたのアカウントを 加えましょう。</para>

      <para>もしくは下記のコマンドを使うことによって、そのシステムで
	<command>tip</command> や <command>cu</command>
	を誰でも使えるようになります:</para>

      <screen>&prompt.root; <userinput>chmod 4511 /usr/bin/tip</userinput></screen>

      <para> このコマンドは <command>cu</command>
	に対しておこなう必要はありません、それは
	<command>cu</command> は <command>tip</command>
	に対するハードリンクだからです。</para>
    </sect2>

    <sect2>
      <title>私の Hayes モデムはサポートされていません、
	どうしよう?</title>

      <para>実際、<command>tip</command> の
	マニュアルページは古くなっています。既に Hayes
	ダイアラが組み込まれています。<filename>/etc/remote</filename>
	ファイル中で <literal>at=hayes</literal>
	を使ってください。</para>

      <para>Hayes ドライバは、最近のモデムの新しい機能である
	<literal>BUSY</literal>、<literal>NO DIALTONE</literal>、
	<literal>CONNECT 115200</literal>などのメッセージを
	認識できるほど賢くはなく、単に混乱を起こすだけです。
	<command>tip</command>を使う場合には、
	(<command>ATX0&amp;W</command> とするなどして) これらの
	メッセージを表示させないようにしなくてはいけません。</para>

      <para>また、<command>tip</command> のダイアルのタイムアウトは
	60秒です。モデムの タイムアウト設定はそれより短くすべきであり、
	そうしないと  <command>tip</command>
	は通信に問題があると判断するでしょう。
	<command>ATS7=45&amp;W</command>  を実行してください。</para>

      <para>実際、デフォルトの <command>tip</command> は Hayes
	の完全なサポートを しているわけではありません。解決方法は
	<filename>/usr/src/usr.bin/tip/tip</filename> の下の
	<filename>tipconf.h</filename>  を変更することです。
	もちろんこれにはソース配布ファイルが必要です。</para>

      <para><literal>#define HAYES 0</literal> と記述されている行を
	<literal>#define HAYES 1</literal> と変更し、そして
	<command>make</command>、<command>make install</command>
	を実行します。これでうまく動作するでしょう。</para>
    </sect2>

    <sect2 id="direct-at">
      <title>これらの AT コマンドを入力するには?</title>

      <indexterm>
        <primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para><filename>/etc/remote</filename> ファイルの中で
	<quote>direct</quote> エントリを作ります。たとえばモデムが
	1番目のシリアルポートである <filename>/dev/cuaa0</filename>
	に接続されている場合、次のようにします:</para>

      <programlisting>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</programlisting>

      <para>モデムがサポートする最大の bps レートを br
	フィールドに使います。そして <command>tip cuaa0</command>
	を実行すると、モデムが利用できるようになります。</para>

      <para><filename>/dev/cuaa0</filename>
	がシステムに存在しない場合は、次のようにします:</para>

      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV cuaa0</userinput></screen>

      <para>または root になって以下のように cu
	コマンドを実行します:</para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable>
	にはシリアルポートを指定します (例えば
	<filename>/dev/cuaa0</filename>)。そして
	<replaceable>speed</replaceable> には接続する速度を指定します
	(例えば <literal>57600</literal>)。その後 AT
	コマンドを実行したら、<command>~.</command>
	と入力すれば終了します。</para>
    </sect2>

    <sect2>
      <title>pn 機能の <literal>@</literal> 記号が使えません!</title>

      <para>電話番号 (pn) 機能の中での <literal>@</literal> 記号は、
	tip に <filename>/etc/phone</filename>
	にある電話番号を参照するように伝えます。しかし
	<literal>@</literal> の文字は <filename>/etc/remote</filename>
	のような 設定ファイルの中では特殊文字となります。
	バックスラッシュを使ってエスケープをおこないます:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2>
      <title>コマンドラインから電話番号を指定するには?</title>

      <para><quote>generic</quote> エントリと呼ばれるものを
	<filename>/etc/remote</filename> に追加します。
	例えば次のようにします:</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
	    :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600bps:\
	    :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>そして </para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>のように利用できます。
	<command>tip</command> より <command>cu</command> を使いたい場合、
	<command>cu</command> の generic エントリを使います:

	<programlisting>cu115200|Use cu to dial any number at 115200bps:\
	:dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</programlisting>

	そして</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>

      <para> と実行します。</para>
    </sect2>

    <sect2>
      <title>毎回 bps レートを入力しなければいけませんか?</title>

      <para><literal>tip1200</literal> や <literal>cu1200</literal>
	用のエントリを記述し、適切な通信速度を br
	フィールドに設定します。<command>tip</command> は 1200 bps
	が正しいデフォルト値であるとみなすので、
	<literal>tip1200</literal> エントリを参照します。もちろん 1200
	bps  を使わなければならないわけではありません。</para>
    </sect2>

    <sect2>
      <title>ターミナルサーバを経由して
	複数のホストへアクセスしたいんです。</title>

      <para>毎回接続されるのを待って
	<command>CONNECT &lt;host&gt;</command> と入力する
	かわりに、tip の <literal>cm</literal> 機能を使います。
	例えば、<filename>/etc/remote</filename>
	に次のようなエントリを追加します:

	<programlisting>pain|pain.deep13.com|Forrester's machine:\
	:cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
	:cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
	:dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

	これで、<command>tip pain</command> や
	<command>tip muffin</command> と実行すると
	pain や muffin のホストに接続することができ、
	<command>tip deep13</command>
	を実行するとターミナルサーバに接続します。</para>
    </sect2>

    <sect2>
      <title>tip を使ってそれぞれのサイトの
	複数の回線に接続できますか?</title>

      <para>これは大学に電話回線がいくつかあって
	数千人の学生が接続しようとする 場合によくある問題です。</para>

      <para>あなたの大学のエントリを <filename>/etc/remote</filename>
	ファイルに作成して、<literal>pn</literal> のフィールドには
	<literal>@</literal> を使います:</para>

      <programlisting>big-university:\
	:pn=\@:tc=dialout
dialout:\
	:dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>そして <filename>/etc/phone</filename>
	ファイルに大学の電話番号の一覧を書きます:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> は一連の電話番号を試みて、
	最終的に接続できなければあきらめます。
	リトライを続けさせたい場合は、<command>tip</command> を while
	ループに入れて 実行します。</para>
    </sect2>

    <sect2>
      <title>CTRL+P を 1回送るために 2度押す必要があるのはなぜ?</title>

      <para>CTRL+P は通常 <quote>force (強制)</quote> 文字であり、
	<command>tip</command> に次の文字が
	リテラルデータであることを伝えます。force
	文字は <quote>変数の設定</quote> を意味する
	<command>~s</command>
	エスケープによって他の文字にすることができます。</para>

      <para><command>
	  ~sforce=<replaceable>single-char</replaceable></command>
	と入力して改行します。<replaceable>single-char</replaceable>
	は、任意の 1バイト文字です。
	<replaceable>single-char</replaceable> を省略すると NUL
	文字になり、これは CTRL+2 や CTRL+SPACE
	を押しても入力できます。また、
	<replaceable>single-char</replaceable> に SHIFT+CTRL+6
	を割り当てる方法を使っているターミナルサーバもあります。</para>

      <para><filename>&#36;HOME/.tiprc</filename>
	に次のように定義することで、任意の文字を force
	文字として利用できます:</para>

      <programlisting>force=&lt;single-char&gt;</programlisting>
    </sect2>

    <sect2>
      <title>打ち込んだ文字が突然すべて大文字になりました??</title>

      <para>CTRL+A を押してしまい、caps-lock
	キーが壊れている場合のために設計された  <command>tip</command>
	の <quote>raise character</quote> モードに入ったのでしょう。
	既に述べたように <command>~s</command> を使って、
	<literal>raisechar</literal> をより適切な値に
	変更してください。もしこれら両方の機能を使用しないのであれば、
	force 文字と同じ設定にすることもできます。</para>

      <!-- kuriyama - file tiprc /file -->
      <para>以下は CTRL+2 や CTRL+A などを頻繁に使う必要のある Emacs
	ユーザにうってつけの .tiprc ファイルのサンプルです:</para>

      <programlisting>force=^^
raisechar=^^</programlisting>

      <para>^^ は SHIFT+CTRL+6 です。</para>
    </sect2>

    <sect2>
      <title><command>tip</command> でファイルを転送するには?</title>

      <para>もし他の Unix のシステムと接続しているなら、
	<command>~p</command>(put) や  <command>~t</command>(take)
	でファイルの送受信ができます。これらのコマンドは
	相手のシステムの上で <command>cat</command> や
	<command>echo</command> を実行することで 送受信をします。
	書式は以下のようになります:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">ローカルのファイル名</arg>
	<arg choice="opt">リモートのファイル名</arg>
      </cmdsynopsis>
      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">リモートのファイル名</arg>
	<arg choice="opt">ローカルのファイル名</arg>
      </cmdsynopsis>

      <para>この方法ではエラーチェックをおこないませんので、zmodem
	などの他のプロトコルを使った方がよいでしょう。</para>
    </sect2>

    <sect2>
      <title><command>tip</command> から zmodem を実行するには?</title>

      <para>ファイルを受信するには、
	リモート側で送信プログラムを起動します。そして <command>~C
	  rz</command> と入力すると、ローカル側へのファイルの受信が
	始まります。</para>

      <para>ファイルを送信するには、
	リモート側で受信プログラムを起動します。そして <command>~C sz
	  <replaceable>files</replaceable></command> と入力すると、
	リモート側への ファイルの送信が始まります。</para>
    </sect2>
  </sect1>
 
  <sect1 id="serialconsole-setup">
    <title>シリアルコンソールの設定</title>
    <indexterm><primary>シリアルコンソール</primary></indexterm>
    
    <para><emphasis>原作: &a.yokota;、&a.wpaul;</emphasis></para>
    
    <para><emphasis>この文書はほとんどが &a.wpaul; 氏の
	<filename>/sys/i386/boot/biosboot/README.serial</filename>
	に基づいています。</emphasis></para>
  
    <sect2 id="serialconsole-intro">
      <title>導入</title>
      
      <para>FreeBSD/i386 オペレーティングシステムは、コンソールとして
	シリアルポート上のダム端末しか持たないシステムでも起動できます。
	この様な構成はきっと次のような二種類の人達に便利でしょう。それは、
	キーボードやモニタのないマシンに
	FreeBSD をインストールしたいシステム管理者と、
	カーネルやデバイスドライバをデバッグしたい開発者です。</para>
  
      <para>バージョン 3.1 から、FreeBSD/i386 は 3 ステージ構成のブートストラップ
	を用いるようになりました。最初の 2 つのステージは、
        ブートディスクにある FreeBSD スライスの最初に格納されている、
        ブートブロックのコードが行います。
	それからブートブロックは、第 3 ステージのコードとしてブートローダ
	(<filename>/boot/loader</filename>) を読み込み、実行します。
	(ブートプロセスの詳細については &man.boot.8; と &man.loader.8;
	をご覧下さい。)</para>
  
      <para>シリアルコンソールを設定するためには、ブートブロックコード、
	ブートローダコード、カーネルを設定する必要があります。</para>
      
      <para>FreeBSD バージョン 3.0 では、ブートローダはないので
	ブートストラップは 2 ステージです。つまり、ブートブロックが直接
	カーネルをメモリに読み込みます。もしあなたが FreeBSD 3.0 を使って
	いるなら、このセクションでブートローダについて述べている部分は無視してください。
	それでもシリアルポートをコンソールとして使うのに支障はありません。</para>
  
      <para>FreeBSD バージョン 2.X と 3.X のシリアルポートドライバ
	&man.sio.4 は全く違いますので、設定も異なった方法で行う必要があります。
	この章ではバージョン 2.X システム用の設定については扱っていません。
	もしあなたが古いバージョンの FreeBSD を使っているなら、かわりに
	<filename>/sys/i386/boot/biosboot/README.serial</filename>
	を調べてみてください。</para>
    </sect2>
    
    <sect2 id="serialconsole-howto">
      <title>シリアルコンソールを設定するための 6 ステップ</title>
  
      <procedure>
	<step>
	  <para>シリアルケーブルを用意してください。</para>
	  
    <indexterm><primary>ヌルモデムケーブル</primary></indexterm>
	  <para>ヌルモデムケーブル、
            もしくは標準シリアルケーブルとヌルモデムアダプタが必要となります。
            シリアルケーブルについては <xref linkend="term"> をご覧下さい。</para>
	</step>
	
	<step>
	  <para>キーボードをはずして下さい。</para>
	  
	  <para>たいていの PC システムは Power-On Self-Test (POST)
	    の間にキーボードを検出し、もし見つからなければエラーと
	    なります。また、キーボードがないことを大きな音で知らせ、
	    キーボードが接続されるまでは起動を中断するようなマシンもあります。</para>

	  <para>コンピュータがエラーを表示していても、
	    とにかく起動するなら特別な対応は必要ありません
	    (Phoenix BIOS を搭載しているマシンには、
	    <errorname>Keyboard failed</errorname>
            と表示されても、正常に起動するものがあります)。</para>
	  
	  <para>あなたのコンピュータがキーボードを接続していない状態で
	    起動しないようなら、(もし可能ならば) エラーを無視するように
	    BIOS を設定する必要があります。設定方法の詳細については、
	    マザーボードのマニュアルを調べてください。</para>
	  
	  <tip>
	    <para>BIOS の設定でキーボードを <quote>Not installed</quote>
	      にするということは、キーボードを使えないということを
	      意味しているわけでは<emphasis>ありません</emphasis>。これは、BIOS
	      がキーボードがなくても文句を言わないように、電源投入時には
	      キーボードを探すな、と指示するだけです。このフラグを
	      <quote>Not installed</quote> にしていてもキーボードを
	      接続したままにできますし、ちゃんと動作します。</para>
	  </tip>
	  
	  <note>
	    <para>あなたのシステムが PS/2 マウスを使っているなら、
	      おそらくマウスもキーボード同様にはずす必要があるでしょう。
	      というのは、PS/2 マウスは部分的にキーボードとハードウェアを
	      共有しており、マウスを接続したままにしていると、
              キーボードも存在する、と誤って検出してしまう可能性があるからです。
	      AMI BIOS を持つ Gateway 2000 Pentium 90MHz システム
	      はこれに該当すると言われています。
	      一般的にこれは問題ではありません。なぜなら、どっちにしても
	      マウスはキーボードなしではたいして役に立たないからです。</para>
	  </note>
	</step>
	
	<step>
	  <para><devicename>COM1:</devicename> (<devicename>sio0</devicename>)
	    にダム端末を接続してください。</para>
	  
	  <para>ダム端末がなければ、かわりに古い PC/XT でモデム
	    プログラムを走らせて使ったり、シリアルボートに他の Unix
	    マシンを繋いだりできます。もしも <devicename>COM1:</devicename>
	    (<devicename>sio0</devicename>) がなければ、作成してください。
	    今のところ、<devicename>COM1:</devicename> 以外のポートを
	    選択するためにはブートブロックの再コンパイルが必要です。
	    すでに <devicename>COM1:</devicename> を他の装置に
	    使っていた場合は、一時的にその装置をはずして
	    いったん FreeBSD がうまく動作してから、
	    新しいブートブロックとカーネルをインストールしてください。
	    (上記はとにかくファイル/演算/端末サーバの
	    <devicename>COM1:</devicename> が利用可能であると仮定して
	    います。あなたが本当に何かのために
	    <devicename>COM1:</devicename> が必要 (で、なおかつその何かを
	    <devicename>COM2:</devicename> (<devicename>sio1</devicename>)
	    に付け替えることができない) ならば、多分、そもそも
	    悩んでる場合ではありません。)</para>
	</step>
    
	<step>
	  <para>カーネルコンフィグファイルの <devicename>COM1:</devicename>
	    (<devicename>sio0</devicename>) に適切なフラグを
	    設定していることを確認してください。</para>
	  
	  <para>関連するフラグ:</para>
	  
	  <variablelist>
	    <varlistentry>
	      <term><literal>0x10</literal></term>
	      
	      <listitem>
		<para>このポートのコンソールサポートを有効にします。
		  このフラグが設定されない場合、他のフラグは無視されます。
		  現在のところ、一つのポートしかコンソールサポートを有効に
		  できません。(config ファイルに書かれた順番で) 最初にこのフラグを
		  指定されたポートが選択されます。
		  なお、このオプションを指定するだけでシリアルポートが
		  コンソールとして使えるわけではありません。
		  このフラグと一緒に、以下のフラグも指定するかもしくは
		  <option>-h</option> オプションも使ってください。</para>
	      </listitem>
	    </varlistentry>
	    
	    <varlistentry>
	      <term><literal>0x20</literal></term>
	      
	      <listitem>
		<para>後述される <option>-h</option> オプション
		  を無視して、(他に優先度の高いコンソールがない限り)
                  このポートをコンソールとして指定します。
		  このフラグは FreeBSD バージョン 2.X の
		  <literal>COMCONSOLE</literal> オプションに対応するものです。
		  フラグ <literal>0x20</literal> は必ず
		  フラグ <option>0x10</option> と一緒に指定されなければなりません。</para>
	      </listitem>
	    </varlistentry>
	    
	    <varlistentry>
	      <term><literal>0x40</literal></term>
	      
	      <listitem>
		<para>(<literal>0x10</literal> と組み合わせることで)
		  このポートを予約し、通常のアクセスができない
		  ようにします。
		  このフラグは、シリアルコンソールとして使いたいポートに
		  指定すべきではありません。
		  唯一の使い道は、ユニットがカーネルのリモートデバッグ用
		  であることを指定することです。
		  リモートデバッグの詳細については
                  <ulink url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/">The
		  Developer's Handbook</ulink> を参照してください。</para>
		
		<note>
		  <para>FreeBSD 4.0-CURRENT 以降では、
		    フラグ <literal>0x40</literal> の意味が若干異なり、
		    シリアルポートにリモートデバッグを指定するためには、
		    別のフラグを使います。</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  
	  <para>例:</para>
	  
	  <programlisting>device sio0 at isa? port "IO_COM1" tty flags 0x10 irq 4</programlisting>
      
	  <para>詳細については &man.sio.4; を参照して下さい。</para>
	  
	  <para>もしこれらのフラグがセットされていなければ、(別のコンソールで)
	    UserConfig を実行するか、
            カーネルを再コンパイルする必要があります。</para>
	</step>
	
	<step>
	  <para>ブートドライブの <literal>a</literal> パーティションの
	    ルートディレクトリに <filename>boot.config</filename>
	    を作成してください。</para>
	  
	  <para>このファイルは、ブートブロックコードに対してどのように
	    システムを起動したいかを教えます。
	    シリアルコンソールを活かすためには、以下のオプションを幾つか
	    dash; 複数の場合も一行で、設定する必要があります:</para>
	  
	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>
	      
	      <listitem>
		<para>内蔵コンソールとシリアルコンソールの切替えを行います。
		  これを使用してコンソールデバイスを変更できます。
		  例えば、内蔵 (ビデオ) コンソールからブートした場合、
		  カーネルとブートローダがコンソールデバイスとして
		  シリアルポートを使用するようにするため、
		  <option>-h</option> を使って指示できます。
		  反対に、シリアルポートからブートした場合、
		  ブートローダとカーネルがコンソールとして代わりに
		  ビデオディスプレイを使用するようにするため、
		  <option>-h</option> を使用できます。</para>
	      </listitem>
	    </varlistentry>
	    
	    <varlistentry>
	      <term><option>-D</option></term>
	      
	      <listitem>
		<para>シングルとデュアルのコンソール設定を切り替えます。
		  シングル設定では、上記の <option>-h</option>
		  オプションの状態によって、コンソールは内蔵コンソール
		  (ビデオディスプレイ)かシリアルポートのいずれかになります。
		  デュアルコンソール設定では、ビデオディスプレイと
		  シリアルポートの両方が、<option>-h</option>
		  オプションの状態によらず、同時にコンソールになります。
		  しかし、デュアルコンソール設定は、ブートブロックが
		  実行されている間でしか効果を持ちません。
		  一旦ブートローダに制御が移ると、<option>-h</option>
		  オプションによって指定されたコンソールが
		  唯一のコンソールになります。</para>
	      </listitem>
	    </varlistentry>
	    
	    <varlistentry>
	      <term><option>-P</option></term>
	      
	      <listitem>
		<para>ブートブロックがキーボードを検出するようにします。
		  キーボードが発見できなかった場合には、
		  <option>-D</option> と <option>-h</option> 
                  オプションが自動的にセットされます。</para>
		
		<note>
		  <para>現バージョンのブートブロックでは容量の制限により、
		    <option>-P</option> オプションは拡張キーボードしか
		    検出できません。キーが 101 個より少ない (そして F11
		    と F12 がない) キーボードは検出されない可能性があります。
		    この制限から、いくつかのラップトップコンピュータの
		    キーボードは正しく検出されないでしょう。
		    残念ながら、この問題の回避策はありません。</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>
      
	  <para><option>-P</option> オプションを使ってコンソールを
	    自動的に選ぶか、<option>-h</option> オプションを使って
	    シリアルコンソールを有効にしてください。</para>
      
	  <para>さらに &man.boot.8; で説明されている他のオプションも使う
	    ことができます。</para>
      
	  <para><option>-P</option> 以外のオプションはブートローダ
	    (<filename>/boot/loader</filename>) に渡されます。
	    ブートローダは、<option>-h</option> オプションだけの状態を
	    調べることで内蔵ビデオとシリアルポートのどちらがコンソールに
	    なるのか決めます。
	    つまり、<filename>/boot.config</filename> の中で
	    <option>-D</option> オプションを指定して
	    <option>-h</option> オプションを指定しなかった場合、
	    ブートブロック実行中でのみシリアルポートをコンソールとして
	    使うことができます。ブートローダは内蔵ビデオディスプレイを
	    コンソールとして使います。</para>
	</step>
	
	<step>
	  <para>マシンを起動する。</para>
	  
	  <para>FreeBSD を起動したとき、ブートブロックは
	    <filename>/boot.config</filename> の内容をコンソールに表示
	    します。例えば、</para>
    
	  <screen>/boot.config: -P
Keyboard: no</screen>
    
	  <para>行の二番目は、
            <filename>/boot.config</filename> にオプション
            <option>-P</option> が指定してあるときだけ表示され、
            キーボードが存在するかどうかを表します。
            これらのメッセージは、シリアルか内蔵のいずれか、
            あるいはその両方のコンソールに表示されます。
            どちらに表示されるかは、
            <filename>/boot.config</filename> の設定によって変わります。</para>
    
	  <informaltable frame="none">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>オプション指定</entry>
		  <entry>メッセージの表示される場所</entry>
		</row>
	      </thead>
	      
	      <tbody>
		<row>
		  <entry>なし</entry>
		  <entry>内蔵</entry>
		</row>
		
		<row>
		  <entry><option>-h</option></entry>
		  <entry>シリアル</entry>
		</row>
		
		<row>
		  <entry><option>-D</option></entry>
		  <entry>シリアルと内蔵の両方</entry>
		</row>
		
		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>シリアルと内蔵の両方</entry>
		</row>
		
		<row>
		  <entry><option>-P</option>、キーボードが存在する場合</entry>
		  <entry>内蔵</entry>
		</row>
		
		<row>
		  <entry><option>-P</option>、キーボードが存在しない場合</entry>
		  <entry>シリアル</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>
	  
	  <para>このメッセージが表示された後、
            ブートブロックがブートローダのロードを再開し、
            他の全てのメッセージがコンソールに表示されるまで、
            若干時間がかかります。通常の環境では、ブートブロックに
            割り込みをかける必要はありませんが、
            ちゃんとセットアップされているかどうか確かめるために、
            割り込みをかけることができるようになっています。</para>
    
	  <para>ブートプロセスに割り込みをかけるには、
            コンソールの(Enter/Return キー以外の)キーをたたいて下さい。
            ブートブロックはその時、操作を指定するためのプロンプトを表示します。
            こんな風に表示されるでしょう。
          </para>
    
	  <screen>>> FreeBSD/i386 BOOT
Default: 0:wd(0,a)/boot/loader
boot:</screen>
    
	  <para>上に示したメッセージが、シリアルか内蔵、
            あるいはその両方といった、<filename>/boot.config</filename>
            で指定したとおりのコンソールに表示されることを確認して下さい。
            メッセージが正しいコンソールに表示されたら、Enter/Return
            キーを押してブートプロセスを継続してください。
          </para>
	  
	  <para>もし、シリアルコンソールを利用するように設定しているのに
            シリアル端末にプロンプトが出てこない場合は、
            設定のどこかに間違いがあります。
            ブートブロック(とブートローダ、カーネル)に対して
            シリアルポートをコンソールに使うことを伝えるため、
            割り込みをかけた時に <option>-h</option> を入力し、
            (可能ならば) Enter/Return キーを押して下さい。そして、
            一度システムを起動させてから、どこが悪いのかをチェックして下さい。</para>
	</step>
      </procedure>
      
      <para>ブートローダがロードされ、ブートプロセスの第三ステージに
      いる時には、まだ内蔵コンソールとシリアルコンソールを切り替えることができます。
      それにはブートローダの環境変数を適切に設定すれは良いのですが、
      詳細については <xref linkend="serialconsole-loader"> を参照してください。</para>
    </sect2>
  
  <sect2 id="serialconsole-summary">
    <title>まとめ</title>
    
      <para>このセクションで扱ったさまざまな設定と、
        最終的に選択されるコンソールに関するまとめです。</para>
      
      <sect3>
	<title>Case 1: sio0 の flags に 0x10 をセットした場合</title>
	
	<programlisting>device sio0 at isa? port "IO_COM1" tty flags 0x10 irq 4</programlisting>
	
	<informaltable frame="none">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry>/boot.config 内のオプション</entry>
		<entry>ブートブロック実行中のコンソール</entry>
		<entry>ブートローダ実行中のコンソール</entry>
		<entry>カーネルのコンソール</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry>なし</entry>
		<entry>内蔵</entry>
		<entry>内蔵</entry>
		<entry>内蔵</entry>
	      </row>
	      
	      <row>
		<entry><option>-h</option></entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
	      </row>
	      
	      <row>
		<entry><option>-D</option></entry>
		<entry>内蔵、シリアルの両方</entry>
		<entry>内蔵</entry>
		<entry>内蔵</entry>
	      </row>
	      
	      <row>
		<entry><option>-Dh</option></entry>
		<entry>内蔵、シリアルの両方</entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
	      </row>
	      
	      <row>
		<entry><option>-P</option>、キーボードが存在する場合</entry>
		<entry>内蔵</entry>
		<entry>内蔵</entry>
		<entry>内蔵</entry>
	      </row>
	      
	      <row>
		<entry><option>-P</option>、キーボードが存在しない場合</entry>
		<entry>内蔵、シリアルの両方</entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
      
      <sect3>
	<title>Case 2:  sio0 の flags に 0x30 をセットした場合</title>
	
	<programlisting>device sio0 at isa? port "IO_COM1" tty flags 0x30 irq 4</programlisting>
  
	<informaltable frame="none">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry>/boot.config 内のオプション</entry>
		<entry>ブートブロック実行中のコンソール</entry>
		<entry>ブートローダ実行中のコンソール</entry>
		<entry>カーネルのコンソール</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry>なし</entry>
		<entry>内蔵</entry>
		<entry>内蔵</entry>
		<entry>シリアル</entry>
	      </row>
	      
	      <row>
		<entry><option>-h</option></entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
	      </row>
	      
	      <row>
		<entry><option>-D</option></entry>
		<entry>内蔵、シリアルの両方</entry>
		<entry>内蔵</entry>
		<entry>シリアル</entry>
	      </row>
	      
	      <row>
		<entry><option>-Dh</option></entry>
		<entry>内蔵、シリアルの両方</entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
	      </row>
	      
	      <row>
		<entry><option>-P</option>、キーボートが存在する場合</entry>
		<entry>内蔵</entry>
		<entry>内蔵</entry>
		<entry>シリアル</entry>
	      </row>
	      
	      <row>
		<entry><option>-P</option>、キーボードが存在しない場合</entry>
		<entry>内蔵、シリアルの両方</entry>
		<entry>シリアル</entry>
		<entry>シリアル</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>
    
    <sect2 id="serialconsole-tips">
      <title>シリアルコンソールを利用する上で役に立つ情報</title>
  
      <sect3>
	<title>シリアルポートの通信速度をもっと速いものに設定するには</title>
	
	<para>デフォルトのシリアルポート通信速度は、9600 ボー、
          8 ビット、パリティなし、ストップビット 1 です。
          通信速度を変更したい場合には、少なくとも
          ブートブロックの再コンパイルが必要になります。
          <filename>/etc/make.conf</filename> に次のような行を追加して、
          新しくブートブロックをコンパイルして下さい。</para>
	
	<programlisting>BOOT_COMCONSOLE_SPEED=19200</programlisting>
  
	<para>もし、シリアルコンソールがブート時の <option>-h</option>
          オプション以外の方法で設定されていたり、
          カーネルが利用するシリアルコンソールが
          ブートブロック実行中のものと異なる場合には、
          カーネルコンフィグレーションファイルに次のオプションを追加して、
          新しくカーネルをコンパイルしなければなりません。</para>
  
	<programlisting>options CONSPEED=19200</programlisting>
      </sect3>
      
      <sect3 id="serialconsole-com2">
	<title><devicename>sio0</devicename> 以外のシリアルポートを
          コンソールとして使うには</title>
	
	<para><devicename>sio0</devicename>
          以外のポートをコンソールとして使うには、再コンパイルが必要です。
          それがどんな理由であれ、他のポートを使用する場合には
          ブートブロック、ブートローダ、カーネルを
          次のようにして再コンパイルして下さい。</para>
  
	<procedure>
	  <step>
	    <para>カーネルソースを取得する。</para>
	  </step>
	  
	  <step>
	    <para><filename>/etc/make.conf</filename> を編集し、
	      <literal>BOOT_COMCONSOLE_PORT</literal> に
              使用したいポートのアドレス(0x3F8、0x2F8、0x3E8 or 0x2E8)を
              設定してください。使用可能なのは
              <devicename>sio0</devicename> から
	      <devicename>sio3</devicename> (<devicename>COM1:</devicename>
	      から <devicename>COM4:</devicename>) までで、
              マルチポートシリアルカードは使えません。
              また、ここで割り込みの設定をする必要はありません。</para>
	  </step>
	  
	  <step>
	    <para>設定を変更するために新たなカーネルコンフィグレーションファイルを作成し、
              使いたいシリアルポートのフラグを適切に設定します。
              例えば、<devicename>sio1</devicename>
	      (<devicename>COM2:</devicename>) をコンソールにしたければ、</para>
  
	    <programlisting>device sio1 at isa? port "IO_COM2" tty flags 0x10 irq 3</programlisting>
  
	    <para>または、</para>
	    
	    <programlisting>device sio1 at isa? port "IO_COM2" tty flags 0x30 irq 3</programlisting>
  
	    <para>とします。その際、
            他のシリアルポートにコンソールフラグをつけてはいけません。</para>
	  </step>
	  
	  <step>
	    <para>ブートブロックを再コンパイルし、インストールする。</para>
	    
	    <screen>&prompt.root; <userinput>cd /sys/boot/i386/boot2</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </step>
	  
	  <step>
	    <para>ブートローダを再コンパイルし、インストールする。</para>
	    
	    <screen>&prompt.root; <userinput>cd /sys/boot/i386/loader</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
        </step>
	  
	  <step>
	    <para>カーネルを再構築し、インストールする。</para>
	  </step>
	  
	  <step>
	    <para>&man.disklabel.8;
              を使ってブートブロックをブートディスクに書き込み、
              新しいカーネルから起動する。</para>
	  </step>
	</procedure>
      </sect3>
      
      <sect3>
	<title>シリアルポートから DDB デバッガを起動するには</title>
	
	<para>シリアルコンソールからカーネルデバッガを起動したい(これは
          リモートで診断する際に便利ですが、もしおかしな BREAK
          信号がシリアルポートに送られるような場合には危険です!)
          場合には、次のオプションを使ってカーネルをコンパイルして下さい。
        </para>
  
	<programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>
      
      <sect3>
	<title>シリアルコンソールにログインプロンプトを表示させるには</title>
	
	<para>シリアルコンソールからブートメッセージを確認したり、
          シリアルコンソールを経由してカーネルデバッグセッションに入ることが
          できるので、これは必要がないかもしれませんが、
          <emphasis>login</emphasis> プロンプトをシリアルポートに
          出力するように設定することもできます。
          これには、次のようにします。</para>
  
	<para>エディタで <filename>/etc/ttys</filename> というファイルを開き、
          次に示す行に移動して下さい。</para>
  
      <programlisting>ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>
  
	<para><literal>ttyd0</literal> から
          <literal>ttyd3</literal> は、
          <devicename>COM1</devicename> から
	  <devicename>COM4</devicename> に対応しています。
          設定したいポートの <literal>off</literal> を
	  <literal>on</literal> に変更して下さい。
          また、もしシリアルポートの通信速度を変更しているなら、
          <literal>std.9600</literal> が実際の通信速度になるように、
          例えば <literal>std.19200</literal> のように変更して下さい。</para>
  
	<para>さらに、実際のシリアル端末に合わせて、
          端末タイプを <literal>unknown</literal> から変更することも可能です。
        </para>

	<para>ファイルの編集が終了したら、
          変更を有効化するために <command>kill -HUP 1</command>
          を実行しなければなりません。</para>
      </sect3>
    </sect2>
  
    <sect2 id="serialconsole-loader">
      <title>ブートローダからコンソールを変更するには</title>
      
      <para>前セクションは、ブートブロックの設定を変更することでシリアルコンソールを
        セットアップする方法について解説していました。
        このセクションでは、ブートローダへのコマンド入力と環境変数設定で
        コンソールの指定を行なう方法を紹介します。
        ブートローダがブートブロックの後、
        ブートプロセスの第三ステージとして呼び出されたとき、
        ブートローダの設定には、ブートブロックの設定がそのまま使われます。
        </para>
      
      <sect3>
	<title>シリアルコンソールをセットアップする</title>
	
	<para>ブートローダとカーネルに対して
          シリアルコンソールを使用するように設定するには、
          単に <filename>/boot/loader.rc</filename>
          のファイルに、次のような一行を書くだけで実現できます。</para>
  
	<programlisting>set console=comconsole</programlisting>
  
	<para>これは、前セクションで扱ったブートブロックの設定に
          全く関係なく機能します。</para>
  
	<para>上に示した行は、
	  <filename>/boot/loader.rc</filename>
          の最初の行に書き込まなくてはいけません。
          これはできるだけ早く、ブートメッセージをシリアルコンソールに
          出力させるために必要なことです。</para>
  
	<para>同様にして、次のように内蔵コンソールを指定することもできます。</para>
	
	<programlisting>set console=vidconsole</programlisting>
  
	<para>もし、ブートローダの環境変数
	  <envar>console</envar> が設定されていない場合、
          ブートローダ、そしてその次に起動するカーネルは
          ブートブロックで指定された <option>-h</option> オプションに
          示されたコンソールを使用します。
          </para>
  
	<para>3.2 以降のバージョンにおいては
	  <filename>/boot/loader.rc</filename> ではなく、
	  <filename>/boot/loader.conf.local</filename> や
	  <filename>/boot/loader.conf</filename>
          にコンソール指定を書き込みます。
          その場合、
	  <filename>/boot/loader.rc</filename>
          は次のようになっていなければなりません。
          </para>
  
	<programlisting>include /boot/loader.4th
start</programlisting>
  
	<para>それから、<filename>/boot/loader.conf.local</filename>
          を作成して、次の行をそこに追加して下さい。
        </para>
  
	<programlisting>console=comconsole</programlisting>
  
	<para>か、もしくは</para>
	
	<programlisting>console=vidconsole</programlisting>
  
	<para>です。詳細については、&man.loader.conf.5; を参照して下さい。</para>
	
	<note>
	  <para>その際、ブートローダはオプション指定なし
          (ブートブロックに <option>-P</option> オプションが指定されたのと等価)になり、
          キーボードの存在を調べて
          内蔵コンソールとシリアルコンソールを自動的に選択する機能は働きません。</para>
	</note>
      </sect3>
  
      <sect3>
	<title><devicename>sio0</devicename> 以外のシリアルポートを
          コンソールとして使うには</title>
	
	<para><devicename>sio0</devicename> 以外のシリアルポートを
          コンソールとして使うには、ブートローダを再コンパイルする必要があります。
          それには、
          <xref linkend="serialconsole-com2"> に書かれている説明にしたがって下さい。</para>
      </sect3>
    </sect2>
    
    <sect2 id="serialconsole-caveats">
      <title>注意</title>
      
      <para>シリアルコンソールというアイデアは、
        グラフィック出力用のハードウェアやキーボードが接続されていない
        専用サーバのセットアップを可能にするためのものです。
        (ほとんど?)全てのシステムはキーボードなしで起動できますが、
        不幸にも、グラフィックアダプタなしでは起動できないシステムはたくさんあります。
        AMI BIOS を採用しているマシンでは、CMOS 設定の
        `graphics adapter' を `Not Installed'
        にするだけで、
        グラフィックアダプタがなくとも起動できるように設定することができます。</para>
  
      <para>しかしながら、多くのマシンはこのようなオプションを持っていませんし、
        ディスプレイハードウェアがシステムに存在しないと起動しないように
        なっています。そのようなマシンでは、
        モニタを接続する必要がなかったとしても、
        適当なグラフィックカード(モノクロのジャンク品でも構いません)を
        挿入したままにしておく必要があるでしょう。
        また、AMI BIOS をインストールする、という手もあります。</para>
    </sect2>
  </sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
