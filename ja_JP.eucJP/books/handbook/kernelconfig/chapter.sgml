<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r39097
     $FreeBSD$
-->

<chapter id="kernelconfig">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>改訂および再構成: </contrib>
	<!-- Mar 2000 -->
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jake</firstname>
	<surname>Hamby</surname>
	<contrib>原作: </contrib>
	<!-- 6 Oct 1995 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>FreeBSD カーネルのコンフィグレーション</title>

  <sect1 id="kernelconfig-synopsis">
    <title>この章では</title>

    <!--
    <para><emphasis>訳: &a.jp.tomo;、&a.jp.yoshiaki; 1996 年 11 月 2 日</emphasis></para>
    -->
    <indexterm>
      <primary>カーネル</primary>
      <secondary>カスタムカーネルの構築</secondary>
    </indexterm>

    <para>カーネルは &os; オペレーティングシステムの中核をなすものです。
      カーネルは、メモリ管理、セキュリティ制御の強制、ネットワーク、
      ディスクアクセスなどを担っています。
      &os; はどんどん動的に構成することができるようになっていますが、
      まだ、時にはカーネルコンフィグレーションをやり直して、
      再構築する必要があります。</para>

    <para>この章では、以下のことを扱っています。</para>

    <itemizedlist>
      <listitem>
	<para>なぜカスタムカーネルの構築が必要になることがあるのか。</para>
      </listitem>

      <listitem>
	<para>コンフィグレーションファイルの書き方や、
	  既存のコンフィグレーションファイルの置き換え。</para>
      </listitem>

      <listitem>
	<para>カーネルコンフィグレーションファイルから新しいカーネルを構築する方法。</para>
      </listitem>

      <listitem>
	<para>新しいカーネルのインストール方法。</para>
      </listitem>

      <listitem>
	<para>うまく行かないときの問題解決法。</para>
      </listitem>
    </itemizedlist>

    <para>この章で表示されているコマンドは、
      <username>root</username> 権限で実行する必要があります。</para>
  </sect1>

  <sect1 id="kernelconfig-custom-kernel">
    <title>なぜカスタムカーネルを作るか?</title>

    <para>伝統的に、&os; のカーネルは <quote>モノリシック</quote>
      (monolithic) カーネルと呼ばれるものでした。
      これは、カーネルが単一の巨大なプログラムで、
      扱えるデバイスは固定されていて、
      カーネルの振る舞いを変えたければ新しいカーネルを構築して、
      コンピュータを再起動して新しいカーネルを動かさなれければならなかったということです。</para>

    <para>今日では &os; は、
      カーネルのかなりの機能が必要に応じて動的にカーネルに組み込んだり外したりできるモジュールにおかれているモデルへと、
      急速に移行しています。こうしてカーネルは
      (ノート PC の PCMCIA カードのように)
      突如使えるようになったハードウェアに対応したり、
      カーネルが作成された時点では必要なかった新たな機能を取り入れられるようになります。
      このようなカーネルは、モジュラ (modular)
      カーネルと呼ばれます。</para>

    <para>しかしながら、いまだにいくらかは静的にカーネルを構成する必要があります。
      ある場合においては、機能がカーネルとあまりに密接に結びついているため、
      動的に組み込むことができません。ほかには、
      単に誰もその機能に対する組み込み可能なカーネルモジュールを書く時間をとっていないだけということもあります。</para>

    <para>システムに合わせたカーネルの構築は、高度な知識を持つ
      BSD ユーザが避けて通ることのできない最も重要な通過儀礼の 1 つです。
      この作業は、多くの時間を必要としますが、あなたの &os;
      システムに多くの利益をもたらします。
      広範囲のハードウェアをサポートしなければならない
      <filename>GENERIC</filename> カーネルとは異なり、
      システムに合わせたカーネルは
      <emphasis>あなたの</emphasis> PC
      のハードウェアのみをサポートします。これは、
      次にあげるような利益をもたらします。</para>

    <itemizedlist>
      <listitem>
	<para>素早く起動します。
	  カーネルはあなたのシステム上にあるハードウェアしか検出を行わないので、
	  あなたのシステムの起動にかかる時間を劇的に短くできます。
	</para>
      </listitem>

      <listitem>
	<para>メモリの消費量を減らすことができます。
	  システムに合わせたカーネルは、
	  使用しない機能やデバイスドライバを含まないので、
	  大抵 <filename>GENERIC</filename>
	  カーネルより少ないメモリしか消費しません。
	  カーネルコードは常に物理メモリ上に存在し、
	  アプリケーションはその容量分のメモリを使用できないので、
	  これは重要なことです。
	  したがって、メモリが少ないシステムでは、
	  カーネルの再構築は大変重要です。</para>
      </listitem>

      <listitem>
	<para>追加のハードウェアをサポートします。
	  システムに合わせたカーネルは、サウンドカードなど
	  <filename>GENERIC</filename>
	  カーネルに存在しないデバイスのサポートを追加することができます。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="kernelconfig-devices">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>システムのハードウェアについて知る</title>
    
    <para>カーネルコンフィグレーションの冒険を始める前に、
      コンピュータのハードウェア一覧を作成すると良いでしょう。
      もし、&os; 以外のオペレーティングシステムがすでにインストールされているのであれば、
      現在インストールされているオペレーティングシステムの設定を調べることで、
      簡単に一覧を作成できます。
      たとえば、&microsoft; の
      <application>デバイスマネージャ</application>
      は、インストールされているデバイスに関する重要な情報を持っています。
      <application>デバイスマネージャ</application> は、
      コントロールパネルから開くことが出来ます。</para>

    <note>
      <para>&microsoft.windows; のバージョンによっては、
	<application>デバイスマネージャ</application>
	にアクセス可能なウィンドウを表示する
	<application>システム</application> アイコンがあります。</para>
    </note>

    <para>もし他のオペレーティングシステムがコンピュータにインストールされていないのであれば、
      管理者はこれらの情報を手動で収集する必要があります。
      情報を集める方法のひとつが、&man.dmesg.8; ユーティリティと
      &man.man.1; コマンドを用いる方法です。
      &os; のほとんどのデバイスドライバにはマニュアルページが用意され、
      対応しているハードウェアの一覧を提供しています。
      また、起動時には検出されたハードウェアの一覧が表示されます。
      たとえば、以下の行は、<devicename>psm</devicename>
      ドライバがマウスを検出したことを示しています。</para>

    <programlisting>psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: [GIANT-LOCKED]
psm0: [ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</programlisting>

    <para>このドライバがカスタムカーネルコンフィグレーションファイルに含まれている、
      もしくは &man.loader.conf.5; によって読み込まれる必要があります。</para>

    <para>場合によっては、<command>dmesg</command> が起動時の検出結果ではなく、
      システムメッセージだけを表示することがあります。
      このような場合には、<filename>/var/run/dmesg.boot</filename>
      ファイルで出力を確認できます。</para>

    <para>ハードウェアを見つけるためのもうひとつの方法は、
      より冗長な出力を行う &man.pciconf.8; ユーティリティを用いる方法です。
      たとえば、以下のようになります。</para>

    <programlisting>ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
    vendor     = 'Atheros Communications Inc.'
    device     = 'AR5212 Atheros AR5212 802.11abg wireless'
    class      = network
    subclass   = ethernet</programlisting>

    <para>この出力は <command>pciconf <option>-lv</option></command>
      を用いて得られ、
      <devicename>ath</devicename>
      ドライバがワイヤレスイーサネットデバイスにあることを示しています。
      <command>man <replaceable>ath</replaceable></command> を実行すると
      &man.ath.4; のマニュアルページが表示されます。</para>

    <para>&man.man.1; を <option>-k</option> フラグで実行すると、
      有用な情報を得ることができます。上のケースでは以下のようになります。</para>

    <screen>&prompt.root; man -k <replaceable>Atheros</replaceable></screen>

    <para>ある特定の単語を含むマニュアルページの一覧が表示されます。</para>

    <programlisting>ath(4)                   - Atheros IEEE 802.11 wireless network driver
ath_hal(4)               - Atheros Hardware Access Layer (HAL)</programlisting>

    <para>ハードウェアの一覧を作っておくと、
      カスタムカーネルを構築する過程であわてずにすむでしょう。</para>
  </sect1>

  <sect1 id="kernelconfig-modules">
    <title>カーネルドライバ、サブシステムとモジュール</title>
    <indexterm>
      <primary>カーネル</primary>
      <secondary>ドライバ / モジュール / サブシステム</secondary>
    </indexterm>

    <para>カスタムカーネルを構築する前に、再構築する理由を考えてください。
      ある特定のハードウェアに対応することが目的であれば、
      そのハードウェアに対応するためのモジュールがすでに用意されている場合には再構築の必要はありません。</para>

    <para>カーネルモジュールは、
      <filename class="directory">/boot/kernel</filename>
      ディレクトリにあります。&man.kldload.8; によって、
      すでに実行中のカーネルに動的に読み込まれているモジュールもあるかもしれません。
      すべてというわけではありませんが、ほとんどのカーネルドライバには、
      モジュールやマニュアルページが用意されています。
      たとえば、前の章で例として出た <devicename>ath</devicename>
      ワイヤレスイーサネットドライバのマニュアルページには以下の記述があります。</para>

    <programlisting>Alternatively, to load the driver as a module at boot time, place the
following line in &man.loader.conf.5;:

    if_ath_load="YES"</programlisting>

    <para>ここで示された手順通り、
      <filename>/boot/loader.conf</filename> ファイルに
      <literal>if_ath_load="YES"</literal> 行を追加すると、
      起動時にモジュールが読み込まれるようになります。</para>

    <para>ただし、特定のサブシステムであったり、
      とても重要なドライバのような場合には、
      対応するモジュールが存在しないこともあります。
      たとえば、Fast File System (<acronym>FFS</acronym>) は、
      カーネルでのみ設定可能なオプションです。
      ネットワークサポート (INET) も同様です。
      残念ながら、ドライバが必要かどうかを知るには、
      モジュールそのものを調べる方法しかありません。</para>

    <warning>
      <para>カーネルを壊すことは簡単で、
	デバイスやオプションのサポートをビルドから削除するだけで壊れてしまうことがあります。
	たとえば、&man.ata.4; ドライバをカーネルコンフィグレーションファイルから除くと、
	<acronym>ATA</acronym> ディスクドライバを用いるシステムは、
	<filename>loader.conf</filename> に記述がないかぎり起動しません。
	もし、確信がないのであれば、モジュールを確認し、
	カーネルにサポートを残したままにしてください。</para>
    </warning>
  </sect1>

  <sect1 id="kernelconfig-building">
    <title>カスタムカーネルの構築とインストール</title>
    <indexterm>
      <primary>カーネル</primary>
      <secondary>構築 / インストール</secondary>
    </indexterm>

    <note>
      <para>カーネルを構築するには、&os; のすべてのソースファイルが必要です。</para>
    </note>

    <para>まず、
      カーネル再構築に必要なディレクトリをざっと見てみましょう。
      ここではディレクトリはすべて
      <filename>/usr/src/sys</filename> 以下の相対位置で示します。
      また、パス名 <filename>/sys</filename> からもアクセス可能です。
      ここには、カーネルの各部分を構成するサブディレクトリがいくつもあります。
      しかし、私たちの目的で最も重要なのは
      <filename><replaceable>arch</replaceable>/conf</filename> です。
      ここで、あなたのシステムに合わせてカーネルコンフィグレーションを編集します。
      それから <filename>compile</filename>ディレクトリ、
      ここはカーネルが作られる場所です。
      <replaceable>arch</replaceable> は、<filename>i386</filename>,
      <filename>amd64</filename>, <filename>ia64</filename>,
      <filename>powerpc</filename>, <filename>sparc64</filename>
      または <filename>pc98</filename>
      (日本で普及している PC のための開発ブランチ) のいずれかを表します。
      各アーキテクチャのディレクトリ内部にあるファイルはすべてそのアーキテクチャでのみ使用されます。
      残りのコードは、アーキテクチャに依存しない、
      &os; が移植されるすべてのプラットフォームで共有されるコードです。
      サポートされているデバイス、ファイルシステム、オプションが、
      それぞれのサブディレクトリに分かれている、
      という論理的な構成に注意してください。</para>

    <para>この章で示されるコマンドの例は、
      i386 アーキテクチャを使用していることを仮定しています。
      他のアーキテクチャを使用しているのであれば、
      使用しているアーキテクチャに適したパス名に変更してください。</para>

    <note>
      <para>もし、あなたのシステムに <filename>/usr/src/</filename>
	ディレクトリが存在しない (または、空である) のであれば、
	カーネルのソースがインストールされていません。
	すべてのソースツリーをインストールするもっとも簡単な方法は、<xref
	  linkend="synching"> で説明した &man.csup.1; を用いる方法です。
	以下のように、<filename>/usr/src/sys/</filename>
	へのシンボリックリンクも作成してください。</para>

	<screen>&prompt.root; <userinput>ln -s /usr/src/sys /sys</userinput></screen>
    </note>

    <para>つぎに、
      <filename><replaceable>arch</replaceable>/conf</filename> に移動して、
      <filename>GENERIC</filename>
      コンフィグレーションファイルをカーネルに与えたい名前にコピーしてください。
      たとえば次のようにします。</para>

    <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>cp GENERIC <replaceable>MYKERNEL</replaceable></userinput></screen>

    <para>慣習として、この名前はすべて大文字でつづられます。もし、
      いくつかの異なるハードウェアの &os; マシンを扱うなら、
      この名前にホスト名を含めるとよいでしょう。ここでは、例として
      <filename><replaceable>MYKERNEL</replaceable></filename>
      と呼ぶことにします。</para>

    <tip>
      <para>カーネルコンフィグレーションファイルを、直に
	<filename>/usr/src</filename> の下に置くのはよい考えとはいえません。
	なにか問題が起きたときに、
	<filename>/usr/src</filename> を消してやり直したいと思うかもしれません。
	その後で、あなたがカスタマイズしたカーネルコンフィグレーションファイルを消してしまったことに気づくのに時間はかからないでしょう。
	また、<filename>GENERIC</filename> ファイルを直接編集しないでください。
	なぜなら、編集後に
	<link linkend="updating-upgrading">ソースツリーをアップデート</link>
	すると、ファイルが上書きされ、変更点が失われてしまいます。</para>

      <para>カーネルコンフィグレーションファイルは他の場所において、
	<filename><replaceable>i386</replaceable></filename>
	ディレクトリにシンボリックリンクを張る方がよいでしょう。</para>

      <para>たとえば、次のようにします。</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/<replaceable>MYKERNEL</replaceable></userinput>	
&prompt.root; <userinput>ln -s /root/kernels/<replaceable>MYKERNEL</replaceable></userinput></screen>
    </tip>

    <para>では、<filename><replaceable>MYKERNEL</replaceable></filename>
      をあなたの好きなエディタで編集してください。もし、
      システムをインストールしたばかりならば、利用できるエディタは
      <application>vi</application>
      だけかもしれません。ここでは使い方の説明はしませんが、
      <link linkend="bibliography">参考図書</link>
      にあるような多くの本で詳しく説明 されていますので、
      そちらを参照してください。&os; にはより簡単なエディタとして
      <application>ee</application>
      があります。初心者の方であればこちらをエディタに選ぶとよいでしょう。
      まずファイルの最初の方のコメント行を編集し、
      あなたのコンフィグレーションに合せて変更した点などを記述して
      <filename>GENERIC</filename> と区別がつくようにしておきましょう。</para>
    <indexterm><primary>SunOS</primary></indexterm>

    <para>もし &sunos; や他の BSD
      オペレーティングシステムでカーネルの再構築をしたことがあれば、
      このファイルはとても親しみやすいでしょう。しかし、DOS のようなその他の
      オペレーティングシステムしか知らない人から見れば、
      <filename>GENERIC</filename>
      コンフィグレーションファイルはとてもなじみにくいものかもしれません。
      そのような場合は、
      <link linkend="kernelconfig-config"> コンフィグレーションファイル
      </link> の節をゆっくりと注意深く読んでください。</para>

    <note>
      <para>&os; プロジェクトの最新のソースファイルと、<link
	linkend="updating-upgrading">あなたのソースツリーを同期させている</link>
	場合、アップデートを行う際には、必ず
	<filename>/usr/src/UPDATING</filename>
	ファイルをチェックしてください。
	このファイルには、
	アップデートされたソースコードに関する重要な問題や特別に注意すべき点がすべて書かれています。
	<filename>/usr/src/UPDATING</filename> は常にあなたの &os;
	のソースと同期しているので、
	ハンドブックの記述よりも内容が新しいことがあります。</para>
    </note>

    <para>さあ、カーネルのソースコードをコンパイルしましょう。</para>

    <procedure>
      <title>カーネルの構築</title>

      <note>
	<para>カーネルを構築するには、&os; のすべてのソースファイルが必要です。</para>
      </note>

      <step>
	<para><filename
	  class="directory">/usr/src</filename> ディレクトリに移動します。</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>カーネルをコンパイルします。</para>

	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>新しいカーネルをインストールします。</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>
    </procedure>

    <tip>
      <para>デフォルトでは、カスタムカーネルを構築すると
	<emphasis>すべて</emphasis> のカーネルモジュールが同時に構築されます。
	カーネルのアップデートをより早く行いたい、または、
	カスタムモジュールのみを構築したいといった場合には、
	カーネルの構築を開始する前に、以下のように <filename>/etc/make.conf</filename>
	を編集してください。</para>

      <programlisting>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>この変数は、すべてのモジュールのかわりに構築するモジュールを指定します。</para>

      <programlisting>WITHOUT_MODULES = linux acpi sound ntfs</programlisting>

      <para>この変数は、構築を行わないトップレベルのモジュールを指定します。
	カーネルの構築のプロセスに関する、他の有益な変数については、
	&man.make.conf.5; を参照してください。</para>
    </tip>

    <indexterm>
      <primary><filename class="directory">/boot/kernel.old</filename></primary>
    </indexterm> 

    <para>新しいカーネルは <filename class="directory">/boot/kernel</filename> ディレクトリに
      <filename>/boot/kernel/kernel</filename> という名前でコピーされ、
      今までのカーネルは <filename>/boot/kernel.old/kernel</filename>
      という名前へ変更されます。
      では、新しいカーネルを使うために、システムをシャットダウンして再起動してください。
      うまく行かない場合は、この章の終りの
      <link linkend="kernelconfig-trouble">問題が起きた場合には</link>
      を参照してください。有用な情報があるかもしれません。この章の新しいカーネルが
      <link linkend="kernelconfig-noboot">起動しない</link>
      場合のリカバリの方法を注意深く読んでおいてください。</para>

    <note>
      <para>ブートローダ (&man.loader.8;)
	や設定などのブートプロセスに関係する他のファイルは、
	<filename>/boot</filename> に置かれます。
	サードパーティ製やカスタムモジュールを
	<filename class="directory">/boot/kernel</filename> に置くこともできますが、
	コンパイルしたカーネルとモジュールを同期しておく必要があります。
	コンパイルしたカーネルとモジュールが対応しない場合には、
	システムが不安定になったり、正常に動作しない可能性があります。</para>
    </note>
  </sect1>

  <sect1 id="kernelconfig-config">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Joel</firstname>
	  <surname>Dahl</surname>
	  <contrib>改訂: </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>コンフィグレーションファイル</title>
    <indexterm>
      <primary>カーネル</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm><primary>NOTES</primary></indexterm>
    <indexterm>
      <primary>カーネル</primary>
      <secondary>コンフィグレーションファイル</secondary>
    </indexterm>

    <para>コンフィグレーションファイルの一般的なフォーマットはとてもシンプルです。
      各行は 1 つのキーワードと 1 つ以上の引数を含んでいます。
      見やすくするために、ほとんどのキーワードは引数を 1 つしか書いてありません。
      <literal>#</literal> に続くものはすべてコメントとして扱われ、
      無視されます。ここでは、それぞれのキーワードについて
      <filename>GENERIC</filename> に出てくる順番で説明します。
      <anchor id="kernelconfig-options">アーキテクチャ依存のおびただしい数のオプション一覧については、
      <filename>GENERIC</filename> と同じディレクトリにある
      <filename>NOTES</filename> ファイルをご覧ください。
      アーキテクチャに依存しないオプションについては、
      <filename>/usr/src/sys/conf/NOTES</filename> ファイルをご覧ください。</para>

    <para>コンフィグレーションファイルでは <literal>include</literal>
      ディレクティブを利用できます。
      コンフィグレーションファイルに他のファイルを取り込むことができるので、
      すでに存在するファイルに対する小さな変更を簡単に維持できます。
      たとえば、オプションやドライバを少しだけ追加した
      <filename>GENERIC</filename> カーネルを必要としているのであれば、
      <literal>include</literal> を用いて、以下のように GENERIC
      からの差分だけの記述でコンフィグレーションファイルを作成できます。</para>

    <programlisting>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT
</programlisting>

    <para>多くの管理者は、
      コンフィグレーションファイルを個別に管理していたこれまでの手法にくらべ、
      このモデルが大変有益だと考えるでしょう。
      ローカルのコンフィグレーションファイルには、<filename>GENERIC</filename>
      とローカルとの差分のみが記述されており、
      <filename>GENERIC</filename> がアップグレードされて新しい機能が追加されると、
      (<literal>nooptions</literal> や <literal>nodevice</literal>
      によって外されない限り) ローカルのカーネルにも反映されます。
      この章のここから先は、典型的なコンフィグレーションファイルの中身と、
      さまざまなオプションやデバイスの役割について説明します。</para>

    <note>
      <para>利用可能なすべてのオプションを含むファイルを
	(通常はテスト目的で) 構築するには、
	以下のコマンドを <username>root</username> 権限で実行してください。</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf &amp;&amp; make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>カーネル</primary>
      <secondary>コンフィグレーションファイル</secondary>
    </indexterm>

    <para>以下は必要に応じてコメントを追加した
      <filename>GENERIC</filename> カーネルのコンフィグレーションファイルの例です。
      この設定例は
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/GENERIC</filename>
      に極めて近いものになっているはずです。</para>

    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>machine</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>マシンのアーキテクチャです。これは
      <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal> または
      <literal>sparc64</literal>
      のいずれかでなければなりません。</para>

    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>cpu</secondary>
    </indexterm>
    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>上記のオプションは、あなたのシステムの CPU タイプを指定します。
      複数の行を書いても構いません
      (例: <literal>I586_CPU</literal> とすべきか
      <literal>I686_CPU</literal> とすべきかはっきり分からない場合)。
      しかしながら、カスタムカーネルを作る場合、あなたの持つ CPU
      だけを指定するのがベストです。
      もしあなたの CPU がどのタイプか分からない場合、
      <filename>/var/run/dmesg.boot</filename>
      ファイルを確認して起動メッセージを調べるとよいでしょう。</para>

    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>ここにはカーネルの識別名を書きます。
      (前記の例の <literal><replaceable>MYKERNEL</replaceable></literal> のように)
      あなたがカーネルに付けたい名前に書き換えて下さい。
      <literal>ident</literal> に書いた名前はカーネルを起動する時に表示されるので、
      (実験的なカーネルを構築する場合など)
      普段使っているカーネルと区別したいときは、
      新しいカーネルに違う名前を付けると良いでしょう。</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>デバイスドライバのオプションは &man.device.hints.5;
      を用いて設定されます。
      &man.loader.8; は、起動時にデフォルトで
      <filename>/boot/device.hints</filename> を確認します。
      <literal>hints</literal> オプションを用いると、
      カーネルにこれらのヒント情報を静的に加えてコンパイルできます。
      その場合には、<filename>/boot</filename> に
      <filename>device.hints</filename>
      ファイルを作成する必要はありません。</para>

    <!-- XXX: Add a comment here that explains when compiling hints into
      the kernel is a good idea and why. -->

    <programlisting>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>通常の &os; のビルド過程では、<option>-g</option> 
      オプションとともにカーネルを構築すると、デバッグ情報を含みます。
      このオプションは &man.gcc.1; がデバッグ情報を生成するようにします。</para>

    <programlisting>options          SCHED_ULE         # ULE scheduler</programlisting>

    <para>&os; のデフォルトのスケジューラです。
      このオプションはこのままにしてください。</para>

    <programlisting>options          PREEMPTION         # Enable kernel thread preemption</programlisting>

    <para>カーネル空間において、優先度の高いスレッドがプリエンプションできるようにします。
      このオプションを使うことでインタラクティブになり、
      待ち状態になるよりすぐに実行状態になるようスレッドの割り込みを許可します。</para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>ネットワークのサポート。
      ネットワークに接続する予定がなくてもこのオプションは残して下さい。
      殆どのプログラムは少なくともループバックネットワーク
      (あなたの PC の中でのネットワーク接続) を必要としますので、
      基本的にこの行は必須です。</para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>このオプションは IPv6 通信プロトコルを利用可能にします。</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>これは標準のハードドライブファイルシステムです。
      ハードディスクから起動する場合は残して下さい。</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>このオプションは、カーネル内の Soft Updates 機能を有効にし、
      ディスクへの高速な書き込みを支援します。
      カーネルがこの機能を提供していても、
      特定のディスクに対してはこのオプションを有効にする必要があります。
      &man.mount.8; の出力を見て、使用しているディスクで
      Soft Updates が有効になっているかどうかを確認してください。
      <literal>soft-updates</literal> オプションが見当たらなければ、
      (現在使用しているファイルシステムには) &man.tunefs.8; や、
      (新規のファイルシステムには) &man.newfs.8;
      コマンドで有効にする必要があります。</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>このオプションは、カーネルのアクセス制御リストのサポートを有効にします。
      この機能は拡張属性および <acronym>UFS2</acronym> が有効になっていることに依存し、
      <xref linkend="fs-acl"> で機能の説明が行われています。
      <acronym>ACL</acronym> はデフォルトで有効にされています。
      もし、これまでにファイルシステムで有効にしていたのであれば、
      カーネルの中で無効にすべきではありません。
      なぜなら、無効にするとアクセス制御リストが削除され、
      ファイルの保護が予想できない方法で行われるためです。</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>このオプションは、メモリを多少余分に食うものの、
      大きなディレクトリに対するディスク操作を高速化する機能を有効にします。
      大規模なサーバや対話的なワークステーションではこのオプションを残しておいて、
      ファイアウォールのように、
      メモリが貴重でディスクアクセス速度がそれほど重要でない小規模なシステムでは削除するとよいでしょう。</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>このオプションは、メモリディスクによる root デバイスのサポートを有効にします。</para>

    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>
    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>ネットワークファイルシステム。
      &unix; ファイルサーバから TCP/IP
      を介してパーティションをマウントするのでない限り、
      これらの行をコメントアウトして下さい。</para>

    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>
    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>&ms-dos; ファイルシステム。
      起動時に DOS でフォーマットされたハードドライブをマウントするのでない限り、
      この行は安全にコメントアウトできます。
      この機能は最初に DOS パーティションをマウントする時に自動的にロードされます。
      又、優秀な <filename role="package">emulators/mtools</filename>
      を使ってもマウント、
      アンマウントすることなしに DOS フロッピーにアクセスすることができます。
      (<literal>MSDOSFS</literal> は必要としません)</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>CD-ROM 用の ISO 9660 ファイルシステム。
      もしあなたが CD-ROM ドライブを持っていないか、
      時々データ CD をマウントするだけならこの行をコメントアウトしても大丈夫です
      (データ CD を最初にマウントする時、自動的にロードされます)。
      音楽 CD はこのファイルシステムを必要としません。</para>

    <programlisting>options          PROCFS            # Process filesystem (requires PSEUDOFS)</programlisting>

    <para>プロセスファイルシステム。
      これは <filename>/proc</filename> にマウントされる、
      ファイルシステムの <quote>ふりをする</quote> もので、
      &man.ps.1; のようなプログラムに、
      どんなプロセスが走っているかに関するより多くの情報を提供させる事ができます。
      ほとんどのデバッグおよびモニタリングツールが
      <literal>PROCFS</literal> なしで起動するので、
      ほとんどの環境では <literal>PROCFS</literal> を必要としません。
      新しくインストールした場合には、
      デフォルトではプロセスファイルシステムをマウントしません。</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

    <para>カーネルで <literal>PROCFS</literal> を使う場合には、
      <literal>PSEUDOFS</literal> のサポートが必要です。</para>

    <programlisting>options          GEOM_PART_GPT     # GUID Partition Tables.</programlisting>

    <para><ulink url="http://en.wikipedia.org/wiki/GUID_Partition_Table">GUID
      パーティションテーブル</ulink> に対応します。
      GPT では、1 つのディスクに数多くのパーティション
      (標準の構成では最大 128) を作成可能です。</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>4.3BSD との互換機能です。
      有効なままにして下さい。
      この行をコメントアウトするとおかしな動きをするプログラムがあります。
    </para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with &os;4</programlisting>

    <para>このオプションは、
      古いバージョンの &os; でコンパイルされた古いシステムコールインターフェースを用いるアプリケーションを利用する場合に必要とされます。
      古いアプリケーションを実行するすべての
      &i386; システムで、このオプションの利用を推奨します。
      5.X でのみサポートされている ia64 や &sparc64; といったプラットフォームでは、
      このオプションは必要ありません。</para>

    <programlisting>options          COMPAT_FREEBSD5   # Compatible with &os;5</programlisting>

    <para>このオプションは、
      &os;&nbsp;5.X でコンパイルされた &os;&nbsp;5.X
      のシステムコールインタフェースを用いるアプリケーションを利用する場合に必要とされます。</para>

    <programlisting>options          COMPAT_FREEBSD6   # Compatible with &os;6</programlisting>

    <para>このオプションは、
      &os;&nbsp;6.X でコンパイルされた &os;&nbsp;6.X
      のシステムコールインタフェースを用いるアプリケーションを利用する場合に必要とされます。</para>

    <programlisting>options          COMPAT_FREEBSD7   # Compatible with &os;7</programlisting>

    <para>このオプションは、&os;&nbsp;8 以降において
      &os;&nbsp;7.X でコンパイルされた &os;&nbsp;7.X
      のシステムコールインタフェースを用いるアプリケーションを利用する場合に必要とされます。</para>

    <programlisting>options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI</programlisting>

    <para>この行は、カーネルがそれぞれの SCSI 機器を検出する前に
      5 秒間待つようにします。
      あなたが IDE ドライブしか持たないなら無視して結構です。
      そうでないなら、起動時間を短くするために、この数字を小さく変更できます。
      勿論、そうした場合に &os; が SCSI
      機器を認識しなくなってしまったら、もう一度数字を増やしてください。</para>

    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>この行はデバッグに役立つカーネルプロセスのトレースを可能にします。</para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>このオプションは System&nbsp;V 共有メモリを提供します。
      この機能の最も一般的な使用方法は X における XSHM 拡張です。
      多くのグラフィックス重視のプログラムではこの機能を自動的に描画のスピードアップに利用します。
      X を使っているなら、これを含めておいた方がいいでしょう。</para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>System&nbsp;V のメッセージのサポート。
      このオプションはカーネルサイズを数百バイト大きくするだけです。
    </para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>System&nbsp;V セマフォのサポート。
      あまり使われませんが、カーネルサイズは数百バイト大きくなるだけです。</para>

    <note>
      <para>&man.ipcs.1; コマンドを <option>-p</option>
	オプションで実行すると、これらの System&nbsp;V
	機能を使っているプロセスのリストを表示します。</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>リアルタイム拡張が 1993 &posix; に追加されました。
      Ports Collection の内のいくつかのアプリケーション
      (たとえば <application>&staroffice</application>)
      はこれを使っています。</para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>キーボードデバイスノードを <filename>/dev</filename>
      に作成するにはこのオプションが必要です。</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>Giant は、カーネル資源の広い範囲をプロテクトする
      mutex 排他メカニズム (sleep mutex) の名前です。
      このメカニズムは、今日では受け入れがたいほどにパフォーマンスのボトルネックとなっており、
      個々の資源をプロテクトするロック機構に移行しています。
      <literal>ADAPTIVE_GIANT</literal> オプションは、
      スピンしている適応型 mutex のセットに Giant を追加します。
      すなわち、スレッドが Giant mutex をロックしようとする際、
      他の CPU 上のスレッドによってすでにロックされていた場合には、
      最初のスレッドは実行状態のままロックが解除されるのを待ちます。
      通常、スレッドは実行の機会をスリープ状態で待ちます。
      もし、よくわからないのであれば、そのままにしておいてください。</para>

    <note>
      <para>&os; 8.0-RELEASE 以降では
	(<literal>NO_ADAPTIVE_MUTEXES</literal>
	オプションでコンパイルを行って非適合型にするのでなければ)
	すべての mutex はデフォルトで適合型になりました。
	現在の Giant は適合型なので、<literal>ADAPTIVE_GIANT</literal>
	オプションはカーネルコンフィグレーションから外されました。</para>
    </note>

    <indexterm>
      <primary>カーネルオプション</primary>
      <secondary>SMP</secondary>
    </indexterm>
    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>apic デバイスは、I/O APIC の割り込みを有効にします。
      ユニプロセッサおよび SMP カーネル両方で使用できますが、
      SMP カーネルでは必須です。
      マルチプロセッサに対応するには
      <literal>options SMP</literal> を追加してください。</para>

    <note>
      <para>apic デバイスは i386 アーキテクチャにのみ存在します。
	他のアーキテクチャでは、この行を含まないでください。</para>
    </note>

    <programlisting>device          eisa</programlisting>

    <para>あなたが EISA マザーボードを持っている場合、
      この行を含めて下さい。これは EISA
      バスに接続されているすべてのデバイスの自動検出と設定を可能にします。</para>

    <programlisting>device          pci</programlisting>

    <para>あなたが PCI マザーボードを持っている場合、この行を含めて下さい。
      これは PCI カードの自動検出と PCI から ISA
      バスへのゲートウエイを可能にします。</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>これはフロッピーディスクコントローラです。</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>このドライバはすべての ATA と ATAPI デバイスをサポートします。
      最近のマシンでは <literal>device ata</literal> 行を
      1 行書くだけですべての PCI ATA/ATAPI デバイスを検出することができます。</para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>ATA ディスクドライブには <literal>device ata</literal>
      と共にこの行が必要です。</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>ATA RAID ドライブには
      <literal>device ata</literal> と共にこのデバイスが必要です。</para>

    <programlisting><anchor id="kernelconfig-atapi">device          atapicd                 # ATAPI CDROM drives</programlisting>

    <para>ATAPI CDROM ドライブには <literal>device ata</literal>
      と共にこの行が必要です。</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

    <para>ATAPI フロッピードライブには <literal>device ata</literal>
      と共にこの行が必要です。</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>ATAPI テープドライブには <literal>device ata</literal>
      と共にこの行が必要です。</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>この行はコントローラ番号を静的に割り当てます。
      このオプションがない場合、デバイス番号は動的に割り当てられます。</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>SCSI コントローラです。
      あなたのシステムにないデバイスはコメントアウトして下さい。
      もし IDE しかないシステムならこれらすべてを削除できます。
      <literal>*_REG_PRETTY_PRINT</literal> 行は、
      対応するドライバに対するデバッグオプションです。</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>SCSI 周辺機器です。
      あなたが持っていないデバイスはコメントアウトして下さい。
      もし IDE しか持っていないならこれらを完全に削除できます。</para>

    <note>
      <para>USB &man.umass.4; ドライバ、およびその他のいくつかのドライバは、
	本当の SCSI デバイスではないにもかかわらず、
	SCSI サブシステムを利用します。
	そのため、そのようなドライバがカーネルコンフィグレーションに含まれている場合には、
	SCSI サポートを削除しないでください。</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          hptrr      # Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>サポートされる RAID コントローラです。
      これらのどれも持っていない場合、
      すべてをコメントアウト又は削除することができます。</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>キーボードコントローラ (<literal>atkbdc</literal>)
      は AT キーボード及び PS/2 スタイルポインティングデバイスの
      I/O サービスを提供します。
      キーボードドライバ (<literal>atkbd</literal>) と PS/2
      ポインティングデバイスドライバ (<literal>psm</literal>)
      はこのコントローラを必要とします。</para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para><literal>atkbd</literal> ドライバ。
      <literal>atkbdc</literal> コントローラと協調して動作し、
      AT キーボードコントローラに接続された AT 84 キーボードや
      AT 拡張キーボードへのアクセスを提供します。</para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>あなたのマウスが PS/2
      マウスポートに接続するタイプならこのデバイスを使って下さい。</para>

    <programlisting>device          kbdmux        # keyboard multiplexer</programlisting>

    <para>標準のキーボードマルチプレクサのサポート。
      2 つ以上のキーボードを用いる予定がないのであれば、
      この行を削除してもかまいません。</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>ビデオカードドライバです。</para>

    <programlisting>
device          splash     # Splash screen and screen saver support</programlisting>

    <para>起動時にスプラッシュスクリーンが表示されます!
      スクリーンセーバもこのデバイスを必要とします。</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> は SCO に類似したデフォルトのコンソールドライバです。
      殆どのフルスクリーンのプログラムは <filename>termcap</filename>
      のようなターミナルデータベールライブラリにアクセスするので、
      <literal>sc</literal> を使うか <literal>VT220</literal>
      互換のコンソールドライバである <literal>vt</literal>
      を使うかは重要ではありません。
      ログイン時、このコンソールでフルスクリーンプログラムが動かないときは
      <envar>TERM</envar> 変数を <literal>scoansi</literal> に設定して下さい。
    </para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>これは VT220 互換のコンソールドライバで、
      VT100/102 と後方互換性があります。
      <literal>sc</literal> とハード的に互換性がないラップトップでも問題なく動きます。
      ここでもログイン時に <envar>TERM</envar> 変数を
      <literal>vt100</literal> 又は <literal>vt220</literal>
      と設定して下さい。
      このドライバは、<literal>sc</literal> デバイス用の
      <filename>termcap</filename> や <filename>terminfo</filename>
      のエントリが無い、ネットワーク上の多くの異なったマシンに接続する際にも有用です
      &mdash; <literal>vt100</literal>
      は仮想的にすべてのプラットフォームで有効であるべきです。</para>

    <programlisting>device          agp</programlisting>

    <para>システムが AGP カードを搭載している場合には、
      この行を含めてください。
      AGP および (ボードが機能を持っている場合には) AGP GART 
      に対応します。</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># Power management support (see NOTES for more options)
#device          apm</programlisting>

    <para>先進的な電源管理機能 (APM) のサポート。
      <filename>GENERIC</filename>
      ではデフォルトで無効にされていますが、
      ラップトップでは役に立つでしょう。</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>APM および ACPI といった電源管理イベントのためのタイマデバイスドライバです。</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>PCMCIA サポート。ラップトップを使っているなら必要でしょう。</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>これらは &ms-dos;/&windows; の世界では <devicename>COM</devicename>
      と呼ばれているシリアルポートです。</para>

    <note>
      <para>もしあなたが内蔵モデムを <devicename>COM4</devicename> に、
	シリアルポートを <devicename>COM2</devicename>
	に設定している場合、&os; からアクセスするには、
	(IRQ2=IRQ9 という、不明瞭な技術的理由により) モデムの IRQ を 2
	に変更する必要があります。
	もしマルチポートシリアルカードを持っていて、これらを
	<filename>/boot/device.hints</filename>
	に追加する正しい数値に関する情報がほしい場合は、マニュアルページ &man.sio.4;
	を参照して下さい。
	ビデオカードのいくつかは (S3 チップベースのものは特に) IO
	アドレスを <literal>0x*2e8</literal> と言う形式で表現する一方、
	多くの安価なシリアルカードは 16 ビットの IO アドレスを完全に
	デコードしないので、これらのカードを使った場合衝突が起こり、
	事実上 <devicename>COM4</devicename> ポートを使用不可能にします。</para>

      <para>各々のシリアルポートは
	(共有割り込み番号をサポートするマルチポートカードを使っていない限り)
	固有の IRQ を必要とします。
	従って <devicename>COM3</devicename> と <devicename>COM4</devicename>
	用のデフォルト IRQ は利用できません。</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>ISA バスパラレルポートインタフェースです。</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>パラレルポートバスのサポートを提供します。</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>パラレルポートプリンタのサポートです。</para>

    <note>
      <para>上の 3 つはすべてパラレルプリンタを利用可能にするために必要です。</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>パラレルネットワークインタフェース用のドライバです。</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>汎用I/O (<quote>geek port</quote>) + IEEE1284 I/O です。</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>zip ドライブ</primary></indexterm>
    <para>Iomega の Zip ドライブ用です。<literal>scbus</literal>
      と <literal>da</literal> サポートが必要です。
      EPP 1.9モードを使うと最高の性能が得られます。</para>

    <programlisting>#device         puc</programlisting>

    <para>&man.puc.4 glue ドライバがサポートしている
      <quote>dumb</quote> シリアル、
      またはパラレル PCI カードを持っているのであれば、
      このデバイスを有効にしてください。</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>PCI ネットワークカードのドライバです。
      あなたのシステムにないものはコメントアウトするか削除して下さい。</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>MII バスサポートはいくつかの PCI 10/100 イーサネット NIC、
      すなわち MII に従うトランシーバや MII
      のようなトランシーバ制御インタフェースを実装するもの、に必要となります。
      カーネルコンフィギュレーションに <literal>device miibus</literal>
      を追加することで、汎用 miibus API のサポートと、
      特定のドライバを必要としない場合に利用される汎用のものを含むすべての
      PHY ドライバが導入されます。</para>

    <programlisting>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>MII バスコントローラコードを利用するドライバです。</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>ISA イーサネットドライバです。
      どのカードがどのドライバによりサポートされているかの詳細は、
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename> を参照して下さい。</para>

    <programlisting># Wireless NIC cards
device          wlan            # 802.11 support</programlisting>

    <para>標準の 802.11 サポート。ワイヤレスネットワークではこの行が必要です。</para>

    <programlisting>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</programlisting>

    <para>802.11 デバイスの暗号化サポート。
      暗号化および 802.11i セキュリティプロトコルを使うことを考えているのであれば、
      これらの行が必要です。</para>

    <programlisting>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>ワイヤレスカードのサポートです。</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>TCP/IP の汎用ループバックデバイスです。
      <hostid>localhost</hostid> (すなわち
      <hostid role="ipaddr">127.0.0.1</hostid>) に対して telnet や FTP
      で接続すると、このデバイスを通して戻ってきます。
      これは<emphasis>必須</emphasis>です。</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>暗号化されたセキュア乱数ジェネレータです。</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal>
      はイーサネットカードを持っている場合にのみ必要です。
      汎用イーサネットプロトコルコードを含みます。</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> は SLIP サポートを行います。
      SLIP は設定のより簡単な、モデム-モデム間の接続にはより適していてより高機能な
      PPP に殆ど取って代わられています。</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>これはダイアルアップ接続用のカーネル PPP サポートです。
      他にも <literal>tun</literal> を利用し、
      デマンドダイアリングのような柔軟性と機能を提供するユーザーランドのアプリケーションとして実装された
      PPP が存在します。</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>これはユーザーランド PPP ソフトウエアにより利用されます。
      詳細はこの本の <link linkend="userppp">PPP</link>
      セクションを参照して下さい。</para>

    <programlisting><anchor id="kernelconfig-ptys">
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>これは <quote>疑似ターミナル</quote> 或いはシミュレートされたログインポートです。
      これは入ってくる <command>telnet</command> と
      <command>rlogin</command> セッション、
      <application>xterm</application> やその他の
      <application>Emacs</application>
      のようなアプリケーションにより利用されます。</para>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>メモリディスク疑似デバイス。</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>この行は IPv6 over IPv4 トンネル、IPv4 over IPv6 トンネル、
      IPv4 over IPv4 トンネル、IPv6 over IPv6 トンネルを提供します。
      <literal>gif</literal> デバイスは
      <quote>auto-cloning (自動複製)</quote> し、
      必要に応じてデバイスノードを作成します。</para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>この疑似デバイスは自分宛に送られたパケットを受け取り、
      IPv4/IPv6 変換デーモンに渡します。</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>これはバークレーパケットフィルタです。
      この疑似デバイスはネットワークインタフェースを、
      イーサネットのようなブロードキャストネットワーク上ですべてのパケットを拾うことのできる
      promiscuous モードに設定できるようにします。
      これらのパケットはディスクに取り込むこともできますし、
      &man.tcpdump.1; を使ってチェックをすることもできます。</para>

    <note>
      <para>&man.bpf.4; デバイスは、&man.dhclient.8;
	がデフォルトルータ (ゲートウェイ)
	の IP アドレスなどを取得するためにも使われています。
	DHCP を使っているなら、これはコメントアウトしないでください。</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>さまざまな USB デバイスのサポートです。</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>Firewire デバイスのサポートです。</para>

    <para>より詳細な情報と、&os; によりサポートされる他のデバイスについては
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>
      を参照して下さい。</para>

      <sect2>
        <title>大容量メモリ構成 (<acronym>PAE</acronym>)</title>
	<indexterm>
	  <primary>Physical Address Extensions
	    (<acronym>PAE</acronym>)</primary>
	  <secondary>large memory</secondary>
	</indexterm>

	<para>大容量のメモリを搭載したコンピュータは、
	  ユーザ＋カーネル仮想アドレス (<acronym>KVA</acronym>) 空間における
	  4 ギガバイトの制限を越えてメモリにアクセスする必要があります。
	  Intel は &pentium; Pro およびそれ以降の CPU において、
	  36-bit 物理アドレス空間に対応しました。</para>

	<para>&intel; &pentium; Pro およびそれ以降の CPU では、
	  Physical Address Extensions (<acronym>PAE</acronym>) 
	  を用いて 64 ギガバイトまでのメモリの構成を可能にします。
	  &os; は、<option>PAE</option>
	  カーネルコンフィグレーションオプションを用いることで PAE に対応します。
	  現在すべてのバージョンの &os; で利用できます。 
	  Intel のメモリアーキテクチャの制限により、
	  4 ギガバイト以上または以下の区別をしません。
	  4 ギガバイト以上に割り当てられたメモリは、
	  利用可能なメモリのプールに単純に追加されます。</para>

	<para><acronym>PAE</acronym> サポートをカーネルで有効にするには、
	  以下の行を単にカーネルコンフィグレーションファイルに追加してください。</para>
	
	<programlisting>options		    PAE</programlisting>

	<note>
	  <para>&os; の <acronym>PAE</acronym> のサポートは、
	    &intel; IA-32 プロセッサでのみ利用できます。
	    また、&os; における <acronym>PAE</acronym>
	    サポートは広くテストが行われているわけではないので、
	    &os; の他の機能と比較するとベータ品質に位置づけられます。</para>
	</note>

	<para>&os; における <acronym>PAE</acronym> サポートには、
	  以下のような制限があります。</para>
	
	<itemizedlist>
	  <listitem>
	    <para>プロセスは、4 ギガバイト以上の VM 空間にアクセスできません。</para>
	  </listitem>

	  <listitem>
	    <para>&man.bus.dma.9; インタフェースを用いないデバイスドライバは、
	      <acronym>PAE</acronym> が有効なカーネルにおいてデータの破損を引き起こす可能性があるため、
	      利用することは推奨されません。
	      そのため &os; で提供される <filename>PAE</filename>
	      カーネルコンフィグレーションファイルでは、<acronym>PAE</acronym> 
	      が有効なカーネルで動作することが知られていないすべてのドライバが外されています。</para>
	  </listitem>

	  <listitem>
	    <para>いくつかの調整可能なシステムパラメータは、
	      利用可能な物理メモリによるメモリリソースを調整します。
	      <acronym>PAE</acronym> を必要とするような大きなメモリのシステムでは、
	      そのような調整可能なリソースが不必要に割り当てられることがあります。
	      そのような例のひとつが <option>kern.maxvnodes</option>
	      sysctl です。この sysctl は、カーネルで許される
	      vnode の最大数を調節します。
	      この sysctl や同様に変更可能なパラメータを適切な値に調整することをお奨めします。</para>
	  </listitem>

	  <listitem>
	    <para>カーネルバーチャルアドレス (<acronym>KVA</acronym>)
	      の枯渇を避けるため、<acronym>KVA</acronym> 空間を大きくとる、または、
	      (上記のように) 激しく消費される特定のカーネルリソースの量を減らす必要があるでしょう。
	      <option>KVA_PAGES</option> カーネルオプションを用いて
	      <acronym>KVA</acronym> 空間を増やすことができます。</para>
	  </listitem>
	</itemizedlist>

	<para>パフォーマンスや安定性については、
	  &man.tuning.7; マニュアルページを調べることをお奨めします。
	  &man.pae.4; マニュアルページは、&os; の <acronym>PAE</acronym>
	  サポートに関する最新の情報を含んでいます。</para>
    </sect2>
  </sect1>

  <sect1 id="kernelconfig-trouble">
    <title>問題が起きた場合には</title>

    <para>カスタムカーネルを作る場合に起きるトラブルは、
        次の 4 種類に分けられます。</para>

    <variablelist>
      <varlistentry>
	<term><command>config</command> コマンドの失敗</term>

	<listitem>
	  <para>カーネルコンフィグレーションファイルの設定後に
	    &man.config.8; コマンドが失敗したのであれば、
	    おそらくファイルのどこかに単純な間違いがあります。
            さいわい、&man.config.8;
            はトラブルの起きた行番号を出力するので、
	    エラーを含む行を素早く見つけることができます。
	    例えば、次のように出力された場合</para>

            <screen>config: line 17: syntax error</screen>

	  <para><filename>GENERIC</filename> カーネルのファイルや、
            他のリファレンスと比較して注意深く修正してください。</para>
	</listitem>
      </varlistentry>

      <varlistentry><term><command>make</command> コマンドの失敗</term>
	<listitem>
	  <para><command>make</command> コマンドが失敗した場合には、
	    カーネル設定で &man.config.8;
	    がとらえられなかったような間違いをしていることが多いようです。
            もう一度コンフィグレーションファイルを見直してください。
            それでも問題を解決することができなければ、
            &a.questions;
            へあなたのカーネルコンフィグレーションファイルをつけてメールしてください。
            誰かが素早く間違いを見つけてくれるでしょう。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>カーネルが起動しない<anchor
	  id="kernelconfig-noboot"></term>
	<listitem>
	  <para>新しいカーネルが起動しなかったり、
	    デバイスの認識をしない場合でもあわてないでください!
	    さいわい、&os;
	    には利用できないカーネルから復帰する洗練されたメカニズムがあります。
	    それは、&os;
	    のブートローダで起動したいカーネルを選択するだけです。
	    システムの起動メニューが表示されている時に、この機能を使えます。
	    6 番目の
	    <quote>Escape to a loader prompt</quote> オプションを選択してください。
	    プロンプトで
	    <command>boot <replaceable>kernel.old</replaceable></command>
	    か他の正常に起動するカーネルを入力してください。
	    カーネルの再設定をおこなう場合にはいつも、
            確実に動くことが分かっているカーネルを用意しておくようにすると良いでしょう。
          </para>

	  <para>問題のないカーネルで起動した後にあなたのコンフィグレー ションファイルを調べ、
	    再び構築を試みてください。
	    <filename>/var/log/messages</filename>
	    ファイルにはすべての成功した起動時のカーネルメッセージやその他の記録があり、
	    これは助けになる情報の一つでしょう。また、
	    &man.dmesg.8; コマンドは現在の起動時のカーネルメッセージを出力します。</para>

	  <note>
	    <para>カーネルの構築中にトラブルが起きた時に使うために、
	      GENERIC や他のカーネルを次回の構築で消されないよう別の名前で保存するようにしてください。<emphasis
		remap=tt>kernel.old</emphasis>
	      は新しいカーネルをインストールする時に、
	      その一つ前にインストールした、
	      うまく動かないかもしれないカーネルで上書きされてしまうので当てにできません。
	      またできる限り早く動作しているカーネルを本来の
	      <filename class="directory">/boot/kernel</filename> の位置に移動させてください。
	      そうしないと
	      &man.ps.1; のようなコマンドが正しく動きません。これを行うには、
	      以下のように正しく起動するカーネルを含むディレクトリ名に変更するだけです。</para>

	    <screen>&prompt.root; <userinput>mv /boot/kernel <replaceable>/boot/kernel.bad</replaceable></userinput>
&prompt.root; <userinput>mv /boot/<replaceable>kernel.good</replaceable> /boot/kernel</userinput></screen>

	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>カーネルは動きますが &man.ps.1; は動きません!</term>

	<listitem>
	  <para>システムユーティリティと異るバージョンのカーネルをインストールした場合、
	    例えば -CURRENT のカーネルを -RELEASE 上にインストールするような場合、
	    &man.ps.1; や &man.vmstat.8;
	    のような多くのシステムステータスコマンドは動かなくなります。
	    カーネルと同じバージョンのソースツリーで
	    <link linkend="makeworld">world を再構築し、インストール</link>
	    してください。
            これは、カーネルとそれ以外で異なるバージョンを組み合わせてオペレーティングシステムを使用することが推奨されない理由の一つとなっています。</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
