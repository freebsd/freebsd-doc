<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.13
     $FreeBSD$
-->

<chapter id="security">
  <title>セキュリティ</title>

  <sect1 id="crypt">
    <title>DES, MD5, と Crypt</title>

    <para><emphasis>原作: &a.wollman;<!-- <br> -->
	24 September 1995.</emphasis></para>

    <para><emphasis>訳: &a.hanai;<!-- <br> -->
	12 September 1996.</emphasis></para>

    <para>UN*X システムにおいてパスワードを保護し,
      簡単に覗かれるのを防 ぐために,
      従来パスワードはある方法によりスクランブルされてきました.
      ベル研の Unix 第7版に始まって以来,
      パスワードはセキュリティの専門家がい うところの
      &ldquo;一方向ハッシュ関数&rdquo;
      というものを用いることにより暗号化されるようになりました.
      つまり, 可能な限りのパスワード空間を検索するという強引な
      方法以外にそのオリジナルを得ることができない,
      といった方法でパスワードは変換 されるのです. 不幸なことに,
      その当時 AT&amp;T の研究者たちが手に入れることができ
      た唯一の暗号化方法は DES(Data Encryption Standard)
      に基づいたものでし た.
      これは営利企業にとっては大して問題ではありませんが, FreeBSD のよ
      うにすべてのソースコードが自由に手に入る
      オペレーティングシステムにとっ ては重大な問題となります.
      なぜなら, 多くの政府は DES やその他の暗号化ソフ
      トウェアが国境を越えることに
      制限をつけようとしているからです.</para>

    <para>ここで, FreeBSD チームは一つのジレンマに直面しました.
      つまり, どうす れば法に触れることなく国外にあるそれらの UNIX
      システムのすべてに互換性を持 たせることができるか,
      ということです. 私たちは ``dual track approach'' を
      取ることに決めました.
      規制されていないパスワードスクランブラのみを含む
      配布用物件を作り, DES
      に基づいたパスワードハッシュを付加ライブラリ
      として分けて供給するのです.
      パスワードをスクランブルさせる関数は, C ライブラリから
      <filename>libcrypt</filename> と呼ばれる(それを実行する C 関数が
      <function>crypt</function> と
      いう名前だからです)別のライブラリへ移されました. FreeBSD 1.x
      及び 2.0 のリリース前のスナップショットでは,
      その規制されていないスクランブラは Nate Williams
      によって書かれた安全でない関数を使っていますが, 次の
      リリースでは RSA Data Security 社の一方向ハッシュ関数の MD5
      を使う方法 に置き換えられました.
      これらの関数はどれも暗号化を含んでいないため,
      合衆国から持ち出し,
      他の多くの国へ持ち込めるものであるとされています.</para>

    <para>一方, DES
      に基づいたパスワードハッシュ関数に関する作業もまた進行中 でした,
      まず, 合衆国及び他の国で書かれたコードの同期をとりながら,
      合衆国の外で書かれた <function>crypt</function>
      のあるバージョンが持ち込まれました. そしてライブラリは修正され,
      二つにわけられました. すなわち DES <filename>libcrypt</filename>
      は一方向パスワードハッシュをおこなうのに必要なコード のみを含み,
      それとは別の <filename>libcipher</filename>
      は実際に暗号化をおこなう
      ためのエントリポイントとして生成されました.
      コンパイルされたライブラリに対
      して国外に持ち出す許可を得るのを簡単にするために,
      コードはこのように分け られたのです.</para>

    <sect2>
      <title><command>crypt</command> メカニズムを理解する</title>

      <para>あるパスワード文字列を作るのに, DES
	に基づいたハッシュ関数を使っ たのか,
	MD5に基づいたハッシュ関数を使ったのかは非常に簡単にわかります.
	MD5 を使ったパスワード文字列は必ず
	<literal>&#36;1&#36;</literal> という文字 で始まります.
	DESを使ったパスワード文字列はどんな特定の文字も持っていま
	せんが, MD5を使ったパスワードよりも短く,
	<literal>&#36;</literal> という文字
	を持たない64文字のアルファベットで構成されています.
	したがって, ドル記号で 始まっていない比較的短い文字列は DES
	を使ったパスワードである可能性が非常 に高いです.</para>

      <para>あなたのシステムで,
	どちらのライブラリが使われているかを決めるの は,
	スタティックにリンクされている <command>init</command>
	のようなもの(その ようなプログラムに対する唯一の方法は
	わかっているパスワードを試してみ
	て動くかどうかを確認することです.)
	を除いたほとんどのプログラムについ ては非常に簡単なことです.
	<function>crypt</function> を使うようなプログラムは
	<filename>libcrypt</filename> にリンクされています.
	そしてそれぞれのライブラリに 対する <emphasis
	  remap=tt>libcrypt</emphasis>
	は適切な実装へのシンボリックリンクとなってい ます. 例えば, DES
	版を使っているようなシステムにおいては次のようになって
	います:</para>

      <screen>&prompt.user; <userinput>cd /usr/lib</userinput>
&prompt.user; <userinput>ls -l /usr/lib/libcrypt*</userinput>
lrwxr-xr-x  1 bin  bin  13 Sep  5 12:50 libcrypt.a -&gt; libdescrypt.a
lrwxr-xr-x  1 bin  bin  18 Sep  5 12:50 libcrypt.so.2.0 -&gt; libdescrypt.so.2.0
lrwxr-xr-x  1 bin  bin  15 Sep  5 12:50 libcrypt_p.a -&gt; libdescrypt_p.a</screen>

      <para>MD5 に基づいたライブラリを使っているシステムにおいては,
	同じようなリンクが 見られるでしょうが, そのターゲットは
	<filename>libdescrypt</filename> ではなく
	<filename>libscrypt</filename> になっているでしょう.</para>
    </sect2>
  </sect1>

  <sect1 id="skey">
    <title>S/KEY</title>

    <para><emphasis>原作: &a.wollman;<!-- <br> -->
	25 September 1995.</emphasis></para>

    <para><emphasis>訳: &a.jp.hino;.<!-- <br> -->
	24 September 1996.</emphasis></para>

    <para>S/KEY は一方向ハッシュ関数 (ここで述べているバージョンでは,
      過去と の互換性を保つために MD4 を用いています. S/KEY
      の他のバージョンでは  MD5 や DES-MAC を用いているものもあります)
      を基にしたワンタイムパスワー ド方式です. S/KEY は, バージョン
      1.1.5 以降のすべての FreeBSD に標準的 に含まれています. S/KEY は
      FreeBSD 以外の数多くのシステムの上でも利用 可能であり,
      その実装の数も増えています. S/KEY ば Bell Communications
      Research, Inc. の登録商標です.</para>

    <para>以下の説明では, 三種類の異なる「パスワード」が使われます.
      まず一つ 目は, あなたが普段使っている普通の UNIX スタイルの,
      もしくは Kerberos  でのパスワードです. ここではこれを
      &ldquo;UNIX パスワード&rdquo; と呼ぶことにし ます. 二つ目は,
      S/KEY の <command>key</command> プログラムによって生成され,
      <command>keyinit</command>
      プログラムとログインプロンプトが受け付ける, 一回限りの
      パスワードです. ここではこれを
      &ldquo;ワンタイムパスワード&rdquo; と呼ぶことにし ます.
      三つ目のパスワードは, <command>key</command> (と場合により
      <command>keyinit</command>)
      プログラムに対してユーザが入力する秘密のパスワードで,
      ワンタイムパスワー ドを生成するのに使われます. ここではこれを
      &ldquo;秘密のパスフレーズ&rdquo; もし くは単に
      &ldquo;パスフレーズ&rdquo; と呼ぶことにします. (訳注:
      ユーザが頭の中だ けにしまっておくべきものが,
      この秘密のパスフレーズです. なお, 原文では
      これをパスワードと表記していますが,
      混乱を避けるために訳文ではすべて &ldquo;
      秘密のパスフレーズ&rdquo; に統一しています.)</para>

    <para>秘密のパスフレーズは, UNIX
      パスワードと同じである必要はありませんし,  また UNIX
      パスワードと何らかの関連性を持たなければならないということも
      ありません (両者を同一に設定することは可能ですが,
      お奨めしません).  UNIX パスワードは長さが 8
      文字に制限されています (訳注: FreeBSD で DES
      を導入していない場合はもっと長いパスワードも認識されます).
      これに対し, S/KEY
      では秘密のパスフレーズを好きなだけ長くすることができます (訳注:
      実装上, `<emphasis remap=tt>key</emphasis>'
      コマンドなどのバッファ長で制限されてしまう可能性が あります.
      200文字程度に押えておいた方がよいでしょう :-). 筆者は 7 語か
      らなる文を使っています. 通常の設定では, S/KEY システムは UNIX
      のパスワー
      ドシステムと完全に独立して動作するようになっています.</para>

    <para>S/KEY システムでは他に二種類のデータを使用します. 一つは
      &ldquo;シード (種)&rdquo; または (混乱を招きますが)
      &ldquo;キー&rdquo; と呼ばれるもので, (訳注: デ フォルトでは)
      二つの文字と五つの数字で構成されます. もう一つは
      &ldquo;<quote>シー ケンス番号</quote> で, 1 以上の整数です.
      シーケンス番号は特に指定しなければ 100以下です (訳注:
      ``<emphasis remap=tt>keyinit</emphasis>' プログラムでは 9999
      まで指定できま す). S/KEY
      はここまでに述べたデータを利用してワンタイムパスワードを生
      成します. その方法は, まずシードと秘密のパスフレーズを連結し,
      それに対 してシーケンス番号の回数だけ一方向ハッシュ (RSA Data
      Security, Inc. に よる MD4 セキュアハッシュ関数)
      を繰り返し計算します. そしてその結果を 六つの英単語に変換します
      (訳注: ハッシュ計算の後, 64ビットに収まるよう
      にデータを処理したものが厳密な意味でのワンタイムパスワードです.
      通常は ユーザの便宜のために, この
      64ビットデータと六つの英単語との間で変換処 理をおこなっています)
      . <command>login</command> プログラムと <command>su</command>
      プログラム は,
      前回最後に受け付けられたワンタイムパスワードを記録しています.
      そし て, その前回のワンタイムパスワードと,
      ユーザが入力したワンタイムパスワー
      ドを一回ハッシュ関数にかけた結果とが一致した場合に,
      このユーザは認証さ れます. 一方向ハッシュ関数を使うことにより,
      もし (ログイン等に成功した)
      ワンタイムパスワードが一回盗聴されたとしても,
      次回以降に使われる複数の
      ワンタイムパスワードを生成することは不可能です.
      シーケンス番号はログイ ン (等)
      が成功するたびに一つずつ減らされて, ユーザとログインプログラム
      の間で同期が取られます. (シーケンス番号が 1 になったら, S/KEY
      を再度初 期化する必要があります.)</para>

    <para>次に, S/KEY 関連の四つのプログラムについて説明します.
      <command>key</command> プ ログラムは, シーケンス番号と,
      シードと, 秘密のパスフレーズを受け付けて,
      ワンタイムパスワードを生成します. <command>keyinit</command>
      プログラムは, S/KEY  を初期化するのに使用され,
      また秘密のパスフレーズやシーケンス番号やシー
      ドを変更するためにも使用されます. このプログラムを実行するには,
      秘密の パスフレーズか, または,
      シーケンス番号とシードとワンタイムパスワードの 一組かの,
      どちらかが必要になります. <command>keyinfo</command>
      プログラムは, <filename>/etc/skeykeys</filename>
      というファイルを調べて, このプログラムを起動し
      たユーザの現在のシーケンス番号とシードを表示します. 最後に,
      <command>login</command> と <command>su</command>
      プログラムについてですが, これらは S/KEY の
      ワンタイムパスワードを, (訳注:システムが)
      ユーザを認証するものとして受 理する処理をおこないます.
      <command>login</command> プログラムは, 指定された特定の
      アドレスからの接続に対して, UNIX
      パスワードの使用を認めなくする機能,  逆に言えば S/KEY
      の利用を強制する機能も持っています.</para>

    <para>このドキュメントでは, 四種類の異なる操作について説明します.
      一つ目 は, <command>keyinit</command>
      プログラムを信頼できる通信路上で利用する場合で, 一 番始めに
      S/KEY を設定する操作や, 使い始めたあとで秘密のパスフレーズや
      シードを変更する操作です. 二つ目は, <command>keyinit</command>
      プログラムを信頼で きない通信路上で利用する場合で,
      操作の目的は一つ目と同じです. この場合 には
      <command>key</command> プログラムを併用する必要があります.
      三つ目は, <command>key</command> プログラムを使い,
      信頼できない通信路を通じてログインする操 作です. 四番目は,
      <command>key</command> プログラムを使って, 複数のワンタイムパス
      ワードを一気に生成する操作です.
      ここで生成した複数のワンタイムパスワー ドは,
      メモしたり印刷したりして携帯し, 信頼できる通信路が一切ないところ
      (例えば展示会場など) で利用することができます. (訳注:
      ワンタイムパスワー ドを記録した紙をなくさないこと!
      電話番号やIPアドレス, ユーザ名を一緒に
      メモしていたら最悪です!!)</para>

    <sect2>
      <title>信頼できる通信路での初期化</title>

      <para>信頼できる通信路 (例えばあるマシンのコンソール画面など)
	を利用して いるときに, S/KEY の初期化, S/KEY
	の秘密のパスフレーズの変更, またはシー
	ドの変更をおこなうことができます. そのためには,
	まずあなた自身がログイ ンし, <command>keyinit</command>
	コマンドを以下のようにパラメタなしで実行します:</para>

      <screen>&prompt.user; keyinit
Updating wollman:                       ) この部分は始めて S/KEY を使
Old key: ha73895                        ) うときには表示されません.
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
        ) `keyinit' コマンドが出力する注意です. 訳すと,
        ) 注意 - この動作モードはマシンに直接入力しているときのみ利用
        ) すること. もし今 telnet や rlogin を使っているなら, 秘密のパ
        ) スフレーズを入力せずにこのままコマンドを終了し, かわりに
        ) keyinit -s を実行すること.
<prompt>Enter secret password:</prompt>                 ) ここで秘密のパスフレーズを入力します.
<prompt>Again secret password:</prompt>                 ) もう一回入力します.

ID wollman s/key is 99 ha73896          ) あとで説明します.
SAG HAS FONT GOUT FATE BOOM             )</screen>

      <para>上の例で出てきた事柄について説明しましょう. <prompt>Enter
	  secret password:</prompt>
	というプロンプトに対してあなたが考えた秘密のパスフレーズを
	入力します (筆者は 7
	単語以上の文を秘密のパスフレーズにしています). こ
	の秘密のパスフレーズは後でログインするために
	必要になるものです. `ID'  から始まる行は, S/KEY
	における一回分のパラメタであり, あなたのログイ
	ン名とシーケンス番号とシードです. (訳注:
	`<command>keyinit</command>' コマンドは次回
	にログインするときに使われるパラメタを参考のために
	ここで表示しま す. ) S/KEY を使ってログインするときには,
	システム側が自動的にこれらの パラメタを表示してくれますから,
	これらのパラメタを覚えておく必要は ありません. 最後の行が,
	今述べたパラメタと入力された秘密のパスフレー
	ズから計算されたワンタイムパスワードです. この例を実行した後,
	次にログ インするときに打ち込むべきワンタイムパスワードが
	これです.</para>
    </sect2>

    <sect2>
      <title>信頼できない通信路での初期化</title>

      <para>信頼できない通信路を使って S/KEY を初期化,
	または秘密のパスフレーズ やシードを変更するためには,
	信頼できる通信路として, その信頼できない通
	信路とは別のものを用意する必要があります.
	その信頼できる通信路は  <command>key</command>
	プログラムを実行するために必要となるもので, 例えばそれは,
	あなたが信頼できる Macintosh
	のデスクアクセサリや信頼できるマシンのシェ
	ルプロンプトだったりするでしょう
	(そこでの操作に関しては後述します). (訳注:
	ここでの通信路とはマシンそのものになります. 信頼できるマシンと
	は, 信頼できる人がしっかり管理しているマシンということです.)
	他に準備 しておくものとして, シーケンス番号
	(100は適切な値といえるでしょう) と,
	場合によっては自分で考えた,
	またはランダムに生成されたシードがあります.  あなたが S/KEY
	を初期化しようとしているマシンへの通信路が, 信頼できな
	いものである場合には <command>keyinit -s</command>
	コマンドを以下のように使用しま す:</para>

      <!-- kuriyama - missed by nik? -->
      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating wollman:
Old key: kh94741
Reminder you need the 6 English words from the skey command.
	) `keyinit' コマンドが出力する注意です. 訳すと,
	) 注意 - skey コマンドの出力する 6 英単語が必要になります.
<prompt>Enter sequence count from 1 to 9999:</prompt> <userinput>100</userinput>	) ここを入力.
<prompt>Enter new key [default kh94742]:</prompt> 		) リターンのみ入力.
s/key 100 kh94742</screen>

      <para>デフォルトのシード (<command>keyinit</command>
	プログラムは困ったことにこれを <literal>key</literal> と
	読んでいるのですが, 混乱しないよう注意してください)
	で構わなければ, リ ターンキーを押してください. 次に,
	あらかじめ用意しておいた信頼できる通 信路
	(信頼できるマシンや信頼できる S/KEY デスクアクセサリなど)
	へ移っ て, 先ほどと同じパラメタを入力します.</para>

      <screen>$prompt.user; <userinput>key 100 kh94742</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
<prompt>Enter secret password:</prompt> 		) ここで秘密のパスフレーズを入力します.
HULL NAY YANG TREE TOUT VETO</screen>

      <para>ここで信頼できない通信路の方に戻って,
	<command>key</command> コマンドが出力したワ
	ンタイムパスワードをコピーして <command>keyinit</command>
	プログラムに入力します.</para>

      <screen><prompt>s/key access password:</prompt> <userinput>HULL NAY YANG TREE TOUT VETO</userinput>
ID wollman s/key is 100 kh94742
HULL NAY YANG TREE TOUT VETO</screen>

      <para>後は, 前章で説明したことと同様です.</para>
    </sect2>

    <sect2>
      <title>ちょっと寄り道: ログインプロンプトについて</title>

      <para>どうやってワンタイムパスワードを生成するかを説明する前に,
	S/KEY を 使う場合のログインプロンプトを
	見ておいた方がよいでしょう.</para>

      <screen>&prompt.user; <userinput>telnet himalia</userinput>
Trying 18.26.0.186...
Connected to himalia.lcs.mit.edu.
Escape character is '^]'.
s/key 92 hi52030
<prompt>Password:</prompt></screen>

      <para>パスワードを要求する前に,
	ログインプログラムがシーケンス番号とシードを
	表示していることがわかります.
	この二つのパラメタを使ってワンタイムパ
	スワードを計算することになります.
	ここではまだ使っていませんが, 便利な
	機能がログインプログラムに備わっています:
	パスワードプロンプトに対して,
	何も入力せずにリターンを押すとエコーモードに切り替わります.
	つまりタイ プした文字がそのまま見えるようになるのです. これは
	S/KEY のワンタイム パスワードを紙に印刷していた場合など,
	ワンタイムパスワードを手で入力し
	なければならない場合に特に役立つ機能です.</para>

      <para>このログインしようとしてるマシンが,
	あなたが今使っているマシンから UNIX
	パスワードを使ってログインすることができないように
	設定されている 場合があります. その場合には,
	ログインプロンプトには S/KEY のワンタイ
	ムパスワードの利用が必要であることを示す <literal>(s/key
	  required)</literal>  という注釈が表示されます.</para>
    </sect2>

    <sect2>
      <title>ワンタイムパスワードを生成する</title>

      <para>次に前章のログインプロンプトに対して入力するための
	ワンタイムパスワー ドを生成しましょう. そのために,
	信頼できるマシンと <command>key</command> プログラ
	ムを使用します. (<command>key</command> プログラムには DOS や
	Windows の上で動くも の,
	Macintoshのデスクアクセサリとして動くものなどもあります.)
	コマンド ラインで <command>key</command>
	プログラムを起動するときには, シーケンス番号とシー
	ドを引数として指定します. 入力が面倒な人は,
	ログインプロンプトに表示さ れたもののうちで
	<literal>key</literal> からその行の最後までを,
	そのままカットア ンドペーストすることもできます.
	<command>key</command> プログラムの実行は以下のよ
	うになります:</para>

      <screen>&prompt.user; <userinput>key 92 hi52030</userinput>				) 前章の例からペースト.
Reminder - Do not use this program while logged in via telnet or rlogin.
<prompt>Enter secret password:</prompt> 				) 秘密のパスフレーズを入力.
ADEN BED WOLF HAW HOT STUN</screen>

      <para>そして別のウィンドウで:</para>

      <screen>s/key 92 hi52030				) 前章の例の続き.
<prompt>Password:</prompt>					) ここでリターンキーを押した.
 (turning echo on)
<prompt>Password:</prompt>ADEN BED WOLF HAW HOT STUN
Last login: Wed Jun 28 15:31:00 from halloran-eldar.l
[以下略.]</screen>

      <para>以上の手順は, 信頼できるマシンが利用できる場合
	<emphasis>のみに</emphasis> 使えるもっ とも簡単な方法です.
	Java S/Key の <command>key</command> applet もあり,  <ulink
	  URL="http://www.cs.umd.edu/~harry/jotp/src.html">The Java
	  OTP Calculator</ulink> からダウンロードして  Java
	をサポートするブラウザ上でローカルに
	実行することができます.</para>
    </sect2>

    <sect2>
      <title>複数のワンタイムパスワードを生成する</title>

      <para>都合によっては,
	信頼できるマシンや信頼できる通信路が一切確保できな
	いようなところで S/KEY を使う必要があるでしょう.
	このような場合には, <command>key</command>
	コマンドを使って複数のワンタイムパスワードを一気に生成する
	ことが可能です.
	そして結果を紙に印刷して携帯していくことができます. 例
	えば:</para>

      <screen>&prompt.user; <userinput>key -n 25 57 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
<prompt>Enter secret password: </prompt>
33: WALT THY MALI DARN NIT HEAD
34: ASK RICE BEAU GINA DOUR STAG 
[...]
56: AMOS BOWL LUG FAT CAIN INCH  
57: GROW HAYS TUN DISH CAR BALM  </screen>

      <para><option>-n 25</option> という引数によって 25
	個のワンタイムパスワードの生成を要 求します. ここで
	<option>57</option> は,
	<emphasis>最後に表示されている</emphasis> (もっとも大き い)
	シーケンス番号です. 残りのパラメタは前出の例と同様です.
	出力は普 通に使う順番とは <emphasis>逆</emphasis>
	に出力されていることに注意してください (訳注:
	一番最初に使うワンタイムパスワードは
	一番最後に出力されたものです). こ
	の結果をカットアンドペーストして <command>lpr</command>
	コマンドを使って印刷すると よいでしょう.
	もしあなたがセキュリティに偏執するなら, この結果を紙と鉛
	筆を使って手で書き移した方がよいかもしれません. ここで,
	出力の各行はシー
	ケンス番号とそれに対応する一回分のワンタイムパスワードです.
	消費済みの ワンタイムパスワードの行をペンで消していくと
	便利でしょう.</para>
    </sect2>

    <sect2>
      <title>UNIX パスワードの利用を制限する</title>

      <para>設定ファイル <filename>/etc/skey.access</filename>
	を使って UNIX パスワードの利
	用を制限することができます. この場合の判断基準として,
	ログインを受け付
	ける際のホスト名, ユーザ名, 端末のポート, IP
	アドレスなどが利用できま
	す. この設定ファイルの詳細に関してはマニュアル
	&man.skey.access.5; を
	ご覧ください. マニュアルにはこの機能に関わるセキュリティに
	ついて, いく
	つかの警告が記述してあります. この機能を使って
	セキュリティを高めようと
	するのならば絶対にこのマニュアルを読んでください.</para>

      <para>もし <filename>/etc/skey.access</filename>
	ファイルが存在しないならば (FreeBSD
	をインストールした直後の状態では存在しません),
	すべてのユーザが UNIX  パスワードを利用することができます.
	逆に, もしファイルが存在するならば,
	<filename>/etc/skey.access</filename>
	ファイルに明示的に記述されていない限り, すべ てのユーザは
	S/KEY の利用を要求されます. どちらの場合においても, その
	マシンのコンソールからはいつでも UNIX
	パスワードを使ってログインするこ とが可能です.</para>

      <para>以下によく使われるであろう
	三種類の設定を含む設定ファイルの例を示し ます:</para>

      <programlisting>
permit internet 18.26.0.0 255.255.0.0
permit user jrl
permit port ttyd0</programlisting>

      <para>はじめの行 (<literal>permit internet</literal>) で, telnet
	などで接続するときの IP  のソースアドレス (注意:
	これは偽造されるおそれがあります) が特定の値と
	マスクに一致している場合に, UNIX
	パスワードの利用を許可することを指定 しています.
	この設定自体はセキュリティを高めるための機能ではありません.
	そうではなく, ログインの権利を持つ許可されたユーザに対して,
	現在そのユー
	ザが使っているネットワークが信頼できないと考えられるので S/KEY
	を使う べきである,
	ということを気づかせるための機能であると考えてください.</para>

      <para>二行目 (<literal>permit user</literal>) によって,
	ある特定のユーザに対して, い つでも UNIX
	パスワードの利用を許可するように指定しています. 一般的には
	この設定をおこなうべきではありません. <command>key</command>
	プログラムがどうして も使えない環境にいる人や,
	ダム端末しかない環境にいる人, または何度教え
	ても聞く耳を持たないような人を
	サポートする必要がある場合にのみ設定をお
	こなってください.</para>

      <para>三行目 (<literal>permit port</literal>) によって,
	ある特定の端末ポートからログ
	インしようとするすべてのユーザに対して UNIX
	パスワードの利用を許可する ように指定しています.
	この設定はダイヤルアップ回線に対する設定として利
	用できるでしょう.</para>
    </sect2>
  </sect1>

  <sect1 id="kerberos">
    <title>Kerberos</title>

    <para><emphasis>原作: &a.markm;
	(&a.md; からの寄稿に基づいています).</emphasis></para>

    <para><emphasis>訳: &a.jp.arimura;.</emphasis></para>

    <para>Kerberosは,
      サーバのサービスによってユーザが安全に認証を受けられる
      ようにするための, ネットワークの付加システム及びプロトコルです.
      リモートログイン, リモートコピー,
      システム間での安全なファイルのコピ
      ーやその他のリスクの高い仕事がかなり安全に,
      そしてこれまでより制御 できるようになります.</para>

    <para>以下の文章は,
      FreeBSD用として配布されているKerberosをセットアップ
      する際のガイドとして読むことができます.  しかし,
      完全な説明が必要な場合には, マニュアルページを読んだ方がよい
      でしょう.</para>

    <para>FreeBSDのKerberosは,
      オリジナルの4.4BSD-Liteの配布に含まれている ものではなく,
      FreeBSD 1.1.5.1のときに移植されたeBonesです.
      これはアメリカ/カナダの外で作成されており,
      これら以外の国の人々にも 手に入れられるものです.</para>

    <para>このソフトウェアを合法的な配布物として得るために, アメリカも
      しくはカナダのサイトから
      <emphasis>持ってこないでください</emphasis>.   でないと,
      そのサイトが<emphasis>大変な</emphasis>問題に巻き込まれます.
      合法的な配布は, 南アフリカの<hostid
	role="fqdn">ftp.internat.freebsd.org</hostid>や, FreeBSD
      の公式ミラーサイトから入手することができます.</para>

    <sect2>
      <title>初期データベースの作成</title>

      <para>この作業はKerberosサーバだけでおこないます. まず,
	古いKerberosの データベースが存在しないことを確認してください.
	ディレクトリ<filename>/etc/kerberosIV</filename>に移って,
	次のファイルだけが 存在することをチェックします:</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README          krb.conf        krb.realms</screen>

      <para>もし他のファイル (<filename>principal.*</filename> や
	<filename>master_key</filename>) が 存在する場合には,
	<command>kdb_destroy</command>というコマンドで古い
	Kerberosデータベースを消してください.
	Kerberosが走っていなければ,
	単に余計なファイルを消せばよいです.</para>

      <para>まず, <filename>krb.conf</filename> と
	<filename>krb.realms</filename>を編集してKerberosの 管理領域
	(realm) を定義してください.
	ここでは管理領域が<filename>GRONDAR.ZA</filename> で,
	サーバ名が<filename>grunt.grondar.za</filename>であるとします.
	<filename>krb.conf</filename>
	というファイルを次のように編集してください:</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
GRONDAR.ZA
GRONDAR.ZA grunt.grondar.za admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>この例にあるような他の管理領域は, 実際には必要ありません.
	この例は複数の管理領域を認識する方法を示したものですので,
	これらの行は含めなくても結構です.</para>

      <para>1行目はこのシステムが動いている管理領域の名前です.
	他の行は管理領域とホスト名のエントリです.
	行の1つめの単語が管理領域で, 2つめがその管理領域の中で
	&ldquo;鍵配布センター&rdquo;(Key Distribution Center)
	として働くホスト名です.  ホスト名の次に <literal>admin
	  server</literal> と書いてある場合には, そのホストが
	``管理データベースサーバ''(Administrative Database Server)
	も提供 することを意味します.
	これらの単語について詳しく知りたい場合にはKerberosのマニュアル
	ページをご覧ください.</para>

      <para>ここで,
	<filename>GRONDAR.ZA</filename>という管理領域に<hostid
	  role="fqdn">grunt.grondar.za</hostid> およびその他の<hostid
	  role="domainname">.grondar.za</hostid>
	ドメインのすべてのホストを追加し なければなりません.
	<filename>krb.realms</filename>は次のようになります:</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.grondar.za GRONDAR.ZA
.grondar.za GRONDAR.ZA
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>もう一度注意しますが, 他の管理領域を書く必要はありません.
	これらは複数の管理領域を認識できるようにマシンを設定する方法を
	示した例ですので, これらの行は消して構いません.</para>

      <para>1行目は名前をつけた管理領域に <emphasis>特定の</emphasis>
	システムを含めるための ものです.
	残りの行は名前をつけた管理領域にサブドメインのデフォルトの
	システムを含めるためのものです.</para>

      <para>これでデータベースを作成する準備ができました.
	この操作はKerberos サーバ (鍵配布センター) を起動するだけです.
	<command>kdb_init</command>コ
	マンドを次のように実行してください:</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]: </prompt> <userinput>GRONDAR.ZA</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

<prompt>Enter Kerberos master key:</prompt> </screen>

      <para>ここで鍵を保存して,
	ローカルのマシンにあるサーバが取り出せるように します.
	それには<command>kstash</command>コマンドを使用します.</para>

      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>これで暗号化されたマスタパスワードが
	<filename>/etc/kerberosIV/master_key</filename>
	に保存されました.</para>
    </sect2>

    <sect2>
      <title>すべてが動くようにするための設定</title>

      <para>Kerberosを導入する <emphasis>それぞれの</emphasis>
	システムのデータベースに, 2つ のprincipal (主体名)
	を追加する必要があります. その名前は
	<literal>kpasswd</literal>と<literal>rcmd</literal>です.
	これら2つのprincipalは, 個々 のシステムにおいて,
	システム名と同じ名前のインスタンスと組にして作成
	されます.</para>

      <para>これらの <command>kpasswd</command> と
	<command>rcmd</command> というデーモンによって, 他の
	システムからKerberosのパスワードを変更したり,
	<command>rcp</command>や <command>rlogin</command>,
	<command>rsh</command>といったコマンドを実行したりできるよ
	うになります.</para>

      <para>それでは実際にこれらのエントリを追加しましょう:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください

<prompt>Random password [y] ? </prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>
    </sect2>

    <sect2>
      <title>サーバファイルの作成</title>

      <para>次に, 各マシンにおけるサービスを定義している,
	すべてのインスタンス を展開します.
	これには<command>ext_srvtab</command>というコマンドを使用しま
	す. このコマンドで作成されるファイルは, Kerberosの各クライアン
	トの/etc/kerberosIVディレクトリに
	<emphasis>安全な方法で</emphasis>コピーまたは
	移動する必要があります. このファイルはそれぞれのサーバとクラ
	イアントに存在しなければならず,
	またKerberosの運用において重要なも のです.</para>

      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>このコマンドは一時的なファイルを作成するだけです.
	ファイル名をすべ てのサーバが読めるような
	<filename>srvtab</filename> という名前に変更しな
	ければなりません.
	<command>mv</command>コマンドを用いてシステムの場所に移動
	してください.</para>

      <screen>&prompt.root; mv grunt-new-srvtab srvtab</screen>

      <para>そのファイルがクライアントに配るためのもので,
	ネットワークが安全で はないと思われる場合には, <filename>
	  <replaceable>client</replaceable>-new-srvtab</filename>
	を移動
	可能なメディアにコピーして物理的に安全な方法で運んでください.
	クラ
	イアントの<filename>/etc/kerberosIV</filename>ディレクトリで,
	名前を <filename>srvtab</filename>に変更し,
	modeを600にするのを忘れないでください:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>データベースへのユーザの追加</title>

      <para>ここで,
	ユーザのエントリをデータベースに追加する必要があります.
	始めに,
	ユーザ<username>jane</username>のエントリを作成してみましょう.
	<command>kdb_edit</command>
	を用いて次のように作成してください:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- 安全なパスワードを入れてください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- もう一度パスワードを入れてください

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>
    </sect2>

    <sect2>
      <title>すべてのテスト</title>

      <para>まず始めにKerberosデーモンを起動する必要があります.
	<filename>/etc/rc.conf</filename>
	ファイルを正しく編集してあれば, マシンを再
	起動することでに自動的にデーモンが起動します.
	これはKerberosサー バでのみ必要です.
	Kerberosクライアントは<filename>/etc/kerberosIV</filename>か
	ら必要なものを自動的に入手します.</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered.  BEWARE!

Current Kerberos master key version is 1
Local realm: GRONDAR.ZA
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>さあ, これで上で作成した <username>jane</username>
	というIDのチケットを
	<command>kinit</command>コマンドで得ることができます:</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.grondar.za)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para><command>klist</command> コマンドを用いてトークンを見て,
	きちんとチケットを持って いるかどうか確認してください:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:    jane@GRONDAR.ZA

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.GRONDAR.ZA@GRONDAR.ZA</screen>

      <para><command>passwd</command>
	コマンドを用いてパスワードを変更して, kpasswdデーモ
	ンがKerberos
	データベースに対して認証されるかどうかチェックして
	ください:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm GRONDAR.ZA
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title><command>su</command>特権の追加</title>

      <para>root権限が必要なユーザは<emphasis>誰でも</emphasis>,
	<command>su</command>コマンドのパス
	ワードをユーザ毎に<emphasis>別のもの</emphasis>
	として持つことができます.
	<username>root</username>に<command>su</command>
	できる権利を与えられたidを追加します.  これは,
	principalに付いている<username>root</username>
	というインスタンスに よって制御されています.
	<command>kdb_edit</command>を用いて
	<literal>jane.root</literal>というエントリを
	Kerberosデータベースに作成します:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- 安全なパスワードを入れます
Verifying password

<prompt>New Password:</prompt>                    &lt;---- もう一回パスワードを入れます

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- ここは短くしてください
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>

      <para>実際にトークンをもらって,
	ちゃんと働いているかどうか確認しましょう:</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.grondar.za)
Kerberos Initialization for "jane.root"
<prompt>Password: </prompt></screen>

      <para>ここでrootユーザの <filename>.klogin</filename>
	ファイルにユーザを追加する必要が あります.</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@GRONDAR.ZA</screen>

      <para><command>su</command>してみましょう:</para>

      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password: </prompt></screen>

      <para>どのトークンを持っているか見てみましょう:</para>

      <screen>&prompt.root; klist
Ticket file:	/tmp/tkt_root_245
Principal:	jane.root@GRONDAR.ZA

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.GRONDAR.ZA@GRONDAR.ZA</screen>
    </sect2>

    <sect2>
      <title>他のコマンドの使用</title>

      <para>ここまでの例では, <literal>jane</literal> という principal
	を <literal>root</literal> とい
	うインスタンス付きで作成しました.
	これはユーザと同じ名前をprincipalと しており,
	Kerberosのデフォルトの値です;
	<literal>&lt;username&gt;.</literal><literal>root</literal>
	という形式の
	<literal>&lt;principal&gt;.&lt;instance&gt;</literal>で,
	必要なエント
	リが<username>root</username>のホームディレクトリの
	<filename>.klogin</filename>ファイルに あれば,
	<literal>&lt;username&gt;</literal>がrootに
	<command>su</command>することができま す.</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@GRONDAR.ZA</screen>

      <para>同様に, ユーザのホームディレクトリの
	<filename>.klogin</filename>ファイルに次の
	ような行がある場合には:</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@GRONDAR.ZA
jack@GRONDAR.ZA</screen>

      <para><username>jane</username> または <username>jack</username>
	という名前で (前述の<command>kinit</command> によって)
	認証されている <filename>GRONDAR.ZA</filename>
	という管理領域のユーザ なら誰でも<command>rlogin</command> や
	<command>rsh</command>, <command>rcp</command>等によってこ
	のシステム (<hostid>grunt</hostid>)
	の<username>jane</username>のアカウントまたはファ
	イルにアクセスできます.</para>

      <para>例えば, Janeが他のシステムにKerberos
	を用いてloginします:</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.grondar.za)
<prompt>Password: </prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>次の例では, Jackが同じマシンの Jane
	のアカウントにloginします. Janeは <filename>.klogin</filename>
	ファイルを前述のように設定しており,
	Kerberosでは<emphasis>jack</emphasis>というprincipal
	をインスタンスなしで設定してあ ります.</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.grondar.za)
<prompt>Password: </prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="firewalls">
    <title>ファイアウォール</title>

    <para><emphasis>原作: &a.gpalmer;, &a.alex;.</emphasis></para>

    <para><emphasis>訳: &a.jp.saeki;.<!-- <br> -->
	11 November 1996.</emphasis></para>

    <para>ファイアウォールは,
      インターネットに参加している人はもちろんのこと,
      プライベートネットワークのセキュリティ向上のための
      アプリケーションを 探している人にとっても,
      ますます興味深くなりつつある分野です.
      このセクションではファイアウォールとは何か,
      ファイアウォールの使用法,
      そしてファイアウォールを構築するために FreeBSD のカーネルで
      提供されているファシリティ (機能)
      の使用法について説明したいと思います.</para>

    <note>
      <para>社内のネットワークと &ldquo;巨大かつ信頼のおけない
	インターネット&rdquo; との間にファイアウォールを構築することで
	セキュリティ上のすべての問題が解決できると考える人がいます.
	ファイアウォールはセキュリティ上の問題を
	解決する助けになる場合もありますが,
	充分な設定がなされていないファイアウォールは,
	まったくファイアウォールを
	持たない場合よりもセキュリティ上の危険を増大させてしまいます.
	ファイアウォールにできることは,
	あなたのシステムにもう一つのセキュリティ層を
	追加することだけで,
	本気でアタックをしかけてくるクラッカーが内部ネットワークに
	侵入するのを妨げることはできません.
	ファイアウォールを侵入不可能と過信して
	内部のセキュリティをおろそかにすることは,
	単にクラッカーの仕事を少し簡単にするだけでしか
	ありません.</para>
    </note>

    <sect2>
      <title>ファイアウォールとは何か ?</title>

      <para>現在インターネットで普通に使用されている
	ファイアウォールには 二つの異なるタイプがあります.  一つは,
	厳密には <emphasis> パケットフィルタリングルータ </emphasis>
	と 呼ばれるタイプのものです. これはマルチホームのホストマシン
	(複数の ネットワークに接続されているマシン) のカーネルが,
	ある規則にしたがって
	パケットを転送したりブロックしたりするものです.  もう一つは,
	<emphasis> proxy (代理) サーバ </emphasis>
	として知られているタイプのものです.  これは,
	おそらくはマルチホームのホストマシン上で,
	カーネルによるパケット転送を 禁止して,
	デーモンにより認証の提供とパケットの転送とを
	おこなうものです.</para>

      <para>二つのタイプのファイアウォールを組み合わせて使用して,
	特定のマシン (<emphasis> 要塞ホスト </emphasis> と呼ばれる)
	だけが パケットフィルタリングルータを通して内部ネットワークへ
	パケットを送ることができるよう設定している
	サイトがしばしば存在します.  proxy (代理)
	サービスは通常の認証メカニズムよりもセキュリティを
	強化してある 要塞ホストで動作させます.</para>

      <para>FreeBSD は (<application>IPFW</application>
	として知られる) カーネルパケットフィルタ込みで
	提供されています. このセクションの後の方では,
	このフィルタについての 説明を集中しておこないます.
	サードパーティから提供されるソフトウェアを使用することにより,
	Proxy サーバを FreeBSD 上に構築することができます. しかし,
	現在入手可能な proxy サーバは
	たいへんバラエティに富んでいるので,
	このドキュメントでそれらすべてを
	カバーすることは不可能です.</para>

      <sect3 id="firewalls-packet-filters">
	<title>パケットフィルタリングルータ</title>

	<para>ルータとは, 二つまたはそれ以上のネットワークの間で
	  パケットの転送をおこなう マシンのことです.
	  パケットフィルタリングルータは, そのカーネルの内部に,
	  一つ一つのパケットをルールリストと比較して
	  転送するかしないかを決める 特別なコードを持っています.
	  最近の IP ルーティングソフトウェアのほとんどは, 内部に
	  パケットのフィルタリングをおこなうためのコードを持っていて,
	  デフォルトでは すべてのパケットを転送するようになっています.
	  このフィルタを有効にするためには,
	  パケットの通過を許すべきかどうかを決める
	  ルールを自分で定義する必要があります.</para>

	<para>パケットを通すべきか通すべきでないかを決めるために,
	  パケットヘッダの内容にマッチするものが
	  ルールリストから探されます.  マッチするルールが見つかると,
	  ルールアクションが実行されます.  ルールアクションには,
	  パケットを捨てる, パケットを転送する,
	  またはパケットの発信元に ICMP
	  メッセージを送り返すというものがあります.
	  ルールの検索は先頭から順番におこなわれ,
	  通常は最初にマッチしたものだけが 適用されます.  そのため,
	  このルールリストは &ldquo;ルールチェーン&rdquo;
	  と呼ばれることもあります.</para>

	<para>パケットマッチングの基準は使用するソフトウェアに
	  よって異なりますが,  通常はパケットの発信元 IP アドレス,
	  宛先 IP アドレス, 発信元ポート番号,  宛先ポート番号
	  (ポート番号はポートをサポートするプロトコルの場合のみ),
	  パケットタイプ (UDP, TCP, ICMP など)
	  に基づくルールを指定することができます.</para>
      </sect3>

      <sect3 id="firewalls-proxy-servers">
	<title>Proxy サーバ</title>

	<para>Proxy サーバとは通常のシステムデーモン (telnetd, ftpd
	  など) を 特別なサーバで置き換えたマシンのことです.
	  これらのサーバは,
	  通常は中継をおこなって特定方向への接続だけを許すため,
	  <emphasis>proxy サーバ </emphasis> と呼ばれます.  (例えば)
	  proxy telnet
	  サーバをファイアウォールホストで走らせておきます.
	  外部からユーザがファイアウォールに対して telnet
	  を実行すると,  proxy telnet サーバが応答して,
	  何らかの認証メカニズムを実行します.  これを通過した後で,
	  内部ネットワークへのアクセスがおこなえるように なるのです.
	  (内部ネットワークからの信号は proxy
	  サーバがかわりに受け取り,  外へ向けて送り出します.)</para>

	<para>Proxy サーバは通常,
	  普通のサーバより堅固に構築されていて,  しばしば
	  &ldquo;使い捨て&rdquo; パスワードシステムなどを含む,
	  多様な認証メカニズムを持っています.
	  &ldquo;使い捨て&rdquo;パスワードシステムとは,
	  どういうものなのでしょうか.  仮に誰かが何らかの方法で,
	  あなたが使用したパスワードを手に入れたとします.  しかし,
	  一度使用したことで,
	  そのパスワードは既に無効になっているのです.  ですから,
	  そのパスワードをもう一度使用したとしても, あなたのシステムへ
	  アクセスすることはできないというわけです.
	  これらのサーバは中継をおこなうだけで,
	  実際のところサーバホスト自身への
	  アクセスをユーザに許してはいません. そのため,
	  何者かがセキュリティシステムに
	  侵入用の裏口を取り付けることは,
	  より困難になっています.</para>

	<para>proxy サーバはアクセス制限の方法をいくつも持っていて,
	  特定のホスト
	  だけがサーバへのアクセス権を得ることができるように
	  なっていることがあり ます.
	  そして目的のマシンと通信できるユーザを制限するように
	  設定することもできます.  もう一度言いますが,
	  どんなファシリティ (機能) が使えるかは,  どんな proxy
	  サービスをおこなうソフトウェアを選ぶかに大きく
	  依存します.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>IPFW で何ができるか</title>

      <para>FreeBSD とともに配布されている
	<application>IPFW</application> は, カーネル内部にあって
	パケットのフィルタリングとアカウンティングを
	おこなうシステムであり,
	ユーザ側のコントロールユーティリティである &man.ipfw.8; を
	含んでいます. ルーティングの決定をおこなう際に,
	これらは互いに協力して,
	カーネルで使用されるルールを定義したり,
	現在使用されているルールを
	問い合わせたりすることができます.</para>

      <para><application>IPFW</application>
	は互いに関連する二つの部分からなっています.
	ファイアウォールセクションは
	パケットフィルタリングをおこないます.  また, IP
	アカウンティングセクションはファイアウォールセクションのものと
	似たルールに基づいてルータの使用を追跡します.  これにより,
	(例えば) 特定のマシンからルータへのトラフィックがどのくらい
	発生しているか調べたり, どれだけの WWW (World Wide Web)
	トラフィックが
	フォワードされているかを知ることができます.</para>

      <para><application>IPFW</application> は,
	ルータではないマシンにおいても入出力コネクションの
	パケットフィルタリングのために
	使用することができるように設計されています.  これは一般的な
	<application>IPFW</application>
	の使用法とは異なる特別な使い方ですが,
	こういった状況でも同じコマンドと
	テクニックが使用されます.</para>
    </sect2>

    <sect2>
      <title>FreeBSD で IPFW を有効にする</title>

      <para><application>IPFW</application>
	システムの中心となる部分はカーネル内部にあります.  そのため,
	どのファシリティ (機能) を必要とするかによって, 一つまたは
	それ以上のオプションをカーネルコンフィグレーション
	ファイルに追加し,
	カーネルを再コンパイルする必要があるでしょう.
	カーネルの再コンパイル方法の詳細については,  <link
	  linkend="kernelconfig">カーネルコンフィグレーション</link>
	を参照してください.</para>

      <para>現在, IPFW
	に関係するカーネルコンフィグレーションオプションは
	三つあります:</para>

      <variablelist>
	<varlistentry><term><literal>options IPFIREWALL</literal></term>
	  <listitem>
	    <para>パケットフィルタリングのためのコードを
	      カーネルに組み込みます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><literal>
	      options IPFIREWALL_VERBOSE</literal></term>
	  <listitem>
	    <para>&man.syslogd.8; を通じて
	      パケットのログを取るためのコードを有効にします.
	      フィルタルールでパケットのログを取るように指定しても,
	      このオプションが指定されていなければ,
	      ログを取ることはできません.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><literal>
	      options IPFIREWALL_VERBOSE_LIMIT=10</literal></term>
	  <listitem>
	    <para>&man.syslogd.8; を通じて
	      ログを取るパケットの数をエントリ毎に制限します.
	      敵対的な環境においてファイアウォールの
	      動作のログを取りたいけれど,
	      syslog の洪水によるサービス拒絶攻撃に対し
	      無防備でありたくないという場合に,
	      このオプションを使用したいと思うことが
	      あるかもしれません.</para>

	    <para>チェーンエントリのログが指定された制限数に達すると,
	      そのエントリに関するログ取りは停止されます.
	      ログ取りを再開するには, &man.ipfw.8;
	      ユーティリティを使用して
	      関連するカウンタをリセットする必要があります:</para>

	    <screen>&prompt.root; <userinput>ipfw zero 4500</userinput></screen>

	    <para>4500 とは,
	      ログ取りを続行したいチェーンエントリの番号です.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>以前のバージョンの FreeBSD は
	<literal>IPFIREWALL_ACCT</literal> というオプションを
	持っていました.  しかし,
	ファイアウォールコードがアカウンティングファシリティ (機能) を
	自動的に含むようになったため,
	現在では使用されることはなくなっています.</para>
    </sect2>

    <sect2>
      <title>IPFW の設定</title>

      <para><application>IPFW</application> ソフトウェアの設定は
	&man.ipfw.8; ユーティリティを
	通じておこないます. このコマンドの構文は非常に
	複雑に見えますが,
	一旦その構造を理解すれば比較的単純です.</para>

      <para>このユーティリティでは今のところ四つの異なる
	コマンドカテゴリが 使用されています: それは追加 / 削除, 表示,
	フラッシュ, およびクリアです.  追加 /
	削除はパケットの受け入れ, 拒絶, ログ取りをどのようにおこなうか
	というルールを構築するのに使用します.  表示はルールリスト
	(またはチェーン) と (アカウンティング用) パケットカウンタの
	内容を調べるのに使用します.
	フラッシュはチェーンからすべてのエントリを
	取り除くのに使用します.
	クリアは一つまたはそれ以上のアカウンティングエントリを
	ゼロにするのに 使用します.</para>

      <sect3>
	<title>IPFW ルールの変更</title>

	<para>この形式での使用法は:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-N</arg>
	    <arg choice="plain">コマンド</arg>
	    <arg>index</arg>
	    <arg choice="plain">アクション</arg>
	    <arg>log</arg>
	    <arg choice="plain">プロトコル</arg>
	    <arg choice="plain">アドレス</arg>
	    <arg>オプション</arg>
	  </cmdsynopsis>
	</para>

	<para>この形式で使用する際に有効なフラグは一つだけです:</para>

	<variablelist>
	  <varlistentry><term>-N</term>
	    <listitem>
	      <para>アドレスやサービス名を
		文字列に変換して表示します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para><emphasis> コマンド </emphasis>
	  は一意である限り短縮可能です.  有効な <emphasis> コマンド
	  </emphasis> は:</para>

	<variablelist>
	  <varlistentry><term>add</term>
	    <listitem>
	      <para>ファイアウォール / アカウンティングルールリストに
		エントリを追加します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>delete</term>
	    <listitem>
	      <para>ファイアウォール /
		アカウンティングルールリストから
		エントリを削除します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>以前のバージョンの <application>IPFW</application> では,
	  ファイアウォールエントリと
	  パケットアカウンティングエントリが別々に利用されていました.
	  現在のバージョンでは, それぞれのファイアウォールエントリ毎に
	  パケットアカウンティングエントリが備えられています.</para>

	<para><emphasis>index</emphasis> が指定されていると,
	  エントリはチェーン中の <emphasis remap=tt>index</emphasis>
	  で示される位置に置かれます. <emphasis
	    remap=tt>index</emphasis> が指定されて いなければ,
	  エントリは (65535 番のデフォルトルールである
	  パケット拒絶を別にして) 最後のチェーンエントリの index に
	  100 を足した 位置 (チェーンの最後) に置かれます.</para>

	<para>カーネルが <literal>IPFIREWALL_VERBOSE</literal>
	  つきでコンパイルされている場合,  <literal>log</literal>
	  オプションはマッチしたルールを
	  システムコンソールに出力させます.</para>

	<para>有効な <emphasis> アクション </emphasis> は:</para>

	<variablelist>
	  <varlistentry><term>reject</term>
	    <listitem>
	      <para>パケットを捨てます, ICMP ホスト /
		ポート到達不能パケットを (適切な方を)
		発信元へ送ります.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>allow</term>
	    <listitem>
	      <para>通常通りパケットを通過させます. (別名:
		<literal>pass</literal> および
		<literal>accept</literal>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>deny</term>
	    <listitem>
	      <para>パケットを捨てます. 発信元は ICMP メッセージによる
		通知を受けません (そのためパケットが
		宛先に到達しなかったように見えます).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>count</term>
	    <listitem>
	      <para>このルールはパケットカウンタを更新するだけで,
		パケットを 通過させたり拒絶したりしません.
		検索は次のチェーンエントリから続けられます.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>それぞれの <emphasis> アクション </emphasis>
	  は一意な先頭部分だけでも認識されます.</para>

	<para>指定可能な <emphasis> プロトコル </emphasis>
	  は以下の通り:</para>

	<variablelist>
	  <varlistentry><term>all</term>
	    <listitem>
	      <para>任意の IP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>icmp</term>
	    <listitem>
	      <para>ICMP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>tcp</term>
	    <listitem>
	      <para>TCP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>udp</term>
	    <listitem>
	      <para>UDP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para><emphasis> アドレス </emphasis> の指定は:</para>
	<cmdsynopsis>
	  <arg choice="plain">from</arg>
	  <arg choice="plain"><replaceable>address/mask</replaceable></arg>
	  <arg><replaceable>port</replaceable></arg>
	  <arg choice="plain">to</arg>
	  <arg choice="plain"><replaceable>address/mask</replaceable></arg>
	  <arg><replaceable>port</replaceable></arg>
	  <arg>via <replaceable>interface</replaceable></arg>
	</cmdsynopsis>

	<para><replaceable>port</replaceable> はポートをサポートする
	  <emphasis> プロトコル </emphasis> (UDP と TCP) の
	  場合にだけ指定可能です.</para>

	<para><option>via</option> は必須ではなく,
	  特定のインターフェースを通ってきたパケット
	  だけにマッチするように, IP アドレスまたはローカル IP
	  インターフェースの ドメイン名, またはインターフェース名
	  (例えば <devicename>ed0</devicename>) を
	  指定することができます.
	  インターフェースユニット番号はオプションで,
	  ワイルドカードで指定することが できます. 例えば,
	  <literal>ppp*</literal> はすべてのカーネル PPP
	  インターフェースに マッチします.</para>

	<para><replaceable>address/mask</replaceable> の指定は:

	  <screen><replaceable>address</replaceable></screen>

	  または

	  <screen><replaceable>address</replaceable>/<replaceable>mask-bits</replaceable></screen>

	  または

	  <screen><replaceable>address</replaceable>:<replaceable>mask-pattern</replaceable></screen>
	</para>

	<para>IP
	  アドレスのかわりに有効なホスト名を指定することも可能です.
	  <option><replaceable>mask-bits</replaceable></option>
	  はアドレスマスクで上位何ビットを１にするべきかを
	  示す十進数値です. 例えば次の指定,
	  <literal>192.216.222.1/24</literal> はクラス C のサブネット
	  (この場合 192.216.222) の任意のアドレスにマッチする
	  マスクを作成します.
	  <option><replaceable>mask-pattern</replaceable></option>
	  は与えられたアドレスと 論理 AND される IP アドレスです.
	  キーワード <literal>any</literal> は&ldquo;任意の IP
	  アドレス&rdquo;を指定するために
	  使用することができます.</para>

	<para>ブロックするポート番号は以下のように指定します:

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>port</replaceable><arg>,
		<replaceable>port</replaceable><arg>,
		  <replaceable>port</replaceable><arg>&hellip;
		  </arg></arg></arg></arg>
	  </cmdsynopsis>

	  のように単独のポートまたはポートのリストを指定します.
	  または

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>port</replaceable>-
	      <replaceable>port</replaceable></arg>
	  </cmdsynopsis>

	  のようにポートの範囲を指定します.
	  単独のポートとポートのリストを
	  組み合わせて指定することも可能ですが,
	  その場合は常に範囲の方を
	  最初に指定しなければなりません.</para>

	<para>使用可能な <emphasis> オプション </emphasis> は:</para>

	<variablelist>
	  <varlistentry><term>frag</term>
	    <listitem>
	      <para>データグラムの最初の
		フラグメントでなければマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>in</term>
	    <listitem>
	      <para>入力途中のパケットであればマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>out</term>
	    <listitem>
	      <para>出力途中のパケットであればマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>ipoptions <replaceable>spec</replaceable></term>
	    <listitem>
	      <para>IP ヘッダが <replaceable>spec</replaceable>
		に指定された カンマで区切られた
		オプションのリストを含んでいればマッチします.
		サポートされている IP オプションのリストは:
		<literal>ssrr</literal> (ストリクトソースルート),
		<literal>lsrr</literal> (ルーズソースルート),
		<literal>rr</literal> (レコードパケットルート),
		そして <literal>ts</literal> (タイムスタンプ) です.
		特定のオプションを含まないことを指定するには
		<literal>!</literal> を先頭につけます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>established</term>
	    <listitem>
	      <para>パケットが既に確立されている TCP
		コネクションの一部であれば (つまり RST または ACK
		ビットがセットされていれば) マッチします.
		<emphasis>established</emphasis>
		ルールをチェーンの最初の方に置くことで,
		ファイアウォールのパフォーマンスを向上させることが
		できます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>setup</term>
	    <listitem>
	      <para>パケットが TCP
		コネクションを確立しようとするものであれば (SYN
		ビットがセットされ ACK ビットはセットされていなければ)
		マッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>tcpflags <replaceable>flags</replaceable></term>
	    <listitem>
	      <para>TCP ヘッダが <replaceable>flags</replaceable>
		に指定された カンマで区切られたフラグの
		リストを含んでいればマッチします.
		サポートされているフラグは, <literal>fin</literal>,
		<literal>syn</literal>, <literal>rst</literal>,
		<literal>psh</literal>, <literal>ack</literal> と
		<literal>urg</literal> です.
		特定のフラグを含まないことを指定するには
		<literal>!</literal> を先頭につけます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>icmptypes <replaceable>types</replaceable></term>
	    <listitem>
	      <para>ICMP タイプが <replaceable>types</replaceable>
		リストに 存在していればマッチします.
		リストはタイプの範囲または個々のタイプを
		カンマで区切った任意の組合せで指定できます.
		一般的に使用されている ICMP タイプは:
		<literal>0</literal> エコーリプライ (ping リプライ),
		<literal>3</literal> 相手先到達不可能,
		<literal>5</literal> リダイレクト,
		<literal>8</literal> エコーリクエスト (ping
		リクエスト), そして <literal>11</literal> 時間超過
		(&man.traceroute.8; で使用されているように,  TTL
		満了を示すのに使用されます) です.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>IPFW ルールリストの表示</title>

	<para>この形式での使用法は:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-a</arg>
	    <arg>-t</arg>
	    <arg>-N</arg>
	    <arg choice="plain">l</arg>
	  </cmdsynopsis>
	</para>

	<para>この形式で使用する際に有効なフラグは三つあります:</para>

	<variablelist>
	  <varlistentry><term>-a</term>
	    <listitem>
	      <para>リスト表示の際にカウンタの値も表示します.
		このオプションは アカウンティングカウンタの
		内容を見る唯一の手段です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>-t</term>
	    <listitem>
	      <para>各チェーンエントリが最後に
		マッチした時刻を表示します.  この時刻表示は
		  &man.ipfw.8; ユーティリティで使用される入力形式と
		互換性がありません.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>-N</term>
	    <listitem>
	      <para>(可能であれば)
		アドレスやサービス名を文字列に変換して表示します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>IPFW ルールのフラッシュ</title>

	<para>チェーンをフラッシュするには:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">flush</arg>
	  </cmdsynopsis>
	</para>

	<para>カーネルに固定されているデフォルトルール (インデックス
	  65535 番)  以外の,
	  ファイアウォールチェーンの中のすべてのエントリを削除します.
	  デフォルトではすべてのパケットが拒絶されるので,
	  一旦これを実行すると,
	  パケットを許可するエントリがチェーンに追加されるまで,
	  あなたのシステムがネットワークから切り放されてしまいます.
	  そのため,
	  ルールのフラッシュをおこなうときは注意が必要です.</para>
      </sect3>

      <sect3>
	<title>IPFW パケットカウンタのクリア</title>

	<para>一つまたはそれ以上のパケットカウンタをクリアするためには:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">zero</arg>
	    <arg choice="opt"><replaceable>index</replaceable></arg>
	  </cmdsynopsis>
	</para>

	<para><replaceable>index</replaceable> が指定されていなければ,
	  すべてのパケットカウンタが クリアされます.
	  <replaceable>index</replaceable> が指定されていれば,
	  特定のチェーンエントリだけが クリアされます.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>ipfw に対するコマンドの例</title>

      <para>このコマンドはルータを介して転送される,  ホスト <hostid
	  role="fqdn">evil.crackers.org</hostid> から ホスト <hostid
	  role="fqdn">nice.people.org</hostid> の telnet ポートへの
	すべてのパケットを拒絶します:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from evil.crackers.org to nice.people.org 23</userinput></screen>

      <para>次の例は, ネットワーク <hostid
	  role="domainname">crackers.org</hostid> (クラス C) 全体から
	マシン <hostid role="fqdn">nice.people.org</hostid>
	(の任意のポート) への 任意の TCP トラフィックを拒絶し,
	ログを取ります.</para>

      <screen>&prompt.root; <userinput>ipfw add deny log tcp from evil.crackers.org/24 to nice.people.org</userinput></screen>

      <para>あなたの内部ネットワーク (クラス C のサブネット) に対する
	X セッションを 張れないようにする場合,
	以下のコマンドで必要なフィルタリングがおこなえます:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to my.org/28 6000 setup</userinput></screen>

      <para>アカウンティングレコードを見るには:

	<screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

	または短縮形式で</para>

      <screen>&prompt.root; <userinput>ipfw -a l</userinput></screen>

      <para>最後にチェーンエントリがマッチした
	時刻を見ることもできます. </para>

      <screen>&prompt.root; <userinput>ipfw -at l</userinput></screen>
    </sect2>

    <sect2>
      <title>パケットフィルタリングファイアウォールの構築</title>

      <note>
	<para>以下の提案は, ただの提案にすぎません:
	  必要な処理はそれぞれのファイアウォールで異なるため,
	  あなた独自の要求にあったファイアウォールを構築する方法を
	  ここで述べることはできないのです.</para>
      </note>

      <para>最初にファイアウォールをセットアップするとき,
	コントロールされた環境でファイアウォールホストの
	設定がおこなえるような
	テストベンチセットアップが用意できない場合には,
	カーネルのログ取りを
	有効にしてログ取り版のコマンドを使用することを
	強くおすすめします.  そうすることで,
	大した混乱や中断なしに問題となる範囲の特定と処置を
	素早くおこなうことができます.
	初期セットアップフェーズが完了してからであっても,
	アタックの可能性のあるアクセスをトレースしたり,
	要求の変化に応じてファイアウォールルールを
	変更したりできるので,  `deny'
	に対するログ取りをおこなうことをおすすめします.</para>

      <note>
	<para><command>accept</command>
	  コマンドのログ取りをおこなっていると,
	  ファイアウォールをパケットが一つ通過する毎に 1
	  行のログが生成されるため <emphasis>大量の</emphasis>
	  ログデータが発生します.  そのため, 大規模な ftp/http
	  転送などをおこなうと, システムが非常に 遅くなってしまいます.
	  また, パケットが通過するまでにカーネルにより
	  多くの仕事を要求するため,  パケットのレイテンシ (latency)
	  を増加させてしまいます.  syslogd
	  もログをディスクに記録するなど, より多くの CPU タイムを
	  使用し始め, 実に容易に <filename>/var/log</filename>
	  が置かれているパーティションを
	  パンクさせてしまう可能性があります.</para>
      </note>

      <para>現状では, FreeBSD
	はブート時にファイアウォールルールをロードする
	能力を持っていません.  私は <filename>/etc/netstart</filename>
	スクリプトにロードをおこなうスクリプトを
	追加することをおすすめします. IP
	インターフェースの設定がおこなわれる前に
	ファイアウォールの設定がおこなわれるように, netstart
	ファイル中の 充分に早い位置にルールをロードする
	スクリプトを配置してください.  こうすることで,
	ネットワークがオープンな間は常に抜け道が塞がれている
	ことになります.</para>

      <para>ルールをロードするために使用するスクリプトは,
	あなたが作成しなければなりません.  現在のところ
	<command>ipfw</command> は 1 コマンドで複数のルールを
	ロードするユーティリティをサポートしていません.
	私が使用しているシステムでは以下のようにしています:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>ファイルに現在のルールリストを出力し,
	テキストエディタを使用して すべての行の前に
	<literal>ipfw</literal> と書き足します.  こうすることで,
	このスクリプトを /bin/sh に与えてルールをカーネルに再読み込み
	させることができます.
	これは最も効率的な方法とはいえないかもしれませんが,
	きちんと動作しています.</para>

      <para>次の問題は, ファイアウォールが実際には何を <emphasis> する
	</emphasis> べきかです !
	これは外部からそのネットワークへのどんなアクセスを許したいか,
	また内部から外界へのアクセスを
	どのくらい許したいかに大きく依存します.
	いくつか一般的なルールを挙げると:</para>

      <itemizedlist>
	<listitem>
	  <para>1024 番以下のポートへのすべての TCP
	    入力アクセスをブロックします.  ここは finger, SMTP (mail)
	    そして telnet など, 最もセキュリティに敏感な
	    サービスが存在する場所だからです.</para>
	</listitem>

	<listitem>
	  <para><emphasis> すべての </emphasis> 入力 UDP
	    トラフィックをブロックします.  これは UDP
	    を使用しているサービスで有用なものは極めて少ないうえ,
	    有用なトラフィック (例えば Sun の RPC と NFS プロトコル)
	    は,  通常セキュリティに対する脅威となるためです.  UDP
	    はコネクションレスプロトコルであるため,  入力 UDP
	    トラフィックを拒絶することは すなわち出力 UDP
	    トラフィックに対する返答をも ブロックすることになるので,
	    このことはそれなりの不利益をもたらします.  たとえば外部の
	    archie (prospero) サーバを使用している (内部の) ユーザに
	    とって問題となる可能性があります.  もし archie
	    へのアクセスを許したければ, 191 番と 1525 番のポートから
	    任意の UDP
	    ポートへ来るパケットがファイアウォールを通過することを
	    許可しなければなりません.  123
	    番のポートから来るパケットは ntp パケットで,
	    これも通過の許可を考慮する必要がある
	    もう一つのサービスです.</para>
	</listitem>

	<listitem>
	  <para>外部から 6000
	    番のポートへのトラフィックをブロックします.  6000
	    番のポートは X11 サーバへのアクセスに使用されるポートで,
	    セキュリティに対する脅威となりえます.
	    (特に自分のワークステーションで  <command>xhost
	      +</command>
	    をおこなう癖を持っている人がいればなおさらです).  X11
	    は実際に 6000 番以降のポートを使用する可能性があるため,
	    通過許可に 上限を定めると,
	    そのマシンで走らせることのできる X ディスプレイの
	    個数が制限されます.  RFC 1700 (Assigned Numbers)
	    で定義されているように, 上限は 6063 です.</para>
	</listitem>

	<listitem>
	  <para>内部のサーバ (例えば SQL サーバなど)
	    がどのポートを使用するかを チェックします.
	    それらのポートは通常, 上で指定した 1-1024
	    番の範囲から外れていますので,
	    これらも同様にブロックしておくことは
	    おそらく良い考えです.</para>
	</listitem>
      </itemizedlist>

      <para>これとは別のファイアウォール設定に 関するチェックリストが
	CERT から 入手可能です.  <ulink
	  URL="ftp://ftp.cert.org/pub/tech_tips/packet_filtering">
	  ftp://ftp.cert.org/pub/tech_tips/packet_filtering</ulink></para>

      <para>前にも述べたように, これはただの <emphasis> ガイドライン
	</emphasis> にすぎません.
	ファイアウォールでどのようなフィルタルールを使用するかは,
	あなた自身が 決めなければなりません.
	これまでのアドバイスにしたがったにも関わらず,
	誰かがあなたのネットワークに 侵入してきたとしても,
	私は「いかなる」責任もとることはできません.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../handbook.sgml" "part" "chapter")
     End:
-->
