<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r9815
     $FreeBSD$
-->

<chapter id="users">
  <title>ユーザと基本的なアカウントの管理</title>
  
  <sect1 id="users-synopsis">
    <title>この章では</title>
    
    <para><emphasis>寄稿: &a.nbm;、2000 年 2 月</emphasis></para>
    
    <para>
      システムへアクセスするには、かならずユーザアカウントが使われます。
      また、プロセスもすべてユーザによって実行されますので、
      ユーザとアカウントの管理は FreeBSD
      システムにおいて欠かすことのできない重要なものです。
    </para>

    <para>
      アカウントには大きく分けて三種類のものがあります。それは、
      <link linkend="users-superuser">スーパーユーザ (Superuser)</link>、
      <link linkend="users-system">システムユーザ (system users)</link>、
      そして<link linkend="users-user">ユーザアカウント (user accounts)</link> です。
      スーパーユーザのアカウントは通常 <username>root</username> と呼ばれ、
      無制限の特権を持つためにシステムの管理に用いられます。
      また、システムユーザはサービスの運用に用いられ、
      最後のユーザアカウントは、
      実際にログインしてメールを読むといった作業を行なう利用者のためのものです。
    </para>
  </sect1>
    
  <sect1 id="users-superuser">
    <title>スーパーユーザアカウント</title>
    
    <para>スーパーユーザアカウントは通常
      <username>root</username> と呼ばれ、初期時から設定済みです。
      このアカウントはシステム管理を行なうためのもので、
      メールのやりとり、システムの調査、
      プログラミングといった日常的な作業を行なうために使われるべきものではありません。
    </para>

    <para>
      その理由は、スーパーユーザが通常のユーザアカウントと異なり、
      操作にまったく制限を受けないことによります。
      そのためスーパーユーザアカウントで操作を間違えると、
      システムに重大な影響を与えてしまう恐れがあるのです。
      ユーザアカウントでは、仮に操作を間違えてもシステムを壊してしまうようなことは
      できないようになっています。したがって特権を必要としていないのであれば、
      できるだけいつもユーザアカウントを利用する方が望ましいと言えるでしょう。
    </para>

    <para>
      また、スーパーユーザで実行するコマンドはいつでも、
      二回、三回と何度もコマンドをチェックしてください。
      なぜならスペースが多かったり、文字が欠けていたりするだけで、
      取り返しのつかないデータの破壊につながる可能性があるからです。
      スーパーユーザになると得られる特権は、
      言い換えてみれば通常のユーザアカウントの保護を受けることができない、
      ということも意味しています。
    </para>

    <para>
      ですから、この章を読んでからあなたが最初にすべきなのは、
      もし用意していないなら、日常的に利用するための
      あなた自身のユーザアカウントを作成することです。
      これはマルチユーザモード、シングルユーザモードを問わず、
      同様にあてはまります。
      この章のうしろの方では、アカウントの追加と通常のユーザから
      スーパーユーザへと移行する手順について扱います。
    </para>
  </sect1>
    
  <sect1 id="users-system">
    <title>システムアカウント</title>

    <para>
      システムユーザとは、DNS、メール、
      ウェブサーバといった各種サービスを運用するために使われます。
      この目的は、セキュリティを確保するためです。
      もしサービスがスーパーユーザで実行されていると、
      それらのサービスは (本来意図しないような)
      どんな動作でも可能となり、適切な制限を適用することができません。
    </para>

    <para>
      システムユーザの具体例として、
      <username>daemon</username>、
      <username>operator</username>、
      <username>bind</username> (DNS; Domain Name Service 用) および
      <username>news</username> といったものがあります。
      またシステム管理者はよく、
      インストールしたウェブサーバを運用するために
      <username>httpd</username>
      というユーザを作成しています。
    </para>

    <para>
      <username>nobody</username>
      ユーザは通常の特権を持たないシステムユーザですが、
      <username>nobody</username>
      を利用するサービスが増えれば増えるほど、その特権も大きくなります。
    </para>
  </sect1>

  <sect1 id="users-user">
    <title>ユーザアカウント</title>

    <para>
      ユーザアカウントは、
      主に現実のユーザがシステムにアクセスする手段として用いられるものです。
      このアカウントは利用するユーザとシステム環境を分離します。
      そのため、システムや他のユーザに危害をおよぼす危険性をなくし、また、
      他に影響を与えることなくユーザ自身の環境をカスタマイズすることを可能にしています。
    </para>

    <para>システムにアクセスするすべてのユーザは、
      それぞれに一人一つのユーザアカウントを持つべきです。
      こうすることで誰が何を行なっているかがわかりますし、
      他の人の設定を壊してしまったり、
      他人にメールを読まれてしまうようなことを避けることができます。</para>

    <para>それぞれのユーザは快適にシステムを利用するため、
      シェル、エディタ、キー設定、言語など、
      各自の環境をセットアップすることができます。</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>アカウント情報の変更</title>

    <para>強力で柔軟性に富むアカウント情報の変更手段として、
      <application>pw</application> があります。
      しかし、新しいアカウントをつくる場合は
      <application>adduser</application> を、
      アカウントを削除する場合は <application>rmuser</application>
      を使うことが推奨されています。</para>

    <para><application>chpass</application> を使うことで、
      システム管理者、通常のユーザはパスワード、シェル、
      その他の個人情報を変更することができます。
      また、特にパスワードを変更する場合には、
      通常 <application>passwd</application> の方が良く使われます。</para>

    <sect2 id="users-adduser">
      <title>adduser</title>

      <para><application>adduser</application> は、
        新しいユーザを登録するためのシンプルなプログラムです。
        このプログラムは <filename>passwd</filename> と
        <filename>group</filename>
        に新しいユーザのエントリを作成するのと同時に、
        ホームディレクトリを作成して <filename>/usr/share/skel</filename>
        からデフォルトで使用されるドットファイル (訳注:
        ホームディレクトリに存在する <quote>.</quote>
        から始まるファイルのことで、各種設定に用いられます) をコピーします。
        また、新しく作成されたユーザに対して、
        ウェルカムメッセージをメールで送信することも可能です。
      </para>

      <para>初期設定ファイルを作成するには、
	<command>adduser -s -config_create</command>
        とします<footnote>
	  <para>オプション <option>-s</option> をつけると、
            デフォルトで詳細を表示しないように adduser を設定します。
            この後に詳細を表示させるようにしたい場合は、
            オプション <option>-v</option> を指定してください。</para>
	</footnote>。
        そして次に adduser のデフォルト設定を行ない、
        最初のユーザアカウントを作成します。
        システムを日常利用する際に root を用いるのは最悪です。</para>

      <example>
	<title>adduser の設定の変更</title>

	<screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh [sh]: <userinput>tcsh</userinput>
Your default shell is: tcsh -> /usr/local/bin/tcsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]: 
Send message from file: /etc/adduser.message no 
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh [tcsh]: 
Enter home directory (full path) [/home/jru]: 
Uid [1001]: 
Enter login class: default []: 
Login group jru [jru]: 
Login group is ``jru''. Invite jru into other groups: guest no 
[no]: <userinput>wheel</userinput>
Enter password []: 
Enter password again []: 

Name:	  jru
Password: ****
Fullname: J. Random User
Uid:	  1007
Gid:	  1007 (jru)
Class:	  
Groups:	  jru wheel
HOME:     /home/jru
Shell:	  /usr/local/bin/tcsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>簡単に上の操作を説明します。
        まずデフォルトシェルを <application>tcsh</application>
        (packages にある追加のシェルです) に変更し、
        新しいユーザにウェルカムメッセージのメールを送付しないようにしました。
        そしてその設定を保存し、<username>wheel</username>
        グループ (後に、
        これが重要な意味を持っていることがわかるでしょう) に所属する
        <username>jru</username>
        というアカウントを作成しています。
      </para>

      <note>
	<para>入力したパスワードは画面に表示されません。
          アスタリスク記号も表示されませんので、
          パスワードを二回とも間違えて入力してしまわないように注意してください。:-)
        </para>
      </note>

      <note>
	<para>これ以降はオプション引数をつけず単に <command>adduser</command>
          を起動します。
          デフォルト設定を変更する必要はありません。
          もし、adduser がデフォルト設定を変更するかどうか尋ねてきたら、
          adduser を終了し、<option>-s</option>
          オプションを使うようにしてください。</para>
      </note>
    </sect2>

    <sect2 id="users-rmuser">
      <title>rmuser</title>

      <para><application>rmuser</application> は、
        システムからユーザを削除します。
        これにはユーザデータベースからの削除だけでなく、
        その他、そのユーザに依存する情報すべてが含まれます。
      </para>

      <para><application>rmuser</application>
        は次の手順を実行します。</para>

      <procedure>
	<step>
	  <para>指定されたユーザの &man.crontab.1; エントリを削除
            (存在する場合)。</para>
	</step>

	<step>
          <para>指定されたユーザの &man.at.1; ジョブをすべて削除。</para>
	</step>

	<step>
	  <para>指定されたユーザが所有するすべてのプロセスを強制終了。</para>
	</step>

	<step>
	  <para>ローカルパスワードファイルから、
            指定されたユーザのエントリを削除。</para>
	</step>

	<step>
	  <para>指定されたユーザのホームディレクトリを削除
            (ディレクトリの所有者が指定されたユーザのものだった場合)。</para>
	</step>

	<step>
	  <para><filename>/var/mail</filename>
            から、指定されたユーザの到着メールファイルを削除。</para>
	</step>

	<step>
	  <para><filename>/tmp</filename>
            のような一時ファイル保存領域から、
            指定されたユーザの所有するファイルを削除。</para>
	</step>

	<step>
	  <para>そして最後に、
            <filename>/etc/group</filename> にある
            すべてのグループから、指定されたユーザを削除します。
	    
	    <note>
	      <para>
                指定されたユーザと同じ名前のグループで、
                そのユーザが削除されると空のグループとなる場合は、
                そのグループ自体が削除されます。
                これは &man.adduser.8; によってユーザごとに作成される、
                ユニークなグループに対応するものです。
              </para>
	    </note>
	  </para>
	</step>
      </procedure>

      <para>スーパユーザアカウントの削除に
        <application>rmuser</application> を利用することはできません。
        スーパユーザアカウントの削除はほとんどすべての場合、
        大規模なシステムの破壊を意味するからです。
      </para>

      <para>デフォルトでは、
        どういう操作を行なっているか確認できる対話モードが使われます。
      </para>

      <example>
	<title>rmuser による対話的なアカウントの削除</title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1000:1000::0:0:J. Random User:/home/jru:/usr/local/bin/tcsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-pw">
      <title>pw</title>

      <para><application>pw</application> は、
	ユーザやグループの作成、削除、変更および表示を行なうことができ、
	システムユーザファイルやシステムグループファイルの編集機能を持ったコマンドラインのユーティリティです。
	この節では、ユーザに対する使用方法を説明します。
	後の <link linkend="users-groups">グループ</link> 節では、
	グループに対する使用方法を説明します。</para>

      <para>
        これはシェルスクリプトからの利用や、
        直接コマンドを実行する際に便利に使えるように設計されたものです。
      </para>

      <para>詳細はすべて &man.pw.8; に書かれています。</para>
    </sect2>

    <sect2 id="users-chpass">
      <title>chpass</title>

      <para><application>chpass</application> は、
        パスワード、シェル、その他の個人情報といった、
        ユーザデータベース情報を変更します。
      </para>

      <para>システム管理者に限りスーパユーザ権限で chpass を用い、
        他のユーザの情報やパスワードを変更することが可能です。
      </para>

      <para>ユーザ名の他にオプションを指定しないと、
        <application>chpass</application>
        はユーザ情報を編集するエディタを表示します。
        そのエディタを終了すると、
        <application>chpass</application>
        はユーザデータベース情報の変更を試みます。
      </para>

      <example>
	<title>スーパユーザによる対話的な chpass</title>

	<screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1000
Gid [# or name]: 1000
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>通常のユーザは、この情報の限られた部分のみ変更が可能です。
        また、変更できるのはそのユーザ自身の情報のみです。
      </para>

      <example>
	<title>通常のユーザによる対話的な chpass</title>

	<screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
	<para><command>chfn</command>、
          <command>chsh</command> はいずれも、
          単に chpass へのハードリンクになっています。
          また、<command>ypchpass</command>、
	  <command>ypchfn</command> および
	  <command>ypchsh</command> も同様です。
          NIS のサポートは自動的に行なわれますので、
          コマンドの先頭に <literal>yp</literal>
          をつける必要はありません。
        </para>
      </note>
    </sect2>

    <sect2 id="users-passwd">
      <title>パスワードの変更</title>

      <para><application>passwd</application> は、
        ユーザが自分のパスワードを変更する通常の方法です。
        スーパユーザ権限では、
        他のユーザのパスワードを変更するのに使われます。
      </para>

      <note>
	<para>ユーザはパスワードを変更する前に、
          もともと設定されていたパスワードを入力しなければなりません。
          これはユーザがコンソールを離れた際に、
          不審な人物によってパスワードが変更されることを防ぐためです。
        </para>
      </note>

      <example>
	<title>passwd</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>スーパーユーザ権限での他のユーザのパスワード変更</title>

	<screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
	<para><command>yppasswd</command> は、
          単に <command>passwd</command> へのハードリンクになっています。
          NIS のサポートは自動的に行なわれますので、
          コマンドの先頭に <literal>yp</literal>
          をつける必要はありません。</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="users-limiting">
    <title>ユーザへの制限</title>

    <para>あなたがマルチユーザシステムを運用しているのなら、
      どのユーザもシステムに損害を与えないという信頼はおいていないのではないでしょうか。
      FreeBSD は、
      個々のユーザが利用できるシステムのリソースをシステム管理者が制限する方法をいくつも用意しています。
      その種の制限は一般的には、ディスククォータ (quota)
      とその他のリソースの制限の 2 つに分けられます。</para>

    <para>ディスククォータは、
      システム管理者がファイルシステムにユーザが使用できるディスク領域の量を指示する手段です。
      さらに、その都度測定しなくてもユーザのディスク使用量を簡単に確認できる手段も提供しています。
      クォータについては、<xref linkend="quotas"> で解説しています。</para>

    <para>その他のリソースの制限とは、ユーザが消費できる
      CPU、メモリなどのリソースを制限する手段のことです。
      これはログインクラスを用いて定義されているもので、
      この後で解説しています。</para>

    <para>ログインクラスは <filename>/etc/login.conf</filename>
      で定義します。詳細な働きの説明はこの節の範囲を超えますが、
      &man.login.conf.5; のマニュアルに詳しく記載されています。
      各ユーザにはログインクラスが割り当てられていて
      (デフォルトでは <literal>default</literal> です)、
      それぞれのログインクラスにはログインケーパビリティの集合が割り当てられているといえば十分でしょう。
      ログインケーパビリティとは、
      <literal><replaceable>名称</replaceable>=<replaceable>値</replaceable></literal>
      の組のことで、<replaceable>名称</replaceable>
      は周知の識別子、<replaceable>値</replaceable>
      は、名称に応じて処理される任意の文字列です。
      ログインクラスとケーパビリティを設定するのはどちらかといえば簡単なことで、
      &man.login.conf.5; でも説明されています。</para>

    <para>リソースの制限は、
      2 つの点で標準的なログインケーパビリティと異なっています。
      第一に、どの制限についても、ソフト (現在の)
      リミットとハードリミットがあります。
      ソフトリミットは、ユーザやアプリケーションが調整できますが、
      ハードリミットを超えることはできません。
      ユーザはハードリミットを下げることはできますが、上げることはできません。
      第二に、ほとんどのリソースの制限は特定のユーザに対してプロセス毎に適用されるもので、
      そのユーザが利用するリソースの総量を制限するものではありません。
      ただし、この違いは制限を特別扱いすることで実現されるものであり、
      ログインケーパビリティフレームワークの実装によるものではありません
      (つまり、リソースの制限は、
      <emphasis>実際には</emphasis>ログインケーパビリティの特別な場合ではないのです)。</para>

    <para>難しい話はこのくらいにしておいて、
      以下が最もよく使われるリソースの制限になります
      (残りは、他のすべてのログインケーパビリティと並んで
      &man.login.conf.5; に書かれています)。</para>

    <variablelist>
      <varlistentry>
	<term><literal>coredumpsize</literal></term>

	<listitem>
	  <para>プログラムが生成する core
	  ファイルのサイズにかかる制限は、
	  自明な理由でほかのディスク使用に関する制限に従属します
	  (例: <literal>filesize</literal> やディスククォータ)。それでも、
	  ディスク領域の消費を制御するあまり厳しくない手段としてよく使われています。
	  ユーザは core ファイルを自分で生成するわけではなく、
	  削除しないことも多いので、これを設定すれば大きなプログラム
	  (たとえば Emacs)
	  が異常終了してもディスクの空きがなくならずに済みます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

	<listitem>
	  <para>そのユーザのプロセスが消費できる CPU 時間の上限です。
	    これを超えたプロセスは、カーネルにより終了されます。

	    <note>
	      <para>これは、消費される CPU <emphasis>時間</emphasis> 
		についての制限であって、&man.top.1; や&man.ps.1;
		の項目のどれかに表示される
		CPU の割合に関するものではありません。
		これを書いている時点では後者の制限はかけられませんし、
		役にたたないでしょう。たとえば
		(正当なタスクである可能性が高い)
		コンパイラはたやすく一定時間
		CPU を 100% 近く使ってしまいます。</para>
	    </note>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

	<listitem>
	  <para>ユーザが所有できるファイルの大きさの上限です。<link
	    linkend="quotas">ディスククォータ</link> と違い、
	    この制限はユーザのファイルをすべてまとめた集合にではなく、
	    個々のファイルにかかります。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

	<listitem>
	  <para>ユーザが実行できるプロセス数の上限です。
	    フォアグラウンドプロセスとバックグラウンドプロセスの両方を平等に扱います。
	    自明な理由から、sysctl 変数 <literal>kern.maxproc</literal>
	    で指定されたシステムの制限を超えることはできません。
	    また、同時に複数ログインすることや、
	    パイプライン実行することは便利なことが多いので、
	    この値をあまり小さな値に設定すると、
	    そのユーザの生産性が悪化することにも注意してください。
	    大きなプログラムをコンパイルする場合のように、
	    タスクによっては複数のプロセスが実行されます (たとえば
	    &man.make.1;, &man.cc.1;
	    や、その他仲立ちとなるプリプロセッサ)。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

	<listitem>
	  <para>これは、
	    1 つのプロセスがメインメモリにロックされることを要求できるメモリの最大容量です
	    (&man.mlock.2; をご覧ください)。&man.amd.8;
	    のようなシステムで重要なプログラムは、
	    問題発生時にスワップアウトされてしまって、
	    システムのスラッシングを引き起こさないように、
	    メインメモリへのロックを要求します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memoryuse</literal></term>

	<listitem>
	  <para>これは、どの時点かを問わず、
	    あるプロセスが消費できる最大のメモリ容量です。
	    これは、メインメモリとスワップの使用量を合わせたものです。
	    メモリ消費を抑えるための包括的な制限ではありませんが、
	    手始めにはよいでしょう。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>openfiles</literal></term>

	<listitem>
	  <para>これは、あるプロセスが開いておける最大のファイル数です。
	    FreeBSD では、ファイルはまた、ソケットや
	    IPC チャンネルを表わすのにも使われています。
	    ですから、あまり低い値に設定しないよう注意してください。
	    これに対応するシステム全体の制限は sysctl 変数
	    <literal>kern.maxfiles</literal> で定義されています。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>sbsize</literal></term>

	<listitem>
	  <para>これは、あるユーザが消費できるネットワークメモリ
	    (つまり mbuf) の上限の量です。これは、
	    大量のソケットを生成する古いサービス拒否攻撃に対応するものとして作られましたが、
	    一般的にはネットワーク通信を制限するのに使えます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>stacksize</literal></term>

	<listitem>
	  <para>これは、プロセスのスタックサイズの上限です。
	    あるプログラムが使用しうるメモリの量を制限するには、
	    これだけでは十分ではありません。
	    したがって、他の制限と組み合わせて使わなければなりません。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>リソースの制限を設定するにあたり、
      ほかにもいくつか覚えておかなければならないことがあります。
      以下は、一般的なこつやお勧め、さまざまなコメントになります。</para>

    <itemizedlist>
      <listitem>
	<para>システム起動時に <filename>/etc/rc</filename>
	  から起動されたプロセスは、<literal>daemon</literal>
	  ログインクラスに割り当てられます。</para>
      </listitem>

      <listitem>
	<para>システムに付属していた
	  <filename>/etc/login.conf</filename>
	  はほとんどの制限について妥当な値になっていますが、
	  あなたのシステムに何がふさわしいか分かるのは、
	  管理者であるあなただけです。
	  制限をあまり緩くするとシステムを悪用しやすくしてしまいますし、
	  厳しくしすぎると生産性を悪化させてしまいます。</para>
      </listitem>

      <listitem>
	<para>X Window System (X11) のユーザには、
	  他のユーザより多くのリソースを与えるべきかもしれません。
	  X11 そのものが多くのリソースを使うだけでなく、
	  より多くのプログラムを並行して使うことをユーザに促します。</para>
      </listitem>

      <listitem>
	<para>多くの制限は個々のプロセスにかかるもので、
	  一人のユーザにまとめてかかるものではないことを忘れないでください。
	  例えば、openfiles を 50 に設定することは、
	  ユーザが動かすそれぞれのプロセスが最大
	  50 個のファイルを開けるということです。
	  したがって、あるユーザが開けられるファイルの総数は、
	  <literal>openfiles</literal> の値に <literal>maxproc</literal>
	  をかけたものになります。
	  同じことがメモリ消費量にもあてはまります。</para>
      </listitem>
    </itemizedlist>

    <para>リソースの制限と、ログインクラス、
      ログインケーパビリティ一般についての詳しい情報は、
      それぞれのマニュアルページ、
      &man.cap.mkdb.1;, &man.getrlimit.2;, &man.login.conf.5;
      をご覧ください。</para>
  </sect1>

  <sect1 id="users-personalizing">
    <title>ユーザ個別の設定</title>

    <para>地域化 (localization) とは、
      それぞれ異なる言語、キャラクタセット、
      日付や時間の標準などに適応させるための環境設定を、
      システム管理者やユーザが行なうことを指します。
      地域化については、
      <link linkend="l10n">地域化の章</link>に書かれています。</para>
  </sect1>

  <sect1 id="users-groups">
    <title>グループ</title>

    <para>グループとは、単にユーザを羅列したものです。
      グループは、グループ名と gid (グループ ID) で識別されます。
      FreeBSD (と他の Unix システムのほとんど) では、
      あるプロセスが何かするのを許可するかどうかをカーネルが判断する際に利用する
      2 つの因子は、ユーザ ID とそのユーザが所属するグループの一覧です。
      ユーザ ID と異なり、プロセスはそのプロセスに関係付けられたグループの一覧を持ちます。
      どこかで "グループ ID" に触れているのを聞くことがあるでしょうが、
      ほとんどの場合は、これは単に一覧の最初のグループを指しています。</para>

    <para>グループ名からグループ ID への写像は
      <filename>/etc/group</filename> にあります。
      これは、コロンで区切られた 4 項目からなるテキストファイルです。
      1 番目の項目はグループ名、
      2 番目は暗号化されたパスワード、
      3 番目がグループ ID、
      4 番目がカンマで区切られたメンバの一覧です。
      これは手で編集して問題ありません
      (もちろん、文法をまったく間違えない限りはですが)。
      文法についての完全な説明は、&man.group.5; をご覧ください。</para>

    <para><filename>/etc/group</filename> を手で編集したくなければ、
      &man.pw.8; コマンドを使ってグループの追加や編集をできます。
      たとえば、<groupname>teamtwo</groupname>
      というグループを追加して、その存在を確認するには、
      次のように使えばできます。</para>

    <example>
      <title>&man.pw.8; によるグループの追加</title>

      <screen>&prompt.root; <userinput><command>pw</command> groupadd <groupname>teamtwo</groupname></userinput>
&prompt.root; <userinput><command>pw</command> groupshow <groupname>teamtwo</groupname></userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>上記の <literal>1100</literal> という番号は、
      <groupname>teamtwo</groupname> グループのグループ ID です。
      この時点では、<groupname>teamtwo</groupname>
      にはメンバがおらず、あまり意味がありません。
      <username>jru</username> を <groupname>teamtwo</groupname>
      に参加させて、この状況を変えましょう。</para>

    <example>
      <title>&man.pw.8; によるグループへのユーザ追加</title>

      <screen>&prompt.root; <userinput><command>pw</command> groupmod <groupname>teamtwo</groupname> <option>-M</option> <username>jru</username></userinput>
&prompt.root; <userinput><command>pw</command> groupshow <groupname>teamtwo</groupname></userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para><option>-M</option> オプションの引数は、
      カンマで区切られたグループに所属するユーザの一覧です。
      前の節を読まれたなら、
      パスワードファイルに各ユーザのグループが記載されていることをご存知でしょう。
      パスワードファイルに記載されているグループは、
      システムが自動的にグループ一覧に加えますので、&man.pw.8;
      でグループのメンバ一覧を調べた時にはそのユーザは表示されません
      (し、表示されるべきではありません)。
      あるユーザがどのグループに属しているかを調べたければ、
      次のように &man.id.1; プログラムが使えます。</para>

    <example>
      <title>&man.id.1; によるグループのメンバの確認</title>

      <screen>&prompt.user; <userinput><command>id</command> <username>jru</username></userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>見れば分かりますが、<username>jru</username> は
      <groupname>jru</groupname> グループと
      <groupname>teamtwo</groupname> グループのメンバです。</para>

    <para>&man.pw.8; について詳しくはマニュアルページをご覧ください。
      <filename>/etc/group</filename> のフォーマットの詳細については、
      &man.group.5; マニュアルページをご覧ください。</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
