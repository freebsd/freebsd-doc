<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r10428
     $FreeBSD$
-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Neil</firstname>
	<surname>Blakey-Milner</surname>
	<contrib>寄稿: </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
  </chapterinfo>

  <title>ユーザと基本的なアカウントの管理</title>

  <sect1 id="users-synopsis">
    <title>この章では</title>

    <para>FreeBSD は、複数のユーザが同時にコンピュータを使えるようにします。
      もちろん、
      スクリーンとキーボードの前に一度に座れるのはその中の一人だけですが、
      ユーザは何人でもネットワークを通してログインして作業できます。
      システムを使うためには、
      どのユーザもアカウントがなければなりません。</para>

    <para>この章を読むと、以下のことがわかります。</para>

    <itemizedlist>
      <listitem>
	<para>FreeBSD のさまざまなユーザアカウントの違い</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントの追加方法</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントの削除方法</para>
      </listitem>

      <listitem>
	<para>ユーザの名前やシェルなど、アカウントの細目を変更する方法</para>
      </listitem>

      <listitem>
	<para>アカウント毎に制限をかけて、メモリや CPU 時間など、
	  アカウントやグループに対してアクセスが許可される資源を制御する方法</para>
      </listitem>

      <listitem>
	<para>アカウント管理を楽にするためのグループの使い方</para>
      </listitem>
    </itemizedlist>

    <para>この章を読む前に</para>

    <itemizedlist>
      <listitem>
	<para>Unix と　FreeBSD の基礎知識 (<xref linkend="basics">)
	  を理解しておいてください。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>はじめに</title>

    <para>
      システムへアクセスするには、かならずユーザアカウントが使われます。
      また、プロセスもすべてユーザによって実行されますので、
      ユーザとアカウントの管理は FreeBSD
      システムにおいて欠かすことのできない重要なものです。
    </para>

    <para>FreeBSD 上のどのアカウントにも、
      そのアカウントを識別するための情報がなにかしら結び付けられています。</para>

    <variablelist>
      <varlistentry>
	<term>ユーザ名</term>

	<listitem>
	  <para><prompt>login:</prompt>
	    プロンプトに対して入力するユーザの名前です。
	    ユーザ名はそのコンピュータ内で一意でなければならず、
	    2 名のユーザに同じユーザ名をつけることはできません。
	    有効なユーザ名を作成するには &man.passwd.5;
	    に記載されているいくつもの規則があります。
	    8 文字以下の小文字からなるユーザ名が一般的です。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>パスワード</term>

	<listitem>
	  <para>それぞれのアカウントにはパスワードがあります。
	    パスワードは空白にもでき、
	    その場合はシステムにアクセスするのにパスワードは不要です。
	    これは通常はとても悪い考えです。
	    すべてのアカウントにはパスワードをつけるべきです。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>ユーザ ID (UID)</term>

	<listitem>
	  <para>UID は、システムがユーザを一意に識別するための 0 から
	    65535 の間の数値です。FreeBSD 内部ではユーザの識別に UID
	    を使っています。ユーザ名を指定できる FreeBSD のコマンドは、
	    どれもユーザ名を UID に変換してから扱っています。
	    これは、同じ UID
	    を持つ異なるユーザ名のアカウントがいくつあってもよいということになります。
	    FreeBSD に限っていうと、
	    これらのアカウントはひとりのユーザとして扱われます。
	    そうする必要があるとは思えませんが。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>グループ ID (GID)</term>

	<listitem>
	  <para>GID は、ユーザが属する第一グループを一意に識別するための
	    0 から 65535 の間の数値です。グループは、UID ではなく、
	    ユーザの GID に基づいて資源へのアクセスを制御する仕組みです。
	    これは、ある種の設定ファイルのサイズを大幅に小さくします。
	    ユーザは、複数のグループに所属できます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>ログインクラス</term>

	<listitem>
	  <para>ログインクラスはグループの仕組みを拡張したもので、
	    別々のユーザに対してシステムを調整する時に、
	    さらなる柔軟性を提供します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>パスワード変更時間</term>

	<listitem>
	  <para>デフォルトでは、FreeBSD
	    は定期的にパスワードを変更することをユーザに強制しません。
	    これをユーザごとに設定して、一部またはすべてのユーザに、
	    一定の時間がたったらパスワードを強制的に変更させることができます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>アカウント失効時間</term>

	<listitem>
	  <para>デフォルトでは、FreeBSD はアカウントを失効させません。
	    たとえば学校で生徒のアカウントがある場合など、
	    限られた期間だけのアカウントを作成するなら、
	    そのアカウントがいつ失効するか指定できます。
	    有効期間が経過したら、
	    そのアカウントのディレクトリやファイルは残っていますが、
	    システムへのログインはできなくなります。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>ユーザの氏名</term>

	<listitem>
	  <para>FreeBSD ではユーザ名でアカウントを一意に識別しますが、
	    必ずしもユーザの本名を反映したものではありません。
	    この情報をアカウントに関連付けることもできます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>ホームディレクトリ</term>

	<listitem>
	  <para>ホームディレクトリは、
	    ユーザがログインした時に作業を開始する、
	    システム中のディレクトリへのフルパスです。
	    一般的な慣習は、すべてのユーザのホームディレクトリを
	    <filename>/home/<replaceable>username</replaceable></filename>
	    の下に置くことです。
	    ユーザは、個人のファイルをホームディレクトリや、
	    その下に作成するディレクトリに保存します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>ユーザシェル</term>

	<listitem>
	  <para>シェルは、
	    ユーザがシステムと対話するデフォルトの環境を提供します。
	    いろいろな種類のシェルがあり、
	    経験を積んだユーザはそれぞれ好みがあり、
	    それをアカウントの設定に反映できます。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>
      アカウントには大きく分けて三種類のものがあります。それは、
      <link linkend="users-superuser">スーパーユーザ (Superuser)</link>、
      <link linkend="users-system">システムユーザ (system users)</link>、
      そして<link linkend="users-user">ユーザアカウント (user accounts)</link> です。
      スーパーユーザのアカウントは通常 <username>root</username> と呼ばれ、
      無制限の特権を持つためにシステムの管理に用いられます。
      また、システムユーザはサービスの運用に用いられ、
      最後のユーザアカウントは、
      実際にログインしてメールを読むといった作業を行なう利用者のためのものです。
    </para>
  </sect1>
    
  <sect1 id="users-superuser">
    <title>スーパーユーザアカウント</title>
    
    <indexterm>
      <primary>アカウント</primary>
      <secondary>スーパーユーザ (root)</secondary>
    </indexterm>
    <para>スーパーユーザアカウントは通常
      <username>root</username> と呼ばれ、
      システム管理を行なうために最初から設定済みです。
      このアカウントはメールのやりとり、システムの調査、
      プログラミングといった日常的な作業を行なうために使われるべきものではありません。
    </para>

    <para>
      その理由は、スーパーユーザが通常のユーザアカウントと異なり、
      操作にまったく制限を受けないことによります。
      そのためスーパーユーザアカウントで操作を間違えると、
      システムに重大な影響を与えてしまう恐れがあるのです。
      ユーザアカウントでは、仮に操作を間違えてもシステムを壊してしまうようなことは
      できないようになっています。したがって特権を必要としていないのであれば、
      できるだけいつもユーザアカウントを利用する方が望ましいと言えるでしょう。
    </para>

    <para>スーパーユーザで実行するコマンドはいつでも、
      二回、三回と確認してください。
      なぜならスペースが多かったり、文字が欠けていたりするだけで、
      取り返しのつかないデータの破壊につながる可能性があるからです。</para>

    <para>
      ですから、この章を読んでからあなたが最初にすべきなのは、
      もし用意していないなら、日常的に利用するための
      あなた自身のユーザアカウントを作成することです。
      これはマルチユーザモード、シングルユーザモードを問わず、
      同様にあてはまります。
      この章のうしろの方では、アカウントの追加と通常のユーザから
      スーパーユーザへと移行する手順について扱います。
    </para>
  </sect1>
    
  <sect1 id="users-system">
    <title>システムアカウント</title>

    <indexterm>
      <primary>アカウント</primary>
      <secondary>システム</secondary>
    </indexterm>
    <para>
      システムユーザとは、DNS、メール、
      ウェブサーバといった各種サービスを運用するために使われます。
      この目的は、セキュリティを確保するためです。
      もしサービスがスーパーユーザで実行されていると、
      それらのサービスは (本来意図しないような)
      どんな動作でも可能となり、適切な制限を適用することができません。
    </para>

    <indexterm>
      <primary>アカウント</primary>
      <secondary><username>daemon</username></secondary>
    </indexterm>
    <indexterm>
      <primary>アカウント</primary>
      <secondary><username>operator</username></secondary>
    </indexterm>
    <para>
      システムユーザの具体例として、
      <username>daemon</username>、
      <username>operator</username>、
      <username>bind</username> (DNS; Domain Name Service 用) および
      <username>news</username> といったものがあります。
      またシステム管理者はよく、
      インストールしたウェブサーバを運用するために
      <username>httpd</username>
      というユーザを作成しています。
    </para>

    <indexterm>
      <primary>アカウント</primary>
      <secondary><username>nobody</username></secondary>
    </indexterm>
    <para>
      <username>nobody</username>
      ユーザは通常の特権を持たないシステムユーザです。
      しかし、<username>nobody</username>
      を利用するサービスが増えれば増えるほど、
      それに所属するファイルやプロセスも増え、
      その特権も大きくなるということを忘れないようにしてください。</para>
  </sect1>

  <sect1 id="users-user">
    <title>ユーザアカウント</title>

    <indexterm>
      <primary>アカウント</primary>
      <secondary>user</secondary>
    </indexterm>
    <para>
      ユーザアカウントは、
      主に現実のユーザがシステムにアクセスする手段として用いられるものです。
      このアカウントは利用するユーザとシステム環境を分離します。
      そのため、システムや他のユーザに危害をおよぼす危険性をなくし、また、
      他に影響を与えることなくユーザ自身の環境をカスタマイズすることを可能にしています。
    </para>

    <para>システムにアクセスするすべてのユーザは、
      それぞれ唯一のユーザアカウントを持つべきです。
      こうすることで誰が何を行なっているかがわかりますし、
      他の人の設定を壊してしまったり、
      他人のメールを読んでしまうようなことを避けることができます。</para>

    <para>それぞれのユーザは快適にシステムを利用するため、
      シェル、エディタ、キー設定、言語など、
      各自の環境をセットアップすることができます。</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>アカウント情報の変更</title>

    <indexterm>
      <primary>アカウント</primary>
      <secondary>変更</secondary>
    </indexterm>
    <para><command>pw</command>
      は、強力で柔軟性に富むアカウント情報の変更ツールです。
      しかし、業務の多くでは、
      <command>adduser</command> または
      <command>rmuser</command>
      を、それぞれ新しいアカウントをつくる場合と、
      アカウントを削除する場合に使うことが推奨されています。</para>

    <para><command>chpass</command> を使うことで、
      システム管理者、通常のユーザはパスワード、シェル、
      その他の個人情報を変更することができます。
      パスワードを変更したいだけなら、
      <command>passwd</command> コマンドの方が早いです。</para>

    <sect2 id="users-adduser">
      <title>adduser</title>

      <indexterm>
	<primary>アカウント</primary>
	<secondary>追加</secondary>
      </indexterm>
      <indexterm>
	<primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
	<primary><filename class=directory>/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>スケルトンディレクトリ</primary></indexterm>
      <para><command>adduser</command> は、
        新しいユーザを登録するためのシンプルなプログラムです。
	このプログラムは、システムの <filename>passwd</filename> と
	<filename>group</filename> ファイルに新しい項目を作成します。
	また、新規ユーザのホームディレクトリを作成し、
	<filename>/usr/share/skel</filename>
	から、デフォルトで使用される設定ファイル (ドットファイル)
	をコピーします。また、新しく作成されたユーザに対して、
        ウェルカムメッセージをメールで送信することも可能です。
      </para>

      <para>初期設定ファイルを作成するには、
	<command>adduser -s -config_create</command>
        とします<footnote>
	  <para>オプション <option>-s</option> をつけると、
	    デフォルトで詳細を表示しないように
	    <command>adduser</command> を設定します。
            この後に詳細を表示させるようにしたい場合は、
            オプション <option>-v</option> を指定してください。</para>
	</footnote>。
	そして次に <application>adduser</application>
	のデフォルト設定を行ない、最初のユーザアカウントを作成します。
        システムを日常利用する際に <username>root</username> を用いるのは最悪です。</para>

      <example>
	<title>adduser の設定</title>

	<screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh zsh [sh]: <userinput>zsh</userinput>
Your default shell is: zsh -&gt; /usr/local/bin/zsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]: 
Send message from file: /etc/adduser.message no 
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh zsh [zsh]: 
Enter home directory (full path) [/home/jru]: 
Uid [1001]: 
Enter login class: default []: 
Login group jru [jru]: 
Login group is ``jru''. Invite jru into other groups: guest no 
[no]: <userinput>wheel</userinput>
Enter password []: 
Enter password again []: 

Name:	  jru
Password: ****
Fullname: J. Random User
Uid:	  1001
Gid:	  1001 (jru)
Class:	  
Groups:	  jru wheel
HOME:     /home/jru
Shell:	  /usr/local/bin/zsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>簡単に上の操作を説明します。
	まずデフォルトシェルを <application>zsh</application>
        (packages にある追加のシェルです) に変更し、
        新しいユーザにウェルカムメッセージのメールを送付しないようにしました。
        そしてその設定を保存し、<username>wheel</username>
        グループ (後に、
        これが重要な意味を持っていることがわかるでしょう) に所属する
        <username>jru</username>
        というアカウントを作成しています。
      </para>

      <note>
	<para>入力したパスワードは画面に表示されません。
          アスタリスク記号も表示されませんので、
          パスワードを二回とも間違えて入力してしまわないように注意してください。</para>
      </note>

      <note>
	<para>これ以降はオプション引数をつけず単に <command>adduser</command>
          を起動します。
          デフォルト設定を変更する必要はありません。
          もし、adduser がデフォルト設定を変更するかどうか尋ねてきたら、
          adduser を終了し、<option>-s</option>
          オプションを使うようにしてください。</para>
      </note>
    </sect2>

    <sect2 id="users-rmuser">
      <title><application>rmuser</application></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
	<primary>アカウント</primary>
	<secondary>削除</secondary>
      </indexterm>

      <para><command>rmuser</command> を使えば、
	システムから完全にユーザを削除できます。
	<command>rmuser</command> は、次の手順を実行します。</para>

      <procedure>
	<step>
	  <para>指定されたユーザの &man.crontab.1; エントリを削除
            (存在する場合)。</para>
	</step>

	<step>
          <para>指定されたユーザの &man.at.1; ジョブをすべて削除。</para>
	</step>

	<step>
	  <para>指定されたユーザが所有するすべてのプロセスを強制終了。</para>
	</step>

	<step>
	  <para>ローカルパスワードファイルから、
            指定されたユーザのエントリを削除。</para>
	</step>

	<step>
	  <para>指定されたユーザのホームディレクトリを削除
            (ディレクトリの所有者が指定されたユーザのものだった場合)。</para>
	</step>

	<step>
	  <para><filename>/var/mail</filename>
            から、指定されたユーザの到着メールファイルを削除。</para>
	</step>

	<step>
	  <para><filename>/tmp</filename>
            のような一時ファイル保存領域から、
            指定されたユーザの所有するファイルを削除。</para>
	</step>

	<step>
	  <para>そして最後に、
            <filename>/etc/group</filename> にある
            すべてのグループから、指定されたユーザを削除します。
	    
	    <note>
	      <para>
                指定されたユーザと同じ名前のグループで、
                そのユーザが削除されると空のグループとなる場合は、
                そのグループ自体が削除されます。
                これは &man.adduser.8; によってユーザごとに作成される、
                ユニークなグループに対応するものです。
              </para>
	    </note>
	  </para>
	</step>
      </procedure>

      <para>スーパユーザアカウントの削除に
	<command>rmuser</command> を利用することはできません。
        スーパユーザアカウントの削除はほとんどすべての場合、
        大規模なシステムの破壊を意味するからです。
      </para>

      <para>デフォルトでは、
        どういう操作を行なっているか確認できる対話モードが使われます。
      </para>

      <example>
	<title>rmuser による対話的なアカウントの削除</title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/tcsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-pw">
      <title><application>pw</application></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para><command>pw</command> は、
	ユーザやグループの作成、削除、変更および表示を行なうことができ、
	システムユーザファイルやシステムグループファイルの編集機能を持ったコマンドラインのユーティリティです。
	この節では、ユーザに対する使用方法を説明します。
	後の <link linkend="users-groups">グループ</link> 節では、
	グループに対する使用方法を説明します。</para>

      <para>
        これはシェルスクリプトからの利用や、
        直接コマンドを実行する際に便利に使えるように設計されたものです。
      </para>

      <para>詳細については &man.pw.8; をご覧ください。</para>
    </sect2>

    <sect2 id="users-chpass">
      <title><application>chpass</application></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para><command>chpass</command> は、
        パスワード、シェル、その他の個人情報といった、
        ユーザデータベース情報を変更します。
      </para>

      <para>システム管理者に限りスーパユーザ権限で
	<command>chpass</command> を用い、
	他のユーザの情報やパスワードを変更できます。</para>

      <para>ユーザ名の他にオプションを指定しないと、
	<command>chpass</command>
        はユーザ情報を編集するエディタを表示します。
	ユーザがエディタを終了すると、
	ユーザデータベースが新しい情報に更新されます。</para>

      <example>
	<title>スーパユーザによる対話的な chpass</title>

	<screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1000
Gid [# or name]: 1000
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>通常のユーザは、この情報の限られた部分のみ変更が可能です。
        また、変更できるのはそのユーザ自身の情報のみです。
      </para>

      <example>
	<title>通常のユーザによる対話的な chpass</title>

	<screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
	<para><command>chfn</command>、
          <command>chsh</command> はいずれも、
	  単に <command>chpass</command>
	  へのハードリンクになっています。
          また、<command>ypchpass</command>、
	  <command>ypchfn</command> および
	  <command>ypchsh</command> も同様です。
          NIS のサポートは自動的に行なわれますので、
          コマンドの先頭に <literal>yp</literal>
          をつける必要はありません。
        </para>
      </note>
    </sect2>

    <sect2 id="users-passwd">
      <title>パスワードの変更</title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
	<primary>アカウント</primary>
	<secondary>パスワードの変更</secondary>
      </indexterm>
      <para><command>passwd</command> は、
        ユーザが自分のパスワードを変更する通常の方法です。
        スーパユーザ権限では、
        他のユーザのパスワードを変更するのに使われます。
      </para>

      <note>
	<para>ユーザはパスワードを変更する前に、
          もともと設定されていたパスワードを入力しなければなりません。
          これはユーザがコンソールを離れた際に、
          不審な人物によってパスワードが変更されることを防ぐためです。
        </para>
      </note>

      <example>
	<title>自分のパスワードの変更</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>スーパーユーザ権限での他のユーザのパスワード変更</title>

	<screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
	<para><command>yppasswd</command> は、
          単に <command>passwd</command> へのハードリンクになっています。
          NIS のサポートは自動的に行なわれますので、
          コマンドの先頭に <literal>yp</literal>
          をつける必要はありません。</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="users-limiting">
    <title>ユーザへの制限</title>

    <indexterm><primary>ユーザに対する制限</primary></indexterm>
    <indexterm>
      <primary>アカウント</primary>
      <secondary>制限</secondary>
    </indexterm>
    <para>あなたがマルチユーザシステムを運用しているのなら、
      どのユーザもシステムに損害を与えないという信頼はおいていないのではないでしょうか。
      FreeBSD は、
      個々のユーザが利用できるシステムのリソースをシステム管理者が制限する方法をいくつも用意しています。
      その種の制限は一般的には、ディスククォータ (quota)
      とその他のリソースの制限の 2 つに分けられます。</para>

    <indexterm><primary>クォータ (quotas)</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>クォータ</secondary>
    </indexterm>
    <indexterm><primary>disk quotas</primary></indexterm>
    <para>ディスククォータは、
      システム管理者がファイルシステムにユーザが使用できるディスク領域の量を指示する手段です。
      さらに、その都度測定しなくてもユーザのディスク使用量を簡単に確認できる手段も提供しています。
      クォータについては、<xref linkend="quotas"> で解説しています。</para>

    <para>その他のリソースの制限とは、ユーザが消費できる
      CPU、メモリなどのリソースを制限する手段のことです。
      これはログインクラスを用いて定義されているもので、
      この後で解説しています。</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>ログインクラスは <filename>/etc/login.conf</filename>
      で定義します。詳細な働きの説明はこの節の範囲を超えますが、
      &man.login.conf.5; のマニュアルに詳しく記載されています。
      各ユーザにはログインクラスが割り当てられていて
      (デフォルトでは <literal>default</literal> です)、
      それぞれのログインクラスにはログインケーパビリティの集合が割り当てられているといえば十分でしょう。
      ログインケーパビリティとは、
      <literal><replaceable>名称</replaceable>=<replaceable>値</replaceable></literal>
      の組のことで、<replaceable>名称</replaceable>
      は周知の識別子、<replaceable>値</replaceable>
      は、名称に応じて処理される任意の文字列です。
      ログインクラスとケーパビリティを設定するのはどちらかといえば簡単なことで、
      &man.login.conf.5; でも説明されています。</para>

    <para>リソースの制限は、
      2 つの点で標準的なログインケーパビリティと異なっています。
      第一に、どの制限についても、ソフト (現在の)
      リミットとハードリミットがあります。
      ソフトリミットは、ユーザやアプリケーションが調整できますが、
      ハードリミットを超えることはできません。
      ユーザはハードリミットを下げることはできますが、上げることはできません。
      第二に、ほとんどのリソースの制限は特定のユーザに対してプロセス毎に適用されるもので、
      そのユーザが利用するリソースの総量を制限するものではありません。
      ただし、この違いは制限を特別扱いすることで実現されるものであり、
      ログインケーパビリティフレームワークの実装によるものではありません
      (つまり、リソースの制限は、
      <emphasis>実際には</emphasis>ログインケーパビリティの特別な場合ではないのです)。</para>

    <para>難しい話はこのくらいにしておいて、
      以下が最もよく使われるリソースの制限になります
      (残りは、他のすべてのログインケーパビリティと並んで
      &man.login.conf.5; に書かれています)。</para>

    <variablelist>
      <varlistentry>
	<term><literal>coredumpsize</literal></term>

	<listitem>
    <indexterm><primary>coredumpsize</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>coredumpsize</secondary>
    </indexterm>
	  <para>プログラムが生成する core
	  ファイルのサイズにかかる制限は、
	  自明な理由でほかのディスク使用に関する制限に従属します
	  (例: <literal>filesize</literal> やディスククォータ)。それでも、
	  ディスク領域の消費を制御するあまり厳しくない手段としてよく使われています。
	  ユーザは core ファイルを自分で生成するわけではなく、
	  削除しないことも多いので、これを設定すれば大きなプログラム
	  (たとえば <application>Emacs</application>)
	  が異常終了してもディスクの空きがなくならずに済みます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

	<listitem>
    <indexterm><primary>cputime</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>cputime</secondary>
    </indexterm>
	  <para>そのユーザのプロセスが消費できる CPU 時間の上限です。
	    これを超えたプロセスは、カーネルにより終了されます。

	    <note>
	      <para>これは、消費される CPU <emphasis>時間</emphasis> 
		についての制限であって、&man.top.1; や&man.ps.1;
		の項目のどれかに表示される
		CPU の割合に関するものではありません。
		これを書いている時点では後者の制限はかけられませんし、
		役にたたないでしょう。たとえば
		(正当なタスクである可能性が高い)
		コンパイラはたやすく一定時間
		CPU を 100% 近く使ってしまいます。</para>
	    </note>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

	<listitem>
    <indexterm><primary>filesize</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>filesize</secondary>
    </indexterm>
	  <para>ユーザが所有できるファイルの大きさの上限です。<link
	    linkend="quotas">ディスククォータ</link> と違い、
	    この制限はユーザのファイルをすべてまとめた集合にではなく、
	    個々のファイルにかかります。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

	<listitem>
    <indexterm><primary>maxproc</primary></indexterm>
        <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>maxproc</secondary>
    </indexterm>
	  <para>ユーザが実行できるプロセス数の上限です。
	    フォアグラウンドプロセスとバックグラウンドプロセスの両方を平等に扱います。
	    自明な理由から、<command>sysctl</command> 変数
	    <varname>kern.maxproc</varname>
	    で指定されたシステムの制限を超えることはできません。
	    また、同時に複数ログインすることや、
	    パイプライン実行することは便利なことが多いので、
	    この値をあまり小さな値に設定すると、
	    そのユーザの生産性が悪化することにも注意してください。
	    大きなプログラムをコンパイルする場合のように、
	    タスクによっては複数のプロセスが実行されます (たとえば
	    &man.make.1;, &man.cc.1;
	    や、その他仲立ちとなるプリプロセッサ)。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

	<listitem>
    <indexterm><primary>memorylocked</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>memorylocked</secondary>
    </indexterm>
	  <para>これは、
	    1 つのプロセスがメインメモリにロックされることを要求できるメモリの最大容量です
	    (&man.mlock.2; をご覧ください)。&man.amd.8;
	    のようなシステムで重要なプログラムは、
	    問題発生時にスワップアウトされてしまって、
	    システムのスラッシングを引き起こさないように、
	    メインメモリへのロックを要求します。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memoryuse</literal></term>

	<listitem>
    <indexterm><primary>memoryuse</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>memoryuse</secondary>
    </indexterm>
	  <para>これは、どの時点かを問わず、
	    あるプロセスが消費できる最大のメモリ容量です。
	    これは、メインメモリとスワップの使用量を合わせたものです。
	    メモリ消費を抑えるための包括的な制限ではありませんが、
	    手始めにはよいでしょう。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>openfiles</literal></term>

	<listitem>
    <indexterm><primary>openfiles</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>openfiles</secondary>
    </indexterm>
	  <para>これは、あるプロセスが開いておける最大のファイル数です。
	    FreeBSD では、ファイルはまた、ソケットや
	    IPC チャンネルを表わすのにも使われています。
	    ですから、あまり低い値に設定しないよう注意してください。
	    これに対応するシステム全体の制限は
	    <command>sysctl</command> 変数
	    <varname>kern.maxfiles</varname> で定義されています。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>sbsize</literal></term>

	<listitem>
    <indexterm><primary>sbsize</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>sbsize</secondary>
    </indexterm>
	  <para>これは、あるユーザが消費できるネットワークメモリ
	    (つまり mbuf) の上限の量です。これは、
	    大量のソケットを生成する古いサービス拒否攻撃に対応するものとして作られましたが、
	    一般的にはネットワーク通信を制限するのに使えます。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>stacksize</literal></term>

	<listitem>
    <indexterm><primary>stacksize</primary></indexterm>
    <indexterm>
      <primary>ユーザに対する制限</primary>
      <secondary>stacksize</secondary>
    </indexterm>
	  <para>これは、プロセスのスタックサイズの上限です。
	    あるプログラムが使用しうるメモリの量を制限するには、
	    これだけでは十分ではありません。
	    したがって、他の制限と組み合わせて使わなければなりません。</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>リソースの制限を設定するにあたり、
      ほかにもいくつか覚えておかなければならないことがあります。
      以下は、一般的なこつやお勧め、さまざまなコメントになります。</para>

    <itemizedlist>
      <listitem>
	<para>システム起動時に <filename>/etc/rc</filename>
	  から起動されたプロセスは、<literal>daemon</literal>
	  ログインクラスに割り当てられます。</para>
      </listitem>

      <listitem>
	<para>システムに付属していた
	  <filename>/etc/login.conf</filename>
	  はほとんどの制限について妥当な値になっていますが、
	  あなたのシステムに何がふさわしいか分かるのは、
	  管理者であるあなただけです。
	  制限をあまり緩くするとシステムを悪用しやすくしてしまいますし、
	  厳しくしすぎると生産性を悪化させてしまいます。</para>
      </listitem>

      <listitem>
	<para>X Window System (X11) のユーザには、
	  他のユーザより多くのリソースを与えるべきかもしれません。
	  X11 そのものが多くのリソースを使うだけでなく、
	  より多くのプログラムを並行して使うことをユーザに促します。</para>
      </listitem>

      <listitem>
	<para>多くの制限は個々のプロセスにかかるもので、
	  一人のユーザにまとめてかかるものではないことを忘れないでください。
	  例えば、<varname>openfiles</varname> を 50 に設定することは、
	  ユーザが動かすそれぞれのプロセスが最大
	  50 個のファイルを開けるということです。
	  したがって、あるユーザが開けられるファイルの総数は、
	  <literal>openfiles</literal> の値に <literal>maxproc</literal>
	  をかけたものになります。
	  同じことがメモリ消費量にもあてはまります。</para>
      </listitem>
    </itemizedlist>

    <para>リソースの制限と、ログインクラス、
      ログインケーパビリティ一般についての詳しい情報は、
      それぞれのマニュアルページ、
      &man.cap.mkdb.1;, &man.getrlimit.2;, &man.login.conf.5;
      をご覧ください。</para>
  </sect1>

  <sect1 id="users-personalizing">
    <title>ユーザ個別の設定</title>

    <para>地域化 (localization) とは、
      それぞれ異なる言語、キャラクタセット、
      日付や時間の標準などに適応させるための環境設定を、
      システム管理者やユーザが行なうことを指します。
      地域化については、
      <link linkend="l10n">地域化の章</link>に書かれています。</para>
  </sect1>

  <sect1 id="users-groups">
    <title>グループ</title>

    <indexterm><primary>グループ</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>アカウント</primary>
      <secondary>グループ</secondary>
    </indexterm>
    <para>グループとは、単にユーザを羅列したものです。
      グループは、グループ名と gid (グループ ID) で識別されます。
      FreeBSD (と他の Unix システムのほとんど) では、
      あるプロセスが何かするのを許可するかどうかをカーネルが判断する際に利用する
      2 つの因子は、ユーザ ID とそのユーザが所属するグループの一覧です。
      ユーザ ID と異なり、プロセスはそのプロセスに関係付けられたグループの一覧を持ちます。
      どこかで "グループ ID" に触れているのを聞くことがあるでしょうが、
      ほとんどの場合は、これは単に一覧の最初のグループを指しています。</para>

    <para>グループ名からグループ ID への写像は
      <filename>/etc/group</filename> にあります。
      これは、コロンで区切られた 4 項目からなるテキストファイルです。
      1 番目の項目はグループ名、
      2 番目は暗号化されたパスワード、
      3 番目がグループ ID、
      4 番目がカンマで区切られたメンバの一覧です。
      これは手で編集して問題ありません
      (もちろん、文法をまったく間違えない限りはですが)。
      文法についての完全な説明は、&man.group.5; をご覧ください。</para>

    <para><filename>/etc/group</filename> を手で編集したくなければ、
      &man.pw.8; コマンドを使ってグループの追加や編集をできます。
      たとえば、<groupname>teamtwo</groupname>
      というグループを追加して、その存在を確認するには、
      次のように使えばできます。</para>

    <example>
      <title>&man.pw.8; によるグループの追加</title>

      <screen>&prompt.root; <userinput><command>pw</command> groupadd <groupname>teamtwo</groupname></userinput>
&prompt.root; <userinput><command>pw</command> groupshow <groupname>teamtwo</groupname></userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>上記の <literal>1100</literal> という番号は、
      <groupname>teamtwo</groupname> グループのグループ ID です。
      この時点では、<groupname>teamtwo</groupname>
      にはメンバがおらず、あまり意味がありません。
      <username>jru</username> を <groupname>teamtwo</groupname>
      に参加させて、この状況を変えましょう。</para>

    <example>
      <title>&man.pw.8; によるグループへのユーザ追加</title>

      <screen>&prompt.root; <userinput><command>pw</command> groupmod <groupname>teamtwo</groupname> <option>-M</option> <username>jru</username></userinput>
&prompt.root; <userinput><command>pw</command> groupshow <groupname>teamtwo</groupname></userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para><option>-M</option> オプションの引数は、
      カンマで区切られたグループに所属するユーザの一覧です。
      前の節から、
      パスワードファイルに各ユーザのグループが記載されていることがわかります。
      前者 (ユーザ) は、システムが自動的にグループ一覧に追加します。
      &man.pw.8; の <command>groupshow</command> コマンドを使った時は、
      そのユーザはグループの一員として表示されませんが、&man.id.1;
      などのツールを使って情報を問い合わせれば、
      その情報を引き出せます。つまり、&man.pw.8; は
      <filename>/etc/group</filename> しか扱わず、
      <filename>/etc/passwd</filename> のデータを読んだりはしません。</para>

    <example>
      <title>グループに所属しているユーザを調べるための &man.id.1; の使い方</title>

      <screen>&prompt.user; <userinput><command>id</command> <username>jru</username></userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>見れば分かりますが、<username>jru</username> は
      <groupname>jru</groupname> グループと
      <groupname>teamtwo</groupname> グループのメンバです。</para>

    <para>&man.pw.8; について詳しくはマニュアルページをご覧ください。
      <filename>/etc/group</filename> のフォーマットの詳細については、
      &man.group.5; マニュアルページをご覧ください。</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
