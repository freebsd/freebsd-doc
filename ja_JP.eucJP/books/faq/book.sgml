<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V3.1-Based Extension//EN" [
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN">
%man;
]>
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.45 -->

<book>
  <bookinfo>
    <title>FreeBSD 2.X と 3.X についての FAQ (よくある質問とその答え)</title>

    <authorgroup>
      <author>
        <surname>The FreeBSD Documentation Project</surname>
      </author>
    </authorgroup>

    <pubdate>$FreeBSD: doc/ja_JP.eucJP/books/faq/book.sgml,v 1.31 2000/03/11 00:09:05 kuriyama Exp $</pubdate>

    <abstract>
      <para>
        これは FreeBSD システムバージョン 2.X と 3.X についての FAQ です.
        特に断わりがない限りはどの項目も FreeBSD 2.0.5 以降のものを想定しています.
        &lt;XXX&gt; のついている項目はまだ作業中のものです.
        この FreeBSD ドキュメンテーション プロジェクトに協力したいと思ったら,
        FreeBSD ドキュメンテーションプロジェクトメーリングリスト
        <ulink URL="mailto:freebsd-doc@FreeBSD.org">&lt;freebsd-doc@FreeBSD.ORG&gt;</ulink>
        <!-- hrs:2000/03/09 should be email tag? -->
        まで(英語で)電子メールを送ってください.
        この文書の最新バージョンは, いつでも
        <ulink URL="http://www.jp.FreeBSD.org/">日本国内版 FreeBSD World Wide Web サーバ</ulink>や
        <ulink URL="http://www.FreeBSD.org/">FreeBSD World Wide Web サーバ</ulink>で
        見ることができます.
        また, ひとつの巨大な <ulink URL="book.html">HTML</ulink>
        ファイルとして HTTP でダウンロードすることもできます.
        プレーンテキスト, PostScript, PDF 形式のものは
        <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc">FreeBSD
          FTP サーバ</ulink>に置かれています.
        また, <ulink URL="http://www.FreeBSD.org/search/search.html">FAQ
          の検索</ulink>も可能です.

        <note>
          <!-- hrs:2000/03/09 This notice added by hrs -->
          <!-- title>HTML 版以外の日本語 FAQ について</title -->
          <!-- hrs:2000/03/09 TITLE rendered strangely, so comment this out.-->
          <para>
            2000 年 3 月現在, HTML 版以外の日本語 FAQ は用意されていません.
          </para>
        </note>
      </para>

      <para>
        日本語版の作成は FreeBSD 日本語ドキュメンテーションプロジェクトが
        オリジナルの英語版をもとにしておこなっています.
        日本語訳および,  日本語版のみに関することは,
        FreeBSD 日本語ドキュメンテーションプロジェクト
        <email>doc-jp@jp.FreeBSD.org</email> において日本語で議論されています. 
        必要に応じて日本語ドキュメンテーションプロジェクトから,
        FreeBSD Documentation Project に対してフィードバックをおこないますので,
        英語が得意でない方は FreeBSD 日本語ドキュメンテーションプロジェクト
        <email>doc-jp@jp.FreeBSD.org</email> まで日本語でコメントをお寄せください.
      </para>
  
      <para>また, この FreeBSD FAQ とは別に, 日本の FreeBSD ユーザ有志によって
        メーリングリスト
        <ulink URL="mailto:FreeBSD-users-jp@jp.FreeBSD.org">FreeBSD-users-jp</ulink>
        やニュースグループ
        <ulink URL="news:fj.os.bsd.freebsd">fj.os.bsd.freebsd</ulink>
        などへの投稿をもとに作成された
        <ulink URL="http://www.jp.FreeBSD.org/QandA/">QandA</ulink>
        が公開されています.
        特に日本語環境など日本固有の話題が充実していますので,
        こちらも合わせてご覧ください.
      </para>
    </abstract>
  </bookinfo>

  <preface id="preface">
    <title>まえがき</title>

    <para>
      <emphasis>訳:
        くりやま <email>kuriyama@opt.phys.waseda.ac.jp</email>,
        花井 浩之 <email>hanai@jp.FreeBSD.org</email>,
        中井 幸博 <email>nakai@mlab.t.u-tokyo.ac.jp</email>,
        今野 元之 <email>motoyuki@jp.FreeBSD.org</email>,
        杉村 貴士 <email>sugimura@jp.FreeBSD.org</email>,
        1997 年 11 月 5 日.
      </emphasis>
    </para>
  
    <para>
      FreeBSD 2.X-3.X FAQ へようこそ!
    </para>
  
    <para>
      Usenet の FAQ がそうであるように,
      この文書も FreeBSD オペレーティングシステムに関して
      頻繁に尋ねられる質問を網羅することを目的としています(もちろんそれに対する答えも!).
      FAQ は本来バンド幅を減らし,
      同じ質問が何度も繰り返されるのを避けるために作られたものですが,
      最近は有用な情報源と見なされるようになってきました.
    </para>
    
    <para>
      この FAQ をできる限り有用なものにしようと,
      あらゆる努力がはらわれています.
      もし何かしらの改善案が浮かんだら, ぜひ
      <ulink URL="mailto:FAQ@FreeBSD.org">FAQ 管理者</ulink> まで
      メールを送ってください.
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>FreeBSD って何?</para>
        </question>

        <answer>
          <para>FreeBSD 2.X は, カリフォルニア大学バークレイ校から
            i386 系のプラットフォーム向けにリリースされた 4.4BSD-lite
            をもとにした UN*X ライクなオペレーティングシステムです.
            間接的には同じバークレイ校の Net/2 を William Jolitz が
            i386 系に移植した 386BSD も基にしていますが,
            386BSD のコードはほとんど残っていません.
            FreeBSD についての詳細と, 何ができるかについては
            <ulink URL="http://www.FreeBSD.org/">FreeBSD のホームページ</ulink>
            を参照してください.
          </para>
  
          <para>
            FreeBSD は企業やインターネットサービスプロバイダ, 研究者,
            コンピュータ専門家, 学生, 家庭のユーザなどにより, 業務や教育,
            娯楽に用いられています. これらに関しては
            <ulink URL="../gallery/gallery.html">FreeBSD ギャラリー</ulink>
            をご覧下さい.
          </para>
  
          <para>
            FreeBSD に関するより詳しい情報は 
            <ulink URL="../handbook/index.html">FreeBSD ハンドブック</ulink>
            を参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD が目指しているもの</para>
        </question>

        <answer>
          <para>
            FreeBSD プロジェクトの目的は,
            いかなる用途にも使用でき,
            何ら制限のないソフトウェアを供給することです.
            私たちの多くは,
            コード(そしてプロジェクト)に対してかなりの投資をしてきており,
            これからも多少の代償はあっても投資を続けて行くつもりです.
            ただ, 他の人達にも同じような負担をするように主張しているわけではありません.
            FreeBSD に興味を持っている一人残らず全ての人々に,
            目的を限定しないでコードを提供すること.
            これが,
            私たちの最初のそして最大の「任務」であると信じています.
            そうすれば, コードは可能な限り広く使われ,
            最大の恩恵をもたらすことができるでしょう.
            これが, 私たちが熱烈に支持しているフリーソフトウェアの最も基本的な目的であると,
            私は信じています. 
          </para>
  
          <para>
            私たちのソースツリーに含まれるソースのうち, GNU
            一般公有使用許諾(GPL) または GNU ライブラリ
            一般公有使用許諾(GLPL) に従っているものについては,
            多少制限が科されています. ただし,
            ソースコードへのアクセスの保証という,
            一般の制限とはいわば逆の制限です.
            ただし GPL ソフトウェアを商用で利用する場合,
            さらに複雑になるのは避けられません.
            そのため, それらのソフトウェアを, より制限の少ない
            BSD 著作権に従ったソフトウェアで置き換える努力を,
            可能な限り日々続けています.

            <note>
              <title>訳注</title>
              <para>
                GPL では, 「ソースコードを実際に受け取るか,
                あるいは希望しさえすればそれを入手することが可能であること」を求めています.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どうして FreeBSD と呼ばれているのですか?</para>
        </question>

        <answer>
          <para>
            <itemizedlist>
              <listitem>
                <para>無料(free)で使うことができる(商利用も含む).
                </para>
              </listitem>

              <listitem>
                <para>オペレーティングシステムの完全なソースコードが自由(freely)に手に入り,
                  商利用・非商利用にかかわらず, 最低限の制限で他の仕事への利用, 配布, 導入が可能.
                </para>
              </listitem>

              <listitem>
                <para>改良やバグフィックスがある場合,
                  誰でも(free)そのコードを提出でき,
                  ソースツリーに加えることができます
                  (いくつかの簡単な条件には従ってもらいます).</para>
              </listitem>

            </itemizedlist>
          </para>
  
          <para>
            母国語が英語でない読者のために, ここでは &ldquo;free&rdquo;
            という単語が二つの意味で用いられていることを指摘しておくと分かりやすいかも知れません.
            ひとつは「無料である」ということ,
            もうひとつは「自分のやりたいようにできる」ということです.
            FreeBSD のコードで<emphasis remap=tt>できない</emphasis>いくつかのこと
            (自分が書いたものだと偽るなど)を除けば,
            あなたは自分のやりたいことをやることが可能なのです. 
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD の最新バージョンは?</para>
        </question>
        <answer>

          <para>
            <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/3.4-RELEASE/">3.4</ulink>
            が最新の <emphasis>stable</emphasis> バージョンで,
            1999 年 12 月にリリースされました.
            また, これは最新の <emphasis>release</emphasis>
            バージョンでもあります.
          </para>
  
          <para>
            簡単に言ってしまうと, <emphasis>-STABLE</emphasis>
            は最新の <emphasis>-CURRENT</emphasis> 
            のスナップショットのすばらしい新機能の数々よりも,
            安定性と変更回数の少なさを好む ISP や,
            他の企業のユーザをターゲットにしています.
            リリースはこの二種類の &ldquo;ブランチ&rdquo; で行なわれますが,
            (<emphasis>-STABLE</emphasis>
            と比較すると多少)不安定な動作があるということを許容できるなら,
            必要となるのは <emphasis>-CURRENT</emphasis> の方だけでしょう.
          </para>

          <para>
            各リリースは<link linkend="release-freq">
              数カ月毎</link>にしか行なわれません.
            多くの人々が FreeBSD のソースをそのリリースよりも
            最新の状態に維持している(<link linkend="current">FreeBSD-current</link>
            と
            <link linkend="stable">FreeBSD-stable</link>
            に関する質問も参照して下さい)のですが,
            ソースというのは常に改変され続けているため,
            そうすることは一種の慣例になっています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="current">
          <para>FreeBSD-CURRENTって何?</para>
        </question>

        <answer>
          <para>
            <ulink URL="../handbook/cutting-edge.html#CURRENT">FreeBSD-CURRENT</ulink>
            はオペレーティングシステムのの開発バージョンで,
            やがて 4.0-RELEASE となります. よってこれは, そこに携わっている開発者や,
            どんな障害をも乗り越えていけるタフな愛好家たちにとってのみ興味の対象となるものです.
            -CURRENT の使用に際しての詳細は
            <ulink URL="../handbook/index.html">FreeBSD ハンドブック</ulink>
            の
            <ulink URL="../handbook/cutting-edge.html#CURRENT">関連するセクション</ulink>
            を参照してください.
          </para>
  
          <para>
            オペレーティングシステムに馴染みがない場合や,
            それが一時的に発生している問題なのか,
            それとも本質的な問題かを見極める能力がない場合は,
            FreeBSD-CURRENT を使うべきではありません.
            このブランチは時々急激に拡張されたり, 
            システムが構築できない状態になることもちょっちゅうあります. 
            FreeBSD-CURRENT を使う人は問題を分析し,
            「小さな欠陥」ではなく,
            明らかに間違いであると思われるものだけを報告できるものと想定されています.
            「make world したら group 関係でエラーがでました」のような質問は,
            -CURRENT メーリングリストでは軽蔑の眼差しであしらわれることもあります.
          </para>
  
          <para>時たま, -CURRENT の開発コードから
            <ulink URL="../releases/snapshots.html">snapshot</ulink> が作成され,
            snapshot の中からは 配布 CD-ROM が作成されることもあります.
            それぞれの snapshot には以下のような目的があります.
          </para>
  
          <para>
            <itemizedlist>

              <listitem>
                <para>インストールプログラムの最新版のテスト.
                </para>
              </listitem>
              
              <listitem>
                <para>
                  試してみたいけれど,
                  基礎的な所から毎日変わるようなものを追いかける時間もバンド幅も無い,
                  という人にも -CURRENT を使えるようにする.
                  また, そのような人たちのシステム移行のための手っ取り早い方法を提供する.
                </para>
              </listitem>

              <listitem>
                <para>
                  あとでとんでもないことをしてしまった時のために, 
                  問題となるコードの特定の参照基準点を保存しておく.
                  (通常は CVS がこういうハプニングのような恐ろしい事態を防止して
                  いるんですけどね :)
                </para>
              </listitem>

              <listitem>
                <para>
                  テストが必要な新しい機能を,
                  できる限り多くの隠れテスターに試してもらう.</para>
              </listitem>
              
            </itemizedlist>
          </para>
  
          <para>
            どんな目的であれ, snapshot
            が「製品レベルの品質」であるとの考えに基づく要求は行わないでください.
            安定性やテスト十分性にこだわる人は,
            完全なリリースから離れてはいけません.
          </para>
  
          <para>
            4.0-CURRENT および
            3.0-STABLEブランチの snapshot は, 
            両方とも平均一日に一回構築されており,
            <ulink URL="ftp://current.FreeBSD.org/pub/FreeBSD/">ftp://current.FreeBSD.org/pub/FreeBSD/</ulink>
            から直接入手することができます.
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="stable">
          <para>FreeBSD-STABLE のコンセプトは何ですか?</para>
        </question>

        <answer>
          <para>
            FreeBSD 2.0.5 がリリースされた後, 私たちは FreeBSD の開発を
            2 系統に分割することにしました.
            一つは <ulink URL="../handbook/stable.html">-STABLE</ulink>
            というブランチで, バグの修正はしっかりテストされ, 
            機能の強化は少しずつしか行われません(急な変更や実験的機能を望まない, 
            インターネットサービスプロバイダや営利企業向け).
            もう一方のブランチは 
            <ulink URL="../handbook/cutting-edge.html#CURRENT">-CURRENT</ulink>
            で, 2.0 がリリースされて以来
            4.0-RELEASE(そしてその後も)へ向けて脈々と続いているものです.
            ASCII で描いた簡単な図がわかりやすいかは自信がありませんが,
            こんな感じになります.
          </para>
  
          <para>
            <literallayout>                 2.0
                  |
                  |
                  |  [2.1-STABLE]
 *BRANCH*       2.0.5 -&gt; 2.1 -&gt; 2.1.5 -&gt; 2.1.6 -&gt; 2.1.7.1  [2.1-STABLE 終了]
                  |                            (1997年3月)
                  |
                  |
                  |  [2.2-STABLE]
 *BRANCH*       2.2.1 -&gt; 2.2.2-RELEASE -&gt; 2.2.5 -&gt; 2.2.6 -&gt; 2.2.7 -&gt; 2.2.8 [終了]
                  |       (1997年3月)  (97年10月) (98年4月)(98年7月)(98年12月)
                  |
                  |
               3.0-SNAPs  (1997年第一四半期開始)
                  |
                  |
             3.0.0-RELEASE (1998年10月)
                  |
                  |  [3.0-STABLE]
 *BRANCH*        3.1  (Feb 1999) -&gt; 3.2 -&gt; ... 今後の 3.x リリース群 ...
                  |               (1999年5月)
                  |
                 \|/
                  +
          [4.0-CURRENT として継続中]</literallayout>
          </para>
  
          <para>
            -CURRENT ブランチは
            4.0 とその先へ向けてゆっくりと進化を続けており, 
            従来の 2.2-STABLE ブランチは 2.2.8 のリリースをもって終了しました. 
            3.4-STABLE がそれに代わり, 1999 年の 12 月半ばに 3.4
            がリリースされました.
            4.0-CURRENT が現在の &ldquo;current branch&rdquo; であり,
            最初の 4.0 系列のリリースは 2000 年第一四半期の予定です.
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="release-freq">
          <para>FreeBSD のリリースはいつ作られるのですか?</para>
        </question>

        <answer>
          <para>
            FreeBSD コアチームは原則的に,
            新しい機能やバグフィックスが充分集まり,
            リリースの安定性を損なうことが無いよう,
            さまざまな変更が十分に安定しているという条件を満たしている場合にのみ, 
            新しいバージョンの FreeBSD をリリースします.
            たとえこの用心深さが新しい機能が使えるようになることを
            待ち望んでいるユーザを欲求不満にさせるとしても,
            多くのユーザはこのことを FreeBSD
            の最も良い所の一つだと考えています.
          </para>
  
          <para>
            リリースの作成は, 平均的に言っておよそ 4 ヶ月ごとに行なわれます.
          </para>
  
          <para>
            もう少し刺激が欲しい(あるいは待ち遠しい)方々向けに SNAP 
            というものがあります.  これは特にリリースに近付いてきた数ヶ月
            ぐらいの期間により頻繁に公開されます.
          </para>
          <!-- hrs:2000/03/09 needs to refine translation -->
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD は PC 用だけしかないの?</para>
        </question>

        <answer>
          <para>
            現在 FreeBSD 3.x は x86 アーキテクチャと同様,
            <ulink URL="../alpha/alpha.html">DEC Alpha</ulink> でも動作します. 
            また, SPARC への移植という興味深い話もありますが, 
            このプロジェクトの詳細については未だ不透明です.
          </para>
  
          <para>
            異なるアーキテクチャのマシンを
            持っていて, ゆっくり待てないという場合には次の URL を
            参照してください.
          </para>
  
          <para>
            <ulink URL="http://www.netbsd.org/">NetBSD</ulink>
            または
            <ulink URL="http://www.openbsd.org/">OpenBSD</ulink>.
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD の責任者はいったい誰?</para>
        </question>

        <answer>
          <para>
            プロジェクトの全体的な方向性や,
            誰にソースツリーにコードの書き込み権限を与えるか,
            などといった FreeBSD プロジェクトに関する重要な意思決定は,
            15 名からなる<ulink URL="../handbook/staff.html#STAFF-CORE">コアチーム(core team)</ulink>によってなされます. 
            ソースツリーを直接変更できる人はもっと多く,
            150 名以上の<ulink URL="../handbook/staff:committers.html">ソースツリー管理者(committer)</ulink> がいます.
          </para>
  
          <para>
            しかし, <link linkend="mailing">メーリングリスト</link>で先行して議論される,
            通常の変更ではないものの議論への参加には, 一切制限はありません.
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="where-get">
          <para>どこから FreeBSD を入手できますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD のすべての主要なリリースは anonymous FTP 経由で
            <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/">FreeBSD FTP サイト</ulink>
            から入手できます.
          </para>
  
          <para>
            <itemizedlist>

              <listitem>
                <para>
                  現在の 2.2-STABLE リリース, 2.2.8R は 
                  <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/2.2.8-RELEASE/">FreeBSD 2.2.8-RELEASE</ulink>
                  にあります.
                </para>
              </listitem>

              <listitem>
                <para>
                  現在の 3.X-STABLE, 3.X-RELEASE は 
                  <ulink URL="ftp://current.FreeBSD.org/pub/FreeBSD/releases/i386/3.4-RELEASE/">3.4-RELEASE</ulink>
                  にあります.
                </para>
              </listitem>

              <listitem>
                <para>
                  保守状態にある
                  RELENG_2_2 ブランチ(2.2.8 以降)から, 一日に一回 
                  <ulink URL="ftp://releng22.FreeBSD.org/pub/FreeBSD/">2.2 Snapshot</ulink>
                  リリースが作成されます.
                  RELENG_2_2 ブランチは現在, 保守要員によって注意深く保守されており, 
                  セキュリティや信頼性面での強い必要性がなければ, 変更が加えられる
                  ことはありません. 
                </para>
              </listitem>

              <listitem>
                <para>
                  3.4-RELEASE へ向けた
                  <ulink URL="ftp://releng30.FreeBSD.org/pub/FreeBSD/">3.X Snapshot</ulink>
                  リリースも一日に一回, 
                  RELENG_3 ブランチ(3.0-RELEASE 以降)から作成されます. 
                </para>
              </listitem>

              <listitem>
                <para>
                  <ulink URL="ftp://current.FreeBSD.org/pub/FreeBSD/">4.0 Snapshot</ulink>
                  リリースは <link linkend="current">-CURRENT</link>
                  ブランチ用に一日に一回作成されており,
                  これらは純粋に最先端の開発者およびテスターのために提供されています.
                </para>
              </listitem>

            </itemizedlist>
          </para>
  
          <para>
            また, FreeBSD は CD-ROM でも入手でき, 次のところで注文できます.
          </para>

	  <address>
	    <otheraddr>Walnut Creek CDROM</otheraddr>
	    <street>4041 Pike Lane, Suite F</street>
	    <city>Concord</city>, <state>CA</state>  <postcode>94520</postcode>
	    <country>USA</country>

	    <phone>Orders:	+1 800 786-9907</phone>
	    <phone>Questions:	+1 925 674-0783</phone>
	    <fax>FAX:		+1 925 674-0821</fax>
	    <otheraddr>email:	<ulink URL="mailto:orders@cdrom.com">WC Orders address</ulink></otheraddr>
	    <otheraddr>WWW:	<ulink URL="http://www.cdrom.com/">WC Home page</ulink></otheraddr>
	  </address>
  
          <para>
            オーストラリアでは, 次のところに問い合わせてください.
          </para>
  
	  <address>
	    <otheraddr>Advanced Multimedia Distributors</otheraddr>
	    <street>Factory 1/1 Ovata Drive</street>
	    <city>Tullamarine, Melbourne</city>
	    <state>Victoria</state>
	    <country>Australia</country>
	    <phone>Voice:	+61 3 9338 6777</phone>
	    <otheraddr>CDROM Support BBS</otheraddr>
	    <street>17 Irvine St</street>
	    <city>Peppermint Grove</city>, <state>WA</state> <postcode>6011</postcode>
	    <phone>Voice:	+61 9 385-3793</phone>
	    <fax>Fax:		+61 9 385-2360</fax>
	  </address>

          <para>イギリスの場合は次のところです.</para>

	  <address>
	    <otheraddr>The Public Domain &amp; Shareware Library</otheraddr>
	    <street>Winscombe House, Beacon Rd</street>
	    <city>Crowborough</city>
	    <state>Sussex. TN6 1UL</state>
	    <phone>Voice:	+44 1892 663-298</phone>
	    <fax>Fax:		+44 1892 667-473</fax>
	  </address>
	</answer>
      </qandaentry>

      <qandaentry>
        <question id="mailing">
          <para>FreeBSD のメーリングリストについて知りたいのですが?</para>
        </question>

        <answer>

          <para>
            完全な情報が 
            <ulink URL="../handbook/eresources.html#ERESOURCES-MAIL">FreeBSD
              ハンドブックのメーリングリストの節</ulink>
            にあります.
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD の西暦 2000 年問題に関する情報はどこにありますか?</para>
        </question>

        <answer>
          <para>
            完全な情報が
            <ulink URL="http://www.FreeBSD.org/y2kbug.html">
              FreeBSD Y2K のページ</ulink>
            にあります.
          </para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD のニュースグループは何がありますか?</para>
        </question>

        <answer>
          <para>完全な情報が  
            <ulink URL="../handbook/eresources-news.html">FreeBSD
              ハンドブックのニュースグループの節</ulink>にあります.
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD の IRC(Internet Relay Chat)について何か情報はありますか?</para>
        </question>

        <answer>
          <para>
            あります.
            FreeBSD チャットチャンネルのもっとも主要な IRC
            ネットワークホストは以下のとおりです.
          </para>
  
          <para>
            <itemizedlist>

              <listitem>
                <para>EFNet の Channel <emphasis remap=tt>#FreeBSD</emphasis> は
                  FreeBSD 関係のフォーラムですが,
                  そこで技術的サポートを期待してはいけません.
                  そこにいる人たちはあなたをマニュアルページを読むとか,
                  研究をするとかといった苦労から遠ざけようとします.
                  まず第一に, これはチャットチャンネルであり,
                  そこにあるトピックスは恋人募集, スポーツ,
                  核兵器といったようなものであり, 
                  FreeBSD も同列に扱われています.
                  一応注意しましたからね! これは
                  <hostid>irc.chat.org</hostid> のサーバー上にあります.
                </para>
              </listitem>

              <listitem>
                <para>DALNET の Channel <emphasis remap=tt>#FreeBSD</emphasis>
                  はアメリカでは
                  <hostid>irc.dal.net</hostid>,
                  ヨーロッパでは
                  <hostid>irc.eu.dal.net</hostid>
                  にあります.
                </para>
              </listitem>

              <listitem>
                <para>UNDERNET の Channel <emphasis remap=tt>#FreeBSD</emphasis>
                  はアメリカでは
                  <hostid>us.undernet.org</hostid>,
                  ヨーロッパでは <hostid>eu.undernet.org</hostid>
                  にあります.
                  ここはヘルプチャンネルです.
                  ドキュメントを読める準備をしてから利用してください. 
                </para>
              </listitem>

            </itemizedlist>
          </para>
  
          <para>
            それぞれのチャンネルは別個のもので,
            互いに接続されていません.
            チャットのスタイルも違っていますので,
            自分のチャットのスタイルにあったものを見つけるために一つ一つ試すのもいいでしょう.
            あらゆる種類の IRC トラフィックのため,
            失礼なことをいう若者たち(年輩の方は少数です)のために機嫌を損ねたり,
            手に負えなくなっても気にしてはいけません. 
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD の本</para>
        </question>

        <answer>
          <para>
            FreeBSD ドキュメンテーションプロジェクトがありますので, 
            <emphasis remap=tt>doc</emphasis>(<ulink URL="mailto:freebsd-doc@FreeBSD.org">&lt;freebsd-doc@FreeBSD.org&gt;</ulink>)メーリングリストにコンタクトしてみてください(さらに参加すればもっとよいでしょう).
            このリストは FreeBSD のドキュメントに関して議論するためのものです.
            FreeBSD に関する質問に対しては,
            <emphasis remap=tt>questions</emphasis>(<ulink URL="mailto:freebsd-questions@FreeBSD.org">&lt;freebsd-questions@FreeBSD.org&gt;</ulink>)
            というメーリングリストがあります.
          </para>
  
          <para>
            FreeBSD の
            <ulink URL="../handbook/index.html">FreeBSD
              ハンドブック</ulink>もあります.
            現在作業中ですので, 不完全な部分もあることに注意してください.
          </para>
  
          <para>
            FreeBSD のガイド本の決定版は,
            Greg Lehey が書いた
            &ldquo;The Complete FreeBSD&rdquo; です.
            これは Walnut Creek CDROM Books
            から出版されています.
            現在は第二版になっていて,
            インストール, システム管理ガイド, プログラム設定のヘルプ,
            マニュアルページまでの内容が 1,750
            ページにわたって書かれています.
            この本は(そして現在の FreeBSD リリースは)
            <ulink URL="http://www.cdrom.com">Walnut Creek</ulink>,
            <ulink URL="http://www.cheapbytes.com">CheapBytes</ulink>,
            または最寄りの書店で注文することができます.
            ISBN コードは 1-57176-227-2 です.
          </para>
  
          <para>
            また, FreeBSD 2.2.X は Berkeley 4.4BSD-Lite2
            ベースなので, 多くの 4.4BSD のマニュアルが
            FreeBSD 2.2.X にも応用できます.
            O'Reilly and Associates
            が以下のマニュアルを出版しています.
          </para>
  
          <para>
            <itemizedlist>

              <listitem>
                <para>4.4BSD System Manager's Manual <!-- <br> -->
                  By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                  1st Edition June 1994, 804 pages <!-- <br> -->
                  <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-080-5">ISBN</ulink>:
                  1-56592-080-5 <!-- <br> -->
                </para>
              </listitem>

              <listitem>
                <para>4.4BSD User's Reference Manual <!-- <br> -->
                  By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                  1st Edition June 1994, 905 pages <!-- <br> -->
                  <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-075-9">ISBN</ulink>:
                  1-56592-075-9 <!-- <br> -->
                </para>
              </listitem>

              <listitem>
                <para>4.4BSD User's Supplementary Documents <!-- <br> -->
                  By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                  1st Edition July 1994, 712 pages <!-- <br> -->
                  <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-076-7">ISBN</ulink>:
                  1-56592-076-7 <!-- <br> -->
                </para>
              </listitem>
              
              <listitem>
                <para>4.4BSD Programmer's Reference Manual <!-- <br> -->
                  By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                  1st Edition June 1994, 886 pages <!-- <br> -->
                  <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-078-3">ISBN</ulink>:
                  1-56592-078-3 <!-- <br> -->
                </para>
              </listitem>
              
              <listitem>
                <para>4.4BSD Programmer's Supplementary Documents <!-- <br> -->
                  By Computer Systems Research Group, UC Berkeley <!-- <br> -->
                  1st Edition July 1994, 596 pages <!-- <br> -->
                  <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-079-1">ISBN</ulink>:
                  1-56592-079-1 <!-- <br> --></para>
              </listitem>

            </itemizedlist>
          </para>
  
          <para>
            WWW 経由で以下の URL から,
            これらの詳細な説明を読むことができます.
          </para>
  
          <para>
            <ulink URL="http://gnn.com/gnn/bus/ora/category/bsd.html">4.4BSD
              books description</ulink>.  販売数が少ないためこれらの
            マニュアルは入手しにくいかもしれません.
          </para>
  
          <para>
            4.4BSD のカーネル構成についてより徹底的に知りたいのなら, 
            これなら間違いないでしょう.
          </para>
  
          <para>
            McKusick, Marshall Kirk, Keith Bostic, Michael J Karels,
            and John Quarterman.<!-- <br> -->
          </para>
  
          <para>
            <emphasis>The Design and Implementation of the 4.4BSD Operating
              System</emphasis>.  Reading, Mass. : Addison-Wesley, 1996.<!-- <br> -->
            <ulink URL="http://www.amazon.com/exec/obidos/ASIN/0-201-54979-4">ISBN</ulink>:
            0-201-54979-4<!-- <br> -->
          </para>
  
          <para>システム管理について参考になる本は次のものです.</para>
  
          <para>Evi Nemeth, Garth Snyder, Scott Seebass &amp; Trent R. Hein,<!-- <br> -->
            ``Unix System Administration Handbook'', Prentice-Hall, 1995<!-- <br> -->
            <ulink URL="http://www.amazon.com/exec/obidos/ASIN/0-13-151051-7">ISBN</ulink>:
            0-13-151051-7<!-- <br> --></para>
  
          <para>
            <emphasis remap=bf>注意</emphasis>
            初版のものではなく, 赤いカバーの第二版であるか
            確認してください.
          </para>
  
          <para>
            この本は TCP/IP だけでなく DNS, NFS, SLIP/PPP, sendmail, 
            INN/NNTP, 印刷などの基礎を扱っています.
            高価ですが(およそ US&#36;45-&#36;55),
            買う価値はあります.
            また, 色々なツールのソースコードが入った CD-ROM が付属しています.
            しかし, それらのほとんどは FreeBSD 2.2.6R CD-ROM
            に収録されています(さらに
            FreeBSD CD-ROM の収録物の方がより新しい場合があります).
          </para>
          <!-- hrs:2000/03/09 &#xx; should not be used -->

        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>障害報告(PR; Problem Report)
            データベースにアクセスする方法は?</para>
        </question>

        <answer>
          <para>
            ユーザからの変更要求がまとめられている
            Problem Report データベースは,
            障害報告の web ベースのインタフェースを通して, 
            <ulink URL="http://www.FreeBSD.org/ja/send-pr.html">提出</ulink>と<ulink URL="http://www.FreeBSD.org/cgi/query-pr-summary.cgi">問い合わせ</ulink>をおこなうことができます.
            また, <command>send-pr(1)</command> 
            コマンドを使用して,
            電子メール経由で障害報告や変更要求を提出することもできます.</para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FAQ の ASCII/PostScript 版はどこで手に入りますか?</para>
        </question>

        <answer>
          <para>
            最新の FAQ は FreeBSD Web サーバや,
            ほかのミラーサイトから Postscript 形式,
            プレインテキスト形式(7-bit ASCII と 8-bit
            Latin1)を入手することができます.

            <note>
              <!-- hrs:2000/03/09 This notice(the same in the preamble) added by hrs -->
              <title>HTML 版以外の日本語 FAQ について</title>
              <para>
                2000 年 3 月現在, HTML 版以外の日本語 FAQ は用意されていません.
              </para>
            </note>
          </para>
  
          <para>PostScript 形式(約 370KB):
            <itemizedlist>

              <listitem>
                <para><ulink URL="http://www.FreeBSD.org/FAQ/FAQ.ps">http://www.FreeBSD.org/FAQ/FAQ.ps</ulink></para>
              </listitem>

            </itemizedlist>
          </para>
  
          <para>ASCII テキスト形式(約 220KB):
            <itemizedlist>
              <listitem>
                <para><ulink URL="http://www.FreeBSD.org/FAQ/FAQ.ascii">http://www.FreeBSD.org/FAQ/FAQ.ascii</ulink></para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>ISO 8859-1 テキスト形式(約 220KB):
            <itemizedlist>
              <listitem>
                <para><ulink URL="http://www.FreeBSD.org/FAQ/FAQ.latin1">http://www.FreeBSD.org/FAQ/FAQ.latin1</ulink></para>
              </listitem>

            </itemizedlist>
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD ハンドブックの ASCII/PostScript 版はどこで手に入りますか?</para>
        </question>

        <answer>
          <para>
            最新のハンドブックは FreeBSD Web サーバやほかのミラーサイトから
            PostScript 形式やプレインテキスト形式(7-bit ASCII と
            8-bit Latin1)で入手することができます.

            <note>
              <!-- hrs:2000/03/09 This notice added by hrs -->
              <title>HTML 版以外の日本語ハンドブックについて</title>
              <para>
                2000 年 3 月現在, HTML 版以外の日本語ハンドブックは用意されていません.
              </para>
            </note>
          </para>
  
          <para>PostScript 形式(約 1.7MB):
            <itemizedlist>
              <listitem>
                <para><ulink URL="http://www.FreeBSD.org/handbook/handbook.ps">http://www.FreeBSD.org/handbook/handbook.ps</ulink></para>
              </listitem>
              
            </itemizedlist>
          </para>
  
          <para>ASCII テキスト形式(約 1080KB):
            <itemizedlist>
              <listitem>
                <para><ulink URL="http://www.FreeBSD.org/handbook/handbook.ascii">http://www.FreeBSD.org/handbook/handbook.ascii</ulink></para>
              </listitem>              
            </itemizedlist>
          </para>
  
          <para>ISO 8859-1 テキスト形式(約 1080KB):
            <itemizedlist>
              <listitem>
                <para><ulink URL="http://www.FreeBSD.org/handbook/handbook.latin1">http://www.FreeBSD.org/handbook/handbook.latin1</ulink></para>
              </listitem>
            </itemizedlist>
          </para>
          
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ASCII のハンドブックがプレインテキスト形式になってません!</para>
        </question>

        <answer>
          <para>
            正確には, FAQ やハンドブックの ASCII, Latin1 版は,
            厳密なプレインテキストではありません.
            それらはドットマトリクスプリンタへ直接出力するため,
            下線や重ね刷り文字が含まれています.
            もしそれらを人間が読める形になったものが欲しかったら,
            そのファイルを col に通してください.</para>
  
          <screen>&prompt.user; <userinput><command>col -b &lt; <replaceable>inputfile</replaceable> &gt; <replaceable>outputfile</replaceable></command></userinput></screen>          
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD の Web のミラーサイトになりたいです!</para>
        </question>

        <answer>
          <para>
            承知しました!
            Web ページをミラーするにはいくつかの手段があります.
          </para>
  
          <para>
            <itemizedlist>

              <listitem>
                <para>
                  CVSup を使います.
                  cvsup.FreeBSD.org から CVSup を使うことで,
                  整形されたファイルを取ってくることができます.
                  次の行をあなたの cvsup ファイルに加えてください.

                  <programlisting>
www release=current hostname=/home base=/usr/local/etc/cvsup 
prefix=/usr/local/www/data/www.FreeBSD.org delete old use-rel-suffix</programlisting>
                </para>
              </listitem>

              <listitem>
                <para>
                  rsync を使います. 詳細については
                  <ulink URL="http://www.FreeBSD.org/internal/mirror.html">ミラーサイトのページ</ulink>
                  を参照してください.
                </para>
              </listitem>

              <listitem>
                <para>
                  FTP を使ってミラーリングします.
                  あなたの好きな FTP ミラーリングツールを使って,
                  FTP サーバに置いてある web
                  サイトのコピーをダウンロードすることができます.
                  タウンロードは単純に ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-CURRENT/www
                  から始めてください.</para>
              </listitem>              
            </itemizedlist>
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>この文書を他の言語に翻訳したいのですが?</para>
        </question><answer>

          <para>
            報酬は支払えませんが,
            文書の翻訳を提出してくださる方には,
            フリーの CD, T シャツの手配や,
            ハンドブックにある貢献者一覧への登録を行ないたいと思います.
          </para>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>その他の情報</para>
        </question>

        <answer>
          <para>
            以下のニュースグループには FreeBSD
            ユーザに直接関係のある議論が行われてます.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para><ulink URL="news:comp.unix.bsd.freebsd.announce">comp.unix.bsd.freebsd.announce</ulink> (moderated)</para>
              </listitem>

              <listitem>
                <para><ulink URL="news:comp.unix.bsd.freebsd.misc">comp.unix.bsd.freebsd.misc</ulink></para>
              </listitem>

              <listitem>
                <para><ulink URL="news:comp.unix.bsd.misc">comp.unix.bsd.misc</ulink></para>
              </listitem>

            </itemizedlist>
          </para>
  
          <para>Web 上のリソース:</para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para><ulink URL="http://www.FreeBSD.org/">FreeBSD のホームページ</ulink></para>
              </listitem>

              <listitem>
                <para><anchor id="pao">
                    ラップトップ PC を持っている方は,
                    迷うことなく日本の<ulink URL="http://www.jp.FreeBSD.org/PAO/">細川 達己氏の
                      Mobile Computing のページ</ulink> を見ましょう.
                </para>
              </listitem>

              <listitem>
                <para><anchor id="smp">
                    SMP (Symmetric MultiProcessing) に関する情報は, 
                    <ulink URL="http://people.FreeBSD.org/~fsmp/SMP/SMP.html">SMP
                      サポートページ</ulink>をご覧ください.
                </para>
              </listitem>

              <listitem>
                <para><anchor id="multimedia">
                    FreeBSD のマルチメディアアプリケーションに関する情報は,
                    <ulink URL="http://people.FreeBSD.org/~faulkner/multimedia/mm.html">マルチメディア</ulink>のページをご覧ください.
                    特に
                    <ulink URL="http://people.FreeBSD.org/~ahasty/Bt848.html">Bt848</ulink>
                    ビデオキャプチャチップに興味のある方は, 
                    リンクをたどってみてください.
                </para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>FreeBSD ハンドブックには,
            実に完成された<ulink URL="../handbook/bibliography.html">参考図書</ulink>の一覧があり,
            買うべき本をさがしている方は読む価値があります.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </preface>

  <chapter id="install">
    <title>インストール</title>

    <para>
      <emphasis>訳:
        岩崎 満 <email>iwasaki@jp.FreeBSD.org</email>,
        むらたしゅういちろう <email>mrt@mickey.ai.kyutech.ac.jp</email>,
        1997 年 11 月 8 日.</emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>FreeBSD を入手するには, どのファイルをダウンロードすれば良いのでしょうか?</para>
        </question>

        <answer>
          <para>
            FreeBSD 3.1-RELEASE 以前では,
            インストールの際に必要なのは
            <filename>floppies/boot.flp</filename> と名前のついた
            一つのフロッピーディスクイメージだけでした.
            しかし FreeBSD 3.1-RELEASE 以降,
            幅広い種類のハードウェアサポートが基本システムに追加され,
            そのサポートが必要とする容量を補うため,
            3.X と 4.X の系列では新たに,
            <filename>floppies/kernel.flp</filename>
            および
            <filename>floppies/mfsroot.flp</filename>
            という, 二つのフロッピーディスクイメージを使うようになりました.
            これらのイメージをフロッピーディスクに書き込むには,
            <command>fdimage</command> や
            &man.dd.1; といったツールが必要となります.
          </para>
          
          <para>
            (DOS ファイルシステムからのインストールなどで)
            あなた自身が手動で配布ファイルをダウンロードする場合には,
            以下の配布ファイルをダウンロードすることをおすすめします.
          </para>

          <para>
            <itemizedlist>
              <listitem>
                <para><filename>bin/</filename></para>
              </listitem>

              <listitem>
                <para><filename>manpages/</filename></para>
              </listitem>

              <listitem>
                <para><filename>compat*/</filename></para>
              </listitem>

              <listitem>
                <para><filename>doc/</filename></para>
              </listitem>

              <listitem>
                <para><filename>src/ssys.*</filename></para>
              </listitem>

            </itemizedlist>
          </para>
  
          <para>
            この手順の完全な説明と, 一般的なインストール時の問題については 
            <ulink URL="../handbook/install.html">FreeBSD
              ハンドブックのインストールの節</ulink>
            を参照してください.</para>
        </answer>

      </qandaentry>

      <qandaentry>
        <question>
          <para>ブートフロッピーイメージが一枚のフロッピーディスクに納まらないみたい!</para>
        </question>

        <answer>

          <para>
            3.5 インチ(1.44MB)のフロッピーディスクには,
            1474560 バイトのデータを格納できます.
            ブートイメージはちょうど 1474560 バイトの大きさです.
          </para>
  
          <para>
            ブートフロッピーディスクを準備する際のよくある間違いには,
            以下のものがあります.

            <itemizedlist>
              <listitem>
                <para>
                  <acronym>FTP</acronym>
                  によってフロッピーイメージをダウンロードする際に, 
                  <emphasis remap=tt>バイナリ(binary)</emphasis>モードにしていなかった.
                </para>

                <para>
                  FTP クライアントの中には,
                  転送モードのデフォルトを<emphasis remap=tt>アスキー(ascii)</emphasis>モードにして,
                  クライアント側システムの慣習にあうよう,
                  すべての行末の文字を変更するものがあります.
                  この場合は常に, ブートイメージが壊れたものになります.
                  ダウンロードしたブートイメージのサイズをチェックしてください.
                  サーバ上のものと<emphasis>正確に</emphasis>一致しなければ,
                  ダウンロードの処理を疑いましょう. 
                </para>

                <para>
                  これを回避するには,
                  サーバに接続してイメージのダウンロードを開始する前に
                  FTP のコマンドプロンプトで
                  <command>binary</command> とタイプします.
                </para>
              </listitem>

              <listitem>
                <para>ブートイメージを
                  DOS の <command>copy</command>
                  コマンド(または GUI の同等のツール)でフロッピーディスクへ転送した. 
                </para>

                <para>
                  <command>copy</command>
                  のようなプログラムは,
                  直接起動するように作成されたブートイメージをうまく処理できません. 
                  イメージにはフロッピーディスクの完全な中身がトラック単位で格納されており,
                  フロッピーディスク上に通常のファイルとして
                  格納されるように想定されているわけではありません.
                  <ulink URL="../handbook/install.html">FreeBSD
                    のインストール</ulink>に記述されているように,
                  低レベルのツール(たとえば
                  <command>fdimage</command> や 
                  <command>rawrite</command>)
                  を使用して&ldquo;そのままの(raw)&rdquo;の状態でフロッピーディスクに
                  転送する必要があります.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD のインストールについての説明書はどこにありますか?</para>
        </question>

        <answer>
          <para>
            インストールの説明書は<ulink URL="../handbook/install.html">FreeBSD
              ハンドブックのインストールの章</ulink>にあります.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD を動作させるには何が必要ですか?</para>
        </question>

        <answer>
          <para>
            386 以上の PC, 5MB 以上の RAM,
            そして最低 60MB のハードディスク容量が必要となります.
            ローエンドの MDA カードでも動作しますが,
            X11R6 を使うには VGA かそれ以上のビデオカードが必要となります.
          </para>
  
          <para>
            <xref linkend="hardware" remap="ハードウェアコンパチビリティ"> 
              もご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>4 MB しかメモリがないのですが, インストールできますか?</para>
        </question>

        <answer>

          <para>
            4MB のシステムにインストールできた最後の FreeBSD は 
            FreeBSD 2.1.7 でした. 2.2 を含むより新しいバージョンの 
            FreeBSD は新規のインストールに最低 5MB は必要になります.
          </para>
  
          <para>
            ただし, インストールプログラムが 4MB では動作しないだけで,
            3.0 を含む FreeBSD のすべてのバージョンは 4MB の RAM で動作可能です. 
            インストールする時だけさらに 4MB 追加しておき,
            システムがセットアップされて動作するようになった後,
            また 4MBを取り出して元に戻すこともできます.
            あるいは 4MB より多くメモリを搭載したシステムにディスクを持っていき,
            そのマシンでインストールした後にディスクを戻すこともできます.
          </para>
  
          <para>
            また, FreeBSD 2.1.7 であっても, 4MB
            ではインストールできない場合があります.
            正確には, 640KB のベースメモリ + 3MB の拡張メモリでは,
            インストールはできません. もしマシンのマザーボードが 
            640KB から 1MB
            の領域で「失われた」メモリを再マップできる場合は,
            FreeBSD 2.1.7 をインストールできるかもしれません.
          </para>
  
          <para>
            BIOS のセットアップ画面で, &ldquo;remap&rdquo;
            のオプションを探して有効(enable)にしてみてください.
            また, ROM shadowing
            を無効(disable)にする必要もあります.
          </para>
  
          <para>
            簡単なやり方としては, インストールする時だけあと
            4MB 追加しておく方法があります.
            必要なオプションだけを選択してカスタムカーネルを構築し,
            また 4MB を取り出してもとに戻せばいいのです.
          </para>
  
          <para>
            また, 2.0.5 をインストールして,
            それから 2.1.7 のインストーラの
            &ldquo;upgrade&rdquo;
            オプションでシステムを 2.1.7 へアップグレード
            するというやり方もあります.
          </para>
  
          <para>
            インストールしたあとでカスタムカーネルの構築をした場合には,
            4MB でも動作します.
            2MBでブートに成功した人もいます(でもそのシステムは,
            ほとんど使いものになりませんでした :-)).
          </para>          
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>自分用のインストールフロッピーを作るには?</para>
        </question>

        <answer>
          <para>
            現在はカスタムインストールフロッピーディスク「だけ」を作る方法はありません. 
            カスタムインストールフロッピーディスクイメージを含む,
            release 環境全体を新たに作る必要があります.
            <filename>/usr/src/release/floppies/Makefile</filename>
            にあるコードでフロッピーディスクイメージ「だけ」を作れるはずですが, 
            まだ完全なものにはなっていません.
          </para>
  
          <para>
            カスタムの release 環境をつくるには,
            <link linkend="custrel">ここの指示</link>にしたがってください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>自分の PC に複数のオペレーティングシステムを入れるには?</para>
        </question>

        <answer>
          <para>
            <ulink URL="../../articles/multi-os/">multi-OS
              のページ</ulink>をご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>同じマシンで Windows 95 と共存できますか?</para>
        </question>

        <answer>
          <para>
            まず Windows 95 をインストールしてから, そのあとで FreeBSD
            をインストールしてください. FreeBSD のブートマネージャが Win95 
            と FreeBSD のブート管理をしてくれるようになります. 
            Windows 95 を後にインストールした場合はひどいことに, 
            問い合わせることもなくブートマネージャを上書きしてしまいます. 
            そうなってしまった場合は次の節をご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Windows 95 がブートマネージャを潰しちゃった! どうやって戻すの?</para>
        </question>

        <answer>
          <para>
            ブートマネージャの再インストールの方法として,
            FreeBSD では以下に示す二通りの方法が用意されています.</para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>DOS を起動し, FreeBSD の配布物の中にある
                  <filename>tools/</filename> ディレクトリへ移動し,
                  <filename>bootinst.exe</filename> を探してください.
                  そして次のように実行します.
                </para>

                <screen><prompt>&gt;</prompt> <userinput><command>bootinst.exe boot.bin</command></userinput></screen>

                <para>
                  こうすることで,
                  ブートマネージャが再インストールされます.
                </para>
              </listitem>

              <listitem>
                <para>
                  FreeBSD のブートフロッピーディスクから起動し,
                  「カスタム」インストールメニューを選択し,
                  続いて「パーティション」を選択します.
                  ブートマネージャがインストールされていたドライブ(多分最初のもの)を選択し,
                  パーティションエディタにたどり着いたら,
                  (何も変更せず)そのまま (W)rite を指定します.
                  確認のメッセージが出ますので「はい(Y)」と答え,
                  ブートマネージャ選択の画面で確実に &ldquo;Boot Manager&rdquo;
                  を選択します.
                  これでブートマネージャがディスクに再び書き込まれます. 
                  インストールメニューから抜けて再起動すると,
                  ハードディスクは元通りになります.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>不良ブロックのあるディスクにインストールできますか?</para>
        </question>

        <answer>
          <!-- hrs:2000/03/09 &man.bad144.8 is needed -->
          <para>
            FreeBSD
            の不良ブロックの扱い(<ulink URL="http://www.FreeBSD.org/cgi/man.cgi?bad144">bad144</ulink>
            コマンド)は, (ひいき目に見ても)100% 完全ではなく,
            残念ながら多数の不良ブロックのある IDE や ESDI ドライブは FreeBSD 
            では使用できないと言わざるをえません!
            でも, 非常に多くの IDE ベースのシステムで動作しているようですので,
            簡単にあきらめてしまう前にとりあえず試してみましょう.
          </para>
  
          <para>
            不良ブロックのある SCSI ドライブの場合は, 
            <link linkend="awre">この回答</link> を参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>インストーラからブートしたら変なことになりました!</para>
        </question>
        
        <answer>
          <para>
            インストーラからブートしようとしたときに, マシンが固まってし
            まうとか自然とリブートしてしまうといった現象であれば, 
            次の三つの項目を確認してください.
          </para>
  
          <para>
            <orderedlist>

              <listitem>
                <para>
                  新品の, フォーマットしたての,
                  エラーフリーのフロッピーディスクを使っていますか?
                  (三年間もベッドの下に放置されていた雑誌の付録みたいなやつではなくて, 
                  買ってきたばかりの新品を使って下さい)
                </para>
              </listitem>

              <listitem>
                <para>
                  フロッピーイメージをバイナリモードでダウンロードしましたか?
                  (困った顔をしないでください. 私たちの中で一番優秀な人でさえ,
                  少なくとも一回はバイナリファイルを
                  ASCII モードで思いがけずダウンロードしたことがあるのです!)
                </para>
              </listitem>

              <listitem>
                <para>Windows95 や Windows NT のような,
                  最近ご流行のオペレーティングシステムを使用している場合,
                  システムをシャットダウンして,
                  ありのままの本物の DOS を再起動しましたか?
                  これらの OS はディスク作成プログラムのような,
                  ハードウェアに直接書き込みを行なうプログラムに干渉する可能性があります.
                  GUI の中の DOS シェル内部で動作している場合でも, この問題は発生します.
                </para>
              </listitem>
            </orderedlist>
          </para>
  
          <para>
            また, Netscape
            でブートイメージをダウンロードする場合も問題があることが報告されていますので,
            できれば別の FTP クライアントを使うのがよいでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>あれれ? テープからインストールできません!</para>
        </question>

        <answer>
          <para>
            FreeBSD 2.1.7R をテープからインストールする場合,
            tar ブロックサイズを 10(5120
            バイト)にしたテープを作る必要があります. 
            デフォルト の tar ブロックサイズは 20(10240 バイト)で, 
            このデフォルトサイズで作られたテープでは FreeBSD 2.1.7R
            をインストールすることはできません.
            もしこうしたテープを使うと,
            レコードサイズが大きすぎるというエラーが起きることになります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>PLIP 経由で二つ FreeBSD box を接続したいのですが</para>
        </question>

        <answer>
          <para>Laplink パラレルケーブルを用意して,
            両方の PC のカーネルに <devicename>lpt</devicename>
            ドライバが組み込まれていることを確認してください.
          </para>
  
          <screen>&prompt.user; <userinput><command>dmesg | grep lp</command></userinput>
lpt0 at 0x378-0x37f irq 7 on isa
lpt0: Interrupt-driven port
lp0: TCP/IP capable interface</screen>
  
          <para>
            パラレルインタフェースに Laplink
            パラレルケーブルを接続します.
          </para>
  
          <para>
            <username>root</username>
            になって, 両方で <devicename>lp0</devicename>
            のネットワークインタフェースパラメータを設定します. 
            例えば, ホスト <hostid>max</hostid> と <hostid>moritz</hostid> を接続したい場合,
          </para>
  
          <programlisting>                max &lt;-----&gt; moritz
IP Address      10.0.0.1        10.0.0.2</programlisting>
  
          <para>max 側で次のようにして,</para>

          <screen>&prompt.root; <userinput><command>ifconfig</command> lp0 10.0.0.1 10.0.0.2</userinput></screen>
  
          <para>moritz 側で同様に次のようにします.</para>

          <screen>&prompt.root; <userinput><command>ifconfig</command> lp0 10.0.0.2 10.0.0.1</userinput></screen>

          <!-- hrs:2000/03/09 needs &man.lp.4; and &man.lpt.4 -->
          <para>
            以上です!
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?lp">lp(4)</ulink> と
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?lpt">lpt(4)</ulink>
            のマニュアルページも参照してください.
          </para>
  
          <para>
            また,
            <filename>/etc/hosts</filename> にホストの追加もしましょう.
          </para>
  
          <programlisting>127.0.0.1               localhost.my.domain localhost 
10.0.0.1                max.my.domain max
10.0.0.2                moritz.my.domain moritz</programlisting>
  
          <para>
            動作確認は次のようにします.
          </para>
  
          <para><hostid>max</hostid> 側:</para>
  
          <screen>&prompt.user; <userinput><command>ifconfig lp0</command></userinput> 
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000</screen>
  
          <screen>&prompt.user; <userinput><command>netstat -r</command></userinput>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use     Netif Expire
moritz              max              UH          4   127592       lp0</screen>

          <screen>&prompt.user; <userinput><command>ping</command> -c 4 moritz</userinput>
PING moritz (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- moritz ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ラップトップ PC に PLIP 経由でインストールできますか?</para>
        </question>

        <answer>
          <para>
            次のようにして, 二つのコンピュータを Laplink
            パラレルケーブルで接続してください.
          </para>
  
          <!-- hrs:2000/03/09 this should be table in DocBook -->
          <programlisting>+----------------------------------------+
|A-name A-End   B-End   Descr.  Port/Bit |
+----------------------------------------+
|DATA0  2       15      Data    0/0x01   |
|-ERROR 15      2               1/0x08   |
+----------------------------------------+
|DATA1  3       13      Data    0/0x02   |
|+SLCT  13      3               1/0x10   |
+----------------------------------------+
|DATA2  4       12      Data    0/0x04   |
|+PE    12      4               1/0x20   |
+----------------------------------------+
|DATA3  5       10      Strobe  0/0x08   |
|-ACK   10      5               1/0x40   |
+----------------------------------------+
|DATA4  6       11      Data    0/0x10   |
|BUSY   11      6               1/0x80   |
+----------------------------------------+
|GND    18-25   18-25   GND -            |
+----------------------------------------+</programlisting>
  
          <para>
            また,
            <link linkend="pao">Mobile Computing
              についてのページ</link>もご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="geometry">
          <para>ハードディスクドライブには,
            どのジオメトリを使うべきでしょうか?</para>
        </question>

        <answer>
          <para>
            (ここでディスクの「ジオメトリ」とは, ディスクのシリンダ, ヘッダ,
            トラック当りのセクタの数を意味しています - 便宜上, 
            C/H/S とすることにします. これはディスクのどの領域で読み書きを
            おこなうかを PC の BIOS が決定する手段となります.)
          </para>
  
          <para>
            これについてはある理由のために, 誤解されている点が多いようです. 
            まず最初に, FreeBSD はディスクブロックで動作しているため, 
            SCSI ドライブの<emphasis remap=tt>物理的</emphasis>なジオメトリという言い方は, 
            まったく見当違いのものです. 事実,
            セクタの密度はディスクによってまちまちであるため,
            物理的なジオメトリというものは存在しません.
            製造者が「本当の」物理的なジオメトリと公表しているものは通常,
            彼らが検査して得た最小の使用不可容量の結果のジオメトリのことです.
            IDE の場合, FreeBSD は C/H/S で動作しますが,
            最近のドライブはすべて, これを内部で参照するブロックに変換しています.
          </para>
  
          <para>
            問題はとなるのは<emphasis remap=tt>論理的な</emphasis>ジオメトリです.
            これは BIOS がそのディスクのジオメトリについて調べた際に取得されるものであり, 
            その後のディスクへのアクセスに使用します.
            FreeBSD は起動時に BIOS を使用するため,
            これを正しく取得することは非常に重要なことなのです.
            実際に, ディスク上に複数のオペレーティングシステムがある場合は,
            ジオメトリはどこからでも同じように解釈される必要があります.
            そうしないと, 起動時に深刻な問題が発生します.
          </para>
  
          <para>
            SCSI ディスクでは,
            使用するジオメトリはコントローラの拡張 BIOS
            トランスレーション(&ldquo;&gt;1GB の 
            DOS ディスクドライブのサポート&rdquo;
            とも呼ばれます)が有効になっているかどうかによります.
            無効になっている場合, N シリンダ, 64 ヘッド,
            32 セクタ/トラックを使用しますが,
            ここで `N' は MB 単位のディスク容量です. 
            例えば, 2GB ディスクは見かけ上 2048 シリンダ, 64 ヘッド, 
            32 セクタ/トラックとなります.
          </para>
  
          <para>
            それが「有効」になっており(MS-DOS
            ではこの方法で, ある制限を回避する場合もあります),
            ディスク容量が 1GB を越える場合は, M シリンダ,
            63 セクタ/トラック (64 「ではなく」),
            255 ヘッドを使用します.
            `M' は MB 単位のディスク容量を 7.844238(!) 
            で割った値となります.
            ということで, 2GB ディスクの例では, 
            261 シリンダ, 63 セクタ/トラック, 255 ヘッドとなります. 
            (訳注: 以上は Adaptec 社と NCR 社製の SCSI アダプタの場合です. 
            SCSI アダプタによって変換の数値が変わってくるのでマニュアルを
            参照してください.)
          </para>
  
          <para>
            これについてよく分からない場合や
            FreeBSD がインストール中に正しくジオメトリを取得できない場合,
            これを回避するもっとも簡単な方法は,
            ディスクに小さな DOS パーティションを作ることです. 
            そうすると正しいジオメトリが取得されるはずです(そして, 
            残しておきたくないとか,
            ネットワークカードのプログラミング用に使いたい場合などには,
            いつでもパーティションエディタで DOS
            パーティションを削除することができます).
          </para>
  
          <para>
            もう一つの方法として, FreeBSD
            と一緒にに配布されているフリーで使えるユーティリティに
            &ldquo;<emphasis remap=tt>pfdisk</emphasis>&rdquo;(FreeBSD
            CD-ROM の <filename>tools</filename>
            ディレクトリや, 他のさまざまな FTP
            サイトにあります)と呼ばれるものがあり,
            ディスク上の他のオペレーティングシステムが使用している
            ジオメトリを調べるのに役立ちます.
            このジオメトリ情報は,
            パーティションエディタに入力することができます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ディスクの分割の仕方で何か制限はありますか?</para>
        </question>

        <answer>
          <para>
            はい.
            BIOS がカーネルをブートできるようにルートパーティションが
            1024 シリンダ以内にあることを確認する必要があります(これは
            FreeBSD ではなく PC の BIOS の制限です).
          </para>
  
          <para>
            SCSI ドライブでは, 通常はルートパーティションが最初の 1024MB 
            に収まっていることが前提となります(または拡張 BIOS
            トランスレーションが有効になっている場合は最初の 4096MB -
            他の質問をご覧ください). IDE でそれに相当する値は 504MB
            となります(訳注: E-IDE
            対応の BIOS 搭載マシンの場合は
            IDE の 504MB という制限はありません).
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>大容量ディスクを持っていますが, ディスクマネージャは使えますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD は Ontrack Disk Manager を認識し, これを考慮にいれます. 
            他のディスクマネージャはサポートしません.
          </para>
  
          <para>
            ディスク全体を FreeBSD で使いたい場合,
            ディスクマネージャは必要ありません.
            BIOS が扱える容量(通常 504MB)いっぱいでディスクの設定をおこなうと,
            FreeBSD は実際の容量を算出するはずです.
            MFM コントローラ付きの古いディスクを使っている場合は, 
            FreeBSD に使用するシリンダ数を詳細に指定する必要があります.
          </para>
  
          <para>
            FreeBSD
            と他のオペレーティングシステムが入っているディスクを使用したい場合は,
            ディスクマネージャなしでもできるでしょう.
            FreeBSD
            のブートパーティションと他のオペレーティングシステム用のスライスが,
            最初の 1024 シリンダ内に収まっている事を確認するだけです.
            気になる方は, ブートパーティションを 20
            メガバイトぐらいにして大きめにするととよいでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="missing-os">
          <para>FreeBSD のブート時に
            &ldquo;<computeroutput>Missing Operationg System</computeroutput>&rdquo;
            と表示されます</para>
        </question>

        <answer>
          <para>
            これは FreeBSD や DOS,
            そのほかの OS がディスク領域<link linkend="geometry">ジオメトリ</link>
            のとらえ方で衝突しあっていることから起こる典型的な例です.
            こうなったら FreeBSD
            をインストールし直す以外にはありませんが, 
            他のところで説明した手順にしたがってやれば, 
            ほぼ間違いなくうまくいくはずです.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ブートマネージャの &ldquo;<literal>F?</literal>&rdquo; プロンプトが表示されません.</para>
        </question>

        <answer>
          <para>
            これはすでに前に質問されている問題のもう一つの症状です.
            BIOS のジオメトリと FreeBSD のジオメトリ設定が一致していないのです! 
            コントローラや BIOS がシリンダの変換(&ldquo;&gt;1GB ドライブの
            サポート&rdquo;とも呼ばれます)をサポートしていたら, 
            その設定を無効化して FreeBSD をインストールし直してみてください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="bigram">
          <para>16MB を越えるメモリを搭載していますが, 何か問題が起こりますか?</para>
        </question>

        <answer>
          <para>
            性能問題以外は問題ありません.
            FreeBSD 2.X はバウンスバッファ(bounce-buffer)をサポートしており, 
            バスマスタリングコントローラは 16MB
            より上位のメモリ領域にアクセスできます.
            (これは ISA デバイスを使用している場合のみ必要となるものですが,
            一部の EISA と VLB デバイスでも必要な場合があります.)
          </para>
  
          <para>
            また, もっと多くのメモリを搭載している場合,
            Compaq や利用可能なメモリサイズを正しく報告しない他の
            BIOS を使用している場合は, 
            <link linkend="reallybigram">&gt;64M
              マシン</link>の節をご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ソースを全部インストールする必要はありますか?</para>
        </question>

        <answer>
          <para>
            一般的には「いいえ」です.
            しかし最低でも, &ldquo;<emphasis remap=tt>base</emphasis>&rdquo; 
            ソースキット(これにはこの FAQ
            で述べられているファイルのいくつかが含まれています)と,
            &ldquo;<emphasis remap=tt>sys</emphasis>&rdquo;(kernel)ソースキット(これにはカーネルのソースが含まれています)をインストールする事を強くおすすめします.
            通常, 何かの実行にソースが必要になる事はありません.
            しかし, カーネルをコンフィグレーションするためのプログラム &man.config.8;
            を実行する時は例外です.
            カーネルのソースをインストールしなくてもよい例として,
            どこか別の場所からカーネルのソースを読み込み専用で NFS
            マウントすることができます. また,
            そこから新しいバイナリを作成できるようにもなっています.
            (カーネルソースの制限があるので, 直接 <filename>/usr/src</filename>
            をマウントする事はおすすめできません.
            それよりもどこか別のディレクトリにマウントして,
            ソースツリーの複製ができるように適切にシンボリックリンクを張ってください.)
          </para>
  
          <para>
            ソースをネットワーク上に持ち,
            そこからシステムをビルドするようにしておけば,
            FreeBSD の将来のリリースへのアップグレードがずっと簡単になります.
          </para>
  
          <para>
            実際にソースのサブセットを選択するには,
            システムインストールツールの「配布ファイル」メニューにある,
            「カスタム」メニューを使用します.
            また, <filename>src/install.sh</filename>
            スクリプトでも与える引数によって,
            ソース配布ファイルの一部分をインストールできます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>カーネルは必ず作り直さなくちゃならないんですか?</para>
        </question>

        <answer>
          <para>
            カーネルを新しく作り直すのは元々,
            FreeBSD のインストール時に必須の作業でした.
            でも最近のリリースでは,
            とてもユーザフレンドリなカーネル設定ツールの恩恵を受けています. 
            FreeBSD のブートプロンプト(boot:)で &ldquo;-c&rdquo;
            と打てばビジュアルな設定画面になり,
            ほとんどの一般的な ISA
            カードについてのカーネルの設定をすることができるのです.
          </para>

          <para>
            今でも,
            必要なデバイスドライバだけを組み込んだカーネルを作ることはよい事とされています.
            ほんのちょっとだけメモリを節約できますからね.
            でもほとんどのシステムでは,
            もはやどうしてもやらなくちゃならないことではないのです.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>アメリカ合衆国国外に住んでいますが,
            DES 暗号化ソフトウェアは使えますか?</para>
        </question>

        <answer>
          <para>
            DES スタイルの暗号化コードの使用が絶対避けられないものでない場合は,
            <emphasis remap=bf>より安全</emphasis>で輸出規制のない
            FreeBSD のデフォルトの暗号化コードが使用できます.
            FreeBSD 2.0 ではパスワードのデフォルトのスクランブラは
            <emphasis remap=bf>MD5</emphasis> ベースになっています. 
            これは, パスワード破りのプログラムに対して DES よりも CPU 
            パワーを要求し, またより長いパスワードを使うことできます. 
            いまどき <emphasis remap=bf>MD5</emphasis> ベースの
            crypt を使用しない理由があるとすれば, 
            それは FreeBSD とそれ以外のシステムで同じ password エントリを
            使用しているぐらいのもんでしょう.
          </para>
  
          <para>
            DES 暗号化アルゴリズムは合法的に合衆国国外に持ち出す事ができないため,
            合衆国国外のユーザは合衆国の FTP
            サイトから該当するソフトウェア(<emphasis remap=tt>secrdist</emphasis>
            の部分)を持ち出してはいけません.
          </para>
  
          <para>
            しかし, これに代わる libcrypt が,
            オーストラリアの David Burren
            氏によって書かれたソースをベースに作られています. 
            これは合衆国国外のいくつかの FTP ミラーサイトで公開されています. 
            この制限の課せられていない libcrypt のソースと,
            それを使ったプログラムのバイナリは, 以下の FTP
            サイトから入手することができます.</para>
  
          <para>
            <!-- hrs:2000/03/09
                 why filename? this QnA-entry is quite broken! -->

            <variablelist>
              <varlistentry>
                <term>南アフリカ</term>
                <listitem>
                  <para>
                    <filename>ftp://ftp.internat.FreeBSD.org/pub/FreeBSD</filename><!-- <br> -->
                    <filename>ftp://storm.sea.uct.ac.za/pub/FreeBSD</filename>
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>ブラジル</term>

                <listitem>
                  <para><filename>ftp://ftp.iqm.unicamp.br/pub/FreeBSD</filename></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>フィンランド</term>
                <listitem>
                  <para><filename>ftp://nic.funet.fi/pub/unix/FreeBSD/eurocrypt</filename></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>日本</term>
                <listitem>
                  <para><filename>ftp://daemon.jp.FreeBSD.org/pub/FreeBSD-internat</filename></para>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
  
          <para>
            この合衆国国外向けの <emphasis remap=tt>securdist</emphasis> は,
            合衆国国内向けの 
            <emphasis remap=tt>securedist</emphasis>
            をちょうど置き換えるように使う事ができます. 
            この <emphasis remap=tt>securedist</emphasis>
            は合衆国国内版のパッケージと同じ方法でインストールできます
            (詳しい方法はインストールノートをご覧ください).
            DES 暗号化コードをインストールしたい場合は, 
            他のアプリケーションをインストールする前に, なるべく早い段階で
            インストールしておく必要があります.
          </para>
  
          <para>
            合衆国国外のユーザは,
            どうか暗号化ソフトウェアを合衆国内からダウンロードしないでください.
            そうされてしまうと, ダウンロードされたサイトの管理者は,
            法律的にとても困難な立場に立たされる事になります.
          </para>
  
          <para>
            合衆国以外向けの Kerberos も開発されつつあります.
            現在のバージョンは anonymous FTP で
            <filename>braae.ru.ac.za</filename>
            から入手できます.
          </para>
  
          <para>
            また, 合衆国国外向けの暗号化ソフトウェアに関する議論のための
            <link linkend="mailing">メーリングリスト</link>もあります. 
            より詳しい情報については, メールの本文に
            &ldquo;<emphasis remap=tt>help</emphasis>&rdquo;
            とだけ書いて 
            <email>majordomo@braae.ru.ac.za</email>
            まで送ってください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ブートフロッピーで起動すると,
            &ldquo;<computeroutput>Probing Devices...</computeroutput>&rdquo;
            の画面でハングアップします.</para>
        </question>

        <answer>
          <para>
            IDE Zip か Jaz ドライブが接続されていたら,
            それを取り外してもう一度試してみましょう.
            ブートフロッピーはこの種のドライブを誤認してしまうのです. 
            システムがインストールされた後は, そのドライブを再度接続することができます. 
            うまくいけばこの問題は将来のリリースで解決されるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>インストール終了後にシステムをリブートすると,
            &ldquo;<computeroutput>panic: cant mount root</computeroutput>&rdquo;
            のエラーとなります.</para>
        </question>

        <answer>
          <para>
            このエラーはディスクデバイスについて,
            ブートブロックとカーネルの認識が混乱しているために起こります.
            このエラーは通常,
            2 台の IDE ディスクがそれぞれ別の IDE
            コントローラのマスターに一つずつ接続されているシステムにおいて,
            FreeBSD がセカンダリ IDE
            コントローラに接続されたディスクにインストールされている場合に発生します. 
            ブートブロックは FreeBSD が
            <devicename>wd1</devicename>(2 台目の BIOS
            ディスク)にインストール
            されていると認識するのに対し,
            カーネルはセカンダリ IDE の 1 台目のハードディスクである
            <devicename>wd2</devicename>
            にインストールされていると認識するのです.
            デバイス検出後で,
            カーネルはブートブロックがブートディスクだと認識したディスクである
            <devicename>wd1</devicename> をマウントしようとします.
            しかし, 実際にはブートディスクは
            <devicename>wd2</devicename> なので失敗してしまうのです.
          </para>
  
          <para>
            この問題を解決するには, 以下のどれか一つを行ってください.
          </para>
  
          <para>
            <orderedlist>
              <listitem>
                <para>Boot: プロンプトで,
                  <command>1:wd(2,a)kernel</command>
                  と入力してエンターキーを押します.
                  システムが起動したら,

                  <screen>&prompt.root <userinput><command>echo</command> "1:wd(2,a)kernel" &gt; /boot.config</userinput></screen>

                  というコマンドを実行してこれをデフォルトのブート文字列とします.
                </para>
              </listitem>

              <listitem>
                <para>FreeBSD のディスクをプライマリ IDE コントローラに接続して,
                  ハードディスクが連続したドライブ番号で認識されるようにします.
                </para>
              </listitem>

              <listitem>
                <para>
                  カーネルのコンフィグレーションファイルで wd
                  の行を以下のように変更し,
                  <ulink URL="../handbook/kernelconfig.html">カーネルの再構築</ulink>を行って,
                  新しいカーネルをインストールします.
                </para>

                <programlisting>controller      wdc0    at isa? port "IO_WD1" bio irq 14 vector wdintr
disk            wd0     at wdc0 drive 0
# disk            wd1     at wdc0 drive 1 # この行をコメントアウト

controller      wdc1    at isa? port "IO_WD2" bio irq 15 vector wdintr
disk            wd1     at wdc1 drive 0 # wd2 から wd1 へ変更
disk            wd2     at wdc1 drive 1 # wd3 から wd2 へ変更</programlisting>

                <para>
                  ディスクの接続を変更して元の設定に戻したい場合は, ディスクを
                  お望みの設定の通りの接続に戻してからリブートします.
                  システムは正常に起動するはずです.
                </para>
              </listitem>
            </orderedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>メモリの大きさの制限は?</para>
        </question>

        <answer>
          <para>
            認識できるメモリの上限は, 4GB です.
            この構成は試験済みで,
            詳細は <ulink URL="ftp://ftp.cdrom.com/archive-info/configuration">wcarchive's
              configuration</ulink> をご覧下さい.
            このようにたくさんのメモリをマシンに導入しようという場合には,
            注意が必要です. ECC 機能をサポートし, なおかつ
            容量性負荷(訳注: 多くのメモリ素子は容量性負荷として働きますが,
            メモリバス上に容量性負荷が増えると信号の伝達が遅れ, 誤動作の原因となります)を
            低減させるため, 18 チップ構成のメモリモジュールより
            9 チップ構成のメモリモジュールを選択することが, おそらく望ましいでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ffs ファイルシステムの大きさの制限は?</para>
        </question>

        <answer>
          <para>
            ffs ファイルシステムの場合,
            論理的な最大の上限は 8 TB(2G ブロック),
            デフォルトのブロックサイズを 8K とすると 16 TBとなります.
            実際問題として, 1 TB のソフトウェアの限界がありますが,
            修正すれば 4 TB のファイルシステムが可能です(実際に存在します).
          </para>
  
          <para>
            一つの ffs のファイルの最大のサイズは, ブロックサイズが 4K の場合で
            約 1G ブロック(4 TB)です.
          </para>
  
          <!-- hrs:2000/03/09 this should be an table in DocBook -->
          <programlisting>                           maxfilesize
                ----------------------------------
                2.2.7    3.0
fs block size   -STABLE  -CURRENT  works  should-work
-------------   -------  --------  -----  -----------
4K              4T-1       4T-1    4T-1   4+T
8K              32+G       8T-1    32+G   16T-1
16K             128+G      16T-1   128+G  32T-1
32K             512+G      32T-1   512+G  64T-1
64K             2048+G     64T-1   2048+G 128T-1</programlisting>
  
          <para>
            fs ブロックサイズが 4K の場合は三重間接ブロックが使用され, 
            いづれの場合でも三重間接ブロックを使用して表現できる最大の 
            fs ブロック番号 (およそ 1K^3 + 1K^2 + 1K) に制限されるはずなのですが,
            実際は fs ブロック番号の (間違った) 上限 1G-1 で制限されます. 
            fs ブロック番号の制限は 2G-1 となるはずです. 2G-1 付近に
            fs ブロック番号のバグが多少ありますが, fs ブロックサイズが
            4K の場合は, ここまでのブロック番号には到達しません.
          </para>
  
          <para>
            ブロックサイズが 8K 以上の場合, いずれの場合も
            fs ブロック番号の上限 2G-1 で制限されるはずですが,
            実際は fs ブロック番号の上限
            1G-1 で制限されます.
            例外的に -STABLE では三重間接ブロックまでは到達しないため,
            制限は二重間接ブロックで表現できる最大の 
            fs ブロック番号 (およそ (blocksize/4)^2 + (blocksize/4)) となります.
            -CURRENT ではこの制限を超えると問題を引き起こすかもしれません. 
            正しい制限値である 2G-1 ブロックを使用すると明らかに問題が出ます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>フロッピーに 1 TB のファイルを格納するには?</para>
          <para><emphasis>寄稿: Bruce Evans, 1998 年 9 月</emphasis></para>
        </question>

        <answer>
          <para>
            わたしのところでは,
            フロッピーにいくつかの実際のファイルを保存しています :-).
            最大のファイルサイズは最大のディスクサイズとはあまり関係はありません.
            最大のディスクサイズは 1 TB です.
            ファイルサイズがディスクサイズより大きくなりうるというのは仕様です.
          </para>
  
          <para>
            以下の例は, 32K のディスク容量(3
            つの間接ブロックと 1 つのデータブロック)を使って,
            小さなルートパーティションに
            8T-1 の大きさのファイルを作成します.
            ここでの dd コマンドは大きなファイルが扱えるものが必要です.
          </para>
  
          <screen><prompt>ttyv0:bde@alphplex:/tmp/q&gt;</prompt> <userinput><command>cat</command> foo</userinput>
df .
dd if=/dev/zero of=z bs=1 seek=`echo 2^43 - 2 | bc` count=1
ls -l z
du z
df .
<prompt>ttyv0:bde@alphplex:/tmp/q&gt;</prompt> <userinput><command>sh</command> foo</userinput>
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27702    31619    47%    /
1+0 records in
1+0 records out
1 bytes transferred in 0.000187 secs (5346 bytes/sec)
-rw-r--r--  1 bde  bin  8796093022207 Sep  7 16:04 z
32	z
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27734    31587    47%    /
<prompt>ttyv0:bde@alphplex:/tmp/q&gt;</prompt> <userinput><command>exit</command></userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>新しいカーネルをコンパイルしたのですが, ブート時に
            &ldquo;<computeroutput>archsw.readin.failed</computeroutput>&rdquo; というエラーメッセージが
            表示されるようになってしまいました.</para>
        </question>

        <answer>
          <para>
            起動させるには,
            ブートプロセスのセカンドステージにおいて起動したいカーネルを直接指定してください.
            それには, ローダが始動する前, | が表示されている時に何かキーを押します.
            これは特に,
            カーネルのソースをアップグレードして, 構築したカーネルを
            <emphasis>make world しないで</emphasis>
            インストールしてしまった場合に起こります,
            この場合の動作はサポートされていません.
            必ず make world を実行してください.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="hardware">
    <title>ハードウェアコンパチビリティ</title>

    <para>
      <emphasis>訳:
        にしか <email>nishika@cheerful.com</email>,
        1997 年 11 月 12 日.</emphasis>
    </para>
  

    <qandaset>
      <qandaentry>
        <question>
          <para>FreeBSD は,
            どんなハードディスクドライブをサポートしているのですか?</para>
        </question>

        <answer>
          <para>
            FreeBSD は, EIDE と SCSI
            ハードディスクドライブをサポートしています(互換コントローラも含みます.
            次の節参照).
            また独自の &ldquo;Western Digital&rdquo;
            インタフェースを使用しているすべてのドライブ(MFM,
            RLL, ESDI, もちろん IDE)もサポートしています.
            独自仕様のインタフェースを使用する 
            ESDI コントローラでは動作しないものがあり,
            WD1002/3/6/7 
            とその互換インタフェースと衝突します.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どの SCSI コントローラをサポートしているのですか?</para>
        </question>

        <answer>
          <para><ulink URL="../handbook/install.html#INSTALL-HW">FreeBSD
              ハンドブック</ulink>に記されている完全なリストを参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どんな CD-ROM ドライブをサポートしているのですか?</para>
        </question>

        <answer>
          <para>
            サポートされている SCSI コントローラに接続できる SCSI 
            ドライブは, すべてサポートされています.
          </para>
  
          <para>
            また, 以下の専用 CD-ROM
            インタフェースもサポートしています.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>ミツミ LU002(8bit), LU005(16bit) および FX001D(16bit 2倍速).</para>
              </listitem>

              <listitem>
                <para>ソニー CDU 31/33A<!-- <br> --></para>
              </listitem>

              <listitem>
                <para>Sound Blaster 非 SCSI タイプの CD-ROM<!-- <br> --></para>
              </listitem>

              <listitem>
                <para>松下/Panasonic CD-ROM<!-- <br> --></para>
              </listitem>

              <listitem>
                <para>ATAPI 互換の IDE CD-ROM<!-- <br> --></para>
              </listitem>              
            </itemizedlist>
          </para>
  
          <para>
            SCSI でないカードはすべて, SCSI ドライブよりも極めて動作速度が
            遅いことが知られており, ATAPI CD-ROM には動作しないものもあるようです.
          </para>
  
          <para>
            Walnut Creek の FreeBSD 2.2 CD-ROM からは CD からの直接ブートが
            サポートされています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ZIP ドライブをサポートしていますか?</para>
        </question>

        <answer>
          <para>
            もちろん,
            FreeBSD は SCSI ZIP ドライブ(外付け)をサポートしています. 
            ZIP ドライブは SCSI ID を 5 か 6 に設定した状態でなら使用できますが, 
            もし SCSI ホストアダプタの BIOS がサポートしてさえいれば
            ZIP ドライブからブートさせることもできます. 私はどのホストアダプタが
            SCSI ID を 0 や 1 以外に設定したデバイスからブートできるのか知りませんが...
            ドキュメントを参照してください(うまくいった場合は教えてください).</para>
  
          <para>
            ATAPI(IDE) ZIP ドライブは, FreeBSD 2.2.6
            以降のバージョンでサポートされています.
          </para>
  
          <para>
            バージョン 3.0 以降の FreeBSD では,
            パラレルポート接続の ZIP ドライブをサポートしています.
            最近のバージョンの FreeBSD をお使いでしたら,
            カーネルコンフィグレーションファイルに
            <devicename>scbus0</devicename>,
            <devicename>da0</devicename>,
            <devicename>ppbus0</devicename>,
            <devicename>vp0</devicename>
            の各ドライバが記述されていることを確認してください.
            (GENERIC カーネルには <devicename>vp0</devicename>
            を除くすべてのドライバが含まれています).
            これらすべてのドライバがあれば,
            パラレルポートのドライブは
            <filename>/dev/da0s4</filename>
            となります. 
            ディスクは

            <screen>&prompt.root; <userinput><command>mount</command> <filename>/dev/da0s4</filename> <filename>/mnt</filename></userinput></screen>
            または
            
                <screen>&prompt.root; <userinput><command>mount_msdos</command> <filename>/dev/da0s4</filename> <filename>/mnt</filename></userinput>(DOS ディスクの場合)</screen>

            でマウントできます.
          </para>
  
          <para>
            それから<link linkend="jaz">リムーバブルドライブに関する注意</link>および,
            <link linkend="disklabel">「フォーマット」に関する注意</link>についても
            確認しておいてください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>では, JAZ や EZ,
            それからその他のリムーバブルドライブはサポートしていますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD では, IDE バージョンの EZ
            ドライブを除くすべての SCSI デバイスは, 
            SCSI のディスクと同等に扱われます.
            また IDE EZ は IDE ドライブと同等となります.
          </para>
  
          <para><anchor id="jaz">
              システム稼働中のメディア交換について
              FreeBSD がどれほどうまく動くか定かではありません.
              もちろんメディアを入れ替える前にそのドライブのマウントを解除しなければいけないでしょうし, 
              FreeBSD がそれらを認識するには,
              ブート時に外部ユニットにも電源が投入されていることを確認しなければいけないでしょう.
          </para>
  
          <para><link linkend="disklabel">「フォーマット」に関する注意</link>も参照のこと.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どのマルチポートシリアルカードをサポートしていますか?</para>
        </question>

        <answer>
          <para>一覧は
            <ulink URL="../handbook/install-hw.html#INSTALL-MISC">その他のデバイス</ulink>の節にあります.
          </para>
  
          <para>
            無名のカードにもうまく動くものがあり, 
            特に AST 互換といわれているものに多く見られます.
          </para>
  
          <para>
            カード設定の詳細な情報は, &man.sio.4;
            のマニュアルページを参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="usbkbd">
          <para>USB キーボードを持っているのですが, FreeBSD で使えますか?</para>
        </question>
        
        <answer>
          <para>
            USB デバイスは FreeBSD 3.1 からサポートされましたが,
            実装は FreeBSD 3.2 であってもまだ完全ではないため,
            必ずしも安定して動作するとは限りません.
            もし, それでも USB キーボードを使ってみたいという人は,
            以下の手順を試してみて下さい.
          </para>
          
          <orderedlist>
            <listitem>
              <para>FreeBSD 3.2 か, それ以降を使います.</para>
            </listitem>
            
            <listitem>
              <para>
                カーネルコンフィグレーションファイルに以下の行を追加し,
                カーネルを再構築します.
              </para>
              
              <programlisting>
controller      uhci0
controller      ohci0
controller      usb0
controller      ukbd0
options         KBD_INSTALL_CDEV</programlisting>
            </listitem>

            <listitem>
              <para><filename>/dev</filename> ディレクトリに移動し,
                次のようにしてデバイスノードを作成します.</para>
              
              <screen>&prompt.root; <userinput><command>cd</command> /dev</userinput>
&prompt.root; <userinput><command>./MAKEDEV</command> kbd0 kbd1</userinput></screen>
            </listitem>

            <listitem>
              <para><filename>/etc/rc.conf</filename> を編集し,
                以下の行を追加します.</para>

              <programlisting>
usbd_enable="YES"
usbd_flags=""</programlisting>
            </listitem>
          </orderedlist>

          <para>
            システムを再起動させた後,
            AT, USB 両方のキーボードが接続されていれば,
            AT キーボードは <devicename>/dev/kbd0</devicename> に,
            USB キーボードは <devicename>/dev/kbd1</devicename>になります.
            一方, USB キーボードだけが接続されているなら,
            <devicename>/dev/ukbd0</devicename> となります.
          </para>
          
          <para>
            USB キーボードをコンソールで利用するには,
            それをコンソールドライバに対して明示的に指定する必要があります.
            システムの初期化の際に, 次に示すようなコマンドを実行して下さい.
          </para>
          
          <screen>&prompt.root; <userinput>kbdcontrol -k /dev/kbd1 &lt; /dev/ttyv0 &gt; /dev/null</userinput></screen>
          
          <para>
            ただし, USB キーボードしか接続されていない場合, それは
            <devicename>/dev/kbd0</devicename> としてアクセスされますので,
            コマンドは次のようにしなければなりません. ご注意下さい.
          </para>
          
          <screen>&prompt.root; <userinput>kbdcontrol -k /dev/kbd0 &lt; /dev/ttyv0 &gt; /dev/null</userinput></screen>
          
          <para>
            上のコマンドは, <filename>/etc/rc.i386</filename>
            に追加すると良いでしょう.
          </para>

          <para>
            この設定を一度行なっていれば,
            X 環境でも特に他の設定なしに USB キーボードが利用できます.
          </para>

          <para>
            USB キーボードの活線挿抜(ホットプラグ機能)は,
            まだおそらくきちんと動作しないと思われます.
            トラブルを避けるためにも, キーボードはシステムを起動させる前に接続しておき,
            シャットダウンするまではずさないようにした方が良いでしょう.
          </para>
          
          <para>
            詳細については, &man.ukbd.4; のマニュアルページを参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="busmouse">
          <para>珍しいバスマウスを持っているのですが, どのように設定すればいいのですか?</para>
        </question>

        <answer>
          <para>
            FreeBSD は Microsoft, Logitech,
            ATI 等のメーカーから出ているバスマウスと InPort
            バスマウスをサポートしています. FreeBSD 2.X の場合,
            バスマウスのデバイスドライバは GENERIC カーネルに標準で含まれますが,
            FreeBSD 3.X 以降では標準で含まれていません. もしバスマウスのデバイス
            ドライバを含むカーネルを自分で構築する場合には,
            カーネルコンフィグレーションファイルに以下の行が含まれていることを確認して下さい.</para>
  
          <para>それは FreeBSD 3.0 を含む, それ以前のリリースの場合は次のとおり,

            <programlisting>device mse0 at isa? port 0x23c tty irq5 vector mseintr</programlisting>

            FreeBSD 3.1 を含む, それ以降のリリースでは次のとおりです.

            <programlisting>device mse0 at isa? port 0x23c tty irq5</programlisting>
          </para>

          <para>
            通常バスマウスには専用のインタフェースカードが附属しています.
            インタフェースカードによってはポートアドレスや割り込み番号を上記の
            設定以外に変更できるかもしれません. 詳しくはバスマウスのマニュアルと
            &man.mse.4; のマニュアルページを参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ps2mouse">
          <para>PS/2 マウス(マウスポートマウス, キーボードマウス)を使うには,
            どのように設定すればいいのですか?</para>
        </question>

        <answer>
          <para>
            あなたが 2.2.5 以降のバージョン FreeBSD を使っているのなら,
            必要なドライバ <devicename>psm</devicename>
            はカーネルに含まれていて有効になっています.
            カーネルはブート時に PS/2 マウスを検出するでしょう.
          </para>

          <para>
            あなたの使っている FreeBSD
            が比較的新しいけれど前のバージョン(2.1.x 以降)のものなら,
            インストールの時に, 単にカーネルのコンフィグレーションのメニュー上で 
            PS/2 マウスを有効化するだけです, あるいは後で
            <prompt>boot:</prompt> プロンプト上で 
            <option>-c</option> を指定することでもメニューは現れます. 
            デフォルトでは無効に設定されていますので,
            明示的に有効化してあげないといけません.
          </para>
  
          <para>
            あなたの使っている FreeBSD が比較的古いものなら, 
            カーネルコンフィグレーションファイルに以下の行を加えて
            カーネルを再コンパイルする必要があります. 
          </para>
  
          <para>
            それは FreeBSD 3.0 を含む, それ以前のリリースでは次のとおり,

            <programlisting>device psm0 at isa? port "IO_KBD" conflicts tty irq 12 vector psmintr</programlisting>
            FreeBSD 3.1 を含む, それ以降のリリースでは次のとおり,
            
            <programlisting>device psm0 at isa? tty irq 12</programlisting>

            FreeBSD 4.0-CURRENT を含む, それ以降のリリースでは次のとおりです.

            <programlisting>device psm0 at atkbdc? irq 12</programlisting>
          </para>
  
          <para>
            カーネルの再構築についてよく知らないのであれば, 
            <ulink URL="../handbook/kernelconfig.html">カーネルのコンフィグレーション</ulink>を参照してください.
          </para>
  
          <para>
            ブート時にカーネルが <devicename>psm0</devicename> を検出したら,
            <devicename>psm0</devicename> のエントリが <filename>/dev</filename> 
            の中にあることを確認してください. それには, 以下のようにします.

            <programlisting>&prompt.root; <command>cd /dev; sh MAKEDEV psm0</command></programlisting>

            これは <username>root</username> でログインしているときにおこなってください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="moused">
          <para>X Window System 以外の環境でマウスを使うことは可能ですか?</para>
        </question>

        <answer>
          <para>
            もしデフォルトのコンソールドライバである syscons
            を使っているのであれば,
            テキストコンソール上でマウスを使って,
            テキストのカットアンドペーストができます.
            マウスデーモンである moused を起動し,
            仮想コンソールでマウスポインタを有効にして下さい.
          </para>

          <screen>&prompt.root; <userinput><command>moused</command> -p /dev/<replaceable>xxxx</replaceable> -t <replaceable>yyyy</replaceable></userinput>
&prompt.root; <userinput><command>vidcontrol</command> -m on</userinput></screen>
  
          <para>
            ここで <replaceable>xxxx</replaceable>
            はマウスのデバイス名,
            <replaceable>yyyy</replaceable>
            はマウスのプロトコルタイプです.
            サポートされているプロトコルタイプについては
            &man.moused.8; のマニュアルページを参照してください.
          </para>
  
          <para>
            システムを起動する時に自動的に
            moused を起動したい場合には, 次のようにします.
            FreeBSD 2.2.1 では以下の変数を
            <filename>/etc/sysconfig</filename>
            で設定して下さい.</para>
  
          <programlisting>mousedtype="<replaceable>yyyy</replaceable>"
mousedport="<replaceable>xxxx</replaceable>"
mousedflags=""</programlisting>  

          <para>
            FreeBSD 2.2.2 以降のバージョンでは
            <filename>/etc/rc.conf</filename>
            で以下のように設定して下さい.</para>
  
          <programlisting>moused_type="<replaceable>yyyy</replaceable>"
moused_port="<replaceable>xxxx</replaceable>"
moused_flags=""</programlisting>
  
          <para>
            また, 起動時にすべての仮想端末で,
            標準のコンソールに加えマウスデーモンも使えるようにしたい,
            という場合には, 以下の行を
            <filename>/etc/rc.conf</filename> に加えて下さい.
          </para>

          <programlisting>allscreens_flags="-m on"</programlisting>

          <para>
            FreeBSD 2.2.6 以降の場合で
            比較的新しいシリアルマウスを使っているならば,
            マウスデーモンはマウスのプロトコルタイプを自動判別できます.
            自動判別を試みるには, プロトコルタイプとして
            &ldquo;<symbol>auto</symbol>&rdquo;
            を指定します.
          </para>
  
          <para>
            マウスデーモンを実行中は, マウスデーモンと他のプログラム(例えば X Window
            System)の間でマウスへのアクセスを調整しなければなりません.
            この問題については <link linkend="x-and-moused">X とマウス</link>をご覧下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>マウスを使って,
            テキストコンソールでカットアンドペーストするにはどうしたらよいのですか?</para>
        </question>

        <answer>
          <para>
            マウスデーモンを起動(<link linkend="moused">前の質問に対する答え</link>を参照して下さい)したあと
            ボタン 1(左ボタン)を押しながらマウスを動かして範囲を指定して下さい.
            ボタン 2(中ボタン)またはボタン 3(右ボタン)をクリックするとテキスト
            カーソルの位置に選択した範囲のテキストがペーストされます.
          </para>
  
          <para>
            FreeBSD 2.2.6 以降では, ボタン 2
            をクリックするとペーストされ, ボタン 3
            をクリックした場合に既存の選択範囲が現在のマウスポインタの位置まで
            延長または短縮されます. もしマウスに中ボタンがないなら,
            moused のオプションを使って中ボタンのエミュレーションをするか,
            他のボタンを中ボタンとして使う事ができます.
            詳しくは &man.moused.8 のマニュアルページを参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="usbmouse">
          <para>USB マウスを持っているのですが, FreeBSD で使えますか?</para>
        </question>
        
        <answer>
          <para>
            USB デバイスは FreeBSD 3.1 からサポートされましたが,
            実装は FreeBSD 3.2 であってもまだ完全ではないため,
            必ずしも安定して動作するとは限りません.
            もし, それでも USB マウスを使ってみたいという人は,
            以下の手順を試してみて下さい.
          </para>
          
          <orderedlist>
            <listitem>
              <para>FreeBSD 3.2 か, それ以降を使います.</para>
            </listitem>
            
            <listitem>
              <para>
                カーネルコンフィグレーションファイルに以下の行を追加し,
                カーネルを再構築します.
              </para>
              
              <programlisting>
controller      uhci0
controller      ohci0
controller      usb0
device          ums0</programlisting>
            </listitem>

            <listitem>
              <para><filename>/dev</filename> ディレクトリに移動し,
                次のようにしてデバイスノードを作成します.</para>
              
              <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV ums0</userinput></screen>
            </listitem>

            <listitem>
              <para><filename>/etc/rc.conf</filename> を編集し,
                以下の行を追加します.</para>

              <programlisting>
moused_enable="YES"
moused_type="auto"
moused_port="/dev/ums0"
moused_flags=""
usbd_enable="YES"
usbd_flags=""</programlisting>
              
              <para>moused の設定の詳細については,
                <link linkend="moused">前項</link>も参照してください.
              </para>
            </listitem>
            
            <listitem>
              <para>
                X のセッションで USB マウスを使うには,
                <filename>XF86Config</filename> を編集する必要があります.
                XFree86 3.3.2, もしくはそれ以降を利用している場合は,
                <emphasis>Pointer</emphasis>
                セクションが次のようになっていることを確認して下さい.
              </para>
              
              <programlisting>
Device          "/dev/sysmouse"
Protocol        "Auto"</programlisting>
              
              <para>
                それより前のバージョンの XFree86 を利用している場合は,
                <emphasis>Pointer</emphasis>
                セクションが次のようになっていることを確認して下さい.
              </para>
              
              <programlisting>
Device          "/dev/sysmouse"
Protocol        "SysMouse"</programlisting>
            </listitem>
          </orderedlist>

          <para>X 環境でのマウスの利用については,
            <link linkend="x-and-moused">他の項</link>も参照してください.
          </para>
          
          <para>
            USB マウスの活線挿抜(ホットプラグ機能)は,
            まだおそらくきちんと動作しないと思われます.
            トラブルを避けるためにも, マウスはシステムを起動させる前に接続しておき,
            シャットダウンするまではずさないようにした方が良いでしょう.
          </para>
        </answer>
      </qandaentry>
      
      <qandaentry>
        <question>
          <para>わたしのマウスにはホイール機能や便利なボタンがついているのですが,
            これは FreeBSD でも使えるのですか?</para>
        </question>

        <answer>
          <para>
            答えは残念ながら「場合によります」です.
            こうしたマウスの付加的な機能は大抵の場合, 特殊なドライバを必要とします.
            マウスのデバイスドライバやユーザのプログラムが
            そのマウスに対する固有のサポートをしていない場合には,
            標準的な 2 ボタン/3 ボタンマウスのように振舞います.
          </para>

          <para>
            X ウィンドウシステムの環境でのホイールの使い方については,
            <link linkend="x-and-wheel">X とホイール</link>の項をご覧下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="psmerr">
          <para>
            わたしのマウスはきちんと動いてくれないようです. 
            マウスカーソルが画面中をとびまわります.
            このマウスにはホイールがついていて,
            接続は PS/2 ポートです.</para>
        </question>
        
        <answer>
          <para>
            FreeBSD 3.2 およびそれ以前の PS/2 マウスドライバ psm には,
            Logitech モデル M-S48 とその
            OEM のホイールマウスで不具合が発生します.
            以下のパッチを <filename>/sys/i386/isa/psm.c</filename>
            に適用して, カーネルを再構築して下さい.
          </para>
          
          <programlisting>
Index: psm.c
===================================================================
RCS file: /src/CVS/src/sys/i386/isa/Attic/psm.c,v
retrieving revision 1.60.2.1
retrieving revision 1.60.2.2
diff -u -r1.60.2.1 -r1.60.2.2
--- psm.c	1999/06/03 12:41:13	1.60.2.1
+++ psm.c	1999/07/12 13:40:52	1.60.2.2
@@ -959,14 +959,28 @@
     sc->mode.packetsize = vendortype[i].packetsize;
 
     /* set mouse parameters */
+#if 0
+    /* 
+     * A version of Logitech FirstMouse+ won't report wheel movement,
+     * if SET_DEFAULTS is sent...  Don't use this command.
+     * This fix was found by Takashi Nishida.
+     */
     i = send_aux_command(sc->kbdc, PSMC_SET_DEFAULTS);
     if (verbose >= 2)
 	printf("psm%d: SET_DEFAULTS return code:%04x\n", unit, i);
+#endif
     if (sc->config & PSM_CONFIG_RESOLUTION) {
         sc->mode.resolution
 	    = set_mouse_resolution(sc->kbdc, 
-	        (sc->config & PSM_CONFIG_RESOLUTION) - 1);
+				   (sc->config & PSM_CONFIG_RESOLUTION) - 1);
+    } else if (sc->mode.resolution >= 0) {
+	sc->mode.resolution
+	    = set_mouse_resolution(sc->kbdc, sc->dflt_mode.resolution);
+    }
+    if (sc->mode.rate > 0) {
+	sc->mode.rate = set_mouse_sampling_rate(sc->kbdc, sc->dflt_mode.rate);
     }
+    set_mouse_scaling(sc->kbdc, 1);
 
     /* request a data packet and extract sync. bits */
     if (get_mouse_status(sc->kbdc, stat, 1, 3) < 3) {</programlisting>

          <para>FreeBSD 3.2
            より新しいリリースではきちんと動作するはずです.
          </para>

        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ラップトップ PC のマウス/トラックボール/タッチパッドは使えますか?</para>
        </question>

        <answer>
          <para>
            <link linkend="ps2mouse">前の質問に対する答え</link>と,
            <link linkend="pao">モバイルコンピューティングのページ</link>をご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どんなテープドライブをサポートしていますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD は SCSI, QIC-36 (QIC-02 インタフェース付き) および 
            QIC-40/80 (フロッピーベース) テープドライブをサポートしています. 
            これらには 8-mm (Exabyte と呼ばれています) や DAT ドライブも含まれています. 
            QIC-40/80 ドライブは遅いことが知られています.
          </para>
  
          <para>
            初期の 8-mm ドライブの中には SCSI-2
            とまったく互換性を持たないものがあります. 
            これらは FreeBSD 上では動作しません.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どんなテープチェンジャーをサポートしていますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD 2.2 は &man.ch.4; デバイスと &man.chio.1
            コマンドを使用した SCSI チェンジャーをサポートしています. 
            実際のチェンジャーの制御方法の詳細は,
            &man.chio.1 のマニュアルページを参照してください.
          </para>
  
          <para>
            使用している製品が
            <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?amanda">AMANDA</ulink>
            のようにチェンジャーに対応済みのものでない場合は, 
            次のことについて留意してください.
            それらの製品は任意のポイント間のテープの移動を制御するだけなので,
            テープがどのスロットに入っているか, 現在ドライブにあるテープが
            どのスロットに戻るべきかを把握しておく必要があります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どんなサウンドカードをサポートしていますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD は SoundBlaster, SoundBlaster Pro, SoundBlaster 16,
            Pro Audio Spectrum 16, AdLib それから Gravis UltraSound サウンドカードを
            サポートしています. MPU-401 やその互換カードも機能に制限はあるものの
            サポートされています. マイクロソフトサウンドシステムのスペックに準拠
            したカードも, <devicename>pcm</devicename> ドライバでサポートされています.

            <note>
              <para>
                これらはサウンドについてのみの話です! これらのドライバは
                CD-ROM, SCSI, カード上にあるジョイスティックをサポートしていません
                (SoundBlaster は例外です). SoundBlaster SCSI インタフェースと非 SCSI 
                CD-ROM はサポートしていますが, そのデバイスからはブートできません.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><devicename>pcm</devicename>
            ドライバで es1370 から音が出ないのはどうにかなりませんか?</para>
        </question><answer>

          <para>マシンを起動するごとに以下のコマンドを実行してください.</para>
  
          <screen>&prompt.root; <userinput><command>mixer</command> pcm 100 vol 100 cd 100</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どんなネットワークカードをサポートしていますか?</para>
        </question>

        <answer>
          <para>
            より完全な一覧については<ulink URL="../handbook/install-hw.html#INSTALL-NICS">イーサネットカード</ulink>の節を参照してください.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>数値演算コプロセッサを持っていませんが, 何かまずいでしょうか?</para>
        </question>

        <answer>
          <para>
            <note>
              <para>
                これらは 386/486SX/486SLC を持っている場合に影響します
                - ほかのマシンでは CPU に内蔵されています. 
              </para>
            </note>
          
            一般にこれらは問題とはなりません.
            しかし, 数値演算エミュレーションコードのパフォーマンスか,
            正確さのいずれかを選択する状況があります(詳しくは <link linkend="emul">FP
              エミュレーション</link> についての節をご覧ください).
            とくに, X 上で弧を描く際にとても遅くなることでしょう. 
            数値演算コプロセッサを購入されることを強くおすすめします. 
            とても役立つことでしょう.

            <note>
              <para>
                他の数値演算コプロセッサよりも優れたコプロセッサもあります. 
                これは言いにくいことなのですが, Intel を買うために躍起になる人もいないでしょう. 
                それが FreeBSD 上で動くという確信がないのなら, クローンにご用心を.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>2.x で, 他にどのドライバがサポートされていますか?</para>
        </question>

        <answer>
          <para><ulink URL="../handbook/install-hw.html#INSTALL-MISC">FreeBSD
              ハンドブック</ulink>に記されている,
            サポートされている他のデバイスの一覧を参照して下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>パワーマネージメント機能付きのラップトップ PC を持っているのですが...</para>
        </question>

        <answer>
          <para>
            FreeBSD は一部のマシンの APM をサポートしています. 
            <acronym>LINT</acronym> カーネルコンフィグファイル の
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?apm">APM</ulink>
            の部分をご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Micron システムがブート時に固まってしまいます. </para>
        </question>

        <answer>
          <para>
            特定の Micron 製のマザーボードの中には, PCI BIOS が規格通りに
            実装されていないために FreeBSD の起動に失敗するものがあります.
            その BIOS は, PCI デバイスをあるアドレスで設定したと報告するにも
            関わらず, 実際にはそうしていないのです.
          </para>
  
          <para>
            この問題を回避するには, BIOS の
            &ldquo;Plug and Play Operating System&rdquo;
            を無効に設定して下さい. また, より詳しい情報は
            <ulink URL="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</ulink>
            を参照して下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>新しい Adaptec コントローラを持っているのですが,
            FreeBSD が検出できないようです.</para>
        </question>

        <answer>
          <para>
            新しい AIC789x シリーズの Adaptec チップは, 3.0 でデビューした CAM SCSI
            フレームワークでサポートされています.  2.2-STABLE のパッチは
            <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/">ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/</ulink> にあります.
            CAM システムが入っている高機能ブートフロッピーは
            <ulink URL="http://people.FreeBSD.org/~abial/cam-boot/">http://people.FreeBSD.org/~abial/cam-boot/</ulink> にあります.
            どちらの場合にしても, 作業を始める前に <filename>README</filename>
            をお読み下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>内蔵の Plug &amp; Play
            モデムを持っているのですが, FreeBSD が検出できないようです.</para>
        </question>

        <answer>
          <para>
            モデムの PnP ID を シリアルドライバの PnP ID
            リストに追加する必要があるでしょう. Plug &amp; Play サポートを有効にするには,

            <programlisting>controller pnp0</programlisting>

            をコンフィグレーションファイルに付け加え,
            新しいカーネルをコンパイルしてシステムを再起動して下さい.
            カーネルは, 検出した全てのデバイスの
            PnP ID を表示します.
            モデムの欄にある PnP ID を <filename>/sys/i386/isa/sio.c</filename>
            の 2777 行目くらいにあるテーブルに書き入れて下さい.
            テーブルを見つけるには, 構造体
            &ldquo;siopnp_ids[]&rdquo; の文字列 &ldquo;SUP1310&rdquo;
            を探します.
            カーネルを作り直したらインストールし, システムを再起動して下さい.
            そうすれば, モデムが検出されるはずです.
          </para>
  
          <para>
            起動時のコンフィグレーションの際に, <command>pnp</command>
            コマンドを使用して PnP の設定をマニュアルで行なわなければならないかもしれません.
            その場合, モデムを検出させるためのコマンドは

            <screen>&prompt.root; <userinput><command>pnp</command> 1 0 enable os irq0 3 drq0 0 port0 0x2f8</userinput></screen>

            のようになります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>シリアルコンソールで boot: プロンプトを表示するにはどうすればいい?</para>
        </question>

        <answer>
          <para>
            <orderedlist>
              <listitem>
                <para>
                  <literal>options COMCONSOLE</literal>
                  を指定してカーネルを構築して下さい.
                </para>
              </listitem>

              <listitem>
                <para>
                  そして <filename>/boot.config</filename>
                  を作成して <option>-P</option> とだけ書き入れて下さい.
                </para>
              </listitem>

              <listitem>
                <para>その後, キーボードをシステムから抜いて下さい.</para>
              </listitem>
            </orderedlist>
          </para>
  
          <para>
            <filename>/usr/src/sys/i386/boot/biosboot/README.serial</filename> に,
            これに関する情報が書かれています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>なぜ Micron コンピュータで 3Com PCI ネットワークカードが動かないのでしょう?</para>
        </question>

        <answer>
          <para>
            特定の Micron 製のマザーボードの中には, PCI BIOS が規格通りに
            実装されていないために FreeBSD の起動に失敗するものがあります.
            その BIOS は, PCI デバイスをあるアドレスで設定したと報告するにも
            関わらず, 実際にはそうしていないのです.
          </para>
  
          <para>
            この問題を回避するには, BIOS の
            &ldquo;Plug and Play Operating System&rdquo;
            を無効に設定して下さい. また, より詳しい情報は
            <ulink URL="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</ulink>
            を参照して下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>対称型マルチプロセッシング(SMP)をサポートしていますか?</para>
        </question>

        <answer>
          <para>
            SMP は 3.0-STABLE
            とそれ以降のリリースでしかサポートされていません.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="troubleshoot">
    <title>トラブルシューティング</title>

    <para>
      <emphasis>訳:
        内川 喜章 <email>yoshiaki@kt.rim.or.jp</email>,
        1997 年 11 月 10 日.</emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question id="awre">
          <para>ハードディスクに不良ブロックがあります!</para>
        </question>

        <answer>
          <para>
            SCSI ディスクの場合は自動的に再マップする機能があるはずです. 
            しかし, 理解し難い理由から多くのドライブがこの機能が無効化
            されて出荷されています...
          </para>
  
          <para>
            これを有効化するには,
            最初のデバイスのモードページを変更する必要があります.
            これは次のコマンドを実行することで, FreeBSD 
            上でおこなうことができます(<username>root</username>
            権限でおこないます).
          </para>
  
          <screen>&prompt.root; <userinput><command>scsi</command> -f /dev/rsd0c -m 1 -e -P 3</userinput></screen>
  
          <para>
            そして, <acronym>AWRE</acronym> と <acronym>ARRE</acronym>
            の値を 0 から 1 へ変更します
          </para>
  
          <screen>AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1</screen>
  
          <para>
            以下は, <ulink URL="mailto:tedm@toybox.placo.com">Ted
              Mittelstaedt 氏</ulink>から寄せられたものです.
          </para>
  
          <para>
            IDE ドライブの場合は通常, 不良ブロックは潜在的な障害の兆候です.
            最近の IDE ドライブは, 内部の不良ブロック再マッピング機能を有効にした状態で
            出荷されています. また, 今日の IDE ハードディスクメーカは,
            出荷以降に不良ブロックが発生することに関して保証を提供していて,
            不良ブロックのあるディスクドライブを交換するサービスを行なっています.
          </para>
  
          <para>
            もし, 不良ブロックのある IDE ディスクドライブを復旧しようと思うなら,
            IDE ドライブメーカが提供する IDE 診断プログラムをダウンロードして,
            そのドライブに使ってみてください. この種のプログラムは大抵,
            ドライブの制御部分に対して不良ブロックを再走査し,
            不良ブロックを使用不能にするようにセットすることができます.
          </para>
  
          <para>
            ESDI, RLL および MFM ドライブの場合,
            不良ブロックはドライブの正常な部分であり,
            一般的に言って障害を表すものではありません.
            PC では, ディスクドライブコントローラカードと
            BIOS が不良ブロックの使用不能化の作業を行ないます.
            DOS など, ディスクアクセスに BIOS
            を経由する OS にとっては有効に働きますが, FreeBSD
            のディスクドライバは BIOS を利用しません. そのため,
            代替として bad144 という機構が存在します.
            bad144 は, wd ドライバにだけ作用し, SCSI ドライバに利用することは
            *できません*. bad144 は,
            検出された不良セクタをスペシャルファイルに記録するという働きを持っています.
          </para>
  
          <para>
            bad144 を利用する上で, 注意しなければならない点が一つあります.
            それは, 不良ブロックスペシャルファイルは,
            ディスクの最終トラックに置かれるということです.
            このファイルには, ディスクの先頭の付近,
            <filename>/kernel</filename>
            ファイルが位置しているであろう部分で発生した不良セクタが記録されています.
            したがって, このファイルは BIOS
            コールを使ってカーネルファイルを読み込む起動プログラムが,
            アクセス可能でなければなりません.
            これはつまり, bad144 を利用するディスクは
            1024 シリンダ, 16 ヘッド, 63 セクタを超えてはならないということを意味し,
            bad144 を利用したディスクが実質 500MB を超えられないことになります.
          </para>
  
          <para>
            bad144 を使うには, FreeBSD のインストール時に表示される fdisk 画面で
            &ldquo;Bad Block&rdquo; 走査を ON に設定するだけです.
            これは, FreeBSD 2.2.7 以降で機能します.
            ディスクは, 1024 シリンダ以内でなければなりません.      
            ディスクドライブは事前に少なくとも 4 時間,
            ディスクが温度によって膨張し,
            トラックに曲がりが出るまで回転させることをお薦めします(訳注:
            温度変化に対する膨張によって,
            ディスクが微小変形することにより発生する不良セクタを確実に検出するためです).
          </para>
  
          <para>
            大容量の ESDI ドライブのように 1024 シリンダを超えるディスクの場合,
            DOS 上でそのディスクが利用できるよう,
            ESDI コントローラは特殊な変換モードを利用します.
            fdisk の &ldquo;set geometry&rdquo; コマンドを使って
            &ldquo;変換された(translated)&rdquo;
            ジオメトリに切替えると, wd ドライバはこの変換モードを解釈できます.
            その際, FreeBSD パーティションを作成するのに
            &ldquo;dangerously dedicated&rdquo;
            モードを利用してはいけません.
            このモードは, そのようなジオメトリを無視するからです.
            たとえ fdisk がオーバーライドされたジオメトリ情報を使ったとしても,
            依然としてディスクの真の大きさを保持しているため, 大きすぎる FreeBSD
            パーティションを作成しようとしてしまうでしょう.
            ディスクジオメトリ情報が変換されたジオメトリ情報にかわっている場合は,
            手動でブロック数を入力し,
            パーティションを作成する必要があります.
          </para>
  
          <para>
            大容量の ESDI ディスクを ESDI コントローラでセットアップするには,
            ちょっとしたトリックを使います. まず, DOS のディスクで起動して
            そのディスクを DOS パーティションとしてフォーマットします.
            そして FreeBSD を起動し, インストーラの fdisk 画面で
            DOS パーティションのブロックサイズとブロック数を読みとり, メモしておきます.
            ジオメトリ情報を DOS が利用しているものと同一に再設定し,
            DOS パーティションを削除して "cooperative" FreeBSD パーティションを
            先程記録したブロックサイズを使って作成して下さい.
            そのパーティションを起動可能パーティションに設定し, 不良ブロック走査を
            有効にして下さい. 実際のインストールでは, ファイルシステムが作成される前に
            bad144 が最初に実行されます(Alt-F2 を押すことで状況を確認できます).
            不良セクタファイルを作成中に何らかの障害が発生したなら,
            システムを再起動して, もう一度最初からやり直しになります.
            おそらくディスクジオメトリ情報の設定を大きくしすぎているのでしょう.
            (やり直しは, DOS によるフォーマットとパーティション確保を含みます)
          </para>
          
          <para>
            もし, 不良ブロックの再マッピングを有効にしていて不良ブロックが見付かったら,
            ドライブの交換を考えて下さい. 不良ブロックは, 時間とともに悪化するからです.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Bustek 742a EISA SCSI が認識されません.</para>
        </question>

        <answer>
          <para>
            この情報は 742a のためのものですが, 他の Buslogic カードについても
            同様のことが言えます. (Bustek = Buslogic)
          </para>
  
          <para>
            742a カードには大きくわけて 2つのバージョンが存在します. 
            ハードウェアリビジョンの A-G と H 以降です. リビジョンの
            文字はカードの隅にあるアセンブリ番号の後ろにあります. 
            742a は二つの ROM チップを持っており, 一つは BIOS チップで
            もう一つはファームウェアチップです. FreeBSD はあなたの
            持っているものがどの BIOS バージョンかは問題ありませんが, 
            ファームウェアバージョンについては問題となります.
            Buslogic の技術サポート部門に連絡すれば, アップグレード版の
            ROM を送ってくれることでしょう. BIOS チップと
            ファームウェアチップはペアで出荷されます. 
            アダプタカードのハードウェアリビジョンにあわせた
            最も新しいファームウェア ROM を使用しなければなりません.
          </para>
  
          <para>
            リビジョン A-G のカードには, 2.41/2.21 までの
            BIOS/ファームウェアのセットを使用することができます.
            リビジョン H 以降のカードには, 最新のものである
            4.70/3.37 の BIOS/ファームウェアのセットを
            使用することができます. これらのファームウェアの違いは,
            ファームウェア 3.37 が 「ラウンドロビン方式」
            をサポートしているところからきています.
          </para>
  
          <para>
            Buslogic のカードには, 製造番号も刻印されています. 古い
            ハードウェアリビジョンのカードを持っている場合は, Buslogic の RMA
            部門に問い合わせて製造番号を伝えると, 新しいハードウェアリビジョンの
            カードに交換することもできます. もしカードが十分新しければ, 彼らは
            交換に応じてくれるでしょう.
          </para>
  
          <para>
            FreeBSD 2.1 は ファームウェアリビジョン 2.21
            以降のものをサポートしています.
            これよりも古いファームウェアリビジョンのものは,
            Buslogic カードとして正常に認識されません.
            しかし, Adaptec 1540 として認識されるかもしれません. 
            初期の Buslogic のファームウェアは AHA1540 互換モードを
            持っています. しかし, EISA カードにとってこれは
            よいことではありません.
          </para>
  
          <para>
            古いハードウェアリビジョンのカードを持っていてファームウェア
            2.21 を入手するのであれば, ジャンパ W1 の位置をデフォルトの
            A-B から B-C に合わせる必要があるでしょう.
          </para>
  
          <para>
            742a EISA カードには, <link linkend="bigram">16 MB
              を越える容量のメモリを載せたマシン</link>の節で説明している
            「16 MB を越える」ことによる問題はありません. 
            これは Vesa-Local Buslogic SCSI カードで発生する問題です.
          </para> 
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>HP Netserver 上のオンボード SCSI コントローラが認識されません.</para>
        </question>

        <answer>
          <para>
            基本的にこれは既知の問題です. HP Netserver マシンの
            EISA オンボード SCSI コントローラは EISA のスロット番号 11
            を占有しますが, 「本当の」EISA
            スロットはすべてそれよりも前のアドレスに配置されているのです.
            残念ながら,
            10 番以上の EISA スロットは PCI
            に割り当てられたアドレス空間と衝突し, FreeBSD 
            の自動コンフィグレーションは,
            現状ではうまくこの状況を処理できていないのです.
          </para>
  
          <para>
            ですから現時点での最良の方法は, カーネルオプションの
            <symbol>EISA_SLOTS</symbol> を 12 に変え,
            アドレス空間の衝突がないかの
            ようなふりをさせることです :)
            <ulink URL="../handbook/kernelconfig.html">カーネルの再構築</ulink>に記述されているようにしてカーネルを再構築してください.</para>
  
          <para>
            もちろん, これはこのようなマシンにインストールする際に
            「卵が先か,
            鶏が先か」といった問題を生み出すことになります. 
            この問題を回避するために,
            <emphasis>ユーザコンフィグ(UserConfig)</emphasis>
            の中には特別な仕組みが組み込まれています.
            このとき ``visual'' インタフェースは使用せず,
            コマンドラインインタフェースを使用してください. 単純に

            <screen><userinput>eisa 12</userinput>
<userinput>quit</userinput></screen>
  
            とプロンプト上から打ち込み, 
            後は普通にインストールをおこなってください.
            とにかくカスタムカーネルのコンパイルとインストールをおこなうことを
            おすすめしますが,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?dset">dset</ulink>
            も現時点ではこの値の変更を認識するようになっています.
          </para>
  
          <para>
            うまくいけば, 将来のバージョンではこの問題が解決していることでしょう.

            <note>
              <para>HP Netserver
                では<emphasis remap=bf>危険覚悟の専用ディスク</emphasis>は使用できません.
                詳細については <link linkend="dedicate">この注意事項</link>をご覧ください.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>この CMD640 IDE コントローラはどこかおかしいようです.</para>
        </question>

        <answer>
          <para>
            それは壊れているのです. 両方のチャンネルを同時に制御できないのです.
          </para>
  
          <!-- hrs:2000/03/09 needs &man.wd.4; -->
          <para>
            現在, このチップを使っているシステムを自動的に検出して,
            うまく動かすためのしくみが使えるようになっています.
            くわしくは wd(4) のマニュアルページを参照してください.
          </para>
  
          <para>
            CMD640 IDE コントローラを使っているシステムで FreeBSD 2.2.1 
            あるいは 2.2.2 を使い,
            かつセカンダリのチャネルを使いたいのであれば,
            <symbol>options "CMD640"</symbol>
            を有効にしてカーネルを作り直してください. 
            FreeBSD 2.2.5 以降では, デフォルトでそうなっています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>&ldquo;<computeroutput>ed1: timeout</computeroutput>&rdquo;
            のようなメッセージがいつも出ます. </para>
        </question>

        <answer>
          <para>
            たぶん IRQ の衝突が原因でしょう (二つのボードが同じ IRQ 
            を使用しているなど). FreeBSD 2.0.5R
            以前はこれに関して寛大で,
            IRQ の衝突があってもネットワークドライバは機能していました.
            しかし 2.0.5R 以降はもはや, IRQ の衝突に寛大ではありません.
            <option>-c</option> オプションをつけて起動し,
            ed0/de0/... のエントリをボードの設定に合わせてください.
          </para>
  
          <para>
            ネットワークカードの BNC
            コネクタ(訳注: 10BASE-2 タイプのインターフェース)
            を使っている場合,
            デバイスのタイムアウトはターミネーションの不良によっても起きます.
            これをチェックするにはケーブルを外してターミネータを直接 NIC
            に接続します. そしてエラーメッセージが消えるかどうか
            確認します.
          </para>
  
          <para>
            NE2000 コンパチブルカードのなかには,
            UTP ポートのリンクがなかったりケーブルが接続されていない場合に
            このエラーを出すものがあります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>CDROM をマウントしようとすると
            &ldquo;<computeroutput>Incorrect super block</computeroutput>&rdquo; と言われます.</para>
        </question>

        <answer>
          <para>&man.mount.8; にマウントしたいデバイスのタイプを指定する必要があります.
            デフォルトでは &man.mount.8; はファイルシステムを 
            &ldquo;<symbol>ufs</symbol>&rdquo; とみなします. CDROM のファイルシステムを
            マウントしたいのであれば &ldquo;<option>-t cd9660</option>&rdquo;
            とオプションをつけて明示する必要があります. 
            これはもちろん 
            CDROM が ISO 9660 ファイルシステムである場合です. ほとんどの 
            CDROM はこの形式です. 1.1R の FreeBSD では (訳注: 2.1.5R, 
            2.2R でも同様です) 自動的に
            Rock Ridge 拡張(長いファイル名への対応)をうまく解釈します.
          </para>
  
          <para>
            CDROM のデバイス &ldquo;<filename>/dev/cd0c</filename>&rdquo;
            を
            <filename>/mnt</filename>
            にマウントしたい場合の例では, 次のようにします.
          </para>
  
          <screen>&prompt.root; <userinput><command>mount</command> -t cd9660 /dev/cd0c /mnt</userinput></screen>
  
          <para>デバイスの名前はインタフェースによっては別の名前になっている
            かもしれないので注意してください(&ldquo;<filename>/dev/cd0c</filename>&rdquo;
            はこの場合の例です).
            オプション &ldquo;<option>-t cd9660</option>&rdquo;
            によって 
            &ldquo;<command>mount_cd9660</command>&rdquo;
            コマンドが実行されることに注意してください.
            このため例は次のようにすることもできます.
          </para>

          <screen>&prompt.root; <userinput><command>mount_cd9660</command> /dev/cd0c /mnt</userinput></screen>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>CDROM をマウントしようとすると
            &ldquo;<computeroutput>Device not configured</computeroutput>&rdquo;
            と言われます. </para>
        </question>

        <answer>
          <para>
            これは 一般的に CDROM ドライブの中に CDROM が入っていないか, 
            ドライブがバス上に見えないことを意味します. ドライブに CDROM 
            を入れるか, IDE (ATAPI) であれば master/slave
            の状態をチェックしてください.
            また, CDROM ドライブに CDROM
            を入れてから認識するまでには数秒かかりますので,
            少し待ってみてください.
          </para>
  
          <para>
            SCSI CDROM ではバスリセットへの応答時間が遅いために,
            失敗することがあるかもしれません.
            SCSI CDROM を持っている場合は,
            カーネルコンフィグレーションファイルに以下の行を加えて
            再コンパイルして試してみてください.

            <note>
              <title>訳注</title>
              <para>
                現在の GENERIC カーネルでは上の設定はデフォルトになっています.
                問題のある場合は <symbol>SCSI_DELAY</symbol>
                の数値を増やしてみてください.
              </para>
            </note>
          </para>
  
          <programlisting>options "SCSI_DELAY=15"</programlisting>
          
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私のプリンタはとてつもなく遅いのです.
            どうしたらよいのでしょう?</para>
        </question>

        <answer>
          <para>
            パラレルインタフェースで, 問題はとんでもなく遅いだけであるなら, 
            プリンタボートを &ldquo;polled&rdquo;
            モードに設定してみてください.</para>

          <screen>&prompt.root; <userinput><command>lptcontrol</command> -p</userinput></screen>
  
          <para>
            HP の新しいプリンタには,
            割り込みモードで使えないものがあるようです(完全にわかったわけではありませんが). 
            タイミングの問題のように思われます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私のプログラムは時々
            &ldquo;<computeroutput>Signal 11</computeroutput>&rdquo;
            のエラーで止まってしまいます.</para>
        </question>

        <answer>
          <para>
            これはハードウェア(メモリ,
            マザーボードなど)の不具合が原因です.
            PC でメモリテストプログラムを動かしてみてください. 
            ただしメモリが正常に動作していると報告されたとしても,
            ぎりぎりでメモリテストにパスしたメモリは,
            処理の内容 (例えばカーネルのコンパイルや,
            特にシステムの負荷が高いような場合,
            Adaptec 1542 などの SCSI コントローラのバスマスタ DMA
            を使っている場合)によっては問題が起きる可能性は大いにあります.
          </para>
  
          <para>
            SIG11 FAQ(後述)では,
            遅いメモリが一般的に問題を起こしがちであることを指摘しています.
            BIOS セットアップでウェイトステート数を増やすかメモリを速いものに交換してください.
          </para>
  
          <para>
            わたしの場合は, キャッシュ RAM
            やオンボードキャッシュコントローラの問題でした.
            このような問題ではないか確認するために BIOS
            セットアップでオンボード(二次)キャッシュを無効にして
            みてください.
          </para>
  
          <para>
            以下のところには広い範囲の FAQ があります. 
            <ulink URL="http://www.bitwizard.nl/sig11/">the SIG11 problem FAQ</ulink>
          </para>
         </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ブートの時に画面が真っ暗になって同期も取れません. </para>
        </question>

        <answer>
          <para>
            これは ATI Mach 64 ビデオカードの既知の問題です. 
            この問題はカードがアドレス <literal>2e8</literal> を使い,
            4 番目のシリアルポートもここを使うということにあります.
            &man.sio.4; ドライバのバグ(仕様?)のため,
            4 番目のシリアルポートがなくても,
            通常このアドレスを使う sio3(4 番目のポートにあたります)
            を無効にしても, ドライバはこのアドレスをさわります.
          </para>
  
          <para>
            バグが修正されるまでは, 次のようにして対処してください.
          </para>
  
          <para>
            <orderedlist>
              <listitem>
                <para> ブートプロンプトが出たら <option>-c</option> と入力します
                  (これによりカーネルはコンフィグレーションモードに入ります).
                </para>
              </listitem>

              <listitem>
                <para>
                  <symbol>sio0</symbol>,
                  <symbol>sio1</symbol>,
                  <symbol>sio2</symbol>,
                  <symbol>sio3</symbol>(これらすべて)を無効にします.
                  これによって &man.sio.4; ドライバは動作しなくなりますが, 問題はありません. 
                </para>
              </listitem>

              <listitem>
                <para><userinput>exit</userinput> とタイプしてブートを続行します.</para>
              </listitem>
            </orderedlist>
          </para>
  
          <para>
            もしシリアルポートを有効にしたいのであれば以下の変更をおこなって
            新しいカーネルを作る必要があります. 
            <filename>/usr/src/sys/i386/isa/sio.c</filename> の中で 1 ヵ所ある 
            <literal>0x2e8</literal> という文字列を探し,
            この文字列とその手前にあるコンマを削除します(後ろのコンマは残します).
            後は通常の手続きにしたがって新しいカーネルを作ります.
          </para>
  
          <para>
            この対処をおこなった後でもまだ
            X ウィンドウシステムはうまく動かないかもしれません.
            その場合は,
            使用している XFree86 がすくなくとも XFree86 3.3.3
            以降であることを確かめてください. 
            それ以降のバージョンでは,
            Mach64 カードやそれらのカードのためにつくられた
            X サーバ の組込みをサポートします. 
          </para>
        </answer>
      </qandaentry>
      
      <qandaentry>
        <question id="reallybigram">
          <para>128MB の RAM があるのですが, 64MB しか認識しません.</para>
        </question>

        <answer>
          <para>
            FreeBSD がメモリのサイズを BIOS から取得する方法の制限により,
            KB 単位で 16 ビット分までしか検出できません(すなわち最大
            65535KB=64MB です. これより少ない場合もあります.
            ある BIOS の場合はメモリサイズが 16MB に制限されます).
            64MB 以上のメモリを積んでいる場合,
            FreeBSD はそれを検出しようとします.
            しかしその試みは失敗するかもしれません.
          </para>
  
          <para>
            この問題を回避するには,
            以下に示すカーネルオプションを使用する必要があります.
            完全なメモリ情報を BIOS から取得する方法もありますが,
            ブートブロックに空きが無いため実装できません.
            ブートブロックの問題が解決されれば,
            いつか拡張 BIOS 機能を使用して完全なメモリ情報を取得できるようになるでしょう.
            とりあえず現在は, カーネルオプションを使ってください.
          </para>
  
          <programlisting>options "MAXMEM=<replaceable>n</replaceable>"</programlisting>
  
          <para>
            <replaceable>n</replaceable> には,
            キロバイト単位でメモリの量を指定します. 128MB 
            の場合は, 131072 となります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD 2.0 が
            &ldquo;<computeroutput>kmem_map too small!</computeroutput>&rdquo;
            と言ってパニックします. </para>
        </question>

        <answer>
          <para>
            <note>
              <para>メッセージは, &ldquo;<computeroutput>mb_map too small!</computeroutput>&rdquo;
                の場合もあります.
              </para>
            </note>
  
            このパニックは, ネットワークバッファ(特に mbuf
            クラスタ)の仮想メモリが無くなったことを示します.
            以下のオプションをカーネルコンフィグファイルに追加して
            mbuf クラスタに使用できる仮想メモリの量を増やしてください.
          </para>
  
          <programlisting>options "NMBCLUSTERS=<replaceable>n</replaceable>"</programlisting>
  
          <para>
            <replaceable>n</replaceable>
            には,
            同時に使用したい TCP コネクションの数に応じて 
            512 から 4096 までの数値を指定できます.
            とりあえず 2048 を試してみるのをおすすめします.
            これでパニックは完全の予防できるはずです. 
            mbuf クラスタの割り当て, 使用状況については,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?netstat">netstat -m</ulink>
            で知ることができます. <symbol>NMBCLUSTERS</symbol> のデフォルト値は 
            <literal>512 + MAXUSERS * 16</literal> です.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>新しいカーネルでリブートすると
            &ldquo;<computeroutput>CMAP busy panic</computeroutput>&rdquo;
            となってパニックを起こしてしまいます. 
          </para>
        </question>

        <answer>
          <para>
            ファイル <filename>/var/db/kvm_*.db</filename>
            において範囲外のデータを検出するためのロジックは失敗することがあり,
            こうした矛盾のあるファイルを使用することでパニックを引き起こすことがあります.
          </para>
  
          <para>
            これが起こったなら, シングルユーザでリブートした後に,
            以下のコマンドを実行してください.
          </para>

          <screen>&prompt.root; <userinput><command>rm</command> /var/db/kvm_*.db</userinput></screen>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><computeroutput>ahc0: brkadrint,  Illegal Host Access at seqaddr 0x0</computeroutput>
            というエラーが出ます</para>
        </question>

        <answer>
          <para>
            これは Ultrastor SCSI Host Adapter と衝突しています.
          </para>
  
          <para>
            ブート時に kernel configuration メニューに入り,
            問題を起こしている
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?uha(4)">uha0</ulink>
            を disable にしましょう.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>sendmail が &ldquo;<computeroutput>mail loops back to myself</computeroutput>&rdquo;
            というメッセージを出すのですが.</para>
        </question>

        <answer>
          <para>
            この事は, sendmail FAQ に次のように書いてあります.
          </para>
  
          <blockquote>
            <para>
              * "<computeroutput>Local configuration error</computeroutput>" というメッセージが出ます. 例えば:
              <screen><computeroutput>553 relay.domain.net config error: mail loops back to myself</computeroutput>
<computeroutput>554 &lt;user@domain.net&gt;... Local configuration error</computeroutput></screen>

のような物ですが, どのようにしたらこの問題を解決できますか?
            </para>

            <para>
              これは, 例えば <hostid>domain.net</hostid> のようなドメイン宛てのメールを 
              <literal>MX</literal> record で特定のホスト(ここでは
              <hostid>relay.domain.net</hostid>) に送ろうとしたのに,
              そのホストでは <hostid>domain.net</hostid>
              宛てのメールを受け取れるような設定になっていない場合です. 設定の際に 
              <literal>FEATURE(use_cw_file)</literal> を指定してある場合には
              <filename>/etc/sendmail.cw</filename> 
              の中に <hostid>domain.net</hostid> を追加してください.
              もしくは, <filename>/etc/sendmail.cf</filename>
              の中に &ldquo;<literal>Cw domain.net</literal>&rdquo; を追加してください.
            </para>
          </blockquote>
  
          <para>
            もはや現在の
            <ulink URL="ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq">sendmail FAQ</ulink>
            は sendmail release とは一緒には保守されていません.
            しかし次のネットニュースに定期的に投稿されてます. 
            <ulink URL="news:comp.mail.sendmail">comp.mail.sendmail</ulink>,
            <ulink URL="news:comp.mail.misc">comp.mail.misc</ulink>,
            <ulink URL="news:comp.mail.smail">comp.mail.smail</ulink>,
            <ulink URL="news:comp.answers">comp.answers</ulink>,
            <ulink URL="news:news.answers">news.answers</ulink>.
            また, メール経由でコピーを入手する場合は 
            <ulink URL="mailto:mail-server@rtfm.mit.edu">mail-server@rtfm.mit.edu</ulink>
            宛まで本文に &ldquo;<literal>send usenet/news.answers/mail/sendmail-faq</literal>&rdquo;
            と書いて送ります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>リモートマシン上のフルスクリーンアプリケーションがうまく動かない</para>
        </question>

        <answer>
          <para>
            リモートマシンのターミナルタイプが FreeBSD
            のコンソールで必要とされている <symbol>cons25</symbol>
            以外のものです.
          </para>
  
          <para>この問題を解決しうる方法はいろいろあります:

            <itemizedlist>
              <listitem>
                <para>リモートマシンにログインした後, 
                  そのリモートマシンが
                  <symbol>ansi</symbol> か
                  <symbol>sco</symbol>
                  のターミナルタイプを知っているなら,
                  shell 変数の <varname>TERM</varname> にそれらのいずれかを設定します.
                </para>
              </listitem>

              <listitem>
                <para>FreeBSD のコンソール側で
                  <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?screen-">screen</ulink>
                  のような VT100 エミュレータを使用します.
                  <command>screen</command>
                  は一つのターミナルの中で複数のセッションを並列動作させることができますし,
                  本来の機能も優れています.
                  各々の <command>screen</command> のウィンドウは
                  VT100 ターミナルのように振る舞うので,
                  リモート側で設定されるべき <varname>TERM</varname> 変数は
                  <symbol>vt100</symbol> となります.
                </para>
              </listitem>

              <listitem>
                <para>リモートマシンのターミナルデータベースに
                  <symbol>cons25</symbol>
                  のエントリをインストールします.
                  このインストール方法はリモートマシンのオペレーティングシステムに依存します.
                  リモートのシステムのシステム管理マニュアルが役に立つことでしょう.
                </para>
              </listitem>

              <listitem>
                <para>FreeBSD 側で X サーバを起動して,
                  リモートマシンに <command>xterm</command>
                  のような X ベースのターミナルエミュレータを使ってログインします.
                  (訳注: 日本語が必要な場合は <command>kterm</command> 等を
                  利用します)
                  リモートホストの <varname>TERM</varname> 変数は
                  <symbol>xterm</symbol> もしくは
                  <symbol>vt100</symbol>(訳注: もしくは <literal>kterm</literal>)
                  に設定します.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私のマシンで &ldquo;<computeroutput>calcru: negative time...</computeroutput>&rdquo;
            と表示されるのですが</para>
        </question>

        <answer>
          <para>
            これは, 割り込みに関連するさまざまな不具合によって発生します.
            あるいは, あるデバイスが元々持っているバグが表面化したのかも知れません.
            この症状を再現させる一つの方法として, パラレルポート上で,
            TCP/IP を 大きな <acronym>MTU</acronym>
            で走らせるというものがあります.
            グラフィックアクセラレータがこの症状を起こすことがありますが,
            その場合はまず, カードの割り込み設定を確認して下さい.
          </para>
  
          <para>
            この問題の副作用として,
            プロセスが &ldquo;<computeroutput>SIGXCPU exceeded cpu time limit</computeroutput>&rdquo;
            というメッセージとともに終了してしまう, というものがあります.</para>
  
          <para>
            1998 年 11 月 29 日に公開された FreeBSD 3.0 以降で
            この問題が解決しないなら, 次の <literal>sysctl</literal> 変数をセットしてください.
          </para>  

          <screen>&prompt.root; <userinput><command>sysctl</command> -w kern.timecounter.method=1</userinput></screen>
  
          <para>
            これは, パフォーマンスへ強い影響を与えますが,
            問題の発生に比べればおそらく気にならない程度でしょう.
            もし, これでもまだ問題が残るようなら,
            カーネルオプションの &ldquo;<literal>NTIMECOUNTER</literal>&rdquo;
            を大きな値に増やして下さい.
            &ldquo;<literal>NTIMECOUNTER=20</literal>&rdquo;
            にまで増やしても解決しない場合は,
            計時処理の信頼性が保てない程の割り込みが,
            そのマシン上で起こっていることを意味します.
          </para>  
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="commercial">
    <title>商用アプリケーション</title>

    <para>
      <emphasis>訳:
        山下 淳 <email>junkun@esys.tsukuba.ac.jp</email>,
        1997 年 11 月 10 日.</emphasis>

      <note>
        <para>
          この章はまだまだ情報が足りません.
          情報を追加してくれるような企業を待ち望んでいます.
          FreeBSD グループはここに載っている企業からの金銭的な支援を期待してはいませんので,
          奉仕作業の一つとして掲載しています(そして
          FreeBSD が係わる宣伝は, 長い目で見ると FreeBSD
          に対してよい方向へ働くと思っています). 
          私たちは商用ソフトウェアベンダに,
          ここで製品を宣伝してもらうことを望んでいます. 詳しくは,
          <ulink URL="../commercial/commercial.html">商用ソフトウェアベンダ覧のページ</ulink>をご覧ください.</para>
      </note>
    </para>
 
    <qandaset>
      <qandaentry>
        <question>
          <para>FreeBSD 用の Motif はどうやったら手に入りますか</para>
        </question>

        <answer>
          <para>
            FreeBSD 用の廉価版 ELF Motif 2.1.20 (i386 版, Alpha 版)
            に関する情報は<link linkend="apps2go">Apps2go</link> から
            手に入れることができます.<anchor id="apps2go">
          </para>
  
          <para>
            この製品には, 「開発者版(development edition)」 と,
            より安価な「ランタイム版(runtime edition)」
            の二つの版があります. これらの製品は以下の物が含まれています.

            <itemizedlist>
              <listitem>
                <para>OSF/Motif manager, xmbind, panner, wsm.
                </para>
              </listitem>

              <listitem>
                <para>uil, mrm, xm, xmcxx, インクルードファイルや Imake 
                  ファイルといった開発者向けキット
                </para>
              </listitem>

              <listitem>
                <para>FreeBSD 3.0 以降で利用できる ELF 版スタティックライブラリ,
                  およびダイナミックライブラリ
                </para>
              </listitem>
              
              <listitem>
                <para>デモンストレーションプログラム
                </para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>
            注文する際には FreeBSD 用の Motif であることをきちんと
            確認してください(あなたの欲しいアーキテクチャを指定するのも
            忘れないでください!). NetBSD や OpenBSD 用の Motif もまた,
            <emphasis>Apps2go</emphasis>から販売されています. 現在, FTP による
            ダウンロードのみ利用可能です.
          </para>

          <para>
            <variablelist>
              <varlistentry>
                <term>より詳しい情報は</term>
                <listitem>
                  <para><ulink URL="http://www.apps2go.com/">Apps2go WWW page</ulink></para>
                </listitem>
              </varlistentry>
              
              <varlistentry>
                <term>問い合わせは</term>
                <listitem>
                  <para><ulink URL="mailto:sales@apps2go.com">Sales</ulink> または
                    <ulink URL="mailto:support@apps2go.com">Support</ulink> 電子メールアドレス.</para>  
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>もしくは</term>
                <listitem>
                  <para>phone (817) 431 8775  or +1 817 431-8775</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
  
          <para>
            他の FreeBSD 用 Motif 2.1(ELF 版, a.out 版) に関する情報は
            <link linkend="metrox">Metro Link</link> から手に入れることができます.
          </para>
  
          <para>この製品は以下の物が含まれています.

            <itemizedlist>
              <listitem>
                <para>OSF/Motif manager, xmbind, panner, wsm.
                </para>
              </listitem>
              
              <listitem>
                <para>uil, mrm, xm, xmcxx, インクルードファイルや Imake 
                  ファイルといった開発者向けキット
                </para>
              </listitem>
              
              <listitem>
                <para>スタティックライブラリ, およびダイナミックライブラリ.
                  (FreeBSD 3.0 以降で利用できる ELF 版か,
                  FreeBSD 2.2.8 以前で利用できる a.out 版を指定して下さい)
                </para>
              </listitem>
              
              <listitem>
                <para>デモンストレーションプログラム
                </para>
              </listitem>
              
              <listitem>
                <para>整形済みのマニュアルページ</para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>
            注文する際には FreeBSD 用の Motif であることをきちんと
            確認してください. Linux 用の Motif も <emphasis>Metri Link</emphasis>
            から販売されています. 現在, CDROM および FTP
            によるダウンロードが利用可能です.
          </para>
  
          <para>
            FreeBSD 用の a.out 版 Motif 2.0 に関する情報は
            <link linkend="xig">Xi Graphics</link> から
            手に入れることができます.
          </para>
  
          <para>
            この製品は以下の物が含まれています.
            <itemizedlist>
              <listitem>
                <para>OSF/Motif manager, xmbind, panner, wsm.
                </para>
              </listitem>
              
              <listitem>
                <para>uil, mrm, xm, xmcxx, インクルードファイルや Imake 
                  ファイルといった開発者向けキット
                </para>
              </listitem>
              
              <listitem>
                <para>FreeBSD 2.2.8 以前のバージョンで利用できるスタティックライブラリ,
                  およびダイナミックライブラリ
                </para>
              </listitem>
              
              <listitem>
                <para>デモンストレーションプログラム
                </para>
              </listitem>
              
              <listitem>
                <para>整形済みのマニュアルページ</para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>
            注文する際には FreeBSD 用の Motif であることをきちんと
            確認してください. BSDI や Linux 用の Motif もまた, <emphasis>Xi Graphics</emphasis>
            から販売されています. 現在フロッピーディスク 4枚組ですが, 
            将来的には CDE のように統合された CD に変わるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD 用の CDE はどうやったら手に入りますか</para>
        </question>

        <answer>
          <para>以前
            <link linkend="xig">Xi Graphics</link> より FreeBSD 用の CDE が
            販売されていましたが, 現在は既に販売が終了しています.
          </para>
  
          <para><ulink URL="http://www.kde.org/">KDE</ulink>
            多くの点で CDE と類似しているオープンソースの X11 デスクトップ環境です.
            <ulink url="http://www.xfce.org/">xfce</ulink> の
            ルック &amp; フィール(訳注: 外観や操作方法のこと)も気に入るかも知れません.
            KDE, xfce は, いずれも
            <ulink url="http://www.FreeBSD.org/ports/">FreeBSD Ports Collection</ulink>
            に含まれています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>高機能な商用 X サーバってあるんですか?</para>
        </question>

        <answer>
          <para>はい, <ulink URL="http://www.xig.com/">Xi Graphics</ulink> と
            <ulink URL="http://www.metrolink.com/">Metro Link</ulink>
            から, FreeBSD ほか Intel ベースのシステムで動作する 
            Accelerated-X という製品が販売されています. 
          </para>
  
          <para>
            Metro Link は, FreeBSD のパッケージ操作ツールを利用することで
            容易に設定が行なえるほか, 数多くのビデオボードをサポートした
            高機能な X サーバを提供しています. 配布はバイナリ形式のみで,
            FTP が利用可能です. もちろん, とても安価($39)に手に入れることができます.
            <anchor id="metrox">
          </para>
  
          <para>
            また, Metro Link は ELF 版, a.out 版の FreeBSD 用 Motif
            も販売しています(前を参照).
          </para>
  
          <para>
            <variablelist>
              <varlistentry><term>より詳しい情報は</term>
                <listitem>
                  <para><ulink URL="http://www.metrolink.com/">Metro Link WWW page</ulink></para>
                </listitem>
              </varlistentry>

              <varlistentry><term>問い合わせは</term>
                <listitem>
                  <para><ulink URL="mailto:sales@metrolink.com">Sales</ulink>
                    または
                    <ulink URL="mailto:tech@metrolink.com">Support</ulink> 電子メールアドレス</para>
                </listitem>
              </varlistentry>
              
              <varlistentry><term>もしくは</term>
                <listitem>
                  <para>phone (954) 938-0283  or +1 954 938-0283</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
          
          <para>
            Xi Graphics が提供している高性能な X サーバは楽に設定をおこなえるほか,
            数多くのビデオボード
            をサポートしています. サーバはバイナリのみが含まれます. 
            FreeBSD 用と Linux 用の統合されたフロッピーディスクに入っています. 
            Xi Graphics は Laptop サポートに特化した高性能 X サーバも提供しています.
            <anchor id="xig">
          </para>
  
          <para>
            バージョン 5.0 の「互換デモ」が無料で入手できます.
          </para>
  
          <para>
            また Xi Graphics は FreeBSD 用の Motif と CDE も販売しています (前を参照).
          </para>
  
          <para>
            <variablelist>
              <varlistentry>
                <term>より詳しい情報は</term>
                <listitem>
                  <para><ulink URL="http://www.xig.com/">Xi Graphics WWW page</ulink></para>
                </listitem>
              </varlistentry>
              
              <varlistentry>
                <term>問い合せは</term>
                <listitem>
                  <para><ulink URL="mailto:sales@xig.com">Sales</ulink> または
                    <ulink URL="mailto:support@xig.com">Support</ulink></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>もしくは</term>
                <listitem>
                  <para>phone (800) 946 7433  or +1 303 298-7478.</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD 用のデータベースシステムはありますか?</para>
        </question>

        <answer>
          <para>もちろんです. FreeBSD のウェブサイトにある
            <ulink URL="../../commercial/software_bycat.html#CATEGORY_DATABASE">
              商用ベンダー</ulink> というセクションをご覧下さい.
          </para>
          
          <para>
            また, FreeBSD Ports Collection
            の<ulink URL="../ports/databases.html">データベース</ulink>のセクションも参考になるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Oracle を FreeBSD 上で動かすことはできますか?</para>
        </question>

        <answer>
          <para>
            はい. Linux 版 Oracle を FreeBSD でセットアップするための方法は,
            次に示すページに詳しく書かれています.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para><ulink URL="http://www.scc.nl/~marcel/howto-oracle.html">http://www.scc.nl/~marcel/howto-oracle.html</ulink></para>
              </listitem>

              <listitem>
                <para><ulink URL="http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd">http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd</ulink></para>
              </listitem>
            </itemizedlist>
          </para>
        </answer>
      </qandaentry>
    </qandaset>
</chapter>

  <chapter id="applications">
    <title>ユーザアプリケーション</title>

    <para>
      <emphasis>訳:
        山下 淳 <email>junkun@esys.tsukuba.ac.jp</email>,
        広瀬 昌一 <email>shou@kt.rim.or.jp</email>,
        1997 年 11 月 8 日.</emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>そういうユーザアプリケーションはどこにあるの?</para>
        </question>

        <answer>
          <para>FreeBSDに移植されたソフトウェアパッケージについては,
            <ulink URL="../ports/">FreeBSD Ports Collection
              のページ</ulink>をご覧下さい.
            このリストには現在 1800 を越える項目があり, 
            しかも毎日更新されています. このページをこまめに訪れるか,
            <link linkend="mailing">freebsd-announce
              メーリングリスト</link>を購読すると,
            新しく入った ports を定期的にチェックすることができます.
          </para>
  
          <para>
            大部分の ports は 2.2 と 3.x および 4.0 ブランチで利用できるはずです.
            多くは 2.1.x 系のシステムでも同様に動作するでしょう. 
            FreeBSD のリリースが出る度に, そのリリースの時点での ports ツリーの
            スナップショットが撮られ, <filename>ports/</filename> ディレクトリに
            納められることになっています.
          </para>
  
          <para>
            また, &ldquo;package&rdquo;
            という考えも採用されています. これは基本的には
            gzip で圧縮されたバイナリディストリビューションに,
            インストール時に環境に合わせた作業が必要になった場合,
            行う機能を多少付け加えたものです.
            package を使えば, どのようなファイルが配布物として含まれているか,
            と言った細かい事柄にいちいち煩わされることなく,
            簡単にインストールやアンインストールを繰り返すことができます.
          </para>
  
          <para>
            インストールしたい package があるなら,
            <filename>/stand/sysinstall</filename>の,
            「インストール後の FreeBSD の設定を行う」の下にある
            package のインストールメニューを使うか,
            package のファイル名を指定して
            <command>pkg_add(1)</command> を使用して下さい.
            package のファイル名には,
            通常末尾に <filename>.tgz</filename> がついています. 
            CDROM をご使用の方は, CD の
            <filename>packages/All</filename>
            ディレクトリからそれらのファイルを利用することができます.
            また, 以下の場所から,
            FreeBSD の各種バージョンにあわせた package をダウンロードする
            こともできます.
          </para>
  
          <para>
            <variablelist>
              <varlistentry>
                <term>2.2.8-RELEASE/2.2.8-STABLE 用</term>
                <listitem>
                  <para><ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/</ulink></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>3.X-RELEASE/3.X-STABLE 用</term>
                <listitem>
                  <para><ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/</ulink></para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>4.0-CURRENT 用</term>
                <listitem>
                  <para><ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-current/">ftp://ftp.FreeBSD.ORG/pub/FreeBSD/ports/i386/packages-4-current/</ulink></para>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
  
          <para>お近くのミラーサイトもご利用下さい.</para>
  
          <para>
            新しい ports が続々と追加されている状態なので, 全ての ports に
            対応する package が存在するわけではないことを覚えておいてください.
            定期的に <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/">ftp.FreeBSD.org</ulink>
            マスターサイトを訪れて, どのような
            package が利用できるのかチェックするのも良いでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
	<question>
	  <para>なぜ <command>/bin/sh</command> はこんなに低機能なのですか?
            どうして <command>bash</command> や他のシェルを採用しないのでしょう?</para>
	</question>
        
	<answer>
	  <para>それは, POSIX がそのようなシェルがあることを規定しているからです.</para>
          
	  <para>
            もっと込み入った回答:
            多くのユーザは, 多くのシステムで同じように動作できるシェルスクリプトを書く必要があります.
            これが, POSIX でシェルやユーティリティコマンドが細く規定されている理由です.
	    ほとんどすべてのスクリプトは Bourne shell で書かれているのですが,
            それは, 数多くの重要なプログラミングインタフェイス(&man.make.1;,
	    &man.system.3;, &man.popen.3;, や Perl や Tcl 等の類似の
	    高水準スクリプト言語)が, コマンドの解釈に Bourne shell を使うからです.
            このように Bourne shell が極めて頻繁にかつ広範囲で使われているため, 
	    素早く起動できて確実に動作し, メモリを少ししか消費しないということが
	    重要になります.</para>

	  <para>
            既存の実装は,
            私たちに可能な限りこれらの多くの要求を同時に満足することができる最良のものです.
            <command>/bin/sh</command> を小さいままに保つため,
            私たちは他のシェルが持つ様々な便利な機能を提供していません.
            Ports コレクションが bash や scsh, tcsh, zsh などの
	    多機能なシェルを含んでいるからです. (これらのシェルすべての
	    メモリ使用状況は, <command>ps -u</command> の <quote>VSZ</quote> や
	    <quote>RSS</quote> の行で, あなた自身が確認することができます.)</para>
	</answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><filename>libc.so.3.0</filename> はどこにありますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD 2.1.x のシステムで 2.2/3.x/4.0 用の
            package を動かそうとしていますね. 
            前のセクションを読んで, システムに合った正しい
            port/package を入手してください.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="emul">
          <para>386/486SX のマシンで ghostscript を動かすとエラーがでます. </para>
        </question>

        <answer>
          <para>
            あなたのマシンには数値演算プロセッサが塔載されていませんね?
            カーネルにコプロセッサの代わりとなる数値演算エミュレータを追加する必要があります. 
            以下のオプションをカーネルのコンフィグレーションファイルに追加して,
            カーネルを再構築してください.
  
            <programlisting>options GPL_MATH_EMULATE</programlisting>
  
            <note>
              <para>このオプションを追加する場合, 
                <literal>MATH_EMULATE</literal>
                の行を削除してください.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>SCO/iBCS2 のアプリケーションを実行すると,
            <literal>socksys</literal> で落ちてしまいます.</para>
        </question>

        <answer>
          <para>
            まず最初に
            <filename>/etc/sysconfig</filename>(または 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">/etc/rc.conf</ulink>)の中の
            最後のセクションを編集し,
            以下の変数を <literal>YES</literal> に直します.
          </para>
  
          <programlisting># Set to YES if you want ibcs2 (SCO) emulation loaded at startup
ibcs2=NO
          </programlisting>

          <para>
            これでシステムの起動時に
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ibcs2">ibcs2</ulink>
            カーネルモジュールが読み込まるようになります.
          </para>
  
          <para>
            次に <filename>/compat/ibcs2/dev/</filename>
            を以下のように編集します.
          </para>
  
          <screen>lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 X0R@ -&gt; /dev/null
lrwxr-xr-x  1 root  wheel         7 Oct 15 22:20 nfsd@ -&gt; socksys
-rw-rw-r--  1 root  wheel         0 Oct 28 12:02 null
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 socksys@ -&gt; /dev/null
crw-rw-rw-  1 root  wheel   41,   1 Oct 15 22:14 spx</screen>
  
          <para>
            open や close の処理は,
            socksys から
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?null(4)">/dev/null</ulink>
            へシンボリックリンクを張ることで代用します. 
            残りの処理は, -CURRENT に入っているコードが担当しています. 
            これは以前のものより ずっとスッキリした方法です.
          </para>
  
          <para>
            ローカルでの X のソケット接続に <literal>spx</literal>
            ドライバを使いたいのであれば,
            システムをコンパイルする際に
            <literal>SPX_HACK</literal>
            を定義してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>INN(インターネットニュース)の設定方法は?</para>
        </question>

        <answer>
          <para>inn の package や port をインストールしたあとに
            <ulink URL="http://www.cis.ohio-state.edu/~barr/INN.html">Dave Barr's
              INN Page</ulink> を見てみましょう. 初心者向けの INN FAQ があります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どのバージョンの Microsoft FrontPage を手に入れる必要がありますか?</para>
        </question><answer>

          <para>
            ルーク, ports を使え!
            パッチ処理済みの Apache が ports ツリーから入手できます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD は Java をサポートしていますか?</para>
        </question>

        <answer>
          <para>はい.
            <ulink URL="http://www.FreeBSD.org/java/">http://www.FreeBSD.org/java/</ulink>
            をご覧ください.
            <ulink URL="../java/">日本語訳</ulink>
            もあります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>3.x-STABLE を載せているマシンで port
            がコンパイルできないことがあります. それはどうしてですか?
          </para>
        </question>

        <answer>
          <para>
            もし, その時点の -CURRENT か -STABLE
            に比べてずっと古いバージョンの FreeBSD を利用しているなら,
            <ulink URL="http://www.FreeBSD.org/ports/">http://www.FreeBSD.org/ports/</ulink>
            にある ports アップグレードキットが必要です.
            最新の FreeBSD を利用しているのに発生する場合はおそらく,
            -CURRENT では正常なのに -STABLE ではうまく動かなくなるような変更がその
            port に対して行なわれ, 受理されてしまっているのでしょう.
            ports コレクションは -CURRENT と -STABLE,
            両方のブランチで動かなければならないものですので,
            もしそれを発見したら <command>send-pr(1)</command>
            コマンドを使ってバグレポートの提出をお願いします.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><filename>ld.so</filename> はどこにありますか?</para>
        </question>

        <answer>
          <para>3.1-R 以降などの Elf 化されたマシンで Netscape Navigator などの
            aout 形式のアプリケーションを動かすときには,
            <filename>/usr/libexec/ld.so</filename> と
            aout ライブラリのファイルが必要です.
            それらは配布物の <literal>compat22</literal> に納められています.
            <filename>/stand/sysinstall</filename> や
            <filename>compat22</filename> サブディレクトリ内の
            <filename>install.sh</filename> を使って
            <literal>compat22</literal>
            をインストールしてください.
            合わせて 3.1-R と 3.2-R の ERRATA もお読みください.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
</chapter>

  <chapter id="kernelconfig">
    <title>カーネルコンフィグレーション</title>

    <para>
      <emphasis>訳:
        はらだ きろう <email>kiroh@jp.FreeBSD.org</email>,
        1997 年 11 月 10 日.
      </emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question id="make-kernel">
          <para>カーネルをカスタマイズしたいんですが, 難しいですか?</para>
        </question>

        <answer>
          <para>
            全然難しくありません.
            <ulink URL="../handbook/kernelconfig.html">カーネルの再構築</ulink>を調べてください.

          <note>
              <para>うまく動作するカーネルができたら,
                日付入りのカーネルのスナップショットを
                <filename>kernel.<replaceable>YYMMDD</replaceable></filename>
                のように作成することをおすすめします.
                こうしておけば, 次にカーネルの構築をやってうまくいかなくなってしまっても,
                <filename>kernel.GENERIC</filename> にわざわざ戻る必要がなくなります.
                これは, GENERIC カーネルでサポートされないデバイスから起動している場合は,
                特に重要です(経験者は語るってやつです).
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><literal>_hw_float</literal>
            が無いので, カーネルのコンパイルがうまくいきません.</para>
        </question>

        <answer>
          <para>
            推測ですけど, 数値演算コプロセッサを持ってないからと思って,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?npx(4)">npx0</ulink>
            をカーネルコンフィグファイルから削除しちゃったんじゃないですか?
            <literal>npx0</literal> は<emphasis>必須</emphasis>です.
            コプロセッサがなくても, <literal>npx0</literal>
            デバイスは削除してはいけません.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            マルチポートシリアルをサポートするコードを含んだカーネルをコンパイルしようとすると,
            最初のポートだけ検出され, 
            残りのポートは割り込みの競合のためスキップされたと言われます. 
            どうやったらいいでしょうか?
          </para>
        </question>

        <answer>
          <para>
            ここでの問題は, FreeBSD
            にはハードウェアまたはソフトウェアの競合により,
            カーネルがクラッシュするのを防ぐコードが含まれているという点です.
            解決するには, 最初のポートにだけ IRQ の設定を書き,
            残りは IRQ の設定を削除します. 
            以下に例を示します.
          </para>
  
          <programlisting># Multiport high-speed serial line - 16550 UARTS
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr</programlisting>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>QIC-40/80 ドライブのサポートを有効にするには?</para>
        </question>

        <answer>
          <para>GENERIC
            コンフィグファイルの以下の行のコメントを外してください(もしくは使用するコンフィグファイルに追加してください).
            そして
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?fdc(4)">fdc</ulink> の行に,
            &ldquo;<literal>flags 0x1</literal>&rdquo; を追加してください.
          </para>
  
          <programlisting>
controller  fdc0  at isa? port "IO_FD1" bio irq 6 drq 2 flags 0x1 vector fdintr
disk        fd0   at fdc0 drive 0                       ^^^^^^^^^
disk        fd1   at fdc0 drive 1
#tape       ft0   at fdc0 drive 2
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</programlisting>
  
          <para>
            次に, <filename>/dev/ft0</filename> デバイスを作成します.
            <filename>/dev/</filename> 
            に移動して, 以下のコマンドを実行します.
          </para>
  
          <screen>&prompt.root; <userinput><command>sh</command> ./MAKEDEV ft0</userinput></screen>
  
          <para>
            これは, 1 番目のドライブの例です.
            2 番目には <filename>ft1</filename>
            を使い, 
            以降は同様にしてください.
          </para>
  
          <para>
            <filename>/dev/ft0</filename> デバイスは,
            &ldquo;<command>ft</command>&rdquo;
            と呼ばれる特別なコマンドを使用して書き込みをおこなえます.
            詳細については 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ft">ft</ulink> 
            のマニュアルページを参照してください.
          </para>
  
          <para>
            -CURRENT 以前のバージョンの <command>ft</command> には, 
            不良テープメディアの扱いに問題があります.
            <command>ft</command>
            がテープの同じ部分を行ったり来たりしているようであれば, 
            -CURRENT の
            <filename>/usr/src/sbin/ft</filename>
            から最新の <filename>ft</filename>
            を取得して試してみてください.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="admin">
    <title>システム管理</title>

    <para>
      <emphasis>訳:
        にしか <email>nishika@cheerful.com</email>,
        1997 年 11 月 12 日.</emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>システムスタートアップファイルはどこにあるのですか?</para>
        </question>

        <answer>
          <para>
            FreeBSD 2.0.5R から 2.2.1R までは,
            プライマリコンフィグレーションファイルは
            <filename>/etc/sysconfig</filename> にあります.
            オプションはすべて, このファイルと
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc">/etc/rc</ulink> および
            <filename>/etc/netstart</filename>といった, 
            別のファイルに指定されています.
          </para>
  
          <para>
            ファイル <filename>/etc/sysconfig</filename>
            を見て, システムに適合するように変更してください.
            このファイルには,
            それぞれの場所に何を書けばいいのかを表すコメントがたくさん書かれています.
          </para>
  
          <para>
            FreeBSD 2.2.2 に続くリリース と 3.0 では,
            <filename>/etc/sysconfig</filename> は, 
            より分りやすい名前の
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">rc.conf</ulink>
            に改名され, それに従って書式もいくぶん改められています.
            <filename>/etc/netstart</filename> も
            <filename>/etc/rc.network</filename> に改名され,
            全部のファイルを
            <command><ulink URL="http://www.FreeBSD.org/cgi/man.cgi?cp">cp</ulink> /usr/src/etc/rc* /etc</command> で一度にコピーすることが出来るようになります.
          </para>
  
          <para>
            ファイル <filename>/etc/rc.local</filename> は常にここにあり,
            <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?inn">INN</ulink>
            や
            http といった追加のサービス開始や,
            カスタムオプションを記述するために使われるでしょう.
          </para>
  
          <para>
            ファイル <filename>/etc/rc.serial</filename>
            はシリアルポートの初期化(例えばポートの設定を固定したり等々)のためにあります.
          </para>
  
          <para>
            ファイル <filename>/etc/rc.i386</filename> は iBCS2
            エミュレーションのような
            Intel アーキテクチャ固有の設定や,
            PC システムコンソール設定のためにあります.
          </para>
  
          <para>
            FreeBSD 2.1.0R からは,
            「ローカル」スタートアップファイルをディレクトリ 
            <filename>/etc/sysconfig</filename>(または
            <filename>/etc/rc.conf</filename>)の中に作って指定することもできます.
          </para>
  
          <programlisting># Location of local startup files.
local_startup=/usr/local/etc/rc.local.d</programlisting>
  
          <para>
            <filename>.sh</filename>
            で終わるそれぞれのファイルは, アルファベット順に実行されます.
          </para>
  
          <para>
            ファイル名を変えることなくある一定の順序で確実に実行したいのであれば, 
            順序が保証されるよう,
            以下のようにしてそれぞれのファイルの頭に数値をつけるようなデザインを
            使うことができます.
  
          <programlisting>
10news.sh
15httpd.sh
20ssh.sh</programlisting> 
          </para>
 
          <para>
            この方法は見苦しく (あるいは SysV のように :-)) なりますが, 
            <filename>/etc/rc.local</filename>
            を手品のような編集でソートするようなことなくローカルの追加パッケージを使うためには,
            シンプルでしかもよく使われる手法ではあります.
            ほとんどの ports/packages は 
            <filename>/usr/local/etc/rc.d</filename>
            をローカルスタートアップディレクトリであると仮定しています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>簡単にユーザを追加するにはどうすればいいのですか?</para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?adduser">adduser</ulink>
            コマンドを使用してください. 
            また, <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?pw">pw</ulink>
            コマンドを用いることで, さらに細かい操作が可能です.
          </para>
  
          <para>
            ユーザを削除するには <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rmuser">rmuser</ulink>
            コマンドを使用してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD システムに新しいハードディスクを追加するには?</para>
        </question>

        <answer>
          <para><ulink URL="../../tutorials/formatting-media/">www.FreeBSD.org</ulink>
            に書かれているディスクフォーマットチュートリアルを参照して下さい.</para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>新しいリムーバブルドライブを持っていますが, どうやって使うの?</para>
        </question>
        <answer>

          <para>
            そのリムーバブルドライブが ZIP であれ EZ drive であれ 
            (あるいはもしそういう風に使いたいのなら, フロッピーであれ), 
            またハードディスクであれ, 一旦システムにインストールされて認識され, 
            カートリッジ, フロッピー等々が挿入されていれば, 
            ことはどのデバイスでも全く同じように進みます.
          </para>
  
          <para><anchor id="disklabel">
              (このセクションは<ulink URL="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html">Mark Mayo's ZIP FAQ</ulink> に基づいています.)
          </para>
  
          <para>
            ZIP ドライブやフロッピーで, すでに DOS のファイルシステムで
            フォーマットしてある場合, 次のコマンドを使うことができます. 
            これはフロッピーの場合です.
          </para>

          <screen>&prompt.root; <userinput><command>mount</command> -t msdos /dev/fd0c /floppy</userinput></screen>
  
          <para>出荷時の設定の ZIP ディスクではこうです. </para>
  
          <screen>&prompt.root; <userinput><command>mount</command> -t msdos /dev/da2s4 /zip</userinput></screen>
  
          <para>
            その他のディスクに関しては,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?fdisk">fdisk</ulink>
            や
            <filename>/stand/sysinstall</filename> を使って,
            どのようにレイアウトされているか確かめてください.
          </para>
  
          <para>
            以降は ZIP ドライブが 3 番目の SCSI ディスクで, 
            da2 と認識されている場合の例です.
          </para>
  
          <para>
            他人と共有しなければならないフロッピーやリムーバブルディスク
            でなければ, BSD ファイルシステムを載せてしまうのが良い考えでしょう. 
            ロングファイル名もサポートされ, パフォーマンスは少なくとも 
            2 倍は向上しますし, おまけにずっと安定しています. 
            まず最初に, DOS レベルでのパーティション <filename>/</filename>
            ファイルシステムを無効にしておく必要があります. 使用するのは
            <command>fdisk</command> でも
            <filename>/stand/sysinstall</filename> でも結構です. 
            複数のオペレーティングシステムを入れることを考慮する
            必要がないような容量の小さなドライブの場合は, 
            次のように <acronym>FAT</acronym> パーティションテーブル (スライス) 
            全体を飛ばして, BSD
            のパーティション設定を行うだけで良いでしょう.
          </para>
              
          <screen>&prompt.root; <userinput><command>dd</command> if=/dev/zero of=/dev/rda2 count=2</userinput>
&prompt.root; <userinput><command>disklabel</command> -Brw da2 auto</userinput></screen>
  
          <para>
            複数の BSD パーティションをつくる場合,
            <command>disklabel</command> か
            <filename>/stand/sysinstall</filename> を使います.
            固定ディスク上にスワップ領域を加える場合,
            そういうことをしたいと思うのはもっともですが, 
            ZIP のようなリムーバブルドライブの上ではそういう考えは不適切
            でしょう.
          </para>
  
          <para>
            最後に, 新しいファイルシステムをつくります. ディスク全体を使用する
            ZIP ドライブの場合は, 以下のようにします.
          </para>
  
          <screen>&prompt.root; <userinput><command>newfs</command> /dev/rda2c</userinput></screen>

          <para>次にマウントします. </para>
  
          <screen>&prompt.root; <userinput><command>mount</command> /dev/da2c /zip</userinput></screen>
  
          <para>また, 次のような行を
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?fstab">/etc/fstab</ulink>
            に入れておくのも良い考えでしょう. 
            &ldquo;<command>mount /zip</command>&rdquo;
            と入力するだけでマウントできるようになります.
          </para>
  
          <programlisting>/dev/da2c /zip ffs rw,noauto 0 0</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どのようにしたら DOS の拡張パーティションをマウントできますか?</para>
        </question>

        <answer>
          <para>
            DOS 拡張パーティションは,
            すべての基本パーティションの後に認識されます.
            たとえば, 2台目の SCSIドライブの拡張パーティションに
            &ldquo;E&rdquo;
            パーティションがあるとしますと,
            これは <filename>/dev</filename>
            にスライス 5 のスペシャルファイルを作る必要があり,
            <filename>/dev/da1s5</filename>
            としてマウントされます.
          </para>
  
          <screen>&prompt.root; <userinput><command>cd</command> /dev</userinput>
&prompt.root; <userinput><command>./MAKEDEV</command> da1s5</userinput>
&prompt.root; <userinput><command>mount</command> -t msdos /dev/da1s5 /dos/e</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</para>
        </question>

        <answer>
          <para>
            <emphasis>Digital UNIX:</emphasis>
            UFS CDROM は直接 FreeBSD でマウントすることができます.
            Digital UNIX やそれ以外のシステムのサポートする
            UFS のディスクパーティションをマウントすることはもっと複雑なことで,
            オペレーティングシステムのディスクパーティションの詳細に依存します.
          </para>
  
          <para>
            <emphasis>Linux:</emphasis>
            2.2 以降は ext2fs パーティションをサポートします. 
            マニュアルの
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?mount_ext2fs">mount_ext2fs</ulink>
            を見てください. より多くの情報があります.
          </para>
  
          <para>
            <emphasis>NT:</emphasis>
            FreeBSD 用の読みだしのみ可能な NTFS ドライバがあります.
            詳しくは, Mark Ovens 氏によって書かれたチュートリアル
            <ulink URL="http://ukug.uk.freebsd.org/~mark/ntfs_install.html">http://ukug.uk.freebsd.org/~mark/ntfs_install.html</ulink>
            をご覧下さい.
          </para>
  
          <para>
            この問題について他の情報があれば, 他の人から感謝されるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どのようにしたら FreeBSD を NT ローダーからブートさせることができますか?</para>
        </question>

        <answer>
          <para>
            この手順は 2.2.x と(起動が 3 つのステージに分かれている)3.x
            のシステムとで多少異なります.
          </para>

          <para>
            FreeBSD のネイティブルートパーティションの最初のセクタをファイルにして
            DOS/NT パーティション上に置くという画期的なアイディアがあります. 
            ファイル名を
            <filename>c:\bootsect.bsd</filename>(<filename>c:\bootsect.dos</filename>
            からの発想です)としたとします.
            <filename>c:\boot.ini</filename>ファイルを次のように編集します.
          </para>

          <programlisting>[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="FreeBSD"
C:\="DOS"</programlisting>
  
          <para>
            この手順は, 利用しているシステムが 2.2.x であり, DOS, NT, FreeBSD
            あるいはその他のオペレーティングシステムがすべて,
            <emphasis>同じ</emphasis>ディスクのそれぞれの
            fdisk
            パーティションにインストールされていることを想定しています.
            私の場合は, DOS と NT は最初のパーティション, FreeBSDは 2番目にあります. 
            また, FreeBSD は <acronym>MBR</acronym>
            を<emphasis>使わずに</emphasis>,
            ネイティブパーティションからブートするようにインストールしてあります. 
            (訳注: FreeBSD のインストールではブートマネジャを使わずに標準 
            <acronym>MBR</acronym> を使う場合に相当します)
          </para>
  
          <para>
            (もし NTFS に変換してしまっているなら)DOS
            フォーマットのフロッピーディスクか FAT
            パーティションを <filename>/mnt</filename> に DOS
            マウントします.
          </para>
  
          <screen>&prompt.root; <userinput><command>dd</command> if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1</userinput></screen>
          
          <para>
            リブートして DOS か NT に切替えます. NTFS ユーザは 
            <filename>bootsect.bsd</filename> や
            <filename>bootsect.lnx</filename> をフロッピーディスクから
            <filename>C:\</filename>
            へコピーします.
            <filename>boot.ini</filename>
            のファイル属性(パーミッション)の変更を以下のようにおこないます.
          </para>
  
          <screen><prompt>&gt;</prompt> <userinput><command>attrib</command> +s +r c:\boot.ini</userinput></screen>
  
          <para>
            上の例の
            <filename>boot.ini</filename> で示したような正しいエントリを加え, 
            ファイル属性を元に戻します.
          </para>
  
          <screen><prompt>&gt;</prompt> <userinput><command>attrib</command> -r -s c:\boot.ini</userinput></screen>
  
          <para>
            FreeBSD が MBR からブートするようになっている場合, 
            それぞれのネイティブパーティションからブートするように設定した後で, 
            DOS から &ldquo;<command>fdisk</command>&rdquo;
            コマンドを実行して元に戻してください.
          </para>

          <para>
            FreeBSD 3.X における手順は, これよりいくぶん簡単です.
          </para>

          <para>
            FreeBSD が NT ブートパーティションとして同じディスクにインストールされている場合には,
            <filename>/boot/boot1</filename> を
            <filename>c:\bootsect.bsd</filename> へコピーします.
            もし FreeBSD が異なったディスクにインストールされている場合には,
            <filename>/boot/boot0</filename> を
            <filename>c:\bootsect.bsd</filename>
            へコピーして, 先に述べたように
            <filename>c:\bootsect.ini</filename> を編集してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD と Linux を LILO からブートするには?</para>
        </question>

        <answer>
          <para>
            FreeBSD と Linux が同じディスクにインストールされている場合,
            単に Linux 以外の OS をブートするための LILO のインストール手順に
            従えばいいだけです. 非常に簡単にではありますが, 記してみましょう.
          </para>
  
          <para>
            Linux をブートし, <filename>/etc/lilo.conf</filename>
            に以下の行を加えて
            ください.

            <programlisting>other=/dev/hda2
table=/dev/hda
label=FreeBSD</programlisting>

            (上記の手順は FreeBSD のスライスが Linux から
            <filename>/dev/hda2</filename>
            という名前で見えていると仮定しています.
            あなたの設定にあわせてください)

            その後, <command>lilo</command> を
            <username>root</username>
            で実行すれば完了です.
          </para>
  
          <para>
            FreeBSD が別のディスクにインストールされているのなら,
            LILO のエントリに
            &ldquo;<literal>loader=/boot/chain.b</literal>&rdquo;
            を追加してください. 例えば, このようになります.

            <programlisting>other=/dev/dab4
table=/dev/dab
loader=/boot/chain.b
label=FreeBSD</programlisting>
          </para>
  
          <para>
            場合によっては, 二つ目のディスクを正しく起動するために FreeBSD
            ブートローダに BIOS ドライブ番号を指定する必要があるかもしれません.
            例えば, FreeBSD SCSI ディスクが BIOS によって
            BIOS ディスク 1 として認識されるのなら,
            FreeBSD のブートローダのプロンプトで, 次のように指定する必要があります.

            <screen><prompt>Boot:</prompt> <userinput>1:da(0,a)/kernel</userinput></screen>
          </para>
  
          <para>
            FreeBSD 2.2.5 やそれ以降の版では,
            ブート時に上記のことを行なう
            だけで自動的に
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?boot(8)">boot(8)</ulink>
            が設定されます.
          </para>
  
          <para>
            <ulink URL="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html">Linux+FreeBSD
              mini-HOWTO</ulink> が FreeBSD と Linux
            とを相互に使えるようにするためのよい参考資料になるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD と Linux を BootEasy からブートするには?</para>
        </question>

        <answer>
          <para>
            LILO をマスターブートレコード(MBR)ではなく
            Linux のブートパーティションにインストールしてください.
            これで BootEasy から
            LILO をブートできるようになります.
          </para>
  
          <para>
            Windows95 と Linux を使用している場合は,
            いずれにせよ後者の方がおすすめです.
            Windows95 を再インストールする必要にかられたとき, 
            Linux をブート可能に戻す手続きが簡単ですむからです
            (Windows95 は偏屈なオペレーティングシステムで,
            マスターブートレコード(MBR)から他のオペレーティングシステムを追い払ってしまうのです).
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>「危険覚悟の専用(dangerously dedicated)ディスク」は健康に悪いの?</para>
        </question>

        <answer>
          <para><anchor id="dedicate">
              インストール作業中,
              ハードディスクのパーティションを切る際に
              2 つの方法を選ぶことができます.
              デフォルトの方法では, fdisk のテーブルエントリ(FreeBSD
              ではスライスと呼ばれる) を使って, 
              自身のパーティションを使用する FreeBSD のスライスを,
              同じマシンの他のオペレーティングシステムと互換性のある形にします. 
              それに付随して, ブートセレクタをインストールすれば,
              ディスク上の使用可能なオペレーティングシステムを切り替えることができます. 
              もう一つの方法はディスク全てを FreeBSD で使うというもので,
              この場合ほかのオペレーティングシステムとの互換性を考慮しないことになります.
          </para>
  
          <para>
            では, なぜこれが 「危険覚悟の」と言われるのでしょう?
            このモードのディスクが, 通常の PC のユーティリティが有効な fdisk
            テーブルと見なす情報を持っていないからです.
            ユーティリティの出来如何によりますが,
            そのようなディスクを発見したとき,
            警告を出すものもあります. また, もっと悪い場合,
            確認も通告もなしに
            BSD のブートストラップにダメージを与えるものもあるでしょう. 
            さらには, 「危険覚悟の」ディスクレイアウトは多数の BIOS,
            AWARD(例えば HP Netserver や Micronics システム,
            他多数で使用されていた)や
            Symbios/NCR(人気のあるSCSI コントローラ 53C8xx
            用)などを混乱させることが分かっています.
            これは完全なリストではありません.
            他にもまだまだあります. この混乱の兆候は,
            起動時にシステムがロックするというだけでなく,
            FreeBSD のブートストラップが自分自身を見つけられないために表示する
            &ldquo;<computeroutput>read error</computeroutput>&rdquo;
            というメッセージなどにも現れることでしょう.
          </para>
  
          <para>
            そもそもいったいなぜこのモードがあるのでしょうか?
            これはわずかに数キロバイトのディスク容量を節約するのみであり,
            新規インストールで実際に問題を生ずるのです.
            「危険覚悟の」モードの起源は新しい FreeBSD インストーラでの,
            BIOS から見えるディスクの
            「ジオメトリ」の値とディスク自身との整合性という,
            もっとも一般的な問題のひとつを回避したいという要求が背景にあります.
          </para>
  
          <para>
            「ジオメトリ」は時代遅れの概念ですが,
            未だに PC BIOS とディスクへの相互作用の中核をなしています.
            FreeBSD のインストーラがスライスを作る時,
            ディスク上のスライスを BIOS が見つけられるように,
            スライス位置をディスク上に記録します. それが誤っていれば,
            起動できなくなってしまうでしょう.
          </para>
          
          <para>
            「危険覚悟の」モードはこれを,
            問題を単純にすることで回避しようとします.
            状況によってはこれでうまくいきます. 
            しかし次善の策として使われているに過ぎません.
            この問題を解決するもっと良い方法はいくらでもあるのです.
          </para>
          
          <para>
            では,
            インストール時に「危険覚悟の専用」モードが必要になる
            状況を回避するにはどうすればよいのでしょうか? 
            まず BIOS が報告するディスクのジオメトリの値を覚えておくことからはじめましょう.
            &ldquo;boot:&rdquo;
            プロンプトで &ldquo;<option>-v</option>&rdquo;
            を指定するか, ローダで
            &ldquo;boot -v&rdquo;
            と指定して,
            ブート時にカーネルにこの値を表示させることができます.
            インストーラが起動する直前に, 
            カーネルがジオメトリ値のリストを表示するでしょう. 
            パニックを起こさないでください.
            インストーラが起動するのを待ち, 
            逆スクロールでさかのぼって値を確認してください.
            普通は BIOS 
            ディスクユニット番号は,
            FreeBSD がディスクを検出する順序と同様であり, 
            最初に IDE, 次に SCSI となります.
          </para>
          
          <para>
            ディスクをスライシングする際に,
            FDISK の画面で表示されるディスクのジオメトリが正しいこと(BIOS
            の返す値と一致しているか)を確認してください.
            万一異なっていたら &ldquo;<userinput>g</userinput>&rdquo;
            を押して修正してください.
            ディスクにまったくなにもない場合や,
            他のシステムから持ってきたディスクの場合は
            これをおこなう必要があるかもしれません.
            これはそのディスクから起動させようとしている場合にのみ,
            問題になることに注意してください. 
            FreeBSD はそのディスクをうまい具合いに他のディスクと区別してくれます.
          </para>
          
          <para>
            ディスクのジオメトリについて BIOS と FreeBSD
            間で一致させることができたら, この問題はほぼ解決したと思ってよいでしょう. 
            そしてもはや「危険覚悟の専用」モードは必要ありません. 
            しかし, まだブート時に恐怖の
            &ldquo;<computeroutput>read error</computeroutput>&rdquo;
            メッセージが出るようであれば,
            お祈りを捧げて新しいディスクを買いましょう. 
            もう失うものは何もありません.
          </para>
          
          <para>
            「危険覚悟の専用ディスク」を通常の PC
            での使用法に戻すには,
            原則として 2 つ方法があります. 1 つは十分な NULL 
            バイトを MBR に書き込んで,
            きたるべきインストーラにディスクはまっさらだと思い込ませる方法です.
            例えば, こんな感じです.
            
            <screen>&prompt.root; <userinput><command>dd</command> if=/dev/zero of=/dev/rda0 count=15</userinput></screen>
          </para>
          
          <para>
            また, マニュアルには書かれていない DOS の「機能」
            
            <screen><prompt>&gt;</prompt> <userinput><command>fdisk</command> /mbr</userinput></screen>
            
              は, BSD ブートストラップを追い払ってくれる上に, 
            新しいマスターブートレコードをインストールしてくれます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どのようにしたらスワップ領域を増やせますか?</para>
        </question>

        <answer>
          <para>
            スワップパーティションのサイズを増やすのが最良の方法ですが, 
            別のディスクを追加しなくて済むという利点のある方法があります. 
            経験から得た一般的な方法はメインメモリの 2倍程度のスワップ領域を
            とるというものです. しかしごく小さなメインメモリしかない場合は, 
            それ以上のスワップを構成したいと思うでしょう. また, 将来のメモリの
            アップグレードに備え, 後でスワップの構成を変更する必要がないように
            十分なスワップを構成しておくことは良い考えです.
          </para>
          
          <para>
            スワップを別のディスク上に追加することは, 単純に同じディスク上
            にスワップを追加する場合よりも高速に動作するようになります. 
            例に挙げれば, あるディスク上のソースをコンパイルしているとして, 
            スワップが別のディスク上に作られていれば, これらが同じディスク上
            にある場合よりも断然速いです. SCSI ディスクの場合は特にそうだと言えます.
          </para>
  
          <para>
            ディスクが複数ある場合, スワップパーティションを各ディスクに
            作るように構成すると, 使用中のディスク上にスワップを置いたとしても,
            通常の場合は有益です. 一般的に, システムにある高速なディスクには
            スワップを作るようにすべきでしょう. 
            FreeBSD はデフォルトでインターリーブなスワップデバイスを 4つまで
            サポートします. 複数のスワップパーティションを構成する際に, 
            普通はそれらを大体同じくらいの大きさにして作りたいところですが, 
            カーネルのコアダンプを取るのに都合が良いようにメインの
            スワップパーティションを大きめにとる人もいます. 
            メインのスワップパーティションはカーネルのコアがとれるように
            最低でも実メモリと同じ大きさにすべきでしょう.
          </para>
  
          <para>
            IDE ドライブは同時に同じチャネル上の複数のドライブには
            アクセスできません (FreeBSD は mode 4 をサポートしていないので, 
            すべての IDE ディスク I/O は &ldquo;programmed&rdquo; です). 
            IDE の場合であってもやはり, スワップを別のハードディスク上に
            作成することをおすすめします. 
            ドライブは実に安いものです, 心配するだけ無駄です.
          </para>
          
          <para>
            NFS 越しにスワッピングさせる方法は,
            スワップ用のローカルディスクが無い場合にのみ推奨されます. 
            NFS 越しのスワッピングは遅く, FreeBSD 4.x より前のリリースでは
            効率が悪いのですが, 4.0 以降ではそれなりに高速になります. 
            そうはいっても, 利用できるネットワークの太さに制限されますし, 
            NFS サーバに余計な負荷がかかります.
          </para>
  
          <para>
            これは 64MBの vn-swap を作る例です(ここでは
            <filename>/usr/swap0</filename> 
            としますが, もちろん好きな名前を使うことができます).
          </para>
  
          <para>
            カーネルが次の行を含むコンフィグファイルから構成されているかを
            確認します. GENERIC カーネルには, この行が含まれています.
          </para>
  
          <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
  
          <para>
            <orderedlist>
              <listitem>
                <para>vn デバイスを作ります
                  <screen>&prompt.root; <userinput><command>cd</command> /dev</userinput>
&prompt.root; <userinput><command>sh</command> ./MAKEDEV vn0</userinput></screen>
                </para>
              </listitem>

              <listitem>
                <para>スワップファイルを作ります(<filename>/usr/swap0</filename>)
                  <screen>&prompt.root; <userinput><command>dd</command> if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
                </para>
              </listitem>

              <listitem>
                <para><filename>/etc/rc.conf</filename> でスワップファイルを有効化させます

                  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
                </para>
              </listitem>

              <listitem>
                <para>マシンをリブートします</para>
              </listitem>
            </orderedlist>
          </para>
  
          <para>
            スワップファイルをすぐに有効化させたいのなら以下のようにタイプします.

            <screen>&prompt.root; <userinput><command>vnconfig</command> -ce /dev/vn0c /usr/swap0 swap</userinput></screen>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>プリンタのセットアップで問題があります</para>
        </question>

        <answer>
          <para>ハンドブックのプリンタの部分を参照してください. 
            探している問題のほとんどが書かれているはずです. 
            <ulink URL="../handbook/printing.html">FreeBSD
              ハンドブックの「プリンタの利用」</ulink>をご覧ください.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私のシステムのキーボードマッピングは間違っています.</para>
        </question>

        <answer>
          <para>
            <command>kbdcontrol</command> プログラムは,
            キーボードマップファイルを読み込むためのオプションを備えています. 
            <filename>/usr/share/syscons/keymaps</filename>
            の下にたくさんのマップファイルがあります. 
            システムに関連のあるものを一つ選んで, ロードしてください.
          </para>
  
          <screen>&prompt.root; <userinput><command>kbdcontrol</command> -l uk.iso</userinput></screen>
  
          <para>
            <filename>/usr/share/syscons/keymaps</filename>
            と拡張子 
            <filename>.kbd</filename> は, どちらも
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?kbdcontrol">kbdcontrol</ulink>
            によって使用されます.
          </para>
  
          <para>
            これは <filename>/etc/sysconfig</filename>(または
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">rc.conf</ulink>)
            中で設定することができます. 
            このファイル中にあるそれぞれのコメントを参照してください.
          </para>
  
          <para>
            FreeBSD 2.0.5R
            やそれ以降の版では,
            テキストフォントやキーボードマッピングに関係のあるものはすべて,
            <filename>/usr/share/examples/syscons</filename> 
            の中におさめられています. 
          </para>
  
          <para>現在以下のマッピングがサポートされています.</para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>Belgian ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>Brazilian 275 keyboard Codepage 850 </para>
              </listitem>
              
              <listitem>
                <para>Brazilian 275 keyboard ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>Danish Codepage 865 </para>
              </listitem>
              
              <listitem>
                <para>Danish ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>French ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>German Codepage 850 </para>
              </listitem>
              
              <listitem>
                <para>German ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>Italian ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>Japanese 106 </para>
              </listitem>
              
              <listitem>
                <para>Japanese 106x </para>
              </listitem>
              
              <listitem>
                <para>Latin American </para>
              </listitem>
              
              <listitem>
                <para>Norwegian ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>Polish ISO-8859-2 (programmer's) </para>
              </listitem>
              
              <listitem>
                <para>Russian Codepage 866 (alternative) </para>
              </listitem>
              
              <listitem>
                <para>Russian koi8-r (shift) </para>
              </listitem>
              
              <listitem>
                <para>Russian koi8-r </para>
              </listitem>
              
              <listitem>
                <para>Spanish ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>Swedish Codepage 850 </para>
              </listitem>
              
              <listitem>
                <para>Swedish ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>Swiss-German ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>United Kingdom Codepage 850 </para>
              </listitem>

              <listitem>
                <para>United Kingdom ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>United States of America ISO-8859-1 </para>
              </listitem>
              
              <listitem>
                <para>United States of America dvorak </para>
              </listitem>
              
              <listitem>
                <para>United States of America dvorakx </para>
              </listitem>
              
            </itemizedlist>
          </para>
        </answer>
      </qandaentry>
      
      <qandaentry>
        <question>
          <para>ユーザディスククォータが正常に動作していないようです. </para>
        </question>

        <answer>
          <para>
            <orderedlist>              
              <listitem>
                <para>&ldquo;<filename>/</filename>&rdquo;
                  にはディスククォータを設定しないでください.</para>
              </listitem>

              <listitem>
                <para>
                  クォータファイルが置かれるファイルシステム上に
                  クォータファイルを置くようにしてください.
                  <programlisting>
FS      QUOTA FILE
/usr    /usr/admin/quotas
/home   /home/admin/quotas
...</programlisting>
                </para>
              </listitem>
            </orderedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>わたしの ccd は,
            何が適合していない(Inappropriate)のでしょう?</para>
        </question>

        <answer>
          <para>次のような症状が現れます.</para>
  
          <screen>&prompt.root; <userinput><command>ccdconfig</command> -C</userinput>
<computeroutput>ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format</computeroutput>
&prompt.root;</screen>
  
          <para>
            通常この現象はタイプを「未使用 (unused)」のまま放っておかれた
            &ldquo;c&rdquo;
            パーティションをつなげようとした場合に現れます. ccd ドライバは
            <literal>FS_BSDFFS</literal>
            タイプをベースとするパーティションを要求します. 
            つなげようとしているディスクのディスクラベルを編集して, 
            パーティションのタイプを &ldquo;<literal>4.2BSD</literal>&rdquo;
            に変更してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</para>
        </question>

        <answer>
          <para>次のような症状が現れます.</para>
  
          <screen>&prompt.root; <userinput><command>disklabel</command> ccd0</userinput>
        (it prints something sensible here, so let's try to edit it)
&prompt.root; <userinput><command>disklabel</command> -e ccd0</userinput>
        (edit, save, quit)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
&prompt.root;</screen>
  
          <para>
            これは ccd から返されるディスクラベルが,
            実はディスク上にはないまったくの偽の情報だからです.
            これを明示的に書き直すことで問題を解消できます,
            それには, つぎのようにします.
          </para>
  
          <screen>&prompt.root; <userinput><command>disklabel</command> ccd0 &gt; /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput><command>disklabel</command> -Rr ccd0 /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput><command>disklabel</command> -e ccd0</userinput>
        (this will work now)</screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD は System V の IPC プリミティブをサポートしますか?</para>
        </question>

        <answer>
          <para>
            はい.
            FreeBSD は System-V スタイルの IPC をサポートします. 
            共有メモリ, メッセージ, セマフォが含まれます.
            以下の行をカーネルコンフィグファイルに加えると,
            サポートが有効になります.
          </para>
  
          <programlisting>options    SYSVSHM
options    "SHMMAXPGS=64"   # 256Kb of sharable memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging</programlisting>

          <para>
            カーネルを再構築してインストールしてください.
  
            <note>
              <para>GIMP を実行したい場合は, <literal>SHMMAXPGS</literal>
                を 4096(16M) 
                くらい馬鹿でかい数字に増やす必要があります.
                X11R6 の共有メモリは 
                256KB
                で十分です.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="uucpmail">
          <para>UUCP でメールを配送するには sendmail をどう使えばよいのですか?</para>
        </question>

        <answer>
          <para>
            FreeBSD に付属している sendmail は,
            インターネットに直接つながっているサイトにあわせて設定してあります.
            UUCP 経由で mail を交換したい場合には sendmail
            の設定ファイルを改めてインストールしなければなりません.
          </para>
  
          <para>
            <filename>/etc/sendmail.cf</filename>
            を自分の手で改造するのは純粋主義者のやるような事です.
            sendmail の version 8 は <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?m4">m4</ulink>
            のようなプリプロセッサを通して設定ファイルを生成する新しいアプローチを取っており,
            より抽象化されたレベルの設定ファイルを編集します. 
            <filename>/usr/src/usr.sbin/sendmail/cf</filename>
            ディレクトリの中にある設定ファイルを使用してください. 
          </para>
  
          <para>
            もしすべてのソースをインストールしていない場合には sendmail 
            の設定ツールは, 別の tar ファイルにまとめてあります. CD-ROM が 
            mount されている場合には, 次のようにしてください.
          </para>
  

	  <screen>&prompt.root; <userinput>cd /cdrom/src</userinput>
&prompt.root; <userinput>cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</userinput></screen>

          <para>
            これはたった数 100Kbyte ですから心配ないでしょう.
            <filename>cf</filename> 
            ディレクトリにある <filename>README</filename>
            に, m4 での設定の基本的な説明があります.
          </para>
  
          <para>
            UUCP での配送のためには, <literal>mailertable</literal> を使用すれば
            よいでしょう. これによって, sendmail
            が配送方式を決定するデータベースを
            作成することができます.
          </para>
  
          <para>まずはじめに,
            <filename>.mc</filename> ファイルを作成しなければなりません. 
            <filename>/usr/src/usr.sbin/sendmail/cf/cf</filename> というディレクトリが, 
            これらのファイルを作成する場所です. 既にいくつか例があると思います. 
            これから作成するファイルの名前を <filename>foo.mc</filename> とすると, 
            <filename>sendmail.cf</filename> を求めているような形式に変換するには, 
            次のようにしてください. </para>
  
          <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/sendmail/cf/cf</userinput>
&prompt.root; <userinput>make foo.cf</userinput>
&prompt.root; <userinput>cp foo.cf /etc/sendmail.cf</userinput></screen>
  
          <para>
            標準的な
            <filename>.mc</filename> ファイルは次のようになります.
          </para>
  
          <programlisting>include(`../m4/cf.m4')
VERSIONID(`<replaceable>Your version number</replaceable>')
OSTYPE(bsd4.4)
 
FEATURE(nodns)
FEATURE(nocanonify)
FEATURE(mailertable)

define(`UUCP_RELAY', <replaceable>your.uucp.relay</replaceable>)
define(`UUCP_MAX_SIZE', 200000)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <replaceable>your.alias.host.name</replaceable>
Cw    <replaceable>youruucpnodename.UUCP</replaceable></programlisting>

          <para>
            <literal>nodns</literal> と
            <literal>nocanonify</literal> という指定をすることで, 
            mail の配送に DNS を使用しなくなります.
            <symbol>UUCP_RELAY</symbol> という
            行に関しては,
            ある理由から必要ですがそれは聞かないでください. 
            .UUCP で終わる仮想ドメインを処理することのできるインターネット上での
            ホスト名をここに書いてください. 通常は, ISP の mail リレーホストを
            書くことになると思います.
          </para>
  
          <para>
            これが終了したら, 次に
            <filename>/etc/mailertable</filename>
            というファイルが必要です. 標準的な例は次のとおりです.
          </para>
  
<programlisting>#
# makemap hash /etc/mailertable.db &lt; /etc/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:</programlisting>

  
          <para>
            見れば分かるように, これは実在する設定のファイルです. はじめの
            3 行はドメイン名で指定されたメールが default の経路で配送されずに, 
            「近道」するために UUCP で隣りのサイトに送るための特別な状況を
            処理するものです. 
            次の行は Ethernet でつながっているローカルのドメインに対しては 
            SMTP で送るための設定です. 
            最後に, UUCP での隣りのサイトが. UUCP で終わる仮想ドメインの書式で
            指定されており, default の rule を
            &ldquo;<literal>uucp-neighbour!recipient</literal>&rdquo; 
            で上書きするためのものです. 一番最後の行はいつもドットを一つ書きます. 
            これは, ここまでの行でマッチしなかったすべてのホストにマッチし, 
            このサイトから世界に向けて出ていくための mail gateway に UUCP 
            で配送するためのものです. 
            <literal>uucp-dom:</literal> に続けて書かれているノード名は, 
            <literal>uuname</literal> コマンドで指定することによって UUCP 
            で直接配送される正しいノード名でなければなりません.
          </para>
  
          <para>
            最後に, このファイルは使用する前に DBM データベースのファイルに
            変換する必要があります. これをおこなうコマンドラインは mailertable
            の最初のコメントに書いてあります. mailertable を変更した時には, 
            必ずこのコマンドを実行してください.
          </para>
  
          <para>
            最後のヒントです: もし特定のメール配送がうまく作動するかどうか
            確かめたい場合には, sendmail の<option>-bt</option> オプションを
            使用してください. このオプションによって sendmail は
            <emphasis>アドレステストモード</emphasis>で起動します.
            &ldquo;0&rdquo;
            の後に配送したいアドレスを書いてください. 最後の行に, 実際に使用される 
            mail agent, この mail agent で送られる送信先のホスト, そして 
            (多分変換されている) アドレスが表示されます. このモードを抜けるには 
            Control-D を押してください.
          </para>
  
	  <screen>&prompt.user; <userinput>sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<prompt>&gt;</prompt> <userinput>0 foo@interface-business.de</userinput>
rewrite: ruleset  0   input: foo @ interface-business . de
...
rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
&lt; @ interface-business . de &gt;
<prompt>&gt;</prompt> <userinput>^D</userinput></screen>

        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ispmail">
          <para>ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?</para></question>

        <answer>
          <para>
            静的に IP アドレスが割り当てられる場合は,
            デフォルトの状態を変更する必要はありません.
            割り当てられた名前をホストネームと
            するだけで, sendmail が後のことを引き受けてくれます.
          </para>
  
          <para>
            ダイアルアップ ppp をインターネット接続に使用し, 動的に IP
            アドレスが割り当てられる場合は,
            インターネットサービスプロバイダ(ISP)のメールサーバにメールボックスがあるはずです.
            ISP のドメインが
            <filename>myISP.com</filename>
            で, あなたのユーザ名が
            <username>user</username> だと仮定します. 
            また, あなたが自分のマシンを <filename>bsd.home</filename>
            と呼んでおり, ISP が
            <filename>relay.myISP.com</filename>
            をメールリレーとして使用できると言っているとしましょう.
          </para>
  
          <para>
            メールボックスからメールを取ってくるためには,
            回収(retrieval)エージェントをインストールする必要があります.
            <command>fetchmail</command>
            は多種多様なプロトコルをサポートしているのでお勧めです.
            ISP が使用しているのは, 大抵 POP3 プロトコルです.
            ユーザ ppp を使用している場合, 
            <filename>/etc/ppp/ppp.linkup</filename>
            に以下のように記述すると,
            インターネットと接続が完了した時点で自動的にメールを取得するようになります.
          </para>
  
          <programlisting>MYADDR:
        !bg su user -c fetchmail</programlisting>

  
          <para>
            ローカルでないアカウントにメールを配送するのに
            sendmail を使用している場合(後述),
            上に示したエントリの後に
          </para>
  
<programlisting>        !bg su user -c "sendmail -q"</programlisting>
  
          <para>
            を記述します. これはネットワーク接続が確立したらすぐに
            sendmail に溜っている mailqueue を強制的に処理させるようにします.
          </para>
  
          <para>
            この例では, <username>user</username> が
            <filename>bsd.home</filename> にアカウントを持ち, 
            <filename>bsd.home</filename> 上の
            <username>user</username>
            のホームディレクトリに, 以下のような
            <filename>.fetchmailrc</filename>
            ファイルがつくられていることを想定しています.
          </para>
  
          <programlisting>poll myISP.com protocol pop3 fetchall pass MySecret;</programlisting>
  
          <para>
            言うまでもなく, このファイルは
            <username>user</username>
            以外のユーザが読むことが出来ないようにしなくてはなりません.
            内容にパスワード <literal>MySecret</literal>
            が含まれているからです.
          </para>
  
          <para>
            正しい
            <symbol>from:</symbol>
            ヘッダをつけてメールを送るためには, sendmail に
            <email>user@bsd.home</email> ではなく
            <email>user@myISP.com</email>
            を使用するよう教える必要があります.
            メールをより早く転送するために, 全てのメールを
            <filename>relay.myISP.com</filename>
            へ送るように sendmail に指示しておくのも良いでしょう.
          </para>
  
          <para>
            上の要件を満たすには, 以下のような <filename>.mc</filename>
            ファイルが適しています.
          </para>
  
          <programlisting>VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`myISP.com')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(SMART_HOST, `relay.myISP.com')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE', `deferred')dnl</programlisting>
  
          <para>
            <filename>.mc</filename> ファイルから
            <filename>sendmail.cf</filename> への変換方法については, 
            前のセクションを参照してください. sendmail.cf を更新した後に
            sendmail をリスタートするのもお忘れなく.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>しまった! root のパスワードを忘れてしまった!</para>
        </question>

        <answer>
          <para>
            あわてないで下さい! 単にシステムを再起動し,
            シングルユーザモードに移るために <prompt>Boot:</prompt>
            と表示されるプロンプトで <userinput>boot -s</userinput>
            と入力してください.
            (FreeBSD の 3.2 より前のリリースでは
            <userinput>-s</userinput>となります. )
            どのシェルを使うのかという質問には, ENTER
            キーを押してください. &prompt.root;
            に移ることができるでしょう.
            <command>mount -u /</command> と入力して
            ルートファイルシステムの読み書きを再マウントし,
            <command>mount -a</command> と入力して,
            すべてのファイルシステムをマウントし直した後,
            <command>passwd root</command>
            と入力して <username>root</username>
            のパスワードを設定し直して下さい.
            その後, <command>exit</command>
            と入力すれば, ブートが続けられます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            <keycap>Control</keycap>-<keycap>Alt</keycap>-<keycap>Delete</keycap>
            でシステムがリブートしないようにするにはどうすればいい?</para>
        </question>

        <answer>
          <para>
            FreeBSD 2.2.7-RELEASE 以降で syscons(デフォルトのコンソールドライバ)
            を使用している場合には, 次の行をカーネルコンフィグレーションファイルに追加して
            カーネルを再構築し, インストールして下さい.
          </para>

          <programlisting>options SC_DISABLE_REBOOT</programlisting>

          <para>
            FreeBSD 2.2.5-RELEASE 以降で PCVT コンソールドライバを使用している
            場合には, 同様に次の行をカーネルコンフィグレーションファイルに追加して
            カーネルを再構築し, インストールして下さい.
          </para>

          <programlisting>options PCVT_CTRL_ALT_DEL</programlisting>

          <para>
            上にあげたものよりも古い FreeBSD の場合,
            現在コンソールが使用しているキーマップを編集し, 
            キーワード
            <symbol>boot</symbol> を
            <symbol>nop</symbol> に書き換えてください.
            <filename>/usr/share/syscons/keymaps/us.iso.kbd</filename>
            にあります.
            その変更を反映させようとして,
            このキーマップのロードを明示的に行なうために,
            <filename>/etc/rc.conf</filename> を実行すべきかもしれません.
            もちろん他の国のキーマップを使っているのであれば,
            代わりにそのキーマップファイルを編集して下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>DOS のテキストファイルを UNIX
            のテキストファイルに整形するにはどうすればいい?</para>
        </question>

        <answer>
          <para>
            単に次の perl コマンドを実行してください.
          </para>
  
          <screen>&prompt.user; <userinput><command>perl</command> <option>-i.bak -npe 's/\r\n/\n/g'</option> <replaceable>file ...</replaceable></userinput></screen>

  
          <para>
            <replaceable>file</replaceable>
            の部分には処理するファイルを指定して下さい.
            整形後のファイルは元のファイル名で作成され,
            整形前のファイルはバックアップとして元の
            ファイル名の末尾に拡張子
            <filename>.bak</filename> のつけられた名前で作成されます.
          </para>
  
          <para>
            あるいは
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tr">tr(1)</ulink>
            コマンドを使うこともできます.
          </para>
  
          <screen>&prompt.user; <userinput><command>tr</command> <option>-d '\r'</option> &lt; <replaceable>dos-text-file</replaceable> &gt; <replaceable>unix-file</replaceable></userinput></screen>
          
          <para>
            <replaceable>dos-text-file</replaceable> は
            DOS 形式のテストファイル, 
            <replaceable>unix-file</replaceable>
            には変換された出力が格納されます. 
            perl を使うよりほんのちょっぴり速くなります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>名前で指定してプロセスにシグナルを送るにはどうすればいい?</para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?killall">killall(1)</ulink>
            を使って下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>su</command> が <computeroutput>not in root's ACL</computeroutput>
            と言って私を悩ませるのはなぜ?</para>
        </question>

        <answer>
          <para>Kerberos の認証システムからくるエラーです.
            この問題は致命的なものではなく,
            うっとおしいといったものです.
            <command>su</command> に <option>-K</option>
            オプションをつけて起動するか,
            次の質問で説明されている方法で Kerberos
            をアンインストールして下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Kerberos をアンインストールするにはどうすればいいの?</para>
        </question>

        <answer>
          <para>
            システムから Kerberos を削除するには,
            あなたの動かしているリリースの
            <symbol>bin</symbol>
            ディストリビューションを再インストールして下さい.
            もし CDROM を持っているのなら,
            その CDROM をマウント(マウントポイントは
            <filename>/cdrom</filename> と仮定)して,
            次のように入力して下さい.
          </para>
  
          <screen>&prompt.root; <userinput><command>cd /cdrom/bin</command></userinput>
&prompt.root; <userinput><command>./install.sh</command></userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>疑似ターミナルを追加するには?</para>
        </question>

        <answer>
          <para>
            telnet, ssh, X, screen をたくさん利用されている場合, 
            疑似ターミナルが足りなくなっている可能性があります. 
            これを増やすには次のようにします.
          </para>
  
          <para>
            <orderedlist>
              <listitem>
                <para>
                  次の行をカーネルコンフィグレーションファイルに追加して

                  <programlisting>pseudo-device pty 256</programlisting>

                  新たにカーネルを作りインストールします.
                </para>
              </listitem>

              <listitem>
                <para>
                  次のコマンドを実行して

                  <screen>&prompt.root; <userinput><command>cd /dev</command></userinput>
&prompt.root; <userinput><command>./MAKEDEV pty{1,2,3,4,5,6,7}</command></userinput></screen>

                  新たなターミナル用の 256 個のデバイスノードを作ります.
                </para>
              </listitem>

              <listitem>
                <para>
                  <filename>/etc/ttys</filename> を編集し
                  256 個のターミナルごとの定義を追加します. 
                  既存のエントリーの形式にあわせる必要があるでしょう.
                  例えばこんな感じです.

                  <programlisting>ttyqc none network</programlisting>
                </para>

                <para>
                  正規表現を使った指定は
                  <literal>tty[pqrsPQRS][0-9a-v]</literal>
                  となります.
                </para>
              </listitem>

              <listitem>
                <para>
                  新しいカーネルでシステムをリブートすると完了です.
                </para>
              </listitem>
            </orderedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            <devicename>snd0</devicename>
            デバイスを作成することができません!</para>
        </question>

        <answer>
          <para>
            以下に示すコマンドでサウンドカード用のデバイスを作ることができます.

            <screen>&prompt.root; <userinput><command>cd /dev</command></userinput>
&prompt.root; <userinput><command>sh MAKEDEV snd0</command></userinput></screen>
          </para>

          <para>
            ただし, このコマンドは
            <filename>/dev/snd0</filename>
            という名前のデバイスファイルを作成するわけではなく,
            代わりに
            <filename>mixer0</filename>,
            <filename>audio0</filename>,
            <filename>dsp0</filename>
            などといった名前のデバイスファイルを作成します.
            作成されるデバイス名は異なるのですが,
            サウンドデバイスを追加するためには, 依然として
            上に示すコマンドの実行が必要です.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>リブートせずにもう一度
            <filename>/etc/rc.conf</filename>
            を読み込んで
            <filename>/etc/rc</filename>
            を開始させるには?</para>
        </question>

        <answer>
          <para>
            シングルユーザモードに移行して,
            マルチユーザモードに戻ってください.
          </para>
  
          <para>
            コンソールで次のように実行します.

            <screen>&prompt.root; <userinput><command>shutdown now</command></userinput><emphasis>(注: <option>-r</option> や <option>-h</option> は付けません)</emphasis>
&prompt.root; <userinput><command>return</command></userinput>
&prompt.root; <userinput><command>exit</command></userinput></screen>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>砂場(sandbox)とは何ですか?</para>
        </question>

        <answer>
          <para>&quot;砂場(Sandbox)&quot; とはセキュリティ用語の一つで,
            次の二つの意味があります.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  一つ目は, 「仮想的な『防壁』で囲まれているプロセス」です.
                  その『防壁』は, そのプロセスに侵入した第三者が,
                  さらにシステムの広い範囲に影響を与えることを防ぐように設計されます.
                </para>

                <para>
                  このプロセスの振舞いは, 『防壁』の中だけに制限される, と表現できます.
                  つまり, このプロセスにおいて, 『防壁』を越えるようなコードの実行は
                  できないという意味です. そのため, コードの実行におけるセキュリティは
                  確かなものであると保証でき, 実行の詳細な追跡を行なう必要はなくなります.
                </para>

                <para>
                  その『防壁』とは, 例えばユーザ ID がそれにあたるでしょう.
                  この定義は, security(7) や named(8) のマニュアルページで用いられています.
                </para>

                <para>
                  &ldquo;ntalk&rdquo;
                  サービス(<filename>/etc/inetd.conf</filename>
                  参照のこと)を例にとってみます.
                  このサービスはかつて, 実行時の ユーザ ID として
                  <username>root</username>
                  を用いていましたが, 現在では
                  <username>tty</username>
                  というユーザ ID で動作します.
                  ユーザ
                  <username>tty</username> は,
                  ntalk を経由してシステムの侵入に成功した第三者が
                  そのユーザ ID 以上の権限を得ることを,
                  より一層困難にするために設計された砂場(sandbox)なのです.
                </para>
              </listitem>

              <listitem>
                <para>
                  二つ目は「シミュレートされたマシンの内側で実行されるプロセス」のことで,
                  こちらはより中核的です.
                  普通に考えれば, あるプロセスに侵入することができる第三者は,
                  マシンのより広い範囲にも侵入できると信じるものなのですが,
                  この種のプロセスの場合, それは実際にはシミュレートされたマシンに
                  侵入しただけなので, 現実のデータを変更することは何一つできません.
                </para>

                <para>
                  これを実現するための最も広く用いられている方法は,
                  シミュレートされた環境をサブディレクトリに構築し,
                  そのディレクトリに chroot して, そのディレクトリで
                  プロセスを実行すること(つまり, そのプロセスにとって
                  &ldquo;<filename>/</filename>&rdquo; は
                  システムの実際のルートディレクトリ
                  &ldquo;<filename>/</filename>&rdquo; ではなく,
                  chroot されたサブディレクトリを指す)です.
                </para>

                <para>
                  広く用いられているもう一つの方法があります.
                  それは, 既に存在しているファイルシステムを
                  読み込み専用(read-only)でマウントし, その上に, あるプロセスに対して
                  そのファイルシステムが書き込み可能であるように見せるような,
                  もう一つのファイルシステムの層を用意するものです. すると,
                  そのプロセスはファイルを書き込むことができると認識し,
                  実際に書き込むことができるのもその特定のプロセスだけ
                  - システムにある他のプロセスは書き込めないのに対して -
                  であるという状況を実現することができます.
                </para>

                <para>
                  この種の砂場(sandbox)は,
                  その非常に透過的な性質を使って, ユーザ(もしくは侵入者)が
                  その事実に気付かないように実現されます.
                </para>
              </listitem>
            </itemizedlist>
          </para>
          
          <para>
            UNIX は, 内部的に二つの砂場(sandbox)を実装しています.
            一つはプロセスレベルのもの, もう一つはユーザ ID レベルのものです.
          </para>
  
          <para>
            UNIX プロセスは全て, 他の UNIX プロセスから完全に隔離されています.
            どのプロセスも, 他のプロセスのアドレス空間を変更することはできません.
            これは, あるプロセスが他のプロセスのアドレス空間を上書きできるような,
            クラッシュにつながる行為が容易に実現できる Windows とは全く異なるものです.
          </para>
  
          <para>
            UNIX プロセスは, 特定のユーザ ID が所有します.
            もし, 実行者のユーザ ID が <username>root</username>
            ユーザのものでなければ,
            ユーザ ID は, 他のユーザが所有するプロセスから
            そのプロセスを守る機能を果たすわけです.
            また, そのユーザ ID は, ディスク上にあるデータを
            保護するのにも使われています.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
	<question>
	  <para>フロッピーや他のリムーバブルメディアのマウントを一般ユーザーに許可するには?</para>
	</question>
	
	<answer>
	  <para>
            一般ユーザーでもデバイスをマウントできるようにすることができます.
            手順は次のとおりです.
          </para>
	  
	  <procedure>
	    <step>
	      <para><username>root</username>
                になって,
                リムーバブルメディアに関連するブロックデバイスに適切なパーミッションを設定します.
              </para>

	      <para>
                例として, 最初のフロッピーデバイスをユーザーがマウントできるようにするには,
                次のようにします.
              </para>
		
	      <screen>&prompt.root; <userinput><command>chmod</command> 777 /dev/fd0</userinput></screen>
	    </step>

	    <step>
	      <para><username>root</username>
                になって,
                <symbol>sysctl</symbol> 変数である
                <varname>vfs.usermount</varname> を
		<literal>1</literal> に設定します.
              </para>
	      
	      <screen>&prompt.root; <userinput><command>sysctl</command> -w vfs.usermount=1</userinput></screen>
	    </step>
	  </procedure>

	  <para>
            これで, ユーザー所有のディレクトリへ
	    <filename>/dev/fd0</filename> をマウントすることができます.
	  </para>
	  
	  <screen>&prompt.user; <userinput><command>mkdir</command> ~/my-mount-point</userinput>
&prompt.user; <userinput><command>mount</command> -t msdos /dev/fd0 ~/my-mount-point</userinput></screen>

	  <para>デバイスのアンマウントは簡単です.</para>
	  
	  <screen>&prompt.user; <userinput><command>umount</command> <filename>~/my-mount-point</filename></userinput></screen>
	  
	  <para>
            しかし,
            <varname>vfs.usermount</varname>
	    を有効にすることは, セキュリティ上よいことではありません.
	    MSDOS 形式のメディアにアクセスには, Ports コレクションにある
	    パッケージ
            <ulink url="http://www.freebsd.org/cgi/ports.cgi?query=%5Emtools-&amp;stype=name">mtools</ulink>
	    を使用した方がよいでしょう.
          </para>
	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="x">
    <title>X Window System と仮想コンソール</title>

    <para>
      <emphasis>訳:
        今野 元之 <email>motoyuki@jp.FreeBSD.org</email>,
        1997 年 11 月 13 日.</emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>X を動かしたいのですが, どうすればいいのですか?</para>
        </question>

        <answer>
          <para>
            もっとも簡単な方法は FreeBSD のインストールの際に
            X を動かすことを指定するだけです.
          </para>
  
          <para>それから
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config">xf86config</ulink>
            ツールのドキュメントを読んでこれに従ってください.
            このツールはあなたのグラフィックカードやマウスなどに合わせて
            XFree86(tm) の設定を行うのを助けてくれます.
          </para>
  
          <para>
            Xaccel サーバーについて調べてみるのもいいでしょう.
            詳しくは <link linkend="xig">Xi Graphics について</link> か
            <link linkend="metrox">Metro Link</link> をご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="x-and-moused">
          <para>私のマウスはなぜ X で動かないのでしょうか?</para>
        </question>

        <answer>
          <para>syscons (デフォルトのコンソールドライバ) を使っているのであれば,
            それぞれの仮想スクリーンでマウスポインターをサポートするように
            FreeBSD を設定できます. X でのマウスの衝突を避けるために, syscons は
            &ldquo;<filename>/dev/sysmouse</filename>&rdquo;
            という仮想デバイスをサポートしています.
            本物のマウスデバイスから入力された全てのマウスのイベントは,
            moused を経由して sysmouse デバイスへ出力されます.
            一つ以上の仮想コンソールと X の
            <emphasis>両方で</emphasis> マウスを使いたい場合,
            <xref linkend="moused" remap="another section">
            を参照して moused を設定して下さい.
          </para>

          <para>
            そして, <filename>/etc/XF86Config</filename> を編集し,
            次のように書かれていることを確認して下さい.</para>

          <programlisting>Section         Pointer
Protocol        "SysMouse"
Device          "/dev/sysmouse"
.....</programlisting>

          <para>
            上の例は, XFree86 3.3.2 以降の場合の例です.
            それより前のバージョンでは,
            <symbol>Protocol</symbol> という部分を
            <symbol>MouseSystems</symbol> と置き換える必要があります.
          </para>
  
          <para>
            X で &ldquo;<filename>/dev/mouse</filename>&rdquo;
            を使うのを好む人もいます.
            この場合は, 
            &ldquo;<filename>/dev/mouse</filename>&rdquo;
            を
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sysmouse">/dev/sysmouse</ulink>
            にリンクしてください.
          </para>
  
          <screen>&prompt.root; <userinput><command>cd</command> /dev</userinput>
&prompt.root; <userinput><command>rm</command> -f mouse</userinput>
&prompt.root; <userinput><command>ln</command> -s sysmouse mouse</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="x-and-wheel">
          <para>わたしのマウスにはホイール機能が付いているのですが, X で使うことはできますか?</para>
        </question>
        
        <answer>
          <para>はい, もちろん使えますが, そのためには
            X クライアントプログラムを適切に設定する必要があります. これについては,
            <ulink URL="http://www.inria.fr/koala/colas/mouse-wheel-scroll/">Colas Nahaboo
              氏のウェブページ(http://www.inria.fr/koala/colas/mouse-wheel-scroll/)</ulink>
            を参照してください.</para>

	  <para>
            <application>imwheel</application>
            というプログラムを使う場合は,
            次のような簡単な手順にしたがって下さい.
          </para>

	  <orderedlist>
	    <listitem>
	      <para>ホイールイベントの変換</para>

              <para>
                <application>imwheel</application> は,
                マウスのボタン 4, ボタン 5 をキー押下イベントに変換するプログラムです.
                そのためホイールマウスで利用するには, マウスホイールのイベントをボタン 4,
                ボタン 5 のイベントに変換するマウスドライバを利用する必要があります.
                この変換を行なうには二つの方法があります.
                一つは &man.moused.8;
                で行なう方法, 二つめは X サーバ自身に変換を行なわせる方法です.
              </para>

	      <orderedlist>
		<listitem>
		  <para>ホイールイベントの変換に &man.moused.8; を使う</para>

		  <para>
                    &man.moused.8; にイベントを変換させるには,
                    &man.moused.8; 起動時にオプション
                    <option>-z 4</option> を追加します.
                    たとえば, 普段 &man.moused.8; を
                    <command>moused -p /dev/psm0</command>
                    として起動しているなら, その代わりに
                    <command>moused -p /dev/psm0 -z 4</command>
                    とします.
                    もし,
                    <filename>/etc/rc.conf</filename>
                    を使って自動的に起動するように設定しているなら,
                    <filename>/etc/rc.conf</filename>
                    の中の
                    <varname>moused_flags</varname> という変数に
                    <option>-z 4</option> を追加するだけです.
                  </para>

		  <para>
                    そして, 5 ボタンマウスを使うことを
                    X サーバに伝える必要があります.
                    これを行なうには
                    <filename>/etc/XF86Config</filename> の
                    <quote>Pointer</quote> セクションに
                    <literal>Buttons 5</literal> という行を追加するだけです.
                    そうすると
		    <filename>/etc/XF86Config</filename> の
		    <quote>Pointer</quote> は,
                    たとえば次のようになるでしょう.
                  </para>

		  <example>
                    <title>
                      moused による変換を利用してホイールマウスを使用するための
                      XF86Config の <quote>Pointer</quote> セクションの設定例</title>

		    <programlisting>Section "Pointer"
   Protocol        "SysMouse"
   Device          "/dev/sysmouse"
   Buttons         5
EndSection
		    </programlisting>
		  </example>
		</listitem>

		<listitem>
		  <para>X サーバを使ったホイールイベントの変換</para>

		  <para>
                    &man.moused.8; を起動していなかったり,
                    ホイールイベントの変換に &man.moused.8;
                    を起動したくない場合には, その代わりに
                    X サーバを使うことができます.
                    これには, <filename>/etc/XF86Config</filename>
                    ファイルを書き換える必要があります.
                    まず最初に必要なのは,
                    マウスがどのプロトコルを使っているのかを確認することです.
                    ほとんどのホイールマウスは
                    <quote>IntelliMouse</quote>
                    プロトコルを使用していますが,
                    XFree86 サーバはその他のプロトコル,
                    たとえば
                    Logitech MouseMan+ マウスが利用している
                    <quote>MouseManPlusPS/2</quote>
                    プロトコルなどもサポートしています.
                    使用されているプロトコルが確認できたら
                    <quote>Pointer</quote> セクションに
                    <varname>Protocol</varname> の行を追加して下さい.
                  </para>

		  <para>
                    つぎに,
                    ホイールのスクロールイベントをマウスボタン 4,
                    マウスボタン 5 に割り当てることを X サーバに伝えます.
                    これを行なうには
                    <varname>ZAxisMapping</varname>
                    オプションを使用します.
                  </para>

		  <para>
                    たとえば, &man.moused.8; が起動していない状態で,
                    PS/2 マウスポートに IntelliMouse が接続されているとしたら
                    <filename>/etc/XF86Config</filename>
                    はおそらく次のようになります.
                  </para>

		  <example>
                    <title>
                      X サーバによる変換を利用してホイールマウスを使用するための
                      XF86Config の <quote>Pointer</quote> セクションの設定例</title>

		    <programlisting>Section "Pointer"
   Protocol        "IntelliMouse"
   Device          "/dev/psm0"
   ZAxisMapping    4 5
EndSection
		    </programlisting>
		  </example>
		</listitem>
	      </orderedlist>
	    </listitem>

	    <listitem>
	      <para><application>imwheel</application> のインストール</para>

	      <para>
                さて, つぎに Ports Collection から
                <application>imwheel</application> をインストールします.
                これがあるのは <filename>x11</filename> カテゴリです.
                このプログラムは,
                マウスイベントをキーボードイベントに変換します.
                たとえば, マウスホイールを前に回した時,
                <application>imwheel</application> は <keycap>PageUp</keycap>
                をアプリケーションプログラムに送るような動作をするわけです.                
                <application>Imwheel</application>
                はホイールイベントとキーボード押下の対応を設定ファイルを使って設定するため,
                アプリケーション毎に異なる対応を持たせることも可能です.
                <application>imwheel</application> のデフォルトの設定ファイルは
                <filename>/usr/X11R6/etc/imwheelrc</filename>
                にインストールされます.
                これを <filename>~/.imwheelrc</filename> にコピーして編集し,
                お好きなように <application>imwheel</application>
                で利用したいアプリケーションの設定をカスタマイズしてください.
		設定ファイルの書式は &man.imwheel.1; に説明されています.
              </para>
	    </listitem>

	    <listitem>
	      <para><application>Emacs</application> で
                <application>Imwheel</application> を使うように設定する
		(<emphasis>必須ではありません</emphasis>)</para>

	      <para>
                <application>emacs</application> や
		<application>Xemacs</application>
                で利用するには,
                <filename>~/.emacs</filename> にいくらか書き加える必要があります.
		<application>emacs</application> の場合は次の部分を追加して下さい.
              </para>

	      <example>
		<title><application>Imwheel</application> を利用するための
                  <application>Emacs</application> の設定例</title>

		<programlisting>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(global-set-key [?\M-\C-\)] 'imwheel-scroll-up-some-lines)
(global-set-key [?\M-\C-\(] 'imwheel-scroll-down-some-lines)
;;; end imwheel section
		</programlisting>
	      </example>

	      <para>
		<application>Xemacs</application> の場合は
                <filename>~/.emacs</filename> に次の部分を追加して下さい.
              </para>

	      <example>
		<title><application>Imwheel</application> を利用するための
                  <application>XEmacs</application> の設定例</title>

		<programlisting>;;; For imwheel
(setq imwheel-scroll-interval 3)
(defun imwheel-scroll-down-some-lines ()
  (interactive)
  (scroll-down imwheel-scroll-interval))
(defun imwheel-scroll-up-some-lines ()
  (interactive)
  (scroll-up imwheel-scroll-interval))
(define-key global-map [(control meta \))] 'imwheel-scroll-up-some-lines)
(define-key global-map [(control meta \()] 'imwheel-scroll-down-some-lines)
;;; end imwheel section
		</programlisting>
	      </example>
	    </listitem>

	    <listitem>
	      <para><application>Imwheel</application> の実行</para>

	      <para>
                インストールが完了していれば, 単に xterm(訳注:
                日本語環境で広く使われている kterm でも構いません)から
                <command>imwheel</command> を入力するだけで起動できます.
                起動するとバックグラウンドで動作し, すぐに利用できます.
                <application>imwheel</application> をいつも使うように設定するには,
                <filename>.xinitrc</filename> か
		<filename>.xsession</filename> のファイルにそのままコマンドを追加してください.
                <application>imwheel</application> が PID
                ファイルに関する警告を表示するかも知れませんが,
                無視しても危険はありません. この警告が意味を持つのは,
                Linux 版の <application>imwheel</application> だけです.
              </para>
	    </listitem>
	  </orderedlist>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>X のメニューやダイアログボックスがうまく動きません.</para>
        </question>

        <answer>
          <para>
            Num Lock キーをオフにしてください.
          </para>
          
          <para>Num Lock キーがデフォルトでブート時にオンになる場合は, 
            <filename>XF86Config</filename> ファイルの
            &ldquo;<symbol>Keyboard</symbol>&rdquo;
            セクションに以下の行を加えてもいいでしょう.
  
          <programlisting># Let the server do the NumLock processing.  This should only be
# required when using pre-R6 clients
    ServerNumLock</programlisting>
  
            <note>
              <title>訳注</title>
              <para>
                この問題は XFree86 3.2 以降では解決しています.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>仮想コンソールとは何ですか? どうやったら使えますか?</para>
        </question>

        <answer>
          <para>
            仮想コンソールは, 簡単にいうと, ネットワークや X
            を動かすなどの複雑なことをおこなわずに,
            いくつかのセッションを同時におこなうことを可能にします.
          </para>
  
          <para>
            システムのスタート時には,
            ブートメッセージが出た後に login 
            プロンプトが表示されます. そこで
            ログイン名とパスワードを入力すると
            1 番目の仮想コンソール上で仕事(あるいは遊び)を始めることができます.
          </para>
  
          <para>
            他のセッションを始めたい場合もあるでしょう.
            それは動かしているプログラムのドキュメントを見たり,
            FTP の転送が終わるまで待つ間,
            メールを読もうとしたりすることかもしれません.
            <keycap>Alt</keycap>-<keycap>F2</keycap>
            を押す(<keycap>Alt</keycap> キーを押しながら
            <keycap>F2</keycap> キーを押す) と,
            2 番目の「仮想コンソール」で
            ログインプロンプトが待機していることがわかります.
            最初のセッションに戻りたいときは
            <keycap>Alt</keycap>-<keycap>F1</keycap> を押します.
          </para>
  
          <para>
            標準の FreeBSDインストールでは,
            3 枚(3.3-RELEASE では 8 枚)の仮想コンソールが有効になっていて,
            <keycap>Alt</keycap>-<keycap>F1</keycap>,
            <keycap>Alt</keycap>-<keycap>F2</keycap>,
            <keycap>Alt</keycap>-<keycap>F3</keycap>
            で仮想コンソール間の切替えをおこないます.
          </para>
  
          <para>
            より多くの仮想コンソールを有効にするには,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
            を編集して
            &ldquo;<literal>Virtual terminals</literal>&rdquo;
            のコメント行の後に
            &ldquo;<symbol>ttyv4</symbol>&rdquo;
            から
            &ldquo;<symbol>ttyvc</symbol>&rdquo;
            の手前までのエントリを加えます(以下の例は先頭には空白は入りません).
          </para>
  
          <programlisting># /etc/ttys には ttyv3 がありますので 
# "off" を "on" に変更します. 
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</programlisting>

          <para>
            多くするか少なくするかはあなたの自由です.
            より多くの仮想ターミナルを使うとより多くのリソースを使うことになります.
            8MB 以下のメモリしかない場合はこれは重要な問題です.
            もし必要があれば
            &ldquo;<symbol>secure</symbol>&rdquo; を
            &ldquo;<symbol>insecure</symbol>&rdquo;
            に変更してください.
  
            <important>
              <para>X を使いたいのであれば,
                最低一つの仮想ターミナル(のエントリ)を使わずに残しておくか,
                off にしておく必要があります.
                つまり, 12 個の
                <keycap>Alt</keycap>-ファンクションキー全てでログインプロンプトを
                出したいのならば,
                残念ながら X は利用できないということです. 
                同じマシンで X サーバーも動かしたいのならば
                11 個しか使えません.
              </para>
            </important>
          </para>
  
          <para>
            仮想コンソールを無効にするもっとも簡単な方法は,
            コンソールを
            off にすることです.
            例えば 12 個全てのターミナルを割り当てている状態で
            X を動かしたいときは,
            仮想ターミナル 12 を変更します.
          </para>
  
          <programlisting>ttyvb   "/usr/libexec/getty Pc"         cons25  on secure</programlisting>
  
          <para>
            これを次のように変更します.
          </para>
  
          <programlisting>ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</programlisting>
  
          <para>
            キーボードにファンクションキーが 10 個しかないのであれば,
            次のように設定します.
          </para>
          
          <programlisting>ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure</programlisting>
  
          <para>
            (これらの行を消すだけでもいいです.)
          </para>
  
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
            を編集したら,
            次は十分な数の仮想ターミナルデバイスを作らなくてはなりません.
            もっとも簡単な方法を示します.
          </para>
  
          <screen>&prompt.root; <userinput><command>cd</command> /dev</userinput>
&prompt.root; <userinput><command>./MAKEDEV</command> vty12</userinput><emphasis>(12 個のデバイスをつくる場合)</emphasis></screen>
  
          <para>
            さて, 仮想コンソールを有効にするもっとも簡単(そして確実)な方法は,
            リブートすることです. しかし, リブートしたくない場合は,
            X ウィンドウシステムを終了させて次の内容を(<username>root</username>
            権限で)実行します.
          </para>
  
          <screen>&prompt.root; <userinput><command>kill</command> -HUP 1</userinput></screen>
  
          <para>
            重要な点は,
            このコマンドを実行する前に X
            ウィンドウシステムを完全に終了させておくことです.
            もしそうしないと <command>kill</command>
            コマンドを実行した後,
            システムはおそらくハングアップするでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>X から仮想コンソールに切替えるにはどうすればよいのですか?</para>
        </question>

        <answer>
          <para>
            コンソールが X の表示をしている場合は,
            <keycap>Ctrl</keycap>-<keycap>Alt</keycap>-<keycap>F1</keycap>
            などを使って仮想コンソールの切替えをおこなうことができます.
            ただし, X
            から離れて仮想ターミナルへ移っている時は,
            <keycap>Alt</keycap>-ファンクションキーを使って他の仮想ターミナルへ切替えたり
            X へ戻ったりします. 
            コントロールキーは押さないでください.
            <keycap>Ctrl</keycap>-<keycap>Alt</keycap>-ファンクションキーの組合せは,
            X から仮想ターミナルに移る時だけ利用してください.
            コントロールキーを押してしまうと
            &ldquo;control-lock&rdquo; モードになり,
            テキストコンソールが止まってしまいます.
            コントロールキーを押して回復させてください.
  
            <note>
              <title>訳注</title>
              <para>
                X に戻るには,
                3 枚の仮想コンソールが有効になっている場合は
                <keycap>Alt</keycap>-<keycap>F4</keycap> です.
                有効な仮想コンソールの数 +1 のファンクションキーの
                位置に X が割り当てられます.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>XDM をブート時に起動させるにはどうしますか?</para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm">xdm</ulink>
            の起動方法について, その考え方には二つの流派があります.
            ある流派では提供された例を使用して xdm を
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
            から起動し, 他の流派では xdm を単に
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc">rc.local</ulink>
            または <filename>/usr/local/etc/rc.d</filename> にある
            <filename>X.sh</filename> スクリプトから起動します.
            どちらも正しく, 片方が動作しない場合は, もう片方が動作するでしょう.
            どちらも場合でも結果は同じであり, X はグラフィカルな
            <prompt>login:</prompt> プロンプトを表示します.
          </para>
  
          <para>
            <filename>ttys</filename> を利用する方法の利点は,
            どの <acronym>vty</acronym> で X が起動したかの記録が残せることと,
            ログアウト時に X サーバを再起動する責任を
            init に押しつけることができることでしょう.
          </para>
  
          <para>
            <filename>rc.local</filename> からロードされる場合,
            <command>xdm</command> は引数を持たずに(すなわち, デーモンとして)起動します.
            <command>xdm</command> は <command>getty</command>
            が起動した後にロードされなければなりません.
            そうでないと, <command>xdm</command> は <command>getty</command>
            と衝突し, コンソールをロックアウトしてしまいます.
            この問題に対処する最善の方法は,
            起動スクリプト(訳注: <filename>rc.local</filename>
            のこと)で 10 秒ほどの <command>sleep</command> を実行させ,
            その後に <command>xdm</command> をロードすることです.
          </para>
  
          <para>
            <filename>/etc/ttys</filename> から
            <command>xdm</command> を起動させている場合には,
            <command>xdm</command> と <command>getty</command>
            が衝突する可能性があります.
            この問題を回避するには, <filename>/usr/X11R6/lib/X11/xdm/Xservers</filename> に
            <literal>vt</literal> 番号を追加して下さい.
          </para>

          <programlisting>:0 local /usr/X11R6/bin/X vt4</programlisting>
 
          <para>上の例は, <filename>/dev/ttyv3</filename> を
            X サーバに対応させます.  番号は 1 から始まりますので注意して下さい.
            X サーバは
            <acronym>vty</acronym> を 1 から数えますが,
            FreeBSD カーネルは
            <acronym>vty</acronym> を 0 から数えます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>xconsole</command> を動かそうとすると
            &ldquo;<computeroutput>Couldn't open console</computeroutput>&rdquo;
            とエラーが出ます. </para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=X">X</ulink> を
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=startx">startx</ulink>
            で起動しますと, <filename>/dev/console</filename> のパーミッションは
            <emphasis>変更ができない</emphasis>ようになっていますので,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xterm">xterm
              -C</ulink> や
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xconsole">xconsole</ulink>
            は動きません.
          </para>
  
          <para>
            これはコンソールのパーミッションが,
            標準ではそのように設定されているからです.
            マルチユーザシステムでは,
            ユーザの誰もがシステムコンソールに書き込むことが可能である必要は必ずしもありません.
            <acronym>VTY</acronym>
            を使い直接マシンにログインするユーザのために,
            このような問題を解決するために
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?fbtab">fbtab</ulink>
            というファイルがあります.
          </para>
  
          <para>
            要点を述べると, 次のような形式の行を
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?fbtab">fbtab</ulink> に加えます.
          </para>
  
          <programlisting>/dev/ttyv0 0600 /dev/console</programlisting>
  
          <para>
            そうすると,
            <filename>/dev/ttyv0</filename> からログインしたユーザが
            コンソールを所有することになるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私の PS/2 マウスは X ウィンドウシステム上でうまく動きません. </para>
        </question>

        <answer>
          <para>
            あなたのマウスとマウスドライバがうまく同期していないからかもしれません.
          </para>
  
          <para>
            FreeBSD 2.2.5 までのバージョンでは, X から仮想ターミナルへ切替えて,
            また X へ戻ると再同期するかもしれません.
            この問題がよく起きるようであれば, カーネルコンフィグレーション
            ファイルに次のオプションを書いてカーネルを再構成してみてください.
          </para>
  
          <programlisting>options PSM_CHECKSYNC</programlisting>
  
          <para>
            もし, カーネルの再構築をおこなったことがないのであれば,
            <link linkend="make-kernel">カーネルを構築する</link>の項を参照してください.
          </para>
  
          <para>
            このオプションにより,
            マウスとドライバの同期で問題が起きる可能性は少なくなるでしょう.
            もしそれでもこの問題が起きるようならば,
            再同期させるにはマウスを動かさないようにしておいて
            マウスボタンのどれかを押してください.
          </para>
  
          <para>
            このオプションは残念ながらすべてのシステムで働くわけではなく,
            また, PS/2 マウスポートにつながれているのが
            タップ(tap)機能を持つ アルプス社製 GlidePoint デバイスの場合,
            タップ機能が無効となってしまいます.
          </para>
  
          <para>
            FreeBSD 2.2.6 以降のバージョンでは,
            同期のチェック方法が少し改善されたので標準で有効になっています.
            GlidePoint でもうまく働きます(同期チェックが標準の機能になったので
            <symbol>PSM_CHECKSYNC</symbol>
            オプションはこれらのバージョンからは削除されました).
            しかしながら,
            まれにドライバが間違って(訳注:
            問題がないのに)同期に関して問題があると報告し, カーネルから
          </para>
  
          <screen><computeroutput>psmintr: out of sync (<replaceable>xxxx</replaceable> != <replaceable>yyyy</replaceable>)</computeroutput></screen>
  
          <para>
            というメッセージが出力されて, マウスが正しく動作していないように見える
            ことがあるかもしれません.
          </para>
  
          <para>
            もしこのようなことが起こる場合には, PS/2 マウスドライバのフラグに
            0x100 を指定して同期チェックを無効にして下さい. システムの起動時に
            &ldquo;<option>-c</option>&rdquo;
            ブートオプションを与えて
            <emphasis>UserConfig</emphasis> に入ります.
          </para>
  
          <screen><prompt>boot:</prompt> <userinput><option>-c</option></userinput></screen>
  
          <para>
            <emphasis>UserConfig</emphasis>
            のコマンドラインで以下のように入力して下さい.
          </para>
  
          <screen><prompt>&gt;</prompt> <userinput>flags psm0 0x100</userinput>
<prompt>&gt;</prompt> <userinput>quit</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>MouseSystems の PS/2 マウスがうまく動きません.</para>
        </question>

        <answer>
          <para>
            MouseSystems の PS/2 マウスのあるモデルは,
            高解像度モードの場合にのみ正しく動作するということが報告されています.
            それ以外のモードでは,
            マウスカーソルがしょっちゅうスクリーン左上に行ってしまうかもしれません.
          </para>
  
          <para>
            残念ながら FreeBSD 2.0.X や 2.1.X のバージョンでは,
            この問題の解決する方法はありません.
            2.2 から 2.2.5 のバージョンでは,
            以下のパッチを
            <filename>/sys/i386/isa/psm.c</filename>
            に適用しカーネルの再構築を行なって下さい.
          </para>
  
          <para>
            もし, カーネルの再構築をおこなったことがないのであれば,
            <link linkend="make-kernel">カーネルの構築</link>の項を参照してください.
          </para>
  
          <screen>&prompt.user; <userinput><command>diff</command> <option>-u</option> psm.c.orig psm.c</userinput>
@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
 	log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
 	    unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc);	/* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);		/* stream mode */</screen>

  
          <para>
            FreeBSD 2.2.6 以降のバージョンでは,
            PS/2 マウスドライバのフラグに
            0x04 を指定してマウスを高解像度モードにします.
            システムの起動時に
            &ldquo;<option>-c</option>&rdquo;
            ブートオプションを与えて
            <emphasis>UserConfig</emphasis> に入ります.
          </para>
  
  
          <screen><prompt>boot:</prompt> <userinput><option>-c</option></userinput></screen>
  
          <para>
            <emphasis>UserConfig</emphasis>
            のコマンドラインで以下のように入力して下さい.
          </para>
  
          <screen><prompt>&gt;</prompt> <userinput>flags psm0 0x04</userinput>
<prompt>&gt;</prompt> <userinput>quit</userinput></screen>
  
          <para>
            マウスに関する不具合の他の原因の可能性については,
            直前のセクションも見てみて下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>X のアプリケーションを構築する時に,
            <computeroutput>imake can't find <filename>Imake.tmpl</filename></computeroutput>
            となります. どこにあるのでしょうか?
          </para>
        </question>

        <answer>
          <para>
            <filename>Imake.tmpl</filename> は
            X の標準アプリケーション構築ツールである Imake パッケージの一部です.
            <filename>Imake.tmpl</filename> は,
            X アプリケーションの構築に必要な多くのヘッダファイルと同様に,
            X のプログラムディストリビューションに含まれています.
            <command>sysinstall</command> を使うか,
            手動で X のディストリビューションファイルからインストールすることができます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>マウスのボタンを入れ替える方法はありますか?</para>
        </question>

        <answer>
          <para>
            <filename>.xinitrc</filename> か
            <filename>.xsession</filename> で
            
            <programlisting><command>xmodmap</command> <option>-e "pointer = 3 2 1"</option></programlisting>

            というコマンドを実行してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>スプラッシュスクリーンのインストールはどうするのですか.
            どこで見つけることができますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD 3.1 のリリース直前に, ブートメッセージの表示期間に
            いわゆる &quot;スプラッシュ&quot;
            スクリーンを表示させることができる新しい機能が追加されました.
            いまのところスプラッシュスクリーンは
            256 色のビットマップ(<filename>*.BMP</filename>)か
            ZSoft PCX(<filename>*.PCX</filename>)ファイルです.
            それに加えて, 標準の <acronym>VGA</acronym> アダプタでの動作させるには
            320x200 以下の解像度である必要があります.
            カーネルに <acronym>VESA</acronym>
            サポートを追加すれば 1024x768
            までのより大きいビットマップを使用できます.
            <acronym>VESA</acronym> サポートを有効化するにはまず,
            カーネルが
            <symbol>VM86</symbol>
            カーネルオプションとともにコンパイルされている必要があることに注意してください.
            <acronym>VESA</acronym> サポートそのものは
            <symbol>VESA</symbol> カーネルコンフィグオプション
            によって直接カーネル中にコンパイルするか,
            ブート時に <acronym>VESA</acronym> kld
            モジュールを読み込ませることができます.
          </para>

          <para>
            スプラッシュスクリーンを使うには,
            FreeBSD
            のブートプロセスをコントロールするスタートアップファイルを書き換える必要があります.
            これらのファイルは FreeBSD 3.2 のリリース以前に変更されましたので,
            現在は, スプラッシュスクリーンを読み込む方法が二つあります.
          </para>

          <para>
            <itemizedlist>
              <listitem>
                <para>FreeBSD 3.1 の場合</para>
                
                <para>
                  まず最初のステップは,
                  スプラッシュスクリーンのビットマップ版を探してくることです.
                  3.1-RELEASE では Windows
                  のビットマップ形式のスプラッシュスクリーンだけをサポートしています.
                  お望みのスプラッシュスクリーンを見つけたなら, それを
                  <filename>/boot/splash.bmp</filename>
                  にコピーします. 次に, これらの行が書かれた
                  <filename>/boot/loader.rc</filename>
                  ファイルが必要です.
                </para>

                <programlisting>load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot</programlisting>
              </listitem>

              <listitem>
                <para>FreeBSD 3.2 以降の場合</para>

                <para>PCX 形式のスプラッシュスクリーンのサポートが追加されると同時に,
                  FreeBSD 3.2 にはブートプロセスを設定する,
                  より洗練された方法が含まれています.
                  もしお望みなら, 上に示した
                  FreeBSD 3.1 用の方法を使うこともできます.
                  もしそうしたくて, かつ PCX 形式を使いたいなら,
                  <symbol>splash_bmp</symbol> を
                  <symbol>splash_pcx</symbol> と読み換えてください.
                  そうではなくて, 新しいブート設定方法を使うのなら,
                  次の数行が書かれた <filename>/boot/loader.rc</filename>
                  ファイルと,</para>

                <programlisting>include /boot/loader.4th
start</programlisting>

                <para>
                  次の数行が含まれた
                  <filename>/boot/loader.conf</filename>
                  ファイルを作ることが必要です.
                </para>

                <programlisting>splash_bmp_load="YES"
bitmap_load="YES"</programlisting>

                <para>
                  この例では, スプラッシュスクリーンとして
                  <filename>/boot/splash.bmp</filename>
                  を使うことを想定しています. PCX 形式のファイルを使う場合には,
                  そのファイルを <filename>/boot/splash.pcx</filename> にコピーして,
                  上で示したように
                  <filename>/boot/loader.rc</filename> を作ります.
                  そして, 次の内容の
                  <filename>/boot/loader.conf</filename>
                  というファイルを作ってください.
                </para>

                <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/splash.pcx"</programlisting>
              </listitem>
            </itemizedlist>
          </para>

          <para>
            さて, あとはスプラッシュスクリーンを用意するだけです.
            それには <ulink url="http://www.cslab.vt.edu/~jobaldwi/splash/">
              http://www.cslab.vt.edu/~jobaldwi/splash/</ulink>
            のギャラリーをサーフしてみてください.
          </para>
        </answer>
      </qandaentry>

      <!-- hrs:2000/03/09 ja-translation needed -->
      <qandaentry>
	<question>
	  <para>X で Windows(tm) キーを使うことはできるのでしょうか?</para>
	</question>

	<answer>
	  <para>
            はい, もちろん.
            どういう動作をするかについて定義するには &man.xmodmap.1; を使います.
          </para>

          <para>
            標準的な &quot;Windows(tm)&quot; キーボードの場合,
            対応するキーコードは 3 種類あります.
          </para>

	  <itemizedlist>
	    <listitem>
	      <para>115 - 左の Ctrl と Alt の間にある Windows(tm) キー</para>
	    </listitem>
	    
	    <listitem>
	      <para>116 - 右の Alt と Gr の間にある Windows(tm) キー</para>
	    </listitem>
	    
	    <listitem>
	      <para>117 - 右の Ctrl の左隣にあるメニューキー</para>
	    </listitem>
	  </itemizedlist>
	  
	  <para>
            左にある Windows(tm) キーを押すとカンマ記号が入力されるようにするには,
            こんな風にします.
          </para>

	  <screen>&prompt.root; <userinput>xmodmap -e "keycode 115 = comma"</userinput></screen>

	  <para>
            設定を反映させるには, おそらく X を再起動する必要があります.
          </para>

	  <para>
            Windows(tm) キーのキーマップを X 起動時に毎回,
            自動的に有効化するには <command>xmodmap</command> コマンドを
            <filename>~/.xinitrc</filename> に追加するか,
            もしくはおすすめできる方法として
            <filename>~/.xmodmaprc</filename> というファイルを作成して,
            そのファイルの一行一行に <command>xmodmap</command>
            のオプションを記述するという方法があります.
          </para>

	  <para>
            たとえば, 先ほどあげた三つのキーを F13, F14, F15 に割り当てるとします.
            こうしておけば, アプリケーションやウィンドウマネージャの便利な機能を
            その三つのキーに簡単に割り当てることができます.
          </para>

	  <para>
            こうするには, 次の内容を <filename>~/.xmodmaprc</filename>
            に追加します.
          </para>

	  <programlisting>keycode 115 = F13
keycode 116 = F14
keycode 117 = F15</programlisting>

	  <para>
            わたしは <command>fvwm2</command> を使っていて,
            F13 をカーソル下のウィンドウのアイコン化,
            F14 をウィンドウの前面/背面化,
            F15 を, あたかもデスクトップにカーソルが存在しないかのように,
            メインワークスペース(アプリケーション)のメニューを呼び出せる機能に割り当てています.
            最後の機能は, そのデスクトップがまったく見えないときに便利です.
            (また, キートップのロゴにもぴったりです)
            <!-- hrs:2000/03/10 needs refine translation -->
          </para>

	  <para>
            次の例は, わたしがそのように割り当てをおこなうために使っている
            <filename>~/.fvwmrc</filename> のエントリです.
          </para>

	  <programlisting>Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop</programlisting>

	</answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="networking">
    <title>ネットワーキング</title>

    <para>
      <emphasis>訳:
        有村 光晴 <email>arimura@jp.FreeBSD.org</email>,
        広瀬 昌一 <email>shou@kt.rim.or.jp</email>,
        にしか <email>nishika@cheerful.com</email>,
        はらだ きろう <email>kiroh@jp.FreeBSD.org</email>,
        1998 年 10 月 4 日.</emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>&ldquo;ディスクレスブート(diskless boot)&rdquo;
            に関する情報はどこで得られますか?</para>
        </question>

        <answer>
          <para>&ldquo;ディスクレスブート(diskless boot)&rdquo;
            というのは, FreeBSD がネットワーク上で起動し, 
            必要なファイルを自分のハードディスクではなくてサーバから読み込むものです. 
            詳細については
            <ulink URL="../handbook/diskless.html">FreeBSD
              ハンドブックの「ディスクレスブート」</ulink>を読んでください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            FreeBSD をネットワークのルータ(router)として使用することはできますか?
          </para>
        </question>

        <answer>
          <para>
            インターネット標準やこれまでのよい経験によって指摘されている通り, 
            FreeBSD は標準ではパケットを転送(forward)するように設定されていません.
            しかし,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">rc.conf</ulink>
            の中で次の変数の値を 
            <symbol>YES</symbol>
            とする事によってこの機能を有効にすることができます.
          </para>
  
          <programlisting>gateway_enable=YES          # Set to YES if this host will be a gateway</programlisting>
  
          <para>
            このオプションによって
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sysctl">sysctl</ulink>
            の変数
            <varname>net.inet.ip.forwarding</varname> が
            <literal>1</literal> になります.
          </para>
  
          <para>
            ほとんどの場合,
            ルータについての情報を同じネットワークの他の計算機等に知らせるために,
            経路制御のためのプロセスを走らせる必要があるでしょう.
            FreeBSD には BSD の標準経路制御デーモンである
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?routed">routed</ulink>
            が付属していますが, より複雑な状況に対処するためには
            <emphasis>GaTeD</emphasis>(<ulink URL="http://www.gated.org/">http://www.gated.org/</ulink>
            から入手可能)を使用することもできます.
            3_5Alpha7 において FreeBSD がサポートされています.
          </para>
  
          <para>
            注意してほしいのは, FreeBSD をこのようにして使用している場合でも, 
            ルータに関するインターネット標準の必要条件を完全には満たしていない
            ということです. しかし, 普通に使用する場合にはほとんど問題ありません.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Win95 の走っているマシンを, FreeBSD 経由でインターネットに接続できますか?</para>
        </question>

        <answer>
          <para>
            通常, この質問が出てくる状況は自宅に二台の PC があり, 一台では
            FreeBSD が, もう一台では Win95 が走っているような場合です. 
            ここでやろうとしていう事は FreeBSD の走っている計算機をインターネット
            に接続し, Win95 の走っているマシンからは FreeBSD
            の走っているマシンを経由して接続をおこなう事です.
            これは二つ前の質問の特別な場合に相当します.
          </para>
  
          <para>
            FreeBSD を
            <ulink URL="http://www.ssimicro.com/~jeremyc/ppp.html">PPP
              のダイヤルアップルータ</ulink>として設定する方法については, 
            役に立つ文書があります.

            <note>
              <para>
                これには, Windows の走っているマシンから
                どれだけの作業を同時におこなうかによって,
                最低 2 個, 場合によってはもっと多くの
                固定した IP アドレスが必要です.
                もし固定した IP アドレスがない場合には, 
                プライベートな IP アドレスを用いたサブネットを使用し,
                FreeBSD 上で
                <ulink URL="http://squid.nlanr.net/Squid/">SQUID</ulink>や
                <ulink URL="http://www.tis.com/">TIS firewall
                  ツールキット</ulink>のような
                <emphasis>プロキシ(proxy)</emphasis>を用いることによって実現することもできます.
              </para>
            </note>
          </para>
          
          <para>
            また,
            <link linkend="natd">natd</link>
            に関する節も参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ISC からリリースされている BIND の最新版はコンパイルできないんでしょうか?</para>
        </question>

        <answer>
          <para>
            BIND の配布物と FreeBSD とでは
            &ldquo;<filename>cdefs.h</filename>&rdquo;
            というファイルの中でデータ型の矛盾があります. 
            <filename>compat/include/sys/cdefs.h</filename>
            を削除してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD で <acronym>SLIP</acronym> と
            <acronym>PPP</acronym> は使えますか?</para>
        </question>

        <answer>
          <para>
            使えます. FreeBSD を用いて他のサイトに接続する場合には,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?slattach">slattach</ulink>,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sliplogin">sliplogin</ulink>,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?pppd">pppd</ulink> そして
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>
            のマニュアルページを見てください. 
            <command>pppd</command> と
            <command>ppp</command> は,
            <acronym>PPP</acronym> のサーバ, クライアント両方の機能を持っています.
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sliplogin">sliplogin</ulink> は
            <acronym>SLIP</acronym> のサーバ専用で,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?slattach">slattach</ulink> は
            <acronym>SLIP</acronym> のクライアント専用です.
          </para>
  
          <para>
            これらのプログラムの解説が,
            <ulink URL="../handbook/index.html">FreeBSD
              ハンドブック</ulink>の以下のセクションにあります.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para><ulink URL="../handbook/slips.html">SLIP サーバ</ulink>
                </para>
              </listitem>

              <listitem>
                <para><ulink URL="../handbook/slipc.html">SLIP クライアント</ulink>
                </para>
              </listitem>

              <listitem>
                <para><ulink URL="../handbook/ppp.html">カーネル PPP</ulink>
                </para>
              </listitem>

              <listitem>
                <para><ulink URL="../handbook/ppp-and-slip.html#USERPPP">ユーザモード PPP</ulink></para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>
            「シェルアカウント」を通じてのみインターネットへアクセス可能な場合, 
            <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^slirp">slirp</ulink>
            package みたいなものが欲しくなるかもしれませんね.
            これを使えば, ローカルマシンから直接 <acronym>ftp</acronym>
            や <acronym>http</acronym>
            のようなサービスに(限定的ではありますが)アクセスすることができます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="natd">
          <para>FreeBSD は <acronym>NAT</acronym> か
            <acronym>IP</acronym> マスカレードをサポートしていますか?
          </para>
        </question>

        <answer>
          <para>
            ローカルなサブネット (一台以上のローカルマシン) を持っているが, 
            インターネットプロバイダから 1 つしか <acronym>IP</acronym>
            アドレスの割り当てを受けていない場合(または <acronym>IP</acronym>
            アドレスを動的に割り当てられている場合でも), 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?natd">natd</ulink>
            プログラムを使いたくなるかもしれませんね.
            <emphasis remap=tt>natd</emphasis> を使えば,
            1 つしか <acronym>IP</acronym> アドレスを持っていない場合でも,
            サブネット全体をインターネットに接続させることができます.
          </para>
  
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>
            も同様の機能を持っており, <option>-alias</option> 
            スイッチで有効にすることができます.
            どちらの場合も
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?libalias">alias library</ulink>
            が使われます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><filename>/dev/ed0</filename>
            デバイスを作成することができません. </para>
        </question>

        <answer>
          <para>Berkeley UNIX におけるネットワークの構成において,
            ネットワークのインタフェースはカーネルコードからのみ,
            直接あつかうことができます.
            より詳しく知りたい場合は,
            <filename>/etc/rc.network</filename> 
            というファイルや,
            このファイルの中に書いてある,
            さまざまなプログラムについてのマニュアルページを見てください.
            それでもまだ分からない場合には, 
            他の BSD 系の OS のネットワーク管理についての本を読むべきでしょう. 
            ごく少しの例外をのぞいては, FreeBSD のネットワーク管理は SunOS 4.0 
            や Ultrix と基本的に同じです.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>Ethernet アドレスのエイリアス(alias)はどのようにして設定できますか?</para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ifconfig">ifconfig</ulink>
            のコマンドラインに
            &ldquo;<literal>netmask 0xffffffff</literal>&rdquo;
            を追加して, 次のように書いてください.
          </para>
  
          <programlisting>ifconfig ed0 alias 204.141.95.2 netmask 0xffffffff</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>3C503 で他のネットワークポートを使用するにはどのようにすればよいですか?</para>
        </question>

        <answer>
          <para>
            他のポートを使用したい場合には,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ifconfig">ifconfig</ulink>
            のコマンドラインにパラメータを追加しなければなりません.
            デフォルトでは
            &ldquo;<symbol>link0</symbol>&rdquo;
            が用いられるようになっています.
            <acronym>BNC</acronym> のかわりに
            <acronym>AUI</acronym> ポートを使用したい場合には,
            &ldquo;<symbol>link2</symbol>&rdquo;
            というパラメータを追加してください.
            これらのフラグは,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">/etc/rc.conf</ulink>
            にある <varname>ifconfig_*</varname>
            の変数を使って指定されるはずです.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD との間で <acronym>NFS</acronym> がうまくできません.</para>
        </question>

        <answer>
          <para>
            PC 用のネットワークカードによっては,
            <acronym>NFS</acronym> のような,
            ネットワークを酷使するアプリケーションにおいて問題を起こすものがあります.
          </para>
  
          <para>
            この点に関しては
            <ulink URL="../handbook/nfs.html">FreeBSD
              ハンドブックの「NFS」</ulink>を参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>何故 Linux のディスクを <acronym>NFS</acronym>
            マウントできないのでしょうか?</para>
        </question>

        <answer>
          <para>
            Linux の <acronym>NFS</acronym>
            のコードには,
            許可されたポートからのリクエストしか受けつけないものがあります. 
            以下を試してみてください.
          </para>
  
          <screen>&prompt.root; <userinput><command>mount</command> <option>-o -P</option> <replaceable>linuxbox:/blah</replaceable> /mnt</userinput></screen>

        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>何故 Sun のディスクを <acronym>NFS</acronym>
            マウントできないのでしょうか?</para>
        </question>

        <answer>
          <para>
            SunOS 4.X が走っている Sun Workstation は,
            許可されたポートからのマウント要求しか受けつけません. 
            以下を試してみてください.
          </para>
  
          <screen>&prompt.root; <userinput><command>mount</command> <option>-o -P</option> <replaceable>sunbox:/blah</replaceable> /mnt</userinput></screen>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><acronym>PPP</acronym> で NeXTStep
            に接続する際に問題があるのですが.
          </para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">/etc/rc.conf</ulink>
            の中で次の変数を <literal>NO</literal> にして, 
            TCP extension を無効にしてみてください.
          </para>
  
          <programlisting>tcp_extensions=NO</programlisting>
  
          <para>
            Xylogic の Annex も同様の問題がありますので,
            Annex 経由で <acronym>PPP</acronym>
            をおこなう場合にもこの変更を行ってください.
          </para>  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><acronym>IP</acronym>
            マルチキャスト(multicast)を有効にするには?</para>
        </question>

        <answer>
          <para>
            FreeBSD 2.0 かそれ以降では,
            標準の状態で完全にマルチキャストに対応しています. 
            現在使用している計算機をマルチキャストのルータ(router)として使用するには, 
            <symbol>MROUTING</symbol>
            というオプションを定義したカーネルを作ったうえで,
            <command>mrouted</command>
            を走らせる必要があります. 2.2 かそれ以降の FreeBSD ならば,
            <filename>/etc/rc.conf</filename>
            でフラグ
            <symbol>mrouted_enable</symbol> を
            &ldquo;<literal>YES</literal>&rdquo; にセットしておくことで,
            ブート時に <command>mrouted</command>
            を起動できます.
          </para>
  
          <para>
            MBONE
            用のツールは ports 内の専用のカテゴリー <symbol>mbone</symbol>
            にあります.
            <literal>vic</literal> や
            <literal>vat</literal>
            といった会議用のツールを探している場合は,
            この場所を見てください.
          </para>
  
          <para>
            詳しい情報は
            <ulink URL="http://www.mbone.com/">Mbone Information Web</ulink>
            にあります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            DEC
            の PCI チップセットを用いているネットワークカードには,
            どのような物がありますか?</para>
        </question>

        <answer>
          <para>
            <ulink URL="mailto:gfoster@driver.nsta.org">Glen Foster
              氏</ulink>による一覧に,
            最近の製品を追加したものを以下に示します.
          </para>
  
          <programlisting>Vendor          Model
----------------------------------------------
ASUS            PCI-L101-TB
Accton          ENI1203
Cogent          EM960PCI
Compex          ENET32-PCI
D-Link          DE-530
Dayna           DP1203, DP2100
DEC             DE435, DE450
Danpex          EN-9400P3
JCIS            Condor JC1260
Linksys         EtherPCI
Mylex           LNP101
SMC             EtherPower 10/100 (Model 9332)
SMC             EtherPower (Model 8432)
TopWare         TE-3500P
Znyx            (2.2.X) ZX312, ZX314, ZX342, ZX345, ZX346, ZX348
                (3.X) ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442,
                      ZX444, ZX474, ZX478, ZX212, ZX214 (10mbps/hd)</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            何故自分のサイトのホストに対して <acronym>FQDN</acronym>
            を使用する必要があるのですか?</para>
        </question>

        <answer>
          <para>
            実際にはそのホストは別のドメインにあるのではないですか.
            たとえば, <hostid>foo.bar.edu</hostid>
            というドメインの中から,
            <hostid>bar.edu</hostid> ドメインにある
            &ldquo;<hostid>mumble</hostid>&rdquo;
            というホストを指定したい場合には, 
            &ldquo;<hostid>mumble</hostid>&rdquo;
            だけではダメで, 
            &ldquo;<hostid>mumble.bar.edu</hostid>&rdquo;
            という <acronym>FQDN(fully-qualified domain name)</acronym>
            で指定しなければなりません.
          </para>
  
          <para>
            伝統的に, BSD の
            BIND のリゾルバ(resolver)ではこのような事は可能でしたが, 
            FreeBSD に入っている
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?named">bind</ulink> 
            の現在のバージョンでは,
            自分以外のドメインに対して <acronym>FQDN</acronym> 
            でない別名を自動的につけてくれるような事はありません. 
            したがって <hostid>mumble</hostid> というホスト名は,
            <hostid>mumble.foo.bar.edu</hostid> 
            という名前か, もしくは <hostid>root</hostid>
            ドメイン内にある場合にしか適用されません.
          </para>
  
          <para>
            これは, 
            <hostid>mumble.bar.edu</hostid> と
            <hostid>mumble.edu</hostid> 
            ということなったドメイン名に対してホスト名のサーチがおこなわれていた
            以前の振る舞いとは異なったものです. このような事が悪い例もしくは
            セキュリティホールとみなされる理由については
            RFC 1535 を見てください.
          </para>
  
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?resolv.conf">/etc/resolv.conf</ulink>
            の中で
  
            <programlisting>domain foo.bar.edu</programlisting>
  
            と書いてある行を,
  
            <hostid>search foo.bar.edu bar.edu</hostid>

            のように書きかえることで, 上のような事ができます. しかし, 
            RFC 1535 にあるように,
            検索順序が「内部(local)と外部(public)の管理の境界」をまたがないようにしてください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>すべてのネットワークの操作に対して
            &ldquo;<computeroutput>Permission denied</computeroutput>&rdquo;
            というメッセージが表示されるのですが. </para>
        </question>

        <answer>
          <para>
            <symbol>IPFIREWALL</symbol>
            オプションを付けてカーネルをコンパイルした場合には, 
            2.1-STABLE の開発の途中から変更になった 2.1.7R の標準的な方針として, 
            明示的に許可されていないすべてのパケットは落とされる設定
            になっている事を覚えておいてください.
          </para>
  
          <para>
            もしファイアウォールの設定を間違えた場合にネットワークの操作が再びできる
            ようにするには, <username>root</username>
            でログインして次のコマンドを実行してください.
          </para>
  
          <screen>&prompt.root; <userinput><command>ipfw</command> add 65534 allow all from any to any</userinput></screen>
  
          <para>
            <filename>/etc/rc.conf</filename> に
            &ldquo;<literal>firewall_type='open'</literal>&rdquo;
            を追加してもよいでしょう.
          </para>
  
          <para>
            FreeBSD のファイアウォールの設定についての情報は
            <ulink URL="../handbook/firewalls.html">FreeBSD
              ハンドブックの「ファイアウォール」</ulink>にあります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>IPFW のオーバヘッドはどのくらいでしょうか?</para>
        </question>

        <answer>
          <para>
            この答えは,
            使っているルールセットとプロセッサのスピードによってほとんど決まります.
            イーサネットに対して少しのルールセットだけを使っている場合には,
            ほとんどその影響は無視できる程度です.
            実際の測定値を見ないと満足できない方々のために,
            実際の測定結果をお見せしましょう.
          </para>
  
          <para>
            次の測定は 486-66(訳注: Intel 社製 CPU i486, 66MHz のこと)上で
            2.2.5-STABLE を使用しておこなわれました.
            IPFW は変更が加えられて, <symbol>ip_fw_chk</symbol>
            ルーチン内でかかる時間を
            測定して 1000
            パケット毎に結果をコンソールに表示するようになっています.
          </para>
  
          <para>
            それぞれ 1000 ずつのルールが入っている 2
            つのルールセットでテストがおこなわれました.
            ひとつ目のルールセットは最悪のケースを見るために

            <programlisting>ipfw add deny tcp from any to any 55555</programlisting>
          
            というルールを繰り返したものです.
          </para>
  
          <para>
            IPFW のパケットチェックルーチンは,
            パケットが(ポート番号のせいで)このルールにマッチしないことがわかるまでに,
            何度も実行されます. そのため, これは最悪のケースを示します.
            このルールを 999 個繰り返し並べた後に

            <programlisting>allow ip from any to any</programlisting>

            が書かれています.
          </para>
  
          <para>
            2つ目のルールセットは, なるべく早くチェックが終了するように書かれたものです.
  
            <programlisting>ipfw add deny ip from 1.2.3.4 to 1.2.3.4</programlisting>
          </para>
  
          <para>
            このルールでは, 発信元の IP アドレスがマッチしないので,
            チェックはすぐに終了します. 上のルールセットとおなじように,
            1000 個目のルールは

            <programlisting>allow ip from any to any</programlisting>

            です.
          </para>
  
          <para>
            1 つ目のルールセットの場合,
            パケットあたりのオーバヘッドはおよそ
            2.703ms/packet,
            これはだいたい 1 つのルールあたり 2.7
            マイクロ秒かかっていることになります.
            したがって,
            このルールにおけるパケット処理時間の理論的な限界は,
            毎秒約 370 パケットです.
            10Mbps のイーサネットで 1500 バイト以下のパケットサイズを仮定すると,
            バンド幅の利用効率は 55.5% が限界となることになります.
          </para>
  
          <para>
            2 つ目のルールセットでは, それぞれのパケットがおよそ
            1.172msで処理されていますので,
            だいたい 1 つのルールあたり 1.2
            マイクロ秒かかっていることになります.
            パケット処理時間の理論的な限界は,
            毎秒約 853 パケットとなりますので,
            10Mbps Ethernet のバンド幅を使い切ることができます.
          </para>
  
          <para>
            このテストでのルール数は多過ぎるため,
            実際に使用する際の結果を反映している訳ではありません.
            これらは上に示した数値を出すためだけに用いられたものです.
            効率の良いルールセットを作るためには,
            次のような事を考えておけばよいでしょう.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  「確定している」ルールは先頭の方に持ってきてください.
                  これは, 多数の TCP のトラフィックがこのルールで処理されるためです. 
                  そしてこのルールの前には
                  <symbol>allow tcp</symbol>
                  という記述を置かないでください.
                </para>
              </listitem>

              <listitem>
                <para>
                  良く使われるルールを, あまり良く使われないルールよりも
                  前の方に(もちろん<emphasis>ファイアウォールの許可設定を変えない範囲で</emphasis>)
                  持ってきてください. 
                  <command>ipfw -a l</command> のようしてパケット数の統計を取ることで,
                  どのルールが最もよく使われているかを調べることができます.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>サービス要求を他のマシンにリダイレクトするには?</para>
        </question>

        <answer>
          <para>
            FTP などのサービスのリクエストは, &ldquo;socket&rdquo;
            パッケージを利用してリダイレクトできます.
            &ldquo;socket&rdquo;
            パッケージは ports の
            <symbol>sysutils</symbol>
            カテゴリに含まれています.
            (<filename>/etc/inet.conf</filename>に書かれている)            
            コマンド行を, 次のように &ldquo;socket&rdquo; を呼ぶように変更してください.
        </para>
  
          <programlisting>ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.foo.com ftp</programlisting>
  
          <para>
            ここで
            &ldquo;<hostid>ftp.foo.com</hostid>&rdquo;
            はリダイレクト先のホスト名,
            行の最後の
            &ldquo;<symbol>ftp</symbol>&rdquo; はポート名です.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>バンド幅の管理を行なえるツールはどこで手に入れられますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD 用のバンド幅管理ツールには, 無料で手に入れられる
            <ulink URL="http://www.csl.sony.co.jp/person/kjc/programs.html">ALTQ</ulink> と, 
            <ulink URL="http://www.etinc.com/">Emerging Technologies</ulink>
            から入手できる Bandwidth Manager
            という市販のものの 2 種類があります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>なぜ &ldquo;<computeroutput>/dev/bpf0: device not configured</computeroutput>&rdquo;
            が出るのでしょうか?</para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?bpf">バークレーパケットフィルタ(bpf)</ulink>
            ドライバは, それを利用するプログラムを実行する前に有効にしておく必要があります.
            カーネルコンフィグファイルに, 次のように追加してカーネルの再構築をして下さい.
          </para>
  
          <programlisting>pseudo-device bpfilter		# Berkeley Packet Filter</programlisting>
  
          <para>
            そして再起動してから, 次にデバイスノードを作成する必要があります.
            これは, 次のように入力し, <filename>/dev</filename> を変更することで行ないます.
          </para>
  
          <informalexample>
            <screen>&prompt.root; <userinput><command>sh</command> MAKEDEV bpf0</userinput></screen>
          </informalexample>
  
          <para>
            デバイスノードの作成の詳細は,
            <ulink URL="../handbook/kernelconfig-nodes.html">FreeBSD
              ハンドブックの「デバイスノード」</ulink>を参照して下さい.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="ppp">
    <title>PPP</title>

    <qandaset>
      <qandaentry>
        <question id="userppp">
          <para><command>ppp</command> が動きません. どこを間違えているのでしょう?</para>
        </question>

        <answer>
          <para>
            まず
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>
            のマニュアルと,
            <ulink URL="../handbook/ppp-and-slip.html#USERPPP">FreeBSD
              ハンドブックの「PPP」</ulink>を読んでみましょう.
            次に,
            
            <programlisting>set log Phase Chat Connect Carrier lcp ipcp ccp command</programlisting>
  
            という命令を <command>ppp</command>
            のコマンドプロンプトに対して打ち込むか,
            設定ファイル
            <filename>/etc/ppp/ppp.conf</filename>
            に加えて(<symbol>default</symbol>
            セクションの先頭に加えるのが一番良いでしょう)ログを有効にしてみてください.
            その際,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?syslog.conf">/etc/syslog.conf</ulink>
            に

            <programlisting>!ppp
*.*              /var/log/ppp.log</programlisting>
  
            と書かれた行が含まれているか, また,
            <filename>/var/log/ppp.log</filename>
            が存在しているかどうか確かめておいてください.
            さて, これで何が起きているのか突き止めるために,
            ログファイルからたくさんの情報を得られるようになりました.
            ログに訳の分らない部分があっても心配ご無用.
            あなたが助けを求めた誰かにとっては,
            その部分が意味をなす場合があるのです.
  
            <note>
              <title>訳注</title>
              <para>
                ログの取得に syslog を使用するようになったのは
                2.2.5 以降からです. 
              </para>
            </note>
          </para>

          <para>
            使用中の <command>ppp</command> のバージョンで
            &ldquo;<literal>set log</literal>&rdquo;
            命令を解釈しない場合は, <ulink URL="http://people.FreeBSD.org/~brian/">最新版</ulink>をダウンロードすべきです.
            FreeBSD の 2.1.5 以降でビルドできます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>ppp</command> を実行するとハングします</para>
        </question>

        <answer>
          <para>
            ホスト名の解決がうまくいっていないのでしょう. まず,
            リゾルバ(resolver)が
            <filename>/etc/hosts</filename>を参照するように,
            <filename>/etc/host.conf</filename>
            の最初の行に
            <symbol>host</symbol>
            と書き込んでください.
            つぎに, <filename>/etc/hosts</filename>
            に使用しているマシンのエントリを書き加えます.
            ローカルでネットワークを使用していない場合は, 
            <symbol>localhost</symbol>
            の行を以下のように変更してください.
          </para>
  
          <programlisting>127.0.0.1      foo.bar.com foo localhost</programlisting>
  
          <para>
            使用しているホストのエントリを追加してもかまいません. 
            詳細は関連するマンページを参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>ppp</command> が
            <option>-auto</option> モードでダイアルしてくれない</para>
        </question>

        <answer>
          <para>
            まず最初に, デフォルトルートが確立しているかどうかチェックしてください.
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?netstat">netstat -rn</ulink>
            を実行すると, 以下のような情報が表示されるはずです.
          </para>
  
          <screen>Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0</screen>
  
          <para>
            これはあなたがハンドブックやマニュアル,
            <filename>ppp.conf.sample</filename>
            の中で出てくるアドレスを使用していると仮定した場合の例です.
            デフォルトルートが確立していない場合,
            <filename>ppp.conf</filename>
            の中の
            <symbol>HISADDR</symbol>
            が理解できない,
            古いバージョンの
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>
            が走っている可能性があります.
            FreeBSD 2.2.5 より前のバージョンに付属していた
            <command>ppp</command>
            を使用している場合,

            <programlisting>add 0 0 HISADDR</programlisting>
            
            と書かれた行を以下のように修正してください.
  
            <programlisting>add 0 0 10.0.0.2</programlisting>
          </para>
  
          <para>
            <command>netstat -rn</command>
            でデフォルトルートの情報が表示されない場合, もう一つ,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">/etc/rc.conf</ulink>(2.2.2
            より前のリリースでは
            <filename>/etc/sysconfig</filename>
            と呼ばれていました)の中でデフォルトのルータを誤って設定し,
            <filename>ppp.conf</filename> から

            <programlisting>delete ALL</programlisting>
            
            の行をうっかり消してしまった可能性があります. 
            この場合は, 
            <ulink URL="../handbook/ppp-and-slip.html#USERPPP-FINAL">FreeBSD
              ハンドブックの「システムの最終設定」</ulink>の項を読み直してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>&ldquo;<computeroutput>No route to host</computeroutput>&rdquo;
            とはどういう意味ですか?</para>
        </question>

        <answer>
          <para>
            このエラーは通常,
            <filename>/etc/ppp/ppp.linkup</filename>
            に以下のようなセクションが無い場合に起こります.

            <programlisting>MYADDR:
  delete ALL
  add 0 0 HISADDR</programlisting>
          </para>
  
          <para>
            これは動的 <acronym>IP</acronym>
            アドレスを使用している場合,
            またはゲートウェイのアドレスを知らない場合にのみ必要な設定です.
            インタラクティブモードを使用している場合,
            <emphasis>パケットモード</emphasis>に入った後で(プロンプトが
            <acronym>PPP</acronym>
            と大文字に変わったらパケットモードに入ったしるしです),
            以下の命令を入力してください.
          </para>
  
          <screen>delete ALL
add 0 0 HISADDR</screen>
  
          <para>
            詳しい情報については, 
            <ulink URL="../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP">FreeBSD
              ハンドブックの「PPP と動的 IP 設定」</ulink>の項を参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>3 分ほど経つと接続が切れてしまう</para>
        </question>

        <answer>
          <para>
            <command>ppp</command>
            のタイムアウトは デフォルトでは 3 分です.
            これは
          </para>
  
          <programlisting>set timeout <replaceable>NNN</replaceable></programlisting>
  
          <para>
            という命令によって調整することができます.
            <replaceable>NNN</replaceable> には,
            接続が切れるまでのアイドル時間が秒数で入ります.
            <replaceable>NNN</replaceable> が 0 の場合, 
            タイムアウトによる切断は起こりません.
            このコマンドは <filename>ppp.conf</filename> 
            に入れることも,
            インタラクティブモードでプロンプトから入力することも
            できます.
            ソケットを用いる
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?telnet">telnet</ulink> か
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?pppctl">pppctl</ulink> を使用し,
            <command>ppp</command>
            サーバに接続することによって,
            回線がアクティブな間に限定してタイムアウトの時間を調整することも可能です.
            
            <note>
              <title>訳注</title>
              <para>
                <command>pppctl</command> は 2.2.5R からです.
              </para>
            </note>
          </para>

          <para>
            詳しい情報は 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>
            のマニュアルページを参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>負荷が高いと接続が切れてしまう</para>
        </question>

        <answer>
          <para>
            Link Quality Reporting(LQR)の設定を行っている場合,
            マシンと接続先の間で非常にたくさんの <acronym>LQR</acronym>
            パケットが失われている可能性があります. 結果として
            <command>ppp</command> は回線の具合いが悪いと考え,
            回線を切断するのです. 2.2.5 より前のバージョンの FreeBSD では
            <acronym>LQR</acronym>
            はデフォルトで有効になっています.
            現在ではデフォルトの状態で無効です.
            <acronym>LQR</acronym>
            は以下の命令で無効にすることができます.
          </para>
  
          <programlisting>disable lqr</programlisting>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>接続がランダムに切れてしまう</para>
        </question>

        <answer>
          <para>
            ノイズの多い回線, あるいは待ち機能付きの回線では, 
            時々モデムが(誤って)キャリアを失ったと思い込み,
            回線が切断されてしまうことがあります.
          </para>
  
          <para>
            大多数のモデムでは,
            一時的なキャリアの喪失をどれくらいの時間で検出するかを,
            設定で決めることができます.
            例えば USR Sportster では, S10 レジスタ
            の値を 10 倍した秒数がその値になります.
            この場合, モデムをもっとのんびり屋さんにするには,
            <symbol>dial</symbol>
            行に次のような文字列を加えると良いでしょう.
          </para>
  
          <programlisting>set dial "...... ATS10=10 OK ......"</programlisting>
  
          <para>
            詳しくはお使いのモデムのマニュアルをご覧ください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>接続が不規則にハングアップしてしまう</para>
        </question>

        <answer>
          <para>
            たくさんの人が, 原因不明のハングアップを経験しています.
            検証のために必要なのは, まずどちら側のリンクでそれが起こっているか,
            ということです.
          </para>
  
          <para>
            外部接続型モデムを利用しているなら,
            単に <command>ping</command> を使うことで,
            データを送信するときに <acronym>TD</acronym>
            ランプが点灯するかどうかを確認することができます.
            もし, <acronym>TD</acronym> ランプが点灯して,
            <acronym>RD</acronym> ランプが点灯しなければ,
            問題は回線の向こう側にあります. <acronym>TD</acronym> が点灯しなければ,
            問題は回線のこちら側です. 内蔵型モデムの場合,
            <filename>ppp.conf</filename> ファイルに
            <command>set server</command> コマンドを入れる必要があるでしょう.
            回線が切断されたとき, <command>pppctl</command>
            を使って <command>ppp</command>
            に接続してください.
            そのとき,
            ネットワーク接続が急に復旧(診断ソケットへのアクセスで,
            <command>ppp</command> が復活します)するか,
            もしくは接続自体が全くできない(ただし,
            <command>ppp</command>
            起動時に <command>set socket</command>
            コマンドがちゃんと実行されているとします)としたら, 
            問題は回線のこちら側です.
            もし, 接続可能で, かつ状況が変化しなければ,
            <command>set log local async</command>
            を使ってローカル非同期ログ(async logging)を有効にし,
            <command>ping</command>
            を他のウィンドウかターミナルから使ってください.
            非同期ログには, こちら側のリンクの送受信データが記録されます.
            もし, データが送信されたにもかかわらず返って来ていなければ,
            問題は回線の向こう側にあることになります.
          </para>
  
          <para>
            問題が回線のどちら側かにあることが分かったら,
            つぎの二つの可能性が考えられるでしょう.
          </para>
        </answer>
      </qandaentry>  

      <qandaentry>
        <question>
          <para>回線の向こう側での反応がない</para>
        </question>

        <answer>
          <para>
            これに対処できることはほとんどありません. 大部分の ISP
            は, Microsoft 社製 OS 以外の利用者に対してのサポートを拒否するでしょう.
            <filename>ppp.conf</filename> ファイルの中に
            <literal>enable lqr</literal>
            を記述することで
            <command>ppp</command>
            が回線の向こう側で発生する切断を検出することができますが,
            この検出は比較的遅いため, あまり役に立ちません. また, あなたは
            user-ppp を利用していることを
            ISP に知られたくないと思うかも知れませんね.
          </para>
  
          <para>
            まず最初に, こちら側の圧縮機能を全て無効にしてみて下さい.
            それには, 設定ファイルをつぎのようにします.
          </para>
  
          <programlisting>disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj</programlisting>
  
          <para>
            そして再接続し, 変更前と同じように通信できることを確認します.
            もしこれによって状況が改善されるか, 完全に解決したら,
            (上の設定のうち)どの設定で状況が変化したのかを,
            色々な組合せで試してみて下さい. これは, ISP
            に問い合わせを行なうときの有効な情報となります(ただし,
            あなたが Microsoft
            社製品以外のものを利用していることも明らかにしてしまいますが).
          </para>
  
          <para>
            ISP に問い合わせを行なう前に, こちら側の非同期ログを有効にして,
            接続がハングアップするまで待って下さい. この作業は,
            非常に多くのディスク空間を消費するかも知れません.
            興味の対象となっているのは, 通信ポートから最後に読み込まれたデータです.
            それは通常 <acronym>ASCII</acronym> データで,
            問題点の詳細(&ldquo;<computeroutput>Memory fault, core dump</computeroutput>&rdquo;など)が
            記載されている可能性があります.
          </para>
  
          <para>
            回線の向こう側で通信ログを監視することは可能なはずですので,
            切断が発生した時, ISP の対応が好意的ならば
            どうして ISP 側で問題が発生したのかこちらに伝えてくれるかも知れません.
            <email>brian@Awfulhak.org</email>
            まで詳細を送って頂くか, ISP
            に直接私に連絡するように伝えて下さっても構いません.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>ppp</command> がハングアップする</para>
        </question>

        <answer>
          <para>
            ベストな方法は,
            <literal>CFLAGS+=-g</literal> と
            <literal>STRIP=</literal> を
            <command>ppp</command> の
            <filename>Makefile</filename>
            に追加して,
            <command>ppp</command> を再構築し,
            そして
            <literal>make clean &amp;&amp; make &amp;&amp; make install</literal>
            を行なうことです.
            <command>ppp</command> がハングアップした時,
            <literal>ps ajxww | fgrep ppp</literal> を使って
            <command>ppp</command>
            のプロセス ID を調べ,
            <literal>gdb ppp PID</literal> を実行して下さい.
            <command>gdb</command>
            のプロンプトから,
            <command>bt</command>
            を使ってスタックをトレースすることができます.
	  </para>
  
          <para>
            スタックトレースの結果は, <email>brian@Awfulhak.org</email>
            まで送って下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><computeroutput>Login OK!</computeroutput>
            のメッセージが出た後, 何も起こらない</para>
        </question>

        <answer>
          <para>
            2.2.5 より前のリリースの FreeBSD では, 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>
            はリンクが確立した後, 接続先が <acronym>Line Control Protocol(LCP)</acronym>
            を発信するのを待ちます. しかし, 多くの <acronym>ISP</acronym>
            ではネゴシエーションを自分からは起こさず,
            クライアントが起こすのを待っています.
            <command>ppp</command> に強制的に
            <acronym>LCP</acronym> を発信させるには,
            次の命令を使います.
  
            <programlisting>set openmode active</programlisting>
  
            <note>
              <para>
                両方の側がネゴジェーションを起こしても,
                大抵の場合は何の問題もありません.
                ですから, 現在では <symbol>openmode</symbol>
                はデフォルトで <symbol>active</symbol> になっています.
                次のセクションでこれが<emphasis>問題になる場合</emphasis>を説明します.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>でもまだ &ldquo;<computeroutput>magic is the same</computeroutput>&rdquo;
            というエラーが出る</para>
        </question>

        <answer>
          <para>
            時折, 接続直後のログに
            &ldquo;<computeroutput>magic is the same</computeroutput>&rdquo;
            というメッセージがあらわれることがあります.
            このメッセージがあらわれても何も起きない場合もありますし,
            どちらかの側が接続を切ってしまう場合もあります.
            <command>ppp</command> の実装の多くはこの問題に対応できておらず,
            その場合にはちゃんと link が上がっている状態であっても,
            <command>ppp</command> が最終的にあきらめてしまい,
            接続を切るまで設定のリクエストが繰り返し送られ,
            設定が行われたという通知がログファイルに残ると思います.
          </para>
  
          <para>
            これは通常,
            ディスクアクセスの遅いサーバマシンのシリアルポートで
            <command>getty</command> が生きていて,
            <command>ppp</command> がログインスクリプトか,
            ログイン直後に起動されたプログラムから実行されている場合に起こります.
            <command>slirp</command>
            を使用している場合に同様の症状が見られたという報告もあります.
            原因は
            <command>getty</command> の終了されるまでと,
            <command>ppp</command> が実行され,
            クライアント側の
            <command>ppp</command> が
            <acronym>Line Control Protocol(LCP)</acronym>
            を送り始めるまでのタイミングにあります.
            サーバ側のシリアルポートで
            <symbol>ECHO</symbol>
            が有効なままになっているので,
            クライアント側の
            <command>ppp</command>
            にパケットが「反射」してしまうのです.
          </para>
  
          <para>
            <acronym>LCP</acronym>
            ネゴシエーションの一部として,
            リンクの両サイドで
            magic number を定めて,
            「反射」が起きていないかどうか確かめる作業があります.
            規約では, 接続相手がこちらと同じ magic number を提示してきたら,
            <acronym>NAK</acronym> を送って新しい
            magic number を選択しなければならないと定めています.
            この作業の間, サーバのシリアルポートの
            <symbol>ECHO</symbol> がずっと有効になったままなので,
            クライアント側の <command>ppp</command>
            は <acronym>LCP</acronym> パケットを送り,
            パケットが反射して全く同じ magic number
            が送られてくるのを見つけ,
            それに対して <acronym>NAK</acronym>
            を送るのです. 一方 <acronym>NAK</acronym>
            自体も(これは <command>ppp</command>
            が magic number
            を変更しなければいけないことを意味しています)反射してくるので,
            結果として magic number が数えきれないほど変更され,
            その全てがサーバの <acronym>tty</acronym>
            バッファの中に積み重なることになるのです.
            サーバでスタートした <command>ppp</command>
            は, すぐに magic number であふれかえってしまい,
            <acronym>LCP</acronym>
            のネゴシエーションを十分に行ったものと判断して,
            さっさと接続を切ってしまいます.
            一方,
            クライアント側は反射が帰ってこなくなったので満足しますが,
            それもサーバが接続を切ったことを知るまでです.
          </para>
  
          <para>
            この事態は, 以下の行を
            <filename>ppp.conf</filename>
            の中に書いて,
            相手がネゴシエーションを開始できるようにする事によって回避できます.
          </para>
  
          <programlisting>set openmode passive</programlisting>
  
          <para>
            これで <command>ppp</command> はサーバが
            <acronym>LCP</acronym>
            ネゴシエーションを起こすのを待つようになります.
            しかし,
            自分からは決してネゴジェーションを起こさないサーバもあるかもしれません.
            もしこの状況に遭遇した場合には, 次のようにしてください.
          </para>
  
          <programlisting>set openmode active 3</programlisting>
  
          <para>
            これによって <command>ppp</command> は 3 秒間
            passive モードを続けた後で,
            <acronym>LCP</acronym> リクエストを送り始めます.
            この間に相手がリクエストを送り始めた場合には
            3 秒間待たずにこのリクエストに即座に応答します.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>接続が切れるまで <acronym>LCP</acronym>
            のネゴシエーションが続くのですが.</para>
        </question>

        <answer>
          <para>
            現在の <command>ppp</command> は, まだ
            <acronym>LCP</acronym> や
            <acronym>CCP</acronym>,
            <acronym>IPCP</acronym>
            の返事が,
            元のリクエストと連携してくれる機能がきちんと実装されていません.
            その結果, ある
            <command>ppp</command>
            が相手よりも 6 秒以上遅い場合には,
            <acronym>LCP</acronym> 設定ののリクエストをさらに 2 回送ります.
            これは致命的な物です.
          </para>
  
          <para>
            <emphasis>A</emphasis> と <emphasis>B</emphasis>という
            2 つの実装を考えてみましょう.
            <emphasis>A</emphasis> が接続の直後に
            <acronym>LCP</acronym> リクエストを送り,
            一方 <emphasis>B</emphasis> の方はスタートするのに
            7 秒かかったとします. <emphasis>B</emphasis> がスタートする時には
            <emphasis>A</emphasis> は <acronym>LCP</acronym>
            リクエストを 3 回送ってしまっています.
            前の節で述べた magic number の問題が起きないよう,
            <symbol>ECHO</symbol> は <symbol>off</symbol> になっていると考えています.
            <emphasis>B</emphasis> は <acronym>REQ</acronym> を送ります.
            するとこれは <emphasis>A</emphasis> の <acronym>REQ</acronym> のうち,
            最初の物に対する <acronym>ACK</acronym> となります. 
            結果として, <emphasis>A</emphasis>
            は <symbol>OPENED</symbol>
            の状態に入り,
            <emphasis>B</emphasis>
            に対して(最初の) <acronym>ACK</acronym> を送ります.
            そのうちに
            <emphasis>B</emphasis> は,
            <emphasis>B</emphasis>
            がスタートする前に
            <emphasis>A</emphasis>
            から送られたもう 2 つの
            <acronym>REQ</acronym> に対する
            <acronym>ACK</acronym> を送り返します.
            <emphasis>B</emphasis> は
            <emphasis>A</emphasis>
            からの最初の
            <acronym>ACK</acronym> を受け取り
            <symbol>OPENED</symbol> の状態に入ります.
            <emphasis>A</emphasis> は
            <emphasis>B</emphasis> からの
            2 つ目の <acronym>ACK</acronym>
            を受け取りますので,
            <symbol>REQ-SENT</symbol>の状態に戻り,
            さらに, RFC のとおりに(4 つ目の)<acronym>REQ</acronym>
            を送ります. そして 3 つ目の
            <acronym>ACK</acronym>
            を受け取って
            <symbol>OPENED</symbol>
            の状態に入ります.
            一方, <emphasis>B</emphasis>
            は
            <emphasis>A</emphasis>
            からの 4 つ目の
            <acronym>REQ</acronym>
            を受け取りますので,
            <symbol>ACK-SENT</symbol>
            の状態に入り, 2 つ目の
            <acronym>REQ</acronym>
            と 4 つ目の
            <acronym>ACK</acronym> を
            RFC のとおりに送ります.
            <emphasis>A</emphasis>は,
            <acronym>REQ</acronym>
            を受けとると
            <symbol>REQ-SENT</symbol>
            の状態になり, さらに
            <acronym>REQ</acronym>
            を送ります.
            そしてすぐに
            <acronym>ACK</acronym> を受け取って
            <symbol>OPENED</symbol>
            の状態に入ります.
          </para>
  
          <para>
            これが, 片方の
            <command>ppp</command>
            があきらめてしまうまで続きます.
          </para>
  
          <para>
            これを回避する最も良い方法は,
            片方を
            <emphasis>passive</emphasis>
            モードに設定する,
            すなわち反対側がネゴシエーションを開始するまで待つようにする事です. 
            これは, 

            <programlisting>set openmode passive</programlisting>

            というコマンドでできます.
            このオプションは気を付けて使わないといけません. さらに

            <programlisting>set stopped <replaceable>N</replaceable></programlisting>
  
            というコマンドを追加して,
            <command>ppp</command>がnegotiationが開始するまで待つ
            最大の時間を設定してください. もしくは, 

            <programlisting>set openmode active <replaceable>N</replaceable></programlisting>
 
            というコマンド(ここで,
            <replaceable>N</replaceable>
            はネゴシエーションが始まるまで待つ時間)を使うこともできます.
            詳しくはマニュアルページを参照して下さい.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ppp が接続直後に固まってしまう</para>
        </question>

        <answer>
          <para>
            2.2.5 より前のバージョンの FreeBSD では, <command>ppp</command>
            が Predictor1 圧縮のネゴシエーションを誤って解釈して,
            接続直後にリンクを無効にしている可能性があります.
            これは両サイドが異なる
            <acronym>Compression Control Protocols (CCP)</acronym>
            を使ってネゴジェーションを行った場合にのみ発生します.
            この問題は現在は解決していますが, あなたの走らせている
            <command>ppp</command>
            のバージョンが古い場合でも, 次の命令で解決することができます.</para>
  
          <programlisting>disable pred1</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>ppp</command> の内部でシェルを起動しようとすると固まってしまう</para>
        </question>

        <answer>
          <para>
            <command>shell</command> あるいは
            <command>!</command>
            コマンドを使用すると,
            <command>ppp</command>
            はシェルを起動し(何か引数を渡した場合は,
            <command>ppp</command>
            は引数も実行します),
            コマンドが終了するまで処理を中断します.
            コマンドを実行中に <command>ppp</command>
            のリンクを使おうとすると,
            リンクが固まっているように見えますが,
            これは <command>ppp</command> がコマンドの終了を待っているからです.
          </para>
  
          <para>
            このような場合は, 代わりに
            <command>!bg</command>
            コマンドを使用してください.
            与えられたコマンドがバックグラウンドで実行されるので,
            <command>ppp</command>
            はリンクに関するサービスを継続することができます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ヌルモデムケーブルを使用しているとき,
            <command>ppp</command> が終了しない</para>
        </question>

        <answer>
          <para>
            ヌルモデムケーブルを使用して直接接続している場合,
            <command>ppp</command>
            は自動的には接続の終了を知ることができません.
            これはヌルモデムシリアルケーブルの配線に起因しています.
            この種の接続形態を用いる場合は,
            以下の命令を用いて <acronym>LQR</acronym>
            を常に有効にする必要があります.
          </para>
  
          <programlisting>enable lqr</programlisting>
  
          <para>
            こうすると, 接続先がネゴシエーションを行う場合, デフォルトで
            <acronym>LQR</acronym> の使用を受け入れるようになります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>ppp</command> を
            <option>-auto</option> モードで動かすと,
            勝手にダイアルすることがある</para>
        </question>

        <answer>
          <para>
            <command>ppp</command>
            が思いもしないときにダイアルを始める場合, その原因を突き止め,
            防止のためにダイヤルフィルタ(dfilters)をかけてやる
            必要があります.
          </para>
  
          <para>
            原因を突き止めるためには, 以下の命令を使用してください.
          </para>
  
          <programlisting>set log +tcp/ip</programlisting>
  
          <para>
            これで接続を通過する全てのトラフィックをログに残すことができるようになりました.
            次に突然回線がつながったときのログのタイムスタンプをたどれば,
            原因を突き止めることができるはずです.
          </para>
  
          <para>
            原因がわかったら, 次に, このような状況ではダイヤルが起こらないようにしましょう.
            通常, この手の問題は, <acronym>DNS</acronym>
            で名前の解決をしようとしたために起こります.
            <acronym>DNS</acronym> による名前の解決によって,
            接続が行われるのを防止するには,
            次のような手段を用います(これは <command>ppp</command>
            の既に確立した接続に関してパケットのフィルタリングをするものでは<emphasis>ありません</emphasis>).
          </para>
  
          <programlisting>set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0</programlisting>
  
          <para>
            これはデマンドダイヤル機能に問題を生じさせるため,
            常に適切であるとはかぎりません.
            ほとんどのプログラムは他のネットワーク関連の処理をおこなう前に
            <acronym>DNS</acronym>
            への問い合わせが必要になります.
          </para>
  
          <para>
            <acronym>DNS</acronym> の場合は,
            何が実際にホスト名を検索しようとしているのかを突き止めるべきでしょう.
            大抵の場合は,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sendmail">sendmail</ulink>
            が犯人です.
            設定ファイルで sendmail が
            <acronym>DNS</acronym> に問い合わせないようになっているか確認すべきです.
            自分用の設定ファイルを作成するための詳しい方法は,
            <link linkend="ispmail">メールの設定</link> の項をご覧ください.
            または,
            <filename>.mc</filename>
            ファイルに次のような行を追加してもよいでしょう.
          </para>
  
          <programlisting>define(`confDELIVERY_MODE', `d')dnl</programlisting>
          
          <para>
            この行を追加すると, sendmail
            はメールキューを処理する(通常
            sendmail は 30 分ごとにキューを処理するよう,
            &ldquo;<option>-bd -q30m</option>&rdquo;
            というオプションを付けて起動されます)までか,
            または(多分 <filename>ppp.linkup</filename> というファイルの中で)
            &ldquo;<command>sendmail -q</command>&rdquo;
            というコマンドが実行されるまで,
            全てのメールをキューに溜めるようになります.

            <note>
              <title>訳注</title>
              <para>
                &ldquo;<command>sendmail -q</command>&rdquo;
                はその時点のメールキューの内容を処理して終了します.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><acronym>CCP</acronym>
            エラーとはどういう意味ですか</para>
        </question>

        <answer>
          <para>
            ログファイル中の以下のエラーは,
  
            <programlisting>CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)</programlisting>
  
            のネゴシエーションにおいて <command>ppp</command> は
            Predictor1 圧縮を用いるべく主張したのに対して,
            接続先は圧縮を使用しないことを主張した場合に起こります.
            このメッセージには何の害もありませんが,
            出るのが嫌なら, 以下の命令を用いてこちら側でも
            Predictor1 圧縮を無効にすることで対応できます.
          </para>
  
          <programlisting>disable pred1</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ファイル転送の途中で, <command>ppp</command> が
            IO エラーを出して固まってしまう</para>
        </question>

        <answer>

          <para>
            FreeBSD 2.2.2 以前のバージョンの <devicename>tun</devicename>
            ドライバには, <devicename>tun</devicename>
            インタフェースの <acronym>MTU</acronym>
            のサイズより大きなパケットを受け取ることができないというバグがありました.
            <acronym>MTU</acronym>
            のサイズより大きなパケットを受け付けると IO エラーが起こり,
            <command>syslogd</command> 経由で記録されるのです.
          </para>
  
          <para>
            <command>ppp</command> の仕様では,
            <acronym>LCP</acronym>
            のネゴシエーションを行う場合を含む<emphasis>どのような場合でも</emphasis>最低
            1500 オクテットの
            <acronym>Maximum Receive Unit (MRU)</acronym>
            を受け入れる必要があります.
            ですから, <acronym>MTU</acronym> を
            1500 以下に設定した場合でも, ISP はそれに関係なく
            1500 の大きさのパケットを送ってくるでしょう.
            そしてこのイケてない機能にぶちあたって,
            リンクが固まるのを目にすることになるのです.
          </para>
  
          <para>
            FreeBSD 2.2.2 以前のバージョンでは, <acronym>MTU</acronym>
            を決して 1500 より小さくしないことで,
            この問題を回避することができます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どうして <command>ppp</command>
            は接続速度をログに残さないんでしょう?</para>
        </question>

        <answer>
          <para>
            モデムとの「やり取り」全ての行をログに残すには,
            以下のようにして接続速度のログの有効化を行ってください.
          </para>
  
          <programlisting>set log +connect</programlisting>
  
          <para>これは
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>
            に最後にくることが要求されている &ldquo;<literal>expect</literal>&rdquo;
            という文字列がくるまでのすべてのものをログに記録させます.
          </para>
  
          <para>
            接続速度はログにとりたいけれど, <acronym>PAP</acronym>
            や <acronym>CHAP</acronym>
            を使っている(その結果, ダイヤルスクリプト中の
            <literal>CONNECT</literal>
            以降に全く「やりとり」を行わない - &ldquo;<literal>set login</literal>&rdquo;
            スクリプトには何も書かない)のであれば,
            <command>ppp</command> に
            &ldquo;<literal>expect</literal>&rdquo;
            を含んだ <literal>CONNECT</literal>
            行全てがくるまで待たせるようにしないといけません,
            以下のようになります.
          </para>
  
          <programlisting>set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"</programlisting>
  
          <para>
            ここで, <literal>CONNECT</literal> を受信してから,
            何も送らず, 復帰改行(linefeed)を待っています,
            <command>ppp</command> に <literal>CONNECT</literal>
            の応答全てを読み込ませているわけです.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私の <literal>chat</literal> スクリプトでは
            &ldquo;<literal>\</literal>&rdquo;
            という文字を <command>PPP</command> が解釈してくれません.</para>
        </question>

        <answer>
          <para>
            <command>PPP</command> は設定ファイルを読み込むときに,
            <literal>set phone "123 456 789"</literal>
            のような文字列を正しく解釈し,
            番号が実際に<emphasis>1 つの</emphasis>引数であると理解します.
            &ldquo;&quot;&rdquo;
            という文字を指定するには, バックスラッシュ(backslash;
            &ldquo;<literal>\</literal>&rdquo;)でエスケープしなければなりません.
          </para>
  
          <para>
            <literal>chat</literal> の各引数が解釈されるときには,
            &ldquo;<literal>\P</literal>&rdquo;
            や
            &ldquo;<literal>\T</literal>&rdquo;
            のような特別なエスケープシーケンス(マニュアルページ参照のこと)を見付けるために,
            もう 1 回, 字句解析を行います.
            このように字句解析は 2 回繰り返されますので,
            正しい回数だけエスケープ処理を行わないといけません.
          </para>
  
          <para>
            モデムにたとえば &ldquo;<literal>\</literal>&rdquo;
            のような文字を送りたい場合には,
            次のようにする必要があります.</para>
  
          <programlisting>set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"</programlisting>
  
          <para>
            実際にモデムに送られる文字列は次のようになります.
          </para>
          
          <programlisting>ATZ
OK
AT\X
OK</programlisting>
  
          <para>
            他の例ですと
  
            <programlisting>set phone 1234567
              set dial "\"\" ATZ OK ATDT\\T"</programlisting>
  
            は次のようになります.
  
            <programlisting>ATZ
OK
ATDT1234567</programlisting>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>ppp</command> が
            <computeroutput>segmentation fault</computeroutput> になるのですが,
            <filename>ppp.core</filename> ファイルがありません</para>
        </question>

        <answer>
          <para>
            <command>ppp</command>(や他のプログラム)は決して
            core を吐いてはいけません.
            <command>ppp</command>
            は実効 uid が 0 で動いていますので,
            オペレーティングシステムは <command>ppp</command>
            を終了させる前にディスクに core イメージを書き込みません.
            しかし <command>ppp</command>
            は実際にはセグメンテーション違反や,
            他の core を吐く原因となるようなシグナルによって<emphasis>終了して</emphasis> おり,
            <emphasis>さらに</emphasis>最新のバージョン(このセクションの始めを見てください)を使用しているならば,
            次のようにしてください.
          </para>
  
          <screen>&prompt.user; <userinput><command>tar</command> xfz ppp-*.src.tar.gz</userinput>
&prompt.user; <userinput><command>cd</command> ppp*/ppp</userinput>
&prompt.user; <userinput><command>echo</command> STRIP= &gt;&gt; Makefile</userinput>
&prompt.user; <userinput><command>echo</command> CFLAGS+=-g &gt;&gt; Makefile</userinput>
&prompt.user; <userinput><command>make</command> clean all</userinput>
&prompt.user; <userinput><command>su</command></userinput>
&prompt.root; <userinput><command>make</command> install</userinput>
&prompt.root; <userinput><command>chmod</command> 555 /usr/sbin/ppp</userinput></screen>
  
          <para>
            これでデバッグ可能なバージョンの
            <userinput>ppp</userinput> がインストールされます.
            <username>root</username> で
            <command>ppp</command> を実行し,
            全ての特権が無効になっているようにする必要があるでしょう.
            <command>ppp</command> を実行する時には,
            カレントディレクトリが <command>make</command>
            したディレクトリであるようにしてください.
          </para>
  
          <para>
            これで, <command>ppp</command>
            がセグメンテーション例外を受け取ったときには
            <filename>ppp.core</filename>
            という名前の
            core ファイルを吐くようになります. core が
            吐かれたら次のようにしてください.
          </para>
  
          <screen>&prompt.user; <userinput><command>su</command></userinput>
&prompt.root; <userinput><command>gdb</command> /usr/sbin/ppp ppp.core</userinput>
<prompt>(gdb)</prompt> <userinput>bt</userinput>
.....
<prompt>(gdb)</prompt> <userinput>f 0</userinput>
.....
<prompt>(gdb)</prompt> <userinput>i args</userinput>
.....
<prompt>(gdb)</prompt> <userinput>l</userinput>
.....</screen>
  
          <para>
            質問する際には, これら全ての情報を提供して,
            問題点の分析ができるようにしてください.
          </para>
  
          <para>
            <command>gdb</command>
            の使い方に慣れている場合には, 実際に dump
            の原因となった理由やそのアドレス,
            関連した変数の値なども調べる事ができるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>auto モードでダイアルをするようなプロセスが接続されない.
          </para>
        </question>

        <answer>
          <para>
            これは <command>ppp</command>
            がローカル側の <acronym>IP</acronym> アドレスを,
            動的に通信相手と交渉するように設定されている時に発生する良く知られた障害でした.
            最新のバージョンでは,
            この問題は修正されています.
            <symbol>iface</symbol>
            をマニュアルページから検索してみて下さい.
          </para>
  
          <para>
            これは, 最初のプログラムが
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?connect">connect(2)</ulink>
            を呼び出した時, <devicename>tun</devicename>
            インターフェイスの <acronym>IP</acronym> アドレスが,
            ソケットの終端に割り当てられてしまうという問題です.
            カーネルは,
            外へ出ていく最初のパケットを作り, それを <devicename>tun</devicename>
            デバイスへ書き込みます.
            そして <command>ppp</command> は,
            そのパケットを読み込んで接続を確立します.
            <command>ppp</command>
            は動的に <acronym>IP</acronym>
            アドレスを割り当てるため,
            もしインターフェイスのアドレスが変化してしまうと,
            最初に割り当てられたソケット終端の <acronym>IP</acronym>
            アドレスは無効になってしまいます.
            そのため, それ以降相手に送られる全てのパケットは通常,
            相手に届くことはないでしょう. もし仮に届いたとしても,
            既にこちらの <acronym>IP</acronym> アドレスは変更されているので,
            どんな反応も最初のマシンには戻ってきません.
          </para>
  
          <para>
            この問題に対処する理論的な方法がいくつかあります. もし可能なら, 
            相手が再度, 同じ <acronym>IP</acronym>
            アドレスを割り当ててくれることが一番です <literal>:-)</literal>
            <command>ppp</command>
            の現在のバージョンはこれを行ないますが,
            他のほとんどの実装はそういった動作をしません.
          </para>
  
          <para>
            我々の側から対処できる最も簡単な方法は, <devicename>tun</devicename>
            インターフェイスの
            <acronym>IP</acronym> アドレスを固定する事です. またそのかわりに,
            外に出ていくパケットを変更して,
            発信元 <acronym>IP</acronym>
            アドレスをインターフェイスの <acronym>IP</acronym>
            アドレスから, 交渉によって得られた <acronym>IP</acronym> アドレスに,
            適宜書きかえる事によっても対処できます.
            これは, 基本的に
            <command>ppp</command> の最新バージョンにある <symbol>iface-alias</symbol>
            オプションが行なっていることと同じです(<ulink URL="http://www.FreeBSD.org/cgi/man.cgi?libalias">libalias(3)</ulink>
            および, <command>ppp</command> の <option>-alias</option>
            スイッチにも関係します). それは, 以前の <acronym>IP</acronym>
            アドレスを全て管理し,
            それらを最後の交渉によって得られた <acronym>IP</acronym>
            アドレスの別名として扱えるようにします.</para>
  
          <para>
            もう 1 つの(おそらく最も信頼できる)方法は, bind された
            全てのソケットの <acronym>IP</acronym> アドレスを,
            異なるものに変更できるシステムコールを実装することです.
            <command>ppp</command>は,
            交渉によって新しい <acronym>IP</acronym> アドレスを得た時,
            このシステムコールを用いて実行されているプログラムにある,
            全てのソケットを書きかえてやるわけです.
            同じシステムコールが, <acronym>DHCP</acronym> クライアントが利用するソケットを
            強制的に再 bind するのにも使うことができるでしょう.
          </para>
  
          <para>
            3 つ目の方法は, <acronym>IP</acronym>
            アドレスを指定しないでインターフェイスを利用できるようにすることです.
            外に出ていくパケットは, 最初の <symbol>SIOCAIFADDR</symbol>
            ioctl の完了まで,
            255.255.255.255 という <acronym>IP</acronym> アドレス が与えられます.
            これによって. ソケットは常に bind することができます.
            <command>ppp</command> に対して発信元
            <acronym>IP</acronym> アドレスを変更させる事になりますが,
            もしそれが 255.255.255.255 になっていたら, <acronym>IP</acronym> アドレスと
            <acronym>IP</acronym> チェックサムだけ変更すれば良ければの話になります.
            この方法はちょっとした変更ですが,
            他の機構が今までのように, <acronym>IP</acronym>
            アドレスを固定して利用する場合に,
            カーネルが不適切に設定されたインターフェイスに向けて,
            正常でないパケットを送り出してしまう可能性があります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>何故ほとんどのゲームが
            <option>-alias</option> スイッチ付きだと動かないんですか?</para>
        </question>

        <answer>
          <para>
            <note>
              <title>訳注</title>
              <para>
                <!-- hrs:2000/03/10 this link is obsolete. -->
                この問題は佐藤 淳一さん作の <acronym>NAT</acronym>
                パッチを使っても解決できます. 
                <ulink URL="http://www2a.biglobe.ne.jp/~junichi/freebsd/lowtech/nat.html">NAT on iij-ppp</ulink>をご覧ください. 
              </para>
            </note>

            libalias を使っている時にゲームなどの類のものが動作しない理由は, 
            外側にあるマシンが接続しようとしているか, 内側にあるマシンに
            (余計な)UDP パケットを送信しようとしているからです. 
            内側のマシンにこれらのパケットを送るべきかについて, 
            packet alias ソフトウェアは関知しません.
          </para>
  
          <para>
            うまく動かすためには,
            実行中のものが問題の発生しているソフトウェアだけであるかを確認し,
            ゲートウェイの <devicename>tun</devicename> インタフェースに対して 
            <command>tcpdump</command> を実行するか,
            ゲートウェイ上で <command>ppp</command> の
            <acronym>TCP</acronym>/<acronym>IP</acronym>
            ログ記録を有効化(&ldquo;<literal>set log
              +tcp/ip</literal>&rdquo;)してください. </para>
  
          <para>
            行儀の悪いソフトウェアを起動する際に,
            ゲートウェイマシンを通過するパケットを監視すべきです.
            外側から何かパケットが戻ってきた時に, 
            そのパケットは破棄されるでしょう(それが問題なのです). 
            これらのパケットのポート番号に注意して,
            その行儀の悪いソフトウェアを停止してください. 
            これを数回繰り返してポート番号が常に同じであるかを確認してみてください. 
            同じであった場合は,
            <filename>/etc/ppp/ppp.conf</filename>
            の適切なセクションに次の行を入れると, 
            そのソフトウェアは動作するようになるでしょう.
          </para>
  
          <programlisting>alias <replaceable>port</replaceable> <replaceable>proto</replaceable> <replaceable>internalmachine</replaceable>:<replaceable>port</replaceable> <replaceable>port</replaceable></programlisting>
  
          <para>
            ここで &ldquo;<replaceable>proto</replaceable>&rdquo; は
            &ldquo;<symbol>tcp</symbol>&rdquo; か
            &ldquo;<symbol>udp</symbol>&rdquo; であり,
            &ldquo;<replaceable>internalmachine</replaceable>&rdquo;
            はパケットを送りたいマシン, そして
            &ldquo;<replaceable>port</replaceable>&rdquo;
            はパケットの送信先のポート番号です.
          </para>
  
          <para>
            上記のコマンドを変更せずに,
            他のマシン上でそのソフトウェアを使用できるようにはしたくないかもしれません.
            そして同時に二つの内部のマシン上でそのソフトウェアを実行することは,
            この質問の範囲を超えています. 結局, 外側の世界からは,
            内部ネットワーク全体がただ一つのマシンとして見えるのです.
          </para>
  
          <para>
            ポート番号が常に同じとは限らない場合, さらに三つのオプションがあります.
          </para>
  
          <orderedlist>
            <listitem>
              <para>
                libalias でサポートするようにし, 結果を送り付ける.
                特定の場合の例は <filename>/usr/src/lib/libalias/alias_*.c</filename>
                にあります(<filename>alias_ftp.c</filename>
                は良いプロトタイプです). これには通常, 外向きの特定のパケットを読み,
                内部の計算機のある特定のポートへの接続を開始するような命令が,
                外部の計算機対して送られていることを見分け,
                後続のパケットがどこに行けばいいのかが分かるように,
                エイリアステーブル中の &ldquo;<replaceable>route</replaceable>&rdquo; の部分を設定する,
                という作業が含まれます.
              </para>
  
              <para>
                これは最も難しい方法ですが, 最も良い方法でもありますし, ソフトウェアが
                複数の計算機で動くようにできます.
              </para>              
            </listitem>

            <listitem>
              <para>プロキシ(proxy)を使う. アプリケーションが, 例えば socks5
                をサポートしているか, (cvsup のように) &ldquo;passive&rdquo;
                オプションを持っているとこの方法が使えます.
                &ldquo;passive&rdquo;
                とは相手側のほうから接続を求めてくることを避けるためにあるオプションです.
              </para>
            </listitem>

            <listitem>
              <para>
                &ldquo;<literal>alias addr</literal>&rdquo;
                を使ってなんでもかんでも内部の計算機に向けて流してしまう.
                これはちょっと無理矢理な解決法です.
              </para>
            </listitem>
          </orderedlist>
        </answer>
      </qandaentry>  

      <qandaentry>
        <question>
          <para>有用なポート番号のリストはありませんか?</para>
        </question>

        <answer>
          <para>
            まだ出来ていません. しかし,
            これは(関心を持って頂けるならば)そういったリストにしていく予定です.
            それぞれの例にある
            <replaceable>internal</replaceable> は,
            ゲームで遊ぶマシンの <acronym>IP</acronym> アドレスに置き換えて下さい.  
          </para>

          <para>
            <variablelist>
              <varlistentry>
                <term>Quake</term>
                <listitem>
                  <programlisting>alias port udp <replaceable>internal</replaceable>:6112 6112</programlisting>

                  <para>このように設定する代わりに,
                    <ulink URL="http://www.battle.net/support/proxy/">www.battle.net</ulink>
                    で Quake のプロキシ(proxy)がサポートされているか調べてもいいでしょう.
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Quake2</term>
                <listitem>
                  <programlisting>alias port udp <replaceable>internal</replaceable>:27901 27910</programlisting>

                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Red Alert</term>
                <listitem>
                  <programlisting>alias port udp <replaceable>internal</replaceable>:8675 8675
alias port udp <replaceable>internal</replaceable>:5009 5009</programlisting>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Half Life</term>
                <listitem>
                  <programlisting>alias port udp <replaceable>internal</replaceable>:27005 27015</programlisting>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>PCAnywhere 8.0</term>
                <listitem>
                  <programlisting>alias port udp <replaceable>internal</replaceable>:5632 5632
alias port tcp <replaceable>internal</replaceable>:5631 5631</programlisting>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><acronym>FCS</acronym> エラーって何?</para>
        </question>

        <answer>
          <para>
            <acronym>FCS</acronym> とは
            Frame Check Sequence(フレームチェックシーケンス)の略です.
            個々の <command>ppp</command> パケットには,
            送受信するデータが正しいかを調べるためのチェックサムが含まれています.
            受信したパケットの <acronym>FCS</acronym> が正しくない場合は, そのパケットは廃棄され,
            <acronym>HDLC</acronym> <acronym>FCS</acronym> カウントが増やされます.
            <acronym>HDLC</acronym> エラーの数 は,
            <command>show hdlc</command>
            コマンドを使って表示できます.
          </para>
  
          <para>
            リンクの品質が悪かったり,
            シリアルドライバがパケットを取りこぼしていたりすると,
            <acronym>FCS</acronym> エラーがたびたび発生します.
            <acronym>FCS</acronym> エラーは,
            圧縮プロトコルの速度低下の原因にはなりますが,
            特に心配する必要はありません.
            外付けモデムを使っている場合は,
            ケーブルがちゃんとシールドされているかを確認してください.
            そうでない場合,
            <acronym>FCS</acronym> エラーの原因となる場合があります.
          </para>
  
          <para>
            接続直後からリンクがフリーズし, 大量の
            <acronym>FCS</acronym> エラーが発生する場合は,
            リンクが 8 ビットクリーンでない可能性があります.
            ソフトウェアフロー制御(<symbol>XON/XOFF</symbol>)
            が使われていないことを確認してください.
            どうしてもソフトウェアフロー制御を使わなければならない場合は,
            <literal>set accmap 0x000a0000</literal> コマンドを使用して,
            <command>ppp</command> に
            <literal>^Q</literal> と
            <literal>^S</literal> をエスケープさせてください.
          </para>
  
          <para>
            リモートホストが <acronym>PPP</acronym>
            プロトコルを使用してない場合も, 大量の
            <acronym>FCS</acronym> エラーが発生します.
            この場合はログをとりながら<emphasis>非同期</emphasis>で接続し,
            ログインプロンプトやシェルプロンプトが送られて来ていないか確認してください.
          </para>
  
          <para>
            ログファイルにリンクを終了した原因となるような記録がない場合は,
            リモートホスト(プロバイダ?)の管理者に,
            セッションを終了された理由を尋ねてください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どれにも当てはまらない! どうしたらいいの?</para>
        </question>

        <answer>
          <para>
            これまでの全ての質問に当てはまらない場合, 設定ファイル,
            <command>ppp</command>
            の実行方法, ログファイルの該当部分と
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?netstat">netstat -rn</ulink>
            コマンドの出力 (接続前と接続後) を含む,
            あなたの持っている全ての情報を
            <ulink URL="mailto:freebsd-questions@FreeBSD.org">freebsd-questions@FreeBSD.org</ulink>
            メーリングリストや
            <ulink URL="news:comp.unix.bsd.freebsd.misc">comp.unix.bsd.freebsd.misc</ulink>
            ニュースグループへ送ってください. 誰かがあなたを正しい方向へ導いてくれるでしょう.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="serial">
    <title>シリアル接続</title>

    <para>
      <emphasis>訳:
        一宮 亮 <email>ryo@azusa.shinshu-u.ac.jp</email>,
        1997 年 11 月 16 日.</emphasis>
    </para>
  
    <para>
      このセクションでは, FreeBSD でシリアル接続をする時の一般的な質問に答えます.
      <acronym>PPP</acronym> および
      <acronym>SLIP</acronym> については,
      <xref linkend="networking" remap="ネットワーキング">のセクションを参照してください.
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>どうやったら FreeBSD がシリアルポートを認識したことを知る事ができますか?</para>
        </question>

        <answer>
          <para>
            FreeBSD のカーネルがブートする時, カーネルはその設定にしたがって,
            システムのシリアルポートを検出します. 起動時に表示されるメッセージをよく観察するか,
            起動後に次のコマンドを実行する事によって確認できます.
          </para>
  
          <screen>dmesg | grep sio</screen>
  
          <para>ここに上に挙げたコマンドの出力例を示します.</para>
  
          <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A</screen>

          <para>
            これは, 二つのシリアルポートを示しています. 1 番めは,
            irq が 4 で <literal>0x3f8</literal> のポートアドレスを使用しています.
            そして, 16550A-type UART チップが存在します.
            2 番目は, 同じチップを使っていますが,
            irq は 3 で, <literal>0x2f8</literal>
            のポートアドレスを使用しています. 内蔵のモデムカードは,
            通常のシリアルポートと同じように扱われますが,
            常時シリアルポートにモデムが接続されているという点で異なります.
          </para>
  
          <para>
            GENERIC カーネルは, 上の例と同じ irq
            とポートアドレスの設定の二つのシリアルポートをサポートしています.
            これらの設定があなたのシステムに合わない場合,
            またはモデムカードを追加した場合やカーネルの設定以上にシリアルポートを持っている場合は,
            カーネルを再構築してください.
            詳しくは,
            <link linkend="make-kernel">カーネルの構築</link>の項を参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            どうやったら FreeBSD がモデムカードを認識したことを知ることができますか?</para>
        </question>

        <answer>
          <para>
            前の質問を参照してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD 2.0.5 にアップグレードしたら <devicename>tty0X</devicename>
            が見つからなくなってしまったのですが</para>
        </question>

        <answer>
          <para>
            心配ありません. <devicename>ttydX</devicename> に統合されました.
            ただ, 古い設定ファイルのすべてを更新する必要があります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どうやったら FreeBSD でシリアルポートにアクセスできますか?</para>
        </question>

        <answer>
          <para>
            3 番目のポート
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sio">sio2</ulink>(DOS
            では, <symbol>COM3</symbol> と呼ばれます.) には,
            ダイヤルアウトデバイスとしては <filename>/dev/cuaa2</filename>,
            ダイヤルインデバイスとして <filename>/dev/ttyd2</filename> があります.
            それではこの両者にはどのような違いがあるのでしょうか?
          </para>
  
          <para>
            まず, ダイヤルインの時には <symbol>ttydX</symbol> を使います.
            <filename>/dev/ttydX</filename> をブロッキングモードでオープンすると,
            プロセスは対応する <devicename>cuaaX</devicename>
            デバイスがインアクティブになるのを待ちます.
            次に <acronym>CD</acronym> 信号がアクティブになるのを待ちます.
            <devicename>cuaaX</devicename>
            デバイスをオープンすると, シリアルポートが
            <devicename>ttydX</devicename>
            デバイスによってすでに使われていないかどうかを確認します.
            もしこのポートが使用可能であれば, ポートの使用権を
            <devicename>ttydX</devicename> から「奪い取る」のです.
            また, <devicename>cuaXX</devicename>
            デバイスは <acronym>CD</acronym> 信号を監視しません.
            この仕組みと自動応答モデムによって,
            リモートユーザーをログインさせたり,
            同じモデムでダイヤルアウトしたりすることができ,
            システムのあらゆるトラブルの面倒を見ることができるでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>マルチポートシリアルカードをサポートさせるにはどうしたらよいのでしょうか?</para>
        </question>

        <answer>
          <para>
            繰り返しになりますが,
            <link linkend="make-kernel">カーネルコンフィグレーション</link>のセクションでは,
            あなたのカーネルの設定についての情報が得られるでしょう.
            マルチポートシリアルカードを使用するためには, カーネルの設定ファイルに,
            カードの持つそれぞれのシリアルポートに対応する
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sio">sio</ulink>
            の行を記述する必要があります. しかし,
            irq とベクタアドレスは一つのエントリにのみ記述してください.
            カード上のすべてのポートは一つの irq を共有しなければなりません.
            一貫性を持たせるためにも,
            最後のシリアルポートの所で irq を指定してください.
            また, <symbol>COM_MULTIPORT</symbol> オプションも付けてください.
          </para>
  
          <para>
            次に示す例は, AST の 4 ポートシリアルカードを irq 7 で設定したものです.
          </para>
  
          <programlisting>options "COM_MULTIPORT"
device sio4 at isa? port 0x2a0 tty flags 0x781
device sio5 at isa? port 0x2a8 tty flags 0x781
device sio6 at isa? port 0x2b0 tty flags 0x781
device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr</programlisting>
  
          <para>
            このフラグはマスタポートがマイナー番号
            7(<literal>0x700</literal>) を持っていて,
            検出時の診断機能を有効にし(<literal>0x080</literal>),
            そしてすべてのポートで irq
            を共有する(<literal>0x001</literal>)ということを意味しています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD で複数のマルチポートシリアルカード間で
            irq を共有することはできますか?</para>
        </question>

        <answer>
          <para>
            現在のところはできません. それぞれのカード毎に異なった irq
            を使ってください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            ポートにデフォルトのパラメータを設定する事は出来ますか?</para>
        </question>

        <answer>
          <para>
            <devicename>ttydX</devicename> デバイス(または
            <devicename>cuaaX</devicename> デバイス)は,
            アプリケーションのためにオープンする標準的なデバイスです.
            プロセスがそのポートをオープンする時,
            プロセスはデフォルトの端末 I/O 設定を取得します.
            これらの設定は次のコマンドで確認することができます.
          </para>
  
          <programlisting>stty -a -f /dev/ttyd1</programlisting>
  
          <para>
            このデバイスに対する設定を変更した場合,
            その設定はデバイスをクローズするまで有効です.
            デバイスを再オープンした場合, それらの設定はデフォルトに戻ってしまいます.
            デフォルトの設定に変更を加えるために,
            「初期設定」デバイスをオープンし,
            設定を修正することができます.
            例えば, <symbol>CLOCAL</symbol> モード, 8 ビット,
            <literal>XON/XOFF</literal>
            フロー制御という設定を
            <devicename>ttyd5</devicename>
            のデフォルトにしたい場合, 次のようにおこなってください.
          </para>
  
          <programlisting>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</programlisting>
  
          <para>
            この設定をおこなうためのコマンドを記述するのに適切なファイルは,
            <filename>/etc/rc.serial</filename> です.
            これでアプリケーションが
            <devicename>ttyd5</devicename> をオープンした時に,
            これらの設定をデフォルトで取得します.
            しかし, こういったリンクによる設定は変更可能です.
          </para>
  
          <para>
            「設定固定」デバイスを調整してやることによって,
            アプリケーションによる設定の変更を禁止することができます.
            例えば, <devicename>ttyd5</devicename>
            の通信速度を 57600bps
            に固定するには, 次のように行ってください.
          </para>
  
          <programlisting>stty -f /dev/ttyld5 57600</programlisting>
  
          <para>
            これにより, アプリケーションは <devicename>ttyd5</devicename>
            をオープンし, ポートの通信速度を変更しようとしますが,
            通信速度は 57600bps のままになります.
          </para>
  
          <para>
            当然のことながら, 初期設定デバイスおよび, 設定固定デバイスは
            <username>root</username> のみが書き込みできるようになっていなければなりません. 
            しかし, <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV">MAKEDEV</ulink>
            スクリプトはデバイスエントリを作成する時に, 
            このような設定は行いません.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どのようにしたらモデム経由でダイヤルアップログインができるのでしょうか?</para>
        </question>

        <answer>
          <para>
            つまり, インターネットサービスプロバイダーになりたいのですね. 
            それにはまず, 1 台ないし複数の自動応答モデムが必要です. 
            モデムには, キャリアーを検出した時には
            <acronym>CD</acronym> 信号を出力し,
            そうでない場合には出力しないことが必要とされます.
            また <acronym>DTR</acronym> 信号が
            on から off になった時には,
            電話回線を切断し, モデム自身をリセットしなければなりません. 
            おそらく, <acronym>RTS/CTS</acronym> フロー制御を使うか,
            ローカルフロー制御をまったく使わないかのどちらかでしょう.
            最後に, コンピュータとモデムの間は固定速度でなければなりません.
            ただ, (ダイヤルアップの発呼者に対して親切であるためには,
            )こちらのモデムと相手側のモデムの間の速度を,
            モデム間で自動調整できるようにすべきでしょう.
          </para>
  
          <para>
            多くあるヘイズコマンド互換モデムに対して, 次のコマンドはこれらの設定をおこない,
            その設定を不揮発性メモリーに保存します.
          </para>
  
          <programlisting>AT&amp;C1&amp;D3&amp;K3&amp;Q6S0=1&amp;W</programlisting>
  
          <para>
            MS-DOS のターミナルプログラムに頼らずに AT コマンドを送出するには,
            <link linkend="direct-at">「AT
              コマンドを入力するには」</link>のセクションを参照してください.
          </para>
  
          <para>
            次に, モデム用のエントリを
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
            に作成しましょう. 
            このファイルには,
            オペレーティングシステムがログインを待っているすべてのポートが記述されています.
            以下のような行を追加してください.
          </para>
  
          <programlisting>ttyd1 "/usr/libexec/getty std.57600" dialup on insecure</programlisting>
  
          <para>
            この行は, 2 番目のシリアルポート(<filename>/dev/ttyd1</filename>)には,
            57600bps の通信速度でノンパリティ(<literal>std.57600</literal>:
            これは
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?gettytab">/etc/gettytab</ulink>
            に記述されています)のモデムが接続されていることを示しています.
            このポートの端末タイプは &ldquo;<symbol>dialup</symbol>&rdquo; です.
            またこのポートは, &ldquo;<symbol>on</symbol>&rdquo;
            すなわちログイン可能であり,
            &ldquo;<symbol>insecure</symbol>&rdquo;
            これは <username>root</username>
            がこのポートから直接ログインするのは,
            許可されていないということを意味します.
            このようなダイヤルインポートに対しては, 
            <devicename>ttydX</devicename> のエントリを使用してください.
          </para>
  
          <para>
            これが一般的な, ターミナルタイプとして &ldquo;<symbol>dialup</symbol>&rdquo;
            を使う方法です. 多くのユーザーは,
            <filename>.profile</filename> や
            <filename>.login</filename> で,
            ログイン時の端末タイプが
            <symbol>dialup</symbol> であった場合には,
            実際の端末タイプをユーザーに問い合わせるように設定しています.
            この例は, ポートが &ldquo;<symbol>insecure</symbol>&rdquo;
            でした. このポートで <username>root</username> になるには,
            一般ユーザーとしてログインし, それから
            &ldquo;<ulink URL="http://www.FreeBSD.org/cgi/man.cgi?su">su</ulink>&rdquo; を使って
            <username>root</username> になってください.
            もし, &ldquo;<symbol>secure</symbol>&rdquo;
            を指定したならば,
            直接 <username>root</username> がそのポートからログインできます.
          </para>
  
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
            に変更を加えた後は, <acronym>HUP</acronym> シグナル(SIGHUP)を
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?init">init</ulink>
            プロセスに送る必要があります.
          </para>
  
          <screen>&prompt.root; <userinput><command>kill</command> -HUP 1</userinput></screen>
  
          <para>
            この操作は init プロセスに
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
            を再読み込みさせます. 
            これにより, init プロセスは
            <command>getty</command> プロセスをすべての
            &ldquo;<symbol>on</symbol>&rdquo;
            となっているポートに起動させます.
            次のようにして, ポートがログイン可能かを知ることができます.
          </para>
  
          <screen>&prompt.user; <userinput><command>ps</command> <option>-ax</option> | <command>grep</command> '[t]tyd1'</userinput></screen>
          
          <para>
            ログイン可能であれば, 次のような出力が得られるはずです.
          </para>
  
          <screen>747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1</screen>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ダムターミナルを FreeBSD マシンに接続するにはどうしたらよいのでしょうか?</para>
        </question>

        <answer>
          <para>
            もし, 他のコンピューターを FreeBSD の端末として接続したいのならば,
            お互いのシリアルポート間をつなぐヌルモデムケーブル(訳注:
            リバースケーブルもしくはクロスケーブルとも呼ばれます)を用意してください.
            もし, 既製の端末を使う場合は, 付属するマニュアルを参照してください.
          </para>
  
          <para>
            そして, <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
            を上と同じように変更してください.
            例えば, WYSE-50 という端末を 5 番目のポートに接続するならば,
            次のようなエントリを使用してください.
          </para>
  
          <programlisting>ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure</programlisting>
  
          <para>
            この例は, <filename>/dev/ttyd4</filename> ポートにノンパリティ,
            端末タイプが wyse50, 通信速度が
            38400bps(<literal>std.38400</literal>: この設定は, 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?gettytab">/etc/gettytab</ulink>
            に記述されています)の端末が存在しており,
            <username>root</username>
            のログインが許可されている(secure)であることを示しています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どうして <command>tip</command> や
            <command>cu</command> が動かないのですか?</para>
        </question>

        <answer>
          <para>
            おそらくあなたのシステムでは
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink> や
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?cu">cu</ulink> は
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?uucp">uucp</ulink> ユーザーか,
            <username>dialer</username> グループによってのみ実行可能なのでしょう.
            <username>dialer</username> グループは,
            モデムやリモートシステムにアクセスするユーザーを管理するために,
            使用することができます.
            それには, <filename>/etc/group</filename>
            ファイルの <username>dialer</username>
            グループにあなた自身を追加してください.
          </para>
  
          <para>
            そうする代わりに, 次のようにタイプすることにより,
            あなたのシステムの全ユーザーが
            <command>tip</command> や
            <command>cu</command>
            を実行できるようになります.
          </para>
  
          <screen>&prompt.root; <userinput><command>chmod</command> 4511 /usr/bin/cu</userinput>
&prompt.root; <userinput><command>chmod</command> 4511 /usr/bin/tip</userinput></screen>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私の Hayes モデムはサポートされていないのですが,
            どうしたらいいのでしょうか. </para>
        </question>

        <answer>
          <para>
            実際,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>
            のオンラインマニュアルは古くなっています.
            すでに, Hayes ダイアラが実装されています.
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>
            ファイルで,
            &ldquo;<literal>at=hayes</literal>&rdquo;
            と指定してください.
          </para>
  
          <para>
            Hayes ドライバは, 最近のモデムの新しい機能である,
            <literal>BUSY</literal>,
            <literal>NO DIALTONE</literal>,
            <literal>CONNECT 115200</literal>
            などのメッセージを認識できるほど賢くはなく,
            単に混乱を起こすだけです.
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>
            を使う場合には(<literal>ATX0&amp;W</literal>とするなどして),
            これらのメッセージを表示させないようにしなくてはいけません.
          </para>
  
          <para>
            また, <emphasis remap=tt>tip</emphasis> のダイヤルのタイムアウトは 60 秒です.
            モデムのタイムアウト設定はそれより短くすべきであり,
            そうしないと <emphasis remap=tt>tip</emphasis>
            は通信に問題があると判断するでしょう.
            <literal>ATS7=45&amp;W</literal> を実行してください.
          </para>
  
          <para>
            実際, デフォルトの
            <emphasis remap=tt>tip</emphasis> は Hayes
            の完全なサポートをしているわけではありません.
            解決方法は <filename>/usr/src/usr.bin/tip/tip</filename>
            の下の <filename>tipconf.h</filename> を変更することです.
            もちろん, これにはソース配布ファイルが必要です.
          </para>
  
          <para>
            &ldquo;<literal>#define HAYES 0</literal>&rdquo;
            と記述されている行を
            &ldquo;<literal>#define HAYES1</literal>&rdquo; と変更し, そして
            &ldquo;<command>make</command>&rdquo; と
            &ldquo;<command>make install</command>&rdquo;
            を実行します. これでうまく動作するでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="direct-at">
          <para>これらの AT コマンドを入力するには?</para>
        </question>
        
        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>
            ファイルの中で
            &ldquo;<symbol>direct</symbol>&rdquo; エントリを作ります. 
            たとえばモデムが 1 番目のシリアルポートである
            <filename>/dev/cuaa0</filename>に接続されている場合,
            次のようにします.</para>
  
          <programlisting>cuaa0:dv=/dev/cuaa0:br#19200:pa=none</programlisting>
  
          <para>
            モデムがサポートする最大の bps レートを
            <symbol>br</symbol> フィールドに使います.
            そして <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip cuaa0</ulink>
            を実行すると, モデムが利用できるようになります.
          </para>
  
          <para>
            <filename>/dev/cuaa0</filename>がシステムに存在しない場合は, 次のようにします.
          </para>
  
          <screen>&prompt.root; <userinput><command>cd</command> /dev</userinput>
&prompt.root; <userinput><command>./MAKEDEV</command> cuaa0</userinput></screen>
  
          <para>
            または <username>root</username>
            になって以下のように
            <command>cu</command> コマンドを実行します.
          </para>
  
          <screen>&prompt.root; <userinput><command>cu</command> -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>
  
          <para>
            &ldquo;<replaceable>line</replaceable>&rdquo;
            にはシリアルポート(例えば
            <filename>/dev/cuaa0</filename>)を指定します.
            そして &ldquo;<replaceable>speed</replaceable>&rdquo;
            には接続する速度(例えば
            <literal>57600</literal>)を指定します.
            その後 AT コマンドを実行したら,
            <literal>~.</literal>
            と入力すれば終了します.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>pn 機能の <literal>&lt;@&gt;</literal> 記号が使えません!</para>
        </question>

        <answer>
          <para>電話番号 (pn) 機能の中での
            <literal>&lt;@&gt;</literal> 記号は,
            <command>tip</command> に
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?phones(5)">/etc/phones</ulink>
            にある電話番号を参照するように伝えます. しかし
            <literal>&lt;@&gt;</literal> の文字は
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>
            のような設定ファイルの中では特殊文字となります.
            そこで, バックスラッシュを使ってエスケープを行います.
          </para>
  
          <programlisting>pn=\@</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>コマンドラインから電話番号を指定するには?</para>
        </question>

        <answer>
          <para>
            &ldquo;<literal>generic</literal>&rdquo;
            エントリと呼ばれるものを
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink> に追加します.
            例えば, 次のようにします.
          </para>
            
          <programlisting>tip115200|Dial any phone number at 115200 bps:\
:dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
:dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</programlisting>

  
          <para>
            そして
            &ldquo;<command>tip -115200 5551234</command>&rdquo;
            のように利用できます.
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink> より
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?cu">cu</ulink> を使いたい場合,
            <command>cu</command> の
            <literal>generic</literal> エントリを使います.
          </para>
  
          <programlisting>cu115200|Use cu to dial any number at 115200bps:\
:dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</programlisting>

          <para>
            そして &ldquo;<command>cu 5551234 -s 115200</command>&rdquo;
            と実行します.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>毎回 bps レートを入力しなければいけませんか?</para>
        </question>

        <answer>
          <para>
            <literal>tip1200</literal> や
            <literal>cu1200</literal> 用のエントリを記述し,
            適切な通信速度を <symbol>br</symbol>
            フィールドに設定します.
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink> は
            1200bps が正しいデフォルト値であるとみなすので,
            &ldquo;<literal>tip1200</literal>&rdquo; エントリを参照します.
            もちろん 1200bps を使わなければならないわけではありません.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ターミナルサーバを経由して複数のホストへアクセスしたいのですが.</para>
        </question>

        <answer>
          <para>
            毎回接続されるのを待って
            &ldquo;<userinput>CONNECT &lt;<replaceable>host</replaceable>&gt;</userinput>&rdquo;
            と入力するかわりに,
            <command>tip</command> の
            <symbol>cm</symbol> 機能を使います.
            例えば, <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>
            に次のようなエントリを追加します.
          </para>
  
          
          <programlisting>pain|pain.deep13.com|Forrester's machine:\
:cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
:cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
:dv=/dev/cua02:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

          <para>
            これで, &ldquo;<command>tip <hostid>pain</hostid></command>&rdquo;
            や &ldquo;<command>tip <hostid>muffin</hostid></command>&rdquo;
            と実行すると
            <hostid>pain</hostid> や
            <hostid>muffin</hostid> のホストに接続することができ,
            &ldquo;<command>tip <hostid>deep13</hostid></command>&rdquo;
            を実行するとターミナルサーバに接続します.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>
            <command>tip</command>
            を使ってそれぞれのサイトの複数の回線に接続できますか?</para>
        </question>

        <answer>
          <para>
            これは大学に電話回線がいくつかあって,
            数千人の学生が接続しようとする場合によくある問題です.
          </para>
  
          <para>
            あなたの大学のエントリを
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>
            ファイルに作成して,
            <symbol>pn</symbol> のフィールドには
            <literal>&lt;\@&gt;</literal> を使います.
          </para>
  
          <programlisting>big-university:\
:pn=\@:tc=dialout
dialout:\
:dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</programlisting>

  
          <para>
            そして
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?phones">/etc/phones</ulink>
            ファイルに大学の電話番号の一覧を書きます.
          </para>
  

          <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

  
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>
            は一連の電話番号を上から順に試みて, 
            最終的に接続できなければあきらめます. リトライを続けさせたい場合は,
            <command>tip</command> を
            while ループに入れて実行します.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><keycap>CTRL</keycap>+<keycap>P</keycap> を
            1 回送るために 2 度押す必要があるのはなぜ?</para>
        </question>

        <answer>
          <para><keycap>CTRL</keycap>+<keycap>P</keycap>
            は通常「強制(force)」文字であり,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>
            に次の文字がリテラルデータであることを伝えます.
            強制文字は「変数の設定」を意味する
            <literal>~s</literal> エスケープによって,
            他の文字にすることができます.
          </para>
  
          <para>
            &ldquo;<literal>~sforce=<replaceable>&lt;single-char&gt;</replaceable></literal>&rdquo;
            と入力して改行します.
            <replaceable>&lt;single-char&gt;</replaceable> は, 任意の 1 バイト文字です.
            <replaceable>&lt;single-char&gt;</replaceable> を省略すると
            <symbol>NUL</symbol> 文字になり,
            これは <keycap>CTRL</keycap>+<keycap>2</keycap> や
            <keycap>CTRL</keycap>+<keycap>SPACE</keycap>
            を押しても入力できます.
            いくつかのターミナルサーバで使われているのを見ただけですが,
            <replaceable>&lt;single-char&gt;</replaceable> に
            <keycap>SHIFT</keycap>+<keycap>CTRL</keycap>+<keycap>6</keycap>
            に割り当てるのもよいでしょう.
          </para>
  
          <para>
            <filename>&#36;HOME/.tiprc</filename> に次のように定義することで,
            任意の文字を強制文字として利用できます.
          </para>
  
          <programlisting>force=<replaceable>&lt;single-char&gt;</replaceable></programlisting>
  
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>打ち込んだ文字が突然すべて大文字になりました??</para>
        </question>

        <answer>
          <para>
            <keycap>CTRL</keycap>+<keycap>A</keycap>
            を押してしまい, <keycap>caps-lock</keycap>
            キーが壊れている場合のために設計された
            &ldquo;<ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>&rdquo;
            の &ldquo;raise character&rdquo; モードに入ったのでしょう.
            既に述べた <literal>~s</literal> を使って,
            &ldquo;raisechar&rdquo; をより適切な値に変更してください.
            もしこれら両方の機能を使用しないのであれば,
            強制文字と同じ設定にすることもできます.
          </para>
  
          <para>
            以下は <keycap>CTRL</keycap>+<keycap>2</keycap> や
            <keycap>CTRL</keycap>+<keycap>A</keycap>
            などを頻繁に使う必要のある Emacs ユーザにうってつけの
            <filename>.tiprc</filename> ファイルのサンプルです.
          </para>
  
          <programlisting>force=^^
raisechar=^^</programlisting>

          <para>
            <literal>^</literal> は
            <keycap>SHIFT</keycap>+<keycap>CTRL</keycap>+<keycap>6</keycap> です.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>tip</command> でファイルを転送するには?</para>
        </question>

        <answer>
          <para>
            もし他の UNIX のシステムと接続しているなら,
            <literal>~p</literal>(送信)や
            <literal>~t</literal>(受信)でファイルの送受信ができます.
            これらのコマンドは, 相手のシステムの上で
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?cat">cat</ulink> や
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?echo">echo</ulink>
            を実行することで送受信をします. 書式は以下のようになります.
          </para>
  
          
          <programlisting>~p <replaceable>&lt;ローカルのファイル名&gt;</replaceable> <replaceable>[&lt;リモートのファイル名&gt;]</replaceable>
~t <replaceable>&lt;リモートのファイル名&gt;</replaceable> <replaceable>[&lt;ローカルのファイル名&gt;]</replaceable></programlisting>

  
          <para>
            この方法ではエラーチェックを行いませんので,
            zmodem などの他のプロトコルを使った方がよいでしょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><command>tip</command> から zmodem を実行するには?</para>
        </question>

        <answer>
          <para>
            まず始めに, FreeBSD Ports
            Collection(<ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^lrzsz">lrzsz</ulink>と
            <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^rzsz">rzsz</ulink>
            との, 2 つの通信カテゴリーのプログラムのどちらか)をインストールします.
          </para>
  
          <para>
            ファイルを受信するには, リモート側で送信プログラムを起動します.
            そして, <keycap>Enter</keycap> キーを押してから
            &ldquo;<literal>~C rz</literal>&rdquo;
            (lrzsz をインストールした場合は
            &ldquo;<literal>~C lrz</literal>&rdquo;)と入力すると,
            ローカル側へのファイルの受信が始まります.
          </para>
  
          <para>
            ファイルを送信するには, リモート側で受信プログラムを起動します.
            そして, <keycap>Enter</keycap> キーを押してから
            &ldquo;<literal>~C sz <replaceable>&lt;files&gt;</replaceable></literal>&rdquo;
            (lrzsz をインストールした場合は
            &ldquo;<literal>~C lsz
              <replaceable>&lt;files&gt;</replaceable></literal>&rdquo;)と入力すると,
            リモート側へのファイルの送信が始まります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>設定が正しいのにもかかわらず, FreeBSD がシリアルポートを見付けられません.</para>
        </question>

        <answer>
          <para>
            マザーボードやシリアルカードが Acer の UART チップを使った物の場合,
            FreeBSD の <devicename>sio</devicename> ドライバでは正しく検出する事が出来ません. 
            この問題を解決するためには,
            <ulink URL="http://www.lemis.com/serial-port-patch.html">www.lemis.com</ulink>
            からパッチを入手してください.
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="misc">
    <title>その他の質問</title>

    <para>
      <emphasis>訳:
        内川 喜章 <email>yoshiaki@kt.rim.or.jp</email>,
        杉村 貴士 <email>sugimura@jp.FreeBSD.org</email>,
        福間 康弘 <email>yasuf@big.or.jp</email>,
        1997 年 11 月 10 日 - 1999 年 5 月 8 日.</emphasis>
    </para>
  

    <qandaset>
      <qandaentry>
        <question>
          <para>FreeBSD は Linux より多くのスワップ領域を消費するのはなぜですか?</para>
        </question>

        <answer>
          <para>
            実際にはそうではありません. 
            FreeBSD は Linux よりもスワップを多く使っているように見えるだけです.
            この点における FreeBSD と Linux の主な違いは,
            FreeBSD はより多くのメインメモリを有効利用できるようにするため,
            完全にアイドルになったものやメインメモリ上の使われなくなったページを,
            スワップにあらかじめ積極的に移動しているということです.
            Linux では,
            最後の手段としてページをスワップに移動させるだけという傾向があります.
            このスワップの使い方は,
            メインメモリをより効果的に使用することによってバランスが保たれています.
          </para>
  
          <para>
            FreeBSD はこのような状況では先手策を取りますが,
            システムが本当に空き状態の時に,
            理由も無くページをスワップしようと決めることはないということに注意してください.
            したがって,
            夜中に使わずにおいたシステムが朝起きたとき,
            すべてページアウトされているということはないのです.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <!-- hrs:2000/03/10 this entry is quite obsolete, so needed to rewrite -->
        <question>
          <para>FreeBSD の実行フォーマットの <symbol>a.out</symbol>
            はどのようなものですか, <symbol>a.out</symbol> を使う理由,
            ELFを使う理由は何でしょう?</para></question>

        <answer>
          <para>
            FreeBSD の <symbol>a.out</symbol>
            フォーマットを理解するためには, 
            まず UNIXにおいて現在「優勢」な
            3 種類の実行フォーマットについて
            いくらか知っておく必要があります.
          </para>
  
          <variablelist>
            <varlistentry>
              <term><ulink URL="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out</ulink></term>
              <listitem>
                <para>
                  最も古く 「由緒正しい」 unix オブジェクトフォーマットです. 
                  マジックナンバを含む短くてコンパクトなヘッダが先頭にあり, 
                  これがフォーマットの特徴とされています(<ulink URL="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out(5)</ulink> に詳細な内容があります).
                  ロードされる 3種類のセグメント,
                  <literal>.text</literal>,
                  <literal>.data</literal>,
                  <literal>.bss</literal>
                  と加えてシンボルテーブルと文字列テーブルを含みます.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><acronym>COFF</acronym></term>
              <listitem>
                <para>
                  SVR3 のオブジェクトフォーマットです.
                  ヘッダは単一のセクションテーブルから成り, 
                  <literal>.text</literal>,
                  <literal>.data</literal>,
                  <literal>.bss</literal>
                  セクション以外の部分を持つことができます.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><acronym>ELF</acronym></term>
              <listitem>
                <para>
                  <acronym>COFF</acronym>の後継です. 複数のセクションをサポートし, 32-bit
                  と 64-bitのいずれの値も可能です. 大きな欠点の一つは, <acronym>ELF</acronym> 
                  はそれぞれのシステムアーキテクチャ毎に単一の <acronym>ABI</acronym>
                  のみが存在するという仮定で設計されていることです.
                  この仮定はまったく正しくありません.
                  商用の SYSV の世界でさえそうです(少なくとも SVR4,
                  Solaris, SCO の 3種類の ABI があります).
                </para>

                <para>
                  FreeBSD はこの問題を解決するための試みとして,
                  既知の <acronym>ELF</acronym>
                  実行ファイルに <acronym>ABI</acronym> に応じた情報を
                  <emphasis>書き加える</emphasis>ユーティリティを提供しています.
                  <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?brandelf">brandelf</ulink>
                  のマニュアルページを参照してください.
                  より多くの情報があります.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
  
          <para>
            FreeBSD は伝統的な立場をとり, 数多くの世代の BSD
            のリリースで試され, 実証されてきた
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out</ulink>
            フォーマットを伝統的に使用しています. 
            いつかは FreeBSD システムでネイティブ
            <acronym>ELF</acronym> バイナリを作り, 
            実行することができるようになるかもしれませんが,
            初期の頃 FreeBSD
            では <acronym>ELF</acronym>
            をデフォルトのフォーマットに変更するという動きは
            ありませんでした. なぜでしょうか?
            ところで Linux においては, 
            <acronym>ELF</acronym> への苦痛をともなった変更は,
            その時に <filename>a.out</filename> 
            実行フォーマットから逃れたというよりは,
            ジャンプテーブルベースの共有ライブラリのメカニズムの柔軟性の低さからの脱却でした. 
            これはベンダや開発者全体にとって,
            共有ライブラリの作成が非常に難しかった原因でした. 
            <acronym>ELF</acronym>
            のツールには共有ライブラリの問題を解決することができるものが提供されており,
            またいずれにせよ一般的に「進歩」していると考えられます.
            このため移行のコストは必要なものとして容認され,
            移行はおこなわれました.
          </para>
  
          <para>
            FreeBSD の場合は, 共有ライブラリのメカニズムは Sun の SunOS
            スタイルの共有ライブラリのメカニズムに極めて近いものになっていて,
            非常に使いやすいものになっています.
            しかしながら, FreeBSD では 3.0 から <acronym>ELF</acronym>
            バイナリをデフォルトのフォーマットとして公式にサポートしています.
            a.out 実行フォーマットはよいものを私達に提供してくれているものの,
            私たちの使っているコンパイラの作者である GNU の人々は
            a.out フォーマットのサポートをやめてしまったのでした.
            このことは,
            私たちに別バージョンのコンパイラとリンカを保守することを余儀なくされることとなり,
            最新の GNU 開発の努力による恩恵から遠ざかることになります.
            その上, ISO C++ の,
            とくにコンストラクタやデストラクタがらみの要求もあって, 今後の
            FreeBSD のリリースでネイティブの <acronym>ELF</acronym>
            のサポートされる方向へと話が進んでいます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>それにしても, なぜそんなに多くのフォーマットがあるのですか?</para>
        </question>

        <answer>
          <para>
            もうおぼろげになってしまった暗い過去に, 単純なハードウェアがありました.
            この単純なハードウェアは, 単純で小さなシステムをサポートしていました.
            a.out はこの単純なシステム(PDP-11)
            での作業を行なうバイナリとして完全に適したものだったのです.
            人々はこの単純なシステムから UNIX を移植する際に, a.out
            フォーマットをそのまま使いました. というのは
            Motorola 68k, VAXen,
            といったアーキテクチャへの UNIX の初期の移植ではこれで十分だったからです.
          </para>
  
          <para>
            やがてある聡明なエンジニアが,
            ソフトウェアでちょっとしたトリックを使うことを決めました.
            彼はいくつかのゲートを削り取って
            CPU のコアをより速く走らせることができたのです.
            これは新しい種類のハードウェア(今日では <acronym>RISC</acronym>
            として知られています)で動いたのです.
            a.out はこのハードウェアには適していなかったので,
            このハードウェア上で多くのフォーマットが,
            限定された単純な a.out
            フォーマットでのものよりもより良いパフォーマンスを出すことを目指して開発されたのです.
            <acronym>COFF</acronym>, <acronym>ECOFF</acronym>,
            そしていくつかの有名でないフォーマットが
            <acronym>ELF</acronym> が標準になる前に開発され,
            それらの限界が探求されたのです.
          </para>
  
          <para>
            さらに, プログラムサイズは巨大になり,
            ディスク(および物理メモリ)は依然として相対的に小さかったため,
            共用ライブラリのコンセプトが誕生しました.
            また, VM システムはより複雑なものになりました.
            これらの個々の進歩は a.out フォーマットを使用して遂げられましたが,
            その有用性は新しい機能とともにどんどん広がってきました.
            これらに加え, 実行時に必要なものを動的にロードする,
            または初期化コードの実行後にプログラムの一部を破棄し,
            コアメモリおよびスワップ空間を節約するという要望が高まりました.
            プログラミング言語はさらに複雑になり, <symbol>main</symbol>
            関数の前に自動的にコールされるコードの要望が高まりました.
            多くの機能拡張がおこなわれ, a.out
            フォーマットがこれらすべてを実現できるようになり,
            それらはしばらくは基本的に動作していました.
            やがて, a.out はコードでのオーバヘッドと複雑さを増大させずに,
            これらの問題すべてを処理することに無理がでてきました.
            一方, <acronym>ELF</acronym> はこれらの問題の多くを解決しますが,
            現状稼働しているシステムからの切替えは厄介なものになるでしょう.
            そのため <acronym>ELF</acronym> は, a.out のままでいることが
            <acronym>ELF</acronym>
            への移行よりももっと厄介なものになるまで待つ必要がありました.
          </para>
  
          <para>
            しかし時が経つにつれ, FreeBSD
            のビルドツールの元となったツール群(特にアセンブラとローダ)と
            FreeBSD のビルドツール群は異なった進化の経路をたどりました.
            FreeBSD のツリーでは, 共有ライブラリが追加され,
            バグフィックスも行われました.
            もともとのツール群を作成した GNU の人たちは, プログラムを書き直し,
            クロスコンパイラのサポート,
            異なるフォーマットを任意に取り込む機能などを追加していきました.
            多くの人々が FreeBSD
            をターゲットとしたクロスコンパイラの構築を試みましたが,
            FreeBSD の使っている <command>as</command> と 
            <command>ld</command>
            の古いプログラムコードはクロスコンパイルをサポートしておらず,
            うまくいきませんでした.
            新しい GNU のツール群(binutils)は,
            クロスコンパイル, 共有ライブラリ, C++
            拡張などの機能をサポートしています.
            さらに数多くのベンダが
            <acronym>ELF</acronym> バイナリをリリースしています.
            FreeBSD にとって <acronym>ELF</acronym>
            バイナリが実行できることは,
            非常にメリットがあります. <acronym>ELF</acronym> バイナリが
            FreeBSD で動くのなら, a.out
            を動かすのに手間をかける必要はありませんね.
            長い間忠実によく働いた老いた馬は,
            そろそろ牧草地で休ませてあげましょう.
          </para>
  
          <para>
            <acronym>ELF</acronym> は a.out に比べてより表現力があり, 
            ベースのシステムに対してより幅広い拡張性を提供できます.
            <acronym>ELF</acronym> 用のツールはよりよく保守されています.
            また多くの人にとって重要なクロスコンパイルもサポートしています.
            <acronym>ELF</acronym> の実行速度は, ほんの少し a.out より遅いかもしれませんが,
            実際に速度の差をはかるのは困難でしょう.
            <acronym>ELF</acronym> と a.out の間には, ページマッピング,
            初期化コードの処理など多くの違いがありますが,
            とりたてて重要なものはありません. しかし違いがあるのは確かです. ほどなく,
            GENERIC カーネルから a.out のサポートが外されます.
            a.out のプログラムを実行する必要性がなくなれば,
            最終的に a.out のサポートはカーネルから削除されます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>なぜシンボリックリンクのパーミッションは
            <command>chmod</command> で変えられないのですか?</para>
        </question>

        <answer>
          <para>
            この場合, &ldquo;<option>-H</option>&rdquo; か
            &ldquo;<option>-L</option>&rdquo; のどちらかのオプションを 
            &ldquo;<option>-R</option>&rdquo; と同時に使う必要があります. 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</ulink> と
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?symlink">symlink</ulink>
            のマニュアルページにはもっと詳しい情報があります.

            <note>
              <para>
                &ldquo;<option>-R</option>&rdquo; オプションは<emphasis>再帰的に</emphasis>
                <command>chmod</command>
                を実行します. ディレクトリやディレクトリへのシンボリックリンクを 
                <command>chmod</command> する場合は気をつけてください.
                シンボリックリンクで参照されている単一のディレクトリのパーミッションを変更したい場合は,
                <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</ulink> 
                をオプションをつけずに,
                シンボリックリンクの名前の後ろにスラッシュ(&ldquo;<filename>/</filename>&rdquo;)
                をつけて使います. 例えば, &ldquo;<filename>foo</filename>&rdquo;
                がディレクトリ &ldquo;<filename>bar</filename>&rdquo;
                へのシンボリックリンクである場合,
                &ldquo;<filename>foo</filename>&rdquo;(実際には
                &ldquo;<filename>bar</filename>&rdquo;)のパーミッションを変更したい場合には,
                このようにします.
              </para>
  
              <screen>&prompt.user; <userinput><command>chmod</command> 555 foo/</userinput></screen>
  
              <para>
                後ろにスラッシュをつけると,
                <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</ulink> はシンボリックリンク 
                &ldquo;<filename>foo</filename>&rdquo;
                を追いかけてディレクトリ
                &ldquo;<filename>bar</filename>&rdquo; 
                のパーミッションを変更します.
              </para>  
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ログイン名が<emphasis>いまだに</emphasis>
            8 文字に制限されているのはなぜですか?</para>
        </question>

        <answer>
          <para>
            <symbol>UT_NAMESIZE</symbol>
            を変更してシステム全体を作り直せば十分で,
            それだけでうまくいくだろうとあなたは考えるかもしれません. 
            残念ながら多くのアプリケーションやユーティリティ(システムツールも含めて)は,
            小さな数値を構造体やバッファなどに使っています(必ずしも
            &ldquo;8&rdquo; や &ldquo;9&rdquo; ではなく,
            &ldquo;15&rdquo; や &ldquo;20&rdquo; などの変った値を使うものもあります).
            (固定長のレコードを期待するところで可変長レコードになるため,
            )台無しになったログファイルを得ることになるということだけでなく,
            Sun の <acronym>NIS</acronym>
            のクライアントの場合は問題が起きますし, 他の UNIX
            システムとの関連においてこれら以外の問題も起きる可能性があります.
          </para>
  
          <para>
            しかし, FreeBSD 3.0 以降では 16 文字となり,
            多くのユーティリティのハードコードされた名前の長さの問題も解決されます.
            実際にはシステムのあまりに多くの部分を修正するために,
            3.0 になるまでは変更が行われませんでした.
          </para>
  
          <para>
            それ以前のバージョンでは, これらの問題が起こった場合に,
            問題を自分自身で発見し, 解決できることに絶対的な自信がある場合は 
            <filename>/usr/include/utmp.h</filename> を編集し,
            <symbol>UT_NAMESIZE</symbol> の変更にしたがって,
            長いユーザ名を使うことができます.
            また,
            <symbol>UT_NAMESIZE</symbol> の変更と一致するように 
            <filename>/usr/include/sys/param.h</filename> の
            <symbol>MAXLOGNAME</symbol> 更新しなくてはなりません.
            最後に, ソースからビルドする場合は 
            <filename>/usr/include</filename>
            を毎回アップデートする必要があることを忘れないように! 
            <filename>/usr/src/..</filename> 上のファイルを変更しておいて置き換えましょう.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD 上で DOS のバイナリを動かすことはできますか?</para>
        </question>

        <answer>
          <para>
            はい, FreeBSD 3.0 からは,
            統合と改良が重ねられた BSDI の <command>doscmd</command>
            DOS エミュレーションサブシステムを使ってできるようになりました.
            今なお続けられているこの努力に興味を持って参加していただけるなら,
            <ulink URL="mailto:freebsd-emulation@FreeBSD.org">FreeBSD
              エミュレーションメーリングリスト</ulink>へメールを送ってください.
          </para>
  
          <para>FreeBSD 3.0 以前のシステムでは, 
            <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^pcemu">pcemu</ulink>
            という巧妙なユーティリティが FreeBSD Ports Collection にあり,
            8088 のエミュレーションと DOS
            のテキストモードアプリケーションを動かすに十分な
            BIOS サービスをおこないます. これは X ウィンドウシステムが必要です(XFree86
            として提供されています).
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>&ldquo;<acronym>sup</acronym>&rdquo; とは何で,
            どのようにして使うものなのでしょうか?</para>
        </question>

        <answer>
          <para>
            <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^sup">SUP</ulink>
            とは, ソフトウェアアップデートプロトコル(Software Update Protocol)で
            カーネギーメロン大学(CMU)で開発ツリーの同期のために開発されました. 
            私たちの中心開発ツリーをリモートサイトで同期させるために使っていました.
          </para>
  
          <para>
            SUP はバンド幅を浪費しますので, 今は使っていません.
            ソースコードのアップデートの現在のおすすめの方法は
            <ulink URL="../handbook/synching.html#CVSUP">FreeBSD
              ハンドブックの「CVSup」</ulink>にあります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD をクールに使うには?</para>
          <para>
            FreeBSD を動かす時に温度測定をおこなった人はいますか? Linux 
            は dos よりも温度が下がるということは知っていますが, FreeBSD
            についてはこのようなことに触れたものを見たことはありません. 
            実際熱くなっているように見えます.
          </para>
        </question>

        <answer>
          <para>
            いいえ.
            私たちは 250 マイクログラムの LSD-25
            をあらかじめ与えておいたボランティアに対する,
            目隠し味覚テストを大量におこなっています.
            35% のボランティアは FreeBSD
            はオレンジのような味がすると言っているのに対し,
            Linux は紫煙のような味わいがあると言っている人もいます.
            私の知る限り両方のグループとも温度の不一致については触れていません.
            この調査で, 非常に多くのボランティアがテストをおこなった部屋から不思議そうに出てきて, 
            このようなおかしな結果を示したことに私たちは当惑させられました. 
            私は, ほとんどのボランティアは Apple
            にいて彼らの最新の「引っかいて匂いをかぐ」GUI
            を使っているのではないかと考えています.
            私たちは奇妙な古い仕事をしているのでしょう!
          </para>
  
          <para>
            真面目に言うと, FreeBSD や Linux は共に
            &ldquo;<acronym>HLT</acronym>&rdquo; (停止) 
            命令をシステムのアイドル(idle)時に使い,
            エネルギーの消費を押えていますので熱の発生も少なくなります.
            また, <acronym>APM(automatic power management)</acronym>
            を設定してあるなら FreeBSD は <acronym>CPU</acronym>
            をローパワーモードにすることができます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>誰かが私のメモリカードをひっかいているのですか??</para>
          <para>
            FreeBSDでカーネルのコンパイルをしている時,
            メモリから引っかいているような奇妙な音が聞こえるようなことはあるのでしょうか? 
            コンパイルをしている時(あるいは起動時にフロッピドライブを認識した後の短い間など),
            奇妙な引っかくような音がメモリカードのあたりから聞こえてきます.
          </para>
        </question>

        <answer>
          <para>
            その通りです. BSD
            のドキュメントでしばしば「デーモン」について述べられている理由がわかるでしょう.
            しかし多くの人は本当の事については触れていません.
            非物質的な存在があなたのコンピュータにあるのです.
            メモリからの引っかいたような音は,
            実際に色々なシステム管理タスクの扱いをいかに最善なものにするかという内容を交わす, 
            デーモンたちのかん高いささやきなのです.
          </para>
  
          <para>
            「雑音」があなたに DOS プログラムの
            &ldquo;<command>fdisk /mbr</command>&rdquo; 
            を使ってうまくささやきを取り除かせようとしているように聞こえても, 
            彼らは逆にそうすることをやめさせようとしているのかもしれません. 
            本当は内蔵スピーカからのビル ゲイツ(Bill
            Gates)の悪魔的な声があなたに影響を与えているのかもしれません. 
            実行するのは止めましょう, そして振り返ってはいけません!
            BSD の守護神(daemon)の力により, 
            繰り返しあなたのマシンを支配下に置こうとし,
            あなたの魂を無限地獄に突き落そうとする DOSと Windows
            の双子の悪鬼(demon)の影響から自由になりましょう. 
            選択の機会は与えられました.
            私自身はこの引っかくような音が聞こえていたことを嬉しく思っています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>&quot;MFC&quot; とはどういう意味ですか</para>
        </question>

        <answer>
          <para>
            <acronym>MFC</acronym> とは,
            「CURRENT との合流(Merged From -CURRENT)」の頭文字をとったものです.
            <acronym>CVS</acronym> ログで
            -CURRENT から
            -STABLE ブランチへの合流を示します.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>&quot;BSD&quot; とはどういう意味ですか?</para>
        </question>

        <answer>
          <para>
            この言葉は, 仲間うちだけに分かる隠語で何とかという意味です.
            文字どおりに訳すことはできませんが,
            BSD の訳は「F1 のレーシングチーム」か「ペンギンはおいしいスナック」,
            あるいは「俺たちゃ
            Linux より洒落は利いてるぜ」とかそのへんだと言っておけばおっけーでしょう.
            <literal>:-)</literal>
          </para>
  
          <para>
            閑話休題. BSD とは, Berkeley
            CSRG(コンピュータシステム評議会)が彼らの
            UNIX の配布形態の名前として当時選んだ
            &quot;Berkeley Software Distribution&quot;
            の略です.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>ひとつの電球を取り替えるのに, 何人の FreeBSD ハッカーが必要?</para>
        </question>

        <answer>
          <para>
            1,172人です.
          </para>

          <itemizedlist>
            <listitem>
              <para>電球が消えていると -CURRENT で文句を言うのに 23 人.</para>
            </listitem>
            <listitem>
              <para>設定上の問題で -questions で話をすべきことについて騒ぐのに 4 人.</para>
            </listitem>  
            <listitem>
              <para>それを send-pr (訳注: 障害報告) するのに 3
                人(そのうちのひとつは間違って doc カテゴリに送りつけられたうえに,
                内容が「暗くなった」というだけのもの).</para>
            </listitem>
            <listitem>
              <para>buildworld を失敗させ, 5 分後には元に戻されるような電球を
                テストもせずにコミットするのに 1 人.</para>
            </listitem>
            <listitem>
              <para>send-pr した人に, パッチが含まれていないと「いちゃもん」を付けるのに
                8 人.</para>
            </listitem>
            <listitem>
              <para>buildworld が失敗すると文句を言うのに 5 人.</para>
            </listitem>
            <listitem>
              <para>自分のところではちゃんと動く,
                cvsup したタイミングが悪かったんだろうと答えるのに 31 人.</para>
            </listitem>
            <listitem>
              <para>新しい電球のためのパッチを -hackers に投げるのに 1 人.</para>
            </listitem>
            <listitem>
              <para>自分は 3年も前にパッチを作ったが, それを -CURRENT
                に投げたときには無視されただけだった,
                自分は send-pr のシステムには嫌な経験があると(おまけに,
                提案された新しい電球には柔軟性が無いとまで)文句を言うのに 1 人.</para>
            </listitem>
            <listitem>
              <para>電球が基本システムに組み込まれていない,
                committer はコミュニティの意見を聞くこと無しにこんなことをする権利は無いと叫び,
                「こんなときに -core は何をやってるんだ!?」とわめきちらすのに 37 人.</para>
            </listitem>
            <listitem>
              <para>自転車置き場の色に文句を言うのに 200 人.</para>
            </listitem>
            <listitem>
              <para>パッチが style(9) 違反だと指摘するのに 3 人.</para>
            </listitem>
            <listitem>
              <para>提案された新しい電球は GPL の下にあると文句を言うのに 70 人.</para>
            </listitem>
            <listitem>
              <para>GPL と BSD ライセンスと MIT ライセンスと NPL と,
                某 FSF 創立者らの個人的な健康法の優位性についての論争を戦わすのに 586 人.</para>
            </listitem>
            <listitem>
              <para>スレッドのあちこちの枝を -chat や -advocacy に移動するのに 7 人.</para>
            </listitem>
            <listitem>
              <para>提案された電球を, 古いのよりずっと薄暗いのにコミットしてしまうのに 1 人.</para>
            </listitem>
            <listitem>
              <para>FreeBSD に薄暗い電球を付けるくらいなら真っ暗のほうがましだという,
                コミットメッセージへの凄まじい非難の嵐によって,
                それを元に戻すのに 2 人.</para>
            </listitem>
            <listitem>
              <para>薄暗い電球が帳消しにされたことに対してどなり声で口論し,
                -core の声明を要求するのに 46 人.</para>
            </listitem>
            <listitem>
              <para>もし FreeBSD をたまごっちに移植することになったときに都合がいいように,
                もっと小さな電球を要求するのに 11 人.</para>
            </listitem>
            <listitem>
              <para>-hackers と -chat の S/N比に文句を言い,
                抗議のため講読を取りやめるのに 73 人.</para>
            </listitem>
            <listitem>
              <para>「unsubscribe」「どうやったら講読をやめられるんですか?」
                「このメーリングリストからわたしを外してください」といった
                メッセージを, 例のフッタをくっつけて投稿するのに 13 人.</para>
            </listitem>
            <listitem>
              <para>みんなが激論を戦わせるのに忙がしくて気付かない間に,
                作業中の電球をコミットするのに 1 人.</para>
            </listitem>
            <listitem>
              <para>新しい電球は TenDRA を使ってコンパイルされた場合に 0.364%
                も明るくなる(ただし電球を立方体にしなければならない),
                だから FreeBSD は EGCS から TenDRA に変えるべきだと指摘するのに 31 人.</para>
            </listitem>
            <listitem>
              <para>新しい電球は美しさに欠けていると文句を言うのに 1 人.</para>
            </listitem>
            <listitem>
              <para>「MFC って何ですか?」と聞くのに 9 人(send-pr した人も含む).</para>
            </listitem>
            <listitem>
              <para>電球が取り替えられてから
                2 週間も消えっぱなしだと文句を言うのに 57 人.</para>
            </listitem>
          </itemizedlist>
  
          <para>
            <note>
            <title><ulink URL="mailto:nik@FreeBSD.org">Nik Clayton</ulink>
                による追記</title>
              <para>
                これには爆笑しました.
              </para>  
              <para>
                それからわたしは考えました.
                「ちょっと待てよ? このリストのどこかに,
                『これを文書にまとめるのに 1人』というのがあってもいいんじゃないか?」
              </para>
              <para>
                それからわたしは悟りを開いたのです <literal>:-)</literal>
              </para>
            </note>

            <emphasis>この項目の著作権は
              Copyright (c) 1999 <ulink URL="mailto:des@FreeBSD.org">Dag-Erling
                Co&iuml;dan Sm&oslash;rgrav</ulink>にあります.
              無断に使用しないでください.</emphasis>
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="hackers">
    <title>まじめな FreeBSD ハッカーだけの話題</title>

    <para>
      <emphasis>訳:
        岩崎 満 <email>iwasaki@jp.FreeBSD.org</email>,
        1997 年 11 月 8 日.</emphasis>
    </para>
  
    <qandaset>
      <qandaentry>
        <question>
          <para>SNAP とか RELEASE とかは何?</para>
        </question>

        <answer>
          <para>現在, FreeBSD の
            <ulink URL="http://www.FreeBSD.org/cgi/cvsweb.cgi">CVS リポジトリ</ulink>
            には, 三つのアクティブ/準アクティブなブランチがあります.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  <symbol>RELENG_2_2</symbol>
                  通称
                  <literal>2.2-STABLE</literal> または
                  <literal>&ldquo;2.2 branch&rdquo;</literal>
                </para>
              </listitem>

              <listitem>
                <para>
                  <symbol>RELENG_3</symbol>
                  通称 <literal>3.X-STABLE</literal> または
                  <literal>&ldquo;3.0 branch&rdquo;</literal>
                </para>
              </listitem>

              <listitem>
                <para>
                  <acronym>HEAD</acronym>
                  通称 <literal>-CURRENT</literal> または
                  <literal>4.0-CURRENT</literal>
                </para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>
            <acronym>HEAD</acronym>
            は他の二つと違って,
            実際のブランチ tag ではなく,
            <emphasis>「current,
              分岐していない開発本流」</emphasis>のための単なるシンボリックな定数です.
            私たちはこれを <literal>-CURRENT</literal> と呼んでいます.
          </para>
  
          <para>
            現在,
            <literal>-CURRENT</literal> は 4.0 の開発本流であり, 
            <literal>3.0-STABLE</literal> ブランチ,
            つまり <symbol>RELENG_3</symbol> は
            1999 年 1 月に
            <literal>-CURRENT</literal> から分岐しています.
          </para>
  
          <para>
            <literal>2.2-STABLE</literal> ブランチ,
            <symbol>RELENG_2_2</symbol> は
            1996 年 11 月に <literal>-CURRENT</literal> から分岐しました.
          </para>
  
          <para>
            <literal>2.1-STABLE</literal> ブランチ,
            <symbol>RELENG_2_1_0</symbol> は
            1994 年 9 月に <literal>-CURRENT</literal> から分岐しました.
            このブランチは完全に保守されなくなっています.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="custrel">
          <para>自分用のカスタムリリースを構築するには?</para>
        </question>

        <answer>
          <para>
            リリースを構築するには三つのことが必要です. まず,
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?vn">vn</ulink>
            ドライバが組み込まれたカーネルを実行させている必要があります. 
            以下をカーネルコンフィグレーションファイルに追加し, 
            カーネルを作り直してください.
          </para>
  
          <programlisting>pseudo-device vn         #Vnode driver (turns a file into a device)</programlisting>
          <para>
            次に, CVS リポジトリ全体を手元においておく必要があります. 
            これを入手するには
            <ulink URL="../handbook/synching.html#CVSUP">CVSUP</ulink>
            が使用できますが, supfile で release の名称を cvs にして
            他のタグや date フィールドを削除する必要があります.
          </para>
 
          <programlisting>*default prefix=/home/ncvs
*default base=/a
*default host=cvsup.FreeBSD.org
*default release=cvs
*default delete compress use-rel-suffix

## Main Source Tree
src-all
src-eBones
src-secure

# Other stuff
ports-all
www
doc-all</programlisting>
  
          <para>
            そして <command>cvsup -g supfile</command> を実行して自分のマシンに 
            CVS リポジトリ全体をコピーします...
          </para>
  
          <para>
            最後に, ビルド用にかなりの空き領域を用意する必要があります. 
            そのディレクトリを <filename>/some/big/filesystem</filename> として, 
            上の例で CVS リポジトリを <filename>/home/ncvs</filename> に置いたものとすると, 
            以下のようにしてリリースを構築します.
          </para>
  
          <programlisting>setenv CVSROOT /home/ncvs        # or export CVSROOT=/home/ncvs
cd /usr/src/release
make release BUILDNAME=3.0-MY-SNAP CHROOTDIR=/some/big/filesystem/release</programlisting>
  
          <para>
            処理が終了すると,
            リリース全体が <filename>/some/big/filesystem/release</filename> 
            に構築され, 完全な <acronym>FTP</acronym> インストール用の配布物が 
            <filename>/some/big/filesystem/release/R/ftp</filename> に作成されます. 
            -current 以外の開発ブランチの SNAP を自分で構築したい場合は, 
            <literal>RELEASETAG=SOMETAG</literal>
            を上の <command>make release</command> のコマンドラインに追加します. 
            例えば, <literal>RELEASETAG=RELENG_2_2</literal>
            とすると最新の 2.2-STABLE snapshot が構築されます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>カスタムのインストールディスクを作るにはどうすればいいのですか? </para>
        </question>

        <answer>
          <para>
            <filename>/usr/src/release/Makefile</filename>
            のいろいろなターゲットとしてインストールディスク,
            ソース, バイナリアーカイブを作る完全な処理を自動的におこなうようになっています.
            <filename>Makefile</filename> に十分な情報があります. 
            しかし, 実行には &ldquo;make world&rdquo; が必要で, 
            多くの時間とディスクの容量が必要です.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>&ldquo;make world&rdquo;
            をおこなうと既存のバイナリを上書きしてしまうのですが.</para>
        </question>

        <answer>
          <para>ええ, それが一般的な考え方です. 名前が示しているように
            &ldquo;make world&rdquo;
            はすべてのシステムのバイナリを最初から作り直しますので, 結果として,
            クリーンで一貫性のある環境を得ることができます(これがそれだけ長い時間がかかる理由です).
          </para>
  
          <para>
            環境変数 <symbol>DESTDIR</symbol> を
            &ldquo;<command>make world</command>&rdquo; や
            &ldquo;<command>make install</command>&rdquo;
            を実行する時に定義しておくと, 新しく作られたバイナリは 
            <symbol>&#36;{DESTDIR}</symbol>を <username>root</username>
            とみなしたディレクトリツリーにインストールされます.
            あるでたらめな共有ライブラリの変更やプログラムの再構築によって 
            &ldquo;<command>make world</command>&rdquo;
            は失敗することもあります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>システムブート時に
            &ldquo;(<computeroutput>bus speed defaulted</computeroutput>)&rdquo; とメッセージが出ます.
          </para>
        </question>

        <answer>
          <para>
            Adaptec の 1542 SCSI ホストアダプタは,
            ユーザがソフトウェア的にバスアクセス速度の設定をおこなうことができます.
            以前のバージョンの 1542 ドライバは,
            使用可能な最大の速度を求めてアダプタをその設定にしようとしました.
            これは特定のユーザのシステムでは問題がある事がわかり,
            現在ではカーネルコンフィグオプションに 
            &ldquo;<symbol>TUNE_1542</symbol>&rdquo; が加えられています.
            これを使用すると, これが働くシステムではディスクが速くなりますが, 
            データの衝突が起きて速くはならないシステムもあるでしょう
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question id="ctm">
          <para>インターネットアクセスに制限があっても current を追いかけられますか?</para>
        </question>

        <answer>
          <para>
            はい,
            <ulink URL="../handbook/synching.html#CTM">CTM
              システム</ulink>を使って,
            ソースツリー全体のダウンロードを<emphasis>おこなわず</emphasis>に追いかけることができます.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>どのようにして配布ファイルを 240KB
            に分割しているのですか?</para>
        </question>

        <answer>
          <para>
            比較的新しい BSD ベースのシステムでは,
            <command>split</command> に任意のバイト境界で分割する
            &ldquo;<option>-b</option>&rdquo; オプションがあります.
          </para>
  
          <para>
            以下は <filename>/usr/src/Makefile</filename> からの例です.
          </para>
  
          <programlisting>bin-tarball:
              (cd ${DISTDIR}; \
              tar cf - . \
              gzip --no-name -9 -c | \
              split -b 240640 - \
              ${RELEASEDIR}/tarballs/bindist/bin_tgz.)</programlisting>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>私はカーネルに拡張をおこないました.
            誰に送ればいいですか? </para></question>

        <answer>
          <para>
            <ulink URL="../handbook/contrib.html">FreeBSD
              ハンドブックの「FreeBSD への貢献」</ulink>を参照してください.
          </para>
  
          <para>
            あなたのアイディアに感謝します!
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><acronym>PnP</acronym> <acronym>ISA</acronym>
            カードの検出と初期化はどのようにおこなうのですか? </para>
        </question>

        <answer>
          <para>
            <ulink URL="mailto:uhclem@nemesis.lonestar.org">Frank Durda IV 氏</ulink> より:
          </para>

          <blockquote>
            <para>
              要点は, ホストが認識されていないボードを探す時に, すべての
              PnP ボードが応答することのできる少数の I/O
              ポートがあるということです.
              それにより, PnP プローブルーチンが開始したとき, PnP 
              ボードが存在するなら, すべての PnP ボードは自分のモデル番号を返します.
              そのポートを I/O read するとプローブルーチンは問いに対するワイアード-OR
              された &ldquo;yes&rdquo; を得ます. この場合は
              少なくとも 1ビットが ON になります.
              そして, プローブルーチンはモデル ID(Microsoft/Intel
              によって割り当てられています)が X より小さいボードを
              &ldquo;オフライン&rdquo; にすることができます. 
              この操作をおこない, 問い合わせに応答しているボードがまだ
              残っているかどうかを調べます.
              もし &ldquo;<literal>0</literal>&rdquo; が返ってくるなら X 
              より大きな ID を持つボードはないことになります.
              今度は &ldquo;X&rdquo; 
              よりも小さな値を持つボードについて問い合わせます.
              もしあるのであれば, 
              プローブルーチンはモデル番号が X より小さいことを知ります. 
              今度は, X-(limit/4)
              より大きな値を持つボードをオフラインにして問い合わせを繰り返します.
              この ID の範囲による準バイナリサーチを十分繰り返すことにより,
              プローブルーチンはマシンに存在するすべての 
              PnP ボードの値を最終的に得ることができます. その繰り返しの回数は 
              2^64 よりはるかに少ない回数です.
            </para>
  
            <para>
              ID は二つの 32-bit (つまり 64bit) フィールド + 8 bit 
              チェックサムからなります. 最初の 32 bits はベンダの識別子です. 
              これは公表されてはいませんが,
              同一のベンダから供給されている異なるタイプのボードでは異なる
              32-bit ベンダ ID を持つことができるように考えられます.
              製造元を特定するだけのために 32-bit 
              はいくらか過剰です.
            </para>
  
            <para>
              下位の 32-bit はシリアル番号,
              イーサネットアドレスなどのボードを特定するものです.
              ベンダは上位 32 bits が異なっていないのであれば,
              下位 32-bit が同一である 2枚目のボードを製造することはありません.
              したがって, 同じタイプの複数のボードをマシンにいれることができ,
              この場合でも 64-bit
              全体ではユニークです.
            </para>
  
            <para>
              32-bit のフィールドはすべてを 0 にすることはできません. 
              これは初期化のバイナリサーチの間ワイアード-OR
              によって 0 ではない
              ビットを参照するからです.
            </para>
  
            <para>
              システムがすべてのボードの与えられた ID を認識すると, 
              それぞれのボードに対応した処理を一つずつ(同一の
              I/O ポートを通して)おこないます.
              そして, 利用できる割り込みの選択などのボードが必要とするリソースを検出します.
              すべてのボードについてこの情報を集めます.
            </para>

            <para>
              この情報はハードディスク上の ECU ファイルなどの情報とまとめられ, 
              マザーボードの BIOS にも結合されます.
              マザーボード上のハードウェアへの ECU と
              BIOS PnP のサポートは通常は統合されていますが, 
              周辺機器については真の PnPであるとはいえません. 
              しかし, BIOS の情報に ECU の情報を加えて調査することで, 
              プローブルーチンは PnP
              デバイスが再配置できなくなることを避けることができます.
            </para>
  
            <para>
              それから, 再度 PnP デバイスにアクセスし, I/O, DMA, IRQ, 
              メモリマップアドレスの設定をします.
              デバイスはこのアドレスに見えるようになり,
              次にリブートするまでこの位置を占めます. しかし, 
              あなたの望む時に移動させることが不可能である,
              といっているわけではありません.
            </para>
  
            <para>
              以上の話では大きく単純化をしてありますが,
              基本的な考え方は得られたでしょう.
            </para>
  
            <para>
              マイクロソフトは, ボードのロジックが対立する
              I/O サイクルではデコードしていない(訳注:
              おそらく read 時しかデコードされていず 
              write 時はポートが空いているという意味でしょう),
              プライマリプリンタのステータスポートのいくつかを PnP
              のために占有しました.
              私は初期の PnP の提案レビュー時に IBM
              純正のプリンタボードでステータスポートの write
              のデコードがされているということに気がつきましたが,
              MS は &ldquo;tough (頑固, 不運, 無法な)&rdquo;
              と言っています.
              そしてプリンタのステータスポートへアドレスの設定のために
              write をおこなっています. また, 
              そのアドレス + <literal>0x800</literal> と
              read のための 3番目の I/O ポートが
              <literal>0x200</literal> から
              <literal>0x3ff</literal> の間のどこかに置かれるでしょう.
            </para>
          </blockquote>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>FreeBSD は, 他のアーキテクチャをサポートしないんですか? </para>
        </question>

        <answer>
          <para>
            いくつかのグループの人々が, FreeBSD
            の他のアーキテクチャへの移植に関心を示しており,
            FreeBSD/AXP (ALPHA) はこれらの成果としてはとても成功したものの一つです.
            FreeBSD/AXP は 3.0 スナップショットリリースが現在
            <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha/">ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha</ulink>
            から入手できます.
            ALPHA への移植版が現在動く機種は増えつつあり,
            その中には AlphaStation, AXPpci, PC164, Miata そして Multia
            といったモデルが含まれています.
            この ALPHA への移植版はまだ完全なリリースとはみなされていません.
            システムインストールツール一式や CDROM のインストールメディアの配布が提供され,
            適度な数の ports/packages が動くようになってからになるでしょう.
            現在のところ FreeBSD/AXP はベータ(試験的な)クオリティのソフトウェアとみなすべきです.
            現状についての情報を得るには
            <email>freebsd-alpha@FreeBSD.org</email><link linkend="mailing">メーリングリスト</link>に参加してください.
          </para>
  
          <para>
            その他に FreeBSD の SPARC アーキテクチャへの移植があります.
            プロジェクトへの参加に興味がある方は
            <email>freebsd-sparc@FreeBSD.org</email><link linkend="mailing">メーリングリスト</link>
            に参加してください.
            新しいアーキテクチャに関する一般的な議論については
            <email>freebsd-platforms@FreeBSD.org</email><link linkend="mailing">メーリングリスト</link>
            へ参加してください.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>デバイスドライバを開発したので, メジャー番号が欲しいのですが.</para>
        </question>

        <answer>
          <para>
            これは, 開発したドライバを公開するかどうかに依存します. 
            公開するのであれば, ドライバのソースコード,
            <filename>files.i386</filename> の変更, 
            コンフィグファイルのサンプル,
            デバイスが使うスペシャルファイルを作成する 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV">MAKEDEV</ulink>
            のコードを私たちに送ってください.
            公開するつもりがない場合, ライセンスの問題により公開できない場合は,
            キャラクタメジャー番号 32 および,
            ブロックメジャー番号 8 がこのような目的のために予約されています. 
            これらの番号を使用してください.
            どちらの場合であれ, ドライバに関する情報を 
            <email>freebsd-hackers@FreeBSD.org</email>
            に流して頂けると助かります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>代替のディレクトリ配置ポリシー</para>
        </question>

        <answer>
          <para>
            現在使われているディレクトリの配置ポリシーは,
            私が 1983 年に書いたものから全く変更されていません.
            私は当初の配置ポリシーを, オリジナルの fast filesystem のために書き,
            まったく改定していません.
            このポリシーはシリンダグループを使い尽くすのを防ぐにはうまくいきましたが,
            お気づきの方もいる通り find の動作には不適切です.
            ほとんどのファイルシステムの内容は,
            深さ優先検索(ftw とも呼ばれます)によって作られたアーカイブから,
            抽出(restore)して作成されます. この際, 
            ディレクトリは,シリンダグループにまたがって配置され,
            以降の深さ優先検索を行うには,
            考え得る限り最悪の状態になります.
            もし作成するディレクトリの総数がわかっていれば,
            解決方法はあります. (総数/シリンダグループ数)個のディレクトリを,
            シリンダグループごとにまとめて作成すれば良いのです.
            もちろん最適なディレクトリ配置になるように,
            総数を予測する方法を考えなければなりません.
            しかし仮にシリンダグループあたりのディレクトリ数を
            10 くらいの小さな数に固定してしまったとしても,
            大幅な改善が望めるでしょう.
            このポリシーを用いるべきリストア作業を,
            通常の作業(おそらく既存のポリシーを使用したほうが良いでしょう)を区別するには,
            10 秒間の間に作成されたディレクトリを最大
            10 個までまとめて単一のシリンダグループに書き込むという手順が使えるでしょう.
            とにかく私の結論は, そろそろ実験を始めて見る時期だろうということです.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>カーネルパニックを最大限に利用する</para>
        </question>

        <answer>
          <para>
            <note>
              <para>
                この節は, freebsd-current <link linkend="mailing">メーリングリスト</link>に
                <ulink URL="mailto:wpaul@FreeBSD.org">Bill Paul 氏</ulink>が投稿したメールを,
                <ulink URL="mailto:des@FreeBSD.org">Dag-Erling Co&iuml;dan Sm&oslash;rgrav
                  氏</ulink>が校正し, [] 内のコメントを追加して引用したものです.
              </para>
            </note>
          </para>

<programlisting>From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: ben@rosengart.com
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.ORG

<emphasis>[&lt;ben@rosengart.com&gt; が以下のパニックメッセージを投稿しました.]</emphasis>

&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault</programlisting>
  
          <para>
            このようなメッセージが表示された場合, 問題が起きる状況を確認して,
            情報を送るだけでは十分ではありません.
            下線をつけた命令ポインタ値は重要な値ですが,
            残念ながらこの値は構成に依存します. つまり,
            この値は使っているカーネルのイメージに依存するのです.
            もしスナップショットなどの GENERIC カーネルを使っているのであれば,
            他の人間が問題のある関数について追試をすることができますが,
            カスタマイズされたカーネルの場合は,
            使っている本人にしか問題の起こった場所は特定できないのです.
          </para>
  
          <para>
            何をすれば良いのでしょう?
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  命令ポインタ値をメモします.
                  <literal>0x8:</literal> という部分は今回必要ありません.
                  必要なのは <literal>0xf0xxxxxx</literal> という部分です.
                </para>
              </listitem>

              <listitem>
                <para>
                  システムがリブートしたら, 以下の操作を行います.

                  <screen>&prompt.user; <userinput><command>nm</command> /kernel.that.caused.the.panic | grep f0xxxxxx</userinput></screen>

                  ここで, <literal>f0xxxxxx</literal> は命令ポインタ値です.
                  カーネルシンボルのテーブルは関数のエントリポイントを含み,
                  命令ポインタ値は, 関数内部のある点であり最初の点ではないため,
                  この操作を行っても完全に一致するものが表示されない場合もあります.
                  この場合は, 
                  最後の桁を省いてもういちどやってみてください.
                  このようになります.

                  <screen>&prompt.user; <userinput><command>nm</command> /kernel.that.caused.the.panic | grep f0xxxxx</userinput></screen>

                  これでも一致しない場合は,
                  桁を減らしながら何らかの出力があるまで繰り返してください.
                  何か出力されたら,
                  それがカーネルパニックを引き起こした可能性のある関数のリストです.
                  これは, 問題点を見付ける正確な方法ではありませんが, 何もないよりましです. 
                </para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>
            このようなパニックメッセージを投稿している人はよく見掛けますが, 
            このように, 命令ポインタ値を,
            カーネルシンボルテーブルの中の関数とつき合わせて調べている人はまれです.
          </para>
  
          <para>
            パニックの原因を突き止める最良の方法は, クラッシュダンプをとり, 
            <command>gdb(1)</command>
            でスタックトレースを行うことです. もちろん -CURRENT 
            で <command>gdb(1)</command>
            がちゃんと動いていればですが(私は動くことを保証
            できません. ELF 化された
            <command>gdb(1)</command>
            はカーネルクラッシュダンプを正しく扱えないと言っている人がいました.
            FreeBSD 3.0 がベータテストを終える前に調べなければいけません.
            さもないと CD 出荷後に大顰蹙を買うことになります).
          </para>
  
          <para>
            どっちにしろ, 私は普通以下のようにします.
          </para>
  
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  カーネルコンフィグファイルを作ります.
                  カーネルデバッガが必要そうであれば
                  <literal>options 'DDB'</literal>
                  を加えても良いです(私は永久ループが起こっていそうな場合に,
                  ブレークポイントを設定するのに使って います).
                </para>
              </listitem>

              <listitem>
                <para>
                  <command>config -g KERNELCONFIG</command>
                  としてビルドディレクトリを設定します. 
                </para>
              </listitem>

              <listitem>
                <para>
                  <command>cd /sys/compile/KERNELCONFIG; make</command> を実行します.
                </para>
              </listitem>

              <listitem>
                <para>カーネルのコンパイルが終了するのを待ちます. </para>
              </listitem>

              <listitem>
                <para><command>make install</command> を実行します.</para>
              </listitem>

              <listitem>
                <para>再起動します.</para>
              </listitem>
            </itemizedlist>
          </para>
  
          <para>
              &man.make.1; プロセスは２つのカーネル,
            <filename>kernel</filename> と
            <filename>kernel.debug</filename> をビルドします.
            <filename>kernel</filename> は <filename>/kernel</filename>
            としてインストールされ,
            <filename>kernel.debug</filename> は gdb(1)
            のデバッグ用シンボル情報を取り出すために利用されます.
          </para>

          <para>
            確実にクラッシュダンプをとるには, <filename>/etc/rc.conf</filename>
            を編集して <devicename>dumpdev</devicename>
            を使用しているスワップパーティションに指定する必要があります.
            こうすると <command>rc(8)</command> スクリプトから 
            <command>dumpon(8)</command> コマンドが実行され,
            クラッシュダンプ機能が有効になります.
            手動で <command>dumpon(8)</command> コマンドを実行してもかまいません.
            パニックの後, クラッシュダンプは <command>savecore(8)</command>
            コマンドを使用して取り出すこと ができます.
            <devicename>dumpdev</devicename> が 
            <filename>/etc/rc.conf</filename> で設定されていれば,
            <command>rc(8)</command> スクリプトから
            <command>savecore(8)</command> が自動的に実行され, クラッシュダンプを 
            <filename>/var/crash</filename> に保存します.
 
            <note>
              <para>FreeBSD のクラッシュダンプのサイズは,
                ふつう物理メモリサイズと同じです.
                つまり 64MB のメモリを積んでいれば,
                64MB のクラッシュダンプが生成されることになります.
                <filename>/var/crash</filename>
                に十分な空き容量があることを確認してください. 手動で 
                <command>savecore(8)</command> を実行すれば,
                もっと空き容量のあるディレクトリにクラッシュダンプを保存できます.
                <literal>options MAXMEM=(foo)</literal>
                という行をカーネルコンフィグファイルに追加することで,
                カーネルのメモリ使用量を制限できます.
                たとえば 128MB のメモリがある場合も, 
                カーネルのメモリ使用量を 16MB
                に制限し, クラッシュダンプのサイズも
                128MB ではなく 16MB にすることができます.
              </para>
            </note>
          </para>

          <para>
            クラッシュダンプを取り出せたら,
            以下のように <command>gdb(1)</command>
            を使ってスタックトレースをとります.
          </para>
  

          <screen>&prompt.user; <userinput><command>gdb</command> -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</userinput>
<prompt>(gdb)</prompt> <userinput>where</userinput></screen>

  
          <para>
            必要な情報が 1 画面に収まらないことも多いので, できれば
            <command>script(1)</command> を使って出力を記録します.
            strip していないカーネルイメージを使うことで,
            全てのデバッグシンボルが参照でき,
            パニックの発生したカーネルのソースコードの行が表示されているはずです.
            通常, 正確なクラッシュへの過程を追跡するには,
            出力を最後の行から逆方向に読まなければなりません.
            また <command>gdb(1)</command> を使って,
            変数や構造体の内容を表示させ,
            クラッシュした時のシステムの状態を調べられます.
          </para>
  
          <para>
            もしあなたがデバッグ狂で, 同時に別のコンピュータを利用できる環境にあれば,
            <command>gdb(1)</command> をリモートデバッグに使うこともできます.
            リモートデバッグを使うと, あるコンピュータ上の
            <command>gdb(1)</command> を使って,
            別のコンピュータのカーネルをデバッグできます.
            ブレークポイントの設定, カーネルコードのステップ実行など,
            ふつうのプログラムのデバッグと変わりません.
            コンピュータを 2 台並べてデバッグするチャンスにはなかなか恵まれないので,
            私はまだリモートデバッグを試したことはありません.

            <note>
              <title>Bill による追記</title>
              <para>
                DDB を有効にしていてカーネルがデバッガに
                落ちたら, ddb のプロンプトで &quot;<command>panic</command>&quot;
                と入力すれば, 強制的にパニックを起こしクラッシュダンプさせることができます.
                パニックの途中で, 再びデバッガに落ちるかもしれませんが,
                &quot;<command>continue</command>&quot;
                と入力すれば,
                クラッシュダンプを最後まで実行させられます.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para><function>dlsym()</function> が ELF 実行形式では動作しなくなります!</para>
        </question>

        <answer>
          <para>
            <acronym>ELF</acronym> のツール類は,
            デフォルトでは実行形式の中に定義されているシンボルを,
            ダイナミックリンカから見えるようにはしません.
            このため, <literal>dlopen(NULL, flags)</literal>
            を呼び出して得られたハンドルに対して,
            <function>dlsym()</function> で探索を行っても,
            こういったシンボルを見つけられません.
          </para>
  
          <para>
            もし, あなたがプロセスの中心にあたる実行形式の中にあるシンボルを探索したければ, 
            <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ld">ELF リンカ</ulink> に
            <option>-export-dynamic</option>
            オプションを付けて実行形式をリンクする必要があります.
          </para>
        </answer>
      </qandaentry>

      <qandaentry>
        <question>
          <para>カーネルアドレス空間を大きくしたり,
            小さくするにはどうしたら良いのですか?</para>
        </question>

        <answer>
          <para>
            カーネルアドレス空間は, FreeBSD 3.X 上で
            256MB, FreeBSD 4.X 上で 1GB がデフォルトになっています.
            負荷の高いネットワークサーバ(例えば大きな FTP, HTTP サーバ)を運用する場合は,
            256MB では足りないことに気付くかも知れません.
          </para>
  
          <para>
            では, アドレス空間を大きくするにはどうしたら良いのでしょうか?
            それには, 二つの段階を踏みます. まず,
            より大きいアドレス空間を割り当てることをカーネルに知らせる必要があります.
            次に, カーネルはアドレス空間の先頭にロードされるため,
            アドレスの先頭が天井(訳注:カーネルアドレス空間の最下端アドレスのこと)と
            ぶつかることのないように, ロードアドレスを今までより低位に設定する必要があります.
          </para>
  
          <para>
            最初の段階は, <filename>src/sys/i386/include/pmap.h</filename> にある
            <symbol>NKPDE</symbol> の値を増加させることで行ないます.
            ここに 1GB のアドレス空間にするために, どのようにすれば良いかを示します.
          </para>
  
<programlisting>#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif</programlisting>
  
          <para>
            正確な <symbol>NKPDE</symbol> の値を計算するには,
            望みのアドレス空間の大きさ(メガバイト単位)を 4 で割って,
            それから単一プロセッサ(UP)なら 1, SMP なら 2 を引き算して下さい.
          </para>
  
          <para>
            次の段階を行なうには, ロードアドレスを正確に計算することが必要です.
            単純に, アドレス空間の大きさ(バイト単位)を 0x100100000 から引き算して下さい.
            1GB アドレス空間の場合, その結果は 0xc0100000 になります.
            そして, <filename>src/sys/i386/conf/Makefile.i386</filename> にある
            <symbol>LOAD_ADDRESS</symbol> に, 今計算した値を入れます. また, 次のように
            <filename>src/sys/i386/conf/kernel.script</filename>
            のセクションの始めの方にあるロケーションカウンタにも同じ値を入れて下さい.
          </para>
  
          <programlisting>OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }</programlisting>
  
          <para>
            それが完了したら, <command>config</command> し直してカーネルを再構築して下さい.
            おそらく, <command>ps(1)</command>, <command>top(1)</command>
            などに不具合が出るでしょう.
            それらを正常にするために, <command>make world</command>(もしくは,
            変更した <filename>pmap.h</filename> を <filename>/usr/include/vm/</filename>
            にコピーした後に, <literal>libkvm</literal>,
            <command>ps</command> および <command>top</command>
            を手動で再構築すること)を行なうべきです.
  
            <note>
              <para>カーネルアドレス空間の大きさは, 4MB の倍数である必要があります.</para>
            </note>
          </para>

          <para>
            <note>
              <title><ulink URL="mailto:dg@FreeBSD.org">David Greenman 氏</ulink>による補足</title>
              <para>
                カーネルアドレス空間は 2 の乗数である必要があると思いますが,
                それが確かなことかどうかははっきりしていません.
                昔の起動コードには, 良く高位アドレスビットのトリックが使われていたため,
                少なくとも 256MB の粒度であることが想定されていたと思います.
              </para>
            </note>
          </para>
        </answer>
      </qandaentry>
    </qandaset>
  </chapter>

  <chapter id="aknowledgments">
    <title>謝辞</title>

    <para>
      <emphasis>訳:
        こがよういちろう <email>y-koga@ccs.mt.nec.co.jp</email>,
        1997 年 11 月 10 日.</emphasis>
    </para>
  
    <blockquote>
      <attribution>FreeBSD Core Team</attribution>
      <para>
        この FAQ について問題を見つけたり, 何か登録したい場合は, 
        <email>FAQ@FreeBSD.org</email> までメールを送ってください.
        フィードバックしてくれるみなさんには感謝感謝なのです. 
        みなさんに手伝ってもらわないとこの FAQ はよくなりませんから!
      </para>
    </blockquote>
  
    <para>
      <variablelist>
        <varlistentry><term>Jordan Hubbard</term>
          <listitem>
            <para>たまに起こす FAQ の並べ替えや更新の発作</para>
          </listitem>
        </varlistentry>

        <varlistentry><term>Doug White</term>
          <listitem>
            <para>freebsd-questions メーリングリストでの義務を超えたサービス</para>
          </listitem>
        </varlistentry>

        <varlistentry><term>Joerg Wunsch</term>
          <listitem>
            <para>Usenet (NetNews) での義務を超えたサービス</para>
          </listitem>
        </varlistentry>

        <varlistentry><term>Garrett Wollman</term>
          <listitem>
            <para>ネットワーク節の執筆と文書整形</para>
          </listitem>
        </varlistentry>

        <varlistentry><term>Jim Lowe</term>
          <listitem>
            <para>マルチキャストについて</para>
          </listitem>
        </varlistentry>

        <varlistentry><term>Peter da Silva</term>
          <listitem>
            <para>FreeBSD FAQ タイピング機械奴隷</para>
          </listitem>
        </varlistentry>

        <varlistentry><term>FreeBSD チーム</term>
          <listitem>
            <para>不平を言ったり, うめいたり, 情報提供してくれたり</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
  
    <para>
      あと, 抜けてしまった他の方々に対して, 謝罪と心からの感謝を捧げます!
    </para>
  </chapter>

  <chapter id="jcontrib">
    <title>FreeBSD FAQ 日本語化について</title>

    <para>
      FreeBSD 日本語ドキュメンテーションプロジェクトは,
      FreeBSD 関係の日本語文書が少ないことを嘆いた数人の
      FreeBSD ユーザの提唱によって 1996 年 2 月 26 日にスタートし,
      FreeBSD 日本語ハンドブックの作成をはじめとした活動をおこなってきました. 
      FreeBSD FAQ の日本語化についてはオリジナルの翻訳作業だけでなく,
      日本国内に固有の話題についても広く情報を集め,
      日本の FreeBSD ユーザにとって真に有益なドキュメントを提供しようと考えています. 
      オリジナルの FAQ は日毎に更新されており,
      私たちもまたこれに追い付くために作業を続けていきます. もちろん, 新しいメンバも大歓迎です. 
      日本語翻訳版について, 何かお気づきの点がありましたら,
      FreeBSD 日本語ドキュメンテーションプロジェクト <email>doc-jp@jp.FreeBSD.org</email>
      までご連絡ください. 
      また, もし私たちの作業を手伝ってくれるなら, 
      <ulink URL="http://www.jp.FreeBSD.org/doc-jp/">FreeBSD
        日本語ドキュメンテーションプロジェクトのページ</ulink>をご覧の上, 是非参加してください.
    </para>
  
    <bridgehead renderas="sect2">翻訳者 (五十音順)</bridgehead>

    <itemizedlist>
      <listitem><para>有村 光晴 <email>arimura@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>一宮 亮 <email>ryo@azusa.shinshu-u.ac.jp</email></para></listitem>
      <listitem><para>岩崎 満<email>iwasaki@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>内川 喜章 <email>yoshiaki@kt.rim.or.jp</email></para></listitem>
      <listitem><para>くりやま <email>kuriyama@opt.phys.waseda.ac.jp</email></para></listitem>
      <listitem><para>こがよういちろう <email>y-koga@ccs.mt.nec.co.jp</email></para></listitem>
      <listitem><para>今野 元之 <email>motoyuki@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>杉村 貴士 <email>sugimura@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>中井 幸博 <email>nakai@mlab.t.u-tokyo.ac.jp</email></para></listitem>
      <listitem><para>にしか <email>nishika@cheerful.com</email></para></listitem>
      <listitem><para>花井 浩之 <email>hanai@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>はらだ きろう <email>kiroh@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>広瀬 昌一 <email>shou@kt.rim.or.jp</email></para></listitem>
      <listitem><para>福間 康弘 <email>yasuf@big.or.jp</email></para></listitem>
      <listitem><para>むらたしゅういちろう <email>mrt@mickey.ai.kyutech.ac.jp</email></para></listitem>
      <listitem><para>山下 淳 <email>junkun@esys.tsukuba.ac.jp</email></para></listitem>
    </itemizedlist>

    <bridgehead renderas="sect2">査読者 (五十音順)</bridgehead>

    <itemizedlist>
      <listitem><para>浅見 賢 <email>asami@FreeBSD.org</email></para></listitem>
      <listitem><para>岩崎 満 <email>iwasaki@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>内川 喜章 <email>yoshiaki@kt.rim.or.jp</email></para></listitem>
      <listitem><para>大橋 健 <email>ohashi@mickey.ai.kyutech.ac.jp</email></para></listitem>
      <listitem><para>くりやま <email>kuriyama@opt.phys.waseda.ac.jp</email></para></listitem>
      <listitem><para>今野 元之 <email>motoyuki@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>佐伯 隆司 <email>saeki@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>杉村 貴士 <email>sugimura@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>花井 浩之 <email>hanai@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>浜田 直樹 <email>nao@tom-yam.or.jp</email></para></listitem>
      <listitem><para>はらだ きろう <email>kiroh@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>日野 浩志 <email>hino@ccm.cl.nec.co.jp</email></para></listitem>
      <listitem><para>檜山  卓 <email>shiyama@intercity.or.jp</email></para></listitem>
      <listitem><para>広瀬 昌一 <email>shou@kt.rim.or.jp</email></para></listitem>
      <listitem><para>むらたしゅういちろう <email>mrt@mickey.ai.kyutech.ac.jp</email></para></listitem>
      <listitem><para>若井  久史 <email>earth@hokuto7.or.jp</email></para></listitem>
    </itemizedlist>
    
    <bridgehead renderas="sect2">作業環境整備 (五十音順)</bridgehead>

    <itemizedlist>
      <listitem><para>一宮 亮 <email>ryo@azusa.shinshu-u.ac.jp</email></para></listitem>
      <listitem><para>岩崎 満 <email>iwasaki@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>下川 英敏 <email>simokawa@jp.FreeBSD.org</email></para></listitem>
      <listitem><para>鈴木  秀幸 <email>hideyuki@jp.FreeBSD.org</email></para></listitem>
    </itemizedlist>

  </chapter>
</book>
