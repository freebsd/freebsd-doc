<!-- $FreeBSD$ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.8 --> 

  <sect>
    <heading>X Window System と仮想コンソール<label id="x"></heading>
    <p><em>訳: &a.motoyuki;.<newline>13 November 1997.</em>

    <sect1>
      <heading>X を動かしたいのですが, どうすればいいのですか?</heading>

      <p>もっとも簡単な方法は (訳注: FreeBSD の) インストールの際に
      X を動かすことを指定するだけです.

      <p>それから <htmlurl url=
      "http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config"
      name="xf86config">
      ツールのドキュメントを読んでこれに従ってください.
      このツールはあなたのグラフィックカードやマウスなどに合わせて
      XFree86(tm) の設定を行うのを助けてくれます.

      <p>Xaccel サーバーについて調べてみるのもいいでしょう.
      詳しくは <ref id="xig" name="Xi Graphics について"> か
      <ref id="metrox" name="Metro Link"> をご覧ください.

    <sect1>
      <heading>私のマウスはなぜ X で動かないのでしょうか?<label id="x-and-moused"></heading>

      <p>syscons (デフォルトのコンソールドライバ) を使っているのであれば,
      それぞれの仮想スクリーンでマウスポインターをサポートするように
      FreeBSD を設定できます. X でのマウスの衝突を避けるために, syscons は
      ``<tt>/dev/sysmouse</tt>'' という仮想デバイスをサポートしています.
      本物のマウスデバイスから入力された全てのマウスのイベントは sysmouse
      デバイスへ MouseSystems プロトコルで出力されます.
      一つ以上の仮想コンソールと X の <bf/両方で/ マウスを使いたい場合,
      以下のように設定することをお勧めします:

      <verb>
        /etc/rc.conf:
          moused_type=ps/2            # 実際のマウスのタイプ
          moused_port=/dev/psm0       # 実際のマウスポート
          moused_flags=

        /etc/XF86Config
          Section Pointer
              Protocol "MouseSystems"
              Device   "/dev/sysmouse"
              .....
      </verb>

      <p>X で ``<tt>/dev/mouse</tt>'' を使うのを好む人もいます.
      この場合は, ``<tt>/dev/mouse</tt>'' を
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?sysmouse"
      name="/dev/sysmouse">
      にリンクしてください:

      <verb>
        # cd /dev
        # rm -f mouse
        # ln -s sysmouse mouse
      </verb>

    <sect1>
      <heading>X のメニューやダイアログボックスがうまく動きません.</heading>

      <p>Num Lock キーをオフにしてください. 

      <p>Num Lock キーがデフォルトでブート時にオンになる場合は, 
      <tt/XF86Config/ ファイルの ``<tt/Keyboard/'' セクションに
      以下の行を加えてもいいでしょう. 

      <verb>
        # Let the server do the NumLock processing.  This should only be
        # required when using pre-R6 clients
            ServerNumLock
      </verb>

      訳注: この問題は XFree86 3.2 以降では解決しています. 

    <sect1>
      <heading>仮想コンソールとは何ですか? どうやったら使えますか?</heading>

      <p>仮想コンソールは, 簡単にいうと, ネットワークや X
      を動かすなどの複雑なことをおこなわずに, いくつかのセッションを
      同時におこなうことを可能にします. 

      <p>システムのスタート時には, ブートメッセージが出た後に login 
      プロンプトが表示されます. そこで login ネームとパスワードを
      入力すると 1 番目の仮想コンソール上で仕事 (あるいは遊び) を
      始めることができます.
 
      <p>他のセッションを始めたい場合もあるでしょう. それは動かしている
      プログラムのドキュメントを見たり, FTP の転送が終わるまで待つ間
      メールを読もうとしたりすることかもしれません.
      Alt-F2 を押す (Alt キーを押しながら F2 キーを押す) と 2 番目の
      「仮想コンソール」で login プロンプトが待機していることが
      わかります. 最初のセッションに戻りたいときは Alt-F1 を押します. 

      <p>標準の FreeBSDインストールでは 3 枚の仮想コンソールが
      有効になっていて, Alt-F1, Alt-F2, Alt-F3 で仮想コンソール間の
      切替えをおこないます. 

      より多くの仮想コンソールを有効にするには, <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys">
      を編集して ``Virtual terminals'' のコメント行の後に ``<tt/ttyv4/''
      から ``<tt/ttyvc/'' の手前までのエントリを加えます
      (以下の例は先頭には空白は入りません) :
 
      <verb>
        # /etc/ttys には ttyv3 がありますので 
        # "off" を "on" に変更します. 
        ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
        ttyva   "/usr/libexec/getty Pc"         cons25  on secure
        ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </verb> 

      <p>多くするか少なくするかはあなたの自由です. より多くの仮想
      ターミナルを使うとより多くのリソースを使うことになります.
      8MB 以下のメモリしかない場合はこれは重要な問題です.
      もし必要があれば ``<tt/secure/'' を ``<tt/insecure/''
      に変更してください. 
 
      <p><bf/重要/ X を使いたいのであれば, 最低一つの仮想ターミナル
      (のエントリ) を使わずに残しておくか, off にしておく必要があります.
      つまり, 12 個の Alt-ファンクションキー全てでログインプロンプトを
      出したいのならば不運にも X は使えない, ということです. 
      同じマシンで X サーバーも動かしたいのならば 11 個しか使えません.

      <p>仮想コンソールを無効にするもっとも簡単な方法はコンソールを
      off にすることです. 例えば 12 個全てのターミナルを割り当てている
      状態で X を動かしたいときは仮想ターミナル 12 を変更します:

      <verb>
        ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </verb>

      <p>これを次のように変更します:

      <verb>
        ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </verb>

      <p>キーボードにファンクションキーが 10 個しかないのであれば
      次のように設定します. 

      <verb>
        ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
        ttyva   "/usr/libexec/getty Pc"         cons25  off secure
        ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </verb>

      <p>(これらの行を消すだけでもいいです.)
 
      <p><htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys">
      を編集したら次は十分な数の仮想ターミナルデバイスを
      作らなくてはなりません. もっとも簡単な方法を示します:

      <verb>
        # cd /dev
        # ./MAKEDEV vty12                 # For 12 devices
      </verb>

      <p>さて, 仮想コンソールを有効にするのにもっとも簡単 (そして確実) 
      な方法はリブートすることです. しかし, リブートしたくない場合は,
      X ウィンドウシステムを終了させて次の内容を実行します 
      (<tt/root/ 権限で) :

      <verb>
        kill -HUP 1
      </verb>

      <p>重要な点はこのコマンドを実行する前に X ウィンドウシステムを
      完全に終了させておくことです. もしそうしないと kill コマンドを
      実行した後にシステムはおそらくハングアップするでしょう. 

    <sect1>
      <heading>X から仮想コンソールに切替えるにはどうすればよいのですか? </heading>

      <p>コンソールが X の表示をしている場合は, Ctrl-Alt-F1 などを使って
      仮想コンソールの切替えをおこなうことができます. ただし, X
      から離れて仮想ターミナルへ移っている時は Alt-ファンクションキーを
      使って他の仮想ターミナルへ切替えたり X へ戻ったりします. 
      コントロールキーは押さないでください. Ctrl-Alt-ファンクションキーの
      組合せは X から仮想ターミナルに移る時だけ利用してください.
      コントロールキーを押してしまうと ``control-lock'' モードになり
      テキストコンソールが止まってしまいます. コントロールキーを押して
      回復させてください. 

      <p>訳注: X に戻るには 3枚の仮想コンソールが有効になっている場合は
      Alt-F4 です. 有効な仮想コンソールの数 +1 のファンクションキーの
      位置に X が割り当てられます. 

    <sect1>
      <heading>XDM をブート時に起動させるにはどうしますか?</heading>

      <p><htmlurl url=
      "http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm"
      name="xdm"> の起動方法について, その考え方には二つの流派があります.
      ある流派では提供された例を使用して xdm を
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?ttys"
      name="/etc/ttys"> から起動し, 他の流派では xdm を単に
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?rc" 
      name="rc.local"> または <tt>/usr/local/etc/rc.d</tt> にある
      <tt/X.sh/ スクリプトから起動します.
      どちらも正しく, 片方が動作しない場合は, もう片方が動作するでしょう.
      どちらも場合でも結果は同じであり, X はグラフィカルな
      login: プロンプトを表示します.

      <p>ttys を利用する方法の利点は, どの vty で X が起動したかの記録が
      残せることと, ログアウト時に X サーバを再起動する責任を init に
      押しつけることができることでしょう. 

      <p>rc.local からロードされる場合, <tt/xdm/ は引数を持たずに起動します.
      (すなわち, デーモンとして起動します.) <tt/xdm/ は getty が起動した後に
      ロードされなければなりません. そうでないと, <tt/xdm/ は getty と衝突し,
      コンソールをロックアウトしてしまいます. この問題に対処する最善の方法は
      起動スクリプト(訳注: rc.local のこと)で 10秒ほどの sleepを実行させ,
      その後に xdm をロードすることです.

      <p>以前のバージョンの FAQ では 
      <tt>/usr/X11R6/lib/X11/xdm/Xservers</tt> ファイルに X の使う
      <tt/vt/ を加えるように書いてあります. これは必要ありません:
      X は最初に見つけた利用可能な <tt/vt/ を使います. 

    <sect1>
      <heading>xconsole を動かそうとすると ``Couldn't open console'' とエラーが出ます. </heading>

      <p><htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=X"
      name="X"> を
      <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=startx"
      name="startx"> で起動しますと, /dev/console のパーミッションは
      <tt /変更ができない/ ようになっていますので,
      <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xterm"
      name="xterm -C"> や
      <htmlurl url=
      "http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xconsole"
      name="xconsole"> は動きません. 
    
      <p>これはコンソールのパーミッションが標準ではそのように
      設定されているからです. マルチユーザシステムでは, ユーザの誰もが
      システムコンソールに書き込むことが可能である必要は必ずしもありません.
      VTY を使い 直接マシンにログインするユーザのために,
      このような問題を解決するために
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fbtab"
      name="fbtab"> というファイルがあります. 

      <p>要点を述べると, 次のような形式の行を
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fbtab"
      name="fbtab"> に加えます. 

      <verb>
	/dev/ttyv0 0600 /dev/console
      </verb>

      <p>そうすると, <tt>/dev/ttyv0</tt> からログインしたユーザが
      コンソールを所有することになるでしょう. 


    <sect1>
      <heading>私の PS/2 マウスは X ウィンドウシステム上でうまく動きません. </heading>

      <p>あなたのマウスとマウスドライバがうまく同期していないからかも
      しれません.

      <p>FreeBSD 2.2.5 までのバージョンでは, X から仮想ターミナルへ
      切替えてまた X へ戻ると再同期するかもしれません.
      この問題がよく起きるようであれば, カーネルコンフィグレーション
      ファイルに次のオプションを書いてカーネルを再構成してみてください. 

      <verb>
        options PSM_CHECKSYNC
      </verb>

      <p>もし, カーネルの再構築をおこなったことがないのであれば
      <ref id="make-kernel" name="カーネルを作る">のセクションを
      見てください. 

      <p>このオプションにより, マウスとドライバの同期の問題の起きる
      可能性は少なくなるでしょう. もしそれでもこの問題が起きるようならば,
      再同期させるにはマウスを動かさないようにしておいて
      マウスボタンのどれかを押してください.

      <p>このオプションは残念ながら, すべてのシステムで働くわけではなく
      また, PS/2 マウスポートにつながれているのが ``tap'' の特色を
      持つ ALPS GlidePoint デバイスの場合, ``tap'' が無効となってしまいます.

      <p>FreeBSD 2.2.6 以降のバージョンでは, 同期のチェック方法が少し改善
      されたので標準で有効になっています. GlidePoint でもうまく働きます
      (同期チェックが標準の機能になったので PSM_CHECKSYNC オプションは
      これらのバージョンからは削除されました). しかしながら, 稀れに
      ドライバが間違って(訳注: 問題がないのに)同期に関して問題があると報告し, 
      カーネルから

      <verb>
        psmintr: out of sync (xxxx != yyyy)
      </verb>

      というメッセージが出力されて, マウスが正しく動作していないように見える
      ことがあるかもしれません.

      <p>もしこのようなことが起こる場合には, PS/2 マウスドライバのフラグに
      0x100 を指定して同期チェックを無効にして下さい. システムの起動時に
      ``<tt>-c</tt>'' ブートオプションを与えて <em>UserConfig</em> に入ります.

      <verb>
        boot: -c
      </verb>

      <em>UserConfig</em> のコマンドラインで以下のように入力して下さい.

      <verb>
        > flags psm0 0x100
        > quit
      </verb>

    <sect1>
      <heading>MouseSystems の PS/2 マウスがうまく動きません.</heading>

      <p>MouseSystems の PS/2 マウスのあるモデルは, 高解像度モードの場合
      にのみ正しく動作するということが報告されています. それ以外のモードでは
      マウスカーソルがしょっちゅうスクリーン左上に行ってしまうかもしれません.

      <p>残念ながら FreeBSD 2.0.X や 2.1.X のバージョンではこの問題の解決する
      方法はありません. 2.2 から 2.2.5 のバージョンでは以下のパッチを
      <tt>/sys/i386/isa/psm.c</tt> に適用しカーネルの再構築を行なって下さい.
      <p>もし, カーネルの再構築をおこなったことがないのであれば
      <ref id="make-kernel" name="カーネルを作る">のセクションを
      見てください.

      <verb>
diff -u psm.c.orig psm.c
@@ -766,6 +766,8 @@
     if (verbose >= 2)
 	log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
 	    unit, i);
+    set_mouse_resolution(sc->kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc->kbdc);	/* 1:1 scaling */
     set_mouse_mode(sc->kbdc);		/* stream mode */
       </verb>

      <p>FreeBSD 2.2.6 以降のバージョンでは, PS/2 マウスドライバのフラグに
      0x04 を指定してマウスを高解像度モードにします. システムの起動時に
      ``<tt>-c</tt>'' ブートオプションを与えて <em>UserConfig</em> に入ります.

      <verb>
        boot: -c
      </verb>

      <em>UserConfig</em> のコマンドラインで以下のように入力して下さい.

      <verb>
        > flags psm0 0x04
        > quit
      </verb>


      <p>マウスに関する不具合の他の原因の可能性については直前のセクションも
      見てみて下さい.

  <sect1>
    <heading>X のアプリケーションを構築する時に, <tt/imake/ can't find
    <tt/Imake.tmpl/ となります.  どこにあるのでしょうか?
    </heading>

    <p>Imake.tmpl は X の標準アプリケーション構築ツールである Imake
    パッケージの一部です.
    Imake.tmpl は X アプリケーションの構築に必要な多くのヘッダファイルと
    同様に, X のプログラムディストリビューションに含まれています.
    sysinstall を使うか手動で X のディストリビューションファイルから
    インストールすることができます. </p>

  </sect1> 

  <sect1>
   <heading>マウスのボタンを入れ替える方法はありますか?
   </heading>
 
   <p>.xinitrc か .xsession で <tt/ xmodmap -e "pointer = 3 2 1"/
   というコマンドを実行してください.
   </p>
  </sect1>

  </sect>
