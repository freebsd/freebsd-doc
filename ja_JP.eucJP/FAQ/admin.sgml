<!-- $FreeBSD$ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.22 --> 

  <sect>
    <heading>システム管理<label id="admin"></heading>
    <p><em>訳: &a.nishika;.<newline>12 November 1997.</em>

    <sect1>
      <heading>システムスタートアップファイルはどこにあるのですか?</heading>

      <p>2.0.5R から 2.2.1R までは, プライマリコンフィグレーションファイルは
      <tt>/etc/sysconfig</tt> にあります. オプションはすべて, このファイルと
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?rc"
      name="/etc/rc"> および <tt>/etc/netstart</tt>といった, 
      別のファイルに指定されています. 

      <p>ファイル <tt>/etc/sysconfig</tt> を見て, システムに適合するように
      変更してください. このファイルはそれぞれの場所に何を書けばいいのかを表す
      コメントがたくさん書かれています. 

      <p>2.2.2 に続くリリース と 3.0 では, <tt>/etc/sysconfig</tt> は, 
      より分りやすい名前の <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)"
      name="rc.conf"> に改名され, それに従って
      書式もいくぶん改められます. <tt>/etc/netstart</tt> も
      <tt>/etc/rc.network</tt> に改名され, 全部のファイルを
      <tt><htmlurl url="http://www.freebsd.org/cgi/man.cgi?cp"
      name="cp"> /usr/src/etc/rc* /etc</tt>で一度にコピーすることが
      出来るようになります. 

      <p>ファイル <tt>/etc/rc.local</tt> は常にここにあり, <htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^inn" name="INN">
      や <tt/http/ といった追加のサービス開始や
      カスタムオプションを記述するために使われるでしょう. 

      <p>ファイル <tt>/etc/rc.serial</tt> はシリアルポートの初期化
      (例えばポートの設定を固定したり等々) のためにあります. 

      <p>ファイル <tt>/etc/rc.i386</tt> は iBCS2 エミュレーションのような
      Intel アーキテクチャ固有の設定や PC システムコンソール設定のためにあります. 

      <p>2.1.0R からは, "ローカル" スタートアップファイルをディレクトリ 
      <tt>/etc/sysconfig</tt> (または <tt>/etc/rc.conf</tt>) 
      の中に作って指定することもできます:

      <verb>
        # Location of local startup files.
        local_startup=/usr/local/etc/rc.local.d
      </verb>

      <p>.sh で終わるそれぞれのファイルは, アルファベット順に実行されます. 

      <p>ファイル名を変えることなくある一定の順序で確実に実行したいのであれば, 
      順序が保証されるように以下のようにして, 
      それぞれのファイルの頭に数値をつけるようなデザインを
      使うことができます:

      <verb>
        10news.sh
        15httpd.sh
        20ssh.sh
      </verb>

      <p>この方法は見苦しく (あるいは SysV のように :-)) なりますが, 
      <tt>/etc/rc.local</tt> を 手品のような編集でソートするようなことなく
      ローカルの追加パッケージを使うためには, シンプルでしかもよく使われる
      手法ではあります. ほとんどの ports/packages は 
      <tt>/usr/local/etc/rc.d</tt> をローカルスタートアップディレクトリ
      であると仮定しています. 

    <sect1>
      <heading>簡単にユーザを追加するにはどうすればいいのですか?</heading>

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?adduser"
      name="adduser"> コマンドを使用してください. 

      <p>Ollivier Robert によって Perl で書かれた ``<tt/new-account/'' と
      呼ばれるパッケージもあります. これについては
      <tt>&lt;roberto@FreeBSD.ORG&gt;</tt> にたずねてみてください. 
      現在さらなる開発をおこなっています. 

      <p>また, ユーザを削除するには <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rmuser" name="rmuser">
      コマンドを使用してください. 

    <sect1>
      <heading>FreeBSD システムに新しいハードディスクを追加するには?</heading>

      <p><url url="../../tutorials/diskformat" 
       name="www.freebsd.org"> に書かれているディスクフォーマット
       チュートリアルを参照して下さい.

    <sect1>
      <heading>新しいリムーバブルドライブを持っていますが, どうやって使うの?</heading>

      <p>そのリムーバブルドライブが ZIP であれ EZ drive であれ 
      (あるいはもしそういう風に使いたいのなら, フロッピーであれ), 
      またハードディスクであれ, 一旦システムにインストールされて認識され, 
      カートリッジ, フロッピー等々が挿入されていれば, 
      ことはどのデバイスでも全く同じように進みます. 

      <p><label id="disklabel"> (このセクションは<url
      url="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html"
      name="Mark Mayo's ZIP FAQ"> に基づいています.)

      <p>ZIP ドライブやフロッピーで, すでに DOS のファイルシステムで
      フォーマットしてある場合, 次のコマンドを使うことができます. 
      これはフロッピーの場合です. 

      <verb>
        mount -t msdos /dev/fd0c /floppy
      </verb>

      <p>出荷時の設定の ZIP ディスクではこうです. 

      <verb>
        mount -t msdos /dev/sd2s4 /zip
      </verb>

      <p>その他のディスクに関しては, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fdisk" name="fdisk">
      や <tt>/stand/sysinstall</tt> を使って, どのようにレイアウト
      されているか確かめてください. 

      <p>以降は ZIP ドライブが 3 番目の SCSI ディスクで, 
      sd2 と認識されている場合の例です. 

      <p>他人と共有しなければならないフロッピーやリムーバブルディスク
      でなければ, BSD ファイルシステムを載せてしまうのが良い考えでしょう. 
      ロングファイル名もサポートされ, パフォーマンスは少なくとも 
      2 倍は向上しますし, おまけにずっと安定しています. 
      まず最初に, DOS レベルでのパーティション / ファイルシステムを
      無効にしておく必要があります. 使用するのは <tt/fdisk/ でも
      <tt>/stand/sysinstall</tt> でも結構です. 
      複数のオペレーティングシステムを入れることを考慮する
      必要がないような容量の小さなドライブの場合は, 
      次のように FAT パーティションテーブル (スライス) 
      全体を飛ばして, BSD のパーティション設定を行うだけで良いでしょう. 

      <verb>
        dd if=/dev/zero of=/dev/rsd2 count=2
        disklabel -Brw sd2 auto
      </verb>

      <p>複数の BSD パーティションをつくる場合, disklabel か
      <tt>/stand/sysinstall</tt> を使います. 固定ディスク上にスワップ領域
      を加える場合はそういうことをしたいと思うのはもっともですが, 
      ZIP のようなリムーバブルドライブの上ではそういう考えは不適切
      でしょう. 

      <p>最後に, 新しいファイルシステムをつくります. ディスク全体を使用する
      ZIP ドライブの場合は, 以下のようにします. 

      <verb>
        newfs /dev/rsd2c
      </verb>

      <p>次にマウントします. 

      <verb>
        mount /dev/sd2c /zip
      </verb>

      <p>また, 次のような行を <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fstab"
      name="/etc/fstab"> に入れておくのも良い考えでしょう. 
      "mount /zip" と入力するだけでマウントできるようになります. 

      <verb>
        /dev/sd2c /zip ffs rw,noauto 0 0
      </verb>

    <sect1>
       <heading>どのようにしたら DOS の拡張パーティションをマウントできますか?</heading>

       <p>DOS 拡張パーティションはすべての基本パーティションの後に
       認識されます. たとえば, 2台目の SCSIドライブの拡張パーティションに 
       "E" パーティションがあるとしますと, これは /dev にスライス 5 
       のスペシャルファイルを作る必要があり, /dev/sd1s5 としてマウントされます. 

      <verb>
        # cd /dev
        # ./MAKEDEV sd1s5
        # mount -t msdos /dev/sd1s5 /dos/e
      </verb>

    <sect1>
       <heading>他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</heading>

       <p><bf/ Digital UNIX/ UFS CDROM は直接 FreeBSD でマウント
       することができます. Digital UNIX やそれ以外のシステムのサポートする
       UFS のディスクパーティションをマウントすることはもっと複雑
       なことで, オペレーティングシステムのディスクパーティション
       の詳細に依存します. 

       <p><bf/ Linux/: 2.2 以降は <bf/ext2fs/ パーティションをサポートします. 
       マニュアルの <htmlurl
       url="http://www.freebsd.org/cgi/man.cgi?mount_ext2fs"
       name="mount_ext2fs"> を見てください. より多くの情報があります. 
 
       <p><bf/ NT/: FreeBSD 用の読みだしのみ可能な NTFS ドライバがあります.
       より詳しくは, Mark Ovens 氏によって書かれたチュートリアル
       <htmlurl url="http://www.users.globalnet.co.uk/~markov/ntfs_install.html"
       name="http://www.users.globalnet.co.uk/~markov/ntfs_install.html"> を
       見てください.

       <p>この問題について他の情報があれば, 他の人から感謝されるでしょう. 

    <sect1>
      <heading>どのようにしたら FreeBSD を NT ローダーからブートさせることができますか?</heading>

      <p>FreeBSD のネイティブルートパーティションの最初のセクタを
      ファイルにして DOS/NT パーティション上に置くという画期的な
      アイディアがあります. 
      ファイル名を <tt>c:&bsol;bootsect.bsd</tt> 
      (<tt>c:&bsol;bootsect.dos</tt> からの発想です) 
      としたとします. <tt>c:&bsol;boot.ini</tt> 
      ファイルを次のように編集します:

      <verb>
        [boot loader]
        timeout=30
        default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
        [operating systems]
        multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
        C:\BOOTSECT.BSD="FreeBSD"
        C:\="DOS"
      </verb>

      <p>この手順では DOS, NT, FreeBSD その他が<bf/同じ/ディスクのそれぞれの 
      fdisk パーティションにインストールされているとしています. 
      私の場合は, DOS と NT は最初のパーティション, FreeBSDは 2番目にあります. 
      また, FreeBSD は MBR を<bf/使わずに/, ネイティブパーティションから
      ブートするようにインストールしてあります. 
      (訳注: FreeBSD のインストールではブートマネジャを使わずに標準 
      MBR を使う場合に相当します)

      <p>(もし NTFS に変換してしまっているなら) DOS フォーマットの
      フロッピーディスクか FAT パーティションを <tt>/mnt</tt> に DOS 
      マウントします. 

      <verb>
        dd if=/dev/rsd0a of=/mnt/bootsect.bsd bs=512 count=1
      </verb>

      <p>リブートして DOS か NT に切替えます. NTFS ユーザは 
      <tt/bootsect.bsd/ や <tt/bootsect.lnx/ をフロッピーディスクから
      <tt/C:&bsol;/ へコピーします. <tt/boot.ini/ のファイル属性 
      (パーミッション) の変更を以下のようにおこないます:

      <verb>
        attrib -s -r c:\boot.ini
      </verb>

      <p>上の例の <tt/boot.ini/ で示したような正しいエントリを加え, 
      ファイル属性を元に戻します. 

      <verb>
        attrib -r -s c:\boot.ini
      </verb>

      <p>FreeBSD が MBR からブートするようになっている場合, 
      それぞれのネイティブパーティションからブートするように設定した後で, 
      DOS から ``<tt/fdisk/'' コマンドを実行して元に戻してください. 

    <sect1>
      <heading>
        FreeBSD と Linux を LILO からブートするには?
      </heading>

      <p>FreeBSD と Linux が同じディスクにインストールされている場合,
      単に Linux 以外の OS をブートするための LILO のインストール手順に
      従えばいいだけです. 非常に簡単にではありますが, 記してみましょう:

      <p>Linux をブートし, <tt>/etc/lilo.conf</tt> に以下の行を加えて
      ください:
      <verb>
      other=/dev/hda2
             table=/dev/hda
             label=FreeBSD
      </verb>
      (上記の手順は FreeBSD のスライスが Linux から <tt>/dev/hda2</tt>
      という名前で見えていると仮定しています; あなたの設定にあわせて
      ください) その後, <tt>lilo</tt> を root で実行すれば完了です.

      <p>FreeBSD が別のディスクにインストールされているのなら, LILO の
      エントリに ``<tt>loader=/boot/chain.b</tt>'' を追加してください.
      例えば, このようになります:
      <verb>
      other=/dev/sdb4
             table=/dev/sdb
             loader=/boot/chain.b
             label=FreeBSD
      </verb>

      <p>場合によっては, 二つ目のディスクを正しく起動するために FreeBSD
      ブートローダに BIOS ドライブ番号を指定する必要があるかもしれません.
      例えば, FreeBSD SCSI ディスクが BIOS によって BIOS ディスク 1 と
      して認識されるのなら, FreeBSD のブートローダのプロンプトで, 次の
      ように指定する必要があります:
      <verb>
      Boot: 1:sd(0,a)/kernel
      </verb>

      <p>FreeBSD 2.2.5 やそれ以降の版では, ブート時に上記のことを行なう
      だけで自動的に <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?boot(8)" name="boot(8)">
      が設定されます.

      <p><htmlurl 
      url="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html"
      name="Linux+FreeBSD mini-HOWTO"> が FreeBSD と Linux とを相互に
      使えるようにするためのよい参考資料になるでしょう.

    <sect1>
      <heading>
       FreeBSD と Linux を BootEasy からブートするには?
      </heading>

      <p>LILO をマスターブートレコード (MBR) ではなく Linux のブート
      パーティションにインストールしてください. これで BootEasy から
      LILO をブートできるようになります.

      <p>Windows95 と Linux を使用している場合は, いずれにせよ後者の方が
      お勧めです. Windows95 を再インストールする必要にかられたとき, 
      Linux をブート可能に戻す手続きが簡単ですむからです
      (Windows95 は偏屈なオペレーティングシステムで, マスターブートレコード 
      (MBR) から他のオペレーティングシステムを追い払ってしまうのです).

    <sect1>
      <heading>
        「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?
      </heading>

      <p><label id="dedicate">
      インストール作業中, ハードディスクのパーティションを切る際に
      2 つの方法を選ぶことができます. デフォルトの方法では, fdisk の
      テーブルエントリ (FreeBSD ではスライスと呼ばれる) を使って, 
      自身のパーティションを使用する FreeBSD のスライスを, 同じマシン
      の他のオペレーティングシステムと互換性のある形にします. 
      それに付随して, ブートセレクタをインストールすれば, ディスク上の
      使用可能なオペレーティングシステムを切り替えることができます. 
      もう一つの方法はディスク全てを FreeBSD で使うというもので, この
      場合ほかのオペレーティングシステムとの互換性を考慮しないことに
      なります.


      <p>では, なぜこれが 「危険覚悟の」と言われるのでしょう?
      このモードのディスクが, 通常の PC のユーティリティが有効な fdisk
      テーブルと見なす情報を持っていないからです. ユーティリティの出来
      如何によりますが, そのようなディスクを発見したとき, 警告を
      出すものもあります. また, もっと悪い場合, 確認も通告もなしに
      BSD のブートストラップにダメージを与えるものもあるでしょう. 
      さらには, 「危険覚悟の」ディスクレイアウトは多数の BIOS,
      AWARD (例えば HP Netserver や Micronics システム, 他多数で
      使用されていた) や Symbios/NCR (人気のあるSCSI コントローラ
      53C8xx 用) などを混乱させることが分かっています. これは完全な
      リストではありません. 他にもまだまだあります. この混乱の兆候は,
      起動時にシステムがロックするというだけでなく, FreeBSD のブート
      ストラップが自分自身を見つけられないために表示する "read error"
      というメッセージなどにも現れることでしょう.

      <p>そもそもいったいなぜこのモードがあるのでしょうか? これは
      わずかに数キロバイトのディスク容量を節約するのみであり, 新規
      インストールで実際に問題を生ずるのです. 「危険覚悟の」モードの
      起源は新しい FreeBSD インストーラでの, BIOS から見えるディスクの
      「ジオメトリ」の値とディスク自身との整合性という, もっとも一般的な
      問題のひとつを回避したいという要求が背景にあります.  

      <p>「ジオメトリ」は時代遅れの概念ですが, 未だに PC BIOS と
      ディスクへの相互作用の中核をなしています. FreeBSD のインストーラが
      スライスを作る時, ディスク上のスライスを BIOS が見つけられる
      ようにスライス位置をディスク上に記録します. それが誤っていれば,
      起動できなくなってしまうでしょう.

      <p>「危険覚悟の」モードはこれを, 問題を単純にすることで
      回避しようとします. 状況によってはこれでうまくいきます. 
      しかし次善の策として使われているに過ぎません. この問題を
      解決するもっと良い方法はいくらでもあるのです. 

      <p>では, インストール時に「危険覚悟の専用」モードが必要になる
      状況を回避するにはどうすればよいのでしょうか? 
      まず BIOS が報告するディスクのジオメトリの値を覚えておくことから
      はじめましょう. ``boot:'' プロンプトで ``-v'' を指定するか
      ローダで ``boot -v'' と指定して, ブート時にカーネルにこの値を
      表示させることができます. インストーラが起動する直前に, 
      カーネルがジオメトリ値のリストを表示するでしょう. 
      パニックを起こさないでください. インストーラが起動するのを待ち, 
      逆スクロールでさかのぼって値を確認してください. 普通は BIOS 
      ディスクユニット番号は, FreeBSD がディスクを検出する順序と同様であり, 
      最初に IDE, 次に SCSI となります. 

      <p>ディスクをスライシングする際に, FDISK の画面で表示される
      ディスクのジオメトリが正しいことを確認してください (BIOS の
      返す値と一致しいるか). 万一ちがっていたら ``g'' を押して
      修正してください. ディスクにまったくなにもない場合や他の
      システムから持ってきたディスクの場合は, これをおこなう必要が
      あるかもしれません. これはそのディスクから起動させようと
      している場合にのみ問題になることに注意してください. 
      FreeBSD はそのディスクをうまい具合いに他のディスクと区別して
      くれます. 

      <p>ディスクのジオメトリについて BIOS と FreeBSD 間で一致させる
      ことができたら, この問題はほぼ解決したと思ってよいでしょう. 
      そしてもはや「危険覚悟の専用」モードは必要ありません. 
      しかし, まだブート時に恐怖の ``read error'' メッセージが出るようで
      あれば, お祈りを捧げて新しいディスクを買いましょう. 
      もう失うものは何もありません. 

      <p>「危険覚悟の専用ディスク」を通常の PC での使用法に
      戻すには, 原則として 2 つ方法があります. 1 つは十分な NULL 
      バイトを MBR に書き込んで, きたるべきインストーラにディスク
      はまっさらだと思い込ませる方法です. 例えば, こんな感じです. 
          
      <verb>
        dd if=/dev/zero of=/dev/rsd0 count=15
      </verb>

      <p>また, マニュアルには書かれていない DOS の「機能」

      <verb>
        fdisk /mbr
      </verb>

      <p>は, BSD ブートストラップを追い払ってくれる上に, 
      新しいマスターブートレコードをインストールしてくれます. 

    <sect1>
      <heading>どのようにしたらスワップ領域を増やせますか?</heading>

      <p>スワップパーティションのサイズを増やすのが最良の方法ですが, 
      別のディスクを追加しなくて済むという利点のある方法があります. 
      経験から得た一般的な方法はメインメモリの 2倍程度のスワップ領域を
      とるというものです. しかしごく小さなメインメモリしかない場合は, 
      それ以上のスワップを構成したいと思うでしょう. また, 将来のメモリの
      アップグレードに備え, 後でスワップの構成を変更する必要がないように
      十分なスワップを構成しておくことは良い考えです. 

      <p>スワップを別のディスク上に追加することは, 単純に同じディスク上
      にスワップを追加する場合よりも高速に動作するようになります. 
      例に挙げれば, あるディスク上のソースをコンパイルしているとして, 
      スワップが別のディスク上に作られていれば, これらが同じディスク上
      にある場合よりも断然速いです. SCSI ディスクの場合は特にそうだと言えます. 

      <p>ディスクが複数ある場合, スワップパーティションを各ディスクに
       作るように構成すると, 使用中のディスク上にスワップを置いたとしても,
       通常の場合は有益です. 一般的に, システムにある高速なディスクには
       スワップを作るようにすべきでしょう. 
       FreeBSD はデフォルトでインターリーブなスワップデバイスを 4つまで
       サポートします. 複数のスワップパーティションを構成する際に, 
       普通はそれらを大体同じくらいの大きさにして作りたいところですが, 
       カーネルのコアダンプを取るのに都合が良いようにメインの
       スワップパーティションを大きめにとる人もいます. 
       メインのスワップパーティションはカーネルのコアがとれるように
       最低でも実メモリと同じ大きさにすべきでしょう. 

      <p> IDE ドライブは同時に同じチャネル上の複数のドライブには
      アクセスできません (FreeBSD は mode 4 をサポートしていないので, 
      すべての IDE ディスク I/O は ``programmed'' です). 
      IDE の場合であってもやはり, スワップを別のハードディスク上に
      作成することをおすすめします. 
      ドライブは実に安いものです, 心配するだけ無駄です. 

      <p>NFS 越しにスワッピングさせる方法は, スワップ用の
      ローカルディスクが無い場合にのみ推奨されます. 
      NFS 越しのスワッピングは遅く, FreeBSD 4.x より前のリリースでは
      効率が悪いのですが, 4.0 以降ではそれなりに高速になります. 
      そうはいっても, 利用できるネットワークの太さに制限されますし, 
      NFS サーバに余計な負荷がかかります. 

      <p>これは 64MBの vn-swap を作る例です (ここでは <tt>/usr/swap0</tt> 
      としますが, もちろん好きな名前を使うことができます).

      <p>カーネルが次の行を含むコンフィグファイルから構成されているかを
      確認します. GENERIC カーネルには, この行が含まれています. 

      <verb>
        pseudo-device   vn 1   #Vnode driver (turns a file into a device)
      </verb>

      <enum>
        <item>vn デバイスを作ります
        <verb>
          cd /dev
          sh ./MAKEDEV vn0
        </verb>

        <item>スワップファイルを作ります (<tt>/usr/swap0</tt>)

        <verb>
          dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
        </verb>

        <item><tt>/etc/rc.conf</tt> でスワップファイルを有効化させます

        <verb>
          swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </verb>

        <item>マシンをリブートします
      </enum>

      <p>スワップファイルをすぐに有効化させたいのなら以下のようにタイプします
      <verb>
        vnconfig -ce /dev/vn0c /usr/swap0 swap
      </verb>

    <sect1>
      <heading>プリンタのセットアップで問題があります</heading>

      <p>ハンドブックのプリンタの部分を参照してください. 
      探している問題のほとんどが書かれているはずです. 
      <url url="../handbook/printing.html" 
      name="ハンドブック中のプリンタの利用">をご覧ください. 

    <sect1>
      <heading>私のシステムのキーボードマッピングは間違っています. </heading>

      <p>kbdcontrol プログラムは, キーボードマップファイルを読み込むための
      オプションを備えています. 
      <tt>/usr/share/syscons/keymaps</tt> の下にたくさんのマップファイルがあります. 
      システムに関連のあるものを一つ選んで, ロードしてください. 

      <verb>
        kbdcontrol -l uk.iso
      </verb>

      <tt>/usr/share/syscons/keymaps</tt> と拡張子 <tt/.kbd/ は
      どちらも <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?kbdcontrol"
      name="kbdcontrol"> によって使用されます. 

      <p>これは <tt>/etc/sysconfig</tt> (または <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)"
      name="rc.conf">) 中で設定することができます. 
      このファイル中にあるそれぞれのコメントを参照してください. 

      <p>2.0.5R やそれ以降の版では, テキストフォントやキーボードマッピングに
      関係のあるものはすべて, <tt>/usr/share/examples/syscons</tt> 
      の中におさめられています. 

      <p>現在以下のマッピングがサポートされています:

      <itemize>
        <!-- generate by `kbdmap -p' -->
        <item>Belgian ISO-8859-1 
        <item>Brazilian 275 keyboard Codepage 850 
        <item>Brazilian 275 keyboard ISO-8859-1 
        <item>Danish Codepage 865 
        <item>Danish ISO-8859-1 
        <item>French ISO-8859-1 
        <item>German Codepage 850 
        <item>German ISO-8859-1 
        <item>Italian ISO-8859-1 
        <item>Japanese 106 
        <item>Japanese 106x 
        <item>Latin American 
        <item>Norwegian ISO-8859-1 
        <item>Polish ISO-8859-2 (programmer's) 
        <item>Russian Codepage 866 (alternative) 
        <item>Russian koi8-r (shift) 
        <item>Russian koi8-r 
        <item>Spanish ISO-8859-1 
        <item>Swedish Codepage 850 
        <item>Swedish ISO-8859-1 
        <item>Swiss-German ISO-8859-1 
        <item>United Kingdom Codepage 850 
        <item>United Kingdom ISO-8859-1 
        <item>United States of America ISO-8859-1 
        <item>United States of America dvorak 
        <item>United States of America dvorakx 
      </itemize>

    <sect1>
      <heading>ユーザディスククォータが正常に動作していないようです. </heading>

      <p>
      <enum>
        <item>'/' にはディスククォータを設定しないでください, 

        <item>クォータファイルが置かれるファイルシステム上に
        クォータファイルを置くようにしてください. つまり:
        <verb>
          FS      QUOTA FILE
          /usr    /usr/admin/quotas
          /home   /home/admin/quotas
          ...
        </verb>
      </enum>

    <sect1>
      <heading>わたしの ccd の何が適合していない (Inappropriate) のでしょう?</heading>

      <p>このような症状が現れます:

      <verb>
        # ccdconfig -C
        ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
        #
      </verb>

      <p>通常この現象はタイプを ' 未使用 (unused)' のまま放っておかれた
      'c' パーティションをつなげようとした場合に現れます. ccd ドライバは
      FS_BSDFFS タイプをベースとするパーティションを要求します. 
      つなげようとしているディスクのディスクラベルを編集して, 
      パーティションのタイプを '4.2BSD' に変更してください. 

    <sect1>
      <heading>どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</heading>

      <p>このような症状が現れます:

      <verb>
        # disklabel ccd0
        (it prints something sensible here, so let's try to edit it)
        # disklabel -e ccd0
        (edit, save, quit)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
        #
      </verb>

      <p>これは ccd から返されるディスクラベルが, 実はディスク上にはない
      まったくの偽の情報だからです. これを明示的に書き直すことで
      問題を解消できます, このようになります:

      <verb>
        # disklabel ccd0 > /tmp/disklabel.tmp
        # disklabel -Rr ccd0 /tmp/disklabel.tmp
        # disklabel -e ccd0
        (this will work now)
      </verb>

    <sect1>
      <heading>FreeBSD は System V の IPC プリミティブをサポートしますか? </heading>

      <p>はい. FreeBSD は System-V スタイルの IPC をサポートします. 
      共有メモリ, メッセージ, セマフォが含まれます. 以下の行を
      カーネルコンフィグファイルに加えると, サポートが有効になります. 

      <verb>
        options    SYSVSHM
        options    "SHMMAXPGS=64"   # 256Kb of sharable memory
        options    SYSVSEM          # enable for semaphores
        options    SYSVMSG          # enable for messaging
      </verb>

      <p>コンパイルしてインストールしてください. 

      <p><bf/注:/ GIMP を実行したい場合は, SHMMAXPGS を 4096(16M) 
      くらい馬鹿でかい数字に増やす必要があります. X11R6 の共有メモリは 
      256Kb で十分です. 

    <sect1>
      <heading>
        UUCP で mail を配送するには sendmail をどう使えばよいのですか?<label id="uucpmail">
      </heading>

      <p>FreeBSD に付属している sendmail は, インターネットに直接
      つながっているサイトにあわせて設定してあります. UUCP 経由で mail 
      を交換したい場合には sendmail の設定ファイルを改めてインストール
      しなければなりません. 

      <p><tt>/etc/sendmail.cf</tt>を自分の手で改造するのは純粋主義者の
      やるような事です. sendmailの version 8 は <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?m4" name="m4"> のような
      プリプロセッサを通して設定ファイルを生成する新しいアプローチを
      取っており, より抽象化されたレベルの設定ファイルを編集します. 
      以下のディレクトリの中にある設定ファイルを使用してください. 

      <verb>
        /usr/src/usr.sbin/sendmail/cf
      </verb>

      <p>もしすべてのソースをインストールしていない場合には sendmail 
      の設定ツールは, 別の tar ファイルにまとめてあります. CD-ROM が 
      mount されている場合には, 次のようにしてください. 

      <verb>
        cd /usr/src
        tar -xvzf /cdrom/dists/src/ssmailcf.aa
      </verb>

      <p>これはたった数 100Kbyte ですから心配ないでしょう. <tt>cf</tt> 
      ディレクトリにある <tt>README</tt> に, m4 での設定の基本的な説明があります. 

      <p>UUCP での配送のためには, <em>mailertable</em> を使用すれば
      よいでしょう. これによって, sendmail が配送方式を決定するデータベースを
      作成することができます. 

      <p>まずはじめに, <tt>.mc</tt> ファイルを作成しなければなりません. 
      <tt>/usr/src/usr.sbin/sendmail/cf/cf</tt> というディレクトリが, 
      これらのファイルを作成する場所です. 既にいくつか例があると思います. 
      これから作成するファイルの名前を <tt>foo.mc</tt> とすると, 
      <tt>sendmail.cf</tt> を求めているような形式に変換するには, 
      次のようにしてください. 

      <verb>
        cd /usr/src/usr.sbin/sendmail/cf/cf
        make foo.cf
        cp foo.cf /etc/sendmail.cf
      </verb>

      <p>標準的な <tt>.mc</tt> ファイルは次のようになります. 

      <verb>
        include(`../m4/cf.m4')
        VERSIONID(`Your version number')
        OSTYPE(bsd4.4)

        FEATURE(nodns)
        FEATURE(nocanonify)
        FEATURE(mailertable)

        define(`UUCP_RELAY', your.uucp.relay)
        define(`UUCP_MAX_SIZE', 200000)

        MAILER(local)
        MAILER(smtp)
        MAILER(uucp)

        Cw    your.alias.host.name
        Cw    youruucpnodename.UUCP
      </verb>

      <p><em>nodns</em> と <em>nocanonify</em> という指定をすることで, 
      mail の配送に DNS を使用しなくなります. <em>UUCP_RELAY</em> という
      行に関しては, ある理由から必要ですがそれは聞かないでください. 
      .UUCPで終わる仮想ドメインを処理することのできるインターネット上での
      ホスト名をここに書いてください. 通常は, ISP の mail リレーホストを
      書くことになると思います. 

      <p>これが終了したら, 次に <tt>/etc/mailertable</tt> というファイル
      が必要です. 標準的な例は次のとおりです. 

      <verb>
        #
        # makemap hash /etc/mailertable.db < /etc/mailertable
        #
        horus.interface-business.de   uucp-dom:horus
        .interface-business.de        uucp-dom:if-bus
        interface-business.de         uucp-dom:if-bus
        .heep.sax.de                  smtp8:%1
        horus.UUCP                    uucp-dom:horus
        if-bus.UUCP                   uucp-dom:if-bus
        .                             uucp-dom:sax
      </verb>

      <p>見れば分かるように, これは実在する設定のファイルです. はじめの
      3 行はドメイン名で指定されたメールが default の経路で配送されずに, 
      ``近道'' するために UUCP で隣りのサイトに送るための特別な状況を
      処理するものです. 
      次の行は Ethernet でつながっているローカルのドメインに対しては 
      SMTP で送るための設定です. 
      最後に, UUCP での隣りのサイトが. UUCP で終わる仮想ドメインの書式で
      指定されており, default の rule を ``uucp-neighbour!recipient'' 
      で上書きするためのものです. 一番最後の行はいつもドットを一つ書きます. 
      これは, ここまでの行でマッチしなかったすべてのホストにマッチし, 
      このサイトから世界に向けて出ていくための mail gateway に UUCP 
      で配送するためのものです. 
      <tt>uucp-dom:</tt> に続けて書かれているノード名は, 
      <tt>uuname</tt> コマンドで指定することによって UUCP 
      で直接配送される正しいノード名でなければなりません. 

      <p>最後に, このファイルは使用する前に DBM データベースのファイルに
      変換する必要があります. これをおこなうコマンドラインは mailertable
      の最初のコメントに書いてあります. mailertable を変更した時には, 
      必ずこのコマンドを実行してください. 

      <p>最後のヒントです: もし特定のメール配送がうまく作動するかどうか
      確かめたい場合には, sendmail の<tt>-bt</tt> オプションを
      使用してください. このオプションによって sendmail は
      <em>アドレステストモード</em>で起動します. ``0 '' の後に
      配送したいアドレスを書いてください. 最後の行に, 実際に使用される 
      mail agent, この mail agent で送られる送信先のホスト, そして 
      (多分変換されている) アドレスが表示されます. このモードを抜けるには 
      Control-D を押してください. 

      <verb>
        j@uriah 191% sendmail -bt
        ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
        Enter <ruleset> <address>
        > 0 foo@interface-business.de
        rewrite: ruleset  0   input: foo @ interface-business . de
        ...
        rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
        < @ interface-business . de >
        > ^D
        j@uriah 192%
      </verb>

    <sect1>
      <heading>
        ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?
        <label id="ispmail">
      </heading>

      <p>静的に IP アドレスが割り当てられる場合は, デフォルトの状態を
      変更する必要はありません. 割り当てられた名前をホストネームと
      するだけで, sendmail が後のことを引き受けてくれます. 

      <p>ダイアルアップ <bf/ppp/ をインターネット接続に使用し, 動的に IP
      アドレスが割り当てられる場合は, インターネットサービスプロバイダ
      (ISP) のメールサーバにメールボックスがあるはずです. ISP のドメイン
      が <tt/myISP.com/ で, あなたのユーザ名が <tt/user/ だと仮定します. 
      また, あなたが自分のマシンを <tt/bsd.home/ と呼んでおり, ISP が
      <tt/relay.myISP.com/ をメールリレーとして使用できると言っていると
      しましょう. 

      <p>メールボックスからメールを取ってくるためには, retrieval (回収)
      エージェントをインストールする必要があります. <bf/Fetchmail/ は
      多種多様なプロトコルをサポートしているのでお勧めです. ISP が
      使用しているのは大抵 POP3 プロトコルです. ユーザ ppp を使用している場合, 
      <tt>/etc/ppp/ppp.linkup</tt> に以下のように記述すると, インターネットと
      接続が完了した時点で自動的にメールを取得するようになります. 

      <verb>
        MYADDR:
          !bg su user -c fetchmail
      </verb>

      <p><tt>non-local なアカウントにメールを配送するのに 
      sendmail</tt> を使用している場合 (後述), 上に示したエントリの後に

      <verb>
	  !bg su user -c "sendmail -q"
      </verb>

      を記述します. これはネットワーク接続が確立したらすぐに
      sendmail に溜っている mailqueue を強制的に処理させるようにします. 

      <p>この例では, <tt/user/ が <tt/bsd.home/ にアカウントを持ち, 
      <tt/bsd.home/ 上の <tt/user/ のホームディレクトリに, 以下のような
      <tt/.fetchmailrc/ ファイルがつくられていることを想定しています. 

      <verb>
        poll myISP.com protocol pop3 fetchall pass MySecret;
      </verb>

      <p>言うまでもなく, このファイルは <tt/user/ 以外のユーザが読むことが
      出来ないようにしなくてはなりません. 内容にパスワード <tt/MySecret/ が
      含まれているからです. 

      <p>正しい <bf/from:/ ヘッダをつけてメールを送るためには, sendmail に
      <tt/user@bsd.home/ ではなく <tt/user@myISP.com/ を使用するよう教える
      必要があります. メールをより早く転送するために, 全てのメールを
      <tt/relay.myISP.com/ へ送るように sendmail に指示しておくのも良い
      でしょう. 

      <p>上の要件を満たすには, 以下のような <tt/.mc/ ファイルが適しています. 

      <verb>
        VERSIONID(`bsd.home.mc version 1.0')
        OSTYPE(bsd4.4)dnl
        FEATURE(nouucp)dnl
        MAILER(local)dnl
        MAILER(smtp)dnl
        Cwlocalhost
        Cwbsd.home
        MASQUERADE_AS(`myISP.com')dnl
        FEATURE(allmasquerade)dnl
        FEATURE(masquerade_envelope)dnl
        FEATURE(nocanonify)dnl
        FEATURE(nodns)dnl
        define(SMART_HOST, `relay.myISP.com')
        Dmbsd.home
        define(`confDOMAIN_NAME',`bsd.home')dnl
        define(`confDELIVERY_MODE', `deferred')dnl
      </verb>

      <p><tt/.mc/ ファイルから <tt/sendmail.cf/ への変換方法については, 
      前のセクションを参照してください. sendmail.cf を更新した後に
      sendmail をリスタートするのもお忘れなく. 

    <sect1>
      <heading>しまった! root のパスワードを忘れてしまった!</heading>

      <p>あわてないで下さい! 単にシステムを再起動し, シングルユーザモード
      に移るために Boot: と表示されるプロンプトで -s と入力してください.
      どのシェルを使うのかという質問には, ENTER キーを押してください.
      # プロンプトに移ることができるでしょう. <tt/mount -a / と入力
      して, root ファイルシステムを読み書きできるようにマウントし直した後,
      <tt/passwd root/ と入力して root のパスワードを設定し直して下さい.
      その後, <tt/exit/ と入力すれば, ブートが続けられます.

    <sect1>
      <heading>Control-Alt-Delete でシステムがリブートしないようにするにはどうすればいい?</heading>

      <p>コンソールで使っているキーマップを編集して, <tt/boot/ という
      キーワードを <tt/nop/ に置き換えて下さい. デフォルトキーマップは,
      <tt>/usr/share/syscons/keymaps/us.iso.kbd</tt> にあります. その
      変更を反映させようとして, このキーマップのロードを明示的に行なう
      ために, <tt>/etc/rc.conf</tt> を実行すべきかもしれません. もちろん
      他の国のキーマップを使っているのであれば, 代わりにそのキーマップ
      ファイルを編集して下さい.

  <sect1>
    <heading>DOS のテキストファイルを UNIX のテキストファイルに整形するにはどうすればいい?</heading>

     <p>単に次の perl コマンドを実行してください:

<verb>
perl -i.bak -npe 's/\r\n/\n/g' file ...
</verb>

     <p>file の部分には処理するファイルを指定して下さい. 整形後のファイルは
     元のファイル名で作成され, 整形前のファイルはバックアップとして元の
     ファイル名の末尾に拡張子 .bak のつけられた名前で作成されます.

     <p>あるいは <url url="/cgi/man.cgi?tr" 
	name="tr(1)"> コマンドを使うこともできます:

<verb>
tr -d '\r' &lt; dos-text-file &gt; unix-file
</verb>

     <p>dos-text-file は DOS 形式のテストファイル, 
     unix-file には変換された出力が格納されます. 
     perl を使うよりほんのちょっぴり速くなります. 

   <sect1>
     <heading>名前で指定してプロセスにシグナルを送るにはどうすればいい?</heading>

     <p><url url="/cgi/man.cgi?killall" name="killall(1)"> を
     使って下さい.

   <sect1>
     <heading>su が not in root's ACL と言って私を悩ませるのはなぜ?</heading>

     <p>Kerberos の認証システムからくるエラーです. この問題は致命的なもの
     ではなく, うっとおしいといったものです. su に -K オプションをつけて
     起動するか, 次の質問で説明されている方法で Kerberos をアンインストール
     して下さい.
   
   <sect1>
     <heading>Kerberos をアンインストールするにはどうすればいいの?</heading>

     <p>システムから Kerberos を削除するには, あなたの動かしているリリースの
     bin ディストリビューションを再インストールして下さい. もし CDROM を
     持っているのなら, その CDROM をマウント (マウントポイントは /cdrom と
     仮定) して, 次のように入力して下さい.
    
<verb>
cd /cdrom/bin
./install.sh
</verb>

   <sect1>
     <heading>疑似ターミナルを追加するには?</heading>
 
     <p>telnet, ssh, X, screen をたくさん利用されている場合, 
     疑似ターミナルが足りなくなっている可能性があります. 
     これを増やすには次のようにします:

     <enum>
     <item>次の行をカーネルコンフィグレーションファイルに追加して

     <verb>
       pseudo-device pty 256
     </verb>

     <p>新たにカーネルを作りインストールします. 

     <item>次のコマンドを実行して

     <verb>
     # cd /dev
     # ./MAKEDEV pty{1,2,3,4,5,6,7}
     </verb>

     <p>新たなターミナル用の 256 個のデバイスノードを作ります. 

     <item><tt>/etc/ttys</tt> を編集し 256 個のターミナルごとの定義を追加します. 
     既存のエントリーの形式にあわせる必要があるでしょう. 例えばこんな感じです.

     <verb>
       ttyqc none network
     </verb>

    <p>正規表現を使った指定は <tt>tty[pqrsPQRS][0-9a-v]</tt> となります. 

    <item>新しいカーネルでシステムをリブートすると完了です. 
    </enum>

   <sect1>
     <heading>リブートせずにもう一度 /etc/rc.conf を読み込んで /etc/rc を開始させるには?</heading>

     <p>シングルユーザモードに移行して、マルチユーザモードに戻ってください. 

     コンソールで次のように実行します:
<verb>
     # shutdown now
     (注: -r や -h は付けません)

     # return
     # exit
</verb>

  </sect>

