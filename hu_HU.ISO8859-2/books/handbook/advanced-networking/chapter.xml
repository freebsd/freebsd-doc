<?xml version="1.0" encoding="iso-8859-2"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<!-- The FreeBSD Hungarian Documentation Project
     Translated by: PALI, Gabor <pgj@FreeBSD.org>
     %SOURCE%	en_US.ISO8859-1/books/handbook/advanced-networking/chapter.xml
     %SRCID%	1.433
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="advanced-networking" xml:lang="hu">
  <title>Egyéb haladó hálózati
    témák</title>

  <sect1 xml:id="advanced-networking-synopsis">
    <title>Áttekintés</title>

    <para>Ebben a fejezetben számos komolyabb
      hálózati témát fogunk
      tárgyalni.</para>

    <para>A fejezet elolvasása során
      megismerjük:</para>

    <itemizedlist>
      <listitem>
	<para>az átjárók és az
	  útválasztás alapjait;</para>
      </listitem>

      <listitem>
	<para>hogyan állítsunk be &ieee; 802.11 és
	  &bluetooth; eszközöket;</para>
      </listitem>

      <listitem>
	<para>a &os; segítségével hogyan tudunk
	  két hálózatot összekötni
	  hálózati hidakon keresztül;</para>
      </listitem>

      <listitem>
	<para>hogyan indítsuk hálózatról egy
	  lemez nélküli gépet;</para>
      </listitem>

      <listitem>
	<para>hogyan állítsunk be hálózati
	  címfordítást;</para>
      </listitem>

      <listitem>
	<para>hogyan kapcsoljunk össze két
	  számítógépet PLIP
	  használatával;</para>
      </listitem>

      <listitem>
	<para>hogyan állítsuk be az IPv6
	  használatát egy &os;-s gépen</para>
      </listitem>

      <listitem>
	<para>hogyan állítsuk be az ATM
	  használatát;</para>
      </listitem>

      <listitem>
	<para>hogyan engedélyezzük és
	  használjuk a Közös címredundancia
	  protokollt &os;-ben.</para>
      </listitem>
    </itemizedlist>

    <para>A fejezet elolvasásához ajánlott:</para>

    <itemizedlist>
      <listitem>
	<para>az <filename>/etc/rc</filename> könyvtárban
	  található szkriptek
	  mûködésének ismerete;</para>
      </listitem>

      <listitem>
	<para>az alapvetõ hálózati fogalmak
	  ismerete;</para>
      </listitem>

      <listitem>
	<para>egy új &os; rendszermag
	  beállításának és
	  telepítésének ismerete (<xref linkend="kernelconfig"/>);</para>
      </listitem>

      <listitem>
	<para>a külsõ szoftverek
	  telepítésének ismerete (<xref linkend="ports"/>).</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 xml:id="network-routing">
    <info><title>Átjárók és az
      útválasztás</title>
      <authorgroup>
	<author><personname><firstname>Coranth</firstname><surname>Gryphon</surname></personname><contrib>Készítette: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>útválasztás</primary></indexterm>
    <indexterm><primary>átjáró</primary></indexterm>
    <indexterm><primary>alhálózat</primary></indexterm>

    <para>Egy gép egy másikat úgy tud
      megtalálni a hálózaton, ha erre
      létezik egy olyan mechanizmus, amely leírja, hogyan
      tudunk eljutni az egyiktõl a másikig.  Ezt
      hívjuk
      <firstterm>útválasztásnak</firstterm>
      (routing).  Az <quote>útvonal</quote> (route) címek
      egy párjaként adható meg, egy
      <quote>céllal</quote> (destination) és egy
      <quote>átjáróval</quote> (gateway).  Ez a
      páros mondja meg, hogy ha el akarjuk érni ezt a
      <emphasis>célt</emphasis>, akkor ezen az
      <emphasis>átjárón</emphasis> keresztül
      kell továbbhaladnunk.  A céloknak három
      típusa lehet: egyéni gépek,
      alhálózatok és az
      <quote>alapértelmezett</quote>.  Az
      <quote>alapértelmezett útvonalat</quote> (default
      route) abban az esetben alkalmazzuk, ha semelyik más
      útvonal nem megfelelõ.  Az alapértelmezett
      útvonalakról a késõbbiekben még
      beszélni fogunk.  Három típusa van az
      átjáróknak: egyéni gépek,
      felületek (avagy <quote>linkek</quote>) és a hardveres
      Ethernet címek (MAC-címek).</para>

    <sect2>
      <title>Példa</title>

      <para>Az útválasztás
	különbözõ területeit a
	következõ <command>netstat</command> parancs
	alapján fogjuk bemutatni:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.example.com link#1             UC          0        0
224              link#1             UC          0        0</screen>

      <indexterm><primary>alapértelmezett
	útvonal</primary></indexterm>

      <para>Az elsõ két sorban az alapértelmezett
	útvonalat (melyrõl részleteiben majd a <link linkend="network-routing-default">következõ
	szakaszban</link> fogunk szólni) és a
	<systemitem>localhost</systemitem> útvonalát
	láthatjuk.</para>

      <indexterm><primary>loopback eszköz</primary></indexterm>

      <para>A <systemitem>localhost</systemitem> címhez az
	útválasztási táblázatban a
	<filename>lo0</filename> eszköz tartozik (a
	<literal>Netif</literal> oszlopban), amelyet loopback
	eszköznek is neveznek.  Ez arra utasítja a
	rendszert, hogy az ide küldött csomagokat ne a helyi
	hálózaton küldje keresztül, hanem csak
	ezen a belsõ felületen, mivel úgyis oda
	jutnának vissza, ahonnan indultak.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC-cím</secondary>
      </indexterm>

      <para>A táblázatban a következõ sor egy
	<systemitem class="etheraddress">0:e0</systemitem> kezdetû címet
	tartalmaz.  Ez egy hardveres Ethernet cím, más
	néven MAC-cím.  A &os; magától
	képes beazonosítani tetszõleges gépet
	(ebben a példában a <systemitem>test0</systemitem>
	gépet) a helyi Ethernetes hálózaton
	és felvenni hozzá egy útvonalat,
	közvetlenül az <filename>ed0</filename> Ethernetes
	csatolófelületen keresztül.  Ehhez a
	típusú útvonalhoz tartozik még egy
	lejárati idõ is (a <literal>Expire</literal>
	oszlop), amely akkor kap szerepet, ha ennyi idõ
	elteltével nem kapunk semmilyen hírt a
	géprõl.  Amikor ilyen történik, az
	géphez eddig nyilvántartott útvonal
	automatikusan törlõdik.  Ezek a gépek a RIP
	(útvonal-információs protokoll, Routing
	Information Protocol) nevû mechanizmuson keresztül
	azonosítódnak, mely a legrövidebb út
	kiszámítása alapján határozza
	meg a helyi gépekhez vezetõ útvonalat.</para>

      <indexterm><primary>alhálózat</primary></indexterm>

      <para>A &os; a helyi alhálózat (<systemitem class="ipaddress">10.20.30.255</systemitem> és <systemitem class="fqdomainname">example.com</systemitem>, az
	alhálózathoz tartozó név)
	esetében is felvesz útvonalakat.  A
	<literal>link#1</literal> megnevezés a gépben
	található elsõ Ethernet-kártyát
	jelöli.  Megfigyelhetjük, hogy rajta kívül
	nincs is több felülete.</para>

      <para>Mindegyik csoport (a helyi hálózati
	gépek és a helyi alhálózatokatok)
	útvonalait a <application>routed</application> nevû
	démon tartja automatikusan karban.  Ha ez nem fut, akkor
	csak a statikusan definiált (vagyis az elõre
	megadott) útvonalak fognak létezni.</para>

      <para>A <literal>host1</literal> sor a saját
	gépünkre vonatkozik, amelyet az Ethernet címe
	szerint ismerünk.  Mivel mi vagyunk küldõ
	gép, a &os; tudni fogja, hogy ilyenkor az Ethernetes
	felület helyett a loopback eszközt
	(<filename>lo0</filename>) kell használnia.</para>

      <para>A két <literal>host2</literal> sor arra mutat
	példát, amikor az &man.ifconfig.8; paranccsal
	álneveket hozunk létre (ennek konkrét okait
	lásd az Ethernetrõl szóló
	részben).  A <filename>lo0</filename> felület
	neve után szereplõ <literal>=&gt;</literal>
	szimbólum azt jelzi, hogy ez nem csak egy loopback
	felület (mivel a címe szintén a helyi
	gépre mutat), hanem a felület egy másik neve.
	Ilyen útvonalak csak az álneveket ismerõ
	gépeknél jelennek meg.  A helyi
	hálózaton minden más gépnél
	egyszerûen csak a <literal>link#1</literal> jelenik meg az
	ilyen útvonalak esetében.</para>

      <para>Az utolsó sor (a <systemitem class="ipaddress">224</systemitem>
	céllal rendelkezõ alhálózat) a
	multicastre (többesküldésre) szolgál,
	amellyel majd egy másik szakaszban foglalkozunk.</para>

      <para>Végezetül az útvonalakhoz tartozó
	különféle tulajdonságok a
	<literal>Flags</literal> oszlopban láthatóak.  Az
	alábbi rövid táblázatban
	összefoglaltunk közülük
	néhányat:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="4*"/>

	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Up: az útvonal aktív</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Host: az útvonal egyetlen gépre
		mutat</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Gateway: az adott cél felé ezen a
		gépen keresztül küldjünk, amely
		majd kitalálja, hogy merre küldje
		tovább</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Static: ez az útvonal statikus, nem a
		rendszer hozta létre automatikusan</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Clone: ebbõl az útvonalból
		származtatunk új útvonalat azokhoz
		a gépekhez, amelyekhez csatlakozunk.  Ilyen
		útvonalakat általában a helyi
		hálózatokban találhatunk</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>WasCloned: azt jelzi, hogy ezt az útvonalat
		egy helyi hálózatra mutató
		(klón, avagy Clone típusú)
		útvonal alapján hoztuk létre
		automatikusan</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Link: az útvonal Ethernetes hardverhez
		kapcsolódik</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

    </sect2>

    <sect2 xml:id="network-routing-default">
      <title>Alapértelmezett útvonalak</title>

      <indexterm><primary>alapértelmezett
	útvonal</primary></indexterm>

      <para>Amikor a helyi rendszernek fel kell vennie a kapcsolatot egy
	távoli géppel, ellenõrzi az
	útválasztási táblázatban,
	hogy létezik-e már hozzá valamilyen
	útvonal.  Ha a távoli gép egy olyan
	alhálózatba esik, amelyet már el tudunk
	érni (klónozott útvonalak), akkor a
	rendszer megnézi, hogy a hozzá tartozó
	felületen képes-e kapcsolatot
	létesíteni.</para>

      <para>Ha minden ismert útvonal csõdöt mond, akkor
	a rendszerünknek marad még egy utolsó
	esélye: az <quote>alapértelmezett</quote>
	útvonal használata.  Ez az útvonal egy
	speciális átjáró útvonal
	(ebbõl általában csak egyetlen egy
	létezik a rendszerben) és tulajdonságai
	között mindig szerepel a <literal>c</literal>.  A
	helyi hálózat gépei közül ez az
	átjáró az legyen, amelyik
	közvetlenül kapcsolódik a külsõ
	világhoz (PPP összeköttetéssel, DSL,
	kábelmodem, T1 vagy bármilyen más
	hálózati felületen keresztül).</para>

      <para>Amikor pedig magát a külsõ világ
	felé átjáróként
	szolgáló gépet állítjuk be,
	az alapértelmezett útvonal az
	internet-szolgáltatónk által megadott
	gép címe lesz.</para>

      <para>Vegyünk egy példát az
	alapértelmezett útvonalakra.  Egy tipikus
	konfiguráció:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Helyi2]  &lt;--ether--&gt;  [Helyi1]  &lt;--PPP--&gt; [ Szolg. ]  &lt;--ether--&gt;  [T1-ÁJ]
      </literallayout>
	</textobject>
      </mediaobject>

      <para>A <systemitem>Helyi1</systemitem> és <systemitem>Helyi2</systemitem>
	gépek a hálózatunk tagjai.  A
	<systemitem>Helyi1</systemitem> az internet-szolgáltatót
	éri el egy betárcsázós PPP
	kapcsolaton keresztül.  A PPP szerver a külsõ
	felületén keresztül a helyi
	hálózaton pedig egy másik
	átjáróhoz csatlakozik.</para>

      <para>Az egyes gépek alapértelmezett
	útvonalai így alakulnak:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Gép</entry>
	      <entry>Alapértelmezett
		átjáró</entry>
	      <entry>Felület</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Helyi2</entry>
	      <entry>Helyi1</entry>
	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Helyi1</entry>
	      <entry>T1-ÁJ</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Gyakran felmerül a kérdés, hogy
	<quote>Miért (és hogy-hogy) a
	<systemitem>T1-ÁJ</systemitem> a <systemitem>Helyi1</systemitem>
	gép számára az alapértelmezett
	átjáró és nem a
	szolgáltató azon szervere, amelyhez
	csatlakozott?</quote></para>

      <para>Ne felejtsük el, hogy a PPP felület a
	szolgáltató helyi hálózatában
	a mi részünkre kap címet, és a itt az
	összes többi géphez tartozó
	útvonal automatikusan létrejön.  Emiatt
	már eleve el tudjuk érni a
	<systemitem>T1-ÁJ</systemitem> gépet, ezért amikor
	a szolgáltatón keresztül küldünk,
	nincs szükségünk egy további
	lépcsõre.</para>

      <para>Általában a <systemitem class="ipaddress">X.X.X.1</systemitem> címet szokták a
	helyi hálózat
	átjárójának kiosztani.  Ezért
	(az elõbbi példát
	újrahasznosítva) ha a helyi
	hálózatunkon a C osztályú <systemitem class="ipaddress">10.20.30</systemitem> címtartományt
	használjuk, és a szolgáltatónkhoz a
	<systemitem class="ipaddress">10.9.9</systemitem> címtartomány
	tartozik, akkor az alapértelmezett útvonalak a
	következõk lesznek:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Gép</entry>
	      <entry>Alapértelmezett útvonal</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Helyi2 (10.20.30.2)</entry>
	      <entry>Helyi1 (10.20.30.1)</entry>
	    </row>
	    <row>
	      <entry>Helyi1 (10.20.30.1, 10.9.9.30)</entry>
	      <entry>T1-ÁJ (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Az <filename>/etc/rc.conf</filename>
	állományon keresztül könnyen meg tudjuk
	adni az alapértelmezett útvonalat.  A
	példánkban a <systemitem>Helyi2</systemitem> gép
	<filename>/etc/rc.conf</filename>
	állományába kell felvennünk a
	következõ sort:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>A &man.route.8; parancs használatával viszont
	akár közvetlenül is megtehetjük
	mindezt:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>A &man.route.8; man oldalon olvashatunk arról
	bõvebben, hogy a hálózati
	útválasztási táblázatokat
	kézzel hogyan tudjuk módosítani.</para>

    </sect2>

    <sect2 xml:id="network-dual-homed-hosts">
      <title>Kettõs hálózatú
	gépek</title>

      <indexterm><primary>kettõs hálózatú
	gépek</primary></indexterm>

      <para>Egy másik típusú
	konfigurációról is szót kell
	ejtenünk, ahol a gép egyszerre két
	hálózatnak is tagja.  Gyakorlatilag az
	átjáróként üzemelõ
	számítógépek (mint
	például az, amelyik a fenti példában
	PPP kapcsolattal csatlakozott) ilyen kettõs
	hálózatú gépnek tekinthetõek.
	Ez a kifejezés azonban igazából csak azokra
	az esetekre illik, ahol a gép egyszerre két helyi
	hálózatban is megjelenik.</para>

      <para>Az egyik esetben a gépben két Ethernet
	kártya található, melyek mindegyike
	birtokol egy-egy hálózati címet az egyes
	alhálózatokon.  De elõfordulhat az is, hogy a
	gépünkben csupán egyetlen Ethernet
	kártya van és az &man.ifconfig.8;
	segítségével álneveket hoztunk
	létre hozzá.  Az elõbbi
	általában két fizikailag
	elkülönölõ Ethernet alapú
	hálózat esetében történik,
	míg az utóbbinál csak egyetlen fizikai
	hálózati szegmensrõl van szó, amely
	viszont logikailag két külön
	alhálózatot tartalmaz.</para>

      <para>Akármelyiket is vesszük, az
	útválasztási táblázatok
	úgy jönnek létre, hogy bennük a
	gép a másik alhálózat felé
	átjáróként (bejövõ
	útvonalként) lesz nyilvántartva.  Ebben a
	konfigurációban a gép a két
	alhálózat között
	útválasztóként fog
	tevékenykedni, és gyakran valamelyik vagy
	éppen mind a két irányba be kell
	állítanunk valamilyen csomagszûrést
	vagy tûzfalazást.</para>

      <para>Ha azt szeretnénk, hogy ez a gép a két
	felület között továbbítson
	csomagokat, akkor a &os;-ben külön engedélyezni
	kell ezt a lehetõséget.  A következõ
	szakaszban ennek részleteit tárjuk fel.</para>

    </sect2>

    <sect2 xml:id="network-dedicated-router">
      <title>Az útválasztók
	beállítása</title>

      <indexterm><primary>útválasztó</primary></indexterm>

      <para>A hálózati útválasztó nem
	csinál mást, csak továbbküldi az egyik
	felületén beérkezõ csomagokat egy
	másik felületére.  Az internetes
	szabványok és a sokéves mérnöki
	tapasztalat azonban nem engedik, hogy a &os; Projekt
	alapértelmezés szerint is
	elérhetõvé tegye ezt a &os; rendszerekben.
	Ezt a lehetõséget az alábbi
	változó <literal>YES</literal>
	értékûre
	állításával lehet
	engedélyezni az &man.rc.conf.5;
	állományban:</para>

      <programlisting>gateway_enable="YES"          # Ez legyen YES, ha átjáróként akarunk üzemelni</programlisting>

      <para>Ezzel lényegében a
	<varname>net.inet.ip.forwarding</varname> &man.sysctl.8;
	változó értékét
	állítjuk <literal>1</literal>-re.  Ha
	valamiért egy idõre szüneteltetni akarjuk a
	csomagok továbbküldését, akkor
	állítsuk a változó
	értékét <literal>0</literal>-ra.</para>

      <indexterm><primary>BGP</primary></indexterm>
      <indexterm><primary>RIP</primary></indexterm>
      <indexterm><primary>OSPF</primary></indexterm>

      <para>Az új útválasztónak nem
	árt arról sem tudnia, hogy merre
	továbbítsa a forgalmat.  Ha elég
	egyszerû a hálózatunk, akkor akár
	statikus útvonalakat is használhatunk.  A &os;
	alapból tartalmazza a BSD-k esetén
	szabványos &man.routed.8; útválasztó
	démont, amely a RIP (v1 és v2) valamint az IRDP
	megoldásokat ismeri.  A BGP v4, OSPF v2 és a
	többi fejlettebb útválasztási
	protokoll a <package>net/zebra</package>
	csomagban érhetõ el.  Az ettõl bonyolultabb
	hálózati útválasztási
	feladatokhoz olyan kereskedelmi termékek is
	elérhetõek, mint például a
	<application>&gated;</application>.</para>
    </sect2>

    <sect2 xml:id="network-static-routes">
      <info><title>Statikus útvonalak
	beállítása</title>
	<authorgroup>
	  <author><personname><firstname>Al</firstname><surname>Hoang</surname></personname><contrib>Írta: </contrib></author>
	</authorgroup>
      </info>

      

      <sect3>
	<title>Manuális konfiguráció</title>

	<para>Tegyük fel, hogy hálózatunk a
	  következõ:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/static-routes"/>
	  </imageobject>

	  <textobject>
	<literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) alapértelmezett átjáró internet felé
      |
      |az xl0 felület
      |10.0.0.10/24
   +------+
   |      | A-utvalaszto
   |      | (FreeBSD átjáró)
   +------+
      | az xl1 felület
      | 192.168.1.1/24
      |
  +--------------------------------+
   1. belsõ hálózat    | 192.168.1.2/24
                       |
                   +------+
                   |      | B-utvalaszto
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     2. belsõ hálózat
	</literallayout>
	  </textobject>
	</mediaobject>

	<para>Ebben a forgatókönyvben az
	  <systemitem>A-utvalaszto</systemitem> a mi &os;-s gépünk,
	  amely az internet felé vezetõ
	  útválasztó szerepét
	  játssza.  Számára az
	  alapértelmezett útvonal a <systemitem class="ipaddress">10.0.0.1</systemitem>, amelyen keresztül a
	  külsõ világot tudja elérni.
	  Feltételezzük, hogy a
	  <systemitem>B-utvalaszto</systemitem> nevû gépet
	  már eleve jól állítottuk be,
	  ezért tudja merre kell mennie.  (A kép
	  alapján egyszerû: csak vegyünk fel egy
	  alapértelmezett útvonalat a
	  <systemitem>B-utvalaszto</systemitem> géphez, ahol így a
	  <systemitem class="ipaddress">192.168.1.1</systemitem> lesz az
	  átjáró.)</para>

	<para>Ha megnézzük most az
	  <systemitem>A-utvalaszto</systemitem>
	  útválasztási
	  táblázatát, akkor nagyjából
	  a következõket fogjuk látni:</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Az <systemitem>A-utvalaszto</systemitem>
	  útválasztási táblázata
	  alapján jelen helyzetben nem lehet elérni a 2.
	  belsõ hálózatot.  Nincs ugyanis olyan
	  útvonal, amely a <systemitem class="ipaddress">192.168.2.0/24</systemitem> alhálózat
	  felé vezetne.  Ezt például úgy
	  tudjuk megoldani, ha manuálisan felvesszük ezt az
	  útvonalat.  Az alábbi paranccsal
	  hozzáadjuk a 2.  belsõ hálózat
	  elérését az <systemitem>A-utvalaszto</systemitem>
	  útválasztási
	  táblázatához, ahol a <systemitem class="ipaddress">192.168.1.2</systemitem> lesz a következõ
	  ugrási pont (next hop):</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Most már az <systemitem>A-utvalaszto</systemitem>
	  bármelyik gépet képes elérni a
	  <systemitem class="ipaddress">192.168.2.0/24</systemitem>
	  hálózaton.</para>

      </sect3>

      <sect3>
	<title>Rögzített konfiguráció</title>

	<para>A fenti példa tökéletesen
	  szemlélti a statikus útvonalak
	  felvételét egy mûködõ rendszeren.
	  Azonban ezzel az a gond, hogy az így megadott
	  útválasztási információ nem
	  marad meg a gép újraindítása
	  után.  Ezért az elõbbihez hasonló
	  statikus útvonalakat inkább az
	  <filename>/etc/rc.conf</filename> állományban
	  rögzítsük:</para>

	<programlisting># A 2. belsõ hálózat elérését felvesszük statikus útvonalként
static_routes="belsohalo2"
route_belsohalo2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>A <literal>static_routes</literal>
	  konfigurációs változó
	  karakterláncok szóközzel tagolt
	  felsorolását tartalmazza.  Mindegyik
	  karakterlánc egy útvonal neve.  Az iménti
	  példában csak egyetlen ilyen név
	  szerepelt a <literal>static_routes</literal>
	  értékében, amely a
	  <replaceable>belsohalo2</replaceable> volt.  Utána
	  beírtunk még egy konfigurációs
	  változót is, amelynek a neve
	  <literal>route_belsohalo2</literal>.
	  Ide helyeztük a &man.route.8; parancsnak
	  átadandó beállítás
	  összes paraméterét.  Ez pontosan olyan,
	  mintha a következõ parancsot adtuk volna ki:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Ezért kellett a <literal>"-net 192.168.2.0/24
	  192.168.1.2"</literal>.</para>

	<para>Ahogy már korábban is
	  említettük, a <literal>static_routes</literal>
	  értékében több karakterláncot
	  is megadhatunk, aminek segítségével
	  egyszerre több statikus útvonalat is
	  létrehozhatunk.  A következõ sorok arra
	  mutatnak példát, hogy a <systemitem class="ipaddress">192.168.0.0/24</systemitem> és <systemitem class="ipaddress">192.168.1.0/24</systemitem> hálózatok
	  számára miként állítsunk be
	  statikus útvonalakat a képzeletbeli
	  útválasztónkon:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2 xml:id="network-routing-propagation">
      <title>Az útvonalak terjedése</title>

      <indexterm><primary>útvonalterjedés</primary></indexterm>

      <para>Azt már tudjuk, hogyan adjuk meg a
	külvilág felé vezetõ útvonalakat,
	azonban arról még nem beszéltünk, hogy
	kívülrõl miként találnak meg
	bennünket.</para>

      <para>Annyit már megismertünk, hogy az
	útválasztási táblázatokban
	megadhatjuk a hálózaton azt a gépet,
	amelyen keresztül az adott címtartomány (a
	példában egy C osztályú
	alhálózat) felé küldhetünk, amely
	pedig továbbküldi a hozzá érkezõ
	csomagokat.</para>

      <para>Amikor a csatlakozunk az
	internet-szolgáltatónkhoz, a nála levõ
	útválasztási táblázatok
	úgy állítódnak be, hogy az
	alhálózatunk felé igyekvõ adatok a
	korábban létrejött PPP
	összeköttetésen keresztül jutnak el
	hozzánk.  A világ többi részén
	levõ rendszerek viszont honnan fogják tudni, hogy a
	mi internet-szolgáltatónknak
	küldjenek?</para>

      <para>Van egy rendszer (ez leginkább a névszerverek
	elosztott információs adatbázisához
	hasonlít), ami nyilvántartja a pillanatnyilag
	kiosztott címtartományokat és megadja a
	csatlakozási pontjukat az internet
	gerinchálózatán.  Ez a
	<quote>gerinc</quote> tulajdonképpen olyan
	fõvonalakból áll, amelyen keresztül a
	világban az országok között mozog az
	internet forgalma.  A gerinchálózat mindegyik
	gépe tárolja a központi
	útválasztási táblázatok egy
	másolatát, ami a forgalmat egy adott
	hálózatról a megadott gerincbeli
	hordozóra irányítja át, végig
	az internet-szolgáltatók láncán
	egészen addig, amíg az el nem éri a
	hálózatunkat.</para>

      <para>A szolgáltatónk feladata, hogy a
	gépünk felé leágazásként
	(és így a felénk vezetõ
	útként) beregisztálja magát a
	gerinchálózat gépein.  Ezt nevezik az
	útvonal terjedésének.</para>
    </sect2>

    <sect2 xml:id="network-routing-troubleshooting">
      <title>Hibaelhárítás</title>

      <indexterm><primary><command>traceroute</command></primary></indexterm>

      <para>Néha gondok lehetnek az útvonal
	terjedésével, és egyes gépek nem
	képesek elérni minket.  A &man.traceroute.8;
	parancs mind közül talán az egyik leghasznosabb
	ilyen helyzetekben, mivel ezzel fel tudjuk deríteni, hogy
	az útválasztás hol akad meg.  Ugyanilyen
	jól hasznosítható azokban az esetekben,
	amikor látszólag nem tudunk elérni egy
	távoli gépet (tehát a &man.ping.8;
	csõdöt mond).</para>

      <para>A &man.traceroute.8; parancsnak annak a távoli
	gépnek a nevét kell megadnunk, amelyhez
	csatlakozni akarunk.  Futása közben
	megjeleníti azokat az átjárókat,
	amelyeken keresztül csatlakozni próbál,
	akár sikerült elérni a
	célgépet, akár a kapcsolat hiánya
	miatt kudarcot vall.</para>

      <para>A parancs használatáról és
	mûködésérõl részletesebb
	információkat a &man.traceroute.8; man
	oldalán találunk.</para>
    </sect2>

    <sect2 xml:id="network-routing-multicast">
      <title>Útválasztás multicast
	esetén</title>

      <indexterm>
	<primary>multicast útválasztás</primary>
      </indexterm>

      <indexterm>
	<primary>a rendszermag
	  beállításai</primary>
	<secondary>MROUTING</secondary>
      </indexterm>

      <para>A &os; alapból támogatja mind a multicastet
	használó alkalmazásokat, mind pedig a
	multicasthez tartozó útválasztást.
	Multicast esetében semmilyen speciális
	beállítás nem szükségeltetik,
	az ilyen alkalmazások egybõl el tudják
	érni ezt a lehetõséget.  A multicast
	kérések
	útválasztásához azonban be kell
	építenünk némi
	támogatást a rendszermagba:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Emellett még el kell indítanunk az
	&man.mrouted.8; démont is, amelyhez az
	<filename>/etc/mrouted.conf</filename> állományban
	még be kell állítanunk tunneleket és
	a <acronym>DVMRP</acronym> használatát.  A
	multicasthez tartozó további
	beállításokat az &man.mrouted.8; man
	oldalán találhatjuk.</para>

      <note>
	<para>A &os;&nbsp;7.0 megjelenésével a
	  &man.mrouted.8; démont kivették az
	  alaprendszerbõl.  Azt a <acronym>DVMRP</acronym>
	  többesküldési protokollt
	  valósítja meg, amelyet a legtöbb
	  alkalmazásban mostanság már a &man.pim.4;
	  segítségével oldanak meg.  Ennek
	  megfelelõen a hozzá tartozó
	  multicast protokollt valósítja meg, amelyet a
	  legtöbb alkalmazásban mostanság már
	  a &man.pim.4; segítségével oldanak meg.
	  Ennek megfelelõen a hozzá tartozó
	  &man.map-mbone.8; és &man.mrinfo.8;
	  segédprogramok is eltávolításra
	  kerültek.  Ezek a programok attól a
	  kiadástól kezdõdõen a
	  Portgyûjtemény részeként
	  érhetõek el a <package>net/mrouted</package> portban.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="network-wireless">
    <info><title>Vezeték nélküli
      hálózatok</title>
      <authorgroup>
	<author><personname><othername>Loader</othername></personname></author>

	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname></author>

	<author><personname><firstname>Murray</firstname><surname>Stokely</surname></personname></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>vezeték nélküli
      hálózatok</primary></indexterm>

    <indexterm>
      <primary>802.11</primary>
      <see>vezeték nélküli
	hálózatok</see>
    </indexterm>

    <sect2>
      <title>A vezeték nélküli
	hálózatok alapjai</title>

      <para>A legtöbb vezeték nélküli
	hálózat az &ieee; 802.11 szabványon nyugszik.
	Az alapvetõ vezeték nélküli
	hálózatokban több olyan
	állomást találhatunk, amelyek
	egymással rádiójelek
	szórásával kommunikálnak a
	2,4&nbsp;GHz vagy 5&nbsp;GHz frekvenciatartományban (noha
	ez a helyi viszonyoknak megfelelõen változhat,
	és a 2,3&nbsp;GHz, illetve a 4,9&nbsp;GHz
	tartományokban is lehetséges a
	kommunikáció).</para>

      <para>A 802.11 szabványú hálózatok
	kétféleképpen szervezõdnek.
	Elõször is
	<emphasis>infrastrukturálisan</emphasis>,
	(infrastructural mode) ahol az egyik állomást
	kinevezzük a központnak és a többi pedig
	ehhez fog tartozni.  Az ilyen hálózatokat BSS-nek
	nevezzük és az imént említett
	központ neve hozzáférési pont (Access
	Point, AP) lesz.  A BSS-ben az összes
	kommunikáció a hozzáférési
	pontokon keresztül halad még abban az esetben is,
	amikor az egyik állomás egy másik
	vezeték nélküli állomással
	akarja felvenni a kapcsolatot.  Az ilyen jellegû
	hálózatok másik típusú
	szervezõdési módjában nincsenek
	kijelölt központok és a
	kommunikáció az állomások
	között közvetlenül zajlik.  A
	hálózat ezen formáját IBBS-nek
	nevezzük, vagy ismeretebb nevén <emphasis>ad-hoc
	hálózatnak</emphasis> (ad-hoc network).</para>

      <para>A 802.11 alapú hálózatok
	elsõként a 2,4&nbsp;GHz-es sávot
	hódították meg, és az &ieee; 802.11
	valamint 802.11b szabványokban rögzített
	protokollokat használták.  Ezekben a
	specifikációkban megtalálhatjuk a
	mûködési frekvenciát, a
	közeghozzáférési réteg
	jellemzõinek leírását,
	beleértve a keretezést és az
	átviteli sebességeket (a
	kommunikáció ugyanis eltérõ
	sebességekkel is történhet).  A
	késõbb kiadott 802.11a szabvány azt
	specifikálja, hogy az 5&nbsp;GHz-es tartományban
	miként mûködjenek, ahol többek közt
	megtalálhatjuk a különféle
	jelkezelési mechanizmusokat és a nagyobb
	átviteli sebességek használatát.
	Ezt még a 802.11g szabvány követte, ami a
	802.11b hálózatokkal kompatibilis módon
	lehetõvé tette a 802.11a
	jelkezelésének és átviteli
	módszereinek használatát a 2,4&nbsp;GHz-es
	sávban.</para>

      <para>A 802.11 alapú hálózatok
	mindenféle átviteli technikáitól
	eltekintve többféle biztonsági
	megoldással találkozhatunk.  Az korai 802.11
	dokumentumok egy nagyon egyszerû biztonsági
	protokollt, a WEP-et említenek.  Ez a protokoll a
	hálózaton mozgó adatokat egy
	rögzített és ismert osztott kulccsal
	kódolja le az RC4 titkosítással.  A
	kommunikációhoz az összes
	állomásnak elõre meg kell egyeznie ebben a
	kulcsban.  Errõl a sémáról
	idõközben kiderült, hogy könnyen
	feltörhetõ és manapság már csak
	nagyon ritkán alkalmazzák, kivéve
	talán csak a kóbor felhasználók
	elijesztésére.  A jelenleg érvényes
	biztonsági elõírásokat az &ieee; 802.11i
	specifikáció adja meg, amely új
	kriptográfiai titkosításokat
	definiál valamint egy további protokollt az
	állomások azonosítására
	és a kulcsok cseréjére.  Emellett a
	titkosításhoz használt kulcsok
	idõszakosan frissülnek és külön
	eszközök állnak rendelkezésre a
	betörési kísérletek
	észlelésére (és azok
	elhárítására).  A vezeték
	nélküli hálózatok esetében
	másik elterjedt titkosítási protokoll a
	WPA.  Ez igazából 802.11i elõdjének
	tekinthetõ, amelyet egy ipari csoport definiált,
	amíg a 802.11i minõsítés alatt
	állt.  A WPA ennek megfelelõen teljesíti a
	802.11i szabvány elvárásainak egy
	részét és kifejezetten a régi
	hardverek számára készült.  A WPA
	mûködéséhez egyedül a TKIP
	titkosításra van szükségünk,
	amely az eredeti WEP titkosításból
	származik.  A 802.11i engedi a TKIP
	használatát, de az adatok
	kódolására egy erõsebb
	titkosítás, az AES-CCM ismeretét is
	igényli.  (Az AES a WPA esetében nem kell, mivel a
	régi eszközök esetében
	túlságosan költségesnek
	ítélték meg a
	használatát.)</para>

      <para>A fenti szabványokon kívül a 802.11e a
	másik fontos szabvány, amire tekintettel kell
	lennünk.  Ez írja le a 802.11
	hálózatokon a multimédiás
	alkalmazások közvetítéséhez,
	mint például a videók valós
	idejû lejátszásához vagy a VoIP (voice
	over IP) megvalósításához
	tartozó protokollokat.  A 802.11i szabványhoz
	hasonlóan a 802.11e is magában foglal egy
	elõzetes specifikációt, amelyet WME
	(késõbb pedig már WMM)-nek neveznek.  Ezt
	szintén egy ipari csoport definiálta a 802.11e
	részeként, amivel a 802.11e végsõ
	elfogadásáig tudják a
	multimédiás igényeket kiszolgálni.
	Amit a 802.11e és WME/WMM megoldásaival
	kapcsolatban érdemes tudnunk: a QoS (Quality of Service)
	protokoll és más egyéb fejlett
	közeghozzáférési protokollok
	segítségével a vezeték
	nélküli hálózatokban
	lehetõvé teszik a forgalom prioritás szerinti
	ütemezését.  Ezen protokollok megfelelõ
	implementációjának
	segítségével tehát a fontosabb
	adatok nagy sebességû küldését
	és áramoltatását vagyunk
	képesek elérni.</para>

      <para>A &os; a 6.0 verzió óta ismeri a 802.11a,
	802.11b és 802.11g szabványokon alapján
	mûködõ hálózatokat.  A WPA
	és 802.11i biztonsági protokollok (a 11a, 11b
	és 11g szabványok bármelyike esetén)
	hasonlóképpen támogatottak, valamint a
	WME/WMM protokollok mûködéséhez
	szükséges QoS csak bizonyos vezeték
	nélküli eszközök esetében.</para>

    </sect2>

    <sect2 xml:id="network-wireless-basic">
      <title>Kezdeti beállítások</title>

      <sect3>
	<title>A rendszermag beállítása</title>

	<para>A vezeték nélküli
	  hálózatok használatához egy
	  vezeték nélküli hálózati
	  kártyára lesz szükségünk,
	  valamint a rendszermagban is be kell állítani
	  ehhez a megfelelõ támogatást.  Ez
	  utóbbit több különbözõ modulra
	  szedték szét, és ezek közül
	  csak azokat kell beállítani, amelyeket
	  tényleg használni is fogunk.</para>

	<para>Elõször is tehát kell egy vezeték
	  nélküli eszköz.  Az elterjedtebb
	  típusaik általában az Atheos által
	  gyártott alkatrészeket tartalmazzák.  Az
	  ilyen fajtájú eszközöket az
	  &man.ath.4; meghajtó kezeli, melyet úgy tudunk a
	  rendszer indításakor betölteni, ha a
	  <filename>/boot/loader.conf</filename>
	  állományba felvesszük a következõ
	  sort:</para>

	<programlisting>if_ath_load="YES"</programlisting>

	<para>Az Atheos meghajtója három
	  különálló részre oszlik: maga a
	  meghajtó (&man.ath.4;), a hardveres réteg, ami a
	  chipfüggõ funkciókat kezeli (&man.ath.hal.4;)
	  és a keretek küldésével kapcsolatban
	  az átviteli sebesség
	  megválasztását lehetõvé
	  tevõ algoritmus (ez itt most az ath_rate_sample).  Amikor
	  ezt a támogatást modulként
	  töltjük be, ezek a függõségek
	  automatikusan feloldódnak.  Ha az Atheos
	  eszközök helyett valamelyik másikhoz
	  tartozó modult szeretnénk használni,
	  akkor például az Intersil Prism esetében
	  a &man.wi.4; meghajtót kell megadnunk:</para>

	<programlisting>if_wi_load="YES"</programlisting>

	<note>
	  <para>A leírás további részeiben
	    az &man.ath.4; eszközt fogjuk használni, minden
	    más esetben ennek a nevét kell csak
	    lecserélünk a példákban.  A
	    rendszerben elérhetõ vezeték
	    nélküli meghajtók és az
	    általuk támogatott kártyák
	    listája a &os; Hardverjegyzetekben
	    található.  Ezek a jegyzetek a
	    különbözõ architektúrákra
	    és kiadásokhoz a &os;
	    holnapjáról, a <link xlink:href="http://www.FreeBSD.org/releases/index.html">Kiadási jegyzetek</link>
	    oldalról érhetõek el.  Ha a
	    vezeték nélküli
	    eszközünkhöz nem létezik natív
	    &os;-s meghajtó, akkor az <link linkend="config-network-ndis">NDIS</link> meghajtó
	    segítségével akár
	    közvetlenül a &windows;-os
	    meghajtóját is használhatjuk.</para>
	</note>

	<para>&os;&nbsp;7.<replaceable>X</replaceable> esetén az
	  eszközmeghajtó
	  beállításával együtt a 802.11
	  hálózatok támogatását is be
	  kell töltenünk a rendszermagba.  Ez az &man.ath.4;
	  meghajtó esetében a legalább a
	  &man.wlan.4;, <literal>wlan_scan_ap</literal> és
	  <literal>wlan_scan_sta</literal> modulok
	  betöltését jelenti.  A &man.wlan.4; modul a
	  vezetéknélküli eszköz
	  meghajtóprogramjával együtt
	  töltõdik be, míg a többi modult a
	  <filename>/boot/loader.conf</filename> állomány
	  használatával kell a
	  rendszerindítás során
	  betöltenünk:</para>

	<programlisting>wlan_scan_ap_load="YES"
wlan_scan_sta_load="YES"</programlisting>

	<para>A &os;&nbsp;8.0 kiadástól
	  kezdõdõen ezek a modulok részei a &man.wlan.4;
	  meghajtónak, amely a hálózati
	  kártya meghajtójával együtt mindig
	  automatikusan betöltõdik.</para>

	<para>Emellett még azokra a modulokra is
	  szükségünk van, amelyek a használni
	  kívánt biztonsági protokollokhoz
	  nyújtanak kriptográfiai
	  támogatást.  Ezek hivatalosan a &man.wlan.4;
	  modul kérésére automatikusan
	  betöltõdnek, azonban itt most manuálisan
	  állítjuk be.  Erre a célra a
	  következõ modulokat találjuk:
	  &man.wlan.wep.4;, &man.wlan.ccmp.4; és
	  &man.wlan.tkip.4;.  A &man.wlan.ccmp.4; és
	  &man.wlan.tkip.4; meghajtók csak akkor fognak kelleni,
	  ha a WPA és/vagy a 802.11i biztonsági
	  protokollokat használjuk.  Amennyiben a
	  hálózatunkon nincs titkosítás,
	  akkor még a &man.wlan.wep.4; támogatás
	  sem kell.  Ezeket a modulok úgy lehet betölteni a
	  rendszerindításnál, ha felvesszük a
	  következõ sorokat a
	  <filename>/boot/loader.conf</filename>
	  állományba:</para>

	<programlisting>wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"</programlisting>

	<para>Miután ezt megcsináltuk, egyszerûen
	  csak indítsuk újra a gépünket.  Ha
	  még nem akarjuk újraindítani a
	  gépet, akkor a &man.kldload.8; parancs
	  segítségével akár kézzel is
	  betölthetjük az elõbb felsorolt
	  modulokat.</para>

	<note>
	  <para>Ha nem akarunk modulokat használni, a
	    mûködéshez szükséges
	    meghajtókat a rendszermagba is be tudjuk
	    építeni a következõ sorok
	    megadásával a rendszermag
	    beállításait tartalmazó
	    állományban:</para>

	  <programlisting>device wlan                # a 802.11 támogatása
device wlan_wep            # 802.11 WEP  támogatás
device wlan_ccmp           # 802.11 CCMP támogatás
device wlan_tkip           # 802.11 TKIP támogatás
device wlan_amrr           # AMRR forgalomvezérlési algoritmus
device ath                 # Atheros IEEE 802.11 vezeték nélküli hálózati meghajtó
device ath_hal             # az Atheros meghajtó hardveres rétege
options AH_SUPPORT_AR5416  # az AR5416 tx/rx leírók engedélyezése
device ath_rate_sample     # SampleRate forgalomvezérlési algoritmus</programlisting>

	  <para>Hozzátesszük, hogy az alábbi sorok
	    hozzáadása a &os; 7.<replaceable>X</replaceable>
	    változatában kötelezõ, más
	    verzióknál viszont nem:</para>

	  <programlisting>device wlan_scan_ap        # a 802.11 AP módú keresés
device wlan_scan_sta       # a 802.11 STA módú keresés</programlisting>

	  <para>Az elõbbiek megadásával
	    fordítsuk újra és telepítsük
	    a rendszermagot, majd indítsuk újra a
	    számítógépünket.</para>
	</note>

	<para>Miután a rendszerünk újra elindult, a
	  rendszer indítás során generált
	  üzenetei között találnunk kell
	  valamennyi információt a felismert
	  vezeték nélküli eszközökrõl.
	  Például:</para>

	<screen>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Az infrastrukturális mûködési
	mód</title>

      <para>Általában az infrastrukturális avagy a
	BBS mód használata a gyakori.  Ebben a
	mûködési módban adott
	számú vezeték nélküli
	hozzáférési pont csatlakozik a
	hagyományos hálózatra.  Mindegyik
	vezeték nélküli hálózatnak
	saját neve van, amit a hálózat
	SSID-jének hívunk.  A vezeték
	nélküli kliensek ezekhez a vezeték
	nélküli hozzáférési pontokhoz
	kapcsolódnak.</para>

      <sect3>
	<title>A &os;-s kliensek használata</title>

	<sect4>
	  <title>Hogyan keressünk hozzáférési
	    pontokat</title>

	  <para>A hálózatok kereséséhez az
	    <command>ifconfig</command> paranccsal tudunk nekifogni.
	    Egy ilyen kérés kiszolgálása
	    eltarthat néhány pillanatig, mivel ekkor a
	    rendszernek végig kell bóklásznia az
	    összes elérhetõ frekvenciát
	    és azokon hozzáférési pontok
	    után kutatni.  Egyedül a
	    rendszeradminisztrátor kezdeményezheti ezeket
	    a kereséseket:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE  S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA</screen>

	  <note>
	    <para>Csak <option>up</option> jelzésû
	      felületen tudunk hálózatokat keresni.
	      További keresésekre már nincs
	      szükség a felület <option>up</option>
	      állapotban tartásához.</para>
	  </note>

	  <note>
	    <para>&os;&nbsp;7.<replaceable>X</replaceable> esetén
	      a <filename>wlan0</filename>
	      eszköz helyett közvetlenül az adott
	      eszköz nevét kell megadnunk,
	      például
	      <filename>ath0</filename>.
	      Az iménti sorokat ennek megfelelõen
	      tehát ebben az esetben így kell
	      értelmezni:</para>

	    <screen>&prompt.root; <userinput>ifconfig ath0 up scan</userinput></screen>

	    <para>A leírás további
	      részében a
	      &os;&nbsp;7.<replaceable>X</replaceable>
	      felhasználóknak ezen séma
	      alapján kell használniuk a parancsokat
	      és a konfigurációs
	      beállításokat.</para>
	  </note>

	  <para>A keresés során keletkezõ
	    listában láthatjuk megtalált BBS vagy
	    IBBS fajtájú hálózatokat.  A
	    hálózatok neve és
	    <literal>SSID</literal>-ja mellett még megjelenik egy
	    <literal>BSSID</literal> oszlop is, ahol a
	    hozzáférési pontok MAC-címe
	    szerepel.  A <literal>CAPS</literal> oszlop az egyes
	    állomások tulajdonságait adja
	    meg:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>E</literal></term>

	      <listitem>
		<para>Extended Service Set (ESS): az
		  állomás egy infrastrukturális
		  vagyis BBS hálózat része.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>I</literal></term>

	      <listitem>
		<para>IBSS/ad-hoc hálózat: az
		  állomás egy ad-hoc hálózat
		  része.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>P</literal></term>

	      <listitem>
		<para>Privacy: a BBS-en belül minden keretet
		  titkosítani kell.  Tehát a BSS arra
		  kötelezi az állomást, hogy WEP,
		  TKIP vagy AES-CCMP titkosítás
		  használatával kódolja a
		  hálózat tagjai között
		  közlekedõ kereteket.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>S</literal></term>

	      <listitem>
		<para>Short Preamble: a hálózatban
		  rövid bevezetõjeleket használnak (a
		  802.11b High Rate/DSSS PHY
		  elõírásai szerint), ahol a
		  szokványos 128&nbsp;bites
		  szinkronizációs mezõ hossza csak
		  56&nbsp;bit.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>s</literal></term>

	      <listitem>
		<para>Short Slot Time: a 802.11g hálózat
		  rövid slotidõt használ, mivel nem
		  találhatóak benne régi (802.11b
		  szabványú)
		  állomások.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>A jelenleg ismert hálózatok
	    listáját így tudjuk
	    lekérdezni:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 list scan</userinput></screen>

	  <para>Ezt az információt maga az adapter
	    automatikusan, vagy a felhasználó tudja
	    frissíteni a <option>scan</option>
	    kérés kiadásával.  Az elavult
	    adatok maguktól törlõdnek a
	    gyorsítótárból, így
	    idõvel a lista zsugorodni fog, hacsak nem keresünk
	    folyamatosan hálózatokat.</para>

	</sect4>

	<sect4>
	  <title>Alapvetõ beállítások</title>

	  <para>Ebben a szakaszban arra mutatunk példákat,
	    hogy miként tudunk &os; alatt
	    titkosítás nélkül használni
	    egy vezeték nélküli
	    hálózati kártyát.  Miután
	    elsajátítottuk az itt szereplõ
	    ismereteket, határozottan javasoljuk, hogy a
	    vezeték nélküli
	    hálózatunkat <link linkend="network-wireless-wpa">WPA</link>
	    használatával állítsuk
	    be.</para>

	  <para>A vezeték nélküli
	    hálózatok beállítása
	    három elemi lépésbõl
	    épül fel: a hozzáférési
	    pont kiválasztása, az állomásunk
	    hitelesítése és az IP-cím
	    beállítása.  A következõkben
	    ezeket a lépéseket vitatjuk meg.</para>

	  <sect5>
	    <title>A hozzáférési pont
	      kiválasztása</title>

	    <para>A legtöbb esetben hagyjuk, hogy a rendszer
	      válassza ki magának a
	      különbözõ heurisztikák
	      alapján a leginkább megfelelõ
	      hozzáférési pontot.  Ez az
	      alapértelmezett tevékenység, amikor
	      aktiváljuk a felületet vagy valamilyen
	      más módon, például
	      az<filename>/etc/rc.conf</filename>
	      állományból hivatkozunk
	      rá:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <note>
	      <para>A korábban említettek szerint a
		&os;&nbsp;7.<replaceable>X</replaceable>
		felhasználóknak csak a
		kártyát kell
		beállítani:</para>

	      <programlisting>ifconfig_ath0="DHCP"</programlisting>
	    </note>

	    <para>Ha viszont több hozzáférési
	      pont közül mi magunk akarunk kiválasztani
	      egyet, akkor ezt az SSID megadásával
	      tehetjük meg:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>saját_ssid</replaceable> DHCP"</programlisting>

	    <para>Amikor olyan környezetben vagyunk, ahol több
	      hozzáférési pontnak is megegyezik az
	      SSID-ja (gyakran így próbálják
	      egyszerûsíteni azt, hogy automatikusan
	      váltani lehessen köztük), akkor
	      szükségünk lehet ezt egy adott
	      eszközhöz hozzárendelni.  Ebben az
	      esetben a hozzáférési pont
	      BSSID-ját is definiálni kell (és az
	      SSID-t akár el is hagyhatjuk):</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>saját_ssid</replaceable> bssid <replaceable>xx:xx:xx:xx:xx:xx</replaceable> DHCP"</programlisting>

	    <para>Más módokon is képesek vagyunk
	      szabályozni a hozzáférési
	      pontok megválasztását,
	      például a rendszerünk által
	      vizsgált frekvenciasávok
	      megadásával.  Ez olyankor tud hasznos lenni,
	      ha többsávos vezeték
	      nélküli kártyánk van, és
	      az összes tartomány
	      végigpásztázása
	      túlságosan sok idõt venne el.  Ezt a
	      mûvelet a <option>mode</option> paraméter
	      megadásával lehet egy konkrét
	      sávra leszûkíteni,
	      például a</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="mode <replaceable>11g</replaceable> ssid <replaceable>saját_ssid</replaceable> DHCP"</programlisting>

	    <para>beállítás hatására
	      a kártya 802.11g módban fog üzemelni,
	      ami kizárólag csak 2,4&nbsp;GHz-es
	      frekvenciákon használható, így
	      az 5&nbsp;GHz-es csatornákat egyszerûen
	      figyelmen kívül hagyjuk.  Ugyanezt a
	      <option>channel</option> paraméterrel is meg tudjuk
	      oldani, mivel így a mûködést egy
	      adott frekvenciára korlátozzuk, valamint a
	      <option>chanlist</option> paraméterrel, ahol a
	      pásztázandó csatornákat
	      sorolhatjuk fel.  Ezekrõl a
	      paraméterekrõl részletesebb
	      leírást az &man.ifconfig.8; man oldalon
	      találhatunk.</para>
	  </sect5>

	  <sect5>
	    <title>Hitelesítés</title>

	    <para>Miután sikeresen kiválasztottuk a
	      számunkra megfelelõ
	      hozzáférési pontot, az adatok
	      küldéséhez az
	      állomásunknak valamilyen módon
	      hitelesítenie kell magát.  A
	      hitelesítés több módon
	      történhet.  Erre a leggyakrabban alkalmazott
	      sémát nyílt
	      hitelesítésnek (open authentication)
	      nevezik, ahol a hálózathoz tetszõleges
	      állomás csatlakozhat és
	      kommunikálhat vele.  Ezt a típusú
	      hitelesítést akkor érdemes
	      használni, amikor a vezeték
	      nélküli hálózatunkat
	      teszteljük.  Más sémákban az
	      adatfolyam megindításához egy
	      titkosítási kézfogás
	      szükséges, vagy elõre megosztott kulcsok
	      esetleg jelszavak segítségével, vagy
	      bonyolultabb sémák esetében itt
	      még olyan különbözõ
	      háttérszolgáltatások is
	      megjelennek, mint például a RADIUS.  A
	      legtöbb felhasználó a nyílt
	      hitelesítést használja, ami egyben az
	      alapértelmezés is.  A másik
	      legelterjedtebb beállítás a WPA-PSK,
	      avagy WPA Personal, amelyrõl <link linkend="network-wireless-wpa-wpa-psk">lentebb</link>
	      még szólni fogunk.</para>

	    <note>
	      <para>Ha &apple; &airport; Extreme Base Station
		típusú hozzáférési
		pontunk van, akkor az osztott kulcsú
		hitelesítés mellett egy WEP kulcsot is be
		állítanunk.  Ezt az
		<filename>/etc/rc.conf</filename>
		állományban vagy a &man.wpa.supplicant.8;
		programban tehetjük meg.  Ha egyetlen &airport;
		bázisállomásunk van, akkor az
		elérést valahogy így tudjuk
		beállítani:</para>

	      <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey <replaceable>1</replaceable> wepkey <replaceable>01234567</replaceable> DHCP"</programlisting>

	      <para>Általánosságban véve
		elmondhatjuk, hogy az osztott kulcsú
		hitelesítést inkább
		kerüljük el, mivel WEP kulcsok
		használatára alapszik és
		ráadásul olyan módon, hogy nagyon
		könnyû feltörni.  Ha már
		mindenképpen a WEP mellett kell
		döntenünk (például a
		régebbi eszközökkel így tudunk
		csak kompatibilisek maradni), akkor jobban
		járunk, ha a <literal>nyílt</literal>
		hitelesítéshez alkalmazzuk.  A WEP
		használatát érintõ
		további információkat a <xref linkend="network-wireless-wep"/>ban
		találjuk.</para>
	    </note>
	  </sect5>

	  <sect5>
	    <title>IP-cím szerzése DHCP
	      használatával</title>

	    <para>Miután kiválasztottunk egy
	      hozzáférési pontot és
	      beállítottuk a hitelesítés
	      paramétereit, egy IP-cím is kelleni fog a
	      kommunikációhoz.  Az esetek
	      túlnyomó részében DHCP-n
	      keresztül kapunk IP-címet a vezeték
	      nélküli kapcsolatunkhoz.  Ezt úgy
	      érhetjük el, ha egyszerûen megnyitjuk az
	      <filename>/etc/rc.conf</filename> állományt
	      és az alábbihoz hasonló módon
	      felvesszük a <literal>DHCP</literal>
	      paramétert az eszközünk
	      beállításaihoz:</para>

	    <programlisting>wlans_ath0="DHCP"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Így már készen is állunk a
	      vezeték nélküli felület
	      használatára:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput></screen>

	    <para>Ahogy a felület
	      mûködõképessé válik,
	      az <command>ifconfig</command> parancs
	      segítségével ellenõrizni is
	      tudjuk az <filename>ath0</filename> felület
	      állapotát:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</screen>

	    <para>A <literal>status: associated</literal> azt jelenti,
	      hogy sikeresen csatlakoztunk egy vezeték
	      nélküli hálózathoz (jelen
	      esetben ez a <literal>dlinkap</literal>).  A
	      <literal>bssid 00:13:46:49:41:76</literal> rész a
	      hozzáférési pont
	      MAC-címét tartalmazza.  Az
	      <literal>authmode OPEN</literal> pedig arról
	      számol be, hogy a kommunikáció nem
	      titkosított.</para>

	  </sect5>

	  <sect5>
	    <title>Statikus IP-cím</title>

	    <para>Ha valami okból nem tudjuk az
	      IP-címünket DHCP szerveren keresztül
	      lekérni, beállíthatunk
	      rögzített IP-címet is.  Ehhez nem kell
	      mást tennünk, mint a korábban
	      bemutatott <literal>DHCP</literal> kulcsszót
	      kicserélni egy konkrét címmel.  A
	      hozzáférési ponthoz megadott
	      többi paramétert azonban
	      feltétlenül hagyjuk meg:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable>ssid <replaceable>saját_ssid</replaceable>i"</programlisting>

	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wpa">
	  <title>WPA</title>

	  <para>A WPA (Wi-Fi Protected Access, vagyis védett
	    wi-fi hozzáférés) a 802.11
	    szabványokban használatos biztonsági
	    protokoll, amelyet a <link linkend="network-wireless-wep">WEP</link>
	    gyengeségeinek és megfelelõ
	    hitelesítésének
	    ellensúlyozására dolgoztak ki.  A WPA a
	    802.1X hitelesítési protokolljait
	    erõsíti és az adat
	    sértetlenségének
	    megõrzésére a WEP helyett több
	    titkosítási algoritmust is felhasznál.
	    A WPA által igényelt egyetlen
	    titkosítás a TKIP (Temporary Key Integrity
	    Protocol, vagyis az ideiglenes kulcs integritási
	    protokoll), amely a WEP által az integritás
	    ellenõrzésére és a
	    bejutások észlelésére és
	    azok reagálására szánt alap RC4
	    titkosítást bõvíti ki.  A TKIP a
	    régebbi hardvereken csupán szoftveres
	    módosítással
	    mûködõképessé tehetõ.  Ez
	    a kompromisszum a védelmet ugyan növeli, de
	    még mindig kevés a támadások
	    megfelelõ elhárításához.  A
	    WPA a TKIP mellett tartalmazza még az AES-CCMP
	    titkosítást is, és ennek a
	    használata javasolt.  Ezt a
	    specifikációt gyakran WPA2 (vagy RSN)
	    néven emlegetik.</para>

	  <para>A WPA definiál hitelesítési
	    és titkosítási protokollokat.  A
	    hitelesítés általában a
	    következõ két technika egyike
	    alapján történik: vagy 802.1X és
	    egy háttérszolgáltatás,
	    például a RADIUS
	    segítségével, vagy egy elõre
	    megosztott kulcsot alkalmazó minimális
	    kézfogással az állomás és
	    a hozzáférési pont között.
	    Az elõbbit gyakran WPA Enterprise-nak, míg az
	    utóbbit WPA Personalnak hívják.  Mivel
	    a legtöbben nem állítanak be egy komplett
	    RADIUS alapú szervert a vezeték
	    nélküli hálózatukhoz, ezért
	    a WPA-PSK a WPA leginkább elterjedten használt
	    változata.</para>

	  <para>A vezeték nélküli kapcsolat és
	    a hitelesítés (kulcs alapján vagy
	    szerverrel) vezérlését a
	    &man.wpa.supplicant.8; segédprogram végzi.
	    Ennek a programnak mûködéséhez egy
	    konfigurációs állományra van
	    szüksége, amely az
	    <filename>/etc/wpa_supplicant.conf</filename> néven
	    érhetõ el.  Errõl az
	    állományról bõvebb
	    információt a &man.wpa.supplicant.conf.5; man
	    oldalán lelhetünk.</para>

	  <sect5 xml:id="network-wireless-wpa-wpa-psk">
	    <title>WPA-PSK</title>

	    <para>A WPA-PSK, más néven WPA-Personal, egy
	      adott jelszó alapján generált
	      elõre megosztott kulcssal (pre-shared key, PSK)
	      mûködik, amit a vezeték
	      nélküli hálózatokban
	      mesterkulcsént használnak.  Ez azt jelenti,
	      hogy minden egyes vezeték nélküli
	      felhasználó ugyanazon a kulcson osztozik.  A
	      WPA-PSK olyan kis méretû
	      hálózatok esetében megfelelõ,
	      ahol a hitelesítést elvégzõ
	      szerver használata nem lehetséges vagy nem
	      oldható meg.</para>

	    <warning>
	      <para>Mindig igyekezzünk erõs jelszavakat
		használni, melyek kellõen hosszúak
		és sokféle karaktert tartalmaznak,
		és így nehezebben fejthetõek meg vagy
		törhetõek fel.</para>
	    </warning>

	    <para>Elõször az
	      <filename>/etc/wpa_supplicant.conf</filename>
	      állományban állítsuk be az
	      SSID-t és a hálózatunkhoz
	      tartozó elõre megosztott kulcsot:</para>

	    <programlisting>network={
  ssid="freebsdap"
  psk="freebsdmall"
}</programlisting>

	    <para>Ezután az <filename>/etc/rc.conf</filename>
	      állományban jelezzük, hogy a
	      vezeték nélküli eszközt a WPA
	      segítségével állítjuk
	      be és az IP-címet a DHCP szervertõl
	      kérjük el:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_ath0="WPA DHCP"</programlisting>

	    <para>Innentõl már fel is tudjuk
	      éleszteni a felületet:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Kézzel is megpróbálhatjuk
	      elindítani az <link linkend="network-wireless-wpa-wpa-psk">elõbb</link>
	      elkészített
	      <filename>/etc/wpa_supplicant.conf</filename>
	      állomány használatával:</para>

	    <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]</screen>

	    <para>A következõ parancs a
	      <command>dhclient</command> indítása legyen,
	      amivel megszerezzük a DHCP szervertõl az
	      IP-címünket:</para>

	    <screen>&prompt.root; <userinput>dhclient wlan0</userinput>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
&prompt.root; <userinput>ifconfig wlan0</userinput>
ath0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <note>
	      <para>Ha az <filename>/etc/rc.conf</filename>
		állományban szerepel a
		<literal>ifconfig_wlan0="DHCP"</literal> sor, akkor
		egyáltalán nem szükséges a
		<command>dhclient</command> parancs manuális
		kiadása, mivel a <command>dhclient</command>
		magától el fog indulni, miután a
		<command>wpa_supplicant</command> egyeztette a
		kulcsokat.</para>
	    </note>

	    <para>Amikor a DHCP nem használható,
	      megadhatunk a statikus IP-címet is, miután a
	      <command>wpa_supplicant</command> sikeresen
	      lebonyolította a hitelesítést:</para>

	    <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
ath0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Ha egyáltalán nem használunk DHCP
	      szervert, akkor nekünk kell beállítani
	      az alapértelmezett átjárót
	      és a névszervert is:</para>

	    <screen>&prompt.root; <userinput>route add default alapértelmezett_átjáró</userinput>
&prompt.root; <userinput>echo "nameserver névszerver" &gt;&gt; /etc/resolv.conf</userinput></screen>

	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-tls">
	    <title>WPA és EAP-TLS</title>

	    <para>A másik mód, ahogy a WPA
	      használható, az a 802.1X
	      hitelesítési szerveren keresztül
	      történik, és ebben az esetben a WPA
	      neve WPA-Enterprise.  Ez sokkal biztonságosabb a
	      WPA-Personal elõre kiosztott kulcsaival szemben.  A
	      WPA-Enterprise az EAP (Extensible Authentication Protocol,
	      azaz Bõvíthetõ hitelesítési
	      protokoll) használatán alapszik.</para>

	    <para>Az EAP önmaga nem végez
	      titkosítást, mivel úgy
	      alakították ki, hogy magát az EAP
	      protokollt kell egy titkosított járaton
	      keresztül bújtatni.  Az EAP
	      hitelesítési módszereinek több
	      típusát is kidolgozták, melyek
	      közül a legismertebbek az EAP-TLS, EAP-TTLS
	      valamint a EAP-PEAP.</para>

	    <para>Az EAP-TLS (EAP szállítási
	      rétegbeli védelemmel) a vezeték
	      nélküli világban egy nagyon jól
	      támogatott hitelesítési protokoll,
	      mivel ez volt az elsõ EAP módszer, amit a
	      <link xlink:href="http://www.wi-fi.org/">Wi-fi
	      szövetség</link> jóváhagyott.
	      Az EAP-TLS mûködéséhez
	      három tanúsítvány kell: egy
	      hitelesítõ hatóságtól
	      (Certificate Authority, CA), egy a
	      hitelesítést végzõ
	      szervertõl és egy a klienstõl.  Ezzel az
	      EAP módszerrel mind a hitelesítõ
	      szerver, mind a vezeték nélküli kliens
	      külön képviselik a saját
	      tanúsítványaikat, és ezeket a
	      szervezetünket hitelesítõ
	      hatóság aláírása
	      alapján ellenõrzik.</para>

	    <para>A korábbiaknak megfelelõen a
	      beállításokat szintén az
	      <filename>/etc/wpa_supplicant.conf</filename>
	      állományon keresztül
	      végezzük el:</para>

	    <programlisting>network={
  ssid="freebsdap" <co xml:id="co-tls-ssid"/>
  proto=RSN  <co xml:id="co-tls-proto"/>
  key_mgmt=WPA-EAP <co xml:id="co-tls-kmgmt"/>
  eap=TLS <co xml:id="co-tls-eap"/>
  identity="loader" <co xml:id="co-tls-id"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-tls-cacert"/>
  client_cert="/etc/certs/clientcert.pem" <co xml:id="co-tls-clientcert"/>
  private_key="/etc/certs/clientkey.pem" <co xml:id="co-tls-pkey"/>
  private_key_passwd="freebsdmallclient" <co xml:id="co-tls-pwd"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-tls-ssid">
		<para>Ez a mezõ adja meg a hálózat
		  nevét (SSID).</para>
	      </callout>

	      <callout arearefs="co-tls-proto">
		<para>Itt az RSN (&ieee; 802.11i), vagyis a WPA2
		  protokollt használjuk.</para>
	      </callout>

	      <callout arearefs="co-tls-kmgmt">
		<para>A <literal>key_mgmt</literal> sor a
		  kulcskezelési protokollt adja meg.  A mi
		  esetünkben ez a WPA lesz, EAP
		  hitelesítéssel:
		  <literal>WPA-EAP</literal>.</para>
	      </callout>

	      <callout arearefs="co-tls-eap">
		<para>Ebben a mezõben az EAP módszert
		  nevezzük meg a kapcsolathoz.</para>
	      </callout>

	      <callout arearefs="co-tls-id">
		<para>Az <literal>identity</literal> mezõ az EAP
		  esetén használt azonosítót
		  tartalmazza.</para>
	      </callout>

	      <callout arearefs="co-tls-cacert">
		<para>A <literal>ca_cert</literal> mezõ a
		  hitelesítõ hatóság
		  tanúsítványát
		  tároló állomány
		  elérési útvonalát adja
		  meg.  Ezt a szerver
		  tanúsítványának
		  hitelesítéséhez
		  használjuk.</para>
	      </callout>

	      <callout arearefs="co-tls-clientcert">
		<para>A <literal>client_cert</literal> sor a kliens
		  tanúsítványát
		  tartalmazó állomány
		  elérési útvonalát adja
		  meg.  Ennek a vezeték nélküli
		  hálózat minden egyes kliense
		  esetében egyedinek kell lennie.</para>
	      </callout>

	      <callout arearefs="co-tls-pkey">
		<para>A <literal>private_key</literal> mezõ a
		  kliens tanúsítvánáynak
		  privát kulcsát tároló
		  állomány elérési
		  útját adja meg.</para>
	      </callout>

	      <callout arearefs="co-tls-pwd">
		<para>A <literal>private_key_passwd</literal> mezõ
		  a privát kulcshoz tartozó jelmondatot
		  rögzíti.</para>
	      </callout>
	    </calloutlist>

	    <para>Az <filename>/etc/rc.conf</filename>
	      állományba vegyük fel a
	      következõ sorokat:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>A következõ lépés a
	      felület felébresztése lesz az
	      <filename>rc.d</filename> eszköz
	      segítségével:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Természetesen, ahogy azt már az
	      elõbbiekben is megmutattuk, mindezt manuálisan
	      is el tudjuk végezni a
	      <command>wpa_supplicant</command> és az
	      <command>ifconfig</command> parancsok
	      segítségével.</para>

	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-ttls">
	    <title>WPA és EAP-TTLS</title>

	    <para>Az EAP-TLS használatakor mind a
	      hitelesítést végzõ szervernek
	      és kliensnek is kell
	      tanúsítvány, azonban az EAP-TTLS (
	      szállítási rétegbeli
	      védelem EAP tunnelen keresztül)
	      esetében a kliensnél ez elhagyható.
	      Ez a módszer nagyjából olyan, mint
	      amit a webes oldalak csinálnak, ahol a webszerverek
	      egy védett SSL tunnelt képeznek még
	      akkor is, amikor a látogatók nem
	      rendelkeznek kliens oldali
	      tanúsítvánnyal.  Az EAP-TTLS egy
	      titkosított TLS tunnelen keresztül védi
	      le a hitelesítési adatok
	      forgalmát.</para>

	    <para>Ezt ismét az
	      <filename>/etc/wpa_supplicant.conf</filename>
	      állományon keresztül tudjuk
	      beállítani:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <co xml:id="co-ttls-eap"/>
  identity="test" <co xml:id="co-ttls-id"/>
  password="test" <co xml:id="co-ttls-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-ttls-cacert"/>
  phase2="auth=MD5" <co xml:id="co-ttls-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-ttls-eap">
		<para>Ebben a mezõben az EAP módszert
		  állítjuk be a kapcsolathoz.</para>
	      </callout>

	      <callout arearefs="co-ttls-id">
		<para>Az <literal>identity</literal> mezõ a
		  titkosított TLS tunnelen keresztül az EAP
		  hitelesítésnél felhasznált
		  azonosítót adja meg.</para>
	      </callout>

	      <callout arearefs="co-ttls-passwd">
		<para>A <literal>password</literal> tartalmazza az EAP
		  hitelesítésnél használt
		  jelmondatot.</para>
	      </callout>

	      <callout arearefs="co-ttls-cacert">
		<para>A <literal>ca_cert</literal> mezõ hivatkozik
		  a hitelesítõ hatóság
		  tanúsítványát
		  tartalmazó állományra.  Ez az
		  állomány kell a szerver
		  tanúsítványának
		  ellenõrzéséhez.</para>
	      </callout>

	      <callout arearefs="co-ttls-pha2">
		<para>Ebben a mezõben a titkosított TLS
		  tunnelben használt hitelesítési
		  módszer nevezzük meg.  Jelen
		  esetünkben ez az EAP MD5-Challenge
		  használatával.  A <quote>belsõ
		  hitelesítés</quote>
		  fázisát gyakran csak
		  <quote>phase2</quote>-nak (2.  fázisnak)
		  hívják.</para>
	      </callout>
	    </calloutlist>

	    <para>Mindezek mellett még a következõ
	      sorokat is vegyük fel az
	      <filename>/etc/rc.conf</filename>
	      állományba:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Ezután hozzuk mûködésbe a
	      felületet:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-peap">
	    <title>WPA és EAP-PEAP</title>

	    <para>A PEAP (Védett EAP) az EAP-TTLS egyik
	      alternatívájaként jött
	      létre.  A PEAP módszernek két
	      változata van, melyek közül a
	      leggyakoribb a PEAPv0/EAP-MSCHAPv2.  A
	      leírás további részében
	      a PEAP elnevezéssel erre az EAP módszerre
	      fogunk hivatkozni.  A PEAP az EAP-TLS után a
	      leginkább alkalmazott szabvány, más
	      szóval, ha a hálózatunkban
	      többféle operációs rendszer is
	      megtalálható, akkor az EAP-TLS után
	      valószínûleg a PEAP lesz a
	      másik, amit mindegyik ismerni fog.</para>

	    <para>A PEAP hasonló az EAP-TTLS-hez: szerver oldali
	      tanúsítványokkal hitelesíti a
	      klienseket és titkosított TLS tunnelt hoz
	      létre a kliens és a
	      hitelesítést végzõ szerver
	      között, amivel segíti megóvni a
	      hitelesítési információkat.
	      Biztonság szempontjából az EAP-TTLS
	      és a PEAP között az a
	      különbség, hogy a PEAP
	      hitelesítés a felhasználói
	      nevet titkosítatlanul küldi és csak a
	      jelszó megy át a titkosított TLS
	      tunnelen.  Az EAP-TTLS egyaránt a TLS tunnelt
	      használja mind a felhasználói
	      név, mind a jelszó esetében.</para>

	    <para>Az EAP-PEAP beállításait az
	      <filename>/etc/wpa_supplicant.conf</filename>
	      állományba kell felvenni:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <co xml:id="co-peap-eap"/>
  identity="test" <co xml:id="co-peap-id"/>
  password="test" <co xml:id="co-peap-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-peap-cacert"/>
  phase1="peaplabel=0" <co xml:id="co-peap-pha1"/>
  phase2="auth=MSCHAPV2" <co xml:id="co-peap-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-peap-eap">
		<para>Ebben a mezõben megadjuk, az EAP
		  módszert használjuk a
		  kapcsolathoz.</para>
	      </callout>

	      <callout arearefs="co-peap-id">
		<para>Az <literal>identity</literal> mezõ az EAP
		  hitelesítés során a
		  titkosított TLS tunnelben
		  átküldött azonosítót
		  tartalmazza.</para>
	      </callout>

	      <callout arearefs="co-peap-passwd">
		<para>A <literal>password</literal> mezõ az EAP
		  hitelesítés során használt
		  jelmondatot definiálja.</para>
	      </callout>

	      <callout arearefs="co-peap-cacert">
		<para>A <literal>ca_cert</literal> mezõ a
		  hitelesítõ hatóság
		  tanúsítványát
		  tartalmazó állomány
		  elérési útját adja meg.
		  Ez az állomány kell a szerver
		  tanúsítványának
		  ellenõrzéséhez.</para>
	      </callout>

	      <callout arearefs="co-peap-pha1">
		<para>Ez a mezõ a hitelesítés
		  elsõ fázisának (vagyis a TLS
		  tunnel) paramétereit tartalmazza.  A
		  hitelesítést végzõ
		  szervertõl függõen a
		  hitelesítéshez meg kell adnunk bizonyos
		  címkéket.  A legtöbb esetben a
		  címke a <quote>kliens oldali EAP
		  titkosítás</quote> lesz, amit a
		  <literal>peaplabel=0</literal>
		  használatával állítunk be.
		  A részleteket a &man.wpa.supplicant.conf.5; man
		  oldalon olvashatjuk.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>Ebben a mezõben a titkosított TLS
		  tunnelben alkalmazott hitelesítést
		  protokollt nevezzük meg.  A PEAP esetében
		  ez az <literal>auth=MSCHAPV2</literal> lesz.</para>
	      </callout>
	    </calloutlist>

	    <para>A következõket kell még
	      hozzátennünk az
	      <filename>/etc/rc.conf</filename>
	      állományhoz:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Ezután már mûködésbe is
	      hozhatjuk a felületet:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wep">
	  <title>WEP</title>

	  <para>A WEP (Wired Equivalent Privacy, azaz kábellel
	    egyenértékû titkosság) az eredeti
	    802.11 szabvány része.  Nincs külön
	    hitelesítési mechanizmusa, csupán a
	    hozzáférés-vezérlés egy
	    gyenge formájával találkozhatunk benne,
	    amit azonban könnyen fel lehet törni.</para>

	  <para>A WEP <command>ifconfig</command> parancs
	    használatán keresztül
	    állítható be:</para>

	  <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \
	  ssid saját_hálózat wepmode on weptxkey 3 wepkey 3:0x3456789012</userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para>A <literal>weptxkey</literal> utal arra, hogy a
		küldés során WEP kulcsot
		használunk.  Itt most egy harmadik kulcsot
		használtunk, amelynek egyeznie kell a
		hozzáférési pont
		beállításaival.  Ha nem tudjuk
		pontosan, hogy milyen kulcsot használ a
		hozzáférési pont, akkor
		próbálkozzunk az <literal>1</literal>
		érték (vagyis az elsõ kulcs)
		megadásával.</para>
	    </listitem>

	    <listitem>
	      <para>A <literal>wepkey</literal> után
		következik a kiválasztott WEP kulcs.
		<replaceable>index:kulcs</replaceable> alakban kell
		megadni, és ha itt nem adunk meg indexet, akkor
		azzal az <literal>1</literal> indexû kulcsot
		állítjuk be.  Úgyis
		fogalmazhatnánk, hogy az indexet csak olyankor
		kell megadni, amikor nem az elsõ kulcsot akarjuk
		használni.</para>

	      <note>
		<para>A <literal>0x3456789012</literal>
		  értéket a
		  hozzáférési pontnál
		  beállított kulcsra kell
		  beállítani.</para>
	      </note>
	    </listitem>
	  </itemizedlist>

	  <para>Ha érdekelnek minket a további
	    részletek, akkor bátran lapozzuk fel az
	    &man.ifconfig.8; parancs man oldalát.</para>

	  <para>A <command>wpa_supplicant</command>
	    segédprogramot is bevonhatjuk a vezeték
	    nélküli felületek WEP alapú
	    használatába.  A fenti példát a
	    következõ módon tudjuk leírni az
	    <filename>/etc/wpa_supplicant.conf</filename>
	    állományban:</para>

	  <programlisting>network={
  ssid="sajat_halozat"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</programlisting>

	  <para>Majd:</para>

	  <screen>&prompt.root; <userinput>wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76</screen>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Az ad-hoc mûködési mód</title>

      <para>Az IBSS vagy más néven ad-hoc módot
	pont-pont típusú kapcsolatok
	kialakítására tervezték.
	Például, ha az <systemitem>A</systemitem> és a
	<systemitem>B</systemitem> gépek között egy ad-hoc
	típusú hálózatot akarunk
	létesíteni, akkor egyszerûen csak ki kell
	választanunk két IP-címet és egy
	SSID-t.</para>

      <para>Így állítjuk be az <systemitem>A</systemitem>
	gépet:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 (2417 MHz) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</screen>

      <para>Az <literal>adhoc</literal> paraméterrel utalunk
	arra, hogy a felület most IBSS módban
	mûködik.</para>

      <para>A <systemitem>B</systemitem> gépen ezután már
	képesek vagyunk észlelni az <systemitem>A</systemitem>
	gépet:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode adhoc</userinput>
  SSID/MESH ID    BSSID              CHAN RATE  S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</screen>

      <para>A kimenetben szereplõ <literal>I</literal> is
	megerõsíti, hogy az <systemitem>A</systemitem> gépet
	ad-hoc módban érjük el.  Így
	már csak a <systemitem>B</systemitem> gépet kell
	beállítanunk egy másik
	IP-címmel:</para>

      <screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</screen>

	  <para>Most már mind az <systemitem>A</systemitem> és
	    mind a <systemitem>B</systemitem> készen áll az adatok
	    cseréjére.</para>
    </sect2>

    <sect2 xml:id="network-wireless-ap">
      <title>&os; alapú hozzáférési
	pontok</title>

      <para>A &os; képes hozzáférési
	pontként (Access Point, AP) is üzemelni, így
	nem kell külön hardveres
	hozzáférési pontot
	vásárolnunk vagy ad-hoc hálózatot
	használnunk.  Ez különösen akkor hasznos,
	amikor a &os; gépet egy másik
	hálózat (például az internet)
	felé állítottuk be
	átjárónak.</para>

      <sect3 xml:id="network-wireless-ap-basic">
	<title>Alapvetõ beállítások</title>

	<para>Mielõtt nekiállnánk a &os;-s
	  gépünket hozzáférési pontnak
	  beállítani, egy olyan rendszermagra lesz
	  szükségünk, amely tartalmazza a
	  megfelelõ vezeték nélküli
	  támogatást a kártyánkhoz.
	  Emellett az alkalmazni kívánt biztonsági
	  protokollok támogatását is bele kell
	  építenünk.  Ennek részleteit
	  lásd a <xref linkend="network-wireless-basic"/>ban.</para>

	<note>
	  <para>Jelenleg az NDIS meghajtón keresztül
	    használt &windows;-os meghajtók nem teszik
	    lehetõvé hozzáférési pontok
	    kialakítását.  Egyedül a
	    vezeték nélküli eszközök
	    natív &os;-s meghajtói ismerik a
	    hozzáférési pont módot.</para>
	</note>

	<para>Ahogy betöltöttük a vezeték
	  nélküli hálózatok
	  támogatását, egybõl ellenõrizni
	  is tudjuk, hogy a vezeték nélküli
	  eszközünk használható-e
	  hozzáférési pontként (avagy
	  <quote>hostap</quote> módban):</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
&prompt.root; <userinput>ifconfig wlan0 list caps</userinput>
drivercaps=6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRA&gt;
crytocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</screen>

	<para>A fenti kimenetben láthatjuk a
	  kártyánk tulajdonságait.  A
	  <literal>HOSTAP</literal> szó arról
	  tanúskodik, hogy a vezeték nélküli
	  kártyánk képes
	  hozzáférési pontként viselkedni.
	  Mellette még a különféle
	  támogatott titkosítási módszerek
	  is láthatóak: WEP, TKIP, AES stb.  Ezekbõl
	  az információkból tudjuk
	  kideríteni, hogy a hozzáférési
	  pontunkon milyen titkosítási protokollokat
	  tudunk használni.</para>

	<para>A vezeték nélküli eszközünket
	  innentõl már csak hozzáférési
	  pontnak állíthatjuk át a viruális
	  hálózati eszköz
	  létrehozásakor, ezért a korábban
	  létrehozott eszközt ehhez elõször meg
	  kell semmisítenünk:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 destroy</userinput></screen>

	<para>Ezzel létrejön a megfelelõ
	  beállításokkal, majd ezekhez
	  állítjuk még be a többit:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</userinput></screen>

	<para>Az <command>ifconfig</command> parancs ismételt
	  használatával le is tudjuk kérdezni az
	  <filename>wlan0</filename> felület
	  állapotát:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 (2412 Mhz) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>A <literal>hostap</literal> paraméterbõl
	  kiderül, hogy a felület
	  hozzáférési pont módban
	  van.</para>

	<para>Ha az <filename>/etc/rc.conf</filename>
	  állományban megadjuk a következõ
	  sorokat, akkor a felület beállítása
	  a rendszer indításakor magától
	  megtörténik:</para>

	<programlisting>wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel <replaceable>1</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>Hitelesítés vagy titkosítás
	  nélküli hozzáférési
	  pontok</title>

	<para>Habár a hozzáférési pontok
	  mûködtetése nem javasolt
	  hitelesítés vagy titkosítás
	  nélkül, ebben a módban könnyen meg
	  tudunk gyõzõdni a hozzáférési
	  pontunk használhatóságáról.
	  Ez a típusú konfiguráció
	  ezenkívül még fontos szerepet
	  játszik a klienseken felbukkanó hibák
	  kiszûrésében is.</para>

	<para>Miután sikerült az elõbbiekben
	  bemutatottak alapján beállítani a
	  hozzáférési pontunkat, egy másik
	  vezeték nélküli géprõl
	  rögtön meg is kezdhetjük a
	  keresését:</para>

	<screen>&prompt.root; <userinput>ifconfig ath0 up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</screen>

	<para>Láthatjuk, hogy a kliens megtalálta a
	  hozzáférési pontot és tudunk is
	  rá kapcsolódni:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</userinput>
&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</screen>
      </sect3>

      <sect3>
	<title>WPA titkosítást használó
	  hozzáférési pontok</title>

	<para>Ebben a szakaszban a &os;-s
	  hozzáférési pontunkat WPA
	  titkosítással állítjuk be.  A WPA
	  és a WPA alapú kliensek
	  beállításának részleteit a
	  <xref linkend="network-wireless-wpa"/>ban
	  találjuk.</para>

	<para>A WPA titkosítást használó
	  hozzáférési pontokon a
	  <application>hostapd</application> démon foglalkozik a
	  kliensek hitelesítésével és a
	  kulcsok kezelésével.</para>

	<para>A továbbiakban az összes
	  beállítást egy olyan &os;-s gépen
	  végezzük el, amely
	  hozzáférési pontként
	  mûködik.  Ahogy sikerült
	  beállítanunk a hozzáférési
	  pont módot, az <filename>/etc/rc.conf</filename>
	  állományban a következõ sor
	  segítségével könnyen meg tudjuk
	  oldani, hogy az <application>hostapd</application>
	  démon a rendszerrel együtt magától
	  elinduljon:</para>

	<programlisting>hostapd_enable="YES"</programlisting>

	<para>Mielõtt megpróbálnánk
	  beállítani a <application>hostapd</application>
	  démont, ne felejtsük el elvégezni a <xref linkend="network-wireless-ap-basic"/>ban említett
	  alapvetõ beállításokat sem.</para>

	<sect4>
	  <title>WPA-PSK</title>

	  <para>A WPA-PSK használatát olyan kis
	    méretû hálózatok
	    számára szánják, ahol egy
	    külön hitelesítõ szervert
	    alkalmazása nem lehetséges vagy nem
	    kívánatos.</para>

	  <para>A konfiguráció az
	    <filename>/etc/hostapd.conf</filename>
	    állományon keresztül
	    történik:</para>

	  <programlisting>interface=wlan0 <co xml:id="co-ap-wpapsk-iface"/>
debug=1 <co xml:id="co-ap-wpapsk-dbug"/>
ctrl_interface=/var/run/hostapd <co xml:id="co-ap-wpapsk-ciface"/>
ctrl_interface_group=wheel <co xml:id="co-ap-wpapsk-cifacegrp"/>
ssid=freebsdap <co xml:id="co-ap-wpapsk-ssid"/>
wpa=1 <co xml:id="co-ap-wpapsk-wpa"/>
wpa_passphrase=freebsdmall <co xml:id="co-ap-wpapsk-pass"/>
wpa_key_mgmt=WPA-PSK <co xml:id="co-ap-wpapsk-kmgmt"/>
wpa_pairwise=CCMP TKIP <co xml:id="co-ap-wpapsk-pwise"/></programlisting>

	  <calloutlist>
	    <callout arearefs="co-ap-wpapsk-iface">
	      <para>Ebben a mezõben jelöljük ki a
		hozzáférési pontként
		használt vezeték nélküli
		felületet.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-dbug">
	      <para>Ebben a mezõben adjuk meg a
		<application>hostapd</application> futtatása
		során keletkezõ üzenetek
		részletességét.  A
		példában szereplõ
		<literal>1</literal> érték ennek a
		legkisebb szintjét jelöli.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ciface">
	      <para>A <literal>ctrl_interface</literal> mezõ
		megadja a <application>hostapd</application>
		által használt könyvtár
		elérési útvonalát, amiben
		azokat a tartományokhoz tartozó socketeket
		tároljuk, amelyeken keresztül olyan
		programokkal tudunk kommunikálni, mint
		például a &man.hostapd.cli.8;.  Itt az
		alapértelmezett értéket
		írtuk be.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-cifacegrp">
	      <para>A <literal>ctrl_interface_group</literal> sor
		beállítja azt a csoportot (ez jelen
		esetben a <systemitem class="groupname">wheel</systemitem>), amin
		keresztül a vezérlõfelület
		(control interface) állományaihoz
		hozzá tudunk férni.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ssid">
	      <para>Ebben a mezõben a hálózat
		nevét állítjuk be.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-wpa">
	      <para>A <literal>wpa</literal> mezõvel
		engedélyezzük a WPA
		használatát és megadjuk, hogy
		melyik WPA hitelesítési protokollt
		alkalmazzuk.  Az itt szereplõ <literal>1</literal>
		érték a WPA-PSK hitelesítés
		állítja be a
		hozzáférési pont
		számára.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pass">
	      <para>A <literal>wpa_passphrase</literal> mezõ a WPA
		hitelesítéshez szükséges ASCII
		jelmondatot tartalmazza.</para>

	      <warning>
		<para>Lehetõleg mindig erõs jelszavakat
		  használjunk, amelyek kellõen
		  hosszúak és sokféle karaktert
		  tartalmaznak, így nehezebben fejthetõek
		  meg vagy törhetõek fel.</para>
	      </warning>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-kmgmt">
	      <para>A <literal>wpa_key_mgmt</literal> sor a kulcsok
		kezelésére használt protokollt
		definiálja.  Ez a mi esetünk most a
		WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pwise">
	      <para>A <literal>wpa_pairwise</literal> mezõ a
		hozzáférési pont által
		elfogadott titkosítási algoritmusokat
		határozza meg.  A példában a TKIP
		(WPA) és CCMP (WPA2) titkosítást is
		támogatjuk.  A CCMP titkosítás a
		TKIP egyik alternatívája, és
		lehetõség szerint használjuk ezt.  A
		TKIP csak olyan állomások esetében
		javasolt, amelyek nem támogatják a CCMP
		használatát.</para>
	    </callout>
	  </calloutlist>

	  <para>A következõ lépés a
	    <application>hostapd</application>
	    elindítása:</para>

	  <screen>&prompt.root; <userinput>/etc/rc.d/hostapd forcestart</userinput></screen>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2290
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: associated
	  ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
	  authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100</screen>

	<para>A hozzáférési pont mostantól
	  mûködik, innentõl a kliensek már
	  képesek csatlakozni hozzá, bõvebben
	  lásd a <xref linkend="network-wireless-wpa"/>ban.  A
	  hozzáférési ponthoz tartozó
	  állomásokat az <command>ifconfig
	  wlan0 list sta</command> paranccsal
	  tudjuk listázni.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>WEP titkosítást használó
	  hozzáférési pontok</title>

	<para>A WEP titkosítást nem javasoljuk a
	  hozzáférési pontok esetében, mivel
	  nem tartalmaz semmilyen hitelesítési
	  mechanizmust és könnyen feltörhetõ.
	  Egyes régebbi vezeték nélküli
	  kártyák azonban csak a WEP által
	  nyújtott védelmet ismerik, ezért az
	  ilyenek csak olyan hozzáférési pontokhoz
	  tudnak csatlakozni, amelyek vagy nem használnank
	  hitelesítést és
	  titkosítást, vagy erre a WEP protokollt
	  használják.</para>

	<para>A vezeték nélküli eszközt
	  tegyük hozzáférési pont módba
	  és állítsuk be neki a megfelelõ
	  SSID-t és IP-címet:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0 wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</userinput></screen>

	<itemizedlist>
	  <listitem>
	    <para>A <literal>weptxkey</literal>
	      beállítás után adjuk meg a
	      küldéshez használt WEP kulcsot.  Itt a
	      harmadik kulcsot adtuk meg (vegyük észre, hogy
	      a kulcsok számozása az <literal>1</literal>
	      értékkel kezdõdik).  Ez a
	      paramétert az adatok tényleges
	      titkosításához kell megadni.</para>
	  </listitem>

	  <listitem>
	    <para>A <literal>wepkey</literal> a kiválasztott WEP
	      kulcs beállítását jelöli,
	      aminek a formátuma
	      <replaceable>index:kulcs</replaceable>.  Ha itt nem adunk
	      meg indexet, akkor automatikusan az elsõ kulcsot
	      állítjuk be.  Ezért talán
	      mondanunk sem kell, hogy az indexet csak akkor kell
	      megadni, ha nem az elsõ kulcsot akarjuk
	      használni.</para>
	  </listitem>
	</itemizedlist>

	<para>A <filename>wlan0</filename> felület
	  állapotának megtekintéséhez adjuk
	  ki megint az <command>ifconfig</command> parancsot:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0</userinput>
  ath0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 (2427 Mhz) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>Egy másik vezeték nélküli
	  géprõl most már
	  megpróbálhatjuk megkeresni a
	  hozzáférési pontot:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev ath0</userinput>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</screen>

	<para>Láthatjuk, hogy a kliens megtalálta a
	  hozzáférési pontot, és a
	  megfelelõ paraméterekkel (kulcs stb.) képes
	  kapcsolódni hozzá a <xref linkend="network-wireless-wep"/>ban leírtak
	  szerint.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>A vezetékes és vezeték
	nélküli hálózatok együttes
	használata</title>

      <para>A vezetékes hálózatok
	általában jobb teljesítményt
	nyújtanak és megbízhatóbbak,
	miközben a vezeték nélküli
	hálózatok pedig nagyobb rugalmasságot
	és mozgásteret szolgáltatnak.  Ezért
	a hordozható számítógépek
	tulajdonosaiban felmerülhet az igény, hogy egyszerre
	mind a kettõt használva, tetszõlegesen
	és problémamentesen válthassanak a
	hálózatok között.</para>

      <para>&os; rendszereken ún.
	<quote>hibatûrõ</quote> módon két vagy
	akár több hálózati interfészt
	össze tudunk vonni.  Ennek köszönhetõen az
	aktív hálózati kapcsolat
	megszünésekor rendszerünk
	önállóan igyekszik mindig a fennmaradó
	elérhetõ hálózatok közül a
	leginkább preferáltabbra váltani.</para>

      <para>A hálózati összeköttetések
	összefûzésével és a
	hibatûrés konkrét
	megvalósításával az <xref linkend="network-aggregation"/>ban foglalkozunk, ahol a <xref linkend="networking-lagg-wired-and-wireless"/>ban
	láthatjuk is a vezetékes és vezeték
	nélküli kapcsolatok együttes
	használatának
	beállítását.</para>
    </sect2>

    <sect2>
      <title>Hibaelhárítás</title>

      <para>Ha valamilyen gondunk lenne a vezeték
	nélküli hálózatok
	használatával, akad néhány
	lépés, amivel esetleg fel tudjuk deríteni a
	hiba okát.</para>

      <itemizedlist>
	<listitem>
	  <para>Ha nem látjuk a hozzáférési
	    pontot a pásztázás után,
	    ellenõrizzük, hogy a vezeték
	    nélküli eszközt véletlenül nem
	    korlátoztuk-e le bizonyos csatornákra.</para>
	</listitem>

	<listitem>
	  <para>Ha nem tudunk csatlakozni a
	    hozzáférési ponthoz, akkor
	    egyeztessük vele az állomás egyes
	    paramétereit, beleértve a
	    hitelesítési sémát és a
	    biztonsági protokollokat.  Minél jobban
	    egyszerûsítsük le a
	    konfigurációkat.  Ha WPA vagy WEP
	    titkosítást használunk, akkor a
	    hozzáférési ponton
	    állítsunk be nyílt
	    hitelesítést és kapcsoljuk ki a
	    titkosítást, majd nézzük meg, hogy
	    így eljut-e hozzánk valamilyen
	    forgalom.</para>
	</listitem>

	<listitem>
	  <para>Ahogy sikerült csatlakozunk a
	    hozzáférési ponthoz, a
	    biztonsági beállításokat olyan
	    egyszerû eszközökkel próbáljuk
	    meg diagnosztizálni, mint például a
	    &man.ping.8;.</para>

	  <para>A <command>wpa_supplicant</command>
	    segédprogrammal tudunk nyomkövetést
	    végezni.  A <option>-dd</option> opció
	    megadásával indítsuk el
	    manuálisan és ellenõrizzük a
	    rendszernaplókat.</para>
	</listitem>

	<listitem>
	  <para>Vannak alacsonyabb szintû nyomkövetési
	    lehetõségek is.  A 802.11 protokollt
	    támogató rétegben is tudunk
	    engedélyezni nyomkövetési üzeneteket
	    a <filename>/usr/src/tools/tools/net80211</filename>
	    könyvtárban található
	    <command>wlandebug</command> program
	    segítségével.  Például
	    a</para>

	  <screen>&prompt.root; <userinput>wlandebug -i ath0 +scan+auth+debug+assoc</userinput>
  net.wlan.0.debug: 0 =&gt; 0xc80000&lt;assoc,auth,scan&gt;</screen>

	  <para>paranccsal a hozzáférési pontok
	    kereséséhez és a 802.11 protokollon
	    belül a kapcsolat megszervezéséhez
	    szükséges kézfogásokhoz
	    kapcsolódó konzolüzeneteket tudjuk
	    engedélyezni.</para>

	  <para>A 802.11 rétegben rengeteg hasznos
	    statisztikát találhatunk.  Mindezeket a
	    <command>wlanstats</command> eszközzel tudjuk
	    kiíratni.  Ezeknek a statisztikáknak a 802.11
	    réteg összes hibáját be kell
	    tudniuk azonosítaniuk.  Vigyázzunk azonban,
	    mert az eszközmeghajtókban a 802.11 réteg
	    alatt rejlõ bizonyos hibák ilyenkor nem jelennek
	    meg.  Az eszközfüggõ problémák
	    felderítésével kapcsolatban a
	    megfelelõ meghajtó
	    dokumentációját olvassuk
	    át.</para>
	</listitem>

      </itemizedlist>

      <para>Amennyiben a fenti tanácsok mentén sem
	sikerül orvosolnunk a hibát okát,
	küldjünk egy hibajelentést és
	mellékeljük hozzá a fentebb tárgyalt
	eszközök által gyártott
	kimeneteket.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="network-bluetooth">
    <info><title>Bluetooth</title>
      <authorgroup>
	<author><personname><firstname>Pav</firstname><surname>Lucistnik</surname></personname><contrib>Írta: </contrib><affiliation>
	    <address><email>pav@FreeBSD.org</email></address>
	  </affiliation></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>Bluetooth</primary></indexterm>

    <sect2>
      <title>Bevezetés</title>

      <para>A Bluetooth egy olyan vezeték nélküli
	technológia, amellyel a 2,4&nbsp;GHz-es
	frekvenciatartományban tudunk személyi
	hálózatokat létrehozni 10 méteren
	belül.  Az ilyen típusú
	hálózatok általában alkalmi
	jelleggel keletkeznek különféle
	hordozható eszközök, mint például
	mobiltelefonok, kézi
	számítógépek és laptopok
	között.  Eltérõen más
	népszerû vezeték nélküli
	technológiáktól, például a
	wi-fitõl, a Bluetooth magasabb szintû
	szolgáltási profilokat is felajánl:
	FTP-szerû állományszervereket, az
	állományok áttolását, hang
	átküldését, soros vonali
	emulációt és még sok minden
	mást.</para>

      <para>A &os;-ben megvalósított Bluetooth
	protokollkészlet a Netgraph rendszerre
	építkezik (lásd &man.netgraph.4;).  A
	Bluetooth alapú USB-s hardverzárak széles
	körét támogatja az &man.ng.ubt.4;
	meghajtó.  A Broadcom BCM2033 chipre
	épített Bluetooth eszközöket az
	&man.ubtbcmfw.4; és az &man.ng.ubt.4; meghajtók
	támogatják.  A 3Com Bluetooth PC Card 3CRWB60-A
	eszközt az &man.ng.bt3c.4; meghajtó
	támogatja.  A soros és UART alapú Bluetooth
	eszközöket a &man.sio.4;, &man.ng.h4.4; és
	&man.hcseriald.8; ismeri.  Ebben a szakaszban a Bluetooth
	alapú USB-s hardverzárak használatát
	mutatjuk be.</para>

    </sect2>

    <sect2>
      <title>Az eszköz csatlakoztatása</title>

      <para>Alapértelmezés szerint a Bluetooth
	eszközmeghajtók modulként
	érhetõek el.  Az eszköz csatlakoztatása
	elõtt a megfelelõ meghajtót be kell
	töltenünk a rendszermagba:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Ha a Bluetooth eszköz már a rendszer
	indításakor is jelen van, akkor a modult az
	<filename>/boot/loader.conf</filename> állományon
	keresztül is betölthetjük:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Dugjuk be az USB-s hardverzárunkat.  Az
	alábbihoz hasonló kimenet fog keletkezni a
	konzolon (vagy a rendszernaplóban):</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Az <filename>/etc/rc.d/bluetooth</filename> szkript fogja
	végezni a Bluetooth használatához
	szükséges protokollkészlet
	elindítását és
	leállítását.  Jó ötlet
	leállítani az eszköz
	eltávolítása elõtt, de ha elhagyjuk,
	(általában) nem okoz végzetes hibát.
	Az indításkor a következõ kimenetet
	kapjuk:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>

    </sect2>

    <sect2>
      <title>Host Controller Interface (HCI)</title>

      <indexterm><primary>HCI</primary></indexterm>

      <para>A Host Controller Interface (HCI) egy parancsfelületet
	nyújt a mûködési sáv
	vezérlõjéhez (baseband controller) és
	az összeköttetések kezelõjéhez
	(link manager), valamint hozzáférést a
	hardverállapot és -vezérlõ
	regiszterekhez.  Ez a felület egy egységes
	módszert szolgáltat a Bluetooth
	mûködési sávjához tartozó
	tulajdonságok eléréséhez.  Az
	eszközön üzemelõ HCI réteg a
	Bluetooth hardverben található HCI firmware-rel
	vált adatokat és parancsokat.  A Host Controller
	Transport Layer (vagyis a fizikai busz) meghajtója mind a
	két HCI réteget és a kettejük
	közti információcserét is
	elérhetõvé teszi.</para>

      <para>Az egyes Bluetooth eszközökhöz
	létrejön egy-egy <emphasis>hci</emphasis>
	típusú Netgraph-beli csomópont.  Ez a HCI
	csomópont általában a Bluetooth
	eszközmeghajtó csomópontjához
	(lefelé) és az L2CAP csomóponthoz
	(felfelé) csatlakozik.  Az összes HCI mûveletet
	a HCI csomóponton kell elvégezni és nem az
	eszközmeghajtóhoz tartozón.  A HCI
	csomópont alapértelmezett neve a
	<quote>devicehci</quote>.  Ezekrõl többet az
	&man.ng.hci.4; man oldalán tudhatunk meg.</para>

      <para>Az egyik legáltalánosabb feladat a Bluetooth
	eszközök esetében a közelben levõ
	további eszközök felderítése.
	Ezt a mûveletet
	<emphasis>tudakozódásnak</emphasis>
	(<quote>inquiry</quote>) nevezik.  A tudakozódást
	és az összes többi HCI-hez
	kapcsolódó mûveletet a &man.hccontrol.8;
	segédprogrammal tudjuk elvégezni.  A lentebb
	látható példa azt mutatja meg, hogyan
	tudunk Bluetooth eszközöket keresni egy adott
	távolságon belül.  Az elérhetõ
	eszközök listáját néhány
	másodpercen alatt megkapjuk.  A távoli azonban
	eszközök csak akkor fognak válaszolni, ha
	<emphasis>felderíthetõ</emphasis>
	(<quote>discoverable</quote>) módban vannak.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para>A <literal>BD_ADDR</literal> a Bluetooth eszköz egyedi
	címe, hasonló a hálózati
	kártyák MAC-címéhez.  Erre a
	címre lesz szükség ahhoz, hogy a
	továbbiakban kommunikálni tudjunk az
	eszközzel.  Emberek számára
	értelmezhetõ nevet is hozzá tudunk rendelni a
	BD_ADDR címhez.  Az
	<filename>/etc/bluetooth/hosts</filename> állomány
	tartalmazza a Bluetooth eszközökre vonatkozó
	információkat.  A következõ
	példában azt láthatjuk, hogyan tudunk
	beszédesebb nevet adni egy távoli
	eszköznek:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav T39-ese</screen>

      <para>Amikor tudakozódni kezdünk a távoli
	Bluetooth eszközök jelenléte felõl, a
	gépünket <quote>sajat.gep.nev (ubt0)</quote>
	néven fogják látni.  Ez a helyi
	eszközhöz rendelt név bármikor
	megváltoztatható.</para>

      <para>A Bluetooth rendszer lehetõség ad pont-pont
	(természetesen csak két Bluetooth egység
	között) vagy pont-multipont típusú
	kapcsolatok kiépítésére.  A
	pont-multipont kapcsolat esetén a kapcsolaton több
	Bluetooth eszköz osztozik.  A most következõ
	példában megláthatjuk, hogyan kell az
	aktív mûködési sávban
	lekérdezni a helyi eszköz létrejött
	kapcsolatait:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>A <emphasis>kapcsolat azonosítója</emphasis>
	(connection handle) akkor hasznos, amikor egy sávbeli
	kapcsolatot akarunk lezárni.  Ezt általában
	nem kell kézzel megcsinálni.  A rendszer
	magától lezárja az inaktív
	sávbeli kapcsolatokat.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>A <command>hccontrol help</command> paranccsal tudjuk
	lekérdezni az elérhetõ HCI parancsokat.  A
	legtöbb HCI parancs végrehajtásához
	nem kellenek rendszeradminisztrátori
	jogosultságok.</para>

    </sect2>

    <sect2>
      <title>Logical Link Control and Adaptation Protocol
	(L2CAP)</title>

      <indexterm><primary>L2CAP</primary></indexterm>

      <para>A Logical Link Control and Adaptation Protocol (L2CAP) a
	kapcsolat-orientált és a kapcsolat
	nélküli adatszolgáltatásokért
	felelõs a felsõbb rétegek felé, valamit
	támogatja a protokollok
	többszörözését, a darabolást
	és az összerakást.  Az L2CAP a magasabb
	szintû protokollok és az alkalmazások
	számára egészen 64&nbsp;kilobyte
	méretig lehetõvé teszi az adatcsomagok
	küldését és
	fogadását.</para>

      <para>A L2CAP a <emphasis>csatorna</emphasis> (channel)
	fogalmára építkezik.  A csatorna egy
	logikai kapcsolatot képvisel a mûködési
	sávon belüli kapcsolat felett.  Mindegyik
	csatornához egyetlen protokoll kötõdik, egy a
	többhöz alapon.  Több csatorna is tarthozhat
	ugyanahhoz a protokollhoz, de egy csatornán nem
	használhatunk több protokollt.  A csatornákon
	keresztül érkezõ L2CAP csomagok ezután a
	megfelelõ felsõbb rétegbeli protokollokhoz
	kerülnek.  Több csatorna osztozhat ugyanazon a
	sávbeli kapcsolaton.</para>

      <para>Minden Bluetooth eszközhöz létrejön
	egy <emphasis>l2cap</emphasis> típusú
	Netgraph-csomópont.  Az L2CAP csomópont
	általában egy Bluetooth HCI csomóponthoz
	(lefelé) és egy Bluetooth sockethez
	(felfelé) kapcsolódik.  Az L2CAP csomópont
	alapértelmezett neve <quote>devicel2cap</quote>.
	Errõl részletesebben az &man.ng.l2cap.4; man oldal
	világosít fel minket.</para>

      <para>Ezen a szinten hasznos parancsnak bizonyulhat az
	&man.l2ping.8;, amivel más eszközöket tudunk
	pingelni.  Elõfordulhat, hogy egyes Bluetooth
	implementációk nem válaszolnak semmilyen
	feléjük küldött adatra, így az
	alábbi példában is szereplõ <literal>0
	bytes</literal> teljesen normális.</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>Az &man.l2control.8; segédprogram
	használható az L2CAP csomópontok
	különbözõ mûveleteinek
	kivitelezésére.  Ebben a példában a
	helyi eszközhöz tartozó logikai kapcsolatokat
	(csatornák) és sávokat
	kérdezzük le:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>Másik ugyanilyen diagnosztikai eszköz a
	&man.btsockstat.1;.  Ha a viselkedését
	tekintjük, akkor leginkább a &man.netstat.1;
	programra hasonlít, de a Bluetooth
	hálózatban megjelenõ adatszerkezetekkel
	dolgozik.  Az alábbi példa az iménti
	&man.l2control.8; parancs kimenetében szereplõ
	logikai kapcsolatokat mutatja:</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <sect2>
      <title>Az RFCOMM protokoll</title>

      <indexterm><primary>RFCOMM</primary></indexterm>

      <para>Az RFCOMM protokoll a soros portok
	emulációját valósítja meg az
	L2CAP protokollon keresztül.  A protokoll az ETSI TS 07.10.
	RFCOMM szabványán alapszik, és egy
	egyszerû átviteli protokoll, amelyet a 9 tûs
	RS-232 (EIATIA-232-E) soros portok
	emulációjára készítettek fel.
	Az RFCOMM protokoll legfeljebb 60 kapcsolat (RFCOMM csatorna)
	párhuzamos használatát támogatja
	két Bluetooth eszköz között.</para>

      <para>Az RFCOMM számára a teljes
	kommunikációs útvonal két
	különbözõ eszközön futó
	alkalmazást (kommunikációs
	végpontot) és köztük levõ
	kommunikációs szegments foglalja magában.
	Az RFCOMM az adott eszközön a soros portot
	használó alkalmazások részére
	készült.  A kommunikációs szegmens az
	egyik eszköztõl a másikig vezetõ Bluetooth
	alapú összeköttetés (közvetlen
	kapcsolat).</para>

      <para>Közvetlen kapcsolat esetén az RFCOMM csak az
	eszközök közti kapcsolattal foglalkozik, valamint
	hálózati kapcsolat esetén az eszköz
	és a modem közti kapcsolattal.  Az RFCOMM más
	konfigurációkat is támogat,
	például olyan modulokat, amelyek az egyik oldalon
	a Bluetooth vezeték nélküli
	technológián keresztül kommunikálnak,
	míg a másik oldalon egy vonalas felületet
	nyújtanak.</para>

      <para>A &os;-ben az RFCOMM protokollt Bluetooth foglalatok
	rétegében valósították
	meg.</para>

    </sect2>

    <sect2>
      <title>Az eszközök
	párosítása</title>

      <indexterm><primary>párosítás</primary></indexterm>

      <para>Alapértelmezés szerint a Bluetooth
	kommunikáció nem hitelesítõdik
	és bármelyik eszköz képes
	bármelyik másikkal felvenni a kapcsolatot.  Egy
	Bluetooth eszköz (például egy mobiltelefon)
	egy adott szolgáltatáshoz igényelhet
	hitelesítést (például
	betárcsázáshoz).  A Bluetooth alapú
	hitelesítés többnyire <emphasis>PIN
	kódokkal</emphasis> történik.  A PIN
	kód egy legfeljebb 16 karakterbõl álló
	ASCII karakterlánc.  A felhasználóknak mind
	a két eszközön ugyanazt a PIN kódot kell
	megadniuk.  Miután megadtuk a PIN kódot, az
	eszközök létrehoznak hozzájuk egy
	<emphasis>összekötettésbeli kulcsot</emphasis>
	(link key).  Ezután ezt a kulcsot vagy az
	eszközökön tároljuk vagy pedig valamilyen
	tartós tárolón.  A következõ
	alkalommal mind a két eszközt ezt a korábban
	elkészített kulcsot fogja használni.  Ezt
	az eljárást nevezik
	<emphasis>párosításnak</emphasis>
	(pairing).  Ha valamelyik eszköz elveszti az
	össszeköttetés kulcsát, akkor a
	párosítást meg kell
	ismételni.</para>

      <para>A &man.hcsecd.8; démon felelõs az összes
	Bluetooth alapú hitelesítési
	kérés lekezeléséért.  Az
	alapértelmezett konfigurációs
	állománya az
	<filename>/etc/bluetooth/hcsecd.conf</filename>.
	Például így tudjuk benne egy
	mobiltelefonhoz megadni az <quote>1234</quote> PIN
	kódot:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav T39-ese";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Semmilyen korlátozás nincs a PIN
	kódokra (a méretüktõl eltekintve).
	Egyes eszközökbe (például a Bluetooth
	fejhallgatók) elõre rögzített PIN
	kódot építettek bele.  A
	<option>-d</option> kapcsoló hatására a
	&man.hcsecd.8; démont az elõtérben lehet
	futtatni, így könnyebben láthatjuk mi
	történik.  A távoli eszközt
	állítsuk be a párosítás
	elfogadására és kezdeményezzünk
	felé egy Bluetooth kapcsolatot.  A távoli
	eszköznek erre azt kell válaszolnia, hogy elfogadta
	a párosítást, majd kérni fogja a PIN
	kódot.  Adjuk meg ugyanazt a PIN kódot, mint amit
	a <filename>hcsecd.conf</filename> állományba is
	beírtunk.  Most már a gépünk és
	a távoli eszköz párban vannak.  A
	párosítást a távoli
	eszközrõl is kezdeményezhetjük.</para>

      <para>A &os;&nbsp;5.5, 6.1 és újabb
	változataiban az <filename>/etc/rc.conf</filename>
	állományba a következõ sort kell
	felvenni a <application>hcsecd</application> automatikus
	indításához:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Ez pedig a <application>hcsecd</application> démon
	által generált kimenetre példa:</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <sect2>
      <title>Service Discovery Protocol (SDP)</title>

      <indexterm><primary>SDP</primary></indexterm>

      <para>A Service Discovery Protocol (SDP)
	segítségével a kliens alkalmazások
	képes felderíteni, hogy a szerver
	alkalmazások részérõl milyen
	szolgáltatások érhetõek el, valamint
	ezek a szolgáltatások milyen
	tulajdonságokkal rendelkeznek.  A
	szolgáltatások tulajdonsági
	közé soroljuk többek között a
	felajánlott szolgáltatás
	típusát vagy osztályát, illetve a
	szolgáltatás kihasználásához
	szükséges mechanizmusra vagy protokollra
	vonatkozó információkat.</para>

      <para>Az SDP az SDP szerver és az SDP kliens közti
	kommunikációt foglalja magában.  A szerver
	karbantart egy listát azokról a
	szolgáltatási rekordokról, amelyek a
	szerverhez tartozó szolgáltatások
	jellemzõit írják le.  Mindegyik ilyen
	szolgáltatási rekord egyetlen
	szolgáltatás adatait tartalmazza.  A kliensek egy
	SDP kéréssel ezeket a szolgáltatási
	rekordokat kérhetik el az SDP szervertõl.
	Amennyiben a kliens, vagy a hozzá tartozó
	alkalmazás a szolgáltatás használata
	mellett dönt, akkor a szolgáltatás
	használatához a megfelelõ
	szolgáltató felé nyitnia kell egy
	külön kapcsolatot.  Az SDP csak a
	szolgáltatások és azok
	tulajdonságainak felderítéséhez ad
	segítséget, de semmilyen eszközt nem
	tartalmaz a felhasználásukra.</para>

      <para>Általában az SDP kliensek
	általában valamilyen számunkra kellõ
	tulajdonság alapján keresnek
	szolgáltatásokat.  Ráadásul
	adódhatnak olyan alkalmak is, amikor a
	szolgáltatások elõzetes ismerete
	nélkül szeretnénk felderíteni a
	rendelkezésre álló
	szolgáltatások típusait.  A
	felajánlott szolgáltatások ilyen
	típusú feldolgozását nevezzük
	<emphasis>böngészésnek</emphasis>
	(browsing).</para>

      <para>Az &man.sdpd.8; Bluetooth SDP szerver és a
	parancssoros &man.sdpcontrol.8; kliens az alap &os;
	telepítés része.  Az alábbi
	példában egy SDP böngészési
	kérést adunk ki:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</screen>

      <para>és így tovább.  Mindegyik
	szolgáltatáshoz hozzátartozik a
	tulajdonságok egy listája (például
	RFCOMM csatorna).  Lehetséges, hogy
	szolgáltatástól függõen bizonyos
	tulajdonságokat kell figyelnünk.  Egyes Bluetooth
	implementációk nem támogatják a
	szolgáltatások
	böngészését és ezért egy
	üres listát adnak vissza.  Ebben az esetben egy
	konkrét szolgáltatásra tudunk
	rákeresni.  A következõ példában
	az OBEX Object Push (OPUSH) szolgáltatást
	keressük:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>&os; alatt az &man.sdpd.8; szerverrel tudunk
	szolgáltatásokat felajánlani a Bluetooth
	klienseknek.  A &os;&nbsp;5.5, 6.1 vagy késõbbi
	változataiban ehhez a következõ sort kell
	megadnunk az <filename>/etc/rc.conf</filename>
	állományban:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Ezután az <application>sdpd</application>
	démon így indítható el:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sdpd start</userinput></screen>

      <para>A távoli kliensek részére Bluetooth
	szolgáltatásokat felajánlani
	kívánó helyi szerver alkalmazásoknak
	regisztrálniuk kell magukat a helyi SDP
	démonnál.  Például az egyik ilyen
	alkalmazás az &man.rfcomm.pppd.8;, és
	elindítása után regisztrálni fogja a
	Bluetooth LAN szolgáltatást a helyi SDP
	démonnál.</para>

      <para>A helyi SDP szerveren regisztrált
	szolgáltatásokat a helyi vezérlési
	csatornán keresztül egy <literal>browse</literal>
	kéréssel tudjuk lekérdezni:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>

    </sect2>

    <sect2>
      <title>A betárcsázós hálózati
	és a PPP hálózati
	hozzáférési (LAN) profilok</title>

      <para>A betárcsázós hálózati
	(Dial-Up Networking, DUN) profil leggyakrabban a modemek
	és mobiltelefonok között tûnik fel.  Ez a
	profil a következõ forgatókönyveket
	dolgozza fel:</para>

      <itemizedlist>
	<listitem>
	  <para>A számítógépünkkel egy
	    mobiltelefont vagy modemet vezeték
	    nélküli modemként használunk,
	    amivel az internethez vagy más
	    hálózatokhoz csatlakozunk
	    betárcsázással.</para>
	</listitem>

	<listitem>
	  <para>A számítógépünkkel egy
	    mobiltelefonon vagy modemen keresztül fogadunk
	    adathívásokat.</para>
	</listitem>
      </itemizedlist>

      <para>A PPP hálózati
	hozzáférési (LAN) profil a
	következõ helyezetekben alkalmazható:</para>

      <itemizedlist>
	<listitem>
	  <para>LAN hozzáférés egyetlen Bluetooth
	    eszközhöz</para>
	</listitem>

	<listitem>
	  <para>LAN hozzáférés több Bluetooth
	    eszközhöz</para>
	</listitem>

	<listitem>
	  <para>Két gép összekötése (a
	    soros vonali kapcsolat emulációval PPP-n
	    keresztül)</para>
	</listitem>
      </itemizedlist>

      <para>&os; alatt mind a két profilt a &man.ppp.8; és
	az &man.rfcomm.pppd.8; valósítja meg &mdash; egy
	olyan wrapper eszköz, amely az RFCOMM Bluetooth
	kapcsolatokat a PPP számára is
	értelmessé alakítja át.
	Mielõtt még bármelyik profilt
	elkezdenénk használni, egy új PPP
	címkét kell létrehozni az
	<filename>/etc/ppp/ppp.conf</filename>
	állományban.  Erre példát az
	&man.rfcomm.pppd.8; man oldalon találhatunk.</para>

      <para>A következõ példában az
	&man.rfcomm.pppd.8; programot fogjuk használni arra, hogy
	egy RFCOMM típusú kapcsolatot nyissunk a
	00:80:37:29:19:a4 címmel rendelkezõ távoli
	Bluetooth eszköz felé.  A tényleges RFCOMM
	csatorna számát SDP-n keresztül a
	távoli eszköztõl kapjuk.  Az RFCOMM csatorna
	kézzel is megadható, és ilyen esetekben az
	&man.rfcomm.pppd.8; nem fog SDP kérést
	küldeni.  A &man.sdpcontrol.8; használatával
	tudjuk lekérdezni a távoli eszközön
	létrejött RFCOMM csatornát.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>A PPP hálózati elérés (LAN)
	szolgáltatás beindításához
	futni kell a &man.sdpd.8; szervernek.  A helyi
	hálózaton keresztül csatlakozó
	kliensekhez létre kell hozni egy új
	bejegyzést az <filename>/etc/ppp/ppp.conf</filename>
	állományban.  Az &man.rfcomm.pppd.8; man oldalon
	találhatunk erre példákat.
	Végezetül indítsuk el az RFCOMM PPP szervert
	egy érvényes RFCOMM csatornaszámmal.  Az
	RFCOMM PPP szerver ekkor automatikusan regisztrálja a
	Bluetooth LAN szolgáltatást a helyi SDP
	démonnál.  A következõ
	példában megmutatjuk, hogyan lehet
	elindítani egy RFCOMM PPP szervert:</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <sect2>
      <title>Az OBEX Object Push (OPUSH) profil</title>

      <indexterm><primary>OBEX</primary></indexterm>

      <para>Az OBEX egy széles körben alkalmazott protokoll
	a mobileszközök közti egyszerû
	állományvitelre.  Legfõképpen az
	infravörös kommunikációban
	alkalmazzák, ahol a laptopok vagy PDA-k közti
	általános állományátvitelre
	használják, illetve
	névjegykártyák vagy
	naptárbejegyzések
	átküldésére mobiltelefonok
	között és egyéb PIM alkalmazást
	futtató eszközök esetében.</para>

      <para>Az OBEX szervert és klienst egy külsõ
	csomag, az <application>obexapp</application>
	valósítja meg, amelyet az <package>comms/obexapp</package> portból
	érhetünk el.</para>

      <para>Az OBEX kliens használható objektumok
	áttolására vagy
	lehúzására az OBEX szerverhez.  Ez az
	objektum lehet például egy
	névjegykártya vagy egy megbeszélt
	találkozó.  Az OBEX kliens SDP-n keresztül
	tud magának RFCOMM csatornaszámot szerezni.  Ezt
	úgy tehetjük meg, ha a szolgáltatás
	neve helyett egy RFCOMM csatorna számát adjuk meg.
	A támogatott szolgáltatások: IrMC, FTRN
	és OPUSH.  Számként RFCOMM csatorna is
	megadható.  Az alábbi példában egy
	OBEX munkamenetet láthatunk, ahol az eszköz
	információs objektumát húzzuk le a
	mobiltelefonról és egy új objektumot (egy
	névjegykártyát) tolunk fel a telefon
	könyvtárába.</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Az OBEX objektumok tologatásának
	támogatásához az &man.sdpd.8; szervernek
	kell futnia.  Továbbá a beérkezõ
	objektumok tárolásához létre kell
	hoznunk még egy könyvtárat is.  Ez az
	könyvtár alapértelmezés szerint a
	<filename>/var/spool/obex</filename>.  Végül
	indítsuk el az OBEX szervert egy érvényes
	RFCOMM csatorna számának
	megadásával.  Az OBEX szerver ezután
	automatikusan regisztrálja az <quote>OBEX Object
	Push</quote> nevû szolgáltatást a helyi SDP
	démonnál.  Ebben a példában
	láthatjuk az OBEX szerver
	indítását:</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>

    </sect2>

    <sect2>
      <title>Soros vonali profil (SPP)</title>

      <para>A soros vonali profil (Serial Port Profile, SPP)
	használatával RS232 (vagy ahhoz hasonló)
	vonali adatátvitelt tudunk emulálni.  Ez a profil
	a régebben fejlesztett alkalmazásokkal
	birkózik meg, és a Bluetooth
	technológiával valódi kábel helyett
	egy virtuális soros portot képez le.</para>

      <para>Az &man.rfcomm.sppd.1; segédprogram ezt a soros
	vonali profilt valósítja meg.  Így egy
	pszeudo terminált tudunk virtuális soros
	portként használni.  Ha nem adunk meg RFCOMM
	csatornát, akkor az &man.rfcomm.sppd.1; képes
	SDP-n keresztül kérni egyet magának a
	távoli eszköztõl.  Ha ezt felül
	kívánjuk bírálni, akkor a
	parancssorban megadhatunk akár egy konkrét RFCOMM
	csatornát is.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Miután csatlakoztunk, a pszeudo terminált
	tudjuk soros portként használni:</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>

    </sect2>

    <sect2>
      <title>Hibaelhárítás</title>

      <sect3>
	<title>Nem tudunk csatlakozni a távoli
	  eszközzel</title>

	<para>Egyes Bluetooth eszközök nem
	  támogatják a szerepek cseréjét
	  (role switch).  Alapértelmezés szerint amikor a
	  &os; elfogad egy új kapcsolatot,
	  megpróbál rajta szerepet cserélni
	  és mesterré válni.  Azok az
	  eszközök, amelyek ezt nem támogatják,
	  nem lesznek képesek emiatt csatlakozni.  Ez a
	  szerepváltás az új kapcsolatok
	  felépítése során zajlik le,
	  ezért egy távoli eszköztõl nem lehet
	  megtudni, hogy ismeri-e ezt a lehetõséget.  A
	  helyi oldalon a következõ HCI opcióval lehet
	  kikapcsolni a szerepcserét:</para>

	<screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
	<title>Valami nem megy.  Lehet látni valahogy, pontosan
	  mi is történik?</title>

	<para>Persze, igen.  Egy külsõ csomag, a
	  <application>hcidump</application>
	  segítségével, amely a <package>comms/hcidump</package> portból
	  érhetõ el.  A <application>hcidump</application>
	  segédprogram a &man.tcpdump.1; programhoz
	  hasonlítható.  Ezzel lehet a Bluetooth csomagok
	  tartalmát megnézni a terminálon vagy
	  elmenteni ezeket egy állományba.</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bridging">
    <info><title>Hálózati hidak</title>
      <authorgroup>
	<author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <sect2>
      <title>Bevezetés</title>

      <indexterm><primary>IP-alhálózat</primary></indexterm>
      <indexterm><primary>hálózati
	híd</primary></indexterm>

      <para>Gyakran hasznos lehet anélkül felosztani egy
	fizikai hálózatot (például egy
	Ethernet szegmenst) két külön
	hálózati szegmensre, hogy külön
	IP-alhálózatot kellene létrehozunk
	és összekötnünk ezeket egy
	útválasztóval.  A két ilyen
	módon kialakított hálózatot
	összekötõ eszközt nevezzük
	<quote>hálózati hídnak</quote> (bridge).  A
	legalább két hálózati
	felülettel rendelkezõ &os; rendszerek képesek
	hálózati híd szerepét
	betölteni.</para>

      <para>A hálózati híd az eszközök
	adatkapcsolati rétegben a hozzá tartozó
	felületein megjelenõ (vagyis Ethernet)
	címének megtanulásával
	mûködik.  A két hálózat
	között csak akkor közvetít forgalmat,
	amikor a forrás és cél nem ugyanabban a
	hálózatban található.</para>

      <para>A hálózati hidak bizonyos szempontból
	lényegében nagyon kevés porttal
	rendelkezõ Ethernet switch-ek.</para>

    </sect2>

    <sect2>
      <title>A hálózati hidak tipikus
	alkalmazásai</title>

      <para>Napjainkban akad néhány igen jellemzõ
	szituáció, ahol szükség van a
	hálózati hidak alkalmazására.</para>

      <sect3>
	<title>Hálózatok
	  összekötése</title>

	<para>A hálózati hidak alapvetõ feladata
	  két vagy több hálózati szegmens
	  összekötése.  Az egyszerû
	  hálózati környezet
	  felállítása helyett több
	  okból is felmerülhet a hidak
	  létrehozása: kábelezési
	  megszorítások, tûzfalazás vagy
	  pszeudo hálózatok, például
	  virtuális gépek felületének
	  csatlakoztatása miatt.  Egy híd
	  használatával ráadásul össze
	  tudunk kötni egy vezeték nélküli
	  hozzáférési pontként
	  üzemelõ felületet egy vezetékes
	  hálózattal.</para>

      </sect3>

      <sect3>
	<title>Szûrés vagy forgalomkorlátozás
	  tûzfallal</title>

	<indexterm><primary>tûzfal</primary></indexterm>
	<indexterm><primary>NAT</primary></indexterm>

	<para>Sokszor elõfordulhat, hogy
	  útválasztás vagy hálózati
	  címfordítás (NAT) nélkül
	  szeretnénk tûzfalat használni.</para>

	<para>Példaként képzeljünk el egy
	  olyan kis méretû céget, amely egy DSL vagy
	  ISDN vonalon kapcsolódik az
	  internet-szolgáltatójához.  A
	  szolgáltatótól 13, mindenki által
	  használható IP-címet kaptak és a
	  hálózatukban 10 gép van.  Ebben a
	  helyzetben egy útválasztást
	  végzõ tûzfal mûködtetése
	  nehézkessé válna az
	  alhálózatok problémái
	  miatt.</para>

	<indexterm><primary>útválasztó</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>

	<para>Egy hídként viselkedõ tûzfallal
	  azonban minden IP számozási probléma
	  nélkül egyszerûen be tudjuk dobni a
	  gépeket a DSL/ISDN útválasztó
	  mögé.</para>

      </sect3>

      <sect3>
	<title>A hálózat megcsapolása</title>

	<para>Egy hálózati híddal úgy
	  kapcsolunk össze két hálózati
	  szegmenst, hogy közben meg tudjuk vizsgálni a
	  kettejük között mozgó Ethernet
	  kereteket.  Ezt a híd felületen a &man.bpf.4;
	  valamint a &man.tcpdump.1; segítségével
	  tudjuk megoldani, vagy úgy, ha egy másik
	  felületen elküldjük az összes keret
	  másolatát (span, vagyis feszítõ
	  port).</para>

      </sect3>

      <sect3>
	<title>VPN az adatkapcsolati rétegben</title>

	<para>A két Ethernet hálózatot egy IP
	  alapú összeköttetésen keresztül
	  is össze tudunk kötni, ha a
	  hálózatokat egy EtherIP járaton
	  keresztül kötjük össze híddal, vagy
	  egy OpenVPN-hez hasonló &man.tap.4; alapú
	  megoldással.</para>

      </sect3>

      <sect3>
	<title>Redundancia az adatkapcsolati rétegben</title>

	<para>A hálózatokat több linken
	  keresztül kötjük össze és a
	  redundáns útvonalakat a feszítõfa
	  protokollal (Spanning Tree Protocol, STP).  Az Ethernetes
	  hálózatok esetében a megfelelõ
	  mûködéshez a két eszköz
	  között csak egyetlen aktív útvonal
	  létezhet, így a feszítõfa protokoll
	  észleli a hurkokat és a redundáns
	  összeköttetéseket blokkolt állapotba
	  teszi.  Amikor azonban az aktív linkek egyike
	  meghibásodik, akkor a protokoll
	  újraszámolja a fát és a
	  hálózati pontjai közti
	  konnektivitást megpróbálja
	  helyreállítani az addig blokkolt linkek
	  ismételt engedélyezésével.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>A rendszermag beállításai</title>

      <para>Ebben a szakaszban az &man.if.bridge.4;
	hálózati híd implementációval
	foglalkozunk, de a Netgraph segítségével is
	tudunk hidakat építeni.  Ez
	utóbbiról az &man.ng.bridge.4; man oldalon
	olvashatunk.</para>

      <para>Amikor létrehozunk egy hálózati hidat,
	az &man.ifconfig.8; automatikusan betölti a
	hozzá tartozó meghajtót.  Ha viszont a
	rendszermag beállításait tartalmazó
	állományba felvesszük a <literal>device
	if_bridge</literal> sort, akkor akár be is
	építhetjük a rendszermagba.</para>

      <para>A csomagszûrés minden olyan tûzfallal
	használható, amely a &man.pfil.9; rendszerre
	kapcsolódik.  Maga a tûzfal is betölthetõ
	modulként, vagy belefordítható a
	rendszermagba.</para>

      <para>A hálózati híddal forgalmat is tudunk
	szabályozni az &man.altq.4; vagy a &man.dummynet.4;
	segítségével.</para>

    </sect2>

    <sect2>
      <title>A hálózati híd
	engedélyezése</title>

      <para>Hálózati hidak felületek
	klónozásával hozhatóak létre.
	A híd létrehozásához
	használjuk az &man.ifconfig.8; programot, és a
	megfelelõ meghajtó automatikusan
	betöltõdik, ha nem lenne még
	elérhetõ a rendszermagban.</para>

      <screen>&prompt.root; <userinput>ifconfig bridge create</userinput>
bridge0
&prompt.root; <userinput>ifconfig bridge0</userinput>
bridge0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</screen>

      <para>Ekkor létrejön a hálózati
	hídhoz tartozó felület és
	véletlenszerûen generálódik
	hozzá egy Ethernetes cím.  A
	<literal>maxaddr</literal> és a
	<literal>timeout</literal> paraméterek vezérlik,
	hogy a híd mennyi MAC-címet tartson meg a keretek
	továbbításáért felelõs
	táblázatban és mennyi másodperc
	után töröljön automatikusan egy
	bejegyzést a legutolsó használat
	után.  A többi paraméter a
	feszítõfa mûködését
	irányítja.</para>

      <para>Vegyük fel a hídhoz tartozó
	hálózati tagfelületeket.  A híd csak
	akkor fog a tagfelületek között csomagokat
	továbbküldeni, amikor a híd és a tagok
	is <literal>up</literal> állapotban vannak:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 up</userinput>
&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput></screen>

      <para>A híd most már átküldi az Ethernet
	kereteket a <filename>fxp0</filename> és
	<filename>fxp1</filename> felületek között.
	Az iméntiekkel megegyezõ konfigurációt
	az <filename>/etc/rc.conf</filename> állományban
	így alakíthatjuk ki:</para>

      <programlisting>cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"</programlisting>

      <para>Ha a hídhoz IP-címet is rendelni akarunk,
	akkor inkább magánál a hídnál
	adjuk meg, ne a tagoknál.  Ezt statikusan vagy DHCP
	használatával is megtehetjük:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

      <para>A hídhoz IPv6 címet is hozzá tudunk
	rendelni.</para>

    </sect2>

    <sect2>
      <title>Tûzfalazás</title>

      <indexterm><primary>tûzfalak</primary></indexterm>

      <para>Ha engedélyezzük a csomagszûrést, a
	hídon áthaladó csomagok elõször a
	küldõ felület érkezési
	oldalára kerülnek, majd a hídra,
	végül a megfelelõ irányban levõ
	felület küldési oldalára.
	Bármelyik fázis letiltható.  Amikor a
	csomagok áramlásának iránya fontos
	számunkra, akkor jobban járunk, ha nem
	magára a hídra, hanem csak a tagfelületekre
	állítjuk be a tûzfalat.</para>

      <para>A híd számos módosítható
	beállítással rendelkezik a nem-IP és
	ARP csomagok átküldésére, valamint
	arra, hogy az IPFW tûzfal adatkapcsolati réteg
	szintjén mûködhessen.  Az &man.if.bridge.4; man
	oldal ennek részleteit tárja fel.</para>

    </sect2>

    <sect2>
      <title>Feszítõfák</title>

      <para>A híd meghajtója a gyors feszítõfa
	protokollt (Rapid Spanning Tree Protocol, RSTP avagy 802.1w)
	valósítja meg, ami visszafelé kompatibilis
	a korábban említett feszítõfa
	protokollal.  A feszítõfákat a
	hálózati topológiában
	felbukkanó hurkok észlelésére
	és eltávolítására
	alkalmazzák.  Az RSTP azonban a hagyományos
	STP-nél valamivel gyorsabb konvergenciát
	ígér, mivel itt a szomszédos switch-ek
	kicserélik egymás között az adataikat,
	és így újabb hurkok
	létrehozása nélkül képesek
	viszonylag gyorsan egyik állapotból
	átváltani a másikba.</para>

      <para>Az alábbi táblázat a támogatott
	mûködési módokat
	láthatjuk:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Operációs rendszer</entry>
	      <entry>STP módok</entry>
	      <entry>Alapértelmezés</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>&os;&nbsp;5.4&mdash;&os;&nbsp;6.2</entry>
	      <entry>STP</entry>
	      <entry>STP</entry>
	    </row>

	    <row>
	      <entry>&os;&nbsp;6.3+</entry>
	      <entry>RSTP vagy STP</entry>
	      <entry>STP</entry>
	    </row>

	    <row>
	      <entry>&os;&nbsp;7.0+</entry>
	      <entry>RSTP vagy STP</entry>
	      <entry>RSTP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>A tagfelületeken az <literal>stp</literal> paranccsal
	tudjuk engedélyezni a feszítõfák
	használatát.  Az <filename>fxp0</filename>
	és <filename>fxp1</filename> felületeket
	összekötõ hídfelület esetében
	tehát így:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 stp fxp0 stp fxp1</userinput>
bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Láthatjuk, hogy a híd a
	feszítõfában megkapta a
	<literal>00:01:02:4b:d4:50</literal>-es azonosítót
	és a <literal>32768</literal>-as prioritást.
	Mivel <literal>root id</literal> értéke is
	ugyanez, elmondhatjuk, hogy ez a fa gyökereként
	funkcionáló híd.</para>

      <para>Ha a hálózaton már valahol
	létezik egy másik híd:</para>

      <screen>bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>A <literal>root id 00:01:02:4b:d4:50 priority 32768 ifcost
	400000 port 4</literal> sor mutatja, hogy a fa
	gyökerét képezõ híd most a
	<literal>00:01:02:4b:d4:50</literal> azonosítóval
	rendelkezik, és ezt a hidat <literal>400000</literal>-res
	költséggel éri el a <literal>port 4</literal>
	(a 4.  porton) keresztül, amely jelen esetben az
	<filename>fxp0</filename> felület.</para>

    </sect2>

    <sect2>
      <title>Komolyabb hidak építése</title>

      <sect3>
	<title>A forgalom áramlásának
	  átszerkesztése</title>

	<para>A hidak támogatják az ún.
	  megfigyelési módot, ahol a csomagokat a
	  &man.bpf.4; feldolgozásuk után eldobja,
	  így nem folytatódik a feldolgozásuk vagy
	  nem haladnak tovább.  Ennek
	  kihasználásával a két vagy
	  több felületen érkezõ adatokat egyetlen
	  &man.bpf.4; folyammá tudjuk alakítani.  Ez olyan
	  hálózati csapok forgalmának
	  átszerkesztésében hasznos, ahol a
	  két különbözõ felületen
	  keresztül küldjük ki az RX/TX
	  (fogadás/küldés) jeleket.</para>

	<para>Az alábbi paranccsal tudjuk megoldani, hogy
	  négy felületrõl érkezõ adatot
	  legyünk képesek egyetlen folyamként
	  olvasni:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</userinput>
&prompt.root; <userinput>tcpdump -i bridge0</userinput></screen>

      </sect3>

      <sect3>
	<title>Feszítõ portok</title>

	<para>A hídhoz befutó Ethernet keretek
	  mindegyikérõl készül egy
	  másolat, ami egy megadott feszítõ porton
	  keresztül megy tovább.  Hidanként
	  végtelen számú ilyen feszítõ
	  port létezhet, és ha egy felületet
	  feszítõ portnak adtunk meg, akkor
	  hagyományos portként már nem
	  használhatjuk.  Ez leginkább akkor hasznos,
	  amikor passzívan akarjuk megfigyelni a híddal
	  rendelkezõ hálózatot a híd
	  valamelyik feszítõ portjára
	  csatlakozó géprõl.</para>

	<para>Küldessük az összes keretrõl egy
	  másolatot az <filename>fxp4</filename>
	  felületre:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 span fxp4</userinput></screen>

      </sect3>

      <sect3>
	<title>Privát felületek</title>

	<para>A privát felületek (private interface) csak
	  más privát felületek felé
	  küldenek tovább adatot.  Így
	  feltétel nélkül tudjuk korlátozni a
	  forgalmat, és sem Ethernet keretek, sem pedig ARP nem
	  megy keresztül rajtuk.  Ha viszont szelektíven
	  akarjuk korlátozni a forgalmat, akkor helyette
	  használjunk tûzfalat.</para>

      </sect3>

      <sect3>
	<title>Tapadós felületek</title>

	<para>Ha a híd egyik tagfelületét
	  tapadósnak (sticky) adjuk meg, akkor a dinamikusan
	  megtanult címek bejegyzései a
	  gyorsítótárba kerülésük
	  után állandósulnak.  A tapadós
	  bejegyzések soha nem évülnek el vagy
	  cserélõdnek le, még abban az esetben sem,
	  ha utána az adott címet egy másik
	  felületrõl látjuk.  Így a
	  továbbításra vonatkozó
	  táblázatot nem kell elõre
	  feltöltenünk, és a híd egyik
	  oldalán meglátott kliensek nem képesek
	  átvándorolni egy másik
	  hálózati szegmensbe.</para>

	<para>Másik ilyen példa a tapadós
	  címek használatára az lehetne, amikor a
	  hidat VLAN-nal kombináljuk, és így egy
	  olyan útválasztót hozunk létre,
	  ahol az ügyfeleink az IP-címtartomány
	  pocséklása nélkül
	  zárhatóak el egymástól.
	  Tegyük fel, hogy az <systemitem class="fqdomainname">A-ugyfel</systemitem> a
	  <literal>vlan100</literal>, és a <systemitem class="fqdomainname">B-ugyfel</systemitem> a <literal>vlan101</literal>
	  felületen csatlakozik.  A híd IP-címe
	  <systemitem class="ipaddress">192.168.0.1</systemitem>, amely maga is egy
	  internet felé mutató
	  útválasztó.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</userinput>
&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

	<para>Mind a két kliens a <systemitem class="ipaddress">192.168.0.1</systemitem> címet látja
	  alapértelmezett átjáróként,
	  és mivel a híd gyorsítótára
	  tapadós bejegyzéseket tartalmaz, a
	  MAC-címeik meghamisításával nem
	  tudják elcsípni a másikuk
	  forgalmát.</para>

	<para>A VLAN-ok közti bárminemû
	  kommunikációt privát felületek
	  létrehozásával akadályozzuk meg
	  (vagy egy tûzfallal):</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 private vlan100 private vlan101</userinput></screen>

	<para>Ezzel a megoldással az ügyfeleinket teljesen
	  elszigeteljük egymástól úgy, hogy
	  közben az egész <systemitem class="netmask">/24</systemitem> címtartomány
	  külön alhálózatok
	  kialakítása nélkül
	  kiosztható.</para>

      </sect3>

      <sect3>
	<title>Címek korlátozása</title>

	<para>Korlátozhatóak az egy felület
	  mögül küldeni képes egyedi
	  MAC-címek.  Amikor ezen a határon felül
	  érkeznek ismeretlen feladótól csomagok,
	  egészen addig eldobjuk ezeket, amíg egy
	  korábban már regisztrált
	  bejegyzést a rendszer ki nem töröl vagy ki
	  nem veszünk a
	  gyorsítótárból.</para>

	<para>A következõ példában az
	  <literal>vlan100</literal> felületen csatlakozó
	  <systemitem class="fqdomainname">A-ugyfel</systemitem>
	  számára korlátozzuk le 10-re az Ethernet
	  eszközök számát:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 ifmaxaddr vlan100 10</userinput></screen>

      </sect3>

      <sect3>
	<title>SNMP felügyelet</title>

	<para>A hidak és az STP paraméterei az alap &os;
	  rendszerben megtalálható SNMP démonnal
	  felügyelhetõek.  A hídhoz exportált
	  felügyeleti információk (Management
	  Information Base, MIB) megfelelnek az IETF által
	  elõírt szabványoknak, így
	  akár tetszõleges SNMP kliens vagy bármilyen
	  más felügyeleti szoftver alkalmas az
	  olvasásukra.</para>

	<para>A hidat mûködtetõ gépen az
	  <filename>/etc/snmpd.config</filename>
	  állományban engedélyezzük a
	  <literal>begemotSnmpdModulePath."bridge" =
	  "/usr/lib/snmp_bridge.so"</literal> sort és
	  indítsuk el a <application>bsnmpd</application>
	  démont.  Itt még szükség lehet
	  más beállítások,
	  például a közösségek
	  nevének (community name) vagy a
	  hozzáférési listák (access list)
	  módosítására is.  Ezzel
	  kapcsolatban a &man.bsnmpd.1; és az &man.snmp.bridge.3;
	  man oldalakat lapozzuk fel.</para>

	<para>A következõ példában a
	  <application>Net-SNMP</application> nevû szoftver
	  (<package>net-mgmt/net-snmp</package>) fogjuk
	  használni a híd elérésére,
	  de ugyanerre a <package>net-mgmt/bsnmptools</package> port is
	  alkalmas.  Az SNMP klienst használó gépen
	  egészítsük ki az
	  <filename>$HOME/.snmp/snmp.conf</filename>
	  állományt a híd felügyeleti
	  információinak
	  importálásával az
	  <application>Net-SNMP</application> rendszerébe:</para>

	<programlisting>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</programlisting>

	<para>Az IETF BRIDGE-MIB (RFC&nbsp;4188)
	  használatán keresztül így tudjuk
	  elindítani egy híd
	  felügyeletét:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge</userinput>
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)</screen>

	<para>A példában látszik, hogy a
	  <literal>dot1dStpTopChanges.0</literal> értéke
	  kettõ, ami arra utal, hogy az STP híd
	  topológiája kétszer változott.  A
	  topológia változása pedig azt jelenti,
	  hogy a hálózaton belül egy vagy több
	  link állapota megváltozott vagy egyszerûen
	  meghibásodott és ezért egy új
	  fát kellett számolni.  A
	  <literal>dot1dStpTimeSinceTopologyChange.0</literal>
	  érték adja meg, hogy ez pontosan mikor is
	  történt.</para>

	<para>Több híd felületének
	  felügyeletéhez a belsõ BEGEMOT-BRIDGE-MIB
	  parancsot is használhatjuk:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com</userinput>
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9</screen>

	<para>Így tudjuk megadni, hogy a hidat
	  <literal>mib-2.dot1dBridge</literal> részfán
	  keresztül akarjuk megfigyelni:</para>

	<screen>&prompt.user; <userinput>snmpset -v 2c -c private bridge1.example.com</userinput>
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</screen>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-aggregation">
    <info><title>Linkek összefûzése és
      hibatûrése</title>
      <authorgroup>
	<author><personname><firstname>Andrew</firstname><surname>Thompson</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>lagg</primary></indexterm>
    <indexterm><primary>failover</primary></indexterm>
    <indexterm><primary>fec</primary></indexterm>
    <indexterm><primary>lacp</primary></indexterm>
    <indexterm><primary>loadbalance</primary></indexterm>
    <indexterm><primary>roundrobin</primary></indexterm>

    <sect2>
      <title>Bevezetés</title>

      <para>A &man.lagg.4; felület lehetõvé teszi, hogy
	több hálózati felületet egyetlen
	virtuális felületként fûzzünk
	össze, és ezzel egy hibatûrõ és
	nagysebességû összeköttetést
	alakítsunk ki.</para>

    </sect2>

    <sect2>
      <title>Mûködési módok</title>

      <variablelist>
	<varlistentry><term>failover</term>
	<listitem>
	  <para>Csak az elsõdlegesként kijelölt porton
	    keresztül fogad és küld adatokat.  Amikor
	    ez az elsõdleges port elérhetetlenné
	    válik, a következõ aktív portot
	    fogja használni.  Az elsõként felvett
	    felület válik automatikusan az elsõdleges
	    porttá, és az utána felvett összes
	    többit pedig csak hiba esetén
	    használjuk.</para>
	</listitem>
	</varlistentry>

	<varlistentry><term>&cisco; Fast &etherchannel;</term>

	<listitem>
	  <para>A &cisco; Fast &etherchannel; (FEC) technológia
	    támogatása.  Ez egy statikus
	    beállítás, és nem egyezteti az
	    összefûzést a többiekkel vagy a linkek
	    felügyeletéhez nem vált kereteket.  Ha a
	    switch támogatja az LACP használatát,
	    akkor inkább azt válasszuk.</para>

	  <para>A <acronym>FEC</acronym> a kimenõ forgalmat a
	    fejlécekben szereplõ protokollok alapján
	    számolt hasítókóddal
	    próbálja szétosztani az aktív
	    portok között, és tetszõleges
	    aktív porton fogad beérkezõ adatokat.  Az
	    említett hasítókódban egy
	    Ethernetes forrás- és célcím
	    szerepel, valamint ha elérhetõ, akkor egy VLAN
	    címke, illetve az IPv4/IPv6 forrás- és
	    célcím.</para>
	</listitem>
	</varlistentry>

	<varlistentry><term>LACP</term>

	<listitem>
	  <para>Az &ieee; 802.3ad Link Aggregation Control Protocol (LACP)
	    és a Marker Protcol támogatása.  Az
	    LACP megpróbálja egyeztetni a többi
	    géppel az összefûzhetõ linkeket egy
	    vagy több csoportban (Link Aggregated Group, LAG).
	    Mindegyik ilyen csoportban ugyanolyan sebességû
	    portokat találunk, full-duplex
	    mûködési módban.  A forgalmat
	    így a legnagyobb összsebességgel
	    rendelkezõ csoportban megtalálható portok
	    között osztja el, ami a legtöbb esetben az
	    összes portot magában foglaló csoport.  A
	    fizikai konnektivitás megváltozása
	    esetén a linkek összefûzõdése
	    igen gyorsan alkalmazkodik az új
	    konfigurációhoz.</para>

	  <para>Az <acronym>LACP</acronym> a kimenõ forgalmat az
	    aktív portok között osztja szét
	    fejlécekben szereplõ protokollok alapján
	    számolt hasítókóddal, és
	    bármelyik aktív portról fogad
	    bejövõ forgalmat.  A
	    hasítókódban megtalálható
	    az Ethernetes forrás- és célcím,
	    valamint ha elérhetõ, akkor a VLAN címke,
	    illetve az IPv4/IPv6 forrás- és
	    célcímek.</para>
	</listitem>
	</varlistentry>

	<varlistentry><term>Loadbalance</term>

	<listitem>
	  <para>Ez a <emphasis>FEC</emphasis> mód másik
	    neve.</para>
	</listitem>
	</varlistentry>

	<varlistentry><term>Round-Robin</term>

	<listitem>
	  <para>A kimenõ forgalmat egy körkörös
	    (Round-Robin) elvû ütemezõvel osztja
	    szét az aktív portok között
	    és tetszõleges aktív portról fogad
	    bejövõ forgalmat.  Ez a mûködési
	    mód megsérti az Ethernet keretek
	    rendezését és csak nagy
	    körültekintés mellett alkalmazzuk.</para>
	</listitem>
	</varlistentry>
      </variablelist>

    </sect2>

    <sect2>
      <title>Példák</title>

      <example xml:id="networking-lacp-aggregation-cisco">
	<title>LACP alapú összefûzés egy &cisco;
	  switch-csel</title>

	<para>Ebben a példában egy &os;-s gép
	  két felületét kapcsoljuk össze
	  switch-csel egy egyszerû
	  terhelés-kiegyenlítéssel és
	  hibatûréssel beállított linken
	  keresztül.  Mivel az Ethernet keretek sorrendje
	  döntõ fontosságú, ezért a
	  két állomás között egyazon
	  fizikai linken zajló forgalom maximális
	  sebességét az adott felület
	  kapacitása korlátozza.  A küldési
	  algoritmus a lehetõ legtöbb információ
	  alapján próbálja egymástól
	  megkülönböztetni a forgalmakat és
	  elosztani ezeket a rendelkezésre álló
	  felületek között.</para>

	<para>A &cisco; switch-en vegyünk fel a
	  <replaceable>FastEthernet0/1</replaceable> és
	  <replaceable>FastEthernet0/2</replaceable>
	  interfészeket az <replaceable>1</replaceable> csoportba
	  (channel group):</para>

	<screen><userinput>interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp</userinput>
!
<userinput>interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</userinput></screen>

	<para>A &os;-s gépen pedig a
	  <replaceable>fxp0</replaceable> és
	  <replaceable>fxp1</replaceable> használatával
	  hozzunk létre a &man.lagg.4; interfészt:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1</userinput></screen>

	<para>Ellenõrizzük a felület
	  állapotát:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput></screen>

	<para>A <emphasis>ACTIVE</emphasis> jelzésû, vagyis
	  aktív állapotú portok az
	  összefûzéshez kialakított csoport azon
	  tagjai, amelyeknél felépült a kapcsolat a
	  távoli switch felé és készen
	  állnak a küldésre és
	  fogadásra.  Ha az &man.ifconfig.8; programtól
	  részletesebb kimenetet kérünk, akkor
	  láthatjuk a csoportok azonosítóit
	  is:</para>

	<screen>lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</screen>

	<para>A <userinput>show lacp neighbor</userinput> paranccsal
	  kérdezhetjük le a portok
	  állapotát:</para>

	<screen>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</screen>

	<para>Részletesebb kijelzést a <userinput>show
	    lacp neighbor detail</userinput> paranccsal kaphatunk.</para>
      </example>

      <example xml:id="networking-lagg-failover">
	<title>A hibatûrés
	  beállítása</title>

	<para>A hibatûrési mód arra alkalmas, hogy
	  amikor az elsõdleges porton elvesztjük a
	  kapcsolatot, helyette egy másodlagos interfész
	  használatára tudunk áttérni.
	  Hozzuk létre és állítsuk be a
	  <replaceable>lagg0</replaceable> interfészt, ahol az
	  <replaceable>fxp0</replaceable> legyen a
	  fõinterfész, az <replaceable>fxp1</replaceable>
	  pedig a tartalék interfész:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1</userinput></screen>

	<para>Az így létrejövõ interfész
	  nagyjából az alábbi lesz, ahol
	  eltérés a <acronym>MAC</acronym>-cím
	  és az eszköz neve:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0&lt;&gt;
        laggport: fxp0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>A forgalom kezdetben az <replaceable>fxp0</replaceable>
	  felületen keresztül érkezik és
	  távozik.  Ha az <replaceable>fxp0</replaceable>
	  felületen valamiért megszakadna a kapcsolat,
	  helyette az <replaceable>fxp1</replaceable> lesz az
	  aktív link.  Ha késõbb helyreáll a
	  kapcsolat az elsõdleges felületen, akkor újra
	  az lesz aktív link.</para>
      </example>

      <example xml:id="networking-lagg-wired-and-wireless">
	<title>Hibatûrés beállítása
	  vezetékes és vezeték nélküli
	  hálózatok között</title>

	<para>Hordozható számítógépek
	  használata esetén általában
	  érdemesebb a vezeték nélküli
	  kapcsolatot másodlagos interfészként
	  beállítani, így csak akkor
	  használja a rendszer, ha vezetékes
	  hálózat nem érhetõ el.  A
	  &man.lagg.4; segítségével egyetlen
	  IP-címmel tudjuk használni mind a két
	  interfészt: a teljesítmény és
	  biztonságosság miatt elsõsorban a
	  vezetékes hálózatot használjuk,
	  miközben megmarad a lehetõség az adatok
	  továbbítására a vezeték
	  nélküli kapcsolaton keresztül is.</para>

	<para>A beállítás során a
	  vezeték nélküli interfész
	  <acronym>MAC</acronym>-címét úgy kell
	  módosítanunk, hogy megegyezzen a &man.lagg.4;
	  címével.  A &man.lagg.4; interfész a
	  saját <acronym>MAC</acronym>-címét az
	  elsõdleges interfésztõl örökli,
	  amely jelen esetünkben a vezetékes
	  interfész lesz.</para>

	<para>A most következõ példában a
	  vezetékes hálózatunk lesz az
	  elsõdleges interfész
	  (<replaceable>bge0</replaceable>), míg a vezeték
	  nélküli (<replaceable>wlan0</replaceable>) a
	  másodlagos.  A <replaceable>wlan0</replaceable>
	  interfészt az <replaceable>iwn0</replaceable>
	  interfészbõl hoztuk létre, és a
	  vezetékes kapcsolat
	  <acronym>MAC</acronym>-címét
	  állítjuk be neki.  Elsõ
	  lépésként tehát le kell
	  kérdeznünk a vezetékes interfész
	  <acronym>MAC</acronym>-címét:</para>

	<screen>&prompt.root; <userinput>ifconfig bge0</userinput>
bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
	ether 00:21:70:da:ae:37
	inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
	nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
	media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
	status: active</screen>

	<para>A <replaceable>bge0</replaceable> helyett
	  természetesen a saját vezetékes
	  hálózati interfészünket kell
	  megadni, és az <literal>ether</literal> kezdetû
	  sorban is saját kártyánk
	  <acronym>MAC</acronym>-címe fog megjelenni.
	  Ezután már meg is tudjuk változtatni az
	  <replaceable>iwn0</replaceable> címét:</para>

	<screen>&prompt.root; <userinput>ifconfig iwn0 ether 00:21:70:da:ae:37</userinput></screen>

	<para>Aktiváljuk a vezeték nélküli
	  interfészt, de ne állítsunk be neki
	  semmilyen IP-címet:</para>

	<screen>&prompt.root; <userinput>ifconfig wlan0 create wlandev iwn0 ssid wlan_hálózat up</userinput></screen>

	<para>Hozzuk létre a &man.lagg.4; interfészt a
	  <replaceable>bge0</replaceable> mint elsõdleges
	  interfész megadásával, valamint a
	  <replaceable>wlan0</replaceable> legyen a szükség
	  esetén használható
	  tartalék:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0 create</userinput>
&prompt.root; <userinput>ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0</userinput></screen>

	<para>Az így létrehozott interfész
	  nagyjából így fog megjelenni, egyedüli
	  fontosabb eltérések a
	  <acronym>MAC</acronym>-címek és az
	  eszközök nevei:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 flags=0&lt;&gt;
        laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Hogy ne kelljen a rendszer minden egyes
	  indítása után ezt a mûveletet
	  megismételni, vegyük fel a következõ
	  sorokat az <filename>/etc/rc.conf</filename>
	  állományba:</para>

	<programlisting>ifconfig_bge0="up"
ifconfig_iwn0="ether 00:21:70:da:ae:37"
wlans_iwn0="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto failover laggport bge0 laggport wlan0 DHCP"
</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="network-diskless">
    <info><title>Lemez nélküli mûködés</title>
      <authorgroup>
	<author><personname><firstname>Jean-Fran&ccedil;ois</firstname><surname>Dock&egrave;s</surname></personname><contrib>Frissítette: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Alex</firstname><surname>Dupre</surname></personname><contrib>Átdolgozta és javította:
	    </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>lemez nélküli
      munkaállomás</primary></indexterm>
    <indexterm><primary>lemez nélküli
      mûködés</primary></indexterm>

    <para>A &os; képes hálózaton keresztül
      elindulni és helyi lemez nélkül egy
      <acronym>NFS</acronym> szerver által megosztott
      állományrendszer csatlakoztatásával
      mûködni.  Ehhez a szabványos
      konfigurációs állományok
      módosításán kívül semmi
      másra nincs szükségünk.  Egy ilyen
      rendszert viszonylag könnyû beállítani,
      mivel az összes hozzávaló szinte készen
      elérhetõ:</para>

    <itemizedlist>
      <listitem>
	<para>Rögtön adott legalább két
	  módszer, ha a rendszermagot hálózaton
	  keresztül akarjuk betölteni:</para>

	<itemizedlist>
	  <listitem>
	    <para><acronym>PXE</acronym>: az &intel; által
	      fejlesztett Preboot eXecution Environment
	      (<quote>indítás elõtti
	      végrehajtási környezet</quote>)
	      nevû rendszer a hálózati
	      kártyákba vagy alaplapokba
	      épített ROM
	      segítségével teszi
	      lehetõvé az intelligens
	      rendszerindítást.  A &man.pxeboot.8; man
	      oldalán olvashatunk errõl
	      részletesebben.</para>
	  </listitem>
	  <listitem>
	    <para>Az <application>Etherboot</application> port
	      (<package>net/etherboot</package>) olyan
	      ROM-ba programozható kódot
	      készít, amellyel rendszermagokat tudunk
	      hálózaton keresztül betölteni.  Ez
	      a kód egyaránt felhasználható
	      egy hálózati rendszerindító
	      PROM beégetéséhez, vagy
	      betölthetõ a helyi floppy (esetleg
	      merev)lemezrõl, illetve &ms-dos; rendszer
	      alól.  Elég sok hálózati
	      kártya támogatja ezt a módot.</para>
	  </listitem>
	</itemizedlist>
	</listitem>

      <listitem>
	<para>Egy mintaszkript
	  (<filename>/usr/share/examples/diskless/clone_root</filename>)
	  is próbálja megkönnyíteni a
	  szerveren a munkaállomás
	  rendszerindító
	  állományrendszerének
	  létrehozását és
	  karbantartását.  Ezt a szkriptet
	  valószínûleg némileg
	  módosítani kell, de így is sokat
	  segít az elindulásban.</para>
      </listitem>

      <listitem>
	<para>Az <filename>/etc</filename> könyvtárban
	  található szabványos
	  rendszerindításhoz használt
	  állományok, amelyekkel a lemez
	  nélküli indulást lehet detektálni
	  és segíteni.</para>
      </listitem>

      <listitem>
	<para>A lapozás, amennyiben szükséges,
	  <acronym>NFS</acronym> vagy helyi lemez
	  segítségével oldható meg.</para>
      </listitem>
    </itemizedlist>

    <para>Számos módon állíthatunk be egy
      lemez nélküli munkaállomást.  Rengeteg
      részbõl tevõdik össze, és ezek
      legtöbbje remekül testreszabható az
      igényeinknek.  A továbbiakban egy teljes rendszer
      összeállításának
      lehetséges variációit ismertetjük,
      különös hangsúlyt fektetünk arra, hogy
      egyszerûek és a hagyományos &os;
      indítószkriptekkel kompatibilisek maradjanak.  A
      bemutatandó rendszer a következõ
      jellemzõkkel bír:</para>

    <itemizedlist>
      <listitem>
	<para>A lemez nélküli munkaállomások
	  megosztott <filename>/</filename> és
	  <filename>/usr</filename> állományrendszereket
	  használnak.</para>

	<para>A rendszer indításához
	  használt gyökér
	  állományrendszer a szabvány &os;-s
	  gyökér (ez általában a
	  szerveré), ahol néhány
	  állományt felülírtunk a lemez
	  nélküli mûködéshez vagy
	  azért, mert egyszerûen az adott
	  munkaállomáshoz tartozik.</para>

	<para>A gyökér azon részeit, amelyeket
	  írhatóvá kívánunk tenni,
	  &man.md.4; alapú állományrendszerekkel
	  lapoljuk felül.  Ilyenkor azonban bármilyen rajtuk
	  ejtett változtatás a rendszer
	  újraindításával elveszik.</para>
      </listitem>

      <listitem>
	<para>A rendszermagot vagy az
	  <application>Etherboot</application> vagy a
	  <acronym>PXE</acronym> használatával
	  küldessük át és töltsük be,
	  mivel egyes helyzetekben ezekre szükség
	  lesz.</para>
      </listitem>
    </itemizedlist>

    <caution>
      <para>A bemutatott rendszer nem biztonságos.
	Helyezzük a hálózatunk egy jól
	védett részére, és a többi
	gép ne tekintse megbízhatónak.</para>
    </caution>

    <para>A szakaszban szereplõ összes
      információt a &os;&nbsp;5.2.1-RELEASE
      változatával teszteltük.</para>

    <sect2>
      <title>Háttérinformációk</title>

      <para>A lemez nélküli munkaállomások
	beállítása egyszerre adja magát
	és könnyen is elvéthetõ.  Az
	elkövetett hibákat olykor számos okból
	kifolyólag nehéz felismerni.
	Például:</para>

      <itemizedlist>
	<listitem>
	  <para>A fordítási idõben megadott
	    beállítások mást
	    eredményeznek futási idõben.</para>
	</listitem>

	<listitem>
	  <para>A hibaüzenetek gyakran titokzatosak vagy esetleg
	    teljesen el is maradnak.</para>
	</listitem>
      </itemizedlist>

      <para>Ezért ha valamennyire tisztában vagyunk a
	háttérben zajló folyamatokkal, akkor sokkal
	több eséllyel leszünk képesek megoldani
	a menet közben felmerülõ
	problémákat.</para>

      <para>A rendszernek a sikeres felkapaszkodáshoz több
	mûveletet is végre kell hajtania:</para>

      <itemizedlist>
	<listitem>
	  <para>A gépnek szüksége van olyan
	    induló paraméterekhez, mint
	    például az IP-cím, a
	    végrehajtható állomány neve, a
	    szerver neve, a gyökér elérési
	    útja.  Ezeket a <acronym>DHCP</acronym> vagy a BOOTP
	    protokollok használatával adhatjuk meg.  A
	    <acronym>DHCP</acronym> a BOOTP kompatibilis
	    kiterjesztése, ezért ugyanazokat a portokat
	    és alapvetõ csomagformátumot
	    alkalmazza.</para>

	  <para>A rendszerüket kizárólag BOOTP
	    használatával is beállíthatjuk.
	    A &man.bootpd.8; szerver az alap &os; rendszer
	    része.</para>

	  <para>A <acronym>DHCP</acronym> azonban rengeteg elõnnyel
	    rendelkezik a BOOTP protokollal szemben
	    (áttekinthetõbb konfigurációs
	    állományok, a <acronym>PXE</acronym>
	    használatának lehetõsége, illetve
	    sok minden más, ami nem csak a lemez
	    nélküli mûködéshez kellhet),
	    ezért itt alapvetõen egy DHCP alapú
	    konfigurációt mutatunk be, de ahol
	    megoldható, megemlítjük a &man.bootpd.8;
	    esetén alkalmas példákat is.  A
	    mintaként szolgáló
	    konfiguráció az <application>ISC
	    DHCP</application> szoftvercsomagot használja (a
	    tesztszerverre ennek a 3.0.1.r12 verzióját
	    telepítetük fel).</para>
	</listitem>

	<listitem>
	  <para>A gépnek egy vagy több programot kell a
	    saját memóriájába
	    áttöltenie.  Erre vagy a <acronym>TFTP</acronym>
	    vagy pedig az <acronym>NFS</acronym> alkalmas.  A
	    <acronym>TFTP</acronym> és az <acronym>NFS</acronym>
	    között sok helyen fordítási
	    idõben tudunk választani.  Gyakori
	    hibaforrás a protokollhoz rosszul megadott
	    állománynevek használata: a
	    <acronym>TFTP</acronym> általában az
	    összes állományt a szerverrõl
	    egyetlen könyvtárból tölti
	    át, ezért arra számít, hogy a
	    neveiket ehhez viszonyítva adjuk meg.  Az
	    <acronym>NFS</acronym> használata során
	    azonban abszolút elérési utakat kell
	    megadnunk.</para>
	</listitem>

	<listitem>
	  <para>A rendszer indítását
	    lehetõvé tevõ közbensõ
	    programokat és a rendszermagot valahogy
	    inicializálni kell és elindítani.  Ezen
	    a területen több fontos változat kapott
	    helyet:</para>

	  <itemizedlist>
	    <listitem>
	      <para>A <acronym>PXE</acronym> a &man.pxeboot.8;
		kódját fogja betölteni, ez
		lényegében a &os; betöltõ
		harmadik fokozatának egy módosított
		változata.  A &man.loader.8; a
		mûködéséhez
		szükséges paramétereket a rendszer
		indításakor kapja meg, majd a
		vezérlés átadása elõtt
		ezeket a rendszermag környezetében hagyja.
		Ebben az esetben akár a
		<filename>GENERIC</filename> rendszermag is
		használható.</para>
	    </listitem>

	    <listitem>
	      <para>Az <application>Etherboot</application> kevesebb
		elõkészítéssel
		közvetlenül magát a rendszermagot
		tölti be.  Ehhez azonban egy saját
		rendszermagot kell építeni,
		külön
		beállításokkal.</para>
	    </listitem>
	  </itemizedlist>

	  <para>A <acronym>PXE</acronym> és az
	    <application>Etherboot</application> egyaránt
	    jól használható.  Mivel azonban a
	    rendszermagok általában a &man.loader.8;
	    kódjára hagyják a munka legnagyobb
	    részét, ezért ahol lehetséges, a
	    <acronym>PXE</acronym> megoldását
	    érdemes alkalmazni.</para>

	  <para>Tehát ha az alaplapi <acronym>BIOS</acronym>
	    és a hálózati kártya is
	    támogatja a <acronym>PXE</acronym>
	    használatát, akkor válasszunk
	    inkább azt.</para>
	</listitem>

	<listitem>
	  <para>Végezetül a gépnek valamilyen
	    módon hozzá kell tudnia férnie az
	    állományrendszerekhez.  Erre többnyire az
	    <acronym>NFS</acronym> jöhet szóba.</para>
	</listitem>
      </itemizedlist>

      <para>A további részleket lásd a
	&man.diskless.8; man oldalon.</para>

    </sect2>

    <sect2>
      <title>Beállítási
	útmutató</title>

      <sect3>
	<title>Beállítás a <application>ISC
	  DHCP</application> használatával</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>lemez nélküli
	    mûködés</secondary>
	</indexterm>

	  <para>Az <application>ISC DHCP</application> szervere
	    képes a BOOTP és <acronym>DHCP</acronym>
	    kéréseket is megválaszolni.</para>

	  <para>Az <application>ISC DHCP 3.0</application> nem az
	    alaprendszer része, ezért a
	    használatához elõször
	    telepítenünk kell a <package>net/isc-dhcp30-server</package> portot vagy a
	    neki megfelelõ csomagot.</para>

	  <para>Ahogy feltelepítettük, le kell futtatnunk az
	    <application>ISC DHCP</application>
	    konfigurációs állományát
	    (ezt általában
	    <filename>/usr/local/etc/dhcpd.conf</filename> néven
	    találjuk meg).  A most következõ,
	    megjegyzésekkel kiegészített
	    példában egy <systemitem>margaux</systemitem>
	    nevû gép az
	    <application>Etherboot</application>, valamint egy
	    <systemitem>corbieres</systemitem> nevû gép
	    <acronym>PXE</acronym> használatával akar
	    kapcsolódni:</para>

	  <programlisting>
default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "minta.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <co xml:id="co-dhcp-host-name"/>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.minta.com;
    next-server 192.168.4.4; <co xml:id="co-dhcp-next-server"/>
    filename "/data/misc/kernel.diskless"; <co xml:id="co-dhcp-filename"/>
    option root-path "192.168.4.4:/data/misc/diskless"; <co xml:id="co-dhcp-root-path"/>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.minta.com;
    next-server 192.168.4.4;
    filename "pxeboot";
    option root-path "192.168.4.4:/data/misc/diskless";
  }
}
</programlisting>

	  <calloutlist>
	    <callout arearefs="co-dhcp-host-name">
	      <para>Ez a beállítás arra
		utasítja a <application>dhcpd</application>
		démont, hogy a lemez nélküli
		gép hálózati neveként a
		<literal>host</literal> deklarációban
		megadott értéket küldje el.  Ezt
		úgyis meg lehet csinálni, hogy
		felvesszünk egy <literal>option host-name
		margaux </literal>
		részt a <literal>host</literal>
		deklarációk közé.</para>
	    </callout>

	    <callout arearefs="co-dhcp-next-server">
	      <para>A <literal>next-server</literal> direktíva a
		betöltõ vagy a rendszermag
		betöltéséért felelõs
		<acronym>TFTP</acronym> vagy <acronym>NFS</acronym>
		szervert jelöli ki (alapértelmezés
		szerint ez megegyezik a <acronym>DHCP</acronym>
		szerverrel).</para>
	    </callout>

	    <callout arearefs="co-dhcp-filename">
	      <para>A <literal>filename</literal> direktíva azt
		az állományt adja meg, amelyet az
		<application>Etherboot</application> vagy a
		<acronym>PXE</acronym> a következõ
		végrehajtási lépésben
		betölt.  Ezt a kiválasztott átviteli
		módnak megfelelõen kell megadni.  Az
		<application>Etherboot</application>
		lefordítható az <acronym>NFS</acronym>
		vagy a <acronym>TFTP</acronym>
		használatával is.  A &os; port
		alapból az <acronym>NFS</acronym>
		támogatását tartalmazza.  A
		<acronym>PXE</acronym> a <acronym>TFTP</acronym>
		protokollt használja, ezért itt
		relatív állományneveket adunk meg
		(ez persze a <acronym>TFTP</acronym> szerver
		beállításaitól függ, de
		általában ez a jellemzõ).  Sõt,
		a <acronym>PXE</acronym> a <filename>pxeboot</filename>
		állományt tölti be, nem is a
		rendszermagot.  Léteznek további
		érdekes lehetõségek is, mint
		például a <filename>pxeboot</filename>
		állomány betöltése a &os;
		CD-jén található <filename>/boot</filename>
		könyvtárból (mivel a &man.pxeboot.8;
		a <filename>GENERIC</filename> rendszermagot
		képes betölteni, ezért a
		<acronym>PXE</acronym> használatával
		akár egy távoli
		CD-meghajtóról is indíthatjuk a
		rendszert).</para>
	    </callout>

	    <callout arearefs="co-dhcp-root-path">
	      <para>A <literal>root-path</literal> opció a
		rendszer indításához
		használt gyökér
		állományrendszert nevezi meg, amelyet
		többnyire az <acronym>NFS</acronym>
		jelölési módszere szerint kell
		megadni.  A <acronym>PXE</acronym> használata
		során el lehet hagyni a gép
		IP-címét egészen addig, amíg
		nem engedélyezzük a rendszermagban a BOOTP
		beállítást.  Az
		<acronym>NFS</acronym> szerver ekkor megegyzik a
		<acronym>TFTP</acronym> szerverrel.</para>
	    </callout>
	  </calloutlist>

      </sect3>

      <sect3>
	<title>Beállítás a BOOTP
	  használatával</title>

	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>lemez nélküli
	    mûködés</secondary>
	</indexterm>

	  <para>Itt a <application>bootpd</application> (egyetlen
	    kliensre korlátozott)
	    beállítását láthatjuk.
	    Ezt az <filename>/etc/bootptab</filename>
	    állományba tegyük.</para>

	  <para>Ne feledjük, hogy a BOOTP
	    használatához az
	    <application>Etherboot</application> portot a
	    <literal>NO_DHCP_SUPPORT</literal>
	    beállítással kell fordítanunk,
	    miközben a <acronym>PXE</acronym> esetében kell
	    a <acronym>DHCP</acronym>.  Egyébként a
	    <application>bootpd</application> egyedüli
	    nyilvánvaló elõnye csupán annyi,
	    hogy az alaprendszer része.</para>

	  <programlisting>
.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100
</programlisting>

      </sect3>

      <sect3>
	<title>A rendszer elõkészítése az
	  <application>Etherboot</application>
	  számára</title>

	<indexterm><primary>Etherboot</primary></indexterm>

	<para>Az <link xlink:href="http://etherboot.sourceforge.net">Etherboot
	  honlapján </link> találhatunk egy <link xlink:href="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
	  minden részletre kiterjedõ
	  dokumentációt (angolul)</link>, amely
	  elsõsorban ugyan a Linux típusú rendszerek
	  számára íródott, de ettõl
	  függetlenül még hasznos
	  információkat tartalmaz.  A továbbiakban
	  csak annyit szeretnénk körvonalazni, hogy az
	  <application>Etherboot</application> miként
	  bírható mûködésre &os;
	  rendszerekkel.</para>

	<para>Elõször telepítenünk kell a
	  <package>net/etherboot</package> csomagot
	  vagy portot.</para>

	<para>Az <application>Etherboot</application>
	  beállítását (vagyis a
	  <acronym>TFTP</acronym> használatának
	  megadását az <acronym>NFS</acronym> helyett) az
	  <application>Etherboot</application> forrását
	  tartalmazó könyvtárban
	  található <filename>Config</filename>
	  állomány megfelelõ
	  átírásával tudjuk megtenni.</para>

	<para>Itt most floppyról fogjuk indítani a
	  rendszert.  A többi módszerrel (PROM vagy &ms-dos;
	  program) kapcsolatban olvassuk el az
	  <application>Etherboot</application>
	  dokumentációját.</para>

	<para>A rendszerindító lemez
	  elkészítéséhez tegyünk egy
	  lemezt annak a gépnek a meghajtójába,
	  ahová az <application>Etherboot</application>
	  felkerült.  Váltsunk az
	  <application>Etherboot</application>
	  könyvtárán belül az
	  <filename>src</filename> alkönyvtárba és
	  gépeljük be:</para>

	<screen>
&prompt.root; <userinput>gmake bin32/eszköztípus.fd0</userinput>
</screen>

	<para>Az <replaceable>eszköztípus</replaceable> a
	  lemez nélküli munkaállomás Ethernet
	  kártyájától függ.  Az
	  ugyanebben a könyvtárban található
	  <filename>NIC</filename> állományból
	  tudjuk kiolvasni, hogy az adott kártyához melyik
	  <replaceable>eszköztípus</replaceable>
	  tartozik.</para>

      </sect3>

      <sect3>
	<title>A rendszer indítása <acronym>PXE</acronym>
	  használatával</title>

	<para>Alapértelmezés szerint a &man.pxeboot.8;
	  betöltõ a rendszermagot <acronym>NFS</acronym>-en
	  keresztül tölti be.  Ha az
	  <filename>/etc/make.conf</filename> állományban
	  a <literal>LOADER_TFTP_SUPPORT</literal>
	  beállítást adjuk meg, akkor
	  <acronym>TFTP</acronym> támogatással is
	  lefordítható.  Ezzel kapcsolatban a
	  <filename>/usr/share/examples/etc/make.conf</filename>
	  állományban található
	  megjegyzéseket érdemes elolvasnunk.</para>

	<para>A <filename>make.conf</filename> állományban
	  még további két másik hasznos
	  opciót is találhatunk a soros vonali konzollal
	  üzemelõ lemez nélküli gépek
	  számára: az egyik a
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, a másik
	  pedig a <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal>.</para>

	<para>A gép indításakor úgy tudjuk
	  beüzemelni a <acronym>PXE</acronym>
	  használatát, ha a BIOS
	  beállításai között a
	  <literal>Boot from network</literal> opciót
	  választjuk ki, vagy a gép bekapcsolása
	  után lenyomjuk hozzá a megfelelõ
	  funkcióbillentyût.</para>

      </sect3>

      <sect3>
	<title>A <acronym>TFTP</acronym> és
	  <acronym>NFS</acronym> szerverek
	  beállítása</title>

	<indexterm>
	  <primary>TFTP</primary>
	  <secondary>lemez nélküli
	    mûködés</secondary>
	</indexterm>
	<indexterm>
	  <primary>NFS</primary>
	  <secondary>lemez nélküli
	    mûködés</secondary>
	</indexterm>

	<para>Ha a <acronym>PXE</acronym> vagy az
	  <application>Etherboot</application> a <acronym>TFTP</acronym>
	  protokollt használja, akkor az
	  állományszerveren a
	  <application>tftpd</application> démont kell
	  elindítani:</para>

	<procedure>
	  <step>
	    <para>Készítsünk egy
	      könyvtárat, ahonnan majd a
	      <application>tftpd</application> küldi az
	      állományokat, például legyen
	      ez a <filename>/tftpboot</filename>.</para>
	  </step>

	  <step>
	    <para>Vegyük fel a következõ sort az
	      <filename>/etc/inetd.conf</filename>
	      állományunkba:</para>

	    <programlisting>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</programlisting>

	    <note>
	      <para>A tapasztalat szerint egyes <acronym>PXE</acronym>
		verziók a <acronym>TFTP</acronym>
		<acronym>TCP</acronym> alapú
		változatát használják.
		Ebben az esetben vegyünk fel még egy
		második sort is, ahol a <literal>dgram
		udp</literal> részt <literal>stream
		tcp</literal>-re cseréljük.</para>
	    </note>
	  </step>

	  <step>
	    <para>Mondjuk meg az <application>inetd</application>
	      démonnak, hogy olvassa újra a
	      konfigurációs
	      állományát.  Az alábbi parancs
	      megfelelõ mûködéséhez Az
	      <option>inetd_enable="YES"</option> sornak szerepelnie
	      kell az <filename>/etc/rc.conf</filename>
	      állományban:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/inetd restart</userinput></screen>
	  </step>
	</procedure>

	<para>A <filename>tftpboot</filename> könyvtárat
	  bárhova rakhatjuk a szerveren.  Viszont az
	  <filename>inetd.conf</filename> és
	  <filename>dhcpd.conf</filename> állományokban
	  ezt ne felejtsük fel megadni.</para>

	<para>Minden esetben engedélyeznünk kell az
	  <acronym>NFS</acronym> használatát és
	  vele együtt exportálni az <acronym>NFS</acronym>
	  szerverrõl elérni kívánt
	  állományrendszereket.</para>

	<procedure>
	  <step>
	    <para>Az <filename>/etc/rc.conf</filename>
	      állományba tegyük bele a
	      következõt:</para>

	    <programlisting>nfs_server_enable="YES"</programlisting>
	  </step>

	  <step>
	    <para>Az <filename>/etc/exports</filename>
	      állományban a lemez nélküli
	      rendszereknek szánt
	      gyökérkönyvtárat tegyük
	      elérhetõvé (a példában
	      írjuk át a kötet csatlakozási
	      pontját és a <replaceable>margaux
	      corbieres</replaceable> helyére
	      állítsuk be a saját lemez
	      nélküli munkaállomásaink
	      neveit:</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux corbieres</replaceable></programlisting>
	  </step>

	  <step>
	    <para>Kérjük meg a
	      <application>mountd</application> démont, hogy
	      olvassa újra a konfigurációs
	      állományát.  Elõfordulhat
	      azonban, hogy ehhez elõször az
	      <acronym>NFS</acronym> szolgáltatást kell
	      engedélyezni az <filename>/etc/rc.conf</filename>
	      állományból és
	      újraindítani a gépet.</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/mountd restart</userinput></screen>
	  </step>
        </procedure>

      </sect3>

      <sect3>
	<title>Lemez nélküli rendszermag
	  fordítása</title>

	<indexterm>
	  <primary>lemez nélküli
	    mûködés</primary>
	  <secondary>a rendszermag
	    beállításai</secondary>
	</indexterm>

	<para>Ha az <application>Etherboot</application>
	  használata mellett döntünk, akkor a lemez
	  nélküli kliensek számára a
	  rendszermagot a következõ
	  beállítások használatával
	  kell újrafordítani (a megszokottak
	  mellett):</para>

	<programlisting>
options     BOOTP          # BOOTP-n keresztül kérünk IP-címet és hálózati nevet
options     BOOTP_NFSROOT  # a BOOTP-tõl kapott információk alapján csatoljuk a gyökeret NFS-en keresztül
</programlisting>

	<para>Ezek mellett valószínûleg
	  szükségünk lesz a
	  <literal>BOOTP_NFSV3</literal>, <literal>BOOT_COMPAT</literal>
	  és <literal>BOOTP_WIRED_TO</literal>
	  beállítások megadására is
	  (lásd a <filename>NOTES</filename>
	  állományt).</para>

	<para>A beállítások nevei
	  régrõl származnak és némileg
	  félrevezetõek lehetnek, mivel
	  valójában semmit sem változtatnak a
	  rendszermagban levõ <acronym>DHCP</acronym> vagy a BOOTP
	  rutinok használatában (egyébként
	  meg lehet adni vagy az egyik vagy a másik protokoll
	  kizárólágos használatát
	  is).</para>

	<para>Fordítsuk le a rendszermagot (lásd <xref linkend="kernelconfig"/>), és másoljuk a
	  <filename>dhcpd.conf</filename> állományban
	  megadott helyre.</para>

	<note>
	  <para>Amikor a <acronym>PXE</acronym> protokollt
	    használjuk, a rendszermagot nem fontos az
	    imént felsorolt paraméterekkel
	    fordítanunk (habár ajánlatos).  Az
	    engedélyezésükkel több
	    <acronym>DHCP</acronym> kérés keletkezik a
	    rendszermag elindulása közben, ezért
	    kisebb a kockázata annak, hogy a &man.pxeboot.8;
	    által bizonyos esetekben megszerzett és az
	    új értékek között valamilyen
	    ellentmondás jön létre.  A
	    használatuk egyik elõnye, hogy így
	    mellékhatásként a
	    hálózati nevünket is megkapjuk.
	    Ellenkezõ esetben erre is találnunk kellene
	    valamilyen módot, például fenntartani
	    egy-egy <filename>rc.conf</filename> állományt
	    minden kliensen.</para>
	</note>

	<note>
	  <para>Az <application>Etherboot</application> csak akkor lesz
	    képes betölteni a rendszermagot, ha device
	    hinteket is beépítünk.  Ezt a
	    következõ beállítással tudjuk
	    megoldani (errõl bõvebben lásd a
	    <filename>NOTES</filename> állomány
	    megjegyzéseit):</para>

	  <programlisting>hints		"GENERIC.hints"</programlisting>
	</note>

      </sect3>

      <sect3>
	<title>A rendszerindító
	  állományrendszer
	  elõkészítése</title>

	<indexterm>
	  <primary>rendszerindító
	    állományrendszer</primary>
	  <secondary>lemez nélküli
	    mûködés</secondary>
	</indexterm>

	<para>A <filename>dhcpd.conf</filename> állomány
	  <literal>root-path</literal>
	  beállításának megfelelõen
	  hozzunk létre a rendszer
	  indítására alkalmas gyökér
	  állományrendszert.</para>

	<sect4>
	  <title>Az állományrendszer
	    feltöltése a <command>make world</command>
	    paranccsal</title>

	  <para>Ezzel a módszerrel a <envar>DESTDIR</envar>
	    könyvtárba pillanatok alatt telepíteni
	    tudunk egy teljes szûz rendszert (és nem csak a
	    rendszerindító
	    állományrendszert).  Ehhez mindössze csak
	    annyit kell tenni, hogy lefuttatjuk a következõ
	    szkriptet:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Miután végzett, már csak a
	    <envar>DESTDIR</envar> könyvtárban
	    található <filename>/etc/rc.conf</filename>
	    és <filename>/etc/fstab</filename>
	    állományokat kell az igényeinkhez
	    igazítani.</para>

	</sect4>
      </sect3>

      <sect3>
	<title>A lapozóterület
	  beállítása</title>

	<para>Amennyiben szükséges, a szerveren
	  található lapozóállományt
	  <acronym>NFS</acronym>-en keresztül el tudjuk
	  érni.</para>

	<sect4>
	  <title>Lapozás <acronym>NFS</acronym>-sel</title>

	  <para>A rendszermag maga nem támogatja az
	    <acronym>NFS</acronym> alapú lapozás
	    engedélyezését a rendszer
	    indításakor.  A
	    lapozóállományt ezért a
	    rendszerindító szkripteken keresztül
	    aktiváljuk, amelyekben csatlakoztatunk egy
	    írható állományrendszert, ahol
	    létrehozzuk és engedélyezzük a
	    lapozóállományt.  Tetszõleges
	    méretû lapozóállományt
	    például így tudunk
	    készíteni:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/a/lapozóállomány/helye bs=1k count=1 oseek=100000</userinput></screen>

	  <para>Az engedélyezéséhez pedig a
	    következõ sort kell felvenni az
	    <filename>rc.conf</filename>
	    állományba:</para>

	  <programlisting>swapfile=<replaceable>/a/lapozóállomány/helye</replaceable></programlisting>

	</sect4>
      </sect3>

      <sect3>
	<title>Egyéb problémák</title>

	<sect4>
	  <title>Írásvédett
	    <filename>/usr</filename> használata</title>

	  <indexterm>
	    <primary>lemez nélküli
	      mûködés</primary>
	    <secondary>írásvédett /usr</secondary>
	  </indexterm>

	    <para>Ha a lemez nélküli
	      munkaállomáson X szervert akarunk futtatni,
	      akkor az <application>XDM</application>
	      konfigurációs állományait
	      kicsit módosítanunk kell, mert
	      alapértelmezés szerint a
	      <filename>/usr</filename> könyvtárban hozza
	      létre a naplókat.</para>

	</sect4>

	<sect4>
	  <title>Nem &os;-s szerver használata</title>

	  <para>Amikor a rendszer indításához
	    használt állományrendszert nem egy &os;
	    alapú számítógépen
	    tároljuk, akkor elõször ezt egy &os;-s
	    gépen kell elkészíteni, majd a
	    <command>tar</command> vagy <command>cpio</command>
	    segítségével átmásolni a
	    megfelelõ helyre.</para>

	  <para>Ilyen helyzetekben gyakran gondok adódhatnak
	    olyan speciális állományokkal, mint
	    például amelyek a <filename>/dev</filename>
	    könyvtárban találhatóak, mivel a
	    fõ- és aleszközazonosítók
	    tárolására szánt méret
	    különbözhet.  Ezt úgy oldhatjuk meg,
	    ha exportálunk egy könyvtárat a nem &os;
	    alapú szerveren, ezt csatlakoztatjuk a &os;-s
	    gépen, majd a &man.devfs.5;
	    segítségével a
	    eszközleírókat a
	    felhasználó számára
	    észrevétlen módon foglaljuk le.</para>

	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="network-isdn">
    <title>ISDN</title>

    <indexterm><primary>ISDN</primary></indexterm>

    <para>Az ISDN technológiai és hardveres
      hátterérõl sokat megtudhatunk <link xlink:href="http://www.alumni.caltech.edu/~dank/isdn/">Dan Kegel
      ISDN-rõl szóló oldalán
      (angolul)</link>.</para>

    <para>Az ISDN használatát röviden így
      foglalhatnánk össze:</para>

    <itemizedlist>
      <listitem>
	<para>Ha Európában élünk, akkor minden
	  bizonnyal az ISDN kártyákkal foglalkozó
	  szakaszt érdemes elolvasnunk.</para>
      </listitem>

      <listitem>
	<para>Ha elsõsorban betárcsázós
	  ISDN-nel szeretnénk csatlakozni az internetre egy
	  internet-szolgáltatón keresztül, akkor a
	  terminál adaptereket tárgyaló szakaszt
	  nézzük meg.  A szolgáltatók
	  váltásakor ezzel jár a legtöbb
	  rugalmasság és a legkevesebb
	  probléma.</para>
      </listitem>

      <listitem>
	<para>Ha két helyi hálózat
	  összekötésére használjuk, vagy
	  az internethez egy bérelt ISDN vonalon keresztül
	  kapcsolódunk, akkor egy önálló
	  útválasztó vagy hálózati
	  híd beállításában
	  érdemes gondolkodnunk.</para>
      </listitem>
    </itemizedlist>

    <para>A költség fontos szerepet játszik az
      elfogadható megoldás
      kiválasztásában.  A most következõ
      lehetõségeket a legolcsóbbtól indulva
      kezdjük el felsorolni egészen a
      legdrágábbig.</para>

    <sect2 xml:id="network-isdn-cards">
      <info><title>ISDN kártyák</title>
	<authorgroup>
	  <author><personname><firstname>Hellmuth</firstname><surname>Michaelis</surname></personname><contrib>Készítette: </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>ISDN</primary>
	<secondary>kártyák</secondary>
      </indexterm>

      <para>A &os;-ben megtalálható ISDN
	implementáció csak a DSS1/Q.931 (más
	néven Euro-ISDN) szabvány szerint gyártott
	passzív kártyákat támogatja.  Ismer
	azonban egyes olyan aktív kártyákat is,
	amelyeknél a firmware további más
	jelkezelési protokollokat is támogat.  Ilyen
	többek közt az elsõként támogatott
	Primary Rate (PRI) ISDN kártya.</para>

      <para>Az <application>isdn4bsd</application> szoftver
	segítségével kapcsolódni tudunk
	más ISDN útválasztókhoz IP-n
	keresztül a nyers HDLC felett, vagy szinkron PPP
	használatával.  Mindezeket a rendszermagban
	található PPP-re vagy az
	<literal>isppp</literal>-re építkezik.</para>

      <para>&os; alatt egyre több PC-s ISDN kártyához
	készül el a támogatás, és a
	visszajelzések azt mutatják, hogy
	Európában és a világ minden
	részén sikerrel használják
	ezeket.</para>

      <para>A passzív ISDN kártyák közül
	is leginkább az Infineon (korábban Siemens)
	gyártmányú ISAC/HSCX/IPAC ISDN
	chipkészletek támogatottak, de a Cologne chippel
	rendelkezõ (de csak ISA buszos) ISDN kártyák,
	a Winbond W6692 chipes PCI buszos kártyák,
	és a Tiger300/320/ISAC chipkészletek egyes
	változatai, valamint néhány
	gyártófüggõ chipkészlettel
	rendelkezõ kártya, mint például az AVM
	Fritz!Card PCI V.1.0 és az AVM Fritz!Card PnP is
	remekül mûködik.</para>

      <para>Jelenleg a következõ aktív ISDN
	kártyákat támogatja a rendszer: AVM B1 (ISA
	és PCI) BRI kártyák és az AVM T1 PCI
	PRI kártyák.</para>

      <para>Az <application>isdn4bsd</application>
	dokumentációját a rendszerünkön
	belül a <filename>/usr/share/examples/isdn/</filename>
	könyvtárban találhatjuk meg, vagy
	közvetlenül <link xlink:href="http://www.freebsd-support.de/i4b/">az isdn4bsd
	honlapján</link>, ahol több hivatkozást is
	találunk tippekre, hibajegyzékekre és
	bõségesebb dokumentációra,
	például <link xlink:href="http://people.FreeBSD.org/~hm/">az isdn4bsd saját
	kézikönyvére</link>.</para>

      <para>Ha szeretnénk egy másik ISDN protokoll
	támogatásának
	kifejlesztésében résztvenni, vagy egy
	jelenleg még nem támogatott ISDN
	kártyát használhatóvá tenni,
	esetleg valamilyen más módon segíteni az
	<application>isdn4bsd</application> ügyét,
	vegyük fel a kapcsolatot &a.hm; fejlesztõvel.</para>

      <para>Az <application>isdn4bsd</application>
	telepítésével,
	beállításával és
	hibaelhárításával kapcsolatos
	kérdéseinket a &a.isdn.name; levelezési
	listán tehetjük fel.</para>

    </sect2>

    <sect2>
      <title>ISDN terminál adapterek</title>

      <para>Az ISDN számára olyanok a terminál
	adapterek, mint a hagyományos telefonvonalak
	számára a modemek.</para>

      <indexterm><primary>modem</primary></indexterm>

      <para>A legtöbb terminál adapter a Hayes-modemek
	szabványos AT parancskészletét
	használja, és könnyen be lehet iktatni egy
	modem helyett.</para>

      <para>A terminál adapterek alapvetõen ugyanúgy
	mûködnek, mint a modemek, kivéve, hogy egy
	átlagos modemnél jóval nagyobb
	adatátviteli sebességre képesek.
	Ezért a <link linkend="ppp">PPP</link> kapcsolatunkat
	pontosan ugyanúgy kell beállítani, mint a
	modemek esetében.  Ne felejtsük a soros pont
	sebességét a maximális
	értékre állítani.</para>

      <indexterm><primary>PPP</primary></indexterm>

      <para>A terminál adapterek használatának
	egyik legnagyobb elõnye, hogy
	segítségükkel dinamikus PPP-n keresztül
	tudunk az internet-szolgáltatónkhoz
	kapcsolódni.  Mivel az IP-címtartomány
	egyre inkább szûkösebb, a legtöbb
	szolgáltató nem szívesen oszt ki
	bárkinek is statikus IP-címet.  A legtöbb
	önálló útválasztó
	azonban nem képes alkalmazkodni az IP-címek
	dinamikus kiosztásához.</para>

      <para>A terminál adapter az elérhetõ
	lehetõségeket és a kapcsolat
	stabilitását tekintve teljesen a PPP
	démontól függ.  Emiatt egy &os;-s
	gépet könnyû modemrõl
	átállítani az ISDN
	használatára, ha már egyszer
	beállítottuk a PPP démont.  Ezzel
	együtt azonban a PPP használata során
	tapasztalt problémák ugyanúgy ismét
	felmerülnek.</para>

      <para>Ha a maximális stabilitásra van
	szükségünk, akkor a rendszermag <link linkend="ppp">PPP</link> beállítását
	használjuk, és ne a <link linkend="userppp">felhasználói PPP
	megoldást</link>.</para>

      <para>A &os; hivatalosan az alábbi terminál
	adaptereket ismeri:</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola&nbsp;BitSurfer és
	    Bitsurfer&nbsp;Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>Valószínûleg a többi terminál
	adapterrel is képes együttmûködni, mivel a
	terminál adapterek gyártói
	általában igyekeznek a termékeiket a
	szabványos modemes AT parancskészletével
	kompatibilissá tenni.</para>

      <para>Az igazi probléma a külsõ terminál
	adapterekkel adódik, mivel, akárcsak a modemek
	esetében, egy nagyon jó soros
	kártyát igényelnek.</para>

      <para>A soros eszközök
	mûködésének részleteit valamint
	az aszinkron és szinkron soros portok közti
	különbségeket a <link xlink:href="&url.articles.serial-uart.en;/index.html">&os; soros
	hardverekrõl</link> szóló cikkében
	olvashatjuk.</para>

      <para>A terminál adaptereken keresztül
	elérhetõ sebességet a PC-kben
	található szabványos (aszinkron) soros port
	115,2&nbsp;Kb/mp-re korlátozza, még
	128&nbsp;Kb/mp-es adatátvitelû kapcsolatok
	esetében is.  Az ISDN által nyújtott
	128&nbsp;Kb/mp kihasználásához a
	terminál adaptert egy szinkron soros
	kártyával kell összekötnünk.</para>

      <para>Ne higyjük, hogy egy belsõ terminál adapter
	megvásárlásával
	megmenekülünk ettõl a gondtól.  A
	belsõ terminál adapterekbe egyszerûen csak egy
	sima szabványos PC-s soros portot építettek
	bele.  Mindössze egy soros kábelt és egy
	konnektort takarítunk meg velük.</para>

      <para>A terminál adapterhez csatlakozó szinkron
	kártyák legalább olyan gyorsak, mint egy
	önálló útválasztó,
	és egy egyszerû 386-osra épülõ &os;
	rendszerrel talán még rugalmasabban is
	kezelhetõek.</para>

      <para>A terminál adapter plusz szinkron kártya
	kontra önálló útválasztó
	kérdése már
	hitkérdéssé fajult, amirõl igen sokat
	vitatkoztak szerte a levelezési listákon.  A
	teljes okfejtés elolvasásához az <link xlink:href="&url.base;/search/index.html">archívum</link>
	böngészését javasoljuk.</para>

    </sect2>

    <sect2>
      <title>Önálló ISDN hálózati hidak
	és útválasztók</title>

      <indexterm>
	<primary>ISDN</primary>
	<secondary>önálló hálózati
	  hidak és útválasztók</secondary>
      </indexterm>

      <para>Az ISDN hidak vagy útválasztók nem
	egészen a &os; vagy operációs rendszerek
	területéhez tartoznak.  Az
	útválasztás és a
	hálózatok hidak alapjainak a
	számítógépes
	hálózatokról szóló
	szakirodalomban járhatunk utána.</para>

      <para>Ebben a szakaszban a hálózati híd
	és az útválasztó
	kifejezéseket egymás
	szinonímájaként fogjuk
	használni.</para>

      <para>Ahogy az olcsóbb ISDN
	útválasztók és hidak árai
	egyre jobban csökkennek, ezért egyre inkább
	népszerûbbé válnak.  Az ISDN
	útválasztó egy apró doboz, amelyet
	közvetlenül a helyi Ethernet
	hálózatunkra tudunk csatlakoztatni, és a
	többi útválasztóhoz vagy hídhoz
	kapcsolódik.  A benne található szoftverrel
	képes kommunikálni a PPP vagy más
	egyéb népszerû protokollokon
	keresztül.</para>

      <para>Az útválasztó egy szabványos
	terminál adapternél sokkal nagyobb
	adatátvitelt tesz lehetõvé, mivel a teljes
	szinkron ISDN kapcsolatot képes
	kihasználni.</para>

      <para>Az ISDN útválasztókkal és
	hidakkal kapcsolatban az egyik legnagyobb
	problémát a különbözõ
	gyártók közti eltérések
	jelenthetik.  Ha egy szolgáltatóhoz akarunk ezen a
	módon csatlakozni, akkor érdemes elõzetesen
	egyeztetni az igényeinket velük.</para>

      <para>Ha két helyi hálózati szegmenst akarunk
	összekapcsolni, mint például az otthoni
	és az irodai hálózatot, akkor ez a
	megoldás jár a legkevesebb karbantartási
	költséggel.  Mivel ekkor mi magunk
	vásároljuk a kapcsolat mind a két
	oldalára a felszerelést, biztosak lehetünk
	benne, hogy az így létrehozott
	összekötettés mûködni fog.</para>

      <para>Például, ha egy otthon vagy a vállalat
	egy fiókjánál levõ gépet
	akarjuk összekötni az igazgatóság
	hálózatával, akkor a következõ
	felállást érdemes
	követnünk:</para>

      <example>
	<title>Egy otthoni vagy egy fiókbeli
	  hálózat</title>

	<indexterm><primary>10 Base 2</primary></indexterm>

	<para>A hálózat busz
	  topológiájú és 10 Base 2
	  Ethernetet használ (<quote>thinnet</quote>).  Ha
	  szükséges, akkor az
	  útválasztót egy AUI/10BT
	  adó-vevõvel csatlakoztassuk a
	  hálózati kábelre.</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-buse"/>
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">---Sun munkaállomás
|
---&os;
|
---Windows 95
|
az önálló útválasztó
   |
ISDN BRI vonal</literallayout>
          </textobject>

	  <textobject>
	    <phrase>10 Base 2 Ethernet</phrase>
	  </textobject>
	</mediaobject>

	<para>Ha az otthoni vagy fiókbeli
	  számítógép az egyedüli, akkor
	  egy keresztkötésû sodrott érpár
	  kábellel akár közvetlenül is
	  csatlakozhatunk az útválasztóhoz.</para>
      </example>

      <example>
	<title>Az igazgatósági iroda vagy egy másik
	  helyi hálózat</title>

	<indexterm><primary>10 Base T</primary></indexterm>

	<para>A hálózat csillag
	  topológiájú, és 10 Base T Ethernet
	  kábelezésû (<quote>sodrott
	  érpár</quote>).</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-twisted-pair"/>
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">    -------Novell szerver
    | H |
    |   ---Sun
    |   |
    | U ---&os;
    |   |
    |   ---Windows 95
    | B |
    |___---az önálló útválasztó
                |
        ISDN BRI vonal</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>Az ISDN hálózat
	      felépítése</phrase>
	  </textobject>
	</mediaobject>
      </example>

      <para>A legtöbb útválasztó/híd
	elõnye, hogy <emphasis>egyszerre</emphasis> 2
	<emphasis>egymástól független</emphasis> PPP
	kapcsolatot tudunk felépíteni velük 2
	egymástól független géppel.  Ezt a
	legtöbb terminál adapter nem támogatja,
	kivéve azok a (általában drága)
	típusok, amelyek két soros porttal rendelkeznek.
	Ezt ne tévesszük össze a csatornák
	nyalábolásával, az MPP-vel és a
	többivel.</para>

      <para>Ez nagyon hasznos lehet például olyan
	esetekben, amikor van egy dedikált ISDN kapcsolatunk az
	irodában, amelyet ugyan szeretnénk megcsapolni, de
	nem szeretnénk a másik ISDN vonalat is elrabolni.
	Az irodában levõ A útválasztó
	képes a dedikált B csatornájú
	kapcsolaton (64&nbsp;Kb/mp) keresztül elérni az
	internetet, miközben a másik B csatornát
	ettõl független adatkapcsolatra használja.  A
	második B csatorna így használható
	betárcsázásra,
	kitárcsázásra vagy a másik B
	csatornával együtt dinamikus
	nyalábolásra (MPP stb.) a nagyobb
	sávszélesség elérése
	érdekében.</para>

      <indexterm><primary>IPX/SPX</primary></indexterm>

      <para>Az Ethernetes híd nem IP alapú forgalmat is
	képes továbbítani, ezért rajta
	keresztül akár IPX vagy SPX és más
	egyéb protokollokat is használni tudunk.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="network-natd">
    <info><title>Hálózati
      címfordítás</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <sect2 xml:id="network-natoverview">
      <title>Áttekintés</title>

      <indexterm><primary><application>natd</application></primary></indexterm>

      <para>A &os; hálózati
	címfordításért felelõs
	démonprogramja, a &man.natd.8; (Network Address
	Translation daemon), a beérkezõ nyers IP csomagokat
	dolgozza fel, és a helyi gépek
	forráscímét kicserélve
	visszailleszti ezeket a csomagokat a kimenõ folyamba.  A
	&man.natd.8; mindezt úgy teszi a forrás
	IP-címekkel és portokkal, hogy amikor az adat
	visszaérkezik, akkor képes lesz megmondani a
	csomag eredeti küldõjét és
	visszaküldeni neki a választ.</para>

      <indexterm><primary>internet-kapcsolat
	megosztása</primary></indexterm>
      <indexterm><primary>NAT</primary></indexterm>

      <para>A hálózati címfordítást
	általában az internet-kapcsolatok
	megosztásánál alkalmazzuk.</para>

    </sect2>

    <sect2 xml:id="network-natsetup">
      <title>A hálózat
	felépítése</title>

      <para>Az IPv4 világában egyre jobban fogyó
	IP-címek és az egyre növekvõ
	számú, nagysebességre vágyó,
	például kábeles vagy DSL-es
	fogyasztók miatt az igény is egyre nagyobb az
	internet-kapcsolatok megosztására.  Ha több
	számítógéppel szeretnénk
	egyetlen kapcsolaton és egy IP-címen
	keresztül kapcsolódni az internetre, akkor ehhez a
	&man.natd.8; tökéletes
	választás.</para>

      <para>Az esetek többségében a
	felhasználók egy kábeles vagy DSL vonalra
	csatlakoznak, melyhez egyetlen IP-cím tartozik, és
	ezen a gépen keresztül szeretnék
	elérni az internetet a helyi hálózaton
	levõ többi géprõl.</para>

      <para>Ezt úgy tudjuk elérni, ha az internethez
	kapcsolódó &os;-s gépet
	átjárónak állítjuk be.  Ebben
	az átjáróban legalább két
	hálózati felületnek kell léteznie
	&mdash; az egyikkel az internetes
	útválasztóhoz, a másikkal pedig a
	helyi hálózathoz kapcsolódik.  A belsõ
	hálózaton levõ gépek egy hub vagy egy
	switch segítségével csatlakoznak
	egymáshoz.</para>

      <note>
	<para>Több módon is el tudjuk érni a
	  belsõ hálózatról az internetet egy
	  &os;-s átjárón keresztül.  Ebben a
	  példában most csak olyan
	  átjárókkal foglalkozunk, amelyekben
	  legalább két hálózati
	  kártya található.</para>
      </note>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/natd"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| B kliens |-----| Útvál. |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|          |
| A kliens |
|__________|</literallayout>
        </textobject>

	<textobject>
	  <phrase>A hálózat felosztása</phrase>
	</textobject>
      </mediaobject>

      <para>Egy ehhez hasonló beállítás igen
	gyakori a megosztott internet-kapcsolatok esetében.  A
	helyi hálózat egyik gépe csatlakozik az
	internetre.  A többi gép ezen az
	<quote>átjárón</quote> keresztül
	éri el az internetet.</para>
    </sect2>

    <sect2 xml:id="network-netdloaderconfiguration">
      <title>A rendszerbetöltõ
	beállítása</title>

      <indexterm>
	<primary>rendszerbetöltõ</primary>
	<secondary>beállítása</secondary>
      </indexterm>

      <para>A &man.natd.8; mûködéséhez
	szükséges címfordítási
	támogatást a <filename>GENERIC</filename>
	típusú rendszermagok nem tartalmazzák,
	viszont a <filename>/boot/loader.conf</filename> megfelelõ
	paraméterezésével a rendszer
	betöltése közben ezt hozzá tudjuk
	adni:</para>

      <programlisting>ipfw_load="YES"
ipdivert_load="YES"</programlisting>

      <para>Valamint a <varname>net.inet.ip.fw.default_to_accept</varname>
	változót állítsuk az <literal>1</literal> értékre.</para>

      <programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

      <note>
	<para>Ez utóbbi beállítást
	  leginkább a tûzfal és a
	  címfordítást végzõ
	  átjáró
	  próbálgatásakor érdemes
	  alkalmazni.  Ilyenkor ugyanis az &man.ipfw.8;
	  alapértelmezett módon az <literal>allow ip from
	  any to any</literal> (minden forgalom engedélyezett)
	  szabályt követi, és nem pedig a
	  kevésbé barátságos <literal>deny
	  ip from any to any</literal> (minden forgalom tiltott)
	  szabályt.  A rendszer
	  újraindításakor így valamivel
	  nehezebb lesz kizárnunk magunkat a szabályok
	  megadása során.</para>
      </note>
    </sect2>

    <sect2 xml:id="network-natdkernconfiguration">
      <title>A rendszermag beállítása</title>

      <indexterm>
	<primary>rendszermag</primary>
	<secondary>beállítása</secondary>
      </indexterm>

      <para>Amikor viszont nincs lehetõségünk modulok
	használatára, vagy szeretnénk minden
	igényelt funkciót beépíteni a
	rendszermagba, akkor a rendszermag
	beállításait tartalmazó
	állományban a következõket kell
	megadnunk:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>A fentiek mellett még ezeket a
	lehetõségeket tudjuk választani:</para>

      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>
    </sect2>

    <sect2 xml:id="network-natdsystemconfiguration">
      <title>A rendszerindítás
	beállítása</title>

      <para>A tûzfal és a hálózati
	címfordítás
	beindításához a következõknek
	kell az <filename>/etc/rc.conf</filename>
	állományban lennie:</para>

      <programlisting>gateway_enable="YES" <co xml:id="co-natd-gateway-enable"/>
firewall_enable="YES" <co xml:id="co-natd-firewall-enable"/>
firewall_type="OPEN" <co xml:id="co-natd-firewall-type"/>
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>" <co xml:id="co-natd-natd-interface"/>
natd_flags="" <co xml:id="co-natd-natd-flags"/></programlisting>

      <calloutlist>
	<callout arearefs="co-natd-gateway-enable">
	  <para>A gépet átjárónak
	    állítja be.  Hatása megegyezik a
	    <command>sysctl net.inet.ip.forwarding=1</command> parancs
	    kiadásával.</para>
	</callout>

	<callout arearefs="co-natd-firewall-enable">
	  <para>A rendszer indításakor engedélyezi
	    az <filename>/etc/rc.firewall</filename>
	    állományban szereplõ
	    tûzfalszabályok
	    használatát.</para>
	</callout>

	<callout arearefs="co-natd-firewall-type">
	  <para>Egy olyan elõre definiált tûzfalat ad
	    meg, amely alapból mindent beenged.  Az
	    <filename>/etc/rc.firewall</filename>
	    állományban találhatjuk a többi
	    típust.</para>
	</callout>

	<callout arearefs="co-natd-natd-interface">
	  <para>Megadja, hogy melyik felületen
	    továbbítsunk csomagokat az internet
	    felé (ez a felület csatlakozik az
	    internetre).</para>
	</callout>

	<callout arearefs="co-natd-natd-flags">
	  <para>Itt szerepel minden további paraméter,
	    amelyet még az indításkor át
	    kell adnunk a &man.natd.8; démonnak.</para>
	</callout>
      </calloutlist>

      <para>Amikor megadjuk ezeket a beállításokat
	az <filename>/etc/rc.conf</filename> állományban,
	pontosan ugyanaz történik, mintha a <command>natd
	-interface fxp0</command> parancsot adtunk volna ki a rendszer
	indításakor.  Ez tehát manuálisan is
	elindítható.</para>

      <note>
	<para>Ha túlságosan sok paramétert akarunk
	  egyszerre beállítani &man.natd.8;
	  használatához, akkor akár egy
	  külön konfigurációs
	  állományt is megadhatunk.  Ebben az esetben a
	  konfigurációs állományt a
	  következõ módon kell megjelölni az
	  <filename>/etc/rc.conf</filename>
	  állományban:</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<para>Ekkor a <filename>/etc/natd.conf</filename>
	  állomány fogja tartalmazni a
	  beállításokat, soronként egyet.
	  Például a következõ szakaszban ez lesz
	  a tartalma:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>A konfigurációs
	  állományról és az
	  <option>-f</option> opció használatával
	  kapcsolatban olvassuk el a &man.natd.8; man
	  oldalát.</para>
      </note>

      <para>A helyi hálózaton mindegyik gépnek az
	<link xlink:href="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC&nbsp;1918</link>
	által megadott privát IP-címterekbõl
	származó címet kell használnia,
	és az alapértelmezett
	átjárónak mindenhol a
	<application>natd</application> démont futtató
	gép IP-címét kell megadni.</para>

      <para>Például a belsõ hálózaton
	található <systemitem>A</systemitem> és
	<systemitem>B</systemitem> kliensek IP-címei rendre <systemitem class="ipaddress">192.168.0.2</systemitem> és <systemitem class="ipaddress">192.168.0.3</systemitem>, míg a &man.natd.8;
	démont futtató gép belsõ címe
	<systemitem class="ipaddress">192.168.0.1</systemitem>.  Az
	<systemitem>A</systemitem> és a <systemitem>B</systemitem> kliens
	alapértelmezett átjáróját a
	<application>natd</application> gépre, vagyis a <systemitem class="ipaddress">192.168.0.1</systemitem> címre kell
	beállítanunk.  A <application>natd</application>
	gép külsõ, avagy internetes felülete
	semmilyen további módosítást nem
	igényel a &man.natd.8;
	mûködéséhez.</para>

    </sect2>

    <sect2 xml:id="network-natdport-redirection">
      <title>A portok átirányítása</title>

      <para>A &man.natd.8; alkalmazásának
	hátránya, hogy a belsõ
	hálózatra csatlakozó kliensek az
	internetrõl nem érhetõek el.  Tehát a
	helyi hálózat kliensei képesek
	elérni a külvilágot, de az visszafelé
	már nem igaz.  Ez akkor jelent igazából
	problémát, ha az egyik belsõ kliensen
	szolgáltatásokat akarunk futtatni.  A
	probléma egyik egyszerû megoldása, ha a
	<application>natd</application> használatával az
	internet felõl egyszerûen
	átirányítunk bizonyos portokat a
	megfelelõ belsõ kliensre.</para>

      <para>Például tegyük fel, hogy az
	<systemitem>A</systemitem> kliens egy IRC szervert, míg a
	<systemitem>B</systemitem> kliens egy webszervert futtat.  Ez akkor fog
	mûködni, ha a szolgáltatásokhoz
	tartozó 6667 (IRC) és 80 (web) portokat
	átirányítjuk a hozzájuk
	tartozó gépek felé.</para>

      <para>Ehhez a &man.natd.8; démonnak a
	<option>-redirect_port</option> paramétert kell
	átadni.  A pontos felírás így
	néz ki:</para>

      <programlisting>     -redirect_port <replaceable>protokoll</replaceable> <replaceable>célIP</replaceable>:<replaceable>célPORT</replaceable>[-<replaceable>célPORT</replaceable>]
                 [<replaceable>külsõIP</replaceable>:]<replaceable>külsõPORT</replaceable>[-<replaceable>külsõPORT</replaceable>]
                 [<replaceable>távoliIP</replaceable>[:<replaceable>távoliPORT</replaceable>[-<replaceable>távoliPORT</replaceable>]]]</programlisting>

      <para>A fenti példában tehát ezt kell
	megadnunk:</para>

      <programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Így az egyes külsõ <emphasis>tcp</emphasis>
	portokat átirányítjuk a belsõ
	hálózat gépei felé.</para>

      <para>A <option>-redirect_port</option> paraméternek
	akár egész porttartományokat is
	megadhatunk.  Például a <replaceable>tcp
	192.168.0.2:2000-3000 2000-3000</replaceable>
	megadásával az összes 2000-tõl 3000-ig
	terjedõ port csatlakozását
	leképezzük az <systemitem>A</systemitem> kliens 2000
	és 3000 közti portjaira.</para>

      <para>Ezek a beállítások a &man.natd.8;
	közvetlen futtatásakor adhatóak meg, esetleg
	az <filename>/etc/rc.conf</filename> állományban
	az <literal>natd_flags=""</literal> opció keresztül,
	vagy egy külön konfigurációs
	állományban.</para>

      <para>A többi beállítási
	lehetõséget a &man.natd.8; man oldalán
	ismerhetjük meg.</para>

    </sect2>

    <sect2 xml:id="network-natdaddress-redirection">
      <title>A címek
	átirányítása</title>

      <indexterm><primary>címátirányítás</primary></indexterm>

      <para>A címek átirányítása
	abban az esetben hasznos, amikor több IP-cím
	áll rendelkezésünkre, de ezek egy
	géphez tartoznak.  Ilyenkor az &man.natd.8; képes
	a belsõ hálózat egyes gépeihez
	saját külsõ IP-címet rendelni.  A
	&man.natd.8; a belsõ hálózat kliensei
	által küldött csomagokban kicseréli a
	címüket a megfelelõ külsõ
	IP-címmel, illetve az ezekre a címekre
	érkezõ forgalmat továbbítja a
	megfelelõ belsõ kliens irányába.  Ezt a
	megoldást statikus hálózati
	címfordításnak is nevezzük.
	Például a <systemitem class="ipaddress">128.1.1.2</systemitem>
	és a <systemitem class="ipaddress">128.1.1.3</systemitem>
	IP-címek a <application>natd</application> démont
	futtató átjáróhoz tartoznak.  A
	<systemitem class="ipaddress">128.1.1.1</systemitem> cím
	használható a <application>natd</application>
	alapú átjáró külsõ
	IP-címeként, miközben a <systemitem class="ipaddress">128.1.1.2</systemitem> és a <systemitem class="ipaddress">128.1.1.3</systemitem> címeket a belsõ
	hálózaton elérhetõ <systemitem>A</systemitem>
	és <systemitem>B</systemitem> kliensek felé
	közvetítjük.</para>

      <para>A <option>-redirect_address</option> felírása
	tehát a következõ:</para>

      <programlisting>-redirect_address <replaceable>helyiIP</replaceable> <replaceable>publikusIP</replaceable></programlisting>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><replaceable>helyiIP</replaceable></entry>
	      <entry>A helyi hálózaton
		található kliens saját
		IP-címe.</entry>
	    </row>
	    <row>
	      <entry><replaceable>publikusIP</replaceable></entry>
	      <entry>A klienshez tartozó megfelelõ
		külsõ IP-cím.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Az iménti példában a pontos
	paraméterek ezek lesznek:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>A <option>-redirect_port</option> opcióhoz
	hasonlóan ez is megadható az
	<filename>/etc/rc.conf</filename> állományban az
	<literal>natd_flags=""</literal>
	beállításon keresztül vagy egy
	külön konfigurációs
	állományban.  A címek
	átirányításával nincs
	szüksége a portok
	átirányítására, mivel az
	adott IP-címhez tartozó összes forgalmat
	átirányítjuk.</para>

      <para>A <application>natd</application> démont
	futtató gépen a külsõ IP-címeket
	aktiválni kell és a külsõ
	felületéhez kell rendelni.  A &man.rc.conf.5; man
	oldalon járhatunk utána, hogy mindezt hogyan is
	tudjuk megcsinálni.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="network-plip">
    <title>Párhuzamos vonali IP (PLIP)</title>

    <indexterm><primary>PLIP</primary></indexterm>
    <indexterm>
      <primary>párhuzamos vonali IP</primary>
      <see>PLIP</see>
    </indexterm>

    <para>A párhuzamos vonali IP (Parallel Line IP, PLIP) a
      TCP/IP protokoll használatát valósítja
      meg párhuzamos porton keresztül.  Olyan gépek
      számára lehet hasznos, amelyekben nincs
      hálózati kártya, vagy esetleg
      laptopoknál.  Ebben a szakaszban a következõket
      tárgyaljuk:</para>

    <itemizedlist>
      <listitem>
	<para>Párhuzamos (laplink) kábel
	  készítése</para>
      </listitem>

      <listitem>
	<para>Két számítógép
	  összekapcsolása a PLIP
	  segítségével</para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="network-create-parallel-cable">
      <title>Párhuzamos kábel
	készítése</title>

      <para>Párhuzamos kábelt a legtöbb
	számítástechnikai boltban tudunk
	vásárolni.  Ha mégsem tudnánk sehol
	sem beszerezni, vagy egyszerûen tudni szeretnénk,
	hogyan lehet ilyet készíteni, akkor az
	alábbi táblázatban láthatjuk, hogy
	miként tudunk egy hétköznapi
	nyomtatókábelt átalakítani a
	céljainkra.</para>

      <table frame="none">
	<title>A párhuzamos kábel hálózati
	  használatra alkalmas bekötése</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-név</entry>
	      <entry>A-vég</entry>
	      <entry>B-vég</entry>
	      <entry>Leírás</entry>
	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>
	      <entry><literallayout>2
15</literallayout></entry>
	      <entry><literallayout>15
2</literallayout></entry>
	      <entry>Adat</entry>
	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>
	      <entry><literallayout>3
13</literallayout></entry>
	      <entry><literallayout>13
3</literallayout></entry>
	      <entry>Adat</entry>
	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>
	      <entry><literallayout>4
12</literallayout></entry>
	      <entry><literallayout>12
4</literallayout></entry>
	      <entry>Adat</entry>
	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>
	      <entry><literallayout>5
10</literallayout></entry>
	      <entry><literallayout>10
5</literallayout></entry>
	      <entry>Vál. imp.</entry>
	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>
	      <entry><literallayout>6
11</literallayout></entry>
	      <entry><literallayout>11
6</literallayout></entry>
	      <entry>Adat</entry>
	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>
	      <entry>18-25</entry>
	      <entry>18-25</entry>
	      <entry>Föld</entry>
	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 xml:id="network-plip-setup">
      <title>A PLIP beállítása</title>

      <para>Elõször is szereznünk kell valahonnan egy
	laplink kábelt.  Ha ez megvan, akkor mind a két
	gépen ellenõrizzük, hogy a rendszermag
	tartalmazza az &man.lpt.4; meghajtót:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>A párhuzamos portnak megszakítással
	vezéreltnek kell lennie (<quote>interrupt driven</quote>),
	és az <filename>/boot/device.hints</filename>
	állományban szerepelnie kell
	nagyjából a következõ soroknak:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>Ezután nézzük meg, hogy a rendszermag
	beállításait tartalmazó
	állományban megjelenik-e a <literal>device
	plip</literal> sor, vagy a <filename>plip.ko</filename> modul
	betöltõdött-e.  Akármelyik is
	történt, a párhuzamos hálózati
	felület most már a rendelkezésünkre
	áll, és az &man.ifconfig.8; paranccsal ezt meg is
	tudjuk nézni:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>A laplink kábelt csatlakoztassuk mind a két
	számítógéphez.</para>

      <para>Mind a két a hálózati felület
	paramétereit <systemitem class="username">root</systemitem>
	felhasználóként hangoljuk be.
	Például, ha az
	<systemitem><replaceable>egyikgép</replaceable></systemitem>
	nevû gépet akarjuk a
	<systemitem><replaceable>másikgép</replaceable></systemitem>
	nevû géphez csatlakoztatni:</para>

      <programlisting>              <replaceable>egyikgép</replaceable> &lt;-----&gt; <replaceable>másikgép</replaceable>
IP-cím        10.0.0.1      10.0.0.2</programlisting>

      <para>Az
      <systemitem><replaceable>egyikgép</replaceable></systemitem>
	felületét így állítsuk be:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>A
      <systemitem><replaceable>másikgép</replaceable></systemitem>
	felületét így állítsuk be:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>

      <para>Ezt követõen már egy mûködõ
	kapcsolatnak kell felépülnie.  Az egyéb
	részletek kapcsán az &man.lp.4; és az
	&man.lpt.4; man oldalait nézzük át.</para>

      <para>Ezt a két gépet vegyük fel az
	<filename>/etc/hosts</filename> állományba
	is:</para>

      <programlisting>127.0.0.1               <replaceable>localhost.saját.tartomány</replaceable> localhost
10.0.0.1                <replaceable>egyikgép.saját.tartomány egyikgép</replaceable>
10.0.0.2                <replaceable>másikgép.saját.tartomány</replaceable></programlisting>

      <para>A kapcsolat
	mûködõképességérõl
	úgy tudunk meggyõzõdni, ha az egyik
	géprõl megpróbáljuk pingelni a
	másikat.  Például az
	<systemitem><replaceable>egyikgép</replaceable></systemitem>
	esetében:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
<replaceable>másikgép</replaceable>           <replaceable>egyikgép</replaceable>         UH          0       0       plip0
&prompt.root; <userinput>ping -c 4 másikgép</userinput>
PING <replaceable>másikgép</replaceable> (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- <replaceable>másikgép</replaceable> ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>

    </sect2>
  </sect1>

  <sect1 xml:id="network-ipv6">
    <info><title>Az IPv6</title>
      <authorgroup>
	<author><personname><firstname>Aaron</firstname><surname>Kaplan</surname></personname><contrib>Eredetileg írta: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Átszervezte és
	    kiegészítette: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Brad</firstname><surname>Davis</surname></personname><contrib>Tovább bõvítette: </contrib></author>
      </authorgroup>

    </info>

    

    <para>Az IPv6 (másik néven az IPng, vagy a <quote>az
      internet következõ generációs
      protokollja</quote>, <quote>IP next generation</quote>) a
      jól ismert IP protokoll (avagy az <acronym>IPv4</acronym>)
      új változata.  Hasonlóan a jelenleg
      mûködõ összes többi BSD rendszerhez, a
      &os; is tartalmazza a KAME IPv6 referencia
      implementációt.  Ezért ha ezzel
      szeretnénk kísérletezni, akkor ehhez a &os;
      minden eszköz biztosít számunkra.  Ez a szakasz
      az IPv6 beállítását és
      használatát mutatja be.</para>

    <para>Az 1990-es évek elején az IPv4-es
      címterek rohamos mértékû
      kimerülését figyelték meg.  Az internet
      jelenlegi bõvülési üteme mellett két
      nagyobb aggodalomnak adott okot:</para>

    <itemizedlist>
      <listitem>
	<para>A címek elfogyása.  Napjainkban efelõl
	  egyre kevesebb a kétség, mivel az RFC&nbsp;1918
	  által megfogalmazott privát címterek
	  (<systemitem class="ipaddress">10.0.0.0/8</systemitem>, <systemitem class="ipaddress">172.16.0.0/12</systemitem>, és <systemitem class="ipaddress">192.168.0.0/16</systemitem>), valamint a
	  hálózati címfordítás
	  (Network Address Translation, <acronym>NAT</acronym>)
	  használata igen elterjedt.</para>
      </listitem>

      <listitem>
	<para>Az útválasztási
	  táblázatok méretének
	  növekedése.  Ez még manapság is
	  aggasztó.</para>
      </listitem>
    </itemizedlist>

    <para>Az IPv6 ezeket és még más egyéb
      problémákat a következõ módon
      igyekszik megoldani:</para>

    <itemizedlist>
      <listitem>
	<para>A 128&nbsp;bites címtér használata.
	  Más szóval, elméletben összesen
	  340&nbsp;282&nbsp;366&nbsp;920&nbsp;938&nbsp;463&nbsp;463&nbsp;374&nbsp;607&nbsp;431&nbsp;768&nbsp;211&nbsp;456
	  darab címet képes kiosztani.  Ez azt jelenti,
	  hogy bolygónk minden egyes
	  négyzetméterére
	  megközelítõleg 6,67 * 10^27 IPv6
	  típusú cím jut.</para>
      </listitem>

      <listitem>
	<para>Az útválasztók a saját
	  táblázataikban csak a hálózatok
	  összevont címeit tárolják el,
	  ezáltal egy átlagos
	  útválasztási táblázatban
	  található bejegyzések száma 8192
	  alá csökken.</para>
      </listitem>
    </itemizedlist>

    <para>Az IPv6 emellett még rengeteg más
      elõnyös lehetõséget is
      kínál:</para>

    <itemizedlist>
      <listitem>
	<para>A címek automatikus beállítása
	  (lásd <link xlink:href="http://www.ietf.org/rfc/rfc2462.txt">RFC&nbsp;2462</link>)</para>
      </listitem>

      <listitem>
	<para>Anycast (bárkiküldés, vagyis <quote>egy
	  a sokból</quote>)</para>
      </listitem>

      <listitem>
	<para>Kötelezõ (mandatory) multicast</para>
      </listitem>

      <listitem>
	<para>IPsec (IP szintû védelem)</para>
      </listitem>

      <listitem>
	<para>Egyszerûsített fejléc</para>
      </listitem>

      <listitem>
	<para>Mobil <acronym>IP</acronym></para>
      </listitem>

      <listitem>
	<para>IPv6-IPv4 közti
	  átjárhatóság</para>
      </listitem>
    </itemizedlist>

    <para>Ha mindezekrõl többet szeretnénk megtudni,
      akkor erre érdemes továbblépnünk:</para>

    <itemizedlist>
      <listitem>
	<para>Az IPv6 áttekintése a <link xlink:href="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</link>
	  honlapon</para>
      </listitem>

      <listitem>
	<para><link xlink:href="http://www.kame.net">KAME.net</link></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Az IPv6 címek háttere</title>

      <para>Az IPv6 címeknek több típusa
	létezik: a unicast (egyesküldés), az anycast
	(bárkiküldés) és a multicast
	(többesküldés).</para>

      <para>A unicasthez használt címek jól ismert
	címek.  Az így elküldött csomag pontosan
	ahhoz a felülethez érkezik meg, amelyhez az adott
	cím tartozik.</para>

      <para>Az anycasthez használt címek
	felírásukban tökéletesen megegyeznek a
	unicast esetével, de valójában
	felületek egy csoportját címezik.  Az
	anycastre beállított címekre
	küldött csomagok mindig a(z
	útválasztó szerinti) legközelebb
	levõ felülethez érkeznek meg.  Az anycastet az
	útválasztók számára
	találták ki.</para>

      <para>A multicasthez használt címek felületek
	egy csoportját nevezik meg.  A multicast címekre
	érkezõ csomagokat a csoport minden egyes tagja
	megkapja.</para>

	<note>
	  <para>Az IPv4 esetében az
	    üzenetszórásra szánt
	    (általában az <systemitem class="ipaddress">xxx.xxx.xxx.255</systemitem>
	    formátumú) címeket az IPv6
	    esetében multicast címekkel fejezzük
	    ki.</para>
	</note>

      <table frame="none">
	<title>Fenntartott IPv6 címek</title>

	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry>IPv6 cím</entry>
	      <entry>Az elõtag hossza (bitekben)</entry>
	      <entry>Leírás</entry>
	      <entry>Megjegyzés</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><systemitem>::</systemitem></entry>
	      <entry>128&nbsp;bit</entry>
	      <entry>nem specifikált</entry>
	      <entry>Vö.  a <systemitem class="ipaddress">0.0.0.0</systemitem>
		címmel az IPv4 esetében.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::1</systemitem></entry>
	      <entry>128&nbsp;bit</entry>
	      <entry>saját cím</entry>
	      <entry>Vö.  a <systemitem class="ipaddress">127.0.0.1</systemitem> címmel az IPv4
		esetében.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::00:xx:xx:xx:xx</systemitem></entry>
	      <entry>96&nbsp;bit</entry>
	      <entry>IPv4 beágyazása</entry>
	      <entry>Az alsó 32&nbsp;bit egy IPv4
		formátumú cím.  Ezt <quote>IPv4
		kompatibilis IPv6 címnek</quote> is
		nevezik.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::ff:xx:xx:xx:xx</systemitem></entry>
	      <entry>96&nbsp;bit</entry>
	      <entry>IPv4-re leképzett IPv6 címek</entry>
	      <entry>Az alsó 32&nbsp;bit egy IPv4 címet
		jelöl.  Olyan gépeknél
		használatos, amelyek nem támogatják
		az IPv6 protokollt.</entry>
	    </row>

	    <row>
	      <entry><systemitem>fe80::</systemitem> - <systemitem>feb::</systemitem></entry>
	      <entry>10&nbsp;bit</entry>
	      <entry>helyi összeköttetés</entry>
	      <entry>Vö.  az IPv4 loopback címeivel.</entry>
	    </row>

	    <row>
	      <entry><systemitem>fec0::</systemitem> - <systemitem>fef::</systemitem></entry>
	      <entry>10&nbsp;bit</entry>
	      <entry>helyi cím</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><systemitem>ff::</systemitem></entry>
	      <entry>8&nbsp;bit</entry>
	      <entry>multicast</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><systemitem>001</systemitem> (2-es alapú)</entry>
	      <entry>3&nbsp;bit</entry>
	      <entry>globális unicast</entry>
	      <entry>Az összes globális unicast címet
		ebbõl a tartományból osztjuk ki.  Az
		elsõ 3&nbsp;bit
		értéke<quote>001</quote>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2>
      <title>Az IPv6 címek olvasása</title>

      <para>Az IPv6 címek kanonikus formája így
	ábrázolható: <systemitem>x:x:x:x:x:x:x:x</systemitem>, ahol mindegyik
	<quote>x</quote> egy 16&nbsp;bites hexadecimális
	érték.  Például: <systemitem>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</systemitem>.</para>

      <para>Gyakran a címek hosszú nullákból
	álló sorozatokat tartalmaznak, ezért
	mindegyik ilyen sorozatot rövidíteni tudjuk a
	<quote>::</quote> jelöléssel.  Rajtuk
	kívül még az egyes hexadecimális
	csoportokban a bevezetõ nullák is
	elhagyhatóak.  Például az <systemitem>fe80::1</systemitem> cím kanonikus
	formája: <systemitem>fe80:0000:0000:0000:0000:0000:0000:0001</systemitem>.</para>

      <para>A harmadik forma szerint az utolsó 32&nbsp;bites
	részt írjuk fel a megszokott (decimális)
	IPv4 stílusú pontozással, ahol tehát
	a <quote>.</quote> választja el a tagokat.  Így
	például a <systemitem>2002::10.0.0.1</systemitem> felírás a
	<systemitem>2002:0000:0000:0000:0000:0000:0a00:0001</systemitem>
	kanonikus (hexadecimális)
	ábrázolásnak feleltethetõ meg, ami
	pedig egyszerûen <systemitem>2002::a00:1</systemitem> alakban is
	megadható.</para>

      <para>Mostanra már minden bizonnyal a kedves olvasó
	érteni fogja a következõt:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</programlisting>

      <para>A <systemitem>fe80::200:21ff:fe03:8e1%rl0</systemitem> cím
	az automatikusan beállított helyi
	összeköttetés címe.  Ez az automatikus
	beállítás részeként a
	MAC-címbõl jött létre.</para>

      <para>Az IPv6 címek szerkezetérõl
	további részleteket az <link xlink:href="http://www.ietf.org/rfc/rfc3513.txt">RFC&nbsp;3513</link>-ban
	találunk.</para>

    </sect2>

    <sect2>
      <title>Kapcsolódás</title>

      <para>Jelenleg négy módon tudunk más IPv6-os
	géphez és hálózathoz
	csatlakozni:</para>

      <itemizedlist>
	<listitem>
	  <para>Kérjünk a hálózati
	    elérésünkért felelõs
	    illetékesektõl IPv6 alapú
	    hálózatot.  A részletek
	    tekintetében vegyük fel a kapcsolatot az
	    internet-szolgáltatónkkal.</para>
	</listitem>

	<listitem>
	  <para>A <link xlink:href="http://www.sixxs.net">SixXS</link> a
	    világ minden táján kínál
	    végpontokkal rendelkezõ tunneleket.</para>
	</listitem>

	<listitem>
	  <para>Egy 6-ból-4 (<link xlink:href="http://www.ietf.org/rfc/rfc3068.txt">RFC&nbsp;3068</link>)
	    típusú tunnellel.</para>
	</listitem>

	<listitem>
	  <para>Ha betárcsázós kapcsolatunk van,
	    akkor használjuk a <package>net/freenet6</package> portot.</para>
	</listitem>
      </itemizedlist>

    </sect2>

    <sect2>
      <title>A nevek feloldása az IPv6
	világában</title>

      <para>IPv6 alatt régebben két típusa volt a
	nevek feloldásáért felelõs
	rekordoknak.  Az IETF az A6 rekordokat idõközben
	elavultnak nyilvánította.  Ezért
	manapság már az AAAA rekordok tekinthetõek
	szabványosnak.</para>

      <para>Az AAAA rekordok használata magától
	értetõdik.  A hálózati
	nevükhöz az alábbi módon tudunk IPv6
	címet rendelni az elsõdleges zónát
	leíró állományban:</para>

      <programlisting><replaceable>SAJÁTNÉV</replaceable>           AAAA    <replaceable>SAJÁTIPv6CÍM</replaceable></programlisting>

      <para>Ha nem rendelkezünk saját
	névfeloldási zónával, akkor erre
	kérjük meg a névfeloldást
	végzõ szolgáltatónkat.  A
	<application>bind</application> jelenlegi változatai (8.3
	és 9), valamint a <package>dns/djbdns</package> (IPv6
	támogatására vonatkozó
	javítással) támogatják az AAAA
	rekordokat.</para>

    </sect2>

    <sect2>
      <title>Az <filename>/etc/rc.conf</filename> szükséges
	módosításai</title>

      <sect3>
	<title>Az IPv6 kliensek beállításai</title>

	<para>Ezek a beállítások egy helyi
	  hálózaton levõ gépre vonatkoznak,
	  nem pedig egy útválasztóra.  Az
	  &man.rtsol.8; az alábbi megadásával fogja
	  automatikusan beállítani a felületeinket a
	  rendszer indításakor:</para>

	<programlisting>ipv6_enable="YES"</programlisting>

	<para>Ha az <filename>fxp0</filename> felülethez
	  statikusan akarunk IP-címet rendelni,
	  például a <systemitem>
	  2001:471:1f11:251:290:27ff:fee0:2093</systemitem> címet,
	  akkor ehhez a következõt kell megadni:</para>

	<programlisting>ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"</programlisting>

	<para>Az <filename>/etc/rc.conf</filename>
	  állományban az alapértelmezett
	  átjárót a következõ
	  módon tudjuk a <systemitem>2001:471:1f11:251::1</systemitem> címre
	  beállítani:</para>

	<programlisting>ipv6_defaultrouter="2001:471:1f11:251::1"</programlisting>

      </sect3>

      <sect3>
	<title>Az IPv6 útválasztók és
	  átjárók
	  beállítása</title>

	<para>Itt most a tunnelt biztosító
	  szolgáltató által mutatott irányt
	  követjük, és olyan formára
	  alakítjuk, amely megmarad az
	  újraindítás után is.  A rendszer
	  indításakor az <filename>/etc/rc.conf</filename>
	  állományban valami ilyesmit kell megadni a
	  járat
	  visszaállításához:</para>

	<para>Soroljuk fel a beállítandó
	  általános tunnel alapú felületeket,
	  ilyen lehet például a
	  <filename>gif0</filename>:</para>

	<programlisting>gif_interfaces="gif0"</programlisting>

	<para>A felületnek állítsunk be egy helyi
	  végpontot a
	  <replaceable>SAJÁT_IPv4_CÍM</replaceable>
	  megadásával, valamint egy távoli
	  végpontot a
	  <replaceable>TÁVOLI_IPv4_CÍM</replaceable>
	  megadásával:</para>

	<programlisting>gifconfig_gif0="<replaceable>SAJÁT_IPv4_CÍM TÁVOLI_IPv4_CÍM</replaceable>"</programlisting>

	<para>Az IPv6 tunnelünk végpontjához kapott
	  cím aktiválásához az
	  alábbit kell még megadnunk:</para>

	<programlisting>ipv6_ifconfig_gif0="<replaceable>SAJÁT_KAPOTT_IPv6_TUNNEL_VÉGPONTJÁNAK_CÍME</replaceable>"</programlisting>

	<para>Ezután már csak az alapértelmezett
	  útvonalat kell beállítani az IPv6
	  számára.  Ez az IPv6 járat másik
	  oldala:</para>

	<programlisting>ipv6_defaultrouter="<replaceable>SAJÁT_IPv6_TÁVOLI_TUNNEL_VÉGPONTJÁNAK_CÍME</replaceable>"</programlisting>

      </sect3>

      <sect3>
	<title>Az IPv6 tunnel beállításai</title>

	<para>Amennyiben a szerver IPv6 alapú forgalmat
	  közvetít a hálózatunk és a
	  világ között, az
	  <filename>/etc/rc.conf</filename> állományba a
	  következõt kell felvennünk:</para>

	<programlisting>ipv6_gateway_enable="YES"</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Az útválasztók kihirdetése
	és automatikus konfigurációja</title>

      <para>Ebben a szakaszban az &man.rtadvd.8;
	beállításával fogjuk az
	alapértelmezett IPv6 útvonalat kihirdetni.</para>

      <para>Az &man.rtadvd.8; engedélyezéséhez az
	alábbi sort kell betennünk az
	<filename>/etc/rc.conf</filename>
	állományba:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Emellett még fontos megadnunk azt a felületet,
	ahol az IPv6 útválasztó
	kérelmezését végezzük.  Ha erre
	a feladatra például az
	<filename>fxp0</filename> felületet választjuk,
	akkor errõl az &man.rtadvd.8; így
	értesíthetõ:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Most pedig készítenünk kell hozzá
	egy konfigurációt is, vagyis az
	<filename>/etc/rtadvd.conf</filename> állományt.
	Íme erre egy példa:</para>

      <programlisting>fxp0:\
	:addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Az <filename>fxp0</filename> felületet
	természetesen cseréljük ki a
	sajátunkkal.</para>

      <para>Ezután a <systemitem>2001:471:1f11:246::</systemitem> címre
	helyére írjuk be a saját kiosztásunk
	elõtagját.</para>

      <para>Egy egész <systemitem class="netmask">/64</systemitem>
	alhálózat esetén nem is kell többet
	megadni.  Minden más helyezetben az elõtag
	hosszára <literal>prefixlen#</literal> vonatkozó
	értéket is be kell még
	állítanunk.</para>

   </sect2>
  </sect1>

  <sect1 xml:id="network-atm">
    <info><title>Az Aszinkron adatátviteli mód (ATM)</title>
      <authorgroup>
	<author><personname><firstname>Harti</firstname><surname>Brandt</surname></personname><contrib>Készítette: </contrib></author>
      </authorgroup>
    </info>

    

    <sect2>
      <title>A klasszikus IP-címek
	beállítása ATM felett
	(állandó)</title>

      <para>A klasszikus IP ATM felett (Classical IP over ATM,
	<acronym>CLIP</acronym>) a legegyszerûbb módszer az
	IP-címek használatára az Aszinkron
	adatátviteli móddal (Asynchronous Transfer Mode,
	ATM) együtt.  Kapcsolt és állandó
	kapcsolatok (Switched Virtual Channel, SVC és Permanent
	Virtual Channel, PVC) esetén egyaránt
	megfelelõ.  Ebben a szakaszban ez utóbbival fogunk
	foglalkozni.</para>

      <sect3>
	<title>A teljesen hálószerû
	  konfigurációk</title>

	<para>A <acronym>CLIP</acronym>
	  beállítását állandó
	  csatornákon például úgy tudjuk
	  megoldani, ha az összes gépet külön
	  ezekre a célokra szánt állandó
	  csatornákkal összekapcsoljuk egymással.  Ez
	  az egyszerû megoldás azonban nagyobb
	  számú gép esetében már nem
	  eléggé hatékony.  A következõ
	  példában csupán négy gépet
	  kötünk hálózatba, melyik mindegyike
	  egy <acronym role="Asynchronous Transfer Mode">ATM</acronym>
	  kártyával csatlakozik az <acronym role="Asynchronous Transfer Mode">ATM</acronym>
	  hálózatra.  Ehhez elsõként
	  tervezzük meg az IP-címek kiosztását
	  és a gépek közti <acronym role="Asynchronous Transfer Mode">ATM</acronym> kapcsolatokat.
	  A példában ez az alábbiak szerint
	  alakul:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Gép</entry>
		<entry>IP-cím</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>A-gep</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.1</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>B-gep</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.2</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>C-gep</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.3</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>D-gep</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.4</systemitem></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>A teljes hálózat
	  felépítéséhez minden egyes
	  pár között egy-egy ATM kapcsolatra lesz
	  szükségünk:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Gépek</entry>
		<entry>VPI.VCI pár</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>A-gep</systemitem> -
		  <systemitem>B-gep</systemitem></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><systemitem>A-gep</systemitem> -
		  <systemitem>C-gep</systemitem></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><systemitem>A-gep</systemitem> -
		  <systemitem>D-gep</systemitem></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><systemitem>B-gep</systemitem> -
		  <systemitem>C-gep</systemitem></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><systemitem>B-gep</systemitem> -
		  <systemitem>D-gep</systemitem></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><systemitem>C-gep</systemitem> -
		  <systemitem>D-gep</systemitem></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>A kapcsolatok egyes végein szereplõ VPI
	  és VCI értékek természetesen
	  eltérhetnek, de ezeket mi most az
	  egyszerûség kedvéért egyenlõnek
	  tekintettük.  A következõ
	  lépésben minden gépen
	  állítsuk be az ATM felület:</para>

	<screen>A-gep&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
B-gep&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
C-gep&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
D-gep&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

	<para>Ha feltételezzük, hogy minden gépen a
	  <filename>hatm0</filename> az ATM felület neve.  Most
	  pedig az <systemitem>A-gep</systemitem>-en állítsuk be
	  az állandó csatornákat.  (Itt most
	  feltesszük, hogy az ATM switch-eken mindezt már
	  elvégeztük.  A switch
	  kézikönyvében errõl
	  részletesebb leírást is
	  találhatunk.)</para>

	<screen>A-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
A-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
A-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

B-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
B-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
B-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

C-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
C-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
C-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

D-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
D-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
D-gep&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

	<para>Természetesen nem csak UBR
	  használható, hanem minden más olyan
	  forgalmazási beállítás, amit az
	  ATM kártyáink ismernek.  Itt most a forgalmi
	  beállítás nevét a
	  hozzá tartozó konkrét paraméterek
	  követik.  Az &man.atmconfig.8; segédprogram
	  használatához így kérhetünk
	  segítséget:</para>

	<screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

	<para>Olvassuk el az &man.atmconfig.8; man
	  oldalát.</para>

	<para>Ugyanez a beállítás az
	  <filename>/etc/rc.conf</filename> állomány
	  használatával is elvégezhetõ.  Az
	  <systemitem>A-gep</systemitem> esetében mindez így
	  nézne ki:</para>

	<programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="B-gep C-gep D-gep"
route_B-gep="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_C-gep="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_D-gep="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

	<para>A <acronym>CLIP</acronym> útvonalak pillanatnyi
	  állapota így kérdezhetõ le:</para>

	<screen>A-gep&prompt.root; <userinput>atmconfig natm show</userinput></screen>

      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="carp">
    <info><title>A Közös cím redundancia protokoll
      (CARP)</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Írta: </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>CARP</primary></indexterm>
    <indexterm><primary>Közös cím redundancia
      protokoll</primary></indexterm>

    <para>A Közös cím redundancia protokoll (Common
      Address Redundancy Protocol, avagy <acronym>CARP</acronym>)
      segítségével több gép
      képes egyazon <acronym>IP</acronym>-címen osztozni.
      Bizonyos konfigurációkban ez a terhelés
      elosztására
      (terhelés-kiegyenlítésre) vagy a
      rendelkezésre állás
      növelésére (hibatûrésre)
      alkalmazható.  A benne szereplõ gépek
      akár eltérõ <acronym>IP</acronym>-címmel
      is rendelkezhetnek, ahogy azt majd a példában is
      láthatjuk.</para>

    <para>A <acronym>CARP</acronym> támogatásának
      engedélyezéséhez a &os; rendszermagját
      a következõ beállítással kell
      újrafordítanunk:</para>

    <programlisting>device	carp</programlisting>

    <para>A <acronym>CARP</acronym> által biztosított
      lehetõségek ezután már
      elérhetõek, és számos
      <command>sysctl</command> változón keresztül
      állíthatóak:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Változó</entry>
	    <entry>Leírás</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><varname>net.inet.carp.allow</varname></entry>
	    <entry>A beérkezõ <acronym>CARP</acronym>
	      csomagok elfogadása.  Alapértelmezés
	      szerint engedélyezett.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.preempt</varname></entry>
	    <entry>Ezzel a beállítással az adott
	      gépen az összes <acronym>CARP</acronym>
	      felület leáll, ha közülük
	      bármelyik is
	      mûködésképtelenné
	      válik.  Alapértelmezés szerint
	      tiltott.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.log</varname></entry>
	    <entry>A <literal>0</literal> értékkel
	      kikapcsoljuk a naplózást.  Az
	      <literal>1</literal> értékkel a rossz
	      <acronym>CARP</acronym> csomagok
	      naplózását engedélyezzük.
	      Az ettõl nagyobb értékek esetén
	      pedig a <acronym>CARP</acronym> felületek
	      változásait naplózzuk.  Az
	      alapértelmezett értéke az
	      <literal>1</literal>.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.arpbalance</varname></entry>
	    <entry>Az <acronym>ARP</acronym> protokoll
	      segítségével próbálja
	      meg a helyi hálózati forgalmat
	      mentesíteni a terheléstõl.
	      Alapértelmezés szerint tiltott.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.suppress_preempt</varname></entry>
	    <entry>Ez a változó
	      írásvédett, és a
	      megszakítás elnyomásának
	      állapotát mutatja.  A
	      megszakítás elnyomható, ha a
	      felület egyik linkje nem mûködik.  A
	      <literal>0</literal> érték arra utal, hogy a
	      megszakítást nem nyomták el.  Minden
	      probléma növeli ennek a
	      változónak az
	      értékét.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>A <acronym>CARP</acronym> eszközök maguk az
      <command>ifconfig</command> paranccsal
      készíthetõek el:</para>

    <screen>&prompt.root; <userinput>ifconfig carp0 create</userinput></screen>

    <para>Egy valós környezetben az ilyen felületeknek
      egy <acronym>VHID</acronym> néven ismert egyedi
      azonosítóval kell rendelkezniük.  Ez a
      <acronym>VHID</acronym> vagy más néven a
      virtuális gépazonosító (azaz Virtual
      Host Identification) fogja a gépünket a
      hálózat többi elemétõl
      megkülönböztetni.</para>

    <sect2>
      <title>A CARP felhasználása a rendelkezésre
	állás javításában</title>

      <para>A <acronym>CARP</acronym> használatának egyik
	módja, ahogy arra már korábban is utaltunk,
	a szerverek rendelkezésre állásának
	feljavítása.  Ebben a példában
	három géppel fogunk hibatûrést
	biztosítani, melyik mindegyike egyedi
	<acronym>IP</acronym>-címmel rendelkezik és
	ugyanazt a webes tartalmat szolgáltatják.  A
	gépeket egy Round Robin rendszerû
	(körbejáró) névfeloldással
	együtt használjuk.  A tartalék
	gépünknek lesz még további két
	<acronym>CARP</acronym> felülete, külön a szerver
	<acronym>IP</acronym>-címeihez tartozó egyes webes
	tartalmakhoz.  Amikor valami meghibásodik, a
	tartalék szerver átveszi a meghibásodott
	gép <acronym>IP</acronym>-címét.  Ilyenkor
	a hiba teljesen észrevétlen marad a
	felhasználók számára.  A
	tartalék szerveren a többi szerverrel egyezõ
	tartalomnak és szolgáltatásoknak kell
	megjelennie, hogy bármikor át tudja
	tõlük venni a forgalmat.</para>

      <para>A hálózati neveiktõl és a
	virtuális azonosítóiktól eltekintve
	a két gépet ugyanúgy kell
	beállítani.  Ebben a példában a
	gépeket most az <systemitem>a-gep.minta.org</systemitem>
	és <systemitem>b-gep.minta.org</systemitem> nevekkel
	láttuk el.  Elõször is a
	<acronym>CARP</acronym>
	beállításához el kell
	helyeznünk a megfelelõ hivatkozásokat az
	<filename>rc.conf</filename> állományban.  Az
	<systemitem>a-gep.minta.org</systemitem> esetében az
	<filename>rc.conf</filename> állomány a
	következõ sorokat tartalmazza:</para>

      <programlisting>hostname="a-gep.minta.org"
ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"</programlisting>

      <para>Miközben a <systemitem>b-gep.minta.org</systemitem> az
	<filename>rc.conf</filename> állományában
	ezeket adjuk meg:</para>

      <programlisting>hostname="b-gep.minta.org"
ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"</programlisting>

      <note>
	<para>Nagyon fontos, hogy az <command>ifconfig</command> parancs
	  <literal>pass</literal> paraméterével megadott
	  jelszavak megegyezzenek.  A <filename>carp</filename>
	  eszközök csak a megfelelõ jelszót
	  birtokló gépeket fogadják el.  A
	  virtuális gépazonosítónak azonban
	  minden esetben el kell térnie.</para>
      </note>

      <para>A harmadik, <systemitem>szolgaltato.minta.org</systemitem>
	címmel rendelkezõ gépet fogjuk
	felkészíteni az elõbbi gépek
	meghibásodására felkészíteni.
	Ennek a gépnek két <filename>carp</filename>
	eszközre lesz szüksége, melyek az egyes
	gépeket kezelik.  Az ehhez illeszkedõ sorok valahogy
	így fognak kinézni az <filename>rc.conf</filename>
	állományban:</para>

      <programlisting>hostname="szolgaltato.minta.org"
ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"</programlisting>

      <para>Két <filename>carp</filename> eszköz
	használatával a
	<systemitem>szolgaltato.minta.org</systemitem> képes
	észlelni és átvenni bármelyik olyan
	gép <acronym>IP</acronym>-címét, amely nem
	válaszol.</para>

      <note>
	<para>Az alap &os; rendszermag használata esetén
	  <emphasis>elõfordulhat</emphasis>, hogy a
	  megszakítás (a <quote>preemption</quote>
	  opció) engedélyezett.  Amennyiben így
	  lenne, a <systemitem>szolgaltato.minta.org</systemitem> nem fogja
	  minden esetben fogja rendesen visszaadni az
	  <acronym>IP</acronym>-címet az eredeti
	  tulajdonosának.  Ilyenkor a rendszergazdának
	  kell ezt manuálisan megtennie.  Tehát a
	  következõ parancsot kell kiadnia a
	  <systemitem>szolgaltato.minta.org</systemitem> gépen:</para>

	<screen>&prompt.root; <userinput>ifconfig carp0 down &amp;&amp; ifconfig carp0 up</userinput></screen>

	<para>Ezt az adott géphez tartozó
	  <filename>carp</filename> felülettel kell
	  megcsinálni.</para>
      </note>

      <para>Innentõl a <acronym>CARP</acronym> már teljesen
	engedélyezhetõ és készen áll a
	tesztelésre.  A teszteléshez vagy a
	hálózati rendszert kell
	újraindítani, vagy a gépeket.</para>

      <para>További információkat a &man.carp.4;
	man oldalán találhatunk.</para>

    </sect2>
  </sect1>
</chapter>
