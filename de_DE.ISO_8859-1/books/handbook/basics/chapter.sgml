<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     Original version 1.20
     $FreeBSD$
-->

<chapter id="basics">
  <title>Unix Grundlagen</title>
  
  <sect1>
    <title>&Uuml;bersicht</title>

    <para><emphasis>Neugeschrieben von Chris Shumway
      <email>cshumway@cdrom.com</email>, 10 Mar 2000.</emphasis></para>
    <para><emphasis>&Uuml;bersetzt von &a.de.pierau,
      Juni 2000</emphasis></para>

   <para>Das folgende Kapitel umfa&szlig;t die grundlegenden Kommandos
     und Funktionsweisen des Betriebssystems FreeBSD.  Wenn FreeBSD neu
     f&uuml;r Sie ist, dann sollten Sie dieses Kapitel auf jeden Fall
     lesen, bevor Sie um Hilfe fragen.</para>
  </sect1>

  <sect1 id="permissions">
    <title>Zugriffsrechte</title>

    <para>Die Grundlagen von FreeBSD, dessen Geschichte in BSD UNIX 
      begr&uuml;ndet ist, st&uuml;tzen sich auf verschiedene UNIX
      Grundkonzepte.  Das erste und ausgepr&auml;gteste: FreeBSD ist
      ein Multi-User Betriebssystem.  Das System erm&ouml;glicht,
      da&szlig; mehrere User gleichzeitig an v&ouml;llig verschiedenen
      und unabh&auml;ngigen Aufgaben arbeiten k&ouml;nnen. Es ist
      verantwortlich f&uuml;r eine gerechte Auf- und Zuteilung von
      Nachfragen nach Hardware- und Peripherieger&auml;ten, Speicher
      und CPU Zeit unter den Usern.</para>

    <para>Da das System mehere Benutzer unterst&uuml;tzt, hat alles,
      was das System verwaltet, einen Satz von Rechten, die bestimmen, 
      wer die jeweilige Ressource lesen, schreiben oder ausf&uuml;hren 
      darf.  Diese Zugriffsrechte stehen in einer Achtergruppe, die in
      drei Teile unterteilt ist: einen f&uuml;r den Besitzer der
      Datei, einen f&uuml;r die Gruppe¸ zu der die Datei geh&ouml;rt
      und einen f&uuml;r alle anderen.  Die numerische Darstellung
      sieht wie folgt aus:</para>

    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Bei einer ausf&uuml;hrlichen Verzeichnisauflistung mittels
      <command>ls -l</command> zeigt eine Spalte die Zugriffsrechte
      f&uuml;r den Besitzer, die Gruppe und alle anderen an.  Hier
      sieht man, wie das aussehen k&ouml;nnte:</para>

    <screen>-rw-r--r--</screen>

    <para>Das erste Zeichen von links ist ein Sysmbol, welches angibt, 
      ob es sich um eine normale Datei, ein Verzeichnis, ein special-
      oder block-device, ein Socket oder irgend eine andere
      Pseudo-Datei handelt.  Die n&auml;chsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      f&uuml;r den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      geh&ouml;rt.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte f&uuml;r den Rest der Welt an.  Ein Minus
      bedeutet, da&szlig; das Recht nicht gegeben ist.  In diesem Fall
      sind die Zugriffsrechte also: der Eigent&uuml;mer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      k&ouml;nnen auch nur lesen.  Entsprechend obiger Tabelle
      w&auml;ren die Zugriffsrechte f&uuml;r diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffrechte dieser Datei verk&ouml;rpert.</para>

    <para>Das ist alles sch&ouml;n und gut, aber wie kontrolliert das 
      System die Rechte von Hardware Ger&auml;ten?  FreeBSD behandelt
      die meisten Hardware Ger&auml;te als Dateien, welche Programme
      &ouml;ffnen, lesen und mit Daten beschreiben k&ouml;nnen wie
      alle anderen Dateien auch.  Diese Spezial-Dateien sind im
      Verzeichnis <filename>/dev</filename> gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie 
      haben Lese-, Schreib- und Ausf&uuml;hr-Rechte.  Das
      Ausf&uuml;hrungs-Bit hat eine etwas andere Bedeutung f&uuml;r
      ein Verzeichnis als f&uuml;r eine Datei.  Die Ausf&uuml;hrbarkeit 
      eines Verzeichnisses bedeutet, da&szlig; man darin Suchen kann.
      Zum Beispiel kann man sich in diesem Verzeichnis eine Auflistung 
      erstellen.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umst&auml;nden benutzt, wie zum Beispiel bei
      setuid binaries und sticky directories.  Wollen Sie mehr
      &uuml;ber Zugriffsrechte von Dateien erfahren, lesen Sie in die
      &man.chmod.1; Man-Page.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Verzeichnis-Strukturen</title>

    <para>Da FreeBSD seine Dateisysteme nutzt, um viele grundlegende
      Systemt&auml;tigkeiten festzulegen, ist die Hierarchie des
      Dateisystems &auml;u&szlig;erst wichtig.  Durch den Umstand,
      da&szlig; die Man-Page &man.hier.7; eine komplette Beschreibung
      der Verzeichnisstruktur bietet, wird sie hier nicht dupliziert.
      Bitte lesen Sie &man.hier.7; f&uuml;r ausf&uuml;hrlichere
      Informationen.</para>
      
    <para>Von bedeutender Wichtigkeit ist die Wurzel aller
      Verzeichnisse, das / Verzeichnis.  Dieses wird beim booten als 
      erstes gemountet und es enth&auml;lt das Basissystem,
      welches zum boot-Zeitpunkt notwendig ist.  Das / Verzeichnis
      enth&auml;lt au&szlig;erdem mount Punkte (Montierungspunkte)
      f&uuml;r jedes weitere Dateisystem, das Sie mounten
      wollen.</para>

    <para>Ein mount Punkt ist ein Verzeichnis, in das zus&auml;tzliche
      Dateisysteme ins / Verzeichnis eingepflanzt werden k&ouml;nnen.  
      Standard mount Punkte beinhalten <filename>/usr</filename>, 
      <filename>/var</filename>, <filename>/mnt</filename> und 
      <filename>/cdrom</filename>.  Auf diese Verzeichnisse verweisen
      &uuml;blicherweise Eintr&auml;ge in der Datei
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename> ist
      eine Tabelle mit verschiedenen Dateisystemen und mount Punkten
      als Referenz des Systems.  Die meisten der Dateisysteme in 
      <filename>/etc/fstab</filename> werden zur boot Zeit automatisch 
      durch das Skript &man.rc.8; gemountet, wenn die zugeh&ouml;rigen
      Eintr&auml;ge nicht mit der Option <option>noauto</option>
      versehen sind.  Konsultieren Sie die &man.fstab.5; Man-Page
      f&uuml;r mehr Informationen &uuml;ber das Format der Datei
      <filename>/etc/fstab</filename> und den Optionen darin.</para>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>

    <para>Von der tagt&auml;glichen Arbeit mit FreeBSD wird eine Menge
      mit der Kommandozeilen Schnittstelle der Shell erledigt.  Die
      Hauptaufgabe einer Shell besteht darin, Kommandos der Eingabe
      anzunehmen und diese auszuf&uuml;hren.  Viele Shells haben
      au&szlig;erdem eingebaute Funktionen, um die t&auml;gliche
      Arbeit zu erleichtern, wie Dateiverwaltung, Editieren von 
      Kommandozeilen, Makros und Umgebungsvariablen.  FreeBSD 
      enth&auml;lt die Shells sh (die Bourne Shell) und csh 
      (die C-Shell) im Basissystem.  Viele andere sind in der Ports 
      Sammlung zu finden, von denen einige auch leistungsf&auml;higer 
      sind, zum Beispiel tcsh und bash.</para>

    <para>Welche Shell soll ich benutzen?  Das ist wirklich eine
      Geschmacksfrage.  Sind Sie ein C Programmierer, finden Sie
      vielleicht eine C-artige Shell wie die tcsh angenehmer.  Kommen
      Sie von Linux oder Ihnen ist eine UNIX Kommandozeile neu, so
      k&ouml;nnten Sie die bash probieren.  Der Punkt ist, da&szlig;
      jede Shell ihre speziellen Eigenschaften hat, die mit Ihrer
      bevorzugten Arbeitsumgebung harmonieren k&ouml;nnen oder nicht.
      Sie m&uuml;ssen sich eine Shell aussuchen.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollst&auml;ndigung.  Sie m&uuml;ssen nur einige
      Buchstaben eines Kommandos oder eines Dateinames eingeben und
      die Shell vervollst&auml;ndigt den Rest automatisch durch
      dr&uuml;cken der TAB-Taste.  Hier ist ein Beispiel.  Ich habe
      zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Die Datei
      <filename>foo.bar</filename> m&ouml;chte ich l&ouml;schen.  Nun
      w&uuml;rde ich an der Tastatur eingeben: 
      <command>rm fo[TAB].[TAB]</command>.</para>

    <para>Die Shell g&auml;be dann ausgeben <command>rm
      foo[BEEP].bar</command>.</para>

    <para>[BEEP] meint den Rechner-Piepser.  Diesen gibt die Shell
      aus, um anzuzeigen, da&szlig; es den Dateinamen nicht
      vervollst&auml;ndigen konnte, da es mehrere M&ouml;glichkeiten
      gibt.  Beide Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename> beginnen mit <literal>fo</literal>,
      so konnte nur bis <literal>foo</literal> erg&auml;nzt werden.
      Nachdem ich <literal>.</literal> eingab und dann die TAB-Taste
      dr&uuml;ckte, konnte die Shell den Rest f&uuml;r mich 
      ausf&uuml;llen.</para>

    <para>Eine andere Funktion der Shell sind die Umgebungsvariablen.
      Das sind ver&auml;nderbare Schl&uuml;sselpaare im Umgebungsraum
      der Shell.  Diesen Umgebungsraum kann jedes von der Shell
      aufgerufene Programm lesen.  So kommt es, da&szlig; viel
      Programmkonfiguration darin enthalten ist.  Hier eine Liste
      verbreiteter Umgebungsvariablen und was sie bedeuten:</para>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des zur Zeit angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt) 
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Wenn gesetzt der Netzwerkname des X11 Bildschirms
              f&uuml;r die Anzeige.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminals des Benutzers.  Benutzt, um die
              F&auml;higkeiten des Terminals bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Kodes,
              ben&ouml;tigt um verschieden Terminalfunktionen
              auszuf&uuml;hren.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebsystems.  Z.B., FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU Architektur auf dem das System 
              l&auml;uft.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bervorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt) 
              zum Suchen nach Man-Pages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Das Anzeigen oder Setzen von Umgebungsvariablen funktioniert
      von Shell zu Shell unterschiedlich.  Zum Beispiel benutzt man
      in C-artigen Shells wie der tcsh dazu <command>setenv</command>.
      Unter Bourne-Shells wie sh oder bash w&uuml;rde man
      <command>set</command> und <command>export</command> benutzen
      zum ansehen oder setzen von aktuellen Umgebungsvariablen.  Um
      beispielsweise die Variable <envar>EDITOR</envar> zu setzen oder
      zu modifizieren, w&uuml;rde folgendes Kommando die Variable
      <envar>EDITOR</envar> auf 
      <filename>/usr/local/bin/emacs</filename> setzen:</para>

    <para><command>setenv EDITOR /usr/local/bin/emacs</command></para>

    <para>Unter Bourne-Shells:</para>

    <para><command>export EDITOR="/usr/local/bin/emacs"</command></para>

    <para>Sie k&ouml;nnen die meisten Shells Umgebungsvariablen
      expandieren lassen, in dem Sie in der Kommandozeile ein 
      <literal>$</literal> davor eingeben.  Zum Beispiel gibt 
      <command>echo $TERM</command> aus, worauf <envar>$TERM</envar> 
      gesetzt ist, weil die Shell <envar>$TERM</envar> expandiert
      und das Ergebnis an echo gibt.</para>

    <para>Shells behandeln eine Menge an Spezialzeichen, sogenannte
      meta-characters, als besondere Darstellungen f&uuml;r Daten.
      Das allgemeinste ist das Zeichen <literal>*</literal>, das eine
      beliebige Anzahl Zeichen in einem Dateinamen repr&auml;sentiert.
      Das Kommando <command>echo *</command> liefert nahezu das gleiche 
      wie die Eingabe von <command>ls</command>, da die Shell alle
      Dateinamen die mit <command>*</command> &uuml;bereinstimmen an
      echo weitergibt.</para>

    <para>Um zu verhindern, da&szlig; die Shell diese Sonderzeichen
      interpretiert, kann man sie sch&uuml;tzen, indem man ihnen einen
      backslash (<literal>\</literal>) voranstellt.  <command>echo
      $TERM</command> gibt aus, auf was auch immer Ihr Terminal
      gesetzt ist.  <command>echo \$TERM</command> gibt 
      <envar>$TERM</envar> genauso aus, wie es hier steht.</para>

    <sect2 id="changing-shells">
      <title>&Auml;ndern der Shell</title>

      <para>Der einfachste Weg Ihre Shell zu &auml;ndern, ist das
        Kommando <command>chsh</command> zu benutzen.  
        <command>chsh</command> platziert Sie im Editor, welcher durch
        Ihre Umgebungsvariable <envar>EDITOR</envar> gesetzt ist,
        im <command>vi</command> wenn die Variable nicht gesetzt ist.
        &Auml;ndern Sie die Zeile mit <quote>Shell:</quote>
        entsprechend Ihren W&uuml;nschen.</para>

      <para>Sie k&ouml;nnen auch <command>chsh</command> mit der Option
	<option>-s</option> aufrufen, dann wird Ihre Shell gesetzt,
        ohne das&szlig; Sie in einen Editor gelangen.  Um Ihre Shell
        zum Beispiel auf die bash zu &auml;ndern, geben Sie das
        folgende Kommando ein:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Einfach <command>chsh</command> ohne Optionen und mit
        Editieren der entsprechenden Zeile w&uuml;rde auch
        funktionieren.</para>

      <note>
	<para>Die von Ihnen gew&uuml;nschte Shell 
          <emphasis>mu&szlig;</emphasis> in <filename>/etc/shells</filename> 
          aufgef&uuml;hrt sein.  Haben Sie eine Shell aus der
	  <!--<link linkend="ports">-->Ports Sammlung<!--</link>--> installiert,
          sollte das schon automatisch erledigt werden.  Installierten
          Sie die Shell von Hand, so m&uuml;ssen Sie sie dort
          eintragen.</para>
     
      <para>Haben Sie beispielsweise die <command>bash</command> nach
	<filename>/usr/local/bin</filename> installiert, wollen Sie
        dies tun:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach <command>chsh</command> aufrufen.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text Editoren</title>

    <para>Eine Menge der Konfiguration bei FreeBSD wird durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  FreeBSD hat
      ein paar davon im Basissystem und sehr viel mehr in der Ports
      Sammlung.</para>

    <para>Der am leichtesten und einfachsten zu erlernende Editor nennt
      sich <application>ee</application>, was f&uuml;r easy editor steht.
      Um <application>ee</application> zu starten, gibt man in der
      Kommandozeile <command>ee filename</command> ein, worin
      <literal>filename</literal> der Name der zu editierenden Datei
      ist.  Um zum Beispiel <filename>/etc/rc.conf</filename> zu
      editieren, tippen Sie <command>ee /etc/rc.conf</command>.
      Einmal im Editor, finden Sie alle Editor-Funktionen oben im
      Display aufgelistet.  Das Einschaltungszeichen 
      <literal>^</literal> meint die Control (oft Steuerung) Taste,
      also ^e hei&szlig;t, da&szlig; die Controltaste und dann der
      Buchstabe <literal>e</literal> gedr&uuml;ckt werden.  Um
      <application>ee</application> zu verlassen, einfach die
      Escapetaste dr&uuml;cken und leave editor w&auml;hlen.  Der
      Editor fragt Sie nach, ob Sie speichern m&ouml;chten, wenn die
      Datei ver&auml;ndert wurde.</para>

    <para>FreeBSD verf&uuml;gt &uuml;ber leistungf&auml;higere
      Editoren wie <application>vi</application> als Teil des
      Basissystems und <application>emacs</application> oder 
      <application>vim</application> als Teil der Ports Sammlung.
      Diese Editoren bieten h&ouml;here Funktionalit&auml;t und
      Leistungsf&auml;higkeit jedoch auf Kosten einer etwas
      schwierigeren Erlernbarkeit.  Dennoch, wenn Sie viel 
      Textdateien editieren werden, sparen Sie auf lange Sicht mehr
      Zeit ein durch das Erlernen solcher Editoren wie
      <application>vim</application> oder
      <application>emacs</application>.</para>
  </sect1>

  <sect1>
    <title>Weitere Informationen...</title>

    <sect2 id="basics-man">
      <title>Man pages</title>

      <para>Die umfassendste Dokumentation rund um FreeBSD gibt es in
        Form von Man-Pages.  Ann&auml;hrernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grunds&auml;tzliche Funktion und verschiedene Parameter 
        erkl&auml;rt.  Diese Dokumentationen kann man mit dem 
        <command>man</command> Kommando benutzen.  Die Benutzung des 
        <command>man</command> Kommandos ist einfach:</para>

      <para><command>&prompt.user; man Kommando</command></para>

      <para><literal>Kommando</literal> ist der Name des Kommandos,
        &uuml;ber das Sie etwas erfahren wollen. Um beispielsweise
        mehr &uuml;ber das Kommando <command>ls</command> zu lernen,
        geben Sie ein:</para>

      <para><command>&prompt.user; man ls</command></para>

      <para>Die Online-Dokumentation ist in numerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothkene.</para>
	</listitem>

	<listitem>
	  <para>Ger&auml;tetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen F&auml;llen kann dasselbe Thema in mehreren
        Sektionen auftauchen.  Es gibt zum Beispiel ein chmod
        Benutzerkommando und ein <literal>chmod()</literal>
        Systemaufruf.  In diesem Fall k&ouml;nnen Sie dem man Kommando
        sagen, aus welcher Sektion Sie die Information erhalten
        m&ouml;chten, indem Sie die Sektion mit angeben:</para>

      <para><command>&prompt.user; man 1 chmod</command></para>

      <para>Dies wird Ihnen die Man-Page f&uuml;r das Benutzerkommando
        <command>chmod</command> zeigen.  Verweise auf eine Sektion
        der Man-Pages werden traditionsgem&auml;&szlig; in Klammern
        gesetzt.  So nezieht sich &man.chmod.1; auf das
        Benutzerkommando <command>chmod</command> und mit
        &man.chmod.2; ist der Systemaufruf gemeint.</para>

      <para>Das ist nett, wenn Sie den Namen eines Kommandos wissen,
        und lediglich wissen wollen, wie es zu benutzen ist. Aber was
        tun Sie, wenn Sie Sich nicht an den Namen des Kommandos
        erinnern k&ouml;nnen?  Sie k&ouml;nnen man benutzen, um nach
        Schl&uuml;sselbegriffen in den Kommandobeschreibungen zu
        suchen, indem Sie den Parameter <option>-k</option>
        benutzen:</para>

      <para><command>&prompt.user; man -k mail</command></para>

      <para> Mit diesem Kommando bekommen Sie eine Liste der
        Kommandos, deren Beschreibung das Schl&uuml;sselwort
        <quote>mail</quote> enth&auml;lt.  Diese Funktionalit&auml;t
        erhalten Sie auch, wenn Sie das Kommando apropos
        benutzen.</para>

      <para>Nun, Sie schauen Sich alle die geheimnisvollen Kommandos
        in <filename>/usr/bin</filename> an, haben aber nicht den
        blassesten Schimmer, wozu die meisten davon gut sind?  Dann
        geben Sie doch einfach <command>&prompt.user; cd /usr/bin; 
        man -f *</command> oder <command>&prompt.user; cd /usr/bin; 
        whatis *</command> ein, beides tut dasselbe.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Dateien</title>

      <para>FreeBSD enth&auml;lt viele Applikationen und Utilities
        der Free Software Foundation (FSF).  Zus&auml;tzlich zu den
        Man-Pages bringen diese Programme ausf&uuml;hrlichere
        Hypertext-Dokumente (<literal>info</literal> genannt) mit, 
        welche man sich mit dem Kommando <command>info</command>
        ansehen kann.  Wenn Sie <application>emacs</application>
        installiert haben, k&ouml;nnen Sie auch dessen info-Modus
        benutzen.</para>

      <para>Um das Kommando &man.info.1; zu benutzen, geben Sie
        einfach ein:</para>

      <para><command>&prompt.user; info</command></para>

      <para>Eine kurze Einf&uuml;rung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

