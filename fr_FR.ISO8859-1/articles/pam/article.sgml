<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN"> %man;
<!ENTITY % urls PUBLIC "-//FreeBSD//ENTITIES Common Document URL Entities//FR"> %urls;
<!ENTITY % abstract PUBLIC "-//FreeBSD//ENTITIES DocBook Abstract Entities//FR"> %abstract;
<!ENTITY % artheader PUBLIC "-//FreeBSD//ENTITIES DocBook ArtHeader Entities//FR"> %artheader;
<!ENTITY % translators PUBLIC "-//FreeBSD//ENTITIES DocBook Translator Entities//FR"> %translators;
 
<!ENTITY % authors PUBLIC "-//FreeBSD//ENTITIES DocBook Author Entities//EN"> %authors;
<!ENTITY % mailing-lists PUBLIC "-//FreeBSD//ENTITIES DocBook Mailing List Entities//FR"> %mailing-lists;
<!ENTITY rel.current CDATA "3.2">
]>

<!--
  - Copyright (c) 2001-2003 Networks Associates Technology, Inc.
  - All rights reserved.
  -
  - This software was developed for the FreeBSD Project by ThinkSec AS and
  - Network Associates Laboratories, the Security Research Division of
  - Network Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
  - ("CBOSS"), as part of the DARPA CHATS research program.
  -
  - Redistribution and use in source and binary forms, with or without
  - modification, are permitted provided that the following conditions
  - are met:
  - 1. Redistributions of source code must retain the above copyright
  -    notice, this list of conditions and the following disclaimer.
  - 2. Redistributions in binary form must reproduce the above copyright
  -    notice, this list of conditions and the following disclaimer in the
  -    documentation and/or other materials provided with the distribution.
  - 3. The name of the author may not be used to endorse or promote
  -    products derived from this software without specific prior written
  -    permission.
  -
  - THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
  - ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  - IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  - ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  - FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  - DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  - OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  - HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  - LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  - OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  - SUCH DAMAGE.
  -->

<article>
  <articleinfo>
    <title>Pluggable Authentication Modules</title>

    <pubdate>$FreeBSD$</pubdate>

    <abstract>
      <para>Cet  article  décrit  les  principes sous-jacent  et  les
      mécanismes  de   la  bibliothèque  PAM,   il  explique  comment
      configurer PAM,  l'intégrer dans  les applications, et
      écrire ses propres modules PAM.</para>

	  &trans.a.mathieu;
    </abstract>

    <copyright>
      <year>2001</year>
      <year>2002</year>
      <year>2003</year>
      <holder>Networks Associates Technology, Inc.</holder>
    </copyright>

    <authorgroup>
      <author>
	<firstname>Dag-Erling</firstname>
	<surname>Sm&oslash;rgrav</surname>
	<contrib>Contributed by </contrib>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Cet  article  a  été  écrit  pour le  Projet  FreeBSD  par
      ThinkSec  AS et  les laboratoires  de Networks  Associates,  la
      division de  recherche en  sécurité de Networks  Associates, Inc.
      sous      le      contrat     DARPA/SPAWAR      N66001-01-C-8035
      (<quote>CBOSS</quote>),  en  tant  que  partie du  programme  de
      recherche DARPA CHATS.</para>
    </legalnotice>
  </articleinfo>

  <section id="pam-intro">
    <title id="pam-intro.title">Introduction</title>

	 <para>La  bibliothèque  PAM  est  une  API  généralisée  pour  les
	 services   relevant  de   l'authentification  permettant   à  un
	 administrateur    système   d'ajouter    une    nouvelle   méthode
	 d'authentification en  ajoutant simplement un  nouveau module PAM,
	 ainsi que de  modifier  les  règles d'authentification  en  éditant  les
	 fichiers de configuration.</para>

	 <para>PAM  a été conçu  et développé  en 1995  par Vipin  Samar et
	 Charlie  Lai  de Sun  Microsystems,  et  n'a  pas beaucoup  évolué
	 depuis. En  1997 l'Open Group publie  les premières spécifications
	 XSSO  qui standardisent  l'API  PAM et  ajoute  des extensions  pour
	 un simple (ou plutot intégré) &quot;sign-on&quot;.  Lors  de l'écriture de  cet article, la  spécification n'a
	 toujours pas été adoptée comme standard.</para>

	 <para>Bien  que  cet  article  se  concentre  principalement  sur
	 FreeBSD  5.x,  qui  utilise  OpenPAM, il  devrait  également  être
	 applicable  à FreeBSD 4.x  qui utilise  Linux-PAM, ainsi qu'à d'autres
	 systèmes d'exploitations tels que Linux ou Solaris.</para>

    <section id="pam-trademarks">
      <title id="pam-trademarks.title">Marques déposées</title>

      <para>Sun, Sun Microsystems, SunOS and Solaris are trademarks or
	registered trademarks of Sun Microsystems, Inc.</para>

      <para>UNIX and The Open Group are trademarks or registered
	trademarks of The Open Group.</para>

      <para>All other brand or product names mentioned in this
	document may be trademarks or registered trademarks of their
	respective owners.</para>
    </section>
  </section>

  <section id="pam-terms">
    <title id="pam-terms.title">Termes et conventions</title>

    <section id="pam-definitions">
      <title id="pam-definitions.title">Définitions</title>


		<para>La  terminologie   de  PAM  est  plutôt   confuse.  Ni  la
		publication originale  de Samar et Lai, ni  la spécification XSSO
		n'ont essayé de définir formellement des termes pour les acteurs
		et  les  entités intervenant  dans  PAM, les termes  qu'ils
		utilisent (mais  ne définissent  pas) sont parfois  trompeurs et
		ambigus.   Le   premier   essai  d'établir   une   terminologie
		consistante  et  non ambiguë  fut  un  papier  écrit par  Andrew
		G. Morgan (l'auteur de Linux-PAM) en 1999. Bien que les choix de
		Morgan furent  un énorme  pas en avant,  ils ne sont  pas parfait
		d'après  l'auteur de  ce  document.  Ce qui  suit,
		largement  inspiré par  Morgan, est un  essai de  définir précisément  et sans
		ambiguïté des termes pour  chaque acteur ou entité utilisé dans
		PAM.</para>

      <glosslist>
	<glossentry>
	  <glossterm>compte</glossterm>
	  <glossdef>
	    <para>L'ensemble  de  permissions  que  le demandeur  demande  a
	 	l'arbitre.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>demandeur</glossterm>
	  <glossdef>
	    <para>L'utilisateur         ou        l'entité        demandant
	    authentification.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>arbitre</glossterm>
	  <glossdef>
	    <para>L'utilisateur ou l'entité possèdant les privilèges nécessaires
	    pour   vérifier  la  requête   du  demandeur   ainsi que  l'autorité
	    d'accorder ou de rejeter la requête.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>chaîne</glossterm>
	  <glossdef>
	    <para>Une séquence de modules qui sera invoquée pour répondre à
	    une requête  PAM. La chaîne comprend  les informations concernant
	    l'ordre dans lequel invoquer  les modules, les arguments à leur
	    passer et la façon d'interpréter les résultats.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>client</glossterm>
	  <glossdef>
	    <para>L'application      responsable     de      la     requête
	    d'authentification   au   nom   du   demandeur   et   de receuillir
	    l'information d'authentification nécessaire.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>mécanisme</glossterm>
	  <glossdef>
	    <para>Il  s'agit  de  l'un  des  quatre  groupes  basiques  de
	    fonctionnalités  fournit par PAM  : authentification,  gestion de
	    compte,   gestion   de   session   et   mise à jour   du   jeton
	    d'authentification.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>module</glossterm>
	  <glossdef>
	    <para>Une collection d'une ou plusieurs fonctions implémentant
	    un  service  d'authentification  particulier,  rassemblées  dans  un
	    fichier binaire (normalement chargeable dynamiquement)
	    et identifié par un nom unique.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>règles</glossterm>
	  <glossdef>
	    <para>Le  jeu  complet  de  configuration  des règles  décrivant
	    comment   traiter   les    requêtes   PAM   pour   un   service
	    particulier. Une règle consiste normalement en quatre chaînes,
	    une   pour  chaque   mécanisme,  bien   que   quelques  services
	    n'utilisent pas les quatre mécanismes.</para>

 </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>serveur</glossterm>
	  <glossdef>
	    <para>L'application agissant au nom de l'arbitre pour converser
	    avec le client,  récupérer les informations d'authentification,
	    vérifier les droits du demandeur et autoriser ou rejeter
	    la requête.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>service</glossterm>
	  <glossdef>
	    <para>Un  ensemble de  serveurs  fournissant des  fonctionnalités
	    similaires  ou   liées  et  nécessitant   une  authentification
	    similaire. Les règles  de PAM sont définies sur  un le principe
	    de par-service;  ainsi tous les serveurs qui  demandent le même
	    nom de service seront soumis aux mêmes règles.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>session</glossterm>
	  <glossdef>
	    <para>Le  contexte  dans  lequel  le  service  est  délivré  au
	    demandeur par le serveur. L'un  des quatre mécanismes de PAM, la
	    gestion  de   session,  s'en occupe   exclusivement  par  la
	    mise en place  et le relâchement  de ce contexte.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>jeton</glossterm>
	  <glossdef>
	    <para>Un morceau d'information associé avec un compte tel qu'un
	    mot de passe  ou une passphrase que le  demandeur doit fournir
	    pour prouver son identité.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>transaction</glossterm>
	  <glossdef>
	    <para>Une séquence de requêtes depuis le même demandeur vers la
	    même    instance    du    même   serveur,    commençant    avec
	    l'authentification  et la  mise en  place de  la session  et se
	    terminant avec le démontage de la session.</para>
	  </glossdef>
	</glossentry>
      </glosslist>
    </section>

    <section id="pam-usage-examples">
      <title id="pam-usage-examples.title"> Exemples d'utilisation</title>

      <para>Cette section  a pour but d'illustrer
      quelques-uns des termes  définis précédemment  à l'aide
      d'exemples basiques.</para>

      <section>
	<title>Client et serveurs ne font qu'un</title>

	<para>Cet exemple  simple montre <literal>alice</literal> utilisant
	&man.su.1; pour devenir <literal>root</literal>.</para>


<screen>&prompt.user; <userinput>whoami</userinput>
alice
&prompt.user; <userinput>ls -l `which su`</userinput>
-r-sr-xr-x  1 root  wheel  10744 Dec  6 19:06 /usr/bin/su
&prompt.user; <userinput>su -</userinput>
Password: <userinput>xi3kiune</userinput>
&prompt.root; whoami
root
</screen>

	<itemizedlist>
	  <listitem>
	    <para>Le demandeur est <literal>alice</literal>.</para>
	  </listitem>
	  <listitem>
	    <para>Le compte est <literal>root</literal>.</para>
	  </listitem>
	  <listitem>
	    <para>Le processus  &man.su.1; est à la fois client et serveur.</para>
	  </listitem>
	  <listitem>
	    <para>Le jeton d'authentification est
	    <literal>xi3kiune</literal>.</para>
	  </listitem>
	  <listitem>
	    <para>L'arbitre  est <literal>root</literal>,  ce  qui explique
		   pourquoi            &man.su.1;           est           setuid
		   <literal>root</literal>.</para>
	  </listitem>
	</itemizedlist>
      </section>

      <section>
	<title>Client et serveur sont distincts.</title>

	<para>L'exemple  suivant   montre  <literal>eve</literal>  essayant
	d'initier        une       connexion        &man.ssh.1;       vers
	<literal>login.exemple.com</literal>, en demandant  à se logguer en
	tant que <literal>bob</literal>. La connexion réussit. Bob aurait du choisir
	un meilleur mot de passe !</para>

<screen>&prompt.user; <userinput>whoami</userinput>
eve
&prompt.user; <userinput>ssh bob@login.example.com</userinput>
bob@login.example.com's password: <userinput>god</userinput>
Last login: Thu Oct 11 09:52:57 2001 from 192.168.0.1
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.  All rights reserved.
FreeBSD 4.4-STABLE (LOGIN) #4: Tue Nov 27 18:10:34 PST 2001

Welcome to FreeBSD!
&prompt.user;</screen>

	<itemizedlist>
	  <listitem>
	    <para>Le demandeur est  <literal>eve</literal>.</para>
	  </listitem>
	  <listitem>
	    <para>Le client d'<literal>eve</literal> est représenté par les processus &man.ssh.1; </para>
	  </listitem>
	  <listitem>
	    <para>Le serveur est le processus &man.sshd.8; sur
	      <literal>login.example.com</literal></para>
	  </listitem>
	  <listitem>
	    <para>Le compte est <literal>bob</literal>.</para>
	  </listitem>
	  <listitem>
	    <para>Le jeton d'identification est
	    <literal>god</literal>.</para>
	  </listitem>
	  <listitem>
	    <para>Bien  que  cela ne  soit  pas  montré  dans cet  exemple,
	     l'arbitre est <literal>root</literal>.</para>
	  </listitem>
	</itemizedlist>
      </section>

      <section>
	<title>Exemple de règles</title>

	<para>Les  lignes  qui  suivent  sont  les  règles  par  défaut  de
	  <literal>sshd</literal>:</para>

<programlisting>
sshd	auth		required	pam_nologin.so	no_warn
sshd	auth		required	pam_unix.so	no_warn try_first_pass
sshd	account		required	pam_login_access.so
sshd	account		required	pam_unix.so
sshd	session		required	pam_lastlog.so	no_fail
sshd	password	required	pam_permit.so</programlisting>

	<itemizedlist>
	  <listitem>
	  	 <para>Cette      politique      s'applique      au      service
	  	 <literal>sshd</literal> (qui n'est pas necéssairement restreind
	  	 au serveur &man.sshd.8;)</para>
	  </listitem>
	  <listitem>
	    <para><literal>auth</literal>, <literal>account</literal>,
	      <literal>session</literal> et
	      <literal>password</literal> sont des mécanismes.</para>
	  </listitem>
	  <listitem>
	    <para><filename>pam_nologin.so</filename>,
	      <filename>pam_unix.so</filename>,
	      <filename>pam_login_access.so</filename>,
	      <filename>pam_lastlog.so</filename>                         et
	      <filename>pam_permit.so</filename> sont  des modules.  Il est
	      clair  dans cet exemple  que <filename>pam_unix.so</filename>
	      fournit  au  moins  deux  mécanismes (  authentification  et
	      gestion de compte).</para>
	  </listitem>
	</itemizedlist>
      </section>
    </section>

    <section id="pam-conventions">
      <title id="pam-conventions.title">Conventions</title>

      <para><!--XXX-->Cette section n'a pas encore été écrite.</para>
    </section>
  </section>

  <section id="pam-essentials">
    <title id="pam-essentials.title">Les bases de PAM</title>

    <section id="pam-facilities-primitives">
      <title id="pam-facilities-primitives.title">Mécanismes et primitives</title>

		<para>L'API   PAM  fournit  six   primitives  d'authentification
		différentes  regroupées dans quatre  mécanismes qui  seront décrits
		dans la partie suivante.</para>


      <variablelist>
	<varlistentry>
	  <term><literal>auth</literal></term>
	  <listitem>
	    <para><emphasis>Authentification.</emphasis>    Ce   mécanisme
	      concerne  l'authentification  du  demandeur  et  établit  les
	      droits du compte. Il fournit deux primitives :</para>


	    <itemizedlist>
	      <listitem>
		<para>&man.pam.authenticate.3;    authentifie    le   demandeur,
		généralement  en demandant  un jeton  d'identification et  en le
		comparant  a une  valeur stockée  dans une  base de  données ou
		obtenue par le biais d'un serveur d'authentification.</para>
	      </listitem>

	      <listitem>
		<para>&man.pam.setcred.3;  établi les  paramètres du  compte tel
		que l'uid, les groupes dont  le compte fait parti ou les limites
		sur l'utilisation des ressources.</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>account</literal></term>
	  <listitem>
	    <para><emphasis>Gestion  de  compte.</emphasis>  Ce  mécanisme
	    concerne la  disponibilité du  compte pour des raisons autres que
	    l'authentification.  Par exemple  les  restrictions basées  sur
	    l'heure courante ou la charge  du serveur. Il fournit une seule
	    primitive:</para>

	    <itemizedlist>
	      <listitem>
		<para>&man.pam.acct.mgmt.3;  vérifie que  le compte  demandé est
		disponible.</para>
	</listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>session</literal></term>
	  <listitem>
	    <para><emphasis>Gestion  de  session.</emphasis> Ce  mécanisme
	    concerne la mise en place de la session  et sa terminaison, par
	    exemple l'enregistrement  de la  session dans les  journaux. Il
	    fournit deux primitives:</para>
	    <itemizedlist>
	      <listitem>
		<para>&man.pam.open.session.3; accomplie  les tâches associées à
		la mise  en place  d'une session :  ajouter une entrée  dans les
		bases  <filename>utmp</filename>  et  <filename>wtmp</filename>,
		démarrer un agent SSH...</para>
	      </listitem>

	      <listitem>
		<para>&man.pam.close.session.3; accomplie les tâches associées à
		la terminaison d'une session : ajouter une entrée dans les bases
		<filename>utmp</filename>  et <filename>wtmp</filename>, arrêter
		l'agent SSH...</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>password</literal></term>
	  <listitem>
	    <para><emphasis>Gestion   des  mots  de   passe.</emphasis>  Ce
	 mécanisme est  utilisé pour modifier  le jeton d'authentification
	 associé à un  compte, soit parce qu'il a expiré,  soit parce que
	 l'utilisateur   désire   le   changer.   Il  fournit   une   seule
	 primitive:</para>
	    <itemizedlist>
	      <listitem>
		<para>&man.pam.chauthtok.3; modifie le jeton d'authentification,
		et éventuellement vérifie que celui-ci est assez robuste pour ne
		pas  être  deviné  facilement  ou  qu'il  n'a  pas  déjà utilisé.
		</para>

	      </listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>
      </variablelist>

    </section>

    <section id="pam-modules">
      <title id="pam-modules.title">Modules</title>


      <para>Les modules  sont le concept  clef de PAM; après  tout ils
      constituent  le  <quote>M</quote>  de  PAM. Un  module  PAM  est
      lui-même un  morceau de code qui implémente  les primitives d'un
      ou   plusieurs   mécanismes    pour   une   forme   particulière
      d'authentification; par  exemple, les bases de mots  de passe UNIX
      que sont NIS, LDAP et Radius.</para>

      <section id="pam-module-naming">
	<title id="pam-module-naming.title">Nom des modules</title>


	<para>FreeBSD implémente chaque  mécanismes dans un module distinct
	  nommé
	  <literal>pam_<replaceable>mécanisme</replaceable>.so</literal>
	  (par  exemple  <literal>pam_unix.so</literal>  pour le  mechanisme
	  Unix  .)   Les autres  implementations  possèdent  parfois des  modules
	  séparés pour  des mécanismes séparés et incluent aussi  bien le
	  nom du service  que celui du mécanisme dans le  nom du module. Un
	  exemple  est le  module  <literal>pam_dial_auth.so.1</literal> de
	  Solaris  qui  est  utilisé  pour  authentifier  les  utilisateurs
	  dialup.</para>
      </section>

      <section id="pam-module-versioning">
	<title id="pam-module-versioning.title">Gestion des versions de module </title>

	<para>L'implementation  originale  de PAM  par  FreeBSD, basée  sur
	Linux-PAM, n'utilisait  pas de numéro  de version pour  les modules
	PAM. Ceci peut poser des  problèmes avec les applications tiers qui
	peuvent être liées avec  d'anciennes bibliothèques systèmes, puisqu'il
	n'y  a pas  possibilité  de charger  la  version correspondante  du
	module désiré.</para>

	<para>Pour  sa part,  OpenPAM cherche  les  modules qui  ont la  même
	version que la bibliothèque PAM (pour le moment 2) et se rabat sur
	un module  sans version si aucun  module avec version  n'a put être
	chargé.  Ainsi les anciens  modules peuvent  être fournis  pour les
	anciennes  applications,   tout  en  permettant   aux  nouvelles applications
	(ou  bien nouvellement  compilées)  de  tirer parti  des
	modules les plus récents.</para>

	<para>Bien que les modules PAM de Solaris possèdent généralement un
	numéro de version, ils ne sont pas réellement versionnés car
	le numéro  correspond à une  partie du nom  du module et  doit être
	inclus dans la configuration.</para>
      </section>
    </section>

    <section id="pam-chains-policies">
      <title id="pam-chains-policies.title">Chaînes et politiques</title>

      <para>Lorsqu'un   <!--XXX-->serveur  initie   une   transaction  PAM,   la
      bibliothèque PAM essaie de  charger une politique pour le service
      spécifié  dans  l'appel  a  &man.pam.start.3;  .   La  politique
      indique comment la requête d'authentification doit être traitée
      et est définie dans un  fichier de configuration. Il  s'agit de
      l'autre   concept    clef   de   PAM :    la   possibilité   pour
      l'administrateur  de  configurer  la  politique de  sécurité  d'un
      système en éditant simplement une fichier texte.</para>

      <para>Une politique consiste en quatre chaînes, une pour chacune
      des  quatre mécanismes  de PAM. Chaque  chaîne est  une  suite de
      règles  de  configuration,  chacune  spécifiant un  module  à
      invoquer, des paramètres, options,  à passer au module et un
      drapeau de  contrôle qui décrit  comment interpréter le  code de
      retour du module.</para>

      <para>Comprendre  le  drapeau  de  contrôle est  essentiel  pour
      comprendre  les  fichiers de  configuration  de  PAM. Il  existe
      quatre drapeaux de contrôle différents :</para>

      <variablelist>
	<varlistentry>
	  <term><literal>binding</literal></term>
	  <listitem>
	    <para>Si le  module réussit et qu'aucun module  précédent de la
	    chaîne n'a  échoué, la chaîne s'interrompt  immédiatement et la
	    requête  est autorisée.  Si le  module échoue  le reste  de la
	    chaîne   est  exécuté,   mais   la  requête   est  rejetée   au
	    final.</para>

	    <para>Ce drapeau  de contrôle a  été introduit par  Sun Solaris
	    dans la  version 9  (SunOS 5.9);  il est aussi  supporté par
	    OpenPAM.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>required</literal></term>
	  <listitem>
	    <para>Si le module réussit, le  reste de la chaîne est exécuté,
	    et  la  requête est  autorisée  si  aucun  des autres  modules
	    n'échoue.  Si le  module  échoue,  le reste  de  la chaîne  est
	    exécuté, mais au final la requête est rejetée.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>requisite</literal></term>
	  <listitem>
	    <para>Si le module  réussit le reste de la  chaîne est exécuté,
	    et  la   requête  est   autorisée  sauf  si   d'autres  modules
	    échoués.  Si  le  module  échoue la  chaîne  est  immédiatement
	    terminée et la requête est rejetée.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>sufficient</literal></term>
	  <listitem>
	    <para>Si le  module réussit  et qu'aucun des  modules précédent
	    n'a échoué  la chaîne est immédiatement terminée  et la requête
	    est allouée. Si  le module échoue il est ignore  et le reste de
	    la chaîne est exécuté.</para>

	    <para>Puisque  la sémantique  de  ce drapeau  peut  être un  peu
	    confuse,  spécialement  lorsqu'il s'agit  de  celui du  dernier
	    module de  la chaîne, il  est recommandé d'utiliser  le drapeau
	    <literal>binding</literal>   à   la   place  de   celui-ci   sous la condition que
	    l'implementation le supporte.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>optional</literal></term>
	  <listitem>
	    <para>Le  module est exécuté  mais le  résultat est  ignoré. Si
	    tout    les    modules    de    la    chaîne    sont    marqués
	    <literal>optional</literal>,   toutes   les   requêtes   seront
	    toujours acceptées.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Lorsqu'un  serveur invoque l'une  des six  primitives PAM,
       PAM  récupère  la chaîne  du  mécanisme  à  laquelle la  requête
      correspond et  invoque chaque module de la  chaîne dans l'ordre
      indiqué,  jusqu'à  ce que  la  fin  soit  atteinte ou  qu'aucune
      exécution  supplémentaire ne  soit nécessaire  (soit à  cause du
      succès    d'un   module    en    <literal>binding</literal>   ou
      <literal>sufficient</literal>,  soit  à  cause de  l'échec  d'un
      module <literal>requisite</literal>). La requête est acceptée si
      et seulement  si au moins un  module a été invoqué,  et que tout
      les modules non optionnels ont réussi.</para>

      <para>Notez qu'il est possible, bien que peu courant, d'avoir le
      même  module  listé plusieurs  fois  dans  la  même chaîne.  Par
      exemple un module qui détermine  le nom utilisateur et le mot de
      passe  à  l'aide  d'un   serveur  directory  peut  être  invoqué
      plusieurs  fois   avec  des  paramètres   spécifiant  différents
      serveurs a contacter.  PAM considère les différentes occurrences
      d'un  même  module  dans  une  même  chaîne  comme  des  modules
      différents et non liés.</para>
    </section>

    <section id="pam-transactions">
      <title id="pam-transactions.title">Transactions</title>

      <para>Le cycle  de vie d'une transaction PAM  typique est décrit
      ci-dessous. Notez que si l'une  de ces étapes échoue, le serveur
      devrait  reporter un message  d'erreur au  client et  arrêter la
      transaction.</para>

      <orderedlist>
	<listitem>
	  <para>Si  nécessaire,  le   serveur  obtient  les  privilèges  de
	  l'arbitre par le biais d'un mécanisme indépendant de PAM &mdash;
	  généralement en ayant  été démarré par <literal>root</literal> ou
	  en étant setuid <literal>root</literal>.</para>
	</listitem>

	<listitem>
	  <para>Le  serveur appel  &man.pam.start.3; afin  d'initialiser la
	  bibliothèque PAM  et indique  le service et  le compte  cible, et
	  enregistre une fonction de conversation appropriée.</para>
	</listitem>

	<listitem>
	  <para>Le  serveur  obtient  diverses informations  concernant  la
	  transaction (tel que le nom  d'utilisateur du demandeur et le nom
	  d'hôte de la machine sur  lequel le client tourne) et les soumet
	  à PAM en utilisant la fonction &man.pam.set.item.3;.</para>
	</listitem>

	<listitem>
	  <para>Le serveur appel  &man.pam.authenticate.3; pour authentifier le demandeur.</para>
	</listitem>

	<listitem>
	  <para>Le  serveur  appel  la fonction  &man.pam.acct.mgmt.3;  qui
	  vérifie  que le compte  est valide  et disponible.  Si le  mot de
	  passe est correct mais a expiré, &man.pam.acct.mgmt.3; retournera
	  <literal>PAM_NEW_AUTHTOK_REQD</literal>    à    la    place    de
	  <literal>PAM_SUCCESS</literal>.</para>
	</listitem>

	<listitem>
	  <para>Si        l'étape        précédente       a        retourné
	  <literal>PAM_NEW_AUTHTOK_REQD</literal>,    le    serveur   appel
	  maintenant  &man.pam.chauthtok.3;  pour  obliger l'utilisateur  à
	  changer le jeton d'authentification du compte désiré.</para>
	</listitem>

	<listitem>
	  <para>Maintenant que le demandeur a été correctement authentifié,
	  le serveur appelle  &man.pam.setcred.3; pour obtenir les privilèges
	  du compte désiré. Il lui est  possible de faire ceci parce qu'il
	  agit au nom de l'arbitre dont il possède les privilèges.</para>
	</listitem>

	<listitem>
	  <para>Lorsque les privilèges corrects  ont été établi le serveur
	  appelle   &man.pam.open.session.3;   pour   mettre  en   place   la
	  session.</para>
	</listitem>

	<listitem>
	  <para>Maintenant le serveur effectue les services demandés par le
	  client &mdash; par exemple fournir un shell au demandeur.</para>
	</listitem>

	<listitem>
	  <para>Lorsque le  serveur a  fini de servir  le client,  il appelle
	  &man.pam.close.session.3; afin de  terminer la session.</para>
	</listitem>

	<listitem>
	  <para>Pour finir, le  serveur appelle &man.pam.end.3; afin signaler
	  à la bibliothèque  PAM que la transaction se termine et qu'elle peut libérer
	  les   ressources    qu'elle   a    alloué   au   cours    de   la
	  transaction.</para>
	</listitem>
      </orderedlist>
    </section>
  </section>

  <section id="pam-config">
    <title id="pam-config.title">Configuration de PAM</title>

    <section id="pam-config-file-locations">
      <title id="pam-config-file-locations.title">Emplacement des fichiers de configuration</title>

      <para>Le fichier de  configuration de PAM est traditionnellement
      <filename>/etc/pam.conf</filename>.  Ce fichier  contient toutes
      les  politiques  de PAM  pour  votre  système.  Chaque ligne  du
      fichier décrit une étape dans une chaîne, tel que nous allons le
      voir ci-dessous:</para>

<programlisting>login   auth    required        pam_nologin.so  no_warn</programlisting>

      <para>Les champs  sont respectivement, le service, le nom  du mécanisme, le
      drapeau  de contrôle,  le nom  du  module et  les arguments  du
      module. Tout  champ additionnel est considéré  comme argument du
      module.</para>

      <para>Une   chaîne  différente   est   construite  pour   chaque couple
      service/mécanisme;  ainsi,  alors  que  l'ordre  des  lignes  est
      important  lorsqu'il s'agit  des mêmes  services  ou mécanismes,
      l'ordre  dans  lequel  les  différents  services  et  mécanismes
      apparaissent  ne  l'est pas  &mdash;  excepté  l'entrée pour  le
      service  <literal>other</literal>, qui  sert de  référence par défaut  et doit
      être  placé à  la  fin.  L'exemple du  papier  original sur  PAM
      regroupait  les lignes  de configurations  par mécanisme  et le
      fichier   <filename>pam.conf</filename>  de   Solaris   le  fait
      toujours, mais  FreeBSD groupe  les lignes de  configuration par
      service. Toutefois il ne s'agit pas de la seule possibilité et les autres possèdent
      aussi un sens.</para>


      <para>OpenPAM et Linux-PAM offrent un mécanisme de configuration
      alternatif  où les  politiques  sont placées  dans des  fichiers
      séparés portant  le nom du service auquel  ils s'appliquent. Ces
      fichiers  sont situés dans  <filename>/etc/pam.d/</filename> et
      ne contiennent que  quatre champs à la place  de cinq &mdash; le
      champ contenant  le nom du service  est omis. Il  s'agit du mode
      par  défaut   dans  FreeBSD  4.x.   Notez  que  si   le  fichier
      <filename>/etc/pam.conf</filename>   existe   et  contient   des
      informations de configuration pour des services qui n'ont pas de
      politique  spécifiée  dans <filename>/etc/pam.d</filename>,  ils
      seront utilisés pour ces services.</para>



      <para>Le  gros avantage de  <filename>/etc/pam.d/</filename> sur
      <filename>/etc/pam.conf</filename>   est   qu'il  est   possible
      d'utiliser  la même  politique pour  plusieurs services  en liant
      chaque  nom  de service  à  un  fichier  de configuration.  Par
      exemple  pour  utiliser  la  même politique  pour  les  services
      <literal>su</literal>  et <literal>sudo</literal>,  nous pouvons
      faire comme ceci :</para>

<screen>&prompt.root; <userinput>cd /etc/pam.d</userinput>
&prompt.root; <userinput>ln -s su sudo</userinput></screen>

      <para>Ceci  fonctionne car  le nom  de service  est  déterminé a
      partir  du nom  de fichier  plutôt qu'indiqué  à  l'intérieur du
      fichier de configuration, ainsi le même fichier peut être utilisé
      pour des services nommés différemment.</para>

      <para>Un autre avantage est  qu'un logiciel tiers peu facilement
      installer  les politiques  pour ses  services sans  avoir besoin
      d'éditer  <filename>/etc/pam.conf</filename>. Pour  continuer la
      tradition     de     FreeBSD,     OpenPAM     regardera     dans
      <filename>/usr/local/etc/pam.d</filename>   pour   trouver   les
      fichiers  de  configurations; puis si  aucun n'est  trouvé  pour  le
      service   demandé,   il cherchera dans   <filename>/etc/pam.d/</filename>   ou
      <filename>/etc/pam.conf</filename>.</para>

      <para>Finalement,   quelque   soit   le   mécanisme   que   vous
      choisissiez,       la      politique      <quote>magique</quote>
      <literal>other</literal> est  utilisée par défaut  pour tous les
      services qui n'ont pas leur propre politique.</para>

    </section>

    <section id="pam-config-breakdown">
      <title id="pam-config-breakdown.title">Breakdown of a
	configuration line</title>

      <para>Comme      expliqué     dans     la      section     <link
	linkend="pam-config-file-locations"
	endterm="pam-config-file-locations.title"></link>,  chaque ligne de
	<filename>pam.conf</filename> consiste en quatre champs ou plus: le
	nom de service, le nom du mécanisme, le drapeau de contrôle, le nom
	du module et la présence ou non d'arguments pour le module.</para>

      <para>Le nom du service  est généralement, mais pas toujours, le
      nom  de  l'application auquelle  les  règles  s'appliquent. Si  vous
      n'êtes pas sûr, référez vous à la documentation de l'application
      pour déterminer quel nom de service elle utilise.</para>


      <para>Notez         que         si         vous         utilisez
      <filename>/etc/pam.d/</filename>      à     la      place     de
      <filename>/etc/pam.conf</filename>,   le  nom  du   service  est
      spécifié par  le nom du  fichier de configuration et  n'est pas
      indiqué  dans   les  lignes  de  configuration   qui,  dès  lors,
      commencent par le nom du mécanisme.</para>


      <para>Le mécanisme est  l'un des quatre mots clef  décrit dans la
      section         <link        linkend="pam-facilities-primitives"
      endterm="pam-facilities-primitives.title"></link></para>

      <para>De même, le  drapeau de contrôle est l'un  des quatre mots
      clef décrits dans la section <link linkend="pam-chains-policies"
      endterm="pam-chains-policies.title"></link>  et  décrit comment
      le   module   doit   interpréter    le   code   de   retour   du
      module.  Linux-PAM  supporte une  syntaxe  alternative qui  vous
      laisse  spécifier l'action à  associer à  chaque code  de retour
      possible;  mais ceci  devrait être  évité puisque  ce  n'est pas
      standard et étroitement lié à la façon dont Linux-PAM appelle les
      services  (qui diffère  grandement  de la  façon  de Solaris  et
      OpenPAM). C'est  sans étonnement que l'on  apprend qu'OpenPAM ne
      supporte pas cette syntaxe.</para>
    </section>

    <section id="pam-policies">
      <title id="pam-policies.title">Politiques</title>

      <para>Pour  configurer  PAM correctement,  il  est essentiel  de
      comprendre comment les politiques sont interprétées.</para>

      <para>Lorsqu'une   application   appelle  &man.pam.start.3;   la
      bibliothèque  PAM charge  la  politique du  service spécifié  et
      construit  les  quatre  chaînes   de  module  (une  pour  chaque
      mécanisme). Si  une ou plusieurs chaînes sont  vides, les chaînes
      de  la   politique  du  service   <literal>other</literal>  sont
      utilisées.</para>

      <para>Plus  tard,  lorsque  l'application  appelle  l'une  des  six
      primitives  PAM,  la  bibliothèque  PAM récupère  la  chaîne  du
      mécanisme  correspondant et  appelle la  fonction  appropriée avec
      chaque  module listé dans  la chaîne.  Après chaque  appel d'une
      fonction  de service,  le type  du  module et  le code  d'erreur
      sont retournés par  celle-ci pour  déterminer quoi faire.  À quelques
      exceptions  près,  dont  nous  parlerons  plus  tard,  la  table
      suivante s'applique:</para>

      <table>
	<title>Résumé de la chaîne d'exécution PAM </title>
	<tgroup cols="4">
	  <colspec colwidth="1*" colname="type">
	  <colspec colwidth="1*" colname="success">
	  <colspec colwidth="1*" colname="ignore">
	  <colspec colwidth="1*" colname="other">
	  <thead>
	    <row>
	      <entry colname="type"></entry>
	      <entry colname="success"><literal>PAM_SUCCESS</literal></entry>
	      <entry colname="ignore"><literal>PAM_IGNORE</literal></entry>
	      <entry colname="other"><literal>other</literal></entry>
	   </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry colname="type">binding</entry>
	      <entry colname="success">if (!fail) break;</entry>
	      <entry colname="ignore">-</entry>
	      <entry colname="other">fail = true;</entry>
	    </row>
	    <row>
	      <entry colname="type">required</entry>
	      <entry colname="success">-</entry>
	      <entry colname="ignore">-</entry>
	      <entry colname="other">fail = true;</entry>
	    </row>
	    <row>
	      <entry colname="type">requisite</entry>
	      <entry colname="success">-</entry>
	      <entry colname="ignore">-</entry>
	      <entry colname="other">fail = true; break;</entry>
	    </row>
	    <row>
	      <entry colname="type">sufficient</entry>
	      <entry colname="success">if (!fail) break;</entry>
	      <entry colname="ignore">-</entry>
	      <entry colname="other">-</entry>
	    </row>
	    <row>
	      <entry colname="type">optional</entry>
	      <entry colname="success">-</entry>
	      <entry colname="ignore">-</entry>
	      <entry colname="other">-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Si <varname>fail</varname> est vrai à la fin de la chaîne,
      ou  lorsqu'un <quote>break</quote>  est atteint,  le dispatcheur
      retourne le  code d'erreur renvoyé  par le premier module  qui a
      échoué.     Autrement     <literal>PAM_SUCCESS</literal>     est
      retourné.</para>

      <para>La   première   exception  est   que   le  code   d'erreur
      <literal>PAM_NEW_AUTHOK_REQD</literal>  soit considéré  comme un
      succès, sauf si  aucun module n'échoue et qu'au  moins un module
      retourne  <literal>PAM_NEW_AUTHOK_REQD</literal>  le dispatcheur
      retournera <literal>PAM_NEW_AUTHOK_REQD</literal>.</para>

     <para>La seconde exception  est que &man.pam.setcred.3; considère
     les         modules         <literal>binding</literal>         et
     <literal>sufficient</literal>       comme      s'ils      étaient
     <literal>required</literal>.</para>

      <para>La    troisième   et    dernière    exception   est    que
      &man.pam.chauthtok.3; exécute la totalité de la chaîne deux fois
      (la première pour des vérifications préliminaires et la deuxième
      pour mettre le  mot de passe) et lors  de la première exécution
      il    considère   les   modules    <literal>binding</literal>   et
      <literal>sufficient</literal>      comme      s'ils      étaient
      <literal>required</literal>.</para>

    </section>
  </section>

  <section id="pam-freebsd-modules">
    <title id="pam-freebsd-modules.title">Les modules PAM de FreeBSD</title>

    <section id="pam-modules-deny">
      <title id="pam-modules-deny.title">&man.pam.deny.8;</title>

      <para>Le module &man.pam.deny.8; est l'un des modules disponibles
      les  plus simples;  il répond  à n'importe  qu'elle  requête par
      <literal>PAM_AUTH_ERR</literal>.  Il est  utile  pour désactiver
      rapidement un service (ajoutez-le au début de chaque chaîne), ou
      pour       terminer      les       chaînes       de      modules
      <literal>sufficient</literal>.</para>
    </section>

    <section id="pam-modules-echo">
      <title id="pam-modules-echo.title">&man.pam.echo.8;</title>

      <para>Le module &man.pam.echo.8;  passe simplement ses arguments
      à    la   fonction    de   conversation    comme    un   message
      <literal>PAM_TEXT_INFO</literal>. Il est principalement utilisé
      pour  le debogage  mais  il  peut aussi  servir  à afficher  un
      message    tel   que    <quote>Les    accès   illégaux    seront
      poursuivits</quote>    avant    de    commencer   la    procédure
      d'authentification.</para>
    </section>

    <section id="pam-modules-exec">
      <title id="pam-modules-exec.title">&man.pam.exec.8;</title>

      <para>Le module &man.pam.exec.8; prend comme premier argument le
      nom  du programme  à exécuter, les arguments  restant étant
      utilisés   comme  arguments   pour  ce   programme.   L'une  des
      applications possibles est d'utiliser un programme  qui monte le
      répertoire de l'utilisateur lors du login.</para>
    </section>

    <section id="pam-modules-ftp">
      <title id="pam-modules-ftp.title">pam_ftp(8)</title>

      <para>Le module pam_ftp(8)</para>
    </section>

    <section id="pam-modules-ftpusers">
      <title id="pam-modules-ftpusers.title">&man.pam.ftpusers.8;</title>

      <para>Le module &man.pam.ftpusers.8;</para>
    </section>

    <section id="pam-modules-group">
      <title id="pam-modules-group.title">&man.pam.group.8;</title>

      <para>Le   module  &man.pam.group.8;   accepte  ou   rejette  le
      demandeur à  partir de son appartenance à  un groupe particulier
      (généralement  <literal>wheel</literal> pour  &man.su.1;).  Il a
      pour but  premier de  conserver le comportement  traditionnel de
      &man.su.1; mais possède  d'autres applications comme par exemple
      exclure   un   certain   groupe   d'utilisateurs   d'un   service
      particulier.</para>

    </section>

    <section id="pam-modules-krb5">
      <title id="pam-modules-krb5.title">&man.pam.krb5.8;</title>

      <para>Le module &man.pam.krb5.8; </para>
    </section>

    <section id="pam-modules-ksu">
      <title id="pam-modules-ksu.title">&man.pam.ksu.8;</title>

      <para>Le module &man.pam.ksu.8; </para>
    </section>

    <section id="pam-modules-lastlog">
      <title id="pam-modules-lastlog.title">&man.pam.lastlog.8;</title>

      <para>Le module &man.pam.lastlog.8; </para>
    </section>

    <section id="pam-modules-login-access">
      <title id="pam-modules-login-access.title">&man.pam.login.access.8;</title>

      <para>Le module  &man.pam.login.access.8; </para>
    </section>

    <section id="pam-modules-nologin">
      <title id="pam-modules-nologin.title">&man.pam.nologin.8;</title>

      <para>Le module &man.pam.nologin.8; </para>
    </section>

    <section id="pam-modules-opie">
      <title id="pam-modules-opie.title">&man.pam.opie.8;</title>

      <para>Le   module   &man.pam.opie.8;   implémente   la   méthode
      d'authentification &man.opie.4;. Le  système &man.opie.4; est un
      mécanisme  de challenge-response o&ugrave;  la réponse  à chaque
      challenge est une fonction directe  du challenge et une phrase de
      passe, ainsi la réponse  peut facilement être calculée <quote>en
      temps  voulu</quote> par  n'importe qui  possédant la  phrase de
      passe ce qui élimine le besoin  d'une liste de mots de passe. De
      plus, puisque  &man.opie.4; ne réutilise  jamais un mot  de passe
      qui a  reçu une  réponse correcte, il  n'est pas  vulnérable aux
      attaques basée sur le rejouage.</para>
    </section>

    <section id="pam-modules-opieaccess">
      <title id="pam-modules-opieaccess.title">&man.pam.opieaccess.8;</title>

      <para>Le  module  &man.pam.opieaccess.8;  est  un  compagnon  du
      module   &man.pam.opie.8;.  Son   but  est   de   renforcer  les
      restrictions  codifiées  dans  &man.opieaccess.5;, il  régule  les
      conditions  sous  lesquelles   un  utilisateur  qui  normalement
      devrait s'authentifier  par &man.opie.4; est  amené à utiliser
      d'autres méthodes. Ceci  est généralement utilisé pour interdire
      l'authentification par  mot de passe depuis des  hôtes non digne
      de confiance.</para>

      <para>Pour     être    réellement     effectif,     le    module
      &man.pam.opieaccess.8;      doit      être      listé      comme
      <literal>requisite</literal>  immédiatement   après  une  entrée
      <literal>sufficient</literal>  pour  &man.pam.opie.8; et  avant
      tout       autre        module,       dans       la       chaîne
      <literal>auth</literal>.</para>

    </section>

    <section id="pam-modules-passwdqc">
      <title id="pam-modules-passwdqc.title">&man.pam.passwdqc.8;</title>

      <para>Le module  &man.pam.passwdqc.8; </para>
    </section>

    <section id="pam-modules-permit">
      <title id="pam-modules-permit.title">&man.pam.permit.8;</title>

      <para>Le   module  &man.pam.permit.8;   est  l'un   des  modules
      disponibles  les  plus simples;  il  répond  à n'importe  quelle
      requête  par <literal>PAM_SUCCESS</literal>.  Il est  utile pour
      les  services  o&ugrave;   une  ou  plusieurs  chaînes  auraient
      autrement été vides.</para>
    </section>

    <section id="pam-modules-radius">
      <title id="pam-modules-radius.title">&man.pam.radius.8;</title>

      <para>Le module &man.pam.radius.8; </para>
    </section>

    <section id="pam-modules-rhosts">
      <title id="pam-modules-rhosts.title">&man.pam.rhosts.8;</title>

      <para>Le module &man.pam.rhosts.8; </para>
    </section>

    <section id="pam-modules-rootok">
      <title id="pam-modules-rootok.title">&man.pam.rootok.8;</title>

      <para>Le  module  &man.pam.rootok.8; retourne  un  succès si  et
      seulement  si  l'identifiant  d'utilisateur  réel  du  processus
      appelant est 0. Ceci est utile pour les services non basés sur
      le  réseau  tel   que  &man.su.1;  ou  &man.passwd.1;  o&ugrave;
      l'utilisateur   <literal>root</literal>  doit  avoir   un  accès
      automatique.</para>
    </section>

    <section id="pam-modules-securetty">
      <title id="pam-modules-securetty.title">&man.pam.securetty.8;</title>

      <para>Le module &man.pam.securetty.8; </para>
    </section>

    <section id="pam-modules-self">
      <title id="pam-modules-self.title">&man.pam.self.8;</title>

      <para>Le  module  &man.pam.self.8;  retourne  un  succès  si  et
      seulement si  le nom  du demandeur correspond  au nom  du compte
      désiré. Il est  utile pour les services non  basés sur le réseau
      tel que  &man.su.1; o&ugrave; l'identité du  demandeur peut être
      vérifiée facilement .</para>
    </section>

    <section id="pam-modules-ssh">
      <title id="pam-modules-ssh.title">&man.pam.ssh.8;</title>

      <para>Le module  &man.pam.ssh.8; </para>
    </section>

    <section id="pam-modules-tacplus">
      <title id="pam-modules-tacplus.title">&man.pam.tacplus.8;</title>

      <para>Le module  &man.pam.tacplus.8; </para>
    </section>

    <section id="pam-modules-unix">
      <title id="pam-modules-unix.title">&man.pam.unix.8;</title>

      <para>Le  module &man.pam.unix.8;  implémente l'authentification
      Unix   traditionnelle    par   mot   de    passe,   il   utilise
      &man.getpwnam.3; pour obtenir le mot  de passe du compte visé et
      le compare avec celui fournit par le demandeur. Il fournit aussi
      des services  de gestion de  compte (désactivation du  compte et
      date d'expiration) ainsi que  des services pour le changement de
      mot de passe. Il s'agit certainement du module le plus utile car
      la plupart  des administrateurs désirent  garder le comportement
      historique pour quelques services.</para>
    </section>
  </section>

  <section id="pam-appl-prog">
    <title id="pam-appl-prog.title">Programmation d'applications PAM </title>

    <para><!--XXX-->Cette section n'a pas encore été écrite.</para>

    <!--

      Note that while the original PAM paper includes a sample PAM
      application that calls pam_open_session() before pam_setcred(),
      the Linux-PAM documentation states that pam_setcred() must be
      called first, which makes more sense.

      Also note that the example in the paper calls setgid(),
      initgroups() and setuid() itself rather than rely on
      pam_setcred() to do it.

      -->

  </section>

  <section id="pam-module-prog">
    <title id="pam-module-prog.title">Programmation de modules PAM</title>

    <para><!--XXX-->Cette section n'a pas été encore écrite.</para>
  </section>

  <appendix id="pam-sample-appl">
    <title id="pam-sample-appl.title">Exemples d'application PAM </title>

    <para>Ce qui suit est une implémentation minimale de &man.su.1; en
    utilisant PAM.  Notez qu'elle utilise la  fonction de conversation
    &man.openpam.ttyconv.3;  spécifique à  OpenPAM qui  est prototypée
    dans                                                      <filename
    class="headerfile">security/openpam.h</filename>.  Si vous désirez
    construire  cette   application  sur  un   système  utilisant  une
    bibliothèque  PAM  différente  vous  devrez fournir  votre  propre
    fonction de conversation. Une fonction de conversation robuste est
    étonnamment   difficile  à   implémenter;  celle   présentée  dans
    l'appendice<link                          linkend="pam-sample-conv"
    endterm="pam-sample-conv.title"></link>   est  un  bon   point  de
    départ, mais  ne devrait pas  être utilisée dans  des applications
    réelles.</para>

<programlisting>
<inlinegraphic fileref="pam_app.c"
  format="linespecific">
</programlisting>
  </appendix>

  <appendix id="pam-sample-module">
    <title id="pam-sample-module.title">Exemple d'un module PAM</title>

    <para>Ce   qui   suit   est   une   implémentation   minimale   de
    &man.pam.unix.8;      offrant     uniquement      les     services
    d'authentification.  Elle  devrait  compiler  et tourner  avec  la
    plupart  des implémentations  PAM, mais  tire parti  des extensions
    d'OpenPAM  si  elles  sont  disponibles :  notez  l'utilisation  de
    &man.pam.get.authtok.3;  qui simplifie  énormément  l'affichage de
    l'invite pour demander le mot de passe à l'utilisateur.</para>


<programlisting>
<inlinegraphic fileref="pam_module.c"
  format="linespecific">
</programlisting>
  </appendix>

  <appendix id="pam-sample-conv">
    <title id="pam-sample-conv.title">Exemple d'une fonction de conversation PAM</title>

    <para>La  fonction  de conversation  présentée  ci-dessous est  une
    version      grandement     simplifiée     de      la     fonction
    &man.openpam.ttyconv.3; d'OpenPAM. Elle est pleinement fonctionnelle
    et devrait  donner au  lecteur une bonne  idée de comment  doit se
    comporter une fonction de  conversation, mais elle est trop simple
    pour une utilisation réelle.  Même si vous n'utilisez pas OpenPAM,
    N'hésitez pas à  télécharger le  code  source et  d'adapter
    &man.openpam.ttyconv.3;  à vos besoins,  nous pensons  qu'elle est
    raisonnablement  aussi  robuste  qu'une fonction  de  conversation
    orientée tty peut l'être.</para>

<programlisting>

<inlinegraphic fileref="pam_conv.c"
  format="linespecific">
</programlisting>
  </appendix>

  <bibliography id="pam-further">
    <title id="pam-further.title">Lectures complémentaires</title>

    <abstract>
      <para>Ceci  est une  liste  de documents  concernant  PAM et  les
      domaines  gravitant autours.   Elle    n'a   pas   la   prétention   d'être
      complète.</para>
    </abstract>

    <bibliodiv>
      <title>Publications</title>

      <biblioentry>
	<title><ulink
	  url="http://www.sun.com/software/solaris/pam/pam.external.pdf">
	  Rendre les services de connexion indépendants des technologies d'authentification
	  </ulink></title>
	<authorgroup>
	  <author>
	    <surname>Samar</surname>
	    <firstname>Vipin</firstname>
	  </author>
	  <author>
	    <surname>Lai</surname>
	    <firstname>Charlie</firstname>
	  </author>
	</authorgroup>
	<orgname>Sun Microsystems</orgname>
      </biblioentry>

      <biblioentry>
	<title><ulink
	  url="http://www.opengroup.org/pubs/catalog/p702.htm">X/Open
	  Single Sign-on Preliminary Specification</ulink></title>
	<orgname>The Open Group</orgname>
	<isbn>1-85912-144-6</isbn>
	<pubdate>June 1997</pubdate>
      </biblioentry>

      <biblioentry>
	<title><ulink
	  url="http://www.kernel.org/pub/linux/libs/pam/pre/doc/current-draft.txt">
	  Pluggable Authentication Modules</ulink></title>
	<author>
	  <surname>Morgan</surname>
	  <firstname>Andrew</firstname>
	  <othername role="mi">G.</othername>
	</author>
	<pubdate>October 6, 1999</pubdate>
      </biblioentry>
    </bibliodiv>

    <bibliodiv>
      <title>Guides utilisateur</title>

      <biblioentry>
	<title><ulink
	  url="http://www.sun.com/software/solaris/pam/pam.admin.pdf">Administration de PAM
	 </ulink></title>
	<orgname>Sun Microsystems</orgname>
      </biblioentry>
    </bibliodiv>

    <bibliodiv>
      <title>Page internet liées</title>

      <biblioentry>
	<title><ulink url="http://openpam.sourceforge.net/">La page d'OpenPAM</ulink></title>
	<author>
	  <surname>Sm&oslash;rgrav</surname>
	  <firstname>Dag-Erling</firstname>
	</author>
	<orgname>ThinkSec AS</orgname>
      </biblioentry>

      <biblioentry>
	<title><ulink url="http://www.kernel.org/pub/linux/libs/pam/">La page de Linux-PAM</ulink></title>
	<author>
	  <surname>Morgan</surname>
	  <firstname>Andrew</firstname>
	  <othername role="mi">G.</othername>
	</author>
      </biblioentry>

      <biblioentry>
	<title><ulink url="http://wwws.sun.com/software/solaris/pam/">La page de Solaris PAM</ulink></title>
	<orgname>Sun Microsystems</orgname>
      </biblioentry>
    </bibliodiv>
  </bibliography>
</article>
