<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project
         
     $Id: chapter.sgml,v 1.1 2002-02-14 14:25:02 gioria Exp $
     Original revision: 1.4
     $FreeBSD$
-->

    <chapter id="tools">
      <title>Outils de programmation</title>

      <para><emphasis>Ce chap&icirc;tre a &eacute;t&eacute; &eacute;crit par James Raynard.
      Les modifications pour le livre de chevet du d&eacute;veloppeur par Murray Stokely.
      </emphasis></para>

      <sect1><title>Synopsis</title>

      <para>Ce document est une introduction &agrave; l'utilisation de quelques 
      outils de programmation fournis avec FreeBSD, toutefois tout sera applicable
      &agrave; beaucoup d'autres versions d'Unix. Cette introduction <emphasis>n'essaye</emphasis>
      pas de d&eacute;crire la programmation dans le d&eacute;tail.
      La plupart du document suppose que vous poss&eacute;dez peu ou pas de connaissances
      en programmation, esp&eacute;rant que les programmeurs trouveront un 
      int&eacute;r&ecirc;t dans ce document.</para>

      </sect1>

      <sect1><title>Introduction</title>
  
      <para>FreeBSD offre un excellent environnement de d&eacute;veloppement.
      Des compilateurs pour C, C++ et Fortran ainsi qu'un assembleur sont fournis avec 
      le syst&egrave;me de base, sans parler de l'interpr&eacute;teur PERL ni des
      outils classiques Unix comme <command>sed</command> et <command>awk</command>.
      Si cela n'est pas suffisant, il y a encore plus de compilateurs et 
      d'interpr&eacute;teurs dans la collection des logiciels port&eacute;s.
      FreeBSD est compatible avec les standards comme <acronym>POSIX</acronym> et C
      <acronym>ANSI</acronym>, aussi bien qu'avec son propre h&eacute;ritage BSD,
      aussi il est possible d'&eacute;crire des applications qui se compileront
      et s'ex&eacute;cuteront avec peu ou pas de modifications sur un grand nombre de
      plateformes.</para>

      <para>Toutefois, toute cette puissance peut &ecirc;tre plut&ocirc;t &eacute;crasante
      au premier abord si vous n'avez jamais &eacute;crit de programmes sur une 
      plateforme Unix auparavant. Ce document a pour but de vous aider &agrave; commencer,
      sans entrer trop loin dans des sujets plus avanc&eacute;s. L'intention est
      que ce document devrait vous donner assez de bases pour &ecirc;tre capable de
      donner du sens &agrave; la documentation.</para>

      <para>La majeure partie du document requiert peu ou pas de connaissance
      de la programmation, bien qu'il suppose une comp&eacute;tence de base dans 
      l'utilisation d'Unix et dans la bonne volont&eacute; d'apprendre !</para>

      </sect1>

      <sect1>
      <title>Introduction &#224; la programmation</title>

      <para>Un programme est un ensemble d'instructions qui disent &agrave; l'ordinateur
      de faire diverses choses; quelques fois, l'instruction qu'il a &agrave; ex&eacute;cuter
      d&eacute;pend de ce qui s'est pass&eacute; lors de l'ex&eacute;cution d'une instruction 
      pr&eacute;c&eacute;dente. Cette section donne un aperçu des deux mani&egrave;res par lesquelles 
      vous pouvez donner ces instructions, ou
      <quote>commandes</quote> comme elles sont habituellement nomm&eacute;es. 
      Une façon utilise un <firstterm>interpr&eacute;teur</firstterm>, l'autre
      un <firstterm>compilateur</firstterm>. Comme les langages humains sont
      trop difficiles &agrave; comprendre sans ambiguït&eacute; par un ordinateur,
      les commandes sont habituellement &eacute;crites dans un langage ou un autre 
      sp&eacute;cialement conçus pour cet usage.</para>

    <sect2>
      <title>Les interpr&#233;teurs</title>

      <para>Avec un interpr&eacute;teur, le langage va avec un environnement
	o&ugrave; vous entrez des commandes &agrave; un invite de commandes et l'environnement
	les ex&eacute;cute pour vous. Pour des programmes plus compliqu&eacute;s, vous pouvez
	entrer les commandes dans un fichier et demander &agrave; l'interpr&eacute;teur de charger
	le fichier et d'ex&eacute;cuter les commandes qui sont &agrave; l'int&eacute;rieur. 
	Si quoique ce soit se passe mal, beaucoup d'interpr&eacute;teurs vous enverrons
	dans un d&eacute;vermineur pour vous aider &agrave; d&eacute;busquer le probl&egrave;me.</para>

      <para>L'avantage de cela est que vous pouvez voir les r&eacute;sultats de
	vos commandes imm&eacute;diatement, et les erreurs peuvent &ecirc;tre corrig&eacute;es
	facilement. Le plus gros d&eacute;savantage arrive quand vous voulez partager
	vos programmes avec d'autres personnes. Ils doivent avoir le m&ecirc;me 
	interpr&eacute;teur ou bien vous devez avoir un moyen de leur donner,
	et ils doivent comprendre comment l'utiliser. Par ailleurs, les 
	utilisateurs pourraient ne pas appr&eacute;cier d'&ecirc;tre renvoy&eacute;s dans un 
	d&eacute;vermineur s'ils ont appuy&eacute; sur la mauvaise touche !
	D'un point de vue performance, les interpr&eacute;teurs peuvent utiliser
	beaucoup de m&eacute;moire et g&eacute;n&eacute;ralement ne g&eacute;n&egrave;rent pas un code aussi
	efficace que les compilateurs.</para>

      <para>A mon avis, les langages interpr&eacute;t&eacute;s sont le meilleur moyen
      	pour d&eacute;marrer si vous n'avez jamais programm&eacute;. Ce genre 
      	d'environnement se trouve typiquement avec des langages comme Lisp,
      	Smalltalk, Perl et Basic. Il peut aussi &ecirc;tre dit que l'interpr&eacute;teur de 
	commandes Unix (<command>sh</command>, <command>csh</command>) est 
	lui-m&ecirc;me un interpr&eacute;teur, et beaucoup de gens &eacute;crivent en fait des
	<quote>scripts</quote> (proc&eacute;dures) pour l'interpr&eacute;teur pour les aider
	dans diverses t&acirc;ches <quote>domestiques</quote> sur leur machine. 
	En effet, une partie de la philosophie d'origine d'Unix &eacute;tait de 
	fournir plein de petits programmes utilitaires qui pouvaient &ecirc;tre li&eacute;s
	ensemble dans des proc&eacute;dures pour effectuer des t&acirc;ches utiles.</para>
    </sect2>

    <sect2>
      <title>Les interpr&#233;teurs disponibles avec FreeBSD</title>

      <para>Voici la liste des interpr&eacute;teurs qui sont disponibles sous la forme
      de <ulink URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/"> 
      logiciels pr&eacute;-compil&eacute;s pour FreeBSD</ulink>, avec une br&egrave;ve description 
      de quelques uns des langages interpr&eacute;t&eacute;s les plus populaires.</para>

      <para>Pour obtenir un de ces logiciels pr&eacute;-compil&eacute;s, tout ce que vous 
      avez &agrave; faire est de cliquer sur le lien du logiciel et d'ex&eacute;cuter</para>

      <screen>&prompt.root; <userinput>pkg_add <replaceable>nom du logiciel</></userinput>
      </screen>

      <para>en tant que super-utilisateur. Evidemment, vous aurez besoin d'un 
      FreeBSD 2.1.0 ou plus en &eacute;tat de marche pour que le logiciel fonctionne !</para>

      <variablelist>
	<varlistentry>
	  <term><acronym>BASIC</acronym></term>

	  <listitem>
	    <para>Abbr&eacute;viation de "Beginner's All-purpose Symbolic
	      Instruction Code" (code d'instruction symbolique tout usage 
	      pour le d&eacute;butant). D&eacute;velopp&eacute; dans les ann&eacute;es 50 pour apprendre
	      aux &eacute;tudiants d'universit&eacute; &agrave; programmer et fourni avec tout
	      ordinateur qui se respecte dans les ann&eacute;es 80,
	      <acronym>BASIC</acronym> a &eacute;t&eacute; le premier langage de 
	      programmation pour beaucoup de programmeurs. Il est aussi le 
	      fondement m&ecirc;me du Visual Basic.</para>

	    <para>L'interpr&eacute;teur Basic <ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/bwbasic-2.10.tgz">Bywater
		</ulink> et l'interpr&eacute;teur Basic de <ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/pbasic-2.0.tgz">Phil
		Cockroft</ulink> (anciennement Rabbit
	      Basic) sont disponibles pour FreeBSD sous forme de<ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/"> logiciels pr&eacute;-compil&eacute;s
		</ulink></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Lisp</term>

	  <listitem>
	    <para>Un langage qui a &eacute;t&eacute; d&eacute;velopp&eacute; &agrave; la fin des ann&eacute;es 50 comme
	      une alternative aux langages <quote>d&eacute;voreurs de calculs</quote>
	      qui &eacute;taient tr&egrave;s populaires &agrave; l'&eacute;poque. Plut&ocirc;t qu'&ecirc;tre bas&eacute;
	      sur les nombres, Lisp est bas&eacute; sur les listes; en fait
	      le nom est l'abbr&eacute;viation de <quote>List Processing</quote>.
	      Tr&egrave;s populaire en IA (Intelligence Artificielle).</para>

	    <para>Lisp est un langage extr&egrave;mement puissant et sophistiqu&eacute;
	      , mais peut &ecirc;tre assez lourd et peu maniable.</para>

	    <para>FreeBSD a <ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/gcl-2.0.tgz">GNU
		Common Lisp</ulink> de disponible sous la forme d'un logiciel pr&eacute;-compil&eacute;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Perl</term>

	  <listitem>
	    <para>Tr&egrave;s populaire aupr&egrave;s des administrateurs syst&egrave;me pour la r&eacute;daction
	      de proc&eacute;dures; aussi souvent utilis&eacute; sur les serveurs Internet pour 
	      l'&eacute;criture de proc&eacute;dures <acronym>CGI</acronym>.</para>

	    <para>La derni&egrave;re version (version 5) est fournie avec FreeBSD.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Scheme</term>

	  <listitem>
	    <para>Un d&eacute;riv&eacute; du Lisp qui est plut&ocirc;t plus compact et
	      plus propre que le Common Lisp. Populaire dans les universit&eacute;s &eacute;tant
	      suffisamment simple &agrave; apprendre aux &eacute;tudiants comme premier langage
	      , il poss&egrave;de un niveau d'abstraction suffisamment important pour &ecirc;tre 
	      utilis&eacute; dans le travail de recherche.</para>

	    <para>On trouve pour FreeBSD les logiciels pr&eacute;-compil&eacute;s <ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/elk-3.0.tgz">interpr&eacute;teur
		Scheme Elk</ulink>, <ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/mit-scheme-7.3.tgz">l'interpr&eacute;teur
		Scheme du MIT</ulink> et <ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/scm-4e1.tgz">l'interpr&eacute;teur Scheme 
		SCM</ulink>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Icon</term>

	  <listitem>
	    <para><ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/icon-9.0.tgz">Le langage 
		de programmation Icon</ulink>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Logo</term>

	  <listitem>
	    <para><ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/ucblogo-3.3.tgz">l'interpr&eacute;teur Logo
		de Brian Harvey</ulink>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Python</term>

	  <listitem>
	    <para><ulink
		URL="ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/python-1.2">Le
		langage orient&eacute; objet Python</ulink></para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Les compilateurs</title>

      <para>Les compilateurs sont plut&ocirc;t diff&eacute;rents entre eux. Tout d'abord, vous &eacute;crivez
	votre code dans un fichier (ou des fichiers) en utilisant un &eacute;diteur de texte. Vous 
	ex&eacute;cutez ensuite le compilateur et v&eacute;rifiez qu'il accepte votre programme. S'il ne 
	compile pas, grincez des dents et retournez &agrave; l'&eacute;diteur; s'il compile et
	vous donne un programme, vous pouvez ex&eacute;cuter ce dernier &agrave; l'invite de commande ou
	dans un d&eacute;vermineur pour voir s'il fonctionne correctement.
	
	<footnote>
	  <para>Si vous l'ex&eacute;cuter &agrave; l'invite de commande, vous pouvez recevoir un fichier 
	  d'image m&eacute;moire (NDT: le d&eacute;sormais c&eacute;l&egrave;bre "core dump").</para>
	</footnote></para>

      <para>Evidemment, ce n'est pas aussi direct que d'utiliser un interpr&eacute;teur. 
      Toutefois cela vous permet de faire beaucoup de choses qui sont difficiles 
      ou m&ecirc;me impossibles avec un interpr&eacute;teur, comme &eacute;crire du code qui interagit
      de façon proche du syst&egrave;me d'exploitation ou m&ecirc;me d'&eacute;crire votre propre
      syst&egrave;me d'exploitation ! C'est aussi utile si vous avez besoin d'&eacute;crire du code
      tr&egrave;s efficace, &eacute;tant donn&eacute; que le compilateur peut prendre son temps et 
      optimiser le code, ce qui ne serait pas acceptable avec un interpr&eacute;teur.
      Et distribuer un programme &eacute;crit pour un compilateur est habituellement
      plus &eacute;vident qu'un &eacute;crit pour un interpr&eacute;teur&mdash;vous pouvez juste donner
      une copie de l'ex&eacute;cutable, en supposant que l'utilisateur poss&egrave;de le m&ecirc;me
      syst&egrave;me d'exploitation que vous.</para>

      <para>Les langages compil&eacute;s incluent Pascal, C et C++. C et C++
	sont des langages plut&ocirc;t impitoyables et conviennent mieux
	aux programmeurs exp&eacute;riment&eacute;s; Pascal, d'autre part, a &eacute;t&eacute;
	conçu comme un langage &eacute;ducatif, et est un assez bon langage
	pour commencer. Malheureusement, FreeBSD ne poss&egrave;de aucun
	support Pascal, except&eacute; pour un convertisseur Pascal vers C 
	dans les logiciels port&eacute;s.</para>

      <para>Le cycle &eacute;dition-compilation-ex&eacute;cution-d&eacute;verminage &eacute;tant relativement p&eacute;nible
      lors de l'utilisation de programmes s&eacute;par&eacute;s, beaucoup de fabricants de compilateur 
      ont produit des environnements de d&eacute;veloppement int&eacute;gr&eacute;s (ou <acronym>IDE</acronym> pour 
      Integrated Development Environments et <acronym>EDI</acronym> dans la langue de 
      Moli&egrave;re). FreeBSD ne poss&egrave;de pas d'<acronym>EDI</acronym>
      tel quel; toutefois il est possible d'utiliser Emacs &agrave; cet effet. 
      Ceci est vu dans <xref
	  linkend="emacs">.</para>
    </sect2>
  </sect1>


  <sect1>
    <title>Compiler avec <command>cc</command></title>

    <para>Cette section traite uniquement du compilateur GNU pour C et C++,
      celui-ci faisant partie du syst&egrave;me FreeBSD de base. Il peut &ecirc;tre invoqu&eacute;
      soit par <command>cc</command> ou <command>gcc</command>. Les
      d&eacute;tails de production d'un programme avec un interpr&eacute;teur varient
      consid&eacute;rablement d'un interpr&eacute;teur &agrave; l'autre, et sont habituellement
      bien couverts par la documentation et l'aide en ligne de l'interpr&eacute;teur.</para>

    <para>Une fois que vous avez &eacute;crit votre chef d'oeuvre, la prochaine &eacute;tape est
      de le convertir en quelque chose qui s'ex&eacute;cutera (esp&eacute;rons !) sur FreeBSD.
      Cela implique normalement plusieurs &eacute;tapes, r&eacute;alis&eacute;es chacune par un programme
      diff&eacute;rent.</para>

    <procedure>
      <step>
	<para>Pr&eacute;-traiter votre code source pour retirer les commentaires et faire
	  d'autres trucs comme d&eacute;velopper (expanser) les macros en C.</para>
      </step>

      <step>
	<para>V&eacute;rifier la syntaxe de votre code source pour voir si vous avez 
	ob&eacute;i aux r&egrave;gles du langage. Si vous ne l'avez pas fait, il se plaindra !</para>
      </step>

      <step>
	<para>Convertir le code source en langage assembleur&mdash;
	cela est vraiment proche du code machine, mais reste
	  compr&eacute;hensible par des humains. Pr&eacute;tendument.

	  <footnote>
	    <para>Pour &ecirc;tre vraiment pr&eacute;cis, <command>cc</command> convertit &agrave; ce niveau le
	      code source dans son propre <firstterm>p-code</firstterm> ind&eacute;pendant de la 
	      machine plut&ocirc;t qu'en langage assembleur.</para>
	  </footnote></para>
      </step>

      <step>
	<para>Convertir le langage  assembleur en code machine
	  &mdash;ouais, on parle de bits et d'octets, de uns et
	  de z&eacute;ros.</para>
      </step>

      <step>
	<para>V&eacute;rifier que vous avez utilis&eacute; des choses comme des fonctions et
	des variables globales de façon consistente. Par exemple, si vous
	  avez appel&eacute; une fonction inexistente, le compilateur se plaindra.</para>
      </step>

      <step>
	<para>Si vous essayez de produire un ex&eacute;cutable depuis plusieurs
	  fichiers de code source, r&eacute;soudre comment les faire fonctionner
	  ensemble.</para>
      </step>

      <step>
	<para>R&eacute;soudre comment produire quelque chose que le chargeur au vol
	du syst&egrave;me sera capable de charger en m&eacute;moire et ex&eacute;cuter.</para>
      </step>

      <step>
	<para>Finalement, &eacute;crire l'ex&eacute;cutable dans le syst&egrave;me de fichiers.</para>
      </step>
    </procedure>

    <para>Le mot <firstterm>compilation</firstterm> est souvent utilis&eacute; pour
      les &eacute;tapes 1 &agrave; 4 seules&mdash;les autres correspondent au terme
      <firstterm>liaison</firstterm>. Quelquefois, l'&eacute;tape 1 est appel&eacute;e
      <firstterm>pre-traitement</firstterm> et les &eacute;tapes 3-4 <firstterm>assemblage</firstterm>.</para>

    <para>Heureusement, la plupart de ces d&eacute;tails vous sont cach&eacute;s, &eacute;tant donn&eacute; que
    <command>cc</command> est un frontal qui s'occupe d'appeler tous les
      programmes avec les arguments corrects pour vous; tapez simplement</para>

    <screen>&prompt.user; <userinput>cc foobar.c</>
    </screen>

    <para>compilera <filename>foobar.c</filename> avec toutes les &eacute;tapes au-dessus.
    Si vous avez plus d'un fichier &agrave; compiler, faites simplement
      quelque chose comme</para>

    <screen>&prompt.user; <userinput>cc foo.c bar.c</>
    </screen>

    <para>Notez que la v&eacute;rification de syntaxe n'est que cela&mdash;v&eacute;rifier
      la syntaxe. Cela ne v&eacute;rifiera pas les erreurs de logique que vous pouvez
      avoir faites, comme mettre le programme en boucle infinie ou
      utiliser un tri &agrave; bulles quand vous devriez utiliser un tri binaire.

      <footnote>
	<para>Au cas o&ugrave; vous ne le sauriez pas, un tri binaire est un mani&egrave;re
	  efficace de trier les &eacute;l&eacute;ments et le tri &agrave; bulles n'en est pas une.</para>
      </footnote></para>

    <para>Il y a beaucoup d'options pour <command>cc</command>, qui
      qui se trouvent toutes dans les pages de manuel en ligne.
      Voici quelques unes des plus importantes, avec des exemples illustrant leur
      utilisation.</para>

    <variablelist>
      <varlistentry>
	<term><option>-o <replaceable>nom_du_fichier</replaceable></option></term>

	<listitem>
	  <para>Le nom de sortie du fichier.  Si vous n'utilisez pas cette option,
	  <command>cc</command> produira un ex&eacute;cutable appel&eacute;
	    <filename>a.out</filename>.

	    <footnote>
	      <para>Les raisons de ceci sont enterr&eacute;es dans les brumes de l'histoire.</para>
	    </footnote></para>

	  <informalexample>
	    <screen>&prompt.user; <userinput>cc foobar.c</>               <lineannotation>l'ex&eacute;cutable est <filename>a.out</></>
&prompt.user; <userinput>cc -o foobar foobar.c</>     <lineannotation>l'ex&eacute;cutable est <filename>foobar</></>
	    </screen>
	  </informalexample>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-c</option></term>
	
	<listitem>
	  <para>Compile juste le fichier, ne le lie pas. Utile pour les
	    programmes jouets dont vous voulez juste v&eacute;rifier la syntaxe, 
	    ou si vous utilisez un <filename>Makefile</filename>.</para>

	  <informalexample>
	    <screen>&prompt.user; <userinput>cc -c foobar.c</userinput>
	    </screen>
	  </informalexample>

	  <para>Cela va produire un <firstterm>fichier objet</firstterm> (pas un
	    ex&eacute;cutable) appel&eacute; <filename>foobar.o</filename>. Celui-ci
	    peut &ecirc;tre li&eacute; ensuite avec d'autres fichiers objets pour produire un
	    ex&eacute;cutable.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-g</option></term>

	<listitem>
	  <para>Cr&eacute;e une version de d&eacute;verminage de l'ex&eacute;cutable. Cela oblige
	    le compilateur &agrave; placer des informations dans l'ex&eacute;cutable comme
	    telle ligne du fichier source correspond &agrave; tel appel de fonction.
	    Un d&eacute;vermineur peut utiliser cette information pour vous montrer
	    le code source au fur et &agrave; mesure que vous avancez pas &agrave; pas dans le programme,
	    ce qui est <emphasis>tr&egrave;s</emphasis> utile; le d&eacute;savantage est que
	    toutes ces informations suppl&eacute;mentaires rendent le programme plus gros.
	    Normalement, vous compilez avec l'option <option>-g</option> quand vous
	    &ecirc;tes en train de d&eacute;velopper un programme et compilez ensuite une 
	    <quote>version de production</quote> sans <option>-g</option> quand vous &ecirc;tes
	    satisfait du fonctionnement.</para>

	  <informalexample>
	    <screen>&prompt.user; <userinput>cc -g foobar.c</userinput>
	    </screen>
	  </informalexample>

	  <para>Cela va produire une version de d&eacute;verminage du programme foobar.

	    <footnote>
	      <para>Notez, nous n'avons pas utilis&eacute; l'option <option>-o</option>
		pour sp&eacute;cifier le nom de l'ex&eacute;cutable, aussi nous obtiendrons un 
		ex&eacute;cutable du nom de <filename>a.out</filename>.
		Produire une version de d&eacute;verminage du nom de 
		<filename>foobar</filename> est laiss&eacute; en exercice pour le lecteur!</para>
	    </footnote></para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-O</option></term>

	<listitem>
	  <para>Cr&eacute;e une version optimis&eacute;e de l'ex&eacute;cutable. Le compilateur
	    effectue diff&eacute;rents trucs malins pour essayer de produire
	    un ex&eacute;cutable qui s'ex&eacute;cute plus rapidement que normal.
	    Vous pouvez ajouter un nombre apr&egrave;s l'option <option>-O</option> 
	    pour sp&eacute;cifier un niveau d'optimisation plus important, mais cela vous expose
	    souvent aux bogues dans l'optimiseur du compilateur. Par exemple, la version de
	    <command>cc</command> fournit avec la version 2.1.0 FreeBSD est connue 
	    pour produire du mauvais code avec l'option <option>-O2</option>
	    dans certaines circonstances.</para>

	  <para>L'optimisation est habituellement activ&eacute;e uniquement lors de 
	  la compilation d'une version de production.</para>

	  <informalexample>
	    <screen>&prompt.user; <userinput>cc -O -o foobar foobar.c</userinput>
	    </screen>
	  </informalexample>

	  <para>Cela va produire une version optimis&eacute;e de
	    <filename>foobar</filename>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Les trois prochaines options vont forcer <command>cc</command>
      &agrave; v&eacute;rifier que votre code est conforme au standard international en cours,
      se r&eacute;f&eacute;rant souvent &agrave; la norme <acronym>ANSI</acronym>, qui pour dire pr&eacute;cisement
      est un standard <acronym>ISO</acronym>.</para>

    <variablelist>
      <varlistentry>
	<term><option>-Wall</option></term>

	<listitem>
	  <para>Active tous les avertissements que les auteurs de
	    <command>cc</command> pensent valoir le coup. Malgr&eacute; le nom, il 
	    n'active pas tous les avertissements dont <command>cc</command>
	    est capable.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-ansi</option></term>

	<listitem>
	  <para>D&eacute;sactive la plupart, mais pas toutes, des caract&eacute;ristiques
	    du C fournies par <command>cc</command> qui sont non-<acronym>ANSI</acronym>&nbsp;. Malgr&eacute; 
	    le nom, cela ne garantit pas strictement que votre code sera conforme au standard.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-pedantic</option></term>

	<listitem>
	  <para>D&eacute;sactive <emphasis>toutes</emphasis>
	    les caract&eacute;ristiques de <command>cc</command> qui ne sont pas <acronym>ANSI</acronym>&nbsp;.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Sans ces options, <command>cc</command> vous permettrait d'utiliser
      quelques extensions au standard non-standards. Quelques unes de celles-ci 
      sont tr&egrave;s utiles, mais ne fonctionneront pas avec d'autres compilateurs
      &mdash;en fait, un des principaux buts du standard est de permettre aux gens 
      d'&eacute;crire du code qui fonctionnera avec n'importe quel compilateur sur
      n'importe quel syst&egrave;me. Cela est connu sous le nom de <firstterm>code portable</firstterm>.</para>

    <para>Generalement, vous devriez essayer de faire votre code aussi portable 
    que possible, sinon vous pourriez avoir a r&eacute;-&eacute;crire totalement votre 
    programme plus tard pour le faire fonctionner autre part&mdash;et qui
      sait ce que vous utiliserez dans quelques ann&eacute;es?</para>

    <informalexample>
      <screen>&prompt.user; <userinput>cc -Wall -ansi -pedantic -o foobar foobar.c</userinput>
      </screen>
    </informalexample>

    <para>Cela produira un ex&eacute;cutable <filename>foobar</filename>
      apr&egrave;s avoir v&eacute;rifi&eacute; que <filename>foobar.c</filename> est conforme au standard.</para>

    <variablelist>
      <varlistentry>
	<term><option>-l<replaceable>librairie</replaceable></option></term>

	<listitem>
	  <para>Sp&eacute;cifie une librairie de fonctions &agrave; utiliser lors
	  de l'&eacute;dition des liens.</para>

	  <para>L'exemple le plus commun de cela est lors de la compilation
	  d'un programme qui utilise quelques fonctions math&eacute;matiques en C.
	  A l'inverse de la plupart des plateformes, celles-ci se trouvent dans
	  une librairie standard du C et vous devez dire au compilateur de l'ajouter.
	  </para>

	  <para>La r&egrave;gle est que si une librairie est appel&eacute;e
	    <filename>lib<replaceable>quelque_chose</replaceable>.a</filename>,
	    vous donnez &agrave;  <command>cc</command> l'argument
	    <option>-l<replaceable>quelque_chose</replaceable></option>.
	    Par exemple, la librairie des fonctions math&eacute;matiques est 
	    <filename>libm.a</filename>, aussi vous donnez &agrave; 
	    <command>cc</command> le param&egrave;tre  <option>-lm</option>.
	    Un <quote>pi&egrave;ge</quote> habituel avec la librairie math est
	    qu'elle doit &ecirc;tre la derni&egrave;re sur la ligne de commande.</para>

	  <informalexample>
	    <screen>&prompt.user; <userinput>cc -o foobar foobar.c -lm</userinput>
	    </screen>
	  </informalexample>

	  <para>Cela va lier les fonctions de la librairie math &agrave; l'interieur de
	    <filename>foobar</filename>.</para>

	  <para>Si vous compilez du C++; vous devrez ajouter
	    <option>-lg++</option>, ou <option>-lstdc++</option> si
	    vous utilisez FreeBSD 2.2 ou ult&eacute;rieur, &agrave; la ligne de commande de
	    <command>cc</command> pour lier avec les fonctions de la librairie C++.
	    Alternativement, vous pouvez utiliser <command>c++</command> plut&ocirc;t
	    que <command>cc</command>, qui fait tout cela pour vous.
	    <command>c++</command> peut aussi &ecirc;tre invoqu&eacute; par 
	    <command>g++</command> sur FreeBSD.</para>

	  <informalexample>
	    <screen>&prompt.user; <userinput>cc -o foobar foobar.cc -lg++</userinput>     <lineannotation>Pour FreeBSD 2.1.6 et ant&eacute;rieur</>
&prompt.user; <userinput>cc -o foobar foobar.cc -lstdc++</userinput>  <lineannotation>Pour FreeBSD 2.2 et ult&eacute;rieur</>
&prompt.user; <userinput>c++ -o foobar foobar.cc</userinput>
	    </screen>
	  </informalexample>

	  <para>Chacune de ces commandes va produire un ex&eacute;cutable
	    <filename>foobar</filename> &agrave; partir du fichier source C++
	    <filename>foobar.cc</filename>. Notez que, sur les syst&egrave;mes Unix
	    , les fichiers source C++ se terminent traditionnellement en
	    <filename>.C</filename>, <filename>.cxx</filename> ou
	    <filename>.cc</filename>, plut&ocirc;t que le style MS-DOS
	    <filename>.cpp</filename> (qui &eacute;tait d&eacute;j&agrave; 
	    utilis&eacute; pour autre chose).  <command>gcc</command> a utilis&eacute; cela
	    pour trouver le type de compilateur &agrave; utiliser sur le fichier source;
	    toutefois, cette restriction ne s'applique plus,
	    aussi vous pouvez maintenant appeler vos fichiers C++
	    <filename>.cpp</filename> en toute impunit&eacute; !</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <sect2>
      <title>Questions et probl&#232;mes usuels sur <command>cc</command></title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>J'essaye d'&eacute;crire un programme qui utilise la fonction
	      <function>sin()</function> et je re&ccedil;ois l'erreur suivante. 
	      Que cela signifie-t-il ?</para>

	    <informalexample>
	      <screen>/var/tmp/cc0143941.o: Undefined symbol `_sin' referenced from text segment
	      </screen>
	    </informalexample>
	  </question>

	  <answer>
	    <para>Lors de l'utilisation des fonctions math&eacute;matiques comme
	      <function>sin()</function>, vous devez dire &agrave;
	      <command>cc</command> de lier avec la librairie math, comme :</para>

	    <informalexample>
	      <screen>&prompt.user; <userinput>cc -o foobar foobar.c -lm</userinput>
	      </screen>
	    </informalexample>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>J'ai &eacute;crit un programme simple pour m'exercer &agrave; 
	    l'utilisation de l'option <option>-lm</option>. Tout ce qu'il fait
	    est d'&eacute;lever 2,1 &agrave; la puissance 6.</para>

	    <informalexample>
	      <programlisting>#include &lt;stdio.h&gt;

int main() {
	float f;

	f = pow(2.1, 6);
	printf("2.1 ^ 6 = %f\n", f);
	return 0;
}
	      </programlisting>
	    </informalexample>

	    <para>j'ai effectu&eacute; la compilation comme suit :</para>

	    <informalexample>
	      <screen>&prompt.user; <userinput>cc temp.c -lm</userinput>
	      </screen>
	    </informalexample>

	    <para>et comme expliqu&eacute; ici, mais j'obtiens ceci 
	    quand je l'ex&eacute;cute :</para>

	    <informalexample>
	      <screen>&prompt.user; <userinput>./a.out</userinput>
2.1 ^ 6 = 1023.000000
	      </screen>
	    </informalexample>

	    <para>Ce <emphasis>n'est pas</emphasis> la r&eacute;ponse correcte !
	      Que se passe-t-il ?</para>
	  </question>

	  <answer>
	    <para>Quand le compilateur voit que vous appelez une fonction, il
	    v&eacute;rifie s'il a d&eacute;j&agrave; un prototype pour celle-ci. 
	    S'il ne l'a pas vu, il suppose que la fonction retourne un <type>int</type>, 
	    ce qui n'est absolument  pas ce que vous voulez ici.
	    </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Alors comment puis-je le r&eacute;parer?</para>
	  </question>

	  <answer>
	    <para>Les prototypes des fonctions math&eacute;matiques sont dans
	      <filename>math.h</filename>. Si vous incluez ce fichier,
	      le compilateur sera capable de trouver le prototype et il
	      arr&ecirc;tera de faire des trucs &eacute;tranges &agrave; vos calculs!
	      </para>

	    <informalexample>
	      <programlisting>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main() {
...
	      </programlisting>
	    </informalexample>

	    <para>Apr&egrave;s avoir recompil&eacute; comme pr&eacute;c&eacute;demment, 
	    ex&eacute;cutez :
	    </para>

	    <informalexample>
	      <screen>&prompt.user; <userinput>./a.out</userinput>
2.1 ^ 6 = 85.766121
	      </screen>
	    </informalexample>

	    <para>Si vous utilisez quelques fonctions math&eacute;matiques que ce soit,
	    incluez <emphasis>toujours</emphasis> <filename>math.h</filename> et n'oubliez pas
	    de lier avec la librairie math.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>J'ai compil&eacute; un fichier appel&eacute;
	      <filename>foobar.c</filename> et je ne trouve pas d'ex&eacute;cutable
	      appel&eacute; <filename>foobar</filename>. O&ugrave; est-il parti?</para>
	  </question>

	  <answer>
	    <para>Souvenez-vous, <command>cc</command> appellera
	    l'ex&eacute;cutable <filename>a.out</filename> sauf si vous lui dites
	    de faire autrement. Utilisez l'option
	      <option>-o&nbsp;<replaceable>nomfichier</replaceable></option>:</para>

	    <informalexample>
	      <screen>&prompt.user; <userinput>cc -o foobar foobar.c</userinput>
	      </screen>
	    </informalexample>
	  </answer>
	</qandaentry>
	
	<qandaentry>
	  <question>
	    <para>OK, j'ai un ex&eacute;cutable appel&eacute;
	      <filename>foobar</filename>, je peux le voir en ex&eacute;cutant
	      <command>ls</command>, mais quand je tape
	      <command>foobar</command> &agrave; l'invite de commandes, la r&eacute;ponse
	      est qu'il n'y a pas de tel fichier. Pourquoi le syst&egrave;me ne le trouve pas?
	    </para>
	  </question>

	  <answer>
	    <para>A l'inverse de MS-DOS, Unix ne regarde pas dans le 
	    r&eacute;pertoire courant lorsqu'il essaye de trouver un 
	    ex&eacute;cutable que vous voulez ex&eacute;cuter, sauf si
	    vous lui avez dit de le faire.
	    Vous pouvez soit taper <command>./foobar</command>, ce qui
	    signifie <quote>ex&eacute;cute le fichier nomm&eacute;
	    <filename>foobar</filename> dans le r&eacute;pertoire courant</quote>,
	    soit changer votre variable d'environnement <envar>PATH</envar>
	    de fa&ccedil;on &agrave; ce qu'elle ressemble &agrave; quelque chose comme
	    </para>

	    <informalexample>
	      <screen>bin:/usr/bin:/usr/local/bin:.
	      </screen>
	    </informalexample>

	    <para>Le point &agrave; la fin signifie <quote>regarde dans le repertoire 
	    courant s'il n'est dans aucun autre</quote>.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>J'ai appel&eacute; mon ex&eacute;cutable <filename>test</filename>,
	    mais rien ne se passe quand je l'ex&eacute;cute. Que se passe-t-il?
	    </para>
	  </question>

	  <answer>
	    <para>La plupart des syst&egrave;mes Unix ont un programme appel&eacute;
	      <command>test</command> dans <filename>/usr/bin</filename>
	      et l'interpr&eacute;teur prend celui-ci avant de v&eacute;rifier dans
	      le r&eacute;pertoire courant. Soit vous tapez
	      </para>

	    <informalexample>
	      <screen>&prompt.user; <userinput>./test</userinput>
	      </screen>
	    </informalexample>

	    <para>soit vous choisissez un meilleur nom pour votre programme !!
	    </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>J'ai compil&eacute; mon programme et il semble fonctionner au premier abord,
	    puis il y a une erreur et le syst&egrave;me a dit quelque chose comme
	    <errorname>core dumped</errorname>. Que cela signifie-t-il?</para>
	  </question>

	  <answer>
	    <para>Le nom <firstterm>core dump</firstterm> date
	    des tous premiers jours d'Unix, quand les machines utilisaient
	    la m&eacute;moire centrale<footnote><para>NDT: je n'ai pas trouv&eacute; 
	    de meilleure traduction pour core memory</para></footnote>pour stocker 
	    les donn&eacute;es.
	    Simplement, si le programme a &eacute;chou&eacute; sous certaines conditions,
	    le syst&egrave;me va &eacute;crire le contenu de la m&eacute;moire centrale
	    sur le disque dans un fichier appel&eacute;
	    <filename>core</filename>, que le programmeur peut ensuite
	    examiner de pr&egrave;s pour trouver ce qui s'est mal pass&eacute;.
	    </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Fascinant, mais que suis-je suppos&eacute; faire ?</para>
	  </question>

	  <answer>
	    <para>Utilisez <command>gdb</command> pour analyser le fichier <filename>core</filename> 
	    (voir <xref linkend="debugging">).</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Quand mon programme a g&eacute;n&eacute;r&eacute; un fichier <filename>core</filename>,
	    il a parl&eacute; d'une erreur <errorname>segmentation fault</errorname>.
	    Qu'est-ce que c'est ?</para>
	  </question>

	  <answer>
	    <para>Cela signifie simplement que votre programme a essay&eacute;
	    d'effectuer une op&eacute;ration ill&eacute;gale sur la m&eacute;moire;
	    Unix est con&ccedil;u pour prot&eacute;ger le syst&egrave;me d'exploitation
	    et les autres programmes des programmes crapuleux.
	    </para>

	    <para>Les causes habituelles de cela sont :</para>

	    <itemizedlist>
	      <listitem>
		<para>Essayer d'&eacute;crire dans un pointeur <symbol>NULL</symbol>,
		par exemple 
		</para>

		<programlisting>char *foo = NULL;
strcpy(foo, "bang!");
		</programlisting>
	      </listitem>

	      <listitem>
		<para>Utiliser un pointeur qui n'a pas &eacute;t&eacute; initialis&eacute;,
		par exemple</para>

		<programlisting>char *foo;
strcpy(foo, "bang!");
		</programlisting>

		<para>Le pointeur va avoir une valeur al&eacute;atoire qui
		avec de la chance, pointera dans une zone de la m&eacute;moire qui
		n'est pas disponible pour votre programme et le noyau va tuer
		votre programme avant qu'il ne fasse des dommages. Si
		vous &ecirc;tes malchanceux, il pointera quelque part dans votre
		propre programme et alt&egrave;rera une de vos structures de donn&eacute;es,
		faisant planter votre programme myst&eacute;rieusement.
		</para>
	      </listitem>

	      <listitem>
		<para>Essayer d'acc&egrave;der la m&eacute;moire au-del&agrave; de la fin
		d'un tableau,
		par exemple</para>

		<programlisting>int bar[20];
bar[27] = 6;
		</programlisting>
	      </listitem>

	      <listitem>
		<para>Essayer de stocker quelque chose dans la m&eacute;moire en lecture seule,
		par exemple</para>

		<programlisting>char *foo = "Ma chaine";
strcpy(foo, "bang!");
		</programlisting>

		<para>Les compilateurs Unix mettent souvent les cha&icirc;nes comme
		<literal>"Ma chaine"</literal> dans des zones de m&eacute;moire 
		en lecture seule.
		</para>
	      </listitem>

	      <listitem>
		<para>Faire des trucs sales avec
		  <function>malloc()</function> et
		  <function>free()</function>, par exemple</para>

		<programlisting>char bar[80];
free(bar);
		</programlisting>

		<para>ou</para>

		<programlisting>char *foo = malloc(27);
free(foo);
free(foo);
		</programlisting>
	      </listitem>
	    </itemizedlist>

	    <para>Faire une de ces fautes ne conduit pas toujours
	    &agrave; une erreur, mais elles sont toujours de mauvais entrainements.
	    Certains syst&egrave;mes et compilateurs sont plus tol&eacute;rants que d'autres,
	    ce qui explique pourquoi des programmes qui fonctionnent bien sur un syst&egrave;me
	    peuvent planter si vous les essayer sur un autre.
	    </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Des fois quand je re&ccedil;oit une erreur <errorname>core dump</errorname>,
	    il est pr&eacute;cis&eacute; <errorname>bus error</errorname>.
	    Il est dit dans mon livre Unix qu'il s'agit d'un probl&egrave;me mat&eacute;riel
	    mais l'ordinateur semble toujours fonctionner. Est-ce vrai ?
	    </para>
	  </question>

	  <answer>
	    <para>Non, heureusement non (sauf si bien s&ucirc;r vous avez r&eacute;ellement
	    un probl&egrave;me mat&eacute;riel&hellip;). Cela est habituellement une
	    mani&egrave;re de dire que vous avez acc&eacute;d&eacute; &agrave; la m&eacute;moire
	    d'une fa&ccedil;on que vous n'auriez pas d&ucirc;.
	    </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Toute cette affaire de fichier <filename>core</filename> semble &ecirc;tre
	    assez utile, si je peux le faire appara&icirc;tre quand je le d&eacute;sire.
	    Puis-je faire cela, ou dois-je attendre la prochaine erreur ?</para>
	  </question>

	  <answer>
	    <para>Oui, ouvrez une autre console ou xterm, faites</para>

	    <screen>&prompt.user; <userinput>ps</userinput>
	    </screen>

	    <para>pour trouver l'identifiant du processus de votre programme, et faites
	    </para>

	    <screen>&prompt.user; <userinput>kill -ABRT <replaceable>identifiant</replaceable></userinput>
	    </screen>

	    <para>o&ugrave;
	      <parameter><replaceable>identifiant</replaceable></parameter> est
	      l'identifiant du processus que vous avez trouv&eacute;.</para>

	    <para>Ceci est utile si votre programme est bloqu&eacute; dans une boucle 
	    infinie, par exemple. Si votre programme arrive &agrave; bloquer le signal
	    <symbol>SIGABRT</symbol>, il y a d'autres signaux qui ont des effets
	    similaires.
	    </para>

	    <para>Alternativement, vous pouvez cr&eacute;er un fichier <filename>core</filename> depuis
	    votre programme, en appelant la fonction <function>abort()</function>.
	    Voir la page de manuel en ligne de &man.abort.3; pour en savoir plus.
	    </para>

            <para>Si vous voulez cr&eacute;er un fichier <filename>core</filename> depuis 
	    l'ext&eacute;rieur de votre programme, mais ne voulez pas que le processus
	    s'arr&ecirc;t,vous pouvez utiliser le programme <command>gcore</command>.
	    Voir la page de manuel en ligne de &man.gcore.1 pour plus d'informations.
	    </para>

	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1>
    <title>Make</title>

    <sect2>
      <title>Qu'est-ce que <command>make</command>?</title>

      <para>Quand vous travaillez sur un programme simple avec seulement
      un ou deux fichiers source, taper 
      </para>

      <screen>&prompt.user; <userinput>cc fichier1.c fichier2.c</userinput>
      </screen>

      <para>n'est pas si mal, mais cela devient rapidement fastidieux quand
      il y a plusieurs fichiers&mdash;et cela peut prendre du temps &agrave; compiler aussi.
      </para>

      <para>Une fa&ccedil;on de contourner cela est d'utiliser les fichiers objet 
      et de recompiler le fichier source seulement si le code source a chang&eacute;.
      Aussi, nous pourrions avoir quelque chose comme &ccedil;a:
      </para>

      <screen>&prompt.user; <userinput>cc fichier1.o fichier2.o</userinput> &hellip; <userinput>fichier37.c</userinput> &hellip
      </screen>

      <para>si nous avions chang&eacute; le fichier <filename>fichier37.c</filename> mais aucun
      des autres depuis la dern&egrave;re compilation. Cela pourrait acc&eacute;lerer assez bien
      la compilation mais cela ne resoud pas le probl&egrave;me de la frappe au clavier.
      </para>

      <para>Ou nous pourrions &eacute;crire une proc&eacute;dure pour r&eacute;soudre ce
      probl&egrave;me de frappe, mais celle-ci devrait tout re-compiler, devenant
      ainsi inefficace sur un gros projet.
      </para>

      <para>Que se passe-t-il si nous avons des centaines de fichiers source ?
      Que se passe-t-il si nous travaillons dans une &eacute;quipe avec 
      d'autres personnes qui oublient de nous dire quand ils ont chang&eacute;
      un de leurs fichiers source que nous utilisons ?
      </para>

      <para>Peut-&ecirc;tre pourrions nous mettre ensemble les deux solutions et
      &eacute;crire quelque chose comme une proc&eacute;dure qui contiendrait
      quelque r&egrave;gle magique disant quand notre fichier source doit &ecirc;tre
      compil&eacute;. Maintenant, tout ce dont nous avons besoin est un programme
      qui comprend ces r&egrave;gles, alors que c'est trop compliqu&eacute; pour 
      l'interpr&eacute;teur.
      </para>

      <para>Ce programme s'appelle <command>make</command>. Il lit
      dans un fichier, appel&eacute; un <firstterm>makefile</firstterm>, 
      qui lui dit comment les diff&eacute;rents fichiers d&eacute;pendent les
      uns des autres, et d&eacute;termine quels fichiers ont besoin d'&ecirc;tre
      recompil&eacute;s et quels n'en ont pas besoin.
      Par exemple, une r&egrave;gle pourrait dire quelque chose comme
      <quote>si <filename>fromboz.o</filename> est plus ancien que
      <filename>fromboz.c</filename>, cela signifie que quelqu'un a d&ucirc; 
      changer <filename>fromboz.c</filename>, aussi il a besoin d'&ecirc;tre
      recompil&eacute;.</quote> Le makefile poss&egrave;de aussi des r&egrave;gles
      pour dire &agrave; <command>make</command> <emphasis>comment</emphasis>
      re-compiler un fichier source, en faisant ainsi un outil encore plus
      puissant.
      </para>

      <para>Les <filename>Makefile</filename>s sont typiquement stock&eacute;s dans le m&ecirc;me 
      r&eacute;pertoire que le source auxquels il s'appliquent, et peuvent &ecirc;tre 
      appel&eacute;s <filename>makefile</filename>, <filename>Makefile</filename>
      ou <filename>MAKEFILE</filename>. La plupart des programmeurs utilise le nom
      <filename>Makefile</filename>, celui-ci se trouvant proche du d&eacute;but de la
      liste du contenu du r&eacute;pertoire o&ugrave; il peut &ecirc;tre facilement vu.

	<footnote>
	  <para>Ils n'utilisent pas la forme <filename>MAKEFILE</filename> 
	  car les bloques de majuscules sont souvent utilis&eacute;s pour les
	  fichiers de documentation comme <filename>README</filename>.
	  </para>
	</footnote>
      </para>
    </sect2>

    <sect2>
      <title>Exemple d'utilisation de <command>make</command></title>

      <para>Voici un exemple tr&egrave;s simple de <filename>Makefile</filename>:
      </para>
      <programlisting>foo: foo.c
	cc -o foo foo.c</programlisting>

      <para>Il consiste en deux lignes, une ligne de d&eacute;pendance et une ligne
      de cr&eacute;ation.
      </para>

      <para>La ligne de d&eacute;pendance ici consiste en le nom du programme (connu comme
      <firstterm>cible</firstterm>), suivi de deux-points puis un espace et enfin
      le nom du fichier source.
      Quand <command>make</command> lit cette ligne, il v&eacute;rifie si
       <filename>foo</filename> existe; s'il existe, il compare la date &agrave; laquelle
       <filename>foo</filename> a &eacute;t&eacute; modifi&eacute; la derni&egrave;re fois
       avec la date de derni&egrave;re modification de <filename>foo.c</filename>.
       Si <filename>foo</filename> n'existe pas ou est plus ancien que <filename>foo.c</filename>,
       il regarde la ligne de cr&eacute;ation pour trouver ce qu'il doit faire.
       En d'autres termes, il s'agit de la r&egrave;gle &agrave; utiliser quand
       <filename>foo.c</filename> a besoin d'&ecirc;tre re-compil&eacute;.
       </para>

      <para>La ligne de cr&eacute;ation commence avec un <token>tab</token> (appuyez
      sur la touche <keycap>tab</keycap>) suivi de la commande que vous taperiez
      pour cr&eacute;er <filename>foo</filename> si vous deviez le faire &agrave; l'invite
      de commandes. Si <filename>foo</filename> n'est pas &agrave; jour ou n'existe
      pas, <command>make</command> ex&eacute;cute alors cette commande pour
      le cr&eacute;er. En d'autres termes, il s'agit de la r&egrave;gle permettant
      &agrave; make de re-compiler <filename>foo.c</filename>.
      </para>

      <para>Aussi, quand vous tapez <userinput>make</userinput>, il v&eacute;rifiera 
      que <filename>foo</filename> est &agrave; jour en respect de vos derniers 
      changements sur <filename>foo.c</filename>. Ce principe peut &ecirc;tre
      &eacute;tendu &agrave; des <filename>Makefile</filename>s de plusieurs
      centaines de cibles&mdash;en fait, sur FreeBSD, il est possible de 
      compiler un syst&egrave;me d'exploitation entier en tapant juste
      <userinput>make world</userinput> dans le r&eacute;pertoire appropri&eacute; !
      </para>	 

      <para>Une autre propri&eacute;t&eacute; utile des makefiles est que les cibles
      n'ont pas n&eacute;cessairement besoin d'&ecirc;tre des programmes.
      Par exemple, nous pourrions avoir un <filename>Makefile</filename>
      qui ressemble &agrave; cela:
      </para>

      <programlisting>foo: foo.c
	cc -o foo foo.c

install:
	cp foo /home/moi</programlisting>

      <para>Nous pouvons dire &agrave; <command>make</command> quelle cible nous
      voulons en tapant:
      </para>

      <screen>&prompt.user; <userinput>make <replaceable>cible</replaceable></userinput>
      </screen>

      <para><command>make</command> ira seulement voir cette cible
      et ingorera les autres. Par exemple, si nous tapons 
      <userinput>make foo</userinput> avec le <filename>Makefile</filename> du dessus,
      <command>make</command> ignorera la cible <action>install</action>.
      </para>

      <para>Si nous tapons juste <userinput>make</userinput>,
      <command>make</command> regardera toujours la premi&egrave;re cible et s'arr&ecirc;tera
      sans regarder aucune autre. Aussi, si nous avions tap&eacute; <userinput>make</userinput>
      seul, <command>make</command> serait juste all&eacute; &agrave; la cible <action>foo</action>,
      aurait recompil&eacute; <filename>foo</filename> si n&eacute;cessaire et se 
      serait arr&ecirc;t&eacute; sans aller &agrave; la cible <action>install</action>.
      </para>

      <para>Notez que la cible <action>install</action> ne d&eacute;pend pour l'instant
      de rien ! Cela signifie que la commande qui suit est toujours ex&eacute;cut&eacute;e
      lorsque nous essayons de cr&eacute;er cette cible en tapant <userinput>make install</userinput>.
      Dans ce cas, <command>make</command> va copier <filename>foo</filename> dans le
      r&eacute;pertoire de l'utilisateur. Cela est souvent utilis&eacute; par les
      <filename>Makefile</filename>s des applications, ainsi l'application
      peut &ecirc;tre install&eacute;e dans le r&eacute;pertoire correct 
      quand elle a &eacute;t&eacute; correctement compil&eacute;e
      </para>

      <para>Il s'agit d'un sujet l&eacute;g&egrave;rement embrouillant &agrave; essayer
      et expliquer.
      Si vous ne comprenez pas bien comment <command>make</command>
      fonctionne, la meilleure chose &agrave; faire est d'&eacute;crire un petit
      programme comme <quote>bonjour monde</quote> et un fichier <filename>Makefile</filename>
      comme le pr&eacute;c&eacute;dent et de le tester. Ensuite continuez en
      utilisant plus d'un fichier source ou en ayant un fichier source
      incluant un fichier d'en-t&ecirc;te. La commande <command>touch</command> est
      tr&egrave;s utile ici&mdash;elle change la date sur un fichier sans avoir
      &agrave; l'&eacute;diter.
      </para>
    </sect2>

    <sect2>
      <title>Les <filename>Makefiles</filename>de FreeBSD</title>

      <para>Les <filename>Makefile</filename>s peuvent &ecirc;tre plut&ocirc;t compliqu&eacute;s
      &agrave; &eacute;crire. Heureusement, les syst&egrave;mes BSD comme FreeBSD sont fournis avec
      des fichiers tr&egrave;s puissants comme partie int&eacute;grante du syst&egrave;me.
      Un tr&egrave;s bon exemple est le syst&egrave;me des logiciels port&eacute;s. Voici
      la partie essentielle d'un <filename>Makefile</filename> typique des logiciels port&eacute;s:
      </para>

      <programlisting>MASTER_SITES=   ftp://freefall.cdrom.com/pub/FreeBSD/LOCAL_PORTS/
DISTFILES=      scheme-microcode+dist-7.3-freebsd.tgz

.include &lt;bsd.port.mk&gt;</programlisting>

      <para>Maintenant, si nous allons dans le r&eacute;pertoire de ce logiciel port&eacute; et
      tapons <userinput>make</userinput>, la chose suivante se passe :
      </para>

      <procedure>
	<step>
	  <para>Une v&eacute;rification est faite pour voir si le code source de ce logiciel port&eacute;
	  est d&eacute;j&agrave; dans le syst&egrave;me.
	  </para>
	</step>

	<step>
	  <para>Si celui-ci n'y est pas, une connexion FTP &agrave; l'URL dans
	  <symbol>MASTER_SITES</symbol> est faite pour t&eacute;l&eacute;charger le source.
	  </para>
	</step>

	<step>
	  <para>La somme de contr&ocirc;le (<literal>checksum</literal>) du source est calcul&eacute;e
	  et compar&eacute;e avec celle d'une bonne et connue copie du source. Cela est fait pour
	  &ecirc;tre s&ucirc;r que le source n'a pas &eacute;t&eacute; corrompu pendant le transfert.
	  </para>
	</step>

	<step>
	  <para>Tout changement requis pour faire fonctionner le source sur FreeBSD est appliqu&eacute;&mdash;
	  cela est connu sous le nom de <firstterm>correctif</firstterm><footnote><para>NDT: On entendra plus souvent parler de 
	  <literal>patch</literal>.</para></footnote>.
	  </para>
	</step>

	<step>
	  <para>Toute configuration sp&eacute;ciale n&eacute;cessaire pour le source est faite.
	  (Beaucoup de distributions de programmes Unix essaye de fonctionner quelle que soit
	  la version d'Unix sur laquelle elles sont compil&eacute;es et quelles que soient les
	  caract&eacute;ristiques optionnelles qui sont pr&eacute;sentes&mdash;c'est ce qui se trouve
	  dans le sc&eacute;nario des logiciels port&eacute;s pour FreeBSD).
	  </para>
	  <!--  A verifier
	  optional Unix features are present&mdash;this is where
	    they are given the information in the FreeBSD ports
	    scenario.</para>
	    -->
	</step>

	<step>
	  <para>Le code source pour ce programme est compil&eacute;. En effet, nous changeons
	  de r&eacute;pertoire pour le r&eacute;pertoire o&ugrave; le source a &eacute;t&eacute;
	  d&eacute;compress&eacute; et faisons <command>make</command>&mdash;le fichier <filename>Makefile</filename> 
	  du programme contient les informations n&eacute;cessaires pour construire le programme.
	  </para>
	</step>

	<step>
	  <para>Nous avons maintenant une version compil&eacute;e du programme. Si nous le d&eacute;sirons,
	  nous pouvons le tester maintenant; quand nous sommes confiant dans le programme, nous pouvons
	  taper <userinput>make install</userinput>. Cela va installer le programme et ses fichiers de
	  soutien n&eacute;cessaires au bon endroit; une entr&eacute;e est aussi cr&eacute;&eacute;e dans
	  la <database>base de donn&eacute;es des logiciels pr&eacute;-compil&eacute;s</database>, ainsi
	  le logiciel port&eacute; peut &ecirc;tre facilement d&eacute;sinstall&eacute; plus tard si
	  nous changeons d'avis sur ce programme.
	  </para>
	</step>
      </procedure>

      <para>Maintenant je pense que vous serez d'accord que c'est plus impressionnant qu'une
      proc&eacute;dure de quatre lignes !
      </para>

      <para>Le secret r&eacute;side dans la derni&egrave;re ligne qui dit &agrave;
      <command>make</command> de regarder dans le <filename>Makefile</filename> syst&egrave;me
      appel&eacute; <filename>bsd.port.mk</filename>. Il est facile de fermer les yeux sur cette
      ligne mais c'est ici que tous les trucs forts se passent&mdash;quelqu'un a &eacute;crit un <filename>Makefile</filename>
      qui dit &agrave; <command>make</command> de faire tout ce qu'il y a au-dessus (plus un couple d'autres choses
      que je n'ai pas mentionn&eacute;es, comme la gestion des erreurs) et n'importe qui peut avoir acc&egrave;s
      &agrave; cela simplement est ajoutant une simple ligne dans son propre fichier <filename>Makefile</filename> !
      </para>

      <para>Si vous voulez jeter un regard sur ces <filename>Makefile</filename>s syst&egrave;me,
      ils se trouvent <filename>/usr/share/mk</filename> mais il est probablement mieux
      d'attendre un moment jusqu'&agrave; ce que vous ayez un peu d'entrainement avec les
      <filename>Makefile</filename>s car ceux-ci sont tr&egrave;s compliqu&eacute;s (et
      si vous les lisez, soyez s&ucirc;r d'avoir un thermos de caf&eacute; fort &agrave; port&eacute;e
      de main !)
      </para>
    </sect2>

    <sect2>
      <title>Utilisations plus avanc&#233;es de <command>make</command></title>

      <para><command>Make</command> est un outil tr&egrave;s puissant et peut
      faire beaucoup plus que le simple exemple pr&eacute;c&eacute;dent ne l'a montr&eacute;.
      Malheureusement, il y a diff&eacute;rentes versions de <command>make</command>
      et elles diff&egrave;rent consid&eacute;rablement.
      Le meilleur moyen d'apprendre ce qu'elles peuvent faire est probablement de lire
      la documentation&mdash;heureusement cette introduction vous donnera la base
      &agrave; partir de laquelle vous pourrez faire cela.
      </para>

      <para>La version de <command>make</command> fournies avec FreeBSD est le
      <application>Berkeley make</application>(make de Berkeley); il y a un cours d'instruction
      pour celui-ci dans <filename>/usr/share/doc/psd/12.make</filename>. Pour le voir, faites
      </para>

      <screen>&prompt.user; <userinput>zmore paper.ascii.gz</userinput>
      </screen>

      <para>dans ce r&eacute;pertoire.</para>

      <para>Beaucoup d'applications dans les logiciels port&eacute;s utilisent 
      <application>GNU make</application>, qui poss&egrave;de un tr&egrave;s bon ensemble de page 
      d'<quote>info</quote>. Si vous avez install&eacute; un de ces logiciels port&eacute;s,
      <application>GNU make</application> aura &eacute;t&eacute; automatiquement install&eacute;
      sous le nom de <command>gmake</command>. Il est aussi disponible comme logiciel port&eacute; ou 
      logiciel pr&eacute;-compil&eacute; seul.
      </para>

      <para>Pour voir les pages d'info pour <application>GNU make</application>, vous devrez
      editer le fichier <filename>dir</filename> dans le r&eacute;pertoire
      <filename>/usr/local/info</filename> pour ajouter une entr&eacute;e pour celui-ci.
      Cela implique d'ajouter une ligne
      </para>

      <programlisting> * Make: (make).                 l'utilitaire GNU Make.</programlisting>

      <para>au fichier. Une fois que vous avez fait ceci, vous pouvez taper
	<userinput>info</userinput> et ensuite s&eacute;lectionner
	<guimenuitem>make</guimenuitem> dans le menu (ou dans <application>Emacs</application>, 
	faites <userinput>C-h i</userinput>).
      </para>

    </sect2>
  </sect1>

  <sect1 id="debugging">
    <title>D&#233;verminer</title>

    <sect2>
      <title>Le d&#233;vermineur</title>

      <para>Le d&eacute;vermineur fourni avec FreeBSD est appel&eacute;
      <command>gdb</command> (<application>GNU
	  debugger</application>). Vous pouvez le d&eacute;marrer en tapant
      </para>

      <screen>&prompt.user; <userinput>gdb <replaceable>nomprog</replaceable></userinput>
      </screen>

      <para>bien que la plupart des gens pr&eacute;f&egrave;rent le d&eacute;marrer au 
      sein d'<application>Emacs</application>. Vous pouvez faire cela avec:
      </para>

      <screen><userinput>M-x gdb RET <replaceable>nomprog</replaceable> RET</userinput>
      </screen>

      <para>Utiliser un d&eacute;vermineur vous permet d'ex&eacute;cuter le programme
      dans des circonstances plus contr&ocirc;l&eacute;es. Typiquement, vous pouvez
      ex&eacute;cuter le programme ligne &agrave; ligne, inspecter la valeur des
      variables, changer cette derni&egrave;re, dire au d&eacute;vermineur d'ex&eacute;cuter jusqu'&agrave;
      un certain point puis de s'arr&ecirc;ter etc... Vous pouvez m&ecirc;me vous brancher
      sur un programme en fonctionnement, ou charger un fichier <filename>core</filename>
      pour enqu&ecirc;ter sur le plantage du programme. Il est m&ecirc;me possible de
      d&eacute;verminer le noyau, quoique ce soit un peu plus rus&eacute; que de
      d&eacute;verminer des applications utilisateur dont nous discuterons
      dans cette section.
      </para>

      <para><command>gdb</command> dispose d'une assez bonne aide en ligne
      comme d'un ensemble de pages d'info, aussi cette section va se concentrer sur
      quelques commandes basiques.
      </para>

      <para>Finalement, si vous trouvez son interface texte non fonctionnelle,
      il y a une interface graphique pour celui-ci, <ulink URL="../../ports/devel.html">xxgdb</ulink>, 
      dans la collection des logiciels port&eacute;s.
      </para>

      <para>Cette section a pour but d'&ecirc;tre une introduction
      &agrave; l'utilisation de <command>gdb</command> et ne couvre pas les sujets
      tr&egrave;s sp&eacute;cialis&eacute;s comme le d&eacute;verminage du noyau.
      </para>
    </sect2>

    <sect2>
      <title>Ex&#233;cuter un programme dans le d&#233;vermineur</title>

      <para>Vous devrez avoir compil&eacute; le programme avec l'option	<option>-g</option>
      pour avoir la meilleure utilisation de <command>gdb</command>. Il fonctionnera sans
      mais vous ne verrez que le nom de la fonction dans laquelle vous vous trouvez plut&ocirc;t
      que son code source. Si vous voyez une ligne comme:
      </para>

      <screen>&hellip; (no debugging symbols found) &hellip;
      </screen>

      <para>quand <command>gdb</command> d&eacute;marre, vous saurez que le programme
      n'a pas &eacute;t&eacute; compil&eacute; avec l'option <option>-g</option>.
      </para>

      <para>A l'invite de <command>gdb</command>, tapez
      <userinput>break main</userinput>. Cela dira au d&eacute;vermineur
      de passer le code pr&eacute;liminaire d'initialisation du programme
      et de d&eacute;marrer au d&eacute;but de votre code. Maintenant tapez
      <userinput>run</userinput> pour d&eacute;marrer le programme&mdash;cela va
      d&eacute;marrer au d&eacute;but du code d'initialisation et ensuite s'arr&ecirc;tera
      lors de l'appel &agrave; <function>main()</function>.
      (Si vous vous &ecirc;tes toujours demand&eacute; o&ugrave; <function>main()</function>
      &eacute;tait appel&eacute;, maintenant vous le savez !).
      </para>

      <para>Vous pouvez maintenant vous d&eacute;placer dans le programme ligne par ligne en
      pressant <command>n</command>. Si vous arrivez &agrave; l'appel d'une fonction,
      vous pouvez entrer dans celle-ci en appuyant sur <command>s</command>. Une fois
      que vous &ecirc;tes dans l'appel de la fonction, vous pouvez retourner dans le code
      appelant en appuyant sur <command>f</command>. Vous pouvez aussi utiliser
      <command>up</command> et <command>down</command> pour avoir une vue rapide de l'appelant.
      </para>

      <para>Voici un exemple simple de comment d&eacute;tecter une erreur dans un programme avec
      <command>gdb</command>. Voici notre programme (avec une erreur d&eacute;lib&eacute;r&eacute;e):
      </para>

      <programlisting>#include &lt;stdio.h&gt;

int bazz(int anint);

main() {
	int i;

	printf("C'est mon programme\n");
	bazz(i);
	return 0;
}

int bazz(int anint) {
	printf("Vous m'avez fourni %d\n", anint);
	return anint;
}</programlisting>

      <para>Le programme met <symbol>i</symbol> &agrave; <literal>5</literal> et le passe &agrave; une
      fonction <function>bazz()</function> qui imprime le nombre que nous lui avons donn&eacute;.
      </para>

      <para>Puis nous compilons et ex&eacute;cutons le programme obtenu
      </para>

      <screen>&prompt.user; <userinput>cc -g -o temp temp.c</userinput>
&prompt.user; <userinput>./temp</userinput>
C'est mon programme
Vous m'avez fourni 4231
      </screen>

      <para>Ce n'&eacute;tait pas ce que nous attendions ! Il est temps de voir ce qui se passe !
      </para>

      <screen>&prompt.user; <userinput>gdb temp</userinput>
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.13 (i386-unknown-freebsd), Copyright 1994 Free Software Foundation, Inc.
(gdb) <userinput>break main</>				<lineannotation>passe le code d'initialisation</>
Breakpoint 1 at 0x160f: file temp.c, line 9.	<lineannotation><command>gdb</command> met un point d'arr&ecirc;t sur <function>main()</></>
(gdb) <userinput>run</>					<lineannotation>Ex&eacute;cute jusqu'&agrave; <function>main()</></>
Starting program: /home/james/tmp/temp		<lineannotation>Le programme d&eacute;marre</>

Breakpoint 1, main () at temp.c:9		<lineannotation><command>gdb</command> s'arr&ecirc;te &agrave; <function>main()</></>
(gdb) <userinput>n</>						<lineannotation>Va &agrave; la ligne suivante</>
C'est mon programme				<lineannotation>Le programme &eacute;crit</>
(gdb) <userinput>s</>						<lineannotation>entre dans <function>bazz()</></>
bazz (anint=4231) at temp.c:17			<lineannotation><command>gdb</command> montre la pile</>
(gdb)
      </screen>

      <para>Arr&ecirc;tons-nous une minute! Comment <symbol>anint</symbol> a eu la valeur
      <literal>4231</literal>? Ne l'avons-nous pas mis &agrave; <literal>5</literal> 
      dans <function>main()</function>? Remontons dans <function>main()</function> 
      et regardons.
      </para>

      <screen>(gdb) <userinput>up</>					<lineannotation>Remonte la pile des appels</>
#1  0x1625 in main () at temp.c:11		<lineannotation><command>gdb</command> montre la pile</>
(gdb) <userinput>p i</>					<lineannotation>Montre la valeur de <symbol>i</></>
$1 = 4231					<lineannotation><command>gdb</command> montre <literal>4231</></>
      </screen>

      <para>Oh ! En regardant dans le code, nous avons oubli&eacute; d'initialiser <symbol>i</symbol>.
      Nous aurions d&ucirc; mettre
      </para>

      <programlisting><lineannotation>&hellip;</>
main() {
	int i;

	i = 5;
	printf("C'est mon programme\n");
<lineannotation>&hellip</></programlisting>

      <para>mais nous n'avions pas mis la ligne <literal>i=5;</literal>. Comme
      nous n'avons pas initialis&eacute; <symbol>i</symbol>, il a pris le nombre se trouvant
      dans la zone de m&eacute;moire quand le programme a d&eacute;marr&eacute;,
      ce qui dans ce cas &eacute;tait <literal>4231</literal>.
      </para>

      <note>
	<para><command>gdb</command> montre la pile chaque fois que nous entrons ou sortons
	d'une fonction, m&ecirc;me si nous avons utilis&eacute;	<command>up</command> et
	<command>down</command> pour nous d&eacute;placer dans la pile des appels.
	Cela montre le nom de la fonction et les valeurs de ses arguments, ce qui nous aide
	&agrave; garder une trace d'o&ugrave; nous sommes et de ce qui se passe.
	(La pile est une zone de stockage o&ugrave; le programme stocke les informations
	sur les arguments pass&eacute;s aux fonctions et o&ugrave; il doit aller
	quand il revient d'une fonction).
	</para>
      </note>
    </sect2>

    <sect2>
      <title>Examiner un fichier <filename>core</filename></title>

      <para>Un fichier <filename>core</filename> est basiquement un fichier qui contient
      l'&eacute;tat complet du processus quand il s'est plant&eacute;.
      Dans <quote>le bon vieux temps</quote>, les programmeurs devait imprimer des
      listings en hexad&eacute;cimal de fichiers <filename>core</filename> et transpirer
      sur leur manuels de code machine, mais la vie est maintenant un peu plus facile.
      Par chance, sous FreeBSD et les autres syst&egrave;mes 4.4BSD, un fichier <filename>core</filename>
      est appel&eacute; <filename><replaceable>nomprog</replaceable>.core</filename> 
      plut&ocirc;t que juste <filename>core</filename>, pour mieux savoir &agrave; quel
      programme appartient un fichier <filename>core</filename>.
      </para>

      <para>Pour examiner un fichier <filename>core</filename>, d&eacute;marrez <command>gdb</command> 
      de fa&ccedil;on habituel. Plut&ocirc;t que de taper <command>break</command> ou 
      <command>run</command>, tapez
      </para>

      <screen>(gdb) <userinput>core <replaceable>nomprog</replaceable>.core</userinput>
      </screen>

      <para>Si vous n'&ecirc;tes pas dans le m&ecirc;me r&eacute;pertoire que le fichier
      <filename>core</filename>, vous devrez faire <userinput>dir /path/to/core/file</userinput>
      d'abord.
      </para>

      <para>Vous devriez voir quelque chose comme cela:
      </para>

      <screen>&prompt.user; <userinput>gdb a.out</userinput>
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.13 (i386-unknown-freebsd), Copyright 1994 Free Software Foundation, Inc.
(gdb) <userinput>core a.out.core</userinput>
Core was generated by `a.out'.
Program terminated with signal 11, Segmentation fault.
Cannot access memory at address 0x7020796d.
#0  0x164a in bazz (anint=0x5) at temp.c:17
(gdb)
      </screen>

      <para>Dans ce cas, le programme a &eacute;t&eacute; appel&eacute;	<filename>a.out</filename>, 
      aussi le fichier <filename>core</filename> s'appelle <filename>a.out.core</filename>. 
      Nous pouvons voir que le programme s'est plant&eacute; car il a essay&eacute; 
      d'acc&egrave;der &agrave; une zone dans la m&eacute;moire qui n'&eacute;tait pas
      disponible dans la fonction appel&eacute;e <function>bazz</function>.
      </para>

      <para>Quelquefois il est utile de pouvoir voir comment une fonction a &eacute;t&eacute; 
      appel&eacute;e car le probl&egrave;me peut avoir eu lieu bien avant
      dans la pile des appels dans un programme complexe. La commande <command>bt</command>
      demande &agrave; <command>gdb</command> d'afficher une trace inverse de la pile
      des appels:
      </para>

      <screen>(gdb) <userinput>bt</userinput>
#0  0x164a in bazz (anint=0x5) at temp.c:17
#1  0xefbfd888 in end ()
#2  0x162c in main () at temp.c:11
(gdb)
      </screen>

      <para>La fonction <function>end()</function> est appel&eacute;e lorsque le programme se plante;
      dans ce cas, la fonction <function>bazz()</function> a &eacute;t&eacute; appel&eacute;e 
      <function>main()</function>.
      </para>
    </sect2>

    <sect2>
      <title>Se brancher sur un programme en cours d'ex&#233;cution</title>

      <para>Une des plus belles caract&eacute;ristiques de <command>gdb</command>
      est qu'il peut se brancher sur un programme qui s'ex&eacute;cute d&eacute;j&agrave;.
      Bien s&ucirc;r, cela suppose que vous ayez les privil&egrave;ges suffisants pour
      le faire. Un probl&egrave;me habituel est quand vous vous d&eacute;placez dans
      un programme qui se d&eacute;double et que vous voulez tracer le programme fils
      cependant le d&eacute;vermineur ne vous laissera seulement tracer le p&egrave;re.
      </para>

      <para>Ce que vous devez faire est de d&eacute;marrer un autre <command>gdb</command>,
      utiliser <command>ps</command> pour trouver l'ID du processus fils et faire
      </para>

      <screen>(gdb) <userinput>attach <replaceable>identifiant_processus</replaceable></userinput>
      </screen>

      <para>dans <command>gdb</command>, et d&eacute;verminer ensuite comme d'habitude.
      </para>

      <para><quote>C'est tout simple,</quote> pensez-vous certainement,<quote>
      mais pendant le temps que je faisais &ccedil;a, le processus fils
      sera d&eacute;j&agrave; parti loin</quote>. Ne vous en faites pas,
      noble lecteur, voici comment faire (avec l'appui des pages d'info
      de <command>gdb</command>):
      </para>

      <screen><lineannotation>&hellip</lineannotation>
if ((pid = fork()) < 0)		/* _Toujours_ verifier cela */
	error();
else if (pid == 0) {		/* le fils */
	int PauseMode = 1;

	while (PauseMode)
		sleep(10);	/* Attendre jusqu'a ce que quelqu'un se brache sur nous */
	<lineannotation>&hellip</lineannotation>
} else {			/* le pere */
	<lineannotation>&hellip</lineannotation>
      </screen>

      <para>Maintenant tout ce que nous avons &agrave; faire est de nous brancher sur le processus fils,
      de mettre <symbol>PauseMode</symbol> &agrave; <literal>0</literal> et d'attendre
      que l'appel &agrave; la fonction <function>sleep()</function> retourne !
      </para>
    </sect2>
  </sect1>

  <sect1 id="emacs">
    <title>Utiliser Emacs comme environnement de d&#233;veloppement</title>

    <sect2>
      <title>Emacs</title>

      <para>Malheureusement, les syst&egrave;mes Unix ne sont pas fournis avec des sortes
      d'environnements de d&eacute;veloppement int&eacute;gr&eacute;s 
      tout-ce-que-vous-avez-toujours-voulu-et-beaucoup-plus-dans-un-ensemble-gigantesque
      que d'autres syt&egrave;mes ont.

	<footnote>
	  <para>Sauf si vous payez des sommes importantes.
	  </para>
	</footnote>

	Toutefois, il est possible de se faire son propre environnement.
	Cela n'est pas forc&eacute;ment aussi joli et il peut ne pas &ecirc;tre
	autant int&eacute;gr&eacute; mais vous pouvez le personnaliser comme
	vous voulez. Et c'est gratuit. Et vous en avez les sources.
	</para>

      <para>La cl&eacute; de tout cela est Emacs. Maintenant il y a des gens qui le d&eacute;testent, 
      mais beaucoup l'aiment. Si vous &ecirc;tes un du premier groupe, j'ai peur que cette section
      ait peu d'int&eacute;r&ecirc;t pour vous. Vous aurez besoin d'une quantit&eacute;
      moyenne de m&eacute;moire pour le faire fonctionner&mdash;Je recommenderai 8Mo en mode
      texte et 16Mo dans X pour avoir un minimum de performances.
      </para>

      <para>Emacs est basiquement un &eacute;diteur hautement personnalisable
      &mdash;en effet, il a &eacute;t&eacute; personnalis&eacute; au point de ressembler
      plus &agrave; un syst&egrave;me d'exploitation qu'&agrave; un &eacute;diteur!
      Beaucoup de d&eacute;veloppeurs et d'administrateurs syst&egrave;me passent
      en fait pratiquement tout leur temps &agrave; travailler dans Emacs, 
      en ne le quittant qu'&agrave; leur d&eacute;connexion.
      </para>

      <para>Il est impossible de dire tout ce qu'Emacs peut faire ici,
      mais voici quelques unes des caract&eacute;ristiques d'int&eacute;r&ecirc;t
      pour les d&eacute;veloppeurs:
      </para>

      <itemizedlist>
	<listitem>
	  <para>Un tr&egrave;s puissant &eacute;diteur, permettant le chercher-remplacer sur
	  les cha&icirc;nes et les expressions r&eacute;guli&egrave;res (motifs),
	  sauter &agrave; la fin ou au d&eacute;but d'un bloc, etc, etc.
	  </para>
	</listitem>

	<listitem>
	  <para>Menus d&eacute;roulants et aide en ligne.
	  </para>
	</listitem>

	<listitem>
	  <para>Colorisation syntaxique en fonction du langage et indentation.
	  </para>
	</listitem>

	<listitem>
	  <para>Totalement personnalisable.
	  </para>
	</listitem>

	<listitem>
	  <para>Vous pouvez compiler et d&eacute;verminer des programmes dans Emacs.
	  </para>
	</listitem>

	<listitem>
	  <para>Sur erreur de compilation, vous pouvez aller directement
	  &agrave; la ligne de code source fautive.
	  </para>
	</listitem>

	<listitem>
	  <para>Une interface amicale au programme <command>info</command>
	  utilis&eacute; pour lire la documentation hypertexte GNU,
	  incluant la documentation sur Emacs elle-m&ecirc;me.
	  </para>
	</listitem>

	<listitem>
	  <para>Une interface agr&eacute;able &agrave; <command>gdb</command>, vous permettant
	  de voir le code source au fur et &agrave; mesure que vous vous d&eacute;placez
	  dans votre programme.
	  </para>
	</listitem>

	<listitem>
	  <para>Vous pouvez lire les nouvelles Usenet et envoyer des e-mails pendant que
	  votre programme est en compilation.
	  </para>
	</listitem>
      </itemizedlist>

      <para>Et sans doute beaucoup plus que je n'ai survol&eacute;.
      </para>

      <para>Emacs peut &ecirc;tre install&eacute; sur FreeBSD en utilisant Emacs 
      <ulink URL="../../ports/editors.html">le logiciel port&eacute; Emacs</ulink>.
      </para>

      <para>Une fois install&eacute;, d&eacute;marrez-le et faites <userinput>C-h t</userinput>
      pour lire un cours sur Emacs&mdash;cela signifie maintenir la touche <keycap>control</keycap>,
      presser <keycap>h</keycap>, rel&acirc;cher la touche <keycap>control</keycap>
      et presser <keycap>t</keycap>. (Alternativement, vous pouvez utiliser la souris
      pour s&eacute;lectionner <guimenuitem>Emacs Tutorial</guimenuitem> dans le menu
      <guimenu>Help</guimenu>).
      </para>

      <para>Bien que Emacs poss&egrave;de des menus, il est valable d'apprendre les raccourcis
      clavier, &eacute;tant plus rapide quand vous &eacute;ditez quelque chose
      d'appuyer sur un couple de touches que de reprendre la souris et de cliquer
      au bon endroit. Et, quand vous discutez avec des utilisateurs exp&eacute;riment&eacute;s
      d'Emacs, vous trouverez qu'ils parlent souvent de choses comme
      <quote><literal>M-x replace-s RET foo RET bar RET</literal></quote> aussi il est utile
      de savoir ce que cela veut dire. Et dans tous les cas, Emacs poss&egrave;de beaucoup trop
      de fonctions pour qu'elles soient dans les barres de menus.
      </para>

      <para>Heureusement, il est assez simple de r&eacute;cup&eacute;rer les raccourcis
      clavier car ils sont affich&eacute;s &agrave; c&ocirc;t&eacute; des &eacute;l&eacute;ments
      des menus d&eacute;roulants. Mon conseil est d'utiliser un &eacute;l&eacute;ment de menu
      pour, disons, ouvrir un fichier jusqu'&agrave; ce que vous sachiez comment cela fonctionne
      et que quand vous vous sentez &agrave; l'aise avec, essayez <userinput>C-x C-f</userinput>.
      Quand vous serez content avec &ccedil;a, passez &agrave; une autre commande du menu.
      </para>

      <para>Si vous ne pouvez pas vous rappeler de ce qu'une combinaison de touches particuli&egrave;res
      fait, s&eacute;lectionnez <guimenuitem>Describe Key</guimenuitem> dans le menu
      <guimenu>Help</guimenu> et tapez-la&mdash;Emacs vous dira ce qu'elle fait.
      Vous pouvez aussi utiliser l'&eacute;l&eacute;ment de menu <guimenuitem>Command Apropos</guimenuitem>
      pour trouver toutes les commandes qui contiennent un mot particulier, avec leur
      raccourci clavier.
      </para>

      <para>De cette mani&egrave;re, l'expression ci-dessus signifie maintenir la touche
      <keysym>Meta</keysym>, taper <keysym>x</keysym>, rel&acirc;cher 
      la touche <keysym>Meta</keysym>, taper <userinput>replace-s</userinput> 
      (raccourci pour <literal>replace-string</literal>&mdash;
      une autre caract&eacute;ristique d'Emacs est que vous pouvez abr&eacute;ger
      les commandes), appuyer sur la touche <keysym>Entr&eacute;e</keysym>, taper
      <userinput>foo</userinput> (la cha&icirc;ne que vous voulez remplacer), presser
      la touche <keysym>Entr&eacute;e</keysym>, taper <userinput>bar</userinput> (la cha&icirc;ne
      que vous voulez substituer &agrave; <literal>foo</literal>) puis appuyer sur
      <keysym>Entr&eacute;e</keysym> une derni&egrave;re fois. Emacs va alors faire 
      l'op&eacute;ration chercher-remplacer que vous avez demand&eacute;.
      </para>

      <para>Si vous vous demandez ce qu'est cette touche <keysym>Meta</keysym>,
      il s'agit d'une touche sp&eacute;ciale que beaucoup de stations de travail Unix
      poss&egrave;dent. Malheureusement, les PC n'en ont pas, aussi c'est habituellement
      la touche <keycap>alt</keycap> (ou si vous n'avez pas de chance, la touche <keysym>&eacute;chap</keysym>).
      </para>

      <para>Oh, et pour sortir d'Emacs, faites <command>C-x C-c</command>
      (ce qui signifie maintenir la touche <keysym>control</keysym> appuy&eacute;e,
      appuyer <keysym>c</keysym> et rel&acirc;cher la touche <keysym>control</keysym>.
      Si vous avez des fichiers non sauvegard&eacute;s ouverts, Emacs vous demandera si
      vous voulez les sauvegarder. (Ignorez le bout de documentation o&ugrave; il est dit
      que <command>C-z</command> est la mani&egrave;re habituelle de quitter Emacs&mdash;
      qui quitte Emacs en le laissant tourner en t&acirc;che de fond et qui n'est
      vraiment utile que si vous avez un syst&egrave;me sans terminal virtuel).
      </para>
    </sect2>

    <sect2>
      <title>Configurer Emacs</title>

      <para>Emacs fait des choses merveilleuses; une partie est int&eacute;gr&eacute;e
      directement, une autre doit &ecirc;tre configur&eacute;e.
      </para>

      <para>Plut&ocirc;t que d'utiliser un macro langage propri&eacute;taire pour la configuration,
      Emacs utilise une version du Lisp sp&eacute;cialement adapt&eacute;e pour les
      &eacute;diteurs, connue sous le nom d'Emacs Lisp. Celui-ci peut &ecirc;tre assez utile si
      vous voulez poursuivre et apprendre quelque chose comme le Common Lisp,
      car il est consid&eacute;rablement plus petit que le Common Lisp (bien que
      d&eacute;j&agrave; assez gros!).
      </para>

      <para>La meilleure fa&ccedil;on d'apprendre l'Emacs Lisp est de t&eacute;l&eacute;charger
      le <ulink URL="ftp://prep.ai.mit.edu:pub/gnu/elisp-manual-19-2.4.tar.gz">cours d'Emacs</ulink>
      </para>

      <para>Toutefois, il n'y a pas besoin de conna&icirc;tre le Lisp pour commencer
      la configuration d'Emacs, car j'ai inclus un exemple de fichier <filename>.emacs</filename>
      qui devrait &ecirc;tre suffisant pour commencer. Copiez juste celui-ci dans votre
      r&eacute;pertoire utilisateur et red&eacute;marrez Emacs si celui-ci s'ex&eacute;cute,
      il lira les commandes du fichier et (si tout va bien!) vous donnera une configuration
      basique utile.
      </para>
    </sect2>

    <sect2>
      <title>Un fichier exemple <filename>.emacs</filename></title>

      <para>Malheureusement, il y a beaucoup trop de choses ici pour les expliquer en d&eacute;tail;
      toutefois, il y a un ou deux points qui valent d'&ecirc;tre mentionn&eacute;s.
      </para>

      <itemizedlist>
	<listitem>
	  <para>Tout ce qui commence avec un <literal>;</literal> est un commentaire et est
	  ignor&eacute; par Emacs.
	  </para>
	</listitem>

	<listitem>
	  <para>A la premi&egrave;re ligne, le <literal>-*-&nbsp;Emacs-Lisp&nbsp;-*-</literal> 
	  est tel que vous pouvez &eacute;diter le fichier <filename>.emacs</filename> lui-m&ecirc;me
	  &agrave; l'int&eacute;rieur d'Emacs et d'obtenir tous les fantaisistes dispositifs
	  pour l'&eacute;dition en Emacs Lisp. Emacs essaye habituellement de deviner cela
	  en se basant sur le nom du fichier, et ne trouvera peut-&ecirc;tre pas pour
	  <filename>.emacs</filename>.
	  </para>
	</listitem>

	<listitem>
	  <para>La touche <keysym>tab</keysym> est li&eacute;e &agrave; la fonction d'indentation
	  dans certains modes, aussi quand vous l'enfoncez, cela va indenter la ligne courante
	  de code. Si vous voulez mettre un caract&egrave;re <token>tab</token> dans quoique ce soit
	  que vous tapiez, maintenez la touche <keysym>control</keysym> enfonc&eacute;e pendant
	  que vous appuyez sur <keysym>tab</keysym>.
	  </para>
	</listitem>

	<listitem>
	  <para>Ce fichier supporte la colorisation de syntaxe pour les langages C, C++, Perl, Lisp
	  et Scheme en devinant le langage par leur nom.
	  </para>
	</listitem>

	<listitem>
	  <para>Emacs poss&egrave;de d&eacute;j&agrave; une fonction pr&eacute;-d&eacute;finie
	  appel&eacute;e <function>next-error</function>.  Dans la fen&ecirc;tre de sortie d'une
	  compilation, cela vous permet de vous d&eacute;placer d'une erreur de compilation
	  &agrave; la suivante en faisant <command>M-n</command>; nous d&eacute;finissons une
	  fonction compl&eacute;mentaire <function>previous-error</function>, qui vous permet
	  d'aller &agrave; l'erreur pr&eacute;c&eacute;dente en faisant <command>M-p</command>.
	  Le plus beau dispositif de tous est que <command>C-c C-c</command>
	  va ouvrir le fichier source dans lequel l'erreur a eu lieu et sautera &agrave; la ligne
	  appropri&eacute;e.
	  </para>
	</listitem>

	<listitem>
	  <para>Nous autorisons la capacit&eacute; d'Emacs &agrave; agir comme un serveur
	  ainsi si vous faites quelque chose en dehors d'Emacs et voulez &eacute;diter un
	  fichier, tapez juste
	  </para>

	  <screen>&prompt.user; <userinput>emacsclient <replaceable>nomfichier</replaceable></userinput>
	  </screen>

	  <para>et alors vous pouvez &eacute;diter le fichier dans votre Emacs!
	  <footnote>
	  <para>Beaucoup d'utilisateurs d'Emacs mettent leur variable d'environnement
	  <envar>EDITOR</envar> &agrave; <literal>emacsclient</literal> ainsi cela se passe
	  &agrave; chaque fois qu'ils ont besoin d'&eacute;diter un fichier.
	  </para>
	  </footnote>
	  </para>
	</listitem>
      </itemizedlist>

      <example>
	<title>Un fichier exemple <filename>.emacs</filename></title>

	<programlisting>;; -*-Emacs-Lisp-*-

;; Ce fichier est concu pour etre reevalue, utiliser la variable first-time
;; pour eviter tout probleme.
(defvar first-time t 
  "Valeur signifiant que c'est la premiere fois que .emacs a ete evalue"
  )

;; Meta
(global-set-key "\M- " 'set-mark-command)
(global-set-key "\M-\C-h" 'backward-kill-word)
(global-set-key "\M-\C-r" 'query-replace)
(global-set-key "\M-r" 'replace-string)
(global-set-key "\M-g" 'goto-line)
(global-set-key "\M-h" 'help-command)

;; Function keys
(global-set-key [f1] 'manual-entry)
(global-set-key [f2] 'info)
(global-set-key [f3] 'repeat-complex-command)
(global-set-key [f4] 'advertised-undo)
(global-set-key [f5] 'eval-current-buffer)
(global-set-key [f6] 'buffer-menu)
(global-set-key [f7] 'other-window)
(global-set-key [f8] 'find-file)
(global-set-key [f9] 'save-buffer)
(global-set-key [f10] 'next-error)
(global-set-key [f11] 'compile)
(global-set-key [f12] 'grep)
(global-set-key [C-f1] 'compile)
(global-set-key [C-f2] 'grep)
(global-set-key [C-f3] 'next-error)
(global-set-key [C-f4] 'previous-error)
(global-set-key [C-f5] 'display-faces)
(global-set-key [C-f8] 'dired)
(global-set-key [C-f10] 'kill-compilation)

;; Keypad bindings
(global-set-key [up] "\C-p")
(global-set-key [down] "\C-n")
(global-set-key [left] "\C-b")
(global-set-key [right] "\C-f")
(global-set-key [home] "\C-a")
(global-set-key [end] "\C-e")
(global-set-key [prior] "\M-v")
(global-set-key [next] "\C-v")
(global-set-key [C-up] "\M-\C-b")
(global-set-key [C-down] "\M-\C-f")
(global-set-key [C-left] "\M-b")
(global-set-key [C-right] "\M-f")
(global-set-key [C-home] "\M-&lt;")
(global-set-key [C-end] "\M-&gt;")
(global-set-key [C-prior] "\M-&lt;")
(global-set-key [C-next] "\M-&gt;")

;; Souris
(global-set-key [mouse-3] 'imenu)

;; Divers
(global-set-key [C-tab] "\C-q\t")	; Control tab quotes a tab.
(setq backup-by-copying-when-mismatch t)

;; Traite 'y' ou &lt;CR&gt; comme yes, 'n' comme no.
(fset 'yes-or-no-p 'y-or-n-p)
    (define-key query-replace-map [return] 'act)
    (define-key query-replace-map [?\C-m] 'act)

;; Charge les ajouts
(require 'desktop)
(require 'tar-mode)

;; Diff mode sympa
(autoload 'ediff-buffers "ediff" "Intelligent Emacs interface to diff" t)
(autoload 'ediff-files "ediff" "Intelligent Emacs interface to diff" t)
(autoload 'ediff-files-remote "ediff"
  "Intelligent Emacs interface to diff")

(if first-time
    (setq auto-mode-alist
	  (append '(("\\.cpp$" . c++-mode)
		    ("\\.hpp$" . c++-mode)
                    ("\\.lsp$" . lisp-mode)
		    ("\\.scm$" . scheme-mode)
		    ("\\.pl$" . perl-mode)
		    ) auto-mode-alist)))

;; Mode de verrouillage automatique de la police de caracteres
(defvar font-lock-auto-mode-list 
  (list 'c-mode 'c++-mode 'c++-c-mode 'emacs-lisp-mode 'lisp-mode 'perl-mode 'scheme-mode)
  "List of modes to always start in font-lock-mode")

(defvar font-lock-mode-keyword-alist
  '((c++-c-mode . c-font-lock-keywords)
    (perl-mode . perl-font-lock-keywords))
  "Associations between modes and keywords")

(defun font-lock-auto-mode-select ()
  "Automatically select font-lock-mode if the current major mode is
in font-lock-auto-mode-list"
  (if (memq major-mode font-lock-auto-mode-list) 
      (progn
	(font-lock-mode t))
    )
  )

(global-set-key [M-f1] 'font-lock-fontify-buffer)

;; New dabbrev stuff
;(require 'new-dabbrev)
(setq dabbrev-always-check-other-buffers t)
(setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
(add-hook 'emacs-lisp-mode-hook
	  '(lambda () 
	     (set (make-local-variable 'dabbrev-case-fold-search) nil)
	     (set (make-local-variable 'dabbrev-case-replace) nil)))
(add-hook 'c-mode-hook
	  '(lambda () 
	     (set (make-local-variable 'dabbrev-case-fold-search) nil)
	     (set (make-local-variable 'dabbrev-case-replace) nil)))
(add-hook 'text-mode-hook
	  '(lambda () 
	     (set (make-local-variable 'dabbrev-case-fold-search) t)
	     (set (make-local-variable 'dabbrev-case-replace) t)))

;; mode C++ et C...
(defun my-c++-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (define-key c++-mode-map "\C-ce" 'c-comment-edit)
  (setq c++-auto-hungry-initial-state 'none)
  (setq c++-delete-function 'backward-delete-char)
  (setq c++-tab-always-indent t)
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c++-empty-arglist-indent 4))

(defun my-c-mode-hook ()
  (setq tab-width 4)
  (define-key c-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (define-key c-mode-map "\C-ce" 'c-comment-edit)
  (setq c-auto-hungry-initial-state 'none)
  (setq c-delete-function 'backward-delete-char)
  (setq c-tab-always-indent t)
;; Style d'indentation BSD
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c-brace-offset -4)
  (setq c-argdecl-indent 0)
  (setq c-label-offset -4))

;; mode Perl
(defun my-perl-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (setq perl-indent-level 4)
  (setq perl-continued-statement-offset 4))

;; mode Scheme...
(defun my-scheme-mode-hook ()
  (define-key scheme-mode-map "\C-m" 'reindent-then-newline-and-indent))

;; mode Emacs-Lisp...
(defun my-lisp-mode-hook ()
  (define-key lisp-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (define-key lisp-mode-map "\C-i" 'lisp-indent-line)
  (define-key lisp-mode-map "\C-j" 'eval-print-last-sexp))

;; Ajoute tout le reste...
(add-hook 'c++-mode-hook 'my-c++-mode-hook)
(add-hook 'c-mode-hook 'my-c-mode-hook)
(add-hook 'scheme-mode-hook 'my-scheme-mode-hook)
(add-hook 'emacs-lisp-mode-hook 'my-lisp-mode-hook)
(add-hook 'lisp-mode-hook 'my-lisp-mode-hook)
(add-hook 'perl-mode-hook 'my-perl-mode-hook)

;; Le complement a next-error
(defun previous-error (n)
  "Visit previous compilation error message and corresponding source code."
  (interactive "p")
  (next-error (- n)))

;; Divers...
(transient-mark-mode 1)
(setq mark-even-if-inactive t)
(setq visible-bell nil)
(setq next-line-add-newlines nil)
(setq compile-command "make")
(setq suggest-key-bindings nil)
(put 'eval-expression 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'set-goal-column 'disabled nil)

;; Recherche des archives Elisp
(autoload 'format-lisp-code-directory "lispdir" nil t)
(autoload 'lisp-dir-apropos "lispdir" nil t)
(autoload 'lisp-dir-retrieve "lispdir" nil t)
(autoload 'lisp-dir-verify "lispdir" nil t)

;; Mode de verrouillage de police
(defun my-make-face (face colour &amp;optional bold)
  "Create a face from a colour and optionally make it bold"
  (make-face face)
  (copy-face 'default face)
  (set-face-foreground face colour)
  (if bold (make-face-bold face))
  )

(if (eq window-system 'x)
    (progn
      (my-make-face 'blue "blue")
      (my-make-face 'red "red")
      (my-make-face 'green "dark green")
      (setq font-lock-comment-face 'blue)
      (setq font-lock-string-face 'bold)
      (setq font-lock-type-face 'bold)
      (setq font-lock-keyword-face 'bold)
      (setq font-lock-function-name-face 'red)
      (setq font-lock-doc-string-face 'green)
      (add-hook 'find-file-hooks 'font-lock-auto-mode-select)

      (setq baud-rate 1000000)
      (global-set-key "\C-cmm" 'menu-bar-mode)
      (global-set-key "\C-cms" 'scroll-bar-mode)
      (global-set-key [backspace] 'backward-delete-char)
					;      (global-set-key [delete] 'delete-char)
      (standard-display-european t)
      (load-library "iso-transl")))

;; X11 ou PC utilisant les ecritures directes a l'ecran
(if window-system
    (progn
      ;;      (global-set-key [M-f1] 'hilit-repaint-command)
      ;;      (global-set-key [M-f2] [?\C-u M-f1])
      (setq hilit-mode-enable-list  
	    '(not text-mode c-mode c++-mode emacs-lisp-mode lisp-mode
		  scheme-mode)
	    hilit-auto-highlight nil
	    hilit-auto-rehighlight 'visible
	    hilit-inhibit-hooks nil
	    hilit-inhibit-rebinding t)
      (require 'hilit19)
      (require 'paren))
  (setq baud-rate 2400)			; For slow serial connections
  )

;; Terminal de type TTY
(if (and (not window-system) 
	 (not (equal system-type 'ms-dos)))
    (progn
      (if first-time
	  (progn
	    (keyboard-translate ?\C-h ?\C-?)
	    (keyboard-translate ?\C-? ?\C-h)))))

;; Sous Unix
(if (not (equal system-type 'ms-dos))
    (progn
      (if first-time
	  (server-start))))

;; Add any face changes here
(add-hook 'term-setup-hook 'my-term-setup-hook)
(defun my-term-setup-hook ()
  (if (eq window-system 'pc)
      (progn
;;	(set-face-background 'default "red")
	)))

;; Restaure le  "desktop" - faire cela le plus tard possible
(if first-time
    (progn
      (desktop-load-default)
      (desktop-read)))

;; Indique que ce fichier a ete lu au moins une fois
(setq first-time nil)

;; Pas besoin de deverminer quoique ce soit maintenant

(setq debug-on-error nil)

;; Tout est fait
(message "All done, %s%s" (user-login-name) ".")
	</programlisting>
      </example>
    </sect2>

    <sect2>
      <title>Etendre la palette de langages qu'Emacs comprend</title>

      <para>Maintenant, Emacs est tr&egrave;s bien si vous voulez seulement programmer
      dans des langages d&eacute;j&agrave; fournis dans le fichier <filename>.emacs</filename> 
      (C, C++, Perl, Lisp et Scheme), mais qu'arrive-t-il si un nouveau langage appel&eacute;
      <quote>whizbang</quote> sort, plein d'excitantes fonctionnalit&eacute;s ?
      </para>

      <para>La premi&egrave;re chose &agrave; faire est de savoir si whizbang est fourni avec
      des fichiers de configuration pour Emacs. Ceux-ci se terminent habituellement
      par <filename>.el</filename>, raccourci pour <quote>Emacs Lisp</quote>.
      Par exemple, si whizbang est un logiciel port&eacute; FreeBSD, nous pouvons
      localiser ces fichiers en faisant
      </para>

      <screen>&prompt.user; <userinput>find /usr/ports/lang/whizbang -name "*.el" -print</userinput>
      </screen>

      <para>et les installer en les copiant dans le r&eacute;pertoire Lisp d'Emacs.
      Sur FreeBSD 2.1.0-RELEASE, il s'agit de <filename>/usr/local/share/emacs/site-lisp</filename>
      <footnote><para>NDT : Sur FreeBSD 4.2-RELEASE aussi.</para></footnote>.
      </para>

      <para>Aisni par exemple, si la sortie de la commande <command>find</command> &eacute;tait
      </para>

      <screen>/usr/ports/lang/whizbang/work/misc/whizbang.el
      </screen>

      <para>nous ferions
      </para>

      <screen>&prompt.root; <userinput>cp /usr/ports/lang/whizbang/work/misc/whizbang.el /usr/local/share/emacs/site-lisp</userinput>
      </screen>

      <para>Ensuite, nous devons d&eacute;cider quel extension les fichiers source whizbang ont. Disons
      qu'il s'agit de fichiers se terminant par <filename>.wiz</filename>. Nous devons
      ajouter une entr&eacute;e dans notre fichier <filename>.emacs</filename> pour &ecirc;tre s&ucirc;r
      qu'Emacs sera capable d'utiliser les informations dans <filename>whizbang.el</filename>.
      </para>

      <para>Trouvez l'entr&eacute;e <symbol>auto-mode-alist</symbol> dans
      <filename>.emacs</filename> et ajoutez une ligne pour whizbang, comme :
      </para>

      <programlisting><lineannotation>&hellip;</>
("\\.lsp$" . lisp-mode)
("\\.wiz$" . whizbang-mode)
("\\.scm$" . scheme-mode)
<lineannotation>&hellip;</></programlisting>

      <para>Cela signifie qu'Emacs ira automatiquement dans la fonction
      <function>whizbang-mode</function> quand vous &eacute;diterez un fichier se terminant
      par <filename>.wiz</filename>.
      </para>

      <para>Juste en-dessous, vous trouverez l'entr&eacute;e <symbol>font-lock-auto-mode-list</symbol>. 
      Ajoutez <function>whizbang-mode</function> &agrave; celle-ci comme ceci :
      </para>

      <programlisting>;; Auto font lock mode
(defvar font-lock-auto-mode-list 
  (list 'c-mode 'c++-mode 'c++-c-mode 'emacs-lisp-mode 'whizbang-mode 'lisp-mode 'perl-mode 'scheme-mode)
  "List of modes to always start in font-lock-mode")</programlisting>

      <para>Cela signifie qu'Emacs autorisera toujours <function>font-lock-mode</function> 
      (ie colorisation de la syntaxe) pendant l'&eacute;dition d'un fichier <filename>.wiz</filename>.
      </para>

      <para>Et c'est tout ce qui est n&eacute;cessaire. S'il y a quoique ce soit que
      vous voulez de fait automatiquement quand vous ouvrez un fichier
      <filename>.wiz</filename>, vous pouvez ajouter un	<function>whizbang-mode hook</function> 
      (voir <function>my-scheme-mode-hook</function> pour un exemple simple
      qui ajoute <function>auto-indent</function>, l'auto-indentation).
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Pour aller plus loin</title>

    <itemizedlist>
      <listitem>
	<para>Brian Harvey and Matthew Wright
	  <emphasis>Simply Scheme</emphasis>
	  MIT 1994.<!-- <br> -->
	  ISBN 0-262-08226-8</para>
      </listitem>

      <listitem>
	<para>Randall Schwartz
	  <emphasis>Learning Perl</emphasis>
	  O'Reilly 1993<!-- <br> -->
	  ISBN 1-56592-042-2</para>
      </listitem>

      <listitem>
	<para>Patrick Henry Winston and Berthold Klaus Paul Horn
	  <emphasis>Lisp (3rd Edition)</emphasis>
	  Addison-Wesley 1989<!-- <br> -->
	  ISBN 0-201-08319-1</para>
      </listitem>

      <listitem>
	<para>Brian W. Kernighan and Rob Pike
	  <emphasis>The Unix Programming Environment</emphasis>
	  Prentice-Hall 1984<!-- <br> -->
	  ISBN 0-13-937681-X</para>
      </listitem>

      <listitem>
	<para>Brian W. Kernighan and Dennis M. Ritchie
	  <emphasis>The C Programming Language (2nd Edition)</emphasis>
	  Prentice-Hall 1988<!-- <br> -->
	  ISBN 0-13-110362-8</para>
      </listitem>

      <listitem>
	<para>Bjarne Stroustrup
	<emphasis>The C++ Programming Language</emphasis>
	Addison-Wesley 1991<!-- <br> -->
	ISBN 0-201-53992-6</para>
      </listitem>

      <listitem>
	<para>W. Richard Stevens
	  <emphasis>Advanced Programming in the Unix Environment</emphasis>
	  Addison-Wesley 1992<!-- <br> -->
	  ISBN 0-201-56317-7</para>
      </listitem>

      <listitem>
	<para>W. Richard Stevens
	  <emphasis>Unix Network Programming</emphasis>
	  Prentice-Hall 1990<!-- <br> -->
	  ISBN 0-13-949876-1</para>
      </listitem>
    </itemizedlist>
  </sect1>

    </chapter>
