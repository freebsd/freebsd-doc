<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.155
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="security">
  <info><title>Sécurité</title>
    <authorgroup>
      <author><personname><firstname>Matthew</firstname><surname>Dillon</surname></personname><contrib>Une grande partie de ce chapitre provient de la page
	  de manuel security(7) écrite par </contrib></author>
    </authorgroup>
  </info>

  
  <indexterm><primary>sécurité</primary></indexterm>
  &trans.a.fonvieille;

  <sect1 xml:id="security-synopsis">
    <title>Synopsis</title>

    <para>Ce chapitre sera une introduction aux concepts de base de la
      sécurité système, &agrave; certaines
      règles empiriques, et &agrave;
      des sujets avancés sous &os;.  De nombreux sujets
      abordés ici peuvent être appliqués &agrave;
      la sécurité système et &agrave; l'Internet en
      général.
      L'Internet n'est plus un endroit &ldquo;amical&rdquo;
      dans lequel chacun désire être votre gentil voisin.
      Sécuriser votre système est impératif pour
      protéger vos données, la propriété
      intellectuelle,
      votre temps, et bien plus des mains des &ldquo;hackers&rdquo; et
      équivalents.</para>

    <para>&os; fournit un ensemble d'utilitaires et de mécanismes
      pour assurer l'intégrité et la sécurité
      de votre système et votre réseau.</para>

    <para>Après la lecture de ce chapitre, vous
      connaîtrez:</para>

    <itemizedlist>
      <listitem>
	<para>Les concepts de base de la sécurité
	  système en ce qui concerne &os;.</para>
      </listitem>

      <listitem>
	<para>Les différents mécanismes de chiffrement
	  disponibles sous &os;, comme <acronym>DES</acronym> et <acronym>MD5</acronym>.</para>
      </listitem>

      <listitem>
	<para>Comment mettre en place une authentification
	  par mot de passe non réutilisable.</para>
      </listitem>

      <listitem>
	<para>Comment configurer l'encapsuleur <acronym>TCP</acronym>
	  pour une utilisation avec
	  <application>inetd</application>.</para>
      </listitem>

      <listitem>
	<para>Comment configurer <application>KerberosIV</application>
	  sous les versions de &os; antérieures &agrave; la
	  5.0.</para>
      </listitem>

      <listitem>
	<para>Comment configurer <application>Kerberos5</application>
	  sous &os;.</para>
      </listitem>

      <listitem>
	<para>Comment configurer IPsec et mettre en place un
	  <acronym>VPN</acronym> entre machines &os; et
	  &windows;.</para>
      </listitem>

      <listitem>
	<para>Comment configurer et utiliser
	  <application>OpenSSH</application>, la version de
	  <acronym>SSH</acronym> implémentée sous
	  &os;.</para>
      </listitem>

      <listitem>
	<para>Ce que sont les <acronym>ACL</acronym>s et comment les
	  utiliser.</para>
      </listitem>

      <listitem>
	<para>Comment employer l'utilitaire
	  <application>Portaudit</application> pour l'audit des
	  logiciels tierce-partie installés &agrave; partir du
	  catalogue des logiciels portés.</para>
      </listitem>

      <listitem>
	<para>Comment utiliser les avis de sécurité de
	  &os;.</para>
      </listitem>

      <listitem>
	<para>Ce qu'est la comptabilité des processus et
	  comment l'activer sous &os;.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Comprendre les concepts de base de &os; et
	  d'Internet.</para>
      </listitem>
    </itemizedlist>

    <para>D'autres sujets relatifs &agrave; la sécurité
      sont abordés par ailleurs dans ce Manuel.  Par exemple,
      le contrôle d'accès obligatoire est
      présenté dans le <xref linkend="mac"/> et les
      coupe-feux Internet sont développés dans le <xref linkend="firewalls"/>.</para>
  </sect1>

  <sect1 xml:id="security-intro">
    <title>Introduction</title>

    <para>La sécurité est un domaine qui débute
      et se termine au niveau de l'administrateur système.
      Alors que tous les systèmes multi-utilisateurs &unix; BSD
      ont des sécurités inhérentes, la mise en
      place et la maintenance des mécanismes
      supplémentaires de sécurité pour conserver
      des utilisateurs <quote>honnêtes</quote> est probablement
      une des tâches les plus vastes de l'administrateur
      système.  La sécurité des machines est
      celle que vous voulez bien mettre en oeuvre, de plus les
      préoccupations en matière de
      sécurité sont plus que jamais en concurrence avec
      les besoins de confort des utilisateurs.  Les systèmes
      &unix; sont, en général, capables
      d'exécuter un nombre important de processus
      simultanément et plusieurs de ces processus fonctionnent
      en tant que serveur &mdash; cela signifiant que des
      entités extérieures peuvent se connecter et
      échanger avec ces processus.  Comme les mini-ordinateurs
      et les gros ordinateurs d'hier deviennent aujourd'hui nos
      ordinateurs de bureau, et comme les ordinateurs sont
      désormais en réseau et reliés &agrave;
      Internet, la sécurité devient d'autant plus un
      problème majeur.</para>

    <para>La sécurité système concerne
      également la lutte contre les diverses formes d'attaque,
      y compris les attaques destinées &agrave; faire planter,
      ou &agrave; rendre inutilisable le système, mais qui ne
      cherchent pas &agrave; compromettre le compte
      <systemitem class="username">root</systemitem>.  Les problèmes de
      sécurité peuvent être divisés en
      plusieurs catégories:</para>

    <orderedlist>
      <listitem>
	<para>Attaques par déni de service.</para>
      </listitem>

      <listitem>
	<para>Compte utilisateur compromis.</para>
      </listitem>

      <listitem>
	<para>Le compte <systemitem class="username">root</systemitem> compromis par
	  l'intermédiaire de serveurs accessibles.</para>
      </listitem>

      <listitem>
	<para>Le compte <systemitem class="username">root</systemitem> compromis par
	  l'intermédiaire de comptes utilisateur.</para>
      </listitem>

      <listitem>
	<para>Création d'une <quote>Backdoor</quote> (porte
	  dérobée).</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>attaques DoS</primary>
      <see>déni de service (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>sécurité</primary>
      <secondary>attaques DoS</secondary>
      <see>déni de service (DoS)</see>
    </indexterm>
    <indexterm><primary>déni de service
      (DoS)</primary></indexterm>

    <para>Une attaque par déni de service (<quote>DoS</quote>)
      est une action qui prive la machine de ressources
      nécessaires &agrave; son bon fonctionnement.
      Généralement, les attaques par déni de
      service sont des mécanismes de force brute qui tentent de
      faire planter ou tout au moins de rendre inutilisable la machine
      en saturant ses serveurs ou sa pile réseau.  Certaines
      attaques par déni de service peuvent se servir de bogues
      présents dans la pile réseau pour faire planter
      une machine avec un seul paquet.  Ces problèmes ne
      peuvent être corrigés que par l'application d'un
      correctif sur le noyau.  On peut souvent remédier aux
      attaques sur les serveurs en fixant correctement des options
      pour limiter la charge que provoquent ces serveurs sur le
      système lors de conditions critiques.  Les attaques
      réseau par force brute sont plus difficiles &agrave;
      traiter.  Une attaque par paquets usurpés
      (<quote>spoofed-packet</quote>), par exemple, est
      quasi-impossible &agrave; arrêter, &agrave; moins de
      déconnecter de l'Internet votre système.  Elle
      peut ne pas être en mesure de stopper votre machine, mais
      elle peut saturer votre connexion Internet.</para>

    <indexterm>
      <primary>sécurité</primary>
      <secondary>comptes compromis</secondary>
    </indexterm>

    <para>La compromission d'un compte utilisateur est bien plus
      fréquente qu'une attaque de type DoS.  De nombreux
      administrateurs utilisent toujours sur leurs machines les
      versions standards des serveurs
      <application>telnetd</application>,
      <application>rlogind</application>,
      <application>rshd</application>, et
      <application>ftpd</application>.  Par défaut, ces
      serveurs ne fonctionnent pas avec des connexions
      chiffrées.  Cela aura pour résultat si vous
      disposez d'un nombre d'utilisateurs conséquent qu'un ou
      plusieurs de ces utilisateurs ayant l'habitude de se connecter
      &agrave; partir d'une machine distante (ce qui représente
      la manière la plus courante et la plus pratique pour
      ouvrir une session sur un système) auront leur mot de
      passe <quote>sniffé</quote>.  L'administrateur
      système méticuleux analysera ses journaux de
      connexions effectuées &agrave; partir de machines
      distantes &agrave; la recherche d'adresses sources suspectes
      même pour les ouvertures de sessions ayant
      réussies.</para>

    <para>Il faut toujours supposer qu'une fois l'attaquant a
      l'accès &agrave; un compte utilisateur, il pourra
      s'attaquer et avoir accès au compte
      <systemitem class="username">root</systemitem>.  Cependant, la réalité
      est que dans un système bien sécurisé et
      surveillé, l'accès &agrave; un compte utilisateur
      ne donne pas nécessairement &agrave; l'attaquant
      l'accès au compte <systemitem class="username">root</systemitem>.  Cette
      distinction est importante car sans accès aux droits de
      <systemitem class="username">root</systemitem>, l'attaquant ne peut
      généralement pas dissimuler ses traces et peut,
      dans le meilleur des cas, ne rien faire d'autre que mettre la
      pagaille dans les fichiers de l'utilisateur ou faire planter la
      machine.  La compromission de comptes utilisateur est
      très fréquente parce que les utilisateurs n'ont
      pas l'habitude de prendre les précautions que prennent
      les administrateurs système.</para>

    <indexterm>
      <primary>sécurité</primary>
      <secondary>backdoors</secondary>
    </indexterm>

    <para>Les administrateurs doivent garder &agrave; l'esprit qu'il
      existe potentiellement de nombreuses manières d'avoir
      accès au compte <systemitem class="username">root</systemitem> sur une
      machine.  L'attaquant peut connaître le mot de passe
      <systemitem class="username">root</systemitem>, l'attaquant peut trouver un bogue
      dans un serveur tournant avec les droits de
      <systemitem class="username">root</systemitem> et être en mesure de devenir
      <systemitem class="username">root</systemitem> par l'intermédiaire d'une
      connexion réseau &agrave; ce serveur, ou l'attaquant peut
      connaître un bogue dans un programme suid-root qui permet
      de devenir <systemitem class="username">root</systemitem> une fois qu'il a
      accédé &agrave; un compte utilisateur.  Si un
      attaquant a trouvé un moyen de devenir
      <systemitem class="username">root</systemitem> sur une machine, il n'aura
      peut-être pas besoin d'installer une
      <quote>backdoor</quote> (porte dérobée).  De
      nombreux trous de sécurité
      <systemitem class="username">root</systemitem> trouvés et fermés
      &agrave; temps demandent un travail considérable &agrave;
      l'attaquant pour effacer ses traces, aussi la plupart des
      attaquants installe des portes dérobées.  Une
      porte dérobée offre &agrave; l'attaquant un moyen
      aisé d'avoir &agrave; nouveau accès aux droits de
      <systemitem class="username">root</systemitem> sur le système, mais cela donne
      également &agrave; l'administrateur système
      intelligent un bon moyen de détecter l'intrusion.  Rendre
      impossible &agrave; un attaquant l'installation d'une porte
      dérobée peut en fait être
      préjudiciable &agrave; votre sécurité,
      parce que cela ne fermera pas le trou qu'a découvert en
      premier lieu l'attaquant pour pénétrer sur le
      système.</para>

    <para>Les solutions aux problèmes de sécurité
      devraient toujours être mises en place suivant l'approche
      multi-couches de <quote>la pelure d'oignon</quote>, elles
      peuvent être classées comme suit:</para>

    <orderedlist>
      <listitem>
	<para>Sécuriser les comptes <systemitem class="username">root</systemitem>
	  et d'administration.</para>
      </listitem>

      <listitem>
	<para>Sécuriser les serveurs exécutés
	  avec les droits de <systemitem class="username">root</systemitem> et les binaires
	  suid/sgid.</para>
      </listitem>

      <listitem>
	<para>Sécuriser les comptes utilisateurs.</para>
      </listitem>

      <listitem>
	<para>Sécuriser le fichier des mots de passe.</para>
      </listitem>

      <listitem>
	<para>Sécuriser le noyau, les
	  périphériques et les systèmes de
	  fichiers.</para>
      </listitem>

      <listitem>
	<para>Installer un mécanisme de détection rapide
	  des modifications inappropriées apportées au
	  système.</para>
      </listitem>

      <listitem>
	<para>La paranoïa.</para>
      </listitem>
    </orderedlist>

    <para>La section suivante de ce chapitre abordera de
      manière plus approfondie les points énoncés
      ci-dessus.</para>
  </sect1>

  <sect1 xml:id="securing-freebsd">
    <title>Securing FreeBSD ** Traduction en Cours **</title>

    <para/>
  </sect1>

  <sect1 xml:id="crypt">
    <info><title>DES, MD5, et chiffrement</title>
      <authorgroup>
	<author><personname><firstname>Bill</firstname><surname>Swingle</surname></personname><contrib>En partie réécrit et mis &agrave; jour
	    par </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>sécurité</primary>
      <secondary>chiffrement</secondary>
    </indexterm>

    <indexterm><primary>chiffrement</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>Chaque utilisateur d'un système &unix; possède un
      mot de passe associé &agrave; son compte.
      Il semble évident
      que ces mots de passe ne doivent être connus que de
      l'utilisateur et du système d'exploitation.  Afin de
      conserver ces mots de passe secrets, ils sont chiffrés
      avec ce que l'on appelle un &ldquo;hachage
      irréversible&rdquo;, ce qui signifie que le mot de passe
      peut être aisément chiffré mais pas
      déchiffré.
      En d'autres mots, ce que nous vous disions précédemment
      n'est même pas vrai: le système d'exploitation
      lui-même ne connaît pas <emphasis>vraiment</emphasis>
      le mot de passe.  Il ne connaît que la forme
      <emphasis>chiffrée</emphasis> du mot de passe.  La
      seule manière d'obtenir le mot de passe en
      <emphasis>clair</emphasis> est d'effectuer une recherche par
      force brute de tous les mots de passe possibles.</para>

    <para>Malheureusement, la seule méthode sécurisée
      pour chiffrer les mots de passe quand &unix; a vu le jour
      était basée sur DES, le &ldquo;Data Encryption
      Standard&rdquo; (standard de chiffrement des données).
      C'était un problème mineur pour les utilisateurs
      résidants aux Etats-Unis, mais puisque le code source
      de DES ne pouvait être exporté en dehors des Etats-Unis,
      &os; dû trouver un moyen de respecter la législation
      américaine et de rester compatible avec les autres
      systèmes &unix; qui utilisaient encore DES.</para>

    <para>La solution fut de séparer les bibliothèques
      de chiffrement de façon &agrave; ce que les utilisateurs
      américains puissent installer les bibliothèques DES
      et utiliser DES, mais que les utilisateurs internationaux
      disposent d'une méthode de chiffrement non restreinte
      &agrave; l'exportation.  C'est comment &os; est venu &agrave;
      utiliser MD5 comme méthode de chiffrement par défaut.
      MD5 est reconnu comme étant plus sure que DES,
      l'installation de DES est proposée principalement
      pour des raisons de compatibilité.</para>

    <sect2>
      <title>Identifier votre mécanisme de chiffrement</title>

      <para>Avant FreeBSD&nbsp;4.4 <filename>libcrypt.a</filename>
	était un lien symbolique pointant sur la bibliothèque
	utilisée pour le chiffrement.  FreeBSD&nbsp;4.4 modifia
	<filename>libcrypt.a</filename> pour fournir une bibliothèque
	de hachage pour l'authentification des mots de passe
	configurable.  Actuellement la bibliothèque supporte les
	fonctions de hachage DES, MD5 et Blowfish.  Par défaut
	&os; utilise MD5 pour chiffrer les mots de passe.</para>

      <para>Il est relativement facile d'identifier quelle
	méthode de chiffrement &os; utilise.  Examiner les
	mots de passe chiffrés dans le fichier
	<filename>/etc/master.passwd</filename> est une méthode.
	Les mots de passe MD5 sont plus longs que les mots de passe
	DES, et commencent par les caractères
	<literal>&dollar;1&dollar;</literal>.  Les mots de passe
	débutant par <literal>&dollar;2&dollar;</literal> sont
	chiffrés suivant la méthode Blowfish.  Les mots de
	passe DES n'ont pas de caractéristique particulière,
	mais sont plus courts que les mots de passe MD5 et utilisent
	un alphabet de 64 caractères qui ne contient pas le
	caractère <literal>&dollar;</literal>, aussi une
	chaîne relativement courte qui ne commence pas par un dollar
	a donc de très fortes chances d'être un mot de passe
	DES.</para>

      <para>Le format utilisé par les nouveaux mots de passe est
	contrôlé par la capacité de classe de session
	<literal>passwd_format</literal> dans
	<filename>/etc/login.conf</filename>, qui prend comme
	valeur <literal>des</literal>, <literal>md5</literal> ou
	<literal>blf</literal>.  Voir la page de manuel
	&man.login.conf.5; pour plus d'information sur les
	capacités de classe de session.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="one-time-passwords">
    <title>Mots de passe non réutilisables</title>
    <indexterm><primary>mots de passe non réutilisables</primary></indexterm>
    <indexterm>
      <primary>sécurité</primary>
      <secondary>mots de passe non réutilisables</secondary>
    </indexterm>

    <para>S/Key est un système de mots de passe non
      réutilisables basé sur une fonction de hachage
      irréversible.  &os; utilise le hachage MD4 pour des
      raisons de compatibilité mais d'autres système
      utilisent MD5 et DES-MAC.  S/Key fait partie du système
      de base de &os; depuis la version 1.1.5 et est aussi
      utilisé sur un nombre toujours plus important d'autres
      systèmes d'exploitation.  S/Key est une marque
      déposée de Bell
      Communications Research, Inc.</para>

    <para>Depuis la version 5.0 de &os;, S/Key a été
      remplacé par la fonction équivalente OPIE
      (&ldquo;One-time Passwords In Everything&rdquo; &mdash; Mots de
      passe non réutilisables dans toutes les applications).
      OPIE utilise le hachage MD5 par défaut.</para>

    <para>Il existe trois types de mots de passe dont nous parlerons
      dans ce qui suit.  Le premier est votre mot de passe &unix;
      habituel ou mot de passe Kerberos; nous appellerons &ldquo;mot
      de passe &unix;&ldquo;.  Le deuxième type est le mot de passe
      généré par les programmes
      S/Key <command>key</command> ou
      OPIE &man.opiekey.1; et reconnu par les programmes
      <command>keyinit</command> ou &man.opiepasswd.1; et l'invite
      de session; nous appellerons ceci un &ldquo;mot de passe non
      réutilisable&rdquo;.  Le dernier type de mot de passe
      est le mot de passe secret que vous donnez aux programmes
      <command>key</command>/<command>opiekey</command> (et parfois
      aux programmes
      <command>keyinit</command>/<command>opiepasswd</command>) qui
      l'utilisent pour générer des mots de passe non
      réutilisable; nous l'appellerons &ldquo;mot de passe
      secret&rdquo; ou tout simplement &ldquo;mot de
      passe&rdquo;.</para>

    <para>Le mot de passe secret n'a rien &agrave; voir avec
      votre mot de passe &unix;; ils peuvent être identique,
      mais c'est déconseillé.  Les mots de passe secret
      S/Key et OPIE ne sont pas limités &agrave; 8
      caractères comme les
      anciens mots de passe &unix;<footnote><para>Sous &os; le mot de
      passe standard peut avoir une longueur de 128 caractères
      maximum.</para></footnote>, ils peuvent avoir la longueur que
      vous désirez.  Des mots de passe de six ou sept mots de long
      sont relativement communs.  La plupart du temps, le système
      S/Key ou OPIE fonctionne de façon complètement
      indépendante du système de mot de passe &unix;.</para>

    <para>En plus du mot de passe, deux autres types de données
      sont importantes pour S/Key et OPIE.  L'une d'elles est
      connue sous le nom de &ldquo;germe&rdquo; (&ldquo;seed&rdquo;)
      ou &ldquo;clé&rdquo;, formé de deux lettres et
      cinq chiffres.  L'autre est ce que l'on appelle le
      &ldquo;compteur d'itérations&rdquo;, un nombre compris
      entre 1 et 100.  S/Key génère un mot de passe non
      réutilisable en concaténant le germe et le mot de
      passe secret, puis en appliquant la fonction de hachage MD4/MD5
      autant de fois qu'indiqué par le compteur
      d'itérations, et en convertissant le résultat en
      six courts mots anglais.
      Ces six mots anglais constituent votre mot de
      passe non réutilisable.  Le système d'authentification
      (principalement PAM) conserve une trace du dernier mot de passe
      non réutilisable utilisé, et l'utilisateur est
      authentifié si la valeur de hachage du mot de passe fourni par
      l'utilisateur est la même que celle du mot de passe
      précédent.  Comme le hachage utilisé est
      irréversible, il est impossible de générer
      de mot de passe non réutilisable si on a surpris un de
      ceux qui a été utilisé avec succès; le
      compteur d'itérations est décrémenté
      après chaque ouverture de session réussie, de sorte que
      l'utilisateur et le programme d'ouverture de session restent en
      phase.  Quand le compteur d'itération passe &agrave; 1,
      S/Key et OPIE doivent être
      réinitialisés.</para>

    <para>Il y a trois programmes impliqués dans chacun des
      systèmes que nous aborderons plus bas.  Les programmes
      <command>key</command> et <command>opiekey</command> ont pour
      paramètres un compteur d'itérations, un germe, et un
      mot de passe secret, et génère un mot
      de passe non réutilisable ou une liste de mots
      de passe non réutilisable.  Les programmes
      <command>keyinit</command> et <command>opiepasswd</command>
      sont utilisés pour initialiser respectivement
      S/Key et OPIE, et pour modifier les mots de passe, les compteurs
      d'itérations, ou les germes; ils prennent pour
      paramètres soit un mot de passe secret, soit un compteur
      d'itérations, soit un germe, et un mot de passe non
      réutilisable.  Le programme <command>keyinfo</command> ou
      <command>opieinfo</command> consulte le fichier d'identification
      correspondant (<filename>/etc/skeykeys</filename> ou
      <filename>/etc/opiekeys</filename>) et imprime la valeur du
      compteur d'itérations et le germe de l'utilisateur qui l'a
      invoqué.</para>

    <para>Nous décrirons quatre sortes d'opérations.  La
      première est l'utilisation du programme
      <command>keyinit</command> ou <command>opiepasswd</command> sur
      une connexion sécurisée pour initialiser les mots
      de passe non réutilisables pour la première
      fois, ou pour modifier votre mot de passe ou votre germe.
      La seconde opération est l'emploi des programmes
      <command>keyinit</command> ou <command>opiepasswd</command>
      sur une connexion non sécurisée, en conjonction
      avec <command>key</command> ou <command>opiekey</command> sur
      une connexion sécurisée, pour faire la même
      chose.  La troisième est l'utilisation de
      <command>key</command>/<command>opiekey</command> pour ouvrir
      une session sur une connexion non sécurisée.
      La quatrième est l'emploi de <command>key</command>
      ou <command>opiekey</command> pour générer
      un certain nombre de clés qui peuvent être
      notées ou imprimées et emportées avec vous
      quand vous allez quelque part ou il n'y a aucune connexion
      sécurisée.</para>

    <sect2>
      <title>Initialisation depuis une connexion
	sécurisée</title>

      <para>Pour initialiser S/Key pour la première fois,
	changer votre mot de passe, ou changer votre germe quand
	vous êtes attaché sous votre compte par
	l'intermédiaire d'une connexion sécurisée
	(e.g., sur la console d'une machine ou via
	<application>ssh</application>), utilisez la commande
	<command>keyinit</command> sans paramètres:</para>

      <screen>&prompt.user; <userinput>keyinit</userinput>
Adding unfurl:
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
Enter secret password:
Again secret password:

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</screen>

      <para>Pour OPIE, <command>opiepasswd</command> est
	utilisé &agrave; la place:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para>A l'invite <prompt>Enter new secret pass phrase:</prompt>
	ou <prompt>Enter secret password:</prompt>, vous devez entrer
	un mot de passe ou une phrase.  Rappelez-vous que ce n'est pas
	le mot de passe que vous utiliserez pour ouvrir une session,
	mais celui utilisé pour générer vos clés
	non réutilisables.  La ligne commençant par
	&ldquo;ID&rdquo; liste les paramètres de votre instance:
	votre nom d'utilisateur, la valeur de votre compteur
	d'itérations et votre germe.  Quand vous ouvrirez une
	session, le système aura mémorisé ces
	paramètres et vous les redonnera, vous n'avez donc
	pas besoin de les retenir.  La dernière ligne
	donne le mot de passe non réutilisable correspondant
	&agrave; ces paramètres et &agrave; votre mot de passe secret;
	si vous devez vous reconnectez immédiatement, c'est ce
	mot de passe que vous utiliseriez.</para>
    </sect2>

    <sect2>
      <title>Initialisation depuis une connexion non
	sécurisée</title>

      <para>Pour initialiser ou changer votre mot de passe secret
	par l'intermédiaire d'une connexion non
	sécurisée, il faudra avoir déj&agrave;
	une connexion sécurisée sur une machine
	où vous pouvez exécuter <command>key</command> ou
	<command>opiekey</command>; ce peut être
	depuis une icone sur le bureau d'un Macintosh
	ou depuis la ligne de commande d'une machine sûre.
	Il vous faudra également donner une valeur au compteur
	d'itération (100 est probablement une bonne valeur),
	et indiquer un germe ou utiliser la valeur aléatoire
	générée par le programme.  Sur la connexion non
	sécurisée (vers la machine que vous initialisez),
	employez la commande <command>keyinit -s</command>:</para>

      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: <userinput>100</userinput>
Enter new key [default to17759]:
s/key 100 to 17759
s/key access password:
s/key access password:<userinput>CURE MIKE BANE HIM RACY GORE</userinput>
</screen>

      <para>Pour OPIE, vous devez utiliser <command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

      <para>Pour accepter le germe par défaut (que le programme
	<command>keyinit</command> appelle <literal>key</literal>,
	ce qui prête &agrave; confusion), appuyez sur
	<keycap>Entrée</keycap>.  Ensuite avant d'entrer un mot de
	passe d'accès, passez sur votre connexion
	sécurisée et donnez lui les mêmes
	paramètres:</para>

      <screen>&prompt.user; <userinput>key 100 to17759</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
CURE MIKE BANE HIM RACY GORE</screen>

      <para>Ou pour OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Retournez maintenant sur votre connexion non
	sécurisée, et copiez le mot de passe
	non réutilisable généré par le programme
	adapté.</para>
    </sect2>

    <sect2>
      <title>Générer un unique mot de passe non
	réutilisable</title>

      <para>Une fois que vous avez initialisé S/Key ou OPIE,
	lorsque que vous ouvrez une session, une invite de ce type
	apparaîtra:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: </screen>

      <para>Ou pour OPIE:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>Les invites S/Key et OPIE disposent d'une fonction utile
	(qui n'est pas illustrée ici): si vous appuyez sur la touche
	<keycap>Entrée</keycap> lorsque l'on vous demande votre
	mot de passe, le programme active l'écho au terminal, de
	sorte que vous voyez ce que vous êtes en train de taper.
	Ceci est très utile si vous essayez de taper un mot de
	passe &agrave; la main, &agrave; partir d'un résultat
	imprimé par exemple.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>A ce moment vous devez générer votre
	mot de passe non réutilisable pour répondre &agrave;
	cette invite de session.  Cela doit être effectué
	sur une machine de confiance sur laquelle vous pouvez
	exécuter <command>key</command> ou
        <command>opiekey</command> (il y a des versions de ces
	programmes pour DOS, Windows et MacOS).  Ces programmes
	ont besoin du compteur d'itérations et du germe comme
	paramètres.  Vous pouvez les copier-coller de l'invite de
	session de la machine sur laquelle vous voulez ouvrir une
	session.</para>

      <para>Sur le système sûr:</para>

      <screen>&prompt.user; <userinput>key 97 fw13894</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password:
WELD LIP ACTS ENDS ME HAAG</screen>

      <para>Pour OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Maintenant que vous disposez de votre mot de passe non
	réutilisable vous pouvez continuer et vous
	connecter:</para>

      <screen>login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: <userinput>&lt;return to enable echo&gt;</userinput>
s/key 97 fw13894
Password [echo on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ... </screen>

    </sect2>

    <sect2>
      <title>Générer de multiples mots de passe
	non réutilisables</title>

      <para>Il faut parfois se rendre en des endroits où
	vous n'avez pas accès &agrave; une machine de confiance
	ou &agrave; une connexion sécurisée.  Dans ce cas, vous
	pouvez utiliser la commande <command>key</command> ou
	<command>opiekey</command> pour générer plusieurs
	mots de passe non réutilisables que vous pouvez imprimer
	et transporter avec vous.  Par exemple:</para>

      <screen>&prompt.user; <userinput>key -n 5 30 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
26: SODA RUDE LEA LIND BUDD SILT
27: JILT SPY DUTY GLOW COWL ROT
28: THEM OW COLA RUNT BONG SCOT
29: COT MASH BARR BRIM NAN FLAG
30: CAN KNEE CAST NAME FOLK BILK</screen>

      <para>Ou pour OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>L'option <option>-n 5</option> demande cinq clés en
	séquence, l'option <option>30</option> indique quel doit
	être le rang de la dernière itération.  Notez que
	les clés sont imprimées dans l'ordre
	<emphasis>inverse</emphasis> de celui où elles seront
	éventuellement utilisées.  Si vous êtes
	vraiment paranoïaque, vous pouvez les recopier &agrave; la main,
	sinon vous pouvez les copier-coller vers la commande
	<command>lpr</command>.  Remarquez que chaque ligne liste le
	compteur d'itération et le mot de passe non
	réutilisable; vous trouverez peut-être utile de rayer les
	mots de passe au fur et &agrave; mesure de leur utilisation.</para>
    </sect2>

    <sect2>
      <title>Restreindre l'utilisation des mots de passe &unix;</title>

      <para>S/Key peut placer des restrictions sur l'utilisation des
	mots de passe &unix; en fonction des noms de machine,
	d'utilisateur, de la ligne utilisée par le terminal ou de
	l'adresse IP de la machine connectée &agrave; distance.
	Ces restrictions peuvent être trouvées dans le
	fichier de configuration
	<filename>/etc/skey.access</filename>.  La page de manuel
	&man.skey.access.5; donne de plus amples informations sur le
	format de ce fichier et elle détaille également
	certains avertissements relatifs &agrave; la sécurité
	qu'il faut lire avant de se fier &agrave; ce fichier pour sa
	sécurité.</para>

      <para>S'il n'y a pas de fichier
	<filename>/etc/skey.access</filename> (ce qui est le cas par
	défaut sur les systèmes &os;&nbsp;4.X), tous les
	utilisateurs pourront se servir de mots de passe &unix;.  Si le
	fichier existe, alors tous les utilisateurs devront passer par
	S/Key, &agrave; moins qu'ils ne soient explicitement
	autorisés &agrave; ne pas le faire par des instructions du
	fichier <filename>/etc/skey.access</filename>.  Dans tous les
	cas l'usage des mots de passe &unix; est autorisé sur
	la console.</para>

      <para>Voici un exemple de configuration du fichier
	<filename>skey.access</filename> qui illustre les trois types
	d'instructions les plus courantes:</para>

      <programlisting>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</programlisting>

      <para>La première ligne (<literal>permit internet</literal>)
	autorise les utilisateurs dont l'adresse IP (ce qui rend
	vulnérable en cas d'usurpation) appartient au
	sous-réseau spécifié &agrave; employer les mots
	de passe &unix;.  Cela ne doit pas être
	considéré comme une mesure de sécurité,
	mais plutôt comme un moyen de rappeler aux utilisateurs
	autorisés qu'ils sont sur un réseau non
	sécurisé et doivent utiliser S/Key pour
	s'authentifier.</para>

      <para>La seconde ligne (<literal>permit user</literal>)
	autorise l'utilisateur désigné, dans notre cas
	<systemitem class="username">fnord</systemitem>, &agrave; employer n'importe quand
	les mots de passe &unix;.  En général,
	il faut se servir de cette possibilité si les personnes
	soit n'ont pas moyen d'utiliser le programme
	<command>key</command>, s'ils ont par exemple des terminaux
	passifs, soit s'ils sont définitivement réfractaires au
	système.</para>

      <para>La troisième ligne (<literal>permit port</literal>)
	autorise tous les utilisateurs d'un terminal sur une liaison
	particulière &agrave; utiliser les mots de passe &unix;;
	cela devrait être employé pour les connexions
	téléphoniques.</para>

      <para>OPIE peut restreindre l'usage des mots de passe &unix;
	sur la base de l'adresse IP lors de l'ouverture d'une session
	comme peut le faire S/Key.  Le fichier impliqué est
	<filename>/etc/opieaccess</filename>, qui est présent par
	défaut sous &os;&nbsp;5.0 et versions suivantes.
	Veuillez consulter la page de manuel &man.opieaccess.5; pour
	plus d'information sur ce fichier et certaines
	considérations sur la sécurité dont vous
	devez être au courant en l'utilisant.</para>

      <para>Voici un exemple de fichier
	<filename>opieaccess</filename>:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Cette ligne autorise les utilisateurs dont l'adresse IP (ce
	qui rend vulnérable en cas d'usurpation) appartient au
	sous-réseau spécifié &agrave; employer les mots
	de passe &unix; &agrave; tout moment.</para>

      <para>Si aucune règle du fichier <filename>opieaccess</filename>
	ne correspond, le comportement par défaut est de
	refuser toute ouverture de session non-OPIE.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="tcpwrappers">
    <info><title>L'encapsuleur TCP (<quote>TCP Wrappers</quote>)</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Ecrit par </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>TCP Wrappers</primary></indexterm>

    <para>Toute personne familière avec &man.inetd.8; a
      probablement entendu parlé &agrave; un moment ou &agrave;
      un autre de l'encapsuleur <acronym>TCP</acronym> (<quote>TCP
      Wrappers</quote>).  Mais peu sont ceux qui semblent saisir
      complètement son intérêt dans un
      réseau.  Il semble que tout le monde désire
      installer un coupe-feu pour contrôler les connexions
      réseaux.  Alors qu'un coupe-feu peut avoir de nombreuses
      utilisations, il existe des choses qu'un coupe-feu ne peut
      gérer comme renvoyer un message &agrave; l'initiateur
      d'une connexion.  L'encapsuleur <acronym>TCP</acronym> en est
      capable ainsi que bien d'autres choses.  Dans les sections
      suivantes plusieurs fonctionnalités de l'encapsuleur
      <acronym>TCP</acronym> seront abordées, et, dès
      que ce sera possible, un exemple de configuration sera
      proposé.</para>

    <para>L'encapsuleur <acronym>TCP</acronym> étend les
      capacités d'<application>inetd</application> au niveau du
      support pour chaque serveur sous son contrôle.  En
      utilisant cette méthode il est possible d'offrir le
      support des ouvertures de session, de retourner des messages
      lors des connexions, de permettre &agrave; un
      <quote>daemon</quote> de n'accepter que les connexions internes,
      etc.  Bien que certaines de ces fonctionnalités peuvent
      être obtenues par l'implémentation d'un coupe-feu,
      ce système ajoutera non seulement une couche
      supplémentaire de protection mais ira plus loin dans le
      contrôle que ce que peut fournir un coupe-feu.</para>

    <para>Les fonctionnalités apportées par
      l'encapsuleur <acronym>TCP</acronym> ne peuvent se substituer
      &agrave; l'utilisation d'un bon coupe-feu.  L'encapsuleur
      <acronym>TCP</acronym> peut être utilisé de paire
      avec un coupe-feu ou tout autre système de
      sécurité et il pourra alors servir comme une
      couche supplémentaire de protection pour le
      système.</para>

    <para>Etant donné que ce programme est une extension
      &agrave; la configuration du programme
      <application>inetd</application>, le lecteur est supposé
      avoir pris connaissance de la section de <link linkend="network-inetd">configuration d'inetd</link>.</para>

    <note>
      <para>Bien que les programmes lancés par &man.inetd.8; ne
	soient pas tout &agrave; fait des <quote>daemons</quote>, ils
	sont traditionnellement appelés <quote>daemons</quote>.
	C'est le terme que nous utiliserons également dans le
	reste de cette section.</para>
    </note>

    <sect2>
      <title>Configuration initiale</title>

      <para>Le seul pré-requis &agrave; l'utilisation de
	l'encapsuleur <acronym>TCP</acronym> sous &os; est de
	s'assurer que le serveur <application>inetd</application> est
	lancé &agrave; partir de <filename>rc.conf</filename>
	avec l'option <option>-Ww</option>; c'est la configuration par
	défaut.  Bien évidemment une configuration
	correcte du fichier <filename>/etc/hosts.allow</filename> est
	également sous-entendue, mais dans le cas contraire
	&man.syslogd.8; émettra des messages d'avertissement
	dans les journaux du système.</para>

      <note>
	<para>Contrairement &agrave; d'autres implémentations
	  de l'encapsuleur <acronym>TCP</acronym>, l'emploi du fichier
	  <filename>hosts.deny</filename> est obsolète.  Toutes
	  les options de configuration doivent être
	  placées dans le fichier
	  <filename>/etc/hosts.allow</filename>.</para>
      </note>

      <para>Dans la configuration la plus simple, la politique de
	connexion aux <quote>daemons</quote> est soit de tout
	autoriser ou soit de tout bloquer en fonctions des options
	choisies dans <filename>/etc/hosts.allow</filename>.  La
	configuration par défaut sous &os; est d'autoriser les
	connexions &agrave; chaque <quote>daemon</quote> lancé
	&agrave; l'aide d'<application>inetd</application>.  La
	modification de ce réglage par défaut sera
	discutée une fois que la configuration de base aura
	été vue.</para>

      <para>Une configuration de base prend en général
	la forme <literal>daemon : adresse : action</literal>.
	Où <literal>daemon</literal> est le nom du
	<quote>daemon</quote> lancé par
	<application>inetd</application>.
	L'<literal>adresse</literal> peut être un nom de machine
	valide, une adresse <acronym>IP</acronym> ou une adresse IPv6
	entre crochets ([&nbsp;]).  Le champ <literal>action</literal>
	pourra avoir comme valeur <literal>allow</literal> ou
	<literal>deny</literal> pour autoriser ou interdire
	l'accès.  Gardez &agrave; l'esprit que ce type de
	configuration fonctionne de manière &agrave; honorer la
	première règle sémantique correspondante,
	cela signifie que le fichier de configuration est parcouru
	&agrave; la recherche d'une règle correspondant
	&agrave; la requête.  Quand une correspondance est
	trouvée, la règle est appliquée et la
	recherche s'arrête.</para>

      <para>Plusieurs autres options existent mais elles seront
	exposées dans une section ultérieure.  Une
	simple ligne de configuration peut être construite avec
	peu d'information.  Par exemple, pour autoriser les connexions
	<acronym>POP</acronym>3 via le <quote>daemon</quote> <package>mail/qpopper</package>, les lignes suivantes
	doivent être ajoutées au fichier
	<filename>hosts.allow</filename>:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>Après l'ajout de cette ligne,
	<application>inetd</application> devra être
	redémarré.  Cela sera fait en utilisant la
	commande &man.kill.1;, ou avec le passage du paramètre
	<parameter>restart</parameter> &agrave; la commande
	<filename>/etc/rc.d/inetd</filename>.</para>
    </sect2>

    <sect2>
      <title>Configuration avancée</title>

      <para>L'encapsuleur <acronym>TCP</acronym> dispose
	également d'options avancées; elles permettrons
	plus de contrôle sur la manière dont sont
	gérées les connexions.  Dans certains cas cela
	peut être une bonne idée de renvoyer un
	commentaire &agrave; certaines machines ou lors de connexions
	&agrave; certains <quote>daemon</quote>s.  Dans d'autres cas,
	peut-être qu'un fichier journal pourrait être
	enregistré ou un courrier électronique pourrait
	être envoyé &agrave; l'administrateur.  D'autres
	situations peuvent nécessiter l'utilisation d'un
	service uniquement pour les connexions locales.  Tout cela est
	possible &agrave; l'aide des options de configuration connues
	sous le nom de <literal>jokers</literal>, caractères
	d'expansion et d'exécution de commandes externes.  Les
	deux sections suivantes abordent ces situations.</para>

      <sect3>
	<title>Commandes externes</title>

	<para>Imaginez une situation dans laquelle une connexion doit
	  être refusée et que la raison de ce refus doit
	  être envoyée &agrave; la personne qui a
	  tenté d'établir cette connexion.  Comment cela
	  peut-il être mis en place?  Ce type d'action est rendu
	  possible par l'emploi de l'option <option>twist</option>.
	  Quand une tentative de connexion est faite,
	  <option>twist</option> sera appelée pour
	  exécuter une commande ou une procédure
	  d'interpréteur de commande.  Un exemple est
	  déj&agrave; présent dans le fichier
	  <filename>hosts.allow</filename>:</para>

	<programlisting># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>Cet exemple montre que le message <quote>You are not
	  allowed to use <literal>daemon</literal> from
	  <literal>hostname</literal>.</quote> sera retourné
	  pour tout <quote>daemon</quote> qui n'a pas
	  été précédemment
	  configuré dans le fichier d'accès.  Cette
	  fonction est très utile pour envoyer une
	  réponse &agrave; l'initiateur de la connexion juste
	  après le refus de la connexion.  Notez que tout
	  message &agrave; retourner <emphasis>doit</emphasis>
	  être placé entre des guillemets
	  <literal>"</literal>; il n'y a pas d'exception possible
	  &agrave; cette règle.</para>

	<warning>
	  <para>Il est possible de lancer une attaque par déni
	    de service sur le serveur si un agresseur, ou un groupe
	    d'agresseurs sont en mesure de submerger ces
	    <quote>daemon</quote>s avec des demandes de
	    connexion.</para>
	</warning>

	<para>Une autre possibilité dans ce cas est d'employer
	  l'option <option>spawn</option>.  Tout comme l'option
	  <option>twist</option>, <option>spawn</option> interdit
	  implicitement les connexions et peut être
	  utilisée pour lancer une commande ou une
	  procédure externe.  Contrairement &agrave;
	  <option>twist</option>, <option>spawn</option> n'enverra pas
	  de réponse &agrave; la personne qui a établi
	  la connexion.  Examinons par exemple la ligne de
	  configuration suivante:</para>

	<programlisting># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>Cela interdira toute tentative de connexion &agrave;
	  partir du domaine <systemitem class="fqdomainname">*.example.com</systemitem>, enregistrant
	  simultanément dans le fichier
	  <filename>/var/log/connections.log</filename> le nom de
	  machine, l'adresse <acronym>IP</acronym> et le
	  <quote>daemon</quote> auquel on tente
	  d'accéder.</para>

	<para>Il existe d'autres caractères de substitution en
	  dehors de ceux déj&agrave; présentés,
	  par exemple <literal>%a</literal>.  Consultez la page de
	  manuel &man.hosts.access.5; pour une liste
	  complète.</para>
      </sect3>

      <sect3>
	<title>Les options jokers</title>

	<para>Jusqu'ici l'option <literal>ALL</literal> a
	  été utilisée dans tous les exemples.
	  Il existe d'autres options pour étendre un peu plus
	  les fonctionnalités.  Par exemple, l'option
	  <literal>ALL</literal> peut être utilisée pour
	  prendre en compte chaque instance d'un
	  <quote>daemon</quote>, d'un domaine ou d'une adresse
	  <acronym>IP</acronym>.  Un autre joker disponible est
	  l'option <literal>PARANOID</literal> qui peut être
	  employée pour prendre en compte toute machine qui
	  fournirait une adresse <acronym>IP</acronym> susceptible
	  d'être falsifiée.  En d'autres termes, l'option
	  <literal>PARANOID</literal> peut être utilisée
	  pour définir l'action a effectuer dès qu'une
	  connexion se fait &agrave; partir d'une adresse
	  <acronym>IP</acronym> qui diffère de celle
	  attachée &agrave; une machine.  L'exemple suivant
	  apporte un éclairage sur cette option:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>Dans cet exemple, toutes les requêtes de connexion
	  &agrave; <application>sendmail</application> &agrave; partir
	  d'adresses <acronym>IP</acronym> différentes de celle
	  correspondant au nom de la machine seront
	  refusées.</para>

	<caution>
	  <para>Utiliser l'option <literal>PARANOID</literal> peut
	    gravement paralyser les serveurs si le client ou le
	    serveur a une configuration de <acronym>DNS</acronym>
	    défectueuse.  Les administrateurs sont maintenant
	    prévenus.</para>
	</caution>

	<para>Pour en apprendre plus sur les jokers et leurs
	  fonctionnalités associées, consultez la page
	  de manuel &man.hosts.access.5;.</para>

	<para>Avant que n'importe quelle des lignes de configuration
	  données ci-dessus ne fonctionne, la première
	  ligne de configuration du fichier
	  <filename>hosts.allow</filename> devra être
	  dé-commentée.  Cela a été
	  noté en début de section.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="kerberosIV">
    <info><title>Kerberos</title>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Murray</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Dapoz</surname></personname><contrib>Basée sur une contribution de </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm><primary>Kerberos</primary></indexterm>

    <para>Kerberos est un protocole réseau supplémentaire
      qui permet aux utilisateurs de s'authentifier par
      l'intermédiaire d'un serveur sécurisé.
      Des services comme l'ouverture de session et la copie &agrave;
      distance, la copie sécurisée de fichiers entre
      systèmes et autres fonctionnalités &agrave; haut
      risque deviennent ainsi considérablement plus
      sûrs et contrôlables.</para>

    <para>Les instructions qui suivent peuvent être
      utilisées comme guide d'installation de Kerberos dans
      la version distribuée pour &os;.  Vous devriez
      cependant vous référer aux pages de manuel
      correspondantes pour avoir une description
      complète.</para>

    <sect2>
      <title>Installation de Kerberos</title>

      <indexterm><primary>MIT</primary></indexterm>
      <indexterm>
	<primary>Kerberos</primary>
	<secondary>installation</secondary>
      </indexterm>
      <para>Kerberos est un composant optionnel de &os;.  La
	manière la plus simple d'installer ce logiciel est de
	sélectionner la distribution <literal>krb4</literal>
	ou <literal>krb5</literal> dans
	<application>sysinstall</application> lors de l'installation
	de &os;.  Cela installera les implémentations
	&ldquo;eBones&rdquo; (KerberosIV) ou &ldquo;Heimdal&rdquo;
	(Kerberos5) de Kerberos.  Ces implémentations sont
	distribuées car elles sont développées en dehors
	des USA ou du Canada et étaient par conséquent
	disponibles aux utilisateurs hors de ces pays durant
	l'ère restrictive du contrôle des exportations de
	code de chiffrement &agrave; partir des USA.</para>

      <para>Alternativement, l'implémentation du MIT de
	Kerberos est disponible dans le catalogue des logiciels
	portés sous
        <package>security/krb5</package>.</para>
    </sect2>

    <sect2>
      <title>Créer la base de données initiale</title>

      <para>Cela se fait uniquement sur le serveur Kerberos.
	Vérifiez tout d'abord qu'il ne traîne pas d'anciennes
	bases Kerberos.  Allez dans le répertoire
	<filename>/etc/kerberosIV</filename> et assurez-vous qu'il ne
	contient que les fichiers suivants:</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README		krb.conf        krb.realms</screen>

      <para>S'il y a d'autres fichiers (comme
	<filename>principal.*</filename> ou
	<filename>master_key</filename>), utilisez alors la commande
	<command>kdb_destroy</command> pour supprimer l'ancienne base de
	données Kerberos, ou si Kerberos ne tourne pas, effacez
	simplement les fichiers supplémentaires.</para>

      <para>Vous devez maintenant éditer les fichiers
	<filename>krb.conf</filename> et <filename>krb.realms</filename>
	pour définir votre domaine Kerberos.  Dans notre cas,
	le domaine sera  <literal>EXAMPLE.COM</literal> et le
	serveur <systemitem class="fqdomainname">grunt.example.com</systemitem>.  Nous
	éditons ou créons le fichier
	<filename>krb.conf</filename>:</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>Dans notre cas les autres domaines n'ont pas besoin
	d'être mentionnés.  Ils ne sont l&agrave; que pour
	montrer comment une machine peut avoir connaissance de
	plusieurs domaines.  Pour plus de simplicité, vous
	pouvez ne pas les inclure.</para>

      <para>La première ligne indique pour quel domaine cette
	machine agit.  Les autre lignes définissent les autres
	domaines/machines.  Le premier élément sur une ligne
	est le domaine, le second le nom de la machine qui est le
	&ldquo;centre de distribution de clés&rdquo; de ce
	domaine.  Les mots <literal>admin server</literal> qui suivent
	un nom de machine signifient que la machine est aussi serveur
	d'administration de la base de données.  Pour plus
	d'explication sur cette terminologie, consultez les pages de
	manuel de Kerberos.</para>

      <para>Nous devons maintenant ajouter <systemitem class="fqdomainname">grunt.example.com</systemitem> au domaine
	<literal>EXAMPLE.COM</literal> et ajouter une entrée pour
	mettre toutes les machines du domaine DNS <systemitem class="fqdomainname">.example.com</systemitem> dans le domaine
	Kerberos <literal>EXAMPLE.COM</literal>.  Le fichier
	<filename>krb.realms</filename> aura alors l'allure
	suivante:</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>Encore une fois, les autres domaines n'ont pas besoin
	d'être mentionnés.  Ils ne sont l&agrave; que pour
	montrer comment une machine peut avoir connaissance de
	plusieurs domaines.  Pour plus de simplicité, vous pouvez
	ne pas les inclure.</para>

      <para>La première ligne assigne un système
	<emphasis>particulier</emphasis> au domaine désigné.
	Les lignes restantes montrent comment affecter par défaut
	les systèmes d'un sous-domaine DNS particulier &agrave; un
	domaine Kerberos donné.</para>

      <para>Nous sommes maintenant prêt pour la création
	de la base de données.  Il n'y a &agrave; le faire que
	sur le serveur Kerberos (ou Centre de Distribution de
	Clés).  Cela se fait avec la commande
	<command>kdb_init</command>:</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

<prompt>Enter Kerberos master key:</prompt> </screen>

      <para>Nous devons maintenant sauvegarder la clé pour que
	les serveurs sur la machine locale puissent la lire.
	Utilisons la commande <command>kstash</command> pour faire
	cela:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!</screen>

      <para>Le mot de passe maître chiffré est
	sauvegardé dans
	<filename>/etc/kerberosIV/master_key</filename>.</para>
    </sect2>

    <sect2>
      <title>Installer les services</title>

      <para>Il faut ajouter deux entrées (&ldquo;principals&rdquo;)
	&agrave; la base de données pour <emphasis>chaque</emphasis>
	système qui sera sécurisé par Kerberos.  Ce
	sont <literal>kpasswd</literal> et <literal>rcmd</literal>.
	Ces deux entrées sont définies pour chaque
	système, chacune de leurs instances se voyant
	attribuer le nom du système.</para>

      <para>Ces &ldquo;daemons&rdquo;,
	<application>kpasswd</application> et
	<application>rcmd</application> permettent aux autres
	systèmes de changer les mots de passe Kerberos et
	d'exécuter des commandes comme &man.rcp.1;,
	&man.rlogin.1;, et &man.rsh.1;.</para>

      <para>Ajoutons donc maintenant ces entrées:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- entrez RANDOM ici
Verifying password

<prompt>New Password:</prompt> &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>		&lt;---- entrez RANDOM ici
Verifying password

<prompt>New Password:</prompt>           &lt;---- entrez RANDOM ici

<prompt>Random password [y] ?</prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>         &lt;---- ne rien entrer ici permet de quitter le programme</screen>
    </sect2>

    <sect2>
      <title>Créer le fichier des services</title>

      <para>Il faut maintenant extraire les instances qui
	définissent les services sur chaque machine.  Pour cela
	on utilise la commande <command>ext_srvtab</command>.
	Cela créera un fichier qui doit être copié
	ou déplacé <emphasis>par un moyen
	sûr</emphasis> dans le répertoire
	<filename>/etc/kerberosIV</filename> de chaque client
	Kerberos.  Ce fichier doit être présent sur
	chaque serveur et client, et est crucial au bon fonctionnement
	de Kerberos.</para>


      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>
<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>Cette commande ne génère qu'un fichier temporaire
	qui doit être renommé en <filename>srvtab</filename>
	pour que tous les serveurs puissent y accéder.
	Utilisez la commande &man.mv.1; pour l'installer sur le
	système d'origine:</para>

      <screen>&prompt.root; <userinput>mv grunt-new-srvtab srvtab</userinput></screen>

      <para>Si le fichier est destiné &agrave; un client, et que
	le réseau n'est pas considéré comme sûr,
	alors copiez le fichier
	<filename>client-new-srvtab</filename>
	sur un support amovible et transportez-le par un moyen
	physiquement sûr.  Assurez-vous de le renommer en
	<filename>srvtab</filename> dans le répertoire
	<filename>/etc/kerberosIV</filename> du client, et mettez-le
	bien en mode 600:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>Renseigner la base de données</title>

      <para>Nous devons maintenant créer des entrées
	utilisateurs dans la base de données.  Tout d'abord
	créons une entrée pour l'utilisateur
	<systemitem class="username">jane</systemitem>.  Utilisez la commande
	<command>kdb_edit</command> pour cela:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                &lt;---- entrez un mot de passe sûr ici
Verifying password

<prompt>New Password:</prompt>                &lt;---- réentrez le mot de passe sûr l&agrave;
Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		   &lt;---- ne rien entrer ici permet de quitter le programme</screen>
    </sect2>

    <sect2>
      <title>Tester l'ensemble</title>

      <para>Il faut tout d'abord démarrer les &ldquo;daemons&rdquo;
	Kerberos.  Notez que si vous avez correctement modifié
	votre fichier <filename>/etc/rc.conf</filename>, cela se fera
	automatiquement au redémarrage du système.  Ceci
	n'est nécessaire que sur le serveur Kerberos.  Les
	clients Kerberos récupéreront automatiquement les
	informations dont ils ont besoin via leur répertoire
	<filename>/etc/kerberosIV</filename>.</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>Nous pouvons maintenant utiliser la commande
	<command>kinit</command> pour obtenir un &ldquo;ticket
	d'entrée&rdquo; pour l'utilisateur
	<systemitem class="username">jane</systemitem> que nous avons créé
	plus haut:</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para>Essayons de lister les informations associées
	avec la commande <command>klist</command> pour voir si nous
	avons vraiment tout ce qu'il faut:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>

      <para>Essayons maintenant de modifier le mot de passe en
	utilisant la commande &man.passwd.1; pour vérifier
	si le &ldquo;daemon&rdquo; <application>kpasswd</application>
	est autorisé &agrave; accéder &agrave; la base
	de données Kerberos:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title>Autoriser l'utilisation de la commande
	<command>su</command></title>

      <para>Kerberos permet d'attribuer &agrave;
	<emphasis>chaque</emphasis> utilisateur qui a besoin des droits
        du super-utilisateur son <emphasis>propre</emphasis> mot de
	passe &man.su.1;.  Nous pouvons créer un identifiant
	qui est autorisé &agrave; utiliser &man.su.1;
	pour devenir <systemitem class="username">root</systemitem>.  Cela se fait en
	associant une instance <systemitem class="username">root</systemitem> un
	identificateur (&ldquo;principal&rdquo;) de base.  En
	utilisant la commande <command>kdb_edit</command> nous pouvons
	créer l'entrée <literal>jane.root</literal>
	dans la base de données Kerberos:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- entrez un mot de passe SUR ici
Verifying password

<prompt>New Password:</prompt>    	 	 &lt;---- réentrez le mot de passe ici

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- Laissez une valeur faible!
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		         &lt;---- ne rien entrer ici permet de quitter le programme</screen>

      <para>Vérifions maintenant les caractéristiques
	associées pour voir si cela fonctionne:</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password:</prompt></screen>

      <para>Nous devons maintenant ajouter l'utilisateur au fichier
	<filename>.klogin</filename> de
	<systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Essayons maintenant la commande &man.su.1;:</para>

      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt></screen>

      <para>et voyons quelles sont nos caractéristiques:</para>

      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>Utiliser d'autres commandes</title>

      <para>Dans l'exemple précédent, nous avons
	créé une entrée principale nommée
	<literal>jane</literal> avec une instance <literal>root</literal>.
	Cette entrée reposait sur un utilisateur ayant le même
	nom que l'entrée principale, c'est ce que fait par
	défaut Kerberos; une
	<literal>&lt;entrée_principale&gt;.&lt;instance&gt;</literal>
	de la forme
	<literal>&lt;nom_d_utilisateur&gt;.</literal><systemitem class="username">root</systemitem>
	autorisera <literal>&lt;nom_d_utilisateur&gt;.</literal> &agrave;
	utiliser &man.su.1; pour devenir <systemitem class="username">root</systemitem> si
	le fichier <filename>.klogin</filename> du répertoire
	personnel de l'utilisateur <systemitem class="username">root</systemitem> est
	correctement renseigné:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>De même, si un utilisateur a dans son répertoire des
	lignes de la forme:</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>

      <para>Cela permet &agrave; quiconque dans le domaine
	<literal>EXAMPLE.COM</literal> s'étant authentifié
	en tant que <systemitem class="username">jane</systemitem> ou
	<systemitem class="username">jack</systemitem> (via <command>kinit</command>, voir
	plus haut) d'accéder avec &man.rlogin.1; au compte de
	<systemitem class="username">jane</systemitem> ou &agrave; ses fichiers sur le
	système (<systemitem>grunt</systemitem>) via &man.rlogin.1;,
	&man.rsh.1; ou &man.rcp.1;.</para>

      <para>Par exemple, <systemitem class="username">jane</systemitem> ouvre maintenant
	une session sur un autre système en utilisant
	Kerberos:</para>

	    <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>Ou bien <systemitem class="username">jack</systemitem> ouvre une session sur le
	compte de <systemitem class="username">jane</systemitem> sur la même machine
	(<systemitem class="username">jane</systemitem> ayant modifié son fichier
	<filename>.klogin</filename> comme décrit plus haut, et la
	personne an charge de Kerberos ayant défini une entrée
	principale <emphasis>jack</emphasis> sans instance):</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="kerberos5">
    <info><title><application>Kerberos5</application> ** Traduction en Cours **</title>
      <authorgroup>
	<author><personname><firstname>Tillman</firstname><surname>Hodgson</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Murray</surname></personname><contrib>Based on a contribution by </contrib><contrib>Basé sur une contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <para/>
  </sect1>

  <sect1 xml:id="openssl">
    <info><title>OpenSSL</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Ecrit par </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>sécurité</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>

    <para>Une des caractéristiques que de nombreux utilisateurs
      ignorent souvent est la présence des outils
      <application>OpenSSL</application> dans le système &os;.
      <application>OpenSSL</application> fournit une couche de
      transport des données chiffrée par-dessus la
      couche de communication, lui permettant ainsi d'être
      liée &agrave; de nombreux services et applications
      réseau.</para>

    <para>Les applications d'<application>OpenSSL</application>
      pourront être l'authentification chiffrée de
      clients de messagerie, les transactions via le Web comme les
      paiements par carte bancaire et bien plus encore.  De nombreux
      logiciels portés tels que <package>www/apache13-ssl</package>, et <package>mail/sylpheed-claws</package> offriront un
      support pour <application>OpenSSL</application> lors de leur
      compilation.</para>

    <note>
      <para>Dans la plupart des cas le catalogue des logiciels
	portés tentera de compiler le logiciel porté
	<package>security/openssl</package> &agrave;
	moins que la variable &man.make.1;
	<varname>WITH_OPENSSL_BASE</varname> ne soit explicitement
	fixée &agrave; la valeur <quote>yes</quote>.</para>
    </note>

    <para>La version d'<application>OpenSSL</application> fournie avec
      &os; supporte les protocoles de sécurité
      réseau <emphasis>Secure Sockets Layer v2/v3</emphasis>
      (SSLv2/SSLv3), et <emphasis>Transport Layer Security
      v1</emphasis> (TLSv1) et peut être utilisée comme
      bibliothèque de chiffrement d'usage
      général.</para>

    <note>
      <para>Bien que <application>OpenSSL</application> supporte
	l'algorithme <acronym>IDEA</acronym>, il est
	désactivé par défaut en raison des
	problèmes de brevets aux USA.  Pour l'utiliser, le
	texte de la licence devrait être consulté et si
	les termes de cette licence sont acceptables, la variable
	<varname>MAKE_IDEA</varname> doit être activée
	dans le fichier <filename>make.conf</filename>.</para>
    </note>

    <para>Une des utilisations les plus courantes
      d'<application>OpenSSL</application> est de fournir des
      certificats utilisables avec des applications logicielles.  Ces
      certificats assurent que les références de la
      société ou d'un individu sont valides et non
      frauduleuses.  Si le certificat en question n'a pas
      été vérifié par une des nombreuses
      <quote>autorité de certification</quote>
      (<quote>Certificate Authorities</quote>) ou
      <acronym>CA</acronym>s, une alerte est
      généralement produite.  Une autorité de
      certification est une société, comme <link xlink:href="http://www.verisign.com">VeriSign</link>, qui signera les
      certificats afin de valider les références
      d'individus ou de sociétés.  Ce processus a un
      coût et n'est pas obligatoire pour utiliser des
      certificats, cependant cela pourra mettre plus &agrave; l'aise
      les utilisateurs les plus paranoïaques.</para>

    <sect2>
      <title>Générer des certificats</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>génération de certificats</secondary>
      </indexterm>

      <para>Pour générer un certificat, la commande
	suivante est disponible:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput>US</userinput>
State or Province Name (full name) [Some-State]:<userinput>PA</userinput>
Locality Name (eg, city) []:<userinput>Pittsburgh</userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput>My Company</userinput>
Organizational Unit Name (eg, section) []:<userinput>Systems Administrator</userinput>
Common Name (eg, YOUR name) []:<userinput>localhost.example.org</userinput>
Email Address []:<userinput>trhodes@FreeBSD.org</userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput>SOME PASSWORD</userinput>
An optional company name []:<userinput>Another Name</userinput></screen>

      <para>Notez la réponse &agrave; la question <quote>Common
	Name</quote> qui est un nom de domaine.  Cette question
	demande l'entrée d'un serveur de noms &agrave; des fins
	de vérification; entrer autre chose qu'un nom de
	domaine produira un certificat inutilisable.  D'autres options
	sont disponibles comme par exemple: la date d'expiration, des
	algorithmes de chiffrement alternatifs, etc.  Une liste
	complète peut être obtenue en consultant la page
	de manuel &man.openssl.1;.</para>

      <para>Deux fichiers doivent maintenant être
	présents dans le répertoire dans lequel la
	commande a été exécutée.  La
	demande de certificat, <filename>req.pem</filename>, peut
	être envoyée &agrave; une autorité de
	certification qui validera les références que
	vous avez saisies, signera la demande et vous retournera le
	certificat.  Le deuxième fichier s'appellera
	<filename>cert.pem</filename> et sera la clé
	privée du certificat et devra être &agrave; tout
	prix protégée; si ce fichier tombe dans d'autres
	mains, il pourra être utilisé pour imiter votre
	identité (ou votre serveur).</para>

      <para>Pour les cas où une signature d'une
	<acronym>CA</acronym> n'est pas indispensable, un certificat
	auto-signé peut être créé.
	Générez tout d'abord la clé
	<acronym>RSA</acronym>:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out myRSA.key 1024</userinput></screen>

      <para>Générez ensuite la clé de la
	<acronym>CA</acronym>:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out myca.key myRSA.key</userinput></screen>

      <para>Utilisez cette clé pour créer le
	certificat:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key myca.key -out new.crt</userinput></screen>

      <para>Deux fichiers devraient être présents
	maintenant dans le répertoire: un fichier de signature
	de l'autorité de certification,
	<filename>myca.key</filename>, et le certificat
	lui-même, <filename>new.crt</filename>.  Ces fichiers
	doivent être placés dans un répertoire, de
	préférence sous <filename>/etc</filename>, qui est uniquement lisible
	que par <systemitem class="username">root</systemitem>.  Les permissions 0700
	devraient convenir et peuvent être fixées
	&agrave; l'aide de l'utilitaire
	<command>chmod</command>.</para>
    </sect2>

    <sect2>
      <title>Utilisation des certificats, un exemple</title>

      <para>A quoi peuvent servir ces fichiers?  Un bon exemple serait
	le chiffrage des connexions au <acronym>MTA</acronym>
	<application>sendmail</application>.  Cela permettra de faire
	disparaître l'utilisation d'une authentification en
	clair pour les utilisateurs qui envoient du courrier via le
	<acronym>MTA</acronym> local.</para>

      <note>
	<para>Ce n'est pas la meilleure utilisation au monde
	  étant donné que certains clients de messagerie
	  afficheront une erreur si le certificat n'a pas
	  été installé localement.  Reportez-vous
	  &agrave; la documentation du logiciel pour plus
	  d'information sur l'installation de certificats.</para>
      </note>

      <para>Les lignes suivantes doivent être ajoutées
	dans le fichier <filename>.mc</filename> local:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Où <filename>/etc/certs/</filename> est le
	répertoire &agrave; utiliser pour stocker localement
	les certificats et les clés.  La dernière
	condition nécessaire étant une reconstruction du
	fichier <filename>.cf</filename>.  Cela se fait facilement en
	tapant <command>make</command> <parameter>install</parameter>
	&agrave; l'intérieur du répertoire <filename>/etc/mail</filename>.  Suivi d'un
	<command>make</command> <parameter>restart</parameter> qui
	devrait relancer le <quote>daemon</quote>
	<application>sendmail</application>.</para>

      <para>Si tout s'est bien passé il n'y aura pas de message
	d'erreur dans le fichier <filename>/var/log/maillog</filename>
	et <application>sendmail</application> apparaîtra dans
	la liste des processus.</para>

      <para>Comme test simple, connectez vous au serveur de messagerie
	&agrave; l'aide de l'utilitaire &man.telnet.1;:</para>

      <screen>&prompt.root; <userinput>telnet example.com 25</userinput>
Trying 192.0.34.166...
Connected to <systemitem class="fqdomainname">example.com</systemitem>.
Escape character is '^]'.
220 <systemitem class="fqdomainname">example.com</systemitem> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo example.com</userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <systemitem class="fqdomainname">example.com</systemitem> closing connection
Connection closed by foreign host.</screen>

      <para>Si la ligne <quote>STARTTLS</quote> apparaît dans la
	sortie, cela signifie alors que tout fonctionne
	correctement.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ipsec">
    <info><title>IPsec</title>
      <authorgroup>
	<author><personname><firstname>Yoshinobu</firstname><surname>Inoue</surname></personname><contrib>Contribution de </contrib></author>
	<!-- 5 Mar 2000 -->
      </authorgroup>
    </info>

    
    <indexterm><primary>IPsec</primary></indexterm>
    <indexterm>
      <primary>sécurité</primary>
      <secondary>IPsec</secondary>
    </indexterm>

    <note>
      <title>Caractères de terminaison</title>
      <para>Dans tous les exemples de cette section, et d'autres
	sections, vous remarquerez qu'il y aura un &ldquo;^D&rdquo;
	&agrave; la fin de certains exemples.  Cela signifie qu'il faut
	maintenir la touche <keycap>Ctrl</keycap> enfoncée
	et appuyer sur la touche <keycap>D</keycap>.  Un autre
	caractère couramment utilisé est &ldquo;^C&rdquo;,
	qui signifie de maintenir enfoncé la touche
	<keycap>Ctrl</keycap> et d'appuyer sur
	<keycap>C</keycap>.</para>
    </note>

    <tip>
      <para>Pour d'autres documents détaillant
	l'implémentation d'IPsec, jetez un oeil &agrave;
        <uri xlink:href="http://www.daemonnews.org/200101/ipsec-howto.html">http://www.daemonnews.org/200101/ipsec-howto.html</uri>
        et <uri xlink:href="http://www.freebsddiary.org/ipsec.php">http://www.freebsddiary.org/ipsec.php</uri>.</para>
    </tip>

    <para>Le mécanisme IPsec fournit des communications
      sécurisées sur couche IP ou &agrave; travers les
      <emphasis>sockets</emphasis>.  Cette section explique comment
      l'utiliser.  Pour des détails concernant
      l'implémentation d'IPsec, reportez-vous au
      <link xlink:href="../developers-handbook/ipv6.html">Manuel du
      développeur</link>.</para>

    <para>L'implémentation actuelle d'IPsec supporte le mode
      transport et le mode tunnel.  Cependant, il y a des restrictions
      au mode tunnel.  <uri xlink:href="http://www.kame.net/newsletter/">http://www.kame.net/newsletter/</uri> fournit des
      exemples plus exhaustifs.</para>

    <para>Soyez informé que pour utiliser cette fonctionnalité,
      vous devez avoir les options suivantes présentes dans
      votre fichier de configuration du noyau:</para>

    <programlisting>options          IPSEC              #IP security
options          IPSEC_ESP          #IP security (crypto; define w/IPSEC)</programlisting>

    <sect2>
      <title>Exemple en mode transport avec IPv4</title>

      <para>Configurons une association de sécurité
	pour déployer un canal sécurisé entre la Machine A
	(<systemitem class="ipaddress">10.2.3.4</systemitem>) et la Machine B
	(<systemitem class="ipaddress">10.6.7.8</systemitem>).  Notre exemple est
	un peu compliqué.  De A vers B, nous n'utilisons que
	l'ancien AH.  De B vers A, le nouvel AH et le nouvel ESP sont
	combinés.</para>

      <para>Nous devons maintenant choisir les algorithmes
	correspondant &agrave;
        &ldquo;AH&rdquo;/&ldquo;nouvel AH&rdquo;/&ldquo;ESP&rdquo;/
	&ldquo;nouvel ESP&rdquo;.  Reportez-vous &agrave; la page de manuel
	&man.setkey.8; pour connaître les noms des algorithmes.
	Nous utiliserons MD5 pour AH, new-HMAC-SHA1 pour le nouvel AH,
	et new-DES-expIV avec 8 octets IV pour le nouvel ESP.</para>

      <para>La longueur de la clé dépend de chaque algorithme.
	Par exemple, elle doit être égale &agrave; 16 octets
	pour MD5, 20 pour new-HMAC-SHA1, et 8 pour new-DES-expIV.
	Nous choisissons maintenant &ldquo;MYSECRETMYSECRET&rdquo;,
        &ldquo;KAMEKAMEKAMEKAMEKAME&rdquo;, &ldquo;PASSWORD&rdquo;,
	respectivement.</para>

      <para>Définissons maintenant le SPI (<emphasis>Security Parameter
	Index</emphasis>) pour chaque protocole.  Remarquez qu'il nous
	faut 3 SPIs pour ce canal sécurisé puisqu'il y aura
	trois entêtes de sécurité (une de la Machine A vers la
	Machine B et deux de la Machine B vers la Machine A).  Notez
	également que les SPIs doivent être supérieurs
	&agrave; 256.  Nous choisirions 1000, 2000 et 3000
	respectivement.</para>

      <screen>
	          (1)
	Machine A ------&gt; Machine B

	(1)PROTO=AH
		ALG=MD5(RFC1826)
		KEY=MYSECRETMYSECRET
		SPI=1000

	           (2.1)
	Machine A &lt;------ Machine B
	          &lt;------
	           (2.2)

	(2.1)
	PROTO=AH
		ALG=new-HMAC-SHA1(new AH)
		KEY=KAMEKAMEKAMEKAMEKAME
		SPI=2000

	(2.2)
	PROTO=ESP
		ALG=new-DES-expIV(new ESP)
			IV length = 8
		KEY=PASSWORD
		SPI=3000
</screen>

      <para>Maintenant, définissons l'association de
	sécurité.  Exécutons &man.setkey.8; sur
	la Machine A et la Machine B:</para>

      <screen>&prompt.root; <userinput>setkey -c
    add 10.2.3.4 10.6.7.8 ah-old  1000 -m transport -A keyed-md5 "MYSECRETMYSECRET" ;
    add 10.6.7.8 10.2.3.4 ah  2000 -m transport -A hmac-sha1 "KAMEKAMEKAMEKAMEKAME" ;
    add 10.6.7.8 10.2.3.4 esp 3000 -m transport -E des-cbc "PASSWORD" ;
    ^D</userinput></screen>

      <para>En fait, la communication IPsec n'aura pas lieu avant que
	les entrées de politique de sécurité
	ne soient définies.  Dans notre cas, il faut le faire sur les
	deux machines.</para>

      <screen>
Côté A:

&prompt.root; <userinput>setkey -c
    spdadd 10.2.3.4 10.6.7.8 any -P out ipsec
	ah/transport/10.2.3.4-10.6.7.8/require ;
    ^D</userinput>

Côté B:

&prompt.root; <userinput>setkey -c
    spdadd 10.6.7.8 10.2.3.4 any -P out ipsec
	esp/transport/10.6.7.8-10.2.3.4/require ;
    spdadd 10.6.7.8 10.2.3.4 any -P out ipsec
	ah/transport/10.6.7.8-10.2.3.4/require ;
    ^D</userinput>


   Machine A --------------------------&gt; Machine E
   10.2.3.4                               10.6.7.8
      |                                     |
      ========= ancien AH keyed-md5 ========&gt;

      &lt;======== nouveau AH hmac-sha1 ========
      &lt;======== nouveau ESP des-cbc =========
</screen>
    </sect2>

    <sect2>
      <title>Exemple en mode transport avec IPv6</title>

      <para>Un autre exemple utilisant IPv6.</para>

      <para>Le mode de transport ESP est recommandé pour le
	port TCP numéro 110 entre la Machine-A et la
	Machine-B.</para>

      <screen>
              ============ ESP ============
              |                           |
          Machine-A                   Machine-B
          fec0::10 -------------------- fec0::11
</screen>

      <para>L'algorithme de chiffrement est blowfish-cbc avec la
	clé &ldquo;kamekame&rdquo;, et l'algorithme
	d'authentification est hmac-sha1 avec la clé
	&ldquo;this is the test key&rdquo;.  Configuration de la
	Machine-A:</para>

      <screen>&prompt.root; <userinput>setkey -c &lt;&lt;EOF
    spdadd fec0::10[any] fec0::11[110] tcp -P out ipsec
	esp/transport/fec0::10-fec0::11/use ;
    spdadd fec0::11[110] fec0::10[any] tcp -P in ipsec
	esp/transport/fec0::11-fec0::10/use ;
    add fec0::10 fec0::11 esp 0x10001
	-m transport
	-E blowfish-cbc "kamekame"
	-A hmac-sha1 "this is the test key" ;
    add fec0::11 fec0::10 esp 0x10002
	-m transport
	-E blowfish-cbc "kamekame"
	-A hmac-sha1 "this is the test key" ;
    EOF</userinput></screen>

      <para>et de la Machine-B:</para>

      <screen>&prompt.root; <userinput>setkey -c &lt;&lt;EOF
    spdadd fec0::11[110] fec0::10[any] tcp -P out ipsec
	esp/transport/fec0::11-fec0::10/use ;
    spdadd fec0::10[any] fec0::11[110] tcp -P in ipsec
	esp/transport/fec0::10-fec0::11/use ;
    add fec0::10 fec0::11 esp 0x10001 -m transport
	-E blowfish-cbc "kamekame"
	-A hmac-sha1 "this is the test key" ;
    add fec0::11 fec0::10 esp 0x10002 -m transport
	-E blowfish-cbc "kamekame"
	-A hmac-sha1 "this is the test key" ;
    EOF</userinput></screen>

      <para>Remarquez la direction de SP.</para>
    </sect2>

    <sect2>
      <title>Exemple en mode tunnel avec IPv4</title>

      <para>Mode tunnel entre deux passerelles de
	sécurité</para>

      <para>Le protocole de sécurité est l'ancien mode
	tunnel AH, i.e. spécifié par la RFC1826,
	avec keyed-md5 comme algorithme d'authentification
	et &ldquo;this is the test&rdquo; comme clé.</para>

      <screen>
                             ======= AH =======
                             |                |
         Réseau-A       Passerelle-A     Passerelle-B       Réseau-B
        10.0.1.0/24 ---- 172.16.0.1 ----- 172.16.0.2 ---- 10.0.2.0/24
</screen>

      <para>Configuration de la Passerelle-A:</para>

      <screen>&prompt.root; <userinput>setkey -c &lt;&lt;EOF
    spdadd 10.0.1.0/24 10.0.2.0/24 any -P out ipsec
	ah/tunnel/172.16.0.1-172.16.0.2/require ;
    spdadd 10.0.2.0/24 10.0.1.0/24 any -P in ipsec
	ah/tunnel/172.16.0.2-172.16.0.1/require ;
    add 172.16.0.1 172.16.0.2 ah-old 0x10003 -m any
	-A keyed-md5 "this is the test" ;
    add 172.16.0.2 172.16.0.1 ah-old 0x10004 -m any
	-A keyed-md5 "this is the test" ;

EOF</userinput></screen>

      <para>Si le numéro de port n'est pas précisé
	comme ci-dessus, alors <literal>[any]</literal> est
	utilisé.  <literal>-m</literal> définit le mode
	de SA &agrave; utiliser. <literal>-m any</literal> signifie
	tout mode de protocole de sécurité.  Vous
	pouvez utiliser cette SA &agrave; la fois en mode transport
	et en mode tunnel.</para>

      <para>et de la Passerelle-B:</para>

      <screen>&prompt.root; <userinput>setkey -c &lt;&lt;EOF
    spdadd 10.0.2.0/24 10.0.1.0/24 any -P out ipsec
	ah/tunnel/172.16.0.2-172.16.0.1/require ;
    spdadd 10.0.1.0/24 10.0.2.0/24 any -P in ipsec
	ah/tunnel/172.16.0.1-172.16.0.2/require ;
    add 172.16.0.1 172.16.0.2 ah-old 0x10003 -m any
	-A keyed-md5 "this is the test" ;
    add 172.16.0.2 172.16.0.1 ah-old 0x10004 -m any
	-A keyed-md5 "this is the test" ;

EOF</userinput></screen>

      <para>Etablir une SA regroupée entre deux passerelles
	de sécurité</para>

      <para>On désire le mode de transport AH et le mode
	tunnel ESP entre Passerelle-A et Passerelle-B.  Dans ce
	cas, on applique d'abord le mode tunnel ESP puis le mode
	de transport AH.</para>

      <screen>
                            ========== AH =========
                            |  ======= ESP =====  |
                            |  |               |  |
       Réseau-A         Passerelle-A        Passerelle-B        Réseau-B
    fec0:0:0:1::/64 --- fec0:0:0:1::1 ---- fec0:0:0:2::1 --- fec0:0:0:2::/64
</screen>
    </sect2>

    <sect2>
      <title>Exemple en mode tunnel avec IPv6</title>

      <para>L'algorithme de chiffrement est 3des-cbc, et l'algorithme
	d'authentification est hmac-sha1.  L'algorithme
	d'authentification pour AH est hmac-md5.  Configuration de la
	Passerelle-A:</para>

      <screen>&prompt.root; <userinput>setkey -c &lt;&lt;EOF
    spdadd fec0:0:0:1::/64 fec0:0:0:2::/64 any -P out ipsec
	esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require
	ah/transport/fec0:0:0:1::1-fec0:0:0:2::1/require ;
    spdadd fec0:0:0:2::/64 fec0:0:0:1::/64 any -P in ipsec
	esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require
	ah/transport/fec0:0:0:2::1-fec0:0:0:1::1/require ;
    add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10001 -m tunnel
	-E 3des-cbc "kamekame12341234kame1234"
	-A hmac-sha1 "this is the test key" ;
    add fec0:0:0:1::1 fec0:0:0:2::1 ah 0x10001 -m transport
	-A hmac-md5 "this is the test" ;
    add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10001 -m tunnel
	-E 3des-cbc "kamekame12341234kame1234"
	-A hmac-sha1 "this is the test key" ;
    add fec0:0:0:2::1 fec0:0:0:1::1 ah 0x10001 -m transport
	-A hmac-md5 "this is the test" ;

    EOF</userinput></screen>

      <para>Etablir des SAs avec les différentes
	extrémités</para>

      <para>On désire un mode tunnel ESP entre Machine-A et
	Passerelle-A.  L'algorithme de chiffrement est cast128-cbc,
	et l'algorithme d'authentification pour ESP est hmac-sha1.
	Le mode de transport ESP est recommandé entre Machine-A
	et Machine-B.  L'algorithme de chiffrement est rc5-cbc, et
	l'algorithme d'authentification pour ESP est hmac-md5.</para>

      <screen>
              ================== ESP =================
              |  ======= ESP =======                 |
              |  |                 |                 |
            Machine-A        Passerelle-A         Machine-B
          fec0:0:0:1::1 ---- fec0:0:0:2::1 ---- fec0:0:0:2::2
</screen>

      <para>Configuration de la Machine-A:</para>

      <screen>&prompt.root; <userinput>setkey -c &lt;&lt;EOF
    spdadd fec0:0:0:1::1[any] fec0:0:0:2::2[80] tcp -P out ipsec
	esp/transport/fec0:0:0:1::1-fec0:0:0:2::2/use
	esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require ;
    spdadd fec0:0:0:2::1[80] fec0:0:0:1::1[any] tcp -P in ipsec
	esp/transport/fec0:0:0:2::2-fec0:0:0:l::1/use
	esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require ;
    add fec0:0:0:1::1 fec0:0:0:2::2 esp 0x10001
	-m transport
	-E cast128-cbc "12341234"
	-A hmac-sha1 "this is the test key" ;
    add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10002
	-E rc5-cbc "kamekame"
	-A hmac-md5 "this is the test" ;
    add fec0:0:0:2::2 fec0:0:0:1::1 esp 0x10003
	-m transport
	-E cast128-cbc "12341234"
	-A hmac-sha1 "this is the test key" ;
    add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10004
	-E rc5-cbc "kamekame"
	-A hmac-md5 "this is the test" ;

    EOF</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="openssh">
    <info><title>OpenSSH</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Contribution de </contrib></author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </info>

    
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>sécurité</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> est un ensemble d'outils
      de connexion réseau utilisés pour
      accéder &agrave; des machines
      distantes de façon sécurisée.  Ils peuvent
      être utilisés comme remplaçants directs de
      <command>rlogin</command>, <command>rsh</command>,
      <command>rcp</command>, et <command>telnet</command>.
      De plus, <application>OpenSSH</application> peut
      sécuriser n'importe quelle connexion
      TCP/IP via un tunnel.  <application>OpenSSH</application>
      chiffre tout le trafic de façon
      &agrave; déjouer les écoutes réseau, les
      prises de contrôle de connexion, et aux attaques au niveau
      du réseau.</para>

    <para><application>OpenSSH</application> est maintenu par le
      projet OpenBSD, et est basé sur SSH v1.2.12 avec tous les
      récentes corrections et mises &agrave; jour.  Il est
      compatible avec les protocoles SSH 1 et 2.
      <application>OpenSSH</application> est présent dans le
      système de base depuis &os;&nbsp;4.0.</para>

    <sect2>
      <title>Les avantages &agrave; utiliser OpenSSH</title>

      <para>Normalement, quand on utilise &man.telnet.1; ou
	&man.rlogin.1;, les données sont envoyées sur le
	réseau en clair, sous forme non chiffrée.
	Des &ldquo;renifleurs de paquets&rdquo; placés
	n'importe où entre le client et le serveur peuvent
	prendre connaissance de votre nom d'utilisateur, de votre mot
	de passe et des données transmises lors de votre session.
	<application>OpenSSH</application> offre une
	variété de méthodes d'authentification et
	de chiffrage pour éviter ce genre de
	problème.</para>
    </sect2>

    <sect2>
      <title>Activer sshd</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>activation</secondary>
      </indexterm>

      <para>Assurez-vous d'ajouter la ligne suivante &agrave;
	votre fichier <filename>rc.conf</filename>:</para>

      <screen>sshd_enable="YES"</screen>

      <para>Cela chargera le &ldquo;daemon&rdquo;
	<application>ssh</application> &agrave; l'initialisation suivante
	du système.  Alternativement, vous pouvez tout simplement
	exécuter le &ldquo;daemon&rdquo;
	<application>sshd</application> directement en tapant
	<command>sshd</command> sur la ligne de commande.</para>
    </sect2>

    <sect2>
      <title>Client SSH</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>client</secondary>
      </indexterm>

      <para>L'utilitaire &man.ssh.1; fonctionne de la même
	manière que &man.rlogin.1;:</para>

      <screen>&prompt.root; <userinput>ssh user@example.com</userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>L'ouverture de session se poursuit comme si elle
	avait lancée par &man.rlogin.1; ou &man.telnet.1;.
	Le système SSH utilise un système d'empreinte
	de clé pour vérifier l'authenticité du
	serveur quand le client se connecte.  L'utilisateur est
	invité &agrave; entrer <literal>yes</literal> uniquement
	&agrave; la première connexion.  Lors des futures
	connexions, l'empreinte de la clé sauvegardé est
	vérifiée.  Le client SSH vous avertira si
	l'empreinte sauvée diffère de l'empreinte
	reçue lors de futures tentatives
	de connexion.  Les empreintes sont sauvées dans le
	fichier <filename>~/.ssh/known_hosts</filename>, ou
	<filename>~/.ssh/known_hosts2</filename> pour les empreintes
	du protocole SSH 2.</para>

      <para>Par défaut, les serveurs
	<application>OpenSSH</application> sont
	configurés pour accepter les connexions dans les deux
	protocoles SSH 1 et 2.  Le client peut, cependant, choisir
	entre les deux.  Le protocole 2 est connu pour être plus
	robuste et plus sécurisé que son
	prédécesseur.</para>

      <para><command>ssh</command> peut être forcé &agrave;
	utilisé l'un des protocole en passant l'argument
	<option>-1</option> ou <option>-2</option> pour le protocole 1
	ou 2 respectivement.</para>
    </sect2>

    <sect2>
      <title>Copie sécurisée</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>copie sécurisée</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>La commande &man.scp.1; fonctionne de la même
	manière que &man.rcp.1;; elle copie un fichier vers ou
	&agrave; partir d'une machine distante &agrave; la
	différence qu'elle le fait
	d'une façon sécurisé.</para>

      <screen>&prompt.root; <userinput> scp user@example.com:/COPYRIGHT COPYRIGHT</userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>

      <para>Puisque l'empreinte a déj&agrave; été
	sauvée pour cette machine dans l'exemple
	précédent, cela se vérifie ici quand on utilise
	&man.scp.1;.</para>

      <para>Les arguments passés &agrave; &man.scp.1; sont
	similaires &agrave; ceux de &man.cp.1;, avec le ou les fichiers
	en premier argument, et la destination en second.
	Puisque que le fichier est copié via le réseau, par
	l'intermédiaire de SSH, un ou plusieurs des arguments
	prennent la forme
	<option>utilisateur@machine_distante:&lt;chemin_du_fichier&gt;</option>.</para>
    </sect2>

    <sect2>
      <title>Configuration</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>configuration</secondary>
      </indexterm>

      <para>Les fichiers de configuration général au
	système pour le &ldquo;daemon&rdquo; et le client
	<application>OpenSSH</application> résident dans le
	répertoire <filename>/etc/ssh</filename>.</para>

      <para><filename>ssh_config</filename> permet de paramétrer
	le client, tandis que <filename>sshd_config</filename>
	s'occupe de la configuration du &ldquo;daemon&rdquo;.</para>

      <para>De plus, les options <option>sshd_program</option>
	(<filename>/usr/sbin/sshd</filename> par défaut),
	et <option>sshd_flags</option> du fichier
	<filename>rc.conf</filename> peut fournir un niveau
	supplémentaire de configuration.</para>
    </sect2>

    <sect2>
      <title>ssh-keygen</title>

      <para>Au lieu d'utiliser des mots de passe, &man.ssh-keygen.1;
	peut être employé pour générer des
	clés RSA pour authentifier un utilisateur:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t rsa1</userinput>
Initializing random number generator...
Generating p:  .++ (distance 66)
Generating q:  ..............................++ (distance 498)
Computing the keys...
Key generation complete.
Enter file in which to save the key (/home/user/.ssh/identity):
Enter passphrase:
Enter the same passphrase again:
Your identification has been saved in /home/user/.ssh/identity.
...</screen>

      <para>&man.ssh-keygen.1; créera une paire de clés
	publique et privée &agrave; utiliser pour l'authentification.
	La clé privée est stockée dans le fichier
        <filename>~/.ssh/identity</filename>, alors que la clé
	publique l'est dans le fichier
	<filename>~/.ssh/identity.pub</filename>.  La clé
	publique doit être placée dans le fichier
        <filename>~/.ssh/authorized_keys</filename> sur la machine
	distante pour que cela fonctionne.</para>

      <para>Ceci autorisera les connexions sur la machine distante
	en utilisant l'authentification RSA &agrave; la place des
	mots de passe.</para>

      <note><para>L'option <option>-t rsa1</option> créera des
	clés RSA pour le protocole SSH 1.  Si vous désirez
	utiliser des clés RSA avec le protocole SSH 2, vous devez
	employer la commande <command>ssh-keygen -t
	rsa</command>.</para></note>

      <para>Si une phrase d'authentification est utilisée
	avec &man.ssh-keygen.1;, l'utilisateur se verra demandé
	d'entrer un mot de passe &agrave; chaque utilisation de la clé
	privé.</para>

      <para>Une clé DSA SSH protocole 2 peut être
	créée pour le même objectif en utilisant
	la commande <command>ssh-keygen -t dsa</command>.
	Cela créera une paire de clés DSA pour les sessions
	SSH utilisant le protocole 2.  La clé publique est
	conservée dans <filename>~/.ssh/id_dsa.pub</filename>,
	tandis que la clé privée se trouve dans
	<filename>~/.ssh/id_dsa</filename>.</para>

      <para>Les clés publiques DSA sont placées dans le
	fichier <filename>~/.ssh/authorized_keys</filename> sur la
	machine distante.</para>

      <para>&man.ssh-agent.1; et &man.ssh-add.1; sont des utilitaires
	employés pour la gestion de multiples clés
	privées protégées par mots de passe.</para>

      <warning><para>Les divers fichiers et options peuvent être
	différents selon la version
	d'<application>OpenSSH</application> dont vous disposez,
	pour éviter les problèmes vous devez consultez la page de
	manuel &man.ssh-keygen.1;.</para></warning>
    </sect2>

    <sect2 xml:id="security-ssh-tunneling">
      <title>Tunnels SSH</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>tunnel</secondary>
      </indexterm>

      <para><application>OpenSSH</application> a la
	capacité de créer un tunnel
	pour encapsuler un autre protocole dans une session
	chiffrée.</para>

      <para>La commande suivante demande &agrave; &man.ssh.1; de
	créer un tunnel pour <application>telnet</application>:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L 5023:localhost:23 user@foo.example.com</userinput>
&prompt.user;</screen>

      <para>La commande <command>ssh</command> est utilisée avec
	les options suivantes:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Force <command>ssh</command> &agrave; utiliser la
	      version du protocole (&agrave; ne pas utiliser si vous
	      travaillez avec de vieux serveurs SSH).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>N'exécute aucune commande &agrave; distance, ou
	      mode se place en mode tunnel.  Si cette option est omise
	      <command>ssh</command> initiera une session
	      normale.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Force <command>ssh</command> &agrave; s'exécuter
	      en arrière-plan.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Spécifie un tunnel local de la manière
	      <replaceable>port_local:machine_distante:port_distant</replaceable>.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Le serveur SSH distant.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


      <para>Un tunnel SSH fonctionne grâce &agrave;
	l'allocation d'une &ldquo;socket&rdquo; qui écoute
	sur le port spécifié de la machine
	<systemitem>localhost</systemitem>.
	Il transfère ensuite toute connexion reçue sur la/le
	machine/port local(e) via la connexion SSH vers la machine et
	le port distants spécifiés.</para>

      <para>Dans l'exemple, le port <replaceable>5023</replaceable>
	sur la machine locale transfère toute connexion
	sur ce port vers le port <replaceable>23</replaceable> de la
	machine distante (le <systemitem>localhost</systemitem> de la
	commande).  Puisque le port <replaceable>23</replaceable> est
	celui de <application>telnet</application>, cela créerai
	une session <application>telnet</application>
	sécurisée par l'intermédiaire
	d'un tunnel SSH.</para>

      <para>Cela peut être utilisé pour
	encapsuler n'importe quel nombre de protocoles TCP non
	sécurisé comme SMTP, POP3, FTP, etc.</para>

      <example>
	<title>Utiliser SSH pour créer un tunnel
	  sécurisé pour SMTP</title>

        <screen>&prompt.user; <userinput>ssh -2 -N -f -L 5025:localhost:25 user@mailserver.example.com</userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

        <para>Ceci peut être utilisé en conjonction
	  avec &man.ssh-keygen.1; et des comptes utilisateurs
	  supplémentaires pour la création et l'accès au
	  tunnel SSH sans trop de problème.
	  Des clés peuvent être utilisées &agrave;
	  la place de la saisie d'un mot de passe, et les tunnels
	  peuvent être exécutés sous un
	  utilisateur séparé.</para>
      </example>

      <sect3>
	<title>Exemples pratiques de tunnels SSH</title>

	<sect4>
	  <title>Accès sécurisé &agrave; un serveur POP3</title>

	  <para>Au travail, il y a un serveur SSH qui accepte les
	    connexions de l'extérieur.  Sur le même réseau
	    d'entreprise réside un serveur de courrier
	    électronique faisant fonctionner un serveur POP3.
	    Le réseau ou le chemin entre chez vous et le bureau
	    peut ou peut ne pas être complètement sûr.
	    Pour cette raison, vous devez récupérer votre
	    courrier électronique d'une façon
	    sécurisée.
	    La solution est de créer une connexion SSH vers
	    le serveur SSH de votre entreprise, et d'utiliser ce
	    tunnel vers le serveur de courrier.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L 2110:mail.example.com:110 user@ssh-server.example.com</userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Quand le tunnel est configuré et fonctionne,
	    vous pouvez demander &agrave; votre client de courrier
	    électronique d'envoyer ses requêtes POP3 sur le
	    port 2110 de la machine locale: <systemitem>localhost</systemitem>.
	    Les connexions seront transférées de façon
	    sécurisé &agrave; travers le tunnel jusqu'&agrave;
	    <systemitem>mail.example.com</systemitem>.</para>
	</sect4>

	<sect4>
	  <title>Passer &agrave; travers un coupe-feu restrictif</title>

	  <para>Certains administrateurs réseau imposent
	    des règles draconiennes au niveau du coupe-feu,
	    filtrant non seulement les connexions entrantes,
	    mais également les connexions sortantes.  Il se
	    peut que vous n'ayez accès qu'aux ports 22 et 80
	    de machines distantes pour SSH ou la navigation
	    Internet.</para>

	  <para>Vous pouvez vouloir accéder &agrave; un autre
	    (n'ayant peut-être aucun rapport avec votre travail)
	    service, comme un serveur Ogg Vorbis pour écouter
	    de la musique.  Si le serveur Ogg Vorbis diffuse
	    (&ldquo;streaming&rdquo;) ses données
	    &agrave; partir d'un port différent
	    des ports 22 ou 80, vous ne serez alors pas en mesure d'y
	    accéder.</para>

	  <para>La solution est de créer une connexion SSH
	    vers une machine &agrave; l'extérieur du
	    réseau protégé
	    par le coupe-feu, et l'utiliser pour créer un
	    tunnel vers le serveur Ogg Vorbis.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L 8888:music.example.com:8000 user@unfirewalled-system.example.org</userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>Vous pouvez maintenant faire pointer votre client
	    pour la récupération du flux de
	    données sur le port 8888
	    de la machine locale, qui sera transféré
	    jusqu'au port 8000 de la machine
	    <systemitem>music.example.com</systemitem>, passant ainsi outre
	    les restrictions du coupe-feu.</para>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Lectures supplémentaires</title>
      <para><link xlink:href="http://www.openssh.com/">OpenSSH</link></para>
      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
        &man.ssh-agent.1; &man.ssh-add.1;</para>
      <para>&man.sshd.8; &man.sftp-server.8;</para>
    </sect2>
  </sect1>

  <sect1 xml:id="fs-acl">
    <info><title>Listes de contrôle d'accès au système de
      fichiers</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>ACL</primary>
    </indexterm>

    <para>Avec les améliorations des systèmes de fichiers
      comme les &ldquo;snapshots&rdquo;, FreeBSD&nbsp;5.0 et versions
      suivantes offrent une nouveauté en matière de
      sécurité: les listes de contrôle d'accès
      au système de fichiers (<acronym>ACL</acronym>s -
      &ldquo;Access Control Lists&rdquo;).</para>

    <para>Les listes de contrôle d'accès étendent
      le système de permission standard d'UNIX d'une manière
      hautement compatible (POSIX.1e).  Cette caractéristique
      permet &agrave; un administrateur d'utiliser avantageusement
      un modèle de sécurité plus
      sophistiqué.</para>

    <para>Pour activer le support <acronym>ACL</acronym> pour les
      systèmes de fichiers <acronym>UFS</acronym>, ce qui
      suit:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>doit être compilé dans le noyau.  Si cette option
      n'a pas été ajoutée, un avertissement sera
      affiché lors d'une tentative de montage d'un système
      de fichiers supportant les <acronym>ACL</acronym>s.
      Cette option est présente dans le noyau
      <filename>GENERIC</filename>.  Les <acronym>ACL</acronym>s
      reposent sur des attributs étendus rajoutés
      au système de fichiers.  Les attributs étendus sont
      nativement supportés par la prochaine
      génération du système de fichiers UNIX,
      <acronym>UFS2</acronym>.</para>

    <note>
      <para>Un supplément de travail d'administration est requis
	pour configurer les attributs étendus sous
	<acronym>UFS1</acronym> par rapport &agrave;
	<acronym>UFS2</acronym>.  Les performances des attributs
	étendus sous <acronym>UFS2</acronym> sont sensiblement
	meilleures également.  Il en résulte donc, que
	l'<acronym>UFS2</acronym> est généralement
	recommandé par rapport &agrave;
	l'<acronym>UFS1</acronym> pour une utilisation des listes
	de contrôle d'accès.</para>
      </note>

    <para>Les <acronym>ACL</acronym>s sont activés grâce
      l'option utilisée lors du montage, <option>acls</option>,
      qui peut être ajouté dans le fichier
      <filename>/etc/fstab</filename>.  Cette option de montage peut
      être également automatiquement fixée
      d'une manière définitive en utilisant  &man.tunefs.8;
      pour modifier l'indicateur <acronym>ACL</acronym> du
      &ldquo;superblock&rdquo; dans l'entête du système de
      fichiers.  Il est en général préférable
      d'utiliser cet indicateur pour plusieurs raisons:</para>

    <itemizedlist>
      <listitem>
	<para>L'option de montage pour les <acronym>ACL</acronym>s ne
	  peut être modifiée par un simple remontage
	  (&man.mount.8; <option>-u</option>), mais uniquement par un
	  &man.umount.8; complet et suivi d'un &man.mount.8;.  Cela
	  signifie que les <acronym>ACL</acronym>s ne peuvent
	  être activées sur le système de fichiers
	  racine après le démarrage. Cela signifie
	  également que vous ne pouvez pas modifier la
	  disposition d'un système de fichier une fois que
	  c'est activé.</para>
      </listitem>

      <listitem>
	<para>Positionner l'indicateur du &ldquo;superblock&rdquo;
	  fera que le système de fichiers sera toujours monté
	  avec les <acronym>ACL</acronym>s activées même
	  s'il n'y a pas d'entrée dans le fichier
	  <filename>fstab</filename>, ou s'il y a une réorganisation
	  des périphériques.  Cela prévient
	  le montage accidentel du système de fichiers sans les
	  <acronym>ACL</acronym>s activées, ce qui peut provoquer
	  une activation impropre des <acronym>ACL</acronym>s et
	  par conséquent des problèmes de
	  sécurité.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Nous pourrions modifier le comportement des
	<acronym>ACL</acronym>s pour permettre l'activation de
	l'indicateur sans le besoin d'un nouveau &man.mount.8;
	complet, mais nous considérons qu'il est préférable
	d'éviter un montage accidentel sans les
	<acronym>ACL</acronym>s activées, parce que vous pouvez
	vous &ldquo;tirer facilement dans les pieds&rdquo;
	si vous activez les <acronym>ACL</acronym>s, puis
	les désactivez, et ensuite les réactivez &agrave;
	nouveau sans réinitialiser les attributs étendus.
	En général, une fois que vous avez activé
	les <acronym>ACL</acronym>s sur un système de fichiers,
	elles ne devraient pas être désactivées
	étant donné que les protections de fichiers
	résultantes peuvent ne pas être compatible avec
	celles prévues par les utilisateurs du système,
	et réactiver les <acronym>ACL</acronym>s peut
	réaffecter les précédentes
	<acronym>ACL</acronym>s aux fichiers qui ont depuis eût
	leur permissions modifiées, avec pour résultat
	un comportement imprévisible.</para>
    </note>

    <para>Les systèmes de fichiers avec les
      <acronym>ACL</acronym>s activées présenteront un signe
      <literal>+</literal> au niveau de leurs permissions
      quand elles seront affichées.  Par exemple:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Ici nous voyons que les répertoires
      <filename>directory1</filename>,
      <filename>directory2</filename>, et
      <filename>directory3</filename> utilisent les
      <acronym>ACL</acronym>s.  Ce n'est pas le cas du
      répertoire <filename>public_html</filename>.</para>

    <sect2>
      <title>Utilisation des <acronym>ACL</acronym>s</title>

      <para>Les <acronym>ACL</acronym>s
	peuvent être affichées par l'utilitaire
	&man.getfacl.1;.  Par exemple pour voir les
	<acronym>ACL</acronym>s sur le fichier
	<filename>test</filename>, on utilisera la commande:</para>

      <screen>&prompt.user; <userinput>getfacl test</userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>Pour modifier le paramétrage des
	<acronym>ACL</acronym>s sur ce fichier, invoquez la commande
	&man.setfacl.1;.  Intéressons-nous &agrave; la
	ligne:</para>

      <screen>&prompt.user; <userinput>setfacl -k test</userinput></screen>

      <para>L'indicateur <option>-k</option> supprimera toutes les
	<acronym>ACL</acronym>s actuellement définies pour un
	fichier ou un système de fichiers.  Une méthode
	plus adaptée est d'utiliser l'option
	<option>-b</option> étant donné qu'elle conserve
	les champs de base nécessaires au bon
	fonctionnement des <acronym>ACL</acronym>s.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,group:web:r--,o::--- test</userinput></screen>

      <para>Dans la commande ci-dessus, l'option <option>-m</option> a
	été utilisée pour modifier les
	entrées <acronym>ACL</acronym> par défaut.
	Comme il n'y avait pas d'entrées
	pré-définies, puisqu'elles ont été
	supprimées par la commande précédente,
	cela restaurera les options par défaut et prendra en
	compte les options précisées.  Prenez soin de
	noter que si vous ajoutez un utilisateur ou un groupe qui
	n'existe pas sur le système, une erreur
	<errorname>Invalid argument</errorname> sera affichée
	sur la sortie standard.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-portaudit">
    <info><title>Surveillance des problèmes de sécurité
      relatifs aux programmes tierce-partie</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Portaudit</primary>
    </indexterm>

    <para>Ces dernières années, le monde de la
      sécurité a fait beaucoup de progrès dans la
      manière d'évaluer les
      vulnérabilités.  Le risque d'une intrusion dans le
      système augmente avec l'installation et la configuration
      d'utilitaires tierce-partie et cela pour quasiment n'importe
      quel système d'exploitation disponible
      aujourd'hui.</para>

    <para>L'évaluation des vulnérabilités est un
      facteur clé de la politique de sécurité,
      alors que &os; publie des avis pour le système de base,
      faire de même pour les programmes tierce-partie
      dépasse les capacités du projet &os;.  Il existe
      un moyen d'atténuer les vulnérabilités des
      logiciels tierce-partie et de prévenir les
      administrateurs des problèmes de sécurité
      connus.  Un outil &os; connu sous le nom de
      <application>Portaudit</application> existe dans cet unique
      but.</para>

    <para>Le logiciel porté <package role="port">ports-mgmt/portaudit</package> consulte une base de
      données, mise &agrave; jour et maintenue par
      l'équipe de sécurité de &os; et les
      développeurs des logiciels portés, &agrave; la
      recherche de problèmes de sécurité
      connus.</para>

    <para>Pour utiliser <application>Portaudit</application>, ce
      dernier doit être installé &agrave; partir du
      catalogue des logiciels portés:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>Lors du processus d'installation, les fichiers de
      configuration de &man.periodic.8; seront mis &agrave; jour,
      autorisant l'ajout des résultats de
      <application>Portaudit</application> dans l'exécution
      quotidienne du rapport de sécurité.  Assurez-vous
      que les rapports de sécurité quotidiens, qui sont
      envoyés au compte messagerie de
      <systemitem class="username">root</systemitem>, sont bien lus.  Pas plus de
      configuration ne sera nécessaire.</para>

    <para>Après l'installation, un administrateur peut mettre
      &agrave; jour la base de données et afficher les
      vulnérabilités connues des logiciels
      installés en invoquant la commande suivante:</para>

    <screen>&prompt.root; <userinput>portaudit -Fda</userinput></screen>

    <note>
      <para>La base de données sera automatiquement mise
	&agrave; jour lors de l'exécution de &man.periodic.8;,
	cela rendant par conséquent facultative la commande
	précédente.  Elle n'est requise que pour les
	exemples qui vont suivre.</para>
    </note>

    <para>Pour contrôler &agrave; n'importe quel moment les
      programmes tierce-partie installés &agrave; partir du
      catalogue des logiciels portés, un administrateur n'aura
      qu'&agrave; exécuter la commande suivante:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para><application>Portaudit</application> produira pour les
      logiciels vulnérables quelque chose comme ceci:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>En faisant pointer un navigateur Web sur
      l'<acronym>URL</acronym> proposée, un administrateur
      pourra obtenir plus d'information au sujet de la
      vulnérabilité en question.  Cela comprendra les
      versions affectées, listées par version du
      logiciel porté &os;, ainsi que des liens vers d'autres
      sites Web pouvant contenir des avis de
      sécurité.</para>

    <para>En résumé,
      <application>Portaudit</application> est un outil puissant et
      extrêmement utile quand il est employé
      conjointement avec le logiciel
      <application>Portupgrade</application>.</para>
  </sect1>

  <sect1 xml:id="security-advisories">
    <info><title>Avis de sécurité de &os;</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Avis de sécurité de FreeBSD</primary>
    </indexterm>

    <para>Comme plusieurs systèmes d'exploitation
      destinés &agrave; la production, &os; publie des
      &ldquo;Avis de sécurité&rdquo;.  Ces avis sont
      généralement envoyés aux listes de
      diffusion traitant de la sécurité et
      ajoutés dans l'errata une fois seulement que les versions
      correspondantes ont été corrigées.  Cette
      section aura pour objectif d'expliquer ce qu'est un avis,
      comment le comprendre, et quelles mesures sont &agrave; prendre
      pour appliquer des correctifs &agrave; un système.</para>

    <sect2>
      <title>A quoi ressemble un avis de
	sécurité?</title>

      <para>Les avis de sécurité de &os; ressemblent
	&agrave; celui présenté ci-dessous qui provient
	de la liste de diffusion
	&a.security-notifications.name;.</para>

      <programlisting>=============================================================================
&os;-SA-XX:XX.UTIL                                     Security Advisory
                                                          The &os; Project

Topic:          denial of service due to some problem<co xml:id="co-topic"/>

Category:       core<co xml:id="co-category"/>
Module:         sys<co xml:id="co-module"/>
Announced:      2003-09-23<co xml:id="co-announce"/>
Credits:        Person@EMAIL-ADDRESS<co xml:id="co-credit"/>
Affects:        All releases of &os;<co xml:id="co-affects"/>
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co xml:id="co-corrected"/>
&os; only:   NO<co xml:id="co-only"/>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.freebsd.org/security/.

I.   Background<co xml:id="co-backround"/>


II.  Problem Description<co xml:id="co-descript"/>


III. Impact<co xml:id="co-impact"/>


IV.  Workaround<co xml:id="co-workaround"/>


V.   Solution<co xml:id="co-solution"/>


VI.  Correction details<co xml:id="co-details"/>


VII. References<co xml:id="co-ref"/></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para>Le champ <literal>Topic</literal> indique exactement
	    quel est le problème.  C'est basiquement une
	    introduction &agrave; l'avis de sécurité en
	    tant que tel et mentionne l'utilitaire contenant la
	    vulnérabilité.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>Le champ <literal>Category</literal> fait
	    référence &agrave; la partie du système
	    affectée qui peut être une parmi
	    <literal>core</literal>, <literal>contrib</literal>, ou
	    <literal>ports</literal>.  La catégorie
	    <literal>core</literal> signifie que la
	    vulnérabilité affecte un composant
	    système du système d'exploitation &os;.  La
	    catégorie <literal>contrib</literal> précise
	    que la vulnérabilité affecte du logiciel
	    contribué au projet &os;, comme
	    <application>sendmail</application>.  Et enfin la
	    catégorie <literal>ports</literal> indique que la
	    vulnérabilité affecte un logiciel du catalogue
	    des logiciels portés.</para>
	</callout>

	<callout arearefs="co-module">
	  <para>Le champ <literal>Module</literal> fait
	    référence &agrave; l'emplacement du composant,
	    par exemple <literal>sys</literal>.  Dans notre exemple,
	    nous voyons que le module <literal>sys</literal> est
	    affecté, par conséquent, cette
	    vulnérabilité concerne un composant
	    utilisé dans le noyau.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para>Le champ <literal>Announced</literal> reflète
	    la date &agrave; laquelle l'avis de sécurité a
	    été publié, ou annoncé au monde
	    entier.  Cela signifie que l'équipe de
	    sécurité a vérifié que le
	    problème existait vraiment et qu'un correctif a
	    été ajouté au référentiel
	    des sources de &os;.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para>Le champ <literal>Credits</literal> donne le
	    crédit de la découverte du problème
	    &agrave; la personne ou l'organisation qui a constaté
	    et rapporté le problème.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para>Le champ <literal>Affects</literal> explique quelles
	    versions de &os; sont affectées par cette
	    vulnérabilité.  Pour le noyau, un coup d'oeil
	    rapide &agrave; la sortie de la commande
	    <command>ident</command> sur les fichiers affectés
	    aidera &agrave; déterminer la révision.  Pour
	    les logiciels portés, le numéro de version est
	    listé après le nom du logiciel dans <filename>/var/db/pkg</filename>.  Si le
	    système ne se synchronise pas avec le
	    référentiel <acronym>CVS</acronym> &os; et ne
	    recompile pas les sources quotidiennement, il y a des
	    chances qu'il soit affecté par le
	    problème.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para>Le champ <literal>Corrected</literal> indique la date,
	    l'heure, le fuseau horaire, et la version de publication qui
	    a été corrigée.</para>
	</callout>

	<callout arearefs="co-only">
	  <para>Le champ <literal>&os; only</literal> précise
	    si cette vulnérabilité affecte juste &os;, ou
	    si elle concerne d'autres systèmes d'exploitation
	    également.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para>Le champ <literal>Background</literal> donne une
	    information précise sur ce qu'est l'utilitaire
	    affecté.  La plupart du temps, ce champ indique
	    pourquoi l'utilitaire existe sous &os;, son rôle, et
	    quelques informations sur la naissance de
	    l'utilitaire.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para>Le champ <literal>Problem Description</literal>
	    explique en profondeur le problème de
	    sécurité.  Cela peut comprendre des
	    informations sur le code défectueux, ou même
	    comment l'utilitaire pourrait être utilisé pour
	    ouvrir un faille de sécurité.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para>Le champ <literal>Impact</literal> décrit
	    l'impact sur le système du problème de
	    sécurité.  Par exemple, cela peut aller de
	    l'attaque par refus de service, au gain de droits
	    supplémentaires par les utilisateurs, en passant par
	    l'obtention des droits de super-utilisateur par
	    l'attaquant.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para>Le champ <literal>Workaround</literal> offre une
	    solution de contournement possible pour les administrateurs
	    qui ne sont pas en mesure de mettre &agrave; jour le
	    système.  Cela pouvant être due &agrave; des
	    contraintes de temps, &agrave; une disponibilité
	    réseau, ou une tout autre raison.  Cependant, la
	    sécurité ne devrait pas être prise
	    &agrave; la légère, et un système
	    affecté devrait soit être corrigé soit
	    implémenter une solution de contournement du
	    problème de sécurité.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para>Le champ <literal>Solution</literal> donne les
	    instructions sur l'application de correctifs sur le
	    système affecté.  C'est une méthode pas
	    &agrave; pas vérifiée et testée pour
	    obtenir un système corrigé et fonctionnant de
	    manière sécurisée.</para>
	</callout>

	<callout arearefs="co-details">
	  <para>Le champ <literal>Correction Details</literal> liste
	    la branche <acronym>CVS</acronym> ou la version de
	    publication avec les points remplacés par des
	    caractères souligné.  Il donne
	    également le numéro de révision des
	    fichiers affectés sur chaque branche.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para>Le champ <literal>References</literal> donne en
	    général d'autres sources d'informations.  Cela
	    peut être des <acronym>URL</acronym>s web, des
	    ouvrages, des listes de diffusions, et des forums de
	    discussion.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 xml:id="security-accounting">
    <info><title>Comptabilité des processus</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Comptabilité des processus</primary>
    </indexterm>

    <para>La comptabilité des processus est une mesure de
      sécurité avec laquelle un administrateur peut
      suivre l'utilisation des ressources du système, leur
      répartition entre les utilisateurs, surveiller le
      système et avoir un suivi minimal des commandes
      exécutées par un utilisateur.</para>

    <para>Ce système possède des avantages et des
      inconvénients.  Un de ses avantages est qu'une intrusion
      pourra être remontée jusqu'&agrave; son point
      d'entrée.  Un des inconvénients est la
      quantité de journaux générée par
      cette comptabilité et l'espace disque que cela peut
      demander.  Cette section guidera l'administrateur au travers des
      bases de la comptabilité des processus.</para>

    <sect2>
      <title>Activer et utiliser la comptabilité des
	processus</title>

      <para>Avant de pouvoir utiliser la comptabilité des
	processus, il faut l'activer.  Cela se fait en
	exécutant les commandes suivantes:</para>

      <screen>&prompt.root; <userinput>touch /var/account/acct</userinput>

&prompt.root; <userinput>accton /var/account/acct</userinput>

&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; /etc/rc.conf</userinput></screen>

      <para>Une fois activée, les statistiques concernant le
	<acronym>CPU</acronym>, les commandes, etc. commenceront
	&agrave; être comptabilisée.  Tous les journaux
	de comptabilisation des processus sont dans un format
	directement illisible pour l'utilisateur, ils pourront
	être examinés &agrave; l'aide de l'utilitaire
	&man.sa.8;.  Si elle est utilisée sans
	paramètre, la commande <command>sa</command> affichera
	les informations relatives au nombre d'appels par utilisateur,
	le temps écoulé en minutes, la durée
	totale des temps <acronym>CPU</acronym> et utilisateur en
	minutes, le nombre moyen des opérations d'E/S,
	etc.</para>

      <para>Pour afficher les informations sur les commandes
	utilisées, on emploiera l'utilitaire &man.lastcomm.1;.
	La commande <command>lastcomm</command> peut être
	employée pour afficher les commandes tapées par
	les utilisateurs sur des terminaux (&man.ttys.5;)
	spécifiques; par exemple:</para>

      <screen>&prompt.root; <userinput>lastcomm ls
	trhodes ttyp1</userinput></screen>

      <para>imprimera toute utilisation de la commande
	<command>ls</command> par l'utilisateur
	<systemitem class="username">trhodes</systemitem> sur le terminal
	<literal>ttyp1</literal>.</para>

      <para>De nombreuses autres options utiles existent et sont
	détaillées dans les pages de manuel
	&man.lastcomm.1;, &man.acct.5; et &man.sa.8;.</para>
    </sect2>
  </sect1>
</chapter>
