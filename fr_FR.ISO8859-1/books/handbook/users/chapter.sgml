<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.42
-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Neil</firstname>
	<surname>Blakey-Milner</surname>
	<contrib>Contribution de </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
  </chapterinfo>

  <title>Gestion des comptes et des utilisateurs</title>
  &trans.a.fonvieille;

  <sect1 id="users-synopsis">
    <title>Synopsis</title>

    <para>FreeBSD permet &agrave; de nombreux utilisateurs d'utiliser
      l'ordinateur en m&ecirc;me temps.  Evidemment, seul un de ces
      utilisateurs peut &ecirc;tre assis devant l'&eacute;cran et le clavier
      &agrave; un instant donn&eacute;
      <footnote>
	<para>Bon, &agrave; moins que vous ne connectiez de multiples
	terminaux, mais nous laisserons cela pour le
	<xref linkend="serialcomms">.</para>
      </footnote>, mais n'importe quel nombre d'utilisateurs peut ouvrir
      une session par l'interm&eacute;diaire du r&eacute;seau pour mener
      &agrave; bien son
      travail.  Pour utiliser le syst&egrave;me chaque utilisateur doit
      poss&eacute;der un compte.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous conna&icirc;trez:</para>

    <itemizedlist>
      <listitem>
	<para>Les diff&eacute;rences entre les divers comptes utilisateur sur
	  un syst&egrave;me FreeBSD.</para>
      </listitem>

      <listitem>
	<para>Comment ajouter des comptes utilisateur.</para>
      </listitem>

      <listitem>
	<para>Comment supprimer des comptes utilisateur.</para>
      </listitem>

      <listitem>
	<para>Comment modifier les param&egrave;tres d'un compte, comme le nom
	complet de l'utilisateur, ou l'interpr&eacute;teur de commandes
	pr&eacute;f&eacute;r&eacute;.</para>
      </listitem>

      <listitem>
	<para>Comment fixer des limites par compte, pour contr&ocirc;ler les
	  ressources comme la m&eacute;moire et le temps CPU auxquels les
	  comptes et les groupes de comptes sont autoris&eacute;s &agrave;
	  acc&eacute;der.</para>
      </listitem>

      <listitem>
	<para>Comment utiliser les groupes pour rendre la gestion de
	  comptes plus ais&eacute;e.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Comprendre les fondements d'&unix; et de FreeBSD (<xref
	  linkend="basics">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>Introduction</title>

    <para>Tout acc&egrave;s au syst&egrave;me est effectu&eacute;
      par l'interm&eacute;diaire de comptes, et tous les processus sont
      ex&eacute;cut&eacute;s par des utilisateurs, la gestion des comptes et des
      utilisateurs est capitale sur les syst&egrave;mes FreeBSD.</para>

    <para>Chaque compte sur un syst&egrave;me FreeBSD est associ&eacute;
      avec un certain nombre d'informations utilis&eacute; pour
      identifier le compte.</para>

    <variablelist>
      <varlistentry>
	<term>&ldquo;User name&rdquo; - nom d'utilisateur</term>

	<listitem>
	  <para>Le nom d'utilisateur comme il sera tap&eacute; &agrave;
	    l'invite <prompt>login:</prompt>.  Les noms d'utilisateur
	    doivent &ecirc;tre uniques sur le syst&egrave;me; vous ne pouvez
	    pas avoir deux utilisateurs avec le m&ecirc;me nom
	    d'utilisateur.  Il y a un certain nombre de r&egrave;gles
	    pour la cr&eacute;ation de noms d'utilisateur valides,
	    document&eacute;es dans &man.passwd.5;; vous utiliserez
	    g&eacute;n&eacute;ralement des noms d'utilisateurs de huit lettres
	    ou moins et en minuscules.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Password&rdquo; - mot de passe</term>

	<listitem>
	  <para>Chaque compte est associ&eacute; &agrave; un mot de passe.
	    Le mot de passe peut &ecirc;tre vide, dans ce cas aucun mot de
	    passe ne sera requis pour acc&eacute;der au syst&egrave;me.
	    Ceci est une tr&egrave;s mauvaise id&eacute;e; chaque compte
	    devrait avoir un mot de passe.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;User ID (UID)&rdquo; - identifiant utilisateur</term>

	<listitem>
	  <para>L'UID est un nombre compris entre 0 et 65535<footnote id="users-largeuidgid">
	    <para>Il est possible d'utiliser pour les UID/GIDs tout
	      nombre inf&eacute;rieur &agrave; 4294967295, mais de
	      telles valeurs peuvent &ecirc;tre &agrave; l'origine de
	      s&eacute;rieux probl&egrave;mes avec des logiciels qui
	      font des suppositions sur la valeur des
	      identifiants.</para>
	    </footnote>, utilis&eacute;
	    pour identifier de fa&ccedil;on unique un utilisateur sur le
	    syst&egrave;me.  Au niveau interne, FreeBSD utilise l'UID pour
	    identifier les utilisateurs&mdash;toute commande qui vous
	    permet de sp&eacute;cifier un utilisateur convertira le nom
	    d'utilisateur en son UID avant de le traiter.  Cela signifie
	    que vous pouvez avoir plusieurs comptes avec des noms
	    d'utilisateurs diff&eacute;rents mais le m&ecirc;me UID.
	    En ce qui concerne FreeBSD ces comptes ne sont qu'un seul et
	    unique utilisateur.  Il est peu probable que vous ayez
	    jamais &agrave; faire cela.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Group ID (GID)&rdquo; - identifiant de groupe</term>

	<listitem>
	  <para>Le GID est un nombre compris entre 0 et 65535<footnoteref linkend="users-largeuidgid">, utilis&eacute;
	    pour identifier de fa&ccedil;on unique le groupe principal auquel
	    appartient l'utilisateur.  Les groupes sont un m&eacute;canisme
	    pour contr&ocirc;ler l'acc&egrave;s aux ressources qui est
	    bas&eacute; sur le GID de l'utilisateur plut&ocirc;t que
	    sur son UID.  Un utilisateur peut &eacute;galement
	    appartenir &agrave; plus d'un groupe.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Login class&rdquo; - classe de session</term>

	<listitem>
	  <para>Les classes de session sont une extension du
	    m&eacute;canisme de groupe qui apporte une flexibilit&eacute;
	    suppl&eacute;mentaire quand on adapte le syst&egrave;me aux
	    diff&eacute;rents utilisateurs.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Password change time&rdquo; - dur&eacute;e de vie d'un
	  mot de passe</term>

	<listitem>
	  <para>Par d&eacute;faut FreeBSD n'oblige pas les utilisateurs
	    &agrave; changer leur mot de passe r&eacute;guli&egrave;rement.
	    Vous pouvez forcer cela en fonction de l'utilisateur, en
	    obligeant certains ou tous les utilisateurs &agrave; changer
	    leur mot de passe apr&egrave;s qu'une certaine p&eacute;riode
	    de temps se soit &eacute;coul&eacute;e.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Account expiry time&rdquo; - date d'expiration
	  d'un compte</term>

	<listitem>
	  <para>Par d&eacute;faut FreeBSD ne d&eacute;sactive pas de
	    comptes apr&egrave;s une certaine p&eacute;riode.  Si vous
	    cr&eacute;ez des comptes qui auront une dur&eacute;e de vie
	    limit&eacute;e, par exemple, dans une &eacute;cole o&ugrave;
	    il existe des comptes pour les &eacute;tudiants, alors vous
	    pouvez sp&eacute;cifier la date d'expiration des comptes.
	    Apr&egrave;s la dur&eacute;e d'expiration &eacute;coul&eacute;e
	    le compte ne pourra plus &ecirc;tre utilis&eacute;
	    pour ouvrir de session sur le syst&egrave;me, bien que les
	    r&eacute;pertoires et les fichiers attach&eacute;s au compte
	    seront conserv&eacute;s.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;User's full name&rdquo; - nom complet d'utilisateur</term>

	<listitem>
	  <para>Le nom d'utilisateur identifie uniquement le compte sur
	    FreeBSD, mais ne refl&egrave;te pas n&eacute;cessairement le
	    nom r&eacute;el de l'utilisateur.  Cette information peut &ecirc;tre
	    associ&eacute;e avec le compte.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;Home directory&rdquo; - r&eacute;pertoire
	  utilisateur</term>

	<listitem>
	  <para>Le r&eacute;pertoire utilisateur est le chemin complet
	    vers un r&eacute;pertoire sur le syst&egrave;me dans lequel se
	    retrouve l'utilisateur quand il ouvre une session sur le
	    syst&egrave;me.  Une convention commune est de mettre tous les
	    r&eacute;pertoires d'utilisateurs sous
	    <filename>/home/<replaceable>username</replaceable></filename>
	    ou <filename>/usr/home/<replaceable>username</replaceable></filename>.
	    L'utilisateur pourra stocker ses fichiers personnel dans son
	    r&eacute;pertoire utilisateur et dans tout sous-r&eacute;pertoire
	    qu'il pourra y cr&eacute;er.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>&ldquo;User shell&rdquo; - interpr&eacute;teur de commandes
	  de l'utilisateur</term>

	<listitem>
	  <para>L'interpr&eacute;teur de commandes fournit aux utilisateurs
	    l'environnement par d&eacute;faut pour communiquer avec le
	    syst&egrave;me.  Il existe plusieurs diff&eacute;rents types
	    d'interpr&eacute;teurs de commandes, et les utilisateurs
	    exp&eacute;riment&eacute;s auront leur pr&eacute;f&eacute;rence,
	    qui peut se refl&eacute;ter dans le param&eacute;trage
	    de leur compte.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Il y a trois principales sortes de comptes: le <link
	linkend="users-superuser">super-utilisateur</link>, les <link
	linkend="users-system">utilisateurs syst&egrave;me</link>,
	et les <link linkend="users-user">comptes utilisateur</link>.
	Le compte super-utilisateur, normalement appel&eacute;
	<username>root</username>, est utilis&eacute; pour g&eacute;rer le
	syst&egrave;me
	sans aucune limitation de privil&egrave;ges.  Les utilisateurs
	syst&egrave;me ex&eacute;cutent des services.  Et enfin,
	les comptes utilisateur sont utilis&eacute;s par de v&eacute;ritables
	utilisateurs, qui ouvrent des sessions, lisent leur courrier
	&eacute;lectronique, et ainsi de suite.</para>
  </sect1>

  <sect1 id="users-superuser">
    <title>Le compte super-utilisateur</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>super-utilisateur (root)</secondary>
    </indexterm>
    <para>Le compte super-utilisateur, habituellement appel&eacute;
      <username>root</username>, est pr&eacute;configur&eacute; pour
      simplifier l'administration syst&egrave;me, et ne devrait pas
      &ecirc;tre utilis&eacute; pour des t&acirc;ches quotidiennes comme
      l'envoi et la r&eacute;ception de courrier &eacute;lectronique,
      l'exploration
      du syst&egrave;me, ou la programmation.</para>

    <para>Cela parce que le super-utilisateur, &agrave; la
      diff&eacute;rence des comptes utilisateurs ordinaires, peut agir sans
      aucune limite, et une mauvaise utilisation du compte
      super-utilisateur peut &ecirc;tre &agrave; l'origine de r&eacute;sultats
      catastrophiques.  On ne peut pas endommager par erreur le syst&egrave;me
      avec un compte utilisateur, il est donc g&eacute;n&eacute;ralement
      pr&eacute;f&eacute;rable d'utiliser des comptes utilisateur ordinaires
      chaque fois que c'est possible, &agrave; moins d'avoir
      particuli&egrave;rement besoin
      de droits suppl&eacute;mentaires.</para>

    <para>Vous devriez toujours v&eacute;rifier et rev&eacute;rifier
      les commandes que vous tapez en tant que super-utilisateur, parce
      qu'un espace en trop ou un caract&egrave;re manquant peuvent signifier la
      perte d&eacute;finitive de donn&eacute;es.</para>

    <para>Donc, la premi&egrave;re chose que vous devriez faire,
      apr&egrave;s la lecture de ce chapitre, est de vous cr&eacute;er
      un compte utilisateur sans privil&egrave;ges si vous n'en avez pas
      d&eacute;j&agrave;.  Cela s'applique aussi bien &agrave; une machine
      multi-utilisateurs qu'&agrave; une machine mono-utilisateur.  Plus loin
      dans ce chapitre, nous expliquerons comment cr&eacute;er de nouveaux
      comptes, et comment passer d'un compte utilisateur ordinaire au
      compte du super-utilisateur.</para>
  </sect1>

  <sect1 id="users-system">
    <title>Comptes syst&egrave;me</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>syst&egrave;me</secondary>
    </indexterm>
    <para>Les utilisateurs syst&egrave;me sont ceux utilis&eacute;s pour
      ex&eacute;cuter des services comme le DNS, le courrier
      &eacute;lectronique,
      les serveurs web, et ainsi de suite.  La raison de cela est la
      s&eacute;curit&eacute;; si tous les services s'ex&eacute;cutaient
      avec les droits du super-utilisateur, ils pourraient agir sans
      aucune restriction.</para>

    <indexterm>
      <primary>comptes</primary>
      <secondary><username>daemon</username></secondary>
    </indexterm>
    <indexterm>
      <primary>comptes</primary>
      <secondary><username>operator</username></secondary>
    </indexterm>
    <para>Des exemples d'utilisateurs syst&egrave;me sont
      <username>daemon</username>, <username>operator</username>,
      <username>bind</username> (pour le serveur de noms de domaine), et
      <username>news</username>.  Souvent les administrateurs syst&egrave;me
      cr&eacute;ent l'utilisateur <username>httpd</username> pour
      ex&eacute;cuter les serveurs web qu'ils installent.</para>

    <indexterm>
      <primary>comptes</primary>
      <secondary><username>nobody</username></secondary>
    </indexterm>
    <para><username>nobody</username> est l'utilisateur sans
      privil&egrave;ges g&eacute;n&eacute;rique du syst&egrave;me.
      Cependant, il est important de garder &agrave; l'esprit que plus grand
      est le nombre de services utilisant <username>nobody</username>,
      plus grand sera le nombre de fichiers et de processus associ&eacute;s
      &agrave; cet utilisateur, et par cons&eacute;quent plus grand sera le
      nombre de privil&egrave;ges de cet utilisateur.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Comptes utilisateur</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>utilisateur</secondary>
    </indexterm>
    <para>Les comptes utilisateur sont le principal moyen pour les
      v&eacute;ritables utilisateurs d'acc&eacute;der au
      syst&egrave;me, ces comptes isolent l'utilisateur du reste de
      l'environnement, emp&ecirc;chant les utilisateurs d'endommager
      le syst&egrave;me et ou les comptes d'autres utilisateurs, tout en
      leur permettant de personnaliser leur environnement sans incidence
      pour les autres utilisateurs.</para>

    <para>Chaque personne acc&eacute;dant &agrave; votre syst&egrave;me
      ne devrait poss&eacute;der que son propre et unique compte.  Cela
      vous permet de savoir qui fait quoi, emp&ecirc;che un utilisateur de
      d&eacute;sorganiser l'environnement d'un autre ou de lire du courrier
      &eacute;lectronique qui ne lui est pas destin&eacute;, et ainsi de
      suite.</para>

    <para>Chaque utilisateur peut configurer son propre environnement en
      fonction de ses besoins, pour utiliser d'autres interpr&eacute;teurs
      de commandes, &eacute;diteurs, raccourcis de clavier,
      et langues.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Modifier des comptes</title>

    <indexterm>
      <primary>comptes</primary>
      <secondary>modification</secondary>
    </indexterm>

    <para>Il existe une vari&eacute;t&eacute; de diff&eacute;rentes
      commandes disponibles dans l'environnement &unix; pour manipuler les
      comptes utilisateur.  Les commandes les plus communes sont
      r&eacute;capitul&eacute;es ci-dessous, suivis par des exemples
      d&eacute;taill&eacute;s de leur utilisation.</para>

    <informaltable>
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Commande</entry>
	    <entry>R&eacute;sum&eacute;</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>
	    <entry>L'application en ligne de commande recommand&eacute;e
	      pour ajouter de nouveaux utilisateurs.</entry>
	  </row>
	  <row>
	    <entry>&man.rmuser.8;</entry>
	    <entry>L'application en ligne de commande recommand&eacute;e
	      pour supprimer des utilisateurs.</entry>
	  </row>
	  <row>
	    <entry>&man.chpass.1;</entry>
	    <entry>Un outil flexible pour modifier les informations de
	      la base de donn&eacute;es utilisateur.</entry>
	  </row>
	  <row>
	    <entry>&man.passwd.1;</entry>
	    <entry>L'outil simple en ligne de commande pour changer les
	      mots de passe utilisateur.</entry>
	  </row>
	  <row>
	    <entry>&man.pw.8;</entry>
	    <entry>Un puissant et flexible outil pour modifier tous les
	      aspects des comptes utilisateurs.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
        <primary>compte</primary>
        <secondary>cr&eacute;ation</secondary>
      </indexterm>
      <indexterm>
        <primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
        <primary><filename class=directory>/usr/share/skel</filename></primary>
      </indexterm>
      <indexterm><primary>r&eacute;pertoire de squelettes</primary></indexterm>
      <para>&man.adduser.8; est un programme simple pour
	ajouter de nouveaux utilisateurs.  Il cr&eacute;e les entr&eacute;es
	dans les fichiers syst&egrave;me <filename>passwd</filename> et
	<filename>group</filename>.  Il cr&eacute;e &eacute;galement le
	r&eacute;pertoire utilisateur pour le nouvel utilisateur, y copie les
	fichiers de configuration par d&eacute;faut (&ldquo;dotfiles&rdquo;)
	&agrave; partir de <filename>/usr/share/skel</filename>, et peut
	&eacute;ventuellement envoyer &agrave; l'utilisateur un courrier
	&eacute;lectronique de bienvenue.</para>

      <para>Dans &os;&nbsp;5.0, &man.adduser.8; a &eacute;t&eacute;
	converti d'une proc&eacute;dure d'origine en Perl en une
	proc&eacute;dure d'interpr&eacute;teur de commandes sous la
	forme d'un programme ex&eacute;cutant &man.pw.8;, aussi
	l'utilisation de &man.adduser.8; est l&eacute;g&egrave;rement
	diff&eacute;rente entre &os;&nbsp;4.X et &os;&nbsp;5.X.</para>

      <para>Pour cr&eacute;er le fichier de configuration initial, utilisez
	<command>adduser -s -config_create</command>.
	<footnote>
	  <para>L'option <option>-s</option> rend &man.adduser.8;
	    silencieux par d&eacute;faut.  Nous utiliserons
	    <option>-v</option> plus tard quand nous voudrons modifier
	    les valeurs par d&eacute;faut.</para>
	</footnote>
	Ensuite, nous configurons les valeurs par d&eacute;faut pour
	&man.adduser.8;, et cr&eacute;ons notre premier
	compte utilisateur, puisque l'utilisation du compte
	<username>root</username> pour un usage ordinaire est une
	mauvaise id&eacute;e.</para>

      <example>
	<title>Configurer <command>adduser</command> et ajouter un
	  utilisateur sous &os;&nbsp;4.X</title>

	<screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh zsh [sh]: <userinput>zsh</userinput>
Your default shell is: zsh -&gt; /usr/local/bin/zsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]:
Send message from file: /etc/adduser.message no
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh zsh [zsh]:
Enter home directory (full path) [/home/jru]:
Uid [1001]:
Enter login class: default []:
Login group jru [jru]:
Login group is ``jru''. Invite jru into other groups: guest no
[no]: <userinput>wheel</userinput>
Enter password []:
Enter password again []:

Name:	  jru
Password: ****
Fullname: J. Random User
Uid:	  1001
Gid:	  1001 (jru)
Class:
Groups:	  jru wheel
HOME:     /home/jru
Shell:	  /usr/local/bin/zsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>En r&eacute;sum&eacute;, nous avons modifi&eacute;
	l'interpr&eacute;teur de commandes par d&eacute;faut pour
	<application>zsh</application> (un autre interpr&eacute;teur de
	commandes trouv&eacute; dans le catalogue des logiciels
	port&eacute;s), et d&eacute;sactiv&eacute; l'envoi d'un
	courrier &eacute;lectronique de bienvenue &agrave; la
	cr&eacute;ation d'un compte.  Nous avons ensuite enregistr&eacute;
	cette configuration, cr&eacute;&eacute; le compte
	<username>jru</username>,
	et fait en sorte que <username>jru</username> appartienne au
	groupe <username>wheel</username> (de sorte qu'il puisse assurer
	le r&ocirc;le de <username>root</username> avec la commande
	&man.su.1;).</para>

      <note>
	<para>Le mot de passe que vous tapez n'appara&icirc;t pas &agrave;
	  l'&eacute;cran, et il n'y a pas non plus d'ast&eacute;risques
	  affich&eacute;s.  Veillez &agrave; ne pas vous tromper deux fois de
	  suite.</para>
      </note>

      <note>
	<para>Vous pouvez d&eacute;sormais utiliser
	  &man.adduser.8; sans arguments, et vous n'aurez pas
	  besoin de modifier les valeurs par d&eacute;faut.  Si le
	  programme vous demandait de le faire, quittez-le et essayez
	  l'option <option>-s</option>.</para>
      </note>

      <example>
	<title>Ajouter un utilisateur sous &os;&nbsp;5.X</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
        <primary>comptes</primary>
        <secondary>suppression</secondary>
      </indexterm>

      <para>Vous pouvez utiliser &man.rmuser.8; pour
	supprimer compl&egrave;tement un utilisateur du syst&egrave;me.
	&man.rmuser.8; effectue les op&eacute;rations
	suivantes:</para>

      <procedure>
	<step>
	  <para>Supprime les entr&eacute;es appartenant &agrave; l'utilisateur
	  de la &man.crontab.1; (s'il y en a).</para>
	</step>
	<step>
	  <para>Supprime les t&acirc;ches &man.at.1; appartenant &agrave;
	    l'utilisateur.</para>
	</step>
	<step>
	  <para>Tue tous les processus appartenant &agrave;
	    l'utilisateur.</para>
	</step>
	<step>
	  <para>Supprime l'utilisateur du fichier de mots de passe
	    local.</para>
	</step>
	<step>
	  <para>Supprime le r&eacute;pertoire l'utilisateur (s'il lui
	    appartient).</para>
	</step>
	<step>
	  <para>Supprime les courriers &eacute;lectroniques en attente pour
	  l'utilisateur dans <filename>/var/mail</filename>.</para>
	</step>
	<step>
	  <para>Supprime tous les fichiers temporaires appartenant &agrave;
	    l'utilisateur des zones de stockages temporaires comme
	    <filename>/tmp</filename>.</para>
	</step>
	<step>
	  <para>Et enfin, supprime l'utilisateur de tous les groupes
	    auxquels il appartient dans <filename>/etc/group</filename>.

	    <note>
	      <para>Si un groupe est vide de ce fait et que le nom du
		groupe est le m&ecirc;me que celui de l'utilisateur,
		le groupe est supprim&eacute;; c'est la r&eacute;ciproque de la
		cr&eacute;ation par &man.adduser.8; d'un groupe propre
		pour chaque utilisateur.</para>
	    </note>
	  </para>
	</step>
      </procedure>

      <para>&man.rmuser.8; ne peut pas &ecirc;tre
	employ&eacute; pour supprimer des comptes super-utilisateur,
	car cela entra&icirc;nerait presque toujours des destructions
	massives.</para>

      <para>Par d&eacute;faut, la commande travaille en mode interactif, pour
	garantir que vous soyez s&ucirc;r de ce que vous
	faites.</para>

      <example>
	<title>Suppression interactive de compte avec <command>rmuser</command></title>

	<screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para>&man.chpass.1; modifie les informations de la
	base de donn&eacute;es des utilisateurs comme les mots de passe,
	les interpr&eacute;teurs de commandes, et les informations
	personnelles.</para>

      <para>Seuls les administrateurs syst&egrave;me, comme le
	super-utilisateur, peuvent modifier les informations concernant
	les autres utilisateurs et les mots de passe &agrave; l'aide de
	&man.chpass.1;.</para>

      <para>Utilis&eacute; sans options, en dehors du nom facultatif de
	l'utilisateur, &man.chpass.1; ouvre un &eacute;diteur
	affichant les informations de l'utilisateur.  Quand
	l'utilisateur quitte l'&eacute;diteur, la base de donn&eacute;es
	utilisateur est mise &agrave; jour avec les nouvelles
	informations.</para>

      <note>
	<para>Sous os;&nbsp;5.X, on vous demandera votre mot de passe
	  en quittant l'&eacute;diteur si vous n'&ecirc;tes pas le
	  super-utilisateur.</para>
      </note>

      <example>
	<title><command>chpass</command> interactif par le super-utilisateur</title>

	<screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Un utilisateur ordinaire ne peut modifier qu'une partie de
	ces informations, et seulement celles qui le concernent.</para>

      <example>
	<title><command>chpass</command> interactif par un utilisateur ordinaire</title>

	<screen>#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
	<para>&man.chfn.1; et &man.chsh.1; sont
	  juste des liens vers &man.chpass.1;, comme le sont
	  &man.ypchpass.1;, &man.ypchfn.1;, et
	  &man.ypchsh.1;.  NIS est support&eacute;
	  automatiquement, aussi sp&eacute;cifier <literal>yp</literal>
	  avant la commande n'est pas n&eacute;cessaire.  Si cela vous
	  semble confus, ne vous inqui&eacute;tez pas, NIS sera
	  abord&eacute; dans le chapitre <xref
	  linkend="advanced-networking">.</para>
      </note>
    </sect2>
    <sect2 id="users-passwd">
      <title><command>passwd</command></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
        <primary>comptes</primary>
        <secondary>modifier le mot de passe</secondary>
      </indexterm>
      <para>&man.passwd.1; est la m&eacute;thode habituelle
	pour modifier son mot de passe, ou celui d'un autre utilisateur
	si vous &ecirc;tes le super-utilisateur.</para>

      <note>
	<para>Avant de pouvoir changer leur mot de passe, les utilisateurs doivent taper le mot de passe en cours
	  pour &eacute;viter qu'une personne non
	  autoris&eacute;e ne puisse le faire quand l'utilisateur n'est pas
	  devant la console.</para>
      </note>

      <example>
	<title>Modifier votre mot de passe</title>

	<screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>Modifier le mot de passe d'un autre utilisateur en tant
	  que super-utilisateur</title>

        <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
	<para>Comme pour &man.chpass.1;,
	  &man.yppasswd.1; est juste un lien vers
	  &man.passwd.1;, donc NIS fonctionnera avec l'une
	  des deux commandes.</para>
      </note>
    </sect2>


    <sect2 id="users-pw">
      <title><command>pw</command></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; est un utilitaire en ligne de commande pour
	cr&eacute;er, supprimer, modifier, et lister utilisateurs et groupes.
	Il fonctionne comme une interface aux fichiers d'utilisateurs et
	de groupe.  &man.pw.8; poss&egrave;de un ensemble puissant
	d'options qui le rende adapt&eacute; &agrave; une utilisation
	dans des proc&eacute;dures, mais les nouveaux utilisateurs
	pourront le trouver plus compliqu&eacute; que les autres
	commandes pr&eacute;sent&eacute;es ici.</para>
    </sect2>


  </sect1>

  <sect1 id="users-limiting">
    <title>Mettre en place des restrictions pour les utilisateurs</title>

    <indexterm><primary>restrictions pour les utilisateurs</primary></indexterm>
    <indexterm>
      <primary>comptes</primary>
      <secondary>restriction</secondary>
    </indexterm>
    <para>Si vous avez plusieurs utilisateurs sur votre syst&egrave;me,
      la possibilit&eacute; de limiter leur utilisation du syst&egrave;me
      peut venir &agrave; l'esprit.
      FreeBSD fournit plusieurs m&eacute;thodes &agrave;
      l'administrateur syst&egrave;me pour limiter la quantit&eacute; de
      ressources syst&egrave;me qu'un utilisateur peut utiliser.
      Ces limites sont g&eacute;n&eacute;ralement divis&eacute;es
      en deux parties: les quotas disque, et les autres limites de
      ressource.</para>

    <indexterm><primary>quotas</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>quotas</secondary>
    </indexterm>
    <indexterm><primary>quotas disque</primary></indexterm>
    <para>Les quotas limitent l'utilisation des disques par les
      utilisateurs, et
      ils fournissent un moyen de
      v&eacute;rifier rapidement cette utilisation
      sans avoir &agrave; faire des calculs &agrave; chaque fois.
      Les quotas sont abord&eacute;s dans la <xref
      linkend="quotas">.</para>

    <para>Les autres limites de ressource comprennent les moyens de
      limiter l'utilisation du CPU, de la m&eacute;moire, et les autres
      ressources qu'un utilisateur peut consommer.  Elles sont
      d&eacute;finies en employant des classes de session et sont
      abord&eacute;es ici.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Les classes de session sont d&eacute;finies dans
      <filename>/etc/login.conf</filename>.  La s&eacute;mantique
      pr&eacute;cise sort du cadre de cette section, mais est
      d&eacute;crite en d&eacute;tail dans la page de manuel
      &man.login.conf.5;.  Il est suffisant de dire que chaque
      utilisateur est assign&eacute; &agrave; une classe
      (<literal>default</literal> par d&eacute;faut), et que chaque classe
      dispose d'un ensemble de capacit&eacute;s associ&eacute;es.
      La forme utilis&eacute;e pour ces capacit&eacute;s est une paire
      <literal><replaceable>nom</replaceable>=<replaceable>valeur</replaceable></literal>
      o&ugrave; <replaceable>nom</replaceable> est un identifiant connu et
      <replaceable>valeur</replaceable> est une cha&icirc;ne arbitraire
      d&eacute;pendante du nom.  Param&eacute;trer des classes et des
      capacit&eacute;s est plut&ocirc;t direct et &eacute;galement
      d&eacute;crit dans &man.login.conf.5;.</para>

    <para>Les limites de ressource sont diff&eacute;rentes des
      capacit&eacute;s standards des classes en deux points.
      Premi&egrave;rement, pour chaque limite, il existe une limite douce
      (actuelle) et limite dure.  Une limite douce peut &ecirc;tre
      ajust&eacute;e par l'utilisateur ou une application, mais jamais
      d&eacute;passer la limite dure.  Cette derni&egrave;re peut &ecirc;tre
      abaiss&eacute;e par l'utilisateur, mais jamais augment&eacute;e.
      Deuxi&egrave;mement, la plupart des limites de ressource s'applique
      par processus &agrave; un utilisateur sp&eacute;cifique, et non pas
      &agrave; l'utilisateur dans sa totalit&eacute;.  Notez, cependant, que ces
      diff&eacute;rences sont exig&eacute;es par la manipulation
      sp&eacute;cifique des
      limites, et non pas par l'impl&eacute;mentation du syst&egrave;me des
      capacit&eacute;s des classes de session utilisateur (i.e., elles ne sont
      <emphasis>vraiment</emphasis> pas un cas particulier des
      capacit&eacute;s des classes de session).</para>

    <para>Sans plus attendre, ci-dessous sont pr&eacute;sent&eacute;es
      les limites de ressource les plus souvent utilis&eacute;es
      (le reste, avec les autres capacit&eacute;s des classes
      de session, peut &ecirc;tre trouv&eacute; dans
      &man.login.conf.5;).</para>

    <variablelist>
      <varlistentry>
        <term><literal>coredumpsize</literal></term>

	<listitem>
    <indexterm><primary>coredumpsize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>coredumpsize</secondary>
    </indexterm>
	  <para>La limite sur la taille du fichier core
	    g&eacute;n&eacute;r&eacute; par un programme est, pour
	    d'&eacute;videntes raisons, subordonn&eacute;e aux autres limites
	    sur l'utilisation du disque (e.g., <literal>filesize</literal>,
	    ou les quotas de disque).  N&eacute;anmoins, elle est souvent
	    employ&eacute;e comme m&eacute;thode moins
	    s&eacute;v&egrave;re pour contr&ocirc;ler la
	    consommation d'espace disque: puisque les utilisateurs ne
	    g&eacute;n&egrave;rent pas de fichier core eux-m&ecirc;mes,
	    et souvent ne les
	    suppriment pas, param&eacute;trer cela peut leur &eacute;viter
	    de manquer d'espace disque si un programme important (e.g.,
	    <application>emacs</application>) plante.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>cputime</literal></term>

	<listitem>
    <indexterm><primary>cputime</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>cputime</secondary>
    </indexterm>
	  <para>C'est la quantit&eacute; maximale de temps CPU qu'un
	    processus d'un utilisateur peut consommer.  Les processus
	    la d&eacute;passant seront tu&eacute;s par le noyau.

	    <note>
	      <para>C'est une limite sur le <emphasis>temps</emphasis>
		CPU consomm&eacute;, non sur le pourcentage comme
		affich&eacute; par certains champs de &man.top.1; et
		&man.ps.1;.  Une limite sur ce dernier est, au moment de
		l'&eacute;criture de ces lignes, impossible, et serait
		plut&ocirc;t inutile: un compilateur&mdash;probablement
		une t&acirc;che l&eacute;gitime&mdash;peut
		ais&eacute;ment utiliser presque 100% du CPU pendant un certain
		temps.</para>
	    </note>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>filesize</literal></term>

	<listitem>
    <indexterm><primary>filesize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>filesize</secondary>
    </indexterm>
	  <para>C'est la taille maximale du plus gros fichier qu'un utilisateur
	    peut poss&eacute;der.  Contrairement aux <link
	    linkend="quotas">quotas</link>, cette limite ne s'applique
	    qu'aux fichiers individuellement, et non pas sur l'ensemble
	    lui-m&ecirc;me de tous les fichiers que poss&egrave;de
	    un utilisateur.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>maxproc</literal></term>

	<listitem>
    <indexterm><primary>maxproc</primary></indexterm>
        <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>maxproc</secondary>
    </indexterm>
	  <para>C'est le nombre maximal de processus que peut ex&eacute;cuter
	    un utilisateur en m&ecirc;me temps.  Ceci inclut
	    les processus de premier plan et de t&acirc;che de fond.
	    Pour d'&eacute;videntes raisons, il ne doit pas &ecirc;tre plus
	    grand que les limites du syst&egrave;me sp&eacute;cifi&eacute;es
	    par la variable &man.sysctl.8;
	    <varname>kern.maxproc</varname>.  Notez en outre qu'une
	    valeur trop basse peut g&ecirc;ner la productivit&eacute;
	    de l'utilisateur: il est souvent utile d'ouvrir plusieurs
	    sessions &agrave; la fois ou d'ex&eacute;cuter des op&eacute;rations
	    sous forme de &ldquo;pipeline&rdquo;.
	    Certaines t&acirc;ches, comme
	    compiler un gros programme, engendrent &eacute;galement
	    de multiples processus (e.g., &man.make.1;, &man.cc.1;, et
	    autres pr&eacute;processeurs).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memorylocked</literal></term>

	<listitem>
    <indexterm><primary>memorylocked</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>memorylocked</secondary>
    </indexterm>
	  <para>C'est la quantit&eacute; maximale de m&eacute;moire
	    qu'un processus peut avoir demand&eacute; de verrouiller en
	    m&eacute;moire principale (e.g., voir &man.mlock.2;).
	    Certains programmes syst&egrave;me critiques, comme
	    &man.amd.8;, sont verrouill&eacute;s en m&eacute;moire
	    principale de sorte qu'en cas de d&eacute;passement de la
	    m&eacute;moire de pagination, ils ne contribuent pas aux ennuis
	    du syst&egrave;me.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>memoryuse</literal></term>

	<listitem>
    <indexterm><primary>memoryuse</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>memoryuse</secondary>
    </indexterm>
	  <para>C'est la quantit&eacute; maximale de m&eacute;moire
	    qu'un processus peut consommer &agrave; un instant donn&eacute;.
	    Cela inclus la m&eacute;moire principale et celle de pagination.
	    Ce n'est pas le rem&egrave;de miracle pour restreindre la
	    consommation de m&eacute;moire, mais c'est un bon
	    d&eacute;but.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>openfiles</literal></term>

	<listitem>
    <indexterm><primary>openfiles</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>openfiles</secondary>
    </indexterm>
	  <para>C'est le nombre maximal de fichiers qu'un processus peut
	    avoir ouvert.  Sous FreeBSD, des fichiers sont &eacute;galement
	    employ&eacute;s pour repr&eacute;senter les sockets et
	    les canaux IPC, par cons&eacute;quent faites attention
	    &agrave; ne fixer une valeur trop basse.  La limite
	    g&eacute;n&eacute;rale du syst&egrave;me pour cela est
	    d&eacute;finie par la variable &man.sysctl.8;
	    <varname>kern.maxfiles</varname>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>sbsize</literal></term>

	<listitem>
    <indexterm><primary>sbsize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>sbsize</secondary>
    </indexterm>
	  <para>C'est une limite sur la quantit&eacute; de
	    m&eacute;moire r&eacute;seau, et donc de &ldquo;mbufs&rdquo;,
	    qu'un utilisateur peut consommer.  Ceci est &agrave;
	    l'origine une r&eacute;ponse &agrave; une vielle attaque par
	    refus de service en cr&eacute;ant de nombreuses sockets, mais peut
	    &ecirc;tre g&eacute;n&eacute;ralement employ&eacute;e
	    pour limiter les communications r&eacute;seau.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>stacksize</literal></term>

	<listitem>
    <indexterm><primary>stacksize</primary></indexterm>
    <indexterm>
      <primary>restrictions pour les utilisateurs</primary>
      <secondary>stacksize</secondary>
    </indexterm>
	  <para>C'est la taille maximale de la pile d'un processus.
	    Seule, cela n'est pas suffisant pour limiter la quantit&eacute;
	    de m&eacute;moire que peut utiliser un programme, par
	    cons&eacute;quent, cette limite devra &ecirc;tre
	    utilis&eacute;e en m&ecirc;me temps que d'autres
	    limitations.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Il y a quelques &eacute;l&eacute;ments
      &agrave; se rappeler quand on fixe des
      limites de ressource.  Quelques astuces g&eacute;n&eacute;rales,
      suggestions, et commentaires divers:</para>

    <itemizedlist>
      <listitem>
        <para>Les processus lanc&eacute;s au d&eacute;marrage
	  du syst&egrave;me par <filename>/etc/rc</filename>
	  sont assign&eacute;s &agrave; la classe
	  <literal>daemon</literal>.</para>
      </listitem>

      <listitem>
        <para>Bien que le fichier <filename>/etc/login.conf</filename>
	  qui est fourni avec le syst&egrave;me est une bonne source
	  de valeurs raisonnables pour la plupart des limites, seul
	  vous, l'administrateur, peut savoir ce qui est appropri&eacute;
	  &agrave; votre syst&egrave;me.  Fixer une limite trop haute
	  peut laisser la porte ouverte aux abus, alors qu'une limite
	  trop basse peut &ecirc;tre un frein &agrave; la
	  productivit&eacute;.</para>
      </listitem>

      <listitem>
        <para>Les utilisateurs du syst&egrave;me X Window (X11) devraient
	  se voir allouer plus de ressources que les autres
	  utilisateurs.  X11 par lui-m&ecirc;me utilise beaucoup de
	  ressources, mais il encourage &eacute;galement les
	  utilisateurs &agrave; ex&eacute;cuter plus de
	  programmes simultan&eacute;ment.</para>
      </listitem>

      <listitem>
        <para>Souvenez-vous que de nombreuses limites ne s'appliquent
	  qu'aux processus individuels, et non pas &agrave; l'utilisateur
	  globalement.  Par exemple, param&eacute;trer
	  <varname>openfiles</varname> &agrave; 50 signifie
	  que chaque processus que l'utilisateur ex&eacute;cute pourra ouvrir
	  jusqu'&agrave; 50 fichiers.  Ainsi, la quantit&eacute; totale
	  de fichiers qu'un utilisateur peut ouvrir est la valeur
	  <literal>openfiles</literal> multipli&eacute;e par la valeur
          <literal>maxproc</literal>.  Ceci s'applique &eacute;galement
	  &agrave; la consommation de m&eacute;moire.</para>
      </listitem>
    </itemizedlist>

    <para>Pour de plus amples informations sur les limites et les
      classes de session et les capacit&eacute;s en
      g&eacute;n&eacute;ral, veuillez consulter les pages de manuel
      appropri&eacute;es: &man.cap.mkdb.1;, &man.getrlimit.2;,
      &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-personalizing">
    <title>Personnaliser des comptes utilisateur</title>

    <para>La localisation est une configuration de l'environnement mise
      en place par l'administrateur syst&egrave;me ou l'utilisateur pour
      adapter l'environnement &agrave; diff&eacute;rentes
      langues, jeux de caract&egrave;res, normes d'&eacute;criture de la
      date et de l'heure, et ainsi de suite.  Ceci est abord&eacute; dans le
      chapitre sur la <link linkend="l10n">localisation</link>.</para>
  </sect1>

  <sect1 id="users-groups">
    <title>Groupes</title>

    <indexterm><primary>groupes</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>comptes</primary>
      <secondary>groupes</secondary>
    </indexterm>
    <para>Un groupe est simplement une liste d'utilisateurs.  Les
      groupes sont identifi&eacute;s par leur nom et leur GID
      (identificateur de groupe).  Dans FreeBSD (et la plupart des
      syst&egrave;mes &unix;), les deux &eacute;l&eacute;ments
      que le noyau utilise pour d&eacute;cider si un processus
      est autoris&eacute; &agrave; faire quelque chose sont son ID
      utilisateur et la liste des groupes auxquels il appartient.
      Diff&eacute;rent d'un identificateur utilisateur, un
      processus est associ&eacute; &agrave; une liste de groupes.  Vous pourrez
      entendre faire r&eacute;f&eacute;rences au &ldquo;group ID&rdquo;
      d'un utilisateur ou d'un processus; la plupart du temps on veut
      parler du premier groupe dans la liste.</para>

    <para>La table d'&eacute;quivalence nom de groupe et identificateur de
      groupe se trouve dans <filename>/etc/group</filename>.  C'est un
      fichier texte avec quatre champs d&eacute;limit&eacute;s par deux points.
      Le premier champ est le nom du groupe, le second est le mot de
      passe crypt&eacute;, le troisi&egrave;me est l'ID du groupe, et le
      quatri&egrave;me est
      une liste de membres s&eacute;par&eacute;s par des virgules.
      Ce fichier peut sans risque &ecirc;tre &eacute;dit&eacute;
      &agrave; la main (en supposant, bien s&ucirc;r, que vous ne faites pas
      d'erreur de syntaxe!).  Pour une description compl&egrave;te de le
      syntaxe, voir la page de manuel &man.group.5;.</para>

    <para>Si vous ne voulez pas &eacute;diter
      <filename>/etc/group</filename> &agrave; la main, vous pouvez
      utiliser la commande &man.pw.8; pour ajouter et &eacute;diter
      des groupes.  Par exemple, pour ajouter un groupe appel&eacute;
      <groupname>teamtwo</groupname> et ensuite v&eacute;rifier qu'il existe
      bien vous pouvez utiliser:</para>

    <example>
      <title>Ajouter un groupe en utilisant &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>Le nombre <literal>1100</literal> ci-dessus est
      l'identificateur de groupe pour le groupe
      <groupname>teamtwo</groupname>.  A cet instant
      <groupname>teamtwo</groupname> n'a aucun membre, et est par
      cons&eacute;quent plut&ocirc;t inutile.  Changeons cela en ajoutant
      <username>jru</username> au groupe
      <groupname>teamtwo</groupname>.</para>

    <example>
      <title>Ajouter quelqu'un dans un groupe en utilisant
	&man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>Le param&egrave;tre ajout&eacute; &agrave; l'option <option>-M</option>
      est une liste, d&eacute;limit&eacute;e par des virgules,
      d'utilisateurs qui sont membres du groupe.  Des sections
      pr&eacute;c&eacute;dentes nous savons que le fichier des mots de passe
      contient &eacute;galement un groupe pour chaque utilisateur.  Le dernier
      (utilisateur) est automatiquement ajout&eacute; &agrave; la
      liste des groupes par le syst&egrave;me; l'utilisateur
      n'appara&icirc;tra pas comme &eacute;tant membre quand on utilise
      l'option <option>groupshow</option> avec &man.pw.8;, mais
      appara&icirc;tra quand l'information est demand&eacute;e
      par l'interm&eacute;diaire de &man.id.1; ou un outil similaire.
      En d'autres termes, &man.pw.8; manipule uniquement le fichier
      <filename>/etc/group</filename>, il n'essaiera jamais de lire des
      donn&eacute;es suppl&eacute;mentaires &agrave; partir
      du fichier <filename>/etc/passwd</filename>.</para>

    <example>
      <title>Utilisation de &man.id.1; pour d&eacute;terminer
	l'appartenance &agrave; un groupe</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Comme vous pouvez le voir, <username>jru</username> est membre
      des groupes <groupname>jru</groupname> et
      <groupname>teamtwo</groupname>.</para>

    <para>Pour plus d'information sur &man.pw.8;, voir sa page de
      manuel, et pour d'information sur le format de
      <filename>/etc/group</filename>, consultez la page de manuel
      &man.group.5;.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
