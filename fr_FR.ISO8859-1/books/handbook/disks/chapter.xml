<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.277
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="disks">
  <title>Stockage des données</title>
  &trans.a.fonvieille;

  <sect1 xml:id="disks-synopsis">
    <title>Synopsis</title>


    <para>Ce chapitre couvre l'utilisation des disques sous FreeBSD.
      Cela comprend les disques mémoire, les disques réseau,
      les périphériques standards de stockage
      SCSI/IDE, et les périphériques utilisant
      l'interface USB.</para>

    <para>Après la lecture de ce chapitre, vous
      connaîtrez:</para>
    <itemizedlist>
      <listitem>
	<para>La terminologie qu'utilise FreeBSD pour décrire
	  l'organisation des données sur un disque physique (les
	  partitions et les tranches).</para>
      </listitem>
      <listitem>
	<para>Comment ajouter des disques durs supplémentaires sur
	  votre système.</para>
      </listitem>
      <listitem>
	<para>Comment configurer &os; pour l'utilisation de
	  périphériques de stockage USB.</para>
      </listitem>
      <listitem>
	<para>Comment configurer des systèmes de fichiers virtuels,
	  comme les disques mémoires.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les quotas pour limiter l'usage de
	  l'espace disque.</para>
      </listitem>
      <listitem>
	<para>Comment chiffrer des disques pour les sécuriser
	  contre les attaques.</para>
      </listitem>
      <listitem>
	<para>Comment créer et graver des CDs et DVDs sous
	  FreeBSD.</para>
      </listitem>
      <listitem>
	<para>Les différents supports disponibles pour les
	  sauvegardes.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les programmes de sauvegarde
	  disponibles sous FreeBSD.</para>
      </listitem>
      <listitem>
	<para>Comment faire des sauvegardes sur disquettes.</para>
      </listitem>
      <listitem>
	<para>Ce que sont les <quote>snapshots</quote>
	  (instantanés) de systèmes de fichiers et
	  comment les utiliser efficacement.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Savoir comment configurer et installer un nouveau noyau
	  &os; (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="disks-naming">
    <title>Noms des périphériques</title>

    <para>Ce qui suit est une liste des périphériques
      de stockage physiques, et des noms de périphériques
      associés.</para>

    <table xml:id="disk-naming-physical-table" frame="none">
      <title>Conventions de nom pour les disques physiques</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Type de disque</entry>
	    <entry>Nom du périphérique</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>Disques durs IDE</entry>
	    <entry><literal>ad</literal></entry>
	  </row>
	  <row>
	    <entry>Lecteurs de CDROMs IDE</entry>
	    <entry><literal>acd</literal></entry>
	  </row>
	  <row>
	    <entry>Disques durs SCSI et périphériques de
	      stockage USB</entry>
	    <entry><literal>da</literal></entry>
	  </row>
	  <row>
	    <entry>Lecteurs de CDROMs SCSI</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry><literal>mcd</literal> pour les CD-ROMs Mitsumi,
	      <literal>scd</literal> pour les CD-ROMs Sony
	    </entry>
	  </row>
	  <row>
	    <entry>Lecteurs de disquette</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>Lecteurs de bande SCSI</entry>
	    <entry><literal>sa</literal></entry>
	  </row>
	  <row>
	    <entry>Lecteurs de bande IDE</entry>
	    <entry><literal>ast</literal></entry>
	  </row>
	  <row>
	    <entry>Disques flash</entry>
	    <entry><literal>fla</literal> pour les
	      périphériques Flash &diskonchip;</entry>
	  </row>
	  <row>
	    <entry>Disques RAID</entry>
	    <entry><literal>aacd</literal> pour l'AdvancedRAID &adaptec;,
	      <literal>mlxd</literal> et <literal>mlyd</literal>
	      pour les &mylex;,
	      <literal>amrd</literal> le &megaraid; d'AMI,
	      <literal>idad</literal> pour le Smart RAID de Compaq,
	      <literal>twed</literal> pour le &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 xml:id="disks-adding">
    <info><title>Ajouter des disques</title>
      <authorgroup>
	<author><personname><firstname>David</firstname><surname>O'Brien</surname></personname><contrib>Contribution originale de </contrib></author>
      </authorgroup>
      
    </info>

    

    <indexterm>
      <primary>disques</primary>
      <secondary>ajout</secondary>
    </indexterm>

    <para>Supposons que nous voulions ajouter un second disque SCSI
      &agrave; une machine qui n'a pour l'instant qu'un seul disque.
      Commençons par arrêter l'ordinateur et installer le disque
      en suivant les instructions données par le constructeur de
      l'ordinateur, du contrôleur et du disque.  Comme il y a de
      nombreuses façon de procéder, ces détails
      dépassent le cadre de ce document.</para>

    <para>Ouvrons maintenant une session sous le compte
      <systemitem class="username">root</systemitem>.  Après avoir installé le disque,
      consultez le fichier <filename>/var/run/dmesg.boot</filename>
      pour vérifier que le nouveau disque a été
      reconnu.  Dans notre exemple, le disque que nous venons
      d'ajouter sera le périphérique
      <filename>da1</filename> et nous le monterons sur le
      répertoire <filename>/1</filename> (si vous ajoutez
      un disque IDE, le nom de périphérique sera
      <filename>ad1</filename>).</para>

    <indexterm><primary>partitions</primary></indexterm>
    <indexterm><primary>tranches</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>

    <para>&os; tourne sur des ordinateurs compatibles IBM-PC,
      il doit tenir compte des partitions PC BIOS.  Ces dernières
      sont différentes des partitions BSD traditionnelles.
      Un disque PC peut avoir jusqu'&agrave; quatre partitions.  Si le
      disque va être réservé uniquement &agrave; FreeBSD,
      vous pouvez utiliser le mode <emphasis>dédié</emphasis>.
      Sinon, FreeBSD devra utiliser une des partitions PC BIOS.
      FreeBSD appelle les partitions PC BIOS
      <emphasis>tranches</emphasis> (&ldquo;slices&rdquo;) pour
      les distinguer des partitions BSD traditionnelles.
      Vous pouvez aussi des tranches sur un disque dédié
      &agrave; FreeBSD, mais utilisé sur une machine où
      un autre système d'exploitation est également
      installé.  C'est une bonne manière pour
      éviter de perturber l'utilitaire <command>fdisk</command>
      des autres système d'exploitation différents de
      &os;.</para>

    <para>Dans le cas d'une tranche, le disque ajouté deviendra
      le périphérique <filename>/dev/da1s1e</filename>.
      Ce qui se lit: disque SCSI, numéro d'unité 1 (second disque
      SCSI), tranche 1 (partition PC BIOS 1), et partition BSD
      <filename>e</filename>.  Dans le cas du mode dédié,
      le disque sera ajouté en tant que
      <filename>/dev/da1e</filename>.</para>

    <para>En raison de l'utilisation d'entiers codés sur 32
      bits pour stocker le nombre de secteurs, &man.bsdlabel.8;
      est
      limité &agrave; 2^32-1 secteurs par disque ou 2TB dans la
      plupart des cas.  Le format &man.fdisk.8; n'autorise pas de
      secteur au del&agrave; de 2^32-1 et une largeur de plus de
      2^32-1, limitant donc les partitions &agrave; 2TB et les disques
      &agrave; 4TB en général.  Le format
      &man.sunlabel.8; est limité &agrave; 2^32-1 secteur par
      partition et 8 partitions pour un total de 16TB d'espace.  Pour
      des disques plus importants, les partitions &man.gpt.8; peuvent
      être utilisées.</para>

    <sect2>
      <title>Utiliser &man.sysinstall.8;</title>
      <indexterm>
	<primary><application>sysinstall</application></primary>
	<secondary>ajout de disque</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>
      <procedure>
	<step>
	  <title>Naviguer dans <application>sysinstall</application></title>

	  <para>Vous pouvez utiliser <command>sysinstall</command>
	    et ses menus simples d'emploi pour partitionner et
	    libeller le nouveau disque.  Ouvrez une session sous
	    le compte super-utilisateur <systemitem class="username">root</systemitem> ou
	    utilisez la commande &man.su.1;.  Lancez
	    <command>sysinstall</command> et sélectionnez
	    <guimenuitem>Configure</guimenuitem>.  A l'intérieur
	    du menu <guimenuitem>FreeBSD Configuration
	    Menu</guimenuitem>, descendez et sélectionnez l'option
	    <guimenuitem>Fdisk</guimenuitem>.</para>
	</step>

	<step>
	  <title>L'éditeur de partition
	    <application>fdisk</application></title>
	  <para>Une fois dans l'utilitaire <application>fdisk</application>,
	    nous pouvons taper <keycap>A</keycap> pour utiliser tout
	    le disque pour FreeBSD.  Lorsque l'on vous demande si vous
	    voulez garder la possibilité de pouvoir coopérer avec
	    d'autres systèmes d'exploitation (&ldquo;remain
	    cooperative with any future possible operating
	    systems&rdquo;), répondez par l'affirmative
	    (<literal>YES</literal>).  Enregistrez les modifications
	    sur le disque avec <keycap>W</keycap>.  Quittez maintenant
	    l'éditeur <application>fdisk</application> en tapant
	    <keycap>q</keycap>.  La prochaine question concernera le
	    secteur de démarrage (&ldquo;Master Boot Record&rdquo;).
	    Comme vous ajoutez un disque &agrave; un système
	    déj&agrave; opérationnel, choisissez
	    <guibutton>None</guibutton>.</para>
	</step>

	<step>
	  <title>L'éditeur de label du disque</title>
	  <indexterm><primary>partitions BSD</primary></indexterm>

	  <para>Ensuite, vous devez quitter puis relancer
	    <application>sysinstall</application>.  Suivez les
	    instructions précédentes, en choisissant cette fois
	    l'option <guimenuitem>Label</guimenuitem>.  Vous entrerez
	    dans l'éditeur de label du disque (<literal>Disk Label
	    Editor</literal>).  C'est l&agrave; que vous allez créer
	    les partitions BSD traditionnelles.  Un disque peut avoir
	    jusqu'&agrave; huit partitions, libellées de
	    <literal>a</literal> &agrave; <literal>h</literal>.  Certains
	    de ces labels ont des significations particulières.
	    La partition <literal>a</literal> est la partition racine
	    (<filename>/</filename>).  Seul votre disque système
	    (e.g., celui &agrave; partir duquel vous démarrez)
	    doit avoir une partition <literal>a</literal>.  La
	    partition <literal>b</literal> est utilisée pour la
	    pagination, vous pouvez avoir plusieurs disques avec des
	    partitions de pagination.  La partition
	    <literal>c</literal> désigne la totalité du
	    disque en mode dédié, ou toute la tranche
	    FreeBSD dans le cas contraire.  Les autres partitions sont
	    &agrave; usage général.</para>

	  <para>L'éditeur de label de
	    <application>sysinstall</application> définit par
	    défaut
	    la partition <literal>e</literal> comme première partition
	    qui n'est ni racine, ni de pagination.  Dans l'éditeur
	    de label, créez un seul système de fichiers avec
	    l'option <keycap>C</keycap>.  Quand on vous demande si ce sera un
	    système de fichiers (FS) ou une partition de pagination,
	    choisissez <literal>FS</literal> et indiquez un point de
	    montage (e.g., <filename>/mnt</filename>).  Lorsque vous
	    ajoutez un disque sur un système déj&agrave;
	    installé, <application>sysinstall</application> ne
	    créera
	    pas d'entrées dans <filename>/etc/fstab</filename>, donc
	    le nom que vous donnez au point de montage n'a pas
	    d'importance.</para>

	  <para>Vous pouvez maintenant écrire le nouveau label sur
	    le disque et y créer un système de fichiers.
	    Faites-le en tapant <keycap>W</keycap>.  Ignorez les
	    erreurs de <application>sysinstall</application>
	    disant que la nouvelle partition ne peut être
	    montée.  Quittez maintenant l'éditeur de label et
	    <application>sysinstall</application>.</para>
	</step>

	<step>
	  <title>Dernière étape</title>

	  <para>La dernière étape consiste &agrave; éditer
	    le fichier <filename>/etc/fstab</filename> pour y
	    ajouter une entrée pour votre nouveau disque.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Utiliser les utilitaires en ligne de commande</title>

      <sect3>
	<title>Utiliser les tranches &mdash; &ldquo;slices&rdquo;</title>

	<para>Cette configuration permettra de faire fonctionner
	  correctement votre disque dure avec d'autres systèmes
	  d'exploitation qui pourraient être installé
	  sur votre machine, et ne perturbera pas les utilitaires
	  <command>fdisk</command> de ces autres systèmes
	  d'exploitation.  C'est la méthode recommandée
	  pour l'installation de nouveau disques.  N'utilisez le mode
	  <emphasis>dédié</emphasis> que si vous avez une bonne
	  raison de le faire!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> #Initialize your new disk
&prompt.root; <userinput>bsdlabel -B -w da1s1 auto</userinput> #Label it.
&prompt.root; <userinput>bsdlabel -e da1s1</userinput> # Edit the disklabel just created and add any partitions.
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # Repeat this for every partition you created.
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> # Mount the partition(s)
&prompt.root; <userinput>vi /etc/fstab</userinput> # Add the appropriate entry/entries to your <filename>/etc/fstab</filename>.</screen>

	<para>Si vous avez un disque IDE, remplacez <filename>da</filename>
	  par <filename>ad</filename>.</para>
      </sect3>

      <sect3>
	<title>Mode dédié</title>
	<indexterm><primary>OS/2</primary></indexterm>

	<para>Si le nouveau disque n'est pas destiné a être
	  partagé avec un autre système d'exploitation, vous
	  pouvez utiliser le mode <emphasis>dédié</emphasis>.
	  Rappelez-vous que ce mode peut perturber les systèmes
	  d'exploitation Microsoft; cependant, ils ne toucheront pas
	  au disque.  &os2; d'IBM, au contraire,
	  &ldquo;s'approprie&rdquo; toute partition qu'il trouve et ne
	  reconnaît pas.</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw da1 auto</userinput>
&prompt.root; <userinput>bsdlabel -e da1</userinput>				# create the `e' partition
&prompt.root; <userinput>newfs -d0 /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>

	<para>Un autre méthode est:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="raid">
    <title>RAID</title>

    <sect2 xml:id="raid-soft">
      <title>RAID logiciel</title>

      <sect3 xml:id="ccd">
	<info><title>Configuration du pilote de disque concaténé
	  (CCD &mdash; &ldquo;Concatenated Disk Driver&rdquo;)</title>
	  <authorgroup>
	    <author><personname><firstname>Christopher</firstname><surname>Shumway</surname></personname><contrib>Travail original de </contrib></author>
	  </authorgroup>
	  <authorgroup>
	    <author><personname><firstname>Jim</firstname><surname>Brown</surname></personname><contrib>Révisé par </contrib></author>
	  </authorgroup>
	</info>

	

<indexterm><primary>RAID</primary><secondary>Logiciel</secondary></indexterm>
<indexterm>
  <primary>RAID</primary><secondary>CCD</secondary>
</indexterm>

	<para>Quand il est question du choix d'une solution de
	  stockage de masse les critères de choix les plus
	  importants &agrave; considérer sont la vitesse, la
	  fiabilité, et le
	  coût.  Il est plutôt rare de pouvoir réunir
	  ces trois critères; normalement un
	  périphérique de stockage rapide et fiable est
	  coûteux, et pour diminuer les coûts la
	  vitesse ou la fiabilité doivent
	  être sacrifiées.</para>

	<para>A la conception du système décrit plus bas,
	  le coût a été choisi comme facteur
	  le plus important, suivi de la vitesse, et enfin
	  la fiabilité.  La vitesse de transfert des données
	  est limitée par le réseau.  Et tandis que la
	  fiabilité est très importante, le disque CCD
	  décrit ci-dessous est destiné au stockage de
	  données en ligne qui sont déj&agrave;
	  complètement sauvegardées sur CD-Rs et qui
	  peuvent être facilement remplacées.</para>

	<para>Définir vos propres besoins est la première
	  étape dans le choix d'une solution de stockage
	  de masse.  Si vos critères de choix privilégient
	  la vitesse ou la fiabilité par rapport au coût,
	  votre solution diférera du système décrit dans
	  cette section.</para>

	<sect4 xml:id="ccd-installhw">
	  <title>Installation du matériel</title>

	  <para>En plus du disque système IDE, trois
	    disques Western Digital de 30Go, 5400 trs/min IDE
	    forment le coeur du disque CCD décrit ci-dessous
	    donnant approximativement 90Go de stockage en ligne.
	    La solution idéale serait d'avoir
	    pour chaque disque IDE son propre câble et
	    contrôleur IDE, mais pour minimiser les coûts,
	    des contrôleur IDE supplémentaires n'ont pas
	    été utilisés.  Aussi, les disques ont
	    été configuré de telle façon que chaque
	    contrôleur IDE ait un disque maître et un disque
	    esclave.</para>

	  <para>Au redémarrage, le BIOS a été
	    configuré pour détecter automatiquement
	    les disques attachés.  FreeBSD les a d'ailleurs
	    détectés au redémarrage:</para>

	  <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

	  <note><para>Si FreeBSD ne détecte pas les disques,
	    assurez-vous que vous avez correctement placé les
	    cavaliers.  La plupart des disques IDE disposent
	    également d'un cavalier &ldquo;Cable Select&rdquo;.
	    Ce n'est <emphasis>pas</emphasis> le cavalier de
	    configuration maître/esclave.  Consultez la
	    documentation du disque pour identifier le cavalier
	    correct.</para></note>

	  <para>Ensuite, réfléchissez sur la manière
	    de les intégrer au système de fichiers.
	    Vous devriez faire des recherches sur &man.vinum.8;
	    (<xref linkend="vinum-vinum"/>) et &man.ccd.4;.  Dans
	    cette configuration particulière, &man.ccd.4; a
	    été choisi.</para>
	</sect4>

	<sect4 xml:id="ccd-setup">
	  <title>Configuration du CCD</title>

	  <para>Le pilote &man.ccd.4; vous permet de prendre
	    plusieurs disques identiques et les concaténer
	    en un seul système de fichiers logique.  Afin
	    d'utiliser &man.ccd.4;, vous avez besoin
	    d'un noyau avec le support &man.ccd.4;.
	    Ajoutez la ligne suivante &agrave; votre fichier de
	    configuration de noyau, recompilez, et installez
	    le noyau:</para>

	  <programlisting>device   ccd</programlisting>

	  <para>Le support &man.ccd.4; peut
	    également chargé sous la forme d'un module
	    noyau.</para>

	  <para>Pour configurer &man.ccd.4;,
	    vous devez tout d'abord utiliser &man.bsdlabel.8;
	    pour labéliser les disques:</para>

	  <programlisting>bsdlabel -w ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto</programlisting>

	  <para>Cela a créé un label de disque
	    <filename>ad1c</filename>,
	    <filename>ad2c</filename> et
	    <filename>ad3c</filename> qui s'étend sur
	    l'intégralité du disque.</para>

	  <para>L'étape suivante est de modifier le type de label de
	    disque.  Vous pouvez utiliser &man.bsdlabel.8; pour
	    éditer les disques:</para>

	  <programlisting>bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3</programlisting>

	  <para>Cela ouvre le label de disque actuel de chaque
	    disque dans l'éditeur fixé par la variable
	    d'environnement <envar>EDITOR</envar>,
	    généralement, &man.vi.1;.</para>

	  <para>Un label de disque non modifié ressemblera
	    &agrave; quelque chose comme ceci:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	  <para>Ajoutez une nouvelle partition
	    <literal>e</literal> pour être utilisé par
	    &man.ccd.4;.  Cela peut être une copie de la
	    partition <literal>c</literal> mais le type de système
	    de fichiers (<option>fstype</option>) doit être
	    <userinput>4.2BSD</userinput>.  Le label de disque devait
	    ressembler &agrave;:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	</sect4>

	<sect4 xml:id="ccd-buildingfs">
	  <title>Création du système de fichiers</title>

	  <para>Maintenant que tous les disques sont labélisés,
	    vous devez construire le &man.ccd.4;.  Pour cela,
	    utilisez &man.ccdconfig.8;, avec des options semblables
	    &agrave; ce qui suit:</para>

	    <programlisting>ccdconfig ccd0<co xml:id="co-ccd-dev"/> 32<co xml:id="co-ccd-interleave"/> 0<co xml:id="co-ccd-flags"/> /dev/ad1e<co xml:id="co-ccd-devs"/> /dev/ad2e /dev/ad3e</programlisting>

	  <para>L'utilisation et la signification de chaque option
	    est données ci-dessous:</para>

          <calloutlist>
            <callout arearefs="co-ccd-dev">
	    <para>Le premier argument est le périphérique
	      &agrave; configurer, dans ce cas,
	      <filename>/dev/ccd0c</filename>. La partie
	      <filename>/dev/</filename> est optionnelle.</para>
            </callout>

            <callout arearefs="co-ccd-interleave">

	    <para>L'entrelacement (&ldquo;interleave&rdquo;) du
	      système de fichiers.  L'entrelacement définit
	      la taille d'une bande de blocs disque, de 512 octets
	      chacune normalement.  Donc un entrelacement de 32
	      serait d'une largeur de 16384 octets.</para>
            </callout>

            <callout arearefs="co-ccd-flags">
	    <para>Paramètres pour &man.ccdconfig.8;.  Si vous
	      désirez activer les miroirs disque, vous pouvez
	      spécifier un indicateur &agrave; cet endroit.  Cette
	      configuration ne fournit pas de miroir pour
	      &man.ccd.4;, aussi l'indicateur est a 0
	      (zéro).</para>
            </callout>

            <callout arearefs="co-ccd-devs">
	    <para>Les derniers arguments de &man.ccdconfig.8;
	      sont les périphériques &agrave; placer dans
	      le disque concaténé.  Utilisez le chemin
	      complet pour chaque périphérique.</para>
            </callout>
          </calloutlist>

	  <para>Après avoir utilisé &man.ccdconfig.8; le
	    &man.ccd.4; est configuré.  Un système de fichiers
	    peut être créé.  Consultez la page de manuel de
	    &man.newfs.8; pour les options disponibles, ou lancez
	    simplement:</para>

	  <programlisting>newfs /dev/ccd0c</programlisting>

	</sect4>

	<sect4 xml:id="ccd-auto">
	  <title>Automatiser la procédure</title>

	  <para>Généralement, vous voudrez monter le
	    &man.ccd.4; &agrave; chaque redémarrage.  Pour cela,
	    vous devez le configurer avant toute chose.
	    Ecrivez votre configuration actuelle dans
	    <filename>/etc/ccd.conf</filename> en utilisant la
	    commande suivante:</para>

	  <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

	  <para>Lors du démarrage, la procédure
	    <command>/etc/rc</command> exécute
	    <command>ccdconfig -C</command> si
	    <filename>/etc/ccd.conf</filename> existe.  Cela configure
	    automatiquement le &man.ccd.4; de façon
	    &agrave; pouvoir être monté.</para>

	  <note><para>Si vous démarrez en mode mono-utilisateur,
	    avant que vous ne puissiez monter le &man.ccd.4;, vous
	    devez utiliser la commande suivante pour configurer
	    l'unité:</para>

	    <programlisting>ccdconfig -C</programlisting>
	  </note>

	  <para>Pour monter automatiquement le &man.ccd.4;
	    placez une entrées pour le &man.ccd.4; dans
	    <filename>/etc/fstab</filename>, il sera ainsi monté
	    au démarrage:</para>

	  <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
	</sect4>
      </sect3>

      <sect3 xml:id="vinum">
	<title>Le gestionnaire de volume Vinum</title>

<indexterm><primary>RAID</primary><secondary>Logiciel</secondary></indexterm>
  <indexterm>
    <primary>RAID</primary>
    <secondary>Vinum</secondary>
</indexterm>

	<para>Le gestionnaire de volume Vinum est un pilote
	  de périphérique de gestion de disques
	  virtuels.  Il sépare le disque matériel de l'interface
	  de périphérique bloc et organise les données
	  de telle façon qu'il en résulte une amélioration
	  de la flexibilité, des performances et de la
	  fiabilité, comparé &agrave; la vision
	  traditionnelle sous forme partitionnée du stockage
	  disque.  &man.vinum.8; implémente les modèles
	  RAID-0, RAID-1 et RAID-5, individuellement ou
	  combinés.</para>

	<para>Voir le <xref linkend="vinum-vinum"/> pour plus
	  d'information au sujet de &man.vinum.8;.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="raid-hard">
      <title>RAID Matériel</title>

      <indexterm>
	<primary>RAID</primary>
	<secondary>Matériel</secondary>
      </indexterm>
      <para>FreeBSD supporte également de nombreux contrôleurs
	<acronym>RAID</acronym>.  Ces périphériques
	peuvent contrôler un système <acronym>RAID</acronym>
	sans nécessiter l'utilisation d'un logiciel spécifique
	pour &os; pour gérer l'unité.</para>

      <para>En utilisant son propre <acronym>BIOS</acronym>, la carte
	contrôle la plupart des opérations disque.  Ce qui
	suit est une description rapide d'une configuration utilisant
	un contrôleur Promise <acronym>IDE</acronym> <acronym>RAID</acronym>.
	Quand cette carte est installée et le système
	redémarré, une invite s'affichera posant quelques
	questions.  Suivez les instructions &agrave; l'écran
	pour atteindre l'écran de configuration de la carte.
	A partir de l&agrave;, vous avez la possibilité de combiner
	tous les disques attachés.  En faisant cela, les
	disques apparaîtront sous la forme d'un unique disque
	sous FreeBSD.  D'autres niveaux <acronym>RAID</acronym>
	peuvent être configurés en conséquence.</para>
    </sect2>

    <sect2>
      <title>Reconstruire une unité ATA RAID1</title>

      <para>FreeBSD vous permet de remplacer &agrave; chaud
	un disque défectueux dans une unité.  Cela doit
	être fait avant redémarrage.</para>

      <para>Vous verrez probablement dans
	<filename>/var/log/messages</filename> ou dans la sortie de
	&man.dmesg.8; quelque chose comme:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)
status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>En utilisant &man.atacontrol.8;, recherchez
	de plus amples informations:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>Vous devrez détacher le canal ATA avec le
	    disque défectueux de façon &agrave; pouvoir
	    le retirer sans risque:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach ata3</userinput></screen>
	</step>

	<step>
	  <para>Remplacer le disque.</para>
	</step>

	<step>
	  <para>Rattacher le canal ATA:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach ata3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>
	</step>

	<step>
	  <para>Rajouter le disque de rechange &agrave;
	    l'unité:</para>

	  <screen>&prompt.root; <userinput>atacontrol addspare ar0 ad6</userinput></screen>
	</step>

	<step>
	  <para>Recontruire l'unité:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>Il est possible de contrôler l'avancée de
	    la procédure en utilisant la commande
	    suivante:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>Attendre jusqu'&agrave; la fin de cette opération.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="usb-disks">
    <info><title>Périphériques de stockage USB</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>USB</primary>
      <secondary>disques</secondary>
    </indexterm>

    <para>De nombreuses solutions de stockage externes utilisent, de
      nos jours, le bus série universel (&ldquo;Universal
      Serial Bus&rdquo;&mdash;USB): disques durs, clés USB,
      graveurs de CDs, etc.  &os; fournit un support pour ces
      périphériques.</para>

    <sect2>
      <title>Configuration</title>

      <para>Le pilote de périphériques USB de stockage
	de masse, &man.umass.4;, fournit le support pour les
	périphériques de stockage USB.  Si vous utilisez
	le noyau <filename>GENERIC</filename>, vous n'avez rien
	&agrave; modifier &agrave; votre configuration.  Si vous
	utilisez un noyau personnalisé, assurez-vous que les
	lignes suivantes sont présentent dans votre fichier de
	configuration du noyau:</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ohci
device usb
device umass</programlisting>

      <para>Le pilote &man.umass.4; utilise le sous-système
	SCSI pour accéder aux périphériques de
	stockage USB, votre périphérique USB sera vu par
	le système comme étant un
	périphérique SCSI.  En fonction du
	contrôleur USB présent sur votre carte
	mère, vous n'avez besoin qu'une des lignes
	<literal>device uhci</literal> et <literal>device
	ohci</literal>, cependant avoir les deux lignes dans votre
	configuration du noyau est sans danger.  N'oubliez pas de
	compiler et d'installer le nouveau noyau si vous y avez
	effectué des modifications.</para>

      <note>
	<para>Si votre périphérique USB est un graveur
	  de CD ou de DVD, le pilote de périphérique SCSI
	  CD-ROM, &man.cd.4;, doit être ajouté au noyau via
	  la ligne:</para>

	<programlisting>device cd</programlisting>

	<para>Puisque le graveur est vu comme un disque SCSI, le
	  pilote &man.atapicam.4; ne devrait pas être
	  employé dans la configuration du noyau.</para>
      </note>

      <para>Le support pour les contrôleurs USB 2.0 est fourni
	avec &os; vous devez cependant ajouter:</para>

      <programlisting>device ehci</programlisting>

      <para>&agrave; votre fichier de configuration pour
	bénéficier du support USB 2.0.  Notez que les
	pilotes &man.uhci.4; et &man.ohci.4; sont toujours
	nécessaires si vous désirez le support de l'USB
	1.X.</para>
    </sect2>

    <sect2>
      <title>Test de la configuration</title>

      <para>La configuration est prête &agrave; être
	testée: branchez votre périphérique USB,
	et dans le tampon des messages du système
	(&man.dmesg.8;), le disque devrait apparaître de cette
	manière:</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>Bien évidement, le modèle, le fichier
	spécial de périphérique
	(<filename>da0</filename>) et d'autres détails
	peuvent être différents en fonction de votre
	configuration.</para>

      <para>Comme le périphérique USB est vu comme
	étant un périphérique SCSI, la commande
	<command>camcontrol</command> peut être employée
	pour lister les périphériques de stockage USB
	attachés au système:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>Si le disque dispose d'un système de fichiers, vous
	devriez pouvoir le monter.  La <xref linkend="disks-adding"/>
	vous aidera &agrave; formater et créer des partitions
	sur le disque USB si nécessaire.</para>

      <para>Pour rendre ce périphérique montable par un
	utilisateur normal, un certain nombre de paramétrages
	sont nécessaires.  Tout d'abord, les entrées de
	périphériques qui sont créées lors
	de la connexion d'un périphérique USB doivent
	être accessibles &agrave; l'utilisateur.  Une solution
	est de faire en sorte que tous les utilisateurs de ces
	périphériques soient membres du groupe
	<systemitem class="groupname">operator</systemitem>.  Cela se fait &agrave; l'aide
	de &man.pw.8;.  Ensuite, quand ces entrées de
	périphériques sont créées, le
	groupe <systemitem class="groupname">operator</systemitem> doit pouvoir y
	accéder en lecture et en écriture.  Pour cela,
	les lignes suivantes sont ajoutées &agrave;
	<filename>/etc/devfs.rules</filename>:</para>

      <programlisting>[localrules=1]
add path 'da*' mode 0660 group operator</programlisting>

      <note>
	<para>S'il y a déj&agrave; des disques SCSI dans le
	  système, on doit procéder
	  légèrement différemment.  Par exemple,
	  si le système contient déj&agrave; des disques
	  <filename>da0</filename> &agrave;
	  <filename>da2</filename> attachés au
	  système, changez la seconde ligne pour:</para>

	<programlisting>add path 'da[3-9]*' mode 0660 group operator</programlisting>

	<para>Les disques déj&agrave; présents
	  n'appartiendront pas au groupe
	  <systemitem class="groupname">operator</systemitem>.</para>
      </note>

      <para>Vous devez également activer votre ensemble de
	règles &man.devfs.rules.5; dans votre fichier
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>devfs_system_ruleset="localrules"</programlisting>

      <para>Le noyau doit être ensuite configuré pour
	autoriser les utilisateurs habituels &agrave; monter des
	systèmes de fichiers.  La méthode la plus simple
	est d'ajouter la ligne suivante au fichier
	<filename>/etc/sysctl.conf</filename>:</para>

      <programlisting>vfs.usermount=1</programlisting>

      <para>Notez que ce paramétrage ne prendra effet qu'au
	prochain redémarrage.  Il est également possible
	d'utiliser &man.sysctl.8; pour fixer cette variable.</para>

      <para>La dernière étape est de créer un
	répertoire où le système de fichiers sera
	monté.  Ce répertoire doit appartenir &agrave;
	l'utilisateur qui montera le système de fichiers.  Une
	méthode adaptée et la création par
	<systemitem class="username">root</systemitem> d'un sous-répertoire
	<filename>/mnt/$USER</filename>
	appartenant &agrave; l'utilisateur en question (remplacez
	<replaceable>$USER</replaceable> par le nom d'utilisateur de
	cet utilisateur):</para>

      <screen>&prompt.root; <userinput>mkdir /mnt/$USER</userinput>
&prompt.root; <userinput>chown $USER:$USER /mnt/$USER</userinput></screen>

      <para>Supposez qu'une clé USB soit branchée et
	qu'un périphérique
	<filename>/dev/da0s1</filename> apparaît.  Comme ce type
	de périphériques est en général
	livré préformaté avec un système
	de fichiers de type FAT, on pourra le monter de cette
	manière:</para>

      <screen>&prompt.user; <userinput>mount -t msdosfs -m 644 -M 755 /dev/da0s1 /mnt/$USER</userinput></screen>

      <para>Si vous débranchez le périphérique
	(le disque doit être démonté auparavant),
	vous devriez voir dans les messages du système quelque
	chose comme:</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>
    </sect2>

    <sect2>
      <title>Lectures supplémentaires</title>

      <para>En plus des sections <link linkend="disks-adding">Ajouter
	des disques</link> et <link linkend="mount-unmount">Monter et
	démonter des systèmes de fichiers</link>, la
	lecture de différentes pages de manuel peut être
	également utile: &man.umass.4;, &man.camcontrol.8;, et
	&man.usbdevs.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-cds">
    <info><title>Création et utilisation de supports optiques
      (CDs)</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>CDROMs</primary>
      <secondary>création</secondary>
    </indexterm>

    <sect2>
      <title>Introduction</title>

      <para>Les CDs se différencient des disques conventionnels
	par de nombreuses caractéristiques.  Au départ, ils
	n'étaient pas inscriptible par l'utilisateur.  Ils sont
	conçu pour être lut de façon continue sans
	délai
	pour déplacer la tête de lecture entre les pistes.
	Ils sont également plus facile &agrave; déplacer
	entre systèmes que les supports de même taille
	&agrave; cette époque.</para>

      <para>Les CDs possèdent des pistes, mais cela fait
	référence &agrave; un ensemble de données
	qui peuvent être lues de façon continue et non pas
	&agrave; une particularité physique du disque.  Pour produire
	un CD sous FreeBSD, il faut préparer les fichiers
	de données qui vont constituer les pistes sur le CD, puis
	écrire les pistes sur le CD.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
        <primary>systèmes de fichiers</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>Le système de fichiers ISO 9660 a été
	conçu pour gérer ces différences.
	Malheureusement il incorpore
	des limites du système de fichiers qui semblaient normale
	alors.  Mais heureusement, il fournit un mécanisme
	d'extension qui permet au CDs proprement gravés de passer
	outre ces limites tout en restant lisibles par les systèmes
	qui ne supportent pas ces extensions.</para>

      <indexterm>
        <primary><package>sysutils/cdrtools</package></primary>
      </indexterm>
      <para>Le logiciel <package>sysutils/cdrtools</package>
	comprend &man.mkisofs.8;, un programme que vous pouvez
	utiliser pour produire un fichier de données
	contenant un système de fichiers ISO 9660.  Il dispose
	d'options pour le support de diverses extensions, et est
	décrit ci-dessous.</para>

      <indexterm>
        <primary>graveur de CD</primary>
        <secondary>ATAPI</secondary>
      </indexterm>
      <para>L'outil a utiliser pour graver un CD varie en fonction du
	type de graveur de CD: ATAPI ou autre.  Les graveurs ATAPI
	utilisent le programme <command>burncd</command> qui fait partie
	du système de base.  Les graveurs SCSI ou USB devraient
	utiliser l'utilitaire <command>cdrecord</command> du logiciel porté
	<package>sysutils/cdrtools</package> port.
	Il est également possible d'utiliser
	  <command>cdrecord</command>
	  et d'autres outils pour lecteurs SCSI sur du matériel
	  ATAPI avec le <link linkend="atapicam">module
	  ATAPI/CAM</link>.</para>

      <para>Si vous voulez un programme de gravure de CD avec une
	interface graphique, vous devriez jeter un oeil &agrave;
	<application>X-CD-Roast</application> ou
	<application>K3b</application>.  Ces outils sont disponibles
	sous une version pré-compilée ou &agrave; partir
	des logiciels portés <package>sysutils/xcdroast</package> et <package>sysutils/k3b</package>.
	<application>X-CD-Roast</application> et
	<application>K3b</application> nécessitent le <link linkend="atapicam">module ATAPI/CAM</link> avec des
	périphériques ATAPI.</para>
    </sect2>

    <sect2 xml:id="mkisofs">
      <title>mkisofs</title>

      <para>L'utilitaire &man.mkisofs.8;, qui fait partie du logiciel
	porté <package>sysutils/cdrtools</package>,
	produit un système de fichiers ISO 9660 qui est une image de
	l'arborescence des répertoires dans un système de fichiers
	&unix;.  L'utilisation la plus simple est:</para>

      <screen>&prompt.root; <userinput>mkisofs -o fichierimage.iso /chemin/vers/arborescence</userinput></screen>

      <indexterm>
        <primary>systèmes de fichiers</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>Cette commande créera un
	<replaceable>fichierimage.iso</replaceable> contenant un
	système de fichiers ISO 9660 qui est une copie de
	l'arborescence
	<replaceable>/chemin/vers/arborescence</replaceable>.
	Durant le processus de création, les noms de fichiers
	seront modifiés de façon &agrave; respecter les
	limitations de la norme ISO 9660, et rejettera les fichiers ayant
	des noms non acceptables pour un système de fichiers
	ISO.</para>

      <indexterm>
        <primary>systèmes de fichiers</primary>
        <secondary>HFS</secondary>
      </indexterm>
      <indexterm>
        <primary>systèmes de fichiers</primary>
        <secondary>Joliet</secondary>
      </indexterm>
      <para>De nombreuses options sont disponibles pour passer
	outre ces restrictions.  En particulier, <option>-R</option>
	qui autorise les extensions Rock Ridge communes aux systèmes
	&unix;, <option>-J</option> qui active les extensions Joliet
	utilisées par les systèmes Microsoft, et
	<option>-hfs</option> peut être utilisé pour créer
	des systèmes de fichiers HFS utilisés par &macos;.</para>

      <para>Pour des CDs qui sont destinés &agrave; n'être
	utilisé que sur des systèmes &os;, l'option
	<option>-U</option> peut être utilisée pour
	désactiver toutes les restrictions au niveau des noms de
	fichiers.  Quand elle est utilisée avec l'option
	<option>-R</option>, cela produit une image de système de
	fichiers qui est identique &agrave; l'arborescence &os; d'origine,
	cependant ce système de fichiers pourra violer la norme ISO
	9660 de nombreuses façon.</para>

      <indexterm>
        <primary>CDROMs</primary>
        <secondary>création d'un CDROM bootable</secondary>
      </indexterm>
      <para>La dernière option d'usage général est l'option
	<option>-b</option>.  Elle est utilisée pour indiquer
	l'emplacement de l'image de démarrage &agrave; utiliser dans
	la création d'un CD démarrable <quote>El Torito</quote>.
	Cette option prend en argument le chemin vers une image
	de démarrage &agrave; partir de la racine de l'arborescence
	qui va être copiée sur le CD.  Par défaut,
	&man.mkisofs.8; créé une image ISO dans un mode
	appelé <quote>émulation de disquette</quote>, et
	s'attend donc &agrave; une image de démarrage de 1200,
	1440 ou 2880&nbsp;Ko en taille.  Certains chargeurs, comme
	celui utilisé par les disques d'installation de &os;,
	n'utilisent pas ce mode d'émulation, dans ce cas
	l'option <option>-no-emul-boot</option> devrait être
	utilisée.  Aussi, si
	<filename>/tmp/monboot</filename> contient un système &os;
	avec une image de démarrage dans
	<filename>/tmp/monboot/boot/cdboot</filename>, vous pourrez
	produire l'image d'un système de fichiers ISO 9660 dans
	<filename>/tmp/bootable.iso</filename> de cette façon:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/monboot</userinput></screen>

      <para>Cela étant fait, si vous avez le pilote
	<filename>md</filename> configuré
	dans votre noyau, vous pouvez monter le système de fichiers
	avec:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>A ce moment vous pouvez vérifier que
	<filename>/mnt</filename> et <filename>/tmp/monboot</filename>
	sont identique.</para>

      <para>Il existe de nombreuses autres options que vous pouvez
	utiliser avec &man.mkisofs.8;
	pour régler finement son comportement.  En particulier: les
	modifications d'une organisation ISO 9660 et la création de
	disques Joliet et HFS.  Voir la page de manuel &man.mkisofs.8;
	pour plus de détails.</para>
    </sect2>

    <sect2 xml:id="burncd">
      <title>burncd</title>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>gravure</secondary>
      </indexterm>
      <para>Si vous disposez d'un graveur de CD ATAPI, vous pouvez
	utiliser la commande <command>burncd</command> pour graver
	une image ISO sur un CD.  <command>burncd</command> fait
	partie du système de base, installé sous
	<filename>/usr/sbin/burncd</filename>.  Son utilisation est
	très simple, car il dispose de peu d'options:</para>

      <screen>&prompt.root; <userinput>burncd -f cddevice data fichierimage.iso fixate</userinput></screen>

      <para>Gravera une copie de
	<replaceable>fichierimage.iso</replaceable> sur
	<replaceable>cddevice</replaceable>.  Le périphérique par
	défaut est <filename>/dev/acd0</filename>.  Consultez
	&man.burncd.8; pour les options pour fixer la vitesse
	d'écriture, éjecter le CD après gravure, et graver
	des données audios.</para>
    </sect2>

    <sect2 xml:id="cdrecord">
      <title>cdrecord</title>

      <para>Si vous n'avez pas de graveur de CD ATAPI, vous devrez
	utiliser <command>cdrecord</command> pour graver vos CDs.
	<command>cdrecord</command> ne fait pas partie du système de
	base; vous devez l'installer soit &agrave; partir du logiciel
	porté <package>sysutils/cdrtools</package>
	ou de la version pré-compilée appropriée.
	Des modifications du système de base peuvent provoquer
	le dysfonctionnement des versions binaires de ce programme,
	et donner lieu &agrave; une production de &ldquo;dessous de
	bouteille&rdquo;.  Vous devrez par conséquent soit
	mettre &agrave; jour le logiciel porté quand vous mettez
	&agrave; jour votre système, soit si vous <link linkend="stable">suivez la branche -STABLE</link>, mettre
	&agrave; jour le logiciel porté lorsqu'une nouvelle
	version est disponible.</para>

      <para>Bien que <command>cdrecord</command> dispose de
	nombreuses options, l'usage de base est même plus simple
	qu'avec <command>burncd</command>.  La gravure d'une image
	ISO 9660 se fait avec:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=device fichierimage.iso</userinput></screen>

      <para>La partie délicate dans l'utilisation de
	<command>cdrecord</command> est la recherche de la valeur &agrave;
	utiliser pour l'option <option>dev</option>.  Pour déterminer
	le bon paramètre &agrave; utiliser, utilisez l'indicateur
	<option>-scanbus</option> de <command>cdrecord</command>,
	qui produira des résultats du type:</para>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>gravure</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord-Clone 2.01 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Cela donne la valeur <option>dev</option> appropriée
	pour les périphériques listés.
	Recherchez votre graveur de
	CD dans la liste, et utilisez les trois chiffres séparés
	par une virgule comme valeur pour <option>dev</option>.
	Dans notre cas le périphérique de gravure est 1,5,0, donc
	l'entrée appropriée serait <option>dev=1,5,0</option>.
	Il existe des manières plus simple de spécifier
	cette valeur, consultez la page de manuel &man.cdrecord.1;
	pour des détails.
	C'est également la documentation &agrave;
	consulter pour des informations sur la gravure de pistes
	audios, le contrôle de la vitesse, et d'autres
	choses.</para>
    </sect2>

    <sect2 xml:id="duplicating-audiocds">
      <title>Dupliquer des CDs Audio</title>

      <para>Vous pouvez dupliquer un CD audio en effectuant
	l'extraction des données audio du CD vers un ensemble de
	fichiers, puis graver ces fichiers sur un CD vierge.  Le
	processus est légèrement différent entre
	lecteurs ATAPI et SCSI.</para>

      <procedure>
	<title>Lecteurs SCSI</title>

	<step>
	  <para>Utiliser <command>cdda2wav</command> pour effectuer
	  l'extraction audio.</para>

	  <screen>&prompt.user; <userinput>cdda2wav -v255 -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Utiliser <command>cdrecord</command> pour graver les
	  fichiers <filename>.wav</filename>.</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=2,0 -dao -useinfo  *.wav</userinput></screen>

	  <para>Assurez-vous que <replaceable>2,0</replaceable> est
	    choisi correctement, comme décrit dans
	    <xref linkend="cdrecord"/>.</para>
	</step>
      </procedure>

      <procedure>
	<title>Lecteurs ATAPI</title>

	<step>
	  <para>Le pilote CD ATAPI rend disponible chaque piste
	    sous la forme
	    <filename>/dev/acddtnn</filename>,
	    où <replaceable>d</replaceable> est le numéro de
	    lecteur, et <replaceable>nn</replaceable> est le numéro
	    de la piste écrit sur deux digits décimaux.
	    Donc la première piste sur le premier
	    lecteur est <filename>/dev/acd0t01</filename>, la
	    seconde est <filename>/dev/acd0t02</filename>, la
	    troisième <filename>/dev/acd0t03</filename>, et
	    ainsi de suite.</para>

	  <para>Assurez-vous que les fichiers appropriés existent
	    sous <filename>/dev</filename>.  Si ces entrées
	    sont absentes, forcez le système &agrave; lire le
	    disque &agrave; nouveau:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=/dev/null count=1</userinput></screen>
	</step>

	<step>
	  <para>Extraire chaque piste en utilisant &man.dd.1;.
	    Vous devez également préciser une taille de
	    bloc durant l'extraction des fichiers.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=piste1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=piste2.cdr bs=2352</userinput>
...
</screen>
	</step>

	<step>
	  <para>Graver les fichiers récupérés en utilisant
	    <command>burncd</command>.  Vous devez spécifier que ce
	    sont des fichiers audio, et que <command>burncd</command>
	    devra fermer le disque une fois terminé.</para>

	  <screen>&prompt.root; <userinput>burncd -f /dev/acd0 audio piste1.cdr piste2.cdr ... fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="imaging-cd">
      <title>Dupliquer des CDs de données</title>

      <para>vous pouvez copier un CD de données vers un
	fichier image équivalent au fichier créé avec
	&man.mkisofs.8;, et
	vous pouvez l'utiliser pour dupliquer n'importe quel CD de
	données.  L'exemple présenté ici suppose
	que votre lecteur de CDROM est les périphérique
	<filename>acd0</filename>.  Remplacez-le avec le
	périphérique correct.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=fichier.iso bs=2048</userinput></screen>

      <para>Vous disposez maintenant d'une image, vous pouvez la
	graver comme décrit plus haut.</para>
    </sect2>

    <sect2 xml:id="mounting-cd">
      <title>Utiliser des CDs de données</title>

      <para>Maintenant que vous avez créé une CDROM de
	données standard, vous voulez probablement le monter et lire
	les données présentes.  Par défaut,
	&man.mount.8; suppose que le système de fichier &agrave;
	monter est de type <literal>UFS</literal>.  Si vous essayez
	quelque chose comme:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>vous obtiendrez une erreur du type <errorname>Incorrect
	super block</errorname>, et pas de montage.  Le CDROM n'est
	pas un système de fichiers de type <literal>UFS</literal>,
	aussi toute tentative de montage de ce type échouera.
	Vous devez juste préciser &agrave; &man.mount.8; que le
	système de fichiers est du type <literal>ISO9660</literal>, et
	tout fonctionnera.  Cela se fait en spécifiant l'option
	<option>-t cd9660</option> option &agrave; &man.mount.8;.
	Par exemple, si vous désirez monter un CDROM, contenu
	dans le lecteur <filename>/dev/cd0</filename>, sous
	<filename>/mnt</filename>, vous devrez exécuter:</para>

          <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Notez que votre nom de lecteur
	(<filename>/dev/cd0</filename> dans cet exemple) pourra
	être différent, en fonction de l'interface
	utilisée par votre lecteur de CDROM.  De plus l'option
	<option>-t cd9660</option> ne fait qu'exécuter la commande
	&man.mount.cd9660.8;.  L'exemple précédent pourrait
	être réduit &agrave;:</para>

<screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Vous pouvez généralement utiliser
	des CDROMs de données de n'importe quelle provenance de
	cette façon.  Les disques avec certaines extensions
	ISO 9660 pourront se comporter de façon étrange,
	cependant.  Par exemple, les disques Joliet conservent
	tous les noms de fichiers en utilisant des caractères
	Unicodes sur 2 octets.  Le noyau &os; ne comprend pas
	l'Unicode, mais le pilote CD9660 de &os; est en mesure de
	convertir au vol les caractères Unicode.  Si des
	caractères non-anglais apparaissent sous la forme de
	points d'interrogation, vous devrez préciser la table
	de caractères locale que vous utilisez avec l'option
	<option>-C</option>.  Pour plus d'information, consultez la
	page de manuel &man.mount.cd9660.8;.</para>

      <note>
	<para>Pour pouvoir effectuer cette conversion de
	  caractères &agrave; l'aide de l'option
	  <option>-C</option>, le module
	  <filename>cd9660_iconv.ko</filename> devra être
	  chargé.  Cela peut être fait soit en ajoutant
	  au fichier <filename>loader.conf</filename> la ligne:</para>

	<programlisting>cd9660_iconv_load="YES"</programlisting>

	<para>puis en redémarrant la machine, soit en chargeant
	  directement le module avec &man.kldload.8;.</para>
      </note>

      <para>Occasionnellement, vous pourrez obtenir le message
	<errorname>Device not configured</errorname>
	(périphérique non configuré)
	lors d'une tentative de montage
	d'un CDROM.  Cela veut généralement dire que le
	lecteur de CDROM pense qu'il n'y a pas de disque dans le
	lecteur, ou que le lecteur n'est pas visible sur le bus.
	Cela peut demander plusieurs secondes &agrave; un lecteur de
	CDROM de s'apercevoir qu'il a été chargé,
	soyez donc patient.</para>

      <para>Parfois, un lecteur de CDROM SCSI peut être manquant
	parce qu'il n'a pas eu suffisamment de temps pour répondre
	&agrave; la réinitialisation du bus.  Si vous avez un lecteur
	de CDROM SCSI, veuillez ajouter l'option suivante &agrave;
	la configuration de votre noyau et <link linkend="kernelconfig-building">recompiler votre
	noyau</link>.</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Ceci demande &agrave; votre bus SCSI une pause de 15 seconds
	au démarrage, pour donner &agrave; votre lecteur de CDROM une chance
	de répondre la réinitialisation du bus.</para>
    </sect2>

    <sect2 xml:id="rawdata-cd">
      <title>Graver des CDs de données brutes</title>

      <para>Il est possible de graver directement un fichier sur CD,
	sans créer de système de fichiers ISO 9660.
	Certaines personnes le font dans le cas de sauvegardes.
	Cela est beaucoup plus rapide que de graver un CD
	standard:</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>Afin de récupérer les données gravées
	sur un tel CD, vous devez lire les données &agrave;
	partir du fichier spécial de périphériques
	en mode caractère:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>Vous ne pouvez monter ce disque comme vous le feriez avec
	un CDROM classique.  Un tel CDROM ne pourra être lu
	sous un autre système d'exploitation en dehors de &os;.
	Si vous voulez être en mesure de monter le CD, ou
	d'en partager les données avec un autre système
	d'exploitation, vous devez utiliser
	&man.mkisofs.8; comme
	décrit plus haut.</para>
    </sect2>

    <sect2 xml:id="atapicam">
      <info><title>Utilisation du pilote de périphérique
	ATAPI/CAM</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Contribution de </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>graveur de CD</primary>
	<secondary>pilote ATAPI/CAM</secondary>
      </indexterm>

      <para>Ce pilote permet d'accéder aux périphériques
	ATAPI (lecteurs de CD-ROM, graveurs CD-RW, lecteur de DVD etc...)
	par l'intermédiaire du sous-système SCSI, et
	autorise l'utilisation d'applications comme <package>sysutils/cdrdao</package> ou
	&man.cdrecord.1;.</para>

      <para>Pour utiliser ce pilote, vous devrez ajouter la ligne
	suivante au fichier
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>atapicam_load="YES"</programlisting>

      <para>puis redémarrez votre machine.</para>

      <note>
	<para>Si vous préférez compiler en statique dans le noyau
	  le support &man.atapicam.4;, vous devrez ajouter au fichier
	  de configuration du noyau la ligne:</para>

      <programlisting>device atapicam</programlisting>

      <para>Vous avez également besoin des lignes suivantes dans
	votre fichier de configuration:</para>

      <programlisting>device ata
device scbus
device cd
device pass</programlisting>

      <para>qui devraient être déj&agrave;
	présentes.  Puis recompilez, installez votre nouveau
	noyau, et enfin redémarrez votre machine.</para>
      </note>

      <para>Lors du démarrage, votre
	graveur devrait apparaître, comme suit:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>Le lecteur doit être accessible via le nom de
	périphérique <filename>/dev/cd0</filename>,
	par exemple pour monter un CD-ROM sous
	<filename>/mnt</filename>, tapez juste ce qui suit:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>En tant que <systemitem class="username">root</systemitem>, vous pouvez
	exécuter la commande suivante pour obtenir l'adresse SCSI du
	graveur:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>Donc <literal>1,0,0</literal> sera l'adresse SCSI &agrave;
	utiliser avec &man.cdrecord.1; et tout autre application
	SCSI.</para>

      <para>Pour plus d'information concernant ATAPI/CAM et le
	système SCSI, consultez les pages de manuel
	&man.atapicam.4; et &man.cam.4;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-dvds">
    <info><title>Création et utilisation de supports optiques
      (DVDs)</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Andy</firstname><surname>Polyakov</surname></personname><contrib>Avec l'aide de </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>DVD</primary>
      <secondary>gravure</secondary>
    </indexterm>

    <sect2>
      <title>Introduction</title>

      <para>Comparé au CD, le DVD est la
	génération technologique suivante de support
	optique de stockage de données.  Un DVD peut contenir
	plus de données qu'un CD et est de nos jour le standard
	pour la publication de vidéos.</para>

      <para>Cinq formats physiques enregistrables peuvent être
	définis pour ce que nous appellerons un DVD
	enregistrable:</para>

      <itemizedlist>
	<listitem>
	  <para>DVD-R: Ce fut le premier format DVD enregistrable
	    disponible.  La norme DVD-R est définie par le
	    <link xlink:href="http://www.dvdforum.com/forum.shtml">Forum
	    DVD</link>.  Ce format n'est pas
	    réinscriptible.</para>
	</listitem>

	<listitem>
	  <para>DVD-RW: C'est la version réinscriptible du
	    standard DVD-R.  Un DVD-RW peut supporter environ 1000
	    réécritures.</para>
	</listitem>

	<listitem>
	  <para>DVD-RAM: C'est également un format
	    réinscriptible supporté par le Forum DVD.
	    Un DVD-RAM peut être vu comme un disque dur
	    extractible.  Cependant, ce support n'est pas compatible
	    avec la plupart des lecteurs DVD-ROM et DVD-Vidéo;
	    seuls quelques graveurs de DVDs supportent le
	    DVD-RAM.  Consultez la <xref linkend="creating-dvd-ram"/>
	    pour plus d'information sur l'utilisation d'un
	    DVD-RAM.</para>
	</listitem>

	<listitem>
	  <para>DVD+RW: C'est un format réinscriptible
	    défini par l' <link xlink:href="http://www.dvdrw.com/">Alliance DVD+RW</link>.  Un
	    DVD+RW supporte environ 1000
	    réécritures.</para>
	</listitem>

	<listitem>
	  <para>DVD+R: Ce format est la version
	    non-réinscriptible du format DVD+RW.</para>
	</listitem>
      </itemizedlist>

      <para>Un DVD enregistrable simple couche peut contenir
	jusqu'&agrave; 4&nbsp;700&nbsp;000&nbsp;000&nbsp;octets ce qui
	équivaut en fait &agrave; 4.38&nbsp;Go ou 4485&nbsp;Mo
	(1 kilo-octet représente 1024 octets).</para>

      <note>
	<para>Une différence doit être faite entre un
	  support physique et son application.  Par exemple un
	  DVD-Vidéo est une organisation de fichiers
	  particulière qui peut être écrite sur n'importe
	  quel type de DVD enregistrable: DVD-R, DVD+R, DVD-RW etc.
	  Avant de choisir le type de support, vous devez vous assurer
	  que le graveur et le lecteur de DVD-Vidéo (lecteur de
	  salon ou un lecteur de DVD-ROM sur un micro-ordinateur) sont
	  compatibles avec le support.</para></note>
    </sect2>

    <sect2>
      <title>Configuration</title>

      <para>Le programme &man.growisofs.1; sera utilisé pour
	effectuer la gravure des DVDs.  Cette commande fait partie des
	utilitaires <application>dvd+rw-tools</application> (<package>sysutils/dvd+rw-tools</package>).  Les outils
	<application>dvd+rw-tools</application> supportent l'ensemble
	des supports DVD.</para>

      <para>Ces utilitaires utilisent le sous-système SCSI pour
	accéder aux périphériques, par
	conséquent le <link linkend="atapicam">support
	ATAPI/CAM</link> doit être ajouté &agrave; votre
	noyau.  Si votre graveur utilise l'interface USB, cet ajout
	est inutile et vous devriez lire la <xref linkend="usb-disks"/>
	sur la configuration de périphériques
	USB.</para>

      <para>Vous devez également activer l'accès aux
	périphériques ATAPI par DMA, cela peut
	être fait en ajoutant la ligne suivante au fichier
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Avant de tenter d'utiliser les utilitaires
	<application>dvd+rw-tools</application> vous devriez consulter
	les <link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">notes
	de compatibilité matérielle des
	dvd+rw-tools</link> pour des informations concernant votre
	graveur de DVDs.</para>

      <note>
	<para>Si vous désirez une interface graphique, vous
	  devriez jeter un oeil &agrave; <application>K3b</application>
	  (<package>sysutils/k3b</package>) qui offre
	  une interface conviviale &agrave; &man.growisofs.1; et
	  &agrave; d'autres outils de gravure.</para>
      </note>
    </sect2>

    <sect2>
      <title>Graver des DVDs de données</title>

      <para>La commande &man.growisofs.1; est une interface &agrave;
	<link linkend="mkisofs">mkisofs</link>, elle invoquera
	&man.mkisofs.8; pour la création du système de
	fichiers et effectuera la gravure des données sur le
	DVD.  Cela signifie que vous n'avez pas besoin de créer
	une image des données avant le processus de
	gravure.</para>

      <para>Pour écrire les données du répertoire
	<filename>/path/to/data</filename>, utilisez
	la commande suivante:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</userinput></screen>

      <para>Les options <option>-J -R</option> sont passées
	&agrave; &man.mkisofs.8; pour la création du
	système de fichiers (dans le cas présent: un
	système de fichiers ISO 9660 avec les extensions Joliet
	et Rock Ridge), consultez la page de manuel de &man.mkisofs.8;
	pour plus de détails.</para>

      <para>L'option <option>-Z</option> est utilisée pour la
	session d'écriture initiale dans tous les cas:
	multi-sessions ou pas.  Le périphérique
	correspondant au graveur, <replaceable>/dev/cd0</replaceable>,
	doit être adapté en fonction de votre
	configuration.  Le paramètre
	<option>-dvd-compat</option> provoquera la fermeture du
	disque, rien ne pourra être écrit &agrave; la
	suite de l'enregistrement.  En retour cela devrait donner lieu &agrave;
	une plus grande compatibilité avec les lecteurs de
	DVD-ROMs.</para>

      <para>Il est également possible de graver une image de
	système de fichiers, par exemple pour graver l'image
	<replaceable>imagefile.iso</replaceable>, nous
	lancerons:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</userinput></screen>

      <para>La vitesse d'écriture devrait être
	détectée et positionnée automatiquement
	en fonction du support et du graveur utilisé.  Si vous
	voulez forcer la vitesse de gravure, utilisez le
	paramètre <option>-speed=</option>.  Pour plus
	d'informations, lisez la page de manuel de
	&man.growisofs.1;.</para>
    </sect2>

    <sect2>
      <title>Graver un DVD-Vidéo</title>

      <indexterm>
        <primary>DVD</primary>
        <secondary>DVD-Video</secondary>
      </indexterm>

      <para>Un DVD-Vidéo est un système de fichiers
	particulier basé sur les spécifications IS0 9660
	et micro-UDF (M-UDF).  Le DVD-Vidéo présente
	également une arborescence de données
	spécifique, c'est la raison pour laquelle vous devez
	utiliser un programme particulier tel que <package>multimedia/dvdauthor</package> pour créer
	le DVD.</para>

      <para>Si vous disposez déj&agrave; d'une image du
	système de fichiers du DVD-Vidéo, gravez-la de
	la même façon que pour une autre image,
	reportez-vous aux sections précédentes pour un
	exemple.  Si vous avez réalisé vous-même
	l'arborescence du DVD et que le résultat est dans, par
	exemple, le répertoire <filename>/path/to/video</filename>, la commande
	suivante devrait être utilisée pour graver le
	DVD-Vidéo:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -dvd-video /path/to/video</userinput></screen>

      <para>L'option <option>-dvd-video</option> sera passée
	&agrave; &man.mkisofs.8; et lui demandera de créer un
	système de fichiers de DVD-Vidéo.  De plus,
	l'option <option>-dvd-video</option> implique l'option
	<option>-dvd-compat</option> de &man.growisofs.1;.</para>
    </sect2>

    <sect2>
      <title>Utiliser un DVD+RW</title>

      <indexterm>
        <primary>DVD</primary>
        <secondary>DVD+RW</secondary>
      </indexterm>

      <para>Contrairement &agrave; un CD-RW, un DVD+RW vierge doit
	être formaté avant la première
	utilisation.  Le programme &man.growisofs.1; s'en chargera
	automatiquement quand cela sera nécessaire, ce qui est la
	méthode <emphasis>recommandée</emphasis>.  Cependant vous
	pouvez utiliser la commande <command>dvd+rw-format</command>
	pour formater le DVD+RW:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Vous devez effectuer cette opération qu'une seule
	fois, gardez &agrave; l'esprit que seuls des DVD+RW vierges
	doivent être formatés.  Ensuite vous pouvez
	graver le DVD+RW de la manière vue dans les sections
	précédentes.</para>

      <para>Si vous voulez graver de nouvelles données (graver
	un système de fichiers totalement nouveau et pas juste
	ajouter des données) sur un DVD+RW, vous n'avez pas
	besoin de l'effacer, vous avez juste &agrave;
	récrire sur l'enregistrement
	précédent (en effectuant une nouvelle session
	initiale), comme ceci:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /path/to/newdata</userinput></screen>

      <para>Le format DVD+RW offre la possibilité d'ajouter
	facilement des données &agrave; un enregistrement
	précédent.  L'opération consiste &agrave;
	fusionner une nouvelle session avec la session existante, ceci
	n'est pas une gravure multisession, &man.growisofs.1;
	<emphasis>augmentera</emphasis> le système de fichiers
	ISO 9660 présent sur le disque.</para>

      <para>Par exemple, si nous voulons ajouter des données
	&agrave; notre DVD+RW précédent, nous devons
	utiliser cela:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /path/to/nextdata</userinput></screen>

      <para>Les mêmes options de &man.mkisofs.8;
	utilisées lors de la gravure de la session initiale
	doivent être &agrave; nouveau utilisées lors des
	écritures ultérieures.</para>

      <note>
	<para>Vous pouvez ajouter l'option
	  <option>-dvd-compat</option> si vous désirez une
	  meilleure compatibilité avec les lecteurs de DVD-ROM.
	  Dans le cas d'un DVD+RW cela ne vous empêchera pas de
	  rajouter des données par la suite.</para>
      </note>

      <para>Si pour une quelconque raison vous voulez vraiment
	effacer le disque, faites ce qui suit:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0=/dev/zero</userinput></screen>
    </sect2>

    <sect2>
      <title>Utiliser un DVD-RW</title>

      <indexterm>
        <primary>DVD</primary>
        <secondary>DVD-RW</secondary>
      </indexterm>

      <para>Un DVD-RW accepte deux formats de disque: le format
	séquentiel incrémental et le format
	&ldquo;restricted overwrite&rdquo;.  Par défaut les
	disques DVD-RW sont fournis sous le format
	séquentiel.</para>

      <para>Un DVD-RW vierge peut être directement gravé
	sans le besoin d'une opération de formatage
	préalable, cependant un DVD-RW non-vierge au format
	séquentiel doit être effacé avant de
	pouvoir y écrire une nouvelle session initiale.</para>

      <para>Pour effacer un DVD-RW en mode séquentiel,
	exécutez:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>

      <note>
	<para>Une opération d'effacement complète
	  (<option>-blank=full</option>) prendra environ une heure avec
	  un support 1x.  Un effacement rapide peut être
	  effectué en utilisant l'option <option>-blank</option>
	  si le DVD-RW est destiné &agrave; être
	  enregistré suivant le mode d'écriture
	  Disk-At-Once (DAO).  Pour écrire le DVD-RW suivant le
	  mode DAO, utilisez la commande:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</userinput></screen>

	<para>L'option <option>-use-the-force-luke=dao</option> ne
	  devrait pas être nécessaire puisque
	  &man.growisofs.1; tente de détecter les supports
	  effacés rapidement et engage une écriture
	  DAO.</para>

	<para>En fait le mode &ldquo;restricted overwrite&rdquo;
	  devrait être utilisé avec tout DVD-RW, ce
	  format est plus flexible que le format séquentiel
	  incrémental par défaut.</para>
      </note>

      <para>Pour écrire des données sur un DVD-RW en
	mode séquentiel, utilisez les mêmes instructions
	que pour tout autre format de DVD:</para>

      <screen>&prompt.root; <userinput>growisofs -Z /dev/cd0 -J -R /path/to/data</userinput></screen>

      <para>Si vous voulez ajouter des données &agrave; votre
	enregistrement précédent, vous devrez utiliser
	la commande <option>-M</option> de &man.growisofs.1;.
	Cependant, si vous effectuez un ajout de données sur un
	DVD-RW en mode séquentiel, une nouvelle session sera
	créée sur le disque avec pour résultat de
	donner naissance &agrave; un disque multi-sessions.</para>

      <para>Un DVD-RW dans le format &ldquo;restricted
	overwrite&rdquo; n'a pas besoin d'être effacé
	avant une nouvelle session initiale, vous avez juste &agrave;
	récrire sur le disque avec l'option
	<option>-Z</option>, ceci est similaire &agrave; un DVD+RW.
	Il est également possible d'augmenter un système
	de fichiers ISO 9660 existant écrit sur le disque de la
	même manière que pour un DVD+RW en utilisant
	l'option <option>-M</option>.  Le résultat sera un DVD
	avec une seule session.</para>

      <para>Pour faire passer un DVD-RW dans le format
	&ldquo;restricted overwrite&rdquo;, la commande suivante doit
	être utilisée:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format /dev/cd0</userinput></screen>

      <para>Pour revenir au format séquentiel, utilisez:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full /dev/cd0</userinput></screen>
    </sect2>

    <sect2>
      <title>Multi-sessions</title>

      <para>Très peu de lecteurs de DVD-ROMs
	supportent les DVDs multi-sessions, ils ne
	liront, dans le meilleur des cas, que la première
	session.  Les DVD+R, DVD-R et DVD-RW en mode séquentiel
	peuvent accepter de multiples sessions, la notion de multiples
	sessions n'existe pas pour les formats DVD+RW et DVD-RW en
	mode &ldquo;restricted overwrite&rdquo;.</para>

      <para>Utiliser la commande suivante après une session
	initiale (non fermée) sur un DVD+R, DVD-R, ou DVD-RW en
	mode séquentiel, ajoutera une nouvelle session sur le
	disque:</para>

      <screen>&prompt.root; <userinput>growisofs -M /dev/cd0 -J -R /path/to/nextdata</userinput></screen>

      <para>L'utilisation de cette ligne de commande avec un DVD+RW ou
	un DVD-RW en mode &ldquo;restricted overwrite&rdquo; aura pour
	effet d'ajouter les données en fusionnant la nouvelle session
	avec celle déj&agrave; présente.  Le résultat sera un disque
	mono-session.  C'est la méthode utilisée pour ajouter des
	données sur ces médias après une écriture initiale.</para>

      <note>
	<para>De l'espace sur le médium est utilisé
	  entre chaque session pour la fin et le début des
	  sessions.  Par conséquent, tout ajout de données
	  devrait se faire suivant une quantité importante de
	  données pour optimiser l'espace sur le disque.  Le
	  nombre de sessions est limité &agrave; 154 pour un
	  DVD+R, environ 2000 pour un DVD-R, et 127 pour un DVD+R
	  double couche.</para>
      </note>
    </sect2>

    <sect2>
      <title>Pour plus d'informations</title>

      <para>Pour obtenir plus d'informations sur un DVD, la commande
	<command>dvd+rw-mediainfo
	/dev/cd0</command> peut être
	exécutée avec le disque dans le lecteur.</para>

      <para>Plus d'informations sur les utilitaires
	<application>dvd+rw-tools</application> peuvent être
	trouvées dans la page de manuel de &man.growisofs.1;,
	sur le <link xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/">site Web de
	dvd+rw-tools</link> et dans les archives de la <link xlink:href="http://lists.debian.org/cdwrite/">liste de diffusion
	cdwrite</link>.</para>

      <note>
	<para>La sortie de la commande
	  <command>dvd+rw-mediainfo</command> sur le résultat
	  de la gravure ou le disque posant problème est
	  obligatoire avec tout rapport de problème.  Sans
	  cette sortie, il sera quasiment impossible de vous
	  aider.</para>
      </note>
    </sect2>

    <sect2 xml:id="creating-dvd-ram">
      <title>Utiliser un disque DVD-RAM</title>
      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RAM</secondary>
      </indexterm>

      <sect3>
	<title>Configuration</title>

	<para>Les graveurs de DVD-RAM sont fournis soit avec une
	  interface SCSI soit une interface ATAPI.  Dans le cas des
	  périphériques ATAPI, l'accès DMA doit
	  être activé, cela peut être fait en
	  ajoutant la ligne suivante au fichier
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>hw.ata.atapi_dma="1"</programlisting>
      </sect3>

      <sect3>
	<title>Préparer le disque</title>

	<para>Comme précisé dans l'introduction de cette
	  section, un DVD-RAM peut être vu comme un disque dur
	  extractible.  Comme tout autre disque dur le DVD-RAM doit
	  être <quote>préparé</quote> avant la
	  première utilisation.  Dans l'exemple,
	  l'intégralité de l'espace sur le disque sera
	  utilisé par un système de fichiers UFS2
	  standard:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/acd0 count=2</userinput>
&prompt.root; <userinput>bsdlabel -Bw acd0</userinput>
&prompt.root; <userinput>newfs /dev/acd0</userinput></screen>

	<para>Le périphérique DVD
	  <filename>acd0</filename> doit être modifié
	  en fonction de la configuration.</para>
      </sect3>

      <sect3>
	<title>Utiliser le disque</title>

	<para>Une fois les opérations précédentes
	  effectuées sur le DVD-RAM, il peut être
	  monté comme un disque dur classique:</para>

	<screen>&prompt.root; <userinput>mount /dev/acd0 /mnt</userinput></screen>

	<para>Après cela, on pourra lire et écrire sur
	  le DVD-RAM.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="floppies">
    <info><title>Création et utilisation de disquettes</title>
      <authorgroup>
	<author><personname><firstname>Julio</firstname><surname>Merino</surname></personname><contrib>Travail original de </contrib></author>
      </authorgroup>
      
      <authorgroup>
	<author><personname><firstname>Martin</firstname><surname>Karlsson</surname></personname><contrib>Réécrit par </contrib></author>
      </authorgroup>
      
    </info>

    

    <para>Sauvegarder des données sur disquette est
      parfois utile, par exemple quand on a pas d'autre
      support de stockage amovible de disponible ou quand on
      doit transférer de petites quantités de
      données sur un autre ordinateur.</para>

    <para>Cette section expliquera comment utiliser des disquettes
      sous &os;.  Elle couvrira principalement le formatage et
      l'utilisation de disquettes DOS de 3.5pouces, mais les
      concepts exposés sont identiques pour d'autres formats
      de disquettes.</para>

    <sect2>
      <title>Formater des disquettes</title>

      <sect3>
	<title>Le périphérique</title>

	<para>On accède aux disquettes par l'intermédiaire
	  d'entrées dans <filename>/dev</filename>, comme
	  pour tout autre périphérique.  Pour
	  accéder directement &agrave; la disquette, utilisez
	  simplement
	  <filename>/dev/fdN</filename>.</para>
      </sect3>

      <sect3>
	<title>Le formatage</title>

	<para>Une disquette doit subir un formatage bas niveau avant
	  d'être utilisable.  Il est généralement
	  réalisé par le constructeur, mais le formatage est
	  une bonne manière de contrôler
	  l'intégrité du support.  Bien qu'il soit possible de
	  forcer une plus grande (ou plus petite) capacité,
	  1440Ko est celle pour laquelle sont conçues la plupart
	  des disquettes.</para>

	<para>Pour effectuer un formatage bas niveau d'une disquette
	  vous devez utiliser &man.fdformat.1;.  L'utilitaire
	  attend le nom du périphérique en argument.</para>

	<para>Notez tout message d'erreur, sachant que cela peut aider
	  &agrave; déterminer si la disquette est bonne ou
	  défectueuse.</para>

	<sect4>
	  <title>Formatage des disquettes</title>

	    <para>Utilisez un des périphériques
	    <filename>/dev/fdN.size</filename>,
	    pour formater la disquette.  Insérez une disquette
	    3.5pouces dans votre lecteur et tapez:</para>

	    <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Le label de disque</title>

      <para>Après le formatage bas niveau du disque, vous
	devrez y placer un label de disque.  Ce label sera
	détruit plus tard, mais il est nécessaire au
	système pour déterminer par la suite la taille
	et la géométrie du disque.</para>

      <para>Le nouveau label de disque prendra l'intégralité
	du disque, et contiendra l'information correcte sur la
	géométrie de la disquette.
	Les différentes géométries possibles pour le label
	sont listées dans
	<filename>/etc/disktab</filename>.</para>

      <para>Vous pouvez maintenant exécuter &man.bsdlabel.8;
        de la façon suivante:</para>

      <screen>&prompt.root; <userinput>/sbin/bsdlabel -B -w /dev/fd0 fd1440</userinput></screen>
    </sect2>

    <sect2>
      <title>Le système de fichiers</title>

      <para>La disquette est maintenant fin prête pour un
	formatage haut niveau.  Cette opération placera un nouveau
	système de fichiers sur la disquette, qui permettra
	&agrave; &os; d'écrire et de lire sur le disque.
	Après la création du nouveau système
	de fichiers, le label disque est détruit, aussi
	si vous désirez reformater le disque, vous devrez
	recréer le label de disque &agrave; nouveau.</para>

      <para>Le système de fichiers de la disquette peut
	soit être de l'UFS soit utiliser le système FAT.
	Le système FAT est généralement un meilleur choix
	pour les disquettes.</para>

      <para>Pour placer un nouveau système de fichier sur la
	disquette faites ceci:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>La disquette est maintenant prête &agrave;
	être utilisée.</para>
    </sect2>

    <sect2>
      <title>Utilisation de la disquette</title>

      <para>Pour utiliser la disquette, montez-la avec
	&man.mount.msdosfs.8;.  On peut également utiliser
	<package>emulators/mtools</package> du
	catalogue des logiciels portés.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="backups-tapebackups">
    <title>Créer et utiliser les bandes magnétiques</title>

    <indexterm><primary>bande magnétique</primary></indexterm>
    <para>Les principaux types de bandes sont les 4mm, 8mm, QIC, les
      mini-cartouches et les DLTs.</para>

    <sect2 xml:id="backups-tapebackups-4mm">
      <title>Bandes 4mm (DDS: &ldquo;Digital Data Storage&rdquo;)</title>

      <indexterm>
	<primary>bande magnétique</primary>
	<secondary>bandes DDS (4mm)</secondary>
      </indexterm>
      <indexterm>
        <primary>bande magnétique</primary>
	<secondary>bandes QIC</secondary>
      </indexterm>
      <para>Les bandes 4mm sont en train de remplacer les bandes QIC
	comme le format usuel de sauvegarde pour les stations de
	travail.  Cette tendance s'est accélérée
	quand Conner a racheté Archive, un des leaders de la
	fabrication des lecteurs QIC, et a arrêté la
	production de ces derniers.  Les lecteurs 4mm sont petits et
	silencieux mais n'ont pas la réputation de fiabilité des
	lecteurs 8mm.  Les cartouches sont moins coûteuse et plus
	petites (3 x 2 x 0.5 pouces, 76 x 51 x 12 mm) que les
	cartouches 8mm.  Les cartouches 4mm, tout comme les 8mm, ont
	une durée de vie faible car elles utilisent un
	procédé de lecture/écriture en
	hélice.</para>

      <para>Le débit de ces lecteurs va de ~150&nbsp;Ko/s
	&agrave; ~500&nbsp;Ko/s au maximum.  Leur capacité de varie de
	1.3&nbsp;Go &agrave; 2.0&nbsp;Go.  La compression matérielle,
	disponible sur la plupart des lecteurs, double
	approximativement leur capacité.
	Les unités multi-lecteurs peuvent avoir jusqu'&agrave; 6 lecteurs
	dans une seule tour avec changement automatique de bande.  La
	capacité totale atteint 240&nbsp;Go.</para>

      <para>Le standard DDS-3 supporte maintenant des capacités de
	bande jusqu'&agrave; 12&nbsp;Go (ou 24&nbsp;Go
	compressés).</para>

      <para>Les lecteurs 4mm, comme les lecteurs 8mm, utilisent un
	procédé de lecture/écriture en hélice.  Tous
	les avantages et les inconvénients de ce procédé
	s'appliquent aux deux types de lecteurs.</para>

      <para>Les bandes doivent être changées après
	2000 utilisations ou 100 sauvegardes complètes.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-8mm">
      <title>Bandes 8mm (Exabyte)</title>
      <indexterm>
	<primary>bande magnétique</primary>
	<secondary>Bandes Exabyte (8mm)</secondary>
      </indexterm>

      <para>Les unités de bandes 8mm sont les lecteurs de bandes
	SCSI les plus courant; c'est le meilleur choix de bandes
	amovibles.  Presque chaque site dispose d'une unité Exabyte
	2&nbsp;Go 8mm.  Les lecteurs 8mm sont fiables, pratiques et
	silencieux.  Les cartouches sont bon marché et d'encombrement
	faible (4.8 x 3.3 x 0.6 pouces; 122 x 84 x 15 mm).  Un des
	inconvénients de la bande 8mm est la durée de
	vie relativement courte des bandes et des têtes de lectures
	en raison de la grande vitesse de défilement de la bande
	devant les têtes.</para>

      <para>Leur débit va de ~250&nbsp;Ko/s &agrave; ~500&nbsp;Ko/s.
	Leur capacité commence &agrave; 300&nbsp;Mo jusqu'&agrave;
	7&nbsp;Go.
	La compression matérielle, disponible sur la plupart des
	lecteurs, double approximativement la capacité.  Ces lecteurs
	sont disponibles sous forme d'unité simple ou multiple
	accueillant 6 lecteurs et 120 bandes.  Les bandes sont
	changées automatiquement par l'unité.  Ils peuvent
	gérer une capacité de stockage de plus de
	840&nbsp;Go.</para>

      <para>Le lecteur Exabyte &ldquo;Mammoth&rdquo; supporte
	12&nbsp;Go sur une seule bande (24&nbsp;Go compressé)
	et coûte approximativement le double d'un lecteur
	classique.</para>

      <para>L'enregistrement des données sur la bande utilise
	un procédé en hélice, les têtes
	sont positionnées en biais par rapport &agrave; la bande
	(environ 6 degrés).  La bande fait un angle de 270
	degrés avec le cylindre sur lequel se trouvent les têtes.
	Ce cylindre tourne en même temps que la bande défile.  Il
	en résulte donc une grande densité de données
	et des pistes très serrées qui vont de biais
	d'un bord &agrave; l'autre de la bande.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-qic">
      <title>QIC</title>
      <indexterm>
        <primary>bande magnétique</primary>
	<secondary>QIC-150</secondary>
      </indexterm>

      <para>Les bandes et les lecteurs QIC-150 sont, peut-être, le
	format le plus courant.  Les lecteurs QIC sont les moins
	chers des supports de sauvegarde &ldquo;sérieux&rdquo;.
	Leur inconvénient par contre est le coût des bandes.
	Les bandes QIC sont chères comparées aux bandes 8mm ou
	4mm, jusqu'&agrave; 5 fois le coût au Go.  Mais, si une
	demi-douzaine de bandes vous suffit, le format QIC peut
	être le bon choix.  QIC est le format le
	<emphasis>plus</emphasis> répandu.  Chaque site dispose d'un
	lecteur QIC d'une densité ou d'une autre.  C'est l&agrave;
	la difficulté, il existe de nombreuses densités pour
	des bandes physiquement semblables (parfois même identiques).
	Les lecteurs QIC ne sont pas silencieux.  Ces lecteurs se
	positionnent bruyamment avant d'enregistrer des données et
	ont les entend clairement lors de lecture, écriture ou
	recherche.  Les bandes QIC sont volumineuses: 6&nbsp;x 4&nbsp;x 0.7
	pouces (152&nbsp;x 102&nbsp;x 17 mm).</para>

      <para>Leur débit va de ~150&nbsp;Ko/s &agrave; ~500&nbsp;Ko/s.
	Leur capacité varie de 40&nbsp;Mo &agrave; 15&nbsp;Go.  La
	compression matérielle est disponible sur de nombreux lecteurs
	récents.  Les lecteurs QIC sont de moins en moins utilisés,
	ils sont supplantés par les lecteurs DAT.</para>

      <para>Les données sont enregistrées sur des pistes
	sur la bande.
	Les pistes sont parallèles &agrave; la bande et vont d'une
	extrémité &agrave; l'autre.  Le nombre de piste, et
	par conséquent la largeur des pistes, varie avec la
	capacité de la bande.  La plupart des nouveaux lecteurs
	fournissent au moins une compatibilité descendante en
	lecture (mais aussi en écriture).  Le format QIC a une
	bonne réputation de sécurité des données
	(la mécanique est plus simple et plus robuste que les lecteurs
	&agrave; système en hélice).</para>

      <para>Les bandes devraient être changée
	après 5000 sauvegardes.</para>
    </sect2>

    <sect2 xml:id="backups-tapebackups-dlt">
      <title>DLT</title>
      <indexterm>
	<primary>bande magnétique</primary>
	<secondary>DLT</secondary>
      </indexterm>

      <para>Les DLT ont le taux de transfert le plus élevé
	de tous les types de lecteurs décrits ici.  La bande
	d'1/2" (12.5mm) est contenue dans une seule cartouche
	(4 x 4 x 1 pouces; 100 x 100 x 25 mm).  La cartouche est
	munie d'une trappe basculante le long d'un côté de la
	cartouche.  Le lecteur ouvre cette trappe pour saisir l'amorce
	de la bande.  Cette amorce comporte une découpe ovale que le
	lecteur utilise pour &ldquo;crocheter&rdquo; la bande.
	La bobine d'entraînement est située dans le lecteur.
	Tous les autres types de cartouches décrits ici (les bandes 9
	pistes sont la seule exception) ont les bobines
	de stockage et d'entraînement dans la cartouche
	elle-même.</para>

      <para>Leur débit est d'environ 1.5&nbsp;Mo/s, trois fois celui
	des lecteurs 4mm, 8mm, ou QIC.  La capacité d'une bande varie
	de 10&nbsp;Go &agrave; 20&nbsp;Go pour une unité simple.  Les
	lecteurs sont disponibles en unités multi-bandes avec
	changeurs et multi-lecteurs contenant de 5 &agrave; 900 bandes et 1
	&agrave; 20 lecteurs, fournissant une capacité de stockage
	allant de 50&nbsp;Go &agrave; 9&nbsp;TO.</para>

      <para>Avec la compression, le format DLT type IV supporte
	jusqu'&agrave; une capacité de 70&nbsp;Go.</para>

      <para>Les données sont enregistrées sur la bande
	sur des pistes parallèles &agrave; la direction de
	défilement (comme
	pour les bandes QIC).  Deux pistes sont écrites
	&agrave; la fois.  La durée de vie des têtes de
	lecture/écriture est relativement longue; une fois que la
	bande s'arrête, il n'y a pas de déplacement des
	têtes par rapport &agrave; la bande.</para>
    </sect2>

    <sect2>
      <title xml:id="backups-tapebackups-ait">AIT</title>
      <indexterm>
	<primary>bande magnétique</primary>
	<secondary>AIT</secondary>
      </indexterm>

      <para>AIT est le nouveau format de Sony, il peut supporter
	jusqu'&agrave; 50&nbsp;Go par bande (avec compression).  Les bandes
	contiennent un circuit mémoire qui contient un index du
	contenu de la bande.  Cet index peut être lu rapidement par le
	lecteur pour déterminer l'emplacement de fichiers sur la
	bande, au lieu des nombreuses minutes nécessaires aux autres
	types de bande.  Des programmes comme
	<application>SAMS:Alexandria</application> peuvent
	contrôler quarante ou plus ensemble de bandes AIT,
	communiquant directement avec le circuit mémoire de la
	bande pour en afficher le contenu &agrave; l'écran,
	déterminer quels fichiers ont été
	sauvegardé sur quelle bande,
	localiser la bonne bande, la charger, et en restaurer les
	données.</para>

      <para>Les ensembles de ce type reviennent aux alentour des 20000
	dollars, les rendant inaccessibles &agrave; l'amateur
	éclairé.</para>
    </sect2>

    <sect2>
      <title>Utiliser une bande neuve pour la première fois</title>

      <para>La première fois que vous essayez de lire ou d'écrire
	sur une bande vierge, l'opération échoue.  Les messages
	affichés par la console devraient être du type:</para>

      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready</screen>

      <para>La bande ne contient pas de bloc d'identification (bloc
	numéro 0).  Tous les lecteurs QIC depuis l'adoption du
	standard QIC-525 écrivent un bloc d'identification sur la
	bande.  Il y a alors deux solutions:</para>

      <itemizedlist>
	<listitem>
	  <para><command>mt fsf 1</command> fait écrire au lecteur un
	    bloc d'identification sur la bande.</para>
	</listitem>

	<listitem>
	  <para>Utiliser le bouton en face avant pour éjecter la
	    bande.</para>

	  <para>Ré-insérer la bande et utiliser &man.dump.8; pour
	    écrire dessus.</para>

	  <para>&man.dump.8; produira l'erreur <errorname>DUMP: End of tape
	    detected</errorname> et la console affichera: <errorname>HARDWARE
	    FAILURE info:280 asc:80,96</errorname>.</para>

	  <para>Rembobiner la bande avec:
	    <command>mt rewind</command>.</para>

	  <para>Les manipulations ultérieures sur la bande
	    fonctionneront.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="backups-floppybackups">
    <title>Sauvegardes sur disquettes</title>

    <sect2 xml:id="floppies-using">
      <title>Puis-je utiliser des disquettes pour la sauvegarde
	des mes données?</title>
      <indexterm><primary>disquettes de sauvegarde</primary></indexterm>
      <indexterm><primary>disquettes</primary></indexterm>

      <para>Les disquettes ne sont pas des supports adaptés &agrave; la
	réalisation de sauvegardes étant
	donné que:</para>

      <itemizedlist>
	<listitem>
	  <para>Le support n'est pas fiable, spécialement
	    sur de longues périodes de temps.</para>
	</listitem>

	<listitem>
	  <para>Les opérations de sauvegarde et de restauration
	    sont très lentes.</para>
	</listitem>

	<listitem>
	  <para>Elles ont une capacité très
	    limitée (le jour où l'on pourra sauvegarder
	    l'intégralité d'un disque dur sur une douzaine de
	    disquette n'est pas encore arrivé).</para>
	</listitem>
      </itemizedlist>

      <para>Cependant, si vous n'avez pas d'autres méthodes
	pour sauvegarder vos données alors les disquettes
	sont mieux que pas de sauvegardes du tout.</para>

      <para>Si vous devez utiliser les disquettes, alors assurez-vous
	que vous en utiliser des disquettes de bonne qualité.
	Les disquettes qui traînent sur le bureau depuis quelques
	années sont un mauvais choix.  Idéalement utilisez de
	des disquettes neuves en provenance d'un fabricant
	renommé.</para>
    </sect2>

    <sect2 xml:id="floppies-creating">
      <title>Alors, comment je sauvegarde mes données
	sur disquettes?</title>

      <para>La meilleur façon de sauvegarder sur disquette est
	d'utiliser la commande &man.tar.1; avec l'option
	<option>-M</option> (volume multiple), qui autorise
	la répartition des sauvegardes sur plusieurs
	disquettes.</para>

      <para>Pour sauvegarder tous les fichiers du répertoire
	courant et des sous-répertoires (en tant que
	<systemitem class="username">root</systemitem>):</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>Quand la première disquette est pleine &man.tar.1;
	vous réclamera d'introduire le volume suivant (parce
	que &man.tar.1; est indépendant du support il parle en
	terme de volume; dans notre contexte cela signifie
	disquette).</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>Cette opération est répétée
	(avec incrémentation du numéro de volume)
	jusqu'&agrave; ce que les fichiers spécifiés soient
	sauvegardés.</para>
    </sect2>

    <sect2 xml:id="floppies-compress">
      <title>Puis-je sauvegarder mes sauvegardes?</title>
      <indexterm>
	<primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>compression</primary></indexterm>

      <para>Malheureusement, &man.tar.1; ne permettra pas
	l'utilisation de l'option <option>-z</option> pour
	les archives multi-volumes.  Vous pourrez, bien sûr,
	utiliser &man.gzip.1; sur tous les fichiers, les archiver
	avec &man.tar.1; sur disquettes, puis décompresser les
	fichiers avec &man.gunzip.1;!</para>
    </sect2>

    <sect2 xml:id="floppies-restoring">
      <title>Comment puis-je restaurer mes sauvegardes?</title>

      <para>Pour restaurer une archive complète utiliser:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>Vous pouvez utiliser deux manières pour restaurer
	uniquement certains fichiers.  Tout d'abord, vous pouvez
	commencer avec la première disquette et utiliser:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 nomdufichier</userinput></screen>

      <para>&man.tar.1; vous demandera d'insérer les disquettes
	suivantes jusqu'&agrave; trouver le fichier recherché.</para>

      <para>Alternativement, si vous savez sur quelle disquette
	le fichier se trouve alors vous pouvez simplement insérer
	cette disquette et utiliser la commande précédente.
	Notez que si le premier fichier sur la disquette est la suite
	d'un fichier de la précédente disquette alors
	&man.tar.1; vous avertira qu'il ne peut le restaurer,
	même si vous ne le voulez pas!</para>
    </sect2>
  </sect1>

  <sect1 xml:id="backup-strategies">
    <info><title>Stratégies de sauvegarde</title>
      <authorgroup>
	<author><personname><firstname>Lowell</firstname><surname>Gilbert</surname></personname><contrib>Travail original de </contrib></author>
      </authorgroup>
      
    </info>

    

    <para>La première chose a faire lors de la mise en place
      d'un plan de sauvegarde est de s'assurer que l'ensemble des
      problèmes suivants sera couvert:</para>

    <itemizedlist>
      <listitem>
	<para>Panne d'un disque</para>
      </listitem>
      <listitem>
	<para>Suppression accidentelle de fichiers</para>
      </listitem>
      <listitem>
	<para>Corruption aléatoire de fichiers</para>
      </listitem>
      <listitem>
	<para>Destruction complète de la machine (par exemple
	  suite &agrave; un incendie), avec destruction des sauvegardes
	  stockées sur le même site.</para>
      </listitem>
    </itemizedlist>

    <para>Il est parfaitement possible que certains systèmes
      utilisent une technique différente pour chacun des
      problèmes évoqués ci-dessus.  En dehors des
      systèmes personnels avec des données peu
      importantes, il est peu probable qu'une seule technique puisse
      répondre &agrave; l'ensemble de ces risques.</para>

    <para>Quelques-unes des techniques &agrave; notre disposition
      sont:</para>

    <itemizedlist>
      <listitem>
	<para>Des archives de tout le système,
	  sauvegardées sur un support fiable et &agrave;
	  l'extérieur du site.  C'est une protection
	  réelle contre tous les problèmes
	  précédemment cités, mais cette
	  méthode est lente et peu pratique lors des
	  restaurations.  Vous pouvez conserver des copies de ces
	  sauvegardes sur site et/ou en ligne, mais il y aura toujours
	  des difficultés lors de la restauration des fichiers,
	  en particulier pour les utilisateurs sans droits.</para>
      </listitem>

      <listitem>
	<para>Instantané de systèmes de fichiers.  Cet
	  outil n'est vraiment utile que dans le cas d'une suppression
	  accidentelle de fichiers, mais il l'est
	  <emphasis>vraiment</emphasis> dans ce cas; de plus cette
	  méthode est rapide et simple &agrave; employer.</para>
      </listitem>

      <listitem>
	<para>Copies de l'intégralité des
	  systèmes de fichiers et/ou des disques (par une
	  utilisation régulière de &man.rsync.1; sur
	  l'intégralité de la machine par exemple).  C'est
	  le procédé en général le plus
	  utile dans le cas des réseaux avec des besoins
	  spécifiques.  Dans le cas d'une protection contre les
	  pannes disques, cette méthode est normalement
	  inférieure &agrave; un système
	  <acronym>RAID</acronym>.  Pour la restauration de fichiers
	  supprimés accidentellement, c'est comparable aux
	  instantanés <acronym>UFS</acronym>, c'est plus une
	  question de préférence.</para>
      </listitem>

      <listitem>
	<para><acronym>RAID</acronym>.  Réduit ou évite
	  les périodes où le système est
	  inutilisable quand un disque tombe en panne.  Avec
	  l'inconvénient d'avoir &agrave; faire face &agrave; des
	  pannes disques plus fréquentes (parce que vous utilisez
	  plus de disques), mais avec cependant une moindre
	  urgence.</para>
      </listitem>

      <listitem>
	<para>Le contrôle des empreintes de fichiers.
	  L'utilitaire &man.mtree.8; est très utile dans ce cas.
	  Bien que cela ne soit pas une technique de sauvegarde des
	  données, ce contrôle aidera &agrave; garantir que
	  vous serez averti quand vous devrez ressortir vos sauvegardes.
	  C'est tout particulièrement important dans le cas de
	  sauvegardes hors site, et ces empreintes devraient être
	  vérifiées régulièrement.</para>
      </listitem>
    </itemizedlist>

    <para>Il est relativement simple de trouver d'autres solutions,
      nombreuses sont celles qui sont des variations des techniques
      présentées ci-dessus.  Des besoins
      spécifiques conduiront généralement
      &agrave; des solutions spécifiques (par exemple
      sauvegarder une base de données durant son utilisation
      demande une étape intermédiaire spécifique
      au logiciel de base de données).  L'important est de
      connaître les dangers contre lesquels vous désirez
      vous protéger, et comment vous ferez face &agrave; chacun
      d'entre eux.</para>
  </sect1>

  <sect1 xml:id="backup-basics">
    <title>Sauvegardes</title>

    <para>Les trois principaux programmes de sauvegarde sont:
	&man.dump.8;, &man.tar.1;, et &man.cpio.1;.</para>

    <sect2>
      <title>Dump et Restore</title>
      <indexterm>
	<primary>programmes de sauvegarde</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para>&man.dump.8; et &man.restore.8; sont les programmes de
	sauvegarde traditionnels d'&unix;.  Ils opèrent sur le disque
	comme sur une suite de blocs disque, en dessous du niveau
	d'abstraction que constituent les fichiers, liens et
	répertoires créés par les systèmes de
	fichiers.  Le programme &man.dump.8; sauvegarde
	l'intégralité d'un système de
	fichiers d'un périphérique.  Il est incapable
	de sauvegarder seulement une partie d'un système
	de fichiers ou une arborescence de répertoires
	s'étalant sur plus d'un système de fichiers.
	Le programme &man.dump.8; n'écrit pas de fichiers ou
	des répertoires sur la bande, mais écrit
	plutôt les blocs de données brutes dont sont
	constitués les fichiers et les répertoires.</para>

      <note>
	<para>Si vous utilisez &man.dump.8; sur votre répertoire
	  racine, vous ne sauvegarderez pas
	  <filename>/home</filename>, <filename>/usr</filename> ou
	  beaucoup d'autres répertoires puisque que ces derniers
	  sont généralement des points de montages pour
	  d'autres systèmes de fichiers ou des liens symboliques
	  vers ces systèmes de fichiers.</para>
      </note>

      <para>L'utilitaire &man.dump.8; a quelques particularités
	datant de ses débuts sous la version 6 d'AT&amp;T UNIX (circa
	1975).  Les paramètres par défaut conviennent aux bandes
	9 pistes (6250&nbsp;bpi), et non aux supports &agrave; haute
	densité d'aujourd'hui (jusqu'&agrave; 62182&nbsp;ftpi).
	Il faut surcharger ces valeurs par défaut sur la ligne
	de commande pour utiliser la capacité des bandes
	actuelles.</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>
      <para>Il est également possible de sauvegarder les
	données par l'intermédiaire d'un réseau sur un
	lecteur de bande se trouvant sur une autre ordinateur
	&agrave; l'aide des commandes <command>rdump</command> et
	<command>rrestore</command>.
	Ces deux programmes utilisent &man.rcmd.3; et &man.ruserok.3;
	pour accéder &agrave; l'unité de bandes distante.
        Cependant, l'utilisateur effectuant une sauvegarde doit
	être présent dans le fichier <filename>.rhosts</filename>
	sur la machine distante.  Les arguments de &man.rdump.8; et
	&man.rrestore.8; doivent être compatibles avec une
	utilisation sur la machine distante.  Quand on sauvegarde
	une machine FreeBSD sur un lecteur Exabyte installé sur
	un ordinateur Sun appelé <systemitem>komodo</systemitem>,
	utilisez:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</userinput></screen>

      <para>Attention: il y a des conséquences pour la
	sécurité &agrave; utiliser l'authentification
	<filename>.rhosts</filename>.  Evaluez soigneusement votre
	situation.</para>

      <para>Il est également possible d'utiliser &man.dump.8; et
	&man.restore.8; d'une façon plus sécurisée sur
	&man.ssh.1;.</para>

      <example>
	<title>Utiliser &man.dump.8; sur <application>ssh</application></title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>

      </example>

      <para>Ou en utilisant une fonction interne de
	<command>dump</command>, positionner la variable
	d'environnement <envar>RSH</envar>:</para>

      <example>
	<title>Utiliser <command>dump</command> sur <application>ssh</application>
	avec la variable <envar>RSH</envar> positionnée</title>

	<screen>&prompt.root; <userinput>RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</userinput></screen>
      </example>
    </sect2>

    <sect2>
      <title><command>tar</command></title>
      <indexterm>
	<primary>programmes de sauvegarde</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>

      <para>Le programme &man.tar.1; date aussi de la Version 6
	d'AT&amp;T UNIX (circa 1975).  &man.tar.1; travaille en
	coopération avec le système de fichiers; il
	permet d'écrire
	des fichiers et des répertoires sur bandes.
	&man.tar.1; ne supporte pas toutes les options permises
	par &man.cpio.1;, mais ne demande pas
	l'inhabituelle concaténation de commandes qu'utilise
	&man.cpio.1;</para>

      <indexterm><primary><command>tar</command></primary></indexterm>
      <para>Sous &os;&nbsp;5.3 et versions suivantes, GNU
	<command>tar</command> et la version par défaut
	<command>bsdtar</command> sont disponibles.  La version GNU
	peut être invoquée avec la commande
	<command>gtar</command>.  Elle supporte les sauvegardes sur
	des périphériques distants et cela
	avec la même syntaxe que &man.rdump.8;.  Pour sauvegarder avec
	&man.tar.1; sur une unité Exabyte connectée sur une machine
	Sun appelée <systemitem>komodo</systemitem>, utilisez:</para>

      <screen>&prompt.root; <userinput>/usr/bin/gtar cf komodo:/dev/nsa8 . 2&gt;&amp;1</userinput></screen>

      <para>La même opération peut être
	effectuée avec <command>bsdtar</command> en utilisant
	un tuyau et &man.rsh.1; pour
	envoyer les données sur un lecteur de bande distant:</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh hostname dd of=tape-device obs=20b</userinput></screen>

      <para>Si vous êtes inquiet au sujet de la sécurité
	de sauvegardes par réseau, vous devriez utiliser la
	commande &man.ssh.1; &agrave; la place de &man.rsh.1;.</para>
    </sect2>

    <sect2>
      <title><command>cpio</command></title>
      <indexterm>
	<primary>programmes de sauvegarde</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>

      <para>&man.cpio.1; est le programme &unix; original pour l'échange
	de fichiers par bandes magnétiques.  &man.cpio.1; dispose
	d'options (parmi beaucoup d'autres) pour intervertir les
	octets, utiliser de nombreux différents formats, et envoyer
	les données &agrave; d'autres programmes.  Cette dernière
	caractéristique fait de &man.cpio.1; un excellent choix pour
	les supports d'installation.  &man.cpio.1; ne sait pas
	parcourir une arborescence de répertoires et il faut lui
	passer la liste des fichiers via
	<filename>stdin</filename>.</para>
      <indexterm><primary><command>cpio</command></primary></indexterm>

      <para>&man.cpio.1; ne supporte pas les sauvegardes par le
	réseau.  Vous pouvez utiliser un tuyau et &man.rsh.1; pour
	envoyer les données sur un lecteur de bande distant:</para>

      <screen>&prompt.root; <userinput>for f in directory_list; do</userinput>
<userinput>find $f &gt;&gt; backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc &lt; backup.list | ssh user@host "cat &gt; backup_device"</userinput></screen>

      <para>Où <replaceable>directory_list</replaceable> est la liste
	des répertoires que vous désirez sauvegarder,
	<replaceable>user</replaceable>@<replaceable>host</replaceable>
	est l'ensemble utilisateur/nom de machine qui effectuera les
	sauvegardes, et <replaceable>backup_device</replaceable>
	représente l'unité où seront écrites les sauvegardes
	(e.g., <filename>/dev/nsa0</filename>).</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>
      <indexterm>
	<primary>programmes de sauvegarde</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; est la réponse IEEE/&posix; &agrave;
	&man.tar.1; et &man.cpio.1;.  Au fil des ans
	les différentes versions de &man.tar.1; et &man.cpio.1;
	sont devenues légèrement incompatibles.  Aussi,
	plutôt que de batailler pour les standardiser entièrement,
	&posix; a défini un nouvel utilitaire d'archivage.  &man.pax.1;
	tente de lire et d'écrire nombre des divers formats
	&man.tar.1; et &man.cpio.1;, en plus de ses propres nouveaux
	formats.  Son ensemble de commandes ressemble plus &agrave; celui
	de &man.cpio.1; qu'&agrave; celui de &man.tar.1;.</para>
    </sect2>

    <sect2 xml:id="backups-programs-amanda">
      <title><application>Amanda</application></title>
      <indexterm>
	<primary>programmes de sauvegarde</primary>
	<secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm><primary><application>Amanda</application></primary></indexterm>

      <!-- Remove link until <port> tag is available -->
      <para><application>Amanda</application> (Advanced Maryland
	Network Disk Archiver&mdash;Système Avancé d'Archivage
	de Disques en Réseau du Maryland) est un système
	d'archivage
	client/serveur plutôt qu'un simple programme.  Un serveur
	<application>Amanda</application> archivera sur une seule
	unité de bandes un nombre quelconque d'ordinateurs disposant
	de clients <application>Amanda</application> et un accès
	réseau au serveur <application>Amanda</application>.
	Un problème classique sur les sites qui ont de nombreux
	disques volumineux est que le temps nécessaire pour
	sauvegarder directement les données sur la bande dépasse
	le temps alloué &agrave; cette tâche.
	<application>Amanda</application> résout ce problème.
	<application>Amanda</application> peut utiliser un
	&ldquo;disque intermédiaire&rdquo; pour sauvegarder plusieurs
	systèmes de fichiers &agrave; la fois.
	<application>Amanda</application> des &ldquo;jeux
	d'archive&rdquo;: un ensemble de bandes utilisé pour une
	période donnée pour créer une sauvegarde
	complète de tous les systèmes de fichiers listé
	dans le fichier de configuration d'<application>Amanda</application>.
	Le &ldquo;jeu d'archive&rdquo; contient également les
	sauvegardes nocturnes incrémentales (ou
	différentielles) de tous les systèmes de fichiers.
	Pour restaurer une système de fichiers endommagé,
	il faut la sauvegarde complète la plus récente et
	les sauvegardes incrémentales.</para>

      <para>Le fichier de configuration permet un contrôle en finesse
	des sauvegardes et du trafic réseau
	qu'<application>Amanda</application> génère.
	<application>Amanda</application> utilisera n'importe quel des
	programmes de sauvegarde décrits plus haut pour écrire les
	données sur bande.  <application>Amanda</application> est
	disponible sous forme de logiciel porté ou de logiciel
	pré-compilé, il n'est pas installé
	par défaut.</para>
      </sect2>

    <sect2>
      <title>Ne rien faire</title>

      <para>&ldquo;Ne rien faire&rdquo; n'est pas un logiciel, mais
	c'est la stratégie de sauvegarde la plus utilisée.
	Il n'y a aucun investissement initial.  Il n'y a pas de de
	planification des sauvegardes &agrave; suivre.  Juste dire non.  Si
	quelque chose arrive &agrave; vos données, souriez et
	débrouillez-vous!</para>

      <para>Si votre temps et vos données ne valent pas grand chose,
	alors &ldquo;Ne rien faire&rdquo; est le programme de
	sauvegarde le mieux adapté &agrave; votre ordinateur.
	Mais prenez garde, &unix; est un outil utile, et vous pouvez vous rendre
	compte au bout de six mois que vous disposez d'une collection
	de fichiers qui vous sont utiles.</para>

      <para>&ldquo;Ne rien faire&rdquo; est la bonne méthode de
	sauvegarde pour <filename>/usr/obj</filename> et les autres
	répertoires qui peuvent facilement être
	recréés par votre ordinateur.  Un exemple est les
	fichiers qui constituent la version HTML ou &postscript; de ce manuel.
	Ces fichiers ont été générés
	&agrave; partir de fichiers SGML.
	Faire des sauvegardes des fichiers HTML ou &postscript; n'est
	pas nécessaire.  Les fichiers source SGML sont
	sauvegardés régulièrement.</para>
    </sect2>

    <sect2>
      <title>Quel est le meilleur programme de sauvegarde?</title>
      <indexterm>
        <primary>LISA</primary>
      </indexterm>

      <para>&man.dump.8; <emphasis>Point.</emphasis> Elizabeth D. Zwicky
	a soumis &agrave; rude épreuve tous les programmes de
	sauvegarde dont nous avons parlé.  Le choix de &man.dump.8;
	s'impose pour préserver toutes vos données et les
	particularités des systèmes de fichiers &unix;.  Elizabeth
	a créé des systèmes de fichiers avec une grande
	variété de particularités inhabituelles (et
	quelques unes pas tellement inhabituelles) et a testé chacun des
	programmes en faisant une sauvegarde et une restauration de ces
	systèmes de fichiers.  Parmi les spécificités
	testées: fichiers avec des trous, fichiers avec des trous
	et des blocs de caractères &ldquo;null&rdquo;, fichiers
	dont les noms comportent des caractères inhabituels,
	les fichiers illisibles ou impossible &agrave; modifier, les
	périphériques, fichiers dont la taille change pendant
	la sauvegarde, fichiers créés ou détruits en cours
	de sauvegarde et bien plus.  Elle a présenté les
	résultats de ces tests au LISA V en Octobre 1991.
	Voir les <link xlink:href="http://berdmann.dyndns.org/zwicky/testdump.doc.html">tests
	d'endurance des programmes de sauvegarde et
	d'archivage</link>.</para>
    </sect2>

    <sect2>
      <title>Procédure de restauration d'urgence</title>

      <sect3>
	<title>Avant le désastre</title>

	<para>Il y a quatre étapes &agrave; mettre en oeuvre en
	  prévision d'un désastre éventuel.</para>
	<indexterm>
    <primary><command>bsdlabel</command></primary>
  </indexterm>

	<para>Tout d'abord, imprimez le label de chacun de vos disques
	  (par exemple <command>bsdlabel da0 | lpr</command>), votre table
	  des systèmes de fichiers (<filename>/etc/fstab</filename>)
	  et tous les messages de démarrage, en deux
	  exemplaires.</para>

	<indexterm><primary>disquette de reprise
	  d'urgence</primary></indexterm>
	<para>Deuxièmement, vérifiez que vos disquettes de
	  démarrage et de reprise d'urgence
	  (<filename>boot.flp</filename> et <filename>fixit.flp</filename>)
	  incluent tous vos périphériques.  La méthode
	  la plus simple pour vérifier est de redémarrer avec la
	  disquette de démarrage dans le lecteur et contrôler
	  les messages de démarrage.  Si tous vos
	  périphériques
	  sont listés et opérationnels, passez &agrave; la
	  troisième étape.</para>

	<para>Sinon, vous devez créer deux disquettes de démarrage
	  sur-mesure avec un noyau qui puisse monter tous vos disques et
	  accéder &agrave; votre unité de bandes.  Ces disquettes
	  doivent contenir: &man.fdisk.8;, &man.bsdlabel.8;,
	  &man.newfs.8;, &man.mount.8;, et le programme de sauvegarde
	  que vous utilisez.  L'édition de liens de ces programmes
	  doit être statique.  Si vous utilisez &man.dump.8;, la
	  disquette doit contenir &man.restore.8;.</para>

	<para>Troisièmement, faites régulièrement des
	  sauvegardes sur bandes.  Toutes les modifications
	  effectuées après votre dernière sauvegarde
	  peuvent irrémédiablement perdues.  Protégez
	  vos bandes de sauvegarde en écriture.</para>

	<para>Quatrièmement, testez les disquettes (soit
	  <filename>boot.flp</filename> et <filename>fixit.flp</filename>
	  soit les deux disquettes sur-mesure que vous avez
	  créées &agrave; la seconde étape) et vos
	  bandes de sauvegarde.  Prenez note de la procédure.
	  Conservez ces notes avec la disquette de démarrage, les
	  impressions et les bandes de sauvegarde.  Vous serez si
	  préoccupé quand vous devrez restaurer que ces notes
	  peuvent vous éviter de détruire vos bandes de sauvegarde
	  (Comment?  Au lieu de <command>tar xvf /dev/sa0</command>,
	  vous pourriez taper accidentellement
	  <command>tar cvf /dev/sa0</command>, ce qui écraserait votre
	  bande de sauvegarde).</para>

	<para>Par mesure de sécurité, créez une
	  disquette de démarrage et deux bandes de sauvegarde
	  &agrave; chaque fois.  Conservez-les dans un lieu
	  éloigné.  Un endroit éloigné n'est
	  PAS le sous-sol du
	  même bâtiment.  Un certain nombre de compagnies du World
	  Trade Center l'ont appris &agrave; leurs dépends.  Un endroit
	  éloigné doit être physiquement
	  séparé de vos ordinateurs
	  et de vos disques par une distance significative.</para>

	<example>
	  <title>Procédure de création d'une disquette
	    de démarrage</title>

	<programlisting><![CDATA[#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo "Bad floppy, please use a new one"
	 exit 1
fi

# place boot blocks on the floppy
#
bsdlabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat &lt;&lt; EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI - A kernel to get FreeBSD onto a disk.
#
machine         "i386"
cpu             "I486_CPU"
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device          npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out's
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init > /mnt/sbin/init
gzip -c -best /sbin/fsck > /mnt/sbin/fsck
gzip -c -best /sbin/mount > /mnt/sbin/mount
gzip -c -best /sbin/halt > /mnt/sbin/halt
gzip -c -best /sbin/restore > /mnt/sbin/restore

gzip -c -best /bin/sh > /mnt/bin/sh
gzip -c -best /bin/sync > /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat &lt; /mnt/etc/fstab &lt;&lt;EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat &lt; /mnt/etc/passwd &lt;&lt;EOM
root:*:0:0:Charlie &amp;:/root:/bin/sh
EOM

cat &lt; /mnt/etc/master.passwd &lt;&lt;EOM
root::0:0::0:0:Charlie &amp;:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo "The floppy has been unmounted and is now ready."]]></programlisting>

        </example>

      </sect3>

      <sect3>
	<title>Après le désastre</title>

	<para>La question cruciale est: votre matériel a-t-il
	  survécu?  Vous avez régulièrement fait des
	  sauvegardes, vous n'avez donc pas besoin de vous
	  inquiéter pour les fichiers et les programmes.</para>

	<para>Si le matériel a subi des dégâts, remplacez
	  tout d'abord ce qui a été endommagé
	  avant de tenter d'utiliser l'ordinateur.</para>

	<para>Si votre matériel est en état, contrôlez
	  vos disquettes.  Si vous utilisez une disquette de démarrage
	  personnalisée, démarrez en mode mono-utilisateur (tapez
	  <literal>-s</literal> &agrave; l'invite <prompt>boot:</prompt>).
	  Sautez le paragraphe suivant.</para>

	<para>Si vous utilisez les disquettes <filename>boot.flp</filename>
	  et <filename>fixit.flp</filename>, continuez &agrave; lire.
	  Mettre la disquette <filename>boot.flp</filename> dans le
	  premier lecteur et démarrez l'ordinateur.  Le menu
	  d'installation d'origine s'affiche &agrave; l'écran.
	  Choisissez
	  l'option <guimenuitem>Fixit--Repair mode with CDROM or
	  floppy.</guimenuitem>.  Insérez la disquette
	  <filename>fixit.flp</filename> quand on vous la demande.
	  &man.restore.8; et les autres programmes dont vous avez
	  besoin sont situés dans le répertoire
	  <filename>/mnt2/rescue</filename>
	  (<filename>/mnt2/stand</filename> pour les
	  versions de &os; antérieures &agrave; la 5.2).</para>

	<para>Restaurez chaque système de fichiers
	  séparément.</para>

	<indexterm>
    <primary><command>mount</command></primary>
  </indexterm>
	<indexterm><primary>partition racine</primary></indexterm>
	<indexterm>
    <primary><command>bsdlabel</command></primary>
  </indexterm>
	<indexterm>
    <primary><command>newfs</command></primary>
  </indexterm>
	<para>Essayez &man.mount.8; (e.g. <command>mount /dev/da0a
	  /mnt</command>) sur la partition racine de votre premier
	  disque.  Si le label du disque est endommagé, utilisez
	  &man.bsdlabel.8; pour repartitionner et libeller le disque
	  conformément au label que vous avez imprimé et mis
	  de côté.  Utilisez &man.newfs.8; pour recréer
	  les systèmes de fichiers.  Remontez la partition racine
	  de la disquette en lecture/écriture (<command>mount -u -o rw
	  /mnt</command>).  Utilisez votre programme de restauration
	  et vos bandes de sauvegardes pour restaurer les données
	  de ce système de fichiers (e.g. <command>restore vrf
	  /dev/sa0</command>).  Démontez le système de fichiers
	  (e.g. <command>umount /mnt</command>).  Répétez
	  l'opération pour chacun des systèmes de fichiers
	  endommagés.</para>

	<para>Une fois que le système fonctionne &agrave; nouveau,
	  faites une sauvegarde sur de nouvelles bandes.  Ce qui
	  a causé la panne ou la perte de données peut se
	  reproduire.  Une heure de perdue maintenant peut vous
	  épargner d'autres ennuis plus tard.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-virtual">
    <info><title>Systèmes de fichiers réseaux, en mémoire
      et sauvegardés sur fichier</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Réorganisée et augmentée par </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm><primary>disques virtuels</primary></indexterm>
    <indexterm>
      <primary>disques</primary>
      <secondary>virtuels</secondary>
    </indexterm>

    <para>En plus des disques que vous introduisez physiquement
      dans votre ordinateur: disquettes, CD, disques durs, et ainsi
      de suite; d'autres formes de disques sont gérées
      par &os; &mdash; les <firstterm>disques
      virtuels</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>disques</primary>
      <secondary>mémoire</secondary>
    </indexterm>
    <para>Ceux-ci comprennent les systèmes de fichiers
      réseaux comme le <link linkend="network-nfs">NFS</link>
      et Coda, les systèmes de fichiers en mémoire et
      les systèmes de fichiers sauvegardé dans un
      fichier.</para>

    <para>En fonction de la version de &os; que vous utilisez,
      vous devrez utiliser des outils différents pour la
      création et l'utilisation de systèmes de fichiers
      en mémoire ou sauvegardé dans un
      fichier.</para>

    <note>
      <para>Utilisez &man.devfs.5; pour
	allouer de façon transparente pour l'utilisateur
	les fichiers spéciaux de périphériques.</para>
    </note>

    <sect2 xml:id="disks-mdconfig">
      <title>Système de fichiers sauvegardé dans un fichier</title>
      <indexterm>
	<primary>disques</primary>
	<secondary>système de fichiers sauvegardé dans un
	  fichier</secondary>
      </indexterm>

      <para>L'utilitaire &man.mdconfig.8; est utilisé pour
	configurer et activer les disques mémoires,
	&man.md.4;, sous &os;.  Pour utiliser
	&man.mdconfig.8;, vous devez charger le module &man.md.4;
	ou en ajouter le support dans votre fichier de configuration
	du noyau:</para>

      <programlisting>device md</programlisting>

      <para>La commande &man.mdconfig.8; supporte trois sortes
	de disques virtuels en mémoire: les disques mémoire
	alloués avec &man.malloc.9;, les disques mémoires
	utilisant un fichier ou l'espace de pagination comme
	espace disque.  Une des utilisations possibles est
	le montage d'images de disquettes ou de CDs conservées
	sous forme de fichier.</para>

      <para>Pour monter l'image d'un système de fichiers:</para>

      <example>
	<title>Utilisation de <command>mdconfig</command> pour monter
	  une image d'un système de fichiers</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f diskimage -u 0</userinput>
&prompt.root; <userinput>mount /dev/md0 /mnt</userinput></screen>
      </example>

      <para>Pour créer l'image d'un nouveau système de
	fichiers avec &man.mdconfig.8;:</para>

      <example>
	<title>Création d'un nouveau disque sauvegardé sur
	  fichier avec <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=newimage bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f newimage -u 0</userinput>
&prompt.root; <userinput>bsdlabel -w md0 auto</userinput>
&prompt.root; <userinput>newfs md0a</userinput>
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
&prompt.root; <userinput>mount /dev/md0a /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</screen>
      </example>

      <para>Si vous ne préciser pas de numéro d'unité
	avec l'option <option>-u</option>, &man.mdconfig.8;
	utilisera le mécanisme d'allocation automatique
	de &man.md.4; pour sélectionner un
	périphérique libre.
	Le nom de l'unité allouée s'affichera sur
	la sortie standard comme par exemple
	<filename>md4</filename>.  Pour plus de détails concernant
	&man.mdconfig.8;, référez-vous &agrave; la page de
	manuel.</para>

      <para>L'outil &man.mdconfig.8; est très utile, cependant
	son utilisation demande de nombreuses lignes de commandes
	pour créer un système de fichiers sauvegardé
	sur fichier.  &os; vient avec un outil appelé
	&man.mdmfs.8;, ce programme configure un disque &man.md.4;
	en utilisant &man.mdconfig.8;, y ajoute dessus un
	système de fichiers UFS en utilisant &man.newfs.8;, et le
	monte avec &man.mount.8;.  Par exemple, si vous désirez
	créer et monter la même image de système de
	fichiers que précédemment, tapez simplement ce
	qui suit:</para>

      <example>
	<title>Création et montage d'un disque sauvegardé
	  sur fichier avec <command>mdmfs</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=newimage bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F newimage -s 5m md0 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</screen>
      </example>

      <para>Si vous utilisez l'option <option>md</option> sans
	numéro d'unité, &man.mdmfs.8; utilisera la fonction
	automatique de sélection d'unité de &man.md.4; pour
	choisir un périphérique non utilisé.  Pour
	plus de détails au sujet de &man.mdmfs.8;,
	référez-vous &agrave; la page de manuel.</para>

    </sect2>

    <sect2 xml:id="disks-md-freebsd5">
      <title>Système de fichiers en mémoire</title>
      <indexterm>
	<primary>disques</primary>
	<secondary>système de fichiers en mémoire</secondary>
      </indexterm>

      <para>Pour un système de fichiers en mémoire la
	<quote>sauvegarde sur l'espace de pagination</quote> devrait
	être normalement utilisée.  Utiliser l'espace de
	pagination ne signifie pas que le disque en mémoire
	sera par défaut sur l'espace de pagination, mais
	plutôt que le disque mémoire sera alloué
	sur une zone de mémoire qui pourra être
	sauvegardée sur l'espace de pagination si
	nécessaire.  Il est également possible de
	créer un disque en mémoire dont la
	mémoire est allouée &agrave; l'aide de
	&man.malloc.9;, mais ce type de configuration, tout
	particulièrement dans le cas de disques de grande
	taille, peut donner lieu &agrave; une panique du
	système si le noyau se trouve &agrave; cours de
	mémoire.</para>

      <example>
	<title>Création d'un disque mémoire avec
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t swap -s 5m -u 1</userinput>
&prompt.root; <userinput>newfs -U md1</userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
&prompt.root; <userinput>mount /dev/md1 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</screen>
      </example>

      <example>
	<title>Création d'un disque mémoire avec
	  <command>mdmfs</command></title>
	<screen>&prompt.root; <userinput>mdmfs -s 5m md2 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2>
      <title>Détacher un disque mémoire du système</title>
      <indexterm>
	<primary>disques</primary>
	<secondary>détacher un disque mémoire</secondary>
      </indexterm>

      <para>Quand un système de fichiers en mémoire ou
	sauvegardé dans un fichier n'est pas utilisé,
	vous devriez rendre au système toutes les ressources.
	La première chose &agrave; faire est de démonter le
	système de fichiers, ensuite utiliser &man.mdconfig.8;
	pour détacher le disque du système et rendre les
	ressources.</para>

      <para>Par exemple pour détacher et libérer
	toutes les ressources utilisées par
	<filename>/dev/md4</filename>:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>Il est possible d'afficher des informations
	sur les périphériques &man.md.4; configurés
	en utilisant la commande <command>mdconfig
	-l</command>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="snapshots">
    <info><title>Instantané (&ldquo;Snapshot&rdquo;) d'un système de fichiers</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
      
    </info>

    

    <indexterm>
      <primary>Instantané de système de fichiers</primary>
      <secondary>Snapshot</secondary>
    </indexterm>

      <para>&os; en association avec les
	<link linkend="soft-updates">Soft Updates</link> offre une
	nouvelle caractéristique: les instantanés de
	systèmes de fichiers (&ldquo;file system
	snapshots&rdquo;).</para>

      <para>Les instantanés permettent &agrave; un utilisateur de
	créer des images d'un système de fichiers
	précis, et de les traiter comme un fichier.
	Les instantanés doivent être créés
	dans le système de fichiers sur lequel on veut effectuer
	l'opération, et un utilisateur ne pourra pas créer
	plus de 20 instantanés par système de fichiers.
	Les instantanés actifs sont enregistrés dans le
	superbloc, ils sont donc conservés durant les
	opérations de démontage et de remontage lors des
	redémarrages du système.  Quand un instantané
	n'est plus requis, il peut être supprimé avec
	la commande standard &man.rm.1;.  Les instantanés peuvent
	être supprimés dans n'importe quel ordre,
	cependant tout l'espace utilisé pourra ne pas
	être &agrave; nouveau disponible car un autre instantané
	réclamera éventuellement les blocs
	libérés.</para>

      <para>L'indicateur inaltérable <option>snapshot</option>
	est positionné lors de la création initiale de
	l'instantané.  La commande &man.unlink.1; fait une
	exception pour les fichiers d'instantanés puisqu'elle
	autorise leur suppression.</para>

      <para>Les instantanés sont créés avec la commande
	&man.mount.8;.  Pour placer un instantané de
	<filename>/var</filename> dans le fichier
	<filename>/var/snapshot/snap</filename> utilisez la commande
	suivante:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

      <para>Alternativement, vous pouvez utiliser &man.mksnap.ffs.8;
	pour créer un instantané:</para>

      <screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

      <para>Les fichiers d'instantanés peuvent être
	localisés sur un système de fichiers (e.g.
	<filename>/var</filename>) en utilisant la
	commande &man.find.1;:</para>

      <screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

      <para>Une fois un instantané créé, ce dernier
	pourra avoir de nombreux usages:</para>

      <itemizedlist>
	<listitem>
	  <para>Certains administrateurs utiliseront un instantané
	    pour des besoins de sauvegarde, car l'instantané
	    peut être transféré sur CD ou bande.</para>
	</listitem>

	<listitem>
	  <para>Un contrôle d'intégrité du système fichiers,
	    &man.fsck.8;, pourra être effectué sur
	    l'instantané.  En supposant que le système de
	    fichiers était propre quand il a été
	    monté, vous devriez toujours obtenir un résultat
	    positif (et non différent).  C'est essentiellement
	    que effectue le processus de &man.fsck.8; en tâche
	    de fond (&ldquo;background &man.fsck.8;&rdquo;).</para>
	</listitem>

	<listitem>
	  <para>Lancer l'utilitaire &man.dump.8; sur l'instantané.
	    Une image cohérente du système de fichiers avec
	    les paramètres temporels de l'instantané
	    sera produite.
	    &man.dump.8; peut également &agrave; partir d'un
	    instantané, créer une image et puis supprimer
	    l'instantané en une seule fois en utilisant l'indicateur
	    <option>-L</option> dans la ligne de commande.</para>
	</listitem>

	<listitem>
	  <para>Monter l'instantané comme une image figée
	    du système de fichiers.  Pour monter l'instantané
	    <filename>/var/snapshot/snap</filename> lancer:</para>

<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

	</listitem>
      </itemizedlist>

      <para>Vous pouvez maintenant parcourir l'arborescence de
	votre système de fichiers <filename>/var</filename>
	figé monter sous <filename>/mnt</filename>.
	Tout sera au départ dans le même état que lors de la
	création de l'instantané.  La seule exception est que les
	instantanés antérieurs apparaîtront
	sous la forme de fichiers vides.  Quand l'utilisation d'un
	instantané est terminée, il peut être
	démonté avec:</para>

<screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>Pour plus d'informations sur les
	<option>softupdates</option> et les instantanés de
	systèmes de fichiers, et également de la documentation
	technique, vous pouvez consulter le site Web de
	Marshall Kirk McKusick &agrave; l'adresse
	<uri xlink:href="http://www.mckusick.com/">http://www.mckusick.com/</uri></para>
  </sect1>

  <sect1 xml:id="quotas">
    <title>Quotas d'utilisation des disques</title>
    <indexterm>
      <primary>accounting</primary>
      <secondary>espace disque</secondary>
    </indexterm>
    <indexterm><primary>quotas disque</primary></indexterm>

    <para>Les quotas sont une option du système d'exploitation
      qui vous permet de limiter la quantité d'espace disque
      et/ou le nombre de fichiers auxquels ont droit un utilisateur
      ou tous les utilisateurs d'un même groupe, sur un système
      de fichiers donné.  On les utilise la plupart du temps
      sur les systèmes en temps partagé où il est
      souhaitable de limiter la quantité de ressources allouée
      &agrave; un utilisateur ou &agrave; un groupe.  Cela évitera qu'un
      utilisateur ou un groupe d'utilisateur consomme tout l'espace
      disque.</para>

    <sect2>
      <title>Configurer votre système pour pouvoir utiliser
	les quotas d'utilisation des disques</title>

      <para>Avant d'essayer de mettre en place des quotas disque, il
	est nécessaire de s'assurer que le noyau est configuré
	pour les quotas.  Cela se fait en ajoutant la ligne suivante
	dans votre fichier de configuration du noyau:</para>

      <programlisting>options QUOTA</programlisting>

      <para>Cette option n'est pas activée par défaut dans le
	noyau <filename>GENERIC</filename> de base, vous devrez donc
	configurer, compiler et installer un noyau sur-mesure pour
	utiliser les quotas disque.  Reportez-vous au chapitre <xref linkend="kernelconfig"/> pour plus d'informations sur la
	configuration du noyau.</para>

      <para>Ensuite vous devrez activer les quotas disques dans le
	fichier <filename>/etc/rc.conf</filename>.  Pour cela, ajoutez
	la ligne:</para>

      <programlisting>enable_quotas="YES"</programlisting>
      <indexterm>
        <primary>quotas disque</primary>
        <secondary>contrôle</secondary>
      </indexterm>
      <para>Pour un contrôle plus fin des quotas au démarrage
	du système, il existe une variable supplémentaire de
	configuration.  Normalement au démarrage,
	l'intégrité des quotas sur chaque système de
	fichiers est vérifiée par le programme
	&man.quotacheck.8;.  Ce programme s'assure que les données
	de la base de données des quotas correspondent bien aux
	données présentes sur le système de
	fichiers.  C'est un processus consommateur en temps qui
	affectera considérablement la durée de
	démarrage du système.  Si vous désirez passer
	cette étape, une variable dans
	<filename>/etc/rc.conf</filename> est prévue &agrave; cet
	effet:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Vous devez enfin éditer le fichier
	<filename>/etc/fstab</filename> pour activer les quotas
	système de fichiers par système de fichiers.  C'est
	l&agrave; que vous pouvez soit activer les quotas par utilisateur ou
	par groupe soit les pour les deux sur tous vos systèmes
	de fichiers.</para>

      <para>Pour activer les quotas par utilisateur sur un système
	de fichiers, ajouter l'option <option>userquota</option>
	dans le champ d'options sur l'entrée de
	<filename>/etc/fstab</filename> pour le système de fichiers
	sur lequel vous voulez activer les quotas.  Par
	exemple:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>De même, pour activer les quotas par groupe, utilisez
	l'option <option>groupquota</option> &agrave; la place de
	<option>userquota</option>.  Pour activer &agrave; la fois les quotas
	par utilisateur et par groupe, modifiez l'entrée de la
	façon suivante:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Par défaut, les fichiers où sont définis les
	quotas dans le répertoire racine du système de fichiers
	sous les noms <filename>quota.user</filename> et
	<filename>quota.group</filename>, respectivement pour les
	quotas utilisateur et les quotas par groupe.  Consultez
	la page de manuel &man.fstab.5; pour plus d'information.
	Bien que la page de manuel &man.fstab.5; indique que vous
	pouvez spécifier un autre emplacement pour ces fichiers,
	cela n'est pas recommandé parce que les divers utilitaires
	qui gèrent les quotas ne semblent pas les prendre correctement
	en compte.</para>

      <para>A ce point vous devriez redémarrer votre système
	avec votre nouveau noyau.  La procédure
	<filename>/etc/rc</filename> exécutera automatiquement les
	commandes nécessaires pour créer les fichiers de quotas
	initiaux pour tous les quotas que vous avez définis
	dans <filename>/etc/fstab</filename>, vous n'avez donc pas
	besoin de créer &agrave; la main de fichiers de
	quotas vides.</para>

      <para>Vous ne devriez pas avoir &agrave; exécuter les
	commandes &man.quotacheck.8;, &man.quotaon.8;, ou
	&man.quotaoff.8; manuellement.  Cependant, vous pouvez lire
	leur page de manuel pour vous familiariser avec leur
	rôle.</para>
    </sect2>

    <sect2>
      <title>Définir les quotas</title>
      <indexterm>
	<primary>quotas disque</primary>
	<secondary>limites</secondary>
      </indexterm>

      <para>Une fois que vous avez activé les quotas sur votre
	système, assurez-vous que cela fonctionne correctement.
	Une manière simple de le faire est
	d'exécuter:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>Vous devriez obtenir une ligne résumant l'utilisation
	disque avec les quotas actuellement définis pour chaque
	système de fichiers sur lesquels il y a des quotas.</para>

      <para>Vous êtes maintenant prêt &agrave; définir les
	quotas avec la commande &man.edquota.8;.</para>

      <para>Vous disposez de différentes options pour instaurer
	les quotas d'espace disque alloué &agrave; un utilisateur
	ou &agrave; un groupe, et le nombre de fichiers qu'ils peuvent
	créer.  Vous pouvez baser les limitations sur l'espace disque
	alloué (quotas en nombre de blocs) ou sur le nombre de
	fichiers (quotas en inode) ou les deux.  Ces options
	peuvent être divisées en deux catégories: les
	limites strictes ou souples.</para>

      <indexterm><primary>limite stricte</primary></indexterm>
      <para>Une limite stricte ne peut être dépassée.
	Une fois qu'un utilisateur atteint sa limite stricte, il
	ne pourra plus rien allouer sur le système de fichiers
	en question.  Par exemple, si l'utilisateur a droit &agrave; une
	limite stricte de 500&nbsp;Ko sur un système de fichiers et en
	utilise 490&nbsp; Ko, il ne pourra allouer que 10&nbsp;Ko
	supplémentaires.  Une tentative d'allouer 11&nbsp;Ko
	échouerait.</para>

      <indexterm><primary>limite souple</primary></indexterm>
      <para>Une limite souple peut être dépassée
	pour une période de temps restreinte.  C'est ce que l'on
	appelle le délai de grâce, qui est d'une semaine
	par défaut.  Si un utilisateur dépasse cette limite
	au del&agrave; du délai de grâce, cette limite
	devient stricte, et plus aucune allocation ne sera possible.
	Quand l'utilisateur redescend en dessous de la limite souple,
	le délai de grâce est &agrave; nouveau
	réaccordé.</para>

      <para>Ce qui suit est un exemple de ce que vous pourrez voir
	en utilisant la commande &man.edquota.8;.  Quand vous invoquez
	la commande &man.edquota.8;, vous vous retrouvez dans
	l'éditeur défini par la variable d'environnement
	<envar>EDITOR</envar>, ou sous <application>vi</application>
	si la variable d'environnement <envar>EDITOR</envar> n'est
	pas positionnée, ce qui vous permet d'éditer les
	quotas.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>Vous verrez normalement deux lignes pour chaque système
	de fichiers sur lequel il y a des quotas.  Une ligne pour
	les quotas de blocs, et une autre pour la limite d'inode.
	Modifiez simplement les valeurs que vous voulez mettre &agrave; jour.
	Par exemple, pour augmenter la limite de blocs accordée
	&agrave; cet utilisateur de 50 pour la limite souple et de 75 pour la
	limite stricte &agrave; 500 pour la limite souple et 600 pour la
	limite stricte, modifiez:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>en:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Les nouveaux quotas seront en service dès que vous
	quitterez l'éditeur.</para>

      <para>Il est parfois souhaitable de définir des quotas
	pour une plage d'UIDs (identifiants utilisateur).  Cela
	peut être réalisé avec l'option
	<option>-p</option> de la commande &man.edquota.8;.
	Définissez d'abord les quotas pour un seul utilisateur, et
	puis exécutez
	<command>edquota -p protouser startuid-enduid</command>.
	Par exemple, si l'utilisateur <systemitem class="username">test</systemitem>
	dispose des quotas désirés, la commande suivante peut
	être utilisée pour appliquer ces quotas pour les UIDs
	de 10000 &agrave; 19999:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>Pour plus d'informations consultez la page de manuel
	&man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>Consulter les quotas et l'utilisation des disques</title>
      <indexterm>
	<primary>quotas disque</primary>
	<secondary>contrôle</secondary>
      </indexterm>

      <para>Vous pouvez soit utiliser la commande &man.quota.1;
	soit la commande &man.repquota.8; pour consulter les quotas
	et l'utilisation des disques.  La commande &man.quota.1;
	peut être employée pour connaître
	les quotas et l'utilisation des disques pour un utilisateur et
	un groupe.  Un utilisateur ne peut consulter que ses propres
	quotas et ceux d'un groupe auquel il appartient.  Seul le
	super-utilisateur peut consulter les quotas et l'usage disque
	de tous les utilisateurs et groupes.  La commande
	&man.repquota.8; permet d'obtenir un résumé de tous
	les quotas et l'utilisation disque pour les systèmes
	de fichiers sur lesquels il y a des quotas.</para>

      <para>Ce qui suit est un extrait de la sortie de la commande
	<command>quota -v</command> pour un utilisateur pour lequel
	on a défini des quotas sur deux systèmes de
	fichiers.</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>délai de grâce</primary></indexterm>
      <para>Sur le système de fichiers <filename>/usr</filename>
	dans l'exemple ci-dessus, l'utilisateur occupe 15&nbsp;Ko de
	plus que la limite de 50&nbsp;Ko qui lui est allouée et
	dispose d'un délai de grâce de 5 jours.  Notez
	l'astérisque <literal>*</literal> qui indique que
	l'utilisateur dépasse actuellement son quota.</para>

      <para>Normalement les systèmes de fichiers sur lesquels
	l'utilisateur n'occupe pas d'espace n'apparaissent pas
	dans la sortie de la commande &man.quota.1;, même s'il a des
	quotas sur ces systèmes de fichiers.  L'option
	<option>-v</option> listera ces systèmes de fichiers, comme
	<filename>/usr/var</filename> dans l'exemple ci-dessus.</para>
    </sect2>

    <sect2>
      <title>Quotas avec NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Les quotas sont gérés par le sous-système
	de gestion des quotas sur le serveur NFS.  Le démon
	&man.rpc.rquotad.8; fournit les informations sur les quotas
	&agrave; la commande &man.quota.1; des clients NFS, permettant
	aux utilisateurs sur ces machines de consulter l'utilisation
	des quotas qui leur sont alloués.</para>

      <para>Activez <command>rpc.rquotad</command> dans
	<filename>/etc/inetd.conf</filename> de la façon
	suivante:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Puis redémarrez <command>inetd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-encrypting">
    <info><title>Chiffrer les partitions d'un disque</title>
      <authorgroup>
	<author><personname><firstname>Lucky</firstname><surname>Green</surname></personname><contrib>Contribution de </contrib><affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>disques</primary>
      <secondary>chiffrement</secondary></indexterm>

    <para>&os; offre d'excellentes protections contre un accès
      non autorisé aux données par l'intermédiaire du
      réseau.  Les permissions sur les fichiers et le contrôle
      d'accès obligatoire &mdash; &ldquo;Mandatory Access
      Control&rdquo; (MAC) (voir <xref linkend="mac"/>) empêchent
      l'accès aux données pour des tiers non autorisés
      quand le système d'exploitation est actif et l'ordinateur en
      fonctionnement.  Cependant, des permissions renforcés
      sont inutiles si l'attaquant a un accès physique &agrave;
      un ordinateur et peut simplement déplacer le disque dur
      sur un autre système pour copier et analyser les
      données sensibles.</para>

    <para>Indépendamment de la manière dont une personne
      malveillante s'est
      trouvé en possession d'un disque dur ou a arrêté
      un ordinateur, le <application>chiffrage de disque basé
      sur GEOM (gbde)</application> (&ldquo;GEOM Based Disk
      Encryption&rdquo;) et le système de chiffrage
      <command>geli</command> de &os; sont en mesure de
      protéger les données des systèmes de
      fichiers contre des attaquants très motivés et aux
      ressources importantes.  A la différence des
      méthodes de chiffrage lourdes qui chiffrent uniquement
      les fichiers individuels, <application>gbde</application> et
      <command>geli</command> chiffrent de manière transparente
      l'intégralité du système de fichiers.
      Aucun texte en clair ne touche les plateaux du disque.</para>

    <sect2>
      <title>Chiffrage des disques avec
	<application>gbde</application></title>

      <procedure>
	<step>
	  <title>Devenir <systemitem class="username">root</systemitem></title>

	  <para>La configuration de <application>gbde</application>
	    requiert les privilèges du super-utilisateur.</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>

	<step>
	  <title>Ajouter le support &man.gbde.4; au fichier de
	    configuration du noyau</title>

	  <para>Ajoutez la ligne suivante &agrave; votre fichier de
	    configuration du noyau:</para>

	  <para><literal>options GEOM_BDE</literal></para>

	  <para>Recompilez le noyau comme décrit dans <xref linkend="kernelconfig"/>.</para>

	  <para>Redémarrez avec le nouveau noyau.</para>
	</step>

	<step>
	  <para>Au lieu de recompiler le noyau, on peut utiliser
	    <command>kldload</command> pour charger le support
	    &man.gbde.4;:</para>

	  <screen>&prompt.root; <userinput>kldload geom_bde</userinput></screen>
	</step>
      </procedure>

    <sect3>
      <title>Préparation du disque dur chiffré</title>

      <para>L'exemple suivant suppose que vous ajoutez un nouveau
	disque dur &agrave; votre système et qui contiendra une
	seule partition chiffrée.  Cette partition sera
	montée sous <filename>/private</filename>.
	<application>gbde</application> peut également être
	utilisé pour chiffrer les répertoires
	<filename>/home</filename> et <filename>/var/mail</filename>,
	mais cela demande une configuration plus complexe qui
	dépasse le cadre de cette introduction.</para>

      <procedure>
	<step>
	  <title>Ajouter le nouveau disque</title>

	  <para>Installez le nouveau disque comme expliqué dans
	    <xref linkend="disks-adding"/>.  Pour les besoins de cet
	    exemple, une nouvelle partition disque a été
	    ajoutée en tant que <filename>/dev/ad4s1c</filename>.
	    Les périphériques du type
	    <filename>/dev/ad0s1*</filename>
	    représentent les partitions &os; standards sur le
	    système exemple.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>Créer un répertoire pour héberger
	    les fichiers de verrouillage de GBDE</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para>Le fichier de verrouillage de
	    <application>gbde</application> contient l'information
	    nécessaire &agrave; <application>gbde</application> pour
	    accéder aux partitions chiffrées.  Sans accès
	    au fichier de verrouillage,
	    <application>gbde</application> sera incapable de
	    déchiffrer les données contenues sur la partition
	    chiffrée sans une aide manuelle significative ce
	    qui n'est pas supporté par le logiciel.  Chaque
	    partition chiffrée utilise un fichier de verrouillage
	    propre.</para>
	</step>

	<step>
	  <title>Initialiser la partition gbde</title>

	  <para>Une partition <application>gbde</application>
	    doit être initialisée avant d'être utilisable.
	    Cette initialisation doit être effectuée une seule
	    fois:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c</userinput></screen>

	  <para>&man.gbde.8; lancera votre éditeur, vous permettant
	    de fixer diverses options de configuration dans un
	    gabarit.  Pour une utilisation de UFS1 ou UFS2, fixez
	    l'option <literal>sector_size</literal> &agrave;
	    2048:</para>

	  <programlisting>$<!-- This is not the space you are looking
for-->FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# La taille d'un secteur est la plus petite unité de donnée
# qui peut être lue ou écrite.
# Une valeur trop petite diminue les performances et l'espace
# disponible.
# Une valeur trop grande peut empêcher des systèmes de
# fichiers de fonctionner correctement.  512 est la valeur minimale
# et sans risque.  Pour l'UFS, utiliser la taille d'un fragment
#
sector_size     =       2048
[...]
</programlisting>

	  <para>&man.gbde.8; vous demandera de taper deux fois
	    la phrase d'authentification qui devra être
	    utilisée pour sécuriser les données.  La
	    phrase d'authentification doit être la même
	    dans les deux cas.  La capacité de
	    <application>gbde</application> &agrave; protéger
	    vos données dépend de la qualité de la
	    phrase d'authentification que vous avez choisie.
	  <footnote>
          <para>Pour des conseils sur comment choisir une
	    phrase d'authentification sécurisée et facile
	    &agrave; retenir, consultez le site Web <link xlink:href="http://world.std.com/~reinhold/diceware.html">Diceware
	    Passphrase</link>.</para></footnote></para>

	  <para>La commande <command>gbde init</command> crée
	    un fichier de verrouillage pour votre partition
	    <application>gbde</application> qui dans cet exemple est
	    stocké sous <filename>/etc/gbde/ad4s1c</filename>.</para>

	  <caution>
	    <para>Les fichiers de verrouillage de
	      <application>gbde</application>
	      <emphasis>doivent</emphasis> être conservés de
	      pair avec le contenu des partitions chiffrées.
	      Alors que la suppression seule d'un fichier de
	      verrouillage ne peut empêcher une personne
	      déterminée de déchiffrer une partition
	      <application>gbde</application>, sans le fichier
	      de verrouillage, le propriétaire légitime sera
	      incapable d'accéder aux données de la partition
	      chiffrée sans beaucoup de travail ce qui est
	      totalement non supporté par
	      &man.gbde.8; et son concepteur.</para>
	  </caution>
	</step>

	<step>
	  <title>Attacher la partition chiffrée au noyau</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>

	  <para>On vous demandera de fournir la phrase
	    d'authentification que vous avez choisie lors de
	    l'initialisation de la partition chiffrée.  Le
	    nouveau périphérique chiffré apparaîtra
	    dans <filename>/dev</filename> en tant que
	    <filename>/dev/nom_périphérique.bde</filename>:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>Créer un système de fichiers
	    sur le périphérique chiffré</title>

	  <para>Une fois que le périphérique chiffré
	    a été attaché au noyau, vous pouvez créer
	    un système de fichiers sur le périphérique.
	    Pour créer un système de fichiers sur le
	    périphérique, utilisez &man.newfs.8;.
	    Puisqu'il est plus rapide d'initialiser un nouveau
	    système de fichiers UFS2 qu'un nouveau système
	    UFS1, l'utilisation de &man.newfs.8; avec l'option
	    <option>-O2</option> est recommandé.</para>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
	    <para>La commande &man.newfs.8; peut être effectuée
	      sur une partition <application>gbde</application>
	      attachée qui est identifiée par une extension
	      <filename>*.bde</filename>
	      au niveau du nom de périphérique.</para>
	  </note>
	</step>

	<step>
	  <title>Monter la partition chiffrée</title>

	  <para>Créez un point de montage pour le système
	    de fichiers chiffré.</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

	  <para>Montez le système de fichiers chiffré.</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
	  <title>Vérifiez que le système de fichiers
	    chiffré est disponible</title>

	  <para>Le système de fichiers chiffré devrait
	    être visible par &man.df.1; et prêt &agrave;
	    être utilisé:</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>
    </sect3>

    <sect3>
      <title>Montage des systèmes de fichiers chiffrés</title>

      <para>Après chaque démarrage, tout système
	de fichiers chiffré doit être rattaché
	au noyau, contrôlé pour les erreurs, et monté,
	avant que les systèmes de fichiers ne puissent être
	utilisés.  Les commandes nécessaires doivent être
	exécutées en tant que
	<systemitem class="username">root</systemitem>.</para>

      <procedure>
	<step>
	  <title>Attacher la partition gdbe au noyau</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>

	  <para>On vous demandera de fournir la phrase
	    d'authentification que vous avez choisie lors de
	    l'initialisation de la partition <application>gbde</application> chiffrée.</para>
	</step>

	<step>
	  <title>Contrôler les erreurs du système de fichiers</title>

	  <para>Puisque les systèmes de fichiers chiffrés
	    ne peuvent être encore listés dans le fichier
	    <filename>/etc/fstab</filename> pour un montage
	    automatique, on doit donc contrôler les systèmes de
	    fichiers pour d'éventuelles erreurs en exécutant
	    manuellement &man.fsck.8; avant le montage.</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>Monter le système de fichiers chiffré</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>

	  <para>Le système de fichiers est maintenant
	    disponible &agrave; l'utilisation.</para>
	</step>
      </procedure>

      <sect4>
	<title>Montage automatique de partitions chiffrées</title>

	<para>Il est possible de créer une procédure pour
	  automatiquement attacher, contrôler, et monter une
	  partition chiffrée, mais pour des raisons de
	  sécurité la procédure ne devrait pas contenir le
	  mot de passe &man.gbde.8;.  A la place, il est recommandé
	  que de telles procédures soient exécutées
	  manuellement tout en fournissant le mot de passe via la
	  console ou &man.ssh.1;.</para>

	<para>Comme autre possibilité, une procédure
	  <filename>rc.d</filename> est fournie.  Des arguments
	  peuvent être passés &agrave; cette
	  procédure par l'intermédiaire de
	  &man.rc.conf.5;,, par exemple:</para>

	<programlisting>gbde_autoattach_all="YES"
gbde_devices="ad4s1c"</programlisting>

	<para>Cela impose la saisie de la phrase d'authentification
	  <application>gbde</application> au démarrage.
	  Après avoir entré la phrase d'authentification
	  correctement, la partition chiffrée
	  <application>gbde</application> sera montée
	  automatiquement.  Cela peut être très utile
	  quand <application>gbde</application> est utilisé sur
	  des ordinateurs portables.</para>
      </sect4>
    </sect3>

      <sect3>
	<title>Les protections cryptographiques utilisées
	  par gbde</title>

	<para>&man.gbde.8; chiffre la partie utile des secteurs en
	  utilisant le chiffrage AES 128 bits en mode CBC.  Chaque
	  secteur sur le disque est chiffré avec une clé AES
	  différente.  Pour plus d'informations sur l'architecture
	  cryptographique de <application>gbde</application>, y
	  compris comment les clés pour chaque secteur sont
	  des dérivés de la phrase d'authentification
	  donnée par l'utilisateur, voir la page de manuel
	  &man.gbde.4;.</para>
      </sect3>

      <sect3>
	<title>Problèmes de compatibilité</title>

	<para>&man.sysinstall.8; est incompatible avec
	  les périphériques
	  <application>gbde</application>-chiffrés.  Tous les
	  périphériques
	  <filename>*.bde</filename>
	  doivent être détachés du noyau
	  avant de lancer &man.sysinstall.8; ou ce dernier plantera
	  durant son processus initial de recherche des
	  périphériques.  Pour détacher le
	  périphérique chiffré utilisé dans notre
	  exemple, utilisez la commande suivante:</para>

	<screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

	<para>Notez également qu'étant donné
	  que &man.vinum.4; n'utilise pas le sous-système
	  &man.geom.4;, vous ne pouvez utiliser
	  <application>gbde</application> avec des volumes
	  <application>vinum</application>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="disks-encrypting-geli">
      <info><title>Chiffrage des disques avec
	<command>geli</command></title>
	<authorgroup>
	  <author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Contribution de </contrib></author>
	</authorgroup>
	
      </info>

      

      <para>Depuis &os; 6.0, une nouvelle classe GEOM pour le
	chiffrage des données est disponible:
	<command>geli</command>.  Cette classe est
	développée par &a.pjd;.  L'outil
	<command>geli</command> est différent de
	<command>gbde</command>; il offre des fonctionnalités
	différentes et utilise une méthode
	différente pour chiffrer les données.</para>

      <para>Les caractéristiques les plus importantes de
	&man.geli.8; sont:</para>

      <itemizedlist>
	<listitem>
	  <para>Utilisation du système &man.crypto.9; &mdash;
	    quand du matériel destiné au chiffrement est
	    disponible dans la machine, <command>geli</command>
	    l'utilisera automatiquement.</para>
	</listitem>
	<listitem>
	  <para>Support de plusieurs algorithmes de chiffrement
	    (actuellement AES, Blowfish, et 3DES).</para>
	</listitem>
	<listitem>
	  <para>Permettre le chiffrage de la partition racine.  La
	    phrase d'authentification utilisée pour
	    accéder &agrave; la partition racine
	    chiffrée sera demandée au démarrage
	    du système.</para>
	</listitem>
	<listitem>
	  <para>Permettre l'emploi de deux clés
	    indépendantes (par exemple une <quote>clé
	    utilisateur</quote> et une <quote>clé
	    entreprise</quote>).</para>
	</listitem>
	<listitem>
	  <para><command>geli</command> est rapide&mdash;il effectue
	    un simple chiffrement de secteur &agrave; secteur.</para>
	</listitem>
	<listitem>
	  <para>Permettre la sauvegarde et la restauration des
	    clés principales.  Quand un utilisateur doit
	    détruire ses clés, il sera possible
	    d'accéder &agrave; nouveau aux données en
	    restaurant les clés &agrave; partir de la
	    sauvegarde.</para>
	</listitem>
	<listitem>
	  <para>Permettre d'attacher un disque avec une clé
	    aléatoire &agrave; usage unique &mdash; utile pour
	    les partitions de pagination et les systèmes de
	    fichiers temporaires.</para>
	</listitem>
      </itemizedlist>

      <para>Plus de caractéristiques concernant
	<command>geli</command> peuvent être trouvées
	dans la page de manuel de &man.geli.8;.</para>

      <para>Les points suivants décriront comment activer le
	support pour <command>geli</command> dans le noyau &os; et
	expliqueront comment créer et utiliser un
	<emphasis>provider</emphasis> (ou partition) chiffré
	<command>geli</command>.</para>

      <para>Afin de pouvoir employer <command>geli</command>, vous
	devez utiliser &os; 6.0-RELEASE ou une version
	ultérieure.  Les privilèges du super-utilisateur
	seront également nécessaire puisque il faudra
	effectuer des modifications au niveau du noyau.</para>

      <procedure>
	<step>
	  <title>Ajouter le support <command>geli</command> au
	    noyau</title>

	  <para>Ajoutez les lignes suivantes au fichier de
	    configuration du noyau:</para>

	  <programlisting>options GEOM_ELI
device crypto</programlisting>

	  <para>Recompilez le noyau comme décrit dans la <xref linkend="kernelconfig"/>.</para>

	  <para>Sinon, le module <command>geli</command> peut
	    être chargé au démarrage.  Ajoutez la
	    ligne suivante au fichier
	    <filename>/boot/loader.conf</filename>:</para>

	  <programlisting>geom_eli_load="YES"</programlisting>

	  <para>Le système &man.geli.8; devrait
	    désormais être supporté par le
	    noyau.</para>
	</step>

	<step>
	  <title>Générer la clé
	    principale</title>

	  <para>L'exemple suivant décrira la méthode
	    pour générer un fichier clé qui sera
	    utilisé comme partie de la clé principale
	    pour le <emphasis>provider</emphasis> chiffré
	    monté sous le répertoire <filename>/private</filename>.  Le fichier
	    clé fournira des données aléatoires
	    qui seront employées pour chiffrer la clé
	    principale.  La clé principale sera
	    également protégée par une phrase
	    d'authentification.  La taille des secteurs du
	    <emphasis>provider</emphasis> sera de 4Ko.  De plus, sera
	    décrit comment attacher au système le
	    <emphasis>provider</emphasis> geli, créer un
	    système de fichiers dessus, utiliser ce
	    système de fichiers et enfin comment le
	    détacher.</para>

	  <para>Il est recommandé d'utiliser une taille de
	    secteur plus grande (comme 4Ko) pour de meilleures
	    performances.</para>

	  <para>La clé principale sera protégée
	    avec une phrase d'authentification et la source de
	    données pour le fichier clé sera
	    <filename>/dev/random</filename>.  La taille des secteurs
	    de <filename>/dev/da2.eli</filename>, partition que nous
	    appelons <emphasis>provider</emphasis>, sera de
	    4Ko.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/root/da2.key bs=64 count=1</userinput>
&prompt.root; <userinput>geli init -s 4096 -K /root/da2.key /dev/da2</userinput>
Enter new passphrase:
Reenter new passphrase:</screen>

	  <para>Il n'est pas obligatoire d'utiliser la phrase
	    d'authentification et le fichier clé; chacune de
	    ces méthodes de sécurisation de la
	    clé principale peut être utilisée
	    séparément.</para>

	  <para>Si &agrave; la place du fichier clé un
	    <quote>-</quote> est passé, l'entrée
	    standard sera utilisée.  Cet exemple montre comment
	    on peut utiliser plus d'un fichier clé:</para>

	  <screen>&prompt.root; <userinput>cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</userinput></screen>
	</step>

	<step>
	  <title>Attacher le <emphasis>provider</emphasis> avec la
	    clé générée</title>

	  <screen>&prompt.root; <userinput>geli attach -k /root/da2.key /dev/da2</userinput>
Enter passphrase:</screen>

	  <para>Le nouveau périphérique sera appelé
	    <filename>/dev/da2.eli</filename>.</para>

	  <screen>&prompt.root; <userinput>ls /dev/da2*</userinput>
/dev/da2  /dev/da2.eli</screen>
	</step>

	<step>
	  <title>Créer le nouveau système de
	    fichiers</title>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/da2.eli bs=1m</userinput>
&prompt.root; <userinput>newfs /dev/da2.eli</userinput>
&prompt.root; <userinput>mount /dev/da2.eli /private</userinput></screen>

	  <para>Le système de fichiers chiffré devrait
	    être maintenant visible par &man.df.1; et disponible
	    &agrave; l'utilisation:</para>

	  <screen>&prompt.root; <userinput>df -H</userinput>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</screen>
	</step>

	<step>
	  <title>Démonter et détacher le
	    <emphasis>provider</emphasis></title>

	  <para>Une fois l'utilisation de la partition chiffrée
	    achevée et que la partition <filename>/private</filename> n'est plus
	    nécessaire, il est prudent de penser &agrave;
	    démonter et détacher la partition
	    <command>geli</command> chiffrée:</para>

	  <screen>&prompt.root; <userinput>umount /private</userinput>
&prompt.root; <userinput>geli detach da2.eli</userinput></screen>
	</step>
      </procedure>

	  <para>Plus d'information sur l'utilisation de &man.geli.8;
	    peut être trouvée dans sa page de
	    manuel.</para>

      <sect3>
	<title>Utiliser la procédure <filename>rc.d</filename>
	  de <filename>geli</filename></title>

	<para>La commande <filename>geli</filename> est fournie avec
	  une procédure <filename>rc.d</filename> qui peut
	  être employée pour simplifier l'utilisation de
	  <command>geli</command>.  Un exemple de configuration de
	  <command>geli</command> &agrave; l'aide de &man.rc.conf.5;
	  sera:</para>

	<programlisting>geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"</programlisting>

	<para>Ces lignes configureront <filename>/dev/da2</filename>
	  comme <emphasis>provider</emphasis> <command>geli</command>
	  avec une clé principale
	  <filename>/root/da2.key</filename>, de plus
	  <command>geli</command> n'utilisera pas de phrase
	  d'authentification pour attacher le
	  <emphasis>provider</emphasis> (notez que ceci n'est
	  utilisable que si l'option <option>-P</option> a
	  été passée durant la phase
	  <literal>geli init</literal>).  Le système
	  détachera du noyau le <emphasis>provider</emphasis>
	  <command>geli</command> avant l'arrêt du
	  système.</para>

	<para>Plus d'information sur la configuration du
	  système <filename>rc.d</filename> est fournie dans la
	  section <link linkend="configtuning-rcd">rc.d</link> de ce
	  Manuel.</para>
      </sect3>
    </sect2>
  </sect1>


  <sect1 xml:id="swap-encrypting">
    <info><title>Chiffrage de l'espace de pagination</title>
      <authorgroup>
	<author><personname><firstname>Christian</firstname><surname>Brüffer</surname></personname><contrib>Ecrit par </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>espace de pagination</primary>
      <secondary>chiffrage</secondary>
    </indexterm>

    <para>Sous &os;, le chiffrement de l'espace de pagination est
      simple &agrave; mettre en place et est possible depuis &os;
      5.3-RELEASE.  En fonction de la version de &os; utilisée,
      différentes options sont disponibles et la configuration
      peut légèrement varier.  Depuis &os; 6.0-RELEASE,
      les systèmes de chiffrage &man.gbde.8; ou &man.geli.8;
      peuvent être utilisé &agrave; cet effet.  Avec les
      versions antérieures, seul &man.gbde.8; est disponible.
      Les deux systèmes utilisent la procédure <link linkend="configtuning-rcd">rc.d</link> nommée
      <filename>encswap</filename>.</para>

    <para>La section précédente, <link linkend="disks-encrypting">Chiffrer les partitions d'un
      disque</link>, contient une courte explication sur les
      différents systèmes de chiffrage.</para>

    <sect2>
      <title>Pourquoi l'espace de pagination devrait être
	chiffré?</title>

      <para>Comme pour le chiffrage des partitions d'un disque,
	chiffrer l'espace de pagination a pour but la protection des
	informations sensibles.  Imaginez une application qui, par
	exemple, traite des mots de passe.  Tant que ces mots de passe
	résident en mémoire tout va pour le mieux.
	Cependant, si le système d'exploitation commence
	&agrave; transférer des pages mémoires vers
	l'espace de pagination en vue de libérer de la
	mémoire pour d'autres applications, les mots de passe
	peuvent être écrits en clair sur les plateaux du
	disque et seront faciles &agrave; récupérer par
	une personne malveillante.  Chiffrer l'espace de pagination
	peut être une solution contre ce scénario.</para>
    </sect2>

    <sect2>
      <title>Préparation</title>

      <note>
	<para>Pour le reste de cette section,
	  <filename>ad0s1b</filename> sera la partition
	  réservée &agrave; l'espace de
	  pagination.</para>
      </note>

      <para>Jusqu'ici l'espace de pagination n'a jamais
	été chiffré.  Il est fort possible qu'il
	y ait déj&agrave; des mots de passe ou toute autre
	donnée sensible de présents en clair sur les
	plateaux du disque.  Afin d'y remédier, les
	données de la partition de pagination doivent
	être écrasées avec des données
	aléatoires:</para>

      <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/ad0s1b bs=1m</userinput></screen>
    </sect2>

    <sect2>
      <title>Chiffrer de l'espace de pagination avec
	&man.gbde.8;</title>

      <para>Si &os; 6.0-RELEASE ou une version plus récente est
	utilisée, le suffixe <literal>.bde</literal> doit
	être ajouté au nom de périphérique
	sur la ligne du fichier <filename>/etc/fstab</filename>
	correspondant &agrave; cet espace de pagination:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0</programlisting>

      <para>Pour les systèmes antérieurs &agrave; &os;
	6.0-RELEASE, la ligne suivante doit également
	être ajoutée &agrave;
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>gbde_swap_enable="YES"</programlisting>
    </sect2>

    <sect2>
      <title>Chiffrage de l'espace de pagination avec
	&man.geli.8;</title>

      <para>La procédure pour le chiffrage de l'espace de
	pagination avec &man.geli.8; est similaire &agrave; celle pour
	l'utilisation de &man.gbde.8;.  Le suffixe
	<literal>.eli</literal> doit être ajouté au nom
	de périphérique sur la ligne du fichier
	<filename>/etc/fstab</filename> correspondant &agrave; cet
	espace de pagination:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0</programlisting>

      <para>Par défaut, &man.geli.8; utilise l'algorithme
	<acronym>AES</acronym> avec une longueur de clé de
	256bits.</para>

      <para>Les valeurs par défaut peuvent être
	modifiées en utilisant l'option
	<literal>geli_swap_flags</literal> dans le fichier
	<filename>/etc/rc.conf</filename>.  La ligne suivante demande
	&agrave; la procédure rc.d <filename>encswap</filename>
	de créer des partitions de pagination en utilisant
	l'algorithme Blowfish avec une clé de 128 bits de
	longueur, une taille de secteur de 4 kilo-octets et avec
	l'option <quote>detach on last close</quote> (détacher
	après démontage de la partition)
	activée:</para>

      <programlisting>geli_swap_flags="-a blowfish -l 128 -s 4096 -d"</programlisting>

      <para>Veuillez vous référer &agrave; la
	description de la commande <command>onetime</command> dans la
	page de manuel &man.geli.8; pour une liste des options
	possibles.</para>
    </sect2>

    <sect2>
      <title>Vérifier que cela fonctionne</title>

      <para>Une fois que le système a été
	redémarré, le fonctionnement correct de l'espace
	de pagination peut être vérifié en
	utilisant la commande <command>swapinfo</command>.</para>

      <para>Si &man.gbde.8; est utilisé:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%</screen>

      <para>Si &man.geli.8; est utilisé:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%</screen>
    </sect2>
  </sect1>
</chapter>
