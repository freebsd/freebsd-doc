<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.152
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>R&eacute;&eacute;crit par </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>Quelques bases d'UNIX</title>
  &trans.a.fonvieille;

  <sect1 id="basics-synopsis">
    <title>Synopsis</title>

   <para>Le chapitre suivant couvrira les commandes et fonctionnalit&eacute;s
     de base du syst&egrave;me d'exploitation FreeBSD.  La plupart de ces
     informations sera valable pour n'importe quel syst&egrave;me
     d'exploitation &unix;.  Soyez libre de passer ce chapitre si vous
     &ecirc;tes familier avec ces informations.  Si vous &ecirc;tes nouveau
     &agrave;
     FreeBSD, alors vous voudrez certainement lire attentivement ce
     chapitre.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous saurez:</para>

    <itemizedlist>
      <listitem>
	<para>Comment utiliser les &ldquo;consoles virtuelles&rdquo;
	  de &os;.</para>
      </listitem>
      <listitem>
	<para>Comment les permissions des fichiers d'&unix;
	  fonctionnent ainsi que l'utilisation des indicateurs de
	  fichiers sous &os;.</para>
      </listitem>
      <listitem>
	<para>L'architecture par d&eacute;faut du syst&egrave;me de
	  fichiers sous &os;.</para>
      </listitem>
      <listitem>
	<para>L'organisation des disques sous &os;.</para>
      </listitem>
      <listitem>
	<para>Comment monter et d&eacute;monter des syst&egrave;mes de
	  fichier.</para>
      </listitem>
      <listitem>
	<para>Ce que sont les processus, daemons et signaux.</para>
      </listitem>
      <listitem>
	<para>Ce qu'est un interpr&eacute;teur de commande, et comment
	  changer votre environnement de session par
	  d&eacute;faut.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les &eacute;diteurs de texte de base.</para>
      </listitem>
      <listitem>
	<para>Ce que sont les p&eacute;riph&eacute;riques et les
	  fichiers sp&eacute;ciaux de p&eacute;riph&eacute;rique.</para>
      </listitem>
      <listitem>
	<para>Quel est le format des binaires utilis&eacute; sous
	  &os;.</para>
      </listitem>
      <listitem>
	<para>Comment lire les pages de manuel pour plus
	  d'information.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Consoles virtuelles &amp; terminaux</title>
    <indexterm><primary>consoles virtuelles</primary></indexterm>
    <indexterm><primary>terminaux</primary></indexterm>

    <para>FreeBSD peut &ecirc;tre utilis&eacute; de diverses fa&ccedil;ons.
      L'une d'elles est en tapant des commandes sur un terminal
      texte.  Une bonne partie de la flexibilit&eacute; et de la puissance
      d'un syst&egrave;me d'exploitation &unix; est directement
      disponible sous vos mains en utilisant FreeBSD de cette mani&egrave;re.
      Cette section d&eacute;crit ce que sont les &ldquo;terminaux&rdquo; et
      les &ldquo;consoles&rdquo;, et comment les utiliser sous
      FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>La console</title>
      <indexterm><primary>console</primary></indexterm>

      <para>Si vous n'avez pas configur&eacute; FreeBSD pour lancer
	automatiquement un environnement graphique au d&eacute;marrage, le
	syst&egrave;me vous pr&eacute;sentera une invite d'ouverture de session
	apr&egrave;s son d&eacute;marrage, juste apr&egrave;s la fin des
	proc&eacute;dures de d&eacute;marrage.  Vous verrez quelque chose
	de similaire &agrave;:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Les messages pourront &ecirc;tre diff&eacute;rents sur votre
	syst&egrave;me, mais cela devrait y ressembler.  Les deux
	derni&egrave;res lignes sont celles qui nous int&eacute;ressent
	actuellement.  La seconde de ces lignes nous donne:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Cette ligne contient quelques &eacute;l&eacute;ments d'information
	sur le syst&egrave;me que vous venez de d&eacute;marrer.  Vous
	&ecirc;tes en train de lire une console &ldquo;FreeBSD&rdquo;,
	tournant sur un processeur Intel ou compatible de la famille
	x86<footnote>
	  <para>C'est ce que signifie <literal>i386</literal>.  Notez
	    que m&ecirc;me si vous ne faites pas tourner FreeBSD sur un CPU Intel
	    386, cela sera <literal>i386</literal>.  Ce n'est pas le
	    type de votre microprocesseur, mais
	    &ldquo;l'architecture&rdquo; du microprocesseur qui est
	    donn&eacute;e ici.</para>
	</footnote>.  Le nom de cette machine (chaque machine &unix;
	a un nom) est <hostid>pc3.example.org</hostid>, et vous
	regardez actuellement sa console syst&egrave;me&mdash;le terminal
	<devicename>ttyv0</devicename>.</para>

      <para>Et enfin, la derni&egrave;re ligne est toujours:</para>

      <programlisting>login:</programlisting>

      <para>C'est le moment o&ugrave; vous &ecirc;tes suppos&eacute;
	taper votre &ldquo;nom d'utilisateur&rdquo; pour vous
	attacher au syst&egrave;me FreeBSD.  La section suivante d&eacute;crit
	comment proc&eacute;der.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Ouvrir une session sur un syst&egrave;me FreeBSD</title>

      <para>FreeBSD est un syst&egrave;me multi-utilisateur,
	multi-processeur.  C'est la description formelle qui est
	habituellement donn&eacute;e pour un syst&egrave;me qui peut
	&ecirc;tre utilis&eacute; par diff&eacute;rentes personnes,
	qui ex&eacute;cutent simultan&eacute;ment de nombreux programmes sur une
	machine individuelle.</para>

      <para>Chaque syst&egrave;me multi-utilisateur a besoin d'un moyen pour
	distinguer un &ldquo;utilisateur&rdquo; du reste.  Sous
	FreeBSD (et sous tous les syst&egrave;mes de type &unix;),
	cela est effectu&eacute; en demandant &agrave; chaque utilisateur de
	&ldquo;s'attacher&rdquo; au syst&egrave;me avant d'&ecirc;tre en
	mesure d'ex&eacute;cuter des programmes.  Chaque utilisateur
	poss&egrave;de un nom unique (le nom d'utilisateur) et une cl&eacute;
	secr&egrave;te personnelle (le mot de passe).  FreeBSD demandera ces
	deux &eacute;l&eacute;ments avant d'autoriser un utilisateur &agrave;
	lancer un programme.</para>

      <indexterm><primary>proc&eacute;dures de d&eacute;marrage</primary></indexterm>
      <para>Juste apr&egrave;s que FreeBSD ait d&eacute;marr&eacute; et
	en ait termin&eacute; avec l'ex&eacute;cution des proc&eacute;dures de
	d&eacute;marrage<footnote>
	  <para>Les proc&eacute;dures de d&eacute;marrage sont des programmes
	    qui sont ex&eacute;cut&eacute;s automatiquement par FreeBSD au
	    d&eacute;marrage.  Leur fonction principale est de configurer le
	    syst&egrave;me pour permettre l'ex&eacute;cution de tout programme,
	    et de d&eacute;marrer tout service que vous avez configur&eacute; pour
	    tourner en t&acirc;che de fond et ex&eacute;cuter des choses
	    utiles.</para>
	</footnote>, il pr&eacute;sentera une invite et demandera un nom
	d'utilisateur valide:</para>

      <screen>login:</screen>

      <para>Pour cet exemple, supposons que votre nom d'utilisateur
	est <username>john</username>.  Tapez
	<username>john</username> &agrave; cette invite puis appuyez sur
	<keycap>Entr&eacute;e</keycap>.  Alors vous devrez &ecirc;tre
	invit&eacute; &agrave; entrer un &ldquo;mot de passe&rdquo;:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Tapez maintenant le mot de passe de <username>john</username>,
	et appuyez sur <keycap>Entr&eacute;e</keycap>.  Le mot de passe
	<emphasis>n'est pas affich&eacute;!</emphasis>  Vous n'avez pas &agrave;
	vous pr&eacute;occuper de cela maintenant.  Il suffit de penser que
	cela est fait pour des raisons de s&eacute;curit&eacute;.</para>

      <para>Si vous avez tap&eacute; correctement votre mot de passe,
	vous devriez &ecirc;tre maintenant attach&eacute;
	au syst&egrave;me et pr&ecirc;t &agrave; essayer toutes les commandes
	disponibles.</para>

      <para>Vous devriez voir appara&icirc;tre le <acronym>MOTD</acronym>
	ou message du jour suivi de l'invite de commande (un
	caract&egrave;re <literal>#</literal>, <literal>$</literal>, ou
	<literal>%</literal>).  Cela indique que vous avez ouvert
	avec succ&egrave;s une session sous &os;.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Consoles multiples</title>

      <para>Ex&eacute;cuter des commandes &unix; dans une console est bien
	beau, mais FreeBSD peut ex&eacute;cuter plusieurs programmes
	&agrave; la fois.  Avoir une seule console sur laquelle les commandes
	peuvent &ecirc;tre tap&eacute;es serait un peu du gaspillage quand
	un syst&egrave;me d'exploitation comme FreeBSD peut ex&eacute;cuter des
	dizaines de programmes en m&ecirc;me temps.  C'est ici que des
	&ldquo;consoles virtuelles&rdquo; peuvent &ecirc;tre vraiment
	utiles.</para>

      <para>FreeBSD peut &ecirc;tre configur&eacute; pour pr&eacute;senter
	de nombreuses consoles virtuelles.  Vous pouvez basculer
	d'une console virtuelle &agrave; une autre en utilisant une
	combinaison de touches sur votre clavier.  Chaque console
	a son propre canal de sortie, et FreeBSD prend soin de
	rediriger correctement les entr&eacute;es au clavier et la sortie
	vers &eacute;cran quand vous basculez d'une console virtuelle &agrave;
	la suivante.</para>

      <para>Des combinaisons de touches sp&eacute;cifiques ont
	&eacute;t&eacute; r&eacute;serv&eacute;es par FreeBSD pour le
	basculement entre consoles<footnote>
	  <para>Une description assez technique et pr&eacute;cise de tous
	    les d&eacute;tails de la console FreeBSD et des pilotes de
	    clavier peut &ecirc;tre trouv&eacute;e dans les pages de manuel de
	    &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1;
	    et &man.kbdcontrol.1;.  Nous ne nous &eacute;tendrons pas
	    en d&eacute;tails ici, mais le lecteur int&eacute;ress&eacute; peut
	    toujours consulter les pages de manuel pour explication plus
	    d&eacute;taill&eacute;e et plus compl&egrave;te sur le
	    fonctionnement des choses.</para>
	</footnote>.  Vous pouvez utiliser
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>,
	jusqu'&agrave;
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	pour basculer vers une console virtuelle diff&eacute;rente sous
	FreeBSD.</para>

      <para>Quand vous basculez d'une console &agrave; une autre, FreeBSD
	prend soin de sauvegarder et restaurer la sortie d'&eacute;cran.
	Il en r&eacute;sulte l'&ldquo;illusion&rdquo; d'avoir plusieurs
	&eacute;crans et claviers &ldquo;virtuels&rdquo; que vous pouvez
	utiliser pour taper des commandes pour FreeBSD.  Les
	programmes que vous lancez sur une console virtuelle ne
	cessent pas de tourner quand cette console n'est plus visible.
	Ils continuent de s'ex&eacute;cuter quand vous avez
	bascul&eacute; vers une console virtuelle diff&eacute;rente.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>Le fichier <filename>/etc/ttys</filename></title>

      <para>La configuration par d&eacute;faut de FreeBSD d&eacute;marre avec huit
	consoles virtuelles.  Cependant ce n'est pas un param&eacute;trage
	fixe, et vous pouvez ais&eacute;ment personnaliser votre installation
	pour d&eacute;marrer avec plus ou moins de consoles virtuelles.  Le
	nombre et les param&eacute;trages des consoles virtuelles sont
	configur&eacute;s dans le fichier
	<filename>/etc/ttys</filename>.</para>

      <para>Vous pouvez utiliser le fichier
	<filename>/etc/ttys</filename> pour configurer les consoles
	virtuelles de FreeBSD.  Chaque ligne non-comment&eacute;e dans ce fichier
	(les lignes qui ne d&eacute;butent pas par le caract&egrave;re
	<literal>#</literal>) contient le param&eacute;trage d'un terminal ou
	d'une console virtuelle.  La version par d&eacute;faut de ce
	fichier livr&eacute;e avec FreeBSD configure neuf consoles virtuelles,
	et en active huit.  Ce sont les lignes commen&ccedil;ant avec le terme
	<literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Pour une description d&eacute;taill&eacute;e de chaque colonne
	de ce fichier et toutes les options que vous pouvez utiliser
	pour configurer les consoles virtuelles, consultez la page de
	manuel &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Console en mode mono-utilisateur</title>

      <para>Une description d&eacute;taill&eacute;e de ce qu'est
	<quote>le mode mono-utilisateur</quote> peut &ecirc;tre
	trouv&eacute;e dans <xref linkend="boot-singleuser">.  Il est
	important de noter qu'il n'y a qu'une console de disponible
	quand vous ex&eacute;cutez FreeBSD en mode mono-utilisateur.  Il n'y
	a aucune console virtuelle de disponible.  Le param&eacute;trage de
	la console en mode mono-utilisateur peut &ecirc;tre
	&eacute;galement trouv&eacute; dans le fichier
	<filename>/etc/ttys</filename>.  Recherchez la ligne qui
	commence avec le mot <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para>Comme l'indiquent les commentaires au-dessus de la ligne
	  <literal>console</literal>, vous pouvez &eacute;diter cette ligne
	  et changer <literal>secure</literal> pour
	  <literal>insecure</literal>.  Si vous faites cela, quand
	  FreeBSD d&eacute;marrera en mode mono-utilisateur, il demandera le
	  mot de passe de <username>root</username>.</para>

	<para><emphasis>Cependant faites attention quand vous modifiez
	  cela pour <literal>insecure</literal>.</emphasis>  Si vous
	  oubliez le mot de passe de <username>root</username>, le
	  d&eacute;marrage en mode mono-utilisateur sera condamn&eacute;.
	  Il est encore possible, mais cela pourra &ecirc;tre relativement
	  compliqu&eacute; pour quelqu'un qui n'est pas &agrave; l'aise avec le
	  processus de d&eacute;marrage de FreeBSD et les programmes entrant
	  en jeu.</para>
      </note>
    </sect2>

    <sect2 id="consoles-vidcontrol">
      <title>Modifier la r&eacute;solution de la console</title>

      <para>La r&eacute;solution (ou encore le mode vid&eacute;o) de
	la console &os; peut &ecirc;tre r&eacute;gl&eacute;e &agrave;
	1024x768, 1280x1024, ou tout autre r&eacute;solution
	support&eacute;e par le circuit graphique et le moniteur.
	Pour utiliser une r&eacute;solution vid&eacute;o
	diff&eacute;rente vous devez en premier lieu recompiler votre
	noyau en ajoutant deux options suppl&eacute;mentaires:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>Une fois votre noyau recompil&eacute; avec ces deux
	options, vous pouvez d&eacute;terminer quels sont les modes
	vid&eacute;o support&eacute;s par votre mat&eacute;riel en
	utilisant l'outil &man.vidcontrol.1;.  Pour obtenir une liste
	des modes support&eacute;s, tapez la ligne suivante:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>La sortie de cette commande est une liste des modes
	vid&eacute;o que supporte votre mat&eacute;riel.  Vous pouvez
	ensuite d&eacute;cider d'utiliser un nouveau mode en le
	passant &agrave; la commande &man.vidcontrol.1; tout en ayant
	les droits de <username>root</username>:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Si le nouveau mode vid&eacute;o est satisfaisant, il peut
	&ecirc;tre activ&eacute; au d&eacute;marrage de mani&egrave;re
	permanente en le configurant dans le fichier
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Permissions</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, &eacute;tant un descendant direct de l'&unix; BSD, est
      bas&eacute; sur plusieurs concepts cl&eacute;s d'&unix;.  Le premier,
      et le plus prononc&eacute;, est le fait que FreeBSD est un
      syst&egrave;me d'exploitation multi-utilisateurs.  Le syst&egrave;me
      peut g&eacute;rer plusieurs utilisateurs travaillant tous
      simultan&eacute;ment sur des t&acirc;ches compl&egrave;tement
      ind&eacute;pendantes.  Le syst&egrave;me est responsable du partage
      correct et de la gestion des requ&ecirc;tes pour les
      p&eacute;riph&eacute;riques mat&eacute;riels, la m&eacute;moire,
      et le temps CPU de fa&ccedil;on &eacute;quitable entre chaque
      utilisateur.</para>

    <para>Puisque le syst&egrave;me est capable de supporter des utilisateurs
      multiples, tout ce que le syst&egrave;me g&egrave;re poss&egrave;de un
      ensemble de permissions d&eacute;finissant qui peut &eacute;crire, lire,
      et ex&eacute;cuter la ressource.  Ces permissions sont stock&eacute;es
      sous forme de trois octets divis&eacute;s en trois parties, une pour le
      propri&eacute;taire du fichier, une pour le groupe auquel appartient le
      fichier, et une autre pour le reste du monde.
      Cette repr&eacute;sentation num&eacute;rique fonctionne comme
      ceci:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>permissions de fichier</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valeur</entry>
	    <entry>Permission</entry>
	    <entry>Contenu du r&eacute;pertoire</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Pas d'acc&egrave;s en lecture, pas d'acc&egrave;s en
	      &eacute;criture,
	      pas d'acc&egrave;s en ex&eacute;cution</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Pas d'acc&egrave;s en lecture, pas d'acc&egrave;s en
	      &eacute;criture, ex&eacute;cution</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Pas d'acc&egrave;s en lecture, &eacute;criture, pas
	      d'acc&egrave;s en ex&eacute;cution</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Pas d'acc&egrave;s en lecture, &eacute;criture,
	      ex&eacute;cution</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lecture, pas d'acc&egrave;s en &eacute;criture, pas
	      d'acc&egrave;s en ex&eacute;cution</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lecture, pas d'acc&egrave;s en &eacute;criture,
	      ex&eacute;cution</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lecture, &eacute;criture, pas d'acc&egrave;s en
	      ex&eacute;cution</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lecture, &eacute;criture, ex&eacute;cution</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>r&eacute;pertoires</primary></indexterm>

    <para>Vous pouvez utiliser l'option <option>-l</option> avec la
      commande &man.ls.1; pour afficher le contenu du r&eacute;pertoire
      sous forme une longue et d&eacute;taill&eacute;e qui inclut une colonne
      avec des informations sur les permissions d'acc&egrave;s des fichiers
      pour le propri&eacute;taire, le groupe, et le reste du monde.
      Par exemple un <command>ls -l</command> dans un r&eacute;pertoire
      quelconque devrait donner:</para>

   <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Voici
      comment est divis&eacute;e la premi&egrave;re colonne de l'affichage
      g&eacute;n&eacute;r&eacute; par <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>Le premier caract&egrave;re (le plus &agrave; gauche) indique
      si c'est un fichier normal, un r&eacute;pertoire, ou
      un p&eacute;riph&eacute;rique mode caract&egrave;re,
      une socket, ou tout autre pseudo-p&eacute;riph&eacute;rique.
      Dans ce cas, <literal>-</literal>
      indique un fichier normal.  Les trois caract&egrave;res suivants,
      <literal>rw-</literal> dans cet exemple, donnent les
      permissions pour le propri&eacute;taire du fichier.  Les trois
      caract&egrave;res qui suivent, <literal>r--</literal>, donnent les
      permissions pour le groupe auquel appartient le fichier.
      Les trois derniers caract&egrave;res, <literal>r--</literal>,
      donnent les permissions pour le reste du
      monde. Un tiret signifie que la permission est d&eacute;sactiv&eacute;e.
      Dans le cas de ce fichier, les permissions sont telles que le
      propri&eacute;taire peut lire et &eacute;crire le fichier, le groupe
      peut lire le fichier, et le reste du monde peut seulement lire le fichier.
      D'apr&egrave;s la table ci-dessus, les permissions pour ce fichier
      seraient <literal>644</literal>, o&ugrave; chaque chiffre
      repr&eacute;sente les
      trois parties des permissions du fichier.</para>

    <para>Tout cela est bien beau, mais comment le syst&egrave;me
      contr&ocirc;le les permissions sur les p&eacute;riph&eacute;riques?
      En fait FreeBSD traite la plupart des p&eacute;riph&eacute;riques
      sous la forme d'un fichier que les programmes peuvent ouvrir, lire,
      et &eacute;crire des donn&eacute;es dessus comme tout autre fichier.
      Ces p&eacute;riph&eacute;riques sp&eacute;ciaux sont stock&eacute;s
      dans le r&eacute;pertoire <filename>/dev</filename>.</para>

    <para>Les r&eacute;pertoires sont aussi trait&eacute;s comme des fichiers.
      Ils ont des droits en lecture, &eacute;criture et ex&eacute;cution.
      Le bit d'ex&eacute;cution pour un r&eacute;pertoire a une signification
      l&eacute;g&egrave;rement diff&eacute;rente que pour les fichiers.
      Quand un r&eacute;pertoire est marqu&eacute; ex&eacute;cutable, cela
      signifie qu'il peut &ecirc;tre travers&eacute;, i.e. il est possible
      d'utiliser &ldquo;cd&rdquo; (changement de r&eacute;pertoire).  Ceci signifie &eacute;galement qu'&agrave;
      l'int&eacute;rieur du r&eacute;pertoire il est possible d'acc&eacute;der
      aux fichiers dont les noms sont connus (en fonction, bien s&ucirc;r,
      des permissions sur les fichiers eux-m&ecirc;mes).</para>

    <para>En particulier, afin d'obtenir la liste du
      contenu d'un r&eacute;pertoire, la permission de lecture doit &ecirc;tre
      positionn&eacute;e sur le r&eacute;pertoire, tandis que pour effacer un
      fichier dont on conna&icirc;t le nom, il est n&eacute;cessaire d'avoir
      les droits d'&eacute;criture <emphasis>et</emphasis> d'ex&eacute;cution
      sur le r&eacute;pertoire contenant le fichier.</para>

    <para>Il y a d'autres types de permissions, mais elles sont
      principalement employ&eacute;es dans des circonstances
      sp&eacute;ciales comme les binaires &ldquo;setuid&rdquo; et
      les r&eacute;pertoires &ldquo;sticky&rdquo;.  Si
      vous d&eacute;sirez plus d'information sur les permissions de fichier et
      comment les positionner, soyez s&ucirc;r de consulter la page de manuel
      &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribution de </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Permissions symboliques</title>
      <indexterm><primary>permissions</primary><secondary>symboliques</secondary></indexterm>

      <para>Les permissions symboliques, parfois d&eacute;sign&eacute;es
	sous le nom d'expressions symboliques, utilisent des
	caract&egrave;res &agrave; la place de valeur en octal pour
	assigner les permissions aux fichiers et r&eacute;pertoires.
	Les expressions symboliques emploient la syntaxe: (qui)
	(action) (permissions), avec les valeurs possibles
	suivantes:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Lettre</entry>
	      <entry>Repr&eacute;sente</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(qui)</entry>
	    <entry>u</entry>
	    <entry>Utilisateur</entry>
	  </row>

	  <row>
	    <entry>(qui)</entry>
	    <entry>g</entry>
	    <entry>Groupe</entry>
	  </row>

	  <row>
	    <entry>(qui)</entry>
	    <entry>o</entry>
	    <entry>Autre</entry>
	  </row>

	  <row>
	    <entry>(qui)</entry>
	    <entry>a</entry>
	    <entry>Tous (<quote>le monde entier</quote>)</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>+</entry>
	    <entry>Ajouter des permissions</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>-</entry>
	    <entry>Retirer des permissions</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>=</entry>
	    <entry>Fixe les permissions de fa&ccedil;on explicite</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>r</entry>
	    <entry>Lecture</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>w</entry>
	    <entry>Ecriture</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>x</entry>
	    <entry>Ex&eacute;cution</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>t</entry>
	    <entry>bit collant (sticky)</entry>
	  </row>

	  <row>
	    <entry>(permissions)</entry>
	    <entry>s</entry>
	    <entry>Ex&eacute;cuter avec l'ID utilisateur (UID) ou groupe (GID)</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Ces valeurs sont utilis&eacute;es avec la commande
      &man.chmod.1; comme pr&eacute;c&eacute;demment mais avec
      des lettres.  Par exemple, vous pourriez utiliser la commande
      suivante pour refuser l'acc&egrave;s au fichier
      <replaceable>FICHIER</replaceable> &agrave; d'autres
      utilisateurs:</para>

    <screen>&prompt.user; <userinput>chmod go= FICHIER</userinput></screen>

    <para>Une liste s&eacute;par&eacute; par des virgules peut &ecirc;tre
      fournie quand plus d'un changement doit &ecirc;tre effectu&eacute;
      sur un fichier.  Par exemple la commande suivante retirera
      les permissions d'&eacute;criture au groupe et au &ldquo;reste du
      monde&rdquo; sur le fichier <replaceable>FICHIER</replaceable>,
      puis ajoutera la permission d'ex&eacute;cution pour tout le
      monde:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FICHIER</replaceable></userinput></screen>

<!--
    <para>La plupart des utilisateurs ne rel&egrave;veront pas ceci,
      mais il doit &ecirc;tre pr&eacute;cis&eacute; que la
      m&eacute;thode avec les nombres en octal ne fera que fixer ou
      assigner des permissions &agrave; un fichier; elle n'en ajoutera
      ou n'en supprimera pas.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribution de </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Indicateurs des fichiers sous &os;</title>

      <para>En addition des permissions sur les fichiers
	pr&eacute;c&eacute;demment pr&eacute;sent&eacute;es, &os;
	supporte l'utilisation d'<quote>indicateurs de
	fichiers</quote>.  Ces indicateurs rajoutent un niveau de
	contr&ocirc;le et de s&eacute;curit&eacute; sur les fichiers,
	mais ne concernent pas les r&eacute;pertoires.</para>

      <para>Ces indicateurs ajoutent donc un niveau de contr&ocirc;le
	suppl&eacute;mentaire des fichiers, permettant d'assurer que
	dans certains cas m&ecirc;me le super-utilisateur
	<username>root</username> ne pourra effacer ou modifier des
	fichiers.</para>

      <para>Les indicateurs de fichiers peuvent &ecirc;tre
	modifi&eacute;s avec l'utilitaire &man.chflags.1;, ce dernier
	pr&eacute;sentant une interface simple.  Par exemple, pour
	activer l'indicateur syst&egrave;me de suppression impossible
	sur le fichier <filename>file1</filename>, tapez la commande
	suivante:</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>file1</filename></userinput></screen>

      <para>Et pour d&eacute;sactiver l'indicateur de suppression
	impossible, utilisez la commande pr&eacute;c&eacute;dente avec
	le pr&eacute;fixe <quote>no</quote> devant l'option
	<option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>file1</filename></userinput></screen>

      <para>Pour afficher les indicateurs propres &agrave; ce fichier,
	utilisez la commande &man.ls.1; avec l'option
	<option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>file1</filename>
	</userinput></screen>

      <para>La sortie de la commande devrait ressembler
	&agrave;:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Plusieurs indicateurs ne peuvent &ecirc;tre
	positionn&eacute;s ou retir&eacute;s que par le
	super-utilisateur <username>root</username>.  Dans les autres
	cas, le propri&eacute;taire du fichier peut activer ces
	indicateurs.  Pour plus d'information, la lecture des pages de
	manuel &man.chflags.1; et &man.chflags.2; est
	recommand&eacute;e &agrave; tout administrateur.</para>
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>Organisation de l'arborescence des r&eacute;pertoires</title>
    <indexterm><primary>hi&eacute;rarchie des r&eacute;pertoires</primary></indexterm>

    <para>L'organisation de l'arborescence des r&eacute;pertoires de FreeBSD
      est essentielle pour obtenir une compr&eacute;hension globale du
      syst&egrave;me.  Le concept le plus important &agrave; saisir est
      celui du r&eacute;pertoire racine, &ldquo;/&rdquo;.
      Ce r&eacute;pertoire est le premier a &ecirc;tre mont&eacute; au
      d&eacute;marrage et il contient le syst&egrave;me de base
      n&eacute;cessaire pour pr&eacute;parer le syst&egrave;me d'exploitation
      au fonctionnement multi-utilisateurs.
      Le r&eacute;pertoire racine contient &eacute;galement les
      points de montage pour les autres syst&egrave;mes de fichiers qui
      sont mont&eacute;s lors du passage en mode multi-utilisateurs.</para>

    <para>Un point de montage est un r&eacute;pertoire o&ugrave; peuvent
      &ecirc;tre greff&eacute;s des syst&egrave;mes de fichiers
      suppl&eacute;mentaires au syst&egrave;me de
      fichiers parent (en g&eacute;n&eacute;ral le syst&egrave;me de fichiers racine).  Cela est d&eacute;crit plus en d&eacute;tails dans la <xref linkend="disk-organization">.  Les points de montage standards incluent
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>,
      <filename>/mnt</filename>, et <filename>/cdrom</filename>.  Ces
      r&eacute;pertoires sont en g&eacute;n&eacute;ral
      r&eacute;f&eacute;renc&eacute;s par des entr&eacute;es dans le
      fichier <filename>/etc/fstab</filename>.
      <filename>/etc/fstab</filename> est une table des divers syst&egrave;mes
      de fichiers et de leur point de montage utilis&eacute; comme
      r&eacute;f&eacute;rence par le syst&egrave;me.
      La plupart des syst&egrave;mes de fichiers pr&eacute;sents dans
      <filename>/etc/fstab</filename> sont mont&eacute;s automatiquement au
      moment du d&eacute;marrage par la proc&eacute;dure &man.rc.8; &agrave;
      moins que
      l'option <option>noauto</option> soit pr&eacute;sente.
      Plus de d&eacute;tails peuvent &ecirc;tre trouv&eacute;s dans la
      <xref linkend="disks-fstab">.</para>

    <para>Une description compl&egrave;te de l'arborescence du syst&egrave;me de
      fichiers est disponible dans la page de manuel &man.hier.7;.  Pour
      l'instant, une br&egrave;ve vue d'ensemble des r&eacute;pertoires les plus
      courants suffira.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>R&eacute;pertoire</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>R&eacute;pertoire racine du syst&egrave;me de
		fichiers.</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Programmes utilisateur fondamentaux aux deux modes
		de fonctionnement mono et multi-utilisateurs.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Programmes et fichiers de configuration utilis&eacute;s
		durant le processus de d&eacute;marrage du
		syst&egrave;me.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Fichiers de configuration par d&eacute;faut du processus
		de d&eacute;marrage; voir la page de manuel
		&man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Fichiers sp&eacute;ciaux de p&eacute;riph&eacute;rique;
		voir la page de manuel &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Proc&eacute;dures et fichiers de configuration du
		syst&egrave;me.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Fichiers de configuration du syst&egrave;me par
		d&eacute;faut; voir la page de manuel &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Fichiers de configuration pour les agents de
		transport du courrier &eacute;lectronique comme
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Fichiers de configuration de <command>named</command>;
		voir la page de manuel &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>Proc&eacute;dures qui sont ex&eacute;cut&eacute;es de
		fa&ccedil;on quotidienne, hebdomadaire et mensuelle par
		l'interm&eacute;diaire de &man.cron.8;;
		voir la page de manuel &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Fichiers de configuration de <command>ppp</command>; voir
		la page de manuel &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>R&eacute;pertoire vide habituellement utilis&eacute;
		par les administrateurs syst&egrave;me comme un point de
		montage temporaire.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Le syst&egrave;me de fichiers pour les processus; voir les
		pages de manuel &man.procfs.5;, &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
	      <entry>Programmes li&eacute;s en statique pour les
		r&eacute;parations d'urgence; consultez la page de
		manuel &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>R&eacute;pertoire personnel du compte
		<username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Programmes syst&egrave;mes et utilitaires syst&egrave;mes
		fondamentaux aux environnements mono et multi-utilisateurs.
		</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Fichiers temporaires.
		Le contenu de <filename class="directory">/tmp</filename>
		n'est en g&eacute;n&eacute;ral PAS pr&eacute;serv&eacute;
		par un red&eacute;marrage du syst&egrave;me.  Un
		syst&egrave;me de fichiers en m&eacute;moire est
		souvent mont&eacute; sur <filename
		class="directory">/tmp</filename>.  Cela peut
		&ecirc;tre automatis&eacute; en utilisant les
		variables &man.rc.conf.5; relatives au syst&egrave;me
		<quote>tmpmfs</quote> (ou &agrave; l'aide d'une
		entr&eacute;e dans le fichier
		<filename>/etc/fstab</filename>; consultez la page de
		manuel &man.mdmfs.8;).</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>La majorit&eacute; des utilitaires et applications
		utilisateur.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Utilitaires g&eacute;n&eacute;raux, outils de
		programmation, et applications.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Fichiers d'en-t&ecirc;te C standard.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Ensemble des biblioth&egrave;ques.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Divers fichiers de donn&eacute;es de service.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>Utilitaires et daemons syst&egrave;me
		(ex&eacute;cut&eacute;s par d'autres programmes).</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Ex&eacute;cutables, biblioth&egrave;ques, etc...  Egalement
		utilis&eacute; comme destination de d&eacute;faut pour les
		logiciels port&eacute;s pour FreeBSD.  Dans
		<filename>/usr/local</filename>, l'organisation
		g&eacute;n&eacute;rale
		d&eacute;crite par la page de manuel &man.hier.7; pour
		<filename>/usr</filename> devrait &ecirc;tre utilis&eacute;e.
		Exceptions faites du r&eacute;pertoire man qui est directement
		sous <filename>/usr/local</filename> plut&ocirc;t que sous
		<filename>/usr/local/share</filename>, et la
		documentation des logiciels port&eacute;s est dans
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Arborescence cible sp&eacute;cifique &agrave; une
		architecture produite par la compilation de l'arborescence
		<filename>/usr/src</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>Le catalogue des logiciels port&eacute;s
		(optionnel).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>Utilitaires et daemons syst&egrave;me
		(ex&eacute;cut&eacute;s par les utilisateurs).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Fichiers ind&eacute;pendants de l'architecture.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Fichiers source FreeBSD et/ou locaux.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Ex&eacute;cutables, biblioth&egrave;ques etc... de la
		distribution d'X11R6 (optionnel).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Fichiers de traces, fichiers temporaires, et
		fichiers tampons.  Un syst&egrave;me de fichiers en
		m&eacute;moire est parfois mont&eacute; sur <filename
		class="directory">/var</filename>.  Cela peut
		&ecirc;tre automatis&eacute; en utilisant les
		variables &man.rc.conf.5; relatives au syst&egrave;me
		<quote>varmfs</quote> (ou &agrave; l'aide d'une
		entr&eacute;e dans le fichier
		<filename>/etc/fstab</filename>; consultez la page de
		manuel &man.mdmfs.8;).</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Divers fichiers de trace du syst&egrave;me.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Bo&icirc;tes aux lettres des utilisateurs.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Divers r&eacute;pertoires tampons des syst&egrave;mes
		de courrier &eacute;lectronique et d'impression.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Fichiers temporaires.  Ces fichiers sont
		g&eacute;n&eacute;ralement conserv&eacute;s lors d'un
		red&eacute;marrage du syst&egrave;me, &agrave; moins
		que <filename class="directory">/var</filename> ne
		soit un syst&egrave;me de fichiers en
		m&eacute;moire.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Tables NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
    <title>Organisation des disques</title>

    <para>Le plus petit &eacute;l&eacute;ment qu'utilise FreeBSD pour
      retrouver des fichiers est le nom de fichier.  Les noms de
      fichiers sont sensibles &agrave; la casse des caract&egrave;res,
      ce qui signifie que <filename>readme.txt</filename> et
      <filename>README.TXT</filename> sont deux fichiers
      s&eacute;par&eacute;s.  FreeBSD n'utilise pas l'extension
      (<filename>.txt</filename>) d'un fichier pour d&eacute;terminer
      si ce fichier est un programme, un document ou une autre forme
      de donn&eacute;e.</para>

    <para>Les fichiers sont stock&eacute;s dans des
      r&eacute;pertoires.  Un r&eacute;pertoire peut ne contenir aucun
      fichier, ou en contenir plusieurs centaines.  Un
      r&eacute;pertoire peut &eacute;galement contenir d'autre
      r&eacute;pertoires, vous permettant de construire une
      hi&eacute;rarchie de r&eacute;pertoires &agrave;
      l'int&eacute;rieur d'un autre.  Cela rend plus simple
      l'organisation de vos donn&eacute;es.</para>

    <para>Les fichiers et les r&eacute;pertoires sont
      r&eacute;f&eacute;renc&eacute;s en donnant le nom du fichier ou
      du r&eacute;pertoire, suivi par un slash, <literal>/</literal>,
      suivi par tout nom de r&eacute;pertoire n&eacute;cessaire.  Si
      vous avez un r&eacute;pertoire <filename>foo</filename>, qui
      contient le r&eacute;pertoire <filename>bar</filename>, qui
      contient le fichier <filename>readme.txt</filename>, alors le
      nom complet, ou <firstterm>chemin</firstterm>
      (&ldquo;path&rdquo;) vers le fichier est
      <filename>foo/bar/readme.txt</filename>.</para>

    <para>Les r&eacute;pertoires et les fichiers sont stock&eacute;s
      sur un syst&egrave;me de fichiers.  Chaque syst&egrave;me de
      fichiers contient &agrave; son niveau le plus haut un
      r&eacute;pertoire appel&eacute; <firstterm>r&eacute;pertoire
      racine</firstterm> pour ce syst&egrave;me de fichiers.  Ce
      r&eacute;pertoire racine peut alors contenir les autres
      r&eacute;pertoires.</para>

    <para>Jusqu'ici cela est probablement semblable &agrave; n'importe
      quel autre syst&egrave;me d'exploitation que vous avez pu avoir
      utilis&eacute;.  Il y a quelques diff&eacute;rences: par
      exemple, &ms-dos; utilise <literal>\</literal> pour s&eacute;parer
      les noms de fichier et de r&eacute;pertoire, alors que MacOS
      utilise <literal>:</literal>.</para>

    <para>FreeBSD n'utilise pas de lettre pour les lecteurs, ou
      d'autres noms de disque dans le chemin.  Vous n'&eacute;crirez
      pas <filename>c:/foo/bar/readme.txt</filename> sous
      FreeBSD.</para>

    <para>Au lieu de cela, un syst&egrave;me de fichiers est
      d&eacute;sign&eacute; comme <firstterm>syst&egrave;me de
      fichiers racine</firstterm>.  La racine du syst&egrave;me de
      fichiers racine est repr&eacute;sent&eacute;e par un
      <literal>/</literal>. Tous les autres syst&egrave;mes de
      fichiers sont alors <firstterm>mont&eacute;s</firstterm> sous le
      syst&egrave;me de fichiers racine.  Peu importe le nombre de
      disques que vous avez sur votre syst&egrave;me FreeBSD, chaque
      r&eacute;pertoire appara&icirc;t comme faisant partie du
      m&ecirc;me disque.</para>

    <para>Supposez que vous avez trois syst&egrave;mes de fichiers,
      appel&eacute;s <literal>A</literal>, <literal>B</literal>, et
      <literal>C</literal>.  Chaque syst&egrave;me de fichiers
      poss&egrave;de un r&eacute;pertoire racine, qui contient deux
      autres r&eacute;pertoires, nomm&eacute;s <literal>A1</literal>,
      <literal>A2</literal> (et respectivement <literal>B1</literal>,
      <literal>B2</literal> et <literal>C1</literal>,
      <literal>C2</literal>).</para>

    <para>Appelons <literal>A</literal> le syst&egrave;me de fichiers
      racine.  Si vous utilisiez la commande <command>ls</command>
      pour visualiser le contenu de ce r&eacute;pertoire, vous verriez
      deux sous-r&eacute;pertoires, <literal>A1</literal> et
      <literal>A2</literal>.  L'arborescence des r&eacute;pertoires
      ressemblera &agrave; ceci:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir1" format="EPS">
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Un syst&egrave;me de fichiers doit &ecirc;tre mont&eacute;
      dans un r&eacute;pertoire d'un autre syst&egrave;me de fichiers.
      Supposez maintenant que vous montez le syst&egrave;me de
      fichiers <literal>B</literal> sur le r&eacute;pertoire
      <literal>A1</literal>.  Le r&eacute;pertoire racine de
      <literal>B</literal> remplace <literal>A1</literal>, et les
      r&eacute;pertoires de <literal>B</literal> par cons&eacute;quent
      apparaissent:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir2" format="EPS">
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Tout fichier de <literal>B1</literal> ou
      <literal>B2</literal> peut &ecirc;tre atteint avec le chemin
      <filename>/A1/B1</filename> ou <filename>/A1/B2</filename> si
      n&eacute;cessaire.  Tous les fichiers qui &eacute;taient dans
      <filename>A1</filename> ont &eacute;t&eacute; temporairement
      cach&eacute;s.  Ils r&eacute;appara&icirc;tront si
      <literal>B</literal> est
      <firstterm>d&eacute;mont&eacute;</firstterm> de A.</para>

    <para>Si <literal>B</literal> a &eacute;t&eacute; mont&eacute; sur
      <literal>A2</literal> alors le diagramme sera semblable &agrave;
      celui-ci:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir3" format="EPS">
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>et les chemins seront <filename>/A2/B1</filename> et
      respectivement <filename>/A2/B2</filename>.</para>

    <para>Les syst&egrave;mes de fichiers peuvent &ecirc;tre
      mont&eacute;s au sommet d'un autre.  En continuant l'exemple
      pr&eacute;c&eacute;dent, le syst&egrave;me de fichiers
      <literal>C</literal> pourrait &ecirc;tre mont&eacute; au sommet
      du r&eacute;pertoire <literal>B1</literal> dans le
      syst&egrave;me de fichiers <literal>B</literal>, menant &agrave;
      cet arrangement:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir4" format="EPS">
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>O&ugrave; <literal>C</literal> pourrait &ecirc;tre
      mont&eacute; directement sur le syst&egrave;me de fichiers
      <literal>A</literal>, sous le r&eacute;pertoire
      <literal>A1</literal>:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir5" format="EPS">
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Si vous &ecirc;tes familier de &ms-dos;, ceci est semblable, bien
      que pas identique, &agrave; la commande
      <command>join</command>.</para>

    <para>Ce n'est normalement pas quelque chose qui doit vous
      pr&eacute;occuper.  G&eacute;n&eacute;ralement vous cr&eacute;ez
      des syst&egrave;mes de fichiers &agrave; l'installation de
      FreeBSD et d&eacute;cidez o&ugrave; les monter, et ensuite ne
      les modifiez jamais &agrave; moins que vous ajoutiez un nouveau
      disque.</para>

    <para>Il est tout &agrave; fait possible de n'avoir qu'un seul
      grand syst&egrave;me de fichiers racine, et de ne pas en
      cr&eacute;er d'autres.  Il y a quelques inconv&eacute;nients
      &agrave; cette approche, et un avantage.</para>

    <itemizedlist>
      <title>Avantages des syst&egrave;mes de fichiers
	multiples</title>

      <listitem>
	<para>Les diff&eacute;rents syst&egrave;mes de fichiers
	  peuvent avoir diff&eacute;rentes <firstterm>options de
	  montage</firstterm>.  Par exemple, avec une planification
	  soigneuse, le syst&egrave;me de fichiers racine peut
	  &ecirc;tre mont&eacute; en lecture seule, rendant impossible
	  tout effacement par inadvertance ou &eacute;dition de fichier
	  critique.  La s&eacute;paration des syst&egrave;mes de
	  fichiers inscriptibles par l'utilisateur permet leur montage
	  en mode <firstterm>nosuid</firstterm>; cette option
	  emp&ecirc;che les bits
	  <firstterm>suid</firstterm>/<firstterm>guid</firstterm> des
	  ex&eacute;cutables stock&eacute;s sur ce syst&egrave;me de
	  fichiers de prendre effet, am&eacute;liorant peut-&ecirc;tre
	  la s&eacute;curit&eacute;.</para>
      </listitem>

      <listitem>
	<para>FreeBSD optimise automatiquement la disposition des
	  fichiers sur un syst&egrave;me de fichiers, selon la
	  fa&ccedil;on dont est utilis&eacute; le syst&egrave;me de
	  fichiers.  Aussi un syst&egrave;me de fichiers contenant
	  beaucoup de petits fichiers qui sont &eacute;crits
	  fr&eacute;quemment aura une optimisation diff&eacute;rente
	  &agrave; celle d'un syst&egrave;me contenant moins, ou de plus
	  gros fichiers.  En ayant un seul grand syst&egrave;me de
	  fichiers cette optimisation est perdue.</para>
      </listitem>

      <listitem>
	<para>Les syst&egrave;mes de fichiers de FreeBSD sont
	  tr&egrave;s robustes m&ecirc;me en cas de coupure secteur.
	  Cependant une coupure secteur &agrave; un moment critique
	  pourrait toujours endommager la structure d'un syst&egrave;me
	  de fichiers.  En r&eacute;partissant vos donn&eacute;es sur
	  des syst&egrave;mes de fichiers multiples il est plus probable
	  que le syst&egrave;me red&eacute;marre, vous facilitant la
	  restauration des donn&eacute;es &agrave; partir de sauvegardes
	  si n&eacute;cessaire.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Avantage d'un syst&egrave;me de fichiers unique</title>

      <listitem>
	<para>Les syst&egrave;mes de fichiers ont une taille fixe.  Si
	  vous cr&eacute;ez un syst&egrave;me de fichiers &agrave;
	  l'installation de FreeBSD et que vous lui donnez une taille
	  sp&eacute;cifique, vous pouvez plus tard vous apercevoir que
	  vous avez besoin d'une partition plus grande.  Cela n'est pas
	  facilement faisable sans sauvegardes, recr&eacute;ation du
	  syst&egrave;me de fichiers, et enfin restauration des
	  donn&eacute;es.</para>

	<important>
	  <para>&os; dispose d'une commande,
	    &man.growfs.8;, qui permettra d'augmenter la taille d'un
	    syst&egrave;me de fichiers au vol, supprimant cette
	    limitation.</para>
	</important>
      </listitem>
    </itemizedlist>

    <para>Les syst&egrave;mes de fichiers sont contenus dans des
      partitions.  Cela n'a pas la m&ecirc;me signification que
      l'utilisation commune du terme partition (par exemple une
      partition
      &ms-dos;), en raison de l'h&eacute;ritage Unix de FreeBSD.
      Chaque partition est identifi&eacute;e par une lettre de
      <literal>a</literal> &agrave; <literal>h</literal>.  Chaque
      partition ne contient qu'un seul syst&egrave;me de fichiers,
      cela signifie que les syst&egrave;mes de fichiers sont souvent
      d&eacute;crits soit par leur point de montage typique dans la
      hi&eacute;rarchie du syst&egrave;me de fichiers, soit par la
      lettre de la partition qui les contient.</para>

    <para>FreeBSD utilise aussi de l'espace disque pour
      <firstterm>l'espace de pagination</firstterm>
      (&ldquo;swap&rdquo;).  L'espace de pagination fournit &agrave;
      FreeBSD la <firstterm>m&eacute;moire virtuelle</firstterm>.
      Cela permet &agrave; votre ordinateur de se comporter comme s'il
      disposait de beaucoup plus de m&eacute;moire qu'il n'en a
      r&eacute;ellement.  Quand FreeBSD vient &agrave; manquer de
      m&eacute;moire il d&eacute;place certaines donn&eacute;es qui ne
      sont pas actuellement utilis&eacute;es vers l'espace de
      pagination, et les rapatrie (en d&eacute;pla&ccedil;ant quelque
      chose d'autre) quand il en a besoin.</para>

    <para>Quelques partitions sont li&eacute;es &agrave; certaines
      conventions.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*">
	<colspec colwidth="5*">

	<thead>
	  <row>
	    <entry>Partition</entry>

	    <entry>Convention</entry>
	  </row>
	</thead>

	<tbody valign="top">
	  <row>
	    <entry><literal>a</literal></entry>

	    <entry>Contient normalement le syst&egrave;me de
	      fichiers racine</entry>
	  </row>

	  <row>
	    <entry><literal>b</literal></entry>

	    <entry>Contient normalement l'espace de pagination</entry>
	  </row>

	  <row>
	    <entry><literal>c</literal></entry>

	    <entry>Normalement de la m&ecirc;me taille que la tranche
	      (&ldquo;slice&rdquo;) contenant les partitions.  Cela
	      permet aux utilitaires devant agir sur
	      l'int&eacute;gralit&eacute; de la tranche (par exemple
	      un analyseur de blocs d&eacute;fectueux) de travailler
	      sur la partition <literal>c</literal>.  Vous ne devriez
	      normalement pas cr&eacute;er de syst&egrave;me de
	      fichiers sur cette partition.</entry>
	  </row>

	  <row>
	    <entry><literal>d</literal></entry>

	    <entry>La partition <literal>d</literal> a eu dans le
	      pass&eacute; une signification particuli&egrave;re, ce
	      n'est plus le cas aujourd'hui, et <literal>d</literal>
	      pourra &ecirc;tre utilis&eacute;e comme une partition
	      classique.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Chaque partition contenant un syst&egrave;me de fichiers est
      stock&eacute;e dans ce que FreeBSD appelle une
      <firstterm>tranche</firstterm> (&ldquo;slice&rdquo;). Tranche -
      &ldquo;slice&rdquo; est le terme FreeBSD pour ce qui
      est commun&eacute;ment appel&eacute; partition,
      et encore une fois, cela en raison des fondations Unix de
      FreeBSD.  Les tranches sont num&eacute;rot&eacute;es, en partant
      de 1, jusqu'&agrave; 4.</para>

    <indexterm><primary>slices</primary></indexterm>
    <indexterm><primary>tranches</primary></indexterm>
    <indexterm><primary>partitions</primary></indexterm>
    <indexterm><primary>mode d&eacute;di&eacute;</primary></indexterm>

    <para>Les num&eacute;ros de tranche suivent le nom du
      p&eacute;riph&eacute;rique, avec le pr&eacute;fixe
      <literal>s</literal>, et commencent &agrave; 1.  Donc
      &ldquo;da0<emphasis>s1</emphasis>&rdquo; est la premi&egrave;re
      tranche sur le premier disque SCSI.  Il ne peut y avoir que
      quatre tranches physiques sur un disque, mais vous pouvez avoir
      des tranches logiques dans des tranches physiques d'un type
      pr&eacute;cis.  Ces tranches &eacute;tendues sont
      num&eacute;rot&eacute;es &agrave; partir de 5, donc
      &ldquo;ad0<emphasis>s5</emphasis>&rdquo; est la premi&egrave;re
      tranche &eacute;tendue sur le premier disque IDE.  Elles sont
      utilis&eacute;es par des syst&egrave;mes de fichiers qui
      s'attendent &agrave; occuper une tranche enti&egrave;re.</para>

    <para>Les tranches, les disques &ldquo;en mode
      d&eacute;di&eacute;&rdquo;, et les autres disques contiennent
      des <firstterm>partitions</firstterm>, qui sont
      repr&eacute;sent&eacute;es par des lettres allant de
      <literal>a</literal> &agrave; <literal>h</literal>.  Cette
      lettre est ajout&eacute;e au nom de p&eacute;riph&eacute;rique,
      aussi &ldquo;da0<emphasis>a</emphasis>&rdquo; est la partition a
      sur le premier disque da, qui est en &ldquo;en mode
      d&eacute;di&eacute;&rdquo;.
      &ldquo;ad1s3<emphasis>e</emphasis>&rdquo; est la
      cinqui&egrave;me partition de la troisi&egrave;me tranche du
      second disque IDE.</para>

    <para>En conclusion chaque disque pr&eacute;sent sur le
      syst&egrave;me est identifi&eacute;.  Le nom d'un disque
      commence par un code qui indique le type de disque, suivi d'un
      nombre, indiquant de quel disque il s'agit.  Contrairement aux
      tranches, la num&eacute;rotation des disques commence &agrave;
      0.  Les codes communs que vous risquez de rencontrer sont
      &eacute;num&eacute;r&eacute;s dans le <xref
      linkend="basics-dev-codes">.</para>

    <para>Quand vous faites r&eacute;f&eacute;rence &agrave; une
      partition, FreeBSD exige que vous nommiez &eacute;galement la
      tranche et le disque contenant la partition, et quand vous
      faites r&eacute;f&eacute;rence &agrave; une tranche vous devrez
      &eacute;galement faire r&eacute;f&eacute;rence au nom du disque.
      On fait donc r&eacute;f&eacute;rence &agrave; une partition en &eacute;crivant le nom du disque,
      <literal>s</literal>, le num&eacute;ro de la tranche, et enfin
      la lettre de la partition.  Des exemples sont donn&eacute;s dans
      l'<xref linkend="basics-disk-slice-part">.</para>

    <para>L'<xref linkend="basics-concept-disk-model"> montre un
      exemple de l'organisation d'un disque qui devrait aider &agrave;
      clarifier les choses.</para>

    <para>Afin d'installer FreeBSD vous devez tout d'abord configurer
      les tranches sur votre disque, ensuite cr&eacute;er les
      partitions dans la tranche que vous utiliserez pour FreeBSD, et
      alors cr&eacute;er un syst&egrave;me de fichiers (ou espace de
      pagination) dans chaque partition, et d&eacute;cider de
      l'endroit o&ugrave; seront mont&eacute;s les syst&egrave;mes de
      fichiers.</para>

    <table frame="none" pgwide="1" id="basics-dev-codes">
      <title>Codes des p&eacute;riph&eacute;riques disques</title>

      <tgroup cols="2">
	<colspec colwidth="1*">
	<colspec colwidth="5*">

	<thead>
	  <row>
	    <entry>Code</entry>

	    <entry>Signification</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><devicename>ad</devicename></entry>

	    <entry>Disque ATAPI (IDE)</entry>
	  </row>

	  <row>
	    <entry><devicename>da</devicename></entry>

	    <entry>Disque SCSI</entry>
	  </row>

	  <row>
	    <entry><devicename>acd</devicename></entry>

	    <entry>CDROM ATAPI (IDE)</entry>
	  </row>

	  <row>
	    <entry><devicename>cd</devicename></entry>

	    <entry>CDROM SCSI</entry>
	  </row>

	  <row>
	    <entry><devicename>fd</devicename></entry>

	    <entry>Lecteur de disquette</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <example id="basics-disk-slice-part">
      <title>Exemples d'appellation de disques, tranches et
      partitions</title>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Nom</entry>

	      <entry>Signification</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>ad0s1a</literal></entry>

	      <entry>Premi&egrave;re partition (<literal>a</literal>)
		sur la premi&egrave;re tranche (<literal>s1</literal>)
		du premier disque IDE
		(<literal>ad0</literal>).</entry>
	    </row>

	    <row>
	      <entry><literal>da1s2e</literal></entry>

	      <entry>Cinqui&egrave;me partition (<literal>e</literal>)
		sur la seconde tranche (<literal>s2</literal>) du
		deuxi&egrave;me disque SCSI
		(<literal>da1</literal>).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </example>

    <example id="basics-concept-disk-model">
      <title>Mod&egrave;le conceptuel d'un disque</title>

      <para>Ce diagramme montre comment FreeBSD voit le premier disque
	IDE attach&eacute; au syst&egrave;me.  Supposons que le disque
	a une capacit&eacute; de 4&nbsp;Go, et contient deux tranches
	de 2&nbsp;Go (partitions &ms-dos;).  La premi&egrave;re tranche
	contient un disque &ms-dos;, <devicename>C:</devicename>, et la
	seconde tranche contient une installation de FreeBSD.  Dans
	cet exemple l'installation de FreeBSD a trois partitions de donn&eacute;es, et
	une partition de pagination.</para>

      <para>Les trois partitions accueilleront chacune un
	syst&egrave;me de fichiers.  La partition <literal>a</literal>
	sera utilis&eacute;e en tant que syst&egrave;me de fichiers
	racine, la partition <literal>e</literal> pour le contenu du
	r&eacute;pertoire <filename>/var</filename>, et
	<literal>f</literal> pour l'arborescence du r&eacute;pertoire
	<filename>/usr</filename>.</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/disk-layout" format="EPS">
	</imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  Premi&egrave;re tranche, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                                   --.
|                 |    |  Partition a, mont&eacute;e en tant que /  |
|                 |     &gt; r&eacute;f&eacute;renc&eacute;e ad0s2a	             |
|                 |    |                                     |
:-----------------:  ==:                                     |
|                 |    |  Partition b, utilis&eacute;e comme swap   |
|                 |     &gt; r&eacute;f&eacute;renc&eacute;e ad0s2b	             |  Partition c,
|                 |    |                               	     |  pas de
:-----------------:  ==:                                     |  syst&egrave;me de
|                 |    |  Partition e, utilis&eacute;e en /var       &gt; fichiers
|                 |     &gt; r&eacute;f&eacute;renc&eacute;e ad0s2e                  |  int&eacute;gralit&eacute;
|                 |    |                                     |  de la tranche
:-----------------:  ==:                                     |  FreeBSD ad0s2c
|                 |    |                                     |
:                 :    |  Partition f, utilis&eacute;e en /usr      |
:                 :     &gt; r&eacute;f&eacute;renc&eacute;e ad0s2f                  |
:                 :    |                                     |
|                 |    |                                     |
|                 |  --'                                     |
`-----------------'                                        --'</literallayout>
	</textobject>
      </mediaobject>
    </example>
  </sect1>

  <sect1 id="mount-unmount">
    <title>Monter et d&eacute;monter des syst&egrave;mes de fichiers</title>

    <para>Le syst&egrave;me de fichiers peut &ecirc;tre vu comme un arbre
      enracin&eacute; sur le r&eacute;pertoire <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename>, et les
      autres r&eacute;pertoires dans le r&eacute;pertoire racine sont des
      branches, qui peuvent avoir leurs propres branches, comme
      <filename>/usr/local</filename>, et ainsi de suite.</para>

    <indexterm><primary>syst&egrave;me de fichiers racine</primary></indexterm>
    <para>Il y a diverses raisons pour h&eacute;berger certains de ces
      r&eacute;pertoires sur des syst&egrave;mes de fichiers
      s&eacute;par&eacute;s.
      <filename>/var</filename> contient les r&eacute;pertoires
      <filename>log/</filename>, <filename>spool/</filename>, et divers
      types de fichiers temporaires, et en tant que tels, peuvent voir
      leur taille augmenter de fa&ccedil;on importante.
      Remplir le syst&egrave;me de
      fichiers racine n'est pas une bonne id&eacute;e, aussi s&eacute;parer
      <filename>/var</filename> de <filename>/</filename> est souvent
      favorable.</para>

    <para>Une autre raison courante de placer certains r&eacute;pertoires sur
      d'autres syst&egrave;mes de fichiers est s'ils doivent &ecirc;tre
      h&eacute;berg&eacute;s sur
      des disques physiques s&eacute;par&eacute;s, ou sur des disques virtuels
      s&eacute;par&eacute;s, comme les <link linkend="network-nfs">syst&egrave;mes de
      fichiers r&eacute;seau</link>, ou les lecteurs de CDROM.</para>

    <sect2 id="disks-fstab">
      <title>Le fichier <filename>fstab</filename></title>
      <indexterm>
	<primary>syst&egrave;mes de fichiers</primary>
	<secondary>mont&eacute;s avec fstab</secondary>
      </indexterm>

      <para>Durant le <link linkend="boot">processus de
	d&eacute;marrage</link>, les syst&egrave;mes de fichiers list&eacute;s
	dans <filename>/etc/fstab</filename> sont automatiquement
	mont&eacute;s (&agrave; moins qu'il ne soient list&eacute;s avec
	l'option <option>noauto</option>).</para>

      <para>Le fichier <filename>/etc/fstab</filename> contient une
	liste de lignes au format suivant:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>Un nom de p&eacute;riph&eacute;rique (qui devrait exister),
	      comme expliqu&eacute; dans la
	      <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem><para>Un r&eacute;pertoire (qui devrait exister), sur
	    lequel sera mont&eacute; le syst&egrave;me de fichier.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem><para>Le type de syst&egrave;me de fichiers &agrave;
	      indiquer &agrave;
	      &man.mount.8;.  Le syst&egrave;me de fichiers par d&eacute;faut de
	      FreeBSD est l'<literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem><para>Soit <option>rw</option> pour des syst&egrave;mes de
	      fichiers &agrave; lecture-&eacute;criture, soit
	      <option>ro</option> pour des syst&egrave;mes de fichiers
	      &agrave; lecture seule, suivi par toute
	      option qui peut s'av&eacute;rer n&eacute;cessaire.  Une option
	      courante est <option>noauto</option> pour les syst&egrave;mes de
	      fichiers qui ne sont normalement pas mont&eacute;s durant la
	      s&eacute;quence de d&eacute;marrage.  D'autres options sont
	      pr&eacute;sent&eacute;es dans la page de manuel &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

         <listitem><para>C'est utilis&eacute; par &man.dump.8; pour
	     d&eacute;terminer quels syst&egrave;mes de fichiers
	     n&eacute;cessitent
	     une sauvegarde.  Si ce champ est absent, une valeur
	     de z&eacute;ro est suppos&eacute;e.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Ceci d&eacute;termine l'ordre dans lequel les syst&egrave;mes
	     de fichiers devront &ecirc;tre v&eacute;rifi&eacute;s.
	     Les syst&egrave;mes de fichiers
	     qui doivent &ecirc;tre ignor&eacute;s devraient avoir leur
	     <literal>passno</literal> positionn&eacute; &agrave; z&eacute;ro.
	     Le syst&egrave;me de fichiers racine (qui doit &ecirc;tre
	     v&eacute;rifi&eacute; avant tout le reste) devrait avoir son
	     <literal>passno</literal> positionn&eacute; &agrave; un,
	     et les options <literal>passno</literal> des autres
	     syst&egrave;mes fichiers devraient &ecirc;tre positionn&eacute;es
	     &agrave; des valeurs sup&eacute;rieures &agrave; un.  Si plus
	     d'un syst&egrave;me de fichiers ont le m&ecirc;me
	     <literal>passno</literal> alors &man.fsck.8; essaiera
	     de v&eacute;rifier les syst&egrave;mes de fichiers
	     en parall&egrave;le si c'est possible.</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>Consultez la page de manuel de &man.fstab.5; pour plus
	d'information sur le format du fichier
	<filename>/etc/fstab</filename> et des options qu'il
	contient.</para>
    </sect2>

    <sect2 id="disks-mount">
      <title>La commande <command>mount</command></title>
      <indexterm>
	<primary>syst&egrave;mes de fichiers</primary>
	<secondary>montage</secondary>
      </indexterm>

      <para>La commande &man.mount.8; est ce qui est finalement
	utilis&eacute; pour monter des syst&egrave;mes de fichiers.</para>

      <para>Dans sa forme la plus simple, vous utilisez:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Il y beaucoup d'options, comme mentionn&eacute; dans la page de
	manuel &man.mount.8;, mais les plus courantes sont:</para>

      <variablelist>
	<title>Options de montage</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Monte tous les syst&egrave;mes de fichiers list&eacute;s dans
	      <filename>/etc/fstab</filename>.  Exception faite de ceux
	      marqu&eacute;s comme &ldquo;noauto&rdquo;, ou exclus par
	      le drapeau <option>-t</option>, ou encore ceux qui sont
	      d&eacute;j&agrave; mont&eacute;s.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Tout effectuer &agrave; l'exception de l'appel
	      syst&egrave;me de montage r&eacute;el.  Cette option est utile
	      conjointement avec le drapeau <option>-v</option> pour
	      d&eacute;terminer ce que &man.mount.8; est en train
	      d'essayer de faire.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Force le montage d'un syst&egrave;me de fichiers non propre
	      (dangereux), ou force la r&eacute;vocation de l'acc&egrave;s en
	      &eacute;criture quand on modifie l'&eacute;tat de montage d'un
	      syst&egrave;me de fichiers de l'acc&egrave;s
	      lecture-&eacute;criture &agrave; l'acc&egrave;s
	      lecture seule.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	  <listitem>
	    <para>Monte le syst&egrave;me de fichiers en lecture seule.  C'est
	      identique &agrave; l'utilisation de l'argument
	      <option>ro</option> (<option>rdonly</option> pour les
	      versions de &os; ant&eacute;rieures &agrave; la 5.2)
	      avec l'option
	      <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Monte le syst&egrave;me de fichiers comme &eacute;tant
	    du type de syst&egrave;me donn&eacute;, ou monte
	      seulement les syst&egrave;mes de fichiers du type donn&eacute;,
	      si l'option <option>-a</option> est pr&eacute;cis&eacute;e.</para>
	    <para>&ldquo;ufs&rdquo; est le type de syst&egrave;me de
	      fichiers par d&eacute;faut.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Mets &agrave; jour les options de montage sur le
	      syst&egrave;me de fichiers.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Rends la commande prolixe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Monte le syst&egrave;me de fichiers en
	      lecture-&eacute;criture.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>L'option <option>-o</option> accepte une liste d'options
	s&eacute;par&eacute;es par des virgules, dont les suivantes:</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
              <para>Ne pas autoriser l'ex&eacute;cution de binaires sur ce
		syst&egrave;me de fichiers.  C'est &eacute;galement une
		option de s&eacute;curit&eacute; utile.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Ne pas prendre en compte les indicateurs setuid ou setgid
	      sur le syst&egrave;me de fichiers.  C'est &eacute;galement une
	      option de s&eacute;curit&eacute; utile.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>La commande <command>umount</command></title>
      <indexterm>
	<primary>syst&egrave;mes de fichiers</primary>
	<secondary>d&eacute;montage</secondary>
      </indexterm>

      <para>La commande &man.umount.8; prend, comme param&egrave;tre, un des
	points de montage, un nom de p&eacute;riph&eacute;rique, ou
	l'option <option>-a</option> ou <option>-A</option>.</para>

      <para>Toutes les formes acceptent <option>-f</option> pour forcer
	de d&eacute;montage, et <option>-v</option> pour le mode
	prolixe.  Soyez averti que l'utilisation de <option>-f</option>
	n'est g&eacute;n&eacute;ralement pas une bonne id&eacute;e.
	D&eacute;monter de force des syst&egrave;mes de fichiers pourrait
	faire planter l'ordinateur ou endommager les donn&eacute;es sur
	le syst&egrave;me de fichiers.</para>

      <para>Les options <option>-a</option> et <option>-A</option>
	sont utilis&eacute;es pour d&eacute;monter tous les syst&egrave;mes
	de fichiers actuellement mont&eacute;s, &eacute;ventuellement
	modifi&eacute; par les types de syst&egrave;mes de fichiers
	list&eacute;s apr&egrave;s l'option <option>-t</option>.
	Cependant l'option <option>-A</option>, n'essaye pas de
	d&eacute;monter le syst&egrave;me de fichiers racine.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Processus</title>

    <para>FreeBSD est un syst&egrave;me d'exploitation multi-t&acirc;ches.
      Cela veut dire qu'il semble qu'il y ait plus d'un programme
      fonctionnant &agrave;
      la fois.  Tout programme fonctionnant &agrave; un moment donn&eacute; est
      appel&eacute; un <firstterm>processus</firstterm>.  Chaque commande que
      vous utiliserez lancera au moins un nouveau processus, et il y a
      de nombreux processus syst&egrave;me qui tournent constamment, maintenant
      ainsi les fonctionnalit&eacute;s du syst&egrave;me.</para>

    <para>Chaque processus est identifi&eacute; de fa&ccedil;on unique par
      un nombre appel&eacute; <firstterm>process ID</firstterm> (identifiant de
      processus), ou <firstterm>PID</firstterm>, et, comme pour les fichiers,
      chaque processus poss&egrave;de &eacute;galement un propri&eacute;taire
      et un groupe.  Les informations sur le propri&eacute;taire et le groupe
      sont utilis&eacute;es pour d&eacute;terminer quels fichiers et
      p&eacute;riph&eacute;riques sont accessibles au processus, en utilisant le
      principe de permissions de fichiers abord&eacute; plus t&ocirc;t.
      La plupart
      des processus ont &eacute;galement un processus parent.  Le processus
      parent est le processus qui les a lanc&eacute;s.  Par exemple, si vous
      tapez des commandes sous un interpr&eacute;teur de commandes, alors
      l'interpr&eacute;teur de commandes est un processus, et toute commande
      que vous lancez est aussi un processus.  Chaque processus que vous
      lancez de cette mani&egrave;re aura votre interpr&eacute;teur de
      commandes comme processus parent.
      Une exception &agrave; cela est le processus sp&eacute;cial
      appel&eacute; &man.init.8;.  <command>init</command> est
      toujours le premier processus, donc son PID est toujours 1.
      <command>init</command> est lanc&eacute; automatiquement par le noyau au
      d&eacute;marrage de FreeBSD.</para>

    <para>Deux commandes sont particuli&egrave;rement utiles pour voir les
      processus sur le syst&egrave;me, &man.ps.1; et &man.top.1;.  La
      commande <command>ps</command> est utilis&eacute;e pour afficher une liste statique
      des processus tournant actuellement, et peut donner leur PID, la
      quantit&eacute; de m&eacute;moire qu'ils utilisent, la ligne de
      commande par l'interm&eacute;diaire de laquelle ils ont
      &eacute;t&eacute; lanc&eacute;s, et ainsi de suite.
      La commande &man.top.1; affiche tous les processus, et actualise
      l'affichage r&eacute;guli&egrave;rement, de sorte que vous puissiez voir
      de fa&ccedil;on int&eacute;ractive ce que fait l'ordinateur.</para>

    <para>Par d&eacute;faut, &man.ps.1; n'affiche que les commandes que vous
      faites tourner et dont vous &ecirc;tes le propri&eacute;taire.  Par
      exemple:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Comme vous pouvez le voir dans cet exemple, la sortie de
      &man.ps.1; est organis&eacute;e en un certain nombre de colonnes.
      <literal>PID</literal> est l'identifiant de processus discut&eacute; plus
      t&ocirc;t.  Les PIDs sont assign&eacute;s &agrave; partir de 1, et
      vont jusqu'&agrave; 99999,
      et puis repassent &agrave; 1 quand le maximum est atteint
      (un PID n'est pas r&eacute;assign&eacute; s'il est
      d&eacute;j&agrave; utilis&eacute;).
      La colonne <literal>TT</literal> donne le terminal sur lequel tourne le
      programme, et peut &ecirc;tre pour le moment ignor&eacute; sans risque.
      <literal>STAT</literal> affiche l'&eacute;tat du programme, peut
      &ecirc;tre &eacute;galement ignor&eacute;.
      <literal>TIME</literal> est la dur&eacute;e d'utilisation du CPU&mdash;ce
      n'est g&eacute;n&eacute;ralement pas le temps &eacute;coul&eacute; depuis
      que vous avez lanc&eacute; le programme, comme la plupart des programmes passent
      beaucoup de temps &agrave; attendre que certaines choses se produisent
      avant qu'ils n'aient besoin de d&eacute;penser du temps CPU.
      Et enfin, <literal>COMMAND</literal> est la ligne de commande qui a
      &eacute;t&eacute; utilis&eacute;e lors du lancement du programme.</para>

    <para>&man.ps.1; supporte un certain nombre d'options diff&eacute;rentes
      pour modifier les informations affich&eacute;es.  Un des ensembles
      d'options les plus utiles est <literal>auxww</literal>.
      <option>a</option> affiche l'information au sujet de tous les
      processus tournant, et pas seulement les v&ocirc;tres.
      <option>u</option> donne le nom de l'utilisateur du propri&eacute;taire
      du processus, ainsi que l'utilisation de la m&eacute;moire.
      <option>x</option> affiche des informations sur les processus
      &ldquo;daemon&rdquo;, et <option>ww</option> oblige &man.ps.1; &agrave;
      afficher la ligne de commande compl&egrave;te pour chaque processus, plut&ocirc;t que de la
      tronquer quand elle est trop longue pour tenir &agrave;
      l'&eacute;cran.</para>

    <para>La sortie de &man.top.1; est semblable.  Un extrait de session
      ressemble &agrave; ceci:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>La sortie est divis&eacute;e en deux sections.
      L'ent&ecirc;te (les cinq premi&egrave;res lignes) donne le PID du
      dernier processus lanc&eacute;, la charge syst&egrave;me moyenne
      (qui est une mesure de l'occupation du syst&egrave;me), la dur&eacute;e
      de fonctionnement du syst&egrave;me (le temps &eacute;coul&eacute;
      depuis le dernier red&eacute;marrage), et l'heure actuelle.  Les autres
      &eacute;l&eacute;ments de l'ent&ecirc;te concernent le nombre de
      processus en fonctionnement (47 dans notre cas), combien d'espace
      m&eacute;moire et d'espace de pagination sont occup&eacute;s, et
      combien de temps le syst&egrave;me passe dans les diff&eacute;rents
      &eacute;tats du CPU.</para>

    <para>En dessous il y a une s&eacute;rie de colonnes contenant des
      informations semblables &agrave; celles donn&eacute;es par &man.ps.1;.
      Comme pr&eacute;c&eacute;demment vous pouvez lire le PID, le nom
      d'utilisateur, la quantit&eacute; de temps CPU consomm&eacute;e, et
      la commande qui a &eacute;t&eacute; lanc&eacute;e.  &man.top.1; vous
      affiche par d&eacute;faut la quantit&eacute; d'espace m&eacute;moire
      utilis&eacute;e par chaque processus.  Cela est divis&eacute; en deux
      colonnes, une pour la quantit&eacute; totale, et une autre pour la
      quantit&eacute; r&eacute;sidente&mdash;la quantit&eacute; totale
      repr&eacute;sente l'espace m&eacute;moire dont a eu besoin l'application,
      et la quantit&eacute; r&eacute;sidente repr&eacute;sente
      l'espace qui est en fait utilis&eacute; actuellement.  Dans cet exemple
      vous pouvez voir que <application>&netscape;</application> a
      exig&eacute; presque 30&nbsp;Mo de RAM, mais
      utilise actuellement seulement 9Mo.</para>

    <para>&man.top.1; actualise l'affichage toutes les deux secondes;
      cela peut &ecirc;tre modifi&eacute; avec l'option
      <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Daemons, signaux, et comment tuer un processus</title>

    <para>Quand vous utilisez un &eacute;diteur il est facile de le
      contr&ocirc;ler, de lui dire de charger des fichiers, et ainsi de suite.
      Vous pouvez faire cela parce que l'&eacute;diteur fournit les
      possibilit&eacute;s de le faire, et parce qu'un &eacute;diteur est
      attach&eacute; &agrave; un <firstterm>terminal</firstterm>.
      Certains programmes ne sont pas con&ccedil;us pour fonctionner avec
      un dialogue constant avec l'utilisateur, et donc ils se
      d&eacute;connectent du terminal &agrave; la premi&egrave;re occasion.
      Par exemple, un serveur web passe son temps &agrave; r&eacute;pondre
      aux requ&ecirc;tes web, il n'attend normalement pas d'entr&eacute;e de
      votre part.  Les programmes qui transportent le courrier
      &eacute;lectronique de site en site sont un autre exemple de cette
      classe d'application.</para>

    <para>Nous appelons ces programmes des
      <firstterm>daemons</firstterm> (d&eacute;mons).  Les
      &ldquo;daemons&rdquo; &eacute;taient des personnages de la mythologie
      Grecque: ni bon ni mauvais, c'&eacute;taient de petits esprits serviteurs
      qui, g&eacute;n&eacute;ralement, ont &eacute;t&eacute; &agrave; l'origine
      de choses utiles &agrave; l'humanit&eacute;,
      un peu comme les serveurs web ou de messagerie d'aujourd'hui nous
      sont utiles.  C'est pourquoi la mascotte BSD a &eacute;t&eacute;, pendant
      longtemps, un d&eacute;mon &agrave; l'apparence joyeuse portant des
      chaussures de tennis et une fourche.</para>

    <para>Il existe une convention pour nommer les programmes qui
      fonctionnent normalement en tant que daemons qui est d'utiliser
      une terminaison en &ldquo;d&rdquo;.
      <application>BIND</application> est le &ldquo;Berkeley Internet Name
      Domain&rdquo;, mais le programme r&eacute;el qui est ex&eacute;cut&eacute;
      s'appelle <command>named</command>); le programme
      correspondant au serveur web <application>Apache</application> est
      appel&eacute; <command>httpd</command>; le daemon de gestion de la file
      d'attente de l'imprimante est <command>lpd</command>, et ainsi de
      suite.  C'est une convention, mais pas une obligation pure et
      simple; par exemple le daemon principal de gestion du courrier
      &eacute;lectronique pour l'application
      <application>Sendmail</application> est appel&eacute;
      <command>sendmail</command>, et non pas <command>maild</command>,
      comme vous pourriez l'imaginer.</para>

    <para>Parfois vous devrez communiquer avec un processus daemon.
      Une mani&egrave;re de proc&eacute;der est de lui (ou &agrave; tout processus en cours
      d'ex&eacute;cution) envoyer ce que l'on appelle un
      <firstterm>signal</firstterm>.  Il existe un certain
      nombre de signaux diff&eacute;rents que vous pouvez
      envoyer&mdash;certains d'entre eux ont une signification pr&eacute;cise,
      d'autres sont interpr&eacute;t&eacute;s par l'application, et la
      documentation de l'application vous indiquera comment l'application
      interpr&egrave;te ces signaux.  Vous ne pouvez envoyer de signaux
      qu'aux processus dont vous &ecirc;tes le propri&eacute;taire.
      Si vous envoyez un signal &agrave; un
      processus appartenant &agrave; quelqu'un d'autre avec &man.kill.1;
      ou &man.kill.2;, vous obtiendrez un refus de permission.  Il existe
      une exception &agrave; cela: l'utilisateur <username>root</username>, qui
      peut envoyer des signaux aux processus de chacun.</para>

    <para>Dans certain cas FreeBSD enverra &eacute;galement aux applications
      des signaux.  Si une application est mal &eacute;crite, et tente
      d'acc&eacute;der &agrave; une partie de m&eacute;moire &agrave;
      laquelle elle n'est pas suppos&eacute;e avoir acc&egrave;s, FreeBSD
      envoie au processus le signal de
      <firstterm>violation de segmentation</firstterm>
      (<literal>SIGSEGV</literal>).  Si une application a utilis&eacute;
      l'appel syst&egrave;me &man.alarm.3; pour &ecirc;tre avertie
      d&egrave;s qu'une p&eacute;riode de temps pr&eacute;cise est
      &eacute;coul&eacute;e alors lui sera envoy&eacute; le signal d'alarme
      (<literal>SIGALRM</literal>), et ainsi de suite.</para>

    <para>Deux signaux peuvent &ecirc;tre utilis&eacute;s pour arr&ecirc;ter
      un processus, <literal>SIGTERM</literal> et <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> est la mani&egrave;re polie de tuer un
      processus; le processus peut <emphasis>attraper</emphasis> le signal,
      r&eacute;aliser que vous d&eacute;sirez qu'il se termine, fermer les
      fichiers de trace qu'il a peut-&ecirc;tre ouvert, et
      g&eacute;n&eacute;ralement
      finir ce qu'il &eacute;tait en train de faire juste avant la demande
      d'arr&ecirc;t.  Dans certains cas un processus peut ignorer un
      <literal>SIGTERM</literal> s'il est au milieu d'une t&acirc;che qui ne
      peut &ecirc;tre interrompue.</para>

    <para><literal>SIGKILL</literal> ne peut &ecirc;tre ignor&eacute; par un
      processus.  C'est le signal &ldquo;Je me fiche de ce que vous
      faites, arr&ecirc;tez imm&eacute;diatement&rdquo;.  Si vous envoyez un
      <literal>SIGKILL</literal> &agrave; un processus alors FreeBSD
      stoppera le processus<footnote>
	<para>Ce n'est pas tout &agrave; fait vrai&mdash;il y a quelques cas
	  o&ugrave; les choses ne peuvent &ecirc;tre interrompues.  Par exemple,
	  si le processus est en train d'essayer de lire un fichier qui
	  est sur un autre ordinateur sur le r&eacute;seau, et que l'autre
	  ordinateur n'est plus accessible pour quelque raison
	  (a &eacute;t&eacute; &eacute;teint, ou le r&eacute;seau a un
	  probl&egrave;me),
	  alors le processus est dit &ldquo;non interruptible&rdquo;.
	  Par la suite le processus entrera en pause, typiquement apr&egrave;s
	  deux minutes.  D&egrave;s que cette pause sera effective le processus
	  sera tu&eacute;.</para>
      </footnote>.</para>

    <para>Les autres signaux que vous pourriez avoir envie d'utiliser
      sont <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, et
      <literal>SIGUSR2</literal>.  Ce sont des signaux d'usage
      g&eacute;n&eacute;ral, et diff&eacute;rentes applications se
      comporteront diff&eacute;remment quand ils
      sont envoy&eacute;s.</para>

    <para>Supposez que vous avez modifi&eacute; le fichier de configuration de
      votre serveur web&mdash;vous voudriez dire &agrave; votre serveur web de
      relire son fichier de configuration.  Vous pourriez arr&ecirc;ter et
      relancer <command>httpd</command>, mais il en r&eacute;sulterait une
      br&egrave;ve p&eacute;riode d'indisponibilit&eacute; de votre serveur
      web, ce qui peut &ecirc;tre ind&eacute;sirable.
      La plupart des daemons sont &eacute;crits pour r&eacute;pondre
      au signal <literal>SIGHUP</literal> en relisant leur fichier de
      configuration.  Donc au lieu de tuer et relancer
      <command>httpd</command> vous lui enverriez le signal
      <literal>SIGHUP</literal>.  Parce qu'il n'y a pas de mani&egrave;re
      standard de r&eacute;pondre &agrave; ces signaux, diff&eacute;rents
      daemons auront diff&eacute;rents comportements, soyez s&ucirc;r
      de ce que vous faites et lisez
      la documentation du daemon en question.</para>

    <para>Les signaux sont envoy&eacute;s en utilisant la commande
      &man.kill.1;, comme cet exemple le montre:</para>

    <procedure>
      <title>Envoyer un signal &agrave; un processus</title>

      <para>Cet exemple montre comment envoyer un signal &agrave;
	&man.inetd.8;.  Le fichier de configuration d'<command>inetd</command> est
	<filename>/etc/inetd.conf</filename>, et <command>inetd</command> relira ce
	fichier de configuration quand un signal
	<literal>SIGHUP</literal> est envoy&eacute;.</para>

      <step>
	<para>Trouvez l'identifiant du processus (PID) auquel vous
	  voulez envoyer le signal.  Faites-le en employant &man.ps.1;
	  et &man.grep.1;.  La commande &man.grep.1; est utilis&eacute;e pour
	  rechercher dans le r&eacute;sultat la cha&icirc;ne de
	  caract&egrave;res que
	  vous sp&eacute;cifiez.  Cette commande est lanc&eacute;e en tant
	  qu'utilisateur normal, et &man.inetd.8; est lanc&eacute; en tant que
	  <username>root</username>, donc les options <option>ax</option>
	  doivent &ecirc;tre pass&eacute;es &agrave; &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Donc le PID d'&man.inetd.8; est 198.  Dans certains cas la
	  commande <literal>grep inetd</literal> pourrait aussi
	  appara&icirc;tre dans le r&eacute;sultat.  C'est &agrave;
	  cause de la fa&ccedil;on dont
	  &man.ps.1; recherche la liste des processus en
	  fonctionnement.</para>
      </step>

      <step>
	<para>Utilisez &man.kill.1; pour envoyer le signal.  Etant donn&eacute;
	  qu'&man.inetd.8; tourne sous les droits de l'utilisateur
	  <username>root</username> vous devez utilisez &man.su.1; pour
	  devenir, en premier lieu, <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Comme la plupart des commandes &unix;, &man.kill.1; n'affichera
	  rien si la commande est couronn&eacute;e de succ&egrave;s.  Si vous
	  envoyez un signal &agrave; un processus dont vous n'&ecirc;tes pas le
	  propri&eacute;taire alors vous verrez <errorname>kill:
	  <replaceable>PID</replaceable>: Operation not
	  permitted</errorname>.  Si vous avez fait une erreur dans le
	  PID, vous enverrez le signal soit &agrave; un mauvais processus, ce
	  qui peut &ecirc;tre mauvais, soit, si vous &ecirc;tes chanceux, vous
	  enverrez le signal &agrave; un PID qui n'est pas actuellement
	  utilis&eacute;, et vous verrez <errorname>kill:
	  <replaceable>PID</replaceable>: No such
	  process</errorname>.</para>

	<note>
	  <title>Pourquoi utiliser <command>/bin/kill</command>?</title>

	  <para>De nombreux interpr&eacute;teurs de commandes fournissent la
	    commande <command>kill</command> comme commande interne;
	    c'est &agrave; dire, que l'interpr&eacute;teur de commandes enverra
	    directement le signal, plut&ocirc;t que de lancer
	    <filename>/bin/kill</filename>.  Cela peut &ecirc;tre utile,
	    cependant les diff&eacute;rents interpr&eacute;teurs ont une syntaxe
	    diff&eacute;rente pour sp&eacute;cifier le nom du signal &agrave;
	    envoyer.
	    Plut&ocirc;t que de tenter de les apprendre toutes, il peut
	    &ecirc;tre plus simple de juste employer directement la commande
	    <command>/bin/kill
	    <replaceable>...</replaceable></command>.</para>
	</note>
      </step>
    </procedure>

    <para>Envoyer d'autres signaux est tr&egrave;s semblable, substituez juste
      <literal>TERM</literal> ou <literal>KILL</literal> dans la ligne
      de commande si n&eacute;cessaire.</para>

    <important>
      <para>Tuer au hasard des processus sur le syst&egrave;me peut
	&ecirc;tre une mauvaise id&eacute;e.
	En particulier, &man.init.8;, processus &agrave;
	l'identifiant 1, qui est tr&egrave;s particulier.  Lancer la commande
	<command>/bin/kill -s KILL 1</command> est une mani&egrave;re
	rapide d'arr&ecirc;ter votre syst&egrave;me.  V&eacute;rifiez
	<emphasis>toujours</emphasis> &agrave; deux fois les arguments que vous
	utilisez avec &man.kill.1; <emphasis>avant</emphasis> d'appuyer
	sur <keycap>Entr&eacute;e</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Interpr&eacute;teurs de commandes - &ldquo;Shells&rdquo;</title>
    <indexterm><primary>interpr&eacute;teurs de commandes</primary></indexterm>
    <indexterm><primary>ligne de commande</primary></indexterm>

    <para>Sous FreeBSD, beaucoup du travail quotidien est effectu&eacute; sous
      une interface en ligne de commande appel&eacute;e interpr&eacute;teur de
      commandes ou &ldquo;shell&rdquo;.  Le r&ocirc;le principal d'un
      interpr&eacute;teur de commandes est de prendre les commandes sur le
      canal d'entr&eacute;e et de les ex&eacute;cuter.  Beaucoup
      d'interpr&eacute;teurs de commandes ont &eacute;galement des fonctions
      int&eacute;gr&eacute;es pour aider dans les t&acirc;ches quotidiennes
      comme la gestion de fichiers, le m&eacute;canisme de
      remplacement et d'expansion des jokers (&ldquo;file globbing&rdquo;),
      l'&eacute;dition de la ligne de commande, les macros commandes, et les
      variables d'environnement.  FreeBSD est fournit avec un ensemble
      d'interpr&eacute;teurs de commandes, comme <command>sh</command>,
      l'interpr&eacute;teur de commandes Bourne, et <command>tcsh</command>,
      l'interpr&eacute;teur de commandes C-shell am&eacute;lior&eacute;.
      Beaucoup d'autres
      interpr&eacute;teurs de commandes sont disponibles dans le catalogue des
      logiciels port&eacute;s, comme <command>zsh</command> et
      <command>bash</command>.</para>

    <para>Quel interpr&eacute;teur de commandes utilisez-vous?  C'est vraiment
      une question de go&ucirc;t.  Si vous programmez en C vous pourriez vous
      sentir plus &agrave; l'aise avec un interpr&eacute;teur de commandes
      proche du C
      comme <command>tcsh</command>.  Si vous venez du monde Linux ou que
      vous &ecirc;tes nouveau &agrave; l'interface en ligne de commande d'&unix;
      vous pourriez essayer <command>bash</command>.  L'id&eacute;e principale
      est que chaque interpr&eacute;teur de commandes &agrave; des
      caract&eacute;ristiques uniques qui peuvent ou ne peuvent pas
      fonctionner avec votre environnement de travail
      pr&eacute;f&eacute;r&eacute;, et que vous avez vraiment le
      choix de l'interpr&eacute;teur de commandes &agrave; utiliser.</para>

    <para>Une des caract&eacute;ristiques communes des interpr&eacute;teurs de
      commandes est de pouvoir compl&eacute;ter les noms de fichiers
      (&ldquo;filename completion&rdquo;).  En tapant les premi&egrave;res
      lettres d'une commande ou d'un fichier, vous pouvez habituellement
      faire compl&eacute;ter automatiquement par l'interpr&eacute;teur de
      commandes le reste de la commande ou du nom du fichier en appuyant sur la
      touche <keycap>Tab</keycap> du clavier.  Voici un exemple.
      Supposez que vous avez deux fichiers appel&eacute;s respectivement
      <filename>foobar</filename> et <filename>foo.bar</filename>.
      Vous voulez effacer <filename>foo.bar</filename>.  Donc ce
      que vous devriez taper sur le clavier est: <command>rm
      fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>L'interpr&eacute;teur de commandes devrait afficher <command>rm
      foo[BEEP].bar</command>.</para>

    <para>Le [BEEP] est la sonnerie de la console, c'est l'interpr&eacute;teur
      de commande indiquant qu'il n'est pas en mesure de compl&eacute;ter
      totalement le nom du fichier parce qu'il y a plus d'une
      possibilit&eacute;.  <filename>foobar</filename> et
      <filename>foo.bar</filename> commencent tous les deux par
      <literal>fo</literal>, mais il fut capable de compl&eacute;ter
      jusqu'&agrave; <literal>foo</literal>.  Si vous tapez
      <literal>.</literal>, puis appuyez &agrave; nouveau sur
      <keycap>Tab</keycap>, l'interpr&eacute;teur de
      commandes devrait pouvoir compl&eacute;ter le reste du nom du fichier
      pour vous.</para>
    <indexterm><primary>variables d'environnement</primary></indexterm>

    <para>Une autre caract&eacute;ristique de l'interpr&eacute;teur de
      commandes est l'utilisation de variables d'environnement.  Les variables
      d'environnement sont une paire variable/valeur stock&eacute;es dans
      l'espace m&eacute;moire d'environnement de l'interpr&eacute;teur de
      commandes.  Cet espace peut &ecirc;tre lu par n'importe quel programme
      invoqu&eacute; par l'interpr&eacute;teur de commandes, et contient
      ainsi beaucoup d'&eacute;l&eacute;ments
      de configuration des programmes.  Voici une liste des variables
      d'environnement habituelles et ce qu'elles signifient:</para>
    <indexterm><primary>variables d'environnement</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Description</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Le nom d'utilisateur de la personne actuellement
	      attach&eacute;e au syst&egrave;me.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>La liste des r&eacute;pertoires, s&eacute;par&eacute;s par
	      deux points, pour la recherche des programmes.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Le nom r&eacute;seau de l'affichage X11 auquel on peut se
	      connecter, si disponible.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Le nom de l'interpr&eacute;teur de commandes actuellement
	      utilis&eacute;.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Le nom du type de terminal de l'utilisateur.  Utilis&eacute; pour
	      d&eacute;terminer les capacit&eacute;s du terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>L'entr&eacute;e de la base de donn&eacute;es des codes
	      d'&eacute;chappement pour permettre l'ex&eacute;cution de
	      diverses fonctions du terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Type du syst&egrave;me d'exploitation, e.g. FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>L'architecture du CPU sur lequel tourne actuellement
	      le syst&egrave;me.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>L'&eacute;diteur de texte pr&eacute;fer&eacute; de
	      l'utilisateur.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Le visualisateur de page de texte pr&eacute;ferr&eacute; de
	      l'utilisateur.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>La liste des r&eacute;pertoires, s&eacute;par&eacute;s par
	      deux points, pour la recherche des pages de manuel.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Fixer une variable d'environnement diff&egrave;re
      l&eacute;g&egrave;rement d'un interpr&eacute;teur de commandes
      &agrave; l'autre.  Par exemple,
      dans le style de l'interpr&eacute;teur de commandes de type C-shell comme
      <command>tcsh</command> et <command>csh</command>, vous
      utiliseriez <command>setenv</command> pour fixer le
      contenu d'une variable d'environnement.  Sous les interpr&eacute;teurs de
      commandes Bourne comme <command>sh</command> et
      <command>bash</command>, vous utiliseriez
      <command>export</command> pour configurer vos
      variables d'environnement.  Par exemple, pour fixer ou modifier la
      variable d'environnement <envar>EDITOR</envar>, sous
      <command>csh</command> ou <command>tcsh</command> une commande
      comme la suivante fixera <envar>EDITOR</envar> &agrave;
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Sous les interpr&eacute;teurs de commandes Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Vous pouvez faire afficher &agrave; la plupart des
      interpr&eacute;teurs de commandes la variable d'environnement
      en pla&ccedil;ant un caract&egrave;re
      <literal>$</literal> juste devant son nom sur la ligne
      de commande.  Par exemple, <command>echo $TERM</command> affichera
      le contenu de <envar>$TERM</envar>, car l'interpr&eacute;teur de commande
      compl&egrave;te <envar>$TERM</envar> et passe la main &agrave;
      <command>echo</command>.</para>

    <para>Les interpr&eacute;teurs de commandes traitent beaucoup de
      caract&egrave;res sp&eacute;ciaux, appel&eacute;s
      m&eacute;tacaract&egrave;res, en tant que repr&eacute;sentation
      particuli&egrave;re des donn&eacute;es.  Le plus commun est le
      caract&egrave;re <literal>*</literal>, qui repr&eacute;sente
      z&eacute;ro ou plusieurs caract&egrave;res dans le nom du fichier.
      Ces m&eacute;tacaract&egrave;res sp&eacute;ciaux peuvent &ecirc;tre
      utilis&eacute;s pour compl&eacute;ter automatiquement le nom des
      fichiers.  Par exemple, taper <command>echo *</command> est presque
      la m&ecirc;me chose
      que taper <command>ls</command> parce que l'interpr&eacute;teur de
      commandes prendra tous les fichiers qui correspondent &agrave;
      <literal>*</literal> et les passera &agrave; <command>echo</command> pour
      les afficher.</para>

    <para>Pour &eacute;viter que l'interpr&eacute;teur de commande
      n'interpr&egrave;te les caract&egrave;res sp&eacute;ciaux, ils peuvent
      &ecirc;tre neutralis&eacute;s en ajoutant un
      caract&egrave;re antislash (<literal>\</literal>) devant.  <command>echo
      $TERM</command> affichera votre type de terminal.  <command>echo
      \$TERM</command> affichera <envar>$TERM</envar> tel quel.</para>

    <sect2 id="changing-shells">
      <title>Changer d'interpr&eacute;teur de commandes</title>

      <para>La m&eacute;thode la plus simple pour changer votre
	interpr&eacute;teur de commandes est d'utiliser la commande
	<command>chsh</command>.  En lan&ccedil;ant <command>chsh</command>
	vous arriverez dans l'&eacute;diteur
	correspondant &agrave; votre variable d'environnement
	<envar>EDITOR</envar>; si elle n'est pas fix&eacute;e, cela sera
	<command>vi</command>.  Modifiez la ligne &ldquo;Shell:&rdquo;
	en cons&eacute;quence.</para>

      <para>Vous pouvez &eacute;galement passer le param&egrave;tre
	<option>-s</option> &agrave; <command>chsh</command>; cela modifiera
	votre interpr&eacute;teur de commandes sans avoir &agrave; utiliser
	un &eacute;diteur.  Par exemple, si
	vous vouliez changer votre interpr&eacute;teur de commandes pour
	<command>bash</command>,
	ce qui suit devrait faire l'affaire:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>L'interpr&eacute;teur de commandes que vous d&eacute;sirez
	  utiliser <emphasis>doit</emphasis> &ecirc;tre pr&eacute;sent dans
	  le fichier <filename>/etc/shells</filename>.  Si vous avez
	  install&eacute; l'interpr&eacute;teur de commandes &agrave; partir
	  du <link linkend="ports">catalogue des logiciels port&eacute;s</link>,
	  alors cela a d&ucirc; d&eacute;j&agrave; &ecirc;tre fait pour vous.
	  Si vous avez install&eacute; &agrave;
	  la main l'interpr&eacute;teur de commandes, vous devez alors le
	  faire.</para>

      <para>Par exemple, si vous avez install&eacute; <command>bash</command>
	&agrave; la main et l'avez plac&eacute; dans
	<filename>/usr/local/bin</filename>, vous devrez faire:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Puis relancer <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Editeurs de texte</title>
    <indexterm><primary>&eacute;diteurs de texte</primary></indexterm>
    <indexterm><primary>&eacute;diteurs</primary></indexterm>

    <para>Beaucoup de configurations sous FreeBSD sont faites en &eacute;ditant
      des fichiers textes.  Aussi ce serait une bonne id&eacute;e de se
      familiariser avec un &eacute;diteur de texte.  FreeBSD est fourni avec
      quelques-uns en tant qu'&eacute;l&eacute;ments du syst&egrave;me de base,
      et beaucoup d'autres sont disponibles dans le catalogue des logiciels
      port&eacute;s.</para>

    <indexterm>
      <primary>&eacute;diteurs</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>L'&eacute;diteur de plus facile et le plus simple &agrave; apprendre
      est un &eacute;diteur appel&eacute; <application>ee</application>,
      qui signifie l'&eacute;diteur facile (easy editor).  Pour lancer
      <application>ee</application>, on taperait sur la ligne de
      commande <command>ee <replaceable>fichier</replaceable></command> o&ugrave;
      <replaceable>fichier</replaceable> est le nom du fichier qui doit &ecirc;tre
      &eacute;dit&eacute;.  Par exemple, pour &eacute;diter
      <filename>/etc/rc.conf</filename>, tapez <command>ee
      /etc/rc.conf</command>.  Une fois sous <command>ee</command>, toutes
      les commandes pour utiliser les fonctions de l'&eacute;diteur sont
      affich&eacute;es en haut de l'&eacute;cran.  Le caract&egrave;re
      <literal>^</literal>
      repr&eacute;sente la touche <keycap>Ctrl</keycap> sur le clavier, donc
      <literal>^e</literal> repr&eacute;sente la combinaison de touches
      <keycombo
      action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
      Pour quitter <application>ee</application>, appuyez sur la touche
      <keycap>Echap</keycap>, ensuite choisissez
      &ldquo;leave editor&rdquo;.  L'&eacute;diteur
      vous demandera s'il doit sauver les changements si le fichier a
      &eacute;t&eacute; modifi&eacute;.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>&eacute;diteurs</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>&eacute;diteurs</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD est &eacute;galement fourni avec des &eacute;diteurs de texte
      plus puissants comme <application>vi</application> en tant
      qu'&eacute;l&eacute;ment du
      syst&egrave;me de base, alors que d'autres &eacute;diteurs, comme
      <application>Emacs</application> et <application>vim</application>, en tant
      qu'&eacute;l&eacute;ment du catalogue des logiciels port&eacute;s de
      FreeBSD (<filename role="package">editors/emacs</filename> et <filename role="package">editors/vim</filename>).  Ces &eacute;diteurs offrent beaucoup plus de
      fonctionnalit&eacute;s et de puissance aux d&eacute;pens d'&ecirc;tre
      un peu plus compliqu&eacute;s &agrave; apprendre.
      Cependant si vous projetez de faire beaucoup d'&eacute;dition de texte,
      l'&eacute;tude d'un &eacute;diteur plus puissant comme
      <application>vim</application> ou
      <application>Emacs</application> vous permettra d'&eacute;conomiser beaucoup plus
      de temps &agrave; la longue.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>P&eacute;riph&eacute;riques et fichiers sp&eacute;ciaux de
      p&eacute;riph&eacute;rique</title>

    <para>Un p&eacute;riph&eacute;rique est un terme utilis&eacute; la plupart
      du temps pour les activit&eacute;s en rapport avec le mat&eacute;riel
      pr&eacute;sent sur le syst&egrave;me,
      incluant les disques, les imprimantes, les cartes graphiques, et les
      claviers.  Quand FreeBSD d&eacute;marre, la majorit&eacute; de ce
      qu'affiche FreeBSD est la d&eacute;tection des
      p&eacute;riph&eacute;riques.  Vous pouvez &agrave; nouveau
      consulter les messages de d&eacute;marrage en visualisant le fichier
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Par exemple, <devicename>acd0</devicename> est le premier
      lecteur de CDROM IDE, tandis que <devicename>kbd0</devicename>
      repr&eacute;sente le clavier.</para>

    <para>La plupart de ces p&eacute;riph&eacute;riques sous un syst&egrave;me
      d'exploitation &unix; peuvent &ecirc;tre acc&eacute;d&eacute;s par
      l'interm&eacute;diaire de fichiers appel&eacute;s fichiers
      sp&eacute;ciaux de p&eacute;riph&eacute;rique
      (&ldquo;device node&rdquo;), qui sont situ&eacute;s dans le
      r&eacute;pertoire <filename>/dev</filename>.</para>

    <sect2>
      <title>Cr&eacute;er des fichiers sp&eacute;ciaux de
	p&eacute;riph&eacute;rique</title>
      <para>Quand vous ajoutez un nouveau p&eacute;riph&eacute;rique
	&agrave; votre syst&egrave;me, ou compilez le support pour des
	p&eacute;riph&eacute;riques suppl&eacute;mentaires, de nouveaux
	fichiers sp&eacute;ciaux de p&eacute;riph&eacute;rique doivent
	&ecirc;tre cr&eacute;&eacute;s.</para>

      <sect3>
	<title><literal>DEVFS</literal> (&ldquo;DEVice File System&rdquo; -
	  Syst&egrave;me de fichiers de p&eacute;riph&eacute;rique)</title>

	<para>Le syst&egrave;me de fichiers de p&eacute;riph&eacute;rique, ou
	  <literal>DEVFS</literal>, fournit un acc&egrave;s &agrave; l'espace
	  nom des p&eacute;riph&eacute;riques du noyau dans l'espace nom du
	  syst&egrave;me de fichiers global.  Au lieu d'avoir &agrave;
	  cr&eacute;er et modifier les fichiers sp&eacute;ciaux de
	  p&eacute;riph&eacute;rique, <literal>DEVFS</literal>
	  maintient ce syst&egrave;me de fichiers particulier pour vous.</para>

	<para>Voir la page de manuel de &man.devfs.5; pour plus
	  d'information.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Le format des fichiers binaires</title>

    <para>Afin de comprendre pourquoi &os; utilise le format
      &man.elf.5;, vous devez d'abord conna&icirc;tre
      quelques d&eacute;tails concernant les trois formats
      &ldquo;dominants&rdquo; d'ex&eacute;cutables actuellement en vigueur
      sous &unix;:</para>

    <itemizedlist>
      <listitem>
	<para>&man.a.out.5;</para>

	<para>Le plus vieux et le format objet &ldquo;classique&rdquo;
	  d'&unix;.  Il utilise une ent&ecirc;te courte et compacte
	  avec un nombre magique au d&eacute;but qui est souvent
	  utilis&eacute; pour caract&eacute;riser le format (voir la
	  page de manuel &man.a.out.5; pour plus de d&eacute;tails).
	  Il contient trois segments charg&eacute;s: .text, .data,
	  et .bss plus une table de symboles et une table de
	  cha&icirc;nes de caract&egrave;res.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Le format objet SVR3.  L'ent&ecirc;te comprend une
	  table de section, de telle sorte que vous avez plus de
	  sections qu'uniquement .text, .data et .bss.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Le successeur de <acronym>COFF</acronym>, qui
	  permet des sections multiples et des valeurs possibles de 32
	  bits et 64 bits.  Un inconv&eacute;nient majeur:
	  <acronym>ELF</acronym> a aussi &eacute;t&eacute; con&ccedil;u
	  en supposant qu'il y aurait qu'un seul ABI par architecture
	  syst&egrave;me.  Cette hypoth&egrave;se est en fait assez
	  incorrecte, et m&ecirc;me dans le monde SYSV (qui a
	  au moins trois ABIs: SVR4, Solaris, SCO) cela ne se
	  v&eacute;rifie pas.</para>

        <para>&os; essaye de contourner ce probl&egrave;me en
	  fournissant un utilitaire pour <emphasis>marquer</emphasis>
	  un ex&eacute;cutable connu <acronym>ELF</acronym> avec
	  des informations sur l'ABI qui va avec.  Consultez la page
	  de manuel de &man.brandelf.1; pour plus
	  d'informations.</para>
      </listitem>
    </itemizedlist>

    <para>&os; vient du camp &ldquo;classique&rdquo; et a
      utilis&eacute; le format &man.a.out.5;, une technologie
      employ&eacute;e et &eacute;prouv&eacute;e &agrave; travers des
      g&eacute;n&eacute;rations de BSDs, jusqu'aux d&eacute;buts de la
      branche 3.X.  Bien qu'il fut possible de compiler et
      d'ex&eacute;cuter des binaires natifs <acronym>ELF</acronym> (et
      noyaux) sous &os; avant cela, &os; a initialement
      r&eacute;sist&eacute; &agrave; la &ldquo;pression&rdquo; de passer
      &agrave; <acronym>ELF</acronym> comme format par d&eacute;faut.
      Pourquoi?  Bien, quand le camp Linux ont fait leur
      p&eacute;nible transition vers <acronym>ELF</acronym>, ce n'est pas
      tant fuir le format <filename>a.out</filename> qui rendait
      difficile la construction de biblioth&egrave;ques partag&eacute;e
      pour les d&eacute;veloppeurs mais le m&eacute;canisme de
      biblioth&egrave;ques partag&eacute;es bas&eacute; sur des tables de
      sauts inflexible.  Puisque les outils <acronym>ELF</acronym>
      disponibles offraient une solution au probl&egrave;me 
      des biblioth&egrave;ques partag&eacute;es et &eacute;taient
      per&ccedil;us comme &ldquo;le chemin &agrave; suivre&rdquo; de toute
      fa&ccedil;on, le co&ucirc;t de la migration a &eacute;t&eacute;
      accept&eacute; comme n&eacute;cessaire, et la transition a
      &eacute;t&eacute; r&eacute;alis&eacute;e.  Le m&eacute;canisme &os;
      de biblioth&egrave;ques partag&eacute;es se rapproche plus
      du style de m&eacute;canisme de biblioth&egrave;ques
      partag&eacute;es de &sunos; de Sun, et est tr&egrave;s simple
      &agrave; utiliser.</para>

    <para>Pourquoi existe-t-il tant de formats diff&eacute;rents?</para>

    <para>Dans un obscure et lointain pass&eacute;, il y avait du
      mat&eacute;riel simple.  Ce mat&eacute;riel simple supportait
      un simple petit syst&egrave;me.  <filename>a.out</filename>
      &eacute;tait compl&egrave;tement adapt&eacute; pour
      repr&eacute;senter les binaires sur ce syst&egrave;me simple
      (un PDP-11).  Au fur et &agrave; mesure que des personnes
      portaient &unix; &agrave; partir de ce syst&egrave;me
      simple, ils ont maintenus le format <filename>a.out</filename>
      parce qu'il &eacute;tait suffisant pour les premiers portages
      d'&unix; sur des architectures comme le Motorola 68k, les VAX,
      etc.</para>

    <para>Alors un certain ing&eacute;nieur mat&eacute;riel brillant
      a d&eacute;cid&eacute; qu'il pourrait forcer le mat&eacute;riel
      &agrave; faire des choses bizarre, l'autorisant ainsi &agrave;
      r&eacute;duire le nombre de portes logiques et permettant
      au coeur du CPU de fonctionner plus rapidement.
      Bien qu'on l'a fait fonctionner avec ce nouveau
      type de mat&eacute;riel (connu de nos jour sous le nom de
      <acronym>RISC</acronym>), <filename>a.out</filename> n'&eacute;tait pas adapt&eacute;
      &agrave; ce mat&eacute;riel, aussi beaucoup de formats ont
      &eacute;t&eacute; d&eacute;velopp&eacute;s
      pour obtenir de meilleures performances de ce mat&eacute;riel
      que ce que pouvait offrir le simple et limit&eacute; format
      qu'&eacute;tait <filename>a.out</filename>.  Des
      choses comme <acronym>COFF</acronym>, <acronym>ECOFF</acronym>,
      et quelques autres obscures formats ont &eacute;t&eacute;
      invent&eacute; et leur limites explor&eacute;es avant que les choses
      ne se fixent sur <acronym>ELF</acronym>.</para>

    <para>En outre, les tailles des programmes devenaient
      &eacute;normes alors que les disques (et la m&eacute;moire
      physique) &eacute;taient toujours relativement
      petits, aussi le concept de biblioth&egrave;que partag&eacute;e
      est n&eacute;.  Le syst&egrave;me de VM (m&eacute;moire virtuelle)
      est &eacute;galement devenu plus sophistiqu&eacute;.
      Tandis que chacune de ces avanc&eacute;es &eacute;tait
      faites en utilisant le format <filename>a.out</filename>,
      son utilit&eacute; a &eacute;t&eacute; &eacute;largie
      de plus en plus avec chaque nouvelle fonction.  De plus les
      gens ont voulu charger dynamiquement des choses &agrave;
      l'ex&eacute;cution, ou se d&eacute;barrasser de partie de
      leur programme apr&egrave;s l'initialisation pour &eacute;conomiser
      de l'espace m&eacute;moire et de pagination.  Les langages
      sont devenus plus sophistiqu&eacute;s et les gens ont voulu
      du code appel&eacute; automatiquement avant la partie
      principale du programme.  Beaucoup de modifications ont
      &eacute;t&eacute; apport&eacute;es au format <filename>a.out</filename>
      pour rendre possible toutes ces choses, et cela a
      fonctionn&eacute; pendant un certain temps.  Avec le temps,
      <filename>a.out</filename> n'&eacute;tait plus capable de
      g&eacute;rer tous ces probl&egrave;mes sans une augmentation
      toujours croissante du code et de sa complexit&eacute;.
      Tandis <acronym>ELF</acronym> r&eacute;solvait plusieurs de
      ces probl&egrave;mes, il aurait &eacute;t&eacute; p&eacute;nible
      de quitter un syst&egrave;me qui a fonctionn&eacute;.
      Ainsi <acronym>ELF</acronym> a d&ucirc; attendre jusqu'au moment
      o&ugrave; il &eacute;tait plus p&eacute;nible de rester avec
      <filename>a.out</filename> que d'&eacute;migrer vers
      <acronym>ELF</acronym>.</para>

    <para>Cependant, avec le temps, les outils de compilation
      desquels ceux de &os; sont d&eacute;riv&eacute;s (l'assembleur
      et le chargeur tout sp&eacute;cialement) ont
      &eacute;volu&eacute; en parall&egrave;le.
      Les d&eacute;veloppeurs &os; ajout&egrave;rent les
      biblioth&egrave;ques partag&eacute;es et corrig&egrave;rent
      quelques bogues.  Les gens de chez GNU qui ont &agrave;
      l'origine &eacute;crit ces programmes, les r&eacute;crivirent
      et ajout&egrave;rent un support plus simple pour la compilation
      multi-plateformes, avec diff&eacute;rents formats
      &agrave; volont&eacute;, et ainsi de suite.  Lorsque beaucoup de personnes
      ont voulu &eacute;laborer des compilateurs multi-plateformes
      pour &os;, elles n'eurent pas beaucoup de chance puisque
      les anciennes sources que &os; avait pour
      <application>as</application> et <application>ld</application>
      n'&eacute;taient pas adapt&eacute;es &agrave; cette t&acirc;che.
      Le nouvel ensemble d'outils de GNU
      (<application>binutils</application>) supporte la compilation
      multi-plateformes, <acronym>ELF</acronym>, les
      biblioth&egrave;ques partag&eacute;es, les extensions C++, etc.
      De plus, de nombreux vendeurs de logiciels fournissent des
      binaires <acronym>ELF</acronym>, et c'est une bonne chose pour
      permettre leur ex&eacute;cution sous &os;.</para>

    <para><acronym>ELF</acronym> est plus expressif
      qu'<filename>a.out</filename> et permet plus d'extensibilit&eacute;
      dans le syst&egrave;me de base.
      Les outils <acronym>ELF</acronym> sont mieux maintenus, et
      offrent un support pour la compilation multi-plateformes, ce qui
      est important pour de nombreuses personnes.
      <acronym>ELF</acronym> peut &ecirc;tre l&eacute;g&egrave;rement plus lent
      qu'<filename>a.out</filename>, mais tenter de mesurer cette
      diff&eacute;rence n'est pas ais&eacute;.  Il y a
      &eacute;galement de nombreux d&eacute;tails qui
      diff&egrave;rent entre les deux dans la fa&ccedil;on dont
      ils mappent les pages m&eacute;moire, g&egrave;re le code
      d'initialisation, etc.
      Dans le futur, le support <filename>a.out</filename> sera
      retir&eacute; du noyau <filename>GENERIC</filename>, et
      par la suite retir&eacute; des sources du noyau une fois que le
      besoin d'ex&eacute;cuter d'anciens programmes
      <filename>a.out</filename> aura disparu.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Pour plus d'information</title>

    <sect2 id="basics-man">
      <title>Les pages de manuel</title>
      <indexterm><primary>pages de manuel</primary></indexterm>

      <para>La documentation la plus compl&egrave;te sur FreeBSD est sous la
	forme de pages de manuel.  Presque chaque programme sur le
	syst&egrave;me est fournit avec un court manuel de
	r&eacute;f&eacute;rence expliquant l'utilisation de base et les
	diverses options.  Ces manuels peuvent &ecirc;tre visualis&eacute;s
	avec la commande <command>man</command>.
	L'utilisation de la commande <command>man</command> est
	simple:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para><literal>command</literal> est le nom de la commande
	&agrave; propos de laquelle vous d&eacute;sirez en savoir plus.
	Par exemple, pour en savoir plus au sujet de la commande
	<command>ls</command> tapez:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Les manuels en ligne sont divis&eacute;s en sections
	num&eacute;rot&eacute;es:</para>

      <orderedlist>
	<listitem>
	  <para>Commandes utilisateur.</para>
	</listitem>

	<listitem>
	  <para>Appels syst&egrave;me et num&eacute;ros d'erreur.</para>
	</listitem>

	<listitem>
	  <para>Fonctions des biblioth&egrave;ques C.</para>
	</listitem>

	<listitem>
	  <para>Pilotes de p&eacute;riph&eacute;rique.</para>
	</listitem>

	<listitem>
	  <para>Formats de fichier.</para>
	</listitem>

	<listitem>
	  <para>Jeux et autres divertissements.</para>
	</listitem>

	<listitem>
	  <para>Information diverse.</para>
	</listitem>

	<listitem>
	  <para>Commandes de maintenance et d'utilisation du
	    syst&egrave;me.</para>
	</listitem>

	<listitem>
	  <para>Information de d&eacute;veloppement du noyau.</para>
	</listitem>
      </orderedlist>

      <para>Dans certains cas, le m&ecirc;me sujet peut appara&icirc;tre
	dans plus d'une section du manuel en ligne.  Par exemple, il existe une
	commande utilisateur <command>chmod</command> et un appel
	syst&egrave;me <function>chmod()</function>.  Dans ce cas, vous pouvez
	pr&eacute;ciser &agrave; la commande <command>man</command> laquelle
	vous d&eacute;sirez en sp&eacute;cifiant la section:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Cela affichera la page de manuel de la commande utilisateur
	<command>chmod</command>.  Les r&eacute;f&eacute;rences &agrave;
	une section particuli&egrave;re du manuel en ligne sont
	traditionnellement plac&eacute;es entre parenth&egrave;ses, ainsi
	&man.chmod.1; se rapporte &agrave; la commande
	utilisateur <command>chmod</command> et &man.chmod.2; se
	rapporte &agrave; l'appel syst&egrave;me.</para>

      <para>C'est parfait si vous connaissez le nom de la commande et
	vous souhaitez simplement savoir comment l'utiliser, mais qu'en
	est-il si vous ne pouvez pas vous rappelez du nom de la
	commande?  Vous pouvez utiliser <command>man</command> pour
	rechercher des mots-cl&eacute;s dans les descriptions de commandes en
	employant l'option <option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Avec cette commande on vous affichera la liste des commandes
	qui ont le mot-cl&eacute; &ldquo;mail&rdquo; dans leurs descriptions.
	C'est en fait &eacute;quivalent &agrave; l'utilisation de la commande
	<command>apropos</command>.</para>

      <para>Ainsi, vous regardez toutes ces commandes fantaisistes
	contenues dans <filename>/usr/bin</filename> mais vous n'avez
	pas la moindre id&eacute;e de ce quelles font vraiment?  Faites
	simplement:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>ou</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>ce qui fait la m&ecirc;me chose.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>Fichiers GNU Info</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>
      <indexterm><primary>Fondation pour le Logiciel Libre</primary></indexterm>

      <para>FreeBSD inclut beaucoup d'applications et d'utilitaires
	produit par la Fondation pour le Logiciel Libre ( Free Software
	Foundation).  En plus des pages de manuel, ces programmes sont
	fournis avec des documents hypertexte appel&eacute;s fichiers
	<literal>info</literal> qui peuvent &ecirc;tre lus avec la commande
	<command>info</command> ou, si vous avez install&eacute;
	<application>emacs</application>, dans le mode info
	d'<application>emacs</application>.</para>

      <para>Pour utiliser la commande &man.info.1;, tapez simplement:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Pour une br&egrave;ve introduction, tapez <literal>h</literal>.
	Pour une r&eacute;f&eacute;rence rapide sur la commande, tapez
	<literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

