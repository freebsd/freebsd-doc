<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.380
-->

<chapter id="advanced-networking">
  <title>Administration r&eacute;seau avanc&eacute;e</title>
  &trans.a.fonvieille;

  <sect1 id="advanced-networking-synopsis">
    <title>Synopsis</title>

    <para>Ce chapitre abordera certains nombre de sujets r&eacute;seau
      avanc&eacute;s.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous
      conna&icirc;trez:</para>

    <itemizedlist>
      <listitem>
	<para>Les bases sur les passerelles et les routes.</para>
      </listitem>

      <listitem>
	<para>Comment configurer les p&eacute;riph&eacute;riques IEEE
	  802.11 et &bluetooth;.</para>
      </listitem>

      <listitem>
	<para>Comment utiliser &os; en tant que pont
	  (&ldquo;bridge&rdquo;).</para>
      </listitem>

      <listitem>
	<para>Comment configurer le d&eacute;marrage via le
	  r&eacute;seau pour une machine sans disque dur.</para>
      </listitem>

      <listitem>
	<para>Comment configurer la translation d'adresse
	  r&eacute;seau.</para>
      </listitem>

      <listitem>
	<para>Comment connecter deux ordinateurs via PLIP.</para>
      </listitem>

      <listitem>
	<para>Comment configurer l'IPv6 sur une machine &os;.</para>
      </listitem>

      <listitem>
	<para>Comment configurer ATM.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Comprendre les bases des proc&eacute;dures
	  <filename>/etc/rc</filename>.</para>
      </listitem>

      <listitem>
	<para>Etre familier avec la terminologie r&eacute;seau de
	  base.</para>
      </listitem>

      <listitem>
	<para>Savoir comment configurer et installer un nouveau noyau
	  &os; (<xref linkend="kernelconfig">).</para>
      </listitem>

      <listitem>
	<para>Savoir comment installer des logiciels tierce-partie
	  (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Coranth</firstname>
	  <surname>Gryphon</surname>
	  <contrib>Contribution de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Passerelles et routes</title>

    <indexterm><primary>routage</primary></indexterm>
    <indexterm><primary>passerelles</primary></indexterm>
    <indexterm><primary>sous-r&eacute;seau</primary></indexterm>
    <para>Pour qu'une machine soit en mesure d'en contacter une autre,
      il faut que soit mis en place un m&eacute;canisme qui
      d&eacute;crive comment aller de l'une &agrave; l'autre.  C'est ce
      que l'on appelle le <firstterm>routage</firstterm>.  Une
      &ldquo;route&rdquo; est d&eacute;finie par une paire d'adresses:
      une &ldquo;destination&rdquo; et une &ldquo;passerelle&rdquo;.
      Cette paire signifie que pour atteindre cette
      <emphasis>destination</emphasis>, vous devez passer par cette
      <emphasis>passerelle</emphasis>.  Il y a trois sortes de
      destination: les machines individuelles, les sous-r&eacute;seaux,
      et &ldquo;default&rdquo;&mdash;la destination par d&eacute;faut.
      La route par d&eacute;faut (&ldquo;default route&rdquo;) est
      utilis&eacute;e lorsqu'aucune autre route n'est applicable.  Nous
      parlerons un peu plus des routes par d&eacute;faut par la suite.
      Il existe &eacute;galement trois sortes de passerelles: les
      machines individuelles, les interfaces (aussi appel&eacute;es
      &ldquo;liens&rdquo;), et les adresses Ethernet mat&eacute;rielles
      (adresses MAC).</para>

    <sect2>
      <title>Un exemple</title>

      <para>Pour illustrer diff&eacute;rents aspects du routage,
	nous utiliserons l'exemple suivant, qui est produit par la
	commande <command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.example.com link#1             UC          0        0
224              link#1             UC          0        0</screen>

      <indexterm><primary>route par d&eacute;faut</primary></indexterm>
      <para>Les deux premi&egrave;res lignes d&eacute;finissent la
	route par d&eacute;faut (dont nous parlerons dans la <link
	linkend="network-routing-default">section suivante</link>) et la
	route <hostid>localhost</hostid>.</para>

      <indexterm><primary>interface en boucle</primary></indexterm>
      <para>L'interface (colonne <literal>Netif</literal>) qu'il est
	indiqu&eacute; d'utiliser pour <literal>localhost</literal> est
	<devicename>lo0</devicename>, aussi appel&eacute;e interface
	&ldquo;loopback&rdquo;&mdash;en boucle.  Ce qui veut dire que
	tout le trafic vers cette destination doit rester interne, au
	lieu d'&ecirc;tre envoy&eacute; sur le r&eacute;seau local,
	puisqu'il reviendra de toute fa&ccedil;on &agrave; son point de
	d&eacute;part.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>adresse MAC</secondary>
      </indexterm>
      <para>Ce qui se remarque ensuite, ce sont les adresses
	commen&ccedil;ant par <hostid role="mac">0:e0:</hostid>.  Ce
	sont les adresses Ethernet mat&eacute;rielles, qui sont
	&eacute;galement connues sous le nom d'adresses MAC.  &os;
	reconna&icirc;tra automatiquement toute machine
	(<hostid>test0</hostid> dans l'exemple) sur le r&eacute;seau
	local Ethernet et ajoutera une route vers cette machine,
	directement via l'interface Ethernet
	<devicename>ed0</devicename>.  Il y a aussi un d&eacute;lai
	(colonne <literal>Expire</literal>) associ&eacute; &agrave; ce
	type de route, qui est utilis&eacute; si l'on entend plus parler
	de cette machine pendant un laps de temps pr&eacute;cis.  Quand
	cela arrive, la route vers cette machine est automatiquement
	supprim&eacute;e.  Ces machines sont identifi&eacute;es par un
	m&eacute;canisme appel&eacute; RIP (&ldquo;Routing Information
	Protocol&rdquo;&mdash;protocole d'information de routage), qui
	met en place des routes vers les machines locales en
	d&eacute;terminant le chemin le plus court.</para>

      <indexterm><primary>sous-r&eacute;seau</primary></indexterm>
      <para>&os; ajoutera &eacute;galement des routes de
	sous-r&eacute;seau pour le sous-r&eacute;seau local (<hostid
	role="ipaddr">10.20.30.255</hostid> est l'adresse de diffusion
	pour le sous-r&eacute;seau <hostid
	role="ipaddr">10.20.30</hostid>, et <hostid
	role="domainname">example.com</hostid> est le nom de domaine
	associ&eacute; &agrave; ce sous-r&eacute;seau).  La
	d&eacute;nomination <literal>link#1</literal> fait
	r&eacute;f&eacute;rence &agrave; la premi&egrave;re carte
	Ethernet de la machine.  Vous constaterez qu'il n'y a pas
	d'autre interface associ&eacute;e &agrave; ces routes.</para>

      <para>Ces deux types de routes (vers les machines du
	r&eacute;seau local et les sous-r&eacute;seaux locaux) sont
	automatiquement configur&eacute;s par un &ldquo;daemon&rdquo;
	appel&eacute; <application>routed</application>.  S'il ne
	tourne pas, alors seules les routes d&eacute;finies comme
	statiques (i.e. explicitement d&eacute;finies)
	existeront.</para>

      <para>La ligne <literal>host1</literal> fait
	r&eacute;f&eacute;rence &agrave; votre machine, qui est
	identifi&eacute;e par l'adresse Ethernet.  Puisque nous sommes
	l'&eacute;metteur, &os; sait qu'il faut utiliser l'interface
	en &ldquo;boucle&rdquo; (<devicename>lo0</devicename>)
	plut&ocirc;t que d'envoyer les donn&eacute;es sur l'interface
	Ethernet.</para>

      <para>Les deux lignes <literal>host2</literal> montrent ce qui
	se passe quand on utilise un alias avec &man.ifconfig.8;
	(lisez la section sur l'Ethernet pour savoir pour quelles
	raisons on peut vouloir cela).  Le symbole
	<literal>=&gt;</literal> qui suit l'interface
	<devicename>lo0</devicename> indique que non seulement nous
	utilisons l'interface en &ldquo;boucle&rdquo; (puisque cette
	adresse correspond &eacute;galement &agrave; la machine
	locale), mais que c'est plus sp&eacute;cifiquement un alias.
	Ce type de route n'appara&icirc;t que sur la machine pour
	laquelle est d&eacute;fini l'alias; sur toutes les autres
	machines du r&eacute;seau local il n'y aura q'une ligne
	<literal>link#1</literal> pour cette machine.</para>

      <para>La derni&egrave;re ligne (le sous-r&eacute;seau
	destinataire <hostid role="ipaddr">224</hostid>) concerne le
	multicasting (diffusion pour plusieurs destinataires), qui
	sera abord&eacute; dans une autre section.</para>

      <para>Et enfin, diverses caract&eacute;ristiques de chaque route
	sont indiqu&eacute;es dans la colonne <literal>Flags</literal>
	(indicateurs).  Ci-dessous, une courte table pr&eacute;sente
	certains de ces indicateurs et leur signification:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="4*">

	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Active (&ldquo;Up&rdquo;): la route est
		active.</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Machine (&ldquo;Host&rdquo;): la destination de
		la route est une machine.</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Passerelle (&ldquo;Gateway&rdquo;): envoyer tout
		ce qui concerne cette destination sur la machine
		distante indiqu&eacute;e, qui d&eacute;terminera
		&agrave; qui transmettre ensuite.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Statique (&ldquo;Static&rdquo;): cette route a
		&eacute;t&eacute; configur&eacute;e manuellement et non
		pas g&eacute;n&eacute;r&eacute;e automatiquement par le
		syst&egrave;me.</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Clone: g&eacute;n&egrave;re une nouvelle route
		sur la base de celle-ci pour les machines auxquelles
		nous nous connectons.  Ce type de route est normalement
		utilis&eacute; pour les r&eacute;seaux locaux.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>Clon&eacute;e (&ldquo;WasCloned&rdquo;): cette
		route a &eacute;t&eacute; auto-configur&eacute;e (Clone)
		&agrave; partir d'une route pour le r&eacute;seau
		local.</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Lien (&ldquo;Link&rdquo;): la route fait
		r&eacute;f&eacute;rence &agrave; une adresse
		mat&eacute;rielle Ethernet.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Routes par d&eacute;faut</title>

      <indexterm><primary>route par d&eacute;faut</primary></indexterm>
      <para>Quand le syst&egrave;me local doit &eacute;tablir une
	connexion avec une machine distante, il consulte la table de
	routage pour voir s'il existe d&eacute;j&agrave; une route
	connue.  Si la machine distante appartient &agrave; un
	sous-r&eacute;seau auquel le syst&egrave;me sait se connecter
	(routes clon&eacute;es), alors le syst&egrave;me v&eacute;rifie
	s'il peut se connecter via cette interface.</para>

      <para>Si toutes les routes connues &eacute;chouent, il reste
	alors au syst&egrave;me une derni&egrave;re option: la route
	par &ldquo;d&eacute;faut&rdquo;.  Cette route est un type
	particulier de route passerelle (c'est
	g&eacute;n&eacute;ralement la seule du syst&egrave;me), et est
	toujours marqu&eacute;e avec un <literal>c</literal> dans le
	champ des indicateurs.  Pour les machines du r&eacute;seau
	local, cette passerelle est d&eacute;finie avec la machine qui
	est directement connect&eacute;e au monde ext&eacute;rieur
	(que ce soit par une liaison PPP, DSL, cable, T1, ou toute
	autre interface r&eacute;seau).</para>

      <para>Si vous configurez la route par d&eacute;faut sur une
	machine qui fonctionne comme passerelle vers le monde
	ext&eacute;rieur, alors la route par d&eacute;faut sera la
	passerelle de votre Fournisseur d'Acc&egrave;s &agrave;
	Internet (FAI).</para>

      <para>Examinons un exemple de route par d&eacute;faut.  Voici
	une configuration classique:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [FAI-Serv]  &lt;--ether--&gt;  [T1-GW]
      </literallayout>
	</textobject>
      </mediaobject>

      <para>Les machines <hostid>Local1</hostid> et
	<hostid>Local2</hostid> sont sur votre site.
	<hostid>Local1</hostid> est connect&eacute;e au serveur du FAI
	via une liaison PPP par modem.  Ce serveur PPP est
	connect&eacute; par l'interm&eacute;diaire d'un r&eacute;seau
	local &agrave; un autre ordinateur passerelle reli&eacute; au
	point d'entr&eacute;e Internet du FAI.</para>

      <para>Les routes par d&eacute;faut sur chacune de vos machines
	seront:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Machine</entry>
	      <entry>Passerelle par d&eacute;faut</entry>
	      <entry>Interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Une question qui revient souvent est &ldquo;Pourquoi
	(ou comment) d&eacute;finir <hostid>T1-GW</hostid> comme
	passerelle par d&eacute;faut pour <hostid>Local1</hostid>,
	plut&ocirc;t que le serveur du FAI auquel elle est
	connect&eacute;e?&ldquo;.</para>

      <para>Rappelez-vous, puisque l'interface PPP utilise, de votre
	c&ocirc;t&eacute; de la connexion, une adresse IP du
	r&eacute;seau local du FAI, les routes vers toute autre
	machine du r&eacute;seau local du FAI seront automatiquement
	g&eacute;n&eacute;r&eacute;es.  Par cons&eacute;quent vous
	savez d&eacute;j&agrave; comment atteindre la machine
	<hostid>T1-GW</hostid>, il n'y a donc pas besoin
	d'&eacute;tape interm&eacute;diaire qui passe par le serveur
	du FAI.</para>

      <para>Il est habituel d'attribuer l'adresse <hostid
	role="ipaddr">X.X.X.1</hostid> &agrave; la passerelle sur
	votre r&eacute;seau local.  Donc (dans notre exemple), si
	votre espace d'adresse de classe C local &eacute;tait <hostid
	role="ipaddr">10.20.30</hostid> et que votre FAI utilisait
	l'espace <hostid role="ipaddr">10.9.9</hostid>, alors les
	routes par d&eacute;faut seraient:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Machine</entry>
	      <entry>Route par d&eacute;faut</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>
	      <entry>Local1 (10.20.30.1)</entry>
	    </row>
	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>
	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Vous pouvez ais&eacute;ment d&eacute;finir la route par
	d&eacute;faut via le fichier
	<filename>/etc/rc.conf</filename>.  Dans notre exemple, sur la
	machine <hostid>Local2</hostid>, nous avons ajout&eacute; la
	ligne suivante dans <filename>/etc/rc.conf</filename>:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Il est &eacute;galement possible de faire directement cela
	&agrave; partir de la ligne de commande avec la commande
	&man.route.8;:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Pour plus d'informations sur la manipulation &agrave; la
	main des tables de routage r&eacute;seau, consultez la page de
	manuel &man.route.8;.</para>
    </sect2>

    <sect2>
      <title>Machines sur deux r&eacute;seaux</title>

      <indexterm><primary>machines sur deux r&eacute;seaux</primary></indexterm>
      <para>Il y a un autre type de configuration dont il faut parler,
	c'est celle d'une machine qui est connect&eacute;e &agrave; deux
	r&eacute;seaux diff&eacute;rents.  Techniquement, toute machine
	servant de passerelle (comme dans l'exemple ci-dessus, en
	utilisant une connexion PPP) est une machine sur deux
	r&eacute;seaux.  Mais ce terme n'est normalement utilis&eacute;
	que pour faire r&eacute;f&eacute;rence &agrave; une machine qui
	est sur deux r&eacute;seaux locaux diff&eacute;rents.</para>

      <para>Selon le cas, la machine dispose de deux cartes Ethernet,
	ayant chacune une adresse sur des sous-r&eacute;seaux
	s&eacute;par&eacute;s.  Alternativement, la machine peut ne
	disposer que d'une seule carte Ethernet, et utiliser des alias
	avec &man.ifconfig.8;.  Le premier cas correspond &agrave;
	l'utilisation de deux r&eacute;seaux Ethernet physiquement
	s&eacute;par&eacute;s, le deuxi&egrave;me cas est
	employ&eacute; s'il n'y a qu'un seul r&eacute;seau physique
	mais deux sous-r&eacute;seaux logiquement distincts.</para>

      <para>Dans les deux cas, les tables de routage sont
	d&eacute;finies de telle sorte que chaque sous-r&eacute;seau
	sache que cette machine est la passerelle (route entrante)
	vers l'autre sous-r&eacute;seau.  Cette configuration,
	o&ugrave; la machine sert de routeur entre les deux
	sous-r&eacute;seaux, est souvent utilis&eacute;e quand il faut
	mettre en place un dispositif de s&eacute;curit&eacute;:
	filtrage de paquets ou coupe-feu, dans l'une ou dans les deux
	directions.</para>

      <para>Si vous voulez que cette machine transmette
	r&eacute;ellement les paquets entre les deux interfaces, vous
	devez demander &agrave; &os; d'activer cette
	fonctionnalit&eacute;.  Lisez la section suivante pour plus de
	d&eacute;tails sur comment faire cela.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Mettre en place un routeur</title>

      <indexterm><primary>routeur</primary></indexterm>

      <para>Un routeur est un syst&egrave;me qui transmet les paquets
	d'une interface &agrave; une autre.  Les standards de
	l'Internet et de bons principes d'ing&eacute;nierie
	emp&ecirc;chent le projet &os; d'activer cette fonction par
	d&eacute;faut sous &os;.  Vous pouvez l'activer en
	positionnant &agrave; <literal>YES</literal> la variable
	suivante du fichier &man.rc.conf.5;:</para>

      <programlisting>gateway_enable=YES          # Set to YES if this host will be a gateway</programlisting>

      <para>Cette option fixera la variable &man.sysctl.8;
	<varname>net.inet.ip.forwarding</varname> &agrave; la valeur
	<literal>1</literal>.  Si vous devez arr&ecirc;ter
	temporairement le routage, vous pouvez positionner la variable
	momentan&eacute;ment &agrave; <literal>0</literal>.</para>

      <para>Votre nouveau routeur aura besoin de route pour savoir
	o&ugrave; envoyer le trafic.  Si votre r&eacute;seau est
	suffisamment simple vous pouvez utiliser des routes statiques.
	&os; est &eacute;galement fourni avec le &ldquo;daemon&rdquo;
	de routage BSD standard &man.routed.8;, qui comprend et
	utilise les protocoles RIP (version 1 est 2) et IRDP.  Le
	support de BGP v4, OSPF v2, et d'autres protocoles de routage
	sophistiqu&eacute; est disponible avec le logiciel <filename
	role="package">net/zebra</filename>.  Des produits commerciaux
	comme <application>&gated;</application> sont &eacute;galement
	disponibles comme solutions avanc&eacute;es de routage.</para>

<indexterm><primary>BGP</primary></indexterm>
<indexterm><primary>RIP</primary></indexterm>
<indexterm><primary>OSPF</primary></indexterm>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Al</firstname>
	    <surname>Hoang</surname>
	    <contrib>Contribution de </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <!-- Feb 2004 -->
      <title>Configurarion des routes statiques</title>

      <sect3>
	<title>Configuration manuelle</title>

	<para>Supposons que nous avons un r&eacute;seau comme
	  celui-ci:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/static-routes">
	  </imageobject>

	  <textobject>
	<literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Routeur Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouteurA
   |      | (passerelle FreeBSD)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   R&eacute;seau interne 1    | 192.168.1.2/24
                       |
                   +------+
                   |      | RouteurB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     R&eacute;seau interne 2
	</literallayout>
	  </textobject>
	</mediaobject>

	<para>Dans ce sc&eacute;nario, <hostid>RouteurA</hostid> est
	  notre machine &os; qui joue le r&ocirc;le de routeur pour
	  l'Internet.  Elle a une route par d&eacute;faut vers <hostid
	  role="ipaddr">10.0.0.1</hostid> qui permet de se connecter
	  au reste du monde ext&eacute;rieur.  Nous supposerons que la
	  machine <hostid>RouteurB</hostid> est correctement
	  configur&eacute;e et sait comment transmettre vers n'importe
	  quelle destination (D'apr&egrave;s notre sch&eacute;ma c'est
	  relativement simple.  Ajoutez juste une route par
	  d&eacute;faut sur <hostid>RouteurB</hostid> en utilisant
	  <hostid role="ipaddr">192.168.1.1</hostid> comme
	  passerelle).</para>

	<para>Si nous regardons la table de routage de
	  <hostid>RouteurA</hostid> nous verrions quelque chose
	  comme:</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Avec la table de routage actuelle,
	  <hostid>RouteurA</hostid> ne sera pas en mesure d'atteindre
	  notre r&eacute;seau interne 2.  Elle ne dispose pas de route
	  pour <hostid role="ipaddr">192.168.2.0/24</hostid>.  Une
	  mani&egrave;re de r&eacute;soudre cela est d'ajouter
	  manuellement la route.  La commande suivante ajouterait le
	  r&eacute;seau interne 2 &agrave; la table de routage de
	  <hostid>RouteurA</hostid> en utilisant <hostid
	  role="ipaddr">192.168.1.2</hostid> comme point
	  interm&eacute;diaire:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Maintenant <hostid>RouteurA</hostid> peut joindre
	  n'importe quelle machine du r&eacute;seau <hostid
	  role="ipaddr">192.168.2.0/24</hostid>.</para>
      </sect3>

      <sect3>
	<title>Configuration persistante</title>

	<para>L'exemple pr&eacute;c&eacute;dent est parfait pour
	  configurer une route statique sur un syst&egrave;me en
	  fonctionnement.  Cependant, le probl&egrave;me est que
	  l'information de routage ne sera pas conserv&eacute;e si
	  vous red&eacute;marrez votre machine &os;.  L'addition d'une
	  route statique doit se faire dans votre fichier
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>La variable <literal>static_routes</literal> est une
	  liste de cha&icirc;ne de caract&egrave;res
	  s&eacute;par&eacute;es par une espace.  Chaque cha&icirc;ne
	  fait r&eacute;f&eacute;rence &agrave; un nom de route.  Dans
	  notre exemple nous avons qu'une seule cha&icirc;ne dans
	  <literal>static_routes</literal>.  Cette cha&icirc;ne est
	  <replaceable>internalnet2</replaceable>.  Nous ajoutons
	  ensuite une variable de configuration appel&eacute;e
	  <literal>route_<replaceable>internalnet2</replaceable></literal>
	  dans laquelle nous mettons tous les param&egrave;tres de
	  configuration que nous passerions &agrave; la commande
	  &man.route.8;.  Pour nous exemple pr&eacute;c&eacute;dent
	  nous aurions utilis&eacute; la commande:</para>

	  <screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	  <para>nous avons donc besoin de <literal>"-net 192.168.2.0/24
	    192.168.1.2"</literal>.</para>

	<para>Comme cela a &eacute;t&eacute; pr&eacute;cis&eacute;,
	  nous pouvons avoir plus d'une cha&icirc;ne dans la variable
	  <literal>static_routes</literal>.  Cela nous permet de
	  cr&eacute;er plusieurs routes statiques.  Les lignes
	  suivantes donnent un exemple d'ajout de routes statiques
	  pour les r&eacute;seaux <hostid
	  role="ipaddr">192.168.0.0/24</hostid> et <hostid
	  role="ipaddr">192.168.1.0/24</hostid> sur un routeur
	  imaginaire:</para>

        <programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Propagation de route</title>
      <indexterm><primary>propagation de route</primary></indexterm>

      <para>Nous avons d&eacute;j&agrave; expliqu&eacute; comment
	d&eacute;finir nos routes vers le monde ext&eacute;rieur, mais
	pas comment le monde ext&eacute;rieur apprend &agrave; nous
	localiser.</para>

      <para>Nous savons d&eacute;j&agrave; que les tables de routages
	peuvent &ecirc;tre renseign&eacute;es pour que tout le trafic
	pour un espace d'adresses donn&eacute; (dans nos exemples, un
	sous-r&eacute;seau de classe C) soit envoy&eacute; &agrave;
	une machine pr&eacute;cise de ce r&eacute;seau, qui
	transmettra les paquets entrants.</para>

      <para>Lorsqu'il attribue un espace d'adresses &agrave; votre
	site, votre fournisseur d'acc&egrave;s d&eacute;finira ses
	tables de routage de sorte que tout le trafic destin&eacute;
	&agrave; votre sous-r&eacute;seau vous soit envoy&eacute; sur
	votre liaison PPP.  Mais comment les sites &agrave; l'autre
	bout du pays savent-ils qu'ils doivent passer par votre
	fournisseur d'acc&egrave;s?</para>

      <para>Il existe un m&eacute;canisme (assez semblable au
	syst&egrave;me d'information distribu&eacute; du DNS) qui
	conserve un enregistrement de tous les espaces d'adresses
	affect&eacute;s, et d&eacute;finit leur point de connexion
	&agrave; la dorsale Internet (&ldquo;backbone&rdquo;).  La
	&ldquo;dorsale&rdquo; comprend les liaisons principales qui
	v&eacute;hiculent le trafic Internet &agrave; travers le pays
	et le monde entier.  Chaque machine de la dorsale dispose
	d'une copie de l'ensemble des tables ma&icirc;tresses qui
	aiguillent le trafic pour un r&eacute;seau donn&eacute; vers
	le transporteur correspondant de la dorsale, et de l&agrave;
	par l'interm&eacute;diaire de fournisseurs d'acc&egrave;s
	successifs, jusqu'&agrave; atteindre votre
	r&eacute;seau.</para>

      <para>C'est le r&ocirc;le de votre fournisseur d'acc&egrave;s
	d'annoncer aux sites de la dorsale qu'il est le point de
	connexion (et par cons&eacute;quent la route entrante) pour
	votre site.  C'est ce que l'on appelle la propagation de
	route.</para>
    </sect2>

    <sect2>
      <title>En cas de probl&egrave;me</title>
      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>
      <para>Il se peut qu'il y ait parfois un probl&egrave;me avec la
	propagation de route et que certains sites ne puissent vous
	atteindre.  La commande probablement la plus utile pour
	d&eacute;terminer o&ugrave; une route est d&eacute;faillante est
	la commande &man.traceroute.8;.  Elle est &eacute;galement utile
	si vous n'arrivez pas &agrave; vous connecter &agrave; une
	machine distante (i.e.  lorsque &man.ping.8;
	&eacute;choue).</para>

      <para>La commande &man.traceroute.8; prend comme
	param&egrave;tre le nom de la machine distante avec laquelle
	vous essayez d'&eacute;tablir une connexion.  Elle vous
	donnera la liste de passerelles interm&eacute;diaires
	jusqu'&agrave; la machine cible, ou jusqu'&agrave; ce qu'il
	n'y ait plus de connexion.</para>

      <para>Pour plus d'informations, consultez la page de manuel de
	&man.traceroute.8;.</para>
    </sect2>

    <sect2>
      <title>Routage multicast</title>
      <indexterm>
	<primary>routage multicast</primary>
      </indexterm>
      <indexterm>
	<primary>options du noyau</primary>
	<secondary>MROUTING</secondary>
      </indexterm>
      <para>&os; supporte nativement les applications et le routage
	multicast (diffusion pour plusieurs destinataires).  Les
	applications multicast ne n&eacute;cessitent pas de
	configuration sp&eacute;cifique de &os;,
	g&eacute;n&eacute;ralement, elles fonctionneront directement.
	Le routage multicast demande &agrave; ce que le support soit
	compil&eacute; dans le noyau:</para>

      <programlisting>options MROUTING</programlisting>

      <para>De plus, le &ldquo;daemon&rdquo; de routage multicast,
	&man.mrouted.8; doit &ecirc;tre configur&eacute; par
	l'interm&eacute;diaire du fichier
	<filename>/etc/mrouted.conf</filename> pour mettre en place
	des tunnels et le protocole <acronym>DVMRP</acronym>.  Plus de d&eacute;tails sur
	la configuration du routage multicast peuvent &ecirc;tre
	trouv&eacute;s dans la page de manuel de
	&man.mrouted.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Anderson</surname>
	  <contrib>Ecrit par </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>R&eacute;seau sans fil</title>

    <indexterm><primary>r&eacute;seau sans fil</primary></indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>r&eacute;seau sans fil</see>
    </indexterm>

    <sect2>
      <title>Introduction</title>

      <para>Il peut &ecirc;tre tr&egrave;s utile de pouvoir utiliser
	un micro-ordinateur sans le d&eacute;sagr&eacute;ment
	d'&ecirc;tre constamment reli&eacute; &agrave; un c&acirc;ble
	r&eacute;seau.  &os; peut &ecirc;tre utilis&eacute; comme
	client sans fil, et m&ecirc;me comme &ldquo;point
	d'acc&egrave;s&rdquo; sans fil.</para>
    </sect2>

    <sect2>
      <title>Modes de fonctionnement des syst&egrave;mes sans
	fils</title>

      <para>Il existe deux mani&egrave;res diff&eacute;rentes de
	configurer les p&eacute;riph&eacute;riques sans fil 802.11:
	les modes BSS et IBSS.</para>

      <sect3>
	<title>Mode BSS</title>

	<para>Le mode BSS est le mode g&eacute;n&eacute;ralement
	  utilis&eacute;.  Le mode BSS est &eacute;galement
	  appel&eacute; mode infrastructure.  Dans ce mode, plusieurs
	  points d'acc&egrave;s sans fils sont connect&eacute;s
	  &agrave; un r&eacute;seau c&acirc;bl&eacute;.  Chaque
	  r&eacute;seau sans fil poss&egrave;de son propre nom.  Ce
	  nom est ce que l'on appelle le &ldquo;SSID&rdquo; du
	  r&eacute;seau.</para>

	<para>Les clients sans fils se connectent &agrave; ces points
	  d'acc&egrave;s sans fils.  La norme IEEE 802.11
	  d&eacute;finie le protocole que les r&eacute;seaux sans fils
	  utilisent pour les connexions.  Un client sans fil peut
	  &ecirc;tre attach&eacute; &agrave; un r&eacute;seau
	  particulier quand un SSID est fix&eacute;.  Un client peut
	  s'attacher &agrave; n'importe quel r&eacute;seau en ne
	  d&eacute;finissant pas explicitement de SSID.</para>
      </sect3>

      <sect3>
	<title>Mode IBSS</title>

	<para>Le mode IBSS, &eacute;galement appel&eacute; mode
	  &ldquo;ad-hoc&rdquo;, est con&ccedil;u pour les connexions
	  point &agrave; point.  Il existe en fait deux types de mode
	  ad-hoc.  Le premier est le mode IBSS, &eacute;galement
	  appel&eacute; mode ad-hoc ou IEEE ad-hoc.  Ce mode est
	  d&eacute;fini par les normes IEEE 802.11.  Le
	  deuxi&egrave;me mode est appel&eacute; ad-hoc d&eacute;mo ou
	  encore mode ad-hoc Lucent (et parfois, ce qui pr&ecirc;te
	  &agrave; confusion, mode ad-hoc).  C'est l'ancien mode
	  ad-hoc pr&eacute;-standard 802.11 et ne devrait &ecirc;tre
	  utilis&eacute; qu'avec d'anciennes installations.  Nous ne
	  parlerons pas des modes ad-hoc dans ce qui suit.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Mode infrastructure</title>

      <sect3>
	<title>Points d'acc&egrave;s</title>

	<para>Un point d'acc&egrave;s est un
	  p&eacute;riph&eacute;rique sans fil qui permet &agrave; un
	  ou plusieurs clients sans fils d'utiliser ce
	  p&eacute;riph&eacute;rique comme un hub.  Quand ils
	  utilisent un point d'acc&egrave;s, tous les clients
	  communiquent par l'interm&eacute;diaire de ce point
	  d'acc&egrave;s.  Plusieurs points d'acc&egrave;s sont
	  souvent utilis&eacute;s pour couvrir
	  l'int&eacute;gralit&eacute; d'une zone g&eacute;ographique
	  comme une maison, une entreprise, ou un parc avec un
	  r&eacute;seau sans fil.</para>

	<para>Les points d'acc&egrave;s ont g&eacute;n&eacute;ralement
	  plusieurs connexions r&eacute;seaux: la carte r&eacute;seaux
	  sans fil, et une ou plusieurs cartes r&eacute;seaux Ethernet
	  pour les connexions avec le reste du r&eacute;seau.</para>

	<para>Les points d'acc&egrave;s peuvent &ecirc;tre
	  achet&eacute;s tout fait, ou vous pouvez construire le votre
	  avec &os; et une carte r&eacute;seau sans fil
	  support&eacute;e.  De nombreux constructeurs proposent des
	  points d'acc&egrave;s et des cartes r&eacute;seaux sans fils
	  avec diverses fonctionnalit&eacute;s.</para>
      </sect3>

      <sect3>
	<title>Construire un point d'acc&egrave;s avec &os;</title>
	<indexterm>
	  <primary>r&eacute;seau sans fil</primary>
	  <secondary>point d'acc&egrave;s</secondary>
	</indexterm>

	<sect4>
	  <title>Pr&eacute;-requis</title>

	  <para>En vue de mettre en place un point d'acc&egrave;s sans
	    fil sous &os;, vous avez besoin d'une carte r&eacute;seau
	    sans fil compatible.  Actuellement seule les cartes
	    bas&eacute;es sur le circuit Prism sont support&eacute;es.
	    Vous aurez &eacute;galement besoin d'une carte
	    r&eacute;seau c&acirc;bl&eacute;e support&eacute;e par
	    &os; (cela ne devrait pas &ecirc;tre difficile &agrave;
	    trouver, &os; supporte de nombreuses cartes).  Dans le
	    cadre de cette section, nous supposerons que le trafic
	    passera par un pont entre la carte sans fil et le
	    r&eacute;seau reli&eacute; &agrave; la carte r&eacute;seau
	    classique.</para>

	  <para>Le mode point d'acc&egrave;s impl&eacute;ment&eacute;
	    par &os; fonctionne mieux avec certaines versions de
	    firmware.  Les cartes utilisant un circuit Prism 2
	    devraient utiliser un firmware 1.3.4 ou plus
	    r&eacute;cent.  Les cartes Prism 2.5 et Prism 3 devraient
	    utiliser la version 1.4.9.  Des versions de firmware plus
	    anciennes pourront ne pas fonctionner correctement.
	    Actuellement, la seule mani&egrave;re de mettre &agrave;
	    jour vos cartes est d'utiliser les outils de mise &agrave;
	    jour du firmware pour &windows; disponibles aupr&egrave;s
	    du constructeur de votre carte.</para>
	</sect4>

	<sect4>
	  <title>Configuration</title>

	  <para>Assurez-vous tout d'abord que votre syst&egrave;me
	    voit la carte r&eacute;seau sans fil:</para>

	  <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
	status: no carrier
	ssid ""
	stationname "FreeBSD Wireless node"
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</screen>

	  <para>Ne vous pr&eacute;occupez pas des d&eacute;tails,
	    verifiez juste que s'affiche quelque chose qui vous
	    indique qu'une carte r&eacute;seau sans fil est
	    install&eacute;e.  Si vous avez des probl&egrave;mes
	    &agrave; voir l'interface r&eacute;seau sans fil
	    correspondante, et que vous utilisez une carte de type PC
	    Card, vous devriez consultez les pages de manuel
	    &man.pccardc.8; et &man.pccardd.8; pour plus
	    d'information.</para>

	  <para>Ensuite, vous devrez charger un module afin de mettre
	    en place la partie de &os; faisant office de pont pour le
	    point d'acc&egrave;s.  Pour charger le module
	    &man.bridge.4;, ex&eacute;cutez la commande
	    suivante:</para>

	  <screen>&prompt.root; <userinput>kldload bridge</userinput></screen>

	  <para>Vous ne devriez pas voir appara&icirc;tre de message
	    d'erreur lors du chargement du module.  Si ce n'est pas le
	    cas, vous devrez peut-&ecirc;tre compiler le support
	    &man.bridge.4; dans votre noyau.  La section sur le <link
	    linkend="network-bridging">Bridging</link> de ce manuel
	    devrait pouvoir vous aider dans cette t&acirc;che.</para>

	  <para>Maintenant que cette partie est assur&eacute;e, nous
	    devons dire &agrave; &os; entre quelles interface le pont
	    doit &ecirc;tre install&eacute;.  Nous effectuons cette
	    configuration en utilisant &man.sysctl.8;:</para>

	  <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge.enable=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge.config="wi0 xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	  <para>Sous les versions ant&eacute;rieures &agrave; la 5.2,
	    vous devez utiliser &agrave; la place les options
	    suivantes:</para>

	  <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge_cfg="wi0,xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	  <para>Il est maintenant possible de configurer la carte.  La
	    commande suivante positionnera la carte en mode point
	    d'acc&egrave;s:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 ssid <replaceable>my_net</replaceable> channel 11 media DS/11Mbps mediaopt hostap up stationname "<replaceable>FreeBSD AP</replaceable>"</userinput></screen>

	  <para>La ligne &man.ifconfig.8; active l'interface
	    <devicename>wi0</devicename>, fixe son param&egrave;tre
	    SSID &agrave; la valeur <replaceable>my_net</replaceable>,
	    et fixe le nom de station &agrave; <replaceable>FreeBSD
	    AP</replaceable>.  L'option <option>media
	    DS/11Mbps</option> positionne la carte dans le mode 11Mbps
	    et est n&eacute;cessaire pour que le param&egrave;tre
	    <option>mediaopt</option> soit pris en compte.  L'option
	    <option>mediaopt hostap</option> place l'interface dans le
	    mode point d'acc&egrave;s.  L'option <option>channel
	    11</option> fixe le canal 802.11b &agrave; employer.  La
	    page de manuel &man.wicontrol.8; donne les options de
	    canaux valides en fonction de votre zone
	    g&eacute;ographique.</para>

	  <para>Vous devez maintenant disposer d'un point
	    d'acc&egrave;s op&eacute;rationnel et en fonctionnement.
	    Vous &ecirc;tes encourag&eacute;s &agrave; lire les pages
	    de manuel &man.wicontrol.8;, &man.ifconfig.8;, et
	    &man.wi.4; pour plus d'amples informations.</para>

	  <para>Il est &eacute;galement conseill&eacute; de lire la
	    section qui suit sur le chiffrage.</para>
	</sect4>

	<sect4>
	  <title>Information d'&eacute;tat</title>

	  <para>Une fois que le point d'acc&egrave;s est
	    configur&eacute; et op&eacute;rationnel, les
	    op&eacute;rateurs voudront voir quels clients sont
	    associ&eacute;s avec le point d'acc&egrave;s.  A n'importe
	    quel instant, l'op&eacute;rateur pourra taper:</para>

	  <screen>&prompt.root; <userinput>wicontrol -l</userinput>
1 station:
00:09:b7:7b:9d:16  asid=04c0, flags=3&lt;ASSOC,AUTH&gt;, caps=1&lt;ESS&gt;, rates=f&lt;1M,2M,5.5M,11M&gt;, sig=38/15</screen>

	  <para>Ceci nous montre qu'une station est associ&eacute;e,
	    ainsi que son param&eacute;trage.  Les informations
	    indiqu&eacute;es concernant le signal devraient &ecirc;tre
	    utilis&eacute;es uniquement comme une indication relative
	    sur sa puissance.  Sa conversion en dBm ou tout autre
	    unit&eacute; varie en fonction des diff&eacute;rentes
	    versions de firmware.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Clients</title>

	<para>Un client sans fil est un syst&egrave;me qui se connecte
	  &agrave; un point d'acc&egrave;s ou un autre client
	  directement.</para>

	<para>Typiquement, les clients sans fils disposent d'une seule
	  interface r&eacute;seau, la carte r&eacute;seau sans
	  fil.</para>

	<para>Il existe quelques mani&egrave;res diff&eacute;rentes de
	  configurer un client sans fil.  Elles sont bas&eacute;es sur
	  les diff&eacute;rents modes sans fils,
	  g&eacute;n&eacute;ralement les modes BSS (mode
	  infrastructure, qui n&eacute;cessite un point
	  d'acc&egrave;s), et IBSS (mode ad-hoc, ou mode point
	  &agrave; point).  Dans notre exemple, nous utiliserons le
	  plus populaire des deux, le mode BSS, pour discuter avec un
	  point d'acc&egrave;s.</para>

	<sect4>
	  <title>Pr&eacute;-requis</title>

	  <para>Il n'y a qu'un seul pr&eacute;-requis pour configurer
	    &os; comme client sans fil.  Vous aurez besoin d'une carte
	    sans fil support&eacute;e par &os;.</para>
	</sect4>

	<sect4>
	  <title>Configurer un client sans fil &os;</title>

	  <para>Avant de commencer, vous aurez besoin de
	    conna&icirc;tre certaines choses concernant le
	    r&eacute;seau sans fil auquel vous d&eacute;sirez vous
	    connecter.  Dans cet exemple, nous rejoignons un
	    r&eacute;seau ayant pour nom
	    <replaceable>my_net</replaceable>, et avec le chiffrage
	    des liaisons d&eacute;sactiv&eacute;.</para>

	  <note>
	    <para>Dans cet exemple, nous n'utilisons pas le chiffrage
	      des liaisons, ce qui est une situation dangereuse.  Dans
	      la section suivante, nous verrons comment activer le
	      chiffrage, pourquoi il est important de le faire, et
	      pourquoi certaines technologies de chiffrage ne vous
	      prot&eacute;gerons pas compl&egrave;tement.</para>
	  </note>

	  <para>Assurez-vous que votre carte est reconnue par
	    &os;:</para>

	  <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
	inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
	ether 00:09:2d:2d:c9:50
	media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
	status: no carrier
	ssid ""
	stationname "FreeBSD Wireless node"
	channel 10 authmode OPEN powersavemode OFF powersavesleep 100
	wepmode OFF weptxkey 1</screen>

	  <para>Maintenant, nous pouvons configurer la carte suivant
	    les param&egrave;tres de notre r&eacute;seau:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet <replaceable>192.168.0.20</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>my_net</replaceable></userinput></screen>

	  <para>Remplacez <hostid role="ipaddr">192.168.0.20</hostid>
	    et <hostid role="netmask">255.255.255.0</hostid> avec une
	    adresse IP ainsi qu'un masque de sous-r&eacute;seau
	    valides de votre r&eacute;seau c&acirc;bl&eacute;.
	    Rappelez-vous, notre point d'acc&egrave;s joue le
	    r&ocirc;le de pont entre le r&eacute;seau sans fil et le
	    r&eacute;seau c&acirc;bl&eacute;, il appara&icirc;tra aux
	    autres cartes sur votre r&eacute;seau que vous &ecirc;tes
	    sur le m&ecirc;me r&eacute;seau c&acirc;bl&eacute;.</para>

	  <para>Une fois cela effectu&eacute;, vous devriez &ecirc;tre
	    en mesure d'utiliser &man.ping.8; pour atteindre les
	    machines sur le r&eacute;seau c&acirc;bl&eacute; de la
	    m&ecirc;me fa&ccedil;on que si vous &eacute;tiez
	    connect&eacute; en utilisant un c&acirc;ble r&eacute;seau
	    standard.</para>

	  <para>Si vous rencontrez des probl&egrave;mes avec votre
	    connexion sans fil, v&eacute;rifiez que vous &ecirc;tes
	    associ&eacute;&mdash;&ldquo;associated&rdquo;
	    (connect&eacute;) avec le point d'acc&egrave;s:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0</userinput></screen>

	  <para>devrait retourner un certain nombre d'information; et
	    vous devriez voir s'afficher:</para>

	  <screen>status: associated</screen>

	  <para>Si <literal>associated</literal> n'est pas
	    affich&eacute;, alors il se peut que vous soyez hors de
	    port&eacute;e du point d'acc&egrave;s, que vous ayez le
	    chiffrage activ&eacute;, ou peut-&ecirc;tre que vous ayez
	    un probl&egrave;me de configuration.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Chiffrement</title>
	<indexterm>
	  <primary>r&eacute;seau sans fil</primary>
	  <secondary>chiffrement</secondary>
	</indexterm>

	<para>L'utilisation du chiffrement sur un r&eacute;seau sans
	  fil est important parce que vous n'avez plus la
	  possibilit&eacute; de conserver le r&eacute;seau dans une
	  zone prot&eacute;g&eacute;e.  Vos donn&eacute;es sans fil
	  seront diffus&eacute;es dans tout le voisinage, et toute
	  personne d&eacute;sirant y acc&eacute;der pourra le faire.
	  C'est ici que le chiffrement entre en jeu.  En chiffrant les
	  donn&eacute;es qui sont envoy&eacute;es par les ondes, vous
	  rendez plus difficile l'interception de celles-ci par
	  quiconque d'int&eacute;ress&eacute;.</para>

	<para>Les deux m&eacute;thodes les plus courantes de chiffrage
	  des donn&eacute;es entre un client et un point
	  d'acc&egrave;s sont le protocol WEP et &man.ipsec.4;.</para>

	<sect4>
	  <title>WEP</title>
	  <indexterm><primary>WEP</primary></indexterm>

	  <para>WEP est l'abbr&eacute;vation de &ldquo;Wired
	    Equivalency Protocol&ldquo;.  Le protocole de chiffrage
	    WEP est une tentative de rendre les r&eacute;seaux sans fils
	    aussi s&ucirc;rs et s&eacute;curis&eacute;s qu'un
	    r&eacute;seau filaire.  Malheureusement, il a
	    &eacute;t&eacute; craqu&eacute;, et est relativement
	    simple &agrave; d&eacute;jouer.  Cela signifie que l'on ne
	    doit pas lui faire confiance quand il est
	    n&eacute;cessaire de chiffrer des donn&eacute;es
	    sensibles.</para>

	  <para>Cela reste mieux que rien du tout, utilisez ce qui
	    suit pour activer WEP sur votre nouveau point
	    d'acc&egrave;s &os;:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet up ssid <replaceable>my_net</replaceable> wepmode on wepkey <replaceable>0x1234567890</replaceable> media DS/11Mbps mediaopt hostap</userinput></screen>

	  <para>Et vous pouvez activer WEP sur un client avec la
	    commande:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet <replaceable>192.168.0.20</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>my_net</replaceable> wepmode on wepkey <replaceable>0x1234567890</replaceable></userinput></screen>

	  <para>Notez que vous devriez remplacer
	    <replaceable>0x1234567890</replaceable> par une cl&eacute;
	    plus personnelle.</para>
	</sect4>

	<sect4>
	  <title>IPsec</title>

	  <para>&man.ipsec.4; est un outil bien plus puissant et
	    robuste pour chiffrer des donn&eacute;es sur un
	    r&eacute;seau.  C'est la m&eacute;thode &agrave;
	    pr&eacute;f&eacute;rer pour chiffrer les donn&eacute;es sur un
	    r&eacute;seau sans fil.  Vous pouvez obtenir plus de
	    d&eacute;tails concernant &man.ipsec.4; et comment
	    l'impl&eacute;menter dans la section <link
	    linkend="ipsec">IPsec</link> de ce manuel.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Outils</title>

	<para>Il existe un petit nombre d'outils disponibles pour le
	  d&eacute;bogage et la configuration d'un r&eacute;seau sans
	  fil, et nous tenterons ici d'en d&eacute;crire certains
	  ainsi que leurs fonctionnalit&eacute;s.</para>

	<sect4>
	  <title>La suite
	    <application>bsd-airtools</application></title>

	  <para>La suite <application>bsd-airtools</application> est
	    une trousse &agrave; outils compl&egrave;te qui comprend
	    des outils d'audit sans fil pour le craquage du
	    syst&egrave;me WEP, la d&eacute;tection de points
	    d'acc&egrave;s, etc.</para>

	  <para>Les utilitaires
	    <application>bsd-airtools</application> peuvent &ecirc;tre
	    install&eacute;s &agrave; partir du logiciel port&eacute;
	    <filename role="package">net-mgmt/bsd-airtools</filename>.  Des
	    instructions sur l'installation des logiciels
	    port&eacute;s peuvent &ecirc;tre trouv&eacute;es dans le
	    <xref linkend="ports"> de ce manuel.</para>

	  <para>Le programme <command>dstumbler</command> est l'outil
	    qui permet la recherche de points d'acc&egrave;s et la
	    mesure du rapport signal sur bruit.  Si vous avez des
	    difficult&eacute;s &agrave; mettre en place et &agrave;
	    faire fonctionner votre point d'acc&egrave;s,
	    <command>dstumbler</command> pourra vous aider dans ce
	    sens.</para>

	  <para>Pour tester la s&eacute;curit&eacute; de votre
	    r&eacute;seau sans fil, vous pouvez choisir d'employer les
	    outils &ldquo;dweputils&rdquo;
	    (<command>dwepcrack</command>, <command>dwepdump</command>
	    et <command>dwepkeygen</command>) pour vous aider &agrave;
	    d&eacute;terminer si WEP r&eacute;pond &agrave; vos
	    besoins en mati&egrave;re de s&eacute;curit&eacute; au
	    niveau de votre r&eacute;seau sans fil.</para>
	</sect4>

	<sect4>
	  <title>Les utilitaires <command>wicontrol</command>,
	    <command>ancontrol</command> et
	    <command>raycontrol</command></title>

	  <para>Il existe des outils que vous pouvez utiliser pour
	    contr&ocirc;ler le comportement de votre carte
	    r&eacute;seau sans fil sur le r&eacute;seau sans fil.
	    Dans les exemples pr&eacute;c&eacute;dents, nous avons
	    choisi d'employer &man.wicontrol.8; puisque notre carte
	    sans fil utilise l'interface <devicename>wi0</devicename>.
	    Si vous avez une carte sans fil Cisco, elle
	    appara&icirc;trait comme <devicename>an0</devicename>, et
	    vous utiliseriez alors le programme
	    &man.ancontrol.8;.</para>
	</sect4>

	<sect4>
	  <title>La commande <command>ifconfig</command></title>
	  <indexterm><primary>ifconfig</primary></indexterm>

	  <para>La commande &man.ifconfig.8; propose plusieurs options
	    identiques &agrave; celles de &man.wicontrol.8;, cependant
	    il manque quelques options.  Consultez la page de manuel
	    d'&man.ifconfig.8; pour les diff&eacute;rents
	    param&egrave;tres et options en ligne de commande.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Cartes support&eacute;es</title>

	<sect4>
	  <title>Points d'acc&egrave;s</title>

	  <para>Les seules cartes actuellement support&eacute;es pour
	    le mode BSS (points d'acc&egrave;s) sont celles
	    bas&eacute;es sur les circuits Prism 2, 2.5, ou 3.  Pour
	    une liste compl&egrave;te, consultez la page de manuel de
	    &man.wi.4;.</para>
	</sect4>

	<sect4>
	  <title>Clients 802.11b</title>

	  <para>Presque toutes les cartes r&eacute;seaux sans fil
	    802.11b sont support&eacute;es sous &os;.  La plupart des
	    cartes bas&eacute;es sur les circuits Prism, Spectrum24,
	    Hermes, Aironet, et Raylink fonctionneront dans le mode
	    IBSS (ad-hoc, point &agrave; point, et BSS).</para>
	</sect4>

	<sect4>
	  <title>Clients 802.11a &amp; 802.11g</title>

	  <para>Le pilote de p&eacute;riph&eacute;rique &man.ath.4;
	    supporte les normes 802.11a et 802.11g.  Si votre carte
	    est bas&eacute;e sur un circuit Atheros, vous devriez
	    &ecirc;tre en mesure d'utiliser ce pilote.</para>

	  <para>Malheureusement il y a toujours de nombreux fabricants
	    qui ne fournissent pas &agrave; la communaut&eacute; des
	    logiciels libres les informations concernant les pilotes
	    pour leurs cartes consid&eacute;rant de telles
	    informations comme des secrets industriels.  Par
	    cons&eacute;quent, il ne reste aux d&eacute;veloppeurs de
	    &os; et d'autres syst&egrave;mes d'exploitation libres que
	    deux choix: d&eacute;velopper les pilotes en passant par
	    un long et p&eacute;nible processus de <quote>reverse
	    engineering</quote> ou utiliser les pilotes binaires
	    existants disponibles pour la plateforme
	    &microsoft.windows;.  La plupart des d&eacute;veloppeurs,
	    y compris ceux impliqu&eacute;s dans &os;, ont choisi
	    cette derni&egrave;re approche.</para>

	  <para>Gr&acirc;ce aux contributions de Bill Paul (wpaul),
	    depuis &os;&nbsp;5.3-RELEASE, il existe un support
	    <quote>natif</quote> pour la sp&eacute;cification
	    d'interface des pilotes de p&eacute;riph&eacute;rique
	    r&eacute;seau (Network Driver Interface
	    Specification&mdash;NDIS).  Le NDISulator &os; (connu
	    &eacute;galement sous le nom de Project Evil) prend un
	    pilote binaire r&eacute;seau &windows; et lui fait penser
	    qu'il est en train de tourner sous &windows;.  Cette
	    fonctionnalit&eacute; est relativement nouvelle, mais
	    semble fonctionner correctement dans la plupart des
	    tests.</para>

	  <indexterm><primary>NDIS</primary></indexterm>
	  <indexterm><primary>NDISulator</primary></indexterm>
	  <indexterm><primary>pilotes de p&eacute;riph&eacute;riques
	    &windows;</primary></indexterm>
	  <indexterm><primary>Microsoft Windows</primary></indexterm>
	  <indexterm><primary>Microsoft Windows</primary>
	    <secondary>pilotes de
	      p&eacute;riph&eacute;riques</secondary></indexterm>
	  <indexterm><primary>KLD (kernel loadable
	    object)</primary></indexterm>
<!-- We should probably omit the expanded name, and add a <see> entry
for it.  Whatever is done must also be done to the same indexterm in
linuxemu/chapter.sgml -->

	  <para>Pour utiliser le NDISulator, vous avez besoin de trois
	    choses:</para>

	  <orderedlist>
	    <listitem>
	      <para>les sources du noyau;</para>
	    </listitem>
	    <listitem>
	      <para>le pilote binaire &windowsxp;
		(extension <filename>.SYS</filename>);</para>
	    </listitem>
	    <listitem>
	      <para>le fichier de configuration du pilote &windowsxp;
		(extension <filename>.INF</filename>).</para>
	    </listitem>
	  </orderedlist>
       
	  <para>Vous aurez besoin de compiler le module d'interface du
	    mini-pilote &man.ndis.4;.  En tant que
	    <username>root</username>:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/sys/modules/ndis</userinput>
&prompt.root; <userinput>make &amp;&amp; make install</userinput></screen>

	  <para>Recherchez les fichiers sp&eacute;cifiques &agrave;
	    votre carte.  G&eacute;n&eacute;ralement, ils peuvent
	    &ecirc;tre trouv&eacute;s sur les CDs livr&eacute;s avec
	    la carte ou sur le site du fabricant.  Dans les exemples
	    qui suivent nous utiliseront les fichiers
	    <filename>W32DRIVER.SYS</filename> et
	    <filename>W32DRIVER.INF</filename>.</para>

	  <para>L'&eacute;tape suivante est de compiler le pilote
	    binaire dans un module chargeable du noyau.  Pour
	    effectuer cela, en tant que <username>root</username>,
	    rendez vous dans le r&eacute;pertoire du module
	    <filename>if_ndis</filename> et copiez-y les fichiers du
	    pilote &windows;:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/sys/modules/if_ndis</userinput>
&prompt.root; <userinput>cp <replaceable>/path/to/driver/W32DRIVER.SYS</replaceable> ./</userinput>
&prompt.root; <userinput>cp <replaceable>/path/to/driver/W32DRIVER.INF</replaceable> ./</userinput></screen>

	  <para>Nous utiliserons maintenant l'utilitaire
	    <command>ndiscvt</command> pour g&eacute;n&eacute;rer le
	    fichier d'ent&ecirc;te
	    <filename>ndis_driver_data.h</filename> du pilote pour la
	    compilation du module:</para>

	  <screen>&prompt.root; <userinput>ndiscvt -i <replaceable>W32DRIVER.INF</replaceable> -s <replaceable>W32DRIVER.SYS</replaceable> -o ndis_driver_data.h</userinput></screen>

	  <para>Les options <option>-i</option> et <option>-s</option>
	    pr&eacute;cisent respectivement le fichier de
	    configuration et le fichier binaire.  Nous utilisons
	    l'option <option>-o ndis_driver_data.h</option> car le
	    <filename>Makefile</filename> recherchera ce fichier lors
	    de la compilation du module.</para>

	  <note>
	    <para>Certains pilotes &windows; n&eacute;cessitent des
	      fichiers suppl&eacute;mentaires pour fonctionner.  Vous
	      pouvez les ajouter avec <command>ndiscvt</command> en
	      utilisant l'option <option>-f</option>.  Consultez la page
	      de manuel &man.ndiscvt.8; pour plus d'information.</para>
	  </note>

	  <para>Nous pouvons enfin compiler et installer le module du
	    pilote:</para>

	  <screen>&prompt.root; <userinput>make && make install</userinput></screen>

	  <para>Pour utiliser le pilote, vous devez charger les
	    modules appropri&eacute;s:</para>

	  <screen>&prompt.root; <userinput>kldload ndis</userinput>
&prompt.root; <userinput>kldload if_ndis</userinput></screen>

	  <para>La premi&egrave;re commande charge le pilote
	    d'interface NDIS, la seconde charge l'interface
	    r&eacute;seau.  Contr&ocirc;lez la sortie de &man.dmesg.8;
	    &agrave; la recherche d'une quelconque erreur au
	    chargement.  Si tout s'est bien pass&eacute;, vous devriez
	    obtenir une sortie ressemblant &agrave; ce qui
	    suit:</para>

	  <screen>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
      ndis0: NDIS API version: 5.0
      ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
      ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
      ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</screen>

	  <para>A partir de l&agrave;, vous pouvez traiter le
	    p&eacute;riph&eacute;rique <devicename>ndis0</devicename>
	    comme n'importe quel p&eacute;riph&eacute;rique sans fil
	    (e.g. <devicename>wi0</devicename>) et consulter les
	    premi&egrave;res sections de ce chapitre.</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bluetooth">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Pav</firstname>
	  <surname>Lucistnik</surname>
	  <contrib>Ecrit par </contrib>
	  <affiliation>
	    <address><email>pav@FreeBSD.org</email></address>
	  </affiliation>
	</author>
      </authorgroup>
    </sect1info>
    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>
    <sect2>
      <title>Introduction</title>

      <para>&bluetooth; est une technologie sans fil pour cr&eacute;er
	des r&eacute;seaux personnels sans fils fonctionnant dans la
	bande 2.4 GHz ne n&eacute;cessitant pas d'autorisation, avec
	une port&eacute;e de 10 m&egrave;tres.  Les r&eacute;seaux
	&eacute;tant g&eacute;n&eacute;ralement compos&eacute;s de
	p&eacute;riph&eacute;riques nomades comme les
	t&eacute;l&eacute;phones portables, les assistants personnels
	et les ordinateurs portables.  Contrairement &agrave; l'autre
	technologie sans fil, Wi-Fi, &bluetooth; offre un niveau plus
	&eacute;lev&eacute; de profils de service, par exemple des
	serveurs de fichiers semblables &agrave; FTP, &ldquo;file
	pushing&rdquo;, transport de la voix, &eacute;mulation de
	lignes s&eacute;ries, et bien plus.</para>

      <para>La pile &bluetooth; sous &os; utilise le syst&egrave;me
	Netgraph (voir &man.netgraph.4;).  Une large gamme
	d'adaptateurs USB &bluetooth; sont support&eacute;s par le
	pilote &man.ng.ubt.4;.  Les p&eacute;riph&eacute;riques
	&bluetooth; bas&eacute;s sur le circuit Broadcom BCM2033 sont
	support&eacute;s par les pilotes &man.ubtbcmfw.4; et
	&man.ng.ubt.4;.  La carte 3Com &bluetooth; PC Card 3CRWB60-A
	demande le pilote &man.ng.bt3c.4;.  Les
	p&eacute;riph&eacute;riques &bluetooth; de type s&eacute;rie
	et UART sont support&eacute;s via les pilotes &man.sio.4;,
	&man.ng.h4.4; et &man.hcseriald.8;.  Cette section
	d&eacute;crit l'utilisation d'un adaptateur USB &bluetooth;.
	Le support &bluetooth; est disponible sur les syst&egrave;mes
	5.0 et suivants.</para>
    </sect2>

    <sect2>
      <title>Branchement du p&eacute;riph&eacute;rique</title>

      <para>Par d&eacute;faut les pilotes de
	p&eacute;riph&eacute;riques &bluetooth; sont disponibles sous
	la forme de modules du noyau.  Avant de brancher le
	p&eacute;riph&eacute;rique, vous devrez charger le pilote dans
	le noyau:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Si le p&eacute;riph&eacute;rique &bluetooth; est
	pr&eacute;sent au d&eacute;marrage du syst&egrave;me, chargez
	le module &agrave; partir de
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Branchez votre cl&eacute; USB.  Une sortie semblable
	&agrave; celle-ci devrait s'afficher sur la console (ou dans
	les journaux du syst&egrave;me):</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <note>
	<para>La pile Bluetooth doit &ecirc;tre lanc&eacute;e
	  manuellement sous &os;&nbsp;6.0, et sous les versions 5.0
	  ant&eacute;rieures &agrave; la 5.5.  Ce lancement est
	  automatique &agrave; partir de &man.devd.8; sous
	  &os;&nbsp;5.5, 6.1 et versions suivantes.</para>

      <para>Copiez
	<filename>/usr/share/examples/netgraph/bluetooth/rc.bluetooth</filename>
	&agrave; un emplacement adapt&eacute;, comme
	<filename>/etc/rc.bluetooth</filename>.  Cette
	proc&eacute;dure est utilis&eacute;e pour d&eacute;marrer et
	arr&ecirc;ter la pile &bluetooth;.  C'est une bonne
	id&eacute;e d'arr&ecirc;ter la pile avant de d&eacute;brancher
	le p&eacute;riph&eacute;rique, mais ce n'est pas
	(g&eacute;n&eacute;ralement) fatal.  Quand la pile
	d&eacute;marre, vous devriez avoir des messages similaires aux
	suivants:</para>

      <screen>&prompt.root; <userinput>/etc/rc.bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>
      </note>
    </sect2>

    <indexterm><primary>HCI</primary></indexterm>
    <sect2>
      <title>Interface de contr&ocirc;le de l'h&ocirc;te (HCI)</title>

      <para>L'interface de contr&ocirc;le de l'h&ocirc;te (HCI)
	fournit une interface de commande pour le contr&ocirc;leur de
	la bande de base et le gestionnaire de liaisons, et
	l'acc&egrave;s &agrave; l'&eacute;tat du mat&eacute;riel et
	aux registres de contr&ocirc;le.  Cette interface offre une
	m&eacute;thode uniforme d'acc&egrave;s aux fonctions de la
	bande de base &bluetooth;.  La couche HCI de l'h&ocirc;te
	&eacute;change des donn&eacute;es et des commandes avec le
	firmware HCI du mat&eacute;riel &bluetooth;.  Le pilote de la
	couche de transport du contr&ocirc;leur d'h&ocirc;te (i.e.  le
	bus physique) fournit aux deux couches HCI la
	possibilit&eacute; d'&eacute;changer des informations entre
	elles.</para>

      <para>Un seul noeud Netgraph de type <emphasis>hci</emphasis>
	est cr&eacute;&eacute; pour un p&eacute;riph&eacute;rique
	&bluetooth;.  Le noeud HCI est normalement connect&eacute; au
	noeud du pilote &bluetooth; (flux descendant) et au noeud
	L2CAP (flux montant).  Toutes les op&eacute;rations HCI
	doivent &ecirc;tre effectu&eacute;es sur le noeud HCI et non
	pas sur le noeud du pilote de p&eacute;riph&eacute;rique.  Le
	nom par d&eacute;faut pour le noeud HCI est
	&ldquo;devicehci&rdquo;.  Pour plus de d&eacute;tails
	consultez la page de manuel &man.ng.hci.4;.</para>

      <para>Une des t&acirc;ches les plus courantes est la recherche
	de p&eacute;riph&eacute;riques &bluetooth; dans le voisinage
	hertzien.  Cette op&eacute;ration est appel&eacute;e
	<emphasis>inquiry</emphasis> (enqu&ecirc;te, recherche).
	Cette recherche et les autres op&eacute;rations relatives
	&agrave; HCI sont effectu&eacute;es par l'utilitaire
	&man.hccontrol.8;.  L'exemple ci-dessous montre comment
	d&eacute;terminer quels p&eacute;riph&eacute;riques
	&bluetooth; sont dans le voisinage.  Vous devriez obtenir une
	listes de p&eacute;riph&eacute;riques au bout de quelques
	secondes.  Notez qu'un p&eacute;riph&eacute;rique distant ne
	r&eacute;pondra &agrave; la recherche que s'il est
	plac&eacute; dans le mode <emphasis>discoverable</emphasis>.

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> est l'adresse unique d'un
	p&eacute;riph&eacute;rique &bluetooth;, similaire &agrave;
	l'adresse MAC d'une carte r&eacute;seau.  Cette adresse est
	n&eacute;cessaire pour communiquer avec un
	p&eacute;riph&eacute;rique.  Il est possible d'assigner un nom
	humainement compr&eacute;hensible &agrave; l'adresse BD_ADDR.
	Le fichier <filename>/etc/bluetooth/hosts</filename> contient
	des informations concernant les h&ocirc;tes &bluetooth;
	connus.  L'exemple suivant montre comment obtenir le nom qui a
	&eacute;t&eacute; assign&eacute; au p&eacute;riph&eacute;rique
	distant:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Si vous effectuez une recherche sur un
	p&eacute;riph&eacute;rique &bluetooth; distant, vous devriez
	trouver votre ordinateur en tant que &ldquo;votre.machine.nom
	(ubt0)&rdquo;.  Le nom affect&eacute; au
	p&eacute;riph&eacute;rique local peut &ecirc;tre
	modifi&eacute; &agrave; tout moment.</para>

      <para>Le syst&egrave;me &bluetooth; fournit une connexion point
	&agrave; point (seules deux mat&eacute;riels &bluetooth; sont
	concern&eacute;s), ou une connexion point &agrave;
	multipoints.  Dans le cas d'une connexion point &agrave;
	multipoints, la connexion est partag&eacute;s entre plusieurs
	p&eacute;riph&eacute;riques &bluetooth;.  L'exemple suivant
	montre comment obtenir la liste des connexions en bande de
	base actives pour le p&eacute;riph&eacute;rique local:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Une <emphasis>manipulation de la connexion</emphasis> est
	utile quand la fin d'une connexion en bande de base est
	n&eacute;cessaire.  Notez qu'il n'est normalement pas
	n&eacute;cessaire de le faire &agrave; la main.  La pile
	mettra fin automatiquement aux connexions en bande de base
	inactives.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>R&eacute;f&eacute;rez-vous &agrave; la commande
	<command>hccontrol help</command> pour une liste
	compl&egrave;te des commandes HCI disponibles.  La plupart des
	commandes HCI ne n&eacute;cessitent pas les privil&egrave;ges
	du super-utilisateur.</para>
    </sect2>

    <indexterm><primary>L2CAP</primary></indexterm>
    <sect2>
      <title>Protocole d'adaptation et de contr&ocirc;le de lien
	logique (L2CAP)</title>

      <para>Le protocole d'adaptation et de contr&ocirc;le de lien
	logique (L2CAP) fournit des services orient&eacute;s connexion
	ou non aux protocoles de niveaux sup&eacute;rieurs, et cela
	avec des possibilit&eacute;s de multiplexage de protocoles, de
	segmentation et de r&eacute;assemblage.  L2CAP permet aux
	applications et aux protocoles de niveaux sup&eacute;rieurs de
	transmettre et recevoir des paquets L2CAP d'une taille allant
	jusqu'&agrave; 64 Ko.</para>

      <para>L2CAP est bas&eacute; sur le concept de
	<emphasis>canaux</emphasis>.  Un canal est une connexion
	logique au sommet de la connexion en bande de base.  Chaque
	canal est attach&eacute; &agrave; un protocole suivant le
	sch&eacute;ma plusieurs-vers-un.  Plusieurs canaux peuvent
	&ecirc;tre attach&eacute;s au m&ecirc;me protocole, mais un
	canal ne peut &ecirc;tre attach&eacute;s &agrave; plusieurs
	protocoles.  Chaque paquet L2CAP re&ccedil;u sur un canal est
	dirig&eacute; vers le protocole de niveau sup&eacute;rieur
	appropri&eacute;.  Plusieurs canaux peuvent partager la
	m&ecirc;me connexion en bande de base.</para>

      <para>Un seul noeud Netgraph de type <emphasis>l2cap</emphasis>
	est cr&eacute;&eacute; pour un p&eacute;riph&eacute;rique
	&bluetooth;.  Le noeud L2CAP est normalement connect&eacute;
	au noeud HCI &bluetooth; (flux descendant) et aux noeuds des
	&ldquo;sockets&rdquo; &bluetooth; (flux montant).  Le nom par
	d&eacute;faut pour le noeud L2CAP est
	&ldquo;device2cap&rdquo;.  Pour plus de d&eacute;tails
	consultez la page de manuel &man.ng.l2cap.4;.</para>

      <para>Une commande utile est &man.l2ping.8;, qui peut &ecirc;tre
	utilis&eacute;e pour &ldquo;pinguer&rdquo; les autres
	p&eacute;riph&eacute;riques.  Certaines impl&eacute;mentations
	de &bluetooth; peuvent ne pas renvoyer toutes les
	donn&eacute;es qui leur sont envoy&eacute;es, aussi <literal>0
	bytes</literal> dans ce qui suit est normal.</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>L'utilitaire &man.l2control.8; est employ&eacute; pour
	effectuer diverses op&eacute;rations sur les noeuds L2CAP.
	Cet exemple montre comment obtenir la liste des connexions
	logiques (canaux) et la liste des connexions en bande de base
	pour le p&eacute;riph&eacute;rique local:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>Un autre outil de diagnostic est &man.btsockstat.1;.  Il
	effectue un travail similaire &agrave; celui de
	&man.netstat.1;, mais relatif aux structures de donn&eacute;es
	r&eacute;seau &bluetooth;.  L'exemple ci-dessous montre la
	m&ecirc;me connexion logique que &man.l2control.8;
	ci-dessus.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>
    </sect2>

    <indexterm><primary>RFCOMM</primary></indexterm>
    <sect2>
      <title>Protocole RFCOMM</title>

      <para>Le protocole RFCOMM permet l'&eacute;mulation du port
	s&eacute;rie au-dessus du protocole L2CAP.  Le protocole est
	bas&eacute; sur la norme ETSI TS 07.10.  RFCOMM est un
	protocole de transport simple, avec les dispositions
	suppl&eacute;mentaires pour &eacute;muler les 9 circuits
	(signaux) d'un port s&eacute;rie RS232 (EIATIA-232-E).  Le
	protocole RFCOMM supporte jusqu'&agrave; 60 connexions
	simultan&eacute;es (canaux RFCOMM) entre deux
	p&eacute;riph&eacute;riques &bluetooth;.</para>

      <para>Dans le cas de RFCOMM, l'&eacute;tablissement d'une
	communication implique deux applications tournant sur des
	p&eacute;riph&eacute;riques diff&eacute;rents (les
	extr&eacute;mit&eacute;s de la communication) avec un segment
	de communication entre eux.  RFCOMM est pr&eacute;vu pour
	couvrir les applications faisant usage des ports s&eacute;ries
	des p&eacute;riph&eacute;riques sur lesquels elles
	r&eacute;sident.  Le segment de communication est une liaison
	&bluetooth; d'un p&eacute;riph&eacute;rique vers un autre
	(connexion directe).</para>

      <para>RFCOMM est seulement concern&eacute; par la connexion
	entre p&eacute;riph&eacute;riques dans le cas d'un
	raccordement direct, ou entre le p&eacute;riph&eacute;rique et
	un modem dans le cas d'un r&eacute;seau.  RFCOMM peut
	supporter d'autres configurations, comme les modules qui
	communiquent par l'interm&eacute;diaire de la technologie sans
	fil &bluetooth; d'un c&ocirc;t&eacute; et utilise une
	interface c&acirc;bl&eacute;e de l'autre
	c&ocirc;t&eacute;.</para>

      <para>Sous &os;, le protocole RFCOMM est
	impl&eacute;ment&eacute; au niveau de la couche des
	&ldquo;sockets&rdquo; &bluetooth;.</para>
    </sect2>

    <indexterm><primary>couplage</primary></indexterm>
    <sect2>
      <title>Couplage des p&eacute;riph&eacute;riques</title>

      <para>Par d&eacute;faut, une communication &bluetooth; n'est pas
	authentifi&eacute;e, et n'importe quel
	p&eacute;riph&eacute;rique peut parler avec n'importe quel
	autre p&eacute;riph&eacute;rique.  Un
	p&eacute;riph&eacute;rique &bluetooth; (par exemple un
	t&eacute;l&eacute;phone portable) peut choisir de demander une
	authentification pour fournir un service particulier (par
	exemple un service de connexion t&eacute;l&eacute;phonique).
	L'authentification &bluetooth; est g&eacute;n&eacute;ralement
	effectu&eacute;e avec des <emphasis>codes PIN</emphasis>.  Un
	code PIN est une cha&icirc;ne ASCII d'une longueur de 16
	caract&egrave;res.  L'utilisateur doit entrer le m&ecirc;me
	code PIN sur les deux p&eacute;riph&eacute;riques.  Une fois
	que l'utilisateur a entr&eacute; le code PIN, les deux
	p&eacute;riph&eacute;riques g&eacute;n&egrave;rent une
	<emphasis>cl&eacute; de liaison</emphasis> (link key).
	Ensuite la cl&eacute; peut &ecirc;tre enregistr&eacute;e soit
	dans les p&eacute;riph&eacute;riques eux-m&ecirc;mes ou sur un
	moyen de stockage non-volatile.  La fois suivante les deux
	p&eacute;riph&eacute;riques utiliseront la cl&eacute;
	pr&eacute;c&eacute;demment g&eacute;n&eacute;r&eacute;e.  La
	proc&eacute;dure d&eacute;crite est appel&eacute;e
	<emphasis>couplage</emphasis>.  Si la cl&eacute; de liaison
	est perdue par un des p&eacute;riph&eacute;riques alors
	l'op&eacute;ration de couplage doit &ecirc;tre
	r&eacute;p&eacute;t&eacute;e.</para>

      <para>Le &ldquo;daemon&rdquo; &man.hcsecd.8; est responsable de
	la gestion de toutes les requ&ecirc;tes d'authentification
	&bluetooth;.  Le fichier de configuration par d&eacute;faut
	est <filename>/etc/bluetooth/hcsecd.conf</filename>.  Un
	exemple de section pour un t&eacute;l&eacute;phone portable
	avec un code PIN arbitraire de &ldquo;1234&rdquo; est
	donn&eacute; ci-dessous:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Il n'y pas de limitation sur les codes PIN (en dehors de
	la longueur).  Certains p&eacute;riph&eacute;riques (comme les
	casques-micro &bluetooth;) peuvent avoir un code PIN
	d&eacute;finitivement fix&eacute;.  Le param&egrave;tre
	<option>-d</option> force le &ldquo;daemon&rdquo;
	&man.hcsecd.8; &agrave; rester en t&acirc;che de fond, il est
	donc ais&eacute; de voir ce qu'il se passe.  Configurez le
	p&eacute;riph&eacute;rique distant pour recevoir le couplage
	et initier la connexion &bluetooth; vers le
	p&eacute;riph&eacute;rique distant.  Le
	p&eacute;riph&eacute;rique distant devrait annoncer que le
	couplage a &eacute;t&eacute; accept&eacute;, et demander le
	code PIN.  Entrez le m&ecirc;me code PIN que celui que vous
	avez dans le fichier <filename>hcsecd.conf</filename>.
	Maintenant votre PC et le p&eacute;riph&eacute;rique distant
	sont coupl&eacute;s.  Alternativement, vous pouvez initier le
	couplage sur le p&eacute;riph&eacute;rique distant.</para>

      <para>Sous &os; 5.5, 6.1 et versions suivantes, la ligne
	suivante peut &ecirc;tre ajout&eacute;e au fichier
	<filename>/etc/rc.conf</filename> pour obtenir un lancement
	automatique de <application>hcsecd</application> au
	d&eacute;marrage du syst&egrave;me:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Ce qui
	suit est une partie de la sortie du &ldquo;daemon&rdquo;
	<application>hcsecd</application>:</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>
    </sect2>

    <indexterm><primary>SDP</primary></indexterm>
    <sect2>
      <title>Le protocole de d&eacute;couverte de service
	(SDP)</title>

      <para>Le protocole de d&eacute;couverte de service (SDP) offre
	aux applications clientes les moyens de d&eacute;couvrir
	l'existence des services fournis par les applications serveurs
	ainsi que les propri&eacute;t&eacute;s (attributs) de ces
	services.  Les attributs d'un service comprennent le type ou
	la classe du service offert et le m&eacute;canisme ou
	l'information sur le protocole n&eacute;cessaire pour utiliser
	le service.</para>

      <para>Le SDP implique la communication entre un serveur SDP et
	un client SDP.  Le serveur maintient une liste
	d'enregistrements de services qui d&eacute;crit les
	caract&eacute;ristiques des services associ&eacute;s avec le
	serveur.  Chaque enregistrement de service contient
	l'information sur un seul serveur.  Un client peut
	r&eacute;cup&eacute;rer l'information &agrave; partir d'un
	enregistrement de service maintenu par le serveur SDP en
	&eacute;mettant une requ&ecirc;te SDP.  Si le client, ou une
	application associ&eacute;e avec le client, d&eacute;cide
	d'utiliser un service, il doit ouvrir une connexion
	s&eacute;par&eacute;e avec le fournisseur du service afin
	d'utiliser ce service.  Le SDP fournit un m&eacute;canisme
	pour d&eacute;couvrir les services et leur attributs, mais
	n'offre pas de m&eacute;canisme pour utiliser ces
	services.</para>

      <para>G&eacute;n&eacute;ralement, un client SDP recherche les
	services sur la base de caract&eacute;ristiques de services
	d&eacute;sir&eacute;es.  Cependant, il est parfois
	d&eacute;sirable de d&eacute;couvrir quel type de services
	sont d&eacute;crits par les enregistrements de services d'un
	serveur SDP sans aucune information pr&eacute;alable sur les
	services.  Ce processus de recherche des services offerts est
	appel&eacute; <emphasis>navigation</emphasis>
	(&ldquo;browsing&rdquo;).</para>

      <para>Le serveur SDP &bluetooth; &man.sdpd.8; et le client en
	ligne de commande &man.sdpcontrol.8; font partie de
	l'installation &os; standard.  L'exemple suivant montre
	comment effectuer un requ&ecirc;te de navigation
	(&ldquo;browse&rdquo;) SDP:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</screen>

      <para>... et ainsi de suite.  Remarquez que chaque service a une
	liste d'attributs (canal RFCOMM par exemple).  En fonction du
	service vous pourrez avoir besoin de prendre note de certains
	de ces attributs.  Certaines impl&eacute;mentations
	&bluetooth; ne supportent pas les requ&ecirc;tes de navigation
	et peuvent renvoyer une liste vide.  Dans ce cas il est
	possible de chercher un service sp&eacute;cifique.  L'exemple
	ci-dessous montre comment chercher le service OBEX Object Push
	(OPUSH):</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>Offrir des services sous &os; aux clients &bluetooth; se
	fait &agrave; l'aide du serveur &man.sdpd.8;.  Sous les
	versions de &os; 5.5, 6.1 et plus r&eacute;centes, la ligne
	suivante peut &ecirc;tre ajout&eacute;e au fichier
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Ensuite, le <quote>d&eacute;mon</quote>
	<application>sdpd</application> peut &ecirc;tre
	d&eacute;marr&eacute; avec:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sdpd start</userinput></screen>
      <para>Sous &os; 6.0, et sous les versions &os;&nbsp;5.X
	ant&eacute;rieures &agrave; 5.5, <application>sdpd</application>
	n'est pas int&eacute;gr&eacute; aux proc&eacute;dures de
	d&eacute;marrage du syst&egrave;me.  Il doit &ecirc;tre
	lanc&eacute; manuellement:</para>

      <screen>&prompt.root; <userinput>sdpd</userinput></screen>

      <para>L'application serveur locale qui d&eacute;sire offrir un
	service &bluetooth; &agrave; des clients distants enregistrera
	le service aupr&egrave;s du &ldquo;daemon&rdquo; SDP local.
	Un exemple d'une telle application est &man.rfcomm.pppd.8;.
	Une fois d&eacute;marr&eacute;, il enregistrera un service de
	r&eacute;seau local &bluetooth; aupr&egrave;s du serveur SDP
	local.</para>

      <para>La liste des services enregistr&eacute;s aupr&egrave;s du
	serveur SDP local peut &ecirc;tre obtenue en &eacute;mettant
	une requ&ecirc;te de navigation (&ldquo;browse&rdquo;) SDP par
	l'interm&eacute;diaire du canal de contr&ocirc;le:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>
    </sect2>

    <sect2>
      <title>Les profils Dial-Up Networking (DUN) et acc&egrave;s au
	r&eacute;seau local avec PPP (LAN)</title>

      <para>Le profil Dial-Up Networking (DUN) est principalement
	utilis&eacute; avec les modems et les t&eacute;l&eacute;phones
	portables.  Les cas de figure couverts par ce profil sont les
	suivants:</para>

      <itemizedlist>
	<listitem>
	  <para>Utilisation d'un t&eacute;l&eacute;phone portable ou
	    d'un modem par un ordinateur comme modem sans fil pour se
	    connecter &agrave; un serveur d'acc&egrave;s Internet, ou
	    pour l'utilisation de services accessibles par
	    t&eacute;l&eacute;phone;</para>
	</listitem>

	<listitem>
	  <para>Utilisation d'un t&eacute;l&eacute;phone portable ou
	    d'un modem par un ordinateur pour recevoir des appels avec
	    transmission de donn&eacute;es.</para>
	</listitem>
      </itemizedlist>

      <para>Le profil d'acc&egrave;s au r&eacute;seau local avec PPP
	(LAN) peut &ecirc;tre utilis&eacute; dans les situations
	suivantes:</para>

      <itemizedlist>
	<listitem>
	  <para>Acc&egrave;s au r&eacute;seau local pour un
	    p&eacute;riph&eacute;rique &bluetooth;;</para>
	</listitem>

	<listitem>
	  <para>Acc&egrave;s au r&eacute;seau local pour plusieurs
	    p&eacute;riph&eacute;riques &bluetooth;;</para>
	</listitem>

	<listitem>
	  <para>Liaison PC &agrave; PC (en utilisant le protocole PPP
	    sur une &eacute;mulation de c&acirc;ble
	    s&eacute;rie).</para>
	</listitem>
      </itemizedlist>

      <para>Sous &os; les deux profils sont impl&eacute;ment&eacute;s
	par &man.ppp.8; et &man.rfcomm.pppd.8;&mdash;un
	&ldquo;wrapper&rdquo; convertit la connexion &bluetooth;
	RFCOMM en quelque chose d'utilisable par PPP.  Avant qu'un
	profil ne soit utilisable, un nouveau label doit &ecirc;tre
	cr&eacute;&eacute; dans le fichier
	<filename>/etc/ppp/ppp.conf</filename>.  Consultez la page de
	manuel &man.rfcomm.pppd.8; pour des exemples.</para>

      <para>Dans l'exemple suivant &man.rfcomm.pppd.8; sera
	employ&eacute; pour ouvrir un connexion RFCOMM avec le
	p&eacute;riph&eacute;rique distant avec une adresse BD_ADDR
	00:80:37:29:19:a4 sur un canal DUN RFCOMM.  Le num&eacute;ro
	de canal RFCOMM r&eacute;el sera obtenu du
	p&eacute;riph&eacute;rique distant par l'interm&eacute;diaire
	de SDP.  Il est possible de pr&eacute;ciser le canal RFCOMM
	&agrave; la main, dans ce cas &man.rfcomm.pppd.8;
	n'&eacute;mettra pas de requ&ecirc;te SDP.  Utilisez
	&man.sdpcontrol.8; pour trouver le canal RFCOMM sur le
	p&eacute;riph&eacute;rique distant.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Afin de fournir un service d'acc&egrave;s au r&eacute;seau
	local avec PPP, le serveur &man.sdpd.8; doit &ecirc;tre en
	fonctionnement.  Une nouvelle entr&eacute;e pour les clients
	du r&eacute;seau local doit &ecirc;tre cr&eacute;&eacute;e
	dans le fichier <filename>/etc/ppp/ppp.conf</filename>.
	Consultez la page de manuel &man.rfcomm.pppd.8; pour des
	exemples.  Enfin, lancez le serveur RFCOMM PPP sur un
	num&eacute;ro de canal RFCOMM valide.  Le serveur RFCOMM PPP
	enregistrera automatiquement un service &bluetooth; LAN
	aupr&egrave;s du &ldquo;daemon&rdquo; SDP local.  L'exemple
	ci-dessous montre comment d&eacute;marrer le serveur RFCOMM
	PPP:</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>
    </sect2>

    <indexterm><primary>OBEX</primary></indexterm>
    <sect2>
      <title>Le profil OBEX Object Push (OPUSH)</title>

      <para>OBEX (&eacute;change d'objets) est un protocole
	tr&egrave;s largement utilis&eacute; pour les transferts de
	fichiers entre p&eacute;riph&eacute;riques mobiles.  Son
	utilisation principale se trouve dans les communications par
	infrarouge, o&ugrave; il est utilis&eacute; pour le transfert
	des fichiers entre ordinateurs portables ou PDAs, et pour
	envoyer des cartes de visite &eacute;lectronique ou des
	&eacute;l&eacute;ments d'agenda entre t&eacute;l&eacute;phones
	portables et d'autres p&eacute;riph&eacute;riques disposant
	d'applications de gestion d'informations personnelles
	(PIM).</para>

      <para>Le serveur et le client OBEX sont
	impl&eacute;ment&eacute;s dans le logiciel tierce-partie
	<application>obexapp</application>, qui est disponible sous la
	forme du logiciel port&eacute; <filename
	role="package">comms/obexapp</filename>.</para>

      <para>Le client OBEX est employ&eacute; pour
	&ldquo;pousser&rdquo; et/ou &ldquo;tirer&rdquo; des objets du
	serveur OBEX.  Un objet peut &ecirc;tre, par exemple, une
	carte de visite ou un rendez-vous.  Le client OBEX peut
	obtenir un num&eacute;ro de canal RFCOMM d'un
	p&eacute;riph&eacute;rique distant par l'interm&eacute;diaire
	de SDP.  Cela peut &ecirc;tre fait en sp&eacute;cifiant le nom
	du service plut&ocirc;t que le num&eacute;ro du canal RFCOMM.
	Les noms de service support&eacute;s sont: IrMC, FTRN et
	OPUSH.  Il est possible de pr&eacute;ciser le canal RFCOMM par
	un nombre.  Un exemple de session OBEX est
	pr&eacute;sent&eacute; ci-dessous, o&ugrave; l'objet
	information du p&eacute;riph&eacute;rique d'un
	t&eacute;l&eacute;phone portable est
	r&eacute;cup&eacute;r&eacute;, et un nouvel objet (carte de
	visite) est envoy&eacute; dans le r&eacute;pertoire du
	t&eacute;l&eacute;phone.</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Afin de fournir le service OBEX Object Push, le serveur
	&man.sdpd.8; doit tourner.  Un dossier racine o&ugrave; tous
	les objets entrant seront stock&eacute;s doit &ecirc;tre
	cr&eacute;&eacute;.  Le chemin d'acc&egrave;s par
	d&eacute;faut du r&eacute;pertoire racine est <filename
	role="directory">/var/spool/obex</filename>.  Le serveur OBEX
	enregistrera automatiquement le service OBEX Object Push
	aupr&egrave;s du &ldquo;daemon&rdquo; SDP local.  L'exemple
	ci-dessous montre comment d&eacute;marrer le serveur
	OBEX:</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
    </sect2>

    <sect2>
      <title>Le profil port s&eacute;rie (SPP)</title>

      <para>Le profil port s&eacute;rie (SPP) permet aux
	p&eacute;riph&eacute;riques &bluetooth; d'&eacute;muler un
	c&acirc;ble s&eacute;rie RS232 (ou similaire).  Ce profil
	traite avec les applications classiques en utilisant
	&bluetooth; comme un c&acirc;ble de remplacement, &agrave;
	travers une abstraction de port s&eacute;rie virtuel.</para>

      <para>L'utilitaire &man.rfcomm.sppd.1; impl&eacute;mente le
	profil port s&eacute;rie.  Un pseudo terminal est
	utilis&eacute; comme abstraction de port s&eacute;rie virtuel.
	L'exemple ci-dessous montre comment se connecter &agrave; un
	service port s&eacute;rie d'un p&eacute;riph&eacute;rique
	distant.  Notez que vous n'avez pas besoin d'indiquer un canal
	RFCOMM &mdash; &man.rfcomm.sppd.1; peut l'obtenir
	aupr&egrave;s du p&eacute;riph&eacute;rique distant via SDP.
	Si vous d&eacute;sirez forcer cela, sp&eacute;cifiez un canal
	RFCOMM sur la ligne de commande.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Une fois connect&eacute;, le pseudo-terminal peut
	&ecirc;tre utilis&eacute; comme un port s&eacute;rie:</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>D&eacute;pannage</title>

      <sect3>
	<title>Un p&eacute;riph&eacute;rique distant ne peut pas se
	  connecter</title>

	<para>Certains anciens p&eacute;riph&eacute;riques &bluetooth;
	  ne supportent pas de changement de r&ocirc;le.  Par
	  d&eacute;faut, quand &os; accepte une nouvelle connexion, il
	  tente d'effectuer un changement de r&ocirc;le et de devenir
	  ma&icirc;tre.  Les p&eacute;riph&eacute;riques qui ne
	  supportent pas cela ne seront pas en mesure de se connecter.
	  Notez qu'un changement de r&ocirc;le est effectu&eacute;
	  quand une nouvelle connexion est &eacute;tablie, il n'est
	  donc pas possible de demander au p&eacute;riph&eacute;rique
	  distant s'il supporte le changement de r&ocirc;le.  Il
	  existe une option HCI pour d&eacute;sactiver le changement
	  de r&ocirc;le au niveau local:</para>

	<screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>
      </sect3>

      <sect3>
	<title>Quelque chose ne va pas, puis-je voir ce qui se passe
	  exactement?</title>

	<para>Bien s&ucirc;r.  Utilisez le logiciel tierce-partie
	  <application>hcidump</application> qui est disponible sous
	  <filename role="package">comms/hcidump</filename> dans le
	  catalogue des logiciels port&eacute;s.
	  L'utilitaire <application>hcidump</application> est
	  similaire &agrave; &man.tcpdump.1;.  Il peut &ecirc;tre
	  utilis&eacute; pour afficher le contenu des paquets
	  &bluetooth; &agrave; l'&eacute;cran et les sauvegarder dans
	  un fichier.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Steve</firstname>
	  <surname>Peterson</surname>
	  <contrib>Ecrit par </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Bridging</title>

    <sect2>
      <title>Introduction</title>
      <indexterm><primary>sous-r&eacute;seau IP</primary></indexterm>
      <indexterm><primary>bridge/pont</primary></indexterm>
      <para>Il est parfois utile de diviser un r&eacute;seau physique
	(comme un r&eacute;seau Ethernet) en deux r&eacute;seaux
	s&eacute;par&eacute;s sans avoir &agrave; cr&eacute;er de
	sous-r&eacute;seaux IPs et &agrave; utiliser un routeur pour
	connecter ces r&eacute;seaux entre eux.  Le
	p&eacute;riph&eacute;rique qui connecte ensemble deux
	r&eacute;seaux de cette mani&egrave;re est appel&eacute;
	&ldquo;bridge&rdquo;&mdash;pont.  Un syst&egrave;me &os; avec
	deux cartes r&eacute;seaux peut faire fonction de pont.</para>

      <para>Le pont apprend les adresses MAC (adresses Ethernet) des
	p&eacute;riph&eacute;riques branch&eacute;s sur chacune de ses
	interfaces r&eacute;seaux.  Il transmet le trafic entre deux
	r&eacute;seaux uniquement quand la source et la destination
	sont sur des r&eacute;seaux diff&eacute;rents.</para>

      <para>Sous de nombreux aspects, un pont ressemble &agrave; un
	switch (commutateur) Ethernet avec tr&egrave;s peu de
	ports.</para>
    </sect2>

    <sect2>
      <title>Situations o&ugrave; l'utilisation d'un pont est
	appropri&eacute;e</title>

      <para>Il existe deux situations dans lesquelles un pont est de
	nos jours utilis&eacute;.</para>

      <sect3>
	<title>Trafic important sur un segment</title>

	<para>La premi&egrave;re situation appara&icirc;t quand un
	  segment physique d'un r&eacute;seau est submerg&eacute; par
	  le trafic, mais vous ne voulez pas, pour diff&eacute;rentes
	  raisons, subdiviser le r&eacute;seau et interconnecter les
	  sous-r&eacute;seaux &agrave; l'aide d'un routeur.</para>

	<para>Prenons comme exemple un journal o&ugrave; les bureaux
	  de la r&eacute;daction et de la production sont sur le
	  m&ecirc;me sous-r&eacute;seau.  Les utilisateurs de la
	  r&eacute;daction utilisent tous le serveur de fichiers
	  <hostid>A</hostid>, et les utilisateurs de la production le
	  serveur <hostid>B</hostid>.  Un r&eacute;seau Ethernet est
	  utilis&eacute; pour connecter ensemble les utilisateurs, et
	  des surcharges du r&eacute;seau ralentissent les
	  &eacute;changes.</para>

	<para>Si les utilisateurs de la r&eacute;daction peuvent
	  &ecirc;tre cantonn&eacute; sur un segment, et les
	  utilisateurs de la production sur un autre, les deux
	  r&eacute;seaux pourront &ecirc;tre connect&eacute;s par un
	  pont.  Seul le trafic r&eacute;seau destin&eacute; aux
	  interfaces r&eacute;seaux situ&eacute;es de
	  l'&ldquo;autre&rdquo; c&ocirc;t&eacute; du pont sera
	  transmis &agrave; l'autre r&eacute;seau, r&eacute;duisant
	  ainsi les congestions sur chaque segment.</para>
      </sect3>

      <sect3>
	<title>Coupe-feu filtrant/r&eacute;gulant le trafic</title>
	<indexterm><primary>coupe-feu</primary></indexterm>
	<indexterm><primary>NAT</primary></indexterm>

	<para>La deuxi&egrave;me situation est quand un coupe-feu est
	  n&eacute;cessaire mais sans translation d'adresses
	  (NAT).</para>

	<para>Un exemple est une compagnie qui est connect&eacute;e
	  &agrave; son fournisseur d'acc&egrave;s internet par
	  l'interm&eacute;diaire d'une connexion ISDN ou DSL.  Elle
	  dispose de 13 adresses IP routables fournies par le
	  fournisseur d'acc&egrave;s et dispose de 10 PCs sur son
	  r&eacute;seau.  Dans cette situation, utiliser un
	  coupe-feu/routeur est complexe en raison des
	  probl&egrave;mes de sous-r&eacute;seaux.</para>

	<indexterm><primary>routeur</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>
	<para>Un coupe-feu bas&eacute; sur un pont peut &ecirc;tre
	  configur&eacute; et positionn&eacute; dans le flux juste en
	  aval de leur routeur DSL/ISDN sans aucun probl&egrave;me
	  d'adressage IP.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuration d'un pont</title>

      <sect3>
	<title>Choix des cartes r&eacute;seaux</title>

	<para>Un pont n&eacute;cessite au moins deux cartes
	  r&eacute;seaux pour fonctionner.  Malheureusement toutes les
	  cartes r&eacute;seaux ne supportent pas le mode bridging.
	  Lisez la page de manuel &man.bridge.4; pour des
	  d&eacute;tails sur les cartes support&eacute;es.</para>

	<para>Installez et testez les deux cartes r&eacute;seaux avant
	  de poursuivre.</para>
      </sect3>

      <sect3>
	<title>Modification de la configuration du noyau</title>
	<indexterm>
	  <primary>options du noyau</primary>
	  <secondary>BRIDGE</secondary>
	</indexterm>

	<para>Pour activer le support n&eacute;cessaire pour mettre en
	  place un pont ajouter la ligne suivante:</para>

	<programlisting>options BRIDGE</programlisting>

	<para>&agrave; votre fichier de configuration du noyau, et
	  recompilez votre noyau.</para>
      </sect3>

      <sect3>
	<title>Support du coupe-feu</title>

	<indexterm><primary>coupe-feu</primary></indexterm>
	<para>Si vous projetez d'utiliser un pont en tant que
	  coupe-feu, vous devrez &eacute;galement ajouter l'option
	  <literal>IPFIREWALL</literal>.  Lisez la <xref
	  linkend="firewalls"> pour des informations
	  g&eacute;n&eacute;rales sur la configuration d'un pont en tant
	  que coupe-feu.</para>

	<para>Si vous avez besoin de permettre le passage &agrave;
	  travers le pont des paquets non-IP (comme ARP), il existe
	  une option du coupe-feu qui doit &ecirc;tre activ&eacute;e.
	  Cette option est
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.  Prennez
	  note que cela modifie le fonctionnement par d&eacute;faut du
	  coupe-feu, ce dernier acceptera alors tous les paquets.
	  Assurez-vous de savoir ce que ce changement signifie pour
	  votre ensemble de r&egrave;gles de filtrage avant de
	  l'effectuer.</para>
      </sect3>

      <sect3>
	<title>Support de la r&eacute;gulation du trafic</title>

	<para>Si vous d&eacute;sirez utiliser le pont comme
	  r&eacute;gulateur de trafic, vous devrez ajouter l'option
	  <literal>DUMMYNET</literal> &agrave; votre fichier de
	  configuration du noyau.  Consultez la page de manuel
	  &man.dummynet.4; pour plus d'information.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Activer le pont</title>

      <para>Ajoutez la ligne:</para>

      <programlisting>net.link.ether.bridge.enable=1</programlisting>

      <para>au fichier <filename>/etc/sysctl.conf</filename> pour
	activer le pont au d&eacute;marrage, et la ligne:</para>

      <programlisting>net.link.ether.bridge.config=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>pour activer le mode bridging sur les interfaces
	sp&eacute;cifi&eacute;es (remplacez
	<replaceable>if1</replaceable> et
	<replaceable>if2</replaceable> par les noms de vos interfaces
	r&eacute;seaux).  Si vous d&eacute;sirez que les paquets
	traversant le pont soient filtr&eacute;s par &man.ipfw.8;,
	vous devrez ajouter &eacute;galement la ligne:</para>

      <programlisting>net.link.ether.bridge.ipfw=1</programlisting>

      <para>Pour les versions ant&eacute;rieures &agrave; &os;&nbsp;5.2-RELEASE, utilisez
	les lignes suivantes:</para>

      <programlisting>net.link.ether.bridge=1
net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable>
net.link.ether.bridge_ipfw=1</programlisting>
    </sect2>

    <sect2>
      <title>Informations suppl&eacute;mentaires</title>

      <para>Si vous d&eacute;sirez &ecirc;tre en mesure de vous
	connecter au pont par l'interm&eacute;diaire de
	&man.ssh.1;, il est correct d'ajouter &agrave; l'une des
	cartes r&eacute;seaux une adresse IP.  Il existe un consensus
	sur le fait qu'assigner une adresse aux deux cartes est une
	mauvaise id&eacute;e.</para>

      <para>Si vous avez plusieurs ponts sur votre r&eacute;seau, il
	ne peut y en avoir plus d'un sur le chemin qui sera
	emprunt&eacute; par le trafic entre deux stations de travail.
	Techniquement, cela signifie qu'il n'y a pas de support pour
	la gestion du &ldquo;spanning tree&rdquo;.</para>

      <para>Un pont peut ajouter des temps de latence lors de
	l'utilisation de &man.ping.8;, et tout particuli&egrave;rement
	dans le cas du trafic d'un segment vers un autre.</para>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Jean-Fran&ccedil;ois</firstname>
	  <surname>Dock&egrave;s</surname>
	  <contrib>Mis &agrave; jour par </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Dupre</surname>
	  <contrib>R&eacute;organis&eacute; et augment&eacute;
	    par </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Syst&egrave;me sans disque dur</title>

    <indexterm><primary>station de travail sans disque
      dur</primary></indexterm>
    <indexterm><primary>syst&egrave;me sans disque
      dur</primary></indexterm>

    <para>Une machine &os; peut d&eacute;marrer via le r&eacute;seau
      et fonctionner sans disque dur local, en utilisant des
      syst&egrave;mes de fichiers mont&eacute;s &agrave; partir d'un
      serveur <acronym>NFS</acronym>.  Aucune modification du
      syst&egrave;me n'est n&eacute;cessaire en dehors des fichiers de
      configuration standards.  Un tel syst&egrave;me est facile
      &agrave; mettre en oeuvre comme tous les &eacute;l&eacute;ments
      sont directement disponibles:</para>

    <itemizedlist>
      <listitem>
	<para>Il y a au moins deux m&eacute;thodes possibles pour
	  charger un noyau via le r&eacute;seau:</para>

	<itemizedlist>
	  <listitem>
	    <para><acronym>PXE</acronym>: l'environnement
	      d'ex&eacute;cution pr&eacute;alable au d&eacute;marrage
	      d'&intel; (Preboot eXecution Environment) est une sorte de
	      ROM intelligente pr&eacute;sente sur certaines cartes
	      r&eacute;seau ou cartes m&egrave;re.  Consultez la page de
	      manuel &man.pxeboot.8; pour plus de d&eacute;tails.</para>
	  </listitem>

	  <listitem>
	    <para>Le logiciel port&eacute;
	      <application>Etherboot</application> (<filename
	      role="package">net/etherboot</filename>) produit un code
	      stockable dans une ROM pour d&eacute;marrer des noyaux via
	      le r&eacute;seau.  Le code peut &ecirc;tre soit
	      implant&eacute; dans une PROM de d&eacute;marrage sur une
	      carte r&eacute;seau, soit charg&eacute; &agrave; partir
	      d'une disquette (ou d'un disque dur local), ou &agrave;
	      partir d'un syst&egrave;me &ms-dos; en fonctionnement.  De
	      nombreuses cartes r&eacute;seau sont
	      support&eacute;es.</para>
	  </listitem>
	</itemizedlist>
      </listitem>

      <listitem>
	<para>Une proc&eacute;dure d'exemple
	  (<filename>/usr/share/examples/diskless/clone_root</filename>)
	  facilite la cr&eacute;ation et la maintenance du
	  syst&egrave;me de fichiers racine de la station de travail sur
	  le serveur.  La proc&eacute;dure demandera s&ucirc;rement
	  quelques modifications mais vous permettra de d&eacute;marrer
	  rapidement.</para>
      </listitem>

      <listitem>
	<para>Des fichiers de d&eacute;marrage du syst&egrave;me
	  existent dans le r&eacute;pertoire <filename
	  role="directory">/etc</filename> pour d&eacute;tecter et
	  supporter le d&eacute;marrage d'un syst&egrave;me sans disque
	  dur.</para>
      </listitem>

      <listitem>
	<para>La pagination, si n&eacute;cessaire, peut &ecirc;tre
	  faite par l'interm&eacute;diaire d'un fichier
	  <acronym>NFS</acronym> ou sur un disque local.</para>
      </listitem>
    </itemizedlist>

    <para>Il existe plusieurs fa&ccedil;ons de configurer des stations
      de travail sans disque dur.  Plusieurs &eacute;l&eacute;ments
      entrent en oeuvre, et la plupart peuvent &ecirc;tre
      ajust&eacute;s en fonction des besoins locaux.  Ce qui suit
      d&eacute;crit des variations sur la configuration d'un
      syst&egrave;me complet, mettant en avant le simplicit&eacute; et
      la compatibilit&eacute; avec les proc&eacute;dures standards de
      d&eacute;marrage de &os;.  Le syst&egrave;me d&eacute;crit
      pr&eacute;sente les caract&eacute;ristiques suivantes:</para>

    <itemizedlist>
      <listitem>
	<para>Les stations de travail sans disque dur utilisent des
	  syst&egrave;mes de fichiers <filename>/</filename> et
	  <filename>/usr</filename> partag&eacute;s et en lecture
	  seule.</para>

	<para>Le syst&egrave;me de fichiers racine est une copie d'une
	  racine &os; standard (g&eacute;n&eacute;ralement celle du
	  serveur), avec certains fichiers de configuration
	  remplac&eacute;s par des versions sp&eacute;cifiques
	  &agrave; un fonctionnement sans disque dur, et parfois
	  &agrave; la station de travail auxquels ils
	  appartiennent.</para>

	<para>Les parties de la racine qui doivent &ecirc;tre
	  inscriptibles sont remplac&eacute;es par des syst&egrave;mes
	  de fichiers &man.mfs.8; (&os;&nbsp;4.X) ou &man.md.4;
	  (&os;&nbsp;5.X).  Toute modification sera perdue au
	  red&eacute;marrage du syst&egrave;me.</para>
      </listitem>

      <listitem>
	<para>Le noyau est transf&eacute;r&eacute; et charg&eacute;
	  soit &agrave; l'aide d'<application>Etherboot</application>
	  soit de <acronym>PXE</acronym> comme certaines situations
	  peuvent exiger l'utilisation de l'une ou l'autre
	  m&eacute;thode.</para>
      </listitem>
    </itemizedlist>

    <caution>
      <para>Ainsi d&eacute;crit, le syst&egrave;me n'est pas
	s&eacute;curis&eacute;.  Il devrait se trouver dans une partie
	prot&eacute;g&eacute;e du r&eacute;seau, et les autres machines
	ne devraient pas lui faire confiance aveugl&eacute;ment.</para>
    </caution>

    <para>Toutes les instructions de cette section ont
      &eacute;t&eacute; test&eacute;es sous &os;&nbsp;4.9-RELEASE et
      5.2.1-RELEASE.  Le texte est destin&eacute; &agrave; l'origine
      pour une utilisation sous 4.X.  Des notes on &eacute;t&eacute;
      ins&eacute;r&eacute;es aux endroits n&eacute;cessaires pour
      indiquer les modifications concernant la branche 5.X.</para>

    <sect2>
      <title>Information de fond</title>

      <para>Mettre en place des stations de travail sans disque dur
	est &agrave; la fois relativement simple et enclin aux
	erreurs.  Ces derni&egrave;res sont parfois difficiles
	&agrave; diagnostiquer pour de nombreuses raisons.  Par
	exemple:</para>

      <itemizedlist>
	<listitem>
	  <para>Des options de compilation peuvent donner lieu
	    &agrave; des comportements diff&eacute;rents &agrave;
	    l'ex&eacute;cution.</para>
	</listitem>

	<listitem>
	  <para>Les messages d'erreurs sont souvent cach&eacute;s ou
	    totalement absents.</para>
	</listitem>
      </itemizedlist>

      <para>Dans ce contexte, avoir quelques connaissances des
	m&eacute;canismes sous-jacents impliqu&eacute;s est tr&egrave;s
	utile pour r&eacute;soudre les probl&egrave;mes qui peuvent
	surgir.</para>

      <para>Plusieurs op&eacute;rations doivent &ecirc;tre
	effectu&eacute;es pour un amor&ccedil;age
	r&eacute;ussi:</para>

      <itemizedlist>
	<listitem>
	  <para>La machine doit obtenir des param&egrave;tres de base
	    comme son adresse IP, le nom du fichier ex&eacute;cutable,
	    le nom du serveur, l'emplacement de la racine.  Ceci est
	    fait en utilisant le protocole <acronym>DHCP</acronym> ou le
	    protocole BOOTP.  <acronym>DHCP</acronym> est une extension
	    compatible de BOOTP, et utilise les m&ecirc;mes
	    num&eacute;ros de ports et son format de paquets
	    basic.</para>

	  <para>Il est possible de configurer un syst&egrave;me pour
	    n'utiliser que BOOTP.  Le programme serveur &man.bootpd.8;
	    fait partie du syst&egrave;me de base de &os;.</para>

	  <para>Cependant, <acronym>DHCP</acronym> pr&eacute;sente
	    plusieurs avantage sur BOOTP (des fichiers de
	    configuration plus lisibles, la possibilit&eacute;
	    d'utiliser <acronym>PXE</acronym>, plus de nombreux autres
	    avantages n'ayant pas de relation directe avec les
	    syst&egrave;mes sans disque dur), et nous d&eacute;crirons
	    principalement une configuration <acronym>DHCP</acronym>,
	    avec des exemples &eacute;quivalent utilisant
	    &man.bootpd.8; quand cela est possible.  L'exemple de
	    configuration utilisera le logiciel <application>ISC
	    DHCP</application> (la version 3.0.1.r12 &eacute;tait
	    install&eacute;e sur le serveur de test).</para>
	</listitem>

	<listitem>
	  <para>La machine a besoin de transf&eacute;rer un ou
	    plusieurs programmes en m&eacute;moire locale.
	    <acronym>TFTP</acronym> ou <acronym>NFS</acronym> sont
	    utilis&eacute;s.  Le choix entre <acronym>TFTP</acronym> et
	    <acronym>NFS</acronym> est &agrave; de nombreux endroits une
	    option s&eacute;lectionn&eacute;e lors de la compilation.
	    Une source d'erreur courante est d'indiquer des noms de
	    fichiers pour le mauvais protocole: <acronym>TFTP</acronym>
	    transf&egrave;re g&eacute;n&eacute;ralement tous les
	    fichiers &agrave; partir d'un seul r&eacute;pertoire sur le
	    serveur, et attendra des noms de fichiers relatifs &agrave;
	    ce r&eacute;pertoire.  <acronym>NFS</acronym> a besoin de
	    chemins d'acc&egrave;s absolus.</para>
	</listitem>

	<listitem>
	  <para>Les &eacute;ventuels programmes d'amorce
	    interm&eacute;diaires et le noyau doivent &ecirc;tre
	    initialis&eacute;s et ex&eacute;cut&eacute;s.  Il existe
	    plusieurs variations &agrave; ce niveau:</para>

	  <itemizedlist>
	    <listitem>
	      <para><acronym>PXE</acronym> chargera &man.pxeboot.8;,
		qui est une version modifi&eacute;e du chargeur.  Le
		chargeur (&man.loader.8;) r&eacute;cup&eacute;rera la
		plupart des param&egrave;tres n&eacute;cessaires au
		d&eacute;marrage du syst&egrave;me, et les transmettra
		au noyau avant de lui abandonner le contr&ocirc;le du
		syst&egrave;me.  Dans ce cas il est possible d'utiliser
		un noyau <filename>GENERIC</filename>.</para>
	    </listitem>

	    <listitem>
	      <para><application>Etherboot</application>, chargera
		directement le noyau avec moins de pr&eacute;paration.
		Vous devrez compiler un noyau avec des options
		particuli&egrave;res.</para>
	    </listitem>
	  </itemizedlist>

	  <para><acronym>PXE</acronym> et
	    <application>Etherboot</application> fonctionnent aussi
	    bien l'un que l'autre avec des syst&egrave;mes 4.X.  Comme
	    le noyau des syst&egrave;mes 5.X laisse au chargeur
	    (&man.loader.8;) un peu plus de travail &agrave;
	    effectuer, <acronym>PXE</acronym> est
	    pr&eacute;f&eacute;r&eacute; pour les syst&egrave;mes
	    5.X.</para>

	  <para>Si votre <acronym>BIOS</acronym> et vos cartes
	    r&eacute;seau supportent <acronym>PXE</acronym>, vous
	    devriez probablement l'utiliser.  Cependant, il est
	    toujours possible de d&eacute;marrer un syst&egrave;me 5.X
	    &agrave; l'aide
	    d'<application>Etherboot</application>.</para>
	</listitem>

	<listitem>
	  <para>Et enfin, la machine a besoin d'acc&eacute;der
	    &agrave; ses syst&egrave;mes de fichiers.
	    <acronym>NFS</acronym> est utilis&eacute; dans tous les
	    cas.</para>
	</listitem>
      </itemizedlist>

      <para>Consultez &eacute;galement la page de manuel
	&man.diskless.8;.</para>
    </sect2>

    <sect2>
      <title>Configuration</title>

      <sect3>
	<title>Configuration utilisant <application>ISC
	  DHCP</application></title>
	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>syst&egrave;me sans disque dur</secondary>
	</indexterm>

	<para>Le serveur <application>ISC DHCP</application>
	  peut r&eacute;pondre aux requ&ecirc;tes BOOTP et
	  <acronym>DHCP</acronym>.</para>

	<para>Avec la version 4.9, <application>ISC DHCP
	  3.0</application> ne fait pas partie du syst&egrave;me de
	  base.  Vous devrez installer le logiciel port&eacute;
	  <filename role="package">net/isc-dhcp3-server</filename> ou
	  la version pr&eacute;-compil&eacute;e correspondante.</para>

	<para>Une fois <application>ISC DHCP</application>
	  install&eacute;, il n&eacute;cessite un fichier de
	  configuration pour fonctionner (normalement appel&eacute;
	  <filename>/usr/local/etc/dhcpd.conf</filename>).  Voici un
	  exemple comment&eacute;, o&ugrave; la machine
	  <hostid>margaux</hostid> utilise
	  <application>Etherboot</application> et o&ugrave; la machine
	  <hostid>corbieres</hostid> emploie
	  <acronym>PXE</acronym>:</para>

	<programlisting>
default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "example.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <co id="co-dhcp-host-name">
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <co id="co-dhcp-next-server">
    filename "/data/misc/kernel.diskless"; <co id="co-dhcp-filename">
    option root-path "192.168.4.4:/data/misc/diskless"; <co id="co-dhcp-root-path">
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename "pxeboot";
    option root-path "192.168.4.4:/data/misc/diskless";
  }
}
	</programlisting>

	<calloutlist>
	  <callout arearefs="co-dhcp-host-name"><para>Cette option dit
	      &agrave; <application>dhcpd</application> d'envoyer le
	      param&egrave;tre des d&eacute;clarations
	      <literal>host</literal> comme nom de machine pour la
	      machine sans disque dur.  Une autre m&eacute;thode
	      aurait &eacute;t&eacute; d'ajouter <literal>option
	      host-name <replaceable>margaux</replaceable></literal>
	      &agrave; l'int&eacute;rieur des d&eacute;clarations
	      <literal>host</literal>.</para>
	  </callout>

	  <callout arearefs="co-dhcp-next-server"><para>La directive
	      <literal>next-server</literal> d&eacute;signe le serveur
	      <acronym>TFTP</acronym> ou <acronym>NFS</acronym>
	      &agrave; utiliser pour t&eacute;l&eacute;charger le
	      chargeur ou le noyau (le comportement par d&eacute;faut
	      &eacute;tant d'utiliser la m&ecirc;me machine que le
	      serveur <acronym>DHCP</acronym>).</para>
	  </callout>

	  <callout arearefs="co-dhcp-filename"><para>La directive
	      <literal>filename</literal> pr&eacute;cise le fichier
	      que chargera <application>Etherboot</application> ou
	      <acronym>PXE</acronym> &agrave; la prochaine
	      &eacute;tape.  Il doit &ecirc;tre d&eacute;fini en
	      fonction de la m&eacute;thode de transfert
	      utilis&eacute;e.  <application>Etherboot</application>
	      peut &ecirc;tre compil&eacute; pour utiliser
	      <acronym>NFS</acronym> ou <acronym>TFTP</acronym>.  Le
	      logiciel port&eacute; pour &os; utilisera
	      <acronym>NFS</acronym> par d&eacute;faut.
	      <acronym>PXE</acronym> emploie <acronym>TFTP</acronym>,
	      c'est pourquoi un chemin d'acc&egrave;s relatif est
	      utilis&eacute; ici (cela peut d&eacute;pendre de la
	      configuration du serveur <acronym>TFTP</acronym>, mais
	      devrait &ecirc;tre plut&ocirc;t classique).  De plus,
	      <acronym>PXE</acronym> charge
	      <filename>pxeboot</filename>, et non pas le noyau.  Il
	      existe d'autres possibilit&eacute;s
	      int&eacute;ressantes, comme le chargement de
	      <filename>pxeboot</filename> &agrave; partir du
	      r&eacute;pertoire <filename
	      role="directory">/boot</filename> d'un CD-ROM &os;
	      (comme &man.pxeboot.8; peut charger un noyau
	      <filename>GENERIC</filename> cela rend possible
	      l'utilisation de <acronym>PXE</acronym> pour
	      d&eacute;marrer &agrave; partir d'un lecteur de CD-ROM
	      distant).</para>
	  </callout>

	  <callout arearefs="co-dhcp-root-path"><para>L'option
	      <literal>root-path</literal> d&eacute;finie le chemin
	      d'acc&egrave;s au syst&egrave;me de fichiers racine,
	      suivant la notation classique de <acronym>NFS</acronym>.
	      En utilisant <acronym>PXE</acronym>, il est possible de
	      ne pas pr&eacute;ciser l'adresse IP de la machine
	      d&egrave;s lors que vous n'activez pas l'option BOOTP du
	      noyau.  Le serveur <acronym>NFS</acronym> sera alors le
	      m&ecirc;me que le serveur
	      <acronym>TFTP</acronym>.</para>
	  </callout>
	</calloutlist>
      </sect3>

      <sect3>
	<title>Configuration utilisant BOOTP</title>
	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>syst&egrave;me sans disque dur</secondary>
	</indexterm>

	<para>Ce qui suit pr&eacute;sente une configuration
	  <application>bootpd</application> &eacute;quivalente
	  (r&eacute;duite &agrave; un seul client).  Elle se
	  trouverait sous <filename>/etc/bootptab</filename>.</para>

	<para>Veuillez noter qu'<application>Etherboot</application>
	  doit &ecirc;tre compil&eacute; avec l'option
	  <literal>NO_DHCP_SUPPORT</literal> (qui n'est pas
	  activ&eacute;e par d&eacute;faut) afin d'utiliser BOOTP et
	  que <acronym>PXE</acronym>
	  <emphasis>n&eacute;cessite</emphasis>
	  <acronym>DHCP</acronym>.  The seul avantage &eacute;vident
	  de <application>bootpd</application> est qu'il est
	  disponible dans le syst&egrave;me de base.</para>

	<programlisting>
.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100
	</programlisting>
      </sect3>

      <sect3>
	<title>Pr&eacute;paration d'un programme de d&eacute;marrage
	  avec <application>Etherboot</application></title>

	<indexterm>
	  <primary>Etherboot</primary>
	</indexterm>

	<para>Le <ulink url="http://etherboot.sourceforge.net">site
	  Web d'Etherboot</ulink> propose une <ulink
	  url="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
	  documentation importante</ulink> principalement
	  destin&eacute;e aux syst&egrave;mes Linux, mais contenant
	  n&eacute;amoins des informations utiles.  Ce qui suit
	  pr&eacute;sente comment vous utiliseriez
	  <application>Etherboot</application> sur un syst&egrave;me
	  &os;.</para>

	<para>Vous devez tout d'abord installer le logiciel
	  port&eacute; <filename
	  role="package">net/etherboot</filename> ou sa version
	  pr&eacute;-compil&eacute;e.</para>

	<para>Vous pouvez modifier la configuration
	  d'<application>Etherboot</application> (i.e. pour utiliser
	  <acronym>TFTP</acronym> au lieu de <acronym>NFS</acronym>)
	  en &eacute;ditant le fichier <filename>Config</filename>
	  dans le r&eacute;pertoire des sources
	  d'<application>Etherboot</application>.</para>

	<para>Pour notre configuration nous utiliserons une disquette
	  de d&eacute;marrage.  Pour d'autres m&eacute;thodes (PROM,
	  ou un programme &ms-dos;), consultez la documentation
	  d'<application>Etherboot</application>.</para>

	<para>Pour cr&eacute;er une disquette de d&eacute;marrage,
	  ins&eacute;rez une disquette dans le lecteur de la machine
	  o&ugrave; vous avez install&eacute;
	  <application>Etherboot</application>, puis rendez-vous dans
	  le r&eacute;pertoire <filename
	  role="directory">src</filename> de l'arborescence
	  <application>Etherboot</application> et tapez:</para>

	<screen>
&prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput></screen>

	<para><replaceable>devicetype</replaceable> d&eacute;pend du
	  type de carte Ethernet se trouvant dans la station de
	  travail sans disque dur.  R&eacute;f&eacute;rez-vous au
	  fichier <filename>NIC</filename> dans le m&ecirc;me
	  r&eacute;pertoire pour d&eacute;terminer la valeur
	  <replaceable>devicetype</replaceable> correcte.</para>
      </sect3>

      <sect3>
	<title>D&eacute;marrer avec <acronym>PXE</acronym></title>

	<para>Par d&eacute;faut le chargeur &man.pxeboot.8; charge le
	  noyau via <acronym>NFS</acronym>.  Il peut &ecirc;tre
	  compil&eacute; pour utiliser <acronym>TFTP</acronym>
	  &agrave; la place en sp&eacute;cifiant l'option
	  <literal>LOADER_TFTP_SUPPORT</literal> dans le fichier
	  <filename>/etc/make.conf</filename>.  Lisez les commentaires
	  dans le fichier <filename>/etc/defaults/make.conf</filename>
	  (ou <filename>/usr/share/examples/etc/make.conf</filename>
	  pour les syst&egrave;mes 5.X) pour plus de
	  d&eacute;tails.</para>

	<para>Il existe deux autres options de
	  <filename>make.conf</filename> non-document&eacute;es qui
	  peuvent &ecirc;tre utiles pour la configuration d'une
	  machine faisant fonction de console s&eacute;rie sans disque
	  dur: <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, et
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal> (cette
	  derni&egrave;re n'existe que sous &os;&nbsp;5.X).</para>

	<para>Pour utiliser <acronym>PXE</acronym> quand la machine
	  d&eacute;marre, vous aurez normalement besoin de
	  s&eacute;lectionner l'option <literal>Boot from
	  network</literal> dans votre <acronym>BIOS</acronym>, ou
	  d'appuyer sur une touche de fonction lors de
	  l'initialisation du PC.</para>
      </sect3>

      <sect3>
	<title>Configuration des serveurs <acronym>TFTP</acronym> et
	  <acronym>NFS</acronym></title>

	<indexterm>
	  <primary>TFTP</primary>
	  <secondary>syst&egrave;me sans disque dur</secondary>
	</indexterm>
	<indexterm>
	  <primary>NFS</primary>
	  <secondary>syst&egrave;me sans disque dur</secondary>
	</indexterm>

	<para>Si vous utilisez <acronym>PXE</acronym> ou
	  <application>Etherboot</application> configur&eacute;s pour
	  employer <acronym>TFTP</acronym>, vous devez activer
	  <application>tftpd</application> sur le serveur de
	  fichier:</para>

	<procedure>
	  <step>
	    <para>Cr&eacute;ez un r&eacute;pertoire &agrave; partir
	      duquel <application>tftpd</application> proposera les
	      fichiers, e.g. <filename
	      role="directory">/tftpboot</filename>.</para>
	  </step>

	  <step>
	    <para>Ajoutez la ligne suivante &agrave; votre fichier
	      <filename>/etc/inetd.conf</filename>:</para>

	    <programlisting>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</programlisting>

	    <note>
	      <para>Il appara&icirc;t que certaines versions de
		<acronym>PXE</acronym> veulent la version
		<acronym>TCP</acronym> de <acronym>TFTP</acronym>.
		Dans ce cas, ajoutez une seconde ligne, en
		rempla&ccedil;ant <literal>dgram udp</literal> par
		<literal>stream tcp</literal>.</para>
	    </note>
          </step>
	  <step>
	    <para>Demandez &agrave; <application>inetd</application>
	      de relire son fichier de configuration:</para>

	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
	  </step>
        </procedure>

	<para>Le r&eacute;pertoire <filename
	  role="directory">tftpboot</filename> peut &ecirc;tre
	  plac&eacute; n'importe o&ugrave; sur le serveur.
	  Assurez-vous que son emplacement est d&eacute;fini dans les
	  fichiers <filename>inetd.conf</filename> et
	  <filename>dhcpd.conf</filename>.</para>

	<para>Dans tous les cas, vous devez &eacute;galement activer
	  <acronym>NFS</acronym> et exporter le syst&egrave;me de
	  fichiers appropri&eacute; sur le serveur
	  <acronym>NFS</acronym>.</para>

	<procedure>
	  <step>
	    <para>Ajoutez ce qui suit au fichier
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>nfs_server_enable="YES"</programlisting>
	  </step>

	  <step>
	    <para>Exportez le syst&egrave;me de fichiers contenant le
	      r&eacute;pertoire racine du syst&egrave;me sans disque dur
	      en ajoutant ce qui suit au fichier
	      <filename>/etc/exports</filename> (ajustez le point de
	      montage et remplacez <replaceable>margaux
	      corbieres</replaceable> avec les noms des stations de
	      travail sans disque dur):</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux corbieres</replaceable></programlisting>
          </step>

	  <step>
	    <para>Demandez &agrave; <application>mountd</application>
	      de relire son fichier de configuration.  Si vous avez eu
	      besoin d'activer <acronym>NFS</acronym> dans
	      <filename>/etc/rc.conf</filename> lors du premier point,
	      vous voudrez probablement plutot red&eacute;marrer la
	      machine.</para>

	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>
	  </step>
        </procedure>
      </sect3>

      <sect3>
	<title>Compilation d'un noyau pour syst&egrave;me sans disque
	  dur</title>

	<indexterm>
	  <primary>syst&egrave;me sans disque dur</primary>
	  <secondary>configuration du noyau</secondary>
	</indexterm>

	<para>Si vous utilisez <application>Etherboot</application>,
	  vous devez cr&eacute;er un fichier de configuration du noyau
	  pour le client sans disque dur avec les options suivantes
	  (en plus des options habituelles):</para>

	<programlisting>
options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
	</programlisting>

	<para>Vous pouvez vouloir &eacute;galement employer les
	  options <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> et
	  <literal>BOOTP_WIRED_TO</literal> (r&eacute;f&eacute;rez-vous au
	  fichier <filename>LINT</filename> sous 4.X ou
	  <filename>NOTES</filename> sous 5.X).</para>

	<para>Les noms de ces options sont historiques et
	  l&eacute;g&egrave;rement trompeur comme elles activent
	  indiff&eacute;rement l'utilisation de
	  <acronym>DHCP</acronym> et BOOTP dans le noyau (il est
	  &eacute;galement possible de forcer une utilisation stricte
	  de BOOTP ou <acronym>DHCP</acronym>).</para>

	<para>Compilez le noyau (voir <xref linkend="kernelconfig">),
	  et copiez-le &agrave; l'emplacement indiqu&eacute; dans
	  <filename>dhcpd.conf</filename>.</para>

	<note>
	  <para>Quand on utilise <acronym>PXE</acronym>, la
	    compilation d'un noyau avec les options
	    pr&eacute;c&eacute;dentes n'est pas strictement
	    n&eacute;cessaire (bien que conseill&eacute;).  Les activer
	    causera un plus grand nombre de requ&ecirc;tes
	    <acronym>DHCP</acronym> g&eacute;n&eacute;r&eacute;es lors
	    du d&eacute;marrage du noyau, avec un petit risque
	    d'inconsistance entre les nouvelles valeurs et celles
	    r&eacute;cup&eacute;r&eacute;es par &man.pxeboot.8; dans
	    certains cas particuliers.  L'avantage de leur utilisation
	    est que le nom de la machine sera forc&eacute;ment
	    d&eacute;fini.  Sinon vous devrez d&eacute;finir le nom de
	    la machine par une autre m&eacute;thode, par exemple dans un
	    fichier <filename>rc.conf</filename> particulier au
	    client.</para>
	</note>

	<note>
	  <para>Afin d'&ecirc;tre chargeable par
	    <application>Etherboot</application>, un noyau 5.X doit
	    &ecirc;tre compil&eacute; avec les &ldquo;device
	    hints&rdquo;.  Vous d&eacute;finirez normalement l'option
	    suivante dans le fichier de configuration (voir le fichier
	    de commentaires sur la configuration:
	    <filename>NOTES</filename>):</para>

	  <programlisting>hints		"GENERIC.hints"</programlisting>
	</note>
      </sect3>

      <sect3>
	<title>Pr&eacute;parer le syst&egrave;me de fichiers
	  racine</title>

	<indexterm>
	  <primary>syst&egrave;me de fichiers racine</primary>
	  <secondary>syst&egrave;me sans disque dur</secondary>
	</indexterm>

	<para>Vous devez cr&eacute;er un syst&egrave;me de fichiers
	  racine pour les stations de travail sans disque dur,
	  &agrave; l'emplacement d&eacute;fini par
	  <literal>root-path</literal> dans le fichier
	  <filename>dhcpd.conf</filename>.  Les sections suivantes
	  d&eacute;crivent deux mani&egrave;res de le faire.</para>

	<sect4>
	  <title>Utilisation de la proc&eacute;dure
	    <filename>clone_root</filename></title>

	  <para>C'est la m&eacute;thode la plus rapide pour
	    cr&eacute;er un syst&egrave;me de fichiers racine, mais
	    elle est, pour le moment, uniquement support&eacute;e sous
	    &os;&nbsp;4.X..  Cette proc&eacute;dure est situ&eacute;e
	    &agrave; l'emplacement
	    <filename>/usr/share/examples/diskless/clone_root</filename>
	    et demande quelques modifications, pour au moins ajuster
	    l'emplacement du syst&egrave;me de fichiers &agrave;
	    cr&eacute;er (la variable <literal>DEST</literal>).</para>

	  <para>R&eacute;f&eacute;rez-vous aux commentaires
	    situ&eacute;s en d&eacute;but de la proc&eacute;dure pour
	    information.  Ils expliquent comment le syst&egrave;me de
	    fichiers de base est construit, et comment les fichiers
	    peuvent &ecirc;tre remplac&eacute;s de fa&ccedil;on
	    s&eacute;lective par des versions sp&eacute;cifiques
	    &agrave; un fonctionnement sans disque dur, ou &agrave; un
	    sous-r&eacute;seau, ou encore &agrave; une station de
	    travail particuli&egrave;re.  Ils donnent &eacute;galement
	    des exemples de fichiers <filename>/etc/fstab</filename>
	    et <filename>/etc/rc.conf</filename> pour un
	    fonctionnement sans disque dur.</para>

	  <para>Les fichiers <filename>README</filename> dans le
	    r&eacute;pertoire <filename
	    role="directory">/usr/share/examples/diskless</filename>
	    contiennent beaucoup d'information de fond, mais, avec les
	    autres exemples du r&eacute;pertoire <filename
	    role="directory">diskless</filename>, ils documentent une
	    m&eacute;thode de configuration qui est distincte de celle
	    utilis&eacute;e par <filename>clone_root</filename> et les
	    proc&eacute;dures de d&eacute;marrage du syst&egrave;me de
	    <filename role="directory">/etc</filename>, ce qui est un
	    peu &agrave; l'origine de confusions.  Utilisez-les comme
	    r&eacute;f&eacute;rence uniquement, &agrave; moins que
	    vous pr&eacute;f&eacute;riez la m&eacute;thode qu'ils
	    d&eacute;crivent, dans quel cas vous devrez modifier les
	    proc&eacute;dures <filename>rc</filename>.</para>
	</sect4>

	<sect4>
	  <title>Utilisation de la proc&eacute;dure <command>make
	    world</command> standard</title>

	  <para>Cette m&eacute;thode s'applique aussi bien &agrave;
	    &os;&nbsp;4.X qu'&agrave; &os;&nbsp;5.X et installera un
	    syst&egrave;me complet (et non pas uniquement le
	    syst&egrave;me de fichiers racine) dans le
	    r&eacute;pertoire d&eacute;fini par
	    <envar>DESTDIR</envar>.  Tout ce dont vous avez besoin de
	    faire est d'ex&eacute;cuter la proc&eacute;dure
	    suivante:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make world &amp;&amp; make kernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Une fois cela termin&eacute;, vous devrez personaliser
	    vos fichiers <filename>/etc/rc.conf</filename> et
	    <filename>/etc/fstab</filename> situ&eacute;s dans
	    <envar>DESTDIR</envar> en fonction de vos besoins.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Configuration de l'espace de pagination</title>

	<para>Si n&eacute;cessaire, un fichier de pagination
	  situ&eacute; sur le serveur peut &ecirc;tre utilis&eacute;
	  via <acronym>NFS</acronym>.  Une des m&eacute;thodes
	  couramment utilis&eacute;es pour cela n'est plus
	  support&eacute;e sous 5.X.</para>

	<sect4>
	  <title>Pagination via <acronym>NFS</acronym> sous
	    &os;&nbsp;4.X</title>

	  <para>L'emplacement et la taille du fichier de pagination
	    peuvent &ecirc;tre sp&eacute;cifi&eacute;s avec les
	    options BOOTP/<acronym>DHCP</acronym> 128 et 129
	    sp&eacute;cifiques &agrave; &os;.  Des exemples de
	    fichiers de configuration pour <application>ISC DHCP
	    3.0</application> ou <application>bootpd</application>
	    suivent:</para>

	  <procedure>
	    <step>
	      <para>Ajoutez les lignes suivantes au fichier
		<filename>dhcpd.conf</filename>:</para>

	      <programlisting>
# Global section
option swap-path code 128 = string;
option swap-size code 129 = integer 32;

host margaux {
  ... # Standard lines, see above
  option swap-path <replaceable>"192.168.4.4:/netswapvolume/netswap"</replaceable>;
  option swap-size <replaceable>64000</replaceable>;
}
	      </programlisting>

	      <para><literal>swap-path</literal> est le chemin
		d'acc&egrave;s vers un r&eacute;pertoire o&ugrave; les
		fichiers de pagination sont situ&eacute;s.  Chaque
		fichier sera nomm&eacute;
		<filename>swap.<replaceable>ip-client</replaceable></filename>.</para>

	      <para>Les anciennes version de
		<application>dhcpd</application> utilisaient une
		syntaxe du type <literal>option option-128
		"...</literal>, qui n'est plus
		support&eacute;e.</para>

	      <para><filename>/etc/bootptab</filename> utiliserait la
		syntaxe suivante &agrave; la place:</para>

	      <programlisting>T128="192.168.4.4:/netswapvolume/netswap":T129=0000fa00</programlisting>

	      <note>
		<para>Dans le fichier
		  <filename>/etc/bootptab</filename>, la taille de
		  l'espace de pagination doit &ecirc;tre exprim&eacute;e
		  en hexad&eacute;cimal.</para>
	      </note>
	    </step>

	    <step>
	      <para>Sur le serveur du fichier de pagination
		par <acronym>NFS</acronym>, cr&eacute;ez le(s)
		fichier(s) de pagination:</para>

	      <screen>
&prompt.root; <userinput>mkdir <replaceable>/netswapvolume/netswap</replaceable></userinput>
&prompt.root; <userinput>cd <replaceable>/netswapvolume/netswap</replaceable></userinput>
&prompt.root; <userinput>dd if=/dev/zero bs=1024 count=<replaceable>64000</replaceable> of=swap.<replaceable>192.168.4.6</replaceable></userinput>
&prompt.root; <userinput>chmod 0600 swap.<replaceable>192.168.4.6</replaceable></userinput></screen>

	      <para><replaceable>192.168.4.6</replaceable> est
		l'adresse IP du client sans disque dur.</para>
	    </step>

	    <step>
	      <para>Sur le serveur du fichier de pagination par
		<acronym>NFS</acronym>, ajoutez la ligne suivante au
		fichier <filename>/etc/exports</filename>:</para>

	      <programlisting>
<replaceable>/netswapvolume</replaceable>  -maproot=0:10 -alldirs <replaceable>margaux corbieres</replaceable>
	      </programlisting>

	      <para>Ensuite demandez &agrave;
		<application>mountd</application> &agrave; relire le
		fichier <filename>exports</filename>, comme plus
		haut.</para>
	    </step>
	  </procedure>
	</sect4>

	<sect4>
	  <title>Pagination via <acronym>NFS</acronym> sous
	    &os&nbsp;5.X</title>

	  <para>Le noyau ne supporte pas l'activation de la pagination
	    par <acronym>NFS</acronym> au d&eacute;marrage.  L'espace
	    de pagination doit &ecirc;tre activ&eacute; par les
	    proc&eacute;dures de d&eacute;marrage, en montant un
	    syst&egrave;me de fichiers accessible en &eacute;criture
	    et en cr&eacute;ant et en activant un fichier de
	    pagination.  Pour cr&eacute;er un fichier de pagination de
	    la taille appropri&eacute;e, vous pouvez effectuer ce qui
	    suit:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/path/to/swapfile</replaceable> bs=1k count=1 oseek=<replaceable>100000</replaceable></userinput></screen>

	  <para>Pour ensuite l'activer, vous devez ajouter la ligne
	    suivante &agrave; votre fichier
	    <filename>rc.conf</filename>:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
        </sect4>
      </sect3>

      <sect3>
	<title>Probl&egrave;mes divers</title>

	<sect4>
	  <title>Utilisation d'un <filename>/usr</filename> en lecture
	    seule</title>

	  <indexterm>
	    <primary>syst&egrave;me sans disque dur</primary>
	    <secondary>/usr en lecture seule</secondary>
	  </indexterm>

	  <para>Si la station de travail sans disque dur est
	    configur&eacute;e pour ex&eacute;cuter X, you devrez
	    ajuster le fichier de configuration de
	    <application>XDM</application>, qui envoie le journal
	    d'erreurs sur <filename role="directory">/usr</filename>
	    par d&eacute;faut.</para>
	</sect4>

	<sect4>
	  <title>Utilisation d'un serveur non-&os;</title>

	  <para>Quand le serveur pour le syst&egrave;me de fichiers
	    racine ne fait pas tourner &os;, vous devrez cr&eacute;er
	    le syst&egrave;me de fichiers racine sur une machine &os;,
	    puis le copier vers sa destination en utilisant
	    <command>tar</command> ou <command>cpio</command>.</para>

	  <para>Dans cette situation, il y a parfois des
	    probl&egrave;mes avec les fichiers sp&eacute;ciaux de
	    p&eacute;riph&eacute;riques dans <filename
	    role="directory">/dev</filename>, en raison de
	    diff&eacute;rences de taille sur les entiers.  Une
	    solution &agrave; ce probl&egrave;me est d'exporter un
	    r&eacute;pertoire &agrave; partir du serveur non-&os;, de
	    monter ce r&eacute;pertoire sur une machine &os;, et
	    ex&eacute;cuter <command>MAKEDEV</command> sur la machine
	    &os; pour cr&eacute;er les entr&eacute;es de
	    p&eacute;riph&eacute;riques correctes (&os;&nbsp;5.X et
	    les versions suivantes utilisent &man.devfs.5; pour
	    l'allocation des fichiers sp&eacute;ciaux de
	    p&eacute;riph&eacute;riques de mani&egrave;re transparente
	    pour l'utilisateur, ex&eacute;cuter
	    <command>MAKEDEV</command> sur ces versions est
	    inutile).</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>ISDN</title>

    <indexterm>
      <primary>ISDN&mdash;(RNIS)</primary>
    </indexterm>

    <para>Une bonne source d'information sur la technologie et le
      mat&eacute;riel ISDN (RNIS) est <ulink
      url="http://www.alumni.caltech.edu/~dank/isdn/">la page ISDN de
      Dan Kegel</ulink>.</para>

    <para>Voici un rapide aper&ccedil;u &agrave; propos de
      l'ISDN:</para>

    <itemizedlist>
      <listitem>
	<para>Si vous r&eacute;sidez en Europe, vous devriez
	  &eacute;tudier la section sur les cartes ISDN.</para>
      </listitem>

      <listitem>
	<para>Si vous envisagez d'utiliser l'ISDN avant tout pour vous
	  connecter &agrave; l'Internet par l'interm&eacute;diaire d'un
	  fournisseur d'acc&egrave;s Internet et d'une ligne
	  t&eacute;l&eacute;phonique non d&eacute;di&eacute;e, vous
	  devriez vous int&eacute;resser aux Adaptateurs Terminaux.
	  C'est la solution la plus souple, qui vous posera le moins de
	  probl&egrave;mes si vous changez de fournisseur
	  d'acc&egrave;s.</para>
      </listitem>

      <listitem>
	<para>Si vous interconnectez deux r&eacute;seaux locaux, ou si
	  vous vous connectez &agrave; l'Internet avec une liaison ISDN
	  d&eacute;di&eacute;e, vous devriez envisager un pont/routeur
	  autonome.</para>
      </listitem>
    </itemizedlist>

    <para>Le co&ucirc;t est un facteur d&eacute;terminant de la
      solution que vous choisirez.  Les options suivantes sont
      list&eacute;es de la moins ch&egrave;re &agrave; la plus
      ch&egrave;re.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Hellmuth</firstname>
	    <surname>Michaelis</surname>
	    <contrib>Contribution de </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>Cartes ISDN</title>

      <indexterm>
	<primary>ISDN</primary>
	<secondary>cartes</secondary>
      </indexterm>

      <para>L'impl&eacute;mentation ISDN de &os; ne supporte que la
	norme DSS1/Q.931 (ou Euro-ISDN) utilisant des cartes passives.
	Depuis &os;&nbsp;4.4, quelques cartes actives sont
	support&eacute;es o&ugrave; le firmware supporte
	&eacute;galement d'autres protocoles au niveau des signaux,
	cela inclut les premi&egrave;res cartes support&eacute;es du
	type &ldquo;Primary Rate ISDN&rdquo; (PRI).</para>

      <para>Le logiciel <application>isdn4bsd</application> vous
	permet de vous connecter &agrave; d'autres routeurs ISDN soit
	en utilisant l'IP sur de l'HDLC de base, soit en utilisant PPP
	synchrone: en employant PPP int&eacute;gr&eacute; au noyau
	avec <literal>isppp</literal>, une version modifi&eacute;e du
	pilote de p&eacute;riph&eacute;rique &man.sppp.4;, ou en
	employant &man.ppp.8; en mode utilisateur.  L'utilisation de
	&man.ppp.8; en mode utilisateur rend possible
	l'agr&eacute;gation de deux ou plus canaux ISDN de type B.
	Une application capable de r&eacute;pondre aux appels
	t&eacute;l&eacute;phoniques est &eacute;galement disponible,
	tout comme de nombreux utilitaires comme un modem logiciel 300
	bauds.</para>

      <para>Un nombre croissant de cartes ISDN pour PC sont
	support&eacute;es sous &os; et les retours montrent qu'elles
	sont utilis&eacute;es avec succ&egrave;s dans toute l'Europe
	et dans de nombreuses autres parties du monde.</para>

      <para>Les cartes ISDN passives support&eacute;es sont
	principalement celles avec le circuit ISDN ISAC/HSCX/IPAC
	d'Infineon (pr&eacute;c&eacute;demment Siemens), mais
	&eacute;galement les cartes avec des circuits en provenance de
	Cologne Chip (cartes ISA uniquement), les cartes PCI avec les
	circuits Winbond W6692, quelques cartes avec les circuits
	Tiger300/320/ISAC et quelques cartes avec des circuits
	sp&eacute;cifiques comme l'AVM Fritz!Card PCI V.1.0 de l'AVM
	Fritz!Card PnP.</para>

      <para>Actuellement les cartes ISDN actives support&eacute;es
	sont les cartes AVM B1 (ISA et PCI) BRI et les cartes PCI AVM
	T1 PRI.</para>

      <para>Pour de la documentation sur
	<application>isdn4bsd</application>, consultez le
	r&eacute;pertoire <filename
	role="directory">/usr/share/examples/isdn/</filename> sur
	votre syst&egrave;me &os; ou sur la <ulink
	url="http://www.freebsd-support.de/i4b/">page web
	d'isdn4bsd</ulink> qui propose &eacute;galement des astuces,
	des erratas et bien plus de documentation que le <ulink
	url="http://people.FreeBSD.org/~hm/">manuel
	d'isdn4bsd</ulink>.</para>

      <para>Au cas o&ugrave; vous seriez int&eacute;ress&eacute; par
	l'ajout du support pour un protocole ISDN diff&eacute;rent,
	d'une carte ISDN pour PC non encore support&eacute;e ou par
	l'am&eacute;lioration d'<application>isdn4bsd</application>,
	veuillez contacter &a.hm;.</para>

      <para>Pour les questions concernant l'installation, la
	configuration et le d&eacute;pannage
	d'<application>isdn4bsd</application>, une liste de diffusion
	&a.isdn.name; est disponible.</para>
    </sect2>

    <sect2>
      <title>Adaptateurs terminaux ISDN</title>

      <para>Les adaptateurs terminaux&mdash;&ldquo;Terminal adapters
	(TA)&rdquo;; sont l'&eacute;quivalent ISDN des modems pour les
	lignes t&eacute;l&eacute;phoniques ordinaires.</para>

      <indexterm><primary>modem</primary></indexterm>

      <para>La plupart des TA utilisent le jeu de commandes standard
	des modems Hayes, et peuvent &ecirc;tre utilis&eacute;s en
	remplacement d'un modem.</para>

      <para>Un TA fonctionne essentiellement de la m&ecirc;me
	mani&egrave;re qu'un modem &agrave; la diff&eacute;rence que
	la vitesse de la connexion sera plus &eacute;lev&eacute;e
	qu'avec votre vieux modem.  Vous devrez configurer <link
	linkend="ppp">PPP</link> de fa&ccedil;on exactement identique
	que pour un modem classique.  Assurez-vous de fixer la vitesse
	de votre port s&eacute;rie la plus haute possible.</para>

      <indexterm><primary>PPP</primary></indexterm>

      <para>Le principal avantage d'utiliser un TA pour vous connecter
	&agrave; votre fournisseur d'acc&egrave;s Internet est de
	pouvoir utiliser PPP en mode dynamic.  Comme l'espace
	d'adressage IP disponible devient de plus en plus restreint,
	la plupart des fournisseurs d'acc&egrave;s ne d&eacute;sirent
	plus vous fournir d'adresse IP statique.  La plupart des
	routeurs autonomes ne peuvent pas fonctionner avec une
	allocation dynamique d'adresse IP.</para>

      <para>Les fonctionnalit&eacute;s et la stabilit&eacute; de la
	connexion des adaptateurs terminaux reposent
	compl&egrave;tement sur le &ldquo;daemon&rdquo; PPP.  Cela
	vous permet de passer facilement d'un modem classique &agrave;
	l'ISDN sur une machine &os;, si vous avez d&eacute;j&agrave;
	configur&eacute; PPP.  Cependant, les probl&egrave;mes que
	vous avez &eacute;ventuellement rencontr&eacute;s avec PPP
	persisteront.</para>

      <para>Si vous d&eacute;sirez un maximum de stabilit&eacute;,
	utilisez <link linkend="ppp">PPP int&eacute;gr&eacute; au
	noyau</link>, &agrave; la place du <link linkend="userppp">PPP
	en mode utilisateur</link>.</para>

      <para>Les adaptateurs suivants sont connus pour fonctionner avec
	&os;:</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola BitSurfer et Bitsurfer Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>La plupart des adaptateurs terminaux fonctionneront
	probablement &eacute;galement, les fabricants de TA font en
	sorte que leurs produits acceptent la plupart du jeu de
	commandes AT des modems.</para>

      <para>Le vrai probl&egrave;me avec les adaptateurs terminaux est
	que comme pour les modems, il vous faudra une bonne interface
	s&eacute;rie dans votre ordinateur.</para>

      <para>Vous devriez lire le document sur <ulink
	url="&url.articles.serial-uart;/index.html">les ports
	s&eacute;rie sous &os;</ulink> pour comprendre en
	d&eacute;tail le fonctionnement des
	p&eacute;riph&eacute;riques s&eacute;rie et les
	diff&eacute;rences entre les ports s&eacute;ries asynchrones
	et synchrones.</para>

      <para>Un adaptateur terminal sur un port s&eacute;rie PC
	standard (asynchrone) vous limite &agrave; 115.2&nbsp;Kbs,
	m&ecirc;me si vous disposez d'une connexion &agrave;
	128&nbsp;Kbs.  Pour utiliser compl&egrave;tement les
	128&nbsp;Kbs offert par l'ISDN, vous devez brancher
	l'adaptateur sur une carte s&eacute;rie synchrone.</para>

      <para>Ne vous imaginez pas qu'il suffit d'acheter un adaptateur
	terminal interne pour s'affranchir du probl&egrave;me
	synchrone/asynchrone.  Les adaptateurs internes disposent
	simplement d'un port s&eacute;rie PC standard.  Tout ce que
	vous y gagnerez sera d'&eacute;conomiser un c&acirc;ble
	s&eacute;rie et de lib&eacute;rer une prise
	&eacute;lectrique.</para>

      <para>Une carte synchrone avec un adaptateur terminal est au
	moins aussi rapide qu'un routeur autonome, pilot&eacute; par
	une simple machine &os;, et probablement plus souple.</para>

      <para>Le choix entre carte synchrone/adaptateur ou routeur
	autonome est une question de go&ucirc;t.  Ce sujet a
	&eacute;t&eacute; abord&eacute; dans les listes de diffusion.
	Nous vous sugg&eacute;rons de chercher dans les <ulink
	url="&url.base;/search/index.html">archives</ulink> pour
	obtenir l'int&eacute;gralit&eacute; de la discussion.</para>
    </sect2>

    <sect2>
      <title>Ponts/Routeurs ISDN autonomes</title>
      <indexterm>
	<primary>ISDN</primary>
	<secondary>ponts/routeurs autonomes</secondary>
      </indexterm>

      <para>Les ponts ou routeurs ISDN ne sont pas sp&eacute;cifiques
	&agrave; &os; ou &agrave; tout autre syst&egrave;me
	d'exploitation.  Pour une description compl&egrave;te de la
	technologie du routage et des ponts, veuillez vous reportez
	&agrave; un ouvrage de r&eacute;f&eacute;rence sur les
	r&eacute;seaux.</para>

      <para>Dans le contexte de cette section, les termes de routeur
	et de pont seront utilis&eacute;s
	indiff&eacute;remment.</para>

      <para>Comme le prix des routeurs/ponts ISDN d'entr&eacute;e de
	gamme baissent, il est probable qu'ils deviennent un choix de
	plus en plus populaire.  Un routeur ISDN est une petite
	bo&icirc;te qui se branche directement sur votre r&eacute;seau
	Ethernet, et g&egrave;re sa propre connexion aux autres
	ponts/routeurs.  Il int&egrave;gre le logiciel
	n&eacute;cessaire au support du protocole PPP et d'autres
	protocoles.</para>

      <para>Un routeur vous offrira un d&eacute;bit plus
	&eacute;lev&eacute; qu'un adaptateur terminal standard,
	puisqu'il utilisera une connexion ISDN synchrone.</para>

      <para>Le principal probl&egrave;me avec les routeurs et ponts
	ISDN est que l'int&eacute;rop&eacute;rabilit&eacute; entre les
	mat&eacute;riels des diff&eacute;rents constructeurs n'est pas
	toujours garantie.  Si vous projetez de vous connecter
	&agrave; un fournisseur d'acc&egrave;s Internet, vous devriez
	discuter de vos besoins avec ce dernier.</para>

      <para>Si vous envisagez de connecter ensemble deux
	r&eacute;seaux locaux, comme le r&eacute;seau de votre
	domicile et celui de votre bureau, c'est la solution la plus
	simple et celle qui demande le moins de maintenance.  Etant
	donn&eacute; que vous &ecirc;tes la personne qui ach&egrave;te
	les &eacute;quipements pour les deux extr&eacute;mit&eacute;s,
	vous &ecirc;tes s&ucirc;r que cela fonctionnera.</para>

      <para>Par exemple pour connecter un ordinateur personnel
	situ&eacute; &agrave; son domicile ou le r&eacute;seau d'une
	agence &agrave; celui du si&egrave;ge social, la configuration
	suivante pourra &ecirc;tre utilis&eacute;e:</para>

      <example>
	<title>R&eacute;seau d'agence ou &agrave; domicile</title>

	<indexterm><primary>10 base 2</primary></indexterm>
	<para>Le r&eacute;seau utilise une topologie en bus avec une
	  connectique Ethernet 10 base 2 (&ldquo;thinnet&rdquo;).
	  Connectez le routeur au r&eacute;seau &agrave; l'aide d'un
	  &eacute;metteur/r&eacute;cepteur AUI/10BT si
	  n&eacute;cessaire.</para>

        <mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-bus">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">---Station de travail Sun
|
---Machine FreeBSD
|
---Windows 95
|
Routeur autonome
   |
Liaison ISDN BRI</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>Ethernet 10 Base 2</phrase>
	  </textobject>
	</mediaobject>

	<para>Si votre r&eacute;seau de domicile/d'agence n'est
	  constitu&eacute; que d'un seul ordinateur, vous pouvez
	  utiliser une paire torsad&eacute;e crois&eacute;e pour le
	  connecter directement au routeur autonome.</para>
      </example>

      <example>
	<title>Si&egrave;ge social ou autre r&eacute;seau</title>

	<indexterm><primary>10 base T</primary></indexterm>
	<para>Le r&eacute;seau utilise une topologie en &eacute;toile
	  avec une connectique Ethernet 10 base T (&ldquo;paire
	  torsad&eacute;e&rdquo;).</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="advanced-networking/isdn-twisted-pair">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">    -------Serveur Novell
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Routeur autonome
                |
        Liaison ISDN BRI</literallayout>
	  </textobject>

	  <textobject>
	    <phrase>Architecture du R&eacute;seau ISDN</phrase>
	  </textobject>
	</mediaobject>
      </example>

      <para>Un des principaux avantages de la plupart des
	routeurs/ponts est le fait qu'ils permettent d'avoir deux
	connexions PPP <emphasis>s&eacute;par&eacute;es et
	ind&eacute;pendantes</emphasis> vers deux sites
	diff&eacute;rents et cela en <emphasis>m&ecirc;me</emphasis>
	temps.  Ceci n'est pas support&eacute; par la plupart des
	adaptateurs terminaux, en dehors de mod&egrave;les
	sp&eacute;cifiques (en g&eacute;n&eacute;ral co&ucirc;teux)
	qui disposent de deux ports s&eacute;rie.  Ne confondez pas
	cette possibilit&eacute; avec l'agr&eacute;gation de canaux,
	MPP, etc.</para>

      <para>Ceci peut &ecirc;tre une fonctionnalit&eacute; tr&egrave;s
	utile si, par exemple, vous disposez d'une connexion ISDN
	d&eacute;di&eacute;e au bureau et vous voudriez en profiter
	mais vous ne voulez pas acqu&eacute;rir une nouvelle ligne
	ISDN.  Un routeur au bureau peut g&eacute;rer un canal B
	d&eacute;di&eacute; (64&nbsp;Kbps) vers l'Internet et utiliser
	l'autre canal B pour une autre connexion.  Le deuxi&egrave;me
	canal B peut &ecirc;tre utilis&eacute; pour les connexions
	entrantes, sortantes ou pour l'agr&eacute;gation de canaux
	(MPP, etc.) avec le premier canal B pour augmenter la bande
	passante.</para>

      <indexterm><primary>IPX/SPX</primary></indexterm>
      <para>Un pont Ethernet vous permettra de transmettre autre chose
	que juste du trafic IP.  Vous pouvez &eacute;galement faire
	passer de l'IPX/SPX ou tout autre protocole que vous
	utilisez.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contribution de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Translation d'adresses</title>

    <sect2 id="network-natoverview">
      <title>G&eacute;n&eacute;ralit&eacute;s</title>
      <indexterm>
	<primary><application>natd</application></primary>
      </indexterm>
      <para>Le &ldquo;daemon&rdquo; de translation d'adresses
	(&ldquo;Network Address Translation&rdquo;&mdash;NAT) de &os;,
	g&eacute;n&eacute;ralement connu sous le nom de &man.natd.8; est
	un &ldquo;daemon&rdquo; qui accepte les paquets IP entrants,
	change l'adresse de la source par celle de la machine locale et
	r&eacute;-injecte les paquets dans le flux sortant des paquets
	IP.  Le programme &man.natd.8; effectue cela en changeant
	l'adresse IP et le port source de sorte quand les donn&eacute;es
	r&eacute;ponse arrivent il soit en mesure de d&eacute;terminer
	la provenance des donn&eacute;es d'origine et les
	transf&eacute;rer &agrave; l'&eacute;metteur original.</para>

      <indexterm><primary>Partage de connexion Internet</primary></indexterm>
      <indexterm><primary>NAT</primary></indexterm>

      <para>L'utilisation classique de NAT est le partage de connexion
	Internet.</para>
    </sect2>

    <sect2 id="network-natsetup">
      <title>Architecture du r&eacute;seau</title>

      <para>En raison de la diminution du nombre d'adresses IP libres
	sous IPv4, et de l'augmentation du nombre d'utilisateurs de
	lignes haut-d&eacute;bit comme le c&acirc;ble ou l'ADSL, le
	besoin d'utiliser une solution de partage de connexion est
	donc en constante augmentation.  La possibilit&eacute; de
	connecter plusieurs ordinateurs par l'interm&eacute;diaire
	d'une connexion et d'une adresse IP fait de &man.natd.8; une
	solution de choix.</para>

      <para>Plus g&eacute;n&eacute;ralement, un utilisateur dispose
	d'une machine connect&eacute; sur la c&acirc;ble ou une ligne
	ADSL avec une adresse IP et d&eacute;sire utiliser cet
	ordinateur connect&eacute; pour fournir un acc&egrave;s
	Internet &agrave; d'autres machines du r&eacute;seau
	local.</para>

      <para>Pour cela, la machine &os; sur Internet doit jouer le
	r&ocirc;le de passerelle.  Cette machine passerelle doit avoir
	deux cartes r&eacute;seaux&mdash;l'une pour se connecter au
	routeur Internet, l'autre est connect&eacute;e au
	r&eacute;seau local.  Toutes les machines du r&eacute;seau
	local sont connect&eacute;es par l'interm&eacute;diaire d'un
	hub ou d'un switch.</para>

      <note>
	<para>Il existe plusieurs mani&egrave;res pour connecter un
	  r&eacute;seau local &agrave; l'Internet &agrave; travers une
	  passerelle &os;.  Cet exemple n'abordera que le cas d'une
	  passerelle avec au moins deux cartes r&eacute;seaux.</para>
      </note>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/natd">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">  _______       __________       _________
 |       |     |          |     |         |
 |  Hub  |-----| Client B |-----| Routeur |----- Internet
 |_______|     |__________|     |_________|
     |
 ____|_____
|          |
| Client A |
|__________|</literallayout>
	</textobject>

	<textobject>
	  <phrase>Organisation du r&eacute;seau</phrase>
	</textobject>
      </mediaobject>

      <para>Une telle configuration est commun&eacute;ment
	utilis&eacute;e pour partager une connexion Internet.  Une des
	machines du r&eacute;seau local est connect&eacute;e &agrave;
	Internet.  Le reste des machines acc&egrave;de &agrave;
	Internet par l'interm&eacute;diaire de cette machine
	&ldquo;passerelle&rdquo;.</para>
    </sect2>

    <sect2 id="network-natdkernconfiguration">
      <indexterm>
	<primary>noyau</primary>
	<secondary>configuration</secondary>
      </indexterm>
      <title>Configuration</title>

      <para>Les options suivantes doivent &ecirc;tre pr&eacute;sentes
	dans le fichier de configuration du noyau:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>De plus, les options suivantes peuvent &eacute;galement
	&ecirc;tre utiles:</para>

      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>

      <para>Ce qui suit doit figurer dans le fichier
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>gateway_enable="YES" <co id="co-natd-gateway-enable">
firewall_enable="YES" <co id="co-natd-firewall-enable">
firewall_type="OPEN" <co id="co-natd-firewall-type">
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>" <co id="co-natd-natd-interface">
natd_flags="" <co id="co-natd-natd-flags"></programlisting>

      <calloutlist>
	<callout arearefs="co-natd-gateway-enable">
	  <para>Configure la machine comme passerelle.
	    Ex&eacute;cuter <command>sysctl
	    net.inet.ip.forwarding=1</command> aurait le m&ecirc;me
	    effet.</para>
	</callout>

	<callout arearefs="co-natd-firewall-enable">
	  <para>Active au d&eacute;marrage les r&egrave;gles du
	    coupe-feu se trouvant dans le fichier
	    <filename>/etc/rc.firewall</filename>.</para>
	</callout>

	<callout arearefs="co-natd-firewall-type">
	  <para>Cela sp&eacute;cifie un ensemble de r&egrave;gles
	    pr&eacute;d&eacute;finies pour le coupe-feu qui autorise
	    tous les paquets entrant.  Consultez le fichier
	    <filename>/etc/rc.firewall</filename> pour d'autres
	    ensembles de r&eacute;gles.</para>
	</callout>

	<callout arearefs="co-natd-natd-interface">
	  <para>Indique &agrave; travers quelle interface
	    transf&eacute;rer les paquets (l'interface
	    connect&eacute;e &agrave; l'Internet).</para>
	</callout>

	<callout arearefs="co-natd-natd-flags">
	  <para>Toutes options de configuration
	    suppl&eacute;mentaires pass&eacute;es &agrave;
	    &man.natd.8; au d&eacute;marrage.</para>
	</callout>
      </calloutlist>

      <para>Le fait d'avoir les options pr&eacute;c&eacute;dentes
	d&eacute;finies dans le fichier
	<filename>/etc/rc.conf</filename> lancera la commande
	<filename>/etc/rc.conf</filename> au d&eacute;marrage.  Cette
	commande peut &ecirc;tre &eacute;galement
	ex&eacute;cut&eacute;e &agrave; la main.</para>

      <note>
	<para>Il est &eacute;galement possible d'utiliser un fichier
	  de configuration pour &man.natd.8; quand il y a trop d'options
	  &agrave; passer.  Dans ce cas, le fichier de configuration
	  doit &ecirc;tre d&eacute;fini en ajoutant la ligne suivante au
	  fichier <filename>/etc/rc.conf</filename>:</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<para>Le fichier <filename>/etc/natd.conf</filename>
	  contiendra une liste d'options de configuration, une par
	  ligne.  Par exemple le cas de figure de la section suivante
	  utiliserait le fichier suivant:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Pour plus d'information concernant le fichier de
	  configuration, consultez la page de manuel de &man.natd.8;
	  au sujet de l'option <option>-f</option>.</para>
      </note>

      <para>A chaque machine et interface derri&egrave;re le
	r&eacute;seau local doit &ecirc;tre assign&eacute; une adresse
	IP de l'espace d'adresses priv&eacute;es comme d&eacute;fini
	par la <ulink url="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC
	1918</ulink> et doit disposer d'une passerelle par
	d&eacute;faut qui est l'adresse IP interne de la machine
	&man.natd.8;.</para>

      <para>Par exemple, les clients <hostid>A</hostid> et
	<hostid>B</hostid> du r&eacute;seau local ont les adresses IP
	<hostid role="ipaddr">192.168.0.2</hostid> et <hostid
	role="ipaddr">192.168.0.3</hostid>, tandis que l'interface sur
	le r&eacute;seau local de la machine
	<application>natd</application> a pour adresse IP <hostid
	role="ipaddr">192.168.0.1</hostid>.  La passerelle par
	d&eacute;faut des clients <hostid>A</hostid> et
	<hostid>B</hostid> doit &ecirc;tre l'adresse <hostid
	role="ipaddr">192.168.0.1</hostid> de la machine
	<application>natd</application>.  L'interface externe ou
	Internet de cette derni&egrave;re ne demande aucune
	modification sp&eacute;cifique pour que &man.natd.8; puisse
	fonctionner.</para>
    </sect2>

    <sect2 id="network-natdport-redirection">
      <title>Redirection de ports</title>

      <para>L'inconv&eacute;nient avec &man.natd.8; est que les
	clients du r&eacute;seau local ne sont pas accessibles depuis
	l'Internet.  Les clients sur le r&eacute;seau local peuvent
	&eacute;tablir des connexions sortantes vers le monde
	ext&eacute;rieur mais ne peuvent recevoir de connexions
	entrantes.  Cela pr&eacute;sente un probl&egrave;me si l'on
	tente de faire tourner des services Internet sur une des
	machines du r&eacute;seau local.  Une solution simple &agrave;
	ce probl&egrave;me est de rediriger les ports Internet
	s&eacute;lectionn&eacute;s de la machine
	<application>natd</application> vers le client sur le
	r&eacute;seau local.</para>

      <para>Par exemple, un serveur IRC tourne sur le client
	<hostid>A</hostid>, et un serveur web sur le client
	<hostid>B</hostid>.  Pour que cela fonctionne correctement,
	les connections re&ccedil;ues sur les ports 6667 (IRC) et 80
	(web) doivent &ecirc;tre redirig&eacute;es vers les machines
	correspondantes.</para>

      <para>L'option <option>-redirect_port</option> doit &ecirc;tre
	pass&eacute;e &agrave; &man.natd.8; avec les autres options
	ad&eacute;quates.  La syntaxe est la suivante:</para>

      <programlisting>-redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>Dans l'exemple pr&eacute;c&eacute;dent, l'argument
	pass&eacute; &agrave; la commande devrait &ecirc;tre:</para>

      <programlisting>-redirect_port tcp 192.168.0.2:6667 6667
-redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Cela va rediriger les ports <emphasis>tcp</emphasis>
	voulus vers les machines du r&eacute;seau local.</para>

      <para>L'option <option>-redirect_port</option> peut &ecirc;tre
	utilis&eacute;e pour indiquer une plage de ports plut&ocirc;t
	que des ports individuels.  Par exemple <replaceable>tcp
	192.168.0.2:2000-3000 2000-3000</replaceable> redirigerait
	toutes les connexions re&ccedil;ues sur les ports 2000
	&agrave; 3000 vers les ports 2000 &agrave; 3000 du client
	<hostid>A</hostid>.</para>

      <para>Ces options peuvent &ecirc;tre utilis&eacute;es quand on
	ex&eacute;cute directement &man.natd.8;, plac&eacute;es dans
	l'option <literal>natd_flags=""</literal> du fichier
	<filename>/etc/rc.conf</filename>, ou pass&eacute;es
	par l'interm&eacute;diaire d'un fichier de configuration.</para>

      <para>Pour plus d'&eacute;l&eacute;ments et d'options de
	configuration consultez la page de manuel &man.natd.8;</para>
    </sect2>

    <sect2 id="network-natdaddress-redirection">
      <title>Redirection d'adresses</title>
      <indexterm><primary>redirection d'adresses</primary></indexterm>

      <para>La redirection d'adresses est utile si plusieurs adresses
	IP sont disponibles mais doivent se trouver sur une seule
	machine.  Avec cela, &man.natd.8; peut assigner &agrave;
	chaque client du r&eacute;seau local sa propre adresse IP
	externe.  Le programme &man.natd.8; r&eacute;crit alors les
	paquets sortant des clients du r&eacute;seau local avec
	l'adresse IP externe correcte et redirige tout le trafic
	entrant sur une adresse IP particuli&egrave;re vers la machine
	du r&eacute;seau local correspondante.  Ce principe est
	&eacute;galement connu sous le nom de translation d'adresses
	statique.  Par exemple, les adresses IP <hostid
	role="ipaddr">128.1.1.1</hostid>, <hostid
	role="ipaddr">128.1.1.2</hostid>, et <hostid
	role="ipaddr">128.1.1.3</hostid> appartiennent &agrave; la
	passerelle <application>natd</application>.  L'adresse <hostid
	role="ipaddr">128.1.1.1</hostid> peut &ecirc;tre
	utilis&eacute;e comme adresse IP externe de la passerelle
	<application>natd</application>, tandis que <hostid
	role="ipaddr">128.1.1.2</hostid> et <hostid
	role="ipaddr">128.1.1.3</hostid> sont redirig&eacute;es vers
	les machines <hostid>A</hostid> et <hostid>B</hostid> du
	r&eacute;seau local.</para>

      <para>La syntaxe de l'option <option>-redirect_address</option>
	est la suivante:</para>

      <programlisting>-redirect_address localIP publicIP</programlisting>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>localIP</entry>
	      <entry>L'adresse IP interne du client sur le
		r&eacute;seau local.</entry>
	    </row>
	    <row>
	      <entry>publicIP</entry>
	      <entry>L'adresse IP externe correspondant au client sur
		le r&eacute;seau local.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Dans l'exemple, les arguments pass&eacute;s &agrave; la
	commande seraient:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Comme pour l'option <option>-redirect_port</option>, ces
	options peuvent &ecirc;tre plac&eacute;es dans l'option
	<literal>natd_flags=""</literal> du fichier
	<filename>/etc/rc.conf</filename>, ou pass&eacute;es par l'interm&eacute;diaire d'un fichier de configuration.  Avec la redirection
	d'adresse, il n'y a pas besoin de redirection de ports puisque
	toutes les donn&eacute;es re&ccedil;ues sur une IP
	particuli&egrave;re sont redirig&eacute;es.</para>

      <para>Les adresses IP sur la machine
	<application>natd</application> doivent &ecirc;tre active et
	pointer sur l'interface externe.  Consultez la page de manuel
	&man.rc.conf.5; pour cela.</para>
    </sect2>
  </sect1>

  <sect1 id="network-plip">
    <title>IP sur liaison parall&egrave;le (PLIP)</title>

    <indexterm><primary>PLIP</primary></indexterm>
    <indexterm>
      <primary>IP sur liaison parall&egrave;le</primary>
      <see>PLIP</see>
    </indexterm>

    <para>PLIP nous permet d'utiliser le protocole TCP/IP entre ports
      parall&egrave;les.  C'est utile sur des machines sans cartes
      r&eacute;seaux, ou pour effectuer une installation sur
      ordinateur portable.  Dans cette section nous aborderons:</para>

    <itemizedlist>
      <listitem>
	<para>La fabrication d'un c&acirc;ble parall&egrave;le
	  (&ldquo;laplink&rdquo;).</para>
      </listitem>

      <listitem>
	<para>La connexion de deux ordinateurs via PLIP.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Fabriquer un c&acirc;ble parall&egrave;le</title>

      <para>Vous pouvez acheter un c&acirc;ble parall&egrave;le
	aupr&egrave;s de la plupart des vendeurs de mat&eacute;riel
	informatique.  Si ce n'est pas le cas, ou d&eacute;sirez
	savoir comment est fait un tel c&acirc;ble, le tableau suivant
	montre comment en faire un &agrave; partir d'un c&acirc;ble
	parall&egrave;le d'imprimante.</para>

      <table frame="none">
	<title>C&acirc;blage d'un c&acirc;ble parall&egrave;le pour
	  r&eacute;seau</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-name</entry>

	      <entry>A-End</entry>

	      <entry>B-End</entry>

	      <entry>Descr.</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>Configurer PLIP</title>

      <para>Tout d'abord procurez-vous un c&acirc;ble
	&ldquo;laplink&rdquo;.  V&eacute;rifiez ensuite que les deux
	ordinateurs disposent d'un noyau avec le support pour le
	pilote de p&eacute;riph&eacute;rique &man.lpt.4;.</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>Le port parall&egrave;le doit fonctionner sous interruption,
	sous &os;&nbsp;4.X vous devriez avoir une ligne semblable
	&agrave; la ligne suivante dans le fichier de configuration du
	noyau:</para>

      <programlisting>device ppc0 at isa? irq 7</programlisting>

      <para>Sous &os;&nbsp;5.X, le fichier
	<filename>/boot/device.hints</filename> devrait contenir les
	lignes suivantes:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>Ensuite v&eacute;rifiez si le fichier de configuration du
	noyau contient une ligne <literal>device plip</literal>
	ou si le module <filename>plip.ko</filename> est charg&eacute;.
	Dans les deux cas l'interface r&eacute;seau parall&egrave;le
	devrait appara&icirc;tre quand vous utilisez la
	commande &man.ifconfig.8;:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>Branchez le c&acirc;ble &ldquo;laplink&rdquo; sur les
	interfaces parall&egrave;les des deux ordinateurs.</para>

      <para>Configurez les param&egrave;tres de l'interface
	r&eacute;seau des deux c&ocirc;t&eacute;s en tant que
	<username>root</username>.  Par exemple, si vous voulez
	connecter la machine <hostid>host1</hostid>
	avec la machine <hostid>host2</hostid>:</para>

      <programlisting>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Configurez l'interface sur <hostid>host1</hostid> en tapant:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Configurez l'interface sur <hostid>host2</hostid> en tapant:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>

      <para>Vous devriez avoir maintenant une connexion qui
	fonctionne.  Veuillez consulter les pages de manuel &man.lp.4;
	et &man.lpt.4; pour plus de d&eacute;tails.</para>

      <para>Vous devriez &eacute;galement ajouter les deux noms de
	machines dans le fichier
	<filename>/etc/hosts</filename>:</para>

      <programlisting>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</programlisting>

      <para>Pour v&eacute;rifier le bon fonctionnement de la connexion,
	aller sur les deux machines et effectuez un &ldquo;ping&rdquo;
	vers l'autre machine.  Par exemple, sur
	<hostid>host1</hostid>:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       plip0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>
    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Aaron</firstname>
	  <surname>Kaplan</surname>
	  <contrib>Ecrit original de </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Restructur&eacute; et ajout&eacute; par </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Brad</firstname>
	  <surname>Davis</surname>
	  <contrib>Compl&eacute;t&eacute; par </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>IPv6</title>

    <para>L'IPv6 (&eacute;galement connu sous le nom de IPng &ldquo;IP
      nouvelle g&eacute;n&eacute;ration&rdquo;) est la nouvelle
      version du tr&egrave;s c&eacute;l&egrave;bre protocole IP (aussi
      connu sous le nom d'<acronym>IPv4</acronym>).  Comme les autres
      syst&egrave;mes BSD, &os; utilise l'impl&eacute;mentation IPv6
      KAME.  Votre syst&egrave;me &os; est donc
      fourni avec tout ce dont vous aurez besoin pour tester l'IPv6.
      Cette section se concentre sur la configuration et l'utilisation
      d'IPv6.</para>

    <para>Au d&eacute;but des ann&eacute;es 90, on a pris conscience
      de la diminution rapide de l'espace d'adresses IPv4.  Etant
      donn&eacute; le taux d'expansion de l'Internet, deux
      probl&egrave;mes majeurs apparaissaient:</para>

    <itemizedlist>
      <listitem>
	<para>Le manque d'adresses.  Aujourd'hui ce n'est plus
	  vraiment un probl&egrave;me puisque les espaces d'adresses
	  priv&eacute;es RFC1918 (<hostid role="ipaddr">10.0.0.0/8</hostid>,
	  <hostid role="ipaddr">172.16.0.0/12</hostid>, et
	  <hostid role="ipaddr">192.168.0.0/16</hostid>) et la
	  translation d'adresses (<acronym>NAT</acronym>) sont
	  utilis&eacute;s.</para>
      </listitem>

      <listitem>
	<para>Les tables des routeurs devenaient trop importantes.
	  C'est toujours un probl&egrave;me actuellement.</para>
      </listitem>
    </itemizedlist>

    <para>L'IPv6 rem&eacute;die &agrave; ces probl&egrave;mes
      et &agrave; de nombreux autres:</para>

    <itemizedlist>
      <listitem>
	<para>Espace d'adressage sur 128 bits.  Ou plus
	  pr&eacute;cis&eacute;ment, il y a 340 282 366 920 938 463 463
	  374 607 431 768 211 456 adresses disponibles.  Cela
	  &eacute;quivaut &agrave; approximativement 6.67 * 10^27
	  adresses IPv6 par kilom&egrave;tre-carr&eacute; de surface de
	  notre plan&egrave;te.</para>
      </listitem>

      <listitem>
	<para>Les routeurs ne stockeront que des regroupements
	  d'adresses dans leurs tables de routage r&eacute;duisant donc
	  l'espace moyen d'une table de routage &agrave; 8192
	  entr&eacute;es.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 pr&eacute;sente &eacute;galement de nombreuses autres
      int&eacute;ressantes fonctionnalit&eacute;s telles que:</para>

    <itemizedlist>
      <listitem>
	<para>L'autoconfiguration des adresses (<ulink
	  url="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</ulink>)</para>
      </listitem>

      <listitem>
	<para>Adresses unicast (&ldquo;une parmi
	  plusieurs&rdquo;)</para>
      </listitem>

      <listitem>
	<para>Adresses multicast (multidestinataires)
	  obligatoires</para>
      </listitem>

      <listitem>
	<para>IPsec (protocole de s&eacute;curit&eacute; IP)</para>
      </listitem>

      <listitem>
	<para>Struture d'ent&ecirc;te simplifi&eacute;e</para>
      </listitem>

      <listitem>
	<para><acronym>IP</acronym> mobile</para>
      </listitem>

      <listitem>
	<para>M&eacute;canismes de transition IPv6-vers-IPv4</para>
      </listitem>
    </itemizedlist>


    <para>Pour plus d'informations consultez les
      r&eacute;f&eacute;rences suivantes:</para>

    <itemizedlist>
      <listitem>
	<para>G&eacute;n&eacute;ralit&eacute;s sur l'IPv6 &agrave;
	  <ulink url="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.6bone.net">6bone.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Les adresses IPv6</title>

      <para>Il existe diff&eacute;rent types d'adresses IPv6: unicast,
	anycast et multicast.</para>

      <para>Les adresses unicast (mono-destinataire) sont les adresses
	classiques.  Un paquet envoy&eacute; &agrave; une adresse
	unicast arrive &agrave; l'interface correspondant &agrave;
	l'adresse.</para>

      <para>Les adresses anycast ne sont normalement pas distinguables
	des adresses unicast mais correspondent &agrave; un groupe
	d'interfaces.  Un paquet destin&eacute; &agrave; une adresse
	anycast arrivera &agrave; l'interface la plus proche (en terme
	d'unit&eacute; de distance du protocole de routage).  Les
	adresses anycast devraient n'&ecirc;tre utilis&eacute;es que
	par les routeurs.</para>

      <para>Les adresses multicast identifient un groupe d'interfaces.
	Un paquet destin&eacute; &agrave; une adresse multicast
	arrivera sur toutes les interfaces appartenant au groupe
	multicast.</para>

	<note>
	  <para>L'adresse de diffusion IPv4
	    (g&eacute;n&eacute;ralement <hostid
	    role="ipaddr">xxx.xxx.xxx.255</hostid>) est exprim&eacute;e
	    par des adresses multicast en IPv6.</para>
	</note>

      <table frame="none">
	<title>Adresses IPv6 r&eacute;serv&eacute;es</title>

	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry>Adresse IPv6</entry>
	      <entry>Longueur du pr&eacute;fixe (bits)</entry>
	      <entry>Description</entry>
	      <entry>Notes</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><hostid role="ip6addr">::</hostid></entry>
	      <entry>128 bits</entry>
	      <entry>non-sp&eacute;cifi&eacute;e</entry>
	      <entry>similaire &agrave; <hostid
		role="ipaddr">0.0.0.0</hostid> sous IPv4</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">::1</hostid></entry>
	      <entry>128 bits</entry>
	      <entry>adresse de boucle</entry>
	      <entry>similaire &agrave; <hostid
		role="ipaddr">127.0.0.1</hostid> sous IPv4</entry>
	    </row>

	    <row>
	      <entry><hostid
		role="ip6addr">::00:xx:xx:xx:xx</hostid></entry>
	      <entry>96 bits</entry>
	      <entry>IPv4 encapsul&eacute;</entry>
	      <entry>Les 32 bits de poids faible sont l'adresse IPv4.
		Egalement appel&eacute;e &ldquo;adresse IPv6 compatible
		IPv4&rdquo;.</entry>
	    </row>

	    <row>
	      <entry><hostid
		role="ip6addr">::ff:xx:xx:xx:xx</hostid></entry>
	      <entry>96 bits</entry>
	      <entry>adresse IPv6 mapp&eacute;e IPv4</entry>
	      <entry>Les 32 bits de poids faible sont l'adresse IPv4.
		Destin&eacute;es aux machines ne supportant pas
		l'IPv6.</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">fe80::</hostid> - <hostid
		role="ip6addr">feb::</hostid></entry>
	      <entry>10 bits</entry>
	      <entry>lien-local</entry>
	      <entry>similaire &agrave; l'interface de boucle sous
		IPv4</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">fec0::</hostid> - <hostid
		role="ip6addr">fef::</hostid></entry>
	      <entry>10 bits</entry>
	      <entry>site-local</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">ff::</hostid></entry>
	      <entry>8 bits</entry>
	      <entry>multicast</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><hostid role="ip6addr">001</hostid> (base
		2)</entry>
	      <entry>3 bits</entry>
	      <entry>unicast globale</entry>
	      <entry>Toutes les adresses unicast globales sont
		assign&eacute;es &agrave; partir de ce pool.  Les trois
		premiers bits de l'adresse sont
		&ldquo;001&rdquo;.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2>
      <title>Lecture des adresses IPv6</title>

      <para>La forme canonique est repr&eacute;sent&eacute;e suivant
	le sch&eacute;ma: <hostid
	role="ip6addr">x:x:x:x:x:x:x:x</hostid>, o&ugrave; chaque
	&ldquo;x&rdquo; est une valeur h&eacute;xad&eacute;cimale sur
	16 bits.  Par exemple <hostid
	role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid></para>

      <para>Souvent dans une adresse on aura de longues sous-parties
	constitu&eacute;es de z&eacute;ros, une telle
	sous-partie peut &ecirc;tre abr&eacute;g&eacute;e par
	&ldquo;::&rdquo;.  Les trois <quote>0</quote>s de poids fort
	de chaque quartet hexad&eacute;cimal peuvent &eacute;galement &ecirc;tre omis.
	Par exemple <hostid
	role="ip6addr">fe80::1</hostid> correspond &agrave; la forme
	canonique <hostid
	role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid>.</para>

      <para>Une troisi&egrave;me forme est d'&eacute;crire les
	derniers 32 bits dans le style IPv4 bien connu
	(d&eacute;cimal) avec des points &ldquo;.&rdquo; comme
	s&eacute;parateurs.  Par exemple <hostid
	role="ip6addr">2002::10.0.0.1</hostid> correspond &agrave; la
	repr&eacute;sentation canonique (hexad&eacute;cimale) <hostid
	role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>
	qui est &agrave; son tour &eacute;quivalente &agrave;
	l'&eacute;criture <hostid
	role="ip6addr">2002::a00:1</hostid>.</para>

      <para>Maintenant le lecteur devrait &ecirc;tre en mesure de
	comprendre ce qui suit:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</programlisting>

      <para><hostid
	role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid> est une
	adresse de lien local configur&eacute;e automatiquement.  Elle
	est g&eacute;n&eacute;r&eacute;e &agrave; partir de l'adresse MAC dans le cas de
	l'autoconfiguration.</para>

      <para>Pour plus d'informations sur la structure des adresses
	IPv6 consultez la <ulink
	url="http://www.ietf.org/rfc/rfc3513.txt">RFC3513</ulink>.</para>
    </sect2>

    <sect2>
      <title>Se connecter</title>

      <para>Actuellement, il y a quatre fa&ccedil;ons de se connecter
	&agrave; des machines et des r&eacute;seaux utilisant
	l'IPv6:</para>

      <itemizedlist>
	<listitem>
	  <para>Rejoindre le r&eacute;seau exp&eacute;rimental
	    6bone</para>
	</listitem>

	<listitem>
	  <para>Obtenir un r&eacute;seau IPv6 aupr&egrave;s de votre
	  fournisseur d'acc&egrave;s.  Contactez votre fournisseur
	  d'acc&egrave;s Internet pour plus d'informations.</para>
	</listitem>

	<listitem>
	  <para>Utilisation d'un tunnel 6-vers-4 (<ulink
	    url="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</ulink>)</para>
	</listitem>

	<listitem>
	  <para>Utilisation du logiciel port&eacute; <filename
	    role="package">net/freenet6</filename> si vous utilisez
	    une connexion par modem.</para>
	</listitem>
      </itemizedlist>

      <para>Ici nous ne parlerons que de la mani&egrave;re de se
	connecter au r&eacute;seau 6bone puisque cela semble
	&ecirc;tre aujourd'hui la m&eacute;thode de connexion la plus
	populaire.</para>

      <para>Consultez tout d'abord le site <ulink
	url="http://www.6bone.net/">6bone</ulink> et recherchez une
	connexion 6bone proche de vous.  Contactez le responsable et
	avec un peu de chance on vous donnera les instructions
	&agrave; suivre pour configurer votre connexion.
	G&eacute;n&eacute;ralement cela implique la mise en place d'un
	tunnel GRE (gif).</para>

      <para>Voici un exemple typique de configuration d'un tunnel
	&man.gif.4;:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>MON_ADR_IPv4 MON_ADR_IPv4_ASSIGNEE_A_LAUTRE_BOUT_DU_TUNNEL</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 inet6 alias <replaceable>MON_ADR_IPv6_ASSIGNEE_A_LEXTREMITE_DU_TUNNEL MON_ADR_IPv6_ASSIGNEE_A_LAUTRE_BOUT_DU_TUNNEL</replaceable></userinput></screen>

      <para>Remplacez les mots en majuscules par les informations que
	vous avez re&ccedil;ues du point d'acc&egrave;s 6bone.</para>

      <para>Ceci &eacute;tablit le tunnel.  V&eacute;rifiez si le
	tunnel fonctionne en utilisant &man.ping6.8; sur l'adresse
	<hostid role="ip6addr">ff02::1%gif0</hostid>.  Vous devriez
	r&eacute;cevoir les r&eacute;ponses aux requ&ecirc;tes
	ping.</para>

      <note>
	<para>Au cas o&ugrave; vous seriez intrigu&eacute; par
	  l'adresse <hostid role="ip6addr">ff02:1%gif0</hostid>, sachez
	  que c'est une adresse multicast.  <literal>%gif0</literal>
	  pr&eacute;cise que l'adresse multicast de l'interface
	  <devicename>gif0</devicename> doit &ecirc;tre utilis&eacute;e.
	  Puisque nous utilisons <command>ping</command> sur une adresse
	  multicast, l'autre bout du tunnel devrait &eacute;galement
	  r&eacute;pondre.</para>
      </note>

      <para>D&eacute;sormais, la mise en place d'une route vers votre
	lien 6bone devrait &ecirc;tre relativement directe:</para>

      <screen>&prompt.root; <userinput>route add -inet6 default -interface gif0</userinput>
&prompt.root; <userinput>ping6 -n <replaceable>MON_LIEN_MONTANT</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>traceroute6 www.jp.FreeBSD.org</userinput>
(3ffe:505:2008:1:2a0:24ff:fe57:e561) from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms *
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</screen>

      <para>La sortie pourra &ecirc;tre diff&eacute;rente d'une
	machine &agrave; une autre.  Maintenant vous devriez
	&ecirc;tre en mesure d'atteindre le site IPv6 <ulink
	url="http://www.kame.net">www.kame.net</ulink> et de voir la
	tortue dansante &mdash; et cela si vous disposez d'un
	navigateur supportant l'IPv6 comme <filename
	role="package">www/mozilla</filename>,
	<application>Konqueror</application> qui fait partie du
	logiciel <filename role="package">x11/kdebase3</filename>,
	ou <filename role="package">www/epiphany</filename>.</para>
    </sect2>

    <sect2>
      <title>DNS dans le monde IPv6</title>

      <para>A l'origine, il existait deux types d'enregistrement DNS
	pour l'IPv6.  L'organisme IETF a d&eacute;clar&eacute;
	obsol&egrave;te l'enregistrement A6.  Les enregistrements AAAA
	sont aujourd'hui le standard.</para>

      <para>L'utilisation des enregistrements AAAA est assez direct.
	Assignez votre nom de machine &agrave; la nouvelle adresse
	IPv6 que vous venez d'obtenir en ajoutant:</para>

      <programlisting>MYHOSTNAME           AAAA    MYIPv6ADDR</programlisting>

      <para>&agrave; votre fichier de zone DNS primaire.  Dans le cas
	o&ugrave; vous ne g&eacute;rez pas vos propres zones
	<acronym>DNS</acronym> contactez le responsable de votre
	<acronym>DNS</acronym>.  Les versions actuelles de
	<application>bind</application> (version 8.3 et 9) et <filename role="package">dns/djbdns</filename> (avec le correctif IPv6) supportent
	les enregistrements AAAA.</para>
    </sect2>

    <sect2>
      <title>Effectuer les changements n&eacute;cessaires dans le
	fichier <filename>/etc/rc.conf</filename></title>

      <sect3>
	<title>Param&eacute;trage du client IPv6</title>

	<para>Ces param&egrave;tres vous permettront de configurer une
	  machine qui sera sur votre r&eacute;seau local et sera un
	  client, non pas un routeur.  Pour que &man.rtsol.8;
	  configure automatiquement votre interface r&eacute;seau au
	  d&eacute;marrage tout ce dont vous avez besoin d'ajouter
	  est:</para>

	<programlisting>ipv6_enable="YES"</programlisting>

	<para>Pour assigner une adresse IP statique telle que <hostid
	  role="ip6addr">2001:471:1f11:251:290:27ff:fee0:2093</hostid>,
	  &agrave; votre interface <devicename>fxp0</devicename>,
	  ajoutez:</para>

	<programlisting>ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"</programlisting>

	<para>Pour assigner le routeur par d&eacute;faut <hostid
	  role="ip6addr">2001:471:1f11:251::1</hostid>, ajoutez ce qui
	  suit au fichier <filename>/etc/rc.conf</filename>:</para>

	<programlisting>ipv6_defaultrouter="2001:471:1f11:251::1"</programlisting>
      </sect3>

      <sect3>
	<title>Param&eacute;trage d'un routeur/passerelle IPv6</title>

	<para>Ceci vous aidera &agrave; mettre en oeuvre les
	  instructions que votre fournisseur de tunnel, tel que <ulink
	  url="http://www.6bone.net/">6bone</ulink>, vous a
	  donn&eacute; et &agrave; les convertir en param&egrave;tres
	  qui seront conserv&eacute;s &agrave; chaque
	  d&eacute;marrage.  Pour r&eacute;tablir votre tunnel au
	  d&eacute;marrage, utilisez quelque chose comme ce qui suit
	  dans le fichier <filename>/etc/rc.conf</filename>:</para>

	<para>Listez les interfaces g&eacute;n&eacute;riques de tunnel
	  qui seront configur&eacute;es, par exemple
	  <devicename>gif0</devicename>:</para>

	<programlisting>gif_interfaces="gif0"</programlisting>

	<para>Pour configurer l'interface avec une adresse
	  (extr&eacute;mit&eacute;) locale
	  <replaceable>MY_IPv4_ADDR</replaceable> vers une adresse
	  (extr&eacute;mit&eacute;) distante
	  <replaceable>REMOTE_IPv4_ADDR</replaceable>:</para>

	<programlisting>gifconfig_gif0="<replaceable>MY_IPv4_ADDR REMOTE_IPv4_ADDR</replaceable>"</programlisting>

	<para>Pour utiliser l'adresse IPv6 que l'on vous a
	  assign&eacute; en vue d'&ecirc;tre utilis&eacute;e pour
	  votre extr&eacute;mit&eacute; du tunnel IPv6,
	  ajoutez:</para>

	<programlisting>ipv6_ifconfig_gif0="<replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

	<para>Ensuite tout ce qu'il reste &agrave; faire est de
	  d&eacute;finir la route par d&eacute;faut pour l'IPv6.
	  C'est l'autre extr&eacute;mit&eacute; du tunnel IPv6:</para>

	<programlisting>ipv6_defaultrouter="<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>Param&eacute;trage d'un tunnel IPv6</title>

	<para>Si le serveur doit router de l'IPv6 entre votre
	  r&eacute;seau et le reste du monde, le param&egrave;tre
	  suivant sera &eacute;galement n&eacute;cessaire dans votre
	  fichier <filename>/etc/rc.conf</filename>:</para>

	<programlisting>ipv6_gateway_enable="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Annonce du routeur et auto-configuration</title>

      <para>Cette section vous aidera &agrave; configurer
	&man.rtadvd.8; pour l'annonce de la route IPv6 par
	d&eacute;faut.</para>

      <para>Pour activer &man.rtadvd.8;, vous devrez ajouter ce qui
	suit &agrave; votre fichier
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Il est important que vous indiquiez l'interface sur
	laquelle le routeur IPv6 sera sollicit&eacute;.  Par exemple
	pour que &man.rtadvd.8; utilise
	<devicename>fxp0</devicename>:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Nous devons maintenant cr&eacute;er le fichier de
	configuration <filename>/etc/rtadvd.conf</filename>.  Voici un
	exemple:</para>

      <programlisting>fxp0:\
	:addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Remplacez <devicename>fxp0</devicename> avec l'interface
	que vous allez utiliser.</para>

      <para>Ensuite remplacez <hostid
	role="ip6addr">2001:471:1f11:246::</hostid> avec votre
	pr&eacute;fixe.</para>

      <para>Si vous &ecirc;tes un sous-r&eacute;seau <hostid
	role="netmask">/64</hostid> d&eacute;di&eacute;, il ne sera
	pas n&eacute;cessaire de modifier quelque chose d'autre.
	Sinon, vous devrez modifier <literal>prefixlen#</literal> avec
	la valeur correcte.</para>
   </sect2>
  </sect1>

  <sect1 id="network-atm">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Harti</firstname>
	  <surname>Brandt</surname>
	  <contrib>Contribution de </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>ATM (<quote>Asynchronous Transfer Mode</quote>)</title>

    <sect2>
      <title>Configuration IP conventionnelle sur ATM (PVCs)</title>

      <para>L'IP conventionnelle sur ATM (&ldquo;Classical IP over
	ATM&rdquo;&mdash;<acronym>CLIP</acronym>) est la
	m&eacute;thode la plus simple pour utiliser ATM
	(Asynchronous Transfer Mode) avec l'IP.
	Elle peut &ecirc;tre utilis&eacute;e en mode non
	connect&eacute; (&ldquo;Switched Virtual
	Connections&rdquo;&mdash;SVCs) et en mode connect&eacute;
	(&ldquo;Permanent Virtual Connections&rdquo;&mdash;PVCs).
	Cette section d&eacute;crit comment configurer un
	r&eacute;seau bas&eacute; sur les PVCs.</para>

      <sect3>
	<title>Configurations en r&eacute;seau maill&eacute;</title>

	<para>La premi&egrave;re m&eacute;thode de configuration
	  <acronym>CLIP</acronym> avec des PVCs est de connecter entre
	  elles chaque machine du r&eacute;seau par
	  l'interm&eacute;diaire d'une PVC d&eacute;di&eacute;e.  Bien
	  que cela soit simple &agrave; configurer, cela tend &agrave;
	  devenir impraticable avec un nombre important de machines.
	  Notre exemple suppose que nous avons quatre machines sur le
	  r&eacute;seau, chacune connect&eacute;e au r&eacute;seau
	  <acronym role="Asynchronous Transfer Mode">ATM</acronym>
	  &agrave; l'aide d'une carte r&eacute;seau <acronym
	  role="Asynchronous Transfer Mode">ATM</acronym>.  La
	  premi&egrave;re &eacute;tape est d'&eacute;tablir le plan
	  des adresses IP et des connexions <acronym
	  role="Asynchronous Transfer Mode">ATM</acronym> entre machines.  Nous
	  utilisons le plan suivant:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>Machine</entry>
		<entry>Adresse IP</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.1</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.2</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.3</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostD</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.4</hostid></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Pour r&eacute;aliser un r&eacute;seau maill&eacute;,
	  nous avons besoin d'une connexion ATM entre chaque paire de
	  machines:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>Machines</entry>
		<entry>Couple VPI.VCI</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostB</hostid></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Les valeurs VPI et VCI &agrave; chaque
	  extr&eacute;mit&eacute; de la connexion peuvent bien
	  &eacute;videmment &ecirc;tre diff&eacute;rentes, mais par
	  souci de simplicit&eacute; nous supposerons quelles sont
	  identiques.  Ensuite nous devons configurer les interfaces
	  ATM sur chaque machine:</para>

	<screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

	<para>en supposant que l'interface ATM est
	  <devicename>hatm0</devicename> sur toutes les machines.
	  Maintenant les PVCs doivent &ecirc;tre configur&eacute;es
	  sur <hostid>hostA</hostid> (nous supposons qu'elles sont
	  d&eacute;j&agrave; configur&eacute;es sur les switches ATM,
	  vous devez consulter le manuel du switch sur comment
	  r&eacute;aliser cette configuration).</para>

	<screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

	<para>Bien &eacute;videmment des contrats de trafic autres
	  qu'UBR (&ldquo;Unspecified Bit Rate&rdquo;) peuvent
	  &ecirc;tre utilis&eacute;s d&egrave;s que la carte ATM les
	  supportent.  Dans ce cas le nom du contrat de trafic est
	  suivi par les param&egrave;tres du trafic.  De l'aide
	  concernant l'outil &man.atmconfig.8; peut &ecirc;tre obtenue
	  avec:</para>

	<screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

	<para>ou dans la page de manuel de &man.atmconfig.8;.</para>

	<para>La m&ecirc;me configuration peut &ecirc;tre faite par
	  l'interm&eacute;diaire de <filename>/etc/rc.conf</filename>.
	  Pour la machine <hostid>hostA</hostid> cela ressemblerait
	  &agrave;:</para>

<programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

	<para>L'&eacute;tat de toutes les routes
	  <acronym>CLIP</acronym> peut &ecirc;tre obtenu avec:</para>

	<screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
<!--  LocalWords:  config mnt www -->
