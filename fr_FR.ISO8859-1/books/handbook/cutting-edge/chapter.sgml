<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.235
-->

<chapter id="updating-upgrading">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Restructur&eacute;, r&eacute;organis&eacute;, et en partie mis
	  &agrave; jour par </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Travail original de </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
  </chapterinfo>

  <title>Mise &agrave; jour de &os;</title>
  &trans.a.fonvieille;

  <sect1 id="updating-upgrading-synopsis">
    <title>Synopsis</title>

    <para>&os; est en constant d&eacute;veloppement entre deux
      versions.
      Certains utilisateurs pr&eacute;f&egrave;rent utiliser les
      versions publi&eacute;es officiellement alors que d'autres
      voudront rester &agrave; jour avec les tous derniers
      d&eacute;veloppements.  M&ecirc;mes les versions officielles
      sont souvent mises &agrave; jour avec les correctifs de
      probl&egrave;mes critiques et de s&eacute;curit&eacute;.
      Ind&eacute;pendamment de la version utilis&eacute;e, &os;
      fournit tous les outils n&eacute;cessaires &agrave; la mise
      &agrave; jour de votre syst&egrave;me, et permet
      &eacute;galement des mises &agrave; jour ais&eacute;es entre
      versions.
      Ce chapitre vous aidera &agrave;
      d&eacute;cider si vous voulez suivre les d&eacute;veloppements, ou vous
      en tenir aux versions publi&eacute;es.  Les outils de base pour
      le maintien &agrave; jour de votre syst&egrave;me seront
      &eacute;galement pr&eacute;sent&eacute;s.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous
      conna&icirc;trez:</para>

    <itemizedlist>
      <listitem>
	<para>Quels utilitaires peuvent &ecirc;tre employ&eacute;s
	  pour mettre &agrave; jour le syst&egrave;me et le catalogue
	  des logiciels port&eacute;s.</para>
      </listitem>

      <listitem><para>Comment maintenir votre syst&egrave;me &agrave;
	jour avec <application>freebsd-update</application>,
	<application>CVSup</application>,
	<application>CVS</application>, ou
	<application>CTM</application>.</para>
      </listitem>

      <listitem>
	<para>Comment comparer l'&eacute;tat d'un syst&egrave;me
	  install&eacute; avec une copie de confiance.</para>
      </listitem>

      <listitem>
	<para>La diff&eacute;rence entre les deux branches de
	  d&eacute;veloppement: &os.stable; et &os.current;.</para>
      </listitem>

      <listitem><para>Comment recompiler et r&eacute;installer
	l'int&eacute;gralit&eacute; du syst&egrave;me de base avec
	la commande <command>make buildworld</command> (etc.).</para>
      </listitem>

    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem><para>Correctement configurer votre connexion
	r&eacute;seau (<xref linkend="advanced-networking">).</para>
      </listitem>
      <listitem><para>Savoir comment installer des logiciels
	tiers (<xref linkend="ports">).</para></listitem>
    </itemizedlist>

    <note>
      <para>Tout au long de ce chapitre, la commande
	<command>cvsup</command> sera utilis&eacute;e pour
	r&eacute;cup&eacute;rer et mettre &agrave; jour les sources de
	&os;.  Pour l'utiliser, vous devrez installer un logiciel
	port&eacute; ou pr&eacute;-compil&eacute; tel que <filename
	role="package">net/cvsup-without-gui</filename>.  Si vous
	utilisez &os;&nbsp;6.2-RELEASE ou une version
	ult&eacute;rieure, vous pouvez remplacer cette commande par
	&man.csup.1;, qui fait d&eacute;sormais partie du
	syst&egrave;me de base.</para>
    </note>
  </sect1>

  <sect1 id="updating-upgrading-freebsdupdate">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Ecrit par </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Colin</firstname>
	  <surname>Percival</surname>
	  <contrib>Bas&eacute; sur des notes de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Mise &agrave; jour de FreeBSD</title>

    <indexterm><primary>Mise &agrave; jour</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>mise &agrave; jour</see>
    </indexterm>

    <para>Appliquer des correctifs de s&eacute;curit&eacute; est une
      part importante de la maintenance de logiciels informatiques
      tout particuli&egrave;rement dans le cas du syst&egrave;me
      d'exploitation.  Pendant tr&egrave;s longtemps sous &os;, ce
      processus n'&eacute;tait pas ais&eacute;.  Les correctifs
      devaient &ecirc;tre appliqu&eacute;s au code source, le code
      ensuite recompil&eacute; sous forme de binaires, et enfin les
      binaires devaient &ecirc;tre r&eacute;-install&eacute;s.</para>

    <para>Ce processus n'est plus de mise comme &os; dispose
      d&eacute;sormais d'un utilitaire appel&eacute; simplement
      <command>freebsd-update</command>.  Cet utilitaire fournit deux
      fonctions distinctes.  Tout d'abord, il permet l'application de
      mises &agrave; jour de correction et de s&eacute;curit&eacute;
      sur le syst&egrave;me de base de &os; sans n&eacute;cessiter une
      compilation et une r&eacute;-installation.  En second lieu,
      l'utilitaire supporte les mises &agrave; jour mineures et
      majeures des versions publi&eacute;es.</para>

    <note>
      <para>Les mise &agrave; jour binaires sont disponibles pour
	toutes les architectures actuellement support&eacute;es par
	l'&eacute;quipe de s&eacute;curit&eacute;.  Avant de mettre
	&agrave; jour vers une nouvelle version, les annonces
	concernant la version devront &ecirc;tre pass&eacute;es en
	revue sachant qu'elles peuvent contenir des informations
	importantes au sujet de cette version.  Ces annonces peuvent
	&ecirc;tre consult&eacute;es &agrave; l'adresse suivante:
	<ulink url="http://www.FreeBSD.org/releases/"></ulink>.</para>
    </note>

    <para>S'il existe une table <command>crontab</command> utilisant
      <command>freebsd-update</command>, elle doit &ecirc;tre
      d&eacute;sactiv&eacute;e avant de d&eacute;marrer les
      op&eacute;rations qui vont suivre.</para>

    <sect2 id="freebsdupdate-config-file">
      <title>Le fichier de configuration</title>

      <para>Certains utilisateurs peuvent souhaiter adapter le fichier
	de configuration par d&eacute;faut
	<filename>/etc/freebsd-update.conf</filename>, permettant un
	meilleur contr&ocirc;le du processus.  Les options sont
	tr&egrave;s bien document&eacute;es, mais les suivantes
	demandent un peu plus d'explication:</para>

      <programlisting># Composants du syst&egrave;me de base qui doivent &ecirc;tre maintenus &agrave; jour.
Components src world kernel</programlisting>

      <para>Ce param&egrave;tre contr&ocirc;le quelles sont les
	parties de &os; qui seront mises &agrave; jour.  Par
	d&eacute;faut on met &agrave; jour le code source,
	l'int&eacute;gralit&eacute; du syst&egrave;me de base et le
	noyau.  Les composants sont les m&ecirc;mes que ceux
	disponibles durant l'installation, par exemple, ajouter
	<literal>world/games</literal> ici permettrait d'appliquer les
	correctifs relatifs aux jeux.  Utiliser
	<literal>src/bin</literal> permettrait la mise &agrave; jour
	du code source du r&eacute;pertoire <filename
	class="directory">src/bin</filename>.</para>

      <para>La meilleure option est de laisser telle quelle la
	configuration par d&eacute;faut car la modifier pour ajouter
	des &eacute;l&eacute;ments particuliers demandera &agrave;
	l'utilisateur de lister chaque &eacute;l&eacute;ment qu'il
	d&eacute;sire mettre &agrave; jour.  Cela pourrait avoir des
	cons&eacute;quences d&eacute;sastreuses puisque le code source
	et les binaires peuvent &agrave; terme ne plus &ecirc;tre en
	phase.</para>

      <programlisting># Les chemins d'acc&egrave;s commen&ccedil;ant par quelque chose correspondant &agrave; une
# entr&eacute;e de type IgnorePaths seront ignor&eacute;s.
IgnorePaths</programlisting>

      <para>Ajoute les chemins d'acc&egrave;s comme <filename
	class="directory">/bin</filename> ou <filename
	class="directory">/sbin</filename> pour pr&eacute;server
	intacts ces r&eacute;pertoires durant le processus de mise
	&agrave; jour.  Cette option peut &ecirc;tre utilis&eacute;e
	pour emp&ecirc;cher <command>freebsd-update</command>
	d'&eacute;craser des modifications locales.</para>

      <programlisting># Les chemins d'acc&egrave;s qui commencent par quelque chose correspondant &agrave;
# une entr&eacute;e de type UpdateIfUnmodified seront mis &agrave; jour que si le
# contenu du fichier n'a pas &eacute;t&eacute; modifi&eacute; par l'utilisateur (&agrave; moins
# que les modifications ne soient fusionn&eacute;es; voir plus bas).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Met &agrave; jour les fichiers de configuration dans les
	r&eacute;pertoires d&eacute;sign&eacute;s seulement s'ils
	n'ont pas &eacute;t&eacute; modifi&eacute;s.  Tout changement
	effectu&eacute; par l'utilisateur invalidera automatiquement
	la mise &agrave; jour de ces fichiers.  Il existe une autre
	option <literal>KeepModifiedMetadata</literal> qui indiquera
	&agrave; <command>freebsd-update</command> de sauvegarder les
	changements durant la fusion.</para>

      <programlisting># Quand on met &agrave; jour vers une nouvelle version de &os;, les fichiers
# correspondant &agrave; une entr&eacute;e de type MergeChanges verront leurs
# diff&eacute;rences locales fusionn&eacute;es avec le fichier de la nouvelle
# version de &os;.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Liste des r&eacute;pertoires avec des fichiers de
	configuration que <command>freebsd-update</command> devrait
	tenter de fusionner.  Le processus de fusion des fichiers est
	l'application d'une s&eacute;rie de correctifs &man.diff.1;
	similaires &agrave; ceux de &man.mergemaster.8; avec cependant
	moins d'options, les fusions sont soit accept&eacute;es,
	ouvrant un &eacute;diteur, soit abandonn&eacute;es par
	<command>freebsd-update</command>.  En cas de doute,
	sauvegardez <filename class="directory">/etc</filename> et
	acceptez les fusions.  Consultez la section sur <xref
	linkend="mergemaster"> pour plus d'information sur la commande
	<command>mergemaster</command>.</para>

      <programlisting># R&eacute;pertoire dans lequel stocker les mise &agrave; jour t&eacute;l&eacute;charg&eacute;es et les
# fichiers temporaires utilis&eacute;s par la mise &agrave; jour de &os;.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>Ce r&eacute;pertoire est l'endroit o&ugrave; tous les
	correctifs et les fichiers temporaires seront plac&eacute;s.
	Dans les cas o&ugrave; l'utilisateur effectue une mise
	&agrave; jour de version, cet emplacement doit disposer d'au
	moins un gigaoctet d'espace disponible.</para>

      <programlisting># Lors de mises &agrave; jour entre versions de &os;, doit-on lire la liste
# de composants de mani&egrave;re stricte (StrictComponents yes)
# ou tout simplement comme une liste de composants qui *pourraient*
# &ecirc;tre install&eacute;s et pour lesquels la mise &agrave; jour de &os; devrait
# d&eacute;terminer lesquels sont effectivement install&eacute;s et les mettre &agrave;
# jour (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Cette option fix&eacute;e &agrave; <literal>yes</literal>,
	<command>freebsd-update</command> supposera que la liste de
	composants est compl&egrave;te et n'essaiera pas d'effectuer
	des modifications en dehors de cette liste.
	Concr&egrave;tement, <command>freebsd-update</command> tentera
	de mettre &agrave; jour chaque fichier appartenant &agrave; la
	liste de composants.</para>
    </sect2>

    <sect2 id="freebsdupdate-security-patches">
      <title>Correctifs de s&eacute;curit&eacute;</title>

      <para>Les correctifs de s&eacute;curit&eacute; sont
	stock&eacute;s sur une machine distante et peuvent &ecirc;tre
	t&eacute;l&eacute;charg&eacute;s et install&eacute;s en
	utilisant la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Si des correctifs ont &eacute;t&eacute; appliqu&eacute;s
	au noyau le syst&egrave;me devra &ecirc;tre
	red&eacute;marr&eacute;.  Si tout c'est bien pass&eacute; le
	syst&egrave;me est corrig&eacute; et
	<command>freebsd-update</command> pourra &ecirc;tre
	ex&eacute;cut&eacute; chaque nuit via un processus
	&man.cron.8;.  Une entr&eacute;e dans le fichier
	<filename>/etc/crontab</filename> devrait &ecirc;tre
	suffisante pour accomplir cette t&acirc;che:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Cette entr&eacute;e indique qu'une fois par jour,
	l'utilitaire <command>freebsd-update</command> sera
	ex&eacute;cut&eacute;.  De cette mani&egrave;re, en employant
	l'option <option>cron</option>,
	<command>freebsd-update</command> v&eacute;rifiera seulement
	l'existence de mises &agrave; jour.  Si des correctifs
	existent, il seront automatiquement
	t&eacute;l&eacute;charg&eacute;s sur le disque local mais
	non-appliqu&eacute;s.  L'utilisateur <username>root</username>
	sera contact&eacute; par courrier &eacute;lectronique, il
	pourra ainsi les installer manuellement.</para>

      <para>Si quelque s'est mal pass&eacute;,
	<command>freebsd-update</command> a la capacit&eacute;
	d'annuler le dernier ensemble de changements avec la commande
	suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Une fois la commande achev&eacute;e, le syst&egrave;me
	devra &ecirc;tre red&eacute;marr&eacute; si le noyau ou un de
	ses modules ont &eacute;t&eacute; modifi&eacute;s.  Cela
	permettra &agrave; &os; de charger en m&eacute;moire les
	nouveaux binaires.</para>

      <para>L'utilitaire <command>freebsd-update</command> peut mettre
	&agrave; jour uniquement et automatiquement le noyau
	<literal>GENERIC</literal>.  Si un noyau personnalis&eacute;
	est utilis&eacute;, il devra &ecirc;tre recompil&eacute; et
	r&eacute;install&eacute; apr&egrave;s que la commande
	<command>freebsd-update</command> ait achev&eacute;
	l'installation du reste des mises &agrave; jour.  Cependant
	<command>freebsd-update</command> d&eacute;tectera et mettra
	&agrave; jour le noyau <literal>GENERIC</literal> dans
	<filename class="directory">/boot/GENERIC</filename> (s'il
	existe), et cela m&ecirc;me si ce n'est pas le noyau actuel
	(qui tourne) du syst&egrave;me.</para>

      <note>
	<para>C'est toujours une bonne id&eacute;e de conserver une
	  copie du noyau <literal>GENERIC</literal> dans <filename
	  class="directory">/boot/GENERIC</filename>.  Cela sera utile
	  pour diagnostiquer une vari&eacute;t&eacute; de
	  probl&egrave;mes, et lors des mises &agrave; jour utilisant
	  <command>freebsd-update</command> comme d&eacute;crit dans
	  la <xref linkend="freebsdupdate-upgrade">.</para>
      </note>

      <para>A moins que la configuration par d&eacute;faut
	pr&eacute;sente dans
	<filename>/etc/freebsd-update.conf</filename> n'ait
	&eacute;t&eacute; modifi&eacute;e,
	<command>freebsd-update</command> installera les sources du
	noyau mises &agrave; jour avec le reste des mises &agrave;
	jour.  La recompilation et la r&eacute;installation d'un noyau
	personnalis&eacute; peuvent effectu&eacute;es de la
	mani&egrave;re classique.</para>

      <note>
	<para>Les mises &agrave; jour distribu&eacute;es via
	  <command>freebsd-update</command>, n'impliquent pas toujours
	  le noyau.  Il ne sera pas n&eacute;cessaire de recompiler
	  votre noyau personnalis&eacute; si les sources du noyau
	  n'ont pas &eacute;t&eacute; modifi&eacute;es par
	  l'ex&eacute;cution de <command>freebsd-update
	  install</command>.  Cependant
	  <command>freebsd-update</command> met toujours &agrave; jour
	  le fichier
	  <filename>/usr/src/sys/conf/newvers.sh</filename>.  Le
	  niveau ou la version de correctifs (comme indiqu&eacute; par
	  le nombre <literal>-p</literal> rapport&eacute; par
	  <command>uname -r</command>) est obtenu &agrave; partir de
	  ce fichier.  Recompiler votre noyau personnalis&eacute;,
	  m&ecirc;me si rien d'autre n'a chang&eacute;, permettra
	  &agrave; la commande &man.uname.1; de rapporter
	  pr&eacute;cis&eacute;ment le niveau de correctifs du
	  syst&egrave;me.  C'est particuli&egrave;rement utile quand
	  on g&egrave;re de multiples syst&egrave;mes, car cela permet
	  une &eacute;valuation rapide des mises &agrave; jour
	  pr&eacute;sentes sur chacun d'eux.</para>
      </note>
    </sect2>

    <sect2 id="freebsdupdate-upgrade">
      <title>Mises &agrave; jour mineures et majeures</title>

      <para>Ce processus supprimera les anciens fichiers objets et
	biblioth&egrave;ques qui rendent inutilisables la plupart des
	applications tierce-partie.  Il est recommand&eacute; que tous
	les logiciels port&eacute;s soient supprim&eacute;s et
	r&eacute;install&eacute;s ou mis &agrave; jour
	ult&eacute;rieurement en utilisant l'outil <filename
	role="package">ports-mgmt/portupgrade</filename>.  La plupart
	des utilisateurs voudront lancer une compilation test &agrave;
	l'aide de la commande suivante:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Cela garantira que tout sera r&eacute;install&eacute;
	correctement.  Notez que fixer la variable d'environnement
	<makevar>BATCH</makevar> &agrave; <literal>yes</literal>
	r&eacute;pondra <literal>yes</literal> &agrave; toute question
	lors de ce processus, supprimant ainsi la
	n&eacute;cessit&eacute; d'une intervention humaine durant le
	processus de compilation.</para>

      <para>Si un noyau personnalis&eacute; est utilis&eacute;, le
	processus de mise &agrave; jour est un peu plus complexe.  Une
	copie du noyau <literal>GENERIC</literal> est
	n&eacute;cessaire et devrait &ecirc;tre plac&eacute;e dans le
	r&eacute;pertoire <filename
	class="directory">/boot/GENERIC</filename>.  Si le noyau
	<literal>GENERIC</literal> n'est pas pr&eacute;sent sur le
	syst&egrave;me, il peut &ecirc;tre obtenu en utilisant une des
	m&eacute;thodes suivantes:</para>

      <itemizedlist>
	<listitem>
	  <para>Si un noyau personnalis&eacute; a d&eacute;j&agrave;
	    &eacute;t&eacute; compil&eacute;, le noyau pr&eacute;sent
	    dans <filename
	    class="directory">/boot/kernel.old</filename> est en fait
	    le noyau <literal>GENERIC</literal>.  Renommer ce
	    r&eacute;pertoire en <filename
	    class="directory">/boot/GENERIC</filename>.</para>
	</listitem>

	<listitem>
	  <para>En supposant qu'un acc&egrave;s physique &agrave; la
	    machine est possible, une copie du noyau
	    <literal>GENERIC</literal> peut &ecirc;tre install&eacute;
	    &agrave; partir d'un CD-ROM.  Ins&eacute;rer votre disque
	    d'installation et utiliser les commandes suivantes:</para>

	  <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/<replaceable>X.Y-RELEASE</replaceable>/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	  <para>Remplacer <filename
	    class="directory"><replaceable>X.Y-RELEASE</replaceable></filename>
	    avec la version que vous utilisez.  Le noyau
	    <literal>GENERIC</literal> sera install&eacute; par
	    d&eacute;faut dans <filename
	    class="directory">/boot/GENERIC</filename>.</para>
	</listitem>

	<listitem>
	  <para>En dehors de ce qui pr&eacute;c&egrave;de le noyau
	    <literal>GENERIC</literal> peut &ecirc;tre
	    recompil&eacute; et install&eacute; &agrave; partir des
	    sources:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	  <para>Pour que ce noyau soit pris en compte comme
	    <literal>GENERIC</literal> par
	    <command>freebsd-update</command>, le fichier de
	    configuration <literal>GENERIC</literal> devra ne pas
	    avoir &eacute;t&eacute; modifi&eacute;.  Il est
	    &eacute;galement sugg&eacute;r&eacute; qu'il soit
	    compil&eacute; sans aucune option particuli&egrave;re (de
	    pr&eacute;f&eacute;rence avec un fichier
	    <filename>/etc/make.conf</filename> vide).</para>
	</listitem>
      </itemizedlist>

      <para>Red&eacute;marrer avec le noyau <literal>GENERIC</literal>
	n'est pas n&eacute;cessaire &agrave; ce stade.</para>

      <para>Les mises &agrave; jour de versions majeures et mineures
	peuvent &ecirc;tre effectu&eacute;es en passant &agrave; la
	commande <command>freebsd-update</command> la version vers
	laquelle on d&eacute;sire mettre &agrave; jour, par exemple,
	la commande suivante effectuera la mise &agrave; jour vers
	&os;&nbsp;8.1:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 8.1-RELEASE upgrade</userinput></screen>

      <para>La commande <command>freebsd-update</command> analysera le
	fichier de configuration et le syst&egrave;me afin de
	r&eacute;cup&eacute;rer les informations n&eacute;cessaires
	&agrave; la mise &agrave; jour du syst&egrave;me.  A
	l'&eacute;cran s'affichera quels sont les composants
	d&eacute;tect&eacute;s et quels sont ceux qui n'ont pas
	&eacute;t&eacute; d&eacute;tect&eacute;s.  Par exemple:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 8.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>A ce niveau <command>freebsd-update</command> tentera de
	t&eacute;l&eacute;charger tous les fichiers n&eacute;cessaires
	&agrave; la mise &agrave; jour.  Dans certains cas
	l'utilisateur sera interrog&eacute; sur ce qu'il faut
	installer ou sur comment proc&eacute;der &agrave; certaines
	actions.</para>

      <para>Si un noyau personnalis&eacute; est utilis&eacute;,
	l'&eacute;tape pr&eacute;c&eacute;dente produira un
	avertissement semblable au suivant:</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Cet avertissement peut sans risque &ecirc;tre
	ignor&eacute; &agrave; ce niveau.  Le noyau
	<filename>GENERIC</filename> mis &agrave; jour sera
	utilis&eacute; comme une &eacute;tape interm&eacute;diaire
	dans le processus de mise &agrave; jour.</para>

      <para>Une fois l'ensemble des correctifs
	t&eacute;l&eacute;charg&eacute; sur le syst&egrave;me local,
	ils seront appliqu&eacute;s.  Ce processus peut prendre plus
	ou moins de temps en fonction de la vitesse et de la charge de
	la machine.  Les fichiers de configuration seront
	fusionn&eacute;s&nbsp;&mdash; cette partie du processus
	demande l'intervention de l'utilisateur car un fichier peut
	&ecirc;tre automatiquement fusionn&eacute; ou en cas de besoin
	un &eacute;diteur peut appara&icirc;tre sur l'&eacute;cran
	pour une fusion manuelle.  Les r&eacute;sultats des fusions
	r&eacute;ussies seront affich&eacute;s au fur et &agrave;
	mesure que se d&eacute;roule l'op&eacute;ration.  Un
	&eacute;chec ou une fusion ignor&eacute;e provoqueront
	l'arr&ecirc;t du processus.  Certains utilisateurs peuvent
	vouloir conserver une sauvegarde du r&eacute;pertoire
	<filename class="directory">/etc</filename> et fusionner plus
	tard &agrave; la main les fichiers importants comme
	<filename>master.passwd</filename> ou
	<filename>group</filename>.<para>

      <note>
	<para>Le syst&egrave;me n'a pas encore &eacute;t&eacute;
	  r&eacute;ellement modifi&eacute;, les fusions et
	  l'application des correctifs ont lieu dans un autre
	  r&eacute;pertoire.  Quand tous les correctifs ont
	  &eacute;t&eacute; appliqu&eacute;s avec succ&egrave;s, que
	  tous les fichiers de configuration ont &eacute;t&eacute;
	  fusionn&eacute;s et que le processus s'est
	  d&eacute;roul&eacute; sans probl&egrave;me, les
	  modifications devront &ecirc;tre appliqu&eacute;es
	  d&eacute;finitivement au syst&egrave;me par
	  l'utilisateur.</para>
      </note>

      <para>Une fois les op&eacute;rations pr&eacute;c&eacute;dentes
	achev&eacute;es, la mise &agrave; jour peut &ecirc;tre
	appliqu&eacute;e en utilisant la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Le noyau et les modules seront corrig&eacute;s les
	premiers.  A ce moment la machine doit &ecirc;tre
	obligatoirement red&eacute;marr&eacute;e.  Si le
	syst&egrave;me utilisait un noyau personnalis&eacute;,
	utiliser la commande &man.nextboot.8; pour indiquer le noyau
	<filename class="directory">/boot/GENERIC</filename> (qui a
	&eacute;t&eacute; mis &agrave; jour) pour le prochain
	d&eacute;marrage:</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>Avant de red&eacute;marrer sur le noyau
	  <literal>GENERIC</literal>, assurez-vous qu'il contient tous
	  les pilotes n&eacute;cessaires pour que votre syst&egrave;me
	  d&eacute;marre correctement (et se connecte au
	  r&eacute;seau, si la mise &agrave; jour de la machine se
	  fait &agrave; distance).  En particulier, si le noyau
	  pr&eacute;c&eacute;demment utilis&eacute; contient des
	  fonctions g&eacute;n&eacute;ralement fournies par des
	  modules, faites en sorte de charger temporairement ces
	  modules avec le noyau <filename>GENERIC</filename> &agrave;
	  l'aide de <filename>/boot/loader.conf</filename>.  Vous
	  pouvez &eacute;galement avoir int&eacute;r&ecirc;t &agrave;
	  d&eacute;sactiver les services non-indispensables, les
	  montages r&eacute;seaux ou disques, etc.  avant que le
	  processus de mise &agrave; jour ne soit
	  achev&eacute;.</para>
      </warning>

      <para>La machine doit maintenant &ecirc;tre
	red&eacute;marr&eacute;e avec le noyau mis &agrave;
	jour:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Une fois la machine de nouveau active,
	<command>freebsd-update</command> devra &ecirc;tre
	lanc&eacute;e &agrave; nouveau.  L'&eacute;tat du processus de
	mise &agrave; jour a &eacute;t&eacute; sauvegard&eacute;, et
	donc <command>freebsd-update</command> ne recommencera pas au
	d&eacute;but, mais supprimera les anciens fichiers objet et
	biblioth&egrave;ques partag&eacute;es.  Afin de poursuivre les
	op&eacute;rations, taper la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>En fonction d'un changement ou non de
	  num&eacute;rotation d'une ou plusieurs biblioth&egrave;ques,
	  il pourra y avoir deux phases d'installation au lieu de
	  trois.</para>
      </note>

      <para>Tous les logiciels tierce-partie doivent &ecirc;tre
	maintenant recompil&eacute;s et r&eacute;install&eacute;s.
	Cela est n&eacute;cessaire comme certains logiciels peuvent
	d&eacute;pendre de biblioth&egrave;ques qui ont
	&eacute;t&eacute; supprim&eacute;es lors du processus de mise
	&agrave; jour.  La commande <filename
	role="package">ports-mgmt/portupgrade</filename> peut
	&ecirc;tre employ&eacute;e pour automatiser la chose.  Les
	commandes suivantes peuvent &ecirc;tre utilis&eacute;es pour
	initier le processus:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Une fois cela effectu&eacute;, terminer le processus de
	mise &agrave; jour avec un dernier appel &agrave;
	<command>freebsd-update</command>.  Taper la commande suivante
	pour r&eacute;gler les derniers d&eacute;tails:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Si le noyau <literal>GENERIC</literal> a &eacute;t&eacute;
	utilis&eacute; temporairement, il est temps de compiler et
	d'installer un nouveau noyau personnalis&eacute; suivant la
	m&eacute;thode habituelle.</para>

      <para>Red&eacute;marrer la machine avec la nouvelle version de
	&os;.  Le processus de mise &agrave; jour est
	termin&eacute;.</para>
    </sect2>

    <sect2 id="freebsdupdate-system-comparison">
      <title>Comparaison de l'&eacute;tat du syst&egrave;me</title>

      <para>L'utilitaire <command>freebsd-update</command> peut
	&ecirc;tre utilis&eacute; pour comparer l'&eacute;tat du
	syst&egrave;me &os; install&eacute; avec une copie de
	confiance.  Cette fonctionnalit&eacute; inspecte la version
	actuelle des utilitaires syst&egrave;me, des
	biblioth&egrave;ques et des fichiers de configuration.  Pour
	lancer la comparaison, utiliser la commande suivante:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
	<para>Bien que le nom de la commande soit
	  <acronym>IDS</acronym>, elle ne devrait en aucun cas
	  &ecirc;tre consid&eacute;r&eacute;e comme un syst&egrave;me
	  de d&eacute;tection d'intrusion du type de <filename
	  role="package">security/snort</filename>.  Etant
	  donn&eacute; que <command>freebsd-update</command> stocke
	  des donn&eacute;es sur le disque, le risque de modification
	  des donn&eacute;es est &eacute;vident.  Alors que cette
	  possibilit&eacute; peut &ecirc;tre minimis&eacute;e en
	  utilisant le param&eacute;trage
	  <varname>kern.securelevel</varname> et en stockant les
	  donn&eacute;es <command>freebsd-update</command> sur un
	  syst&egrave;me de fichiers en lecture seule quand elles ne
	  sont pas utilis&eacute;es, une bien meilleure solution
	  serait de comparer le syst&egrave;me avec un disque
	  s&eacute;curis&eacute; comme un <acronym>DVD</acronym> ou un
	  disque <acronym>USB</acronym> conserv&eacute; &agrave;
	  l'ext&eacute;rieur.</para>
      </warning>

      <para>Le syst&egrave;me sera analys&eacute;, et une liste de
	fichiers ainsi que la valeur de leur empreinte
	num&eacute;rique &man.sha256.1;, celle de la version d'origine
	et celle de la version actuellement install&eacute;e, seront
	affich&eacute;s.  C'est pour cela que cet affichage est
	copi&eacute; dans le fichier <filename>outfile.ids</filename>.
	L'affichage d&eacute;file trop rapidement une comparaison
	visuelle et remplira rapidement le tampon de la
	console.</para>

      <para>Ces lignes sont &eacute;galement tr&egrave;s longues mais
	le format de sortie peut &ecirc;tre facilement pass&eacute;
	par une analyse syntaxique.  Par exemple, pour obtenir une
	liste des fichiers qui diff&egrave;rent avec ceux de la
	version d'origine, utiliser la commande suivante:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>La sortie de cette commande a &eacute;t&eacute;
	tronqu&eacute;e, bien plus de fichiers sont concern&eacute;s.
	Certains de ces fichiers sont naturellement modifi&eacute;s,
	le fichier <filename>/etc/passwd</filename> a
	&eacute;t&eacute; modifi&eacute; en raison de l'ajout
	d'utilisateurs au syst&egrave;me.  Dans certains cas, d'autres
	fichiers appara&icirc;trons, comme les modules du noyau, qui
	diff&egrave;rent puisque <command>freebsd-update</command>
	peut les avoir mis &agrave; jour.  Pour exclure des fichiers
	ou des r&eacute;pertoires sp&eacute;cifiques, ajoutez-les au
	param&egrave;tre <literal>IDSIgnorePaths</literal> dans le
	fichier <filename>/etc/freebsd-update.conf</filename>.</para>

      <para>Ce syst&egrave;me peut prendre part &agrave; une
	m&eacute;thode de mise &agrave; jour &eacute;labor&eacute;, en
	dehors de ce qui a &eacute;t&eacute; pr&eacute;sent&eacute;
	pr&eacute;c&eacute;demment.</para>
    </sect2>
  </sect1>

  <sect1 id="updating-upgrading-portsnap">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Ecrit par </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Colin</firstname>
	  <surname>Percival</surname>
	  <contrib>Bas&eacute; sur les notes de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Portsnap: un outil de mise &agrave; jour du catalogue des
      logiciels port&eacute;s</title>

    <indexterm><primary>Mise &agrave; jour</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>mise &agrave; jour</see>
    </indexterm>

    <para>Le syst&egrave;me de base de &os; dispose &eacute;galement
      d'un utilitaire pour la mise &agrave; jour du catalogue des
      logiciels port&eacute;s: &man.portsnap.8;.  Lors de son
      ex&eacute;cution, il se connectera sur un site distant,
      contr&ocirc;lera la cl&eacute; de s&eacute;curit&eacute; et
      t&eacute;l&eacute;chargera une nouvelle copie du catalogue des
      logiciels port&eacute;s.  La cl&eacute; est utilis&eacute;e pour
      v&eacute;rifier l'int&eacute;grit&eacute; de tous les fichiers
      t&eacute;l&eacute;charg&eacute;s, s'assurant qu'ils n'ont pas
      &eacute;t&eacute; modifi&eacute;s au vol.  Pour
      r&eacute;cup&eacute;rer les tout derniers fichiers du catalogue
      des logiciels port&eacute;s, utiliser la commande
      suivante:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Cet exemple nous montre que &man.portsnap.8; a trouv&eacute;
      et contr&ocirc;l&eacute; plusieurs mises &agrave; jour pour les
      donn&eacute;es actuelles du catalogue.  Est &eacute;galement
      indiqu&eacute; si l'utilitaire a &eacute;t&eacute;
      pr&eacute;c&eacute;demment ex&eacute;cut&eacute;, si cela avait
      &eacute;t&eacute; une premi&egrave;re ex&eacute;cution, le
      catalogue aurait &eacute;t&eacute; tout simplement
      t&eacute;l&eacute;charg&eacute;.</para>

    <para>Lorsque &man.portsnap.8; termine avec succ&egrave;s une
      op&eacute;ration de r&eacute;cup&eacute;ration
      (<command>fetch</command>), le catalogue des logiciels
      port&eacute;s et ses mises &agrave; jour sont pr&eacute;sents
      sur le syst&egrave;me.  A la premi&egrave;re ex&eacute;cution de
      <command>portsnap</command> vous devez utiliser la commande
      <literal>extract</literal> pour installer les fichiers
      t&eacute;l&eacute;charg&eacute;s:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Pour mettre &agrave; jour un catalogue des logiciels
      port&eacute;s d&eacute;j&agrave; install&eacute; utilisez la
      commande <command>portsnap update</command>:</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>Le processus est maintenant termin&eacute; et les
      applications peuvent &ecirc;tre install&eacute;es ou mises
      &agrave; jour &agrave; l'aide du catalogue &agrave; jour.</para>

    <para>Les op&eacute;rations <literal>fetch</literal> et
      <literal>extract</literal> ou <literal>update</literal> peuvent
      &ecirc;tre ex&eacute;cut&eacute;es &agrave; la suite comme
      montr&eacute; dans l'exemple suivant:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>Cette commande t&eacute;l&eacute;chargera la derni&egrave;re
      version du catalogue des logiciels port&eacute;s et mettra
      &agrave; jour votre version locale situ&eacute;e dans <filename
      class="directory">/usr/ports</filename>.</para>
  </sect1>

  <sect1 id="current-stable">
    <title>Suivre une branche de d&eacute;veloppement</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Il existe deux branches de d&eacute;veloppement de FreeBSD:
      &os.current; et &os.stable;.  Cette section d&eacute;taillera
      un peu chacune d'elles et d&eacute;crira comment garder &agrave;
      jour votre syst&egrave;me avec chaque arborescence respective.
      &os.current; sera tout d'abord trait&eacute;, suivit de
      &os.stable;.</para>

    <sect2 id="current">
      <title>Se synchroniser avec la version -CURRENT de &os;</title>

      <para>En lisant ces lignes, gardez &agrave; l'esprit que
	&os.current; repr&eacute;sente &ldquo;les tout derniers&rdquo;
	d&eacute;veloppement de &os;.  On attend des utilisateurs
	de &os.current; un degr&eacute; &eacute;lev&eacute; de
	comp&eacute;tences techniques, et devraient &ecirc;tre
	capables de r&eacute;soudre des probl&egrave;mes syst&egrave;me
	compliqu&eacute;s par eux-m&ecirc;mes.  Si vous &ecirc;tes
	nouveau &agrave; &os;, pensez &agrave; deux fois avant de
	l'installer.</para>

      <sect3>
	<title>Qu'est-ce que &os.current;?</title>
	<indexterm><primary>instantan&eacute;</primary></indexterm>

	<para>&os.current; est la toute derni&egrave;re version des sources
	  de &os; en cours de d&eacute;veloppement.  Cela inclut des
	  &eacute;volutions en cours, des modifications exp&eacute;rimentales,
	  et des m&eacute;canismes de transition qui feront ou ne feront pas
	  partie de la prochaine version officielle du logiciel.
	  Bien que de nombreux d&eacute;veloppeurs de &os; compilent les
	  sources de &os.current; quotidiennement, il arrive que
	  celles-ci ne soient pas compilables pendant une certaine
	  p&eacute;riode de temps.  Ces probl&egrave;mes sont r&eacute;solus
	  aussi rapidement que possible, mais que &os.current; soit
	  &agrave; l'origine d'un d&eacute;sastre ou de l'apport d'une nouvelle
	  fonctionnalit&eacute; attendue peut parfois d&eacute;pendre
	  que du moment auquel vous avez charg&eacute; le code
	  source.</para>
      </sect3>

      <sect3>
	<title>Qui a besoin de &os.current;?</title>

	<para>&os.current; est mis &agrave; disposition pour 3
	  types de personnes:</para>

	<orderedlist>
	  <listitem>
	    <para>Les membres de la communaut&eacute; &os; qui travaillent
	      activement sur une partie de l'arborescence des sources
	      et pour qui rester constamment &agrave; jour est une
	      n&eacute;cessit&eacute; absolue.</para>
	  </listitem>

	  <listitem>
	    <para>Les membres de la communaut&eacute; &os; qui participent
	      activement aux tests et sont dispos&eacute;s &agrave; passer du
	      temps &agrave; r&eacute;soudre les probl&egrave;mes pour
	      garantir que &os.current; reste aussi saine que
	      possible.  Il y a &eacute;galement ceux qui d&eacute;sirent
	      faire des suggestions dans certains domaines sur les
	      modifications &agrave; faire et la direction
	      g&eacute;n&eacute;rale que prend &os;, et soumettent des
	      correctifs pour les impl&eacute;menter.</para>
	  </listitem>

	  <listitem>
	    <para>Ceux qui veulent simplement garder un oeil sur les
	      &eacute;volutions, ou utiliser les derni&egrave;res sources comme
	      r&eacute;f&eacute;rence (e.g. pour les <emphasis>lire</emphasis>,
	      et non pour les utiliser).  Ces personnes font parfois
	      des remarques ou contribuent au code.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Qu'est-ce que <emphasis>n'est pas</emphasis>
	  &os.current;?</title>

	<orderedlist>
	  <listitem>
	    <para>Un raccourci pour se procurer des pr&eacute;-versions
	      parce que vous avez entendu dire qu'il y a de nouvelles
	      fonctionnalit&eacute;s g&eacute;niales et que vous voulez
	      &ecirc;tre le premier du coin &agrave; les avoir.  Etre le
	      premier &agrave; avoir la nouvelle fonctionnalit&eacute;
	      signifie &ecirc;tre le premier &agrave; avoir les nouveaux bogues
	      &eacute;galement.</para>
	  </listitem>

	  <listitem>
	    <para>Une moyen rapide d'avoir des corrections de bogues.
	      N'importe quelle version de &os.current; apportera
	      probablement de nouveaux bogues comme elle corrigera
	      ceux d&eacute;j&agrave; pr&eacute;sents.</para>
	  </listitem>

	  <listitem>
	    <para>Nous ne le &ldquo;supportons officiellement&rdquo;
	      en aucun cas.  Nous faisons du mieux que nous pouvons
	      pour aider les personnes qui font vraiment partie des
	      trois groupes &ldquo;l&eacute;gitimes&rdquo; &agrave; qui s'adresse
	      &os.current;, mais nous n'avons tout simplement
	      &ldquo;pas le temps&rdquo; de fournir un support
	      technique.  Ce n'est pas parce que nous sommes des
	      personnes d&eacute;testables qui n'aiment pas aider les autres
	      (nous ne ferions pas &os; si tel &eacute;tait le cas), nous ne
	      pouvons simplement pas r&eacute;pondre &agrave; des centaines de
	      messages par jour <emphasis>et</emphasis> travailler sur
	      FreeBSD!  Entre am&eacute;liorer &os; et r&eacute;pondre &agrave; de
	      nombreuses questions sur le code exp&eacute;rimental, les
	      d&eacute;veloppeurs optent pour le premier choix.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Utiliser &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>utilisation</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Inscrivez-vous &agrave; la &a.current.name; et la &a.svn-src-head.name;.
	      Ce n'est pas seulement une bonne id&eacute;e, c'est
	      <emphasis>indispensable</emphasis>.  Si vous n'&ecirc;tes
	      pas sur la liste <emphasis>&a.current.name;</emphasis>, vous
	      ne verrez pas les commentaires qui sont faits sur l'&eacute;tat
	      courant du syst&egrave;me et vous vous retrouverez probablement
	      confront&eacute;s &agrave; de nombreux probl&egrave;mes que
	      d'autres ont d&eacute;j&agrave; identifi&eacute;s et
	      r&eacute;solus.  Encore plus grave, vous manqueriez des
	      bulletins importants potentiellement critiques pour la bonne
	      sant&eacute; de votre syst&egrave;me.</para>

	    <para>La liste &a.svn-src-head.name; vous permettra de voir les courriers
	      de trace des soumissions de toutes les modifications
	      d&egrave;s qu'elles sont faites et des informations
	      pertinentes sur les &eacute;ventuels effets de bord.</para>

	    <para>Pour vous inscrire &agrave; ces listes, ou &agrave;
	      une autre, rendez vous &agrave; &a.mailman.lists.link;
	      et cliquez sur la liste &agrave; laquelle vous
	      d&eacute;sirez vous inscrire.  Des instructions sur le
	      reste de la proc&eacute;dure sont alors donn&eacute;es.
	      Si vous &ecirc;tes int&eacute;ress&eacute; par le suivi
	      des modifications appliqu&eacute;es &agrave; l'ensemble
	      de l'arborescence des sources, nous vous recommandons de
	      vous inscrire &agrave; &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>R&eacute;cup&eacute;rez les sources sur un <link
	      linkend="mirrors">site miroir</link> &os;.  Vous pouvez le
	      faire de deux mani&egrave;res:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Synchronisation avec <application>CVSup</application></secondary>
	      </indexterm>

	      <listitem>
		<para>Utilisez le programme <link linkend="cvsup">cvsup</link>
		  avec le fichier <filename>supfile</filename>
		  nomm&eacute; <filename>standard-supfile</filename>
		  disponible dans le r&eacute;pertoire <filename
		  role='directory'>/usr/share/examples/cvsup</filename>.
		  C'est la m&eacute;thode recommand&eacute;e, puisqu'elle
		  permet de r&eacute;cup&eacute;rer la totalit&eacute;
		  des sources la premi&egrave;re fois et par la suite
		  uniquement ce qui a &eacute;t&eacute; modifi&eacute;.
		  De nombreuses personnes ex&eacute;cutent
		  <command>cvsup</command> depuis
		  <command>cron</command> et maintiennent ainsi
		  automatiquement &agrave; jour leurs sources.  Vous devez
		  personnaliser l'exemple de <filename>supfile</filename>
		  pr&eacute;c&eacute;dent, et configurer
		  <link linkend="cvsup">cvsup</link> pour
		  votre environnement.</para>

		<note>
		  <para>Le fichier d'exemple
		    <filename>standard-supfile</filename> est
		    destin&eacute; au suivi d'une branche de
		    s&eacute;curit&eacute; &os; sp&eacute;cifique et
		    non pas &agrave; celui de &os.current;.  Vous
		    devrez &eacute;diter ce fichier et remplacer la
		    ligne suivante:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

		  <para>Par celle-ci:</para>

		  <programlisting>*default release=cvs tag=.</programlisting>

		  <para>Pour une explication d&eacute;taill&eacute;e
		    des &eacute;tiquettes utilisables, veuillez vous
		    r&eacute;f&eacute;rer &agrave; la section <link
		    linkend="cvs-tags">Etiquettes CVS</link> de ce
		    manuel.</para>
		</note>
	      </listitem>

	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Synchroniser avec
		  <application>CTM</application></secondary>
	      </indexterm>
	      <listitem>
		<para>Utilisez <application><link
		  linkend="ctm">CTM</link></application>.  Si vous
		  disposez d'une mauvaise connexion (connexions ch&egrave;res
		  ou seulement un acc&egrave;s au courrier &eacute;lectronique)
		  <application>CTM</application> est une bonne
		  solution.  Cependant, c'est une source de probl&egrave;mes
		  et peut donner lieu &agrave; des fichiers endommag&eacute;s.
		  C'est pourquoi cette m&eacute;thode est rarement
		  utilis&eacute;e, ce qui augmente les chances que cela ne
		  fonctionne pas pendant d'assez longue p&eacute;riodes.
		  Nous recommandons d'utiliser
		  <application><link linkend="cvsup">CVSup</link></application>
		  &agrave; tous ceux disposant d'un modem 9600&nbsp;bps ou
		  d'une connexion plus rapide.
		</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Si vous r&eacute;cup&eacute;rez les sources pour compiler
	      un syst&egrave;me op&eacute;rationnel, et pas simplement
	      pour les lire, alors r&eacute;cup&eacute;rez
	      <emphasis>tout</emphasis>  &os.current;, et pas
	      uniquement certaines portions.  La raison de cela est
	      que diverses parties des sources d&eacute;pendent de
	      modifications effectu&eacute;es ailleurs, et si vous essayez
	      de compiler juste une partie des source, il est quasiment
	      certain que vous aurez des probl&egrave;mes.</para>

	  <indexterm>
	    <primary>-CURRENT</primary>
	    <secondary>compilation</secondary>
	  </indexterm>
	    <para>Avant de compiler &os.current;, lisez attentivement
	      le <filename>Makefile</filename> dans
	      <filename>/usr/src</filename>.  Vous devriez au moins
	      la premi&egrave;re fois <link
	      linkend="makeworld">installer un nouveau noyau et recompiler le syst&egrave;me</link>, comme
	      &eacute;tape n&eacute;cessaire &agrave; votre processus de
	      mise &agrave; jour.  La lecture de la &a.current; et du fichier <filename>/usr/src/UPDATING</filename> vous tiendra
	      au courant des autres proc&eacute;dures de transition qui
	      sont parfois n&eacute;cessaires lorsque nous pr&eacute;parons la
	      prochaine version.</para>
	  </listitem>

	  <listitem>
	    <para>Participez!  Si vous utilisez &os.current;, nous
	      aimerions savoir ce que vous en pensez, tout
	      particuli&egrave;rement si vous avez des am&eacute;liorations
	      &agrave; nous sugg&eacute;rer ou des corrections de bogues
	      &agrave; nous soumettre.  Les suggestions accompagn&eacute;es
	      de code sont accueillies avec enthousiasme!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>Se synchroniser avec la version -STABLE de &os;</title>

      <sect3>
	<title>Qu'est-ce que &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; est notre branche de d&eacute;veloppement &agrave;
	  partir de laquelle sont extraites les versions majeures.
	  Les modifications sur cette branche se font &agrave; une allure
	  diff&eacute;rente, et en supposant g&eacute;n&eacute;ralement
	  qu'elles ont &eacute;t&eacute; tout d'abord test&eacute;es
	  sur &os.current;.  Cela reste cependant
	  <emphasis>toujours</emphasis> une branche de d&eacute;veloppement,
	  et cela signifie qu'&agrave; certains moments, les sources de
	  &os.stable; pourront &ecirc;tre ou pas utilisables pour une
	  quelconque raison.  C'est tout simplement une autre branche
	  de mise au point, et non pas une ressource pour
	  l'utilisateur final.</para>
      </sect3>

      <sect3>
	<title>Qui a besoin de &os.stable;?</title>

	<para>Si vous d&eacute;sirez suivre ou contribuer au processus
	  de d&eacute;veloppement de FreeBSD, tout particuli&egrave;rement si
	  cela a rapport avec la prochaine version de FreeBSD, alors
	  vous devriez penser &agrave; suivre &os.stable;.</para>

	<para>Bien qu'il soit vrai que les correctifs de s&eacute;curit&eacute;
	  vont &eacute;galement dans la branche &os.stable;, vous
	  n'avez pas <emphasis>besoin</emphasis> de suivre
	  &os.stable; pour cela.  Chaque rapport de s&eacute;curit&eacute;
	  concernant FreeBSD explique comment corriger le probl&egrave;me sur
	  les versions affect&eacute;es
	  <footnote><para>Ceci n'est pas tout &agrave; fait vrai.  Nous
	    ne pouvons continuer &agrave; supporter les anciennes versions de
	    FreeBSD &eacute;ternellement, bien que nous les supportions
	    pendant de nombreuses ann&eacute;es.  Pour une description
	    compl&egrave;te de la politique de s&eacute;curit&eacute;
	    actuelle pour les anciennes versions de FreeBSD, veuillez
	    consulter <ulink
	    url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>
	  , et suivre int&eacute;gralement une branche de d&eacute;veloppement
	  juste pour des raisons de s&eacute;curit&eacute; apportera
	  &eacute;galement de nombreux changements non
	  d&eacute;sir&eacute;s.</para>

	<para>Bien que nous tentons de nous assurer que la branche
	  &os.stable; soit compilable et constamment stable, cela
	  ne peut &ecirc;tre garanti.  De plus, alors que le code est
	  d&eacute;velopp&eacute; sous &os.current; avant de l'inclure dans
	  &os.stable;, le nombre de personnes utilisant &os.stable;
	  est plus nombreux que celui utilisant &os.current;, aussi
	  il est in&eacute;vitable que des bogues et des probl&egrave;mes
	  pourront parfois appara&icirc;tre sous &os.stable; alors qu'ils
	  n'existaient pas sous &os.current;.</para>

	<para>Pour ces raisons, nous ne recommandons
	  <emphasis>pas</emphasis> de suivre aveugl&eacute;ment
	  &os.stable;, et il est tout particuli&egrave;rement important que
	  vous ne mettiez pas &agrave; jour des serveurs de production
	  sous &os.stable; sans avoir tout d'abord test&eacute; le code
	  dans votre environnement de travail.</para>

	<para>Si vous ne disposez pas des ressources pour faire
	  cela alors nous recommandons que vous utilisiez la version
	  de FreeBSD la plus r&eacute;cente, et que vous utilisiez le
	  m&eacute;canisme de mise &agrave; jour binaire pour passer d'une
	  version &agrave; une autre.</para>
      </sect3>

      <sect3>
	<title>Utiliser &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>utilisation</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Inscrivez-vous &agrave; &agrave; la liste &a.stable.name;.
	      Vous serez tenu au courant des d&eacute;pendances de
	      compilation qui peuvent appara&icirc;tre dans la
	      branche &os.stable; ou de tout autre probl&egrave;me
	      demandant une attention particuli&egrave;re.  Les
	      d&eacute;veloppeurs publieront &eacute;galement des annonces
	      sur cette liste lorsqu'ils envisagent une correction ou
	      modification controvers&eacute;e, offrant la possibilit&eacute;
	      aux utilisateurs de r&eacute;pondre s'ils ont des questions
	      &agrave; soulever en rapport avec la modification
	      propos&eacute;e.</para>

	    <para>Inscrivez-vous &agrave; la liste
	      <application>SVN</application> correspondant &agrave; la
	      branche que vous suivez.  Par exemple, si vous suivez la
	      branche 7-STABLE, inscrivez-vous &agrave; la liste
	      &a.svn-src-stable-7.name;.  Cela vous permettra de lire
	      les courriers de trace des soumissions de toutes les
	      modifications d&egrave;s qu'elles sont faites et des
	      informations pertinentes sur les &eacute;ventuels effets
	      de bord.</para>

	    <para>Pour vous inscrire &agrave; ces listes, ou &agrave;
	      une autre, rendez vous &agrave; &a.mailman.lists.link;
	      et cliquez sur la liste &agrave; laquelle vous
	      d&eacute;sirez vous inscrire.  Des instructions sur le
	      reste de la proc&eacute;dure sont alors
	      donn&eacute;es.  Si vous &ecirc;tes
	      int&eacute;ress&eacute; par le suivi des modifications
	      appliqu&eacute;es &agrave; l'ensemble de l'arborescence
	      des sources, nous vous recommandons de vous inscrire
	      &agrave; &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Si vous installez un nouveau syst&egrave;me et vous
	      voulez qu'il utilise le dernier instantan&eacute;
	      publi&eacute; tous les mois &agrave; partir de la
	      branche &os.stable;, consultez la page sur les <ulink
	      url="&url.base;/snapshots/">instantan&eacute;s</ulink>
	      pour plus d'information.  D'autre part, vous pouvez
	      installer la version &os.stable; la plus r&eacute;cente
	      &agrave; partir des <link linkend="mirrors">sites
	      miroirs</link> et suivre les instructions ci-dessous
	      pour mettre &agrave; jour votre syst&egrave;me avec les
	      sources &os;stable; les plus r&eacute;centes.</para>

	    <para>Si vous faites tourner une version pr&eacute;c&eacute;dente
	      de &os; et que vous d&eacute;sirez mettre &agrave; jour via
	      les sources vous pouvez ais&eacute;ment le faire &agrave; partir
	      d'un <link linkend="mirrors">site miroir</link> &os;.  Cela
	      peut &ecirc;tre fait de deux mani&egrave;res:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>Synchronisation avec <application>CVSup</application></secondary>
	      </indexterm>
	      <listitem>
		<para>Utilisez le programme <link linkend="cvsup">cvsup</link>
		  avec le fichier <filename>supfile</filename>
		  nomm&eacute; <filename>stable-supfile</filename>
		  disponible dans le r&eacute;pertoire <filename
		  role='directory'>/usr/share/examples/cvsup</filename>.
		  C'est la m&eacute;thode recommand&eacute;e, puisqu'elle
		  permet de r&eacute;cup&eacute;rer la totalit&eacute;
		  des sources la premi&egrave;re fois et par la suite
		  uniquement ce qui a &eacute;t&eacute; modifi&eacute;.
		  De nombreuses personnes ex&eacute;cutent
		  <command>cvsup</command> depuis
		  <command>cron</command> et maintiennent ainsi
		  automatiquement &agrave; jour leurs sources.  Vous devez
		  personnaliser l'exemple de <filename>supfile</filename>
		  pr&eacute;c&eacute;dent, et configurer
		  <link linkend="cvsup">cvsup</link> pour
		  votre environnement.</para>
	      </listitem>


	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>Synchroniser avec
		  <application>CTM</application></secondary>
	      </indexterm>
	      <listitem>
		<para>Utilisez <application><link
		  linkend="ctm">CTM</link></application>.  Si vous
		  ne disposez pas d'une connexion Internet rapide et
		  peu co&ucirc;teuse, c'est la m&eacute;thode que vous
		  devriez penser &agrave; utiliser.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Avant tout, si vous avez besoin d'un acc&egrave;s rapide
	      &agrave; la demande aux sources et que la bande passante n'est
	      pas un probl&egrave;me, utilisez
	      <command>cvsup</command> ou <command>ftp</command>.
	      Sinon, utilisez <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>compilation</secondary>
	  </indexterm>
	  <listitem>
	    <para>Avant de compiler &os.stable;, lisez attentivement
	      le <filename>Makefile</filename> dans
	      <filename>/usr/src</filename>.  Vous devriez au moins
	      la premi&egrave;re fois <link
	      linkend="makeworld">installer un nouveau noyau et recompiler le syst&egrave;me</link>, comme
	      &eacute;tape n&eacute;cessaire &agrave; votre processus de
	      mise &agrave; jour.  La lecture de la &a.stable; et du fichier <filename>/usr/src/UPDATING</filename> vous tiendra
	      au courant des autres proc&eacute;dures de transition qui
	      sont parfois n&eacute;cessaires lorsque nous pr&eacute;parons la
	      prochaine version.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Synchroniser vos sources</title>

    <para>Il existe diff&eacute;rentes fa&ccedil;ons d'utiliser une connexion
      Internet (ou le courrier &eacute;lectronique) pour garder &agrave; jour
      les sources de n'importe quelle partie, ou de l'ensemble,
      du projet &os;, selon ce qui vous int&eacute;resse.  Les
      principaux services que nous fournissons sont le
      <link linkend="anoncvs">CVS anonyme</link>, <link
      linkend="cvsup">CVSup</link>, et <link linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Alors qu'il est possible de mettre &agrave; jour seulement
	certaines parties de l'arbre des sources, la seule proc&eacute;dure
	de mise &agrave; jour support&eacute;e est celle consistant
	&agrave; mettre &agrave; jour l'int&eacute;gralit&eacute; de
	l'arborescence et de recompiler les sources des applicatifs de
	base&mdash;&ldquo;userland&rdquo; (i.e., tous les programmes
	qui tournent dans l'espace utilisateur, comme ceux des
	r&eacute;pertoires <filename>/bin</filename> et
	<filename>/sbin</filename>) et du noyau.  Ne mettre &agrave; jour
	qu'une partie des sources, uniquement le noyau, ou seul le
	&ldquo;userland&rdquo; m&egrave;nera souvent &agrave; des
	probl&egrave;mes.  Ces probl&egrave;mes pourront aller d'erreurs de
	compilation &agrave; des paniques du noyau ou m&ecirc;me des
	corruptions de donn&eacute;es.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonyme</secondary>
    </indexterm>

    <para><application>CVS anonyme</application> et
      <application>CVSup</application> utilisent une m&eacute;thode de
      mise &agrave; jour pilot&eacute;e par le
      client&mdash;<emphasis>pull</emphasis>.  Dans le cas de
      <application>CVSup</application>, l'utilisateur (ou une
      proc&eacute;dure <command>cron</command>) appelle le programme
      <command>cvsup</command>, qui interagit avec un serveur
      <command>cvsupd</command> distant, pour mettre &agrave; jour vos
      fichiers.  Les mises &agrave; jour que vous recevez sont les plus
      r&eacute;centes, et vous ne les recevez seulement lorsque vous le
      d&eacute;sirez.  Vous pouvez ais&eacute;ment restreindre vos mises
      &agrave; jour aux fichiers ou r&eacute;pertoires particuliers
      qui vous int&eacute;ressent.  Les mises &agrave; jour sont
      g&eacute;n&eacute;r&eacute;es &agrave; la vol&eacute;e par le serveur,
      en fonction de ce que vous avez d&eacute;j&agrave; et de ce que vous
      voulez.  <application>CVS anonyme</application> est plus
      simpliste que <application>CVSup</application>, car ce n'est
      qu'une extension de <application>CVS</application> qui
      permet de r&eacute;cup&eacute;rer des modifications directement
      d'une archive CVS distante.  Pour cela,
      <application>CVSup</application> est bien plus efficace mais
      <application>CVS anonyme</application> est plus facile &agrave;
      utiliser.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application>, &agrave; l'inverse, ne compare
      pas interactivement les sources dont vous disposez avec celles
      qui sont sur l'archive de r&eacute;f&eacute;rence.  Au lieu de cela,
      une proc&eacute;dure qui identifie les modifications intervenues
      depuis qu'elle a &eacute;t&eacute; ex&eacute;cut&eacute;e pour la
      derni&egrave;re fois, est lanc&eacute;e plusieurs fois par jour
      sur la machine CTM de r&eacute;f&eacute;rence (ma&icirc;tre),
      les modifications d&eacute;tect&eacute;es sont
      compress&eacute;es, affect&eacute;es d'un num&eacute;ro de
      s&eacute;quence et encod&eacute;es pour pouvoir &ecirc;tre envoy&eacute;es
      par courrier &eacute;lectronique (en ASCII imprimable uniquement).
      Une fois re&ccedil;us, ces &ldquo;deltas CTM&rdquo; peuvent
      &ecirc;tre pass&eacute;s &agrave; l'utilitaire &man.ctm.rmail.1;
      qui d&eacute;codera, contr&ocirc;lera et appliquera automatiquement
      les modifications &agrave; l'exemplaire des sources de l'utilisateur.
      Cette m&eacute;thode est beaucoup plus efficace que
      <application>CVSup</application> et consomme beaucoup moins de
      ressources sur notre serveur, parce que c'est un mod&egrave;le
      pilot&eacute; par le serveur&mdash;<emphasis>push</emphasis>
      plut&ocirc;t que par
      l'utilisateur&mdash;<emphasis>pull</emphasis>.</para>

    <para>Il y a, bien s&ucirc;r, quelques contreparties.
      Si vous effacez par inadvertance des parties de votre archive,
      <application>CVSup</application> s'en apercevra et vous
      reconstruira les parties endommag&eacute;es.
      <application>CTM</application> ne le fera pas, et si vous
      effacez des parties de votre l'arborescence des sources
      (et que vous n'avez pas fait de sauvegarde) alors vous devrez
      repartir de z&eacute;ro (&agrave; partir du plus r&eacute;cent
      &ldquo;delta de base&rdquo; CVS) et tout reconstituer avec
      <application>CTM</application> ou <application>CVS
      anonyme</application>, effacer les parties endommag&eacute;es et
      resynchroniser.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Recompiler le syst&egrave;me</title>

    <indexterm>
      <primary>recompiler le syst&egrave;me</primary>
    </indexterm>
    <para>Une fois que vous avez synchronis&eacute; votre arborescence des
      sources avec une version donn&eacute;e de &os; (&os.stable;,
      &os.current;, et ainsi de suite) vous pouvez alors utiliser
      cette arborescence des sources pour recompiler le
      syst&egrave;me.</para>

    <warning>
      <title>Faites une sauvegarde</title>

      <para>On n'insistera jamais assez sur l'importance de faire une
	sauvegarde de votre syst&egrave;me <emphasis>avant</emphasis> tout
	autre chose.  Bien qu'il soit facile de &ldquo;refaire le
	monde&rdquo; (recompiler FreeBSD), si vous suivez ces
	instructions, vous ferez in&eacute;vitablement des erreurs
	&agrave; un moment ou un autre, ou d'autres feront des erreurs
	au niveau de l'arborescence des sources qui emp&ecirc;cheraient
	votre syst&egrave;me de red&eacute;marrer.</para>

      <para>Assurez-vous que vous avez bien fait une sauvegarde.  Ayez
	une disquette de maintenance, ou un CD d&eacute;marrable &agrave; port&eacute;e de la main.
	Vous ne l'utiliserez probablement pas, mais prudence est m&egrave;re
	de s&ucirc;ret&eacute;!</para>
    </warning>

    <warning>
      <title>S'abonner &agrave; la bonne liste de diffusion</title>

      <indexterm><primary>liste de diffusion</primary></indexterm>
      <para>Les branches &os.stable; et &os.current; sont, par
	nature, <emphasis>en d&eacute;veloppement</emphasis>.  Les personnes
	qui participent &agrave; &os; sont des humains, et
	des erreurs se produisent occasionnellement.</para>

      <para>Ces erreurs sont parfois b&eacute;nignes, provocant
	simplement l'affichage d'un nouveau message d'avertissement
	par votre syst&egrave;me.  Elles peuvent aussi &ecirc;tre
	catastrophiques, et emp&ecirc;cher votre syst&egrave;me de
	red&eacute;marrer ou d&eacute;truire vos syst&egrave;mes de fichiers
	(ou pire).</para>

      <para>Quand de tels probl&egrave;mes se produisent, un avertissement
	&ldquo;heads up&rdquo; est post&eacute; sur la liste de diffusion
	appropri&eacute;e, d&eacute;crivant la nature du probl&egrave;me et
	quels syst&egrave;mes sont concern&eacute;s.  Un message &ldquo;all
	clear&rdquo; est post&eacute; quand le probl&egrave;me est
	r&eacute;solu.</para>

      <para>Si vous tentez de suivre &os.stable; ou &os.current; et
	que vous ne lisez pas la &a.stable; ou la &a.current;,
	vous allez au devant d'ennuis.</para>
    </warning>

    <warning>
      <title>N'utilisez pas la commande
	<command>make world</command></title>

      <para>De nombreuses anciennes documentations pr&eacute;conisent
	d'utiliser la commande <command>make world</command>.  Cette
	commande n'effectue pas un certain nombre d'&eacute;tapes
	importantes et ne devrait &ecirc;tre utilis&eacute;e que si
	vous &ecirc;tes s&ucirc;r de ce que vous faites.  Dans presque
	tout les cas <command>make world</command> n'est pas une bonne
	chose &agrave; faire, et la proc&eacute;dure d&eacute;crite
	dans la suite de ce document devrait &ecirc;tre
	utilis&eacute;e &agrave; la place.</para>
    </warning>

    <sect2>
      <title>La m&eacute;thode g&eacute;n&eacute;rique de mise
	&agrave; jour du syst&egrave;me</title>

      <para>Pour mettre &agrave; jour votre syst&egrave;me, vous
	devriez consulter <filename>/usr/src/UPDATING</filename> pour
	toute op&eacute;ration pr&eacute;liminaire n&eacute;cessaire
	en fonction de la version de vos sources et ensuite
	utiliser la proc&eacute;dure suivante:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Dans quelques rares cas, il est n&eacute;cessaire de
	  lancer un <command>mergemaster -p</command> avant
	  l'&eacute;tape <maketarget>buildworld</maketarget>.  Ces cas
	  sont d&eacute;crits dans le fichier
	  <filename>UPDATING</filename>.  G&eacute;n&eacute;ralement,
	  vous pouvez omettre cette op&eacute;ration si vous ne mettez
	  pas &agrave; jour d'une version majeure de &os; &agrave; une
	  autre.</para>
      </note>

      <para>Une fois l'op&eacute;ration
	<maketarget>installkernel</maketarget> termin&eacute;e avec
	succ&egrave;s,
	vous devrez d&eacute;marrer en mode mono-utilisateur (en
	utilisant par exemple la commande <command>boot -s</command>
	&agrave; l'invite du chargeur).  Ex&eacute;cutez
	ensuite:</para>

      <screen>&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lisez les explications suppl&eacute;mentaires</title>

	<para>La s&eacute;quence d&eacute;crite ci-dessus n'est qu'un
	  court r&eacute;sum&eacute; pour vous aider &agrave;
	  d&eacute;marrer.  Vous devriez cependant lire les sections
	  suivantes afin de comprendre clairement chaque &eacute;tape,
	  tout particuli&egrave;rement si vous d&eacute;sirez utiliser
	  une configuration du noyau personnalis&eacute;e.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Lire <filename>/usr/src/UPDATING</filename></title>

      <para>Avant tout autre chose, lisez
	<filename>/usr/src/UPDATING</filename> (ou le fichier
	&eacute;quivalent en fonction de l'endroit o&ugrave; se trouve vos
	sources).  Ce fichier devrait contenir les informations
	importantes au sujet des probl&egrave;mes que vous pourriez
	rencontrer, ou indique l'ordre dans lequel vous devriez
	ex&eacute;cuter certaines commandes.  Si le fichier
	<filename>UPDATING</filename> contredit quelque chose d'&eacute;crit
	ici, <filename>UPDATING</filename> prime sur tout le
	reste.</para>

      <important>
	<para>La lecture du fichier <filename>UPDATING</filename>
	  n'est pas un substitut &agrave; l'abonnement &agrave; la liste
	  de diffusion correcte, comme d&eacute;crit
	  pr&eacute;c&eacute;demment.  Ces deux pr&eacute;requis sont
	  compl&eacute;mentaires, et non pas exclusifs.</para>
      </important>
    </sect2>

    <sect2>
      <title>Contr&ocirc;ler <filename>/etc/make.conf</filename></title>
      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Contr&ocirc;lez les fichiers
	<filename>/usr/share/examples/etc/make.conf</filename>
	et
	<filename>/etc/make.conf</filename>.  Le premier contient
	des param&egrave;tres par d&eacute;faut &ndash; la plupart
	&eacute;tant plac&eacute;s en commentaires.  Pour les utiliser quand
	vous recompilez votre syst&egrave;me &agrave; partir des sources,
	rajout&eacute;s-les au fichier <filename>/etc/make.conf</filename>.
	Gardez &agrave; l'esprit que tout ce que vous ajoutez au fichier
	<filename>/etc/make.conf</filename> est utilis&eacute; chaque fois
	que vous invoquez la commande <command>make</command>, il est
	donc bon de s'assurer que les valeurs par d&eacute;faut sont
	appropri&eacute;es &agrave; votre syst&egrave;me.</para>

      <para>Un utilisateur typique voudra probablement copier
	les lignes <makevar>CFLAGS</makevar> et
	<makevar>NO_PROFILE</makevar> se trouvant dans
	<filename>/usr/share/examples/etc/make.conf</filename> vers
	<filename>/etc/make.conf</filename> et les d&eacute;commenter.</para>

      <para>Examinez les autres d&eacute;finitions
	(<makevar>COPTFLAGS</makevar>, <makevar>NOPORTDOCS</makevar>
	et ainsi de suite) et d&eacute;cidez si elles vous conviennent.</para>
    </sect2>

    <sect2>
      <title>Mettre &agrave; jour les fichiers dans <filename>/etc</filename></title>

      <para>Le r&eacute;pertoire <filename>/etc</filename> contient la
	plupart des informations de configuration de votre syst&egrave;me,
	ainsi que les proc&eacute;dures de d&eacute;marrage.  Certaines de ces
	proc&eacute;dures changent d'une version &agrave; l'autre de
	FreeBSD.</para>

      <para>Certains fichiers de configuration sont &eacute;galement
	utilis&eacute;s en permanence par le syst&egrave;me.  En particulier
	<filename>/etc/group</filename>.</para>

      <para>Il est arriv&eacute; que la phase d'installation <command>make
	installworld</command> ait besoin que certains utilisateurs et groupes
	existent.  Il y a de fortes chances qu'ils n'aient pas
	&eacute;t&eacute; d&eacute;finis avant la mise &agrave; jour.
	C'est une source de probl&egrave;mes.  Dans certains cas
	<command>make buildworld</command> contr&ocirc;lera si ces
	utilisateurs ou groupes existent.</para>

      <para>Un exemple de cela fut l'addition de l'utilisateur
	<username>smmsp</username>.  Le processus d'installation
	&eacute;chouait quand <command>mtree</command> tentait de cr&eacute;er
	<filename>/var/spool/clientmqueue</filename>.</para>

      <para>La solution est d'ex&eacute;cuter
	&man.mergemaster.8; dans le mode pr&eacute;-&ldquo;buildworld&rdquo;
	en ajoutant l'option <option>-p</option>.  Cela effectuera la
	comparaison uniquement des fichiers essentiels pour le succ&egrave;s
	de la proc&eacute;dure <maketarget>buildworld</maketarget> ou
	<maketarget>installworld</maketarget>.  Si votre vieille
	version de <command>mergemaster</command> ne supporte pas
	l'option <option>-p</option>, utilisez la nouvelle version
	pr&eacute;sente dans l'arborescence des sources quand vous
	l'ex&eacute;cutez pour la premi&egrave;re fois:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Si vous &ecirc;tes particuli&egrave;rement parano&iuml;aque,
	  vous pouvez contr&ocirc;ler votre syst&egrave;me afin de voir quels
	  fichiers appartiennent au groupe que vous renommez ou
	  effacez:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>affichera les fichiers appartenant au groupe
	  <replaceable>GID</replaceable> (qui peut &ecirc;tre soit un nom de
	  groupe ou un identifiant num&eacute;rique de groupe).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Passer en mode mono-utilisateur</title>
      <indexterm><primary>mode mono-utilisateur</primary></indexterm>

      <para>Il vaut mieux recompiler le syst&egrave;me en mode
	mono-utilisateur.  En dehors du fait que cela sera
	l&eacute;g&egrave;rement plus rapide, la r&eacute;installation
	va modifier un grand nombre de fichiers syst&egrave;mes
	importants, tous les binaires de base du syst&egrave;me, les
	biblioth&egrave;ques, les fichiers d'include et ainsi de suite.
	Les modifier sur un syst&egrave;me en fonctionnement (en
	particulier s'il y a des utilisateurs connect&eacute;s &agrave;
	ce moment l&agrave;), c'est aller au devant de
	probl&egrave;mes.</para>

      <indexterm><primary>mode multi-utilisateurs</primary></indexterm>
      <para>Une autre m&eacute;thode consiste &agrave; compiler le
	syst&egrave;me en mode multi-utilisateurs, et passer dans le mode
	mono-utilisateur pour l'installation.  Si vous d&eacute;sirez
	utiliser cette m&eacute;thode, conservez les &eacute;tapes suivantes
	pour le moment o&ugrave; la compilation sera termin&eacute;e.  Vous
	pouvez reporter le passage en mode mono-utilisateur jusqu'&agrave;
	l'ex&eacute;cution de
	<maketarget>installkernel</maketarget> ou
	<maketarget>installworld</maketarget>.</para>

      <para>En tant que super-utilisateur, vous pouvez ex&eacute;cuter la
	commande:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>sur un syst&egrave;me en fonctionnement, pour passer en mode
	mono-utilisateur.</para>

      <para>Ou bien, red&eacute;marrer le syst&egrave;me, et &agrave;
	l'invite de d&eacute;marrage, s&eacute;lectionnez l'option
	<quote>single user</quote>.  Le syst&egrave;me d&eacute;marrera alors
	en mode mono-utilisateur.  A l'invite de l'interpr&eacute;teur de
	commandes, ex&eacute;cutez alors:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Cela effectue une v&eacute;rification des syst&egrave;mes
	de fichiers, remonte <filename>/</filename> en mode
	lecture/&eacute;criture, et monte tous les autres syst&egrave;mes
	de fichiers UFS list&eacute;s dans le fichier
	<filename>/etc/fstab</filename>, puis active la
	pagination.</para>

      <note>
	<para>Si votre horloge CMOS est r&eacute;gl&eacute;e sur l'heure locale
	  et non pas sur le fuseau GMT (cela est vrai si la sortie
	  de la commande <command>date</command> ne donne pas l'heure
	  et le fuseau correct), vous aurez &eacute;galement peut-&ecirc;tre
	  besoin d'ex&eacute;cuter la commande suivante:</para>

<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	<para>Cela permettra de s'assurer que vos param&egrave;tres
	  de fuseaux horaires sont correctement configur&eacute;s &mdash;
	  sans cela, vous risquez de faire face, plus tard, &agrave; des
	  probl&egrave;mes.
	</para>
      </note>

    </sect2>

    <sect2>
      <title>Effacer <filename>/usr/obj</filename></title>

      <para>Au fur et &agrave; mesure que les diff&eacute;rentes parties
	du syst&egrave;me sont recompil&eacute;es, elles sont
	plac&eacute;es dans des r&eacute;pertoires qui (par d&eacute;faut) sont
	sous <filename>/usr/obj</filename>.  Les r&eacute;pertoires sont
	agenc&eacute;s comme sous <filename>/usr/src</filename>.</para>

      <para>Vous pouvez acc&eacute;l&eacute;rer le processus <command>make
	buildworld</command>, et &eacute;galement vous &eacute;viter d'&eacute;ventuels
	probl&egrave;mes de d&eacute;pendances en effa&ccedil;ant ce
	r&eacute;pertoire.</para>

      <para>Certains fichiers dans <filename>/usr/obj</filename>
	peuvent avoir l'indicateur immuable positionn&eacute; (consultez la
	page de manuel &man.chflags.1; pour plus d'informations)
	qui doit &ecirc;tre retir&eacute; en premier.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 id="updating-upgrading-compilebase">
      <title>Recompiler le syst&egrave;me de base</title>

      <sect3>
	<title>Enregistrer la sortie</title>

	<para>C'est une bonne id&eacute;e d'enregistrer la sortie de
	  &man.make.1; dans un fichier.  Si quelque chose se passe
	  mal, vous aurez une trace des messages d'erreur.  M&ecirc;me
	  si cela ne vous aide pas &agrave; diagnostiquer ce qui n'a pas
	  fonctionn&eacute;, cela peut aider les autres si vous postez
	  votre probl&egrave;me sur une des listes de diffusion de
	  &os;.</para>

	<para>La m&eacute;thode la plus ais&eacute;e pour faire cela est
	  d'utiliser la commande &man.script.1;, avec en param&egrave;tre
	  le nom du fichier o&ugrave; enregistrer les r&eacute;sultats.
	  Vous devez faire cela imm&eacute;diatement juste avant de
	  recompiler le syst&egrave;me, et taper <userinput>exit</userinput>
	  une fois que c'est termin&eacute;.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Si vous le faites, <emphasis>n'enregistrez pas</emphasis>
	  le r&eacute;sultat dans <filename>/tmp</filename>.
	  Ce r&eacute;pertoire peut &ecirc;tre vid&eacute; au prochain
	  red&eacute;marrage du syst&egrave;me.  Un meilleur endroit de
	  sauvegarde est <filename>/var/tmp</filename> (comme dans l'exemple
	  pr&eacute;c&eacute;dent) ou dans le r&eacute;pertoire utilisateur
	  de <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>Compiler le nouveau syst&egrave;me</title>

	<para>Vous devez &ecirc;tre dans le r&eacute;pertoire
	  <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(&agrave; moins, bien s&ucirc;r, que votre code source ne
	  soit ailleurs, auquel cas vous devrez aller dans le
	  r&eacute;pertoire correspondant).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Pour recompiler le syst&egrave;me, on utilise la commande
	  &man.make.1;.  Cette commande lit ses instructions dans
	  le fichier <filename>Makefile</filename>, qui d&eacute;crit comment
	  devraient &ecirc;tre reconstruits les programmes qui constituent
	  &os;, dans quel ordre, et ainsi de suite.</para>

	<para>Le format g&eacute;n&eacute;ral de la ligne de commande que
	  vous taperez sera la suivante:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>cible</replaceable></userinput></screen>

	<para>Dans cet exemple,
	  <option>-<replaceable>x</replaceable></option> est une
	  option que vous passez &agrave; &man.make.1;.  Reportez-vous
	  &agrave; la page de manuel pour un exemple d'options que vous
	  pouvez passer.</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  transmet un variable au fichier
	  <filename>Makefile</filename>.  Le comportement du
	  <filename>Makefile</filename> est d&eacute;fini par ces variables.
	  Ce sont les m&ecirc;mes variables que l'on trouve dans
	  <filename>/etc/make.conf</filename>, et c'est un autre moyen
	  de les positionner.</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>cible</replaceable></userinput></screen>

	<para>est une autre mani&egrave;re de dire qu'il ne faut pas compiler
	  les biblioth&egrave;ques profil&eacute;es et correspond &agrave;
	  la ligne:</para>

	<programlisting>NO_PROFILE=    true	#    Avoid compiling profiled libraries</programlisting>

	<para>dans <filename>/etc/make.conf</filename>.</para>

	<para><replaceable>cible</replaceable> indique &agrave; &man.make.1;
	  ce que vous voulez faire.  Chaque
	  <filename>Makefile</filename> d&eacute;finit un certain nombre de
	  &ldquo;cibles&rdquo;, et votre choix de cible d&eacute;termine ce
	  qui se passe.</para>

	<para>Certaines cibles list&eacute;es dans le fichier
	  <filename>Makefile</filename>, ne doivent pas &ecirc;tre
	  employ&eacute;es.  Ce sont des &eacute;tapes interm&eacute;diaires
	  utilis&eacute;es par le processus de recompilation pour
	  d&eacute;composer les &eacute;tapes importantes de la recompilation
	  du syst&egrave;me en sous-&eacute;tapes.</para>

	<para>La plupart du temps, vous n'aurez pas besoin de passer
	  de param&egrave;tres &agrave; &man.make.1;, et votre commande
	  ressemblera &agrave; ceci:</para>

	<screen>&prompt.root; <userinput>make <replaceable>cible</replaceable></userinput></screen>

	<para>O&ugrave; <replaceable>cible</replaceable> sera une des
	  nombreuses options de compilation.  La premi&egrave;re cible
	  devrait toujours &ecirc;tre
	  <makevar>buildworld</makevar>.</para>

	<para>Comme leurs noms l'indiquent,
	  <maketarget>buildworld</maketarget> reconstruit la nouvelle
	  arborescence dans <filename>/usr/obj</filename>, et
	  <maketarget>installworld</maketarget>, une autre cible, l'installe sur la
	  machine.</para>

	<para>Disposer d'options s&eacute;par&eacute;es est tr&egrave;s utile pour deux raisons.  Tout d'abord
	  cela vous permet de recompiler en toute s&ucirc;ret&eacute; en sachant
	  qu'aucun composant du syst&egrave;me actuel ne sera affect&eacute;.
	  La compilation est &ldquo;autonome&rdquo;.  En raison de
	  cela vous pouvez ex&eacute;cuter
	  <maketarget>buildworld</maketarget> sur une machine en mode
	  multi-utilisateurs sans redouter d'effets f&acirc;cheux.  Il est
	  n&eacute;anmoins recommand&eacute; de toujours ex&eacute;cuter
	  l'&eacute;tape <maketarget>installworld</maketarget> en mode
	  mono-utilisateur.</para>

	<para>En second lieu, cela vous permet d'utiliser des
	  syst&egrave;mes mont&eacute;s par NFS pour mettre &agrave;
	  jour plusieurs machines de votre r&eacute;seau.  Si vous avez
	  trois machines <hostid>A</hostid>, <hostid>B</hostid> et
	  <hostid>C</hostid> que vous voulez mettre &agrave; jour,
	  ex&eacute;cutez <command>make buildworld</command> et
	  <command>make installworld</command> sur <hostid>A</hostid>.
	  <hostid>B</hostid> et <hostid>C</hostid> doivent
	  ensuite monter par NFS <filename>/usr/src</filename>
	  et <filename>/usr/obj</filename> depuis <hostid>A</hostid>,
	  et vous pouvez alors ex&eacute;cuter
	  <command>make installworld</command> pour installer le
	  syst&egrave;me recompil&eacute; sur <hostid>B</hostid> et
	  <hostid>C</hostid>.</para>

	<para>Bien que la cible <maketarget>world</maketarget> existe
	  toujours, vous &ecirc;tes fortement encourag&eacute;
	  &agrave; ne pas l'utiliser.</para>

	<para>Ex&eacute;cutez:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Il est possible de passer l'option
	  <option>-j</option> &agrave; &man.make.1; ce qui lui permettra
	  d'ex&eacute;cuter plusieurs processus simultan&eacute;ment.
	  C'est particuli&egrave;rement utile sur une machine avec plusieurs
	  processeurs.  Cependant, comme la compilation est plus
	  gourmande en E/S plut&ocirc;t qu'en CPU, c'est &eacute;galement
	  utile sur des machines mono-processeur.</para>

	<para>Typiquement sur une machine mono-processeur, vous
	  ex&eacute;cuteriez:</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; pourra ex&eacute;cuter jusqu'&agrave; 4 processus
	  simultan&eacute;ment.  Des constatations empiriques
	  post&eacute;es sur les listes de diffusion montrent que c'est
	  en g&eacute;n&eacute;ral ce qui apporte le plus de gain en
	  performances.</para>

	<para>Si vous avez une machine multi-processeurs et que vous
	  avez configur&eacute; un noyau SMP, essayez des valeurs entre 6 et
	  19 et voyez quel b&eacute;n&eacute;fice vous en tirez.</para>
      </sect3>

      <sect3>
	<title>Dur&eacute;e</title>
	<indexterm>
	  <primary>compilation du syst&egrave;me</primary>
	  <secondary>dur&eacute;e</secondary>
	</indexterm>

        <para>De nombreux facteurs influencent la dur&eacute;e de
	  compilation, mais les machines r&eacute;centes devraient
	  mettrent seulement de une &agrave; deux heures
	  pour compiler l'arborescence &os.stable;,
	  sans modification ni raccourcis durant le processus.
	  Une arborescence &os.current; n&eacute;cessitera un peu plus de
	  temps.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Compiler et installer un nouveau noyau</title>
      <indexterm>
	<primary>noyau</primary>
	<secondary>compilation</secondary>
      </indexterm>

      <para>Pour tirer pleinement parti de votre nouveau syst&egrave;me,
	vous devrez recompiler le noyau.  C'est pratiquement
	indispensable, parce que certaines structures m&eacute;moires
	peuvent avoir chang&eacute;es, et des programmes comme &man.ps.1;
	et &man.top.1; ne fonctionneront pas tant que le syst&egrave;me
	et le noyau n'utilisent pas les m&ecirc;mes versions de code
	source.</para>

      <para>La mani&egrave;re la plus simple et la plus s&ucirc;re est de
	compiler et installer un noyau bas&eacute; sur le noyau
	<filename>GENERIC</filename>.  Alors que le noyau
	<filename>GENERIC</filename> peut ne pas comporter les pilotes
	de p&eacute;riph&eacute;riques n&eacute;cessaires pour votre
	syst&egrave;me, il devrait contenir tout ce qui est
	n&eacute;cessaire pour faire d&eacute;marrer votre syst&egrave;me
	en mode mono-utilisateur.  C'est une bonne fa&ccedil;on de tester
	le fonctionnement de votre nouveau syst&egrave;me.  Apr&egrave;s
	avoir d&eacute;marr&eacute; &agrave; partir du noyau
	<filename>GENERIC</filename> et v&eacute;rifi&eacute; que
	votre syst&egrave;me fonctionne vous pouvez alors compiler un nouveau
	noyau bas&eacute; sur votre fichier de configuration normal du
	noyau.</para>

      <para>Sur &os;, il est important
	de <link linkend="make-buildworld">recompiler le
	syst&egrave;me</link> avant de compiler un nouveau
	noyau.</para>

      <note>
	<para>Si vous d&eacute;sirez compiler un noyau personnalis&eacute;,
	  et que vous avez d&eacute;j&agrave; un fichier de
	  configuration, utilisez juste
	  <maketarget>KERNCONF=<replaceable>MONNOYAU</replaceable></maketarget>
	  comme suit:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MONNOYAU</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MONNOYAU</replaceable></userinput></screen>
      </note>

      <para>Notez que si vous avez augment&eacute; la variable
	<literal>kern.securelevel</literal> &agrave; une valeur
	sup&eacute;rieure &agrave; 1 <emphasis>et</emphasis> que vous
	avez positionn&eacute; l'indicateur <literal>noschg</literal>
	ou similaire sur votre noyau, il sera int&eacute;ressant de passer
	en mode mono-utilisateur pour utiliser
	<maketarget>installkernel</maketarget>.  Sinon vous devriez
	&ecirc;tre en mesure d'ex&eacute;cuter ces commandes &agrave;
	partir du mode multi-utilisateur sans probl&egrave;mes.  Voir
	la page de manuel de &man.init.8; pour plus de d&eacute;tails
	&agrave; propos de <literal>kern.securelevel</literal> et la page
	&man.chflags.1; pour des informations sur les diff&eacute;rents
	indicateurs de fichiers.</para>
    </sect2>

    <sect2>
      <title>Red&eacute;marrer en mode mono-utilisateur</title>
      <indexterm><primary>mode mono-utilisateur</primary></indexterm>

      <para>Vous devriez red&eacute;marrer en mode mono-utilisateur pour
	tester le fonctionnement du nouveau noyau.  Pour cela suivez
	les instructions de
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2 id="make-installworld">
      <title>Installer les nouveaux binaires syst&egrave;me</title>

      <para>Si vous avez compil&eacute; une version de &os; assez
	r&eacute;cente pour avoir utilis&eacute;
	<command>make buildworld</command> alors vous devriez
	utiliser maintenant <maketarget>installworld</maketarget>
	pour installer les nouveaux binaires syst&egrave;me.</para>

      <para>Lancez:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Si vous sp&eacute;cifiez des variables sur la
	  ligne de commande de <command>make buildworld</command>,
	  vous devez utiliser les m&ecirc;mes variables avec la commande
	  <command>make installworld</command>.  Cela ne reste
	  pas forc&eacute;ment vrai pour d'autres options; par exemple,
	  <option>-j</option> ne doit jamais &ecirc;tre utilis&eacute;e
	  avec <maketarget>installworld</maketarget>.</para>

	<para>Par exemple, si vous ex&eacute;cutez:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>vous devrez ensuite installer les r&eacute;sultats avec:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>sinon il essayera d'installer les biblioth&egrave;ques
	  profil&eacute;es qui n'ont pas &eacute;t&eacute;
	  recompil&eacute;es &agrave; l'&eacute;tape
	  <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Mettre &agrave; jour les fichiers non modifi&eacute;s par
	<command>make installworld</command></title>

      <para>La recompilation du syst&egrave;me ne mettra pas &agrave;
	jour certains r&eacute;pertoires (en particulier,
	<filename>/etc</filename>, <filename>/var</filename> et
	<filename>/usr</filename>) avec les fichiers nouveaux
	ou modifi&eacute;s.</para>

      <para>La mani&egrave;re la plus simple de mettre &agrave; jour
	ces fichiers est d'utiliser &man.mergemaster.8;, bien
	qu'il soit possible de le faire manuellement si vous le
	d&eacute;sirez.  Ind&eacute;pendamment de la mani&egrave;re
	que vous choisissez, assurez-vous de faire une sauvegarde
	du r&eacute;pertoire <filename>/etc</filename> au cas
	o&ugrave; quelque chose se passerait mal.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribution de </contrib>
	  </author>
	</authorgroup>
      </sect3info>
	<title><command>mergemaster</command></title>
	<indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>L'utilitaire &man.mergemaster.8; est une proc&eacute;dure Bourne
	qui vous aidera &agrave; d&eacute;terminer les diff&eacute;rences entre
	vos fichiers de configuration dans le r&eacute;pertoire
	<filename>/etc</filename>, et les fichiers de configuration
	dans l'arborescence des sources
	<filename>/usr/src/etc</filename>.  C'est la solution
	recommand&eacute;e pour maintenir &agrave; jour les fichiers de
	configuration du syst&egrave;me avec ceux situ&eacute;s
	dans l'arborescence des sources.</para>

      <para>Pour commencer, tapez simplement
	<command>mergemaster</command> &agrave; l'invite, et observez-le
	travailler.  <command>mergemaster</command> commencera &agrave;
	constituer une arborescence temporaire, &agrave; partir de
	<filename>/</filename>, et la remplira avec divers fichiers
	de configuration.  Ces fichiers sont alors compar&eacute;s avec
	ceux actuellement install&eacute;s sur votre syst&egrave;me.
	A ce point, les fichiers qui diff&egrave;rent seront
	affich&eacute;s dans le format &man.diff.1;, avec le signe
	<option>+</option> repr&eacute;sentant les lignes modifi&eacute;es
	ou ajout&eacute;es, et le <option>-</option> repr&eacute;sentant
	les lignes qui seront soit compl&egrave;tement supprim&eacute;es,
	soit remplac&eacute;es avec une nouvelle ligne.
	Voir la page de manuel &man.diff.1; pour plus d'informations
	au sujet de la syntaxe &man.diff.1; et comment sont affich&eacute;es
	les diff&eacute;rences.</para>

      <para>&man.mergemaster.8; vous affichera ensuite chaque fichier
	pr&eacute;sentant des diff&eacute;rences, et vous aurez
	&agrave; ce moment-l&agrave; le choix de soit supprimer le
	nouveau fichier (le fichier temporaire), soit d'installer
	le fichier temporaire non modifi&eacute;, soit de fusionner
	le fichier temporaire et le fichier actuellement install&eacute;,
	soit enfin de revoir les r&eacute;sultats de l'op&eacute;ration
	&man.diff.1;.</para>

      <para>Choisir de supprimer le fichier temporaire indiquera &agrave;
	&man.mergemaster.8; que nous d&eacute;sirons conserver notre
	fichier actuel intacte, et effacera la nouvelle version.
	Cette option n'est pas recommand&eacute;e, &agrave; moins
	que vous ne voyez aucune raison de modifier le fichier actuel.
	Vous pouvez obtenir de l'aide &agrave; n'importe quel moment en
	tapant <keycap>?</keycap> &agrave; l'invite de &man.mergemaster.8;.
	Si l'utilisateur choisit de passer un fichier, il sera
	pr&eacute;sent&eacute; &agrave; nouveau une fois que tous les
	autres fichiers auront &eacute;t&eacute; trait&eacute;s.</para>

      <para>Choisir d'installer un fichier temporaire intact
	remplacera le fichier actuel avec le nouveau.  Pour la plupart
	des fichiers non modifi&eacute;es, c'est la meilleure option.</para>

      <para>Choisir de fusionner le fichier, vous affichera un &eacute;diteur
	de texte, et le contenu des deux fichiers.  Vous pouvez
	maintenant les fusionner en les visionnant c&ocirc;te
	&agrave; c&ocirc;te sur l'&eacute;cran, et en s&eacute;lectionnant
	des parties des deux fichiers pour cr&eacute;er un fichier final.
	Quand les fichiers sont compar&eacute;s c&ocirc;te &agrave;
	c&ocirc;te, la touche <keycap>l</keycap> s&eacute;lectionnera le
	contenu de gauche et la touche <keycap>r</keycap>
	s&eacute;lectionnera celui de droite.
	Le r&eacute;sultat final sera un fichier constitu&eacute; des deux
	parties, qui peut alors &ecirc;tre install&eacute;.
	Cette option est habituellement utilis&eacute;e pour les fichiers
	o&ugrave; les des param&egrave;tres ont &eacute;t&eacute;
	modifi&eacute;s par l'utilisateur.</para>

      <para>Choisir de revoir les r&eacute;sultats de l'op&eacute;ration
	&man.diff.1; vous affichera les diff&eacute;rences entre fichiers
	tout comme la fait &man.mergemaster.8; avant de vous demander
	un choix.</para>

      <para>Apr&egrave;s que &man.mergemaster.8; en ait termin&eacute; avec
	les fichiers syst&egrave;me, il vous proposera de nouvelles
	op&eacute;rations.  &man.mergemaster.8; vous demandera si vous
	d&eacute;sirez reconstruire le fichier des mots de passe
	et terminera en vous proposant
	de supprimer les fichiers temporaires
	restants.</para>
      </sect3>

      <sect3>
	<title>Mise &agrave; jour manuelle</title>

      <para>Si vous d&eacute;sirez faire la mise &agrave; jour manuellement,
	vous ne pouvez cependant pas vous contenter de copier
	les fichiers de <filename>/usr/src/etc</filename> dans
	<filename>/etc</filename> pour que cela fonctionne.  Certains
	de ces fichiers doivent d'abord &ecirc;tre
	&ldquo;install&eacute;s&rdquo;.
	En effet le r&eacute;pertoire <filename>/usr/src/etc</filename>
	&ldquo;n'est pas&rdquo; une copie de ce que devrait contenir
	votre r&eacute;pertoire <filename>/etc</filename>.  De plus,
	il a des fichiers qui doivent &ecirc;tre dans
	<filename>/etc</filename> et qui ne sont pas dans
	<filename>/usr/src/etc</filename>.</para>

      <para>Si vous utilisez &man.mergemaster.8; (comme recommand&eacute;),
	vous pouvez passer cette section et aller directement &agrave;
	la <link linkend="updating-upgrading-rebooting">section
	suivante</link>.</para>

      <para>La fa&ccedil;on la plus simple de proc&eacute;der est
	d'installer les fichiers dans un nouveau r&eacute;pertoire, puis de
	passer en revue les diff&eacute;rences.</para>

      <warning>
	<title>Sauvegardez votre r&eacute;pertoire
	  <filename>/etc</filename> actuel</title>

	<para>Bien qu'en principe rien ne sera modifi&eacute; automatiquement
	  dans ce r&eacute;pertoire, prudence est m&egrave;re de
	  s&ucirc;ret&eacute;.  Copiez donc votre r&eacute;pertoire
	  <filename>/etc</filename> dans un endroit s&ucirc;r.  Quelque
	  chose du genre:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para>conviendra; l'option <option>-R</option> fait une copie
	  r&eacute;cursive, <option>-p</option> pr&eacute;serve la date, les
	  autorisations des fichiers et ainsi de suite.</para>
      </warning>

      <para>Vous devez cr&eacute;er un ensemble de r&eacute;pertoires
	provisoires pour y installer les fichiers du r&eacute;pertoire <filename>/etc</filename>
	et autres.  <filename>/var/tmp/root</filename> est un bon
	choix, il y a un certain nombre de sous-r&eacute;pertoires
	&agrave; cr&eacute;er &eacute;galement:</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Cela va cr&eacute;er l'arborescence n&eacute;cessaire et y
	installera les fichiers.  Un grand nombre des
	sous-r&eacute;pertoires cr&eacute;&eacute;s dans
	<filename>/var/tmp/root</filename>
	sont vides et devront &ecirc;tre supprim&eacute;s.
	La fa&ccedil;on la plus simple de le faire est:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>Ceci supprimera tous les r&eacute;pertoires vides (la sortie
	d'erreur standard est redirig&eacute;e vers
	<filename>/dev/null</filename> pour emp&ecirc;cher les
	avertissements &agrave; propos des r&eacute;pertoires non
	vides).</para>

      <para><filename>/var/tmp/root</filename> contient maintenant
	tous les fichiers &agrave; installer &agrave; l'endroit requis sous
	<filename>/</filename>.  Vous devez maintenant examiner chacun
	de ces fichiers pour d&eacute;terminer en quoi ils diff&egrave;rent
	de vos propres fichiers.</para>

      <para>Notez que certains des fichiers qui seront install&eacute;s
	dans <filename>/var/tmp/root</filename> commencent par un
	&ldquo;.&rdquo;.  Au moment o&ugrave; sont &eacute;crites ces
	lignes, les seuls fichiers concern&eacute;s sont les fichiers
	d'initialisation des interpr&eacute;teurs de commandes dans
	<filename>/var/tmp/root/</filename> et
	<filename>/var/tmp/root/root/</filename>, mais il pourrait y
	en avoir d'autres (cela d&eacute;pend de quand vous lirez ces
	lignes).  Assurez-vous d'utiliser la commande <command>ls
	-a</command> pour ne pas les oublier.</para>

      <para>La mani&egrave;re la plus simple de proc&eacute;der est
	d'utiliser la commande &man.diff.1; pour comparer les deux
	fichiers:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>Cela vous indiquera les diff&eacute;rences entre votre fichier
	<filename>/etc/shells</filename> et le nouveau fichier
	<filename>/var/tmp/root//etc/shells</filename>.  A partir de
	l&agrave;, d&eacute;cidez si vous aller reporter les modifications
	que vous y avez apport&eacute;e ou si vous allez simplement
	recopier le nouveau fichier.</para>

      <tip>
	<title>Donnez au nouveau r&eacute;pertoire racine
	  (<filename>/var/tmp/root</filename>) un nom qui inclue une
	  date, pour pouvoir facilement comparer les diff&eacute;rentes
	  versions</title>

	<para>Si vous recompilez fr&eacute;quemment votre syst&egrave;me,
	  cela signifie que vous devez &eacute;galement souvent
	  mettre &agrave; jour le r&eacute;pertoire <filename>/etc</filename>,
	  ce qui peut rapidement devenir une corv&eacute;e.</para>

	<para>Vous pouvez acc&eacute;l&eacute;rer le processus en
	  conservant une copie du dernier ensemble de fichiers
	  modifi&eacute;s que vous avez report&eacute;s dans
	  <filename>/etc</filename>.  La proc&eacute;dure suivante
	  pr&eacute;sente une fa&ccedil;on de faire.</para>

	<procedure>
	  <step>
	    <para>Recompilez le syst&egrave;me comme &agrave;
	      l'accoutum&eacute;.  Au moment de mettre &agrave; jour
	      <filename>/etc</filename> et les autre r&eacute;pertoires,
	      donnez au r&eacute;pertoire cible un nom bas&eacute; sur la
	      date du jour.  Si vous faisiez cela le 14 f&eacute;vrier
	      1998, vous pourriez proc&eacute;der comme suit:</para>

	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>Reporter les modifications depuis ce r&eacute;pertoire
	      comme d&eacute;crit plus haut.</para>

	    <para><emphasis>Ne supprimez pas</emphasis> le
	      r&eacute;pertoire <filename>/var/tmp/root-19980214</filename>
	      quand vous aurez termin&eacute;.</para>
	  </step>

	  <step>
	    <para>Quand vous r&eacute;cup&eacute;rez la derni&egrave;re
	      version des sources et la recompilerez, suivez l'&eacute;tape
	      1.  Vous aurez alors un nouveau r&eacute;pertoire, qui
	      pourrait s'appeler <filename>/var/tmp/root-19980221</filename>
	      (si vous faites une mise &agrave; jour chaque semaine).</para>
	  </step>

	  <step>
	    <para>Vous pouvez maintenant voir les modifications
	      intervenues d'une semaine &agrave; l'autre en utilisant
	      &man.diff.1; pour afficher les diff&eacute;rences entre tous
	      les fichiers deux r&eacute;pertoires:</para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	    <para>G&eacute;n&eacute;ralement, il y aura beaucoup moins de
	      diff&eacute;rences qu'entre
	      <filename>/var/tmp/root-19980221/etc</filename> et
	      <filename>/etc</filename>.  Comme il y a beaucoup
	      moins de diff&eacute;rences, il est beaucoup plus facile
	      de les reporter dans le r&eacute;pertoire
	      <filename>/etc</filename>.</para>
	  </step>

	  <step>
	    <para>Vous pouvez maintenant supprimer le plus ancien
	      des deux r&eacute;pertoires
	      <filename>/var/tmp/root-*</filename>:</para>

	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>

	  <step>
	    <para>R&eacute;p&eacute;tez l'op&eacute;ration chaque fois que vous devez
	      reporter des modifications dans
	      <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>Vous pouvez utiliser &man.date.1; pour automatiser la
	  g&eacute;n&eacute;ration des noms de r&eacute;pertoires:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>

    <sect2 id="updating-upgrading-rebooting">
      <title>Red&eacute;marrer</title>

      <para>Vous en avez termin&eacute;.  Apr&egrave;s avoir
	v&eacute;rifi&eacute; que tout semble &ecirc;tre en place, vous
	pouvez alors red&eacute;marrez votre syst&egrave;me.  Un simple
	&man.shutdown.8; devrait suffire:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>C'est fini</title>

      <para>Vous devriez maintenant avoir mis &agrave; jour avec
	succ&egrave;s votre syst&egrave;me &os;.  F&eacute;licitations.</para>

      <para>Si les choses se sont l&eacute;g&egrave;rement mal
	pass&eacute;es, il est facile de recompiler un &eacute;l&eacute;ment
	particulier du syst&egrave;me.  Par exemple, si vous avez
	accidentellement effac&eacute; <filename>/etc/magic</filename>
	lors de la mise &agrave; jour de <filename>/etc</filename>, la
	commande &man.file.1; ne fonctionnerait plus.  Dans ce cas,
	la solution serait d'ex&eacute;cuter:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Questions</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Dois-je refaire le monde &agrave; chaque
	      &eacute;volution?</para>
	  </question>

	  <answer>
	    <para>Il n'y a pas de r&eacute;ponse toute faite &agrave;
	      cette question, tout d&eacute;pend de la nature des
	      &eacute;volutions.  Par exemple, si vous venez juste
	      d'ex&eacute;cuter <application>CVSup</application>, et que
	      les fichiers suivants on &eacute;t&eacute; mis &agrave;
	      jour:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>cela ne vaut probablement pas la peine de recompiler
	      tout le syst&egrave;me.  Vous pouvez tout simplement aller dans
	      les sous-r&eacute;pertoires appropri&eacute;s,
	      ex&eacute;cuter <command>make all install</command>, et
	      c'est &agrave; peu pr&egrave;s tout.  Mais s'il y a des
	      &eacute;volutions importantes, par exemple sur
	      <filename>src/lib/libc/stdlib</filename> alors vous
	      devrez soit refaire le monde, ou recompiler au moins
	      toutes les parties du syst&egrave;me qui sont li&eacute;es
	      statiquement (de m&ecirc;me que tout ce vous pourriez
	      avoir ajout&eacute; qui y serait li&eacute; statiquement).</para>

	    <para>C'est &agrave; vous de voir.  Vous pr&eacute;f&eacute;rerez
	      peut-&ecirc;tre recompiler votre syst&egrave;me tous les
	      quinze jours, et laisser les modifications s'empiler
	      pendant quinze jours.  Ou bien vous pr&eacute;f&eacute;rerez
	      ne recompiler que ce qui a chang&eacute; et vous faire
	      confiance pour tout ce qui en d&eacute;pend.</para>

	    <para>Et, bien s&ucirc;r, cela d&eacute;pend de la
	      fr&eacute;quence avec laquelle vous voulez faire vos mises
	      &agrave; jour, et de si vous suivez la branche &os.stable;
	      ou &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Ma compilation &eacute;choue avec de nombreuses erreurs
	      &ldquo;signal 11&rdquo; (ou tout autre num&eacute;ro de
	      signal).  Que s'est-il pass&eacute;?</para>
	  </question>
    <indexterm><primary>signal 11</primary></indexterm>

	  <answer>

	    <para>Cela indique g&eacute;n&eacute;ralement un probl&egrave;me
	      mat&eacute;riel.  (Re)compiler le syst&egrave;me est un bon
	      moyen de mettre votre mat&eacute;riel sous pression, et
	      mettra souvent en &eacute;vidence des d&eacute;faillances
	      de la m&eacute;moire vive.  Elles se manifestent normalement
	      d'elles-m&ecirc;mes, la compilation &eacute;chouant
	      lors de la r&eacute;ception de myst&eacute;rieux signaux.</para>

	    <para>Un bon indicateur de cet &eacute;tat de fait, est que
	      vous pouvez relancer la compilation et qu'elle &eacute;chouera
	      en un endroit diff&eacute;rent.</para>

	    <para>Dans ce cas, vous ne pouvez gu&egrave;re faire autre chose
	      que d'intervertir les diff&eacute;rents composants de votre
	      mat&eacute;riel pour d&eacute;terminer lequel est en cause.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Puis-je effacer <filename>/usr/obj</filename> apr&egrave;s
	      avoir fini?</para>
	  </question>

	  <answer>
	    <para>Une r&eacute;ponse courte est oui.</para>

	    <para><filename>/usr/obj</filename> contient tous les
	      fichiers objets g&eacute;n&eacute;r&eacute;s &agrave; la
	      compilation.  Normalement, une des premi&egrave;res
	      &eacute;tapes de <command>make buildworld</command> est de supprimer ce
	      r&eacute;pertoire et de repartir &agrave; z&eacute;ro.
	      Dans ce cas, conserver le r&eacute;pertoire
	      <filename>/usr/obj</filename> apr&egrave;s avoir termin&eacute; ne
	      sert pas &agrave; grand chose, alors que vous
	      &eacute;conomiseriez pas mal d'espace disque (actuellement
	      environ 340&nbsp;MO).</para>

	    <para>Cependant, si vous savez ce que vous faites, vous
	      pouvez faire en sorte que <command>make buildworld</command>
	      saute cette &eacute;tape.  Cela rendra les compilations
	      ult&eacute;rieures plus rapides, puisque la plupart des sources
	      n'auront pas besoin d'&ecirc;tre recompil&eacute;es.
	      Le revers de la m&eacute;daille est que des probl&egrave;mes
	      subtils de d&eacute;pendance peuvent se manifester, provoquant
	      l'&eacute;chec de votre compilation de mani&egrave;re
	      &eacute;trange.  Cela g&eacute;n&egrave;re fr&eacute;quemment
	      du bruit sur les listes de diffusion de &os;, quand quelqu'un se
	      plaint que sa mise &agrave; jour a &eacute;chou&eacute;, sans
	      r&eacute;aliser que c'est parce qu'il a tent&eacute; de
	      br&ucirc;ler les &eacute;tapes.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Une recompilation interrompue peut-elle &ecirc;tre
	      reprise?</para>
	  </question>

	  <answer>
	    <para>Tout d&eacute;pend de jusqu'o&ugrave; vous &ecirc;tes
	      aller avant de rencontrer un probl&egrave;me.</para>

	    <para><emphasis>En g&eacute;n&eacute;ral</emphasis> (et ceci n'est
	      pas une r&egrave;gle absolue) <command>make buildworld</command>
	      cr&eacute;e de nouveaux exemplaires des outils indispensables
	      (comme &man.gcc.1; et &man.make.1;) et des biblioth&egrave;ques
	      syst&egrave;me.  Ces outils et biblioth&egrave;ques sont
	      ensuite install&eacute;s.  Puis ils sont utilis&eacute;s pour
	      se reconstruire eux-m&ecirc;mes, et install&eacute;s de nouveau.
	      L'int&eacute;gralit&eacute; du syst&egrave;me (y compris
	      maintenant les programmes utilisateurs classiques, comme
	      &man.ls.1; ou &man.grep.1;) est alors recompil&eacute; avec
	      les nouveaux fichiers syst&egrave;me.</para>

	    <para>Si vous &ecirc;tes &agrave; cette derni&egrave;re
	      &eacute;tape, et que vous le savez (parce que vous avez
	      consult&eacute; les r&eacute;sultats que vous avez
	      enregistr&eacute;s) alors vous pouvez (sans trop de risque)
	      faire:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Cela ne d&eacute;truira pas les r&eacute;sultats du
	      travail qu'&agrave; d&eacute;j&agrave; effectu&eacute; <command>make
	      buildworld</command>.</para>

	    <para>Si vous voyez le message:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>dans les comptes-rendus de <command>make buildworld</command>
	      alors cette fa&ccedil;on de proc&eacute;der est probablement
	      bonne.</para>

	    <para>Si vous ne voyez pas ce message, ou que vous doutez
	      de vous, alors prudence est m&egrave;re de s&ucirc;ret&eacute;,
	      et il vaut mieux tout reprendre depuis le d&eacute;but.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Comment puis-je acc&eacute;l&eacute;rer la compilation
	      du syst&egrave;me?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Passez en mode mono-utilisateur.</para>
	      </listitem>

	      <listitem>
		<para>Mettez les r&eacute;pertoires
		  <filename>/usr/src</filename> et
		  <filename>/usr/obj</filename> sur des syst&egrave;mes de
		  fichiers et des disques diff&eacute;rents.  Si possible,
		  installez ces disques sur des contr&ocirc;leurs
		  diff&eacute;rents.</para>
	      </listitem>

	      <listitem>
		<para>Encore mieux, mettez ces syst&egrave;mes de fichiers
		  sur plusieurs disques utilisant le syst&egrave;me
		  &man.ccd.4; (pilote de disques
		  concat&eacute;n&eacute;s).</para>
	      </listitem>

	      <listitem>
		<para>Ne compilez pas les biblioth&egrave;ques profil&eacute;es
		  (mettez &ldquo;NO_PROFILE=true&rdquo; dans le fichier
		  <filename>/etc/make.conf</filename>).  Vous n'en
		  avez certainement pas besoin.</para>
	      </listitem>

	      <listitem>
		<para>Egalement dans <filename>/etc/make.conf</filename>,
		  positionnez <makevar>CFLAGS</makevar> &agrave; quelque
		  chose comme <option>-O -pipe</option>.
		  L'optimisation <option>-O2</option> est bien plus
		  lente, et la diff&eacute;rence d'optimisation entre
		  <option>-O</option> et <option>-O2</option> est en
		  g&eacute;n&eacute;ral n&eacute;gligeable.
		  <option>-pipe</option> demande au compilateur d'utiliser
		  des tuyaux &agrave; la place de fichiers temporaires, ce
		  qui &eacute;conomise des acc&egrave;s disque (mais
		  utilise plus de m&eacute;moire).</para>
	      </listitem>

	      <listitem>
		<para>Passez l'option
		  <option>-j<replaceable>n</replaceable></option>
		  &agrave; &man.make.1; pour permettre l'ex&eacute;cution de
		  plusieurs processus en parall&egrave;le.  Cela
		  am&eacute;liore g&eacute;n&eacute;ralement les choses, que
		  vous ayez une machine mono- ou multi-processeurs.</para>
	      </listitem>

	      <listitem>
		<para>Le syst&egrave;me de fichiers qui contient
		  <filename>/usr/src</filename> peut &ecirc;tre mont&eacute;
		  (ou remont&eacute;) avec l'option <option>noatime</option>.
		  Cela emp&ecirc;che l'enregistrement des dates d'acc&egrave;s
		  aux fichiers par le syst&egrave;me de fichiers.  Vous
		  n'avez de toute fa&ccedil;on probablement pas besoin de cette
		  information.</para>

		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		  <warning>
		    <para>Cet exemple suppose que
		      <filename>/usr/src</filename> constitue &agrave; lui
		      seul un syst&egrave;me de fichiers.  Si ce n'est pas
		      le cas (s'il fait partie de
		      <filename>/usr</filename> par exemple) vous
		      devez alors indiquer le point de montage de ce
		      syst&egrave;me de fichiers, et non
		      <filename>/usr/src</filename>.</para>
		  </warning>
	      </listitem>

	      <listitem>
		<para>Le syst&egrave;me de fichiers o&ugrave; se trouve
		  <filename>/usr/obj</filename> peut &ecirc;tre
		  mont&eacute; (ou remont&eacute;) avec l'option
		  <option>async</option>.  Les &eacute;critures sur le
		  disque se feront alors de fa&ccedil;on asynchrone.  En
		  d'autres termes, le programme reprend imm&eacute;diatement
		  la main, et l'&eacute;criture des donn&eacute;es sur le
		  disque se fait quelques secondes plus tard.  Cela
		  permet le groupement des &eacute;critures sur le disque,
		  et le gain en performance peut &ecirc;tre
		  spectaculaire.</para>

		<warning>
		  <para>Gardez &agrave; l'esprit que cette option rend votre
		    syst&egrave;me de fichiers plus fragile.  Avec cette
		    option, les risques ne sont accrus qu'en cas de
		    coupure d'alimentation, le syst&egrave;me de fichiers
		    soit irr&eacute;cup&eacute;rable quand la machine
		    red&eacute;marrera.</para>

		  <para>S'il n'y a que <filename>/usr/obj</filename>
		    sur ce syst&egrave;me de fichiers, ce n'est alors pas un
		    probl&egrave;me.  Si vous avez d'autres donn&eacute;es
		    importantes sur ce syst&egrave;me de fichiers,
		    assurez-vous que vos sauvegardes soient &agrave; jour
		    avant d'activer cette option.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Comme auparavant, si
		    <filename>/usr/obj</filename> ne constitue pas un
		    syst&egrave;me de fichiers en soit, remplacez-le dans
		    l'exemple par le nom du point de montage
		    appropri&eacute;.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Que faire si quelque chose se passe mal?</para>
	  </question>

	  <answer>
	    <para>Soyez absolument s&ucirc;r que votre environnement
	      ne contient pas des restes de compilation
	      pr&eacute;c&eacute;dentes.  Cela est plut&ocirc;t simple:</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>En effet, <command>make cleandir</command>
	      doit vraiment &ecirc;tre ex&eacute;cut&eacute;e
	      deux fois.</para>

	    <para>Ensuite relancez l'ensemble du processus,
	      en commen&ccedil;ant avec
	      <command>make buildworld</command>.</para>

	    <para>Si vous avez toujours des probl&egrave;mes,
	      envoyez l'erreur et le r&eacute;sultat de la commande
	      <command>uname -a</command> &agrave; la &a.questions;.
	      Tenez-vous pr&ecirc;t &agrave; r&eacute;pondre &agrave; d'autres
	      concernant votre configuration!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Contribution de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Suivre les mises &agrave; jour pour plusieurs machines</title>
    <indexterm>
      <primary>NFS</primary>
      <secondary>installation de multiples machines</secondary>
    </indexterm>

    <para>Si vous avez plusieurs machines dont vous voulez maintenir &agrave;
      jour l'arborescence des sources, alors faire
      t&eacute;l&eacute;charger et recompiler &agrave; chacune d'entre elles
      les sources semble un gaspillage de ressources: espace disque, bande
      passante r&eacute;seau, et cycles CPU.  C'est en effet bien le cas,
      et la solution est d'avoir une machine qui fait la majeure
      partie du travail, pendant que le reste des machines montent ce
      travail par NFS.  Cette section d&eacute;crit une fa&ccedil;on
      de le faire.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Pr&eacute;liminaires</title>

      <para>Premi&egrave;rement, identifiez un ensemble de machines
	qui va utiliser le m&ecirc;me ensemble de binaires, que nous
	appellerons un <emphasis>ensemble de compilation</emphasis>.
	Chaque machine peut avoir un noyau personnalis&eacute;, mais
	elles ex&eacute;cuteront les m&ecirc;mes binaires utilisateur du
	syst&egrave;me de base.  Dans cet ensemble de machine, choisissez
	une machine qui sera la <emphasis>machine de
	compilation</emphasis>.  Cela sera la machine sur laquelle
	le monde et le noyau seront compil&eacute;s.  Id&eacute;alement, cela
	devrait &ecirc;tre une machine rapide avec un CPU suffisamment
	disponible pour ex&eacute;cuter la commande <command>make
	buildworld</command> et <command>make buildkernel</command>.  Vous voudrez &eacute;galement utiliser
	une <emphasis>machine de test</emphasis>, qui testera
	les mises &agrave; jour logicielles avant d'&ecirc;tre utilis&eacute;es
	en production.  Cela <emphasis>doit</emphasis> &ecirc;tre une
	machine que vous pouvez vous permettre d'avoir hors service
	pour une longue p&eacute;riode.  Cela peut &ecirc;tre la machine
	de compilation, mais cela n'est pas obligatoire.</para>

      <para>Toutes les machines de cet ensemble de compilation
	doivent monter <filename>/usr/obj</filename> et
	<filename>/usr/src</filename> &agrave; partir de la m&ecirc;me
	machine, et du m&ecirc;me point de montage.  Id&eacute;alement, ces
	derniers sont sur deux disques diff&eacute;rents sur la machine de
	compilation, mais peuvent &eacute;galement &ecirc;tre
	mont&eacute;s par NFS sur cette machine.  Si vous avez plusieurs
	ensembles de compilation, <filename>/usr/src</filename>
	devrait &ecirc;tre sur une machine de compilation, et mont&eacute;
	par NFS sur les autres.</para>

      <para>Finalement assurez-vous que
	<filename>/etc/make.conf</filename> et
	<filename>/etc/src.conf</filename> sur toutes les machines
	de l'ensemble de compilation sont en accord avec la machine de
	compilation.  Cela signifie que la machine de compilation doit
	compiler toutes les parties du syst&egrave;me de base que toute
	machine de l'ensemble de compilation va installer.
	De plus, chaque machine de compilation devra avoir son nom de
	noyau d&eacute;fini avec <makevar>KERNCONF</makevar> dans
	<filename>/etc/make.conf</filename>, et la machine de
	compilation devrait tous les lister dans
	<makevar>KERNCONF</makevar>, en listant son noyau en premier.
	La machine de compilation doit avoir les fichiers de
	configuration des noyaux de chaque machine dans
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	si elle va compiler leur noyau.</para>
    </sect2>

    <sect2>
      <title>Le syst&egrave;me de base</title>

      <para>Maintenant que tout est configur&eacute;, vous &ecirc;tes
	fin pr&ecirc;t pour tout compiler.  Compilez le noyau et le monde
	sur la machine de compilation comme d&eacute;crit dans la <xref
	linkend="make-buildworld">, mais n'installez rien.  La
	compilation une fois termin&eacute;e, allez sur la machine de
	test, et installez le noyau que vous venez juste de compiler.
	Si la machine monte <filename>/usr/src</filename>
	et <filename>/usr/obj</filename> via NFS, quand vous
	red&eacute;marrez en mode mono-utilisateur vous devrez activer le
	r&eacute;seau et monter ces r&eacute;pertoires.  La m&eacute;thode
	la plus simple est de d&eacute;marrer en mode multi-utilisateur,
	puis ex&eacute;cutez <command>shutdown now</command> pour passer en
	mode mono-utilisateur.  Une fois &agrave; ce niveau, vous pouvez
	installer le nouveau noyau et monde puis ex&eacute;cuter
	<command>mergemaster</command> comme vous le feriez
	habituellement.  Une fois cela effectu&eacute;, red&eacute;marrez
	pour retourner en mode multi-utilisateur pour cette
	machine.</para>

      <para>Apr&egrave;s que vous soyez certain que tout fonctionne
	correctement sur la machine de test, utilisez la m&ecirc;me
	proc&eacute;dure pour installer le nouvel ensemble logiciel sur
	chacune des autres machines de l'ensemble de
	compilation.</para>
    </sect2>

    <sect2>
      <title>Les logiciels port&eacute;s</title>

      <para>La m&ecirc;me id&eacute;e peut &ecirc;tre utilis&eacute;e
	pour le catalogue des logiciels port&eacute;s.  La
	premi&egrave;re &eacute;tape critique est de monter
	<filename>/usr/ports</filename> depuis la m&ecirc;me machine vers
	toutes les machines de l'ensemble de compilation.  Vous
	pouvez alors configurer correctement
	<filename>/etc/make.conf</filename> pour partager les
	archives.  Vous devrez faire pointer <makevar>DISTDIR</makevar>
	sur un r&eacute;pertoire de partage commun dans lequel peut
	&eacute;crire n'importe quel utilisateur utilis&eacute; pour
	correspondance de l'utilisateur <username>root</username> par vos
	montages NFS.  Chaque machine devrait faire pointer
	<makevar>WRKDIRPREFIX</makevar> sur une r&eacute;pertoire de
	compilation local.  Et enfin, si vous projetez de compiler et
	distribuer des logiciels pr&eacute;compil&eacute;s, vous
	devriez fixer <makevar>PACKAGES</makevar> sur un r&eacute;pertoire
	similaire &agrave; <makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
