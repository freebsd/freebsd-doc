<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.198
-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Restructur&eacute;, r&eacute;organis&eacute;, et en partie mis
	  &agrave; jour par </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Travail original de </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
  </chapterinfo>

  <title>Questions avanc&eacute;es</title>
  &trans.a.fonvieille;

  <sect1 id="cutting-edge-synopsis">
    <title>Synopsis</title>

    <para>&os; est en constant d&eacute;veloppement entre deux
      versions.  Pour ceux d&eacute;sirant toujours &ecirc;tre
      &agrave; jour, il existe plusieurs m&eacute;canismes simples pour
      maintenir votre syst&egrave;me synchronis&eacute; avec les derniers
      d&eacute;veloppements.  Soyez pr&eacute;venus&mdash;cela ne s'adresse pas
      &agrave; tout le monde!  Ce chapitre vous aidera &agrave;
      d&eacute;cider si vous voulez suivre les d&eacute;veloppements, ou vous
      en tenir aux versions publi&eacute;es.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous
      conna&icirc;trez:</para>

    <itemizedlist>
      <listitem><para>La diff&eacute;rence entre les deux branches de
	d&eacute;veloppement: &os.stable; et &os.current;.</para>
      </listitem>
      <listitem><para>Comment maintenir votre syst&egrave;me &agrave;
	jour avec <application>CVSup</application>,
	<application>CVS</application>, ou
	<application>CTM</application>.</para>
      </listitem>
      <listitem><para>Comment recompiler et r&eacute;installer
	l'int&eacute;gralit&eacute; du syst&egrave;me de base avec
	la commande <command>make world</command>.</para>
      </listitem>

    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem><para>Correctement configurer votre connexion
	r&eacute;seau (<xref linkend="advanced-networking">).</para>
      </listitem>
      <listitem><para>Savoir comment installer des logiciels
	tiers (<xref linkend="ports">).</para></listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="current-stable">
    <title>&os.current; contre &os.stable;</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Il existe deux branches de d&eacute;veloppement de FreeBSD:
      &os.current; et &os.stable;.  Cette section d&eacute;taillera
      un peu chacune d'elles et d&eacute;crira comment garder &agrave;
      jour votre syst&egrave;me avec chaque arborescence respective.
      &os.current; sera tout d'abord trait&eacute;, suivit de
      &os.stable;.</para>

    <sect2 id="current">
      <title>Se synchroniser avec la version -CURRENT de &os;</title>

      <para>En lisant ces lignes, gardez &agrave; l'esprit que
	&os.current; repr&eacute;sente &ldquo;les tout derniers&rdquo;
	d&eacute;veloppement de &os;.  On attend des utilisateurs
	de &os.current; un degr&eacute; &eacute;lev&eacute; de
	comp&eacute;tences techniques, et devraient &ecirc;tre
	capables de r&eacute;soudre des probl&egrave;mes syst&egrave;me
	compliqu&eacute;s par eux-m&ecirc;mes.  Si vous &ecirc;tes
	nouveau &agrave; &os;, pensez &agrave; deux fois avant de
	l'installer.</para>

      <sect3>
	<title>Qu'est-ce que &os.current;?</title>
	<indexterm><primary>instantan&eacute;</primary></indexterm>

	<para>&os.current; est la toute derni&egrave;re version des sources
	  de &os; en cours de d&eacute;veloppement.  Cela inclut des
	  &eacute;volutions en cours, des modifications exp&eacute;rimentales,
	  et des m&eacute;canismes de transition qui feront ou ne feront pas
	  partie de la prochaine version officielle du logiciel.
	  Bien que de nombreux d&eacute;veloppeurs de &os; compilent les
	  sources de &os.current; quotidiennement, il arrive que
	  celles-ci ne soient pas compilables pendant une certaine
	  p&eacute;riode de temps.  Ces probl&egrave;mes sont r&eacute;solus
	  aussi rapidement que possible, mais que &os.current; soit
	  &agrave; l'origine d'un d&eacute;sastre ou de l'apport d'une nouvelle
	  fonctionnalit&eacute; attendue peut parfois d&eacute;pendre
	  que du moment auquel vous avez charg&eacute; le code
	  source.</para>
      </sect3>

      <sect3>
	<title>Qui a besoin de &os.current;?</title>

	<para>&os.current; est mis &agrave; disposition pour 3
	  types de personnes:</para>

	<orderedlist>
	  <listitem>
	    <para>Les membres du groupe &os; qui travaillent
	      activement sur une partie de l'arborescence des sources
	      et pour qui rester constamment &agrave; jour est une
	      n&eacute;cessit&eacute; absolue.</para>
	  </listitem>

	  <listitem>
	    <para>Les membres du groupe &os; qui participent
	      activement aux tests et sont dispos&eacute;s &agrave; passer du
	      temps &agrave; r&eacute;soudre les probl&egrave;mes pour
	      garantir que &os.current; reste aussi saine que
	      possible.  Il y a &eacute;galement ceux qui d&eacute;sirent
	      faire des suggestions dans certains domaines sur les
	      modifications &agrave; faire et la direction
	      g&eacute;n&eacute;rale que prend &os;, et soumettent des
	      correctifs pour les impl&eacute;menter.</para>
	  </listitem>

	  <listitem>
	    <para>Ceux qui veulent simplement garder un oeil sur les
	      &eacute;volutions, ou utiliser les derni&egrave;res sources comme
	      r&eacute;f&eacute;rence (e.g. pour les <emphasis>lire</emphasis>,
	      et non pour les utiliser).  Ces personnes font parfois
	      des remarques ou contribuent au code.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Qu'est-ce que <emphasis>n'est pas</emphasis>
	  &os.current;?</title>

	<orderedlist>
	  <listitem>
	    <para>Un raccourci pour se procurer des pr&eacute;-versions
	      parce que vous avez entendu dire qu'il y a de nouvelles
	      fonctionnalit&eacute;s g&eacute;niales et que vous voulez
	      &ecirc;tre le premier du coin &agrave; les avoir.  Etre le
	      premier &agrave; avoir la nouvelle fonctionnalit&eacute;
	      signifie &ecirc;tre le premier &agrave; avoir les nouveaux bogues
	      &eacute;galement.</para>
	  </listitem>

	  <listitem>
	    <para>Une moyen rapide d'avoir des corrections de bogues.
	      N'importe quelle version de &os.current; apportera
	      probablement de nouveaux bogues comme elle corrigera
	      ceux d&eacute;j&agrave; pr&eacute;sents.</para>
	  </listitem>

	  <listitem>
	    <para>Nous ne le &ldquo;supportons officiellement&rdquo;
	      en aucun cas.  Nous faisons du mieux que nous pouvons
	      pour aider les personnes qui font vraiment partie des
	      trois groupes &ldquo;l&eacute;gitimes&rdquo; &agrave; qui s'adresse
	      &os.current;, mais nous n'avons tout simplement
	      &ldquo;pas le temps&rdquo; de fournir un support
	      technique.  Ce n'est pas parce que nous sommes des
	      personnes d&eacute;testables qui n'aiment pas aider les autres
	      (nous ne ferions pas &os; si tel &eacute;tait le cas), nous ne
	      pouvons simplement pas r&eacute;pondre &agrave; des centaines de
	      messages par jour <emphasis>et</emphasis> travailler sur
	      FreeBSD!  Entre am&eacute;liorer &os; et r&eacute;pondre &agrave; de
	      nombreuses questions sur le code exp&eacute;rimental, les
	      d&eacute;veloppeurs optent pour le premier choix.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Utiliser &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>utilisation</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Inscrivez-vous &agrave; la &a.current; et la &a.cvsall;.
	      Ce n'est pas seulement une bonne id&eacute;e, c'est
	      <emphasis>indispensable</emphasis>.  Si vous n'&ecirc;tes
	      pas sur la liste <emphasis>&a.current.name;</emphasis>, vous
	      ne verrez pas les commentaires qui sont faits sur l'&eacute;tat
	      courant du syst&egrave;me et vous vous retrouverez probablement
	      confront&eacute;s &agrave; de nombreux probl&egrave;mes que
	      d'autres ont d&eacute;j&agrave; identifi&eacute;s et
	      r&eacute;solus.  Encore plus grave, vous manqueriez des
	      bulletins importants potentiellement critiques pour la bonne
	      sant&eacute; de votre syst&egrave;me.</para>

	    <para>La liste &a.cvsall.name; vous permettra de voir les courriers
	      de trace des soumissions de toutes les modifications
	      d&egrave;s qu'elles sont faites et des informations
	      pertinentes sur les &eacute;ventuels effets de bord.</para>

	    <para>Pour vous inscrire &agrave; ces listes, ou &agrave;
	      une autre, rendez vous &agrave; &a.mailman.lists.link;
	      et cliquez sur la liste &agrave; laquelle vous
	      d&eacute;sirez vous inscrire.  Des instructions sur le
	      reste de la proc&eacute;dure sont alors
	      donn&eacute;es.</para>
	  </listitem>

	  <listitem>
	    <para>R&eacute;cup&eacute;rez les sources sur un <link
	      linkend="mirrors">site miroir</link> &os;.  Vous pouvez le
	      faire de deux mani&egrave;res:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Synchronisation avec <application>CVSup</application></secondary>
	      </indexterm>

	      <listitem>
		<para>Utilisez le programme <link linkend="cvsup">cvsup</link>
		  avec le fichier <filename>supfile</filename>
		  nomm&eacute; <filename>standard-supfile</filename>
		  disponible dans le r&eacute;pertoire <filename
		  role='directory'>/usr/share/examples/cvsup</filename>.
		  C'est la m&eacute;thode recommand&eacute;e, puisqu'elle
		  permet de r&eacute;cup&eacute;rer la totalit&eacute;
		  des sources la premi&egrave;re fois et par la suite
		  uniquement ce qui a &eacute;t&eacute; modifi&eacute;.
		  De nombreuses personnes ex&eacute;cutent
		  <command>cvsup</command> depuis
		  <command>cron</command> et maintiennent ainsi
		  automatiquement &agrave; jour leurs sources.  Vous devez
		  personnaliser l'exemple de <filename>supfile</filename>
		  pr&eacute;c&eacute;dent, et configurer
		  <link linkend="cvsup">cvsup</link> pour
		  votre environnement.</para>
	      </listitem>

	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Synchroniser avec
		  <application>CTM</application></secondary>
	      </indexterm>
	      <listitem>
		<para>Utilisez <application><link
		  linkend="ctm">CTM</link></application>.  Si vous
		  disposez d'une mauvaise connexion (connexions ch&egrave;res
		  ou seulement un acc&egrave;s au courrier &eacute;lectronique)
		  <application>CTM</application> est une bonne
		  solution.  Cependant, c'est une source de probl&egrave;mes
		  et peut donner lieu &agrave; des fichiers endommag&eacute;s.
		  C'est pourquoi cette m&eacute;thode est rarement
		  utilis&eacute;e, ce qui augmente les chances que cela ne
		  fonctionne pas pendant d'assez longue p&eacute;riodes.
		  Nous recommandons d'utiliser
		  <application><link linkend="cvsup">CVSup</link></application>
		  &agrave; tous ceux disposant d'un modem 9600&nbsp;bps ou
		  d'une connexion plus rapide.
		</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Si vous r&eacute;cup&eacute;rez les sources pour compiler
	      un syst&egrave;me op&eacute;rationnel, et pas simplement
	      pour les lire, alors r&eacute;cup&eacute;rez
	      <emphasis>tout</emphasis>  &os.current;, et pas
	      uniquement certaines portions.  La raison de cela est
	      que diverses parties des sources d&eacute;pendent de
	      modifications effectu&eacute;es ailleurs, et si vous essayez
	      de compiler juste une partie des source, il est quasiment
	      certain que vous aurez des probl&egrave;mes.</para>

	  <indexterm>
	    <primary>-CURRENT</primary>
	    <secondary>compilation</secondary>
	  </indexterm>
	    <para>Avant de compiler &os.current;, lisez attentivement
	      le <filename>Makefile</filename> dans
	      <filename>/usr/src</filename>.  Vous devriez au moins
	      la premi&egrave;re fois <link
	      linkend="makeworld">installer un nouveau noyau et recompiler le syst&egrave;me</link>, comme
	      &eacute;tape n&eacute;cessaire &agrave; votre processus de
	      mise &agrave; jour.  La lecture de la &a.current; et du fichier <filename>/usr/src/UPDATING</filename> vous tiendra
	      au courant des autres proc&eacute;dures de transition qui
	      sont parfois n&eacute;cessaires lorsque nous pr&eacute;parons la
	      prochaine version.</para>
	  </listitem>

	  <listitem>
	    <para>Participez!  Si vous utilisez &os.current;, nous
	      aimerions savoir ce que vous en pensez, tout
	      particuli&egrave;rement si vous avez des am&eacute;liorations
	      &agrave; nous sugg&eacute;rer ou des corrections de bogues
	      &agrave; nous soumettre.  Les suggestions accompagn&eacute;es
	      de code sont accueillies avec enthousiasme!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>Se synchroniser avec la version -STABLE de &os;</title>

      <sect3>
	<title>Qu'est-ce que &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; est notre branche de d&eacute;veloppement &agrave;
	  partir de laquelle sont extraites les versions majeures.
	  Les modifications sur cette branche se font &agrave; une allure
	  diff&eacute;rente, et en supposant g&eacute;n&eacute;ralement
	  qu'elles ont &eacute;t&eacute; tout d'abord test&eacute;es
	  sur &os.current;.  Cela reste cependant
	  <emphasis>toujours</emphasis> une branche de d&eacute;veloppement,
	  et cela signifie qu'&agrave; certains moments, les sources de
	  &os.stable; pourront &ecirc;tre ou pas utilisables pour une
	  quelconque raison.  C'est tout simplement une autre branche
	  de mise au point, et non pas une ressource pour
	  l'utilisateur final.</para>
      </sect3>

      <sect3>
	<title>Qui a besoin de &os.stable;?</title>

	<para>Si vous d&eacute;sirez suivre ou contribuer au processus
	  de d&eacute;veloppement de FreeBSD, tout particuli&egrave;rement si
	  cela a rapport avec la prochaine version de FreeBSD, alors
	  vous devriez penser &agrave; suivre &os.stable;.</para>

	<para>Bien qu'il soit vrai que les correctifs de s&eacute;curit&eacute;
	  vont &eacute;galement dans la branche &os.stable;, vous
	  n'avez pas <emphasis>besoin</emphasis> de suivre
	  &os.stable; pour cela.  Chaque rapport de s&eacute;curit&eacute;
	  concernant FreeBSD explique comment corriger le probl&egrave;me sur
	  les versions affect&eacute;es
	  <footnote><para>Ceci n'est pas tout &agrave; fait vrai.  Nous
	    ne pouvons continuer &agrave; supporter les anciennes versions de
	    FreeBSD &eacute;ternellement, bien que nous les supportions
	    pendant de nombreuses ann&eacute;es.  Pour une description
	    compl&egrave;te de la politique de s&eacute;curit&eacute;
	    actuelle pour les anciennes versions de FreeBSD, veuillez
	    consulter <ulink
	    url="../../../../security/index.html">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>
	  , et suivre int&eacute;gralement une branche de d&eacute;veloppement
	  juste pour des raisons de s&eacute;curit&eacute; apportera
	  &eacute;galement de nombreux changements non
	  d&eacute;sir&eacute;s.</para>

	<para>Bien que nous tentons de nous assurer que la branche
	  &os.stable; soit compilable et constamment stable, cela
	  ne peut &ecirc;tre garanti.  De plus, alors que le code est
	  d&eacute;velopp&eacute; sous &os.current; avant de l'inclure dans
	  &os.stable;, le nombre de personnes utilisant &os.stable;
	  est plus nombreux que celui utilisant &os.current;, aussi
	  il est in&eacute;vitable que des bogues et des probl&egrave;mes
	  pourront parfois appara&icirc;tre sous &os.stable; alors qu'ils
	  n'existaient pas sous &os.current;.</para>

	<para>Pour ces raisons, nous ne recommandons
	  <emphasis>pas</emphasis> de suivre aveugl&eacute;ment
	  &os.stable;, et il est tout particuli&egrave;rement important que
	  vous ne mettiez pas &agrave; jour des serveurs de production
	  sous &os.stable; sans avoir tout d'abord test&eacute; le code
	  dans votre environnement de travail.</para>

	<para>Si vous ne disposez pas des ressources pour faire
	  cela alors nous recommandons que vous utilisiez la version
	  de FreeBSD la plus r&eacute;cente, et que vous utilisiez le
	  m&eacute;canisme de mise &agrave; jour binaire pour passer d'une
	  version &agrave; une autre.</para>
      </sect3>

      <sect3>
	<title>Utiliser &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>utilisation</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Inscrivez-vous &agrave; &agrave; la liste &a.stable.name;.
	      Vous serez tenu au courant des d&eacute;pendances de
	      compilation qui peuvent appara&icirc;tre dans la
	      branche &os.stable; ou de tout autre probl&egrave;me
	      demandant une attention particuli&egrave;re.  Les
	      d&eacute;veloppeurs publieront &eacute;galement des annonces
	      sur cette liste lorsqu'ils envisagent une correction ou
	      modification controvers&eacute;e, offrant la possibilit&eacute;
	      aux utilisateurs de r&eacute;pondre s'ils ont des questions
	      &agrave; soulever en rapport avec la modification
	      propos&eacute;e.</para>

	    <para>La liste &a.cvsall.name; vous permettra de voir les courriers
	      de trace des soumissions de toutes les modifications
	      d&egrave;s qu'elles sont faites et des informations
	      pertinentes sur les &eacute;ventuels effets de bord.</para>

	    <para>Pour vous inscrire &agrave; ces listes, ou &agrave;
	      une autre, rendez vous &agrave; &a.mailman.lists.link;
	      et cliquez sur la liste &agrave; laquelle vous
	      d&eacute;sirez vous inscrire.  Des instructions sur le
	      reste de la proc&eacute;dure sont alors
	      donn&eacute;es.</para>
	  </listitem>

	  <listitem>
	    <para>Si vous installez un nouveau syst&egrave;me et voulez qu'il
	      soit aussi stable que possible, vous pouvez simplement
	      r&eacute;cup&eacute;rer le dernier instantan&eacute; en date de
	      la branche &agrave; partir de <ulink
	      url="ftp://snapshots.jp.FreeBSD.org/pub/FreeBSD/snapshots/"></ulink>
	      et l'installer comme toute autre version.  Ou vous pouvez
	      installer la version &os.stable; la plus r&eacute;cente
	      &agrave; partir des <link linkend="mirrors">sites
	      miroirs</link> et suivre les instructions ci-dessous
	      pour mettre &agrave; jour votre syst&egrave;me avec les
	      sources &os;stable; les plus r&eacute;centes.</para>

	    <para>Si vous faites tourner une version pr&eacute;c&eacute;dente
	      de &os; et que vous d&eacute;sirez mettre &agrave; jour via
	      les sources vous pouvez ais&eacute;ment le faire &agrave; partir
	      d'un <link linkend="mirrors">site miroir</link> &os;.  Cela
	      peut &ecirc;tre fait de deux mani&egrave;res:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>Synchronisation avec <application>CVSup</application></secondary>
	      </indexterm>
	      <listitem>
		<para>Utilisez le programme <link linkend="cvsup">cvsup</link>
		  avec le fichier <filename>supfile</filename>
		  nomm&eacute; <filename>stable-supfile</filename>
		  disponible dans le r&eacute;pertoire <filename
		  role='directory'>/usr/share/examples/cvsup</filename>.
		  C'est la m&eacute;thode recommand&eacute;e, puisqu'elle
		  permet de r&eacute;cup&eacute;rer la totalit&eacute;
		  des sources la premi&egrave;re fois et par la suite
		  uniquement ce qui a &eacute;t&eacute; modifi&eacute;.
		  De nombreuses personnes ex&eacute;cutent
		  <command>cvsup</command> depuis
		  <command>cron</command> et maintiennent ainsi
		  automatiquement &agrave; jour leurs sources.  Vous devez
		  personnaliser l'exemple de <filename>supfile</filename>
		  pr&eacute;c&eacute;dent, et configurer
		  <link linkend="cvsup">cvsup</link> pour
		  votre environnement.</para>
	      </listitem>


	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>Synchroniser avec
		  <application>CTM</application></secondary>
	      </indexterm>
	      <listitem>
		<para>Utilisez <application><link
		  linkend="ctm">CTM</link></application>.  Si vous
		  ne disposez pas d'une connexion Internet rapide et
		  peu co&ucirc;teuse, c'est la m&eacute;thode que vous
		  devriez penser &agrave; utiliser.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Avant tout, si vous avez besoin d'un acc&egrave;s rapide
	      &agrave; la demande aux sources et que la bande passante n'est
	      pas un probl&egrave;me, utilisez
	      <command>cvsup</command> ou <command>ftp</command>.
	      Sinon, utilisez <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>compilation</secondary>
	  </indexterm>
	  <listitem>
	    <para>Avant de compiler &os.stable;, lisez attentivement
	      le <filename>Makefile</filename> dans
	      <filename>/usr/src</filename>.  Vous devriez au moins
	      la premi&egrave;re fois <link
	      linkend="makeworld">installer un nouveau noyau et recompiler le syst&egrave;me</link>, comme
	      &eacute;tape n&eacute;cessaire &agrave; votre processus de
	      mise &agrave; jour.  La lecture de la &a.stable; et du fichier <filename>/usr/src/UPDATING</filename> vous tiendra
	      au courant des autres proc&eacute;dures de transition qui
	      sont parfois n&eacute;cessaires lorsque nous pr&eacute;parons la
	      prochaine version.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Synchroniser vos sources</title>

    <para>Il existe diff&eacute;rentes fa&ccedil;ons d'utiliser une connexion
      Internet (ou le courrier &eacute;lectronique) pour garder &agrave; jour
      les sources de n'importe quelle partie, ou de l'ensemble,
      du projet &os;, selon ce qui vous int&eacute;resse.  Les
      principaux services que nous fournissons sont le
      <link linkend="anoncvs">CVS anonyme</link>, <link
      linkend="cvsup">CVSup</link>, et <link linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Alors qu'il est possible de mettre &agrave; jour seulement
	certaines parties de l'arbre des sources, la seule proc&eacute;dure
	de mise &agrave; jour support&eacute;e est celle consistant
	&agrave; mettre &agrave; jour l'int&eacute;gralit&eacute; de
	l'arborescence et de recompiler les sources des applicatifs de
	base&mdash;&ldquo;userland&rdquo; (i.e., tous les programmes
	qui tournent dans l'espace utilisateur, comme ceux des
	r&eacute;pertoires <filename>/bin</filename> et
	<filename>/sbin</filename>) et du noyau.  Ne mettre &agrave; jour
	qu'une partie des sources, uniquement le noyau, ou seul le
	&ldquo;userland&rdquo; m&egrave;nera souvent &agrave; des
	probl&egrave;mes.  Ces probl&egrave;mes pourront aller d'erreurs de
	compilation &agrave; des paniques du noyau ou m&ecirc;me des
	corruptions de donn&eacute;es.</para>
    </warning>

    <indexterm><primary>CVS anonyme</primary></indexterm>
    <para><application>CVS anonyme</application> et
      <application>CVSup</application> utilisent une m&eacute;thode de
      mise &agrave; jour pilot&eacute;e par le
      client&mdash;<emphasis>pull</emphasis>.  Dans le cas de
      <application>CVSup</application>, l'utilisateur (ou une
      proc&eacute;dure <command>cron</command>) appelle le programme
      <command>cvsup</command>, qui interagit avec un serveur
      <command>cvsupd</command> distant, pour mettre &agrave; jour vos
      fichiers.  Les mises &agrave; jour que vous recevez sont les plus
      r&eacute;centes, et vous ne les recevez seulement lorsque vous le
      d&eacute;sirez.  Vous pouvez ais&eacute;ment restreindre vos mises
      &agrave; jour aux fichiers ou r&eacute;pertoires particuliers
      qui vous int&eacute;ressent.  Les mises &agrave; jour sont
      g&eacute;n&eacute;r&eacute;es &agrave; la vol&eacute;e par le serveur,
      en fonction de ce que vous avez d&eacute;j&agrave; et de ce que vous
      voulez.  <application>CVS anonyme</application> est plus
      simpliste que <application>CVSup</application>, car ce n'est
      qu'une extension de <application>CVS</application> qui
      permet de r&eacute;cup&eacute;rer des modifications directement
      d'une archive CVS distante.  Pour cela,
      <application>CVSup</application> est bien plus efficace mais
      <application>CVS anonyme</application> est plus facile &agrave;
      utiliser.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application>, &agrave; l'inverse, ne compare
      pas interactivement les sources dont vous disposez avec celles
      qui sont sur l'archive de r&eacute;f&eacute;rence.  Au lieu de cela,
      une proc&eacute;dure qui identifie les modifications intervenues
      depuis qu'elle a &eacute;t&eacute; ex&eacute;cut&eacute;e pour la
      derni&egrave;re fois, est lanc&eacute;e plusieurs fois par jour
      sur la machine CTM de r&eacute;f&eacute;rence (ma&icirc;tre),
      les modifications d&eacute;tect&eacute;es sont
      compress&eacute;es, affect&eacute;es d'un num&eacute;ro de
      s&eacute;quence et encod&eacute;es pour pouvoir &ecirc;tre envoy&eacute;es
      par courrier &eacute;lectronique (en ASCII imprimable uniquement).
      Une fois re&ccedil;us, ces &ldquo;deltas CTM&rdquo; peuvent
      &ecirc;tre pass&eacute;s &agrave; l'utilitaire &man.ctm.rmail.1;
      qui d&eacute;codera, contr&ocirc;lera et appliquera automatiquement
      les modifications &agrave; l'exemplaire des sources de l'utilisateur.
      Cette m&eacute;thode est beaucoup plus efficace que
      <application>CVSup</application> et consomme beaucoup moins de
      ressources sur notre serveur, parce que c'est un mod&egrave;le
      pilot&eacute; par le serveur&mdash;<emphasis>push</emphasis>
      plut&ocirc;t que par
      l'utilisateur&mdash;<emphasis>pull</emphasis>.</para>

    <para>Il y a, bien s&ucirc;r, quelques contreparties.
      Si vous effacez par inadvertance des parties de votre archive,
      <application>CVSup</application> s'en apercevra et vous
      reconstruira les parties endommag&eacute;es.
      <application>CTM</application> ne le fera pas, et si vous
      effacez des parties de votre l'arborescence des sources
      (et que vous n'avez pas fait de sauvegarde) alors vous devrez
      repartir de z&eacute;ro (&agrave; partir du plus r&eacute;cent
      &ldquo;delta de base&rdquo; CVS) et tout reconstituer avec
      <application>CTM</application> ou <application>CVS
      anonyme</application>, effacer les parties endommag&eacute;es et
      resynchroniser.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Utiliser <command>make world</command></title>

    <indexterm>
      <primary><command>make world</command></primary>
    </indexterm>
    <para>Une fois que vous avez synchronis&eacute; votre arborescence des
      sources avec une version donn&eacute;e de &os; (&os.stable;,
      &os.current;, et ainsi de suite) vous pouvez alors utiliser
      cette arborescence des sources pour recompiler le
      syst&egrave;me.</para>

    <warning>
      <title>Faites une sauvegarde</title>

      <para>On n'insistera jamais assez sur l'importance de faire une
	sauvegarde de votre syst&egrave;me <emphasis>avant</emphasis> tout
	autre chose.  Bien qu'il soit facile de &ldquo;refaire le
	monde&rdquo; (recompiler FreeBSD), si vous suivez ces
	instructions, vous ferez in&eacute;vitablement des erreurs
	&agrave; un moment ou un autre, ou d'autres feront des erreurs
	au niveau de l'arborescence des sources qui emp&ecirc;cheraient
	votre syst&egrave;me de red&eacute;marrer.</para>

      <para>Assurez-vous que vous avez bien fait une sauvegarde.  Ayez
	une disquette de maintenance &agrave; port&eacute;e de la main.
	Vous ne l'utiliserez probablement pas, mais prudence est m&egrave;re
	de s&ucirc;ret&eacute;!</para>
    </warning>

    <warning>
      <title>S'abonner &agrave; la bonne liste de diffusion</title>

      <indexterm><primary>liste de diffusion</primary></indexterm>
      <para>Les branches &os.stable; et &os.current; sont, par
	nature, <emphasis>en d&eacute;veloppement</emphasis>.  Les personnes
	qui participent &agrave; &os; sont des humains, et
	des erreurs se produisent occasionnellement.</para>

      <para>Ces erreurs sont parfois b&eacute;nignes, provocant
	simplement l'affichage d'un nouveau message d'avertissement
	par votre syst&egrave;me.  Elles peuvent aussi &ecirc;tre
	catastrophiques, et emp&ecirc;cher votre syst&egrave;me de
	red&eacute;marrer ou d&eacute;truire vos syst&egrave;mes de fichiers
	(ou pire).</para>

      <para>Quand de tels probl&egrave;mes se produisent, un avertissement
	&ldquo;heads up&rdquo; est post&eacute; sur la liste de diffusion
	appropri&eacute;e, d&eacute;crivant la nature du probl&egrave;me et
	quels syst&egrave;mes sont concern&eacute;s.  Un message &ldquo;all
	clear&rdquo; est post&eacute; quand le probl&egrave;me est
	r&eacute;solu.</para>

      <para>Si vous tentez de suivre &os.stable; ou &os.current; et
	que vous ne lisez pas la &a.stable; ou la &a.current;,
	vous allez au devant d'ennuis.</para>
    </warning>

    <sect2>
      <title>La m&eacute;thode g&eacute;n&eacute;rique de mise
	&agrave; jour du syst&egrave;me</title>

      <para>Pour mettre &agrave; jour votre syst&egrave;me, vous
	devriez utiliser la proc&eacute;dure suivante:</para>

      <screen>&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <para>Vous devriez d&eacute;marrer en mode mono-utilisateur (en
	utilisant par exemple la commande <command>boot -s</command>
	&agrave; l'invite du chargeur).  Ex&eacute;cutez
	ensuite:</para>

      <screen>&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lisez les explications suppl&eacute;mentaires</title>

	<para>La s&eacute;quence d&eacute;crite ci-dessus n'est qu'un
	  court r&eacute;sum&eacute; pour vous aider &agrave;
	  d&eacute;marrer.  Vous devriez cependant lire les sections
	  suivantes afin de comprendre clairement chaque &eacute;tape,
	  tout particuli&egrave;rement si vous d&eacute;sirez utiliser
	  une configuration du noyau personnalis&eacute;e.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Lire <filename>/usr/src/UPDATING</filename></title>

      <para>Avant tout autre chose, lisez
	<filename>/usr/src/UPDATING</filename> (ou le fichier
	&eacute;quivalent en fonction de l'endroit o&ugrave; se trouve vos
	sources).  Ce fichier devrait contenir les informations
	importantes au sujet des probl&egrave;mes que vous pourriez
	rencontrer, ou indique l'ordre dans lequel vous devriez
	ex&eacute;cuter certaines commandes.  Si le fichier
	<filename>UPDATING</filename> contredit quelque chose d'&eacute;crit
	ici, <filename>UPDATING</filename> prime sur tout le
	reste.</para>

      <important>
	<para>La lecture du fichier <filename>UPDATING</filename>
	  n'est pas un substitut &agrave; l'abonnement &agrave; la liste
	  de diffusion correcte, comme d&eacute;crit
	  pr&eacute;c&eacute;demment.  Ces deux pr&eacute;requis sont
	  compl&eacute;mentaires, et non pas exclusifs.</para>
      </important>
    </sect2>

    <sect2>
      <title>Contr&ocirc;ler <filename>/etc/make.conf</filename></title>
      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Contr&ocirc;lez les fichiers
	<filename>/etc/defaults/make.conf</filename> et
	<filename>/etc/make.conf</filename>.  Le premier contient
	des param&egrave;tres par d&eacute;faut &ndash; la plupart
	&eacute;tant plac&eacute;s en commentaires.  Pour les utiliser quand
	vous recompilez votre syst&egrave;me &agrave; partir des sources,
	rajout&eacute;s-les au fichier <filename>/etc/make.conf</filename>.
	Gardez &agrave; l'esprit que tout ce que vous ajoutez au fichier
	<filename>/etc/make.conf</filename> est utilis&eacute; chaque fois
	que vous invoquez la commande <command>make</command>, il est
	donc bon de s'assurer que les valeurs par d&eacute;faut sont
	appropri&eacute;es &agrave; votre syst&egrave;me.</para>

      <para>Un utilisateur typique voudra probablement copier
	les lignes <makevar>CFLAGS</makevar> et
	<makevar>NOPROFILE</makevar> se trouvant dans
	<filename>/etc/defaults/make.conf</filename> vers
	<filename>/etc/make.conf</filename> et les d&eacute;commenter.</para>

      <para>Examinez les autres d&eacute;finitions
	(<makevar>COPTFLAGS</makevar>, <makevar>NOPORTDOCS</makevar>
	et ainsi de suite) et d&eacute;cidez si elles vous conviennent.</para>
    </sect2>

    <sect2>
      <title>Mettre &agrave; jour les fichiers dans <filename>/etc</filename></title>

      <para>Le r&eacute;pertoire <filename>/etc</filename> contient la
	plupart des informations de configuration de votre syst&egrave;me,
	ainsi que les proc&eacute;dures de d&eacute;marrage.  Certaines de ces
	proc&eacute;dures changent d'une version &agrave; l'autre de
	FreeBSD.</para>

      <para>Certains fichiers de configuration sont &eacute;galement
	utilis&eacute;s en permanence par le syst&egrave;me.  En particulier
	<filename>/etc/group</filename>.</para>

      <para>Il est arriv&eacute; que la phase d'installation de &ldquo;make
	world&rdquo; ait besoin que certains utilisateurs et groupes
	existent.  Il y a de fortes chances qu'ils n'aient pas
	&eacute;t&eacute; d&eacute;finis avant la mise &agrave; jour.
	C'est une source de probl&egrave;mes.</para>

      <para>Un exemple r&eacute;cent de cela fut l'addition de l'utilisateur
	<username>smmsp</username>.  Le processus d'installation
	&eacute;chouait quand <command>mtree</command> tentait de cr&eacute;er
	<filename>/var/spool/clientmqueue</filename>.</para>

      <para>La solution est d'examiner le fichier
	<filename>/usr/src/etc/group</filename> et de comparer sa
	liste de groupe avec la votre.  S'il y a des groupes dans le
	nouveau fichier qui sont absents du votre, alors rajoutez-les.
	De m&ecirc;me vous devriez renommer tous les groupes dans
	<filename>/etc/group</filename> qui ont le m&ecirc;me GID mais un nom
	diff&eacute;rent que ceux pr&eacute;sents dans
	<filename>/usr/src/etc/group</filename>.</para>

      <para>Depuis 4.6-RELEASE vous pouvez ex&eacute;cuter
	&man.mergemaster.8; dans le mode pr&eacute;-&ldquo;buildworld&rdquo;
	en ajoutant l'option <option>-p</option>.  Cela effectuera la
	comparaison uniquement des fichiers essentiels pour le succ&egrave;s
	de la proc&eacute;dure <maketarget>buildworld</maketarget> ou
	<maketarget>installworld</maketarget>.  Si votre vieille
	version de <command>mergemaster</command> ne supporte pas
	l'option <option>-p</option>, utilisez la nouvelle version
	pr&eacute;sente dans l'arborescence des sources quand vous
	l'ex&eacute;cutez pour la premi&egrave;re fois:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Si vous &ecirc;tes particuli&egrave;rement parano&iuml;aque,
	  vous pouvez contr&ocirc;ler votre syst&egrave;me afin de voir quels
	  fichiers appartiennent au groupe que vous renommez ou
	  effacez:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>affichera les fichiers appartenant au groupe
	  <replaceable>GID</replaceable> (qui peut &ecirc;tre soit un nom de
	  groupe ou un identifiant num&eacute;rique de groupe).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Passer en mode mono-utilisateur</title>
      <indexterm><primary>mode mono-utilisateur</primary></indexterm>

      <para>Il vaut mieux recompiler le syst&egrave;me en mode
	mono-utilisateur.  En dehors du fait que cela sera
	l&eacute;g&egrave;rement plus rapide, la r&eacute;installation
	va modifier un grand nombre de fichiers syst&egrave;mes
	importants, tous les binaires de base du syst&egrave;me, les
	biblioth&egrave;ques, les fichiers d'include et ainsi de suite.
	Les modifier sur un syst&egrave;me en fonctionnement (en
	particulier s'il y a des utilisateurs connect&eacute;s &agrave;
	ce moment l&agrave;), c'est aller au devant de
	probl&egrave;mes.</para>

      <indexterm><primary>mode multi-utilisateurs</primary></indexterm>
      <para>Une autre m&eacute;thode consiste &agrave; compiler le
	syst&egrave;me en mode multi-utilisateurs, et passer dans le mode
	mono-utilisateur pour l'installation.  Si vous d&eacute;sirez
	utiliser cette m&eacute;thode, conservez les &eacute;tapes suivantes
	pour le moment o&ugrave; la compilation sera termin&eacute;e.  Vous
	pouvez reporter le passage en mode mono-utilisateur jusqu'&agrave;
	l'ex&eacute;cution de
	<maketarget>installkernel</maketarget> ou
	<maketarget>installworld</maketarget>.</para>

      <para>En tant que super-utilisateur, vous pouvez ex&eacute;cuter la
	commande:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>sur un syst&egrave;me en fonctionnement, pour passer en mode
	mono-utilisateur.</para>

      <para>Ou bien, red&eacute;marrer le syst&egrave;me, et &agrave;
	l'invite de d&eacute;marrage, entrez l'indicateur
	<option>-s</option>.  Le syst&egrave;me d&eacute;marrera alors
	en mode mono-utilisateur.  A l'invite de l'interpr&eacute;teur de
	commandes, ex&eacute;cutez alors:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Cela effectue une v&eacute;rification des syst&egrave;mes
	de fichiers, remonte <filename>/</filename> en mode
	lecture/&eacute;criture, et monte tous les autres syst&egrave;mes
	de fichiers UFS list&eacute;s dans le fichier
	<filename>/etc/fstab</filename>, puis active la
	pagination.</para>

      <note>
	<para>Si votre horloge CMOS est r&eacute;gl&eacute;e sur l'heure locale
	  et non pas sur le fuseau GMT (cela est vrai si la sortie
	  de la commande <command>date</command> ne donne pas l'heure
	  et le fuseau correct), vous aurez &eacute;galement peut-&ecirc;tre
	  besoin d'ex&eacute;cuter la commande suivante:</para>

<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	<para>Cela permettra de s'assurer que vos param&egrave;tres
	  de fuseaux horaires sont correctement configur&eacute;s &mdash;
	  sans cela, vous risquez de faire face, plus tard, &agrave; des
	  probl&egrave;mes.
	</para>
      </note>

    </sect2>

    <sect2>
      <title>Effacer <filename>/usr/obj</filename></title>

      <para>Au fur et &agrave; mesure que les diff&eacute;rentes parties
	du syst&egrave;me sont recompil&eacute;es, elles sont
	plac&eacute;es dans des r&eacute;pertoires qui (par d&eacute;faut) sont
	sous <filename>/usr/obj</filename>.  Les r&eacute;pertoires sont
	agenc&eacute;s comme sous <filename>/usr/src</filename>.</para>

      <para>Vous pouvez acc&eacute;l&eacute;rer le processus &ldquo;make
	world&rdquo;, et &eacute;galement vous &eacute;viter d'&eacute;ventuels
	probl&egrave;mes de d&eacute;pendances en effa&ccedil;ant ce
	r&eacute;pertoire.</para>

      <para>Certains fichiers dans <filename>/usr/obj</filename>
	peuvent avoir l'indicateur immuable positionn&eacute; (consultez la
	page de manuel &man.chflags.1; pour plus d'informations)
	qui doit &ecirc;tre retir&eacute; en premier.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2>
      <title>Recompiler les sources</title>

      <sect3>
	<title>Enregistrer la sortie</title>

	<para>C'est une bonne id&eacute;e d'enregistrer la sortie de
	  &man.make.1; dans un fichier.  Si quelque chose se passe
	  mal, vous aurez une trace des messages d'erreur.  M&ecirc;me
	  si cela ne vous aide pas &agrave; diagnostiquer ce qui n'a pas
	  fonctionn&eacute;, cela peut aider les autres si vous postez
	  votre probl&egrave;me sur une des listes de diffusion de
	  &os;.</para>

	<para>La m&eacute;thode la plus ais&eacute;e pour faire cela est
	  d'utiliser la commande &man.script.1;, avec en param&egrave;tre
	  le nom du fichier o&ugrave; enregistrer les r&eacute;sultats.
	  Vous devez faire cela imm&eacute;diatement juste avant de
	  recompiler le syst&egrave;me, et taper <userinput>exit</userinput>
	  une fois que c'est termin&eacute;.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Si vous le faites, <emphasis>n'enregistrez pas</emphasis>
	  le r&eacute;sultat dans <filename>/tmp</filename>.
	  Ce r&eacute;pertoire peut &ecirc;tre vid&eacute; au prochain
	  red&eacute;marrage du syst&egrave;me.  Un meilleur endroit de
	  sauvegarde est <filename>/var/tmp</filename> (comme dans l'exemple
	  pr&eacute;c&eacute;dent) ou dans le r&eacute;pertoire utilisateur
	  de <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>Compiler le nouveau syst&egrave;me</title>

	<para>Vous devez &ecirc;tre dans le r&eacute;pertoire
	  <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(&agrave; moins, bien s&ucirc;r, que votre code source ne
	  soit ailleurs, auquel cas vous devrez aller dans le
	  r&eacute;pertoire correspondant).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Pour recompiler le syst&egrave;me, on utilise la commande
	  &man.make.1;.  Cette commande lit ses instructions dans
	  le fichier <filename>Makefile</filename>, qui d&eacute;crit comment
	  devraient &ecirc;tre reconstruits les programmes qui constituent
	  &os;, dans quel ordre, et ainsi de suite.</para>

	<para>Le format g&eacute;n&eacute;ral de la ligne de commande que
	  vous taperez sera la suivante:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>cible</replaceable></userinput></screen>

	<para>Dans cet exemple,
	  <option>-<replaceable>x</replaceable></option> est une
	  option que vous passez &agrave; &man.make.1;.  Reportez-vous
	  &agrave; la page de manuel pour un exemple d'options que vous
	  pouvez passer.</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  transmet un variable au fichier
	  <filename>Makefile</filename>.  Le comportement du
	  <filename>Makefile</filename> est d&eacute;fini par ces variables.
	  Ce sont les m&ecirc;mes variables que l'on trouve dans
	  <filename>/etc/make.conf</filename>, et c'est un autre moyen
	  de les positionner.</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE <replaceable>cible</replaceable></userinput></screen>

	<para>est une autre mani&egrave;re de dire qu'il ne faut pas compiler
	  les biblioth&egrave;ques profil&eacute;es et correspond &agrave;
	  la ligne:</para>

	<programlisting>NOPROFILE=    true	#    Avoid compiling profiled libraries</programlisting>

	<para>dans <filename>/etc/make.conf</filename>.</para>

	<para><replaceable>cible</replaceable> indique &agrave; &man.make.1;
	  ce que vous voulez faire.  Chaque
	  <filename>Makefile</filename> d&eacute;finit un certain nombre de
	  &ldquo;cibles&rdquo;, et votre choix de cible d&eacute;termine ce
	  qui se passe.</para>

	<para>Certaines cibles list&eacute;es dans le fichier
	  <filename>Makefile</filename>, ne doivent pas &ecirc;tre
	  employ&eacute;es.  Ce sont des &eacute;tapes interm&eacute;diaires
	  utilis&eacute;es par le processus de recompilation pour
	  d&eacute;composer les &eacute;tapes importantes de la recompilation
	  du syst&egrave;me en sous-&eacute;tapes.</para>

	<para>La plupart du temps, vous n'aurez pas besoin de passer
	  de param&egrave;tres &agrave; &man.make.1;, et votre commande
	  ressemblera &agrave; ceci:</para>

	<screen>&prompt.root; <userinput>make <replaceable>cible</replaceable></userinput></screen>

	<para>A partir de la version 2.2.5 de &os; (en fait, c'est
	  apparu en premier sur la branche &os.current;, et ensuite
	  int&eacute;gr&eacute; dans la branche &os.stable; entre les
	  versions 2.2.2 et 2.2.5) la cible <maketarget>world</maketarget> a
	  &eacute;t&eacute; d&eacute;compos&eacute;e en deux parties:
	  <maketarget>buildworld</maketarget> et
	  <maketarget>installworld</maketarget>.</para>

	<para>Comme leurs noms l'indiquent,
	  <maketarget>buildworld</maketarget> reconstruit la nouvelle
	  arborescence dans <filename>/usr/obj</filename>, et
	  <maketarget>installworld</maketarget> l'installe sur la
	  machine.</para>

	<para>Ceci est tr&egrave;s utile pour deux raisons.  Tout d'abord
	  cela vous permet de recompiler en toute s&ucirc;ret&eacute; en sachant
	  qu'aucun composant du syst&egrave;me actuel ne sera affect&eacute;.
	  La compilation est &ldquo;autonome&rdquo;.  En raison de
	  cela vous pouvez ex&eacute;cuter
	  <maketarget>buildworld</maketarget> sur une machine en mode
	  multi-utilisateurs sans redouter d'effets f&acirc;cheux.  Il est
	  n&eacute;anmoins recommand&eacute; de toujours ex&eacute;cuter
	  l'&eacute;tape <maketarget>installworld</maketarget> en mode
	  mono-utilisateur.</para>

	<para>En second lieu, cela vous permet d'utiliser des
	  syst&egrave;mes mont&eacute;s par NFS pour mettre &agrave;
	  jour plusieurs machines de votre r&eacute;seau.  Si vous avez
	  trois machines <hostid>A</hostid>, <hostid>B</hostid> et
	  <hostid>C</hostid> que vous voulez mettre &agrave; jour,
	  ex&eacute;cutez <command>make buildworld</command> et
	  <command>make installworld</command> sur <hostid>A</hostid>.
	  <hostid>B</hostid> et <hostid>C</hostid> doivent
	  ensuite monter par NFS <filename>/usr/src</filename>
	  et <filename>/usr/obj</filename> depuis <hostid>A</hostid>,
	  et vous pouvez alors ex&eacute;cuter
	  <command>make installworld</command> pour installer le
	  syst&egrave;me recompil&eacute; sur <hostid>B</hostid> et
	  <hostid>C</hostid>.</para>

	<para>Bien que la cible <maketarget>world</maketarget> existe
	  toujours, vous &ecirc;tes fortement encourag&eacute;
	  &agrave; ne pas l'utiliser.</para>

	<para>Ex&eacute;cutez:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Il est maintenant possible de passer l'option
	  <option>-j</option> &agrave; &man.make.1; ce qui lui permettra
	  d'ex&eacute;cuter plusieurs processus simultan&eacute;ment.
	  C'est particuli&egrave;rement utile sur une machine avec plusieurs
	  processeurs.  Cependant, comme la compilation est plus
	  gourmande en E/S plut&ocirc;t qu'en CPU, c'est &eacute;galement
	  utile sur des machines mono-processeur.</para>

	<para>Typiquement sur une machine mono-processeur, vous
	  ex&eacute;cuteriez:</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; pourra ex&eacute;cuter jusqu'&agrave; 4 processus
	  simultan&eacute;ment.  Des constatations empiriques
	  post&eacute;es sur les listes de diffusion montrent que c'est
	  en g&eacute;n&eacute;ral ce qui apporte le plus de gain en
	  performances.</para>

	<para>Si vous avez une machine multi-processeurs et que vous
	  avez configur&eacute; un noyau SMP, essayez des valeurs entre 6 et
	  19 et voyez quel b&eacute;n&eacute;fice vous en tirez.</para>

	<para>Soyez conscient que c'est toujours quelque peu
	  exp&eacute;rimental, et que des modifications de l'arborescence
	  des sources rendent parfois cette possibilit&eacute; inutilisable.
	  Si la recompilation &eacute;choue avec ce param&egrave;tre, essayez
	  sans avant de signaler votre probl&egrave;me.</para>
      </sect3>

      <sect3>
	<title>Dur&eacute;e</title>
	<indexterm>
	  <primary><command>make world</command></primary>
	  <secondary>dur&eacute;e</secondary>
	</indexterm>

        <para>De nombreux facteurs influencent la dur&eacute;e de
	  compilation, mais actuellement un &pentium;&nbsp;III &agrave;
	  500&nbsp;MHz avec 128&nbsp;MO de RAM met environ
	  2&nbsp;heures pour compiler l'arborescence &os.stable;,
	  sans modification ni raccourcis durant le processus.
	  Une arborescence &os.current; n&eacute;cessitera un peu plus de
	  temps.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Compiler et installer un nouveau noyau</title>
      <indexterm>
	<primary>noyau</primary>
	<secondary>compilation</secondary>
      </indexterm>

      <para>Pour tirer pleinement parti de votre nouveau syst&egrave;me,
	vous devrez recompiler le noyau.  C'est pratiquement
	indispensable, parce que certaines structures m&eacute;moires
	peuvent avoir chang&eacute;es, et des programmes comme &man.ps.1;
	et &man.top.1; ne fonctionneront pas tant que le syst&egrave;me
	et le noyau n'utilisent pas les m&ecirc;mes versions de code
	source.</para>

      <para>La mani&egrave;re la plus simple et la plus s&ucirc;re est de
	compiler et installer un noyau bas&eacute; sur le noyau
	<filename>GENERIC</filename>.  Alors que le noyau
	<filename>GENERIC</filename> peut ne pas comporter les pilotes
	de p&eacute;riph&eacute;riques n&eacute;cessaires pour votre
	syst&egrave;me, il devrait contenir tout ce qui est
	n&eacute;cessaire pour faire d&eacute;marrer votre syst&egrave;me
	en mode mono-utilisateur.  C'est une bonne fa&ccedil;on de tester
	le fonctionnement de votre nouveau syst&egrave;me.  Apr&egrave;s
	avoir d&eacute;marr&eacute; &agrave; partir du noyau
	<filename>GENERIC</filename> et v&eacute;rifi&eacute; que
	votre syst&egrave;me fonctionne vous pouvez alors compiler un nouveau
	noyau bas&eacute; sur votre fichier de configuration normal du
	noyau.</para>

      <para>Si vous mettez &agrave; jour vers &os;&nbsp;4.0 ou suivante
	alors l'ancienne proc&eacute;dure de compilation du noyau (comme
	d&eacute;crit dans <xref linkend="kernelconfig">) est
	obsol&egrave;te.  A la place, vous devriez utiliser les commandes
	suivantes <emphasis>apr&egrave;s</emphasis> que vous ayez
	<link linkend="make-buildworld">recompil&eacute; le syst&egrave;me
	avec <maketarget>buildworld</maketarget></link>.</para>

      <note>
	<para>Si vous d&eacute;sirez compiler un noyau personnalis&eacute;,
	  et que vous avez d&eacute;j&agrave; un fichier de
	  configuration, utilisez juste
	  <maketarget>KERNCONF=<replaceable>MONNOYAU</replaceable></maketarget>
	  comme suit:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MONNOYAU</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MONNOYAU</replaceable></userinput></screen>

	<para>Sous FreeBSD&nbsp;4.2 et versions ant&eacute;rieures vous
	  devez remplacer <literal>KERNCONF=</literal> par
	  <literal>KERNEL=</literal>.  Une version 4.2-STABLE qui a
	  &eacute;t&eacute; r&eacute;cup&eacute;r&eacute;e avant
	  le 2 f&eacute;vrier 2001 ne reconna&icirc;t pas le param&egrave;tre
	  <literal>KERNCONF=</literal>.</para>
      </note>

      <para>Notez que si vous avez augment&eacute; la variable
	<literal>kern.securelevel</literal> &agrave; une valeur
	sup&eacute;rieure &agrave; 1 <emphasis>et</emphasis> que vous
	avez positionn&eacute; l'indicateur <literal>noschg</literal>
	ou similaire sur votre noyau, il sera int&eacute;ressant de passer
	en mode mono-utilisateur pour utiliser
	<maketarget>installkernel</maketarget>.  Sinon vous devriez
	&ecirc;tre en mesure d'ex&eacute;cuter ces commandes &agrave;
	partir du mode multi-utilisateur sans probl&egrave;mes.  Voir
	la page de manuel de &man.init.8; pour plus de d&eacute;tails
	&agrave; propos de <literal>kern.securelevel</literal> et la page
	&man.chflags.1; pour des informations sur les diff&eacute;rents
	indicateurs de fichiers.</para>

      <para>Si vous mettez &agrave; jour vers une version de &os;
	ant&eacute;rieure &agrave; la 4.0, vous devriez utiliser l'ancienne
	proc&eacute;dure de compilation du noyau.  Cependant, il est
	recommand&eacute; d'utiliser la nouvelle version de
	&man.config.8;, en utilisant une ligne de commande comme
	celle-ci:</para>

      <screen>&prompt.root; <userinput>/usr/obj/usr/src/usr.sbin/config/config <replaceable>KERNELNAME</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Red&eacute;marrer en mode mono-utilisateur</title>
      <indexterm><primary>mode mono-utilisateur</primary></indexterm>

      <para>Vous devriez red&eacute;marrer en mode mono-utilisateur pour
	tester le fonctionnement du nouveau noyau.  Pour cela suivez
	les instructions de
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2>
      <title>Installer les nouveaux binaires syst&egrave;me</title>

      <para>Si vous avez compil&eacute; une version de &os; assez
	r&eacute;cente pour avoir utilis&eacute;
	<command>make buildworld</command> alors vous devriez
	utiliser maintenant <maketarget>installworld</maketarget>
	pour installer les nouveaux binaires syst&egrave;me.</para>

      <para>Lancez:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Si vous sp&eacute;cifiez des variables sur la
	  ligne de commande de <command>make buildworld</command>,
	  vous devez utiliser les m&ecirc;mes variables avec la commande
	  <command>make installworld</command>.  Cela ne reste
	  pas forc&eacute;ment vrai pour d'autres options; par exemple,
	  <option>-j</option> ne doit jamais &ecirc;tre utilis&eacute;e
	  avec <maketarget>installworld</maketarget>.</para>

	<para>Par exemple, si vous ex&eacute;cutez:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE buildworld</userinput></screen>

	<para>vous devrez ensuite installer les r&eacute;sultats avec:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE installworld</userinput></screen>

	<para>sinon il essayera d'installer les biblioth&egrave;ques
	  profil&eacute;es qui n'ont pas &eacute;t&eacute;
	  recompil&eacute;es &agrave; l'&eacute;tape
	  <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Mettre &agrave; jour les fichiers non modifi&eacute;s par
	<command>make world</command></title>

      <para>La recompilation du syst&egrave;me ne mettra pas &agrave;
	jour certains r&eacute;pertoires (en particulier,
	<filename>/etc</filename>, <filename>/var</filename> et
	<filename>/usr</filename>) avec les fichiers nouveaux
	ou modifi&eacute;s.</para>

      <para>La mani&egrave;re la plus simple de mettre &agrave; jour
	ces fichiers est d'utiliser &man.mergemaster.8;, bien
	qu'il soit possible de le faire manuellement si vous le
	d&eacute;sirez.  Ind&eacute;pendamment de la mani&egrave;re
	que vous choisissez, assurez-vous de faire une sauvegarde
	du r&eacute;pertoire <filename>/etc</filename> au cas
	o&ugrave; quelque chose se passerait mal.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contribution de </contrib>
	  </author>
	</authorgroup>
      </sect3info>
	<title><command>mergemaster</command></title>
	<indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>L'utilitaire &man.mergemaster.8; est une proc&eacute;dure Bourne
	qui vous aidera &agrave; d&eacute;terminer les diff&eacute;rences entre
	vos fichiers de configuration dans le r&eacute;pertoire
	<filename>/etc</filename>, et les fichiers de configuration
	dans l'arborescence des sources
	<filename>/usr/src/etc</filename>.  C'est la solution
	recommand&eacute;e pour maintenir &agrave; jour les fichiers de
	configuration du syst&egrave;me avec ceux situ&eacute;s
	dans l'arborescence des sources.</para>

      <para>L'outil &man.mergemaster.8; a &eacute;t&eacute;
	int&eacute;gr&eacute; dans la base de FreeBSD entre la version
	3.3-RELEASE et la version 3.4-RELEASE, ce qui signifie
	qu'il est pr&eacute;sent dans tous les syst&egrave;mes
	-STABLE et -CURRENT depuis la version 3.3.</para>

      <para>Pour commencer, tapez simplement
	<command>mergemaster</command> &agrave; l'invite, et observez-le
	travailler.  <command>mergemaster</command> commencera &agrave;
	constituer une arborescence temporaire, &agrave; partir de
	<filename>/</filename>, et la remplira avec divers fichiers
	de configuration.  Ces fichiers sont alors compar&eacute;s avec
	ceux actuellement install&eacute;s sur votre syst&egrave;me.
	A ce point, les fichiers qui diff&egrave;rent seront
	affich&eacute;s dans le format &man.diff.1;, avec le signe
	<option>+</option> repr&eacute;sentant les lignes modifi&eacute;es
	ou ajout&eacute;es, et le <option>-</option> repr&eacute;sentant
	les lignes qui seront soit compl&egrave;tement supprim&eacute;es,
	soit remplac&eacute;es avec une nouvelle ligne.
	Voir la page de manuel &man.diff.1; pour plus d'informations
	au sujet de la syntaxe &man.diff.1; et comment sont affich&eacute;es
	les diff&eacute;rences.</para>

      <para>&man.mergemaster.8; vous affichera ensuite chaque fichier
	pr&eacute;sentant des diff&eacute;rences, et vous aurez
	&agrave; ce moment-l&agrave; le choix de soit supprimer le
	nouveau fichier (le fichier temporaire), soit d'installer
	le fichier temporaire non modifi&eacute;, soit de fusionner
	le fichier temporaire et le fichier actuellement install&eacute;,
	soit enfin de revoir les r&eacute;sultats de l'op&eacute;ration
	&man.diff.1;.</para>

      <para>Choisir de supprimer le fichier temporaire indiquera &agrave;
	&man.mergemaster.8; que nous d&eacute;sirons conserver notre
	fichier actuel intacte, et effacera la nouvelle version.
	Cette option n'est pas recommand&eacute;e, &agrave; moins
	que vous ne voyez aucune raison de modifier le fichier actuel.
	Vous pouvez obtenir de l'aide &agrave; n'importe quel moment en
	tapant <keycap>?</keycap> &agrave; l'invite de &man.mergemaster.8;.
	Si l'utilisateur choisit de passer un fichier, il sera
	pr&eacute;sent&eacute; &agrave; nouveau une fois que tous les
	autres fichiers auront &eacute;t&eacute; trait&eacute;s.</para>

      <para>Choisir d'installer un fichier temporaire intact
	remplacera le fichier actuel avec le nouveau.  Pour la plupart
	des fichiers non modifi&eacute;es, c'est la meilleure option.</para>

      <para>Choisir de fusionner le fichier, vous affichera un &eacute;diteur
	de texte, et le contenu des deux fichiers.  Vous pouvez
	maintenant les fusionner en les visionnant c&ocirc;te
	&agrave; c&ocirc;te sur l'&eacute;cran, et en s&eacute;lectionnant
	des parties des deux fichiers pour cr&eacute;er un fichier final.
	Quand les fichiers sont compar&eacute;s c&ocirc;te &agrave;
	c&ocirc;te, la touche <keycap>l</keycap> s&eacute;lectionnera le
	contenu de gauche et la touche <keycap>r</keycap>
	s&eacute;lectionnera celui de droite.
	Le r&eacute;sultat final sera un fichier constitu&eacute; des deux
	parties, qui peut alors &ecirc;tre install&eacute;.
	Cette option est habituellement utilis&eacute;e pour les fichiers
	o&ugrave; les des param&egrave;tres ont &eacute;t&eacute;
	modifi&eacute;s par l'utilisateur.</para>

      <para>Choisir de revoir les r&eacute;sultats de l'op&eacute;ration
	&man.diff.1; vous affichera les diff&eacute;rences entre fichiers
	tout comme la fait &man.mergemaster.8; avant de vous demander
	un choix.</para>

      <para>Apr&egrave;s que &man.mergemaster.8; en ait termin&eacute; avec
	les fichiers syst&egrave;me, il vous proposera de nouvelles
	op&eacute;rations.  &man.mergemaster.8; vous demandera si vous
	d&eacute;sirez reconstruire le fichier des mots de passe et/ou
	ex&eacute;cuter &man.MAKEDEV.8; si vous utilisez une version de
	FreeBSD ant&eacute;rieure &agrave; la 5.0, et terminera avec la
	possibilit&eacute; de supprimer les fichiers temporaires
	restants.</para>
      </sect3>

      <sect3>
	<title>Mise &agrave; jour manuelle</title>

      <para>Si vous d&eacute;sirez faire la mise &agrave; jour manuellement,
	vous ne pouvez cependant pas vous contenter de copier
	les fichiers de <filename>/usr/src/etc</filename> dans
	<filename>/etc</filename> pour que cela fonctionne.  Certains
	de ces fichiers doivent d'abord &ecirc;tre
	&ldquo;install&eacute;s&rdquo;.
	En effet le r&eacute;pertoire <filename>/usr/src/etc</filename>
	&ldquo;n'est pas&rdquo; une copie de ce que devrait contenir
	votre r&eacute;pertoire <filename>/etc</filename>.  De plus,
	il a des fichiers qui doivent &ecirc;tre dans
	<filename>/etc</filename> et qui ne sont pas dans
	<filename>/usr/src/etc</filename>.</para>

      <para>Si vous utilisez &man.mergemaster.8; (comme recommand&eacute;),
	vous pouvez passer directement &agrave; la <link
	linkend="update-dev">section suivante</link>.</para>

      <para>La fa&ccedil;on la plus simple de proc&eacute;der est
	d'installer les fichiers dans un nouveau r&eacute;pertoire, puis de
	passer en revue les diff&eacute;rences.</para>

      <warning>
	<title>Sauvegardez votre r&eacute;pertoire
	  <filename>/etc</filename> actuel</title>

	<para>Bien qu'en principe rien ne sera modifi&eacute; automatiquement
	  dans ce r&eacute;pertoire, prudence est m&egrave;re de
	  s&ucirc;ret&eacute;.  Copiez donc votre r&eacute;pertoire
	  <filename>/etc</filename> dans un endroit s&ucirc;r.  Quelque
	  chose du genre:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para>conviendra; l'option <option>-R</option> fait une copie
	  r&eacute;cursive, <option>-p</option> pr&eacute;serve la date, les
	  autorisations des fichiers et ainsi de suite.</para>
      </warning>

      <para>Vous devez cr&eacute;er un ensemble de r&eacute;pertoires
	provisoires pour y installer les fichiers du r&eacute;pertoire <filename>/etc</filename>
	et autres.  <filename>/var/tmp/root</filename> est un bon
	choix, il y a un certain nombre de sous-r&eacute;pertoires
	&agrave; cr&eacute;er &eacute;galement:</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Cela va cr&eacute;er l'arborescence n&eacute;cessaire et y
	installera les fichiers.  Un grand nombre des
	sous-r&eacute;pertoires cr&eacute;&eacute;s dans
	<filename>/var/tmp/root</filename>
	sont vides et devront &ecirc;tre supprim&eacute;s.
	La fa&ccedil;on la plus simple de le faire est:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>Ceci supprimera tous les r&eacute;pertoires vides (la sortie
	d'erreur standard est redirig&eacute;e vers
	<filename>/dev/null</filename> pour emp&ecirc;cher les
	avertissements &agrave; propos des r&eacute;pertoires non
	vides).</para>

      <para><filename>/var/tmp/root</filename> contient maintenant
	tous les fichiers &agrave; installer &agrave; l'endroit requis sous
	<filename>/</filename>.  Vous devez maintenant examiner chacun
	de ces fichiers pour d&eacute;terminer en quoi ils diff&egrave;rent
	de vos propres fichiers.</para>

      <para>Notez que certains des fichiers qui seront install&eacute;s
	dans <filename>/var/tmp/root</filename> commencent par un
	&ldquo;.&rdquo;.  Au moment o&ugrave; sont &eacute;crites ces
	lignes, les seuls fichiers concern&eacute;s sont les fichiers
	d'initialisation des interpr&eacute;teurs de commandes dans
	<filename>/var/tmp/root/</filename> et
	<filename>/var/tmp/root/root/</filename>, mais il pourrait y
	en avoir d'autres (cela d&eacute;pend de quand vous lirez ces
	lignes).  Assurez-vous d'utiliser la commande <command>ls
	-a</command> pour ne pas les oublier.</para>

      <para>La mani&egrave;re la plus simple de proc&eacute;der est
	d'utiliser la commande &man.diff.1; pour comparer les deux
	fichiers:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>Cela vous indiquera les diff&eacute;rences entre votre fichier
	<filename>/etc/shells</filename> et le nouveau fichier
	<filename>/var/tmp/root//etc/shells</filename>.  A partir de
	l&agrave;, d&eacute;cidez si vous aller reporter les modifications
	que vous y avez apport&eacute;e ou si vous allez simplement
	recopier le nouveau fichier.</para>

      <tip>
	<title>Donnez au nouveau r&eacute;pertoire racine
	  (<filename>/var/tmp/root</filename>) un nom qui inclue une
	  date, pour pouvoir facilement comparer les diff&eacute;rentes
	  versions</title>

	<para>Si vous recompilez fr&eacute;quemment votre syst&egrave;me,
	  cela signifie que vous devez &eacute;galement souvent
	  mettre &agrave; jour le r&eacute;pertoire <filename>/etc</filename>,
	  ce qui peut rapidement devenir une corv&eacute;e.</para>

	<para>Vous pouvez acc&eacute;l&eacute;rer le processus en
	  conservant une copie du dernier ensemble de fichiers
	  modifi&eacute;s que vous avez report&eacute;s dans
	  <filename>/etc</filename>.  La proc&eacute;dure suivante
	  pr&eacute;sente une fa&ccedil;on de faire.</para>

	<procedure>
	  <step>
	    <para>Recompilez le syst&egrave;me comme &agrave;
	      l'accoutum&eacute;.  Au moment de mettre &agrave; jour
	      <filename>/etc</filename> et les autre r&eacute;pertoires,
	      donnez au r&eacute;pertoire cible un nom bas&eacute; sur la
	      date du jour.  Si vous faisiez cela le 14 f&eacute;vrier
	      1998, vous pourriez proc&eacute;der comme suit:</para>

	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>Reporter les modifications depuis ce r&eacute;pertoire
	      comme d&eacute;crit plus haut.</para>

	    <para><emphasis>Ne supprimez pas</emphasis> le
	      r&eacute;pertoire <filename>/var/tmp/root-19980214</filename>
	      quand vous aurez termin&eacute;.</para>
	  </step>

	  <step>
	    <para>Quand vous r&eacute;cup&eacute;rez la derni&egrave;re
	      version des sources et la recompilerez, suivez l'&eacute;tape
	      1.  Vous aurez alors un nouveau r&eacute;pertoire, qui
	      pourrait s'appeler <filename>/var/tmp/root-19980221</filename>
	      (si vous faites une mise &agrave; jour chaque semaine).</para>
	  </step>

	  <step>
	    <para>Vous pouvez maintenant voir les modifications
	      intervenues d'une semaine &agrave; l'autre en utilisant
	      &man.diff.1; pour afficher les diff&eacute;rences entre tous
	      les fichiers deux r&eacute;pertoires:</para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	    <para>G&eacute;n&eacute;ralement, il y aura beaucoup moins de
	      diff&eacute;rences qu'entre
	      <filename>/var/tmp/root-19980221/etc</filename> et
	      <filename>/etc</filename>.  Comme il y a beaucoup
	      moins de diff&eacute;rences, il est beaucoup plus facile
	      de les reporter dans le r&eacute;pertoire
	      <filename>/etc</filename>.</para>
	  </step>

	  <step>
	    <para>Vous pouvez maintenant supprimer le plus ancien
	      des deux r&eacute;pertoires
	      <filename>/var/tmp/root-*</filename>:</para>

	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>

	  <step>
	    <para>R&eacute;p&eacute;tez l'op&eacute;ration chaque fois que vous devez
	      reporter des modifications dans
	      <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>Vous pouvez utiliser &man.date.1; pour automatiser la
	  g&eacute;n&eacute;ration des noms de r&eacute;pertoires:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>

    <sect2 id="update-dev">
      <title>Mettre &agrave; jour <filename>/dev</filename></title>

      <note>
	<title>DEVFS</title>
        <indexterm><primary>DEVFS</primary></indexterm>
	<para>Si vous utilisez FreeBSD&nbsp;5.0 ou suivante
	  vous pouvez sans risque passer cette section.  Ces versions
	  utilisent &man.devfs.5; pour allouer les fichiers sp&eacute;ciaux
	  de p&eacute;riph&eacute;riques de fa&ccedil;on transparente pour
	  l'utilisateur.</para>
      </note>

      <para>Dans la plupart des cas, l'outil &man.mergemaster.8;
	d&eacute;terminera quand il sera n&eacute;cessaire de mettre &agrave;
	jour les fichiers sp&eacute;ciaux de p&eacute;riph&eacute;riques,
	et proposera de le faire automatiquement.  Les instructions
	suivantes expliquent comment mettre &agrave; jour les fichiers
	sp&eacute;ciaux de p&eacute;riph&eacute;riques manuellement.</para>

      <para>Pour des raisons de s&eacute;curit&eacute;, cette mise
	&agrave; jour se fait en plusieurs &eacute;tapes.</para>

      <procedure>
	<step>
	  <para>Copiez <filename>/var/tmp/root/dev/MAKEDEV</filename> dans
	    <filename>/dev</filename>:</para>

	  <screen>&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>
	  <indexterm>
	    <primary><filename>MAKEDEV</filename></primary>
	  </indexterm>

	  <para>Si vous avez utilis&eacute; &man.mergemaster.8; pour
	    mettre &agrave; jour <filename>/etc</filename>, alors votre
	    proc&eacute;dure <filename>MAKEDEV</filename> a d&ucirc;
	    d&eacute;j&agrave; &ecirc;tre mise &agrave; jour,
	    bien que cela ne peut pas faire de mal de la contr&ocirc;ler
	    (avec &man.diff.1;) et la copier manuellement si
	    n&eacute;cessaire.</para>
	</step>

	<step>
	  <para>Maintenant, prenez une photographie de l'&eacute;tat de
	    votre r&eacute;pertoire <filename>/dev</filename>.  Cette
	    photographie doit contenir les droits, propri&eacute;taires et
	    les codes majeur et mineur de fichier sp&eacute;cial de
	    p&eacute;riph&eacute;rique, mais pas leur date de
	    derni&egrave;re mise &agrave; jour.  La fa&ccedil;on la plus
	    ais&eacute;e de proc&eacute;der est d'utiliser la commande
	    &man.awk.1; pour &eacute;liminer les informations
	    inutiles:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
	</step>

	<step>
	  <para>Recr&eacute;ez tous les fichiers sp&eacute;ciaux de
	    p&eacute;riph&eacute;riques:</para>

	    <screen>&prompt.root; <userinput>sh MAKEDEV all</userinput></screen>
	</step>

	<step>
	  <para>Reprenez une autre photographie du r&eacute;pertoire, cette
	    fois-ci dans <filename>/var/tmp/dev2.out</filename>.
	    Comparez maintenant ces deux fichiers pour voir si
	    certains fichiers sp&eacute;ciaux de
	    p&eacute;riph&eacute;riques manquant n'ont pas
	    &eacute;t&eacute; cr&eacute;&eacute;s.  Cela ne devrait pas
	    &ecirc;tre le cas, mais prudence est m&egrave;re de
	    s&ucirc;ret&eacute;.</para>

	  <screen>&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>

	  <para>Il manquera peut-&ecirc;tre des descripteurs de partitions,
	    il vous faudra alors ex&eacute;cuter des commandes du
	    type:</para>

	    <screen>&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput></screen>

	  <para>pour les recr&eacute;er.  Les d&eacute;tails d&eacute;pendent
	    de votre installation.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Mettre &agrave; jour <filename>/stand</filename></title>

      <note>
	<para>Cette &eacute;tape n'est d&eacute;crite que pour
	  &ecirc;tre exhaustif.  Elle peut &ecirc;tre omise sans risque.
	  Si vous utilisez &os;&nbsp;5.2 ou suivante, le
	  r&eacute;pertoire <filename
	  role='attribute'>/rescue</filename> est automatiquement mis
	  &agrave; jour avec des binaires compil&eacute;s en statique
	  lors de l'op&eacute;ration <command>make
	  installworld</command>, rendant par cons&eacute;quent
	  obsol&egrave;te la mise &agrave; jour du r&eacute;pertoire
	  <filename role='attribute'>/stand/</filename>.</para>
      </note>

      <para>Pour &ecirc;tre exhaustif, vous pouvez &eacute;galement mettre
	&agrave; jour les fichiers du r&eacute;pertoire
	<filename>/stand</filename>.  Ces fichiers sont des liens
	physiques vers le binaire
	<filename>/stand/sysinstall</filename>.  Cet ex&eacute;cutable
	doit &ecirc;tre compil&eacute; en statique, pour qu'il soit
	utilisable sans qu'aucun autre syst&egrave;me de fichiers
	(et en particulier <filename>/usr</filename>) ne soit
	mont&eacute;.</para>

      <screen>&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Red&eacute;marrer</title>

      <para>Vous en avez termin&eacute;.  Apr&egrave;s avoir
	v&eacute;rifi&eacute; que tout semble &ecirc;tre en place, vous
	pouvez alors red&eacute;marrez votre syst&egrave;me.  Un simple
	&man.shutdown.8; devrait suffire:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>C'est fini</title>

      <para>Vous devriez maintenant avoir mis &agrave; jour avec
	succ&egrave;s votre syst&egrave;me &os;.  F&eacute;licitations.</para>

      <para>Si les choses se sont l&eacute;g&egrave;rement mal
	pass&eacute;es, il est facile de recompiler un &eacute;l&eacute;ment
	particulier du syst&egrave;me.  Par exemple, si vous avez
	accidentellement effac&eacute; <filename>/etc/magic</filename>
	lors de la mise &agrave; jour de <filename>/etc</filename>, la
	commande &man.file.1; ne fonctionnerait plus.  Dans ce cas,
	la solution serait d'ex&eacute;cuter:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Questions</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Dois-je refaire le monde &agrave; chaque
	      &eacute;volution?</para>
	  </question>

	  <answer>
	    <para>Il n'y a pas de r&eacute;ponse toute faite &agrave;
	      cette question, tout d&eacute;pend de la nature des
	      &eacute;volutions.  Par exemple, si vous venez juste
	      d'ex&eacute;cuter <application>CVSup</application>, et que
	      les fichiers suivants on &eacute;t&eacute; mis &agrave;
	      jour:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>cela ne vaut probablement pas la peine de recompiler
	      tout le syst&egrave;me.  Vous pouvez tout simplement aller dans
	      les sous-r&eacute;pertoires appropri&eacute;s,
	      ex&eacute;cuter <command>make all install</command>, et
	      c'est &agrave; peu pr&egrave;s tout.  Mais s'il y a des
	      &eacute;volutions importantes, par exemple sur
	      <filename>src/lib/libc/stdlib</filename> alors vous
	      devrez soit refaire le monde, ou recompiler au moins
	      toutes les parties du syst&egrave;me qui sont li&eacute;es
	      statiquement (de m&ecirc;me que tout ce vous pourriez
	      avoir ajout&eacute; qui y serait li&eacute; statiquement).</para>

	    <para>C'est &agrave; vous de voir.  Vous pr&eacute;f&eacute;rerez
	      peut-&ecirc;tre recompiler votre syst&egrave;me tous les
	      quinze jours, et laisser les modifications s'empiler
	      pendant quinze jours.  Ou bien vous pr&eacute;f&eacute;rerez
	      ne recompiler que ce qui a chang&eacute; et vous faire
	      confiance pour tout ce qui en d&eacute;pend.</para>

	    <para>Et, bien s&ucirc;r, cela d&eacute;pend de la
	      fr&eacute;quence avec laquelle vous voulez faire vos mises
	      &agrave; jour, et de si vous suivez la branche &os.stable;
	      ou &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Ma compilation &eacute;choue avec de nombreuses erreurs
	      &ldquo;signal 11&rdquo; (ou tout autre num&eacute;ro de
	      signal).  Que s'est-il pass&eacute;?</para>
	  </question>
    <indexterm><primary>signal 11</primary></indexterm>

	  <answer>

	    <para>Cela indique g&eacute;n&eacute;ralement un probl&egrave;me
	      mat&eacute;riel.  (Re)compiler le syst&egrave;me est un bon
	      moyen de mettre votre mat&eacute;riel sous pression, et
	      mettra souvent en &eacute;vidence des d&eacute;faillances
	      de la m&eacute;moire vive.  Elles se manifestent normalement
	      d'elles-m&ecirc;mes, la compilation &eacute;chouant
	      lors de la r&eacute;ception de myst&eacute;rieux signaux.</para>

	    <para>Un bon indicateur de cet &eacute;tat de fait, est que
	      vous pouvez relancer la compilation et qu'elle &eacute;chouera
	      en un endroit diff&eacute;rent.</para>

	    <para>Dans ce cas, vous ne pouvez gu&egrave;re faire autre chose
	      que d'intervertir les diff&eacute;rents composants de votre
	      mat&eacute;riel pour d&eacute;terminer lequel est en cause.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Puis-je effacer <filename>/usr/obj</filename> apr&egrave;s
	      avoir fini?</para>
	  </question>

	  <answer>
	    <para>Une r&eacute;ponse courte est oui.</para>

	    <para><filename>/usr/obj</filename> contient tous les
	      fichiers objets g&eacute;n&eacute;r&eacute;s &agrave; la
	      compilation.  Normalement, une des premi&egrave;res
	      &eacute;tapes de &ldquo;make world&rdquo; est de supprimer ce
	      r&eacute;pertoire et de repartir &agrave; z&eacute;ro.
	      Dans ce cas, conserver le r&eacute;pertoire
	      <filename>/usr/obj</filename> apr&egrave;s avoir termin&eacute; ne
	      sert pas &agrave; grand chose, alors que vous
	      &eacute;conomiseriez pas mal d'espace disque (actuellement
	      environ 340&nbsp;MO).</para>

	    <para>Cependant, si vous savez ce que vous faites, vous
	      pouvez faire en sorte que &ldquo;make world&rdquo;
	      saute cette &eacute;tape.  Cela rendra les compilations
	      ult&eacute;rieures plus rapides, puisque la plupart des sources
	      n'auront pas besoin d'&ecirc;tre recompil&eacute;es.
	      Le revers de la m&eacute;daille est que des probl&egrave;mes
	      subtils de d&eacute;pendance peuvent se manifester, provoquant
	      l'&eacute;chec de votre compilation de mani&egrave;re
	      &eacute;trange.  Cela g&eacute;n&egrave;re fr&eacute;quemment
	      du bruit sur les listes de diffusion de &os;, quand quelqu'un se
	      plaint que sa mise &agrave; jour a &eacute;chou&eacute;, sans
	      r&eacute;aliser que c'est parce qu'il a tent&eacute; de
	      br&ucirc;ler les &eacute;tapes.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Une recompilation interrompue peut-elle &ecirc;tre
	      reprise?</para>
	  </question>

	  <answer>
	    <para>Tout d&eacute;pend de jusqu'o&ugrave; vous &ecirc;tes
	      aller avant de rencontrer un probl&egrave;me.</para>

	    <para><emphasis>En g&eacute;n&eacute;ral</emphasis> (et ceci n'est
	      pas une r&egrave;gle absolue) &ldquo;make world&rdquo;
	      cr&eacute;e de nouveaux exemplaires des outils indispensables
	      (comme &man.gcc.1; et &man.make.1;) et des biblioth&egrave;ques
	      syst&egrave;me.  Ces outils et biblioth&egrave;ques sont
	      ensuite install&eacute;s.  Puis ils sont utilis&eacute;s pour
	      se reconstruire eux-m&ecirc;mes, et install&eacute;s de nouveau.
	      L'int&eacute;gralit&eacute; du syst&egrave;me (y compris
	      maintenant les programmes utilisateurs classiques, comme
	      &man.ls.1; ou &man.grep.1;) est alors recompil&eacute; avec
	      les nouveaux fichiers syst&egrave;me.</para>

	    <para>Si vous &ecirc;tes &agrave; cette derni&egrave;re
	      &eacute;tape, et que vous le savez (parce que vous avez
	      consult&eacute; les r&eacute;sultats que vous avez
	      enregistr&eacute;s) alors vous pouvez (sans trop de risque)
	      faire:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput></screen>

	    <para>Cela ne d&eacute;truira pas les r&eacute;sultats du
	      travail qu'&agrave; d&eacute;j&agrave; effectu&eacute; &ldquo;make
	      world&rdquo;.</para>

	    <para>Si vous voyez le message:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>dans les comptes-rendus de &ldquo;make world&rdquo;
	      alors cette fa&ccedil;on de proc&eacute;der est probablement
	      bonne.</para>

	    <para>Si vous ne voyez pas ce message, ou que vous doutez
	      de vous, alors prudence est m&egrave;re de s&ucirc;ret&eacute;,
	      et il vaut mieux tout reprendre depuis le d&eacute;but.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Comment puis-je acc&eacute;l&eacute;rer la compilation
	      du syst&egrave;me?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Passez en mode mono-utilisateur.</para>
	      </listitem>

	      <listitem>
		<para>Mettez les r&eacute;pertoires
		  <filename>/usr/src</filename> et
		  <filename>/usr/obj</filename> sur des syst&egrave;mes de
		  fichiers et des disques diff&eacute;rents.  Si possible,
		  installez ces disques sur des contr&ocirc;leurs
		  diff&eacute;rents.</para>
	      </listitem>

	      <listitem>
		<para>Encore mieux, mettez ces syst&egrave;mes de fichiers
		  sur plusieurs disques utilisant le syst&egrave;me
		  &man.ccd.4; (pilote de disques
		  concat&eacute;n&eacute;s).</para>
	      </listitem>

	      <listitem>
		<para>Ne compilez pas les biblioth&egrave;ques profil&eacute;es
		  (mettez &ldquo;NOPROFILE=true&rdquo; dans le fichier
		  <filename>/etc/make.conf</filename>).  Vous n'en
		  avez certainement pas besoin.</para>
	      </listitem>

	      <listitem>
		<para>Egalement dans <filename>/etc/make.conf</filename>,
		  positionnez <makevar>CFLAGS</makevar> &agrave; quelque
		  chose comme <option>-O -pipe</option>.
		  L'optimisation <option>-O2</option> est bien plus
		  lente, et la diff&eacute;rence d'optimisation entre
		  <option>-O</option> et <option>-O2</option> est en
		  g&eacute;n&eacute;ral n&eacute;gligeable.
		  <option>-pipe</option> demande au compilateur d'utiliser
		  des tuyaux &agrave; la place de fichiers temporaires, ce
		  qui &eacute;conomise des acc&egrave;s disque (mais
		  utilise plus de m&eacute;moire).</para>
	      </listitem>

	      <listitem>
		<para>Passez l'option
		  <option>-j<replaceable>n</replaceable></option>
		  &agrave; &man.make.1; pour permettre l'ex&eacute;cution de
		  plusieurs processus en parall&egrave;le.  Cela
		  am&eacute;liore g&eacute;n&eacute;ralement les choses, que
		  vous ayez une machine mono- ou multi-processeurs.</para>
	      </listitem>

	      <listitem>
		<para>Le syst&egrave;me de fichiers qui contient
		  <filename>/usr/src</filename> peut &ecirc;tre mont&eacute;
		  (ou remont&eacute;) avec l'option <option>noatime</option>.
		  Cela emp&ecirc;che l'enregistrement des dates d'acc&egrave;s
		  aux fichiers par le syst&egrave;me de fichiers.  Vous
		  n'avez de toute fa&ccedil;on probablement pas besoin de cette
		  information.</para>

		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		  <warning>
		    <para>Cet exemple suppose que
		      <filename>/usr/src</filename> constitue &agrave; lui
		      seul un syst&egrave;me de fichiers.  Si ce n'est pas
		      le cas (s'il fait partie de
		      <filename>/usr</filename> par exemple) vous
		      devez alors indiquer le point de montage de ce
		      syst&egrave;me de fichiers, et non
		      <filename>/usr/src</filename>.</para>
		  </warning>
	      </listitem>

	      <listitem>
		<para>Le syst&egrave;me de fichiers o&ugrave; se trouve
		  <filename>/usr/obj</filename> peut &ecirc;tre
		  mont&eacute; (ou remont&eacute;) avec l'option
		  <option>async</option>.  Les &eacute;critures sur le
		  disque se feront alors de fa&ccedil;on asynchrone.  En
		  d'autres termes, le programme reprend imm&eacute;diatement
		  la main, et l'&eacute;criture des donn&eacute;es sur le
		  disque se fait quelques secondes plus tard.  Cela
		  permet le groupement des &eacute;critures sur le disque,
		  et le gain en performance peut &ecirc;tre
		  spectaculaire.</para>

		<warning>
		  <para>Gardez &agrave; l'esprit que cette option rend votre
		    syst&egrave;me de fichiers plus fragile.  Avec cette
		    option, les risques ne sont accrus qu'en cas de
		    coupure d'alimentation, le syst&egrave;me de fichiers
		    soit irr&eacute;cup&eacute;rable quand la machine
		    red&eacute;marrera.</para>

		  <para>S'il n'y a que <filename>/usr/obj</filename>
		    sur ce syst&egrave;me de fichiers, ce n'est alors pas un
		    probl&egrave;me.  Si vous avez d'autres donn&eacute;es
		    importantes sur ce syst&egrave;me de fichiers,
		    assurez-vous que vos sauvegardes soient &agrave; jour
		    avant d'activer cette option.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Comme auparavant, si
		    <filename>/usr/obj</filename> ne constitue pas un
		    syst&egrave;me de fichiers en soit, remplacez-le dans
		    l'exemple par le nom du point de montage
		    appropri&eacute;.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Que faire si quelque chose se passe mal?</para>
	  </question>

	  <answer>
	    <para>Soyez absolument s&ucirc;r que votre environnement
	      ne contient pas des restes de compilation
	      pr&eacute;c&eacute;dentes.  Cela est plut&ocirc;t simple:</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>En effet, <command>make cleandir</command>
	      doit vraiment &ecirc;tre ex&eacute;cut&eacute;e
	      deux fois.</para>

	    <para>Ensuite relancez l'ensemble du processus,
	      en commen&ccedil;ant avec
	      <command>make buildworld</command>.</para>

	    <para>Si vous avez toujours des probl&egrave;mes,
	      envoyez l'erreur et le r&eacute;sultat de la commande
	      <command>uname -a</command> &agrave; la &a.questions;.
	      Tenez-vous pr&ecirc;t &agrave; r&eacute;pondre &agrave; d'autres
	      concernant votre configuration!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Contribution de </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Suivre les mises &agrave; jour pour plusieurs machines</title>
    <indexterm>
      <primary>NFS</primary>
      <secondary>installation de multiples machines</secondary>
    </indexterm>

    <para>Si vous avez plusieurs machines dont vous voulez maintenir &agrave;
      jour l'arborescence des sources, alors faire
      t&eacute;l&eacute;charger et recompiler &agrave; chacune d'entre elles
      les sources semble un gaspillage de ressources: espace disque, bande
      passante r&eacute;seau, et cycles CPU.  C'est en effet bien le cas,
      et la solution est d'avoir une machine qui fait la majeure
      partie du travail, pendant que le reste des machines montent ce
      travail par NFS.  Cette section d&eacute;crit une fa&ccedil;on
      de le faire.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Pr&eacute;liminaires</title>

      <para>Premi&egrave;rement, identifiez un ensemble de machines
	qui va utiliser le m&ecirc;me ensemble de binaires, que nous
	appellerons un <emphasis>ensemble de compilation</emphasis>.
	Chaque machine peut avoir un noyau personnalis&eacute;, mais
	elles ex&eacute;cuteront les m&ecirc;mes binaires utilisateur du
	syst&egrave;me de base.  Dans cet ensemble de machine, choisissez
	une machine qui sera la <emphasis>machine de
	compilation</emphasis>.  Cela sera la machine sur laquelle
	le monde et le noyau seront compil&eacute;s.  Id&eacute;alement, cela
	devrait &ecirc;tre une machine rapide avec un CPU suffisamment
	disponible pour ex&eacute;cuter la commande <command>make
	world</command>.  Vous voudrez &eacute;galement utiliser
	une <emphasis>machine de test</emphasis>, qui testera
	les mises &agrave; jour logicielles avant d'&ecirc;tre utilis&eacute;es
	en production.  Cela <emphasis>doit</emphasis> &ecirc;tre une
	machine que vous pouvez vous permettre d'avoir hors service
	pour une longue p&eacute;riode.  Cela peut &ecirc;tre la machine
	de compilation, mais cela n'est pas obligatoire.</para>

      <para>Toutes les machines de cet ensemble de compilation
	doivent monter <filename>/usr/obj</filename> et
	<filename>/usr/src</filename> &agrave; partir de la m&ecirc;me
	machine, et du m&ecirc;me point de montage.  Id&eacute;alement, ces
	derniers sont sur deux disques diff&eacute;rents sur la machine de
	compilation, mais peuvent &eacute;galement &ecirc;tre
	mont&eacute;s par NFS sur cette machine.  Si vous avez plusieurs
	ensembles de compilation, <filename>/usr/src</filename>
	devrait &ecirc;tre sur une machine de compilation, et mont&eacute;
	par NFS sur les autres.</para>

      <para>Finalement assurez-vous que
	<filename>/etc/make.conf</filename> sur toutes les machines
	de l'ensemble de compilation est en accord avec la machine de
	compilation.  Cela signifie que la machine de compilation doit
	compiler toutes les parties du syst&egrave;me de base que toute
	machine de l'ensemble de compilation va installer.
	De plus, chaque machine de compilation devra avoir son nom de
	noyau d&eacute;fini avec <makevar>KERNCONF</makevar> dans
	<filename>/etc/make.conf</filename>, et la machine de
	compilation devrait tous les lister dans
	<makevar>KERNCONF</makevar>, en listant son noyau en premier.
	La machine de compilation doit avoir les fichiers de
	configuration des noyaux de chaque machine dans
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	si elle va compiler leur noyau.</para>
    </sect2>

    <sect2>
      <title>Le syst&egrave;me de base</title>

      <para>Maintenant que tout est configur&eacute;, vous &ecirc;tes
	fin pr&ecirc;t pour tout compiler.  Compilez le noyau et le monde
	sur la machine de compilation comme d&eacute;crit dans la <xref
	linkend="make-buildworld">, mais n'installez rien.  La
	compilation une fois termnin&eacute;e, allez sur la machine de
	test, et installez le noyau que vous venez juste de compiler.
	Si la machine monte <filename>/usr/src</filename>
	et <filename>/usr/obj</filename> via NFS, quand vous
	red&eacute;marrez en mode mono-utilisateur vous devrez activer le
	r&eacute;seau et monter ces r&eacute;pertoires.  La m&eacute;thode
	la plus simple est de d&eacute;marrer en mode multi-utilisateur,
	puis ex&eacute;cutez <command>shutdown now</command> pour passer en
	mode mono-utilisateur.  Une fois &agrave; ce niveau, vous pouvez
	installer le nouveau noyau et monde puis ex&eacute;cuter
	<command>mergemaster</command> comme vous le feriez
	habituellement.  Une fois cela effectu&eacute;, red&eacute;mmarez
	pour retourner en mode multi-utilisateur pour cette
	machine.</para>

      <para>Apr&egrave;s que vous soyez certain que tout fonctionne
	correctement sur la machine de test, utilisez la m&ecirc;me
	proc&eacute;dure pour installer le nouvel ensemble logiciel sur
	chacune des autres machines de l'ensemble de
	compilation.</para>
    </sect2>

    <sect2>
      <title>Les logiciels port&eacute;s</title>

      <para>La m&ecirc;me id&eacute;e peut &ecirc;tre utilis&eacute;e
	pour le catalogue des logiciels port&eacute;s.  La
	premi&egrave;re &eacute;tape critique est de monter
	<filename>/usr/ports</filename> depuis la m&ecirc;me machine vers
	toutes les machines de l'ensemble de compilation.  Vous
	pouvez alors configurer correctement
	<filename>/etc/make.conf</filename> pour partager les
	archives.  Vous devrez faire pointer <makevar>DISTDIR</makevar>
	sur un r&eacute;pertoire de partage commun dans lequel peut
	&eacute;crire n'importe quel utilisateur utilis&eacute; pour
	correspondance de l'utilisateur <username>root</username> par vos
	montages NFS.  Chaque machine devrait faire pointer
	<makevar>WRKDIRPREFIX</makevar> sur une r&eacute;pertoire de
	compilation local.  Et enfin, si vous projetez de compiler et
	distribuer des logiciels pr&eacute;compil&eacute;s, vous
	devriez fixer <makevar>PACKAGES</makevar> sur un r&eacute;pertoire
	similaire &agrave; <makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
