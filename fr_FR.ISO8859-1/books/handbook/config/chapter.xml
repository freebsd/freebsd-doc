<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 38826+44296
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="config-tuning">
  <info>
    <title>Configuration et optimisation</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	</personname>
	
	<contrib>Ecrit par </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Mike</firstname>
	  <surname>Smith</surname>
	</personname>
	
	<contrib>Basé sur un guide rédigé par </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Matt</firstname>
	  <surname>Dillon</surname>
	</personname>
	
	<contrib>Egalement basé sur la page de manuel tuning(7) écrite
	par </contrib>
      </author>
    </authorgroup>
  </info>

  
  &trans.a.fonvieille;

  <sect1 xml:id="config-synopsis">
    <title>Synopsis</title>

    <indexterm><primary>configuration du
      système</primary></indexterm>
    <indexterm><primary>optimisation du
      système</primary></indexterm>

    <para>La configuration correcte d'un système peut sensiblement
      réduire la quantité de travail impliquée
      dans la maintenance et la mise &agrave; jour.  Ce chapitre
      décrit certains des aspects de la configuration des
      systèmes FreeBSD.</para>

    <para>Ce chapitre décrira également certains
      paramètres qui peuvent être modifiés
      pour configurer un système FreeBSD pour des performances
      optimales.</para>

    <para>Après la lecture de ce chapitre, vous saurez:</para>

    <itemizedlist>
      <listitem>
	<para>Les bases de la configuration du fichier
	  <filename>rc.conf</filename> et des fichiers de démarrage
	  <filename class="directory">/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Comment configurer et tester une carte
	  réseau.</para>
      </listitem>
      <listitem>
	<para>Comment configurer des hôtes virtuels sur vos
	  périphériques réseau.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les divers fichiers de configuration du
	  répertoire <filename class="directory">/etc</filename>.</para>
      </listitem>
      <listitem>
        <para>Comment optimiser FreeBSD en utilisant les variables
	  <command>sysctl</command>.</para>
      </listitem>
      <listitem>
	<para>Comment optimiser les performances des disques et
	  modifier les limitations du noyau.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Comprendre les fondements d'&unix; et de FreeBSD (<xref linkend="basics"/>).</para>
      </listitem>
      <listitem>
	<para>Etre familier avec la configuration et la compilation du
	  noyau
	  (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="configtuning-core-configuration">
    <title>Configuration principale</title>

    <indexterm>
      <primary>fichiers rc</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>L'emplacement principal pour les données de configuration
      du système est le fichier <filename>/etc/rc.conf</filename>.
      Ce fichier contient une large gamme d'informations de
      configuration, principalement utilisées au démarrage
      du système
      pour configurer ce dernier.  Son nom le sous-entend; c'est
      l'information de configuration pour les fichiers
      <filename>rc*</filename>.</para>

    <para>Un administrateur devrait ajouter des entrées dans le
      fichier <filename>rc.conf</filename> pour remplacer les valeurs
      par défaut du fichier
      <filename>/etc/defaults/rc.conf</filename>.  Les fichiers de
      valeurs par défaut ne devraient pas être copiés
      directement tels quels dans <filename class="directory">/etc</filename> - ils
      contiennent des valeurs par défaut, et non pas des exemples.
      Tout changement spécifique au système devrait
      être fait dans le fichier <filename>rc.conf</filename>.</para>

    <para>Un certain nombre de stratégies peuvent être
      appliquées dans le cas d'applications en grappe pour
      séparer la configuration d'un site de celle d'un système
      afin de réduire le travail d'administration.  L'approche
      recommandée est
      de placer la configuration propre au site dans le fichier
      <filename>/etc/rc.conf.local</filename>.  Par exemple:</para>

    <itemizedlist>
      <listitem><para><filename>/etc/rc.conf</filename>:</para>

<programlisting>sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"</programlisting></listitem>

      <listitem><para><filename>/etc/rc.conf.local</filename>:</para>

<programlisting>hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"</programlisting></listitem>
    </itemizedlist>

    <para>Le fichier <filename>rc.conf</filename> peut être
      distribué &agrave; l'ensemble des systèmes en utilisant
      <command>rsync</command> ou un programme semblable, tandis que
      le fichier <filename>rc.conf.local</filename> reste unique.</para>

    <para>Mettre &agrave; jour le système en employant
      &man.sysinstall.8; ou <command>make world</command> n'écrasera
      pas le fichier <filename>rc.conf</filename>, les informations de
      configuration du système ne seront donc pas perdues.</para>

    <para>Le fichier de configuration
      <filename>/etc/rc.conf</filename> est analysé par &man.sh.1;.
      Cela permet aux administrateurs système d'ajouter un certain
      niveau de logique à ce fichier, ce qui peut aider à créer des
      scénaris de configuration complexes.  Veuillez consulter
      &man.rc.conf.5; pour plus d'information sur ce sujet.</para>

  </sect1>

  <sect1 xml:id="configtuning-appconfig">
    <title>Configuration des applications</title>

    <para>Généralement, les applications installées
      ont leurs propres fichiers de configuration, avec leur propre
      syntaxe, etc...  Il est important que ces fichiers soient
      séparés du système de base, de sorte qu'ils soient
      facilement localisables et gérables par les outils de gestion
      des logiciels installés.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Ces fichiers sont généralement installés
      dans le répertoire <filename class="directory">/usr/local/etc</filename>.  Dans
      le cas où une application possède un grand nombre
      de fichiers de configuration, un sous-répertoire sera
      créé pour les héberger.</para>

    <para>Normalement, quand un logiciel porté ou
      pré-compilé est installé, des exemples de
      fichiers de configuration sont également installés.
      Ces derniers sont généralement identifiés
      par un suffixe &ldquo;.default&rdquo;.  Si aucun fichier de
      configuration n'existe pour l'application, on les créera en
      copiant les fichiers <filename>.default</filename>.</para>

    <para>Par exemple, considérez le contenu du
      répertoire <filename class="directory">/usr/local/etc/apache</filename>:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Les tailles des fichiers indiquent que seul le
      fichier <filename>srm.conf</filename> a été modifié.  Une mise &agrave;
      jour, plus tard, du logiciel <application>Apache</application> ne devrait pas écraser le
      fichier modifié.</para>

  </sect1>

  <sect1 xml:id="configtuning-starting-services">
    <info><title>Démarrer des services</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>services</primary></indexterm>

    <para>Nombreux sont les utilisateurs qui choisissent d'installer
      des logiciels tierce partie sous &os; &agrave; partir du
      catalogue des logiciels portés.  Dans de nombreuses
      situations, il peut être nécessaire de configurer
      le logiciel de manière &agrave; ce qu'il soit
      lancé au démarrage du système.  Des
      services comme <package>mail/postfix</package>
      ou <package>www/apache22</package> sont deux
      exemples de logiciels parmi tant d'autres qui peuvent être
      lancés &agrave; l'initialisation du système.
      Cette section explique les procédures disponibles pour
      démarrer certains logiciels tierce partie.</para>

    <para>Sous &os;, la plupart des services offerts, comme
      &man.cron.8;, sont lancés par l'intermédiaire des
      procédures de démarrage du système.  Ces
      procédures peuvent varier en fonction de la version de
      &os;, ou du fournisseur; cependant, l'aspect le plus important
      &agrave; considérer est que leur configuration de
      démarrage peut être gérée &agrave;
      l'aide de procédures de démarrage simples.</para>

    <sect2>
      <title>Configuration étendue des applications</title>

      <para>Maintenant que &os; dispose du système <filename>rc.d</filename>, la
	configuration du démarrage des applications est plus
	simple, et propose plus de possibilités.
	En utilisant les mots clés présentés dans
	la section sur le système <link linkend="configtuning-rcd">rc.d</link>, les applications
	peuvent désormais être paramétrées
	pour démarrer après certains services, par
	exemple le <acronym>DNS</acronym>, des paramètres
	supplémentaires peuvent être passés par
	l'intermédiaire de <filename>rc.conf</filename> au lieu
	d'utiliser des paramètres fixes dans les
	procédures de démarrage, etc.  Une
	procédure de base pourra ressembler &agrave; ce qui
	suit:</para>

      <programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"</programlisting>

      <para>Cette procédure s'assurera que l'application
	<application>utility</application> sera lancée après le
	le service
	<literal>DAEMON</literal>.  Elle fournie également une
	méthode de suivi du <acronym>PID</acronym>, ou encore
	<acronym>ID</acronym> (identifiant) de processus.</para>

      <para>Cette application pourra alors avoir la ligne suivante la
	concernant dans le fichier
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>utility_enable="YES"</programlisting>

      <para>Cette méthode permet également une
	manipulation plus aisée des arguments en ligne de
	commande, l'inclusion des fonctions offertes par défaut
	dans <filename>/etc/rc.subr</filename>, offre une
	compatibilité avec l'utilitaire &man.rcorder.8; et
	fournie une configuration plus aisée par
	l'intermédiaire du fichier
	<filename>rc.conf</filename>.</para>
    </sect2>

    <sect2>
      <title>Utiliser des services pour démarrer d'autres
	services</title>

      <para>Certains services, comme les serveurs
	<acronym>POP</acronym>3, <acronym>IMAP</acronym>, etc.,
	peuvent être démarrés en utilisant
	&man.inetd.8;.  Cela implique d'installer le service &agrave;
	partir du catalogue des logiciels portés et avec une
	ligne de configuration ajoutée au fichier
	<filename>/etc/inetd.conf</filename>, ou en
	décommentant une des lignes de configuration
	déj&agrave; présentes.  L'utilisation
	d'<application>inetd</application> et sa configuration sont
	décrits en profondeur dans la section concernant <link linkend="network-inetd">inetd</link>.</para>

      <para>Dans certains cas, il peut être plus
	approprié d'utiliser le <quote>daemon</quote>
	&man.cron.8; pour démarrer des services.  Cette
	approche présente un certain nombre d'avantages parce
	que <command>cron</command> exécute ces processus sous
	les privilèges du propriétaire de la table
	<filename>crontab</filename>.  Cela permet aux utilisateurs
	normaux de lancer et maintenir certaines applications.</para>

      <para>L'utilitaire <command>cron</command> offre une fonction
	unique, <literal>@reboot</literal>, qui peut être
	utilisée en remplacement de la date d'exécution.
	Cela provoquera l'exécution de la tâche quand
	&man.cron.8; est lancé, normalement lors de
	l'initialisation du système.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-cron">
    <info><title>Configuration de l'utilitaire
      <command>cron</command></title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>
    

    <indexterm><primary>cron</primary>
      <secondary>configuration</secondary></indexterm>

    <para>Un des utilitaires les plus importants de &os; est
      &man.cron.8;.  L'utilitaire <command>cron</command> tourne en
      arrière plan et contrôle constamment le fichier
      <filename>/etc/crontab</filename>.  L'utilitaire
      <command>cron</command> consulte également le
      répertoire <filename class="directory">/var/cron/tabs</filename>, &agrave; la
      recherche de nouveaux fichiers <filename>crontab</filename>.
      Ces fichiers <filename>crontab</filename> conservent les
      informations sur les tâches que <command>cron</command>
      est censé exécuter &agrave; des moments
      donnés.</para>

    <para>L'utilitaire <command>cron</command> utilise deux types
      différents de fichiers de configuration, le fichier
      <filename>crontab</filename> système et les
      <filename>crontab</filename>s des utilisateurs.  Ces deux
      formats diffèrent à partir du sixième champ.  Dans le fichier
      <filename>crontab</filename> système, <command>cron</command>
      exécutera la commande en tant que l'utilisateur indiqué dans le
      sixième champ.  Dans le fichier <filename>crontab</filename>
      d'un utilisateur, toutes les commandes sont exécutées sous
      l'utilisateur qui a créé ce fichier
      <filename>crontab</filename>, aussi le sixième champ est le
      dernier champ; c'est un aspect sécurité important.  Le dernier
      champ est toujours la commande à exécuter.</para>

    <note>
      <para>Les fichiers <filename>crontab</filename> utilisateur
	permettent aux utilisateurs de planifier l'exécution de tâches
	sans avoir besoin des privilèges du super-utilisateur
	<systemitem class="username">root</systemitem>.  Les commandes
	contenues dans le fichier <filename>crontab</filename> d'un
	utilisateur s'exécutent avec les privilèges de l'utilisateur
	auquel appartient ce fichier.</para>

      <para>Le super-utilisateur <systemitem
	class="username">root</systemitem> peut posséder un fichier
	<filename>crontab</filename> utilisateur comme tout autre
	utilisateur.  Ce fichier est différent de
	<filename>/etc/crontab</filename> (le
	<filename>crontab</filename> système).  Etant donné que le
	fichier <filename>crontab</filename> système invoque les
	commandes spécifiées en tant que <systemitem
	class="username">root</systemitem>, il n'y a généralement pas
	besoin d'un fichier <filename>crontab</filename> utilisateur
	pour <systemitem class="username">root</systemitem>.</para>
    </note>

    <para>Examinons le fichier
      <filename>/etc/crontab</filename> (fichier
      <filename>crontab</filename> système):</para>


    <programlisting># /etc/crontab - root's crontab for &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co xml:id="co-comments"/>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co xml:id="co-env"/>
HOME=/var/log
#
#
#minute	heure	date	mois	jour	utilisateur	commande <co xml:id="co-field-descr"/>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co xml:id="co-main"/></programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Comme pour la plupart des fichiers de configuration de
	  &os;, le caractère <literal>#</literal> indique un
	  commentaire.  Un commentaire peut être ajouté
	  dans le fichier comme rappel de ce que fait une action bien
	  précise et pourquoi elle est effectuée.  Les
	  commentaires ne peuvent être situés sur la
	  même ligne qu'une commande ou sinon ils seront
	  interprétés comme faisant partie de la commande;
	  ils doivent se trouver sur une nouvelle ligne.  Les lignes
	  vides sont ignorées.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Tout d'abord, les variables d'environnement doivent
	  être définies.  Le caractère égal
	  (<literal>=</literal>) est utilisé pour définir
	  tout paramètre concernant l'environnement, comme dans
	  notre exemple où il a été utilisé
	  pour les variables <envar>SHELL</envar>, <envar>PATH</envar>,
	  et <envar>HOME</envar>.  Si la ligne concernant
	  l'interpréteur de commande est omise,
	  <command>cron</command> utilisera celui par défaut, qui
	  est <command>sh</command>.  Si la variable <envar>PATH</envar>
	  est omise, il n'y aura pas de valeur par défaut
	  utilisée et l'emplacement des fichiers devra être
	  absolu.  Si <envar>HOME</envar> est omise,
	  <command>cron</command> utilisera le répertoire
	  personnel de l'utilisateur qui l'invoque.</para>
	</callout>

      <callout arearefs="co-field-descr">
	<para>Cette ligne définie un total de sept champs.
	  Sont listés ici les valeurs <literal>minute</literal>,
	  <literal>heure</literal>, <literal>date</literal>,
	  <literal>mois</literal>, <literal>jour</literal>,
	  <literal>utilisateur</literal>, et
	  <literal>commande</literal>.  Ces champs sont relativement
	  explicites.  <literal>minute</literal> représente
	  l'heure en minute &agrave; laquelle la commande sera
	  exécutée.  L'option <literal>heure</literal> est
	  semblable &agrave; l'option <literal>minute</literal>, mais en
	  heures.  Le champ <literal>date</literal> précise le
	  jour dans le mois.  <literal>mois</literal> est similaire
	  &agrave; <literal>heure</literal> et <literal>minute</literal>
	  mais désigne le mois.  L'option <literal>jour</literal>
	  représente le jour de la semaine.  Tous ces champs
	  doivent être des valeurs numériques, et respecter
	  un format horaire de vingt quatre heures.  Le champ
	  <literal>utilisateur</literal> est spécial, et n'existe
	  que dans le fichier <filename>/etc/crontab</filename>.  Ce
	  champ précise sous quel utilisateur sera
	  exécutée la commande.  Le dernier champ désigne la commande
	  à exécuter.</para>
      </callout>

      <callout arearefs="co-main">
	<para>Cette dernière ligne définie les valeurs
	  discutées ci-dessus.  Nous avons ici
	  <literal>*/5</literal> suivi de plusieurs caractères
	  <literal>*</literal>.  Ces caractères
	  <literal>*</literal> signifient &ldquo;premier-dernier&rdquo;,
	  et peuvent être interprétés comme voulant
	  dire &agrave; <emphasis>chaque</emphasis> instance.  Aussi,
	  d'après cette ligne, il apparaît que la commande
	  <command>atrun</command> sera invoquée par
	  l'utilisateur <systemitem class="username">root</systemitem> toutes les cinq
	  minutes indépendamment du jour ou du mois.  Pour plus
	  d'informations sur la commande <command>atrun</command>,
	  consultez la page de manuel de &man.atrun.8;.</para>

	<para>N'importe quel nombre d'indicateur peut être
	  passé &agrave; ces commandes; cependant, les
	  commandes qui s'étendent sur de multiples lignes
	  doivent être &ldquo;cassées&rdquo; avec le
	  caractère, contre-oblique <literal>\</literal>, de
	  continuation de lignes.</para>
      </callout>
    </calloutlist>

    <para>Ceci est la configuration de base pour chaque fichier
      <filename>crontab</filename>, bien qu'il y ait une
      différence dans celui présenté ici.  Le
      sixième champ, où est précisé le nom
      d'utilisateur, n'existe que dans le fichier système
      <filename>/etc/crontab</filename>.  Ce champ devrait être
      omis pour les fichiers <filename>crontab</filename>
      d'utilisateur.</para>

    <sect2 xml:id="configtuning-installcrontab">
      <title>Installer un fichier crontab</title>

      <important>
	<para>Ne pas utiliser la procédure
	  décrite ci-dessous pour éditer et installer le
	  fichier <filename>crontab</filename> système.  Utilisez
	  directement votre éditeur: l'utilitaire
	  <command>cron</command> remarquera le changement au niveau de ce
	  fichier et utilisera immédiatement la nouvelle version.
	  Consultez <link xlink:href="&url.books.faq;/admin.html#ROOT-NOT-FOUND-CRON-ERRORS">cette
	  entrée de la FAQ</link> pour plus d'information.</para>
      </important>

      <para>Pour installer un fichier <filename>crontab</filename>
	utilisateur fraîchement rédigé, tout d'abord
	utilisez votre éditeur favori pour créer un
	fichier dans le bon format, ensuite utilisez
	l'utilitaire <command>crontab</command>.  L'usage le plus
	typique est:</para>

      <screen>&prompt.root; <userinput>crontab fichier-crontab</userinput></screen>

      <para>Dans cet exemple, <filename>fichier-crontab</filename> est
	le nom d'un fichier <filename>crontab</filename> qui a
	été précédemment
	créé.</para>

      <para>Il existe également une option pour afficher les
	fichiers <filename>crontab</filename> installés, passez
	simplement le paramètre <option>-l</option> &agrave;
	<command>crontab</command> et lisez ce qui est
	affiché.</para>

      <para>Pour les utilisateurs désirant créer leur
	fichier crontab &agrave; partir de zéro, sans utiliser
	de modèle, l'option <command>crontab -e</command> est
	disponible.  Cela invoquera l'éditeur par défaut
	avec un fichier vide.  Quand le fichier est sauvegardé,
	il sera automatiquement installé par la commande
	<command>crontab</command>.</para>

      <para>Afin d'effacer le fichier
	<filename>crontab</filename> utilisateur complètement,
	utiliser la commande <command>crontab</command> avec l'option
	<option>-r</option>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-rcd">
    <info><title>Utilisation du système &man.rc.8; sous &os;</title>
      <authorgroup>
        <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <para>En 2002, le système <filename>rc.d</filename> de NetBSD pour
      l'initialisation du système a
      été intégré &agrave; &os;.  Les
      utilisateurs noteront les fichiers présents dans le
      répertoire <filename class="directory">/etc/rc.d</filename>.  Plusieurs de ces
      fichiers sont destinés aux services de base qui peuvent
      être contrôlés avec les options
      <option>start</option>, <option>stop</option>, et
      <option>restart</option>.  Par exemple, &man.sshd.8; peut
      être relancé avec la commande suivante:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>
    <para>Cette procédure est similaire pour d'autres services.
      Bien sûr, les services sont généralement
      lancés automatiquement au démarrage dès qu'ils sont
      spécifiés dans le fichier &man.rc.conf.5;.  Par
      exemple, activer le &ldquo;daemon&rdquo; de translation d'adresses
      au démarrage est aussi simple que d'ajouter la ligne
      suivante au fichier <filename>/etc/rc.conf</filename>:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Si une ligne <option>natd_enable="NO"</option> est
      déj&agrave; présente, modifiez alors le
      <option>NO</option> par <option>YES</option>.  Les
      procédures rc chargeront automatiquement les autres
      services dépendants lors du prochain redémarrage
      comme décrit ci-dessous.</para>

    <para>Comme le système <filename>rc.d</filename> est
      &agrave; l'origine destiné pour lancer/arrêter les
      services au démarrage/&agrave; l'arrêt du
      système, les options standards <option>start</option>,
      <option>stop</option> et <option>restart</option> ne seront
      effectives que si les variables appropriées sont
      positionnées dans le fichier
      <filename>/etc/rc.conf</filename>.  Par exemple, la commande
      <command>sshd restart</command> ci-dessus ne fonctionnera que si
      <varname>sshd_enable</varname> est fixée &agrave;
      <option>YES</option> dans <filename>/etc/rc.conf</filename>.
      Pour lancer, arrêter ou redémarrer un service
      indépendemment des paramétrages du fichier
      <filename>/etc/rc.conf</filename>, les commandes doivent
      être précédées par
      <quote>one</quote>.  Par exemple pour redémarrer
      <command>sshd</command> indépendemment du
      paramétrage du fichier <filename>/etc/rc.conf</filename>,
      exécutez la commande suivante:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd onerestart</userinput></screen>

    <para>Il est facile de contrôler si un service est
      activé dans le fichier <filename>/etc/rc.conf</filename>
      en exécutant la procédure
      <filename>rc.d</filename> appropriée avec l'option
      <option>rcvar</option>.  Ainsi, un administrateur peut
      contrôler que <command>sshd</command> est
      réellement activé dans
      <filename>/etc/rc.conf</filename> en exécutant:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>La seconde ligne (<literal># sshd</literal>) est la sortie
	de la commande <command>sshd</command> et non pas une console
	<systemitem class="username">root</systemitem>.</para>
    </note>

    <para>Pour déterminer si un service est actif, une option
      appelée <option>status</option> est disponible.  Par
      exemple pour vérifier que <command>sshd</command> a
      réellement été lancé:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Dans certains cas, il est également possible de recharger un service
      avec l'option <option>reload</option>.  Le système
      tentera d'envoyer un signal &agrave; un service individuel, le
      forçant &agrave; recharger ses fichiers de configuration.
      Dans la plupart des cas cela signifie envoyer un signal
      <literal>SIGHUP</literal> au service.  Le support de cette
      fonctionnalité n'est pas disponible pour chaque
      service.</para>

    <para>Le système <filename>rc.d</filename> n'est pas
      uniquement utilisée pour les services réseaux,
      elle participe &agrave; la majeure partie de l'initialisation du
      système.  Prenez par exemple le fichier
      <filename>bgfsck</filename>.  Quand cette procédure est
      exécutée, il affichera le message suivant:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Donc ce fichier est utilisé pour les
      vérifications du système de fichiers en
      arrière plan, qui sont uniquement effectuées lors
      de l'initialisation du système.</para>

    <para>De nombreux services système dépendent
      d'autres services pour fonctionner correctement.  Par exemple,
      NIS et les autres services basés sur les RPCs peuvent
      échouer s'ils sont lancés après le
      lancement du service <command>rpcbind</command> (portmapper).
      Pour résoudre ce problème, l'information
      concernant les dépendances et autres
      méta-données est inclue dans les commentaires au
      début de chaque procédure de démarrage.  Le
      programme &man.rcorder.8; est alors utilisé pour analyser
      ces commentaires lors de l'initialisation du système en
      vue de déterminer l'ordre dans lequel les services
      système seront invoqués pour satisfaire les
      dépendances.</para>

    <para>Les mots suivants doivent être présents en tête de tous les
      fichiers de démarrage (ils sont nécessaires pour que
      &man.rc.subr.8; active les procédures de démarrages):</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: indique les services que
	  fournit ce fichier.</para>
      </listitem>
    </itemizedlist>

    <para>Les mots clés suivants peuvent être ajoutés au début de
      chaque fichier de démarrage.  Ils ne sont pas strictement
      nécessaires, mais sont utiles comme aide pour
      &man.rcorder.8;:</para>

    <itemizedlist>
      <listitem>
	<para><literal>REQUIRE</literal>: liste les fichiers dont
	  dépend ce service.  Ce fichier sera
	  exécuté <emphasis>après</emphasis> les
	  services indiqués.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: liste les services qui
	  dépendent du service présent.  Ce fichier sera
	  exécuté <emphasis>avant</emphasis> les services
	  indiqués.</para>
      </listitem>
    </itemizedlist>

    <para>En utilisant avec soin ces mots clés pour chaque fichier de
      démarrage, un administrateur dispose d'un niveau de contrôle
      très fin de l'ordre d'exécution des procédures de démarrage sans
      les inconvénients des <quote>runlevels</quote> comme sur
      d'autres systèmes d'exploitation &unix;.</para>

    <para>Des informations supplémentaires concernant le
      système <filename>rc.d</filename>
      peuvent être trouvées dans les pages de manuel
      &man.rc.8; et &man.rc.subr.8;.  Si vous êtes
      intéressé par l'écriture de vos propres
      procédures <filename>rc.d</filename> ou pour
      l'amélioration des procédures existantes, vous
      trouverez <link xlink:href="&url.articles.rc-scripting;">cette
      article</link> utile.</para>
  </sect1>

  <sect1 xml:id="config-network-setup">
    <info><title>Configuration des cartes réseaux</title>
      <authorgroup>
        <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>cartes réseaux</primary>
      <secondary>pilote</secondary>
    </indexterm>

    <para>De nos jours il est impossible de penser &agrave; un ordinateur
      sans penser connexion &agrave; un réseau.  Installer et configurer
      une carte réseau est une tâche classique pour tout
      administrateur FreeBSD.</para>

    <sect2>
      <title>Déterminer le bon pilote de
	périphérique</title>

      <indexterm>
	<primary>configuration des cartes réseaux</primary>
	<secondary>déterminer le pilote de
	  périphérique</secondary>
      </indexterm>

      <para>Avant de commencer, vous devez connaître le modèle
	de la carte dont vous disposez, le circuit qu'elle
	utilise, et si c'est une carte PCI ou ISA.  FreeBSD supporte
	une large variété de cartes PCI et ISA.  Consultez la liste de
	compatibilité matérielle pour votre version de FreeBSD afin de
	voir si votre carte est supportée.</para>

      <para>Une fois que vous êtes sûrs que votre carte
	est supportée, vous devez déterminer le bon pilote de
	périphérique pour la carte.  Les fichiers
	<filename>/usr/src/sys/conf/NOTES</filename> et
	<filename>/usr/src/sys/arch/conf/NOTES</filename>
	vous donneront
	la liste des pilotes de périphériques pour cartes
	réseaux avec des informations sur les cartes/circuits
	supportés.  Si vous avez des doutes au sujet du bon pilote,
	lisez la page de manuel du pilote.  La page de manuel vous
	donnera plus d'information sur le matériel supporté et
	même les éventuels problèmes qui pourront
	apparaître.</para>

      <para>Si vous possédez une carte courante, la plupart du temps
	vous n'aurez pas &agrave; chercher trop loin pour trouver un pilote.
	Les pilotes pour les cartes réseaux courantes sont
	présents dans le noyau <filename>GENERIC</filename>, aussi
	votre carte devrait apparaître au démarrage, comme
	suit:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]</screen>

      <para>Dans cet exemple, nous voyons que deux cartes utilisant le
	pilote de périphérique &man.dc.4; sont présentes
	sur le système.</para>

      <para>Si le pilote de votre carte n'est pas présent dans
	le noyau <filename>GENERIC</filename>, vous devrez charger le
	module approprié pour pouvoir utiliser votre carte.  Cela
	peut être effectué de deux manières
	différentes:</para>

      <itemizedlist>
        <listitem>
	  <para>La méthode la plus simple est de charger le
	    module pour votre carte réseau avec
	    &man.kldload.8;, ou automatiquement au démarrage du
	    système en ajoutant la ligne appropriée au
	    fichier <filename>/boot/loader.conf</filename>.  Tous les
	    pilotes de cartes réseau ne sont pas disponibles
	    sous forme de modules; les cartes ISA sont un bon exemple
	    de périphériques pour lesquels les modules
	    n'existent pas.</para>
	</listitem>

	<listitem>
	  <para>Alternativement, vous pouvez compiler en statique
	    le support pour votre carte dans votre noyau.  Consultez
	    <filename>/usr/src/sys/conf/NOTES</filename>,
	    <filename>/usr/src/sys/arch/conf/NOTES</filename>
	    et la page de manuel du pilote de
	    périphérique pour savoir ce qu'il faut
	    ajouter au fichier de configuration de votre noyau.  Pour
	    plus d'information sur la recompilation de votre noyau,
	    veuillez lire le <xref linkend="kernelconfig"/>.  Si votre
	    carte a été détectée au
	    démarrage par votre noyau
	    (<filename>GENERIC</filename>) vous n'avez pas &agrave;
	    compiler un nouveau noyau.</para>
	</listitem>
      </itemizedlist>

      <sect3 xml:id="config-network-ndis">
	<title>Utilisation des pilotes NDIS de &windows;</title>

	<indexterm><primary>NDIS</primary></indexterm>
	<indexterm><primary>NDISulator</primary></indexterm>
	<indexterm><primary>pilotes &windows;</primary></indexterm>
	<indexterm><primary>Microsoft Windows</primary></indexterm>
	<indexterm><primary>Microsoft Windows</primary>
	    <secondary>pilotes de périphériques</secondary></indexterm>
	<indexterm><primary>KLD (module noyau chargeable)</primary></indexterm>
<!-- We should probably omit the expanded name, and add a <see> entry
for it.  Whatever is done must also be done to the same indexterm in
linuxemu/chapter.xml -->

	<para>Malheureusement il y a toujours de nombreux fabricants
	  qui ne fournissent pas &agrave; la communauté des
	  logiciels libres les informations concernant les pilotes
	  pour leurs cartes considérant de telles
	  informations comme des secrets industriels.  Par
	  conséquent, il ne reste aux développeurs de
	  &os; et d'autres systèmes d'exploitation libres que
	  deux choix: développer les pilotes en passant par
	  un long et pénible processus de <quote>reverse
	  engineering</quote> ou utiliser les pilotes binaires
	  existants disponibles pour la plateforme
	  &microsoft.windows;.  La plupart des développeurs,
	  y compris ceux impliqués dans &os;, ont choisi
	  cette dernière approche.</para>

	<para>Grâce aux contributions de Bill Paul (wpaul),
	  il existe un support
	  <quote>natif</quote> pour la spécification
	  d'interface des pilotes de périphérique
	  réseau (Network Driver Interface
	  Specification&mdash;NDIS).  Le NDISulator &os; (connu
	  également sous le nom de Project Evil) prend un
	  pilote binaire réseau &windows; et lui fait penser
	  qu'il est en train de tourner sous &windows;.  Etant
	  donné que le pilote &man.ndis.4; utilise un binaire
	  &windows;, il ne fonctionne que sur les systèmes
	  &i386; et amd64.  Les périphériques PCI, CardBus, PCMCIA
	  (PC-Card), et USB sont supportés.</para>

	<para>Pour utiliser le NDISulator, trois choses sont
	  nécessaires:</para>

	<orderedlist>
	 <listitem>
	    <para>les sources du noyau;</para>
	  </listitem>
	  <listitem>
	    <para>le pilote binaire &windowsxp; (extension
	      <filename>.SYS</filename>);</para>
	  </listitem>
	  <listitem>
	    <para>le fichier de configuration du pilote &windowsxp;
	      (extension <filename>.INF</filename>).</para>
	 </listitem>
	</orderedlist>

	<para>Recherchez les fichiers spécifiques &agrave;
	  votre carte.  Généralement, ils peuvent
	  être trouvés sur les CDs livrés avec la
	  carte ou sur le site du fabricant.  Dans les exemples qui
	  suivent nous utiliseront les fichiers
	  <filename>W32DRIVER.SYS</filename> et
	  <filename>W32DRIVER.INF</filename>.</para>

	<para>Le type de pilote doit correspondre à la version de
	  &os;.  Pour &os;/i386, utiliser un pilote &windows; 32bits.
	  Pour &os;/amd64, un pilote &windows; 64bits est
	  nécessaire.</para>

	<para>L'étape suivante est de compiler le pilote
	  binaire dans un module chargeable du noyau.
	  En tant que <systemitem class="username">root</systemitem>,
	  utilisez &man.ndisgen.8;:</para>

	<screen>&prompt.root; <userinput>ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</userinput></screen>

	<para>L'utilitaire &man.ndisgen.8; est interactif, il
	  sollicitera l'utilisateur pour d'éventuelles informations
	  complémentaires si nécessaire. Un nouveau module noyau est
	  créé dans le répertoire courant.  Utiliser &man.kldload.8;
	  pour charger le nouveau module:</para>

	<screen>&prompt.root; <userinput>kldload ./W32DRIVER_SYS.ko</userinput></screen>

	<para>Avec le module généré, vous devez également charger les
	  modules <filename>ndis.ko</filename> et
	  <filename>if_ndis.ko</filename>.  Cela devrait être fait
	  automatiquement quand vous chargez un module qui dépend de
	  &man.ndis.4;.  Si vous désirez les charger manuellement,
	  utilisez les commandes suivantes:</para>

	<screen>&prompt.root; <userinput>kldload ndis</userinput>
&prompt.root; <userinput>kldload if_ndis</userinput></screen>

	<para>La première commande charge le pilote d'interface
	  NDIS, la seconde charge l'interface réseau.</para>

	<para>Contrôlez maintenant la sortie de &man.dmesg.8;
	  &agrave; la recherche d'une quelconque erreur au chargement.
	  Si tout s'est bien passé, vous devriez obtenir une
	  sortie ressemblant &agrave; ce qui suit:</para>

	<screen>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</screen>

	<para>A partir de l&agrave; vous pouvez traiter le
	  périphérique <filename>ndis0</filename>
	  comme n'importe quelle interface réseau (par exemple
	  <filename>dc0</filename>).</para>

	<para>Vous pouvez configurer le système pour charger
	  les modules NDIS au démarrage du système de la
	  même manière que pour n'importe quel autre
	  module.  Tout d'abord, copiez le module
	  généré,
	  <filename>W32DRIVER_SYS.ko</filename>, dans le répertoire
	  <filename>/boot/modules</filename>.
	  Ajoutez ensuite la ligne suivante au fichier
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>W32DRIVER_SYS_load="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuration de la carte réseau</title>

      <indexterm>
	<primary>cartes réseaux</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <para>Une fois que le bon pilote de périphérique
	pour la carte réseau est chargé, la carte doit
	être configurée.  Comme beaucoup d'autres choses, la carte
	aura pu être configurée &agrave;
	l'installation par <application>sysinstall</application>.</para>

      <para>Pour afficher la configuration des interfaces réseaux
	de votre système, entrer la commande suivante:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        options=3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</screen>

      <para>Dans cet exemple, les périphériques suivants
	ont été affichés:</para>

      <itemizedlist>
	<listitem>
	  <para><filename>dc0</filename>: La première
	    interface Ethernet</para>
	</listitem>

	<listitem>
	  <para><filename>dc1</filename>: La seconde
	    interface Ethernet</para>
	</listitem>

	<listitem>
	  <para><filename>lo0</filename>: L'interface
	    &ldquo;en boucle&rdquo; (&ldquo;loopback&rdquo;)</para>
	</listitem>
      </itemizedlist>

      <para>FreeBSD utilise le nom du pilote de périphérique
	suivi par un chiffre représentant l'ordre dans lequel
	la carte est détectée au démarrage du noyau pour nommer la
	carte.  Par exemple <filename>sis2</filename> serait la
	troisième carte sur le système utilisant le pilote de
	périphérique &man.sis.4;.</para>

      <para>Dans cet exemple, le périphérique
	<filename>dc0</filename> est actif et en fonctionnement.
	Les indicateurs importants sont:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> signifie que la carte est
	    configurée et prête.</para>
	</listitem>

	<listitem>
	  <para>La carte possède une adresse Internet
	    (<literal>inet</literal>) (dans ce cas-ci
	    <systemitem class="ipaddress">192.168.1.3</systemitem>).</para>
	</listitem>

	<listitem>
	  <para>Elle a un masque de sous-réseau valide
	    (<literal>netmask</literal>;
	    <systemitem class="netmask">0xffffff00</systemitem> est équivalent
	    &agrave; <systemitem class="netmask">255.255.255.0</systemitem>).</para>
	</listitem>

	<listitem>
	  <para>Elle a une adresse de diffusion valide (dans ce cas-ci
	    <systemitem class="ipaddress">192.168.1.255</systemitem>).</para>
	</listitem>

	<listitem>
	  <para>L'adresse MAC de la carte (<literal>ether</literal>)
	    est <systemitem class="etheraddress">00:a0:cc:da:da:da</systemitem></para>
	</listitem>

	<listitem>
	  <para>La sélection du média est sur le mode
	    d'autosélection (<literal>media: Ethernet autoselect
	    (100baseTX &lt;full-duplex&gt;)</literal>).  Nous voyons
	    que <filename>dc1</filename> a été configurée
	    pour utiliser un matériel de type
	    <literal>10baseT/UTP</literal>.  Pour plus d'information
	    sur le type de matériel disponible pour un pilote de
	    périphérique, référez-vous &agrave;
	    sa page de manuel.</para>
	</listitem>

	<listitem>
	  <para>La liaison (<literal>status</literal>)
	    est <literal>active</literal>, i.e. la porteuse est
	    détectée.  Pour <filename>dc1</filename>, nous lisons
	    <literal>status: no carrier</literal>.  Cela est normal
	    lorsqu'aucun câble n'est branché &agrave;
	    la carte.</para>
	</listitem>
      </orderedlist>

      <para>Si le résultat de la commande &man.ifconfig.8; est
	similaire &agrave;:</para>

      <screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active</screen>

      <para>cela indiquerait que la carte n'a pas été
	configurée.</para>

      <para>Pour configurer votre carte, vous avez besoin des
	privilèges de l'utilisateur <systemitem class="username">root</systemitem>.
	La configuration de la carte réseau peut être
	faite &agrave; partir de la ligne de commande avec &man.ifconfig.8;
	mais vous aurez &agrave; répéter cette
	opération &agrave; chaque redémarrage du système.
	Le fichier <filename>/etc/rc.conf</filename> est l'endroit où
	ajouter la configuration de la carte réseau.</para>

      <para>Ouvrez le fichier <filename>/etc/rc.conf</filename>
	dans votre éditeur favori.  Vous devez ajouter une ligne
	pour chaque carte réseau présente sur le système, par exemple
	dans notre cas, nous avons ajouté ces lignes:</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Vous devez remplacer <filename>dc0</filename>,
	<filename>dc1</filename>, et ainsi de suite, avec
	le périphérique correspondant pour vos cartes, et les adresses
	avec celles désirées.  Vous devriez lire les pages de manuel
	du pilote de périphérique et d'&man.ifconfig.8; pour
	plus de détails sur les options autorisées et
	également la page de manuel de &man.rc.conf.5; pour plus
	d'information sur la syntaxe de
	<filename>/etc/rc.conf</filename>.</para>

      <para>Si vous avez configuré le réseau &agrave;
	l'installation, des lignes concernant la/les carte(s)
	réseau pourront être déj&agrave; présentes.
	Contrôler &agrave; deux fois le fichier
	<filename>/etc/rc.conf</filename> avant d'y ajouter des
	lignes.</para>

      <para>Vous devrez également éditer le fichier
	<filename>/etc/hosts</filename> pour ajouter les noms et les
	adresses IP des diverses machines du réseau local, si elles
	ne sont pas déj&agrave; présentes.  Pour plus
	d'information référez-vous &agrave; la page de manuel &man.hosts.5;
	et au fichier
	<filename>/usr/share/examples/etc/hosts</filename>.</para>

      <note>
	<para>S'il n'y a pas de serveur <acronym>DHCP</acronym> et
	  qu'un accès à Internet est nécessaire, configurez
	  manuellement la passerelle par défaut et le serveur de
	  noms:</para>

	<screen>&prompt.root; <userinput>echo 'defaultrouter="<replaceable>your_default_router</replaceable>"' &gt;&gt; /etc/rc.conf</userinput>
&prompt.root; <userinput>echo 'nameserver <replaceable>your_DNS_server</replaceable>' &gt;&gt; /etc/resolv.conf</userinput></screen>
      </note>
    </sect2>

    <sect2>
      <title>Test et dépannage</title>

      <para>Une fois les modifications nécessaires du fichier
	<filename>/etc/rc.conf</filename> effectuées, vous
	devrez redémarrer votre système.  Cela
	permettra la prise en compte de la ou les modifications
	au niveau des interfaces, et permettra de vérifier
	que le système redémarre sans erreur de
	configuration.  Sinon, une autre méthode pour faire prendre en
	compte les modifications au niveau de la gestion du réseau
	consiste à utiliser la commande:</para>

      <screen>&prompt.root; <userinput>service netif restart</userinput></screen>

      <note>
	<para>Si une passerelle par défaut a été configurée dans
	  <filename>/etc/rc.conf</filename>, lancez également cette
	  commande:</para>

	<screen>&prompt.root; <userinput>service routing restart</userinput></screen>
      </note>

      <para>Une fois que le système a été
	redémarré, vous testez les interfaces
	réseau.</para>

      <sect3>
	<title>Tester la carte Ethernet</title>

	<indexterm>
	  <primary>cartes réseaux</primary>
	  <secondary>tests</secondary>
	</indexterm>

	<para>Pour vérifier qu'une carte Ethernet est
	  configurée correctement, vous devez essayer deux choses.
	  Premièrement, &ldquo;pinguer&rdquo; l'interface, puis une
	  autre machine sur le réseau local.</para>

	<para>Tout d'abord testons l'interface:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>Nous devons maintenant &ldquo;pinguer&rdquo; une
	  autre machine sur le réseau:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Vous pourrez utiliser le noms de la machine &agrave;
	  la place de <systemitem class="ipaddress">192.168.1.2</systemitem>
	  si vous avez configuré le fichier
	  <filename>/etc/hosts</filename>.</para>
      </sect3>

      <sect3>
	<title>Dépannage</title>

      <indexterm>
	<primary>cartes réseaux</primary>
	<secondary>dépannage</secondary>
      </indexterm>

      <para>Le dépannage de matériels ou de logiciels
	est toujours une tâche relativement pénible, mais
	qui peut être rendue plus aisée en
	vérifiant en premier lieu certaines choses
	élémentaires.  Votre câble réseau
	est-il branché?  Avez-vous correctement
	configuré les services réseau?  Le coupe-feu
	est-il bien configuré?  Est-ce que la carte
	réseau est supportée par &os;?  Consultez
	toujours les notes concernant le matériel avant
	d'envoyer un rapport de bogue.  Mettez &agrave; jour votre
	version de &os; vers la dernière version STABLE.
	Consultez les archives des listes de diffusion, et faites
	même des recherches sur l'Internet.</para>

      <para>Si la carte fonctionne mais les performances sont
	mauvaises, une lecture de la page de manuel &man.tuning.7;
	peut valoir la peine.  Vous pouvez également
	vérifier la configuration du réseau puisque des
	paramètres réseau incorrects peuvent donner lieu
	&agrave; des connexions lentes.</para>

      <para>Certains utilisateurs peuvent voir apparaître un ou
	deux messages <errorname>device timeout</errorname>, ce qui
	est normal pour certaines cartes.  Si ces messages se
	multiplient, assurez-vous que la carte n'est pas en conflit
	avec un autre périphérique.  Contrôlez
	&agrave; deux fois les câbles de connexion.
	Peut-être que vous avez juste besoin d'une autre
	carte.</para>

      <para>Parfois, des utilisateurs sont confrontés &agrave;
	des messages d'erreur <errorname>watchdog timeout</errorname>.
	La première chose &agrave; faire dans ce cas est de
	vérifier votre câble réseau.  De
	nombreuses cartes demandent un slot PCI supportant le
	<quote>Bus Mastering</quote>.  Sur certaines cartes
	mère anciennes, seul un slot PCI le permet (la plupart
	du temps le slot 0).  Consultez la documentation de la carte
	réseau et de la carte mère pour
	déterminer si cela peut être &agrave; l'origine
	du problème.</para>

      <para>Les messages <errorname>No route to host</errorname>
	surviennent si le système est incapable de router un
	paquet vers la machine de destination.  Cela peut arriver s'il
	n'y a pas de route par défaut de définie, ou si
	le câble réseau est débranché.
	Vérifiez la sortie de la commande <command>netstat
	-nr</command> et assurez-vous qu'il y a une route valide en
	direction de la machine que vous essayez d'atteindre.  Si ce
	n'est pas le cas, lisez la <xref linkend="advanced-networking"/>.</para>

      <para>Les messages d'erreur <errorname>ping: sendto: Permission
	denied</errorname> sont souvent dus &agrave; un coupe-feu mal
	configuré.  Si <command>ipfw</command> est
	activé dans le noyau mais qu'aucune règle n'a
	été définie, alors la politique par
	défaut est de refuser tout trafic, même les
	requêtes <quote>ping</quote>!  Lisez <xref linkend="firewalls"/> pour plus d'informations.</para>

      <para>Parfois les performances de la carte ne sont pas bonnes,
	ou en dessous de la moyenne.  Dans ce cas il est
	recommandé de passer la sélection du
	média du mode <literal>autoselect</literal> au mode
	adéquat.  Alors que cela fonctionne
	généralement pour la plupart du matériel,
	il se peut que cela ne résolve pas le problème
	pour tout de monde.  Encore une fois, contrôlez les
	paramétrages réseau et consultez la page de
	manuel &man.tuning.7;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-virtual-hosts">
    <title>Hôtes virtuels</title>

    <indexterm><primary>hôtes virtuels</primary></indexterm>
    <indexterm><primary>alias IP</primary></indexterm>

    <para>Une utilisation très courante de FreeBSD est
      l'hébergement de sites virtuels, où un serveur
      apparaît pour le réseau comme étant
      plusieurs serveurs différents.  Ceci est possible en assignant
      plusieurs adresses réseau &agrave; une interface.</para>

    <para>Une interface réseau donnée possède une
      adresse &ldquo;réelle&rdquo;, et peut avoir n'importe
      quel nombre d'adresses &ldquo;alias&rdquo;.  Ces alias sont
      normalement ajoutés en plaçant les entrées
      correspondantes dans le fichier
      <filename>/etc/rc.conf</filename>.</para>

    <para>Une entrée d'alias pour l'interface
      <filename>fxp0</filename> ressemble &agrave;:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Notez que les entrées d'alias doivent commencer avec alias0
      et continuer en ordre croissant, (par exemple, _alias1, _alias2,
      et ainsi de suite).  Le processus de configuration s'arrêtera
      au premier nombre absent.</para>

    <para>Le calcul des masques de réseau est important, mais
      heureusement assez simple.  Pour une interface donnée, il doit y
      avoir une adresse qui représente correctement le masque de
      réseau de votre réseau.  Tout autre adresse appartenant
      &agrave; ce réseau devra avoir un masque de réseau
      avec chaque bit &agrave; <literal>1</literal> (exprimé soit
      sous la forme <systemitem class="netmask">255.255.255.255</systemitem>
      soit <systemitem class="netmask">0xffffffff</systemitem>).</para>

    <para>Par exemple, considérez le cas où
      l'interface <filename>fxp0</filename> est connectée &agrave;
      deux réseaux, le réseau <systemitem class="ipaddress">10.1.1.0</systemitem> avec un masque de
      réseau de
      <systemitem class="netmask">255.255.255.0</systemitem> et le réseau <systemitem class="ipaddress">202.0.75.16</systemitem> avec un masque de
      <systemitem class="netmask">255.255.255.240</systemitem>.  Nous voulons que le système apparaisse de
      <systemitem class="ipaddress">10.1.1.1</systemitem> jusqu'&agrave; <systemitem class="ipaddress">10.1.1.5</systemitem> et &agrave; <systemitem class="ipaddress">202.0.75.17</systemitem> jusqu'&agrave;
      <systemitem class="ipaddress">202.0.75.20</systemitem>.  Comme noté
      plus haut, seule la première adresse dans un intervalle
      réseau donné (dans ce cas, <systemitem class="ipaddress">10.0.1.1</systemitem> et <systemitem class="ipaddress">202.0.75.17</systemitem>) devrait avoir un masque de
      sous-réseau réel; toutes les autres adresses
      (<systemitem class="ipaddress">10.1.1.2</systemitem> &agrave; <systemitem class="ipaddress">10.1.1.5</systemitem> et <systemitem class="ipaddress">202.0.75.18</systemitem> jusqu'&agrave; <systemitem class="ipaddress">202.0.75.20</systemitem>) doivent être
      configurées avec un masque de sous-réseau de <systemitem class="netmask">255.255.255.255</systemitem>.</para>

    <para>Les entrées suivantes du fichier
      <filename>/etc/rc.conf</filename> configurent la carte
      correctement pour cet arrangement:</para>

<programlisting>ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 xml:id="configtuning-configfiles">
    <title>Fichiers de configuration</title>

    <sect2>
      <title>Organisation du répertoire <filename class="directory">/etc</filename></title>
      <para>Il existe un certain nombre de répertoires dans lesquels
	se trouvent les informations de configuration.  Ceux-ci
	incluent:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="2*"/>

	  <tbody>
	    <row>
	      <entry><filename class="directory">/etc</filename></entry>
	      <entry>Information de configuration générique du
		système; les données ici sont
		spécifiques au système.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/etc/defaults</filename></entry>
	      <entry>Version par défaut des fichiers de configuration
		du système.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/etc/mail</filename></entry>
	      <entry>Configuration de &man.sendmail.8;, et autres fichiers
		de configuration d'agent de transmission du courrier
		électronique.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/etc/ppp</filename></entry>
	      <entry>Configuration pour les programmes PPP utilisateur
		et intégré au noyau.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/etc/namedb</filename></entry>
	      <entry>Emplacement par défaut pour les données de
		 &man.named.8;.  Normalement
		 <filename>named.conf</filename> et les fichiers de zone
		 sont stockés dans ce répertoire.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/usr/local/etc</filename></entry>
	      <entry>Fichiers de configuration pour les applications
		installées.  Peut contenir des sous-répertoires
		pour chaque application.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/usr/local/etc/rc.d</filename></entry>
	      <entry>Procédures de lancement/d'arrêt pour les
		applications installées.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/var/db</filename></entry>
	      <entry>Fichiers de bases de données automatiquement
		générés, spécifiques
		au système, comme la base de données
		des logiciels installés, la base de données de
		localisation des fichiers, et ainsi de suite.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Nom d'hôtes</title>

      <indexterm><primary>nom d'hôte</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm>
	  <primary><filename>resolv.conf</filename></primary>
	</indexterm>

	<para><filename>/etc/resolv.conf</filename> gère comment
	  le résolveur de FreeBSD accède au système
	  de nom de domaine d'Internet (DNS).</para>

	<para>Les entrées la plus classiques du fichier
	  <filename>resolv.conf</filename> sont:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="2*"/>

	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>L'adresse IP du serveur de noms auquel le
		  résolveur devrait envoyer ses requêtes.  Les
		  serveurs sont sollicités dans l'ordre listé
		  avec un maximum de trois.</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Liste de recherche pour la résolution de nom de
		  machine.  Ceci est normalement déterminé par le
		  domaine de l'hôte local.</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Le nom du domaine local.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Un fichier <filename>resolv.conf</filename> typique:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Seule une des options <literal>search</literal> et
	  <literal>domain</literal> devrait être
	  utilisée.</para></note>

	<para>Si vous utilisez DHCP, &man.dhclient.8; réécrit
	  habituellement <filename>resolv.conf</filename> avec
	  l'information reçue du serveur DHCP.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> est une simple base de
	  données texte, une réminiscence des débuts
	  d'Internet.  Il travaille en conjonction avec les serveurs
	  DNS et NIS pour fournir les correspondances nom vers adresse
	  IP.  Les ordinateurs locaux reliés par
	  l'intermédiaire d'un réseau local peuvent
	  être ajoutés dans ce fichier pour une résolution
	  de noms simple plutôt que de configurer un serveur
	  &man.named.8;.
	  De plus <filename>/etc/hosts</filename> peut être
	  utilisé pour fournir un enregistrement local de
	  correspondances de nom, réduisant ainsi le besoin
	  de requêtes vers l'extérieur pour les noms auxquels on
	  accède couramment.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</programlisting>

	<para><filename>/etc/hosts</filename> suit le format simple
	  suivant:</para>

	<programlisting>[Internet address] [official hostname] [alias1] [alias2] ...</programlisting>

	<para>Par exemple:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Consultez la page de manuel &man.hosts.5; pour plus
	  d'informations.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuration des fichiers de trace</title>

      <indexterm><primary>fichiers de trace</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> est le fichier de configuration
	  du programme &man.syslogd.8;.  Il indique quel type de
	  messages <command>syslog</command> sera enregistré
	  dans des fichiers de traces particuliers.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Consultez la page de manuel &man.syslog.conf.5; pour plus
	  d'informations.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para><filename>newsyslog.conf</filename> est le fichier de
	  configuration de &man.newsyslog.8;, un programme qui est
	  normalement programmé &man.cron.8; pour s'exécuter
	  périodiquement.  &man.newsyslog.8; détermine quand les
	  fichiers de traces doivent être archivés
	  ou réorganisés.  <filename>logfile</filename> devient
	  <filename>logfile.0</filename>, <filename>logfile.0</filename>
	  devient &agrave; son tour <filename>logfile.1</filename>, et ainsi
	  de suite.  D'autre part, les fichiers de traces peuvent être
	  archivés dans le format &man.gzip.1;, ils se nommeront
	  alors: <filename>logfile.0.gz</filename>,
	  <filename>logfile.1.gz</filename>, et ainsi de suite.</para>

	<para><filename>newsyslog.conf</filename> indique quels
	  fichiers de traces doivent être gérés,
	  combien doivent être conservés, et quand ils
	  doivent être modifiés.  Les fichiers de traces
	  peuvent être réorganisés et/ou archivés
	  quand ils ont soit atteint une certaine taille, soit &agrave; une
	  certaine période/date.</para>

	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Consultez la page de manuel &man.newsyslog.8; pour plus
	  d'informations.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> ressemble &agrave;
	<filename>rc.conf</filename>.  Les valeurs sont fixées sous
	la forme <literal>variable=value</literal>.  Les valeurs
	spécifiées sont positionnées
	après que le système soit passé
	dans le mode multi-utilisateurs.  Toutes les variables ne sont
	pas paramétrables dans ce mode.</para>

      <para>Pour désactiver l'enregistrement des signaux fatals
	de fin de processus et empêcher les utilisateurs de voir
	les processus lancés par les autres, les variables
	suivantes peuvent être paramétrées dans
	<filename>sysctl.conf</filename>:</para>

      <programlisting># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-sysctl">
    <title>Optimisation avec &man.sysctl.8;</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>optimisation</primary>
      <secondary>avec sysctl</secondary>
    </indexterm>

    <para>&man.sysctl.8; est une interface qui vous permet d'effectuer
      des changements de paramétrage sur un système
      FreeBSD en fonctionnement.  Cela comprend de nombreuses options
      avancées de la pile TCP/IP et du système de
      mémoire virtuelle qui peuvent améliorer dramatiquement les
      performances pour un administrateur système
      expérimenté.  Plus de cinq cent variables
      système peuvent être lues et modifiées
      grâce &agrave; &man.sysctl.8;.</para>

    <para>&man.sysctl.8; remplit deux fonctions: lire et modifier
      les paramétrages du système.</para>

    <para>Pour afficher toutes les variables lisibles:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Pour lire une variable particulière, par exemple,
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Pour fixer une variable particulière, utilisez
      la syntaxe intuitive
      <replaceable>variable</replaceable>=<replaceable>valeur</replaceable>
      :</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -&gt; 5000</screen>

    <para>Les valeurs des variables sysctl sont généralement des
      chaînes de caractères, des nombres, ou des
      booléens (un variable booléenne étant
      <literal>1</literal> pour oui ou un <literal>0</literal> pour
      non).</para>

    <para>Si vous voulez fixer automatiquement certaines variables
      &agrave; chaque démarrage de la machine, ajoutez-les au fichier
      <filename>/etc/sysctl.conf</filename>.  Pour plus d'information
      consultez la page de manuel &man.sysctl.conf.5; et la
      <xref linkend="configtuning-sysctlconf"/>.</para>

  <sect2 xml:id="sysctl-readonly">
    <info><title>Variables &man.sysctl.8; en lecture seule</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contribution de </contrib></author>
      </authorgroup>
    </info>
    

    <para>Dans certains cas, il peut être nécessaire de
      modifier des variables &man.sysctl.8; en lecture seule.  Bien
      que cela soit parfois inévitable, cela ne peut être
      fait qu'au (re)démarrage de la machine.</para>

    <para>Par exemple sur certains modèles d'ordinateurs
      portables le périphérique &man.cardbus.4; ne
      sondera pas le système &agrave; la recherche des zones
      mémoires, et échouera avec des erreurs du
      type:</para>

    <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

    <para>Des cas comme le précédent demandent
      généralement la modification de paramètres
      &man.sysctl.8; par défaut qui sont en lecture seule.
      Pour palier &agrave; ces situations un utilisateur peut placer
      un paramétrage (&ldquo;OID&rdquo;&mdash;Object
      IDentifier) &man.sysctl.8; dans le fichier local
      <filename>/boot/loader.conf.local</filename>.  Les
      paramétrages par défaut se trouvent dans le
      fichier <filename>/boot/defaults/loader.conf</filename>.</para>

    <para>Pour corriger le problème précédent, il
      faudrait que l'utilisateur ajoute la ligne
      <option>hw.pci.allow_unsupported_io_range=1</option> dans le
      fichier précédemment indiqué.
      Désormais le périphérique &man.cardbus.4;
      devrait fonctionner normalement.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-disk">
    <title>Optimiser les disques</title>

    <sect2>
      <title>Les variables sysctl</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>vfs.vmiodirenable</varname>
	  peut être positionnée soit &agrave; 0
	  (désactivée) soit &agrave; 1
	  (activée); elle est a 1 par défaut.  Cette variable
	  spécifie comment les répertoires sont
	  cachés par le système.
	  La plupart des répertoires sont petits, utilisant juste un
	  simple fragment du système de fichiers (typiquement 1KO) et
	  moins dans le cache en mémoire (typiquement 512 octets).
	  Avec cette variable désactivée (&agrave; 0), le
	  cache en mémoire ne cachera qu'un nombre fixe de
	  répertoires même si vous disposez d'une grande
	  quantité de mémoire.  Activée (&agrave; 1), cette variable sysctl
	  permet au cache en mémoire d'utiliser le cache des pages de
	  mémoire virtuelle pour cacher les répertoires,
	  rendant toute la mémoire disponible pour cacher les
	  répertoires.  Cependant, la taille minimale de
	  l'élément mémoire utilisé pour cacher
	  un répertoire est une page physique (typiquement 4KO)
	  plutôt que 512 octets.
	  Nous recommandons de conserver de cette option activée si
	  vous faites fonctionner des services qui manipulent un grand
	  nombre de fichiers.  De tels services peuvent être des
	  caches web, d'importants systèmes de courrier
	  électronique, et des systèmes serveurs de groupe
	  de discussion.  Conserver cette option activée ne réduira
	  généralement pas les performances même
	  avec la mémoire gaspillée mais vous devriez
	  faire des expériences pour le déterminer.</para>
      </sect3>

     <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm>
	  <primary><varname>vfs.write_behind</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>vfs.write_behind</varname> est
	  positionnée par défaut &agrave;
	  <literal>1</literal> (activée).  Elle demande au
	  système de fichiers d'effectuer les écritures
	  lorsque des grappes complètes de données ont
	  été collectées, ce qui se produit
	  généralement lors de l'écriture
	  séquentielle de gros fichiers.  L'idée est
	  d'éviter de saturer le cache tampon avec des tampons
	  sales quand cela n'améliorera pas les performances d'E/S.
	  Cependant, cela peut bloquer les processus et dans certaines
	  conditions vous pouvez vouloir désactiver cette
	  fonction.</para>
       </sect3>

       <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm>
	  <primary><varname>vfs.hirunningspace</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>vfs.hirunningspace</varname>
	  détermine combien d'opérations d'écriture
	  peuvent être mises en attente &agrave; tout moment au
	  niveau des contrôleurs disques du système.  La
	  valeur par défaut est normalement suffisante mais sur les
	  machines avec de nombreux disques, vous pouvez vouloir
	  l'augmenter jusqu'&agrave; quatre ou cinq
	  <emphasis>méga-octets</emphasis>.  Notez que fixer une
	  valeur trop élevée (dépassant la limite
	  d'écriture du cache tampon) peut donner lieu &agrave; de
	  très mauvaises performances.  Ne fixez pas cette valeur
	  &agrave; une valeur élevée arbitraire!  Des
	  valeurs d'écriture élevées peuvent ajouter
	  des temps de latence aux opérations d'écriture
	  survenant au même moment.</para>

	<para>Il existent d'autres variables sysctl relatives aux caches
	  tampons et aux pages VM.  Nous ne recommandons pas de modifier
	  ces valeurs, le système VM
	  effectue un très bon travail d'auto-optimisation.</para>
       </sect3>

       <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm>
	  <primary><varname>vm.swap_idle_enabled</varname></primary>
	</indexterm>

	<para>La variable <varname>vm.swap_idle_enabled</varname> est
	  utile dans le cas de systèmes multi-utilisateurs
	  importants où il y a beaucoup d'utilisateurs s'attachant
	  et quittant le système et de nombreux processus inactifs.
	  De tels systèmes tendent &agrave; générer
	  une pression assez importante et continue sur les
	  réserves de mémoire libres.  Activer cette
	  fonction et régler l'hystéresis de
	  libération de l'espace de pagination (en secondes
	  d'inactivité) par l'intermédiaire des variables
	  <varname>vm.swap_idle_threshold1</varname> et
	  <varname>vm.swap_idle_threshold2</varname>, vous permet de
	  diminuer la priorité des pages mémoire
	  associées avec les processus inactifs plus rapidement
	  qu'avec l'algorithme normal de libération.  Cela aide le
	  <quote>daemon</quote> de libération des pages.  N'activez
	  cette option que si vous en besoin, parce que la concession que
	  vous faites est d'utiliser l'espace de pagination pour les pages
	  mémoire plus tôt qu'&agrave; l'accoutumé,
	  consommant par conséquent plus d'espace de pagination et
	  de bande passante disque.  Sur un petit système, cette
	  option aura un effet limité mais dans le cas d'un
	  système important qui fait appel &agrave; l'espace de
	  pagination de façon modérée, cette option
	  permettra au système VM de transférer l'ensemble
	  des processus de et vers la mémoire
	  aisément.</para>
       </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>FreeBSD 4.3 a flirté avec la désactivation
	  du cache en écriture des disques IDE.  Cela réduisit la
	  bande passante en écriture des disques IDE mais fut
	  considéré comme nécessaire en raison de
	  sérieux problèmes de cohérence de
	  données introduits par les fabricants de disques durs.
	  Le problème est que les disques IDE mentent sur le
	  moment où une écriture est réellement
	  terminée.  Avec le cache en écriture IDE
	  activé, les disques durs IDE non seulement
	  n'écriront pas les données dans l'ordre, mais parfois
	  retarderont l'écriture de certains blocs indéfiniment
	  sous une charge disque importante.  Un crash ou une coupure
	  secteur pourra être &agrave; l'origine de
	  sérieuses corruptions du système de fichiers.
	  Par précaution le paramétrage par défaut
	  de FreeBSD fut modifié.  Malheureusement, le
	  résultat fut une telle perte de performances que nous avons
	  réactivé le cache en écriture
	  après cette version de FreeBSD.  Vous devriez
	  contrôler la valeur par
	  défaut sur votre système en examinant la variable
	  sysctl <varname>hw.ata.wc</varname>.  Si le cache en
	  écriture des disques IDE est désactivé,
	  vous pouvez le réactiver en positionnant la variable
	  &agrave; 1.  Cela doit être fait &agrave; partir du chargeur au
	  démarrage.  Tenter de le faire après le
	  démarrage du noyau n'aura aucun effet.</para>

	<para>Pour plus d'informations, veuillez consulter la page de
	  manuel &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	(<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><varname>kern.cam.scsi_delay</varname></primary>
	</indexterm>

	<indexterm>
	  <primary>options du noyau</primary>
	  <secondary><literal>SCSI_DELAY</literal></secondary>
	</indexterm>

	<para>L'option de configuration du noyau
	<literal>SCSI_DELAY</literal> peut être utilisée
	pour réduire le temps de démarrage du
	système.  Le délai par défaut est important
	et peut être responsable de plus de <literal>15</literal>
	secondes d'attente lors du processus de démarrage.
	Réduire ce délai &agrave; <literal>5</literal>
	secondes est généralement suffisant (tout
	particulièrement avec les disques modernes).
	L'option de démarrage
	<varname>kern.cam.scsi_delay</varname> devrait être utilisée.  Cette option de
	démarrage et celle de configuration du noyau acceptent
	des valeurs en <emphasis>millisecondes</emphasis> et <emphasis>non pas</emphasis> en
	<emphasis>secondes</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="soft-updates">
      <title>Les &ldquo;Soft Updates&rdquo;</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Le programme &man.tunefs.8; peut être utilisé
	pour régler finement un système de fichiers.
	Ce programme dispose de nombreuses options différentes, mais
	pour l'instant nous nous intéresserons uniquement &agrave;
	l'activation et la désactivation des &ldquo;Soft
	Updates&rdquo;, ce qui fait avec:</para>

      <screen>&prompt.root; tunefs -n enable /filesystem
&prompt.root; tunefs -n disable /filesystem</screen>

      <para>Un système de fichiers ne peut être modifié
	avec &man.tunefs.8; tant qu'il est monté.  Un bon moment pour
	activer les &ldquo;Soft Updates&rdquo; est avant que les
	partitions ne soient montées en mode mono-utilisateur.</para>

      <para>Les &ldquo;Soft Updates&rdquo; améliorent de façon
	drastique les performances sur les méta-données,
	principalement la création et la suppression de fichier, par
	l'utilisation d'un cache mémoire.  Nous recommandons d'activer
	les &ldquo;Soft Updates&rdquo; sur tous vos systèmes de
	fichiers.  Il y a deux inconvénients aux &ldquo;Soft
	Updates&rdquo; que vous devez connaître: tout d'abord, les
	&ldquo;Soft Updates&rdquo; garantissent la cohérence du
	système de fichiers en cas de crash mais pourront facilement
	être en retard de quelques secondes (voir même une minute!)
	dans la mise &agrave; jour du disque.  Si votre système plante
	il se peut que vous perdiez plus de travail que dans d'autres cas.
	Deuxièmement, les &ldquo;Soft Updates&rdquo; retardent la
	libération des blocs du système de fichiers.  Si vous
	avez un système de fichiers (comme le système de
	fichiers racine) qui est presque plein, effectuer une mise &agrave;
	jour majeure, comme un <command>make installworld</command>,
	peut mener &agrave; un manque d'espace sur le système de
	fichiers et faire échouer la mise &agrave; jour.</para>

      <sect3>
	<title>Plus de détails &agrave; propos des
	  &ldquo;Soft Updates&rdquo;</title>

	<indexterm>
	  <primary>Soft Updates</primary>
	  <secondary>détails</secondary>
	</indexterm>

	<para>Il y a deux approches traditionnelles pour écrire les
	  méta-données d'un système de fichiers sur le
	  disque (mise &agrave; jour des méta-données et mise
	  &agrave; jour des éléments sans données
	  comme les inodes ou les répertoires).</para>

	<para>Historiquement, le comportement par défaut
	  était d'écrire les mises &agrave; jour des
	  méta-données de façon synchrone.  Si un
	  répertoire a été modifié, le
	  système attendait jusqu'&agrave; ce que le changement soit
	  effectivement écrit sur le disque.  Les tampons des
	  données de fichier (contenu du fichier) passaient par le
	  cache mémoire et étaient copiés
	  sur le disque plus tard de façon asynchrone.
	  L'avantage de cette implémentation est
	  qu'elle est effectuée sans risque.  S'il y a un
	  problème durant une mise &agrave; jour, les
	  méta-données sont toujours dans
	  un état consistant.  Un fichier est soit
	  créé complètement soit pas du tout.  Si les
	  blocs de données d'un fichier n'ont pas trouvé leur
	  chemin du cache mémoire vers le disque au moment du crash,
	  &man.fsck.8; est capable de s'en apercevoir et de réparer le
	  système de fichiers en fixant la taille du fichier &agrave;
	  0.  De plus, l'implémentation est claire et simple.
	  L'inconvénient est que la modification des
	  méta-données
	  est lente.  Un <command>rm -r</command>, par exemple,
	  touche &agrave; tous les fichiers dans un répertoire
	  séquentiellement, mais chaque modification du
	  répertoire (effacement d'un fichier) sera écrite
	  de façon synchrone sur le disque.
	  Cela comprend les mises &agrave; jour
	  du répertoire lui-même, de la table des inodes, et
	  éventuellement celles sur des blocs indirects alloués
	  par le fichier.  Des considérations semblables s'appliquent
	  &agrave; la création d'importantes hiérarchies
	  ((<command>tar -x</command>).</para>

	<para>Le deuxième cas est la mise &agrave; jour
	  asynchrone des méta-données.  C'est le comportement
	  par défaut de Linux/ext2fs et de l'usage de
	  <command>mount -o async</command> pour l'UFS des systèmes
	  BSD.  Toutes les mises &agrave; jour des méta-données
	  passent également par l'intermédiaire d'un cache
	  mémoire, c'est &agrave; dire, qu'elles seront
	  mélangées
	  aux mises &agrave; jour des données du contenu du fichier.
	  L'avantage de cette implémentation est qu'il n'y a pas
	  besoin d'attendre jusqu'&agrave; l'écriture sur le disque
	  de chaque mise &agrave; jour de méta-données, donc
	  toutes les opérations qui sont &agrave; l'origine d'une grande
	  quantité de mise &agrave; jour de méta-données
	  fonctionnent bien plus rapidement que dans le cas synchrone.
	  De plus, l'implémentation est toujours claire et simple, il y
	  a donc peu de risque qu'un bogue se cache dans le code.
	  L'inconvénient est qu'il n'y a aucune garantie du tout sur la
	  cohérence du système de fichiers.  S'il y a un
	  problème durant une opération qui met &agrave; jour
	  une grande quantité de méta-données
	  (comme une coupure secteur, ou quelqu'un appuyant sur le
	  bouton reset), le système de fichiers sera laissé
	  dans un état imprévisible.  Il n'y a aucune
	  opportunité d'examiner l'état du système
	  de fichiers quand le système est &agrave; nouveau relancé;
	  les blocs de données d'un fichier pourraient
	  déj&agrave; avoir été inscrits sur
	  le disque alors que la mise &agrave; jour de la table des inodes
	  ou du répertoire associé n'a pas
	  été faite.  Il est en fait impossible
	  d'implémenter un <command>fsck</command>
	  qui est capable de nettoyer le chaos résultant (parce que
	  l'information nécessaire n'est pas disponible sur le
	  disque).  Si le système de fichiers a été
	  endommagé irrémédiablement, le seul choix est
	  de le recréer avec &man.newfs.8; et de
	  récupérer les données &agrave; partir
	  de sauvegardes.</para>

	<para>La solution commune pour ce problème fut
	  d'implémenter une <emphasis>région de
	  trace</emphasis>, dont
	  on fait souvent référence sous le terme de
	  <emphasis>journalisation</emphasis>, bien que ce terme ne
	  soit pas toujours utilisé de façon
	  cohérente et est occasionnellement utilisé
	  pour d'autres formes de transaction avec trace.  Les mises &agrave;
	  jour des méta-données sont toujours écrites
	  de façon synchrone, mais seulement sur une petite région
	  du disque.  Elles seront plus tard déplacées vers
	  leur emplacement correct.  Parce que la région de trace
	  est une petite région contiguë sur le disque,
	  il n'y a pas de grandes distances de déplacement
	  pour les têtes des disques, même durant
	  les opérations importantes, donc ces opérations
	  sont plus rapides que les mises &agrave; jour synchrones.
	  De plus la complexité de l'implémentation
	  est relativement
	  limitée, donc le risque de présence de bogues est
	  faible. Un inconvénient est que toutes les
	  méta-données sont écrites deux fois (une fois
	  dans la région de trace et une fois sur l'emplacement
	  correct) donc pour un fonctionnement normal, une baisse
	  des performances pourra en résulter.  D'autre part,
	  dans le cas d'un crash, toutes les opérations sur les
	  méta-données en attente peuvent rapidement
	  être annulées ou complétées
	  &agrave; partir de la zone de trace après le
	  redémarrage du système, ayant pour
	  résultat un démarrage rapide du
	  système de fichiers.</para>

	<para>Kirk McKusick, le développeur du FFS de Berkeley,
	  a résolu le problème avec les
	  &ldquo;Soft Updates&rdquo;:
	  toutes les mises &agrave; jour des méta-données sont
	  conservées en mémoire et inscrites sur le disque
	  selon une séquence ordonnée (&ldquo;mise
	  &agrave; jour ordonnée des méta-données&rdquo;).
	  Ceci a pour effet, dans le cas d'un nombre d'opérations
	  sur les méta-données important, que les
	  dernières mises &agrave; jour sur un élément
	  &ldquo;attrapent&rdquo; les premières si ces
	  dernières sont encore en mémoire et n'ont pas
	  encore été inscrites sur le disque.  Donc toutes
	  les opérations sur, par exemple, un répertoire sont
	  généralement effectuées en
	  mémoire avant que la mise &agrave; jour ne soit
	  écrite sur le disque (les blocs de données
	  sont ordonnés en fonction de leur position de
	  sorte &agrave; ce qu'ils ne soient pas sur le disque avant leur
	  méta-données).  Si le système
	  crash, cela provoque un &ldquo;retour dans les traces&rdquo;
	  implicite: toutes les opérations qui n'ont pas
	  trouvé leur chemin vers le disque apparaissent comme si
	  elles n'avaient jamais existé.  Un état
	  cohérent du système de fichiers est maintenu et
	  apparaît comme étant celui de 30 ou 60 secondes
	  plus tôt.  L'algorithme utilisé garantie que toutes les
	  ressources utilisées soient marquées
	  avec leur bons &ldquo;bitmaps&rdquo;: blocs et inodes.
	  Après un crash, les seules erreurs d'allocation de
	  ressources qui apparaissent sont les ressources qui ont
	  été marquées comme
	  &ldquo;utilisées&rdquo; et qui sont en fait
	  &rdquo;libre&rdquo;.  &man.fsck.8; reconnaît cette
	  situation, et libère les ressources qui ne sont plus
	  utilisées.  On peut ignorer sans risque l'état
	  &ldquo;sale&rdquo; d'un système de fichiers après un
	  crash en forçant son montage avec <command>mount
	  -f</command>.  Afin de libérer les ressources qui peuvent
	  être inutilisées, &man.fsck.8; doit
	  être exécuté plus tard.
	  C'est l'idée qu'il y a derrière le
	  &ldquo;<emphasis>background fsck</emphasis>&rdquo; (fsck en
	  tâche de fond): au démarrage du système, seule
	  un &ldquo;<emphasis>snapshot</emphasis>&rdquo; (photographie)
	  du système de fichiers est prise.  La commande
	  <command>fsck</command> peut être
	  exécutée plus tard sur ce système de
	  fichiers.  Tous les systèmes de fichiers peuvent
	  être montés &ldquo;sales&rdquo;, donc le
	  système passe en
	  mode multi-utilisateurs.  Ensuite, les
	  <command>fsck</command> en tâche de fond seront
	  programmés pour tous les systèmes de fichiers pour
	  lesquels c'est nécessaire, pour libérer les ressources
	  qui peuvent être inutilisées (les systèmes
	  qui n'utilisent pas les &lsquo;Soft Updates&rdquo; ont
	  toujours besoin du <command>fsck</command>
	  en avant plan).</para>

	<para>L'avantage est que les opérations sur les
	  méta-données sont presque aussi rapides que les
	  mises &agrave; jour asynchrones (i.e. plus rapide qu'avec le
	  &ldquo;<emphasis>logging</emphasis>&rdquo; - traçage,
	  qui doit écrire les méta-données deux
	  fois).  Les inconvénients sont la complexité du code
	  (impliquant un haut risque de bogues dans une zone qui est
	  hautement sensible en raison de risque perte de données
	  utilisateur), et une plus grande consommation en mémoire.
	  De plus il y a quelques particularités que l'on peut
	  rencontrer lors de l'utilisation.  Après un crash,
	  l'état du système apparaît être en quelque
	  sorte &ldquo;plus vieux&rdquo;.  Dans des situations
	  où l'approche synchrone classique aurait donné lieu
	  &agrave; des fichiers de taille nulle restant après le
	  <command>fsck</command>, ces fichiers n'existent pas du
	  tout avec un système de fichiers utilisant les
	  &ldquo;Soft Updates&rdquo; parce que ni les
	  méta-données ni les contenus de fichiers n'ont
	  jamais été inscrits sur le disque.  L'espace disque
	  n'est pas rendu tant que les mises &agrave; jour n'ont pas
	  été inscrites sur le disque, ce qui peut se produire
	  quelques temps après l'exécution de
	  <command>rm</command>.  Cela peut être &agrave;
	  l'origine de problèmes quand on installe une grande
	  quantité de données sur un système de fichiers
	  qui ne dispose pas de suffisamment d'espace pour contenir tous les
	  fichiers deux fois.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-kernel-limits">
    <title>Optimisation des limitations du noyau</title>

    <indexterm>
      <primary>Optimisation</primary>
      <secondary>limitations du noyau</secondary>
    </indexterm>

    <sect2 xml:id="file-process-limits">
      <title>Limitations sur les fichiers et les processus</title>

      <sect3 xml:id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para>Le paramètre <varname>kern.maxfiles</varname>
	  peut être augmenté ou diminué
	  en fonction des besoins du système.  Cette variable
	  indique le nombre maximal de descripteurs de fichier sur
	  votre système.  Quand la table de descripteurs de fichier
	  est pleine, le message <errorname>file: table is
	  full</errorname> s'affichera régulièrement dans le
	  tampon des messages système, qui peut être
	  visualisé avec la commande
	  <command>dmesg</command>.</para>

	<para>Chaque fichier ouvert, chaque &ldquo;socket&rdquo;,
	  ou chaque emplacement en pile utilise un descripteur de fichier.
	  Un serveur important peut facilement demander plusieurs
	  milliers de descripteurs de fichiers, en fonction du type et
	  du nombre de services s'exécutant en même temps.</para>

	<para>Sous les anciennes versions de &os;, la valeur par défaut de <varname>kern.maxfile</varname>
	  est fixée par l'option <option>maxusers</option>
	  dans votre fichier de configuration du noyau.
	  <varname>kern.maxfiles</varname> augmente proportionnellement
	  avec la valeur de <option>maxusers</option>.  Quand vous
	  compilez un noyau sur mesure, il est bon de paramétrer cette
	  option en fonction de l'utilisation de votre système.  Ce
	  nombre fixe la plupart des limites pré-définies du
	  noyau.
	  Même si une machine de production pourra ne pas avoir en
	  réalité 256 utilisateurs connectés
	  simultanément, les ressources requises pourront être
	  semblables pour un serveur web important.</para>

	<para>La variable <varname>kern.maxusers</varname> est
	  automatiquement ajustée au démarrage en
	  fonction de la quantité de mémoire disponible
	  dans le système, sa valeur peut être connue
	  durant le fonctionnement du système en examinant la
	  valeur de la variable sysctl en lecture seule:
	  <varname>kern.maxusers</varname>.  Certains systèmes
	  auront besoin de valeurs plus élevées ou plus
	  faibles pour <varname>kern.maxusers</varname> et pourront
	  donc la fixer au chargement du système; des valeurs
	  de 64, 128, ou 256 ne sont pas inhabituelles.  Nous
	  recommandons de ne pas dépasser 256 &agrave; moins
	  que vous ayez besoin d'un grand nombre de descripteurs de
	  fichiers; plusieurs des variables dont la valeur par
	  défaut dépend de
	  <varname>kern.maxusers</varname> peuvent être
	  fixées individuellement au démarrage ou en
	  fonctionnement dans le fichier
	  <filename>/boot/loader.conf</filename> (voir la page de
	  manuel &man.loader.conf.5; ou le fichier
	  <filename>/boot/defaults/loader.conf</filename> pour des
	  exemples) ou comme décrit en d'autres endroits dans
	  ce document.</para>

	<para>Sous les anciennes versions, le système auto-ajuste
	  ce paramètre pour vous si vous le fixez explicitement
	  &agrave; <literal>0</literal><footnote>
	    <para>L'algorithme d'auto-ajustement fixe
	      <literal>maxusers</literal> &agrave; une valeur égale
	      &agrave; la quantité de mémoire présente
	      sur le système, avec un minimum de 32 et un maximum de
	      384..</para></footnote>.
	  En paramétrant cette option, vous
	  devrez fixer <literal>maxusers</literal> &agrave; 4 au
	  moins, en particulier si vous utilisez le système X
	  Window ou compilez des logiciels.  La raison de cela est que
	  la valeur la plus importante que dimensionne
	  <literal>maxusers</literal> est le nombre maximal de
	  processus, qui est fixé &agrave; <literal>20 + 16 *
	  maxusers</literal>, donc si vous positionnez
	  <literal>maxusers</literal> &agrave; 1, alors vous ne pouvez
	  avoir que 36 processus en simultanés, comprenant les
	  18, environ, que le système lance au démarrage
	  et les 15, &agrave; peu près, que vous créerez
	  probablement au démarrage du système X Window.
	  Même une tâche simple comme la lecture d'une
	  page de manuel lancera jusqu'&agrave; neuf processus pour la
	  filtrer, la décompresser, et l'afficher.  Fixer
	  <literal>maxusers</literal> &agrave; 64 autorisera
	  jusqu'&agrave; 1044 processus simultanés, ce qui
	  devrait suffire dans la plupart des cas.  Si, toutefois,
	  vous obtenez le message d'erreur tant redouté
	  <errortype>proc table full</errortype> quand vous tentez
	  d'exécuter un nouveau programme, ou gérez un
	  serveur avec un grand nombre d'utilisateurs en
	  simultanés (comme <systemitem class="fqdomainname">ftp.FreeBSD.org</systemitem>), vous pouvez toujours
	  augmenter cette valeur et recompiler le noyau.</para>

	<note>
	  <para><literal>maxusers</literal> ne limite
	    <emphasis>pas</emphasis> le nombre d'utilisateurs qui
	    pourront ouvrir une session sur votre machine.  Cette
	    valeur dimensionne simplement différentes tables
	    &agrave; des valeurs raisonnables en fonction du nombre
	    maximal d'utilisateur que vous aurez vraisemblablement sur
	    votre système et combien de processus chacun
	    d'entre eux pourra utiliser.</para>
	</note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>kern.ipc.somaxconn</varname>
	  limite la taille de la file d'attente acceptant les
	  nouvelles connexions TCP.  La valeur par défaut de
	  <literal>128</literal> est généralement trop
	  faible pour une gestion robuste des nouvelles connexions
	  dans un environnement de serveur web très
	  chargé.  Pour de tels environnements, il est
	  recommandé d'augmenter cette valeur &agrave;
	  <literal>1024</literal> ou plus.  Le <quote>daemon</quote>
	  en service peut de lui-même limiter la taille de la
	  file d'attente (e.g. &man.sendmail.8;, ou
	  <application>Apache</application>) mais disposera, la
	  plupart du temps, d'une directive dans son fichier de
	  configuration pour ajuster la taille de la file d'attente.
	  Les files d'attentes de grandes tailles sont plus
	  adaptées pour éviter les attaques par
	  déni de service (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>

    <sect2 xml:id="nmbclusters">
      <title>Limitations réseau</title>

      <para>L'literal du noyau <literal>NMBCLUSTERS</literal> fixe la
	quantité de <quote>Mbuf</quote>;s disponibles pour le
	système.  Un serveur &agrave; fort trafic avec un nombre faible
	de <quote>Mbuf</quote>;s sous-emploiera les capacités de FreeBSD.
	Chaque &ldquo;cluster&rdquo; représente approximativement 2&nbsp;Ko
	de mémoire, donc une valeur de 1024 représente 2
	mégaoctets de mémoire noyau réservée
	pour les tampons réseau.  Un simple calcul peut
	être fait pour déterminer combien sont
	nécessaires.  Si vous avez un serveur web qui culmine &agrave;
	1000 connexions simultanées, et que chaque connexion
	consomme un tampon de réception de 16Ko et un tampon
	d'émission de 16&nbsp;Ko, vous avez approximativement besoin
	de 32&nbsp;Mo de tampon réseau pour couvrir les besoin du
	serveur web.  Un bon principe est de multiplier ce nombre
	par 2, soit 2x32&nbsp;Mo / 2&nbsp;Ko = 64&nbsp;Mo / 2&nbsp;Ko =32768.
	Nous recommandons des valeurs comprises entre 4096 et 32768
	pour les machines avec des quantités de mémoire
	plus élevées.  Vous ne devriez, dans aucun
	circonstance, spécifier de valeur élevée
	arbitraire pour ce paramètre étant donné
	que cela peut être &agrave; l'origine d'un plantage au
	démarrage.  L'option <option>-m</option> de
	&man.netstat.1; peut être utilisée pour observer
	l'utilisation des <quote>clusters</quote>.</para>

      <para>La variable <varname>kern.ipc.nmbclusters</varname>
	configurable au niveau du chargeur est utilisée pour
	ajuster cela au démarrage.  Seules les anciennes
	versions de &os; vous demanderont d'utiliser l'option de
	configuration du noyau <literal>NMBCLUSTERS</literal>.</para>

      <para>Pour les serveurs chargés qui font une utilisation
	intensive de l'appel système &man.sendfile.2;, il peut
	être nécessaire d'augmenter le nombre de tampons
	&man.sendfile.2; par l'intermédiaire de l'option de
	configuration du noyau <literal>NSFBUFS</literal> ou en fixant
	sa valeur dans le fichier
	<filename>/boot/loader.conf</filename> (consultez la page de
	manuel &man.loader.8; pour plus de détails).  Un
	indicateur de la nécessité d'ajuster ce
	paramètre est lorsque des processus sont dans
	l'état <literal>sfbufa</literal>.  La variable sysctl
	<varname>kern.ipc.nsfbufs</varname> est un aperçu en
	lecture seule de la variable du noyau.  Ce paramètre
	s'ajuste de façon optimale avec
	<varname>kern.maxusers</varname>, il peut être cependant
	nécessaire de l'ajuster en fonction des besoins.</para>

      <important>
	<para>Même si une <quote>socket</quote> a
	  été marquée comme étant
	  non-bloquante, un appel de &man.sendfile.2; sur la
	  <quote>socket</quote> non-bloquante peut résulter en un
	  blocage de l'appel &man.sendfile.2; jusqu'&agrave; ce que
	  suffisamment de <literal>struct sf_buf</literal> soient
	  libérées.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>Les variables <varname>net.inet.ip.portrange.*</varname>
	  contrôlent les intervalles de ports automatiquement
	  alloués aux <quote>socket</quote>s TCP et UDP.  Il y
	  a trois intervalles: un intervalle bas, un intervalle par
	  défaut, et intervalle un haut.  La plupart des
	  programmes réseau utilisent l'intervalle par
	  défaut qui est contrôlé par
	  <varname>net.inet.ip.portrange.first</varname> et
	  <varname>net.inet.ip.portrange.last</varname>, qui ont pour
	  valeur par défaut respectivement 1024 et 5000.  Ces
	  intervalles de ports sont utilisés pour les
	  connexions sortantes, et il est possible de se trouver
	  &agrave; court de ports dans certaines conditions.  Cela
	  arrive le plus souvent quand votre système fait
	  tourner un proxy web très chargé.
	  L'intervalle de ports n'est pas un problème quand
	  vous exécutez des serveurs qui ne gèrent
	  principalement que des connexions entrantes, comme un server
	  web classique, ou qui ont un nombre de connexions sortantes
	  limitées comme un relai de messagerie.  Pour les cas
	  où vous risquez d'être &agrave; court de ports,
	  il est recommandé d'augmenter
	  légèrement
	  <varname>net.inet.ip.portrange.last</varname>.  Une valeur
	  de <literal>10000</literal>, <literal>20000</literal> ou
	  <literal>30000</literal> doit être suffisante.  Vous
	  devriez également penser au problème du
	  coupe-feu lors du changement de l'intervalle des ports.
	  Certains coupes-feu peuvent bloquer de grands intervalles de
	  ports (en général les ports inférieurs)
	  et s'attendent &agrave; ce que les systèmes utilisent
	  les intervalles supérieurs pour les connexions
	  sortantes &mdash; pour cette raison il n'est pas conseillé
	  de diminuer
	  <varname>net.inet.ip.portrange.first</varname>.</para>
      </sect3>

      <sect3>
	<title>Le produit délai-bande passante TCP</title>

	<indexterm>
	  <primary>limitation du produit délai-bande passante
	    TCP</primary>
	  <secondary><varname>net.inet.tcp.inflight.enable</varname></secondary>
	</indexterm>

	<para>La limitation du produit délai-bande passante TCP
	  est semblable au TCP/Vegas sous NetBSD.  Elle peut
	  être activée en positionnant &agrave;
	  <literal>1</literal> la variable
	  <varname>net.inet.tcp.inflight.enable</varname>.  Le
	  système tentera alors de calculer le produit
	  délai-bande passante pour chaque connexion et
	  limitera la quantité de données en attente
	  &agrave; la quantité juste nécessaire au
	  maintient d'un flux de sortie optimal.</para>

	<para>Cette fonctionnalité est utile si vous diffusez
	  des données par l'intermédiaire de modems, de
	  connexions Ethernet Gigabit, ou même de liaisons hauts
	  débits WAN (ou toute autre liaison avec un produit
	  délai-bande passante élevé), tout
	  particulièrement si vous utilisez également le
	  dimensionnement des fenêtres d'émission ou que
	  vous avez configuré une fenêtre
	  d'émission importante.  Si vous activez cette option,
	  vous devriez également vous assurer que
	  <varname>net.inet.tcp.inflight.debug</varname> est
	  positionnée &agrave; <literal>0</literal>
	  (désactive le débogage), et pour une
	  utilisation en production, fixer
	  <varname>net.inet.tcp.inflight.min</varname> &agrave; au
	  moins <literal>6144</literal> peut être
	  bénéfique.  Notez, cependant,  que fixer des
	  minima élevés peut désactiver la
	  limitation de bande passante selon la liaison.  La fonction
	  de limitation diminue la quantité de données
	  accumulées dans les files d'attente
	  intermédiaire de routage et de commutation, et
	  diminue également la quantité de
	  données présentes dans les files d'attente de
	  l'interface de la machine locale.  Avec moins de paquets
	  dans les files d'attente, les connexions interactives, tout
	  particulièrement sur des modems lents, seront en
	  mesure de fonctionner avec des <emphasis>temps
	  d'aller-retour</emphasis> plus faible.  Mais cette
	  fonctionnalité n'affecte que la transmission de
	  données (transmission côté serveur).
	  Ceci n'a aucun effet sur la réception de
	  données (téléchargement).
	</para>

	<para>Modifier <varname>net.inet.tcp.inflight.stab</varname>
	  n'est <emphasis>pas</emphasis> recommandé.  Ce
	  paramètre est fixé par défaut &agrave;
	  la valeur 20, représentant au maximum 2 paquets
	  ajoutés &agrave; la fenêtre de calcul du
	  produit délai-bande passante.  La fenêtre
	  supplémentaire est nécessaire pour stabiliser
	  l'algorithme et améliorer la réponse aux
	  changements de conditions, mais il peut en résulter
	  des temps de <quote>ping</quote> plus élevés
	  sur les liaisons lentes (mais cependant inférieurs
	  &agrave; ce que vous obtiendriez sans l'algorithme de
	  limitation).  Dans de tels cas, vous pouvez essayer de
	  réduire ce paramètre &agrave; 15, 10, ou 5, et
	  vous pouvez avoir &agrave; réduire le
	  paramètre
	  <varname>net.inet.tcp.inflight.min</varname> (par exemple
	  &agrave; 3500) pour obtenir l'effet désiré.
	  Ces paramètres ne doivent être réduits
	  qu'en dernier ressort.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Mémoire virtuelle</title>

      <sect3>
        <title><varname>kern.maxvnodes</varname></title>

	<para>Un vnode est la représentation interne d'un
	  fichier ou d'un répertoire.  Augmenter le nombre de
	  vnodes disponibles pour le système d'exploitation
	  diminue les accès disque.  Cela est normalement
	  géré par le système d'exploitation et
	  n'a pas besoin d'être modifié.  Dans certains
	  cas où les accès aux disques sont un goulot
	  d'étranglement pour le système et que ce
	  dernier est &agrave; cours de vnodes, ce nombre aura besoin
	  d'être augmenté.  La quantité de RAM
	  libre et inactive sera prise en compte.</para>

        <para>Pour connaître le nombre de vnodes actuellement
	  utilisés:</para>

        <screen>&prompt.root; <userinput>sysctl vfs.numvnodes</userinput>
vfs.numvnodes: 91349</screen>

	<para>Pour connaître le maximum de vnodes utilisables:</para>

        <screen>&prompt.root; <userinput>sysctl kern.maxvnodes</userinput>
kern.maxvnodes: 100000</screen>

	<para>Si l'utilisation actuelle des vnodes est proche du
	  maximum, augmenter de 1000 <varname>kern.maxvnodes</varname>
	  est probablement une bonne idée.  Gardez un oeil sur
	  le nombre <varname>vfs.numvnodes</varname>.  S'il approche
	  &agrave; nouveau le maximum,
	  <varname>kern.maxvnodes</varname> devra être
	  augmenté de manière plus conséquente.
	  Une modification dans votre utilisation de la mémoire
	  devrait être visible dans &man.top.1;.  Une plus
	  grande quantité de mémoire devrait être
	  annoncée comme active.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="adding-swap-space">
    <title>Ajouter de l'espace de pagination</title>

    <para>Peu importe comment vous l'avez pensé, parfois un
      système ne fonctionne pas comme prévu.  Si vous
      trouvez que vous avez besoin de plus d'espace de pagination, il
      est assez simple d'en rajouter.  Vous avez trois manières
      d'augmenter votre espace de pagination: ajouter un nouveau
      disque dur, activer la pagination sur NFS, et créer un fichier
      de pagination sur une partition existante.</para>

    <para>Pour des informations sur comment chiffrer l'espace de
      pagination, quelles options existent pour mener &agrave; bien
      cette tâche et pourquoi on devrait le faire, veuillez vous
      référer &agrave; la <xref linkend="swap-encrypting"/>
      du Manuel.</para>

    <sect2 xml:id="new-drive-swap">
      <title>Espace de pagination sur un nouveau disque dur ou une
	partition existante</title>

      <para>Ajouter un nouveau disque pour l'espace de pagination
	donne de meilleures performances qu'utiliser une partition sur
	un disque existant.  La configuration des partitions et des
	disques durs est expliquée dans la <xref
	linkend="disks-adding"/> tandis que la <xref
	linkend="configtuning-initial"/> aborde l'organisation des
	partitions et les problèmes relatifs à la taille de la
	partition de l'espace de pagination.</para>

      <para>Utiliser la commande <command>swapon</command> pour
	ajouter une partition de pagination au système.  Par
	exemple:</para>

      <screen>&prompt.root; <userinput>swapon <replaceable>/dev/ada1s1b</replaceable></userinput></screen>

      <warning>
	<para>Il est possible d'utiliser n'importe quelle partition
	  actuellement non-montée, même si cette dernière contient des
	  données.  Utiliser <command>swapon</command> sur une
	  partition contenant des données écrasera et effacera ces
	  données.  Assurez-vous que la partition à utiliser comme
	  espace de pagination est bien celle prévue à cet effet avant
	  d'exécuter <command>swapon</command>.</para>
      </warning>

      <para>Pour ajouter cette partition de pagination automatiquement
	au démarrage, ajouter une entrée au fichier
	<filename>/etc/fstab</filename>:</para>

      <programlisting><replaceable>/dev/ada1s1b</replaceable>	none	swap	sw	0	0</programlisting>

      <para>Consulter &man.fstab.5; pour plus d'explications sur les
	entrées du fichier <filename>/etc/fstab</filename>.  Plus
	d'informations sur <command>swapon</command> sont disponibles
	dans &man.swapon.8;.</para>
    </sect2>

    <sect2 xml:id="nfs-swap">
      <title>Espace de pagination sur NFS</title>

      <para>L'espace de pagination sur NFS n'est recommandé que si
	vous n'avez pas de disque dur local sur lequel avoir l'espace
	de pagination; la pagination sur NFS sera limitée
	par la bande passante du réseau et sera un fardeau
	supplémentaire pour le serveur NFS.</para>
    </sect2>

    <sect2 xml:id="create-swapfile">
      <title>Fichiers de pagination</title>

      <para>Vous pouvez créer un fichier d'une taille
	spécifique pour	l'utiliser comme fichier de pagination.
	Dans notre exemple nous utiliserons un fichier de 64MO appelé
	<filename>/usr/swap0</filename>.  Vous pouvez, bien sûr,
	utiliser le nom de votre choix.</para>

      <example>
	<title>Créer un fichier de pagination sous &os;</title>

      <orderedlist>
	<listitem>
	  <para>Le noyau <filename>GENERIC</filename> inclut déjà
	    le pilote de disque mémoire (&man.md.4;) nécessaire à
	    cette opération.  Lors de la compilation d'un noyau sur
	    mesures, assurez-vous d'inclure la ligne suivante dans le
	    fichier de configuration:</para>

	  <programlisting>device   md</programlisting>

	  <para>Pour plus d'information sur la compilation du noyau,
	    veuillez vous réferer à la <xref
	    linkend="kernelconfig"/>.</para>
	</listitem>

	<listitem>
	  <para>Créez un fichier de pagination
	    (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Fixez les bonnes permissions sur
	    <filename>/usr/swap0</filename>:</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Activez le fichier de pagination dans
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

	  <para>Redémarrez la machine ou activez directement le
	    fichier de pagination:</para>

	  <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="acpi-overview">
    <info><title>Gestion de l'énergie et des ressources</title>
      <authorgroup>
	<author><personname><firstname>Hiten</firstname><surname>Pandya</surname></personname><contrib>Ecrit par </contrib></author>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname></author>
      </authorgroup>
    </info>

    

    <para>Il est important d'utiliser les ressources
      matérielles d'une manière efficace.  Avant
      l'apparition de l'<acronym>ACPI</acronym>, il était
      difficile pour les systèmes d'exploitation de
      gérer l'utilisation de l'alimentation et la température
      d'un système.  Le matériel était
      géré par le <acronym>BIOS</acronym> et donc
      l'utilisateur avait moins de contrôle et de
      visibilité sur le paramétrage de la gestion de
      l'énergie.  Une configuration limitée était
      accessible via
      l'<emphasis>Advanced Power Management (APM)</emphasis>.
      La gestion de l'énergie et des ressources est un
      des éléments clés d'un système
      d'exploitation moderne.  Par exemple, vous pourrez vouloir qu'un
      système d'exploitation surveille certaines limites (et
      éventuellement vous alerte), au cas où la
      température de votre système augmente de façon
      inattendue.</para>

    <para>Dans cette section,  nous fournirons une information
      complète au sujet de l'<acronym>ACPI</acronym>.  Il sera
      fait référence &agrave; des documents
      supplémentaires en fin de section pour plus de
      détails.</para>

    <sect2 xml:id="acpi-intro">
      <title>Qu'est-ce que l'ACPI?</title>

      <indexterm>
	<primary>ACPI</primary>
      </indexterm>

      <indexterm>
	<primary>APM</primary>
      </indexterm>

      <para>L'<quote>interface de configuration et d'alimentation
	avancée</quote> (<acronym>ACPI</acronym>, Advanced
	Configuration and Power Interface) est une norme créée
	par un ensemble de constructeurs pour fournir une interface
	standard &agrave; la gestion des ressources et de l'énergie.
	C'est un élément clé dans le contrôle
	et la configuration par le système d'exploitation de
	de la gestion d'énergie, i.e., il permet plus de contrôle
	et flexibilité au système d'exploitation.  Les
	systèmes modernes ont &ldquo;repoussé&rdquo; les limites
	des interfaces &ldquo;Plug and Play&rdquo; antérieures
	&agrave;
	l'apparition de l'<acronym>ACPI</acronym>.
	L'<acronym>ACPI</acronym> est le descendant direct de
	l'<acronym>APM</acronym> (Advanced Power Management - gestion
	avancée de l'énergie).</para>
    </sect2>

    <sect2 xml:id="acpi-old-spec">
      <title>Les imperfections de la gestion avancée de
	l'énergie (APM)</title>

      <para>Le système de <emphasis>gestion avancée de
	l'énergie (APM)</emphasis> gère l'utilisation de
	l'énergie par un système en fonction de son
	activité.  Le BIOS APM est fourni par le fabricant (du
	système) et est spécifique &agrave; la plateforme
	matérielle.  Un pilote APM au niveau du système
	d'exploitation gère l'accès &agrave;
	l'<emphasis>interface logicielle APM</emphasis> qui autorise la
	gestion des niveaux de consommation.  L'APM devrait être
	toujours utilisé pour les systèmes
	fabriqués en ou avant 2000.</para>

      <para>L'APM présente quatre problèmes majeurs.  Tout
	d'abord la gestion de l'énergie est effectuée par le
	BIOS (spécifique au constructeur), et le système
	d'exploitation n'en a aucune connaissance.  Un exemple de ce
	problème, est lorsque l'utilisateur fixe des valeurs pour
	le temps d'inactivité d'un disque dur dans le BIOS APM, qui
	une fois dépassé, provoque l'arrêt du disque
	(par le BIOS) sans le consentement du système
	d'exploitation.  Deuxièmement, la logique de l'APM est
	interne au BIOS, et agit indépendamment du système
	d'exploitation.  Cela signifie que les utilisateurs ne peuvent
	corriger les problèmes de leur BIOS APM qu'en flashant un
	nouveau BIOS; c'est une opération dangereuse, qui si elle
	échoue peut laisser le système dans un état
	irrécupérable.  Troisièmement, l'APM est une
	technologie spécifique au constructeur, ce qui veut dire
	qu'il y a beaucoup de redondances (duplication des efforts) et de
	bogues qui peuvent être trouvées dans le BIOS d'un
	constructeur, et qui peuvent ne pas être corrigées
	dans d'autres BIOS.  Et pour terminer, le dernier problème
	est le fait que le BIOS APM n'a pas suffisamment d'espace pour
	implémenter une politique sophistiquée de gestion de
	l'énergie, ou une politique qui peut s'adapter parfaitement
	aux besoins de la machine.</para>

      <para>Le <emphasis>BIOS Plug and Play (PNPBIOS)</emphasis>
	n'était pas fiable dans de nombreuses situations.  Le
	PNPBIOS est une technologie 16 bits, le système
	d'exploitation doit utiliser une émulation 16 bits afin de
	faire l'<quote>interface</quote> avec les méthodes
	PNPBIOS.</para>

      <para>Le pilote <acronym>APM</acronym> &os; est documenté
	dans la page de manuel &man.apm.4;.</para>
    </sect2>

    <sect2 xml:id="acpi-config">
      <title>Configurer l'<acronym>ACPI</acronym></title>

      <para>Le pilote <filename>acpi.ko</filename> est par défaut
	chargé par le &man.loader.8; au démarrage et ne devrait
	<emphasis>pas</emphasis> être compilé dans
	le noyau.  La raison derrière cela est que les modules
	sont plus facile &agrave; manipuler, par exemple pour passer &agrave;
	une autre version du module <filename>acpi.ko</filename> sans
	avoir &agrave; recompiler le noyau.  Cela présente l'avantage
	de rendre les tests aisés.  Une autre raison est que lancer
	l'<acronym>ACPI</acronym> après qu'un système ait
	terminé son lancement donne souvent lieu &agrave; des
	dysfonctionnements.  Si des problèmes surviennent, vous pouvez
	désactiver l'<acronym>ACPI</acronym>.  Ce pilote ne devrait
	et ne peut être déchargé car le bus
	système l'utilise pour différentes
	intéraction avec le matériel.
	L'<acronym>ACPI</acronym> peut être déactivé
	en ajoutant <literal>hint.acpi.0.disabled="1"</literal> dans
	le fichier <filename>/boot/loader.conf</filename> ou
	directement &agrave; l'invite du chargeur (&man.loader.8;).</para>

      <note>
	<para>L'<acronym>ACPI</acronym> et l'<acronym>APM</acronym>
	  ne peuvent coexister et devraient être utilisé
	  séparément.  Le dernier chargé
	  s'arrêtera s'il détecte l'autre en
	  fonctionnement.</para>
      </note>

      <para>L'<acronym>ACPI</acronym> peut
	être utilisé pour mettre en veille un système avec
	&man.acpiconf.8;, les options <option>-s</option> et
	<literal>1-5</literal>.  La plupart des utilisateurs n'auront
	besoin que de <literal>1</literal> ou <literal>3</literal>
	(système suspendu en RAM).  L'option
	<literal>5</literal> provoquera un arrêt de l'alimentation
	par logiciel, effet identique &agrave; un:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>D'autres options sont disponibles via &man.sysctl.8;.
	Consultez les pages de manuel &man.acpi.4; et &man.acpiconf.8;
	pour plus d'informations.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ACPI-debug">
    <info><title>Utiliser et déboguer l'<acronym>ACPI</acronym>
      sous &os;</title>
      <authorgroup>
	<author><personname><firstname>Nate</firstname><surname>Lawson</surname></personname><contrib>Ecrit par </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Peter</firstname><surname>Schultz</surname></personname><contrib>Avec la collaboration de </contrib></author>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>ACPI</primary>
      <secondary>problèmes</secondary>
    </indexterm>

    <para>L'<acronym>ACPI</acronym> est une nouvelle méthode de
      recherche des périphériques, de gestion de
      l'énergie, et fourni un accès standardisé
      &agrave; différents matériels gérés
      auparavant par le <acronym>BIOS</acronym>.  Des progrès ont
      été fait vers un fonctionnement de
      l'<acronym>ACPI</acronym> sur tous les systèmes, mais des
      bogues dans le <quote>bytecode</quote> du <firstterm>langage machine
      <acronym>ACPI</acronym></firstterm>
      (<firstterm><acronym>ACPI</acronym> Machine
      Language</firstterm>&mdash;<acronym>AML</acronym>), des
      imperfections dans les sous-systèmes du noyau &os;, et des
      bogues dans l'interpréteur <acronym>ACPI-CA</acronym>
      d'&intel; continuent d'apparaître.</para>

    <para>Ce document est destiné &agrave; vous permettre d'aider
      les développeurs du système <acronym>ACPI</acronym>
      sous &os; &agrave; identifier la cause originelle des
      problèmes que vous observez et &agrave; déboguer et
      développer une solution.  Merci de lire ce document et nous
      espérons pouvoir résoudre les problèmes de
      votre système.</para>

    <sect2 xml:id="ACPI-submitdebug">
      <title>Soumettre des informations de débogage</title>

      <note>
	<para>Avant de soumettre un problème, assurez-vous
	  d'utiliser la dernière version de votre
	  <acronym>BIOS</acronym>, et si elle est disponible, la
	  dernière version du firmware du contrôleur
	  utilisé.</para>
      </note>

      <para>Pour ceux désirant soumettre directement un
	problème, veuillez faire parvenir les informations
	suivantes &agrave; la liste <link xlink:href="mailto:freebsd-acpi@FreeBSD.org">freebsd-acpi@FreeBSD.org</link>:</para>

      <itemizedlist>
	<listitem>
	  <para>Description du comportement défectueux, en
	    ajoutant le type et le modèle du système et tout
	    ce qui peut causer l'apparition du bogue.  Notez
	    également le plus précisément possible
	    quand le bogue a commencé &agrave; se manifester s'il
	    est nouveau.</para>
	</listitem>

	<listitem>
	  <para>La sortie de &man.dmesg.8; après un <command>boot
	    -v</command>, y compris tout message
	    généré lors de la manifestation du
	    bogue.</para>
	</listitem>

	<listitem>
	  <para>La sortie de &man.dmesg.8; après un <command>boot
	    -v</command> avec
	    l'<acronym>ACPI</acronym> désactivé, si cette
	    désactivation corrige le problème.</para>
	</listitem>

	<listitem>
	  <para>La sortie de <command>sysctl hw.acpi</command>.  C'est
	    également un bon moyen de déterminer quelles
	    fonctionnalités sont offertes par votre
	    système.</para>
	</listitem>

	<listitem>
	  <para>Une <acronym>URL</acronym> où peut être
	    trouvé votre <firstterm>code source
	    <acronym>ACPI</acronym></firstterm> (<acronym>ACPI</acronym>
	    Source Language&mdash;<acronym>ASL</acronym>).  N'envoyez pas
	    directement l'<acronym>ASL</acronym> sur la liste de
	    diffusion, ce fichier peut être très gros.  Vous
	    pouvez générer une copie de votre
	    <acronym>ASL</acronym> en exécutant la commande
	    suivante:</para>

	  <screen>&prompt.root; <userinput>acpidump -dt &gt; name-system.asl</userinput></screen>

	  <para>(Remplacez <replaceable>name</replaceable> par votre
	    nom d'utilisateur et <replaceable>system</replaceable> par
	    celui du constructeur/modèle.  Par exemple:
	    <filename>njl-FooCo6000.asl</filename>)</para>
	</listitem>
      </itemizedlist>

      <para>La plupart des développeurs lisent la liste
	&a.current; mais soumettez également les problèmes
	rencontrés &agrave; la liste &a.acpi.name; afin
	d'être sûr qu'ils seront vus.  Soyez patient, nous
	avons tous un travail &agrave; plein temps qui nous attend
	ailleurs.  Si votre bogue n'est pas immédiatement apparent,
	nous vous demanderons probablement de soumettre un
	<acronym>PR</acronym> par l'intermédiaire de
	&man.send-pr.1;.  Quand vous remplirez un <acronym>PR</acronym>,
	veillez &agrave; inclure les mêmes informations que celles
	précisées précédemment.  Cela nous aidera
	&agrave; cerner et &agrave; résoudre le problème.
	N'envoyez pas de <acronym>PR</acronym> sans avoir contacté
	auparavant la liste &a.acpi.name; étant donné que
	nous utilisons les <acronym>PR</acronym>s comme pense-bêtes
	de problèmes existants, et non pas comme mécanisme
	de rapport.  Il se peut que votre problème puisse avoir
	déj&agrave; été signalé par quelqu'un
	d'autre.</para>
    </sect2>

    <sect2 xml:id="ACPI-background">
      <title>Information de fond</title>

      <indexterm>
	<primary>ACPI</primary>
      </indexterm>

      <para>L'<acronym>ACPI</acronym> est présent sur tous les
	ordinateurs modernes compatibles avec l'une des architectures ia32
	(x86), ia64 (Itanium), et amd64 (AMD).  La norme complète
	définit des fonctionnalités comme la gestion des
	performances du <acronym>CPU</acronym>, des contrôles des
	niveaux d'énergie, des zones de températures, divers
	systèmes d'utilisation des batteries, des contrôleurs
	intégrés, et l'énumération du bus.  La
	plupart des systèmes n'implémentent pas
	l'intégralité des fonctionnalités de la
	norme.  Par exemple, un ordinateur de bureau n'implémentera
	généralement que la partie énumération
	de bus alors qu'un ordinateur portable aura également le
	support de la gestion du refroidissement et de la batterie.  Les
	ordinateurs portables disposent également des modes de mise
	en veille et de réveil, avec toute la complexité qui
	en découle.</para>

      <para>Un système compatible <acronym>ACPI</acronym> dispose
	de divers composants.  Les fabricants de <acronym>BIOS</acronym>
	et de circuits fournissent des tables de description
	(<acronym>FADT</acronym>) fixes en mémoire qui
	définissent des choses comme la table
	<acronym>APIC</acronym> (utilisée par les systèmes
	<acronym>SMP</acronym>), les registres de configuration, et des
	valeurs de configuration simples.  De plus, est fournie une table
	de <quote>bytecode</quote> (la <firstterm>table
	différenciée de description du
	système</firstterm>&mdash;<firstterm>Differentiated System
	Description Table</firstterm> <acronym>DSDT</acronym>) qui
	spécifie sous forme d'une arborescence l'espace des noms
	des périphériques et des méthodes.</para>

      <para>Le pilote <acronym>ACPI</acronym> doit analyser les
	tables, implémenter un interpréteur pour le
	<quote>bytecode</quote>, et modifier les pilotes de
	périphériques et le noyau pour qu'ils
	acceptent des informations en provenance du
	sous-système <acronym>ACPI</acronym>.  Pour &os;, &intel;
	fourni un interpréteur (<acronym>ACPI-CA</acronym>) qui
	est partagé avec Linux et NetBSD.  L'emplacement du code
	source de l'interpréteur <acronym>ACPI-CA</acronym> est
	<filename>src/sys/contrib/dev/acpica</filename>.  Le code
	<quote>glu</quote> permettant &agrave;
	<acronym>ACPI-CA</acronym> de fonctionner sous &os; se trouve
	dans <filename class="directory">src/sys/dev/acpica/Osd</filename>.  Et enfin, les
	pilotes qui gèrent les différents
	périphériques <acronym>ACPI</acronym> se trouvent
	dans <filename>src/sys/dev/acpica</filename>.</para>
    </sect2>

    <sect2 xml:id="ACPI-comprob">
      <title>Problèmes courants</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>problèmes</secondary>
      </indexterm>

      <para>Pour un fonctionnement correct de
	l'<acronym>ACPI</acronym>, il faut que toutes les parties
	fonctionnent correctement.  Voici quelques problèmes
	courants, par ordre de fréquence d'apparition, et
	quelques contournements ou corrections possibles.</para>

      <sect3>
	<title>Problèmes avec la souris</title>

	<para>Dans certains cas le réveil après une mise
	  en veille sera &agrave; l'origine d'un dysfonctionnement de
	  la souris.  Une solution connue est d'ajouter la ligne
	  <literal>hint.psm.0.flags="0x3000"</literal> au fichier
	  <filename>/boot/loader.conf</filename>.  Si cela ne
	  fonctionne pas, pensez &agrave; envoyer un rapport de bogue
	  comme décrit plus haut.</para>
      </sect3>

      <sect3>
	<title>Mise en veille/réveil</title>

	<para>L'<acronym>ACPI</acronym> dispose de trois modes
	  de mise en veille en <acronym>RAM</acronym>
	  (<acronym>STR</acronym>&mdash;Suspend To RAM),
	  <literal>S1</literal> &agrave; <literal>S3</literal>, et un
	  mode de mise en veille vers le disque dur
	  (<literal>STD</literal>&mdash;Suspend To Disk), appelé
	  <literal>S4</literal>.  Le mode <literal>S5</literal> est un
	  arrêt <quote>soft</quote> et est le mode dans lequel se
	  trouve votre système quand il est branché mais
	  pas allumé.  Le mode <literal>S4</literal> peut
	  être implémenté de deux manières
	  différentes.  Le mode
	  <literal>S4</literal><acronym>BIOS</acronym> est une mise en
	  veille vers le disque assistée par le
	  <acronym>BIOS</acronym>.  Le mode
	  <literal>S4</literal><acronym>OS</acronym> est
	  implémenté intégralement par le
	  système d'exploitation.</para>

	<para>Commencez par examiner la sortie de
	  <command>sysctl hw.acpi</command> &agrave; la recherche
	  d'éléments concernant les modes de mise en
	  veille.  Voici les résultats pour un Thinkpad:</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</screen>

	<para>Cela signifie que nous pouvons utiliser
	  <command>acpiconf -s</command> pour tester les modes
	  <literal>S3</literal>,
	  <literal>S4</literal><acronym>OS</acronym>, et
	  <literal>S5</literal>.  Si <option>s4bios</option>
	  était égal &agrave; <literal>1</literal>, nous
	  disposerions d'un support
	  <literal>S4</literal><acronym>BIOS</acronym> &agrave; la place
	  de <literal>S4</literal><acronym>OS</acronym>.</para>

	<para>Quand vous testez la mise en veille et le réveil,
	  commencez avec le mode <literal>S1</literal>, pour voir s'il
	  est supporté.  Ce mode doit fonctionner dans la plupart
	  des cas puisqu'il nécessite peu de support.  Le mode
	  <literal>S2</literal> n'est pas implémenté, mais
	  si vous en disposez, il est similaire au mode
	  <literal>S1</literal>.  La chose suivante &agrave; essayer est
	  le mode <literal>S3</literal>.  C'est le mode
	  <acronym>STR</acronym> le plus avancé et il
	  nécessite un support du pilote important pour
	  réinitialiser correctement votre matériel.  Si
	  vous avez des problèmes au réveil de la machine,
	  n'hésitez pas &agrave; contacter la liste &a.acpi.name;
	  mais ne vous attendez pas &agrave; ce que le problème
	  soit résolu puisqu'il y a de nombreux
	  pilotes/matériels qui nécessitent plus de tests
	  et de développement.</para>

	<para>Un problème courant avec la mise en veille/le réveil est
	  que de nombreux pilotes de périphériques ne sauvegardent
	  pas, ne restaurent pas, ou ne réinitialisent pas leurs logiciel,
	  registres ou mémoire proprement.  En premier lieu pour
	  débogguer le problème, essayez:</para>

	<screen>&prompt.root; <userinput>sysctl debug.bootverbose=1</userinput>
&prompt.root; <userinput>sysctl debug.acpi.suspend_bounce=1</userinput>
&prompt.root; <userinput>acpiconf -s 3</userinput></screen>

	<para>Ce test émule le cycle de mise en veille/réveil de tous
	  les pilotes de périphériques sans réellement passer dans
	  l'état <literal>S3</literal>.  Dans certains cas, les
	  problèmes comme la perte de l'état du périphérique, le
	  dépassement du délai du chien de garde du périphérique, les
	  tentatives répétées, peuvent être capturés avec cette
	  méthode.  Notez que le système n'entrera pas vraiment dans
	  l'état <literal>S3</literal>, ce qui signifie que les
	  périphériques peuvent ne pas perdre leur alimentation, et
	  nombreux fonctionneront correctement même si les méthodes de
	  mise en veille/réveil sont totalement absentes,
	  contrairement au cas d'un véritable état
	  <literal>S3</literal>.</para>

	<para>Les cas plus difficiles nécessitent un matériel
	  supplémentaire, tel qu'un port série et un câble pour
	  débogguer à l'aide d'une console série, un port firewire et
	  un câble pour l'utilisation de &man.dcons.4;, et des
	  compétences en debogguage du noyau.</para>

	<para>Pour isoler le problème, retirez du noyau tous les
	  pilotes de périphériques possibles.  Si cela
	  fonctionne, vous pouvez alors identifier le pilote fautif en
	  chargeant les pilotes un &agrave; un jusqu'&agrave;
	  l'apparition du problème.  Généralement
	  les pilotes binaires comme <filename>nvidia.ko</filename>, les
	  pilotes d'affichage X11, ou les pilotes USB seront victimes de
	  la plupart des problèmes tandis que ceux concernant les
	  interfaces Ethernet fonctionneront normalement.  Si vous
	  pouvez charger/décharger les pilotes de
	  périphériques correctement, vous pouvez
	  automatiser cela en ajoutant les commandes appropriées
	  dans les fichiers <filename>/etc/rc.suspend</filename> et
	  <filename>/etc/rc.resume</filename>.  Il y a un exemple en
	  commentaire pour décharger ou charger un pilote.
	  Essayez de fixer <option>hw.acpi.reset_video</option> &agrave;
	  zéro (<literal>0</literal>) si votre affichage est
	  corrompu après un réveil de la machine.  Essayez
	  des valeurs plus grandes ou plus faibles pour
	  <option>hw.acpi.sleep_delay</option> pour voir si cela
	  aide.</para>

	<para>Une autre méthode est d'essayer de charger une
	  distribution Linux récente avec le support
	  <acronym>ACPI</acronym> et tester la mise en veille et le
	  réveil sur le même matériel.  Si cela
	  fonctionne sous Linux, c'est probablement donc un
	  problème de pilotes &os; et déterminer quel
	  pilote est responsable des dysfonctionnements nous aidera
	  &agrave; corriger le problème.  Notez que les personnes
	  qui maintiennent l'<acronym>ACPI</acronym> sous &os; ne
	  s'occupe pas généralement des autres pilotes de
	  périphériques (comme le son, le système
	  <acronym>ATA</acronym>, etc.), aussi tout rapport concernant
	  un problème de pilote devrait probablement en fin de
	  compte être posté sur la liste &a.current.name;
	  et communiqué au responsable du pilote.  Si vous vous
	  sentez une âme d'aventurier, commencez &agrave; ajouter
	  des &man.printf.3;s de débogage dans un pilote
	  problématique pour déterminer &agrave; quel
	  moment dans sa fonction de réveil il se bloque.</para>

	<para>Enfin, essayez de désactiver
	  l'<acronym>ACPI</acronym> et d'activer l'<acronym>APM</acronym>
	  &agrave; la place, pour voir si la mise en veille et le
	  réveil fonctionnent avec l'<acronym>APM</acronym>, tout
	  particulièrement dans le cas de matériel ancien
	  (antérieur &agrave; 2000).  Cela prend du temps aux
	  constructeurs de mettre en place le support
	  <acronym>ACPI</acronym> et le matériel ancien aura
	  sûrement des problèmes de <acronym>BIOS</acronym>
	  avec l'<acronym>ACPI</acronym>.</para>
      </sect3>

      <sect3>
	<title>Blocages du système (temporaires ou permanents)</title>

	<para>La plupart des blocages système sont le
	  résultat d'une perte d'interruptions ou d'une
	  tempête d'interruptions.  Les circuits ont beaucoup de
	  problèmes en fonction de la manière dont le
	  <acronym>BIOS</acronym> configure les interruptions avant le
	  démarrage, l'exactitude de la table
	  <acronym>APIC</acronym> (<acronym>MADT</acronym>), et le routage
	  du <firstterm>System Control Interrupt</firstterm>
	  (<acronym>SCI</acronym>).</para>

	<indexterm>
	  <primary>tempêtes d'interruptions</primary>
	</indexterm>

	<para>Les tempêtes d'interruptions peuvent être
	  distinguées des pertes d'interruptions en
	  contrôlant la sortie de la commande <command>vmstat
	  -i</command> en examinant la ligne mentionnant
	  <literal>acpi0</literal>.  Si le compteur s'incrémente
	  plusieurs fois par seconde, vous êtes victime d'une
	  tempête d'interruptions.  Si le système semble
	  bloqué, essayez de basculer sous <acronym>DDB</acronym>
	  (<keycombo action="simul"><keycap>CTRL</keycap>
	  <keycap>ALT</keycap><keycap>ESC</keycap></keycombo> sous la
	  console) et tapez <literal>show interrupts</literal>.</para>

	<indexterm>
	  <primary>APIC</primary>
	  <secondary>désactivation</secondary>
	</indexterm>

	<para>Votre plus grand espoir quand vous faites face &agrave;
	  des problèmes d'interruptions est d'essayer de
	  désactiver le support <acronym>APIC</acronym> avec la
	  ligne <literal>hint.apic.0.disabled="1"</literal> dans le
	  fichier <filename>loader.conf</filename>.</para>
      </sect3>

      <sect3>
	<title>Paniques</title>

	<para>Les paniques sont relativement rares dans le cas de
	  l'<acronym>ACPI</acronym> et sont au sommet des
	  priorités en matière de problèmes
	  &agrave; corriger.  Le premier point est d'isoler les
	  étapes nécessaires &agrave; la reproduction de
	  la panique (si possible) et d'obtenir une trace de
	  débogage.  Suivez l'aide sur l'activation de
	  <literal>options DDB</literal> et la configuration d'une
	  console série (lire la <xref linkend="serialconsole-ddb"/>) ou la configuration d'une
	  partition &man.dump.8;.  Vous pouvez obtenir une trace de
	  débogage sous <acronym>DDB</acronym> avec la commande
	  <literal>tr</literal>.  Si vous devez recopier &agrave; la
	  main la trace de débogage, assurez-vous de relever les
	  cinq dernières lignes et les cinq premières
	  ligne de la trace.</para>

	<para>Ensuite essayez d'isoler le problème en
	  démarrant avec l'<acronym>ACPI</acronym>
	  désactivé.  Si cela fonctionne, vous pouvez isoler
	  le sous-système <acronym>ACPI</acronym> en utilisant
	  différentes valeurs pour l'option
	  <option>debug.acpi.disable</option>.  Consultez la page de
	  manuel &man.acpi.4; pour des exemples.</para>
      </sect3>

      <sect3>
	<title>Le système redémarre après une mise
	  en veille ou un arrêt</title>

	<para>Tout d'abord, essayez de fixer
	  <literal>hw.acpi.disable_on_poweroff="0"</literal> dans
	  &man.loader.conf.5;.  Cela empêche
	  l'<acronym>ACPI</acronym> de désactiver divers
	  événements lors du processus d'arrêt.
	  Certains systèmes ont besoin d'avoir cette valeur
	  fixée &agrave; <literal>1</literal> (valeur par
	  défaut) pour la même raison.  Cela corrige
	  généralement le problème d'un
	  système démarrant spontanément
	  après une mise en veille ou un arrêt.</para>
      </sect3>

      <sect3>
	<title>Autres problèmes</title>

	<para>Si vous rencontrez d'autres problèmes avec
	  l'<acronym>ACPI</acronym> (impossible de travailler avec une
	  station d'amarrage, périphériques non
	  détectés, etc.), veuillez envoyer un courrier
	  descriptif &agrave; la liste de diffusion; cependant, certains
	  de ces problèmes peuvent être relatifs &agrave;
	  des partie incomplètes du sous-système
	  <acronym>ACPI</acronym> et qui pourront prendre du temps
	  &agrave; être implémentées.  Soyez patient
	  et prêt &agrave; tester les correctifs que nous pourront
	  éventuellement vous envoyer.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>, <command>acpidump</command>, et
        <acronym>IASL</acronym></title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>ASL</secondary>
      </indexterm>

      <para>Le problème le plus courant est le fait que les
	constructeurs fournissent des <quote>bytecodes</quote>
	erronés (ou plus simplement bogués!).  Cela se
	manifeste généralement sur la console par des
	messages du noyau du type:</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>La plupart du temps vous pouvez corriger ces problèmes en
	mettant &agrave; jour votre <acronym>BIOS</acronym> avec la
	dernière version disponible.  La majorité des
	messages sur la console sont inoffensifs mais si vous avez
	d'autres problèmes comme l'état de la batterie qui
	ne fonctionne pas, ce sont de bonnes raisons pour commencer
	&agrave; jeter un oeil &agrave; ces problèmes dans
	l'<acronym>AML</acronym>.  Le <quote>bytecode</quote>, connu
	sous le nom d'<acronym>AML</acronym>, est compilé
	&agrave; partir d'un langage source appelé
	<acronym>ASL</acronym>.  L'<acronym>AML</acronym> se trouve dans
	une table appelée <acronym>DSDT</acronym>.  Pour obtenir
	une copie de votre <acronym>ASL</acronym>, utilisez
	&man.acpidump.8;.  Vous devriez utiliser de paire les options
	<option>-t</option> (qui affiche le contenu des tables fixes) et
	<option>-d</option> (qui désassemble
	l'<acronym>AML</acronym> en <acronym>ASL</acronym>).  Consultez
	la section <link linkend="ACPI-submitdebug">Soumettre des
	informations de déboguage</link> pour un exemple de
	syntaxe.</para>

      <para>Le tout premier test que vous pouvez effectuer est
	de recompiler votre <acronym>ASL</acronym> &agrave; la recherche
	d'erreurs.  Les avertissements peuvent être
	généralement ignorés mais les erreurs sont
	des bogues qui normalement empêchent
	l'<acronym>ACPI</acronym> de fonctionner correctement.  Pour
	recompiler votre <acronym>ASL</acronym>, utilisez la commande
	suivante:</para>

      <screen>&prompt.root; <userinput>iasl your.asl</userinput></screen>
    </sect2>

    <sect2 xml:id="ACPI-fixasl">
      <title>Correction de votre <acronym>ASL</acronym></title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>ASL</secondary>
      </indexterm>

      <para>A long terme, notre objectif est que tout le monde puisse
	avoir un système <acronym>ACPI</acronym> fonctionnant
	sans aucune intervention de l'utilisateur.  Actuellement, nous
	sommes toujours en train de développer des solutions pour
	contourner les erreurs courantes faites par les fabricants de
	<acronym>BIOS</acronym>.  L'interpréteur de &microsoft;
	(<filename>acpi.sys</filename> et
	<filename>acpiec.sys</filename>) ne contrôle pas de
	façon stricte la conformité avec la norme, et par
	conséquent de nombreux fabricants de
	<acronym>BIOS</acronym> qui testent l'<acronym>ACPI</acronym>
	uniquement sous &windows; ne corrigent donc jamais leur
	<acronym>ASL</acronym>.  Nous espérons poursuivre
	&agrave; identifier et documenter avec exactitude les
	comportements non-standards autorisés par
	l'interpréteur de &microsoft; et les reproduire de
	manière &agrave; permettre &agrave; &os; de fonctionner
	sans obliger les utilisateurs &agrave; corriger leur
	<acronym>ASL</acronym>.  Comme solution et pour nous aider
	&agrave; identifier ces comportements, vous pouvez corriger
	manuellement votre <acronym>ASL</acronym>.  Si cela fonctionne
	pour vous, veuillez nous envoyer un &man.diff.1; de l'ancien et
	du nouveau <acronym>ASL</acronym> de façon &agrave; ce
	que nous puissions corriger le comportement incorrect dans
	<acronym>ACPI-CA</acronym> et rendre donc inutile &agrave;
	l'avenir votre correctif.</para>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>messages d'erreur</secondary>
      </indexterm>

      <para>Voici une liste des messages d'erreur courants, leur cause,
	et comment les corriger:</para>

      <sect3>
	<title>Dépendances _OS</title>

	<para>Certains <acronym>AML</acronym>s supposent que le monde
	  n'est fait de que différentes versions de &windows;.
	  Vous pouvez demander &agrave; &os; de s'annoncer comme
	  étant n'importe quel système d'exploitation pour
	  voir si cela corrige les problèmes que vous pouvez
	  rencontrer.  Une manière simple de faire cela est de
	  fixer la variable <literal>hw.acpi.osname="Windows
	  2001"</literal> dans <filename>/boot/loader.conf</filename> ou
	  avec une autre chaîne de caractères que vous
	  trouvez dans l'<acronym>ASL</acronym>.</para>
      </sect3>

      <sect3>
	<title><errorname>Missing Return statements</errorname></title>

	<para>Certaines méthodes ne renvoient pas explicitement
	  une valeur comme la norme le demande.  Bien
	  qu'<acronym>ACPI-CA</acronym> ne gère pas cela, &os;
	  contourne ce problème en renvoyant implicitement la
	  valeur.  Vous pouvez également ajouter des <quote>Return
	  statements</quote> explicites où cela est
	  nécessaire si vous connaissez la valeur &agrave;
	  renvoyer.  Pour forcer <command>iasl</command> &agrave; compiler
	  l'<acronym>ASL</acronym>, utilisez l'option
	  <option>-f</option>.</para>
      </sect3>

      <sect3>
	<title>Remplacer l'<acronym>AML</acronym> par
	  défaut</title>

	<para>Après avoir personnalisé
	  <filename>votre.asl</filename>, vous voudrez le compiler, pour
	  cela exécutez:</para>

	<screen>&prompt.root; <userinput>iasl your.asl</userinput></screen>

	<para>Vous pouvez ajouter l'option <option>-f</option> pour
	  forcer la création de l'<acronym>AML</acronym>,
	  même s'il y a des erreurs lors de la compilation.
	  Rappelez-vous que certaines erreurs (e.g., <errorname>missing
	  Return statements</errorname>) sont automatiquement
	  contournées par l'interpréteur.</para>

	<para><filename>DSDT.aml</filename> est le fichier de sortie par
	  défaut pour <command>iasl</command>.  Vous pouvez le
	  charger &agrave; la place de la version boguée de votre
	  <acronym>BIOS</acronym> (qui est toujours présent dans la
	  mémoire flash) en éditant le fichier
	  <filename>/boot/loader.conf</filename> comme suit:</para>

	<programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

	<para>Assurez-vous de bien copier votre fichier
	  <filename>DSDT.aml</filename> dans le répertoire
	  <filename>/boot</filename>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="ACPI-debugoutput">
      <title>Obtenir d'<acronym>ACPI</acronym> une sortie de
	débogage</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>problèmes</secondary>
      </indexterm>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>débogage</secondary>
      </indexterm>

      <para>Le pilote <acronym>ACPI</acronym> dispose d'une fonction
	de débogage très flexible.  Elle vous permet de
	spécifier un ensemble de sous-systèmes ainsi que
	le niveau de verbosité.  Les sous-systèmes que
	vous désirez déboguer sont indiqués sous la
	forme de <quote>couches</quote> et sont divisés en
	composants <acronym>ACPI-CA</acronym> (ACPI_ALL_COMPONENTS) et
	en supports matériel <acronym>ACPI</acronym>
	(ACPI_ALL_DRIVERS).  La verbosité de la sortie de
	débogage est spécifiée par un
	<quote>niveau</quote> et des intervalles de ACPI_LV_ERROR
	(rapporte juste les erreurs) &agrave; ACPI_LV_VERBOSE (tout).
	Le <quote>niveau</quote> est un masque de bits
	séparés par des espaces, aussi de nombreuses
	options peuvent être fixées &agrave; la fois.  Dans
	la pratique, vous voudrez utiliser un console série pour
	afficher la sortie si les informations de débogage sont
	si importantes qu'elles dépassent le tampon des messages
	de la console.  Une liste complète des couches
	individuelles et des niveaux peut être trouvée dans
	la page de manuel &man.acpi.4;.</para>

      <para>L'affichage des informations de débogage n'est pas
	activé par défaut.  Pour l'activer, ajoutez la ligne
	<literal>options ACPI_DEBUG</literal> &agrave; votre fichier de
	configuration du noyau si l'<acronym>ACPI</acronym> est
	compilé dans le noyau.  Vous pouvez ajouter la ligne
	<literal>ACPI_DEBUG=1</literal> &agrave; votre fichier
	<filename>/etc/make.conf</filename> pour l'activer de façon
	globale.  Si l'<acronym>ACPI</acronym> est sous forme de module,
	vous pouvez recompiler votre module <filename>acpi.ko</filename>
	comme suit:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp;
make ACPI_DEBUG=1</userinput></screen>

      <para>Installez <filename>acpi.ko</filename> dans le
	répertoire <filename>/boot/kernel</filename> et indiquez le niveau et
	la couche désirée dans
	<filename>loader.conf</filename>.  L'exemple suivant active les
	messages de débogage pour tous les composants
	<acronym>ACPI-CA</acronym> et tous les pilotes de matériel
	<acronym>ACPI</acronym> (<acronym>CPU</acronym>,
	<acronym>LID</acronym>, etc.).  Il n'affichera que les messages
	d'erreur, c'est le niveau le moins verbeux.</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Si l'information que vous voulez est
	déclenchée par un événement particulier
	(disons par exemple une mise en veille suivi d'un réveil),
	vous pouvez abandonner les modifications dans
	<filename>loader.conf</filename> et utiliser &agrave; la place
	<command>sysctl</command> pour indiquer la couche et le niveau
	après le démarrage et préparer votre
	système pour cet événement particulier.  Les
	variables <command>sysctl</command> sont appelées de la
	même manière que dans le fichier
	<filename>loader.conf</filename>.</para>
    </sect2>

    <sect2 xml:id="ACPI-References">
      <title>Références</title>

      <para>Plus d'information au sujet de l'<acronym>ACPI</acronym>
	peut être trouvé aux emplacements suivants:</para>

      <itemizedlist>
	<listitem>
	  <para>La liste de diffusion &a.acpi;</para>
	</listitem>

	<listitem>
	  <para>Les archives de la liste de diffusion
	    <acronym>ACPI</acronym> <uri xlink:href="http://lists.freebsd.org/pipermail/freebsd-acpi/">http://lists.freebsd.org/pipermail/freebsd-acpi/</uri></para>
	</listitem>

	<listitem>
	  <para>Les archives de l'ancienne liste de diffusion
	  <acronym>ACPI</acronym> <uri xlink:href="http://home.jp.FreeBSD.org/mail-list/acpi-jp/">http://home.jp.FreeBSD.org/mail-list/acpi-jp/</uri></para>
	</listitem>

	<listitem>
	  <para>La spécification <acronym>ACPI</acronym> 2.0
	    <uri xlink:href="http://acpi.info/spec.htm">http://acpi.info/spec.htm</uri></para>
	</listitem>

	<listitem>
	  <para>Les pages de manuel: &man.acpi.4;,
	    &man.acpi.thermal.4;, &man.acpidump.8;, &man.iasl.8;,
	    &man.acpidb.8;</para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
	    Ressource sur le débogage de la
	    <acronym>DSDT</acronym></link>.  (Utilise un exemple
	    basé sur du matériel Compaq mais qui est en
	    général intéressant.)</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>
