<!-- $FreeBSD: doc/en_US.ISO_8859-1/articles/new-users/article.sgml,v 1.8 1999/10/04 21:36:22 jesusr Exp $ -->
<!-- The FreeBSD Documentation Project -->

<!DOCTYPE ARTICLE PUBLIC "-//FreeBSD//DTD DocBook V3.1-Based Extension//EN">
<article>

<artheader>
<title>For People New to Both FreeBSD and Unix</title>

<authorgroup>
<author>
<firstname>Annelise</firstname>
<surname>Anderson</surname>
<affiliation>
<address><email>andrsn@andrsn.stanford.edu</email></address>
</affiliation>
</author>
</authorgroup>

<pubdate>August 15, 1997</pubdate>

<abstract><para>Congratulations on installing FreeBSD! This
introduction is for people new to both FreeBSD
<emphasis>and</emphasis> Un*x&mdash;so it starts with basics.  It
assumes you're using version 2.0.5 or later of FreeBSD as distributed
by Walnut Creek or FreeBSD.org, your system (for now) has a single
user (you)&mdash;and you're probably pretty good with DOS/Windows or
OS/2.</para></abstract>

</artheader>

<sect1>
<title>Logging in and Getting Out</title>

<para>Log in (when you see <systemitem
class=prompt>login:</systemitem>) as a user you created during
installation or as <firstterm>root</firstterm>.  (Your FreeBSD
installation will already have an account for root; root can go
anywhere and do anything, including deleting essential files, so be
careful!) The symbols % and # in the following stand for the prompt 
(yours may be different), with % indicating an ordinary user and
# indicating root. </para>

<para>To log out (and get a new <systemitem class=prompt>login:</systemitem> prompt) type
</para>
<informalexample>
<screen>&prompt.root; <userinput>exit</userinput></screen>
</informalexample>
<para>
as often as necessary.  Yes, press <keysym>enter</keysym> after
commands, and remember that Unix is
case-sensitive&mdash;<command>exit</command>, not
<command>EXIT</command>.</para>

<para>To shut down the machine type:
</para>
<informalexample>
<screen>&prompt.root; <userinput>/sbin/shutdown -h now</userinput></screen>
</informalexample>
<para>
Or to reboot type
</para>
<informalexample>
<screen>&prompt.root; <userinput>/sbin/shutdown -r now</userinput></screen>
</informalexample>
<para>
or
</para>
<informalexample>
<screen>&prompt.root; <userinput>/sbin/reboot</userinput></screen>
</informalexample>

<para>You can also reboot with
<keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Delete</keycap></keycombo>. 
Give it a little time to do its work.  This is equivalent to
<command>/sbin/reboot</command> in recent releases of FreeBSD, and is
much, much better than hitting the reset button.  You don't want to
have to reinstall this thing, do you?</para>

</sect1>

<sect1>
<title>Adding A User with Root Privileges</title>

<para>If you didn't create any users when you installed the system and
are thus logged in as root, you should probably create a user now with
</para>
<informalexample>
<screen># <userinput>adduser</userinput></screen>
</informalexample>
<para>
The first time you use adduser, it might ask for some defaults to save.  You
might want to make the default shell csh instead of sh, if it suggests
sh as the default.  Otherwise just press enter to accept each default.
These defaults are saved in <filename>/etc/adduser.conf</filename>,
an editable file.</para>

<para>Suppose you create a user <emphasis>jack</emphasis> with
full name <emphasis>Jack Benimble</emphasis>.  Give jack a password
if security (even kids around who might pound on the keyboard) is an
issue.  When it asks you if you want to invite jack into other
groups, type <userinput>wheel</userinput>
</para>
<informalexample>
<screen>Login group is ``jack''. Invite jack into other groups: <userinput>wheel</userinput></screen>
</informalexample>
<para>
This will make it possible to log in as <emphasis>jack</emphasis> and
use the <command>su</command> command to become root.  Then you won't
get scolded any more for logging in as root.</para>

<para>You can quit <command>adduser</command> any time by typing
<keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>, and at
the end you'll have a chance to approve your new user or simply type
<keycap>n</keycap> for no. You might want to create a
second new user (jill?) so that when you edit jack's login files,
you'll have a hot spare in case something goes wrong.</para>

<para>Once you've done this, use <command>exit</command>
to get back to a login prompt and log in as
<emphasis>jack</emphasis>.  In general, it's a good idea to do as
much work as possible as an ordinary user who doesn't have the
power&mdash;and risk&mdash;of root.</para>

<para>If you already created a user and you want the user to be able
to <command>su</command> to root, you can log in as root
and edit the file <filename>/etc/group</filename>, adding jack to the
first line (the group wheel).  But first you need to practice
<command>vi</command>, the text editor--or use the simpler text
editor, <command>ee</command>, installed on recent version of
FreeBSD.</para>

<para>To delete a user, use the <command>rmuser</command> command.</para>

</sect1>

<sect1>
<title>Looking Around</title>

<para>Logged in as an ordinary user, look around and try out some
commands that will access the sources of help and information within
FreeBSD.</para>

<para>Here are some commands and what they do:
</para>
<variablelist>
<varlistentry><term><command>id</command></term>
<listitem>
<para>Tells you who you are!</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>pwd</command></term>

<listitem>
<para>Shows you where you are&mdash;the current
working directory.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>ls</command></term>

<listitem>
<para>Lists the files in the current directory.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>ls <option>-F</option></command></term>

<listitem>
<para>Lists the files in the current directory with a
<literal>*</literal> after executables, a <literal>/</literal> after
directories, and an <literal>@</literal> after symbolic links.</para>

</listitem>
</varlistentry>

<varlistentry><term><command>ls <option>-l</option></command></term>

<listitem>
<para>Lists the files in long format&mdash;size,
date, permissions.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>ls <option>-a</option></command></term>

<listitem>
<para>Lists hidden <quote>dot</quote>
files with the others.  If you're root, the<quote>dot</quote> files 
show up without the <option>-a</option> switch.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>cd</command></term>

<listitem>
<para>Changes directories.  <command>cd
<parameter>..</parameter></command> backs up one level; note the
space after <command>cd</command>.  <command>cd
<parameter>/usr/local</parameter></command> goes there.  <command>cd
<parameter>~</parameter></command>  goes to the home directory of the
person logged in&mdash;e.g., <filename>/usr/home/jack</filename>. 
Try <command>cd <parameter>/cdrom</parameter></command>, and then
<command>ls</command>, to find out if your CDROM is mounted and
working.</para>

</listitem>
</varlistentry>

<varlistentry><term><command>view <replaceable>filename</replaceable></command></term>

<listitem>
<para>Lets you look at a file (named
<replaceable>filename</replaceable> without changing it.  Try
<command>view <parameter>/etc/fstab</parameter></command>. 
<command>:q</command> to quit.</para>

</listitem>
</varlistentry>

<varlistentry><term><command>cat <replaceable>filename</replaceable></command></term>

<listitem>

<para>Displays <replaceable>filename</replaceable> on screen.  If
it's too long and you can see only the end of it, press
<keycap>ScrollLock</keycap> and use the <keycap>up-arrow</keycap> to
move backward; you can use <keycap>ScrollLock</keycap> with man pages
too.  Press <keycap>ScrollLock</keycap> again to quit scrolling. You
might want to try <command>cat</command> on some of the dot files in
your home directory&mdash;<command>cat
<parameter>.cshrc</parameter></command>, <command>cat
<parameter>.login</parameter></command>, <command>cat
<parameter>.profile</parameter></command>.</para>

</listitem>
</varlistentry>
</variablelist>
<para>
You'll notice aliases in <filename>.cshrc</filename> for some of the
<command>ls</command> commands (they're very convenient). 
You can create other aliases by editing <filename>.cshrc</filename>.
You can make these aliases available to all users on the system by
putting them in the system-wide csh configuration file,
<filename>/etc/csh.cshrc</filename>.</para>

</sect1>

<sect1>
<title>Getting Help and Information</title>

<para>Here are some useful sources of help. 
<replaceable>Text</replaceable> stands for something of your choice
that you type in&mdash;usually a command or filename.</para>

<variablelist>
<varlistentry><term><command>apropos <replaceable>text</replaceable></command></term>

<listitem>
<para>Everything containing string <replaceable>text</replaceable>
in the <database>whatis database</database>.</para>
</listitem>
</varlistentry>

<varlistentry><term><command>man <replaceable>text</replaceable></command></term>

<listitem>
<para>The man page for <replaceable>text</replaceable>. The major
source of documentation for Un*x systems.  <command>man
<parameter>ls</parameter></command> will tell you all the ways to use
the <command>ls</command> command. Press <keycap>Enter</keycap> to
move through text,
<keycombo><keycap>Ctrl</keycap><keycap>b</keycap></keycombo> to go
back a page, <keycombo><keycap>Ctrl</keycap><keycap>f</keycap></keycombo> to
go forward, <keycap>q</keycap> or
<keycombo><keycap>Ctrl</keycap><keycap>c</keycap></keycombo> to
quit.</para>
</listitem>
</varlistentry>

<varlistentry><term><command>which <replaceable>text</replaceable></command></term>

<listitem>
<para>Tells you where in the user's path the command
<replaceable>text</replaceable> is found.</para>
</listitem>
</varlistentry>

<varlistentry><term><command>locate <replaceable>text</replaceable></command></term>

<listitem>
<para>All the paths where the string <replaceable>text</replaceable>
is found.</para>
</listitem>
</varlistentry>

<varlistentry><term><command>whatis <replaceable>text</replaceable></command></term>

<listitem>
<para>Tells you what the command <replaceable>text</replaceable>
does and its man page. Typing <command>whatis *</command> will tell
you about all the binaries in the current directory.</para>
</listitem>
</varlistentry>

<varlistentry><term><command>whereis <replaceable>text</replaceable></command></term>

<listitem>
<para>Finds the file <replaceable>text</replaceable>, giving its full
path.</para>
</listitem>
</varlistentry>
</variablelist>
  
<para>You might want to try using <command>whatis</command> on some
common useful commands like <command>cat</command>,
<command>more</command>, <command>grep</command>,
<command>mv</command>, <command>find</command>,
<command>tar</command>, <command>chmod</command>,
<command>chown</command>, <command>date</command>, and
<command>script</command>. <command>more</command> lets you read a
page at a time as it does in DOS, e.g., <command>ls -l |
more</command> or <command>more
<replaceable>filename</replaceable></command>.  The
<literal>*</literal> works as a wildcard&mdash;e.g., <command>ls
w*</command> will show you files beginning with
<literal>w</literal>.</para>

<para>Are some of these not working very well?  Both
<command>locate</command> and <command>whatis</command>
depend on a database that's rebuilt weekly. If your machine isn't
going to be left on over the weekend (and running FreeBSD), you might
want to run the commands for daily, weekly, and monthly maintenance
now and then.  Run them as root and give each one time to finish
before you start the next one, for now.
</para>
<informalexample>
<screen>&prompt.root; <userinput>/etc/daily</userinput>
<lineannotation>output omitted</lineannotation>
&prompt.root; <userinput>/etc/weekly</userinput>
<lineannotation>output omitted</lineannotation>
&prompt.root; <userinput>/etc/monthly</userinput>
<lineannotation>output omitted</lineannotation></screen>
</informalexample>

<para>If you get tired waiting, press
<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> to get
another <firstterm>virtual console</firstterm>, and log in again. 
After all, it's a multi-user, multi-tasking system.  Nevertheless
these commands will probably flash messages on your screen while
they're running; you can type <command>clear</command> at the prompt
to clear the screen.  Once they've run, you might want to look at
<filename>/var/mail/root</filename> and
<filename>/var/log/messages</filename>.</para>

<para>Basically running such commands is part of system
administration&mdash;and as a single user of a Unix system, you're
your own system administrator. Virtually everything you need to be
root to do is system administration. Such responsibilities aren't
covered very well even in those big fat books on Unix, which seem to
devote a lot of space to pulling down menus in windows managers.  You
might want to get one of the two leading books on systems
administration, either Evi Nemeth et.al.'s <citetitle>UNIX System
Administration Handbook</citetitle> (Prentice-Hall, 1995, ISBN
0-13-15051-7)&mdash;the second edition with the red cover; or
&AElig;leen Frisch's <citetitle>Essential System
Administration</citetitle> (O'Reilly &amp; Associates, 1993, ISBN
0-937175-80-3). I used Nemeth.</para>

</sect1>

<sect1>
<title>Editing Text</title>

<para>To configure your system, you need to edit text files.  Most of
them will be in the <filename>/etc</filename> directory; and you'll
need to <command>su</command> to root to be able to change them.  You
can use the easy <command>ee</command>, but in the long run the
text editor <command>vi</command> is worth learning.  There's an
excellent tutorial on vi in 
<filename>/usr/src/contrib/nvi/docs/tutorial</filename> if you have 
that installed; otherwise you can get it by ftp to
<hostid>ftp.cdrom.com</hostid> in the directory 
FreeBSD/FreeBSD-current/src/contrib/nvi/docs/tutorial.</para>

<para>Before you edit a 
file, you should probably back it up.  Suppose you want to edit
<filename>/etc/rc.conf</filename>.  You could just use <command>cd
/etc</command> to get to the <filename>/etc</filename> directory and
do:
</para>
<informalexample>
<screen>&prompt.root; <userinput>cp rc.conf rc.conf.orig</userinput></screen>
</informalexample>
<para>
This would copy <filename>rc.conf</filename> to
<filename>rc.conf.orig</filename>, and you could later copy
<filename>rc.conf.orig</filename> to <emphasis
remap=tt>rc.conf</emphasis> to recover the original.  But even
better would be moving (renaming) and then copying back:
</para>
<informalexample>
<screen>&prompt.root; <userinput>mv rc.conf rc.conf.orig</userinput>
&prompt.root; <userinput>cp rc.conf.orig rc.conf</userinput></screen>
</informalexample>
<para>
because the <command>mv</command> command preserves the original date
and owner of the file.  You can now edit
<filename>rc.conf</filename>.  If you want the original back, you'd
then <userinput>mv rc.conf rc.conf.myedit</userinput>
(assuming you want to preserve your edited version) and then
</para>
<informalexample>
<screen># <userinput>mv rc.conf.orig rc.conf</userinput></screen>
</informalexample>
<para>
to put things back the way they were.</para>
  
<para>To edit a file, type
</para>
<informalexample>
<screen>&prompt.root; <userinput>vi <replaceable>filename</replaceable></userinput></screen>
</informalexample>
<para>
Move through the text with the arrow keys.  <keycap>Esc</keycap> (the
escape key) puts <command>vi</command> in command mode.  Here are some
commands:
</para>
<variablelist>
<varlistentry><term><command>x</command></term>
<listitem>
<para>delete letter the cursor is on</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>dd</command></term>

<listitem>
<para>delete the entire line (even if it wraps on the screen)</para>

</listitem>
</varlistentry>

<varlistentry><term><command>i</command></term>

<listitem>
<para>insert text at the cursor</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>a</command></term>

<listitem>
<para>insert text after the cursor</para>
  
</listitem>
</varlistentry>
</variablelist>
<para>
Once you type <command>i</command> or <command>a</command>, you can enter text.
<command>Esc</command> puts you back in command mode where you can type
</para>
<variablelist>
<varlistentry><term><command>:w</command></term>
<listitem>
<para>to write your changes to disk and continue editing</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>:wq</command></term>

<listitem>
<para>to write and quit</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>:q!</command></term>

<listitem>
<para>to quit without saving changes</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>/<replaceable>text</replaceable></command></term>

<listitem>
<para>to move the cursor to <replaceable>text</replaceable>;
<command>/<keycap>Enter</keycap></command> (the enter key) to find
the next instance of <replaceable>text</replaceable>.</para>

</listitem>
</varlistentry>

<varlistentry><term><command>G</command></term>

<listitem>
<para>to go to the end of the file</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command><replaceable>n</replaceable>G</command></term>

<listitem>
<para>to go to line <replaceable>n</replaceable> in
the file, where <replaceable>n</replaceable> is a number</para>
  
</listitem>
</varlistentry>

<varlistentry><term><keycombo><keycap>Ctrl</><keycap>L</></keycombo></term>

<listitem>
<para>to redraw the screen</para>
  
</listitem>
</varlistentry>

<varlistentry><term><keycombo><keycap>Ctrl</><keycap>b</></> and <keycombo><keycap>Ctrl</><keycap>f</></></term>

<listitem>
<para>go back
and forward a screen, as they
do with <command>more</> and <command>view</>.</para>
  
</listitem>
</varlistentry>
</variablelist>
  
<para>Practice with <command>vi</> in your home directory by creating
a new file with <command>vi <replaceable>filename</></> and adding
and deleting text, saving the file, and calling it up again. 
<command>vi</> delivers some surprises because it's really quite
complex, and sometimes you'll inadvertently issue a command that will
do something you don't expect.  (Some people actually like
<command>vi</>&mdash;it's more powerful than DOS EDIT&mdash;find out
about the <command>:r</> command.) Use <keycap>Esc</> one or
more times to be sure you're in command mode and proceed from there
when it gives you trouble, save often with <command>:w</>, and
use <command>:q!</> to get out and start over (from
your last <command>:w</>) when you need to.</para>

<para>Now you can <command>cd</> to <filename>/etc</filename>,
<command>su</> to root, use <command>vi</> to edit the file
<filename>/etc/group</filename>, and add a user to wheel so the user
has root privileges.  Just add a comma and the user's login name to
the end of the first line in the file, press <keycap>Esc</>, and use
<command>:wq</> to write the file to disk and quit.  Instantly
effective.  (You didn't put a space after the comma, did you?)</para>

</sect1>

<sect1>
<title>Printing Files from DOS</title>

<para>At this point you probably don't have the printer working, so here's a
way to create a file from a man page, move it to a floppy, and then
print it from DOS.  Suppose you want to read carefully about changing
permissions on files (pretty important).  You can use the command
man chmod to read about it.  The command
</para>
<informalexample>
<screen>&prompt.user; <userinput>man chmod | col -b &gt; chmod.txt</></screen>
</informalexample>
<para>
will remove formatting codes and send the man page to 
the <filename>chmod.txt</filename> file
instead of showing it on your screen.  Now put a dos-formatted
diskette in your floppy drive a, <command>su</> to
root, and type
</para>
<informalexample>
<screen>&prompt.root; <userinput>/sbin/mount -t msdos /dev/fd0 /mnt</></screen>
</informalexample>
<para>
to mount the floppy drive on <filename>/mnt</filename>.</para>
  
<para>Now (you no longer need to be root, and you can type
<command>exit</> to get back to being user jack) you can go to the
directory where you created chmod.txt and copy the file to the floppy
with:
</para>
<informalexample>
<screen>&prompt.user; <userinput>cp chmod.txt /mnt</></screen>
</informalexample>
<para>
and use <command>ls /mnt</command> to get a directory listing of
<filename>/mnt</filename>, which should show the file
<filename>chmod.txt</filename>.</para>

<para>You might especially want to make a file from
<filename>/sbin/dmesg</filename> by typing
</para>
<informalexample>
<screen>&prompt.user; <userinput>/sbin/dmesg &gt; dmesg.txt</></screen>
</informalexample>
<para>
and copying <filename>dmesg.txt</filename> to the floppy. 
<command>/sbin/dmesg</command> is the boot log record, and it's
useful to understand it because it shows what FreeBSD found when it
booted up.  If you ask questions on
<email>freebsd-questions@FreeBSD.org</> or on a USENET
group&mdash;like <quote>FreeBSD isn't finding my tape drive, what do
I do?</quote>&mdash;people will want to know what <command>dmesg</>
has to say.</para>

<para>You can now dismount the floppy drive (as root) to get the disk
out with
</para>
<informalexample>
<screen>&prompt.root; <userinput>/sbin/umount /mnt</></screen>
</informalexample>
<para>
and reboot to go to DOS.  Copy these files to a DOS directory, call
them up with DOS EDIT, Windows Notepad or Wordpad, or a word processor, make a
minor change so the file has to be saved, and print as you normally
would from DOS or Windows. Hope it works!  man pages come out best if
printed with the dos <command>print</> command.  (Copying files from
FreeBSD to a mounted dos partition is in some cases still a little
risky.)</para>

<para>Getting the printer printing from FreeBSD involves creating an
appropriate entry in <filename>/etc/printcap</filename> and creating
a matching spool directory in
<filename>/var/spool/output</filename>.  If your printer is on
<hardware>lpt0</> (what dos calls <hardware>LPT1</>), you may only
need to go to <filename>/var/spool/output</filename> and (as root)
create the directory <filename>lpd</> by typing:
<command>
mkdir lpd</command>, if it doesn't already
exist.
Then the printer should respond if it's turned on when the system is
booted, and lp or lpr should send a file to the printer. Whether or
not the file actually prints depends on configuring it, which is
covered in the <ulink
URL="../../handbook/handbook.html">FreeBSD
handbook.</></para>

</sect1>

<sect1>
<title>Other Useful Commands</title>

<variablelist>
<varlistentry><term><command>df</></term>
<listitem>
<para>shows file space and mounted systems.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>ps aux</></term>

<listitem>
<para>shows processes running. <command>ps ax</> is a narrower form.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>rm <replaceable>filename</></></term>

<listitem>
<para>remove <replaceable>filename</>.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>rm -R <replaceable>dir</></></term>

<listitem>
<para>removes a directory <replaceable>dir</> and all
subdirectories&mdash;careful!</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>ls -R</command></term>

<listitem>
<para>lists files in the current
directory and all subdirectories;
I used a variant, <command>ls -AFR &gt; where.txt</command>,
to get a list of all
the files in <filename>/</filename> and (separately)
<filename>/usr</filename> before I found better
ways to find files.</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>passwd</></term>

<listitem>
<para>to change user's password (or root's password)</para>
  
</listitem>
</varlistentry>

<varlistentry><term><command>man hier</></term>

<listitem>
<para>man page on the Unix file system</para>
  
</listitem>
</varlistentry>
</variablelist>

<para>Use <command>find</> to locate filename in <filename>/usr</filename>
or any of its subdirectories with
</para>
<informalexample>
<screen>&prompt.user; <userinput>find /usr -name "<replaceable>filename</>"</></screen>
</informalexample>
<para>
You can use <literal>*</literal> as a wildcard in
<parameter>"<replaceable>filename</>"</> (which should be in
quotes).  If you tell find to search in <filename>/</filename>
instead of <filename>/usr</filename> it will look for the file(s) on
all mounted file systems, including the CDROM and the dos
partition.</para>

<para>An excellent book that explains Unix commands and utilities is
Abrahams &amp; Larson, <citetitle>Unix for the Impatient</citetitle>
(2nd ed., Addison-Wesley, 1996).  There's also a lot of Unix
information on the Internet.  Try the <ulink
URL="http://www.eecs.nwu.edu/unix.html">Unix Reference
Desk</ulink>.</para>

</sect1>

<sect1>
<title>Next Steps</title>

<para>You should now have the tools you need to get around and edit
files, so you can get everything up and running.  There is a great
deal of information in the FreeBSD handbook (which is probably on
your hard drive) and <ulink URL="http://www.FreeBSD.org/">FreeBSD's
web site</ulink>.  A wide variety of packages and ports are on the
<ulink URL="http://www.cdrom.com/">Walnut Creek</ulink> CDROM as well
as the web site.  The handbook tells you more about how to use them
(get the package if it exists, with <command>pkg_add
/cdrom/packages/All/<replaceable>packagename</></>,
where <replaceable>packagename</replaceable> is the filename of the
package).  The cdrom has lists of the packages and ports with brief
descriptions in <filename>cdrom/packages/index</filename>,
<filename>cdrom/packages/index.txt</filename>, and
<filename>cdrom/ports/index</filename>, with fuller descriptions in
<filename>/cdrom/ports/*/*/pkg/DESCR</filename>, where the
<literal>*</literal>s represent subdirectories of kinds of programs
and program names respectively.</para>

<para>If you find the handbook too sophisticated (what with
<command>lndir</> and all) on installing ports from the cdrom,
here's what usually works:</para>
  
<para>Find the port you want, say <command>kermit</>.  There will be
a directory for it on the cdrom.  Copy the subdirectory to
<filename>/usr/local</filename> (a good place for software you add
that should be available to all users) with:</para>
<informalexample>
<screen>&prompt.root; <userinput>cp -R /cdrom/ports/comm/kermit /usr/local</></screen>
</informalexample>
<para>
This should result in a <filename>/usr/local/kermit</filename>
subdirectory that has all the files that the
<command>kermit</command> subdirectory on the CDROM has.</para>

<para>Next, create the directory <filename>/usr/ports/distfiles</filename>
if it doesn't already exist using <command>mkdir</>.  Now check
check <filename>/cdrom/ports/distfiles</filename> for a
file with a name that indicates it's the port you want.  Copy that
file to <filename>/usr/ports/distfiles</filename>; in recent versions
you can skip this step, as FreeBSD will do it for you. 
In the case of <command>kermit</>, there is no
distfile.</para>

<para>Then <command>cd</> to the subdirectory of
<filename>/usr/local/kermit</filename> that has the file
<filename>Makefile</>.  Type
</para>
<informalexample>
<screen>&prompt.root; <userinput>make all install</></screen>
</informalexample>
  
<para>During this process the port will ftp to get any compressed
files it needs that it didn't find on the cdrom or in
<filename>/usr/ports/distfiles</filename>.  If you don't have your
network running yet and there was no file for the port in
<filename>/cdrom/ports/distfiles</filename>,  you will have to get
the distfile using another machine and copy it to
<filename>/usr/ports/distfiles</filename> from a floppy or your dos
partition. Read <filename>Makefile</> (with <command>cat</> or
<command>more</> or <command>view</>) to find out where to go (the
master distribution site) to get the file and what its name is.  Its
name will be truncated when downloaded to DOS, and after you get it
into <filename>/usr/ports/distfiles</filename> you'll have to rename
it (with the <command>mv</> command) to its original name so it can
be found.  (Use binary file transfers!)  Then go back to
<filename>/usr/local/kermit</filename>, find the directory with
<filename>Makefile</>, and type <command>make all install</>.</para>

<para>The other thing that happens when installing ports or packages
is that some other program is needed.  If the installation stops with
a message <errorname>can't find unzip</errorname> or whatever, you
might need to install the package or port for unzip before you
continue.</para>

<para>Once it's installed type <command>rehash</> to make FreeBSD
reread the files in the path so it knows what's there. (If you get a
lot of <errorname>path not found</> messages when you use
<command>whereis</> or which, you might want to make additions to the
list of directories in the path statement in
<filename>.cshrc</filename> in your home directory.  The path
statement in Unix does the same kind of work it does in DOS, except
the current directory is not (by default) in the path for security
reasons;  if the command you want is in the directory you're in, you
need to type <filename>./</filename> before the command to make it
work; no space after the slash.)</para>

<para>You might want to get the most recent version of Netscape from
their <ulink URL="ftp://ftp.netscape.com">ftp site</ulink>. (Netscape
requires the X Window System.) There's now a FreeBSD version, so look
around carefully. Just use <command>gunzip
<replaceable>filename</></> and <command>tar xvf
<replaceable>filename</></> on it, move the binary to
<filename>/usr/local/bin</filename> or some other place binaries are
kept, <command>rehash</>, and then put the following lines in
<filename>.cshrc</filename> in each user's home directory or (easier)
in <filename>/etc/csh.cshrc</filename>,  the system-wide csh start-up
file:
</para>
<informalexample>
<programlisting>setenv XKEYSYMDB /usr/X11R6/lib/X11/XKeysymDB
setenv XNLSPATH /usr/X11R6/lib/X11/nls</>
</informalexample>
<para>
This assumes that the file <filename>XKeysymDB</> and the directory
<filename>nls</> are in <filename>/usr/X11R6/lib/X11</filename>; if
they're not, find them and put them there.</para>

<para>If you originally got Netscape as a port using the CDROM (or
ftp), don't replace <filename>/usr/local/bin/netscape</filename> with
the new netscape binary; this is just a shell script that sets up the
environmental variables for you. Instead rename the new binary to
<filename>netscape.bin</filename> and replace the old binary, which
is <filename>/usr/local/lib/netscape/netscape.bin</filename>.</para>

</sect1>

<sect1>

<title>Your Working Environment</title>

<para>Your shell is the most important part of your working environment.
In DOS, the usual shell is command.com.  The shell is what interprets
the commands you type on the command line, and thus communicates with
the rest of the operating system.  You can also write shell
scripts, which are like DOS batch files: a series of commands to be
run without your intervention.</para>

<para>Two shells come installed with FreeBSD:  csh and sh. csh is good for  
command-line work, but scripts should be written with sh (or bash).  You can
find out what shell you have by typing <command>echo $SHELL</command>.</para>

<para>The csh shell is okay, but tcsh does everything csh does and more.  It
It allows you to recall commands with the arrow keys and edit them.  
It has tab-key completion
of filenames (csh uses the escape key), and it lets you switch to the
directory you were last in with <command>cd -</command>.  It's also much
easier to alter your prompt with tcsh.  It makes life a lot easier.</para>

<para>Here are the three steps for installing a new shell:</para>

<procedure>
<step><para>Install the shell as a port or a package, just as you 
would any other port or package.  Use <command>rehash</command> and
<command>which tcsh</command> (assuming you're installing tcsh) to
make sure it got installed.</para></step>

<step><para>As root, edit <filename>/etc/shells</filename>, adding
a line in the file for the new shell, in this case /usr/local/bin/tcsh,
and save the file. (Some ports may do this for you.)</para></step>

<step><para>Use the <command>chsh</command> command to change your shell to
tcsh permanently, or type <command>tcsh</command> at the prompt to
change your shell without logging in again.</para></step>
</procedure>

<note>
<para>It can be dangerous to change root's shell
to something other than sh or csh on early versions of FreeBSD and many
other versions of Unix; you may not have a working shell when the system 
puts you into single user mode.  The solution is to use <command>su -m</command>
to become root, which will give you the tcsh as root, because the shell is part
of the environment.  You can make this permanent by adding it to your
<filename>.tcshrc</filename> file as an alias with <programlisting>alias su su -m.</></para>
</note>

<para>When tcsh starts up, it will read the 
<filename>/etc/csh.cshrc</filename> and <filename>/etc/csh.login</filename>
files, as does csh.  It will also read the
<filename>.login</filename> file in your home directory and the 
<filename>.cshrc</filename>
file as well, unless you provide a <filename>.tcshrc</filename> 
file. This you can do by simply copying <filename>.cshrc</filename>
to <filename>.tcshrc</filename>.</para>  

<para>Now that you've installed tcsh, you can adjust your prompt.  You can
find the details in the manual page for tcsh, but here is a line to
put in your <filename>.tcshrc</filename> that will tell you how many
commands you have typed, what time it is, and what directory you are in. 
It also produces a <literal>></literal> if you're an ordinary user and 
a <literal>#</literal> if you're root, but tsch will do that in any
case:</para>
<para>
	set prompt = "%h %t %~ %# "</para>

<para>This should go in the same place as the existing set prompt line
if there is one, or under "if($?prompt) then" if not.
Comment out the old line; you can always switch back to it if you prefer
it. Don't forget the spaces and quotes.  You can get the <filename>.tcshrc</filename> reread by typing <command>source .tcshrc</command>.</para>

<para>You can get a listing of other environmental variables that
have been set by typing <command>env</command> at the prompt.  The
result will show you your default editor, pager, and terminal type,
among possibly many others.  A useful command if you log in from a
remote location and can't run a program because the terminal isn't
capable is
<command>setenv TERM vt100</command>.</para>
</sect1>


<sect1>
<title>Other</title>

<para>As root, you can dismount the CDROM with <command>/sbin/umount
/cdrom</>, take it out of the drive, insert another one, and mount it
with <command>/sbin/mount_cd9660 /dev/cd0a /cdrom</> assuming
<hardware>cd0a</> is the device name for your CDROM drive.  The
most recent versions of FreeBSD let you mount the cdrom with just
<command>/sbin/mount /cdrom</command>.</para>

<para>Using the live file system&mdash;the second of FreeBSD's CDROM
disks&mdash;is useful if you've got limited space.  What is on the
live file system varies from release to release.  You might try
playing games from the cdrom.  This
involves using <command>lndir</>, which gets installed with the X
Window System, to tell the program(s) where to find the necessary
files, because they're in the <filename>/cdrom</filename> file system
instead of in <filename>/usr</filename> and its subdirectories, which
is where they're expected to be.  Read <command>man lndir</>.</para>

</sect1>

<sect1>
<title>Comments Welcome</title>

<para>If you use this guide I'd be interested in knowing where it was
unclear and what was left out that you think should be included, and
if it was helpful.  My thanks to Eugene W. Stark, professor of
computer science at SUNY-Stony Brook, and John Fieber for helpful
comments.</para>
  
<para>Annelise Anderson, <email>andrsn@andrsn.stanford.edu</></para>
  
</sect1>
</article>
