<!-- $FreeBSD$ -->
<!-- The FreeBSD Documentation Project -->

<!DOCTYPE ARTICLE PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % articles.ent PUBLIC "-//FreeBSD//ENTITIES DocBook FreeBSD Articles Entity Set//EN">
%articles.ent;
]>

<article>
  <articleinfo>
    <title>For People New to Both FreeBSD and &unix;</title>

    <authorgroup>
      <author>
	<firstname>Annelise</firstname>

	<surname>Anderson</surname>

	<affiliation>
	  <address><email>andrsn@andrsn.stanford.edu</email></address>
	</affiliation>
      </author>
    </authorgroup>

    <pubdate>August 15, 1997</pubdate>

    <legalnotice id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.ibm;
      &tm-attrib.microsoft;
      &tm-attrib.netscape;
      &tm-attrib.opengroup;
      &tm-attrib.general;
    </legalnotice>

    <abstract>
      <para>Congratulations on installing FreeBSD! This introduction
	is for people new to both FreeBSD <emphasis>and</emphasis>
	&unix;&mdash;so it starts with basics.  It assumes you are using
	version 2.0.5 or later of &os; as distributed by
	&os;.org, your system (for now) has a single user
	(you)&mdash;and you are probably pretty good with DOS/&windows;
	or &os2;.</para>
    </abstract>
  </articleinfo>

  <sect1 id="in-and-out">
    <title>Logging in and Getting Out</title>

    <para>Log in (when you see <prompt >login:</prompt>) as a user you
      created during installation or as <username>root</username>.
      (Your FreeBSD installation will already have an account for
      <username>root</username>; who can go anywhere and do anything, including deleting
      essential files, so be careful!) The symbols &prompt.user; and
      &prompt.root; in the following stand for the prompt (yours may
      be different), with &prompt.user; indicating an ordinary user
      and &prompt.root; indicating <username>root</username>.</para>

    <para>To log out (and get a new <prompt >login:</prompt> prompt)
      type</para>

    <informalexample>
      <screen>&prompt.root; <userinput>exit</userinput></screen>
    </informalexample>

    <para>as often as necessary.  Yes, press <keysym>enter</keysym>
      after commands, and remember that &unix; is
      case-sensitive&mdash;<command>exit</command>, not
      <command>EXIT</command>.</para>

    <para>To shut down the machine type</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -h now</userinput></screen>
    </informalexample>

    <para>Or to reboot type</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -r now</userinput></screen>
    </informalexample>

    <para>or</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/reboot</userinput></screen>
    </informalexample>

    <para>You can also reboot with
      <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Delete</keycap></keycombo>.
      Give it a little time to do its work.  This is equivalent to
      <command>/sbin/reboot</command> in recent releases of FreeBSD
      and is much, much better than hitting the reset button.  You
      do not want to have to reinstall this thing, do you?</para>
  </sect1>

  <sect1 id="adding-a-user">
    <title>Adding A User with Root Privileges</title>

    <para>If you did not create any users when you installed the system
      and are thus logged in as <username>root</username>, you should probably create a
      user now with</para>

    <informalexample>
      <screen>&prompt.root; <userinput>adduser</userinput></screen>
    </informalexample>

    <para>The first time you use <command>adduser</command>, it might ask for some
      defaults to save.  You might want to make the default shell
      &man.csh.1; instead of &man.sh.1;, if it suggests
      <command>sh</command> as the default.  Otherwise just press
      enter to accept each default.  These defaults are saved in
      <filename>/etc/adduser.conf</filename>, an editable file.</para>

    <para>Suppose you create a user <username>jack</username> with
      full name <emphasis>Jack Benimble</emphasis>.  Give <username>jack</username> a
      password if security (even kids around who might pound on the
      keyboard) is an issue.  When it asks you if you want to invite
      <username>jack</username> into other groups, type <groupname>wheel</groupname></para>

    <informalexample>
      <screen>Login group is ``jack''. Invite jack into other groups: <userinput>wheel</userinput></screen>
    </informalexample>

    <para>This will make it possible to log in as
      <username>jack</username> and use the &man.su.1;
      command to become <username>root</username>.  Then you will not get scolded any more for
      logging in as <username>root</username>.</para>

    <para>You can quit <command>adduser</command> any time by typing
      <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>,
      and at the end you will have a chance to approve your new user or
      simply type <keycap>n</keycap> for no.  You might want to create
      a second new user so that when you edit <username>jack</username>'s login
      files, you will have a hot spare in case something goes
      wrong.</para>

    <para>Once you have done this, use <command>exit</command> to get
      back to a login prompt and log in as <username>jack</username>.
      In general, it is a good idea to do as much work as possible as
      an ordinary user who does not have the power&mdash;and
      risk&mdash;of <username>root</username>.</para>

    <para>If you already created a user and you want the user to be
      able to <command>su</command> to <username>root</username>, you can log in as <username>root</username>
      and edit the file <filename>/etc/group</filename>, adding <username>jack</username>
      to the first line (the group <groupname>wheel</groupname>).  But
      first you need to practice &man.vi.1;, the text editor&mdash;or
      use the simpler text editor, &man.ee.1;, installed on recent
      versions of FreeBSD.</para>

    <para>To delete a user, use the <command>rmuser</command>
      command.</para>
  </sect1>

  <sect1 id="looking-around">
    <title>Looking Around</title>

    <para>Logged in as an ordinary user, look around and try out some
      commands that will access the sources of help and information
      within FreeBSD.</para>

    <para>Here are some commands and what they do:</para>

    <variablelist>
      <varlistentry>
	<term><command>id</command></term>

	<listitem>
	  <para>Tells you who you are!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>pwd</command></term>

	<listitem>
	  <para>Shows you where you are&mdash;the current working
	    directory.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls</command></term>

	<listitem>
	  <para>Lists the files in the current directory.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls <option>-F</option></command></term>

	<listitem>
	  <para>Lists the files in the current directory with a
	    <literal>*</literal> after executables, a
	    <literal>/</literal> after directories, and an
	    <literal>@</literal> after symbolic links.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls <option>-l</option></command></term>

	<listitem>
	  <para>Lists the files in long format&mdash;size, date,
	    permissions.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls <option>-a</option></command></term>

	<listitem>
	  <para>Lists hidden <quote>dot</quote> files with the others.
	    If you are <username>root</username>, the <quote>dot</quote> files show up
	    without the <option>-a</option> switch.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>cd</command></term>

	<listitem>
	  <para>Changes directories.  <command>cd
	    <parameter>..</parameter></command> backs up one level;
	    note the space after <command>cd</command>.  <command>cd
	    <parameter>/usr/local</parameter></command> goes there.
	    <command>cd <parameter>~</parameter></command> goes to the
	    home directory of the person logged in&mdash;e.g.,
	    <filename>/usr/home/jack</filename>.  Try <command>cd
	    <parameter>/cdrom</parameter></command>, and then
	    <command>ls</command>, to find out if your CDROM is
	    mounted and working.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>view
	    <replaceable>filename</replaceable></command></term>

	<listitem>
	  <para>Lets you look at a file (named
	    <replaceable>filename</replaceable>) without changing it.
	    Try <command>view
	    <parameter>/etc/fstab</parameter></command>.
	    Type <command>:q</command> to quit.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>cat
	    <replaceable>filename</replaceable></command></term>

	<listitem>
	  <para>Displays <replaceable>filename</replaceable> on
	    screen.  If it is too long and you can see only the end of
	    it, press <keycap>ScrollLock</keycap> and use the
	    <keycap>up-arrow</keycap> to move backward; you can use
	    <keycap>ScrollLock</keycap> with manual pages too.  Press
	    <keycap>ScrollLock</keycap> again to quit scrolling.  You
	    might want to try <command>cat</command> on some of the
	    dot files in your home directory&mdash;<command>cat
	      <parameter>.cshrc</parameter></command>, <command>cat
	      <parameter>.login</parameter></command>, <command>cat
	      <parameter>.profile</parameter></command>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>You will notice aliases in <filename>.cshrc</filename> for
      some of the <command>ls</command> commands (they are very
      convenient).  You can create other aliases by editing
      <filename>.cshrc</filename>.  You can make these aliases
      available to all users on the system by putting them in the
      system-wide <command>csh</command> configuration file,
      <filename>/etc/csh.cshrc</filename>.</para>
  </sect1>

  <sect1 id="getting-help">
    <title>Getting Help and Information</title>

    <para>Here are some useful sources of help.
      <replaceable>Text</replaceable> stands for something of your
      choice that you type in&mdash;usually a command or
      filename.</para>

    <variablelist>
      <varlistentry>
	<term><command>apropos
	    <replaceable>text</replaceable></command></term>

	<listitem>
	  <para>Everything containing string
	    <replaceable>text</replaceable> in the <database>whatis
	    database</database>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>man
	    <replaceable>text</replaceable></command></term>

	<listitem>
	  <para>The manual page for <replaceable>text</replaceable>.  The
	    major source of documentation for &unix; systems.
	    <command>man <parameter>ls</parameter></command> will tell
	    you all the ways to use the <command>ls</command> command.
	    Press <keycap>Enter</keycap> to move through text,
	    <keycombo><keycap>Ctrl</keycap><keycap>B</keycap></keycombo>
	    to go back a page,
	    <keycombo><keycap>Ctrl</keycap><keycap>F</keycap></keycombo>
	    to go forward, <keycap>q</keycap> or
	    <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>
	    to quit.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>which
	    <replaceable>text</replaceable></command></term>

	<listitem>
	  <para>Tells you where in the user's path the command
	    <replaceable>text</replaceable> is found.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>locate
	    <replaceable>text</replaceable></command></term>

	<listitem>
	  <para>All the paths where the string
	    <replaceable>text</replaceable> is found.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>whatis
	    <replaceable>text</replaceable></command></term>

	<listitem>
	  <para>Tells you what the command
	    <replaceable>text</replaceable> does and its manual page.
	    Typing <command>whatis *</command> will tell you about all
	    the binaries in the current directory.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>whereis
	    <replaceable>text</replaceable></command></term>

	<listitem>
	  <para>Finds the file <replaceable>text</replaceable>, giving
	    its full path.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>You might want to try using <command>whatis</command> on
      some common useful commands like <command>cat</command>,
      <command>more</command>, <command>grep</command>,
      <command>mv</command>, <command>find</command>,
      <command>tar</command>, <command>chmod</command>,
      <command>chown</command>, <command>date</command>, and
      <command>script</command>.  <command>more</command> lets you
      read a page at a time as it does in DOS, e.g., <command>ls -l |
	more</command> or <command>more
	<replaceable>filename</replaceable></command>.  The
      <literal>*</literal> works as a wildcard&mdash;e.g., <command>ls
	w*</command> will show you files beginning with
      <literal>w</literal>.</para>

    <para>Are some of these not working very well?  Both
      &man.locate.1; and &man.whatis.1; depend
      on a database that is rebuilt weekly.  If your machine is not
      going to be left on over the weekend (and running FreeBSD), you
      might want to run the commands for daily, weekly, and monthly
      maintenance now and then.  Run them as <username>root</username> and, for now, give each one
      time to finish before you start the next one.</para>

    <informalexample>
      <screen>&prompt.root; <userinput>periodic daily</userinput>
<lineannotation>output omitted</lineannotation>
&prompt.root; <userinput>periodic weekly</userinput>
<lineannotation>output omitted</lineannotation>
&prompt.root; <userinput>periodic monthly</userinput>
<lineannotation>output omitted</lineannotation></screen>
    </informalexample>

    <para>If you get tired of waiting, press
      <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> to
      get another <firstterm>virtual console</firstterm>, and log in
      again.  After all, it is a multi-user, multi-tasking system.
      Nevertheless these commands will probably flash messages on your
      screen while they are running; you can type
      <command>clear</command> at the prompt to clear the screen.
      Once they have run, you might want to look at
      <filename>/var/mail/root</filename> and
      <filename>/var/log/messages</filename>.</para>

    <para>Running such commands is part of system
      administration&mdash;and as a single user of a &unix; system,
      you are your own system administrator.  Virtually everything you
      need to be <username>root</username> to do is system administration.  Such
      responsibilities are not covered very well even in those big fat
      books on &unix;, which seem to devote a lot of space to pulling
      down menus in windows managers.  You might want to get one of
      the two leading books on systems administration, either Evi
      Nemeth et.al.'s <citetitle>UNIX System Administration
      Handbook</citetitle> (Prentice-Hall, 1995, ISBN
      0-13-15051-7)&mdash;the second edition with the red cover; or
      &AElig;leen Frisch's <citetitle>Essential System
      Administration</citetitle> (O'Reilly &amp; Associates, 2002,
      ISBN 0-596-00343-9).  I used Nemeth.</para>
  </sect1>

  <sect1 id="editing-text">
    <title>Editing Text</title>

    <para>To configure your system, you need to edit text files.  Most
      of them will be in the <filename>/etc</filename> directory; and
      you will need to <command>su</command> to <username>root</username> to be able to
      change them.  You can use the easy <command>ee</command>, but in
      the long run the text editor <command>vi</command> is worth
      learning.  There is an excellent tutorial on vi in
      <filename>/usr/src/contrib/nvi/docs/tutorial</filename>, if you
      have the system sources installed.</para> 

    <para>Before you edit a file, you should probably back it up.
      Suppose you want to edit <filename>/etc/rc.conf</filename>.  You
      could just use <command>cd /etc</command> to get to the
      <filename>/etc</filename> directory and do:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp rc.conf rc.conf.orig</userinput></screen>
    </informalexample>

    <para>This would copy <filename>rc.conf</filename> to
      <filename>rc.conf.orig</filename>, and you could later copy
      <filename>rc.conf.orig</filename> to
      <filename>rc.conf</filename> to recover the original.  But even
      better would be moving (renaming) and then copying back:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf rc.conf.orig</userinput>
&prompt.root; <userinput>cp rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>because the <command>mv</command> command preserves the
      original date and owner of the file.  You can now edit
      <filename>rc.conf</filename>.  If you want the original back,
      you would then <userinput>mv rc.conf rc.conf.myedit</userinput>
      (assuming you want to preserve your edited version) and
      then</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>to put things back the way they were.</para>

    <para>To edit a file, type</para>

    <informalexample>
      <screen>&prompt.root; <userinput>vi <replaceable>filename</replaceable></userinput></screen>
    </informalexample>

    <para>Move through the text with the arrow keys.
      <keycap>Esc</keycap> (the escape key) puts <command>vi</command>
      in command mode.  Here are some commands:</para>

    <variablelist>
      <varlistentry>
	<term><command>x</command></term>

	<listitem>
	  <para>delete letter the cursor is on</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>dd</command></term>

	<listitem>
	  <para>delete the entire line (even if it wraps on the
	    screen)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>i</command></term>

	<listitem>
	  <para>insert text at the cursor</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>a</command></term>

	<listitem>
	  <para>insert text after the cursor</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Once you type <command>i</command> or <command>a</command>,
      you can enter text.  <command>Esc</command> puts you back in
      command mode where you can type</para>

    <variablelist>
      <varlistentry>
	<term><command>:w</command></term>

	<listitem>
	  <para>to write your changes to disk and continue
	    editing</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>:wq</command></term>

	<listitem>
	  <para>to write and quit</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>:q!</command></term>

	<listitem>
	  <para>to quit without saving changes</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>/<replaceable>text</replaceable></command></term>

	<listitem>
	  <para>to move the cursor to <replaceable>text</replaceable>;
	    <command>/<keycap>Enter</keycap></command> (the enter key)
	    to find the next instance of
	    <replaceable>text</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>G</command></term>

	<listitem>
	  <para>to go to the end of the file</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command><replaceable>n</replaceable>G</command></term>

	<listitem>
	  <para>to go to line <replaceable>n</replaceable> in the
	    file, where <replaceable>n</replaceable> is a
	    number</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><keycombo><keycap>Ctrl</keycap><keycap>L</keycap></keycombo></term>

	<listitem>
	  <para>to redraw the screen</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><keycombo><keycap>Ctrl</keycap><keycap>b</keycap></keycombo> and
	  <keycombo><keycap>Ctrl</keycap><keycap>f</keycap></keycombo></term>

	<listitem>
	  <para>go back and forward a screen, as they do with
	    <command>more</command> and <command>view</command>.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Practice with <command>vi</command> in your home directory
      by creating a new file with <command>vi
      <replaceable>filename</replaceable></command> and adding and
      deleting text, saving the file, and calling it up again.
      <command>vi</command> delivers some surprises because it is
      really quite complex, and sometimes you will inadvertently issue a
      command that will do something you do not expect.  (Some people
      actually like <command>vi</command>&mdash;it is more powerful
      than DOS EDIT&mdash;find out about the <command>:r</command>
      command.) Use <keycap>Esc</keycap> one or more times to be sure
      you are in command mode and proceed from there when it gives you
      trouble, save often with <command>:w</command>, and use
      <command>:q!</command> to get out and start over (from your last
      <command>:w</command>) when you need to.</para>

    <para>Now you can <command>cd</command> to
      <filename>/etc</filename>, <command>su</command> to <username>root</username>, use
      <command>vi</command> to edit the file
      <filename>/etc/group</filename>, and add a user to <groupname>wheel</groupname> so the
      user has root privileges.  Just add a comma and the user's login
      name to the end of the first line in the file, press
      <keycap>Esc</keycap>, and use <command>:wq</command> to write
      the file to disk and quit.  Instantly effective.  (You did not
      put a space after the comma, did you?)</para>
  </sect1>

  <sect1 id="printing-files-from-dos">
    <title>Printing Files from DOS</title>

    <para>At this point you probably do not have the printer working,
      so here is a way to create a file from a manual page, move it to a
      floppy, and then print it from DOS.  Suppose you want to read
      carefully about changing permissions on files (pretty
      important).  You can use <command>man chmod</command> to read
      about it.  The command</para>

    <informalexample>
      <screen>&prompt.user; <userinput>man chmod | col -b &gt; chmod.txt</userinput></screen>
    </informalexample>

    <para>will remove formatting codes and send the manual page to the
      <filename>chmod.txt</filename> file instead of showing it on
      your screen.  Now put a dos-formatted diskette in your floppy
      drive <devicename>a</devicename>, <command>su</command> to <username>root</username>, and type</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/mount -t msdosfs /dev/fd0 /mnt</userinput></screen>
    </informalexample>

    <para>to mount the floppy drive on
      <filename>/mnt</filename>.</para>

    <para>Now (you no longer need to be <username>root</username>, and you can type
      <command>exit</command> to get back to being user jack) you can
      go to the directory where you created
      <filename>chmod.txt</filename> and copy the file to the floppy
      with:</para>

    <informalexample>
      <screen>&prompt.user; <userinput>cp chmod.txt /mnt</userinput></screen>
    </informalexample>

    <para>and use <command>ls /mnt</command> to get a directory
      listing of <filename>/mnt</filename>, which should show the file
      <filename>chmod.txt</filename>.</para>

    <para>You might especially want to make a file from
      <filename>/sbin/dmesg</filename> by typing</para>

    <informalexample>
      <screen>&prompt.user; <userinput>/sbin/dmesg &gt; dmesg.txt</userinput></screen>
    </informalexample>

    <para>and copying <filename>dmesg.txt</filename> to the floppy.
      <command>/sbin/dmesg</command> is the boot log record, and it is
      useful to understand it because it shows what FreeBSD found when
      it booted up.  If you ask questions on the &a.questions; or on a USENET
      group&mdash;like <quote>FreeBSD is not finding my tape drive,
      what do I do?</quote>&mdash;people will want to know what
      <command>dmesg</command> has to say.</para>

    <para>You can now unmount the floppy drive (as <username>root</username>) to get the
      disk out with</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/umount /mnt</userinput></screen>
    </informalexample>

    <para>and reboot to go to DOS.  Copy these files to a DOS
      directory, call them up with DOS EDIT, &windows; Notepad or
      Wordpad, or a word processor, make a minor change so the file
      has to be saved, and print as you normally would from DOS or
      Windows.  Hope it works!  Manual pages come out best if printed
      with the DOS <command>print</command> command.  (Copying files
      from FreeBSD to a mounted DOS partition is in some cases still a
      little risky.)</para>

    <para>Getting the printer printing from FreeBSD involves creating
      an appropriate entry in <filename>/etc/printcap</filename> and
      creating a matching spool directory in
      <filename>/var/spool/output</filename>.  If your printer is on
      <hardware>lpt0</hardware> (what DOS calls
      <hardware>LPT1</hardware>), you may only need to go to
      <filename>/var/spool/output</filename> and (as <username>root</username>) create the
      directory <filename>lpd</filename> by typing: <command>mkdir
      lpd</command>, if it does not already exist.  Then the printer
      should respond if it is turned on when the system is booted, and
      <command>lp</command> or <command>lpr</command> should send a
      file to the printer.  Whether or not the file actually prints
      depends on configuring it, which is covered in the <ulink
      url="&url.books.handbook;/index.html">FreeBSD
      handbook.</ulink></para>
  </sect1>

  <sect1 id="other-useful-commands">
    <title>Other Useful Commands</title>

    <variablelist>
      <varlistentry>
	<term><command>df</command></term>

	<listitem>
	  <para>shows file space and mounted systems.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ps aux</command></term>

	<listitem>
	  <para>shows processes running.  <command>ps ax</command> is a
	    narrower form.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>rm <replaceable>filename</replaceable></command></term>

	<listitem>
	  <para>remove <replaceable>filename</replaceable>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>rm -R <replaceable>dir</replaceable></command></term>

	<listitem>
	  <para>removes a directory <replaceable>dir</replaceable> and all
	    subdirectories&mdash;careful!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>ls -R</command></term>

	<listitem>
	  <para>lists files in the current directory and all
	    subdirectories; I used a variant, <command>ls -AFR &gt;
	      where.txt</command>, to get a list of all the files in
	    <filename>/</filename> and (separately)
	    <filename>/usr</filename> before I found better ways to
	    find files.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>passwd</command></term>

	<listitem>
	  <para>to change user's password (or <username>root</username>'s password)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>man hier</command></term>

	<listitem>
	  <para>manual page on the &unix; filesystem</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Use <command>find</command> to locate <filename>filename</filename> in
      <filename>/usr</filename> or any of its subdirectories
      with</para>

    <informalexample>
      <screen>&prompt.user; <userinput>find /usr -name "<replaceable>filename</replaceable>"</userinput></screen>
    </informalexample>

    <para>You can use <literal>*</literal> as a wildcard in
      <parameter>"<replaceable>filename</replaceable>"</parameter>
      (which should be in quotes).  If you tell
      <command>find</command> to search in <filename>/</filename>
      instead of <filename>/usr</filename> it will look for the
      file(s) on all mounted filesystems, including the CDROM and the
      DOS partition.</para>

    <para>An excellent book that explains &unix; commands and utilities
      is Abrahams &amp; Larson, <citetitle>Unix for the
	Impatient</citetitle> (2nd ed., Addison-Wesley, 1996).
      There is also a lot of &unix; information on the Internet.</para>
  </sect1>

  <sect1 id="next-steps">
    <title>Next Steps</title>

    <para>You should now have the tools you need to get around and
      edit files, so you can get everything up and running.  There is
      a great deal of information in the FreeBSD handbook (which is
      probably on your hard drive) and <ulink
      url="&url.base;/index.html">FreeBSD's web site</ulink>.  A
      wide variety of packages and ports are on the CDROM as well as
      the web site.  The handbook tells you more about how to use them
      (get the package if it exists, with <command>pkg_add
      /cdrom/packages/All/<replaceable>packagename</replaceable></command>,
      where <replaceable>packagename</replaceable> is the filename of
      the package).  The CDROM has lists of the packages and ports
      with brief descriptions in
      <filename>cdrom/packages/index</filename>,
      <filename>cdrom/packages/index.txt</filename>, and
      <filename>cdrom/ports/index</filename>, with fuller descriptions
      in <filename>/cdrom/ports/*/*/pkg/DESCR</filename>, where the
      <literal>*</literal>s represent subdirectories of kinds of
      programs and program names respectively.</para>

    <para>If you find the handbook too sophisticated (what with
      <command>lndir</command> and all) on installing ports from the
      CDROM, here is what usually works:</para>

    <para>Find the port you want, say <command>kermit</command>.
      There will be a directory for it on the CDROM.  Copy the
      subdirectory to <filename>/usr/local</filename> (a good place
      for software you add that should be available to all users)
      with:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp -R /cdrom/ports/comm/kermit /usr/local</userinput></screen>
    </informalexample>

    <para>This should result in a
      <filename>/usr/local/kermit</filename> subdirectory that has all
      the files that the <command>kermit</command> subdirectory on the
      CDROM has.</para>

    <para>Next, create the directory
      <filename>/usr/ports/distfiles</filename> if it does not already
      exist using <command>mkdir</command>.  Now check
      <filename>/cdrom/ports/distfiles</filename> for a file with a
      name that indicates it is the port you want.  Copy that file to
      <filename>/usr/ports/distfiles</filename>; in recent versions
      you can skip this step, as FreeBSD will do it for you.  In the
      case of <command>kermit</command>, there is no distfile.</para>

    <para>Then <command>cd</command> to the subdirectory of
      <filename>/usr/local/kermit</filename> that has the file
      <filename>Makefile</filename>.  Type</para>

    <informalexample>
      <screen>&prompt.root; <userinput>make all install</userinput></screen>
    </informalexample>

    <para>During this process the port will FTP to get any compressed
      files it needs that it did not find on the CDROM or in
      <filename>/usr/ports/distfiles</filename>.  If you do not have
      your network running yet and there was no file for the port in
      <filename>/cdrom/ports/distfiles</filename>, you will have to
      get the distfile using another machine and copy it to
      <filename>/usr/ports/distfiles</filename> from a floppy or your
      DOS partition.  Read <filename>Makefile</filename> (with
      <command>cat</command> or <command>more</command> or
      <command>view</command>) to find out where to go (the master
      distribution site) to get the file and what its name is.  Its
      name will be truncated when downloaded to DOS, and after you get
      it into <filename>/usr/ports/distfiles</filename> you will have to
      rename it (with the <command>mv</command> command) to its
      original name so it can be found.  (Use binary file transfers!)
      Then go back to <filename>/usr/local/kermit</filename>, find the
      directory with <filename>Makefile</filename>, and type
      <command>make all install</command>.</para>

    <para>The other thing that happens when installing ports or
      packages is that some other program is needed.  If the
      installation stops with a message <errorname>can't find
	unzip</errorname> or whatever, you might need to install the
      package or port for unzip before you continue.</para>

    <para>Once it is installed type <command>rehash</command> to make
      FreeBSD reread the files in the path so it knows what is there.
      (If you get a lot of <errorname>path not found</errorname>
      messages when you use <command>whereis</command> or <command>which</command>, you
      might want to make additions to the list of directories in the
      path statement in <filename>.cshrc</filename> in your home
      directory.  The path statement in &unix; does the same kind of
      work it does in DOS, except the current directory is not (by
      default) in the path for security reasons; if the command you
      want is in the directory you are in, you need to type
      <filename>./</filename> before the command to make it work; no
      space after the slash.)</para>

    <para>You might want to get the most recent version of &netscape;
      from their <ulink url="ftp://ftp.netscape.com/">FTP site</ulink>.
      (&netscape; requires the X Window System.) There is now a FreeBSD
      version, so look around carefully.  Just use <command>gunzip
      <replaceable>filename</replaceable></command> and <command>tar
      xvf <replaceable>filename</replaceable></command> on it, move
      the binary to <filename>/usr/local/bin</filename> or some other
      place binaries are kept, <command>rehash</command>, and then put
      the following lines in <filename>.cshrc</filename> in each
      user's home directory or (easier) in
      <filename>/etc/csh.cshrc</filename>, the system-wide
      <command>csh</command> start-up file:</para>

    <informalexample>
      <programlisting>setenv XKEYSYMDB /usr/X11R6/lib/X11/XKeysymDB
setenv XNLSPATH /usr/X11R6/lib/X11/nls</programlisting>
    </informalexample>

    <para>This assumes that the file <filename>XKeysymDB</filename>
      and the directory <filename>nls</filename> are in
      <filename>/usr/X11R6/lib/X11</filename>; if they are not, find
      them and put them there.</para>

    <para>If you originally got &netscape; as a port using the CDROM (or
      FTP), do not replace <filename>/usr/local/bin/netscape</filename>
      with the new netscape binary; this is just a shell script that
      sets up the environment variables for you.  Instead rename the
      new binary to <filename>netscape.bin</filename> and replace the
      old binary, which is
      <filename>/usr/local/netscape/netscape</filename>.</para>
  </sect1>

  <sect1 id="your-working-environment">
    <title>Your Working Environment</title>

    <para>Your shell is the most important part of your working
      environment.  In DOS, the usual shell is command.com.  The shell
      is what interprets the commands you type on the command line,
      and thus communicates with the rest of the operating system.
      You can also write shell scripts, which are like DOS batch
      files: a series of commands to be run without your
      intervention.</para>

    <para>Two shells come installed with FreeBSD:
      <command>csh</command> and <command>sh</command>.
      <command>csh</command> is good for command-line work, but
      scripts should be written with <command>sh</command> (or
      <command>bash</command>).  You can find out what shell you have
      by typing <command>echo $SHELL</command>.</para>

    <para>The <command>csh</command> shell is okay, but
      <command>tcsh</command> does everything <command>csh</command>
      does and more.  It allows you to recall commands with the arrow
      keys and edit them.  It has tab-key completion of filenames
      (<command>csh</command> uses the <keycap>Esc</keycap> key), and
      it lets you switch to the directory you were last in with
      <command>cd -</command>.  It is also much easier to alter your
      prompt with <command>tcsh</command>.  It makes life a lot
      easier.</para>

    <para>Here are the three steps for installing a new shell:</para>

    <procedure>
      <step>
	<para>Install the shell as a port or a package, just as you
	  would any other port or package.  Use
	  <command>rehash</command> and <command>which tcsh</command>
	  (assuming you are installing <command>tcsh</command>) to make
	  sure it got installed.</para>
      </step>

      <step>
	<para>As <username>root</username>, edit <filename>/etc/shells</filename>, adding a
	  line in the file for the new shell, in this case
	  <filename>/usr/local/bin/tcsh</filename>, and save the file.
	  (Some ports may do this for you.)</para>
      </step>

      <step>
	<para>Use the <command>chsh</command> command to change your
	  shell to <command>tcsh</command> permanently, or type
	  <command>tcsh</command> at the prompt to change your shell
	  without logging in again.</para>
      </step>
    </procedure>

    <note>
      <para>It can be dangerous to change <username>root</username>'s shell to something
	other than <command>sh</command> or <command>csh</command> on
	early versions of FreeBSD and many other versions of &unix;; you
	may not have a working shell when the system puts you into
	single user mode.  The solution is to use <command>su
	-m</command> to become <username>root</username>, which will give you the
	<command>tcsh</command> as <username>root</username>, because the shell is part of
	the environment.  You can make this permanent by adding it to
	your <filename>.tcshrc</filename> file as an alias with:</para>
	<programlisting>alias su su -m</programlisting>
    </note>

    <para>When <command>tcsh</command> starts up, it will read the
      <filename>/etc/csh.cshrc</filename> and
      <filename>/etc/csh.login</filename> files, as does
      <command>csh</command>.  It will also read the
      <filename>.login</filename> file in your home directory and the
      <filename>.cshrc</filename> file as well, unless you provide a
      <filename>.tcshrc</filename> file.  This you can do by simply
      copying <filename>.cshrc</filename> to
      <filename>.tcshrc</filename>.</para>

    <para>Now that you have installed <command>tcsh</command>, you can
      adjust your prompt.  You can find the details in the manual page
      for <command>tcsh</command>, but here is a line to put in your
      <filename>.tcshrc</filename> that will tell you how many
      commands you have typed, what time it is, and what directory you
      are in.  It also produces a <literal>></literal> if you are an
      ordinary user and a <literal>#</literal> if you are <username>root</username>, but
      tsch will do that in any case:</para>

    <para>set prompt = "%h %t %~ %# "</para>

    <para>This should go in the same place as the existing set prompt
      line if there is one, or under "if($?prompt) then" if not.
      Comment out the old line; you can always switch back to it if
      you prefer it.  Do not forget the spaces and quotes.  You can get
      the <filename>.tcshrc</filename> reread by typing
      <command>source .tcshrc</command>.</para>

    <para>You can get a listing of other environmental variables that
      have been set by typing <command>env</command> at the prompt.
      The result will show you your default editor, pager, and
      terminal type, among possibly many others.  A useful command if
      you log in from a remote location and can not run a program
      because the terminal is not capable is <command>setenv TERM
      vt100</command>.</para>
  </sect1>

  <sect1 id="other">
    <title>Other</title>

    <para>As <username>root</username>, you can unmount the CDROM with
      <command>/sbin/umount /cdrom</command>, take it out of the
      drive, insert another one, and mount it with
      <command>/sbin/mount_cd9660 /dev/cd0a /cdrom</command> assuming
      <hardware>cd0a</hardware> is the device name for your CDROM
      drive.  The most recent versions of FreeBSD let you mount the
      CDROM with just <command>/sbin/mount /cdrom</command>.</para>

    <para>Using the live filesystem&mdash;the second of FreeBSD's
      CDROM disks&mdash;is useful if you have got limited space.  What
      is on the live filesystem varies from release to release.  You
      might try playing games from the CDROM.  This involves using
      <command>lndir</command>, which gets installed with the X Window
      System, to tell the program(s) where to find the necessary
      files, because they are in the <filename>/cdrom</filename> file
      system instead of in <filename>/usr</filename> and its
      subdirectories, which is where they are expected to be.  Read
      <command>man lndir</command>.</para>
  </sect1>

  <sect1 id="comments-welcome">
    <title>Comments Welcome</title>

    <para>If you use this guide I would be interested in knowing where it
      was unclear and what was left out that you think should be
      included, and if it was helpful.  My thanks to Eugene W. Stark,
      professor of computer science at SUNY-Stony Brook, and John
      Fieber for helpful comments.</para>

    <para>Annelise Anderson,
	<email>andrsn@andrsn.stanford.edu</email></para>
  </sect1>
</article>
