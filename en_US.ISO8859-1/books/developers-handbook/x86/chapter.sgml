<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->


<chapter id="x86">
  <title>x86 Assembly Language Programming</title>

  <para>
    <emphasis>This chapter written by G. Adam Stanislav.  
    <ulink url="http://www.whizkidtech.net/">Whiz Kid Technomagic</ulink>
    Modifications for the Handbook made by &a.wylie;, &.logo;, 
    and &a.murray;</emphasis></para>

  <sect1>
    <title>Synopsis</title>
    <para>
      Assembly language programing under Unix is highly
      undocumented. It is generally assumed that no one would ever
      want to use it because various Unix systems run on different
      microprocessors, so everything should be written in C for
      portability.</para>

    <para>
      In reality, C portability is quite a myth. Even C programs need
      to be modified when ported from one Unix to another, regardless
      of what processor each runs on.  Typically, such a program is
      full of conditional statements depending on the system it is
      compiled for.</para>

    <para>
      Even if we believe that all of Unix software should be written
      in C, or some other high-level language, we still need assembly
      language programmers: Who else would write the section of C
      library that accesses the kernel?</para>

    <para>
      In this tutorial, which is quite brief at this time, I will
      attempt to show you how you can use assembly language writing
      Unix programs, specifically under FreeBSD. I hope to turn it
      into a complete course of FreeBSD assembly language
      eventually.</para>

    <para>
      This tutorial does not explain the basics of assembly
      language. There are enough resources about that (for a complete
      online course in assembly language, see Randall Hyde's <ulink
      url="http://webster.cs.ucr.edu/">Art of Assembly
      Language</ulink>; or if you prefer a printed book, take a look
      at Jeff Duntemann's Assembly Language Step-by-Step.  However,
      once the tutorial is finished, any assembly language programmer
      will be able to write programs for FreeBSD quickly and
      efficiently.</para>

    <para>
      Copyright &copy; 2000 G. Adam Stanislav.All rights reserved.</para>

  </sect1>
  <sect1>
    <title>The Tools</title>
        
    <sect2>
      <title>The Assembler</title>

      <para>
        The most important tool for assembly language programming is
        the assembler, the software that converts assembly language
        code into machine language.</para>

      <para>
        Two very different assemblers are available for FreeBSD. One
        is &man.as.1;, which uses the traditional Unix assembly
        language syntax. It comes with the system.</para>

      <para>
        The other is <filename>/usr/ports/devel/nasm</filename>. It
        uses the Intel syntax. Its main advantage is that it can
        assemble code for many operating systems. It needs to be
        installed separately, but is completely free.</para>

      <para>
        This tutorial uses <emphasis>nasm</emphasis> syntax because
        most assembly language programmers coming to FreeBSD from
        other operating systems will find it easier to
        understand. And, because, quite frankly, that is what I am
        used to.</para>

    </sect2>

    <sect2>
      <title>The Linker</title>

      <para>
        The output of the assembler, like that of any compiler, needs
        to be linked to form an executable file.</para>

      <para>
        The standard &man.ld.1; linker comes with FreeBSD. It works
        with the code assembled with either assembler.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>System Calls</title>

    <sect2>
      <title>Default Calling Convention</title>
    
      <para>
        By default, the FreeBSD kernel uses the C calling
        convention. Further, although the kernel is accessed using int
        80h, it is assumed the program will call a function that
        issues int 80h, rather than issuing int 80h directly.</para>

      <para>
        This convention is very convenient, and quite superior to the
        Microsoft convention used by MS DOS. Why? Because the Unix
        convention allows any program written in any language to
        access the kernel.</para>

      <para>
        An assembly language program can do that as well. For example,
        we could open a file:</para>

      <programlisting>
             kernel:
	             int	80h	; Call kernel
	             ret

             open:
	             push	dword mode
	             push	dword flags
	             push	dword path
	             mov	eax, 5
	             call	kernel
	             add	esp, byte 12
	             ret
      </programlisting>

      <para>
        This is a very clean and portable way of coding. If you need
        to port the code to a Unix system which uses a different
        interrupt, or a different way of passing parameters, all you
        need to change is the kernel procedure.</para>

      <para>
        But assembly language programmers like to shave off
        cycles. The above example requires a
        <filename>call/ret</filename> combination. We can eliminate it
        by pushing an extra dword:</para>

      <programlisting>
             open:
	             push	dword mode
	             push	dword flags
	             push	dword path
	             mov	eax, 5
	             push	eax		; Or any other dword
	             int	80h
	             add	esp, byte 16
      </programlisting>

      <para>
        The <emphasis>5</emphasis> that we have placed in
        <emphasis>EAX</emphasis> identifies the kernel function, in
        this case <emphasis>open</emphasis>.</para>

    </sect2>

    <sect2>
      <title>Alternate Calling Convention</title>
      <para>
        FreeBSD is an extremely flexible system. It offers other ways
        of calling the kernel. For it to work, however, the system
        must have Linux emulation installed.</para>

      <para>
        Linux is a Unix-like system. However, its kernel uses the
        Microsoft system-call convention of passing parameters in
        registers. As with the Unix convention, the function number is
        placed in <emphasis>EAX</emphasis>. The parameters, however,
        are not passed on the stack but <emphasis>EBX, ECX, EDX, ESI,
        EDI, EBP</emphasis>:</para>

      <programlisting>
             open:
	             mov	eax, 5
	             mov	ebx, path
	             mov	ecx, flags
	             mov	edx, mode
	             int	80h
      </programlisting>

      <para>
        This convention has a great disadvantage over the Unix way, at
        least as far as assembly language programming is concerned:
        Every time you make a kernel call you must
        <emphasis>push</emphasis> the registers, then
        <emphasis>pop</emphasis> them later.  This makes your code
        bulkier and slower. Nevertheless, FreeBSD gives you a
        choice.</para>

      <para>
        If you do choose the Microsoft/Linux convention, you must let
        the system know about it.  After your program is assembled and
        linked, you need to brand the executable:</para>

      <screen>&prompt.user; <userinput>brandelf -f Linux filename</userinput>
      </screen>

    </sect2>

    <sect2>
      <title>Which convention should you use?</title>
      <para>
        If you are coding specifically for FreeBSD, you should always
        use the Unix convention: It is faster, you can store global
        variables in registers, you do not have to brand the
        executable, and you do not impose the installation of the
        Linux emulation package on the target system.</para>

      <para>
        If you want to create portable code that can also run on
        Linux, you will probably still want to give the FreeBSD users
        as efficient a code as possible. I will show you how you can
        accomplish that after I have explained the basics.</para>

    </sect2>

    <sect2>
      <title>Call Numbers</title>

      <para>To tell the kernel which system service you are calling,
        place its number in <emphasis>EAX</emphasis>. Of course, you
        need to know what the number is.</para>

      <sect3>
        <title>The Syscalls File</title>

        <para>The numbers are listed in
          <filename>syscalls</filename>. <emphasis>locate
          syscalls</emphasis> finds this file in several different
          formats, all produced automatically from
          <filename>syscalls.master</filename>.</para>

        <para>You can find the master file for the default Unix
          calling convention in
          <filename>/usr/src/sys/kern/syscalls.master</filename>. If
          you need to use the Microsoft convention implemented in the
          Linux emulation mode, read
          <filename>/usr/src/sys/i386/linux/syscalls.master</filename>.</para>

        <para><emphasis>N.B.:</emphasis> Not only do FreeBSD and Linux
          use different calling conventions, they sometimes use
          different numbers for the same functions.</para>

        <para><filename>syscalls.master</filename> describes how the
          call is to be made:</para>

      <programlisting>             0	    STD	    NOHIDE	        { int nosys(void); } syscall nosys_args int
             1	    STD	    NOHIDE	        { void exit(int rval); } exit rexit_args void
             2	    STD	    POSIX	        { int fork(void); }
             3	    STD	    POSIX	        { ssize_t read(int fd, void *buf, size_t nbyte); }
             4	    STD	    POSIX	        { ssize_t write(int fd, const void *buf, size_t nbyte); }
             5	    STD	    POSIX	        { int open(char *path, int flags, int mode); }
             6	    STD	    POSIX	        { int close(int fd); }
             etc...</programlisting>

        <para>It is the leftmost column that tells us the number to
          place in <emphasis>EAX</emphasis>.</para>

        <para>The rightmost column tells us what parameters to
          <emphasis>push</emphasis>. They are
          <emphasis>push</emphasis>ed from right to left.</para>

        <para><emphasis>EXAMPLE 3.1:</emphasis> For example, to
          <emphasis>open</emphasis> a file, we need to
          <emphasis>push</emphasis> the <emphasis>mode</emphasis>
          first, then <emphasis>flags</emphasis>, then the address at
          which the <emphasis>path</emphasis> is stored.</para>

      </sect3>
    </sect2>

  </sect1>

  <sect1>
    <title>Return Values</title>
    <para>
      A system call would not be useful most of the time if it did not
      return some kind of a value: The file descriptor of an open
      file, the number of bytes read to a buffer, the system time,
      etc.</para>

    <para>
      Additionally, the system needs to inform us if an error occurs:
      A file does not exist, system resources are exhausted, we passed
      an invalid parameter, etc.</para>

    <sect2>
      <title>man-pages</title>
      <para>
        The traditional place to look for information about various
        system calls under Unix systems are the man pages.  FreeBSD
        describes its system calls in section 2, sometimes in section
        3.</para>

      <para>
        For example, <function>open(2)</function> says:</para>

      <para>
        If successful, <function>open()</function> returns a
        non-negative integer, termed a file descriptor. It returns
        <emphasis>-1</emphasis> on failure, and sets
        <emphasis>errno</emphasis> to indicate the error.</para>

      <para>
        The assembly language programmer new to Unix and FreeBSD will
        immediately ask the puzzling question: Where is
        <emphasis>errno</emphasis> and how do I get to it?</para>

      <para>
        <emphasis>N.B.:</emphasis> The information presented in the
        man pages applies to C programs. The assembly language
        programmer needs additional information.</para>

    </sect2>

    <sect2>
      <title>Where are the return values?</title>
      <para>
        Unfortunately, it depends... For most system calls it is in
        <emphasis>EAX</emphasis>, but not for all.  A good rule of
        thumb, when working with a system call for the first time,
        look for the return value in <emphasis>EAX</emphasis>. If it
        is not there, you need further research.</para>

      <para>
        <emphasis>N.B.:</emphasis> I am aware of one system call that
        returns the value in <emphasis>EDX</emphasis>:
        <emphasis>SYS_fork</emphasis>. All others I have worked with
        use <emphasis>EAX</emphasis>. But I have not worked with them
        all yet.</para>

      <para>
        <emphasis>TIP</emphasis>: If you cannot find the answer here
        or anywhere else, study libc source code and see how it
        interfaces with the kernel.</para>

    </sect2>

    <sect2>
      <title>Where is <function>errno</function>>?</title>
      <para>Actually, nowhere...</para>

      <para>
        <function>errno</function> is part of the C language, not the
        Unix kernel. When accessing kernel services directly, the
        error code is returned in <emphasis>EAX</emphasis>, the same
        register the proper return value generally ends up in.</para>

      <para>
        This makes perfect sense. If there is no error, there is no
        error code. If there is an error, there is no return
        value. One register can contain either.</para>

    </sect2>

    <sect2>
      <title>Determining an Error Occurred</title>
      <para>
        When using the standard FreeBSD calling convention, the
        <emphasis>carry flag</emphasis> is cleared upon success, set
        upon failure.</para>

      <para>
        When using the Linux emulation mode, the signed value in
        <emphasis>EAX</emphasis> is non-negative upon success, and
        contains the return value. In case of an error, the value is
        negative, i.e., <emphasis>-errno</emphasis>.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Creating Portable Code</title>
    <para>
      Portability is generally not one of the strengths of assembly
      language. Yet, writing assembly language programs for different
      platforms is possible, especially with
      <emphasis>nasm</emphasis>. I have written assembly language
      libraries that can be assembled for such different operating
      systems as Windows and FreeBSD.</para>

    <para>
      It is all the more possible when you want your code to run on
      two platforms which, while different, are based on similar
      architectures.</para>

    <para>
      For example, FreeBSD is Unix, Linux is Unix-like. I only
      mentioned three differences between them (from an assembly
      language programmerâs perspective): The calling convention, the
      function numbers, and the way of returning values.</para>

    <sect2>
      <title>Dealing With Function Numbers</title>
      <para>
        In many cases the function numbers are the same. However, even
        when they are not, the problem is easy to deal with: Instead
        of using numbers in your code, use constants which you have
        declared differently depending on the target
        architecture:</para>

      <programlisting>
             %ifdef	LINUX
             %define	SYS_execve	11
             %else
             %define	SYS_execve	59
             %endif
      </programlisting>

    </sect2>
    <sect2>
      <title>Dealing With Conventions</title>
      <para>
        Both, the calling convention, and the return value (the
        <emphasis>errno</emphasis> problem) can be resolved with
        macros:</para>

      <programlisting>

                %ifdef	LINUX

                %macro	system	0
                	call	kernel
                %endmacro

                align 4
                kernel:
                	push	ebx
                	push	ecx
                	push	edx
                	push	esi
                	push	edi
                	push	ebp

                	mov	ebx, [esp+32]
                	mov	ecx, [esp+36]
                	mov	edx, [esp+40]
                	mov	esi, [esp+44]
                	mov	ebp, [esp+48]
                	int	80h

                	pop	ebp
                	pop	edi
                	pop	esi
                	pop	edx
                	pop	ecx
                	pop	ebx

                	or	eax, eax
                	js	.errno
                	clc
                	ret

                .errno:
                	neg	eax
                	stc
                	ret

                %else

                %macro	system	0
                	int	80h
                %endmacro

                %endif
      </programlisting>

    </sect2>

    <sect2>
      <title>Dealing With Other Portability Issues</title>
      <para>
        The above solutions can handle most cases of writing code
        portable between FreeBSD and Linux.  Nevertheless, with some
        kernel services the differences are deeper.</para>

      <para>
        In that case, you need to write two different handlers for
        those particular system calls, and use conditional
        assembly. Luckily, most of your code does something other than
        calling the kernel, so usually you will only need a few such
        conditional sections in your code.</para>

    </sect2>

    <sect2>
      <title>Using a Portable Library</title>
      <para>
        You can avoid portability issues in your main code altogether
        by writing a library of system calls.  Create a separate
        library for FreeBSD, a different one for Linux, and yet other
        libraries for more operating systems.</para>

      <para>
        In your library, write a separate function (or procedure, if
        you prefer the traditional assembly language terminology) for
        each system call. Use the C calling convention of passing
        parameters.  But still use <emphasis>EAX</emphasis> to pass
        the call number in. In that case, your FreeBSD library can be
        very simple, as many seemingly different functions can be just
        labels to the same code:</para>

      <programlisting>
                sys.open:
                sys.close:
                [etc...]
                	int	80h
                	ret
      </programlisting>

      <para>
        Your Linux library will require more different functions. But
        even here you can group system calls using the same number of
        parameters:</para>

      <programlisting>
                sys.exit:
                sys.close:
                [etc... one-parameter functions]
                	push	ebx
                	mov	ebx, [esp+12]
                	int	80h
                	pop	ebx
                	jmp	sys.return

                ...

                sys.return:
                	or	eax, eax
                	js	sys.err
                	clc
                	ret

                sys.err:
                	neg	eax
                	stc
                	ret
      </programlisting>

      <para>
        The library approach may seem inconvenient at first because it
        requires you to produce a separate file your code depends
        on. But it has many advantages: For one, you only need to
        write it once and can use it for all your programs. You can
        even let other assembly language programmers use it, or
        perhaps use one written by someone else. But perhaps the
        greatest advantage of the library is that your code can be
        ported to other systems, even by other programmers, by simply
        writing a new library without any changes to your code.</para>

      <para>
        If you do not like the idea of having a library, you can at
        least place all your system calls in a separate assembly
        language file and link it with your main program. Here, again,
        all porters have to do is create a new object file to link
        with your main program.</para>

    </sect2>

    <sect2>
      <title>Using a Portable Include File</title>
      <para>
        If you are releasing your software as (or with) source code,
        you can use macros and place them in a separate file, which
        you include in your code.</para>

      <para>
        Porters of your software will simply write a new include
        file. No library or external object file is necessary, yet
        your code is portable without any need to edit the
        code.</para>

      <para>
        <emphasis>N.B.:</emphasis> This is the approach we will use
        throughout this tutorial. We will name our include file
        <emphasis>system.inc</emphasis>, and add to it whenever we
        deal with a new system call.</para>

      <para>
        We can start our <filename>system.inc</filename> by declaring
        the standard file descriptors:</para>

      <programlisting>
               %define	   stdin	0
               %define	   stdout	1
               %define	   stderr	2
      </programlisting>

      <para>
        Next, we create a symbolic name for each system call:</para>

      <programlisting>
                %define         SYS_nosys	0
                %define         SYS_exit	1
                %define         SYS_fork	2
                %define         SYS_read	3
                %define         SYS_write	4
                ; [etc...]
      </programlisting>

      <para>
        We add a short, non-global procedure with a long name, so we
        do not accidentally reuse the name in our code:</para>

      <programlisting>
               section	.code
               align 4
               access.the.bsd.kernel:
               	    int	    80h
               	    ret
      </programlisting>

      <para>
        We create a macro which takes one argument, the syscall
        number:</para>

      <programlisting>
                %macro	system	1
                	mov	eax, %1
                	call	access.the.bsd.kernel
                %endmacro
      </programlisting>

      <para>
        Finally, we create macros for each syscall. These macros take
        no arguments.</para>

      <programlisting>
                %macro	sys.exit	0
                	system	SYS_exit
                %endmacro

                %macro	sys.fork	0
                	system	        SYS_fork
                %endmacro

                %macro	sys.read	0
                	system  	SYS_read
                %endmacro

                %macro	sys.write	0
                	system	SYS_write
                %endmacro

                ; [etc...]
      </programlisting>

      <para>
        Go ahead, enter it into your editor and save it as
        <filename>system.inc</filename>. We will add more to it as we
        discuss more syscalls.</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Our First Program</title>
    <para>
      We are now ready for our first program, the mandatory
      <emphasis>Hello, World!</emphasis></para>

    <programlisting>
             1: 	%include	'system.inc'
             2:
             3: 	section	.data
             4: 	hello	db	'Hello, World!', 0Ah
             5: 	hbytes	equ	$-hello
             6:
             7: 	section	.code
             8: 	global	_start
             9: 	_start:
            10: 	push	dword hbytes
            11: 	push	dword hello
            12: 	push	dword stdout
            13: 	sys.write
            14:
            15: 	push	dword 0
            16: 	sys.exit
    </programlisting>

    <para>
      Here is what it does: Line 1 includes the defines, the macros,
      and the code from <filename>system.inc</filename>.</para>

    <para>
      Lines 3-5 are the data: Line 3 starts the data
      section/segment. Line 4 contains the string "Hello, World!"
      followed by a new line (0Ah). Line 5 creates a constant that
      contains the length of the string from line 4 in bytes.</para>

    <para>
      Lines 7-16 contain the code. Note that FreeBSD uses the elf file
      format for its executables, which requires every program to
      start at the point labeled _start (or, more precisely, the
      linker expects that). This label has to be global.</para>

    <para>
      Lines 10-13 ask the system to write <emphasis>hbytes</emphasis>
      bytes of the <emphasis>hello</emphasis> string to
      <function>stdout</function>.</para>

    <para>
      Lines 15-16 ask the system to end the program with the return
      value of <emphasis>0</emphasis>. The
      <function>SYS_exit</function> syscall never returns, so the code
      ends there.</para>

    <para>
      <emphasis>N.B.:</emphasis> If you have come to Unix from MS DOS
      assembly language background, you may be used to writing
      directly to the video hardware. You will never have to worry
      about this in FreeBSD, or any other flavor of Unix. As far as
      you are concerned, you are writing to a file known as
      <filename>stdout</filename>. This can be the video screen, or a
      Telnet terminal, or an actual file, or even the input of another
      program. Which it is, is for the system to figure out.</para>

    <sect2>
      <title>Assembling the Code</title>

      <para>Type the code (except the line numbers) in an editor, and
        save it in a file named <filename>hello.asm</filename>. You
        need <emphasis>nasm</emphasis> to assemble it.</para>

      <sect3>
        <title>Installing NASM</title>

        <para>If you do not have <emphasis>nasm</emphasis>, type:</para>

	<screen>&prompt.user; <userinput>su</userinput>              
Password: <userinput>your root password</userinput>
&prompt.root; <userinput>cd /usr/ports/devel/nasm</userinput>
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>exit</userinput>
&prompt.user;</screen> 

        <screen>&prompt.user; <userinput>su</userinput>
Password: <userinput>your root password</userinput>
&prompt.root; <userinput>cd /usr/ports/devel/nasm</userinput>
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>exit</userinput>
&prompt.user;</screen>                                  

        <para>You may type <emphasis>make install clean</emphasis>
	  instead of just <emphasis>make install</emphasis> if you do
	  not want to keep <emphasis>nasm</emphasis> source
	  code.</para>

        <para>Either way, FreeBSD will automatically download
	  <emphasis>nasm</emphasis> from the Internet, compile it, and
	  install it on your system.</para>

        <para><emphasis>N.B.:</emphasis> If your system is not
	  FreeBSD, you need to get <emphasis>nasm</emphasis> from its
	  <ulink url="http://www.web-sites.co.uk/nasm/">home
	  page</ulink>. You can still use it to assemble FreeBSD
	  code.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Assemble, link and run</title>

      <para>Now you can assemble, link, and run the code:</para>

      <screen>&prompt.user; <userinput>nasm -f elf hello.asm</userinput>
&prompt.user; <userinput>ld -s -o hello hello.o</userinput>
&prompt.user; <userinput>./hello</userinput>
Hello, World!
&prompt.user; </screen>
    </sect2>

  </sect1>

  <sect1>
    <title>Writing Unix Filters</title>
  
    <para>A common type of Unix application is a filterâa program that
      reads data from the <emphasis>stdin</emphasis>, processes it
      somehow, then writes the result to
      <emphasis>stdout</emphasis>.</para>

    <para>In this chapter, we shall develop a simple filter, and learn
      how to read from <emphasis>stdin</emphasis> and write to
      <emphasis>stdout</emphasis>. This filter will convert each byte
      of its input into a hexadecimal number followed by a blank
      space.</para>

    <programlisting>                %include 'system.inc'

	        section	.data
	        hex  	db	'0123456789ABCDEF'
	        buffer	db	0, 0, ' '

	        section	.code
	        global	_start
	        _start:
	        ; read a byte from stdin
	        push	dword 1
	        push	dword buffer
	        push	dword stdin
	        sys.read
	        add	esp, byte 12
	        or	eax, eax
	        je	.done

         	; convert it to hex
        	movzx	eax, byte [buffer]
        	mov	edx, eax
        	shr	dl, 4
        	mov	dl, [hex+edx]
        	mov	[buffer], dl
        	and	al, 0Fh
        	mov	al, [hex+eax]
        	mov	[buffer+1], al                                                                
        
        	; print it
        	push	dword 3
        	push	dword buffer
        	push	dword stdout
        	sys.write
        	add	esp, byte 12
        	jmp	short _start                
        
                .done        :
	        push        	dword 0
	        sys.exit</programlisting>

    <para>In the data section we create an array called
      <emphasis>hex</emphasis>. It contains the 16 hexadecimal digits
      in ascending order. The array is followed by a buffer which we
      will use for both input and output. The first two bytes of the
      buffer are initially set to <emphasis>0</emphasis>. This is
      where we will write the two hexadecimal digits (the first byte
      also is where we will read the input). The third byte is a
      space.</para>

    <para>The code section consists of four parts: Reading the byte,
      converting it to a hexadecimal number, writing the result, and
      eventually exiting the program.</para>

    <para>To read the byte, we ask the system to read one byte from
      <emphasis>stdin</emphasis>, and store it in the first byte of
      the <emphasis>buffer</emphasis>. The system returns the number
      of bytes read in <emphasis>EAX</emphasis>. This will be
      <emphasis>1</emphasis> while data is coming, or
      <emphasis>0</emphasis>, when no more input data is
      available. Therefore, we check the value of
      <emphasis>EAX</emphasis>. If it is <emphasis>0</emphasis>, we
      jump to <emphasis>.done</emphasis>, otherwise we
      continue.</para>

    <para><emphasis>N.B.:</emphasis> For simplicity sake, we are
      ignoring the possibility of an error condition at this
      time.</para>

    <para>The hexadecimal conversion reads the byte from the
      <emphasis>buffer</emphasis> into <emphasis>EAX</emphasis>, or
      actually just <emphasis>AL</emphasis>, while clearing the
      remaining bits of <emphasis>EAX</emphasis> to zeros. We also
      copy the byte to <emphasis>EDX</emphasis> because we need to
      convert the upper four bits (nibble) separately from the lower
      four bits. We store the result in the first two bytes of the
      buffer.</para>

    <para>Next, we ask the system to write the three bytes of the
      buffer, i.e., the two hexadecimal digits and the blank space, to
      <emphasis>stdout</emphasis>. We then jump back to the beginning
      of the program and process the next byte.</para>

    <para>Once there is no more input left, we ask the system to exit
      our program, returning a zero, which is the traditional value
      meaning the program was successful.</para>

    <para>Go ahead, and save the code in a file named
      <filename>hex.asm</filename>, then type the following (the
      <emphasis>^D</emphasis> means press the control key and type
      <emphasis>D</emphasis> while holding the control key
      down):</para>

    <screen>&prompt.user; <userinput>nasm -f elf hex.asm</userinput> 
&prompt.user; <userinput>ld -s -o hex hex.o</userinput> 
&prompt.user; <userinput>./hex</userinput>
Hello, World! 
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A 
Here I come! 
48 65 72 65 20 49 20 63 6F 6D 65 21 0A 
<userinput>^D</userinput> 
&prompt.user;</screen>

    <para><emphasis>N.B.:</emphasis> If you are migrating to Unix from
      MS DOS, you may be wondering why each line ends with
      <emphasis>0A</emphasis> instead of <emphasis>0D
      0A</emphasis>. This is because Unix does not use the cr/lf
      convention, but a ânew lineâ convention, which is
      <emphasis>0A</emphasis> in hexadecimal.</para>

    <para>Can we improve this? Well, for one, it is a bit confusing
      because once we have converted a line of text, our input no
      longer starts at the begining of the line. We can modify it to
      print a new line instead of a space after each
      <emphasis>0A</emphasis>:</para>

    <programlisting>%include	'system.inc'

section	.data
hex	db	'0123456789ABCDEF'
buffer	db	0, 0, ' '

section	.code
global	_start
_start:
	mov	cl, ' '

.loop:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	[buffer+2], cl
	cmp	al, 0Ah
	jne	.hex
	mov	[buffer+2], al

.hex:
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short .loop

.done:
	push	dword 0
	sys.exit</programlisting>

    <para>We have stored the space in the <emphasis>CL</emphasis>
      register. We can do this safely because, unlike Microsoft
      Windows, Unix system calls do not modify the value of any
      register they do not use to return a value in.</para>

    <para>That means we only need to set <emphasis>CL</emphasis>
      once. We have, therefore, added a new label
      <emphasis>.loop</emphasis> and jump to it for the next byte
      instead of jumping at <emphasis>_start</emphasis>. We have also
      added the <emphasis>.hex</emphasis> label so we can either have
      a blank space or a new line as the third byte of the
      <emphasis>buffer</emphasis>.</para>

    <para>Once you have changed <emphasis>hex.asm</emphasis> to
      reflect these changes, type:</para>

    <screen>&prompt.user <userinput>nasm -f elf hex.asm</userinput>
&prompt.user <userinput>ld -s -o hex hex.o</userinput>
&prompt.user <userinput>./hex</userinput>
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
<userinput>^D</userinput> 
&prompt.user;</screen>

    <para>That looks better. But this code is quite inefficient! We
      are making a system call for every single byte twice (once to
      read it, another time to write the output).</para>

  </sect1>

  <sect1>
    <title>Buffered Input and Output</title>
  
    <para>We can improve the efficiency of our code by buffering our
      input and output. We create an input buffer and read a whole
      sequence of bytes at one time. Then we fetch them one by one
      from the buffer.</para>

    <para>We also create an output buffer. We store our output in it
      until it is full. At that time we ask the kernel to write the
      contents of the buffer to <emphasis>stdout</emphasis>.</para>

    <para>The program ends when there is no more input. But we still
      need to ask the kernel to write the contents of our output
      buffer to <emphasis>stdout</emphasis> one last time, otherwise
      some of our output would make it to the output buffer, but never
      be sent out. Do not forget that, or you will be wondering why
      some of your output is missing.</para>

    <programlisting>%include	'system.inc'

%define	BUFSIZE	2048

section	.data
hex	db	'0123456789ABCDEF'

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.code
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, ' '
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</programlisting>

    <para>We now have a third section in the source code, named
      <emphasis>.bss</emphasis>. This section is not included in our
      executable file, and, therefore, cannot be initialized. We use
      <emphasis>resb</emphasis> instead of <emphasis>db</emphasis>. It
      simply reserves the requested size of uninitialized memory for
      our use.</para>

    <para>We take advantage of the fact that the system does not
      modify the registers: We use registers for what, otherwise,
      would have to be global variables stored in the
      <emphasis>.data</emphasis> section. This is also why the Unix
      convention of passing parameters to system calls on the stack is
      superior to the Microsoft convention of passing them in the
      registers: We can keep the registers for our own use.</para>

    <para>We use <emphasis>EDI</emphasis> and <emphasis>ESI</emphasis>
      as pointers to the next byte to be read from or written to. We
      use <emphasis>EBX</emphasis> and <emphasis>ECX</emphasis> to
      keep count of the number of bytes in the two buffers, so we know
      when to dump the output to, or read more input from, the
      system.</para>

    <para>Let us see how it works now:</para>

    <screen>&prompt.user; <userinput>nasm -f elf hex.asm</userinput>
&prompt.user; <userinput>ld -s -o hex hex.o</userinput>
&prompt.user; <userinput>./hex</userinput>
Hello, World!
Here I come!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
<userinput>^D</userinput> 
&prompt.user;</screen>

    <para>Not what you expected? The program did not print the output
      until we pressed <emphasis>^D</emphasis>. That is easy to fix by
      inserting three lines of code to write the output every time we
      have converted a new line to <emphasis>0A</emphasis>. I have
      marked the three lines with &gt; (do not copy the &gt; in your
      <filename>hex.asm</filename></para>

    <programlisting>%include	'system.inc'

%define	BUFSIZE	2048

section	.data
hex	db	'0123456789ABCDEF'

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.code
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, ' '
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
>	cmp	al, 0Ah
>	jne	.loop
>	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</programlisting>

    <para>Now, let us see how it works:</para>

    <screen>&prompt.user; <userinput>nasm -f elf hex.asm</userinput>
&prompt.user; <userinput>ld -s -o hex hex.o</userinput>
&prompt.user; <userinput>./hex</userinput>
Hello, World!
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
Here I come!
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
<userinput>^D</userinput> 
&prompt.user;</screen>

    <para>Not bad for a 644-byte executable, is it!</para>

    <sect2>
      <title>How to Unread a Character</title>
      <para>
	<emphasis>WARNING:</emphasis> This may be a somewhat advanced
	topic, mostly of interest to programmers familiar with the
	theory of compilers. If you wish, you may <ulink
	url="#command-line">skip to the next chapter</ulink>, and
	perhaps read this later.</para>

      <para>While our sample program does not require it, more
	sophisticated filters often need to look ahead. In other
	words, they may need to see what the next character is (or
	even several characters). If the next character is of a
	certain value, it is part of the token currently being
	processed. Otherwise, it is not.</para>

      <para>For example, you may be parsing the input stream for a
	textual string (e.g., when implementing a language compiler):
	If a character is followed by another character, or perhaps a
	digit, it is part of the token you are processing. If it is
	followed by white space, or some other value, then it is not
	part of the current token.</para>

      <para>This presents an interesting problem: How to return the
	next character back to the input stream, so it can be read
	again later?</para>

      <para>One possible solution is to store it in a character
	variable, then set a flag. We can modify
	<function>getchar</function> to check the flag, and if it is
	set, fetch the byte from that variable instead of the input
	buffer, and reset the flag. But, of course, that slows us
	down.</para>

      <para>The C language has an <function>ungetc()</function>
	function, just for that purpose. Is there a quick way to
	implement it in our code? I would like you to scroll back up
	and take a look at the <function>getchar</function> procedure
	and see if you can find a nice and fast solution before
	reading the next paragraph. Then come back here and see my own
	solution.</para>

      <para>The key to returning a character back to the stream is in
	how we are getting the characters to start with:</para>

      <para>First we check if the buffer is empty by testing the value
        of <emphasis>EBX</emphasis>. If it is zero, we call the
        <emphasis>read</emphasis> procedure.</para>

      <para>If we do have a character available, we use
	<emphasis>lodsb</emphasis>, then decrease the value of
	<emphasis>EBX</emphasis>. The <emphasis>lodsb</emphasis>
	instruction is effectively identical to:</para>

      <programlisting>	mov	al, [esi]
	inc	esi</programlisting>

      <para>The byte we have fetched remains in the buffer until the
	next time <function>read</function> is called. We do not know
	when that happens, but we do know it will not happen until the
	next call to <function>getchar</function>. Hence, to âreturnâ
	the last-read byte back to the stream, all we have to do is
	decrease the value of <emphasis>ESI</emphasis> and increase
	the value of <emphasis>EBX</emphasis>:</para>

      <programlisting>ungetc:
	dec	esi
	inc	ebx
	ret</programlisting>

      <para>But, be careful! We are perfectly safe doing this if our
	look-ahead is at most one character at a time. If we are
	examining more than one upcoming character and call
	<function>ungetc</function> several times in a row, it will
	work most of the time, but not all the time (and will be tough
	to debug). Why?</para>

      <para>Because as long as <function>getchar</function> does not
	have to call <function>read</function> all of the pre-read
	bytes are still in the buffer, and our
	<function>ungetc</function> works without a glitch. But the
	moment <function>getchar</function> calls
	<function>read</function>, the contents of the buffer
	change.</para>

      <para>We can always rely on <function>ungetc</function> working
	properly on the last character we have read with
	<function>getchar</function>, but not on anything we have read
	before that.</para>

      <para>If your program reads more than one byte ahead, you have
	at least two choices:</para>

      <para>If possible, modify the program so it only reads one byte
        ahead. This is the simplest solution.</para>

      <para>If that option is not available, first of all determine
        the maximum number of characters your program needs to return
        to the input stream at one time. Increase that number
        slightly, just to be sure, preferably to a multiple of 16âso
        it aligns nicely. Then modify the <emphasis>.bss</emphasis>
        section of your code, and create a small âspareâ buffer right
        before your input buffer, something like this:</para>

      <programlisting>section	.bss
	resb	16	; or whatever the value you came up with
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE</programlisting>

      <para>You also need to modify your <function>ungetc</function>
        to pass the value of the byte to unget in
        <emphasis>AL</emphasis>:</para>

      <programlisting>ungetc:
	dec	esi
	inc	ebx
	mov	[esi], al
	ret</programlisting>

      <para>With this modification, you can call
        <function>ungetc</function> up to 17 times in a row safely
        (the first call will still be within the buffer, the remaining
        16 may be either within the buffer or within the
        âspareâ).</para>

    </sect2>
  </sect1>

  <sect1>
    <title>Command-line Arguments</title>

    <para>Our <emphasis>hex</emphasis> program will be more useful if
      it can read the names of an input and output file from its
      command line, i.e., if it can process the command line
      arguments. But... Where are they?</para>

    <para>Before a Unix system starts a program, it pushes some data
      on the stack, then jumps at the <emphasis>_start</emphasis>
      label of the program. Yes, I said jumps, not calls. That means
      the data can be accessed by reading
      <emphasis>[esp+offset]</emphasis>, or by simply
      <emphasis>pop</emphasis>ping it.</para>

    <para>The value at the top of the stack contains the number of
      command line arguments. It is traditionally called
      <emphasis>argc</emphasis>, for âargument count.â</para>

    <para>Command line arguments follow next, all
      <emphasis>argc</emphasis> of them. These are typically referred
      to as <emphasis>argv</emphasis>, for âargument value(s).â That
      is, we get <emphasis>argv[0]</emphasis>,
      <emphasis>argv[1]</emphasis>, <emphasis>...</emphasis>,
      <emphasis>argv[argc-1]</emphasis>. These are not the actual
      arguments, but pointers to arguments, i.e., memory addresses of
      the actual arguments. The arguments themselves are
      NUL-terminated character strings.</para>

    <para>The <emphasis>argv</emphasis> list is followed by a
      <emphasis>NULL</emphasis> pointer, which is simply a
      <emphasis>0</emphasis>. There is more, but this is enough for
      our purposes right now.</para>

    <para><emphasis>N.B.:</emphasis> If you have come from the MS DOS
      programming environment, the main difference is that each
      argument is in a separate string. The second difference is that
      there is no practical limit on how many arguments there can
      be.</para>

    <para>Armed with this knowledge, we are almost ready for the next
      version of <filename>hex.asm</filename>. First, however, we need
      to add a few lines to <filename>system.inc</filename>:</para>

    <para>First, we need to add two new entries to our list of system
      call numbers:</para>

    <programlisting>%define	SYS_open	5
%define	SYS_close	6</programlisting> 

    <para>Then we add two new macros at the end of the file:</para>

    <programlisting>%macro	sys.open	0
	system	SYS_open
%endmacro

%macro	sys.close	0
	system	SYS_close
%endmacro</programlisting> 

    <para>Here, then, is our modified source code:</para>

    <programlisting>%include	'system.inc'

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
hex	db	'0123456789ABCDEF'

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.code
align 4
err:
	push	dword 1		; return failure
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to input file
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	err		; open failed

	add	esp, byte 8
	mov	[fd.in], eax

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to output file
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	err

	add	esp, byte 12
	mov	[fd.out], eax

.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from input file or stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, ' '
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	cmp	al, dl
	jne	.loop
	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</programlisting>

    <para>In our <emphasis>.data</emphasis> section we now have two
      new variables, <emphasis>fd.in</emphasis> and
      <emphasis>fd.out</emphasis>. We store the input and output file
      descriptors here.</para>

    <para>In the <emphasis>.code</emphasis> section we have replaced
      the references to <emphasis>stdin</emphasis> and
      <emphasis>stdout</emphasis> with <emphasis>[fd.in]</emphasis>
      and <emphasis>[fd.out]</emphasis>.</para>

    <para>The <emphasis>.code</emphasis> section now starts with a
      simple error handler, which does nothing but exit the program
      with a return value of <emphasis>1</emphasis>. The error handler
      is before <emphasis>_start</emphasis> so we are within a short
      distance from where the errors occur.</para>

    <para>Naturally, the program execution still begins at
      <emphasis>_start</emphasis>. First, we remove
      <emphasis>argc</emphasis> and <emphasis>argv[0]</emphasis> from
      the stack: They are of no interest to us (in this program, that
      is).</para>

    <para>We pop <emphasis>argv[1]</emphasis> to
      <emphasis>ECX</emphasis>. This register is particularly suited
      for pointers, as we can handle <emphasis>NULL</emphasis>
      pointers with <emphasis>jecxz</emphasis>. If
      <emphasis>argv[1]</emphasis> is not <emphasis>NULL</emphasis>,
      we try to open the file named in the first argument. Otherwise,
      we continue the program as before: Reading from
      <emphasis>stdin</emphasis>, writing to
      <emphasis>stdout</emphasis>. If we fail to open the input file
      (e.g., it does not exist), we jump to the error handler and
      quit.</para>

    <para>If all went well, we now check for the second argument. If
      it is there, we open the output file. Otherwise, we send the
      output to <emphasis>stdout</emphasis>. If we fail to open the
      output file (e.g., it exists and we do not have the write
      permission), we, again, jump to the error handler.</para>

    <para>The rest of the code is the same as before, except we close
      the input and output files before exiting, and, as mentioned, we
      use <emphasis>[fd.in]</emphasis> and
      <emphasis>[fd.out]</emphasis>.</para>

    <para>Our executable is now a whopping 768 bytes long.</para>

    <para>Can we still improve it? Of course! Every program can be
      improved. Here are a few ideas of what we could do:</para>

    <itemizedlist>
      <listitem><para>Have our error handler print a message to
      <emphasis>stderr</emphasis>. </para></listitem>

      <listitem><para>Add error handlers to the
      <function>read</function> and <function>write</function>
      functions.</para></listitem>

      <listitem><para>Close <emphasis>stdin</emphasis> when we open an
      input file, <emphasis>stdout</emphasis> when we open an output
      file.</para></listitem>

      <listitem><para>Add command line switches, such as
      <emphasis>-i</emphasis> and <emphasis>-o</emphasis>, so we can
      list the input and output files in any order, or perhaps read
      from <emphasis>stdin</emphasis> and write to a
      file.</para></listitem>

      <listitem><para>Print a usage message if command line arguments
      are incorrect.</para></listitem>

    </itemizedlist>

    <para>I shall leave these enhancements as an exercise to the
    reader: You already know everything you need to know to implement
    them.</para>

  </sect1>
  <sect1>
    <title>Unix Environment</title>
	
    <para>
      An important Unix concept is the environment, which is defined
      by <emphasis>environment variables</emphasis>. Some are set by
      the system, others by you, yet others by the
      <emphasis>shell</emphasis>, or any program that loads another
      program.</para>

    <sect2>
      <title>How to Find Environment Variables</title>
      <para>
	I said earlier that when a program starts executing, the stack
	contains <emphasis>argc</emphasis> followed by the
	<emphasis>NULL</emphasis>-terminated <emphasis>argv</emphasis>
	array, followed by something else. The âsomething elseâ is the
	<emphasis>environment</emphasis>, or, to be more precise, a
	<emphasis>NULL</emphasis>-terminated array of pointers to
	<emphasis>environment variables</emphasis>. This is often
	referred to as <emphasis>env</emphasis>.</para>

      <para>
	The structure of <emphasis>env</emphasis> is the same as that
	of <emphasis>argv</emphasis>, a list of memory addresses
	followed by a <emphasis>NULL</emphasis>
	(<emphasis>0</emphasis>). In this case, there is no
	<emphasis>âenvcâ</emphasis>âwe figure out where the array ends
	by searching for the final <emphasis>NULL</emphasis>.</para>

      <para>
	The variables usually come in the
	<emphasis>name=value</emphasis> format, but sometimes the
	=value part may be missing. We need to account for that
	possibility.</para>

    </sect2>
    <sect2>
      <title>Webvar</title>
     
      <para>
	I could just show you some code that prints the environment
	the same way the Unix <emphasis>env</emphasis> command
	does. But I thought it would be more interesting to write a
	simple assembly language CGI utility.</para>

      <sect3>
	<title>CGI: A Quick Overview</title>

	<para><emphasis>10.2.1. CGI: A Quick Overview</emphasis></para>

	<para>
	  I have a <ulink
	  url="http://www.whizkidtech.net/cgi-bin/tutorial">detailed
	  CGI tutorial</ulink> on my web site, but here is a very
	  quick overview of CGI:</para>

	<itemizedlist>
	         
          <listitem><para>The web server communicates with the CGI
          program by setting <emphasis>environment
          variables</emphasis>.</para></listitem>
	         
          <listitem><para>The CGI program sends its output to
          <emphasis>stdout</emphasis>. The web server reads it from
          there.</para></listitem>

          <listitem><para>It must start with an HTTP header followed
          by two blank lines.</para></listitem>

          <listitem><para>It then prints the HTML code, or whatever
          other type of data it is producing.</para></listitem>

        </itemizedlist>

        <para>
         <emphasis>N.B.:</emphasis> While certain
         <emphasis>environment variables</emphasis> use standard
         names, others vary, depending on the web server. That makes
         <emphasis>webvars</emphasis> quite a useful diagnostic
         tool.</para>

      </sect3>
    </sect2>
    <sect2>
      <title>Webvar continued...</title>

      <para>
        Our <emphasis>webvar</emphasis> program, then, must send out
        the HTTP header followed by some HTML mark-up. It then must
        read the <emphasis>environment variable</emphasis> one by one
        and send them out as part of the HTML page.</para>

      <para>
        The code follows. I placed comments and explanations right
        inside the code:</para>

      <programlisting>
;;;;;;; webvars.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2000 G. Adam Stanislav
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
; SUCH DAMAGE.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Version 1.0
;
; Started:	 8-Dec-2000
; Updated:	 8-Dec-2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	'system.inc'

section	.data
http	db	'Content-type: text/html', 0Ah, 0Ah
	db	'&lt;?xml version="1.0" encoding="UTF-8"?&gt;', 0Ah
	db	'&lt;!DOCTYPE html PUBLIC "-//W3C/DTD XHTML Strict//EN" '
	db	'"DTD/xhtml1-strict.dtd"&gt;', 0Ah
	db	'&lt;html xmlns="http://www.w3.org/1999/xhtml" '
	db	'xml.lang="en" lang="en"&gt;', 0Ah
	db	'&lt;head&gt;', 0Ah
	db	'&lt;title&gt;Web Environment&lt;/title&gt;', 0Ah
	db	'&lt;meta name="author" content="G. Adam Stanislav" /&gt;', 0Ah
	db	'&lt;/head&gt;', 0Ah, 0Ah
	db	'&lt;body bgcolor="#ffffff" text="#000000" link="#0000ff" '
	db	'vlink="#840084" alink="#0000ff"&gt;', 0Ah
	db	'&lt;div class="webvars"&gt;', 0Ah
	db	'&lt;h1&gt;Web Environment&lt;/h1&gt;', 0Ah
	db	'&lt;p&gt;The following &lt;b&gt;environment variables&lt;/b&gt; are defined '
	db	'on this web server:&lt;/p&gt;', 0Ah, 0Ah
	db	'&lt;table align="center" width="80" border="0" cellpadding="10" '
	db	'cellspacing="0" class="webvars"&gt;', 0Ah
httplen	equ	$-http
left	db	'&lt;tr&gt;', 0Ah
	db	'&lt;td class="name"&gt;&lt;tt&gt;'
leftlen	equ	$-left
middle	db	'&lt;/tt&gt;&lt;/td&gt;', 0Ah
	db	'&lt;td class="value"&gt;&lt;tt&gt;&lt;b&gt;'
midlen	equ	$-middle
undef	db	'&lt;i&gt;(undefined)&lt;/i&gt;'
undeflen	equ	$-undef
right	db	'&lt;/b&gt;&lt;/tt&gt;&lt;/td&gt;', 0Ah
	db	'&lt;/tr&gt;', 0Ah
rightlen	equ	$-right
wrap	db	'&lt;/table&gt;', 0Ah
	db	'&lt;/div&gt;', 0Ah
	db	'&lt;/body&gt;', 0Ah
	db	'&lt;/html&gt;', 0Ah, 0Ah
wraplen	equ	$-wrap

section	.code
global	_start
_start:
	; First, send out all the http and xhtml stuff that is
	; needed before we start showing the environment
	push	dword httplen
	push	dword http
	push	dword stdout
	sys.write

	; Now find how far on the stack the environment pointers
	; are. We have 12 bytes we have pushed before "argc"
	mov	eax, [esp+12]

	; We need to remove the following from the stack:
	;
	;	The 12 bytes we pushed for sys.write
	;	The  4 bytes of argc
	;	The EAX*4 bytes of argv
	;	The  4 bytes of the NULL after argv
	;
	; Total:
	;	20 + eax * 4
	;
	; Because stack grows down, we need to ADD that many bytes
	; to ESP.
	lea	esp, [esp+20+eax*4]
	cld		; This should already be the case, but let's be sure.

	; Loop through the environment, printing it out
.loop:
	pop	edi
	or	edi, edi	; Done yet?
	je	near .wrap

	; Print the left part of HTML
	push	dword leftlen
	push	dword left
	push	dword stdout
	sys.write

	; It may be tempting to search for the '=' in the env string next.
	; But it is possible there is no '=', so we search for the
	; terminating NUL first.
	mov	esi, edi	; Save start of string
	sub	ecx, ecx
	not	ecx		; ECX = FFFFFFFF
	sub	eax, eax
repne	scasb
	not	ecx		; ECX = string length + 1
	mov	ebx, ecx	; Save it in EBX

	; Now is the time to find '='
	mov	edi, esi	; Start of string
	mov	al, '='
repne	scasb
	not	ecx
	add	ecx, ebx	; Length of name

	push	ecx
	push	esi
	push	dword stdout
	sys.write

	; Print the middle part of HTML table code
	push	dword midlen
	push	dword middle
	push	dword stdout
	sys.write

	; Find the length of the value
	not	ecx
	lea	ebx, [ebx+ecx-1]

	; Print "undefined" if 0
	or	ebx, ebx
	jne	.value

	mov	ebx, undeflen
	mov	edi, undef

.value:
	push	ebx
	push	edi
	push	dword stdout
	sys.write

	; Print the right part of the table row
	push	dword rightlen
	push	dword right
	push	dword stdout
	sys.write

	; Get rid of the 60 bytes we have pushed
	add	esp, byte 60

	; Get the next variable
	jmp	.loop

.wrap:
	; Print the rest of HTML
	push	dword wraplen
	push	dword wrap
	push	dword stdout
	sys.write

	; Return success
	push	dword 0
	sys.exit
      </programlisting>

      <para>
	This code produces a 1,396-byte executable. Most of it is
	data, i.e., the HTML mark-up we need to send out.</para>

      <para>
	Assemble and link it as usual:</para>

      <screen>&prompt.user; <userinput>nasm -f elf webvars.asm</userinput>
&prompt.user; <userinput>ld -s -o webvars webvars.o</userinput></screen>

      <para>
	To use it, you need to upload <emphasis>webvars</emphasis> to
	your web server. Depending on how your web server is set up,
	you may have to store in a special
	<emphasis>cgi-bin</emphasis> directory, or perhaps rename it
	with a <emphasis>.cgi</emphasis> extension.</para>

      <para>
	Then you need to use your browser to view its output. To see
	its output on my web server, please instruct your browser to
	go to <emphasis>http://www.int80h.org/webvars/</emphasis>. I
	am deliberately not placing a regular link here because I do
	not want its output to appear on all the search
	engines...</para>
   
    </sect2>
  </sect1>

  <sect1> 
    <title>Working with Files</title>
    <para>
      We have already done some basic file work: We know how to open
      and close them, how to read and write them using buffers. But
      Unix offers much more functionality when it comes to files. We
      will examine some of it in this section, and end up with a nice
      file conversion utility.</para>

    <para>
      Indeed, let us start at the end, that is, with the file
      conversion utility. It always makes programming easier when we
      know from the start what the end product is supposed to
      do.</para>

    <para>
      One of the first programs I wrote for Unix was <ulink
      url="ftp://ftp.int80h.org/unix/tuc/"><emphasis>tuc</emphasis></ulink>,
      a text-to-Unix file converter. It converts a text file from
      other operating systems to a Unix text file. In other words, it
      changes from different kind of line endings to the newline
      convention of Unix. It saves the output in a different
      file. Optionally, it converts a Unix text file to a DOS text
      file.</para>

    <para>I have used <emphasis>tuc</emphasis> extensively, but always
      only to convert from some other OS to Unix, never the other
      way. I have always wished it would just overwrite the file
      instead of me having to send the output to a different
      file. Most of the time, I end up using it like this:</para>

    <screen>&prompt.user; <userinput>tuc myfile tempfile</userinput>
&prompt.user; <userinput>mv tempfile myfile</userinput></screen>

    <para>It would be nice to have a <function>ftuc</function>, i.e.,
      <function>fast tuc</function>, and use it like this:</para>

    <screen>&prompt.user; <userinput>ftuc myfile</userinput></screen>

    <para>In this chapter, then, we will write
      <emphasis>ftuc</emphasis> in assembly language (the original
      <emphasis>tuc</emphasis> is in <emphasis>C</emphasis>), and
      study various file-oriented kernel services in the
      process.</para>

    <para>At first sight, such a file conversion is very simple: All
      you have to do is strip the carriage returns, right?</para>

    <para>If you answered yes, think again: That approach will work
      most of the time (at least with MS DOS text files), but will
      fail occasionally.</para>

    <para>The problem is that not all non-Unix text files end their
      line with the carriage return / line feed sequence. Some use
      carriage returns without line feeds. Others combine several
      blank lines into a single carriage return followed by several
      line feeds. And so on.</para>

    <para>A text file converter, then, must be able to handle any
      possible line endings:</para>

    <itemizedlist>
      <listitem><para>carriage return / line feed</para></listitem>
      <listitem><para>carriage return</para></listitem>
      <listitem><para>line feed / carriage return</para></listitem>
      <listitem><para>line feed</para></listitem>
    </itemizedlist>

    <para>
      It should also handle files that use some kind of a combination
      of the above (e.g., carriage return followed by several line
      feeds).</para>

    <sect2>
      <title>Finite State Machine</title>
      <para>
	The problem is easily solved by the use of a technique called
	<emphasis>finite state machine</emphasis>, originally
	developed by the designers of digital electronic circuits. A
	<emphasis>finite state machine</emphasis> is a digital circuit
	whose output is dependent not only on its input but on its
	previous input, i.e., on its state. The microprocessor is an
	example of a <emphasis>finite state machine</emphasis>: Our
	assembly language code is assembled to machine language in
	which some assembly language code produces a single byte of
	machine language, while others produce several bytes. As the
	microprocessor fetches the bytes from the memory one by one,
	some of them simply change its state rather than produce some
	output. When all the bytes of the op code are fetched, the
	microrpocessor produces some output, or changes the value of a
	register, etc.</para>

      <para>
	Because of that, all software is essentially a sequence of
	state instructions for the microprocessor. Nevertheless, the
	concept of <emphasis>finite state machine</emphasis> is useful
	in software design as well.</para>

      <para>
	Our text file converter can be designed as a <emphasis>finite
	state machine</emphasis> with three possible states. We could
	call them states 0-2, but it will make our life easier if we
	give them symbolic names:</para>

      <itemizedlist>
	<listitem><para><emphasis>ordinary</emphasis></para></listitem>
	<listitem><para><emphasis>cr</emphasis></para></listitem>
	<listitem><para><emphasis>lf</emphasis></para></listitem>
      </itemizedlist>

      <para>
	Our program will start in the <emphasis>ordinary</emphasis>
	state. During this state, the program action depends on its
	input as follows:</para>

      <itemizedlist>
	<listitem><para>If the input is anything other than a carriage
	  return or line feed, the input is simply passed on to the
	  output. The state remains unchanged.</para></listitem>
	
        <listitem><para>If the input is a carriage return, the state
	  is changed to <emphasis>cr</emphasis>. The input is then
	  discarded, i.e., no output is made.</para></listitem>
	
	<listitem><para>If the input is a line feed, the state is
	  changed to <emphasis>lf</emphasis>. The input is then
	  discarded.</para></listitem>
	     
      </itemizedlist>

      <para>
	Whenever we are in the <emphasis>cr</emphasis> state, it is
	because the last input was a carriage return, which was
	unprocessed. What our software does in this state again
	depends on the current input:</para>

      <itemizedlist>
	<listitem>
	  <para>If the input is anything other than a carriage return
	  or line feed, output a line feed, then output the input,
	  then change the state to
	  <emphasis>ordinary</emphasis>.</para></listitem>

	<listitem>
	  <para>If the input is a carriage return, we have received
	  two (or more) carriage returns in a row. We discard the
	  input, we output a line feed, and leave the state
	  unchanged.</para></listitem>

	<listitem>
	  <para>If the input is a line feed, we output the line feed
	  and change the state to <emphasis>ordinary</emphasis>. Note
	  that this is not the same as the first case above â if we
	  tried to combine them, we would be outputting two line feeds
	  instead of one.</para></listitem>

      </itemizedlist>

      <para>
	Finally, we are in the <emphasis>lf</emphasis> state after we
	have received a line feed that was not preceded by a carriage
	return. This will happen when our file already is in Unix
	format, or whenever several lines in a row are expressed by a
	single carriage return followed by several line feeds, or when
	line ends with a line feed / carriage return sequence. Here is
	how we need to handle our input in this state:</para>

      <itemizedlist>
	<listitem>
	  <para>If the input is anything other than a carriage return
	  or line feed, we output a line feed, then output the input,
	  then change the state to <emphasis>ordinary</emphasis>. This
	  is exactly the same action as in the <emphasis>cr</emphasis>
	  state upon receiving the same kind of
	  input.</para></listitem>

	<listitem>
	  <para>If the input is a carriage return, we discard the
	  input, we output a line feed, then change the state to
	  <emphasis>ordinary</emphasis>.</para></listitem>

        <listitem>
	  <para>If the input is a line feed, we output the line feed,
	  and leave the state unchanged.</para></listitem>

      </itemizedlist>

      <sect3>

	<title>The Final State</title>
	<para>
	  The above <emphasis>finite state machine</emphasis> works
	  for the entire file, but leaves the possibility that the
	  final line end will be ignored. That will happen whenever
	  the file ends with a single carriage return or a single line
	  feed. I did not think of it when I wrote
	  <emphasis>tuc</emphasis>, just to discover that occasionally
	  it strips the last line ending.</para>

	<para>
	  This problem is easily fixed by checking the state after the
	  entire file was processed. If the state is not
	  <emphasis>ordinary</emphasis>, we simply need to output one
	  last line feed.</para>

	<para>
	  <emphasis>N.B.:</emphasis> Now that we have expressed our
	  algorithm as a <emphasis>finite state machine</emphasis>, we
	  could easily design a dedicated digital electronic circuit
	  (a âchipâ) to do the conversion for us. Of course, doing so
	  would be considerably more expensive than writing an
	  assembly language program.</para>

      </sect3>

      <sect3>
	<title>The Output Counter</title>
	<para>
	  Because our file conversion program may be combining two
	  characters into one, we need to use an output counter. We
	  initialize it to 0, and increase it every time we send a
	  character to the output. At the end of the program, the
	  counter will tell us what size we need to set the file
	  to.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Implementing FSM in Software</title>
      <para>
	The hardest part of working with a <emphasis>finite state
	machine</emphasis> is analyzing the problem and expressing it
	as a <emphasis>finite state machine</emphasis>. That
	accomplished, the software almost writes itself.</para>

      <para>
	In a high-level language, such as C, there are several main
	approaches. One is to use a <emphasis>switch</emphasis>
	statement which chooses what function should be run. For
	example,</para>

      <programlisting>
	switch (state) {
	default:
	case REGULAR:
		regular(inputchar);
		break;
	case CR:
		cr(inputchar);
		break;
	case LF:
		lf(inputchar);
		break;
	}
      </programlisting> 

      <para>
	Another approach is by using an array of function pointers,
	something like this:</para>

      <programlisting>
	(output[state])(inputchar);
      </programlisting>

      <para>
	Yet another is to have <emphasis>state</emphasis> be a
	function pointer, set to point at the appropriate
	function:</para>

      <programlisting>
	(*state)(inputchar);
      </programlisting>

      <para>
	This is the approach we will use in our program because it is
	very easy to do in assembly language, and very fast, too. We
	will simply keep the address of the right procedure in
	<emphasis>EBX</emphasis>, and then just issue:</para>

      <programlisting>
	call ebx
      </programlisting>

      <para>
	This is possibly faster than hardcoding the address in the
	code because the microprocessor does not have to fetch the
	address from the memoryâit is already stored in one of its
	registers. I said <emphasis>possibly</emphasis> because with
	the caching modern microprocessors do, either way may be
	equally fast.</para>

    </sect2>

    <sect2>
      <title>Memory Mapped Files</title>
      <para>
	Because our program works on a single file, we cannot use the
	approach that worked for us before, i.e., to read from an
	input file and to write to an output file.</para>

      <para>
	Unix allows us to map a file, or a section of a file, into
	memory. To do that, we first need to open the file with the
	appropriate read/write flags. Then we use the
	<emphasis>mmap</emphasis> system call to map it into the
	memory. One nice thing about <emphasis>mmap</emphasis> is that
	it automatically works with virtual memory: We can map more of
	the file into the memory than we have physical memory
	available, yet still access it through regular memory op
	codes, such as <emphasis>mov</emphasis>,
	<emphasis>lods</emphasis>, and
	<emphasis>stos</emphasis>. Whatever changes we make to the
	memory image of the file will be written to the file by the
	system. We do not even have to keep the file open: As long as
	it stays mapped, we can read from it and write to it.</para>

      <para>
	The 32-bit Intel microprocessors can access up to four
	gigabytes of memory â physical or virtual. The FreeBSD system
	allows us to use up to a half of it for file mapping.</para>
   
      <para>
	For simplicity sake, in this tutorial we will only convert
	files that can be mapped into the memory in their
	entirety. There are probably not too many text files that
	exceed two gigabytes in size. If our program encounters one,
	it will simply display a message suggesting we use the
	original <emphasis>tuc</emphasis> instead.</para>

      <para>
        If you examine your copy of
        <filename>syscalls.master</filename>, you will find two
        separate syscalls named <emphasis>mmap</emphasis>. This is
        because of evolution of Unix: There was the traditional BSD
        <emphasis>mmap</emphasis>, syscall 71. That one was superceded
        by the POSIX <emphasis>mmap</emphasis>, syscall 197. The
        FreeBSD system supports both because older programs were
        written by using the original BSD version. But new software
        uses the POSIX version, which is what we will use.</para>

      <para>
	The <filename>syscalls.master</filename> file lists the POSIX
	version like this:</para>

      <programlisting>
197	STD	BSD	{ caddr_t mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
      </programlisting>

      <para>
	This differs slightly from what <function>mmap(2)</function>
	says. That is because <function>mmap(2)</function> describes
	the C version.</para>

      <para>
	The difference is in the <emphasis>long pad</emphasis>
	argument, which is not present in the C version. However, the
	FreeBSD syscalls add a 32-bit pad after pushing a 64-bit
	argument. In this case, <emphasis>off_t</emphasis> is a 64-bit
	value.</para>

      <para>
	When we are finished working with a memory-mapped file, we
	unmap it with the <emphasis>munmap</emphasis> syscall:</para>

      <para>
	<emphasis>TIP:</emphasis> For an in-depth treatment of
	<function>mmap</function>, see W. Richard Stevensâ <ulink
	url="http://www.int80h.org/cgi-bin/isbn?isbn=0130810819">Unix
	Network Programming, Volume 2, Chapter 12</ulink>.</para>
	     
    </sect2>

    <sect2>
      <title>Determining File size</title>
      <para>
	Because we need to tell <function>mmap</function> how many
	bytes of the file to map into the memory, and because we want
	to map the entire file, we need toq determine the size of the
	file.</para>

      <para>
	We can use the <function>fstat</function> syscall to get all
	the information about an open file that the system can give
	us. That includes the file size.</para>

      <para>
	Again, <filename>syscalls.master</filename> lists two versions
	of <function>fstat</function>, a traditional one (syscall 69),
	and a POSIX one (syscall 189)Naturally, we will use the POSIX
	version:</para>

      <programlisting>
189	STD	POSIX	{ int fstat(int fd, struct stat *sb); }
      </programlisting>

      <para>
	This is a very straightforward call: We pass to it the address
	of a <emphasis>stat</emphasis> structure and the descriptor of
	an open file. It will fill out the contents of the
	<emphasis>stat</emphasis> structure.</para>

      <para>
	I do, however, have to say that I tried to declare the
	<function>stat</function> structure in the
	<function>.bss</function> section, and
	<function>fstat</function> did not like it: It set the carry
	flag indicating an error. After I changed the code to allocate
	the structure on the stack, everything was working
	fine.</para>

    </sect2>

    <sect2>
      <title>Changing the File Size</title>

      <para><emphasis>11.5. Changing the File Size</emphasis></para>

      <para>
	Because our program may combine carriage return / line feed
	sequences into straight line feeds, our output may be smaller
	than our input. However, since we are placing our output into
	the same file we read the input from, we may have to change
	the size of the file.</para>

      <para>
	The <function>ftruncate</function> system call allows us to do
	just that. Despite its somewhat misleading name, the
	<function>ftruncate</function> system call can be used to both
	truncate the file (make it smaller) and to grow it.</para>

      <para>
	And yes, we will find two versions of
	<function>ftruncate</function> in
	<function>syscalls.master</function>, an older one (130), and
	a newer one (201). We will use the newer one:</para>

      <programlisting>
201	STD	BSD	{ int ftruncate(int fd, int pad, off_t length); }
      </programlisting>

      <para>
	Please note that this one contains a <function>int
	pad</function> again.</para>
         
      </sect2>

      <sect2>
	<title>ftuc</title>
	<para>
	  We now know everything we need to write
	  <emphasis>ftuc</emphasis>. We start by adding some new lines
	  in <filename>system.inc</filename>. First, we define some
	  constants and structures, somewhere at or near the beginning
	  of the file:</para>

        <programlisting>
;;;;;;; open flags
%define	O_RDONLY	0
%define	O_WRONLY	1
%define	O_RDWR	2

;;;;;;; mmap flags
%define	PROT_NONE	0
%define	PROT_READ	1
%define	PROT_WRITE	2
%define	PROT_EXEC	4
;;
%define	MAP_SHARED	0001h
%define	MAP_PRIVATE	0002h

;;;;;;; stat structure
struc	stat
st_dev		resd	1	; = 0
st_ino		resd	1	; = 4
st_mode		resw	1	; = 8, size is 16 bits
st_nlink	resw	1	; = 10, ditto
st_uid		resd	1	; = 12
st_gid		resd	1	; = 16
st_rdev		resd	1	; = 20
st_atime	resd	1	; = 24
st_atimensec	resd	1	; = 28
st_mtime	resd	1	; = 32
st_mtimensec	resd	1	; = 36
st_ctime	resd	1	; = 40
st_ctimensec	resd	1	; = 44
st_size		resd	2	; = 48, size is 64 bits
st_blocks	resd	2	; = 56, ditto
st_blksize	resd	1	; = 64
st_flags	resd	1	; = 68
st_gen		resd	1	; = 72
st_lspare	resd	1	; = 76
st_qspare	resd	4	; = 80
endstruc
</programlisting>

	       <para>We define the new syscalls:</para>

<programlisting>
%define	SYS_mmap	197
%define	SYS_munmap	73
%define	SYS_fstat	189
%define	SYS_ftruncate	201
</programlisting>
<para>We add the macros for their use:</para>
<programlisting>
%macro	sys.mmap	0
	system	SYS_mmap
%endmacro

%macro	sys.munmap	0
	system	SYS_munmap
%endmacro

%macro	sys.ftruncate	0
	system	SYS_ftruncate
%endmacro

%macro	sys.fstat	0
	system	SYS_fstat
%endmacro
</programlisting>

<para>And here is our code:</para>

<programlisting>
;;;;;;; Fast Text-to-Unix Conversion (ftuc.asm) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Started:	21-Dec-2000
;; Updated:	22-Dec-2000
;;
;; Copyright 2000 G. Adam Stanislav.
;; All rights reserved.
;;
;;;;;;; v.1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	'system.inc'

section	.data
	db	'Copyright 2000 G. Adam Stanislav.', 0Ah
	db	'All rights reserved.', 0Ah
usg	db	'Usage: ftuc filename', 0Ah
usglen	equ	$-usg
co	db	"ftuc: Can't open file.", 0Ah
colen	equ	$-co
fae	db	'ftuc: File access error.', 0Ah
faelen	equ	$-fae
ftl	db	'ftuc: File too long, use regular tuc instead.', 0Ah
ftllen	equ	$-ftl
mae	db	'ftuc: Memory allocation error.', 0Ah
maelen	equ	$-mae

section	.code

align 4
memerr:
	push	dword maelen
	push	dword mae
	jmp	short error

align 4
toolong:
	push	dword ftllen
	push	dword ftl
	jmp	short error

align 4
facerr:
	push	dword faelen
	push	dword fae
	jmp	short error

align 4
cantopen:
	push	dword colen
	push	dword co
	jmp	short error

align 4
usage:
	push	dword usglen
	push	dword usg

error:
	push	dword stderr
	sys.write

	push	dword 1
	sys.exit

align 4
global	_start
_start:
	pop	eax		; argc
	pop	eax		; program name
	pop	ecx		; file to convert
	jecxz	usage

	pop	eax
	or	eax, eax	; Too many arguments?
	jne	usage

	; Open the file
	push	dword O_RDWR
	push	ecx
	sys.open
	jc	cantopen

	mov	ebp, eax	; Save fd

	sub	esp, byte stat_size
	mov	ebx, esp

	; Find file size
	push	ebx
	push	ebp		; fd
	sys.fstat
	jc	facerr

	mov	edx, [ebx + st_size + 4]

	; File is too long if EDX != 0 ...
	or	edx, edx
	jne	near toolong
	mov	ecx, [ebx + st_size]
	; ... or if it is above 2 GB
	or	ecx, ecx
	js	near toolong

	; Do nothing if the file is 0 bytes in size
	jecxz	.quit

	; Map the entire file in memory
	push	edx
	push	edx		; starting at offset 0
	push	edx		; pad
	push	ebp		; fd
	push	dword MAP_SHARED
	push	dword PROT_READ | PROT_WRITE
	push	ecx		; entire file size
	push	edx		; let system decide on the address
	sys.mmap
	jc	near memerr

	mov	edi, eax
	mov	esi, eax
	push	ecx		; for SYS_munmap
	push	edi

	; Use EBX for state machine
	mov	ebx, ordinary
	mov	ah, 0Ah
	cld

.loop:
	lodsb
	call	ebx
	loop	.loop

	cmp	ebx, ordinary
	je	.filesize

	; Output final lf
	mov	al, ah
	stosb
	inc	edx

.filesize:
	; truncate file to new size
	push	dword 0		; high dword
	push	edx		; low dword
	push	eax		; pad
	push	ebp
	sys.ftruncate

	; close it (ebp still pushed)
	sys.close

	add	esp, byte 16
	sys.munmap

.quit:
	push	dword 0
	sys.exit

align 4
ordinary:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	stosb
	inc	edx
	ret

align 4
.cr:
	mov	ebx, cr
	ret

align 4
.lf:
	mov	ebx, lf
	ret

align 4
cr:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	al, ah
	stosb
	inc	edx
	ret

align 4
lf:
	cmp	al, ah
	je	.lf

	cmp	al, 0Dh
	je	.cr

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	ebx, ordinary
	mov	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	ret
      </programlisting>

      <para>
	<emphasis>WARNING:</emphasis> Do not use this program on files
	stored on a disk formated by MS DOS or Windows. There seems to
	be a subtle bug in the FreeBSD code when using
	<function>mmap</function> on these drives mounted under
	FreeBSD: If the file is over a certain size,
	<function>mmap</function> will just fill the memory with
	zeros, and then copy them to the file overwriting its
	contents.</para>

    </sect2>
  </sect1>
             
  <sect1> 
    <title>Caveats</title>

    <para>Assembly language programmers who "grew up" under MS DOS and
      Windows often tend to take shortcuts. Reading the keyboard scan
      codes and writing directly to video memory are two classical
      examples of practices which, under MS DOS are not frowned upon
      but considered the right thing to do.</para>

    <para>The reason? Both the PC BIOS and MS DOS are notoriously slow
      when performing these operations.</para>

    <para>You may be tempted to continue similar practices in the Unix
      environment. For example, I have seen a web site which explains
      how to access the keyboard scan codes on a popular Unix
      clone.</para>

    <para>That is generally a <emphasis>very bad idea</emphasis> in
      Unix environment! Let me explain why.</para>

    <sect2>
      <title>Unix Is Protected</title>
	         
      <para>For one thing, it may simply not be possible. Unix runs in
	protected mode. Only the kernel and device drivers are allowed
	to access hardware directly. Perhaps a particular Unix clone
	will let you read the keyboard scan codes, but chances are a
	real Unix operating system will not. And even if one version
	may let you do it, the next one may not, so your carefully
	crafted software may become a dinosaur overnight.</para>

    </sect2>

    <sect2>
      <title>Unix is an Abstraction</title>
	         
      <para>But there is a much more important reason not to try
	accessing the hardware directly (unless, of course, you are
	writing a device driver), even on the Unix-like systems that
	let you do it:</para>

	<para><emphasis>Unix is an abstraction!</emphasis></para>

	<para>There is a major difference in the philosophy of design
	  between MS DOS and Unix. MS DOS was designed as a
	  single-user system. It is run on a computer with a keyboard
	  and a video screen attached directly to that computer. User
	  input is almost guaranteed to come from that keyboard. Your
	  programâs output virtually always ends up on that
	  screen.</para>

        <para>This is NEVER guaranteed under Unix. It is quite common
	  for a Unix user to pipe and redirect program input and
	  output:</para>

	<screen>&prompt.user <userinput>program1 | program2 | program3 > file1</userinput>
	</screen>

	<para>If you have written <emphasis>program2</emphasis>, your
	  input does not come from the keyboard but from the
	  output<emphasis>program1</emphasis>. Similarly, your output
	  does not go to the screen but becomes the input for
	  <emphasis>program3</emphasis> whose output, in turn, goes to
	  <filename>file1</filename>.</para>

        <para>But there is more! Even if you made sure that your input
	  comes from, and your output goes to, the terminal, there is
	  no guarantee the terminal is a PC: It may not have its video
	  memory where you expect it, nor may its keyboard be
	  producing PC-style scan codes. It may be a Macintosh, or any
	  other computer.</para>

        <para>Now you may be shaking your head: My software is in
	  assembly language, how can it run on a Macintosh? But I did
	  not say your software would be running on a Macintosh, only
	  that its terminal may be a Macintosh.</para>

        <para>Under Unix, the terminal does not have to be directly
	  attached to the computer that runs your software, it can
	  even be on another continent, or, for that matter, on
	  another planet. It is perfectly possible that a Macintosh
	  user in Australia connects to a Unix system in North America
	  (or anywhere else) via <emphasis>telnet</emphasis>. The
	  software then runs on one computer, while the terminal is on
	  a different computer: If you try to read the scan codes, you
	  will get the wrong input!</para>

        <para>Same holds true about any other hardware: A file you are
	  reading may be on a disk you have no direct access to. A
	  camera you are reading images from may be on a space
	  shuttle, connected to you via satellites.</para>

        <para>That is why under Unix you must never make any
	  assumptions about where your data is coming from and going
	  to. Always let the system handle the physical access to the
	  hardware.</para>

        <para><emphasis>N.B.:</emphasis> These are caveats, not
	  absolute rules. Exceptions are possible. For example, if a
	  text editor has determined it is running on a local machine,
	  it may want to read the scan codes directly for improved
	  control. I am not mentioning these caveats to tell you what
	  to do or what not to do, just to make you aware of certain
	  pitfalls that await you if you have just arrived to Unix
	  form MS DOS. Of course, creative people often break rules,
	  and it is OK as long as they know they are breaking them and
	  why.</para>

    </sect2>

  </sect1>

  <sect1> 
    <title>Acknowledgements</title>
	   
    <para>
      This tutorial would never have been possible without the help of
      many experienced FreeBSD programmers from the <ulink
      url="mailto:freebsd-hackers@FreeBSD.org">FreeBSD hackers</ulink>
      mailing list, many of whom have patiently answered my questions,
      and pointed me in the right direction in my attempts to explore
      the inner workings of Unix system programming in general and
      FreeBSD in particular.</para>

    <para>
      Thomas M. Sommers opened the door for me. His <ulink
      url="http://home.ptd.net/~tms2/hello.html">How do I write
      "Hello, world" in FreeBSD assembler?</ulink> web page was my
      first encounter with an example of assembly language programming
      under FreeBSD.</para>

    <para>
      Jake Burkholder has kept the door open by willingly answering
      all of my questions and supplying me with example assembly
      language source code.</para> <para>Copyright &copy; 2000 G. Adam
      Stanislav.All rights reserved.</para>
  </sect1>
</chapter>       
