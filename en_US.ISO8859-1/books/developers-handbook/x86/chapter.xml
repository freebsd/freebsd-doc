<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     This file is automatically generated.  Please do not make commits
     to this file.  Updates should be sent to the author :

     G. Adam Stanislav (adam@redprince.net)

     This chapter is an exception to our general rule, and the author
     retains the copyright.  Among other things, this means that this
     chapter should not be included in any printed version of the
     Developer's Handbook without Adam's explicit permission.

     Eventually we will have to replace this chapter or convince the
     author to assign us the copyright.  For now, it is valuable
     content so it should stay.

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="x86">

  <title>x86 Assembly Language Programming</title>

  <para><emphasis>This chapter was written by
      &a.stanislav.email;.</emphasis></para>

  <sect1 xml:id="x86-intro">
    <title>Synopsis</title>

    <para>Assembly language programming under &unix; is highly
      undocumented.  It is generally assumed that no one would ever
      want to use it because various &unix; systems run on different
      microprocessors, so everything should be written in C for
      portability.</para>

    <para>In reality, C portability is quite a myth.  Even C programs
      need to be modified when ported from one &unix; to another,
      regardless of what processor each runs on.  Typically, such a
      program is full of conditional statements depending on the
      system it is compiled for.</para>

    <para>Even if we believe that all of &unix; software should be
      written in C, or some other high-level language, we still need
      assembly language programmers: Who else would write the section
      of C library that accesses the kernel?</para>

    <para>In this chapter I will attempt to show you how you can use
      assembly language writing &unix; programs, specifically under
      FreeBSD.</para>

    <para>This chapter does not explain the basics of assembly
      language.  There are enough resources about that (for a complete
      online course in assembly language, see Randall Hyde's <link
	xlink:href="http://webster.cs.ucr.edu/">Art of Assembly
	Language</link>; or if you prefer a printed book, take a look
      at Jeff Duntemann's Assembly Language Step-by-Step (ISBN:
      0471375233).  However, once the chapter is finished, any
      assembly language programmer will be able to write programs for
      FreeBSD quickly and efficiently.</para>

    <para>Copyright &copy; 2000-2001 G. Adam Stanislav.  All rights
      reserved.</para>
  </sect1>

  <sect1 xml:id="x86-the-tools">
    <title>The Tools</title>

    <sect2 xml:id="x86-the-assembler">
      <title>The Assembler</title>

      <para>The most important tool for assembly language programming
	is the assembler, the software that converts assembly language
	code into machine language.</para>

      <para>Two very different assemblers are available for FreeBSD.
	One is
	<citerefentry><refentrytitle>as</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
	which uses the traditional &unix; assembly language syntax.
	It comes with the system.</para>

      <para>The other is
	<application>/usr/ports/devel/nasm</application>.  It uses the
	Intel syntax.  Its main advantage is that it can assemble code
	for many operating systems.  It needs to be installed
	separately, but is completely free.</para>

      <para>This chapter uses <application>nasm</application> syntax
	because most assembly language programmers coming to FreeBSD
	from other operating systems will find it easier to
	understand.  And, because, quite frankly, that is what I am
	used to.</para>
    </sect2>

    <sect2 xml:id="x86-the-linker">
      <title>The Linker</title>

      <para>The output of the assembler, like that of any compiler,
	needs to be linked to form an executable file.</para>

      <para>The standard
	<citerefentry><refentrytitle>ld</refentrytitle><manvolnum>1</manvolnum></citerefentry>
	linker comes with FreeBSD.  It works with the code assembled
	with either assembler.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="x86-system-calls">
    <title>System Calls</title>

    <sect2 xml:id="x86-default-calling-convention">
      <title>Default Calling Convention</title>

      <para>By default, the FreeBSD kernel uses the C calling
	convention.  Further, although the kernel is accessed using
	<function role="opcode">int 80h</function>, it is assumed the
	program will call a function that issues <function
	  role="opcode">int 80h</function>, rather than issuing
	<function role="opcode">int 80h</function> directly.</para>

      <para>This convention is very convenient, and quite superior to
	the &microsoft; convention used by
	<acronym>&ms-dos;</acronym>.  Why? Because the &unix;
	convention allows any program written in any language to
	access the kernel.</para>

      <para>An assembly language program can do that as well.  For
	example, we could open a file:</para>

      <programlisting>kernel:
	int	80h	; Call kernel
	ret

open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	call	kernel
	add	esp, byte 12
	ret</programlisting>

      <para>This is a very clean and portable way of coding.  If you
	need to port the code to a &unix; system which uses a
	different interrupt, or a different way of passing parameters,
	all you need to change is the kernel procedure.</para>

      <para>But assembly language programmers like to shave off
	cycles.  The above example requires a <function
	  role="opcode">call/ret</function> combination.  We can
	eliminate it by <function role="opcode">push</function>ing an
	extra dword:</para>

      <programlisting>open:
	push	dword mode
	push	dword flags
	push	dword path
	mov	eax, 5
	push	eax		; Or any other dword
	int	80h
	add	esp, byte 16</programlisting>

      <para>The <constant>5</constant> that we have placed in <varname
	  role="register">EAX</varname> identifies the kernel
	function, in this case <function
	  role="syscall">open</function>.</para>
    </sect2>

    <sect2 xml:id="x86-alternate-calling-convention">
      <title>Alternate Calling Convention</title>

      <para>FreeBSD is an extremely flexible system.  It offers other
	ways of calling the kernel.  For it to work, however, the
	system must have Linux emulation installed.</para>

      <para>Linux is a &unix; like system.  However, its kernel uses
	the same system-call convention of passing parameters in
	registers <acronym>&ms-dos;</acronym> does.  As with the
	&unix; convention, the function number is placed in <varname
	  role="register">EAX</varname>.  The parameters, however, are
	not passed on the stack but in <varname role="register">EBX,
	  ECX, EDX, ESI, EDI, EBP</varname>:</para>

      <programlisting>open:
	mov	eax, 5
	mov	ebx, path
	mov	ecx, flags
	mov	edx, mode
	int	80h</programlisting>

      <para>This convention has a great disadvantage over the &unix;
	way, at least as far as assembly language programming is
	concerned: Every time you make a kernel call you must
	<function role="opcode">push</function> the registers, then
	<function role="opcode">pop</function> them later.  This makes
	your code bulkier and slower.  Nevertheless, FreeBSD gives you
	a choice.</para>

      <para>If you do choose the Linux convention, you must let the
	system know about it.  After your program is assembled and
	linked, you need to brand the executable:</para>

      <screen>&prompt.user; <userinput>brandelf -t Linux <replaceable>filename</replaceable></userinput></screen>
    </sect2>

    <sect2 xml:id="x86-use-geneva">
      <title>Which Convention Should You Use?</title>

      <para>If you are coding specifically for FreeBSD, you should
	always use the &unix; convention: It is faster, you can store
	global variables in registers, you do not have to brand the
	executable, and you do not impose the installation of the
	Linux emulation package on the target system.</para>

      <para>If you want to create portable code that can also run on
	Linux, you will probably still want to give the FreeBSD users
	as efficient a code as possible.  I will show you how you can
	accomplish that after I have explained the basics.</para>
    </sect2>

    <sect2 xml:id="x86-call-numbers">
      <title>Call Numbers</title>

      <para>To tell the kernel which system service you are calling,
	place its number in <varname role="register">EAX</varname>.
	Of course, you need to know what the number is.</para>

      <sect3 xml:id="x86-the-syscalls-file">
	<title>The <filename>syscalls</filename> File</title>

	<para>The numbers are listed in <filename>syscalls</filename>.
	  <command>locate syscalls</command> finds this file in
	  several different formats, all produced automatically from
	  <filename>syscalls.master</filename>.</para>

	<para>You can find the master file for the default &unix;
	  calling convention in
	  <filename>/usr/src/sys/kern/syscalls.master</filename>.  If
	  you need to use the other convention implemented in the
	  Linux emulation mode, read
	  <filename>/usr/src/sys/i386/linux/syscalls.master</filename>.</para>

	<note>
	  <para>Not only do FreeBSD and Linux use different calling
	    conventions, they sometimes use different numbers for the
	    same functions.</para>
	</note>

	<para><filename>syscalls.master</filename> describes how the
	  call is to be made:</para>

	<programlisting>0	STD	NOHIDE	{ int nosys(void); } syscall nosys_args int
1	STD	NOHIDE	{ void exit(int rval); } exit rexit_args void
2	STD	POSIX	{ int fork(void); }
3	STD	POSIX	{ ssize_t read(int fd, void *buf, size_t nbyte); }
4	STD	POSIX	{ ssize_t write(int fd, const void *buf, size_t nbyte); }
5	STD	POSIX	{ int open(char *path, int flags, int mode); }
6	STD	POSIX	{ int close(int fd); }
etc...</programlisting>

      <para>It is the leftmost column that tells us the number to
	place in <varname role="register">EAX</varname>.</para>

      <para>The rightmost column tells us what parameters to <function
	  role="opcode">push</function>.  They are <function
	  role="opcode">push</function>ed <emphasis>from right to
	  left</emphasis>.</para>

      <informalexample>
	<para>For example, to <function>open</function> a file, we
	  need to <function role="opcode">push</function> the
	  <varname>mode</varname> first, then
	  <varname>flags</varname>, then the address at which the
	  <varname>path</varname> is stored.</para>
      </informalexample>
    </sect3>
  </sect2>
</sect1>

<sect1 xml:id="x86-return-values">
  <title>Return Values</title>

  <para>A system call would not be useful most of the time if it did
    not return some kind of a value: The file descriptor of an open
    file, the number of bytes read to a buffer, the system time,
    etc.</para>

  <para>Additionally, the system needs to inform us if an error
    occurs: A file does not exist, system resources are exhausted, we
    passed an invalid parameter, etc.</para>

  <sect2 xml:id="x86-man-pages">
    <title>Man Pages</title>

    <para>The traditional place to look for information about various
      system calls under &unix; systems are the manual pages.  FreeBSD
      describes its system calls in section 2, sometimes in section
      3.</para>

    <para>For example,
      <citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></citerefentry>
      says:</para>

    <blockquote>
      <para>If successful, <function>open()</function> returns a
	non-negative integer, termed a file descriptor.  It returns
	<varname>-1</varname> on failure, and sets
	<varname>errno</varname> to indicate the error.</para>
    </blockquote>

    <para>The assembly language programmer new to &unix; and FreeBSD
      will immediately ask the puzzling question: Where is
      <varname>errno</varname> and how do I get to it?</para>

    <note>
      <para>The information presented in the manual pages applies to C
	programs.  The assembly language programmer needs additional
	information.</para>
    </note>
  </sect2>

  <sect2 xml:id="x86-where-return-values">
    <title>Where Are the Return Values?</title>

    <para>Unfortunately, it depends... For most system calls it is in
      <varname role="register">EAX</varname>, but not for all.  A good
      rule of thumb, when working with a system call for the first
      time, is to look for the return value in <varname
	role="register">EAX</varname>.  If it is not there, you need
      further research.</para>

    <note>
      <para>I am aware of one system call that returns the value in
	<varname role="register">EDX</varname>: <function
	  role="syscall">SYS_fork</function>.  All others I have
	worked with use <varname role="register">EAX</varname>.  But I
	have not worked with them all yet.</para>
    </note>

    <tip>
      <para>If you cannot find the answer here or anywhere else, study
	<application>libc</application> source code and see how it
	interfaces with the kernel.</para>
    </tip>
  </sect2>

  <sect2 xml:id="x86-where-errno">
    <title>Where Is <varname>errno</varname>?</title>

    <para>Actually, nowhere...</para>

    <para><varname>errno</varname> is part of the C language, not the
      &unix; kernel.  When accessing kernel services directly, the
      error code is returned in <varname
	role="register">EAX</varname>, the same register the proper
      return value generally ends up in.</para>

    <para>This makes perfect sense.  If there is no error, there is no
      error code.  If there is an error, there is no return value.
      One register can contain either.</para>
  </sect2>

  <sect2 xml:id="x86-how-to-know-error">
    <title>Determining an Error Occurred</title>

    <para>When using the standard FreeBSD calling convention, the
      <varname role="register">carry flag</varname> is cleared upon
      success, set upon failure.</para>

    <para>When using the Linux emulation mode, the signed value in
      <varname role="register">EAX</varname> is non-negative upon
      success, and contains the return value.  In case of an error,
      the value is negative, i.e., <varname>-errno</varname>.</para>
  </sect2>
</sect1>

<sect1 xml:id="x86-portable-code">
  <title>Creating Portable Code</title>

  <para>Portability is generally not one of the strengths of assembly
    language.  Yet, writing assembly language programs for different
    platforms is possible, especially with
    <application>nasm</application>.  I have written assembly language
    libraries that can be assembled for such different operating
    systems as &windows; and FreeBSD.</para>

  <para>It is all the more possible when you want your code to run on
    two platforms which, while different, are based on similar
    architectures.</para>

  <para>For example, FreeBSD is &unix;, Linux is &unix; like.  I only
    mentioned three differences between them (from an assembly
    language programmer's perspective): The calling convention, the
    function numbers, and the way of returning values.</para>

  <sect2 xml:id="x86-deal-with-function-numbers">
    <title>Dealing with Function Numbers</title>

    <para>In many cases the function numbers are the same.  However,
      even when they are not, the problem is easy to deal with:
      Instead of using numbers in your code, use constants which you
      have declared differently depending on the target
      architecture:</para>

    <programlisting>%ifdef	LINUX
%define	SYS_execve	11
%else
%define	SYS_execve	59
%endif</programlisting>
    </sect2>

    <sect2 xml:id="x86-deal-with-geneva">
      <title>Dealing with Conventions</title>

      <para>Both, the calling convention, and the return value (the
	<varname>errno</varname> problem) can be resolved with
	macros:</para>

      <programlisting>%ifdef	LINUX

%macro	system	0
	call	kernel
%endmacro

align 4
kernel:
	push	ebx
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp

	mov	ebx, [esp+32]
	mov	ecx, [esp+36]
	mov	edx, [esp+40]
	mov	esi, [esp+44]
	mov	ebp, [esp+48]
	int	80h

	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	pop	ebx

	or	eax, eax
	js	.errno
	clc
	ret

.errno:
	neg	eax
	stc
	ret

%else

%macro	system	0
	int	80h
%endmacro

%endif</programlisting>
  </sect2>

  <sect2 xml:id="x86-deal-with-other-portability">
    <title>Dealing with Other Portability Issues</title>

    <para>The above solutions can handle most cases of writing code
      portable between FreeBSD and Linux.  Nevertheless, with some
      kernel services the differences are deeper.</para>

    <para>In that case, you need to write two different handlers for
      those particular system calls, and use conditional assembly.
      Luckily, most of your code does something other than calling the
      kernel, so usually you will only need a few such conditional
      sections in your code.</para>
  </sect2>

  <sect2 xml:id="x86-portable-library">
    <title>Using a Library</title>

    <para>You can avoid portability issues in your main code
      altogether by writing a library of system calls.  Create a
      separate library for FreeBSD, a different one for Linux, and yet
      other libraries for more operating systems.</para>

    <para>In your library, write a separate function (or procedure, if
      you prefer the traditional assembly language terminology) for
      each system call.  Use the C calling convention of passing
      parameters.  But still use <varname
	role="register">EAX</varname> to pass the call number in.  In
      that case, your FreeBSD library can be very simple, as many
      seemingly different functions can be just labels to the same
      code:</para>

    <programlisting>sys.open:
sys.close:
[etc...]
	int	80h
	ret</programlisting>

    <para>Your Linux library will require more different functions.
      But even here you can group system calls using the same number
      of parameters:</para>

    <programlisting>sys.exit:
sys.close:
[etc... one-parameter functions]
	push	ebx
	mov	ebx, [esp+12]
	int	80h
	pop	ebx
	jmp	sys.return

...

sys.return:
	or	eax, eax
	js	sys.err
	clc
	ret

sys.err:
	neg	eax
	stc
	ret</programlisting>

    <para>The library approach may seem inconvenient at first because
      it requires you to produce a separate file your code depends on.
      But it has many advantages: For one, you only need to write it
      once and can use it for all your programs.  You can even let
      other assembly language programmers use it, or perhaps use one
      written by someone else.  But perhaps the greatest advantage of
      the library is that your code can be ported to other systems,
      even by other programmers, by simply writing a new library
      without any changes to your code.</para>

    <para>If you do not like the idea of having a library, you can at
      least place all your system calls in a separate assembly
      language file and link it with your main program.  Here, again,
      all porters have to do is create a new object file to link with
      your main program.</para>
  </sect2>

  <sect2 xml:id="x86-portable-include">
    <title>Using an Include File</title>

    <para>If you are releasing your software as (or with) source code,
      you can use macros and place them in a separate file, which you
      include in your code.</para>

    <para>Porters of your software will simply write a new include
      file.  No library or external object file is necessary, yet your
      code is portable without any need to edit the code.</para>

    <note>
      <para>This is the approach we will use throughout this chapter.
	We will name our include file <filename>system.inc</filename>,
	and add to it whenever we deal with a new system call.</para>
    </note>

    <para>We can start our <filename>system.inc</filename> by
      declaring the standard file descriptors:</para>

    <programlisting>%define	stdin	0
%define	stdout	1
%define	stderr	2</programlisting>

    <para>Next, we create a symbolic name for each system call:</para>

    <programlisting>%define	SYS_nosys	0
%define	SYS_exit	1
%define	SYS_fork	2
%define	SYS_read	3
%define	SYS_write	4
; [etc...]</programlisting>

    <para>We add a short, non-global procedure with a long name, so we
      do not accidentally reuse the name in our code:</para>

    <programlisting>section	.text
align 4
access.the.bsd.kernel:
	int	80h
	ret</programlisting>

    <para>We create a macro which takes one argument, the syscall
      number:</para>

    <programlisting>%macro	system	1
	mov	eax, %1
	call	access.the.bsd.kernel
%endmacro</programlisting>

    <para>Finally, we create macros for each syscall.  These macros
      take no arguments.</para>

    <programlisting>%macro	sys.exit	0
	system	SYS_exit
%endmacro

%macro	sys.fork	0
	system	SYS_fork
%endmacro

%macro	sys.read	0
	system	SYS_read
%endmacro

%macro	sys.write	0
	system	SYS_write
%endmacro

; [etc...]</programlisting>

    <para>Go ahead, enter it into your editor and save it as
      <filename>system.inc</filename>.  We will add more to it as we
      discuss more syscalls.</para>
  </sect2>
</sect1>

<sect1 xml:id="x86-first-program">
  <title>Our First Program</title>

  <para>We are now ready for our first program, the mandatory
    <application>Hello, World!</application></para>

  <programlisting>1:	%include	'system.inc'
 2:
 3:	section	.data
 4:	hello	db	'Hello, World!', 0Ah
 5:	hbytes	equ	$-hello
 6:
 7:	section	.text
 8:	global	_start
 9:	_start:
10:	push	dword hbytes
11:	push	dword hello
12:	push	dword stdout
13:	sys.write
14:
15:	push	dword 0
16:	sys.exit</programlisting>

  <para>Here is what it does: Line 1 includes the defines, the macros,
    and the code from <filename>system.inc</filename>.</para>

  <para>Lines 3-5 are the data: Line 3 starts the data
    section/segment.  Line 4 contains the string "Hello, World!"
    followed by a new line (<constant>0Ah</constant>).  Line 5 creates
    a constant that contains the length of the string from line 4 in
    bytes.</para>

  <para>Lines 7-16 contain the code.  Note that FreeBSD uses the
    <emphasis>elf</emphasis> file format for its executables, which
    requires every program to start at the point labeled
    <varname>_start</varname> (or, more precisely, the linker expects
    that).  This label has to be global.</para>

  <para>Lines 10-13 ask the system to write <varname>hbytes</varname>
    bytes of the <varname>hello</varname> string to
    <varname>stdout</varname>.</para>

  <para>Lines 15-16 ask the system to end the program with the return
    value of <constant>0</constant>.  The <function
      role="syscall">SYS_exit</function> syscall never returns, so the
    code ends there.</para>

  <note>
    <para>If you have come to &unix; from <acronym>&ms-dos;</acronym>
      assembly language background, you may be used to writing
      directly to the video hardware.  You will never have to worry
      about this in FreeBSD, or any other flavor of &unix;.  As far as
      you are concerned, you are writing to a file known as
      <filename>stdout</filename>.  This can be the video screen, or a
      <application>telnet</application> terminal, or an actual file,
      or even the input of another program.  Which one it is, is for
      the system to figure out.</para>
  </note>

  <sect2 xml:id="x86-assemble-1">
    <title>Assembling the Code</title>

    <para>Type the code (except the line numbers) in an editor, and
      save it in a file named <filename>hello.asm</filename>.  You
      need <application>nasm</application> to assemble it.</para>

    <sect3 xml:id="x86-get-nasm">
      <title>Installing <application>nasm</application></title>

      <para>If you do not have <application>nasm</application>,
	type:</para>

      <screen>&prompt.user; <userinput>su</userinput>
Password:<userinput><replaceable>your root password</replaceable></userinput>
&prompt.root; <userinput>cd /usr/ports/devel/nasm</userinput>
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>exit</userinput>
&prompt.user;</screen>

      <para>You may type <userinput>make install clean</userinput>
	instead of just <userinput>make install</userinput> if you do
	not want to keep <application>nasm</application> source
	code.</para>

      <para>Either way, FreeBSD will automatically download
	<application>nasm</application> from the Internet, compile it,
	and install it on your system.</para>

      <note>
	<para>If your system is not FreeBSD, you need to get
	  <application>nasm</application> from its <link
	    xlink:href="https://sourceforge.net/projects/nasm">home
	    page</link>.  You can still use it to assemble FreeBSD
	  code.</para>
      </note>

      <para>Now you can assemble, link, and run the code:</para>

      <screen>&prompt.user; <userinput>nasm -f elf hello.asm</userinput>
&prompt.user; <userinput>ld -s -o hello hello.o</userinput>
&prompt.user; <userinput>./hello</userinput>
Hello, World!
&prompt.user;</screen>
    </sect3>
  </sect2>
</sect1>

<sect1 xml:id="x86-unix-filters">
  <title>Writing &unix; Filters</title>

  <para>A common type of &unix; application is a filter&mdash;a
    program that reads data from the <filename>stdin</filename>,
    processes it somehow, then writes the result to
    <filename>stdout</filename>.</para>

  <para>In this chapter, we shall develop a simple filter, and
    learn how to read from <filename>stdin</filename> and write to
    <filename>stdout</filename>.  This filter will convert each byte
    of its input into a hexadecimal number followed by a blank
    space.</para>

  <programlisting>%include	'system.inc'

section	.data
hex	db	'0123456789ABCDEF'
buffer	db	0, 0, ' '

section	.text
global	_start
_start:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short _start

.done:
	push	dword 0
	sys.exit</programlisting>

      <para>In the data section we create an array called
	<varname>hex</varname>.  It contains the 16 hexadecimal digits
	in ascending order.  The array is followed by a buffer which
	we will use for both input and output.  The first two bytes of
	the buffer are initially set to <constant>0</constant>.  This
	is where we will write the two hexadecimal digits (the first
	byte also is where we will read the input).  The third byte is
	a space.</para>

      <para>The code section consists of four parts: Reading the byte,
	converting it to a hexadecimal number, writing the result, and
	eventually exiting the program.</para>

      <para>To read the byte, we ask the system to read one byte from
	<filename>stdin</filename>, and store it in the first byte of
	the <varname>buffer</varname>.  The system returns the number
	of bytes read in <varname role="register">EAX</varname>.  This
	will be <constant>1</constant> while data is coming, or
	<constant>0</constant>, when no more input data is available.
	Therefore, we check the value of <varname
	  role="register">EAX</varname>.  If it is
	<constant>0</constant>, we jump to <varname>.done</varname>,
	otherwise we continue.</para>

      <note>
	<para>For simplicity sake, we are ignoring the possibility of
	  an error condition at this time.</para>
      </note>

      <para>The hexadecimal conversion reads the byte from the
	<varname>buffer</varname> into <varname
	  role="register">EAX</varname>, or actually just <varname
	  role="register">AL</varname>, while clearing the remaining
	bits of <varname role="register">EAX</varname> to zeros.  We
	also copy the byte to <varname role="register">EDX</varname>
	because we need to convert the upper four bits (nibble)
	separately from the lower four bits.  We store the result in
	the first two bytes of the buffer.</para>

      <para>Next, we ask the system to write the three bytes of the
	buffer, i.e., the two hexadecimal digits and the blank space,
	to <filename>stdout</filename>.  We then jump back to the
	beginning of the program and process the next byte.</para>

      <para>Once there is no more input left, we ask the system to
	exit our program, returning a zero, which is the traditional
	value meaning the program was successful.</para>

      <para>Go ahead, and save the code in a file named
	<filename>hex.asm</filename>, then type the following (the
	<userinput>^D</userinput> means press the control key and type
	<userinput>D</userinput> while holding the control key
	down):</para>

      <screen>&prompt.user; <userinput>nasm -f elf hex.asm</userinput>
&prompt.user; <userinput>ld -s -o hex hex.o</userinput>
&prompt.user; <userinput>./hex</userinput>
<userinput>Hello, World!</userinput>
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A <userinput>Here I come!</userinput>
48 65 72 65 20 49 20 63 6F 6D 65 21 0A <userinput>^D</userinput> &prompt.user;</screen>

      <note>
	<para>If you are migrating to &unix; from
	  <acronym>&ms-dos;</acronym>, you may be wondering why each
	  line ends with <constant>0A</constant> instead of
	  <constant>0D 0A</constant>.  This is because &unix; does not
	  use the cr/lf convention, but a "new line" convention, which
	  is <constant>0A</constant> in hexadecimal.</para>
      </note>

      <para>Can we improve this? Well, for one, it is a bit confusing
	because once we have converted a line of text, our input no
	longer starts at the beginning of the line.  We can modify it
	to print a new line instead of a space after each
	<constant>0A</constant>:</para>

      <programlisting>%include	'system.inc'

section	.data
hex	db	'0123456789ABCDEF'
buffer	db	0, 0, ' '

section	.text
global	_start
_start:
	mov	cl, ' '

.loop:
	; read a byte from stdin
	push	dword 1
	push	dword buffer
	push	dword stdin
	sys.read
	add	esp, byte 12
	or	eax, eax
	je	.done

	; convert it to hex
	movzx	eax, byte [buffer]
	mov	[buffer+2], cl
	cmp	al, 0Ah
	jne	.hex
	mov	[buffer+2], al

.hex:
	mov	edx, eax
	shr	dl, 4
	mov	dl, [hex+edx]
	mov	[buffer], dl
	and	al, 0Fh
	mov	al, [hex+eax]
	mov	[buffer+1], al

	; print it
	push	dword 3
	push	dword buffer
	push	dword stdout
	sys.write
	add	esp, byte 12
	jmp	short .loop

.done:
	push	dword 0
	sys.exit</programlisting>

      <para>We have stored the space in the <varname
	  role="register">CL</varname> register.  We can do this
	safely because, unlike &microsoft.windows;, &unix; system
	calls do not modify the value of any register they do not use
	to return a value in.</para>

      <para>That means we only need to set <varname
	  role="register">CL</varname> once.  We have, therefore,
	added a new label <varname>.loop</varname> and jump to it for
	the next byte instead of jumping at <varname>_start</varname>.
	We have also added the <varname>.hex</varname> label so we can
	either have a blank space or a new line as the third byte of
	the <varname>buffer</varname>.</para>

      <para>Once you have changed <filename>hex.asm</filename> to
	reflect these changes, type:</para>

      <screen>&prompt.user; <userinput>nasm -f elf hex.asm</userinput>
&prompt.user; <userinput>ld -s -o hex hex.o</userinput>
&prompt.user; <userinput>./hex</userinput>
<userinput>Hello, World!</userinput>
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
<userinput>Here I come!</userinput>
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
<userinput>^D</userinput> &prompt.user;</screen>

      <para>That looks better.  But this code is quite inefficient! We
	are making a system call for every single byte twice (once to
	read it, another time to write the output).</para>
    </sect1>

    <sect1 xml:id="x86-buffered-io">
      <title>Buffered Input and Output</title>

      <para>We can improve the efficiency of our code by buffering our
	input and output.  We create an input buffer and read a whole
	sequence of bytes at one time.  Then we fetch them one by one
	from the buffer.</para>

      <para>We also create an output buffer.  We store our output in
	it until it is full.  At that time we ask the kernel to write
	the contents of the buffer to
	<filename>stdout</filename>.</para>

      <para>The program ends when there is no more input.  But we
	still need to ask the kernel to write the contents of our
	output buffer to <filename>stdout</filename> one last time,
	otherwise some of our output would make it to the output
	buffer, but never be sent out.  Do not forget that, or you
	will be wondering why some of your output is missing.</para>

      <programlisting>%include	'system.inc'

%define	BUFSIZE	2048

section	.data
hex	db	'0123456789ABCDEF'

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, ' '
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</programlisting>

      <para>We now have a third section in the source code, named
	<varname>.bss</varname>.  This section is not included in our
	executable file, and, therefore, cannot be initialized.  We
	use <function role="opcode">resb</function> instead of
	<function role="opcode">db</function>.  It simply reserves
	the requested size of uninitialized memory for our use.</para>

      <para>We take advantage of the fact that the system does not
	modify the registers: We use registers for what, otherwise,
	would have to be global variables stored in the
	<varname>.data</varname> section.  This is also why the
	&unix; convention of passing parameters to system calls on the
	stack is superior to the Microsoft convention of passing them
	in the registers: We can keep the registers for our own
	use.</para>

      <para>We use <varname role="register">EDI</varname> and
	<varname role="register">ESI</varname> as pointers to the next
	byte to be read from or written to.  We use <varname
	  role="register">EBX</varname> and <varname
	  role="register">ECX</varname> to keep count of the number of
	bytes in the two buffers, so we know when to dump the output
	to, or read more input from, the system.</para>

      <para>Let us see how it works now:</para>

      <screen>&prompt.user; <userinput>nasm -f elf hex.asm</userinput>
&prompt.user; <userinput>ld -s -o hex hex.o</userinput>
&prompt.user; <userinput>./hex</userinput>
<userinput>Hello, World!</userinput>
<userinput>Here I come!</userinput>
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
<userinput>^D</userinput> &prompt.user;</screen>

      <para>Not what you expected? The program did not print the
	output until we pressed <userinput>^D</userinput>.  That is
	easy to fix by inserting three lines of code to write the
	output every time we have converted a new line to
	<constant>0A</constant>.  I have marked the three lines with
	&gt; (do not copy the &gt; in your
	<filename>hex.asm</filename>).</para>

      <programlisting>%include	'system.inc'

%define	BUFSIZE	2048

section	.data
hex	db	'0123456789ABCDEF'

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
global	_start
_start:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, ' '
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
&gt;	cmp	al, 0Ah
&gt;	jne	.loop
&gt;	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword stdin
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword stdout
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</programlisting>

      <para>Now, let us see how it works:</para>

      <screen>&prompt.user; <userinput>nasm -f elf hex.asm</userinput>
&prompt.user; <userinput>ld -s -o hex hex.o</userinput>
&prompt.user; <userinput>./hex</userinput>
<userinput>Hello, World!</userinput>
48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
<userinput>Here I come!</userinput>
48 65 72 65 20 49 20 63 6F 6D 65 21 0A
<userinput>^D</userinput> &prompt.user;</screen>

      <para>Not bad for a 644-byte executable, is it!</para>

      <note>
	<para>This approach to buffered input/output still
	  contains a hidden danger.  I will discuss&mdash;and
	  fix&mdash;it later, when I talk about the <link
	    linkend="x86-buffered-dark-side">dark side of
	    buffering</link>.</para>
      </note>

      <sect2 xml:id="x86-ungetc">
	<title>How to Unread a Character</title>

	<warning>
	  <para>This may be a somewhat advanced topic, mostly of
	    interest to programmers familiar with the theory of
	    compilers.  If you wish, you may <link
	      linkend="x86-command-line">skip to the next
	      section</link>, and perhaps read this later.</para>
	</warning>

	<para>While our sample program does not require it, more
	  sophisticated filters often need to look ahead.  In other
	  words, they may need to see what the next character is (or
	  even several characters).  If the next character is of a
	  certain value, it is part of the token currently being
	  processed.  Otherwise, it is not.</para>

	<para>For example, you may be parsing the input stream for a
	  textual string (e.g., when implementing a language
	  compiler): If a character is followed by another character,
	  or perhaps a digit, it is part of the token you are
	  processing.  If it is followed by white space, or some other
	  value, then it is not part of the current token.</para>

	<para>This presents an interesting problem: How to return the
	  next character back to the input stream, so it can be read
	  again later?</para>

	<para>One possible solution is to store it in a character
	  variable, then set a flag.  We can modify
	  <function>getchar</function> to check the flag, and if it is
	  set, fetch the byte from that variable instead of the input
	  buffer, and reset the flag.  But, of course, that slows us
	  down.</para>

	<para>The C language has an <function>ungetc()</function>
	  function, just for that purpose.  Is there a quick way to
	  implement it in our code?  I would like you to scroll back
	  up and take a look at the <function>getchar</function>
	  procedure and see if you can find a nice and fast solution
	  before reading the next paragraph.  Then come back here and
	  see my own solution.</para>

	<para>The key to returning a character back to the stream is
	  in how we are getting the characters to start with:</para>

	<para>First we check if the buffer is empty by testing the
	  value of <varname role="register">EBX</varname>.  If it is
	  zero, we call the <function>read</function>
	  procedure.</para>

	<para>If we do have a character available, we use <function
	    role="opcode">lodsb</function>, then decrease the value of
	  <varname role="register">EBX</varname>.  The <function
	    role="opcode">lodsb</function> instruction is effectively
	  identical to:</para>

	<programlisting>mov	al, [esi]
	inc	esi</programlisting>

      <para>The byte we have fetched remains in the buffer until the
	next time <function>read</function> is called.  We do not know
	when that happens, but we do know it will not happen until the
	next call to <function>getchar</function>.  Hence, to "return"
	the last-read byte back to the stream, all we have to do is
	decrease the value of <varname role="register">ESI</varname>
	and increase the value of <varname
	  role="register">EBX</varname>:</para>

      <programlisting>ungetc:
	dec	esi
	inc	ebx
	ret</programlisting>

      <para>But, be careful! We are perfectly safe doing this if our
	look-ahead is at most one character at a time.  If we are
	examining more than one upcoming character and call
	<function>ungetc</function> several times in a row, it will
	work most of the time, but not all the time (and will be tough
	to debug).  Why?</para>

      <para>Because as long as <function>getchar</function> does not
	have to call <function>read</function>, all of the pre-read
	bytes are still in the buffer, and our
	<function>ungetc</function> works without a glitch.  But the
	moment <function>getchar</function> calls
	<function>read</function>, the contents of the buffer
	change.</para>

      <para>We can always rely on <function>ungetc</function> working
	properly on the last character we have read with
	<function>getchar</function>, but not on anything we have read
	before that.</para>

      <para>If your program reads more than one byte ahead, you have
	at least two choices:</para>

      <para>If possible, modify the program so it only reads one byte
	ahead.  This is the simplest solution.</para>

      <para>If that option is not available, first of all determine
	the maximum number of characters your program needs to return
	to the input stream at one time.  Increase that number
	slightly, just to be sure, preferably to a multiple of
	16&mdash;so it aligns nicely.  Then modify the
	<varname>.bss</varname> section of your code, and create a
	small "spare" buffer right before your input buffer, something
	like this:</para>

      <programlisting>section	.bss
	resb	16	; or whatever the value you came up with
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE</programlisting>

      <para>You also need to modify your <function>ungetc</function>
	to pass the value of the byte to unget in <varname
	  role="register">AL</varname>:</para>

      <programlisting>ungetc:
	dec	esi
	inc	ebx
	mov	[esi], al
	ret</programlisting>

      <para>With this modification, you can call
	<function>ungetc</function> up to 17 times in a row safely
	(the first call will still be within the buffer, the remaining
	16 may be either within the buffer or within the
	"spare").</para>
    </sect2>
  </sect1>

  <sect1 xml:id="x86-command-line">
    <title>Command Line Arguments</title>

    <para>Our <application>hex</application> program will be more
      useful if it can read the names of an input and output file from
      its command line, i.e., if it can process the command line
      arguments.  But... Where are they?</para>

    <para>Before a &unix; system starts a program, it <function
	role="opcode">push</function>es some data on the stack, then
      jumps at the <varname>_start</varname> label of the program.
      Yes, I said jumps, not calls.  That means the data can be
      accessed by reading <varname>[esp+offset]</varname>, or by
      simply <function role="opcode">pop</function>ping it.</para>

    <para>The value at the top of the stack contains the number of
      command line arguments.  It is traditionally called
      <varname>argc</varname>, for "argument count."</para>

    <para>Command line arguments follow next, all
      <varname>argc</varname> of them.  These are typically referred
      to as <varname>argv</varname>, for "argument value(s)."  That
      is, we get <varname>argv[0]</varname>,
      <varname>argv[1]</varname>, <varname>...</varname>,
      <varname>argv[argc-1]</varname>.  These are not the actual
      arguments, but pointers to arguments, i.e., memory addresses of
      the actual arguments.  The arguments themselves are
      NUL-terminated character strings.</para>

    <para>The <varname>argv</varname> list is followed by a NULL
      pointer, which is simply a <constant>0</constant>.  There is
      more, but this is enough for our purposes right now.</para>

    <note>
      <para>If you have come from the <acronym>&ms-dos;</acronym>
	programming environment, the main difference is that each
	argument is in a separate string.  The second difference is
	that there is no practical limit on how many arguments there
	can be.</para>
    </note>

    <para>Armed with this knowledge, we are almost ready for the next
      version of <filename>hex.asm</filename>.  First, however, we
      need to add a few lines to
      <filename>system.inc</filename>:</para>

    <para>First, we need to add two new entries to our list of system
      call numbers:</para>

    <programlisting>%define	SYS_open	5
%define	SYS_close	6</programlisting>

    <para>Then we add two new macros at the end of the file:</para>

    <programlisting>%macro	sys.open	0
	system	SYS_open
%endmacro

%macro	sys.close	0
	system	SYS_close
%endmacro</programlisting>

    <para>Here, then, is our modified source code:</para>

    <programlisting>%include	'system.inc'

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
hex	db	'0123456789ABCDEF'

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
err:
	push	dword 1		; return failure
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to input file
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	err		; open failed

	add	esp, byte 8
	mov	[fd.in], eax

	pop	ecx
	jecxz	.init		; no more arguments

	; ECX contains the path to output file
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	err

	add	esp, byte 12
	mov	[fd.out], eax

.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

.loop:
	; read a byte from input file or stdin
	call	getchar

	; convert it to hex
	mov	dl, al
	shr	al, 4
	mov	al, [hex+eax]
	call	putchar

	mov	al, dl
	and	al, 0Fh
	mov	al, [hex+eax]
	call	putchar

	mov	al, ' '
	cmp	dl, 0Ah
	jne	.put
	mov	al, dl

.put:
	call	putchar
	cmp	al, dl
	jne	.loop
	call	write
	jmp	short .loop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
	ret</programlisting>

      <para>In our <varname>.data</varname> section we now have two
	new variables, <varname>fd.in</varname> and
	<varname>fd.out</varname>.  We store the input and output file
	descriptors here.</para>

      <para>In the <varname>.text</varname> section we have replaced
	the references to <varname>stdin</varname> and
	<varname>stdout</varname> with <varname>[fd.in]</varname> and
	<varname>[fd.out]</varname>.</para>

      <para>The <varname>.text</varname> section now starts with a
	simple error handler, which does nothing but exit the program
	with a return value of <constant>1</constant>.  The error
	handler is before <varname>_start</varname> so we are within
	a short distance from where the errors occur.</para>

      <para>Naturally, the program execution still begins at
	<varname>_start</varname>.  First, we remove
	<varname>argc</varname> and <varname>argv[0]</varname> from
	the stack: They are of no interest to us (in this program,
	that is).</para>

      <para>We pop <varname>argv[1]</varname> to <varname
	  role="register">ECX</varname>.  This register is
	particularly suited for pointers, as we can handle NULL
	pointers with <function role="opcode">jecxz</function>.  If
	<varname>argv[1]</varname> is not NULL, we try to open the
	file named in the first argument.  Otherwise, we continue the
	program as before: Reading from <varname>stdin</varname>,
	writing to <varname>stdout</varname>.  If we fail to open the
	input file (e.g., it does not exist), we jump to the error
	handler and quit.</para>

      <para>If all went well, we now check for the second argument.
	If it is there, we open the output file.  Otherwise, we send
	the output to <varname>stdout</varname>.  If we fail to open
	the output file (e.g., it exists and we do not have the write
	permission), we, again, jump to the error handler.</para>

      <para>The rest of the code is the same as before, except we
	close the input and output files before exiting, and, as
	mentioned, we use <varname>[fd.in]</varname> and
	<varname>[fd.out]</varname>.</para>

      <para>Our executable is now a whopping 768 bytes long.</para>

      <para>Can we still improve it? Of course!  Every program can be
	improved.  Here are a few ideas of what we could do:</para>

      <itemizedlist>
	<listitem>
	  <para>Have our error handler print a message to
	    <varname>stderr</varname>.</para>
	</listitem>

	<listitem>
	  <para>Add error handlers to the <function>read</function>
	    and <function>write</function> functions.</para>
	</listitem>

	<listitem>
	  <para>Close <varname>stdin</varname> when we open an input
	    file, <varname>stdout</varname> when we open an output
	    file.</para>
	</listitem>

	<listitem>
	  <para>Add command line switches, such as
	    <parameter>-i</parameter> and <parameter>-o</parameter>,
	    so we can list the input and output files in any order,
	    or perhaps read from <varname>stdin</varname> and write to
	    a file.</para>
	</listitem>

	<listitem>
	  <para>Print a usage message if command line arguments are
	    incorrect.</para>
	</listitem>

      </itemizedlist>

      <para>I shall leave these enhancements as an exercise to the
	reader: You already know everything you need to know to
	implement them.</para>
    </sect1>

    <sect1 xml:id="x86-environment">
      <title>&unix; Environment</title>

      <para>An important &unix; concept is the environment, which is
	defined by <emphasis>environment variables</emphasis>.  Some
	are set by the system, others by you, yet others by the
	<application>shell</application>, or any program that loads
	another program.</para>

      <sect2 xml:id="x86-find-environment">
	<title>How to Find Environment Variables</title>

	<para>I said earlier that when a program starts executing, the
	  stack contains <varname>argc</varname> followed by the
	  NULL-terminated <varname>argv</varname> array, followed by
	  something else.  The "something else" is the
	  <emphasis>environment</emphasis>, or, to be more precise, a
	  NULL-terminated array of pointers to <emphasis>environment
	    variables</emphasis>.  This is often referred to as
	  <varname>env</varname>.</para>

	<para>The structure of <varname>env</varname> is the same as
	  that of <varname>argv</varname>, a list of memory addresses
	  followed by a NULL (<constant>0</constant>).  In this case,
	  there is no <varname>"envc"</varname>&mdash;we figure out
	  where the array ends by searching for the final NULL.</para>

	<para>The variables usually come in the
	  <varname>name=value</varname> format, but sometimes the
	  <varname>=value</varname> part may be missing.  We need to
	  account for that possibility.</para>
      </sect2>

      <sect2 xml:id="x86-webvar">
	<title>webvars</title>

	<para>I could just show you some code that prints the
	  environment the same way the &unix;
	  <application>env</application> command does.  But I thought
	  it would be more interesting to write a simple assembly
	  language CGI utility.</para>

	<sect3 xml:id="x86-cgi">
	  <title>CGI: a Quick Overview</title>

	  <para>I have a <link
	      xlink:href="http://www.whizkidtech.redprince.net/cgi-bin/tutorial">detailed
	      <acronym>CGI</acronym> tutorial</link> on my web site,
	    but here is a very quick overview of
	    <acronym>CGI</acronym>:</para>

	  <itemizedlist>
	    <listitem>
	      <para>The web server communicates with the
		<acronym>CGI</acronym> program by setting
		<emphasis>environment variables</emphasis>.</para>
	    </listitem>

	    <listitem>
	      <para>The <acronym>CGI</acronym> program sends its
		output to <filename>stdout</filename>.  The web server
		reads it from there.</para>
	    </listitem>

	    <listitem>
	      <para>It must start with an <acronym>HTTP</acronym>
		header followed by two blank lines.</para>
	    </listitem>

	    <listitem>
	      <para>It then prints the <acronym>HTML</acronym> code,
		or whatever other type of data it is producing.</para>
	    </listitem>
	  </itemizedlist>

	  <note>
	    <para>While certain <emphasis>environment
		variables</emphasis> use standard names, others vary,
	      depending on the web server.  That makes
	      <application>webvars</application> quite a useful
	      diagnostic tool.</para>
	  </note>
	</sect3>

	<sect3 xml:id="x86-webvars-the-code">
	  <title>The Code</title>

	  <para>Our <application>webvars</application> program, then,
	    must send out the <acronym>HTTP</acronym> header followed
	    by some <acronym>HTML</acronym> mark-up.  It then must
	    read the <emphasis>environment variables</emphasis> one by
	    one and send them out as part of the
	    <acronym>HTML</acronym> page.</para>

	  <para>The code follows.  I placed comments and explanations
	    right inside the code:</para>

	  <programlisting>;;;;;;; webvars.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (c) 2000 G. Adam Stanislav
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
; OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
; HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
; LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
; OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
; SUCH DAMAGE.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Version 1.0
;
; Started:	 8-Dec-2000
; Updated:	 8-Dec-2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	'system.inc'

section	.data
http	db	'Content-type: text/html', 0Ah, 0Ah
	db	'&lt;?xml version="1.0" encoding="utf-8"?&gt;', 0Ah
	db	'&lt;!DOCTYPE html PUBLIC "-//W3C/DTD XHTML Strict//EN" '
	db	'"DTD/xhtml1-strict.dtd"&gt;', 0Ah
	db	'&lt;html xmlns="http://www.w3.org/1999/xhtml" '
	db	'xml.lang="en" lang="en"&gt;', 0Ah
	db	'&lt;head&gt;', 0Ah
	db	'&lt;title&gt;Web Environment&lt;/title&gt;', 0Ah
	db	'&lt;meta name="author" content="G. Adam Stanislav" /&gt;', 0Ah
	db	'&lt;/head&gt;', 0Ah, 0Ah
	db	'&lt;body bgcolor="#ffffff" text="#000000" link="#0000ff" '
	db	'vlink="#840084" alink="#0000ff"&gt;', 0Ah
	db	'&lt;div class="webvars"&gt;', 0Ah
	db	'&lt;h1&gt;Web Environment&lt;/h1&gt;', 0Ah
	db	'&lt;p&gt;The following &lt;b&gt;environment variables&lt;/b&gt; are defined '
	db	'on this web server:&lt;/p&gt;', 0Ah, 0Ah
	db	'&lt;table align="center" width="80" border="0" cellpadding="10" '
	db	'cellspacing="0" class="webvars"&gt;', 0Ah
httplen	equ	$-http
left	db	'&lt;tr&gt;', 0Ah
	db	'&lt;td class="name"&gt;&lt;tt&gt;'
leftlen	equ	$-left
middle	db	'&lt;/tt&gt;&lt;/td&gt;', 0Ah
	db	'&lt;td class="value"&gt;&lt;tt&gt;&lt;b&gt;'
midlen	equ	$-middle
undef	db	'&lt;i&gt;(undefined)&lt;/i&gt;'
undeflen	equ	$-undef
right	db	'&lt;/b&gt;&lt;/tt&gt;&lt;/td&gt;', 0Ah
	db	'&lt;/tr&gt;', 0Ah
rightlen	equ	$-right
wrap	db	'&lt;/table&gt;', 0Ah
	db	'&lt;/div&gt;', 0Ah
	db	'&lt;/body&gt;', 0Ah
	db	'&lt;/html&gt;', 0Ah, 0Ah
wraplen	equ	$-wrap

section	.text
global	_start
_start:
	; First, send out all the http and xhtml stuff that is
	; needed before we start showing the environment
	push	dword httplen
	push	dword http
	push	dword stdout
	sys.write

	; Now find how far on the stack the environment pointers
	; are. We have 12 bytes we have pushed before "argc"
	mov	eax, [esp+12]

	; We need to remove the following from the stack:
	;
	;	The 12 bytes we pushed for sys.write
	;	The  4 bytes of argc
	;	The EAX*4 bytes of argv
	;	The  4 bytes of the NULL after argv
	;
	; Total:
	;	20 + eax * 4
	;
	; Because stack grows down, we need to ADD that many bytes
	; to ESP.
	lea	esp, [esp+20+eax*4]
	cld		; This should already be the case, but let's be sure.

	; Loop through the environment, printing it out
.loop:
	pop	edi
	or	edi, edi	; Done yet?
	je	near .wrap

	; Print the left part of HTML
	push	dword leftlen
	push	dword left
	push	dword stdout
	sys.write

	; It may be tempting to search for the '=' in the env string next.
	; But it is possible there is no '=', so we search for the
	; terminating NUL first.
	mov	esi, edi	; Save start of string
	sub	ecx, ecx
	not	ecx		; ECX = FFFFFFFF
	sub	eax, eax
repne	scasb
	not	ecx		; ECX = string length + 1
	mov	ebx, ecx	; Save it in EBX

	; Now is the time to find '='
	mov	edi, esi	; Start of string
	mov	al, '='
repne	scasb
	not	ecx
	add	ecx, ebx	; Length of name

	push	ecx
	push	esi
	push	dword stdout
	sys.write

	; Print the middle part of HTML table code
	push	dword midlen
	push	dword middle
	push	dword stdout
	sys.write

	; Find the length of the value
	not	ecx
	lea	ebx, [ebx+ecx-1]

	; Print "undefined" if 0
	or	ebx, ebx
	jne	.value

	mov	ebx, undeflen
	mov	edi, undef

.value:
	push	ebx
	push	edi
	push	dword stdout
	sys.write

	; Print the right part of the table row
	push	dword rightlen
	push	dword right
	push	dword stdout
	sys.write

	; Get rid of the 60 bytes we have pushed
	add	esp, byte 60

	; Get the next variable
	jmp	.loop

.wrap:
	; Print the rest of HTML
	push	dword wraplen
	push	dword wrap
	push	dword stdout
	sys.write

	; Return success
	push	dword 0
	sys.exit</programlisting>

      <para>This code produces a 1,396-byte executable.  Most of it is
	data, i.e., the <acronym>HTML</acronym> mark-up we need to
	send out.</para>

      <para>Assemble and link it as usual:</para>

      <screen>&prompt.user; <userinput>nasm -f elf webvars.asm</userinput>
&prompt.user; <userinput>ld -s -o webvars webvars.o</userinput></screen>

      <para>To use it, you need to upload <filename>webvars</filename>
	to your web server.  Depending on how your web server is set
	up, you may have to store it in a special
	<filename>cgi-bin</filename> directory, or perhaps rename it
	with a <filename>.cgi</filename> extension.</para>

      <para>Then you need to use your browser to view its output.  To
	see its output on my web server, please go to <link
	  xlink:href="http://www.int80h.org/webvars/"><filename>http://www.int80h.org/webvars/</filename></link>.
	If curious about the additional environment variables present
	in a password protected web directory, go to <link
	  xlink:href="http://www.int80h.org/private/"><filename>http://www.int80h.org/private/</filename></link>,
	using the name <userinput>asm</userinput> and password
	<userinput>programmer</userinput>.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="x86-files">
    <title>Working with Files</title>

    <para>We have already done some basic file work: We know how to
      open and close them, how to read and write them using buffers.
      But &unix; offers much more functionality when it comes to
      files.  We will examine some of it in this section, and end up
      with a nice file conversion utility.</para>

    <para>Indeed, let us start at the end, that is, with the file
      conversion utility.  It always makes programming easier when we
      know from the start what the end product is supposed to
      do.</para>

    <para>One of the first programs I wrote for &unix; was <link
	xlink:href="ftp://ftp.int80h.org/unix/tuc/"><application>tuc</application></link>,
      a text-to-&unix; file converter.  It converts a text file from
      other operating systems to a &unix; text file.  In other words,
      it changes from different kind of line endings to the newline
      convention of &unix;.  It saves the output in a different file.
      Optionally, it converts a &unix; text file to a
      <acronym>DOS</acronym> text file.</para>

    <para>I have used <application>tuc</application> extensively, but
      always only to convert from some other <acronym>OS</acronym> to
      &unix;, never the other way.  I have always wished it would just
      overwrite the file instead of me having to send the output to a
      different file.  Most of the time, I end up using it like
      this:</para>

    <screen>&prompt.user; <userinput>tuc <replaceable>myfile tempfile</replaceable></userinput>
&prompt.user; <userinput>mv <replaceable>tempfile myfile</replaceable></userinput></screen>

    <para>It would be nice to have a <application>ftuc</application>,
      i.e., <emphasis>fast tuc</emphasis>, and use it like
      this:</para>

    <screen>&prompt.user; <userinput>ftuc <replaceable>myfile</replaceable></userinput></screen>

    <para>In this chapter, then, we will write
      <application>ftuc</application> in assembly language (the
      original <application>tuc</application> is in C), and study
      various file-oriented kernel services in the process.</para>

    <para>At first sight, such a file conversion is very simple: All
      you have to do is strip the carriage returns, right?</para>

    <para>If you answered yes, think again: That approach will work
      most of the time (at least with <acronym>MS DOS</acronym> text
      files), but will fail occasionally.</para>

    <para>The problem is that not all non &unix; text files end their
      line with the carriage return / line feed sequence.  Some use
      carriage returns without line feeds.  Others combine several
      blank lines into a single carriage return followed by several
      line feeds.  And so on.</para>

    <para>A text file converter, then, must be able to handle any
      possible line endings:</para>

    <itemizedlist>
      <listitem>
	<para>carriage return / line feed</para>
      </listitem>

      <listitem>
	<para>carriage return</para>
      </listitem>

      <listitem>
	<para>line feed / carriage return</para>
      </listitem>

      <listitem>
	<para>line feed</para>
      </listitem>
    </itemizedlist>

    <para>It should also handle files that use some kind of a
      combination of the above (e.g., carriage return followed by
      several line feeds).</para>

    <sect2 xml:id="x86-finite-state-machine">
      <title>Finite State Machine</title>

      <para>The problem is easily solved by the use of a technique
	called <emphasis>finite state machine</emphasis>, originally
	developed by the designers of digital electronic circuits.  A
	<emphasis>finite state machine</emphasis> is a digital circuit
	whose output is dependent not only on its input but on its
	previous input, i.e., on its state.  The microprocessor is an
	example of a <emphasis>finite state machine</emphasis>: Our
	assembly language code is assembled to machine language in
	which some assembly language code produces a single byte of
	machine language, while others produce several bytes.  As the
	microprocessor fetches the bytes from the memory one by one,
	some of them simply change its state rather than produce some
	output.  When all the bytes of the op code are fetched, the
	microprocessor produces some output, or changes the value of
	a register, etc.</para>

      <para>Because of that, all software is essentially a sequence of
	state instructions for the microprocessor.  Nevertheless, the
	concept of <emphasis>finite state machine</emphasis> is useful
	in software design as well.</para>

      <para>Our text file converter can be designer as a
	<emphasis>finite state machine</emphasis> with three possible
	states.  We could call them states 0-2, but it will make our
	life easier if we give them symbolic names:</para>

      <itemizedlist>
	<listitem>
	  <para><symbol>ordinary</symbol></para>
	</listitem>

	<listitem>
	  <para><symbol>cr</symbol></para>
	</listitem>

	<listitem>
	  <para><symbol>lf</symbol></para>
	</listitem>
      </itemizedlist>

      <para>Our program will start in the <symbol>ordinary</symbol>
	state.  During this state, the program action depends on its
	input as follows:</para>

      <itemizedlist>
	<listitem>
	  <para>If the input is anything other than a carriage return
	    or line feed, the input is simply passed on to the output.
	    The state remains unchanged.</para>
	</listitem>

	<listitem>
	  <para>If the input is a carriage return, the state is
	    changed to <symbol>cr</symbol>.  The input is then
	    discarded, i.e., no output is made.</para>
	</listitem>

	<listitem>
	  <para>If the input is a line feed, the state is changed to
	    <symbol>lf</symbol>.  The input is then discarded.</para>
	</listitem>
      </itemizedlist>

      <para>Whenever we are in the <symbol>cr</symbol> state, it is
	because the last input was a carriage return, which was
	unprocessed.  What our software does in this state again
	depends on the current input:</para>

      <itemizedlist>
	<listitem>
	  <para>If the input is anything other than a carriage return
	    or line feed, output a line feed, then output the input,
	    then change the state to <symbol>ordinary</symbol>.</para>
	</listitem>

	<listitem>
	  <para>If the input is a carriage return, we have received
	    two (or more) carriage returns in a row.  We discard the
	    input, we output a line feed, and leave the state
	    unchanged.</para>
	</listitem>

	<listitem>
	  <para>If the input is a line feed, we output the line feed
	    and change the state to <symbol>ordinary</symbol>.  Note
	    that this is not the same as the first case above &ndash;
	    if we tried to combine them, we would be outputting two
	    line feeds instead of one.</para>
	</listitem>
      </itemizedlist>

      <para>Finally, we are in the <symbol>lf</symbol> state after we
	have received a line feed that was not preceded by a
	carriage return.  This will happen when our file already is in
	&unix; format, or whenever several lines in a row are
	expressed by a single carriage return followed by several line
	feeds, or when line ends with a line feed / carriage return
	sequence.  Here is how we need to handle our input in this
	state:</para>

      <itemizedlist>
	<listitem>
	  <para>If the input is anything other than a carriage return
	    or line feed, we output a line feed, then output the
	    input, then change the state to <symbol>ordinary</symbol>.
	    This is exactly the same action as in the
	    <symbol>cr</symbol> state upon receiving the same kind of
	    input.</para>
	</listitem>

	<listitem>
	  <para>If the input is a carriage return, we discard the
	    input, we output a line feed, then change the state to
	    <symbol>ordinary</symbol>.</para>
	</listitem>

	<listitem>
	  <para>If the input is a line feed, we output the line feed,
	    and leave the state unchanged.</para>
	</listitem>
      </itemizedlist>

      <sect3 xml:id="x86-final-state">
	<title>The Final State</title>

	<para>The above <emphasis>finite state machine</emphasis>
	  works for the entire file, but leaves the possibility that
	  the final line end will be ignored.  That will happen
	  whenever the file ends with a single carriage return or a
	  single line feed.  I did not think of it when I wrote
	  <application>tuc</application>, just to discover that
	  occasionally it strips the last line ending.</para>

	<para>This problem is easily fixed by checking the state after
	  the entire file was processed.  If the state is not
	  <symbol>ordinary</symbol>, we simply need to output one last
	  line feed.</para>

	<note>
	  <para>Now that we have expressed our algorithm as a
	    <emphasis>finite state machine</emphasis>, we could easily
	    design a dedicated digital electronic circuit (a "chip")
	    to do the conversion for us.  Of course, doing so would be
	    considerably more expensive than writing an assembly
	    language program.</para>
	</note>
      </sect3>

      <sect3 xml:id="x86-tuc-counter">
	<title>The Output Counter</title>

	<para>Because our file conversion program may be combining two
	  characters into one, we need to use an output counter.  We
	  initialize it to <constant>0</constant>, and increase it
	  every time we send a character to the output.  At the end of
	  the program, the counter will tell us what size we need to
	  set the file to.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="x86-software-fsm">
      <title>Implementing FSM in Software</title>

      <para>The hardest part of working with a <emphasis>finite state
	  machine</emphasis> is analyzing the problem and expressing
	it as a <emphasis>finite state machine</emphasis>.  That
	accomplished, the software almost writes itself.</para>

      <para>In a high-level language, such as C, there are several
	main approaches.  One is to use a <function
	  role="statement">switch</function> statement which chooses
	what function should be run.  For example,</para>

      <programlisting>switch (state) {
	default:
	case REGULAR:
		regular(inputchar);
		break;
	case CR:
		cr(inputchar);
		break;
	case LF:
		lf(inputchar);
		break;
	}</programlisting>

      <para>Another approach is by using an array of function
	pointers, something like this:</para>

      <programlisting>(output[state])(inputchar);</programlisting>

      <para>Yet another is to have <varname>state</varname> be a
	function pointer, set to point at the appropriate
	function:</para>

      <programlisting>(*state)(inputchar);</programlisting>

      <para>This is the approach we will use in our program because it
	is very easy to do in assembly language, and very fast, too.
	We will simply keep the address of the right procedure in
	<varname role="register">EBX</varname>, and then just
	issue:</para>

      <programlisting>call	ebx</programlisting>

      <para>This is possibly faster than hardcoding the address in the
	code because the microprocessor does not have to fetch the
	address from the memory&mdash;it is already stored in one of
	its registers.  I said <emphasis>possibly</emphasis> because
	with the caching modern microprocessors do, either way may be
	equally fast.</para>
    </sect2>

    <sect2 xml:id="memory-mapped-files">
      <title>Memory Mapped Files</title>

      <para>Because our program works on a single file, we cannot use
	the approach that worked for us before, i.e., to read from an
	input file and to write to an output file.</para>

      <para>&unix; allows us to map a file, or a section of a file,
	into memory.  To do that, we first need to open the file with
	the appropriate read/write flags.  Then we use the <function
	  role="syscall">mmap</function> system call to map it into
	the memory.  One nice thing about <function
	  role="syscall">mmap</function> is that it automatically
	works with virtual memory: We can map more of the file into
	the memory than we have physical memory available, yet still
	access it through regular memory op codes, such as <function
	  role="opcode">mov</function>, <function
	  role="opcode">lods</function>, and <function
	  role="opcode">stos</function>.  Whatever changes we make to
	the memory image of the file will be written to the file by
	the system.  We do not even have to keep the file open: As
	long as it stays mapped, we can read from it and write to
	it.</para>

      <para>The 32-bit Intel microprocessors can access up to four
	gigabytes of memory &ndash; physical or virtual.  The FreeBSD
	system allows us to use up to a half of it for file
	mapping.</para>

      <para>For simplicity sake, in this tutorial we will only convert
	files that can be mapped into the memory in their entirety.
	There are probably not too many text files that exceed two
	gigabytes in size.  If our program encounters one, it will
	simply display a message suggesting we use the original
	<application>tuc</application> instead.</para>

      <para>If you examine your copy of
	<filename>syscalls.master</filename>, you will find two
	separate syscalls named <function
	  role="syscall">mmap</function>.  This is because of
	evolution of &unix;: There was the traditional
	<acronym>BSD</acronym>
	<function
	  role="syscall">mmap</function>, syscall 71.  That one was
	superseded by the <acronym>&posix;</acronym> <function
	  role="syscall">mmap</function>, syscall 197.  The FreeBSD
	system supports both because older programs were written by
	using the original <acronym>BSD</acronym> version.  But new
	software uses the <acronym>&posix;</acronym> version, which is
	what we will use.</para>

      <para>The <filename>syscalls.master</filename> lists the
	<acronym>&posix;</acronym> version like this:</para>

      <programlisting>197	STD	BSD	{ caddr_t mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }</programlisting>

      <para>This differs slightly from what
	<citerefentry><refentrytitle>mmap</refentrytitle><manvolnum>2</manvolnum></citerefentry>
	says.  That is because
	<citerefentry><refentrytitle>mmap</refentrytitle><manvolnum>2</manvolnum></citerefentry>
	describes the C version.</para>

      <para>The difference is in the <varname>long pad</varname>
	argument, which is not present in the C version.  However, the
	FreeBSD syscalls add a 32-bit pad after <function
	  role="opcode">push</function>ing a 64-bit argument.  In this
	case, <varname>off_t</varname> is a 64-bit value.</para>

      <para>When we are finished working with a memory-mapped file, we
	unmap it with the <function
	  role="syscall">munmap</function> syscall:</para>

      <tip>
	<para>For an in-depth treatment of <function
	    role="syscall">mmap</function>, see W. Richard Stevens'
	  <link
	    xlink:href="http://www.int80h.org/cgi-bin/isbn?isbn=0130810819">Unix
	    Network Programming, Volume 2, Chapter 12</link>.</para>
      </tip>
    </sect2>

    <sect2 xml:id="x86-file-size">
      <title>Determining File Size</title>

      <para>Because we need to tell <function
	  role="syscall">mmap</function> how many bytes of the file to
	map into the memory, and because we want to map the entire
	file, we need to determine the size of the file.</para>

      <para>We can use the <function role="syscall">fstat</function>
	syscall to get all the information about an open file that the
	system can give us.  That includes the file size.</para>

      <para>Again, <filename>syscalls.master</filename> lists two
	versions of <function role="syscall">fstat</function>, a
	traditional one (syscall 62), and a <acronym>&posix;</acronym>
	one (syscall 189).  Naturally, we will use the
	<acronym>&posix;</acronym> version:</para>

      <programlisting>189	STD	POSIX	{ int fstat(int fd, struct stat *sb); }</programlisting>

      <para>This is a very straightforward call: We pass to it the
	address of a <varname remap="structname">stat</varname>
	structure and the descriptor of an open file.  It will fill
	out the contents of the <varname
	  remap="structname">stat</varname> structure.</para>

      <para>I do, however, have to say that I tried to declare the
	<varname remap="structname">stat</varname> structure in the
	<varname>.bss</varname> section, and <function
	  role="syscall">fstat</function> did not like it: It set the
	carry flag indicating an error.  After I changed the code to
	allocate the structure on the stack, everything was working
	fine.</para>
    </sect2>

    <sect2 xml:id="x86-ftruncate">
      <title>Changing the File Size</title>

      <para>Because our program may combine carriage return / line
	feed sequences into straight line feeds, our output may be
	smaller than our input.  However, since we are placing our
	output into the same file we read the input from, we may have
	to change the size of the file.</para>

      <para>The <function role="syscall">ftruncate</function> system
	call allows us to do just that.  Despite its somewhat
	misleading name, the <function
	  role="syscall">ftruncate</function> system call can be used
	to both truncate the file (make it smaller) and to grow
	it.</para>

      <para>And yes, we will find two versions of <function
	  role="syscall">ftruncate</function> in
	<filename>syscalls.master</filename>, an older one (130), and
	a newer one (201).  We will use the newer one:</para>

      <programlisting>201	STD	BSD	{ int ftruncate(int fd, int pad, off_t length); }</programlisting>

      <para>Please note that this one contains a <varname>int
	  pad</varname> again.</para>
    </sect2>

    <sect2 xml:id="x86-ftuc">
      <title>ftuc</title>

      <para>We now know everything we need to write
	<application>ftuc</application>.  We start by adding some new
	lines in <filename>system.inc</filename>.  First, we define
	some constants and structures, somewhere at or near the
	beginning of the file:</para>

      <programlisting>;;;;;;; open flags
%define	O_RDONLY	0
%define	O_WRONLY	1
%define	O_RDWR	2

;;;;;;; mmap flags
%define	PROT_NONE	0
%define	PROT_READ	1
%define	PROT_WRITE	2
%define	PROT_EXEC	4
;;
%define	MAP_SHARED	0001h
%define	MAP_PRIVATE	0002h

;;;;;;; stat structure
struc	stat
st_dev		resd	1	; = 0
st_ino		resd	1	; = 4
st_mode		resw	1	; = 8, size is 16 bits
st_nlink	resw	1	; = 10, ditto
st_uid		resd	1	; = 12
st_gid		resd	1	; = 16
st_rdev		resd	1	; = 20
st_atime	resd	1	; = 24
st_atimensec	resd	1	; = 28
st_mtime	resd	1	; = 32
st_mtimensec	resd	1	; = 36
st_ctime	resd	1	; = 40
st_ctimensec	resd	1	; = 44
st_size		resd	2	; = 48, size is 64 bits
st_blocks	resd	2	; = 56, ditto
st_blksize	resd	1	; = 64
st_flags	resd	1	; = 68
st_gen		resd	1	; = 72
st_lspare	resd	1	; = 76
st_qspare	resd	4	; = 80
endstruc</programlisting>

      <para>We define the new syscalls:</para>

      <programlisting>%define	SYS_mmap	197
%define	SYS_munmap	73
%define	SYS_fstat	189
%define	SYS_ftruncate	201</programlisting>

      <para>We add the macros for their use:</para>

      <programlisting>%macro	sys.mmap	0
	system	SYS_mmap
%endmacro

%macro	sys.munmap	0
	system	SYS_munmap
%endmacro

%macro	sys.ftruncate	0
	system	SYS_ftruncate
%endmacro

%macro	sys.fstat	0
	system	SYS_fstat
%endmacro</programlisting>

      <para>And here is our code:</para>

      <programlisting>;;;;;;; Fast Text-to-Unix Conversion (ftuc.asm) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Started:	21-Dec-2000
;; Updated:	22-Dec-2000
;;
;; Copyright 2000 G. Adam Stanislav.
;; All rights reserved.
;;
;;;;;;; v.1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
%include	'system.inc'

section	.data
	db	'Copyright 2000 G. Adam Stanislav.', 0Ah
	db	'All rights reserved.', 0Ah
usg	db	'Usage: ftuc filename', 0Ah
usglen	equ	$-usg
co	db	"ftuc: Can't open file.", 0Ah
colen	equ	$-co
fae	db	'ftuc: File access error.', 0Ah
faelen	equ	$-fae
ftl	db	'ftuc: File too long, use regular tuc instead.', 0Ah
ftllen	equ	$-ftl
mae	db	'ftuc: Memory allocation error.', 0Ah
maelen	equ	$-mae

section	.text

align 4
memerr:
	push	dword maelen
	push	dword mae
	jmp	short error

align 4
toolong:
	push	dword ftllen
	push	dword ftl
	jmp	short error

align 4
facerr:
	push	dword faelen
	push	dword fae
	jmp	short error

align 4
cantopen:
	push	dword colen
	push	dword co
	jmp	short error

align 4
usage:
	push	dword usglen
	push	dword usg

error:
	push	dword stderr
	sys.write

	push	dword 1
	sys.exit

align 4
global	_start
_start:
	pop	eax		; argc
	pop	eax		; program name
	pop	ecx		; file to convert
	jecxz	usage

	pop	eax
	or	eax, eax	; Too many arguments?
	jne	usage

	; Open the file
	push	dword O_RDWR
	push	ecx
	sys.open
	jc	cantopen

	mov	ebp, eax	; Save fd

	sub	esp, byte stat_size
	mov	ebx, esp

	; Find file size
	push	ebx
	push	ebp		; fd
	sys.fstat
	jc	facerr

	mov	edx, [ebx + st_size + 4]

	; File is too long if EDX != 0 ...
	or	edx, edx
	jne	near toolong
	mov	ecx, [ebx + st_size]
	; ... or if it is above 2 GB
	or	ecx, ecx
	js	near toolong

	; Do nothing if the file is 0 bytes in size
	jecxz	.quit

	; Map the entire file in memory
	push	edx
	push	edx		; starting at offset 0
	push	edx		; pad
	push	ebp		; fd
	push	dword MAP_SHARED
	push	dword PROT_READ | PROT_WRITE
	push	ecx		; entire file size
	push	edx		; let system decide on the address
	sys.mmap
	jc	near memerr

	mov	edi, eax
	mov	esi, eax
	push	ecx		; for SYS_munmap
	push	edi

	; Use EBX for state machine
	mov	ebx, ordinary
	mov	ah, 0Ah
	cld

.loop:
	lodsb
	call	ebx
	loop	.loop

	cmp	ebx, ordinary
	je	.filesize

	; Output final lf
	mov	al, ah
	stosb
	inc	edx

.filesize:
	; truncate file to new size
	push	dword 0		; high dword
	push	edx		; low dword
	push	eax		; pad
	push	ebp
	sys.ftruncate

	; close it (ebp still pushed)
	sys.close

	add	esp, byte 16
	sys.munmap

.quit:
	push	dword 0
	sys.exit

align 4
ordinary:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	stosb
	inc	edx
	ret

align 4
.cr:
	mov	ebx, cr
	ret

align 4
.lf:
	mov	ebx, lf
	ret

align 4
cr:
	cmp	al, 0Dh
	je	.cr

	cmp	al, ah
	je	.lf

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	al, ah
	stosb
	inc	edx
	ret

align 4
lf:
	cmp	al, ah
	je	.lf

	cmp	al, 0Dh
	je	.cr

	xchg	al, ah
	stosb
	inc	edx

	xchg	al, ah
	stosb
	inc	edx
	mov	ebx, ordinary
	ret

align 4
.cr:
	mov	ebx, ordinary
	mov	al, ah
	; fall through

.lf:
	stosb
	inc	edx
	ret</programlisting>

      <warning>
	<para>Do not use this program on files stored on a disk
	  formatted by <acronym>&ms-dos;</acronym> or &windows;.
	  There seems to be a subtle bug in the FreeBSD code when
	  using <function role="syscall">mmap</function> on these
	  drives mounted under FreeBSD: If the file is over a certain
	  size, <function role="syscall">mmap</function> will just
	  fill the memory with zeros, and then copy them to the file
	  overwriting its contents.</para>
      </warning>
    </sect2>
  </sect1>

  <sect1 xml:id="x86-one-pointed-mind">
    <title>One-Pointed Mind</title>

    <para>As a student of Zen, I like the idea of a one-pointed mind:
      Do one thing at a time, and do it well.</para>

    <para>This, indeed, is very much how &unix; works as well.  While
      a typical &windows; application is attempting to do everything
      imaginable (and is, therefore, riddled with bugs), a typical
      &unix; program does only one thing, and it does it well.</para>

    <para>The typical &unix; user then essentially assembles his own
      applications by writing a shell script which combines the
      various existing programs by piping the output of one program to
      the input of another.</para>

    <para>When writing your own &unix; software, it is generally a
      good idea to see what parts of the problem you need to solve can
      be handled by existing programs, and only write your own
      programs for that part of the problem that you do not have an
      existing solution for.</para>

    <sect2 xml:id="x86-csv">
      <title>CSV</title>

      <para>I will illustrate this principle with a specific real-life
	example I was faced with recently:</para>

      <para>I needed to extract the 11th field of each record from a
	database I downloaded from a web site.  The database was a
	<acronym>CSV</acronym> file, i.e., a list of
	<emphasis>comma-separated values</emphasis>.  That is quite
	a standard format for sharing data among people who may be
	using different database software.</para>

      <para>The first line of the file contains the list of various
	fields separated by commas.  The rest of the file contains the
	data listed line by line, with values separated by
	commas.</para>

      <para>I tried <application>awk</application>, using the comma as
	a separator.  But because several lines contained a quoted
	comma, <application>awk</application> was extracting the wrong
	field from those lines.</para>

      <para>Therefore, I needed to write my own software to extract
	the 11th field from the <acronym>CSV</acronym> file.  However,
	going with the &unix; spirit, I only needed to write a simple
	filter that would do the following:</para>

      <itemizedlist>
	<listitem>
	  <para>Remove the first line from the file;</para>
	</listitem>

	<listitem>
	  <para>Change all unquoted commas to a different
	    character;</para>
	</listitem>

	<listitem>
	  <para>Remove all quotation marks.</para>
	</listitem>
      </itemizedlist>

      <para>Strictly speaking, I could use
	<application>sed</application> to remove the first line from
	the file, but doing so in my own program was very easy, so I
	decided to do it and reduce the size of the pipeline.</para>

      <para>At any rate, writing a program like this took me about
	20 minutes.  Writing a program that extracts the 11th field
	from the <acronym>CSV</acronym> file would take a lot longer,
	and I could not reuse it to extract some other field from some
	other database.</para>

      <para>This time I decided to let it do a little more work than a
	typical tutorial program would:</para>

      <itemizedlist>
	<listitem>
	  <para>It parses its command line for options;</para>
	</listitem>

	<listitem>
	  <para>It displays proper usage if it finds wrong
	    arguments;</para>
	</listitem>

	<listitem>
	  <para>It produces meaningful error messages.</para>
	</listitem>
      </itemizedlist>

      <para>Here is its usage message:</para>

      <screen>Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]</screen>

      <para>All parameters are optional, and can appear in any
	order.</para>

      <para>The <parameter>-t</parameter> parameter declares what to
	replace the commas with.  The <constant>tab</constant> is the
	default here.  For example, <parameter>-t;</parameter> will
	replace all unquoted commas with semicolons.</para>

      <para>I did not need the <parameter>-c</parameter> option, but
	it may come in handy in the future.  It lets me declare that I
	want a character other than a comma replaced with something
	else.  For example, <parameter>-c@</parameter> will replace
	all at signs (useful if you want to split a list of email
	addresses to their user names and domains).</para>

      <para>The <parameter>-p</parameter> option preserves the first
	line, i.e., it does not delete it.  By default, we delete the
	first line because in a <acronym>CSV</acronym> file it
	contains the field names rather than data.</para>

      <para>The <parameter>-i</parameter> and
	<parameter>-o</parameter> options let me specify the input and
	the output files.  Defaults are <filename>stdin</filename> and
	<filename>stdout</filename>, so this is a regular &unix;
	filter.</para>

      <para>I made sure that both <parameter>-i filename</parameter>
	and <parameter>-ifilename</parameter> are accepted.  I also
	made sure that only one input and one output files may be
	specified.</para>

      <para>To get the 11th field of each record, I can now do:</para>

      <screen>&prompt.user; <userinput>csv '-t;' <replaceable>data.csv</replaceable> | awk '-F;' '{print $11}'</userinput></screen>

      <para>The code stores the options (except for the file
	descriptors) in <varname role="register">EDX</varname>: The
	comma in <varname role="register">DH</varname>, the new
	separator in <varname role="register">DL</varname>, and the
	flag for the <parameter>-p</parameter> option in the highest
	bit of <varname role="register">EDX</varname>, so a check for
	its sign will give us a quick decision what to do.</para>

      <para>Here is the code:</para>

      <programlisting>;;;;;;; csv.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Convert a comma-separated file to a something-else separated file.
;
; Started:	31-May-2001
; Updated:	 1-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	'system.inc'

%define	BUFSIZE	2048

section	.data
fd.in	dd	stdin
fd.out	dd	stdout
usg	db	'Usage: csv [-t&lt;delim&gt;] [-c&lt;comma&gt;] [-p] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]', 0Ah
usglen	equ	$-usg
iemsg	db	"csv: Can't open input file", 0Ah
iemlen	equ	$-iemsg
oemsg	db	"csv: Can't create output file", 0Ah
oemlen	equ	$-oemsg

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE

section	.text
align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	mov	edx, (',' &lt;&lt; 8) | 9

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .init		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], '-'
	jne	usage

	inc	ecx
	mov	ax, [ecx]

.o:
	cmp	al, 'o'
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	inc	ecx
	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, 'i'
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	inc	ecx
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, 'p'
	jne	.t
	or	ah, ah
	jne	near usage
	or	edx, 1 &lt;&lt; 31
	jmp	.arg

.t:
	cmp	al, 't'		; redefine output delimiter
	jne	.c
	or	ah, ah
	je	near usage
	mov	dl, ah
	jmp	.arg

.c:
	cmp	al, 'c'
	jne	near usage
	or	ah, ah
	je	near usage
	mov	dh, ah
	jmp	.arg

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	mov	edi, obuffer

	; See if we are to preserve the first line
	or	edx, edx
	js	.loop

.firstline:
	; get rid of the first line
	call	getchar
	cmp	al, 0Ah
	jne	.firstline

.loop:
	; read a byte from stdin
	call	getchar

	; is it a comma (or whatever the user asked for)?
	cmp	al, dh
	jne	.quote

	; Replace the comma with a tab (or whatever the user wants)
	mov	al, dl

.put:
	call	putchar
	jmp	short .loop

.quote:
	cmp	al, '"'
	jne	.put

	; Print everything until you get another quote or EOL. If it
	; is a quote, skip it. If it is EOL, print it.
.qloop:
	call	getchar
	cmp	al, '"'
	je	.loop

	cmp	al, 0Ah
	je	.put

	call	putchar
	jmp	short .qloop

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.done
	sub	eax, eax
	ret

align 4
.done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	; return success
	push	dword 0
	sys.exit

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret</programlisting>

      <para>Much of it is taken from <filename>hex.asm</filename>
	above.  But there is one important difference: I no longer
	call <function>write</function> whenever I am outputting a
	line feed.  Yet, the code can be used interactively.</para>

      <para>I have found a better solution for the interactive problem
	since I first started writing this chapter.  I wanted to
	make sure each line is printed out separately only when
	needed.  After all, there is no need to flush out every line
	when used non-interactively.</para>

      <para>The new solution I use now is to call
	<function>write</function> every time I find the input buffer
	  empty.  That way, when running in the interactive mode, the
	  program reads one line from the user's keyboard, processes
	  it, and sees its input buffer is empty.  It flushes its
	  output and reads the next line.</para>

	<sect3 xml:id="x86-buffered-dark-side">
	  <title>The Dark Side of Buffering</title>

	  <para>This change prevents a mysterious lockup in a very
	    specific case.  I refer to it as the <emphasis>dark side
	      of buffering</emphasis>, mostly because it presents a
	    danger that is not quite obvious.</para>

	  <para>It is unlikely to happen with a program like the
	    <application>csv</application> above, so let us consider
	    yet another filter: In this case we expect our input to be
	    raw data representing color values, such as the
	    <emphasis>red</emphasis>, <emphasis>green</emphasis>, and
	    <emphasis>blue</emphasis> intensities of a pixel.  Our
	    output will be the negative of our input.</para>

	  <para>Such a filter would be very simple to write.  Most of
	    it would look just like all the other filters we have
	    written so far, so I am only going to show you its inner
	    loop:</para>

	  <programlisting>.loop:
	call	getchar
	not	al		; Create a negative
	call	putchar
	jmp	short .loop</programlisting>

	  <para>Because this filter works with raw data, it is
	    unlikely to be used interactively.</para>

	  <para>But it could be called by image manipulation software.
	    And, unless it calls <function>write</function> before
	    each call to <function>read</function>, chances are it
	    will lock up.</para>

	  <para>Here is what might happen:</para>

	  <procedure>
	    <step>
	      <para>The image editor will load our filter using the C
		function <function>popen()</function>.</para>
	    </step>

	    <step>
	      <para>It will read the first row of pixels from a bitmap
		or pixmap.</para>
	    </step>

	    <step>
	      <para>It will write the first row of pixels to the
		<emphasis>pipe</emphasis> leading to the
		<varname>fd.in</varname> of our filter.</para>
	    </step>

	    <step>
	      <para>Our filter will read each pixel from its input,
		turn it to a negative, and write it to its output
		buffer.</para>
	    </step>

	    <step>
	      <para>Our filter will call <function>getchar</function>
		to fetch the next pixel.</para>
	    </step>

	    <step>
	      <para><function>getchar</function> will find an empty
		input buffer, so it will call
		<function>read</function>.</para>
	    </step>

	    <step>
	      <para><function>read</function> will call the <function
		  role="syscall">SYS_read</function> system
		call.</para>
	    </step>

	    <step>
	      <para>The <emphasis>kernel</emphasis> will suspend our
		filter until the image editor sends more data to the
		pipe.</para>
	    </step>

	    <step>
	      <para>The image editor will read from the other pipe,
		connected to the <varname>fd.out</varname> of our
		filter so it can set the first row of the output image
		<emphasis>before</emphasis> it sends us the second row
		of the input.</para>
	    </step>

	    <step>
	      <para>The <emphasis>kernel</emphasis> suspends the image
		editor until it receives some output from our filter,
		so it can pass it on to the image editor.</para>
	    </step>
	  </procedure>

	  <para>At this point our filter waits for the image editor to
	    send it more data to process, while the image editor is
	    waiting for our filter to send it the result of the
	    processing of the first row.  But the result sits in our
	    output buffer.</para>

	  <para>The filter and the image editor will continue waiting
	    for each other forever (or, at least, until they are
	    killed).  Our software has just entered a <link
	      linkend="secure-race-conditions">race
	      condition</link>.</para>

	  <para>This problem does not exist if our filter flushes its
	    output buffer <emphasis>before</emphasis> asking the
	    <emphasis>kernel</emphasis> for more input data.</para>
	</sect3>
      </sect2>
    </sect1>

    <sect1 xml:id="x86-fpu">
      <title>Using the <acronym>FPU</acronym></title>

      <para>Strangely enough, most of assembly language literature
	does not even mention the existence of the
	<acronym>FPU</acronym>, or <emphasis>floating point
	  unit</emphasis>, let alone discuss programming it.</para>

      <para>Yet, never does assembly language shine more than when we
	create highly optimized <acronym>FPU</acronym> code by doing
	things that can be done <emphasis>only</emphasis> in assembly
	language.</para>

      <sect2 xml:id="x86-fpu-organization">
	<title>Organization of the <acronym>FPU</acronym></title>

	<para>The <acronym>FPU</acronym> consists of 8 80&ndash;bit
	  floating&ndash;point registers.  These are organized in a
	  stack fashion&mdash;you can <function>push</function> a
	  value on <acronym>TOS</acronym> (<emphasis>top of
	    stack</emphasis>) and you can <function>pop</function>
	  it.</para>

	<para>That said, the assembly language op codes are not
	  <function role="opcode">push</function> and <function
	    role="opcode">pop</function> because those are already
	  taken.</para>

	<para>You can <function>push</function> a value on
	  <acronym>TOS</acronym> by using <function
	    role="opcode">fld</function>, <function
	    role="opcode">fild</function>, and <function
	    role="opcode">fbld</function>.  Several other op codes let
	  you <function>push</function> many common
	  <emphasis>constants</emphasis>&mdash;such as
	  <emphasis>pi</emphasis>&mdash;on the
	  <acronym>TOS</acronym>.</para>

	<para>Similarly, you can <function>pop</function> a value by
	  using <function role="opcode">fst</function>, <function
	    role="opcode">fstp</function>, <function
	    role="opcode">fist</function>, <function
	    role="opcode">fistp</function>, and <function
	    role="opcode">fbstp</function>.  Actually, only the op
	  codes that end with a <emphasis>p</emphasis> will literally
	  <function>pop</function> the value, the rest will
	  <function>store</function> it somewhere else without
	  removing it from the <acronym>TOS</acronym>.</para>

	<para>We can transfer the data between the
	  <acronym>TOS</acronym> and the computer memory either as a
	  32&ndash;bit, 64&ndash;bit, or 80&ndash;bit
	  <emphasis>real</emphasis>, a 16&ndash;bit, 32&ndash;bit, or
	  64&ndash;bit <emphasis>integer</emphasis>, or an
	  80&ndash;bit <emphasis>packed decimal</emphasis>.</para>

	<para>The 80&ndash;bit <emphasis>packed decimal</emphasis> is
	  a special case of <emphasis>binary coded decimal</emphasis>
	  which is very convenient when converting between the
	  <acronym>ASCII</acronym> representation of data and the
	  internal data of the <acronym>FPU</acronym>.  It allows us
	  to use 18 significant digits.</para>

	<para>No matter how we represent data in the memory, the
	  <acronym>FPU</acronym> always stores it in the 80&ndash;bit
	  <emphasis>real</emphasis> format in its registers.</para>

	<para>Its internal precision is at least 19 decimal digits, so
	  even if we choose to display results as
	  <acronym>ASCII</acronym> in the full 18&ndash;digit
	  precision, we are still showing correct results.</para>

	<para>We can perform mathematical operations on the
	  <acronym>TOS</acronym>: We can calculate its
	  <emphasis>sine</emphasis>, we can <emphasis>scale</emphasis>
	  it (i.e., we can multiply or divide it by a power of 2), we
	  can calculate its base&ndash;2
	  <emphasis>logarithm</emphasis>, and many other
	  things.</para>

	<para>We can also <emphasis>multiply</emphasis> or
	  <emphasis>divide</emphasis> it by, <emphasis>add</emphasis>
	  it to, or <emphasis>subtract</emphasis> it from, any of the
	  <acronym>FPU</acronym> registers (including itself).</para>

	<para>The official Intel op code for the
	  <acronym>TOS</acronym> is <varname
	    role="register">st</varname>, and for the
	  <emphasis>registers</emphasis> <varname
	    role="register">st(0)</varname>&ndash;<varname
	    role="register">st(7)</varname>.  <varname
	    role="register">st</varname> and <varname
	    role="register">st(0)</varname>, then,
	  refer to the same register.</para>

	<para>For whatever reasons, the original author of
	  <application>nasm</application> has decided to use
	  different op codes, namely <varname
	    role="register">st0</varname>&ndash;<varname
	    role="register">st7</varname>.  In other words, there are
	  no parentheses, and the <acronym>TOS</acronym> is always
	  <varname role="register">st0</varname>, never just
	  <function role="opcode">st</function>.</para>

	<sect3 xml:id="x86-fpu-packed-decimal">
	  <title>The Packed Decimal Format</title>

	  <para>The <emphasis>packed decimal</emphasis> format uses 10
	    bytes (80 bits) of memory to represent 18 digits.  The
	    number represented there is always an
	    <emphasis>integer</emphasis>.</para>

	  <tip>
	    <para>You can use it to get decimal places by multiplying
	      the <acronym>TOS</acronym> by a power of 10
	      first.</para>
	  </tip>

	  <para>The highest bit of the highest byte (byte 9) is the
	    <emphasis>sign bit</emphasis>: If it is set, the number is
	    <emphasis>negative</emphasis>, otherwise, it is
	    <emphasis>positive</emphasis>.  The rest of the bits of
	    this byte are unused/ignored.</para>

	  <para>The remaining 9 bytes store the 18 digits of the
	    number: 2 digits per byte.</para>

	  <para>The <emphasis>more significant digit</emphasis> is
	    stored in the high <emphasis>nibble</emphasis> (4 bits),
	    the <emphasis>less significant digit</emphasis> in the low
	    <emphasis>nibble</emphasis>.</para>

	  <para>That said, you might think that
	    <constant>-1234567</constant> would be stored in the
	    memory like this (using hexadecimal notation):</para>

	  <programlisting>80 00 00 00 00 00 01 23 45 67</programlisting>

	  <para>Alas it is not! As with everything else of Intel make,
	    even the <emphasis>packed decimal</emphasis> is
	    <emphasis>little&ndash;endian</emphasis>.</para>

	  <para>That means our <constant>-1234567</constant> is stored
	    like this:</para>

	  <programlisting>67 45 23 01 00 00 00 00 00 80</programlisting>

	  <para>Remember that, or you will be pulling your hair out in
	    desperation!</para>

	  <note>
	    <para>The book to read&mdash;if you can find it&mdash;is
	      Richard Startz' <link
		xlink:href="http://www.amazon.com/exec/obidos/ASIN/013246604X/whizkidtechnomag">8087/80287/80387
	      for the IBM PC &amp; Compatibles</link>.  Though it does
	      seem to take the fact about the little&ndash;endian
	      storage of the <emphasis>packed decimal</emphasis> for
	      granted.  I kid you not about the desperation of trying
	      to figure out what was wrong with the filter I show
	      below <emphasis>before</emphasis> it occurred to me I
	      should try the little&ndash;endian order even for this
	      type of data.</para>
	  </note>
	</sect3>
      </sect2>

      <sect2 xml:id="x86-pinhole-photography">
	<title>Excursion to Pinhole Photography</title>

	<para>To write meaningful software, we must not only
	  understand our programming tools, but also the
	  field we are creating software for.</para>

	<para>Our next filter will help us whenever we want to build a
	  <emphasis>pinhole camera</emphasis>, so, we need some
	  background in <emphasis>pinhole photography</emphasis>
	  before we can continue.</para>

	<sect3 xml:id="x86-camera">
	  <title>The Camera</title>

	  <para>The easiest way to describe any camera ever built is
	    as some empty space enclosed in some lightproof material,
	    with a small hole in the enclosure.</para>

	  <para>The enclosure is usually sturdy (e.g., a box), though
	    sometimes it is flexible (the bellows).  It is quite dark
	    inside the camera.  However, the hole lets light rays in
	    through a single point (though in some cases there may be
	    several).  These light rays form an image, a
	    representation of whatever is outside the camera, in front
	    of the hole.</para>

	  <para>If some light sensitive material (such as film) is
	    placed inside the camera, it can capture the image.</para>

	  <para>The hole often contains a <emphasis>lens</emphasis>,
	    or a lens assembly, often called the
	    <emphasis>objective</emphasis>.</para>
	</sect3>

	<sect3 xml:id="x86-the-pinhole">
	  <title>The Pinhole</title>

	  <para>But, strictly speaking, the lens is not necessary: The
	    original cameras did not use a lens but a
	    <emphasis>pinhole</emphasis>.  Even today,
	    <emphasis>pinholes</emphasis> are used, both as a tool to
	    study how cameras work, and to achieve a special kind of
	    image.</para>

	  <para>The image produced by the <emphasis>pinhole</emphasis>
	    is all equally sharp.  Or <emphasis>blurred</emphasis>.
	    There is an ideal size for a pinhole: If it is either
	    larger or smaller, the image loses its sharpness.</para>
	</sect3>

	<sect3 xml:id="x86-focal-length">
	  <title>Focal Length</title>

	  <para>This ideal pinhole diameter is a function of the
	    square root of <emphasis>focal length</emphasis>, which is
	    the distance of the pinhole from the film.</para>

	  <programlisting>D = PC * sqrt(FL)</programlisting>

	  <para>In here, <varname>D</varname> is the ideal diameter of
	    the pinhole, <varname>FL</varname> is the focal length,
	    and <constant>PC</constant> is a pinhole constant.
	    According to Jay Bender, its value is
	    <constant>0.04</constant>, while Kenneth Connors has
	    determined it to be <constant>0.037</constant>.  Others
	    have proposed other values.  Plus, this value is for the
	    daylight only: Other types of light will require a
	    different constant, whose value can only be determined by
	    experimentation.</para>
	</sect3>

	<sect3 xml:id="x86-f-number">
	  <title>The F&ndash;Number</title>

	  <para>The f&ndash;number is a very useful measure of how
	    much light reaches the film.  A light meter can determine
	    that, for example, to expose a film of specific
	    sensitivity with f5.6 mkay require the exposure to last
	    1/1000 sec.</para>

	  <para>It does not matter whether it is a 35&ndash;mm
	    camera, or a 6x9cm camera, etc.  As long as we know the
	    f&ndash;number, we can determine the proper
	    exposure.</para>

	  <para>The f&ndash;number is easy to calculate:</para>

	  <programlisting>F = FL / D</programlisting>

	  <para>In other words, the f&ndash;number equals the focal
	    length divided by the diameter of the pinhole.  It also
	    means a higher f&ndash;number either implies a smaller
	    pinhole or a larger focal distance, or both.  That, in
	    turn, implies, the higher the f&ndash;number, the longer
	    the exposure has to be.</para>

	  <para>Furthermore, while pinhole diameter and focal distance
	    are one&ndash;dimensional measurements, both, the film and
	    the pinhole, are two&ndash;dimensional.  That means that
	    if you have measured the exposure at f&ndash;number
	    <varname>A</varname> as <varname>t</varname>, then the
	    exposure at f&ndash;number <varname>B</varname> is:</para>

	  <programlisting>t * (B / A)&#178;</programlisting>
	</sect3>

	<sect3 xml:id="x86-normalized-f-number">
	  <title>Normalized F&ndash;Number</title>

	  <para>While many modern cameras can change the diameter of
	    their pinhole, and thus their f&ndash;number, quite
	    smoothly and gradually, such was not always the
	    case.</para>

	  <para>To allow for different f&ndash;numbers, cameras
	    typically contained a metal plate with several holes of
	    different sizes drilled to them.</para>

	  <para>Their sizes were chosen according to the above formula
	    in such a way that the resultant f&ndash;number was one
	    of standard f&ndash;numbers used on all cameras
	    everywhere.  For example, a very old Kodak Duaflex IV
	    camera in my possession has three such holes for
	    f&ndash;numbers 8, 11, and 16.</para>

	  <para>A more recently made camera may offer f&ndash;numbers
	    of 2.8, 4, 5.6, 8, 11, 16, 22, and 32 (as well as others).
	    These numbers were not chosen arbitrarily: They all are
	    powers of the square root of 2, though they may be rounded
	    somewha.</para>
	</sect3>

	<sect3 xml:id="x86-f-stop">
	  <title>The F&ndash;Stop</title>

	  <para>A typical camera is designed in such a way that
	    setting any of the normalized f&ndash;numbers changes the
	    feel of the dial.  It will naturally
	    <emphasis>stop</emphasis> in that position.  Because of
	    that, these positions of the dial are called
	    f&ndash;stops.</para>

	  <para>Since the f&ndash;numbers at each stop are powers of
	    the square root of 2, moving the dial by 1 stop will
	    double the amount of light required for proper exposure.
	    Moving it by 2 stops will quadruple the required exposure.
	    Moving the dial by 3 stops will require the increase in
	    exposure 8 times, etc.</para>
	</sect3>
      </sect2>

      <sect2 xml:id="x86-pinhole-software">
	<title>Designing the Pinhole Software</title>

	<para>We are now ready to decide what exactly we want our
	  pinhole software to do.</para>

	<sect3 xml:id="xpinhole-processing-input">
	  <title>Processing Program Input</title>

	  <para>Since its main purpose is to help us design a working
	    pinhole camera, we will use the <emphasis>focal
	      length</emphasis> as the input to the program.  This is
	    something we can determine without software: Proper focal
	    length is determined by the size of the film and by the
	    need to shoot "regular" pictures, wide angle pictures, or
	    telephoto pictures.</para>

	  <para>Most of the programs we have written so far worked
	    with individual characters, or bytes, as their input: The
	    <application>hex</application> program converted
	    individual bytes into a hexadecimal number, the
	    <application>csv</application> program either let a
	    character through, or deleted it, or changed it to a
	    different character, etc.</para>

	  <para>One program, <application>ftuc</application> used the
	    state machine to consider at most two input bytes at a
	    time.</para>

	  <para>But our <application>pinhole</application> program
	    cannot just work with individual characters, it has to
	    deal with larger syntactic units.</para>

	  <para>For example, if we want the program to calculate the
	    pinhole diameter (and other values we will discuss later)
	    at the focal lengths of <constant>100 mm</constant>,
	    <constant>150 mm</constant>, and <constant>210
	      mm</constant>, we may want to enter something like
	    this:</para>

	  <screen><userinput>100, 150, 210</userinput></screen>

	  <para>Our program needs to consider more than a single byte
	    of input at a time.  When it sees the first
	    <constant>1</constant>, it must understand it is seeing
	    the first digit of a decimal number.  When it sees the
	    <constant>0</constant> and the other
	    <constant>0</constant>, it must know it is seeing more
	    digits of the same number.</para>

	  <para>When it encounters the first comma, it must know it is
	    no longer receiving the digits of the first number.  It
	    must be able to convert the digits of the first number
	    into the value of <constant>100</constant>.  And the
	    digits of the second number into the value of
	    <constant>150</constant>.  And, of course, the digits of
	    the third number into the numeric value of
	    <constant>210</constant>.</para>

	  <para>We need to decide what delimiters to accept: Do the
	    input numbers have to be separated by a comma? If so, how
	    do we treat two numbers separated by something
	    else?</para>

	  <para>Personally, I like to keep it simple.  Something
	    either is a number, so I process it.  Or it is not a
	    number, so I discard it.  I do not like the computer
	    complaining about me typing in an extra character when it
	    is <emphasis>obvious</emphasis> that it is an extra
	    character.  Duh!</para>

	  <para>Plus, it allows me to break up the monotony of
	    computing and type in a query instead of just a
	    number:</para>

	  <screen><userinput>What is the best pinhole diameter for the
	    focal length of 150?</userinput></screen>

	  <para>There is no reason for the computer to spit out a
	    number of complaints:</para>

	  <screen>Syntax error: What
Syntax error: is
Syntax error: the
Syntax error: best</screen>

	  <para>Et cetera, et cetera, et cetera.</para>

	  <para>Secondly, I like the <constant>#</constant> character
	    to denote the start of a comment which extends to the end
	    of the line.  This does not take too much effort to code,
	    and lets me treat input files for my software as
	    executable scripts.</para>

	  <para>In our case, we also need to decide what units the
	    input should come in: We choose
	    <emphasis>millimeters</emphasis> because that is how most
	    photographers measure the focus length.</para>

	  <para>Finally, we need to decide whether to allow the use of
	    the decimal point (in which case we must also consider the
	    fact that much of the world uses a decimal
	    <emphasis>comma</emphasis>).</para>

	  <para>In our case allowing for the decimal point/comma would
	    offer a false sense of precision: There is little if any
	    noticeable difference between the focus lengths of
	    <constant>50</constant> and <constant>51</constant>, so
	    allowing the user to input something like
	    <constant>50.5</constant> is not a good idea.  This is
	    my opinion, mind you, but I am the one writing this
	    program.  You can make other choices in yours, of
	    course.</para>
	</sect3>

	<sect3 xml:id="x86-pinhole-options">
	  <title>Offering Options</title>

	  <para>The most important thing we need to know when building
	    a pinhole camera is the diameter of the pinhole.  Since we
	    want to shoot sharp images, we will use the above formula
	    to calculate the pinhole diameter from focal length.  As
	    experts are offering several different values for the
	    <constant>PC</constant> constant, we will need to have the
	    choice.</para>

	  <para>It is traditional in &unix; programming to have two
	    main ways of choosing program parameters, plus to have a
	    default for the time the user does not make a
	    choice.</para>

	  <para>Why have two ways of choosing?</para>

	  <para>One is to allow a (relatively)
	    <emphasis>permanent</emphasis> choice that applies
	    automatically each time the software is run without us
	    having to tell it over and over what we want it to
	    do.</para>

	  <para>The permanent choices may be stored in a configuration
	    file, typically found in the user's home directory.  The
	    file usually has the same name as the application but is
	    started with a dot.  Often <emphasis>"rc"</emphasis> is
	    added to the file name.  So, ours could be
	    <filename>~/.pinhole</filename> or
	    <filename>~/.pinholerc</filename>.  (The
	    <filename>~/</filename> means current user's home
	    directory.)</para>

	  <para>The configuration file is used mostly by programs that
	    have many configurable parameters.  Those that have only
	    one (or a few) often use a different method: They expect
	    to find the parameter in an <emphasis>environment
	      variable</emphasis>.  In our case, we might look at an
	    environment variable named
	    <varname>PINHOLE</varname>.</para>

	  <para>Usually, a program uses one or the other of the above
	    methods.  Otherwise, if a configuration file said one
	    thing, but an environment variable another, the program
	    might get confused (or just too complicated).</para>

	  <para>Because we only need to choose
	    <emphasis>one</emphasis> such parameter, we will go with
	    the second method and search the environment for a
	    variable named <varname>PINHOLE</varname>.</para>

	  <para>The other way allows us to make <emphasis>ad
	      hoc</emphasis> decisions: <emphasis>"Though I usually
	      want you to use 0.039, this time I want
	      0.03872."</emphasis>  In other words, it allows us to
	    <emphasis>override</emphasis> the permanent choice.</para>

	  <para>This type of choice is usually done with command line
	    parameters.</para>

	  <para>Finally, a program <emphasis>always</emphasis> needs a
	    <emphasis>default</emphasis>.  The user may not make any
	    choices.  Perhaps he does not know what to choose.
	    Perhaps he is "just browsing." Preferably, the default
	    will be the value most users would choose anyway.  That
	    way they do not need to choose.  Or, rather, they can
	    choose the default without an additional effort.</para>

	  <para>Given this system, the program may find conflicting
	    options, and handle them this way:</para>

	  <procedure>
	    <step>
	      <para>If it finds an <emphasis>ad hoc</emphasis> choice
		(e.g., command line parameter), it should accept that
		choice.  It must ignore any permanent choice and any
		default.</para>
	    </step>

	    <step>
	      <para><emphasis>Otherwise</emphasis>, if it finds a
		permanent option (e.g., an environment variable), it
		should accept it, and ignore the default.</para>
	    </step>

	    <step>
	      <para><emphasis>Otherwise</emphasis>, it should use the
		default.</para>
	    </step>
	  </procedure>

	  <para>We also need to decide what
	    <emphasis>format</emphasis> our <constant>PC</constant>
	    option should have.</para>

	  <para>At first site, it seems obvious to use the
	    <varname>PINHOLE=0.04</varname> format for the
	    environment variable, and <parameter>-p0.04</parameter>
	    for the command line.</para>

	  <para>Allowing that is actually a security risk.  The
	    <constant>PC</constant> constant is a very small number.
	    Naturally, we will test our software using various small
	    values of <constant>PC</constant>.  But what will happen
	    if someone runs the program choosing a huge value?</para>

	  <para>It may crash the program because we have not designed
	    it to handle huge numbers.</para>

	  <para>Or, we may spend more time on the program so it can
	    handle huge numbers.  We might do that if we were writing
	    commercial software for computer illiterate
	    audience.</para>

	  <para>Or, we might say, <emphasis>"Tough! The user should
	      know better.""</emphasis></para>

	  <para>Or, we just may make it impossible for the user to
	    enter a huge number.  This is the approach we will take:
	    We will use an <emphasis>implied 0.</emphasis>
	    prefix.</para>

	  <para>In other words, if the user wants
	    <constant>0.04</constant>, we will expect him to type
	    <parameter>-p04</parameter>, or set
	    <varname>PINHOLE=04</varname> in his environment.  So, if
	    he says <parameter>-p9999999</parameter>, we will
	    interpret it as <constant>0.9999999</constant>&mdash;still
	    ridiculous but at least safer.</para>

	  <para>Secondly, many users will just want to go with either
	    Bender's constant or Connors' constant.  To make it easier
	    on them, we will interpret <parameter>-b</parameter> as
	    identical to <parameter>-p04</parameter>, and
	    <parameter>-c</parameter> as identical to
	    <parameter>-p037</parameter>.</para>
	</sect3>

	<sect3 xml:id="x86-pinhole-output">
	  <title>The Output</title>

	  <para>We need to decide what we want our software to send to
	    the output, and in what format.</para>

	  <para>Since our input allows for an unspecified number of
	    focal length entries, it makes sense to use a traditional
	    database&ndash;style output of showing the result of the
	    calculation for each focal length on a separate line,
	    while separating all values on one line by a
	    <constant>tab</constant> character.</para>

	  <para>Optionally, we should also allow the user to specify
	    the use of the <acronym>CSV</acronym> format we have
	    studied earlier.  In this case, we will print out a line
	    of comma&ndash;separated names describing each field of
	    every line, then show our results as before, but
	    substituting a <constant>comma</constant> for the
	    <constant>tab</constant>.</para>

	  <para>We need a command line option for the
	    <acronym>CSV</acronym> format.  We cannot use
	    <parameter>-c</parameter> because that already means
	    <emphasis>use Connors' constant</emphasis>.  For some
	    strange reason, many web sites refer to
	    <acronym>CSV</acronym> files as <emphasis>"Excel
	      spreadsheet"</emphasis> (though the
	    <acronym>CSV</acronym> format predates Excel).
	    We will, therefore, use the <parameter>-e</parameter>
	    switch to inform our software we want the output in the
	    <acronym>CSV</acronym> format.</para>

	  <para>We will start each line of the output with the focal
	    length.  This may sound repetitious at first, especially
	    in the interactive mode: The user types in the focal
	    length, and we are repeating it.</para>

	  <para>But the user can type several focal lengths on one
	    line.  The input can also come in from a file or from the
	    output of another program.  In that case the user does not
	    see the input at all.</para>

	  <para>By the same token, the output can go to a file which
	    we will want to examine later, or it could go to the
	    printer, or become the input of another program.</para>

	  <para>So, it makes perfect sense to start each line with
	    the focal length as entered by the user.</para>

	  <para>No, wait! Not as entered by the user.  What if the
	    user types in something like this:</para>

	  <screen><userinput>00000000150</userinput></screen>

	  <para>Clearly, we need to strip those leading zeros.</para>

	  <para>So, we might consider reading the user input as is,
	    converting it to binary inside the <acronym>FPU</acronym>,
	    and printing it out from there.</para>

	  <para>But...</para>

	  <para>What if the user types something like this:</para>

	  <screen><userinput>17459765723452353453534535353530530534563507309676764423</userinput></screen>

	  <para>Ha! The packed decimal <acronym>FPU</acronym> format
	    lets us input 18&ndash;digit numbers.  But the user has
	    entered more than 18 digits.  How do we handle
	    that?</para>

	  <para>Well, we <emphasis>could</emphasis> modify our code to
	    read the first 18 digits, enter it to the
	    <acronym>FPU</acronym>, then read more, multiply what we
	    already have on the <acronym>TOS</acronym> by 10 raised to
	    the number of additional digits, then
	    <function>add</function> to it.</para>

	  <para>Yes, we could do that.  But in
	    <emphasis>this</emphasis> program it would be ridiculous
	    (in a different one it may be just the thing to do): Even
	    the circumference of the Earth expressed in millimeters
	    only takes 11 digits.  Clearly, we cannot build a camera
	    that large (not yet, anyway).</para>

	  <para>So, if the user enters such a huge number, he is
	    either bored, or testing us, or trying to break into the
	    system, or playing games&mdash;doing anything but
	    designing a pinhole camera.</para>

	  <para>What will we do?</para>

	  <para>We will slap him in the face, in a manner of
	    speaking:</para>

	  <screen>17459765723452353453534535353530530534563507309676764423	???	???	???	???	???</screen>

	  <para>To achieve that, we will simply ignore any leading
	    zeros.  Once we find a non&ndash;zero digit, we will
	    initialize a counter to <constant>0</constant> and start
	    taking three steps:</para>

	  <procedure>
	    <step>
	      <para>Send the digit to the output.</para>
	    </step>

	    <step>
	      <para>Append the digit to a buffer we will use later to
		produce the packed decimal we can send to the
		<acronym>FPU</acronym>.</para>
	    </step>

	    <step>
	      <para>Increase the counter.</para>
	    </step>
	  </procedure>

	  <para>Now, while we are taking these three steps, we also
	    need to watch out for one of two conditions:</para>

	  <itemizedlist>
	    <listitem>
	      <para>If the counter grows above 18, we stop appending
		to the buffer.  We continue reading the digits and
		sending them to the output.</para>
	    </listitem>

	    <listitem>
	      <para>If, or rather <emphasis>when</emphasis>, the next
		input character is not a digit, we are done inputting
		for now.</para>

	      <para>Incidentally, we can simply discard the
		non&ndash;digit, unless it is a
		<constant>#</constant>, which we must return to the
		input stream.  It starts a comment, so we must see it
		after we are done producing output and start looking
		for more input.</para>
	    </listitem>
	  </itemizedlist>

	  <para>That still leaves one possibility uncovered: If all
	    the user enters is a zero (or several zeros), we will
	    never find a non&ndash;zero to display.</para>

	  <para>We can determine this has happened whenever our
	    counter stays at <constant>0</constant>.  In that case we
	    need to send <constant>0</constant> to the output, and
	    perform another "slap in the face":</para>

	  <screen>0	???	???	???	???	???</screen>

	  <para>Once we have displayed the focal length and determined
	    it is valid (greater than <constant>0</constant> but not
	    exceeding 18 digits), we can calculate the pinhole
	    diameter.</para>

	  <para>It is not by coincidence that
	    <emphasis>pinhole</emphasis> contains the word
	    <emphasis>pin</emphasis>.  Indeed, many a pinhole
	    literally is a <emphasis>pin hole</emphasis>, a hole
	    carefully punched with the tip of a pin.</para>

	  <para>That is because a typical pinhole is very small.  Our
	    formula gets the result in millimeters.  We will multiply
	    it by <constant>1000</constant>, so we can output the
	    result in <emphasis>microns</emphasis>.</para>

	  <para>At this point we have yet another trap to face:
	    <emphasis>Too much precision.</emphasis></para>

	  <para>Yes, the <acronym>FPU</acronym> was designed for high
	    precision mathematics.  But we are not dealing with high
	    precision mathematics.  We are dealing with physics
	    (optics, specifically).</para>

	  <para>Suppose we want to convert a truck into a pinhole
	    camera (we would not be the first ones to do that!).
	    Suppose its box is <constant>12</constant> meters long,
	    so we have the focal length of <constant>12000</constant>.
	    Well, using Bender's constant, it gives us square root of
	    <constant>12000</constant> multiplied by
	    <constant>0.04</constant>, which is
	    <constant>4.381780460</constant> millimeters, or
	    <constant>4381.780460</constant> microns.</para>

	  <para>Put either way, the result is absurdly precise.  Our
	    truck is not <emphasis>exactly</emphasis>
	    <constant>12000</constant> millimeters long.  We did not
	    measure its length with such a precision, so stating we
	    need a pinhole with the diameter of
	    <constant>4.381780460</constant> millimeters is, well,
	    deceiving.  <constant>4.4</constant> millimeters would do
	    just fine.</para>

	  <note>
	    <para>I "only" used ten digits in the above example.
	      Imagine the absurdity of going for all 18!</para>
	  </note>

	  <para>We need to limit the number of significant digits of
	    our result.  One way of doing it is by using an integer
	    representing microns.  So, our truck would need a pinhole
	    with the diameter of <constant>4382</constant> microns.
	    Looking at that number, we still decide that
	    <constant>4400</constant> microns, or
	    <constant>4.4</constant> millimeters is close
	    enough.</para>

	  <para>Additionally, we can decide that no matter how big a
	    result we get, we only want to display four significant
	    digits (or any other number of them, of course).  Alas,
	    the <acronym>FPU</acronym> does not offer rounding to a
	    specific number of digits (after all, it does not view the
	    numbers as decimal but as binary).</para>

	  <para>We, therefore, must devise an algorithm to reduce
	    the number of significant digits.</para>

	  <para>Here is mine (I think it is awkward&mdash;if you know
	    a better one, <emphasis>please</emphasis>, let me
	    know):</para>

	  <procedure>
	    <step>
	      <para>Initialize a counter to
		<constant>0</constant>.</para>
	    </step>

	    <step>
	      <para>While the number is greater than or equal to
		<constant>10000</constant>, divide it by
		<constant>10</constant> and increase the
		counter.</para>
	    </step>

	    <step>
	      <para>Output the result.</para>
	    </step>

	    <step>
	      <para>While the counter is greater than
		<constant>0</constant>, output <constant>0</constant>
		and decrease the counter.</para>
	    </step>
	  </procedure>

	  <note>
	    <para>The <constant>10000</constant> is only good if you
	      want <emphasis>four</emphasis> significant digits.  For
	      any other number of significant digits, replace
	      <constant>10000</constant> with <constant>10</constant>
	      raised to the number of significant digits.</para>
	  </note>

	  <para>We will, then, output the pinhole diameter in microns,
	    rounded off to four significant digits.</para>

	  <para>At this point, we know the <emphasis>focal
	      length</emphasis> and the <emphasis>pinhole
	      diameter</emphasis>.  That means we have enough
	    information to also calculate the
	    <emphasis>f&ndash;number</emphasis>.</para>

	  <para>We will display the f&ndash;number, rounded to four
	    significant digits.  Chances are the f&ndash;number will
	    tell us very little.  To make it more meaningful, we can
	    find the nearest <emphasis>normalized
	    f&ndash;number</emphasis>, i.e., the nearest power of the
	    square root of 2.</para>

	  <para>We do that by multiplying the actual f&ndash;number by
	    itself, which, of course, will give us its
	    <function>square</function>.  We will then calculate its
	    base&ndash;2 logarithm, which is much easier to do than
	    calculating the
	    base&ndash;square&ndash;root&ndash;of&ndash;2 logarithm!
	    We will round the result to the nearest integer.  Next, we
	    will raise 2 to the result.  Actually, the
	    <acronym>FPU</acronym> gives us a good shortcut to do
	    that: We can use the <function
	      role="opcode">fscale</function> op code to "scale" 1,
	    which is analogous to <function
	      role="opcode">shift</function>ing an integer left.
	    Finally, we calculate the square root of it all, and we
	    have the nearest normalized f&ndash;number.</para>

	  <para>If all that sounds overwhelming&mdash;or too much
	    work, perhaps&mdash;it may become much clearer if you see
	    the code.  It takes 9 op codes altogether:</para>

	  <programlisting>fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1</programlisting>

	  <para>The first line, <function
	      role="opcode">fmul st0, st0</function>, squares the
	    contents of the <acronym>TOS</acronym> (top of the stack,
	    same as <varname role="register">st</varname>, called
	    <varname role="register">st0</varname> by
	    <application>nasm</application>).  The <function
	      role="opcode">fld1</function> pushes
	    <constant>1</constant> on the
	    <acronym>TOS</acronym>.</para>

	  <para>The next line, <function role="opcode">fld
	      st1</function>, pushes the square back to the
	    <acronym>TOS</acronym>.  At this point the square is
	    both in <varname role="register">st</varname> and <varname
	      role="register">st(2)</varname> (it will become clear
	    why we leave a second copy on the stack in a moment).
	    <varname role="register">st(1)</varname> contains
	    <constant>1</constant>.</para>

	  <para>Next, <function role="opcode">fyl2x</function>
	    calculates base&ndash;2 logarithm of <varname
	      role="register">st</varname> multiplied by
	    <varname role="register">st(1)</varname>.  That is why we
	    placed <constant>1</constant> on <varname
	      role="register">st(1)</varname> before.</para>

	  <para>At this point, <varname role="register">st</varname>
	    contains the logarithm we have just calculated, <varname
	      role="register">st(1)</varname> contains the square of
	    the actual f&ndash;number we saved for later.</para>

	  <para><function role="opcode">frndint</function> rounds the
	    <acronym>TOS</acronym> to the nearest integer.  <function
	      role="opcode">fld1</function> pushes a
	    <constant>1</constant>.  <function
	      role="opcode">fscale</function> shifts the
	    <constant>1</constant> we have on the
	    <acronym>TOS</acronym> by the value in <varname
	      role="register">st(1)</varname>, effectively raising 2
	    to <varname role="register">st(1)</varname>.</para>

	  <para>Finally, <function role="opcode">fsqrt</function>
	    calculates the square root of the result, i.e., the
	    nearest normalized f&ndash;number.</para>

	  <para>We now have the nearest normalized f&ndash;number on
	    the <acronym>TOS</acronym>, the base&ndash;2 logarithm
	    rounded to the nearest integer in <varname
	      role="register">st(1)</varname>, and the square of the
	    actual f&ndash;number in <varname
	      role="register">st(2)</varname>.  We are saving the
	    value in <varname role="register">st(2)</varname> for
	    later.</para>

	  <para>But we do not need the contents of <varname
	      role="register">st(1)</varname> anymore.  The last line,
	    <function role="opcode">fstp st1</function>, places the
	    contents of <varname role="register">st</varname> to
	    <varname role="register">st(1)</varname>, and pops.  As a
	    result, what was <varname role="register">st(1)</varname>
	    is now <varname role="register">st</varname>, what was
	    <varname role="register">st(2)</varname> is now <varname
	      role="register">st(1)</varname>, etc.  The new <varname
	      role="register">st</varname> contains the normalized
	    f&ndash;number.  The new <varname
	      role="register">st(1)</varname> contains the square of
	    the actual f&ndash;number we have stored there for
	    posterity.</para>

	  <para>At this point, we are ready to output the normalized
	    f&ndash;number.  Because it is normalized, we will not
	    round it off to four significant digits, but will send it
	    out in its full precision.</para>

	  <para>The normalized f-number is useful as long as it is
	    reasonably small and can be found on our light meter.
	    Otherwise we need a different method of determining proper
	    exposure.</para>

	  <para>Earlier we have figured out the formula of calculating
	    proper exposure at an arbitrary f&ndash;number from that
	    measured at a different f&ndash;number.</para>

	  <para>Every light meter I have ever seen can determine
	    proper exposure at f5.6.  We will, therefore, calculate an
	    <emphasis>"f5.6 multiplier,"</emphasis> i.e., by how much
	    we need to multiply the exposure measured at f5.6 to
	    determine the proper exposure for our pinhole
	    camera.</para>

	  <para>From the above formula we know this factor can be
	    calculated by dividing our f&ndash;number (the actual one,
	    not the normalized one) by <constant>5.6</constant>, and
	    squaring the result.</para>

	  <para>Mathematically, dividing the square of our
	    f&ndash;number by the square of <constant>5.6</constant>
	    will give us the same result.</para>

	  <para>Computationally, we do not want to square two numbers
	    when we can only square one.  So, the first solution seems
	    better at first.</para>

	  <para>But...</para>

	  <para><constant>5.6</constant> is a
	    <emphasis>constant</emphasis>.  We do not have to have our
	    <acronym>FPU</acronym> waste precious cycles.  We can just
	    tell it to divide the square of the f&ndash;number by
	    whatever <constant>5.6&#178;</constant> equals to.  Or we
	    can divide the f&ndash;number by <constant>5.6</constant>,
	    and then square the result.  The two ways now seem
	    equal.</para>

	  <para>But, they are not!</para>

	  <para>Having studied the principles of photography above, we
	    remember that the <constant>5.6</constant> is actually
	    square root of 2 raised to the fifth power.  An
	    <emphasis>irrational</emphasis> number.  The square of
	    this number is <emphasis>exactly</emphasis>
	    <constant>32</constant>.</para>

	  <para>Not only is <constant>32</constant> an integer, it is
	    a power of 2.  We do not need to divide the square of the
	    f&ndash;number by <constant>32</constant>.  We only need
	    to use <function role="opcode">fscale</function> to shift
	    it right by five positions.  In the <acronym>FPU</acronym>
	    lingo it means we will <function
	      role="opcode">fscale</function> it with <varname
	      role="register">st(1)</varname> equal to
	    <constant>-5</constant>.  That is <emphasis>much
	      faster</emphasis> than a division.</para>

	  <para>So, now it has become clear why we have saved the
	    square of the f&ndash;number on the top of the
	    <acronym>FPU</acronym> stack.  The calculation of the
	    f5.6 multiplier is the easiest calculation of this entire
	    program! We will output it rounded to four significant
	    digits.</para>

	  <para>There is one more useful number we can calculate:  The
	    number of stops our f&ndash;number is from f5.6.  This may
	    help us if our f&ndash;number is just outside the range of
	    our light meter, but we have a shutter which lets us set
	    various speeds, and this shutter uses stops.</para>

	  <para>Say, our f&ndash;number is 5 stops from f5.6, and the
	    light meter says we should use 1/1000 sec.  Then we can
	    set our shutter speed to 1/1000 first, then move the dial
	    by 5 stops.</para>

	  <para>This calculation is quite easy as well.  All we have
	    to do is to calculate the base-2 logarithm of the f5.6
	    multiplier we had just calculated (though we need its
	    value from before we rounded it off).  We then output the
	    result rounded to the nearest integer.  We do not need to
	    worry about having more than four significant digits in
	    this one: The result is most likely to have only one or
	    two digits anyway.</para>
	</sect3>
      </sect2>

      <sect2 xml:id="x86-fpu-optimizations">
	<title>FPU Optimizations</title>

	<para>In assembly language we can optimize the
	  <acronym>FPU</acronym> code in ways impossible in high
	  languages, including C.</para>

	<para>Whenever a C function needs to calculate a
	  floating&ndash;point value, it loads all necessary variables
	  and constants into <acronym>FPU</acronym> registers.  It
	  then does whatever calculation is required to get the
	  correct result.  Good C compilers can optimize that part of
	  the code really well.</para>

	<para>It "returns" the value by leaving the result on the
	  <acronym>TOS</acronym>.  However, before it returns, it
	  cleans up.  Any variables and constants it used in its
	  calculation are now gone from the
	  <acronym>FPU</acronym>.</para>

	<para>It cannot do what we just did above: We calculated the
	  square of the f&ndash;number and kept it on the stack for
	  later use by another function.</para>

	<para>We <emphasis>knew</emphasis> we would need that value
	  later on.  We also knew we had enough room on the
	  stack (which only has room for 8 numbers) to store it
	  there.</para>

	<para>A C compiler has no way of knowing that a value it has
	  on the stack will be required again in the very near
	  future.</para>

	<para>Of course, the C programmer may know it.  But the only
	  recourse he has is to store the value in a memory
	  variable.</para>

	<para>That means, for one, the value will be changed from the
	  80-bit precision used internally by the
	  <acronym>FPU</acronym> to a C <emphasis>double</emphasis>
	  (64 bits) or even <emphasis>single</emphasis> (32
	  bits).</para>

	<para>That also means that the value must be moved from the
	  <acronym>TOS</acronym> into the memory, and then back again.
	  Alas, of all <acronym>FPU</acronym> operations, the ones
	  that access the computer memory are the slowest.</para>

	<para>So, whenever programming the <acronym>FPU</acronym> in
	  assembly language, look for the ways of keeping intermediate
	  results on the <acronym>FPU</acronym> stack.</para>

	<para>We can take that idea even further! In our program we
	  are using a <emphasis>constant</emphasis> (the one we named
	  <constant>PC</constant>).</para>

	<para>It does not matter how many pinhole diameters we are
	  calculating: 1, 10, 20, 1000, we are always using the same
	  constant.  Therefore, we can optimize our program by keeping
	  the constant on the stack all the time.</para>

	<para>Early on in our program, we are calculating the value of
	  the above constant.  We need to divide our input by
	  <constant>10</constant> for every digit in the
	  constant.</para>

	<para>It is much faster to multiply than to divide.  So, at
	  the start of our program, we divide <constant>10</constant>
	  into <constant>1</constant> to obtain
	  <constant>0.1</constant>, which we then keep on the stack:
	  Instead of dividing the input by <constant>10</constant> for
	  every digit, we multiply it by
	  <constant>0.1</constant>.</para>

	<para>By the way, we do not input <constant>0.1</constant>
	  directly, even though we could.  We have a reason for that:
	  While <constant>0.1</constant> can be expressed with just
	  one decimal place, we do not know how many
	  <emphasis>binary</emphasis> places it takes.  We, therefore,
	  let the <acronym>FPU</acronym> calculate its binary value to
	  its own high precision.</para>

	<para>We are using other constants: We multiply the pinhole
	  diameter by <constant>1000</constant> to convert it from
	  millimeters to microns.  We compare numbers to
	  <constant>10000</constant> when we are rounding them off to
	  four significant digits.  So, we keep both,
	  <constant>1000</constant> and <constant>10000</constant>, on
	  the stack.  And, of course, we reuse the
	  <constant>0.1</constant> when rounding off numbers to four
	  digits.</para>

	<para>Last but not least, we keep <constant>-5</constant> on
	  the stack.  We need it to scale the square of the
	  f&ndash;number, instead of dividing it by
	  <constant>32</constant>.  It is not by coincidence we load
	  this constant last.  That makes it the top of the stack when
	  only the constants are on it.  So, when the square of the
	  f&ndash;number is being scaled, the <constant>-5</constant>
	  is at <varname role="register">st(1)</varname>, precisely
	  where <function role="opcode">fscale</function> expects it
	  to be.</para>

	<para>It is common to create certain constants from scratch
	  instead of loading them from the memory.  That is what we
	  are doing with <constant>-5</constant>:</para>

	<programlisting>	fld1			; TOS =  1
	fadd	st0, st0	; TOS =  2
	fadd	st0, st0	; TOS =  4
	fld1			; TOS =  1
	faddp	st1, st0	; TOS =  5
	fchs			; TOS = -5</programlisting>

      <para>We can generalize all these optimizations into one rule:
	<emphasis>Keep repeat values on the stack!</emphasis></para>

      <tip>
	<para><emphasis>&postscript;</emphasis> is a
	  stack&ndash;oriented programming language.  There are many
	  more books available about &postscript; than about the
	  <acronym>FPU</acronym> assembly language: Mastering
	  &postscript; will help you master the
	  <acronym>FPU</acronym>.</para>
      </tip>
    </sect2>

    <sect2 xml:id="x86-pinhole-the-code">
      <title><application>pinhole</application>&mdash;The Code</title>

      <programlisting>;;;;;;; pinhole.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Find various parameters of a pinhole camera construction and use
;
; Started:	 9-Jun-2001
; Updated:	10-Jun-2001
;
; Copyright (c) 2001 G. Adam Stanislav
; All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

%include	'system.inc'

%define	BUFSIZE	2048

section	.data
align 4
ten	dd	10
thousand	dd	1000
tthou	dd	10000
fd.in	dd	stdin
fd.out	dd	stdout
envar	db	'PINHOLE='	; Exactly 8 bytes, or 2 dwords long
pinhole	db	'04,', 		; Bender's constant (0.04)
connors	db	'037', 0Ah	; Connors' constant
usg	db	'Usage: pinhole [-b] [-c] [-e] [-p &lt;value&gt;] [-o &lt;outfile&gt;] [-i &lt;infile&gt;]', 0Ah
usglen	equ	$-usg
iemsg	db	"pinhole: Can't open input file", 0Ah
iemlen	equ	$-iemsg
oemsg	db	"pinhole: Can't create output file", 0Ah
oemlen	equ	$-oemsg
pinmsg	db	"pinhole: The PINHOLE constant must not be 0", 0Ah
pinlen	equ	$-pinmsg
toobig	db	"pinhole: The PINHOLE constant may not exceed 18 decimal places", 0Ah
biglen	equ	$-toobig
huhmsg	db	9, '???'
separ	db	9, '???'
sep2	db	9, '???'
sep3	db	9, '???'
sep4	db	9, '???', 0Ah
huhlen	equ	$-huhmsg
header	db	'focal length in millimeters,pinhole diameter in microns,'
	db	'F-number,normalized F-number,F-5.6 multiplier,stops '
	db	'from F-5.6', 0Ah
headlen	equ	$-header

section .bss
ibuffer	resb	BUFSIZE
obuffer	resb	BUFSIZE
dbuffer	resb	20		; decimal input buffer
bbuffer	resb	10		; BCD buffer

section	.text
align 4
huh:
	call	write
	push	dword huhlen
	push	dword huhmsg
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	ret

align 4
perr:
	push	dword pinlen
	push	dword pinmsg
	push	dword stderr
	sys.write
	push	dword 4		; return failure
	sys.exit

align 4
consttoobig:
	push	dword biglen
	push	dword toobig
	push	dword stderr
	sys.write
	push	dword 5		; return failure
	sys.exit

align 4
ierr:
	push	dword iemlen
	push	dword iemsg
	push	dword stderr
	sys.write
	push	dword 1		; return failure
	sys.exit

align 4
oerr:
	push	dword oemlen
	push	dword oemsg
	push	dword stderr
	sys.write
	push	dword 2
	sys.exit

align 4
usage:
	push	dword usglen
	push	dword usg
	push	dword stderr
	sys.write
	push	dword 3
	sys.exit

align 4
global	_start
_start:
	add	esp, byte 8	; discard argc and argv[0]
	sub	esi, esi

.arg:
	pop	ecx
	or	ecx, ecx
	je	near .getenv		; no more arguments

	; ECX contains the pointer to an argument
	cmp	byte [ecx], '-'
	jne	usage

	inc	ecx
	mov	ax, [ecx]
	inc	ecx

.o:
	cmp	al, 'o'
	jne	.i

	; Make sure we are not asked for the output file twice
	cmp	dword [fd.out], stdout
	jne	usage

	; Find the path to output file - it is either at [ECX+1],
	; i.e., -ofile --
	; or in the next argument,
	; i.e., -o file

	or	ah, ah
	jne	.openoutput
	pop	ecx
	jecxz	usage

.openoutput:
	push	dword 420	; file mode (644 octal)
	push	dword 0200h | 0400h | 01h
	; O_CREAT | O_TRUNC | O_WRONLY
	push	ecx
	sys.open
	jc	near oerr

	add	esp, byte 12
	mov	[fd.out], eax
	jmp	short .arg

.i:
	cmp	al, 'i'
	jne	.p

	; Make sure we are not asked twice
	cmp	dword [fd.in], stdin
	jne	near usage

	; Find the path to the input file
	or	ah, ah
	jne	.openinput
	pop	ecx
	or	ecx, ecx
	je near usage

.openinput:
	push	dword 0		; O_RDONLY
	push	ecx
	sys.open
	jc	near ierr		; open failed

	add	esp, byte 8
	mov	[fd.in], eax
	jmp	.arg

.p:
	cmp	al, 'p'
	jne	.c
	or	ah, ah
	jne	.pcheck

	pop	ecx
	or	ecx, ecx
	je	near usage

	mov	ah, [ecx]

.pcheck:
	cmp	ah, '0'
	jl	near usage
	cmp	ah, '9'
	ja	near usage
	mov	esi, ecx
	jmp	.arg

.c:
	cmp	al, 'c'
	jne	.b
	or	ah, ah
	jne	near usage
	mov	esi, connors
	jmp	.arg

.b:
	cmp	al, 'b'
	jne	.e
	or	ah, ah
	jne	near usage
	mov	esi, pinhole
	jmp	.arg

.e:
	cmp	al, 'e'
	jne	near usage
	or	ah, ah
	jne	near usage
	mov	al, ','
	mov	[huhmsg], al
	mov	[separ], al
	mov	[sep2], al
	mov	[sep3], al
	mov	[sep4], al
	jmp	.arg

align 4
.getenv:
	; If ESI = 0, we did not have a -p argument,
	; and need to check the environment for "PINHOLE="
	or	esi, esi
	jne	.init

	sub	ecx, ecx

.nextenv:
	pop	esi
	or	esi, esi
	je	.default	; no PINHOLE envar found

	; check if this envar starts with 'PINHOLE='
	mov	edi, envar
	mov	cl, 2		; 'PINHOLE=' is 2 dwords long
rep	cmpsd
	jne	.nextenv

	; Check if it is followed by a digit
	mov	al, [esi]
	cmp	al, '0'
	jl	.default
	cmp	al, '9'
	jbe	.init
	; fall through

align 4
.default:
	; We got here because we had no -p argument,
	; and did not find the PINHOLE envar.
	mov	esi, pinhole
	; fall through

align 4
.init:
	sub	eax, eax
	sub	ebx, ebx
	sub	ecx, ecx
	sub	edx, edx
	mov	edi, dbuffer+1
	mov	byte [dbuffer], '0'

	; Convert the pinhole constant to real
.constloop:
	lodsb
	cmp	al, '9'
	ja	.setconst
	cmp	al, '0'
	je	.processconst
	jb	.setconst

	inc	dl

.processconst:
	inc	cl
	cmp	cl, 18
	ja	near consttoobig
	stosb
	jmp	short .constloop

align 4
.setconst:
	or	dl, dl
	je	near perr

	finit
	fild	dword [tthou]

	fld1
	fild	dword [ten]
	fdivp	st1, st0

	fild	dword [thousand]
	mov	edi, obuffer

	mov	ebp, ecx
	call	bcdload

.constdiv:
	fmul	st0, st2
	loop	.constdiv

	fld1
	fadd	st0, st0
	fadd	st0, st0
	fld1
	faddp	st1, st0
	fchs

	; If we are creating a CSV file,
	; print header
	cmp	byte [separ], ','
	jne	.bigloop

	push	dword headlen
	push	dword header
	push	dword [fd.out]
	sys.write

.bigloop:
	call	getchar
	jc	near done

	; Skip to the end of the line if you got '#'
	cmp	al, '#'
	jne	.num
	call	skiptoeol
	jmp	short .bigloop

.num:
	; See if you got a number
	cmp	al, '0'
	jl	.bigloop
	cmp	al, '9'
	ja	.bigloop

	; Yes, we have a number
	sub	ebp, ebp
	sub	edx, edx

.number:
	cmp	al, '0'
	je	.number0
	mov	dl, 1

.number0:
	or	dl, dl		; Skip leading 0's
	je	.nextnumber
	push	eax
	call	putchar
	pop	eax
	inc	ebp
	cmp	ebp, 19
	jae	.nextnumber
	mov	[dbuffer+ebp], al

.nextnumber:
	call	getchar
	jc	.work
	cmp	al, '#'
	je	.ungetc
	cmp	al, '0'
	jl	.work
	cmp	al, '9'
	ja	.work
	jmp	short .number

.ungetc:
	dec	esi
	inc	ebx

.work:
	; Now, do all the work
	or	dl, dl
	je	near .work0

	cmp	ebp, 19
	jae	near .toobig

	call	bcdload

	; Calculate pinhole diameter

	fld	st0	; save it
	fsqrt
	fmul	st0, st3
	fld	st0
	fmul	st5
	sub	ebp, ebp

	; Round off to 4 significant digits
.diameter:
	fcom	st0, st7
	fstsw	ax
	sahf
	jb	.printdiameter
	fmul	st0, st6
	inc	ebp
	jmp	short .diameter

.printdiameter:
	call	printnumber	; pinhole diameter

	; Calculate F-number

	fdivp	st1, st0
	fld	st0

	sub	ebp, ebp

.fnumber:
	fcom	st0, st6
	fstsw	ax
	sahf
	jb	.printfnumber
	fmul	st0, st5
	inc	ebp
	jmp	short .fnumber

.printfnumber:
	call	printnumber	; F number

	; Calculate normalized F-number
	fmul	st0, st0
	fld1
	fld	st1
	fyl2x
	frndint
	fld1
	fscale
	fsqrt
	fstp	st1

	sub	ebp, ebp
	call	printnumber

	; Calculate time multiplier from F-5.6

	fscale
	fld	st0

	; Round off to 4 significant digits
.fmul:
	fcom	st0, st6
	fstsw	ax
	sahf

	jb	.printfmul
	inc	ebp
	fmul	st0, st5
	jmp	short .fmul

.printfmul:
	call	printnumber	; F multiplier

	; Calculate F-stops from 5.6

	fld1
	fxch	st1
	fyl2x

	sub	ebp, ebp
	call	printnumber

	mov	al, 0Ah
	call	putchar
	jmp	.bigloop

.work0:
	mov	al, '0'
	call	putchar

align 4
.toobig:
	call	huh
	jmp	.bigloop

align 4
done:
	call	write		; flush output buffer

	; close files
	push	dword [fd.in]
	sys.close

	push	dword [fd.out]
	sys.close

	finit

	; return success
	push	dword 0
	sys.exit

align 4
skiptoeol:
	; Keep reading until you come to cr, lf, or eof
	call	getchar
	jc	done
	cmp	al, 0Ah
	jne	.cr
	ret

.cr:
	cmp	al, 0Dh
	jne	skiptoeol
	ret

align 4
getchar:
	or	ebx, ebx
	jne	.fetch

	call	read

.fetch:
	lodsb
	dec	ebx
	clc
	ret

read:
	jecxz	.read
	call	write

.read:
	push	dword BUFSIZE
	mov	esi, ibuffer
	push	esi
	push	dword [fd.in]
	sys.read
	add	esp, byte 12
	mov	ebx, eax
	or	eax, eax
	je	.empty
	sub	eax, eax
	ret

align 4
.empty:
	add	esp, byte 4
	stc
	ret

align 4
putchar:
	stosb
	inc	ecx
	cmp	ecx, BUFSIZE
	je	write
	ret

align 4
write:
	jecxz	.ret	; nothing to write
	sub	edi, ecx	; start of buffer
	push	ecx
	push	edi
	push	dword [fd.out]
	sys.write
	add	esp, byte 12
	sub	eax, eax
	sub	ecx, ecx	; buffer is empty now
.ret:
	ret

align 4
bcdload:
	; EBP contains the number of chars in dbuffer
	push	ecx
	push	esi
	push	edi

	lea	ecx, [ebp+1]
	lea	esi, [dbuffer+ebp-1]
	shr	ecx, 1

	std

	mov	edi, bbuffer
	sub	eax, eax
	mov	[edi], eax
	mov	[edi+4], eax
	mov	[edi+2], ax

.loop:
	lodsw
	sub	ax, 3030h
	shl	al, 4
	or	al, ah
	mov	[edi], al
	inc	edi
	loop	.loop

	fbld	[bbuffer]

	cld
	pop	edi
	pop	esi
	pop	ecx
	sub	eax, eax
	ret

align 4
printnumber:
	push	ebp
	mov	al, [separ]
	call	putchar

	; Print the integer at the TOS
	mov	ebp, bbuffer+9
	fbstp	[bbuffer]

	; Check the sign
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jns	.leading

	; We got a negative number (should never happen)
	mov	al, '-'
	call	putchar

.leading:
	; Skip leading zeros
	mov	al, [ebp]
	dec	ebp
	or	al, al
	jne	.first
	cmp	ebp, bbuffer
	jae	.leading

	; We are here because the result was 0.
	; Print '0' and return
	mov	al, '0'
	jmp	putchar

.first:
	; We have found the first non-zero.
	; But it is still packed
	test	al, 0F0h
	jz	.second
	push	eax
	shr	al, 4
	add	al, '0'
	call	putchar
	pop	eax
	and	al, 0Fh

.second:
	add	al, '0'
	call	putchar

.next:
	cmp	ebp, bbuffer
	jb	.done

	mov	al, [ebp]
	push	eax
	shr	al, 4
	add	al, '0'
	call	putchar
	pop	eax
	and	al, 0Fh
	add	al, '0'
	call	putchar

	dec	ebp
	jmp	short .next

.done:
	pop	ebp
	or	ebp, ebp
	je	.ret

.zeros:
	mov	al, '0'
	call	putchar
	dec	ebp
	jne	.zeros

.ret:
	ret</programlisting>

      <para>The code follows the same format as all the other filters
	we have seen before, with one subtle exception:</para>

      <blockquote>
	<para>We are no longer assuming that the end of input implies
	  the end of things to do, something we took for granted in
	  the <emphasis>character&ndash;oriented</emphasis>
	  filters.</para>

	<para>This filter does not process characters.  It processes a
	  <emphasis>language</emphasis> (albeit a very simple one,
	  consisting only of numbers).</para>

	<para>When we have no more input, it can mean one of two
	  things:</para>

	<itemizedlist>
	  <listitem>
	    <para>We are done and can quit.  This is the same as
	      before.</para>
	  </listitem>

	  <listitem>
	    <para>The last character we have read was a digit.  We
	      have stored it at the end of our
	      <acronym>ASCII</acronym>&ndash;to&ndash;float
	      conversion buffer.  We now need to convert the contents
	      of that buffer into a number and write the last line of
	      our output.</para>
	  </listitem>
	</itemizedlist>

	<para>For that reason, we have modified our
	  <function>getchar</function> and our
	  <function>read</function> routines to return with the
	  <varname role="register">carry flag</varname>
	  <emphasis>clear</emphasis> whenever we are fetching another
	  character from the input, or the <varname
	    role="register">carry flag</varname>
	  <emphasis>set</emphasis> whenever there is no more
	  input.</para>

	<para>Of course, we are still using assembly language magic to
	  do that! Take a good look at <function>getchar</function>.
	  It <emphasis>always</emphasis> returns with the <varname
	    role="register">carry flag</varname>
	  <emphasis>clear</emphasis>.</para>

	<para>Yet, our main code relies on the <varname
	    role="register">carry flag</varname> to tell it when to
	  quit&mdash;and it works.</para>

	<para>The magic is in <function>read</function>.  Whenever it
	  receives more input from the system, it just returns to
	  <function>getchar</function>, which fetches a character from
	  the input buffer, <emphasis>clears</emphasis> the <varname
	    role="register">carry flag</varname> and returns.</para>

	<para>But when <function>read</function> receives no more
	  input from the system, it does <emphasis>not</emphasis>
	  return to <function>getchar</function> at all.  Instead, the
	  <function role="opcode">add esp, byte 4</function> op code
	  adds <constant>4</constant> to <varname
	    role="register">ESP</varname>, <emphasis>sets</emphasis>
	  the <varname role="register">carry flag</varname>, and
	  returns.</para>

	<para>So, where does it return to? Whenever a program uses the
	  <function role="opcode">call</function> op code, the
	  microprocessor <function role="opcode">push</function>es the
	  return address, i.e., it stores it on the top of the stack
	  (not the <acronym>FPU</acronym> stack, the system stack,
	  which is in the memory).  When a program uses the <function
	    role="opcode">ret</function> op code, the microprocessor
	  <function role="opcode">pop</function>s the return value
	  from the stack, and jumps to the address that was stored
	  there.</para>

	<para>But since we added <constant>4</constant> to <varname
	    role="register">ESP</varname> (which is the stack pointer
	  register), we have effectively given the microprocessor a
	  minor case of <emphasis>amnesia</emphasis>: It no longer
	  remembers it was <function>getchar</function> that <function
	    role="opcode">call</function>ed
	  <function>read</function>.</para>

	<para>And since <function>getchar</function> never <function
	    role="opcode">push</function>ed anything before <function
	    role="opcode">call</function>ing
	  <function>read</function>, the top of the stack now contains
	  the return address to whatever or whoever <function
	    role="opcode">call</function>ed
	  <function>getchar</function>.  As far as that caller is
	  concerned, he <function role="opcode">call</function>ed
	  <function>getchar</function>, which <function
	    role="opcode">ret</function>urned with the <varname
	    role="register">carry flag</varname> set!</para>
      </blockquote>

      <para>Other than that, the <function>bcdload</function> routine
	is caught up in the middle of a Lilliputian conflict between
	the Big&ndash;Endians and the Little&ndash;Endians.</para>

      <para>It is converting the text representation of a number into
	that number: The text is stored in the big&ndash;endian order,
	but the <emphasis>packed decimal</emphasis> is
	little&ndash;endian.</para>

      <para>To solve the conflict, we use the <function>std</function>
	op code early on.  We cancel it with <function>cld</function>
	later on: It is quite important we do not
	<function>call</function> anything that may depend on the
	default setting of the <emphasis>direction flag</emphasis>
	while <function>std</function> is active.</para>

      <para>Everything else in this code should be quit eclear,
	providing you have read the entire chapter that precedes
	it.</para>

      <para>It is a classical example of the adage that programming
	requires a lot of thought and only a little coding.  Once we
	have thought through every tiny detail, the code almost writes
	itself.</para>
    </sect2>

    <sect2 xml:id="x86-pinhole-using">
      <title>Using <application>pinhole</application></title>

      <para>Because we have decided to make the program
	<emphasis>ignore</emphasis> any input except for numbers (and
	even those inside a comment), we can actually perform
	<emphasis>textual queries</emphasis>.  We do not
	<emphasis>have to</emphasis>, but we
	<emphasis>can</emphasis>.</para>

      <para>In my humble opinion, forming a textual query, instead of
	having to follow a very strict syntax, makes software much
	more user friendly.</para>

      <para>Suppose we want to build a pinhole camera to use the 4x5
	inch film.  The standard focal length for that film is about
	150mm.  We want to <emphasis>fine&ndash;tune</emphasis> our
	focal length so the pinhole diameter is as round a number as
	possible.  Let us also suppose we are quite comfortable with
	cameras but somewhat intimidated by computers.  Rather than
	just have to type in a bunch of numbers, we want to
	<emphasis>ask</emphasis> a couple of questions.</para>

      <para>Our session might look like this:</para>

      <screen>&prompt.user; <userinput>pinhole

Computer,

What size pinhole do I need for the focal length of 150?</userinput>
150	490	306	362	2930	12
<userinput>Hmmm... How about 160?</userinput>
160	506	316	362	3125	12
<userinput>Let's make it 155, please.</userinput>
155	498	311	362	3027	12
<userinput>Ah, let's try 157...</userinput>
157	501	313	362	3066	12
<userinput>156?</userinput>
156	500	312	362	3047	12
<userinput>That's it! Perfect! Thank you very much!
^D</userinput></screen>

      <para>We have found that while for the focal length of 150, our
	pinhole diameter should be 490 microns, or 0.49 mm, if we go
	with the almost identical focal length of 156 mm, we can get
	away with a pinhole diameter of exactly one half of a
	millimeter.</para>
    </sect2>

    <sect2 xml:id="x86-pinhole-scripting">
      <title>Scripting</title>

      <para>Because we have chosen the <constant>#</constant>
	character to denote the start of a comment, we can treat our
	<application>pinhole</application> software as a
	<emphasis>scripting language</emphasis>.</para>

      <para>You have probably seen <application>shell</application>
	<emphasis>scripts</emphasis> that start with:</para>

      <programlisting>#! /bin/sh</programlisting>

      <para>...or...</para>

      <programlisting>#!/bin/sh</programlisting>

      <para>...because the blank space after the
	<function>#!</function> is optional.</para>

      <para>Whenever &unix; is asked to run an executable
	file which starts with the <function>#!</function>,
	it assumes the file is a script.  It adds the
	command to the rest of the first line of the
	script, and tries to execute that.</para>

      <para>Suppose now that we have installed
	<application>pinhole</application> in
	<application>/usr/local/bin/</application>, we can now write a
	script to calculate various pinhole diameters suitable for
	various focal lengths commonly used with the 120 film.</para>

      <para>The script might look something like this:</para>

      <programlisting>#! /usr/local/bin/pinhole -b -i
# Find the best pinhole diameter
# for the 120 film

### Standard
80

### Wide angle
30, 40, 50, 60, 70

### Telephoto
100, 120, 140</programlisting>

      <para>Because 120 is a medium size film, we may name this file
	<application>medium</application>.</para>

      <para>We can set its permissions to execute, and run it as if it
	were a program:</para>

      <screen>&prompt.user; <userinput>chmod 755 medium</userinput>
&prompt.user; <userinput>./medium</userinput></screen>

      <para>&unix; will interpret that last command as:</para>

      <screen>&prompt.user; <userinput>/usr/local/bin/pinhole -b -i ./medium</userinput></screen>

      <para>It will run that command and display:</para>

      <screen>80	358	224	256	1562	11
30	219	137	128	586	9
40	253	158	181	781	10
50	283	177	181	977	10
60	310	194	181	1172	10
70	335	209	181	1367	10
100	400	250	256	1953	11
120	438	274	256	2344	11
140	473	296	256	2734	11</screen>

      <para>Now, let us enter:</para>

      <screen>&prompt.user; <userinput>./medium -c</userinput></screen>

      <para>&unix; will treat that as:</para>

      <screen>&prompt.user; <userinput>/usr/local/bin/pinhole -b -i ./medium -c</userinput></screen>

      <para>That gives it two conflicting options:
	<parameter>-b</parameter> and <parameter>-c</parameter>
	(Use Bender's constant and use Connors' constant).  We have
	programmed it so later options override early ones&mdash;our
	program will calculate everything using Connors'
	constant:</para>

      <screen>80	331	242	256	1826	11
30	203	148	128	685	9
40	234	171	181	913	10
50	262	191	181	1141	10
60	287	209	181	1370	10
70	310	226	256	1598	11
100	370	270	256	2283	11
120	405	296	256	2739	11
140	438	320	362	3196	12</screen>

      <para>We decide we want to go with Bender's constant after all.
	We want to save its values as a comma&ndash;separated
	file:</para>

      <screen>&prompt.user; <userinput>./medium -b -e &gt; bender</userinput>
&prompt.user; <userinput>cat bender</userinput>
focal length in millimeters,pinhole diameter in microns,F-number,normalized F-number,F-5.6 multiplier,stops from F-5.6
80,358,224,256,1562,11
30,219,137,128,586,9
40,253,158,181,781,10
50,283,177,181,977,10
60,310,194,181,1172,10
70,335,209,181,1367,10
100,400,250,256,1953,11
120,438,274,256,2344,11
140,473,296,256,2734,11
&prompt.user;</screen>
      </sect2>
    </sect1>

    <sect1 xml:id="x86-caveats">
      <title>Caveats</title>

      <para>Assembly language programmers who "grew up" under
	<acronym>&ms-dos;</acronym> and &windows; often tend to take
	shortcuts.  Reading the keyboard scan codes and writing
	directly to video memory are two classical examples of
	practices which, under <acronym>&ms-dos;</acronym> are not
	frowned upon but considered the right thing to do.</para>

      <para>The reason? Both the <acronym>PC BIOS</acronym> and
	<acronym>&ms-dos;</acronym> are notoriously slow when
	performing these operations.</para>

      <para>You may be tempted to continue similar practices in the
	&unix; environment.  For example, I have seen a web site which
	explains how to access the keyboard scan codes on a popular
	&unix; clone.</para>

      <para>That is generally a <emphasis>very bad idea</emphasis> in
	&unix; environment! Let me explain why.</para>

      <sect2 xml:id="x86-protected">
	<title>&unix; Is Protected</title>

	<para>For one thing, it may simply not be possible.  &unix;
	  runs in protected mode.  Only the kernel and device drivers
	  are allowed to access hardware directly.  Perhaps a
	  particular &unix; clone will let you read the keyboard scan
	  codes, but chances are a real &unix; operating system will
	  not.  And even if one version may let you do it, the next
	  one may not, so your carefully crafted software may become a
	  dinosaur overnight.</para>
      </sect2>

      <sect2 xml:id="x86-abstraction">
	<title>&unix; Is an Abstraction</title>

	<para>But there is a much more important reason not to try
	  accessing the hardware directly (unless, of course, you are
	  writing a device driver), even on the &unix; like systems
	  that let you do it:</para>

	<para><emphasis>&unix; is an abstraction!</emphasis></para>

	<para>There is a major difference in the philosophy of design
	  between <acronym>&ms-dos;</acronym> and &unix;.
	  <acronym>&ms-dos;</acronym> was designed as a single-user
	  system.  It is run on a computer with a keyboard and a video
	  screen attached directly to that computer.  User input is
	  almost guaranteed to come from that keyboard.  Your
	  program's output virtually always ends up on that
	  screen.</para>

	<para>This is NEVER guaranteed under &unix;.  It is quite
	  common for a &unix; user to pipe and redirect program input
	  and output:</para>

	<screen>&prompt.user; <userinput>program1 | program2 | program3 &gt; file1</userinput></screen>

	<para>If you have written <application>program2</application>,
	  your input does not come from the keyboard but from the
	  output of <application>program1</application>.  Similarly,
	  your output does not go to the screen but becomes the input
	  for <application>program3</application> whose output, in
	  turn, goes to <filename>file1</filename>.</para>

	<para>But there is more! Even if you made sure that your input
	  comes from, and your output goes to, the terminal, there is
	  no guarantee the terminal is a PC: It may not have its video
	  memory where you expect it, nor may its keyboard be
	  producing <acronym>PC</acronym>-style scan codes.  It may be
	  a &macintosh;, or any other computer.</para>

	<para>Now you may be shaking your head: My software is in
	  <acronym>PC</acronym> assembly language, how can it run on a
	  &macintosh;? But I did not say your software would be
	  running on a &macintosh;, only that its terminal may be a
	  &macintosh;.</para>

	<para>Under &unix;, the terminal does not have to be directly
	  attached to the computer that runs your software, it can
	  even be on another continent, or, for that matter, on
	  another planet.  It is perfectly possible that a &macintosh;
	  user in Australia connects to a &unix; system in North
	  America (or anywhere else) via
	  <application>telnet</application>.  The software then runs
	  on one computer, while the terminal is on a different
	  computer: If you try to read the scan codes, you will get
	  the wrong input!</para>

	<para>Same holds true about any other hardware: A file you are
	  reading may be on a disk you have no direct access to.  A
	  camera you are reading images from may be on a
	  space shuttle, connected to you via satellites.</para>

	<para>That is why under &unix; you must never make any
	  assumptions about where your data is coming from and going
	  to.  Always let the system handle the physical access to the
	  hardware.</para>

	<note>
	  <para>These are caveats, not absolute rules.  Exceptions are
	    possible.  For example, if a text editor has determined it
	    is running on a local machine, it may want to read the
	    scan codes directly for improved control.  I am not
	    mentioning these caveats to tell you what to do or what
	    not to do, just to make you aware of certain pitfalls that
	    await you if you have just arrived to &unix; form
	    <acronym>&ms-dos;</acronym>.  Of course, creative people
	    often break rules, and it is OK as long as they know they
	    are breaking them and why.</para>
	</note>
      </sect2>
    </sect1>

    <sect1 xml:id="x86-acknowledgements">
      <title>Acknowledgements</title>

      <para>This tutorial would never have been possible without the
	help of many experienced FreeBSD programmers from the
	&a.hackers;, many of whom have patiently answered my
	questions, and pointed me in the right direction in my
	attempts to explore the inner workings of &unix; system
	programming in general and FreeBSD in particular.</para>

      <para>Thomas M. Sommers opened the door for me . His <link
	  xlink:href="https://web.archive.org/web/20090914064615/http://www.codebreakers-journal.com/content/view/262/27">How
	  do I write "Hello, world" in FreeBSD assembler?</link> web
	page was my first encounter with an example of assembly
	language programming under FreeBSD.</para>

      <para>Jake Burkholder has kept the door open by willingly
	answering all of my questions and supplying me with example
	assembly language source code.</para>

      <para>Copyright &copy; 2000-2001 G. Adam Stanislav.  All rights
	reserved.</para>
    </sect1>
  </chapter>
