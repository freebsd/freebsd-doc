<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="ports">
  <title>Installing Applications: Packages and Ports</title>

  <sect1 xml:id="ports-synopsis">
    <title>Synopsis</title>

    <indexterm><primary>ports</primary></indexterm>
    <indexterm><primary>packages</primary></indexterm>
    <para>&os; is bundled with a rich collection of system tools as
      part of the base system.  In addition,  &os; provides two
      complementary technologies for installing third-party software:
      the &os; Ports Collection, for installing from source, and
      packages, for installing from pre-built binaries.  Either
      method may be used to install software from local media or
      from the network.</para>

    <para>After reading this chapter, you will know:</para>

    <itemizedlist>
      <listitem>
	<para>The difference between binary packages and ports.</para>
      </listitem>

      <listitem>
	<para>How to find third-party software that has been ported
	  to &os;.</para>
      </listitem>

      <listitem>
	<para>How to manage binary packages using the traditional
	  package system.</para>
      </listitem>

      <listitem>
	<para>How to manage binary packages using
	  <application>pkgng</application>.</para>
      </listitem>

      <listitem>
	<para>How to build third-party software from source using the
	  Ports Collection.</para>
      </listitem>

      <listitem>
	<para>How to find the files installed with the application
	  for post-installation configuration.</para>
      </listitem>

      <listitem>
	<para>What to do if a software installation fails.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="ports-overview">
    <title>Overview of Software Installation</title>

    <para>The typical steps for installing third-party software on a
      &unix; system include:</para>

    <procedure>
      <step>
	<para>Find and download the software, which might be
	  distributed in source code format or as a binary.</para>
      </step>

      <step>
	<para>Unpack the software from its distribution format.  This
	  is typically a tarball compressed with &man.compress.1;,
	  &man.gzip.1;, or &man.bzip2.1;.</para>
      </step>

      <step>
	<para>Locate the documentation in
	  <filename>INSTALL</filename>, <filename>README</filename>
	  or some file in a <filename>doc/</filename> subdirectory and
	  read up on how to install the software.</para>
      </step>

      <step>
	<para>If the software was distributed in source format,
	  compile it.  This may involve editing a
	  <filename>Makefile</filename> or running a
	  <command>configure</command> script.</para>
      </step>

      <step>
	<para>Test and install the software.</para>
      </step>
    </procedure>

    <para>If the software package was not deliberately ported, or
      tested to work, on &os;, the source code may need editing in
      order for it to install and run properly.  At the time of this
      writing, over &os.numports; third-party applications have been
      ported to &os;.</para>

    <para>&os; provides two technologies which automate these
      steps.</para>

    <para>A &os; package contains pre-compiled copies of all the
      commands for an application, as well as any configuration files
      and documentation.  A package can be manipulated with the
      traditional &os; package management commands, such as
      &man.pkg.add.1;, or using the newer
      <application>pkgng</application> commands, such as
      <command>pkg install</command>.</para>

    <para>A &os; port is a collection of files designed to automate
      the process of compiling an application from source code.  The
      files that comprise a port contain all the necessary information
      to automatically download, extract, patch, compile, and install
      the application.</para>

    <para>The ports system can also be used to generate packages which
      can be manipulated with the &os; package management
      commands.</para>

    <para>Both packages and ports understand dependencies.  If a
      package or port is used to install an application and a
      dependent library is not already installed, the library will
      automatically be installed first.</para>

    <para>While the two technologies are similar, packages and
      ports each have their own strengths.  Select the technology that
      meets your requirements for installing a particular
      application.</para>

    <itemizedlist>
      <title>Package Benefits</title>

      <listitem>
	<para>A compressed package tarball is typically smaller than
	  the compressed tarball containing the source code for the
	  application.</para>
      </listitem>

      <listitem>
	<para>Packages do not require compilation time.  For large
	  applications, such as <application>Mozilla</application>,
	  <application>KDE</application>, or
	  <application>GNOME</application>, this can be important
	  on a slow system.</para>
      </listitem>

      <listitem>
	<para>Packages do not require any understanding of the process
	  involved in compiling software on &os;.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Port Benefits</title>

      <listitem>
	<para>Packages are normally compiled with conservative
	  options because they have to run on the maximum number of
	  systems.  By compiling from the port, one can change the
	  compilation options.</para>
      </listitem>

      <listitem>
	<para>Some applications have compile-time options relating to
	  which features are installed.  For example,
	  <application>Apache</application> can be configured with a
	  wide variety of different built-in options.</para>

	<para>In some cases, multiple packages will exist for the same
	  application to specify certain settings.  For example,
	  <application>Ghostscript</application> is available as a
	  <filename>ghostscript</filename> package and a
	  <filename>ghostscript-nox11</filename> package, depending on
	  whether or not <application>Xorg</application> is installed.
	  Creating multiple packages rapidly becomes impossible if an
	  application has more than one or two different compile-time
	  options.</para>
      </listitem>

      <listitem>
	<para>The licensing conditions of some software forbid binary
	  distribution.  Such software must be distributed as source
	  code which must be compiled by the end-user.</para>
      </listitem>

      <listitem>
	<para>Some people do not trust binary distributions or prefer
	  to read through source code in order to look for potential
	  problems.</para>
      </listitem>

      <listitem>
	<para>Source code is needed in
	  order to apply custom patches.</para>
      </listitem>
    </itemizedlist>

    <para>To keep track of updated ports, subscribe to the
      &a.ports; and the &a.ports-bugs;.</para>

    <warning>
      <para>Before installing any application, check <uri xlink:href="http://vuxml.freebsd.org/">http://vuxml.freebsd.org/</uri> for security issues
	related to the application or install  <package>ports-mgmt/portaudit</package>. Once
	installed, type <command>portaudit -F -a</command> to check
	all installed applications for known vulnerabilities.</para>
    </warning>

    <para>The remainder of this chapter explains how to use packages
      and ports to install and manage third-party software on
      &os;.</para>
  </sect1>

  <sect1 xml:id="ports-finding-applications">
    <title>Finding Software</title>

    <para>&os;'s list of available applications is growing all the
      time.  There are a number of ways to find software to
      install:</para>

    <itemizedlist>
      <listitem>
	<para>The &os; web site maintains an up-to-date searchable
	  list of all the available applications, at <link xlink:href="&url.base;/ports/index.html">http://www.FreeBSD.org/ports/</link>.
	  The ports can be searched by application name or by
	  software category.</para>
      </listitem>

      <listitem>
	<indexterm><primary>FreshPorts</primary></indexterm>

	<para>Dan Langille maintains <link xlink:href="http://www.FreshPorts.org/">FreshPorts.org</link>
	  which provides a comprehensive search utility and also
	  tracks changes to the applications in the Ports Collection.
	  Registered users can create a customized watch list in order
	  to receive an automated email when their watched ports are
	  updated.</para>
      </listitem>

      <listitem>
	<indexterm><primary>Freecode</primary></indexterm>

	<para>If you do not know the name of an application, try
	  using a site like <link xlink:href="http://www.freecode.com/">Freecode.com</link> to
	  find an application, then check back at the &os; site to
	  see if the application has been ported yet.</para>
      </listitem>

      <listitem>
	<para>If the Ports Collection is already installed, there are
	  several methods to query the local version of the ports
	  tree.  To find out which category a port is in, type
	  <command>whereis file</command>,
	  where <replaceable>file</replaceable> is the program to be
	  installed:</para>

	<screen>&prompt.root; <userinput>whereis lsof</userinput>
lsof: /usr/ports/sysutils/lsof</screen>

	<para>Alternately, an &man.echo.1; statement can be
	  used:</para>

	<screen>&prompt.root; <userinput>echo /usr/ports/*/*lsof*</userinput>
/usr/ports/sysutils/lsof</screen>

	<para>Note that this will also return any matched files
	  downloaded into the <filename>/usr/ports/distfiles</filename>
	  directory.</para>
      </listitem>

      <listitem>
	<para>Another way to find software is by using the Ports
	  Collection's built-in search mechanism.  To use the search
	  feature, <application>cd</application> to <filename>/usr/ports</filename> then run
	  <command>make search
	    name=program-name</command>
	  where <replaceable>program-name</replaceable> is the name
	  of the software.  For example, to search for
	  <command>lsof</command>:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make search name=lsof</userinput>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps: </screen>

	<tip>
	  <para>The built-in search mechanism uses a file
	    of index information.  If a message indicates that the
	    <filename>INDEX</filename> is required, run
	    <command>make fetchindex</command> to download the current
	    index file.  With the <filename>INDEX</filename> present,
	    <command>make search</command> will be able to perform the
	    requested search.</para>
	</tip>

	<para>The <quote>Path:</quote> line indicates where to find
	  the port.</para>

	<para>To receive less information, use the
	  <command>quicksearch</command> feature:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make quicksearch name=lsof</userinput>
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))</screen>

	<para>For more in-depth searching, use
	  <command>make search
	  key=string</command> or
	  <command>make quicksearch
	  key=string</command>, where
	  <replaceable>string</replaceable> is some text to search
	  for.  The text can be in comments, descriptions, or
	  dependencies in order to find ports which relate to a
	  particular subject when the name of the program is
	  unknown.</para>

	<para>When using <buildtarget>search</buildtarget> or
	  <buildtarget>quicksearch</buildtarget>, the search string
	  is case-insensitive.  Searching for <quote>LSOF</quote> will
	  yield the same results as searching for
	  <quote>lsof</quote>.</para>
      </listitem>
    </itemizedlist>
  </sect1>


  <sect1 xml:id="packages-using">
    <!--
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    -->

    <title>Using Binary Packages</title>

    <para>At the present time, &os; is transitioning toward a new
      method of package management.  Users
      may wish to investigate the benefits of using
      <link linkend="pkgng-intro">PKGng</link> to manage third-party
      software on &os;.  This section describes the traditional method
      for managing binary packages and only applies to those users
      who have not yet migrated to the
      <application>pkgng</application> format.</para>

    <para>This method of package management uses a package database
      directory, <filename>/var/db/pkg</filename>,
      to track installed software versions and the files installed
      with each application.  Several utilities interact with the
      database directory and are used to manage binary packages.
      These commands begin with <literal>pkg_</literal>.  This section
      provides an overview of the commands which are used to install,
      delete, and gather information about binary packages.  Each
      command provides many switches to customize its operation.
      Refer to the listed man pages for more details and further usage
      examples.</para>

    <sect2>
      <title>Installing a Package</title>

      <indexterm>
	<primary>packages</primary>
	<secondary>installing</secondary>
      </indexterm>

      <indexterm>
	<primary><command>pkg_add</command></primary>
      </indexterm>
      <para>To install a binary package from a local &os; media or
	a remote &os; package server, use &man.pkg.add.1;.  While a
	&os; media can provide a source of local packages without
	requiring a network connection, it may not contain the latest
	versions of binary packages as new versions are always being
	rebuilt for the &os; package servers.  To install from a
	package server, always include <option>-r</option> (for
	remote) with &man.pkg.add.1;.  This automatically determines
	the correct object format and release, and then fetches and
	installs the package from a package server without any
	further user intervention.</para>

      <indexterm>
	<primary><command>pkg_add</command></primary>
      </indexterm>
      <screen>&prompt.root; <userinput>pkg_add -r lsof</userinput></screen>

      <para>In this example, <literal>lsof</literal> is used without
	specifying a version number as the version is not included
	when the remote fetching feature is used.  To specify an
	alternative &os; FTP mirror, specify the mirror in the
	<envar>PACKAGESITE</envar> environment variable.
	&man.pkg.add.1; uses &man.fetch.3; to download files, which
	uses various environment variables, including
	<envar>FTP_PASSIVE_MODE</envar>, <envar>FTP_PROXY</envar>,
	and <envar>FTP_PASSWORD</envar>.  You may need to set one or
	more of these if you are behind a firewall, or need to use
	an FTP/HTTP proxy.  See &man.fetch.3; for the complete list
	of FTP-related variables.</para>

      <note>
	<para>&man.pkg.add.1; will automatically download the latest
	  version of the application if you are using &os.current; or
	  &os.stable;.  If you run a -RELEASE version, it instead
	  installs the version of the package that was built with that
	  release.  It is possible to change this behavior by
	  overriding <envar>PACKAGESITE</envar>.  For example, on a
	  &os;&nbsp;9.1-RELEASE system, by default &man.pkg.add.1;
	  will try to fetch packages from
	  <literal>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-9.1-release/Latest/</literal>.
	  To force &man.pkg.add.1; to download &os;&nbsp;9-STABLE
	  packages, set <envar>PACKAGESITE</envar> to
	  <literal>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-9-stable/Latest/</literal>.</para>
      </note>

      <para>Package files are distributed in the
	<filename>.tbz</filename> format.  Packages are available
	from <uri xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/">ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/</uri>
	or the <filename>/packages</filename> directory of the &os;
	DVD distribution.  The layout of the packages directory is
	similar to that of the <filename>/usr/ports</filename> tree.  Each
	category has its own directory, and every package can be
	found within the <filename>All</filename> directory.</para>
    </sect2>

    <sect2>
      <title>Managing Packages</title>

      <indexterm>
	<primary>packages</primary>
	<secondary>managing</secondary>
      </indexterm>

      <para>To list and describe
	installed packages, use &man.pkg.info.1;:</para>

      <indexterm>
	<primary><command>pkg_info</command></primary>
      </indexterm>

      <screen>&prompt.root; <userinput>pkg_info</userinput>
colordiff-1.0.13    Tool to colorize diff output
docbook-1.4         Meta-port for the different versions of the DocBook DTD
...</screen>

      <para>To receive a summary of the versions of all installed
	packages and a comparison of the installed package versions
	to the current versions found in the locally installed ports
	tree, use &man.pkg.version.1;:</para>

      <indexterm>
	<primary><command>pkg_version</command></primary>
      </indexterm>
      <screen>&prompt.root; <userinput>pkg_version</userinput>
colordiff                   =
docbook                     =
...</screen>

      <para>The symbols in the second column indicate the relative
	age of the installed version and the version available in the
	local ports tree.</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Symbol</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>=</entry>
	      <entry>The version of the installed package matches the
		one in the local ports tree.</entry>
	    </row>

	    <row>
	      <entry>&lt;</entry>
	      <entry>The version of the installed package is older
		than the one in the local ports tree.</entry>
	    </row>

	    <row>
	      <entry>&gt;</entry>
	      <entry>The version of the installed package is newer
		than the one in the local ports tree, meaning
		that the local ports tree is probably out of
		date.</entry>
	    </row>

	    <row>
	      <entry>?</entry>
	      <entry>The installed package cannot be found in the
		ports index.  This can happen when an installed port
		is removed from the Ports Collection or is
		renamed.</entry>
	    </row>

	    <row>
	      <entry>*</entry>
	      <entry>There are multiple versions of the
		package.</entry>
	    </row>

	    <row>
	      <entry>!</entry>

	      <entry>The installed package exists in the index but for
		some reason <command>pkg_version</command> was unable
		to compare the version number of the installed package
		with the corresponding entry in the index.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Deleting a Package</title>

      <indexterm>
	<primary><command>pkg_delete</command></primary>
      </indexterm>

      <indexterm>
	<primary>packages</primary>
	<secondary>deleting</secondary>
      </indexterm>

      <para>To remove a previously installed software package, use
	&man.pkg.delete.1;:</para>

      <screen>&prompt.root; <userinput>pkg_delete xchat-2.8.8_1</userinput></screen>

      <para>Note that &man.pkg.delete.1; requires the full package
	name and number and that the above command would not work if
	<replaceable>xchat</replaceable> was given instead of
	<replaceable>xchat-2.8.8_1</replaceable>.  Use
	&man.pkg.version.1; to find the version of the installed
	package, or use a wildcard:</para>

      <screen>&prompt.root; <userinput>pkg_delete xchat\*</userinput></screen>

      <para>in this case, all packages whose names start with
	<literal>xchat</literal> will be deleted.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="pkgng-intro">
    <title>Using <application>pkgng</application> for Binary Package
      Management</title>

    <para><application>pkgng</application> is the next generation
      replacement for the traditional &os; package management tools,
      offering many features that make dealing with binary packages
      faster and easier.</para>

    <para><application>pkgng</application> is not a replacement for
      port management tools like <package>ports-mgmt/portmaster</package> or <package>ports-mgmt/portupgrade</package>.  These
      tools can be used to install third-party software from both
      binary packages and the Ports Collection, while
      <application>pkgng</application> installs only binary
      packages.</para>

    <sect2 xml:id="pkgng-initial-setup">
      <title>Getting Started with
	<application>pkgng</application></title>

      <para>&os;&nbsp;9.1 and later includes a bootstrap utility
	which can be used to download and install
	<application>pkgng</application>, along with its manual
	pages.</para>

      <para>To bootstrap the system, run:</para>

      <screen>&prompt.root; <userinput>/usr/sbin/pkg</userinput></screen>

      <para>For earlier &os; versions,
	<application>pkgng</application> must instead be installed
	from the Ports Collection or as a binary package.</para>

      <para>To install the port, run:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/pkg</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>To install the binary package, run:</para>

      <screen>&prompt.root; <userinput>pkg_add -r pkg</userinput></screen>

      <para>Once <application>pkgng</application> is installed, the
	package database must be converted from the traditional format
	to the new format by running this command:</para>

      <screen>&prompt.root; <userinput>pkg2ng</userinput></screen>

      <para>This step is not required for new installations that do
	not yet have any third-party software installed.</para>

      <important>
	<para>This step is not reversible.  Once the package database
	  has been converted to the <application>pkgng</application>
	  format, the traditional <literal>pkg_*</literal> tools
	  should not be used.</para>
      </important>

      <note>
	<para>The package database conversion may emit errors as the
	  contents are converted to the new version.  Generally, these
	  errors can be safely ignored.  However, a list of
	  third-party software that was not successfully converted
	  will be listed after <command>pkg2ng</command> has finished
	  and these applications must be manually reinstalled.</para>
      </note>

      <para>To ensure that the &os;&nbsp;Ports Collection registers
	new software with <application>pkgng</application>, and not
	the traditional packages format, &os; versions earlier than
	10.<replaceable>X</replaceable> require this line in
	<filename>/etc/make.conf</filename>:</para>

      <programlisting>WITH_PKGNG=	yes</programlisting>

      <para>The <application>pkgng</application> package management
	system uses a package repository for most operations.  The
	default package repository location is defined in
	<filename>/usr/local/etc/pkg.conf</filename> or by the
	<envar>PACKAGESITE</envar> environment variable, which
	overrides the configuration file.</para>

      <para>Additional <application>pkgng</application>
	configuration options are described in pkg.conf(5).</para>

      <para>Usage information for <application>pkgng</application> is
	available in pkg(8) or by running
	<command>pkg</command> without additional arguments.</para>

      <para>Each <application>pkgng</application> command argument is
	documented in a command-specific manual page.  To read the
	manual page for <command>pkg install</command>, for example,
	run either of these commands:</para>

      <screen>&prompt.root; <userinput>pkg help install</userinput></screen>

      <screen>&prompt.root; <userinput>man pkg-install</userinput></screen>

      <para>The rest of this section demonstrates common binary
	package management tasks which can be performed using
	<application>pkgng</application>.  Each demonstrated command
	provides many switches to customize its use.  Refer to a
	command's help or man page for details and more
	examples.</para>
    </sect2>

    <sect2 xml:id="pkgng-pkg-info">
      <title>Obtaining Information About Installed Packages</title>

      <para>Information about the packages installed on a system
	can be viewed by running <command>pkg info</command> which,
	when run without any switches, will list the package version
	for either all installed packages or the specified
	package.</para>

      <para>For example, to see which version of
	<application>pkgng</application> is installed, run:</para>

      <screen>&prompt.root; <userinput>pkg info pkg</userinput>
pkg-1.1.4_1</screen>
    </sect2>

    <sect2 xml:id="pkgng-installing-deinstalling">
      <title>Installing and Removing Packages</title>

      <para>To install a binary package use the following command,
	where <replaceable>packagename</replaceable> is the name of
	the package to install:</para>

      <screen>&prompt.root; <userinput>pkg install packagename</userinput></screen>

      <para>This command uses repository data to determine which
	version of the software to install and if it has any
	uninstalled dependencies.  For example, to install
	<application>curl</application>:</para>

      <screen>&prompt.root; <userinput>pkg install curl</userinput>
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages [y/N]: <userinput>y</userinput>
Checking integrity... done
[1/2] Installing ca_root_nss-3.15.5_1... done
[2/2] Installing curl-7.31.0_1... done
Cleaning up cache files...Done</screen>

	<para>The new package and any additional packages that were
	  installed as dependencies can be seen in the installed
	  packages list:</para>

	<screen>&prompt.root; <userinput>pkg info</userinput>
ca_root_nss-3.15.5_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1	Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
pkg-1.1.4_6	New generation package manager</screen>

	<para>Packages that are no longer needed can be removed with
	  <command>pkg delete</command>.  For example:</para>

	<screen>&prompt.root; <userinput>pkg delete curl</userinput>
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages [y/N]: <userinput>y</userinput>
[1/1] Deleting curl-7.31.0_1... done</screen>
    </sect2>

    <sect2 xml:id="pkgng-upgrading">
      <title>Upgrading Installed Packages</title>

      <para>Packages that are outdated can be found with
	<command>pkg version</command>.  If a local ports tree
	does not exist, pkg-version(8) will use the remote
	repository catalogue.  Otherwise, the local ports tree will
	be used to identify package versions.</para>

      <para>Installed packages can be upgraded to their latest
	versions by typing <command>pkg upgrade</command>.  This
	command will compare the installed versions with those
	available in the repository catalogue.  When finished, it
	will list the applications that have newer versions.  Type
	<userinput>y</userinput> to proceed with the upgrade or
	<userinput>n</userinput> to cancel the upgrade.</para>
    </sect2>

    <sect2 xml:id="pkgng-auditing">
      <title>Auditing Installed Packages</title>

      <para>Occasionally, software vulnerabilities may be discovered
	in third-party applications.  To address this,
	<application>pkgng</application> includes a built-in auditing
	mechanism.  To determine if there are any known
	vulnerabilities for the software installed on the system,
	run:</para>

	<screen>&prompt.root; <userinput>pkg audit -F</userinput></screen>
    </sect2>

    <sect2 xml:id="pkgng-autoremove">
      <title>Automatically Removing Leaf Dependencies</title>

      <para>Removing a package may leave behind dependencies which
	are no longer required.  Unneeded packages that were installed
	as dependencies can be automatically detected and removed
	using:</para>

      <screen>&prompt.root; <userinput>pkg autoremove</userinput>
Packages to be autoremoved:
	ca_root_nss-3.13.5

The autoremoval will free 723 kB

Proceed with autoremoval of packages [y/N]: <userinput>y</userinput>
Deinstalling ca_root_nss-3.15.1_1... done</screen>
    </sect2>

    <sect2 xml:id="pkgng-backup">
      <title>Backing Up the Package Database</title>

      <para>Unlike the traditional package management system,
	<application>pkgng</application> includes its own package
	database backup mechanism.  To manually back up the contents
	of the package database, run the following command, replacing
	<replaceable>pkgng.db</replaceable> with a suitable file
	name:</para>

      <screen>&prompt.root; <userinput>pkg backup -d pkgng.db</userinput></screen>

      <para>Additionally, <application>pkgng</application> includes
	a &man.periodic.8; script to automatically perform a daily
	back up of the package database.  This functionality is
	enabled if <literal>daily_backup_pkgng_enable</literal> is
	set to <literal>YES</literal> in &man.periodic.conf.5;.</para>

      <tip>
	<para>To disable the periodic script from backing up the
	  package database, set <literal>daily_backup_pkgdb_
	    enable</literal> to <literal>NO</literal> in
	  &man.periodic.conf.5;.</para>
      </tip>

      <para>To restore the contents of a previous package database
	backup, run:</para>

      <screen>&prompt.root; <userinput>pkg backup -r /path/to/pkgng.db</userinput></screen>
    </sect2>

    <sect2 xml:id="pkgng-clean">
      <title>Removing Stale Packages</title>

      <para>By default, <application>pkgng</application> stores
	binary packages in a cache directory defined by
	<envar>PKG_CACHEDIR</envar> in pkg.conf(5).  When upgrading
	packages with <command>pkg upgrade</command>, old versions
	of the upgraded packages are not automatically removed.</para>

      <para>To remove these outdated binary packages, run:</para>

      <screen>&prompt.root; <userinput>pkg clean</userinput></screen>
    </sect2>

    <sect2 xml:id="pkgng-set">
      <title>Modifying Package Metadata</title>

      <para>Software within the &os;&nbsp;Ports Collection can
	undergo major version number changes.  To address this,
	<application>pkgng</application> has a built-in command to
	update package origins.  This can be useful, for example, if
	<package>lang/php5</package> is renamed to
	<package>lang/php53</package> so that
	<package>lang/php5</package> can now
	represent version <literal>5.4</literal>.</para>

      <para>To change the package origin for the above example,
	run:</para>

      <screen>&prompt.root; <userinput>pkg set -o lang/php5:lang/php53</userinput></screen>

      <para>As another example, to update <package>lang/ruby18</package> to <package>lang/ruby19</package>, run:</para>

      <screen>&prompt.root; <userinput>pkg set -o lang/ruby18:lang/ruby19</userinput></screen>

      <para>As a final example, to change the origin of the
	<filename>libglut</filename> shared libraries from <package>graphics/libglut</package> to <package>graphics/freeglut</package>, run:</para>

      <screen>&prompt.root; <userinput>pkg set -o graphics/libglut:graphics/freeglut</userinput></screen>

      <note>
	<para>When changing package origins, it is important to
	  reinstall packages that are dependent on the package with
	  the modified origin.  To force a reinstallation of dependent
	  packages, run:</para>

	<screen>&prompt.root; <userinput>pkg install -Rf graphics/freeglut</userinput></screen>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="ports-using">
    <title>Using the Ports Collection</title>

    <para>The Ports Collection is a set of
      <filename>Makefiles</filename>, patches, and description files
      stored in <filename>/usr/ports</filename>.
      This set of files is used to compile and install applications
      on &os;.  Before an application can be compiled using a port,
      the Ports Collection must first be installed.  If it was not
      installed during the installatio of &os;, use one of the
      following methods to install it:</para>

    <procedure>
      <title>Portsnap Method</title>

      <para><application>Portsnap</application> is a fast and
	user-friendly tool for retrieving the Ports Collection and
	is the recommended choice for most users.  See <xref linkend="updating-upgrading-portsnap"/> for a detailed
	description of <application>Portsnap</application>.</para>

      <step>
	<para>Download a compressed snapshot of the Ports Collection
	  into <filename>/var/db/portsnap</filename>.</para>

	<screen>&prompt.root; <userinput>portsnap fetch</userinput></screen>
      </step>

      <step>
	<para>When running <application>Portsnap</application> for
	  the first time, extract the snapshot into <filename>/usr/ports</filename>:</para>

	<screen>&prompt.root; <userinput>portsnap extract</userinput></screen>
      </step>

      <step>
	<para>After the first use of
	  <application>Portsnap</application> has been completed as
	  shown above, <filename>/usr/ports</filename> can be updated as
	  needed by running:</para>

	<screen>&prompt.root; <userinput>portsnap fetch</userinput>
&prompt.root; <userinput>portsnap update</userinput></screen>
      </step>
    </procedure>

    <procedure>
      <title>Subversion Method</title>

      <para>If more control over the ports tree is needed or if
	local changes need to be maintained,
	<application>Subversion</application> can be used to
	obtain the Ports Collection.  Refer to <link xlink:href="&url.articles.committers-guide;/subversion-primer.html">the
	  Subversion Primer</link> for a detailed description of
	<application>Subversion</application>.</para>

      <step>
	<para><application>Subversion</application> must be
	  installed before it can be used to check out the ports
	  tree.  If a copy of the ports tree is already present,
	  install <application>Subversion</application> like
	  this:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/devel/subversion</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>If the ports tree is not available,
	  <application>Subversion</application> can be installed as
	  a package:</para>

	<screen>&prompt.root; <userinput>pkg_add -r subversion</userinput></screen>

	<para>If <application>pkgng</application> is being used to
	  manage packages, <application>Subversion</application> can
	  be installed with it instead:</para>

	<screen>&prompt.root; <userinput>pkg install subversion</userinput></screen>
      </step>

      <step>
	<para>Check out a copy of the ports tree.  For better
	  performance, replace
	  <replaceable>svn0.us-east.FreeBSD.org</replaceable> with a
	  <link xlink:href="&url.books.handbook;/svn-mirrors.html">Subversion
	    mirror</link> close to your geographic location:</para>

	<screen>&prompt.root; <userinput>svn checkout https://svn0.us-east.FreeBSD.org/ports/head /usr/ports</userinput></screen>
      </step>

      <step>
	<para>As needed, update <filename>/usr/ports</filename> after the initial
	  <application>Subversion</application> checkout:</para>

	<screen>&prompt.root; <userinput>svn update /usr/ports</userinput></screen>
      </step>
    </procedure>

    <para>The Ports Collection installs a series of directories
      representing software categories with each category having
      a subdirectory for each application.  Each subdirectory, also
      referred to as a ports skeleton, contains a set of files that
      tell &os; how to compile and install that program.  Each port
      skeleton includes these files and directories:</para>

    <itemizedlist>
      <listitem>
	<para><filename>Makefile</filename>: contains statements that
	  specify how the application should be compiled and where
	  its components should be installed.</para>
      </listitem>

      <listitem>
	<para><filename>distinfo</filename>: contains the names
	  and checksums of the files that must be downloaded to
	  build the port.</para>
      </listitem>

      <listitem>
	<para><filename>files/</filename>: this directory contains
	  any patches needed for the program to compile and install
	  on &os;.  This directory may also contain other files used
	  to build the port.</para>
      </listitem>

      <listitem>
	<para><filename>pkg-descr</filename>: provides a more detailed
	  description of the program.</para>
      </listitem>

      <listitem>
	<para><filename>pkg-plist</filename>:  a list of all the
	  files that will be installed by the port.  It also tells
	  the ports system which files to remove upon
	  deinstallation.</para>
      </listitem>
    </itemizedlist>

    <para>Some ports include <filename>pkg-message</filename> or
      other files to handle special situations.  For more details
      on these files, and on ports in general, refer to the <link xlink:href="&url.books.porters-handbook;/index.html">&os; Porter's
	Handbook</link>.</para>

    <para>The port does not include the actual source code, also
      known as a <filename>distfile</filename>.  The extract portion
      of building a port will automatically save the downloaded
      source to <filename>/usr/ports/distfiles</filename>.</para>

    <sect2 xml:id="ports-skeleton">
      <title>Installing Ports</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>installing</secondary>
      </indexterm>

      <para>This section provides basic instructions on using the
	Ports Collection to install or remove software.  The detailed
	description of available <command>make</command> targets and
	environment variables is available in &man.ports.7;.</para>

      <warning>
	<para>Before compiling any port, be sure to update the Ports
	  Collection as described in the previous section.  Since
	  the installation of any third-party software can introduce
	  security vulnerabilities, it is recommended to first check
	  <uri xlink:href="http://vuxml.freebsd.org/">http://vuxml.freebsd.org/</uri> for known
	  security issues related to the port.  Alternately, if
	  <package>ports-mgmt/portaudit</package>
	  is installed, run <command>portaudit -F</command> before
	  installing a new port.  This command can be configured to
	  automatically perform a security audit and an update of
	  the vulnerability database during the daily security system
	  check.  For more information, refer to the manual page for
	  <application>portaudit</application> and
	  &man.periodic.8;.</para>
      </warning>

      <para>Using the Ports Collection assumes a working Internet
	connection.  It also requires superuser privilege.</para>

      <para>Some third-party DVD products such as the &os; Toolkit
	from <link xlink:href="http://www.freebsdmall.com/">freebsdmall.com</link>
	contain distfiles which can be used to install ports without
	an Internet connection.  Mount the DVD on <filename>/cdrom</filename>.  If you use a different
	mount point, set the <varname>CD_MOUNTPTS</varname> make
	variable.  The needed distfiles will be automatically used
	if they are present on the disk.  However, the licenses of
	a few ports do not allow their inclusion on the DVD.  This
	could be because a registration form needs to be filled out
	before downloading or redistribution is not allowed.  In
	order to install a port not included on the DVD, a connection
	to the Internet will still be required.</para>

      <para>To compile and install the port, change to the directory
	of the port to be installed, then type <command>make
	  install</command> at the prompt.  Messages will indicate
	the progress:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput>
&prompt.root; <userinput>make install</userinput>
&gt;&gt; lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.88
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.88D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.88.d,8
===&gt;  Applying FreeBSD patches for lsof-4.88.d,8
===&gt;  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===&gt;  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===&gt;  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.88.d,8
===&gt;   Registering installation for lsof-4.88.d,8
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
&prompt.root;</screen>

      <para>Since <command>lsof</command> is a program that runs
	with increased privileges, a security warning is displayed
	as it is installed.  Once the installation is complete, the
	prompt will be returned.</para>

      <para>Some shells keep a cache of the commands that are
	available in the directories listed in the
	<envar>PATH</envar> environment variable, to speed up lookup
	operations for the executable file of these commands.  Users
	of the <command>tcsh</command> shell should type
	<command>rehash</command> so that a newly installed command
	can be used without specifying its full path.  Use
	<command>hash -r</command> instead for the
	<command>sh</command> shell.  Refer to the documentation
	for the shell for more information.</para>

      <para>During installation, a working subdirectory is created
	which contains all the temporary files used during
	compilation.  Removing this directory saves disk space and
	minimizes the chance of problems later when upgrading to the
	newer version of the port:</para>

      <screen>&prompt.root; <userinput>make clean</userinput>
===&gt;  Cleaning for lsof-88.d,8
&prompt.root;</screen>

      <note>
	<para>To save this extra step, instead use <command>make
	    install clean</command> when
	  compiling the port.</para>
      </note>

      <sect3>
	<title>Customizing Ports Installation</title>

	<para>Some ports provide build options which can be used to
	  enable or disable application components, provide security
	  options, or allow for other customizations.  Examples
	  include <package>www/firefox</package>,
	  <package>security/gpgme</package>, and
	  <package>mail/sylpheed-claws</package>.
	  If the port depends upon other ports which have configurable
	  options, it may pause several times for user interaction
	  as the default behavior is to prompt the user to select
	  options from a menu.  To avoid this, run <command>make
	    config-recursive</command>
	  within the port skeleton to do this configuration in one
	  batch.  Then, run <command>make
	    install [clean]</command> to
	  compile and install the port.</para>

	<tip>
	  <para>When using <buildtarget>config-recursive</buildtarget>,
	    the list of ports to configure are gathered by the
	    <buildtarget>all-depends-list</buildtarget> target.  It is
	    recommended to run <command>make
	      config-recursive</command>
	    until all dependent ports options have been defined, and
	    ports options screens no longer appear, to be certain
	    that all dependency options have been configured.</para>
	</tip>

	<para>There are several ways to revisit a port's build options
	  menu in order to add, remove, or change these options after
	  a port has been built.  One method is to
	  <command>cd</command> into the directory containing the
	  port and type <command>make
	    config</command>.  Another
	  option is to use <command>make
	    showconfig</command>.  Another
	  option is to execute <command>make
	    rmconfig</command> which will
	  remove all selected options and allow you to start over.
	  All of these options, and others, are explained in great
	  detail in &man.ports.7;.</para>

	<para>The ports system uses &man.fetch.1; to download the
	  source files, which supports various environment variables.
	  The <envar>FTP_PASSIVE_MODE</envar>,
	  <envar>FTP_PROXY</envar>, and <envar>FTP_PASSWORD</envar>
	  variables may need to be set if the &os; system is behind
	  a firewall or FTP/HTTP proxy.  See &man.fetch.3; for the
	  complete list of supported variables.</para>

	<para>For users who cannot be connected to the Internet all
	  the time, <command>make
	    fetch</command> can be run
	  within <filename>/usr/ports</filename>,
	  to fetch all distfiles, or within a category, such as
	  <filename>/usr/ports/net</filename>, or
	  within the specific port skeleton.  Note that if a port
	  has any dependencies, running this command in a category
	  or ports skeleton will <emphasis>not</emphasis> fetch the
	  distfiles of ports from another category.  Instead, use
	  <command>make
	    fetch-recursive</command> to
	  also fetch the distfiles for all the dependencies of a
	  port.</para>

	<para>In rare cases, such as when an organization has a local
	  distfiles repository, the <varname>MASTER_SITES</varname>
	  variable can be used to override the download locations
	  specified in the <filename>Makefile</filename>.  When using,
	  specify the alternate location:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/directory</userinput>
&prompt.root; <userinput>make MASTER_SITE_OVERRIDE= \
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch</userinput></screen>

	<para>The <varname>WRKDIRPREFIX</varname> and
	  <varname>PREFIX</varname> variables can override the default
	  working and target directories.  For example:</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=/usr/home/example/ports install</userinput></screen>

	<para>will compile the port in <filename>/usr/home/example/ports</filename> and
	  install everything under <filename>/usr/local</filename>.</para>

	<screen>&prompt.root; <userinput>make PREFIX=/usr/home/example/local install</userinput></screen>

	<para>will compile the port in <filename>/usr/ports</filename> and install it
	  in <filename>/usr/home/example/local</filename>.
	  And:</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=../ports PREFIX=../local install</userinput></screen>

	<para>will combine the two.</para>

	<para>These can also be set as environmental variables.
	  Refer to the manual page for your shell for instructions
	  on how to set an environmental variable.</para>

      </sect3>
    </sect2>

    <sect2 xml:id="ports-removing">
      <title>Removing Installed Ports</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>removing</secondary>
      </indexterm>

      <para>Installed ports can be uninstalled using
	&man.pkg.delete.1;.  Alternately, if the &os; system has been
	configured to use <application>pkg</application>, a port can
	be uninstalled using <command>pkg delete</command>.  Examples
	for using these commands can be found in <xref linkend="packages-using"/> and <xref linkend="pkgng-intro"/></para>

      <para>Alternately, <command>make deinstall</command> can be
	run in the port's directory:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput>
<userinput>make deinstall</userinput>
===&gt;  Deinstalling for sysutils/lsof
===&gt;   Deinstalling
Deinstallation has been requested for the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done</screen>

      <para>It is recommended to read the messages as the port is
	uninstalled.  If the port has any applications that depend
	upon it, this information will be displayed but the
	uninstallation will proceed.  In such cases, it may be better
	to reinstall the application in order to prevent broken
	dependencies.</para>
    </sect2>

    <sect2 xml:id="ports-upgrading">
      <title>Upgrading Ports</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>upgrading</secondary>
      </indexterm>

      <para>Over time, newer versions of software become available
	in the Ports Collection.  This section describes how to
	determine which software can be upgraded and how to perform
	the upgrade.</para>

      <para>To determine if newer versions of installed ports are
	available, ensure that the latest version of the ports tree
	is installed, using the updating command described in either
	Procedure 5.1 or Procedure 5.2.  Then, run this command to
	get a listing of the ports which are older than the currently
	available version:</para>

      <screen>&prompt.root; <userinput>pkg_version -l "&lt;"</userinput></screen>

      <important>
	<para>Before
	  attempting an upgrade, read
	  <filename>/usr/ports/UPDATING</filename> from the top of
	  the file to the date closest to the last time ports were
	  upgraded or the system was installed.  This file
	  describes various issues and additional steps users may
	  encounter and need to perform when updating a port,
	  including such things as file format changes, changes in
	  locations of configuration files, or any
	  incompatibilities with previous versions.  Make note of
	  any instructions which match any of the ports that need
	  upgrading and follow these instructions when performing
	  the upgrade.</para>
      </important>

      <para>To perform the actual upgrade, use either
	<application>Portmaster</application> or
	<application>Portupgrade</application>.</para>

      <sect3 xml:id="portmaster">
	<title>Upgrading Ports Using
	  <application>Portmaster</application></title>

	<indexterm>
	  <primary>portmaster</primary>
	</indexterm>

	<para>The <package>ports-mgmt/portmaster</package>
	  package or port is the recommended tool for upgrading
	  installed ports as it is designed to use the tools installed
	  with &os; without depending upon other ports.  It uses the
	  information in <filename>/var/db/pkg/</filename> to determine
	  which ports to upgrade.  To install this utility as a
	  port:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portmaster</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para><application>Portmaster</application> defines four
	  categories of ports:</para>

	<itemizedlist>
	  <listitem>
	    <para>Root port: has no dependencies and is not a
	      dependency of any other ports.</para>
	  </listitem>

	  <listitem>
	    <para>Trunk port: has no dependencies, but other ports
	      depend upon it.</para>
	  </listitem>

	  <listitem>
	    <para>Branch port: has dependencies and other ports
	      depend upon it.</para>
	  </listitem>

	  <listitem>
	    <para>Leaf port: has dependencies but no other ports
	      depend upon it.</para>
	  </listitem>
	</itemizedlist>

	<para>To list these categories and search for updates:</para>

	<screen>&prompt.root; <userinput>portmaster -L</userinput>
===&gt;&gt;&gt; Root ports (No dependencies, not depended on)
===&gt;&gt;&gt; ispell-3.2.06_18
===&gt;&gt;&gt; screen-4.0.3
        ===&gt;&gt;&gt; New version available: screen-4.0.3_1
===&gt;&gt;&gt; tcpflow-0.21_1
===&gt;&gt;&gt; 7 root ports
...
===&gt;&gt;&gt; Branch ports (Have dependencies, are depended on)
===&gt;&gt;&gt; apache22-2.2.3
        ===&gt;&gt;&gt; New version available: apache22-2.2.8
...
===&gt;&gt;&gt; Leaf ports (Have dependencies, not depended on)
===&gt;&gt;&gt; automake-1.9.6_2
===&gt;&gt;&gt; bash-3.1.17
        ===&gt;&gt;&gt; New version available: bash-3.2.33
...
===&gt;&gt;&gt; 32 leaf ports

===&gt;&gt;&gt; 137 total installed ports
        ===&gt;&gt;&gt; 83 have new versions available</screen>

	<para>This command is used to upgrade all outdated
	  ports:</para>

	<screen>&prompt.root; <userinput>portmaster -a</userinput></screen>

	<note>
	  <para>By default, <application>Portmaster</application> will
	    make a backup package before deleting the existing port.
	    If the installation of the new version is successful,
	    <application>Portmaster</application> will delete the
	    backup.  Using <option>-b</option> will instruct
	    <application>Portmaster</application> not to automatically
	    delete the backup.  Adding <option>-i</option> will start
	    <application>Portmaster</application> in interactive mode,
	    prompting for confirmation before upgrading each port.
	    Many other options are available.  Read through the
	    manual page for portmaster(8) for details regarding
	    their usage.</para>
	</note>

	<para>If errors are encountered during the upgrade process,
	  add <option>-f</option> to upgrade and rebuild all
	  ports:</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para><application>Portmaster</application> can also be used
	  to install new ports on the system, upgrading all
	  dependencies before building and installing the new
	  port.  To use this function, specify the location of the
	  port in the Ports Collection:</para>

	<screen>&prompt.root; <userinput>portmaster shells/bash</userinput></screen>
      </sect3>

      <sect3 xml:id="portupgrade">
	<title>Upgrading Ports Using Portupgrade</title>

	<indexterm>
	  <primary>portupgrade</primary>
	</indexterm>

	<para>Another utility that can be used to upgrade ports is
	  <application>Portupgrade</application>, which is
	  available as the <package>ports-mgmt/portupgrade</package> package
	  or port.  This utility installs a suite of applications
	  which can be used to manage ports.  However, it is dependent
	  upon Ruby.  To install the port:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portupgrade</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>Before performing an upgrade using this utility, it is
	  recommended to scan the list of installed ports using
	  <command>pkgdb -F</command> and to fix all the
	  inconsistencies it reports.</para>

	<para>To upgrade all the outdated ports installed on the
	  system, use <command>portupgrade -a</command>.  Alternately,
	  include <option>-i</option> to be asked for confirmation
	  of every individual upgrade:</para>

	<screen>&prompt.root; <userinput>portupgrade -ai</userinput></screen>

	<para>To upgrade only a specified application instead of all
	  available ports, use <command>portupgrade
	    pkgname</command>.  It is
	  very important to include <option>-R</option> to first
	  upgrade all the ports required by the given
	  application:</para>

	<screen>&prompt.root; <userinput>portupgrade -R firefox</userinput></screen>

	<para>If
	  <option>-P</option> is included,
	  <application>Portupgrade</application> searches for
	  available packages in the local directories listed in
	  <envar>PKG_PATH</envar>.  If none are available locally,
	  it then fetches packages from a remote site.  If
	  packages can not be found locally or fetched remotely,
	  <application>Portupgrade</application> will use ports.  To
	  avoid using ports entirely, specify <option>-PP</option>.
	  This last set of options tells
	  <application>Portupgrade</application> to abort if no
	  packages are available:</para>

	<screen>&prompt.root; <userinput>portupgrade -PP gnome2</userinput></screen>

	<para>To just fetch the port distfiles, or packages, if
	  <option>-P</option> is specified, without building or
	  installing anything, use <option>-F</option>.  For further
	  information on all of the available switches, refer to the
	  manual page for <command>portupgrade</command>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="ports-disk-space">
      <title>Ports and Disk Space</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>disk-space</secondary>
      </indexterm>

      <para>Using the Ports Collection will use up disk space over
	time.  After building and installing a port, running
	<command>make clean</command>
	within the ports skeleton will clean up the temporary
	<filename>work</filename> directory.  If
	<application>Portmaster</application> is used to install a
	port, it will automatically remove this directory unless
	<option>-K</option> is specified.  If
	<application>Portupgrade</application> is installed, this
	command will remove all <filename>work</filename> directories found within
	the local copy of the Ports Collection:</para>

      <screen>&prompt.root; <userinput>portsclean -C</userinput></screen>

      <para>In addition, a lot of out-dated source distribution files
	will collect in <filename>/usr/ports/distfiles</filename> over time.
	If <application>Portupgrade</application> is installed, this
	command will delete all the distfiles that are no longer
	referenced by any ports:</para>

      <screen>&prompt.root; <userinput>portsclean -D</userinput></screen>

      <para>To use <application>Portupgrade</application> to remove
	all distfiles not referenced by any port currently installed
	on the system:</para>

      <screen>&prompt.root; <userinput>portsclean -DD</userinput></screen>

      <para>If <application>Portmaster</application> is installed,
	use:</para>

      <screen>&prompt.root; <userinput>portmaster --clean-distfiles</userinput></screen>

      <para>By default, this command is interactive and will prompt
	the user to confirm if a distfile should be deleted.</para>

      <para>In addition to these commands, the <package>ports-mgmt/pkg_cutleaves</package> package
	or port automates the task of removing installed ports that
	are no longer needed.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ports-nextsteps">
    <title>Post-Installation Considerations</title>

    <para>Regardless of whether the software was installed from a
      binary package or port, most third-party applications require
      some level of configuration after installation.  The following
      commands and locations can be used to help determine what was
      installed with the application.</para>

    <itemizedlist>
      <listitem>
	<para>Most applications install at least one default
	  configuration file in <filename>/usr/local/etc</filename>.  The
	  configuration files should be reviewed and possibly edited
	  to meet the system's needs.</para>
      </listitem>

      <listitem>
	<para>Applications which provide documentation will install
	  it into <filename>/usr/local/share/doc</filename> and many
	  applications also install manual pages.  This documentation
	  should be consulted before continuing.</para>
      </listitem>

      <listitem>
	<para>Some applications run services which must be added
	  to <filename>/etc/rc.conf</filename>
	  before starting the application.  These applications usually
	  install a startup script in
	  <filename>/usr/local/etc/rc.d</filename>.  See <link linkend="configtuning-starting-services">Starting
	    Services</link> for more information.</para>
      </listitem>

      <listitem>
	<para>Users of &man.csh.1; should run
	  <command>rehash</command> to rebuild the known binary
	  list in the shells <envar>PATH</envar>.</para>
      </listitem>

      <listitem>
	<para>If the system is running the traditional package system,
	  use &man.pkg.info.1; to determine which files, man pages,
	  and binaries were installed with the application.  If the
	  system is running <application>pkgng</application>, instead
	  use <command>pkg info</command>.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="ports-broken">
    <title>Dealing with Broken Ports</title>

    <para>When a port does not build or
      install, try the following:</para>

    <orderedlist>
      <listitem>
	<para>Search to see if there is a fix pending for the port in
	  the <link xlink:href="&url.base;/support.html#gnats">Problem
	    Report database</link>.  If so, implementing the proposed
	  fix may fix the issue.</para>
      </listitem>

      <listitem>
	<para>Ask the maintainer of the port for help.  Type
	  <command>make maintainer</command>
	  in the ports skeleton or read the port's
	  <filename>Makefile</filename> to find the maintainer's
	  email address.  Remember to include the
	  <literal>&dollar;FreeBSD:</literal> line from the port's
	  <filename>Makefile</filename> and the output leading up to
	  the error in the email to the maintainer.</para>

	<note>
	  <para>Some ports are not maintained by an individual but
	    instead by a <link xlink:href="&url.articles.mailing-list-faq;/article.html">mailing
	      list</link>.  Many, but not all, of these addresses
	    look like <email role="nolink">freebsd-listname@FreeBSD.org</email>.
	    Take this into account when sending an email.</para>

	  <para>In particular, ports shown as maintained by <email role="nolink">ports@FreeBSD.org</email> are not
	    maintained by a specific individual.  Instead, any fixes
	    and support come from the general community who subscribe
	    to that mailing list.  More volunteers are always
	    needed!</para>
	</note>

	<para>If there is no response to the email, use
	  &man.send-pr.1; to submit a bug report using the
	  instructions in <link xlink:href="&url.articles.problem-reports;/article.html">Writing
	    &os; Problem Reports</link>.</para>
      </listitem>

      <listitem>
	<para>Fix it!  The <link xlink:href="&url.books.porters-handbook;/index.html">Porter's
	    Handbook</link> includes detailed information on the
	  ports infrastructure so that you can fix the
	  occasional broken port or even submit your own!</para>
      </listitem>

      <listitem>
	<para>Install the package instead of the port using the
	  instructions in <xref linkend="packages-using"/> or <xref linkend="pkgng-intro"/>.</para>
      </listitem>
    </orderedlist>
  </sect1>
</chapter>
