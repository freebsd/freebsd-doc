<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="serialcomms">
  <title>Serial Communications</title>

  <sect1 id="serial-synopsis">
    <title>Synopsis</title>

    <indexterm><primary>serial communications</primary></indexterm>

    <para>&unix; has always had support for serial communications as
      the very first &unix; machines relied on serial lines for user
      input and output.  Things have changed a lot from the days
      when the average terminal consisted of a 10-character-per-second
      serial printer and a keyboard.  This chapter covers some of the
      ways serial communications can be used on &os;.</para>

    <para>After reading this chapter, you will know:</para>

    <itemizedlist>
      <listitem>
	<para>How to connect terminals to a &os; system.</para>
      </listitem>
      <listitem>
	<para>How to use a modem to dial out to remote hosts.</para>
      </listitem>
      <listitem>
	<para>How to allow remote users to login to a &os; system
	  with a modem.</para>
      </listitem>
      <listitem>
	<para>How to boot a &os; system from a serial console.</para>
      </listitem>
    </itemizedlist>

    <para>Before reading this chapter, you should:</para>

    <itemizedlist>
      <listitem>
	<para>Know how to <link linkend="kernelconfig"> configure and
	    install a custom kernel</link>.</para>
      </listitem>
      <listitem>
	<para>Understand <link linkend="basics"> &os; permissions
	    and processes</link>.</para>
      </listitem>
      <listitem>
	<para>Have access to the technical manual for the serial
	  hardware to be used with &os;.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="serial">
    <title>Introduction</title>

    <!-- XXX Write me! -->

    <sect2 id="serial-terminology">
      <title>Terminology</title>

      <variablelist>
	<indexterm><primary>bits-per-second</primary></indexterm>
	<varlistentry>
	  <term><acronym>bps</acronym></term>
	  <listitem>
	    <para>Bits per Second (<acronym>bps</acronym>) is the rate
	      at which data is transmitted.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><acronym>DTE</acronym></term>
	  <listitem>
	    <indexterm><primary>DTE</primary></indexterm>

	    <para>An example of a Data Terminal Equipment
	      (<acronym>DTE</acronym>) is a computer.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><acronym>DCE</acronym></term>
	  <listitem>
	    <indexterm><primary>DCE</primary></indexterm>

	    <para>An example of a Data Communications Equipment
	      (<acronym>DTE</acronym>) is a modem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RS-232</term>

	  <listitem>
	    <indexterm><primary>RS-232C cables</primary></indexterm>

	    <para>The original standard for hardware serial
	      communications.  It is now usually referred to as
	      <acronym>TIA</acronym>-232</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>When talking about communications data rates, this section
	does not use the term <quote>baud</quote>.  Baud refers to the
	number of electrical state transitions that may be made in a
	period of time, while <acronym>bps</acronym> is the
	<emphasis>correct</emphasis> term to use.</para>
    </sect2>

    <sect2 id="serial-cables-ports">
      <title>Cables and Ports</title>

      <para>To connect a modem or serial terminal to a &os; system, a
	serial port on the computer and the proper cable to connect to
	the serial device are needed.  Users who are already familiar
	with serial hardware and cabling can safely skip this
	section.</para>

      <sect3 id="term-cables">
	<title>Cables</title>

	<para>There are several different kinds of serial cables.  The
	  two most common types are null-modem cables and standard
	  RS-232 cables.  The documentation for the hardware should
	  describe the type of cable required.</para>

	<sect4 id="term-cables-null">
	  <title>Null-modem Cables</title>

	  <indexterm>
	    <primary>null-modem cable</primary>
	  </indexterm>

	  <para>A null-modem cable passes some signals, such as
	    <quote>Signal Ground</quote>, straight through, but
	    switches other signals.  For example, the
	    <quote>Transmitted Data</quote> pin on one end goes to the
	    <quote>Received Data</quote> pin on the other end.</para>

	  <para>A null-modem cable can be constructed for use with
	    terminals.  The following table shows the RS-232C <link
	      linkend="serialcomms-signal-names">signal names</link>
	    and the pin numbers on a DB-25 connector.  While the
	    standard calls for a straight-through pin 1 to pin 1
	    <emphasis>Protective Ground</emphasis> line, it is often
	    omitted.  Some terminals work using only pins 2, 3, and
	    7, while others require different configurations than
	    the examples shown below.</para>

	  <table frame="none" pgwide="1">
	    <title>DB-25 to DB-25 Null-Modem Cable</title>

	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry align="left">Signal</entry>
		  <entry align="left">Pin #</entry>
		  <entry></entry>
		  <entry align="left">Pin #</entry>
		  <entry align="left">Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>connects to</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>2</entry>
		  <entry>connects to</entry>
		  <entry>3</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>RD</entry>
		  <entry>3</entry>
		  <entry>connects to</entry>
		  <entry>2</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry>connects to</entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>connects to</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>connects to</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>connects to</entry>
		  <entry>8</entry>
		  <entry>DCD</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>connects to</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry>connects to</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>The next two tables show two other common
	    schemes.</para>

	  <table frame="none" pgwide="1">
	    <title>DB-9 to DB-9 Null-Modem Cable</title>

	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry align="left">Signal</entry>
		  <entry align="left">Pin #</entry>
		  <entry></entry>
		  <entry align="left">Pin #</entry>
		  <entry align="left">Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>RD</entry>
		  <entry>2</entry>
		  <entry>connects to</entry>
		  <entry>3</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>3</entry>
		  <entry>connects to</entry>
		  <entry>2</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>4</entry>
		  <entry>connects to</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>4</entry>
		  <entry>connects to</entry>
		  <entry>1</entry>
		  <entry>DCD</entry>
		</row>

		<row>
		  <entry>SG</entry>
		  <entry>5</entry>
		  <entry>connects to</entry>
		  <entry>5</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>connects to</entry>
		  <entry>4</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>1</entry>
		  <entry>connects to</entry>
		  <entry>4</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>7</entry>
		  <entry>connects to</entry>
		  <entry>8</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>8</entry>
		  <entry>connects to</entry>
		  <entry>7</entry>
		  <entry>RTS</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <table frame="none" pgwide="1">
	    <title>DB-9 to DB-25 Null-Modem Cable</title>

	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry align="left">Signal</entry>
		  <entry align="left">Pin #</entry>
		  <entry></entry>
		  <entry align="left">Pin #</entry>
		  <entry align="left">Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>RD</entry>
		  <entry>2</entry>
		  <entry>connects to</entry>
		  <entry>2</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>3</entry>
		  <entry>connects to</entry>
		  <entry>3</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>4</entry>
		  <entry>connects to</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>4</entry>
		  <entry>connects to</entry>
		  <entry>8</entry>
		  <entry>DCD</entry>
		</row>

		<row>
		  <entry>SG</entry>
		  <entry>5</entry>
		  <entry>connects to</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>connects to</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>1</entry>
		  <entry>connects to</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>7</entry>
		  <entry>connects to</entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>8</entry>
		  <entry>connects to</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <note>
	    <para>When one pin at one end connects to a pair of pins
	      at the other end, it is usually implemented with one
	      short wire between the pair of pins in their connector
	      and a long wire to the other single pin.</para>
	  </note>

	  <para>The above designs seem to be the most popular.  In
	    another variation, SG connects to SG, TD connects to RD,
	    RTS and CTS connect to DCD, DTR connects to DSR, and
	    vice-versa.</para>
	</sect4>

	<sect4 id="term-cables-std">
	  <title>Standard RS-232C Cables</title>

	  <indexterm><primary>RS-232C cables</primary></indexterm>

	  <para>A standard serial cable passes all of the RS-232C
	    signals straight through.  The <quote>Transmitted
	      Data</quote> pin on one end of the cable goes to the
	    <quote>Transmitted Data</quote> pin on the other end.
	    This is the type of cable used to connect a modem to
	    the &os; system, and is also appropriate for some
	    terminals.</para>
	</sect4>
      </sect3>

      <sect3 id="term-ports">
	<title>Ports</title>

	<para>Serial ports are the devices through which data is
	  transferred between the &os; host computer and the
	  terminal.  This section describes the kinds of ports that
	  exist and how they are addressed in &os;.</para>

	<sect4 id="term-portkinds">
	  <title>Kinds of Ports</title>

	  <para>Several kinds of serial ports exist.  Before
	    purchasing or constructing a cable, make sure it will
	    fit the ports on the terminal and on the &os;
	    system.</para>

	  <para>Most terminals have DB-25 ports.  Personal computers
	    may have DB-25 or DB-9 ports.  A multiport serial card may
	    have RJ-12 or RJ-45 ports.</para>

	  <para>See the documentation that accompanied the hardware
	    for specifications on the kind of port or visually verify
	    the type of port.</para>
	</sect4>

	<sect4 id="term-portnames">
	  <title>Port Names</title>

	  <para>In &os;, each serial port is accessed through an
	    entry in <filename class="directory">/dev</filename>.
	    There are two different kinds of entries:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Call-in ports are named
		<filename>/dev/ttyu<replaceable>N</replaceable></filename>
		where <replaceable>N</replaceable> is the port number,
		starting from zero.  Generally, the call-in port is
		used for terminals.  Call-in ports require that the
		serial line assert the Data Carrier Detect
		(<acronym>DCD</acronym>) signal to work
		correctly.</para>
	    </listitem>

	    <listitem>
	      <para>Call-out ports are named
		<filename>/dev/cuau<replaceable>N</replaceable></filename>.
		Call-out ports are usually not used for terminals, but
		are used for modems.  The call-out port can be used if
		the serial cable or the terminal does not support the
		carrier detect signal.</para>
	    </listitem>
	  </itemizedlist>

	  <para>If a terminal is connected to the first serial
	    port(<devicename>COM1</devicename>), use
	    <filename>/dev/ttyu0</filename> to refer to the
	    terminal.  If the terminal is on the second serial port
	    (<devicename>COM2</devicename>), use
	    <filename>/dev/ttyu1</filename>, and so forth.</para>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Kernel Configuration</title>

      <para>&os; supports four serial ports by default.  In the
	&ms-dos; world, these are known as
	<devicename>COM1</devicename>,
	<devicename>COM2</devicename>,
	<devicename>COM3</devicename>, and
	<devicename>COM4</devicename>.  &os; currently supports
	<quote>dumb</quote> multiport serial interface cards, such as
	the BocaBoard 1008 and 2016, as well as more intelligent
	multi-port cards such as those made by Digiboard and Stallion
	Technologies.  However, the default kernel only looks for the
	standard COM ports.</para>

      <para>To see if the kernel recognizes the serial ports,
	watch for messages while the kernel is booting, or use
	<command>/sbin/dmesg</command> to replay the kernel's
	boot messages.  Look for messages that start with the
	characters <literal>uart</literal>:</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'uart'</userinput></screen>

      <para>If the kernel does not recognize all of the serial
	ports, configure <filename>/boot/device.hints</filename>.
	When editing this file, one can comment out or completely
	remove lines for devices that do not exist on the
	system.</para>

      <note>
	<para><literal>port IO_COM1</literal> is a substitution for
	  <literal>port 0x3f8</literal>, <literal>IO_COM2</literal> is
	  <literal>0x2f8</literal>, <literal>IO_COM3</literal> is
	  <literal>0x3e8</literal>, and <literal>IO_COM4</literal> is
	  <literal>0x2e8</literal>.  These are fairly common port
	  addresses for their respective serial ports and interrupts
	  4, 3, 5, and 9 are fairly common interrupt request lines.
	  Regular serial ports <emphasis>cannot</emphasis> share
	  interrupts on ISA-bus PCs.  Multiport boards have
	  on-board electronics that allow all the 16550A's on the
	  board to share one or two interrupt request lines.</para>
      </note>

    </sect2>

    <sect2>
      <title>Device Special Files</title>

      <para>Most devices in the kernel are accessed through
	<quote>device special files</quote> which are located in
	<filename class="directory">/dev</filename>.  The
	<devicename>sio</devicename> devices are accessed through the
	<filename>/dev/ttyu<replaceable>N</replaceable></filename>
	(dial-in) and
	<filename>/dev/cuau<replaceable>N</replaceable></filename>
	(call-out) devices.  &os; also provides initialization
	devices
	(<filename>/dev/ttyu<replaceable>N</replaceable>.init</filename>
	and
	<filename>/dev/cuau<replaceable>N</replaceable>.init</filename>)
	and locking devices
	(<filename>/dev/ttyu<replaceable>N</replaceable>.lock</filename>
	and
	<filename>/dev/cuau<replaceable>N</replaceable>.lock</filename>).
	The initialization devices are used to initialize
	communications port parameters each time a port is opened,
	such as <literal>crtscts</literal> for modems which use
	<literal>RTS/CTS</literal> signaling for flow control.  The
	locking devices are used to lock flags on ports to prevent
	users or programs changing certain parameters.  Refer to
	&man.termios.4;, &man.sio.4;, and &man.stty.1; for
	information on terminal settings, locking and initializing
	devices, and setting terminal options, respectively.</para>
    </sect2>


    <sect2 id="serial-hw-config">
      <title>Serial Port Configuration</title>

      <indexterm><primary><devicename>ttyu</devicename></primary></indexterm>
      <indexterm><primary><devicename>cuau</devicename></primary></indexterm>

      <para>The
	<devicename>ttyu<replaceable>N</replaceable></devicename> (or
	<devicename>cuau<replaceable>N</replaceable></devicename>)
	is the regular device to open for applications.  When a
	process opens the device, it will have a default set of
	terminal I/O settings.  These settings can be viewed with the
	command:</para>

      <screen>&prompt.root; <userinput>stty -a -f /dev/ttyu1</userinput></screen>

      <para>When the settings are changed for a device, the settings
	are in effect until the device is closed.  When the device is
	reopened, it goes back to the default set.  To permanently
	change the default set, open and adjust the settings of the
	<quote>initial state</quote> device.  For example, to turn on
	<option>CLOCAL</option> mode, 8 bit communication, and
	<option>XON/XOFF</option> flow control for
	<devicename>ttyu5</devicename>, type:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</userinput></screen>

      <indexterm>
	<primary>rc files</primary>
	<secondary><filename>rc.serial</filename></secondary>
      </indexterm>

      <para>System-wide initialization of serial devices is
	controlled by <filename>/etc/rc.d/serial</filename>.  This
	file affects the default settings of serial devices.</para>

      <para>To prevent certain settings from being changed by an
	application, make adjustments to the <quote>lock state</quote>
	device.  For example, to lock the speed of
	<devicename>ttyu5</devicename> to 57600&nbsp;bps, type:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.lock 57600</userinput></screen>

      <para>Now, an application that opens
	<devicename>ttyu5</devicename> and tries to change the speed
	of the port will be stuck with 57600&nbsp;bps.</para>

      <para>The initial state and lock state devices should only be
	writable by <username>root</username>.</para>
    </sect2>
  </sect1>

  <sect1 id="term">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  <contrib>Contributed by </contrib>
	</author>
	<!-- 28 July 1996 -->
      </authorgroup>
    </sect1info>
    <title>Terminals</title>

    <indexterm><primary>terminals</primary></indexterm>

    <para>Terminals provide a convenient and low-cost way to access
      a &os; system when not at the computer's console or on a
      connected network.  This section describes how to use terminals
      with &os;.</para>

    <sect2 id="term-uses">
      <title>Uses and Types of Terminals</title>

      <para>The original &unix; systems did not have consoles.
	Instead, users logged in and ran programs through terminals
	that were connected to the computer's serial ports.</para>

      <para>The ability to establish a login session on a serial port
	still exists in nearly every &unix;-like operating system
	today, including &os;.  By using a terminal attached to an
	unused serial port, a user can log in and run any text program
	that can normally be run on the console or in an
	<command>xterm</command> window.</para>

      <para>Many terminals can be attached to a &os; system.  An older
	spare computer can be used as a terminal wired into a more
	powerful computer running &os;.  This can turn what might
	otherwise be a single-user computer into a powerful multiple
	user system.</para>

      <para>This section describes three kinds of terminals supported
	by &os;: dumb terminals, computers acting as terminals, and X
	terminals.</para>

      <sect3 id="term-dumb">
	<title>Dumb Terminals</title>

	<para>Dumb terminals are specialized hardware that connect to
	  computers over serial lines.  They are called
	  <quote>dumb</quote> because they have only enough
	  computational power to display, send, and receive text.  No
	  programs can be run on these devices.  Dumb terminals
	  connect to a computer that has all the power to run text
	  editors, compilers, email, games, and so forth.</para>

	<para>There are hundreds of kinds of dumb terminals made by
	  many manufacturers, and just about any kind will work with
	  &os;.  Some high-end terminals can even display graphics,
	  but only certain software packages can take advantage of
	  these advanced features.</para>

	<para>Dumb terminals are popular in work environments where
	  workers do not need access to graphical applications.</para>
      </sect3>

      <sect3 id="term-pcs">
	<title>Computers Acting as Terminals</title>

	<para>If a <link linkend="term-dumb">dumb terminal</link> has
	  just enough ability to display, send, and receive text,
	  any spare computer can be a dumb terminal.  All that is
	  needed is the proper cable and some <emphasis>terminal
	    emulation</emphasis> software to run on the
	  computer.</para>

	<para>This configuration can be useful.  For example, if one
	  user is busy working at the &os; system's console, another
	  user can do some text-only work at the same time from a
	  less powerful personal computer hooked up as a terminal to
	  the &os; system.</para>

	<para>There are at least two utilities in the base-system of
	  &os; that can be used to work through a serial connection:
	  &man.cu.1; and &man.tip.1;.</para>

	<para>To connect from a client system that runs &os; to the
	  serial connection of another system, use:</para>

	<screen>&prompt.root; <userinput>cu -l <replaceable>serial-port-device</replaceable></userinput></screen>

	<para>Where <quote>serial-port-device</quote> is the name of a
	  special device file denoting a serial port on the system.
	  These device files are called
	  <devicename>/dev/cuau<replaceable>N</replaceable></devicename>.</para>

	<para>The <quote>N</quote>-part of a device name is the serial
	  port number.</para>

	<note>
	  <para>Note that device numbers in &os; start from zero and
	    not one.  This means that <devicename>COM1</devicename> is
	    <filename>/dev/cuau0</filename> in &os;.</para>
	</note>

	<note>
	  <para>Some people prefer to use other programs available
	    through the Ports Collection, such as <filename
	      role="package">comms/minicom</filename>.</para>
	</note>
      </sect3>

      <sect3 id="term-x">
	<title>X Terminals</title>

	<para>X terminals are the most sophisticated kind of terminal
	  available.  Instead of connecting to a serial port, they
	  usually connect to a network like Ethernet.  Instead of
	  being relegated to text-only applications, they can display
	  any X application.</para>

	<para>This chapter does <emphasis>not</emphasis> cover the
	  setup, configuration, or use of X terminals.</para>
      </sect3>
    </sect2>

    <sect2 id="term-config">
      <title>Configuration</title>

      <para>This section describes how to configure a &os; system to
	enable a login session on a terminal.  It assumes that the
	kernel is configured to support the serial port to which the
	terminal is connected and that the terminal is
	connected.</para>

      <para>The <command>init</command> process is responsible for all
	process control and initialization at system startup.  One of
	the tasks performed by <command>init</command> is to read
	<filename>/etc/ttys</filename> and start a
	<command>getty</command> process on the available terminals.
	The <command>getty</command> process is responsible for
	reading a login name and starting the <command>login</command>
	program.</para>

      <para>To configure terminals for a &os; system, the following
	steps should be taken as <username>root</username>:</para>

      <procedure>
	<step>
	  <para>Add a line to <filename>/etc/ttys</filename> for the
	    entry in <filename class="directory">/dev</filename> for
	    the serial port if it is not already there.</para>
	</step>

	<step>
	  <para>Specify that <command>/usr/libexec/getty</command>
	    be run on the port, and specify the appropriate
	    <replaceable>getty</replaceable> type from
	    <filename>/etc/gettytab</filename>.</para>
	</step>

	<step>
	  <para>Specify the default terminal type.</para>
	</step>

	<step>
	  <para>Set the port to <quote>on.</quote></para>
	</step>

	<step>
	  <para>Specify whether the port should be
	    <quote>secure.</quote></para>
	</step>

	<step>
	  <para>Force <command>init</command> to reread
	    <filename>/etc/ttys</filename>.</para>
	</step>
      </procedure>

      <para>As an optional step, create a custom
	<replaceable>getty</replaceable> type for use in step 2 by
	making an entry in <filename>/etc/gettytab</filename>.  For
	more information, refer to &man.gettytab.5; and
	&man.getty.8;.</para>

      <sect3 id="term-etcttys">
	<title>Adding an Entry to
	  <filename>/etc/ttys</filename></title>

	<para><filename>/etc/ttys</filename> lists all of the ports
	  on the &os; system which allow logins.  For example, the
	  first virtual console,
	  <devicename>ttyv0</devicename>, has an entry in this file,
	  allowing logins on the console.  This file also contains
	  entries for the other virtual consoles, serial ports, and
	  pseudo-ttys.  For a hardwired terminal,
	  list the serial port's <filename
	    class="directory">/dev</filename> entry without the
	  <literal>/dev</literal> part.  For example,
	  <filename>/dev/ttyv0</filename> would be listed as
	  <literal>ttyv0</literal>.</para>

	<para>A default &os; install includes an
	  <filename>/etc/ttys</filename> with support for the
	  first four serial ports: <devicename>ttyu0</devicename>
	  through <devicename>ttyu3</devicename>.  When
	  attaching a terminal to one of those ports, this file does
	  not need to be edited.</para>

	<example id="ex-etc-ttys">
	  <title>Adding Terminal Entries to
	    <filename>/etc/ttys</filename></title>

	  <para>This example configures two terminals: a Wyse-50 and
	    an old 286 IBM PC running
	    <application>Procomm</application> terminal software
	    emulating a VT-100 terminal.  The Wyse is connected to the
	    second serial port and the 286 to the sixth serial port on
	    a multiport serial card.  The corresponding entries in
	    <filename>/etc/ttys</filename> would look like
	    this:</para>

	  <programlisting>ttyu1<co
	      id="co-ttys-line1col1"/>  "/usr/libexec/getty std.38400"<co
	      id="co-ttys-line1col2"/>  wy50<co
	      id="co-ttys-line1col3"/>  on<co
	      id="co-ttys-line1col4"/>  insecure<co
	      id="co-ttys-line1col5"/>
ttyu5   "/usr/libexec/getty std.19200"  vt100  on insecure</programlisting>

	  <calloutlist>
	    <callout arearefs="co-ttys-line1col1">
	      <para>The first field normally specifies the name of
		the terminal special file as it is found in
		<filename class="directory">/dev</filename>.</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col2">
	      <para>The second field is the command to execute for
		this line, which is usually &man.getty.8;.
		<command>getty</command> initializes and opens the
		line, sets the speed, prompts for a user name, and
		then executes &man.login.1;.</para>

	      <para>The <command>getty</command> program accepts one
		(optional) parameter on its command line, the
		<replaceable>getty</replaceable> type.  A
		<replaceable>getty</replaceable> type configures
		characteristics on the terminal line, like
		<acronym>bps</acronym> rate and parity.
		<command>getty</command> reads these characteristics
		from <filename>/etc/gettytab</filename>.</para>

	      <para><filename>/etc/gettytab</filename> contains many
		entries for terminal lines, both old and new.  In
		almost all cases, the entries that start with the
		text <literal>std</literal> will work for hardwired
		terminals as these entries ignore parity.  There is
		a <literal>std</literal> entry for each
		<acronym>bps</acronym> rate from 110 to 115200.
		&man.gettytab.5; provides more information.</para>

	      <para>When setting the <replaceable>getty</replaceable>
		type in <filename>/etc/ttys</filename>, make sure
		that the communications settings on the terminal
		match.</para>

	      <para>For this example, the Wyse-50 uses no parity and
		connects at 38400&nbsp;bps.  The 286&nbsp;PC uses no
		parity and connects at 19200&nbsp;bps.</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col3">
	      <para>The third field is the type of terminal usually
		connected to that terminal line.  For dial-up ports,
		<literal>unknown</literal> or
		<literal>dialup</literal> is typically used since
		users may dial up with practically any type of
		terminal or software.  Since the terminal type does
		not change for hardwired terminals, a real terminal
		type from &man.termcap.5; can be used in this
		field.</para>

	      <para>For this example, the Wyse-50 uses the real
		terminal type while the 286 PC running
		<application>Procomm</application> will be set to
		emulate at VT-100. </para>
	    </callout>

	    <callout arearefs="co-ttys-line1col4">
	      <para>The fourth field specifies if the port should be
		enabled.  If set to <literal>on</literal>, the
		<command>init</command> process will start the program
		in the second field, <command>getty</command>.  If
		this field is set to <literal>off</literal>, there
		will be no <command>getty</command>, and hence no
		logins on the port.</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col5">
	      <para>The final field is used to specify whether the
		port is secure.  Marking a port as
		<literal>secure</literal> means that it is trusted
		enough to allow <username>root</username>, or any
		account with a <acronym>UID</acronym> of 0, to login
		from that port.  Insecure ports do not allow
		<username>root</username> logins.  On an insecure
		port, users must login from unprivileged accounts and
		then use &man.su.1; or a similar mechanism to gain
		superuser privileges.</para>

	      <para>It is highly recommended to use
		<literal>insecure</literal>, even for terminals that
		are behind locked doors.  It is quite easy to login
		and use <command>su</command> when superuser
		privileges are needed.</para>
	    </callout>
	  </calloutlist>
	</example>
      </sect3>

      <sect3 id="term-hup">
	<title>Force <command>init</command> to Reread
	  <filename>/etc/ttys</filename></title>

	<para>After making any changes to
	  <filename>/etc/ttys</filename>, send a SIGHUP
	  (hangup) signal to the <command>init</command> process to
	  force it to re-read its configuration file:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<note>
	  <para><command>init</command> is always the first process
	    run on a system, therefore it will always have a process
	    ID of 1.</para>
	</note>

	<para>If everything is set up correctly, all cables are in
	  place, and the terminals are powered up, then a
	  <command>getty</command> process should be running on each
	  terminal and login prompts should be available on each
	  terminal.</para>
      </sect3>
    </sect2>

    <sect2 id="term-debug">
      <title>Troubleshooting the Connection</title>

      <para>Even with the most meticulous attention to detail,
	something could still go wrong while setting up a terminal.
	Here is a list of common symptoms and some suggested
	fixes.</para>

      <sect3>
	<title>No Login Prompt Appears</title>

	<para>Make sure the terminal is plugged in and powered up.  If
	  it is a personal computer acting as a terminal, make sure it
	  is running terminal emulation software on the correct serial
	  port.</para>

	<para>Make sure the cable is connected firmly to both the
	  terminal and the &os; computer.  Make sure it is the
	  right kind of cable.</para>

	<para>Make sure the terminal and &os; agree on the
	  <acronym>bps</acronym> rate and parity settings.  For a
	  video display terminal, make sure the contrast and
	  brightness controls are turned up.  If it is a printing
	  terminal, make sure paper and ink are in good supply.</para>

	<para>Make sure that a <command>getty</command> process is
	  running and serving the terminal.  For example, to get a
	  list of running <command>getty</command> processes with
	  <command>ps</command>, type:</para>

	<screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

	<para>There should be an entry for the terminal.  For example,
	  the following display shows that a
	  <command>getty</command> is running on the second serial
	  port, <devicename>ttyu1</devicename>, and is using the
	  <literal>std.38400</literal> entry in
	  <filename>/etc/gettytab</filename>:</para>

	<screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</screen>

	<para>If no <command>getty</command> process is running, make
	  sure the port is enabled in
	  <filename>/etc/ttys</filename>.  Remember to run
	  <command>kill -HUP 1</command> after modifying
	  <filename>/etc/ttys</filename>.</para>

	<para>If the <command>getty</command> process is running
	  but the terminal still does not display a login prompt,
	  or if it displays a prompt but will not accept typed input,
	  the terminal or cable may not support hardware handshaking.
	  Try changing the entry in <filename>/etc/ttys</filename>
	  from <literal>std.38400</literal> to
	  <literal>3wire.38400</literal>, then run
	  <command>kill -HUP 1</command> after modifying
	  <filename>/etc/ttys</filename>.  The
	  <literal>3wire</literal> entry is similar to
	  <literal>std</literal>, but ignores hardware
	  handshaking.  The baud rate may need to be reduced or
	  software flow control enabled when using
	  <literal>3wire</literal> to prevent buffer overflows.</para>

      </sect3>

      <sect3>
	<title>If Garbage Appears Instead of a Login Prompt</title>

	<para>Make sure the terminal and &os; agree on the
	  <acronym>bps</acronym> rate and parity settings.  Check the
	  <command>getty</command> processes to make sure the correct
	  <replaceable>getty</replaceable> type is in use.  If not,
	  edit <filename>/etc/ttys</filename> and run <command>kill
	    -HUP 1</command>.</para>

      </sect3>

      <sect3>
	<title>Characters Appear Doubled and the Password Appears When
	  Typed</title>

	<para>Switch the terminal, or the terminal emulation software,
	  from <quote>half duplex</quote> or <quote>local echo</quote>
	  to <quote>full duplex.</quote></para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="dialup">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Guy</firstname>
	  <surname>Helmer</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  <contrib>Additions by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Dial-in Service</title>

    <indexterm><primary>dial-in service</primary></indexterm>

    <para>Configuring a &os; system for dial-in service is similar
      to connecting terminals except that modems are used instead of
      terminal devices.</para>

    <sect2>
      <title>External Versus Internal Modems</title>

      <para>External modems are more convenient for dial-up because
	they often can be semi-permanently configured via parameters
	stored in non-volatile RAM and they usually provide lighted
	indicators that display the state of important RS-232 signals,
	indicating whether the modem is operating properly.</para>

      <para>Internal modems usually lack non-volatile RAM, so their
	configuration may be limited to setting DIP switches.  If the
	internal modem has any signal indicator lights, they are
	difficult to view when the system's cover is in place.</para>

      <sect3>
	<title>Modems and Cables</title>

	<indexterm><primary>modem</primary></indexterm>

	<para>When using an external modem, a proper cable is needed.
	  A standard RS-232C serial cable should suffice as long as
	  all of the normal signals are wired:</para>

	<table frame="none" pgwide="1" id="serialcomms-signal-names">
	  <title>Signal Names</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry align="left">Acronyms</entry>
		<entry align="left">Names</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><acronym>RD</acronym></entry>
		<entry>Received Data</entry>
	      </row>

	      <row>
		<entry><acronym>TD</acronym></entry>
		<entry>Transmitted Data</entry>
	      </row>

	      <row>
		<entry><acronym>DTR</acronym></entry>
		<entry>Data Terminal Ready</entry>
	      </row>

	      <row>
		<entry><acronym>DSR</acronym></entry>
		<entry>Data Set Ready</entry>
	      </row>

	      <row>
		<entry><acronym>DCD</acronym></entry>
		<entry>Data Carrier Detect (RS-232's Received Line
		  Signal Detector)</entry>
	      </row>

	      <row>
		<entry><acronym>SG</acronym></entry>
		<entry>Signal Ground</entry>
	      </row>

	      <row>
		<entry><acronym>RTS</acronym></entry>
		<entry>Request to Send</entry>
	      </row>

	      <row>
		<entry><acronym>CTS</acronym></entry>
		<entry>Clear to Send</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>&os; needs the <acronym>RTS</acronym> and
	  <acronym>CTS</acronym> signals for flow control at speeds
	  above 2400&nbsp;bps, the <acronym>CD</acronym> signal to
	  detect when a call has been answered or the line has been
	  hung up, and the <acronym>DTR</acronym> signal to reset the
	  modem after a session is complete.  Some cables are wired
	  without all of the needed signals, so if a login session
	  does not go away when the line hangs up, there may be a
	  problem with the cable.</para>

	<para>Like other &unix;-like operating systems, &os; uses
	  the hardware signals to find out when a call has been
	  answered or a line has been hung up and to hangup and reset
	  the modem after a call.  &os; avoids sending commands to
	  the modem or watching for status reports from the
	  modem.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Serial Interface Considerations</title>

      <para>&os; supports the NS8250-, NS16450-, NS16550-, and
	NS16550A-based EIA RS-232C (CCITT V.24) communications
	interfaces.  The 8250 and 16450 devices have single-character
	buffers.  The 16550 device provides a 16-character buffer,
	which allows for better system performance.  Bugs in plain
	16550's prevent the use of the 16-character buffer, so use
	16550A's if possible.  Because single-character-buffer
	devices require more work by the operating system than the
	16-character-buffer devices, 16550A-based serial interface
	cards are preferred.  If the system has many active serial
	ports or will have a heavy load, 16550A-based cards are better
	for low-error-rate communications.</para>
    </sect2>

    <sect2>
      <title>Quick Overview</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>As with terminals, <command>init</command> spawns a
	<command>getty</command> process for each configured serial
	port for dial-in connections.  For example, if a modem is
	attached to <filename>/dev/ttyu0</filename>,
	<command>ps ax</command> might show this:</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyu0</screen>

      <para>When a user dials the modem's line and the modems connect,
	the Carrier Detect (<acronym>CD</acronym>) line is reported by
	the modem.  The kernel notices that the carrier has been
	detected and instructs <command>getty</command> to open the
	port.  <command>getty</command> sends a
	<prompt>login:</prompt> prompt at the specified initial line
	speed.  <command>getty</command> watches to see if legitimate
	characters are received, and, in a typical configuration, if
	it finds junk (probably due to the modem's connection speed
	being different than <command>getty</command>'s speed),
	<command>getty</command> tries adjusting the line speeds until
	it receives reasonable characters.</para>

      <indexterm>
	<primary><command>/usr/bin/login</command></primary>
      </indexterm>
      <para>After the user enters their login name,
	<command>getty</command> executes
	<filename>/usr/bin/login</filename>, which completes the login
	by asking for the user's password and then starting the user's
	shell.</para>
    </sect2>


    <sect2>
      <title>Configuration Files</title>

      <para>There are three system configuration files in
	<filename class="directory">/etc</filename> that probably
	need to be edited to allow dial-up access to the &os; system.
	<filename>/etc/gettytab</filename> contains configuration
	information for the <filename>/usr/libexec/getty</filename>
	daemon.  <filename>/etc/ttys</filename> holds information that
	tells <command>init</command> which
	<devicename>tty</devicename>s should have
	<command>getty</command> processes running on them.  Lastly,
	port initialization commands can be placed in
	<filename>/etc/rc.d/serial</filename>.</para>

      <para>There are two schools of thought regarding dial-up modems
	on &unix;.  One group likes to configure their modems and
	systems so that no matter at what speed a remote user dials
	in, the local computer-to-modem RS-232 interface runs at a
	locked speed. The benefit of this configuration is that the
	remote user always sees a system login prompt immediately.
	The downside is that the system does not know what a user's
	true data rate is, so full-screen programs like
	<application>Emacs</application> will not adjust their
	screen-painting methods to make their response better for
	slower connections.</para>

      <para>The other group configures their modems' RS-232 interface
	to vary its speed based on the remote user's connection speed.
	For example, V.32bis (14.4&nbsp;Kbps) connections to the modem
	might make the modem run its RS-232 interface at
	19.2&nbsp;Kbps, while 2400&nbsp;bps connections make the
	modem's RS-232 interface run at 2400&nbsp;bps.  Because
	<command>getty</command> does not understand any particular
	modem's connection speed reporting, <command>getty</command>
	gives a <prompt>login:</prompt> message at an initial speed
	and watches the characters that come back in response.  If the
	user sees junk, it is assumed that they know they should press
	<keycap>Enter</keycap> until they see a recognizable prompt.
	If the data rates do not match, <command>getty</command> sees
	anything the user types as <quote>junk</quote>, tries going to
	the next speed and gives the <prompt>login:</prompt> prompt
	again.  This procedure normally only takes a keystroke or two
	before the user sees a good prompt.  This login sequence does
	not look as clean as the <quote>locked-speed</quote> method,
	but a user on a low-speed connection should receive better
	interactive response from full-screen programs.</para>

      <para>This section will try to give balanced configuration
	information, but is biased towards having the modem's data
	rate follow the connection rate.</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

	<indexterm>
	  <primary><filename>/etc/gettytab</filename></primary>
	</indexterm>
	<para><filename>/etc/gettytab</filename> is a
	  &man.termcap.5;-style file of configuration information for
	  &man.getty.8;.  Refer to &man.gettytab.5; for complete
	  information on the format of the file and the list of
	  capabilities.</para>

	<sect4>
	  <title>Locked-speed Config</title>

	  <para>When locking a modem's data communications rate at a
	    particular speed, no changes to
	    <filename>/etc/gettytab</filename> should be
	    needed.</para>
	</sect4>

	<sect4>
	  <title>Matching-speed Config</title>

	  <para>Set up an entry in
	    <filename>/etc/gettytab</filename> to give
	    <command>getty</command> information about the speeds to
	    use for the modem.  For a 2400&nbsp;bps modem, use the
	    existing <literal>D2400</literal> entry.</para>

	  <programlisting>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

	  <para>For a higher speed modem, add an entry in
	    <filename>/etc/gettytab</filename>.  This entry is for a
	    14.4&nbsp;Kbps modem with a top interface speed of
	    19.2&nbsp;Kbps:</para>

	  <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

	  <para>This will result in 8-bit, no parity
	    connections.</para>

	  <para>The example above starts the communications rate at
	    19.2&nbsp;Kbps (for a V.32bis connection), then cycles
	    through 9600&nbsp;bps (for V.32), 2400&nbsp;bps,
	    1200&nbsp;bps, 300&nbsp;bps, and back to 19.2&nbsp;Kbps.
	    Communications rate cycling is implemented with the
	    <literal>nx=</literal> (<quote>next table</quote>)
	    capability.  Each of the lines uses a
	    <literal>tc=</literal> (<quote>table continuation</quote>)
	    entry to pick up the rest of the <quote>standard</quote>
	    settings for a particular data rate.</para>

	  <para>For a 28.8&nbsp;Kbps modem or to take advantage of
	    compression on a 14.4&nbsp;Kbps modem, use a higher
	    communications rate than 19.2&nbsp;Kbps.  Here is an
	    example of a <filename>gettytab</filename> entry starting
	    a 57.6&nbsp;Kbps:</para>

	  <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

	  <para>For a slow CPU or a heavily loaded system without
	    16550A-based serial ports, there may be
	    <errorname>sio</errorname>
	    <quote>silo</quote> errors at 57.6&nbsp;Kbps.</para>
	</sect4>
      </sect3>

      <sect3 id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>

	<indexterm>
	  <primary><filename>/etc/ttys</filename></primary>
	</indexterm>

	<para>Configuration of <filename>/etc/ttys</filename>
	  is covered in <xref linkend="ex-etc-ttys"/>.
	  Configuration for modems is similar, but a different
	  argument is passed to <command>getty</command> and a
	  different terminal type is specified.  The general format
	  for both locked-speed and matching-speed configurations
	  is:</para>

	<programlisting>ttyu0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

	<para>The first item in the above line is the device special
	  file for this entry.  <literal>ttyu0</literal> indicates
	  that <command>getty</command> is watching
	  <devicename>/dev/ttyu0</devicename>.  The
	  <replaceable>xxx</replaceable> will replace the initial
	  <filename>gettytab</filename> capability and is the process
	  <command>init</command> will run on the device.  The third
	  item, <literal>dialup</literal>, is the default terminal
	  type.  The fourth parameter, <literal>on</literal>,
	  indicates to <command>init</command> that the line is
	  operational.  There can be a fifth parameter,
	  <literal>secure</literal>, but it should only be used for
	  terminals which are physically secure, such as the system
	  console.</para>

	<para>The default terminal type, <literal>dialup</literal> in
	  this example, may depend on local preferences.
	  <literal>dialup</literal> is the traditional default
	  terminal type on dial-up lines so that users may customize
	  their login scripts to notice when the terminal is
	  <literal>dialup</literal> and automatically adjust their
	  terminal type.  Setting <literal>vt102</literal> as the
	  default terminal type allows users to use VT102 emulation on
	  their remote systems.</para>

	<para>After editing <filename>/etc/ttys</filename>, send the
	  <command>init</command> process a <acronym>HUP</acronym>
	  signal to re-read the file:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<para>Wait until the modem is properly configured and
	  connected before signaling <command>init</command>.</para>

	<sect4>
	  <title>Locked-speed Config</title>

	  <para>For a locked-speed configuration, the
	    <filename>ttys</filename> entry needs to have a
	    fixed-speed entry provided to <command>getty</command>.
	    For a modem whose port speed is locked at 19.2&nbsp;Kbps,
	    the <filename>ttys</filename> entry might look like
	    this:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

	  <para>If the modem is locked at a different data rate,
	    substitute the appropriate value for
	    <literal>std.<replaceable>speed</replaceable></literal>
	    instead of <literal>std.19200</literal>.  Make sure to use
	    a valid type listed in
	    <filename>/etc/gettytab</filename>.</para>
	</sect4>

	<sect4>
	  <title>Matching-speed Config</title>

	  <para>In a matching-speed configuration, the
	    <filename>ttys</filename> entry needs to reference the
	    appropriate beginning <quote>auto-baud</quote> entry
	    in <filename>/etc/gettytab</filename>.  For example, for
	    the above suggested entry for a matching-speed modem that
	    starts at 19.2&nbsp;Kbps, the
	    <filename>/etc/ttys</filename> entry might look like
	    this:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty V19200"   dialup on</programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.d/serial</filename></title>

	<indexterm>
	  <primary>rc files</primary>
	  <secondary><filename>rc.serial</filename></secondary>
	</indexterm>

	<para>High-speed modems, like V.32, V.32bis, and V.34 modems,
	  need to use hardware (<literal>RTS/CTS</literal>) flow
	  control.  <command>stty</command> can be used to set the
	  hardware flow control flag in the &os; kernel for the modem
	  ports.</para>

	<para>For example, to set the <literal>termios</literal> flag
	  <varname>crtscts</varname> on
	  <devicename>COM2</devicename>'s dial-in and dial-out
	  initialization devices, the following lines could be added
	  to <filename>/etc/rc.d/serial</filename>:</para>

	<programlisting># Serial port initial configuration
stty -f /dev/ttyu1.init crtscts
stty -f /dev/cuau1.init crtscts</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Modem Settings</title>

      <para>For a modem whose parameters may be permanently set in
	non-volatile RAM, a terminal program such as
	<command>tip</command> can be used to set the parameters.
	Connect to the modem using the same communications speed as
	the initial speed <command>getty</command> will use and
	configure the modem's non-volatile RAM to match these
	requirements:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>CD</acronym> asserted when connected.</para>
	</listitem>

	<listitem>
	  <para><acronym>DTR</acronym> asserted for operation and
	    dropping DTR hangs up the line and resets the
	    modem.</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> transmitted data flow
	    control.</para>
	</listitem>

	<listitem>
	  <para>Disable <acronym>XON/XOFF</acronym> flow
	    control.</para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> received data flow
	    control.</para>
	</listitem>

	<listitem>
	  <para>Quiet mode (no result codes).</para>
	</listitem>

	<listitem>
	  <para>No command echo.</para>
	</listitem>
      </itemizedlist>

      <para>Read the documentation for the modem to find out
	which commands and/or DIP switch settings are needed.</para>

      <para>For example, to set the above parameters on a &usrobotics;
	&sportster; 14,400 external modem, give these commands to
	the modem:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Other settings can be adjusted in the modem, such as
	whether it will use V.42bis and/or MNP5 compression.</para>

      <para>The &usrobotics; &sportster; 14,400 external modem also
	has some DIP switches that need to be set.  Other modems,
	may need these settings:</para>

      <itemizedlist>
	<listitem>
	  <para>Switch 1: UP &mdash; DTR Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 2: N/A (Verbal Result Codes/Numeric Result
	    Codes)</para>
	</listitem>

	<listitem>
	  <para>Switch 3: UP &mdash; Suppress Result Codes</para>
	</listitem>

	<listitem>
	  <para>Switch 4: DOWN &mdash; No echo, offline
	    commands</para>
	</listitem>

	<listitem>
	  <para>Switch 5: UP &mdash; Auto Answer</para>
	</listitem>

	<listitem>
	  <para>Switch 6: UP &mdash; Carrier Detect Normal</para>
	</listitem>

	<listitem>
	  <para>Switch 7: UP &mdash; Load NVRAM Defaults</para>
	</listitem>

	<listitem>
	  <para>Switch 8: N/A (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>Result codes should be disabled/suppressed for dial-up
	modems to avoid problems that can occur if
	<command>getty</command> mistakenly gives a
	<prompt>login:</prompt> prompt to a modem that is in command
	mode and the modem echoes the command or returns a result
	code.  This sequence can result in an extended, silly
	conversation between <command>getty</command> and the
	modem.</para>

      <sect3>
	<title>Locked-speed Config</title>

	<para>For a locked-speed configuration, configure the modem to
	  maintain a constant modem-to-computer data rate independent
	  of the communications rate.  On a &usrobotics; &sportster;
	  14,400 external modem, these commands will lock the
	  modem-to-computer data rate at the speed used to issue the
	  commands:</para>

	<programlisting>ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>Matching-speed Config</title>

	<para>For a variable-speed configuration, configure the modem
	  to adjust its serial port data rate to match the incoming
	  call rate.  On a &usrobotics; &sportster; 14,400 external
	  modem, these commands will lock the modem's error-corrected
	  data rate to the speed used to issue the commands, while
	  allowing the serial port rate to vary for
	  non-error-corrected connections:</para>

	<programlisting>ATZ
AT&amp;B2&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>Checking the Modem's Configuration</title>

	<para>Most high-speed modems provide commands to view the
	  modem's current operating parameters in a somewhat
	  human-readable fashion.  On the &usrobotics; &sportster;
	  14,400 external modem, <command>ATI5</command> displays the
	  settings that are stored in the non-volatile RAM.  To see
	  the true operating parameters of the modem, as influenced by
	  the modem's DIP switch settings, use <command>ATZ</command>
	  and then <command>ATI4</command>.</para>

	<para>For a different brand of modem, check the modem's manual
	  to see how to double-check the modem's configuration
	  parameters.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <para>Here are a few steps for troubleshooting a dial-up modem
	on a &os; system.</para>

      <sect3>
	<title>Checking Out the &os; System</title>

	<para>Hook up the modem to the &os; system, boot the
	  system, and, if the modem has status indication lights,
	  watch to see whether the modem's <acronym>DTR</acronym>
	  indicator lights when the <prompt>login:</prompt> prompt
	  appears on the system's console.  If it lights up, that
	  should mean that &os; has started a
	  <command>getty</command> process on the appropriate
	  communications port and is waiting for the modem to accept a
	  call.</para>

	<para>If the <acronym>DTR</acronym> indicator does not light,
	  login to the &os; system through the console and type
	  <command>ps ax</command> to see if &os; is trying to run
	  a <command>getty</command> process on the correct
	  port:</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu1</screen>

	<para>If something like this is displayed instead:</para>

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyu0</screen>

	<para>and the modem has not accepted a call yet, this means
	  that <command>getty</command> has completed its open on the
	  communications port.  This could indicate a problem with the
	  cabling or a misconfigured modem, because
	  <command>getty</command> should not be able to open the
	  communications port until carrier detect has been asserted
	  by the modem.</para>

	<para>If no <command>getty</command> processes are waiting to
	  open the desired
	  <devicename>ttyu<replaceable>N</replaceable></devicename>
	  port, double-check the entries in
	  <filename>/etc/ttys</filename> to see if there are any
	  mistakes.  Also, check
	  <filename>/var/log/messages</filename> to see if there are
	  any log messages from <command>init</command> or
	  <command>getty</command>.  If there are any messages,
	  triple-check <filename>/etc/ttys</filename> and
	  <filename>/etc/gettytab</filename>, as well as the
	  appropriate device special files,
	  <filename>/dev/ttyuN</filename>, for any mistakes, missing
	  entries, or missing device special files.</para>
      </sect3>

      <sect3>
	<title>Try Dialing In</title>

	<para>Try dialing into the system.  Be sure to use 8 bits, no
	  parity, and 1 stop bit on the remote system.  If a prompt
	  does not appear right away, or the prompt shows garbage, try
	  pressing <keycap>Enter</keycap> about once per second.  If
	  there is still no <prompt>login:</prompt> prompt after a
	  while, try sending a <command>BREAK</command>. When using a
	  high-speed modem, try dialing again after locking the
	  dialing modem's interface speed.</para>

	<para>If there is still no <prompt>login:</prompt>
	  prompt, check <filename>/etc/gettytab</filename> again and
	  double-check that:</para>

	<itemizedlist>
	  <listitem>
	    <para>The initial capability name specified in the entry
	      in <filename>/etc/ttys</filename> matches the name of
	      a capability in
	      <filename>/etc/gettytab</filename>.</para>
	  </listitem>

	  <listitem>
	    <para>Each <literal>nx=</literal> entry matches another
	      <filename>gettytab</filename> capability name.</para>
	  </listitem>

	  <listitem>
	    <para>Each <literal>tc=</literal> entry matches another
	      <filename>gettytab</filename> capability name.</para>
	  </listitem>
	</itemizedlist>

	<para>If the modem on the &os; system will not answer, make
	  sure that the modem is configured to answer the phone when
	  <acronym>DTR</acronym> is asserted.  If the modem seems to
	  be configured correctly, verify that the
	  <acronym>DTR</acronym> line is asserted by checking the
	  modem's indicator lights.</para>

	<para>If it still does not work, take a break and come back to
	  it later.  If it still does not work, try sending an
	  email message to the &a.questions; describing the modem
	  and the problem.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="dialout">
    <title>Dial-out Service</title>

    <indexterm><primary>dial-out service</primary></indexterm>

    <para>The following are tips for getting the host to connect over
      the modem to another computer.  This is appropriate for
      establishing a terminal session with a remote host.</para>

    <para>This kind of connection can be helpful to get a file on the
      Internet if there are problems using PPP.  If PPP is not
      working, use the terminal session to FTP the needed file.  Then
      use zmodem to transfer it to the machine.</para>

    <sect2 id="hayes-unsupported">
      <title>Using a Stock Hayes Modem</title>

      <para>A generic Hayes dialer is built into
	<command>tip</command>.  Use <literal>at=hayes</literal> in
	<filename>/etc/remote</filename>.</para>

      <para>The Hayes driver is not smart enough to recognize some of
	the advanced features of newer modems messages like
	<literal>BUSY</literal>, <literal>NO DIALTONE</literal>, or
	<literal>CONNECT 115200</literal>.  Turn those messages off
	when using <command>tip</command> with
	<command>ATX0&amp;W</command>.</para>

      <para>The dial timeout for <command>tip</command> is 60
	seconds.  The modem should use something less, or else
	<command>tip</command> will think there is a communication
	problem.  Try <command>ATS7=45&amp;W</command>.</para>
    </sect2>

    <sect2 id="direct-at">
      <title>Using <literal>AT</literal> Commands</title>

      <indexterm>
	<primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>Create a <quote>direct</quote> entry in
	<filename>/etc/remote</filename>.  For example, if the
	modem is hooked up to the first serial port,
	<filename>/dev/cuau0</filename>, use the following
	line:</para>

      <programlisting>cuau0:dv=/dev/cuau0:br#19200:pa=none</programlisting>

      <para>Use the highest <acronym>bps</acronym> rate the modem
	supports in the <literal>br</literal> capability.  Then, type
	<command>tip cuau0</command> to connect to the modem.</para>

      <para>Or, use <command>cu</command> as <username>root</username>
	with the following command:</para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable> is the serial port, such
	as <filename>/dev/cuau0</filename>, and
	<replaceable>speed</replaceable> is the speed, such as
	<literal>57600</literal>.  When finished entering the AT
	commands, type <command>~.</command> to exit.</para>
    </sect2>

    <sect2 id="gt-failure">
      <title>The <literal>@</literal> Sign Does Not Work</title>

      <para>The <literal>@</literal> sign in the phone number
	capability tells <command>tip</command> to look in
	<filename>/etc/phones</filename> for a phone number.  But, the
	<literal>@</literal> sign is also a special character in
	capability files like <filename>/etc/remote</filename>, so it
	needs to be escaped with a backslash:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2 id="dial-command-line">
      <title>Dialing from the Command Line</title>

      <para>Put a <quote>generic</quote> entry in
	<filename>/etc/remote</filename>.  For example:</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>This should now work:</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>Users who prefer <command>cu</command> over
	<command>tip</command>, can use a generic
	<literal>cu</literal> entry:</para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>and type:</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2 id="set-bps">
      <title>Setting the <acronym>bps</acronym> Rate</title>

      <para>Put in an entry for <literal>tip1200</literal> or
	<literal>cu1200</literal>, but go ahead and use whatever
	<acronym>bps</acronym> rate is appropriate with the
	<literal>br</literal> capability.
	<command>tip</command> thinks a good default is 1200&nbsp;bps
	which is why it looks for a <literal>tip1200</literal> entry.
	1200&nbsp;bps does not have to be used, though.</para>
    </sect2>

    <sect2 id="terminal-server">
      <title>Accessing a Number of Hosts Through a Terminal
	Server</title>

      <para>Rather than waiting until connected and typing
	<command>CONNECT <replaceable>host</replaceable></command>
	each time, use <command>tip</command>'s <literal>cm</literal>
	capability.  For example, these entries in
	<filename>/etc/remote</filename> will let you type
	<command>tip pain</command> or
	<command>tip muffin</command> to connect to the hosts
	<hostid>pain</hostid> or <hostid>muffin</hostid>, and
	<command>tip deep13</command> to connect to the terminal
	server.</para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

    </sect2>

    <sect2 id="tip-multiline">
      <title>Using More Than One Line with
	<command>tip</command></title>

      <para>This is often a problem where a university has several
	modem lines and several thousand students trying to use
	them.</para>

      <para>Make an entry in <filename>/etc/remote</filename> and use
	<literal>@</literal> for the <literal>pn</literal>
	capability:</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>Then, list the phone numbers in
	<filename>/etc/phones</filename>:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> will try each number in the listed
	order, then give up.  To keep retrying, run
	<command>tip</command> in a <literal>while</literal>
	loop.</para>
    </sect2>

    <sect2 id="multi-controlp">
      <title>Using the Force Character</title>

      <para><keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>P</keycap>
	</keycombo> is the default <quote>force</quote> character,
	used to tell <command>tip</command> that the next character is
	literal data.  The force character can be set to any other
	character with the <command>~s</command> escape, which means
	<quote>set a variable.</quote></para>

      <para>Type
	<command>~sforce=<replaceable>single-char</replaceable></command>
	followed by a newline.  <replaceable>single-char</replaceable>
	is any single character.  If
	<replaceable>single-char</replaceable> is left out, then the
	force character is the null character, which is accessed by
	typing
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	or <keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>Space</keycap>
	</keycombo>.  A pretty good value for
	<replaceable>single-char</replaceable> is
	<keycombo action="simul">
	  <keycap>Shift</keycap>
	  <keycap>Ctrl</keycap>
	  <keycap>6</keycap>
	</keycombo>, which is only used on some terminal
	servers.</para>

      <para>To change the force character, specify the following in
	<filename>~/.tiprc</filename>:</para>

      <programlisting>force=<replaceable>single-char</replaceable></programlisting>
    </sect2>

    <sect2 id="uppercase">
      <title>Upper Case Characters</title>

      <para>This happens when
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo> is pressed, which is <command>tip</command>'s
	<quote>raise character</quote>, specially designed for people
	with broken caps-lock keys.  Use <command>~s</command> to set
	<literal>raisechar</literal> to something reasonable.  It can
	be set to be the same as the force character, if neither
	feature is used.</para>

      <para>Here is a sample <filename>~/.tiprc</filename> for
	<application>Emacs</application> users who need to type
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>2</keycap>
	</keycombo> and <keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo>:</para>

    <programlisting>force=^^
raisechar=^^</programlisting>

      <para>The <literal>^^</literal> is
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	  </keycombo>.</para>

    </sect2>

    <sect2 id="tip-filetransfer">
      <title>File Transfers with <command>tip</command></title>

      <para>When talking to another &unix;-like operating system,
	files can be sent and received using <command>~p</command>
	(put) and <command>~t</command> (take).  These commands run
	<command>cat</command> and <command>echo</command> on the
	remote system to accept and send files.  The syntax is:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">local-file</arg>
	<arg choice="opt">remote-file</arg>
      </cmdsynopsis>

      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">remote-file</arg>
	<arg choice="opt">local-file</arg>
      </cmdsynopsis>

      <para>There is no error checking, so another protocol, like
	zmodem, should probably be used.</para>
    </sect2>

    <sect2 id="zmodem-tip">
      <title>Using <application>zmodem</application> with
	<command>tip</command>?</title>

      <para>To receive files, start the sending program on the remote
	end.  Then, type <command>~C rz</command> to begin receiving
	them locally.</para>

      <para>To send files, start the receiving program on the remote
	end.  Then, type <command>~C sz
	<replaceable>files</replaceable></command> to send them to the
	remote system.</para>
    </sect2>
  </sect1>

  <sect1 id="serialconsole-setup">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Kazutaka</firstname>
	  <surname>YOKOTA</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Paul</surname>
	  <contrib>Based on a document by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Setting Up the Serial Console</title>

    <indexterm><primary>serial console</primary></indexterm>

    <sect2 id="serialconsole-intro">
      <title>Introduction</title>

      <para>&os; has the ability to boot a system with a dumb
	terminal on a serial port as a console.  This configuration is
	useful for system administrators who wish to install &os; on
	machines that have no keyboard or monitor attached, and
	developers who want to debug the kernel or device
	drivers.</para>

      <para>As described in <xref linkend="boot"/>, &os; employs
	a three stage bootstrap.  The first two stages are in the boot
	block code which is stored at the beginning of the &os;
	slice on the boot disk.  The boot block then loads and runs
	the boot loader as the third stage code.</para>

      <para>In order to set up booting from a serial console, the
	boot block code, the boot loader code, and the kernel need to
	be configured.</para>

    </sect2>

    <sect2 id="serialconsole-howto-fast">
      <title>Quick Serial Console Configuration</title>

      <para>This section assumes the default setup and provides a fast
	overview of setting up the serial console.</para>

      <procedure>

	<step>
	  <para>Connect the serial cable to
	    <devicename>COM1</devicename> and the controlling
	    terminal.</para>
	</step>

	<step>
	  <para>To see all the boot messages on the serial console,
	    issue the following command as the superuser:</para>

	  <screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>
	</step>

	<step>
	  <para>Edit <filename>/etc/ttys</filename> and change
	    <literal>off</literal> to <literal>on</literal> and
	    <literal>dialup</literal> to <literal>vt100</literal> for
	    the <devicename>ttyu0</devicename> entry.  Otherwise, a
	    password will not be required to connect via the serial
	    console, resulting in a potential security hole.</para>
	</step>

	<step>
	  <para>Reboot the system to see if the changes took
	    effect.</para>
	</step>

      </procedure>

      <para>If a different configuration is required, see the next
	section for a more in-depth configuration explanation.</para>
    </sect2>

    <sect2 id="serialconsole-howto">
      <title>In-Depth Serial Console Configuration</title>

      <procedure>
	<step>
	  <para>Prepare a serial cable.</para>

	  <indexterm><primary>null-modem cable</primary></indexterm>

	  <para>Use either a null-modem cable or a standard serial
	    cable and a null-modem adapter.  See <xref
	      linkend="serial-cables-ports"/> for a discussion
	    on serial cables.</para>
	</step>

	<step>
	  <para>Unplug the keyboard.</para>

	  <para>Many PC systems probe for the keyboard during the
	    Power-On Self-Test (<acronym>POST</acronym>) and will
	    generate an error if the keyboard is not detected.  Some
	    machines will refuse to boot until the keyboard is plugged
	    in.</para>

	  <para>If the computer complains about the error, but boots
	    anyway, no further configuration is needed.</para>

	  <para>If the computer refuses to boot without a keyboard
	    attached, the BIOS needs to be configured so that it
	    ignores this error (if it can).  Consult the motherboard's
	    manual for details on how to do this.</para>

	  <tip>
	    <para>Try setting the keyboard to <quote>Not
		installed</quote> in the BIOS.  The keyboard can still
	      be used as this setting just tells the BIOS not to probe
	      for a keyboard at power-on.  The BIOS should not
	      complain if the keyboard is absent.  You can leave the
	      keyboard plugged in even with this flag set to
	      <quote>Not installed</quote> and the keyboard will still
	      work.  If the above option is not present in the BIOS,
	      look for an <quote>Halt on Error</quote> option instead.
	      Setting this to <quote>All but Keyboard</quote> or even
	      to <quote>No Errors</quote>, will have the same
	      effect.</para>
	  </tip>

	  <note>
	    <para>If the system has a &ps2; mouse, chances are good
	      that both the mouse and keyboard need to be unplugged.
	      This is because &ps2; mice share some hardware with the
	      keyboard and leaving the mouse plugged in can fool the
	      keyboard probe into thinking the keyboard is still
	      there.</para>
	  </note>
	</step>

	<step>
	  <para>Plug a dumb terminal into
	    <devicename>COM1</devicename>
	    (<devicename>sio0</devicename>).</para>

	  <para>If a dumb terminal is not available, use an old
	    computer with a modem program, or the serial port on
	    another &unix; box.  If there is no
	    <devicename>COM1</devicename>
	    (<devicename>sio0</devicename>), get one.  At this time,
	    there is no way to select a port other than
	    <devicename>COM1</devicename> for the boot blocks without
	    recompiling the boot blocks.  If
	    <devicename>COM1</devicename> is being used by another
	    device, temporarily remove that device and install a new
	    boot block and kernel once &os; is up and running.</para>
	</step>

	<step>
	  <para>Make sure the configuration file of the custom kernel
	    has appropriate flags set for
	    <devicename>COM1</devicename>
	    (<devicename>sio0</devicename>).</para>

	  <para>Relevant flags are:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>0x10</literal></term>

	      <listitem>
		<para>Enables console support for this unit.  The
		  other console flags are ignored unless this is set.
		  Currently, at most one unit can have console
		  support.  The first one, in config file order, with
		  this flag set is preferred.  This option alone will
		  not make the serial port the console.  Set the
		  following flag or use <option>-h</option> as
		  described below, together with this flag.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x20</literal></term>

	      <listitem>
		<para>Forces this unit to be the console, unless there
		  is another higher priority console, regardless of
		  <option>-h</option> as discussed below.  The flag
		  <literal>0x20</literal> must be used together with
		  the <option>0x10</option> flag.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x40</literal></term>

	      <listitem>
		<para>Reserves this unit (in conjunction with
		  <literal>0x10</literal>) and makes the unit
		  unavailable for normal access.  This flag should
		  not be set to the serial port to use as the serial
		  console.  The only use of this flag is to designate
		  the unit for kernel remote debugging.  See <ulink
		    url="&url.books.developers-handbook;/index.html">The
		  Developer's Handbook</ulink> for more information on
		  remote debugging.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Here is an example setting:</para>

	  <programlisting>device sio0 flags 0x10</programlisting>

	  <para>Refer to &man.sio.4; for more details.</para>

	  <para>If the flags were not set, run UserConfig on a
	    different console or recompile the kernel.</para>
	</step>

	<step>
	  <para>Create <filename>boot.config</filename> in the root
	    directory of the <literal>a</literal> partition on the
	    boot drive.</para>

	  <para>This file instructs the boot block code how to boot
	    the system.  In order to activate the serial console,
	    one or more of the following options are needed.  When
	    using multiple options, include them all on the same
	    line:</para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
		<para>Toggles between the internal and serial
		  consoles.  Use this to switch console devices.  For
		  instance, to boot from the internal (video) console,
		  use <option>-h</option> to direct the boot loader
		  and the kernel to use the serial port as its console
		  device.  Alternatively, to boot from the serial
		  port, use <option>-h</option> to tell the boot
		  loader and the kernel to use the video display as
		  the console instead.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
		<para>Toggles between the single and dual console
		  configurations.  In the single configuration, the
		  console will be either the internal console (video
		  display) or the serial port, depending on the state
		  of <option>-h</option>.  In the dual console
		  configuration, both the video display  and the
		  serial port will become the console at the same
		  time, regardless of the state of
		  <option>-h</option>.  However, the dual console
		  configuration takes effect only while the boot
		  block is running.  Once the boot loader gets
		  control, the console specified by
		  <option>-h</option> becomes the only
		  console.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
		<para>Makes the boot block probe the keyboard.  If no
		  keyboard is found, the <option>-D</option> and
		  <option>-h</option> options are automatically
		  set.</para>

		<note>
		  <para>Due to space constraints in the current
		    version of the boot blocks,
		    <option>-P</option> is capable of detecting
		    extended keyboards only.  Keyboards with less
		    than 101 keys and without F11 and F12 keys may
		    not be detected.  Keyboards on some laptops
		    may not be properly found because of this
		    limitation.  If this is the case, do not use
		    <option>-P</option>.  Unfortunately there is no
		    workaround for this problem.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Use either <option>-P</option> to select the
	    console automatically, or <option>-h</option> to
	    activate the serial console.</para>

	  <para>Other options are described in &man.boot.8;.</para>

	  <para>The options, except for <option>-P</option>, are
	    passed to the boot loader.  The boot loader will
	    determine whether the internal video or the serial port
	    should become the console by examining the state of
	    <option>-h</option>.  This means that if
	    <option>-D</option> is specified but
	    <option>-h</option> is not specified in
	    <filename>/boot.config</filename>, the serial port can
	    be used as the console only during the boot block as the
	    boot loader will use the internal video display as the
	    console.</para>
	</step>

	<step>
	  <para>Boot the machine.</para>

	  <para>When &os; starts, the boot blocks echo the contents of
	    <filename>/boot.config</filename> to the console.  For
	    example:</para>

	  <screen>/boot.config: -P
Keyboard: no</screen>

	  <para>The second line appears only if <option>-P</option> is
	    in <filename>/boot.config</filename> and indicates the
	    presence or absence of the keyboard.  These messages go
	    to either the serial or internal console, or both,
	    depending on the option in
	    <filename>/boot.config</filename>.</para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry align="left">Options</entry>
		  <entry align="left">Message goes to</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>none</entry>
		  <entry>internal console</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>serial console</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>serial and internal consoles</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>serial and internal consoles</entry>
		</row>

		<row>
		  <entry><option>-P</option>, keyboard present</entry>
		  <entry>internal console</entry>
		</row>

		<row>
		  <entry><option>-P</option>, keyboard absent</entry>
		  <entry>serial console</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>After the message, there will be a small pause before
	    the boot blocks continue loading the boot loader and
	    before any further messages are printed to the console.
	    Under normal circumstances, there is no need to interrupt
	    the boot blocks, but one can do so in order to make sure
	    things are set up correctly.</para>

	  <para>Press any key, other than <keycap>Enter</keycap>, at
	    the console to interrupt the boot process.  The boot
	    blocks will then prompt for further action:</para>

	  <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

	  <para>Verify that the above message appears on either the
	    serial or internal console, or both, according to the
	    options in <filename>/boot.config</filename>.  If the
	    message appears in the correct console, press
	    <keycap>Enter</keycap> to continue the boot
	    process.</para>

	  <para>If there is no prompt on the serial terminal,
	    something is wrong with the settings.  Enter
	    <option>-h</option> then <keycap>Enter</keycap> or
	    <keycap>Return</keycap> to tell the boot block (and then
	    the boot loader and the kernel) to choose the serial port
	    for the console.  Once the system is up, go back and check
	    what went wrong.</para>
	</step>
      </procedure>

      <para>During the third stage of the boot process, one can still
	switch between the internal console and the serial console by
	setting appropriate environment variables in the boot loader.
	See <xref linkend="serialconsole-loader"/> for more
	information.</para>
    </sect2>

    <sect2 id="serialconsole-summary">
      <title>Summary</title>

      <para>Here is the summary of the various settings discussed in
	this section:</para>

      <sect3>
	<title>Case 1: Set the Flags to 0x10 for
	  <devicename>sio0</devicename></title>

	<programlisting>device sio0 flags 0x10</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Options in /boot.config</entry>
		<entry align="left">Console during boot blocks</entry>
		<entry align="left">Console during boot loader</entry>
		<entry align="left">Console in kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>nothing</entry>
		<entry>internal</entry>
		<entry>internal</entry>
		<entry>internal</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serial</entry>
		<entry>serial</entry>
		<entry>serial</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serial and internal</entry>
		<entry>internal</entry>
		<entry>internal</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serial and internal</entry>
		<entry>serial</entry>
		<entry>serial</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, keyboard present</entry>
		<entry>internal</entry>
		<entry>internal</entry>
		<entry>internal</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, keyboard absent</entry>
		<entry>serial and internal</entry>
		<entry>serial</entry>
		<entry>serial</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>Case 2: Set the Flags to 0x30 for
	  <devicename>sio0</devicename></title>

	<programlisting>device sio0 flags 0x30</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Options in /boot.config</entry>
		<entry align="left">Console during boot blocks</entry>
		<entry align="left">Console during boot loader</entry>
		<entry align="left">Console in kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>nothing</entry>
		<entry>internal</entry>
		<entry>internal</entry>
		<entry>serial</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serial</entry>
		<entry>serial</entry>
		<entry>serial</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serial and internal</entry>
		<entry>internal</entry>
		<entry>serial</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serial and internal</entry>
		<entry>serial</entry>
		<entry>serial</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, keyboard present</entry>
		<entry>internal</entry>
		<entry>internal</entry>
		<entry>serial</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, keyboard absent</entry>
		<entry>serial and internal</entry>
		<entry>serial</entry>
		<entry>serial</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-tips">
      <title>Tips for the Serial Console</title>

      <sect3>
	<title>Setting a Faster Serial Port Speed</title>

	<para>By default, the serial port settings are 9600 baud, 8
	  bits, no parity, and 1 stop bit.  To change the default
	  console speed, the following options are available:</para>

	<itemizedlist>
	  <listitem>
	    <para>Recompile the boot blocks with
	      <makevar>BOOT_COMCONSOLE_SPEED</makevar> set to the
	      new console speed.  See <xref
		linkend="serialconsole-com2"/> for detailed
	      instructions about building and installing new boot
	      blocks.</para>

	    <para>If the serial console is configured in some other
	      way than by booting with <option>-h</option>, or if the
	      serial console used by the kernel is different from the
	      one used by the boot blocks, add the following option
	      to a custom kernel configuration file and compile a
	      new kernel:</para>

	    <programlisting>options CONSPEED=19200</programlisting>
	  </listitem>

	  <listitem>
	    <para>Add the <option>-S</option> boot option to
	      <filename>/boot.config</filename>.  See &man.boot.8; for
	      a description of how to add options to
	      <filename>/boot.config</filename> and a list of the
	      supported options.</para>
	  </listitem>

	  <listitem>
	    <para>Enable <varname>comconsole_speed</varname> in
	      <filename>/boot/loader.conf</filename>.  This option
	      depends on <varname>console</varname>,
	      <varname>boot_serial</varname>, and
	      <varname>boot_multicons</varname> being set in
	      <filename>/boot/loader.conf</filename> too.  An example
	      of using <varname>comconsole_speed</varname> to change
	      the serial console speed is:</para>

	    <programlisting>boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"</programlisting>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3 id="serialconsole-com2">
	<title>Using a Serial Port Other Than
	  <devicename>sio0</devicename> for the Console</title>

	<para>Using a port other than <devicename>sio0</devicename> as
	  the console requires the boot blocks, the boot loader, and
	  the kernel to be recompiled as follows.</para>

	<procedure>
	  <step>
	    <para>Get the kernel source as described in <xref
		linkend="updating-upgrading"/>.</para>
	  </step>

	  <step>
	    <para>Edit <filename>/etc/make.conf</filename> and set
	      <literal>BOOT_COMCONSOLE_PORT</literal> to the address
	      of the port to use: 0x3F8, 0x2F8, 0x3E8 or 0x2E8.  Only
	      <devicename>sio0</devicename> through
	      <devicename>sio3</devicename>
	      (<devicename>COM1</devicename> through
	      <devicename>COM4</devicename>) can be used as multiport
	      serial cards will not work.  No interrupt setting is
	      needed.</para>
	  </step>

	  <step>
	    <para>Create a custom kernel configuration file and add
	      appropriate flags for the serial port to use.  For
	      example, to make <devicename>sio1</devicename>
	      (<devicename>COM2</devicename>) the console:</para>

	    <programlisting>device sio1 flags 0x10</programlisting>

	    <para>or</para>

	    <programlisting>device sio1 flags 0x30</programlisting>

	    <para>The console flags for the other serial ports should
	      not be set.</para>
	  </step>

	  <step>
	    <para>Recompile and install the boot blocks and the boot
	      loader:</para>

	    <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </step>

	  <step>
	    <para>Rebuild and install the kernel.</para>
	  </step>

	  <step>
	    <para>Write the boot blocks to the boot disk with
	      &man.bsdlabel.8; and boot from the new kernel.</para>
	  </step>
	</procedure>
      </sect3>

      <sect3 id="serialconsole-ddb">
	<title>Entering the DDB Debugger from the Serial Line</title>

	<para>To drop into the kernel debugger from the serial
	  console, compile a custom kernel with the following options.
	  Note that while this is useful for remote diagnostics, it is
	  also dangerous if a spurious BREAK is generated on the
	  serial port.</para>

	<programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>

      <sect3>
	<title>Getting a Login Prompt on the Serial Console</title>

	<para>While this is not required, it is possible to get a
	  <emphasis>login</emphasis> prompt over the serial line.
	  First, make sure that the boot messages are displayed and it
	  is possible to enter the kernel debugging session through
	  the serial console.</para>

	<para>Open <filename>/etc/ttys</filename> with a text editor
	  and locate the lines:</para>

	<programlisting>ttyu0 "/usr/libexec/getty std.9600" unknown off secure
ttyu1 "/usr/libexec/getty std.9600" unknown off secure
ttyu2 "/usr/libexec/getty std.9600" unknown off secure
ttyu3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>

	<para><devicename>ttyu0</devicename> through
	  <devicename>ttyu3</devicename> correspond to
	  <devicename>COM1</devicename> through
	  <devicename>COM4</devicename>.  Change
	  <literal>off</literal> to <literal>on</literal> for the
	  desired port.  If the speed of the serial port has been
	  changed, change <literal>std.9600</literal> to match the
	  new setting.</para>

	<para>The terminal type can also be changed from
	  <literal>unknown</literal> to the actual type of the serial
	  terminal.</para>

	<para>After editing the file, type <command>kill -HUP
	    1</command> to make this change take effect.</para>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-loader">
      <title>Changing Console from the Boot Loader</title>

      <para>Previous sections described how to set up the serial
	console by tweaking the boot block.  This section shows how to
	specify the console by entering some commands and
	environment variables in the boot loader.  As the boot loader
	is invoked at the third stage of the boot process, the
	settings in the boot loader will override the settings in the
	boot block.</para>

      <sect3>
	<title>Setting Up the Serial Console</title>

	<para>The boot loader and the kernel to use the serial console
	  can be specified by writing one line in
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>console="comconsole"</programlisting>

	<para>This will take effect regardless of the settings in the
	  boot block discussed in the previous section.</para>

	<para>This line should be the first line of
	  <filename>/boot/loader.conf</filename> so as to see boot
	  messages on the serial console as early as possible.</para>

	<para>Likewise, to specify the internal console:</para>

	<programlisting>console="vidconsole"</programlisting>

	<para>If the boot loader environment variable
	  <envar>console</envar> is not set, the boot loader, and
	  subsequently the kernel, will use whichever console is
	  indicated by <option>-h</option> in the  boot block.</para>

	<para>The console can be specified in
	  <filename>/boot/loader.conf.local</filename> or in
	  <filename>/boot/loader.conf</filename>.</para>

	<para>See &man.loader.conf.5; for more information.</para>

	<note>
	  <para>At the moment, the boot loader has no option
	    equivalent to <option>-P</option> in the boot block, and
	    there is no provision to automatically select the internal
	    console and the serial console based on the presence of
	    the keyboard.</para>
	</note>
      </sect3>

      <sect3>
	<title>Using a Serial Port Other Than
	  <devicename>sio0</devicename> for the Console</title>

	<para>The boot loader needs to be compiled in order to use a
	  serial port other than <devicename>sio0</devicename> for the
	  serial console.  Follow the procedure described in <xref
	    linkend="serialconsole-com2"/>.</para>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-caveats">
      <title>Caveats</title>

      <para>While most systems will boot without a keyboard, quite a
	few will not boot without a graphics adapter.  Machines with
	AMI BIOSes can be configured to  boot with no graphics adapter
	installed by changing the <quote>graphics adapter</quote>
	setting in the CMOS configuration to <quote>Not
	  installed.</quote></para>

      <para>However, many machines do not support this option and will
	refuse to boot if there is no display hardware in the system.
	With these machines, leave some kind of graphics card plugged
	in, even if it is just a junky mono board.  A monitor does not
	need to be attached.  One might also try installing an AMI
	BIOS.</para>
    </sect2>
  </sect1>
</chapter>
