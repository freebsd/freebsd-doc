<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO_8859-1/books/handbook/basics/chapter.sgml,v 1.17 2000/04/10 19:17:16 jim Exp $
-->

<chapter id="basics">
  <title>Unix Basics</title>
  
  <sect1>
    <title>Synopsis</title>

    <para><emphasis>Rewritten by Chris Shumway
      <email>cshumway@cdrom.com</email>, 10 Mar 2000.</emphasis></para>

   <para>The following chapter will cover the basic commands and
     functionality of the FreeBSD operating system.  If you are new to
     FreeBSD, you will definitely want to read through this chapter before
     asking for help.</para>
  </sect1>

  <sect1 id="permissions">
    <title>Permissions</title>

    <para>FreeBSD, having its history rooted in BSD UNIX, has its
      fundamentals based on several key UNIX concepts.  The first, and
      most pronounced, is that FreeBSD is a multi-user operating system.
      The system can handle several users all working simultaneously on
      completely unrelated tasks.  The system is responsible for properly
      sharing and managing requests for hardware devices, peripherals,
      memory, and CPU time evenly to each user.</para>

    <para>Because the system is capable of supporting multiple users,
      everything the system manages has a set of permissions governing who
      can read, write, and execute the resource.  These permissions are
      stored as an octet broken into three pieces, one for the owner of
      the file, one for the group that the file belongs to, and one for
      everyone else.  This numerical representation works like
      this:</para>

    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Value</entry>
	    <entry>Permission</entry>
	    <entry>Directory Listing</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>No read, no write, no execute</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>No read, no write, execute</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>No read, write, no execute</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>No read, write, execute</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Read, no write, no execute</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Read, no write, execute</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Read, write, no execute</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Read, write, execute</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>For the long directory listing by <command>ls -l</command>, a
      column will show a file's permissions for the owner, group, and
      everyone else.  Here's how it is broken up:</para>

    <screen>-rw-r--r--</screen>

    <para>The first character, from left to right, is a special character
      that tells if this is a regular file, a directory, a special
      character or block device, a socket, or any other special
      pseudo-file device.  The  next three characters, designated as
      <literal>rw-</literal> gives the permissions for the owner of the
      file.  The next three characters, <literal>r--</literal> gives the
      permissions for the group that the file belongs to.  The final three
      characters, <literal>r--</literal>, gives the permissions for the
      rest of the world.  A dash means that the permission is turned off.
      In the case of this file, the permissions are set so the owner can
      read and write to the file, the group can read the file, and the
      rest of the world can only read the file.  According to the table
      above, the permissions for this file would be
      <literal>644</literal>, where each digit represents the three parts
      of the file's permission.</para>

    <para>This is all well and good, but how does the system control
      permissions on devices? FreeBSD actually treats most hardware
      devices as a file that programs can open, read, and write data to
      just like any other file.  These special device files are stored on
      the <filename>/dev</filename> directory.</para>

    <para>Directories are also treated as files.  They have read, write,
      and execute permissions.  The executable bit for a directory has a
      slightly different meaning than that of files.  When a directory is
      marked executable, it means it can be searched into, for example,  a
      directory listing can be done in that directory.</para>

    <para>There are more to permissions, but they are primarily used in
      special circumstances such as setuid binaries and sticky
      directories.  If you want more information on file permissions and
      how to set them, be sure to look at the &man.chmod.1; man
      page.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Directory Structures</title>

    <para>Since FreeBSD uses its file systems to determine many
      fundamental system operations, the hierarchy of the file system is
      extremely important.  Due to the fact that the &man.hier.7; man page
      provides a complete description of the directory structure, it will
      not be duplicated here.  Please read &man.hier.7; for more
      information.</para>
      
    <para>Of significant importance is the root of all directories, the /
      directory.  This directory is the first directory mounted at boot
      time and it contains the base system necessary at boot time.  The
      root directory also contains mount points for every other file
      system that you want to mount.</para>

    <para>A mount point is a directory where additional file systems can
      be grafted onto the root file system.  Standard mount points include
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/mnt</filename>, and <filename>/cdrom</filename>.  These
      directories are usually referenced to entries in the file
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename> is
      a table of various file systems and mount points for reference by the
      system.  Most of the file systems in <filename>/etc/fstab</filename>
      are mounted automatically at boot time from the script &man.rc.8;
      unless they contain the <option>noauto</option> option.  Consult the
      &man.fstab.5; manual page for more information on the format of the
      <filename>/etc/fstab</filename> file and the options it
      contains.</para>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>

    <para>In FreeBSD, a lot of everyday work is done in a command line
      interface called a shell.  A shell's main job is to take commands
      from the input channel and execute them.  A lot of shells also have
      built in functions to help everyday tasks such a file management,
      file globing, command line editing, command mar-cos, and environment
      variables.  FreeBSD comes with a set of shells, such as sh, the
      Bourne Shell, and csh, the C-shell.  Many other shells are available
      from the FreeBSD Ports Collection that have much more power, such as
      tcsh and bash.</para>

    <para>Which shell do you use?  It is really a matter of taste.  If you
      are a C programmer you might feel more comfortable with a C-like shell
      such as tcsh.  If you've come from Linux or are new to a UNIX
      command line interface you might try bash.  The point is that each
      shell has unique properties that may or may not work with your
      preferred working environment, and that you have a choice of what
      shell to use.</para>

    <para>One common feature in a shell is file-name completion.  Given
      the typing of the first few letters of a command or filename, you
      can usually have the shell automatically complete the rest of the
      command or filename by hitting the TAB key on the keyboard.  Here is
      an example.  I have two files called <filename>foobar</filename> and
      <filename>foo.bar</filename>.  I want to delete
      <filename>foo.bar</filename>.  So what I would type on the keyboard
      is:  <command>rm fo[TAB].[TAB]</command>.</para>

    <para>The shell would print out <command>rm
      foo[BEEP].bar</command>.</para>

    <para>The [BEEP] is the console bell, which is the shell telling me it
      was unable to totally complete the filename because there is more
      than one match.  Both <filename>foobar</filename> and
      <filename>foo.bar</filename> start with <literal>fo</literal>, but
      it was able to complete to <literal>foo</literal>.  Once I typed in
      <literal>.</literal>, then hit TAB again, the shell was able to fill
      in the rest of the filename for me.</para>

    <para>Another function of the shell is environment variables.
      Environment variables are a variable key pair stored in the shell's
      environment space.  This space can be read by any program invoked by
      the shell, and thus contains a lot of program configuration.  Here
      is a list of common environment variables and what they mean:</para>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Description</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Current logged in user's name.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Colon separated list of directories to search for
	      binaries.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Network name of the X11 display to connect to, if
	      available.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>The current shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>The name of the user's terminal.  Used to determine the
	      capabilities of the terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Database entry of the terminal escape codes to perform
	      various terminal functions.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Type of operating system.  E.g., FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>The CPU architecture that the system is running
	      on.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>The user's preferred text editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>The user's preferred text pager.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Colon separated list of directories to search for
	      manual pages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>To view or set an environment variable differs somewhat from
      shell to shell.  For example, in the C-Style shells such as tcsh
      and csh, you would use <command>setenv</command> to set and view
      environment variables.  Under Bourne shells such as sh and bash, you
      would use <command>set</command> and <command>export</command> to
      view and set your current environment variables.  For example, to
      set or modify the <envar>EDITOR</envar> environment variable, under
      csh or tcsh a command like this would set <envar>EDITOR</envar> to
      <filename>/usr/local/bin/emacs</filename>:</para>

    <para><command>setenv EDITOR /usr/local/bin/emacs</command></para>

    <para>Under Bourne shells:</para>

    <para><command>export EDITOR="/usr/local/bin/emacs"</command></para>

    <para>You can also make most shells expand the environment variable by
      placing a <literal>$</literal> character in front of it on the
      command line.  For example, <command>echo $TERM</command> would
      print out whatever <envar>$TERM</envar> is set to, because the shell
      expands <envar>$TERM</envar> and passes it on to echo.</para>

    <para>Shells treat a lot of special characters, called meta-characters
      as special representations of data.  The most common one is the
      <literal>*</literal> character, which represents any number of
      characters in a filename.  These special meta-characters can be used
      to do file name globing.  For example, typing in
      <command>echo *</command> is almost the same as typing in
      <command>ls</command> because the shell takes all the files that
      match <command>*</command> and puts them on the command line for
      echo to see.</para>

    <para>To prevent the shell from interpreting these special characters,
      they can be escaped from the shell by putting a backslash
      (<literal>\</literal>) character in front of them.  <command>echo
      $TERM</command> prints whatever your terminal is set to.
      <command>echo \$TERM</command> prints <envar>$TERM</envar> as
      is.</para>

    <sect2 id="changing-shells">
      <title>Changing your shell</title>

      <para>The easiest way to change your shell is to use the
	<command>chsh</command> command.  Running <command>chsh</command> will
	place you into the editor that is in your <envar>EDITOR</envar>
	environment variable; if it is not set, you will be placed in
	<command>vi</command>.  Change the &ldquo;Shell:&rdquo; line
	accordingly.</para>

      <para>You can also give <command>chsh</command> the
	<option>-s</option> option; this will set your shell for you,
	without requiring you to enter an editor.  
	For example, if you wanted to
	change your shell to bash, the following should do the
	trick:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Running <command>chsh</command> with no parameters and editing
	the shell from there would work also.</para>

      <note>
	<para>The shell that you wish to use <emphasis>must</emphasis> be
	  present in the <filename>/etc/shells</filename> file.  If you
	  have installed a shell from the <link linkend="ports">ports
	  collection</link>, then this should have been done for you
	  already.  If you installed the shell by hand, you must do
	  this.</para>
     
      <para>For example, if you installed <command>bash</command> by hand
	and placed it into <filename>/usr/local/bin</filename>, you would
	want to:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Then rerun <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text Editors</title>

    <para>A lot of configuration in FreeBSD is done by editing a text
      file.  Because of this, it would be a good idea to become familiar
      with a text editor.  FreeBSD comes with a few as part of the base
      system, and many more are available in the ports collection.</para>

    <para>The easiest and simplest editor to learn is an editor called
      <application>ee</application>, which stands for easy editor.  To
      start <application>ee</application>, one would type at the command
      line <command>ee filename</command> where
      <literal>filename</literal> is the name of the file to be edited.
      For example, to edit <filename>/etc/rc.conf</filename>, type in
      <command>ee /etc/rc.conf</command>.  Once inside of ee, all of the
      commands for manipulating the editor's functions are listed at the
      top of the display. The caret <literal>^</literal> character means
      the control key on the keyboard, so ^e expands to pressing the
      control key plus the letter <literal>e</literal>.  To leave
      <application>ee</application>, hit the escape key, then choose leave
      editor.  The editor will prompt you to save any changes if the file
      has been modified.</para>

    <para>FreeBSD also comes with more powerful text editors such as
      <application>vi</application> as part of the base system, and
      <application>emacs</application> and <application>vim</application>
      as part of the FreeBSD ports collection.  These editors offer much
      more functionality and power at the expense of being a little more
      complicated to learn.  However if you plan on doing a lot of text
      editing, learning a more powerful editor such as
      <application>vim</application> or <application>emacs</application>
      will save you much more time in the long run.</para>
  </sect1>

  <sect1>
    <title>For more information...</title>

    <sect2 id="basics-man">
      <title>Manual pages</title>

      <para>The most comprehensive documentation on FreeBSD is in the form
	of man pages. Nearly every program on the system comes with a
	short reference manual explaining the basic operation and various
	arguments. These manuals can be viewed with the man command.  Use
	of the man command is simple:</para>

      <para><command>&prompt.user; man command</command></para>

      <para><literal>command</literal> is the name of the command you
        wish to learn about.  For example, to learn more about
	<command>ls</command> command type:</para>

      <para><command>&prompt.user; man ls</command></para>

      <para>The online manual is divided up into numbered sections:</para>

      <orderedlist>
	<listitem>
	  <para>User commands.</para>
	</listitem>

	<listitem>
	  <para>System calls and error numbers.</para>
	</listitem>

	<listitem>
	  <para>Functions in the C libraries.</para>
	</listitem>

	<listitem>
	  <para>Device drivers.</para>
	</listitem>

	<listitem>
	  <para>File formats.</para>
	</listitem>

	<listitem>
	  <para>Games and other diversions.</para>
	</listitem>

	<listitem>
	  <para>Miscellaneous information.</para>
	</listitem>

	<listitem>
	  <para>System maintenance and operation commands.</para>
	</listitem>

	<listitem>
	  <para>Kernel developers.</para>
	</listitem>
      </orderedlist>

      <para>In some cases, the same topic may appear in more than one
        section of the online manual.  For example, there is a chmod user
	command and a <literal>chmod()</literal> system call.  In this
	case, you can tell the man command which one you want by
	specifying the section:</para>

      <para><command>&prompt.user; man 1 chmod</command></para>

      <para>This will display the manual page for the user command
        <command>chmod</command>. References to a particular section of
	the online manual are traditionally placed in parenthesis in
	written documentation, so &man.chmod.1; refers to the
	<command>chmod</command> user command and &man.chmod.2; refers to
	the system call.</para>

      <para>This is fine if you know the name of the command and simply
	wish to know how to use it, but what if you cannot recall the
	command name?  You can use man to search for keywords in the
	command descriptions by using the <option>-k</option>
	switch:</para>

      <para><command>&prompt.user; man -k mail</command></para>

      <para>With this command you will be presented with a list of
        commands that have the keyword &ldquo;mail&rdquo; in their
	descriptions.  This is actually functionally equivalent to using
	the apropos command.</para>

      <para>So, you are looking at all those fancy commands in
	<filename>/usr/bin</filename> but do not have the faintest idea
	what most of them actually do?  Simply do a
	<command>&prompt.user; cd /usr/bin; man -f *</command> or
	<command>&prompt.user; cd /usr/bin; whatis *</command> which
	does the same thing.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Files</title>

      <para>FreeBSD includes many applications and utilities produced by
	the Free Software Foundation (FSF).  In addition to man pages,
	these programs come with more extensive hypertext documents called
	<literal>info</literal> files which can be viewed with the
	<command>info</command> command or, if you installed
	<application>emacs</application>, the info mode of
	<application>emacs</application>.</para>

      <para>To use the &man.info.1; command, simply type:</para>

      <para><command>&prompt.user; info</command></para>

      <para>For a brief introduction, type <literal>h</literal>.  For a
	quick command reference, type <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

