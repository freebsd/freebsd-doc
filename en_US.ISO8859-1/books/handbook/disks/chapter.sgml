<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/disks/chapter.sgml,v 1.31 2001/06/25 12:41:15 murray Exp $
-->

<chapter id="disks">
  <title>Disks</title>

  <sect1 id="disks-synopsis">
    <title>Synopsis</title>

    <para>This chapter covers how to use disks, whether physical,
      memory, or networked, on FreeBSD.</para>
  </sect1>

  <sect1 id="disks-bios-numbering">
    <title>BIOS Drive Numbering</title>

    <para>Before you install and configure FreeBSD on your system, there is an
      important subject that you should be aware of if, especially if you have
      multiple hard drives.</para>

    <indexterm><primary>DOS</primary></indexterm>
    <indexterm><primary>Microsoft Windows</primary></indexterm>
    <para>In a PC running DOS or any of the BIOS-dependent operating systems
      (WINxxx), the BIOS is able to abstract the normal disk drive order, and
      the operating system goes along with the change.  This allows the user
      to boot from a disk drive other than the so-called <quote>primary
	master</quote>.  This is especially convenient for some users who have
      found that the simplest and cheapest way to keep a system backup is to
      buy an identical second hard drive, and perform routine copies of the
      first drive to the second drive using Ghost or XCOPY.  Then, if the
      first drive fails, or is attacked by a virus, or is scribbled upon by an
      operating system defect, he can easily recover by instructing the BIOS
      to logically swap the drives. It's like switching the cables on the
      drives, but without having to open the case.</para>

    <indexterm><primary>SCSI</primary></indexterm>
    <indexterm><primary>BIOS</primary></indexterm>
    <para>More expensive systems with SCSI controllers often include BIOS
      extensions which allow the SCSI drives to be re-ordered in a similar
      fashion for up to seven drives.</para>

    <para>A user who is accustomed to taking advantage of these features may
      become surprised when the results with FreeBSD are not as expected.
      FreeBSD does not use the BIOS, and does not know the <quote>logical BIOS
	drive mapping</quote>.  This can lead to very perplexing situations,
      especially when drives are physically identical in geometry, and have
      also been made as data clones of one another.</para>

    <para>When using FreeBSD, always restore the BIOS to natural drive
      numbering before installing FreeBSD, and then leave it that way.  If you
      need to switch drives around, then do so, but do it the hard way, and
      open the case and move the jumpers and cables.</para>

    <sidebar>
      <title>An illustration from the files of Bill and Fred's Exceptional
	Adventures:</title>
      
      <para>Bill breaks-down an older Wintel box to make another FreeBSD box
	for Fred. Bill installs a single SCSI drive as SCSI unit zero, and
	installs FreeBSD on it.</para>

      <para>Fred begins using the system, but after several days notices that
	the older SCSI drive is reporting numerous soft errors, and reports
	this fact to Bill.</para>

      <para>After several more days, Bill decides it's time to address the
	situation, so he grabs an identical SCSI drive from the disk drive
	"archive" in the back room.  An initial surface scan indicates that
	this drive is functioning well, so Bill installs this drive as SCSI
	unit four, and makes an image copy from drive zero to drive four.  Now
	that the new drive is installed and functioning nicely, Bill decides
	that it's a good idea to start using it, so he uses features in the
	SCSI BIOS to re-order the disk drives so that the system boots from
	SCSI unit four.  FreeBSD boots and runs just fine.</para>

      <para>Fred continues his work for several days, and soon Bill and Fred
	decide that it's time for a new adventure -- time to upgrade to a
	newer version of FreeBSD.  Bill removes SCSI unit zero because it was
	a bit flaky, and replaces it with another identical disk drive from
	the "archive."  Bill then installs the new version of FreeBSD onto the
	new SCSI unit zero using Fred's magic Internet FTP floppies.  The
	installation goes well.</para>

      <para>Fred uses the new version of FreeBSD for a few days, and certifies
	that it is good enough for use in the engineering department...it's
	time to copy all of his work from the old version.  So Fred mounts
	SCSI unit four (the latest copy of the older FreeBSD version).  Fred
	is dismayed to find that none of his precious work is present on SCSI
	unit four.</para>

      <para>Where did the data go?</para>

      <para>When Bill made an image copy of the original SCSI unit zero onto
	SCSI unit four, unit four became the "new clone,"  When Bill
	re-ordered the SCSI BIOS so that he could boot from SCSI unit four, he
	was only fooling himself. FreeBSD was still running on SCSI unit zero.
	Making this kind of BIOS change will cause some or all of the Boot and
	Loader code to be fetched from the selected BIOS drive, but when the
	FreeBSD kernel drivers take-over, the BIOS drive numbering will be
	ignored, and FreeBSD will transition back to normal drive numbering.
	In the illustration at hand, the system continued to operate on the
	original SCSI unit zero, and all of Fred's data was there, not on SCSI
	unit four.  The fact that the system appeared to be running on SCSI
	unit four was simply an artifact of human expectations.</para>

      <para>We are delighted to mention that no data bytes were killed or
	harmed in any way by our discovery of this phenomenon.  The older SCSI
	unit zero was retrieved from the bone pile, and all of Fred's work was
	returned to him, (and now Bill knows that he can count as high as
	zero).</para>

      <para>Although SCSI drives were used in this illustration, the concepts
	apply equally to IDE drives.</para>
    </sidebar>
  </sect1>

  <sect1 id="disks-naming">
    <title>Disk Naming</title>

    <indexterm><primary>IDE</primary></indexterm>
    <indexterm><primary>SCSI</primary></indexterm>
    <indexterm><primary>RAID</primary></indexterm>
    <indexterm><primary>fash memory</primary></indexterm>
    <para>Physical drives come in two main flavors,
      <acronym>IDE</acronym>, or <acronym>SCSI</acronym>; but there
      are also drives backed by RAID controllers, flash memory, and so
      forth.  Since these behave quite differently, they have their
      own drivers and devices.</para>

    <table id="disk-naming-physical-table">
      <title>Physical Disk Naming Conventions</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Drive type</entry>
	    <entry>Drive device name</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE hard drives</entry>
	    <entry><literal>ad</literal> in 4.0-RELEASE,
	      <literal>wd</literal> before 4.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>IDE CDROM drives</entry>
	    <entry><literal>acd</literal> from 4.1-RELEASE,
	      <literal>wcd</literal> before 4.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>SCSI hard drives</entry>
	    <entry><literal>da</literal> from 3.0-RELEASE,
	      <literal>sd</literal> before 3.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>SCSI CDROM drives</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Assorted non-standard CDROM drives</entry>
	    <entry><literal>mcd</literal> for Mitsumi CD-ROM,
	      <literal>scd</literal> for Sony CD-ROM,
	      <literal>matcd</literal> for Matsushita/Panasonic CD-ROM
	    </entry>
	  </row>
	  <row>
	    <entry>Floppy drives</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI tape drives</entry>
	    <entry><literal>sa</literal> from 3.0-RELEASE,
	      <literal>st</literal> before 3.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>IDE tape drives</entry>
	    <entry><literal>ast</literal> from 4.0-RELEASE,
	      <literal>wst</literal> before 4.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>Flash drives</entry>
	    <entry><literal>fla</literal> for DiskOnChip Flash device
	      from 3.3-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>RAID drives</entry>
	    <entry><literal>myxd</literal> for Mylex, and
	      <literal>amrd</literal> for AMI MegaRAID,
	      <literal>idad</literal> for Compaq Smart RAID.
	      from 4.0-RELEASE.  <literal>id</literal> between
	      3.2-RELEASE and 4.0-RELEASE.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <sect2>
      <title>Slices and Partitions</title>
      <indexterm><primary>slices</primary></indexterm>
      <indexterm><primary>partitions</primary></indexterm>
      <indexterm><primary>dangerously dedicated</primary></indexterm>
      <para>Physical disks usually contain
	<firstterm>slices</firstterm>, unless they are
	<quote>dangerously dedicated</quote>.  Slice numbers follow
	the device name, prefixed with an <literal>s</literal>:
	<quote>da0<emphasis>s1</emphasis></quote>.</para>

      <para>Slices, <quote>dangerously dedicated</quote> physical
	drives, and other drives contain
	<firstterm>partitions</firstterm>, which represented as
	letters from <literal>a</literal> to <literal>h</literal>.
	<literal>b</literal> is reserved for swap partitions, and
	<literal>c</literal> is an unused partition the size of the
	entire slice or drive.  This is explained in <xref
	linkend="disks-adding" />.</para>
    </sect2>
  </sect1>

  <sect1 id="disks-mounting">
    <title>Mounting and Unmounting Filesystems</title>

    <para>The filesystem is best visualized as a tree,
      rooted, as it were, at <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename>, and the
      other directories in the root directory are branches, which may
      have their own branches, such as
      <filename>/usr/local</filename>, and so on.</para>

    <indexterm><primary>root filesystem</primary></indexterm>
    <para>There are various reasons to house some of these
      directories on separate filesystems.  <filename>/var</filename>
      contains log, spool, and various types of temporary files, and
      as such, may get filled up.  Filling up the root filesystem
      isn't a good idea, so splitting <filename>/var</filename> from
      <filename>/</filename> is often a good idea.</para>

    <para>Another common reason to contain certain directory trees on
      other filesystems is if they are to be housed on separate
      physical disks, or are separate virtual disks, such as <link
	linkend="nfs">Network File System</link> mounts, or CDROM
      drives.</para>

    <sect2 id="disks-fstab">
      <title>The fstab File</title>
      <indexterm><primary>filesystems</primary><secondary>mounted with
      fstab</secondary></indexterm>

      <para>During the <link linkend="boot">boot process</link>,
	filesystems listed in <filename>/etc/fstab</filename> are
	automatically mounted (unless they are listed with
	<option>noauto</option>).</para>

      <para>The <filename>/etc/fstab</filename> file contains a list
	of lines of the following format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <para><literal>device</literal> is a device name (which should
	exist), as explained in the <link linkend="disks-naming">Disk
	  naming conventions</link> above.</para>

      <para><literal>mount-point</literal> is a directory (which
	should exist), on which to mount the filesystem.</para>

      <para><literal>fstype</literal> is the filesystem type to pass
	to &man.mount.8;.  The default FreeBSD filesystem is
	<literal>ufs</literal>.</para>

      <para><literal>options</literal> is either <option>rw</option>
	for read-write filesystems, or <option>ro</option> for
	read-only filesystems, followed by any other options that may
	be needed.  A common option is <option>noauto</option> for
	filesystems not normally mounted during the boot sequence.
	Other options in the &man.mount.8; manual page.</para>

      <para><literal>dumpfreq</literal> is the number of days the
	filesystem should be dumped, and <literal>passno</literal> is
	the pass number during which the filesystem is mounted during
	the boot sequence.</para>
    </sect2>

    <sect2 id="disks-mount">
      <title>The mount Command</title>
      <indexterm><primary>filesystems</primary><secondary>mounting</secondary></indexterm>

      <para>The &man.mount.8; command is what is ultimately used to
	mount filesystems.</para>

      <para>In its most basic form, you use:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>There are plenty of options, as mentioned in the
	&man.mount.8; manual page, but the most common are:</para>

      <variablelist>
	<title>mount options</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Mount all filesystems in
	      <filename>/etc/fstab</filename>, as modified by
	      <option>-t</option>, if given.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Do everything but actually mount the
	      filesystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Force the mounting the filesystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Mount the filesystem read-only.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Mount the given filesystem as the given filesystem
	      type, or mount only filesystems of the given type, if
	      given the <option>-a</option> option.</para>

	    <para><quote>ufs</quote> is the default filesystem
	      type.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Update mount options on the filesystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Be verbose.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Mount the filesystem read-write.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>The <option>-o</option> takes a comma-separated list of
	the options, including the following:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
	    <para>Do not interpret special devices on the
	      filesystem.  Useful security option.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Do not allow execution of binaries on this
	      filesystem.  Useful security option.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Do not interpret setuid or setgid flags on the
	      filesystem.  Useful security option.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>The umount Command</title>
      <indexterm><primary>filesystems</primary><secondary>unmounting</secondary></indexterm>

      <para>The umount command takes, as a parameter, one of a
	mountpoint, a device name, or the <option>-a</option> or
	<option>-A</option> option.</para>

      <para>All forms take <option>-f</option> to force unmounting,
	and <option>-v</option> for verbosity.</para>

      <para><option>-a</option> and <option>-A</option> are used to
	unmount all mounted filesystems, possibly modified by the
	filesystem types listed after <option>-t</option>.
	<option>-A</option>, however, doesn't attempt to unmount the
	root filesystem.</para>
    </sect2>
  </sect1>
  
  <sect1 id="disks-adding">
    <title>Adding Disks</title>
    <indexterm><primary>disks</primary><secondary>adding</secondary></indexterm>

    <para><emphasis>Originally contributed by &a.obrien; 26 April
      1998</emphasis></para>
      
    <para>Lets say we want to add a new SCSI disk to a machine that
      currently only has a single drive.  First turn off the computer
      and install the drive in the computer following the instructions
      of the computer, controller, and drive manufacturer.  Due the
      wide variations of procedures to do this, the details are beyond
      the scope of this document.</para>

    <para>Login as user <username>root</username>.  After you've installed the
      drive, inspect <filename>/var/run/dmesg.boot</filename> to ensure the new
      disk was found.  Continuing with our example, the newly added drive will
      be <filename>da1</filename> and we want to mount it on
      <filename>/1</filename> (if you are adding an IDE drive, it will
      be <filename>wd1</filename> in pre-4.0 systems, or
      <filename>ad1</filename> in most 4.X systems).</para>

    <indexterm><primary>partitions</primary></indexterm>
    <indexterm><primary>slices</primary></indexterm>
    <indexterm><primary>fdisk</primary></indexterm>

    <para>Because FreeBSD runs on IBM-PC compatible computers, it must
      take into account the PC BIOS partitions.  These are different
      from the traditional BSD partitions.  A PC disk has up to four
      BIOS partition entries.  If the disk is going to be truly
      dedicated to FreeBSD, you can use the
      <emphasis>dedicated</emphasis> mode.  Otherwise, FreeBSD will
      have to live with in one of the PC BIOS partitions.  FreeBSD
      calls the PC BIOS partitions <emphasis>slices</emphasis> so as
      not to confuse them with traditional BSD partitions.  You may
      also use slices on a disk that is dedicated to FreeBSD, but used
      in a computer that also has another operating system installed.
      This is to not confuse the <command>fdisk</command> utility of
      the other operating system.</para>

    <para>In the slice case the drive will be added as
      <filename>/dev/da1s1e</filename>.  This is read as: SCSI disk,
      unit number 1 (second SCSI disk), slice 1 (PC BIOS partition 1),
      and <filename>e</filename> BSD partition.  In the dedicated
      case, the drive will be added simply as
      <filename>/dev/da1e</filename>.</para>

    <sect2>
      <title>Using sysinstall</title>
      <indexterm><primary>sysinstall</primary><secondary>adding disks</secondary></indexterm>

      <para>You may use <command>/stand/sysinstall</command> to
	partition and label a new disk using its easy to use menus.
	Either login as user <username>root</username> or use the
	<command>su</command> command.  Run
	<command>/stand/sysinstall</command> and enter the
	<literal>Configure</literal> menu.  With in the
	<literal>FreeBSD Configuration Menu</literal>, scroll down and
	select the <literal>Partition</literal> item.  Next you should
	be presented with a list of hard drives installed in your
	system.  If you do not see <literal>da1</literal> listed, you
	need to recheck your physical installation and
	<command>dmesg</command> output in the file
	<filename>/var/run/dmesg.boot</filename>.</para>
      
      <para>Select <literal>da1</literal> to enter the <literal>FDISK
	Partition Editor</literal>.  Choose <literal>A</literal> to
	use the entire disk for FreeBSD.  When asked if you want to
	<quote>remain cooperative with any future possible operating
	systems</quote>, answer <literal>YES</literal>.  Write the
	changes to the disk using <command>W</command>.  Now exit the
	FDISK editor using <command>q</command>.  Next you will be
	asked about the Master Boot Record.  Since you are adding a
	disk to an already running system, choose
	<literal>None</literal>.</para>

      <indexterm><primary>BSD partitions</primary></indexterm>
      <para>Next enter the <literal>Disk Label Editor</literal>.  This
        is where you will create the traditional BSD partitions.  A
        disk can have up to eight partitions, labeled a-h.  A few of
        the partition labels have special uses.  The
        <literal>a</literal> partition is used for the root partition
        (<filename>/</filename>).  Thus only your system disk (e.g,
        the disk you boot from) should have an <literal>a</literal>
        partition.  The <literal>b</literal> partition is used for
        swap partitions, and you may have many disks with swap
        partitions.  The <literal>c</literal> partition addresses the
        entire disk in dedicated mode, or the entire FreeBSD slice in
        slice mode.  The other partitions are for general use.</para>

      <para>Sysinstall's Label editor favors the <literal>e</literal>
	partition for non-root, non-swap partitions.  With in the
	Label editor, create a single file system using
	<command>C</command>.  When prompted if this will be a FS
	(file system) or swap, choose <literal>FS</literal> and give a
	mount point (e.g, <filename>/mnt</filename>).  When adding a
	disk in post-install mode, Sysinstall will not create entries
	in <filename>/etc/fstab</filename> for you, so the mount point
	you specify isn't important.</para>

      <para>You are now ready to write the new label to the disk and
	create a file system on it.  Do this by hitting
	<command>W</command>.  Ignore any errors from Sysinstall that
	it could not mount the new partition.  Exit the Label Editor
	and Sysinstall completely.</para>

      <para>The last step is to edit <filename>/etc/fstab</filename>
	to add an entry for your new disk.</para>
    </sect2>

    <sect2>
      <title>Using Command Line Utilities</title>

      <sect3>
	<title>Using Slices</title>

	<para>This setup will allow your disk to work correctly with
	  other operating systems that might be installed on your
	  computer and will not confuse other operating systems' fdisk
	  utilities.  It is recommended to use this method for new disk
	  installs.  Only use <literal>dedicated</literal> mode if you
	  have a good reason to do so!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> #Initialize your new disk
&prompt.root; <userinput>disklabel -B -w -r da1s1 auto</userinput> #Label it.
&prompt.root; <userinput>disklabel -e da1s1</userinput> # Now edit the disklabel you just created and add any partitions.
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # Repeat this for every partition you created.
&prompt.root; <userinput>mount -t ufs /dev/da1s1e /1</userinput> # Mount the partition(s)
&prompt.root; <userinput>vi /etc/fstab</userinput> # When satisfied, add the appropriate entry/entries to your <filename>/etc/fstab</filename>.</screen>

	<para>If you have an IDE disk, substitute <filename>ad</filename>
	  for <filename>da</filename>.  On pre-4.x systems use
	  <filename>wd</filename>.</para> 
      </sect3>
      
      <sect3>
	<title>Dedicated</title>
	<indexterm><primary>OS/2</primary></indexterm>

	<para>If you will not be sharing the new drive with another operating
	  system, you may use the <literal>dedicated</literal> mode.  Remember
	  this mode can confuse Microsoft operating systems; however, no damage
	  will be done by them.  IBM's OS/2 however, will
	  <quote>appropriate</quote> any partition it finds which it doesn't
	  understand.</para>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput>				# create the `e' partition
&prompt.root; <userinput>newfs -d0 /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      
	<para>An alternate method is:</para>
      
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/rda1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <title>Virtual Disks: Network, Memory, and File-Based Filesystems</title>
    <indexterm><primary>virtual disks</primary></indexterm>
    <indexterm><primary>disks</primary><secondary>virtual</secondary></indexterm>

    <para>Aside from the disks you physically insert into your computer:
      floppies, CDs, hard drives, and so forth; other forms of disks
      are understood by FreeBSD - the <firstterm>virtual
      disks</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm><primary>disks</primary><secondary>memory</secondary></indexterm>
    <para>These include network filesystems such as the <link
	linkend="nfs">Network Filesystem</link> and Coda, memory-based
      filesystems such as <link linkend="disks-md">md</link> and
      file-backed filesystems created by <link
	linkend="disks-vnconfig">vnconfig</link>.</para>

    <sect2 id="disks-vnconfig">
      <title>vnconfig: file-backed filesystem</title>
      <indexterm><primary>disks</primary><secondary>file-backed</secondary></indexterm>

      <para>&man.vnconfig.8; configures and enables vnode pseudo disk
	devices.  A <firstterm>vnode</firstterm> is a representation
	of a file, and is the focus of file activity.  This means that
	&man.vnconfig.8; uses files to create and operate a
	filesystem.  One possible use is the mounting of floppy or CD
	images kept in files.</para>

      <para>To mount an existing filesystem image:</para>

      <example>
	<title>Using vnconfig to mount an existing filesystem
	  image</title>

	<screen>&prompt.root; <userinput>vnconfig vn<replaceable>0</replaceable> <replaceable>diskimage</replaceable></userinput>
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>To create a new filesystem image with vnconfig:</para>

      <example>
	<title>Creating a New File-Backed Disk with vnconfig</title>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn<replaceable>0</replaceable> <replaceable>newimage</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w vn<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs vn<replaceable>0</replaceable>c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/rvn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 id="disks-md">
      <title>md: Memory Filesystem</title>
      <indexterm><primary>disks</primary><secondary>memory</secondary></indexterm>

      <para>md is a simple, efficient means to do memory
	filesystems.</para>

      <para>Simply take a filesystem you've prepared with, for
	example, &man.vnconfig.8;, and:</para>

      <example>
	<title>md memory disk</title>

	<screen>&prompt.root; <userinput>dd if=<replaceable>newimage</replaceable> of=/dev/md<replaceable>0</replaceable></userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md<replaceable>0c</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>
  </sect1>
  
  <sect1 id="quotas">
    <title>Disk Quotas</title>
    <indexterm><primary>accounting</primary><secondary>disk
    space</secondary></indexterm>
    <indexterm><primary>disk quotas</primary></indexterm>

    <para>Quotas are an optional feature of the operating system that
      allow you to limit the amount of disk space and/or the number of
      files a user, or members of a group, may allocate on a per-file
      system basis. This is used most often on timesharing systems where
      it is desirable to limit the amount of resources any one user or
      group of users may allocate.  This will prevent one user from
      consuming all of the available disk space.</para>

    <sect2>
      <title>Configuring Your System to Enable Disk Quotas</title>

      <para>Before attempting to use disk quotas it is necessary to make
	sure that quotas are configured in your kernel.  This is done by
	adding the following line to your kernel configuration
	file:</para>

      <programlisting>options QUOTA</programlisting>

      <para>The stock <filename>GENERIC</filename> kernel does not have
	this enabled by default, so you will have to configure, build and
	install a custom kernel in order to use disk quotas.  Please refer
	to the <link linkend="kernelconfig">Configuring the FreeBSD
	Kernel</link> section for more information on kernel
	configuration.</para>

      <para>Next you will need to enable disk quotas in
	<filename>/etc/rc.conf</filename>.  This is done by adding the
	line:</para>

      <programlisting>enable_quotas=<quote>YES</quote></programlisting>
      <indexterm><primary>disk quotas</primary><secondary>checking</secondary></indexterm>
      <para>For finer control over your quota startup, there is an
	additional configuration variable available. Normally on bootup,
	the quota integrity of each file system is checked by the
	<command>quotacheck</command> program.  The
	<command>quotacheck</command> facility insures that the data in
	the quota database properly reflects the data on the file system.
	This is a very time consuming process that will significantly
	affect the time your system takes to boot. If you would like to
	skip this step, a variable is made available for the
	purpose:</para>

      <programlisting>check_quotas=<quote>NO</quote></programlisting>

      <para>If you are running FreeBSD prior to 3.2-RELEASE, the
	configuration is simpler, and consists of only one variable.  Set
	the following in your <filename>/etc/rc.conf</filename>:</para>

      <programlisting>check_quotas=<quote>YES</quote></programlisting>

      <para>Finally you will need to edit <filename>/etc/fstab</filename>
	to enable disk quotas on a per-file system basis.  This is where
	you can either enable user or group quotas or both for all of your
	file systems.</para>

      <para>To enable per-user quotas on a file system, add the
	<literal>userquota</literal> option to the options field in the
	<filename>/etc/fstab</filename> entry for the file system you want
	to enable quotas on.  For example:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Similarly, to enable group quotas, use the
	<literal>groupquota</literal> option instead of the
	<literal>userquota</literal> keyword.  To enable both user and
	group quotas, change the entry as follows:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>By default the quota files are stored in the root directory of
	the file system with the names <filename>quota.user</filename> and
	<filename>quota.group</filename> for user and group quotas
	respectively.  See <command>man fstab</command> for more
	information.  Even though that man page says that you can specify
	an alternate location for the quota files, this is not recommended
	because the various quota utilities do not seem to handle this
	properly.</para>

      <para>At this point you should reboot your system with your new
	kernel.  <filename>/etc/rc</filename> will automatically run the
	appropriate commands to  create the initial quota files for all of
	the quotas you enabled in <filename>/etc/fstab</filename>, so
	there is no need to manually create any zero length quota
	files.</para>

      <para>In the normal course of operations you should not be required
	to run the <command>quotacheck</command>,
	<command>quotaon</command>, or <command>quotaoff</command>
	commands manually.  However, you may want to read their man pages
	just to be familiar with their operation.</para>
    </sect2>

    <sect2>
      <title>Setting Quota Limits</title>
      <indexterm><primary>disk quotas</primary><secondary>limits</secondary></indexterm>

      <para>Once you have configured your system to enable quotas, verify
	that they really are enabled.  An easy way to do this is to
	run:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>
	  
      <para>You should see a one line summary of disk usage and current
	quota limits for each file system that quotas are enabled
	on.</para>

      <para>You are now ready to start assigning quota limits with the
	<command>edquota</command> command.</para>

      <para>You have several options on how to enforce limits on the
	amount of disk space a user or group may allocate, and how many
	files they may create.  You may limit allocations based on disk
	space (block quotas) or number of files (inode quotas) or a
	combination of both.  Each of these limits are further broken down
	into two categories; hard and soft limits.</para>

      <indexterm><primary>hard limit</primary></indexterm>
      <para>A hard limit may not be exceeded.  Once a user reaches his
	hard limit he may not make any further allocations on the file
	system in question.  For example, if the user has a hard limit of
	500 blocks on a file system and is currently using 490 blocks, the
	user can only allocate an additional 10 blocks.  Attempting to
	allocate an additional 11 blocks will fail.</para>

      <indexterm><primary>soft limit</primary></indexterm>
      <para>Soft limits, on the other hand, can be exceeded for a limited
	amount of time.  This period of time is known as the grace period,
	which is one week by default.  If a user stays over his or her
	soft limit longer than the grace period, the soft limit will
	turn into a hard limit and no further allocations will be allowed.
	When the user drops back below the soft limit, the grace period
	will be reset.</para>

      <para>The following is an example of what you might see when you run
	the <command>edquota</command> command.  When the
	<command>edquota</command> command is invoked, you are placed into
	the editor specified by the <envar>EDITOR</envar> environment
	variable, or in the <command>vi</command> editor if the
	<envar>EDITOR</envar> variable is not set, to allow you to edit
	the quota limits.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>You will normally see two lines for each file system that has
	quotas enabled.  One line for the block limits, and one line for
	inode limits.  Simply change the value you want updated to modify
	the quota limit.  For example, to raise this users block limit
	from a soft limit of 50 and a hard limit of 75 to a soft limit of
	500 and a hard limit of 600, change:</para>

      <programlisting>/usr: blocks in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>to:</para>

      <programlisting> /usr: blocks in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>The new quota limits will be in place when you exit the
	editor.</para>

      <para>Sometimes it is desirable to set quota limits on a range of
	uids.  This can be done by use of the <option>-p</option> option
	on the <command>edquota</command> command.  First, assign the
	desired quota limit to a user, and then run
	<command>edquota -p protouser startuid-enduid</command>.  For
	example, if user <username>test</username> has the desired quota
	limits, the following command can be used to duplicate those quota
	limits for uids 10,000 through 19,999:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>
	  
      <para>See <command>man edquota</command> for more detailed
	information.</para>
    </sect2>

    <sect2>
      <title>Checking Quota Limits and Disk Usage</title>
      <indexterm><primary>disk quotas</primary><secondary>checking</secondary></indexterm>

      <para>You can use either the <command>quota</command> or the
	<command>repquota</command> commands to check quota limits and
	disk usage.  The <command>quota</command> command can be used to
	check individual user and group quotas and disk usage.  Only the
	super-user may examine quotas and usage for other users, or for
	groups that they are not a member of.  The
	<command>repquota</command> command can be used to get a summary
	of all quotas and disk usage for file systems with quotas
	enabled.</para>

      <para>The following is some sample output from the
	<command>quota -v</command> command for a user that has quota
	limits on two file systems.</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>grace period</primary></indexterm>
      <para>On the <filename>/usr</filename> file system in the above
	example this user is currently 15 blocks over the soft limit of
	50 blocks and has 5 days of the grace period left.  Note the
	asterisk <literal>*</literal> which indicates that the user is
	currently over his quota limit.</para>

      <para>Normally file systems that the user is not using any disk
	space on will not show up in the output from the
	<command>quota</command> command, even if he has a quota limit
	assigned for that file system.  The <option>-v</option> option
	will display those file systems, such as the
	<filename>/usr/var</filename> file system in the above
	example.</para>
    </sect2>

    <sect2>
      <title>Quotas over NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas are enforced by the quota subsystem on the NFS server.
	The &man.rpc.rquotad.8; daemon makes quota information available
	to the &man.quota.1; command on NFS clients, allowing users on
	those machines to see their quota statistics.</para>

      <para>Enable <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> like so:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Now restart <command>inetd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>

  <sect1 id="creating-cds">
    <title>Creating CDs</title>
    <indexterm><primary>CDROMs</primary><secondary>creating</secondary></indexterm>

    <para><emphasis>Contributed by Mike Meyer
      <email>mwm@mired.org</email>, April 2001.</emphasis></para>

    <sect2>
      <title>Introduction</title>

      <para>CDs have a number of features that differentiate them from
	conventional disks. Initially, they weren't writable by the
	user. They are designed so that they can be read continuously without
	delays to move the head between tracks. They are also much easier
	to transport between systems than similarly sized media were at the
	time.</para>
    
      <para>CDs do have tracks, but this refers to a section of data to
	be read continuously and not a physical property of the disk. To
	produce a CD on FreeBSD, you prepare the data files that are going
	to make up the tracks on the CD, then write the tracks to the
	CD.</para>
    
      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm><primary>filesystems</primary><secondary>ISO-9660</secondary></indexterm>
      <para>The ISO 9660 file system was designed to deal with these
	differences. It unfortunately codifies file system limits that were
	common then. Fortunately, it provides an extension mechanism that
	allows properly written CDs to exceed those limits while still
	working with systems that do not support those extensions.</para>

      <indexterm><primary>mkisofs</primary></indexterm>
      <para>The <command><link linkend="mkisofs">mkisofs</link></command>
	program is used to produce a data file containing an ISO 9660 file
	system. It has options that support various extensions, and is
	described below. You can install it with the <filename>
	/usr/ports/sysutils/mkisofs</filename> port.</para>
    
      <indexterm><primary>CD burner</primary><secondary>ATAPI</secondary></indexterm>
      <para>Which tool to use to burn the CD depends on whether your CD burner
	is ATAPI or something else. ATAPI CD burners use the <command><link
	linkend="burncd">burncd</link></command> program that is part of
	the base system. SCSI and USB CD burners should use the
	<command><link linkend="cdrecord">cdrecord</link></command> from
	the <filename>/usr/ports/sysutils/cdrecord</filename> port.</para>
    </sect2>

    <sect2 id="mkisofs">
      <title>mkisofs</title>

      <para><command>mkisofs</command> produces an ISO 9660 file system
	that is an image of a directory tree in the Unix file system name
	space. The simplest usage is:</para>
    
      <screen>&prompt.root; <userinput>mkisofs <option>-o</option> <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm><primary>filesystems</primary><secondary>ISO-9660</secondary></indexterm>
      <para>This command will create an <replaceable>imagefile</replaceable>
	containing an ISO 9660 file system that is a copy of the tree at
	<replaceable>/path/to/tree</replaceable>. In the process, it will
	map the file names to names that fit the limitations of the
	standard ISO 9660 file system, and will exclude files that have
	names uncharacteristic of ISO file systems. Read &man.mkisofs.8;
	for details of this process, and options that can be used to
	control it.</para>
    
      <indexterm><primary>filesystems</primary><secondary>HFS</secondary></indexterm>
      <indexterm><primary>filesystems</primary><secondary>Joliet</secondary></indexterm>
      <para>A number of options are available to overcome those
	restrictions. In particular, <option>-R</option> enables the
	Rock Ridge extensions common to Unix systems, <option>-J</option>
	enables Joliet extensions used by Microsoft systems, and
	<option>-hfs</option> can be used to create HFS file systems used
	by Macs. Read &man.mkisofs.8; for more information on the last
	two.</para>
    
      <para>For CDs that are going to be used only on FreeBSD systems,
	<option>-U</option> can be used to disable all filename
	restrictions. When used with <option>-R</option>, it produces a
	file system image that is identical to the FreeBSD tree you started
	from, though it may violate the ISO 9660 standard in a number of
	ways.</para>

      <indexterm><primary>CDROMs</primary><secondary>creating bootable</secondary></indexterm>    
      <para>The last option of general use is <option>-b</option>. This is
	used to specify the location of the boot image for use in producing an
	<quote>El Torito</quote> bootable CD. This option takes an
	argument which is the path to a boot image from the top of the
	tree being written to the CD. So, given that
	<filename>/tmp/myboot</filename> holds a bootable FreeBSD system
	with the boot image in
	<filename>/tmp/myboot/boot/cdboot</filename>, you could produce the
	image of an ISO 9660 file system in
	<filename>/tmp/bootable.iso</filename> like so:</para>

      <screen>&prompt.root; <userinput>mkisofs <option>-U</option> <option>-R</option> <option>-b</option> <filename>boot/cdboot</filename> <option>-o</option> <filename>/tmp/bootable.iso</filename> <filename>/tmp/myboot</filename></userinput></screen>

      <para>Having done that, if you have vn configured in your kernel, you
	can mount the file system with:</para>

      <screen>&prompt.root; <userinput>vnconfig <option>-e</option> <filename>vn0c</filename> <filename>/tmp/bootable.iso</filename></userinput>
&prompt.root; <userinput>mount <option>-t</option> cd9660 <filename>/dev/vn0c</filename> <filename>/mnt</filename></userinput></screen>

      <para>At which point you can verify that <filename>/mnt</filename>
	and <filename>/tmp/myboot</filename> are identical.</para>

      <para>There are many other options you can use with
	<command>mkisofs</command> to fine-tune its behavior. See
	&man.mkisofs.8; for details.</para>
    </sect2>

    <sect2 id="burncd">
      <title>burncd</title>
      <indexterm><primary>CDROMs</primary><secondary>burning</secondary></indexterm>    
      <para>If you have an ATAPI CD burner, you can use the
	<command>burncd</command> command to burn an ISO image onto a
	CD. <command>burncd</command> is part of the base system, installed
	as <filename>/usr/sbin/burncd</filename>.  Usage is very simple, as
	it has few options:</para>
      
      <screen>&prompt.root; <userinput>burncd <option>-f</option> <replaceable>cddevice</replaceable> data <replaceable>imagefile.iso</replaceable> fixate</userinput></screen>

      <para>Will burn a copy of <replaceable>imagefile.iso</replaceable> on
	<replaceable>cddevice</replaceable>. The default device is
	<filename>/dev/acd0</filename>. See &man.burncd.8; for options to
	set the write speed, eject the CD after burning, and write audio
	data.</para>
    </sect2>

    <sect2 id="cdrecord">
      <title>cdrecord</title>

      <para>If you do not have an ATAPI CD burner, you will have to use
	<command>cdrecord</command> to burn your
	CDs. <command>cdrecord</command> is not part of the base system;
	you must install it from either the port at <filename>
	/usr/ports/sysutils/cdrecord</filename> or the appropriate
	package. Changes to the base system can cause binary versions of
	this program to fail, possibly resulting in a
	<quote>coaster</quote>. You should therefore either upgrade the
	port when you upgrade your system, or if you are <link
	linkend="stable">tracking -stable</link>, upgrade the port when a
	new version becomes available.</para>
      
      <para>While <command>cdrecord</command> has many options, basic usage
	is even simpler than <command>burncd</command>. Burning an ISO 9660
	image is done with:</para>
      
      <screen>&prompt.root; <userinput>cdrecord <option>dev=</option><replaceable>device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>
      
      <para>The tricky part of using <command>cdrecord</command> is finding
	the <option>dev</option> to use. To find the proper setting, use
	the <option>-scanbus</option> flag of <command>cdrecord</command>,
	which might produce results like this:</para>
      <indexterm><primary>CDROMs</primary><secondary>burning</secondary></indexterm>          
      <screen>&prompt.root; <userinput>cdrecord <option>-scanbus</option></userinput>
Cdrecord 1.9 (i386-unknown-freebsd4.2) Copyright (C) 1995-2000 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *
</screen>

      <para>This lists the appropriate <option>dev</option> value for the
	devices on the list. Locate your CD burner, and use the three
	numbers separated by commas as the value for
	<option>dev</option>. In this case, the CRW device is 1,5,0, so the
	appropriate input would be
	<userinput><option>dev</option>=1,5,0</userinput>. There are easier
	ways to specify this value; see &man.cdrecord.1; for
	details. That is also the place to look for information on writing
	audio tracks, controlling the speed, and other things.</para>
    </sect2>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
