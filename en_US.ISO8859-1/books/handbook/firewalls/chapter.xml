<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="firewalls">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Joseph J.</firstname>
	<surname>Barbish</surname>
	<contrib>Contributed by </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Brad</firstname>
	<surname>Davis</surname>
	<contrib>Converted to SGML and updated by </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Firewalls</title>

  <indexterm><primary>firewall</primary></indexterm>

  <indexterm>
    <primary>security</primary>

    <secondary>firewalls</secondary>
  </indexterm>

  <sect1 id="firewalls-intro">
    <title>Introduction</title>

    <para>Firewalls make it possible to filter the incoming and
      outgoing traffic that flows through a system.  A firewall can
      use one or more sets of <quote>rules</quote> to inspect network
      packets as they come in or go out of network connections and
      either allows the traffic through or blocks it.  The rules of
      a firewall can inspect one or more characteristics of the
      packets such as the protocol type, source or destination host
      address, and source or destination port.</para>

    <para>Firewalls can enhance the security of a host or a network.
      They can be used to do one or more of the following:</para>

    <itemizedlist>
      <listitem>
	<para>Protect and insulate the applications, services, and
	  machines of an internal network from unwanted traffic from
	  the public Internet.</para>
      </listitem>

      <listitem>
	<para>Limit or disable access from hosts of the internal
	  network to services of the public Internet.</para>
      </listitem>

      <listitem>
	<para>Support network address translation
	  (<acronym>NAT</acronym>), which allows an internal network
	  to use private <acronym>IP</acronym> addresses and share a
	  single connection to the public Internet using either a
	  single <acronym>IP</acronym> address or a shared pool of
	  automatically assigned public addresses.</para>
      </listitem>
    </itemizedlist>

    <para>After reading this chapter, you will know:</para>

    <itemizedlist>
      <listitem>
	<para>How to define packet filtering rules.</para>
      </listitem>

      <listitem>
	<para>The differences between the firewalls built into
	  &os;.</para>
      </listitem>

      <listitem>
	<para>How to use and configure the
	  <application>PF</application> firewall.</para>
      </listitem>

      <listitem>
	<para>How to use and configure the
	  <application>IPFILTER</application> firewall.</para>
      </listitem>

      <listitem>
	<para>How to use and configure the
	  <application>IPFW</application> firewall.</para>
      </listitem>
    </itemizedlist>

    <para>Before reading this chapter, you should:</para>

    <itemizedlist>
      <listitem>
	<para>Understand basic &os; and Internet concepts.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="firewalls-concepts">
    <title>Firewall Concepts</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>rulesets</secondary>
    </indexterm>

    <para>A firewall ruleset can be either
      <quote>exclusive</quote> or <quote>inclusive</quote>.  An
      exclusive firewall allows all traffic through except for the
      traffic matching the ruleset.  An inclusive firewall does the
      reverse as it only allows traffic matching the rules through and
      blocks everything else.</para>

    <para>An inclusive firewall offers better control of the outgoing
      traffic, making it a better choice for systems that offer
      services to the public Internet.  It also controls the type of
      traffic originating from the public Internet that can gain
      access to a private network.  All traffic that does not match
      the rules is blocked and logged.  Inclusive firewalls are
      generally safer than exclusive firewalls because they
      significantly reduce the risk of allowing unwanted
      traffic.</para>

    <note>
      <para>Unless noted otherwise, all configuration and example
	rulesets in this chapter create inclusive firewall
	rulesets.</para>
    </note>

    <para>Security can be tightened further using a <quote>stateful
	firewall</quote>.  This type of firewall keeps track of open
      connections and only allows traffic which either matches an
      existing connection or opens a new, allowed connection.  The
      disadvantage of a stateful firewall is that it can be vulnerable
      to Denial of Service (<acronym>DoS</acronym>) attacks if a lot
      of new connections are opened very fast.  Most firewalls use a
      combination of stateful and non-stateful behavior.</para>
  </sect1>

  <sect1 id="firewalls-apps">
    <title>Firewall Packages</title>

    <para>&os; has three firewalls built into the base system:
      <emphasis>IPFILTER</emphasis>, also known as
      <acronym>IPF</acronym>, <emphasis>IPFIREWALL</emphasis>, also
      known as <acronym>IPFW</acronym>, and <acronym>PF</acronym>).
      &os; also provides two traffic shapers for controlling bandwidth
      usage: &man.altq.4; and &man.dummynet.4;.  Dummynet has
      traditionally been closely tied with <acronym>IPFW</acronym>,
      and <acronym>ALTQ</acronym> with <acronym>PF</acronym>.  Each
      firewall uses rules to control the access of packets to and from
      a &os; system, although they go about it in different ways and
      each has a different rule syntax.</para>

    <para>&os; provides multiple firewalls in order to meet the
      different requirements and preferences for a wide variety of
      users.  Each user should evaluate which firewall best meets
      their needs.</para>

    <para>Since all firewalls are based on inspecting the values of
      selected packet control fields, the creator of the firewall
      ruleset must have an understanding of how
      <acronym>TCP/IP</acronym> works, what the different values in
      the packet control fields are, and how these values are used in
      a normal session conversation.  For a good introduction, refer
      to <ulink
	url="http://www.ipprimer.com/overview.cfm">Daryl's TCP/IP
	Primer</ulink>.</para>
  </sect1>

  <sect1 id="firewalls-pf">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>John</firstname>
	  <surname>Ferrell</surname>
	  <contrib>Revised and updated by </contrib>
	  <!-- 24 March 2008 -->
	</author>
      </authorgroup>
    </sect1info>

    <title>PF and <acronym>ALTQ</acronym></title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>PF</secondary>
    </indexterm>

    <para>Since &os;&nbsp;5.3, a ported version of OpenBSD's
      <acronym>PF</acronym> firewall has been included as an
      integrated part of the base system.  <acronym>PF</acronym> is a
      complete, full-featured firewall that has optional support for
      <acronym>ALTQ</acronym> (Alternate Queuing), which provides
      Quality of Service (<acronym>QoS</acronym>).</para>

    <para>Since the OpenBSD Project maintains the definitive
      reference for <acronym>PF</acronym> in the<ulink
	url="http://www.openbsd.org/faq/pf/">PF FAQ</ulink>, this
      section of the Handbook focuses on <acronym>PF</acronym> as it
      pertains to &os;, while providing some general usage
      information.</para>

    <para>More information about porting <acronym>PF</acronym> to &os;
      can be found at <ulink
	url="http://pf4freebsd.love2party.net/"></ulink>.</para>

    <sect2>
      <title>Using the PF Loadable Kernel Modules</title>

      <para>In order to use PF, the PF kernel module must be first
	loaded.  Add the following line to
	<filename>/etc/rc.conf</filename>:</para>

        <programlisting>pf_enable="YES"</programlisting>

	<para>Then, run the startup script to load the module:</para>

        <screen>&prompt.root; <userinput>service pf start</userinput></screen>

	<para>The PF module will not load if it cannot find the
	  ruleset configuration file.  The default location is
	  <filename>/etc/pf.conf</filename>.  If the PF ruleset is
	  located somewhere else, add a line to
	  <filename>/etc/rc.conf</filename> which specifies the full
	  path to the file:</para>

        <programlisting>pf_rules="<replaceable>/path/to/pf.conf</replaceable>"</programlisting>

	<para>The sample <filename>pf.conf</filename>
	  can be found in <filename
	    class="directory">/usr/share/examples/pf/</filename>.</para>

	<para>The <acronym>PF</acronym> module can also be loaded
	  manually from the command line:</para>

      <screen>&prompt.root; <userinput>kldload pf.ko</userinput></screen>

      <para>Logging support for PF is provided by
	<varname>pflog.ko</varname> which can be loaded by adding the
	following line to <filename>/etc/rc.conf</filename>:</para>

      <programlisting>pflog_enable="YES"</programlisting>

      <para>Then, run the startup script to load the module:</para>

      <screen>&prompt.root; <userinput>service pflog start</userinput></screen>

    </sect2>

    <sect2>
      <title>PF Kernel Options</title>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>device pfsync</secondary>
      </indexterm>

      <para>While it is not necessary to compile
	<acronym>PF</acronym> support into the &os; kernel, some of
	PF's advanced features are not included in the loadable
	module, namely &man.pfsync.4;, which is a pseudo-device that
	exposes certain changes to the state table used by
	<acronym>PF</acronym>.  It can be paired with &man.carp.4; to
	create failover firewalls using <acronym>PF</acronym>.  More
	information on <acronym>CARP</acronym> can be found in <link
	  linkend="carp">of the Handbook</link>.</para>

      <para>The following <acronym>PF</acronym> kernel options can be
	found in <filename>/usr/src/sys/conf/NOTES</filename>:</para>

      <programlisting>device pf
device pflog
device pfsync</programlisting>

      <para><literal>device pf</literal> enables PF support.</para>

      <para><literal>device pflog</literal> enables the optional
	&man.pflog.4; pseudo network device which can be used to log
	traffic to a &man.bpf.4; descriptor.  The &man.pflogd.8;
	daemon can then be used to store the logging information to
	disk.</para>

      <para><literal>device pfsync</literal> enables the optional
	&man.pfsync.4; pseudo-network device that is used to monitor
	<quote>state changes</quote>.</para>
    </sect2>

    <sect2>
      <title>Available <filename>rc.conf</filename> Options</title>

      <para>The following &man.rc.conf.5; statements can be used to
	configure <acronym>PF</acronym> and &man.pflog.4; at
	boot:</para>

      <programlisting>pf_enable="YES"                 # Enable PF (load module if required)
pf_rules="/etc/pf.conf"         # rules definition file for pf
pf_flags=""                     # additional flags for pfctl startup
pflog_enable="YES"              # start pflogd(8)
pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup</programlisting>

      <para>If there is a LAN behind the firewall and packets need to
	be forwarded for the computers on the LAN, or NAT is required,
	add the following option:</para>

      <programlisting>gateway_enable="YES"            # Enable as LAN gateway</programlisting>
    </sect2>

    <sect2>
      <title>Creating Filtering Rules</title>

      <para>By default, <acronym>PF</acronym> reads its configuration
	rules from <filename>/etc/pf.conf</filename> and modifies,
	drops, or passes packets according to the rules or definitions
	specified in this file.  The &os; installation includes
	several sample files located in
	<filename>/usr/share/examples/pf/</filename>.  Refer to the
	<ulink url="http://www.openbsd.org/faq/pf/">PF FAQ</ulink> for
	complete coverage of <acronym>PF</acronym> rulesets.</para>

      <warning>
	<para>When reading the <ulink
	    url="http://www.openbsd.org/faq/pf/">PF FAQ</ulink>,
	  keep in mind that different versions of &os; contain
	  different versions of PF.  Currently,
	  &os;&nbsp;8.<replaceable>X</replaceable> and prior is using
	  the same version of <acronym>PF</acronym> as
	  OpenBSD&nbsp;4.1.  &os;&nbsp;9.<replaceable>X</replaceable>
	  and later is using the same version of <acronym>PF</acronym>
	  as OpenBSD&nbsp;4.5.</para>
      </warning>

      <para>The &a.pf; is a good place to ask questions about
	configuring and running the <acronym>PF</acronym> firewall.
	Do not forget to check the mailing list archives before asking
	questions.</para>
    </sect2>

    <sect2>
      <title>Working with PF</title>

      <para>To control <acronym>PF</acronym>, use &man.pfctl.8;.
	Below are some useful options to this command.  Review
	&man.pfctl.8; for a description of all available
	options:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Command</entry>
	      <entry>Purpose</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><command>pfctl
		  <option>-e</option></command></entry>
	      <entry>Enable PF.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl
		  <option>-d</option></command></entry>
	      <entry>Disable PF.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl <option>-F</option> all
		  <option>-f</option> /etc/pf.conf</command></entry>
	      <entry>Flush all NAT, filter, state, and table
		rules and reload
		<filename>/etc/pf.conf</filename>.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl <option>-s</option> [ rules | nat
		  state ]</command></entry>
	      <entry>Report on the filter rules, NAT rules, or state
		table.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl <option>-vnf</option>
		  /etc/pf.conf</command></entry>
	      <entry>Check <filename>/etc/pf.conf</filename> for
		errors, but do not load ruleset.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Enabling <acronym>ALTQ</acronym></title>

      <para><acronym>ALTQ</acronym> is only available by compiling its
	support into the &os; kernel.  <acronym>ALTQ</acronym> is not
	supported by all network card drivers.  Refer to &man.altq.4;
	for a list of drivers that are supported by the release of
	&os;.</para>

      <para>The following kernel options will enable
	<acronym>ALTQ</acronym> and add additional
	functionality:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # Class Bases Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)
options         ALTQ_NOPCC      # Required for SMP build</programlisting>

      <para><literal>options ALTQ</literal> enables the
	<acronym>ALTQ</acronym> framework.</para>

      <para><literal>options ALTQ_CBQ</literal> enables
	<emphasis>Class Based Queuing</emphasis>
	(<acronym>CBQ</acronym>).  <acronym>CBQ</acronym>
	can be used to divide a connection's bandwidth into different
	classes or queues to prioritize traffic based on filter
	rules.</para>

      <para><literal>options ALTQ_RED</literal> enables
	<emphasis>Random Early Detection</emphasis>
	(<acronym>RED</acronym>).  <acronym>RED</acronym> is
	used to avoid network congestion by measuring the length of
	the queue and comparing it to the minimum and maximum
	thresholds for the queue.  If the queue is over the maximum,
	all new packets will be dropped.  <acronym>RED</acronym> drops
	packets from different connections randomly.</para>

      <para><literal>options ALTQ_RIO</literal> enables
	<emphasis>Random Early Detection In and Out</emphasis>.</para>

      <para><literal>options ALTQ_HFSC</literal> enables the
	<emphasis>Hierarchical Fair Service Curve Packet
	  Scheduler</emphasis> <acronym>HFSC</acronym>.  For more
	information, refer to <ulink
	  url="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html"></ulink>.</para>

      <para><literal>options ALTQ_PRIQ</literal> enables
	<emphasis>Priority Queuing</emphasis>
	(<acronym>PRIQ</acronym>).  <acronym>PRIQ</acronym> will
	always pass traffic that is in a higher queue first.</para>

      <para><literal>options ALTQ_NOPCC</literal> enables
	<acronym>SMP</acronym> support for <acronym>ALTQ</acronym>.
	This option is required on <acronym>SMP</acronym>
	systems.</para>
    </sect2>
  </sect1>

  <sect1 id="firewalls-ipf">
    <title>The IPFILTER (IPF) Firewall</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>IPFILTER</secondary>
    </indexterm>

    <para>IPFILTER is a cross-platform, open source firewall which
      has been ported to &os;, NetBSD, OpenBSD, &sunos;, HP/UX, and
      &solaris; operating systems.</para>

    <para>IPFILTER is based on a kernel-side firewall and
      <acronym>NAT</acronym> mechanism that can be controlled and
      monitored by userland interface programs.  The firewall rules
      can be set or deleted using &man.ipf.8;.  The
      <acronym>NAT</acronym> rules can be set or deleted using
      &man.ipnat.8;.  Run-time statistics for the kernel parts of
      IPFILTER can be printed using &man.ipfstat.8;.  To log IPFILTER
      actions to the system log files, use &man.ipmon.8;.</para>

    <para>IPF was originally written using a rule processing logic
      of <quote>the last matching rule wins</quote> and only used
      stateless rules.  Over time, IPF has been enhanced to include a
      <quote>quick</quote> option and a stateful
      <quote>keep state</quote> option which modernized the rules
      processing logic.  IPF's official documentation covers only the
      legacy rule coding parameters and rule file processing logic and
      the modernized functions are only included as additional
      options.</para>

    <para>The instructions contained in this section are based on
      using rules that contain <quote>quick</quote> and
      <quote>keep state</quote> as these provide the basic framework
      for configuring an inclusive firewall ruleset.</para>

    <para>For a detailed explanation of the legacy rules processing
      method, refer to <ulink
	url="http://www.munk.me.uk/ipf/ipf-howto.html"></ulink>
      and <ulink
	url="http://coombs.anu.edu.au/~avalon/ip-filter.html"></ulink>.</para>

    <para>The IPF FAQ is at <ulink
	url="http://www.phildev.net/ipf/index.html"></ulink>.</para>

    <para>A searchable archive of the IPFilter mailing list is
      available at <ulink
	url="http://marc.theaimsgroup.com/?l=ipfilter"></ulink>.</para>

    <sect2>
      <title>Enabling IPF</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>enabling</secondary>
      </indexterm>

      <para>IPF is included in the basic &os; install as a kernel
	loadable module.  The system will dynamically load
	this module at boot time when
	<varname>ipfilter_enable="YES"</varname> is added to
	<filename>rc.conf</filename>.  The module enables logging and
	<literal>default pass all</literal>.  To change the
	default to <literal>block all</literal>, add a
	<literal>block all</literal> rule at the end of the
	ruleset.</para>
    </sect2>

    <sect2>
      <title>Kernel Options</title>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFILTER</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>kernel options</secondary>
      </indexterm>

      <para>For users who prefer to statically compile IPF support
	into a custom kernel, the following IPF option statements,
	listed in <filename>/usr/src/sys/conf/NOTES</filename>, are
	available:</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para><literal>options IPFILTER</literal> enables support for
	the <quote>IPFILTER</quote> firewall.</para>

      <para><literal>options IPFILTER_LOG</literal> enables IPF
	logging using the <devicename>ipl</devicename> packet logging
	pseudo&mdash;device for every rule that has the
	<literal>log</literal> keyword.</para>

      <para><literal>options IPFILTER_DEFAULT_BLOCK</literal> changes
	the default behavior so that any packet not matching a
	firewall <literal>pass</literal> rule gets blocked.</para>

      <para>These settings will take effect only after installing a
	kernel that has been built with the above options set.</para>
    </sect2>

    <sect2>
      <title>Available <filename>rc.conf</filename> Options</title>

      <para>To activate IPF at boot time, the following statements
	need to be added to <filename>/etc/rc.conf</filename>:</para>

      <programlisting>ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
ipmon_enable="YES"                # Start IP monitor log
ipmon_flags="-Ds"                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</programlisting>

      <para>If there is a LAN behind the firewall that uses the
	reserved private IP address ranges, the following lines have
	to be added to enable <acronym>NAT</acronym>
	functionality:</para>

      <programlisting>gateway_enable="YES"              # Enable as LAN gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat</programlisting>
    </sect2>

    <sect2>
      <title>IPF</title>

      <indexterm><primary><command>ipf</command></primary></indexterm>

      <para>To load the ruleset file, use &man.ipf.8;.  Custom rules
	are normally placed in a file, and the following command can
	be used to replace the currently running firewall
	rules:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para><option>-Fa</option> flushes all the internal rules
	tables.</para>

      <para><option>-f</option> specifies the file containing the
	rules to load.</para>

      <para>This provides the ability to make changes to a custom
	rules file, run the above IPF command, and thus update the
	running firewall with a fresh copy of the rules without having
	to reboot the system.  This method is convenient for testing
	new rules as the procedure can be executed as many times as
	needed.</para>

      <para>Refer to &man.ipf.8; for details on the other flags
	available with this command.</para>

      <para>&man.ipf.8; expects the rules file to be a standard text
	file.  It will not accept a rules file written as a script
	with symbolic substitution.</para>

      <para>There is a way to build IPF rules that utilize the power
	of script symbolic substitution.  For more information, see
	<link linkend="firewalls-ipf-rules-script"></link>.</para>
    </sect2>

    <sect2>
      <title>IPFSTAT</title>

      <indexterm><primary><command>ipfstat</command></primary></indexterm>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>statistics</secondary>
      </indexterm>

      <para>The default behavior of &man.ipfstat.8; is to retrieve
	and display the totals of the accumulated statistics gathered
	by applying the rules against packets going in and out of the
	firewall since it was last started, or since the last time the
	accumulators were reset to zero using <command>ipf
	  -Z</command>.</para>

      <para>Refer to &man.ipfstat.8; for details.</para>

      <para>The default &man.ipfstat.8; output will look something
	like this:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state(in): kept 0 lost 0
 fragment state(out): kept 0 lost 0
 packet state(in): kept 169364 lost 0
 packet state(out): kept 431395 lost 0
 ICMP replies: 0 <acronym>TCP</acronym> RSTs sent: 0
 Result cache hits(in): 1215208 (out): 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 <acronym>TCP</acronym> cksum fails(in): 0 (out): 0
 Packet log flags set: (0)</screen>

      <para>When supplied with either <option>-i</option> for inbound
	or <option>-o</option> for outbound, the command will retrieve
	and display the appropriate list of filter rules currently
	installed and in use by the kernel.</para>

      <para><command>ipfstat -in</command> displays the inbound
	internal rules table with rule numbers.</para>

      <para><command>ipfstat -on</command> displays the outbound
	internal rules table with rule numbers.</para>

      <para>The output will look something like this:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para><command>ipfstat -ih</command> displays the inbound
	internal rules table, prefixing each rule with a count of how
	many times the rule was matched.</para>

      <para><command>ipfstat -oh</command> displays the outbound
	internal rules table, prefixing each rule with a count of how
	many times the rule was matched.</para>

      <para>The output will look something like this:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>One of the most important options of
	<command>ipfstat</command> is <option>-t</option> which
	displays the state table in a way similar to how &man.top.1;
	shows the &os; running process table.  When a firewall is
	under attack, this function provides the ability to identify
	and see the attacking packets.  The optional sub-flags give
	the ability to select the destination or source IP, port, or
	protocol to be monitored in real time.  Refer to
	&man.ipfstat.8; for details.</para>
    </sect2>

    <sect2>
      <title>IPMON</title>

      <indexterm><primary><command>ipmon</command></primary></indexterm>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>logging</secondary>
      </indexterm>

      <para>In order for <command>ipmon</command> to work properly,
	the kernel option <literal>IPFILTER_LOG</literal> must be
	turned on.  This command has two different modes.  Native mode
	is the default mode when the command is used without
	<option>-D</option>.</para>

      <para>Daemon mode provides a continuous system log file so that
	logging of past events may be reviewed.  &os; has a built in
	facility to automatically rotate system logs.  This is why
	outputting the log information to &man.syslogd.8; is better
	than the default of outputting to a regular file.  The default
	<filename>rc.conf</filename>
	<literal>ipmon_flags</literal> statement uses
	<option>-Ds</option>:</para>

      <programlisting>ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</programlisting>

      <para>Logging provides the ability to review, after the fact,
	information such as which packets were dropped, what addresses
	they came from and where they were going.  These can all
	provide a significant edge in tracking down attackers.</para>

      <para>Even with the logging facility enabled, IPF will not
	generate any rule logging by default.  The firewall
	administrator decides which rules in the ruleset should be
	logged and adds the log keyword to those rules.  Normally,
	only deny rules are logged.</para>

      <para>It is customary to include a <quote>default deny
	  everything</quote> rule with the log keyword included as the
	last rule in the ruleset.  This makes it possible to see all
	the packets that did not match any of the rules in the
	ruleset.</para>
    </sect2>

    <sect2>
      <title>IPMON Logging</title>

      <para>&man.syslogd.8; uses its own method for segregation of log
	data.  It uses groupings called <quote>facility</quote> and
	<quote>level</quote>.  By default, IPMON in
	<option>-Ds</option> mode uses <literal>local0</literal> as
	the <quote>facility</quote> name.  The following levels can be
	used to further segregate the logged data:</para>

      <screen>LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short</screen>

      <!-- XXX: "can be considered short" == "with incomplete header" -->

      <para>In order to setup IPFILTER to log all data to
	<filename>/var/log/ipfilter.log</filename>, first
	create the empty file:</para>

       <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>&man.syslogd.8; is controlled by definition statements in
	<filename>/etc/syslog.conf</filename>.  This file offers
	considerable flexibility in how
	<application>syslog</application> will deal with system
	messages issued by software applications like IPF.</para>

      <para>To write all logged messages to the specified file,
	add the following statement to
	<filename>/etc/syslog.conf</filename>:</para>

      <programlisting>local0.* /var/log/ipfilter.log</programlisting>

      <para>To activate the changes and instruct &man.syslogd.8;
	to read the modified <filename>/etc/syslog.conf</filename>,
	run <command>service syslogd reload</command>.</para>

      <para>Do not forget to change
	<filename>/etc/newsyslog.conf</filename> to rotate the new
	log file.</para>
    </sect2>

    <sect2>
      <title>The Format of Logged Messages</title>

      <para>Messages generated by <command>ipmon</command> consist
	of data fields separated by white space.  Fields common to
	all messages are:</para>

      <orderedlist>
	<listitem>
	  <para>The date of packet receipt.</para>
	</listitem>

	<listitem>
	  <para>The time of packet receipt.  This is in the form
	    HH:MM:SS.F, for hours, minutes, seconds, and fractions
	    of a second.</para>
	</listitem>

	<listitem>
	  <para>The name of the interface that processed the
	    packet.</para>
	</listitem>

	<listitem>
	  <para>The group and rule number of the rule in the format
	    <literal>@0:17</literal>.</para>
	</listitem>
      </orderedlist>

      <para>These can be viewed with
	<command>ipfstat -in</command>.</para>

      <orderedlist>
	<listitem>
	  <para>The action: <literal>p</literal> for passed,
	    <literal>b</literal> for blocked, <literal>S</literal> for
	    a short packet, <literal>n</literal> did not match any
	    rules, and <literal>L</literal> for a log rule.  The order
	    of precedence in showing flags is: <literal>S</literal>,
	    <literal>p</literal>, <literal>b</literal>,
	    <literal>n</literal>, <literal>L</literal>.  A capital
	    <literal>P</literal> or <literal>B</literal> means that
	    the packet has been logged due to a global logging
	    setting, not a particular rule.</para>
	</listitem>

	<listitem>
	  <para>The addresses written as three fields: the source
	    address and port separated by a comma, the -&gt; symbol,
	    and the destination address and port.  For example:
	    <literal>209.53.17.22,80 -&gt;
	      198.73.220.17,1722</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>PR</literal> followed by the protocol name
	    or number: for example, <literal>PR tcp</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>len</literal> followed by the header length
	    and total length of the packet: for example,
	    <literal>len 20 40</literal>.</para>
	</listitem>
      </orderedlist>

      <para>If the packet is a <acronym>TCP</acronym> packet, there
	will be an additional field starting with a hyphen followed by
	letters corresponding to any flags that were set.  Refer to
	&man.ipf.5; for a list of letters and their flags.</para>

      <para>If the packet is an ICMP packet, there will be two fields
	at the end:  the first always being <quote>ICMP</quote> and
	the next being the ICMP message and sub-message type,
	separated by a slash.  For example:  ICMP 3/3 for a port
	unreachable message.</para>
    </sect2>

    <sect2 id="firewalls-ipf-rules-script">
      <title>Building the Rule Script with Symbolic
	Substitution</title>

      <para>Some experienced IPF users create a file containing the
	rules and code them in a manner compatible with running them
	as a script with symbolic substitution.  The major benefit
	of doing this is that only the value associated with the
	symbolic name needs to be changed, and when the script is
	run all the rules containing the symbolic name will have the
	value substituted in the rules.  Being a script, symbolic
	substitution can be used to code frequently used values and
	substitute them in multiple rules.  This can be seen in the
	following example.</para>

      <para>The script syntax used here is compatible with the
	&man.sh.1;, &man.csh.1;, and &man.tcsh.1; shells.</para>

      <para>Symbolic substitution fields are prefixed with a
	<literal>&dollar;</literal>.</para>

      <para>Symbolic fields do not have the &dollar; prefix.</para>

      <para>The value to populate the symbolic field must be enclosed
	between double quotes (<literal>"</literal>).</para>

      <para>Start the rule file with something like this:</para>

      <programlisting>############# Start of IPF rules script ########################

oif="dc0"            # name of the outbound interface
odns="192.0.2.11"    # ISP's DNS server IP address
myip="192.0.2.7"     # my static IP address from ISP
ks="keep state"
fks="flags S keep state"

# You can choose between building /etc/ipf.rules file
# from this script or running this script "as is".
#
# Uncomment only one line and comment out another.
#
# 1) This can be used for building /etc/ipf.rules:
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) This can be used to run script "as is":
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Allow out access to my ISP's Domain name server.
pass out quick on &dollar;oif proto tcp from any to &dollar;odns port = 53 &dollar;fks
pass out quick on &dollar;oif proto udp from any to &dollar;odns port = 53 &dollar;ks

# Allow out non-secure standard www function
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 80 &dollar;fks

# Allow out secure www function https over TLS SSL
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 443 &dollar;fks
EOF
################## End of IPF rules script ########################</programlisting>

      <para>The rules are not important in this example as it instead
	focuses on how the symbolic substitution fields are populated.
	If this example was in a file named
	<filename>/etc/ipf.rules.script</filename>, these rules could
	be reloaded by running:</para>

      <screen>&prompt.root; <userinput>sh /etc/ipf.rules.script</userinput></screen>

      <para>There is one problem with using a rules file with embedded
	symbolics: IPF does not understand symbolic substitution, and
	cannot read such scripts directly.</para>

      <para>This script can be used in one of two ways:</para>

      <itemizedlist>
	<listitem>
	  <para>Uncomment the line that begins with
	    <literal>cat</literal>, and comment out the line that
	    begins with <literal>/sbin/ipf</literal>.  Place
	    <literal>ipfilter_enable="YES"</literal> into
	    <filename>/etc/rc.conf</filename>, and run the script
	    once after each modification to create or update
	    <filename>/etc/ipf.rules</filename>.</para>
	</listitem>

	<listitem>
	  <para>Disable IPFILTER in the system startup scripts by
	    adding <literal>ipfilter_enable="NO"</literal>to
	    <filename>/etc/rc.conf</filename>.</para>

	  <para>Then, add a script like the following to <filename
	      class="directory">/usr/local/etc/rc.d/</filename>.
	    The script should have an obvious name like
	    <filename>ipf.loadrules.sh</filename>, where the
	    <filename>.sh</filename> extension is mandatory.</para>

	  <programlisting>#!/bin/sh
sh /etc/ipf.rules.script</programlisting>

	  <para>The permissions on this script file must be read,
	    write, execute for owner <username>root</username>:</para>

	  <screen>&prompt.root; <userinput>chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</userinput></screen>
	</listitem>
      </itemizedlist>

      <para>Now, when the system boots, the IPF rules will be
	loaded.</para>
    </sect2>

    <sect2>
      <title>IPF Rulesets</title>

      <para>A ruleset contains a group of IPF rules which pass or
	block packets based on the values contained in the packet.
	The bi-directional exchange of packets between hosts comprises
	a session conversation.  The firewall ruleset processes both
	the packets arriving from the public Internet, as well as the
	packets produced by the system as a response to them.
	Each <acronym>TCP/IP</acronym> service is predefined by its
	protocol and listening port.  Packets destined for a specific
	service originate from the source address using an
	unprivileged port and target the specific service port on the
	destination address.  All the above parameters can be used as
	selection criteria to create rules which will pass or block
	services.</para>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>rule processing order</secondary>
      </indexterm>

      <warning>
	<para>When working with the firewall rules, be <emphasis>very
	    careful</emphasis>.  Some configurations <emphasis>can
	  lock the administrator out</emphasis> of the server.  To be
	  on the safe side, consider performing the initial firewall
	  configuration from the local console rather than doing it
	  remotely over <application>ssh</application>.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Rule Syntax</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>rule syntax</secondary>
      </indexterm>

      <para>The rule syntax presented here has been simplified to
	only address the modern stateful rule context and <quote>first
	matching rule wins</quote> logic.  For the complete legacy
	rule syntax, refer to &man.ipf.8;.</para>

      <para>A <literal>#</literal> character is used to mark the
	start of a comment and may appear at the end of a rule line
	or on its own line.  Blank lines are ignored.</para>

      <para>Rules contain keywords which must be written in a specific
	order from left to right on the line.  Keywords are identified
	in bold type.  Some keywords have sub-options which may be
	keywords themselves and also include more sub-options.  Each
	of the headings in the below syntax has a bold section header
	which expands on the content.</para>

      <!-- This section is probably wrong. See the OpenBSD flag -->
      <!-- What is the "OpenBSD flag"?  Reference please -->

      <para><replaceable>ACTION IN-OUT OPTIONS SELECTION STATEFUL
	  PROTO SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG
	  STATEFUL</replaceable></para>

      <para><replaceable>ACTION</replaceable> = block | pass</para>

      <para><replaceable>IN-OUT</replaceable> = in | out</para>

      <para><replaceable>OPTIONS</replaceable> = log | quick | on
	interface-name</para>

      <para><replaceable>SELECTION</replaceable> = proto value |
	source/destination IP | port = number | flags
	flag-value</para>

      <para><replaceable>PROTO</replaceable> = tcp/udp | udp | tcp |
	icmp</para>

      <para><replaceable>SRC_ADD,DST_ADDR</replaceable> = all | from
	object to object</para>

      <para><replaceable>OBJECT</replaceable> = IP address |
	any</para>

      <para><replaceable>PORT_NUM</replaceable> = port number</para>

      <para><replaceable>TCP_FLAG</replaceable> = S</para>

      <para><replaceable>STATEFUL</replaceable> = keep state</para>

      <sect3>
	<title>ACTION</title>

	<para>The action keyword indicates what to do with the packet
	  if it matches the rest of the filter rule.  Each rule
	  <emphasis>must</emphasis> have an action.  The following
	  actions are recognized:</para>

	<para><literal>block</literal> indicates that the packet
	  should be dropped if the selection parameters match the
	  packet.</para>

	<para><literal>pass</literal> indicates that the packet should
	  exit the firewall if the selection parameters match the
	  packet.</para>
      </sect3>

      <sect3>
	<title>IN-OUT</title>

	<para>A mandatory requirement is that each filter rule
	  explicitly state which side of the I/O it is to be used
	  on.  The next keyword must be either <literal>in</literal>
	  or <literal>out</literal> and one or the other has to be
	  included or the rule will not pass syntax checks.</para>

	<para><literal>in</literal> means this rule is being applied
	  against an inbound packet which has just been received on
	  the interface facing the public Internet.</para>

	<para><literal>out</literal> means this rule is being applied
	  against an outbound packet destined for the interface facing
	  the public Internet.</para>
      </sect3>

      <sect3>
	<title>OPTIONS</title>

	<note>
	  <para>These options must be used in the order shown
	    here.</para>
	</note>

	<para><literal>log</literal> indicates that the packet header
	  will be written to the &man.ipl.4; packet log pseudo-device
	  if the selection parameters match the packet.</para>

	<para><literal>quick</literal> indicates that if the selection
	  parameters match the packet, this rule will be the last
	  rule checked, and no further processing of any following
	  rules will occur for this packet.</para>

	<para><literal>on</literal> indicates the interface name to
	  be incorporated into the selection parameters.  Interface
	  names are as displayed by &man.ifconfig.8;.  Using this
	  option, the rule will only match if the packet is going
	  through that interface in the specified direction.</para>

	<para>When a packet is logged, the headers of the packet are
	  written to the &man.ipl.4; packet logging pseudo-device.
	  Immediately following the <literal>log</literal> keyword,
	  the following qualifiers may be used in this order:</para>

	<para><literal>body</literal> indicates that the first 128
	  bytes of the packet contents will be logged after the
	  headers.</para>

	<para><literal>first</literal>.  If the <literal>log</literal>
	  keyword is being used in conjunction with a <literal>keep
	    state</literal> option, this option is recommended so that
	  only the triggering packet is logged and not every packet
	  which matches the stateful connection.</para>
      </sect3>

      <sect3>
	<title>SELECTION</title>

	<para>The keywords described in this section are used to
	  describe attributes of the packet to be checked when
	  determining whether or not rules match.  There is a
	  keyword subject, and it has sub-option keywords, one of
	  which has to be selected.  The following general-purpose
	  attributes are provided for matching, and must be used in
	  this order:</para>
      </sect3>

      <sect3>
	<title>PROTO</title>

	<para><literal>proto</literal> is the subject keyword which
	  must include one of its corresponding keyword sub-option
	  values.  The sub-option indicates a specific protocol to be
	  matched against.</para>

	<para><literal>tcp/udp | udp | tcp | icmp</literal> or any
	  protocol names found in <filename>/etc/protocols</filename>
	  are recognized and may be used.  The special protocol
	  keyword <literal>tcp/udp</literal> may be used to match
	  either a <acronym>TCP</acronym> or a <acronym>UDP</acronym>
	  packet, and has been added as a convenience to save
	  duplication of otherwise identical rules.</para>
      </sect3>

      <sect3>
	<title>SRC_ADDR/DST_ADDR</title>

	<para>The <literal>all</literal> keyword is equivalent to
	  <quote>from any to any</quote> with no other match
	  parameters.</para>

	<para><literal>from | to src to dst</literal>: the
	  <literal>from</literal> and <literal>to</literal>
	  keywords are used to match against IP addresses.  Rules
	  must specify <emphasis>both</emphasis> the source and
	  destination parameters.  <literal>any</literal> is a special
	  keyword that matches any IP address.  Examples include:
	  <literal>from any to any</literal>, <literal>from 0.0.0.0/0
	    to any</literal>, <literal>from any to
	    0.0.0.0/0</literal>, <literal>from 0.0.0.0 to
	    any</literal>, and <literal>from any to
	    0.0.0.0</literal>.</para>

	<para>There is no way to match ranges of IP addresses which
	  do not express themselves easily using the dotted numeric
	  form / mask-length notation.  The <filename
	    role="package">net-mgmt/ipcalc</filename> port may be
	  used to ease the calculation.  Additional information
	  is available at the utility's web page: <ulink
	    url="http://jodies.de/ipcalc"></ulink>.</para>
      </sect3>

      <sect3>
	<title>PORT</title>

	<para>If a port match is included, for either or both of
	  source and destination, it is only applied to
	  <acronym>TCP</acronym> and <acronym>UDP</acronym> packets.
	  When composing port comparisons, either the service name
	  from <filename>/etc/services</filename> or an integer port
	  number may be used.  When the port appears as part of the
	  <literal>from</literal> object, it matches the source port
	  number.  When it appears as part of the
	  <literal>to</literal> object, it matches the destination
	  port number.  An example usage is <literal>from any to any
	    port = 80</literal></para>

	<para>Single port comparisons may be done in a number of ways,
	  using a number of different comparison operators.  Instead
	  of the <literal>=</literal> shown in the example above,
	  the following operators may be used: <literal>!=</literal>,
	  <literal>&lt;</literal>, <literal>&gt;</literal>,
	  <literal>&lt;=</literal>, <literal>&gt;=</literal>,
	  <literal>eq</literal>, <literal>ne</literal>,
	  <literal>lt</literal>, <literal>gt</literal>,
	  <literal>le</literal>, and <literal>ge</literal>.</para>

	<para>To specify port ranges, place the two port numbers
	  between <literal>&lt;&gt;</literal> or
	  <literal>&gt;&lt;</literal></para>
      </sect3>

      <sect3>
	<title><acronym>TCP</acronym>_FLAG</title>

	<para>Flags are only effective for <acronym>TCP</acronym>
	  filtering.  The letters represent one of the possible flags
	  that can be matched against the <acronym>TCP</acronym>
	  packet header.</para>

	<para>The modernized rules processing logic uses the
	  <literal>flags S</literal> parameter to identify the TCP
	  session start request.</para>
      </sect3>

      <sect3>
	<title>STATEFUL</title>

	<para><literal>keep state</literal> indicates that on a pass
	  rule, any packets that match the rules selection parameters
	  should activate the stateful filtering facility.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Stateful Filtering</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>stateful filtering</secondary>
      </indexterm>

      <!-- XXX: duplicated -->

      <para>Stateful filtering treats traffic as a bi-directional
	exchange of packets comprising a session.  When activated,
	<literal>keep-state</literal> dynamically generates
	internal rules for each anticipated packet being exchanged
	during the session.  It has sufficient matching capabilities
	to determine if a packet is valid for a session.  Any packets
	that do not properly fit the session template are
	automatically rejected.</para>

      <para>IPF stateful filtering will also allow
	<acronym>ICMP</acronym> packets related to an existing
	<acronym>TCP</acronym> or <acronym>UDP</acronym> session.  So,
	if an <acronym>ICMP</acronym> type 3 code 4 packet is a
	response in a session started by a keep state rule, it will
	automatically be allowed.  Any packet that IPF can be certain
	is part of an active session, even if it is a different
	protocol, will be allowed.</para>

      <para>Packets destined to go out through the interface connected
	to the public Internet are first checked against the dynamic
	state table.  If the packet matches the next expected packet
	comprising an active session conversation, it exits the
	firewall and the state of the session conversation flow is
	updated in the dynamic state table.  Packets that do not
	belong to an already active session, are checked against the
	outbound ruleset.</para>

      <para>Packets coming in from the interface connected to the
	public Internet are first checked against the dynamic state
	table.  If the packet matches the next expected packet
	comprising an active session, it exits the firewall and the
	state of the session conversation flow is updated in the
	dynamic state table.  Packets that do not belong to an already
	active session, are checked against the inbound
	ruleset.</para>

      <para>When the session completes, it is removed from the
	dynamic state table.</para>

      <para>Stateful filtering allows one to focus on blocking/passing
	new sessions.  If the new session is passed, all its
	subsequent packets are allowed automatically and any impostor
	packets are automatically rejected.  If a new session is
	blocked, none of its subsequent packets are allowed.  Stateful
	filtering provides advanced matching abilities capable of
	defending against the flood of different attack methods
	employed by attackers.</para>
    </sect2>

    <sect2>
      <!-- XXX: This section needs a rewrite -->

      <title>Inclusive Ruleset Example</title>

      <para>The following ruleset is an example of an inclusive type
	of firewall which only allows services matching
	<literal>pass</literal> rules and blocks all others by
	default.  Network firewalls intended to protect other machines
	should have at least two interfaces, and are generally
	configured to trust the <acronym>LAN</acronym> and to not
	trust the public Internet.  Alternatively, a host based
	firewall might be configured to protect only the system it is
	running on, and is appropriate for servers on an untrusted
	network or a desktop system not protected by firewall on the
	network.</para>

      <para>&os; uses interface <devicename>lo0</devicename> and IP
	address <hostid role="ipaddr">127.0.0.1</hostid> for internal
	communication within the operating system.  The firewall rules
	must contain rules to allow free movement of these internally
	used packets.</para>

      <para>The interface which faces the public Internet is the one
	specified in the rules that authorize and control access of
	the outbound and inbound connections.</para>

      <para>In cases where one or more NICs are cabled to private
	network segments, those interfaces may require rules to allow
	packets originating from those LAN interfaces transit to each
	other or to the Internet.</para>

      <para>The rules should be organized into three major
	sections: the trusted interfaces, then the public
	interface outbound, and lastly, the public untrusted interface
	inbound.</para>

      <para>The rules in each of the public interface sections should
	have the most frequently matched rules placed before less
	commonly matched rules, with the last rule in the section
	blocking and logging all packets on that interface and
	direction.</para>

      <para>The outbound section in the following ruleset only
	contains <literal>pass</literal> rules which uniquely identify
	the services that are authorized for public Internet access.
	All the rules use <literal>quick</literal>,
	<literal>on</literal>, <literal>proto</literal>,
	<literal>port</literal>, and <literal>keep state</literal>.
	The <literal>proto tcp</literal> rules include
	<literal>flag</literal> to identify the session start request
	as the triggering packet to activate the stateful
	facility.</para>

      <para>The inbound section blocks undesirable packets first, for
	two different reasons.  The first is that malicious packets
	may be partial matches for legitimate traffic.  These packets
	have to be discarded rather than allowed, based on their
	partial matches against the <literal>allow</literal> rules.
	The second reason is that known and uninteresting rejects may
	be blocked silently, rather than being logged by the last rule
	in the section.</para>

      <para>The ruleset should ensure that there is no response
	returned for any undesirable traffic.  Invalid packets should
	be silently dropped so that the attacker has no knowledge if
	the packets reached the system.  Rules that include a
	<literal>log first</literal> option, will only log the event
	the first time they are triggered.  This option is included in
	the sample <literal>nmap OS fingerprint</literal> rule.  The
	<filename role="package">security/nmap</filename> utility is
	commonly used by attackers who attempt to identify the
	operating system of the server.</para>

      <para>Any time there are logged messages on a rule with
	the <literal>log first</literal> option,
	<command>ipfstat -hio</command> should be executed
	to evaluate how many times the rule has been matched.  A
	large number of matches usually indicates that the system is
	being flooded or is under attack.</para>

      <para>To lookup unknown port numbers, refer to
	<filename>/etc/services</filename>. Alternatively, visit
	<ulink
	  url="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers"></ulink>
	and do a port number lookup to find the purpose of a
	particular port number.</para>

      <para>Check out this link for port numbers used by Trojans
	<ulink
	  url="http://www.sans.org/security-resources/idfaq/oddports.php"></ulink>.</para>

      <para>The following ruleset creates an
	<literal>inclusive</literal> firewall ruleset which can be
	easily customized by commenting out
	<literal>pass</literal> rules for services that should not
	be authorized.</para>

      <para>To avoid logging unwanted messages, add a
	<literal>block</literal> rule in the inbound section.</para>

      <para>Change the <devicename>dc0</devicename> interface name in
	every rule to the interface name that connects the system to
	the public Internet.</para>

      <para>The following statements were added to
	<filename>/etc/ipf.rules</filename>:</para>

      <programlisting>#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Match session start requests originating from behind the
# firewall on the private network
# or from this gateway server destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# xxx must be the IP address of your ISP's DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP's DHCP server for cable or DSL networks.
# This rule is not needed for 'user ppp' type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state


# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users' non-secure FTP ( both passive &amp; active modes)
# This function uses the IP<acronym>NAT</acronym> built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out ssh/sftp/scp (telnet/rlogin/FTP replacements)
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out insecure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FreeBSD CVSup
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois from LAN to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that's trying to get out.
# This rule implements the default block
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Match packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it is the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# 'user ppp' type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence avoids filling up disk with Denial of Service logs.
# This rule implements the default block.
block in log first quick on dc0 all
################### End of rules file #####################################</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym></title>

      <indexterm><primary>NAT</primary></indexterm>

      <indexterm>
	<primary>IP masquerading</primary>

	<see>NAT</see>
      </indexterm>

      <indexterm>
	<primary>network address translation</primary>

	<see>NAT</see>
      </indexterm>

      <para><acronym>NAT</acronym> stands for <emphasis>Network
	  Address Translation</emphasis>.  In &linux;, NAT is called
	<quote>IP Masquerading</quote>.  The IPF
	<acronym>NAT</acronym> function enables the private LAN behind
	the firewall to share a single ISP-assigned IP address, even
	if that address is dynamically assigned.  NAT allows each
	computer in the LAN to have Internet access, without
	having to pay the ISP for multiple Internet accounts or IP
	addresses.</para>

      <para><acronym>NAT</acronym> will automatically translate the
	private LAN IP address for each system on the LAN to the
	single public IP address as packets exit the firewall bound
	for the public Internet.  It also performs the reverse
	translation for returning packets.</para>

      <para>According to RFC 1918, the following IP address ranges are
	reserved for private networks which will never be routed
	directly to the public Internet, and therefore are available
	for use with NAT:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>10.0.0.0/8</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>172.16.0.0/12</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>192.168.0.0/16</literal>.</para>
	</listitem>
      </itemizedlist>

    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym></title>

      <indexterm>
	<primary>NAT</primary>

	<secondary>and IPFILTER</secondary>
      </indexterm>

      <indexterm><primary><command>ipnat</command></primary></indexterm>

      <para><acronym>NAT</acronym> rules are loaded using
	<command>ipnat</command>.  Typically, the
	<acronym>NAT</acronym> rules are stored in
	<filename>/etc/ipnat.rules</filename>.  See &man.ipnat.8; for
	details.</para>

      <para>When the file containing the <acronym>NAT</acronym> rules
	is edited after <acronym>NAT</acronym> has been started, run
	<command>ipnat</command> with <option>-CF</option> to delete
	the internal in use <acronym>NAT</acronym> rules and flush the
	contents of the translation table of all active
	entries.</para>

      <para>To reload the <acronym>NAT</acronym> rules, issue a
	command like this:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f
	  /etc/ipnat.rules</userinput></screen>

      <para>To display some <acronym>NAT</acronym> statistics, use
	this command:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>To list the <acronym>NAT</acronym> table's current
	mappings, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>To turn verbose mode on and display information relating
	to rule processing and active rules/table entries:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym> Rules</title>

      <para><acronym>NAT</acronym> rules are flexible and can
	accomplish many different things to fit the needs of
	commercial and home users.</para>

      <para>The rule syntax presented here has been simplified to
	what is most commonly used in a non-commercial environment.
	For a complete rule syntax description, refer to
	&man.ipnat.5;.</para>

      <para>The syntax for a <acronym>NAT</acronym> rule looks like
	this:</para>

      <programlisting>map <replaceable>IF</replaceable> <replaceable>LAN_IP_RANGE</replaceable> -&gt; <replaceable>PUBLIC_ADDRESS</replaceable></programlisting>

      <para>The keyword <literal>map</literal> starts the rule.</para>

      <para>Replace <replaceable>IF</replaceable> with the external
	interface.</para>

      <para>The <replaceable>LAN_IP_RANGE</replaceable> is used by the
	internal clients use for IP Addressing.  Usually, this is
	something like <hostid
	  role="ipaddr">192.168.1.0/24</hostid>.</para>

      <para>The <replaceable>PUBLIC_ADDRESS</replaceable> can either
	be the static external IP address or the special keyword
	<literal>0/32</literal> which uses the IP address assigned to
	<replaceable>IF</replaceable>.</para>
    </sect2>

    <sect2>
      <title>How <acronym>NAT</acronym> Works</title>

      <para>In IPF, when a packet arrives at the firewall from the LAN
	with a public destination, it passes through the outbound
	filter rules.  <acronym>NAT</acronym> gets its turn at the
	packet and applies its rules top down, where the first
	matching rule wins.  <acronym>NAT</acronym> tests each of its
	rules against the packet's interface name and source IP
	address.  When a packet's interface name matches a
	<acronym>NAT</acronym> rule, the packet's source IP address in
	the private LAN is checked to see if it falls within the IP
	address range specified to the left of the arrow symbol on the
	<acronym>NAT</acronym> rule.  On a match, the packet has its
	source IP address rewritten with the public IP address
	obtained by the <literal>0/32</literal> keyword.
	<acronym>NAT</acronym> posts an entry in its internal
	<acronym>NAT</acronym> table so when the packet returns from
	the public Internet it can be mapped back to its original
	private IP address and then passed to the filter rules for
	processing.</para>
    </sect2>

    <sect2>
      <title>Enabling IP<acronym>NAT</acronym></title>

      <para>To enable IP<acronym>NAT</acronym>, add these statements
	to <filename>/etc/rc.conf</filename>.</para>

      <para>To enable the machine to route traffic between
	interfaces:</para>

      <programlisting>gateway_enable="YES"</programlisting>

      <para>To start IP<acronym>NAT</acronym> automatically each
	time:</para>

      <programlisting>ipnat_enable="YES"</programlisting>

      <para>To specify where to load the IP<acronym>NAT</acronym>
	rules from:</para>

      <programlisting>ipnat_rules="/etc/ipnat.rules"</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym> for a Large LAN</title>

      <para>For networks that have large numbers of systems on the LAN
	or networks with more than a single LAN, the process of
	funneling all those private IP addresses into a single public
	IP address becomes a resource problem that may cause problems
	with the same port numbers being used many times across many
	connections, causing collisions.  There are two ways to
	relieve this resource problem.</para>

      <sect3>
	<title>Assigning Ports to Use</title>

	<para>A normal NAT rule would look like:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32</programlisting>

	<para>In the above rule, the packet's source port is unchanged
	  as the packet passes through IP<acronym>NAT</acronym>.  By
	  adding the <literal>portmap</literal> keyword,
	  IP<acronym>NAT</acronym> can be directed to only use
	  source ports in the specified range.  For example, the
	  following rule will tell IP<acronym>NAT</acronym> to modify
	  the source port to be within the range shown:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

	<para>Additionally, the <literal>auto</literal> keyword tells
	  IP<acronym>NAT</acronym> to determine which ports are
	  available for use:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>
      </sect3>

      <sect3>
	<title>Using a Pool of Public Addresses</title>

	<para>In very large LANs there comes a point where there are
	  just too many LAN addresses to fit into a single public
	  address.  If a block of public IP addresses is available,
	  these addresses can be used as a <quote>pool</quote>, and
	  IP<acronym>NAT</acronym> may pick one of the public IP
	  addresses as packet addresses are mapped on their way
	  out.</para>

	<para>For example, instead of mapping all packets through a
	  single public IP address:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.1</programlisting>

	<para>A range of public IP addresses can be specified either
	  with a netmask:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</programlisting>

	<para>or using CIDR notation:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Port Redirection</title>

      <para>A common practice is to have a web server, email server,
	database server, and DNS server each segregated to a different
	system on the LAN.  In this case, the traffic from these
	servers still has to undergo <acronym>NAT</acronym>, but there
	has to be some way to direct the inbound traffic to the
	correct server.  For example, a web server operating on LAN
	address <hostid
	  role="ipaddr">10.0.10.25</hostid> and using a single public
	IP address of <hostid role="ipaddr">20.20.20.5</hostid>, would
	use this rule:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or:</para>

	<programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>For a LAN DNS server on a private address of <hostid
	    role="ipaddr">10.0.10.33</hostid> that needs to receive
	  public DNS requests:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</programlisting>
    </sect2>

    <sect2>
      <title>FTP and <acronym>NAT</acronym></title>

      <para>FTP has two modes:  active mode and passive mode.  The
	difference is in how the data channel is acquired.  Passive
	mode is more secure as the data channel is acquired by the
	ordinal ftp session requester.  For a good explanation of FTP
	and the different modes, see <ulink
	  url="http://www.slacksite.com/other/ftp.html"></ulink>.</para>

      <sect3>
	<title>IP<acronym>NAT</acronym> Rules</title>

	<para>IP<acronym>NAT</acronym> has a built in FTP proxy option
	  which can be specified on the <acronym>NAT</acronym> map
	  rule.  It can monitor all outbound packet traffic for FTP
	  active or passive start session requests and dynamically
	  create temporary filter rules containing the port number
	  being used by the data channel.  This eliminates the
	  security risk FTP normally exposes the firewall to as it no
	  longer needs to open large ranges of high order ports for
	  FTP connections.</para>

	<para>This rule will handle all the traffic for the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles the FTP traffic from the
	  gateway:</para>

	<programlisting>map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles all non-FTP traffic from the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

	<para>The FTP <literal>map</literal> rules go before the
	  <acronym>NAT</acronym> rule so that when a packet matches an
	  FTP rule, the FTP proxy creates temporary filter rules to
	  let the FTP session packets pass and undergo
	  <acronym>NAT</acronym>.  All LAN packets that are not FTP
	  will not match the FTP rules but will undergo
	  <acronym>NAT</acronym> if they match the third rule.</para>
      </sect3>

      <sect3>
	<title>IP<acronym>NAT</acronym> FTP Filter Rules</title>

	<para>Only one filter rule is needed for FTP if the
	  <acronym>NAT</acronym> FTP proxy is used.</para>

	<para>Without the FTP proxy, the following three rules will be
	  needed:</para>

	<programlisting># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="firewalls-ipfw">
    <title>IPFW</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>IPFW</secondary>
    </indexterm>

    <para><acronym>IPFW</acronym>) is a stateful firewall written for
      &os; which also provides a traffic shaper, packet scheduler,
      and in-kernel NAT.</para>

    <para>&os; provides a sample ruleset in
      <filename>/etc/rc.firewall</filename>.  The sample ruleset
      define several firewall types for common scenarios to assist
      novice users in generating an appropriate ruleset.
      &man.ipfw.8; provides a powerful syntax which advanced users can
      use to craft customized rulesets that meet the security
      requirements of a given environment.</para>

    <para>IPFW is composed of several components:  the kernel firewall
      filter rule processor and its integrated packet accounting
      facility, the logging facility, the
      <literal>divert</literal> rule which triggers
      <acronym>NAT</acronym>, the dummynet traffic shaper facilities,
      the <literal>fwd rule</literal> forward facility, the bridge
      facility, and the ipstealth facility.  IPFW supports both IPv4
      and IPv6.</para>

    <sect2 id="firewalls-ipfw-enable">
      <title>Enabling IPFW</title>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>enabling</secondary>
      </indexterm>

      <para>IPFW is included in the basic &os; install as a run time
	loadable module.  The system will dynamically load the kernel
	module when <filename>rc.conf</filename> contains the
	statement <literal>firewall_enable="YES"</literal>.  After
	rebooting the system, the following white highlighted message
	is displayed on the screen as part of the boot process:</para>

      <screen>ipfw2 initialized, divert disabled, rule-based forwarding disabled, default to deny, logging disabled</screen>

      <para>The loadable module includes logging ability.  To enable
	logging and set the verbose logging limit, add these
	statements to
	<filename>/etc/sysctl.conf</filename> before rebooting:</para>

      <programlisting>net.inet.ip.fw.verbose=1
net.inet.ip.fw.verbose_limit=5</programlisting>
    </sect2>

    <sect2 id="firewalls-ipfw-kernel">
      <title>Kernel Options</title>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL_VERBOSE</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL_VERBOSE_LIMIT</secondary>
      </indexterm>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>kernel options</secondary>
      </indexterm>

      <para>For those users who wish to statically compile kernel
	IPFW support, the following options are available for the
	custom kernel configuration file:</para>

      <programlisting>options    IPFIREWALL</programlisting>

      <para>This option enables IPFW as part of the kernel.</para>

      <programlisting>options    IPFIREWALL_VERBOSE</programlisting>

      <para>This option enables logging of packets that pass through
	IPFW and have the <literal>log</literal> keyword specified in
	the ruleset.</para>

      <programlisting>options    IPFIREWALL_VERBOSE_LIMIT=5</programlisting>

      <para>This option limits the number of packets logged through
	&man.syslogd.8;, on a per-entry basis.  This option may be
	used in hostile environments, when firewall activity logging
	is desired.  This will close a possible denial of service
	attack via syslog flooding.</para>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL_DEFAULT_TO_ACCEPT</secondary>
      </indexterm>

      <programlisting>options    IPFIREWALL_DEFAULT_TO_ACCEPT</programlisting>

      <para>This option allows everything to pass through the firewall
	by default, which is a good idea when the firewall is being
	set up for the first time.</para>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPDIVERT</secondary>
      </indexterm>

      <programlisting>options    IPDIVERT</programlisting>

      <para>This option enables the use of <acronym>NAT</acronym>
	functionality.</para>

      <note>
	<para>The firewall will block all incoming and outgoing
	  packets if either the
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal> kernel
	  option or a rule to explicitly allow these connections is
	  missing.</para>
      </note>
    </sect2>

    <sect2 id="firewalls-ipfw-rc">
      <title><filename>/etc/rc.conf</filename> Options</title>

      <para>Enables the firewall:</para>

      <programlisting>firewall_enable="YES"</programlisting>

      <para>To select one of the default firewall types provided by
	&os;, select one by reading
	<filename>/etc/rc.firewall</filename> and specify it in
	the following:</para>

      <programlisting>firewall_type="open"</programlisting>

      <para>Available values for this setting are:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>open</literal>: passes all traffic.</para>
	</listitem>
	<listitem>
	  <para><literal>client</literal>: protects only this
	    machine.</para>
	</listitem>
	<listitem>
	  <para><literal>simple</literal>: protects the whole
	    network.</para>
	</listitem>
	<listitem>
	  <para><literal>closed</literal>: entirely disables IP
	    traffic except for the loopback interface.</para>
	</listitem>
	<listitem>
	  <para><literal>UNKNOWN</literal>: disables the loading of
	    firewall rules.</para>
	</listitem>
	<listitem>
	  <para><filename><replaceable>filename</replaceable></filename>:
	    absolute path of the file containing the firewall
	    rules.</para>
	</listitem>
      </itemizedlist>

      <para>Two methods are available for loading custom
	<application>ipfw</application> rules.  One is to set the
	<literal>firewall_type</literal> variable to the absolute
	path of the file which contains the firewall rules.</para>

      <para>The other method is to set the
	<literal>firewall_script</literal> variable to the absolute
	path of an executable script that includes
	<command>ipfw</command> commands.  A ruleset script that
	blocks all incoming and outgoing traffic would look like
	this:</para>

      <programlisting>#!/bin/sh

ipfw -q flush

ipfw add deny in
ipfw add deny out</programlisting>

      <note>
	<para>If <literal>firewall_type</literal> is set to either
	  <literal>client</literal> or <literal>simple</literal>,
	  modify the default rules found in
	  <filename>/etc/rc.firewall</filename> to fit the
	  configuration of the system.  The examples used in this
	  section assume that the <literal>firewall_script</literal>
	  is set to <filename>/etc/ipfw.rules</filename>.</para>
      </note>

      <para>Enable logging:</para>

      <programlisting>firewall_logging="YES"</programlisting>

      <warning>
	<para><varname>firewall_logging</varname> sets the
	  <varname>net.inet.ip.fw.verbose</varname> sysctl
	  variable to the value of <literal>1</literal>.  There is no
	  <filename>rc.conf</filename> variable to set log
	  limitations, but the desired value can be set using
	  <command>sysctl</command> or by adding the following
	  variable and desired value to
	  <filename>/etc/sysctl.conf</filename>:</para>

	<programlisting>net.inet.ip.fw.verbose_limit=5</programlisting>
      </warning>

      <para>If the machine is acting as a gateway providing
	<acronym>NAT</acronym> using &man.natd.8;,
	refer to <link linkend="network-natd"></link> for information
	regarding the required <filename>/etc/rc.conf</filename>
	options.</para>
    </sect2>

    <sect2 id="firewalls-ipfw-cmd">
      <title>The IPFW Command</title>

      <indexterm><primary><command>ipfw</command></primary></indexterm>

      <para><command>ipfw</command> can be used to make manual,
	single rule additions or deletions to the active firewall
	while it is running.  The problem with using this method is
	that all the changes are lost when the system reboots.  It is
	recommended to instead write all the rules in a file and to
	use that file to load the rules at boot time and to replace
	the currently running firewall rules whenever that file
	changes.</para>

      <para><command>ipfw</command> is a useful way to display the
	running firewall rules to the console screen.  The IPFW
	accounting facility dynamically creates a counter for each
	rule that counts each packet that matches the rule.  During
	the process of testing a rule, listing the rule with its
	counter is one way to determine if the rule is
	functioning as expected.</para>

      <para>To list all the running rules in sequence:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>To list all the running rules with a time stamp of when
	the last time the rule was matched:</para>

      <screen>&prompt.root; <userinput>ipfw -t list</userinput></screen>

      <para>The next example lists accounting information and the
	packet count for matched rules along with the rules
	themselves.  The first column is the rule number, followed by
	the number of outgoing matched packets, followed by the number
	of incoming matched packets, followed by the rule
	itself.</para>

      <screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

      <para>To list dynamic rules in addition to static rules:</para>

      <screen>&prompt.root; <userinput>ipfw -d list</userinput></screen>

      <para>To also show the expired dynamic rules:</para>

      <screen>&prompt.root; <userinput>ipfw -d -e list</userinput></screen>

      <para>To zero the counters:</para>

      <screen>&prompt.root; <userinput>ipfw zero</userinput></screen>

      <para>To zero the counters for just the rule with number
	<replaceable>NUM</replaceable>:</para>

      <screen>&prompt.root; <userinput>ipfw zero <replaceable>NUM</replaceable></userinput></screen>
    </sect2>

    <sect2 id="firewalls-ipfw-rules">
      <title>IPFW Rulesets</title>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>rule processing order</secondary>
      </indexterm>

      <para>When a packet enters the <acronym>IPFW</acronym> firewall,
	it is compared against the first rule in the ruleset and
	progresses one rule at a time, moving from top to bottom of
	the set in ascending rule number sequence order.  When the
	packet matches the selection parameters of a rule, the rule's
	action field value is executed and the search of the ruleset
	terminates for that packet.  This is referred to as
	<quote>first match wins</quote>.  If the packet does not match
	any of the rules, it gets caught by the mandatory IPFW default
	rule, number 65535, which denies all packets and silently
	discards them.  However, if the packet matches a rule that
	contains the <literal>count</literal>,
	<literal>skipto</literal>, or <literal>tee</literal> keywords,
	the search continues.  Refer to &man.ipfw.8; for details on
	how these keywords affect rule processing.</para>

      <para>The examples in this section create an inclusive type
	firewall ruleset containing the stateful <literal>keep
	  state</literal>, <literal>limit</literal>,
	<literal>in</literal>, <literal>out</literal> and
	<literal>via</literal> options.  For a complete rule syntax
	description, refer to &man.ipfw.8;.</para>

      <warning>
	<para>Be careful when working with firewall rules, as it is
	  easy to lock out even the administrator.</para>
      </warning>

      <sect3 id="firewalls-ipfw-rules-syntax">
	<title>Rule Syntax</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>rule syntax</secondary>
	</indexterm>

	<para>This section describes the keywords which comprise an
	  <acronym>IPFW</acronym> rule.  Keywords must be written in
	  the following order.  <literal>#</literal> is used to mark
	  the start of a comment and may appear at the end of a rule
	  line or on its own line.  Blank lines are ignored.</para>

	<para><replaceable>CMD RULE_NUMBER ACTION LOGGING SELECTION
	    STATEFUL</replaceable></para>

	<sect4>
	  <title>CMD</title>

	  <para>Each new rule has to be prefixed with
	    <parameter>add</parameter> to add the rule to the internal
	    table.</para>
	</sect4>

	<sect4>
	  <title>RULE_NUMBER</title>

	  <para>Each rule is associated with a rule_number in the
	    range of <literal>1</literal> to
	    <literal>65535</literal>.</para>
	</sect4>

	<sect4>
	  <title>ACTION</title>

	  <para>A rule can be associated with one of the following
	    actions.  The specified action will be executed when the
	    packet matches the selection criterion of the rule.</para>

	  <para><parameter>allow | accept | pass |
	      permit</parameter></para>

	  <para>These keywords are equivalent as they allow packets
	    that match the rule to exit the firewall rule processing.
	    The search terminates at this rule.</para>

	  <para><parameter>check-state</parameter></para>

	  <para>Checks the packet against the dynamic rules table.
	    If a match is found, execute the action associated with
	    the rule which generated this dynamic rule, otherwise
	    move to the next rule.  A <literal>check-state</literal>
	    rule does not have selection criterion.  If no
	    <literal>check-state</literal> rule is present in the
	    ruleset, the dynamic rules table is checked at the first
	    <literal>keep-state</literal> or <literal>limit</literal>
	    rule.</para>

	  <para><parameter>deny | drop</parameter></para>

	  <para>Both words mean the same thing, which is to discard
	    packets that match this rule.  The search
	    terminates.</para>
	</sect4>

	<sect4>
	  <title>Logging</title>

	  <para>When a packet matches a rule with the
	    <literal>log</literal> keyword, a message will be logged
	    to &man.syslogd.8; with a facility name of
	    <literal>SECURITY</literal>.  Logging only occurs if the
	    number of packets logged for that particular rule does not
	    exceed the <literal>logamount</literal> parameter.  If no
	    <literal>logamount</literal> is specified, the limit is
	      taken from the <command>sysctl</command> value of
	    <varname>net.inet.ip.fw.verbose_limit</varname>.  In both
	    cases, a value of zero removes the logging limit.  Once
	    the limit is reached, logging can be re-enabled by
	    clearing the logging counter or the packet counter for
	    that rule, using <command>ipfw reset log</command>.</para>

	  <note>
	    <para>Logging is done after all other packet matching
	      conditions have been met, and before performing the
	      final action on the packet.  The administrator decides
	      which rules to enable logging on.</para>
	  </note>
	</sect4>

	<sect4>
	  <title>Selection</title>

	  <para>The keywords described in this section are used to
	    describe attributes of the packet to be checked when
	    determining whether rules match the packet or not.
	    The following general-purpose attributes are provided for
	    matching, and must be used in this order:</para>

	  <para><parameter>udp | tcp | icmp</parameter></para>

	  <para>Any other protocol names found in
	    <filename>/etc/protocols</filename> can be used.  The
	    value specified is the protocol to be matched against.
	    This is a mandatory keyword.</para>

	  <para><parameter>from src to dst</parameter></para>

	  <para>The <literal>from</literal> and <literal>to</literal>
	    keywords are used to match against IP addresses.  Rules
	    must specify <emphasis>both</emphasis> source and
	    destination parameters.  <literal>any</literal> is a
	    special keyword that matches any IP address.
	    <literal>me</literal> is a special keyword that matches
	    any IP address configured on an interface in the &os;
	    system to represent the PC the firewall is running on.
	    Example usage includes <literal>from me to any</literal>,
	    <literal>from any to me</literal>, <literal>from 0.0.0.0/0
	      to any</literal>, <literal>from any to
	      0.0.0.0/0</literal>, <literal>from 0.0.0.0 to
	      any</literal>. <literal>from any to 0.0.0.0</literal>,
	    and <literal>from me to 0.0.0.0</literal>.  IP addresses
	    are specified in dotted IP address format followed by the
	    mask in CIDR notation, or as a single host in dotted IP
	    address format.  This keyword is a mandatory requirement.
	    The <filename role="package">net-mgmt/ipcalc</filename>
	    port may be used to assist the mask calculation.</para>

	  <para><parameter>port number</parameter></para>

	  <para>For protocols which support port numbers, such as
	    <acronym>TCP</acronym> and <acronym>UDP</acronym>, it
	    is mandatory to include the port number of the service
	    that will be matched. Service names from
	    <filename>/etc/services</filename> may be used instead
	    of numeric port values.</para>

	  <para><parameter>in | out</parameter></para>

	  <para>Matches incoming or outgoing packets.  It is mandatory
	    that one or the other is included as part of the rule
	    matching criterion.</para>

	  <para><parameter>via IF</parameter></para>

	  <para>Matches packets going through the interface specified
	    by device name.  The <literal>via</literal> keyword causes
	    the interface to always be checked as part of the match
	    process.</para>

	  <para><parameter>setup</parameter></para>

	  <para>This mandatory keyword identifies the session start
	    request for <acronym>TCP</acronym> packets.</para>

	  <para><parameter>keep-state</parameter></para>

	  <para>This is a mandatory keyword.  Upon a match, the
	    firewall will create a dynamic rule, whose default
	    behavior is to match bidirectional traffic between source
	    and destination IP/port using the same protocol.</para>

	  <para><parameter>limit {src-addr | src-port | dst-addr |
	      dst-port}</parameter></para>

	  <para>The firewall will only allow
	    <replaceable>N</replaceable> connections with the same
	    set of parameters as specified in the rule.  One or more
	    of source and destination addresses and ports can be
	    specified.  <literal>limit</literal> and
	    <literal>keep-state</literal> can not be used on the same
	    rule as they provide the same stateful function.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Stateful Rule Option</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>stateful filtering</secondary>
	</indexterm>

	<para>The <literal>check-state</literal> option is used to
	  identify where in the IPFW ruleset the packet is to be
	  tested against the dynamic rules facility.  On a match, the
	  packet exits the firewall to continue on its way and a new
	  rule is dynamically created for the next anticipated packet
	  being exchanged during this session.  On a no match, the
	  packet advances to the next rule in the ruleset for
	  testing.</para>

	<para>The dynamic rules facility is vulnerable to resource
	  depletion from a SYN-flood attack which would open a huge
	  number of dynamic rules.  To counter this type of attack
	  with  <acronym>IPFW</acronym>, use <literal>limit</literal>.
	  This keyword limits the number of simultaneous sessions by
	  checking that rule's source or destinations fields and using
	  the packet's IP address in a search of the open dynamic
	  rules, counting the number of times this rule and IP address
	  combination occurred.  If this count is greater than the
	  value specified by <literal>limit</literal>, the packet is
	  discarded.</para>
      </sect3>

      <sect3>
	<title>Logging Firewall Messages</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>logging</secondary>
	</indexterm>

	<para>Even with the logging facility enabled, IPFW will not
	  generate any rule logging on its own.  The firewall
	  administrator decides which rules in the ruleset will be
	  logged, and adds the <literal>log</literal> keyword to those
	  rules.  Normally only deny rules are logged.  It is
	  customary to duplicate the <quote>ipfw default deny
	    everything</quote> rule with the <literal>log</literal>
	  keyword included as the last rule in the ruleset.  This
	  way, it is possible to see all the packets that did not
	  match any of the rules in the ruleset.</para>

	<para>Logging is a two edged sword.  If one is not careful,
	  an over abundance of log data or a DoS attack can fill the
	  disk with log files.  Log messages are not only written to
	  <application>syslogd</application>, but also are displayed
	  on the root console screen and soon become annoying.</para>

	<para>The <literal>IPFIREWALL_VERBOSE_LIMIT=5</literal>
	  kernel option limits the number of consecutive messages
	  sent to &man.syslogd.8;, concerning the packet matching of a
	  given rule.  When this option is enabled in the kernel, the
	  number of consecutive messages concerning a particular rule
	  is capped at the number specified.  There is nothing to be
	  gained from 200 identical log messages.  With this option
	  set to five,
	  five consecutive messages concerning a particular rule
	  would be logged to <application>syslogd</application> and
	  the remainder identical consecutive messages would be
	  counted and posted to <application>syslogd</application>
	  with a phrase like the following:</para>

	<programlisting>last message repeated 45 times</programlisting>

	<para>All logged packets messages are written by default to
	  <filename>/var/log/security</filename>, which is
	  defined in <filename>/etc/syslog.conf</filename>.</para>
      </sect3>

      <sect3 id="firewalls-ipfw-rules-script">
	<title>Building a Rule Script</title>

	<para>Most experienced IPFW users create a file containing
	  the rules and code them in a manner compatible with running
	  them as a script.  The major benefit of doing this is the
	  firewall rules can be refreshed in mass without the need
	  of rebooting the system to activate them.  This method is
	  convenient in testing new rules as the procedure can
	  be executed as many times as needed.  Being a script,
	  symbolic substitution can be used for frequently used
	  values to be substituted into multiple rules.</para>

	<para>This example script is compatible with the syntax used
	  by the &man.sh.1;,  &man.csh.1;, and &man.tcsh.1; shells.
	  Symbolic substitution fields are prefixed with a dollar sign
	  (&dollar;).  Symbolic fields do not have the &dollar;
	  prefix.  The value to populate the symbolic field must be
	  enclosed in double quotes ("").</para>

	<para>Start the rules file like this:</para>

	<programlisting>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
&dollar;cmd 00500 check-state
&dollar;cmd 00502 deny all from any to any frag
&dollar;cmd 00501 deny tcp from any to any established
&dollar;cmd 00600 allow tcp from any to any 80 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00610 allow tcp from any to &dollar;odns 53 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00611 allow udp from any to &dollar;odns 53 out via &dollar;oif &dollar;ks
################### End of example ipfw rules script ############</programlisting>

	<para>The rules are not important as the focus of this example
	  is how the symbolic substitution fields are
	  populated.</para>

	<para>If the above example was in
	  <filename>/etc/ipfw.rules</filename>, the rules could be
	  reloaded by the following command:</para>

	<screen>&prompt.root; <userinput>sh /etc/ipfw.rules</userinput></screen>

	<para><filename>/etc/ipfw.rules</filename> can be located
	  anywhere and the file can have any name.</para>

	<para>The same thing could be accomplished by running these
	  commands by hand:</para>

	<screen>&prompt.root; <userinput>ipfw -q -f flush</userinput>
&prompt.root; <userinput>ipfw -q add check-state</userinput>
&prompt.root; <userinput>ipfw -q add deny all from any to any frag</userinput>
&prompt.root; <userinput>ipfw -q add deny tcp from any to any established</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</userinput></screen>
      </sect3>

      <sect3>
	<title>An Example Stateful Ruleset</title>

	<para>The following sample ruleset is a complete inclusive
	  type ruleset.  Comment out any
	  <literal>pass</literal> rules for services that are not
	  required.  To avoid logging undesired messages, add a
	  <literal>deny</literal> rule in the inbound section.
	  Change the <devicename>dc0</devicename> in every rule to the
	  device name of the interface that connects the system to the
	  Internet.</para>

	<para>There is a noticeable pattern in the usage of these
	  rules.</para>

	<itemizedlist>
	  <listitem>
	    <para>All statements that are a request to start a session
	      to the Internet use
	      <literal>keep-state</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>All the authorized services that originate from
	      the Internet use <literal>limit</literal> to prevent
	      flooding.</para>
	  </listitem>

	  <listitem>
	    <para>All rules use <literal>in</literal> or
	      <literal>out</literal> to clarify direction.</para>
	  </listitem>

	  <listitem>
	    <para>All rules use <literal>via</literal>
	      <replaceable>interface-name</replaceable> to specify
	      the interface the packet is traveling over.</para>
	  </listitem>
	</itemizedlist>

	<para>The following rules go into
	  <filename>/etc/ipfw.rules</filename>:</para>

	<programlisting>################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN.
# Change xl0 to your LAN NIC interface name
#################################################################
#&dollar;cmd 00005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
&dollar;cmd 00010 allow all from any to any via lo0

#################################################################
# Allow the packet through if it has previous been added to the
# the "dynamic" rules table by a allow keep-state statement.
#################################################################
&dollar;cmd 00015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Interrogate session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# x.x.x.x must be the IP address of your ISP.s DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
&dollar;cmd 00110 allow tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state
&dollar;cmd 00111 allow udp from any to x.x.x.x 53 out via &dollar;pif keep-state

# Allow out access to my ISP's DHCP server for cable/DSL configurations.
# This rule is not needed for .user ppp. connection to the public Internet.
# so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
&dollar;cmd 00120 allow log udp from any to any 67 out via &dollar;pif keep-state
#&dollar;cmd 00120 allow udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow out non-secure standard www function
&dollar;cmd 00200 allow tcp from any to any 80 out via &dollar;pif setup keep-state

# Allow out secure www function https over TLS SSL
&dollar;cmd 00220 allow tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow out send &amp; get email function
&dollar;cmd 00230 allow tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 00231 allow tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow out FBSD (make install &amp; CVSUP) functions
# Basically give user root "GOD" privileges.
&dollar;cmd 00240 allow tcp from me to any out via &dollar;pif setup keep-state uid root

# Allow out ping
&dollar;cmd 00250 allow icmp from any to any out via &dollar;pif keep-state

# Allow out Time
&dollar;cmd 00260 allow tcp from any to any 37 out via &dollar;pif setup keep-state

# Allow out nntp news (i.e., news groups)
&dollar;cmd 00270 allow tcp from any to any 119 out via &dollar;pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
&dollar;cmd 00280 allow tcp from any to any 22 out via &dollar;pif setup keep-state

# Allow out whois
&dollar;cmd 00290 allow tcp from any to any 43 out via &dollar;pif setup keep-state

# deny and log everything else that.s trying to get out.
# This rule enforces the block all by default logic.
&dollar;cmd 00299 deny log all from any to any out via &dollar;pif

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 00300 deny all from 192.168.0.0/16 to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 00301 deny all from 172.16.0.0/12 to any in via &dollar;pif     #RFC 1918 private IP
&dollar;cmd 00302 deny all from 10.0.0.0/8 to any in via &dollar;pif          #RFC 1918 private IP
&dollar;cmd 00303 deny all from 127.0.0.0/8 to any in via &dollar;pif        #loopback
&dollar;cmd 00304 deny all from 0.0.0.0/8 to any in via &dollar;pif            #loopback
&dollar;cmd 00305 deny all from 169.254.0.0/16 to any in via &dollar;pif   #DHCP auto-config
&dollar;cmd 00306 deny all from 192.0.2.0/24 to any in via &dollar;pif       #reserved for docs
&dollar;cmd 00307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster interconnect
&dollar;cmd 00308 deny all from 224.0.0.0/3 to any in via &dollar;pif         #Class D &amp; E multicast

# Deny public pings
&dollar;cmd 00310 deny icmp from any to any in via &dollar;pif

# Deny ident
&dollar;cmd 00315 deny tcp from any to any 113 in via &dollar;pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
&dollar;cmd 00320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 00321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 00322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 00323 deny tcp from any to any 81 in via &dollar;pif

# Deny any late arriving packets
&dollar;cmd 00330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 00332 deny tcp from any to any established in via &dollar;pif

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP.s DHCP server as it.s the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for .user ppp. type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
#&dollar;cmd 00360 allow udp from any to x.x.x.x 67 in via &dollar;pif keep-state

# Allow in standard www function because I have apache server
&dollar;cmd 00400 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
&dollar;cmd 00410 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
&dollar;cmd 00420 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Reject &amp; Log all incoming connections from the outside
&dollar;cmd 00499 deny log all from any to any in via &dollar;pif

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
&dollar;cmd 00999 deny log all from any to any
################ End of IPFW rules file ###############################</programlisting>
      </sect3>

      <sect3>
	<title>An Example <acronym>NAT</acronym> and Stateful
	  Ruleset</title>

	<indexterm>
	  <primary>NAT</primary>

	  <secondary>and IPFW</secondary>
	</indexterm>

	<para>There are some additional configuration statements that
	  need to be enabled to activate the <acronym>NAT</acronym>
	  function of IPFW.  For a customized kernel, the kernel
	  configuration file needs
	  <literal>option IPDIVERT</literal> added to the other
	  <literal>IPFIREWALL</literal> options.</para>

	<para>In addition to the normal IPFW options in
	  <filename>/etc/rc.conf</filename>, the following are
	  needed:</para>

	<programlisting>natd_enable="YES"                   # Enable <acronym>NAT</acronym>D function
natd_interface="rl0"                # interface name of public Internet NIC
natd_flags="-dynamic -m"            # -m = preserve port numbers if possible</programlisting>

	<para>Utilizing stateful rules with a
	  <literal>divert natd</literal> rule complicates the ruleset
	  logic.  The positioning of the
	  <literal>check-state</literal>, and
	  <literal>divert natd</literal> rules in the ruleset is
	  critical and a new action type is used, called
	  <literal>skipto</literal>.  When using
	  <literal>skipto</literal>, it is mandatory that each rule is
	  numbered, so that the <literal>skipto</literal> rule knows
	  which rule to jump to.</para>

	<para>The following is an uncommented example of a ruleset
	  which explains the sequence of the packet flow.</para>

	<para>The processing flow starts with the first rule from the
	  top of the ruleset and progresses one rule at a time until
	  the end is reached or the packet matches and the packet is
	  released out of the firewall.  Take note of the location of
	  rule numbers 100 101, 450, 500, and 510.  These rules
	  control the translation of the outbound and inbound packets
	  so that their entries in the dynamic keep-state table always
	  register the private LAN IP address.  All the allow and deny
	  rules specify the direction of the packet and the interface.
	  All start outbound session requests will
	  <literal>skipto rule 500</literal> to undergo NAT.</para>

	<para>Consider a web browser which initializes a new HTTP
	  session over port 80.  When the first outbound packet enters
	  the firewall, it does not match rule 100 because it is
	  headed out rather than in.  It passes rule 101 because this
	  is the first packet, and it has not been posted to the
	  dynamic keep-state table yet.  The packet finally matches
	  rule 125 as it is outbound through the NIC facing the
	  Internet and has a source IP address as a private LAN IP
	  address.  On matching this rule, two actions take place.
	  <literal>keep-state</literal> adds this rule to the dynamic
	  keep-state rules table and the specified action is executed
	  and posted as part of the info in the dynamic table.  In
	  this case, the action is <literal>skipto rule 500</literal>.
	  Rule 500 <acronym>NAT</acronym>s the packet IP address and
	  sends it out to the Internet.  This packet makes its way to
	  the destination web server, where a response packet is
	  generated and sent back.  This new packet enters the top of
	  the ruleset.  It matches rule 100 and has it destination IP
	  address mapped back to the corresponding LAN IP address.  It
	  then is processed by the <literal>check-state</literal>
	  rule, is found in the table as an existing session, and is
	  released to the LAN.  It goes to the LAN system that sent it
	  and a new packet is sent requesting another segment of the
	  data from the remote server.  This time it matches the
	  <literal>check-state</literal> rule, its outbound entry is
	  found,  and the associated action,
	  <literal>skipto 500</literal>, is executed.  The packet
	  jumps to rule 500, gets <acronym>NAT</acronym>ed, and is
	  released to the Internet.</para>

	<para>On the inbound side, everything coming in that is part
	  of an existing session is automatically handled by the
	  <literal>check-state</literal> rule and the properly placed
	  <literal>divert natd</literal> rules.  The ruleset only has
	  to deny bad packets and allow only authorized services.
	  Consider a web server running on the firewall where web
	  requests from the Internet should have access to the local
	  web site.  An inbound start request packet will match rule
	  100 and its IP address will be mapped to the LAN IP address
	  of the firewall.  The packet is then matched against all the
	  nasty things that need to be checked and finally matches
	  rule 425 where two actions occur.  The packet rule is posted
	  to the dynamic keep-state table but this time, any new
	  session requests originating from that source IP address are
	  limited to 2.  This defends against DoS attacks against the
	  service running on the specified port number.  The action is
	  <literal>allow</literal>, so the packet is released to the
	  LAN. The packet generated as a response is recognized by the
	  <literal>check-state</literal> as belonging to an existing
	  session.  It is then sent to rule 500 for
	  <acronym>NAT</acronym>ing and released to the outbound
	  interface.</para>

	<para>Example Ruleset #1:</para>

	<programlisting>#!/bin/sh
cmd="ipfw -q add"
skip="skipto 500"
pif=rl0
ks="keep-state"
good_tcpo="22,25,37,43,53,80,443,110,119"

ipfw -q -f flush

&dollar;cmd 002 allow all from any to any via xl0  # exclude LAN traffic
&dollar;cmd 003 allow all from any to any via lo0  # exclude loopback traffic

&dollar;cmd 100 divert natd ip from any to any in via &dollar;pif
&dollar;cmd 101 check-state

# Authorized outbound packets
&dollar;cmd 120 &dollar;skip udp from any to xx.168.240.2 53 out via &dollar;pif &dollar;ks
&dollar;cmd 121 &dollar;skip udp from any to xx.168.240.5 53 out via &dollar;pif &dollar;ks
&dollar;cmd 125 &dollar;skip tcp from any to any &dollar;good_tcpo out via &dollar;pif setup &dollar;ks
&dollar;cmd 130 &dollar;skip icmp from any to any out via &dollar;pif &dollar;ks
&dollar;cmd 135 &dollar;skip udp from any to any 123 out via &dollar;pif &dollar;ks


# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #loopback
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #loopback
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP auto-config
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #reserved for docs
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #Class D &amp; E multicast

# Authorized inbound packets
&dollar;cmd 400 allow udp from xx.70.207.54 to any 68 in &dollar;ks
&dollar;cmd 420 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 1


&dollar;cmd 450 deny log ip from any to any

# This is skipto location for outbound stateful rules
&dollar;cmd 500 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 510 allow ip from any to any

######################## end of rules  ##################</programlisting>

	<para>The next example is functionally equivalent, but uses
	  descriptive comments to help the inexperienced IPFW rule
	  writer to better understand what the rules are doing.</para>

	<para>Example Ruleset #2:</para>

	<programlisting>#!/bin/sh
################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
skip="skipto 800"
pif="rl0"     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Change xl0 to your LAN NIC interface name
#################################################################
&dollar;cmd 005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
&dollar;cmd 010 allow all from any to any via lo0

#################################################################
# check if packet is inbound and nat address if it is
#################################################################
&dollar;cmd 014 divert natd ip from any to any in via &dollar;pif

#################################################################
# Allow the packet through if it has previous been added to the
# the "dynamic" rules table by a allow keep-state statement.
#################################################################
&dollar;cmd 015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Check session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# x.x.x.x must be the IP address of your ISP's DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
&dollar;cmd 020 &dollar;skip tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state


# Allow out access to my ISP's DHCP server for cable/DSL configurations.
&dollar;cmd 030 &dollar;skip udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow out non-secure standard www function
&dollar;cmd 040 &dollar;skip tcp from any to any 80 out via &dollar;pif setup keep-state

# Allow out secure www function https over TLS SSL
&dollar;cmd 050 &dollar;skip tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow out send &amp; get email function
&dollar;cmd 060 &dollar;skip tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 061 &dollar;skip tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow out FreeBSD (make install &amp; CVSUP) functions
# Basically give user root "GOD" privileges.
&dollar;cmd 070 &dollar;skip tcp from me to any out via &dollar;pif setup keep-state uid root

# Allow out ping
&dollar;cmd 080 &dollar;skip icmp from any to any out via &dollar;pif keep-state

# Allow out Time
&dollar;cmd 090 &dollar;skip tcp from any to any 37 out via &dollar;pif setup keep-state

# Allow out nntp news (i.e., news groups)
&dollar;cmd 100 &dollar;skip tcp from any to any 119 out via &dollar;pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
&dollar;cmd 110 &dollar;skip tcp from any to any 22 out via &dollar;pif setup keep-state

# Allow out whois
&dollar;cmd 120 &dollar;skip tcp from any to any 43 out via &dollar;pif setup keep-state

# Allow ntp time server
&dollar;cmd 130 &dollar;skip udp from any to any 123 out via &dollar;pif keep-state

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #loopback
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #loopback
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP auto-config
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #reserved for docs
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #Class D &amp; E multicast

# Deny ident
&dollar;cmd 315 deny tcp from any to any 113 in via &dollar;pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
&dollar;cmd 320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 323 deny tcp from any to any 81  in via &dollar;pif

# Deny any late arriving packets
&dollar;cmd 330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 332 deny tcp from any to any established in via &dollar;pif

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it is the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for 'user ppp' type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
&dollar;cmd 360 allow udp from x.x.x.x to any 68 in via &dollar;pif keep-state

# Allow in standard www function because I have Apache server
&dollar;cmd 370 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
&dollar;cmd 380 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
&dollar;cmd 390 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Reject &amp; Log all unauthorized incoming connections from the public Internet
&dollar;cmd 400 deny log all from any to any in via &dollar;pif

# Reject &amp; Log all unauthorized out going connections to the public Internet
&dollar;cmd 450 deny log all from any to any out via &dollar;pif

# This is skipto location for outbound stateful rules
&dollar;cmd 800 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 801 allow ip from any to any

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
&dollar;cmd 999 deny log all from any to any
################ End of IPFW rules file ###############################</programlisting>
      </sect3>
    </sect2>
  </sect1>
</chapter>
