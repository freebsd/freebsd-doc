<!--
     The FreeBSD Mongolian Documentation Project

     Original revision 1.253

     $FreeBSD$
-->

<chapter id="updating-upgrading">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Жим</firstname>
	<surname>Мок</surname>
	<contrib>Бүтцийг дахин өөрчлөн зохион байгуулж зарим хэсгүүдийг шинэчилсэн </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Жордан</firstname>
	<surname>Хаббард</surname>
	<contrib>Анхлан эхийг бичсэн </contrib>
      </author>
      <author>
	<firstname>Поул-Хэннинг</firstname>
	<surname>Камп</surname>
      </author>
      <author>
	<firstname>Жон</firstname>
	<surname>Полстра</surname>
      </author>
      <author>
	<firstname>Ник</firstname>
	<surname>Клэйтон</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
    <authorgroup>
      <author>
	<firstname>Цагаанхүүгийн</firstname>
	<surname>Ганболд</surname>
	<contrib>Орчуулсан  </contrib>
 	<!-- Nov 2006 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>&os;-г шинэчилж сайжруулах нь</title>

  <sect1 id="updating-upgrading-synopsis">
    <title>Ерөнхий агуулга</title>

    <para>&os; нь өөрийн хувилбаруудын хооронд байнгын хөгжүүлэлтийн доор оршин тогтнож 
      байдаг. Зарим хүмүүс албан ёсоор гаргасан хувилбаруудыг ашиглах хүсэлтэй 
      байдаг бол зарим хүмүүс хамгийн сүүлийн үеийн хөгжүүлэлтийг дагах сонирхолтой 
      байдаг. Гэхдээ албан ёсны хувилбарууд хүртэл аюулгүй байдлын болоод бусад 
      чухал засваруудаар шинэчлэгдэж байдаг. Ямар хувилбар ашиглаж байгаагаас үл 
      хамаараад &os; нь таны системийг шинэ байлгахад шаардлагатай бүх л хэрэгслүүд
      болон хувилбар хооронд хялбараар шинэчлэх боломжоор хангадаг.
      Энэхүү бүлэг нь хөгжүүлэлтийн системийг дагахыг хүсэх эсвэл гаргасан 
      хувилбартай үлдэх эсэхийг шийдэхэд танд туслах болно. Таны системийг шинэчлэхэд 
      зориулсан үндсэн хэрэгслүүдийг бас харуулах болно.</para>

    <para>Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:</para>

    <itemizedlist>
      <listitem><para>Систем болон портын цуглуулгыг ямар хэрэгслүүд 
	  ашиглан шинэчилж болох талаар.</para>
      </listitem>
      <listitem><para>
	  <application>freebsd-update</application>,
	  <application>CVSup</application>,
	  <application>CVS</application>, эсвэл 
	  <application>CTM</application> програмуудын тусламжтай өөрийн системийг 
		хэрхэн хамгийн сүүлийн хэлбэрт авчрах талаар.</para>
      </listitem>

      <listitem>
	<para>Суулгагдсан системийн төлвийг мэдэгдэж байгаа сайн хуулбартай 
	  хэрхэн харьцуулах талаар.</para>
      </listitem>

      <listitem>
        <para><application>CVSup</application> эсвэл баримтжуулах порт ашиглан өөрийн баримтуудыг 
	  хэрхэн сүүлийн хувилбарт байлгаж байх талаар<!-- and
          <application>Docsnap</application>-->.</para>
      </listitem>

      <listitem>
	<para>&os.stable; болон &os.current; хөгжүүлэлтийн 
	  салбаруудын ялгаа.</para>
      </listitem>

      <listitem><para>Бүх үндсэн системийг <command>make buildworld</command> 
	(гэх мэт) ашиглан хэрхэн дахин бүтээж суулгах талаар.</para>
      </listitem>

    </itemizedlist>

    <para>Энэ бүлгийг уншихаасаа өмнө, та дараах зүйлсийг мэдэх шаардлагатай:</para>

    <itemizedlist>
      <listitem><para>Өөрийн сүлжээний холболтыг зөв тохируулах (<xref
      linkend="advanced-networking">).</para>
      </listitem>
      <listitem><para>Нэмэлт гуравдагч програм хангамжуудыг 
	хэрхэн суулгахыг мэдэх (<xref linkend="ports">).</para></listitem>
    </itemizedlist>

    <note>
      <para>Энэ бүлэгт &os;-ийн эхийг авч шинэчлэхийн тулд 
	<command>cvsup</command> тушаалыг ашиглагдсан. Үүнийг хэрэглэхийн 
	тулд <filename role="package">net/cvsup</filename> (хэрэв та график
	<command>cvsup</command> клиентийг суулгах хүсэлгүй байгаа бол 
	<filename>net/cvsup-without-gui</filename> портыг суулгаж болно)
	гэсэн порт буюу багцыг та суулгах хэрэгтэй. Үндсэн системийн 
	хэсэг болсон &man.csup.1; тушаалаар үүнийг орлуулж хэрэглэж болно.</para>
    </note>
  </sect1>
  
  <sect1 id="updating-upgrading-freebsdupdate">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Бичсэн </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Колин</firstname>
	  <surname>Персивал</surname>
	  <contrib>Тэмдэглэгээ бичсэн </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>FreeBSD-ийн шинэчлэлт</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>Аюулгүй байдлын засваруудыг хийнэ гэдэг компьютерийн програм 
      хангамж ялангуяа үйлдлийн системийг арчлалтын чухал хэсгийн нэг юм. 
      Удаан хугацааны туршид &os; дээр энэ процесс хялбар биш байлаа. 
      Засваруудыг эх код руу хийж кодыг хоёртын хэлбэр рүү дахин бүтээж 
      дараа нь хоёртын файлуудыг дахин суулгах шаардлагатай байлаа.</para>

    <para>Энэ нь одоо тийм биш болсон бөгөөд &os; нь 
      <command>freebsd-update</command> гэгддэг хэрэгслийг агуулдаг. 
      Энэ хэрэгсэл нь хоёр тусдаа функцээр хангадаг. Нэгдүгээрт энэ нь 
      бүтээлт болон суулгах шаардлагагүйгээр хоёртын аюулгүй байдал болон 
      алдааны шинэчлэлтүүдийг &os;-ийн үндсэн системд оруулах боломжийг 
      олгодог. Хоёрдугаарт уг хэрэгсэл бага болон том хувилбарын шинэчлэлтүүдийг 
      дэмждэг.</para>

    <note>
      <para>Аюулгүй байдлын багаар дэмжигдсэн бүх архитектур болон 
	хувилбаруудын хувьд хоёртын шинэчлэлтүүд байдаг. Шинэ хувилбар 
	руу шинэчлэхээс өмнө хүссэн хувилбарт чинь хамаатай чухал мэдээлэл байж 
	болох учир одоогийн хувилбарын зарлалуудыг дахин үзэх хэрэгтэй. Тэдгээр 
	зарлалуудыг дараах холбоосоос үзэж болно:
	<ulink url="http://www.FreeBSD.org/releases/"></ulink>.</para>
    </note>

    <para>Хэрэв <command>crontab</command> нь <command>freebsd-update</command>-ийн 
      боломжуудыг хэрэглэж байвал дараах үйлдлийг эхлэхээс өмнө түүнийг болиулах 
      хэрэгтэй.</para>

    <sect2 id="freebsdupdate-config-file">
      <title>Тохиргооны файл</title>

      <para>Процессийг илүү хянах боломжтой болгож зарим хэрэглэгчид 
	<filename>/etc/freebsd-update.conf</filename> анхны тохиргооны 
	файлыг өөрчлөхийг хүсэж болох юм. Тохиргоонууд нь 
	маш сайн баримтжуулагдсан байдаг боловч дараах хэдэн зүйлийг 
	арай илүү тайлбарлах шаардлагатай байж болох юм:</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>Энэ өгөгдөл нь &os;-ийн аль хэсгийг шинэчлэхийг хянадаг. 
	Анхдагчаар эх код, үндсэн систем бүтнээрээ ба цөмийг шинэчлэх 
	байдаг. Бүрэлдэхүүн хэсгүүд нь суулгах явцад байдагтай адил 
	байдаг бөгөөд жишээ нь <literal>world/games</literal> гэдгийг энд нэмэхэд 
	тоглоомын засваруудыг хийх боломжийг олгоно. <literal>src/bin</literal> гэдгийг 
	ашиглах нь <filename class="directory">src/bin</filename> 
	дахь эх кодыг шинэчлэх боломжийг олгодог.</para>

      <para>Хамгийн сайн тохиргоо бол үүнийг анхдагчаар нь үлдээх бөгөөд 
	тусгай зүйлс оруулж үүнийг өөрчилснөөр хэрэглэгчид өөрсдийн шинэчлэхийг 
	хүссэн зүйл болгоноо жагсааж оруулах шаардлагатай болно. Ингэснээр 
	эх код болон хоёртын файлуудын хоорондох уялдаа алдагдаж гамшигт 
	үр дагаварт хүргэж болно.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para><filename class="directory">/bin</filename> эсвэл 
	<filename class="directory">/sbin</filename> зэрэг замуудыг 
	нэмж эдгээр тусгай сангуудыг шинэчлэх процессийн явцад 
	оролдохгүй орхиж болно. Энэ тохиргоо нь 
	<command>freebsd-update</command> локал өөрчлөлтүүдийг 
	дарж бичихээс хамгаалахад хэрэглэж болно.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Заагдсан сангууд дахь тохиргооны файлууд өөрчлөгдөөгүй 
	тохиолдолд шинэчилнэ. Хэрэглэгчийн хийсэн өөрчлөлтүүд эдгээр 
	файлуудын автомат шинэчлэлтийг хүчингүй болгоно. 
	<command>freebsd-update</command>-г нийлүүлэх явцад 
	өөрчлөлтүүдийг хадгалахыг тушаах <literal>KeepModifiedMetadata</literal> 
	гэсэн өөр нэг тохиргоо байдаг.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para><command>freebsd-update</command>-ийн нийлүүлэхийг оролдох 
	тохиргооны файлуудтай сангуудын жагсаалт. Файл нийлүүлэх процесс нь 
	цөөн тохиргоотой &man.mergemaster.8;-тай төстэй &man.diff.1; засварууд 
	бөгөөд нийлүүлэлтийг эсвэл хүлээн авах юм уу эсвэл засварлагч нээж эсвэл 
	<command>freebsd-update</command> ажиллагаагаа зогсоох болно. Эргэлзэж 
	байвал <filename class="directory">/etc</filename> санг нөөцөлж аваад 
	нийлүүлэлтүүдийг хүлээн авах хэрэгтэй. <command>mergemaster</command> тушаалын  
	талаар дэлгэрэнгүй мэдээллийг <xref linkend="mergemaster">-с үзнэ үү.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>Энэ сан нь бүх засварууд болон түр зуурын файлууд байх сан 
	юм. Хэрэглэгч хувилбар шинэчлэлт хийж байвал энэ байрлал нь хамгийн 
	багаар бодоход гигабайт дискийн зайтай байх шаардлагатай.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para><literal>yes</literal> гэж тохируулсан үед 
	<command>freebsd-update</command> нь <literal>Components</literal> буюу 
	бүрэлдэхүүн хэсгүүдийн жагсаалт бүрэн гэж тооцох бөгөөд жагсаалтаас гадна өөрчлөлт 
	хийхийг оролдохгүй. <command>freebsd-update</command> нь 
	<literal>Components</literal>-ийн жагсаалтад хамаарах файл 
	бүрийг шинэчлэхийг оролдох болно.</para>
    </sect2>

    <sect2 id="freebsdupdate-security-patches">
      <title>Аюулгүй байдлын засварууд</title>

      <para>Аюулгүй байдлын засварууд нь алсын машин дээр хадгалагддаг 
	бөгөөд дараах тушаал ашиглан татан авч суулгаж болно:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Хэрэв цөмийн ямар нэг засвар хийгдсэн бол системийг дахин 
	ачаалах хэрэгтэй. Хэрэв бүгд зөв явагдсан бол систем нь засвар хийгдсэн 
	байх ёстой бөгөөд <command>freebsd-update</command>-ийг 
	&man.cron.8; ажлаас шөнө бүр ажиллуулж болно. Энэ ажлыг хийхэд 
	дараах мөрийг <filename>/etc/crontab</filename>-д хийхэд 
	хангалттай байх болно:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Энэ мөр нь өдөр бүр <command>freebsd-update</command> хэрэгслийг 
	ажиллуулахыг зааж байна. Ийм аргаар <option>cron</option>-ий нэмэлт 
	өгөгдлийг ашиглан <command>freebsd-update</command> нь зөвхөн 
	шинэчлэлт байгаа эсэхийг шалгах болно. Хэрэв засварууд байвал тэдгээрийг 
	автоматаар диск рүү татаж авах бөгөөд гэхдээ засваруудыг хийхгүй.
	<username>root</username> хэрэглэгч рүү захиа илгээгдэх бөгөөд 
	дараа нь тэд гараар суулгаж болох юм.</para>

      <para>Хэрэв ямар нэг зүйл буруу болбол <command>freebsd-update</command> нь 
	дараах тушаалаар сүүлийн өөрчлөлтүүдийг буцаах чадвартай байдаг:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Дууссаны дараа цөм эсвэл цөмийн модулиуд өөрчлөгдсөн бол 
	системийг дахин эхлүүлэх хэрэгтэй. Энэ нь шинэ хоёртын файлуудыг санах 
	ой руу дуудах боломжийг &os;-д олгоно.</para>

      <para><command>freebsd-update</command> хэрэгсэл нь автоматаар 
	зөвхөн <literal>GENERIC</literal> цөмийг шинэчилж чаддаг.
	Хэрэв өөрчлөн тохируулсан цөм ашиглагдаж байвал <command>freebsd-update</command> нь 
	шинэчлэлтийг хийж дууссаны дараа цөмийг дахин бүтээж суулгах шаардлагатай. 
	Гэхдээ <command>freebsd-update</command> нь <filename
	  class="directory">/boot/GENERIC</filename> (хэрэв байгаа бол) 
	дахь <literal>GENERIC</literal> цөмийг системийн тухайн үеийн (ажиллаж байгаа) 
	цөм биш байсан ч гэсэн олж шинэчилдэг.</para>

      <note>
	<para><filename
	  class="directory">/boot/GENERIC</filename> дахь 
	  <literal>GENERIC</literal> цөмийн хуулбарыг үргэлж хадгалах нь ер нь зүйтэй 
	  байдаг. Энэ нь төрөл бүрийн асуудлуудыг шинжлэх болон 
	  <xref linkend="freebsdupdate-upgrade">-т тайлбарласны дагуу 
	  <command>freebsd-update</command>-г ашиглан 
	  хувилбар шинэчлэлтийг хийхэд ач тустай байх болно.</para>
      </note>

      <para><filename>/etc/freebsd-update.conf</filename> дахь анхдагч тохиргоо 
	өөрчлөгдөөгүй л бол <command>freebsd-update</command> шинэчлэгдсэн 
	цөмийн эхийг бусад шинэчлэлттэй цуг суулгах болно. Дараа нь өөрийн өөрчлөн 
	тохируулсан цөмийг дахин бүтээж суулгахдаа энгийн сурсан аргаараа хийж 
	болно.</para>

      <note>
	<para><command>freebsd-update</command>-аар түгээгдсэн шинэчлэлтүүд нь 
	  цөмтэй үргэлж холбоотой байдаггүй. <command>freebsd-update install</command> 
	  тушаалаар цөмийн эх өөрчлөгдөөгүй бол өөрийн өөрчлөн тохируулсан цөмийг дахин 
	  бүтээх шаардлагагүй юм. Гэхдээ <command>freebsd-update</command> 
	  тушаал <filename>/usr/src/sys/conf/newvers.sh</filename> файлыг 
	  үргэлж шинэчлэх болно. Тухайн үеийн нөхөөсийн түвшинг (<command>uname -r</command> 
	  тушаалаас гарсан <literal>-p</literal> дугаараар заагдсан) энэ файлаас 
	  авдаг. Өөр бусад юмс өөрчлөгдөөгүй байсан ч гэсэн өөрийн өөрчлөн тохируулсан 
	  цөмийг дахин бүтээх нь системийн тухайн үеийн нөхөөсийн түвшинг зөв гаргах 
	  боломжийг &man.uname.1;-д олгоно. Энэ нь олон системийг арчилж байгаа үед 
	  ялангуяа ач тустай байдаг бөгөөд ингэснээр тэр системүүд дээр суулгагдсан 
	  шинэчлэлтүүдэд түргэн шуурхай үнэлгээ өгөх боломжийг олгодог.</para>
      </note>
    </sect2>

    <sect2 id="freebsdupdate-upgrade">
      <title>Major ба Minor буюу Том ба Бага шинэчлэлтүүд</title>

      <para>Энэ процесс нь ихэнх гуравдагч талын прорамуудыг эвдэх 
	хуучин обьект файлууд болон сангуудыг устгах болно. 
	Бүх суулгагдсан портуудыг устгаж дахин суулгах эсвэл 
	<filename role="package">ports-mgmt/portupgrade</filename> 
	хэрэгсэл ашиглан сүүлд нь шинэчлэхийг зөвлөдөг. Дараах тушаалыг 
	ашиглан ихэнх хэрэглэгчид тест бүтээлтийг ажиллуулахыг хүснэ:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Энэ нь бүгдийг зөв дахин суулгах баталгаа болох юм. 
	<makevar>BATCH</makevar> орчны хувьсагчийг <literal>yes</literal> 
	гэж тохируулснаар энэ процессийн явцад гарч ирэх хүлээх мөрөнд 
	<literal>yes</literal> гэж хариулан бүтээх процессийн 
	үед оролцох шаардлагыг үгүй болгоно.</para>

      <para>Хэрэв өөрчлөн тохируулсан цөм ашиглагдаж байгаа бол шинэчлэх 
	процесс арай илүү ажиллагаатай. <literal>GENERIC</literal> цөмийн 
	хуулбар шаардлагатай бөгөөд <filename
	  class="directory">/boot/GENERIC</filename>-д байрлуулах 
	шаардлагатай. Хэрэв <literal>GENERIC</literal> цөм системд байхгүй 
	бол үүнийг доор дурдсан аргуудын аль нэгийг ашиглан олж авч болно:</para>

      <itemizedlist>
	<listitem>
	  <para>Хэрэв өөрчлөн тохируулсан цөм зөвхөн нэг удаа бүтээгдсэн бол 
	    <filename class="directory">/boot/kernel.old</filename> дахь 
	    цөм нь <literal>GENERIC</literal> цөм юм. Энэ санг 
	    <filename class="directory">/boot/GENERIC</filename> гэж 
	    өөрчлөхөд л болно.</para>
	</listitem>

	<listitem>
	  <para>Машинд физикээр хандах боломжтой гэж тооцвол 
	    <literal>GENERIC</literal> цөмийн хуулбарыг CD-ROM зөөвөрлөгчөөс 
	    суулгаж болно. Өөрийн суулгац дискийг хийж дараах тушаалуудыг 
	    ашиглана:</para>

	  <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/<replaceable>X.Y-RELEASE</replaceable>/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	  <para><filename
	      class="directory"><replaceable>X.Y-RELEASE</replaceable></filename>-г 
	    өөрийн ашиглаж байгаа хувилбараар солих хэрэгтэй. <literal>GENERIC</literal>
	    цөм анхдагчаар <filename
	      class="directory">/boot/GENERIC</filename>-д суулгагдах болно.</para>
	</listitem>

	<listitem>
	  <para>Дээр дурдсан бүгдийг хийх боломжгүй бол <literal>GENERIC</literal>
	    цөмийг эхээс нь дахин бүтээж суулгаж болох юм:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	  <para>Энэ цөмийг <command>freebsd-update</command> хэрэгсэлд  
	    <literal>GENERIC</literal> гэж харуулахын тулд <literal>GENERIC</literal> 
	    тохиргооны файлыг ямар ч тохиолдолд өөрчилсөн байх ёсгүй. Бас ямар нэг 
	    тусгай сонголтуудгүйгээр (аль болох хоосон <filename>/etc/make.conf</filename> 
	    файлтайгаар) бүтээгдсэн байх ёстойг зөвлөдөг.</para>
	</listitem>
      </itemizedlist>

      <para>Энэ үед <literal>GENERIC</literal> цөм рүү дахин ачаалах 
	шаардлагагүй юм.</para>

      <para>Том ба бага хувилбарын шинэчлэлтүүдийг 
	<command>freebsd-update</command> тушаалд хувилбарын дугаарыг өгч 
	гүйцэтгэж болно, жишээ нь дараах тушаал &os;&nbsp;8.1 руу 
	шинэчилнэ:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 8.1-RELEASE upgrade</userinput></screen>

      <para>Тушаал хүлээн авсны дараа <command>freebsd-update</command> 
	системийг шинэчлэхэд шаардлагатай мэдээллийг цуглуулахын тулд 
	тохиргооны файл болон одоогийн системийг шалгана. Ямар бүрэлдэхүүн 
	хэсгүүд илрүүлэгдсэн болон ямар бүрэлдэхүүн хэсгүүд илрүүлэгдээгүй 
	гэдгийг дэлгэц дээр үзүүлнэ. Жишээ нь:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 8.1-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>Энд хүрэхэд <command>freebsd-update</command> шинэчлэлтэд 
	шаардлагатай бүх файлуудыг татан авахаар оролдох болно. Зарим 
	тохиолдолд хэрэглэгчээс юу суулгах эсвэл хэрхэн цааш үргэлжлүүлэх 
	талаар асуултууд асууж болох юм.</para>

      <para>Өөрчлөн тохируулсан цөмийг ашиглаж байх үед дээрх алхам 
	дараахтай төстэй анхааруулгыг харуулах болно:</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Энэ анхааруулгыг энэ үед орхигдуулахад аюулгүй байдаг. Шинэчлэгдсэн 
	<literal>GENERIC</literal> цөм шинэчлэлтийн явцад завсрын алхам 
	болон ашиглагдах болно.</para>

      <para>Бүх засварууд локал систем рүү татагдсаны дараа тэдгээрийг 
	хийж өгөх болно. Машины хурд болон ачааллаас хамаарч энэ процесс нь 
	хугацаа шаардаж болох юм. Тохиргооны файлуудыг нийлүүлэх болно. 
	Файл нийлүүлэгдэх юм уу эсвэл гараар нийлүүлэхэд зориулж засварлагч 
	дэлгэц дээр гарч ирч болох учир процессийн энэ хэсэг хэрэглэгчийн 
	оролцоо шаардана. Амжилттай нийлүүлэлт болгоны үр дүн хэрэглэгчид 
	харуулагдаж процесс үргэлжлэх болно. Амжилтгүй болсон эсвэл орхигдсон 
	нийлүүлэлт нь процессийг зогсоох болно. Хэрэглэгчид нь 
	<filename class="directory">/etc</filename> сангийн нөөцийг 
	хийж  <filename>master.passwd</filename> эсвэл 
	<filename>group</filename> зэрэг чухал файлуудыг гараар сүүлд нь 
	нийлүүлэхийг хүсэж болох юм.</para>

      <note>
	<para>Систем нь өөрчлөгдөөгүй байгаа бөгөөд бүх засвар оруулалт 
	  болон нийлүүлэлт өөр сан дотор болж байгаа болно. Бүх засварууд 
	  амжилттай хийгдэж бүх тохиргооны файлууд нийлүүлэгдэж процесс 
	  тэгш явагдаж байгаа мэт санагдвал хэрэглэгч өөрчлөлтүүдийг хийх 
	  хэрэгтэй.</para>
      </note>

      <para>Энэ процесс дууссаны дараа шинэчлэлтийг дараах тушаалыг ашиглан 
	диск рүү хийж болно.</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Цөм болон цөмийн модулиудад эхлээд засвар хийнэ. Энэ үед 
	машиныг дахих ачаалах ёстой. Хэрэв систем өөрчлөн тохируулсан цөмөөр 
	ажиллаж байгаа бол цөмийг <filename
	  class="directory">/boot/GENERIC</filename> (шинэчлэгдсэн) 
	цөмөөр дараа нь ачаалахаар болгохын тулд &man.nextboot.8;-ийг 
	ашиглана:</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para><literal>GENERIC</literal> цөмөөр ачаалахаас өмнө (хэрэв шинэчлэгдэж 
	  байгаа машинд алсаас хандаж байгаа бол сүлжээнд холбогдон) таны систем зөв ачаалахын 
	  тулд шаардлагатай бүх драйверуудыг агуулсан эсэхийг шалгах хэрэгтэй. Ялангуяа 
	  хэрэв өмнө нь ажиллаж байсан өөрчлөн тохируулсан цөм ерөнхийдөө цөмийн модулиудаар 
	  хангагдаж байдаг ажиллагааг өөртөө агуулсан бол <filename>/boot/loader.conf</filename> 
	  боломжийг ашиглан эдгээр модулиудыг <literal>GENERIC</literal> цөмд түр зуур 
	  ачаалахаа мартуузай. Шинэчлэх процесс бүрэн дуустал шаардлагагүй үйлчилгээнүүд, диск 
	  болон сүлжээний холболтууд гэх мэтийг та бас хааж өгч болох юм.</para>
      </warning>

      <para>Одоо машин шинэчлэгдсэн цөмөөр ачаалагдах ёстой:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Систем буцаж ассаны дараа <command>freebsd-update</command>-г 
	дахин эхлүүлэх хэрэгтэй. Процессийн төлөв хадгалагдсан болохоор 
	<command>freebsd-update</command> эхнээсээ эхлэхгүй бөгөөд бүх 
	хуучин хуваалцсан сангууд болон обьект файлуудыг устгах болно. 
	Энэ шатыг үргэлжлүүлэхийн тулд дараах тушаалыг ажиллуулна:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>Сангуудын хувилбарын тоо дээшилсэн эсэхээс хамаарч 
	  суулгах гурван шатны оронд хоёр шат байж болох юм.</para>
      </note>

      <para>Бүх гуравдагч талын програм хангамжийг дахин бүтээж дахин суулгах 
	хэрэгтэй. Суулгагдсан програм хангамж нь шинэчлэлтийн процессийн явцад 
	устгагдсан сангуудаас хамаарч болох учраас энэ нь шаардлагатай юм. 
	<filename role="package">ports-mgmt/portupgrade</filename> тушаалыг 
	үүнийг автоматжуулахад ашиглаж болох юм. Энэ процессийг эхлүүлэхийн 
	тулд дараах тушаалыг хэрэглэж болно:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Үүнийг дууссаны дараа шинэчлэлтийн процессийг 
	<command>freebsd-update</command>-ийг сүүлийн удаа дуудаж 
	төгсгөнө. Шинэчлэлтийн процессийн сул байгаа бүх зүйлсийг гүйцээхийн  
	тулд дараах тушаалыг ажиллуулна:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Хэрэв <literal>GENERIC</literal> цөм түр зуур ашиглагдаж байсан 
	бол өөрчлөн тохируулсан шинэ цөмийг ердийн хэвшсэн аргаар одоо бүтээж суулгах цаг 
	болжээ.</para>

      <para>Машинаа &os;-ийн шинэ хувилбар руу дахин ачаалах хэрэгтэй. 
	Процесс дууслаа.</para>
    </sect2>

    <sect2 id="freebsdupdate-system-comparison">
      <title>Системийн төлвийн харьцуулалт</title>

      <para><command>freebsd-update</command> хэрэгслийг 
	&os;-ийн суулгагдсан хувилбарын төлвийг байгаа зөв хуулбарын 
	эсрэг тест хийхэд хэрэглэж болно. Энэ сонголт нь системийн хэрэгслүүд 
	сангууд болон тохиргооны файлуудын одоогийн хувилбаруудыг шалгадаг. 
	Харьцуулалтыг эхлүүлэхийн тулд дараах тушаалыг ажиллуулна:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
	<para>Тушаалын нэр <acronym>IDS</acronym> боловч энэ нь 
	  ямар ч тохиолдолд <filename role="package">security/snort</filename> зэрэг 
	  халдлага илрүүлэгч системийг солих зориулалттай биш юм. 
	  <command>freebsd-update</command> нь өгөгдлийг диск дээр 
	  хадгалдаг бөгөөд түүнийг өөрчлөх боломж тодорхой юм.  
	  <varname>kern.securelevel</varname> тохиргоог ашиглах болон  
	  <command>freebsd-update</command>-ийн өгөгдлийг зөвхөн уншигдах файлын 
	  систем дээр ашиглагдаагүй тохиолдолд хадгалах нь энэ боломжийг 
	  багасгах боловч илүү сайн шийдэл нь системийг <acronym>DVD</acronym> эсвэл 
	  нууцлаг хадгалсан гадаад <acronym>USB</acronym> дискийн төхөөрөмж зэрэг 
	  нууцлаг дисктэй харьцуулах явдал юм.</para>
      </warning>

      <para>Систем нь одоо шалгагдах бөгөөд файлууд нь өөрсдийн 
	&man.sha256.1; утгуудын хамт, хувилбар дахь мэдэгдэж байгаа сайн утгууд болон 
	одоо суугдсан байгаа утгуудын хамт хэвлэгдэн харуулагдана. 
	Энэ нь яагаад гаралт <filename>outfile.ids</filename> файл руу 
	илгээгдсэн шалтгаан юм. Үүнийг нүдээр шалгахад хэтэрхий хурдан дээш 
	гүйж удалгүй консолын буфферийг дүүргэх болно.</para>

      <para>Эдгээр мөрүүд нь бас хэтэрхий урт боловч гаралтын хэлбэрийг 
	хялбараар задлан ялгаж болно. Жишээ нь хувилбарт байгаагаас ондоо 
	бүх файлуудын жагсаалтыг авахын тулд дараах тушаалыг ажиллуулна:</para>

	  <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Энэ гаралт нь тайрагдсан бөгөөд олон файл байгаа болно. 
	Эдгээр файлуудын зарим нь төрөлхийн өөрчлөлтүүдтэй байна, жишээ нь 
	<filename>/etc/passwd</filename> нь хэрэглэгч системд нэмэгдсэн 
	болохоор өөрчлөгдсөн байна. Зарим тохиолдолд 
	<command>freebsd-update</command> нь шинэчилсэн байж болзошгүй учир 
	цөмийн модулиуд зэрэг бусад файлууд өөр байж болох юм. 
	Тусгай файлууд болон сангуудыг хасахын тулд тэдгээрийг 
	<filename>/etc/freebsd-update.conf</filename> файлын  
	<literal>IDSIgnorePaths</literal> тохиргоонд нэмж өгнө.</para>

      <para>Өмнө хэлэлцсэн хувилбараас гадна нарийн нягт шинэчлэлтийн аргын 
	хэсэг болгон энэ системийг ашиглаж болно.</para>
    </sect2>
  </sect1>

  <sect1 id="updating-upgrading-portsnap">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Бичсэн </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Колин</firstname>
	  <surname>Персивал</surname>
	  <contrib>Тэмдэглэгээ бичсэн </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Portsnap: Портын цуглуулгыг шинэчлэх хэрэгсэл</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>&os;-ийн үндсэн систем портын цуглуулгыг бас шинэчилдэг 
      &man.portsnap.8; хэрэгслийг агуулдаг. Ажиллуулсны дараа энэ нь 
      алсын сайт руу холбогдож нууц түлхүүрийг шалгаж портын цуглуулгын шинэ 
      хуулбарыг татан авдаг. Түлхүүр нь бүх татаж авсан файлууд татагдаж байхдаа 
      өөрчлөгдөөгүй эсэхийг хянан бүрэн бүтэн байдлыг шалгахад ашиглагддаг.
      Хамгийн сүүлийн үеийн портын цуглуулгыг татаж авахын тулд дараах 
      тушаалыг ажиллуулна:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Энэ жишээ нь юу үзүүлж байна вэ гэхээр &man.portsnap.8; 
      одоо байгаа портын өгөгдөлд хэд хэдэн засварууд байгааг олж шалгаж байна. 
      Энэ нь бас уг хэрэгсэл өмнө нь ажилласныг харуулж байгаа бөгөөд 
      хэрэв эхний удаа ажилласан бол цуглуулга татагдан авагдах байсан
      юм.</para>

    <para>&man.portsnap.8; нь <command>fetch</command> үйлдлийг хийж 
      дууссаны дараа локал систем дээр байгаа портын цуглуулга болон дараа дараагийн 
      засваруудыг шалгалтад дамжуулна. <command>portsnap</command>-ийг эхний удаа ажиллуулахдаа 
      <literal>extract</literal>-г ашиглан татан авсан файлуудыг суулгаж болно:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Аль хэдийн суулгасан портын цуглуулгыг шинэчлэхдээ 
      <command>portsnap update</command> тушаалыг ашиглах ёстой:</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>Процесс одоо дууссан бөгөөд портын цуглуулыг ашиглан 
      програмуудыг суулгаж эсвэл шинэчилж болно.</para>

    <para><literal>fetch</literal> болон <literal>extract</literal> эсвэл 
      <literal>update</literal> үйлдлүүдийг доор харуулсан шиг дараалуулан 
      ажиллуулж болно:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>Энэ тушаал нь портын цуглуулгын сүүлийн хувилбарыг 
      татан авч таны машин дээр байгаа локал хувилбарыг 
      <filename class="directory">/usr/ports</filename> санд 
      шинэчилдэг.</para>
  </sect1>

  <sect1 id="updating-upgrading-documentation">
    <title>Баримтын цуглуулгыг шинэчлэх нь</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Үндсэн систем болон портын цуглуулгаас гадна 
      баримтууд нь &os; үйлдлийн системийн салшгүй хэсэг юм. Хэдийгээр 
      &os;-ийн хамгийн сүүлийн үеийн баримтын цуглуулга <ulink
	url="http://www.freebsd.org/doc/">&os; вэб сайт</ulink> дээр 
      үргэлж байдаг боловч зарим хэрэглэгчид удаан сүлжээний холболттой эсвэл 
      бүр тогтмол сүлжээний холболтгүй байж болох юм. Азаар &os;-ийн хамгийн 
      сүүлийн үеийн баримтын цуглуулгын локал хуулбарыг арчлан хувилбар бүртэй цуг 
      ирдэг баримтыг шинэчлэх хэд хэдэн арга байдаг.</para>

    <sect2 id="csup-doc">
      <title>Баримтыг шинэчлэхийн тулд CVSup-г ашиглах нь</title>

      <para>Үндсэн системийг шинэчлэхтэй төстэй аргыг ашиглан 
	<application>CVSup</application> хэрэглэн эх болон &os;-ийн 
	баримтуудын суулгагдсан хуулбарыг шинэчилж болно 
	(<xref linkend="makeworld">). Энэ хэсэг дараах зүйлсийг 
	  тайлбарладаг:</para>

      <itemizedlist>
	<listitem>
	  <para>&os;-ийн баримтуудыг эхээс нь бүтээхэд шаардлагатай 
	    хэрэгслүүд, баримтын хэрэгслүүдийг хэрхэн суулгах
	    талаар.</para>
	</listitem>

	<listitem>
	  <para><application>CVSup</application> ашиглан 
	    <filename class="directory">/usr/doc</filename> дахь 
	    баримтын эхийн хуулбарыг хэрхэн татаж авах талаар.</para>
	</listitem>

	<listitem>
	  <para>&os;-ийн баримтыг эхээс нь хэрхэн бүтээж 
	    <filename class="directory">/usr/share/doc</filename> дотор 
	    суулгах талаар.</para>
	</listitem>

	<listitem>
	  <para>Баримтыг бүтээх системийн дэмждэг бүтээлтийн 
	    зарим тохируулгууд, өөрөөр хэлбэл баримтын зарим нэг 
	    хэл дээрх орчуулгыг зөвхөн бүтээдэг тохируулгууд эсвэл 
	    тусгай гаралтын хэлбэржүүлэлтийг сонгодог тохируулгууд.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="installing-documentation-toolchain">
      <title>CVSup болон баримтын хэрэгслүүдийг суулгах нь</title>

      <para>&os;-ийн баримтыг эхээс нь бүтээхэд нэлээн олон 
	тооны хэрэгслүүдийг шаарддаг. Эдгээр хэрэгслүүд нь 
	&os;-ийн үндсэн системийн хэсэг биш байдаг. Учир нь эдгээр нь 
	ихээхэн хэмжээний дискийн зай шаарддаг бөгөөд &os;-ийн бүх 
	хэрэглэгчдэд хэрэгтэй байдаггүй. Тэдгээр нь &os;-д зориулж 
	шинэ баримтууд идэвхтэй бичдэг эсвэл өөрсдийн баримтыг 
	эхээс нь байнга шинэчилдэг хэрэглэгчдэд зөвхөн хэрэгтэй 
	байдаг.</para>

      <para>Бүх шаардлагатай хэрэгслүүд портын цуглуулгад байдаг. 
	Эдгээр хэрэгслүүдийн эхний суулгалт болон хожмын шинэчлэлтүүдийг 
	хялбаршуулах <filename
	  role="package">textproc/docproj</filename> порт нь &os;-ийг 
	баримтжуулах төслөөс хөгжүүлсэн мастер порт юм.</para>

      <note>
	<para>&postscript; эсвэл PDF баримт шаардлагагүй үед харин 
	  <filename
	    role="package">textproc/docproj-nojadetex</filename> портыг 
	  суулгаж болох юм. Баримтын хэрэгслийн энэ хувилбар нь 
	  <application>teTeX</application> тайпсет хөдөлгүүрээс бусад 
	  бүгдийг багтаасан байдаг. <application>teTeX</application> нь 
	  маш олон хэрэгслүүдийн цуглуулга учир PDF гаралт үнэхээр 
	  шаардлагагүй тохиолдолд суулгахгүй байх нь зохимжтой 
	  байдаг.</para>
      </note>

      <para><application>CVSup</application>-г суулгаж ашиглах талаарх 
	дэлгэрэнгүй мэдээллийг <link
	  linkend="cvsup">CVSup-г ашиглах</link> хэсгээс үзнэ үү.</para>
    </sect2>

    <sect2 id="updating-documentation-sources">
      <title>Баримтын эхийг шинэчлэх нь</title>

      <para><application>CVSup</application> нь 
	<filename>/usr/share/examples/cvsup/doc-supfile</filename> файлыг 
	тохиргооны загвар болгон ашиглаж баримтын эхийн цэвэр хуулбарыг татан 
	авч чаддаг. Анхдагч шинэчлэлтийн хост нь <filename>doc-supfile</filename> 
	файлд зааснаар байгаа боловч &man.cvsup.1; нь тушаалын мөрөөс хостын 
	нэрийг авдаг бөгөөд баримтын эхийг аль нэг <application>CVSup</application> 
	серверээс дараах тушаалыг бичин татан авч болно:</para>

      <screen>&prompt.root; <userinput>cvsup -h <replaceable>cvsup.FreeBSD.org</replaceable> -g -L 2 <filename>/usr/share/examples/cvsup/doc-supfile</filename></userinput></screen>

      <para><replaceable>cvsup.FreeBSD.org</replaceable>-г хамгийн ойр 
	<application>CVSup</application> серверээр солих хэрэгтэй. Толин 
	тусгал сайтуудын бүрэн жагсаалтыг <xref
	  linkend="cvsup-mirrors">-с үзнэ үү.</para>

      <para>Баримтын эхийн эхний таталт хугацаа шаардаж болох юм. Дуустал нь 
	хүлээх хэрэгтэй.</para>

      <para>Баримтын эхийн дараа дараагийн шинэчлэлтүүдийг дээрх тушаалыг 
	ашиглан татан авч болно. <application>CVSup</application> хэрэгсэл нь 
	хамгийн сүүлийн удаа ажилласнаашаа хойших шинэчлэлтүүдийг зөвхөн татан 
	авч хуулдаг учир эхний удаа бүрэн ажилласнаас хойш дараа дараагийн 
	удаа <application>CVSup</application>-г ажиллуулахад илүү хурдан 
	байдаг.</para>

      <para>Эхийг татан авсныхаа дараа баримтыг шинэчлэх өөр нэг арга нь 
	<filename
	  class="directory">/usr/doc</filename> сангийн 
	<filename>Makefile</filename>-аар дэмжигдсэн байдаг. 
	<filename>/etc/make.conf</filename> файлд 
	<makevar>SUP_UPDATE</makevar>, <makevar>SUPHOST</makevar> болон 
	<makevar>DOCSUPFILE</makevar>-ийг тохируулснаар доорхийг 
	ажиллуулах боломжтой болно:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>

      <para><filename>/etc/make.conf</filename>-д зориулсан 
	&man.make.1;-ийн эдгээр тохируулгууд ийм байдаг:</para>

      <programlisting>SUP_UPDATE= yes
SUPHOST?= cvsup.freebsd.org
DOCSUPFILE?= /usr/share/examples/cvsup/doc-supfile</programlisting>

      <note>
	<para><makevar>SUPHOST</makevar>
	  болон <makevar>DOCSUPFILE</makevar> утгад <literal>?=</literal>-г 
	  өгснөөр бүтээх тушаалын мөрөөс өөрчлөх боломжийг бүрдүүлдэг. 
	  Энэ нь <filename>make.conf</filename>-д тохируулгууд нэмэх 
	  зөвлөсөн арга юм. Ингэснээр өөр өөр тохируулгын утгыг тест хийх 
	  болгонд файлыг засварлах шаардлагагүй болгодог.</para>
      </note>
    </sect2>

    <sect2 id="updating-documentation-options">
      <title>Баримтын эхийн тааруулж болох тохируулгууд</title>

      <para>&os;-ийн баримтжуулалтыг бүтээж шинэчлэх систем нь баримтын 
	зөвхөн тодорхой хэсгийг шинэчлэх эсвэл тусгай орчуулгыг бүтээх 
	процессийг амарчлах хэдэн тохируулгыг дэмждэг. Эдгээр тохируулгуудыг 
	<filename>/etc/make.conf</filename> файлд бүхэл системийн 
	хувьд зааж өгөх юм уу эсвэл &man.make.1; хэрэгсэлд тушаалын 
	мөрийн тохиргоо маягаар зааж өгч болно.</para>

      <para>Дараах тохируулгууд нь эдгээрийн зарим нь юм:</para>

      <variablelist>
	<varlistentry>
	  <term><makevar>DOC_LANG</makevar></term>

	  <listitem>
	    <para>Бүтээж суулгах хэл ба кодчилолын жагсаалт, жишээ нь 
	      Англи баримтад зөвхөн зориулсан <literal>en_US.ISO8859-1</literal>
	      байна.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>FORMATS</makevar></term>

	  <listitem>
	    <para>Бүтээх ганц хэлбэржүүлэлт эсвэл гаралтын хэлбэржүүлэлтийн 
	      жагсаалт. Одоогоор <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, <literal>pdf</literal>,
	      болон <literal>rtf</literal> дэмжигдсэн байгаа.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>SUPHOST</makevar></term>

	  <listitem>
	    <para>Шинэчлэхэд ашиглах <application>CVSup</application> 
	      серверийн хостын нэр.</para>
	  </listitem>
	</varlistentry>
         <varlistentry>

          <term><makevar>DOCDIR</makevar></term>

          <listitem>
            <para>Баримтыг суулгах газар.  Анхдагчаар
              <filename
                class="directory">/usr/share/doc</filename> байдаг.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>&os; дээрх системийн тохируулга болон дэмжигдсэн бүтээлтийн 
	хувьсагчуудын талаар дэлгэрэнгүйг &man.make.conf.5;-с үзнэ үү.</para>

      <para>&os;-ийн баримтжуулалт бүтээх системийн дэмждэг бүтээлтийн 
	хувьсагчуудын талаар дэлгэрэнгүйг 
	<ulink url="&url.doc.langbase;/books/fdp-primer">Шинэ хувь нэмэр оруулагчдад 
	  зориулсан &os; баримтжуулах төслийн гарын авлагаас</ulink> үзнэ үү.</para>
    </sect2>

    <sect2 id="updating-installed-documentation">
      <title>&os;-ийн баримтуудыг эхээс суулгах нь</title>

      <para>Баримтын эхийн хамгийн сүүлийн хормын хувилбарыг 
	<filename class="directory">/usr/doc</filename> санд татаж авснаар 
	суулгагдсан баримтын шинэчлэлтийг хийхэд бүх юм бэлэн болно.</para>

      <para><makevar>DOC_LANG</makevar> makefile-ийн тохиргоонд заагдсан 
	бүх хэлний бүрэн шинэчлэлтийг дараахийг бичин хийж болно:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Хэрэв <filename>make.conf</filename> нь зөв 
	<makevar>DOCSUPFILE</makevar>, <makevar>SUPHOST</makevar>
	болон <makevar>SUP_UPDATE</makevar> тохиргоонуудтайгаар 
	тохируулагдсан бол суулгах алхмыг баримтын шинэчлэлттэй цуг 
	хамтатган ингэж хийж өгч болно:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Хэрэв зөвхөн тусгай хэлний шинэчлэлт хэрэгтэй бол 
	<filename class="directory">/usr/doc</filename>-ийн тухайн хэлний 
	тусгай дэд санд &man.make.1;-ийг ажиллуулж болно, жишээ нь:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Суулгах гаралтын хэлбэржүүлэлтийг <makevar>FORMATS</makevar> 
	бүтээлтийн хувьсагчийг зааж өгөн хийж өгч болно, 
	жишээ нь:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>
    </sect2>

    <sect2 id="doc-ports">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Марк</firstname>
	    <surname>Фонвил</surname>
	    <contrib>Хувь нэмэр болгосон </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Баримтжуулах портуудыг ашиглах нь</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>Өмнөх хэсэгт &os;-ийн баримтжуулалтыг эхээс нь 
	шинэчлэх аргыг бид танилцуулсан. &os;-ийн бүх системүүдийн 
	хувьд эх дээр тулгуурласан шинэчлэлтүүд нь боломжтой эсвэл 
	практикийн биш байж болох юм. Баримтжуулалтын эхүүдийг 
	бүтээх нь нэлээн их хэмжээний хэрэгслийн цуглуулга буюу 
	<emphasis>баримтжуулалт бүтээх хэрэгслийн олонлог</emphasis>,
	<application>CVS</application>-ийг тодорхой хэмжээгээр мэдэх, 
	репозиториос эхийг татаж авах болон татаж авсан эхээ 
	бүтээх хэд хэдэн шат дарааллуудыг шаарддаг. Энэ хэсэгт 
	бид &os;-ийн баримтжуулалтын суулгагдсан хуулбаруудыг 
	шинэчлэх өөр аргыг тайлбарлах болно. Энэ нь портын 
	цуглуулгыг ашиглах бөгөөд дараах боломжийг бүрдүүлнэ:</para>

      <itemizedlist>
	<listitem>
	  <para>Бүгдийг бүтээлгүйгээр баримтжуулалтын урьдчилан 
	    бүтээсэн хормын хувилбарыг татан авч суулгах
	    (ингэснээр баримтжуулалт бүтээх хэрэгслийн олонлогийг 
	    бүхэлд нь суулгах шаардлагагүй болно).</para>
	</listitem>

	<listitem>
	  <para>Баримтжуулалтын эхийг татаж аван портын тогтолцоог 
	    ашиглан бүтээх (татаж аван бүтээх алхмуудыг арай хялбар 
	    болгодог).</para>
	</listitem>
      </itemizedlist>

      <para>&os;-ийн баримтжуулалтыг шинэчлэх эдгээр хоёр арга нь 
	&a.doceng;-ийн сар бүр шинэчилдэг <emphasis>баримтжуулалтын 
	портуудын</emphasis> цуглуулгаар дэмжигддэг. Эдгээр нь 
	&os;-ийн портын цуглуулгад <ulink
	  url="http://www.freshports.org/docs/">docs</ulink>  
	виртуал төрөлд байдаг.</para>

      <sect3 id="doc-ports-install-make">
	<title>Баримтжуулалтын портуудыг бүтээж суулгах нь</title>

	<para>Баримтжуулалтын портууд нь баримтжуулалтын бүтээлтийг 
	  хялбар болгохын тулд порт бүтээх тогтолцоог хэрэглэдэг. 
	  &man.make.1;-ийг тохирох орчны тохиргоонууд болон тушаалын 
	  мөрийн тохиргоонуудын хамтаар ажиллуулж баримтжуулалтын 
	  эхийг татаж авах процессыг тэд автоматжуулдаг бөгөөд 
	  баримтжуулалтын суулгалт болон устгалтыг &os;-ийн 
	  бусад порт эсвэл багцын суулгалтын нэгэн адил хялбар 
	  болгодог.</para>

	<note>
	  <para>Мөн баримтжуулалтын портуудыг бүтээсний дараа тэд 
	    хамааралтай <emphasis>баримтжуулалтыг бүтээх хэрэгслийн олонлогийн</emphasis> 
	    портуудыг бүртгэдэг бөгөөд тэдгээрийг автоматаар бас 
	    суулгадаг.</para>
	</note>

	<para>Баримтжуулалтын портуудын зохион байгуулалт нь 
	  дараах хэлбэрийн байна:</para>

	<itemizedlist>
	  <listitem>
	    <para>Баримтжуулалтын портын файлууд байдаг 
	      <filename
		role="package">misc/freebsd-doc-en</filename>
	      <quote>мастер порт</quote> байдаг. Энэ нь бүх 
	      баримтжуулалтын портуудын үндэс болдог. Анхдагчаар 
	      энэ нь Англи баримтжуулалтыг зөвхөн бүтээдэг.</para>
	  </listitem>

	  <listitem>
	    <para><quote>Нэг портод бүгд багтсан</quote> <filename
		role="package">misc/freebsd-doc-all</filename> байдаг 
	      бөгөөд энэ нь байгаа бүх хэл дээр бүх баримтжуулалтыг 
	      бүтээж суулгадаг.</para>
	  </listitem>

	  <listitem>
	    <para>Эцэст нь орчуулга бүрийн хувьд <quote>зарц порт</quote>
	      байдаг, жишээ нь Унгар хэл дээрх баримтуудад зориулсан 
	      <filename
		role="package">misc/freebsd-doc-hu</filename>-г дурдаж 
	      болно. Эдгээр нь бүгд мастер портоос хамаарах бөгөөд 
	      тухайн хэлний орчуулсан баримтжуулалтыг суулгадаг.</para>
	  </listitem>
	</itemizedlist>

	<para>Баримтжуулалтын портыг эхээс суулгахын тулд дараах 
	  тушаалуудыг ажиллуулна (<username>root</username> эрхээр):</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>Энэ нь Англи баримтжуулалтыг хуваагдсан <acronym>HTML</acronym> 
	  хэлбэрээр (<ulink
	    url="http://www.FreeBSD.org"></ulink> дээр ашигладагийн адилаар) 
	  бүтээж <filename
	    class="directory">/usr/local/share/doc/freebsd</filename> санд 
	  суулгадаг.</para>

	<sect4 id="doc-ports-options">
	  <title>Нийтлэг Knob болон тохируулгууд</title>

	  <para>Баримтжуулалтын портуудын анхдагч байдлыг өөрчлөх 
	    олон тохиргоо байдаг. Доор цөөхөн хэдэн жагсаалтыг 
	    дурдав:</para>

	  <variablelist>
	    <varlistentry>
	      <term><makevar>WITH_HTML</makevar></term>

	      <listitem>
		<para>HTML хэлбэрээр бүтээхийг зөвшөөрдөг: баримт 
		  бүрийн хувьд нэг HTML файл. Хэлбэршүүлсэн 
		  баримтжуулалт нь тохирох <filename>article.html</filename> юм уу 
		  эсвэл <filename>book.html</filename> гэсэн файлуудад зургийн 
		  хамтаар хадгалагддаг.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><makevar>WITH_PDF</makevar></term>

	      <listitem>
		<para>&adobe; &acrobat.reader;,
		  <application>Ghostscript</application> эсвэл бусад PDF уншигчдыг 
		  ашиглах &adobe;-ийн хөрвөх баримтын хэлбэрээр бүтээхийг 
		  зөвшөөрдөг. Хэлбэршүүлсэн 
		  баримтжуулалт нь тохирох <filename>article.pdf</filename> юм уу 
		  эсвэл <filename>book.pdf</filename> гэсэн файлуудад  
		  хадгалагддаг.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><makevar>DOCBASE</makevar></term>

	      <listitem>
		<para>Баримтжуулалтын суулгах байрлал. Энэ нь 
		  анхдагчаар <filename 
		    class="directory">/usr/local/share/doc/freebsd</filename>
		  байдаг.</para>

		<note>
		  <para>Анхдагч суулгах сан нь <application>CVSup</application> 
		    аргын ашигладаг сангаас ялгаатайг санаарай. 
		    Энэ нь яагаад гэвэл бид порт суулгаж байгаа 
		    бөгөөд портууд нь ихэвчлэн <filename
		      class="directory">/usr/local</filename> санд 
		    суудаг. Үүнийг <makevar>PREFIX</makevar> хувьсагчийг  
		    нэмэн өөрчилж болдог.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Энд Унгар баримтжуулалтыг Хөрвөх Баримтын Хэлбэрээр (PDF) 
	    суулгахын тулд дээр дурдсан хувьсагчуудыг хэрхэн 
	    ашиглахыг харуулсан жишээг үзүүлэв:</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 id="doc-ports-install-package">
	<title>Баримтжуулалтын багцуудыг ашиглах нь</title>

	<para>Өмнөх хэсэгт тайлбарласнаар баримтжуулалтын портуудыг 
	  эхээс бүтээх нь баримтжуулалтыг бүтээх хэрэгслийн 
	  олонлогийг суулгах болон  портуудыг бүтээхэд тодорхой 
	  хэмжээний дискийн зай шаарддаг. Баримтжуулалтын 
	  хэрэгслүүдийг суулгахад эх үүсвэр хүрэлцэхгүй үед эсвэл 
	  эхээс бүтээх нь ихээхэн хэмжээний дискийн зай эзлэх 
	  бол баримтжуулалтын портуудын урьдчилан бүтээсэн 
	  хормын хувилбаруудыг суулгах боломж бас байдаг.</para>

	<para>&a.doceng; нь &os;-ийн баримтжуулалтын багцуудын 
	  сар бүрийн хормын хувилбаруудыг бэлддэг. Эдгээр 
	  хоёртын багцуудыг &man.pkg.add.1;,
	  &man.pkg.delete.1; гэх зэрэг багцын хэрэгслүүдийн 
	  хамтаар ашиглаж болдог.</para>

	<note>
	  <para>Хоёртын багцуудыг ашиглаж байгаа үед &os;-ийн 
	    баримтжуулалт нь тухайн хэлний хувьд байгаа 
	    <emphasis>бүх</emphasis> хэлбэрээр суудаг.</para>
	</note>

	<para>Жишээ нь дараах тушаал Унгар баримтжуулалтын 
	  хамгийн сүүлийн урьдчилан бүтээсэн багцыг суулгах 
	  болно:</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
	  <para>Багцууд нь харгалзах портын нэрнээсээ ялгаатай дараах 
	    нэрийн хэлбэртэй байдаг: 
	    <literal><replaceable>lang</replaceable>-freebsd-doc</literal>.
	    Энд <replaceable>lang</replaceable> нь хэлний кодын богино 
	    хэлбэр юм, жишээ нь <literal>hu</literal> нь Унгар, эсвэл 
	    <literal>zh_cn</literal> нь хялбаршуулсан Хятад хэл юм.</para>
	</note>
      </sect3>

      <sect3 id="doc-ports-update">
	<title>Баримтжуулалтын портуудыг шинэчлэх нь</title>

	<para>Өмнө нь суулгасан баримтжуулалтын портыг шинэчлэхийн 
	  тулд портууд шинэчлэх аль ч хэрэгсэл байхад хангалттай.
	  Жишээ нь дараах тушаал суулгасан Унгар баримтжуулалтыг 
	  <filename
	    role="package">ports-mgmt/portupgrade</filename> хэрэгслийн
	  тусламжтайгаар зөвхөн багцуудыг ашиглан шинэчилнэ:</para>

	<screen>&prompt.root; <userinput>portupgrade -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>

<!-- FIXME: Waiting for a working docsnap server... -->
<![ IGNORE [
    <sect2 id="docsnap">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Пав</firstname>
	    <surname>Лукистник</surname>
	    <contrib>Мэдээллээр хангасан </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Docsnap-ийг ашиглах нь</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>Docsnap</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para><application>Docsnap</application> нь &os;-ийн баримтуудыг 
	хялбар, хурдан аргаар шинэчлэхэд зориулагдсан &man.rsync.1; 
	репозитор юм. <quote><application>Docsnap</application> сервер</quote> 
	нь баримтын эхүүдийг дагаж тэдгээрийг цаг бүр HTML хэлбэрт бүтээж 
	байдаг. <filename role="package">textproc/docproj</filename> нь 
	<application>Docsnap</application>-д хэрэггүй байдаг. Учир нь 
	зөвхөн бүтээсэн баримтад зориулсан нөхөөсүүд байдаг болохоор тэр юм.</para>

      <para>Энэ техникийг ашиглахад шаардлагатай цорын ганц зүйл нь 
	<filename role="package">net/rsync</filename> порт юм уу эсвэл багц 
	байдаг. Үүнийг нэмэхийн тулд дараах тушаалыг ашиглана:</para>

      <screen>&prompt.root; <userinput>pkg_add -r rsync</userinput></screen>

      <note>
	<para><application>Docsnap</application> нь 
	  <filename class="directory">/usr/share/doc</filename>-д суулгагдсан 
	  баримтыг шинэчлэхэд зориулж анхлан хөгжүүлэгдсэн боловч дараах жишээнүүдийг 
	  бусад сангуудын хувьд тохируулан ашиглаж болно. Хэрэглэгчийн сангуудын 
	  хувьд энэ нь <username>root</username> эрхийг шаарддаггүй.</para>
      </note>

      <para>Баримтын цуглуулгыг шинэчлэхийн тулд дараах тушаалыг 
	ажиллуулна:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <note>
	<para>Одоогоор зөвхөн нэг <application>Docsnap</application> 
	  сервер байгаа, <hostid>docsnap.sk.FreeBSD.org</hostid> дээр 
	  харуулагдсан байгаа.</para>
      </note>

      <para>Энд <option>--delete</option> тохируулыг ашиглах хэрэггүй, 
	учир нь <command>make installworld</command> тушаалын үеэр 
	<filename class="directory">/usr/share/doc</filename> 
	санд суулгагдсан зарим зүйлсийг санамсаргүйгээр устгаж болох юм. 
	Цэвэрлэхийн тулд энэ тушаалыг ашиглана:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz --delete <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/??_??\.\* <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <para>Хэрэв баримтын хэсгийг шинэчлэх шаардлагатай бол жишээ нь 
	Англи баримтыг зөвхөн шинэчлэх бол дараах тушаалыг ашиглах 
	шаардлагатай:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/en_US.ISO8859-1 <replaceable>/usr/share/doc</replaceable></userinput></screen>
    </sect2>
]]>
  </sect1>

  <sect1 id="current-stable">
    <title>Хөгжүүлэлтийн салбарыг дагах нь</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>FreeBSD-ийн хоёр хөгжүүлэлтийн салбар байдаг: &os.current; болон 
      &os.stable;. Энэ хэсэгт эдгээр тус бүрийг тайлбарлаж өөрийн системийг тус 
	тусын модны хувьд хамгийн шинэ хэлбэрт байнга байлгах талаар тайлбарлах болно. 
	&os.current; эхлээд хэлэлцэгдэх бөгөөд дараа нь &os.stable;-ийн тухай
	яригдах болно.</para>

    <sect2 id="current">
      <title>&os;-ийн одоо үеийн хэлбэрт байх нь</title>

      <para>Та үүнийг уншихдаа &os.current; нь &os;-ийн хөгжүүлэлтийн 
	<quote>bleeding edge салбар буюу амжилт ололтын хамгийн тэргүүний 
	салбар</quote> гэдгийг санаарай. &os.current; хэрэглэгчдийг техникийн өндөр 
	чадавхитай бөгөөд системийн хүнд хэцүү асуудлуудыг өөрсдөө шийдвэрлэх 
	чадвартай байна гэж тооцдог. Хэрэв та &os;-д анхлан суралцагч бол 
	үүнийг суулгахаасаа өмнө дахин сайн бодоорой.</para>

      <sect3>
	<title>&os.current; гэж юу вэ?</title>
	<indexterm><primary>хормын агшны хувилбар</primary></indexterm>

	<para>&os.current; нь &os;-ийн хамгийн сүүлийн үеийн ажлын эх юм. 
	     Энэ нь хийгдэж байгаа ажлууд, туршилтын өөрчлөлтүүд болон програм хангамжийн 
	     дараагийн албан ёсны хувилбарт байхгүй ч байж болох эсвэл байж ч болох 
	     шилжилтийн аргуудыг багтаадаг. &os;-ийн олон хөгжүүлэгчид &os.current;-ийн 
	     эх кодыг өдөр болгон эмхэтгэн хөрвүүлж байдаг боловч эхийг бүтээх боломжгүй үе бас 
	     байдаг. Эдгээр асуудлууд нь боломжийн хэрээр хурдан шийдэгддэг боловч 
	  &os.current; нь сүйрэл авчрах эсвэл тун их хүссэн ажиллагааг авчрах эсэх нь 
	     та яг ямар агшинд эх кодыг татаж авснаас хамаарах юм!</para>
      </sect3>

      <sect3>
	<title>&os.current; хэнд хэрэгтэй вэ?</title>

	<para>&os.current; нь үндсэн 3 сонирхлын бүлэгт зориулагдан
		хийгдсэн:</para>

	<orderedlist>
	  <listitem>
	    <para>Эх модны зарим хэсэг дээр идэвхтэйгээр ажиллаж байгаа &os;-ийн хүрээний 
		гишүүд болон <quote>current буюу одоо үеийн хэлбэрт</quote> байлгах нь 
		туйлын шаардлага болсон хүмүүст.</para>
	  </listitem>

	  <listitem>
	    <para>&os.current;-г аль болох ухаалаг байлгахыг хичээж асуудлуудыг шийдвэрлэхэд
		цагаа зарах хүсэлтэй байдаг идэвхтэй тест хийгч &os;-ийн хүрээний гишүүд. 
		Эдгээр хүмүүс нь өөрчлөлтүүд болон  &os;-ийн ерөнхий чиглэлд цаг үеийн 
		саналуудыг тусгахыг хүсэж тэдгээрийг шийдэх засваруудыг илгээдэг бас хүмүүс 
		юм..</para>
	  </listitem>

	  <listitem>
	    <para>Юу болж байгааг зөвхөн харж мэдэж байхыг хүссэн эсвэл одоо үеийн эхийг 
		лавлагааны зорилгоор ашиглахыг зөвхөн хүссэн хүмүүс (өөрөөр хэлбэл 
		ажиллуулах биш <emphasis>унших</emphasis> зорилгоор).
		Эдгээр хүмүүс нь хааяа бас санал гаргаж кодонд хувь нэмэр оруулдаг.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>&os.current; нь юу <emphasis>Биш</emphasis> вэ?</title>

	<orderedlist>
	  <listitem>
	    <para>Та зарим нэг дажгүй шинэ боломж байгааг сонссон учраас бусдаас 
		түрүүлж урьдчилсан хувилбарын тэдгээр битүүдийг авах таны нэн тэргүүний 
		арга зам. Шинэ боломжийг авч эхэнд байна гэдэг нь та шинэ алдаанууд,
		хорхойнуудыг бас авч эхэнд байна гэсэн үг юм.</para>
	  </listitem>

	  <listitem>
	    <para>Алдааны засваруудыг хурдан авах арга зам. &os.current;-ийн 
		өгөгдсөн дурын хувилбар нь илэрсэн алдаануудыг засахын хажуугаар бас 
		магадгүй шинэ алдаанууд бас гаргаж байдаг.</para>
	  </listitem>

	  <listitem>
	    <para>Аль ч үед <quote>албан ёсоор дэмжигдсэн</quote>. Бид өөрсдийн 
		чадлын хирээр <quote>хууль ёсны</quote> 3 &os.current; бүлгийн 
		аль нэгэнд хүмүүст бодитоор туслахыг хичээдэг, гэхдээ бидэнд ердөө л  
		техникийн дэмжлэг үзүүлэх <emphasis>цаг байдаггүй</emphasis>.
		Энэ нь бид хүмүүст туслах дургүй өөдгүй муухай хүмүүс учраас гэсэн үг 
		биш юм (хэрэв бид байгаагүй бол бид &os;-г хийж байхгүй байх байсан).
		Бид ердөө л өдрийн хэдэн зуун захидлуудад хариулахын  
		<emphasis>хажуугаар</emphasis> FreeBSD дээр ажиллаж чаддаггүй! 
		&os;-г сайжруулах болон туршилтын кодон дээр тавигдсан маш олон 
		асуултуудад хариулах хоёр сонголтын эхнийхийг хөгжүүлэгчид сонгосон 
		юм.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>&os.current; ашиглах нь</title>
      
	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>ашиглах нь</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>&a.current.name; болон &a.svn-src-head.name; жагсаалтуудад элсэн орно уу. 
		Энэ нь зөвхөн сайн санаанаас гадна бас <emphasis>чухал</emphasis> 
		юм. Хэрэв та <emphasis>&a.current.name;</emphasis> жагсаалтад 
		ороогүй бол системийн одоогийн төлвийн талаар хүмүүсийн  өгч байгаа санал 
		хүсэлтүүдийг харахгүй учраас бусдын аль хэдийн олоод шийдсэн маш их асуудлууд 
		дээр магадгүй та бүдрэн төөрөлдөж дуусах биз ээ. Бүр илүү чухал зүйл нь юу вэ гэвэл
		таны системийн эрүүл мэндэд эгзэгтэй байж болох чухал мэдээнүүдээс та хоцрох 
		болно.</para>

	    <para>&a.svn-src-head.name; жагсаалт нь кодонд оруулсан өөрчлөлт бүрийн 
		бүртгэл оруулгыг болзошгүй сөрөг нөлөөнүүдийн талаар тохирсон мэдээллийн 
		хамтаар танд харах боломжийг олгодог.</para>

	    <para>Эдгээр жагсаалтууд эсвэл байгаа бусдын аль нэгэнд элсэхийн тулд 
		&a.mailman.lists.link; хаяг уруу орж элсэхийг хүссэн жагсаалтаа 
		сонгоорой. Дарааллын үлдсэн зааврууд тэнд байгаа болно. Хэрэв та 
	        бүх л эх модон дахь өөрчлөлтийг дагах сонирхолтой байгаа бол 
	        &a.svn-src-all.name; жагсаалтад бүртгүүлэхийг бид зөвлөж байна.</para>
	  </listitem>

	  <listitem>
	    <para>&os;-ийн <link linkend="mirrors">толин тусгал</link>аас 
		эхийг авна. Та үүнийг хоёр аргаар хийж болно:</para>

	    <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>
              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>
              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary><application>CVSup</application> ашиглан сүүлийн хэлбэрт аваачих</secondary>
	      </indexterm>

	      <listitem>
		<para><filename>/usr/share/examples/cvsup</filename> санд байх 
			<filename>standard-supfile</filename> гэж нэрлэгдсэн 
			<filename>supfile</filename>-тай цуг 
			<link linkend="cvsup">cvsup</link> програм ашигла. 
			Энэ нь бүхэл цуглуулгыг нэг л удаа авч дараа нь зөвхөн өөрчлөгдсөнүүдийг
			танд авах боломжийг олгодог хамгийн сайшаасан арга юм.
			Олон хүмүүс <command>cvsup</command>-г <command>cron</command>-с 
			ажиллуулж өөрсдийн эхийг хамгийн сүүлийн хэлбэрт автоматаар 
			аваачдаг. Та дээр дурдсан жишээ <filename>supfile</filename>-г 
			өөрчлөн <link linkend="cvsup">cvsup</link>-г өөрийн орчны хувьд 
			тохируулах хэрэгтэй.</para>
		<note>
		  <para>Жишээ <filename>standard-supfile</filename> нь 
		    &os.current;-ийн биш &os;-ийн аюулгүй байдлын тусгай 
		    салбарыг дагахад хэрэглэгдэнэ. Танд энэ файлыг засварлаж дараах 
		    мөрийг өөрчлөх хэрэгтэй болно:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

		  <para>Дээрх мөрийг дараах мөрөөр сольно:</para>

		  <programlisting>*default release=cvs tag=.</programlisting>

		  <para>Хэрэгцээтэй хаяг/шошгонуудын дэлгэрэнгүй тайлбарыг 
		    гарын авлагын <link
		      linkend="cvs-tags">CVS хаяг/шошгонууд</link> хэсгээс үзнэ үү.</para>
		</note>
	      </listitem>

              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>CTM ашиглан сүүлийн хэлбэрт аваачих</secondary>
	      </indexterm>
	      <listitem>
		<para><application><link
		  linkend="ctm">CTM</link></application> хэрэгслийг ашигла.
			Хэрэв та маш муу холболттой (өндөр үнэтэй холболтууд эсвэл 
			зөвхөн цахим захидлын хандалт) бол <application>CTM</application>
			нь сонголт болох юм. Гэхдээ энэ нь бөөн зовлон бөгөөд та эвдэрсэн 
			файлуудтай үлдэж болох юм. Энэ нь үүнийг ховор ашиглахад хүргэдэг бөгөөд 
			ингэснээр ажиллахгүй байх боломжийг нэлээн удаан хугацаагаар ихэсгэдэг.
			Бид 9600&nbsp;bps модем болон түүнээс хурдан холболттой хүмүүст 
			<application><link linkend="cvsup">CVSup</link></application>-г 
			ашиглахыг зөвлөдөг.
		</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Хэрэв та эхийг зөвхөн харахаар биш ажиллуулахаар татаж авч байгаа бол 
		зөвхөн сонгосон хэсгүүдийг биш &os.current;-ийн <emphasis>бүх</emphasis>
		эхийг татаж аваарай. Үүний шалтгаан нь эхийн төрөл бүрийн хэсгүүд нь бусад хаа нэгтээ байгаа 
		шинэчлэлтүүдээс хамаардаг бөгөөд зөвхөн хэсэг бүлэг эхийг хөрвүүлэхийг оролдох нь 
		таныг бараг л баталгаатайгаар асуудалтай учруулах болно.</para>

	  <indexterm>
	    <primary>-CURRENT</primary>
	    <secondary>хөрвүүлэх</secondary>
	  </indexterm>
	    <para>&os.current;-ийг хөрвүүлэхээсээ өмнө <filename>/usr/src</filename> 
		дахь <filename>Makefile</filename>-г анхааралтай уншина уу.
		Эхний удаа та хамгийн багаар бодоход шинэчлэлтийн процессийн хэсэг болох <link
	      linkend="makeworld">шинэ цөмийг суулгаж ертенцийг дахин бүтээх</link> хэсгээр 
		дамжих хэрэгтэй. &a.current; болон <filename>/usr/src/UPDATING</filename> 
		файлыг унших нь биднийг дараагийн хувилбар уруу шилжихэд заримдаа шаардлагатай 
		болдог бусад эхлүүлэх процедуруудын хувьд хамгийн сүүлийн мэдээлэлтэй  байлгах 
		боломжийг бидэнд олгодог.</para>
	  </listitem>
	      
	  <listitem>
	    <para>Идэвхтэй бай! Хэрэв та &os.current; ажиллуулж байгаа бол 
		түүний талаар таныг юу хэлэхийг ялангуяа хэрэв танд өргөжүүлэлт эсвэл 
		алдааны засваруудын талаар санал хүсэлт байвал түүнийг бид мэдэхийг 
		хүсдэг юм. Хавсаргасан кодтой санал хүсэлтүүдийг хамгийн их урам зоригтойгоор 
		хүлээн авдаг билээ!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  
    <sect2 id="stable">
      <title>&os;-ийн тогтвортой хэлбэрт байх нь</title>

      <sect3>
	<title>&os.stable; гэж юу вэ?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; нь үндсэн хувилбарууд гардаг бидний хөгжүүлэлтийн салбар юм.
		Өөрчлөлтүүд нь эхлээд тест хийгдэх зорилгоор &os.current; уруу ордог гэсэн 
		ерөнхий төсөөлөл/таамаглалтайгаар янз бүрийн зөвшөөрлөөр энэ салбар уруу 
		ордог. Энэ нь <emphasis>одоо болтол</emphasis> хөгжүүлэлтийн салбар 
		бөгөөд гэхдээ энэ нь ямар ч үед &os.stable;-д зориулагдсан эх нь ямар ч зорилгод 
		тохирч эсвэл тохирохгүй байж болно гэсэн үг юм. Энэ нь эцсийн хэрэглэгчид 
		зориулагдсан эх үүсвэр бус ердөө л өөр нэг инженерчлэлийн хөгжүүлэлтийн арга зам 
		юм.</para>
      </sect3>

      <sect3>
	<title>&os.stable; хэнд хэрэгтэй вэ?</title>

	<para>Хэрэв та FreeBSD-ийн хөгжүүлэлтийн процессод хувь нэмэр оруулах сонирхолтой,  
		энэ нь ялангуяа FreeBSD-ийн дараагийн <quote>гарах</quote> хувилбартай холбоотой байдаг, 
		эсвэл юу болж байгааг мэдэж байх сонирхолтой байгаа бол та дараах 
		&os.stable;-г бодолцох хэрэгтэй.</para>

	<para>Аюулгүй байдлын засварууд бас &os.stable; салбар уруу орж байдаг нь 
		үнэн боловч та үүнийг хийхийн тулд &os.stable;-г заавал дагах 
		<emphasis>хэрэггүй</emphasis>. FreeBSD-ийн аюулгүй байдлын 
		зөвлөмжүүд нь тухайн хувилбарт хамааралтай асуудлыг хэрхэн засах тухай 
		тайлбарладаг 
	  <footnote><para>Энэ нь бүр яг үнэн биш юм. Бид FreeBSD-ийн хуучин хувилбаруудыг 
		үргэлж дэмжиж чадахгүй, гэхдээ бид тэдгээрийг олон жилийн турш дэмжсээр 
		ирсэн. FreeBSD-ийн хуучин хувилбаруудын одоогийн аюулгүй байдлын бодлогын 
		бүрэн тайлбарыг <ulink
  	    url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>-с
		үзнэ үү.</para>
	  </footnote>
		бөгөөд зөвхөн аюулгүй байдлын үүднээс бүхэл бүтэн хөгжүүлэлтийн салбарыг 
		дагаж байна гэдэг бас зөндөө олон хүсээгүй өөрчлөлтүүдийг авчрах 
		магадлалтай юм.</para>

	<para>Бид &os.stable; салбар үргэлж хөрвүүлэгдэн эмхэтгэгдэж дандаа ажилладаг байлгахаар 
		чармайж байдаг боловч энэ нь баталгаатай биш юм. Нэмж хэлэхэд код нь &os.stable;-д 
		орохоосоо өмнө &os.current;-д хөгжүүлэгдэж байдаг боловч &os.current;-г 
		ашиглан ажиллуулдгаас илүү &os.stable;-г хүмүүс ажиллуулдаг болохоор 
		&os.current;-ийн хувьд илэрхий биш байсан алдаанууд болон булангийн тохиолдлууд 
		&os.stable;-д  илрэх нь заримдаа зайлшгүй юм.</para>

	<para>Эдгээр шалтгаануудаас болоод бид &os.stable;-г сохроор дагахыг танд 
		<emphasis>зөвлөдөггүй</emphasis> бөгөөд энэ нь 
		өөрийн хөгжүүлэлтийн орчиндоо кодыг эхлээд сайтар тест хийлгүйгээр 
		үйлдвэрлэлд (production) ашиглаж байгаа серверүүдээ  &os.stable; 
		уруу шинэчлэхгүй байхад танд ялангуяа чухал ач холбогдолтой юм.</para>

	<para>Хэрэв танд үүнийг хийх эх үүсвэрүүд байхгүй бол бид FreeBSD-ийн хамгийн сүүлийн үеийн 
		хувилбарыг ажиллуулж хоёртын шинэчлэлт хийх аргыг хувилбараас хувилбар уруу шилжихдээ 
		ашиглахыг танд зөвлөж байна.</para>
      </sect3>

      <sect3>
	<title>&os.stable; ашиглах нь</title>
      
	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>ашиглах нь</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>&a.stable.name; жагсаалтад элсэн орно уу. Энэ нь  
		&os.stable;-д илэрч болох бүтээлтийн хамаарлууд эсвэл 
		тусгайлсан анхаарал шаардлагатай өөр бусад асуудлуудын талаар 
		танд мэдээлж байх болно. Хөгжүүлэгчид нь зарим нэг маргаантай засвар 
		эсвэл шинэчлэлийн талаар бодож байгаа талаараа бас энэ захидлын жагсаалтад 
		мэдээлдэг бөгөөд ийнхүү санал болгож байгаа өөрчлөлтийн талаар хэрэглэгчдэд 
		ямар нэг асуудал байвал тэдэнд эргээд хариу өгөх боломж олгодог юм.</para>

	    <para>Өөрийн дагаж байгаа салбарын тохирох <application>SVN</application>
	      жагсаалтад элсэн орох хэрэгтэй. Жишээ нь хэрэв та 7-STABLE салбарыг дагаж 
	      байгаа бол &a.svn-src-stable-7.name; жагсаалтад элсэн ороорой. 
	      Энэ нь кодонд оруулсан өөрчлөлт бүрийн 
	      бүртгэл оруулгыг болзошгүй сөрөг нөлөөнүүдийн талаар тохирсон мэдээллийн 
	      хамтаар танд харах боломжийг олгодог.</para>

	    <para>Эдгээр жагсаалтууд эсвэл байгаа бусдын аль нэгэнд элсэхийн тулд 
		&a.mailman.lists.link; хаяг уруу орж элсэхийг хүссэн жагсаалтаа 
		сонгоорой. Дарааллын үлдсэн зааврууд тэнд байгаа болно. Хэрэв та 
	        бүх л эх модон дахь өөрчлөлтийг дагах сонирхолтой байгаа бол 
	        &a.svn-src-all.name; жагсаалтад бүртгүүлэхийг бид зөвлөж байна.</para>
	  </listitem>

	  <listitem>
	    <para>Хэрэв та шинэ систем суулгаж &os.stable;-ээс бүтээсэн сар бүрийн хормын 
		агшны хувилбарыг түүн дээр ажиллуулахыг хүсэж байгаа бол дэлгэрэнгүй 
		мэдээллийн талаар <ulink url="&url.base;/snapshots/">
		Хормын агшны хувилбарууд</ulink> вэб хуудаснаас шалгана уу.
		Үүнээс гадна хамгийн сүүлийн үеийн &os.stable; хувилбарыг  
		<link linkend="mirrors">толин тусгалын хаягууд</link>аас 
		татан авч суулгах боломжтой бөгөөд доор дурдсан заавруудыг дагаж 
		өөрийн системийг хамгийн сүүлийн үеийн &os.stable; эх код уруу 
		шинэчилж болох юм.</para>

	    <para>Хэрэв та &os;-ийн урдны хувилбар аль хэдийн ажиллуулж байгаа бөгөөд 
		эхээс шинэчлэхийг хүсэж байгаа бол &os;-ийн 
		<link linkend="mirrors">толин тусгал хуудас</link>аас хялбараар 
		хийж болно. Үүнийг хоёр аргаар хийж болно:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary><application>CVSup</application>  ашиглан сүүлийн хэлбэрт аваачих</secondary>
	      </indexterm>
	      <listitem>
		<para><filename>/usr/share/examples/cvsup</filename> санд байх 
			<filename>standard-supfile</filename> гэж нэрлэгдсэн 
			<filename>supfile</filename>-тай цуг 
			<link linkend="cvsup">cvsup</link> програм ашигла. 
			Энэ нь бүхэл цуглуулгыг нэг л удаа авч дараа нь зөвхөн өөрчлөгдсөнүүдийг
			танд авах боломжийг олгодог хамгийн сайшаасан арга юм.
			Олон хүмүүс <command>cvsup</command>-г <command>cron</command>-с 
			ажиллуулж өөрсдийн эхийг хамгийн сүүлийн хэлбэр автоматаар 
			аваачдаг. Та дээр дурдсан жишээ <filename>supfile</filename>-г 
			өөрчлөн <link linkend="cvsup">cvsup</link>-г өөрийн орчны хувьд 
			тохируулах хэрэгтэй.</para>
	      </listitem>

	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>CTM ашиглан сүүлийн хэлбэрт аваачих</secondary>
	      </indexterm>
	      <listitem>
		<para><application><link
		  linkend="ctm">CTM</link></application> хэрэгслийг ашигла.
			Хэрэв танд Интернэт уруу холбогдсон хурдан хямд холболт байхгүй бол 
			энэ аргыг та ашиглах хэрэгтэй.
		  </para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Гол нь хэрэв та эхэд хурдан, шаардлагын улмаас хандах хэрэгтэй болоод 
		холболтуудын зурвасын өргөн ач холбогдолгүй бол <command>cvsup</command> эсвэл 
		<command>ftp</command> ашиглаарай. Бусад тохиолдолд 
		<application>CTM</application>-г ашигла.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>хөрвүүлэх нь</secondary>
	  </indexterm>
	  <listitem>
	    <para>&os.current;-ийг хөрвүүлэхээсээ өмнө <filename>/usr/src</filename> 
		дахь <filename>Makefile</filename>-г анхааралтай уншина уу.
		Эхний удаа та хамгийн багаар бодоход шинэчлэлтийн процессийн хэсэг болох <link
	      linkend="makeworld">шинэ цөмийг суулгаж ертенцийг дахин бүтээх</link> хэсгээр 
		дамжих хэрэгтэй. &a.current; болон <filename>/usr/src/UPDATING</filename> 
		файлыг унших нь биднийг дараагийн хувилбар уруу шилжихэд заримдаа шаардлагатай 
		болдог бусад эхлүүлэх процедуруудын хувьд хамгийн сүүлийн мэдээлэлтэй  байлгах 
		боломжийг бидэнд олгодог.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Өөрийн эхийг хамгийн сүүлийн хэлбэрт аваачих нь</title>
    
    <para>Интернетийн (эсвэл цахим захидал) холболт ашиглан &os; төслийн эхүүдийн аль ч 
	хэсгийн хувьд эсвэл таны юу сонирхож байгаагаас хамааран бүх хэсгүүдийг  
	хамгийн шинэ байлгаж байх төрөл бүрийн аргууд байдаг. Бидний санал болгодог үндсэн 
	үйлчилгээнүүд бол <link linkend="anoncvs">Anonymous буюу нэргүй 
      CVS</link>, <link linkend="cvsup">CVSup</link> болон <link
      linkend="ctm">CTM</link> юм.</para>

    <warning>
      <para>Өөрийн эх модны зөвхөн зарим хэсгийг шинэчлэх боломжтой боловч 
	цорын ганц шинэчлэх арга бол модыг бүтнээр нь шинэчилж хэрэглэгчийн талбар 
	(өөрөөр хэлбэл <filename>/bin</filename> болон 
        <filename>/sbin</filename> гэх мэт дэх хэрэглэгчийн талбарт ажилладаг 
	бүх програмууд) болон цөмийн эхүүдийг дахин эмхэтгэх явдал юм. Өөрийн эх модны 
	зөвхөн нэг хэсэг зөвхөн цөм эсвэл зөвхөн хэрэглэгчийн талбарыг шинэчлэх нь 
	асуудлууд гарахад ихэвчлэн хүргэдэг. Эдгээр асуудлууд нь эмхэтгэлтийн үеийн 
	алдаануудаас авахуулаад цөмийн сүйрлүүд эсвэл өгөгдлийн эвдрэлийг хүртэл 
	хамардаг.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous буюу нэргүй</secondary>
    </indexterm>

    <para><application>Нэргүй CVS</application> болон 
      <application>CVSup</application> нь эхийг шинэчлэхдээ 
	<emphasis>татах</emphasis> загварыг хэрэглэдэг. 
	<application>CVSup</application>-ийн хувьд хэрэглэгч (эсвэл 
	<command>cron</command> скрипт) <command>cvsup</command>
	програмыг эхлүүлэн хаа нэгтээ байгаа <command>cvsupd</command> 
	серверт хандаж таны өөрийн файлуудыг хамгийн шинэ хэлбэрт авчирдаг. 
	Таны хүлээн авах шинэчлэлтүүд нь хамгийн сүүлийн минут хүртэлх үеийнх 
	байх бөгөөд та тэдгээрийг зөвхөн өөрийн хүссэн тэр үедээ авдаг. Та өөрийн 
	шинэчлэлтүүдийг таны сонирхож байгаа тусгайлсан файлууд эсвэл сангуудаар 
	хялбараар хязгаарлаж болно. Шинэчлэлтүүд нь таны юуг авахыг хүссэн болон танд 
	юу байгаагаас хамааран серверээр тухайн үед үүсгэгддэг.
	<application>Нэргүй CVS</application> нь алсын CVS repository 
	буюу кодын архиваас өөрчлөлтүүдийг шууд татахыг түүнд зөвшөөрдөг 
	<application>CVS</application>-ийн  ердөө л нэг өргөтгөл бөгөөд 
	үүгээрээ <application>CVSup</application>-с арай илүү хялбар юм.
	<application>CVSup</application> нь үүнийг хамаагүй илүү 
	үр дүнтэйгээр хийж чаддаг боловч <application>Нэргүй CVS</application>-г 
	ашиглахад илүү хялбар байдаг.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>Нөгөө талаас <application>CTM</application> нь танд байгаа эхийг 
	мастер архив дахь эхтэй лавлаж асуух зарчмаар харьцуулдаггүй бөгөөд өөрөөр хэлбэл 
	тэдгээрийг татаж авдаггүй. Ингэхийн оронд харин өмнө нь ажиллуулснаас хойшх 
	файл дахь өөрчлөлтүүдийг таньдаг скрипт өдөрт хэд хэдэн удаа мастер CTM машин 
	дээр ажиллаж илэрсэн өөрчлөлтүүдийг шахаж дарааллын-дугаар тавин цахим 
	захидлаар дамжуулахад зориулан кодчилдог (зөвхөн хэвлэгдэх боломжтой ASCII 
	хэлбэрээр). Эдгээр <quote>CTM дельтануудыг</quote> авсаны дараа 
	тэдгээрийг автоматаар декод хийж шалган хэрэгчид байгаа эхийн хуулбарт 
	өөрчлөлтүүдийг хийх &man.ctm.rmail.1; хэрэгсэл уруу өгдөг. Энэ процесс 
	нь <application>CVSup</application>-с хамаагүй илүү үр дүнтэй 
	бөгөөд энэ нь <emphasis>татах</emphasis> биш харин 
	<emphasis>түлхэх</emphasis> загвар учраас бидний серверийн эх үүсвэрт 
	бага ачаалал учруулдаг юм.</para>

    <para>Мэдээж үүнээс гадна харилцан сул болон давуу талуудтай асуудлууд байдаг. 
	Хэрэв та санамсаргүйгээр өөрийн архивын хэсгийг устгачих юм бол 
	<application>CVSup</application> үүнийг илрүүлж эвдэрсэн хэсгүүдийг 
	дахин бүтээж өгдөг. <application>CTM</application> ингэж 
	хийдэггүй бөгөөд хэрэв та өөрийн эх модны зарим хэсгийг устгасан  
	(бас нөөцлөн аваагүй) бол та дахин шинээр эхнээс нь (хамгийн сүүлийн үеийн 
	CVS <quote>суурь дельтагаас</quote>) эхэлж 
	<application>CTM</application>-ийн тусламжтайгаар бүгдийг дахин бүтээх
	буюу эсвэл <application>Нэргүй CVS</application>-ийн тусламжтайгаар
	муу битүүдийг ердөө л устгаж дахин сүүлийн хэлбэрт аваачих хэрэгтэй болно.</para>
  </sect1>

  <sect1 id="makeworld">
    <title><quote>Ертөнц</quote>ийг дахин бүтээх нь</title>

    <indexterm>
      <primary><quote>Ертөнц</quote>ийг дахин бүтээх нь</primary>
    </indexterm>
    <para>Та өөрийн локал эх модоо &os;-ийн тухайн хувилбарын (&os.stable;, 
	&os.current;, гэх зэрэг) хамгийн сүүлийн үеийн хэлбэрт аваачсаныхаа 
	дараа та эх модоо ашиглан системийг дахин бүтээж болно.</para>

    <warning>
      <title>Нөөц хий</title>

      <para>Та дээрхийг хийхээсээ <emphasis>өмнө</emphasis> өөрийн системийг 
	нөөцлөн авах нь ямар чухал болохыг энэ нь хангалттай хэлж өгч чаддаггүй.
	Ертөнцийг дахин бүтээх нь (хэрэв та эдгээр заавруудыг дагасан тохиолдолд) 
	хялбар боловч таныг алдаа гаргахад эсвэл бусдын эх модонд хийсэн алдаанууд 
	нь таны системийг ачаалагдахгүй болгох нөхцөлд зайлшгүй хүргэдэг.</para>

      <para>Нөөц хийж авсан эсэхээ шалгаарай. Засварлах уян диск эсвэл ачаалагдах 
	CD-г гарын дор байлгаарай. Магадгүй та үүнийг хэзээ ч хэрэглэхгүй байж болох 
	юм, гэхдээ харамсахаасаа өмнө аюулгүй байж байх нь илүү дээр юм!</para>
    </warning>

    <warning>
      <title>Тохирох захидлын жагсаалтад бүртгүүл</title>

      <indexterm><primary>захидлын жагсаалт</primary></indexterm>
      <para>&os.stable; болон &os.current; салбарууд нь угаасаа 
	<emphasis>хөгжүүлэлтэд байдаг</emphasis>. &os;-д хувь нэмэр 
	оруулж байгаа хүмүүс нь хүн л учраас алдаанууд заримдаа гардаг.</para>

      <para>Заримдаа эдгээр алдаанууд нь нэг их хор хөнөөлгүй бөгөөд ердөө л таны 
	системийг шинэ оношлогооны анхааруулга хэвлэхэд хүргэдэг. Эсвэл 
	өөрчлөлт нь сүйрлийн байж болзошгүй байдаг бөгөөд таны системийг ачаалагдахгүй 
	болгож эсвэл файлын системүүдийг чинь устгаж (эсвэл бүр муу юм болж) болох юм.</para>

      <para>Эдгээртэй адил асуудлууд гарвал асуудлын учир шалтгаан болон аль систем дээр 
	энэ асуудал хамааралтайг тайлбарласан <quote>heads up буюу бүхний сонорт</quote>
	хандсан зарлал тохирох захидлын жагсаалтад  илгээгддэг. Тэгээд 
	<quote>all clear буюу бүгд цэвэр</quote> зарлал асуудал шийдэгдсэний дараа 
	тавигддаг.</para>

      <para>Хэрэв та &os.stable; эсвэл &os.current;-ийг дагахыг оролдож &a.stable; 
	эсвэл &a.current;-г харгалзуулан уншихгүй байгаа бол энэ нь та өөртөө гай төвөг асууж 
	байна л гэсэн үг юм.</para>
    </warning>

    <warning>
      <title><command>make world</command> тушаалыг бүү ашигла</title>

      <para>Ихэнх хуучин баримтууд үүнд зориулан <command>make world</command>
	тушаалыг ашиглахыг зөвлөдөг. Энэ тушаалыг ажиллуулснаар зарим нэг чухал алхмуудыг 
	алгасах бөгөөд та юу хийж байгаагаа  мэдэж байгаа тохиолдолд үүнийг зөвхөн ашиглах 
	хэрэгтэй. Бараг ихэнх тохиолдолд <command>make world</command> хийх нь  
	буруу зүйл бөгөөд энд тайлбарласан процедурыг түүний оронд ашиглах ёстой юм.</para>
    </warning>

    <sect2 id="canonical-build">
      <title>Шалгагдсан аргаар өөрийн системийг шинэчлэх нь</title>

      <para>Өөрийн системийг шинэчлэхийн тулд өөрт чинь байгаа эхийн хувилбарт шаардлагатай байгаа 
	бүтээхээс урьдах алхмууд та <filename>/usr/src/UPDATING</filename>
	файлд байгаа эсэхийг шалгах хэрэгтэй бөгөөд үүний дараа энд дурдсан процедурыг 
	ашиглана.</para>

      <para>Эдгээр шинэчлэлтийн алхмууд нь таныг хуучин хөрвүүлэгч, хуучин цөм, хуучин 
	ертөнц болон хуучин тохиргооны файлууд бүхий &os;-ийн хуучин хувилбар ашиглаж 
	байгаа гэж тооцдог. <quote>Ертөнц</quote> гэдгийг бид энд системийн гол хоёртын
	файлууд, сангууд болон програмын файлууд гэж ойлгоно. Хөрвүүлэгч нь 
	<quote>ертөнц</quote>ийн хэсэг бөгөөд цөөн асуудлуудтай байдаг.</para>

      <para>Таныг шинэ системийн эхийг аль хэдийн авсан байгаа гэж бид бас 
	энд тооцдог. Тухайн систем дээр байгаа эхүүд бас хуучин байвал шинэ хувилбар 
	руу шилжүүлэх талаар бичсэн <xref linkend="synching">-с дэлгэрэнгүйг 
	үзнэ үү.</para>

      <para>Системийг эхээс шинэчлэх нь эхлээд санагдсанаасаа илүү нарийн байдаг 
	бөгөөд тойрон гарах боломжгүй, хамаарлууд бүхий шинэ асуудлууд гардгаас болоод 
	&os;-ийн хөгжүүлэгчид зөвлөдөг чиг хандлагаа жил ирэх тутам нэлээнээр 
	өөрчлөх шаардлагатай болсон. Энэ хэсгийн үлдсэн хэсэг нь одоогоор зөвлөж 
	байгаа шинэчлэх дарааллын талаар тайлбарлах болно.</para>

      <para>Амжилттай болох шинэчлэх дараалал бүр дараах асуудлуудыг 
	шийдэх ёстой:</para>

      <itemizedlist>
	<listitem>
	  <para>Хуучин хөрвүүлэгч шинэ цөмийг бүтээж чадахгүй байж болох 
	    юм. (Хуучин хөрвүүлэгчид заримдаа алдаатай байдаг.) Тиймээс шинэ 
	    цөмийг шинэ хөрвүүлэгчээр бүтээх ёстой. Ялангуяа шинэ цөм бүтээхээсээ 
	    өмнө шинэ хөрвүүлэгчийг бүтээх хэрэгтэй. Энэ нь шинэ хөрвүүлэгчийг 
	    заавал шинэ цөмөөс өмнө <emphasis>суулгасан</emphasis> байх ёстой 
	    гэсэн үг биш юм.</para>
	</listitem>

	<listitem>
	  <para>Шинэ ертөнц шинэ цөмийн боломжууд дээр тулгуурлаж байж 
	    болох юм. Тиймээс шинэ цөмийг шинэ ертөнцийг суулгахаасаа өмнө 
	    суулгасан байх шаардлагатай.</para>
	</listitem>
      </itemizedlist>

      <para>Эдгээр хоёр асуудал нь бидний дараагийн хэсгүүдэд тайлбарлах 
	гол <maketarget>buildworld</maketarget>,
	<maketarget>buildkernel</maketarget>,
	<maketarget>installkernel</maketarget>,
	<maketarget>installworld</maketarget> дарааллын үндэс болдог. 
	Энэ нь одоогоор зөвлөдөг шинэчлэлтийн просессийг та яагаад заавал 
	сонгох ёстойг харуулсан бүх шалтгаануудын бүрэн дүүрэн жагсаалт 
	биш юм. Зарим нэг тийм ч мэдээжийн биш зүйлсийг доор жагсаав:</para>

      <itemizedlist>
	<listitem>
	  <para>Хуучин ертөнц шинэ цөм дээр зөв ажиллахгүй байж болох учир 
	    та шинэ цөм суулгасныхаа дараа шинэ ертөнцийг даруйхан суулгах 
	    ёстой.</para>
	</listitem>

	<listitem>
	  <para>Шинэ ертөнц суулгахаасаа өмнө зарим нэг тохиргооны өөрчлөлтүүдийг 
	    хийх ёстой боловч зарим нь хуучин ертөнцийг эвдэж магадгүй юм. Тийм 
	    болохоор хоёр өөр тохиргооны шинэчлэлтийн алхам ерөнхийдөө шаардлагатай 
	    байдаг.</para>
	</listitem>

	<listitem>
	  <para>Ихэнх хэсгийн хувьд шинэчлэх процесс нь зөвхөн файлуудыг солих юм уу 
	    эсвэл нэмдэг бөгөөд байгаа хуучин файлуудыг устгадаггүй. Цөөн тохиолдолд 
	    энэ нь асуудал үүсгэж болох юм. Үүний дүнд шинэчлэх арга зам нь зарим нэг 
	    алхам дээр гараар устгах тодорхой файлуудыг заримдаа зааж өгдөг. Үүнийг 
	    ирээдүйд автоматчилах юм уу эсвэл үгүй ч байж болох юм.</para>
	</listitem>
      </itemizedlist>

      <para>Эдгээр зүйлс нь дараах зөвлөсөн дараалалд хүргэдэг. Тухайн шинэчлэлтүүдэд 
	зориулсан дэлгэрэнгүй дараалал нь нэмэлт алхмуудыг шаардаж болохыг санаарай. 
	Гэхдээ эдгээр гол процессууд тодорхой хугацаагаар өөрчлөгдөхгүй байх 
	ёстой юм:</para>

      <orderedlist>
	<listitem>
	  <para><command>make <maketarget>buildworld</maketarget></command></para>

	  <para>Энэ нь эхлээд шинэ хөрвүүлэгч болон хамааралтай цөөн хэрэгслүүдийг 
	    бүтээж дараа нь шинэ ертөнцийн бусдыг хөрвүүлэхийн тулд шинэ хөрвүүлэгчийг 
	    ашигладаг. Үр дүн нь <filename class="directory">/usr/obj</filename>-д 
	    хадгалагддаг.</para>
	</listitem>

	<listitem>
	  <para><command>make <maketarget>buildkernel</maketarget></command></para>

	  <para>&man.config.8; болон &man.make.1;-ийг ашигладаг хуучин аргаасаа 
	    ялгаатай нь энэ тушаал <filename class="directory">/usr/obj</filename> 
	    санд байрлаж байгаа <emphasis>шинэ</emphasis> хөрвүүлэгчийг ашигладаг.
	    Энэ нь хөрвүүлэгч болон цөмийн хооронд тохиромжгүй байдал үүсэхээс таныг 
	    хамгаалдаг.</para>
	</listitem>

	<listitem>
	  <para><command>make <maketarget>installkernel</maketarget></command></para>

	  <para>Шинэ цөм болон цөмийн модулиудыг дискэд байрлуулж шинээр шинэчилсэн 
	    цөмөөр ачаалах боломжийг бүрдүүлдэг.</para>
	</listitem>

	<listitem>
	  <para>Ганц хэрэглэгчийн горим руу ачаалан орно.</para>

	  <para>Ганц хэрэглэгчийн горим нь ажиллаж байгаа програм хангамжуудыг 
	    шинэчлэхэд гарах асуудлуудыг багасгадаг. Энэ нь бас шинэ цөм дээр 
	    хуучин ертөнцийг ажиллуулахад гарах асуудлыг багасгадаг.</para>
	</listitem>

	<listitem>
	  <para><command>mergemaster <option>-p</option></command></para>

	  <para>Энэ нь шинэ ертөнцөд зориулж зарим нэг тохиргооны файлуудын эхний 
	    шинэчлэлтүүдийг хийдэг. Жишээ нь энэ нь шинэ хэрэглэгчийн бүлгийг 
	    системд нэмэх, эсвэл шинэ хэрэглэгчийн нэрсийг нууц үгийн мэдээллийн санд 
	    нэмж болох юм. Сүүлийн шинэчлэлтээс хойш шинэ бүлгүүд эсвэл системийн 
	    тусгай хэрэглэгчийн бүртгэлүүдийг нэмэх үед энэ нь ихэвчлэн шаардлагатай 
	    байдаг. Ингэснээр <maketarget>installworld</maketarget> алхам нь 
	    шинээр суулгагдсан системийн хэрэглэгч эсвэл системийн бүлгийн нэрсийг 
	    ямар ч асуудалгүйгээр ашиглах боломжтой болох юм.</para>
	</listitem>

	<listitem>
	  <para><command>make <maketarget>installworld</maketarget></command></para>

	  <para><filename class="directory">/usr/obj</filename> сангаас 
	    ертөнцийг хуулдаг. Та одоо диск дээрээ шинэ цөм болон шинэ ертөнцтэй 
	    боллоо.</para>
	</listitem>

	<listitem>
	  <para><command>mergemaster</command></para>

	  <para>Нэгэнт диск дээрээ шинэ ертөнцтэй болсон болохоор та одоо 
	    үлдсэн тохиргооны файлуудаа шинэчилж болно.</para>
	</listitem>

	<listitem>
	  <para>Дахин ачаална.</para>

	  <para>Шинэ цөм болон шинэ ертөнцийг шинэ тохиргооны файлуудтай 
	    дуудахын тулд машиныг бүрэн дахин ачаалах хэрэгтэй.</para>
	</listitem>
      </orderedlist>

      <para>Хэрэв та &os;-ийн нэг салбар дотор нэг хувилбараас илүү сүүлийн 
	хувилбар руу шинэчилж байгаа бол, өөрөөр хэлбэл 7.0-с 7.1 рүү шинэчилж 
	байгаа бол хөрвүүлэгч, цөм, хэрэглэгчийн талбар болон тохиргооны файлуудын 
	хооронд айхтар таарамжгүй байдлууд тантай бараг л тохиолдохгүй учир энэ 
	арга нь заавал шаардлагатай биш байж болох юм. Хуучин арга болох 
	<command>make <maketarget>world</maketarget></command> болон шинэ 
	цөмийг бүтээж суулгах нь жижиг шинэчлэлтийн хувьд хангалттай сайн 
	ажиллаж болох юм.</para>

      <para>Гэхдээ гол хувилбаруудын хооронд шинэчлэлт хийж байх үед энэ арга 
	замыг дагахгүй байгаа хүмүүст зарим асуудлууд учирч болох юм.</para>

      <para>Олон шинэчлэлтүүд (өөрөөр хэлбэл 4.<replaceable>X</replaceable>-с 
	5.0 руу) тусгайлсан нэмэлт алхмуудыг (жишээ нь installworld хийхээс өмнө 
	тусгай файлуудын нэрийг өөрчлөх эсвэл устгах гэх мэт) шаардаж болохыг энд 
	тэмдэглэх нь зүйтэй юм. <filename>/usr/src/UPDATING</filename> файлыг 
	анхааралтай уншина уу, ялангуяа одоогоор зөвлөсөн байгаа шинэчлэх дарааллыг 
	тусгайлан тайлбарласан төгсгөл хэсгийг уншаарай.</para>

      <para>Зарим нэг тохиромжгүй байдалтай холбоотой асуудлуудаас бүрэн 
	гүйцэд хамгаалах боломжгүйг хөгжүүлэгчид мэдсэнээр энэ арга нь цаг хугацааны 
	туршид сайжруулагдсаар ирсэн юм. Одоогийн арга замууд нь удаан хугацааны 
	туршид тогвортой байна гэдэгт найдаж байна.</para>

      <para>Дүгнэхэд &os;-г эхээс шинэчлэхэд одоогоор зөвлөдөг арга 
	бол:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para><maketarget>buildworld</maketarget> алхмаас өмнө 
	  <command>mergemaster -p</command> тушаалыг нэмж ажиллуулах 
	    цөөн ховор тохиолдлууд байдаг. Эдгээрийн талаар <filename>UPDATING</filename>
	    файлд тайлбарласан байдаг. Хэрэв та &os;-ийн нэг буюу олон голлох 
	    хувилбаруудын дагуу шинэчлэл хийхгүй байгаа бол ерөнхийдөө энэ алхмыг 
	    эмээлгүйгээр орхиж болох юм.</para>
      </note>

      <para><maketarget>installkernel</maketarget> амжилттай дууссаны 
	дараа та ганц хэрэглэгчийн горим уруу ачаалах хэрэгтэй (өөрөөр хэлбэл&nbsp;
	<command>boot -s</command> тушаалыг дуудагч мөрөөс ашиглана). 
	Дараа нь доор дурдсан тушаалуудыг ажиллуулна:</para>

      <screen>&prompt.root; <userinput>adjkerntz -i</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Тайлбаруудыг цааш уншина уу</title>

	<para>Дээр тайлбарласан дараалал нь зөвхөн таныг эхлэхэд туслах богино 
	     сэргээлт болох юм. Гэхдээ хэрэв та ялангуяа өөрчлөн тохируулсан 
	     цөмийн тохиргоо ашиглахыг хүсэж байгаа бол дараах хэсгүүдийг уншиж 
	     алхам бүрийг сайтар ойлгох хэрэгтэй.</para>
      </warning>
    </sect2>

    <sect2 id="src-updating">
      <title><filename>/usr/src/UPDATING</filename> файлыг унш</title>

      <para>Өөр юм хийж эхлэхээсээ өмнө та <filename>/usr/src/UPDATING</filename>-г 
	(эсвэл эх кодын хуулбар хаана байгаа тэндээс үүнтэй төстэй файлыг ) уншаарай. 
	Энэ файл нь танд учирч болзошгүй асуудлуудын талаар  чухал мэдээлэл агуулдаг бөгөөд  
	эсвэл таны ажиллуулах зарим нэг тушаалуудын дарааллын талаар заасан байдаг. 
	Хэрэв <filename>UPDATING</filename> файл таны энд уншсантай зөрчилдөж 
	байвал <filename>UPDATING</filename> файлд заасныг дагах хэрэгтэй.</para>

      <important>
	<para><filename>UPDATING</filename> файлыг унших нь өмнө нь тайлбарласнаар 
	     зөв захидлын жагсаалтад бүртгүүлэхтэй харьцуулах юм бол хүлээн зөвшөөрч болохуйц  
	     орлогч байж чадахгүй юм. Энэ хоёр шаардлага нь нэмэлт бөгөөд заавал шаардлагатай 
	     биш юм.</para>
      </important>
    </sect2>

    <sect2 id="make-conf">
      <title><filename>/etc/make.conf</filename> файлыг шалга</title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para><filename>/usr/share/examples/etc/make.conf</filename> 
	болон <filename>/etc/make.conf</filename> файлыг шалгаарай.
	Эхнийх нь зарим нэг анхдагч тодорхойлолтуудыг агуулдаг &ndash; тэдгээрийн 
	ихэнх нь тайлбар болон хаагдсан байдаг. Та системээ эхээс нь дахин бүтээх үедээ 
	тэдгээрийг ашиглахын тулд <filename>/etc/make.conf</filename> 
	файлд нэмэх хэрэгтэй. <filename>/etc/make.conf</filename> файлд 
	нэмсэн болгон <command>make</command> тушаалыг ажиллуулах бүрд 
	бас ашиглагддаг учир өөрийн системдээ зориулан тэдгээрийг боломжийн утгаар 
	тохируулж өгөх нь зүйтэй юм.</para>

      <para>Ердийн хэрэглэгч <filename>/usr/share/examples/etc/make.conf</filename> 
	файлд байдаг <makevar>CFLAGS</makevar> болон 
	<makevar>NO_PROFILE</makevar> мөрүүдийг 
	<filename>/etc/make.conf</filename> уруу хуулж 
	тэдгээрийг тайлбар болгосныг болиулж нээхийг магадгүй хүсэж 
	болох юм.</para>

      <para>Бусад тодорхойлолтуудыг (<makevar>COPTFLAGS</makevar>, 
	<makevar>NOPORTDOCS</makevar> гэх зэрэг) шалгаж танд хамаатай 
	эсэхээс хамаарч оруулах эсэхээ шийдээрэй.</para>
    </sect2>

    <sect2 id="updating-etc">
      <title><filename>/etc</filename> дэх файлуудыг шинэчил</title>

      <para><filename>/etc</filename> сан нь таны системийн тохиргооны мэдээллийн 
	ихэнх хэсгийг агуулдгаас гадна системийг эхлүүлэхэд ажилладаг скриптүүд энд байдаг.
	Эдгээр скриптүүдийн зарим нь FreeBSD-ийн хувилбараас хувилбарт өөрчлөгддөг.</para>

      <para>Тохиргооны файлуудын зарим нь бас системийг ажиллуулахад өдөр тутам хэрэглэгддэг.
	Ялангуяа <filename>/etc/group</filename>-г дурдаж болно.</para>

      <para><command>make installworld</command> тушаалын суулгалт хийх хэсэг нь 
	зарим нэг хэрэглэгчийн нэр эсвэл бүлгүүд байж байна гэж тооцдог тохиолдлууд байдаг.
	Шинэчлэл хийж байх үед эдгээр хэрэглэгчид эсвэл бүлгүүд ихэнхдээ байхгүй байдаг. 
	Энэ нь шинэчлэл хийхэд асуудал учруулдаг. Зарим тохиолдолд <command>make buildworld</command> 
	нь эдгээр хэрэглэгчид эсвэл бүлгүүд байгаа эсэхийг шалгана.</para>

      <para>Үүний нэг жишээ нь <username>smmsp</username> хэрэглэгч нэмэгдсэн 
	тохиолдол юм. &man.mtree.8; нь <filename>/var/spool/clientmqueue</filename>-г 
	үүсгэхийг оролдох үед хэрэглэгчийн суулгалтын процесс энэ асуудлаас болж амжилтгүй
	болж байсан.</para>

      <para>Үүний шийдэл нь &man.mergemaster.8;-г ертөнцийг бүтээхээс урд <option>-p</option> 
	тохируулгатай ажиллуулах явдал юм. Энэ нь <maketarget>buildworld</maketarget> 
	эсвэл <maketarget>installworld</maketarget> тушаалыг амжилттай болгоход 
	зөвхөн шаардлагатай файлуудыг харьцуулдаг. Хэрэв таны хуучин <command>mergemaster</command> 
	хувилбар <option>-p</option> тохируулгыг дэмждэггүй бол эх модон дахь шинэ хувилбарыг 
	эхний удаа ажиллуулахдаа ашиглаарай:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Хэрэв та ялангуяа хэтэрхий санаа зовж байгаа бол тухайн бүлэгт харьяалагдаж байгаа
	нэрийг нь өөрчилж байгаа эсвэл устгаж байгаа ямар файлууд байгааг өөрийн системээс 
	шалгаарай:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>дээрх нь <replaceable>GID</replaceable> (энэ бүлгийн нэр байж болно эсвэл
	бүлгийн тоон ID байж болно) бүлгийн эзэмшдэг файлуудыг харуулна.</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Ганц хэрэглэгчийн горимд шилж</title>
      <indexterm><primary>ганц хэрэглэгчийн горим</primary></indexterm>

      <para>Та системийг ганц хэрэглэгчийн горимд эмхэтгэхийг хүсэж болох юм. 
	Энэ нь шинэчлэлтийг арай илүү хурдасгах илэрхий ашиг тустайгаас гадна 
	системийг дахин суулгах нь системийн стандарт хоёртын файлууд, 
	libraries буюу туслах сангууд, оруулгын файлууд гэх зэрэг системийн 
	маш олон чухал файлуудыг хөнддөг. Ажиллаж байгаа систем дээр эдгээрийг 
	өөрчлөх нь (ялангуяа хэрэв тухайн үед таны систем дээр идэвхтэй хэрэглэгчид 
	байвал) гай төвгийг өөрөө эрж байна гэсэн үг юм.</para>

      <indexterm><primary>олон хэрэглэгчийн горим</primary></indexterm>
      <para>Өөр нэг арга бол системийг олон хэрэглэгчийн горимд эмхэтгэж дараа нь 
	суулгахдаа ганц хэрэглэгчийн горимд шилжин хийх явдал юм. Хэрэв та энэ замаар 
	хийхийг хүсэж байвал бүтээлт дуустал дараах алхмууд дээр хүлээж байгаарай.
	Та <maketarget>installkernel</maketarget> эсвэл 
	<maketarget>installworld</maketarget> хийх хүртлээ ганц хэрэглэгчийн горимд 
	оролгүйгээр хүлээж байж болно.</para>

      <para>Супер хэрэглэгч болоод та доор дурдсаныг:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>ажиллаж байгаа системээс ганц хэрэглэгчийн горим уруу оруулахдаа 
	ажиллуулж болно.</para>

      <para>Өөр нэг арга нь системийг дахин ачаалаад ачаалалтын тушаал хүлээх мөрөн дээр 
	<quote>single user буюу ганц хэрэглэгч</quote> тохируулгыг сонгоорой. 
	Ингэхэд систем ганц хэрэглэгчийг ачаална. Бүрхүүлийн тушаал хүлээх мөрөнд та 
	доор дурдсан тушаалуудыг ажиллуулах шаардлагатай:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Энэ нь файлын системүүдийг шалгаж <filename>/</filename>-г 
	дахин унших/бичихээр дахин холбож бусад бүх UFS файлын системүүдийг 
	<filename>/etc/fstab</filename>-д заасны дагуу холбон дараа нь 
	swap-ийг идэмвхжүүлэх болно.</para>


        <note>
          <para>Хэрэв таны CMOS цаг нь GMT биш локал хугацаагаар тохируулагдсан бол 
		(хэрэв &man.date.1; тушаалын гаралт зөв цаг болон бүсийг харуулахгүй 
		бол энэ нь үнэн) та дараах тушаалыг бас ажиллуулах хэрэгтэй болж 
		болох юм:</para>
<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

          <para>Энэ нь таны локал цагийн бүсийн тохируулгуудыг зөвөөр тохируулж өгдөг &mdash; 
		үүнийг хийхгүй бол та дараа нь зарим асуудлуудтай тулгарч магадгүй.
          </para>
        </note>

    </sect2>

    <sect2 id="cleaning-usr-obj">
      <title><filename>/usr/obj</filename>-г устга</title>

      <para>Системийн хэсгүүд дахин бүтээгдсэнийхээ дараа (анхдагчаар) 
	<filename>/usr/obj</filename> дахь сангуудад байршдаг. Эдгээр сангууд нь 
	<filename>/usr/src</filename> дотор байгааг халхалдаг.</para>

      <para>Та <command>make buildworld</command> процессийг хурдасгаж болох бөгөөд 
	энэ санг бас устгаснаар хамаарлын зовлонгуудаас өөрийгөө магадгүй аврах болно.</para>

      <para><filename>/usr/obj</filename> доторх зарим файлуудад immutable 
	буюу хувиршгүй туг тавигдсан (дэлгэрэнгүй мэдээллийг &man.chflags.1;-с үзнэ үү ) 
	байж болох бөгөөд түүнийг эхлээд арилгах хэрэгтэй.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 id="updating-upgrading-compilebase">
      <title>Үндсэн системийг дахин эмхэтгэ</title>

      <sect3>
	<title>Гаралтыг хадгалах нь</title>

	<para>&man.make.1;-г ажиллуулахдаа гарах үр дүнг өөр файл уруу хадгалах нь 
	зүйтэй юм. Хэрэв ямар нэг юм болохоо боливол та алдааны мэдэгдлийн хуулбартай 
	байх болно. Энэ нь танд юу буруутсаныг шинжлэхэд чинь тус болохгүй байж болох боловч 
	та өөрийн энэ асуудлаа &os;-ийн аль нэг захидлын жагсаалт уруу илгээсэн тохиолдолд 
	бусдад тус болж болох юм.</para>

	<para>Үүнийг хамгийн амраар хийхийн тулд &man.script.1; тушаалыг бүх гаралтыг хадгалах 
	файлын нэрийг заасан параметрийн хамтаар ашиглана. Та үүнийг ертөнцийг дахин бүтээхээс 
	өмнөхөн нэн даруй хийж дараа нь процесс дууссаны дараа <userinput>exit</userinput> 
	гэж бичиж гарна.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out	 
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>	  
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Хэрэв та үүнийг хийх бол гаралтыг <filename>/tmp</filename> дотор 
	<emphasis>битгий </emphasis> хадгалаарай. Энэ сан нь таныг дахин ачаалсны 
	дараа цэвэрлэгдэж болох юм. Энэ файлыг хадгалах арай илүү боломжийн газар нь 
	<filename>/var/tmp</filename> (өмнөх жишээн дээрх шиг) эсвэл 
	<username>root</username> хэрэглэгчийн гэр сан байж болох юм.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>Үндсэн системийг эмхэтгэ</title>

	<para>Та <filename>/usr/src</filename> сан дотор байх 
	шаардлагатай:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(гэхдээ мэдээж таны код өөр газар байгаа тохиолдолд тэр сан уруугаа орох 
	     хэрэгтэй).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Ертөнцийг дахин бүтээхдээ та &man.make.1; тушаалыг ашиглана. Энэ 
	тушаал нь &os;-ийн агуулсан програмууд ямар дарааллаар дахин хэрхэн бүтээгдэх зэргийг 
	тайлбарласан <filename>Makefile</filename> файлаас заавруудыг уншдаг.</para>

	<para>Таны бичих тушаалын мөрийн ерөнхий хэлбэр нь дараах байдлаар байна:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>Энэ жишээн дээр <option>-<replaceable>x</replaceable></option> нь 
	&man.make.1; уруу таны дамжуулах тохируулга юм. &man.make.1;-н гарын авлагын хуудаснаас 
	та дамжуулж болох тохируулгуудын жишээг үзнэ үү.</para>

	<para><option>-D<replaceable>VARIABLE</replaceable></option>
	  тохируулга нь <filename>Makefile</filename> уруу хувьсагч дамжуулж байна. 
	<filename>Makefile</filename>-ийн ажиллагаа эдгээр хувьсагчуудаар 
	хянагдана. Эдгээр нь <filename>/etc/make.conf</filename> дотор 
	зааж өгсөн хувьсагчуудтай адил бөгөөд энэ нь тэдгээрийг тохируулах бас нэг өөр 
	арга юм.</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

	<para>тушаал нь профиль хийгдсэн сангууд бүтээгдэх ёсгүйг заах өөр нэг арга бөгөөд
	энэ нь <filename>/etc/make.conf</filename> дахь дараах</para>

	<programlisting>NO_PROFILE=    true 	#    Avoid compiling profiled libraries</programlisting>

	<para>мөрд харгалзах юм.</para>

	<para><replaceable>target</replaceable> нь &man.make.1;-д 
	таны юу хийхийг хэлж өгдөг. <filename>Makefile</filename> болгон 
	өөр өөр <quote>targets буюу даалгаврын төрлүүдийг</quote> тодорхойлдог 
	бөгөөд таны сонгосон төрөл юу болохыг тодорхойлдог.</para>

	<para>Зарим төрлүүд <filename>Makefile</filename>-д жагсаагдсан байх 
	бөгөөд гэхдээ эдгээр нь таныг ажиллуулахад зориулагдаагүй. Харин тэдгээр нь 
	системийг дахин бүтээхэд шаардлагатай алхмуудыг хэд хэдэн дэд алхмуудад хуваахын 
	тулд бүтээх процессод хэрэглэгддэг.</para>

	<para>Ихэнх тохиолдолд та &man.make.1; уруу ямар ч параметр дамжуулах 
	хэрэггүй бөгөөд тэгэхээр таны тушаал дараахтай ижил байж болно:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para>дээрх <replaceable>target</replaceable> нь олон бүтээх тохируулгуудын 
	нэг болно. Эхний төрөл нь үргэлж <makevar>buildworld</makevar> 
	байх ёстой.</para>

	<para>Нэртэйгээ адилаар <maketarget>buildworld</maketarget> нь 
	<filename>/usr/obj</filename> дотор бүрэн гүйцэд шинэ модыг бүтээх бөгөөд 
	өөр нэг төрөл болох <maketarget>installworld</maketarget> нь 
	энэ модыг тухайн машин дээр суулгадаг.</para>

	<para>Тусдаа тохируулгуудтай байх нь хоёр шалтгаанаар маш ач холбогдолтой юм. 
	Нэгдүгээрт энэ нь бүтээлтийг таны ажиллаж байгаа системийн ямар ч хэсэгт нөлөөлөхгүйгээр 
	аюулгүйгээр хийхийг танд зөвшөөрдөг. Бүтээлт нь <quote>өөр дээрээ хийгдэнэ (self hosted)</quote>.
	Ийм болохоор та <maketarget>buildworld</maketarget> тушаалыг олон 
	хэрэглэгчийн горимд ажиллаж байгаа машин дээр буруу нөлөөллөөс айлгүйгээр аюулгүйгээр 
	хийж болно. Гэхдээ <maketarget>installworld</maketarget> хэсгийн хувьд ганц 
	хэрэглэгчийн горимд хийхийг танд зөвлөдөг.</para>

	<para>Хоёрдугаарт энэ нь сүлжээн дэх олон машинуудыг шинэчлэхэд 
	NFS холболтуудыг ашиглахыг танд зөвшөөрдөг. Хэрэв танд гурван машин байгаа бөгөөд 
	<hostid>A</hostid>, <hostid>B</hostid> болон <hostid>C</hostid> 
	машинуудыг шинэчлэхийг хүсвэл <command>make
	  buildworld</command> болон <command>make installworld</command> 
	тушаалыг <hostid>A</hostid> дээр ажиллуулна.  Дараа нь <hostid>B</hostid> болон <hostid>C</hostid> 
	 машинууд <hostid>A</hostid> дээрх <filename>/usr/src</filename>
	  болон <filename>/usr/obj</filename> сангуудыг NFS холболт хийн 
	<command>make installworld</command>-г ажиллуулж 
	бүтээлтийн үр дүнг <hostid>B</hostid> болон <hostid>C</hostid> дээр 
	суулгаж болох юм.</para>

	<para><maketarget>world</maketarget> төрөл байсаар байгаа хэдий ч 
	танд түүнийг ашиглахгүй байхыг зөвлөж байна.</para>

	<para>Дараах тушаалыг ажиллуул</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>
 
        <para>Хэд хэдэн зэрэгцээ процессуудыг үүсгэх <option>-j</option> тохируулгыг 
	<command>make</command> тушаалд зааж өгөх боломжтой. Энэ нь олон CPU-тэй 
	машинууд дээр хамгийн их ашигтай. Гэхдээ эмхэтгэх процессийн ихэнх нь CPU дээр биш  
	IO дээр ажилладаг болохоор энэ нь бас нэг CPU-тэй машинууд дээр ашигтай юм.</para>

	<para>Ердийн нэг CPU-тэй  машин дээр та доор дурдсаныг ажиллуулж болох юм:</para>
	  
	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; нь 4 хүртэлх процессийг нэгэн зэрэг ажиллуулах юм. Захидлын 
	жагсаалтуудад илгээгдсэн туршлагаас харахад энэ нь ерөнхийдөө ажиллагааг хамгийн сайн
	хангаж хурдасгадаг байна.</para>

	<para>Хэрэв та олон CPU машинтай бөгөөд SMP тохируулагдсан цөм ашиглаж байвал 
	утгыг 6-аас 10 хүртэл болгож хэр хурдсаж байгааг хараарай.</para>
      </sect3>
      
      <sect3>
	<title>Хугацаа</title>
	<indexterm>
	  <primary><quote>ертөнцийг</quote> дахин бүтээх нь</primary>
	  <secondary>хугацаа</secondary>
	</indexterm>

        <para>Бүтээхэд шаардагдах хугацаанд олон хүчин зүйлс нөлөөлдөг, гэхдээ 
	нэлээн сүүлийн үеийн машинуудын хувьд &os.stable; модыг процессийн явцад ямар нэгэн 
	заль мэх эсвэл дөт зам ашиглалгүйгээр бүтээхэд зөвхөн нэг юм уу эсвэл хоёр цаг л 
	шаардагдах болох юм.  &os.current; модны хувьд арай удах болов уу.</para>
      </sect3>
    </sect2>
    
    <sect2 id="new-kernel">
      <title>Шинэ цөмийг эмхэтгэж суулга</title>
      <indexterm>
        <primary>цөм</primary>
	<secondary>суулгах нь</secondary>
      </indexterm>

      <para>Та өөрийн шинэ системийн давуу талыг бүгдийг нь авахын тулд цөмөө дахин эмхэтгэх 
	хэрэгтэй. Зарим нэг санах ойн бүтцүүд өөрчлөгдсөн байх талтай бөгөөд 
	&man.ps.1; болон &man.top.1; зэрэг програмууд нь цөм болон эх кодын хувилбарууд 
	адил болтол ажилладаггүй болохоор эмхэтгэх нь үнэндээ чухал хэрэгцээтэй юм.</para>

      <para>Үүнийг хамгийн хялбараар аюулгүйгээр хийхийн тулд <filename>GENERIC</filename> 
	дээр тулгуурласан цөмийг бүтээж суулгах явдал юм. <filename>GENERIC</filename> нь 
	таны системийн хувьд хэрэгцээтэй төхөөрөмжүүдийг агуулаагүй байж болох боловч 
	таны системийг ядаж ганц хэрэглэгчийн горимд ачаалахад шаардлагатай бүгдийг агуулсан 
	байх ёстой. Шинэ систем зөв ажиллуулахад энэ сайн тест болж өгдөг. 
	<filename>GENERIC</filename>-с ачаалж таны систем ажиллаж байгааг шалгасны 
	дараа та өөрийн ердийн цөмийн тохиргооны файл дээр тулгуурлан шинэ цөмөө бүтээж 
	болох юм.</para>

      <para>&os; дээр шинэ цөм бүтээхээсээ өмнө <link
        linkend="make-buildworld">ертөнцийг бүтээх</link> нь чухал юм.</para>

      <note><para>Хэрэв та өөрчлөн тохируулсан цөмийг бүтээхийг хүсэж тохиргооны файлаа аль 
	хэдийн үүсгэсэн бол доор дурдсантай адилаар 
	<literal>KERNCONF=<replaceable>MYKERNEL</replaceable></literal> 
	гэж ашиглаарай:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </note>

      <para>Хэрэв та <literal>kern.securelevel</literal> хувьсагчийг 
	1-ээс дээш болгон ихэсгэсэн <emphasis>бөгөөд</emphasis> 
	<literal>noschg</literal> эсвэл түүнтэй адил тугуудыг өөрийн цөмийн хоёртын 
	файлд тавьсан бол <maketarget>installkernel</maketarget> хийхийн тулд 
	та ганц хэрэглэгчийн горимд шилжин орох шаардлагатай байж болох юм. Үгүй бол 
	та энэ хоёр тушаалыг олон хэрэглэгчийн горимоос ямар ч асуудалгүйгээр 
	ажиллуулах ёстой. <literal>kern.securelevel</literal>-ийн талаар 
	дэлгэрэнгүйг &man.init.8; болон төрөл бүрийн файлын тугуудын талаар дэлгэрэнгүйг 
	&man.chflags.1; гарын авлагын хуудаснуудаас үзнэ үү.</para>
    </sect2>

    <sect2 id="new-kernel-singleuser">
      <title>Ганц хэрэглэгчийн горим уруу дахин ачаалан ор</title>
      <indexterm><primary>ганц хэрэглэгчийн горим</primary></indexterm>

      <para>Та шинэ цөмийн ажиллагааг шалгахын тулд ганц хэрэглэгчийн горимд дахин 
	ачаалан орох хэрэгтэй. Үүнийг <xref linkend="makeworld-singleuser"> 
	дахь заавруудын дагуу хийнэ.</para>
    </sect2>

    <sect2 id="make-installworld">
      <title>Шинэ системийн хоёртын файлуудыг суулга</title>

      <para>Та шинэ системийн хоёртын 
	файлуудыг суулгахын тулд <maketarget>installworld</maketarget> 
	тушаалыг ашиглах шаардлагатай.</para>

      <para>Доор дурдсаныг ажиллуулна</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Хэрэв та <command>make buildworld</command> тушаалын мөрөнд 
	хувьсагчуудыг зааж өгсөн бол тэдгээр хувьсагчуудыг 
	<command>make installworld</command> тушаалын мөрөнд бас адилаар 
	зааж өгөх хэрэгтэй. Энэ бусад тохируулгуудын хувьд заавал шаардлагатай биш 
	байж болох юм; жишээ нь <option>-j</option> тохируулга 
	<maketarget>installworld</maketarget>-той цуг хэзээ ч хэрэглэгдэх 
	ёсгүй.</para>
	
	<para>Жишээ нь хэрэв та доор дурдсаныг ажиллуулсан бол:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>хоёртын файлуудыг дараах тушаалаар суулгана:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>ингэхгүй бол <command>make buildworld</command> тушаалын ажиллах 
	явцад бүтээгдээгүй профиль хийгдсэн сангуудыг (libraries) суулгахыг оролдох болно.</para>
      </note>
    </sect2>

    <sect2 id="post-installworld-updates">
      <title><command>make installworld</command> тушаалаар шинэчлэгдээгүй файлуудыг шинэчил</title>
      
      <para>Ертөнцийг дахин бүтээх нь зарим нэг сангуудыг (ялангуяа <filename>/etc</filename>, 
	<filename>/var</filename> болон <filename>/usr</filename>) шинэ болон 
	өөрчлөгдсөн тохиргооны файлуудаар шинэчилдэггүй.</para>

      <para>Эдгээр файлуудыг хамгийн амархнаар шинэчлэх арга нь &man.mergemaster.8;-г 
	ашиглах явдал юм, гэхдээ та хэрэв хүсвэл үүнийг гараар ажиллуулах боломжтой юм.
	Аль ч аргыг сонголоо гэсэн  ямар нэгэн зүйл буруутсан тохиолдолд сэргээх боломжтойгоор 
	<filename>/etc</filename>-г нөөцөлж авах нь зүйтэй юм.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Том</firstname>
	    <surname>Рөүдс</surname>
	    <contrib>Хувь нэмэр болгон оруулсан </contrib>
	  </author>
	</authorgroup>
      </sect3info>
      <title><command>mergemaster</command></title>
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>&man.mergemaster.8; хэрэгсэл нь <filename>/etc</filename> дэх 
	таны тохиргооны файлууд  болон <filename>/usr/src/etc</filename> эх модон дахь 
	тохиргооны файлуудын ялгааг тодорхойлоход танд тусалдаг Bourne скрипт юм. 
	Энэ нь системийн тохиргооны файлуудыг эх модон дахь тохиргооны файлуудаар шинэчлэх 
	зориулалттай бидний зөвлөдөг шийдэл юм.</para>

      <para>Эхлэхийн тулд өөрийн тушаал оруулах мөрөнд ердөө л <command>mergemaster</command>-г 
	бичиж түүний эхлэхийг нь хараарай. <command>mergemaster</command> нь түр зуурын 
	root орчныг <filename>/</filename>-с доошлуулан бүтээж төрөл бүрийн системийн тохиргооны 
	файлуудаар дамждаг. Тэдгээр файлууд нь таны системд суулгагдсан файлуудтай харьцуулагддаг. 
	Энэ үед хоорондоо ялгаатай файлууд &man.diff.1; хэлбэрээр үзүүлэгддэг бөгөөд 
	<option>+</option> тэмдэгтээр нэмэгдсэн эсвэл өөрчлөгдсөн мөрүүдийг 
	<option>-</option> тэмдэгтээр устгагдсан эсвэл шинэ мөрөөр солигдсон мөрүүдийг 
	харуулдаг. &man.diff.1;-н синтакс болон файлын өөрчлөлтүүдийг хэрхэн үзүүлдэг талаар 
	дэлгэрэнгүй мэдээллийг &man.diff.1; гарын авлагын хуудаснаас үзнэ үү.</para>

      <para>&man.mergemaster.8; нь зөрчилдөөнүүдийг үзүүлсэн файл болгоныг харуулдаг бөгөөд 
	энэ үед танд шинэ файлыг устгах (түр зуурын файл гэгддэг), түр зуурын файлыг өөрчлөлгүйгээр 
	суулгах, суусан байгаа файлтай түр зуурын файлыг нийлүүлэх эсвэл &man.diff.1;-н 
	гаралтыг дахин харах сонголтыг үзүүлэх болно.</para>

      <para>Түр зуурын файлыг устгахыг сонгосноор бид одоо байгаа файлаа хэвээр өөрчлөлгүй үлдээж 
	шинэ хувилбарыг устгахыг хүсэж байгаагаа &man.mergemaster.8;-д хэлж байна гэсэн үг юм. 
	Хэрэв та одоо байгаа файлаа өөрчлөх шалтгааныг олж харахгүй байгаагаас бусад тохиолдолд 
	энэ сонголтыг хийхийг зөвлөдөггүй. Та ямар ч үед &man.mergemaster.8; тушаал хүлээх 
	мөрөн дээр <keycap>?</keycap> гэж бичин тусламж авч болох юм. Хэрэв хэрэглэгч 
	файлыг орхихоор сонгосон бол энэ нь бусад бүх файлуудтай ажилсны дараа дахин үзүүлэгдэн 
	хэрэглэгчээс тушаал хүлээх болно.</para>

      <para>Өөрчлөгдөөгүй түр зуурын файлыг суулгахыг сонгосноор одоо байгаа файлыг шинээр 
	сольдог. Ихэнх өөрчлөгдөөгүй файлуудын хувьд энэ нь хамгийн шилдэг сонголт юм.</para>

      <para>Файлыг нийлүүлэхийг сонгосноор текст засварлагч болон хоёр файлын агуулгыг танд 
	харуулах болно. Та дэлгэцийн хоёр талд байрласан тэдгээр хоёр файлыг хоёуланг нь 
	шалган аль аль талаас нь хэрэгтэй хэсгүүдийг сонгон эцсийн бүтээгдэхүүн гаргаж аван 
	нийлүүлж болно. Файлууд нь дэлгэцийн хоёр талд байрлан харьцуулагдах явцад 
	<keycap>l</keycap> түлхүүр таны зүүн талын агуулгыг сонгодог бол 
	<keycap>r</keycap> түлхүүр нь таны баруун тал дахь агуулгыг сонгох юм. 
	Гарах эцсийн үр дүн нь хоёр файлын хоёулангийн хэсгүүдийг агуулсан файл болох бөгөөд 
	түүнийг дараа нь суулгах боломжтой болох юм. Энэ сонголтыг хэрэглэгчийн тохиргоонуудад 
	хийгдсэн өөрчлөлтүүдтэй файлуудын хувьд хэрэглэх нь зуршил болжээ.</para>

      <para>&man.diff.1;-ээс гарах үр дүнг дахин харахыг сонгосноор өмнө нь 
	&man.mergemaster.8; файлын өөрчлөлтүүдийг харуулан таны сонголтыг хүлээсний 
	нэгэн адилыг дахин харуулдаг.</para>

      <para>&man.mergemaster.8; системийн файлуудтай ажиллаж дууссаны дараа 
	танаас бусад сонголтуудыг хийхийг хүлээдэг. &man.mergemaster.8; тушаал 
	нууц үгийн файлыг дахин бүтээхийг хүсэж байгаа эсэхийг танаас асууж үлдсэн 
	түр зуурын файлуудыг устгах сонголтыг үзүүлэн дуусдаг.</para>
      </sect3>

      <sect3>
	<title>Гараар шинэчлэх</title>

      <para>Хэрэв та гараар шинэчлэхийг хүсвэл гэхдээ та <filename>/usr/src/etc</filename> 
	сангаас <filename>/etc</filename> сан уруу файлуудыг зүгээр л дарж хуулж ажиллуулж 
	чадахгүй. Зарим файлуудыг эхлээд <quote>суулгах</quote> хэрэгтэй. Учир нь 
	<filename>/usr/src/etc</filename> сан таны <filename>/etc</filename> 
	сангийн хуулбар шиг байхаар <emphasis>харагддагүй</emphasis>. Мөн 
	<filename>/usr/src/etc</filename> санд байдаггүй хэрнээ  
	<filename>/etc</filename> сан дотор байх шаардлагатай зарим файлууд 
	байдаг.</para>

      <para>Хэрэв та &man.mergemaster.8; (зөвлөсний дагуу) ашиглаж байвал та 
	<link linkend="updating-upgrading-rebooting">дагаагийн хэсэг</link> уруу 
	орж болно.</para>

      <para>Үүнийг гараар хамгийн хялбар аргаар хийхийн тулд файлуудыг шинэ сан уруу 
	суулгаж нэг бүрчлэн өөрчлөлтүүдийг хайн ажиллах хэрэгтэй.</para>
    
      <warning>
	<title>Өөрт байгаа <filename>/etc</filename>-г нөөцөл</title>

	<para>Онолоор бол автоматаар энэ санд юу ч хүрдэггүй ч үүнд үргэлж итгэлтэй 
	байх хэрэгтэй. Тэгэхээр өөрийн байгаа <filename>/etc</filename> санг 
	хаа нэг аюулгүй газар хуулах хэрэгтэй. Доорхтой адилаар:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para><option>-R</option> нь рекурсив хуулбар хийх бөгөөд 
	<option>-p</option> нь файлуудын хугацаа, эзэмшигч гэх мэтийг 
	хадгалдаг.</para>
      </warning>
      
      <para>Та шинэ <filename>/etc</filename> болон бусад файлуудыг суулгахын тулд 
	хоосон сангууд бүтээх хэрэгтэй. <filename>/var/tmp/root</filename> нь 
	боломжийн сонголт болох бөгөөд энэ сангийн доор хэд хэдэн дэд сангууд бас
	шаардлагатай болно.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Энэ нь шаардлагатай сангийн бүтцийг бүтээж файлуудыг суулгадаг. 
	<filename>/var/tmp/root</filename> дотор үүсгэгдсэн олон дэд сангууд 
	хоосон бөгөөд тэдгээрийг устгах шаардлагатай байдаг. Үүнийг хамгийн хялбараар 
	хийхийн тулд:</para>
      
      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>
      
      <para>Энэ нь бүх хоосон сангуудыг устгана. (Хоосон биш сангуудын тухай анхааруулгуудыг 
	гаргахгүйн тулд стандарт алдаа нь <filename>/dev/null</filename> 
	уруу илгээгддэг.)</para>

      <para>Одоо <filename>/var/tmp/root</filename> нь <filename>/</filename>-с 
	доор байрлах тохирох байрлалуудад байршуулах ёстой бүх файлуудыг агуулсан байх болно.
	Та одоо эдгээр файл бүрийг шалгаж танд байгаа файлуудаас хэрхэн ялгаатай болохыг 
	тогтоох хэрэгтэй.</para>
    
      <para><filename>/var/tmp/root</filename> дотор суулгагдсан зарим файлуудын нэр 
	урдаа <quote>.</quote> тэмдэгттэй байдгийг анхаарна уу. Энэ баримтыг бичиж байх үед 
	ийм файлуудтай адил файлууд <filename>/var/tmp/root/</filename> болон 
	<filename>/var/tmp/root/root/</filename> сан дахь бүрхүүлийн эхлүүлэх файлууд 
	байсан, гэхдээ (таны хэзээ үүнийг уншиж байгаагаас хамаарч) өөр бусад файлууд байхыг 
	үгүйсгэхгүй. Тэдгээрийг олж харахын тулд <command>ls -a</command> тушаалыг 
	заавал ашиглаарай.</para>
    
      <para>Үүнийг хамгийн хялбар аргаар хийж хоёр файлыг харьцуулахын тулд &man.diff.1; 
	тушаалыг ашиглах явдал юм:</para>
    
      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>
      
      <para>Энэ нь таны <filename>/etc/shells</filename> файл болон 
	шинэ <filename>/var/tmp/root/etc/shells</filename> файлын хоорондын 
	ялгааг харуулна. Эдгээрийг ашиглаж өөрийн хийсэн өөрчлөлтүүдийг нийлүүлэх эсвэл 
	өөрийн хуучин файл дээрээс хуулах эсэхээ шийдээрэй.</para>
    
      <tip>
	<title>Хувилбаруудын Хоорондох Ялгаануудыг Хялбараар Харьцуулахын Тулд Та 
	Шинэ Root Сангаа Тухайн Үеийн Хугацаагаар Нэрлээрэй</title>

	<para>Ертөнцийг байнга дахин бүтээнэ гэдэг нь <filename>/etc</filename>-г 
	та бас байнга шинэчилнэ гэсэн үг бөгөөд энэ нь ердөө л жижиг хэвшмэл ажил юм.</para>

	<para>Та энэ процессийг <filename>/etc</filename> уруу нийлүүлсэн 
	өөрийн хамгийн сүүлийн өөрчлөгдсөн файлуудыг хадгалснаар хурдасгаж болох юм. 
	Дараах процедур үүнийг хэрхэн хийж болох нэг санааг өгч байна.</para>

	<procedure>
	  <step>
	    <para>Ертөнцийг жирийнээр бүтээ. <filename>/etc</filename> болон 
		бусад сангуудыг шинэчлэхийг хүсэхдээ тухайн цаг дээр тулгуурласан нэр бүхий 
		санг өг. Хэрэв та үүнийг 1998 оны 2 сарын 14-нд хийж байгаа бол дараах 
		байдлаар хийнэ:</para>
	  
	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>
	  
	  <step>
	    <para>Энэ сангийн өөрчлөлтүүдийг дээр дурдсаны дагуу нийлүүл.</para>
	    
	    <para>Та дууссаныхаа дараа <filename>/var/tmp/root-19980214</filename> 
		санг <emphasis>битгий</emphasis> устгаарай.</para>
	  </step>
	  
	  <step>
	    <para>Та эхийн хамгийн сүүлийн хувилбарыг татан авч дахин бүтээхдээ 1-р алхмыг дага. 
		Энэ нь танд шинэ сан өгөх бөгөөд <filename>/var/tmp/root-19980221</filename> 
		гэж нэрлэгдсэн байж болох юм (хэрэв та шинэчлэлтүүдийг хийхдээ долоо хоног 
		хүлээсэн бол).</para>
	  </step>
	  
	  <step>
	    <para>Та одоо &man.diff.1; ашиглан хоёр сангийн хооронд рекурсив diff үүсгэж 
		долоо хоногийн хооронд хийгдсэн өөрчлөлтүүдийг харж болно:</para>
	      
	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>
	  
	    <para>Ихэнхдээ энэ нь <filename>/var/tmp/root-19980221/etc</filename> болон 
		<filename>/etc</filename> хоёрын хоорондох өөрчлөлтүүдийг бодох юм бол 
		харьцангуй бага өөрчлөлтүүд байдаг. Өөрчлөлтүүд нь арай бага болохоор тэдгээр 
		өөрчлөлтүүдийг өөрийн <filename>/etc</filename> сан уруу шилжүүлэх нь 
		илүү хялбар байдаг.</para>
	  </step>
	  
	  <step>
	    <para>Та одоо хоёр <filename>/var/tmp/root-*</filename> сангуудын аль хуучныг 
		устгаж болно:</para>
	      
	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>
	  
	  <step>
	    <para><filename>/etc</filename> уруу өөрчлөлтүүдийг 
		нийлүүлэх болгондоо энэ процессийг давтах хэрэгтэй.</para>
	  </step>
	</procedure>

	<para>Та &man.date.1;-г ашиглан сангийн нэрсийг автоматаар үүсгэж 
		болно:</para>
	  
	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>
    
    <sect2 id="updating-upgrading-rebooting">
      <title>Дахин ачаалах нь</title>
      
      <para>Та ерөнхийдөө ингээд хийгээд дуусч байна. Та бүх зүйл байх ёстой байрандаа байгаа эсэхийг шалгасныхаа 
	дараа системийг дахин ачаалж болно. Энгийн &man.shutdown.8; үүнийг 
	хийх болно:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Дууслаа</title>
      
      <para>Одоо та өөрийн &os; системийг амжилттайгаар шинэчлээд дууссан байх 
		ёстой. Баяр хүргэе.</para>
      
      <para>Хэрэв юмс шал буруугаар эргэвэл системийн тухайн хэсгийг дахин бүтээхэд амархан 
	байдаг. Жишээ нь хэрэв та шинэчлэлтийн явцад эсвэл <filename>/etc</filename>-г 
	нийлүүлэх явцад санамсаргүйгээр <filename>/etc/magic</filename> файлыг 
	устгасан бол &man.file.1; тушаал ажиллахаа больно. Ийм тохиолдолд дараах 
	засварыг ажиллуулж болох юм:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>    
    
    <sect2 id="updating-questions">
      <title>Асуултууд</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Өөрчлөлт бүрт зориулан ертөнцийг дахин бүтээх хэрэгтэй юу?</para>
	  </question>

	  <answer>
            <para>Үүнд хялбар хариулт байхгүй, учир нь өөрчлөлтийн цаад утга чанараас 
		хамаарна. Жишээ нь хэрэв та <application>CVSup</application>-г 
		дөнгөж ажиллуулахад дараах файлууд шинэчлэгдэж байгааг үзүүлж байгаа бол:</para>
      
	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>магадгүй бүхэл ертөнцийг дахин бүтээх хэрэггүй байж болох юм.
		Та тохирох дэд сангууд уруу орж <command>make all install</command> 
		гэж тушаалыг өгөөд л болох юм. Хэрэв зарим нэг гол чухал зүйл жишээ нь 
		<filename>src/lib/libc/stdlib</filename> өөрчлөгдсөн бол 
		та ертөнцийг эсвэл хамгийн багаар бодоход статикаар холбогдсон (statically linked) 
		түүний тэдгээр хэсгүүдийг дахин бүтээх шаардлагатай болно.</para>
      
	    <para>Эцсийн эцэст энэ нь танаас л хамаарна. Та жишээ нь хоёр долоо хоног тутам 
		ертөнцийг дахин бүтээж тэр хоёр долоо хоногийн хугацаанд өөрчлөлтүүдийг 
		хуримтлуулж байгаадаа сэтгэл хангалуун байж болно. Эсвэл та зөвхөн өөрчлөгдсөн 
		зүйлсүүдийг дахин бүтээхийг хүсэж магадгүй бөгөөд бүх хамаарлуудыг шийднэ 
		гэдэгтээ итгэлтэй байх хэрэгтэй.</para>
      
	    <para>Тэгээд мэдээж энэ бүхэн таны ямар давтамжтайгаар шинэчлэхийг хүсдэг болон 
		&os.stable; эсвэл &os.current;-ийн алийг дагаж байгаагаас хамаарах 
		болно.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Миний эмхэтгэл маш олон дохио 11 (эсвэл бусад дохионы дугаар) 
		алдаагаар амжилтгүй болсон. Юу болсон юм бол?</para>
	  </question>
    <indexterm><primary>дохио 11</primary></indexterm>

	  <answer>

	    <para>Энэ нь ихэвчлэн тоног төхөөрөмжийн асуудлыг илэрхийлдэг. 
		Ертөнцийг (дахин) бүтээх нь өөрийн тоног төхөөрөмжийг ачаалах тест 
		хийх үр дүнтэй арга бөгөөд удаа дараа санах ойн асуудлууд байвал
		тэдгээрийг илрүүлдэг. Эмхэтгэгч нь сонин/хачин дохионуудыг хүлээн авч 
		ид шидийн байдлаар амжилтгүй болсноор тэдгээр асуудлууд нь өөрсдийгөө 
		зарлан тунхагладаг.</para>
      
	    <para>Хэрэв та бүтээлтийг дахин эхлүүлээд тэр нь процессийн өөр өөр хэсэгт 
		амжилтгүй болж байвал энэ нь үүнийг тодоор зааж байна 
		гэсэн үг юм.</para>
      
	    <para>Энэ тохиолдолд та өөрийн машин дахь бүрэлдэхүүн хэсгүүдээ өөрчлөн 
		нэгээс нөгөөд сольж тавин аль нь ажиллахгүй байгааг олохоос өөр зүйл 
		хийж чадахгүй л болов уу.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Би дууссаныхаа дараа <filename>/usr/obj</filename>-г устгаж болох уу?</para>
	  </question>
	  
	  <answer>
	    <para>Товчхондоо бол болно.</para>
      
	    <para><filename>/usr/obj</filename> нь эмхэтгэх үед бүтээгдсэн бүх 
		обьект файлуудыг агуулдаг. Жирийн үед <command>make buildworld</command> 
		процессийн эхний алхмуудын нэг нь энэ санг устгаад цоо шинээр эхлэх явдал 
		юм. Энэ тохиолдолд <filename>/usr/obj</filename>-г дууссаныхаа 
		дараа байлгаад байх нь ухаалаг биш бөгөөд үүнийг устгаснаар ихээхэн хэмжээний дискний зайг 
		суллах болно (одоогоор 2&nbsp;GB орчим).</para>
      
	    <para>Гэхдээ хэрэв та юу хийж байгаагаа мэдэж байгаа бол <command>make buildworld</command> 
		хийхдээ энэ алхмыг алгасаж болно. Энэ нь дараа дараагийн бүтээлтийг илүү хурдасгадаг 
		бөгөөд учир нь ихэнх эхүүд дахин эмхэтгэх шаардлагагүй байдаг. Үүний сул тал нь 
		баригдашгүй хамаарлын асуудлууд илэрч таны бүтээлтийг хачин байдлаар амжилтгүй 
		болгодог. Хэн нэгэн илүү дөтлөх гэснээсээ болоод амжилтгүй болсныг мэдэлгүй өөрийн 
		бүтээлтийг амжилтгүй болсныг гомдоллосноор &os;-ийн захидлын жагсаалтуудад 
		хий дэмий шуугианыг удаа дараа  үүсгэдэг билээ.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Тасалдсан бүтээлтүүдийг үргэлжлүүлж болох уу?</para>
	  </question>

	  <answer>
	    <para>Энэ нь асуудлыг олох хүртлээ та хэр хол явснаас хамаарна.</para>
	    <para><emphasis>Ерөнхийдөө</emphasis> (энэ нь хэцүү бас хурдан дүрэм биш)  
		<command>make buildworld</command> процесс нь үндсэн 
		багажуудын (&man.gcc.1;, болон &man.make.1; зэрэг) болон системийн 
		сангуудын шинэ хуулбаруудыг бүтээдэг. Тэдгээр багажууд болон сангууд нь 
		дараа нь суулгагддаг. Шинэ багажууд болон сангууд дараа нь 
		өөрсдийгөө дахин бүтээхэд ашиглагддаг бөгөөд дахин суулгагддаг. Бүхэл бүтэн 
		систем (одоо &man.ls.1; эсвэл &man.grep.1; зэрэг ердийн хэрэглэгчийн програмууд) 
		дараа нь шинэ системийн файлуудтайгаар дахин бүтээгддэг.</para>

	    <para>Хэрэв та сүүлийн шатанд байгаа бөгөөд та үүнийг мэдэж байгаа бол (та 
		хадгалж байгаа гаралтаас харсан болохоор) та дараах тушаалыг ажиллуулж 
		(бараг л аюулгүйгээр) болно:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Энэ нь өмнөх <command>make buildworld</command> тушаалын 
		хийснийг буцаахгүй.</para>

	    <para>Хэрэв та доорх мэдэгдлийг :</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para><command>make buildworld</command> тушаалын гаралт дээр харсан 
		бол магадгүй тэгж хийх нь аюулгүй байж болох юм.</para>
	    
	    <para>Хэрэв та тийм мэдэгдэл харахгүй байгаа бол эсвэл та итгэлтэй биш байгаа бол 
		харамсахаасаа өмнө аюулгүй байдлыг бодож бүтээлтийг бүр эхнээс нь дахин эхлүүлсэн нь 
		дээр юм.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Би ертөнцийг бүтээхийг хэрхэн хурдасгах вэ?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Ганц хэрэглэгчийн горимд ажиллуул.</para>
	      </listitem>
	      
	      <listitem>
		<para><filename>/usr/src</filename> болон
		  <filename>/usr/obj</filename> сангуудыг тус тусдаа байх дискнүүд 
		дээр тус тусдаа байх файлын системүүд дээр байрлуул. Хэрэв боломжтой бол 
		эдгээр дискнүүдийг тус тусад нь дискний хянагчууд дээр байрлуул.</para>
	      </listitem>
	      
	      <listitem>
		<para>&man.ccd.4; (нийлүүлсэн дискний драйвер) төхөөрөмж ашиглан 
		эдгээр файлын системүүдийг олон дискнүүдийн дагуу байрлуулах нь бас  
		арай илүү хурдасгах юм.</para>
	      </listitem>
	      
	      <listitem>
		<para>Профиль хийгдэхийг (<filename>/etc/make.conf</filename> файлд 
		<quote>NO_PROFILE=true</quote> гэж зааж өг) болиул. Танд энэ бараг 
		гарцаагүй хэрэггүй.</para>
	      </listitem>
	      
	      <listitem>
		<para><filename>/etc/make.conf</filename> файлд бас 
		<makevar>CFLAGS</makevar>-г <option>-O -pipe</option> гэдэгтэй 
		адилаар заа. <option>-O2</option> оновчлол нь илүү удаан байдаг бөгөөд 
		<option>-O</option> болон <option>-O2</option> оновчлолын 
		ялгаа ихэвчлэн өчүүхэн байдаг. <option>-pipe</option> нь эмхэтгэгчид 
		холбооны зориулалтаар түр зуурын файлуудыг биш хоолойнуудыг ашиглахыг 
		зөвшөөрдөг бөгөөд энэ нь дискэнд хандах хандалтыг (санах ойг илүүтэй хэрэглэж) 
		багасгадаг.</para>
	      </listitem>
	      
	      <listitem>
		<para><option>-j<replaceable>n</replaceable></option> тохируулгыг 
		&man.make.1;-д дамжуулж олон процессийг зэрэгцээгээр ажиллуул. Энэ нь  
		танд ганц эсвэл олон процессортой машин аль нь ч байсан ялгаагүйгээр ихэвчлэн тусалдаг.</para>
	      </listitem>
	      
	      <listitem><para><filename>/usr/src</filename>-г агуулж байгаа файлын 
		систем <option>noatime</option> тохируулгаар холболт хийгдэж (эсвэл салгагдаж) 
		болно. Энэ нь файлын систем файл уруу хандах хандалтын хугацааг бүртгэхийг 
		болиулдаг. Танд магадгүй энэ мэдээлэл бараг л хэрэггүй биз ээ.</para>
		  
		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>
		  
		  <warning>
		    <para>Энэ жишээ <filename>/usr/src</filename> нь өөрийн файлын 
			систем дээр байгаа гэж тооцож байгаа болно. Хэрэв энэ нь тийм биш бол 
			(хэрэв энэ сан жишээ нь <filename>/usr</filename>-ийн хэсэг маягаар 
			байгаа бол) та <filename>/usr/src</filename>-г биш харин тэр 
			файлын системээ холболтын цэг болгон ашиглах хэрэгтэй.</para>
		  </warning>
	      </listitem>
	      
	      <listitem>
		<para><filename>/usr/obj</filename>-г агуулж байгаа файлын систем 
		<option>async</option> тохируулгатай холболт хийгдэж (эсвэл салгагдаж) 
		болно. Энэ нь диск уруу хийх бичилтийг асинхроноор буюу зэрэг биш хийлгэдэг. 
		Өөрөөр хэлбэл бичилт нэн даруй хийгдээд өгөгдөл диск уруу цөөн секундын дараа 
		бичигддэг. Энэ нь бичилтүүдийг бүлэглэхийг зөвшөөрч маш их үр дүнтэйгээр 
		ажиллагааг хурдасгаж болох юм.</para>

		<warning>
		  <para>Энэ тохируулга нь таны файлын системийг илүү 
			эмзэг болгохыг санаарай. Тэжээл тасалдаж машин дахин ачаалах үед 
			файлын систем сэргээж болшгүй төлөвт орох магадлал энэ тохируулгатай 
			байхад илүү байдаг.</para>
	   
		  <para>Хэрэв <filename>/usr/obj</filename> нь энэ файлын систем 
			дээрх цорын ганц зүйл бол энэ асуудал биш юм. Хэрэв танд уг файлын 
			систем дээр өөр, үнэтэй өгөгдөл байгаа бол энэ тохируулгыг 
			идэвхжүүлэхээсээ өмнө өөрийн нөөц чинь шинэ эсэхийг шалгаарай.</para>
		</warning>
		
		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>
		
		<warning>
		  <para>Дээр дурдсан шиг хэрэв <filename>/usr/obj</filename> нь 
			өөрийн файлын систем дээр биш байх юм бол жишээн дээрхийг 
			тохирох холболт хийх цэгийн нэрээр солиорой.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
            <para>Хэрэв ямар нэг юм буруутвал би юу хийх вэ?</para>
          </question>

          <answer>
            <para>Таны орчинд өмнөх бүтээлтүүдийн үеийн илүү үлдэгдлүүд   
		байхгүйд үнэхээр итгэлтэй байх хэрэгтэй. Энэ нь их амархан 
		юм.</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

            <para>Тиймээ, <command>make cleandir</command> тушаалыг үнэндээ 
		хоёр удаа ажиллуулах шаардлагатай.</para>

            <para>Тэгээд <command>make buildworld</command> 
		тушаалыг эхлүүлж бүх процессийг дахин эхлүүл.</para>

            <para>Хэрэв та асуудалтай хэвээр байгаа бол алдаа болон 
		<command>uname -a</command> тушаалын дүнг &a.questions; 
		уруу явуулаарай. Өөрийн тохиргооныхоо талаар бусад асуултанд 
		хариулахад бэлэн байгаарай!</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="make-delete-old">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Антон</firstname>
	  <surname>Штеренлихт</surname>
	  <contrib>Тэмдэглэгээ хийсэн </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Хуучин файлууд, хавтаснууд болон сангуудыг устгах</title>
    <indexterm>
      <primary>Хуучин файлууд, хавтаснууд болон сангуудыг устгах</primary>
    </indexterm>

    <para>&os; хөгжүүлэлтийн явцад файлууд болон тэдгээрийн агуулга 
      үе үе хуучирдаг.Тэдгээрийн үүрэг болон боломжууд өөр хаа нэгтээ 
      хийгдсэн юм уу эсвэл сангийн хувилбарын дугаар өөрчлөгдсөн юм уу эсвэл 
      системээс бүрмөсөн хасагдсанаас болоод тийм 
      байж болох юм. Эдгээрт хуучин файлууд, сангууд болон хавтаснууд 
      ордог бөгөөд эдгээрийг системийг шинэчлэхдээ устгах ёстой. Энэ нь 
      хэрэглэгчийн хувьд хадгалах (болон нөөц) төхөөрөмж дээр хэрэгцээгүй 
      зай эзлээд байгаа хуучин файлуудаар систем дүүрэхгүй байх ашигтай  юм.
      Үүнээс гадна хуучин сан аюулгүй байдлын болон найдвартай ажиллагааны 
      хувьд асуудалтай байсан бол та өөрийн системийг аюулгүй болгож хуучин 
      сангаас болоод ажиллахаа болиод байсан асуудлаас сэргийлэхийн тулд 
      шинэ сан руу шинэчлэх хэрэгтэй.
      Хуучин гэгдсэн файлууд, хавтаснууд, сангуудын жагсаалт 
      <filename>/usr/src/ObsoleteFiles.inc</filename> файлд байдаг.
      Дараах заавар нь системийг шинэчлэх явцад хуучин файлуудыг устгахад 
      туслах болно.</para>

    <para>Таныг  <xref
      linkend="canonical-build">-д заасны дагуу явж байгаа гэж энд үзнэ.
	<command>make
      <maketarget>installworld</maketarget></command> болон дараагийн 
	<command>mergemaster</command> тушаал амжилттай хэрэгжсэний 
	дараа дараах маягаар та хуучин файлууд болон сангуудыг шалгах 
	ёстой:</para>

    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

    <para>Хэрэв ямар нэг хуучин файл олдвол дараах тушаал 
      ашиглан тэдгээрийг устгаж болно:</para>

    <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

    <tip>
      <para>Түлхүүр үгсийн талаар дэлгэрэнгүйг сонирхож байгаа бол <filename>/usr/src/Makefile</filename>
        файлыг үзнэ үү.</para>
    </tip>

    <para>Хуучин файл бүрийг устгахын өмнө асууж хариулах дэлгэц гарна.
      Та энэ дэлгэцийг өнгөрөөж систем эдгээр файлуудыг автоматаар устгахаар 
      тохируулахын тулд <makevar>BATCH_DELETE_OLD_FILES</makevar> хувьсагчийг 
      дараах байдлаар ашиглана:

      <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

      <para>Мөн энэ зорилгод хүрэхийн тулд
      доорхитой адилаар эдгээр тушаалд <command>yes</command> өгч хүрч болно:</para>

    <screen>&prompt.root; <userinput>yes|make delete-old</userinput></screen>

    <warning>
      <title>Анхааруулга</title>
        <para>Хуучин файлуудыг устгах нь тэдгээр хуучин файлуудаас 
	  хамааралтай програмуудыг ажиллахгүй болгоно.
	  Энэ нь ялангуяа хуучин сангуудын хувьд үнэн байдаг.
	  Ихэнх тохиолдолд та <command>make
       <maketarget>delete-old-libs</maketarget></command> тушаалыг биелүүлэхээсээ 
	  өмнө хуучин сан ашиглаж байсан програмууд, портууд эсвэл сангуудыг 
	  дахин бүтээх хэрэгтэй.</para>
    </warning>

    <para>Хуваалцсан сангуудаас хамааралтай эсэхийг шалгадаг хэрэгслүүд 
      <filename role="package">sysutils/libchk</filename> эсвэл 
      <filename role="package">sysutils/bsdadminscripts</filename> зэрэг портын 
      цуглуулгад байдаг.</para>

    <para>Хуучин хуваалцсан сангууд нь шинэ сангуудтай зөрчилдөж болох 
      бөгөөд доорх шиг алдаа өгч болно:</para>

    <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

    <para>Эдгээр асуудлуудыг шийдэхийн тулд уг санг аль порт суулгасныг 
      олно:</para>

    <screen>&prompt.root; <userinput>pkg_info -W  /usr/local/lib/libtiff.so</userinput>
/usr/local/lib/libtiff.so was installed by package tiff-3.9.4
&prompt.root; <userinput>pkg_info -W /usr/local/lib/libXext.so</userinput>
/usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

    <para>Дараа нь уг портыг deinstall хийгээд дахин бүтээж суулгах 
      хэрэгтэй. Энэ явцыг автоматжуулахын тулд <filename
      role="package">ports-mgmt/portmaster</filename> болон <filename
      role="package">ports-mgmt/portupgrade</filename> 
      хэрэгслийг ашиглаж болно. Бүх портуудыг дахин бүтээсэн гэдэгтээ
      итгэлтэй болсны дараа хуучин сангуудыг ашиглах хэрэггүй бөгөөд тэдгээрийг 
      дараах тушаал ашиглан устгаж болно:</para>

    <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Майк</firstname>
	  <surname>Мэйэр</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Олон машины хувьд дагах нь</title>
    <indexterm>
      <primary>NFS</primary>
      <secondary>олон машин суулгах нь</secondary>
    </indexterm>
    
    <para>Хэрэв та олон машинуудын хувьд ижил эх модыг дагахыг хүсэж бүгдийн хувьд 
	эхийг татан авахуулж бүгдийг дахин бүтээхийг хүсэж байгаа бол энэ нь дискний зай, 
	сүлжээний зурвасын өргөн болон 
	CPU циклүүд зэрэг эх үүсвэрүүдийг үр ашиггүйгээр ашиглахад хүргэхээр санагдаж 
	болох юм. Тиймээ, үүний шийдэл нь нэг машинаар ихэнх ажлыг хийлгэж 
	бусад машинууд нь тэр ажлыг NFS-ээр дамжуулан холбох явдал юм. Энэ хэсэгт 
	ингэж хийх аргыг тайлбарсан.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Бэлтгэл ажлууд</title>

      <para>Эхлээд хоёртын адил файлуудыг ажиллуулах <emphasis>build set буюу 
	бүтээх олонлог</emphasis> гэж бидний нэрлэх машинуудыг олох хэрэгтэй. 
	Машин бүр өөрчлөн тохируулсан цөмтэй байж болох бөгөөд гэхдээ тэд ижил хэрэглэгчийн 
	талбарын хоёртын файлуудыг ажиллуулж байх ёстой. Тэр олонлогоос 
	<emphasis>бүтээх машин</emphasis>ыг сонгох хэрэгтэй. Энэ нь 
	ертөнц болон цөм бүтээгдэх машин байх юм. Туйлын хүслээр бол энэ 
	нь <command>make buildworld</command> болон 
	<command>make buildkernel</command> тушаалуудыг ажиллуулахад 
	хангалттай нөөц CPU бүхий хурдан машин байх хэрэгтэй. Та мөн 
	үйлдвэрлэлд ашиглахаас өмнө програм хангамжуудыг тест хийдэг 
	<emphasis>тест машин</emphasis> сонгохыг бас хүсэж болох юм. 
	Энэ нь удаан хугацаагаар унтраастай эсвэл зогссон байж болох машин <emphasis>байх 
	ёстой</emphasis>. Энэ нь бүтээх машин байж болох юм, гэхдээ заавал 
	биш юм.</para>

      <para>Энэ бүтээх олонлог дахь бүх машинууд нь өөр өөрийн машин дээрээсээ ижил цэг дээр
	<filename>/usr/obj</filename> болон <filename>/usr/src</filename>-г  
	холболт хийх хэрэгтэй. Туйлын хүслээр бол энэ нь бүтээх машин дээрх хоёр өөр дискнүүд 
	байж болох бөгөөд гэхдээ эдгээр нь уг машин дээр  NFS холболт бас хийгдэж болохоор 
	байж болох юм. Хэрэв танд олон бүтээх олонлогууд байгаа бол 
	<filename>/usr/src</filename> сан нь нэг бүтээх машин дээр байрлаж 
	бусад дээр нь NFS холболт хийгдсэн байх юм.</para>
	  
      <para>Төгсгөлд нь бүтээх олонлогийн бүх машинууд дээрх <filename>/etc/make.conf</filename> 
	болон <filename>/etc/src.conf</filename> файлууд бүтээх машиныхтай тохирч байгаа эсэхийг шалгаарай. Энэ нь бүтээх олонлогийн 
	машин бүрийн суулгах үндсэн системийн бүх хэсгүүдийг бүтээх машин хийх ёстой гэсэн 
	үг юм. Мөн бүтээх машин бүр өөрийн цөмийн нэрийг <filename>/etc/make.conf</filename> 
	файлд <makevar>KERNCONF</makevar> хувьсагчид заан өгөх ёстой бөгөөд бүтээх 
	машин бүр <makevar>KERNCONF</makevar> хувьсагчдаа өөрийн цөмийг эхэнд
	оруулан дараа нь тэдгээрийг жагсаах ёстой байдаг. Бүтээх машин нь машин бүрийн 
	цөмийг бүтээхээр болох юм бол тэдгээрийн тохиргооны файлыг 
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename> 
	санд агуулсан байх шаардлагатай.</para>
    </sect2>

    <sect2 id="small-lan-base-system">
      <title>Үндсэн систем</title>

      <para>Одоо бүх юм ингэж хийгдсэний дараа та бүгдийг бүтээхэд бэлэн боллоо. 
	Бүтээх машин дээр <xref linkend="make-buildworld">-д тайлбарласны 
	дагуу цөм болон ертөнцийг бүтээ, гэхдээ юуг ч битгий суулгаарай. Бүтээлт 
	дууссаны дараа тест машин дээр дөнгөж саяхан бүтээсэн цөмөө суулга. 
	Хэрэв энэ машин нь <filename>/usr/src</filename>
	болон <filename>/usr/obj</filename> сангуудыг NFS-ээр холболт хийх 
	гэж байгаа бол та ганц хэрэглэгчийн горимд дахин ачаалахдаа сүлжээг нээж 
	тэдгээрийг холбож өгөх хэрэгтэй. Үүнийг хамгийн хялбараар хийхийн тулд 
	олон хэрэглэгчийн горимд ачаалан <command>shutdown now</command> 
	тушаалыг ажиллуулж ганц хэрэглэгчийн горимд орох явдал юм. Тэгэж орсныхоо 
	дараа та шинэ цөм болон ертөнцийг суулгаж жирийн үедээ хийдэг 
	<command>mergemaster</command> тушаалыг ажиллуулж болно. 
	Ингэж дууссаныхаа дараа энэ машины хувьд ердийн олон хэрэглэгчийн 
	үйлдлүүдэд дахин ачаалж орно.</para>

      <para>Тест машин дээрх бүх зүйлс зөв ажиллаж байгааг мэдсэнийхээ дараа та 
	бүтээх олонлогийн бусад машин бүр дээр шинэ програм хангамж суулгахдаа 
	ижил процедурыг ашиглаарай.</para>
    </sect2>

    <sect2 id="small-lan-ports">
      <title>Портууд</title>

      <para>Үүнтэй адил санааг бас портуудын модонд ашиглаж болно. Эхний чухал 
	алхам бол нөгөө машин дээрх <filename>/usr/ports</filename> санг  
	бүтээх олонлогийн бусад машинууд дээр холбож өгөх явдал юм. Дараа нь та 
	<filename>/etc/make.conf</filename> файлыг distfiles 
	буюу түгээлтийн файлуудыг хуваалцахаар зөв тохируулж өгч болно. 
	Та <makevar>DISTDIR</makevar> хувьсагчийг таны NFS холболтуудад заагдсан 
	аль ч <username>root</username> хэрэглэгчийн хувьд бичигдэх боломжтой байх 
	нийтлэг хуваалцсан сангаар тохируулах шаардлагатай.
	Машин бүр <makevar>WRKDIRPREFIX</makevar> хувьсагчийг локал 
	бүтээх сангаар зааж өгөх хэрэгтэй. Эцэст нь хэрэв та багцуудыг бүтээж түгээх 
	гэж байгаа бол <makevar>PACKAGES</makevar> хувьсагчийг 
	<makevar>DISTDIR</makevar> хувьсагчийн нэгэн адил сангаар зааж өгөх 
	хэрэгтэй.</para> 
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

