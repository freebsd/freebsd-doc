<!--
     The FreeBSD Mongolian Documentation Project

     Original revision 1.340

     $FreeBSD$
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Мэтью</firstname>
	<surname>Диллон</surname>
	<contrib>Энэ бүлгийн ихэнх хэсгийг security(7) гарын авлагын хуудаснаас авсан бөгөөд
		security(7) гарын авлагын хуудсыг бичсэн </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Цагаанхүүгийн</firstname>
	<surname>Ганболд</surname>
	<contrib>Орчуулсан  </contrib>
 	<!-- Dec 2006 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Аюулгүй байдал</title>
  <indexterm><primary>аюулгүй байдал</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>Ерөнхий агуулга</title>

    <para>Энэ бүлэг нь системийн аюулгүй байдлын ухагдахуунуудын үндэс, зарим нэг нийтлэг  
	практикийн сайн аргууд болон &os; дэх зарим нэг дэвшилттэй сэдвүүдийг
	танилцуулах болно. Энд дурдагдсан олон сэдвүүдийг бас системийн болон Интернэтийн 
	аюулгүй байдалд хэрэглэж болох юм. Интернэт нь хүн бүр таны найрсаг хөрш байхыг 
	хүсдэг <quote>найзархаг</quote> газар байхаа аль хэдийн больсон. 
	Өөрийн системийг аюулгүй болгох нь таны өгөгдөл, оюуны өмч, цаг хугацаа зэрэг 
	олон зүйлсийг хакерууд зэргийн савраас хамгаалахад хойшлуулашгүй чухал юм.</para>

    <para>&os; нь таны систем болон сүлжээний аюулгүй байдал болон бүрэн бүтэн байдлыг 
	хангаж байдаг хэрэгслүүд болон арга замуудын цуглуулгыг агуулдаг.</para>

    <para>Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:</para>

    <itemizedlist>
      <listitem>
	<para>&os;-ийн хувьд системийн аюулгүй байдлын үндсэн ухагдахуунууд.</para>
      </listitem>

      <listitem>
	<para>&os;-д байдаг <acronym>DES</acronym> болон <acronym>MD5</acronym> 
	зэрэг төрөл бүрийн нууцлах арга замуудын талаар.</para>
      </listitem>

      <listitem>
	<para>Нэг удаагийн нууц үгийн нэвтрэлтийг хэрхэн тохируулах талаар.</para>
      </listitem>

      <listitem>
	<para><acronym>TCP</acronym> Wrappers буюу 
	<acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдыг <application>inetd</application>-д ашиглан 
	хэрхэн тохируулах талаар.</para>
      </listitem>

      <listitem>
	<para>&os; дээр <application>Kerberos5</application>-г хэрхэн тохируулах талаар.</para>
      </listitem>

      <listitem>
	<para>IPsec-г хэрхэн тохируулж &os;/&windows; машинуудын хооронд 
	<acronym>VPN</acronym> үүсгэх талаар.</para>
      </listitem>
     
      <listitem>
	<para>&os;-ийн <acronym>SSH</acronym> шийдэл болох <application>OpenSSH</application>-г 
	хэрхэн тохируулж ашиглах талаар.</para>
      </listitem>

      <listitem>
	<para>Файлын системийн  <acronym>ACL</acronym>-үүд гэж юу болох, тэдгээрийг 
	хэрхэн ашиглах талаар.</para>
      </listitem>

      <listitem>
	<para><application>Portaudit</application> хэрэгслийг хэрхэн ашиглаж 
	Портын цуглуулгаас суулгагдсан гуравдагч програм хангамжийн багцуудыг аудит хийх талаар.</para>
      </listitem>

      <listitem>
	<para>&os;-ийн аюулгүй байдлын зөвлөмжүүдийн сонордуулгуудыг хэрхэн хэрэглэх талаар.</para>
      </listitem>

      <listitem>
	<para>Процессийн Бүртгэл хөтлөх гэж юу болох талаар ойлголттой болж 
	түүнийг &os; дээр хэрхэн идэвхжүүлэх талаар.</para>
      </listitem>
    </itemizedlist>

    <para>Энэ бүлгийг уншихаасаа өмнө, та дараах зүйлсийг мэдэх шаардлагатай:</para>

    <itemizedlist>
      <listitem>
	<para>&os; болон Интернэтийн үндсэн ухагдахуунуудыг ойлгох.</para>
      </listitem>
    </itemizedlist>

    <para>Энэ номонд нийтдээ аюулгүй байдлын нэмэлт сэдвүүд хамрагдсан болно.
	Жишээ нь Mandatory Access Control буюу 
	Шаардлагатай Хандалтын Хяналт <xref linkend="mac">-д,  
	Интернэт галт ханануудын талаар <xref linkend="firewalls">-д 
	хэлэлцэгдсэн байгаа.</para>
  </sect1>

  <sect1 id="security-intro">
    <title>Танилцуулга</title>

    <para>Аюулгүй байдал нь системийн администратораас эхэлж түүнтэй дуусдаг 
	үйл ажиллагаа юм. BSD &unix; олон хэрэглэгчийн системүүд нь угаасаа 
	зарим нэг аюулгүй байдлыг хангаж байдаг боловч тэдгээр хэрэглэгчдийг  
	<quote>үнэнч</quote> байлгахыг эрмэлздэг аюулгүй байдлын нэмэлт 
	арга замуудыг бүтээж түүний ажиллагааг хангах ажил нь сисадмины магадгүй 
	ганц, хамгийн том үүргүүдийн нэг юм. Таныг аюулгүй болгосон зөвхөн тэр 
	хэмжээгээр машинууд нь аюулгүй байдаг бөгөөд аюулгүй байдлын санаа зовнилууд 
	нь хүний ая тухтай хялбар байлгах гэсэн хэрэгцээтэй үргэлж тэмцэлдэж байдаг. Ерөнхийдөө 
	&unix; системүүд нь асар олон тооны зэрэгцээ процессуудыг ажиллуулах 
	чадвартай бөгөөд эдгээр процессуудын ихэнх нь серверүүд болон ажилладаг 
	&mdash; энэ нь гаднын зүйлс тэдэнтэй холбогдож ярилцах боломжтой 
	гэсэн үг юм. Өчигдрийн миникомпьютерууд, мэйнфрэймүүдээс өнөөгийн 
	ширээний компьютерууд болж компьютерууд нь сүлжээнд холбогдож  
	сүлжээнүүд нь хоорондоо холбогдох тусам аюулгүй байдал нь улам илүү том 
	асуудал болсоор байна.</para>

    <para>Системийн аюулгүй байдал нь сүйрүүлэхийг оролдсон эсвэл системийг 
	ашиглагдахааргүй болгох гэсэн, гэхдээ <username>root</username> 
	бүртгэлийг буулган авах (<quote>root-г эвдэх</quote>) оролдлого 
	хийдэггүй, халдлагууд зэрэг төрөл бүрийн халдлагуудыг зогсоохтой бас 
	хамааралтай юм. Аюулгүй байдлын санаа зовнилуудыг хэд хэдэн зэрэглэлд 
	хувааж болно:</para>

    <orderedlist>
      <listitem>
	<para>Үйлчилгээг зогсоох халдлагууд.</para>
      </listitem>

      <listitem>
	<para>Хэрэглэгчийн бүртгэл буулган авалтууд.</para>
      </listitem>

      <listitem>
	<para>Хандаж болох серверүүдээр дамжин root-г буулган авах.</para>
      </listitem>

      <listitem>
	<para>Хэрэглэгчийн бүртгэлүүдээс дамжин root-г буулган авах.</para>
      </listitem>

      <listitem>
	<para>Арын хаалга үүсгэлт.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS халдлагууд</primary>
      <see>Үйлчилгээг Зогсоох (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>DoS халдлагууд</secondary>
      <see>Үйлчилгээг Зогсоох (DoS)</see>
    </indexterm>
    <indexterm><primary>Үйлчилгээг Зогсоох (DoS)</primary></indexterm>

    <para>Үйлчилгээг зогсоох халдлага нь машиныг хэрэгцээтэй эх үүсвэрээс нь салгах 
	үйлдэл юм. Ихэвчлэн DoS халдлагууд нь сүйрүүлэхийг оролдсон эсвэл 
	машиныг түүн дээрх серверүүд болон сүлжээний стекийг эзэмдэн ашиглах 
	боломжгүй болгодог балмадаар хүчлэх арга замууд юм. Зарим DoS халдлагууд 
	нь сүлжээний стек дэх алдаануудыг ашиглан ганц пакетаар машиныг сүйрүүлэхийг 
	оролддог. Үүнийг зөвхөн алдааны засварыг цөмд хийснээр засах боломжтой. 
	Систем дээрх хөнөөлтэй нөхцөлд байх тэр серверийн дуудлагыг хязгаарладаг 
	тохируулгуудыг зөв зааж серверүүд уруу хийсэн халдлагуудыг ихэвчлэн засаж болдог. 
	Сүлжээний балмадаар хүчлэх халдлагуудын эсрэг арга хэмжээ авахад илүү 
	төвөгтэй байдаг. Жишээ нь хууран мэхэлсэн пакетийн халдлагыг зогсоох 
	бараг л боломжгүй, таны системийг Интернэтээс салгахад хүргэж болох юм.
	Энэ нь таны машиныг зогсоож чадахгүй байж болох боловч таны Интернэтийн 
	холболтыг дүүргэж болно.</para>

    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>бүртгэл буулган авалтууд</secondary>
    </indexterm>

    <para>Хэрэглэгчийн бүртгэлийг буулган авах халдлага нь DoS халдлагаас илүү их 
	тохиолддог. Одоо болтол олон сисадминууд стандарт <application>telnetd</application>, 
	<application>rlogind</application>, <application>rshd</application>,
      болон <application>ftpd</application> серверүүдийг өөрсдийн машинууд 
	дээр ажиллуулсаар байна. Анхдагчаар серверүүд нь шифрлэсэн холболт дээр 
	ажилладаггүй. Ийм холболт дээр хэрэв та багагүй хэмжээний хэрэглэгчидтэй 
	бөгөөд тэдгээр хэрэглэгчдээс нэг болон хэд хэд нь алсаас (энэ нь систем уруу нэвтрэн 
	орох хамгийн нийтлэг тав тухтай арга юм) таны систем уруу нэвтрэн 
	орж байгаа бол тэдгээр хэрэглэгчийн  нууц үг дундаасаа сүлжээгээр шиншлэгдэн алдагдах 
	боломжтой байдаг. Анхааралтай системийн админ тэр хэрэглэгчийн 
	алсаас хандсан бүртгэлүүд дээрээс бүр амжилттай болсон нэвтрэлтүүдэд хүртэл сэжигтэй 
	эхлэл  хаягууд  байгаа эсэхийг хайн шинжилдэг.</para>

    <para>Халдагч хэрэглэгчийн бүртгэлд хандаж чадсаны дараа <username>root</username>-г 
	бас эвдэж чадна гэдгийг үргэлж бодож байх хэрэгтэй. Гэхдээ жинхэнэ амьдрал дээр бол 
	сайн аюулгүй байдлыг хангаж нууцлаг болгосон байнга ажиллагааг нь хянаж байдаг систем дээр 
	хэрэглэгчийн бүртгэлд хандах нь халдагч заавал ч үгүй <username>root</username> 
	эрхэд хандаж чадна гэсэн үг биш юм. Энэ ялгааг зөв салгаж ойлгох хэрэгтэй. Учир нь 
	<username>root</username> уруу хандах боломжгүй халдагч ерөнхийдөө өөрийн 
	мөрийг баллаж нууж чаддаггүй бөгөөд тухайн хэрэглэгчийн файлуудыг замбараагүйтүүлэх 
	эсвэл машиныг сүйрүүлэхээс илүүтэйг хийж чаддаггүй. Хэрэглэгчид нь сисадминууд шиг 
	аюулгүй байдлын арга хэмжээг тэр болгон авдаггүй болохоор хэрэглэгчийн бүртгэлийн 
	буулган авалт нь маш элбэг байдаг юм.</para>

    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>арын хаалганууд</secondary>
    </indexterm>

    <para>Машин дээрх <username>root</username> бүртгэлийг эвдэх боломжит олон 
	аргууд байдгийг системийн администраторууд санаж байх хэрэгтэй. Халдагч нь 
	<username>root</username>-н нууц үгийг мэдэж болно. Эсвэл халдагч root 
	эрхээр ажилладаг серверт алдаа олж сүлжээгээр тэр сервер уруу дамжин орж
	<username>root</username>-г эвдэж болно. Эсвэл халдагч нь suid-root 
	програмд алдаа байгааг мэдэж хэрэглэгчийн бүртгэлийг эвдэн орсныхоо дараа 
	тэр алдаагаар дамжин <username>root</username>-г эвдэн орж болох юм.
	Хэрэв халдагч машин дээрх <username>root</username>-г эвдэх аргаа 
	олсон бол заавал арын хаалга суулгах шаардлагагүй болж болох юм. 
	<username>root</username>-н цоорхойнуудын олонхийг тухайн үед аль хэдийн 
	олоод хаачихсан байдаг бөгөөд энэ үед халдагчид өөрийн мөрөө цэвэрлэхэд ихээхэн 
	ажиллагаа шаарддаг болохоор ихэнх халдагчид арын хаалга суулгадаг. 
	Арын хаалга нь систем уруу хандах <username>root</username> хандалтыг 
	халдагчид амархнаар дахин олж авах боломжийг олгодог боловч энэ нь ухаалаг системийн 
	администраторт халдлагыг амархнаар илрүүлэх боломжийг бас олгодог юм. 
	Халдагчийн хамгийн эхлээд эвдэн орсон цоорхойг хааж чаддаггүй болохоор арын хаалга 
	суулгахыг  боломжгүй болгох нь магадгүй таны аюулгүй байдалд ашиггүй байж болох юм.</para>

    <para>Аюулгүй байдлын засварууд нь олон давхраатай <quote>сонгины хальс</quote> 
	хандлагаар үргэлж шийдэгдэж байх шаардлагатай бөгөөд тэдгээрийг дараах маягаар 
	зэрэглэж болно:</para>

    <orderedlist>
      <listitem>
	<para><username>root</username> болон staff бүртгэлүүдийг нууцлаг/аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para><username>root</username>&ndash;ажилладаг серверүүд 
	болон suid/sgid хоёртын файлуудыг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Хэрэглэгчийн бүртгэлүүдийг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Нууц үгийн файлыг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Цөмийн гол хэсэг, түүхий төхөөрөмжүүд болон 
	файлын системүүдийг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Системд хийгдсэн зохисгүй өөрчлөлтүүдийг түргэн илрүүлэх.</para>
      </listitem>

      <listitem>
	<para>Параной буюу хэт зовнил.</para>
      </listitem>
    </orderedlist>

    <para>Энэ бүлгийн дараагийн хэсэг нь дээр дурдсан зүйлсүүдийг илүү гүнзгийгээр 
	авч үзэх болно.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>&os;-н аюулгүй байдлыг хангах нь</title>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>&os;-н аюулгүй байдлыг хангах нь</secondary>
    </indexterm>

    <note>
      <title>Тушаалыг Протоколтой харьцуулахад (Command vs. Protocol)</title>
      <para>Энэ баримтын туршид бид <application>тод</application> текстээр 
	програмыг <command>monospaced</command> фонтоор тусгай тушаалуудыг 
	тэмдэглэх болно. Протоколууд ердийн фонт ашиглах болно. Тэмдэглэгээний энэ 
	ялгаа нь ssh зэргийн хувьд ашигтай, учир нь энэ ssh нь протоколоос гадна 
	бас тушаал юм.</para>
    </note>

    <para>Үүнээс хойшх хэсгүүд нь түрүүчийн бүлгийн <link linkend="security-intro">
	сүүлийн хэсэг</link>т дурдсан таны &os; системийг аюулгүй болгох аргуудыг 
	авч үзнэ.</para>

    <sect2 id="securing-root-and-staff">
      <title><username>root</username> бүртгэл болон staff бүртгэлүүдийг 
	аюулгүй болгох</title>
      <indexterm>
        <primary><command>su</command></primary>
      </indexterm>

      <para>Эхлээд хэрэв та <username>root</username> бүртгэлийг аюулгүй болгоогүй 
	бол staff бүртгэлүүдийг аюулгүй болгоход санаа зовсны хэрэггүй. Ихэнх системүүд 
	<username>root</username> бүртгэлд нууц үг өгсөн байдаг. Таны эхний хийх 
	зүйл бол нууц үг <emphasis>үргэлж</emphasis> эвдэгдэж болно гэдгийг 
	бодох хэрэгтэй. Энэ нь та нууц үгээ устгах хэрэгтэй гэсэн үг биш юм. Нууц үг нь 
	машин уруу консол хандалт хийхэд үргэлж хэрэгтэй байдаг. Энэ нь юу гэсэн үг вэ 
	гэхээр та нууц үгийг консолоос гадна эсвэл болж өгвөл бүр &man.su.1; тушаалтай 
	ашиглаж болохоор хийх ёсгүй гэсэн үг юм. Жишээ нь 
	<command>telnet</command> эсвэл <command>rlogin</command>-р хийгдэх 
	шууд <username>root</username> нэвтрэлтүүдийг хаах pty-уудын тохиргоог insecure 
	буюу аюултай гэж <filename>/etc/ttys</filename> файлд заасан эсэхийг шалгаарай. 
	Хэрэв бусад нэвтрэх үйлчилгээнүүд болох <application>sshd</application> 
	зэргийг ашиглаж байгаа бол шууд <username>root</username> нэвтрэлтүүдийг 
	бас хаасан эсэхийг шалгаарай. Та үүнийг <filename>/etc/ssh/sshd_config</filename> 
	файлыг засварлан <literal>PermitRootLogin</literal> тохируулгыг 
	<literal>no</literal> болгон зааж өгөөрэй. Хандах арга бүр &mdash;
	FTP зэрэг үйлчилгээнүүдээр ихэвчлэн эвдлэн ордог болохыг бодолцох хэрэгтэй. 
	Шууд <username>root</username> нэвтрэлтүүд зөвхөн системийн консолоор хийгдэхэд  
	зөвшөөрөгдөх ёстой.</para>
      <indexterm>
        <primary><groupname>wheel</groupname></primary>
      </indexterm>

      <para>Мэдээж систем админы хувьд та <username>root</username> 
	уруу орж чадаж байх ёстой болохоор бид хэдэн цоорхой үлдээдэг. 
	Гэхдээ эдгээр цоорхойнууд нь нэмэлт нууц үг шалгаж ажилладаг байхаар 
	бид хийдэг. <username>root</username>-г хандах боломжтой 
	байлгах нэг арга нь тохирох staff бүртгэлүүдийг <groupname>wheel</groupname> 
	бүлэгт (<filename>/etc/group</filename> файлд) нэмэх явдал юм. 
	<groupname>wheel</groupname> бүлэгт оруулсан staff-ийн гишүүдэд 
	<username>root</username> уруу <command>su</command> хийхийг 
	зөвшөөрдөг. Та staff-ийн гишүүдийг тэдгээрийн нууц үгийн оруулгад 
	<groupname>wheel</groupname> бүлэгт оруулан байрлуулж  анхнаас нь 
	<groupname>wheel</groupname> хандалт өгч хэзээ ч болохгүй. 
	Staff бүртгэлүүдийг <groupname>staff</groupname> бүлэгт 
	оруулах ёстой бөгөөд тэгээд дараа нь <filename>/etc/group</filename> 
	файлын <groupname>wheel</groupname> бүлэгт нэмэх ёстой. 
	Зөвхөн <username>root</username> хандалт заавал шаардлагатай 
	тийм staff-ийн гишүүдийг <groupname>wheel</groupname> бүлэгт 
	оруулах ёстой. Kerberos зэрэг жинхэнээ шалгуулж нэвтрэх аргыг ашиглаж 
	байх тохиолдолд заавал <groupname>wheel</groupname> бүлэгт оруулалгүйгээр 
	<username>root</username> бүртгэл дэх Kerberos-ийн 
	<filename>.k5login</filename> файлыг ашиглаж 
	<username>root</username> уруу &man.ksu.1; хийхийг зөвшөөрөх 
	бас боломжтой байдаг. Энэ нь магадгүй давуу шийдэл байж болох юм. 
	Учир нь хэрэв халдагч таны нууц үгийн файлыг олж аван staff бүртгэлийг 
	эвдлэн орж чадах бол <groupname>wheel</groupname> арга нь 
	халдагчид <username>root</username>-г эвдэх боломжийг олгосон хэвээр 
	байдаг юм. <groupname>wheel</groupname> аргатай байх нь огт аргагүй 
	байхаас илүү боловч энэ нь заавал ч үгүй хамгийн аюулгүй сонголт бас биш 
	юм.</para>

      <para>Бүртгэлийг бүрэн түгжихийн тулд &man.pw.8; тушаалыг ашиглах 
	хэрэгтэй:</para>

      <screen>&prompt.root;<userinput>pw lock <replaceable>staff</replaceable></userinput></screen>

      <para>Энэ нь &man.ssh.1;-ийг оролцуулаад хэрэглэгчийг ямар ч 
	арга ашиглан нэвтрэн орохыг хориглоно.</para>

      <para>Бүртгэлүүдэд хандахыг хориглох өөр нэг арга бол 
	нууцлагдсан нууц үгийг ганц <quote><literal>*</literal></quote>  
	тэмдэгтээр солих явдал юм. Энэ тэмдэгт нь нууцлагдсан 
	нууц үгтэй хэзээ ч таарахгүй бөгөөд хэрэглэгчийн 
	хандалтыг хаах болно. Жишээ нь доор дурдсан staff бүртгэлийг:</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Ийм болгон өөрчлөх хэрэгтэй:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Энэ нь <username>foobar</username> хэрэглэгчийг ердийн 
	аргууд ашиглан нэвтрэн орох боломжийг хаадаг. Энэ хандалт 
	хязгаарлах арга нь <application>Kerberos</application> ашиглаж 
	байгаа сайтууд эсвэл хэрэглэгч &man.ssh.1; ашиглан түлхүүрүүд 
	тохируулсан тохиолдлууд зэрэгт ажилладаггүй.</para>

      <para>Эдгээр аюулгүй байдлын арга замууд нь бас таныг илүү хязгаарласан 
	серверээс арай бага хязгаарласан машин уруу нэвтрэн орж байна гэж тооцдог. 
	Жишээ нь хэрэв таны гол хайрцаг чинь бүх л төрлийн серверүүд ажиллуулж байвал 
	таны ажлын компьютер чинь ямрыг ч ажиллуулах ёсгүй. Өөрийн компьютерийг 
	боломжийн аюулгүй болгохын тулд та ерөөсөө сервергүй болтол аль болох цөөн 
	сервер ажиллуулах хэрэгтэй бөгөөд та нууц үгээр хамгаалагдсан дэлгэц хоослогч 
	ажиллуулах хэрэгтэй. Мэдээж ажлын компьютер уруу физик хандалт өгвөл 
	халдагч ямар ч төрлийн аюулгүй байдлыг та хангасан байлаа гэсэн эвдэж 
	чадна. Энэ нь таны бодох ёстой асуудлын нэг юм. Гэхдээ эвдлэн оролтуудын 
	олонхи нь алсаас сүлжээгээр дамжин таны ажлын компьютер эсвэл серверүүдэд 
	физик хандалт байхгүй хүмүүсээс ирдэг гэдгийг та бас л бодолцох хэрэгтэй юм.</para>

      <para>Kereberos мэтийг ашиглах нь танд staff бүртгэлийн нууц үгийг нэг газар 
	өөрчлөх эсвэл хаах боломжийг олгох бөгөөд staff-ийн гишүүдийн бүртгэл байж болох 
	бүх машинууд дээр нэн даруй бас үйлчилдэг. Хэрэв staff-ийн гишүүний бүртгэл 
	эвдэгдсэн бол түүний нууц үгийг бүх машинууд дээр нэн даруй өөрчлөх тэр боломжийг 
	дутуу үнэлэх ёсгүй юм. Тусдаа байгаа нууц үгүүдийг N машинууд дээр өөрчлөх нь 
	зовлонтой байдаг. Мөн та Kerberos-д нууц үг дахин өгөлтийг ноогдуулж болох 
	бөгөөд Kerberos тасалбарыг хэсэг хугацааны дараа дуусдагаар хийж болохоос 
	гадна Kerberos систем нь тодорхой хугацааны (жишээ нь сар бүр) дараа 
	хэрэглэгчийг шинэ нууц үг сонгохыг шаарддагаар бас тохируулж болдог.</para>
    </sect2>

    <sect2>
      <title>root-ажилладаг серверүүд болон suid/sgid хоёртын файлуудыг аюулгүй болгох</title>

      <indexterm>
        <primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
        <primary>sandboxes</primary>
      </indexterm>
      <indexterm>
        <primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rlogind</application></primary>
      </indexterm>

      <para>Хянамгай сисадмин илүү ч үгүй дутуу ч үгүй зөвхөн өөрийн хэрэгтэй серверүүдийг 
	ажиллуулдаг. Гуравдагч талын серверүүд ихэвчлэн хамгийн алдаатай байх 
	хандлагатай гэдгийг санаж байх хэрэгтэй. Жишээ нь 
	<application>imapd</application> эсвэл 
	<application>popper</application> серверийн хуучин хувилбарыг 
	ажиллуулна гэдэг нь универсал <username>root</username> тасалбарыг 
	бүх дэлхийд өгч байна гэсэн үг юм. Та няхуур шалгаагүй сервер битгий ажиллуул. 
	Олон серверүүд заавал <username>root</username> эрхээр ажиллах 
	шаардлагагүй байдаг. Жишээ нь <application>ntalk</application>,
	<application>comsat</application>, болон 
	<application>finger</application> дэмонуудыг тусгай хэрэглэгчийн 
	<firstterm>sandboxes буюу хамгаалагдсан хязгаарлагдмал орчинд</firstterm> 
	ажиллуулах боломжтой байдаг. Хамгаалагдсан хязгаарлагдмал орчин нь 
	асар их төвгүүдийг давж хийгээгүй л бол төгс биш бөгөөд өмнө дурдсан сонгины 
	хандлагаар аюулгүй байдалд хандах нь хэвээр байна: хэрэв хэн нэгэн нь 
	хамгаалагдсан хязгаарлагдмал орчинд ажиллаж байгаа серверт эвдэн орж 
	чадсан ч гэсэн тэд хамгаалагдсан хязгаарлагдмал орчныг бас эвдэн гарах хэрэг 
	болно. Аль болох олон давхаргыг халдагч эвдлэх ёстой болох тусам тэдгээрийн 
	амжилттай болох нь улам багасах болно. Урьд нь root цоорхойнууд нь 
	системийн үндсэн серверүүдээс авахуулаад бараг л бүх 
	<username>root</username> ажилладаг сервер дээр олдож байсан.
	Хэрэв таны ажиллуулдаг машин уруу хүмүүс зөвхөн <application>sshd</application> 
	ашиглан нэвтэрдэг бөгөөд <application>telnetd</application>,
	<application>rshd</application> эсвэл
	<application>rlogind</application> хэзээ ч ашиглан нэвтэрдэггүй 
	бол эдгээр үйлчилгээнүүдийг хаагаарай!</para>
      
      <para>Одоо &os; нь <application>ntalkd</application>,
	<application>comsat</application>, болон
	<application>finger</application> үйлчилгээнүүдийг хамгаалагдсан 
	хязгаарлагдмал орчинд анхдагчаар ажиллуулдаг. Хамгаалагдсан хязгаарлагдмал 
	орчинд ажиллуулж болох өөр нэг програм нь &man.named.8; юм. 
	<filename>/etc/defaults/rc.conf</filename> нь 
	<application>named</application>-г хамгаалагдсан хязгаарлагдмал 
	орчинд ажиллуулахад шаардлагатай нэмэлт өгөгдлүүдийг тайлбар хэлбэрээр агуулсан 
	байдаг. Таны шинэ систем эсвэл байгаа системээ шинэчилж байгаагаас хамааран 
	тэдгээр хамгаалагдсан хязгаарлагдмал орчинд ашиглагдах тусгай хэрэглэгчийн 
	бүртгэлүүд суулгагдаагүй байж болох юм. Хянамгай сисадмин судалгаа хийж  
	серверүүдийг хамгаалагдсан хязгаарлагдмал орчинд аль болох 
	ажиллуулдаг.</para>
      <indexterm>
        <primary><application>sendmail</application></primary>
      </indexterm>

      <para>Хамгаалагдсан хязгаарлагдмал орчинд ерөнхийдөө ажилладаггүй хэд хэдэн 
	серверүүд байдаг: <application>sendmail</application>,
	<application>popper</application>,
	<application>imapd</application>, <application>ftpd</application>,
	болон бусад. Эдгээрийн зарим шиг бас өөр серверүүд байдаг боловч 
	тэдгээрийг суулгах нь таны хүсэж байгаагаас илүү (амархан байх гэсэн асуудал 
	энд сөхөгдөж байна) их ажиллагаа шаардаж магадгүй юм. Та эдгээр серверүүдийг 
	магадгүй <username>root</username> эрхээр ажиллуулж тэдгээрт учирч болох 
	эвдрэн оролтуудыг илрүүлэх өөр арга замуудад найдах хэрэгтэй болж болох юм.</para>

      <para>Системийн өөр нэг том боломжтой <username>root</username> цоорхойнууд 
	бол системд суусан suid-root болон sgid хоёртын файлууд юм. 
	<application>rlogin</application> зэрэг эдгээрийн ихэнх нь 
	<filename class="directory">/bin</filename>, <filename class="directory">/sbin</filename>,
	<filename class="directory">/usr/bin</filename>, эсвэл <filename class="directory">/usr/sbin</filename>
	сангуудад байрладаг. Юу ч 100% аюулгүй байдаггүй боловч системийн анхдагч 
	suid болон sgid хоёртын файлууд нь боломжийн хэрээр аюулгүй гэж тооцогддог. 
	Гэсэн хэдий ч эдгээр хоёртын файлуудад <username>root</username> цоорхойнууд 
	үе үе олддог. <application>xterm</application>-г (энэ нь ихэвчлэн suid 
	байдаг) эмзэг болгосон <username>root</username> цоорхойнууд 1998 онд 
	<literal>Xlib</literal>-д олджээ. Харамсахаасаа өмнө аюулгүй байж 
	байсан нь дээр учраас хянамгай сисадмин зөвхөн staff ажиллуулах ёстойгоор 
	staff зөвхөн хандаж чадах тусгай бүлэгт зөвшөөрч suid хоёртын файлуудыг 
	хязгаарладаг бөгөөд хэн ч ашигладаггүй suid хоёртын файлуудыг ажиллуулж болохгүй 
	болгодог (<command>chmod 000</command>). Дэлгэцгүй серверт ер нь 
	<application>xterm</application> хоёртын файл хэрэгцээгүй юм. 
	Sgid хоёртын файлууд нь бас л аюултай юм. Хэрэв халдагч  sgid-kmem 
	хоёртын файлыг эвдэж чадвал тэр <filename>/dev/kmem</filename>-г 
	уншиж чадах бөгөөд ингэснээр нууц үгтэй дурын бүртгэлийг эвдэн орж 
	шифрлэсэн нууц үгийн файлыг уншихад хүргэдэг. Бас <literal>kmem</literal> 
	бүлгийг эвдсэн халдагч secure буюу аюулгүй аргаар дамжин нэвтрэн орсон хэрэглэгчдийн 
	ашиглаж байгаа pty-уудаар илгээгдсэн гарын товчнуудын даралтуудыг 
	хянаж чаддаг. <groupname>tty</groupname> бүлгийг эвдсэн халдагч 
	бараг дурын хэрэглэгчийн tty-д бичиж чадна. Хэрэв хэрэглэгч гар дуурайх боломж бүхий 
	терминал програм эсвэл эмулятор ажиллуулж байгаа бол хэрэглэгчийн терминалыг 
	тушаал буцаан харуулахаар болгодог өгөгдлийн урсгалыг халдагч үүсгэж дараа нь 
	тэр тушаалыг тэр хэрэглэгчийн эрхээр ажиллуулдаг.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Хэрэглэгчийн бүртгэлүүдийг аюулгүй болгох</title>

      <para>Хэрэглэгчийн бүртгэлүүдийг аюулгүй болгох нь ихэвчлэн хамгийн хэцүү 
	байдаг. Та өөрийн staff-д ширүүн хандалтын хязгаарлалтууд оногдуулж 
	тэдгээрийн нууц үгүүдийг <quote>од болгож</quote> болох боловч 
	та ердийн хэрэглэгчийн бүртгэлүүдийг яг ингэж хязгаарлаж чадахгүй байж болох 
	юм. Хэрэв та хангалттай хяналттай байх юм бол таны аз болж хэрэглэгчийн 
	бүртгэлүүдийг зөвөөр аюулгүй болгож чадна. Хэрэв үгүй бол та тэдгээр 
	бүртгэлүүдийг хянахдаа ердөө л илүү сонор сэрэмжтэй байх хэрэгтэй. 
	ssh болон Kerberos-г хэрэглэгчийн бүртгэлүүдэд ашиглах нь 
	нэмэлт удирдлага болон техникийн дэмжлэг шаардлагатайгаас болоод 
	илүү асуудалтай байдаг боловч энэ нь шифрлэсэн нууц үгийн файлыг бодох юм 
	бол маш сайн шийдэл хэвээр байдаг.</para>
    </sect2>

    <sect2>
      <title>Нууц үгийн файлыг аюулгүй болгох</title>

      <para>Цорын ганц итгэлтэй арга бол аль болох олон нууц үгүүдийг од болгон 
	тэдгээр бүртгэлүүдэд хандахын тулд ssh эсвэл Kerberos ашигла.
	Шифрлэгдсэн нууц үгийн файлыг (<filename>/etc/spwd.db</filename>) 
	зөвхөн <username>root</username> уншиж чаддаг боловч халдагч 
	root-бичих хандалт олж авч чадаагүй ч гэсэн тэр файлд унших эрх олж авах 
	боломжтой байж болох юм.</para>

      <para>Таны аюулгүй байдлын скриптүүд нууц үгийн файлд хийгдсэн өөрчлөлтүүдийг 
	үргэлж шалгаж тайлагнах шаардлагатай (доорх <link
	  linkend="security-integrity">Файлын бүрэн бүтэн байдлыг шалгах</link> 
	хэсгийг үзнэ үү).</para>
    </sect2>

    <sect2>
      <title>Цөмийн гол хэсэг, түүхий төхөөрөмжүүд болон файлын системүүдийг аюулгүй болгох</title>

      <para>Хэрэв халдагч <username>root</username>-г эвдсэн бол тэр юуг ч хийж чадах 
	боловч зарим ашиг сонирхлууд байдаг. Жишээ нь орчин үеийн ихэнх цөмүүдэд 
	пакет шиншлэх төхөөрөмжийн драйвер бүтээгдсэн байдаг. &os;-д энэ нь 
	<devicename>bpf</devicename> төхөөрөмж гэж нэрлэгддэг. Халдагч 
	ердөө буулган авсан машин дээрээ пакет шиншлэгчийг ажиллуулахыг оролддог. 
	Та халдагчид энэ боломжийг өгөх хэрэггүй бөгөөд ихэнх системүүдэд 
	<devicename>bpf</devicename> төхөөрөмжийг эмхэтгэн оруулах 
	шаардлагагүй юм.</para>

      <indexterm>
        <primary><command>sysctl</command></primary>
      </indexterm>
      <para>Гэхдээ <devicename>bpf</devicename> төхөөрөмжийг хаасан ч гэсэн 
	та <filename>/dev/mem</filename> болон <filename>/dev/kmem</filename> 
	файлуудад бас санаа тавих хэрэгтэй. Энэнээс болоод халдагч түүхий (raw) 
	төхөөрөмжүүдэд бичиж чадсан хэвээр байна. Мөн цөмийн бас нэг боломж болох 
	модуль ачаалагч гэж нэрлэгддэг &man.kldload.8; байдаг. Самбаатай 
	халдагч KLD модуль ашиглаад өөрийн <devicename>bpf</devicename> 
	төхөөрөмж эсвэл бусад шиншлэх төхөөрөмжийг ажиллаж байгаа цөмд суулгадаг. 
	Эдгээр асуудлуудаас зайлсхийхийн тулд та цөмийг илүү өндөр аюулгүй байдлын 
	түвшинд ядаж аюулгүйн түвшин 1-д ажиллуулах хэрэгтэй.</para> 

      <para>Цөмийн аюулгүй байдлын түвшинг янз бүрийн аргаар тохируулж болно.
	Ажиллаж байгаа цөмийн аюулгүй байдлын түвшинг нэмэгдүүлэх хялбар алга бол 
	цөмийн <varname>kern.securelevel</varname> хувьсагчийг 
	<command>sysctl</command> ашиглан өөрчлөх явдал юм:</para>

      <screen>&prompt.root; <userinput>sysctl kern.securelevel=<replaceable>1</replaceable></userinput></screen>

      <para>Анхдагчаар &os; цөм аюулгүй байдлын -1 түвшинтэй ачаалдаг. Аюулгүй 
	байдлын түвшинг администратор эсвэл эхлүүлэх скриптүүд дэх тохиргооноос болоод 
	&man.init.8;-ээр өөрчлөөгүй л бол -1 хэвээр байх болно. 
	<filename>/etc/rc.conf</filename> файлд <varname>kern_securelevel_enable</varname> 
	хувьсагчийг <literal>YES</literal> ба <varname>kern_securelevel</varname> хувьсагчийн 
	утгыг аюулгүй байдлын хүссэн түвшин рүүгээ болгон тохируулж системийг эхлүүлэх 
	үед аюулгүй байдлын түвшинг нэмэгдүүлж болно.</para>

      <para>Эхлүүлэх скриптүүд дөнгөж дуусаад байх үед &os; системийн аюулгүй 
	байдлын анхдагч түвшин -1 байдаг. Үүнийг <quote>insecure mode</quote> 
	буюу <quote>аюулгүй байдлыг хангаагүй горим</quote> гэдэг бөгөөд учир нь 
	хувиршгүй байлын тугуудыг болиулах, бүх төхөөрөмжөөс уншиж эсвэл тэдгээр рүү 
	бичих гэх зэргийг хориогүй байдаг.</para>

      <para>Аюулгүй байдлын түвшинг 1 эсвэл илүү өндөр утгаар тохируулсны дараа 
	зөвхөн нэмэх болон хувиршгүй файлууд идэвхжиж тэдгээрийг болиулах боломжгүй 
	болон түүхийн төхөөрөмжүүдэд хандахыг хориглодог. Илүү өндөр түвшингүүд 
	бүр илүү олон үйлдлүүдийг хязгаарладаг. Төрөл бүрийн аюулгүй байдлын түвшнүүдийн 
	үйлчилгээний талаарх дэлгэрэнгүй тайлбарыг &man.security.7; гарын авлагын 
	хуудсыг уншина уу (&os; 7.0-с хуучин хувилбаруудын хувьд &man.init.8; гарын 
	авлагын хуудсыг уншина уу).</para>

      <note>
	<para>Аюулгүйн түвшинг 1 эсвэл илүү өндөр түвшнээр дээшлүүлэх нь X11 
	  (<filename>/dev/io</filename> руу хандах хандалт хаалттай байна) эсвэл 
	  &os;-ийн бүтээлтийг эхээс суулгах (процессын <maketarget>installworld</maketarget> 
	  хэсэг зарим файлуудын зөвхөн нэмэгдэх болон хувиршгүй тугуудыг түр зуур 
	  өөрчлөхийг шаарддаг) болон бусад цөөн тохиолдлуудын хувьд асуудлууд гаргаж 
	  болох юм. Заримдаа, жишээ нь X11-ийн хувьд ачаалах явцад &man.xdm.1;-ийг 
	  нэлээн эрт аюулгүйн түвшин бага байгаа үед нь ажиллуулж энэ асуудлыг тойрон 
	  гарах боломжтой байж болох юм. Үүнтэй адил тойрон гарах арга замууд нь бүх 
	  аюулгүй байдлын түвшингүүд эсвэл тэдгээрийн мөрдөж шаарддаг боломжит бүх 
	  хязгаарлалтуудын хувьд боломжтой биш байж болох юм. Урьдчилаад бага зэрэг 
	  төлөвлөх нь зүйтэй байдаг. Аюулгүйн түвшин бүр системийн хэрэглээг нэлээн 
	  багасгах боломжтой байдаг учир тэдгээртэй хамааралтай хязгаарлалтуудыг 
	  ойлгох нь чухал юм. Энэ нь бас анхдагч тохиргоог сонгохыг илүү хялбар болгож 
	  санамсаргүй явдлаас урьдчилан сэргийлэх болно.</para>
      </note>

      <para>Хэрэв цөмийн аюулгүйн түвшин 1 эсвэл түүнээс илүү утгаар дээшлүүлэгдсэн 
	бол <literal>schg</literal> тугийг чухал эхлүүлэх хоёртын файлууд, сангууд
	болон скрипт файлууд (өөрөөр хэлбэл аюулгүйн түвшин тохируулагдах хүртэлх ажиллах 
	бүх файлууд) дээр тохируулах нь ашигтай байж болох юм. Энэ нь хэтэрхий хийгдэж  
	байж болох бөгөөд аюулгүйн өндөр түвшинд ажиллаж байхад системийг шинэчлэх үйл 
	явцыг илүү хэцүү болгодог. Арай бага хязгаарлалттай өөр нэг боломж нь 
	системийг илүү өндөр аюулгүйн түвшинд ажиллуулж гэхдээ <literal>schg</literal> 
	тугийг системийн файл болон сан бүр дээр тохируулахгүй байх явдал юм. 
	Өөр нэг боломж нь <filename class="directory">/</filename> болон <filename class="directory">/usr</filename> 
	санг зөвхөн уншигдахаар холбох явдал юм. Юу зөвшөөрөгдсөн байх дээр хэтэрхий 
	чанга байх нь халдлага илрүүлэлтийн бүх чухал зүйлсийг хязгаарлаж болох юм.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>Файлын бүрэн бүтэн байдлыг шалгах нь: Хоёртын файлууд, Тохиргооны файлууд,
	гэх мэт.</title>

      <para>Тэр мөч ирэхэд, та зөвхөн системийн гол тохиргоо болон хяналтын файлуудаа 
	ая тухын хүчин зүйл урьтахаас хамаагүй өмнө хамгаалж чадна. 
	Жишээ нь	<command>chflags</command> тушаал ашиглан 
	<filename class="directory">/</filename> болон <filename class="directory">/usr</filename> 
	сангууд дахь ихэнх файлуудад <literal>schg</literal> битийг тохируулах нь 
	магадгүй үр ашиггүй байж болох бөгөөд учир нь ингэснээр файлуудыг хамгаалахын  
	хажуугаар бас илрүүлэх цонхыг хаадаг юм. Таны аюулгүй байдлын сонгины  
	сүүлийн давхарга нь илрүүлэлт бөгөөд энэ нь хамгийн чухал юм. Хэрэв та боломжит 
	халдагчдыг илрүүлж чадахгүй л бол аюулгүй байдлын бусад үлдсэн асуудлуудын талаар 
	бодоод ч бараг хэрэггүй юм (эсвэл бүр дэмий юм, аюулгүй байдлыг танд буруу ойлгуулахад
	хүргэдэг).  Сонгины ажлын хагас нь халдагчийг үйлдэл дээр нь 
	барихын тулд түүнийг зогсоохын оронд харин удаашруулах явдал юм.</para>

      <para>Халдлагыг илрүүлэх хамгийн сайн арга бол өөрчлөгдсөн, алга болсон, эсвэл 
	гэнэтийн файлуудыг хайх явдал юм. Өөрчлөгдсөн файлуудыг хайх хамгийн сайн арга 
	бол тэдгээрийг өөр (ихэвчлэн төвлөрсөн) хязгаарлагдмал хандалттай системээс хайх 
	явдал юм. Өөрийн аюулгүй байдлын скриптийг нэмэлт аюулгүй байдал хангасан 
	хязгаарлагдмал хандалттай систем дээр бичих нь тэдгээрийг боломжит халдагчдад 
	бараг харагдуулдаггүй бөгөөд энэ нь чухал юм. Давуу талыг хамгийн ихээр авахын 
	тулд ерөнхийдөө хязгаарлагдмал хандалттай хайрцагт бусад машинуудад хандах 
	тэр ач холбогдолтой хандалтыг өгөх хэрэгтэй. Үүнийг ихэвчлэн бусад машинуудын зөвхөн 
	унших NFS экспортыг хязгаарлагдмал хандалттай хайрцагт өгөх эсвэл ssh түлхүүр 
	хослолыг тохируулж хязгаарлагдмал хандалттай хайрцгийг бусад машинууд уруу ssh 
	хийхийг зөвшөөрөх  замаар хийдэг. Өөрийн сүлжээний урсгалыг тооцохгүй юм бол NFS нь 
	хамгийн харагддаггүй арга юм &mdash; энэ нь клиент хайрцаг бүр дэх файлын 
	системүүдийг монитор хийхийг танд зөвшөөрч бараг л илэрдэггүй. Хэрэв таны 
	хязгаарлагдмал хандалттай сервер нь клиент хайрцагнууд уруу hub буюу салаалагч эсвэл 
	чиглүүлэлтийн хэд хэдэн давхаргаар дамжин холбогдсон бол NFS арга нь хэтэрхий 
	аюултай (сүлжээний хувьд) байж болох бөгөөд ssh-ийг ашиглах нь түүний гаргадаг  
	аудит мөрийн замуудтай байсан ч гэсэн магадгүй илүү сонголт байж болох юм.</para>

      <para>Монитор хийгдэх клиент систем уруу хандахад хамгийн багаар бодоход унших эрхийг 
	та хязгаарлагдмал хандалттай хайрцагт өгсний дараа яг мониторыг хийхдээ скрипт бичих 
	хэрэгтэй. Өгөгдсөн NFS холболтод &man.find.1; болон &man.md5.1; зэрэг 
	энгийн системийн хэрэгслүүд ашиглан та скриптүүд бичиж болно. Клиент хайрцгийн 
	файлуудад өдөрт нэг удаа физикээр md5 хийж <filename class="directory">/etc</filename> болон
	<filename class="directory">/usr/local/etc</filename> сангууд дахь хяналтын файлуудыг 
	бүр илүү давтамжтайгаар шалгаж байх нь зүйтэй юм. Хязгаарлагдмал хандалттай 
	машины зөв гэж тооцсон md5 мэдээлэлтэй харьцуулахад тарахгүй файлууд олдвол 
	сисадминд үүнийг очиж шалгахыг хашгиран мэдээлэх ёстой. Аюулгүй байдлын сайн 
	скрипт нь тохирохгүй suid хоёртын файлууд болон <filename class="directory">/</filename> болон
	<filename class="directory">/usr</filename> зэрэг системийн хуваалтууд дээрх шинээр үүссэн 
	эсвэл устгагдсан файлуудыг бас шалгадаг.</para>

      <para>NFS биш ssh-ийг ашиглаж байх үед аюулгүй байдлыг скрипт бичих нь бүр илүү хэцүү 
	байдаг. Та скриптүүдийг харагдуулж ажиллуулахын тулд тэдгээрийг клиент хайрцаг уруу үндсэндээ 
	<command>scp</command> хийх хэрэгтэй бөгөөд аюулгүй байдлаа бодох юм бол 
	та тэдгээр скриптүүдийн ашигладаг хоёртын файлуудыг (find гэх зэрэг) бас 
	<command>scp</command> хийх хэрэгтэй юм. 
	Клиент хайрцаг дээрх <application>ssh</application> клиент аль хэдийн 
	эвдэгдсэн байж болох юм. Аюултай холболтоор ажиллаж байгаа бол ssh-г ашиглах нь 
	шаардлагатай байж болох боловч бас түүнтэй ажиллахад бүр илүү хэцүү байдаг юм.</para>

      <para>Аюулгүй байдлын сайн скрипт нь 
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> гэх зэрэг 
	<literal>MD5</literal> шалгалтын хүрээний гадуур байх хэрэглэгч болон 
	staff-ийн гишүүдийн хандалтын тохиргооны файлууд дахь өөрчлөлтүүдийг бас 
	шалгадаг.</para>

      <para>Хэрэв та асар их хэрэглэгчийн дискний зайтай бол тэдгээр хуваалтууд 
	дээр байгаа файл бүр дээр ажиллахад хэт удаж болох юм. Энэ тохиолдолд suid 
	хоёртын файлуудыг хаах холболтын тугуудыг зааж өгөх нь зүйтэй юм. 
	<literal>nosuid</literal> нь таны хайж байгаа тэр тохируулга юм. 
	Энэ давхаргын зорилго нь эвдлэн оролтын оролдлогуудыг амжилттай эсвэл 
	амжилтгүй болсноос үл хамааран илрүүлэх явдал учраас ямар ч гэсэн ядаж 
	долоо хоногт нэг удаа та тэдгээр файлуудыг магадгүй шалгаж байх 
	хэрэгтэй юм.</para>

      <para>Процессийн бүртгэл хийх нь (&man.accton.8;-г үзнэ үү) эвдлэн оролтын 
	дараах үнэлэх арга замууд болон тусалж болох харьцангуй бага ачаалал бүхий 
	үйлдлийн системийн боломж юм. Энэ нь эвдлэн орсны дараа файлыг хөндөөгүй хэвээр 
	гэж үзэн халдагч систем уруу хэрхэн эвдлэн орсныг мөрдөхөд ялангуяа ашигтай 
	байдаг.</para>

      <para>Эцэст нь аюулгүй байдлын скриптүүд нь бүртгэлийн файлуудыг процесс хийх ёстой 
	бөгөөд бүртгэлүүд өөрсдөө аль болох аюулгүй байдлаар үүсгэгдэх ёстой бөгөөд 
	алсын syslog нь их ашигтай байж болох юм. Халдагч өөрийн мөрийг арилгахыг 
	оролдох бөгөөд эхний эвдлэн оролтын арга болон хугацааг мөрдөхөд сисадмины хувьд  
	бүртгэлийн файлууд нь маш чухал байдаг юм. Бүртгэлийн файлуудын байнгын бичлэгийг 
	хадгалах нэг арга нь системийн консолыг сериал порт уруу ажиллуулж консолуудыг 
	хянаж аюулгүй машин дээр мэдээллийг цуглуулах явдал юм.</para>
    </sect2>

    <sect2>
      <title>Параной буюу хэт зовнил</title>

      <para>Бага зэргийн хэт зовнил буруудахгүй. Дүрэм болгож тав тухтай байдлыг 
	алдагдуулдаггүй дурын тооны аюулгүй байдлын боломжуудыг сисадмин нэмж болох бөгөөд 
	зарим анхаарлыг бодолцон тав тухтай байдалд <emphasis>нөлөөлөх</emphasis> 
	аюулгүй байдлын боломжуудыг бас нэмж болох юм. Бүр илүү чухал нь аюулгүй 
	байдлын администратор үүнийг бага зэрэг хольж хэрэглэж болно &mdash; хэрэв та энэ  
	баримтад дурдсан заавруудыг үгчлэн ашиглавал энэ баримтыг уншсан ирээдүйн халдагчид 
	та өөрийн арга замуудыг заан өгч байна гэсэн үг юм.</para>
    </sect2>

    <sect2>
      <title>Үйлчилгээг Зогсоох Халдлагууд</title>
      <indexterm><primary>Үйлчилгээг Зогсоох (DoS)</primary></indexterm>

      <para>Энэ хэсэг нь Үйлчилгээг Зогсоох халдлагуудыг хамарна. DoS халдлага нь 
	ихэвчлэн пакетийн халдлага байдаг. Таны сүлжээг дүүргэж байгаа орчин үеийн 
	хууран мэхэлсэн пакетийн халдлагуудын эсрэг нэг их юм хийж чадахгүй ч гэсэн 
	халдлагууд таны серверүүдийг унагахгүйн тулд та ерөнхийдөө хохирлыг 
	хязгаарлаж болно:</para>

      <orderedlist>
	<listitem>
	  <para>Серверийн fork хийлтийг хязгаарлах.</para>
	</listitem>

	<listitem>
	  <para>Springboard буюу бусад халдлагуудыг хязгаарлах (ICMP хариу халдлагууд, ping
	    цацалт, гэх мэт.).</para>
	</listitem>

	<listitem>
	  <para>Цөмийн чиглүүлэлтийн кэшийг хэт ачаалах.</para>
	</listitem>
      </orderedlist>

      <para>Нийтлэг DoS халдлагын дүр зураг бол fork хийгдэж байгаа серверт 
	халдаж түүнээр асар их хүүхэд процесс  үүсгүүлж эцсийн эцэст хост системийн 
	хувьд санах ой, файлын тодорхойлогчууд гэх мэтүүд дуусч зогсоход 
	хүргэдэг. <application>inetd</application> (&man.inetd.8;-г 
	үзнэ үү) нь энэ төрлийн халдлагыг хязгаарлах хэд хэдэн тохируулгатай. 
	Машиныг зогсоохоос хамгаалах боломжтой боловч ерөнхийдөө  үйлчилгээг 
	халдлагад өртүүлэхгүй байх боломжгүйг энд тэмдэглэх нь зүйтэй юм. 
	<application>inetd</application> гарын авлагын хуудсыг 
	анхааралтай уншиж <option>-c</option>, <option>-C</option>,
	болон <option>-R</option> тохируулгуудад ялангуяа анхаарлаа 
	хандуулаарай. Хууран мэхэлсэн IP халдлагууд нь 
	<application>inetd</application> дахь  
	<option>-C</option> тохируулгыг хуурах учраас ихэвчлэн тохируулгуудын 
	хослолыг ашиглах шаардлагатай. Зарим дан серверүүд өөрийн 
	fork хийгдэхийг хязгаарлах параметрүүдтэй байдаг.</para>

      <para><application>Sendmail</application> нь 
	<option>-OMaxDaemonChildren</option> тохируулгатай байдаг бөгөөд 
	энэ нь <application>Sendmail</application>-ийг ачаалал хязгаарлах тохируулгатай ажиллуулж ачааллын 
	хоцрогдол үүсгэснээс хавьгүй илүүтэйгээр ажилладаг. Та 
	<application>Sendmail</application>-г ажиллуулахдаа 
	хүссэн ачааллыг даахаар гэхдээ компьютерийг унагахаар их хэмжээний тоогоор 
	<application>Sendmail</application>-үүдийг ажиллуулах биш түүнээс 
	багаар <literal>MaxDaemonChildren</literal> параметрийг 
	хангалттай өндрөөр тавьж өгөх хэрэгтэй. Мөн <application>sendmail</application>-ийг дарааллын 
	горимоор (<option>-ODeliveryMode=queued</option>) ажиллуулах 
	болон дэмонг (<command>sendmail -bd</command>) дараалалтай 
	(<command>sendmail -q15m</command>) ажиллуулдгаас тусад нь ажиллуулах нь 
	чухал юм. Хэрэв та шууд илгээх горимыг хүсэж байгаа бол та дарааллыг  
	<option>-q1m</option> зэргээр бүр бага интервалаар ажиллуулах боломжтой 
	боловч <literal>MaxDaemonChildren</literal> тохируулгыг боломжийн 
	утгаар хоорондоо холбоотой амжилтгүйтлүүдээс <application>sendmail</application>-ийг  хамгаалахын 
	<emphasis>тулд</emphasis> зааж өгсөн эсэхээ шалгаарай.</para>

      <para><application>Syslogd</application>-д шууд халдаж болох учраас аль болох 
	<option>-s</option> тохируулгыг эсвэл <option>-a</option> тохируулгыг ашиглахыг 
	танд зөвлөдөг.</para>

      <para>Шууд халдлага хийгдэж болох <application>TCP Wrapper</application>-ийн 
	буцах identd зэрэг буцан холбогддог үйлчилгээнүүдийн хувьд та маш хянамгай байх 
	хэрэгтэй. Ийм учраас та <application>TCP Wrapper</application>-ийн 
	буцах identd боломжийг ерөнхийдөө ашиглах хэрэггүй юм.</para>

      <para>Та өөрийн захын чиглүүлэгчүүд дээрээ дотоод үйлчилгээнүүд уруугаа 
	гаднаас хандуулахгүй болгож галт ханаар хамгаалах нь зүйтэй юм. 
	Үүний цаадах санаа нь гаднаас ирж болзошгүй сүлжээ дүүргэх халдлагаас өөрийн LAN-г 
	хамгаалах явдал бөгөөд сүлжээн дээр тулгуурласан <username>root</username> 
	эрхийг буулгахаас дотоод үйлчилгээнүүдийг хамгаалах зүйлс тийм их биш юм. 
	exclusive буюу хамааруулаагүй галт ханыг үргэлж тохируулах хэрэгтэй, өөрөөр хэлбэл 
	<quote>A, B, C, D болон M-Z портуудаас <emphasis>бусад</emphasis> 
	бүгдийг галт ханаар хамгаалах хэрэгтэй</quote>. Ингэснээр та 
	<application>named</application> (хэрэв та бүсийн хувьд анхдагч бол),
	<application>ntalkd</application>,
	<application>sendmail</application> болон бусад Интернэтээс хандах 
	үйлчилгээнүүд зэрэг зарим нэг тусгай үйлчилгээнүүдийн портуудаас бусад бүх бага 
	дугаарын портуудыг галт ханаар хамгаалж чадах юм. Хэрэв та галт ханыг өөр 
	аргаар &mdash; inclusive буюу хамааруулсан эсвэл зөвшөөрсөн галт хана маягаар  
	тохируулахыг оролдвол хэд хэдэн үйлчилгээнүүдийг <quote>хаахаа</quote> 
	мартаж магадгүй юм, эсвэл та шинэ дотоод үйлчилгээ нэмээд галт ханаа шинэчлэхээ 
	мартаж болох юм. Та галт хана дээр зөвшөөрсөнтэй адил үйлдлийг нэвтрүүлэхийн 
	тулд бага дугаарын портуудыг нээлгүйгээр өндөр дугаарын портуудыг онгойлгож 
	болох юм. Мөн &os; нь динамик холболтод хэрэглэгддэг портуудыг 
	<command>sysctl</command>-ийн төрөл бүрийн 
	<varname>net.inet.ip.portrange</varname> хувьсагчуудаар 
	(<command>sysctl -a | fgrep portrange</command>) 
	хянах боломжийг танд олгодгийг бас тэмдэглэх нь зүйтэй юм. Энэ нь бас таны 
	галт ханын тохиргооны төвөгтэй байдлыг амарчилдаг юм. Жишээ нь 
	та ердийн 4000-аас 5000 хүртэлх портууд болон 49152-оос 65535 хүртэлх 
	өндөр дугаарын портуудыг ашигладаг бол 4000-аас бага бүгдийг 
	өөрийн галт хана дээр хаах хэрэгтэй (мэдээж Интернэтээс ханддаг хэдэн тусгай портуудаас 
	бусад).</para>

      <para>Өөр нийтлэг DoS халдлагуудын нэг нь springboard халдлага юм 
	&mdash; сервер, дотоод сүлжээ эсвэл бусад машиныг хариу үйлдэл хийхийг нь 
	ихэсгэж хэт ачаалахад хүргэдэг халдлага юм. Ийм маягийн хамгийн нийтлэг 
	халдлага нь <emphasis>ICMP ping broadcast буюу цацалт</emphasis> 
	юм. Халдагч таны LAN-ий цацах хаяг уруу илгээсэн ping пакетийнхаа  
	эхлэл IP хаягийг халдахыг хүсэж байгаа машиныхаа IP хаягаар сольж хуурдаг. 
	Хэрэв таны захын чиглүүлэгчүүд цацах хаяг уруу илгээх ping пакетуудыг 
	зогсоохоор тохируулагдаагүй бол таны LAN хангалттай хариу үүсгэн хууран мэхэлсэн 
	эхлэл хаяг уруу илгээж, ялангуяа халдагч хэдэн арван цацах хаягууд уруу өөр өөр 
	хэдэн арван сүлжээнүүдээр дамжин энэ башир аргаа ашигласан үед, хохирогчийг 
	дүүргэдэг. 120 мегабайтаас илүү хэмжээний цацах халдлага одоогоор 
	хэмжигдээд байна. Энэ төрлийн хоёр дахь нийтлэг халдлага нь ICMP-ийн алдаа 
	тайлагнах системийн эсрэг халдлага юм. ICMP алдааны мэдэгдэл үүсгэдэг 
	пакетуудыг бүтээж халдагч серверийн орж ирж байгаа сүлжээг дүүргэж ингэснээр 
	серверийг өөрийн гарах сүлжээг ICMP хариунуудаар дүүргэхэд хүргэдэг. 
	Энэ төрлийн халдлага нь ялангуяа хэрэв сервер үүсгэж байгаа ICMP хариунуудаа 
	хангалттай хурднаар шавхан гаргаж чадахгүй байгаа бол серверийг санах ойгүй болгож 
	сүйрүүлж бас болох юм. <application>sysctl</application>-ийн 
	<literal>net.inet.icmp.icmplim</literal> хувьсагчийг ашиглан 
	эдгээр халдлагуудыг хязгаарлах хэрэгтэй. Springboard төрлийн халдлагуудын 
	сүүлийн гол ангилал нь udp цуурай үйлчилгээ зэрэг зарим дотоод 
	<application>inetd</application> үйлчилгээнүүдтэй холбоотой юм. 
	Халдагч UDP пакетийг хууран мэхэлж A болон B сервер нь хоёулаа таны LAN-д байгаа 
	тийм A серверийн цуурай порт дээрх эхлэл хаягаар болон  төгсгөл хаягийг B серверийн 
	цуурай порт дээрх хаягаар сольдог. Уг хоёр сервер дараа нь энэ ганц пакетийг 
	хоорондоо шидэлцдэг.  Эдгээр серверүүд болон тэдгээрийн LAN-г энэ маягаар 
	халдагч хэдхэн пакетуудыг хатган оруулан хэт ачаалж чаддаг.	
	Үүнтэй адил асуудлууд дотоод <application>chargen</application> портод 
	бас байдаг. Чадварлаг сисадмин эдгээр бүх дотоод inetd тест үйлчилгээнүүдийг 
	хаадаг.</para>

      <para>Хууран мэхэлсэн пакетийн халдлагуудыг цөмийн чиглүүлэлтийн кэшийг хэт ачаалахад 
	хэрэглэж болдог. <varname>net.inet.ip.rtexpire</varname>,
	<varname>rtminexpire</varname>, болон <varname>rtmaxcache</varname>
	<command>sysctl</command> параметрүүдийг үзнэ үү. Дурын эхлэл 
	IP хаягийг ашигласан хууран мэхэлсэн пакетийн халдлага нь чиглүүлэлтийн хүснэгтэд түр зуур 
	кэш хийгдсэн чиглүүлэлтийг цөмөөр  үүсгүүлэхэд хүргэдэг бөгөөд энэ нь 
	<command>netstat -rna | fgrep W3</command> тушаалаар харагддаг. 
	Эдгээр чиглүүлэлтүүд нь ихэвчлэн 1600 секунд орчим хугацааны дотор дуусдаг.
	Хэрэв цөм кэш хийгдсэн чиглүүлэлтийн хүснэгт хэтэрхий том болсныг илрүүлэх юм бол 
	<varname>rtexpire</varname> динамикаар багасгадаг боловч 
	<varname>rtminexpire</varname>-с бага болтол хэзээ ч багасгадаггүй. 
	Хоёр асуудал байдаг:</para>
	
      <orderedlist>
	<listitem>
	  <para>Бага ачаалагдсан сервер гэнэт халдлагад өртөхөд цөм хангалттай хурдан 
		хариу үйлдэл хийдэггүй.</para>
	</listitem>
	
	<listitem>
	  <para><varname>rtminexpire</varname> хувьсагч нь 
		үргэлжилсэн халдлагыг цөм дааж чадахаар хангалттай бага байдаггүй.</para>
	</listitem>
      </orderedlist>
      
      <para>Хэрэв таны серверүүд Интернэтэд T3 эсвэл илүү хурдаар холбогдсон бол 
	&man.sysctl.8;-оор 
	<varname>rtexpire</varname> болон <varname>rtminexpire</varname> 
	хувьсагчуудыг хоёуланг гараар дарж бичихдээ хянамгай байх хэрэгтэй. 
	Аль ч параметрийг (машиныг сүйрүүлэхийг та хүсээгүй л бол) хэзээ ч битгий 
	0 болгоорой. Эдгээр параметрүүдийг хоёуланг нь 2 секунд болгох нь 
	чиглүүлэлтийн хүснэгтийг халдлагаас хамгаалахад хангалттай байх ёстой.</para>
    </sect2>

    <sect2>
      <title>Kerberos болон SSH-тэй холбоотой хандалтын асуудлууд</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>

      <para>Хэрэв та Kerberos болон ssh-г хоёуланг ашиглахаар бол цөөн хэдэн асуудлуудыг 
	дурдах хэрэгтэй. Kerberos 5 нь жинхэнийг шалгах маш сайн нэвтрэлтийн протокол 
	боловч түүнийг ашигласан <application>telnet</application> болон 
	<application>rlogin</application>-д байдаг алдаанууд нь энэ хоёр програмыг 
	хоёртын урсгалтай ажиллахад тохиромжгүй болгодог. Мөн <option>-x</option> 
	тохируулгыг ашиглахгүй л бол анхдагчаар Kerberos нь сессийг шифрлэдэггүй. 
	<application>ssh</application> нь бүгдийг шифрлэдэг.</para>

      <para>Ssh нь анхдагчаар шифрлэсэн түлхүүрүүдээ дамжуулдгаас бусад бүх л талаараа зэгсэн 
	сайн ажилладаг. Энэ нь юу гэсэн үг вэ гэхээр та хэрэв системийн бусад хэсэгт хандах боломж 
	олгодог түлхүүрүүд бүхий аюулгүй ажлын компьютертай бөгөөд та аюултай машин уруу ssh 
	хийвэл таны түлхүүрүүд ашиглагдах боломжтой гэсэн үг юм. Яг түлхүүрүүд нь өөрсдөө 
	ил гардаггүй боловч ssh нь таны нэвтэрсэн хугацааны туршид зориулж дамжуулах порт 
	суулгадаг бөгөөд хэрэв халдагч аюулгүй машин дээрх <username>root</username>-г 
	эвдсэн бол тэрхүү портыг таны түлхүүрүүдийг ашиглахын тулд хэрэглэн  таны түлхүүрээр 
	тайлагдах өөр бусад машинуудад хандах боломжийг олж авах боломжтой юм.</para>

      <para>Бид staff нэвтрэлтүүдийн хувьд аль болох ssh-г Kerberos-той цуг ашиглахыг 
	зөвлөдөг. <application>Ssh</application> нь Kerberos-ийн дэмжлэгтэй 
	эмхэтгэгдэж болдог. Энэ нь ил гарсан байж болзошгүй ssh түлхүүрүүдэд 
	найдах таны найдварыг багасгахын хамт нууц үгүүдийг Kerberos-оор хамгаалдаг.
	Ssh түлхүүрүүд нь аюулгүй машинуудын автоматчилагдсан ажлуудад (Kerberos-оор 
	хийхэд таарахгүй) зөвхөн хэрэглэгдэх ёстой. Мөн бид таныг ssh-ийн тохиргоондоо 
	key-forwarding буюу түлхүүр дамжуулалтыг болиулах эсвэл ssh-ийн  
	<filename>authorized_keys</filename> файлдаа зөвхөн тусгайлсан 
	машинуудаас нэвтрэхэд түлхүүрийг ашиглаж болохоор болгож зөвшөөрдөг 
	<literal>from=IP/DOMAIN</literal> тохируулгыг ашиглахыг зөвлөдөг.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Билл</firstname>
	  <surname>Свингл</surname>
	  <contrib>Хэсгүүдийг дахин бичиж шинэчилсэн </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, MD5, болон Crypt</title>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>crypt</secondary>
    </indexterm>

    <indexterm><primary>crypt</primary></indexterm>
    <indexterm><primary>Blowfish</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>&unix; систем дээрх хэрэглэгч бүрийн хувьд нууц үг бүртгэлтэй нь холбоотой 
	байдаг. Мэдээж эдгээр нууц үгүүд нь зөвхөн хэрэглэгч ба үйлдлийн системд 
	мэдэгдэж байх ёстой. Эдгээр нууц үгүүдийг нууцлаг байлгахын тулд тэдгээрийг 
	<quote>one-way hash буюу үл буцах хэш</quote> гэгддэг шифрлэхэд амархан 
	боловч буцааж болдоггүй аргаар шифрлэдэг. Өөрөөр хэлбэл хормын өмнө 
	мэдээж гэж хэлсэн бидний хэлсэн үг яг жинхэнэдээ үнэн биш юм: үйлдлийн систем
	өөрөө нууц үгийг <emphasis>жинхэнэдээ</emphasis> мэддэггүй. 
	Энэ нь зөвхөн нууц үгийн <emphasis>шифрлэсэн</emphasis> хэлбэрийг 
	мэддэг. <quote>plain-text буюу ердийн уншигдах текст </quote> 
	хэлбэрийн нууц үгийг авах цорын ганц арга нь боломжит нууц үгүүдийн орон зайгаас 
	балмадаар хүчлэн хайх явдал юм.</para>

    <para>Харамсалтай нь &unix; бий болсон тэр үед нууц үгийг аюулгүй аргаар 
	шифрлэх цорын ганц арга нь DES, Data Encryption Standard буюу 
	Өгөгдөл Шифрлэх Стандарт дээр үндэслэсэн байлаа. Энэ нь АНУ-д оршин 
	сууж байсан хэрэглэгчдийн хувьд тийм ч асуудалтай биш байсан юм, гэхдээ 
	DES-ийн эх код АНУ-аас гадагшаа экспорт хийгдэж болохгүй байсан 
	учир &os; нь АНУ-ын хуулийг дагахын хажуугаар DES-ийг ашигласан хэвээр
	байсан бусад бүх &unix; төрлүүдтэй нийцтэй байх арга замыг хайж олоход 
	хүрсэн юм.</para>

    <para>Үүний шийдэл нь АНУ-ын хэрэглэгчид DES сангуудыг суулгаж ашиглах боломжтой 
	мөртлөө олон улсын хэрэглэгчид гадагш экспорт хийгдэж болох шифрлэх аргатай бас 
	байхаар шифрийн сангуудыг хуваасан явдал байлаа. Ингэж &os; нь 
	MD5-ийг өөрийн анхдагч шифрлэх аргаа болгон ашиглах болсон юм. MD5 нь 
	DES-ээс илүү аюулгүй нууцлаг гэгддэг бөгөөд DES-ийг суулгах нь үндсэндээ 
	нийцтэй байх шалтгаануудын улмаас зориулагдсан юм.</para>

    <sect2>
      <title>Өөрийн Crypt арга замыг таних нь</title>

      <para>Одоогоор шифрийн сан DES, MD5 болон Blowfish хэш функцуудыг дэмждэг.
	Анхдагчаар &os; нь MD5 ашиглан нууц үгүүдийг шифрлэдэг.</para>

      <para>&os; аль шифрлэх аргыг тохируулж ашиглаж байгааг мэдэх хялбар байдаг. 
	<filename>/etc/master.passwd</filename> файл дахь шифрлэсэн 
	нууц үгийг шалгах нь нэг арга юм. MD5 хэшээр шифрлэгдсэн нууц үгүүд нь 
	DES-р шифрлэгдсэнийгээ бодох юм бол урт бөгөөд <literal>&dollar;1&dollar;</literal> 
	тэмдэгтээр бас эхэлдэг. <literal>&dollar;2a&dollar;</literal> 
	тэмдэгтээр эхэлсэн нууц үгүүд Blowfish хэш функцаар шифрлэгдсэн байдаг. 
	DES мөр нь ямар нэг тусгайлан таньж болох шинж тэмдэггүй  байдаг боловч 
	тэд MD5 нууц үгүүдээс богино бөгөөд <literal>&dollar;</literal> 
	тэмдэгт ордоггүй 64 тэмдэгттэй цагаан толгойгоор кодчилогддог, тиймээс 
	долларын тэмдэгтээр эхлээгүй харьцангуй богино мөр ихэвчлэн DES нууц үг 
	байдаг.</para>

      <para>Шинэ нууц үгүүдэд ашиглагдах нууц үгийн хэлбэр нь нэвтрэлтийн 
	<literal>passwd_format</literal> боломжийн тусламжтай 
	<filename>/etc/login.conf</filename> файлд хянагддаг бөгөөд 
	энэ хувьсагч нь <literal>des</literal>, <literal>md5</literal> 
	эсвэл <literal>blf</literal> утгуудыг авдаг. Нэвтрэлтийн 
	боломжуудын талаар дэлгэрэнгүй мэдээллийг &man.login.conf.5; 
	гарын авлагын хуудаснаас үзнэ үү.</para>

    </sect2>
  </sect1>

  <sect1 id="one-time-passwords">
    <title>Нэг удаагийн нууц үгүүд</title>
    <indexterm><primary>нэг удаагийн нууц үгүүд</primary></indexterm>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>нэг удаагийн нууц үгүүд</secondary>
    </indexterm>

    <para>Анхдагчаар &os; OPIE (One-time Passwords
      In Everything буюу Бүхэнд зориулсан нэг удаагийн нууц үгүүд) дэмжлэгтэй 
	байдаг бөгөөд энэ нь MD5 хэшийг анхдагчаар ашигладаг.</para>

    <para>Бид гурван өөр төрлийн нууц үгийг доор хэлэлцэх болно. Эхнийх нь таны ердийн 
	&unix; загварын эсвэл Kerberos нууц үг юм; бид үүнийг <quote>&unix; нууц үг</quote> 
	гэж нэрлэх болно. Хоёр дахь төрөл нь OPIE &man.opiekey.1; програмаар 
	үүсгэгдэж  &man.opiepasswd.1; програм болон нэвтрэлт хүлээх мөр хүлээн авах 
	нэг удаагийн нууц үг юм; бид үүнийг <quote>нэг удаагийн нууц үг</quote> гэх болно. 
	Сүүлийн төрөл нууц үг бол <command>opiekey</command> програмд 
	(заримдаа <command>opiepasswd</command> програмууд) өгдөг 
	нууцлаг нууц үг бөгөөд үүнийг ашиглан дээрх програмууд нэг удаагийн нууц үг 
	үүсгэдэг; бид үүнийг <quote>нууцлаг нууц үг</quote> гэх буюу эсвэл 
	зүгээр л шалгагдаагүй <quote>нууц үг</quote> гэх болно.</para>

    <para>Нууцлаг нууц үг нь таны &unix; нууц үгтэй ямар ч холбоогүй юм; тэдгээр нь 
	адил байж болох боловч ингэхийг зөвлөдөггүй. OPIE нууцлаг нууц үгүүд нь 
	хуучин &unix; нууц үгүүд шиг 8 тэмдэгтэд хязгаарлагддаггүй
	<footnote><para>&os; дээр стандарт нэвтрэх нууц үг уртаараа 128 тэмдэгт 
	хүртэл байж болдог.</para></footnote> бөгөөд таны хүссэн хэмжээний 
	урттай байж болдог. Зургаа эсвэл долоон үг бүхий өгүүлбэрээс тогтох нууц үгүүд 
	нэлээн элбэг байдаг. Ихэнх хэсгийн хувьд OPIE систем &unix;-ийн нууц үгийн 
	системээс бүр мөсөн ангид ажилладаг.</para>

    <para>Нууц үгээс гадна OPIE-д чухал өгөгдлийн өөр хоёр хэсэг байдаг. Нэг нь 
	<quote>seed буюу үр</quote> эсвэл <quote>key буюу түлхүүр</quote> гэгддэг 
	бөгөөд 2 үсэг болон таван тооноос тогтдог. Нөгөөдөх нь <quote>давталтын тоо</quote> 
	буюу 1-ээс 100 хүртэлх тоо юм. OPIE нэг удаагийн нууц үгийг үр болон нууцлаг 
	нууц үгийг нийлүүлэн MD5 хэшийг давталтын тоогоор ашиглан үүсгэж үр дүнг нь 
	зургаан богино Англи үг болгодог. Эдгээр зургаан Англи үг нь таны нэг удаагийн нууц 
	үг юм. Нэвтрэлт шалгах систем (үндсэндээ PAM) ашигласан хамгийн сүүлийн нэг удаагийн 
	нууц үгийг хадгалж байдаг бөгөөд хэрэглэгчийн өгсөн нууц үгийн хэш өмнөх нууц үгтэй таарч 
	байвал хэрэглэгчийг нэвтрүүлдэг. Үл буцах хэш ашиглагддаг болохоор хэрэв 
	амжилттайгаар ашиглагдсан нууц үгийг олж авсан бол дараа дараагийн нэг удаагийн 
	нууц үгүүдийг үүсгэх боломжгүй байдаг; хэрэглэгч болон нэвтрэлтийн програмыг хамгийн 
	сүүлийн хэлбэрт адилхан байлгаж байхын тулд давталтын тоо амжилттай нэвтрэлт хийгдэх бүрийн 
	дараа багасаж байдаг. Давталтын тоо 1 хүрэх үед OPIE дахин хийгдэх 
	хэрэгтэй болно.</para>

    <para>Систем болгоны хувьд хэдэн програмууд байдаг бөгөөд тэдгээрийг бид энд 
	хэлэлцэх болно. <command>opiekey</command> програм давталтын 
	тоо, үр болон нууцлаг нууц үгийг хүлээн авч нэг удаагийн нууц үг эсвэл 
	нэг удаагийн нууц үгүүдийн үргэлжилсэн жагсаалтыг үүсгэдэг. 
	<command>opiepasswd</command> програмыг OPIE-г эхлүүлэх болон 
	нууц үг, давталтын тоо эсвэл үр өөрчлөхөд ашигладаг; энэ нь  
	нууцлаг нэвтрэх үгс аль эсвэл давталтын тоо, үр болон нэг удаагийн нууц үгийг 
	авдаг. <command>opieinfo</command> програм тохирох итгэмжлэлүүдийн 
	файлуудыг (<filename>/etc/opiekeys</filename>) шалгаж 
	ажиллуулсан хэрэглэгчийн одоогийн давталтын тоо болон үрийг дэлгэцэд 
	гаргадаг.</para>

    <para>Бид дөрвөн өөр төрлийн үйлдлийн талаар хэлэлцэх болно. Эхнийх нь аюулгүй 
	холболтоор <command>opiepasswd</command> ашиглаж нэг удаагийн нууц үгүүдийг 
	эхний удаа тохируулах эсвэл өөрийн нууц үг эсвэл үрийг өөрчлөх үйлдэл юм. 
	Хоёр дахь үйлдэл нь <command>opiepasswd</command>-г аюултай холболтоор, 
	<command>opiekey</command> тушаалыг аюулгүй холболтоор ашиглаж 
	адил үйлдлийг хийх явдал юм. Гурав дахь нь <command>opiekey</command>-г 
	аюултай холболтоор ашиглан нэвтрэн орох үйлдэл юм. Дөрөв дэх нь 
	<command>opiekey</command>-г ашиглан хэд хэдэн түлхүүрүүд үүсгэх үйлдэл 
	бөгөөд гадагшаа аюулгүй холболтуудгүй газрууд уруу явахдаа тэдгээр түлхүүрүүдийг бичин авч 
	эсвэл хэвлэн аваад өөртөө авч явж болох юм.</para>

    <sect2>
      <title>Аюулгүй холболт эхлүүлэх</title>
      <para>OPIE-г эхний удаа эхлүүлэхдээ <command>opiepasswd</command> 
	тушаалыг ажиллуул:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para><prompt>Enter new secret pass phrase:</prompt> эсвэл
        <prompt>Enter secret password:</prompt> мөрүүд дээр та 
	нууц үг эсвэл өгүүлбэр оруулах ёстой. Энэ нь таны нэвтрэхдээ ашиглах 
	нууц үг биш гэдгийг санах хэрэгтэй, үүнийг ашиглаж таны нэг удаагийн 
	нэвтрэх түлхүүрийг үүсгэдэг. <quote>ID</quote> мөр таны 
	тухайн үеийн параметрүүд болох таны нэвтрэх нэр, давталтын тоо болон 
	үрийг өгдөг. Нэвтрэн орох үед систем эдгээр параметрүүдийг санаж 
	танд тэдгээрийг санах шаардлагагүйгээр буцаан үзүүлдэг. Сүүлийн мөр нь 
	тэдгээр параметрүүд болон таны нууцлаг нууц үгт харгалзах нэг удаагийн 
	нууц үгийг өгдөг; хэрэв та нэн даруй дахин нэвтэрвэл энэ нэг удаагийн нууц үг 
	нь таны ашиглах тэр нууц үг юм.</para>
    </sect2>

    <sect2>
      <title>Аюултай холболт эхлүүлэх</title>
      
      <para>Өөрийн нууцлаг нууц үгийг аюултай холболтоор эхэлж өгөхдөө эсвэл 
	өөрчлөхдөө <command>opiekey</command> ажиллуулж болох тийм газар уруу 
	аюулгүй холболттой байж байх шаардлагатай; энэ нь таны итгэж байгаа машин 
	дээр бүрхүүлийн тушаал хүлээх мөр хэлбэрээр байж болно. Та бас давталтын тоог 
	(100 боломжийн утга байж болох юм) бодож өгөх хэрэгтэй бөгөөд та өөрөө үр 
	бодож олох эсвэл дурын үүсгэснийг ашиглах хэрэгтэй. Аюултай холболтоор 
	(таны эхлүүлж байгаа машин уруу) <command>opiepasswd</command> 
	тушаалыг ашигла:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

      <para>Анхдагч үрийг хүлээж авах бол <keycap>Return</keycap> дар.
	Дараа нь хандах нууц үгийг оруулахын өмнө аюулгүй холболт уруугаа 
	орж адил параметрүүдийг өгөөрэй:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Одоо аюултай холболт уруугаа шилжиж үүсгэсэн нэг удаагийн нууц үгээ 
	тохирох програм уруу хуулаарай.</para>
    </sect2>

    <sect2>
      <title>Нэг удаагийн нууц үг ганцыг үүсгэх нь</title>

      <para>OPIE-г эхлүүлэн тохируулж нэвтэрсний дараа танд иймэрхүү тушаал 
	хүлээх мөр харуулагдана:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>Энэ дашрамд тэмдэглэн хэлэхэд OPIE тушаал хүлээх мөрүүд ашигтай боломжтой 
	байдаг: хэрэв та нууц үг хүлээх мөр дээр <keycap>Return</keycap> 
	дарвал хүлээх мөр цуурайг идэвхжүүлж таны юу бичиж байгааг танд харуулдаг. 
	Та хэвлэсэн зүйлээсээ харж магадгүй нууц үгийг гараараа бичиж оруулахыг 
	оролдож байгаа бол энэ маш ашигтай байж болох юм.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>Энэ үед нэвтрэлт хүлээх мөрөнд хариулахын тулд та өөрийн нэг удаагийн нууц үгийг 
	үүсгэх хэрэгтэй болно. Үүнийг <command>opiekey</command> тушаал итгэн ажиллуулж 
	чадах тийм систем дээрээ хийх хэрэгтэй. (DOS, &windows; болон &macos;-д 
	зориулсан эдгээрийн хувилбарууд байдаг) Эдгээрт давталтын тоо болон үр тушаалын 
	мөрийн тохируулга хэлбэрээр хэрэгтэй байдаг. Та нэвтрэн орж байгаа машиныхаа 
	нэвтрэлт хүлээх мөрөөс эдгээрийг шууд хуулан тавьж болох юм.</para>

      <para>Итгэсэн систем дээрээ:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Одоо та өөрийн нэг удаагийн нууц үгтэй болсон болохоор нэвтрэлтээ 
	үргэлжлүүлж болно.</para>
    </sect2>

    <sect2>
      <title>Нэг удаагийн нууц үг олныг үүсгэх нь</title>

      <para>Заримдаа та итгэсэн машин эсвэл аюулгүй холболт уруу хандах боломжгүй 
	тийм газар очих хэрэгтэй болдог. Энэ тохиолдолд <command>opiekey</command> 
	тушаал ашиглаж хэд хэдэн нэг удаагийн нууц үгүүдийг урьдчилан үүсгэж хэвлэн 
	биедээ авч явах боломжтой юм. Жишээ нь:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para><option>-n 5</option> нь дараалсан таван түлхүүрийг үүсгэхийг, 
	<option>30</option> нь сүүлийн давталтын тоог хэд байх ёстойг зааж өгч 
	байгаа юм. Эдгээр нь ашиглах бололцоотойг <emphasis>урвуу</emphasis>
	дарааллаар дэлгэцэнд харуулдгийг тэмдэглэх нь зүйтэй. Хэрэв та хэт санаа 
	зовниж байгаа бол та үр дүнг гараар бичиж авахыг хүсэж болох юм; 
	эсвэл <command>lpr</command> уруу хуулан авч тавьж болох юм. Мөр бүр 
	давталтын тоо болон нэг удаагийн нууц үгийг харуулж байгааг анхаараарай; 
	та нууц үгүүдийг хэрэглэх бүртээ тэдгээрийг арилгаж энэ хэвлэсэн арга тань ашигтай 
	хэвээр болохыг мэдэж болох юм.</para>
    </sect2>

    <sect2>
      <title>&unix; нууц үгүүдийг ашиглахыг хязгаарлах нь</title>

      <para>OPIE нь &unix; нууц үгүүдийн ашиглалтыг нэвтрэлтийн сессийн IP хаяг дээр тулгуурлан 
	хязгаарлаж чаддаг. Тохирох файл нь <filename>/etc/opieaccess</filename> 
	бөгөөд энэ файл нь анхдагчаар байдаг. Энэ файлын талаар болон 
	үүнийг ашигласнаар та аюулгүй байдлын ямар зүйлсүүдийг бодолцож анхаарах ёстой талаар 
	дэлгэрэнгүй мэдээллийг &man.opieaccess.5;-с шалгана уу.</para>
	
      <para>Энд жишээ <filename>opieaccess</filename> файл байна:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Энэ мөр нь &unix; нууц үгүүдийг ямар ч үед ашиглахын тулд эхлэл IP хаягийг  
	(хууран мэхлэхэд хүрч болох тийм эмзэг) заагдсан утга болон багтай тааруулах 
	боломжийг хэрэглэгчдэд олгодог.</para>
	
      <para><filename>opieaccess</filename> дахь аль ч дүрэм таарахгүй байгаа 
	бол анхдагчаар OPIE биш нэвтрэлтүүдийг хааж үгүйсгэдэг.</para>

    </sect2>
  </sect1>

  <sect1 id="tcpwrappers">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Бичсэн </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>TCP Гүйцэтгэлийг хялбаршуулагчид</primary></indexterm>
      
    <title>TCP Гүйцэтгэлийг хялбаршуулагчид</title>

    <para>&man.inetd.8;-г мэддэг хэн бүхэн <acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын 
	талаар заримдаа сонссон байх. Гэхдээ цөөн хүмүүс энэ боломжийн 
	сүлжээний орчин дахь ашигтай талыг бүрэн ойлгодог юм шиг санагддаг. 
	Хүн бүхэн сүлжээний холболтууд зохицуулах галт хана суулгахыг хүсдэг 
	юм шиг санагддаг.  Галт хана олон төрлийн хэрэглээтэй боловч 
	холболт үүсгэгч уруу текст илгээх зэрэг зарим зүйлсийг галт хана хийж  
	чаддаггүй. Энд дурдсан <acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчид энэ мэтийг болон 
	үүнээс илүүг хийдэг. Дараагийн хэдэн хэсэгт <acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын 
	олон боломжуудыг хэлэлцэх бөгөөд боломжтой үед нь жишээ тохиргооны 
	мөрийг үзүүлэх болно.</para>

    <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчид програм хангамж нь 
	<application>inetd</application>-ийн чадваруудыг сервер бүрийн 
	хувьд түүний доор хянагдаж болохоор дэмжин өргөтгөдөг. Энэ аргыг ашиглан 
	бүртгэл хөтлөх дэмжлэг нэмэх, холболтууд уруу мэдэгдэл буцаах, дэмонд 
	зөвхөн дотоод холболтуудыг хүлээн авахыг зөвшөөрөх гэх мэт үйлдлүүдийг 
	хийх боломжтой. Эдгээр боломжуудын заримыг галт хана суулган тохируулж хийж  
	болох боловч энэ нь зөвхөн хамгаалалтын нэмэлт давхарга болохоос гадна 
	галт ханын үзүүлж чаддагаас илүү хяналтыг олгодог юм.</para>

    <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын ийнхүү нэмэгдсэн  
	ажиллагаа нь сайн галт ханыг солихоор зүйл гэж ойлгогдох ёсгүй юм. 
	<acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчид нь галт хана 
	эсвэл өөр бусад аюулгүй байдлыг нэмэгдүүлэгч програмуудын хамтаар 
	ашиглагдаж системийн хувьд хамгаалалтын нэмэлт давхарга болон аятайхан 
	үйлчлэх боломжтой юм.</para>

    <para>Энэ нь <application>inetd</application>-ийн тохиргооны өргөтгөл болохоор 
	энэхүү баримтыг уншигч таныг <link linkend="network-inetd">inetd тохиргоо</link> 
	хэсгийг уншсан гэдэгт найдаж байна.</para>

    <note>
      <para>&man.inetd.8;-ээр ажиллуулагдсан програмууд яг жинхэнээрээ 
	<quote>дэмонууд</quote> биш боловч тэдгээрийг уламжлалаар дэмонууд гэдэг. 
	Энэ ухагдахууныг бид энэ хэсэгт бас ашиглах болно.</para>
    </note>

    <sect2>
      <title>Эхний тохиргоо</title>

      <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдыг &os;-д 
	ашиглахад  байх цорын ганц шаардлага нь <application>inetd</application> серверийг 
	<filename>rc.conf</filename> файлаас <option>-Ww</option> 
	тохируулгатай ажиллуулсан эсэхийг шалгах явдал юм; энэ нь анхдагч тохиргоо 
	юм. Мэдээж <filename>/etc/hosts.allow</filename> файлын 
	зөв тохиргоо бас байгааг хүлээж байдаг боловч эдгээр тохиолдлуудад 
	&man.syslogd.8; системийн бүртгэлүүдэд мэдэгдлүүд шиддэг.</para>

      <note>
	<para>Бусад <acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын 
	шийдлүүдтэй харьцуулах юм бол <filename>hosts.deny</filename> 
	файлыг хэрэглэхээ больсон. Тохиргооны бүх сонголтууд 
	<filename>/etc/hosts.allow</filename> файлд байх шаардлагатай.</para>
      </note>

      <para>Хамгийн амархан тохиргоогоороо бол дэмоны холболтын бодлогууд 
	зөвшөөрөгдсөн эсвэл хаагдсаны аль нэгээр <filename>/etc/hosts.allow</filename> 
	файл дахь тохируулгуудаас хамааран тохируулагддаг. &os; дээрх анхдагч 
	тохиргоо нь <application>inetd</application>-ээр эхэлсэн дэмон бүр уруу хийгдэх 
	холболтыг зөвшөөрдөг. Үүнийг өөрчлөх талаар зөвхөн үндсэн тохиргооны тухай  
	дурдсаны дараа хэлэлцэх болно.</para>

      <para>Үндсэн тохиргоо ихэвчлэн <literal>дэмон : хаяг : үйлдэл</literal> 
	хэлбэрийг авдаг. Энд байгаа <literal>дэмон</literal> нь 
	<command>inetd</command>-ийн эхлүүлсэн дэмоны нэр юм. 
	<literal>Хаяг</literal> нь зөв хостын нэр, <literal>address</literal> 
	хаяг эсвэл дөрвөлжин хаалтан ([&nbsp;]) доторх IPv6 хаяг байж болно. 
	<literal>action</literal> буюу үйлдлийн талбар нь <literal>allow</literal> буюу зөвшөөрөх 
	эсвэл <literal>deny</literal> буюу эрхийг хориглох эсвэл хандалтыг хаахын аль нэг байна. 
	Тохиргоо эхний тохирсон дүрэм журмын дагуу ажилладаг гэдгийг 
	санах хэрэгтэй, энэ нь тохирох дүрмийг тохиргооны файлаас өсөх дарааллаар 
	хайна гэсэн үг юм. Тохирох дүрэм олдвол тэр дүрэм ашиглагдаж хайх 
	процесс зогсоно.</para>

      <para>Бусад хэд хэдэн тохируулгууд байдаг боловч тэдгээрийг энэ хэсгийн сүүлд 
	тайлбарлах болно. Хялбар тохиргооны мөр ганцхан тэр мэдээллийн дагуу амархнаар 
	хийгдэж болно. Жишээ нь 
	<filename role="package">mail/qpopper</filename> дэмоноор дамжин 
	хийгдэж болох <acronym>POP</acronym>3 холболтуудыг зөвшөөрөхийн тулд 
	дараах мөрүүд <filename>hosts.allow</filename> файлд нэмж хийгдэх 
	хэрэгтэй:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>Энэ мөрийг нэмснийхээ дараа <application>inetd</application>-г дахин эхлүүлэх 
	хэрэгтэй. Үүнийг &man.kill.1; тушаал эсвэл <filename>/etc/rc.d/inetd</filename>-г 
	<parameter>restart</parameter> параметртай ашиглан хийж болно.</para>
      </sect2>

      <sect2>
        <title>Дэвшилтэт тохиргоо</title>

      <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчид нь бас дэвшилтэт 
	тохируулгуудтай байдаг; тэдгээр нь холболтуудтай хэрхэн ажиллахыг илүүтэйгээр 
	хянах боломжийг олгодог. Зарим тохиолдолд тодорхой хостууд эсвэл дэмон 
	холболтууд уруу тайлбар буцаах нь зүйтэй санаа байж болох юм. Бусад 
	тохиолдолд магадгүй бүртгэлийн файл бичигдэх ёстой эсвэл цахим захидал 
	администратор уруу илгээгдэж болох юм. Бусад тохиолдлууд үйлчилгээг зөвхөн 
	дотоод холболтууддаа ашиглахыг шаардаж болох юм. Эдгээр нь бүгдээрээ  
	<literal>орлуулагддаг тэмдэгтүүд</literal>, өргөтгөх тэмдэгтүүд болон 
	гадаад тушаалыг ажиллуулах зэрэг тохиргооны сонголтуудын тусламжтай хийгдэх 
	боломжтой юм. Дараагийн хоёр хэсэгт эдгээр тохиолдлуудын талаар бичсэн 
	байгаа.</para>
	
      <sect3>
	<title>Гадаад тушаалууд</title>

	<para>Холболтыг хааж түүнийг тогтоохыг оролдсон хүн уруу шалтгааныг нь 
	илгээх тохиолдол гарчээ гэж бодъё. Үүнийг яаж хийх вэ? Энэ үйлдлийг 
	<option>twist</option> тохируулга ашиглан хийх боломжтой. 
	Холболт тогтоохоор оролдоход <option>twist</option> тохируулга 
	бүрхүүлийн тушаал эсвэл скрипт ажилуулахаар дуудагддаг. 
	<filename>hosts.allow</filename> файлд үүний жишээ аль хэдийн 
	орсон байдаг:</para>

	<programlisting># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>Энэ жишээ нь <quote>You are not allowed to use <literal>daemon</literal>
	  from <literal>hostname</literal>.</quote> буюу 
	<quote>Та <literal>дэмон</literal>ыг <literal>hostname</literal>-с 
	ашиглах зөвшөөрөлгүй.</quote> гэсэн мэдэгдлийг хандалтын файлд урьдаар 
	тохируулагдаагүй дэмон бүрийн хувьд буцаадаг. Энэ нь тогтоогдсон холболт дөнгөж 
	салсны дараа холболтыг эхлүүлэгч уруу хариултыг буцааж илгээхэд маш их ашигтай 
	байдаг. Буцсан мэдэгдэл бүр <literal>"</literal> тэмдэгтүүд дотор 
	заавал байх <emphasis>шаардлагатай</emphasis>; энэ дүрмэнд ямар нэг 
	жич зөвшөөрөл байхгүй.</para>

	<warning>
	  <para>Хэрэв халдагч эсвэл бүлэг халдагчид эдгээр дэмонуудыг холболт хийх 
	хүсэлтээр цутгаж чадах юм бол серверийн эсрэг үйлчилгээг зогсоох халдлага явуулах 
	боломжтой байж болох юм.</para>
	</warning>

	<para>Өөр нэг боломж нь эдгээр тохиолдлуудад <option>spawn</option> 
	тохируулгыг ашиглах явдал юм. <option>twist</option> тохируулгын 
	нэгэн адил <option>spawn</option> тохируулга нь холболтуудыг сохроор 
	хааж гадаад бүрхүүлийн тушаалууд эсвэл скриптүүдийг ажиллуулахад ашиглагдаж 
	болно. <option>twist</option> тохируулгаас ялгаатай тал нь 
	<option>spawn</option> нь холболт тогтоосон хүн уруу хариулт буцааж 
	илгээдэггүй. Жишээ нь дараах тохиргооны мөр байжээ гэж бодъё:</para>

	<programlisting># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>Энэ нь <hostid role="fqdn">*.example.com</hostid> домэйноос 
	ирсэн бүх холболтын оролдлогуудаас татгалзахын зэрэгцээ хостын нэр, <acronym>IP</acronym> 
	хаяг  болон тэдний хандалт хийхийг оролдсон дэмонг <filename>/var/log/connections.log</filename> 
	файл уруу бүртгэнэ.</para>

	<para>Дээр тайлбарласан орлуулах тэмдэгтүүдээс гадна, өөрөөр хэлбэл 
	<literal>%a</literal> тэмдэгтээс гадна бусад цөөн хэдэн тэмдэгтүүд бас байдаг. Бүрэн жагсаалтыг 
	&man.hosts.access.5; гарын авлагын хуудаснаас үзнэ үү.</para>
      </sect3>

      <sect3>
	<title>Орлуулагддаг тэмдэгтүүдийн тохиргоонууд</title>

	<para>Энэ хүртэл <literal>ALL</literal> тохируулга бүх л жишээнүүдэд 
	ашиглагдлаа. Ажиллагааг арай цаашлуулж өргөтгөх бусад тохируулгууд 
	байдаг. Жишээ нь <literal>ALL</literal> нь дэмон, домэйн эсвэл 
	<acronym>IP</acronym> хаягийн аль нэгтэй тааруулах зорилгоор 
	ашиглагдаж болох юм. Өөр нэг орлуулагддаг тэмдэгт нь 
	<acronym>IP</acronym> хаягаа өөрчлөн хуурсан байж болох дурын хостыг 
	тааруулах <literal>PARANOID</literal> тохируулга юм. Өөрөөр хэлбэл 
	<literal>PARANOID</literal> буюу хэт зовнил нь 
	өөрийн хостын нэрээс өөр <acronym>IP</acronym> хаягтай машинаас 
	холболт хийгдэх бүр түүнд тохирох үйлдлийг тодорхойлоход ашиглагдаж 
	болох юм. Дараах жишээ энэ хэлэлцүүлэгт арай илүү ойлголт өгч магадгүй 
	юм:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>Энэ жишээн дээр <command>sendmail</command> уруу хийгдэж байгаа 
	өөрийнхөө хостын нэрээс өөр <acronym>IP</acronym> хаягтай холболтын бүх 
	хүсэлтүүдээс татгалзан хааж байна.</para>

	<caution>
	  <para>Хэрэв клиент эсвэл сервер эвдэрхий <acronym>DNS</acronym> 
	суулгацтай бол <literal>PARANOID</literal> орлуулагддаг тэмдэгтийг ашиглах нь серверүүдийг 
	ноцтойгоор зэрэмдэг болгож болох юм. Иймд администраторын зохион байгуулалт 
	болон хуваарилалт хийхийг зөвлөж байна.</para>
	</caution>

	<para>Орлуулагддаг тэмдэгтүүдийн талаар болон тэдэнтэй холбоотой ажиллагааны 
	талаар дэлгэрэнгүйг &man.hosts.access.5; гарын авлагын хуудаснаас 
	үзээрэй.</para>

	<para>Тусгай тохиргооны аль ч мөрүүдийн өмнө дээрх нь ажиллана, эхний тохиргооны 
	мөр <filename>hosts.allow</filename> файлд тайлбар болгон хаагдах 
	шаардлагатай. Үүнийг энэ хэсгийн эхэнд тэмдэглэж хэлсэн байгаа.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="kerberos5">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Тиллмэн</firstname>
	  <surname>Хоожсон</surname>
	  <contrib>Хойно дурдсан хүний бичсэн дээр тулгуурлан хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Марк</firstname>
	  <surname>Мюррей</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>Kerberos5</application></title>

    <para><application>Kerberos</application> нь хэрэглэгчид өөрсдийгөө нууцлаг серверийн үйлчилгээнүүдийн 
	тусламжтайгаар таниулан нэвтрэх боломжийг олгодог сүлжээний нэмэлт систем/протокол юм.
	Алсын нэвтрэлт, алсын хуулбар, нууцлаг систем хоорондох файл хуулбарлалт болон 
	бусад аюул ихтэй үйлдлүүд зэрэг үйлчилгээнүүд харьцангуй аюулгүй хийгдэж илүү хяналт хийж 
	болохоор болсон.</para>

    <para><application>Kerberos</application> нь хэн бэ гэдгийг шалгах прокси систем 
	юм. Энэ нь бас итгэгдсэн гуравдагч нэвтрэлт таних систем гэж тайлбарлагдаж 
	болно. <application>Kerberos</application> нь зөвхөн нэг функцыг 
	хангадаг &mdash; сүлжээн дээр хэрэглэгчдэд өөрсдийгөө аюулгүйгээр таниулах 
	боломжийг хангаж өгдөг. Энэ нь шалгаж таних функцууд (хэрэглэгчдийн 
	хийхийг зөвшөөрдөг) эсвэл аудит функцуудын (тэдгээр хэрэглэгчид юу хийснийг) 
	үүргийг гүйцэтгэдэггүй. Клиент болон сервер өөрийгөө таниулж батлахаар 
	<application>Kerberos</application>-г ашигласны дараа тэд бизнесээ бодож 
	өөрсдийн бүх холболтуудаа шифрлэж нууцлал болон бүрэн бүтэн байдлаа хадгалан 
	баталгаажуулж болно.</para>

    <para>Иймээс <application>Kerberos</application>-ийг нэвтрэлт танилт болон 
	аудит үйлчилгээнүүдийг хангадаг бусад аюулгүй байдлын аргуудтай цуг ашиглахыг 
	маш ихээр зөвлөдөг.</para>

    <para>Дараах заавруудыг &os;-д зориулан түгээгдсэн <application>Kerberos</application>-ийг 
	хэрхэн тохируулах гарын авлага болгон ашиглаж болно. Гэхдээ та тохирох гарын авлагын 
	хуудаснуудаас бүрэн тайлбарын талаар лавлах хэрэгтэй.</para>

    <para><application>Kerberos</application>-ийн суулгацыг үзүүлэх зорилгоор 
	төрөл бүрийн нэрийн талбарууд дараах байдлаар зохицуулагдана:</para>

    <itemizedlist>
      <listitem>
	<para><acronym>DNS</acronym> домэйн (<quote>бүс</quote>)
	  нь example.org байна.</para>
      </listitem>

      <listitem>
	<para><application>Kerberos</application> хүрээ нь 
	  EXAMPLE.ORG байна.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Хэрэв та дотооддоо ажиллуулах бодолтой байсан ч гэсэн <application>Kerberos</application>-ийг 
	суулгаж тохируулахдаа жинхэнэ домэйны нэрүүдийг ашиглана уу. Энэ нь 
	<acronym>DNS</acronym>-ийн асуудлуудыг тойрон гарч 
	бусад <application>Kerberos</application> хүрээнүүдтэй хийх 
	хоорондын үйлдлийг баталгаажуулдаг.</para>
    </note>

    <sect2>
      <title>Түүх</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>түүх</secondary>
      </indexterm>

      <para><application>Kerberos</application>-ийг <acronym>MIT</acronym> 
	анх сүлжээний аюулгүй байдлын асуудлуудын шийдэл болгож хийсэн. 
	<application>Kerberos</application> протокол нь хүчирхэг криптографыг 
	ашигладаг бөгөөд клиент нь аюултай сүлжээний холболтоор өөрийгөө хэн бэ гэдгийг 
	серверт (болон эсрэгээр) баталж чадах боломжийг олгодог.</para>

      <para><application>Kerberos</application> нь сүлжээний танин шалгах 
	протоколын нэрээс гадна програмыг (жишээ нь <application>Kerberos</application> 
	телнет) шийдвэрлэж байгаа програмуудыг тайлбарласан тайлбар бас болдог. 
	Протоколын одоогийн хувилбар нь 5 бөгөөд <acronym>RFC</acronym>&nbsp;1510-д 
	тайлбарласан байдаг.</para>

      <para>Өргөн хүрээний үйлдлийн системүүдийг хамарсан энэ протоколын хэд хэдэн чөлөөтэй 
	шийдлүүд  байдаг. <application>Kerberos</application> анх хөгжүүлэгдсэн 
	Массачусетсийн Технологийн Институт (<acronym>MIT</acronym>) нь 
	өөрийн <application>Kerberos</application> багцыг хөгжүүлсээр байна. 
	Энэ багц нь <acronym>US</acronym>-д криптограф бүтээгдэхүүн болж нийтлэг 
	хэрэглэгддэг бөгөөд энэ нь түүхээс авч үзэхэд <acronym>US</acronym>-ын 
	экспортын дүрэм журмуудаас болсон юм. <acronym>MIT</acronym>
	<application>Kerberos</application> нь порт 
	(<filename role="package">security/krb5</filename>) хэлбэрээр байдаг.
	Heimdal <application>Kerberos</application> нь өөр шийдлийн 5-р 
	хувилбар бөгөөд экспортын дүрэм журмуудыг тойрон гарах зорилгоор 
	<acronym>US</acronym>-ээс гадна хамааралгүйгээр хөгжүүлэгдсэн (
	бөгөөд ихэвчлэн арилжааны бус &unix; төрлүүдэд орсон байдаг) юм. 
	Heimdal <application>Kerberos</application> түгээлт нь 
	порт (<filename role="package">security/heimdal</filename>) 
	хэлбэрээр байдаг бөгөөд үүний хамгийн бага суулгац үндсэн &os; суулгацад 
	орсон байдаг.</para>

    <para>Аль болох олон үзэгчдийг хамрахын тулд эдгээр зааврууд нь &os;-д орсон 
	Heimdal түгээлтийг ашиглаж байна гэж тооцдог.</para>

    </sect2>

    <sect2>
      <title>Heimdal <acronym>KDC</acronym> суулгаж тохируулах</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Түлхүүр Түгээх Төв</secondary>
      </indexterm>

      <para>Түлхүүр Түгээх Төв (<acronym>KDC</acronym>) нь 
	<application>Kerberos</application>-ийн хангадаг төвлөрсөн нэвтрэлт таних 
	үйлчилгээ юм &mdash; энэ нь <application>Kerberos</application> 
	тасалбарууд өгдөг компьютер юм. <acronym>KDC</acronym> нь 
	<application>Kerberos</application> хүрээний бусад бүх компьютеруудад 
	 <quote>итгэгдсэн</quote> гэж тооцогддог бөгөөд аюулгүй байдлын санаа зовнилыг 
	дээшлүүлдэг.</para>

    <para><application>Kerberos</application> серверийг ажиллуулж байхад маш цөөн тооцооллын 
	эх үүсвэрийг шаарддаг боловч аюулгүй байдлын шалтгаанаас болоод зөвхөн 
	<acronym>KDC</acronym> болон ажиллах тусдаа зориулагдсан машинтай байхыг 
	зөвлөдгийг санаарай.</para>

    <para><acronym>KDC</acronym>-г тохируулж эхлэхдээ таны 
	<filename>/etc/rc.conf</filename> файлд <acronym>KDC</acronym> 
	болж ажиллах зөв тохиргоо хийгдсэн эсэхийг шалгаарай (өөрийн системийн хувьд 
	та замуудыг өөрчлөх хэрэгтэй байж болох юм):</para>

    <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Дараа нь бид таны <application>Kerberos</application> тохиргооны 
	файл <filename>/etc/krb5.conf</filename>-г тохируулна:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Энэ <filename>/etc/krb5.conf</filename> файл нь 
	таны <acronym>KDC</acronym> нь бүрэн баталгаажсан хостын нэр 
	<hostid role="fqdn">kerberos.example.org</hostid>-тэй байна 
	гэж үзэж байгааг санаарай. Хэрэв таны <acronym>KDC</acronym> өөр 
	хостын нэртэй бол та өөрийн бүсийн файлдаа CNAME (alias)-ийг нэмэх 
	хэрэгтэй.</para>

      <note>
	<para>Зөв тохируулсан <acronym>BIND</acronym> <acronym>DNS</acronym> 
	сервер бүхий том сүлжээнүүдэд өмнөх жишээ нь:</para>

	<programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>болж дараах мөрүүдийг <hostid role="fqdn">example.org</hostid> 
	бүсийн файлд нэмж цэгцэлж болно:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</programlisting></note>

      <note>
        <para><application>Kerberos</application> үйлчилгээнүүдийг хэрэглэгчдэд 
	хүртээмжтэй болгохын тулд та эсвэл бүрэн тохируулсан <filename>/etc/krb5.conf</filename> 
	файлтай эсвэл хамгийн багаар тохируулсан <filename>/etc/krb5.conf</filename> 
	файл <emphasis>болон</emphasis> зөв тохируулсан DNS сервертэй байх 
	<emphasis>ёстой</emphasis>.</para>
      </note>

      <para>Дараа нь бид <application>Kerberos</application> мэдээллийн бааз 
	үүсгэнэ. Энэ мэдээллийн бааз нь мастер нууц үгээр шифрлэсэн бүх удирдагчдын 
	түлхүүрүүдийг  агуулдаг. Та энэ нууц үгийг тогтоох шаардлагагүй, энэ нь 
	файлд (<filename>/var/heimdal/m-key</filename>) хадгалагдах болно.
	Мастер түлхүүр үүсгэхийн тулд <command>kstash</command> тушаалыг 
	ажиллуулж нууц үгээ оруулаарай.</para>

      <para>Мастер түлхүүр үүсгэгдсэний дараа та мэдээллийн баазыг 
	<command>kadmin</command> програмыг <literal>-l</literal> 
	тохируулгатай (<quote>локал</quote> гэсэн утгатай) ашиглан эхлүүлж болно.
	Энэ тохируулга нь <command>kadmin</command>-д мэдээллийн баазын 
	файлыг <command>kadmind</command> сүлжээний үйлчилгээгээр 
	дамжилгүйгээр шууд өөрчлөхийг заадаг. Энэ нь мэдээллийн бааз үүсэхээс 
	өмнө түүн уруу хандахыг оролдох асуудлыг (яг л өндөг, тахианы аль нь түрүүлж гарсан
 	гэж маргадаг тэр асуудлын адил) зохицуулдаг. <command>kadmin</command> 
	хүлээх мөртэй болсныхоо дараа та өөрийн хүрээнүүдийн эхний мэдээллийн санг 
	<command>init</command> тушаал ашиглан үүсгээрэй.</para>

      <para>Эцэст нь <command>kadmin</command>-ы горимд байхдаа өөрийн 
	эхний удирдагчийг <command>add</command> тушаал ашиглан үүсгээрэй. 
	Одоохондоо удирдагчийн хувьд анхдагч тохируулгуудыг сонгоорой, та 
	тэдгээрийг сүүлд нь <command>modify</command> тушаал ашиглан 
	өөрчилж чадна. Та аль ч тушаал хүлээх мөрөнд <literal>?</literal> 
	тушаал ашиглаж байгаа боломжит тохируулгуудыг харж болохыг 
	санаарай.</para>

      <para>Мэдээллийн сан үүсгэлтийн жишээ сесс доор байна:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin> <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin> <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Одоо <acronym>KDC</acronym> үйлчилгээнүүдийг эхлүүлэх цаг болжээ.
	Үйлчилгээнүүдийг эхлүүлэхдээ <command>/etc/rc.d/kerberos start</command> болон 
	<command>/etc/rc.d/kadmind start</command> тушаалуудыг 
	ажиллуулна. Энэ үед танд ямар ч kerberos хийгдсэн дэмон байхгүйг санаарай, 
	гэхдээ та <acronym>KDC</acronym>-ийн өөрийнх нь тушаалын мөрөөс үүсгэсэн удирдагчид
	(хэрэглэгч) зориулсан тасалбарыг авч жагсаан <acronym>KDC</acronym>-г ажиллаж байгаа 
	гэдгийг та баталж чадаж байх ёстой:</para>

      <screen>&prompt.user; <userinput>kinit <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>klist</userinput>
Credentials cache: FILE:<filename>/tmp/krb5cc_500</filename>
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

	<para>Та дууссаныхаа дараа тасалбарыг буцааж болно:</para>

	<screen>&prompt.user; <userinput>kdestroy</userinput></screen>
      </sect2>

      <sect2>
	<title>Серверийг <application>Kerberos</application> хийн Heimdal үйлчилгээнүүдтэй  
	идэвхжүүлэх</title>

        <indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>үйлчилгээнүүдийг идэвхжүүлэх</secondary>
        </indexterm>

	<para>Эхлээд бидэнд <application>Kerberos</application>-ийн тохиргооны 
	файл <filename>/etc/krb5.conf</filename>-ийн хуулбар хэрэг болно. 
	Ингэхийн тулд <acronym>KDC</acronym>-ээс түүнийг аюулгүй аргаар 
	(&man.scp.1; зэрэг сүлжээний хэрэгслүүд эсвэл физикээр уян диск ашиглан) 
	клиент компьютер уруу ердөө л хуулах хэрэгтэй.</para>

	<para>Дараа нь танд <filename>/etc/krb5.keytab</filename> файл 
	хэрэгтэй. Энэ нь <application>Kerberos</application> хийгдсэн 
	дэмонууд бүхий сервер болон ажлын станц хоёрын гол ялгаа юм &mdash; 
	сервер нь <filename>keytab</filename> файлтай байх шаардлагатай. 
	Энэ файл нь өөрийг нь зөвшөөрдөг серверийн хост түлхүүр болон өөрсдийнхөө 
	нэрийг (identity) шалгах <acronym>KDC</acronym>-г агуулдаг. 
	Хэрэв түлхүүр нь нийтэд мэдэгдвэл серверийн аюулгүй байдал эвдэрч болох учир 
	энэ нь сервер уруу аюулгүйн үүднээс дамжуулагдах ёстой. Энэ нь шууд утгаараа 
	<acronym>FTP</acronym> зэрэг цэвэр текст сувгаар дамжуулах нь маш буруу 
	гэсэн үг юм.</para>

	<para>Ихэвчлэн сервер уруу <filename>keytab</filename> файлыг 
	<command>kadmin</command> тушаал ашиглан дамжуулдаг. 
	Энэ нь тохиромжтой байдаг бөгөөд учир нь та бас хостын удирдагчийг 
	(<filename>krb5.keytab</filename> файлын <acronym>KDC</acronym> 
	төгсгөл) <command>kadmin</command> тушаал ашиглан үүсгэх хэрэгтэй 
	болдог.</para>

	<para>Та тасалбарыг аль хэдийн авсан байх ёстой бөгөөд энэ тасалбар нь 
	<filename>kadmind.acl</filename> файлын <command>kadmin</command> 
	интерфэйсийг ашиглаж болохоор зөвшөөрөгдсөн байх ёстойг санаарай. 
	Heimdal-ийн мэдээллийн хуудаснуудын (<command>info heimdal</command>) 
	<quote>Алсын удирдлага</quote> гэсэн гарчигтай хэсгээс хандалт хянах жагсаалтуудыг 
	дизайн хийх талаар дэлгэрэнгүйг үзнэ үү. Хэрэв та алсын <command>kadmin</command> 
	хандалтыг идэвхжүүлэхийг хүсэхгүй байгаа бол та <acronym>KDC</acronym> уруу
	ердөө л аюулгүйгээр холбогдож (локал консолоор, &man.ssh.1; эсвэл 
	<application>Kerberos</application> &man.telnet.1;) удирдлагыг локалаар 
	өөр дээрээсээ <command>kadmin -l</command> тушаал ашиглан хийж болно.</para>

	<para><filename>/etc/krb5.conf</filename> файлыг суулгасны дараа та 
	<application>Kerberos</application> серверээс <command>kadmin</command> 
	тушаалыг ашиглаж болно. <command>add --random-key</command> тушаал нь 
	серверийн хост удирдагчийг нэмэх боломжийг танд олгох бөгөөд <command>ext</command> 
	тушаал нь серверийн хост удирдагчийг өөрийн keytab уруу задлах боломжийг танд олгоно.
	Жишээ нь:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin><userinput> ext host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para><command>ext</command> тушаал нь (<quote>extract</quote> гэдгийг 
	богиноор илэрхийлнэ) задалсан түлхүүрийг анхдагчаар <filename>/etc/krb5.keytab</filename> 
	файлд хадгалдаг.</para>

	<para>Хэрэв таны хувьд <acronym>KDC</acronym> дээр <command>kadmind</command> 
	ажиллахгүй байгаа бөгөөд (магадгүй аюулгүй байдлын шалтгаануудаас болоод) 
	тэгээд <command>kadmin</command> уруу алсаас хандах боломжгүй бол та 
	хост удирдагчийг (<username>host/myserver.EXAMPLE.ORG</username>) 
	шууд <acronym>KDC</acronym> дээр нэмж дараа нь доор дурдсантай адилаар түүнийг түр 
	зуурын файл уруу (<acronym>KDC</acronym> дээрх 
	<filename>/etc/krb5.keytab</filename> файлыг дарж бичихээс сэргийлж) 
	задалж болно:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para>Та дараа нь keytab-ийг аюулгүйгээр (жишээ нь <command>scp</command> эсвэл 
	уян диск ашиглан) сервер компьютер уруу  хуулж болно. <acronym>KDC</acronym> 
	дээрх keytab-ийг дарж бичихээс сэргийлж keytab нэрийг анхдагч бишээр зааж өгсөн 
	эсэхээ шалгаарай.</para>

	<para>Энэ мөчид хүрэх үед таны сервер <acronym>KDC</acronym>-тэй 
	(<filename>krb5.conf</filename> файлтай учраас) холбогдож чадах бөгөөд 
	(<filename>krb5.keytab</filename> файлтай учраас) өөрийгөө таниулан баталж 
	чадна. Одоо та зарим нэг <application>Kerberos</application> үйлчилгээнүүдийг 
	идэвхжүүлэхэд бэлэн болжээ. Энэ жишээн дээр бид <command>telnet</command> 
	үйлчилгээг <filename>/etc/inetd.conf</filename> файлд доор дурдсантай төстэй 
	мөрийг оруулан идэвхжүүлж дараа нь &man.inetd.8; үйлчилгээг 
	<command>/etc/rc.d/inetd restart</command> тушаалын тусламжтай 
	дахин ачаалах болно:</para>

	<programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

	<para>Хамгийн чухал нь <command>-a</command> төрөл (нэвтрэлт танихад) 
	хэрэглэгчид тохируулагдсан. Илүү дэлгэрэнгүйг &man.telnetd.8; гарын 
	авлагын хуудаснаас лавлана уу.</para>

      </sect2>

      <sect2>
	<title>Клиентийг <application>Kerberos</application> хийн Heimdal үйлчилгээтэйгээр идэвхжүүлэх</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>клиентүүдийг тохируулах</secondary>
	</indexterm>

	<para>Клиент компьютерийг тохируулах нь маш амархан. 
	<application>Kerberos</application> тохиргоо хийгдсэний дараа танд зөвхөн 
	<filename>/etc/krb5.conf</filename>-д байрлах 
	<application>Kerberos</application> тохиргооны файл хэрэгтэй. 
	Үүнийг ердөө л аюулгүйгээр клиент компьютер уруу <acronym>KDC</acronym>-ээс 
	хуулна.</para>

	<para>Клиентээсээ <command>kinit</command>, <command>klist</command>, болон
	  <command>kdestroy</command> тушаалуудыг үүсгэсэн удирдагчийнхаа хувьд 
	тасалбар олж авах, үзүүлэх, болон дараа нь устгахад ашиглахыг оролдон клиент 
	компьютераа тест хийгээрэй. Та <application>Kerberos</application> 
	програмуудыг ашиглан <application>Kerberos</application> хийгдсэн 
	серверүүд уруу холбогдож чадах ёстой бөгөөд хэрэв ингэж ажиллаж болохгүй байгаа 
	бөгөөд тасалбар олж авах нь асуудалтай байгаа бол энэ нь клиент эсвэл 
	<acronym>KDC</acronym>-тэй холбоотой биш сервертэй холбоотой 
	асуудал юм.</para>

	<para><command>telnet</command> зэрэг програмыг тест хийж байх үед 
	таны нууц үг цэвэр текстээр бишээр илгээгдэж байгааг шалгахын тулд пакет 
	шиншлэгч (&man.tcpdump.1; зэрэг) ашиглаад үзээрэй. 
	<command>telnet</command>-ийг бүх өгөгдлийн урсгалыг шифрлэдэг  
	(<command>ssh</command>-тэй адил) <literal>-x</literal> тохируулгатай 
	ашиглахыг оролдоорой.</para>

	<para>Төрөл бүрийн гол биш <application>Kerberos</application> клиент 
	програмууд нь бас анхдагчаар суудаг. Энэ нь үндсэн Heimdal суулгацын 
	<quote>хамгийн бага</quote> мөн чанар юм: <command>telnet</command> 
	нь цорын ганц <application>Kerberos</application> хийгдсэн үйлчилгээ 
	юм.</para>

	<para>Heimdal порт нь зарим нэг дутуу програмуудыг нэмдэг: 
	<command>ftp</command>, <command>rsh</command>,
	  <command>rcp</command>, <command>rlogin</command> болон 
	бусад цөөн хэдэн нийтлэг биш програмуудын <application>Kerberos</application> 
	хийгдсэн хувилбаруудыг нэмдэг. <acronym>MIT</acronym> порт нь бас 
	<application>Kerberos</application> клиент програмуудын бүрэн цуглуулгыг 
	агуулдаг.</para>

      </sect2>

      <sect2>
	<title>Хэрэглэгчийн тохиргооны файлууд: <filename>.k5login</filename> болон <filename>.k5users</filename></title>

	<indexterm>
	  <primary><filename>.k5login</filename></primary>
	</indexterm>

	<indexterm>
	  <primary><filename>.k5users</filename></primary>
	</indexterm>

	<para>Хүрээн дэх хэрэглэгчийн хувьд ихэнхдээ өөрсдийнх нь <application>Kerberos</application> 
	удирдагчийг (<username>tillman@EXAMPLE.ORG</username> зэрэг) 
	локал хэрэглэгчийн бүртгэлд (<username>tillman</username> зэрэг локал бүртгэл) 
	харгалзуулж өгсөн байдаг. <command>telnet</command> зэрэг клиент 
	програмууд ихэвчлэн хэрэглэгчийн нэр эсвэл удирдагчийг шаарддаггүй.</para>

	<para>Гэхдээ хааяа нэг та харгалзах <application>Kerberos</application> 
	удирдагчгүй хэн нэгэнд зориулж локал хэрэглэгчийн бүртгэлд хандах хандалтыг 
	өгөхийг хүсэж болох юм. Жишээ нь <username>tillman@EXAMPLE.ORG</username> 
	магадгүй локал хэрэглэгчийн бүртгэл <username>webdevelopers</username>-д 
	хандах хандалт хэрэгтэй байж болох юм. Бусад удирдагчид бас энэ локал бүртгэлд хандах 
	хэрэгтэй байж болох юм.</para>

	<para><filename>.k5login</filename> болон <filename>.k5users</filename> 
	файлууд нь хэрэглэгчдийн гэрийн сангуудад байрладаг бөгөөд 
	<filename>.hosts</filename> болон <filename>.rhosts</filename> 
	файлуудын хүчирхэг хослолын нэгэн адилаар энэ асуудлыг шийдэн ашиглагдаж болох юм. 
	Жишээ нь хэрэв <filename>.k5login</filename> нь дараах агуулгатайгаар:</para>

	<screen>tillman@example.org
jdoe@example.org</screen>

	<para>локал хэрэглэгч <username>webdevelopers</username>-ийн гэр санд 
	байрлаж байвал энд жагсаагдсан хоёр удирдагч хоёулаа хуваалцсан нууц үгийн шаардлагагүйгээр 
	тэр бүртгэл уруу хандах хандалттай болох юм.</para>

	<para>Эдгээр тушаалуудын гарын авлагын хуудаснуудыг уншихыг зөвлөж байна. 
	<command>ksu</command> гарын авлагын хуудас <filename>.k5users</filename> 
	файлын тухай тайлбарладгийг тэмдэглэх нь зүйтэй юм.</para>

      </sect2>

      <sect2>
	<title><application>Kerberos</application>-той холбоотой арга, зальнууд болон алдааг олж  засварлах</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>алдааг олж засварлах</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>Heimdal эсвэл <acronym>MIT</acronym>
	      <application>Kerberos</application> портууд ашиглах үед 
		таны <envar>PATH</envar> орчны хувьсагч 
		клиентийн програмуудын <application>Kerberos</application> 
		хувилбаруудыг системийн хувилбаруудаас өмнө жагсаасан байхыг 
		шаарддаг.</para>
	  </listitem>

	  <listitem>
	    <para>Таны хүрээний бүх компьютерууд цагийн тохиргоонуудаа адилаар 
		тохируулсан уу? Хэрэв үгүй бол нэвтрэлт танилт амжилтгүй болж 
		болох юм. <xref linkend="network-ntp"> нь 
		<acronym>NTP</acronym> ашиглан цагийг хамгийн сүүлийн 
		хэлбэрт аваачиж адил болгож тохируулах талаар тайлбарладаг.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym> болон Heimdal нь хоорондоо сайн 
		ажилладаг. <command>kadmin</command>-аас бусад талаараа 
		сайн ажилладаг, учир нь энэ програмын протокол стандартчилагдаагүй.</para>
	  </listitem>

	  <listitem>
	    <para>Та хэрэв өөрийн хостын нэрийг өөрчилбөл бас өөрийн <username>host/</username> 
		удирдагчийг өөрчилж өөрийн keytab-ийг шинэчлэх хэрэгтэй. Энэ нь бас 
		Апачигийн <filename role="package">www/mod_auth_kerb</filename>-д 
		хэрэглэгддэг <username>www/</username> удирдагч зэрэг тусгай keytab 
		оруулгуудад хамаатай юм.</para>
	  </listitem>

	  <listitem>
	    <para>Таны хүрээний бүх хостууд <acronym>DNS</acronym>-д (эсвэл
	     	хамгийн багадаа <filename>/etc/hosts</filename>-ийн хувьд) танигдаж 
		(урагш болон эсрэгээр танигдаж) байх ёстой. CNAME-үүд ажиллах боловч A болон PTR 
		бичлэгүүд зөв бөгөөд байрандаа байж байх ёстой. Алдааны мэдэгдэл нь 
		тийм ч ойлгогдохоор байдаггүй, жишээ нь: <errorname>Kerberos5
		refuses authentication because Read req
	      failed: Key table entry not found буюу орчуулбал 
		Унших Req амжилтгүй болсон болохоор Kerberos5 нь нэвтрэлт танилтаас 
		татгалзаж байна</errorname>.</para>
	  </listitem>

	  <listitem>
	    <para>Таны <acronym>KDC</acronym>-ийн хувьд магадгүй клиент маягаар 
		харьцаж байгаа зарим үйлдлийн системүүд setuid
	      <username>root</username> болохын тулд <command>ksu</command>
		тушаалд зөвшөөрлүүдийг тохируулдаггүй. Энэ нь <command>ksu</command> 
		ажиллахгүй гэсэн үг бөгөөд аюулгүй байдлын хувьд сайн боловч залхаамаар 
		байдаг. Энэ  нь <acronym>KDC</acronym>-ийн алдаа биш юм.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym>
	      <application>Kerberos</application>-той байхад хэрэв та 
		анхдагч 10 цагаас арай урт амьдрах хугацаа бүхий тасалбартай удирдагчийг 
		зөвшөөрөхийг хүсвэл <command>kadmin</command> дээр 
		<command>modify_principal</command> тушаал ашиглан 
		өөрчлөхийг хүссэн удирдагч болон <username>krbtgt</username> 
		удирдагчийн maxlife-ийг өөрчлөх шаардлагатай. Дараа нь 
		удирдагч <literal>-l</literal> тохируулгыг 
		<command>kinit</command>-тай ашиглаж илүү урт амьдрах хугацаатай 
		тасалбарыг авах хүсэлт илгээж болох юм.</para>
	  </listitem>

	  <listitem>
	    <note><para>Хэрэв та өөрийн <acronym>KDC</acronym> дээр 
		алдааг олж засварлахын тулд пакет шиншлэгч ажиллуулж дараа нь 
		ажлын станцаасаа <command>kinit</command>-ийг ажиллуулахад  
		<command>kinit</command>-ийг ажилласан даруй 
		таны <acronym>TGT</acronym> илгээгдэхийг 
		&mdash; таныг бүр нууц үгээ бичихээс өмнө та харах болно! 
		Үүний тайлбар нь <application>Kerberos</application> 
		сервер чөлөөтэйгээр <acronym>TGT</acronym>-ийг (Ticket Granting
	      Ticket буюу Тасалбар Баталгаажуулах Тасалбар) ямар ч танигдаагүй 
		хүсэлтэд дамжуулдаг; гэхдээ <acronym>TGT</acronym> бүр 
		хэрэглэгчийн нууц үгээс гарсан түлхүүр болон шифрлэгдсэн байдаг.
		Тийм болохоор хэрэглэгч өөрсдийн нууц үгийг бичихэд 
		тэр нь <acronym>KDC</acronym> уруу илгээгддэггүй бөгөөд 
		харин <command>kinit</command>-ийн аль хэдийн олж авсан 
		<acronym>TGT</acronym>-г буцааж шифрлэхэд (decrypt) 
		ашиглагддаг. Хэрэв буцааж шифрлэх процесс хүчинтэй хугацаа бүхий  
		хүчинтэй тасалбарыг гаргаж авбал хэрэглэгч хүчинтэй 
		<application>Kerberos</application> итгэмжлэлүүдтэй 
		байна. Эдгээр итгэмжлэлүүд нь ирээдүйд 
		<application>Kerberos</application> сервертэй аюулгүй холболтууд 
		хийхэд зориулагдсан сессийн түлхүүр болон бас <application>Kerberos</application>
		серверийн өөрийнх нь түлхүүрээр шифрлэгдсэн тасалбар-баталгаажуулах 
		тасалбарыг агуулдаг. Шифрлэлтийн хоёр дахь давхарга нь хэрэглэгчид 
		мэдэгддэггүй, гэхдээ энэ нь <acronym>TGT</acronym> бүрийн 
		жинхэнийг шалгахыг <application>Kerberos</application> 
		серверт зөвшөөрч байгаа тэр зүйл юм.</para></note>
	  </listitem>

	  <listitem>
	    <para>Хэрэв та урт амьдрах хугацаатай (жишээ нь долоо хоног) тасалбар ашиглахыг 
		хүсэж байгаа бөгөөд та тасалбар хадгалагдаж байгаа машин уруу 
		<application>OpenSSH</application> ашиглан холбогдож байгаа бол 
		<application>Kerberos</application>
	      <option>TicketCleanup</option> тохируулга <literal>no</literal> 
		гэж <filename>sshd_config</filename> тохиргооны файлд байгаа эсэхийг 
		шалгаарай, тэгэхгүй бол таны тасалбарууд таныг гарах үед устгагдах 
		болно.</para>
	  </listitem>

	  <listitem>
	    <para>Хостын удирдагчид илүү урт амьдрах хугацаатай тасалбартай бас байж болно 
		гэдгийг санаарай. Хэрэв таны хэрэглэгчийн удирдагч долоо хоног амьдрах хугацаатай 
		бөгөөд гэхдээ таны холбогдож байгаа хост 9 цаг амьдрах хугацаатай бол 
		та кэшдээ хугацаа нь дууссан хостын удирдагчтай болж тасалбарын кэш 
		хүссэнээр ажиллахгүй болох болно.</para>
	  </listitem>

	  <listitem>
	    <para>Тусгайлсан муу нууц үгүүдийг ашиглуулахгүйн тулд (<command>kadmind</command> 
		тушаалын гарын авлагын хуудас үүнийг товчхон тайлбарладаг) 
		<filename>krb5.dict</filename> файлыг тохируулахдаа 
		нууц үгийн бодлого тавигдсан удирдагчдад энэ нь зөвхөн хамаатайг санах 
		хэрэгтэй. <filename>krb5.dict</filename> файлуудын хэлбэр 
		хялбар байдаг: нэг мөрт нэг үг (string) байна. <filename>/usr/share/dict/words</filename> 
		симболын холбоос үүсгэх нь ашигтай байж болох юм.</para>
	  </listitem>
        </itemizedlist>

      </sect2>

      <sect2>
	<title><acronym>MIT</acronym> портоос ялгаатай талууд</title>

	<para><acronym>MIT</acronym> болон Heimdal суулгацуудын гол ялгаа нь 
	өөр (гэхдээ орлуулж болох) тушаалууд болон өөр протоколууд ашигладаг 
	<command>kadmin</command> програмтай холбоотой юм. 
	Хэрэв таны <acronym>KDC</acronym> нь <acronym>MIT</acronym> бол 
	та Heimdal <command>kadmin</command> програмыг ашиглаж өөрийн 
	<acronym>KDC</acronym>-г алсаас (эсвэл эсрэг чиглэлд энэ 
	зорилгоор) удирдаж чадахгүй  болдог учир энэ нь их хамаатай юм.</para>

	<para>Клиент програмууд нь бас шал өөр өөр тушаалын мөрийн тохируулгууд авч 
	адил үүргийг гүйцэтгэж болох юм. <acronym>MIT</acronym>
	  <application>Kerberos</application> вэб сайт 
	(<ulink url="http://web.mit.edu/Kerberos/www/"></ulink>) дээрх заавруудыг 
	дагахыг зөвлөж байна. Замын асуудлуудаас болгоомжлоорой: 
	<acronym>MIT</acronym> порт нь анхдагчаар <filename class="directory">/usr/local/</filename> 
	уруу суудаг бөгөөд хэрэв таны <envar>PATH</envar> орчны хувьсагч системийн 
	сангуудыг эхлээд жагсаадаг бол <quote>жирийн</quote> системийн програмууд 
	<acronym>MIT</acronym>-ийн оронд ажиллаж болохыг санаарай.</para>

	<note><para><command>telnetd</command> болон <command>klogind</command>-ээр 
	нэвтрэх нэвтрэлтүүд нэг л хачин байдаг тэр шалтгааныг ойлгохыг хүсвэл &os;-ийн хангадаг 
	<acronym>MIT</acronym> <filename role="package">security/krb5</filename> портын 
	суулгасан <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename> 
	файлыг унших хэрэгтэй. Хамгийн чухал нь 
	<quote>кэш файл дахь буруу зөвшөөрлүүд</quote>ийг зөв болгох нь 
	дамжуулагдсан итгэмжлүүдийн эзэмшилтийг зөвөөр солих <command>login.krb5</command> 
	хоёртын файлыг нэвтрэлт танилтад ашиглахыг шаарддаг.</para></note>

	<para><filename>rc.conf</filename> файл дараах тохиргоог агуулж засварлагдсан 
		байх бас шаардлагатай:</para>

	<programlisting>kerberos5_server="/usr/local/sbin/krb5kdc"
kadmind5_server="/usr/local/sbin/kadmind"
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

	<para><acronym>MIT</acronym> керберосд зориулсан програмууд 
	<filename class="directory">/usr/local</filename> санд хоёртын файлуудыг 
	суулгадаг болохоор ингэж хийгддэг.</para>
      </sect2>

      <sect2>
	<title><application>Kerberos</application> дахь хязгааруудыг багасгах</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>хязгаарууд болон дутагдлууд</secondary>
	</indexterm>

	<sect3>
	 <title><application>Kerberos</application> нь бүгдийг эсвэл юуг ч биш гэсэн арга юм</title>

	  <para>Сүлжээнд идэвхжүүлэгдсэн үйлчилгээ бүр <application>Kerberos</application>-тэй 
		ажиллахаар засварлагдсан (эсвэл сүлжээний халдлагуудын эсрэг аюулгүй 
		байдлыг хангасан) байх шаардлагатай, тэгэхгүй бол хэрэглэгчдийн 
		итгэмжлэлүүд хулгайлагдаж дахин ашиглагдаж болох юм. Үүний нэг жишээ нь 
		бүх алсын бүрхүүлүүдийг (жишээ нь <command>rsh</command> болон 
		<command>telnet</command>) <application>Kerberos</application> хийн 
		идэвхжүүлсэн мөртлөө нууц үгүүдийг цэвэр текстээр илгээдэг <acronym>POP3</acronym> 
		захидлын серверийг тэгж хувиргахгүй байх явдал юм.</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application> нь ганц хэрэглэгчийн ажлын станцуудад зориулагдсан</title>

	  <para>Олон хэрэглэгчийн орчинд <application>Kerberos</application> нь 
		тийм ч аюулгүй биш юм. Энэ нь тасалбаруудыг бүх хэрэглэгчийн хувьд уншигдаж 
		болох <filename class="directory">/tmp</filename> санд хадгалдаг учраас тэр юм. 
		Хэрэв хэрэглэгч компьютераа хэд хэдэн бусад хүмүүстэй зэрэг харилцан хуваалцаж 
		байвал (өөрөө хэлбэл олон-хэрэглэгч) хэрэглэгчийн тасалбаруудыг өөр хэрэглэгч 
		хулгайлах (хуулан авах) боломжтой юм.</para>

	  <para>Үүнийг <literal>-c</literal> файлын нэрийн тушаалын мөрийн тохируулгатай 
		эсвэл (илүү зохимжтой) <envar>KRB5CCNAME</envar> орчны хувьсагчтайгаар 
		даван гарч болох юм, гэхдээ ингэх нь их ховор байдаг. Зарчмын хувьд 
		тасалбарыг хэрэглэгчдийн гэр санд хадгалж хялбар файлын зөвшөөрлүүдийг ашиглах нь 
		энэ асуудлыг багасгадаг.</para>

	</sect3>

	<sect3>
	  <title>KDC нь бүтэлгүйтлийн ганц цэг</title>

	  <para>Дизайнаараа бол <acronym>KDC</acronym> нь мастер нууц үгийн 
		мэдээллийн баазаас тогтох бөгөөд түүний нэгэн адил аюулгүй байх ёстой.
		<acronym>KDC</acronym> нь үүн дээр өөр ямар ч үйлчилгээнүүд 
		ажиллуулсан байх ёсгүй бөгөөд физикээр аюулгүй байдлыг нь 
		хангасан байх шаардлагатай. <application>Kerberos</application> 
		нь ижил түлхүүрээр (<quote>мастер</quote> түлхүүр) шифрлэгдсэн бүх 
		нууц үгүүдийг хадгалдаг бөгөөд тэр ижил түлхүүр нь эргээд 
		<acronym>KDC</acronym> дээр файл маягаар хадгалагддаг учраас 
		аюул өндөртэй байдаг.</para>

	  <para>Тэмдэглэн хэлэхэд булаан эзлэгдсэн мастер түлхүүр нь хэн нэг нь айхаар 
		тийм ч муу биш юм. Түлхүүр үг нь зөвхөн <application>Kerberos</application> 
		мэдээллийн баазыг шифрлэхэд болон санамсаргүй тоо үүсгэгчийн үр болон 
		хэрэглэгддэг. Таны <acronym>KDC</acronym> уруу хандахад аюулгүй л 
		байж байвал халдагч мастер түлхүүрээр их юм хийж чадахгүй.</para>

	  <para>Мөн нэмж хэлэхэд хэрэв <acronym>KDC</acronym> нь боломжгүй байвал 
		(магадгүй үйлчилгээ зогсоох халдлага эсвэл сүлжээний асуудлуудаас болоод)
		сүлжээний үйлчилгээнүүд нь нэвтрэлт танилтыг хийж болохгүй болохоор 
		хэрэглэгдэх боломжгүй болох бөгөөд нэг ёсны үйлчилгээ зогсоох халдлагын рецепт 
		болох юм. Үүнийг олон <acronym>KDC</acronym>-тэй (нэг мастер болон 
		нэг буюу хэд хэдэн боолууд) болон хоёрдогч эсвэл нэмэлт, эцсийн нэвтрэлт таних  
		(<acronym>PAM</acronym> нь энэнд маш сайн) болгоомжтой шийдлийн 
		тусламжтайгаар даван гарч болох юм.</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application>-ийн дутагдлууд</title>

	  <para><application>Kerberos</application> нь хэрэглэгчид, хостууд болон 
		үйлчилгээнүүдэд өөр хоорондоо бие биенээ таниулах боломжийг олгодог. Гэхдээ энэ нь 
		<acronym>KDC</acronym>-г хэрэглэгчид, хостууд эсвэл үйлчилгээнүүдэд 
		таниулах аргагүй юм. Энэ нь троян хийгдсэн <command>kinit</command> (жишээ нь) 
		тушаал бүх хэрэглэгчийн нэрс болон нууц үгүүдийг бүртгэн бичиж авч болно гэсэн 
		үг юм. <filename role="package">security/tripwire</filename> 
		ч юм уу эсвэл өөр бусад файлын системийн бүрэн бүтэн байдлыг шалгах хэрэгслүүд
		үүнийг арилгаж чадна.</para>

	</sect3>
      </sect2>

      <sect2>
	<title>Эх сурвалжууд болон нэмэлт мэдээллүүд</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>гадаад эх сурвалжууд</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	  <para><ulink
	    url="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	    <application>Kerberos</application>-ийн FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/dialogue.html">
		Танин шалгах системийг дизайн хийх нь: Дөрвөн үзэгдэл дэх харилцан яриа (диалог)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    <application>Kerberos</application> Сүлжээний Танин Шалгах Үйлчилгээ
	    (V5)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	    <application>Kerberos</application>-ийн гэр хуудас</ulink></para>
	</listitem>

	<listitem>
	<para><ulink url="http://www.pdc.kth.se/heimdal/">Heimdal
	  <application>Kerberos</application>-ийн гэр хуудас</ulink></para>
	</listitem>

	</itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Бичсэн </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>OpenSSL</title>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>

    <para>Олон хэрэглэгчдийн хайдаг нэг боломж нь &os;-д байдаг 
	<application>OpenSSL</application> багаж юм. 
	<application>OpenSSL</application> нь ердийн холбооны давхарга 
	дээр шифрлэлт дамжуулах давхаргыг хангаж өгдөг; ингэснээр түүнийг сүлжээний 
	програмууд болон үйлчилгээнүүдтэй холбож өгөх боломжийг олгодог.</para>

    <para><application>OpenSSL</application>-ийн зарим нэг хэрэглээнд  
	захидлын клиентүүдийн шифрлэсэн нэвтрэлт, кредит картаар хийх төлбөрүүд гэх мэт 
	вэб дээр тулгуурласан шилжүүлгүүд зэрэг олныг дурдаж болно. 
	<filename role="package">www/apache13-ssl</filename> болон 
	<filename role="package">mail/claws-mail</filename> зэрэг 
	олон портууд нь <application>OpenSSL</application>-тэй бүтээх 
	эмхэтгэлийн дэмжлэгийг санал болгодог.</para>

    <note>
      <para>Ихэнх тохиолдолд Портуудын Цуглуулга нь make хувьсагч 
	<makevar>WITH_OPENSSL_BASE</makevar>-ийг <quote>yes</quote> 
	гэж заагаагүй тохиолдолд  
	<filename role="package">security/openssl</filename> портыг 
	бүтээхийг оролддог.</para>
    </note>

    <para>&os;-д орсон <application>OpenSSL</application>-ийн хувилбар нь 
	Secure Sockets Layer v2/v3 (SSLv2/SSLv3) буюу Аюулгүй Сокетуудын 
	Давхаргын v2/v3 хувилбарууд, Transport Layer Security v1 (TLSv1) буюу 
	Тээврийн Давхаргын Аюулгүй байдлын v1 хувилбарын сүлжээний аюулгүй байдлын 
	протоколуудыг дэмждэг бөгөөд ерөнхий криптограф сан болон ашиглагдаж 
	болох юм.</para>

    <note>
      <para><application>OpenSSL</application> нь 
	<acronym>IDEA</acronym> алгоритмийг дэмждэг боловч Нэгдсэн Улсын 
	патентуудаас болоод анхдагчаар хаалттай байдаг. Үүнийг ашиглахын тулд 
	лицензийг шалгасан байх ёстой бөгөөд хэрэв хязгаарлалтуудыг хүлээн 
	авах боломжтой бол <makevar>MAKE_IDEA</makevar> хувьсагчийг 
	<filename>make.conf</filename> файлд заагж өгөх ёстой байдаг.</para>
    </note>

    <para><application>OpenSSL</application>-ийн хамгийн түгээмэл хэрэглээний 
	нэг бол програм хангамжуудад зориулан ашиглах сертификатуудыг бэлдэх явдал 
	юм. Эдгээр сертификатууд нь компани болон хувь хүмүүсийн итгэмжлэлүүдийг  
	хүчинтэй бөгөөд луйврын биш гэдгийг баталгаажуулдаг. Хэрэв асуудалтай сертификат 
	хэд хэдэн <quote>Certificate Authorities</quote> эсвэл <acronym>CA</acronym>-ууд буюу 
	Сертификатын Эрх мэдэлтнүүдээр шалгагдаагүй бол ихэвчлэн анхааруулга үзүүлдэг. 
	Сертификатын Эрх мэдэлтэн нь <ulink url="http://www.verisign.com">VeriSign</ulink> зэрэг 
	компани байдаг бөгөөд компаниуд эсвэл хувь хүмүүсийн итгэмжлэлүүдийг хүчин төгөлдөр болгохын 
	тулд сертификатуудыг баталгаажуулж өгдөг. Энэ процесс нь өртөгтэй бөгөөд 
	сертификатууд ашиглахад заавал ч үгүй шаардлага болдоггүй; гэхдээ энэ нь 
	паранойд буюу хэт зовнисон хэрэглэгчдийн заримын санааг тайвшруулж болох юм.</para>

    <sect2>
      <title>Сертификатуудыг үүсгэх нь</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>сертификат үүсгэлт</secondary>
      </indexterm>

      <para>Сертификат үүсгэхийн тулд дараах тушаал байдаг:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput><replaceable>SOME PASSWORD</replaceable></userinput>
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para><quote>Common Name</quote> хүлээх мөрийн дараах хариу домэйны 
	нэрийг харуулж байгааг анзаараарай. Энэ мөр нь шалгалт хийх зорилгоор 
	серверийн нэрийг оруулахыг шаарддаг; домэйн нэрээс бусдыг байрлуулах нь 
	ашиггүй сертификат үүсэхэд хүргэдэг. Бусал тохируулгууд, жишээ нь 
	дуусах хугацаа, өөр шифрлэх алгоритмууд гэх мэт тохируулгууд байдаг.
	Бүрэн гүйцэд жагсаалтыг &man.openssl.1; гарын авлагын хуудсыг үзэн 
	авч болно.</para>

      <para>Дээрх тушаалын ажилласан санд хоёр файл одоо байж байх ёстой. 
	Сертификатын хүсэлт <filename>req.pem</filename> нь таны оруулсан итгэмжлэлүүдийг 
	хүчин төгөлдөр болгож хүсэлтийг баталгаажуулан сертификатыг танд буцаах сертификатын 
	эрх мэдэлтэн уруу илгээгдэж болно. Үүсгэгдсэн хоёр дахь файл нь 
	<filename>cert.pem</filename> гэж нэрлэгдэн сертификатын хувийн түлхүүр 
	болох бөгөөд ямар ч байсан гэсэн хамгаалагдсан байх ёстой; хэрэв энэ нь 
	бусдын гарт орох юм бол таны (эсвэл таны серверийн) дүрд тоглон ашиглагдаж болох 
	юм.</para>

      <para><acronym>CA</acronym>-с гарын үсэг шаарддаггүй тохиолдолд 
	өөрөө зурсан сертификатыг үүсгэж болно. Эхлээд <acronym>RSA</acronym> 
	түрхүүр үүсгэх хэрэгтэй:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out <filename>myRSA.key</filename> 1024</userinput></screen>
	
	<para>Дараа нь <acronym>CA</acronym> түлхүүр үүсгэ:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out <filename>myca.key</filename> <filename>myRSA.key</filename></userinput></screen>

      <para>Сертификат үүсгэхийн тулд энэ түлхүүрийг ашигла :</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key <filename>myca.key</filename> -out <filename>new.crt</filename></userinput></screen>

      <para>Санд хоёр шинэ файл үүсэх ёстой: сертификатын эрх мэдэлтний гарын 
	үсгийн файл <filename>myca.key</filename> болон сертификат өөрөө 
	<filename>new.crt</filename> байна. Эдгээрийг 
	зөвхөн <username>root</username> унших эрхтэй 
	<filename class="directory">/etc</filename> санд байрлуулах 
	шаардлагатай. Үүнд 0700 зөвшөөрөл байж болох бөгөөд түүнийг 
	<command>chmod</command> хэрэгсэл ашиглан тохируулж болно.</para>
    </sect2>

    <sect2>
      <title>Сертификатуудыг ашиглах нь, жишээ</title>

      <para>Тэгэхээр эдгээр файлууд нь юу хийж чадах вэ? Сайн хэрэглээ болох нэг 
	жишээ нь <application>Sendmail</application>
	<acronym>MTA</acronym> уруу хийгдэх холболтуудыг шифрлэх байж болно. 
	Энэ нь локал <acronym>MTA</acronym> ашиглан захидал илгээх 
	хэрэглэгчдийн цэвэр текст нэвтрэлтийн хэрэглээг болиулах юм.</para>

      <note>
	<para>Зарим <acronym>MUA</acronym>-ууд нь хэрэв хэрэглэгчид дотроо 
	сертификат суулгаагүй бол тэдэнд алдааг харуулдаг болохоор энэ нь 
	ертөнц дээрх хамгийн шилдэг хэрэглээ биш юм. 
	Сертификат суулгах тухай илүү мэдээллийг програм хангамжтай цуг ирсэн 
	баримтаас  үзэх хэрэгтэй.</para>
      </note>

      <para>Дотоод <filename>.mc</filename> файл дотор дараах мөрүүдийг 
	байрлуулах хэрэгтэй:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Дээрх <filename class="directory">/etc/certs/</filename> нь 
	сертификат болон түлхүүр файлуудыг дотооддоо хадгалах сан юм. 
	Сүүлийн хэдэн шаардлагууд нь дотоод <filename>.cf</filename> файлын 
	дахин бүтээлт юм. Үүнийг <filename class="directory">/etc/mail</filename> сан 
	дотроос <command>make <maketarget>install</maketarget></command> тушаал 
	бичин хийж болно. Ингэсний дараа <command>make 
	<maketarget>restart</maketarget></command> тушаалыг ажиллуулаарай, энэ нь 
	<application>Sendmail</application> дэмонг эхлүүлэх ёстой.</para>

      <para>Хэрэв бүгд зүгээр болж өнгөрвөл <filename>/var/log/maillog</filename> 
	файлд ямар ч алдаа бичигдэхгүй бөгөөд <application>Sendmail</application> 
	процессийн жагсаалтад харуулагдана.</para>

      <para>Хялбар тест хийхийн тулд &man.telnet.1; хэрэгсэл ашиглан 
	захидлын серверт холбогдох хэрэгтэй:</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to <hostid role="fqdn">example.com</hostid>.
Escape character is '^]'.
220 <hostid role="fqdn">example.com</hostid> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <hostid role="fqdn">example.com</hostid> closing connection
Connection closed by foreign host.</screen>

      <para>Хэрэв <quote>STARTTLS</quote> мөр гарч ирвэл бүгд зөв ажиллаж 
	байна.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
        <author>
  	  <firstname>Ник</firstname>
	  <surname>Клэйтон</surname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
          </affiliation>
          <contrib>Бичсэн </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>IPsec</primary>
    </indexterm>

    <title>IPsec дээгүүр VPN хийх</title>
    <para>FreeBSD гарц машинуудыг ашиглан Интернэтээр тусгаарлагдсан хоёр сүлжээний 
	хооронд VPN үүсгэх.</para>
 
    <sect2>
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Хитэн М.</firstname>
            <surname>Пандиа</surname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Бичсэн </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>IPsec-ийг ойлгох нь</title>

      <para>Энэ хэсэг нь IPsec-ийг тохируулах процессийг тайлбарлах 
	болно. IPsec-ийг тохируулахын тулд та өөрчлөн тохируулсан 
	цөм бүтээх ухагдахууныг мэдсэн байх шаардлагатай
	(<xref linkend="kernelconfig">-г үзнэ үү).</para>
    
      <para><emphasis>IPsec</emphasis> нь Интернэт Протокол (IP) давхаргын 
	дээр суудаг протокол юм. Энэ нь хоёр буюу хэд хэдэн хостуудыг аюулгүй байдлаар 
	(нэрээс нь харах юм бол) холбох боломжийг олгодог. FreeBSD IPsec 
	<quote>сүлжээний стек</quote> нь IPv4 болон IPv6 протоколуудыг хоёуланг 
	дэмждэг <ulink url="http://www.kame.net/">KAME</ulink> шийдэл дээр 
	үндэслэсэн.</para>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>ESP</secondary>
      </indexterm>
  
      <indexterm>
	<primary>IPsec</primary>
	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec нь хоёр дэд протоколоос тогтоно:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Encapsulated Security Payload
	      (ESP) буюу Хайрцаглагдсан Аюулгүй байдлын ачаа</emphasis> нь 
		гуравдагчийн нөлөөллөөс тэгш хэмт криптограф алгоритмийг 
		(Blowfish, 3DES-тэй адил) ашиглан агуулгыг нь шифрлэж 
		IP пакетийн өгөгдлийг хамгаалдаг.</para>
        </listitem>
        <listitem>
          <para><emphasis>Authentication Header (AH) буюу Нэвтрэлт Танилтын 
		Толгой</emphasis> нь аюулгүй хэш хийх функцаар IP пакетийн толгойн 
		талбаруудыг хэш хийн криптограф хянах нийлбэрийг тооцоолон гуравдагч 
		этгээдийн нөлөөлөл болон хууран мэхлэлтээс IP пакетийн толгойг 
		хамгаалдаг. Үүний дараа пакет дахь мэдээллийг таниулахыг зөвшөөрөх 
		хэшийг агуулсан нэмэлт толгой байдаг.</para>
        </listitem>
      </itemizedlist>
      
      <para><acronym>ESP</acronym> болон <acronym>AH</acronym> нь 
	орчноосоо хамаараад хоёулаа цуг эсвэл тусдаа ашиглагдаж болно.</para>
      
      <indexterm>
	<primary>VPN</primary>
      </indexterm>

      <indexterm>
	<primary>виртуал хувийн сүлжээ</primary>
	<see>VPN</see>
      </indexterm>

      <para>IPsec нь хоёр хостын хоорондох урсгалыг шууд шифрлэх (<emphasis>Transport
	  Mode буюу Тээвэрлэх Горим</emphasis> гэгддэг) буюу эсвэл 
	хоёр корпорацийн сүлжээний хооронд аюулгүй холбоонд ашиглагдаж болох 
	<quote>виртуал туннелиуд</quote> (<emphasis>Tunnel Mode буюу Туннелийн 
	Горим</emphasis> гэгддэг) бүтээхэд хэрэглэгдэж болох юм. Сүүлийнх нь ерөнхийдөө 
	<emphasis>Виртуал Хувийн Сүлжээ (VPN)</emphasis> гэгддэг. 
	FreeBSD-ийн IPsec дэд системийн талаар дэлгэрэнгүй мэдээллийг 
	&man.ipsec.4; гарын авлагын хуудаснаас лавлах хэрэгтэй.</para>
      
      <para>Өөрийн цөмдөө IPsec дэмжлэгийг нэмэхийн тулд та дараах тохируулгуудыг 
	цөмийн тохиргоондоо нэмээрэй:</para>

      <indexterm>
	<primary>цөмийн тохируулгууд</primary>
	<secondary>IPSEC</secondary>
      </indexterm>

      <screen>
options   IPSEC        #IP security
device    crypto
      </screen>

      <indexterm>
	<primary>цөмийн тохируулгууд</primary>
	<secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>Хэрэв IPsec дибаг хийх дэмжлэг заавал хэрэгтэй бол дараах цөмийн тохируулга 
	бас нэмэгдсэн байх шаардлагатай:</para>

      <screen>
options   IPSEC_DEBUG  #debug for IP security
      </screen>
    </sect2>

    <sect2>
      <title>Асуудал</title>
 
      <para>VPN-ийг байгуулахад ямар нэг стандарт байхгүй. VPN-үүд нь өөр өөрийн давуу болон сул 
	талуудтай төрөл бүрийн технологиудыг ашиглан хийгдэж болно. Энэ хэсэг нь 
	нэг тохиолдлын загвар үзүүлэх бөгөөд энэ тохиолдол дахь VPN-ийг хийхэд 
	хэрэглэгдэх стратегиудыг харуулах болно.</para>
    </sect2>
    
    <sect2> 
      <title>Тохиолдол: Хоёр сүлжээ, нэг нь гэрийн нэг нь ажлын. Хоёулаа 
	Интернэтэд холбогдсон бөгөөд энэ <acronym>VPN</acronym>-ээр нэг юм шиг 
	ажиллах сүлжээ.</title>
      
      <indexterm>
	<primary>VPN</primary>
	<secondary>үүсгэх</secondary>
      </indexterm>

      <para>Угтвар нөхцөл дараах маягийн байна:</para>
      
      <itemizedlist>
        <listitem>
          <para>Та хамгийн багадаа хоёр сайттай байна</para>
        </listitem>
        <listitem>
          <para>Хоёр сайт хоёулаа IP-г дотооддоо ашигладаг</para>
        </listitem>
        <listitem>
          <para>FreeBSD дээр нь ажилладаг гарц компьютераар хоёр сайт хоёулаа 
		Интернэтэд холбогдсон.</para>
        </listitem>
        <listitem>
          <para>Хоёр сүлжээний гарц компьютер бүр хамгийн багаар бодоход нэг нийтийн IP 
		хаягтай.</para>
        </listitem>
        <listitem>
          <para>Хоёр сүлжээний дотоод хаягууд нь нийтийн эсвэл хувийн IP хаягууд байж 
	    болох юм, энэ нь хамаагүй. Тэдгээр нь давхцахгүй байх ёстой, өөрөөр 
	    хэлбэл хоёулаа <hostid role="ipaddr">192.168.1.x</hostid>-г ашиглаж 
	    болохгүй юм.</para>
        </listitem>
      </itemizedlist>
    </sect2>
      
    <sect2>
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Том</firstname>
            <surname>Рөүдс</surname>
	    <affiliation>
	      <address><email>trhodes@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Бичсэн </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>IPsec-ийг &os; дээр тохируулах нь</title>

      <para>Эхлээд <filename role="package">security/ipsec-tools</filename> 
	портын цуглуулгаас суусан байх шаардлагатай. Энэ гуравдагч талын програм 
	хангамжийн багц нь тохиргоог дэмжихэд туслах хэд хэдэн програмуудыг 
	агуулдаг.</para>

      <para>Дараагийн шаардлага нь пакетуудыг тунель хийх болон хоёр 
	сүлжээг зөв холбогдоход ашиглагдах хоёр &man.gif.4; псевдо 
	төхөөрөмжийг үүсгэх явдал юм. <username>root</username> хэрэглэгчээр 
	<replaceable>internal</replaceable> болон 
	<replaceable>external</replaceable> гэсэн утгуудыг жинхэнэ 
	дотоод болон гадаад гарцуудаар өөрчлөн дараах тушаалыг 
	ажиллуулна:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput></screen>
      <screen>&prompt.root; <userinput>ifconfig gif0 <replaceable>internal1 internal2</replaceable></userinput></screen>
      <screen>&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>external1 external2</replaceable></userinput></screen>

      <para>Жишээ нь ажлын <acronym>LAN</acronym>-ий нийтийн 
	<acronym>IP</acronym> нь 
	<hostid role="ipaddr">172.16.5.4</hostid> бөгөөд 
	хувийн <acronym>IP</acronym> нь 
	<hostid role="ipaddr">10.246.38.1</hostid> байна.
	Гэрийн <acronym>LAN</acronym>-ий нийтийн <acronym>IP</acronym> нь 
	<hostid role="ipaddr">192.168.1.12</hostid> бөгөөд 
	дотоод хувийн <acronym>IP</acronym> нь 
	<hostid role="ipaddr">10.0.0.5</hostid> байна.</para>

      <para>Энэ нь толгой эргэмээр санагдаж болох бөгөөд 
	&man.ifconfig.8; тушаалын дараах жишээ үр дүнгээс харна уу:</para>

      <programlisting>Gateway 1:

gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00

Gateway 2:

gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</programlisting>

      <para>Хийгдэж дууссаны дараа хоёр хувийн <acronym>IP</acronym>-д 
	&man.ping.8; тушаал ашиглан дараах үр дүнд харуулсан шиг 
	хүрэх боломжтой байх ёстой:</para>

      <programlisting>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</programlisting>

      <para>Хүсэн хүлээж байсны дагуу хоёр тал хоёулаа 
	хувийн тохируулсан хаягаасаа <acronym>ICMP</acronym>
	пакетуудыг илгээх болон хүлээн авах боломжтой байна. Дараа нь 
	аль аль сүлжээнээс урсгалыг зөв илгээдэг байхын тулд хоёр гарцад 
	хоёуланд нь пакетуудыг хэрхэн яаж чиглүүлэхийг зааж өгөх ёстой. 
	Энэ зорилгод дараах тушаал хүрнэ:</para>

      <screen>&prompt.root; <userinput>corp-net# route add <replaceable>10.0.0.0 10.0.0.5 255.255.255.0</replaceable></userinput></screen>
      <screen>&prompt.root; <userinput>corp-net# route add net <replaceable>10.0.0.0: gateway 10.0.0.5</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>priv-net# route add <replaceable>10.246.38.0 10.246.38.1 255.255.255.0</replaceable></userinput></screen>
      <screen>&prompt.root; <userinput>priv-net# route add host <replaceable>10.246.38.0: gateway 10.246.38.1</replaceable></userinput></screen>

      <para>Энэ үе хүрэхэд дотоод машинууд нь аль аль гарц болон гарцын цаана 
	байгаа машинуудаас хүрэх боломжтой байх ёстой. Үүнийг хялбараар 
	дараах жишээнээс тодорхойлж болно:</para>

      <programlisting>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</programlisting>

      <para>Тунелиуд үүсгэж тохируулах нь хялбар хэсэг юм. Аюулгүй 
	холбоосыг тохируулах нь илүү гүнзгий процесс юм. Дараах 
	тохиргоо нь урьдчилан хуваалцсан (<acronym>PSK</acronym>)
	<acronym>RSA</acronym> түлхүүрүүдийг ашиглаж байна.
	<acronym>IP</acronym> хаягаас гадна хоёр 
	<filename>/usr/local/etc/racoon/racoon.conf</filename> файл 
	хоёулаа адил бөгөөд доорхтой төстэй байна.</para>

      <programlisting>path    pre_shared_key  "/usr/local/etc/racoon/psk.txt"; #location of pre-shared key file
log     debug;	#log verbosity setting: set to 'notify' when testing and debugging is complete

padding	# options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer	# timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen	# address [port] that racoon will listening on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)	# address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{								# $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des,des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</programlisting>

      <para>Тохируулга бүрийг энэ жишээн дээр жагсаагдсантай нь 
	тайлбарлах нь энэ баримтын хүрээнээс гадуур юм. 
	<application>racoon</application>-ий тохиргооны гарын 
	авлагын хуудсанд холбогдох мэдээлэл олон бий.</para>

      <para>&os; болон <application>racoon</application> нь 
	хостуудын хооронд сүлжээний урсгалыг нууцлах болон буцааж 
	задалж чаддаг байхын тулд <acronym>SPD</acronym> 
	бодлогуудыг тохируулсан байх ёстой.</para>

      <para>Энэ үйлдлийг дараах ажлын гарц дээрх шиг энгийн бүрхүүлийн 
	скриптээр шийдэж болно. Энэ файлыг системийг эхлүүлэх үед 
	ашиглах бөгөөд 
	<filename>/usr/local/etc/racoon/setkey.conf</filename> гэж 
	хадгалах ёстой.</para>

<programlisting>flush;
spdflush;
# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</programlisting>

      <para>Ингэсний дараа <application>racoon</application>-г 
	хоёр гарц дээр дараах тушаал ашиглан эхлүүлнэ:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</userinput></screen>

      <para>Гарах үр дүнд нь доорхтой төстэй байна:</para>

      <programlisting>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</programlisting>

      <para>Тунель зөв ажиллаж байгааг шалгахын тулд нөгөө 
	консол руу шилжиж сүлжээний урсгалыг харахын тулд 
	&man.tcpdump.1; ашиглан дараах тушаалыг хэрэглэнэ. 
	<literal>em0</literal>-ийг сүлжээний интерфэйс картаараа 
	шаардлагатай бол солиорой.</para>

      <screen>&prompt.root; <userinput>tcpdump -i em0 host <replaceable>172.16.5.4 and dst 192.168.1.12</replaceable></userinput></screen>

      <para>Доорхтой төстэй өгөгдөл консол дээр гарах ёстой. 
	Хэрэв үгүй бол асуудалтай гэсэн үг бөгөөд буцаасан 
	өгөгдлийг дибаг хийх шаардлагатай.</para>

      <programlisting>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</programlisting>

      <para>Энд хүрэхэд хоёр сүлжээ хүрэх боломжтой байх бөгөөд 
	нэг сүлжээний хэсэг юм шиг харагдах болно. Хоёр сүлжээ нь 
	аль аль нь галт ханаар хамгаалагдсан байж болох бөгөөд 
	ингэх ч ёстой юм. Тэдгээрийн хооронд урсгалыг зөвшөөрөхийн 
	тулд пакетуудыг нааш цааш дамжуулах дүрмүүдийг нэмэх 
	шаардлагатай. &man.ipfw.8; галт ханын хувьд галт ханын 
	тохиргооны файлдаа дараах дүрмүүдийг нэмээрэй:</para>

      <programlisting>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</programlisting>

      <note>
	<para>Дүрмийн дугааруудыг тухайн хостын тохиргооноос 
	  хамаарч өөрчлөх шаардлагатай байж болох юм.</para>
      </note>

      <para>&man.pf.4; эсвэл &man.ipf.8;,-ийн хэрэглэгчдийн хувьд 
	дараах дүрмүүд үүнийг хийх болно:</para>

      <programlisting>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</programlisting>

      <para>Төгсгөлд нь системийг эхлүүлэх явцад 
	<acronym>VPN</acronym>-ийг 
	машин дэмжин ажиллаж эхэлдэг байлгахын тулд дараах мөрүүдийг 
	<filename>/etc/rc.conf</filename> файлд нэмэх хэрэгтэй:</para>

      <programlisting>ipsec_enable="YES"
ipsec_program="/usr/local/sbin/setkey"
ipsec_file="/usr/local/etc/racoon/setkey.conf" # allows setting up spd policies on boot
racoon_enable="yes"</programlisting>
    </sect2> 
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Шерн</firstname>
	  <surname>Ли</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> нь алсын машинуудад аюулгүйгээр хандах 
	сүлжээний холболтын хэрэгслүүдийн олонлог юм. <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command>, болон 
      <command>telnet</command>-ийг энэ програмаар шууд орлуулан ашиглаж болно. 
	Мөн TCP/IP холболтууд аюулгүйгээр SSH-ээр туннель хийгдэж/дамжуулагдаж 
	болдог. <application>OpenSSH</application> нь сэм чагналт, холболт булаан авалт, болон 
	бусад сүлжээний түвшний халдлагуудыг үр дүнтэйгээр устгаж бүх трафикийг шифрлэдэг.</para>

    <para><application>OpenSSH</application>-г OpenBSD төсөл дэмжиж байдаг бөгөөд 
	бүх сүүлийн үеийн алдааны засварууд болон шинэчлэлтүүд бүхий  SSH v1.2.12 дээр 
	тулгуурласан байдаг. Энэ програм нь SSH протокол 1 болон 2-той хоёулантай нь 
	нийцтэй.</para>

    <sect2>
      <title>OpenSSH-ийг ашиглах давуу тал</title>
  
      <para>&man.telnet.1; эсвэл &man.rlogin.1; ашиглаж байх үед сүлжээгээр 
	илгээгдэж байгаа өгөгдөл цэвэр, шифрлэгдээгүй хэлбэрээр байдаг.
	Сүлжээний шиншлэгчид клиент болон серверийн хооронд хаана ч байсан гэсэн 
	таны хэрэглэгч/нууц үгийн мэдээлэл эсвэл таны сессээр дамжсан өгөгдлийг 
	хулгайлж чадна. <application>OpenSSH</application> нь ийм асуудлаас 
	хамгаалж төрөл бүрийн нэвтрэлт таних болон шифрлэх аргуудыг санал болгодог.</para>
    </sect2>

    <sect2>
      <title>sshd-г идэвхжүүлэх</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>идэвхжүүлэх</secondary>
      </indexterm>

      <para><application>sshd</application> нь стандарт &os; суулгацын явцад 
	харуулагдах тохируулга юм. <application>sshd</application> идэвхжсэн 
	эсэхийг харахдаа <filename>rc.conf</filename> файлаас дараах мөрийг 
	шалгаарай:</para>
      <screen>sshd_enable="YES"</screen>
      <para>Энэ нь дараагийн удаа таны систем эхлэхэд <application>OpenSSH</application>-д 
	зориулсан &man.sshd.8; дэмон програмыг дуудна. Мөн <filename>/etc/rc.d/sshd</filename> 
	&man.rc.8; скрипт ашиглан <application>OpenSSH</application>-г эхлүүлэх 
	боломжтой байдаг:</para>

      <programlisting>/etc/rc.d/sshd start</programlisting>
    </sect2>

    <sect2>
      <title>SSH клиент</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>клиент</secondary>
      </indexterm>

      <para>&man.ssh.1; хэрэгсэл &man.rlogin.1;-тэй адил 
	ажилладаг.</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>Нэвтрэлт нь <command>rlogin</command> эсвэл 
        <command>telnet</command> ашиглан үүсгэгдсэн сесс шиг үргэлжлэх болно. 
	SSH нь хэрэглэгч холбогдоход серверийн жинхэнэ эсэхийг шалгахын тулд 
	түлхүүр хээ шалгах системийг хэрэглэдэг. Хэрэглэгч зөвхөн эхний удаа холбогдоход 
	<literal>yes</literal> гэж оруулахыг шаардана. Дараа дараагийн 
	нэвтрэлт оролдлогууд бүгд хадгалсан хээ шалгах түлхүүртэй харьцуулагдан 
	шалгагддаг. Хэрэв хадгалсан хээ нь дараа дараагийн нэвтрэлтийн оролдлогуудаас 
	хүлээн авсан хээнээс өөр бол SSH клиент нь танд түгшүүр өгнө. Хээнүүд 
	<filename>~/.ssh/known_hosts</filename> файлд эсвэл SSH v2-ийн хээнүүд
	<filename>~/.ssh/known_hosts2</filename> файлд 
	хадгалагдана.</para>

      <para>Анхдагчаар <application>OpenSSH</application> серверүүдийн 
	сүүлийн үеийн хувилбарууд зөвхөн SSH v2 холболтуудыг хүлээн авдаг. 
	Клиент нь хэрэв боломжтой бол 2-р хувилбарыг ашиглах бөгөөд боломжгүй бол 
	1-р хувилбарыг ашигладаг. <option>-1</option> эсвэл
        <option>-2</option> тохируулгуудыг 1-р эсвэл 2-р хувилбаруудад зориулан 
	дамжуулан клиентэд зөвхөн аль нэгийг ашиглахыг хүчилж болно. 1-р хувилбарын 
	нийцтэй байдал нь клиентэд хуучин хувилбаруудтай нийцтэй байх зорилгоор дэмжигдсэн 
	байдаг.</para>
    </sect2>
    
    <sect2>
      <title>Аюулгүй хуулбарлалт</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>аюулгүй хуулбарлалт</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>&man.scp.1; тушаал &man.rcp.1;-тэй адил ажилладаг; энэ нь файлыг алсын 
	машинаас эсвэл машин уруу, ялгаатай нь аюулгүйгээр хуулдаг.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735       
00:00    
&prompt.root;</screen>
      <para>Өмнөх жишээн дээр энэ хостын хувьд хээ нь аль хэдийн хадгалагдсан болохоор 
	&man.scp.1;-ийг энд ашиглах үед шалгагддаг.</para>

      <para>&man.scp.1;-ээр дамжуулсан нэмэлт өгөгдлүүд нь &man.cp.1;-тэй адил бөгөөд 
	эхний нэмэлт өгөгдөлд файл эсвэл файлууд, хоёр дахь дээр очих файлыг 
	зааж өгдөг. Файл нь сүлжээгээр SSH-ээр татагддаг  болохоор файлын нэг эсвэл хэд хэдэн 
	нэмэлт өгөгдлүүд <option>user@host:&lt;path_to_remote_file&gt;</option> 
	хэлбэрийг авдаг.</para>

    </sect2>

    <sect2>
      <title>Тохиргоо</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>тохиргоо</secondary>
      </indexterm>

      <para><application>OpenSSH</application> дэмон болон клиентийн 
	системийн дагуух тохиргооны файлууд <filename class="directory">/etc/ssh</filename> 
	санд байрладаг.</para>

      <para><filename>ssh_config</filename> клиентийн тохируулгуудыг 
	тохируулдаг бөгөөд <filename>sshd_config</filename> нь 
	дэмонг тохируулдаг.</para>

      <para>Мөн <option>sshd_program</option> 
	(анхдагчаар <filename>/usr/sbin/sshd</filename>) болон 
	<option>sshd_flags</option> <filename>rc.conf</filename> 
	тохируулгууд тохиргооны түвшнүүдийг илүүтэйгээр хангадаг.</para>
    </sect2>

    <sect2 id="security-ssh-keygen">
      <title>ssh-keygen</title>

      <para>Нууц үгүүдийг ашиглахын оронд &man.ssh-keygen.1; нь 
	хэрэглэгчийг шалгаж танихад DSA эсвэл RSA түлхүүрүүдийг үүсгэхэд 
	хэрэглэгдэж болно:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>dsa</replaceable></userinput>
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com
</screen>

      <para>&man.ssh-keygen.1; нь шалгаж танихад хэрэглэгдэх нийтийн болон хувийн 
	түлхүүр хослолыг үүсгэнэ. Хувийн түлхүүр <filename>~/.ssh/id_dsa</filename> эсвэл 
        <filename>~/.ssh/id_rsa</filename>-д хадгалагдах бөгөөд харин нийтийн түлхүүр 
	нь <filename>~/.ssh/id_dsa.pub</filename> эсвэл 
        <filename>~/.ssh/id_rsa.pub</filename>-д DSA болон RSA түлхүүрийн төрлүүдэд 
	зориулагдан хадгалагддаг. Тохируулга нь ажиллахын тулд нийтийн түлхүүр нь алсын машины 
	<filename>~/.ssh/authorized_keys</filename> файлд DSA болон RSA түлхүүрүүдийн 
	хоёулангийнх нь хувьд хийгдэх ёстой байдаг. 
	Үүнтэй адилаар нийтийн түлхүүрүүдийн RSA хувилбар нь 
	<filename>~/.ssh/authorized_keys</filename> файлд бас хийгдэх ёстой.</para>

      <para>Энэ нь нууц үгүүдийн оронд SSH түлхүүрүүдийг ашиглан алсын машин уруу 
	холбогдохыг зөвшөөрөх болно.</para>

      <para>Хэрэв нэвтрэх үгнүүд &man.ssh-keygen.1;-д ашиглагдаж байгаа бол 
	хувийн түлхүүрийг хэрэглэхийн тулд хэрэглэгчээс нууц үгийг нэвтрэх болгонд 
	асуудаг. &man.ssh-agent.1; нь урт нэвтрэх үгнүүдийг дахин дахин оруулах 
	тэр зовлонг зөөллөж чадах бөгөөд <xref linkend="security-ssh-agent"> 
	хэсэгт тайлбарлагдсан байгаа болно.</para>

      <warning><para>Төрөл бүрийн тохируулгууд болон файлууд нь 
	таны систем дээр байгаа <application>OpenSSH</application>-ийн 
	хувилбаруудаас шалтгаалан өөр өөр байдаг; асуудалтай учрахгүйн тулд 
	та &man.ssh-keygen.1; гарын авлагын хуудаснаас лавлах 
	хэрэгтэй.</para></warning>
    </sect2>

    <sect2 id="security-ssh-agent">
      <title>ssh-agent болон ssh-add</title>

      <para>&man.ssh-agent.1; болон &man.ssh-add.1; хэрэгслүүд нь 
	нэвтрэх үгнүүдийг дахин дахин бичүүлэлгүйгээр <application>SSH</application> 
	түлхүүрүүдийг санах ойд дуудан ашиглаж болох аргуудаар хангадаг.</para>

      <para>&man.ssh-agent.1; хэрэгсэл нь түүн уруу дуудагдсан хувийн түлхүүр(үүд) 
	ашиглан жинхэнэ эсэхийг шалгах танилтыг зохицуулна. &man.ssh-agent.1; нь өөр програмыг 
	ачаалахад хэрэглэгдэх ёстой. Хамгийн хялбартаа энэ нь  бүрхүүл  
	эсвэл илүү дэвшилттэйгээр ашиглавал цонхны удирдагч ажиллуулж болох 
	юм.</para>

      <para>&man.ssh-agent.1;-ийг бүрхүүлд ашиглахын тулд үүнийг эхлээд 
	бүрхүүлтэй цуг нэмэлт өгөгдөл маягаар ажиллуулах шаардлагатай. Хоёрдугаарт 
	хэн бэ гэдэг мэдээллийг (identity) &man.ssh-add.1;-г ажиллуулан нэмэх хэрэгтэй бөгөөд 
	түүнд хувийн түлхүүрийн нэвтрэх үгнүүдийг өгөх хэрэгтэй. Эдгээр алхмууд 
	хийгдсэний дараа хэрэглэгч харгалзах нийтийн түлхүүр суулгагдсан 
	дурын хост уруу &man.ssh.1; хийж чадах болно. 
	Жишээ нь:</para>

      <screen>&prompt.user; ssh-agent <replaceable>csh</replaceable>
&prompt.user; ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
&prompt.user;</screen>

      <para>X11 дээр &man.ssh-agent.1; хэрэглэхийн тулд &man.ssh-agent.1;-ийн 
	дуудлага <filename>~/.xinitrc</filename>-д байх шаардлагатай. 
	Ингэснээр X11-д ачаалагдсан бүх програмуудад &man.ssh-agent.1;-ийн  
	үйлчилгээнүүдийг  үзүүлэх болно. Жишээ <filename>~/.xinitrc</filename> 
	файл иймэрхүү харагдах болно:</para>

      <programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

      <para>Энэ нь &man.ssh-agent.1;-ийг ажиллуулах бөгөөд тэр нь эргээд 
	X11 эхлэх бүрт <application>XFCE</application>-ийг ажиллуулна.
	Ингэж хийгдсэний дараа өөрчлөлтүүд нь үйлчлэхийн тулд X11 дахин эхэлсний хойно 
	өөрийн SSH түлхүүрүүдийг бүгдийг ачаалахын тулд ердөө л &man.ssh-add.1;-ийг 
	ажиллуулаарай.</para>
    </sect2>

    <sect2 id="security-ssh-tunneling">
      <title>SSH туннель хийх</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>туннель хийх</secondary>
      </indexterm>

      <para><application>OpenSSH</application> нь шифрлэгдсэн сессийн үед өөр протоколыг 
	хайрцаглах туннель үүсгэх чадвартай байдаг.</para>

      <para>Дараах тушаал <application>telnet</application>-д зориулж туннель үүсгэхийг 
	&man.ssh.1;-д хэлж өгнө:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para><command>ssh</command> тушаал дараах тохируулгуудтай 
	хэрэглэгдэнэ:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>
	  
	  <listitem>
	    <para><command>ssh</command>-ийг протоколын 2-р хувилбарыг 
		ашиглахыг зааж өгнө. (хэрэв та хуучин SSH серверүүдтэй ажиллаж 
		байгаа бол үүнийг битгий ашиглаарай)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Тушаал байхгүй эсвэл зөвхөн туннель гэдгийг заана. Хэрэв үүнийг 
		орхивол <command>ssh</command> ердийн сесс эхлүүлнэ.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para><command>ssh</command>-ийг ард, далд ажиллуулахыг 
		заана.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Локал туннелийг <replaceable>localport:remotehost:remoteport</replaceable>
		загвараар зааж өгнө.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Алсын SSH сервер.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


      <para>SSH туннель нь сонсох сокетийг <hostid>localhost</hostid>-ийн 
	заагдсан порт дээр үүсгэн ажилладаг. Дараа нь локал хост/порт дээр хүлээн 
	авсан дурын холболтыг SSH-ээр дамжуулан заасан алсын хост болон порт уруу 
	илгээдэг.</para>

      <para>Жишээн дээр <hostid>localhost</hostid> дээрх <replaceable>5023</replaceable> 
	порт нь алсын машины <hostid>localhost</hostid> дээрх <replaceable>23</replaceable> 
	порт уруу дамжуулагдаж байна. <replaceable>23</replaceable> нь 
	<application>telnet</application> учир энэ нь SSH туннелээр аюулгүй 
	<application>telnet</application> сесс үүсгэнэ.</para>

      <para>SMTP, POP3, FTP гэх зэрэг ямар ч аюултай TCP протоколуудын 
	гүйцэтгэлийг хялбаршуулахад үүнийг ашиглаж болно.</para>

      <example>
	<title>SMTP-д зориулан SSH ашиглан аюулгүй туннель үүсгэх</title>

        <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>     

        <para>Үүнийг &man.ssh-keygen.1; болон нэмэлт хэрэглэгчийн бүртгэлүүдтэй 
	цуг илүү үл үзэгдэх/төвөггүй SSH туннель хийх орчин үүсгэхэд ашиглаж болно. 
	Түлхүүрүүд нь нууц үг бичихийн оронд ашиглагдаж болох бөгөөд туннелиуд 
	нь тусдаа хэрэглэгч маягаар ажиллаж чадна.</para>
      </example>

      <sect3>
	<title>SSH туннелийн практик жишээнүүд</title>

	<sect4>
	  <title>POP3 сервер уруу аюулгүй хандах</title>

	  <para>Ажил дээр чинь гаднаас холболтууд хүлээн авах SSH сервер байна. 
		Бас тэр оффисийн сүлжээнд POP3 сервер ажиллуулж байгаа 
		захидлын сервер байна. Таны гэр болон оффисийн хоорондын 
		сүлжээ болон сүлжээний зам итгэж болохоор эсвэл итгэж болохооргүй 
		байж магадгүй юм. Ийм учраас та өөрийн захидлыг аюулгүй аргаар 
		шалгах хэрэгтэй юм. Үүний шийдэл нь өөрийн оффисийн SSH сервер 
		уруу SSH холболт үүсгэж захидлын сервер уруу туннель хийх явдал 
		юм.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Туннель эхлэн ажилласны дараа та өөрийн захидлын клиентийнхээ 
		POP3 хүсэлтүүдийг <hostid>localhost</hostid>-ийн 2110 порт уруу 
		илгээхээр зааж өгч болно. Эндэх холболт туннелээр аюулгүйгээр дамжин 
		<hostid>mail.example.com</hostid> уруу илгээгдэнэ.</para>
	</sect4>

	<sect4>
	  <title>Хэцүү галт ханыг тойрон гарах</title>

	  <para>Зарим сүлжээний администраторууд хэтэрхий чанга галт ханын дүрэм ашиглан 
		зөвхөн ирж байгаа холболтууд төдийгүй гарч байгаа холболтуудыг ч бас 
		шүүдэг. Танд алсын машинуудад зөвхөн SSH болон вэбээр аялах 22 болон 
		80-р портуудад хандах боломжийг өгсөн байж болох юм.</para>

	  <para>Та хөгжим цацдаг Ogg Vorbis сервер зэрэг өөр (магадгүй ажилдаа холбоогүй) 
		үйлчилгээ уруу хандахыг магадгүй хүсэж болох юм. Хэрэв энэ Ogg Vorbis 
		сервер нь 22 эсвэл 80-аас бусад өөр порт дээр цацаж байгаа бол 
		та түүнд хандаж чадахгүй юм.</para>

	  <para>Үүний шийдэл нь таны сүлжээний галт ханаас гаднах машин уруу SSH холболт үүсгэж 
		үүнийг Ogg Vorbis сервер уруу туннель хийхэд ашиглах явдал юм.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>Таны урсгал хүлээн авах клиент одоо <hostid>localhost</hostid>-ийн 
		8888 порт уруу заагдах бөгөөд тэр цаашаагаа галт ханыг амжилттайгаар 
		гэтлэн <hostid>music.example.com</hostid> уруу дамжуулагдана.</para>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title><varname>AllowUsers</varname> хэрэглэгчийн тохируулга</title>

      <para>Ямар хэрэглэгчид хаанаас орохыг хязгаарлаж өгөх нь зүйтэй юм. 
	<literal>AllowUsers</literal> тохируулга нь үүнд хүрэх сайн арга 
	юм. Жишээ нь <username>root</username> хэрэглэгчийг зөвхөн 
	<hostid role="ipaddr">192.168.1.32</hostid>-оос орохыг 
	зөвшөөрөхийн тулд доор дурдсантай адил тохируулгыг <filename>/etc/ssh/sshd_config</filename> 
	файлд хийх нь зүйтэй юм:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para><username>admin</username> хэрэглэгчийг хаанаас ч орохыг зөвшөөрөхийн 
	тулд ердөө л хэрэглэгчийн нэрийг өөрийг нь жагсааж өгнө:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Олон хэрэглэгчид нэг мөрөнд жагсаагдах шаардлагатай:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
        <para>Та энэ машин уруу нэвтрэх хэрэгцээтэй хэрэглэгч бүрийг жагсааж өгөх нь чухал юм, 
		тэгэхгүй бол тэдгээр нь орж чадахгүй болно.</para>
      </note>

      <para><filename>/etc/ssh/sshd_config</filename>-д өөрчлөлтүүд хийснийхээ 
	дараа &man.sshd.8;-д өөрийн тохиргооны файлуудыг дахин дуудахыг дараах тушаалыг 
	ажиллуулж та хэлж өгөх ёстой:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>Нэмэлт унших материалууд</title>
      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>
      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1; 
        &man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5;</para>
      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5;</para>
    </sect2>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хавь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>ACL</primary>
    </indexterm>
    <title>Файлын системийн хандалт хянах жагсаалтууд</title>

    <para>Хормын хувилбарууд зэрэг файлын системийн өргөжүүлэлтүүдийн хамтаар FreeBSD нь 
	Файлын системийн хандалт хянах жагсаалтуудын 
	(<acronym>ACL</acronym>-ууд) аюулгүй байдлыг санал болгодог.</para>

    <para>Хандалт Хянах Жагсаалтууд нь стандарт &unix; зөвшөөрлийн загварыг 
	маш нийцтэй (&posix;.1e) аргаар өргөтгөдөг. Энэ боломж нь администраторт 
	илүү төвөгтэй аюулгүй байдлын загвар болон түүний давуу талыг ашиглахыг 
	зөвшөөрдөг.</para>

    <para><acronym>UFS</acronym> файлын системүүдэд <acronym>ACL</acronym> 
	дэмжлэгийг идэвхжүүлэхийн тулд дараах:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>тохируулгыг цөмд эмхэтгэх шаардлагатай. Хэрэв энэ тохируулга эмхэтгэгдээгүй бол 
	<acronym>ACL</acronym>-ууд дэмжих файлын системийг холбохыг оролдоход 
	анхааруулах мэдэгдэл дэлгэцэд гардаг. Энэ тохируулга <filename>GENERIC</filename> 
	цөмд орсон байдаг. <acronym>ACL</acronym>-ууд нь файлын систем дээр өргөтгөсөн шинж 
	чанаруудыг  идэвхжүүлсэн дээр тулгуурладаг. Өргөтгөсөн шинж чанарууд нь 
	дараа үеийн &unix; файлын систем <acronym>UFS2</acronym>-д төрөлхийн 
	дэмжигдсэн байдаг.</para>

    <note><para><acronym>UFS1</acronym> дээр өргөтгөсөн шинж чанаруудыг тохируулахад  
	<acronym>UFS2</acronym> дээр тохируулахтай харьцуулбал илүү удирдлагын 
	зардал шаардлагатай байдаг. <acronym>UFS2</acronym> дээрх өргөтгөсөн 
	шинж чанаруудын ажиллагаа нь бас бодитойгоор илүү байдаг. Иймээс 
	<acronym>UFS2</acronym>-г <acronym>UFS1</acronym>-ийн оронд 
	хандалт хянах жагсаалтуудад ашиглахыг ерөнхийдөө зөвлөдөг.</para></note>

    <para><acronym>ACL</acronym>-ууд нь <filename>/etc/fstab</filename> файлд 
	нэмэгдэж өгч болох холбох үеийн удирдлагын  <option>acls</option> тугаар 
	идэвхтэй болдог.  Файлын системийн толгой дахь супер блокийн <acronym>ACL</acronym>-ууд тугийг 
	өөрчлөхийн тулд &man.tunefs.8;-ийг ашиглан шургуу замаар холбох үеийн тугийг автоматаар 
	зааж өгч болно. Ерөнхийдөө хэд хэдэн шалтгааны улмаас супер блокийн тугийг  ашиглах нь 
	дээр байдаг:</para>

    <itemizedlist>
      <listitem>
	<para>Холбх үеийн <acronym>ACL</acronym>-ууд туг дахин холболтоор өөрчлөгддөггүй 
	(&man.mount.8; <option>-u</option>), зөвхөн бүрэн гүйцэд 
	&man.umount.8; хийгдэж шинэ &man.mount.8; хийгдсэний дараа болно. 
	Энэ нь бас файлын системийг ашиглаж байх үед дарааллыг нь өөрчилж болохгүй гэсэн үг 
	юм.</para>
      </listitem>

      <listitem>
	<para><filename>fstab</filename>-д мөр байхгүй байсан ч гэсэн эсвэл төхөөрөмжүүдийн 
	дараалал өөрчлөгдсөн ч гэсэн супер блокийн тугийг тохируулах нь файлын системийг үргэлж 
	<acronym>ACL</acronym>-уудыг  идэвхтэйгээр холбоход хүргэдэг. Энэ нь файлын системийг 
	<acronym>ACL</acronym>-уудыг идэвхжүүлэлгүйгээр санамсаргүйгээр холбохоос хамгаалдаг бөгөөд 
	ингэж санамсаргүй холбох нь <acronym>ACL</acronym>-уудыг буруугаар албадаж 
	тэгснээр аюулгүй байдлын асуудлуудад хүргэж болох юм.</para>
      </listitem>
    </itemizedlist>

    <note><para>Бид шинэ &man.mount.8; хийлгүйгээр туг идэвхжүүлдгийг зөвшөөрөхөөр  
	<acronym>ACL</acronym>-уудын ажиллагааг өөрчилж болох юм, гэхдээ бид 
	<acronym>ACL</acronym>-уудыг идэвхжүүлэлгүй санамсаргүйгээр холболт хийхийг 
	болиулахыг хүсдэг бөгөөд учир нь хэрэв та <acronym>ACL</acronym>-уудыг идэвхжүүлээд 
	дараа нь болиулаад өргөтгөсөн шинж чанаруудыг устгалгүйгээр дахин идэвхжүүлбэл та 
	өөртөө нэлээн хэцүү асуудал учруулах зүйлийг хийх болно. Ерөнхийдөө та файлын систем 
	дээр <acronym>ACL</acronym>-уудыг идэвхжүүлсний дараа файлын хамгаалалтууд нь 
	системийн хэрэглэгчдэд зориулагдсан файлуудтай нийцгүй болж болох учир тэдгээрийг 
	болиулж болохгүй бөгөөд <acronym>ACL</acronym>-уудыг дахин идэвхжүүлэх нь 
	зөвшөөрлүүд нь өөрчлөгдсөн байж болох файлуудад өмнөх <acronym>ACL</acronym>-уудыг 
	магадгүй дахин холбож өөр тааварлаж болшгүй ажиллагаанд хүргэж болох юм.</para></note>
      
    <para><acronym>ACL</acronym>-ууд идэвхжүүлсэн файлын системүүд өөрсдийн зөвшөөрлийн 
	тохируулгууд дээрээ <literal>+</literal> (нэмэх) тэмдэг үзэх үед харуулдаг.
	Жишээ нь:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Энд бид <filename class="directory">directory1</filename>,
      <filename class="directory">directory2</filename>, болон <filename class="directory">directory3</filename> 
	сангууд бүгд <acronym>ACL</acronym>-ууд-ийн давуу талыг авч байгааг харж байна. 
	<filename class="directory">public_html</filename> сан тэгэхгүй байна.</para>

    <sect2>
      <title><acronym>ACL</acronym>-уудыг ашиглах нь</title>

      <para>Файлын системийн <acronym>ACL</acronym>-уудыг &man.getfacl.1; 
	хэрэгслээр харж болно. Жишээ нь <filename>test</filename> файл дээрх 
	<acronym>ACL</acronym> тохируулгуудыг харахын тулд дараах тушаалыг 
	ажиллуулах хэрэгтэй:</para>

      <screen>&prompt.user; <userinput>getfacl <filename>test</filename></userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>Энэ файлын <acronym>ACL</acronym> тохируулгуудыг өөрчлөхийн тулд 
	&man.setfacl.1; хэрэгслийг ажиллуул. Ажиглаарай:</para>

      <screen>&prompt.user; <userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para><option>-k</option> туг нь тухайн үед тодорхойлогдсон бүх 
	<acronym>ACL</acronym>-уудыг файл эсвэл файлын системээс 
	арилгана. Илүү дээр арга бол <acronym>ACL</acronym>-уудыг 
	ажиллуулахад шаардлагатай үндсэн талбаруудыг орхидог 
	<option>-b</option> тугийг ашиглах явдал юм.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,group:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>Дээр дурдсан тушаал дээр <option>-m</option> тохируулга анхдагч 
	<acronym>ACL</acronym> оруулгуудыг өөрчлөхөд хэрэглэгдсэн. 
	Өмнөх тушаалаар устгагдсан болохоор урьдчилан тодорхойлсон оруулгууд 
	байхгүй учир энэ нь анхдагч тохируулгуудыг  сэргээж жагсаасан тохируулгуудаас 
	зааж өгдөг. Хэрэв та систем дээр байхгүй хэрэглэгч эсвэл бүлэг нэмэх бол 
	<errorname>Invalid argument</errorname> буюу Буруу нэмэлт өгөгдөл 
	гэсэн алдаа <devicename>stdout</devicename> уруу хэвлэгдэнэ гэдгийг 
	санаж байх хэрэгтэй.</para>
    </sect2>
  </sect1>

  <sect1 id="security-portaudit">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>Portaudit</primary>
    </indexterm>
    <title>Гуравдагч талын аюулгүй байдлын асуудлуудыг монитор хийх нь</title>

    <para>Сүүлийн жилүүдэд эмзэг асуудлын үнэлгээ хэрхэн зохицуулагдаж байгаа тал дээр 
	аюулгүй байдлын ертөнц олон сайжруулалт хийсэн. Одоогийн байгаа бүх л үйлдлийн 
	системүүд дээр гуравдагч талын хэрэгслүүд суулгаж тохируулдгаас болж системийн 
	халдлагын заналхийлэл ихэсдэг.</para>

    <para>Эмзэг асуудлын үнэлгээ нь аюулгүй байдлын түлхүүр хүчин зүйл бөгөөд 
	&os; нь үндсэн системд зориулан зөвлөгөөнүүдийг гаргадаг боловч 
	гуравдагч талын хэрэгслүүд бүрийн хувьд хийх нь &os; төслийн боломжоос 
	гадуур юм. Мэдэгдэж байгаа асуудлуудыг администраторуудад анхааруулж 
	гуравдагч талын эмзэг асуудлуудыг зөөлрүүлэх арга байдаг. &os;-д нэмэлтээр 
	<application>Portaudit</application> гэгддэг хэрэгсэл зөвхөн энэ 
	зорилгоор байдаг.</para>

    <para><filename role="package">ports-mgmt/portaudit</filename> порт нь 
	&os;-ийн аюулгүй байдлын баг болон портуудын хөгжүүлэгчдийн шинэчилж 
	ажиллагааг нь хангаж байдаг мэдээллийн баазаас мэдэгдэж байгаа аюулгүй байдлын 
	асуудлуудыг шалгадаг.</para>

    <para><application>Portaudit</application>-г ашиглаж эхлэхийн тулд 
	Портуудын цуглуулгаас түүнийг суулгах хэрэгтэй:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>Суулгах процессийн явцад өдөр бүрийн аюулгүй байдлыг шалгах ажиллагаанд 
	<application>Portaudit</application>-н гаралтыг зөвшөөрч 
	&man.periodic.8;-д зориулсан тохиргооны файлуудыг шинэчилдэг. 
	Өдөр тутмын аюулгүй байдлыг шалгах ажиллагаа <username>root</username>-ийн 
	захидлын бүртгэл уруу цахим захидал явуулж түүнийг уг хэрэглэгч уншсан эсэхийг
	баталгаажуулах хэрэгтэй. Өөр ямар ч илүү тохиргоо энд хэрэггүй.</para>

    <para>Суулгасны дараа администратор мэдээллийн баазыг шинэчлэх болон суулгасан 
	багцуудад мэдэгдэж байгаа эмзэг асуудлуудыг үзэхдээ дараах тушаалыг 
	ажиллуулна:</para>

    <screen>&prompt.root; <userinput>portaudit -Fda</userinput></screen>

    <note>
      <para>Мэдээллийн бааз &man.periodic.8; ажиллах үед автоматаар шинэчлэгддэг; 
	иймээс дээрх тушаал заавал шаардлагагүй юм. Энэ нь зөвхөн дараах жишээнүүдэд 
	шаардлагатай.</para>
    </note>

    <para>Портуудын цуглуулгын хэсэг болгон суулгагдсан гуравдагч талын хэрэгслүүдийг 
	ямар ч үед аудит хийхдээ администратор зөвхөн дараах тушаалыг ажиллуулах 
	хэрэгтэй:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para><application>Portaudit</application> эмзэг асуудалтай багцын хувьд 
	доор дурдсантай адилыг гаргана:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Үзүүлсэн <acronym>URL</acronym> уруу вэб хөтчийг чиглүүлж администратор 
	асуудалтай байгаа эмзэг асуудлын талаар дэлгэрэнгүй мэдээллийг олж авч 
	болно. Ийм мэдээлэл нь нөлөөлөх хувилбарууд болон &os;-ийн портын хувилбар, 
	аюулгүй байдлын зөвлөгөөнүүд байж болох өөр бусад вэб сайтуудыг агуулж болох 
	юм.</para>

    <para>Товчхондоо <application>Portaudit</application> нь хүчирхэг 
	хэрэгсэл бөгөөд <application>Portupgrade</application> порттой цуг 
	хэрэглэхэд маш ашигтай байдаг.</para>
  </sect1>

  <sect1 id="security-advisories">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>FreeBSD-ийн аюулгүй байдлын зөвлөгөөнүүд</primary>
    </indexterm>
    <title>&os;-ийн аюулгүй байдлын зөвлөгөөнүүд</title>

    <para>Үйлдвэрлэлийн чанарыг хангасан үйлдлийн системүүдийн нэгэн адил &os; 
	<quote>Аюулгүй байдлын зөвлөгөөнүүд</quote> гаргадаг. Эдгээр 
	зөвлөгөөнүүд нь ихэвчлэн аюулгүй байдлын жагсаалтууд уруу илгээгддэг 
	бөгөөд зөвхөн тохирох хувилбаруудад засвар хийгдсэний дараа Errata буюу 
	алдааны хуудсанд тэмдэглэгддэг. Энэ хэсэгт зөвлөгөө гэж юу болох, түүнийг 
	хэрхэн ойлгох болон системд засвар хийхдээ ямар арга хэмжээнүүдийг 
	авах талаар тайлбарлах болно.</para>

    <sect2>
      <title>Зөвлөгөө ямархуу харагдах вэ?</title>

      <para>&os;-ийн аюулгүй байдлын зөвлөгөөнүүд 
	&a.security-notifications.name; захидлын жагсаалтаас авсан доорх
	зөвлөгөөтэй адил харагдах болно.</para>

      <programlisting>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem<co id="co-topic">

Category:       core<co id="co-category">
Module:         sys<co id="co-module">
Announced:      2003-09-23<co id="co-announce">
Credits:        Person<co id="co-credit">
Affects:        All releases of &os;<co id="co-affects">
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co id="co-corrected">
<acronym>CVE</acronym> Name:	CVE-XXXX-XXXX<co id="co-cve">

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<co id="co-backround">


II.  Problem Description<co id="co-descript">


III. Impact<co id="co-impact">


IV.  Workaround<co id="co-workaround">


V.   Solution<co id="co-solution">


VI.  Correction details<co id="co-details">


VII. References<co id="co-ref"></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para><literal>Topic</literal> буюу сэдэв талбар асуудал юу болохыг яг заасан 
		байдаг. Энэ нь үндсэндээ тухайн үеийн аюулгүй байдлын зөвлөгөөний 
		танилцуулга бөгөөд эмзэг асуудалтай цуг хэрэгслийг тэмдэглэдэг.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>The <literal>Category</literal> буюу зэрэглэл талбар нь хамаарч байгаа 
		системийн хэсгийг хэлдэг бөгөөд <literal>core</literal>, 
		<literal>contrib</literal>, эсвэл <literal>ports</literal>-ийн 
		аль нэг байж болно. <literal>core</literal> зэрэглэл нь эмзэг 
		асуудал &os; үйлдлийн системийн гол хэсэгт нөлөөлнө гэсэн үг юм. 
		<literal>contrib</literal> зэрэглэл нь эмзэг асуудал 
		<application>sendmail</application> зэрэг &os; төсөлд 
		хувь нэмэр болгон оруулсан програм хангамжуудад нөлөөлнө гэсэн үг юм.
		Эцэст нь <literal>ports</literal> зэрэглэл нь эмзэг асуудал 
		портуудын цуглуулганд ордог нэмэлт програм хангамжуудад нөлөөлөхийг 
		харуулдаг.</para>
	</callout>

	<callout arearefs="co-module">
	  <para><literal>Module</literal> талбар нь бүрэлдэхүүн хэсгийн байрлалыг 
		жишээ нь <literal>sys</literal> гэх зэргээр илэрхийлдэг. Энэ жишээн дээр 
		<literal>sys</literal> модуль өртөхийг бид харж байгаа  бөгөөд ийм учраас энэ 
		эмзэг асуудал нь цөм дотор ашиглагдсан бүрэлдэхүүн хэсэгт нөлөөлөх юм.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para><literal>Announced</literal> буюу зарласан талбар нь аюулгүй байдлын 
		зөвлөгөө хэвлэгдсэн эсвэл ертөнцөд зарлагдсан огноог заадаг. Энэ нь 
		аюулгүй байдлын баг асуудал байгааг шалгаж үүний засвар 
		&os;-ийн эх модны архивт итгэмжлэн оруулсныг тогтоосон гэсэн үг юм.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para><literal>Credits</literal> буюу талархал талбар нь эмзэг асуудлыг 
		мэдэж тайлагнасан хувь хүн болон байгууллагыг зааж талархдаг.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para><literal>Affects</literal> буюу нөлөөлөх хувилбарын талбар нь 
		энэ эмзэг асуудал нөлөөлөх &os;-ийн хувилбаруудыг тайлбарладаг. 
		Цөмийн хувьд уг нөлөөлсөн файлууд дээр ажиллуулсан 
		<command>ident</command> тушаалын үр дүнг зэрвэс харж   
		хувилбарыг тодорхойлж болно. Портуудын хувьд 
		<filename class="directory">/var/db/pkg</filename> санд портын нэрийн дараа 
		хувилбарын дугаар байдаг. Хэрэв систем нь &os;-ийн <acronym>CVS</acronym> 
		архивтай адил хамгийн сүүлийн хэлбэрт орж өдөр тутам дахин бүтээгдээгүй 
		бол энэ нь нөлөөлөлд орсон хэвээр байх магадлалтай юм.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para><literal>Corrected</literal> буюу засварласан талбар нь 
		огноо, цаг, цагийн бүс болон засварласан хувилбаруудыг 
		заадаг.</para>
	</callout>

	<callout arearefs="co-cve">
	  <para>Common Vulnerabilities Database system буюу Нийтлэг Эмзэг асуудлуудын 
		Мэдээллийн Баазын системээс эмзэг асуудлуудыг хайхад хэрэглэгдэх 
		магадлалын мэдээлэлд нөөцлөгддөг.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para><literal>Background</literal> талбар нь нөлөөлөлд яг ямар хэрэгсэл  
		орсон талаар мэдээлэл өгдөг. Ихэнхдээ энэ нь &os;-д яагаад тухайн хэрэгсэл 
		байдаг, юунд хэрэглэгддэг болон хэрэгсэл хэрхэн бий болсон талаар байдаг.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para><literal>Problem Description</literal> буюу асуудлын тайлбар талбар нь 
		аюулгүй байдлын цоорхойг гүнзгий тайлбарладаг. Энэ нь гажигтай кодын мэдээлэл 
		эсвэл бүр хэрэгслийг хэрхэн хорлонтойгоор ашиглаж аюулгүй байдлын цоорхой 
		нээдэг тухай мэдээллийг агуулдаг.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para><literal>Impact</literal> буюу үйлчлэл талбар нь асуудал системд 
		ямар төрлийн үйлчлэл үзүүлдгийг тайлбарладаг. Жишээ нь энэ нь 
		үйлчилгээг зогсоох халдлагаас авахуулаад хэрэглэгчдэд өгч болох нэмэлт 
		зөвшөөрлүүд эсвэл халдагчид супер хэрэглэгчийн хандалт өгөх зэрэг 
		юу ч байж болно.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para><literal>Workaround</literal> буюу тойрон гарах талбар нь 
		боломжит тойрон гарах арга замыг системийг шинэчилж чадахгүй байж болох 
		системийн администраторуудад олгодог. Энэ нь хугацааны шаардлагууд, 
		сүлжээний боломж эсвэл өөр бусад олон шалтгаанаас болдог байж болох 
		юм. Ямар ч байсан гэсэн аюулгүй байдлыг хөнгөнөөр авч үзэж болохгүй 
		бөгөөд нөлөөлөлд орсон систем эсвэл засвар нөхөөс хийгдэх аль эсвэл 
		аюулгүй байдлын цоорхойг тойрон гарах шийдэл хийгдэх 
		шаардлагатай.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para><literal>Solution</literal> буюу шийдэл талбар нь нөлөөлөлд орсон 
		системийг засварлах заавруудыг санал болгодог. Энэ нь системд засвар 
		нөхөөс хийн аюулгүй ажиллуулах алхам алхмаар тест хийгдэж шалгагдсан арга 
		юм.</para>
	</callout>

	<callout arearefs="co-details">
	  <para><literal>Correction Details</literal> буюу засварын нарийн 
		учир талбар нь <acronym>CVS</acronym> салбар эсвэл хувилбарын 
		нэрийн цэгүүдийг доогуур зураас тэмдэгтээр өөрчилж үзүүлдэг. Мөн энэ нь 
		салбар болгон дахь нөлөөлөлд орсон файлуудын хувилбарын дугаарыг бас 
		харуулдаг.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para><literal>References</literal> буюу лавлагаа талбар нь ихэвчлэн 
		бусад мэдээллийн эхүүдийг өгдөг. Энэ нь вэбийн <acronym>URL</acronym>-ууд, 
		номнууд, захидлын жагсаалтууд болон мэдээний бүлгүүдийг агуулж болно.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 id="security-accounting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>Процессийн бүртгэл хөтлөх</primary>
    </indexterm>
    <title>Процессийн бүртгэл хөтлөх</title>

    <para>Процессийн бүртгэл хөтлөх аюулгүй байдлын аргыг ашиглаж 
	администраторууд системийн эх үүсвэрүүдийг ашигласан байдал болон тэдгээрийг 
	хэрэглэгчдэд хэрхэн хуваарилсныг мэдэж болох бөгөөд энэ нь системийг монитор 
	хийх боломжийг олгодог. Мөн энэ арга нь хэрэглэгчдийн тушаалуудыг туйлын 
	багаар  мөшгих боломжийг администраторуудад олгодог.</para>

    <para>Энэ нь үнэн хэрэгтээ өөрийн эерэг болон сөрөг талуудтай. Эерэг талуудын нэг нь 
	халдлагыг орсон цэг хүртэл нарийсган олох боломж юм. Сөрөг тал нь процессийн 
	бүртгэл хөтлөлтөөр үүссэн бүртгэлүүд бөгөөд тэдгээр нь дискний зай шаардаж 
	болох юм. Энэ хэсэг процессийн бүртгэл хөтлөлтийн үндсүүдийг администраторуудад 
	таниулах болно.</para>

    <sect2>
      <title>Процессийн бүртгэл хөтлөлтийг идэвхжүүлж хэрэглэх нь</title>
      <para>Процессийн бүртгэл хөтлөлтийг ашиглаж эхлэхээсээ өмнө үүнийг идэвхжүүлэх 
	хэрэгтэй. Үүнийг хийхийн тулд дараах тушаалуудыг ажиллуул:</para>

      <screen>&prompt.root; <userinput>touch <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>accton <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; <filename>/etc/rc.conf</filename></userinput></screen>

      <para>Идэвхтэй болгосны дараа бүртгэл хөтлөлт <acronym>CPU</acronym> 
	статистикууд, тушаалууд гэх мэтийг даган мөшгиж эхэлнэ. Бүртгэлийн 
	бүх бичлэгүүд уншиж болохооргүй хэлбэрээр байдаг бөгөөд тэдгээрийг 
	&man.sa.8; хэрэгсэл ашиглан үзэж болдог. Ямар нэг тохируулгагүйгээр 
	ажиллуулбал <command>sa</command> тушаал нь хэрэглэгч болгоны 
	дуудлагуудын тоо, нийт зарцуулсан хугацааг минутаар, нийт <acronym>CPU</acronym> 
	болон хэрэглэгчийн хугацааг минутаар, дундаж I/O үйлдлүүдийн тоо 
	гэх мэттэй холбоотой мэдээллийг дэлгэцэнд хэвлэн үзүүлдэг.</para>

      <para>Тушаалуудыг ашигласан тухай мэдээллийг харахын тулд &man.lastcomm.1; 
	хэрэгслийг ашиглах хэрэгтэй. <command>lastcomm</command> тушаал нь 
	тухайн &man.ttys.5; дээр хэрэглэгчдийн ажиллуулсан тушаалуудыг 
	үзүүлэхэд хэрэглэгдэж болно, жишээ нь:</para>

      <screen>&prompt.root; <userinput>lastcomm ls
	<username>trhodes</username> ttyp1</userinput></screen>

      <para>Дээрх тушаал нь <literal>ttyp1</literal> терминал дээр <username>trhodes</username> 
	хэрэглэгчийн <command>ls</command> тушаал ашигласан мэдэгдэж байгаа 
	бүгдийг дэлгэцэд харуулах болно.</para>

      <para>Өөр олон ашигтай тохируулгууд байдаг бөгөөд &man.lastcomm.1;, 
	&man.acct.5; болон &man.sa.8; гарын авлагын хуудаснуудад тайлбарласан 
	байдаг.</para>
    </sect2>
  </sect1>  
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
