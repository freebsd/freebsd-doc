<!--
     The FreeBSD Mongolian Documentation Project

     Original revision 1.159

     $FreeBSD$
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Крис</firstname>
	<surname>Шамвэй</surname>
	<contrib>Дахин бичсэн </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Шагдарын</firstname>
	<surname>Нацагдорж</surname>
	<contrib>Орчуулсан </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>Юниксийн үндэс</title>
  
  <sect1 id="basics-synopsis">
    <title>Ерөнхий агуулга</title>

   <para>Дараах бүлгүүд нь FreeBSD үйлдлийн системийн үндсэн
	тушаал мөн гүйцэтгэлүүдийг хамрах болно. Энэ материалын
	ихэнх хэсэг нь &unix;-төрлийн үйлдлийн системтэй хамаатай. 
	Хэрэв та юникс төрлийн үйлдлийн системтэй танил бол энэ бүлгийг
	алгасаж болно. Харин та FreeBSD-г шинээр сурагч бол энэ бүлгийг
	тун анхааралтай унших хэрэгтэй.</para>

    <para>Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:</para>

    <itemizedlist>
      <listitem>
        <para>FreeBSD-н <quote>виртуал консолыг</quote> хэрхэн 
		хэрэглэх.</para>
      </listitem>
      <listitem>
	<para>&os; дээрх файлын тугийг ойлгосноор &unix;-н файлын
	зөвшөөрөл хэрхэн ажилладгийг мэдэх.</para>
      </listitem>
      <listitem>
	<para>Үндсэн &os; файл системийн байрлуулалтыг мэдэх.</para>
      </listitem>
      <listitem>
	<para>&os; диск зохион байгуулалт.</para>
      </listitem>
      <listitem>
	<para>Файл системийг хэрхэн холбох болон салгах.</para>
      </listitem>
      <listitem>
	<para>Процесс, далд чөтгөр дэмон, мөн дохионууд гэж юу болох.</para>
      </listitem>
      <listitem>
	<para>Бүрхүүл гэж юу болох, мөн хэрхэн анхны нэвтрэх орчноо өөрчлөх.</para>
      </listitem>
      <listitem>
	<para>Үндсэн текст засварлагчийг хэрхэн хэрэглэх.</para>
      </listitem>
      <listitem>
	<para>Төхөөрөмж болох төхөөрөмжийн цэг гэж юу болох.</para>
      </listitem>
      <listitem>
	<para>&os;-д ямар хоёртын хэлбэр хэрэглэгддэг болох.</para>
      </listitem>
      <listitem>
	<para>Нэмэлт мэдээллийг товч гарын авлагаас хэрхэн харах.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Виртуал консол болон терминал</title>
    <indexterm><primary>виртуал консол</primary></indexterm>
    <indexterm><primary>терминал</primary></indexterm>

    <para>FreeBSD нь олон аргаар хэрэглэгдэж чадна. Тэдний нэг нь
	тушаалуудыг текст терминал дээр бичиж хэрэглэх юм. Хэрэв та
	FreeBSD-г ингэж хэрэглэвэл, &unix;-н маш олон боломж болон
	хүч таны	гарт байна гэсэн үг. 
        Энэ бүлэг танд, <quote>терминал</quote> болон <quote>консол</quote> гэж юу болох, мөн тэд нарыг FreeBSD дээр хэрхэн хэрэглэх талаар
	танд тодорхойлж өгөх болно.</para>

    <sect2 id="consoles-intro">
      <title>Консол</title>
      <indexterm><primary>консол</primary></indexterm>

      <para>Хэрэв та FreeBSD-г эхлэх үедээ автоматаар график горимд
	эхлүүлэхээр тохируулаагүй бол, систем нь эхлэлтийн гүйцэтгэдэг
	бичиглэлүүдээ дуусгасны дараа танд нэвтрэх хуудас харуулдаг. 
	Та нэг иймэрхүү хуудас харах байх:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Энд харуулсан текстүүд нь таны систем дээр жаахан
	өөр байж магадгүй ч, ерөнхийдөө үүнтэй ижил байх ёстой. 
	Сүүлийн хоёр мөр нь бидэнд одоогоор чухал мөрүүд. Сүүлээсээ
	хоёр дахь мөр нь ингэж уншигдаж байна:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Энэ мөр нь таны дөнгөж сая эхлүүлсэн системийн тухай
	товч мэдээллийг агуулсан байна. Та x86 архитектуртай тохиромжтой
	Интел юм уу тохирох систем дээр ажиллаж буй <quote>FreeBSD</quote>
	консолыг харж байна <footnote>
	  <para><literal>i386</literal> гэдэг нь үүнийг илэрхийлж байгаа юм. Тэмдэглэж хэлэхэд, хэрэв та FreeBSD-г Интел 386 процессор дээр
	ажиллуулаагүй байсан ч энэ нь <literal>i386</literal> гэж гарна.  		Энэ нь процессорын төрлийг биш харин процессорын <quote>архитектурыг </quote> харуулж байгаа юм.</para>
	</footnote>.  Энэ машины нэр нь (&unix; машин болгон 
	өөрийн нэртэй ) <hostid>pc3.example.org</hostid>, бөгөөд 
	та энэ системийн консолын &mdash; <devicename>ttyv0</devicename>
	нэртэй терминалыг харж байна.</para>

      <para>Эцэст нь, сүүлийн мөр бол үргэлж:</para>

      <programlisting>login:</programlisting>

      <para>Энэ хэсэг нь, таны FreeBSD уруу нэвтрэх 
	<quote>хэрэглэгчийн-нэрээ</quote> бичдэг хэсэг.  Дараагийн 
	хэсэгт энэ талаар тодорхойлсон байгаа.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>FreeBSD уруу нэвтрэх</title>

      <para>FreeBSD бол олон хэрэглэгчийн бас олон үйлдлийн систем.
	Энэ нь, нэг машин уруу олон хүмүүс зэрэг холбогдож 
	нэгэн зэрэг олон үйлдэл хийж болдог системийн ерөнхий тодорхойлолт
	юм. </para>

      <para>Олон хэрэглэгчийн систем нь ямар нэгэн аргаар нэг 
	<quote>хэрэглэгчийг</quote> бусдаас нь ялгаж чаддаг байх ёстой.  
	FreeBSD дээр (мөн бусад &unix;-төрлийн системүүд дээр) энэ нь,
	хэрэглэгч ямар нэгэн програм ажиллуулахаасаа өмнө систем уруу
	 <quote>нэвтрэх үйлдэл</quote> хийж хэрэгждэг. Хэрэглэгч бүрд
	гоц нэр  (
	<quote>хэрэглэгчийн-нэр</quote>) мөн хувийн нууц үг (
	<quote>нууц-үг</quote>) харгалзах ёстой. Хэрэглэгчийг програм
	хэрэглэж эхлэхээс өмнө FreeBSD энэ хоёрыг асуух болно.</para>

      <indexterm><primary>эхлэлийн бичлэг</primary></indexterm>
      <para>Дөнгөж FreeBSD эхлэх үедээ эхлүүлэгч бичлэгүүдийг 
	<footnote>
	  <para>Эхлэх бичлэгүүд гэдэг нь 
	    FreeBSD эхлэх үед автоматаар ажилладаг програмууд. Тэдгээрийн
	үндсэн үүрэг нь, ажиллах ёстой програмуудыг тохируулах, мөн хэрэв 		ар талд далд ажилладаг ямар нэгэн үр ашигтай үйлдэл хийж байдаг 
	таны тохируулсан үйлчилгээнүүд байвал тэднийг
	эхлүүлэх	зэрэг үйлдлүүд юм. </para>
	</footnote> гүйцэтгэж дуусаад танаас зөв 
	хэрэглэгчийн нэр оруулахыг лавлаж асууна:</para>

      <screen>login:</screen>

      <para>Энэ жишээнд зориулаад бүгдээрээ таны хэрэглэгчийн нэрийг 
	<username>john</username> гэж бодоцгооё.  Лавлаж асуусан
	мөрөнд <literal>john</literal> гэж бичээд
	<keycap>Enter</keycap> товч дарна. Ингээд дараа нь танаас
	<quote>password</quote> гэж нууц үг асуух болно:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para><username>john</username>-ны нууц үгийг оруулаад
	<keycap>Enter</keycap> товч дарна.  Нууц үгийг <emphasis>танд 
	харуулдаггүй!</emphasis>  Энэ талаар та одоохондоо санаагаа
	зовоох хэрэггүй. Нууцлалын шалтгаанаар ингэж байгаа юм гэж 
	хэлэхэд хангалттай.</para>

      <para>Хэрэв та нууц үгээ зөв оруулсан бол ингээд FreeBSD 
	уруу нэвтрэх бөгөөд боломжтой бүх програмуудыг туршиж болохоор
	боллоо.</para>

      <para>Та <acronym>MOTD</acronym> эсвэл тухайн өдрийн мэдээллийг
	тушаал бичигчийн араас харах болно ( тушаал бичигч нь 
	<literal>#</literal>,
	<literal>$</literal>, эсвэл <literal>%</literal> гэсэн
	 тэмдэгтүүдийн нэг нь байдаг).  Энэ нь таныг FreeBSD уруу
	амжилттай нэвтэрснийг илэрхийлдэг.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Олон консолууд</title>

      <para>&unix; тушаалуудыг нэг консол дээр гүйцэтгэх нь ердийнх, 	гэхдээ FreeBSD олон програмыг нэг дор ажиллуулж чадна. FreeBSD
	олон програмыг нэг дор нэг цагт ажиллуулж чадаж байхад, нэг консол
	дээр олон тушаал өгч суух нь цаг алдахын л нэмэр. Ийм үед л
	<quote>виртуал консолын</quote> тусламж хэрэг болдог.</para>

      <para>FreeBSD нь танд олон төрлийн виртуал консол хэрэглүүлэхээр
	тохируулагдаж чаддаг. Нэг виртуал консолоос нөгөөх уруу нь 
	гарын хэдхэн товчлуур дараад л шилжиж болдог. Консол бүр өөрийн
	төрөл  бүрийн гаралтын сувагтай бөгөөд FreeBSD нь таныг нэг
	консолоос нөгөө консол уруу сэлгэх үед гарын оруулга болон дэлгэцийн
	гаралтыг тухайн консолд тохируулж дамжуулж өгдөг.</para>

      <para>Гарын тусгай товчлолууд нь FreeBSD дээр консол сэлгэхэд зориулж
	нөөцлөгдсөн байдаг <footnote>
	  <para>FreeBSD консол мөн гарын тохируулгын тухай нэлээн 
		дэлгэрэнгүй техникийн мэдээллийг та 
	    	&man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1;
	    мөн &man.kbdcontrol.1; зэрэг гарын авлагуудаас харж болно. Бид
	нар энд задалж нарийвчлахгүй бөгөөд сонирхсон хүмүүс нь гарын 		авлагуудаас хэрхэн ажилладаг заавар тайлбарыг уншиж болно.</para>
	</footnote>.  Та
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, аас
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> хүртэлх товчлуурыг дарж FreeBSD дээр консолуудын хооронд шилжиж болно.</para>

      <para>Таныг нэгээс нөгөөх уруу нь шилжих үед, FreeBSD таны дэлгэцийн
	гаралтыг хадгалж санаа тавьдаг.  Ингэсний үр дүнд гарнаас 		тушаал оруулж програмуудыг 
	ажиллуулж болдог маш олон 	<quote>виртуал</quote> дэлгэцүүдтэй
	мэт үзэгддэг.  Нэг виртуал консол дээр таны ажиллуулсан програм нь 		уг консолоос сэлгээд өөр консол дээр сэлгэсэн ч гэсэн зогсохгүй
	ажиллаж л байдаг. </para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title> <filename>/etc/ttys</filename> Файл</title>

      <para>FreeBSD анхны тохируулгаараа найман виртуал 
	консолтой эхэлдэг. Энэ нь хатуу тогтоосон тохируулга биш бөгөөд
	хэрэв та хүсвэл олон юм уу цөөн болгож амархан өөрчлөх боломжтой.  		Виртуал консолын тоо болон тохируулга нь 
        <filename>/etc/ttys</filename> файлд байдаг.</para>

      <para>Та <filename>/etc/ttys</filename> файлыг хэрэглэж FreeBSD
	дээрх виртуал консолуудыг тохируулж болно. Энэ файлын тайлбар
	тавиагүй мөр болгон 
	( <literal>#</literal> тэмдгээр эхлээгүй мөрүүд) виртуал 
	консол эсвэл ганц терминалын тохируулгыг агуулж байдаг.  
	Энэ файл FreeBSD-тэй анх цуг ирэхдээ есөн виртуал
	консолтой гэж тохируулагдаж ирдэг бөгөөд тэдний наймыг нь 
	хэрэглэж болохыг зөвшөөрсөн байдаг. Тэдгээр нь 
	<literal>ttyv</literal> гэж эхэлсэн байдаг:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Виртуал консолыг тохируулдаг энэ файлын баганууд
	 мөн нэмэлт сонголтуудын  дэлгэрэнгүй
	тайлбарыг та &man.ttys.5; гарын авлагаас харна уу.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Ганц хэрэглэгчийн горимын консол</title>

      <para><quote>Ганц хэрэглэгчийн горим</quote> гэж юу болох талаар 	дэлгэрэнгүй мэдээлэл <xref linkend="boot-singleuser">-д буй. 
	 FreeBSD дээр ганц хэрэглэгчийн горимд ажиллаж байхад
	зөвхөн нэг консол байдаг гэдгийг мэдэх хэрэгтэй. Энэ үед
	ямар ч виртуал консолууд боломжгүй. Ганц хэрэглэгчийн
	горимын тохируулгыг бас <filename>/etc/ttys</filename> файл
	дотор хийж болно. <literal>console</literal> гэж эхэлсэн
	мөрүүдийг харна уу:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para>Дээрх <literal>console</literal> гэсэн мөрний
	дээд хэсэгт бичсэн тайлбарт бичсэний дагуу та <literal>secure</literal> гэдгийг 
	  <literal>insecure</literal> гэж өөрчилж болно. Хэрэв та ингэвэл,
	FreeBSD ганц хэрэглэгчийн горимд эхэлсэн ч гэсэн танаас
	  <username>root</username> нууц үг асуух болно.</para>

	<para><emphasis>Үүнийг 
	  <literal>insecure</literal> гэж солихдоо та тун болгоомжтой
	байх хэрэгтэй</emphasis>.  Хэрэв та хэзээ нэгэн цагт
	  <username>root</username> нууц үгээ мартаад ганц хэрэглэгчийн 		
	горимд орвол жаахан хүндрэлтэй байх болно. Энэ нь гэхдээ шийдэж 		
	болохоор хүндрэл боловч FreeBSD-н эхлэх үйлдэл болон хамрагдсан
	програмуудад нь дасаагүй хүнд бол жаахан хүндрэлтэй байж магадгүй.</para>
      </note>
    </sect2>

    <sect2 id="consoles-vidcontrol">
      <title>Консолын Видео горимуудыг өөрчлөх нь</title>

      <para>FreeBSD-ийн консолын анхдагч видео горимыг 1024x768, 
	1280x1024, эсвэл таны график бичил схем болон дэлгэц дэмжиж 
	чадах дурын хэмжээгээр тохируулж болох юм. Өөр видео горимыг 
	ашиглахын тулд та эхлээд өөрийн цөмөө дахин эмхэтгэж хоёр нэмэлт 
	тохируулгыг оруулах хэрэгтэй:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>Цөм эдгээр хоёр тохируулгатай дахин эмхэтгэгдсэний дараа 
	таны тоног төхөөрөмж ямар видео горимуудыг дэмждэгийг 
	&man.vidcontrol.1; хэрэгсэл ашиглан та тодорхойлж болно. 
	Дэмжигдсэн видео горимуудын жагсаалтыг авахын тулд доор дурдсан 
	тушаалыг бичнэ:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Энэ тушаалын үр дүн нь таны тоног төхөөрөмжийн дэмждэг 
	видео горимуудын жагсаалт байх болно. Та дараа нь 
	<username>root</username> консол дээр шинэ 
	видео горимыг сонгон &man.vidcontrol.1; уруу өгч болно:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Хэрэв шинэ видео горим боломжийн бол 
	<filename>/etc/rc.conf</filename> файлд 
	ачаалахад үүнийг үргэлж сонгодог байхаар тохируулж 
	болно:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Зөвшөөрлүүд</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD нь BSD &unix;-ээс уламжилж байх үедээ, &unix;-н
	үндсэн хэдэн бүтэц дээр суурилсан.  Эхний бөгөөд хамгийн
	чухал тунхаглал нь FreeBSD бол олон хэрэглэгчийн
	үйлдлийн систем юм.
      Систем нь олон хэрэглэгчийн хоорондоо хамааралгүй олон үйлдлийг
	ачаалж чаддаг.  Хэрэглэгч болгонд шаардагдах компьютерийн 		төхөөрөмж, санах ой мөн процессорын давтамжийг зөв шударга 
	хуваарилахыг систем хариуцдаг.</para>

    <para>Систем олон хэрэглэгчтэй ажиллах болохоор, системийн 
	хийх ёстой зүйл нь хэн тухайн нөөцийг унших, бичих, 		  
	гүйцэтгэх вэ гэдгийг зохицуулах юм. Эдгээр зөвшөөрлүүд нь
	гурав гурваараа нийлүүлэгдсэн гурван хэсэг тоо байдаг. Нэг нь
	файлын эзэмшигчид, нөгөөх нь файлын хамаарагддаг бүлэгт, үлдсэн нь
	хүн болгонд гэж хуваарилагдана. Энэ тоон дараалал нь дараах
	маягаар ажилладаг.:</para>

    <indexterm><primary>зөвшөөрөл</primary></indexterm>
    <indexterm>
      <primary>файлын зөвшөөрөл</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Утга</entry>
	    <entry>Зөвшөөрөл</entry>
	    <entry>Жагсаах харуулалт</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Уншигдахгүй, бичигдэхгүй, гүйцэтгэгдэхгүй</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Уншигдахгүй, бичигдэхгүй, гүйцэтгэгдэнэ</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Уншигдахгүй, бичигдэнэ, гүйцэтгэгдэхгүй</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Уншигдахгүй, бичигдэнэ, гүйцэтгэгдэнэ</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Уншигдана, бичигдэхгүй, гүйцэтгэгдэхгүй</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Уншигдана, бичигдэхгүй, гүйцэтгэгдэнэ</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Уншигдана, бичигдэнэ, гүйцэтгэгдэхгүй</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Уншигдана, бичигдэнэ, гүйцэтгэгдэнэ</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>сангууд</primary></indexterm>

    <para>Та &man.ls.1; тушаалыг <option>-l</option> сонголттой
	хэрэглэж файлын эзэмшигч, бүлэг, мөн хүн болгонд хуваарилсан
	зөвшөөрлийг харуулсан баганатай дэлгэрэнгүй мэдээллийг харж
	болно. Жишээлбэл, 
      <command>ls -l</command> тушаалыг нэг сан дотор гүйцэтгэвэл дараах маягаар харагдана:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Энд <command>ls -l</command> тушаалын эхний баганыг авч үзье:</para>

    <screen>-rw-r--r--</screen>

    <para>Хамгийн эхний (зүүн талын) тэмдэг нь үүнийг ердийн файл
	юм уу, эсвэл сан, онцгой тэмдэг төхөөрөмж, сокет, эсвэл ямар 
	нэгэн холбоост файл мөн эсэхийг илэрхийлдэг. Энэ тохиолдолд
	<literal>-</literal> нь ердийн файлыг зааж байна.
       Дараагийн гурван тэмдэгт  
      <literal>rw-</literal> нь энэ тохиолдолд энэ файлын эзэмшигчид 
	зөвшөөрөл өгч байна. Дараагийн гурван тэмдэгт  <literal>r--</literal> нь файлын хамаарах бүлэгт эрх өгч байна. 
	Сүүлийн гурван тэмдэгт  <literal>r--</literal> нь бусад бүх хүмүүст
	эрх өгч байна.  Зураас нь зөвшөөрөл өгөөгүйг
	 илэрхийлдэг. Энэ файлын тохиолдолд, файлыг унших бичих эрхийг 	эзэмшигчид нь өгөөд, бүлэг нь файлыг унших эрхтэй, бусад хүмүүс
	энэ файлыг зөвхөн унших эрхтэй гэж заагдсан байна.  
	Дээр тайлбарласан хүснэгтийн дагуу, энэ файлын зөвшөөрөл нь 	
      <literal>644</literal> гэж дээрх гурван төрөлд заагдаж байна.</para>

    <para>Энэ бол сайн бөгөөд сайхан хэрэг, гэхдээ төхөөрөмж рүү хандах
	зөвшөөрлийг систем яаж хянах вэ? FreeBSD бараг ихэнх 
	төхөөрөмжийг нээж уншиж өгөгдөл бичдэг файл мэт хандаж уншиж 
	бичдэг. Тэдгээр онцгой төхөөрөмжүүд нь 
      <filename>/dev</filename> сан дотор байрладаг.</para>

    <para>Сангууд ч гэсэн бас файл мэт хандагддаг. Тэд нарт бас
	уншигдах, бичигдэх, гүйцэтгэгдэх зөвшөөрлүүд байдаг.
	Сангийн гүйцэтгэгдэх тэмдэг нь файлаас арай өөрөөр хэрэгждэг.
	Хэрэв сан нь гүйцэтгэгдэнэ гэж тэмдэглэгдсэн бол, энэ сан нь
	дамжиж өнгөрүүлэгдэж болох буюу <quote>cd</quote> тушаалыг 
	(сан сольдог) хэрэглэж ийшээ орж болно гэсэн үг. Энэ нь мөн 
	сан дотор харагдаж байгаа файлууд уруу хандаж болно гэсэн үг. 		(бас нэг зүйл, мэдээжээр, файлууд бас өөр дээрээ зөвшөөрөл агуулсан байгаа).</para>

    <para>Ерөнхийдөө бол, сан доторх файлуудыг жагсааж харахыг хүсвэл,
	уг санд уншигдах зөвшөөрөл суугдсан байх ёстой. Хэрэв санд байгаа
	файлыг устгана гэвэл бичигдэх
      <emphasis>болон</emphasis> гүйцэтгэгдэх зөвшөөрлүүд уг санд
      суугдах ёстой.</para>

    <para>Мөн нэмээд хэдэн зөвшөөрлийн битүүд байдаг, гэхдээ тэдгээр нь
	ажилладаг файлын setuid дугаар болон sticky сан зэрэг тусгай
	 зориулалтаар хэрэглэгддэг. Файлын зөвшөөрлийн талаар
	нэмэлт мэдээлэл авахыг хүсвэл &man.chmod.1; гарын авлага
	хуудаснаас хараарай.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Том</firstname>
	    <surname>Рөүдс</surname>
	    <contrib>Хамтарч бичсэн </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Тэмдэгт зөвшөөрлүүд</title>
      <indexterm><primary>зөвшөөрлүүд</primary><secondary>үсгэн</secondary></indexterm>

      <para>Сан эсвэл файлд тоон утганы оронд заримдаа тэмдгэн зөвшөөрлийг
	хэрэглэдэг.  Тэмдгэн зөвшөөрлийг бичихдээ (хэн) (үйлдэл)
	(зөвшөөрөл) гэсэн дарааллаар бичих бөгөөд дараах утгуудыг авдаг:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Сонголт</entry>
	      <entry>Үсэг</entry>
	      <entry>Илэрхийлэл нь</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(хэн)</entry>
	    <entry>u</entry>
	    <entry>Хэрэглэгч</entry>
	  </row>

	  <row>
	    <entry>(хэн)</entry>
	    <entry>g</entry>
	    <entry>Бүлгийн эзэмшигч</entry>
	  </row>

	  <row>
	    <entry>(хэн)</entry>
	    <entry>o</entry>
	    <entry>Бусад</entry>
	  </row>

	  <row>
	    <entry>(хэн)</entry>
	    <entry>a</entry>
	    <entry>Бүгд (<quote>ертөнц</quote>)</entry>
	  </row>

	  <row>
	    <entry>(үйлдэл)</entry>
	    <entry>+</entry>
	    <entry>Зөвшөөрөл нэмэх</entry>
	  </row>

	  <row>
	    <entry>(action)</entry>
	    <entry>-</entry>
	    <entry>Зөвшөөрлийг устгах</entry>
	  </row>

	  <row>
	    <entry>(үйлдэл)</entry>
	    <entry>=</entry>
	    <entry>зөвхөн тухайн зөвшөөрлийг суулгах</entry>
	  </row>

	  <row>
	    <entry>(зөвшөөрөл)</entry>
	    <entry>r</entry>
	    <entry>Унших</entry>
	  </row>

	  <row>
	    <entry>(зөвшөөрөл)</entry>
	    <entry>w</entry>
	    <entry>Бичих</entry>
	  </row>

	  <row>
	    <entry>(зөвшөөрөл)</entry>
	    <entry>x</entry>
	    <entry>Гүйцэтгэх</entry>
	  </row>

	  <row>
	    <entry>(зөвшөөрөл)</entry>
	    <entry>t</entry>
	    <entry>Sticky бит</entry>
	  </row>

	  <row>
	    <entry>(зөвшөөрөл)</entry>
	    <entry>s</entry>
	    <entry>UID эсвэл GID суулгах</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Эдгээр утгууд нь өмнөх жишээ шиг &man.chmod.1; тушаалтай 
	хэрэглэгддэг бөгөөд гэхдээ үсэг хэрэглэнэ.  Жишээлбэл, та      
      <replaceable>FILE</replaceable> уруу бусад хэрэглэгчид
	хандахыг хориглохдоо:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Файлд нэгээс олон өөрчлөлт хийх шаардлага гарвал таслалаар
	тусгаарласан мөр бичиж болно. Жишээлбэл, дараах тушаал нь
	бүлэг болон <quote>дэлхийг</quote> <replaceable>FILE</replaceable> дээр бичих эрхийг нь аваад дараа нь хүн болгонд гүйцэтгэж
	болно гэсэн эрх өгч байна:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Том</firstname>
	    <surname>Рөүдс</surname>
	    <contrib>Хамтран бичсэн </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>&os; файлын туг</title>

      <para>Өмнө ярилцсан файлын зөвшөөрлөөс гадна &os; нь
	<quote>файлын туг</quote> хэрэглээгээр хангагдсан байдаг. Эдгээр туг
	нь файлд нэмэлт нууцлалын болон хяналтын түвшин тогтоож өгдөг, гэхдээ
	санд бол үгүй.</para>

      <para>Эдгээр файлын тугнууд нь файлд нэмэлт түвшний хяналт тогтоож
	өгснөөрөө зарим тохиолдолд 
	<username>root</username> хэрэглэгч хүртэл файлыг устгах 
	юм уу өөрчилж чадахгүй болгож тусалдаг.</para>

      <para>Файлын тугнууд нь энгийн загвартай &man.chflags.1; 
	багажаар ашиглагддаг. Жишээлбэл,  
	<filename>file1</filename> файл дээр устгагдахгүй гэсэн
	туг хатгахыг системд зөвшөөрүүлэхийн тулд дараах тушаалыг гүйцэтгэнэ:</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>file1</filename></userinput></screen>

      <para>Хэрэв устгагдахгүй тугийг буцааж авна гэвэл өмнөх тушаал дээрээ
	<option>sunlink</option>-ын өмнө <quote>no</quote> залгаж
	 ажиллуулна:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>file1</filename></userinput></screen>

      <para>Энэ файлын тугийг харахын тулд &man.ls.1; тушаалыг
	<option>-lo</option> сонголттой хамт ажиллуулна:</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>file1</filename></userinput></screen>

      <para>Тушаалын гаралт нь дараах маягаар харагдах ёстой:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Нэлээн хэдэн тугнууд нь файлд зөвхөн 
	<username>root</username> хэрэглэгчээр нэмэгдэж устгагдана.
	Бусад тохиолдолд файлын эзэмшигч нь тугийг суулгах боломжтой.
	Администраторуудыг &man.chflags.1; болон &man.chflags.2; гарын 
	авлагуудыг уншихыг зөвлөж байна.</para>
    </sect2>
  
    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Том</firstname>
	    <surname>Рөүдс</surname>
	    <contrib>Хувь нэмэр болгон оруулсан </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>setuid, setgid, болон sticky буюу наалдамхай зөвшөөрлүүд</title>

      <para>Өмнө хэлэлцсэн зөвшөөрлүүдээс гадна бүх администраторуудын 
	мэдэх ёстой өөр гурван тусгай тохиргоо байдаг. Эдгээр нь 
	<literal>setuid</literal>, <literal>setgid</literal> 
	болон <literal>sticky</literal> буюу наалдамхай 
	зөвшөөрлүүд юм.</para>

      <para>Эдгээр тохиргоонууд нь ерөнхийдөө энгийн хэрэглэгчдэд зөвшөөрөгддөггүй 
	ажиллагаагаар хангадаг бөгөөд &unix;-ийн зарим нэг үйлдлүүдэд чухал байдаг. 
	Эдгээрийг ойлгохын тулд жинхэнэ хэрэглэгчийн ID болон хүчинтэй хэрэглэгчийн 
	ID-ийн ялгааг дурдах хэрэгтэй.</para>

      <para>Жинхэнэ хэрэглэгчийн ID нь процессийг эзэмшдэг юм уу эсвэл 
	процессийг эхлүүлдэг <acronym>UID</acronym> юм. Хүчинтэй хэрэглэгчийн 
	<acronym>UID</acronym> нь процессийн ажиллаж байгаа тэр хэрэглэгчийн 
	ID юм. Жишээ нь &man.passwd.1; хэрэгсэл нь хэрэглэгч өөрсдийн нууц үгээ 
	сольж байгаа болохоор жинхэнэ хэрэглэгчийн ID-аар ажиллах боловч 
	нууц үгийн санд өөрчлөлт хийхийн тулд <username>root</username> 
	хэрэглэгчийн хүчинтэй ID-аар ажилладаг. Ингэснээр энгийн хэрэглэгчдэд 
	<errorname>Permission Denied</errorname> буюу зөвшөөрөл хаалттай 
	гэсэн алдааг харуулалгүйгээр өөрсдийн нууц үгсийг солих боломжийг 
	олгодог.</para>

      <note>
	<para><literal>nosuid</literal> &man.mount.8; тохиргоо нь 
	  эдгээр хоёртын файлуудыг дуугай амжилтгүй болоход хүргэдэг. 
	  Энэ нь хэрэглэгчдэд мэдэгдэлгүйгээр ажиллагаа амжилтгүй болно 
	  гэсэн үг юм. &man.mount.8; гарын авлагын дагуу энэ тохиргоо нь 
	  <literal>nosuid</literal> гүйцэтгэл хялбаршуулагчийн хамгаалж болох шиг 
	  бүрэн найдвартай бас биш юм.</para>
      </note>

      <para>setuid зөвшөөрлийг зөвшөөрлийн цуглуулгын өмнө 
	дөрвийн тоог (4) доорх жишээн дээрх шигээр тавьж 
	тохируулж болно:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para><filename><replaceable>suidexample.sh</replaceable></filename> 
	файл дээрх зөвшөөрлүүд нь одоо доорх шиг харагдах ёстой:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>Энэ жишээн дээр <literal>s</literal> нь ажиллуулах битийг 
	сольж файлын эзэмшигчид зориулсан зөвшөөрлүүдийн цуглуулгын хэсэг 
	болж байгаа нь харагдах ёстой. Энэ нь <command>passwd</command> 
	зэрэг дээшлүүлсэн зөвшөөрлүүдийг шаарддаг хэрэгслүүдийг 
	зөвшөөрдөг.</para>

      <para>Жинхнээр нь үүнийг харахын тулд хоёр терминал нээ. Нэг дээр нь 
	энгийн хэрэглэгчээр <command>passwd</command> процессийг 
	эхлүүл. Шинэ нууц үг хүлээж байхад нь процессийн хүснэгтийг 
	шалгаад <command>passwd</command> тушаалын хэрэглэгчийн 
	мэдээллийг хар.</para>

      <para>Терминал A дээр:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>Терминал B дээр:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Дээр харуулснаар <command>passwd</command> нь 
	энгийн хэрэглэгчээр ажиллаж байгаа боловч <username>root</username> 
	хэрэглэгчийн хүчинтэй <acronym>UID</acronym> ашиглаж байна.</para>

      <para><literal>setgid</literal> зөвшөөрөл нь <literal>setuid</literal> 
	зөвшөөрөлтэй адил үүргийг гүйцэтгэдэг, гэхдээ бүлгийн тохиргоог 
	өөрчилдөг. Програм юм уу эсвэл хэрэгсэл нь энэ тохиргоотойгоор ажиллахдаа 
	процессийг эхлүүлсэн хэрэглэгч биш файлыг эзэмшиж байгаа бүлэг дээр 
	тулгуурласан зөвшөөрлүүдийг олгодог.</para>

      <para>Файл дээр <literal>setgid</literal> зөвшөөрлийг тохируулахдаа 
	дараах жишээн дээрх шиг <command>chmod</command> тушаалыг өмнөө 
	хоёртой (2) өгнө:</para>

	  <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Шинэ тохиргоог өмнөх шигээ харж болох бөгөөд 
	<literal>s</literal> нь одоо бүлгийн зөвшөөрлийн тохиргоонд 
	зориулагдсан талбарт байгааг анхаараарай:</para>

	  <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
	<para>Эдгээр жишээнүүд дээр бүрхүүлийн скрипт нь хэдийгээр 
	  ажиллах боломжтой файл боловч өөр <acronym>EUID</acronym> 
	  буюу хүчинтэй хэрэглэгчийн ID-аар ажиллахгүй. 
	  Энэ нь яагаад гэвэл бүрхүүлийн скрипт нь &man.setuid.2; 
	  системийн дуудлагуудад хандаж чадахгүйтэй холбоотой юм.</para>
      </note>

      <para>Бидний хэлэлцсэн эхний хоёр тусгай зөвшөөрлийн битүүд нь 
	(<literal>setuid</literal> болон <literal>setgid</literal>
	зөвшөөрлийн битүүд) дээшлүүлсэн зөвшөөрлүүдийг зөвшөөрч системийн 
	аюулгүй байдлыг доошлуулж болох юм. Системийн аюулгүй байдлыг 
	чангатгаж чадах гурав дахь тусгай зөвшөөрлийн бит байдаг нь 
	<literal>sticky bit</literal> буюу наалдамхай бит юм.</para>

      <para><literal>sticky bit</literal> нь санд тавигдсан үед 
	файл устгалтыг зөвхөн файлыг эзэмшигчид зөвшөөрдөг. Энэ 
	зөвшөөрлийн цуглуулга нь 
	<filename class="directory">/tmp</filename> 
	зэрэг нийтийн сангаас файлыг эзэмшдэггүй хэрэглэгч уг файлыг устгахаас 
	хамгаалахад ашиг тустай байдаг. Энэ зөвшөөрлийг ашиглахын тулд 
	зөвшөөрлийн урд нэгийг (1) тавьж өгнө. Жишээ нь:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Одоо үр дүнг <command>ls</command> тушаал ашиглан 
	харах боломжтой:</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

      <para><literal>sticky bit</literal> буюу наалдамхай бит зөвшөөрөл нь 
	цуглуулгын хамгийн сүүлд байгаа <literal>t</literal>-ээс ялгаатай 
	юм.</para>
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>Сангийн бүтэц</title>
    <indexterm><primary>сангийн зохион байгуулалт</primary></indexterm>

    <para>FreeBSD ийн сангийн бүтэц нь уг системийг ойлгоход тун
	чухал үүрэг гүйцэтгэнэ. Хамгийн чухал бөгөөд үндсэн
	ойлголт бол root буюу хамгийн дээд эх сан 
      <quote>/</quote> юм.  Энэ сан нь систем эхлэх үед хамгийн 
	түрүүнд танигдах ёстой бөгөөд олон хэрэглэгчид зориулсан
	үйлдлийн системийг бэлдэхэд чухал үүрэгтэй.  Энэ дээд эх сан
	нь олон хэрэглэгчийн ажиллагаанд шилжих үед холбогдох бусад файлын системүүдийн 
	холболтын цэгүүдийг бас агуулж байдаг.</para>

    <para>Холболтын цэг нь үндсэн файл систем уруу (ихэвчлэн эх root файл систем) нэмэлт файлын системүүдийг холбож
	нэмдэг цэг юм.
      Энэ тухай цаашид <xref linkend="disk-organization">-д тайлбарласан
	байгаа.
      Үндсэн холбох цэгүүд нь
      <filename>/usr</filename>, <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename>, мөн <filename>/cdrom</filename>
	сангуудыг агуулж байдаг. 
	Эдгээр сангууд нь голдуу 
      <filename>/etc/fstab</filename> файлд заагдсан байдаг.  <filename>/etc/fstab</filename> файл нь төрөл бүрийн файл системүүдийг
	системд ойлгуулах гэж бичсэн хүснэгт бичлэг. 
	<filename>/etc/fstab</filename> файлд байгаа ихэнх файл
	системүүд компьютер эхэлж ачаалагдах үед автоматаар &man.rc.8;
	гүйцэтгэгддэг бичлэгээс таниулагддаг. Гэхдээ хэрэв 
	<option>noauto</option> гэсэн сонголтыг агуулсан бол 
	автоматаар таниулагддаггүй. 
      Дэлгэрэнгүй мэдээлэл <xref linkend="disks-fstab"> хэсэгт буй.</para>

    <para>Файл системийн бүтцийн тухай бүрэн мэдээллийг 
      &man.hier.7;-с харж болно.  Одоохондоо байнга хэрэглэгддэг
	сангуудыг товч тайлбарлахад хангалттай.</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Сан</entry>
	      <entry>Тодорхойлолт</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Файл системийн Root буюу хамгийн дээд эх сан.</entry>
            </row>
	    
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Ганц болон олон хэрэглэгчийн орчны үндсэн
	хэрэгслийн сан.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Үйлдлийн систем эхлэж ачаалагдах үеийн програмууд 			болон тохируулга файлууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Анхдагч ачаалах үеийн тохируулгын файлууд; дэлгэрэнгүйг
	      &man.loader.conf.5; хуудаснаас харна уу.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Төхөөрөмжүүд байдаг сан; &man.intro.4; хуудаснаас харна уу.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Системийн тохируулгын файлууд болон гүйцэтгэх бичлэгүүд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Анхдагч системийн тохируулгын файлууд;  дэлгэрэнгүйг &man.rc.8; хуудаснаас хараарай.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>&man.sendmail.8; мэтийн захиа илгээгчдийн
	тохируулгын файлууд.
	</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry><command>named</command>-н тохируулгын файл; 
	      &man.named.8; хуудаснаас дэлгэрэнгүйг харна уу.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>&man.cron.8;-г ашиглаж өдрөөр, сараар, эсвэл жилээр
	 гэх мэт давтамжаар ажиллаж чаддаг бичлэгүүд	;  дэлгэрэнгүйг &man.periodic.8; хуудаснаас харна уу.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry><command>ppp</command> тохируулга файлууд; 
	      &man.ppp.8;-с харна уу.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Администратор голдуу түр зуур бусад файл систем эсвэл
		төхөөрөмжийг таниулахад хэрэглэдэг хоосон сан.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Процесийн файл систем; &man.procfs.5; болон
	      &man.mount.procfs.8;-с харна уу.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
	      <entry>Эвдэрч гэмтсэн үед сэргээхэд хэрэглэгддэг 
	програмууд &man.rescue.8;-с харна уу.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry><username>root</username> хэрэглэгчийн гэрийн сан.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Ганц болон олон хэрэглэгчийн орчинд хэрэглэж болохоор
	системийн програм ба администраторын үндсэн хэрэгслүүд.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Түр зуурын файлууд.  
		<filename class="directory">/tmp</filename> сан доторх файлууд нь систем шинээр ачаалагдах үед хадгалагдалгүйгээр устгагдана. Санах ойгоос ажилладаг файл системүүд голцуу 
		<filename class="directory">/tmp</filename>
		санд таниулагдаж байрлуулагддаг.
		Энэ үйлдэл нь &man.rc.conf.5;-тай холбоотой  tmpmfs-төрлийг ашиглаж автоматжуулагдаж болдог
		 (эсвэл  <filename>/etc/fstab</filename> дотор буй
		оруулгууд бүгдээрээ; &man.mdmfs.8;-с харна уу).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>Програм болон хэрэглэгчийн хэрэглэдэг үндсэн хэрэгслүүд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Үндсэн хэрэгслүүд, програмын багажууд, мөн програмууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Стандарт C-ийн include файлууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Програмын шахаж бэлдсэн багцууд.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Төрөл бүрийн хэрэгслийн өгөгдлийн файлууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>Системийн далд чөтгөр буюу дэмон болон системийн
	хэрэгслүүд (бусад програмаас дуудагдаж ажилладаг).</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Дотоод гүйцэтгэгддэг болон програмын сангууд гэх мэт програмууд байдаг.  Мөн FreeBSD-н портуудын анхны байрлуулах газар болж өгдөг. <filename>/usr/local</filename> -ийн доторх нь,
	        &man.hier.7;-аар 
	        <filename>/usr</filename> сангийн дотор байгааг байрлуулсан шиг 
		зохион байгуулагдах хэрэгтэй. Гэхдээ энэнд хамаарахгүй
		сангууд нь man гэж <filename>/usr/local/share</filename> сан дотор биш 
	        <filename>/usr/local</filename> дотор байрладаг сан,
		мөн 
	        <filename>share/doc/<replaceable>port</replaceable> 
		</filename> дотор байдаг портуудын бичиг баримт байдаг сан юм.
	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Архитектураасаа хамаараад <filename>/usr/src</filename> санг хөрвүүлэх үед бүтээгддэг сан..</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports/</filename></entry>
	      <entry>FreeBSD Портын цуглуулга (сонгомол).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>Системийн дэмон болон системийн хэрэгслүүд (хэрэглэгчдээр гүйцэтгэгдэнэ).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Архитектуртаа хамаатай файлууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>BSD болон/эсвэл дотоод эх файлууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>X11R6 цогцолборын гүйцэтгэж болдог програмууд, 
		програмын сан зэргүүд
	      (сонгомол).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Олон зорилгоор хэрэглэгддэг бүртгэл бичлэг, түр зуурын, дараалал зэргийн файлууд.
		Санах ойд тулгуурлаж ажилладаг зарим файлын системүүд 
		<filename class="directory">/var</filename> дотор
		танигдаж үүсгэгддэг.
Энэ үйлдэл нь &man.rc.conf.5;-тай холбоотой  varmfs-төрлийг ашиглаж автоматжуулагдаж болдог
		 (эсвэл  <filename>/etc/fstab</filename> дотор буй
		оруулгууд бүгдээрээ; &man.mdmfs.8;-с харна уу).</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Системийн төрөл бүрийн бүртгэл бичлэгийн файлууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Хэрэглэгчийн ирсэн захиаг хадгалах файлууд.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Төрөл бүрийн хэвлэгч болон захианы системийн дарааллыг удирдах сангууд.
	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Түр зуурын файлууд.
		Энэ санд буй файлууд нь голдуу системийг эхлэх үед
		зориулагдахаар нөөцлөгдсөн байдаг. Гэхдээ, хэрэв 
		 <filename class="directory">/var</filename>
		нь санах ойд тулгуурласан файлын систем бол өмнө хэлсэн зүйл хүчингүй.</entry>
	    </row>
	    
	    <row>
	      <entry><filename>/var/yp/</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Диск зохион байгуулалт</title>

      <para>FreeBSD нь файл олохын тулд хэрэглэдэг хамгийн жижиг
	хэрэгсэл бол файлын нэр юм. Файлын нэрний том болон бага үсэгнүүд нь
	бас ялгаатай. Энэ нь юу гэсэн үг вэ гэвэл 
	<filename>readme.txt</filename> болон <filename>README.TXT</filename> гэсэн хоёр файл нь хоорондоо ялгаатай файл гэсэн үг.
	 FreeBSD нь файлын төрлийг програм, бичиг баримт, эсвэл бусад төрлийн
	файл байна гэж ялгахын тулд 
	(<filename>.txt</filename>) гэх мэтийн өргөтгөл хэрэглэдэггүй.</para>

      <para>Файлууд сан дотор хадгалагддаг. Сан нь зуу зуун файл агуулж
      болох бөгөөд эсвэл хоосон байж болно. Сан нь сангаа агуулж бас болох ба ингэж сангийн угсарсан
модлог бүтэц үүсгэж болно. Ингэвэл та файлуудаа илүү амархан зохицуулах болно.</para>

      <para>Файл ба сангууд нь <literal>/</literal> тэмдгийн араас шаардлагатай бол сангуудын нэрийг бичиж өгөгдсөн нэрээрээ хандагдана.
	Хэрэв танд <filename>foo</filename> нэртэй сан нь
	<filename>bar</filename> санг агуулдаг бөгөөд уг сан дотор 
	<filename>readme.txt</filename> файл байгаа бол, файлын хандах
	бүтэн нэр буюу 
	<firstterm>зам</firstterm> нь 
	<filename>foo/bar/readme.txt</filename> гэж бичигдэнэ.</para>

      <para>Сан болон файлууд нь файл системд хадгалагддаг. Файл систем болгон хамгийн эхний дээд хэсэгт заавал нэг сан агуулдаг бөгөөд, түүнийг уг файл системийн 
	<firstterm>root сан</firstterm> буюу дээд эх сан гэж нэрлэдэг.
	Тэгээд энэ эх сан нь цаашаагаа өөр сангуудыг агуулж явдаг.</para>

      <para>Энэ хүртэл таны уншсан зүйлүүд нь таны бусад мэддэг үйлдлийн 
	системтэй ижил байж магадгүй. Гэхдээ жаахан ялгаанууд бий. Жишээлбэл
	&ms-dos; үйлдлийн систем нь файл болон санг тусгаарлахдаа
	<literal>\</literal> тэмдэг хэрэглэдэг байхад &macos; үйлдлийн
	систем нь <literal>:</literal> тэмдгийг хэрэглэдэг.</para>

      <para>FreeBSD дискэнд үсэглэж нэр өгдөггүй бөгөөд үсгээр нэр өгөгдсөн файлын замыг хэрэглэдэггүй. Та FreeBSD дээр <filename>c:/foo/bar/readme.txt</filename> гэж бичиж болохгүй.</para>

      <para>Харин түүний оронд нэг файл системийг нэг <firstterm>root
	  файл систем</firstterm> гэж ангилдаг. Уг root буюу эх файл системийн эх сан нь 
	<literal>/</literal> гэж хандагдана.  Бусад өөр файл системүүд энэ root буюу эх файл систем дотор 
	<firstterm>холбогддог</firstterm>.  Та FreeBSD систем дээрээ
	хэдэн ч дисктэй байсан, сан болгонууд нь нэг дискний хэсэг мэт
	харагддаг.</para>

      <para>Жишээлбэл <literal>A</literal>,
	<literal>B</literal>, мөн <literal>C</literal> гэсэн гурван
	файл систем танд байна гэж бодъё. Файл систем бүр нь өөртөө хоёр сан агуулсан тус тусын эх сантай гэж үзье. Тэдгээр сангууд нь дараах нэртэй байг. 
	<literal>A1</literal>, <literal>A2</literal> (гэх мэтчилэн
	<literal>B1</literal>, <literal>B2</literal> мөн
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para><literal>A</literal>-г эх сан гэж үзнэ. Хэрэв та
	<command>ls</command> тушаалаар энэ сангийн дотор байгааг харвал, <literal>A1</literal> ба
	<literal>A2</literal> гэсэн хоёр санг та харах болно. Энэ сангийн модлог загвар нь ингэж харагдаж байна:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Хэрэв файл систем  өөр файл системд холбогдохоор бол, холбогдож байгаа системийнхээ нэг сан дор холбогдоно. Тэгвэл одоо
        <literal>B</literal> файл системийг <literal>A1</literal> санд холбоно гэж үзье.  Тэгвэл <literal>B</literal>-ийн эх сан нь  <literal>A1</literal>-ээр орлуулагдаж, 
	<literal>B</literal> доторх файлууд дараах маягаар харагдана:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 | 
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Хэрэв <literal>B1</literal> эсвэл
	<literal>B2</literal> сан доторх файлууд шаардлага гаран
	хандагдахаар бол
	<filename>/A1/B1</filename> эсвэл <filename>/A1/B2</filename> гэсэн зам хэрэглэгдэж бичигдэнэ.  Хэрэв <filename>/A1</filename> дотор файлууд байсан бол тэдгээрийг түр зуур нуудаг.  <literal>B</literal> файл систем A системээс <firstterm>салгагдсан</firstterm> үед л тэр файлууд харагдана.</para>

      <para>Хэрэв <literal>B</literal> файл систем <literal>A2</literal>
	дор холбогдсон бол дараах маягаар харагдана:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>мөн файл уруу хандах зам нь <filename>/A2/B1</filename> болон
	<filename>/A2/B2</filename> гэж тус тусдаа хандагдах болно.</para>

      <para>Файл системүүд нэг нэгнийхээ дээр холбогдож болдог.  Сүүлийн жишээгээ үргэлжлүүлээд  <literal>C</literal> файл системийг <literal>B</literal> файл систем доторх
	<literal>B1</literal> сангийн дээд хэсэгт холбож өгвөл дараах зохион байгуулалт үүсэж байна:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>
	
	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Эсвэл <literal>C</literal> файл систем 
	<literal>A</literal> файл систем дотор <literal>A1</literal>
	санд холбогдож болно:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Хэрэв та &ms-dos; системийг гадарладаг бол энэ нь <command>join</command> тушаалтай төсөөтэй боловч яг адилхан биш.</para>

      <para>Угтаа бол энэ нь тийм их анхаарлаа хандуулаад байхаар зүйл биш.
	Ердийн үед та FreeBSD суулгах үедээ нэг файл систем үүсгээд хаана холбохыг нь шийдэж холбоод, шинэ диск нэмэхгүй л бол түүнийгээ хэзээ ч өөрчлөх шаардлага гардаггүй.</para>

      <para>Өөр файл систем үүсгэлгүйгээр нэг бүхэл эх файл систем үүсгэж болдог. Ийм үед зарим сул талууд гарч ирдэг бөгөөд нэг л давуу тал үүснэ.</para>

      <itemizedlist>
	<title>Олон файл системүүдийн давуу талууд</title>
      
	<listitem>
	  <para>Олон төрлийн файл системүүд нь олон төрлийн <firstterm>холбох нөхцөлтэй</firstterm>.  Жишээлбэл, сайн төлөвлөсний
	дараагаар, эх файл систем нь зөвхөн уншигдахаар холбогдож, ингэснээр санамсаргүй юм уу алдаа ослын шалтгаанаар чухал файлуудыг устгахаас сэргийлж болно. Хэрэглэгчдээр бичигдэж болдог файл систем, жишээ нь
	    <filename>/home</filename> мэтийн бусад системээс тусгаарлаж 
	    <firstterm>nosuid</firstterm> төрлийн гэж холбож болно; энэ сонголт нь файл систем дээр буй гүйцэтгэж болдог файлд <firstterm>suid</firstterm>/<firstterm>guid</firstterm> бит утга тавигдахаас сэргийлж аюулгүй байдлыг хангаж өгдөг.</para>
	</listitem>

	<listitem>
	  <para>FreeBSD файл систем ямар зорилгоор хэрэглэгдэхээс нь 
	хамаараад файл систем дээр файлын зохион  байгуулалтыг автоматаар 
  хийдэг. Тийм болохоор байнга бичигдэж байдаг олон жижигхэн файлуудын 
  байгаа файл систем дээр цөөхөн бичигддэг том файл агуулсан
  файл системийг бодвол олон бичигдэхэд зориулж арай 
  өөр файлын зохион байгуулалт хийгддэг.  Ганц том эх файл системд ийм зохион байгуулалт хийх боломжгүй.</para>
	</listitem>
	
	<listitem>
	  <para>FreeBSD-н файл систем нь цахилгаан тэжээлээс огцом салгагдсан үед ч дискний алдаа үүсгэдэггүй найдвартай байдаг. Гэвч маш ноцтой үед цахилгаан тэжээлээс огцом салгагдахад файл системийн бүтэц эвдэрч болзошгүй юм. Өгөгдлүүдээ олон файл системд хувааж байрлуулах нь дараа нь эвдрэлээс буцааж сэргээхэд амар байдаг.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Нэг файл системтэй байх үеийн давуу тал</title>

	<listitem>
	  <para>Энэ файл систем нь тогтсон хэмжээтэй байдаг. Хэрэв та  FreeBSD-ийг суулгах үедээ тодорхой зааж өгсөн файл систем үүсгээд, сүүлд нь түүнийгээ өргөжүүлэхийг хүсвэл, энэ нь тийм амархан биелэхгүй. Та эхлээд байгаа файл системийнхээ файлуудыг нөөцөлж хадгалаад дараа нь файл системдээ шинэ хэмжээ өгч өргөтгөөд дараа нь нөөцөөсөө файлуудаа буцааж сэргээж хадгалах болно.</para>

	  <important>
	    <para>FreeBSD-н &man.growfs.8; тушаал нь дээрх 
		хүндрэлийг алга болгож, файлыг нөөцлөх
		шаардлагагүйгээр шууд файл системийг өргөтгөж болдог болсон.</para>
	  </important>
	</listitem>
      </itemizedlist>
    
      <para>Дискний хуваалт дотор файл систем оршиж байдаг. &os; нь юниксээс 
      уламжилсан болохоор диск хуваалтын ойлголт нь ердийн хэрэглээтэй 
      ижилхэн биш (жишээлбэл, &ms-dos; диск зохион байгуулалт). Дискний 
      хуваагдал бүр  <literal>a</literal> үсэгнээс эхлээд 
	<literal>h</literal> хүртэл үсгээр тэмдэглэгддэг. Хуваагдал бүр зөвхөн ганцхан файл систем агуулах ёстой. Ийм болохоор файл систем нь агуулж байгаа диск хуваалтынхаа үсгээр илэрхийлэгдэх бөгөөд хэрэв өөр файл системд холбогдвол, холбосон сан нь уг файл системийг илэрхийлнэ.</para>

      <para>FreeBSD мөн <firstterm>swap
	  </firstterm>-д зориулж дискэнд зай бэлддэг. Swap хэмжээ нь FreeBSD-н
    <firstterm>виртуал санах ой</firstterm> юм. Ингэснээр таны компьютер
    байгаа бодит хэмжээнээсээ илүү санах ой хэрэглэж байгаа мэт ажилладаг.
    Хэрэв зарим програм FreeBSD дээр ажиллаад санах ойноос хэтрэх хүндрэл
    гарвал, хэрэглэгдэхгүй байгаа хэсгийг swap зай руу зөөж, шаардлагатай
    үед буцааж санах ой руу зөөх зарчмаар хэрэглэгддэг.</para>

      <para>Зарим дискний хуваалт нь тогтсон журамтай байдаг.</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Хуваалт</entry>

	      <entry>Тогтсон журам</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Ихэнхдээ root файл системийг агуулж байдаг</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Ихэнхдээ swap хэмжээг агуулдаг</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Ихэнх үед агуулж буй зүсмэлийнхээ хэмжээтэй
          ижил хэмжээтэй байдаг. Энэ нь ямар нэгэн хэрэгслүүдийг
          (жишээлбэл, дискний эвдэрсэн хэсгийг шалгагч)
          <literal>c</literal> хуваалт дээрх зүсмэл дээр бүхэлд
          нь ажиллаж болох зөвшөөрөл өгдөг.  Ердийн үед 
          та үүн дээр файл систем үүсгэх шаардлага байхгүй.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Урьд нь <literal>d</literal> хуваалт онцгой үүрэгтэй байсан
        боловч одоо тийм биш, харин ердийн хуваалт шиг хэрэглэгдэж болно.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>FreeBSD дээр файл систем агуулж байгаа хуваалтыг 
      <firstterm>зүсмэл</firstterm> гэж нэрлэдэг. Хуваалтын ерөнхий нэр нь
        FreeBSD дээр зүсмэл гэж яригдах бөгөөд FreeBSD-ийн &unix; гаралд
        цаад утга учир нь бий. Зүсмэл нь 1 -ээс эхлээд 4 хүртэлх тоогоор
        дугаарлагдана.</para>

	<indexterm><primary>зүсмэл</primary></indexterm>
	<indexterm><primary>хуваалт</primary></indexterm>
	<indexterm><primary>аюултай зориулалт</primary></indexterm>

      <para>Зүсмэлийн дугаар нь төхөөрөмжийн нэрний араас 
      <literal>s</literal> үсгээр эхэлж бичигддэг. 
      Тэгэхээр <quote>da0<emphasis>s1</emphasis></quote> гэдэг нь,
        эхний SCSI диск дээрх эхний зүсмэлийг илэрхийлж байна.
        Диск дээр физик чанараараа зөвхөн дөрвөн ширхэг зүсмэл байрлуулж 
        болно. Харин логик зүсмэлийг та физик зүсмэл дотор дурын хэмжээтэй
        үүсгэж болно.  Ингэж өргөтгөж нэмсэн зүсмэлүүд нь 5 гэсэн 
        дугаараар эхэлж цаашаагаа тоологддог. Тэгэхээр 
        <quote>ad0<emphasis>s5</emphasis></quote> гэдэг нь эхний IDE
        диск дээрх эхний өргөтгөсөн зүсмэлийг хэлж байна. 
        Ингэж өргөтгөсөн зүсмэлүүд нь файл систем агуулж, систем дээр
        ердийн зүсмэл мэт харагдаж ажиллана.</para> 

      <para>Зүсмэлүүд нь физик диск дээр <quote>аюултай зориулалт</quote>аар
        буюу өөрөөp хэлбэл хүчээр байрлуулагддаг. Харин бусад дискнүүд нь
        <literal>a</literal> -с эхлээд <literal>h</literal> хүртэл нэрлэсэн
        <firstterm>хуваалт</firstterm> агуулж болдог. 
        Эдгээр үсэгнүүд нь төхөөрөмжийн ард залгагдаж бичигддэг ба
        <quote>da0<emphasis>a</emphasis></quote> гэдэг нь 
        эхний da диск дээр байгаа a хуваалтыг илэрхийлж байна.
	<quote>ad1s3<emphasis>e</emphasis></quote> бол хоёр дахь IDE диск дээр байгаа
  гурав дахь зүсмэлийн тав дахь хуваалтыг илэрхийлж байна.</para>
	
      <para>Эцэст нь хэлэхэд, диск болгон системд танигдах ёстой.
      Дискний нэр нь дискний төрлийг илэрхийлсэн үсгээр эхлээд
      тэгээд араас нь хэд дэх диск вэ гэдгийг нь илэрхийлсэн дугаартай
      байдаг. Зүсмэлээс ялгарах зүйл нь, дискний дугаар 0 -ээс эхэлдэг.
      Ерөнхий хэрэглээний жишээг <xref linkend="basics-dev-codes">
      хүснэгтээс харна уу.</para>

      <para>Хуваалт уруу хандах үед FreeBSD уг хуваалтыг
      агуулсан зүсмэл болон дискийг тодорхойлохыг шаарддаг. Тэгээд 
      зүсмэл рүү хандах үед зүсмэлийг агуулсан дискний нэрийг шаардах
      болно. Тэгэхээр та дискний нэр, <literal>s</literal>, зүсмэлийн дугаар,
      тэгээд хуваалтын үсэг гэсэн дарааллаар нэрлэх нь байна. 
      Жишээнүүдийг <xref linkend="basics-disk-slice-part">-д харуулав.</para>

      <para>Танд ойлгоход тань дөхөм болгож <xref linkend="basics-concept-disk-model">
      жишээн дээр дискний зохион байгуулалтын тогтсон загварыг харуулж байна.</para>

      <para>FreeBSD суулгахын тулд та эхлээд дискний зүсмэлийг тохируулна,
        дараа нь зүсмэл дотор FreeBSD-н хэрэглэх хуваалт үүсгээд, дараа нь
        хуваалт бүрд файл систем (эсвэл swap зайг) үүсгэж эцэст нь
        хаана холбогдохыг нь (mount)  зааж өгдөг.</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>Диск төхөөрөмжийн нэрнүүд</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Нэр</entry>
	    
	      <entry>Утга</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>ATAPI (IDE) disk</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>
	      
	      <entry>SCSI direct access disk</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>acd</devicename></entry>
	      
	      <entry>ATAPI (IDE) CDROM</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>cd</devicename></entry>
	      
	      <entry>SCSI CDROM</entry>
	    </row>
	    
	    <row>
	      <entry><devicename>fd</devicename></entry>
	      
	      <entry>Floppy disk</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      
      <example id="basics-disk-slice-part">
	<title>Диск, Зүсмэл, Хуваалтын нэрлэх жишээ</title>
	
	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Нэр</entry>
		
		<entry>Утга</entry>
	      </row>
	    </thead>
	    
	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>
		
		<entry>
      Эхний IDE диск (<literal>ad0</literal>) дээрх эхний
      зүсмэлийн (<literal>s1</literal>) эхний хуваалт (<literal>a</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		
		<entry>
      Хоёр дахь SCSI диск (<literal>da1</literal>) дээрх
      хоёр дахь (<literal>s2</literal>) зүсмэлийн тав дахь
      (<literal>e</literal>) хуваалт.
    </entry>
  </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>Дискний тогтсон загвар</title>

	<para>
    Дараах загвар нь системд буй IDE диск
    FreeBSD дээр хэрхэн харагдаж байгааг харуулж байна.
    Дискний хэмжээг 4&nbsp;ГБ-н хэмжээтэй гэж үзээд хоёр ширхэг
    2&nbsp;ГБ зүсмэл байна (нэг зүсмэл дээр нь &ms-dos; хуваалт байгаа).  
    Эхний зүсмэл нь &ms-dos;-н <devicename>C:</devicename> диск агуулсан,
    харин хоёр дахь зүсмэл дээр FreeBSD суугдсан.
    Энэ жишээн дээр FreeBSD нь гурван өгөгдлийн хуваалт мөн swap хуваалт хэрэглэж
    байна.</para>

	<para>Гурван хуваалт нь тус тусдаа файл систем агуулж байгаа.
   <literal>a</literal> хуваалт root файл системд зориулагдаж,
	  <literal>e</literal> хуваалт <filename>/var</filename> санд, мөн
    <literal>f</literal> хуваалт 
	  <filename>/usr</filename> санд тус тус зориулагдсан.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>
 
          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all 
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 id="mount-unmount">
    <title>Файл системийг холбох болон салгах</title>

    <para>Файл систем нь <filename>/</filename> гэсэн
	эхээс эхлэн модлог хэлбэрээр маш сайн харагддаг.
      <filename>/dev</filename>, <filename>/usr</filename>, мөн 
      бусад сангууд нь root буюу эх сангаасаа салбарласан 
	салаа мөчир бөгөөд цаашаа уг мөчир нь бас 
      
      <filename>/usr/local</filename> гэж салаалах зэргээр
	өргөжиж салаалж болдог.</para>

    <indexterm><primary>root файл систем</primary></indexterm>
    <para>Эдгээр сангуудын заримыг нь өөр файл системд
	байрлуулах маш олон шалтгаан бий. <filename>/var</filename>
      сан нь жишээлбэл <filename>log/</filename>,
      <filename>spool/</filename>, гэх зэрэг янз бүрийн түр зуурын
	файлуудыг агуулдаг бөгөөд түргэн дүүрэх магадлалтай. Эх сан буюу
	root файл систем түргэн дүүрнэ гэдэг бол тийм ч сайн юм биш.
	Тийм болохоор  <filename>/var</filename> санг 
      <filename>/</filename> сангаас тусад нь өөр газар байрлуулах нь 
	тун хэрэгтэй.</para>

    <para>Тодорхой хэдэн сангуудыг тусад нь өөр файл систем дээр
	байрлуулах хүндтэй шалтгаан бол, хэрвээ уг сангууд нь 
	өөр физик диск дээр, тусдаа виртуал диск дээр,  <link
	linkend="network-nfs">Сүлжээний файл систем</link> дээр, 
	эсвэл CDROM дээр байх явдал юм.</para>

    <sect2 id="disks-fstab">
      <title><filename>fstab</filename> файл</title>
      <indexterm>
	<primary>файл систем</primary>
	<secondary>fstab ашиглаж диск холбогдох</secondary>
      </indexterm>

      <para><filename>/etc/fstab</filename> файлд жагсаагдсан
	файл системүүд нь системийн <link linkend="boot">ачаалах явцад</link> автоматаар холбогддог (гэхдээ хэрэв тэдгээр нь 
	<option>noauto</option> сонголт хэрэглээгүй үед).</para>

      <para><filename>/etc/fstab</filename> нь дараах маягийн
	жагсаалтыг агуулж байдаг:</para>

      <programlisting><replaceable>төхөөрөмж</replaceable>       <replaceable>/холбох-цэг</replaceable> <replaceable>файл-системийн-төрөл</replaceable>     <replaceable>сонголтууд</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>төхөөрөмж</literal></term>
	  <listitem>
	    <para>Төхөөрөмжийн нэр (заавал байх ёстой). 
	      <xref linkend="disks-naming"> хуудсанд тайлбарласан байгаа.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point буюу холбох цэг</literal></term>
            
	  <listitem><para>Файл системийг байрлуулах
	сангийн нэр (заавал байх ёстой).</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>файл-системийн-төрөл</literal></term>
            
	  <listitem><para>
		&man.mount.8; хуудсанд тайлбарласан байгаа тул алгасав.  
	 FreeBSD-н анхдагч файл систем бол
	      <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>сонголтууд</literal></term>
            
	  <listitem><para>Уншиж бичигдэх файл системийг заасан 
	<option>rw</option> эсвэл зөвхөн уншигдах файл системд
	зориулсан <option>ro</option> сонголт байж болох бөгөөд
	цаашаагаа мөн нэмэлт сонголтууд агуулж болно.
	Ердийн сонголт бол <option>noauto</option> бөгөөд
	ингэснээр систем эхлэх үед уг файл систем холбогддоггүй.
	Бусад сонголтууд &man.mount.8; гарын авлагад тодорхой
	бичигдсэн байгаа.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><literal>dumpfreq</literal></term>
          
         <listitem><para>Энэ сонголт нь &man.dump.8; хэрэгслээр
	хэрэглэгддэг бөгөөд аль файл системд нөөц хадгалалт хийх вэ гэдгийг
	тодорхойлж өгдөг. Хэрэв энэ сонголтыг бичээгүй бол
        хоосон утгыг агуулж байдаг.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Энэ сонголтыг ашиглан ямар дарааллаар файл системүүдийг
	шалгах вэ гэдгийг зааж өгдөг. 
	 Шалгалгүйгээр алгасна гэсэн файл системүүд нь 
	 <literal>passno</literal> талбардаа 0 утгатай байх ёстой.
	 root буюу эх файл системийн (энэ файл систем нь хамгийн түрүүнд
	шалгагддаг) <literal>passno</literal> талбарын утга нь 
	1 байдаг бөгөөд бусад системийн  <literal>passno</literal>
           нь нэгээс их байх ёстой.
	Хэрэв нэгээс илүү олон файл системүүд <literal>passno</literal>
	талбартаа ижил утгатай бол &man.fsck.8; нь тэдгээр файл системийг
	хэрэв боломжтой зэрэг шалгахыг оролдох болно.</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para><filename>/etc/fstab</filename> файлын бүтэц болон 		тохируулдаг сонголтуудын тухай дэлгэрэнгүй мэдээллийг 		&man.fstab.5; гарын авлагаас харна уу.</para>
    </sect2>

    <sect2 id="disks-mount">
      <title><command>mount</command> тушаал</title>
      <indexterm>
	<primary>файл систем</primary>
	<secondary>mounting буюу файл систем холбох</secondary>
      </indexterm>
        
      <para>&man.mount.8; тушаал нь файл системийг
	холбоход хэрэглэгддэг цорын ганц тушаал юм.</para>
        
      <para>Таны хамгийн өргөн хэрэглэх хэлбэр бол:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>төхөөрөмж-буюу-диск</replaceable> <replaceable>холбох-цэг</replaceable></userinput></screen>
      </informalexample>

      <para>&man.mount.8;-н гарын авлагад зааснаар бол маш олон
	сонголт байдаг бөгөөд өргөн хэрэглэгддэг нь:</para>

      <variablelist>
	<title>Холбох тохируулгууд</title>

	<varlistentry>
	  <term><option>-a</option></term>
            
	  <listitem>
	    <para><filename>/etc/fstab</filename> файлд
		жагсааж бичсэн бүх файл системийг холбоно. Гэхдээ 
		<quote>noauto</quote> гэж тэмдэглэснийг, 
	      <option>-t</option> гэж туг хатгасныг, эсвэл 
	өмнө нь холбогдчихсон файл системүүдийг холбохгүй.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-d</option></term>
            
	  <listitem>
	    <para>Дуудаж ажиллуулж байгаа файл системээсээ бусдад нь
		дурын үйлдлээ хийнэ. Энэ сонголтыг 
	      <option>-v</option> тугтай хамт хэрэглэж 
		&man.mount.8;-г юу хийж байгааг нь харж болдог.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Бохир файл систем
	      (аюултай), эсвэл файл системийн унших-бичигдэх төлвөөс
		зөвхөн-унших төлөв рүү шилжүүлэн бичих эрхийг хасаж
		холбох үед хүчээр холбодог.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
          <term><option>-r</option></term>
            
	  <listitem>
	    <para>Файл системийг зөвхөн-унших төлвөөр холбоно.  
		Энэ нь <option>-o</option> сонголтыг
		<option>ro</option> утгатай
	       хэрэглэсэнтэй ижил.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Өгөгдсөн файл системйиг өгөгдсөн төрлөөр холбоно.
		Эсвэл <option>-a</option> сонголт өгөгдсөн бол зөвхөн
		өгөгдсөн төрлөөр холбоно.</para>
              
	    <para><quote>ufs</quote> нь анхдагч файл систем юм.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-u</option></term>
            
	  <listitem>
	    <para>Файл системд холболтын сонголтыг шинэчилнэ.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-v</option></term>
            
	  <listitem>
	    <para>Болж байгаа үйл явцыг харуулж мэдэгдэнэ.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term><option>-w</option></term>
            
	  <listitem>
	    <para>Файл системийг унших-бичих төлвөөр холбоно.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
        
      <para><option>-o</option> сонголт нь дараах зүйлүүдийг таслалаар тусгаарлаж хэрэглэж болно:</para>
        
      <variablelist>
	<varlistentry>
	  <term>noexec</term>
            
	  <listitem>
              <para>Энэ нь файл систем дээр хоёрлосон файл буюу ачаалагдаж ажиллаж болдог файл ажиллахыг үл зөвшөөрнө. Энэ нь мөн аюулгүй байдлын зорилгоор хэрэгтэй.</para>
	  </listitem>
	</varlistentry>
          
	<varlistentry>
	  <term>nosuid</term>
            
	  <listitem>
	    <para>Файл систем дээр  setuid эсвэл setgid тугуудыг бүү хэрэглэ. Мөн аюулгүй байдлын шалтгаанаар.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title><command>umount</command> тушаал</title>
      <indexterm>
	<primary>файл систем</primary>
	<secondary>файл систем салгах</secondary>
      </indexterm>
        
      <para>&man.umount.8; тушаал нь ардаа холбосон цэг, төхөөрөмжийн нэр зэргийг авдаг бөгөөд мөн 
	 <option>-a</option> сонголт эсвэл бас
	<option>-A</option> сонголтуудыг авч болдог.</para>
        
      <para>Бүх хэлбэрүүд нь <option>-f</option> сонголтыг хүчээр салгах үед болон <option>-v</option> сонголтыг явцын мэдээллийг харахад  хэрэглэдэг. 
        <option>-f</option> сонголт нь тийм сайн санаа биш гэдгийг анхааруулмаар байна.  Хүчээр файл системийг салгах нь файл эсвэл системийн эвдрэлд хүргэж болзошгүй.</para>
        
      <para><option>-a</option> болон <option>-A</option> сонголтууд нь холбогдсон бүх файл системийг салгахад хэрэглэгддэг. Эсвэл мөн
	<option>-t</option> сонголтоор өөрчлөгдсөн файл системүүдийг салгахад хэрэглэнэ. Гэхдээ
	<option>-A</option> сонголт нь 
	root файл системийг салгах гэж оролддоггүй.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Процесс буюу програмын явц</title>

    <para>FreeBSD бол олон үйлдэл зэрэг хийх чадвартай систем. Энэ нь олон програм нэг дор зэрэг ажиллана гэсэн үг. Програмын тухайн үед ажиллаж байгааг нь <firstterm>процесс буюу програмын явц</firstterm> гэдэг.
      Таны ажиллуулсан тушаал болгон шинэ процесс эхлүүлдэг бөгөөд систем дээр
	бүхэлдээ тэр чигээрээ процессууд үргэлж ажиллаж системийн ажиллагааг бүрэлдүүлж байдаг.</para>

    <para>Програмын явц бүр 
      <firstterm>процесс ID</firstterm>, эсвэл <firstterm>PID</firstterm> гэсэн дугаар агуулж байдаг бөгөөд файлтай бас ижилхэн өөрийн гэсэн эзэмшигч болон бүлэгт харъяалагдаж байдаг.  Эзэмшигч ба бүлгийн 
мэдээлэл нь уг процесс файлд хандах эрхийг нь хэрэглэж файлтай хэрхэн 
хандах вэ гэдгийг тодорхойлж өгдөг. Ихэнх процесс нь мөн эцэг процесстой байдаг. Эцэг процесс нь тэдгээр процессийг эхлүүлж өгдөг.  
	Жишээлбэл, хэрэв та тушаалуудыг бүрхүүлд бичиж гүйцэтгэвэл, бүрхүүл ч процесс, тушаалууд ч процесс болдог бөгөөд таны бичсэн тушаал болгон процесс болдог.  Ийм маягаар ажиллуулаад байвал бүрхүүл нь тэдгээр процессуудын эцэг нь болно. Үүнээс өөр онцгой процесс байдаг ба түүнийг 
      &man.init.8; процесс гэж нэрлэдэг.  <command>init</command> 
	бол хамгийн эхний процесс байдаг бөгөөд үүний PID дугаар үргэлж
	 1 байдаг.  FreeBSD эхлэх үед <command>init</command> процесс 
	автоматаар эхэлдэг.</para>

    <para>Системд гүйцэтгэгдэж байгаа процессуудыг хардаг хоёр тушаал бол
	&man.ps.1; ба &man.top.1; хоёр юм.  <command>ps</command> тушаал нь одоо ажиллаж байгаа процессуудыг PID дугаартай нь харуулж, мөн хичнээн санах ойн хэмжээ хэрэглэж байгаа, ямар тушаалаар гүйцэтгэгдэж байгаа  зэргийг нь харуулдаг.  <command>top</command> тушаал нь ажиллаж байгаа
 бүх процессуудыг харуулдаг бөгөөд хэдэн секунд тутамд шинэчлэгдэж байдаг. Ингэснээр таны компьютер тухайн үед юу хийж байгааг харж болно.</para>

    <para>Анхдагч горимондоо, <command>ps</command> тушаал нь зөвхөн таны эзэмшиж байгаа процессуудыг харуулдаг.  Жишээлбэл:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Дээрх жишээнд харуулснаар, &man.ps.1; тушаалын гаралт нь
	хэд хэдэн баганаар харуулагдаж байна.  <literal>PID</literal> бол өмнө ярьсны дагуу процессийн ID дугаар.  PID дугаарууд нь  1 гэж эхлээд 99999 хүртэл дугаарлагддаг бөгөөд хэтрээд ирэхээрээ эхнээсээ эхэлж тоологддог (PID нь ашиглагдаж байгаа бол дахин олгогддоггүй).
      <literal>TT</literal> багана нь, уг програмын ажиллаж байгаа tty буюу терминалыг нь харуулдаг бөгөөд одоохондоо хэрэгсэх шаардлага байхгүй.   <literal>STAT</literal> нь програмын төлвийг харуулдаг бөгөөд мөн одоохондоо хэрэгсэхгүй байж болно.
      <literal>TIME</literal> нь процессор дээр хэр удаан ажиллаж байгааг нь заадаг бөгөөд гэхдээ энэ нь програм эхэлснээс хойш тооцож эхэлсэн цаг биш. Ихэнх програм нь процессор дээр гүйцэтгэх гэж хэсэг хугацаа  зарцуулж хүлээдэг.
      Эцэст нь, <literal>COMMAND</literal> нь тухайн програмыг ажиллуулсан тушаалыг харуулдаг.</para>

    <para>Харуулах мэдээллээ өөрчилж болдог хэд хэдэн нэмэлт сонголт &man.ps.1; тушаалд бий. Байнга хэрэглэгддэг сонголтуудын багц бол
      <literal>auxww</literal> юм.  <option>a</option> сонголт нь зөвхөн өөрийн эзэмшдэг процесс биш харин ажиллаж байгаа бүх процессийг харуулдаг.  <option>u</option>
      сонголт нь процессийг эзэмшиж байгаа хэрэглэгчийн нэрийг харуулдаг бөгөөд мөн хэрэглэж байгаа санах ойг нь харуулдаг.
      <option>x</option> сонголт нь далд ажиллаж байгаа буюу дэмон эсэхийг нь харуулдаг. 
      <option>ww</option> сонголт нь процессуудыг ажиллуулсан тушаалын бүтэн нэрийг нь харуулдаг. Бусад үед, хэрэв тушаалын нэр нь дэлгэцэнд багтахгүй урт байх тохиолдолд хасаж харуулдаг.</para>

    <para>&man.top.1; тушаалын гаралт нь өмнөх жишээтэй ижилхэн. Жишээ болгож нэг гаралтыг харцгаая:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Тушаалын гаралт хоёр хэсэгт хуваагдсан байна.  Толгой хэсэг 
	(эхний таван мөр) нь сүүлд ажиллаж байгаа PID дугаарыг, системийн ачаалалтын дунджууд
      (энэ нь системийг хэр завгүй байгааг илтгэдэг), системийн асаалттай байгаа хугацаа (унтраалгүй хэр удсан эсэхийг) мөн одоогийн цаг зэргийг харуулдаг.  Бусад илэрхийллүүд нь, хичнээн процессууд ажиллаж байгаа (энэ тохиолдолд 47 ), хичнээн санах ойн хэмжээ болон swap хэмжээ хэрэглэгдэж байгаа, мөн хичнээн хугацааг процессорын бусад төлөв байдалд зарцуулсан зэргийг илэрхийлж байна.</para>

    <para>Доорх баганууд нь &man.ps.1; тушаалтай ойролцоо мэдэгдлүүдийг харуулж байна.  Эхлээд PID дугаар дараа нь хэрэглэгчийн нэр, процессороос хэрэглэсэн хугацаа, ажиллуулсан тушаал гэх мэт.
      &man.top.1; тушаал нь анхдагч тохируулгаараа, процессийн хэрэглэж байгаа санах ойн хэмжээг харуулдаг. Тэр хэсэг нь хоёр баганад харуулагддаг бөгөөд эхнийх нь нийт хэмжээ дараагийх нь тухайн үеийнх нь хэмжээ юм. Нийт хэмжээ гэдэг нь програм ажиллахад хэд хэрэгтэйг хэлдэг бөгөөд тухайн үеийнх нь хэмжээ нь одоогоор хэдийг хэрэглэж байгааг заадаг.  Энэ жишээн дээр 
<application>&netscape;</application> програм  бараг 30&nbsp;МБ хэмжээг RAM санах ойд шаардлагатай гэсэн боловч одоогоор 9&nbsp;МБ хэмжээ хэрэглэж байна гэж заасан байна.</para>

    <para>&man.top.1; нь энэ харуулалтыг хоёр секунд тутам шинэчилдэг бөгөөд үүнийг  <option>s</option> тохируулгаар өөрчилж болно.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Далд чөтгөр буюу дэмонууд, дохионууд, мөн процессуудыг зогсоох нь</title>

    <para>Та хэрэв ямар нэг текст засварлагч дээр ажиллаж байхдаа файл нээх, хаах, хадгалах гэх мэт уг програмыг сайн хянаж чаддаг. Та яагаад тэгж
	чадаж байна вэ гэвэл, уг програм нь <firstterm>терминал</firstterm> дээр холбогдон ажиллаж танд тийм боломж олгож байгаа билээ. 
      Зарим програм тэгэхэд үргэлж хүн гарнаас оруулалт хийх шаардлагагүй зориулалтаар бүтээгдсэн байдаг бөгөөд хамгийн эхний боломж гарангуут терминалаас салангид ажилладаг. Жишээлбэл вэб серверүүд өдөржин хүмүүсээс ирсэн хүсэлтэд хариулт өгч байдаг  бөгөөд ердийн үед танаас оруулга шаарддаггүй. Ийм төрлийн бас нэг програм бол захиа илгээгч програм юм.</para>

    <para>Бид ийм програмыг <firstterm>далд чөтгөр буюу дэмон</firstterm> гэж нэрлэдэг.  Дэмонууд нь Грекийн домогт байдаг сайн муугийн аль нь ч биш бөгөөд жижигхэн мөртлөө хүмүүст хэрэгтэй юм хийж байдаг сүнсийг хэлдэг. 
Вэб сервер болон захианы серверүүд үүнтэй ижил хүмүүст тустай юм хийдэг.  Тийм болохоор BSD нь спорт шаахайтай, жижигхэн, сэрээ барьсан чөтгөрийг олон жилээр дуртайяа өөрийнхөө билэг тэмдэг болгож байгаа билээ.</para>

    <para>Далд ажиллаж байгаа буюу дэмон болж ажиллаж байгаа програмын нэрний ард <quote>d</quote> үсэг залгаж бичдэг зарчим бий. <application>BIND</application> програмын бүтэн нэр нь 
      Berkeley Internet Name Daemon бөгөөд үндсэн далд ажилладаг 
	програмын нэр нь 
      <command>named</command>, мөн <application>Apache</application> вэб серверийн далд ажилладаг програмын нэр нь <command>httpd</command>, хэвлэх дарааллыг далд ажиллаж зохицуулж байдаг програмын нэр нь <command>lpd</command> гэх мэт нэртэй байдаг. 
Энэ нь ерөнхийдөө ингэж зарчим гаргасан болохоос хатуу тогтоосон дүрэм биш; жишээлбэл захиа илгээгч үндсэн програм <application>Sendmail</application>-н далд ажилладаг програмыг та <command>maild</command> гэж төсөөлж байгаа бол эндүүрэх бөгөөд харин 
      <command>sendmail</command> гэж нэрлэдэг.</para>

    <para>Заримдаа та эдгээр дэмон процессуудтай холбогдож харилцах хэрэг гарна. Ингэх нэг арга нь түүн рүү (эсвэл бусад ажиллаж байгаа процесс уруу) 
	<firstterm>дохио</firstterm> гэгддэг зүйл илгээх явдал юм. Маш олон төрлийн илгээж болох дохионууд байдаг &mdash; зарим дохионууд онцгой зориулалттай нийтэд нь хэрэгждэг,  зарим нь тухайн програмдаа зориулж өөр өөрөөр хөрвүүлэгддэг бөгөөд програмын заавар дээр ямар дохиог яаж хөрвүүлэн ойлгох вэ гэдгийг заасан байдаг.  Та өөрийнхөө эзэмшиж байгаа процесс уруугаа дохио илгээж болно. Хэрэв та бусдын эзэмшдэг процесс уруу  &man.kill.1; эсвэл &man.kill.2; гэх зэрэг дохио илгээвэл таны эрх дутаж хэрэгждэггүй.
      Гэхдээ ийм эрхээр дутагддаггүй хэрэглэгч бол
      <username>root</username> хэрэглэгч бөгөөд хүн болгоны процесс уруу дохио илгээж чаддаг.</para>

    <para>Мөн FreeBSD-ээс програм уруу зарим тохиолдолд дохио илгээдэг. Жишээлбэл, хэрэв муу зохиогдсон нэг програм санах ойг зориулсан хэмжээнээсээ илүү хэрэглээд эхэлбэл FreeBSD уг програм уруу  <firstterm>Хэсгийн буруу
	хэрэглээ</firstterm>  дохио илгээдэг (<literal>SIGSEGV</literal>).  Мөн хэрэв ямар нэгэн програм нь &man.alarm.3; гэдэг системийн сануулах програмыг ашигласан бол тухайн хугацаа нь хэтрэх үед Сэрүүлэг дохио уг програмд ирэх
      (<literal>SIGALRM</literal>) зэрэг олон дохио бий.</para>

    <para>Процесийг зогсоох хоёр дохио байдаг,
      <literal>SIGTERM</literal> ба <literal>SIGKILL</literal> хоёр.
      <literal>SIGTERM</literal> нь арай эелдэг аргаар процессийг зогсоодог; процесс нь эхлээд дохиог <emphasis>хүлээж аваад</emphasis> өөрийг нь хаах гэж байгаад мэдээд нээлттэй байгаа бүртгэл бичлэг файлуудаа хаагаад тэгээд хийж байгаа ерөнхий үйлдлээ зогсоодог. Зарим тохиолдолд  уг процесс нь таслагдаж болохооргүй үйлдэл хийж байх үедээ 
<literal>SIGTERM</literal> дохиог хэрэгсэхгүй байдал үүсдэг.</para>

    <para><literal>SIGKILL</literal> дохиог ямар ч процесс хэрэгсэхгүй байж чаддаггүй.  Өөрөөр хэлбэл энэ нь
      <quote>Чиний юу хийж байх нь надад хамаагүй, одоо шууд зогсоо</quote>
       гэсэн дохио юм.  Хэрэв та <literal>SIGKILL</literal> дохиог процесс уруу илгээвэл 
      FreeBSD уг процессийг зогсоодог <footnote>
	<para>Бас тэр чигээрээ үнэн биш&mdash;учир нь зарим таслагдаж болдоггүй нөхцлүүд байдаг.  Жишээлбэл, хэрэв сүлжээнд байгаа компьютерийн нэг файлаас унших үйлдэл хийж байгаа процесс нь, хэрэв холбогдсон компьютер нь тодорхойгүй шалтгаанаар холбогдохгүй болох үед (цахилгаан тэжээлээс салгагдах, эсвэл сүлжээ эвдрэх), уг процесс нь
	  <quote>тасрахгүй</quote> нөхцөлд байдаг. Магадгүй хэсэг хугацааны дараа хүлээх хугацаа нь дуусна. Ингэж хүлээх хугацаа нь дууссаны дараа л уг процесс зогсох болно.</para>
      </footnote>.</para>

    <para>Таны хэрэглэж болохоор бусад дохионууд нь
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, мөн
      <literal>SIGUSR2</literal>.  Эдгээр дохио нь ерөнхий зориулалтаар хэрэглэгддэг бөгөөд эдгээр дохиог хүлээж авсан програмууд тус тусдаа өөр өөр хариу үйлдэл хийдэг.</para>

    <para>Жишээлбэл, та вэб серверийнхээ тохируулгын файлд өөрчлөлт хийгээд уг серверийг тохируулгын файлаа дахин шинээр уншуулахыг хүссэн гэж бодъё.  Та <command>httpd</command> дэмоноо зогсоогоод дахин шинээр эхлүүлж болох боловч ажиллаж байгаа вэб серверийг зогсоож болохгүй нөхцөл байж болно. Ихэнх дэмонууд нь 
      <literal>SIGHUP</literal> дохиог хүлээж авбал өөрийнхөө тохируулгынхаа файлыг уншина гэж тохируулагдсан байдаг. Тэгэхээр  <command>httpd</command> дэмоноо зогсоогоод шинээр ачаалж байхын оронд
       <literal>SIGHUP</literal> дохиог илгээхэд хангалттай. Учир нь энэ дохионд тэгж хариулна гэсэн тогтоосон арга зам байхгүй тул дэмон болгон өөр өөр үйлчлэл үзүүлдгийг ойлгож тухайн дэмоны заавар бичгийг нь судлах хэрэгтэй. </para>
    
    <para>дохио илгээхдээ &man.kill.1; тушаалыг ашигладаг. </para>

    <procedure>
      <title>Процесс уруу дохио илгээх</title>

      <para>Энэ жишээ нь  &man.inetd.8; уруу хэрхэн дохио илгээхийг харуулах болно.  
	  <command>inetd</command> -н тохируулгын файл
	<filename>/etc/inetd.conf</filename> гэж байрласан бөгөөд  <command>inetd</command>-ийг тохируулгын файлаа дахин уншуулахын тулд 	<literal>SIGHUP</literal> дохиог илгээх болно.</para>

      <step>
	<para>Илгээх процессийн процесс ID дугаарыг мэдэх хэрэгтэй. Ингэхийн тулд  &man.ps.1; ба &man.grep.1; тушаалуудыг ашиглана.  &man.grep.1;
	  тушаал нь өмнөх тушаалынхаа гаралтаас хайлт хийхэд хэрэглэгддэг бөгөөд хайх мөрөө зааж өгдөг. Энэ тушаал нь энгийн хэрэглэгчээс гүйцэтгэгдэж болох бөгөөд харин &man.inetd.8; програм нь 
	  <username>root</username> хэрэглэгчээр гүйцэтгэгдсэн тул &man.ps.1; тушаалыг  <option>ax</option> сонголттой цуг гүйцэтгэх ёстой.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>За тэгэхээр, &man.inetd.8;-ийн PID дугаар нь 198 гэж энэ тохиолдолд хэлж байна.  Зарим тохиолдолд 
	  <literal>grep inetd</literal> гэсэн тушаал нь өөрөө энэ гаралтад байж байдаг. Учир нь,  &man.ps.1; програм нь уг тушаалыг ажиллуулж байгаа процессийг олсон үед тэгж гаргаж харуулдаг.</para>
      </step>

      <step>
	<para>&man.kill.1; тушаалыг хэрэглэж дохио илгээнэ.   &man.inetd.8; нь 
	   <username>root</username> хэрэглэгчээр гүйцэтгэгдэж байгаа болохоор, та эхлээд  &man.su.1; тушаалыг ашиглан 
	   <username>root</username> хэрэглэгч болох хэрэгтэй.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Ихэнх &unix; системийн тушаалуудын адил, &man.kill.1; тушаал нь хэрэв амжилттай хэрэгжвэл ямар нэгэн төлвийн мэдээлэл харуулдаггүй.  Хэрэв та өөрийнхөө эзэмшдэггүй процесс уруу дохио илгээвэл  <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname> буюу энэ үйлдлийг хийх эрх байхгүй байна гэсэн мэдэгдэл гарч ирнэ.  Хэрэв та  PID дугаараа буруу бичих, эсвэл буруу процесс уруу дохио илгээвэл, азгүй тохиолдолд уг дохио нь тухайн процесс уруу илгээгдэх бөгөөд, уг процесс нь азаар байхгүй байгаа тохиолдолд  <errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname> буюу тийм процесс алга байна гэсэн мэдэгдэл гарч ирнэ.</para>

	<note>
	  <title>Яагаад <command>/bin/kill</command> тушаалыг хэрэглэх хэрэгтэй вэ?</title>

	  <para>Ихэнх shells буюу бүрхүүлүүд <command>kill</command> тушаалыг өөртөө агуулсан байдаг бөгөөд <filename>/bin/kill</filename> тушаалыг бичихийн оронд шууд бүрхүүлд буй тушаалыг нь гүйцэтгэх нь шулуухан байдаг.
	    Энэ нь амарчилсан ашигтай арга боловч бүрхүүл болгон өөрсдийн илгээх дохионы өөр өөр нэртэй байдгийг мэдэх хэрэгтэй. Тийм болохоор бүрхүүл болгоны дохионы бичлэгийг судлахын оронд шууд
	    <command>/bin/kill <replaceable>...</replaceable></command> тушаалыг хэрэглэх нь зөв арга юм.</para>
	</note>
      </step>
    </procedure>

    <para>Бусад дохио илгээх үйлдлүүд нь үүнтэй тун ижил бөгөөд 
      <literal>TERM</literal> эсвэл <literal>KILL</literal> дохионуудын оронд шаардлагатай дохиогоо бичих хэрэгтэй.</para>

    <important>
      <para>Санаанд орсон тоотой дохио болгоныг устгана гэдэг бол буруу санаа юм.   &man.init.8; процесс ялангуяа 1 гэсэн процесс ID байх нь онцгой тохиолдол. Тийм болохоор 
	<command>/bin/kill -s KILL 1</command> гэвэл системийг шууд унтраана.  &man.kill.1; тушаалыг гүйцэтгэхээсээ өмнө <keycap>Return</keycap> товч дарахынхаа <emphasis>өмнө</emphasis> <emphasis>үргэлж</emphasis> ямар процесс уруу ямар дохио илгээж байгаагаа давхар шалгах хэрэгтэй.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shell буюу бүрхүүл</title>
    <indexterm><primary>бүрхүүл</primary></indexterm>
    <indexterm><primary>тушаал өгөх орчин</primary></indexterm>

    <para>FreeBSD дээр маш олон ажил тушаал бичиж оруулдаг shell буюу бүрхүүл хэмээх орчинд хийгддэг. Бүрхүүлийн гол үүрэг нь гарнаас оруулсан тушаалыг гүйцэтгэх юм. Өдөр болгон гүйцэтгэхэд шаардагддаг файл зохицуулах, тушаал оруулагч мөрийг засварлах, тушаалын багц, орчны хувьсагч зэрэг туслах тушаалуудыг олон бүрхүүлүүд агуулж байдаг.  FreeBSD нь 
      <command>sh</command> буюу Bourne Shell, мөн <command>tcsh</command> буюу 
      сайжруулсан C-shell зэрэг багц бүрхүүлүүдтэй хамт ирдэг. <command>zsh</command> болон <command>bash</command> зэрэг маш олон бүрхүүлүүд FreeBSD-ийн портын цуглуулганд ирдэг.</para>

    <para>Та ямар бүрхүүл хэрэглэдэг вэ? Энэ бол тухайн хүний дур сонирхолтой хамаатай.  Хэрэв та C програмын хэл дээр програм бичдэг бол C-тэй адилхан бичигддэг <command>tcsh</command> төрлийн бүрхүүлд дуртай болж болох юм.  Хэрэв та Linux системээс ирсэн юм уу эсвэл  &unix;-ийн тушаалуудтай дөнгөж танилцаж байгаа шинэ хүн бол <command>bash</command> бүрхүүлээр эхлэх нь амар байж болох юм.  
      Хамгийн гол нь бүрхүүл болгон өөрийн гэсэн онцгой шинж чанартай болохоор өөрийнхөө хүсэл зорилгод тааруулж бүрхүүлээ сонгож дадах нь чухал.</para>

    <para>Бүрхүүлийн хамгийн энгийн чадвар бол файлын нэрийн автомат гүйцэтгэл юм.  Тушаал юм уу файлын эхний хэдхэн үсгийг бичээд гарын  <keycap>Tab</keycap> товчийг дарахад уг үсгээр эхэлсэн файлын нэрийг танд гүйцээж бичиж өгдөг. Энд нэг жишээ авч үзье.
   Танд <filename>foobar</filename> болон <filename>foo.bar</filename> гэсэн хоёр файл байгаа гэж бодъё. Та 
  <filename>foo.bar</filename> файлыг устгахыг хүсэв. Тэгвэл та компьютерийнхаа гаран дээр ингэж бичих болно: <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>Бүрхүүл танд ингэж харуулна <command>rm
      foo[BEEP].bar</command>.</para>

    <para>[BEEP] гэдэг нь консолоос гаргаж байгаа хонхны дуу бөгөөд ингэж эхэлсэн файлын нэр нэгээс олон байгааг танд мэдэгдэж байгаа юм.  <filename>foobar</filename> болон
      <filename>foo.bar</filename> хоёр хоёулаа  <literal>fo</literal> гэж эхэлж байгаа ч гэсэн  
      <literal>foo</literal> гэж танд дүүргэж өгдөг. Хэрэв та
      <literal>.</literal> гэж бичээд <keycap>Tab</keycap> дахин дарвал бүрхүүл танд уг хүссэн файлын тань нэрийг гүйцээж өгдөг.</para>
    <indexterm><primary>орчны хувьсагчид</primary></indexterm>

    <para>Бүрхүүлийн бас нэг шинж чанар бол орчны хувьсагчийн хэрэглээ юм.
      Орчны хувьсагч гэдэг нь бүрхүүлийн орчинд хадгалагддаг, нэрэнд утга өгсөн хослол байдаг.  Энэ бүрхүүлийн орчин нь уг бүрхүүлээс гүйцэтгэгдэж байгаа бүх програм болон програмын тохируулгад харагдаж байдаг. Байнга хэрэглэгддэг ерөнхий орчны хувьсагчдыг дор жагсааж тайлбарлав:</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Хувьсагч</entry>
	    <entry>Тодорхойлолт</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Холбогдсон байгаа тухайн хэрэглэгчийн нэр.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Ачаалагдаж болдог хоёртын файлуудыг агуулдаг сангуудыг таслалаар тусгаарлаж бичсэн жагсаалт.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Хэрэв холбогдох боломжтой бол, X11 дэлгэцийн сүлжээгээр холбогдох цэг.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Хэрэглэж байгаа shell буюу бүрхүүл.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Хэрэглэгчийн терминалын төрлийн нэр.  Терминалын шинж чанарыг тодорхойлоход хэрэглэгддэг.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Төрөл бүрийн терминалуудад алгасах ёстой кодуудын өгөгдлийн бааз.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Үйлдлийн системийн төрөл.  жишээ нь, FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Системийн ажиллаж байгаа процессорын архитектур.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Хэрэглэгчийн эрхэмлэж хэрэглэгддэг текст засварлагч.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Хэрэглэгчийн эрхэмлэж хэрэглэдэг пэйжер.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Таслалаар тусгаарлаж жагсаасан, гарын авлагын хуудсуудыг агуулсан хайх сангууд.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Бүрхүүл болгонд орчны хувьсагчаа өөр өөр тохируулдаг.  Жишээлбэл, C-маягийн бүрхүүл
      <command>tcsh</command> болон <command>csh</command> дээр, та 
      <command>setenv</command> тушаалыг ашиглаж орчны хувьсагчийг зааж өгдөг.
      Bourne төрлийн бүрхүүлүүд болох  <command>sh</command> болон
      <command>bash</command> дээр, та
      <command>export</command> тушаалыг ашиглаж орчны хувьсагчийг зааж өгнө.  Жишээ нь, орчны хувьсагч 
      <envar>EDITOR</envar>-г өөрчлөх юм уу зааж өгөхийн тулд  <command>csh</command> юм уу эсвэл 
      <command>tcsh</command> бүрхүүл дээр 
      <envar>EDITOR</envar> хувьсагчид 
      <filename>/usr/local/bin/emacs</filename> утгыг өгөхийн тулд:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Bourne бүрхүүлүүд дээр:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Ихэнх бүрхүүлийн орчны хувьсагчийн утгыг харахын тулд хувьсагчийн нэрний урд
       <literal>$</literal> тэмдгийг хэрэглэж харна. Жишээ нь, <command>echo $TERM</command> гэсэн тушаал нь 
       <envar>$TERM</envar> хувьсагчид ямар утга байгааг консол дээр харуулна. Учир нь, бүрхүүл
       <envar>$TERM</envar> дотор буй утгыг  <command>echo</command> тушаалд дамжуулж өгснөөр консол дээр харуулагддаг.</para>

    <para>Бүрхүүл маш олон тэмдэгтийг тусгай зориулалтаар өгөгдлийг илэрхийлэхдээ хэрэглэдэг бөгөөд тэдгээр тэмдэгтийг мета-тэмдэгтүүд гэж нэрлэдэг. Байнга хэрэглэгддэг тэмдэгтийн нэг нь 
      <literal>*</literal> юм. Энэ тэмдэгт нь файлын нэрэнд байгаа тэмдэгтүүдийг хэд ч байсан хамаагүй орохыг илэрхийлдэг. Тэдгээр мета-тэмдэгтүүд нь файлын нэрийг орлуулахад байнга хэрэглэгддэг.  Жишээлбэл, 
      <command>echo *</command> гэсэн тушаал нь 
      <command>ls</command> тушаалтай ижилхэн үүрэг гүйцэтгэх бөгөөд, яагаад гэвэл бүрхүүл нь <literal>*</literal> тэмдэгтэд тохирох бүх файлуудыг авч 
      <command>echo</command> тушаал руу дамжуулж харуулдаг.</para>

    <para>Бүрхүүл дээр мета-тэмдэгтүүдийг хэрэв тухайн онцгой тохиолдлоор нь биш харин зүгээр тэмдэгт хэлбэрээр нь хэрэглэхийг хүсвэл, уг тэмдэгтийн урд ташуу зураасыг
      (<literal>\</literal>) бичиж өгдөг.  <command>echo
      $TERM</command> гэсэн тушаал нь ямар терминал заагдсан байгааг харуулна. Харин
      <command>echo \$TERM</command> тушаал нь ердөө  <envar>$TERM</envar> гэж харуулна.</para>

    <sect2 id="changing-shells">
      <title>Өөрийнхөө бүрхүүлийг солих</title>

      <para>Бүрхүүлээ буюу shell-ээ солих хамгийн амархан арга бол
	<command>chsh</command> тушаалыг хэрэглэх юм.  <command>chsh</command> тушаал нь
	таныг <envar>EDITOR</envar> орчны хувьсагчид заагдсан засварлагч уруу оруулдаг бөгөөд
	хэрэв энэ хувьсагчид утга заагдаагүй байвал шууд
	<command>vi</command> засварлагчийг ажиллуулдаг.  Тэгээд та <quote>Shell:</quote> мөрөнд
  буй утгыг өөрчилж бүрхүүлээ өөрчилнө.</para>

      <para>Та мөн <command>chsh</command> тушаалыг
	<option>-s</option> сонголттой хэрэглэж болох бөгөөд ингэсэн үед
    нэмэлт засварлагч нээлгүйгээр шууд бүрхүүлийг өөрчилдөг.  
	Жишээ нь та өөрийнхөө бүрхүүлийг  <command>bash</command> бүрхүүлээр
  солихыг хүсвэл дараа тушаалыг өгөх болно:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Таны хэрэглэхийг хүсэж байгаа бүрхүүл тань 
	  <filename>/etc/shells</filename> файл дотор <emphasis>заавал</emphasis>
    байх ёстой.  Хэрэв та <link linkend="ports">портын цуглуулгаас
	  </link> бүрхүүл суулгасан бол энэ нь автоматаар хийгдчихдэг. Харин та
    гар аргаар ямар нэг бүрхүүл суулгавал энэ файлд өөрөө нэмэх хэрэгтэй.</para>
     
      <para>Жишээ нь та  <command>bash</command> бүрхүүлийг гар аргаар суулгаад
	 <filename>/usr/local/bin</filename> байршилд байрлуулсан бол дараах тушаалыг
   өгөх хэрэгтэй:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Тэгээд дараа нь <command>chsh</command> тушаалыг хэрэглэх хэрэгтэй.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Текст засварлагчид</title>
    <indexterm><primary>текст засварлагчид</primary></indexterm>
    <indexterm><primary>засварлагчид</primary></indexterm>

    <para>FreeBSD дээр текст файлуудыг засварлаж маш олон тохиргоонуудыг хийдэг. 
      Тийм болохоор та текст засварлагч дээр гаршиж сурах нь чухал.
      FreeBSD нь үндсэн хэдэн засварлагчтай хамт ирдэг бөгөөд портын цуглуулга
      дээрээ бол олон зуун засварлагчтай.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>засварлагчид</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>Хамгийн амархан бөгөөд сурахад хялбар засварлагч бол
      <application>ee</application> бөгөөд easy editor буюу хялбар засварлагч гэдгийг
      товчилсон нэр юм. <application>ee</application>-г эхлүүлэхийн тулд тушаал бичих
      мөрөнд <command>ee <replaceable>файлын-нэр</replaceable></command> гэж бичих бөгөөд
      <replaceable>файлын-нэр</replaceable> нь засварлагдах файлын нэр.
      Жишээ нь, <filename>/etc/rc.conf</filename> файлыг засварлахын тулд
      <command>ee /etc/rc.conf</command> гэж бичнэ.  
      <command>ee</command> засварлагч дотроо дээд хэсэгт нь програмыг хэрэглэх 
      заавар нь бичээстэй байдаг. <literal>^</literal> гэсэн тэмдэг нь гарын
      <keycap>Ctrl</keycap> товчийг илэрхийлдэг бөгөөд <literal>^e</literal> гэдэг нь 
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo> гэсэн
      гарын товчлол юм.  
      <application>ee</application> програмаас гарахын тулд <keycap>Esc</keycap> товч
      дараад leave editor буюу засварлагчаас гарна гэдгийг сонгох хэрэгтэй. 
      Хэрэв файлд өөрчлөлт орсон бол гарахаас өмнө хадгалах эсэхийг лавлаж асуух болно.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>засварлагчид</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>Мөн FreeBSD нь 
      <application>vi</application> гэсэн хүчирхэг засварлагчийг системийн
      үндсэн хэсэгтэй цуг зөөвөрлөдөг бөгөөд бас
      <application>Emacs</application> болон <application>vim</application> зэрэг
      зaсварлагчдыг FreeBSD Портын цуглуулгадаа багтаасан байдаг
      (<filename role="package">editors/emacs</filename> болон <filename role="package">editors/vim</filename>).  
      Эдгээр засварлагчид нь ажиллах хүчин чадвараараа илүү боловч сурахад арай илүү төвөгтэй байдаг. 
	Гэвч та текст файлыг засварлахад маш их хөдөлмөр гаргахаар бол
      <application>vim</application> эсвэл <application>Emacs</application>
      програмуудыг сурснаар таны цаг болон хөдөлмөрийг цаашид улам илүү хөнгөвчлөх болно.</para>

    <para>Файлууд засварладаг эсвэл бичихийг шаарддаг олон програм 
      текст засварлагчийг автоматаар нээдэг. Ашиглагдах анхдагч засварлагчийг 
      өөрчлөхийн тулд <envar>EDITOR</envar> орчны хувьсагчийг 
      тохируулах хэрэгтэй. Дэлгэрэнгүйг <link linkend="shells">Бүрхүүлүүд</link>
      хэсгээс үзнэ үү.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Төхөөрөмж ба төхөөрөмжийн цэгүүд</title>

    <para>Төхөөрөмж гэдэг ойлголт нь голдуу 
      системд буй төхөөрөмж болох диск, хэвлэгч, график карт, 
      мөн гар зэрэг ордог.  FreeBSD эхэлж ачаалах үедээ, 
      гол чухал таньсан төхөөрөмжүүдээ харуулдаг.
      Ингэж эхлэхдээ харуулсан бичлэгийг та дахин харахыг хүсвэл 
      <filename>/var/run/dmesg.boot</filename> файлыг хараарай.</para>

    <para>Жишээ нь, <devicename>acd0</devicename> гэдэг нь
      эхний IDE CDROM төхөөрөмж байхад, <devicename>kbd0</devicename>
      гэдэг нь гарыг илэрхийлж байдаг.</para>

    <para> &unix; үйлдлийн систем нь эдгээр төхөөрөмж уруу хандахдаа
      төхөөрөмжийн цэг гэж нэрлэгдэх тусгай файл уруу ханддаг. Эдгээр
      төхөөрөмжийн цэгүүд нь 
       <filename>/dev</filename> санд байдаг.</para>

    <sect2>
      <title>Төхөөрөмжийн цэг үүсгэх</title>
      <para>Хэрэв системд шинэ төхөөрөмж нэмэгдвэл, эсвэл нэмэлт
      төхөөрөмжид зориулсан шаардлага гарвал шинэ төхөөрөмжийн цэг үүсгэх ёстой.</para>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System буюу төхөөрөмжийн файл систем)</title>

	<para> Төхөөрөмжийн файл систем буюу <literal>DEVFS</literal> нь ерөнхий файлын 
  системийн нэрийн талбарын цөм дахь төхөөрөмжийн нэрийн талбарт хандах боломжийг өгдөг.
	  Төхөөрөмжийн цэгийг үүсгэх эсвэл өөрчлөх зэрэг үйлдлийг 
	  <literal>DEVFS</literal> нь бидэнд хийж өгч амар болгож өгдөг.</para>

	<para>&man.devfs.5; гарын авлагаас нэмэлт мэдээллийг харна уу.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Хоёртын хэлбэрүүд</title>

    <para>&os; яагаад &man.elf.5; хэлбэр хэрэглэдгийг ойлгохын тулд, та
      ачаалагдаж ажилладаг файлын төрлөөс &unix; дээр <quote>ноёлдог</quote>  гурван
    хэлбэрийг мэдэх ёстой:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>&unix;-н хамгийн хуучин бөгөөд <quote>сонгодог</quote> 
          ачаалагддаг файлын хэлбэр.  Энэ нь эхэн хэсэгтээ өөрийнхөө
          хэлбэрийг таниулах зориулалттай шидэт дугаар агуулж байдаг
          (&man.a.out.5; хуудаснаас дэлгэрэнгүй мэдээлэл авна уу). 
          Ачаалагдсан үедээ санах ойд гурван хэсэгт хуваагддаг:
          .text, .data, мөн .bss бөгөөд дээрээс нь хэрэглэгдэх 
          обьектуудыг агуулсан хүснэгт мөн мөрийн хүснэгтийг агуулж байдаг.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>SVR3 обьект хэлбэр. Толгой хэсэгтээ тодорхой зориулалттай
          хүснэгт агуулж байдаг. Тийм болохоор зөвхөн .text, .data,
          болон .bss хэсгүүдээс гадна нэмэлт зүйлс агуулж чадна.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para><acronym>COFF</acronym>-н дараагийн үе. Энэ нь
          олон хэсэг агуулахаас гадна 32-бит эсвэл 64-битийн утга агуулах
          чадвартай. Нэг муу тал бий: <acronym>ELF</acronym> нь тухайн системийн
          архитектурт зөвхөн ганцхан  ABI байгаа гэж авч үздэг.
          SYSV ертөнц (хамгийн багадаа гурван ABI агуулж байдаг: SVR4, Solaris, SCO)
          байсаар байхад ингэж авч үзэх нь буруу юм.</para>

        <para>
          FreeBSD нь энэ хүндрэлийг, ABI-н мэдээлэл агуулсан
          ачаалагддаг <acronym>ELF</acronym> файлуудыг зохицуулдаг 
          <emphasis>branding</emphasis>  хэрэгслийг ашиглаж сайжруулахыг боддог.
          Нэмэлт мэдээллийг 
          &man.brandelf.1; хуудаснаас харна уу.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD нь хуучны <quote>сонгодог</quote> отгоос салбарлаж гарсан тул
      &man.a.out.5; хэлбэрийг хэрэглэж байсан бөгөөд энэ хэлбэрээ 3.X салбар
      гарах хүртэл маш олон BSD хувилбартаа ашиглаж байжээ.
      Хэдийгээр FreeBSD дээр өмнө нь  <acronym>ELF</acronym> хоёртын хэлбэрийг
      хөрвүүлж мөн ажиллуулж (цөм дээр ч гэсэн) болдог байсан ч, 
      FreeBSD нь анхнаасаа <acronym>ELF</acronym> хэлбэрийг анхдагч хэлбэрээ
      болгохыг <quote>татгалзсан</quote> билээ. Яагаад?  Учир нь,
      Линукс систем нь хуваалцдаг кодын сан буюу <quote>Shared-Libraries</quote>  
      -д зориулсан үсэрч ажилладаг хүснэгт, мөн түүнийг      
      хөгжүүлэгчид болон байгууллагад хүндрэлтэй байдаг шалтгаанаар 
      <filename>a.out</filename> хэлбэрээс зайлсхийж <acronym>ELF</acronym>
      хэлбэр рүү шилжих гэж нүсэр хүнд хөдөлмөр зарсан юм. 
      <acronym>ELF</acronym> хэлбэр нь хуваалцдаг кодын сан буюу <quote>Shared-Libraries</quote>
      хүндрэлийг давах боломж олгосон хэрэгслүүдийг санал болгосон бөгөөд тэгээд ч хөгжлийн
      явцад <quote>нэг алхам урд нь</quote> явж байгааг бодож мөн нэг хэлбэрээс 
      нөгөө хэлбэрт шилжүүлэх үйл явцад гарах хүнд зардал байсан ч шилжүүлэхээр шийдсэн юм.
      
      FreeBSD-н кодын санг хуваалцах зарчим нь Sun-н
      &sunos; загвартай ижил бөгөөд хэрэглэхэд тун хялбар.</para>

    <para>Тэгэхээр, яагаад ийм олон хэлбэр байдаг юм бэ?</para>

    <para>Энэ асуултанд хариулахын тулд хуучны, энгийн ажиллах зарчимтай төхөөрөмж
      хэрэглэж байсан бүүдгэр өнгөрсөн цаг уруу буцацгаая.
      Энэ энгийн төхөөрөмж нь энгийн жижигхэн систем дээр л ажиллахыг хүснэ.
      <filename>a.out</filename> нь (PDP-11) төрлийн иймэрхүү энгийн систем
      дээр бүгдийг нь хангаж байлаа. Хүмүүс &unix; системийг ийм энгийн
      системээс үүсгэсэн болохоор 
      хуучны загвар болох Motorola 68k, VAXen зэрэг системтэй зохицохын тулд
      <filename>a.out</filename> хэлбэрийг үлдээсэн юм.</para>

    <para>Тэгтэл дараа нь нэг сүрхий инженер хөвүүн, 
      зохиогдсон төхөөрөмжийн зарим ажиллах сул талыг нөхөж процессорыг илүү хурдан
      ажиллуулах хөнгөхөн програм бичжээ. 
      Энэ програм нь шинэ төрлийн архитектурт (тэр үедээ <acronym>RISC</acronym> гэж
      нэрлэгддэг байсан архитектур) зориулан ажиллахаар бичигдсэн болохоор <filename>a.out</filename>
      хэлбэр нь энэ төхөөрөмжид тохиромжгүй болон хангахуйц сайн биш болж ирэв.
      Тийм болохоор энэ шинэ төхөөрөмжтэй илүү үр дүнтэй ажиллахын тулд 
      илүү олон хэлбэрүүд шинэ загварт зориулж зохиогдож байсан бөгөөд хуучин төрөлд бол
      энгийн <filename>a.out</filename> төрлийг санал болгож болох юм.
      <acronym>COFF</acronym>, <acronym>ECOFF</acronym> мөн өөр илүү хэд хэдэн
      хэлбэр нь алдаануудаа нөхөн дэс дараалан үүсгэгдсээр 
      <acronym>ELF</acronym> хүртэл хөгжжээ.</para>

    <para>
      Мөн цаашлаад програмын хэмжээ хэдийгээр ихэссэн ч дискний (мөн
      санах ойн) хэмжээ харьцангуй бага байсан болохоор хуваалцаж
      болдог кодын сангийн <quote>Shared-Libraries</quote> санаа үүссэн юм. 
      Мөн VM системүүд сайн 
      хөгжиж эхлэв. Хэдийгээр эдгээр сайжруулалт болгон 
      <filename>a.out</filename> хэлбэрийг хэрэглэж байсан ч, шинэ
      боломжууд үүсэх тоолонд энэ хэлбэрийг хэрэглэхгүй болж ирэх нь
      улам ихэссэн билээ. Мөн түүнчлэн, санах ойг хэмнэх үүднээс
      эхлэн ачаалсны дараа өөр тийшээ үсрэх юм уу эсвэл явцын дунд
      код нэмэгдэж болох загваруудыг хүмүүс сонирхож эхлэв. 
      Програмын хэлүүд улам сайжирч хүмүүс програмын үндсэн хэсгийг автоматжуулсан
      код хүсэх болжээ. Энэ бүх боломжуудыг биелүүлэх гэж 
      <filename>a.out</filename> хэлбэрийг маш их олон янзаар яргалсан бөгөөд хэсэгтээ
      л энэ нь ажилладаг байв. Нэг мэдэхэд <filename>a.out</filename> 
      хэлбэр нь ихсэж буй бүх хүндрэлийг зохицуулж чадахааргүй 
      бичлэгийн төвөгтэй болон хэрэглэхэд хэцүү байдалд хүрсэн байна.
      Хэдийгээр энэ хүндрэлүүдийг <acronym>ELF</acronym> хэлбэр нь 
      давдаг боловч шилжих явц нь маш хүндрэлтэй байдаг. 
      Тийм болохоор <acronym>ELF</acronym> хэлбэр руу шилжих төвөг нь 
      <filename>a.out</filename>  хэлбэрийг хэрэглэх төвгөөс их байвал
      <acronym>ELF</acronym> хэлбэр нь хүлээгдэхээс өөр аргагүй болжээ.</para>

    <para>
      Гэвч цаг хугацаа өнгөрсөөр, FreeBSD ба түүний уламжилж гарсан системийн
      хөрвүүлэх хэрэгсэл нь (ялангуяа ассемблер болон дуудагч буюу loader) хоёр замаар
      зэрэг хөгжсөөр байв. FreeBSD салаа нь кодын хуваалцдаг санг нэмж мөн зарим алдааг
      нь залруулсан байна. Үүнийг анх бичсэн GNU-н ард түмэн уг кодоо шинэчилж дахин
      бичээд янз бүрийн хэлбэрүүдийг нэмж болдог болгоод мөн хөрвүүлэгчээс
      хамааралгүй хөрвүүлэгддэг болгох зэрэг цааш нь хөгжүүлжээ.
      Хэдийгээр маш олон хүн FreeBSD дээр хөрвүүлэгчээс хамаарахгүй 
      хөрвүүлэхийг хүссэн боловч FreeBSD-н <application>as</application> болон 
      <application>ld</application>-д зориулсан  хуучин кодноос болоод 
      азгүйтжээ. GNU-н шинэ хэрэгслүүд нь (<application>binutils</application>) 
      хөрвүүлэгчээс хамааралгүй, <acronym>ELF</acronym>, 
      кодын хуваалцдаг сан, C++ өргөтгөл зэргүүдийг хөрвүүлж чаддаг болжээ.
      Мөн цаашлаад маш олон байгууллагууд 
      <acronym>ELF</acronym> хэлбэртэй хоёртын програмуудыг гаргаж эхэлсэн тул
      тэдгээрийг хэрэглэхийн тулд FreeBSD уг хэлбэрийг дэмжих нь зөв гэж шийдсэн юм.</para>

    <para><acronym>ELF</acronym> хэлбэр нь <filename>a.out</filename> хэлбэрийг бодвол
      илүү өргөн хүрээтэй бөгөөд үндсэн системийг илүү өргөжүүлдэг.
      <acronym>ELF</acronym> хэрэгслүүд нь маш сайн зохион байгуулагдсан бөгөөд
      хөрвүүлэгчээс хамаардаггүй болохоор хүмүүсийн хүсэлд яг тохирдог.
      <acronym>ELF</acronym> нь  <filename>a.out</filename> хэлбэрийг бодвол жаахан 
      удаан байж болох боловч үүнийг хэмжиж тодорхойлно гэдэг нь хэцүү билээ. 
      Мөн энэ хоёрыг санах ойд хуудас зохицуулах, эхлэн ажиллах зарчим зэргийг нь харьцуулсан
      маш олон шинж чанарууд байдаг. Тэдгээр шинж чанарууд нь тийм ч чухал биш бөгөөд
      энэ нь зөвхөн ялгаа нь билээ. Одоо бол
      <filename>a.out</filename> хэлбэр нь <filename>GENERIC</filename>
      цөмөөс хасагдсан бөгөөд <filename>a.out</filename> хэлбэрийг ажиллуулдаг байсан цөм нь
      хуучны цөмд тооцогдоно.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Нэмэлт мэдээлэл олж авах нь</title>

    <sect2 id="basics-man">
      <title>Гарын авлага</title>
      <indexterm><primary>гарын авлага</primary></indexterm>

      <para>Ихэнх дэлгэрэнгүй мэдээллүүд нь FreeBSD дээр гарын авлага хэлбэрээр
      оршиж байдаг. Систем дээр ажиллаж байгаа бараг бүх програмууд нь ажиллах болон
      авдаг шинж чанараа тодорхойлсон товч заавар буюу гарын авлагатай хамт ирдэг.
      Тийм гарын авлагыг <command>man</command> тушаалаар харна. 
	<command>man</command> тушаалын хэрэглээ нь тун хялбар:</para>

      <screen>&prompt.user; <userinput>man <replaceable>тушаал</replaceable></userinput></screen>

      <para><literal>тушаал</literal> нь судалж уншихыг хүссэн тушаалын нэр байх ёстой. 
      Жишээлбэл	<command>ls</command> тушаалын тухай мэдээлэл харахыг хүсвэл:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Гарын авлага нь дотроо дараах хэсгүүдэд дугаарлагдаж хуваагддаг:</para>

      <orderedlist>
	<listitem>
	  <para>Хэрэглэгчийн тушаал.</para>
	</listitem>

	<listitem>
	  <para>Системийн дуудлага болон алдааны дугаар.</para>
	</listitem>

	<listitem>
	  <para>C програмын хэлний санд байрлах функц нь.</para>
	</listitem>

	<listitem>
	  <para>Төхөөрөмжийн драйвер.</para>
	</listitem>

	<listitem>
	  <para>Файлын хэлбэр.</para>
	</listitem>

	<listitem>
	  <para>Тоглоом болон бусад салбар.</para>
	</listitem>

	<listitem>
	  <para>Төрөл бүрийн бусад мэдээлэл.</para>
	</listitem>

	<listitem>
	  <para>Системээс санаа тавьж үйлдэх тушаал.</para>
	</listitem>

	<listitem>
	  <para>Цөм хөгжүүлэгч.</para>
	</listitem>
      </orderedlist>

      <para>Зарим тохиолдолд гарын авлагын зарим бүлэг нь саяны хуваасан хэсэгт бүрд
      ижил байдаг. Жишээлбэл <command>chmod</command> тушаалыг хэрэглэгч нэг янзаар хэрэглэж
      байхад систем бас <function>chmod()</function> тушаалыг өөр зорилгоор хэрэглэдэг.
      Энэ тохиолдолд та системд  аль сэдвээ сонгож байгаагаа ойлгуулахын 
      тулд харгалзах дугаарыг нь өгөх ёстой:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Энэ тохиолдолд <command>chmod</command> тушаалыг хэрэглэгч яаж дуудаж хэрэглэх 
         тухай харуулна. Гарын авлагын тухайн хэсгийг нь харахын тулд голдуу
         хаалт дотор тухайн хэсгийн дугаарыг нь бичиж ханддаг. Тэгэхээр &man.chmod.1; гэвэл
         хэрэглэгчид хамаатай хэсэг нь, &man.chmod.2; гэвэл системд хамаатай хэсэг харуулагдана.</para>

      <para>Хэрэв та тушаалынхаа нэрийг мэдэж байвал энэ аргаар маш амархан 
      хэрэглэх зааврыг уншиж чадахаар боллоо. Гэтэл та тушаалынхаа нэрийг мэдэхгүй
      тохиолдолд яах вэ? Энэ үед та <command>man</command> тушаалд тухайн хэрэгтэй
        тушаалын зааварт хайх түлхүүр үгийг  <option>-k</option> сонголт ашиглан зааж өгч болдог.
:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Энэ тохиолдолд, заавартаа <quote>mail</quote> гэдэг үг агуулсан 
      тушаалуудыг жагсааж танд харуулна. Энэ арга нь үндсэндээ 
      <command>apropos</command> тушаалын үүрэгтэй ижил болно.</para>

      <para>За тэгэхээр, таны 
	<filename>/usr/bin</filename> санд маш их олон тушаалууд байгааг та мэддэг мөртлөө
  ямар үйлдэл хийдгийг нь сайн мэдэхгүй тохиолдолд яах вэ?  Хамгийн амархан арга бол:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>эсвэл</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>энэ хоёр хоёулаа ижилхэн үйлдэл хийдэг.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info файлууд</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD нь Free Software Foundation (FSF) буюу Чөлөөт Програмын Сангаас
      бүтээсэн маш олон програмуудыг агуулж байдаг. Гарын авлага хуудаснаас гадна
      эдгээр програмууд нь мөн нэмэлт текст загвартай
	<literal>info</literal> файл агуулж байдаг бөгөөд уг төрлийн мэдээлэл нь
	<command>info</command> тушаалаар харуулагддаг. Хэрэв та
	<application>emacs</application>-г суулгасан бол 
	<application>emacs</application>-н info горимд бас харж болно.</para>

      <para>&man.info.1; тушаалыг хэрэглэхийн тулд ердөө:</para>

      <screen>&prompt.user; <userinput>info тушаал</userinput></screen>

      <para>Товч тайлбарыг нь харахын тулд <literal>h</literal> дарна. Тушаалын
      түргэн зааврыг харахын тулд <literal>?</literal> гэж дараарай.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
