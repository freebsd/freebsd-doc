<?xml version="1.0" encoding="iso-8859-7"?>
<!--

  Το Εγχειρίδιο του FreeBSD: Βασικές Έννοιες στο Unix

  The FreeBSD Greek Documentation Project

  $FreeBSD$

  %SOURCE%      en_US.ISO8859-1/books/handbook/basics/chapter.xml
  %SRCID%       38826

-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <info><title>Βασικές Έννοιες στο &unix;</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Αναθεωρημένο από τον </contrib></author>
    </authorgroup>
    
  </info>

  

  <sect1 xml:id="basics-synopsis">
    <title>Σύνοψη</title>

    <para>Το ακόλουθο κεφάλαιο θα καλύψει τις βασικές εντολές και
      λειτουργίες του λειτουργικού συστήματος &os;.  Το μεγαλύτερο μέρος
      αυτής της ύλης σχετίζεται με όλα τα Λ.Σ. που είναι βασισμένα
      στο &unix;.  Εάν η ύλη σας φαίνεται οικεία μπορείτε να διατρέξετε
      γρήγορα αυτό το κεφάλαιο.  Εάν - αντιθέτως - είστε νέος στο &os;
      τότε οπωσδήποτε θα πρέπει να διαβάσετε προσεκτικά ολόκληρο το
      κεφάλαιο.</para>

    <para>Μετά την ανάγνωση του κεφαλαίου, θα γνωρίζετε:</para>

    <itemizedlist>
      <listitem>
	<para>Πως να χρησιμοποιείτε τις <quote>εικονικές κονσόλες</quote> του
	  &os;.</para>
      </listitem>

      <listitem>
	<para>Πως λειτουργούν οι άδειες αρχείων στο &unix; και
	  θα καταλάβετε την χρήση των file flags στο &os;.</para>
      </listitem>

      <listitem>
	<para>Την προεπιλεγμένη διάταξη του συστήματος αρχείων του
	  &os;.</para>
      </listitem>

      <listitem>
	<para>Την οργάνωση των δίσκων στο &os;.</para>
      </listitem>

      <listitem>
	<para>Τι είναι και πώς λειτουργεί η προσάρτηση (mount) και
	  αποπροσάρτηση (unmount) συστημάτων αρχείων.</para>
      </listitem>

      <listitem>
	<para>Τι είναι οι διεργασίες (processes), τα σήματα (signals) και
	  οι δαίμονες (daemons).</para>
      </listitem>

      <listitem>
	<para>Τι είναι το κέλυφος (shell) και πως να αλλάζετε το προεπιλεγμένο
	  περιβάλλον εργασίας.</para>
      </listitem>

      <listitem>
	<para>Πως να χρησιμοποιείτε βασικά προγράμματα επεξεργασίας κειμένου
	  (editors).</para>
      </listitem>

      <listitem>
	<para>Τι είναι οι συσκευές (devices) και τα αρχεία συσκευής (device
	  nodes).</para>
      </listitem>

      <listitem>
	<para>Ποια έκδοση εκτελέσιμων χρησιμοποιείται στο &os;.</para>
      </listitem>

      <listitem>
	<para>Πως να διαβάζετε τις σελίδες βοηθείας (manual pages) για
	  περισσότερες πληροφορίες.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Εικονικές Κονσόλες και Τερματικά </title>
    <indexterm><primary>εικονικές κονσόλες</primary></indexterm>
    <indexterm><primary>τερματικά</primary></indexterm>

    <para>Μπορείτε να χειριστείτε το &os; με διάφορους τρόπους.  Ένας από
      αυτούς, είναι πληκτρολογώντας εντολές κειμένου σε ένα τερματικό.  Με
      αυτό τον τρόπο έχετε στα χέρια σας ένα ευέλικτο και δυνατό λειτουργικό
      σύστημα &unix;.  Αυτή η ενότητα περιγράφει τι είναι τα
      <quote>τερματικά</quote> και οι <quote>κονσόλες</quote> και πως μπορούν
      να χρησιμοποιηθούν στο &os;.</para>

    <sect2 xml:id="consoles-intro">
      <title>Η Κονσόλα</title>
      <indexterm><primary>κονσόλα</primary></indexterm>

      <para>Εάν δεν έχετε ρυθμίσει το &os; να ξεκινά αυτόματα κάποιο γραφικό
	περιβάλλον εργασίας, τότε αμέσως μετά την εκκίνηση του συστήματος και
	την ολοκλήρωση των σεναρίων εκκίνησης (startup scripts) θα εμφανιστεί
	η προτροπή σύνδεσης (login prompt).  Θα δείτε κάτι παρόμοιο στην οθόνη
	σας:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Το μήνυμα μπορεί να είναι λίγο διαφορετικό στο σύστημα σας, αλλά
	δεν πρέπει να διαφέρει κατά πολύ.  Θα εστιάσουμε την προσοχή μας στις
	τελευταίες δύο γραμμές.  Η προτελευταία γραμμή αναφέρει:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Αυτή η γραμμή περιέχει μερικές πληροφορίες για το σύστημα που
	μόλις εκκινήσατε.  Έχετε μπροστά σας μια κονσόλα
	<quote>FreeBSD</quote>, που τρέχει με επεξεργαστή αρχιτεκτονικής x86
	της Intel ή άλλον συμβατό

	<footnote>
	  <para>Αυτό ακριβώς σημαίνει το <literal>i386</literal>.  Ακόμη και
	    αν δεν χρησιμοποιείτε επεξεργαστή Intel 386 CPU στο &os; σύστημα
	    σας, θα εμφανίζεται το <literal>i386</literal>.  Αυτή είναι η
	    <quote>αρχιτεκτονική</quote>, κατασκευής του επεξεργαστή και όχι
	    το μοντέλο του επεξεργαστή.</para>
	</footnote>.

	Το όνομα αυτής της μηχανής (όλες οι μηχανές &unix; έχουν κάποιο
	όνομα) είναι <systemitem>pc3.example.org</systemitem>, και έχετε ανοικτό
	μπροστά σας το τερματικό <filename>ttyv0</filename> &mdash;
	κονσόλα του συστήματος.</para>

      <para>Ολοκληρώνοντας, η τελευταία γραμμή είναι πάντα:</para>

      <programlisting>login:</programlisting>

      <para>Σε αυτό το μέρος θα πρέπει να πληκτρολογήσετε το <quote>όνομα
	χρήστη</quote> (username) για να συνδεθείτε στο &os;.  Στην επόμενη
	ενότητα θα περιγράψουμε ακριβώς αυτήν την διαδικασία.</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>Εισαγωγή Χρήστη στο Σύστημα &os;</title>

      <para>Το &os; είναι ένα σύστημα πολυχρηστικό (multiuser) και
	πολυεπεξεργαστικό (multiprocessing).  Αυτός είναι ο ακαδημαϊκός
	ορισμός που δίνεται συνήθως σε ένα σύστημα που μπορεί να
	χρησιμοποιείται από πολλούς διαφορετικούς ανθρώπους, ενώ ταυτόχρονα
	τρέχουν διαφορετικά προγράμματα στην ίδια μηχανή.</para>

      <para>Κάθε σύστημα multiuser χρειάζεται κάποιους τρόπους ώστε να
	ξεχωρίζει κάθε <quote>χρήστη</quote> από τους υπολοίπους.  Στο &os;
	(όπως και σε όλα τα Λ.Σ. που βασίζονται στο &unix;), αυτό
	επιτυγχάνεται απαιτώντας κάθε χρήστης να <quote>είναι συνδεδεμένος
	(log in)</quote> πριν να μπορεί να τρέξει προγράμματα.  Κάθε χρήστης
	έχει ξεχωριστό όνομα (το <quote>όνομα χρήστη ή username</quote>) και
	μία προσωπική δικλείδα ασφαλείας, (τον <quote>κωδικό πρόσβασης ή
	password</quote>).  Αυτά θα ζητηθούν από το &os; σε κάθε χρήστη πριν
	να του επιτραπεί να τρέξει οποιαδήποτε εφαρμογή.</para>

      <indexterm><primary>startup scripts</primary></indexterm>

      <para>Αμέσως μετά την ολοκλήρωση των διεργασιών εκκίνησης του &os; και
	των σεναρίων εκκίνησης (startup scripts)

	<footnote>
	  <para>Τα σενάρια εκκίνησης (startup scripts) είναι προγράμματα που
	    τρέχουν αυτόματα κατά την εκκίνηση του &os;.  Η κύρια λειτουργία
	    τους είναι να βοηθούν στην σωστή λειτουργία όλων των συστατικών
	    του συστήματος, και να ξεκινούν όλες τις υπηρεσίες που έχετε
	    ρυθμίσει να τρέχουν στο παρασκήνιο.</para>
	</footnote>,

	θα εμφανιστεί το σύμβολο της προτροπής (prompt) και θα σας ζητηθεί ένα
	έγκυρο όνομα χρήστη:</para>

      <screen>login:</screen>

      <para>Για παράδειγμα, ας υποθέσουμε πως το όνομα χρήστη σας είναι
	<systemitem class="username">john</systemitem>.  Πληκτρολογήστε <literal>john</literal>
	στην προτροπή και πατήστε <keycap>Enter</keycap>.  Θα ακολουθήσει μια
	νέα προτροπή για να δώσετε τον
	<quote>κωδικό πρόσβασης (password)</quote>:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Πληκτρολογήστε τώρα τον κωδικό πρόσβασης του
	<systemitem class="username">john</systemitem>, και πατήστε <keycap>Enter</keycap>.  Ο
	κωδικός πρόσβασης <emphasis>δεν είναι ορατός!</emphasis>  Δεν
	χρειάζεται να ανησυχείτε για αυτό.  Είναι επαρκές να πούμε πως αυτό
	συμβαίνει για λόγους ασφαλείας.</para>

      <para>Αν έχετε πληκτρολογήσει σωστά τον κωδικό πρόσβασης, τότε έχετε
	συνδεθεί στο &os; και είστε έτοιμοι να δοκιμάσετε όλες τις διαθέσιμες
	εντολές &unix;.</para>

      <para>Πρέπει να δείτε το <acronym>MOTD</acronym> ή αλλιώς το ημερήσιο
	μήνυμα και στη συνέχεια την προτροπή εντολής (ένα
	χαρακτήρα <literal>#</literal>, <literal>$</literal>, ή
	<literal>%</literal>).  Αυτό σημαίνει πως έχετε συνδεθεί επιτυχώς στο
	&os;.</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>Πολλαπλές Κονσόλες</title>

      <para>Η εκτέλεση εντολών &unix; σε μία μόνο κονσόλα μπορεί να είναι
	ικανοποιητική, αλλά το &os; μπορεί να τρέχει ταυτόχρονα πολλά
	προγράμματα.  Η ύπαρξη μίας μόνο κονσόλας για πληκτρολόγηση εντολών
	θα ήταν πραγματικά ελλιπής για ένα Λ.Σ. όπως το &os; που μπορεί να
	τρέχει ταυτόχρονα δεκάδες προγράμματα.  Εδώ είναι που χρειάζονται οι
	<quote>εικονικές κονσόλες</quote>.</para>

      <para>Το &os; μπορεί να ρυθμιστεί κατάλληλα ώστε να παρουσιάζεται με
	διάφορες εικονικές κονσόλες.  Η εναλλαγή από μία εικονική κονσόλα
	σε οποιαδήποτε άλλη μπορεί να γίνει πατώντας μερικά πλήκτρα στο
	πληκτρολόγιο.  Η κάθε κονσόλα έχει το δικό της κανάλι εξόδου, και
	καθώς εναλλάσσετε εικονικές κονσόλες το &os; αποθηκεύει και επαναφέρει
	προσεκτικά το αντίστοιχο πληκτρολόγιο και οθόνη για κάθε κονσόλα σαν
	να υπήρχε πραγματική εναλλαγή.</para>

      <para>Συνδυασμοί ειδικών πλήκτρων χρησιμοποιούνται από το &os; για την
	εναλλαγή κονσολών

	<footnote>
	  <para>Για όλες τις τεχνικές λεπτομέρειες και ακριβείς περιγραφές
	    των οδηγών (drivers) που χρησιμοποιούνται στο &os; για κονσόλες
	    και πληκτρολόγια μπορείτε να βρείτε στις σελίδες &man.syscons.4;,
	    &man.atkbd.4;, &man.vidcontrol.1; και &man.kbdcontrol.1;
	    των σελίδων βοήθειας (manual pages).  Δεν θα συνεχίσουμε
	    περαιτέρω, αλλά ο ενδιαφερόμενος αναγνώστης μπορεί να
	    συμβουλεύεται πάντα τις σελίδες βοηθείας για περισσότερο
	    λεπτομερή και ολοκληρωμένη επεξήγηση των λειτουργιών.</para>
	</footnote>.

	Μπορείτε να χρησιμοποιήσετε
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>,έως
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> για να
	μεταβείτε στις διάφορες εικονικές κονσόλες του &os;.</para>

      <para>Καθώς εναλλάσσεστε από τη μία κονσόλα στην άλλη, το &os;
	αποθηκεύει και επαναφέρει προσεκτικά την αντίστοιχη οθόνη.  Το
	αποτέλεσμα είναι ένα <quote>οπτικό τρικ</quote> σαν να είχαμε
	πολλαπλές <quote>εικονικές</quote> οθόνες και πληκτρολόγια που θα
	μπορούσαμε να χρησιμοποιήσουμε για να τρέχουμε εντολές στο &os;.
	Τα προγράμματα που τρέχετε από μια κονσόλα δεν σταματούν να
	λειτουργούν όταν η κονσόλα δεν είναι ορατή.  Συνεχίζουν να τρέχουν κι
	όταν βρίσκεστε σε διαφορετική κονσόλα.</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title>Το Αρχείο <filename>/etc/ttys</filename></title>

      <para>Η εξ' ορισμού ρύθμιση του &os; θα ξεκινήσει με οκτώ εικονικές
	κονσόλες.  Δεν πρόκειται για μια πολύπλοκη ρύθμιση και μπορείτε εύκολα
	να την αλλάξετε ώστε να φορτώνονται περισσότερες ή λιγότερες εικονικές
	κονσόλες κατά την εκκίνηση.  Το πλήθος και η παραμετροποίηση των
	εικονικών κονσολών ρυθμίζεται στο αρχείο
	<filename>/etc/ttys</filename>.</para>

      <para>Μπορείτε να χρησιμοποιήσετε το αρχείο
	<filename>/etc/ttys</filename> για να ρυθμίσετε τις εικονικές κονσόλες
	στο &os;.  Κάθε γραμμή του αρχείου που δεν είναι σχόλιο (οι γραμμές
	που δεν ξεκινούν με τον χαρακτήρα <literal>#</literal>) περιέχουν
	ρυθμίσεις για ένα τερματικό ή για μια εικονική κονσόλα.  Η
	προκαθορισμένη έκδοση του αρχείου, η οποία περιέχεται στην διανομή
	&os;, περιέχει εννέα εικονικές κονσόλες, εκ των οποίων οι οκτώ είναι
	ενεργοποιημένες.  Είναι στις γραμμές που ξεκινούν με
	<literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Για μια λεπτομερή περιγραφή κάθε στήλης του αρχείου και όλων των
	ρυθμίσεων που μπορούν να εφαρμοστούν για τις εικονικές κονσόλες
	συμβουλευτείτε την σελίδα βοηθείας &man.ttys.5;.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Κονσόλα σε Κατάσταση Ενός Χρήστη</title>

      <para>Μπορείτε να βρείτε μια λεπτομερή περιγραφή για το τι είναι
	<quote>κατάσταση ενός χρήστη</quote> στην ενότητα
	<xref linkend="boot-singleuser"/>.  Αξίζει να αναφέρουμε πως υπάρχει
	ενεργή μόνο μία κονσόλα όταν τρέχετε το &os; σε κατάσταση ενός
	χρήστη.  Δεν υπάρχουν διαθέσιμες εικονικές κονσόλες.  Στο
	αρχείο <filename>/etc/ttys</filename> μπορείτε να βρείτε τις
	ρυθμίσεις σε κατάσταση ενός χρήστη.  Αναζητήστε την γραμμή που ξεκινά
	με <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
	<para>Όπως αναφέρουν τα σχόλια πάνω από το <literal>console</literal>,
	  μπορείτε να επεξεργαστείτε αυτήν τη γραμμή και να αντικαταστήσετε
	  την λέξη <literal>secure</literal> με <literal>insecure</literal>.
	  Σε αυτή την περίπτωση κατά την εκκίνηση του &os; σε κατάσταση ενός
	  χρήστη, θα σας ζητηθεί ο κωδικός πρόσβασης του υπερχρήστη
	  <systemitem class="username">root</systemitem>.</para>

	<para><emphasis>Προσέχετε όταν κάνετε την μετατροπή σε
	  <literal>insecure</literal></emphasis>.  Εάν τύχει να ξεχάσετε τον
	  κωδικό πρόσβασης του <systemitem class="username">root</systemitem>, η πρόσβαση σε
	  κατάσταση λειτουργίας ενός χρήστη μπορεί να γίνει δύσβατη.  Υπάρχει
	  ακόμη τρόπος να κάνετε εκκίνηση, αλλά ίσως να είναι δύσκολο για
	  κάποιον που δεν γνωρίζει πολλά για τις διεργασίες και τα
	  προγράμματα εκκίνησης του &os;.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Αλλάζοντας την Ανάλυση (video mode) της Κονσόλας</title>

      <para>Η προεπιλεγμένη απεικόνιση της κονσόλας στο &os; μπορεί να
	ρυθμιστεί σε ανάλυση 1024x768, 1280x1024, ή σε οποιοδήποτε άλλο
	μέγεθος υποστηρίζεται από την κάρτα γραφικών και την οθόνη σας.  Για
	να χρησιμοποιήσετε διαφορετική ανάλυση, θα πρέπει πρώτα από όλα να
	επαναμεταγλωττίσετε τον πυρήνα σας, και να συμπεριλάβετε τις παρακάτω
	δύο επιλογές:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>Μετά τη μεταγλώττιση του πυρήνα με τις παραπάνω δύο επιλογές,
	μπορείτε να βρείτε ποιες αναλύσεις υποστηρίζονται από το υλικό σας,
	χρησιμοποιώντας το βοηθητικό πρόγραμμα &man.vidcontrol.1;.  Για να
	δείτε μια λίστα από τις υποστηριζόμενες αναλύσεις, δώστε την ακόλουθη
	εντολή:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Η έξοδος της εντολής αυτής, είναι μια λίστα από αναλύσεις οθόνης
	που υποστηρίζονται από το υλικό σας.  Μπορείτε έπειτα να επιλέξετε
	μια νέα ανάλυση, δίνοντας την ως όρισμα στην &man.vidcontrol.1; σε
	μια κονσόλα που έχετε συνδεθεί ως <systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Αν η νέα ανάλυση γίνει δεκτή, μπορείτε να την ορίσετε ως
	προεπιλεγμένη για κάθε εκκίνηση, με την κατάλληλη ρύθμιση στο αρχείο
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Άδειες (Permissions)</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>Το &os; είναι απόγονος του BSD &unix;, και για αυτό το λόγο
      βασίζεται σε μερικές έννοιες κλειδιά του &unix;.  Η πρώτη και πιο
      σημαντική είναι πως το &os; είναι ένα πολυχρηστικό (multiuser)
      λειτουργικό σύστημα.  Το σύστημα μπορεί να εξυπηρετήσει πολλούς χρήστες
      που εργάζονται ταυτόχρονα και σε εντελώς ανεξάρτητες εφαρμογές.
      Το σύστημα είναι υπεύθυνο για τον σωστό διαμοιρασμό και τις ανάγκες
      διαχείρισης συσκευών hardware, περιφερειακών, μνήμης, και την σωστή
      κατανομή των πόρων της CPU για κάθε χρήστη.</para>

    <para>Επειδή το σύστημα έχει την ικανότητα να εξυπηρετεί πολλούς χρήστες,
      σε οτιδήποτε διαχειρίζεται, υπάρχει μια ομάδα αδειών που ορίζει ποιος
      μπορεί να διαβάσει, να γράψει και να εκτελέσει αυτούς τους πόρους.  Οι
      άδειες αποθηκεύονται σε οκτάδες διαχωρισμένες σε τρία μέρη, ένα για τον
      ιδιοκτήτη του αρχείου, ένα για την ομάδα στην οποία ανήκει το αρχείο,
      και ένα μέρος για όλους τους άλλους.  Στη συνέχεια παρουσιάζεται πίνακας
      με τις αντιστοιχίες μεταξύ των ομάδων αδειών και των αριθμητικών τους
      τιμών.</para>

    <indexterm><primary>άδειες</primary></indexterm>
    <indexterm>
      <primary>άδειες αρχείων</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Τιμή</entry>
	    <entry>Άδεια</entry>
	    <entry>Εμφάνιση σε περιεχόμενα καταλόγων</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Ανάγνωση:όχι, Εγγραφή:όχι, Εκτέλεση:όχι</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Ανάγνωση:όχι, Εγγραφή:όχι, Εκτέλεση:ναι</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Ανάγνωση:όχι, Εγγραφή:ναι, Εκτέλεση:όχι</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Ανάγνωση:όχι, Εγγραφή:ναι, Εκτέλεση:ναι</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Ανάγνωση:ναι, Εγγραφή:όχι, Εκτέλεση:όχι</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Ανάγνωση:ναι, Εγγραφή:όχι, Εκτέλεση:ναι</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Ανάγνωση:ναι, Εγγραφή:ναι, Εκτέλεση:όχι</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Ανάγνωση:ναι, Εγγραφή:ναι, Εκτέλεση:ναι</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directories</primary></indexterm>

    <para>Μπορείτε να χρησιμοποιήσετε την εντολή &man.ls.1; με πρόθεμα
      <option>-l</option> στην γραμμή εντολών για να δείτε τα περιεχόμενα
      καταλόγου και παρατηρήστε πως περιέχεται μια στήλη με τις άδειες των
      αρχείων για τον ιδιοκτήτη, την ομάδα, και για όλους τους άλλους.  Για
      παράδειγμα, αν δώσουμε <command>ls -l</command> σε ένα τυχαίο
      κατάλογο:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Η πρώτη στήλη που παίρνουμε με την εντολή <command>ls -l</command>
      διαχωρίζεται ως εξής:</para>

    <screen>-rw-r--r--</screen>

    <para>Ο πρώτος χαρακτήρας (από τα αριστερά) μας ενημερώνει αν πρόκειται
      για ένα κανονικό αρχείο, κατάλογο, ειδική συσκευή χαρακτήρων,
      υποδοχέα (socket), ή οποιαδήποτε άλλo αρχείο ψευδο-συσκευής.  Στην
      περίπτωση μας, το <literal>-</literal> υποδηλώνει ένα κανονικό αρχείο.
      Οι ακόλουθοι τρεις χαρακτήρες, στο παράδειγμα μας,
      <literal>rw-</literal>, ορίζουν τις άδειες για τον ιδιοκτήτη του
      αρχείου.  Οι τρεις επόμενοι χαρακτήρες, <literal>r--</literal>, ορίζουν
      τις άδειες για την ομάδα στην οποία ανήκει το αρχείο.  Οι τελευταίοι
      τρεις χαρακτήρες, <literal>r--</literal>, ορίζουν τις άδειες για τον
      υπόλοιπο κόσμο.  Η παύλα σημαίνει πως η άδεια είναι απενεργοποιημένη.
      Στην περίπτωση του αρχείου μας, οι άδειες έχουν οριστεί ώστε ο
      ιδιοκτήτης να μπορεί να διαβάζει και να γράφει στο αρχείο, η ομάδα να
      μπορεί να διαβάσει το αρχείο, και ο υπόλοιπος κόσμος να μπορεί μόνο να
      διαβάσει το αρχείο.  Σύμφωνα με τον παραπάνω πίνακα, οι άδειες για αυτό
      το αρχείο είναι <literal>644</literal>, όπου καθένα από τα τρία ψηφία
      παρουσιάζει το αντίστοιχο μέρος αδειών του αρχείου.</para>

    <para>Μέχρι εδώ είναι όλα καλά, αλλά όμως πως το σύστημα ελέγχει τις
      άδειες συσκευών; Το &os; μεταχειρίζεται τις περισσότερες συσκευές σαν
      ένα αρχείο το οποίο τα προγράμματα μπορούν να ανοίξουν, να διαβάσουν
      και να γράψουν σε αυτό σαν να ήταν ένα οποιοδήποτε αρχείο.  Αυτά τα
      ειδικά αρχεία συσκευών αποθηκεύονται στον κατάλογο
      <filename>/dev</filename>.</para>

    <para>Το σύστημα μεταχειρίζεται επίσης και τους καταλόγους ως αρχεία.
      Έχουν άδειες ανάγνωσης, εγγραφής και εκτέλεσης.  Το bit που ορίζει την
      εκτέλεση στους καταλόγους έχει ελαφρώς διαφορετικό νόημα από ότι στα
      αρχεία.  Όταν ένας κατάλογος έχει οριστεί εκτελέσιμος, σημαίνει πως
      είναι προσπελάσιμος, δηλαδή είναι επιτρεπτό να περάσουμε σε ένα
      υποκατάλογο του (να κάνουμε <quote>cd</quote>).  Αυτό επίσης σημαίνει
      πως επιτρέπεται η πρόσβαση σε όλα τα γνωστά (αυτό έχει να κάνει με τις
      άδειες των ίδιων των αρχείων) αρχεία.</para>

    <para>Ειδικότερα, για να εμφανίζονται τα περιεχόμενα καταλόγου πρέπει να
      έχει τεθεί άδεια ανάγνωσης (read) στον κατάλογο, ενώ για να διαγραφεί
      ένα αρχείο του οποίου γνωρίζετε το όνομα είναι αναγκαίο να έχουν δοθεί
      οι άδειες εγγραφής (write) <emphasis>και </emphasis> εκτέλεσης (execute)
      στον κατάλογο που περιέχει το αρχείο.</para>

    <para>Υπάρχουν κι άλλα bit αδειών, αλλά χρησιμοποιούνται κυρίως σε
      ειδικές περιπτώσεις όπως σε setuid binaries και sticky directories.  Αν
      θέλετε περισσότερες πληροφορίες για τις άδειες αρχείων και πως να τις
      ορίζετε, συμβουλευτείτε οπωσδήποτε την σελίδα manual
      &man.chmod.1;.</para>

    <sect2>
      <info><title>Συμβολικές Άδειες</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Συνεισφορά του </contrib></author>
	</authorgroup>
      </info>

      
      <indexterm><primary>&gt;άδειες</primary><secondary>συμβολικές</secondary></indexterm>

      <para>Οι συμβολικές άδειες, μερικές φορές αναφέρονται και ως συμβολικές
	εκφράσεις, χρησιμοποιούν χαρακτήρες στην θέση των οκτώ τιμών για να
	θέτουν άδειες σε αρχεία ή καταλόγους.  Οι συμβολικές εκφράσεις
	χρησιμοποιούν την σύνταξη (ποιος) (ενέργεια) (άδειες), όπου είναι
	διαθέσιμες οι ακόλουθες τιμές:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Επιλογή</entry>
	      <entry>Γράμμα</entry>
	      <entry>Σημαίνει</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>(ποιος)</entry>
	      <entry>u</entry>
	      <entry>User (Χρήστης)</entry>
	    </row>

	    <row>
	      <entry>(ποιος)</entry>
	      <entry>g</entry>
	      <entry>Group owner (Ομάδα που ανήκει)</entry>
	    </row>

	    <row>
	      <entry>(ποιος)</entry>
	      <entry>o</entry>
	      <entry>Other (Υπόλοιποι χρήστες)</entry>
	    </row>

	    <row>
	      <entry>(ποιος)</entry>
	      <entry>a</entry>
	      <entry>All (όλοι, <quote>world</quote>)</entry>
	    </row>

	    <row>
	      <entry>(ενέργεια)</entry>
	      <entry>+</entry>
	      <entry>Πρόσθεση αδειών</entry>
	    </row>

	    <row>
	      <entry>(ενέργεια)</entry>
	      <entry>-</entry>
	      <entry>Αφαίρεση αδειών</entry>
	    </row>

	    <row>
	      <entry>(ενέργεια)</entry>
	      <entry>=</entry>
	      <entry>Άμεσος ορισμός αδειών</entry>
	    </row>

	    <row>
	      <entry>(άδειες)</entry>
	      <entry>r</entry>
	      <entry>Read (Ανάγνωση)</entry>
	    </row>

	    <row>
	      <entry>(άδειες)</entry>
	      <entry>w</entry>
	      <entry>Write (Εγγραφή)</entry>
	    </row>

	    <row>
	      <entry>(άδειες)</entry>
	      <entry>x</entry>
	      <entry>Execute (Εκτέλεση)</entry>
	    </row>

	    <row>
	      <entry>(άδειες)</entry>
	      <entry>t</entry>
	      <entry>Sticky bit</entry>
	    </row>

	    <row>
	      <entry>(άδειες)</entry>
	      <entry>s</entry>
	      <entry>Set UID ή GID</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Οι τιμές εισάγονται με την εντολή &man.chmod.1; όπως πριν, αλλά
	με γράμματα.  Για παράδειγμα, θα μπορούσατε να χρησιμοποιήσετε την
	ακόλουθη εντολή για να απαγορεύσετε σε άλλους χρήστες την πρόσβαση στο
	<replaceable>FILE</replaceable>:</para>

      <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

      <para>Μπορούν να γίνουν πάνω από μία αλλαγές στις άδειες ενός αρχείου
	ταυτόχρονα διαχωρίζοντας τις αλλαγές με κόμμα.  Για παράδειγμα, η
	ακόλουθη εντολή θα αφαιρέσει στην ομάδα και στον
	<quote>υπόλοιπο κόσμο</quote> την άδεια εγγραφής, και στη συνέχεια θα
	προσθέσει άδεια εκτέλεσης σε όλους.</para>

      <screen>&prompt.user; <userinput>chmod go-w,a+x FILE</userinput></screen>

<!--
    <para>Οι περισσότεροι χρήστες δεν θα το προσέξουν, αλλά θα πρέπει να
      σημειώσουμε ότι χρησιμοποιώντας την μέθοδο των οκτάδων το μόνο που
      κάνουμε είναι να τίθονται άδειες σε αρχεία.  Δεν προσθέτουμε, ούτε
      σβήνουμε.</para>
-->
    </sect2>

    <sect2>
      <info><title>&os; File Flags</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Συνεισφορά του </contrib></author>
	</authorgroup>
      </info>

      

      <para>Πέρα από τις άδειες αρχείων που συζητήθηκαν πριν από λίγο, το &os;
	υποστηρίζει την χρήση των <quote>file flags.</quote>  Αυτά τα flags
	προσθέτουν ένα επιπρόσθετο επίπεδο ασφαλείας και ελέγχου σε αρχεία,
	αλλά όχι σε καταλόγους.</para>

      <para>Αυτά τα flags προσθέτουν ένα πρόσθετο επίπεδο ελέγχου σε αρχεία,
	διασφαλίζοντας μας πως σε κάποιες περιπτώσεις ακόμη κι ο
	<systemitem class="username">root</systemitem> να μην μπορεί να διαγράψει ή να μετατρέψει
	αρχεία.</para>

      <para>Η μετατροπή των file flags γίνεται με την &man.chflags.1;,
	χρησιμοποιώντας μια απλή διασύνδεση.  Για παράδειγμα, για να
	ενεργοποιήσουμε το flag του συστήματος μη διαγραφής αρχείου στο
	αρχείο <filename>file1</filename>, δίνουμε την ακόλουθη εντολή:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>Για να απενεργοποιήσουμε το flag του συστήματος μη διαγραφής
	αρχείου, απλά δίνουμε την προηγούμενη εντολή με <quote>no</quote>
	μπροστά από το <option>sunlink</option>.  Παρατηρήστε:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Για να δείτε τα flags ενός αρχείου, χρησιμοποιήστε την εντολή
	&man.ls.1; με το πρόθεμα <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo file1</userinput></screen>

      <para>Στην έξοδο θα πρέπει να δείτε κάτι παρόμοιο με το ακόλουθο:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Μερικά flags μπορούν να προστεθούν ή να αφαιρεθούν μόνο από τον
	χρήστη <systemitem class="username">root</systemitem>.  Στις υπόλοιπες περιπτώσεις, ο
	ιδιοκτήτης του αρχείου μπορεί να θέσει αυτά τα flags.  Προτείνουμε
	στους διαχειριστές να διαβάσουν τις σελίδες βοηθείας
	&man.chflags.1; και &man.chflags.2; για περισσότερες
	πληροφορίες.</para>
    </sect2>

    <sect2>
      <info><title>Οι Άδειες setuid, setgid και sticky</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Συνεισφορά από τον </contrib></author>
	</authorgroup>
      </info>

      

      <para>Εκτός από τις άδειες που έχουμε συζητήσει ήδη, υπάρχουν τρεις
	ακόμα τις οποίες κάθε διαχειριστής πρέπει να γνωρίζει.  Πρόκειται για
	τις άδειες <literal>setuid</literal>, <literal>setgid</literal> και
	<literal>sticky</literal>.</para>

      <para>Οι παραπάνω είναι σημαντικές για κάποιες λειτουργίες στο &unix;,
	καθώς παρέχουν λειτουργίες που δεν είναι φυσιολογικά διαθέσιμες στους
	κοινούς χρήστες.  Για να τις κατανοήσετε, θα πρέπει πρώτα να
	καταλάβετε την διαφορά μεταξύ του πραγματικού αναγνωριστικού χρήστη
	(real user ID) και του ενεργού αναγνωριστικού χρήστη (effective user
	ID).</para>

      <para>Το πραγματικό ID του χρήστη, είναι το <acronym>UID</acronym>
	στο οποίο ανήκει, ή με το οποίο ξεκινά, μια διεργασία.  Το ενεργό
	<acronym>UID</acronym>, είναι το αναγνωριστικό χρήστη το οποίο
	εκτελεί την διεργασία.  Για παράδειγμα, το βοηθητικό πρόγραμμα
	&man.passwd.1; εκτελείται με το πραγματικό ID του χρήστη που αλλάζει
	τον κωδικό του.  Ωστόσο, για να μπορεί να διαχειριστεί την βάση
	δεδομένων με τους κωδικούς του συστήματος, το πρόγραμμα αυτό
	χρησιμοποιεί ως ενεργό ID αυτό του χρήστη <systemitem class="username">root</systemitem>.
	Με αυτό τον τρόπο, επιτρέπεται στους απλούς χρήστες να αλλάζουν τους
	κωδικούς τους χωρίς να παίρνουν το μήνυμα λάθους
	<errorname>Permission Denied</errorname> (απαγόρευση
	πρόσβασης).</para>

      <note>
	<para>Η επιλογή <literal>nosuid</literal> στην εντολή &man.mount.8;
	  θα προκαλέσει αποτυχία εκτέλεσης αυτών των εντολών, και μάλιστα
	  χωρίς κάποιο μήνυμα λάθους.  Με λίγα λόγια, η εκτέλεση τους θα
	  αποτύχει, και ο χρήστης δεν θα ενημερωθεί για αυτό.  Η επιλογή
	  αυτή δεν είναι επίσης απόλυτα ασφαλής, καθώς (σύμφωνα με τη σελίδα
	  manual &man.mount.8;) υπάρχει τρόπος να παρακαμφθεί μέσω κάποιου
	  ενδιάμεσου <literal>nosuid</literal> προγράμματος (wrapper).</para>
      </note>

      <para>Μπορείτε να καθορίσετε την άδεια setuid, τοποθετώντας τον αριθμό
	τέσσερα (4) μπροστά από το γενικό σετ των αδειών, όπως φαίνεται
	στο ακόλουθο παράδειγμα:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>Οι άδειες στο αρχείο
	<filename>suidexample.sh</filename> θα
	φαίνονται τώρα όπως παρακάτω:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>Παρατηρήστε στο παράδειγμα, ότι το <literal>s</literal> είναι
	πλέον μέλος του συνόλου αδειών που έχουν καθοριστεί για τον ιδιοκτήτη
	του αρχείου, και έχει αντικαταστήσει την αντίστοιχη άδεια εκτέλεσης.
	Με τον τρόπο αυτό λειτουργούν προγράμματα που χρειάζονται αυξημένα
	δικαιώματα, όπως για παράδειγμα η εντολή
	<command>passwd</command>.</para>

      <para>Για να παρατηρήσετε αυτή τη λειτουργία την ώρα που συμβαίνει,
	ανοίξτε δύο τερματικά.  Στο πρώτο, ξεκινήστε την εντολή
	<command>passwd</command> ως κανονικός χρήστης.  Καθώς η εντολή
	εκτελείται και περιμένει για την εισαγωγή του νέου κωδικού, ελέγξτε
	τον πίνακα διεργασιών και αναζητήστε τις πληροφορίες του χρήστη που
	εκτελεί την εντολή <command>passwd</command>.</para>

      <para>Στο τερματικό Α:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>Στο τερματικό Β:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Όπως είπαμε παραπάνω, η εντολή <command>passwd</command>
	εκτελείται από ένα κανονικό χρήστη, αλλά χρησιμοποιεί το ενεργό
	<acronym>UID</acronym> του χρήστη <systemitem class="username">root</systemitem>.</para>

      <para>Η άδεια <literal>setgid</literal> εκτελεί την ίδια λειτουργία όπως
	και η <literal>setuid</literal>, αλλά επιδρά στις άδειες της ομάδας
	(group).  Όταν εκτελέσετε μια τέτοια εφαρμογή ή βοηθητικό πρόγραμμα,
	θα χρησιμοποιεί τις άδειες της ομάδας στην οποία ανήκει το αρχείο,
	και όχι του χρήστη που την ξεκίνησε.</para>

      <para>Για να θέσετε την άδεια <literal>setgid</literal> σε ένα αρχείο,
	θα πρέπει να τοποθετήσετε τον αριθμό δύο (2) μπροστά από το σύνολο
	αδειών, στην εντολή <command>chmod</command>.  Δείτε το παρακάτω
	παράδειγμα:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Όπως και πριν, θα παρατηρήσετε τη νέα άδεια <literal>s</literal>,
	αλλά αυτή τη φορά στο σετ των αδειών της ομάδας:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
	<para>Στα παραδείγματα μας, αν και το αρχείο είναι ένα εκτελέσιμο
	  script για κέλυφος, δεν θα εκτελεστεί με διαφορετικό ενεργό ID
	  (<acronym>EUID</acronym>).  Αυτό συμβαίνει γιατί σε αυτά τα scripts
	  δεν επιτρέπεται η πρόσβαση στις κλήσεις &man.setuid.2; του
	  συστήματος.</para>
      </note>

      <para>Οι δύο πρώτες ειδικές άδειες που αναφέραμε,
	οι <literal>setuid</literal> και <literal>setgid</literal>,
	ενδεχομένως να μειώσουν την ασφάλεια του συστήματος, αφού επιτρέπουν
	σε προγράμματα να εκτελούνται με αυξημένα δικαιώματα.  Υπάρχει ωστόσο
	μια τρίτη ειδική άδεια, η οποία μπορεί να αυξήσει την ασφάλεια του
	συστήματος: το <literal>sticky bit</literal>.</para>

      <para>Όταν θέσετε το <literal>sticky bit</literal> σε ένα κατάλογο,
	επιτρέπεται η διαγραφή ενός αρχείου μόνο από τον ιδιοκτήτη του.
	Η άδεια αυτή είναι χρήσιμη για να αποφεύγεται η διαγραφή ενός αρχείου
	από κοινόχρηστους καταλόγους, όπως για παράδειγμα ο
	<filename>/tmp</filename>, από κάποιο χρήστη που
	δεν είναι ο ιδιοκτήτης του.  Για να θέσετε αυτή την άδεια, τοποθετήστε
	τον αριθμό ένα (1) στην αρχή του σετ αδειών:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Μπορείτε τώρα να δείτε το αποτέλεσμα, χρησιμοποιώντας την εντολή
	<command>ls</command>:</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

      <para>Η άδεια <literal>sticky bit</literal> φαίνεται ως
	<literal>t</literal> στο τέλος του συνόλου των αδειών.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Δομή Καταλόγου</title>
    <indexterm><primary>ιεραρχία δομής</primary></indexterm>

    <para>Η ιεραρχική δομή του &os; είναι ένα βασικό στοιχείο που πρέπει να
      γνωρίζετε αν θέλετε να έχετε μια ολοκληρωμένη εικόνα του συστήματος.  Η
      πιο σημαντική έννοια είναι αυτή του ριζικού (root) καταλόγου,
      <quote>/</quote>.  Αυτός ο κατάλογος προσαρτάται (mount) πρώτος κατά
      την εκκίνηση και περιέχει το βασικό σύστημα ικανό να ετοιμάσει το Λ.Σ.
      για λειτουργία multi-user.  Ο root κατάλογος περιέχει επίσης σημεία
      προσάρτησης για άλλα συστήματα αρχείων που προσαρτώνται κατά την
      μετάβαση σε κατάσταση λειτουργίας multi-user.</para>

    <para>Σημείο προσάρτησης (mount point) είναι ένας κατάλογος στον οποίο
      μπορούν να αναπτυχθούν πρόσθετα συστήματα αρχείων σε ένα γονικό σύστημα
      αρχείων (συνήθως στο root σύστημα αρχείων).  Αυτό περιγράφεται
      αναλυτικά στην ενότητα <xref linkend="disk-organization"/>.  Στα
      στάνταρντ σημεία προσάρτησης περιλαμβάνονται:
      οι <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/tmp</filename>, <filename>/mnt</filename>, και
      <filename>/cdrom</filename>.  Αυτοί οι
      κατάλογοι συνήθως είναι καταχωρημένοι στο αρχείο
      <filename>/etc/fstab</filename>.  Το <filename>/etc/fstab</filename>
      είναι ένας πίνακας αντιστοιχίας διαφόρων συστημάτων αρχείων και σημείων
      προσάρτησης για αναφορά στο σύστημα.  Τα περισσότερα συστήματα
      που αναφέρονται στο <filename>/etc/fstab</filename> προσαρτώνται
      αυτόματα κατά την εκκίνηση του συστήματος από το script &man.rc.8; εκτός
      αν περιέχεται η επιλογή <option>noauto</option>.  Λεπτομέρειες μπορείτε
      να βρείτε στο <xref linkend="disks-fstab"/>.</para>

    <para>Μια πλήρη περιγραφή της ιεραρχίας του συστήματος αρχείων είναι
      διαθέσιμη στο &man.hier.7;.  Ακολουθεί μια σύντομη ανασκόπηση με τους
      πιο συνήθεις καταλόγους.</para>

    <para>
      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Κατάλογος</entry>
	      <entry>Περιγραφή</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><filename>/</filename></entry>
	      <entry> Ριζικός (root) κατάλογος του συστήματος αρχείων.</entry>
	    </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>Χρήσιμα εργαλεία για περιβάλλον ενός ή πολλαπλών
		χρηστών.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>Προγράμματα και αρχεία ρυθμίσεων που χρησιμοποιούνται
		κατά την εκκίνηση του λειτουργικού συστήματος.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>Προκαθορισμένα αρχεία ρυθμίσεων εκκίνησης, δείτε
		&man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Αρχεία συσκευών, δείτε &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>Αρχεία ρυθμίσεων συστήματος και σενάρια εκκίνησης.
		</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>Προκαθορισμένα αρχεία ρυθμίσεων συστήματος, δείτε την
		&man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>Αρχεία ρυθμίσεων για πράκτορες μεταφοράς ηλεκτρ.
		ταχυδρομείου (ΜΤΑ) όπως το &man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry>Αρχεία ρυθμίσεων <command>named</command>, δείτε
		&man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>Σενάρια λειτουργιών που τρέχουν σε ημερήσια, εβδομαδιαία,
		και μηνιαία βάση, &man.cron.8;; δείτε
		&man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry>Αρχεία ρυθμίσεων <command>ppp</command>, δείτε τις
		&man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>Κενός κατάλογος που συνήθως χρησιμοποιείται από τους
		διαχειριστές συστημάτων ως προσωρινό σημείο
		προσάρτησης.</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>Σύστημα αρχείων διεργασιών, δείτε τις &man.procfs.5;,
		&man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>Προγράμματα με στατική σύνδεση (static link) για ασφαλή
		επαναφορά συστήματος, δείτε την &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry>Προσωπικός κατάλογος του χρήστη
		<systemitem class="username">root</systemitem>.</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>Προγράμματα συστήματος και χρήσιμα εργαλεία διαχείρισης
		για περιβάλλον ενός ή πολλαπλών χρηστών.</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>Προσωρινά αρχεία.  Τα περιεχόμενα του
		<filename>/tmp</filename> συνήθως δεν
		διατηρούνται μετά από επανεκκίνηση του συστήματος.  Στο
		<filename>/tmp</filename> συνήθως
		προσαρτάται ένα σύστημα αρχείων μνήμης.  Αυτό μπορεί να
		επιτευχθεί αυτομάτως χρησιμοποιώντας τις σχετικές μεταβλητές
		tmpmfs του &man.rc.conf.5; (ή με μια καταχώρηση στον
		<filename>/etc/fstab</filename>, δείτε
		την &man.mdmfs.8;).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>Περιέχονται σχεδόν όλα τα βοηθητικά προγράμματα και οι
		εφαρμογές χρηστών.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>Κοινόχρηστα βοηθητικά προγράμματα, εργαλεία
		προγραμματισμού, και εφαρμογές.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>Στάνταρ αρχεία συμπερίληψης C (include files).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>Αρχεία βιβλιοθηκών.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>Διάφορα αρχεία δεδομένων βοηθητικών προγραμμάτων.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>Δαίμονες συστήματος &amp; βοηθητικά προγράμματα
		συστήματος (εκτελούνται από άλλα προγράμματα).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>Τοπικά εκτελέσιμα, βιβλιοθήκες, κτλ.  Επίσης είναι και ο
		προκαθορισμένος προορισμός για προγράμματα που εγκαθίστανται
		από τα ports του &os;.  Μέσα στον
		<filename>/usr/local</filename>, χρησιμοποιείται γενικά η
		διάταξη του <filename>/usr</filename> που περιγράφεται στο
		&man.hier.7;.  Εξαιρούνται οι κατάλογοι σελίδων βοηθείας
		man, που βρίσκεται άμεσα κάτω από τον
		<filename>/usr/local</filename> και όχι κάτω από τον
		<filename>/usr/local/share</filename>, καθώς και η τεκμηρίωση
		κάθε port που βρίσκεται στον
		<filename>share/doc/port
		</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry>Δέντρο προορισμού που εξαρτάται από την αρχιτεκτονική
		του μηχανήματος και παράγεται μεταγλωττίζοντας το δέντρο
		<filename>/usr/src</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports/</filename></entry>
	      <entry>Η Συλλογή Ports του &os; (προαιρετικό).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>Δαίμονες συστήματος &amp; βοηθητικά προγράμματα
		συστήματος (εκτελούνται από χρήστες).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>Αρχεία ανεξάρτητα από την Αρχιτεκτονική του
		μηχανήματος.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>Αρχεία BSD και/ή τοπικά αρχεία πηγαίου κώδικα.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/X11R6/</filename></entry>
	      <entry>Εκτελέσιμα, βιβλιοθήκες, κτλ. για την διανομή X11R6
		(προαιρετικό).</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>Αρχεία αναφοράς (log) διαφόρων χρήσεων, temporary,
		transient, και spool.  Μερικές φορές προσαρτάται στον
		<filename>/var</filename> ένα σύστημα
		αρχείων μνήμης.  Αυτό μπορεί να επιτευχθεί αυτόματα
		χρησιμοποιώντας τις σχετικές μεταβλητές varmfs του
		&man.rc.conf.5; (ή με μία καταχώρηση στο
		<filename>/etc/fstab</filename>, δείτε τις
		&man.mdmfs.8;).</entry>
	    </row>

	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>Διάφορα αρχεία συμβάντων του συστήματος.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>Αρχεία γραμματοκιβωτίου (mailbox) χρηστών.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>Διάφοροι κατάλογοι παροχέτευσης (spool) εκτυπωτών και
		ηλεκτρονικής αλληλογραφίας του συστήματος.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>Προσωρινά (temporary) αρχεία.  Τα αρχεία αυτά συνήθως
		διατηρούνται κατά την διάρκεια επανεκκίνησης του συστήματος,
		εκτός αν ο <filename>/var</filename> είναι
		ένα σύστημα αρχείων μνήμης.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp/</filename></entry>
	      <entry>Απεικονίσεις (maps) NIS.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable></para>
  </sect1>

  <sect1 xml:id="disk-organization">
    <title>Οργάνωση Δίσκου</title>

    <para>Η μικρότερη μονάδα οργάνωσης που χρησιμοποιεί το &os; για να βρει
      αρχεία είναι το όνομα αρχείου.  Τα ονόματα αρχείων είναι ευαίσθητα στα
      κεφαλαία- μικρά, το οποίο σημαίνει ότι το
      <filename>readme.txt</filename> και το <filename>README.TXT</filename>
      είναι δύο διαφορετικά αρχεία.  Το &os; δεν χρησιμοποιεί την επέκταση
      <filename>.txt</filename> αρχείου για να προσδιορίσει αν ένα αρχείο
      είναι πρόγραμμα, ή έγγραφο, ή άλλος τύπος δεδομένων.</para>

    <para>Τα αρχεία αποθηκεύονται σε καταλόγους.  Ένας κατάλογος μπορεί να
      μην περιέχει αρχεία, ή μπορεί να περιέχει εκατοντάδες αρχεία.  Ένας
      κατάλογος μπορεί επίσης να περιέχει άλλους καταλόγους, επιτρέποντας
      σας να κατασκευάσετε μια ιεραρχική δομή καταλόγων όπου κατάλογοι
      εσωκλείουν άλλους καταλόγους.  Αυτό μας επιτρέπει να οργανώσουμε τα
      δεδομένα μας πολύ ευκολότερα.</para>

    <para>Η αναφορά σε αρχεία και καταλόγους γίνεται δίνοντας το όνομα
      αρχείου ή το όνομα καταλόγου, ακολουθεί μία αριστερόστροφη κάθετος,
      <literal>/</literal> και έπειτα οποιοδήποτε άλλο κατάλληλο όνομα
      καταλόγου.  Εάν έχετε τον κατάλογο <filename>foo</filename>, ο οποίος
      περιέχει τον κατάλογο <filename>bar</filename>, ο οποίος περιέχει το
      αρχείο <filename>readme.txt</filename>, τότε το ολοκληρωμένο όνομα,
      <firstterm>διαδρομή (path)</firstterm> στο αρχείο είναι
      <filename>foo/bar/readme.txt</filename>.</para>

    <para>Κατάλογοι και αρχεία αποθηκεύονται σε ένα σύστημα αρχείων.  Κάθε
      σύστημα αρχείων περιέχει ένα κατάλογο στο ανώτερο επίπεδο, που
      ονομάζεται <firstterm>root (ριζικός) κατάλογος</firstterm> για το
      συγκεκριμένο σύστημα αρχείων.  Ο root κατάλογος μπορεί να περιέχει
      άλλους καταλόγους.</para>

    <para>Αυτό πιθανώς είναι παρόμοιο με οποιοδήποτε άλλο λειτουργικό
      σύστημα έχετε χρησιμοποιήσει.  Ωστόσο υπάρχουν μερικές διαφορές.  Για
      παράδειγμα, το &ms-dos; χρησιμοποιεί <literal>\</literal> για να
      διαχωρίζει ονόματα καταλόγων και αρχείων, ενώ το &macos; χρησιμοποιεί
      <literal>:</literal>.</para>

    <para>Το &os; δεν χρησιμοποιεί γράμματα οδηγών ή ονόματα οδηγών στη
      διαδρομή.  Επομένως δεν θα πρέπει να γράφετε
      <filename>c:/foo/bar/readme.txt</filename> στο &os;.</para>

    <para>Αντιθέτως, ένα σύστημα αρχείων καθορίζεται ως root σύστημα
      αρχείων.  Ο ριζικός κατάλογος του root συστήματος αρχείων
      αναφέρεται ως <literal>/</literal>.  Κάθε άλλο σύστημα αρχείου
      <firstterm>προσαρτάται</firstterm> κάτω από το root σύστημα αρχείων
      Δεν έχει σημασία πόσους δίσκους έχετε στο &os; σύστημα σας,
      κάθε κατάλογος εμφανίζεται να είναι μέρος του ίδιου δίσκου.</para>

    <para>Ας υποθέσουμε πως έχετε τρία συστήματα αρχείων, τα ονομάζουμε
      <literal>A</literal>, <literal>B</literal> και <literal>C</literal>.
      Κάθε σύστημα αρχείου έχει έναν ριζικό κατάλογο, ο οποίος περιέχει δύο
      άλλους καταλόγους, που τους ονομάζουμε <literal>A1</literal>,
      <literal>A2</literal> (και παρομοίως <literal>B1</literal>,
      <literal>B2</literal> και <literal>C1</literal>,
      <literal>C2</literal>).</para>

    <para>Ας θεωρήσουμε ότι το <literal>A</literal> είναι το root σύστημα
      αρχείων.  Αν χρησιμοποιήσετε την εντολή <command>ls</command> για να
      δείτε τα περιεχόμενα αυτού του καταλόγου, θα δείτε δύο υποκαταλόγους,
      <literal>A1</literal> και <literal>A2</literal>.  Το δέντρο του
      καταλόγου μοιάζει σαν αυτό:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir1"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Κάθε σύστημα αρχείων πρέπει να προσαρτάται σε ένα κατάλογο
      διαφορετικού συστήματος αρχείων.  Ας υποθέσουμε πως θέλετε να
      προσαρτήσετε το σύστημα αρχείου <literal>B</literal> στον
      <literal>κατάλογο A1</literal>.  Ο ριζικός κατάλογος του
      <literal>B</literal> αντικαθιστά τον <literal>A1</literal>, και οι
      κατάλογοι του <literal>B</literal> εμφανίζονται αναλόγως:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir2"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Όλα τα αρχεία που περιέχονται στους καταλόγους
      <literal>B1</literal> και <literal>B2</literal> τα βρίσκουμε με τη
      διαδρομή <filename>/A1/B1</filename> ή με <filename>/A1/B2</filename>
      αντίστοιχα.  Όλα τα αρχεία που βρίσκονταν στο <filename>/A1</filename>
      είναι προσωρινά κρυμμένα.  Θα επανεμφανιστούν όταν ο
      <literal>B</literal> θα <firstterm>αποπροσαρτηθεί</firstterm> από τον
      A.</para>

    <para>Αν ο <literal>B</literal> είχε προσαρτηθεί στον
      <literal>A2</literal> τότε το διάγραμμα θα έδειχνε κάπως έτσι:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir3"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>και οι διαδρομές θα ήταν <filename>/A2/B1</filename> και
      <filename>/A2/B2</filename> αντίστοιχα.</para>

    <para>Τα συστήματα αρχείων μπορούν να προσαρτώνται στην κορυφή άλλων
      συστημάτων.  Συνεχίζοντας το τελευταίο παράδειγμα, το σύστημα αρχείου
      <literal>C</literal> θα μπορούσε να προσαρτηθεί στην κορυφή του
      καταλόγου <literal>B1</literal> στο σύστημα αρχείου
      <literal>B</literal>, οδηγώντας σε αυτήν την κατανομή:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir4"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Ή ακόμη το <literal>C</literal> θα μπορούσε να προσαρτηθεί άμεσα
      στο σύστημα αρχείου <literal>A</literal>, κάτω από τον κατάλογο
      <literal>A1</literal>:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="install/example-dir5"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Αν γνωρίζετε το σύστημα &ms-dos;, είναι παρόμοιο, αλλά όχι
      ακριβώς το ίδιο, με την εντολή <command>join</command>.</para>

    <para>Αυτό συνήθως δεν είναι κάτι που πρέπει να γνωρίζετε άμεσα.  Τυπικά,
      εσείς δημιουργείτε συστήματα αρχείων όταν εγκαθιστάτε το &os; και
      αποφασίζετε το σημείο προσάρτησης αυτών, και έπειτα δεν χρειάζεται
      να τα αλλάξετε εκτός αν πρόκειται να προσθέσετε ένα καινούργιο
      δίσκο.</para>

    <para>Είναι απόλυτα δυνατόν να έχετε ένα μεγάλο root σύστημα αρχείων,
      και να μην χρειάζεται να δημιουργήσετε άλλα.  Με αυτή την τακτική
      υπάρχουν μερικά μειονεκτήματα και ένα πλεονέκτημα.</para>

    <itemizedlist>
      <title>Προτερήματα Πολλαπλών Συστημάτων Αρχείων</title>

      <listitem>
	<para>Διαφορετικά συστήματα αρχείων μπορούν να έχουν διαφορετικές
	  <firstterm>επιλογές προσάρτησης</firstterm>.  Για παράδειγμα, με
	  προσεκτικό σχεδιασμό, το root σύστημα αρχείων μπορεί να
	  προσαρτηθεί μόνο για ανάγνωση, ώστε να είναι αδύνατη η διαγραφή
	  ή η μετατροπή κάποιου σημαντικού αρχείου.  Διαχωρίζοντας συστήματα
	  αρχείων με δυνατότητα εγγραφής από τον χρήστη, όπως ο
	  <filename>/home</filename>, επιτρέπει επίσης την προσάρτηση τους
	  ως <firstterm>nosuid</firstterm>.  Αυτή η επιλογή περιορίζει την
	  χρήση εκτελέσιμων που είναι αποθηκευμένα στο σύστημα αρχείων, με
	  ενεργοποιημένα τα bits
	  <firstterm>suid</firstterm>/<firstterm>guid</firstterm>,
	  βελτιώνοντας πιθανώς την ασφάλεια.</para>
      </listitem>

      <listitem>
	<para>Ανάλογα με το πως θα χρησιμοποιηθεί το σύστημα αρχείων, το
	  &os; ρυθμίζει με τον καλύτερο τρόπο την διάταξη των αρχείων στο
	  σύστημα.  Επομένως ένα σύστημα που περιέχει πολλά μικρά αρχεία που
	  μεταβάλλονται συχνά, θα έχει διαφορετική διάταξη από ένα άλλο που
	  περιέχει λιγότερα σε αριθμό, αλλά πιο ογκώδη αρχεία.  Εάν έχετε ένα
	  μοναδικό σύστημα αρχείων, τότε χάνετε αυτή τη δυνατότητα.</para>
      </listitem>

      <listitem>
	<para>Τα συστήματα αρχείων του &os; είναι πολύ ισχυρά.  Ωστόσο,
	  μια αδυναμία σε κάποιο σημαντικό σημείο μπορεί ακόμη να οδηγήσει
	  σε κατάρρευση της δομής του συστήματος αρχείων.  Ο διαχωρισμός των
	  δεδομένων σας σε πολλαπλά συστήματα αρχείων κάνει πιο εύκολη μια
	  πιθανή επαναφορά από backup, όταν αυτό είναι αναγκαίο.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Προτερήματα ενός Μονοκόμματου Συστήματος Αρχείου</title>

      <listitem>
	<para>Τα συστήματα αρχείων είναι συγκεκριμένου σταθερού μεγέθους.
	  Αν δημιουργήσετε ένα σύστημα αρχείων κατά την εγκατάσταση του &os;
	  και του δώσετε ένα ορισμένο μέγεθος, μπορεί αργότερα να
	  ανακαλύψετε πως χρειάζεστε να φτιάξετε μια μεγαλύτερη κατάτμηση.
	  Αυτό δεν είναι εύκολα πραγματοποιήσιμο δίχως backup, αναδημιουργία
	  του συστήματος αρχείου με το νέο μέγεθος, και επαναφορά των
	  αποθηκευμένων δεδομένων.</para>

	<important>
	  <para>Στο &os; περιέχεται η εντολή &man.growfs.8;, η οποία
	    επιτρέπει να αυξήσουμε το μέγεθος ενός συστήματος αρχείων κατά
	    τη λειτουργία του, αφαιρώντας αυτόν τον περιορισμό.</para>
	</important>
      </listitem>
    </itemizedlist>

    <para>Τα συστήματα αρχείων περιέχονται σε κατατμήσεις (partitions).
      Αυτό δεν έχει την ίδια έννοια με την κοινή χρήση του όρου κατάτμηση
      (όπως για παράδειγμα, η κατάτμηση του &ms-dos;), λόγω της κληρονομιάς
      που φέρει το &os; από το &unix;.  Κάθε κατάτμηση αναγνωρίζεται από
      ένα λατινικό χαρακτήρα ξεκινώντας από <literal>a</literal> έως το
      <literal>h</literal>.  Κάθε κατάτμηση μπορεί να περιέχει μόνο ένα
      σύστημα αρχείων, το οποίο σημαίνει πως η αναφορά στα συστήματα αρχείων
      γίνεται είτε από το τυπικό σημείο προσάρτησης στην ιεραρχία του
      συστήματος αρχείων, είτε από το λατινικό χαρακτήρα της
      κατάτμησης.</para>

    <para>Επίσης το &os; χρησιμοποιεί μέρος από το δίσκο για
      <firstterm>χώρο swap </firstterm>.  Ο χώρος Swap παρέχει στο &os;
      <firstterm>εικονική μνήμη (virtual memory)</firstterm>.  Αυτό
      επιτρέπει στον υπολογιστή σας να συμπεριφέρεται σαν να είχε πολύ
      περισσότερη μνήμη από όσο πραγματικά έχει.  Όταν το &os; δεν έχει
      διαθέσιμη μνήμη μεταφέρει μερικά από τα δεδομένα που δεν
      χρησιμοποιούνται, την προκειμένη στιγμή, στον χώρο swap, και όταν τα
      χρειαστεί τα επαναφέρει (ενώ μεταφέρει κάποια άλλα δεδομένα στον χώρο
      swap).</para>

    <para>Υπάρχουν κάποιες συμβάσεις σχετικά με τις κατατμήσεις</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Κατάτμηση</entry>

	    <entry>Σύμβαση</entry>
	  </row>
	</thead>

	<tbody valign="top">
	  <row>
	    <entry><literal>a</literal></entry>

	    <entry>Συνήθως περιλαμβάνει το root σύστημα αρχείων</entry>
	  </row>

	  <row>
	    <entry><literal>b</literal></entry>

	    <entry>Συνήθως περιλαμβάνει τον χώρο swap</entry>
	  </row>

	  <row>
	    <entry><literal>c</literal></entry>

	    <entry>Συνήθως ιδίου μεγέθους με την περιλαμβανόμενη φέτα
	      (slice).  Αυτό επιτρέπει σε βοηθητικά προγράμματα που πρέπει
	      να δουλέψουν σε ολόκληρο το κομμάτι (για παράδειγμα, ένας
	      ανιχνευτής κατεστραμμένων μπλοκ) να λειτουργούν στην
	      <literal>c</literal> κατάτμηση.  Κανονικά δεν θα πρέπει να
	      δημιουργείτε σύστημα αρχείων σε αυτή την κατάτμηση.</entry>
	  </row>

	  <row>
	    <entry><literal>d</literal></entry>

	    <entry>Η κατάτμηση <literal>d</literal> είχε στο παρελθόν μια
	      ειδική αντιστοιχία, κάτι που δεν ισχύει πλέον σήμερα,
	      επομένως η <literal>d</literal> μπορεί να χρησιμοποιείται
	      σαν μια κανονική κατάτμηση.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Κάθε κατάτμηση που περιέχει ένα σύστημα αρχείων αποθηκεύεται στο
      &os; σε μια τοποθεσία που ονομάζεται
      <firstterm>φέτα (slice)</firstterm>.  Η φέτα είναι ένας όρος του &os;
      για αυτό που κοινώς αποκαλείται κατάτμηση, και αυτό επίσης οφείλεται
      στην καταγωγή του &os; από το &unix;.  Οι φέτες αριθμούνται αρχίζοντας
      από το 1 έως το 4.</para>

    <indexterm><primary>φέτες</primary></indexterm>
    <indexterm><primary>κατατμήσεις</primary></indexterm>
    <indexterm><primary>dangerously dedicated</primary></indexterm>

    <para>Ο αριθμός της φέτας ακολουθεί το όνομα συσκευής μετά το πρόθεμα
      <literal>s</literal> ξεκινώντας από το 1.  Επομένως,
      <quote>da0<emphasis>s1</emphasis></quote> είναι η πρώτη φέτα του
      πρώτου οδηγού SCSI.  Μπορούν να υπάρχουν μέχρι τέσσερις φέτες σε κάθε
      δίσκο, αλλά μπορείτε να δημιουργήσετε λογικές φέτες μέσα σε
      κατάλληλου τύπου φυσικές φέτες.  Σε αυτές τις εκτεταμένες φέτες
      η αρίθμηση ξεκινάει από το 5, επομένως
      <quote>ad0<emphasis>s5</emphasis></quote>
      είναι η πρώτη εκτεταμένη φέτα στον πρώτο δίσκο IDE.  Αυτές οι
      συσκευές χρησιμοποιούνται από συστήματα αρχείων που πρέπει να
      καταλαμβάνουν μια ολόκληρη φέτα.</para>

    <para>Οι φέτες, οι <quote>επικίνδυνα αφοσιωμένοι (dangerously dedicated)
      </quote> φυσικοί οδηγοί καθώς και άλλοι οδηγοί, περιέχουν
      <firstterm>κατατμήσεις</firstterm>, οι οποίες παρουσιάζονται με
      λατινικούς χαρακτήρες από το <literal>a</literal> έως το
      <literal>h</literal>.  Αυτός ο χαρακτήρας αναφέρεται στο όνομα
      συσκευής, επομένως <quote>da0<emphasis>a</emphasis></quote> είναι η
      a κατάτμηση στον πρώτο οδηγό da, ο οποίος είναι <quote>επικίνδυνα
      αφοσιωμένος</quote>.
      Η <quote>ad1s3<emphasis>e</emphasis></quote> είναι η πέμπτη κατάτμηση
      στην τρίτη φέτα του δεύτερου οδηγού δίσκου IDE.</para>

    <para>Ολοκληρώνοντας, κάθε δίσκος στο σύστημα είναι μονόδρομα ορισμένος.
      Κάθε όνομα δίσκου ξεκινά με ένα κωδικό που υποδεικνύει τον τύπο του
      δίσκου, και ένα νούμερο που υποδηλώνει ποιος δίσκος είναι.  Αντίθετα
      με τις φέτες, οι δίσκοι αριθμούνται ξεκινώντας από το 0.  Οι πιο
      συνήθεις κωδικοί που θα συναντήσετε αναφέρονται στην
      <xref linkend="basics-dev-codes"/>.</para>

    <para>Όταν γίνεται αναφορά σε μια κατάτμηση, το &os; ζητά να δηλωθεί
      επιπλέον η ονομασία της φέτας και του δίσκου που περιέχει την
      κατάτμηση, ενώ στην περίπτωση που αναφέρεστε σε μια φέτα θα πρέπει
      να δηλώνετε το όνομα του δίσκου.  Επομένως, όταν αναφέρεστε σε μια
      κατάτμηση χρειάζεται να δηλώνετε το όνομα του δίσκου,
      <literal>s</literal>, τον αριθμό της φέτας, και τον χαρακτήρα της
      κατάτμησης.  Παραδείγματα μπορείτε να βρείτε στην
      <xref linkend="basics-disk-slice-part"/>.</para>

    <para>Η <xref linkend="basics-concept-disk-model"/> παρουσιάζει ένα
      εννοιολογικό μοντέλο για τη δομή του δίσκου που θα σας βοηθήσει να
      καταλάβετε καλύτερα κάποια πράγματα.</para>

    <para>Για να εγκαταστήσετε το &os; πρέπει πρώτα να ρυθμίσετε τις φέτες
      του δίσκου, να δημιουργήσετε τις κατατμήσεις μέσα στις φέτες που θα
      χρησιμοποιήσετε για το &os;, έπειτα να δημιουργήσετε ένα σύστημα
      αρχείων (ή χώρο swap) σε κάθε κατάτμηση, και τέλος να αποφασίσετε σε
      ποιο σημείο θα προσαρτηθεί το σύστημα αρχείων.</para>

    <table frame="none" pgwide="1" xml:id="basics-dev-codes">
      <title>Κωδικοί Συσκευών Δίσκων</title>

      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Κώδικας</entry>

	    <entry>Σημαίνει</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><filename>ad</filename></entry>
	    <entry>Δίσκος ATAPI (IDE)</entry>
	  </row>

	  <row>
	    <entry><filename>da</filename></entry>
	    <entry>Δίσκος SCSI άμεσης πρόσβασης</entry>
	  </row>

	  <row>
	    <entry><filename>acd</filename></entry>
	    <entry>ATAPI (IDE) CDROM</entry>
	  </row>

	  <row>
	    <entry><filename>cd</filename></entry>
	    <entry>SCSI CDROM</entry>
	  </row>

	  <row>
	    <entry><filename>fd</filename></entry>
	    <entry>Μονάδα Δισκέτας (Floppy)</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <example xml:id="basics-disk-slice-part">
      <title>Υποδείγματα Ονομάτων Δίσκου, Φέτας, Κατάτμησης</title>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Ονομασία</entry>
	      <entry>Σημαίνει</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>ad0s1a</literal></entry>
	      <entry>Η πρώτη κατάτμηση (<literal>a</literal>) στην πρώτη
		φέτα (<literal>s1</literal>) του πρώτου δίσκου IDE
		(<literal>ad0</literal>).</entry>
	    </row>

	    <row>
	      <entry><literal>da1s2e</literal></entry>
	      <entry>Η πέμπτη κατάτμηση (<literal>e</literal>) στην δεύτερη
		φέτα (<literal>s2</literal>) του δεύτερου δίσκου SCSI
		(<literal>da1</literal>).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </example>

    <example xml:id="basics-concept-disk-model">
      <title>Εννοιολογικό Μοντέλο ενός Δίσκου</title>

      <para>Το διάγραμμα παρουσιάζει μια εικόνα του πρώτου δίσκου IDE που
	είναι προσαρτημένος στο σύστημα.  Ας υποθέσουμε πως ο δίσκος έχει
	μέγεθος 4&nbsp;GB, και περιέχει δύο φέτες των 2&nbsp;GB
	(κατατμήσεις &ms-dos;).  Η πρώτη φέτα περιέχει ένα δίσκο &ms-dos;,
	<filename>C:</filename>, και η δεύτερη φέτα μία εγκατάσταση
	&os;.  Σε αυτό το παράδειγμα, η εγκατάσταση &os; έχει τρεις
	κατατμήσεις δεδομένων και μία κατάτμηση swap.</para>

      <para>Καθεμία από τις τρεις κατατμήσεις θα περιέχει ένα σύστημα
	αρχείων.  Η κατάτμηση <literal>a</literal> θα χρησιμοποιηθεί για το
	root σύστημα αρχείων, η <literal>e</literal> για τη δομή κατάλογου
	<filename>/var</filename>, και η <literal>f</literal> για τη δομή
	καταλόγου <filename>/usr</filename>.</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/disk-layout"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  Πρώτη φέτα, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  -a Κατάτμηση a, προσαρτημένη ως /	 	      |
|                 |     &gt; αναφέρεται ως	ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  -swap  Κατάτμηση b, για χρήση  swap	      |
|                 |     &gt; αναφέρεται ως ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  -c Κατάτμηση, απουσία
|                 |    |  -e Κατάτμηση e, για χρήση   /var       &gt; συστήματος αρχείων,
|                 |     &gt; αναφέρεται ως ad0s2e          |  μη προσαρτημένη,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  -f Κατάτμηση f, για χρήση /usr      |
:                 :     &gt; αναφέρεται ως  ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
	</textobject>
      </mediaobject>
    </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Προσάρτηση και Αποπροσάρτηση Συστημάτων Αρχείων</title>

    <para>Ένα σύστημα αρχείων αναπαριστάται καλύτερα σε μορφή δέντρου,
      με τις ρίζες του στο <filename>/</filename>.  Οι κατάλογοι
      <filename>/dev</filename>, <filename>/usr</filename>, και άλλοι είναι
      κλαδιά του καταλόγου root, και μπορεί να έχουν με τη σειρά τους, τα
      δικά τους κλαδιά, όπως τον
      <filename>/usr/local</filename>, και ούτω καθεξής.</para>

    <indexterm><primary>σύστημα αρχείων root</primary></indexterm>
    <para>Υπάρχουν διάφοροι λόγοι για τους οποίους θα έπρεπε να τοποθετήσουμε
      κάποιους από αυτούς τους καταλόγους σε διαφορετικά συστήματα αρχείων.
      Ο κατάλογος <filename>/var</filename> περιέχει τους καταλόγους
      <filename>log/</filename>, <filename>spool/</filename>, και διάφορους
      άλλους τύπους προσωρινών αρχείων, και για το λόγο αυτό μπορεί να
      γεμίσει.  Δεν θα ήταν καλή ιδέα να γεμίσει το root σύστημα αρχείων,
      επομένως ο διαχωρισμός του <filename>/var</filename> από τον
      <filename>/</filename> είναι συχνά επιθυμητός.</para>

    <para>Ένας άλλος συνηθισμένος λόγος να έχουμε διάφορους καταλόγους
      σε διαφορετικά συστήματα αρχείων είναι όταν πρόκειται να φιλοξενηθούν
      σε διαφορετικούς φυσικούς δίσκους, ή είναι ξεχωριστοί εικονικοί δίσκοι,
      όπως συμβαίνει με το
      <link linkend="network-nfs">Δικτυακό Σύστημα Αρχείων (Network File System)</link>, και τους οδηγούς CDROM.</para>

    <sect2 xml:id="disks-fstab">
      <title>Το Αρχείο <filename>fstab</filename></title>
      <indexterm>
	<primary>συστήματα αρχείων</primary>
	<secondary>προσαρτημένα με το fstab</secondary>
      </indexterm>

      <para>Κατά τη <link linkend="boot">διεργασία εκκίνησης</link>, τα
	συστήματα αρχείων που αναφέρονται στο <filename>/etc/fstab</filename>
	προσαρτώνται αυτόματα (εκτός αν αναφέρονται με την επιλογή
	<option>noauto</option> ).</para>

      <para>Το αρχείο <filename>/etc/fstab</filename> περιέχει μια σειρά από
	γραμμές με διάταξη όπως η ακόλουθη:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
	    <para>Όνομα συσκευής (η οποία θα πρέπει να υπάρχει), όπως
	      εξηγείται στην <xref linkend="disks-naming"/>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
	    <para>Κατάλογος (θα πρέπει να υπάρχει) στον οποίο
	      προσαρτάται το σύστημα αρχείων.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
	    <para>Ο τύπος του συστήματος αρχείων που θα δοθεί στην
	      &man.mount.8;.  Το προκαθορισμένο σύστημα αρχείων του &os;
	      είναι το <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Το <option>rw</option> για συστήματα αρχείων
	      ανάγνωσης- εγγραφής (read- write), ή <option>ro</option> για
	      συστήματα αρχείων μόνο ανάγνωσης (read-only), συμπληρωμένο με
	      όποια άλλη επιλογή μπορεί να χρειάζεστε.  Μία συνήθης επιλογή
	      είναι η <option>noauto</option> για συστήματα αρχείων που δεν
	      προσαρτώνται αυτόματα κατά τις διεργασίες εκκίνησης του
	      συστήματος.  Άλλες επιλογές αναφέρονται στην σελίδα βοήθειας
	      &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem>
	    <para>Αυτό το πεδίο χρησιμοποιείται από το &man.dump.8; για να
	      ορίσει ποια συστήματα αρχείων χρειάζονται dumping.  Αν το πεδίο
	      απουσιάζει, τότε η προκαθορισμένη τιμή του είναι μηδέν.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem>
	    <para>Αυτό ορίζει την σειρά με την οποία θα ελέγχονται
	      τα συστήματα αρχείων.  Συστήματα αρχείων που δεν επιθυμούμε να
	      ελεγχθούν θα πρέπει να έχουν στο πεδίο <literal>passno</literal>
	      τιμή μηδέν.  Το root σύστημα αρχείων (το οποίο πρέπει να
	      ελεγχθεί πριν από όλα τα άλλα) θα έχει στο πεδίο
	      <literal>passno</literal> την τιμή ένα και όλα τα άλλα
	      συστήματα αρχείων θα έχουν στο πεδίο <literal>passno</literal>
	      τιμές μεγαλύτερες από ένα.  Αν περισσότερα από ένα συστήματα
	      αρχείων έχουν την ίδια τιμή <literal>passno</literal> τότε το
	      &man.fsck.8; θα επιχειρήσει να ελέγξει παράλληλα τα συστήματα
	      αρχείων, αν αυτό είναι εφικτό.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Συμβουλευτείτε την σελίδα βοηθείας &man.fstab.5; για περισσότερες
	πληροφορίες για την μορφή του αρχείου <filename>/etc/fstab</filename>
	και για τις επιλογές που μπορεί να περιέχει.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>Η Εντολή <command>mount</command></title>
      <indexterm>
	<primary>συστήματα αρχείων</primary>
	<secondary>προσάρτηση</secondary>
      </indexterm>

      <para>Η εντολή &man.mount.8; είναι αυτό ακριβώς που χρειάζεστε για την
	προσάρτηση συστημάτων αρχείων.</para>

      <para>Η βασική μορφή της είναι:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount device mountpoint</userinput></screen>
      </informalexample>

      <para>Υπάρχει πληθώρα επιλογών, όπως αναφέρεται στην σελίδα βοηθείας
	&man.mount.8;, αλλά οι πιο συνήθεις είναι:</para>

      <variablelist>
	<title>Επιλογές εντολής mount</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Προσάρτηση όλων των συστημάτων αρχείων που αναφέρονται
	      στο <filename>/etc/fstab</filename>, εκτός αυτών που φέρουν
	      την επιλογή <quote>noauto</quote>, εξαιρούνται μέσω της επιλογής
	      <option>-t</option>, ή αυτών που ήδη έχουν προσαρτηθεί.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Κάνει τα πάντα εκτός από την πραγματική προσάρτηση του
	      συστήματος.  Αυτή η επιλογή είναι χρήσιμη σε συνεργασία με το
	      πρόθεμα <option>-v</option> για να προσδιοριστεί τι ακριβώς
	      προσπαθεί να κάνει η &man.mount.8; την συγκεκριμένη
	      στιγμή.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Αναγκάζει την προσάρτηση ενός μη-καθαρού συστήματος αρχείων
	      (επικίνδυνο), ή εξαναγκάζει την ανάκληση πρόσβασης εγγραφής όταν
	      υποβιβάζεται η προσάρτηση ενός συστήματος αρχείων
	      ανάγνωσης-εγγραφής (read-write) σε μόνο-ανάγνωσης.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Προσαρτά το σύστημα αρχείων σε κατάσταση μόνο-ανάγνωσης.
	      Είναι ακριβώς το ίδιο με τη χρήση του προθέματος
	      <option>ro</option> με την επιλογή <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Προσαρτά το υπάρχον σύστημα αρχείων, χρησιμοποιώντας τον
	      τύπο συστήματος αρχείων που δίνεται, ή προσαρτά μόνο
	      συστήματα αρχείων του συγκεκριμένου τύπου, εάν δοθεί μαζί με την
	      επιλογή <option>-a</option>.</para>

	    <para>Το <quote>ufs</quote> είναι ο προεπιλεγμένος τύπος
	      συστήματος αρχείων.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Ανανεώνει τις επιλογές προσάρτησης στο σύστημα
	      αρχείων.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Συμπεριλαμβάνει αναλυτική αναφορά.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Προσαρτά το σύστημα αρχείων για ανάγνωση-εγγραφή
	      (read-write).</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Η επιλογή <option>-o</option> δέχεται μία σειρά από επιλογές
	χωρισμένες με κόμμα, περιλαμβάνοντας τις ακόλουθες:</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	      <para>Δεν επιτρέπεται η λειτουργία εκτελέσιμων σε αυτό το
		σύστημα αρχείων.  Αυτό είναι επίσης μια επιλογή
		ασφαλείας.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Δεν λαμβάνονται υπ' όψιν setuid ή setgid flags στο σύστημα
	      αρχείων.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Η Εντολή <command>umount</command></title>
      <indexterm>
	<primary>συστήματα αρχείων</primary>
	<secondary>αποπροσάρτηση</secondary>
      </indexterm>

      <para>Η εντολή &man.umount.8; παίρνει, ως παράμετρο, ένα εκ των σημείων
	προσάρτησης, το όνομα μιας συσκευής, ή τις επιλογές
	<option>-a</option> ή <option>-A</option>.</para>

      <para>Όλοι οι τύποι δέχονται την <option>-f</option> για να
	εξαναγκάσουν σε αποπροσάρτηση, και την <option>-v</option> για
	αναλυτική αναφορά.  Σας προειδοποιούμε πως η επιλογή
	<option>-f</option> γενικά δεν είναι καλή ιδέα.  Η εξ' αναγκασμού
	αποπροσάρτηση μπορεί να οδηγήσει σε κατάρρευση τον υπολογιστή ή να
	καταστρέψει δεδομένα στο σύστημα αρχείων.</para>

      <para>Οι <option>-a</option> και <option>-A</option> χρησιμοποιούνται
	για να αποπροσαρτήσουν όλα τα προσαρτημένα συστήματα αρχείων, σύμφωνα
	και με τις επιλογές που δίνονται από το <option>-t</option>, αν
	υπάρχει.  Το <option>-A</option>, ωστόσο, δεν θα επιχειρήσει να
	αποπροσαρτήσει το root σύστημα αρχείων.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Διεργασίες</title>

    <para>To &os; είναι ένα λειτουργικό σύστημα multi-tasking.  Αυτό σημαίνει
      πως κάθε στιγμή μπορούν να τρέχουν παραπάνω από ένα προγράμματα.  Κάθε
      πρόγραμμα που τρέχει οποιαδήποτε στιγμή ονομάζεται
      <firstterm>διεργασία</firstterm> (process).  Κάθε εντολή που τρέχετε
      ξεκινάει τουλάχιστον μία νέα διεργασία, και υπάρχουν κάποιες διεργασίες
      του συστήματος που τρέχουν συνέχεια για να κρατούν το σύστημα
      σε λειτουργία.</para>

    <para>Κάθε διεργασία χαρακτηρίζεται από ένα μοναδικό αριθμό που
      ονομάζεται <firstterm>ID διεργασίας</firstterm> ή
      <firstterm>PID</firstterm>, και όπως ακριβώς συμβαίνει με τα αρχεία,
      κάθε διεργασία έχει έναν ιδιοκτήτη και ένα γκρουπ.  Οι πληροφορίες του
      ιδιοκτήτη και του γκρουπ χρειάζονται για να προσδιορίζεται ποια αρχεία
      και συσκευές μπορεί να ανοίξει η συγκεκριμένη διεργασία,
      χρησιμοποιώντας τις άδειες αρχείων που συζητήσαμε νωρίτερα.  Οι
      περισσότερες διεργασίες έχουν επίσης μία γονική διεργασία.  Η γονική
      διεργασία είναι εκείνη η διεργασία που τις ξεκίνησε.  Για παράδειγμα,
      εάν πληκτρολογείτε εντολές στο κέλυφος, τότε το κέλυφος είναι μία
      διεργασία, και κάθε εντολή που τρέχετε είναι επίσης μία διεργασία.
      Επομένως κάθε διεργασία που τρέχετε με αυτόν τον τρόπο θα έχει γονική
      διεργασία το κέλυφος σας.  Η μόνη εξαίρεση είναι μία διεργασία που
      ονομάζεται &man.init.8;.  Η <command>init</command> είναι πάντα η πρώτη
      διεργασία, και επομένως το PID της είναι πάντα 1.  Η
      <command>init</command> ξεκινά αυτόματα από τον πυρήνα κατά την
      εκκίνηση του &os;.</para>

    <para>Δύο ιδιαίτερα χρήσιμες εντολές για να παρατηρείτε τις διεργασίες
      στο σύστημα, είναι οι &man.ps.1; και &man.top.1;.  Η εντολή
      <command>ps</command> χρησιμοποιείται για την προβολή μιας στατικής
      λίστας των τρέχοντων διεργασιών, και μπορεί να εμφανίζει το PID τους,
      πόση μνήμη χρησιμοποιούν, την εντολή με την οποία ξεκίνησαν, και άλλες
      πληροφορίες.  Η εντολή <command>top</command> εμφανίζει όλες τις
      τρέχουσες διεργασίες, και ανανεώνει την οθόνη σας ανά λίγα
      δευτερόλεπτα, επομένως μπορείτε να παρατηρείτε τι ακριβώς κάνει ο
      υπολογιστή σας τη δεδομένη στιγμή.</para>

    <para>Η <command>ps</command>, από προεπιλογή, εμφανίζει μόνο τις
      εντολές που τρέχουν και ανήκουν σε εσάς.  Για παράδειγμα:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Όπως μπορείτε να δείτε σε αυτό το παράδειγμα, η έξοδος από την ps
      προβάλλεται σε στήλες.  <literal>PID</literal> είναι το PID της
      διεργασίας όπως αναφέραμε νωρίτερα.  Τα PID διανέμονται από 1, έως
      99999, και όταν υπερβούν το 99999 ξεκινούν από την αρχή (ένα PID
      δεν μπορεί να αποδοθεί ξανά αν είναι ήδη σε χρήση).  Η στήλη
      <literal>TT</literal> δείχνει το τερματικό (tty) του προγράμματος που
      εκτελείται, και μπορεί να αγνοηθεί αυτή τη στιγμή δίχως πρόβλημα.  Η
      <literal>STAT</literal> υποδεικνύει την κατάσταση του προγράμματος, και
      πάλι μπορεί να αγνοηθεί.  Η <literal>TIME</literal> είναι η χρονική
      διάρκεια που το πρόγραμμα απασχολεί την CPU, αυτό συνήθως δεν είναι ο
      χρόνος εκτέλεσης αφού τα περισσότερα προγράμματα καθυστερούν με άλλες
      εργασίες πριν απασχολήσουν την CPU.  Η τελευταία στήλη, η
      <literal>COMMAND</literal> είναι η γραμμή εντολής που δόθηκε για να
      τρέξει το πρόγραμμα.</para>

    <para>Η &man.ps.1; υποστηρίζει διάφορες επιλογές για να αλλάξει την γκάμα
      των πληροφοριών που εμφανίζονται.  Μία από τις πιο χρήσιμες επιλογές
      είναι η <literal>auxww</literal>.  Η <option>a</option> εμφανίζει
      πληροφορίες για όλες τις τρέχουσες διεργασίες, όχι μόνο τις δικές σας.
      Η <option>u</option> εμφανίζει το όνομα χρήστη του ιδιοκτήτη της
      διεργασίας, όπως και τη χρήσης της μνήμης.  Η <option>x</option>
      εμφανίζει πληροφορίες σχετικά με τις διεργασίες των δαιμόνων και η
      <option>ww</option> αναγκάζει την &man.ps.1; να εμφανίσει ολόκληρη την
      εντολή γραμμής για κάθε διεργασία, αφού συνήθως εμφανίζεται κομμένη
      λόγω του μήκους της που δεν χωρά να εμφανιστεί στην οθόνη.</para>

    <para>Η έξοδος της &man.top.1; είναι παρόμοια.  Ένα δείγμα εργασίας της
      μοιάζει σαν αυτή:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Η έξοδος είναι χωρισμένη σε δύο τομείς.  Η κεφαλίδα (οι πέντε
      πρώτες γραμμές) εμφανίζουν το PID της τελευταίας διεργασίας που έτρεξε,
      την μέση τιμή φορτίου (είναι μια μέτρηση που δείχνει πόσο απασχολημένο
      είναι το σύστημα), ο χρόνος λειτουργίας (uptime) του συστήματος
      (από την τελευταία επανεκκίνηση) και την τρέχουσα ώρα.  Τα άλλα στοιχεία
      στην κεφαλίδα σχετίζονται με το νούμερο των διεργασιών που τρέχουν
      (47 σε αυτή τη περίπτωση), πόση μνήμη και χώρο swap κατέχουν και πόσο
      χρόνο ξοδεύει το σύστημα σε διάφορες καταστάσεις λειτουργίας της
      CPU.</para>

    <para>Πιο κάτω ακολουθεί μια σειρά από στήλες, που περιέχουν παρόμοιες
      πληροφορίες με την έξοδο της ps.  Όπως και νωρίτερα μπορείτε να δείτε το
      PID, το όνομα χρήστη, το ποσοστό χρήσης της CPU, και την εντολή με την
      οποία ξεκίνησε η διεργασία.  Η &man.top.1; από προεπιλογή, εμφανίζει
      επίσης το ποσοστό μνήμης που χρησιμοποιείται από τη διεργασία.  Αυτή
      χωρίζεται σε δύο στήλες.  Η μία είναι για το συνολικό μέγεθος μνήμης που
      χρειάστηκε η εφαρμογή, ενώ η άλλη για το μέγεθος της μνήμης που
      καταναλώνει την παρούσα στιγμή.  Σε αυτό το παράδειγμα μπορείτε να δείτε
      ότι ο <application>&netscape;</application> χρειάστηκε σχεδόν 30&nbsp;MB
      RAM, αλλά την παρούσα στιγμή χρησιμοποιεί μόνο 9&nbsp;MB.</para>

    <para>Η &man.top.1; αυτόματα ανανεώνει το περιεχόμενο της κάθε δύο
      δευτερόλεπτα.  Αυτό μπορεί να ρυθμιστεί με την επιλογή
      <option>s</option>.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Δαίμονες, Σήματα, και Τερματισμός Διεργασιών</title>

    <para>Όταν χρησιμοποιείτε ένα κειμενογράφο, είναι εύκολο να τον ελέγχετε,
      να φορτώνετε αρχεία, και οτιδήποτε άλλο.  Αυτό συμβαίνει διότι ο
      κειμενογράφος παρέχει αυτές τις δυνατότητες, και επίσης επειδή
      είναι προσαρτημένος σε ένα <firstterm>τερματικό</firstterm>.  Μερικά
      προγράμματα δεν είναι σχεδιασμένα να δουλεύουν με συνεχείς χειρισμούς
      από τον χρήστη, και επομένως αποσυνδέονται από το τερματικό με την
      πρώτη ευκαιρία.  Για παράδειγμα, ένας εξυπηρετητής web ξοδεύει όλο του
      το χρόνο στο να απαντά σε αιτήματα web, επομένως δεν χρειάζεται καμιά
      εισαγωγή δεδομένων από τον χρήστη.  Άλλο παραπλήσιο παράδειγμα
      εφαρμογής, είναι τα προγράμματα μεταφοράς μηνυμάτων ηλεκτρονικής
      αλληλογραφίας από μια τοποθεσία σε μιαν άλλη.</para>

    <para>Ονομάζουμε αυτά τα προγράμματα
      <firstterm>δαίμονες (daemons)</firstterm>.  Οι δαίμονες ήταν χαρακτήρες
      της Ελληνικής μυθολογίας (ούτε καλοί - ούτε κακοί), ήταν απλά μικρά
      συνοδευτικά πνεύματα που έκαναν χρήσιμα πράγματα για την ανθρωπότητα,
      όπως ακριβώς και οι διακομιστές web και εξυπηρετητές ηλεκτρονικής
      αλληλογραφίας σήμερα κάνουν χρήσιμα πράγματα.  Αυτός είναι και ο λόγος
      για τον οποίο η μασκότ του BSD είναι εδώ και πολύ καιρό ο
      χαρούμενος δαίμονας με πάνινα σπορ παπούτσια και την τρίαινα.</para>

    <para>Η ονομασία των προγραμμάτων που τρέχουν σαν δαίμονες συμβατικά
      τελειώνει με <quote>d</quote>.  Το <application>BIND</application>
      είναι το Berkeley Internet Name Domain, αλλά το πραγματικό πρόγραμμα
      που τρέχει ονομάζεται <command>named</command>, το πρόγραμμα του
      εξυπηρετητή web <application>Apache</application> λέγεται
      <command>httpd</command>, ο δαίμονας ελέγχου των εκτυπωτών
      γραμμής είναι ο <command>lpd</command> και ούτω καθεξής.  Αυτή είναι
      απλά μια σύμβαση, όχι απόλυτος κανόνας, για παράδειγμα, ο κύριος
      δαίμονας ηλεκτρονικής αλληλογραφίας για την εφαρμογή
      <application>Sendmail</application>
      ονομάζεται <command>sendmail</command>, και όχι
      <command>maild</command>, όπως θα ήταν αναμενόμενο.</para>

    <para>Μερικές φορές θα χρειαστεί να επικοινωνείτε με τη διεργασία ενός
      δαίμονα.  Ένας τρόπος για να γίνει αυτό είναι στέλνοντας (όπως και σε
      κάθε εκτελέσιμη διεργασία) <firstterm>σήματα (signals)</firstterm>.
      Υπάρχουν διάφορα σήματα που μπορείτε να στείλετε &mdash; μερικά από
      αυτά έχουν μια συγκεκριμένη σημασία, ενώ άλλα ερμηνεύονται
      μέσα από την εφαρμογή, και επομένως για να ξέρουμε πως ερμηνεύονται τα
      σήματα θα πρέπει να διαβάσουμε την τεκμηρίωση της εφαρμογής.  Μπορείτε
      να στείλετε σήμα σε μια διεργασία μόνο αν σας ανήκει.  Αν στείλετε σήμα
      σε μια διεργασία που ανήκει σε κάποιον άλλο με &man.kill.1; ή
      &man.kill.2;, δεν θα σας επιτραπεί.  Η μοναδική εξαίρεση σε αυτό, είναι
      ο χρήστης <systemitem class="username">root</systemitem>, που μπορεί να στέλνει σήματα στις
      διεργασίες οποιουδήποτε άλλου χρήστη του συστήματος.</para>

    <para>Το &os; στέλνει επίσης σήματα σε εφαρμογές σε μερικές περιπτώσεις.
      Αν μία εφαρμογή είναι γραμμένη άσχημα, και προσπαθεί να προσπελάσει
      μνήμη που δεν της ανήκει, το &os; στέλνει στη διεργασία το σήμα
      <firstterm>Segmentation Violation</firstterm>
      (<literal>SIGSEGV</literal>).  Αν μια εφαρμογή χρησιμοποίησε το σύστημα
      ειδοποίησης &man.alarm.3; για να ειδοποιηθεί μετά την πάροδο μιας
      χρονικής περιόδου τότε το &os; θα στείλει το Alarm signal
      (<literal>SIGALRM</literal>), και ούτω καθ'εξής.</para>

    <para>Δύο σήματα μπορούν να χρησιμοποιηθούν για να σταματήσουν μία
      διαδικασία, το <literal>SIGTERM</literal> και το
      <literal>SIGKILL</literal>.  Το <literal>SIGTERM</literal> είναι ο
      σωστός τρόπος για να σταματήσουμε μια διαδικασία.  Η διεργασία
      <emphasis>αντιλαμβάνεται</emphasis> το σήμα, εκτελεί το σταμάτημα
      κλείνοντας όλα τα αρχεία αναφοράς (log files), που πιθανώς να είναι
      ανοιχτά, και γενικώς τελειώνει οτιδήποτε κάνει την συγκεκριμένη
      χρονική στιγμή πριν σταματήσει.  Σε μερικές περιπτώσεις η διεργασία
      μπορεί να αγνοήσει το <literal>SIGTERM</literal> εάν βρίσκεται στα
      μισά κάποιας εργασίας που δεν μπορεί να διακοπεί.</para>

    <para>Το σήμα <literal>SIGKILL</literal> δεν μπορεί να αγνοηθεί από μία
      διεργασία.  Είναι σαν να λέει στη διεργασία,
      <quote>Δεν με ενδιαφέρει τι κάνεις, σταμάτα τώρα αμέσως</quote>.  Αν
      στείλετε το σήμα <literal>SIGKILL</literal> σε μια διαδικασία τότε το
      &os; θα σταματήσει την διαδικασία άμεσα

      <footnote>
	<para>Αυτό δεν είναι απόλυτα αληθές &mdash; Υπάρχουν μερικά πράγματα
	  που δεν μπορούν να διακοπούν.  Για παράδειγμα, εάν η διεργασία
	  προσπαθεί να διαβάσει ένα αρχείο από άλλον υπολογιστή στο δίκτυο
	  και ξαφνικά αυτός ο άλλος υπολογιστής διακόψει για κάποιο λόγο
	  (λόγω κλεισίματος του pc ή λόγω βλάβης στο δίκτυο), τότε η διεργασία
	  ονομάζεται μη <quote>διακόψιμη</quote>.  Πιθανώς η διεργασία να
	  κάνει time out, συνήθως μετά από δύο λεπτά.  Μόλις συμβεί αυτό, θα
	  τερματιστεί άμεσα.</para>
      </footnote>.</para>

    <para>Άλλα σήματα που πιθανώς να θέλετε να χρησιμοποιήσετε είναι τα
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, και
      <literal>SIGUSR2</literal>.  Αυτά είναι σήματα γενικής χρήσης, και
      όταν αποστέλλονται κάνουν διαφορετικά πράγματα ανάλογα με την
      εφαρμογή.</para>

    <para>Ας υποθέσουμε πως αλλάξατε το αρχείο ρύθμισης του εξυπηρετητή
      διαδικτύου σας, και πως θα θέλατε να πείτε στον εξυπηρετητή να
      ξαναδιαβάσει τις ρυθμίσεις.  Θα μπορούσατε να σταματήσετε και να
      επανεκκινήσετε το <command>httpd</command>, αλλά αυτό θα οδηγούσε σε
      μια χρονική περίοδο όπου ο εξυπηρετητής θα έμενε εκτός λειτουργίας,
      κάτι το οποίο μπορεί να είναι ανεπιθύμητο.  Οι περισσότεροι δαίμονες
      είναι σχεδιασμένοι να απαντούν σε σήματα <literal>SIGHUP</literal> για
      την εκ νέου ανάγνωση του αρχείου ρύθμισης τους.  Επομένως, αντί να
      σταματήσουμε και να επανεκκινήσουμε το <command>httpd</command> θα
      μπορούσαμε να του στείλουμε το σήμα <literal>SIGHUP</literal>.  Επειδή
      δεν υπάρχει συγκεκριμένος τρόπος στην απάντηση αυτών των σημάτων, και
      διαφορετικοί δαίμονες έχουν διαφορετική συμπεριφορά, πρέπει να
      διαβάσετε πρώτα την τεκμηρίωση για τον συγκεκριμένο δαίμονα.</para>

    <para>Τα σήματα στέλνονται χρησιμοποιώντας την εντολή &man.kill.1;, όπως
      υποδεικνύει το ακόλουθο παράδειγμα.</para>

    <procedure>
      <title>Στέλνοντας Σήμα σε μία Διεργασία</title>

      <para>Αυτό το παράδειγμα δείχνει πως να στείλετε σήμα στην
	&man.inetd.8;.  Το αρχείο ρύθμισης της <command>inetd</command> είναι
	το <filename>/etc/inetd.conf</filename>, και η
	<command>inetd</command> θα ξανα-διαβάσει αυτό το αρχείο ρύθμισης
	όταν θα σταλεί το σήμα <literal>SIGHUP</literal>.</para>

      <step>
	<para>Βρείτε το PID της διεργασίας, της οποίας επιθυμείτε να στείλετε
	  το σήμα.  Ενεργήστε χρησιμοποιώντας τις εντολές &man.ps.1; και
	  &man.grep.1;.  Η εντολή &man.grep.1; χρησιμοποιείται για να ψάξει
	  στην έξοδο μιας εντολής, για τους αλφαριθμητικούς χαρακτήρες που
	  έχετε ορίσει.  Η εντολή εκτελείται από έναν απλό χρήστη, ενώ η
	  &man.inetd.8; εκτελείται από τον <systemitem class="username">root</systemitem>,
	  επομένως θα πρέπει να προσθέσετε την επιλογή <option>ax</option>
	  στην &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Επομένως το PID της &man.inetd.8; είναι το 198.  Σε μερικές
	  περιπτώσεις μπορεί να εμφανίζεται στην έξοδο η εντολή
	  <literal>grep inetd</literal>.  Αυτό οφείλεται στον τρόπο με τον
	  οποίο η &man.ps.1; ψάχνει την λίστα των ενεργών διεργασιών.</para>
      </step>

      <step>
	<para>Χρησιμοποιήστε την &man.kill.1; για να στείλετε το σήμα.
	  Επειδή η &man.inetd.8; τρέχει από τον <systemitem class="username">root</systemitem>
	  θα πρέπει πρώτα να χρησιμοποιήσετε &man.su.1; για να γίνετε
	  πρώτα <systemitem class="username">root</systemitem>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Όπως και με τις περισσότερες εντολές στο &unix;, η
	  &man.kill.1; δεν θα τυπώσει τίποτε στην έξοδο αν η εντολή είχε
	  επιτυχία.  Εάν στείλετε ένα σήμα σε μια διεργασία που δεν σας
	  ανήκει θα δείτε <errorname>kill: <replaceable>PID</replaceable>:
	  Operation not permitted</errorname>.  Αν πληκτρολογήσετε λάθος
	  το PID τότε ή θα στείλετε το σήμα σε λάθος διεργασία,κάτι που
	  μπορεί να είναι άσχημο, ή, αν είστε τυχερός, θα έχετε στείλει το
	  σήμα σε ένα PID που δεν χρησιμοποιείται τη συγκεκριμένη στιγμή, και
	  θα δείτε <errorname>kill: <replaceable>PID</replaceable>: No such
	  process</errorname>.</para>

	<note>
	  <title>Γιατί να χρησιμοποιήσετε την εντολή
	    <command>/bin/kill</command>;</title>

	  <para>Πολλά κελύφη παρέχουν την εντολή <command>kill</command> ως
	    ενσωματωμένη εντολή.  Αυτό σημαίνει πως το κέλυφος θα στείλει
	    το σήμα άμεσα, αντί να τρέξει το <filename>/bin/kill</filename>.
	    Αυτό μπορεί να είναι πολύ χρήσιμο, αλλά διαφορετικά κελύφη έχουν
	    διαφορετική σύνταξη για τον καθορισμό το όνομα του σήματος που
	    πρέπει να αποσταλεί.  Αντί λοιπόν να πρέπει να μάθουμε όλες τις
	    περιπτώσεις ,είναι ευκολότερο απλά να χρησιμοποιούμε την εντολή
	    <command>/bin/kill ...</command>
	    άμεσα.</para>
	</note>
      </step>
    </procedure>

    <para>Η αποστολή άλλων σημάτων μοιάζει πάρα πολύ, απλά αντικαταστήστε
      το <literal>TERM</literal> ή το <literal>KILL</literal> στη γραμμή
      εντολών με κάποιο άλλο.</para>

    <important>
      <para>Η φόνευση τυχαίων διεργασιών στο σύστημα μπορεί να είναι κακή
	ιδέα.  Ιδιαίτερα, η &man.init.8;, με PID 1, είναι πολύ ειδική.  Η
	εκτέλεση της εντολής <command>/bin/kill -s KILL 1</command> είναι
	ένας γρήγορος τρόπος να σβήσετε το σύστημα σας.
	<emphasis>Πάντα</emphasis> να ελέγχετε δύο φορές τις παραμέτρους που
	χρησιμοποιείτε με την &man.kill.1; <emphasis>πριν</emphasis>
	πιέσετε <keycap>Return</keycap>.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Κελύφη</title>
    <indexterm><primary>κελύφη</primary></indexterm>
    <indexterm><primary>γραμμή εντολών</primary></indexterm>

    <para>Στο &os; ένα μεγάλο μέρος της καθημερινής εργασίας γίνεται σε ένα
      περιβάλλον γραμμής εντολών ονόματι κέλυφος (shell).  Η κύρια δουλειά
      του κελύφους είναι να παίρνει εντολές από το κανάλι εισόδου και να τις
      εκτελεί.  Μερικά κελύφη έχουν ενσωματωμένες λειτουργίες ώστε να βοηθούν
      στις καθημερινές προγραμματισμένες εργασίες όπως διαχείριση αρχείων,
      file globbing, επεξεργασία γραμμής εντολών, μακροεντολές, και
      μεταβλητές περιβάλλοντος.  Το &os; διατίθεται με διάφορα κελύφη, όπως το
      <command>sh</command>, το Bourne Shell και το <command>tcsh</command>,
      το βελτιωμένο C-shell.  Διάφορα άλλα κελύφη είναι διαθέσιμα από την
      Συλλογή των Ports του &os;, όπως τα <command>zsh</command> και
      <command>bash</command>.</para>

    <para>Ποιο κέλυφος να χρησιμοποιήσετε; Είναι πραγματικά θέμα γούστου.
      Εάν είστε προγραμματιστής σε γλώσσα C θα αισθανθείτε περισσότερο
      οικείος με τα κελύφη τύπου C, όπως το <command>tcsh</command>.  Εάν
      έρχεστε από το Linux ή είστε νέος σε περιβάλλον γραμμής εντολών &unix;
      μπορείτε να δοκιμάσετε το <command>bash</command>.  Η ουσία είναι πως
      κάθε κέλυφος έχει μοναδικές ιδιότητες που μπορεί να συνεργαστούν με το
      περιβάλλον εργασίας της προτίμησης σας, και επομένως είναι επιλογή σας
      ποιο κέλυφος να χρησιμοποιήσετε.</para>

    <para>Μια κοινή ιδιότητα όλων των κελυφών είναι η αυτόματη συμπλήρωση
      ονομάτων αρχείων.  Αφού έχετε πληκτρολογήσει τα πρώτα γράμματα μιας
      εντολής ή ενός ονόματος αρχείου αν πιέσετε το πλήκτρο
      <keycap>Tab</keycap> στο πληκτρολόγιο, τότε το κέλυφος αυτόματα θα
      ολοκληρώσει το υπόλοιπο της εντολής ή του ονόματος αρχείου.  Ας δώσουμε
      ένα παράδειγμα.  Ας υποθέσουμε πως έχετε δύο αρχεία
      <filename>foobar</filename> και <filename>foo.bar</filename>.  Αν
      θέλετε να σβήσετε το <filename>foo.bar</filename> θα πρέπει να
      πληκτρολογήσετε
      <command>rm fo[Tab].[Tab]</command>.</para>

    <para>Το κέλυφος θα τυπώσει αυτόματα <command>rm foo[BEEP].bar</command>.</para>

    <para>Το [BEEP] είναι το κουδούνι της κονσόλας, το οποίο μας πληροφορεί
      πως δεν ήταν δυνατόν να ολοκληρώσει το όνομα του αρχείου διότι υπάρχουν
      περισσότερα από ένα ονόματα αρχείων που ταιριάζουν.  Όντως το
      <filename>foobar</filename> και το <filename>foo.bar</filename>
      ξεκινούν με <literal>fo</literal>, και το κέλυφος κατάφερε να
      συμπληρώσει ως το <literal>foo</literal>.  Αν πληκτρολογήσετε επιπλέον
      <literal>.</literal>, και μετά πάλι <keycap>Tab</keycap>, το κέλυφος
      θα καταφέρει να συμπληρώσει το υπόλοιπο του ονόματος αρχείου
      για σας.</para>

    <indexterm><primary>μεταβλητές περιβάλλοντος</primary></indexterm>

    <para>Άλλο ιδιαίτερο χαρακτηριστικό του κελύφους είναι η χρήση των
      μεταβλητών περιβάλλοντος.  Οι μεταβλητές περιβάλλοντος είναι ένα ζεύγος
      μεταβλητών/κλειδιών αποθηκευμένα στον περιβάλλοντα χώρο του κελύφους
      Αυτός ο χώρος μπορεί να διαβαστεί από οποιοδήποτε πρόγραμμα που
      καλείται από το κέλυφος, και έτσι περιέχει πλήθος ρυθμίσεων
      προγραμμάτων.  Ακολουθεί μία λίστα με συνήθεις μεταβλητές περιβάλλοντος
      και τη σημασία τους:</para>

    <indexterm><primary>μεταβλητές περιβάλλοντος</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Μεταβλητή</entry>
	    <entry>Περιγραφή</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Όνομα του τρέχοντα χρήστη.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Λίστα καταλόγων για την αναζήτηση εκτελέσιμων χωρισμένη
	      με άνω-κάτω τελείες.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Όνομα δικτύου της οθόνης X11 που είναι διαθέσιμη για
	      σύνδεση, αν υπάρχει.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Το ενεργό κέλυφος.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Το όνομα του τύπου του τερματικού χρήστη.  Ορίζει τις
	      δυνατότητες του τερματικού.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Εγγραφή στη βάση δεδομένων κωδικών escape για διάφορες
	      λειτουργίες τερματικών.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Ο τύπος του λειτουργικού συστήματος π.χ., &os;.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Η αρχιτεκτονική CPU στην οποία δουλεύει το σύστημα.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Ο προεπιλεγμένος κειμενογράφος του χρήστη.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Το προεπιλεγμένο πρόγραμμα σελιδοποίησης του
	      χρήστη.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Λίστα καταλόγων για την αναζήτηση των σελίδων βοηθείας
	      (man pages) χωρισμένη με άνω-κάτω τελείες.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>

    <para>Ο ορισμός μιας μεταβλητής περιβάλλοντος διαφέρει κάπως από κέλυφος
      σε κέλυφος.  Για παράδειγμα στα κελύφη τύπου-C, όπως τα
      <command>tcsh</command> και <command>csh</command>, θα πρέπει να
      χρησιμοποιήσετε την <command>setenv</command> για να ορίσετε μεταβλητές
      περιβάλλοντος.  Σε κελύφη Bourne όπως τα <command>sh</command> και
      <command>bash</command>, θα πρέπει να χρησιμοποιείτε την
      <command>export</command> για να θέσετε τις τρέχουσες μεταβλητές
      περιβάλλοντος.  Για παράδειγμα, για να ορίσετε ή να μετατρέψετε την
      μεταβλητή περιβάλλοντος <envar>EDITOR</envar>, σε
      <command>csh</command> ή <command>tcsh</command> θα πρέπει να δώσετε
      μια εντολή που να θέτει τη μεταβλητή <envar>EDITOR</envar> στο
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Για κελύφη Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Μπορείτε επίσης στα περισσότερα κελύφη να αναπτύσσετε τις
      μεταβλητές περιβάλλοντος τοποθετώντας μπροστά τους τον χαρακτήρα
      <literal>$</literal>.  Για παράδειγμα, η <command>echo $TERM</command>
      θα τυπώσει την τιμή που έχουμε θέσει στην μεταβλητή, διότι το κέλυφος
      αναπτύσσει την <envar>$TERM</envar> και περνά την τιμή της στην
      <command>echo</command>.</para>

    <para>Τα κελύφη χρησιμοποιούν μερικούς ειδικούς χαρακτήρες, που
      ονομάζονται meta-χαρακτήρες για εμφανίσεις ιδιαίτερων δεδομένων.  Ο πιο
      κοινός εξ' αυτών είναι ο χαρακτήρας <literal>*</literal>, ο οποίος
      αντιπροσωπεύει οποιοδήποτε αλφαριθμητικό χαρακτήρα σε ένα όνομα αρχείου.
      Αυτοί οι ειδικοί meta-χαρακτήρες μπορούν να χρησιμοποιηθούν για να
      κάνουν filename globbing.  Για παράδειγμα, αν πληκτρολογήσετε
      <command>echo *</command> είναι σχεδόν το ίδιο με το να δώσετε
      <command>ls</command> διότι το κέλυφος παίρνει όλα τα αρχεία που
      ταιριάζουν με <literal>*</literal> και τα προωθεί στην γραμμή εντολών
      για την <command>echo</command>.</para>

    <para>Για να εμποδίσετε το κέλυφος να επεξεργαστεί αυτούς τους ειδικούς
      χαρακτήρες, μπορείτε να χρησιμοποιήσετε το σύμβολο διαφυγής (escape)
      τοποθετώντας μπροστά τους μια δεξιόστροφη κάθετο
      (<literal>\</literal>).  Η <command>echo $TERM</command> τυπώνει τον
      τύπο του τερματικού σας, ενώ η <command>echo \$TERM</command> τυπώνει
      απλά <envar>$TERM</envar>.</para>

    <sect2 xml:id="changing-shells">
      <title>Αλλάζοντας το Κέλυφος σας</title>

      <para>Ο ευκολότερος τρόπος για να αλλάξετε το κέλυφος σας είναι να
	χρησιμοποιήσετε την εντολή <command>chsh</command>.  Τρέχοντας την
	<command>chsh</command> θα οδηγηθείτε στον κειμενογράφο που έχετε
	θέσει στην μεταβλητή περιβάλλοντος <envar>EDITOR</envar>, ενώ αν δεν
	έχετε θέσει, θα οδηγηθείτε στο <command>vi</command>.  Αλλάξτε
	κατάλληλα τη γραμμή <quote>Shell:</quote></para>

      <para>Μπορείτε επίσης να δώσετε στην <command>chsh</command> την
	επιλογή <option>-s</option>, αυτή θα θέσει το κέλυφος για σας, δίχως
	να χρειαστεί να χρησιμοποιήσετε τον κειμενογράφο.  Για παράδειγμα, αν
	θέλετε να αλλάξετε το κέλυφος σας σε <command>bash</command>, η
	ακόλουθη εντολή είναι ακριβώς αυτό που χρειάζεστε:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Το κέλυφος στο οποίο επιθυμείτε να μεταβείτε
	  <emphasis>πρέπει</emphasis> να είναι καταχωρημένο στο αρχείο
	  <filename>/etc/shells</filename>.  Αν έχετε εγκαταστήσει ένα
	  κέλυφος από τη <link linkend="ports">συλλογή των ports</link>, τότε
	  αυτό θα πρέπει να έχει ήδη γίνει.  Αν εγκαταστήσατε το κέλυφος μόνοι
	  σας, τότε θα πρέπει να εκτελέσετε τη διαδικασία που
	  ακολουθεί.</para>

	<para>Αν για παράδειγμα, εγκαταστήσατε το <command>bash</command>
	  μόνοι σας και το τοποθετήσατε στον
	  <filename>/usr/local/bin</filename>, τότε θα πρέπει να
	  δώσετε:</para>

	<screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

	<para>Και μετά ξανατρέξτε την <command>chsh</command>.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Κειμενογράφοι</title>
    <indexterm><primary>κειμενογράφοι</primary></indexterm>
    <indexterm><primary>επεξεργαστές κειμένου</primary></indexterm>

    <para>Αρκετές ρυθμίσεις στο &os; γίνονται με επεξεργασία αρχείων
      κειμένου.  Για αυτό το λόγο, θα ήταν καλή ιδέα να εξοικειωθείτε με ένα
      κειμενογράφο.  Αρκετοί περιέχονται στο βασικό σύστημα του &os; και
      πολλοί περισσότεροι είναι διαθέσιμοι στην Συλλογή των Ports
      (Ports Collection).</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>κειμενογράφοι</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>Ο ευκολότερος και απλούστερος κειμενογράφος για να μάθετε ονομάζεται
      <application>ee</application>, που σημαίνει easy editor (εύκολος
      κειμενογράφος).  Για να ξεκινήσετε τον <application>ee</application>,
      πρέπει να πληκτρολογήσετε στην γραμμή εντολών
      <command>ee filename</command> όπου
      <replaceable>filename</replaceable> είναι το όνομα του αρχείου που
      θέλετε να επεξεργαστείτε.  Για παράδειγμα, για να επεξεργαστείτε το
      <filename>/etc/rc.conf</filename>, πληκτρολογείτε
      <command>ee /etc/rc.conf</command>.  Μόλις εισέλθετε στο
      <command>ee</command>, όλες οι εντολές για να χειριστείτε τις
      λειτουργίες του κειμενογράφου αναφέρονται στο πάνω μέρος της οθόνης.
      Ο χαρακτήρας καπέλο <literal>^</literal> σημαίνει το πλήκτρο
      <keycap>Ctrl</keycap>, επομένως <literal>^e</literal> σημαίνει πως
      πρέπει να πληκτρολογήσετε τον συνδυασμό πλήκτρων
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap>
      </keycombo>.  Για να βγείτε από το <application>ee</application>,
      πιέζετε το πλήκτρο <keycap>Esc</keycap>, και επιλέγετε leave editor.
      Ο κειμενογράφος θα σας προτρέψει να σώσετε τυχόν αλλαγές, αν έχετε
      επεξεργαστεί το αρχείο.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>Το &os; παρέχεται επίσης με πιο εξελιγμένους κειμενογράφους όπως
      το ενσωματωμένο στο βασικό σύστημα <application>vi</application>.  Το
      <application>Emacs</application> και το <application>vim</application>,
      είναι μέρος της Συλλογής των Ports του &os;
      (<package>editors/emacs</package> και
      <package>editors/vim</package>).  Αυτοί οι
      κειμενογράφοι προσφέρουν πολλές περισσότερες λειτουργίες και
      δυνατότητες, με κόστος αυξημένη πολυπλοκότητα και δυσκολία εκμάθησης.
      Ωστόσο αν σχεδιάζετε να επεξεργαστείτε αρκετά κείμενα, η εκμάθηση ενός
      ισχυρού κειμενογράφου όπως το
      <application>vim</application> ή το <application>Emacs</application> θα
      σας γλυτώσει πολύ περισσότερο χρόνο επεξεργασίας στην πορεία.</para>

    <para>Πολλές εφαρμογές που χρειάζεται να αλλάξουν κάποιο αρχείο ή
      απαιτούν από το χρήστη να πληκτρολογήσει κάποιο κείμενο, θα ανοίξουν
      αυτόματα κάποιο κειμενογράφο.  Για να αλλάξετε τον προεπιλεγμένο
      κειμενογράφο, θα πρέπει να θέσετε κατάλληλη τιμή στην μεταβλητή
      περιβάλλοντος <envar>EDITOR</envar>.  Δείτε την ενότητα <link linkend="shells">Κελύφη</link> για περισσότερες λεπτομέρειες.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Συσκευές και Αρχεία συσκευών</title>

    <para>Συσκευή είναι ένας όρος που αναφέρεται σε σχέση με
      λειτουργίες hardware ενός συστήματος, περιλαμβάνοντας δίσκους,
      εκτυπωτές, κάρτες γραφικών και πληκτρολόγια.  Κατά την εκκίνηση του &os;
      οι περισσότερες πληροφορίες που αναγράφονται στην οθόνη είναι συσκευές
      που αναγνωρίζονται από το σύστημα.  Μπορείτε να ξαναδείτε τα μηνύματα
      εκκίνησης, διαβάζοντας το <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Για παράδειγμα, <filename>acd0</filename> είναι ο πρώτος
      οδηγός IDE CDROM, ενώ το <filename>kbd0</filename> αντιπροσωπεύει
      το πληκτρολόγιο.</para>

    <para>Στις περισσότερες από αυτές τις συσκευές σε ένα λειτουργικό σύστημα
      &unix; η πρόσβαση πρέπει να γίνεται διαμέσου ειδικών αρχείων που
      ονομάζονται αρχεία συσκευών, και είναι τοποθετημένα στον κατάλογο
      <filename>/dev</filename>.</para>

    <sect2>
      <title>Δημιουργώντας Αρχεία Συσκευών</title>
      <para>Όταν προσθέτετε μια νέα συσκευή στο σύστημα σας, ή μεταγλωττίζετε
	πηγαίο κώδικα για υποστήριξη νέων οδηγών, πρέπει να δημιουργούνται
	νέα αρχεία συσκευών.</para>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System)</title>

	<para> Το σύστημα αρχείων συσκευών ή, <literal>DEVFS</literal>,
	  παρέχει πρόσβαση στο χώρο ονομάτων συσκευών του πυρήνα (device
	  namespace) στο global σύστημα αρχείων του συστήματος.  Αντί να
	  δημιουργείτε και να μετατρέπετε αρχεία συσκευών, το
	  <literal>DEVFS</literal> συντηρεί για σας αυτό το ιδιαίτερο σύστημα
	  αρχείων.</para>

	<para>Δείτε την σελίδα βοηθείας &man.devfs.5; για περισσότερες
	  πληροφορίες.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">
    <title>Τύποι Εκτελέσιμων</title>

    <para>Για να καταλάβετε γιατί το &os; χρησιμοποιεί τον τύπο &man.elf.5;
      θα πρέπει πρώτα να γνωρίζετε μερικά πράγματα για τους τρεις
      <quote>κυρίαρχους</quote> τύπους εκτελέσιμων για το &unix;</para>

    <itemizedlist>
      <listitem>
	<para>&man.a.out.5;</para>

	<para>Ο παλαιότερος και πιο <quote>κλασσικός</quote> τύπος
	  αντικειμένων του &unix;.  Χρησιμοποιεί μια μικρή και συμπαγή
	  κεφαλίδα με ένα μαγικό νούμερο στην αρχή που συχνά χρησιμοποιείται
	  για να χαρακτηρίζει τον τύπο (δείτε για περισσότερες πληροφορίες
	  την &man.a.out.5;).  Περιέχει τρία φορτωμένα τμήματα: .text, .data
	  και .bss και επιπλέον ένα πίνακα συμβόλων και ένα πίνακα
	  αλφαριθμητικών χαρακτήρων.</para>
      </listitem>

      <listitem>
	<para><acronym>COFF</acronym></para>

	<para>Ο τύπος αντικειμένου SVR3.  Η κεφαλίδα τώρα αποτελείται από ένα
	  πίνακα τομέων, ώστε να μπορούμε να έχουμε κάτι παραπάνω από απλά
	  .text, .data και .bss.</para>
      </listitem>

      <listitem>
	<para>&man.elf.5;</para>

	<para>Ο διάδοχος του <acronym>COFF</acronym>, περιλαμβάνει πολλαπλά
	  τμήματα και δέχεται τιμές 32 ή 64 bit.  Το βασικό μειονέκτημα:
	  Ο <acronym>ELF</acronym> σχεδιάστηκε με την προϋπόθεση πως θα
	  υπήρχε μόνο ένα ABI για κάθε αρχιτεκτονική συστήματος.  Αυτή η
	  υπόθεση είναι όμως εσφαλμένη τώρα, αφού ακόμη και στον εμπορικό
	  κόσμο του SYSV (όπου υπάρχουν τουλάχιστον τρία ABI: SRV4, Solaris,
	  SCO) δεν ισχύει.</para>

	<para>Το &os; προσπαθεί να ξεπεράσει αυτό το πρόβλημα παρέχοντας
	  ένα βοηθητικό πρόγραμμα με το οποίο μπορούμε να
	  <emphasis>ενσωματώσουμε (branding)</emphasis> σε ένα εκτελέσιμο
	  <acronym>ELF</acronym> τις πληροφορίες για το ABI που είναι συμβατό
	  με αυτό.  Δείτε την σελίδα manual του &man.brandelf.1; για
	  περισσότερες πληροφορίες.</para>
      </listitem>
    </itemizedlist>

    <para>Το &os; προέρχεται από τον <quote>κλασσικό</quote> χώρο και
      μέχρι την αρχή της σειράς 3.X, χρησιμοποιούσε τον τύπο &man.a.out.5;,
      μια τεχνολογία δοκιμασμένη και αποδεδειγμένη σε πολλές γενιές εκδόσεων
      του BSD.  Αν και η μεταγλώττιση και εκτέλεση εγγενών εκτελέσιμων (και
      πυρήνων) τύπου <acronym>ELF</acronym> ήταν δυνατή στα &os; συστήματα
      ήδη από πολύ καιρό πριν, το &os; αρχικά αντιστάθηκε στην
      <quote>ώθηση</quote> για καθιέρωση του <acronym>ELF</acronym> ως
      προκαθορισμένου τύπου.  Γιατί; Όταν ο κόσμος του Λίνουξ έκανε την
      οδυνηρή μετάβαση προς το <acronym>ELF</acronym>, δεν ήταν τόσο για να
      ξεφύγει από τον τύπο εκτελέσιμων <filename>a.out</filename> όσο για να
      αντιμετωπίσει το δύσκαμπτο δικό τους μηχανισμό κοινόχρηστων βιβλιοθηκών,
      ο οποίος βασίζονταν σε jump-tables και προκαλούσε μεγάλη δυσχέρεια στην
      κατασκευή τους, τόσο στους προγραμματιστές όσο και στους μεταπωλητές.
      Από τη στιγμή που τα διαθέσιμα εργαλεία του <acronym>ELF</acronym>
      προσέφεραν λύση στο πρόβλημα των κοινών βιβλιοθηκών και έγινε γενικώς
      αποδεκτό πως ήταν <quote>ο δρόμος προς τα εμπρός</quote>, έγινε
      αποδεκτό το αναγκαίο κόστος της μεταφοράς και επιτεύχθηκε η μετακίνηση.
      Ο μηχανισμός κοινόχρηστων βιβλιοθηκών του &os; βασίζεται σε μεγάλο
      βαθμό στον αντίστοιχο μηχανισμό του &sunos; της Sun και είναι πολύ
      εύκολος στη χρήση.</para>

    <para>Τότε, γιατί υπάρχουν τόσοι διαφορετικοί τύποι;</para>

    <para>Πίσω στο σκοτεινό παρελθόν, υπήρχε απλό hardware.  Αυτό
      το απλό hardware υποστήριζε ένα απλό, μικρό σύστημα.  Το
      <filename>a.out</filename> ήταν απόλυτα κατάλληλο για την αναπαράσταση
      εκτελέσιμων σε αυτό το απλό σύστημα (ένα PDP-11).  Όταν ο κόσμος άρχισε
      να μεταφέρει το &unix; από αυτό το απλό σύστημα, διατηρήθηκε ο τύπος
      <filename>a.out</filename> γιατί ήταν ικανοποιητικός για τα πρώτα
      ports του &unix; σε αρχιτεκτονικές όπως η Motorola 68k, VAXen,
      κτλ.</para>

    <para>Μετέπειτα κάποιος λαμπρός μηχανικός hardware αποφάσισε
      πως αφού μπορούσε να εξαναγκάζει το λογισμικό να κάνει τόσα
      πρόχειρα κόλπα, θα μπορούσε επίσης να παραλείψει μερικές πύλες
      από το σχεδιασμό ώστε να επιτρέψει στον πυρήνα της CPU να τρέχει
      γρηγορότερα.  Αν και διασκευάσθηκε ώστε να δουλεύει με αυτό το νέο
      είδος hardware (γνωστό σήμερα ως <acronym>RISC</acronym>), ο τύπος
      <filename>a.out</filename> ήταν τελικά ακατάλληλος για αυτό, και έτσι
      σχεδιάστηκαν πολλοί νέοι τύποι για να επιτευχθεί καλύτερη απόδοση από
      το hardware από ότι ήταν δυνατόν με τον απλό και περιοριστικό τύπο
      <filename>a.out</filename>.  Εφευρέθηκαν διάφοροι τύποι όπως οι
      <acronym>COFF</acronym>, <acronym>ECOFF</acronym>, και μερικοί άλλοι
      λιγότερο γνωστοί, και ερευνήθηκαν οι περιορισμοί τους ώσπου τα πράγματα
      σταθεροποιήθηκαν στο <acronym>ELF</acronym>.</para>

    <para>Επιπλέον, το μέγεθος των προγραμμάτων γινόταν όλο και μεγαλύτερο
      και οι δίσκοι (και η φυσική μνήμη) ήταν ακόμη σχετικά μικροί και κάπως
      έτσι γεννήθηκε η ιδέα της κοινής βιβλιοθήκης.  Το σύστημα VM έγινε
      επίσης περισσότερο περίπλοκο.  Κάθε μία από τις βελτιώσεις γινόταν
      με βάση τον τύπο <filename>a.out</filename>, που όμως γινόταν όλο και
      πιο δύσχρηστος με κάθε νέα προσθήκη.  Επιπρόσθετα, ο κόσμος ήθελε να
      φορτώνει τμήματα δυναμικά ενώ το σύστημα ήταν σε φάση εκτέλεσης, ή να
      εξαλείφει μέρη προγραμμάτων αφού είχε εκτελεστεί ο κώδικας αρχικοποίησης
      (init) ώστε να εξοικονομηθεί φυσική μνήμη και χώρος swap.  Οι γλώσσες
      προγραμματισμού γινόντουσαν ακόμα πιο περίπλοκες και ο κόσμος ήθελε
      αυτόματη φόρτωση και εκτέλεση κώδικα πριν την κλήση της main.  Έγιναν
      πρόχειρες διορθώσεις (hacks) στον τύπο <filename>a.out</filename> ώστε
      να συμβαδίζει με όλες αυτές τις αλλαγές, και πράγματι, για μια περίοδο
      έδειχνε να λειτουργεί.  Με τον καιρό όμως, φάνηκε ότι ο τύπος
      <filename>a.out</filename> δεν θα μπορούσε να αντεπεξέλθει σε όλα αυτά
      τα προβλήματα, αφού θα έπρεπε να αναπτύσσεται συνεχώς και με περίπλοκο
      τρόπο.  Αν και το <acronym>ELF</acronym> έλυνε πολλά από αυτά τα
      προβλήματα, η μετάβαση σε αυτό ενός συστήματος που βασικά λειτουργούσε,
      θα οδηγούσε σε οδυνηρές καταστάσεις.  Έτσι ο τύπος
      <acronym>ELF</acronym> έπρεπε να περιμένει μέχρι τη στιγμή όπου η
      παραμονή στο <filename>a.out</filename> θα δημιουργούσε περισσότερα
      προβλήματα από ότι η μετάβαση στο <acronym>ELF</acronym>.</para>

    <para>Ωστόσο, όσο ο καιρός περνούσε, και τα εργαλεία μεταγλώττισης από
      τα οποία προέρχονται τα αντίστοιχα εργαλεία του &os; (ειδικότερα ο
      assembler και ο loader), αναπτύχθηκαν παράλληλα σε δύο δέντρα.  Το
      δέντρο του &os; πρόσθεσε κοινές βιβλιοθήκες και διόρθωσε κάποια
      σφάλματα.  Η ομάδα του GNU που είχε αρχικά γράψει αυτά τα
      προγράμματα, τα έγραψε ξανά και πρόσθεσε ευκολότερη υποστήριξη για
      κατασκευή cross compilers, την ενσωμάτωση διαφορετικών τύπων κατά
      βούληση, κλπ.  Αν και πολλοί ζητούσαν να κατασκευαστούν cross compilers
      για &os;, ήταν άτυχοι, αφού ο παλιός πηγαίος κώδικας του &os; για τα
      <application>as</application> και <application>ld</application> τα
      έκανε ακατάλληλα.  Η νέα αλυσίδα εργαλείων του GNU
      (<application>binutils</application>) υποστηρίζει cross compiling,
      <acronym>ELF</acronym>, κοινές βιβλιοθήκες, προεκτάσεις C++, κτλ.
      Επιπλέον, πολλοί τρίτοι κατασκευαστές προσφέρουν εκτελέσιμα ELF, και
      είναι πολύ καλό να μπορούν να εκτελεστούν στο &os;.</para>

    <para>Ο <acronym>ELF</acronym> είναι πιο εκφραστικός από τον
      <filename>a.out</filename> και περισσότερο επεκτάσιμος στο βασικό
      σύστημα.  Τα εργαλεία <acronym>ELF</acronym> είναι ευκολότερα στην
      συντήρηση και προσφέρουν υποστήριξη για cross compilers,
      κάτι που είναι πολύ σημαντικό για μερικούς ανθρώπους.  Μπορεί ο
      <acronym>ELF</acronym> να είναι λίγο πιο αργός από τον
      <filename>a.out</filename>, αλλά η διαφορά δεν είναι αισθητή.  Υπάρχουν
      επίσης πολλές άλλες διαφορές μεταξύ τους, σε λεπτομέρειες όπως τον τρόπο
      που αντιστοιχίζουν σελίδες, που χειρίζονται τον κώδικα init, κλπ.
      Καμιά από αυτές δεν είναι πολύ σημαντική, αλλά ωστόσο δεν παύουν να
      είναι διαφορές.  Με τον καιρό η υποστήριξη για το
      <filename>a.out</filename> θα απομακρυνθεί από τον πυρήνα GENERIC, και
      τελικά θα αφαιρεθεί εντελώς από τον πυρήνα όταν εκλείψει ολοκληρωτικά η
      ανάγκη εκτέλεσης παλαιών προγραμμάτων τύπου <filename>a.out</filename>.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Για Περισσότερες Πληροφορίες</title>

    <sect2 xml:id="basics-man">
      <title>Σελίδες Βοηθείας</title>
      <indexterm><primary>σελίδες βοηθείας</primary></indexterm>

      <para>Η πιο κατανοητή τεκμηρίωση στο &os; προσφέρεται με τη μορφή των
	σελίδων βοηθείας (manual pages).  Σχεδόν για κάθε πρόγραμμα του
	συστήματος δίνεται μια σύντομη αναφορά που εξηγεί τις βασικές
	λειτουργίες και διάφορα άλλα θέματα.  Αυτές οι σελίδες προβάλλονται με
	την εντολή <command>man</command>.  Η χρήση της εντολής
	<command>man</command> είναι απλή:</para>

      <screen>&prompt.user; <userinput>man command</userinput></screen>

      <para>όπου <literal>command</literal> είναι το όνομα της εντολής για την
	οποία επιθυμείτε να μάθετε περισσότερες πληροφορίες.  Για παράδειγμα,
	για να μάθετε περισσότερα για την εντολή <command>ls</command>
	πληκτρολογήστε:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Το online manual χωρίζεται σε τέσσερις αριθμημένες
	ενότητες:</para>

      <orderedlist>
	<listitem>
	  <para>Εντολές χρήστη.</para>
	</listitem>

	<listitem>
	  <para>Κλήσεις συστήματος και αριθμοί σφαλμάτων.</para>
	</listitem>

	<listitem>
	  <para>Συναρτήσεις των βιβλιοθηκών της C.</para>
	</listitem>

	<listitem>
	  <para>Οδηγοί συσκευών.</para>
	</listitem>

	<listitem>
	  <para>Τύποι αρχείων.</para>
	</listitem>

	<listitem>
	  <para>Παιχνίδια και άλλες εφαρμογές διασκέδασης.</para>
	</listitem>

	<listitem>
	  <para>Διάφορες πληροφορίες.</para>
	</listitem>

	<listitem>
	  <para>Συντήρηση συστήματος και εντολές λειτουργίας.</para>
	</listitem>

	<listitem>
	  <para>Ανάπτυξη πυρήνα.</para>
	</listitem>
      </orderedlist>

      <para>Σε μερικές περιπτώσεις, το ίδιο θέμα μπορεί να εμφανίζεται σε
	περισσότερες ενότητες των σελίδων βοηθείας.  Για παράδειγμα, υπάρχει
	η εντολή χρήστη <command>chmod</command> και η κλήση συστήματος
	<function>chmod()</function>.  Σε αυτή τη περίπτωση, μπορείτε να
	πείτε στην εντολή <command>man</command> ποια ακριβώς θέλετε
	επιλέγοντας την ενότητα:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Με αυτόν τον τρόπο θα εμφανιστεί η σελίδα βοηθείας για την
	εντολή χρήστη <command>chmod</command>.  Οι αναφορές σε μια ειδική
	ενότητα των σελίδων βοηθείας τοποθετούνται παραδοσιακά μέσα σε
	παρένθεση στην τυπωμένη τεκμηρίωση, επομένως το &man.chmod.1;
	αναφέρεται στην εντολή χρήστη <command>chmod</command> και το
	&man.chmod.2; αναφέρεται στην κλήση συστήματος.</para>

      <para>Αυτό είναι χρήσιμο όταν γνωρίζουμε το όνομα της εντολής και απλά
	επιθυμούμε να μάθουμε πως να την χρησιμοποιήσουμε, αλλά τι γίνεται
	αν δεν γνωρίζουμε το όνομα της;  Μπορείτε να χρησιμοποιήσετε το
	<command>man</command> για να αναζητήσετε λέξεις κλειδιά από τις
	περιγραφές των εντολών χρησιμοποιώντας την επιλογή
	<option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Με την εντολή αυτή θα εμφανιστεί μία λίστα από εντολές που
	περιέχουν την λέξη κλειδί <quote>mail</quote> στην περιγραφή τους.
	Αυτό είναι αντίστοιχο με το να χρησιμοποιήσετε την εντολή
	<command>apropos</command>.</para>

      <para>Επομένως, βλέπετε όλες αυτές τις γουστόζικες εντολές στον
	<filename>/usr/bin</filename> αλλά δεν έχετε την παραμικρή ιδέα του
	τι πραγματικά κάνουν; Απλά πληκτρολογήστε:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>ή</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

      <para>το οποίο κάνει ακριβώς το ίδιο πράγμα.</para>
    </sect2>

    <sect2 xml:id="basics-info">
      <title>GNU Info Files</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>Το &os; περιλαμβάνει πολλές εφαρμογές και βοηθητικά προγράμματα
	που έχουν δημιουργηθεί από την Free Software Foundation (FSF).  Πέρα
	από τις σελίδες βοηθείας, τα προγράμματα αυτά παρέχονται με
	τεκμηρίωση μορφής hypertext σε αρχεία που ονομάζονται
	<literal>info</literal> και τα οποία μπορείτε να προβάλλετε με την
	εντολή <command>info</command> ή, αν έχετε εγκαταστήσει το
	<application>emacs</application>, μέσω της κατάστασης λειτουργίας
	info mode του <application>emacs</application>.</para>

      <para>Για να χρησιμοποιήσετε την εντολή &man.info.1;, απλά
	πληκτρολογήστε:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Για μια σύντομη εισαγωγή, πληκτρολογήστε <literal>h</literal>.
	Για μια γρήγορη αναφορά εντολής, πληκτρολογήστε
	<literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
