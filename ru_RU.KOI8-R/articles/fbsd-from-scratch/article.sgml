<!--
     The FreeBSD Russian Documentation Project

     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/articles/fbsd-from-scratch/article.sgml,v 1.5 2005/06/12 13:52:24 gad Exp $

     Original revision: r33355
-->

<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % articles.ent PUBLIC "-//FreeBSD//ENTITIES DocBook FreeBSD Articles Entity Set//EN">
%articles.ent;
<!ENTITY scratch.ap "<application>FreeBSD From Scratch</application>">
]>

<article lang="ru">
  <articleinfo>
    <title>FreeBSD "с нуля"</title>

    <author>
      <firstname>Jens</firstname>

      <surname>Schweikhardt</surname>

      <affiliation>
        <address><email>schweikh@FreeBSD.org</email></address>
      </affiliation>
    </author>

    <copyright>
      <year>2002,2003,2004,2008</year>

      <holder>Jens Schweikhardt</holder>
    </copyright>

    <pubdate>$FreeBSD$</pubdate>

    <legalnotice id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.adobe;
      &tm-attrib.general;
    </legalnotice>
  </articleinfo>

  <abstract>
    <para>В этой статье описываются мои достижения в создании &scratch.ap;:
      полностью автоматизированной установки скомпилированной из исходных
      текстов системы &os;, включая компиляцию всех ваших любимых портов
      и преднастройку в соответствии с вашими представлениями о завершенной
      системе.  Если вы полагаете, что концепция <command>make world</command>
      является прекрасным подходом, то &scratch.ap; расширяет это понятие до
      <command>make evenmore</command>.</para>
  </abstract>

  <sect1 id="introduction">
    <title>Введение</title>

    <para>Вы когда-либо обновляли вашу систему при помощи
      <command>make world</command>?  Существует одна проблема, возникающая
      при наличии всего лишь одной системы на диске.  Если выполнение цели
      <maketarget>installworld</maketarget> прерывается на середине, у вас
      остаётся неработоспособная система, которая может даже не загружаться.
      Либо цель <maketarget>installworld</maketarget> отрабатывает нормально,
      а новое ядро не загружается.  Тогда наступает момент для поиска Fixit CD
      и резервных копий, которые вы делали полгода назад.</para>

    <para>Я исповедую подход <quote>сотрите данные на дисках при обновлении
      систем</quote>.  Удаление дисков, и даже разделов, обеспечивает вам то,
      что нигде не остаётся никаких частей старого, то, о чём не заботятся
      большее число процедур обновления.  Однако очистка разделов означает, что
      вам нужно перекомпилировать/переустановить все ваши порты и пакаджи, а
      также проделать все тонкие процедуры настройки.  Если вы думаете, что
      эта задача тоже должна быть автоматизирована, то читайте дальше.</para>
  </sect1>

  <sect1 id="why">
    <title>Почему мне (не) нужна &scratch.ap;?</title>

    <para>Это закономерный вопрос.  У нас имеется утилита
      <application>sysinstall</application> и хорошо изученный способ
      компиляции ядра и пользовательских приложений.</para>

    <para>Проблема с утилитой <application>sysinstall</application> заключается
      в том, что она несколько ограничена в том, что, куда и как может
      устанавливать.</para>

    <itemizedlist>
      <listitem>
        <para>Обычно она используется для установки уже откомпилированных
          дистрибутивных наборов и пакаджей с некоторого носителя (CD, DVD,
          FTP).  Она не может устанавливать результат выполнения
          <literal>make buildworld</literal>.</para>
      </listitem>

      <listitem>
        <para>Она не может устанавливать вторую систему в некоторый каталог
          уже работающей системы.</para>
      </listitem>

      <listitem>
        <para>Она не может выполнять установку в разделы
          <application>Vinum</application> или
	  <application>ZFS</application>.</para>
      </listitem>

      <listitem>
        <para>Она не может строить порты, а лишь устанавливать уже
          откомпилированные пакаджи.</para>
      </listitem>

      <listitem>
        <para>Создание скриптов или выполнение нестандартных действий после
          установки затруднено.</para>
      </listitem>

      <listitem>
        <para>И последним, но одним из самых важных факторов, является
          полуофициальное прекращение дальнейшей поддержки
          <application>sysinstall</application>.</para>
      </listitem>
    </itemizedlist>

    <para>Хорошо известный способ полного построения и установки системы,
      описанный в <ulink
      url="http://www.FreeBSD.org/doc/ru_RU.KOI8-R/books/handbook/makeworld.html">
      Руководстве</ulink>, по умолчанию замещает существующую систему.  При
      этом сохраняются только модули и ядро.  Системные бинарные файлы, файлы
      объявлений функций и множество других файлов перезаписываются; уже
      ненужные файлы остаются и могут преподносить сюрпризы.  Если по
      какой-либо причине обновление завершилось неудачно, бывает трудно и даже
      невозможно вернуть систему в исходное состояние.</para>

    <para>&scratch.ap; решает все эти проблемы.  Её стратегия проста:
      использование работающей системы для установки новой в пустое дерево
      каталогов, при этом новые разделы монтируются в соответствующие места
      этого дерева.  Многие конфигурационные файлы могут быть скопированы в
      соответствующее место, а &man.mergemaster.8; сможет позаботиться о тех,
      что скопировать не удалось.  Тонкая настройка новой системы может быть
      выполнена в старой, вплоть до момента, когда вы сможете выполнить chroot
      в новую систему.  Другими словами, мы проходим через три этапа, при этом
      каждый шаг представляет собой либо запуск скрипта, либо вызов команды
      <command>make</command>:</para>

    <orderedlist>
      <listitem>
        <para><filename>stage_1.sh</filename>:
          Создание новой загружаемой системы в пустом каталоге и объединение
          либо копирование максимально большего количества необходимых файлов.
          Затем загрузка новой системы.</para>
      </listitem>

      <listitem>
        <para><filename>stage_2.sh</filename>:
          Установка требуемых портов.</para>
      </listitem>

      <listitem>
        <para><filename>stage_3.mk</filename>:
          Выполнение последующей настройки программного обеспечения,
          установленного на предыдущем этапе.</para>
      </listitem>
    </orderedlist>

    <para>После того, как вы воспользуетесь &scratch.ap; для построения второй
      системы и в течение нескольких недель убедитесь, что она работает
      удовлетворительно, можете затем использовать её повторно для
      переустановки исходной системы.  С этого момента, как только вы
      почувствуете необходимость обновления, то просто выберите разделы,
      которые хотите удалить и выполнить переустановку.</para>

    <para>Может быть, вы слышали и даже пробовали использовать систему <ulink
      url="http://www.linuxfromscratch.org/">Linux From Scratch</ulink>, или
      LFS для краткости.  LFS также определяет, как построить и установить
      систему с нуля на пустой раздел при помощи работающей системы.  LFS
      делает упор на выяснение роли каждого компонента системы (таких, как
      ядро, компилятор, устройства, командный процессор, база данных
      терминальных устройств и так далее) и деталей установки каждого
      компонента.  &scratch.ap; не опускается до такого уровня детализации.
      Моей целью является проведение автоматизированной и полной установки, а
      не описание всех кровавых подробностей полного перепостроения системы.
      В случае, если вы хотите изучить &os; до такого уровня, начните с
      просмотра <filename>/usr/src/Makefile</filename> и следуйте действиям,
      которые выполняет <command>make buildworld</command>.</para>

    <para>В подходе, который применяется в &scratch.ap;, имеются свои
      отрицательные стороны, которые вы должны иметь в виду.</para>

    <!-- XXX: Хорошо бы написать stage_2.sh с применением системы разделения
         jail, которые запускаются в только что установленной при помощи
         stage_1 системе.  При корректной настройке первичного IP-адреса jail,
         возможно строить порты в chroot без деинсталляции всего установленного
         из 'хостирующей' системы.  Однако не забывайте, что даже jail-системы
         работают на ядре 'хоста'. -->

    <itemizedlist>
      <listitem>
        <para>При компиляции портов на втором этапе систему нельзя использовать
          в обычном режиме.  Если вы имеете дело с сервером, работающим в
          режиме промышленной эксплуатации, вы должны быть готовы к простою,
          к которому приводит выполнение второго этапа.  Порты, построенные
          при помощи <filename>stage_2.conf.default</filename> ниже, потребуют
	  для сборки около 8 часов на современной системе (4 из которых займет
	  компиляция <application>OpenOffice.org</application>).  Если вы
	  предпочитаете устанавливать пакеты, а не порты, то вы можете
	  существенно сократить время простоя, примерно до 10 минут.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="prerequisites">
    <title>Предварительные требования</title>

    <para>Для того, чтобы воспользоваться подходом &scratch.ap;, вам нужно
      иметь:</para>

    <itemizedlist>
      <listitem>
        <para>Работающую систему &os; с исходными текстами и деревом
          портов.</para>
      </listitem>

      <listitem>
        <para>По крайней мере один неиспользуемый раздел, куда будет
          устанавливаться новая система.</para>
      </listitem>

      <listitem>
        <para>Опыт работы с &man.mergemaster.8;.  Или по крайней мере
          отсутствие страха его использовать.</para>
      </listitem>

      <listitem>
        <para>Если у вас нет подключения или слабый канал в Internet:
          дистрибутивные файлы для ваших любимых портов.</para>
      </listitem>

      <listitem>
        <para>Знание основ написания скриптов на языке командного процессора
          Bourne, &man.sh.1;.</para>
      </listitem>

      <listitem>
        <para>Наконец, вы должны уметь указывать загрузчику системы на загрузку
          новой системы, либо интерактивно, либо из конфигурационного
          файла.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="stage1">
    <title>Этап первый: Установка системы</title>

    <para>В первом варианте этой статьи на первом шаге использовался
      единственный скрипт, в котором вся настройка выполнялась его
      редактированием.  После того, как пользователи высказали свои замечания,
      я решил разделить код и данные на уровне скриптов.  Это позволяет создавать
      разные наборы конфигурационных данных для установки различных систем без
      внесения изменений в скрипты с кодом.</para>

    <para>Скрипт с кодом для первого этапа называется
      <filename>stage_1.sh</filename>, и он запускается с единственным
      аргументом, например</para>

    <informalexample>
      <screen>&prompt.root; <userinput>./stage_1.sh <replaceable>default</replaceable></userinput></screen>
    </informalexample>

    <para>будет считывать свою конфигурацию из файла
      <filename>stage_1.conf.default</filename> и записывать протокол в файл
      <filename>stage_1.log.default</filename>.</para>

    <para>Далее приводится мой файл <filename>stage_1.conf.default</filename>.
      Вам необходимо подправить его в различных местах для того, чтобы он
      соответствовал вашим представлениям об <quote>идеальной системе</quote>.
      Я попытался подробно прокомментировать те места, которые вы должны
      исправлять.  Конфигурационный скрипт должен предоставлять четыре функции
      для оболочки, <command>create_file_systems</command>,
      <command>create_etc_fstab</command>, <command>copy_files</command> и
      <command>all_remaining_customization</command> (в случае, если это
      имеет смысл: именно в такой последовательности они будут вызываться из
      <filename>stage_1.sh</filename>).</para>

    <para>Следует внимательно отнестись к следующим моментам:</para>

    <itemizedlist>
      <listitem>
        <para>Разбиение разделов.</para>

        <para>Я не являюсь сторонником наличия одного большого раздела для
          всей системы.  Мои системы, как правило, имеют по крайней мере по
          одному разделу для <filename>/</filename>, <filename>/usr</filename>
          и <filename>/var</filename> с каталогом <filename>/tmp</filename>,
          образованным символической ссылкой в <filename>/var/tmp</filename>.
          Вдобавок я использую файловые системы в режиме совместного доступа к
          <filename>/home</filename> (домашние каталоги пользователей),
          <filename>/home/ncvs</filename> (копия CVS-хранилища &os;),
          <filename>/usr/ports</filename> (дерево портов),
          <filename>/src</filename> (различные выгруженные из хранилища деревья
          исходных текстов) и <filename>/share</filename> (остальные совместно
          используемые данные, резервные копии которых не нужны, например,
          спул сервера телеконференций).</para>
      </listitem>

      <listitem>
        <para>Новые возможности.</para>

        <para>Это то, что вы хотите иметь сразу после загрузки новой
          системы и даже до запуска второго этапа.  Причина отказа от
	  создания и перехода в chroot-окружение новой системы во время
	  первого этапа и простой установки всех моих любимых портов
	  заключается в том, что теоретически и практически существуют
	  проблемы начальной загрузки и целостности: на первом этапе работает
	  ваше старое ядро, однако в chroot-окружении содержатся новые
	  двоичные файлы программ и файлы объявлений.  Если новые
	  программы используют новый системный вызов, то они будут
	  завершаться <literal>SIGSYS, Плохой системный вызов</literal>, так
	  как старое ядро не поддерживает этот новый вызов.  Я наблюдал
	  и другие проблемы при попытке построения
	  порта <filename role="package">lang/perl5.8</filename>.</para>
      </listitem>
    </itemizedlist>

    <para>Перед тем, как запускать <filename>stage_1.sh</filename>, убедитесь,
      что вы выполнили обычные действия при подготовке к
      <command>make installworld installkernel</command>, типа:</para>

    <itemizedlist>
      <listitem>
        <para>отредактировали конфигурационный файл вашего ядра</para>
      </listitem>

      <listitem>
        <para>успешно выполнили <command>make buildworld</command></para>
      </listitem>

      <listitem>
        <para>успешно выполнили <command>make buildkernel
          KERNCONF=<replaceable>whatever</replaceable></command></para>
      </listitem>
    </itemizedlist>

    <para>Когда вы запускаете <filename>stage_1.sh</filename> первый раз, и
      конфигурационный файл, скопированный с работающей системы в новую,
      является устаревшим по сравнению с тем, что находится в каталоге
      <filename>/usr/src</filename>, <command>mergemaster</command> будет
      запрашивать вас на отработку этой ситуации.  Я рекомендую переносить
      изменения.  Если вам надоело отвечать на запросы, вы можете просто
      единожды обновить файлы в вашей <emphasis>работающей</emphasis> системе
      (Если только это вам подходит.  Скорее всего, вам не нужно это делать,
      если одна из ваших систем работает под управлением
      <literal>-STABLE</literal>, а другая с <literal>-CURRENT</literal>.
      Изменения могут оказаться несовместимыми).  Последующие вызовы
      утилиты <command>mergemaster</command> обнаружат, что RCS-идентификаторы
      версий соответствуют тем, что находятся в <filename>/usr/src</filename>,
      и пропустят файл.</para>

    <para>Скрипт <filename>stage_1.sh</filename> остановится на первой команде,
      которая завершится неудачно (возвратит ненулевой код завершения) из-за
      <command>set -e</command>, так что вы не пропустите ошибки.  Он также
      остановится, если вы используете неустановленную переменную окружения,
      как правило, из-за опечатки.  Вы должны исправить все ошибки в вашей
      версии <filename>stage_1.conf.default</filename> перед тем, как
      продолжить работу.</para>

    <para>В скрипте <filename>stage_1.sh</filename> мы вызываем
      <command>mergemaster</command>.  Даже если никаким файлам объединение не
      требуется, он выведет сообщение и в конце сделает запрос</para>

    <screen>*** Comparison complete
*** Saving mtree database for future upgrades

Do you wish to delete what is left of /var/tmp/temproot.stage1? [no] <userinput>no</userinput></screen>

    <para>Пожалуйста, ответьте <literal>no</literal> или просто нажмите
      <keycap>Enter</keycap>.  Причина в том, что
      <command>mergemaster</command> оставит несколько файлов нулевой длины в
      каталоге <filename>/var/tmp/temproot.stage1</filename>, которые позже
      будут скопированы в новую систему (в случае, если их там еще нет).</para>

    <para>После этого <command>mergemaster</command> перечислит
      установленные им файлы и уточнит, стоит ли генерировать новый
      <filename>login.conf</filename>:</para>

    <screen>*** You chose the automatic install option for files that did not
    exist on your system.  The following were installed for you:
      /newroot/etc/defaults/rc.conf
      ...
      /newroot/COPYRIGHT

*** You installed a new aliases file into /newroot/etc/mail, but
    the newaliases command is limited to the directories configured
    in sendmail.cf.  Make sure to create your aliases database by
    hand when your sendmail configuration is done.

*** You installed a login.conf file, so make sure that you run
    '/usr/bin/cap_mkdb /newroot/etc/login.conf'
     to rebuild your login.conf database

    Would you like to run it now? y or n [n]</screen>

    <para>Ответ не имеет значения, так как <filename>stage_1.sh</filename>
      будет запускать &man.cap.mkdb.1; в любом случае.</para>

    <para>Вот авторский файл <ulink url="stage_1.conf.default">
      <filename>stage_1.conf.default</filename></ulink>, который вы должны
      потом существенно модифицировать.  В комментариях даётся достаточно информации о том,
      что необходимо изменить.</para>

    <programlisting><inlinegraphic fileref="stage_1.conf.default" format="linespecific"></programlisting>

    <para>Скачайте <ulink url="stage_1.conf.default">
      <filename>stage_1.conf.default</filename></ulink>.</para>

    <para>При работе этот скрипт устанавливает систему, которая при загрузке
      предоставит:</para>

    <itemizedlist>
      <listitem>
        <para>Унаследованные списки пользователей и групп.</para>
      </listitem>

      <listitem>
        <para>Подключение к Internet по Ethernet с использованием
          межсетевого экрана.</para>
      </listitem>

      <listitem>
        <para>Правильный временной пояс и NTP.</para>
      </listitem>

      <listitem>
        <para>Другие более мелкие конфигурационные параметры, например,
          <filename>/etc/ttys</filename> и <command>inetd</command>.</para>
      </listitem>
    </itemizedlist>

    <para>Другие функции готовы к настройке, но не будут работать, пока не
      будет завершён второй этап.  Например, мы скопировали файлы для настройки
      печати и X11.  Однако для печати, скорее всего, необходимы приложения,
      отсутствующие в базовом комплекте системы, например, такие как &postscript;.  X11 не будет работать, пока
      мы не откомпилируем сервер, библиотеки и программы.</para>
  </sect1>

  <sect1 id="stage2">
    <title>Этап второй: Установка портов</title>

    <note>
      <para>На этом этапе вместо компиляции портов возможна также установка
        (уже откомпилированных) пакаджей.  В этом случае
        <filename>stage_2.sh</filename> будет представлять собой не более, чем
        перечень команд <command>pkg_add</command>.  Я надеюсь, что вы сумеете
        написать такой скрипт.  Здесь мы сосредоточимся на более гибком и
        традиционном способе с использованием портов.</para>
    </note>

    <para>Следующий скрипт <filename>stage_2.sh</filename> показывает, как
      я устанавливаю мои любимые порты.  Он может быть запущен любое количество
      раз и будет пропускать все порты, которые уже установлены.  Он
      поддерживает <emphasis>dryrun</emphasis>-параметр (<option>-n</option>)
      для показа того, что будет выполнено.  Вы запускаете его точно
      также, как <filename>stage_1.sh</filename>, с только одним аргументом,
      указывающим на конфигурационный файл, к примеру</para>

    <informalexample>
      <screen>&prompt.root; <userinput>./stage_2.sh <replaceable>default</replaceable></userinput></screen>
    </informalexample>

    <para>который будет считывать перечень портов из
      <filename>stage_2.conf.default</filename>.</para>

    <para>Список портов состоит из строчек с двумя или большим количеством
      слов, разделённых пробелами: категория и порт, за которыми опционально
      следует команда установки, которая будет компилировать и устанавливать
      порт (по умолчанию: <command>make install BATCH=yes &lt; /dev/null</command>).
      Пустые строки и строки, начинающиеся с символа #, игнорируются.  В большинстве
      случаев в них указывается только название категории и порт.  Однако
      некоторые порты могут быть тонко настроены при помощи указания
      <command>make</command>-переменных, к примеру:</para>

    <programlisting>www mozilla make WITHOUT_MAILNEWS=yes WITHOUT_CHATZILLA=yes install</programlisting>

    <para>На самом деле вы можете указать некоторые команды оболочки и не быть
      ограниченными простыми вызовами <command>make</command>:</para>

    <programlisting>java jdk16            echo true > files/license.sh; make install BATCH=yes < /dev/null
print acroread8       yes accept | make install PAGER=ls
x11-fonts gnu-unifont make install && mkfontdir /usr/local/lib/X11/fonts/local
news inn-stable       CONFIGURE_ARGS="--enable-uucp-rnews --enable-setgid-inews" make install</programlisting>

    <para>В первых двух строчках проиллюстрировано, как работать с портами,
      которые предлагают вам принять соглашения лицензии.  Заметьте, что строка для <filename
      role="package">news/inn-stable</filename> является примером единократного
      задания переменной окружения <literal>CONFIGURE_ARGS</literal>.  Файл
      <filename>Makefile</filename> порта будет использовать это как начальное
      значение и определит некоторые другие необходимые аргументы.  Разница в
      задании <application>make</application>-переменных в командной строке
      по команде</para>

    <programlisting>news inn-stable make CONFIGURE_ARGS="--enable-uucp-rnews --enable-setgid-inews" install</programlisting>

    <para>заключается в том, что в последнем случае значение будет
      переназначено, но не расширено.  Выбор нужного метода зависит от
      конкретного порта.</para>

    <para>Убедитесь в том, что ваши порты не используют интерактивный режим
      установки, то есть не должны пытаться читать со стандартного устройства
      ввода ничего кроме того, что вы им подаёте на вход.  Если это всё же
      происходит, то они будут считывать последующие строки из вашего перечня
      портов, описываемого в этом документе, и будут работать некорректно.
      Если скрипт <filename>stage_2.sh</filename> неожиданно пропустил порт
      или прекратил работу, причина может быть в этом.</para>

    <para>Ниже приводится <filename>stage_2.conf.default</filename>.  Для
      каждого установленного им порта создаётся файл протокола
      <filename>LOGDIR/category+port</filename>.</para>

    <programlisting><inlinegraphic fileref="stage_2.conf.default" format="linespecific"></programlisting>

    <para>Скачайте <ulink url="stage_2.conf.default">
      <filename>stage_2.conf.default</filename></ulink>.</para>
  </sect1>

  <sect1 id="stage3">
    <title>Этап третий</title>

    <para>На втором этапе вы установили ваши любимые порты.  Некоторые из них
      требуют небольшой настройки.  Именно для этого и предназначен третий
      этап &mdash; этап настройки.  Я мог бы интегрировать эту настройку в конец скрипта
      <filename>stage_2.sh</filename>.  Однако я думаю, что есть концептуальное
      различие между установкой порта и модификацией его начальной
      конфигурации, и это требует отдельного шага.</para>

    <para>Я решил реализовать третий этап в виде файла
      <filename>Makefile</filename>, потому что это позволяет легко выбирать
      то, что вы хотите конфигурировать, следующим простым вызовом:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>make -f stage_3.mk <replaceable>target</replaceable></userinput></screen>
    </informalexample>

    <para>Как и в случае с <filename>stage_2.sh</filename>, убедитесь, что файл
      <filename>stage_3.mk</filename> после загрузки новой системы есть в
      наличии, поместив его на совместно используемый раздел либо скопировав
      его куда-нибудь в новую систему.</para>
  </sect1>  

  <sect1 id="limitations">
    <title>Ограничения</title>

    <para>Автоматизированная установка порта может оказаться затруднена, если
      она является интерактивной и не поддерживает команду <command>make
      BATCH=YES install</command>.  Для нескольких портов интерактивность
      означает не более, чем ввод <literal>yes</literal> в ответ на вопрос о
      принятии некоторого лицензионного соглашения.  Если такой ответ
      считывается со стандартного устройства ввода, мы просто направляем
      соответствующие ответы на вход установочной команды (к примеру:
      <command>yes | make install</command>).  Для остальных портов вам
      придется разобраться, где конкретно находится интерактивная команда
      и соответственно ее обработать.   Выше были приведены примеры для
      <filename role="package">print/acroread8</filename> and
      <filename role="package">java/jdk16</filename>.</para>

    <para>Вы должны также принять во внимание вопросы обновления
      конфигурационных файлов.  Вообще говоря, вы не знаете, когда и сменился
      ли вообще формат или содержимое конфигурационного файла.  В файл
      <filename>/etc/group</filename> может быть добавлена новая группа, или в
      <filename>/etc/passwd</filename> может добавиться дополнительное поле.
      Всё это уже происходило в прошлом.  Простое копирование конфигурационного
      файла из старой в новую систему может в большинстве случаев оказаться
      достаточным, но в этих случаях это не так.  Если вы обновляете систему
      каноническим способом (путём перезаписывания старых файлов), вы должны
      использовать утилиту <command>mergemaster</command> для работы с
      изменениями, если вы хотите эффективно объединить вашу локальные
      настройки с потенциально новыми возможностями.  К сожалению,
      <command>mergemaster</command> работает только с файлами базового
      комплекта системы, а не с любыми файлами, устанавливаемыми портами.
      Похоже, что стороннее программное обеспечение специально проектируется
      для того, чтобы я не дремал, и меняет конфигурационные файлы по два
      раза в месяц.  Для обнаружения таких скрытых изменений, я держу копию
      изменённых конфигурационных файлов там же, где и <filename>stage_3.mk</filename>
      и сравниваю результат с помощью правил <command>make</command>.
      Например, для конфигурационного файла <application>Apache</application>,
      <filename>httpd.conf</filename>, целью будет
      <command>config_apache</command>.</para>

<programlisting>
@if ! cmp -s /usr/local/etc/apache2/httpd.conf httpd.conf; then \
    echo "ATTENTION: the httpd.conf has changed. Please examine if"; \
    echo "the modifications are still correct. Here is the diff:"; \
    diff -u /usr/local/etc/apache2/httpd.conf httpd.conf; \
fi
</programlisting>

    <para>Если разница между файлами несущественна я могу выполнить
      <command>cp /usr/local/etc/apache2/httpd.conf
        httpd.conf</command>.</para>

    <para>Я использовал систему &scratch.ap; несколько раз для обновления
      <literal>7-CURRENT</literal> до <literal>7-CURRENT</literal> и
      <literal>8-CURRENT</literal> до <literal>8-CURRENT</literal>, то есть
      я никогда не пытался установить <literal>8-CURRENT</literal> из системы
      <literal>7-STABLE</literal> и наоборот.  Из-за количества изменений между
      релизами с разными старшими номерами я ожидаю, что этот процесс будет
      несколько более сложным.  Использование &scratch.ap; для обновления
      внутри ветки <literal>STABLE</literal> должно проходить безболезненно
      (хотя я ещё не пробовал этого делать).</para>
  </sect1>

  <sect1 id="files">
    <title>Файлы</title>

    <para>Вот три файла, которые вам нужны кроме тех конфигурационных, что
      уже показаны выше.</para>

    <para>Это скрипт <ulink url="stage_1.sh">
      <filename>stage_1.sh</filename></ulink>, который вы не должны
      модифицировать.</para>

    <programlisting><inlinegraphic fileref="stage_1.sh" format="linespecific"></programlisting>

    <para>Скачайте <ulink
      url="stage_1.sh"><filename>stage_1.sh</filename></ulink>.</para>

    <para>Это скрипт <ulink
      url="stage_2.sh"><filename>stage_2.sh</filename></ulink>.  Вам может
      понадобиться изменить переменные в самом начале файла.</para>

    <programlisting><inlinegraphic fileref="stage_2.sh" format="linespecific"></programlisting>

    <para>Скачайте <ulink
      url="stage_2.sh"><filename>stage_2.sh</filename></ulink>.</para>

    <para>Это мой файл <ulink
      url="stage_3.mk"><filename>stage_3.mk</filename></ulink>, который даст
      вам идею о том, как автоматизировать всю повторную конфигурацию.</para>

    <programlisting><inlinegraphic fileref="stage_3.mk" format="linespecific"></programlisting>

    <para>Скачайте <ulink
      url="stage_3.mk"><filename>stage_3.mk</filename></ulink>.</para>
  </sect1>
</article>
