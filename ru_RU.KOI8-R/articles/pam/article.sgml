<!--
     The FreeBSD Russian Documentation Project

     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/articles/pam/article.sgml,v 1.11 2004/01/17 06:44:41 andy Exp $

     Original revision: 1.25
-->

<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN">
%man;

<!ENTITY % freebsd PUBLIC "-//FreeBSD//ENTITIES DocBook Miscellaneous FreeBSD Entities//EN">
%freebsd;

<!ENTITY % trademarks PUBLIC "-//FreeBSD//ENTITIES DocBook Trademark Entities//EN">
%trademarks;
]>

<!--
  - Copyright (c) 2001-2003 Networks Associates Technology, Inc.
  - All rights reserved.
  -
  - This software was developed for the FreeBSD Project by ThinkSec AS and
  - Network Associates Laboratories, the Security Research Division of
  - Network Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
  - ("CBOSS"), as part of the DARPA CHATS research program.
  -
  - Redistribution and use in source and binary forms, with or without
  - modification, are permitted provided that the following conditions
  - are met:
  - 1. Redistributions of source code must retain the above copyright
  -    notice, this list of conditions and the following disclaimer.
  - 2. Redistributions in binary form must reproduce the above copyright
  -    notice, this list of conditions and the following disclaimer in the
  -    documentation and/or other materials provided with the distribution.
  - 3. The name of the author may not be used to endorse or promote
  -    products derived from this software without specific prior written
  -    permission.
  -
  - THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
  - ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  - IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  - ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  - FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  - DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  - OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  - HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  - LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  - OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  - SUCH DAMAGE.
  -->

<article>
  <articleinfo>
    <title>Подключаемые Модули Аутентификации (PAM)</title>

    <pubdate>$FreeBSD$</pubdate>

    <abstract>
      <para>В этой статье описываются принципы и механизмы, лежащие в основе
        библиотеки Подключаемых Модулей Аутентификации (PAM - Pluggable
        Authentication Modules), и рассказывается, как настроить PAM, как
        интегрировать PAM в приложения и как создавать модули PAM.</para>
    </abstract>

    <copyright>
      <year>2001</year>

      <year>2002</year>

      <year>2003</year>

      <holder>Networks Associates Technology, Inc.</holder>
    </copyright>

    <authorgroup>
      <author>
	<firstname>Dag-Erling</firstname>

	<surname>Sm&oslash;rgrav</surname>

	<contrib>Текст предоставил</contrib>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Эта статья была написана для Проекта FreeBSD компаниями
        ThinkSec AS и Network Associates Laboratories, Security
        Research Division of Network Associates, Inc. в рамках работ по
        контракту N66001-01-C-8035 с DARPA/SPAWAR (<quote>CBOSS</quote>),
        как часть исследовательской программы DARPA CHATS.</para>
    </legalnotice>

    <legalnotice id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.linux;
      &tm-attrib.opengroup;
      &tm-attrib.sun;
      &tm-attrib.general;
    </legalnotice>
  </articleinfo>

  <section id="pam-intro">
    <title id="pam-intro.title">Введение</title>

    <para>Библиотека Pluggable Authentication Modules (PAM) является обобщённым
      API для служб, связанных с аутентификацией, которые позволяют системному
      администратору добавлять новые методы аутентификации простой установкой
      новых модулей PAM, и изменять политику аутентификации посредством
      редактирования конфигурационных файлов.</para>

    <para>PAM описали и разработали Vipin Samar и Charlie Lai из Sun
      Microsystems в 1995 году, с тех он сильно не менялся.  В 1997 году Open
      Group опубликовала предварительные спецификации на X/Open Single Sign-on
      (XSSO), что стандартизовало API для PAM и добавило расширения для
      одноразовой (или достаточно интегрированной) подписи.  На момент
      написания этого документа эта спецификация ещё не была принята за
      стандарт.</para>

    <para>Хотя эта статья посвящена в основном FreeBSD 5.x, в которой
      используется OpenPAM, она подойдёт для FreeBSD 4.x, использующей
      Linux-PAM, и других операционных систем, таких, как Linux и
      &solaris;.</para>
  </section>

  <section id="pam-terms">
    <title id="pam-terms.title">Термины и соглашения</title>

    <section id="pam-definitions">
      <title id="pam-definitions.title">Определения</title>

      <para>Терминология, используемая в PAM, достаточно запутана.  Ни
        оригинальная работа Samar и Lai, ни спецификация XSSO не делают никаких
        попыток формально определить термины для различных объектов и
        участвующих в PAM сторон, а термины, которые они используют (но не
        определяют) иногда неверны и неоднозначны.  Первой попыткой создать
        недвусмысленную и согласованную терминологию была работа, которую
        написал Andrew G. Morgan (автор Linux-PAM) в 1999 году.  Хотя выбор
        терминологии, которую сделал Морган, был гигантским скачком вперед,
        это, по мнению автора данной статьи, не означает ее правильность.
        Далее делается попытка, в значительной степени на основе работы
        Моргана, дать точные и недвусмысленные определения терминов для всех
        участников и объектов PAM.</para>

      <glosslist>
        <glossentry>
          <glossterm>учётная запись (account)</glossterm>

	  <glossdef>
	    <para>Набор полномочий, которые аппликант запрашивает от
              арбитратора.</para>
	  </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>аппликант (applicant)</glossterm>
	  <glossdef>
	    <para>Пользователь или объект, запрашивающие аутентификацию.</para>
          </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>арбитратор (arbitrator)</glossterm>
	  <glossdef>
	    <para>Пользователь или объект, имеющий привилегии, достаточные
              для проверки полномочий аппликанта и права подтвердить или
              отклонить запрос.</para>
	  </glossdef>
        </glossentry>

	<glossentry>
	  <glossterm>цепочка (chain)</glossterm>
	  <glossdef>
	    <para>Последовательность модулей, которые будут вызваны в ответ на
              запрос PAM.  В цепочку включена информация о последовательности
              вызовов модулей, аргументах, которые нужно им передать, и о том,
              как интерпретировать результаты.</para>
	  </glossdef>
	</glossentry>

        <glossentry>
          <glossterm>клиент (client)</glossterm>
	  <glossdef>
	    <para>Приложение, отвечающее за инициирование запроса на
              аутентификацию от имени аппликанта и получающее от него
              необходимую для аутентификации информацию.</para>
	  </glossdef>
        </glossentry>

	<glossentry>
	  <glossterm>подсистема (facility)</glossterm>
	  <glossdef>
	    <para>Одна из четырех основных групп функциональности, которые дает
              PAM: аутентификация, управление учетными записями, управление
              сеансом и обновление ключом аутентификации.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>модуль (module)</glossterm>
	  <glossdef>
	    <para>Набор из одной или большего количества связанных функций,
              реализующих определенную подсистему аутентификации, собранный в
              один (обычно динамически загружаемый) двоичный файл, 
              идентифицируемый по имени.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>политика (policy)</glossterm>
	  <glossdef>
	    <para>Полный набор конфигурационных деклараций, описывающих, как
              обрабатывать запросы PAM к определенной услуге.  Политика обычно
              состоит из четырех цепочек, по одной для каждой подсистемы, хотя
              некоторые службы используют не все четыре подсистемы.</para>
	  </glossdef>
	</glossentry>

        <glossentry>
          <glossterm>сервер (server)</glossterm>
	  <glossdef>
	    <para>Приложение, выступающее от имени арбитратора для общения с
              клиентом, запрашивания аутентификационной информации, проверки
              полномочий аппликанта и подтверждающее или отклоняющее
              запрос.</para>
	  </glossdef>
        </glossentry>

	<glossentry>
	  <glossterm>сервис (service)</glossterm>
	  <glossdef>
	    <para>Класс серверов, предоставляющих похожую или связанную
              функциональность, и требующую подобную аутентификацию.  Политики
              PAM задаются на основе сервисов, так что ко всем серверам,
              объявляющим одно и тоже имя сервиса, будет применяться одна и та
              же политика.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>сеанс (session)</glossterm>
	  <glossdef>
	    <para>Контекст, в котором сервис оказывается аппликанту сервером.
              Одна из четырех подсистем PAM, управление сеансом, касается
              исключительно настройке и очистке этого контекста.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>ключ (token)</glossterm>
	  <glossdef>
	    <para>Блок информации, связанный с учётной записью, например,
              пароль или ключевая фраза, которую аппликант должен предоставить
              для своей идентификации.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm>транзакция (transaction)</glossterm>
	  <glossdef>
	    <para>Последовательность запросов от одного и того же аппликанта к
              одному и тому же экземпляру того же самого сервера, начиная с
              аутентификации и установления сеанса и заканчивая закрытием
              сеанса.</para>
	  </glossdef>
	</glossentry>
      </glosslist>
    </section>

    <section id="pam-usage-examples">
      <title id="pam-usage-examples.title">Примеры использования</title>

      <para>Этот раздел предназначен для иллюстрации значений некоторых
        терминов, определенных выше, при помощи простых примеров.</para>

      <section>
        <title>Объединенные клиент и сервер</title>

	<para>В этом простом примере показывается пользователь
          <literal>alice</literal>, выполняющий команду &man.su.1; для
          того, чтобы стать пользователем <literal>root</literal>.</para>

        <screen>&prompt.user; <userinput>whoami</userinput>
alice
&prompt.user; <userinput>ls -l `which su`</userinput>
-r-sr-xr-x  1 root  wheel  10744 Dec  6 19:06 /usr/bin/su
&prompt.user; <userinput>su -</userinput>
Password: <userinput>xi3kiune</userinput>
&prompt.root; whoami
root</screen>

	<itemizedlist>
	  <listitem>
	    <para>Аппликантом является <literal>alice</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Учетной записью является <literal>root</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Процесс &man.su.1; является как клиентом, так и
              сервером.</para>
	  </listitem>

	  <listitem>
	    <para>Аутентификационным ключом является
              <literal>xi3kiune</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Арбитратором выступает <literal>root</literal>, и именно
              поэтому у команды &man.su.1; выставлен бит выполнения с
              правами <literal>root</literal>.</para>
	  </listitem>
	</itemizedlist>
      </section>

      <section>
        <title>Клиент и сервер разделены</title>

	<para>В примере ниже рассматривается пользователь
          <literal>eve</literal>, пытающийся установить &man.ssh.1;-соединение
          с <literal>login.example.com</literal>, и успешно входя как
	  пользователь <literal>bob</literal>.  Боб должен был выбрать пароль
          получше!</para>

        <screen>&prompt.user; <userinput>whoami</userinput>
eve
&prompt.user; <userinput>ssh bob@login.example.com</userinput>
bob@login.example.com's password: <userinput>god</userinput>
Last login: Thu Oct 11 09:52:57 2001 from 192.168.0.1
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.  All rights reserved.
FreeBSD 4.4-STABLE (LOGIN) #4: Tue Nov 27 18:10:34 PST 2001

Welcome to FreeBSD!
&prompt.user;</screen>

	<itemizedlist>
	  <listitem>
	    <para>Аппликантом является <literal>eve</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Клиентом является процесс &man.ssh.1; пользователя
              Eve.</para>
	  </listitem>

	  <listitem>
	    <para>Сервером является процесс &man.sshd.8; на машине
	      <literal>login.example.com</literal></para>
	  </listitem>

	  <listitem>
	    <para>Учетной записью является <literal>bob</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Ключом аутентификации является
	      <literal>god</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>Хотя этого не видно в примере, но арбитратором является
	      <literal>root</literal>.</para>
	  </listitem>
	</itemizedlist>
      </section>

      <section>
        <title>Пример политики</title>

	<para>Следующее является политикой, используемой во FreeBSD по
          умолчанию для <literal>sshd</literal>:</para>

        <programlisting>sshd   auth            required        pam_nologin.so  no_warn
sshd   auth            required        pam_unix.so     no_warn try_first_pass
sshd   account         required        pam_login_access.so
sshd   account         required        pam_unix.so
sshd   session         required        pam_lastlog.so  no_fail
sshd   password        required        pam_permit.so</programlisting>

	<itemizedlist>
	  <listitem>
            <para>Эта политика применяется к службе <literal>sshd</literal>
              (что не обязательно ограничено сервером &man.sshd.8;).</para>
	  </listitem>

	  <listitem>
	    <para><literal>auth</literal>, <literal>account</literal>,
	      <literal>session</literal> и
	      <literal>password</literal> являются подсистемами.</para>
	  </listitem>

	  <listitem>
	    <para><filename>pam_nologin.so</filename>,
	      <filename>pam_unix.so</filename>,
              <filename>pam_login_access.so</filename>,
              <filename>pam_lastlog.so</filename> и
	      <filename>pam_permit.so</filename> являются модулями.  Из этого
              примера видно, что <filename>pam_unix.so</filename>
	      реализует по крайней мере две подсистемы (аутентификацию и
              управление учётными записями).</para>
	  </listitem>
	</itemizedlist>
      </section>
    </section>

<!--
    <section id="pam-conventions">
      <title id="pam-conventions.title">Соглашения</title>

      <para>Этот раздел ещё не был написан.</para>
    </section>
-->
  </section>

  <section id="pam-essentials">
    <title id="pam-essentials.title">Основы PAM</title>

    <section id="pam-facilities-primitives">
      <title id="pam-facilities-primitives.title">Подсистемы и
        примитивы</title>

      <para>API для PAM предоставляет шесть различных примитивов для
        аутентификации, сгруппированных в четыре подсистемы, каждая из которых
        описывается ниже.</para>

      <variablelist>
        <varlistentry>
	  <term><literal>auth</literal></term>

	  <listitem>
	    <para><emphasis>Аутентификация.</emphasis> Эта подсистема,
              собственно говоря, реализует аутентификацию аппликанта и
              выяснение полномочий учётной записи.  Она предоставляет два
              примитива:</para>

	    <itemizedlist>
	      <listitem>
	        <para>Функция &man.pam.authenticate.3; аутентифицирует
                  аппликанта, обычно запрашивая аутентификационный ключ и
                  сравнивая его со значением, хранящимся в базе данных или
                  получаемым от сервера аутентификации.</para>
	      </listitem>

	      <listitem>
	        <para>Функция &man.pam.setcred.3; устанавливает полномочия
                  учётной записи, такие, как идентификатор пользователя,
                  членство в группах и ограничения на использование
                  ресурсов.</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>

        <varlistentry>
	  <term><literal>account</literal></term>

	  <listitem>
	    <para><emphasis>Управление учётной записью.</emphasis> Эта
              подсистема обрабатывает вопросы доступности учетной записи, не
              связанные с аутентификацией, такие, как ограничения в доступе на
              основе времени суток или загрузки сервера.  Он предоставляет
              единственный примитив:</para>

	    <itemizedlist>
	      <listitem>
	        <para>Функция &man.pam.acct.mgmt.3; проверяет, доступна ли
                  запрашиваемая учётная запись.</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>

        <varlistentry>
	  <term><literal>session</literal></term>

	  <listitem>
	    <para><emphasis>Управление сеансом.</emphasis> Эта подсистема
              отрабатывает задачи, связанные с установлением и закрытием
              сеанса, такие, как учет входов пользователей.  Она предоставляет
              два примитива:</para>

	    <itemizedlist>
	      <listitem>
	        <para>Функция &man.pam.open.session.3; выполняет действия,
                  связанные с установлением сеанса: добавление записей в базы
                  данных <filename>utmp</filename> и <filename>wtmp</filename>,
                  запуск агента SSH и так далее.</para>
	      </listitem>

	      <listitem>
	        <para>Функция &man.pam.close.session.3; выполняет
                  действия, связанные с закрытием сеанса: добавление записей в
                  базы данных <filename>utmp</filename> и
                  <filename>wtmp</filename>, завершение работы агента SSH и так
                  далее.</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>

        <varlistentry>
	  <term><literal>password</literal></term>
	  <listitem>
	    <para><emphasis>Управление паролем.</emphasis>  Эта подсистема
              используется для изменения ключа аутентификации, связанного с
              учетной записью, по причине истечения его срока действия или
              желания пользователя изменить его.  Она предоставляет
              единственный примитив:</para>

	    <itemizedlist>
	      <listitem>
	        <para>Функция &man.pam.chauthtok.3; изменяет ключ
                  аутентификации, опционально проверяя, что он труден для
                  подбора, не использовался ранее и так далее.</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</varlistentry>
      </variablelist>
    </section>

    <section id="pam-modules">
      <title id="pam-modules.title">Модули</title>

      <para>Модули являются центральной концепцией в PAM; в конце концов, им
        соответствует буква <quote>M</quote> в сокращении <quote>PAM</quote>.
        Модуль PAM представляет собой самодостаточный кусок программного кода,
        который реализует примитивы одной или большего количества подсистем
        одного конкретного механизма; к возможным механизмам для подсистемы
        аутентификации, к примеру, относятся базы данных паролей &unix;,
        системы NIS, LDAP или Radius.</para>

      <section id="pam-module-naming">
        <title id="pam-module-naming.title">Именование модулей</title>

        <para>Во FreeBSD каждый механизм реализуется в отдельном модуле с
          именем <literal>pam_<replaceable>mechanism</replaceable>.so</literal>
          (например, <literal>pam_unix.so</literal> для механизма &unix;.)
          В других реализациях иногда отдельные модули используются для разных
          подсистем, и в их имя включается, кроме названия механизма, и имя
          подсистемы.  К примеру, в &solaris; имеется модуль
          <literal>pam_dial_auth.so.1</literal>, который часто используется
          для аутентификации пользователей, работающих по коммутируемым
          каналам связи.</para>
      </section>

      <section id="pam-module-versioning">
        <title id="pam-module-versioning.title">Версии модулей</title>

        <para>Изначальная реализация PAM во FreeBSD, которая была основана на
          Linux-PAM, не использовала номера версий для модулей PAM.  Это будет
          приводить к проблемам при работе унаследованных приложений, которые
          могут быть скомпонованы со старыми версиями системных библиотек, так
          как способа подгрузить соответствующую версию требуемых модулей
          нет.</para>

        <para>OpenPAM, с другой стороны, ищет модули, которые имеют тот же
          самый номер версии, что и библиотека PAM (на данный момент 2), и
          использует модуль без версии, только если модуль с известной версией
          не был загружен.  Поэтому для старых приложений могут предоставляться
          старые модули, при этом новые (или заново построенные) приложения
          будут использовать все возможности последних версий модулей.</para>

        <para>Хотя модули PAM в &solaris; имеют номер версии, по-настоящему
          номер версии в них не отслеживается, потому что номер является частью
          имени и должен включаться в конфигурацию.</para>
      </section>
    </section>

    <section id="pam-chains-policies">
      <title id="pam-chains-policies.title">Цепочки и политики</title>

      <para>Когда сервер инициирует PAM-транзакцию, библиотека PAM
        пытается загрузить политику для службы, указанной при вызове функции
        &man.pam.start.3;.  Политика определяет, как должны
        обрабатываться запросы на аутентификацию, и задаётся в
        конфигурационном файле.  Это составляет другую основополагающую
        концепцию PAM: возможность администратору настраивать политику
        безопасности системы (в самом широком её понимании) простым
        редактированием текстового файла.</para>

      <para>Политика состоит из четырёх цепочек, по одной на каждый из
        методов PAM.  Каждое звено представляет собой последовательность
        конфигурационных утверждений, задающих вызываемый модуль, некоторые
        (необязательные) параметры для передачи в модуль, и управляющий флаг,
        описывающий, как интерпретировать возвращаемый из модуля код.</para>

      <para>Понимание смысла управляющего флага необходимо для понимания
        конфигурационных файлов PAM.  Существуют четыре различных управляющих
        флага:</para>

      <variablelist>
        <varlistentry>
          <term><literal>binding</literal></term>

          <listitem>
            <para>Если модуль отработал успешно, и ни один из предыдущих
              модулей в цепочке не сработал отрицательно, то цепочка
              прерывается, а запрос подтверждается.  Если же модуль отработает
              неудачно, то выполняется оставшаяся часть цепочки, однако
              запрос отвергается.</para>

            <para>Этот управляющий флаг был добавлен компанией Sun в &solaris;
              9 (&sunos; 5.9), и поддерживается в OpenPAM.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>required</literal></term>

          <listitem>
            <para>Если модуль возвратил положительный ответ, выполняется
              оставшаяся часть цепочки, запрос удовлетворяется, если никакой
              другой модуль не отработает отрицательно.  Если же модуль
              возвратит отрицательный ответ, остаток цепочки тоже
              отрабатывается, но запрос отвергается.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>requisite</literal></term>

          <listitem>
            <para>Если модуль возвращает положительный ответ, выполняется
              оставшаяся часть цепочки, запрос удовлетворяется, если никакой
              другой модуль не отработает отрицательно.  Если же модуль
              отрабатывает отрицательно, то отработка цепочки немедленно
              прекращается, а запрос отвергается.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>sufficient</literal></term>

          <listitem>
            <para>Если модуль возвратит положительный ответ, и ни один из
              предыдущих модулей в цепочке на отработал отрицательно, то
              отработка цепочки немедленно прекращается, а запрос
              удовлетворяется.  Если модуль отработал отрицательно, то
              результат игнорируется и цепочка отрабатывается дальше.</para>

            <para>Так как семантика этого флага может оказаться запутанной,
              особенно при его использовании с последним модулем в цепочке,
              рекомендуется вместо него использовать управляющий флаг
              <literal>binding</literal>, если реализация его
              поддерживает.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>optional</literal></term>

          <listitem>
            <para>Модуль отрабатывается, но результат выполнения игнорируется.
              Если все модули в цепочке помечены как
              <literal>optional</literal>, то удовлетворяться будут все
              запросы.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Когда сервер вызывает один из шести PAM-примитивов, PAM
        запрашивает цепочку подсистемы, к которой принадлежит примитив, и
        запускает каждый модуль, перечисленный в цепочке в порядке их
        перечисления, пока список не будет исчерпан либо не будет определено,
        что дальнейшей обработки не нужно (по причине достижение модуля,
        вернувшего положительный ответ при условии <literal>binding</literal>
        или <literal>sufficient</literal>, либо отрицательный с условием
        <literal>requisite</literal>).  Запрос подтверждается, если только
        был вызван по крайней мере один модуль, и все неопциональные модули
        вернули положительный ответ.</para>

      <para>Заметьте, что возможно, хотя это не распространено, перечислять
        один и тот же модуль несколько раз в одной цепочке.  К примеру,
        модуль, просматривающий имена и пароли пользователя в сервере
        каталога может быть вызван несколько раз с различными параметрами,
        задающими различные серверы каталогов для связи.  PAM считает
        различные появления одного модуля в той же самой цепочке разными и
        не связанными модулями.</para>
    </section>

    <section id="pam-transactions">
      <title id="pam-transactions.title">Транзакции</title>

      <para>Жизненный цикл типичной PAM-транзакции описан ниже.  Заметьте,
        что в случае, если любой из перечисленных шагов оканчивается неудачно,
        сервер должен выдать клиенту соответствующее сообщение об ошибке
        и прервать транзакцию.</para>

      <orderedlist>
        <listitem>
          <para>Если это необходимо, сервер получает полномочия арбитратора
            через независимый от PAM механизм&mdash;чаще всего по факту
            запуска пользователем <literal>root</literal> или с установленным
            setuid-битом <literal>root</literal>.</para>
        </listitem>

        <listitem>
          <para>Сервер вызывает функцию &man.pam.start.3; для
            инициализации библиотеки PAM и задания имени сервиса и целевой
            учётной записи, а также регистрации подходящего способа
            общения.</para>
        </listitem>

        <listitem>
          <para>Сервер получает различную информацию, относящуюся к транзакции
            (такую, как имя пользователя аппликанта и имя хоста, на котором
            запущен клиент), и отправляет её в PAM при помощи функции
            &man.pam.set.item.3;.</para>
        </listitem>

        <listitem>
          <para>Сервер вызывает функцию &man.pam.authenticate.3;
            для аутентификации аппликанта.</para>
        </listitem>

        <listitem>
          <para>Сервер вызывает функцию &man.pam.acct.mgmt.3; для проверки
            того, что запрошенная учётная запись доступна и корректна.  Если
            пароль верен, но его срок истёк, &man.pam.acct.mgmt.3; возвратит
            результат <literal>PAM_NEW_AUTHTOK_REQD</literal>, а не
            <literal>PAM_SUCCESS</literal>.</para>
        </listitem>

        <listitem>
          <para>Если на предыдущем шаге был получен результат
            <literal>PAM_NEW_AUTHTOK_REQD</literal>, то сервер вызывает функцию
            &man.pam.chauthtok.3; для того, чтобы вынудить клиента
            изменить ключ аутентификации для запрошенной учётной записи.</para>
        </listitem>

        <listitem>
          <para>Теперь, когда аппликант полностью аутентифицирован, сервер
            вызывает функцию &man.pam.setcred.3; для получения
            полномочий запрошенной учётной записи.  Сделать это возможно,
            потому что он работает как арбитратор, и оставляет за собой
            полномочия арбитратора.</para>
        </listitem>

        <listitem>
          <para>После получения необходимых полномочий, сервер вызывает функцию
            &man.pam.open.session.3; для установления сеанса.</para>
        </listitem>

        <listitem>
          <para>Теперь сервер выполняет тот сервис, который затребовал
            клиент&mdash;например, предоставляет аппликанту оболочку.</para>
        </listitem>

        <listitem>
          <para>После того, как сервер закончил обслуживание клиента, он
            вызывает функцию &man.pam.close.session.3; для закрытия
            сеанса.</para>
        </listitem>

        <listitem>
          <para>Наконец, сервер вызывает функцию &man.pam.end.3;
            для оповещения библиотеки PAM о том, что работа с ней завершена и
            какие-либо выделенные в течение сеанса ресурсы можно
            освободить.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section id="pam-config">
    <title id="pam-config.title">Настройка PAM</title>

    <section id="pam-config-file">
      <title id="pam-config-file.title">Файлы политик PAM</title>

      <section id="pam-config-pam.conf">
        <title id="pam-config-pam.conf.title">Файл
          <filename>/etc/pam.conf</filename></title>

        <para>Традиционно файлом политик PAM является
          <filename>/etc/pam.conf</filename>.  Он содержит все политики PAM
          для вашей системы.  Каждая строка файла описывает один шаг в цепочке,
          как показано ниже:</para>

        <programlisting>login   auth    required        pam_nologin.so  no_warn</programlisting>

        <para>Поля следуют в таком порядке: имя службы, имя подсистемы,
          управляющий флаг, имя модуля и параметры модуля.  Любые
          дополнительные поля интерпретируются как дополнительные параметры
          модуля.</para>

        <para>Для каждой пары сервис/подсистема составляется отдельная цепочка,
          и тогда получается, что, хотя порядок следования строк для одной и той
          же услуги и подсистемы является значимым, порядок перечисления
          отдельных сервисов не значим.  В примерах из оригинальной
          работы по PAM строки конфигурации сгруппированы по подсистемам, в
          поставляемом с &solaris; файле <filename>pam.conf</filename> именно
          так и сделано, но в стандартном конфигурационном файле из поставки
          FreeBSD строки настроек сгруппированы по сервисам.  Подходит любой
          из этих способов; они имеют один и тот же смысл.</para>
      </section>

      <section id="pam-config-pam.d">
        <title id="pam-config-pam.d.title">Каталог
          <filename>/etc/pam.d</filename></title>

        <para>OpenPAM и Linux-PAM поддерживают альтернативный механизм
          настройки, который для FreeBSD является предпочтительным.  В этой
          схеме каждая политика содержится в отдельном файле с именем,
          соответствующем сервису, к которому она применяется.  Эти файлы
          размещаются в каталоге <filename>/etc/pam.d/</filename>.</para>

        <para>Такие файлы политик, ориентированные на сервисы, имеют только
          четыре поля, вместо пяти полей в файле <filename>pam.conf</filename>:
          поле имени сервиса опущено.  Таким образом, вместо примера строки
          файла <filename>pam.conf</filename> из предыдущего раздела получится
          следующая строка в файле <filename>/etc/pam.d/login</filename>:</para>

        <programlisting>auth    required        pam_nologin.so  no_warn</programlisting>

        <para>Как следствие такого упрощённого синтаксиса, возможно
          использование одних и тех же политик для нескольких сервисов,
          связывая каждое имя сервиса с тем же самым файлом политик.  К
          примеру, для использования той же самой политики для сервисов
          <literal>su</literal> и <literal>sudo</literal>, можно сделать
          следующее:</para>

        <screen>&prompt.root; <userinput>cd /etc/pam.d</userinput>
&prompt.root; <userinput>ln -s su sudo</userinput></screen>
 
        <para>Это работает, потому что имя сервиса определяется именем файла, а
          не его указанием в файле политики, так что один и тот же файл может
          использоваться для нескольких сервисов с разными названиями.</para>

        <para>Так как политика каждого сервиса хранится в отдельном файле,
          то механизм <filename>pam.d</filename> делает установку
          дополнительных политик для программных пакетов сторонних
          разработчиков очень лёгкой задачей.</para>
      </section>

      <section id="pam-config-file-order">
        <title id="pam-config-file-order.title">Порядок поиска политик</title>

        <para>Как вы видели выше, политики PAM могут находиться в нескольких
          местах.  Что будет, если политики для одного и того же сервиса
          имеются в разных местах?</para>

        <para>Необходимо осознать, что система конфигурации PAM ориентирована
          на цепочки.<!-- XXX --></para>
      </section>
    </section>

    <section id="pam-config-breakdown">
      <title id="pam-config-breakdown.title">Структура строки настройки</title>

      <para>Как это объяснено в разделе <link linkend="pam-config-file"
        endterm="pam-config-file.title"></link>, каждая строка файла
        <filename>/etc/pam.conf</filename> состоит из четырёх или большего
        количества полей: имени сервиса, имени подсистемы, управляющего флага,
        имени модуля и дополнительных параметров модуля, которые могут
        отсутствовать.</para>

      <para>Имя сервиса обычно (хотя не всегда) является именем приложения,
        которое этот сервис обслуживает.  Если вы не уверены, обратитесь к
        документации по конкретному приложению для определения используемого
        имени сервиса.</para>

      <para>Заметьте, что если вы используете <filename>/etc/pam.d/</filename>
        вместо <filename>/etc/pam.conf</filename>, то имя сервиса задается
        именем файла политики, и опускается из строк настройки, которые в таком
        случае начинаются с названия подсистемы.</para>

      <para>Имя подсистемы представляет собой одно из четырёх ключевых слов,
        описанных в главе <link linkend="pam-facilities-primitives"
        endterm="pam-facilities-primitives.title"></link>.</para>

      <para>Точно также управляющий флаг является одним из четырёх ключевых
        слов, описанных в разделе <link linkend="pam-chains-policies"
        endterm="pam-chains-policies.title"></link>, в котором рассказано, как
        интерпретировать возвращаемый из модуля код.  В Linux-PAM
        поддерживается альтернативный синтаксис, который позволяет указать
        действие, связанной с каждый возможным кодом возврата, но этого
        следует избегать, так как он не является стандартным и
        тесно связан со способом диспетчеризации вызовов сервисов в Linux-PAM
        (а он значительно отличается от способа взаимодействия в &solaris; и
        OpenPAM).  Не вызывает удивления тот факт, что в OpenPAM этот синтаксис
        не поддерживается.</para>
    </section>

    <section id="pam-policies">
      <title id="pam-policies.title">Политики</title>

      <para>Для корректной настройки PAM необходимо понимать, как происходит
        интерпретация политик.</para>

      <para>В момент, когда приложение вызывает функцию &man.pam.start.3;,
        библиотека PAM загружает политику для указанного сервиса и выстраивает
        четыре цепочки модулей (по одной для каждой подсистемы).  Если
        одна или большее количество этих цепочек являются пустыми, то
        будут выполняться подстановки соответствующих цепочек из политики для
        сервиса <literal>other</literal>.</para>

      <para>Когда затем приложение вызывает одну из шести примитивов PAM,
        библиотека PAM выделяет из цепочки нужную подсистему и вызывает
        функцию, соответствующую сервису, в каждом модуле, перечисленном в
        цепочке, в том порядке, в каком они перечислены в конфигурации.  После
        каждого обращения к функции сервиса, тип модуля и возвращённый из этой
        функции код результата выполнения используются для того, что делать
        дальше.  За некоторыми исключениями, которые будут описаны ниже,
        применяется такая таблица:</para>

      <table>
	<title>Сводная таблица отработки цепочек PAM</title>

	<tgroup cols="4">
	  <colspec colwidth="1*" colname="type">

	  <colspec colwidth="1*" colname="success">

	  <colspec colwidth="1*" colname="ignore">

	  <colspec colwidth="1*" colname="other">

	  <thead>
	    <row>
	      <entry colname="type"></entry>

	      <entry colname="success"><literal>PAM_SUCCESS</literal></entry>

	      <entry colname="ignore"><literal>PAM_IGNORE</literal></entry>

 	      <entry colname="other"><literal>other</literal></entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
              <entry colname="type">binding</entry>

              <entry colname="success">if (!fail) break;</entry>

              <entry colname="ignore">-</entry>

              <entry colname="other">fail = true;</entry>
            </row>

            <row>
	      <entry colname="type">required</entry>

	      <entry colname="success">-</entry>

	      <entry colname="ignore">-</entry>

	      <entry colname="other">fail = true;</entry>
	    </row>

	    <row>
	      <entry colname="type">requisite</entry>

	      <entry colname="success">-</entry>

	      <entry colname="ignore">-</entry>

	      <entry colname="other">fail = true; break;</entry>
	    </row>

	    <row>
	      <entry colname="type">sufficient</entry>

	      <entry colname="success">if (!fail) break;</entry>

	      <entry colname="ignore">-</entry>

	      <entry colname="ignore">-</entry>
	    </row>

	    <row>
	      <entry colname="type">optional</entry>

	      <entry colname="success">-</entry>

	      <entry colname="ignore">-</entry>

	      <entry colname="other">-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Если переменная <varname>fail</varname> принимает истинное
        значение в конце отработки цепочки, или когда достигнут
        <quote>break</quote>, диспетчер возвращает код ошибки, возвращённый
        первым модулем, отработавшим неудачно.  В противном случае
        возвращается <literal>PAM_SUCCESS</literal>.</para>

      <para>Первым исключением является то, что код ошибки
	<literal>PAM_NEW_AUTHTOK_REQD</literal> интерпретируется как успешный
        результат, кроме случая, когда модуль отработал успешно, и по крайней
        мере один модуль возвратил <literal>PAM_NEW_AUTHTOK_REQD</literal>,
        тогда диспетчер возвратит результат
        <literal>PAM_NEW_AUTHTOK_REQD</literal>.</para>

      <para>Вторым исключением является то, что &man.pam.setcred.3; считает,
        что модули <literal>binding</literal> и <literal>sufficient</literal>
        являются равнозначными <literal>required</literal>.</para>

      <para>Третьим и последним исключением является то, что функция
	&man.pam.chauthtok.3; отрабатывает полную цепочку дважды (один раз для
        предварительных проверок, и ещё раз для реального задания пароля), и
        на подготовительной фазе она считает, что модули 
	<literal>binding</literal> и <literal>sufficient</literal> являются
	равнозначными <literal>required</literal>.</para>
    </section>
  </section>

  <section id="pam-freebsd-modules">
    <title id="pam-freebsd-modules.title">Модули PAM во FreeBSD</title>

    <section id="pam-modules-deny">
      <title id="pam-modules-deny.title">&man.pam.deny.8;</title>

      <para>Модуль &man.pam.deny.8; является одним из простейших доступных
        модулей; на любой запрос он возвращает результат
        <literal>PAM_AUTH_ERR</literal>.
        Он полезен для быстрого отключения сервиса (добавьте его на верх
        каждой цепочки) или завершения цепочек модулей
        <literal>sufficient</literal>.</para>
    </section>

    <section id="pam-modules-echo">
      <title id="pam-modules-echo.title">&man.pam.echo.8;</title>

      <para>Модуль &man.pam.echo.8; просто передаёт свои параметры в функцию
        взаимодействия как сообщение <literal>PAM_TEXT_INFO</literal>.  В
        основном полезна для отладки, но также может использоваться для
        вывода сообщений, таких как <quote>Unauthorized access will be
        prosecuted</quote> до запуска процедуры аутентификации.</para>
    </section>

    <section id="pam-modules-exec">
      <title id="pam-modules-exec.title">&man.pam.exec.8;</title>

      <para>Модуль &man.pam.exec.8; воспринимает первый переданный ему
        параметр как имя программы для выполнения, а остальные аргументы
        передаются этой программе в качестве параметров командной строки.
        Одним из возможных применений является его использование для запуска
        в момент регистрации в системе программы монтирования домашнего
        каталога пользователя.</para>
    </section>

    <section id="pam-modules-ftpusers">
      <title id="pam-modules-ftpusers.title">&man.pam.ftpusers.8;</title>

      <para>Модуль &man.pam.ftpusers.8;</para>
    </section>

    <section id="pam-modules-group">
      <title id="pam-modules-group.title">&man.pam.group.8;</title>

      <para>Модуль &man.pam.group.8; принимает или отвергает аппликантов в
        зависимости от их членства в определённой файловой группе (обычно
        <literal>wheel</literal> для &man.su.1;).  В первую очередь
        предназначен для сохранения традиционного поведения утилиты
        BSD &man.su.1;, хотя имеет и много других применений, таких как
        отключение определённых групп пользователей от некоторого
        сервиса.</para>
    </section>

    <section id="pam-modules-guest">
      <title id="pam-modules-guest.title">&man.pam.guest.8;</title>

      <para>Модуль &man.pam.guest.8; позволяет осуществлять гостевые входы
        с использованием фиксированных имён входа в систему.  На пароль могут
        накладываться различные ограничения, однако действием по умолчанию
        является ввод любого пароля при использовании имени, соответствующего
        гостевому входу.  Модуль &man.pam.guest.8; можно легко использовать
        для реализации анонимных входов на FTP.</para>
    </section>

    <section id="pam-modules-krb5">
      <title id="pam-modules-krb5.title">&man.pam.krb5.8;</title>

      <para>Модуль &man.pam.krb5.8;</para>
    </section>

    <section id="pam-modules-ksu">
      <title id="pam-modules-ksu.title">&man.pam.ksu.8;</title>

      <para>Модуль &man.pam.ksu.8;</para>
    </section>

    <section id="pam-modules-lastlog">
      <title id="pam-modules-lastlog.title">&man.pam.lastlog.8;</title>

      <para>Модуль &man.pam.lastlog.8;</para>
    </section>

    <section id="pam-modules-login-access">
      <title id="pam-modules-login-access.title">
        &man.pam.login.access.8;</title>

      <para>Модуль &man.pam.login.access.8; предоставляет реализацию примитива
        для управления учётными записями, который вводит в действие
        ограничения на вход, задаваемые в таблице &man.login.access.5;.</para>
    </section>

    <section id="pam-modules-nologin">
      <title id="pam-modules-nologin.title">&man.pam.nologin.8;</title>

      <para>Модуль &man.pam.nologin.8; отвергает любые входы не пользователем
        root, если существует файл <filename>/var/run/nologin</filename>.
        Обычно этот файл создаётся утилитой &man.shutdown.8;, когда до
        запланированного завершения работы системы остаётся менее пяти
        минут.</para>
    </section>

    <section id="pam-modules-opie">
      <title id="pam-modules-opie.title">&man.pam.opie.8;</title>

      <para>Модуль &man.pam.opie.8; реализует метод аутентификации
        &man.opie.4;.  Система &man.opie.4; является механизмом работы по
        схеме запрос-ответ, при котором ответ на каждый запрос является
        прямой функцией от запроса и ключевой фразы, так что ответ может быть
        легко и <quote>вовремя</quote> вычислен любым, знающим ключевую фразу,
        что избавляет от необходимости передавать пароль.  Кроме того, так
        как в &man.opie.4; никогда повторно не используется запрос, ответ на
        который был корректно получен, эта схема является устойчивой к
        атакам, основанным на повторе действий.</para>
    </section>

    <section id="pam-modules-opieaccess">
      <title id="pam-modules-opieaccess.title">&man.pam.opieaccess.8;</title>

      <para>Модуль &man.pam.opieaccess.8; дополняет модуль &man.pam.opie.8;.
        Его работа заключается в выполнении ограничений, задаваемых файлом
        &man.opieaccess.5;, который определяет условия, при которых
        пользователь, нормально прошедший аутентификацию посредством
        &man.opie.4;, может использовать альтернативные методы.  Чаще всего
        он используется для запрета использования аутентификации на основе
        паролей с непроверенных хостов.</para>

      <para>Для эффективности модуль &man.pam.opieaccess.8; должен быть
        определён в цепочке <literal>auth</literal> как
        <literal>requisite</literal> сразу же после записи
        <literal>sufficient</literal> для &man.pam.opie.8;, но перед любыми
        другими модулями.</para>
    </section>

    <section id="pam-modules-passwdqc">
      <title id="pam-modules-passwdqc.title">&man.pam.passwdqc.8;</title>

      <para>Модуль &man.pam.passwdqc.8;</para>
    </section>

    <section id="pam-modules-permit">
      <title id="pam-modules-permit.title">&man.pam.permit.8;</title>

      <para>Модуль &man.pam.permit.8; является одним из самых простым из
        имеющихся; на любой запрос он отвечает <literal>PAM_SUCCESS</literal>.
        Он полезен в качестве замены пустого места для сервисов, когда
        одна или большее количество цепочек в противном случае останутся
        пустыми.</para>
    </section>

    <section id="pam-modules-radius">
      <title id="pam-modules-radius.title">&man.pam.radius.8;</title>

      <para>Модуль &man.pam.radius.8;</para>
    </section>

    <section id="pam-modules-rhosts">
      <title id="pam-modules-rhosts.title">&man.pam.rhosts.8;</title>

      <para>Модуль &man.pam.rhosts.8;</para>
    </section>

    <section id="pam-modules-rootok">
      <title id="pam-modules-rootok.title">&man.pam.rootok.8;</title>

      <para>Модуль &man.pam.rootok.8; возвращает положительный результат в том
        и только в том случае, если реальный id пользователя процесса, его
        вызвавшего (предполагается, что его запускает аппликант) равен 0.  Это
        полезно для несетевых сервисов, таких как &man.su.1; или
        &man.passwd.1;, к которым пользователь <literal>root</literal> должен
        иметь автоматический доступ.</para>
    </section>

    <section id="pam-modules-securetty">
      <title id="pam-modules-securetty.title">&man.pam.securetty.8;</title>

      <para>Модуль &man.pam.securetty.8;</para>
    </section>

    <section id="pam-modules-self">
      <title id="pam-modules-self.title">&man.pam.self.8;</title>

      <para>Модуль &man.pam.self.8; возвращает положительный результат тогда и
        только тогда, когда имена аппликанта соответствуют целевой учётной
        записи.  Больше всего это пригодится в несетевых сервисах, таких как
        &man.su.1;, в которых идентификация аппликанта может быть с лёгкостью
        проверена.</para>
    </section>

    <section id="pam-modules-ssh">
      <title id="pam-modules-ssh.title">&man.pam.ssh.8;</title>

      <para>Модуль &man.pam.ssh.8; предоставляет как сервис аутентификации,
        так и сеанса.  Сервис аутентификации позволяет пользователям, имеющим
        секретные ключи SSH, защищённые паролями, в своих каталогах
        <filename>~/.ssh</filename>, аутентифицироваться посредством этих
        паролей.  Сеансовый сервис запускает &man.ssh-agent.1; и загружает
        ключи, которые были расшифрованы на фазе аутентификации.  Такая
        возможность, в частности, полезна для локальных входов в систему,
        как в систему X (посредством &man.xdm.1; или другого X-менеджера
        входов, умеющего работать с PAM), так и на консоль.</para>
    </section>

    <section id="pam-modules-tacplus">
      <title id="pam-modules-tacplus.title">&man.pam.tacplus.8;</title>

      <para>Модуль &man.pam.tacplus.8;</para>
    </section>

    <section id="pam-modules-unix">
      <title id="pam-modules-unix.title">&man.pam.unix.8;</title>

      <para>Модуль &man.pam.unix.8; реализует традиционную аутентификацию
        &unix; на основе паролей, использующую функцию &man.getpwnam.3; для
        получения пароля целевой учётной записи и сравнивающую её с тем, что
        представил аппликант.  Он также предоставляет средства управления
        учётными записями (отслеживая время действия учётной записи и пароля) и
        смены паролей.  Наверное, это самый полезный модуль, так как
        подавляющее большинство администраторов хотят сохранить исторически
        сложившееся поведение по крайней мере некоторых сервисов.</para>
    </section>
  </section>

  <section id="pam-appl-prog">
    <title id="pam-appl-prog.title">Программирование приложений с PAM</title>

    <para><!--XXX-->Этот раздел ещё не написан.</para>

    <!--

      Заметьте, что, хотя в оригинальной работе о PAM включен пример
      PAM-приложения, вызывающего pam_open_session() перед pam_setcred(),
      в документации по Linux-PAM указывается, что сначала должны вызываться
      функция pam_setcred(), что имеет больше смысла.

      Отметьте также, что пример из той работы вызывает setgid(),
      initgroups() и setuid() самостоятельно, вместо того, чтобы полагаться
      на функцию pam_setcred().

      -->

  </section>

  <section id="pam-module-prog">
    <title id="pam-module-prog.title">Программирование модуля PAM</title>

    <para><!--XXX-->Этот раздел ещё не написан.</para>
  </section>

  <appendix id="pam-sample-appl">
    <title id="pam-sample-appl.title">Пример PAM-приложения</title>

    <para>Далее следует минимальная реализация программы &man.su.1; с
      использованием PAM.  Заметьте, что в ней используется специфичная для
      OpenPAM функция взаимодействия &man.openpam.ttyconv.3;, объявление
      которой расположено в файле <filename
      class="headerfile">security/openpam.h</filename>.
      Если вы собираетесь строить это приложение в системе с другой
      библиотекой PAM, вам необходимо будет создать собственную функцию
      взаимодействия.  Надёжную функцию взаимодействия неожиданно трудно
      написать; та, что находится в приложении <link linkend="pam-sample-conv"
      endterm="pam-sample-conv.title"></link>, хороша в качестве отправной
      точки, но в реальных приложениях использоваться не может.</para>

    <programlisting><inlinegraphic fileref="pam_app.c"
      format="linespecific"></programlisting>
  </appendix>

  <appendix id="pam-sample-module">
    <title id="pam-sample-module.title">Пример PAM-модуля</title>

    <para>Далее приведена минимальная реализация &man.pam.unix.8;,
      предоставляющая только сервисы аутентификации.  Она должна строиться и
      работать с большинством из реализаций PAM, но использует возможности
      расширений OpenPAM, если они присутствуют: отметьте использование
      функции &man.pam.get.authtok.3;, которая кардинально упрощает
      организацию ввода пароля пользователем.</para>

    <programlisting><inlinegraphic fileref="pam_module.c"
      format="linespecific"></programlisting>
  </appendix>

  <appendix id="pam-sample-conv">
    <title id="pam-sample-conv.title">Пример функции взаимодействия
      PAM</title>

    <para>Функция взаимодействия, приводимая ниже, является значительно
      упрощённой версией функции &man.openpam.ttyconv.3; из OpenPAM.  Она
      полнофункциональна, и должна послужить источником идей о том, как
      должна себя вести функция взаимодействия, однако она слишком проста для
      реальных приложений.  Даже если вы не используете OpenPAM, можете
      сгрузить исходный код и использовать &man.openpam.ttyconv.3; в своих
      целях; мы надеемся, что она достаточно надёжна в качестве функции
      для взаимодействия с терминальными устройствами.</para>

    <programlisting><inlinegraphic fileref="pam_conv.c"
      format="linespecific"></programlisting>
  </appendix>

  <bibliography id="pam-further">
    <title id="pam-further.title">Дополнительная литература</title>

    <abstract>
      <para>Это список документов, относящихся к PAM и связанным вопросам.
        Он, несомненно, не является полным.</para>
    </abstract>

    <bibliodiv>
      <title>Работы</title>

      <biblioentry>
        <title><ulink
          url="http://www.sun.com/software/solaris/pam/pam.external.pdf">
	  Making Login Services Independent of Authentication
          Technologies</ulink></title>

        <authorgroup>
          <author>
            <surname>Samar</surname>

            <firstname>Vipin</firstname>
          </author>

          <author>
            <surname>Lai</surname>

            <firstname>Charlie</firstname>
          </author>
        </authorgroup>

        <orgname>Sun Microsystems</orgname>
      </biblioentry>

      <biblioentry>
        <title><ulink
          url="http://www.opengroup.org/pubs/catalog/p702.htm">X/Open
          Single Sign-on Preliminary Specification</ulink></title>

        <orgname>The Open Group</orgname>

        <isbn>1-85912-144-6</isbn>

        <pubdate>Июнь 1997</pubdate>
      </biblioentry>

      <biblioentry>
        <title><ulink
	  url="http://www.kernel.org/pub/linux/libs/pam/pre/doc/current-draft.txt">
          Pluggable Authentication Modules</ulink></title>

        <author>
          <surname>Morgan</surname>

          <firstname>Andrew</firstname>

          <othername role="mi">G.</othername>
        </author>

        <pubdate>6 октября 1999</pubdate>
      </biblioentry>
    </bibliodiv>

    <bibliodiv>
      <title>Руководства пользователя</title>

      <biblioentry>
        <title><ulink
          url="http://www.sun.com/software/solaris/pam/pam.admin.pdf">PAM
          Administration</ulink></title>

        <orgname>Sun Microsystems</orgname>
      </biblioentry>
    </bibliodiv>

    <bibliodiv>
      <title>Web-страницы по данной тематике</title>

      <biblioentry>
        <title><ulink url="http://openpam.sourceforge.net/">Домашняя страница
          OpenPAM</ulink></title>

        <author>
          <surname>Sm&oslash;rgrav</surname>

          <firstname>Dag-Erling</firstname>
        </author>

        <orgname>ThinkSec AS</orgname>
      </biblioentry>

      <biblioentry>
        <title><ulink url="http://www.kernel.org/pub/linux/libs/pam/">Домашняя
          страница Linux-PAM</ulink></title>

        <author>
          <surname>Morgan</surname>

          <firstname>Andrew</firstname>

          <othername role="mi">G.</othername>
        </author>
      </biblioentry>

      <biblioentry>
        <title><ulink url="http://wwws.sun.com/software/solaris/pam/">Домашняя
          страница Solaris PAM</ulink></title>

        <orgname>Sun Microsystems</orgname>
      </biblioentry>
    </bibliodiv>
  </bibliography>
</article>
