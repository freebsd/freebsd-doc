<!-- $Id: serial.sgml,v 1.3 1999-08-17 21:22:43 nik Exp $ -->
<!-- The FreeBSD Russian Documentation Project -->

  <sect>
    <heading>Коммуникационные адаптеры<label id="serial"></heading>

    <p>В этом разделе освещены вопросы о работе последовательных
    адаптеров во FreeBSD.  Протоколы PPP и SLIP рассматриваются в разделе,
    посвящённом <ref id="networking" name="работе в сети">.

    <sect1>
      <heading>
        Как узнать, какие последовательные порты были обнаружены FreeBSD?
      </heading>

      <p>При загрузке ядра FreeBSD оно будет пытаться найти последовательные
      порты, с поддержкой которых было откомпилировано.  Вы можете
      повнимательней присмотреться к выдаваемым сообщениям либо выполнить
      команду

      <verb>
        dmesg | grep sio
      </verb>

      <p>после загрузки и запуска системы.

      <p>Вот пример вывода указанной команды:

      <verb>
        sio0 at 0x3f8-0x3ff irq 4 on isa
        sio0: type 16550A
        sio1 at 0x2f8-0x2ff irq 3 on isa
        sio1: type 16550A
      </verb>

      <p>Здесь присутствуют два последовательных порта.  Первый использует
      irq 4, порт ввода/вывода <tt/0x3f8/ и построен на микросхеме UART типа
      16550A.  Второй использует тот же тип микросхемы, но использует irq 3 и
      адрес порта ввода/вывода <tt/0x2f8/.  Внутренние модемы выглядят точно
      также, как последовательные порты, за исключением того, что к ним
      всегда ``подключен'' модем.

      <p>В ядро <tt/GENERIC/ встроена поддержка двух последовательных портов,
      с irq и адресами портов ввода/вывода, как в примере выше.  Если эти
      настройки не соответствуют вашим, или если вы добавили внутренние
      модемы, или у вас больше последовательных портов, чем описано в ядре,
      просто переконфигурируйте ядро.  За дополнительной информацией
      обратитесь к разделу <ref id="make-kernel" name="о построении ядра">.

    <sect1>
      <heading>
        Как узнать, какие внутренние модемы были обнаружены FreeBSD?
      </heading>

      <p>Посмотрите ответ на предыдущий вопрос.

    <sect1>
      <heading>
        Я только что поставил 2.0.5 и не нашёл устройств <tt/tty0X/!
      </heading>

      <p>Не волнуйтесь, они были объединены с устройствами <tt/ttydX/.
      Вам придётся подправить конфигурационные файлы, которые вы раньше
      использовали.

    <sect1>
      <heading>
        Как осуществляется доступ к последовательным портам во FreeBSD?
      </heading>

      <p>Третий последовательный порт, <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?sio" name="sio2"> (который в
      DOS называется COM3), называется <tt>/dev/cuaa2</tt> для устройств,
      выполняющих исходящие звонки, и <tt>/dev/ttyd2</tt> для устройств,
      принимающих входящие звонки.  Какая разница между этими двумя классами
      устройств?

      <p>Вы должны использовать <tt/ttydX/ для входящих соединений.  При
      открытии <tt>/dev/ttydX</tt> в блокирующем режиме, процесс будет 
      ожидать неактивности соответствующего устройства <tt/cuaaX/, а затем
      появления сигнала о наличии несущей.  При открытии устройства 
      <tt/cuaaX/, он проверяет, что последовательный порт не используется
      уже устройством <tt/ttydX/.  Если порт доступен, он ``похищает'' его
      у устройства <tt/ttydX/.  Также устройство <tt/cuaXX/ не следит за
      наличием несущей.  С такой схемой работы и модемом, находящимся в
      режиме автоответа, вы можете позволить пользователям входить в
      систему и в то же время можете осуществлять исходящие звонки, а
      система позаботится о возможных конфликтах.

    <sect1>
      <heading>
        Как включить поддержку многопортовых последовательных адаптеров?
      </heading>

      <p>Повторим ещё раз: информация о конфигурировании ядра содержится в 
      разделе, посвящённом этому вопросу.  Для многопортовых последовательных
      адаптеров в файле конфигурации ядра поместите ключевое слово
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?sio" name="sio">
      для каждого порта на адаптере.  Но irq и вектор должен быть указан
      только у одного порта.  Все порты на адаптере должны использовать одно
      и то же irq.  Используйте последний последовательный порт для указания
      irq. Также включите опцию <tt/COM&lowbar;MULTIPORT/.

      <p>В следующем примере дано описание 4-портового адаптер AST на irq 7:

      <verb>
        options "COM_MULTIPORT"
        device sio4 at isa? port 0x2a0 tty flags 0x781
        device sio5 at isa? port 0x2a8 tty flags 0x781
        device sio6 at isa? port 0x2b0 tty flags 0x781
        device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr
      </verb>

      <p>Флаги указывают, что управляющий порт имеет младший номер
      устройства 7 (<tt/0x700/), включена диагностика на время обнаружения
      (<tt/0x080/), и все порты используют одно и то же irq (<tt/0x001/).

    <sect1>
      <heading>
        Может ли FreeBSD использовать несколько многопортовых адаптеров
        с одинаковым irq?
      </heading>

      <p>Пока нет.  Вы должны назначить уникальный irq для каждого адаптера.

    <sect1>
      <heading>
        Можно ли установить режим работы по умолчанию для порта?
      </heading>

      <p>Вашему приложению может понадобиться открыть устройства
      <tt/ttydX/ (или <tt/cuaaX/).  Когда процесс открывает устройство,
      оно имеет набор параметров ввода/вывода.  Вы можете посмотреть их
      значения командой

      <verb>
        stty -a -f /dev/ttyd1
      </verb>

      <p>Когда вы меняете настройки этого устройства, они действуют
      вплоть до закрытия устройства.  При повторном открытии оно будут
      иметь режимы работы по умолчанию.  Чтобы изменить значения режимов
      работы по умолчанию, вы можете открыть и изменить настройки в
      устройстве ``начального состояния''.  Например, чтобы сделать режимом
      по умолчанию режим <tt/CLOCAL/, 8 бит, и управление потоком
      <tt>XON/XOFF</tt> для устройства ttyd5, сделайте следующее:

      <verb>
        stty -f /dev/ttyid5 clocal cs8 ixon ixoff
      </verb>

      <p>Для выполнения таких действий предназначен скрипт
      <tt>/etc/rc.serial</tt>.  Теперь при открытии устройства <tt/ttyd5/
      приложение будет иметь именно такой режим работы с портом.  Оно,
      однако. может изменить эти режимы по своему усмотрению.

      <p>Вы можете запретить изменение приложением некоторых режимов работы,
      выполнив настройки устройства ``постоянного состояния''.  Например,
      чтобы сделать скорость работы <tt/ttyd5/ постоянно равной 57600 bps,
      выполните

      <verb>
        stty -f /dev/ttyld5 57600
      </verb>

      <p>Теперь, если приложение откроет <tt/ttyd5/ и попытается изменить
      скорость работы порта, она всё равно останется равной 57600 bps.

      <p>Естественно, вы должны сделать устройства начального и
      постоянного состояний доступными на запись только пользователю
      <tt/root/.  Скрипт <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV" name="MAKEDEV">
      при создании файлов устройств этого <bf/НЕ/ делает.

    <sect1>
      <heading>Как сделать вход через модем?</heading>

      <p>Похоже, что вы хотите стать Internet-провайдером, да?  Сначала
      вам необходимо подключить к системе один или несколько модемов,
      которые могут работать в режиме автоответа.  Модем должен держать
      сигнал наличия несущей, только когда она присутствует.  Он должен
      вешать трубку и переинициализировать, когда сигнал готовности 
      устройства DTE (<tt/DTR/) меняет состояние из включенного на
      выключенный.  Должно использоваться аппаратное (<tt>RTS/CTS</tt>)
      управление потоком или вовсе отсутствовать.  Ещё он должен работать
      на постоянной скорости с портом компьютера, но (что удобно для
      звонящих) с согласованием скорости передачи с другим модемом.

      <p>Для большинства модемов, поддерживающих набор команд Hayes,
      следующая последовательность команд выполнит эти настройки и
      сохранит их в энергонезависимой памяти:

      <verb>
        AT &amp;C1 &amp;D3 &amp;K3 &amp;Q6 S0=1 &amp;W
      </verb>

      <p>Информация о том, как сделать эти настройки без обращения к
      терминальным программам MS-DOS, содержится в разделе о <ref
      id="direct-at" name="посылке AT-команд">.

      <p>Затем опишите модем в файле <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?ttys" name="/etc/ttys">.
      В нём перечислены все порты, с которых операционная система ожидает
      входа пользователей.  Добавьте строку, которая выглядит как эта:

      <verb>
        ttyd1 "/usr/libexec/getty std.57600" dialup on insecure
      </verb>

      <p>В этой строке указано, что ко второму последовательному порту
      (<tt>/dev/ttyd1</tt>) подключен модем на скорости 57600 bps без
      контроля по чётности (<tt/std.57600/, что берётся из файла
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?gettytab"
      name="/etc/gettytab">).  Тип терминала для этого порта определён
      как ``dialup''.  Порт включен (``on'') и небезопасен (``insecure''),
      что означает, что попытки войти в систему пользователем root с этого
      порта будут отвергнуты.  Для портов, обслуживающих входящие звонки,
      как этот, используйте устройства <tt/ttydX/.

      <p>Использование слова ``dialup'' в качестве имени терминала является
      обычной практикой.  Многие пользователи включают в свои файлы
      .profile или .login скрипты для задания реального типа терминала, если
      начальным является тип dialup.  В примере порт описан небезопасным.
      Чтобы войти администратором на этом порту, вам нужно войти обычным
      пользователем, а затем командой ``<htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?su" name="su">'' стать
      пользователем <tt/root/.  Если порт имеет атрибут ``secure'', то
      пользователь <tt/root/ может входить с этого порта непосредственно.

      <p>После модифицирования <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?ttys" name="/etc/ttys">, вам
      нужно послать сигнал потери связи или <tt/HUP/ процессу <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?init" name="init">:

      <verb>
        kill -HUP 1
      </verb>

      <p>Это заставит процесс init снова прочитать файл <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?ttys" name="/etc/ttys">.
      Процесс init запустит процессы getty для всех включенных портов.
      Вы можете проверить, доступны ли входы с конкретного порта, выполнив
      команду

      <verb>
        ps -ax | grep '[t]tyd1'
      </verb>

      <p>Вы должны увидеть нечто вроде следующего:

      <verb>
        747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1
      </verb>

    <sect1>
      <heading>Как подключить терминал к FreeBSD?</heading>

      <p>Если вы собираетесь использовать другой компьютер в качестве
      терминала для FreeBSD, соедините их послежовательные порты 
      нуль-модемным кабелем.  Если у вас есть терминал, обратитесь к его
      документации.

      <p>Затем модифицируйте файл <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?ttys" name="/etc/ttys">
      описанным выше способом.  Например, если вы подключаете терминал
      WYSE-50 к пятому последовательному порту, используйте такую строчку:

      <verb>
        ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure
      </verb>

      <p>В этом примере описан порт на <tt>/dev/ttyd4</tt>, имеющий
      терминал wyse50, подключенный на скорости 34800 bps без контроля по
      четности (<tt/std.38400/ из <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?gettytab"
      name="/etc/gettytab">) и разрешён непосредственный вход пользователя
      <tt/root/ (secure).

    <sect1>
      <heading>Почему не удаётся запустить <tt/tip/ или <tt/cu/?</heading>

      <p>Скорее всего, в вашей системе запуск программ <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?tip" name="tip"> и <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?cu" name="cu"> разрешён только
      пользователю <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?uucp"
      name="uucp"> и членам группы <tt/dialer/.  Вы можете использовать
      группу <tt/dialer/ для управления доступом к вашему модему или
      удалённым системам.  Достаточно добавить пользоватея в группу dialer.

      <p>Вы можете разрешить всем пользователям вашей системы запускать
      <tt/tip/ и <tt/cu/, выполнив команды:

      <verb>
        # chmod 4511 /usr/bin/cu
        # chmod 4511 /usr/bin/tip
      </verb>

    <sect1>
      <heading>
        Мой модем Hayes не поддерживается---что можно сделать?
      </heading>

      <p>На самом деле страница справочника о программе <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?tip" name="tip"> устарела.
      Модемы Hayes поддерживаются системой.  Просто добавьте
      ``<tt/at=hayes/'' в ваш файл <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?remote" name="/etc/remote">.

      <p>Драйвер модемов Hayes не достаточно умён, чтобы поддерживать
      некоторые из новых возможностей современных модемов---сообщения
      типа <tt/BUSY/, <tt/NO DIALTONE/, или <tt/CONNECT 115200/ будут
      приводить его в замешательство.  Вы должны выключить вывод таких
      сообщений при использовании программы <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?tip" name="tip"> (командой
      <tt/ATX0&amp;W/).

      <p>Таймаут по умолчанию для программы <tt/tip/ равен 60 секундам.
      Ваш модем должен использовать меньшее значение, иначе tip будет
      думать, что у вас проблемы со связью.  Попробуйте <tt/ATS7=45&amp;W/.

      <p>На самом деле <tt/tip/ в том виде, каком поставляется, не 
      поддержимает можемы Hayes полностью.  Решением является редактирование
      файла <tt/tipconf.h/ в каталоге <tt>/usr/src/usr.bin/tip/tip</tt>.
      Чтобы это сделать, вам нужен дистрибутив исходных текстов системы.

      <p>Замените строку ``<tt/#define HAYES 0/'' на ``<tt/#define HAYES
      1/''.  Затем выполните ``<tt/make/'' и ``<tt/make install/''.  После
      этих действий всё работает замечательно.

    <sect1>
      <heading>
        Как я должен ввести эти AT-команды?<label id="direct-at">
      </heading>

      <p>Создайте так называемое ``<tt/прямое/'' описание в вашем файле
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?remote"
      name="/etc/remote">.  Например, если ваш модем подключен к первому
      последовательному порту, <tt>/dev/cuaa0</tt>, сделайте такую строку:

      <verb>
        cuaa0:dv=/dev/cuaa0:br#19200:pa=none
      </verb>

      <p>Укажите максимальную скорость обмена с портом, поддерживаемую
      модемом в параметре br.  Затем выполните команду <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?tip" name="tip cuaa0"> и
      вы подключитесь к модему.

      <p>Если в вашей системе нет устройства <tt>/dev/cuaa0</tt>, сделайте
      следующее:

      <verb>
        # cd /dev
        # ./MAKEDEV cuaa0
      </verb>

      <p>Или используйте cu, войдя администратором, с такими параметрами:

      <verb>
        # cu -l``line'' -s``speed''
      </verb>

      <p>где line - это имя последовательного порта (например,
      <tt>/dev/cuaa0</tt>), а speed - скорость работы модема с портом
      (например, <tt>57600</tt>).  После ввода AT-команд, наберите
      <tt>~.</tt> для завершения работы.

    <sect1>
      <heading>Знак <tt/@/ для описания характеристики pn не работает!</heading>

      <p>Знак <tt/@/ в характеристике, описывающей номер телефона, указывает
      программе tip обратиться к файлу <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?phones(5)" name="/etc/phones">
      для поиска телефонного номера.  Однако знак <tt/@/ является также и
      специальным символом в файлах описания характеристик типа
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?remote"
      name="/etc/remote">.  Экранируйте его символом обратного слэша:

      <verb>
        pn=\@
      </verb>

    <sect1>
      <heading>Как набрать телефонный номер из командной строки?</heading>

      <p>Поместите так называемое ``<tt/общее/'' описание в ваш файл
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?remote"
      name="/etc/remote">.  Например:

      <verb>
        tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
        tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:
      </verb>

      <p>Тогда вы сможете выполнять команды вроде ``<tt/tip -115200
      5551234/''.  Если предпочитаете программу <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?cu"
      name="cu">, а не <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?tip"
      name="tip">, используйте общее описание для cu:

      <verb>
        cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:
      </verb>

      <p>и выполняйте команду ``<tt/cu 5551234 -s 115200/''.

    <sect1>
      <heading>
        Нужно ли при этом каждый раз задавать скорость работы с портом?
      </heading>

      <p>Создайте описание для <tt/tip1200/ или <tt/cu1200/, но не
      останавливайтесь на этом и используйте подходящую скорость
      при задании характеристики br. <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?tip" name="Tip"> полагает,
      что хорошим значением по умолчанию является 1200 bps, поэтому он
      использует описание для ``<tt/tip1200/''.  Однако вас никто не
      заставляет использовать именно эту скорость.

    <sect1>
      <heading>
        Мне нужно иметь доступ к нескольких хостам через терминальный сервер.
      </heading>

      <p>Вместо того, чтобы каждый раз ожидать подключения к терминальному
      серверу, а затем набирать команду ``<tt/CONNECT &lt;host&gt;/'',
      используйте характеристику <tt/cm/ программы tip.  Например, вот такое
      описание в файле <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?remote" name="/etc/remote">:

      <verb>
        pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
        muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
        deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cua02:br#38400:at=hayes:du:pa=none:pn=5551234:
      </verb>

      <p>позволит вам просто набрать ``<tt/tip pain/'' или 
      ``<tt/tip muffin/'' для подключения к хостам pain или muffin и
      ``<tt/tip deep13/'' для доступа к терминальному серверу.

    <sect1>
      <heading>
        Может ли tip использовать несколько телефонов для одного сайта?
      </heading>

      <p>Эта проблема возникает, когда в университете есть пара
      модемных входов и несколько тысяч студентов, пытающихся ими
      воспользоваться...

      <p>Создайте описание для вашего университета в файле
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?remote"
      name="/etc/remote"> и используйте символ <tt>\@</tt> при задании
      характеристики <tt/pn/:

      <verb>
        big-university:\
        :pn=\@:tc=dialout
        dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:
      </verb>

      <p>После этого пропишите номера телефонов университета в файле
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?phones"
      name="/etc/phones">:

      <verb>
        big-university 5551111
        big-university 5551112
        big-university 5551113
        big-university 5551114
      </verb>

      <p><htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?tip"
      name="Tip"> будет пытаться воспользоваться всеми телефонными номерами
      в указанном порядке, прежде чем завершить работу.  Если вы хотите,
      чтобы попытки были продолжены, запустите <tt/tip/ в цикле while.
      
    <sect1>
      <heading>
        Почему нужно нажимать CTRL+P дважды для посылки одного этого 
        символа?
      </heading>

      <p>По умолчанию CTRL+P является специальным символом ``принудительного
      ввода'', используемым для указания программе <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?tip" name="tip">, что
      следующий символ является байтом данных.  Вы можете назначить
      функцию символа принудительного ввода любому другому символу с помощью
      команды <tt/~s/, которая предназначена для ``установки значений
      переменных''.

      <p>Наберите ``<tt/~sforce=&lt;single-char&gt;/'' с начала новой
      строки.  Здесь <tt/&lt;single-char&gt;/ - любой одиночный символ.  
      Если вы не зададите <tt/&lt;single-char&gt;/, то символом
      принудительного ввода будет нулевой символ, который можно получить,
      набрав CTRL+2 или CTRL+SPACE.  Подходящим значением для
      <tt/&lt;single-char&gt;/ может быть SHIFT+CTRL+6, который используется
      только некоторыми терминальными серверами.

      <p>Вы можете задать любое значение для символа принудительного ввода,
      указав его в вашем файле <tt>&dollar;HOME/.tiprc</tt>:

      <verb>
        force=<single-char>
      </verb>

    <sect1>
      <heading>Неожиданно всё стало набираться ЗАГЛАВНЫМИ БУКВАМИ?</heading>

      <p>Должно быть, вы нажали CTRL+A, символ перехода в верхний регистр
      программы <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?tip"
      name="tip">, специально предназначенный для тех, у кого не работает
      клавиша caps-lock.  Используйте команду <tt/~s/, как это было сделано
      выше, и установите значение переменной ``raisechar'' во что-нибудь
      подходящее.  В действительности вы можете установить его равным
      символу принудительного ввода, если не собираетесь пользоваться этими
      особенностями.

      <p>Следующий пример файла .tiprc должен понравиться пользователям
      редактора Emacs, которым часто приходится нажимать CTRL+2 и CTRL+A:

      <verb>
        force=^^
        raisechar=^^
      </verb>

      <p>Здесь ^^ это SHIFT+CTRL+6.

    <sect1>
      <heading>
        Как можно передавать файлы с помощью программы <tt/tip/?
      </heading>

      <p>Если вы соединились с другой UNIX-системой, вы можете посылать и 
      принимать файлы командами <tt/~p/ (передача) и <tt/~t/ (приём).  Эти
      команды запускают программы <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?cat" name="cat"> и <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?echo" name="echo"> на
      удалённой системе, чтобы принять и послать файлы.  Синтаксис вызова
      имеет такой вид:

      <verb>
        ~p <local-file> [<remote-file>]
        ~t <remote-file> [<local-file>]
      </verb>

      <p>Контроль ошибок передачи при этом не осуществляется, так что вам
      может понадобиться другой протокол передачи, например, zmodem.

    <sect1>
      <heading>Как использовать zmodem вместе с <tt/tip/?</heading>

      <p>Первым делом установите одну из программ, реализующих протокол
      zmodem из коллекции портов (там есть парочка в категории comms,
      <htmlurl url="http://www.FreeBSD.org/cgi/ports.cgi?^lrzsz" name="lrzsz">
      и <htmlurl url="http://www.FreeBSD.org/cgi/ports.cgi?^rzsz"
      name="rzsz">).

      <p>Для приёма файлов запустите программу передачи на противоположной
      стороне.  Затем нажмите enter и наберите ``<tt/~C rz/'' (или
      ``<tt/~C lrz/'', если у вас установлеи lrzsz) для начала приёма их на
      локальную машину.

      <p>Для посылки файлов, запустите программу приёма на противоположной
      стороне.  Затем нажмите enter и наберите ``<tt/~C sz &lt;files&gt;/''
      (или ``<tt/~C lsz &lt;files&gt;/'') для посылки их на удалённую
      систему.

    <sect1>
     <heading>
       FreeBSD не распознаёт последовательные порты на моей машине, хотя
       все настройки верны.
     </heading>
   
     <p>Микросхемы UART производства Acer на материнских платах и адаптерах
     распознаются некорректно.  Для решения этой проблемы попробуйте 
     воспользоваться патчем с сервера <url
     url="http://www.lemis.com/serial-port-patch.html" name="www.lemis.com">.

  </sect>

