<!-- $Id: x.sgml,v 1.4 1999-08-17 21:26:37 nik Exp $ -->
<!-- The FreeBSD Russian Documentation Project -->

  <sect>
    <heading>X Window System и виртуальные консоли<label id="x"></heading>

    <sect1>
      <heading>Я хочу запустить X, как это сделать?</heading>

      <p>Самый простой способ - это указать во время инсталляции, что вы
      хотите использовать X.

      <p>Затем следуйте указаниям в документации по утилите <htmlurl url=
      "http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config"
      name="xf86config">, которая предназначена для конфигурирования работы
      XFree86(tm) с вашим графическим адаптером/мышью/итд.

      <p>Вы можете также попробовать сервер Xaccel.  За подробной информацией
      обратитесь к разделу, посвящённому продуктам фирм <ref id="xig"
      name="Xi Graphics"> и <ref id="metrox" name="Metro Link">.

    <sect1>
      <heading>
        Почему моя мышь не работает с X?<label id="x-and-moused">
      </heading>

      <p>Если вы используете syscons (стандартный драйвер консоли), то
      можете настроить поддержку указателя мыши во всех виртуальных экранах.
      Во избежание конфликтов с X, драйвер syscons поддерживает виртуальное
      устройство ``<tt>/dev/sysmouse</tt>''.  Все события, полученные от
      реальной мыши, пишутся в устройство sysmouse, реализующее протокол
      MouseSystems.  Если вы хотите использовать вашу мышь на одной или
      нескольких виртуальных консолях, <bf/продолжая/ использовать X,
      рекомендуется такая конфигурация:

      <verb>
        /etc/rc.conf:
          moused_type=ps/2          # or whatever your actual type is
          moused_port=/dev/psm0     # or whatever your real port is
          moused_flags=

        /etc/XF86Config
          Section Pointer
              Protocol "MouseSystems"
              Device   "/dev/sysmouse"
              .....
      </verb>

      <p>Некоторые предпочитаюют использовать в X устройство
      ``<tt>/dev/mouse</tt>''.  Чтобы оно работало, файл устройства должен
      являться ссылкой на <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?sysmouse"
      name="/dev/sysmouse">:

      <verb>
        # cd /dev
        # rm -f mouse
        # ln -s sysmouse mouse
      </verb>

    <sect1>
      <heading>
        Меню и диалоговые окна в X Window работают неправильно!
      </heading>

      <p>Попробуйте выключить Num Lock.

      <p>Если клавиша Num Lock во время загрузки по умолчанию включена,
      добавьте в секцию ``<tt/Keyboard/'' файла <tt/XF86Config/ следующую
      строку.

      <verb>
        # Let the server do the NumLock processing.  This should only be
        # required when using pre-R6 clients
            ServerNumLock
      </verb>

    <sect1>
      <heading>
        Что такое виртуальные консоли и как изменить их количество?
      </heading>

      <p>Виртуальные консоли, упрощённо говоря, позволяют вам иметь
      несколько одновременных сеансов работы с той же самой машиной без
      установки какой бы то ни было сети или запуска X.

      <p>При запуске системы после вывода сообщений этапа загрузки на консоль
      выдаётся приглашение на вход в систему.  Вы можете ввести своё имя и
      пароль и начать работать (или играть!) на первой виртуальной консоли.

      <p>В какой-то момент вы можете захотеть запустить ещё одну сеанс,
      скажем, чтобы заглянуть в документацию по программе, которую вы
      запустили или для для чтения электронной почты во время ожидания
      завершения передачи данных по FTP.  Просто нажмите Alt-F2 (удерживая
      клавишу Alt, нажмите F2) и вы обнаружите приглашение, ждущее вас на
      второй ``виртуальной консоли''!  Когда захотите вернуться к
      первоначальному сеансу, нажмите Alt-F1.

      <p>После инсталляции по умолчанию во FreeBSD задействованы  три
      виртуальных консоли, а комбинации клавиш Alt-F1, Alt-F2, и Alt-F3
      служат для переключения между ними.

      Чтобы увеличить количество консолей, отредактируйте файл <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?ttys" name="/etc/ttys">,
      добавив туда записи для терминалов с именами от ``<tt/ttyv4/'' до
      ``<tt/ttyvc/'' после слов ``Virtual terminals'':

      <verb>
        # Edit the existing entry for ttyv3 in /etc/ttys and change
        # "off" to "on".
        ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
        ttyva   "/usr/libexec/getty Pc"         cons25  on secure
        ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </verb>

      <p>Используйте из них столько, сколько посчитаете нужным.  Чем больше
      виртуальных терминалов у вас имеется, тем больше ресурсов они
      используют; это может иметь значение, если у вас меньше чем 8МБ ОЗУ.
      Вы можете сменить статус консолей с ``<tt/secure/'' на
      ``<tt/insecure/''.

      <p><bf/ВАЖНОЕ ЗАМЕЧАНИЕ/ если вы хотите запустить X, вы <bf/ДОЛЖНЫ/
      оставить для него по крайней мере один неиспользуемый (или
      выключенный) виртуальный терминал.  Таким образов, если вы хотите
      иметь приглашения login на всех двенадцати функциональнык клавиши,
      то вам не повезло - вы можете это сделать только для одиннадцати из
      них, если хотите на этой же машине ещё запустить X-сервер.

      <p>Самым простым способом убрать консоль является просто её
      выключение.  Например, если вы запустили на всех 12 консолях
      виртуальные терминалы, как указано выше, и ещё хотите запустить X, то
      должны будете изменить параметры двенадцатого виртуального
      терминала с:

      <verb>
        ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </verb>

      <p>на:

      <verb>
        ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </verb>

      <p>Если на вашей клавиатуре только десять функциональных клавиш,
      то последние строки будут выглядеть так:

      <verb>
        ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
        ttyva   "/usr/libexec/getty Pc"         cons25  off secure
        ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </verb>

      <p>(Вы также можете просто их удалить.)

      <p>После того, как вы отредактировали файл <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?ttys" name="/etc/ttys">,
      проверьте, что у вас имеется достаточное количество устройств для
      виртуальных терминалов.  Самый простой способ сделать это:

      <verb>
        # cd /dev
        # ./MAKEDEV vty12                 # For 12 devices
      </verb>

      <p>Самым простым (и надёжным) способом активировать виртуальные
      консоли является перезагрузка.  Однако если вы вовсе не хотите этого
      делать, просто остановите X Window System и выполните (как
      администратор):

      <verb>
        kill -HUP 1
      </verb>

      <p>При этом требуется, чтобы вы полностью закрыли X Window, если она
      была запущена, до запуска этой команды.  Если вы это не сделаете,
      ваша система может повиснуть/заблокироваться после выполнения команды
      kill.

    <sect1>
      <heading>
        Как осуществляется доступ к виртуальным консолям из X?
      </heading>

      <p>Если на консоли запущена X Window, вы можете использовать
      комбинации клавиш, подобные Ctrl-Alt-F1, для переключения в режим
      работы с виртуальной консолью.  Заметьте, однако, что как только вы
      переключитесь из X Window в виртуальный терминал, вы можете
      использовать только Alt- клавиши для переключения в другой
      виртуальный терминал или снова в X Window.  Вам не нужно ещё нажимать
      клавишу Ctrl.  Если вы используете клавишу Ctrl при переключении в X,
      то в старых релизах вы может обнаружить, что ваша текстовая консоль
      осталась в режиме ``заблокированного control''. Нажмите эту клавишу
      ещё раз.

    <sect1>
      <heading>Как запустить XDM во время загрузки?</heading>

      <p>Есть две философские школы, проповедующие различные методы запуска
      <htmlurl url=
      "http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm"
      name="xdm">.  Последователи одного течения запускают xdm из <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?ttys" name="/etc/ttys">,
      используя приводимый пример, тогда как другие вставляют запуск xdm в
      скрипт <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?rc" 
      name="rc.local"> или <tt/X.sh/, поместив последний в каталог
      <tt>/usr/local/etc/rc.d</tt>.  Оба метода равноправны, и один из них
      может работать в ситуациях, с которыми не справляется другой и
      наоборот.  В обоих случая результат один и тот же: X выводит
      графическое приглашение login:.

      <p>Плюсом метода с использованием ttys является документрование того,
      на каком vty будет запущен X и то, что ответственность за перезапуск
      X-сервера при завершении сеанса работы лежит на процессе init.  Метод
      с использованием rc.local позволяет просто прекратить работу xdm, если
      при запуске X возникли какие-нибудь проблемы.

      <p>Из rc.local <tt/xdm/ должен быть запущен без аргументов, (то есть
      как даемон).  xdm должен быть запущен ПОСЛЕ запуска getty, иначе они
      будут конфликтовать, блокируя консоль.  Лучше всего выдержать паузу
      секунд на 10 и потом запустить xdm.

      <p>В предыдущей версии FAQ говорилось о необходимости добавления
      <tt/vt/ который будет использовать X, в файл
      <tt>/usr/X11R6/lib/X11/xdm/Xservers</tt>.  На самом деле делать это
      необязательно: X будет использовать первый свободный <tt/vt/, который
      сможет найти.

    <sect1>
      <heading>
        При запуске xconsole выдаётся сообщение ``Couldn't open console''.
      </heading>

      <p>Если вы запускаете <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=X"
      name="X"> через скрипт <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=startx"
      name="startx">, права на устройство /dev/console <tt /не/ изменяются,
      поэтому такие команды, как <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xterm"
      name="xterm -C"> и <htmlurl url=
      "http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xconsole"
      name="xconsole">, не будут работать.

      <p>Это зависит от прав доступа, установленных для консоли по умолчанию.
      В многопользовательской системе вовсе не нужно, чтобы любой
      пользователь мог выводить информацию на системную консоль.  Для
      пользователей, вошедших в систему через VTY, для решения этой проблемы
      существует файл <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?fbtab" name="fbtab">.

      <p>В общем, раскомментируйте строчку вида

      <verb>
        /dev/ttyv0 0600 /dev/console
      </verb>

      <p>в файле <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?fbtab(5)"
      name="/etc/fbtab">, и этого будет достаточно для того, чтобы всякий,
      кто вошёл в систему с <tt>/dev/ttyv0</tt>, будет иметь доступ к
      консоли.

    <sect1>
      <heading>Моя мышь PS/2 в X работает неправильно.</heading>

      <p>Вполне может быть, что ваша мышь и её драйвер
      рассинхронизировались.

      <p>В версиях 2.2.5 и более ранних это может произойти при переключении
      из X в виртуальный терминал и последующем возвращении в X.  Если эта
      проблема возникает достаточно часто, попробуйте добавить следующую
      строку в файл конфигурации ядра и перекомпилировать его.

      <verb>
        options PSM_CHECKSYNC
      </verb>

      <p>Если у вас нет опыта перекомпиляции ядра, обратитесь к <ref
      id="make-kernel" name="соответствующему разделу">.

      <p>С этой опцией проблем с синхронизацией мыши и её драйвера должно
      быть меньше.  Если, однако, эта проблема всё же осталась, щёлкните
      любой кнопкой мыши, не двигая ей, что заставит мышь и драйвер сделать
      попытку синхронизироваться.

      <p>Заметьте, что в некоторых системах эта опция может не работать и
      приводить к отключению функции ``tap'' устройства ALPS GlidePoint,
      подключенного к порту мыши PS/2.

      <p>В версиях 2.2.6 и выше, проверка синхронизации сделана гораздо лучше
      и включена в стандартный драйвер мыши PS/2.  Она должна работать даже с
      GlidePort.  (Так как код проверки стал стандартной функцией, опция
      PSM_CHECKSYNC в этих версиях нежоступна.)  Однако в редких случаях
      драйвер может ошибочно обнаруживать проблемы с синхронизацией, и вы
      будете видеть такие сообщения ядра:

      <verb>
        psmintr: out of sync (xxxx != yyyy)
      </verb>

      а также обнаружите, что мышь теперь работает неправильно.

      <p>Если это случится, отмените проверку согласования, установив
      значение флага для драйвера мыши PS/2 в 0x100.  Войдите в конфигуратор
      <em>UserConfig</em>, задав опцию ``<tt>-c</tt>'' в приглашении
      загрузчика:

      <verb>
        boot: -c
      </verb>

      Затем в командной строке <em>UserConfig</em> наберите:

      <verb>
        UserConfig> flags psm0 0x100
        UserConfig> quit
      </verb>

    <sect1>
      <heading>Моя мышь PS/2 от MouseSystems похоже, не работает.</heading>

      <p>Было несколько сообщений, что некоторые модели мышей PS/2 от
      MouseSystems работают только в режиме ``высокого разрешения''.  В
      других режимах курсор мыши постоянно прыгает в верхний левый угол
      экрана.

      <p>К сожалению, для версий 2.0.X и 2.1.X решения этой проблемы не
      существует.  Для версий от 2.2 до 2.2.5 приложите следующий патч к
      файлу <tt>/sys/i386/isa/psm.c</tt> и перестройте ядро.  Если у вас
      нет опыта перекомпиляции ядра, обратитесь к <ref
      id="make-kernel" name="соответствующему разделу">.

      <verb>
diff -u psm.c.orig psm.c
@@ -766,6 +766,8 @@
     if (verbose >= 2)
 	log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
 	    unit, i);
+    set_mouse_resolution(sc->kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc->kbdc); 	/* 1:1 scaling */
     set_mouse_mode(sc->kbdc);		/* stream mode */
      </verb>

      <p>Для версий 2.2.6 и выше укажите флаг 0x04 драйверу мыши PS/2
      для перевода её в режим высокого разрешения. Войдите в
      <em>UserConfig</em>, задав опцию ``<tt>-c</tt>'' в приглашении
      загрузчика:

      <verb>
        boot: -c
      </verb>

      Затем в командной строке <em>UserConfig</em> наберите:

      <verb>
        UserConfig> flags psm0 0x04
        UserConfig> quit
      </verb>

      <p>В предыдущем разделе описана возможная причина проблем с мышью.

   <sect1>
    <heading>
      При компиляции приложений для X <tt/imake/ не может найти файл
      <tt/Imake.tmpl/.  Где он находится?
    </heading>

    <p>Файл Imake.tmpl является частью пакета Imake, стандартного
    инструмента для построения X-приложений.  Он, также как ещё несколько
    заголовочных файлов, требуемых для построения X-приложений, содержится
    в дистрибутиве программ X.  Вы можете их проинсталлировать из sysinstall
    или взять из дистрибутива X. </p>

  </sect1> 

  <sect1>
   <heading>Как поменять местами кнопки мыши?</heading>
 
   <p>Поместите команду <tt/ xmodmap -e "pointer = 3 2 1"/ в один из ваших
   скриптов .xinitrc или .xsession.
   </p>

  </sect1>

  <sect1>
    <heading>
      Как установить экранную заставку и где такие заставки можно найти?
    </heading>

    <p>Перед самым выпуском релиза FreeBSD 3.1 в систему была добавлена
    возможность вывода &quot;заставки&quot; во время загрузки.  На данный
    момент экраны заставок должны быть 256-цветными файлами формата BMP
    <tt>*.BMP</tt> или ZSoft PCX (<tt>*.PCX</tt>).  Кроме того, они должны
    иметь разрешение 320x200 или меньше для работы со стандартными адаптерами
    VGA. Если вы включили поддержку VESA при компиляции ядра, то вы можете
    использовать экраны размером до 1024x768.  Заметьте, что поддержка VESA
    требует указание опции <tt>VM86</tt> при компиляции ядра.  Реальная
    поддержка VESA может быть вкомпилирована в ядро при указании опции
    <tt>VESA</tt> либо загружена в виде kld-модуля ядра во время начальной
    загрузки.</p>

    <p>Чтобы использовать заставку, вам нужно изменить файлы, управляющие
    процессом загрузки FreeBSD.  Формат этих файлов был изменён перед выпуском
    релиза FreeBSD 3.2, так что есть два способа загрузки экранных заставок:

    <itemize>
      <item>FreeBSD 3.1

       <p>Первым делом нужно найти экранную заставку в формате BMP. Релиз 3.1
       поддерживает заставки только в формате Windows.  После того, как вы
       нашли понравившуюся вам заставку, скопируйте её в файл
       <tt>/boot/splash.bmp</tt>.  Затем вам нужно поместить в файл
       <tt>/boot/loader.rc</tt> следующие строки:

       <verb>
           load kernel
           load -t splash_image_data /boot/splash.bmp
           load splash_bmp
           autoboot
       </verb>
      </item>

      <item>FreeBSD 3.2+

       <p>Кроме поддержки заставок в формате PCX, FreeBSD 3.2 включает более
       гибкую систему конфигурации процесса загрузки.  Если вы хотите, вы
       можете использовать метод, указанный выше для FreeBSD 3.1.  Если же
       вы хотите использовать формат PCX, замените <tt>splash_bmp</tt> на
       <tt>splash_pcx</tt>.  С другой стороны, если вы хотите использовать
       новую систему конфигурации процесса загрузоки , вам нужно создать файл
       <tt>/boot/loader.rc</tt>, содержащий следующие строки:

       <verb>
           include /boot/loader.4th
           start
       </verb>

       <p>и файл <tt>/boot/loader.conf</tt> со строками:

       <verb>
           splash_bmp_load="YES"
           bitmap_load="YES"
       </verb>
           
       <p>Здесь предполагается, что в качестве заставки вы используете файл 
       <tt>/boot/splash.bmp</tt>.  Если вы используете PCX-файл, скопируйте его
       под именем <tt>/boot/splash.pcx</tt>, создайте файл
       <tt>/boot/loader.rc</tt> как указано выше, и создайте файл
       <tt>/boot/loader.conf</tt>, который содержит следующее:

       <verb>
           splash_pcx_load="YES"
           bitmap_load="YES"
           bitmap_name="/boot/splash.pcx"
       </verb>
      </item>
    </itemize>

    <p>Теперь всё, что вам нужно - это сама заставка.  Поищите заставки в
    галерее по адресу <htmlurl url="http://www.cslab.vt.edu/~jobaldwi/splash/"
    name="http://www.cslab.vt.edu/~jobaldwi/splash/">.</p>

   </sect1>

  </sect>
