<!-- $FreeBSD$ -->
<!-- The FreeBSD Russian Documentation Project -->

  <sect>
    <heading>Системное администрирование<label id="admin"></heading>

    <sect1>
      <heading>Где расположены файлы конфигурации системы?</heading>

      <p>Для FreeBSD версий от 2.0.5R до 2.2.1R основным конфигурационным
      файлом является <tt>/etc/sysconfig</tt>.  Все параметры указываются
      здесь, а остальные конфигурационные файлы, такие, как
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?rc" name="/etc/rc">
      и <tt>/etc/netstart</tt> просто его используют.

      <p>Посмотрите файл <tt>/etc/sysconfig</tt> и измените значения
      переменных на соответствующие вашей системе.  В файле содержатся
      комментарии, описывающие смысл этих переменных и способ их задания.

      <p>В системах выше 2.2.1 и в 3.0 файл <tt>/etc/sysconfig</tt> сменил
      название на говорящее само за себя <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)" name="rc.conf">,
      синтаксис описания переменных был несколько улучшен.
      <tt>/etc/netstart</tt> тоже был переименован в <tt>/etc/rc.network</tt>,
      так что все конфигурационные файлы теперь можно перенести одной
      командой <tt><htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?cp"
      name="cp"> /usr/src/etc/rc* /etc</tt>.

      <p><tt>/etc/rc.local</tt> как обычно, можно использовать для запуска
      дополнительных местных служб типа <htmlurl
      url="http://www.FreeBSD.org/cgi/ports.cgi?^inn" name="INN"> или
      для настройки дополнительных параметров.

      <p>Файл <tt>/etc/rc.serial</tt> предназначен для инициализации
      коммуникационных адаптеров (например, установки характеристик
      работы последовательных портов итд).

      <p>Файл <tt>/etc/rc.i386</tt> предназначен для настройки специфичных
      для архитектуры Intel параметров, таких, как эмуляция iBCS2 или
      характеристик системной консоли ПК.

      <p>Начиная с версии 2.1.0R, вы можете иметь "местные" файлы
      автозапуска в каталоге, указанном в файле <tt>/etc/sysconfig</tt>
      (или <tt>/etc/rc.conf</tt>):

      <verb>
        # Location of local startup files.
        local_startup=/usr/local/etc/rc.local.d
      </verb>

      <p>Каждый файл, оканчивающийся на <tt/.sh/, будет запущен на выполнение
      в алфавитном порядке.

      <p>Если вам нужно добиться определённого порядка выполнения не
      меняя имён файлов, можно использовать схему, в которой для
      упорядочения используются цифры, предшествующие имени файла.

      <verb>
        10news.sh
        15httpd.sh
        20ssh.sh
      </verb>

      <p>Это может выглядеть безобразно (как SysV :-)), но это
      простой и понятный метод для добавления дополнительных служб без
      шаманства с редактированием <tt>/etc/rc.local</tt>.  Многие
      порты/пакаджи предполагают, что каталог
      <tt>/usr/local/etc/rc.d</tt> предназначен для размещения
      запускаемых при загрузке системы скриптов.

    <sect1>
      <heading>Как проще всего добавить пользователя?</heading>

      <p>Используйте команду <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?adduser" name="adduser">. 
      Для выполнения более сложных операций обратитесь к команде <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?pw" name="pw">.

      <p>Чтобы удалить пользователя, используйте команду <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?rmuser" name="rmuser">.

    <sect1>
      <heading>Как добавить в систему новый диск?</heading>

      <p>Обратитесь к Руководству по форматированию дисков на сервере
      <url url="../../tutorials/diskformat/" name="www.FreeBSD.org">.

    <sect1>
      <heading>
        Как использовать устройство для чтения сменных дисков?
      </heading>

      <p>Каким бы ни было это устройство, типа ZIP, EZ (или даже обычным
      дисководом, если вы хотите его использовать) или каким-то
      другим, как только оно будет установлено и распознано
      системой, и вы вставите в него картридж/дискету/что-там-ещё, всё
      будет выглядеть примерно одинаково.

      <p><label id="disklabel">(этот раздел опирается на <url
      url="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html"
      name="FAQ по устройствам ZIP"> Марка Мэйо (Mark Mayo))

      <p>Если это устройство ZIP или обычный дисковод, и у вас уже есть
      файловая система DOS на дискетах, то вы можете нспользовать команду
      типа:

      <verb>
        mount -t msdos /dev/fd0c /floppy
      </verb>

      <p>для обычных дискет, или

      <verb>
        mount -t msdos /dev/da2s4 /zip
      </verb>

      <p>для дискет ZIP со стандартной конфигурацией.

      <p>Для других дисков посмотрите их параметры с помощью
      <tt/fdisk/ или <tt>/stand/sysinstall</tt>.

      <p>Остальные примеры даны для привода ZIP на da2, третьем диске SCSI.

      <p>Если это дискета или сменный диск, который будет использоваться для
      обмена информацией с другими людьми, хорошой идеей будет помещение туда
      файловой системы BSD.  Вы получите поддержку длинных имён файлов,
      увеличение производительности по крайней мере в два раза и гораздо
      большую надёжность.  Первым делом вам снова будет нужно выполнить
      разбиение диска на разделы/файловые системы.  Вы можете
      воспользоваться утилитой <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?fdisk" name="fdisk"> либо
      <tt>/stand/sysinstall</tt>, а в случае небольшого диска, на котором
      не нужно располагать несколько операционных систем, просто сотрите
      таблицу разделов (слайсов) FAT и используйте разбиение на разделы BSD.

      <verb>
        dd if=/dev/zero of=/dev/rda2 count=2
        disklabel -Brw sd2 auto
      </verb>

      <p>Вы можете использовать disklabel или <tt>/stand/sysinstall</tt> для
      создания нескольких разделов BSD.  Вам наверняка придётся это сделать,
      если вы станете добавлять место для раздела подкачки на винчестере,
      хотя это не имеет отношения к устройствам типа ZIP.

      <p>В итоге вы должны создать новую файловую систему (в этом примере
      она занимает весь наш диск ZIP):

      <verb>
        newfs /dev/rda2c
      </verb>

      <p>и смонтировать её:

      <verb>
        mount /dev/da2c /zip
      </verb>

      <p>Хорошо ещё добавить строку типа следующей в файл
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?fstab"
      name="/etc/fstab">, чтобы в будущем можно было просто давать команду
      "mount /zip":

      <verb>
        /dev/da2c /zip ffs rw,noauto 0 0
      </verb>

    <sect1>
      <heading>Как смонтировать вторичный раздел DOS?</heading>

      <p>Вторичные разделы DOS находятся после ВСЕХ первичных разделов.
      Например, если раздел "E" является вторым разделом DOS на
      втором диске SCSI, вам нужно создать специальные файлы для пятого
      "слайса" в каталоге /dev, затем смонтировать /dev/da1s5:

      <verb>
        # cd /dev
        # ./MAKEDEV sd1s5
        # mount -t msdos /dev/da1s5 /dos/e
      </verb>

    <sect1>
      <heading>
        Можно ли смонтировать другие файловые системы?
      </heading>

      <p>Компакт-диски с файловой системой UFS от <bf/ Digital UNIX/
      могут быть замонтированы без всяких проблем.  Монтирование файловых
      систем Digital UNIX или других систем, поддерживающих UFS, может быть
      более сложным, в зависимости от особенностей разбиения диска конкретной
      операционной системой.

      <p><bf/ Linux/: Версии 2.2 и выше имеют поддержку разделов <bf/ext2fs/.
      За дополнительной информацией обратитесь к страницам справочника по
      команде <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?mount_ext2fs"
      name="mount_ext2fs">.

      <p><bf/ NT/: Существует драйвер, позволяющий под FreeBSD иметь
      доступ к NTFS в режиме "только для чтения".  Посмотрите учебник от
      Марка Овенса (Mark Ovens) по адресу <htmlurl
      url="http://www.users.globalnet.co.uk/~markov/ntfs_install.html"
      name="http://www.users.globalnet.co.uk/~markov/ntfs_install.html">.

      <p>Нас интересует любая дополнительная информация по этому вопросу.

    <sect1>
      <heading>
        Как можно использовать загрузчик NT для запуска FreeBSD?
      </heading>

      <p>Идея заключается в копировании первого сектора корневого раздела
      FreeBSD в файл, находящийся в разделе DOS/NT.  Предположим, что
      вы назвали этот файл <tt>c:&bsol;bootsect.bsd</tt> (по аналогии с
      <tt>c:&bsol;bootsect.dos</tt>), после чего можете отредактировать
      файл <tt>c:&bsol;boot.ini</tt>, чтобы он выглядел примерно так:

      <verb>
        [boot loader]
        timeout=30
        default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
        [operating systems]
        multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
        C:\BOOTSECT.BSD="FreeBSD"
        C:\="DOS"
      </verb>

      <p>Здесь предполагается, что DOS, NT, FreeBSD или другая операционная
      система были установлены в их соответствующие разделы fdisk на 
      <bf/одном и том же/ диске.  В моём случае DOS &amp; NT находятся
      на первом разделе fdisk, а FreeBSD на втором.  Я также проинсталлировал
      FreeBSD для загрузки с её раздела, а <bf/не/ из MBR.

      <p>Смонтируйте дискету в формате DOS (если вы используете NTFS) или
      раздел FAT, скажем, в каталог <tt>/mnt</tt>.

      <verb>
        dd if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1
      </verb>

      <p>Перезапустите DOS или NT.  Пользователи NTFS должны скопировать
      файл <tt/bootsect.bsd/ и/или <tt/bootsect.lnx/ с дискеты на диск
      <tt/C:&bsol;/.  Измените атрибуты (права) на файл <tt/boot.ini/
      следующим образом:

      <verb>
        attrib -s -r c:\boot.ini
      </verb>

      <p>Отредактируйте этот файл, добавив соответствующие строки из
      примерного <tt/boot.ini/ выше, и восстановите атрибуты:

      <verb>
        attrib +s +r c:\boot.ini
      </verb>

      <p>Если FreeBSD загружается из MBR, восстановите его командой DOS
      ``<tt/fdisk/'' после того, как переконфигурировали их для загрузки с
      их родных разделов.

    <sect1>
      <heading>
        Как загрузить FreeBSD и Linux с помощью LILO?
      </heading>

      <p>Если у вас установлены FreeBSD и Linux на одном и том же диске,
      следуйте указаниям по установке LILO о загрузке не-Linux операционных
      систем.  Они сводятся к следующему:

      <p>Загрузите Linux, и добавьте слеующие строки в файл
      <tt>/etc/lilo.conf</tt>:
      <verb>
      other=/dev/hda2
	      table=/dev/hda
	      label=FreeBSD
      </verb>
      (здесь вы предполагаем, что слайс с FreeBSD известен Linux как
      <tt>/dev/hda2</tt>; измените эту строку в соответствии с вашей 
      конфигурацией).  Затем достаточно будет запустить <tt>lilo</tt>,
      войдя в систему администратором.

      <p>Если FreeBSD располагается на другом диске, вам нужно добавить
      строчку ``<tt>loader=/boot/chain.b</tt>'' в конфигурационный файл
      LILO.  Например:
      <verb>
      other=/dev/dab4
	      table=/dev/dab
	      loader=/boot/chain.b
	      label=FreeBSD
      </verb>

      <p>В некоторых случаях для успешной загрузки со второго диска вам
      может потребоваться указать номер диска BIOS загрузчику FreeBSD.
      Например, если диск SCSI с FreeBSD определяется BIOS как диск 1,
      в приглашении загрузчика FreeBSD нужно указать:
      <verb>
      Boot: 1:da(0,a)/kernel
      </verb>

      <p>Во FreeBSD 2.2.5 и выше вы можете настроить <htmlurl 
      url="http://www.FreeBSD.org/cgi/man.cgi?boot(8)" name="boot(8)">
      на автоматическое принятие таких параметров во время загрузки.

      <p>В документе <htmlurl 
      url="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html"
      name="Linux+FreeBSD mini-HOWTO"> содержится много информации,
      касающейся взаимодействия FreeBSD и Linux.

    <sect1>
      <heading>
        Как загрузить FreeBSD и Linux с помощью BootEasy?
      </heading>

      <p>Установите LILO в начало загрузочного раздела Linux, а не в
      Master Boot Record.  После этого можно запустить LILO из BootEasy.

      <p>Это рекомендуется сделать в любом случае при одновременном
      использовании Windows-95 и Linux, чтобы упростить восстановление
      работоспособности Linux после переинсталляции Windows95 (которая
      является Недоброжелательной Операционной Системой и не терпит
      присутствия других операционных систем в Master Boot Record).

    <sect1>
      <heading>
        Не угрожает ли режим ``dangerously dedicated'' моему здоровью?
      </heading>

      <p><label id="dedicate">В процессе установки вы можете выбрать два
      различных метода разбиения вашего диска.  По умолчанию это делается
      в режиме совместимости с другими операционными системами на этой же
      машине с использованием записей в таблице разделов fdisk (то, что
      называется ``слайсом'' во FreeBSD), со слайсом (разделом), выделенным
      FreeBSD.  Опционально, вы можете выбрать установку менеджера
      загрузки для переключения между операционными системами.  Либо вы
      можете выделить диск полностью под FreeBSD, не заботясь о совместимости
      с другими операционными системами.

      <p>Почему же этот режим называется ``dangerous''? Дело в том, что
      диск в этом режиме не будет содержать того, что обычные утилиты для
      ПК распознают как таблицу разделов.  В зависимости от того, насколько
      хорошо они написаны, они могут сообщить вам об этом, как только
      обнаружат такой диск, или, что гораздо хуже, могут запортить загрузчик
      BSD, даже не спрашивая и не сообщая об этом.  К тому же известно, что
      разметка диска в режиме ``dangerously dedicated'' вводит в заблуждение
      BIOS многих производителей, включая AWARD (которые используются в
      компьютерах HP Netserver, Micronics и многих других) и Symbios/NCR
      (производителя популярных SCSI-контроллеров серии 53C8xx).  И это не
      полный список, есть ещё другие производители.  Симптомами подобных
      проблем является сообщение "read error", выводимое загрузчиком FreeBSD,
      когда он не может найти сам себя, а также зависания системы при загрузке.

      <p>Тогда зачем вообще нужен этот режим?  Он экономит всего лишь
      несколько килобайт дискового пространства и может вызвать серьёзные 
      проблемы при новой инсталляции.  Причиной появления этого режима
      является желание избежать появления одной из самых распространённых
      проблем, с которой сталкиваются новички - соответствие параметров
      BIOS и реальных параметров диска.

      <p>``Параметры'' диска являются устаревшей концепцией, но она лежит
      в основе работы BIOS с диском.  Когда программа установки FreeBSD
      создаёт слайсы, она записывает их расположение в соответствии с тем,
      как с ними будет работать BIOS.  Если это делается неправильно, вы не
      сможете выполнить загрузку системы.

      <p>Режим ``dangerously dedicated'' пытается обойти это, упрощая решение
      данной проблемы.  Иногда он делает это правильно.  Однако это значит,
      что его нужно использовать только как последнюю альтернативу - есть
      способы получше, решающие проблему в 99 случаях из 100.

      <p>Итак, как избежать использования режима ``DD'' во время установки?
      Сначала запишите параметры диска, которые сообщает BIOS.  Вы можете
      выяснить это, заставив ядро вывести эти параметры при загрузке, указав
      ``-v'' в приглашении ``boot:'', или используя ``boot -v'' в загрузчике.
      Перед тем, как запустится программа установки, ядро выведет параметры,
      используемые BIOS.  Не волнуйтесь - подождите запуска программы
      установки, а затем воспользуйтесь скроллингом, чтобы посмотреть
      значения этих параметров.  Как правило, BIOS нумерует диски в том же
      порядке, что и FreeBSD, сначала IDE, затем SCSI.
       
      <p>Когда вы разбиваете диск на слайсы, проверьте, что параметры диска,
      выводимые в окне программы FDISK, корректны (то есть они соответствуют
      параметрам BIOS); если это не так, воспользуйтесь командой ``g'', чтобы
      их исправить.  Вы можете это сделать, если на диске нет абсолютно
      ничего или если этот диск был перенесён с другой системы.  Заметьте,
      что это касается только загрузочного диска; FreeBSD прекрасно разберётся 
      с остальными дисками, которые могут у вас быть.

      <p>Как только вы добились соответствия параметров диска в BIOS и
      FreeBSD, скорее всего, проблем у вас больше не будет, и использовать
      режим ``DD'' не потребуется.  Если, однако, страшной сообщение
      ``read error'' продолжает появляться при загрузке, самое время
      перекреститься и попробовать этот режим - вам больше нечего терять.
     
      <p>Чтобы вернуть диск из режима ``dangerously dedicated'' к
      нормальному режиму использования, есть два способа. Первый заключается
      в том, что вы записываете достаточное количество байтов NULL поверх
      MBR, чтобы любой инсталлятор думал, что это чистый диск. Это можно
      сделать, например, командой

      <verb>
        dd if=/dev/zero of=/dev/rda0 count=15
      </verb>

      <p>Другой способ - недокументированной командой DOS

      <verb>
        fdisk /mbr
      </verb>

      <p>проинсталлировать новую MBR, удалив загрузчик BSD.

    <sect1>
      <heading>
        Как добавить дополнительную виртуальную память?
      </heading>

      <p>Наилучший способ - увеличить размер раздела подкачки, может быть,
      добавив для этого ещё один диск.  Общим правилом является выбор
      размера виртуальной памяти, в два раза превышающий объём физической
      памяти.  Однако, если у вас очень мало физической памяти, этот объём
      гораздо больше.  Хорошей практикой является задание достаточного
      объёма виртуальной памяти в ожидании добавления физической памяти,
      чтобы потом не испытывать трудностей.

      <p>Перенос виртуальной памяти на отдельный диск увеличивает
      быстродействие системы по сравнению с добавлением виртуальной памяти
      на том же диске.  Например, компиляция исходных текстов происходит
      быстрее, если они находятся не на том же диске, что и раздел подкачки.
      Особенно это заметно для дисков SCSI.

      <p>Если у вас имеется несколько дисков, размещение раздела подкачки
      на каждом из них, даже на рабочем диске, обычно бывает полезно.
      Как правило, каждый быстрый диск в вашей системе должен иметь раздел
      подкачки.  FreeBSD поддерживает по умолчанию до 4 устройств подкачки с
      чередованием.  При задании нескольких разделов подкачки вам захочется
      сделать их одинакового размера, однако иногда первичный раздел подкачки
      делается несколько больше для того, чтобы он мог поместить аварийный
      образ ядра.  Размер вашего первичного раздела подкачки должен по крайней 
      мере быть равным объёму физической памяти, чтобы поместить аварийный
      образ ядра.

      <p>Диски IDE не позволяют реализовать одновременный доступ к обоим
      дискам по одному каналу (FreeBSD не поддерживает режим 4, так что
      весь ввод/вывод для дисков IDE ``программируется'').  Однако я всё
      равно советую перенести раздел подкачки на отдельный диск.  Диски
      достаточно дешёвы, и экономить тут не на чем.
      
      <p>Использование NFS для размещения раздела подкачки рекомендуется
      только в случае, если у вас нет локального диска.  Подкачка поверх
      NFS медленна и неэффективна в релизах FreeBSD до 4.x, хотя достаточно
      быстра в релизах 4.0 и выше.  Кроме того, её скорость будет ограничена
      реальной пропускной способностью сети и это даст дополнительную нагрузку
      на NFS-сервер.

      <p>Вот пример vn-файла подкачки размером 64Мб (<tt>/usr/swap0</tt>,
      хотя, конечно, вы можете выбрать любое другое имя.

      <p>Удостоверьтесь, что ядро откомпилировано со строкой

      <verb>
        pseudo-device   vn 1   #Vnode driver (turns a file into a device)
      </verb>

      <p>в конфигурационном файле.  Ядро GENERIC её содержит

      <enum>
        <item>создайте vn-устройство

        <verb>
          cd /dev
          sh ./MAKEDEV vn0
        </verb>

        <item>создайте файл подкачки (<tt>/usr/swap0</tt>)

        <verb>
          dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
        </verb>

        <item>Установите корректные права на файл (<tt>/usr/swap0</tt>)

        <verb>
          chmod 0600 /usr/swap0
        </verb>
 
        <item>Включите использование файла подкачки в <tt>/etc/rc.conf</tt>

        <verb>
          swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </verb>

        <item>перезагрузите машину
      </enum>

      <p>Чтобы включить использование файла подкачки немедленно, наберите

      <verb>
        vnconfig -ce /dev/vn0c /usr/swap0 swap
      </verb>

    <sect1>
      <heading>У меня проблемы с установкой принтера.</heading>

      <p>Обратитесь к соответствующему <url url="../../handbook/printing.html"
      name="разделу"> Руководства, посвящённому печати.  В нём описаны
      решения большинства ваших проблем.

    <sect1>
      <heading>Раскладка клавиатуры неверна.</heading>

      <p>Программа kbdcontrol имеет параметр, задающий файл раскладки.
      Файлы раскладок находятся в каталоге
      <tt>/usr/share/syscons/keymaps</tt>.  Выберите соответствующий вашей
      системе и загрузите его.

      <verb>
        kbdcontrol -l uk.iso
      </verb>

      <p>Программа <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?kbdcontrol" name="kbdcontrol">
      предполагает использование каталога <tt>/usr/share/syscons/keymaps</tt>
      и расширения <tt/.kbd/.

      <p>Это может быть настроено в файле <tt>/etc/sysconfig</tt> (или
      <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)"
      name="rc.conf">).  Обратитесь к соответствующим комментариям в этом
      файле.

      <p>В системах 2.0.5R и выше, всё, относящееся к знакогенератору,
      раскладке клавиатуры, находится в каталоге
      <tt>/usr/share/examples/syscons</tt>.

      <p>На данный момент поддерживаются следующие раскладки:

      <itemize>
        <!-- generate by `kbdmap -p' -->
        <item>Belgian ISO-8859-1 
        <item>Brazilian 275 keyboard Codepage 850 
        <item>Brazilian 275 keyboard ISO-8859-1 
        <item>Danish Codepage 865 
        <item>Danish ISO-8859-1 
        <item>French ISO-8859-1 
        <item>German Codepage 850 
        <item>German ISO-8859-1 
        <item>Italian ISO-8859-1 
        <item>Japanese 106 
        <item>Japanese 106x 
        <item>Latin American 
        <item>Norwegian ISO-8859-1 
        <item>Polish ISO-8859-2 (programmer's) 
        <item>Russian Codepage 866 (alternative) 
        <item>Russian koi8-r (shift) 
        <item>Russian koi8-r 
        <item>Spanish ISO-8859-1 
        <item>Swedish Codepage 850 
        <item>Swedish ISO-8859-1 
        <item>Swiss-German ISO-8859-1 
        <item>United Kingdom Codepage 850 
        <item>United Kingdom ISO-8859-1 
        <item>United States of America ISO-8859-1 
        <item>United States of America dvorak 
        <item>United States of America dvorakx 
      </itemize>

    <sect1>
      <heading>Не получается заставить работать дисковые квоты.</heading>

      <p>
      <enum>
        <item>Не включайте квотирование на '/',

        <item>Помещайте файл с квотами в ту файловую систему, которую
        он обслуживает, то есть:

        <verb>
          ФС      ФАЙЛ КВОТ
          /usr    /usr/admin/quotas
          /home   /home/admin/quotas
          ...
        </verb>
      </enum>

    <sect1>
      <heading>Что не так с устройством ccd?</heading>

      <p>Симптом выглядит так:

      <verb>
        # ccdconfig -C
        ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
        #
      </verb>

      <p>Это сообщение обычно выдаётся, когда вы пытаетесь объединить разделы
      'c', по умолчанию имеющие тип 'unused'.  Драйвер ccd требует, чтобы
      используемые разделы имели тип FS_BSDFFS.  Отредактируйте метки тех
      дисков, которые вы хотите использовать, сменив типы разделов на 
      '4.2BSD'.

    <sect1>
      <heading>
        Почему невозможно отредактировать метку диска ccd?
      </heading>

      <p>Симптом выглядит так:

      <verb>
        # disklabel ccd0
        (здесь выводится информация о диске, пробуем отредактировать метку)
        # disklabel -e ccd0
        (редактирование, сохранение, выход)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
        #
      </verb>

      <p>Это происходит из-за того, что метка диска, возвращаемая ccd, на
      самом деле 'ненастоящая', не соответствующая реально располагающейся
      на диске.  Вы можете решить эту проблему, явно записав эту метку
      обратно следующим образом:

      <verb>
        # disklabel ccd0 > /tmp/disklabel.tmp
        # disklabel -Rr ccd0 /tmp/disklabel.tmp
        # disklabel -e ccd0
        (теперь это будет работать)
      </verb>

    <sect1>
      <heading>Поддерживает ли FreeBSD вызовы IPC из System V?</heading>

      <p>Да, FreeBSD поддерживает IPC из System V, а именно совместно
      используемую память, сообщения и семафоры.  Чтобы они работали, вам
      нужно добавить следующие строки в файл конфигурации ядра.

      <verb>
        options    SYSVSHM
        options    "SHMMAXPGS=64"   # 256Kb of sharable memory
        options    SYSVSEM          # enable for semaphores
        options    SYSVMSG          # enable for messaging
      </verb>

      <p>Перекомпилируйте и проинсталлируйте ядро.

      <p><bf/ЗАМЕЧАНИЕ:/ Вам может потребоваться увеличить значение
      константы SHMMAXGS на что-то большее, типа 4096 (16М!), если вы
      собираетесь ипользовать GIMP.  256Кб достаточно для работы X11R6.

    <sect1>
      <heading>
        Как настроить sendmail для доставки почты по UUCP?
        <label id="uucpmail">
      </heading>

      <p>Конфигурация sendmail, поставляемая с FreeBSD, предназначена для
      сайтов, которые имеют непосредственный выход в Internet.  Сайты,
      которым требуется обмениваться почтой по UUCP, должны использовать
      другой конфигурационный файл.

      <p>Ковыряние в файле <tt>/etc/sendmail.cf</tt> вручную - это занятие
      для пуристов (и мазохистов).  Восьмая версия sendmail поставляется
      с новой системой генерации конфигурационных файлов с использованием
      препроцессора <htmlurl url="http://www.FreeBSD.org/cgi/man.cgi?m4"
      name="m4">, в которой ручная конфигурация перенесена на более высокий
      уровень абстракции.  Используйте конфигурационные файлы в каталоге

      <verb>
        /usr/src/usr.sbin/sendmail/cf
      </verb>

      <p>Если вы не собираетесь инсталлировать все исходные тексты системы,
      специально для вас конфигурационные файлы sendmail выделены в отдельный
      дистрибутив.  Если вы имеете смонтированный компакт-диск, выполните
      такую команду:

      <verb>
        cd /usr/src
        tar -xvzf /cdrom/dists/src/ssmailcf.aa
      </verb>

      <p>Не волнуйтесь, эти файлы занимают всего лишь несколько сотен
      килобайт.  Файл <tt>README</tt> в каталоге <tt>cf</tt> может быть
      использован как начальное введение в конфигурацию m4.

      <p>Для доставки почты по UUCP лучше всего использовать
      <em>mailertable</em>.  В этом файле содержится база данных,
      используемая sendmail при маршрутизации почты.

      <p>Первым делом создайте ваш файл <tt>.mc</tt>.  Для таких файлов
      предназначен каталог <tt>/usr/src/usr.sbin/sendmail/cf/cf</tt>.
      Посмотрите в нём, там есть уже несколько примеров.  Положим, что
      вы назвали ваш файл <tt>foo.mc</tt>, всё, что вам нужно для
      перобразования его в нормальный <tt>sendmail.cf</tt>, это:

      <verb>
        cd /usr/src/usr.sbin/sendmail/cf/cf
        make foo.cf
        cp foo.cf /etc/sendmail.cf
      </verb>

      <p>Типичный файл <tt>.mc</tt> выглядит примерно так:

      <verb>
        include(`../m4/cf.m4')
        VERSIONID(`Your version number')
        OSTYPE(bsd4.4)

        FEATURE(nodns)
        FEATURE(nocanonify)
        FEATURE(mailertable)

        define(`UUCP_RELAY', your.uucp.relay)
        define(`UUCP_MAX_SIZE', 200000)

        MAILER(local)
        MAILER(smtp)
        MAILER(uucp)

        Cw    your.alias.host.name
        Cw    youruucpnodename.UUCP
      </verb>

      <p>Параметры <em>nodns</em> и <em>nocanonify</em> подавляют
      использование DNS в процессе доставки.  Строка <em>UUCP_RELAY</em>
      может понадобиться только в очень странных случаях, не
      спрашивайте о них.  Просто поместите здесь имя хоста Internet,
      который может обрабатывать адреса с псевдо-доменами .UUCP; в
      большинстве случаев достаточно поставить сюда имя почтового шлюза
      вашего провайдера.

      <p>Как только вы сгенерируете конфигурационный файл, вам понадобится
      <tt>/etc/mailertable</tt>.  Типичный пример такого файла:

      <verb>
        #
        # makemap hash /etc/mailertable.db < /etc/mailertable
        #
        horus.interface-business.de   uucp-dom:horus
        .interface-business.de        uucp-dom:if-bus
        interface-business.de         uucp-dom:if-bus
        .heep.sax.de                  smtp8:%1
        horus.UUCP                    uucp-dom:horus
        if-bus.UUCP                   uucp-dom:if-bus
        .                             uucp-dom:sax
      </verb>

      <p>Как видите, это часть реально существующего файла.  Первые три
      строки описывают особые случаи, когда почта, направленная на 
      некоторые домены, будет посылаться не по стандартному маршруту, а на
      некоторую близлежащую UUCP-систему для `сокращения' маршрута доставки.
      Следующая строка описывает, что почта на локальный домен в сети
      Ethernet может быть доставлена по SMTP.  В конце файла описаны
      близлежащие системы UUCP в псевдо-домене .UUCP, что позволит
      выполнять правильную доставку почты на адреса
      ``uucp-система!получатель''.  В последней строке всегда присутствует
      одна точка, соответствующая всем остальным доменам, с доставкой по
      UUCP на блишнюю систему UUCP, который является универсальный почтовым
      шлюзом во весь остальной мир.  Все имена узлов после <tt>uucp-dom:</tt>
      должны быть реально существующими узлами UUCP, что можно проверить
      командой <tt>uuname</tt>.

      <p>Как напоминание о том, что этот файл должен быть преобразован
      в формат базы данных DBM перед использованием, командная строка,
      выполняющая это действие, помещена как комментарий в начало
      файла.  При изменении mailertable всегда нужно выполнять эту команду.

      <p>Последняя подсказка: если вы не уверены в правильности настройки
      маршрутизаци почты, используйте sendmail с опцией <tt>-bt</tt>.  Она
      переводит sendmail в режим <em>проверки адресов</em>; введите ``0 '',
      а затем адрес, который вы хотите протестировать на правильность
      маршрутизации.  В последней строке будут указаны используемый
      почтовый агент, хост получателя, с которым будет работать этот агент,
      и (может быть преобразованный) адрес.  Выход их этого режима
      осуществляется по Control-D.

      <verb>
        j@uriah 191% sendmail -bt
        ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
        Enter <ruleset> <address>
        > 0 foo@interface-business.de
        rewrite: ruleset  0   input: foo @ interface-business . de
        ...
        rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
        < @ interface-business . de >
        > ^D
        j@uriah 192%
      </verb>

    <sect1>
      <heading>
        Как настроить почту при коммутируемом соединении с Internet?
        <label id="ispmail">
      </heading>

      <p>Если вам выделен статический IP-адрес, вам не нужно ничего
      менять.  Установите имя вашего хоста в соответствии с выделенным
      именем DNS, а sendmail сделаёт всё остальное.

      <p>Если ваш IP-адрес выделяется динамически при коммутируемом 
      соединении по <bf/ppp/ с Internet, может быть, вам выделен почтовый
      ящик на сервере провайдера.  Предположим, что домен вашего
      провайдера называется <tt/myISP.com/, а ваше имя пользователя
      <tt/user/.  Также положим, что вы назвали вашу машину <tt/bsd.home/ и
      что ваш провайдер сказал, что вы должнв использовать
      <tt/relay.myISP.com/ как почтовый шлюз.
 
      <p>Чтобы забирать почту из вашего почтового ящика, вам нужно установить
      соответствующий агент.  Хорошим агентов является <bf/fetchmail/, так
      как он поддерживает много различных протоколов.  Обычно провайдеры
      предлагают POP3.  Если вы используете user-ppp, вы можете
      автоматически забирать вашу почту при установлении соединения с
      Internet, добавив такую строку в <tt>/etc/ppp/ppp.linkup</tt>:

      <verb>
        MYADDR:
          !bg su user -c fetchmail
      </verb>

      <p>Если вы используете <tt>sendmail</tt> (как показано ниже) для 
      доставки почты для внешних пользователей, поместите команду

      <verb>
	  !bg su user -c "sendmail -q"
      </verb>

      после вышеуказанной строки.  Это заставит sendmail обработать вашу
      очередь почтовых сообщений, как только будет осуществлено подключение
      к сети.
 
      <p>Предположим, что вы имеет учётную запись для <tt/user/ на машине
      <tt/bsd.home/.  В домашнем каталоге пользователя <tt/user/ на машине
      <tt/bsd.home/ создайте такой файл <tt/.fetchmailrc/:

      <verb>
        poll myISP.com protocol pop3 fetchall pass MySecret;
      </verb>

      <p>Излишним будет напоминание о том, что этот файл никому не должен
      быть доступен для чтения, кроме пользователя <tt/user/, потому что
      он содержит пароль <tt/MySecret/ доступа к почтовому ящику.

      <p>Чтобы посылать почту с правильным заголовком <bf/from:/, вы должны
      указать программе sendmail использовать <tt/user@myISP.com/, а не
      <tt/user@bsd.home/.  Вам может понадобиться настроить sendmail для
      посылки всей почты через <tt/relay.myISP.com/, чтобы убыстрить её
      передачу.

      <p>Следующий файл <tt/.mc/ должен подойти:

      <verb>
        VERSIONID(`bsd.home.mc version 1.0')
        OSTYPE(bsd4.4)dnl
        FEATURE(nouucp)dnl
        MAILER(local)dnl
        MAILER(smtp)dnl
        Cwlocalhost
        Cwbsd.home
        MASQUERADE_AS(`myISP.com')dnl
        FEATURE(allmasquerade)dnl
        FEATURE(masquerade_envelope)dnl
        FEATURE(nocanonify)dnl
        FEATURE(nodns)dnl
        define(SMART_HOST, `relay.myISP.com')
        Dmbsd.home
        define(`confDOMAIN_NAME',`bsd.home')dnl
        define(`confDELIVERY_MODE',`deferred')dnl
      </verb>

      <p>В предыдущем разделе описано, как преобразовать файл <tt/.mc/ в
      <tt/sendmail.cf/.  И не забудьте перезапустить sendmail после
      обновления sendmail.cf.

   <sect1>
    <heading>Ой! Я забыл пароль администратора!</heading>

    <p>Без паники!  Просто перезапустите систему, наберите -s в приглашении
    Boot: для входа в однопользовательский режим.  На вопрос об используемой
    оболочке нажмите ENTER.  На приглашение # введите <tt>mount -u /</tt>,
    чтобы перемонтировать корневую файловую систему в режиме чтения/записи,
    затем выполните команду <tt/mount -a/ для монтирования всех файловых
    систем.  Запустите команду <tt/passwd root/, чтобы сменить пароль
    администратора и затем <tt/exit/ для продолжения загрузки.  
    
  <sect1>
   <heading>
     Как запретить перезагрузку по клавишам Control-Alt-Delete?
   </heading>

    <p>Отредактируйте используемый вами для консоли файл раскладки
    клавиатуры, заменив ключевые слова <tt/boot/ на <tt/nop/.  Раскладка
    по умолчанию находится в файле 
    <tt>/usr/share/syscons/keymaps/us.iso.kbd</tt>. 
    Вам может потребоваться явно указать в файле <tt>/etc/rc.conf</tt>
    загрузку этой раскладки, чтобы она действительно поменялась.  Конечно,
    если в вашей стране вы используете другую раскладку, вы должны 
    отредактировать именно её.

  <sect1>
    <heading>Как преобразовать текстовые файлы DOS в формат UNIX?</heading>

     <p>Используйте такую команду:

<verb>
perl -i.bak -npe 's/\r\n/\n/g' file ...
</verb>

     <p>где file - это имя файла(ов) для преобразования.  Преобразование
     делается в том же самом файле, оригинальные файлы сохраняются с
     расширением .bak.

     <p>Это преобразование также можно выполнить с помощью команды <htmlurl
     url="http://www.FreeBSD.org/cgi/man.cgi?tr" name="tr">:

<verb>
tr -d '\r' &lt; dos-text-file &gt; unix-file
</verb>

     <p>где dos-text-file - это имя файла, содержащего текст DOS, а
     в файл unix-file будет помещён уже преобразованный текст.  Этот способ
     может работать гораздо быстрее, чем при использовании perl.
     
    <sect1>
      <heading>Как прервать процесс по имени?</heading>

      <p>Используйте команду <htmlurl
      url="http://www.FreeBSD.org/cgi/man.cgi?killall" name="killall">.

    <sect1>
      <heading>
        Почему su выдаёт сообщение о том, что я не вхожу в root ACL?
      </heading>

      <p>Эта ошибка выдаётся распределённой системой аутентификации Kerberos.
      Эта ошибка не фатальна, однако это раздражает.  Вы можете запустит su
      с ключом -K либо деинсталлировать Kerberos, как описано в следующем
      разделе.

    <sect1>
      <heading>Как деинсталлировать Kerberos?</heading>

      <p>Чтобы убрать Kerberos из системы, переинсталлируйте дистрибутив bin
      того релиза, который у вас запущен.  Если у вас есть CDROM, вы можете
      смонтировать компакт-диск (положим, в каталог /cdrom) и выполнить
      команду
    
      <verb>
        cd /cdrom/bin
        ./install.sh
      </verb>

    <sect1>
      <heading>Как добавить в систему дополнительные псевдотерминалы?</heading>

      <p>Если у вас много пользователей, работающий в сеансах telnet, ssh, X
      или в screen, вам можете столкнуться с проблемой нехватки
      псевдотерминалов.  Их количество можно уыеличить следующим образом:

      <enum>
      <item>Откомпилируйте и инсталлируйте новое ядро, в конфигурационный
      файл которого входит строка

      <verb>
        pseudo-device pty 256
      </verb>

      <item>Выполните команду

      <verb>
        # cd /dev
        # ./MAKEDEV pty{1,2,3,4,5,6,7}
      </verb>

      <p>для создания 256 дополнительных файлов устройств для новых терминалов.

      <item>Отредактируйте файл <tt>/etc/ttys</tt>, добавив по строке для
      каждого из 256 терминалов.  Они должны соответствовать формату
      существующих строк, то есть должны выглядеть как

      <verb>
        ttyqc none network
      </verb>

      <p>Порядок назначения букв при записи в виде регулярного выражения имеет
      вид <tt>tty[pqrsPQRS][0-9a-v]</tt>.

      <item>Теперь осталось только перезапустить систему с новым ядром.
      </enum>

    <sect1>
      <heading>Не получается создать устройство snd0!</heading>

      <p>Команда для создания устройств для звуковых адаптеров выглядит
      следующим образом:
      <verb>
        # cd /dev
        # sh MAKEDEV snd0
      </verb>

      <p>Однако при этом устройства с именем <tt>/dev/snd0</tt> не создаётся.
      Вместо этого создаются устройства <tt>mixer0</tt>, <tt>audio0</tt>,
      <tt>dsp0</tt> и другие.  Запуск этой команды необходим для добавления
      звуковых устройств.

    <sect1>
      <heading>
        Как перечитать содержимое /etc/rc.conf и перестартовать /etc/rc
        без перезагрузки системы?
      </heading>

      <p>Перейдите в однопользовательский режим, а затем возвратитесь обратно
      в многопользовательский.

      На консоли выполните следующее:

      <verb>
        # shutdown now
        (Замечание: без -r или -h)

        # return
        # exit
      </verb>
      
    <sect1>
      <heading>Что означает термин sandbox (песочница)?</heading>

      <p>&quot;Sandbox&quot; - это термин, используемый при обеспечении
      безопасности.  Он имеет два значения:

      <itemize>
       <item>
         <p>Процесс, помещённый внутрь некоторых виртуальных стен, которые
         предназначены для того, чтобы предотвратить взлом всей системы в
         результате взлома этого конкретного процесса.

         <p>Говорится, что процесс может "играть" в границах этих стен. Что бы
         этот процесс ни делал, он эти стены разрушить не может, поэтому вам
         не нужен его особый аудит, чтобы с уверенностью сказать, насколько
         его работа безопасна для системы.

         <p>Стеной может служить, например, идентификатор пользователя. Вот
         определение, даваемое на страницах справочника по named и часто
         используемое при обсуждении безопасности систем.

         <p>Рассмотрим, например, службу 'ntalk' (смотрите /etc/inetd.conf).
         Раньше эта служба запускалась с идентификатором пользователя root,
         а сейчас - tty.  Пользователь tty - это та песочница, которая
         осложняет взлом системы через ntalk посредством использования этого
         идентификатора пользователя.

       </item>
 
       <item>
         <p>Процесс, помещённый внутрь симулируемой машины. Это даёт больший
         уровень безопасности.  В общем это означает, что некто, взломавший
         процесс, может думать. что может сломать и систему в целом, однако
         фактически может сломать только симулятор этой машины и не может
         модифицировать никаких реальных данных.
        
         <p>Самым распространённым способом достигнуть такого результата
         является построение имитирующего окружения в каталоге и затем запуск
         процессов и этом каталоге через chroot (т.е. задав этот каталог в
         качестве "/" для этого процесса, а не реальный "/" всей системы).

         <p>Другим часто используемым методом является монтирование низлежащей
         файловой системы в режиме "только для чтения" и затем создание
         уровня фаловой системы поверх неё, что даёт процессу видимость
         доступа по записи на ту файловую систему.  Процесс будет полагать,
         что может записывать в те файлы, но это будет единственный процесс,
         который увидит результат &dash; другие процессы не будут этого делать,
         ни в коем случае.

         <p>Попытка сделать такой тип песочницы настолько прозрачна, что
         пользователь (или взломщик) даже не поймёт, что он в ней находится.
       </item>
      </itemize>

      <p>В UNIX реализованы два типа песочниц. Один на уровне процесса, и один
      на уровне идентификаторов пользователей.

      <p>Каждый процесс в UNIX полностью защищён от других процессов. Никакой
      процесс не может модифицировать адресное пространство другого процесса.
      Это отличается от Windows, где процесс может легко записать что-либо в
      адресное пространство другого процесса, что приводит к аварийным
      ситуациям. 

      <p>В UNIX каждым процессом владеет некоторый идентификатор пользователя.
      Если этот пользователь не root, от ограждает процесс от других, 
      владельцами которых являются другие пользователи.  Этот идентификатор
      используется также для защиты данных на диске.

  </sect>
