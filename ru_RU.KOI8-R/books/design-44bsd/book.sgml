<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/design-44bsd/book.sgml,v 1.6 2001/07/17 07:57:53 phantom Exp $

     Original revision: 1.5
-->

<!DOCTYPE book PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN">
%man;
]>

<book>
  <bookinfo>
    <title>Архитектура и реализация операционной системы 4.4BSD</title>

    <authorgroup>
      <author>
	<firstname>Marshall</firstname>
	<othername>Kirk</othername>
	<surname>McKusick</surname>
      </author>

      <author>
	<firstname>Keith</firstname>
	<surname>Bostic</surname>
      </author>

      <author>
	<firstname>Michael</firstname>
	<othername>J.</othername>
	<surname>Karels</surname>
      </author>

      <author>
	<firstname>John</firstname>
	<othername>S.</othername>
	<surname>Quarterman</surname>
      </author>
    </authorgroup>

    <copyright>
      <year>1996</year>
      <holder>Addison-Wesley Longman, Inc</holder>
    </copyright>

    <copyright>
      <year>2001</year>
      <holder>Перевод на русский язык: Андрей Захватов</holder>
    </copyright>

<!-- I seem to recall the editor wanting this notice to be bold.  In html, I'd
     use the _strong_ tag.  What should I use instead? -->

    <legalnotice>
     <para>Вторая глава книги <citetitle>Архитектура и реализация
       Операционной Системы 4.4BSD</citetitle> представлена здесь с
       разрешения издателя. Никакая из частей этого текста не может
       воспроизводится, либо распространятся без письменного
       <ulink url="mailto:peter.gordon@awl.com">разрешения</ulink>
       издателя. Оставшаяся
       <ulink url="http://cseng.aw.com/book/0,3828,0201549794,00.html">часть
       книги</ulink> очень подробно исследует и раскрывает концепции
       представленные в этой главе и является прекрасным материалом для
       всех кто интересуется BSD UNIX. Более подробную информацию об этой
       книге Вы можете получить от издателя, у которого Вы также можете
       подписатся на получение новостей о
       <ulink url="mailto:curt.johnson@awl.com">подобных книгах</ulink>.
       Информация о <ulink url="http://www.mckusick.com/courses/">Курсах о
       BSD</ulink> доступна у Кирка МакКусика.</para>
    </legalnotice>
  </bookinfo>

  <chapter label="2">
    <title>Обзор архитектуры 4.4BSD</title>

    <sect1>
      <title>Системные сервисы 4.4BSD и ядро</title>

      <para>Ядро 4.4BSD предоставляет четыре основных системных сервиса:
        процессы, файловую систему, коммуникации и запуск системы.  Этот раздел
        перечисляет, в каком месте этой книги описана каждая из этих
        служб.</para>

      <orderedlist>
        <listitem>
	  <para>Процессы образуют поток управления в адресном пространстве.
            Механизмы создания, завершения и другие управляющие процессы
            описаны в Главе 4.  Для каждого процесса система мультиплексирует
            отдельное виртуальное адресное пространство; такое управление
            памятью обсуждается в Главе 5.</para>
        </listitem>
	
        <listitem>
	  <para>Механизм доступа пользователя к файловой системе и устройствам
            один и тот же; общие аспекты обсуждаются в Главе 6.  Файловая
            система является набором именованных файлов, организованных в
            древовидную иерархию каталогов, а операции по управлению ими
            представлены в Главе 7.  Файлы располагаются на таких физических
            носителях, как диски.  4.4BSD поддерживает несколько типов
            организации данных на диске, как описано далее в Главе 8.  Доступ к
            файлам на удаленных машинах является предметом обсуждения в Главе
            9.  Для доступа к системе Терминалы используются терминалы; их
            функционированию посвящена глава 10.</para>
	</listitem>
	
	<listitem>
	  <para>Механизмы коммуникаций, предоставляемые традиционными
            UNIX-системами, включают однонаправленные потоки байтов между
            связанными процессами (смотрите материал о конвейерах в Разделе
            11.1) и извещение об исключительных событиях (смотрите материал о
            сигналах в Разделе 4.7).  В 4.4BSD имеется также механизм
            межпроцессного взаимодействия между процессами.  Этот механизм,
            описываемый в Главе 11, использует способы доступа, отличающиеся от
            тех, что используются в файловой системе, но, как только соединение
            установлено, процесс может работать с ним, как будто это конвейер.
            Имеется и механизм работы с сетью, описываемый в Главе 12, который
            обычно используется как слой ниже механизма IPC.  В Главе 13 дается
            детальное описание конкретной реализации механизма работы с
            сетью.</para>
	</listitem>
	
	<listitem>
	  <para>В любой операционной системе присутствуют вопросы управления,
            такие, как ее запуск.  Запуск и вопросы управления обсуждаются в
            Главе 14.</para>
	</listitem>
      </orderedlist>

      <para>Разделы с 2.3 по 2.14 представляют собой вводный материал,
        относящийся к главам с 3 по 14.  Мы определим понятия, коснемся
        основных системных вызовов и рассмотрим исторические разработки.
        Наконец, мы расскажем о причинах многих ключевых архитектурных
        решений.</para>

      <sect2>
	<title>Ядро</title>

	<para><emphasis>Ядро</emphasis> является частью системы, которая
          работает в защищенном режиме и управляет доступом всех
          пользовательских программ к низкоуровнему аппаратному обеспечению
          (к примеру, ЦПУ, дискам, терминалам, сетевым связям) и программным
          компонентам (к примеру, файловой системе, сетевым протоколам).  Ядро
          предоставляет основные системные услуги; оно создает процессы и
          управляет ими, предоставляет функции для доступа к файловой системе
          и службам связи.  Такие функции, называемые <emphasis>системными
          вызовами</emphasis>, доступны процессам пользователей в виде
          библиотечных подпрограмм.  Эти системные вызовы являются единственным
          способом доступа к таким услугам.  Подробно механизм работы системных
          вызовов дается в Главе 3, вместе с описанием некоторых механизмов
          ядра, работа которых не является прямым результатом процесса,
          выполняющего системный вызов.</para>

	<para><emphasis>Ядро</emphasis>, по традиционной терминологии
          операционных систем, является маленьким куском программного
          обеспечения, которое предоставляет только минимальный набор услуг,
          необходимый для реализации дополнительных служб операционной системы.
          В современных исследовательских операционных системах -- таких, как
	  Chorus <xref linkend="biblio-rozier">, Mach <xref
          linkend="biblio-accetta">, Tunis <xref linkend="biblio-ewens">, и
	  V Kernel <xref linkend="biblio-cheriton"> -- такое разделение
          функциональности выполнено не только логически.  Такие службы, как
          файловые системы и сетевые протоколы, выполнены в виде прикладных
          процессов клиентов ядра или микроядра.</para>
	
	<para>Ядро 4.4BSD не разбивается на несколько процессов.  Это
          основополагающее архитектурное решение было сделано в самых ранних
          версиях UNIX.  В первых двух реализациях Кена Томпсона (Ken Thompson)
          не было отображаемой памяти, и поэтому не было аппаратного различия
          между адресным пространством пользователя и ядра <xref
          linkend="biblio-ritchie">.  Могла бы быть придумана система обмена
          сообщениями как реально реализуемая модель процессов ядра и
          пользователя.  Для простоты и увеличения производительности было
          выбрано монолитное ядро.  К тому же ранние ядра были маленькими;
          включение таких служб, как сетевые коммуникации, в ядро увеличило его
          размер.  Современные тенденции в области операционных систем сводятся
          к уменьшению размера ядра за счет перевода таких служб в
          пользовательское адресное пространство.</para>

	<para>Пользователи обычно общаются с системой через интерпретатор языка
          команд, называемый оболочкой (<emphasis>shell</emphasis>), и, может
          быть, через дополнительные прикладные пользовательские программы.
          Такие программы и оболочка реализованы в виде процессов.  Подробное
          описание таких программ выходит за рамки этой книги, которая
          практически полностью посвящена работе ядра.</para>

	<para>В разделах 2.3 и 2.4 описываются сервисы, предоставляемые ядром
          4.4BSD, и дается обзор их архитектуры.  Последующие главы описывают
          подробности архитектуры и реализации этих сервисов в 4.4BSD.</para>
      </sect2>
    </sect1>
  
    <sect1>
      <title>Организация ядра</title>
      
      <para>В этом разделе мы рассматриваем организацию ядра 4.4BSD с двух
        точек зрения:</para>
      
      <orderedlist>
	<listitem>
	  <para>Как статический блок программного обеспечения, категоризуемый
            по функциональности модулей, составляющих ядро</para>
	</listitem>
	
	<listitem>
	  <para>В его динамике, категоризуемой по услугам, предоставляемым
            пользователям</para>
	</listitem>
      </orderedlist>

      <para>Самая большая часть ядра реализует системные услуги, к которым
        приложения обращаются через системные вызовы.  В 4.4BSD это программное
        обеспечение организуется по следующим принципам:</para>

      <itemizedlist>
	<listitem>
	  <para>Базовые услуги ядра: обработка таймеров и системного таймера,
            управление дескрипторами и процессами</para>
	</listitem>

	<listitem>
	  <para>Поддержка управления памятью: подкачка и выгрузка</para>
	</listitem>
	
	<listitem>
	  <para>Общесистемные интерфейсы: ввод/вывод, управление и
            мультиплексирование операций, выполняемых над дескрипторами</para>
	</listitem>
	
	<listitem>
	  <para>Файловая система: файлы, каталоги, преобразование маршрутов,
            блокировка файлов и управление буфером ввода/вывода</para>
	</listitem>
	
	<listitem>
	  <para>Поддержка работы с терминалами: драйвер терминального
            интерфейса и режимы работы терминального канала</para>
	</listitem>
	
	<listitem>
	  <para>Службы межпроцессного взаимодействия: сокеты</para>
	</listitem>
	
	<listitem>
	  <para>Поддержка сетевых коммуникаций: коммуникационные протоколы и
            общесетевые службы, такие, как маршрутизация</para>
	</listitem>
      </itemizedlist>

      <table frame="none" id="table-mach-indep">
      <title>Машинно-независимое программное обеспечение в ядре 4.4BSD</title>
      <tgroup cols="3">
      <thead>
        <row>
	  <entry>Категория</entry>
	  <entry>Количество строк кода</entry>
	  <entry>Процент от всего ядра</entry>
        </row>
      </thead>
	  
      <tfoot>
        <row>
	  <entry>всего машинно-независимая часть</entry>
	  <entry>162,617</entry>
	  <entry>80.4</entry>
        </row>
      </tfoot>
	  
      <tbody>
        <row>
          <entry>файлы заголовков</entry>
          <entry>9,393</entry>
          <entry>4.6</entry>
        </row>
	    
        <row>
          <entry>инициализация</entry>
          <entry>1,107</entry>
          <entry>0.6</entry>
        </row>
	    
        <row>
          <entry>службы ядра</entry>
          <entry>8,793</entry>
          <entry>4.4</entry>
        </row>
	    
        <row>
          <entry>общесистемные интерфейсы</entry>
          <entry>4,782</entry>
          <entry>2.4</entry>
        </row>
	    
	<row>
	  <entry>межпроцессное взаимодействие</entry>
	  <entry>4,540</entry>
	  <entry>2.2</entry>
	</row>
	    
	<row>
	  <entry>работа с терминалами</entry>
	  <entry>3,911</entry>
	  <entry>1.9</entry>
	</row>
	    
	<row>
	  <entry>виртуальная память</entry>
	  <entry>11,813</entry>
	  <entry>5.8</entry>
	</row>
	    
	<row>
	  <entry>управление vnode</entry>
	  <entry>7,954</entry>
	  <entry>3.9</entry>
	</row>

	<row>
	  <entry>именование файловой системы</entry>
	  <entry>6,550</entry>
	  <entry>3.2</entry>
	</row>
	    
	<row>
	  <entry>хранение файлов</entry>
	  <entry>4,365</entry>
	  <entry>2.2</entry>
	</row>
	    
	<row>
	  <entry>хранение log-структур</entry>
	  <entry>4,337</entry>
	  <entry>2.1</entry>
	</row>
	    
	<row>
	  <entry>хранение на основе памяти</entry>
	  <entry>645</entry>
	  <entry>0.3</entry>
	</row>
	    
	<row>
	  <entry>файловая система cd9660</entry>
	  <entry>4,177</entry>
	  <entry>2.1</entry>
	</row>
	    
	<row>
	  <entry>различные файловые системы (10)</entry>
	  <entry>12,695</entry>
	  <entry>6.3</entry>
	</row>
	    
	<row>
	  <entry>сетевая файловая система</entry>
	  <entry>17,199</entry>
	  <entry>8.5</entry>
	</row>
	    
	<row>
	  <entry>сетевое взаимодействие</entry>
	  <entry>8,630</entry>
	  <entry>4.3</entry>
	</row>
	    
	<row>
	  <entry>протоколы internet</entry>
	  <entry>11,984</entry>
	  <entry>5.9</entry>
	</row>
	    
	<row>
	  <entry>протоколы ISO</entry>
	  <entry>23,924</entry>
	  <entry>11.8</entry>
	</row>
	    
	<row>
	  <entry>протоколы X.25</entry>
	  <entry>10,626</entry>
	  <entry>5.3</entry>
	</row>
	    
        <row>
	  <entry>протоколы XNS</entry>
	  <entry>5,192</entry>
          <entry>2.6</entry>
        </row>
      </tbody>
      </tgroup>
      </table>
      
      <para>Большая часть программного обеспечения в этих категориях является
        машинно-независимой и переносима между различными аппаратными
        архитектурами.</para>
      
      <para>Машинно-зависимые аспекты ядра отделены от основного кода.  В
        частности, ни в одной части машинно-независимого кода не содержится
        кода, зависимого от конкретной архитектуры.  Когда требуется произвести
        действия, зависимые от архитектуры, машинно-независимый код вызывает
        функцию, зависимую от архитектуры машины, которая находится в
        машинно-зависимой части кода.  Машинно-зависимое программное
        обеспечение включает в себя</para>

      <itemizedlist>
	<listitem>
	  <para>Низкоуровневые действия по запуску системы</para>
	</listitem>
	
	<listitem>
	  <para>Обработка исключительных ситуаций и прерываний</para>
	</listitem>
	
	<listitem>
	  <para>Низкоуровневые манипуляции процессом во время работы</para>
	</listitem>

	<listitem>
	  <para>Конфигурация и инициализация аппаратных устройств</para>
	</listitem>
	
	<listitem>
	  <para>Поддержка устройств ввода/вывода во время работы</para>
	</listitem>
      </itemizedlist>
      
      <table frame="none" id="table-mach-dep">
      <title>Машинно-зависимое программное обеспечение для HP300 в ядре
        4.4BSD</title>
	
      <tgroup cols="3">
      <thead>
	<row>
	  <entry>Категория</entry>
	  <entry>Количество строк кода</entry>
	  <entry>Процент от всего ядра</entry>
	</row>
      </thead>

      <tfoot>
        <row>
          <entry>всего машинно-зависимая часть</entry>
          <entry>39,634</entry>
          <entry>19.6</entry>
        </row>
      </tfoot>

      <tbody>
	<row>
	  <entry>машинно-зависимые заголовки</entry>
	  <entry>1,562</entry>
	  <entry>0.8</entry>
	</row>
	    
	<row>
	  <entry>заголовки драйверов устройств</entry>
	  <entry>3,495</entry>
	  <entry>1.7</entry>
        </row>

        <row>
          <entry>исходные тексты драйверов устройств</entry>
          <entry>17,506</entry>
          <entry>8.7</entry>
        </row>
	    
        <row>
          <entry>виртуальная память</entry>
          <entry>3,087</entry>
          <entry>1.5</entry>
        </row>
	    
        <row>
          <entry>остальная машинно-зависимая часть</entry>
          <entry>6,287</entry>
          <entry>3.1</entry>
        </row>
	    
        <row>
          <entry>процедуры на ассемблере</entry>
          <entry>3,014</entry>
          <entry>1.5</entry>
        </row>
	    
        <row>
          <entry>совместимость с HP/UX</entry>
          <entry>4,683</entry>
          <entry>2.3</entry>
        </row>
      </tbody>
      </tgroup>
      </table>

      <para><xref linkend="table-mach-indep"> суммаризует машинно-независимый
        код, который составляет ядро 4.4BSD для HP300.  Числа во второй колонке
        обозначают количество строк исходного кода на языке C, заголовочных
        файлов и ассемблерного кода.  Практически весь код ядра написан на
        языке программирования C; менее двух процентов написано на языке
        ассемблера.  Как показывает статистика в <xref
        linkend="table-mach-dep">, машинно-зависимый код, не включающий
        поддержку HP/UX и устройств, составляет менее 6.9 процента ядра.</para>

      <para>Лишь малая часть ядра отвечает за инициализацию системы.  Этот код
        используется при <emphasis>начальной загрузке</emphasis> системы для
        перехода в рабочий режим и отвечает за настройку аппаратного и
        программного окружения ядра (обратитесь к Главе 14).  Некоторые
        операционные системы (особенно те, что ограничены объемом физической
        памяти) выполняют действия по выгрузке или
        <emphasis>перекрытию</emphasis> программного кода, выполняющего эти
        функции, после окончания его работы.  Ядро 4.4BSD не работает повторно
        с памятью, использованной начальным кодом, потому что этот объем памяти
        составляет менее 0.5 процентов ресурсов ядра, используемых на типичной
        машине.  Также начальный код не находится только в одном месте ядра --
        он рассредоточен везде, и обычно появляется там, где логически связан с
        объектом инициализации.</para>
    </sect1>
  
    <sect1>
      <title>Службы ядра</title>
      
      <para>Разграничение между кодом уровней ядра и пользователя
        обеспечивается аппаратными методами, предоставляемыми оборудованием.
        Ядро работает в отдельном адресном пространстве, которое недоступно
        процессам пользователя.  Привилегированные операции -- такие, как
        осуществление ввода/вывода и остановка модуля центрального процессора
        (CPU) -- доступны только ядру.  Приложения делают запросы ядру на
        доступ к его сервисам при помощи <emphasis>системных
        вызовов</emphasis>.  Системные вызовы используются для указания ядру на
        выполнение как сложных операций, таких, как запись данных во вторичный
        носитель, так и простых, таких, как получение текущего времени.  Все
        системные вызовы выполняются <emphasis>синхронно</emphasis> с
        приложением: Приложение не будет продолжать работу, пока ядро не
        выполнит действия, соответствующие системному вызову.  Ядро может
        завершить некоторые операции, связанные с системным вызовом, после его
        окончания.  Например, системный вызов <emphasis>write</emphasis>
        будет копировать записываемые данные от пользовательского процесса в
        буфер ядра, пока процесс находится в ожидании, но, как правило, будет
        немедленно завершаться до того, как буфер ядра реально будет записан на
        диск.</para>
      
      <para>Системный вызов обычно реализуется как аппаратное прерывание,
        которое изменяет режим работы CPU и текущее отображение адресного
        пространства.  Параметры, передаваемые пользователями системным
        вызовам, перед использованием проверяются ядром.  Такая проверка
        обеспечивает целостность системы.  Все параметры, передаваемые в ядро,
        копируются в адресное пространство ядра, для того, чтобы проверенные
        параметры не могли быть изменены в результате побочного действия
        системного вызова.  Результаты выполнения системного вызова
        возвращаются ядром либо в аппаратных регистрах, либо копированием их
        значений в области памяти, указанные пользователем.  Как и параметры,
        переданные в ядро, адреса, используемые для возвращения результатов,
        должны быть проверены на то, что они являются частью адресного
        пространства приложения.  Если при обработке системного вызова ядром
        возникает ошибка, код ошибки возвращается пользователю.  В случае
        языка программирования C код этой ошибки сохраняется в глобальной
        переменной <emphasis>errno</emphasis>, а функция, соответствующая
        системному вызову, возвращает в качестве результата значение -1.</para>
      
      <para>Пользовательские приложения и ядро работают независимо друг от
        друга.  4.4BSD не хранит управляющие блоки ввода/вывода и другие
        связанные с операционной системой структуры данных в адресном
        пространстве приложения.  Каждому пользовательскому приложению
        предоставляется независимое адресное пространство, в котором оно и
        выполняется.  Ядро выполняет большинство управляющих действий, таких,
        как приостановка процесса на время выполнения другого, незаметно для
        участвующих процессов.</para>
    </sect1>
  
    <sect1>
      <title>Управление процессами</title>

      <para>4.4BSD поддерживает многозадачность.  Каждая задача или
        выполняющийся поток называется <emphasis>процессом</emphasis>.
	<emphasis>Контекст</emphasis> процесса 4.4BSD состоит из состояния
        пользовательского уровня, включая содержимое его адресного
        пространства и окружения времени выполнения, и состояния уровня ядра,
        в который включаются параметры планировщика задач, управляющие ресурсы
        и идентифицирующая информация.  В контекст включается все, что
        используется ядром при предоставлении своих сервисов процессу.
        Пользователи могут создавать процессы, управлять их выполнением и
        получать уведомления при изменении состояния выполнения процессов.
        Каждому процессу назначается уникальное число, называемое
       	<emphasis>идентификатором процесса</emphasis> (PID).  Это число
        используется ядром для идентификации процесса при сообщении
        пользователю об изменении его состояния, и пользователем для указания
        процесса в системном вызове.</para>
      
      <para>Ядро создает процесс, дублируя контекст другого процесса.  Новый
        процесс считается <emphasis>порожденным процессом</emphasis> исходного
        <emphasis>родительского процесса</emphasis>.  Контекст, копируемый в
        ходе создания процесса, включает как состояние выполнения процесса
        уровня пользователя, так и системное состояние процесса, управляемое
        ядром.  Важные компоненты состояния ядра описаны в Главе 4.</para>
      
      <figure id="fig-process-lifecycle">
	<title>Жизненный цикл процесса</title>
	
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="fig1" format="EPS">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
+----------------+               wait               +----------------+
| parent process |--------------------------------->| parent process |--->
+----------------+                                  +----------------+
        |                                                   ^
        | fork                                              |
        V                                                   |
+----------------+ execve +----------------+  wait  +----------------+
|  child process |------->|  child process |------->| zombie process |
+----------------+        +----------------+        +----------------+
            </literallayout>
	  </textobject>
	  
	  <textobject>
	    <phrase>Системные вызовы управления процессами</phrase>
	  </textobject>
	</mediaobject>
      </figure>
      
      <para>Жизненный цикл процесса изображен на <xref
        linkend="fig-process-lifecycle">.  Процесс может создать новый процесс,
        который является копией исходного процесса с помощью системного вызова
	<emphasis>fork</emphasis>.  Возврат из вызова <emphasis>fork</emphasis>
        происходит два раза: один раз в родительском процессе, в котором
        возвращаемое значение является идентификатором порожденного процесса, и
        второй раз в порожденном процессе, в котором возвращаемое значение
        равно 0.  Связь родитель-потомок порождает иерархическую структуру
        процессов в системе.  Новый процесс имеет доступ ко всем ресурсам его
        родителя, таким, как файловые дескрипторы, состояние обработки
        сигналов и распределение памяти.</para>

      <para>Хотя есть ситуации, когда процесс должен быть копией своего
        родителя, наиболее типичным и полезным действием является загрузка и
        выполнение другой программы.  Процесс может заместить себя образом
        памяти другой программы, передавая вновь созданному образу набор
        параметров, при помощи системного вызова <emphasis>execve</emphasis>.
        Одним из параметров является имя файла, содержимое которого имеет
        формате, распознаваемый системой -- это либо двоичный выполняемый файл,
        либо файл, который приводит к запуску указанной программы интерпретации
        для обработки его содержимого.</para>

      <para>Процесс может завершить работу, выполнив системный вызов
	<emphasis>exit</emphasis>, посылающий 8-битовое значение состояния
        завершения своему родителю.  Если процесс хочет передать родительскому
        процессу информацию, превышающую один байт, он должен либо создать
        канал межпроцессных коммуникаций при помощи конвейеров или сокетов,
        или при помощи промежуточного файла.  Коммуникации между процессами
        подробно обсуждаются в Главе 11.</para>

      <para>Процесс может приостановить выполнение до тех пор, пока не завершит
        работу любой из порожденных им процессов, при помощи системного вызова
	<emphasis>wait</emphasis>, который возвращает PID и статус завершения
        выполненного дочернего процесса.  Родительский процесс может быть
        настроен на получение сигнала в случае, когда порожденный процесс
        завершает работу или аварийно прекращает выполнение.  При помощи
        системного вызова <emphasis>wait4</emphasis> родитель может получить
        информацию о событии, приведшем к завершению порожденного процесса и о
        ресурсах, использованных процессом за время его работы.  Если процесс
        становится сиротой из-за того, что процесс, его породивший, завершил
        работу до окончания работы потомка, то ядро перенаправляет состояние
        завершения порожденного процесса особому системному процессу
	<!-- FIXME, the emphasis is wrong -->
	<emphasis>init</emphasis>: обратитесь к разделам 3.1 и 14.6).</para>
      
      <para>Подробное описание того, как ядро создает и уничтожает процессы,
        дается в Главе 5.</para>

      <para>Планирование выполнения процессов осуществляется согласно параметру
	<emphasis>приоритетности процесса</emphasis>.  Этот приоритет
        управляется алгоритмом планирования задач в ядре.  Пользователи могут
        влиять на выполнение процесса, задавая этот параметр
	(<emphasis>nice</emphasis>), который влияет на суммарный приоритет, но
	но ограничен использованием ресурсов CPU согласно алгоритму
        планировщика задач ядра.</para>

      <sect2>
	<title>Сигналы</title>

	<para>В системе определен набор <emphasis>сигналов</emphasis>, которые
          могут быть отправлены процессу.  Сигналы в 4.4BSD сделаны по образу
          аппаратных прерываний.  Процесс может определить пользовательскую
          подпрограмму, которая будет являться
          <emphasis>обработчиком</emphasis>, и которой должен будет
          перенаправляться сигнал.  Когда сигнал генерируется, он блокируется
          от повторного появления до тех пор, пока не будет
          <emphasis>перехвачен</emphasis> обработчиком.  Перехват сигнала
          включает в себя сохранение контекста текущего процесса и построение
          нового, в котором запускается обработчик.  Затем сигнал направляется
          обработчику, который может либо прервать процесс, либо передать
          управление обратно выполняемому процессу (может быть, после установки
          значения глобальной переменной).  Если обработчик возвратил
          управление, сигнал разблокировывается и может быть сгенерирован (и
          получен) снова.</para>
	
	<para>Либо процесс может определить, что сигнал будет
	  <emphasis>игнорироваться</emphasis> или будет выполняться действие
          по умолчанию, определяемое ядром.  Действием по умолчанию для
          некоторых сигналов является прекращение процесса.  Это завершение
          работы может сопровождаться созданием <emphasis>файла
          дампа</emphasis>, содержащего текущий образ памяти процесса для
          использования в последующей отладке.</para>
	
	<para>Некоторые сигналы не могут быть перехвачены или проигнорированы.
          К таким сигналам относятся <emphasis>SIGKILL</emphasis>, прерывающий
          неуправляемый процесс, и сигнал управления заданиями
	  <emphasis>SIGSTOP</emphasis>.</para>

	<para>Процесс может выбрать получение сигналов в специальный стек для
          выполнения хитроумных программных манипуляций стеком.  Например,
          подпрограммам поддержки языка нужно иметь стек для каждой
          подпрограммы.  Система времени выполнения языка может выделять эти
          стеки, разделяя единственный стек, предоставляемый в 4.4BSD.  Если
          ядро не поддерживает отдельный стек сигналов, то пространство,
          выделяемое каждой подпрограмме, должно быть расширено на объем,
          требуемый для перехвата сигнала.</para>

	<para>Все сигналы имеют один и тот же <emphasis>приоритет</emphasis>.
          Если обработки ожидают несколько сигналов, то порядок их направления
          процессу зависит от реализации.  Обработчики сигналов, выполняемые по
          сигналу, который их вызвал, блокируются, но при этом могут быть
          сгенерированы дополнительные сигналы.  Имеется механизм, позволяющий
          защитить критический участок кода от появления заданных
          сигналов.</para>

	<para>Подробное описание архитектуры и реализации механизма сигналов
          дается в Разделе 4.7.</para>
      </sect2>
    
      <sect2>
	<title>Группы управления и сеансы</title>

	<para>Процессы организованы в <emphasis>группы управления</emphasis>.
          Группы управления используются для управления доступом к терминалам и
          для обеспечения передачи сигналов наборам связанных процессов.
          Процесс наследует группу управления от своего родительского процесса.
          Ядром обеспечиваются механизмы, позволяющие процессу изменять свою
          группу управления или группу управления своих наследников.  Создание
          новой группы управления просто; значение, соответствующее новой
          группе управления, обычно является идентификатором создающего ее
          процесса.</para>

	<para>Группу процессов в группе управления иногда называют
	  <emphasis>заданием</emphasis> и оно управляется высокоуровневым
          системным программным обеспечением, таким, как командный процессор.
          Типичным примером задания, созданного командным процессором, является
          <emphasis>конвейер</emphasis> из нескольких связанных процессов, так
          что выходной поток первого процесса является входным потоком для
          второго, выходной поток второго процесса является входным потоком для
          третьего, и так далее.  Командный процессор создает такое задание,
          порождая процесс для каждого участка конвейера, а затем помещая все
          эти процессы в отдельную группу обработки.</para>

	<para>Пользовательский процесс может послать сигнал как всем процессам
          в группе управления, так и конкретному процессу.  Процесс в заданной
          группе управления может получать программные прерывания, отражающиеся
          на группе, приводящие к приостановке или продолжению выполнения, или
          к прерыванию или завершению работы.</para>

	<para>Терминалу ставится в соответствие идентификатор группы
          управления.  Этот идентификатор обычно равен идентификатору группы
          управления, соответствующей терминалу.  Управляющий заданиями
          командный процессор может создать несколько групп управления,
          связанных с одним и тем же терминалом; терминал является
	  <emphasis>управляющим терминалом</emphasis> для каждого процесса в
          этих группах.  Процесс может выполнять чтение из дескриптора своего
          управляющего терминала, если только идентификатор группы управления
          соответствует идентификатору группы этого процесса.  Если
          идентификаторы не совпадают, процесс будет блокирован при попытке
          чтения с терминала.  Изменяя идентификатор группы управления
          терминала, командный процессор может распределять терминал между
          несколькими различными заданиями.  Такое распределение называется
          <emphasis>управлением заданиями</emphasis> и описывается вместе с
          группами управления в Разделе 4.8.</para>
	
	<para>Так же, как и наборы связанных процессов могут объединяться в
          группы управления, набор групп управления может быть объединен в
	  <emphasis>сеанс</emphasis>.  Основное назначение сеансов заключается
          создании изолированного окружения для процесса-даемона и порожденных
          им процессов, а также для объединения начального командного
          процессора пользователя и заданий, которые он порождает.</para>
      </sect2>
    </sect1>
  
    <sect1>
      <title>Управление памятью</title>

      <para>Каждый процесс имеет собственное адресное пространство.  Адресное
        пространство изначально разделяется на три логических сегмента:
	<emphasis>код</emphasis>, <emphasis>данные</emphasis> и
	<emphasis>стек</emphasis>.  Сегмент кода доступен только для
        чтения и содержит машинные коды программы.  Сегменты данных и стека оба
        доступны как для чтения, так и для записи.  Сегмент данных содержит как
        инициализированные, так и неинициализированные области данных
        программы, когда как стековый сегмент представляет собой стек программы
        на этапе выполнения.  На большинстве машин сегмент стека автоматически
        расширяется ядром в процессе работы программы.  Процесс может расширять
        или уменьшать свой сегмент данных, выполняя системный вызов, когда как
        размер сегмента кода процесс может изменить только когда содержимое
        сегмента перекрывается данными файловой системы или в процессе отладки.
        Начальное содержимое сегментов порожденного процесса копируется из
        сегментов родительского процесса.</para>

      <para>Для выполнения процесса вовсе не обязательно постоянно хранить в
        памяти полное содержимое его адресного пространства.  Если процесс
        обращается к области адресного пространства, которая не присутствует в
        оперативной памяти, то система <emphasis>подгружает страницу</emphasis>
        с необходимой информацией в память.  Когда возникает нехватка системных
        ресурсов, то система использует двухуровневый подход к управлению
        имеющимися ресурсами.  Если не хватает памяти, то система будет
        забирать ресурсы памяти от процессов, если они давно не использовались.
        Если ресурсов не хватает очень сильно, то система будет прибегать
        к <emphasis>выгрузке</emphasis> всего контекста процесса во вторичную
        подсистему хранения данных.  <emphasis>Постраничная подгрузка по
        требованию</emphasis> и <emphasis>выгрузка</emphasis> выполняются
        системой абсолютно незаметно для процессов.  Процесс может, однако,
        указать системе объем памяти, который будет использоваться, в качестве
        помощи.</para>
       
      <sect2>
	<title>Решения BSD по архитектуре управления памятью</title>

	<para>В 4.2BSD требовалось реализовать поддержку больших несвязанных
          адресных пространств, отображаемых в память файлов и совместно
          используемой памяти.  Был спроектирован интерфейс, который назвали
	  <emphasis>mmap</emphasis>, позволяющий несвязанным процессам
          запрашивать отображение в их адресное пространство файла в режиме
          совместного использования.  Если несколько процессов отображают в
          свое адресное пространство один и тот же файл, то изменение адресного
          пространства процесса, соответствующего файлу, в одном процессе,
          будет отображено в области отображения этого файла в другом процессе,
          а также и в самом файле.  Однако в конце концов 4.2BSD была выпущена
          без интерфейса <emphasis>mmap</emphasis> из-за необходимости сделать
          в первую очередь другие возможности, такие, как работа с
          сетью.</para>

	<para>Затем разработка интерфейса <emphasis>mmap</emphasis>
          продолжалась во время работы над 4.3BSD.  Более 40 компаний и
          исследовательских групп принимали участие в обсуждениях, которые
          привели к появлению обновленной концепции, описанной в Berkeley
          Software Architecture Manual <xref linkend="biblio-mckusick-1">.
          Несколько компаний реализовали этот обновленный интерфейс
	  <xref linkend="biblio-gingell">.</para>
	
	<para>И снова сроки разработки не позволили включить в 4.3BSD
          реализацию этого интерфейса.  Хотя позже она могла быть встроена в
          имеющуюся подсистему виртуальной памяти 4.3BSD, разработчики решили
          не включать ее сюда. потому что этой реализации было уже более 10
          лет.  Более того, оригинальная архитектура виртуальной памяти была
          основана на предположении, что компьютерная память мала и дорога, а
          диски подключены непосредственно к компьютеру, быстры и дешевы.
          Поэтому подсистема виртуальной памяти была разработана с упором на
          бережное использование памяти ценой более частых обращений к диску.
          Вдобавок реализация в 4.3BSD была пронизана зависимостями от
          аппаратной системы управления памятью машин VAX, что препятствовало
          ее переносу на другие аппаратные платформы.  И наконец, подсистема
          виртуальной памяти не была предназначена для поддержки связных
          многопроцессорных систем, которые сейчас становятся все более
          распространенными и необходимыми.</para>

	<para>Попытки постепенно усовершенствовать старую реализацию заведомо
          были обречены на неудачу.  Полностью новая архитектура, с другой
          стороны, могла бы использовать большие объемы памяти, уменьшить
          дисковые операции и обеспечивать работу с несколькими процессорами.
          Наконец, система виртуальной памяти в 4.4BSD была полностью изменена.
          Система виртуальной памяти 4.4BSD основана на системе виртуальной
          памяти (VM) Mach 2.0 <xref linkend="biblio-tevanian"> с
          заимствованиями из Mach 2.5 и Mach 3.0.  В ней была эффективная
          поддержка совместного использования, полное разделение
          машинно-зависимой и машинно-независимой частей, а также (сейчас не
          используемая) поддержка работы с несколькими процессорами.  Процессы
          могут отображать файлы в любую область своего адресного пространства.
          Они могут совместно использовать части своих адресных пространств
          посредством отображения в память одного и того же файла.  Изменения,
          сделанные одним процессом, видны в адресном пространстве другого
          процесса, а также записываются и в сам файл.  Процессы могут также
          запрашивать эксклюзивное отображение файла в память, при котором
          любые изменения, сделанные процессом, не видны другим процессам,
          которые отображают файл в память и не записываются обратно в
          файл.</para>
	
	<para>Еще одной проблемой с системой виртуальной памяти является
          способ, которым информация передается ядру при выполнении системного
          вызова.  4.4BSD всегда копирует данные из адресного пространства
          процесса в буфер ядра.  Для операций чтения и записи, при которых
          передаются большие объемы данных, выполнение копирования может
          оказаться занимающим время процессом.  Альтернативным способом
          является манипуляции с адресным пространством процесса в ядре.  Ядро
	  4.4BSD всегда копирует данные о нескольким причинам:</para>

	<itemizedlist>
	  <listitem>
	    <para>Зачастую пользовательские данные не выравнены по границе
              страницы памяти и их объем не кратен размеру аппаратной
              страницы памяти.</para>
	  </listitem>
	  
	  <listitem>
	    <para>Если страница памяти забирается от процесса, он не может
              больше ссылаться на эту страницу.  Некоторые программы зависят от
              данных, остающихся в буфере, даже после записи этих
              данных.</para>
	  </listitem>
	  
	  <listitem>
	    <para>Если процесс позволяет хранить копию страницы памяти (как это
              делается в существующей 4.4BSD), то страница должна иметь атрибут
              <emphasis>копирования-при-записи</emphasis>.  Такая страница
              является одной из таковых, что защищается от записи при помощи
              атрибута только-для-чтения.  Если процесс пытается модифицировать
              страницу памяти, в ядре возникает ситуация ошибки записи.  После
              этого ядро делает копию страницы, которую процесс может изменять.
              К несчастью, большинство процессов будет немедленно пытаться
              записать новые данные в свой буфер вывода, что приводит в любом
              случае к копированию данных.</para>
	  </listitem>
	  
	  <listitem>
	    <para>Когда страницы переносятся в новые адреса виртуальной памяти,
              большинство аппаратных менеджеров памяти требуют, чтобы кэш
              аппаратного переназначения адресов был выборочно очищен.
              Очистка кэша зачастую выполняется медленно.  В итоге получается,
              что переназначение адресов оказывается медленнее, чем копирование
              блоков данных, не превышающих 4 или 8 килобайт.</para>
	  </listitem>
	</itemizedlist>

	<para>Больше всего отображение памяти нужно для работы к большими
          файлами и передачи больших объемов данных между процессами.
          Интерфейс <emphasis>mmap</emphasis> дает методы для выполнения обеих
          этих операций без копирования.</para>
      </sect2>
    
      <sect2>
	<title>Управление памятью внутри ядра</title>
	
	<para>Ядро часто выполняет выделение памяти, которое нужно только для
          выполнения единственного системного вызова.  В пользовательском
          процессе такая кратковременно используемая память будет выделяться в
          стеке во время выполнения.  Так как ядро имеет ограниченный объем
          стека времени выполнения, то неэффективно выделять в нем даже блоки
          памяти среднего размера.  Таким образом, такая память должна
          выделяться посредством более гибкого механизма.  Например, когда
          системный вызов должен преобразовать имя каталога, он должен выделить
          буфер размером 1 Кбайт для хранения имени.  Другие блоки памяти
          должны выделяться на более продолжительный срок, чем один системный
          вызов, и поэтому не могут выделяться в стеке, даже если там есть
          место.  В качестве примера можно взять блоки управления протоколами,
          которые существуют на всем протяжении сетевого соединения.</para>

	<para>Необходимость в динамическом выделении памяти в ядре становилась
          все более острой вместе с добавлением количества сервисов.  Общий
          механизм выделения памяти уменьшает сложность написания кода в ядре.
          Поэтому в 4.4BSD ядро имеет единый механизм выделения памяти, который
          может использоваться в любой части системы.  У него есть интерфейс,
          похожий на функции библиотеки языка C <emphasis>malloc</emphasis> и
	  <emphasis>free</emphasis>, которые обеспечивают выделение памяти в
          прикладных программах <xref linkend="biblio-mckusick-2">.  Как
          интерфейс библиотеки языка C, функция выделения памяти получает
          параметр, указывающий на размер памяти, который необходим.  Диапазон
          запрашиваемых объемов выделяемой памяти не ограничен; однако
          выделяемая физическая память не подвергается постраничной подгрузке.
          Функции освобождения памяти передается указатель на освобождаемый
          участок памяти, но указывать размер освобождаемого участка памяти не
          нужно.</para>
      </sect2>
    </sect1>
  
    <sect1>
      <title>Система ввода/вывода</title>

      <para>Базовой моделью системы ввода/вывода UNIX является
        последовательность байт, доступ к которым может осуществляться как
        последовательно, так и в в произвольном порядке.  В типичном
        пользовательском процессе UNIX нет таких понятий, как
	<emphasis>методы доступа</emphasis> или	<emphasis>управляющие
        блоки</emphasis>.</para>

      <para>Различные программы используют разнообразные структуры данных, но
        ядро не связывает ввод/вывод с используемыми структурами.  Например,
        текстовым файлом считается файл из строк символов набора ASCII, которые
        разделены одним символом новой строки (символ ASCII перевода строки),
        но ядро не знает ничего об этом соглашении.  Для удовлетворения
        потребностей большинства программ модель еще более упрощена и сводится
        к потоку байт данных, или <emphasis>потоку ввода/вывода</emphasis>.
        Такое единое представление данных позволяет работать характерному для
        UNIX подходу на основе инструментов <xref linkend="biblio-kernighan">.
        Поток ввода/вывода одной программы может быть подан в качестве входной
        информации практически любой другой программе.  (Этот тип традиционных
        для UNIX потоков ввода/выводы не нужно путать с потоковой системой
        ввода/вывода из Eighth Edition или с потоками из System V, Release 3
	(STREAMS), оба из которых доступны как обычные потоки
        ввода/вывода.)</para>

      <sect2>
	<title>Дескрипторы и ввод/вывод</title>

	<para>Процессы UNIX для работы с потоками ввода/вывода используют
          <emphasis>дескрипторы</emphasis>.  Дескрипторы представляют собой
          беззнаковые целые числа, получаемые после выполнения системных вызовов
	  <emphasis>open</emphasis> и <emphasis>socket</emphasis>.  Системный
          вызов <emphasis>open</emphasis> получает в качестве аргументов имя
          файла и режим доступа, который определяет, должен ли файл открываться
          для чтения, для записи или для обеих операций.  Этот системный вызов
          может также использоваться для создания нового пустого файла.
          Системные вызовы <emphasis>read</emphasis> и
          <emphasis>write</emphasis> могут применяться к дескриптору для
          переноса данных.  Системный вызов <emphasis>close</emphasis> может
          использоваться для уничтожения любого дескриптора.</para>

	<para>Дескрипторы представляют низкоуровневые объекты, поддерживаемые
          ядром, и создаваемые системными вызовами, специфичными для каждого
          типа объектов.  В 4.4BSD дескрипторы могут представлять три типа
          таких объектов: файлы, каналы и сокеты.</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>Файл</emphasis> представляет собой линейную
              последовательность байт, имеющую по крайней мере одно имя.  Файл
              существует, пока все его имена не удалены и ни один из процессов
              не хранит его дескриптор.  Процесс получает дескриптор файла,
              открывая имя файла посредством системного вызова
	      <emphasis>open</emphasis>.  Работа с устройствами ввода/вывода
              осуществляется как с файлами.</para>
	  </listitem>
	  
	  <listitem>
	    <para><emphasis>Каналом</emphasis> является линейная
              последовательность байт, такая же, как файл, но используемая
              исключительно как поток ввода/вывода, причем однонаправленный.
              У канала нет имени, и поэтому он не может быть открыт при помощи
	      <emphasis>open</emphasis>.  Вместо этого он создается посредством
              системного вызова <emphasis>pipe</emphasis>, который возвращает
              два дескриптора, один из которых принимает входные данные,
              без искажений, без повторений и в той же самой последовательности
              посылаемый на другой дескриптор.  Система также поддерживает
              именованный канал, или FIFO.  FIFO имеет те же самые свойства,
              что и канал, за исключением того, что он располагается в файловой
              системе; поэтому он может быть открыт системным вызовом
	      <emphasis>open</emphasis>.  Процессы, которые хотят обмениваться
              данными, открывают FIFO: Один процесс открывает его для чтения, а
              другой для записи.</para>
	  </listitem>

	  <listitem>
	    <para><emphasis>Сокет</emphasis> является промежуточным объектом,
              который используется для межпроцессных коммуникаций; он
              существует, пока какой-либо процесс хранит дескриптор,
              ссылающийся на него.  Сокет создается системным вызовом
	      <emphasis>socket</emphasis>, который возвращает его дескриптор.
              Имеется несколько типов сокетов, которые поддерживают различные
              коммуникационные возможности, такие, как надежную доставку
              данных, сохранение последовательности передаваемых сообщений,
              и сохранение границ сообщений.</para>
	  </listitem>
	</itemizedlist>

	<para>В системах, предшествующих 4.2BSD, каналы были реализованы в
          файловой системе, когда в 4.2BSD появились сокеты, то каналы были
          повторно реализованы как сокеты.</para>
	
	<para>Для каждого процесса ядро хранит <emphasis>таблицу
          дескрипторов</emphasis>, которая является таблицей, используемой
          ядром для преобразования внешнего представления дескриптора в его
          внутреннее представление.  (Дескриптор является просто индексом в
          этой таблице.)  Таблица дескрипторов процесса наследуется от
          родительского процесса, и вместе с ней наследуется и доступ к
          объектам, на которые ссылаются дескрипторы.  Основными способами,
          при помощи которых процесс может получить дескриптор, является
          открытие или создание объекта, а также наследование от родительского
          процесса.  Кроме того, межпроцессные коммуникации при помощи сокетов
          позволяют передавать дескрипторы в сообщениях между несвязанными
          процессами на одной и той же машине.</para>

	<para>Любой рабочий дескриптор имеет связанное с ним <emphasis>смещение
          в файле</emphasis> в байтах от начала объекта.  Операции чтения и
          записи начинаются от этого смещения, который обновляется после каждой
          передачи данных.  Для объектов, к которым разрешен произвольный
          доступ, смещение в файле может быть установлено посредством
          системного вызова <emphasis>lseek</emphasis>.  Обычные файлы, а также
          некоторые устройства, разрешают произвольный доступ к ним.  Каналы и
          сокеты этого делать не позволяют.</para>
	
	<para>Когда процесс завершается, ядро освобождает все дескрипторы,
          которые использовались этим процессом.  Если процесс хранил последнюю
          ссылку на объект, то менеджер объектов уведомляется для выполнения
          всех необходимых действий, таких, как окончательное удаление файла
          или уничтожение сокета.</para>
      </sect2>
    
      <sect2>
	<title>Управление дескрипторами</title>

	<para>Большинство процессов ожидают, что перед началом их работы уже
          будут открыты три дескриптора.  Это дескрипторы 0, 1 и 2, больше
          известные как <emphasis>стандартный ввод</emphasis>,
          <emphasis>стандартный вывод</emphasis> и <emphasis>стандартный поток
          диагностических сообщений</emphasis>, соответственно.  Как правило,
          все они связываются с пользовательским терминалом по время входа в
          систему (смотри Раздел 14.6) и наследуются через вызовы
	  <emphasis>fork</emphasis> и <emphasis>exec</emphasis> процессами,
          запускаемыми пользователем.  Таким образом, программа может считывать
          то, что набирает пользователь, из стандартного ввода, и программа
          может выдавать результат на экран пользователя, осуществляя запись в
          стандартный вывод.  Дескриптор потока диагностических сообщений
          также открыт для записи и используется для вывода ошибок, когда как
          стандартный вывод используется для обычного вывода.</para>

	<para>Эти (и другие) дескрипторы могут отображаться на объекты,
          отличающиеся от терминала; такое отображение называется
	  <emphasis>перенаправлением ввода/вывода</emphasis>, и все стандартные
          командные процессоры позволяют пользователю это делать.  Оболочка
          может направить вывод программы в файл, закрывая дескриптор 1
          (стандартный вывод) и открывая выбранный выходной файл для создания
          нового дескриптора 1.  Подобным же образом стандартный ввод может
          браться из файла, при этом закрывается дескриптор 0 и открывается
          файл.</para>

	<para>Каналы позволяют выводу одной программы становиться вводом другой
          программы без переписывания и даже перекомпоновки программ.  Вместо
          того, чтобы дескриптор 1 (стандартный вывод) исходной программы был
          настроен на запись на терминал, он настраивается на входной
          дескриптор канала.  Аналогично дескриптор 0 (стандартный ввод)
          принимающей программы настраивается на обращение к выводу канала,
          а не к клавиатуре терминала.  Результирующий набор двух процессов и
          соединяющий канал называется <emphasis>конвейером</emphasis>.
          Конвейеры могут быть весьма большими последовательностями процессов,
          соединенных каналами.</para>
	
	<para>Системные вызовы <emphasis>open</emphasis>,
          <emphasis>pipe</emphasis> и <emphasis>socket</emphasis> порождают
          новые дескрипторы с наименьшим неиспользуемым номером, подходящим для
          дескриптора.  Для того, чтобы конвейеры могли работать, должен
          существовать механизм для отображения таких дескрипторов в 0 и 1.
          Системный вызов <emphasis>dup</emphasis> создает копию дескриптора,
          которая указывает на ту же самую запись в таблице файлов.  Новый
          дескриптор также является наименьшим неиспользуемым, но если нужный
          дескриптор сначала закрыть, то <emphasis>dup</emphasis> можно
          использовать для выполнения нужного отображения.  Однако здесь
          требуется некоторая осторожность: если нужен дескриптор 1, а
          дескриптор 0 уже закрыт, то в результате получится дескриптор 0.  Во
          избежание этой проблемы в системе имеется системный вызов
	  <emphasis>dup2</emphasis>; он похож на <emphasis>dup</emphasis>, но
          воспринимает дополнительный аргумент, указывающий номер нужного
          дескриптора (если нужный дескриптор уже открыт, то 
	  <emphasis>dup2</emphasis> его закроет перед повторным
          использованием).</para>
      </sect2>
    
      <sect2>
	<title>Устройства</title>
    
	<para>Аппаратные устройства имеют связанные с ними имена файлов, и к
          ним может обращаться пользователь при помощи тех же самых системных
          вызовов, что используются для обычных файлов.  Ядро может
          различать <emphasis>специальный файл устройства</emphasis> или просто
	  <emphasis>специальный файл</emphasis>, и может определять, к какому
          устройству он относится, но большинство процессов не выполняют такого
          распознавания.  Терминалы, принтеры и стримеры все доступны как
          последовательности байт, как дисковые файлы 4.4BSD.  Таким образом,
          особенности работы устройств максимально скрываются ядром, и даже в
          ядре большинство из них отличаются в драйверах.</para>

	<para>Аппаратные устройства могут быть разделены на
	  <emphasis>структурированные</emphasis> или
	  <emphasis>неструктурированные</emphasis>; они известны под названиями
	  <emphasis>блочные</emphasis> и <emphasis>посимвольные</emphasis>,
          соответственно.  Как правило, процессы обращаются к устройствам
          посредством <emphasis>специальных файлов</emphasis> в файловой
          системе.  Операции ввода/вывода, выполняемые с такими файлами,
          обрабатываются постоянно находящимися в ядре программными модулями,
          называемыми <emphasis>драйверами устройств</emphasis>.  Большинство
          аппаратных устройств для сетевых коммуникаций доступны только при
          помощи механизмов межпроцессного взаимодействия, и не имеют
          специальных устройств в пространстве имен файловой системы, так как
          интерфейс <emphasis>низкоуровневых сокетов</emphasis> дает более
          естественный интерфейс, чем специальный файл.</para>

	<para>Структурированные или блочные устройства разделяются на диски и
          магнитные ленты и включают в себя большинство устройств с
          произвольным доступом.  Ядро поддерживает операции буферизации типа
          чтение-изменение-запись с блочными структурированными устройствами
          для того, чтобы разрешить последним осуществлять чтение и запись
          полностью произвольным образом, как с обычными файлами.  Файловые
          системы создаются на блочных устройствах.</para>

	<para>Неструктурированными устройствами являются те, что не
          поддерживают блочную структуру.   Типичными неструктурированными
          устройствами являются линии связи, растровые графопостроители и
          небуферизируемые магнитные ленты и диски.  Неструктурированные
          устройства, как правило, поддерживают перенос больших объемов
          данных.</para>
	
	<para>Неструктурированные файлы называют <emphasis>символьными
          устройствами</emphasis>, потому что первые из них являлись драйверами
          терминальных устройств.  Интерфейс ядра к драйверу для этих устройств
          доказал удобство его использования для других неструктурированных
          устройств.</para>

	<para>Специальные файлы устройств создаются системным вызовом
	  <emphasis>mknod</emphasis>.  Имеется дополнительный системный вызов,
	  <emphasis>ioctl</emphasis>, для управления низкоуровневыми
          параметрами специальных файлов.  Выполняемые операции для каждого
          устройства различны.  Этот системный вызов позволяет осуществлять
          доступ к специальным характеристикам устройств, не перегружая смысл
          других системных вызовов.  Например, для стримера существует
          <emphasis>ioctl</emphasis> для записи метки конца ленты, но нет
          особой или измененной версии функции
          <emphasis>write</emphasis>.</para>
      </sect2>
    
      <sect2>
	<title>Механизм межпроцессных коммуникаций посредством сокетов</title>
    
	<para>В ядре 4.2BSD появился механизм межпроцессного взаимодействия,
          более гибкий, чем каналы, основанный на <emphasis>сокетах</emphasis>.
          Сокет является конечной точкой коммуникаций, доступный через
          дескриптор, как файл или канал.  Каждый из двух процессов может
          создать сокет, а затем соединить эти конечные точки для получения
          надежного канала передачи потока байт.  После соединения процесс
          может выполнять с дескрипторами операции чтения и записи, как это
          делалось с каналами.  Прозрачность сокетов позволяет ядру
          перенаправить вывод одного процесса на вход другого, работающего на
          другой машине.  Большим различием между каналами и сокетами является
          то, что каналы требуют наличия общего родительского процесса для
          установки коммуникации.  Соединение между сокетами может быть
          установлено двумя несвязанными процессами, возможно, работающими на
          разных машинах.</para>

	<para>System V предоставляет механизм локального межпроцессного
          взаимодействия через FIFO (также называемые <emphasis>именованными
          каналами</emphasis>).  FIFO отображаются как объекты файловой
          системы, которые могут быть открыты несвязанными процессами, и в
          которые можно открывать и посылать данные так же, как в случае
          каналов.  Таким образом, FIFO не требуют общего родительского
          процесса для установки соединения; они могут быть соединены после
          того, как будут запущены два процесса.  В отличие от сокетов, FIFO
          могут быть использованы только на локальной машине; они не могут быть
          использованы для связи между процессами, работающими на разных
          машинах.  FIFO реализованы в 4.4BSD, потому что это требует стандарт
          POSIX.1.  Их функциональность является подмножеством функций
          интерфейса сокетов.</para>

	<para>Механизм сокетов требует расширения традиционных для UNIX
          системных вызовов ввода/вывода для обеспечения соответствующих имен и
          смыслов соединениям.  Вместо того, чтобы перегружать существующий
          интерфейс, разработчики использовали существующие интерфейсы,
          расширив их так, что они продолжили работать без изменений, и
          разработали новые интерфейсы для работы с новыми возможностями.
	  Системные вызовы <emphasis>read</emphasis> и
	  <emphasis>write</emphasis> использовались для соединений типа потока
          байт, и было добавлено шесть новых системных вызовов, что позволило
          посылать и принимать адресованные сообщения, такие, как сетевые
          датаграммы.  Системные вызовы для записи сообщений включают в себя
	  <emphasis>send</emphasis>, <emphasis>sendto</emphasis> и
	  <emphasis>sendmsg</emphasis>.  Системные вызовы для чтения сообщений
          включают <emphasis>recv</emphasis>, <emphasis>recvfrom</emphasis> и
	  <emphasis>recvmsg</emphasis>.  В ретроспективе, первые два в каждом
          классе являются особыми случаями других;
          <emphasis>recvfrom</emphasis> и <emphasis>sendto</emphasis>,
          наверное, должны были быть добавлены как библиотечные интерфейсы к
	  <emphasis>recvmsg</emphasis> и <emphasis>sendmsg</emphasis>,
          соответственно.</para>
      </sect2>
      
      <sect2>
	<title>Множественный ввод/вывод</title>
	
	<para>Кроме традиционных системных вызовов <emphasis>read</emphasis> и
	  <emphasis>write</emphasis>, в 4.2BSD появилась возможность выполнять
          множественный ввод/вывод.  Множественный ввод использует системный
          вызов <emphasis>readv</emphasis> для размещения результата
          единственной операции чтения в нескольких различных буферах.
          Обратно, системный вызов <emphasis>writev</emphasis> позволяет
          осуществлять запись нескольких различных буферов за одну атомарную
          операцию записи.  Вместо передачи одного буфера и его длины в
          качестве параметров, как это делается при использовании системных
          вызовов <emphasis>read</emphasis> и <emphasis>write</emphasis>,
          процесс передает указатель на массив буферов и их длин, а также
          счетчик, определяющий размер массива.</para>

	<para>Такой механизм позволяет буферам в различных областях адресного
          пространства процесса записываться атомарно, без необходимости
          копировать их в один буфер.  Атомарные операции записи необходимы в
          случае, когда низкоуровневые абстракции основаны на записях,
          например, стримеры, которые выводят блок ленты при каждом запросе на
          запись.  Также полезна возможность помещать результат одного запроса
          на чтение в нескольких различных буферах (например, заголовок записи
          в одно место, а данные в другое).  Хотя приложение может симулировать
          возможность выполнять множественные операции посредством чтения
          данных в большой буфер с последующим копированием их частей в
          нужные области, и накладные расходы на копирование в памяти в таких
          случаях часто увеличивает время выполнения приложения чуть ли не
          вдвое.</para>

	<para>Так же, как <emphasis>send</emphasis> и <emphasis>recv</emphasis>
	  могут быть реализованы в виде библиотечных интерфейсов к
	  <emphasis>sendto</emphasis> и <emphasis>recvfrom</emphasis>, возможно
          симулирование <emphasis>read</emphasis> через
          <emphasis>readv</emphasis> и <emphasis>write</emphasis> через
	  <emphasis>writev</emphasis>.  Однако <emphasis>read</emphasis> и
	  <emphasis>write</emphasis> используются столь часто, что накладные
          расходы на такую симуляцию не стоят того.</para>
      </sect2>
      
      <sect2>
	<title>Поддержка нескольких файловых систем</title>
	
	<para>Вместе с распространением сетевых вычислений возникла потребность
          в поддержке как локальных, так и удаленных файловых систем.  Для
          облегчения поддержки нескольких файловых систем разработчики добавили
          в ядро интерфейс виртуальных узлов файловой системы, или
          интерфейс <emphasis>vnode</emphasis>.  Набор операций, экспортируемых
          через интерфейс vnode, похож на операции файловой системы, ранее
          поддерживаемые локальной файловой системой.  Однако они могут
          поддерживаться широким спектром типов файловых систем:</para>

	<itemizedlist>
	  <listitem>
	    <para>Локальные файловые системы, использующие диск</para>
	  </listitem>
	  
	  <listitem>
	    <para>Файлы, импортируемые при помощи разнообразных протоколов
              удаленных файловых систем</para>
	  </listitem>
	  
	  <listitem>
	    <para>Файловые системы CD-ROM, доступные только для чтения</para>
	  </listitem>
	  
	  <listitem>
	    <para>Файловые системы, предоставляющие специализированные услуги
              -- к примеру, файловая система <filename>/proc</filename></para>
	  </listitem>
	</itemizedlist>
	
	<para>Некоторые варианты 4.4BSD, такие, как FreeBSD, позволяют
          выполнять динамическую загрузку файловых систем при первом обращении
          к ним при помощи системного вызова <emphasis>mount</emphasis>.
          Интерфейс vnode описан в Разделе 6.5; вдобавок он поддерживает
          функции, описанные в Разделе 6.6; некоторые из файловых систем
          специального назначения описаны в Разделе 6.7.</para>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Файловые системы</title>

      <para>Обычный файл представляет собой массив байтов, и может читаться и
        записываться, начиная с произвольного байта файла.  Ядро не различает
        в обычных файлах границ записей, хотя многие программы воспринимают
        символы перевода строки в качестве признаков конца строк, но другие
        программы могут предполагать наличие других структур.  В самом файле
        не хранится никакой системной информации о файле, но в файловой системе
        размещается некоторая информация о владельце, правах доступа и об
        использовании каждого файла.</para>

      <para>Компонент под названием <emphasis>имя файла</emphasis> является
        строкой длиной до 255 символов.  Эти имена хранятся в файле особого
        типа, который называется <emphasis>каталогом</emphasis>.  Информация о
        файле в каталоге называется <emphasis>записью каталога</emphasis> и
        включает, кроме имени файла, указатель на сам файл.  Записи каталога
        могут ссылаться как на другие каталоги, так и на обычные файлы.  Таким
        образом формируется иерархия каталогов и файлов, которая и называется
        файловой системой <emphasis>filesystem</emphasis>;</para>

      <figure id="fig-small-fs">
        <title>Небольшая файловая система</title>

        <mediaobject>
          <imageobject>
	    <imagedata fileref="fig2" format="EPS">
          </imageobject>
	
	  <textobject>
	    <literallayout class="monospaced">                                    +-------+
                                    |       |
                                    +-------+
                                   /         \
                              usr /           \ vmunix
                                |/             \|
                        +-------+               +-------+
                        |       |               |       |
                        +-------+               +-------+
                       /    |    \
                staff /     |     \ bin
                    |/      | tmp  \|
            +-------+       V       +-------+
            |       |   +-------+   |       |
            +-------+   |       |   +-------+
           /    |    \  +-------+  /    |    \
 mckusick /     |     \|         |/     |     \ ls
        |/      | karels                | vi   \|
+-------+       V                       V       +-------+
|       |   +-------+               +-------+   |       |
+-------+   |       |               |       |   +-------+
            +-------+               +-------+
            </literallayout>
	  </textobject>
	
	  <textobject>
	    <phrase>Дерево небольшой файловой системы</phrase>
	  </textobject>
        </mediaobject>
      </figure>
    
      <para>Одна небольшая файловая система показана на <xref
        linkend="fig-small-fs">.  Каталоги могут содержать подкаталоги, и нет
        ограничений вложенности одного каталога в другой по глубине.  Для
        соблюдения целостности файловой системы, ядро не позволяет процессу
        производить запись непосредственно в каталоги.  Файловая система может
        хранить не только обычные файлы и каталоги, но также ссылки на другие
        объекты, такие, как устройства и сокеты.</para>

      <para>Файловая система образует дерево, начало которого находится в
        <emphasis>корневом каталоге</emphasis>, иногда называемому по имени
        <emphasis>слэш</emphasis>, которое соответствует символу одинарной
        наклонной черты (/).  Корневой каталог содержит файлы; в нашем примере
        на Рисунке 2.2, он содержит <filename>vmunix</filename>, копию
        выполнимого объектного файла ядра.  В нем также расположены каталоги;
        в этом примере он содержит каталог <filename>usr</filename>.  Внутри
        каталога <filename>usr</filename> располагается каталог
        <filename>bin</filename>, который в основном содержит выполнимый
        объектный код программ, таких, как
        <!-- FIXME -->
        <filename>ls</filename> и <filename>vi</filename>.</para>

      <para>Процесс обращается к файлу, указывая <emphasis>путь</emphasis> до
        него, который является строкой, состоящей из нескольких или ни одного
        имен файлов, разделенных символами слэша (/).  С каждым процессом ядро
        связывает два каталога, при помощи которых можно интерпретировать
        маршруты до файлов.  <emphasis>Корневой каталог</emphasis> процесса
        является самой верхней точкой файловой системы, которую может достичь
        процесс; обычно он соответствует корневому каталогу всей файловой
        системы.  Маршрут, начинающийся с символа слэша, называется
        <emphasis>абсолютным маршрутом</emphasis>, и интерпретируется ядром,
        начиная с корневого каталога процесса.</para>

      <para>Имя пути, которое не начинается со слэша, называется
        <emphasis>относительным маршрутом</emphasis>, и интерпретируется
        относительно <emphasis>текущего рабочего каталога</emphasis> процесса.
        (Этот каталог кратко также называют <emphasis>текущим
        каталогом</emphasis> или <emphasis>рабочим каталогом</emphasis>.)
        Текущий каталог сам по себе можно обозначить непосредственно по имени
        <emphasis>dot</emphasis>, что соответствует одной точке
        (<filename>.</filename>).  Имя файла <emphasis>dot-dot</emphasis>
        (<filename>..</filename>) обозначает родительский каталог текущего
        каталога.  Корневой каталог является предком самому себе.</para>

      <para>Процесс может задать собственный корневой каталог при помощи
        системного вызова <emphasis>chroot</emphasis>, и установить текущий
        каталог системным вызовом <emphasis>chdir</emphasis>.  Каждый процесс
        может в любой момент выполнить вызов <emphasis>chdir</emphasis>, но
        <emphasis>chroot</emphasis> позволено выполнять только процессу с
        административными привилегиями.  <emphasis>Chroot</emphasis> обычно
        используется для ограничения доступа к системе.</para>

      <para>Взяв файловую систему, изображенную на Рисунке 2.2, и полагая, что
        процесс имеет в качестве корневого каталога корневой каталог файловой
        системы, и в качестве текущего каталога <filename>/usr</filename>,
        он может обратиться к файлу <filename>vi</filename> либо от корня по
        абсолютному имени <filename>/usr/bin/vi</filename>, либо из текущего
        каталога с относительным именем <filename>bin/vi</filename>.</para>

      <para>Системные утилиты и базы данных располагаются в нескольких всем
        известных каталогах.  Частью предопределенной иерархии является
        каталог, содержащий <emphasis>домашний каталог</emphasis> для каждого
        пользователя -- например, <filename>/usr/staff/mckusick</filename> и
        <filename>/usr/staff/karels</filename> на Рисунке 2.2.  Когда
        пользователи регистрируются в системе, то рабочий каталог их командного
        процессора устанавливается в домашний каталог.  В своих домашних
        каталогах пользователи могут создавать каталоги так же легко, как и
        обычные файлы.  Таким образом, пользователь может строить иерархии
        каталогов произвольной сложности.</para>

      <para>Пользователь обычно знает только об одной файловой системе, но
        система может знать, что одна виртуальная файловая система на самом
        деле состоит из нескольких физических файловых систем, каждая из
        которых расположена на отдельном устройстве.  Физическая файловая
        система не может располагаться на нескольких физических устройствах.
        Так как большинство физических дисковых устройств разбиваются на
        несколько логических устройств, то на одном физическом устройстве может
        располагаться более одной файловой системы, но не более одной для
        каждого логического устройства.  Одна из файловых систем -- та, с
        которой начинаются все абсолютные имена -- называется
        <emphasis>корневой файловой системой</emphasis>, и она всегда доступна.
        Другие файловые системы могут монтироваться; это значит, что они могут
        интегрироваться в иерархию каталогов корневой файловой системы.  Ссылки
        на каталог, в котором находится смонтированная в него файловая системе,
        прозрачно преобразуются ядром в ссылки на корневой каталог
        смонтированной файловой системы.</para>

      <para>Системный вызов <emphasis>link</emphasis> в качестве параметров
        принимает имя существующего файла и новое имя, которое будет присвоено
        файлу.  После успешного выполнения вызова <emphasis>link</emphasis>,
        файл может быть доступен по любому из имен.  Имя файла может быть
        удалено при помощи системного вызова <emphasis>unlink</emphasis>.
        Когда удаляется последнее имя для файла (и последний процесс, который
        держал файл открытым, закрыл его), удаляется и сам файл.</para>

      <para>Файлы организованы иерархически в <emphasis>каталоги</emphasis>.
        Каталог является типом файла, но, в отличие от обычных файлов, каталог
        имеет структуру, определяемую системой.  Процесс может читать каталог,
        как будто это обычный файл, но только ядру разрешено изменять каталог.
        Каталоги создаются системным вызовом <emphasis>mkdir</emphasis> и
        удаляются системным вызовом <emphasis>rmdir</emphasis>.  До 4.2BSD
        системные вызовы <emphasis>mkdir</emphasis> и
        <emphasis>rmdir</emphasis> были реализованы как последовательность
        системных вызовов <emphasis>link</emphasis> и
        <emphasis>unlink</emphasis>.  Имелось три причины для добавления
        системных вызовов специально для создания и удаления каталогов:</para>

      <orderedlist>
        <listitem>
          <para>Операция может быть сделана атомарной.  Если система завершила
            работу аварийно, то каталог не может оставаться в промежуточном
            состоянии, что может случиться при последовательном вызове серии
            операций.</para>
        </listitem>
   
        <listitem>
          <para>При работе сетевой файловой системы создание и удаление файлов
            и каталогов должны выполняться атомарно, чтобы могли выполняться
            последовательно.</para>
        </listitem>
   
        <listitem>
          <para>При реализации поддержки не-UNIX файловых систем, таких, как
            файловая система MS-DOS, на другом разделе диска, может оказаться,
            что эта файловая система не поддерживает ссылочных операций.  Хотя
            другие файловые системы могут поддерживать концепцию каталогов,
            скорее всего, они не будут создавать и удалять каталоги со
            ссылками, как это делается в файловой системе UNIX.  Соответственно
            они могут создавать и и удалять каталоги только при наличии явных
            запросов на удаление или создание каталогов.</para>
        </listitem>
      </orderedlist>

      <para>Системный вызов <emphasis>chown</emphasis> устанавливает владельца
        и группу файла, а <emphasis>chmod</emphasis> изменяет атрибуты защиты.
        Вызов <emphasis>stat</emphasis>, примененный к имени файла, может
        использоваться для чтения этих свойств файла.  Системные вызовы
        <emphasis>fchown</emphasis>, <emphasis>fchmod</emphasis> и
        <emphasis>fstat</emphasis> применяются с дескрипторами, а не с именами
        файлов, для выполнения того же самого набора операций.  Системный вызов
        <emphasis>rename</emphasis> может использоваться для присвоения файлу
        нового имени в файловой системе с заменой старого имени файла.  Как и
        операции по созданию и удалению каталогов, системный вызов
        <emphasis>rename</emphasis> был добавлен в 4.2BSD для придания
        атомарности изменению имен в локальной файловой системе.  Позже он
        оправдал свою исключительную полезность для экспортирования операций по
        переименованию в сторонних файловых системах и по сети.</para>

      <para>Системный вызов <emphasis>truncate</emphasis> был добавлен в 4.2BSD
        для того, чтобы файлы могли обрезаться по указанному смещению.  Вызов
        был добавлен первоначально для  поддержки библиотеки времени выполнения
        языка Fortran, в котором применялось понятие конца файла с произвольным
        доступом, который мог устанавливаться в любую позицию, в которой был
        последний раз доступ к файлу.  Без системного вызова
        <emphasis>truncate</emphasis> единственным способом обрезать файл было
        копирование нужной части в новый файл, удаление старого и
        переименование копии в первоначальное имя.  Библиотека могла
        теоретически отказываться работать на заполненной файловой системе, к
        тому же такой алгоритм оказывался медленным.</para>

      <para>После того, как файловая система получила возможность обрезать
        файлы, ядро применяло эту возможность для уменьшения больших пустых
        каталогов.  Преимущество в уменьшении пустых каталогов заключается в
        сокращении времени ядра на поиск в них при создании или удалении
        имен.</para>

      <para>Вновь создаваемым файлам присваивается идентификатор пользователя
        процесса, который их создал, и идентификатор группы каталога, в котором
        они были созданы.  Для защиты файлов применяется трехуровневый механизм
        управления доступом.  Эти три уровня определяют доступность файла
        для</para>

      <orderedlist>
        <listitem>
          <para>Пользователя, который является владельцем файла</para>
        </listitem>
  
        <listitem>
          <para>Группы, которая приписана файлу</para>
        </listitem>
  
        <listitem>
          <para>Всех остальных</para>
        </listitem>
      </orderedlist>

      <para>Каждый уровень доступа имеет отдельные индикаторы прав для чтения,
        записи и выполнения.</para>

      <para>Файлы создаются с нулевым размером, который может увеличиться при
        выполнении операций записи.  Пока файл открыт, система отслеживает
        указатель на файл, соответствующий текущему положению в файле,
        связанном с дескриптором.  Этот указатель может перемешаться по файлу в
        произвольном порядке.  Процессы, использующие один и тот же дескриптор
        файла посредством системных вызовов <emphasis>fork</emphasis> или
        <emphasis>dup</emphasis>, используют одновременно один и тот же
        указатель текущей позиции.  Дескрипторы, созданные различными
        системными вызовами <emphasis>open</emphasis>, имеют различные
        указатели текущей позиции.  В файлах могут присутствовать
        <emphasis>дыры</emphasis>.  Дыры представляют собой пустые пространства
        в теле файла, в которые никаких данных не записывалось.  Процесс может
        создать такие дыры, перемещая указатель за текущий конец файла и
        производя запись.  При чтении дыры интерпретируются системой как
        заполненные нулевыми байтами.</para>

      <para>Ранние версии UNIX имели ограничение в 14 символов на имя файла.
        Это ограничение зачастую вызывало проблемы.  Например, кроме
        естественного желания пользователей давать файлам длинные описательные
        имена, распространенным способом формировать имена файлов является
        использование формата
        <filename><replaceable>basename</replaceable>.<replaceable>extension</replaceable></filename>,
        где расширение (указывающее на тип файла, скажем, <literal>.c</literal>
        для исходного года на языке C или <literal>.o</literal> для
        промежуточного двоичного объекта) имеет длину от одного до трех
        символов, оставляя от 10 до 12 символов на имя файла.  Системы
        управления исходным кодом и редакторы обычно используют дополнительно
        два символа для своих целей, для префикса или суффикса имени файла,
        при этом остается от восьми до 10 символов.  В качестве имени файла
        легко использовать от 10 до 12 символов одного английского слова
        (например, ``multiplexer'').</para>

      <para>Можно смириться с этими ограничениями, но это непоследовательно и
        даже опасно, потому что другие системы UNIX могут работать со строками,
        превышающими этот лимит, при создании файлов, но затем имя будет
        <emphasis>обрезано</emphasis>.  Исходный файл с именем
        <filename>multiplexer.c</filename>, содержащий исходный код на языке C,
        (уже 13 символов) может иметь соответствующий файл из системы
        управления исходным кодом с префиксом <literal>s.</literal>, при этом
        получается имя файла <filename>s.multiplexer</filename>, которое не
        не будет отличаться от файла системы управления исходным кодом для
        файла <filename>multiplexer.ms</filename>, содержащего исходный код
        <!-- FIXME -->
        <literal>troff</literal> для документации программы на языке C.
        Содержимое двух оригинальных файлов может оказаться перепутанным без
        каких-либо предупреждений от системы управления исходным кодом.
        При тщательном кодировании эту проблему можно обнаружить, но поддержка
        длинных имен файлов, впервые появившаяся в 4.2BSD, практически
        полностью ликвидировала эту проблему.</para>
    </sect1>
  
    <sect1>
      <title>Размещение файлов</title>

      <para>Операции, определенные для локальных файловых систем, делятся на
        две категории.  Общими для всех локальных систем являются иерархический
        принцип именования, блокировка, квоты, управление атрибутами и защита.
        Эти механизмы не зависят от того, как хранятся данные.  В 4.4BSD
        имеется единая реализация для предоставления этих сервисов.</para>

      <para>Другой частью локальной файловой системы является организация и
        управление данными на носителях информации.  Размещение содержимого
        файлов на носителях является вопросом хранилища файлов.  В 4.4BSD
        поддерживает три различных типа хранилищ файлов:</para>

      <itemizedlist>
        <listitem>
          <para>Традиционная файловая система Berkeley Fast Filesystem</para>
        </listitem>

        <listitem>
          <para>Журналируемая файловая система, основанная на архитектуре
            операционной системы Sprite <xref
            linkend="biblio-rosenblum"></para>
        </listitem>
   
        <listitem>
          <para>Файловая система в памяти</para>
        </listitem>
      </itemizedlist>

      <para>Хотя организация этих хранилищ совершенно различна, эти различия
        скрыты от процессов, использующих файловые системы.</para>

      <para>В файловой системе Fast Filesystem организует данные в группы
        дорожек.  Файлы, к которым, скорее всего, будет осуществляться доступ
        одновременно (на основе их расположения в иерархии файловой системы),
        хранятся на одной и той же группе дорожек.  Файлы, к которым не
        предполагается одновременный доступ, перемещаются на разные группы
        дорожек.  Таким образом, файлы, записываемые в одно и то же время, могут
        располагаться в абсолютно разных областях диска.</para>

      <para>Файловая система с журнальной организацией организует данные в виде
        журнала.  Все данные, записываемые в некоторый момент времени, собираются
        вместе и записываются в одно и то же место диска.  Данные никогда не
        перезаписываются; вместо этого записывается новая копия файла, которая
        заменяет старую.  Старые файлы уничтожаются процессом-сборщиком мусора,
        который запускается, когда файловая система переполняется и появляется
        необходимость в свободном пространстве.</para>

      <para>Файловая система в памяти предназначена для хранения данных в
        виртуальной памяти.  Она используется для файловых систем, в которых
        должны храниться временные данные с обеспечением быстрого доступа к ним,
        к примеру, <filename>/tmp</filename>.  При организации файловой системы в
        памяти преследуется цель организовать максимально компактное хранение
        данных для минимизации использования ресурсов виртуальной памяти.</para>
    </sect1>
  
    <sect1>
      <title>Сетевая файловая система</title>

      <para>Изначально сетевые возможности использовались для передачи
        данных от одной машины к другой.  Позже это получило свое развитие в
        обеспечении подключения пользователей удаленно к другим машинам.
        Следующим логическим шагом было предоставление данных пользователю,
        а не приближение пользователя к данным -- так родились сетевые файловые
        системы.  Пользователи, работающие локально, не ощущают сетевых
        задержек при каждом нажатии клавиши, так что они получают более удобное
        рабочее окружение.</para>

      <para>Подключение файловой системы к локальной машине было одним из
        первых основных клиент-серверных приложений.
        <emphasis>Сервер</emphasis> является удаленной машиной, которая
        экспортирует одну или более своих файловых систем.
        <emphasis>Клиентом</emphasis> является локальная машина, которая
        импортирует эти файловые системы.  С точки зрения локального клиента,
        смонтированные удаленные файловые системы появляются в пространстве
        имен дерева файлов, как любая другая локально смонтированная файловая
        система.  Локальные клиенты могут перемещаться в каталоги на удаленной
        файловой системе, и могут осуществлять чтение, запись и выполнение
        двоичных файлов на удаленной файловой системе точно так же, как они
        выполняют эти операции на локальной файловой системе.</para>

      <para>Когда локальный клиент выполняет операцию на удаленной файловой
        системе, оформляется и посылается запрос к серверу.  Сервер выполняет
        запрошенную операцию и возвращает либо запрошенную информацию, либо
        ошибку, почему запрос был отклонен.  Для получения удовлетворительной
        производительности, клиент должен кэшировать данные, к которым доступ
        осуществляется часто.  Сложность удаленных файловых систем отражается
        на поддержке соответствия между сервером и множеством его
        клиентов.</para>

      <para>Хотя за эти годы было разработано множество протоколов работы с
        удаленными файловыми системами, самой распространенной на системах UNIX
        является сетевая файловая система Network Filesystem (NFS), которая
        была спроектирована и реализована в Sun Microsystems.  Ядро 4.4BSD
        поддерживает протокол NFS, хотя его реализация была выполнена
        независимо от спецификаций протокола <xref linkend="biblio-macklem">.
        Протокол NFS описан в Главе 9.</para>
    </sect1>
  
    <sect1>
      <title>Терминалы</title>

      <para>Терминалы поддерживают стандартные системные операции ввода/вывода,
        а также набор операций, специфичных для терминалов, для управления
        редактированием входных символов и задержек вывода.  На самом нижнем
        уровне находятся драйверы терминальных устройств, которые управляют
        портами аппаратных терминалов.  Терминальный ввод обрабатывается
        согласно низлежащим характеристикам связи, таким, как скорость
        передачи, и согласно набору программно контролируемых параметров, таких,
        как контроль четности.</para>

      <para>Выше уровня драйверов терминальных устройств находятся режимы
        каналов, которые обеспечивают различные уровни обработки символов.
        По умолчанию режим работы канала выбирается, когда порт используется
        для интерактивного входа в систему.  Режим работы канала
        устанавливается в <emphasis>канонический</emphasis>; входной поток
        обрабатывается так, что обеспечиваются стандартные функции,
        ориентированные на редактирование строк, и он представляется процессу
        в виде целых строк.</para>
      
      <para>Экранные редакторы и программы, которые взаимодействуют с другими
        машинами, обычно работают в <emphasis>неканоническом режиме</emphasis>
	(часто называемом <emphasis>raw-режимом</emphasis> или
	<emphasis>посимвольным режимом</emphasis>).  В этом режиме входной
        поток передается в читающий процесс сразу же и без всякой обработки.
        Выключается вся обработка специальных символов, не выполняется
        удаление символов и другое редактирование строк, все символы передаются
        программе, которая выполняет чтение с терминала.</para>

      <para>Терминал может быть настроен тысячами различных способов,
        промежуточных между этими двумя.  Например, экранный редактор, которому
        необходимо получать прерывания от пользователя асинхронно, может
        разрешить использование специальных символов, которые генерируют
        сигналы и разрешить управление выходным потоком, в противном случае
        работать в неканоническом режиме; все остальные символы будут
        передаваться в процесс необработанными.</para>
      
      <para>Что касается выходного потока, то терминальный обработчик
        предоставляет простые службы по его форматированию, включая</para>

      <itemizedlist>
	<listitem>
	  <para>Преобразование символа перевода строки на двухсимвольную
            последовательность из символов возврата каретки и перевода
            строки</para>
	</listitem>

	<listitem>
	  <para>Выдерживание пауз после некоторых стандартных управляющих
            символов</para>
	</listitem>
	
	<listitem>
	  <para>Замещение символов табуляции</para>
	</listitem>
	
	<listitem>
	  <para>Вывод неграфических символов ASCII в виде двухсимвольных
            последовательностей вида ``^C'' (другими словами, вывод знака
            вставки, за которым следует символ, который находится по смещению
            от символа ``@'', соответствующему значению этого символа).</para>
	</listitem>
      </itemizedlist>

      <para>Каждый из этих сервисов преобразования может быть независимо
        выключен процессом при помощи управляющих запросов.</para>
    </sect1>

    <sect1>
      <title>Коммуникации между процессами</title>
      
      <para>Межпроцессные коммуникации в 4.4BSD организованы в
	<emphasis>коммуникационные домены</emphasis>.  К поддерживаемым на
        данный момент доменам относятся	<emphasis>локальный домен</emphasis>
        для взаимодействия между процессами, выполняющимися на одной и той же
        машине; <emphasis>межсетевой домен</emphasis> для связи между
        процессами посредством набора протоколов TCP/IP (возможно, в сети
        Интернет); семейство протоколов ISO/OSI для взаимодействия между
        сайтами, которым нужна именно такая связь, и <emphasis>домен
        XNS</emphasis> для коммуникаций между процессами при помощи протоколов
	XEROX Network Systems (XNS).</para>

      <para>В пределах домена соединения имеют место между конечными точками
        связи, также называемыми <emphasis>сокетами</emphasis>.  Как отмечено в
        Разделе 2.6, системный вызов <emphasis>socket</emphasis> создает сокет
        и возвращает дескриптор; другие системные вызовы IPC описаны в Главе
        11.  Каждый сокет имеет тип, определяющий его коммуникационные
        свойства; к ним относятся такие характеристики, как надежность,
        сохранение последовательности передаваемой информации и предупреждение
        дублирования сообщений.</para>

      <para>с каждым сокетом связан некоторый <emphasis>коммуникационный
        протокол</emphasis>.  Этот протокол обеспечивает выполнение операций,
        требуемых сокету, согласно его типу.  Приложения могут задавать
        нужный протокол при создании сокета или могут разрешить системе выбрать
        протокол, который соответствует типу создаваемого сокета.</para>

      <para>Сокеты могут иметь адреса, связанные с ними.  Формат и смысл
        адресов сокетов зависят от коммуникационного домена, в котором был
        создан сокет.  Привязка имени к сокету в локальном домене приводит к
        созданию файла в файловой системе.</para>

      <para>Обычные данные, передаваемые и получаемые при помощи сокетов, не
        имеют типа.  Вопросы представления данных зависят от библиотек, которые
        находятся на верху коммуникационных сервисов.  Вдобавок к передаче
        обычных данных, коммуникационные домены могут поддерживать передачу и
        прием специальных типов данных, которые называются <emphasis>правами
        доступа</emphasis>.  Например, локальный домен использует эту
        возможность для передачи дескрипторов между процессами.</para>

      <para>До 4.2BSD сетевые реализации в UNIX обычно работали через
        интерфейсы символьных устройств.  Одной из целей создания интерфейса
        сокетов было обеспечение работы простеньким программам без изменения
        на потоковых соединениях.  Такие программы могут работать, если только
        не меняются системные вызовы <emphasis>read</emphasis> и
	<emphasis>write</emphasis>.  Соответственно, оригинальные интерфейсы
        не трогались, но были исправлены для работы с потоковыми сокетами.
        Для более сложных сокетов, таких, как те, что используются для посылки
        датаграмм и в которых при каждом вызове <emphasis>send</emphasis> должен
        указываться адрес назначения, был добавлен новый интерфейс.</para>
      
      <para>Другим достоинством является то, что новый интерфейс легко
        переносим.  Вскоре после тестового релиза, полученного из Беркли,
        интерфейс сокетов был перенесен в System III поставщиком UNIX (хотя
        AT&amp;T не поддерживала интерфейс сокетов до выхода System V Release
        4, решив использовать вместо него механизм потоков из Eighth Edition).
        Интерфейс сокетов был также перенесен для работы на многих
        адаптерах Ethernet поставщиками, такими, как Excelan и Interlan, который
        продавался на рынке PC, где компьютеры были слишком слабыми, чтобы
        обрабатывать сетевой код на основном процессоре.  Сравнительно недавно
        интерфейс сокетов был использован в качестве основы для сетевого
        интерфейса Winsock от Microsoft для Windows.</para>
    </sect1>
  
    <sect1>
      <title>Сетевые коммуникации</title>

      <para>Некоторые из коммуникационных доменов, поддерживаемых
        IPC-механизмом <emphasis>сокетов</emphasis> дают доступ к сетевым
        протоколам.  Эти протоколы реализованы как отдельный программный слой,
        логически находящийся ниже программного обеспечения сокетов в ядре.
        Ядро предоставляет много вспомогательных сервисов, таких, как
        управление буферами, маршрутизация сообщений, стандартные интерфейсы к
        протоколам и интерфейсы к драйверам сетевых интерфейсов для
        использования в различных сетевых протоколах.</para>

      <para>В те времена, когда разрабатывалась 4.2BSD, использовалось или
        разрабатывалось много сетевых протоколов, каждый со своими сильными и
        слабыми сторонами.  Не существует единственного подходящего на все
        случаи жизни протокола или набора протоколов.  Поддерживая много
        протоколов, 4.2BSD может обеспечить взаимодействие и обмен ресурсами
        между различными машинами, которые были доступны в Беркли.  Поддержка
        многих протоколов необходим также для изменений в будущем.  Современные
        протоколы, разработанные для Ethernet со скоростями работы 10 и 100
        Mbit в секунду, вряд ли будут соответствовать для завтрашних оптических
        сетей пропускной способностью 1 и 10 Gbit в секунду.  Поэтому уровень
        сетевых коммуникаций разработан с учетом поддержки многих протоколов.
        Новые протоколы добавляются к ядру, не затрагивая поддержку старых
        протоколов.  Старые приложения могут продолжать работать с
        использованием старых протоколов в той же самой физической сети, что
        использовалась для новых приложений, работающих с новым сетевым
        протоколом.</para>
    </sect1>
  
    <sect1>
      <title>Сетевая реализация</title>

      <para>Первым набором протоколов, реализованным в 4.2BSD, был
        Transmission Control Protocol/Internet Protocol (TCP/IP) от DARPA.
        CSRG выбрала TCP/IP в качестве первого для включения в набор протоколов
        IPC, потому что реализация на основе 4.1 была всем доступна из проекта,
        спонсируемого DARPA, в Bolt, Beranek и Newman (BBN).  Это был выбор,
        повлиявший на многое: Реализация в 4.2BSD стала основной причиной
        очень широкой распространенности и использования этого набора
        протоколов.  Более поздние усовершенствования производительности и
        возможностей TCP/IP были также широко приняты.  Реализация TCP/IP
        подробно описана в Главе 13.</para>

      <para>В релизе 4.3BSD появился набор протоколов Xerox Network Systems
        (XNS), частично основанный на работе, выполненной в Университете
        Мэрилэнда и Университете Корнелла.  Этот набор был нужен для
        объединения отдельных машин, которые не могли работать с протоколом
        TCP/IP.</para>

      <para>В релиз 4.4BSD был добавлен набор протоколов ISO из-за его все
        большей распространенности как внутри, так и во вне США.  По причине
        использования в протоколах ISO несколько другого подхода к сети, в
        интерфейсе сокетов потребовалось сделать некоторые небольшие изменения
        для реализации этого подхода.  Изменения были сделаны так, что они
        были незаметны для клиентов других существующих протоколов.  Протоколы
        ISO требуют также большой работы с двухуровневыми таблицами
        маршрутизации, имеющимися в 4.3BSD.  К значительно расширенным
        возможностям по маршрутизации в 4.4BSD относятся раздельные уровни
        маршрутизации с адресами переменной длины и сетевыми масками.</para>
    </sect1>
  
    <sect1>
      <title>Работа системы</title>

      <para>Механизмы начальной загрузки используются для запуска системы.
        Сначала ядро 4.4BSD должно быть загружено в основную память процессора.
        После загрузки оно должно пройти через фазу инициализации для установки
        аппаратуры в известное состояние.  Затем ядро должно выполнить
        автоконфигурацию, в процессе которой распознаются и настраиваются
        периферийные устройства, подключенные к процессору.  Система начинает
        работу в однопользовательском режиме, пока начальный скрипт выполняет
        проверку дисков и включает подсчет статистики и использования квот.
        Наконец, начальный скрипт запускает общесистемные службы и переводит
        систему в полностью многопользовательский режим.</para>

      <para>При работе в многопользовательском режиме процессы ждут запросов на
        вход в систему с терминальных линий и сетевых портов, которые были
        настроены на вход пользователей.  После обнаружения запроса на вход,
        вызывается процесс входа в систему и выполняется аутентификация
        пользователя.  Если она прошла успешно, запускается начальная
        оболочка, из которой пользователь может запускать дополнительные
        процессы.</para>
    </sect1>
  
    <bibliography>
      <title>Ссылки</title>

      <biblioentry id="biblio-accetta">
        <abbrev>Accetta et al, 1986</abbrev>
      
        <biblioset relation="article">
  	  <title>Mach: A New Kernel Foundation for UNIX Development"</title>

  	  <authorgroup>
	    <author>
	      <firstname>M. </firstname>
              <surname>Accetta</surname>
	    </author>

            <author>
	      <firstname>R.</firstname>
	      <surname>Baron</surname>
	    </author>
	  
            <author>
	      <firstname>W.</firstname>
	      <surname>Bolosky</surname>
	    </author>

	    <author>
	      <firstname>D.</firstname>
	      <surname>Golub</surname>
	    </author>
	  
            <author>
	      <firstname>R.</firstname>
	      <surname>Rashid</surname>
	    </author>
	  
            <author>
	      <firstname>A.</firstname>
	      <surname>Tevanian</surname>
	    </author>

	    <author>
	      <firstname>M.</firstname>
	      <surname>Young</surname>
	    </author>
	  </authorgroup>

	  <pagenums>93-113</pagenums>
        </biblioset>

        <biblioset relation="journal">
	  <title>USENIX Association Conference Proceedings</title>
	  <publishername>USENIX Association</publishername>
	  <pubdate>June 1986</pubdate>
        </biblioset>
      </biblioentry>

      <biblioentry id="biblio-cheriton">
        <abbrev>Cheriton, 1988</abbrev>
      
        <biblioset relation="article">
	  <title>The V Distributed System</title>
	
	  <author>
	    <firstname>D. R.</firstname>
	    <surname>Cheriton</surname>
	  </author>

	  <pagenums>314-333</pagenums>
        </biblioset>

        <biblioset relation="journal">
	  <title>Comm ACM, 31, 3</title>
	
	  <pubdate>March 1988</pubdate>
        </biblioset>
      </biblioentry>

      <biblioentry id="biblio-ewens">
        <abbrev>Ewens et al, 1985</abbrev>
      
        <biblioset relation="article">
	  <title>Tunis: A Distributed Multiprocessor Operating System</title>

	  <authorgroup>
	    <author>
	      <firstname>P.</firstname>
	      <surname>Ewens</surname>
	    </author>

	    <author>
	      <firstname>D. R.</firstname>
	      <surname>Blythe</surname>
	    </author>

	    <author>
	      <firstname>M.</firstname>
	      <surname>Funkenhauser</surname>
	    </author>

	    <author>
	      <firstname>R. C.</firstname>
	      <surname>Holt</surname>
	    </author>
	  </authorgroup>

	  <pagenums>247-254</pagenums>
        </biblioset>

        <biblioset relation="journal">
          <title>USENIX Assocation Conference Proceedings</title>
	  <publishername>USENIX Association</publishername>
	  <pubdate>June 1985</pubdate>
        </biblioset>
      </biblioentry>

      <biblioentry id="biblio-gingell">
        <abbrev>Gingell et al, 1987</abbrev>
      
        <biblioset relation="article">
	  <title>Virtual Memory Architecture in SunOS</title>

	  <authorgroup>
	    <author>
	      <firstname>R.</firstname>
	      <surname>Gingell</surname>
	    </author>

	    <author>
	      <firstname>J.</firstname>
	      <surname>Moran</surname>
	    </author>

	    <author>
	      <firstname>W.</firstname>
	      <surname>Shannon</surname>
	    </author>
	  </authorgroup>

	  <pagenums>81-94</pagenums>
        </biblioset>

        <biblioset relation="journal">
	  <title>USENIX Association Conference Proceedings</title>
	  <publishername>USENIX Association</publishername>
	  <pubdate>June 1987</pubdate>
        </biblioset>
      </biblioentry>
      
      <biblioentry id="biblio-kernighan">
        <abbrev>Kernighan & Pike, 1984</abbrev>
      
        <title>The UNIX Programming Environment</title>

        <authorgroup>
	  <author>
	    <firstname>B. W.</firstname>
	    <surname>Kernighan</surname>
	  </author>
	
	  <author>
	    <firstname>R.</firstname>
	    <surname>Pike</surname>
	  </author>
        </authorgroup>

        <publisher>
	  <publishername>Prentice-Hall</publishername>
	  <address>
	    <city>Englewood Cliffs</city>
	    <state>NJ</state>
	  </address>
        </publisher>
      
        <pubdate>1984</pubdate>
      </biblioentry>
    
      <biblioentry id="biblio-macklem">
        <abbrev>Macklem, 1994</abbrev>
      
        <biblioset relation="chapter">
	  <title>The 4.4BSD NFS Implementation</title>

	  <author>
	    <firstname>R.</firstname>
	    <surname>Macklem</surname>
	  </author>

	  <pagenums>6:1-14</pagenums>
        </biblioset>

        <biblioset relation="book">
	  <title>4.4BSD System Manager's Manual</title>

	  <publisher>
	    <publishername>O'Reilly &amp; Associates, Inc.</publishername>
	    <address>
	      <city>Sebastopol</city>
	      <state>CA</state>
	    </address>
	  </publisher>

	  <pubdate>1994</pubdate>
        </biblioset>
      </biblioentry>

      <biblioentry id="biblio-mckusick-2">
        <abbrev>McKusick & Karels, 1988</abbrev>
      
        <biblioset relation="article">
	  <title>Design of a General Purpose Memory Allocator for the 4.3BSD
	    UNIX Kernel</title>

	  <authorgroup>
	    <author>
	      <firstname>M. K.</firstname>
	      <surname>McKusick</surname>
	    </author>

	    <author>
	      <firstname>M. J.</firstname>
	      <surname>Karels</surname>
	    </author>
	  </authorgroup>

	  <pagenums>295-304</pagenums>
        </biblioset>

        <biblioset relation="journal">
	  <title>USENIX Assocation Conference Proceedings</title>
	  <publishername>USENIX Assocation</publishername>
	  <pubdate>June 1998</pubdate>
        </biblioset>
      </biblioentry>
    
      <biblioentry id="biblio-mckusick-1">
        <abbrev>McKusick et al, 1994</abbrev>
      
        <biblioset relation="manual">
	  <title>Berkeley Software Architecture Manual, 4.4BSD Edition</title>

	  <authorgroup>
	    <author>
	      <firstname>M. K.</firstname>
	      <surname>McKusick</surname>
	    </author>

	    <author>
	      <firstname>M. J.</firstname>
	      <surname>Karels</surname>
	    </author>

	    <author>
	      <firstname>S. J.</firstname>
	      <surname>Leffler</surname>
	    </author>

	    <author>
	      <firstname>W. N.</firstname>
	      <surname>Joy</surname>
	    </author>

	    <author>
	      <firstname>R. S.</firstname>
	      <surname>Faber</surname>
	    </author>
	  </authorgroup>

	  <pagenums>5:1-42</pagenums>
        </biblioset>

        <biblioset relation="book">
	  <title>4.4BSD Programmer's Supplementary Documents</title>

	  <publisher>
	    <publishername>O'Reilly &amp; Associates, Inc.</publishername>
	    <address>
	      <city>Sebastopol</city>
	      <state>CA</state>
	    </address>
	  </publisher>

	  <pubdate>1994</pubdate>
        </biblioset>
      </biblioentry>

      <biblioentry id="biblio-ritchie">
        <abbrev>Ritchie, 1988</abbrev>
      
        <title>Early Kernel Design</title>
        <subtitle>private communication</subtitle>
      
        <author>
	  <firstname>D. M.</firstname>
	  <surname>Ritchie</surname>
        </author>

        <pubdate>March 1988</pubdate>
      </biblioentry>

      <biblioentry id="biblio-rosenblum">
        <abbrev>Rosenblum & Ousterhout, 1992</abbrev>
      
        <biblioset relation="article">
	  <title>The Design and Implementation of a Log-Structured File
	    System</title>

	  <authorgroup>
	    <author>
	      <firstname>M.</firstname>
	      <surname>Rosenblum</surname>
	    </author>

	    <author>
	      <firstname>K.</firstname>
	      <surname>Ousterhout</surname>
	    </author>
	  </authorgroup>
	
	  <pagenums>26-52</pagenums>
        </biblioset>

        <biblioset relation="journal">
	  <title>ACM Transactions on Computer Systems, 10, 1</title>

	  <publishername>Association for Computing Machinery</publishername>
	  <pubdate>February 1992</pubdate>
        </biblioset>
      </biblioentry>

      <biblioentry id="biblio-rozier">
        <abbrev>Rozier et al, 1988</abbrev>
      
        <biblioset relation="article">
	  <title>Chorus Distributed Operating Systems</title>

	  <authorgroup>
	    <author>
	      <firstname>M.</firstname>
	      <surname>Rozier</surname>
	    </author>

	    <author>
	      <firstname>V.</firstname>
	      <surname>Abrossimov</surname>
	    </author>

	    <author>
	      <firstname>F.</firstname>
	      <surname>Armand</surname>
	    </author>

	    <author>
	      <firstname>I.</firstname>
	      <surname>Boule</surname>
	    </author>

	    <author>
	      <firstname>M.</firstname>
	      <surname>Gien</surname>
	    </author>

	    <author>
	      <firstname>M.</firstname>
	      <surname>Guillemont</surname>
	    </author>

	    <author>
	      <firstname>F.</firstname>
	      <surname>Herrmann</surname>
	    </author>

	    <author>
	      <firstname>C.</firstname>
	      <surname>Kaiser</surname>
	    </author>

	    <author>
	      <firstname>S.</firstname>
	      <surname>Langlois</surname>
	    </author>

	    <author>
	      <firstname>P.</firstname>
	      <surname>Leonard</surname>
	    </author>

	    <author>
	      <firstname>W.</firstname>
	      <surname>Neuhauser</surname>
	    </author>
	  </authorgroup>

	  <pagenums>305-370</pagenums>
        </biblioset>

        <biblioset relation="journal">
	  <title>USENIX Computing Systems, 1, 4</title>
	  <pubdate>Fall 1988</pubdate>
        </biblioset>
      </biblioentry>

      <biblioentry id="biblio-tevanian">
        <abbrev>Tevanian, 1987</abbrev>
      
        <title>Architecture-Independent Virtual Memory Management for Parallel
	  and Distributed Environments: The Mach Approach</title>
        <subtitle>Technical Report CMU-CS-88-106,</subtitle>
      
        <author>
	  <firstname>A.</firstname>
	  <surname>Tevanian</surname>
        </author>

        <publisher>
	  <publishername>Department of Computer Science, Carnegie-Mellon
	    University</publishername>

	  <address>
	    <city>Pittsburgh</city>
	    <state>PA</state>
	  </address>
        </publisher>
      
        <pubdate>December 1987</pubdate>
      </biblioentry>
    </bibliography>
  </chapter>
</book>
