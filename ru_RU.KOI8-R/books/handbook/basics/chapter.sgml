<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/basics/chapter.sgml,v 1.41 2007/06/25 10:41:18 den Exp $

     Original revision: r36653
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Переписал </contrib>
      </author>
    </authorgroup>

    <!-- 10 Mar 2000 -->
    <authorgroup>
      <author>
	<firstname>Алексей</firstname>
	<surname>Зелькин</surname>
	<contrib>Перевод на русский язык: </contrib>
      </author>
      <author>
	<firstname>Алексей</firstname>
	<surname>Докучаев</surname>
      </author>
      <author>
	<firstname>Денис</firstname>
	<surname>Пеплин</surname>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Основы UNIX</title>

  <sect1 id="basics-synopsis">
    <title>Краткий обзор</title>

    <para>В этой главе мы попытаемcя раскрыть основные принципы и команды
      операционной системы FreeBSD.  Большая часть нижеизложенного
      материала в более или менее равной степени применима к любой
      &unix;-подобной операционной системе.  Если вы уверены, что не найдете
      здесь ничего нового для себя, можете смело пропустить эту главу.
      Если же вы новичок, мы настоятельно рекомендуем внимательно
      прочесть это главу.</para>

    <para>Прочитав эту главу, вы узнаете:</para>

    <itemizedlist>
      <listitem>
	<para>Как использовать <quote>виртуальные консоли</quote>
	  FreeBSD.</para>
      </listitem>

      <listitem>
	<para>Как работают права доступа на файлы в &unix; и как следует
	  интерпретировать флаги файлов в ОС &os;.</para>
      </listitem>

      <listitem>
	<para>Иерархия каталогов &os;.</para>
      </listitem>
      <listitem>
	<para>Организация дисков &os;.</para>
      </listitem>
      <listitem>
	<para>Как монтировать и размонтировать файловые системы.</para>
      </listitem>
      <listitem>
	<para>Что такое процессы, даемоны и сигналы.</para>
      </listitem>
      <listitem>
	<para>Что такое командная оболочка (или интерпретатор команд) и
	  как настроить личное рабочее окружение.</para>
      </listitem>
      <listitem>
	<para>Как пользоваться стандартными текстовыми
	  редакторами.</para>
      </listitem>
      <listitem>
	<para>Что такое устройства и файлы устройств.</para>
      </listitem>
      <listitem>
	<para>Какие бинарные форматы используются в &os;.</para>
      </listitem>
      <listitem>
	<para>Как пользоваться справочным руководством для получения
	  дополнительной информации.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="consoles">
    <title>Виртуальные консоли и терминалы</title>
    <indexterm><primary>виртуальные консоли</primary></indexterm>
    <indexterm><primary>терминалы</primary></indexterm>

    <para>FreeBSD можно использовать разными способами.  Один из них &mdash;
      набор команд в текстовом терминале.  Используйте этот способ, и вся
      гибкость и мощь систем &unix; будет в ваших руках.  Этот раздел
      рассказывает о <quote>терминалах</quote>, <quote>консолях</quote> и их
      использовании в FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>Консоль</title>
      <indexterm><primary>консоль</primary></indexterm>

      <para>Если во время установки вы не настроили FreeBSD для автоматического
	запуска графической среды при загрузке, система запросит ввод
	логина сразу после завершения стартовых скриптов.  Вы увидите примерно
	следующее:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>В вашей системе сообщение может быть другим, но очень похожим на
	это.  В данный момент нас интересуют последние две строки.  Вторая с
	конца строка:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>В этой строке содержится немного информации о только что загруженной
	системе.  Это консоль <quote>FreeBSD</quote>, работающей на
	Intel или совместимом процессоре x86
	архитектуры<footnote>
	  <para>Это следует из обозначения <literal>i386</literal>.  Обратите
	    внимание, что даже если FreeBSD работает не на процессоре
	    Intel 386, это обозначение будет <literal>i386</literal>.
	    Здесь показан не тип процессора, а его
	    <quote>архитектура</quote>.</para>
	</footnote>.  Имя этого компьютера (у каждого компьютера &unix; есть
	имя) <hostid>pc3.example.org</hostid>, и в данный момент вы видите
	системную консоль &mdash; терминал
	<devicename>ttyv0</devicename>.</para>

      <para>Наконец, последняя строка всегда:</para>

      <programlisting>login:</programlisting>

      <para>Здесь вам предлагается ввести <quote>имя пользователя</quote>,
	чтобы войти в FreeBSD.  Следующий раздел описывает способ, которым вы
	можете сделать это.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Вход в FreeBSD</title>

      <para>FreeBSD это многопользовательская, многопроцессорная система.  Это
	формальное описание системы, которая может быть использована множеством
	разных людей, одновременно запускающих большое количество программ на
	одном компьютере.</para>

      <para>Любой многопользовательской системе нужен способ отличать каждого
	<quote>пользователя</quote> от остальных.  В FreeBSD (и всех
	&unix;-подобных операционных системах), эта задача решается путем
	<quote>входа</quote> пользователя в систему перед запуском каких-либо
	программ.  У каждого пользователя есть уникальное имя (<quote>имя
	пользователя</quote>) и персональный, секретный ключ
	(<quote>пароль</quote>).  Перед тем, как разрешить пользователю
	выполнять какие-либо программы, FreeBSD запрашивает их оба.</para>

      <indexterm><primary>стартовые скрипты</primary></indexterm>
      <para>Сразу после загрузки FreeBSD и завершения работы стартовых
	скриптов<footnote>
	  <para>Стартовые скрипты &mdash; это программы, запускаемые
	    автоматически во время загрузки FreeBSD.  Их основная задача
	    &mdash; подготовить систему к запуску других программ и запустить
	    настроенные сервисы, которые будут работать в фоновом режиме,
	    выполняя полезную работу.</para>
	</footnote>, система предложит вам ввести имя пользователя:</para>

      <screen>login:</screen>

      <para>В этом примере, предположим что ваше имя пользователя
	<username>john</username>.  Введите <literal>john</literal> в этом
	приглашении и нажмите <keycap>Enter</keycap>.  Далее должно появиться
	приглашение ввести <quote>пароль</quote>:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Введите соответствующий имени <username>john</username> пароль и
	нажмите <keycap>Enter</keycap>.  Пароль <emphasis>не виден</emphasis>!
	Не беспокойтесь об этом.  Это сделано по соображениям
	безопасности.</para>

      <para>Если вы ввели пароль правильно, то сразу же войдете в FreeBSD
	и можете начать выполнять команды.</para>

      <para>Вы увидите сообщение дня (<acronym>MOTD</acronym>, или message of
	the day) за которым последует командная строка (с символом
	<literal>#</literal>, <literal>$</literal>, или <literal>%</literal>).
	Это означает, что вы успешно вошли в FreeBSD.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Множественные консоли</title>

      <para>Запуск команд &unix; из консоли &mdash; это конечно хорошо, но FreeBSD может
	выполнять множество программ одновременно, поэтому наличие одной консоли
	может быть недостатком.  В таком случае очень полезны <quote>виртуальные
	консоли</quote>.</para>

      <para>FreeBSD может быть настроена для работы с несколькими виртуальными
	консолями.  Вы можете переключаться с одной виртуальной консоли на
	другую,	нажимая соответствующие сочетания клавиш на клавиатуре.  У
	каждой консоли есть свой канал вывода и FreeBSD заботится о том, чтобы
	правильно перенаправить ввод с клавиатуры и вывод на монитор, как только
	вы переключитесь с одной консоли на другую.</para>

      <para>Для переключения между консолями зарезервированы специальные
	комбинации клавиш<footnote>
	  <para>Подробное техническое описание деталей работы драйверов консолей
	    FreeBSD и клавиатуры можно найти в &man.syscons.4;, &man.atkbd.4;,
	    &man.vidcontrol.1; и &man.kbdcontrol.1;.  Здесь мы не раскрываем
	    деталей, однако интересующиеся этим вопросом всегда могут обратиться
	    к страницам справочника  за более подробным объяснением того,
	    как это работает.</para>
	</footnote>.  Вы можете использовать сочетания
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, до
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> чтобы
	переключаться между различными виртуальными консолями в FreeBSD.</para>

      <para>При переключении от одной консоли к другой, FreeBSD заботится о
	сохранении и восстановлении вывода на экран.  Результатом является
	<quote>иллюзия</quote> наличия множества <quote>виртуальных</quote>
	экранов и клавиатур, которые могут быть использованы для ввода и запуска
	команд FreeBSD.  Программы, которые вы запускаете на одной виртуальной
	консоли, не прекращают выполнение, когда консоль становится невидимой.
	Они продолжают выполняться, когда вы переключаетесь на другую
	виртуальную консоль.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>Файл <filename>/etc/ttys</filename></title>

      <para>В конфигурации по умолчанию FreeBSD запускает восемь виртуальных
	консолей. Тем не менее, это не ограничение оборудования, и вы можете
	легко настроить систему  для загрузки большего или меньшего числа
	виртуальных консолей.  Число и параметры виртуальных консолей задаются
	в файле <filename>/etc/ttys</filename>.</para>

      <para>Вы можете использовать это файл для настройки виртуальных консолей
	FreeBSD.  Любая не закомментированная строка в этом файле
	(строка, не начинающаяся с символа <literal>#</literal>), содержит
	настройки для одного терминала или виртуальной консоли.  Версия этого
	файла по умолчанию, поставляемая с FreeBSD, содержит настройки для
	девяти
	виртуальных консолей и включает восемь терминалов.  Это строки, начинающиеся с
	<literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>За детальным описанием каждой колонки этого файла и всех опций,
	которые можно указать для настройки виртуальных консолей, обращайтесь
	к &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Консоль в однопользовательском режиме</title>

      <para>Детальное описание <quote>однопользовательского режима</quote>
	можно найти в <xref linkend="boot-singleuser">.  Стоит отметить, что
	при работе FreeBSD в однопользовательском режиме есть только одна
	консоль.  Виртуальных консолей нет.  Установки консоли в
	однопользовательском режиме можно найти в файле
	<filename>/etc/ttys</filename>.  Обратите внимание на строку,
	начинающуюся с <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
	<para>Как сказано в комментариях выше строки <literal>console</literal>,
	  можно отредактировать эту строку и изменить <literal>secure</literal>
	  на <literal>insecure</literal>.  Если вы сделаете это, FreeBSD даже
	  при загрузке в однопользовательском режиме будет запрашивать пароль
	  <username>root</username>.</para>

	<para><emphasis>Будьте осторожны при изменении этого значения на
	  <literal>insecure</literal></emphasis>.  Если вы забудете
	  пароль <username>root</username>, загрузка в однопользовательский
	  режим сильно усложнится.  Это все еще возможно, но несколько
	  более сложно для тех, кто еще не очень освоился с процессом
	  загрузки FreeBSD и вызова программ.</para>
      </note>
    </sect2>

    <sect2 id="consoles-vidcontrol">
      <title>Изменение видеорежимов консоли</title>

      <para>Установленный по умолчанию размер изображения для консоли FreeBSD
	может быть изменен до значения 1024x768, 1280x1024, или любого
	другого, который поддерживается вашим монитором и видеокартой.
	Для того, чтобы задействовать иной видеорежим, вам прежде всего
	необходимо будет пересобрать ядро вашей системы, добавив в файл
	конфигурации две дополнительные опции:</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>После пересборки и установки ядра воспользуйтесь утилитой
	&man.vidcontrol.1; для определения видеорежимов, поддерживаемых
	вашим оборудованием.  Чтобы получить перечень видеорежимов,
	выполните следующую команду:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Команда отобразит список поддерживаемых видеорежимов.  Теперь
	вы можете выбрать один из них и установить его на консоли при помощи
	&man.vidcontrol.1;:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Если новый видеорежим вас устраивает, то его можно определить
	устанавливаемым автоматически во время старта системы, для чего
	добавьте в <filename>/etc/rc.conf</filename> следующую строку:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Права доступа</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD является прямым потомком BSD &unix; и основывается на
      некоторых ключевых концепциях &unix;.  В первую очередь это, конечно,
      тот факт, что FreeBSD &ndash; многопользовательская операционная система.
      Это означает, что несколько пользователей могут работать одновременно,
      решая различные задачи и совершенно не мешая друг другу.  На системе
      лежит ответственность за правильное разделение и управление такими
      ресурсами как память, процессорное время, периферийные устройства и
      прочее.</para>

    <para>Многопользовательская среда предполагает наличие механизма
      регулирования прав доступа к любому ресурсу в системе.  Существует три
      типа прав доступа: на чтение, запись и исполнение.  Права
      сгруппированы три по три, соответственно чтение/запись/выполнение для
      владельца/группы/всех остальных.  Численное представление:</para>

    <indexterm><primary>права доступа</primary></indexterm>
    <indexterm>
      <primary>права на файлы</primary>
    </indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Значение</entry>
	    <entry>Права доступа</entry>
	    <entry>Список файлов каталога</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Ничего не разрешено</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Нельзя читать и писать, разрешено исполнять</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Нельзя читать и исполнять, разрешено писать</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Нельзя читать, разрешено писать и исполнять</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Разрешено читать, нельзя писать и исполнять</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Разрешено читать и исполнять, нельзя писать</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Разрешено читать и писать, нельзя исполнять</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Разрешено все</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>каталоги</primary></indexterm>

    <para>Вы можете использовать опцию <option>-l</option> команды
      &man.ls.1; для получения подробного листинга каталога, включающего
      колонку с информацией о правах на файл для владельца, группы и
      всех остальных.  Например, команда <command>ls -l</command>
      в произвольном каталоге может вывести следующее:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Вот как выглядит первая колонка вывода
      <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>Первый (считая слева) символ говорит обычный ли это файл, каталог,
      символьное устройство, сокет или любое другое псевдо-файловое
      устройство.  В нашем случае <literal>-</literal> указывает на обычный
      файл.  Следующие три символа (в данном случае это <literal>rw-</literal>)
      задают права доступа владельца файла.  Затем идут права группы,
      которой принадлежит файл (<literal>r--</literal>).  Последняя тройка
      (<literal>r--</literal>) определяет права для всех остальных.  Минус
      означает отсутствие каких-либо прав (т.е. нельзя ни читать, ни писать, ни
      выполнять).  В данном случае права установлены таким образом, что
      владелец может читать и писать в файл, а группа и другие могут только
      читать.  Таким образом, численное представление прав
      <literal>644</literal>, где каждая цифра представляет три части
      прав на файл.</para>

    <para>Права на устройства контролируются аналогичным образом.  В
      FreeBSD все устройства представлены в виде файлов, которые можно
      открывать, читать и писать в них.  Эти специальные файлы содержатся в
      каталоге <filename>/dev</filename>.</para>

    <para>Каталоги также являются файлами.  К ним применимы
      те же права на чтение, запись и выполнение.  Правда, в данном случае
      <quote>выполнение</quote> имеет несколько другой смысл.  Когда
      каталог помечен как <quote>исполнимый</quote>, это означает, что
      можно <quote>зайти</quote> в него (с помощью команды
      <command>cd</command>, change directory).  Это также означает, что в данном каталоге
      можно получить доступ к файлам, имена которых известны (конечно,
      если собственные права на файл разрешают такой доступ).</para>

    <para>Если же требуется получить список файлов в некотором
      каталоге, права доступа на него должные включать доступ на
      чтение.  Для того, чтобы удалить из каталога какой-либо файл,
      имя которого известно, на этот каталог должны быть даны права
      на запись <emphasis>и</emphasis> на исполнение.</para>

    <para>Существуют и другие права доступа, но они как правило используются
      в особых случаях, например, setuid-бит на выполняемые файлы и sticky-бит
      на каталоги.  За дополнительными сведениями по этому вопросу обращайтесь
      к &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Предоставил </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Символические обозначения прав</title>
      <indexterm>
	<primary>права доступа</primary><secondary>символические</secondary>
      </indexterm>

      <para>Символические обозначения, иногда называемые символическими
	выражениями, используют буквы вместо восьмеричных значений для
	назначения прав на файлы и каталоги.  Символические выражения
	используют синтаксис (кто) (действие) (права), где существуют
	следующие значения:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Опция</entry>
	      <entry>Буква</entry>
	      <entry>Значение</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(кто)</entry>
	    <entry>u</entry>
	    <entry>Пользователь (User)</entry>
	  </row>

	  <row>
	    <entry>(кто)</entry>
	    <entry>g</entry>
	    <entry>Группа (Group)</entry>
	  </row>

	  <row>
	    <entry>(кто)</entry>
	    <entry>o</entry>
	    <entry>Другие (Other)</entry>
	  </row>

	  <row>
	    <entry>(кто)</entry>
	    <entry>a</entry>
	    <entry>Все (All, <quote>world</quote>)</entry>
	  </row>

	  <row>
	    <entry>(действие)</entry>
	    <entry>+</entry>
	    <entry>Добавление прав</entry>
	  </row>

	  <row>
	    <entry>(действие)</entry>
	    <entry>-</entry>
	    <entry>Удаление прав</entry>
	  </row>

	  <row>
	    <entry>(действие)</entry>
	    <entry>=</entry>
	    <entry>Явная установка прав</entry>
	  </row>

	  <row>
	    <entry>(права)</entry>
	    <entry>r</entry>
	    <entry>Чтение (Read)</entry>
	  </row>

	  <row>
	    <entry>(права)</entry>
	    <entry>w</entry>
	    <entry>Запись (Write)</entry>
	  </row>

	  <row>
	    <entry>(права)</entry>
	    <entry>x</entry>
	    <entry>Выполнение (Execute)</entry>
	  </row>

	  <row>
	    <entry>(права)</entry>
	    <entry>t</entry>
	    <entry>Sticky бит</entry>
	  </row>

	  <row>
	    <entry>(права)</entry>
	    <entry>s</entry>
	    <entry>SUID или SGID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Эти значения используются командой &man.chmod.1; так же
      как и раньше, но с буквами.  Например, вы можете использовать
      следующую команду для запрета доступа других пользователей к
      <replaceable>FILE</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Для изменения более чем одного набора прав можно применить список,
      разделенный запятыми.  Например, следующая команда удалит права группы
      и <quote>всех остальных</quote> на запись в
      <replaceable>FILE</replaceable>, а затем добавит права на выполнение для
      всех:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>
<!--
    <para>Большинство пользователей не знают об этом, но необходимо отметить, что
      при использовании восьмеричного метода права на файл будут установлены явно,
      а не добавлены или удалены.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Текст предоставил </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Флаги файлов в &os;</title>

      <para>Кроме уже описанных прав доступа к файлам, &os; поддерживает
	использование <quote>флагов файлов</quote>.  Эти флаги обеспечивают
	дополнительный уровень защиты и контроля над файлами, но не могут
	применяться к каталогам.</para>

      <para>Эти флаги добавляют дополнительные возможности контроля над
	файлами, обеспечивая (при определенных условиях) невозможность их
	удаления или изменения даже пользователю <username>root</username>.</para>

      <para>Файловые флаги изменяются при помощи утилиты &man.chflags.1;
	посредством простого интерфейса.  К примеру, чтобы установить
	системный признак неудаляемости на файл <filename>file1</filename>,
	выполните следующую команду:</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>file1</filename></userinput></screen>

      <para>Чтобы отключить флаг неудаляемости, просто выполните предыдущую
	команду с ключом <quote>no</quote> перед параметром
	<option>sunlink</option>.  Вот так:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>file1</filename></userinput></screen>

      <para>Чтобы просмотреть флаги этого файла, воспользуйтесь командой
	&man.ls.1; с параметрами <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>file1</filename></userinput></screen>

      <para>Результат выполнения команды должен выглядеть примерно так:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Некоторые флаги могут быть установлены или сняты с файлов только
	пользователем <username>root</username>.  В остальных случаях эти флаги
	может установить владелец файла.  Для получения дополнительной
	информации мы рекомендуем изучить содержимое справки по командам
	&man.chflags.1; и &man.chflags.2;.</para>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Текст предоставил </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>setuid, setgid и sticky-биты в правах доступа</title>

      <para>В дополнение к рассмотренным выше правам доступа и флагам файлов
	необходимо также упомянуть еще три бита прав доступа, о которых должны
	знать все системные администраторы.  Это такие биты, как
	<literal>setuid</literal>, <literal>setgid</literal> и
	<literal>sticky</literal>.</para>

      <para>Эти биты играют важную роль в определённых моментах работы
	&unix;, так как они предоставляют функциональность, расширяющую
	права обычного пользователя.  Чтобы понять как они работают, необходимо
	определить различие между реальным идентификатором пользователя
	(<acronym>UID</acronym>) и действующим идентификатором пользователя
	(effective UID, <acronym>EUID</acronym>).</para>

      <para>Реальный <acronym>UID</acronym> &mdash; это идентификатор
	пользователя, запустившего процесс на выполнение.  Действующий
	UID (<acronym>EUID</acronym>) &mdash; это идентификатор пользователя,
	с которым на самом деле выполняется процесс.  Например, утилита
	&man.passwd.1; во время смены пароля пользователем запускается
	с реальным ID пользователя; однако, чтобы внести изменения в базу
	данных пользователей, ей необходимо работать с действующим ID
	пользователя <username>root</username>.  Это тот механизм, который
	позволяет обычным пользователям изменять свои пароли и при этом
	не наблюдать ошибку <errorname>Permission Denied</errorname>.</para>

      <note>
	<para>Опция <literal>nosuid</literal>, указанная при монтировании
	  файловой системы, отменяет действие битов
	  <literal>setuid</literal> и <literal>setgid</literal>.
	  То есть, утилиты, использующие эти биты прав, откажутся выполняться,
	  даже не выдав пользователю никакого предостережения.  К тому же,
	  (с точки зрения обеспечения безопасности) эта опция монтирования
	  не является абсолютно надежной, так как, согласно странице
	  справочника &man.mount.8;, накладываемые ею ограничения могут быть
	  обойдены при помощи <quote>обертки</quote> <literal>nosuid</literal>
	  (<literal>nosuid</literal> wrapper).</para>
      </note>

      <para>Бит setuid устанавливается добавлением цифры четыре (4) перед
	численным представлением прав доступа, например:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>Теперь права доступа на файл
	<filename><replaceable>suidexample.sh</replaceable></filename>
	выглядят подобно следующему:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>В вышеприведенной строке приметно то, что в перечне прав доступа
	для владельца файла присутствует символ <literal>s</literal>,
	который заменил собой бит выполнения.
	<!-- "This allows utilities which need elevated permissions,
	such as <command>passwd</command>." - - something's missing here,
	isn't it? --></para>

      <para>Чтобы посмотреть <literal>setuid</literal> в действии,
	откройте два терминала.  На одном из них запустите команду
	<command>passwd</command> с правами обычного пользователя.  Пока
	утилита ждет ввода нового пароля, просмотрите таблицу процессов
	и найдите в ней запись о процессе <command>passwd</command>.</para>

      <para>В терминале А:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>В терминале Б:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Как уже было сказано, утилита <command>passwd</command> запущена
	с правами обычного пользователя, но ее действующий
	<acronym>UID</acronym> &mdash; <username>root</username>.</para>

      <para>Действие бита <literal>setgid</literal> подобно действию
	<literal>setuid</literal>; отличие заключается в том, что изменяются
	настройки прав для группы.  Когда выполняется приложение (или утилита)
	с установленным битом <literal>setgid</literal>, то ему (ей)
	будут обеспечены права в соответствии с группой владельца файла,
	а не с группой пользователя, запустившего процесс.</para>

      <para>Чтобы установить на файл бит <literal>setgid</literal>,
	выполните команду <command>chmod</command>, добавив цифру два (2)
	перед численным представлением прав доступа, например:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Новый бит отображается подобно предыдущему случаю: обратите
	внимание на наличие <literal>s</literal> в перечне прав доступа
	для группы:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
	<para>В этих примерах, несмотря на то, что сценарий оболочки является
	  исполняемым файлом, он не будет выполняться с другим действующим
	  идентификатором пользователя (<acronym>EUID</acronym>).  Так
	  происходит потому, что сценариям командного интерпретатора недоступен
	  системный вызов &man.setuid.2;.</para>
      </note>

      <para>Позволяя расширять права пользователя, оба бита прав доступа
	(<literal>setuid</literal> и <literal>setgid</literal>) могут привести
	к снижению безопасности системы.  Третий обсуждаемый здесь бит
	&mdash; <literal>sticky</literal> &mdash; способствует повышению
	безопасности системы.</para>

      <para>Бит <literal>sticky</literal>, будучи установленным на каталог,
	позволяет производить удаление файла только владельцу файла.  Этот
	бит применяется для предотвращения удаления файлов в публичных
	каталогах, таких как <filename class="directory">/tmp</filename>,
	пользователями, не владеющими файлом.  Чтобы задействовать этот
	бит, добавьте единицу (1) перед численным представлением прав
	доступа.  Например:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Проверить результат можно при помощи команды
	<command>ls</command>:</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

      <para>Отличительной особенностью бита <literal>sticky</literal>
	является наличие символа <literal>t</literal> в самом конце перечня
	прав.</para>
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>Структура каталогов</title>
    <indexterm><primary>иерархия каталогов</primary></indexterm>

    <para>Файловая система FreeBSD является ключевым моментом в понимании
      устройства всей системы.  Самым важным понятием является, несомненно,
      корневой каталог, обозначаемый символом <quote>/</quote>.
      Корневой каталог монтируется самым первым на этапе загрузки и содержит
      все необходимое, чтобы подготовить систему к загрузке в
      многопользовательский режим.  Корневой каталог также содержит точки
      монтирования для остальных файловых систем, которые монтируются
      во время перехода в многопользовательский режим.</para>

    <para>Точкой монтирования называется каталог, находящийся
      в родительской (обычно &mdash; корневой) файловой системе, к которому
      может быть подсоединена другая файловая система.
      Более детально это описывается в <xref linkend="disk-organization">.
      Стандартные точки монтирования включают <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> и
      <filename>/cdrom</filename>.  Эти каталоги обычно перечислены в
      файле <filename>/etc/fstab</filename>, в котором указаны файловые
      системы и их точки монтирования.  Большинство файловых систем,
      описанных в <filename>/etc/fstab</filename> монтируются автоматически
      из скрипта &man.rc.8;, если только для них не указана опция
      <option>noauto</option>.  Более детальная информация находится в
      <xref linkend="disks-fstab">.</para>

    <para>Полное описание иерархии файловой системы есть в &man.hier.7;.
      Здесь же мы упомянем лишь наиболее важные каталоги.</para>

    <para>
      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Каталог</entry>
	      <entry>Описание</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
	    <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Корневой каталог файловой системы.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Основные утилиты, необходимые для работы как в
		однопользовательском, так и в многопользовательском
		режимах.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Программы и конфигурационные файлы, необходимые для
		нормальной загрузки операционной системы.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Конфигурационные файлы с настройками по умолчанию,
		используемые в процессе загрузки операционной системы
		(см. &man.loader.conf.5;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Файлы устройств (см. &man.intro.4;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Основные конфигурационные файлы системы и
		скрипты.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Основные конфигурационные файлы системы
		с настройками по умолчанию (см. &man.rc.8;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Конфигурационные файлы для систем обработки
		почты (например, &man.sendmail.8;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Конфигурационные файлы для утилиты
		<command>named</command> (см. &man.named.8;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>Файлы сценариев, выполняемые ежедневно,
		еженедельно и ежемесячно (см. &man.cron.8; и
		&man.periodic.8;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Конфигурационные файлы для утилиты
		<command>ppp</command> (см. &man.ppp.8;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Пустой каталог, часто используемый системными
		администраторами как временная точка
		монтирования.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Виртуальная файловая система, отображающая
		текущие процессы (см. &man.procfs.5;,
		&man.mount.procfs.8;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
	      <entry>Статически собранные программы для восстановления
		после сбоев.  Обратитесь к &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Домашний каталог пользователя
		<username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Системные утилиты и утилиты администрирования,
		необходимые для работы как в однопользовательском,
		так и в многопользовательском режимах.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Временные файлы.  Содержимое
		<filename class="directory">/tmp</filename> обычно
		теряется во время перезагрузки системы.  Файловая
		система в памяти часто монтируется в
		<filename class="directory">/tmp</filename>.  Это
		может быть автоматизированно с помощью переменных
		относительно tmpmfs из &man.rc.conf.5; (или же с
		помощью записи в <filename>/etc/fstab</filename>;
		обращайтесь к &man.mdmfs.8;).</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>Большинство пользовательских утилит и приложений.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Пользовательские утилиты и приложения общего
		назначения.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Стандартные заголовочные файлы для языка C.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Файлы стандартных библиотек.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Файлы данных для различных утилит.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>Системные даемоны и утилиты (выполняемые другими
		программами).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/local/</filename></entry>
	      <entry>Локальные пользовательские приложения,
		библиотеки, и т.д.  Также используется по умолчанию коллекцией
		портов.  Внутри <filename>/usr/local</filename>
		иерархия каталогов должна следовать &man.hier.7; для
		<filename>/usr</filename>.  Исключение составляют
		каталог <filename>man</filename>, который расположен
		непосредственно в <filename>/usr/local</filename>, а не
		в <filename>/usr/local/share</filename>, и документация портов,
		которая расположена в
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Архитектурно-зависимые файлы и каталоги,
		образующиеся в процессе сборки системы из исходных
		текстов в <filename>/usr/src</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports/</filename></entry>
	      <entry>Коллекция портов FreeBSD (опционально).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>Системные утилиты и утилиты администрирования
		(исполняемые пользователем).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Архитектурно-независимые файлы.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Исходные тексты BSD и/или
		программ.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/X11R6/</filename></entry>
	      <entry>Утилиты, приложения и библиотеки X11R6 (X Window
		System; необязательно).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Файлы журналов общего назначения, временные,
		перемещаемые файлы и файлы очередей.  Файловая
		система в памяти иногда монтируется в
		<filename class="directory">/var</filename>.  Это
		может быть автоматизированно с помощью переменных
		относительно varmfs из &man.rc.conf.5; (или же с
		помощью записи в <filename>/etc/fstab</filename>;
		обращайтесь к &man.mdmfs.8;).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Различные файлы системных журналов.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Почтовые ящики пользователей.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Файлы очередей печати, почты, и пр.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Временные файлы, которые обычно сохраняются во время
		перезагрузки системы, если только
		<filename class="directory">/var</filename> не является
		файловой системой в памяти.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/yp/</filename></entry>
	      <entry>Карты (maps) NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="disk-organization">
      <title>Организация дисков</title>

      <para>Наименьшая единица, которую FreeBSD использует для обращения
	к файлам, это имя файла.  Имена файлов чувствительны к регистру,
	поэтому <filename>readme.txt</filename> и <filename>README.TXT
	</filename> &mdash; два разных файла.  FreeBSD не использует
	расширение файла (<filename>.txt</filename>) для определения
	программа это, документ или другой тип данных.</para>

      <para>Файлы хранятся в каталогах.  Каталоги могут не содержать файлов,
	или могут содержать много сотен файлов.  Каталоги также могут
	содержать другие каталоги, что позволяет создавать иерархию каталогов
	один в другом.  Это упрощает организацию данных.</para>

      <para>Обращение к файлам происходит путем задания имени файла или
	каталога, дополняемого прямым слэшем <literal>/</literal>, за которым
	может следовать имя другого каталога.  Если есть каталог
	<filename>foo</filename>, содержащий каталог
	<filename>bar</filename>, который содержит файл
	<filename>readme.txt</filename>, полное имя, или
	<firstterm>путь</firstterm> к файлу будет
	<filename>foo/bar/readme.txt</filename>.</para>

      <para>Каталоги и файлы хранятся в файловой системе.  Каждая файловая система
	содержит один каталог на верхнем уровне, называемый
	<firstterm>корневым каталогом</firstterm> этой файловой системы.
	Этот корневой каталог может содержать другие каталоги.</para>

      <para>Внешне это может быть похоже на те операционные системы,
	которые вы возможно использовали.  Есть несколько отличий:
	например, &ms-dos; использует <literal>\</literal> для разделения имен
	файлов и каталогов, а &macos; использует <literal>:</literal>.</para>

      <para>FreeBSD не использует букв дисков, или других имен дисков в
	пути.  Вам не нужно писать <filename>c:/foo/bar/readme.txt</filename>
	в FreeBSD.</para>

      <para>Вместо этого, одна файловая система назначается <firstterm>корневой
	файловой системой</firstterm>.  Обращение к корневому каталогу
	корневой файловой системы происходит через <literal>/</literal>.
	Любая другая файловая система <firstterm>монтируется</firstterm>
	к корневой файловой системе.  Неважно как много дисков есть в вашей
	системе FreeBSD, каждый каталог будет выглядеть как расположенный
	на том же диске.</para>

      <para>Предположим, у вас есть три файловых системы: <literal>A</literal>,
	<literal>B</literal>, и <literal>C</literal>.  Каждая файловая
	система имеет один корневой каталог, в котором содержатся другие
	каталоги, называемые
	<literal>A1</literal>, <literal>A2</literal> (и аналогично
	<literal>B1</literal>, <literal>B2</literal> и
	<literal>C1</literal>, <literal>C2</literal>).</para>

      <para>Назовем <literal>A</literal> корневой файловой системой.
	Если вы используете команду <command>ls</command> для просмотра
	содержимого каталога, вы увидите два подкаталога, <literal>A1</literal>
	и <literal>A2</literal>.  Дерево каталогов выглядит так:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Файловая система должна быть подмонтирована к каталогу другой
	файловой системы.  Предположим, что вы монтируете файловую систему
	<literal>B</literal> на каталог <literal>A1</literal>.  Корневой
	каталог <literal>B</literal> замещается <literal>A1</literal>,
	а каталоги в <literal>B</literal> отображаются соответственно:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Если потребуется, любые файлы из каталогов <literal>B1</literal> или
	<literal>B2</literal> могут быть получены через путь
	<filename>/A1/B1</filename> или <filename>/A1/B2</filename>.
	Все файлы, бывшие в <filename>/A1</filename>, временно скрыты.
	Они появятся, если <literal>B</literal> будет
	<firstterm>размонтирована</firstterm> с A.</para>

      <para>Если <literal>B</literal> была смонтирована на <literal>A2,
	</literal> диаграмма будет выглядеть так:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>а пути будут <filename>/A2/B1</filename> и
	<filename>/A2/B2</filename> соответственно.</para>

      <para>Файловые системы могут быть смонтированы одна на другую.
	Продолжая предыдущий пример, файловая система <literal>C</literal>
	может быть смонтирована на каталог <literal>B1</literal> файловой
	системы <literal>B</literal> в таком порядке:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Или <literal>C</literal> может быть смонтирована прямо на
	файловую систему <literal>A</literal>, на каталог <literal>A1
	</literal>:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Если вы знакомы с &ms-dos;, это похоже, хотя и не идентично,
	команде <command>join</command>.</para>

      <para>Как правило, это не должно вас интересовать.  Обычно вы создаете
	файловые системы во время установки FreeBSD, решаете куда их
	монтировать, и ничего не меняете, пока не понадобится добавить новый
	диск.</para>

      <para>Можно создать одну большую корневую файловую систему и не
	создавать других.  У такого подхода есть несколько
	недостатков и одно преимущество.</para>

      <itemizedlist>
	<title>Преимущества нескольких файловых систем</title>

	<listitem>
	  <para>Различные файловые системы могут иметь различные
	    <firstterm>опции монтирования</firstterm>.  Например,
	    в целях безопасности корневая файловая система может
	    быть смонтирована только для чтения, что делает
	    невозможным случайное удаление или редактирование
	    критически важного файла.  Отделение файловых систем,
	    используемых пользователями для записи, таких как
	    <filename>/home</filename>, от других файловых
	    систем позволяет также монтировать их с параметром
	    <firstterm>nosuid</firstterm>; этот параметр отменяет
	    действие битов <firstterm>suid</firstterm>/
	    <firstterm>guid</firstterm> на исполняемых файлах,
	    в этой файловой системе, что потенциально повышает
	    безопасность.</para>
	</listitem>

	<listitem>
	  <para>FreeBSD автоматически оптимизирует расположение файлов на
	    файловой системе в зависимости от того, как файловая система
	    используется.  Файловая система, содержащая множество мелких часто
	    записываемых файлов, будет иметь оптимизацию, отличную от таковой
	    для файловой системы, содержащей несколько больших файлов.
	    На одной большой файловой системе эта оптимизация не
	    работает.</para>
	</listitem>

	<listitem>
	  <para>Файловые системы FreeBSD очень устойчивы к внезапному
	    отключению.  Тем не менее, потеря питания в критический момент
	    все же может повредить структуру файловой системы.  Разделение
	    данных на несколько файловых систем повышает шансы, что система
	    все-таки будет работать и делает более легким восстановление с
	    резервной копии.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Преимущество одной файловой системы</title>

	<listitem>
	  <para>Размер файловых систем фиксирован.  Если вы создаете файловую
	    систему при установке FreeBSD и задаете определенный размер,
	    позднее вы можете обнаружить что нужен раздел большего размера.
	    Это не так легко сделать без резервного копирования, создания
	    файловых систем нового размера и последующего восстановления
	    сохраненных данных.</para>

	  <important>
	    <para>В FreeBSD представлена команда
	      &man.growfs.8;, которая позволяет увеличивать размер
	      файловой системы на лету, устраняя это ограничение.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Файловые системы содержатся в разделах.  Этот термин не имеет
	того же смысла, что и при более раннем его использовании в этой главе,
	из-за наследия &unix; в &os;.  Каждый раздел обозначается буквой
	от <literal>a</literal> до <literal>h</literal>.  Каждый раздел может
	содержать только одну файловую систему, это значит что файловая система
	может быть описана ее точкой монтирования в файловой иерархии,
	или буквой раздела, в котором она содержится.</para>

      <para>FreeBSD также использует дисковое пространство под
	<firstterm>раздел подкачки (swap space)</firstterm>.  Подкачка позволяет
	FreeBSD	работать с <firstterm>виртуальной памятью</firstterm>.
	Ваш компьютер может работать так, как если бы у него было больше
	памяти,	чем есть на самом деле.  Когда у FreeBSD кончается память, она
	перемещает часть данных, не используемых в данный момент, в раздел
	подкачки и возвращает их обратно (перемещая в подкачку что-то другое),
	когда они нужны.</para>

      <para>По некоторым разделам есть определенные соглашения.</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Раздел</entry>

	      <entry>Соглашение</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Как правило, содержит корневую файловую систему</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Как правило, содержит раздел подкачки</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Как правило, такого же размера, что и весь слайс (slice).
		Это позволяет утилитам, которым нужно работать над всем
		слайсом (например, сканер плохих блоков), работать с
		разделом <literal>c</literal>.  В обычной ситуации не нужно
		создавать файловую систему на этом разделе.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Раздел <literal>d</literal> создавался для специальных
		целей, хотя сейчас они не актуальны и <literal>d</literal>
		может быть задействован как обычный раздел.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Каждый раздел-содержащий-файловую-систему хранится на том, что
	во FreeBSD называется <firstterm>слайс (slice)</firstterm>.  Слайс
	&mdash; это термин FreeBSD, то, что обычно называют разделом,
	и опять же это из-за &unix; основы FreeBSD.  Слайсы нумеруются с 1 по
	4.</para>

	<indexterm><primary>слайсы</primary></indexterm>
	<indexterm><primary>разделы</primary></indexterm>
	<indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>Номера слайсов следуют за именем устройства, предваряемые
	строчной <literal>s</literal>, начиная с 1.  Так
	<quote>da0<emphasis>s1</emphasis></quote> это первый слайс первого
	SCSI устройства.  Может быть только четыре физических слайса на диске,
	но могут быть логические слайсы нужного типа внутри физических
	слайсов.  Эти дополнительные
	слайсы нумеруются начиная с 5, так что
	<quote>ad0<emphasis>s5</emphasis></quote> это первый дополнительный
	слайс на первом IDE диске.  Эти устройства используются файловыми
	системами, занимающими весь слайс.</para>

      <para>Слайсы, <quote>эксклюзивно выделенные (dangerously dedicated)</quote> физические устройства
	и другие устройства содержат <firstterm>разделы</firstterm>,
	представляемые буквами от <literal>a</literal> до <literal>h</literal>.
	Эти буквы добавляются к имени устройства.
	<quote>da0<emphasis>a</emphasis></quote> это раздел a на первом
	устройстве da, который <quote>эксклюзивно выделен</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> это пятый раздел
	в третьем слайсе второго IDE диска.</para>

      <para>Наконец, каждый диск идентифицирован.  Имя диска начинается с
	кода, обозначающего тип диска, затем идет номер диска.
	В отличие от слайсов, нумерация дисков начинается
	с 0.  Основные коды, которые вам могут встретиться, есть в
	<xref linkend="basics-dev-codes">.</para>

      <para>В то время, как ссылка на раздел FreeBSD требует также указания
	слайса и диска, содержащего раздел, ссылка на слайс требует также
	указания имени диска.  Другими словами, ссылаясь на раздел,
	указывайте имя диска, <literal>s</literal>, номер слайса, и затем
	букву раздела.  Примеры показаны в
	<xref linkend="basics-disk-slice-part">.</para>

      <para><xref linkend="basics-concept-disk-model"> показывает
	концептуальную модель диска, которая должна помочь прояснить
	ситуацию.</para>

      <para>Для установки FreeBSD вы должны сначала настроить слайсы
	дисков, затем создать разделы внутри слайсов, которые будут
	использованы для FreeBSD, а затем создать файловую систему
	(или подкачку) в каждом разделе и решить, куда файловая система
	будет смонтирована.</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>Коды дисковых устройств</title>

	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Код</entry>

	      <entry>Значение</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>ATAPI (IDE) диск</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>

	      <entry>SCSI direct access диск</entry>
	    </row>

	    <row>
	      <entry><devicename>acd</devicename></entry>

	      <entry>ATAPI (IDE) CDROM</entry>
	    </row>

	    <row>
	      <entry><devicename>cd</devicename></entry>

	      <entry>SCSI CDROM</entry>
	    </row>

	    <row>
	      <entry><devicename>fd</devicename></entry>

	      <entry>Floppy disk</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example id="basics-disk-slice-part">
	<title>Пример имен диска, слайса, и раздела</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Имя</entry>

		<entry>Значение</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>

		<entry>Первый раздел (<literal>a</literal>) на первом слайсе
		  (<literal>s1</literal>) первого IDE диска
		  (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>

		<entry>Пятый раздел (<literal>e</literal>) на
		  втором слайсе (<literal>s2</literal>) второго SCSI диска
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>Концептуальная модель диска</title>

	<para>Эта диаграмма показывает первый подключенный к системе IDE диск
	  с точки зрения FreeBSD.  Предположим, что размер диска 4&nbsp;GB, и он
	  содержит два 2&nbsp;GB слайса (&ms-dos; разделы).  Первый слайс содержит
	  &ms-dos; диск, <devicename>C:</devicename>, а второй слайс содержит
	  установленную FreeBSD.  В этом примере у установленной FreeBSD
	  есть три раздела с данными и раздел подкачки.</para>

	<para>В каждом из трех разделов есть файловая система.  Раздел
	  <literal>a</literal> используется для корневой файловой системы,
	  <literal>e</literal> для иерархии каталогов
	  <filename>/var</filename>, а <literal>f</literal> для иерархии
	  каталогов <filename>/usr</filename>.</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="install/disk-layout" format="EPS">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; filesystem, all
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
	  </textobject>
	</mediaobject>
      </example>
  </sect1>

  <sect1 id="mount-unmount">
    <title>Монтирование и размонтирование файловых систем</title>

    <para>Файловая система лучше всего представима в виде дерева, с
      корнем в <filename>/</filename>.  Каталоги,
      <filename>/dev</filename>, <filename>/usr</filename> и прочие
      &ndash; это ветви дерева, которые, в свою очередь, являются
      корнями для поддеревьев, также имеющих ветви
      (<filename>/usr/local</filename>), и т.д.</para>

    <indexterm><primary>корневая файловая система</primary></indexterm>
    <para>Хорошей практикой является разнесение некоторых особо важных
      каталогов на разные файловые системы.  Например,
      <filename>/var</filename>, содержит
      <filename>log/</filename>, <filename>spool/</filename>, а также
      всевозможные временные файлы и нередко может занять все свободное
      место на диске.  Поэтому лучше смонтировать
      <filename>/var</filename> отдельно, чтобы избежать переполнения
      <filename>/</filename>.</para>

    <para>Часто бывает так, что некоторые разделы файловой системы
      расположены на разных физических носителях (дисках, CDROM),
      виртуальных или сетевых (например, <link linkend="network-nfs">сетевая
      файловая система (Network File System, NFS)</link>).  В этом
      случае узлы файловой иерархии будут расположены на разных
      файловых системах.</para>

    <sect2 id="disks-fstab">
      <title>Файл <filename>fstab</filename></title>
	<indexterm>
	  <primary>filesystems</primary>
	  <secondary>mounted with fstab</secondary>
	</indexterm>

      <para>Файловые системы, перечисленные в
	<filename>/etc/fstab</filename>, монтируются автоматически в
	<link linkend="boot">процессе загрузки</link>
	(если, конечно, для них не
	указана опция <option>noauto</option>).</para>

      <para>Формат файла <filename>/etc/fstab</filename>
	следующий (файловые системы перечисляются построчно):</para>

      <programlisting>
	<replaceable>устройство</replaceable>	<replaceable>/точка-монтирования</replaceable>	<replaceable>тип файловой системы</replaceable>	<replaceable>опции</replaceable>	<replaceable>частота дампов</replaceable>	<replaceable>порядок проверки</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>устройство</literal></term>
	  <listitem>
	    <para>Имя устройства (которое должно присутствовать), как описано в
	      <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>точка монтирования</literal></term>
	  <listitem>
	    <para>Каталог (существующий), куда следует смонтировать
	      файловую систему.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>тип файловой системы</literal></term>
	  <listitem>
	    <para>Тип файловой системы, который передается программе
	      &man.mount.8;.  По умолчанию FreeBSD использует
	      <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>опции</literal></term>
	  <listitem>
	    <para>Например, <option>rw</option>, для монтирования
	      файловой системы в режиме <quote>чтение-запись</quote>,
	      или <option>ro</option>, для режима <quote>только
	      чтение</quote>, за которыми могут следовать и другие
	      опции.  Довольно часто используется
	      опция <option>noauto</option>, чтобы не монтировать
	      автоматически файловые системы в процессе загрузки.
	      Об остальных опциях можно прочитать в
	      &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>частота дампов</literal></term>
	  <listitem>
	    <para>Используется утилитой &man.dump.8; для определения
	      файловых систем, с которых необходимо периодически
	      снимать специальные архивные копии.  При отсутствии этого
	      параметра принимается равным нулю.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>порядок проверки</literal></term>
	  <listitem>
	    <para>Определяет порядок, в котором следует проверять
	      файловые системы (чаще всего, в случае некорректного
	      размонтирования или внезапной перезагрузки системы).  Если
	      файловую системы не нужно проверять, этот параметр должен
	      быть установлен в ноль.  Для корневой файловой системы
	      (которая должна быть проверена в первую очередь)
	      установите его в 1.  Для всех остальных &ndash; 2 или
	      больше.  Если две или более файловые системы имеют
	      одинаковое значение <literal>passno</literal>,
	      &man.fsck.8; попытается проверять их параллельно (если,
	      конечно, это возможно физически).</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Обратитесь к &man.fstab.5; за дополнительной информацией
	о формате файла <filename>/etc/fstab</filename> и различных
	опциях монтирования.</para>
    </sect2>

    <sect2 id="disks-mount">
      <title>Команда <command>mount</command></title>
      <indexterm>
	<primary>filesystems</primary>
	<secondary>mounting</secondary>
      </indexterm>

      <para>Команда &man.mount.8; используется, как следует из ее имени,
	для монтирования файловых систем.</para>

      <para>Пример использования (простейший случай):</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>устройство</replaceable> <replaceable>точка-монтирования</replaceable></userinput></screen>
      </informalexample>

      <para>Перечислим основные опции, которые может принимать команда
	&man.mount.8; (полный список смотрите на странице
	справочника):</para>

      <variablelist>
	<title>Опции монтирования</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Смонтировать все файловые системы, перечисленные в
	      файле <filename>/etc/fstab</filename>.  Исключение
	      составляют помеченные как <quote>noauto</quote>,
	      перечисленные после опции <option>-t</option> и уже
	      смонтированные.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Сделать все, кроме самого системного вызова mount.
	      Эта опция полезна вместе с флагом <option>-v</option>
	      для определения того, что на самом деле пытается сделать
	      &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Монтировать поврежденный раздел (опасно!),
	      или форсировать отмену всех запросов на запись при
	      изменении режима монтирования с
	      <quote>чтение-запись</quote> на <quote>только
	      чтение</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Монтировать файловую систему в режиме <quote>только
	      для чтения</quote>.  То же самое, что и указание
	      аргумента <option>ro</option> для опции
	      <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Монтировать файловую систему как систему указанного
	      типа, или, в случае опции <option>-a</option>, только
	      файловые системы данного типа.</para>

	    <para>По умолчанию, тип файловой системы &ndash;
	      <quote>ufs</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Обновить опции монтирования для файловой
	      системы.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Выдавать более подробную информацию.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Монтировать файловую систему в режиме
	      <quote>чтение-запись</quote>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Опция <option>-o</option> принимает разделенные запятыми
	аргументы, включая нижеперечисленные:</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Запрет на исполнение бинарных файлов на файловой
	      системе (тоже полезная опция для повышения безопасности
	      системы).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Игнорировать setuid и setgid биты на файловой системе
	      (еще одна полезная опция для повышения безопасности
	      системы).</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>Команда <command>umount</command></title>
      <indexterm>
	<primary>filesystems</primary>
	<secondary>unmounting</secondary>
      </indexterm>

      <para>Команда &man.umount.8; принимает в качестве параметра точку
	монтирования какой-либо файловой системы, имя устройства, опцию
	<option>-a</option> или <option>-A</option>.</para>

      <para>Кроме того, вы можете дополнительно указать опцию
	<option>-f</option> для форсированного размонтирования файловой
	системы, и <option>-v</option> для получения более подробной
	информации.  Имейте ввиду, что это в общем случае опасно и
	потому не рекомендуется, так как тем самым вы можете нарушить
	работу компьютера или повредить данные на файловой системе.</para>

      <para>Опции <option>-a</option> и <option>-A</option>
	используются для размонтирования всех файловых систем (разве
	что вы укажете опцию <option>-t</option>).  Разница состоит в
	том, что <option>-A</option> не пытается размонтировать
	корневую файловую систему.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Процессы</title>

    <para>FreeBSD является многозадачной операционной системой.
      Это означает, что одновременно может быть запущена более чем одна
      программа.  Каждая программа, работающая в некоторый момент времени,
      называется <firstterm>процессом</firstterm>.  Каждая команда,
      которую вы запускаете, порождает хотя бы один процесс.  Есть несколько
      системных процессов, запущенных все время и поддерживающих
      функциональность системы.</para>

    <para>У каждого процесса есть уникальный номер, называемый
      <firstterm>process ID</firstterm>, или <firstterm>PID</firstterm>, и,
      как и у файлов, у каждого процесса есть владелец и группа.  Информация
      о владельце и группе процесса используется для определения того, какие
      файлы и устройства могут быть открыты процессом с учетом прав на файлы,
      о которых говорилось ранее.  Также у большинства процессов есть
      родительский процесс.  Например, при запуске команд из оболочки,
      оболочка является процессом и любая запущенная команда также является
      процессом.  Для каждого запущенного таким путем процесса оболочка будет
      являться родительским процессом.  Исключением из этого правила является
      специальный процесс, называемый &man.init.8;.
      <command>init</command> всегда первый процесс, его PID всегда 1.
      <command>init</command> запускается автоматически ядром во время
      загрузки FreeBSD.</para>

    <para>Две команды очень полезны для просмотра работающих в системе
      процессов, это &man.ps.1; и &man.top.1;.  Команда <command>ps</command> используется
      для получения списка запущенных процессов и может показать их PID,
      сколько памяти они используют, команду, которой они были запущены и т.д.
      Команда <command>top</command> показывает запущенные процессы и обновляет экран
      каждые несколько секунд, что позволяет наблюдать за работой компьютера
      в реальном времени.</para>

    <para>По умолчанию, <command>ps</command> показывает только принадлежащие вам
      процессы.  Например:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Как вы можете видеть в данном примере, вывод &man.ps.1; организован
      в несколько колонок.  Идентификатор процесса <literal>PID</literal>
      обсуждался ранее.  PID назначаются с 1 до 99999 и опять с начала, если
      последнее число будет превышено (однажды выданный и используемый PID
      не может быть назначен повторно).
      Колонка <literal>TT</literal> показывает
      терминал (tty), на котором запущена программа (можете пока забыть про
      это).  <literal>STAT</literal> показывает состояние программы и опять
      же может быть пока проигнорирован.  <literal>TIME</literal> это количество
      времени центрального процессора, использованное
      программой &mdash; это обычно не время, прошедшее с запуска
      программы, поскольку большинство программы проводят много времени
      в ожидании некоторого события перед тем, как занять время процессора.
      Наконец, <literal>COMMAND</literal> это команда, которой программа
      была запущена.</para>

    <para>У &man.ps.1; есть множество различных опций, влияющих на выводимую
      информацию.  Один из наиболее полезных наборов опций это
      <literal>auxww</literal>.  <option>a</option> позволяет показать
      информацию о всех запущенных процессах, а не только тех, которыми вы
      владеете.  <option>u</option> показывает имя пользователя,
      владеющего процессом, и информацию об используемой памяти.
      <option>x</option> показывает информацию о процессах-даемонах и
      <option>ww</option> указывает &man.ps.1; показать всю командную строку
      для каждого процесса,
      вместо обрезания ее, когда она станет слишком длинной, чтобы уместиться
      на экран.</para>

    <para>Вывод &man.top.1; похож на только что описанный.
      Обычно он выглядит так:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Вывод разбит на два раздела.  Заголовок (первые пять строк)
      показывает PID последнего запущенного процесса, среднее значение
      загрузки системы (которое показывает насколько система занята),
      время работы системы с последней перезагрузки и текущее время.
      Другие цифры заголовка относятся к количеству запущенных процессов
      (в данном примере 47), количеству занятой памяти и подкачки и время,
      занимаемое различными состояниями процессора.</para>

    <para>Ниже идут несколько колонок, содержащих похожую на вывод &man.ps.1;
      информацию.  Как и раньше, это PID, время процессора, командная строка.
      &man.top.1; показывает также величину занятой процессом памяти.
      Это значение разбито на две колонки, одна для общего объема, а другая
      для резидентного &mdash; общий объем показывает сколько всего памяти
      нужно приложению, а резидентный показывает количество памяти, используемой
      в данный момент.  Из этого примера видно, что
      <application>&netscape;</application> требует почти 30&nbsp;MB памяти,
      но в данный момент использует только 9&nbsp;MB.</para>

    <para>&man.top.1; автоматически обновляет экран каждые две секунды;
      это значение можно изменить опцией <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Даемоны, сигналы, уничтожение процессов</title>

    <para>Если вы запускаете редактор, им можно легко управлять, открывать в
      нем файлы и т.д.  Вы можете делать это, поскольку редактор предоставляет
      такие возможности и потому, что редактор присоединен к
      <firstterm>терминалу</firstterm>.  Некоторые программы разработаны
      без поддержки интерфейса пользователя, поэтому они отсоединяются от
      терминала при первой возможности.  Например, веб-сервер целый день
      отвечает на запросы из сети, и ему как правило не требуется ваше вмешательство.
      Программы, передающие почту от сервера к серверу &mdash; другой пример
      приложений этого класса.</para>

    <para>Мы называем эти программы <firstterm>даемонами</firstterm>.  Даемоны это
      персонажи греческой мифологии: хорошие или плохие, они были спутниками
      человека и, вообще говоря, выполняли полезную работу для людей, почти как
      веб- и почтовые серверы выполняют полезную работу сегодня.  Это причина,
      по которой талисманом BSD долгое время является веселый даемон в кедах и с
      вилами.</para>

    <para>Есть соглашение, по которому имя программы, которая обычно запускается
      как даемон, заканчивается на <quote>d</quote>.  <application>BIND</application>
      это Berkeley Internet Name Domain, а выполняемая программа называется
      <command>named</command>; программа веб сервера
      <application>Apache</application> называется <command>httpd</command>;
      даемон очереди печати это <command>lpd</command> и так далее.  Это соглашение,
      а не жесткое правило; например, главный почтовый даемон для
      <application>Sendmail</application> называется
      <command>sendmail</command>, а не <command>maild</command>, как вы могли бы
      предположить.</para>

    <para>Иногда может потребоваться взаимодействие с процессом даемона.
      Один из способов взаимодействия с процессом даемона (или с любым другим
      запущенным процессом) &mdash; это посылка ему так называемого
      <firstterm>сигнала</firstterm>.
      Есть множество различных сигналов &mdash; некоторые
      из них имеют специальное значение, другие обрабатываются приложением,
      реакция которого на эти сигналы должна быть описана в документации.
      Вы можете посылать сигналы только тем процессам,
      владельцем которых являетесь.  Если вы отправите сигнал какому-то другому
      процессу с помощью &man.kill.1; или &man.kill.2;, доступ будет запрещен.
      Исключением из правил является пользователь <username>root</username>,
      который может отправлять сигналы любому процессу.</para>

    <para>В некоторых случаях FreeBSD тоже посылает сигналы приложениям.  Если
      приложение плохо написано и пробует обратиться к области памяти, к
      которой оно не должно обращаться, FreeBSD посылает процессу сигнал
      <firstterm>нарушение сегментации</firstterm> (<literal>SIGSEGV</literal>).
      Если приложение использует системный вызов &man.alarm.3;, чтобы получить
      уведомление по истечении определенного периода времени, будет отправлен
      сигнал Alarm (<literal>SIGALRM</literal>) и т.д.</para>

    <para>Два сигнала могут быть использованы для завершения процесса,
      <literal>SIGTERM</literal> и <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> это корректный способ завершить процесс;
      процесс может <emphasis>поймать</emphasis> сигнал, определить, что его
      хотят завершить, закрыть любые файлы, которые он мог открыть,
      и закончить то, что он делал в момент перед закрытием.  В некоторых
      случаях процесс может даже игнорировать <literal>SIGTERM</literal>,
      если выполняет задачу, которая не может быть прервана.</para>

    <para><literal>SIGKILL</literal> не может быть проигнорирован процессом.
      Этот сигнал говорит <quote>Меня не волнует что ты делаешь &mdash;
      остановись немедленно</quote>.  Если вы посылаете процессу
      <literal>SIGKILL</literal>, FreeBSD сразу же остановит этот
	процесс<footnote>
	<para>Не совсем верно &mdash; есть несколько действий, которые не могут
	  быть прерваны.  Например, если процесс пытается прочитать файл на
	  другом компьютере в сети, и другой компьютер по какой-то причине не
	  отвечает (был выключен, или в сети произошла ошибка), процесс
	  находится в так называемом <quote>непрерываемом состоянии</quote>.
	  В конце концов время ожидания закончится, обычно это происходит через
	  две минуты.  Как только время закончится, процесс будет
	  уничтожен.</para>
      </footnote>.</para>

    <para>Другие сигналы, которые возможно вам понадобятся,
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, и
      <literal>SIGUSR2</literal>.  Это сигналы общего назначения,
      различные приложения могут по-разному реагировать на них.</para>

    <para>Предположим, что вы изменили файл конфигурации веб сервера &mdash;
      теперь нужно указать ему перечитать конфигурацию.  Можно остановить
      и запустить <command>httpd</command>, но это приведет к кратковременной
      остановке сервера, которая может быть нежелательна.  Большинство даемонов
      написаны так, чтобы при получении сигнала <literal>SIGHUP</literal>
      перечитывать файлы конфигурации.  Поэтому вместо уничтожения и запуска
      <command>httpd</command> можно послать сигнал <literal>SIGHUP</literal>.
      Поскольку нет стандартного способа реагирования на этот сигнал, различные
      даемоны будут вести себя по разному; прочитайте документацию на даемон
      по этому вопросу.</para>

    <para>Сигналы посылаются с помощью команды &man.kill.1;, как показано в этом
      примере.</para>

    <procedure>
      <title>Отправка сигнала процессу</title>

      <para>Этот пример показывает как послать сигнал &man.inetd.8;.  Файл
	конфигурации <command>inetd</command>
	<filename>/etc/inetd.conf</filename>, <command>inetd</command> перечитает
	этот файл, если ему отправить сигнал <literal>SIGHUP</literal>.</para>

      <step>
	<para>Нужно определить PID процесса, которому вы хотите отправить сигнал.
	  Сделайте это с помощью &man.ps.1; и &man.grep.1;.  Команда &man.grep.1;
	  используется для поиска по заданной строке в выходном потоке.  Эта
	  команда запускается под обычным пользователем, а &man.inetd.8; под
	  <username>root</username>, поэтому &man.ps.1; должна быть запущена с
	  параметром <option>ax</option>.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Итак, PID &man.inetd.8; 198.  В некоторых случаях в выводе команды
	  может также появиться <literal>grep inetd</literal>.  Это из-за способа,
	  которым &man.ps.1; получает список запущенных процессов.</para>
      </step>

      <step>
	<para>Используйте &man.kill.1; для отправки сигнала.  Поскольку
	  &man.inetd.8; запускается из под <username>root</username>,
	  нужно сначала использовать &man.su.1; для получения прав
	  <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Как и большинство команд &unix;, &man.kill.1; ничего не выведет,
	  если отработает нормально.  Если вы посылаете сигнал процессу,
	  которым не владеете, на экране появится <errorname>kill:
	  <replaceable>PID</replaceable>: Operation not
	  permitted</errorname>.  При неправильно набранном PID вы или отправите
	  сигнал другому процессу, что может привести к неприятностям, или, если
	  повезет, сигнал будет отправлен на PID, который в данный момент не
	  используется &mdash; на экране появится <errorname>kill:
	  <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>Зачем использовать <command>/bin/kill</command>?</title>

	  <para>Во многих оболочках команда <command>kill</command> встроена;
	    таким образом, оболочка вместо вызова <filename>/bin/kill</filename>
	    сама посылает сигнал.  Это может быть очень полезно, но в разных
	    оболочках имя сигнала указывается по-разному.  Чем
	    пытаться выучить их все, гораздо проще использовать
	    <command>/bin/kill <replaceable>...</replaceable></command>
	    непосредственно.</para>
	</note>
      </step>
    </procedure>

    <para>Отправка других сигналов очень похожа, просто замените
      <literal>TERM</literal> или <literal>KILL</literal> в командной
      строке на имя другого сигнала.</para>

    <important>
      <para>Уничтожение процессов наугад может быть плохой идеей.  В частности,
	&man.init.8;, чей PID 1, имеет особое значение.  Выполнение
	<command>/bin/kill -s KILL 1</command> &mdash; быстрый способ перегрузить
	систему.  <emphasis>Всегда</emphasis> дважды проверяйте параметры
	запуска &man.kill.1; <emphasis>перед</emphasis> тем, как нажать
	<keycap>Enter</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Интерпретатор команд</title>
    <indexterm><primary>оболочка</primary></indexterm>
    <indexterm><primary>командная строка</primary></indexterm>

    <para>При работе с FreeBSD, в большинстве случаев для выполнения
      повседневных задач используется командный интерфейс (так называемая
      <quote>оболочка</quote>, <quote>shell</quote>).  Основная задача интерпретатора &mdash; принимать
      вводимые команды и выполнять их.  Многие командные интерпретаторы имеют
      встроенные средства для выполнения повседневной работы, например,
      операции над файлами и каталогами, редактирование командной строки,
      командные макросы и переменные окружения.  Вместе с FreeBSD
      поставляется несколько командных интерпретаторов, например,
      <command>sh</command>, или Bourne Shell, и <command>tcsh</command>,
      расширенная версия C-shell.  Многие другие интерпретаторы доступны из
      коллекции портов FreeBSD, например <command>zsh</command> и
      <command>bash</command>.</para>

    <para>Какой из командных интерпретаторов использовать?  Это дело вкуса.
      Если вы программируете на C, то вам, возможно, понравится
      <command>tcsh</command>.  Если вы работали с Linux, или только начинаете
      работать с интерфейсом командной строки &unix;, попробуйте
      <command>bash</command>.  Каждый из названных интерпретаторов имеет свои
      особенности, которые отличат его от других, и, возможно, повлияют на ваш
      выбор.</para>

    <para>Одна из наиболее часто используемых функций командного
      интерпретатора &ndash; дополнение частичного имени файла до полного.  Вы
      можете набрать только первые несколько символов имени файла, нажать
      клавишу табуляции (TAB), и командный интерпретатор автоматически завершит
      имя.  Например, у нас есть два файла, названные <filename>foobar</filename> и
      <filename>foo.bar</filename>.  Допустим, мы хотим удалить файл
      <filename>foo.bar</filename>.  Для этого, наберем на клавиатуре
      <command>rm fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>Вы увидите следующее: <command>rm foo[BEEP].bar</command>.</para>

    <para>Здесь [BEEP] &ndash; это так называемый консольный сигнал,
      оповещающий о том, что интерпретатор не в состоянии закончить имя
      файла, так как по введенным вами символам невозможно однозначно
      идентифицировать файл.  Например, имена файлов
      <filename>foobar</filename> и <filename>foo.bar</filename> оба
      начинаются с <literal>fo</literal>, но после нажатия TAB можно
      однозначно дополнить только до <literal>foo</literal>.  Если же теперь
      ввести точку (<literal>.</literal>) и вновь нажать TAB, интерпретатор
      достроит имя файла целиком.</para>
    <indexterm><primary>переменные окружения</primary></indexterm>

    <para>Дополнительные возможности при работе с интерпретатором дает
      использование переменных окружения.  Переменные окружения это пары
      переменная/значение, хранящиеся в памяти интерпретатора.
      Значение переменных окружения может быть прочитано любой программой,
      запущенной из командного интерпретатора, и часто содержит
      настройки для многих приложений и утилит.  Ниже приведены некоторые
      наиболее часто встречающиеся переменные окружения и их значения:</para>
    <indexterm><primary>переменные окружения</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Переменная</entry>
	    <entry>Описание</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Имя текущего пользователя.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Каталоги, разделенные двоеточием, для
	      поиска исполняемых файлов.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Сетевое имя виртуального дисплея X11, доступного для
	      подключения.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Текущий командный интерпретатор.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Тип терминала пользователя.  Используется, чтобы узнать
	      возможности терминала.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Список escape-последовательностей для управления
	      различными функциями терминала.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Название (тип) операционной системы.  Например,
	      FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Архитектура машины (процессора).</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Выбранный пользователем текстовый редактор.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Выбранная пользователем утилита просмотра
	      файлов.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Каталоги, разделенные двоеточием, для
	      поиска файлов системного справочника.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>оболочки Bourne</primary></indexterm>
    <para>Установка значений переменных окружения различна для разных
      оболочек. Например, в интерпретаторах C-стиля, таких как
      <command>tcsh</command> и <command>csh</command>, это
      <command>setenv</command>.  В интерпретаторах Bourne, таких как
      <command>sh</command> и <command>bash</command>, это
      <command>export</command>.  Например, чтобы установить или изменить
      значение переменной <envar>EDITOR</envar> к значению
      <filename>/usr/local/bin/emacs</filename> в <command>csh</command> или
      <command>tcsh</command>, выполните команду:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>В оболочках Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Чтобы получить значение переменной, например, в командной строке,
      поместите символ <literal>$</literal> перед именем
      переменной.  Например, команда <command>echo $TERM</command> выведет
      значение переменной <envar>$TERM</envar>.</para>

    <para>Командный интерпретатор воспринимает некоторые символы, называемые
      метасимволами, в качестве управляющих.
      Один из наиболее часто используемых &ndash; символ <literal>*</literal>,
      который заменяет любое количество символов в имени файла.
      Метасимволы
      используются для поиска файлов по маске, например, команда
      <command>echo *</command> делает практически тоже самое, что и
      команда <command>ls</command>, поскольку интерпретатор вызывает команду
      <command>echo</command>, передавая ей имена всех файлов, попадающих под маску
      <literal>*</literal>.</para>

    <para>В некоторых ситуациях требуется, чтобы интерпретатор воспринимал
      метасимволы как обычные, не несущие специальной смысловой нагрузки.
      Этого можно достичь, поставив перед символом обратную косую черту
      (<literal>\</literal>).  Например, команда <command>echo
      $TERM</command> выведет тип вашего терминала, в то же время команда
      <command>echo \$TERM</command> выведет именно слово
      <literal>$TERM</literal>, а не значение переменной
      <envar>$TERM</envar>.</para>

    <sect2 id="changing-shells">
      <title>Как изменить командный интерпретатор по умолчанию</title>

      <para>Самым простым способом, пожалуй, будет воспользоваться командой
	<command>chsh</command>.  Если переменная <envar>EDITOR</envar>
	определена, то будет загружен соответствующий текстовый редактор, иначе vi.
	Вам нужно будет изменить значение
	поля <quote>Shell:</quote> и выйти из редактора с сохранением
	результатов.</para>

      <para>Можно также воспользоваться опцией <option>-s</option> команды
	<command>chsh</command>.  Например, если вы хотите изменить
	интерпретатор на <command>bash</command>, выполните:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Интерпретатор, который вы будете использовать,
	  <emphasis>обязательно</emphasis> должен быть в файле
	  <filename>/etc/shells</filename>.  Обычно, при установке
	  интерпретаторов из <link linkend="ports">коллекции портов</link>,
	  это делается автоматически.  Если же это не так, вам нужно будет
	  самостоятельно добавить соответствующую строчку в этот файл.</para>

	<para>Например, если вы установили <command>bash</command>
	  вручную и поместили его в
	  каталог <filename>/usr/local/bin</filename>, нужно набрать:</para>

	<screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

	<para>Теперь можно смело использовать команду
	  <command>chsh</command>.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Текстовые редакторы</title>
    <indexterm><primary>текстовые редакторы</primary></indexterm>
    <indexterm><primary>редакторы</primary></indexterm>

    <para>Большинство настроек в FreeBSD производится путем редактирования
      текстовых файлов.  Соответственно, вам нужно будет освоиться с
      каким-либо текстовым редактором.  Вместе с FreeBSD поставляются лишь
      некоторые из них, гораздо больше редакторов доступно из Коллекции
      портов.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>

    <indexterm>
      <primary>редакторы</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>Самым простым в изучении и использовании, по-видимому, можно
      назвать <application>ee</application>, что расшифровывается как
      <quote>easy editor</quote>, т.е. <quote>простой редактор</quote>.  Чтобы
      начать редактировать какой-либо файл, наберите в командной строке
      <command>ee <replaceable>filename</replaceable></command>, где
      <replaceable>filename</replaceable> имя
      редактируемого файла.  Например, для редактирования файла
      <filename>/etc/rc.conf</filename>, наберите <command>ee
      /etc/rc.conf</command>.  В верхней части экрана вы увидите список
      основных команд редактора.  Символ каретки (<literal>^</literal>)
      означает клавишу <keycap>Ctrl</keycap>, таким образом,
      <literal>^e</literal> означает комбинацию клавиш
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap>
      </keycombo>.  Чтобы выйти из редактора, нажмите
      клавишу <keycap>Esc</keycap>, затем <keycap>Enter</keycap>.
      Если остались какие-либо не сохраненные
      данные, вам потребуется подтвердить выход, сохранив результат
      работы или оставив файл без изменения.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>В FreeBSD присутствует также более мощный текстовый редактор
      <application>vi</application>, а редакторы
      <application>emacs</application> и <application>vim</application>
      можно найти в коллекции портов (<filename
      role="package">editors/emacs</filename> и <filename
      role="package">editors/vim</filename>).  Эти редакторы обладают еще
      большей функциональностью и мощью, но они также и более сложны
      в изучении.  Однако, если в будущем вам потребуется часто редактировать
      большие объемы текстов, то время, потраченное на изучение более мощного
      редактора, такого как <application>vim</application>
      или <application>Emacs</application>, окупится с лихвой.</para>

    <para>Многие приложения, модифицирующие файлы или требующие текстового
      ввода, автоматически открывают текстовый редактор.  Чтобы сменить
      используемый по умолчанию редактор, установите переменную окружения
      <envar>EDITOR</envar>.  За деталями обратитесь к разделу <link
      linkend="shells">интерпретатор команд</link>.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Устройства и файлы устройств</title>

    <para>Термин <quote>устройство</quote> используется в основном по
      отношению к аппаратному обеспечению системы, такому как диски,
      принтеры, графические адаптеры, устройства ввода текста.
      При загрузке FreeBSD главным образом выводит на экран информацию об
      обнаруженных устройствах.  Вы можете найти эти сообщения
      в файле <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Например, <devicename>acd0</devicename> это первый диск
      IDE CDROM, а <devicename>kbd0</devicename> &mdash; клавиатура.</para>

    <para>В &unix; доступ к большинству этих устройств можно получить через
      специальные файлы устройств, расположенные в каталоге
      <filename>/dev</filename>.</para>

    <sect2>
      <title>Создание файлов устройств</title>
      <para>При добавлении в систему нового устройства, или добавлении
	поддержки дополнительных устройств, потребуется создать один
	или несколько файлов устройств для нового оборудования.</para>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System)</title>

	<para>Device filesystem, или <literal>DEVFS</literal>, предоставляет
	  доступ к пространству устройств ядра через общую файловую систему.
	  Вместо создания и модификации файлов устройств,
	  <literal>DEVFS</literal> создает специальную файловую систему.</para>

	<para>Обращайтесь к &man.devfs.5; за дополнительной информацией.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Бинарные форматы</title>

    <para>Для понимания того, почему &os; использует формат
      &man.elf.5;, вам потребуется сначала немного узнать
      о трех <quote>доминирующих</quote> исполняемых форматах для
      &unix;:</para>

    <itemizedlist>
      <listitem>
	<para>&man.a.out.5;</para>

	<para>Старейший и <quote>классический</quote> объектный формат
	  &unix;.  Он использует короткий и компактный заголовок с
	  магическим числом в начале, которое часто используется для
	  описания формата (смотрите &man.a.out.5; с более подробной
	  информацией).  Он содержит три загружаемых сегмента: .text,
	  .data и .bss плюс таблицу символов и таблицу строк.</para>
      </listitem>

      <listitem>
	<para><acronym>COFF</acronym></para>

	<para>Объектный формат SVR3.  Заголовок включает таблицу разделов,
	  так что могут быть сегменты кроме .text, .data и .bss.</para>
      </listitem>

      <listitem>
	<para>&man.elf.5;</para>

	<para>Наследник формата <acronym>COFF</acronym>, поддерживающий
	  множественные сегменты и 32-битные или 64-битные значения.  Одно
	  важное замечание: <acronym>ELF</acronym> был разработан в
	  предположении что есть только по одному ABI на одну архитектуру.
	  Это предположение совершенно неверно, и не только в мире
	  коммерческих SYSV (в котором есть как минимум три ABI: SVR4,
	  Solaris, SCO).</para>
	  <!-- translation issue: ... SCO) does it hold true. -->

	<para>FreeBSD пытается обойти эту проблему, в частности предоставляя
	  утилиту для <emphasis>оглавления</emphasis> известного
	  исполняемого файла <acronym>ELF</acronym> информацией
	  об ABI с которым он совместим.  Обратитесь к странице справочника
	  &man.brandelf.1; за более подробной информацией.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD имеет произошла из <quote>классического</quote> лагеря и
      использовала формат &man.a.out.5;, технологию опробованную и
      проверенную на многих поколениях релизов BSD, до начала ветки
      3.X.  Хотя собирать и запускать родные бинарные
      файлы <acronym>ELF</acronym> (и ядро) в системе FreeBSD
      можно было несколько раньше, FreeBSD вначале сопротивлялась
      <quote>проталкиванию</quote> <acronym>ELF</acronym> как формата
      по умолчанию.  Почему?  Когда лагерь Linux производил болезненный
      переход к <acronym>ELF</acronym>, у него не было большого
      преимущества перед исполняемым форматом <filename>a.out</filename>,
      из-за негибкого, основанного на таблице переходов механизма
      разделяемых библиотек, что делало создание разделяемых библиотек
      очень трудным для поставщиков и разработчиков.  Когда доступные
      инструменты <acronym>ELF</acronym> предоставили решение проблемы
      разделяемых библиотек, и появилась некоторая перспектива,
      цена перехода была признана допустимой и он был сделан.
      Механизм разделяемых библиотек FreeBSD близок по стилю к механизму
      разделяемых библиотек &sunos; от Sun, и поэтому очень прост в
      использовании.</para>

    <para>Итак, почему так много разных форматов?</para>

    <para>Давно, в темном далеком прошлом, оборудование было простым.
      Это простое оборудование поддерживало простые, маленькие системы.
      <filename>a.out</filename> был совершенно адекватен задаче представления
      бинарных файлов на таких простых системах (PDP-11).  Люди, портировавшие
      &unix; с этих простых систем, оставили <filename>a.out</filename>
      формат потому, что он был достаточен для ранних портов &unix; на
      архитектуры, подобные Motorola 68k, VAXen, etc.</para>

    <para>Затем какой-то смышленый инженер по оборудованию решил, что если
      он сможет заставить программы исполнять некоторые трюки, то сможет
      несколько упростить дизайн и заставить ядро CPU работать быстрее.
      Хотя это было сделано с новым типом оборудования (известного сейчас
      как <acronym>RISC</acronym>), формат <filename>a.out</filename> не подходил для него,
      и было разработано множество форматов, чтобы получить
      лучшую производительность на таком оборудовании по сравнению с
      той, которую мог предоставить простой формат <filename>a.out</filename>.
      Были изобретены форматы <acronym>COFF</acronym>, <acronym>ECOFF</acronym>
      и некоторые другие малоизвестные форматы, и их ограничения были учтены,
      когда все похоже остановились на <acronym>ELF</acronym>.</para>

    <para>Кроме того, размеры программ стали огромны, а диски (и оперативная
      память) остались относительно малы, поэтому появилась концепция
      разделяемых библиотек.  Система VM также стала более сложной.
      Хотя все эти усовершенствования были выполнены с форматом
      <filename>a.out</filename>, его полезность все больше и больше
      уменьшалась с каждым нововведением.  К тому же потребовалась
      динамическая загрузка во время выполнения, или выгрузка частей
      программы после выполнения стартового кода для экономии
      памяти или места на диске.  Языки усложнялись, и потребовался
      автоматический вызов кода перед главной программой.  Множество
      изменений было внесено в формат <filename>a.out</filename>, чтобы
      все это появилось, и в основном работало некоторое время.  Настал
      момент, когда <filename>a.out</filename> не смог решить все эти
      проблемы без чрезмерного увеличения размера и сложности.
      В то время, как <acronym>ELF</acronym> решил многие из этих проблем,
      перевод этого формата с системы на систему болезнен. Поэтому
      формату <acronym>ELF</acronym> пришлось подождать, пока не стало
      более болезненным оставаться с <filename>a.out</filename>, чем
      перейти на <acronym>ELF</acronym>.</para>

    <para>Тем временем, инструменты разработки, от которых
      произошли  инструменты разработки FreeBSD (особенно ассемблер и
      загрузчик), развивались в двух параллельных направлениях.
      Направление FreeBSD добавило разделяемые библиотеки и устранило
      некоторые ошибки.  Люди из GNU, написавшие эти программы,
      переписали их и добавили простую поддержку сборки
      кросс-компиляторов, подключения различных форматов в будущем
      и так далее.  Многим требовалось собрать кросс-компиляторы
      для FreeBSD, и это не удалось, поскольку устаревшие исходные
      тексты FreeBSD для <application>as</application> и
      <application>ld</application> не подходили для этой задачи.
      Новый набор инструментов GNU (<application>binutils</application>)
      поддерживает кросс-компилирование, <acronym>ELF</acronym>,
      разделяемые библиотеки, C++, расширения и т.д.  В дополнение,
      многие поставщики выпустили программы в формате
      <acronym>ELF</acronym> и они хорошо подходят для запуска в
      FreeBSD.</para>

    <para><acronym>ELF</acronym> более выразителен, чем
      <filename>a.out</filename>, позволяет базовой системе быть более
      гибкой.  <acronym>ELF</acronym> лучше поддерживается, и
      предоставляет поддержку кросс-компиляторов, что важно для многих
      людей.  <acronym>ELF</acronym> может быть немного медленнее,
      чем <filename>a.out</filename>, но замерить это сложно.
      Есть также множество деталей, отличающихся для этих двух
      форматов, в том как они отображают страницы, обрабатывают
      начальный код, и т.д.  В этом нет ничего очень важного,
      но они различаются.  В настоящее время поддержка
      <filename>a.out</filename> убрана из ядра <filename>GENERIC</filename>, и со
      временем будет убрана из ядра, как только потребность в запуске
      старых программ <filename>a.out</filename> останется в прошлом.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Дополнительная информация</title>

    <sect2 id="basics-man">
      <title>Системный справочник (man)</title>
      <indexterm><primary>страницы справочника</primary></indexterm>

      <para>Пожалуй, самым полным руководством по FreeBSD является
	системный справочник (man).  Практически каждое приложение или
	утилита имеют соответствующую страницу (часто не одну), описывающую
	тот или иной аспект работы программы, всевозможные опции и
	настройки.  Для просмотра этих страниц существует команда
	<command>man</command>:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para>Здесь <literal>command</literal> &ndash; это команда, о которой вы
	хотите получить информацию.  Например, чтобы узнать побольше о команде
	<command>ls</command>, наберите:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Содержимое системного справочника для удобства разделено на
	несколько разделов:</para>

      <orderedlist>
	<listitem>
	  <para>Пользовательские команды.</para>
	</listitem>

	<listitem>
	  <para>Системные вызовы и коды ошибок.</para>
	</listitem>

	<listitem>
	  <para>Функции стандартных библиотек.</para>
	</listitem>

	<listitem>
	  <para>Драйверы устройств.</para>
	</listitem>

	<listitem>
	  <para>Форматы файлов.</para>
	</listitem>

	<listitem>
	  <para>Развлечения и игры.</para>
	</listitem>

	<listitem>
	  <para>Дополнительная информация.</para>
	</listitem>

	<listitem>
	  <para>Команды системного администрирования.</para>
	</listitem>

	<listitem>
	  <para>Для разработчиков ядра.</para>
	</listitem>
      </orderedlist>

      <para>В некоторых случаях (не так уж редко), страницы, относящиеся к
	одной и той же команде, находятся в различных разделах справочника.
	Например, есть команда <command>chmod</command> и системный вызов
	<function>chmod()</function>.  В этом случае, необходимо явно указать
	раздел <command>man</command>, в котором нужно искать соответствующую
	страницу:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Эта команда выведет справку об утилите <command>chmod</command>.
	По традиции, конкретный раздел справочника указывается в скобках
	после команды, например, &man.chmod.1; относится к утилите
	<command>chmod</command>, а &man.chmod.2; &ndash; к соответствующему
	системному вызову.</para>

      <para>Часто бывает так, что вы не знаете название команды, но имеете
	представление о том, что она должна делать.  В этом случае можно
	попытаться найти нужную команду по ключевым словам, встречающимся в
	ее описании, используя опцию <option>-k</option> программы
	<command>man</command>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Вы получите список команд, имеющих слово <quote>mail</quote> в
	своих описаниях.  Это эквивалентно использованию команды
	<command>apropos</command>.</para>

      <para>Или например, вы видите список файлов в каталоге
	<filename>/usr/bin</filename>, при этом не имея ни малейшего
	представления о том, какие функции выполняет каждый их них?  Просто
	наберите:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>или</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>что фактически одно и то же.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>Файлы GNU Info</title>

      <para>FreeBSD поставляется с многочисленными приложениями и утилитами от
	Фонда Свободного Программного Обеспечения, Free Software Foundation
	(FSF).  В дополнение к страницам справочника, с этими программами
	поставляется обширная гипертекстовая документация в виде так называемых
	<literal>info</literal> файлов, которые могут быть просмотрены с
	помощью команды <command>info</command>, или, если установлен
	<application>emacs</application>, в info режиме	этого редактора.</para>

      <para>Чтобы воспользоваться командой &man.info.1;, просто наберите в
	командной строке:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Вызвать на экран краткое введение можно набрав
	<literal>h</literal>.  Краткий список команд можно получить набрав
	<literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
