<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/security/chapter.sgml,v 1.54 2006/06/30 12:36:59 marck Exp $

     Original revision: r28169
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Matthew</firstname>
	<surname>Dillon</surname>
	<contrib>Большая часть этой главы была взята из страницы справочника
	security(7) которую написал </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Денис</firstname>
	<surname>Пеплин</surname>
	<contrib>Перевод на русский язык: </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Безопасность</title>
  <indexterm><primary>безопасность</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>Краткое описание</title>

    <para>Эта глава представляет введение в основные концепции безопасности
      системы, некоторые эмпирические правила и более подробно обращается к
      отдельным темам, касающимся &os;.  Большая часть затрагиваемых тем может
      быть применена к безопасности системы и безопасности в интернет вообще.
      Интернет больше не то <quote>дружественное</quote> место, где каждый
      хочет быть вам добрым соседом.  Защита системы необходима для сохранения
      ваших данных, интеллектуальной собственности, времени и всего остального
      от хакеров и им подобных.</para>

    <para>&os; предоставляет массу утилит и механизмов для обеспечения
      целостности и безопасности системы и сети.</para>

    <para>После прочтения этой главы вы узнаете:</para>

    <itemizedlist>
      <listitem>
	<para>Основные концепции безопасности системы, специфику &os;.</para>
      </listitem>

      <listitem>
	<para>О различных механизмах шифрования в &os;, таких как
	  <acronym>DES</acronym> и <acronym>MD5</acronym>.</para>
      </listitem>

      <listitem>
	<para>Как настроить аутентификацию с использованием одноразовых
	  паролей.</para>
      </listitem>

      <listitem>
	<para>Как настроить <acronym>TCP</acronym> Wrappers для
	  использования с <command>inetd</command>.</para>
      </listitem>

      <listitem>
	<para>Как настроить <application>KerberosIV</application> в релизах
	  &os; до 5.0.</para>
      </listitem>

      <listitem>
	<para>Как настроить <application>Kerberos5</application> в &os;.</para>
      </listitem>

      <listitem>
	<para>Как настроить IPsec и создать <acronym>VPN</acronym> между
	  компьютерами на &os;/&windows;.</para>
      </listitem>

      <listitem>
	<para>Как настроить и использовать <application>OpenSSH</application>,
	  реализацию <acronym>SSH</acronym> в &os;.</para>
      </listitem>

      <listitem>
	<para>Что такое <acronym>ACL</acronym> и как их использовать.</para>
      </listitem>

      <listitem>
	<para>Как использовать утилиту <application>Portaudit</application> для
	  проверки пакетов сторонних разработчиков, установленных из Коллекции
	  Портов.</para>
      </listitem>

      <listitem>
	<para>Как работать с сообщениями безопасности &os;.</para>
      </listitem>

      <listitem>
	<para>Что такое Process Accounting и как активировать его во
	  &os;.</para>
      </listitem>
    </itemizedlist>

    <para>Перед чтением этой главы вам потребуется:</para>

    <itemizedlist>
      <listitem>
	<para>Понимание основных концепций &os; и интернет.</para>
      </listitem>
    </itemizedlist>

    <para>В этой книге рассмотрены и другие вопросы безопасности.
      Например, принудительный контроль доступа (Mandatory Access
      Control) рассматривается в <xref
      linkend="mac">, а брандмауэры в <xref
      linkend="firewalls">.</para>

  </sect1>

  <sect1 id="security-intro">
    <title>Введение</title>

    <para>Безопасность это первая и основная функция системного
      администратора.  Хотя все многопользовательские системы BSD &unix;
      уже снабжены некоторой защитой, работа по созданию и поддержке
      дополнительных механизмов безопасности, обеспечивающих защищенную работу
      пользователей, это одна из самых серьезных задач системного
      администратора.  Компьютеры безопасны настолько, насколько вы сделаете
      их безопасными и требования безопасности всегда находятся в противоречии
      с удобством работы пользователей.  Системы &unix; способны одновременно
      работать с огромным количеством процессов и многие из этих процессов
      серверные &mdash; это означает, что с ними могут взаимодействовать
      внешние программы.  Сегодня десктопы заменили мини-компьютеры и
      мэйнфрэймы, и поскольку компьютеры в наши дни подключены к сети
      интернет, безопасность важна как никогда.</para>

    <para>Наилучшая реализация системы безопасности представима в виде
      <quote>послойной</quote> системы.  Вообще говоря все, что нужно сделать,
      это создать столько слоев безопасности, сколько необходимо и затем
      внимательно следить за вторжениями в систему.  Не переусердствуйте в
      настройке системы безопасности, иначе она сделает невозможной
      обнаружение вторжений, являющееся одним из наиболее важных аспектов
      механизма безопасности.  Например, нет большого смысла в установке
      флага <literal>schg</literal> (&man.chflags.1;) на каждый исполняемый
      файл системы, поскольку хотя таким способом можно временно защитить
      исполняемые файлы, это помешает обнаружению факта взлома
      системы.</para>

    <para>Безопасность системы также относится к различным формам атак,
      имеющих своей целью вызвать крах системы, или сделать систему
      недоступной другим способом, но не пытающихся получить доступ к учётной
      записи <username>root</username> (<quote>break root</quote>).
      Угрозы безопасности могут быть поделены на несколько категорий:</para>

    <orderedlist>
      <listitem>
	<para>Отказ в обслуживании (Denial of service, DoS).</para>
      </listitem>

      <listitem>
	<para>Взлом пользовательских учётных записей.</para>
      </listitem>

      <listitem>
	<para>Взлом учётной записи root через доступные сервисы.</para>
      </listitem>

      <listitem>
	<para>Взлом учётной записи root через учётные записи
	  пользователей.</para>
      </listitem>

      <listitem>
	<para>Создание backdoor.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS атаки</primary>
      <see>отказ в обслуживании (Denial of Service, DoS)</see>
    </indexterm>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>DoS атаки</secondary>
      <see>отказ в обслуживании (Denial of Service, DoS)</see>
    </indexterm>
    <indexterm><primary>Отказ в обслуживании (Denial of Service, DoS)</primary></indexterm>

    <para>Атака <quote>отказ в обслуживании</quote> отбирает у машины
      необходимые ресурсы.  Обычно DoS атаки используют грубую силу, чтобы
      попытаться обрушить систему или сделать ее недоступной другим способом,
      превысив лимиты ее сервисов или сетевого стека.  Некоторые DoS атаки
      пытаются использовать ошибки в сетевом стеке для обрушения системы одним
      пакетом.  Эту проблему можно решить только исправив ядро системы.  Атаки
      зачастую можно предотвратить правильной установкой параметров,
      ограничивающих нагрузку на систему в неблагоприятных условиях. С
      атаками, использующими грубую силу, бороться сложно.  Например, атака с
      использованием пакетов с поддельными адресами, которую почти невозможно
      остановить, может быстро отключить вашу систему от интернет.  Возможно,
      она не приведет к отказу системы, но сможет переполнить соединение с
      интернет.</para>

    <indexterm>
      <primary>безопасность</primary>
      <secondary>взлом учётных записей</secondary>
    </indexterm>

    <para>Взлом учётной записи пользователя обычно встречается чаще, чем DoS
      атаки.  Многие системные администраторы все еще используют стандартные
      сервисы <application>telnetd</application>,
      <application>rlogind</application> и <application>ftpd</application> на
      своих серверах.  Эти сервисы по умолчанию не работают с зашифрованными
      соединениям.  В результате при среднем количестве пользователей пароль
      одного или нескольких пользователей, входящих в систему через внешнее
      соединение (это обычный и наиболее удобный способ входа в систему),
      будет перехвачен.  Внимательный системный администратор должен
      анализировать логи удаленного доступа на предмет подозрительных адресов
      пользователей даже в случае успешного входа.</para>

    <para>Кто-то может предположить, что атакующий при наличии доступа к
      учётной записи пользователя может взломать учётную запись
      <username>root</username>.  Однако, реальность такова, что в хорошо
      защищенной и поддерживаемой системе доступ к учётной записи пользователя
      не обязательно даст атакующему доступ к <username>root</username>.
      Разница между доступом к обычной учётной записи и к
      <username>root</username> важна, поскольку без доступа к
      <username>root</username> атакующий обычно не способен скрыть свои
      действия, и в худшем случае сможет лишь испортить файлы пользователя или
      вызвать крах системы.  Взлом пользовательских учётных записей
      встречается очень часто, поскольку пользователи заботятся о безопасности
      так, как системные администраторы.</para>

    <indexterm>
      <primary>безопасность</primary>
      <secondary>backdoors</secondary>
    </indexterm>

    <para>Системные администраторы должны помнить, что существует множество
      потенциальных способов взлома учётной записи <username>root</username>.
      Атакующий может узнать пароль <username>root</username>, найти ошибку в
      сервисе, работающем с привилегиями и взломать учётную запись
      <username>root</username> через сетевое соединение с этим сервисом, или
      узнать об ошибке в suid-root программе, позволяющей атакующему взлом
      <username>root</username> с помощью взломанной учётной записи
      пользователя.  Если атакующий нашел способ взлома
      <username>root</username>, ему может не понадобиться установка backdoor.
      Многие из обнаруженных и закрытых на сегодняшний день брешей
      в системе, позволяющие взлом <username>root</username>, требуют от
      атакующего серьезной работы по заметанию следов, поэтому большинство
      атакующих устанавливают backdoor.  Backdoor предоставляет атакующему
      простой способ восстановления доступа к системе с привилегиями
      <username>root</username>, но также дает системному администратору
      удобный способ обнаружения вторжения.  Устранение возможности установки
      backdoor возможно повредит безопасности системы, поскольку это
      не устранит брешь, позволившую проникнуть в
      систему.</para>

    <para>Меры безопасности всегда должны реализовываться на нескольких
      уровнях, которые могут быть классифицированы следующим образом:</para>

    <orderedlist>
      <listitem>
	<para>Защита <username>root</username> и служебных учётных
	  записей.</para>
      </listitem>

      <listitem>
	<para>Защита работающих под <username>root</username>
	  сервисов и suid/sgid исполняемых файлов.</para>
      </listitem>

      <listitem>
	<para>Защита учётных записей пользователей.</para>
      </listitem>

      <listitem>
	<para>Защита файла паролей.</para>
      </listitem>

      <listitem>
	<para>Защита ядра, raw устройств и файловых
	  систем.</para>
      </listitem>

      <listitem>
	<para>Быстрое обнаружение несанкционированных изменений в
	  системе.</para>
      </listitem>

      <listitem>
	<para>Паранойя.</para>
      </listitem>
    </orderedlist>

    <para>В следующем разделе этой главы эти темы изложены более
      подробно.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>Защита &os;</title>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>защита &os;</secondary>
    </indexterm>

    <note>
      <title>Команда и протокол</title>
      <para>В этом документе мы будет использовать
	<application>выделенный</application> текст, упоминая приложение,
	и <command>моноширинный</command> шрифт, упоминая определенные
	команды.  Для протоколов используется обычный шрифт.  Это
	типографическое отличие полезно для таких случаев, как ssh, поскольку
	это и команда и протокол.</para>
    </note>

    <para>В последующем разделе будут рассмотрены методы защиты системы
      &os;, упомянутые в <link
	linkend="security-intro">предыдущем разделе</link> этой главы.</para>

    <sect2 id="securing-root-and-staff">
      <title>Защита учётной записи <username>root</username> и служебных
	учётных записей</title>
      <indexterm>
	<primary><command>su</command></primary>
      </indexterm>

      <para>Во-первых, не беспокойтесь о защите служебных учётных записей,
	если не защищена учётная запись <username>root</username>.  В
	большинстве систем у учётной записи <username>root</username> есть
	пароль.  Использование пароля <username>root</username>
	опасно <emphasis>всегда</emphasis>.  Это не означает, что вы должны
	удалить пароль.  Пароль почти всегда необходим для доступа
	по консоли.  Но это означает, что вы должны сделать невозможным
	использование пароля не из консоли или может быть даже с помощью
	команды &man.su.1;.  Например, убедитесь, что псевдо-терминалы
	в файле <filename>/etc/ttys</filename> перечислены с параметром
	<literal>insecure</literal>, что делает невозможным вход на них
	под <username>root</username> напрямую с помощью
	<command>telnet</command> или <command>rlogin</command>.  При
	использовании других средств входа, таких как
	<application>sshd</application>, убедитесь что вход под
	<username>root</username> напрямую отключен и в них.  Сделайте
	это, открыв файл <filename>/etc/ssh/sshd_config</filename>, и
	убедившись, что параметр <literal>PermitRootLogin</literal>
	установлен в <literal>NO</literal>.  Проверьте каждый метод доступа
	&mdash; сервис FTP и ему подобные часто подвержены взлому.  Прямой
	вход под <username>root</username> должен быть разрешен только с
	системной консоли.</para>
      <indexterm>
	<primary><groupname>wheel</groupname></primary>
      </indexterm>

      <para>Конечно, как системный администратор вы должны иметь доступ
	<username>root</username>, поэтому потребуется открыть несколько
	<quote>лазеек</quote>.  Но убедитесь, что для доступа к ним необходим
	дополнительный пароль.  Одним из способов доступа к
	<username>root</username> является добавление соответствующих учётных
	записей к группе <groupname>wheel</groupname> (в файле
	<filename>/etc/group</filename>).  Это позволяет использовать
	<command>su</command> для доступа к <username>root</username>.
	Вы никогда не должны давать таким учётным записям доступ
	к <groupname>wheel</groupname> непосредственно, помещая их в группу
	<groupname>wheel</groupname> в файле паролей.  Служебные учётные
	записи должны помещаться в группу <groupname>staff</groupname>,
	а затем добавляться к группе <groupname>wheel</groupname> в файле
	<filename>/etc/group</filename>.  Только те члены группы staff,
	которым действительно нужен доступ к <username>root</username>,
	должны быть помещены в группу <groupname>wheel</groupname>.
	При работе с такими методами аутентификации как Kerberos, возможно также
	использование файла <filename>.k5login</filename> в каталоге
	пользователя <username>root</username> для доступа к учётной записи
	<username>root</username> с помощью &man.ksu.1; без помещения
	кого-либо в группу <groupname>wheel</groupname>.  Это решение возможно
	лучше, поскольку механизм <groupname>wheel</groupname> все еще
	позволяет взлом <username>root</username>, если злоумышленник
	получил копию файла паролей и смог взломать служебную учётную запись.
	Хотя использование механизма <groupname>wheel</groupname> лучше,
	чем работа через <username>root</username> напрямую, это не
	обязательно самый безопасный способ.</para>

      <!-- XXX:
	This will need updating depending on the outcome of PR bin/71147.
	Personally I know what I'd like to see, which puts this in definite
	need of a rewrite, but we'll have to wait and see.  ceri@
      -->

      <para>Непрямой способ защиты служебных учётных записей и конечно
	<username>root</username> это использование альтернативных методов
	доступа и замена зашифрованных паролей на символ
	<quote><literal>*</literal></quote>.  Используя команду
	&man.vipw.8;, замените каждый зашифрованный пароль служебных учётных
	записей на этот символ для запрета входа с аутентификацией по паролю.
	Эта команда обновит файл <filename>/etc/master.passwd</filename> и
	базу данных пользователей/паролей.</para>

      <para>Служебная учётная запись вроде этой:</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Должна быть заменена на такую:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Это изменение предотвратит обычный вход, поскольку зашифрованный
	пароль никогда не совпадет с <quote><literal>*</literal></quote>.
	После этого члены группы staff должны использовать другой механизм
	аутентификации, например &man.kerberos.1; или &man.ssh.1; с парой
	ключей: публичным и приватным.  При использовании такой	системы как
	Kerberos, потребуется защитить сервер Kerberos и рабочую станцию.
	При использовании пары публичного/приватного ключей с ssh,
	потребуется защитить компьютер, <emphasis>с</emphasis> которого
	происходит вход (обычно это рабочая станция).  Дополнительных слой
	защиты может быть добавлен путем защиты пары ключей при создании их
	с помощью &man.ssh-keygen.1;.  Возможность заменить пароли служебных
	учётных записей на <quote><literal>*</literal></quote> гарантирует
	также, что вход может быть осуществлен только через защищенные методы
	доступа, которые вы настроили.  Это принуждает всех членов staff
	использовать защищенные, шифрованные соединения для всех входов,
	что закрывает большую брешь, используемую многими нарушителями:
	перехват паролей с другого, слабо защищенного компьютера.</para>

      <para>Более непрямой механизм безопасности предполагает, что вы входите
	с более защищенного сервера на менее защищенный.  Например, если
	главный сервер работает со всеми сервисами, рабочая станция не должна
	работать ни с одним.  Для поднятия уровня безопасности до приемлемого
	уровня, число запущенных на ней сервисов необходимо сократить до
	минимума, вплоть до отключения их всех, кроме того необходимо
	использовать защищенный паролем хранитель экрана.  Конечно, при
	наличии физического доступа к рабочей станции атакующий может взломать
	любую систему безопасности.  Это определенно проблема, которую вы
	должны учитывать, но учтите также тот факт, что большинство взломов
	совершаются удаленно, через сеть, людьми, которые не имеют физического
	доступа к вашим рабочим станциям или серверам.</para>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Использование такой системы как Kerberos дает возможность
	заблокировать или изменить пароль в одном месте, что сразу
	отразиться на всех компьютерах, где существует служебная учётная
	запись.  Если эта учётная запись будет взломана, возможность
	немедленно изменить пароль на всех компьютерах нельзя недооценивать.
	Без этой возможности изменение паролей на N машинах может стать
	проблемой.  Вы можете также наложить ограничения на смену паролей
	с помощью Kerberos: не только установить значения timeout в
	Kerberos, но и добавить требование смены пароля пользователем
	после определенного периода времени (скажем, раз в месяц).</para>
    </sect2>

    <sect2>
      <title>Защита работающих под root сервисов и suid/sgid исполняемых
	файлов</title>

      <indexterm>
	<primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
	<primary>sandboxes</primary>
      </indexterm>
      <indexterm>
	<primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>rlogind</application></primary>
      </indexterm>

      <para>Предусмотрительный системный администратор запускает только те
	сервисы, в которых нуждается, ни больше ни меньше.  Учитывайте, что
	сервисы сторонних разработчиков наиболее подвержены ошибкам.  К примеру,
	работа со старыми версиями <application>imapd</application> или
	<application>popper</application> это все равно что раздача доступа
	<username>root</username> всему миру.  Никогда не запускайте
	сервисы, которые вы не проверили достаточно внимательно.  Многим
	сервисам не требуется работа под <username>root</username>.
	Например, даемоны <application>ntalk</application>,
	<application>comsat</application>, и
	<application>finger</application> могут быть запущены в так
	называемых <firstterm>песочницах</firstterm>
	(<firstterm>sandboxes</firstterm>).  Песочница это не идеальное
	решение, поскольку вызывает много проблем, но она подходит под
	модель послойной безопасности: если кто-то сможет взломать сервис,
	работающий в песочнице, ему потребуется взломать еще и саму
	песочницу.  Чем больше уровней (<quote>слоев</quote>) потребуется
	пройти атакующему, тем меньше вероятность его успеха.  Ошибки,
	позволяющие получать root доступ, находили фактически во всех
	сервисах, запускаемых под <username>root</username>, включая
	основные системные сервисы.  Если вы обслуживаете машину, на которую
	входят только через <application>sshd</application> и никогда не
	входят через <application>telnetd</application>,
	<application>rshd</application> или
	<application>rlogind</application>, отключите эти сервисы!</para>

      <para>В &os; сервисы
	<application>ntalkd</application>,
	<application>comsat</application> и
	<application>finger</application> теперь по умолчанию работают в
	<quote>песочнице</quote>.  Другая программа, которая может быть
	кандидатом на запуск в <quote>песочнице</quote> это
	&man.named.8;.  <filename>/etc/defaults/rc.conf</filename> включает
	необходимые для запуска <application>named</application>
	в <quote>песочнице</quote> аргументы в закомментированой форме.
	В зависимости от того, устанавливаете ли вы новую систему, или
	обновляете старую, учётные записи пользователей, используемые
	этими <quote>песочницами</quote> могут не быть созданы.
	Предусмотрительный системный администратор должен узнать о
	<quote>песочницах</quote> для сервисов и установить их если есть
	возможность.</para>
      <indexterm>
	<primary><application>sendmail</application></primary>
      </indexterm>

      <para>Есть множество других сервисов, которые обычно не работают в
	<quote>песочницах</quote>: <application>sendmail</application>,
	<application>popper</application>,
	<application>imapd</application>, <application>ftpd</application>,
	и другие.  Некоторым из этих сервисов есть альтернативы,
	но их установка может потребовать больше работы, чем вы готовы
	выполнить (фактор удобства).  Вы можете запустить эти сервисы под
	<username>root</username> и положиться на другие механизмы обнаружения
	вторжений, которые могут пройти через них.</para>

      <para>Другая большая потенциальная <username>root</username> брешь
	в системе это suid-root и sgid исполняемые файлы.  Большинство
	этих исполняемых файлов, таких как <application>rlogin</application>,
	установлены в <filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, или <filename>/usr/sbin</filename>.
	Хотя ничто не может быть безопасно на 100%, находящиеся по умолчанию
	в системе suid и sgid исполняемые файлы могут быть признаны
	достаточно безопасными.  Но <username>root</username> бреши все еще
	обнаруживаются в этих исполняемых файлах.  <username>root</username>
	брешь, обнаруженная в <literal>Xlib</literal> в 1998 делала
	<application>xterm</application> (который обычно suid) подверженным
	взлому.  Лучше сразу принять меры предосторожности, чем сожалеть
	потом. Предусмотрительный системный администратор ограничит права
	запуска suid исполняемых файлов, которые должны запускаться
	пользователями группы staff, только этой группой, а также запретит
	доступ (<command>chmod 000</command>) к тем исполняемым файлам
	suid, которые никем не используются.  Серверу без монитора обычно
	не требуется исполняемый файл <application>xterm</application>.
	Исполняемые sgid исполняемые файлы могут быть почти так же опасны.
	Если нарушитель сможет взломать sgid-kmem исполняемый файл, он
	возможно сможет прочесть <filename>/dev/kmem</filename> и
	таким образом получить файл зашифрованных паролей, что потенциально
	делает возможным взлом любой защищённой паролем учётной записи.
	Аналогично нарушитель, проникший в группу <literal>kmem</literal>,
	может отслеживать последовательности клавиш, отправляемые через
	псевдо-терминалы, включая те, что используют защищённые соединения.
	Нарушитель, вошедший в группу
	<groupname>tty</groupname> может сделать вывод почти на любой
	пользовательский терминал.  Если пользователь работает с
	терминальной программой или эмулятором с возможностью эмуляции
	клавиатуры, взломщик может потенциально сгенерировать поток данных,
	который заставит терминал пользователя ввести команду, и она будет
	запущена с правами этого пользователя.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Защита учётных записей пользователей</title>

      <para>Учетные записи пользователей обычно сложнее всего защитить.
	Вы можете ввести драконовские ограничения доступа к служебным учётным
	записям, заменив их пароли на символ
	<quote><literal>*</literal></quote>, но возможно не сможете сделать
	то же с обычными учётными записями пользователей.  Если есть
	такая возможность, вы возможно сможете защитить учётные записи
	пользователей соответствующим образом.  Если нет, просто
	более бдительно отслеживайте эти учётные записи.  Использование
	ssh и Kerberos для учётных записей пользователей более
	проблематично, поскольку требует дополнительной административной
	работы и технической поддержки, но все же это решение лучше,
	чем файл с шифрованными паролями.</para>
    </sect2>

    <sect2>
      <title>Защита файла паролей</title>

      <para>Единственный абсолютно надежный способ это замена на
	<literal>*</literal> максимально возможного количества паролей и
	использование ssh или Kerberos для доступа к таким учётным записям.
	Хотя файл с шифрованными паролями (<filename>/etc/spwd.db</filename>)
	доступен для чтения только <username>root</username>, возможно, что
	нарушитель сможет получить доступ на чтение к этому файлу, даже если
	не получит права <username>root</username> на запись.</para>

      <para>Ваши скрипты безопасности должны всегда проверять и составлять
	отчет об изменениях файла паролей (обратитесь к разделу <link
	linkend="security-integrity">Проверка целостности файлов</link>
	ниже по тексту).</para>
    </sect2>

    <sect2>
      <title>Защита ядра, raw устройств и файловых
	систем</title>

      <para>Если атакующий взломает <username>root</username>, он сможет
	сделать практически все, но есть способы усложнить его задачу.
	Например, в большинстве современных ядер встроено устройство
	перехвата пакетов.  В &os; оно называется
	<devicename>bpf</devicename>.  Нарушитель обычно пытается запустить
	перехват пакетов на взломанной машине.  Вы не должны предоставлять
	ему такой возможности, на большинстве систем устройство
	<devicename>bpf</devicename> не должно быть встроено в ядро.</para>

      <indexterm>
	<primary><command>sysctl</command></primary>
      </indexterm>
      <para>Но даже если вы выключите устройство <devicename>bpf</devicename>,
	все еще остаются проблемы, связанные с устройствами
	<filename>/dev/mem</filename> и
	<filename>/dev/kmem</filename>.
	Нарушитель все еще может писать на дисковые raw устройства.
	Есть также другая возможность ядра, загрузка модулей, &man.kldload.8;.
	Активный нарушитель может использовать KLD модуль для установки
	собственного устройства <devicename>bpf</devicename> или другого
	перехватывающего устройства на работающее ядро.  Для решения этих
	проблем запускайте ядро с большим уровнем безопасности, как минимум 1.
	Уровень безопасности может быть установлен с помощью
	<command>sysctl</command> через переменную
	<varname>kern.securelevel</varname>.  После установки уровня
	безопасности в 1 доступ на запись в raw устройства будет запрещена и
	полностью заработают специальные флаги <command>chflags</command>,
	такие как <literal>schg</literal>.  Убедитесь также, что
	флаг <literal>schg</literal> установлен на критически важных
	загрузочных исполняемых файлах, каталогах и файлах скриптов &mdash;
	на всем, что запускается до установке уровня безопасности.
	Это требует большого объема работы, и обновление системы на более
	высоком уровне безопасности может стать гораздо сложнее.  Вы можете
	пойти на компромисс и запускать систему на высоком уровне безопасности,
	но не устанавливать флаг <literal>schg</literal> для каждого
	существующего системного файла и каталога.  Другая возможность
	состоит в монтировании <filename>/</filename> и
	<filename>/usr</filename> только для чтения.  Необходимо заметить,
	что такие правила слишком жесткие и могут помешать обнаружению
	вторжения.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>Проверка целостности файлов: исполняемые, конфигурационные файлы
	и т.д.</title>

      <para>Вы можете защищать только ядро, файлы настройки и управления
	системой только до тех пор, пока эта защита не вступит в конфликт
	с удобством работы в системе.  Например, использование
	<command>chflags</command> для установки бита
	<literal>schg</literal> на большинство файлов в <filename>/</filename>
	вероятно может только навредить, поскольку хотя и может защитить
	файлы, препятствует обнаружению.  Последний слой системы безопасности,
	возможно, наиболее важный &mdash; обнаружение.  Остальные меры
	безопасности практически бесполезны (или, что еще хуже, могут дать
	вам ложное ощущение безопасности) если вы не обнаружите потенциальное
	вторжение.  Половина функций системы безопасности направлена на
	замедление атакующего, а не на его остановку, для того, чтобы дать
	системе обнаружения возможность поймать нарушителя на месте
	преступления.</para>

      <para>Лучший способ обнаружения вторжения &mdash; отслеживание
	измененных, отсутствующих, или неожиданно появившихся файлов.
	Для наблюдения за измененными файлами лучше всего использовать
	другую (зачастую централизованную) систему с ограниченным
	доступом.  Добавление написанных вами скриптов к этой дополнительно
	защищенной системе с ограниченным доступом делает ее практически
	невидимой для потенциальных взломщиков, и это важно.  В целях
	достижения максимального эффекта вам может потребоваться предоставить
	этой системе доступ к другим машинам в сети, обычно с помощью
	NFS экспорта только для чтения или сгенерировав пары ключей ssh
	для доступа к другим машинам по ssh.  Помимо большого объема
	сетевого трафика, NFS более скрытый метод &mdash; он позволяет
	контролировать файловые системы на каждом клиентском компьютере
	практически незаметно.  Если ваш сервер с ограниченным доступом
	подключен к клиентским компьютерам через коммутатор, NFS метод
	это зачастую лучший выбор.  При соединении через концентратор, или
	через несколько маршрутизаторов, NFS метод может стать слишком
	небезопасным и использование ssh может стать лучшим выбором даже
	несмотря на то, что ssh оставляет следы своей работы.</para>

      <para>Как только у вас появился сервер с ограниченным доступом,
	и как минимум доступ на чтение в клиентских системах, потребуется
	написать скрипты для выполнения мониторинга.  При наличии доступа
	по NFS вы можете написать скрипты с помощью простых системных утилит,
	таких как &man.find.1; и &man.md5.1;.  Лучше всего подсчитывать
	md5 файлов на клиентском компьютере как минимум один раз в день,
	а файлы, контролирующие запуск из <filename>/etc</filename> и
	<filename>/usr/local/etc</filename> даже более часто.  При
	обнаружении расхождений в md5, контролирующий компьютер должен
	просигналить системному администратору проверить изменившиеся
	файлы.  Хороший скрипт безопасности проверит также наличие
	несоответствующих исполняемых suid файлов и новых или измененных
	файлов в системных разделах <filename>/</filename> и
	<filename>/usr</filename>.</para>

      <para>При использовании ssh вместо NFS, написать скрипты безопасности
	гораздо сложнее.  Вам обязательно потребуется скопировать
	(<command>scp</command>) скрипты на клиентский компьютер,
	сделать из невидимыми, и для безопасности потребуется также
	скопировать исполняемые файлы (такие как find), которые будут
	использоваться скриптом.  Приложение <application>ssh</application>
	на клиентском компьютере может быть уже взломано.  В конечном итоге,
	без ssh не обойтись при работе через небезопасные соединения,
	но его гораздо сложнее использовать.</para>

      <para>Хороший скрипт безопасности проверит также изменения в файлах
	настройки, работающих при подключении пользователей и служебных учётных
	записей:
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> и так далее&hellip;
	файлы, которые могли не попасть в область проверки
	<literal>MD5</literal>.</para>

      <para>Если для пользователей выделен большой объем дискового
	пространства, проверка каждого файла на таких разделах может занять
	слишком много времени.  В таком случае установка флагов монтирования
	для запрета suid исполняемых файлов и устройств на таких разделах
	это хорошая идея.  Примените параметры &man.mount.8;
	<literal>nodev</literal> и <literal>nosuid</literal>.  Проверяйте
	эти разделы в любом случае, хотя бы раз в неделю, поскольку
	необходимо обнаруживать попытки взлома, независимо от того,
	эффективны они или нет.</para>

      <para>Учет процессов (&man.accton.8;) это относительно несложная
	возможность операционной системы, которая может помочь
	как механизм обнаружения состоявшихся вторжений.  Она особенно
	полезна для обнаружения пути проникновения нарушителя в систему,
	если файл не был затронут проникновением.</para>

      <para>Наконец, скрипты безопасности должны обработать лог файлы,
	которые необходимо создавать настолько защищенным способом, насколько
	это возможно &mdash; подключение syslog удаленно может быть очень
	полезным.  Злоумышленник попытается уничтожить следы взлома,
	и лог файлы критически важны для системного администратора,
	пытающегося отследить время и метод первого проникновения.
	Один из надежных способов получения лог файлов является подключение
	системной консоли к последовательному порту и постоянный
	сбор информации через защищенную машину, отслеживающую
	консоли.</para>
    </sect2>

    <sect2>
      <title>Паранойя</title>

      <para>Немного паранойи никогда не повредит.  Как правило, системный
	администратор может добавлять элементы безопасности в любом
	количестве, пока это не влияет на удобство, а также некоторое
	количество элементов безопасности, <emphasis>влияющих</emphasis>
	на удобство.  Что даже более важно, системный администратор должен
	немного изменить их &mdash; если вы используете рекомендации, например
	те, что даны в этом документе, они становятся известны атакующему,
	который также имеет доступ к этому документу.</para>
    </sect2>

    <sect2>
      <title>Атаки DoS</title>
      <indexterm><primary>Отказ в обслуживании (DoS)</primary></indexterm>

      <para>Этот раздел охватывает DoS атаки.  DoS атаки это обычно
	пакетные атаки.  Хотя против современной атаки с подделкой пакетов,
	которая перегружает сеть, мало что можно сделать, вы можете
	ограничить повреждения, убедившись, что атака не может
	обрушить ваши сервера.</para>

      <orderedlist>
	<listitem>
	  <para>Ограничение количества порождаемых процессов.</para>
	</listitem>

	<listitem>
	  <para>Уменьшение последствий springboard атак (ICMP ответ,
	    широковещательный ping и т.д.).</para>
	</listitem>

	<listitem>
	  <para>Кэш маршрутизации ядра.</para>
	</listitem>
      </orderedlist>

      <para>Обычная DoS атака против порождающего процессы сервера пытается
	исчерпать ресурсы сервера по процессам, файловым дескрипторам и
	памяти до тех пор, пока машина не <quote>повиснет</quote>.  У
	<application>inetd</application> (обратитесь к &man.inetd.8;)
	есть несколько параметров, позволяющих ограничить такие атаки.
	Необходимо учесть, что хотя можно предотвратить падение системы, в
	общем случае невозможно предотвратить прекращение работы сервиса.
	Внимательно прочтите страницу справочника и обратите особое внимание
	на параметры <option>-c</option>, <option>-C</option>, и
	<option>-R</option>.  Учтите, что параметр <option>-C</option> не
	работает в случае атак с использованием поддельных IP пакетов,
	поэтому как правило необходимо использование комбинации параметров.
	Некоторые standalone сервисы используют собственные параметры,
	ограничивающие порождение процессов.</para>

      <para>У <application>Sendmail</application> есть собственный параметр
	<option>-OMaxDaemonChildren</option>, которая работает гораздо лучше,
	чем параметр sendmail, ограничивающий нагрузку. Вам необходимо задать
	параметр запуска <application>sendmail</application>
	<literal>MaxDaemonChildren</literal> достаточно большим, чтобы
	обслуживать ожидаемую нагрузку, но так, чтобы компьютер мог обслужить
	такое количество приложений <application>sendmail</application> без
	падения системы.  Хорошей мерой является запуск sendmail в режиме
	очереди (<option>-ODeliveryMode=queued</option>) и запуск даемона
	(<command>sendmail -bd</command>) отдельно от очереди
	(<command>sendmail -q15m</command>).  Если вы все же хотите
	организовать доставку в режиме реального времени, запускайте
	очередь с меньшим интервалом <option>-q1m</option>, но убедитесь
	в правильной установке параметра sendmail
	<literal>MaxDaemonChildren</literal> для предотвращения
	ошибок.</para>

      <para><application>Syslogd</application> может быть атакован
	непосредственно, настоятельно рекомендуется использовать параметр
	<option>-s</option> если это возможно и параметр <option>-a</option>
	в остальных случаях.</para>

      <para>Вы также должны быть очень осторожны с сервисами, совершающими
	обратное подключение, например, с <application>TCP
	Wrapper</application> и его обратным identd-запросом, который может
	быть атакован напрямую.  По этой причине возможность <application>TCP
	Wrapper</application> генерировать обратный ident обычно не следует
	использовать.</para>

      <para>Правильным будет запрет доступа к внутренним сервисам из внешней
	сети путем соответствующей настройки брандмауэра на внешнем
	маршрутизаторе.  Идея в том, чтобы предотвратить перегрузку сервисов
	атаками из внешней сети, а кроме того защитить
	<username>root</username> от взлома через сеть.  Всегда настраивайте
	исключающий брандмауэр, т.е. <quote>закрыть все
	<emphasis>кроме</emphasis> портов A, B, C, D, и M-Z</quote>.
	Этим способом вы можете закрыть все порты нижнего диапазона,
	кроме явно указанных, таких как <application>named</application>
	(если вы поддерживаете интернет-зону),
	<application>ntalkd</application>,
	<application>sendmail</application>, и других сервисов, доступных
	из интернет.  Если вы попробуете настроить брандмауэр другим
	способом &mdash; включающий, или разрешающий брандмауэр, есть
	большой шанс забыть <quote>закрыть</quote> пару сервисов, или
	добавить новый внутрисетевой сервис и забыть обновить брандмауэр.
	Вы можете открыть диапазон портов с большими номерами
	для обычных приложений без угрозы портам нижнего диапазона.
	Учтите также, что &os; позволяет вам контролировать диапазоны
	портов, используемые для динамической привязки через различные
	переменные <command>sysctl</command>
	<varname>net.inet.ip.portrange</varname> (<command>sysctl -a | fgrep
	portrange</command>), что позволяет упростить настройку
	брандмауэра.  Например, вы можете использовать обычный
	диапазон портов со значениями от 4000 до 5000, и диапазон портов с
	большими номерами от 49152 до 65535, а затем заблокировать все до
	4000 порта (конечно оставив доступ из интернет к определенным
	портам.</para>

      <para>Другой распространенный тип DoS атак называется springboard
	&mdash; сервер атакуется таким образом, что генерируемые ответы
	перегружают его, локальную сеть или какие-то другие компьютеры.
	Наиболее распространенная атака этого вида это
	<emphasis>широковещательная ICMP ping атака</emphasis>.
	Атакующий подделывает пакеты ping, подставляя IP адрес машины, которую
	он намеревается атаковать, и отправляет их на широковещательный
	адрес вашей локальной сети.  Если ваш внешний маршрутизатор не
	настроен на отбрасывание пакетов ping на широковещательные адреса,
	ваша сеть начинает генерировать соответствующие ответы на
	поддельный адрес, что приводит к перегрузке хоста-жертвы, особенно
	если атакующий использует этот же трюк с множеством
	широковещательных адресов в множестве сетей одновременно.
	Были зарегистрированы широковещательные атаки свыше ста двадцати
	мегабит.  Другая распространенная springboard атака направлена на
	ICMP систему сообщения об ошибках.  Конструируя пакеты, вызывающие
	ICMP сообщения об ошибках, атакующий может нагрузить входящее
	соединение сервера и вынудить сервер нагрузить исходящее соединение
	ICMP ответами.  Этот тип атаки может также обрушить сервер, когда
	тот исчерпает mbuf, обычно если сервер не может ограничить число
	ответов ICMP, когда они генерируются слишком быстро.
	Используйте переменную <application>sysctl</application>
	<literal>net.inet.icmp.icmplim</literal>.  Последний
	основной класс springboard атак относится к определенным
	внутренним сервисам <application>inetd</application>, таким как
	сервис udp echo.  Атакующий просто подделывает адрес источника
	и адрес назначения UDP пакетов, устанавливая в их качестве
	соответственно echo порт сервера A и B, оба этих сервера принадлежат
	вашей локальной сети.  Эти два сервера начинают перебрасываться
	этим пакетом друг с другом.  Атакующий может вызвать перегрузку
	обеих серверов и их сетей, просто отправив несколько пакетов таким
	способом.  Аналогичные проблемы существуют с портом
	<application>chargen</application>.  Компетентный системный
	администратор должен отключить эти тестовые сервисы inetd.</para>

      <para>Атаки с поддельными пакетами могут также использоваться для
	переполнения кэша маршрутизации ядра.  Обратитесь к параметрам
	<command>sysctl</command> <varname>net.inet.ip.rtexpire</varname>,
	<varname>rtminexpire</varname>, и <varname>rtmaxcache</varname>.
	Атака с поддельными пакетами, использующая произвольный IP адрес
	источника, заставит ядро сгенерировать временный кэшированный
	маршрут в таблице маршрутизации, который можно увидеть с помощью
	<command>netstat -rna | fgrep W3</command>.  Эти маршруты обычно
	удаляются через 1600 секунд или около того.  Если ядро определит,
	что кэшированная маршрутная таблица стала слишком большой, оно
	динамически уменьшит <varname>rtexpire</varname>, но никогда не
	станет делать его меньше чем <varname>rtminexpire</varname>.
	С этим связаны две проблемы:</para>

      <orderedlist>
	<listitem>
	  <para>Ядро не отреагирует достаточно быстро, когда легко нагруженный
	    сервер будет внезапно атакован.</para>
	</listitem>

	<listitem>
	  <para>Значение <varname>rtminexpire</varname> недостаточно мало
	    для поддержки работоспособности в условиях продолжительной
	    атаки.</para>
	</listitem>
      </orderedlist>

      <para>Если ваши серверы подключены к интернет через линию T3 или
	более быструю, предусмотрительно будет изменить оба значения
	<varname>rtexpire</varname> и <varname>rtminexpire</varname>
	с помощью &man.sysctl.8;.  Никогда не устанавливайте ни один из этих
	параметров в нуль (если только вы не хотите обрушить систему).
	Установка обеих параметров в значение 2 секунды должна предотвратить
	таблицу маршрутизации от атак.</para>
    </sect2>

    <sect2>
      <title>Проблемы, связанные с доступом к Kerberos и SSH</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>При использовании Kerberos и ssh необходимо учесть несколько
	возможных проблем.  Kerberos V это отличный протокол
	аутентификации, но в адаптированных к нему приложениях
	<application>telnet</application> и
	<application>rlogin</application> есть несколько ошибок, которые
	могут сделать их непригодными к работе с бинарными потоками.
	К тому же, по умолчанию Kerberos не шифрует сессию, если вы не
	используете параметр <option>-x</option>.
	<application>ssh</application> шифрует все по умолчанию.

      <para>ssh работает очень хорошо во всех ситуациях, но пересылает
	ключи по умолчанию.  Это означает, что если вы работаете с
	защищенной рабочей станции, ключи на которой дают доступ к
	остальной сети, и заходите по ssh на незащищенный компьютер,
	эти ключи могут быть использованы для взлома.  Атакующему
	не удастся получить сами ключи, но поскольку ssh открывает порт
	во время входа в систему, то если на незащищенной машине
	взломан <username>root</username>, эти ключи могут быть использованы
	для доступа к другим компьютерам, на которых они действуют.</para>

      <para>Мы рекомендуем использовать ssh в комбинации с Kerberos
	для служебных учётных записей если это возможно.
	<application>ssh</application> может быть собран с поддержкой
	Kerberos.  Это уменьшает зависимость от потенциально подверженных
	взлому ssh ключей, и в то же время защищает пароли через
	Kerberos.  Ключи ssh должны использоваться только для работы
	скриптов на защищенных компьютерах (там, где Kerberos использовать
	не получится).  Мы также рекомендуем или выключить передачу ключей
	в настройках ssh, или использовать параметр
	<literal>from=IP/DOMAIN</literal>, поддерживаемый ssh в файле
	<filename>authorized_keys</filename>, который позволяет использовать
	ключи только с определенных компьютеров.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Частично переписал и обновил </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, MD5, и шифрование</title>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>шифрование</secondary>
    </indexterm>

    <indexterm><primary>шифрование</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>У каждого пользователя &unix; системы есть пароль, связанный с его
      учётной записью.  Очевидно, что эти пароли должны быть известны только
      пользователю и соответствующей операционной системе.  Для защиты паролей
      они шифруются способом, известным как <quote>односторонний хэш</quote>,
      то есть их можно легко зашифровать, но нельзя расшифровать.  Другими
      словами, то, что мы сказали чуть раньше было очевидно, но не совсем
      верно: операционной системе <emphasis>сам пароль</emphasis>
      неизвестен.  Ей известен только пароль в
      <emphasis>зашифрованной</emphasis> форме.  Единственный способ получить
      <quote>обычный</quote> пароль это простой перебор всех возможных
      паролей.</para>

    <para>К сожалению, единственный способ шифрования пароля при появлении
      &unix; был основан на DES, Data Encryption Standard.  Это не было
      проблемой для пользователей, живущих в США, но поскольку исходный код
      DES нельзя было экспортировать из США, &os; нашла способ одновременно
      не нарушать законов США и сохранить совместимость со всеми другими
      вариантами &unix;, где все еще использовался DES.</para>

    <para>Решение было в разделении библиотек шифрования, чтобы пользователи
      в США могли устанавливать и использовать библиотеки DES, а у остальных
      пользователей был метод шифрования, разрешенный к экспорту.  Так
      &os; пришла к использованию MD5 в качестве метода шифрования по
      умолчанию.  MD5 считается более безопасным, чем DES, поэтому установка
      DES рекомендуется в основном из соображений совместимости.</para>

    <sect2>
      <title>Определения механизма шифрования</title>

      <para>На данный момент библиотека поддерживает хэши DES, MD5 и
	Blowfish.  По умолчанию &os; использует для шифрования паролей
	MD5.</para>

      <para>Довольно легко определить какой метод шифрования используется
	в &os;.  Один из способов это проверка файла
	<filename>/etc/master.passwd</filename>.  Пароли, зашифрованные в
	хэш MD5 длиннее, чем те, что зашифрованы с помощью DES и начинаются
	с символов <literal>&dollar;1&dollar;</literal>.  Пароли, начинающиеся
	с символов <literal>&dollar;2a&dollar;</literal> зашифрованы с помощью
	Blowfish.  Пароли, зашифрованные DES не содержат каких-то определенных
	идентифицирующих символов, но они короче, чем пароли MD5 и
	закодированы в 64-символьном алфавите, не содержащем символа
	<literal>&dollar;</literal>, поэтому относительно короткая строка,
	не начинающаяся с этого символа это скорее всего DES пароль.</para>

      <para>Формат паролей, используемых для новых паролей, определяется
	параметром <literal>passwd_format</literal> в
	<filename>/etc/login.conf</filename>, которое может принимать значения
	<literal>des</literal>, <literal>md5</literal> или
	<literal>blf</literal>.  Обратитесь к странице справочника
	&man.login.conf.5; за дополнительной информацией о параметрах
	login.</para>

    </sect2>
  </sect1>

  <sect1 id="one-time-passwords">
    <title>Одноразовые пароли</title>
    <indexterm><primary>одноразовые пароли</primary></indexterm>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>одноразовые пароли</secondary>
    </indexterm>

    <para>&os; использует для одноразовых паролей
      OPIE (One-time Passwords In Everything).
      OPIE по умолчанию использует MD5.</para>

    <para>Есть три различных вида паролей, о которых мы поговорим ниже.
      Первый вид это ваш обычный пароль &unix; или пароль Kerberos; мы
      будем называть его <quote>пароль &unix;</quote>.  Второй вид это
      одноразовый пароль, сгенерированный программой
      OPIE &man.opiekey.1; и принимаемый
      командой &man.opiepasswd.1;
      и в приглашении login; мы будем называть их <quote>одноразовыми
      паролями</quote>.  Последний вид паролей это защищенные пароли, которые
      вы передаете программам <command>opiekey</command> (и иногда
      <command>opiepasswd</command>),
      и которые эти программы используют для создания одноразовых паролей;
      мы будем называть его <quote>защищенными паролями</quote> или просто
      <quote>паролями</quote>.</para>

    <para>Защищенный пароль не имеет никакого отношения к вашему паролю
      &unix;; они могут быть одинаковыми, но это не рекомендуется.
      Защищенные пароли OPIE не ограничены 8-ю символами, как
      старые &unix; пароли<footnote><para>В &os; стандартный пароль
      может быть до 128 символов длиной.</para></footnote>,
      они могут быть настолько длинными, насколько вы захотите.  Очень часто
      используются пароли длиной в шесть или семь символов.  По большей части
      система OPIE работает полностью независимо от системы
      паролей &unix;.</para>

    <para>Помимо паролей, есть два других вида данных, важных для
      OPIE.  Первый, известный как <quote>seed</quote> или
      <quote>ключ</quote>, состоит из двух букв и пяти цифр.  Другой,
      называемый <quote>счетчиком цикла</quote>, это номер от 1 до 100.
      OPIE создает одноразовый пароль, соединяя ключ и защищенный пароль,
      а затем применяя MD4 столько раз, сколько указано счетчиком цикла и
      выдает результат в виде шести коротких слов на английском.  Эти шесть
      слов на английском и есть ваш одноразовый пароль.  Система
      аутентификации (как правило PAM) хранит последний использованный
      одноразовый пароль, и пользователь аутентифицируется если хэш вводимого
      пользователем пароля совпадает с предыдущим паролем.  Поскольку
      используется односторонний хэш, невозможно сгенерировать следующий
      одноразовый пароль если получен предыдущий; счетчик цикла уменьшается
      после каждого успешного входа для поддержки синхронизации пользователя
      с программой login.  Когда счетчик цикла уменьшается до 1, набор OPIE
      должен быть переинициализирован.</para>

    <para>В каждой из обсуждаемых ниже систем задействованы три программы.
      Программа <command>opiekey</command>
      получает счетчик цикла, ключ и защищенный пароль и создает одноразовый
      пароль или последовательный список одноразовых паролей.  Программа
      <command>opiepasswd</command>
      используется для инициализации OPIE соответственно,
      и для смены паролей, счетчиков цикла, или ключей; она принимает
      защищенный пароль или счетчик цикла, ключ и одноразовый пароль.
      Программа <command>opieinfo</command>
      проверяет соответствующий файл (<filename>/etc/opiekeys</filename>)
      и печатает текущий счетчик
      цикла и ключ вызывающего пользователя.</para>

    <para>Мы рассмотрим четыре вида операций.  Первая это использование
      <command>opiepasswd</command> через
      защищенное соединение для первоначальной настройки системы одноразовых
      паролей, или для изменения пароля или ключа.  Вторая операция это
      использование в тех же целях
      <command>opiepasswd</command> через незащищенное соединение, в сочетании
      с <command>opiekey</command> через защищенное
      соединение.  Третья это использование
      <command>opiekey</command> для входа через
      незащищенное соединение.  Четвертая это использование
      <command>opiekey</command> для генерации
      набора ключей, которые могут быть записаны или распечатаны для
      соединения из места, где защищенное соединение недоступно.</para>

    <sect2>
      <title>Защищенная установка соединения</title>

      <para>Для первоначальной настройки OPIE используется команда
	<command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para>В приглашениях <prompt>Enter new secret pass phrase:</prompt> или
	<prompt>Enter secret password:</prompt>, введите пароль или фразу.
	Запомните, это не тот пароль, с которым вы будете входить, он
	используется для генерации одноразовых паролей.  Строка
	<quote>ID</quote> содержит информацию для вашего конкретного случая:
	имя пользователя, счетчик цикла и ключ.  При входе система запомнит
	эти параметры и отправит их вам, поэтому их не надо запоминать.  В
	последней строке находится одноразовый пароль, соответствующий
	этим параметрам и секретному паролю; если вы войдете в систему сразу,
	используйте этот одноразовый пароль.</para>
    </sect2>

    <sect2>
      <title>Незащищенная установка соединения</title>

      <para>Для инициализации или изменения защищенного пароля через
	незащищенное соединение, вам потребуется существующее защищенное
	соединение куда-то, где вы сможете запустить
	<command>opiekey</command>; это может быть
	shell на компьютере, которому вы доверяете.
	Вам потребуется также установить значение счетчика цикла (100
	возможно подойдет), и задать ключ или использовать сгенерированный.
	Через незащищенное соединение (к компьютеру, на котором производится
	настройка), используйте команду <command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

	<!--russian translation issue: seed/key == ключ? -->
      <para>Чтобы принять ключ по умолчанию нажмите <keycap>Enter</keycap>.
	Затем, перед вводом пароля доступа введите те же параметры в
	вашем защищенном соединении или средстве доступа OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Теперь переключитесь на незащищенное соединение и скопируйте
	одноразовый пароль, сгенерированный соответствующей программой.</para>
    </sect2>

    <sect2>
      <title>Создание одного одноразового пароля</title>

      <para>Как только вы настроите OPIE, во время входа появится
	приглашение вроде этого:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>Кроме того, у OPIE есть полезная особенность (не
	показанная здесь): если вы нажмете <keycap>Enter</keycap>
	в приглашении на ввод пароля, включится эхо, и вы сможете увидеть
	то, что вводите.  Это может быть очень полезно, если вы пытаетесь
	ввести пароль вручную, например с распечатки.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>В этот момент вам потребуется сгенерировать одноразовый пароль,
	чтобы ввести его в приглашение.  Это должно быть выполнено на
	защищенной системе, в которой вы можете запустить
	<command>opiekey</command> (есть версии
	для DOS, &windows; и &macos;).  Им требуются значения счетчика цикла
	и ключ в качестве параметров командной строки.  Вы можете скопировать
	и вставить их прямо из приглашения login компьютера, на который
	входите.</para>

      <para>В защищенной системе:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Теперь, когда у вас есть одноразовый пароль, можете продолжить
	вход в систему.</para>
    </sect2>

    <sect2>
      <title>Создание нескольких одноразовых паролей</title>

      <para>Иногда вы отправляетесь туда, где нет доступа к защищенному
	компьютеру или защищенному соединению.  В этом случае, можно
	использовать команду
	<command>opiekey</command> для создания нескольких одноразовых
	паролей, которые вы сможете распечатать и забрать с собой.
	Например:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>Параметр <option>-n 5</option> запрашивает пять паролей,
	<option>30</option> указывает значение последнего счетчика цикла.
	Обратите внимание, что пароли печатаются в
	<emphasis>обратном</emphasis> по сравнению с обычным использованием
	порядке.  Если вы действительно параноик, перепишите результат
	вручную; иначе скопируйте и передайте его <command>lpr</command>.
	Обратите внимание, что каждая линия содержит как счетчик цикла, так
	и одноразовый пароль; вам может показаться удобным отрывать пароль
	после использования.</para>
    </sect2>

    <sect2>
      <title>Ограничение использования &unix; паролей</title>

      <para>OPIE может ограничивать использование паролей &unix; на основе IP
	адреса.  Соответствующий файл называется
	<filename>/etc/opieaccess</filename>, он существует по умолчанию.
	Обратитесь к
	&man.opieaccess.5; за более подробной информацией об этом файле и о
	предосторожностях, которые вы должны предпринять при использовании
	этого файла.</para>

      <para>Вот пример файла <filename>opieaccess</filename>:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Эта строка позволяет пользователям, чей IP адрес (который
	подвержен подделке) соответствует указанному значению и маске,
	входить с паролем &unix;.</para>

      <para>Если ни одно из правил в <filename>opieaccess</filename> не
	сработало, поведением по умолчанию является запрет всех не-OPIE
	входов.</para>

    </sect2>
  </sect1>

  <sect1 id="tcpwrappers">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Написал: </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>TCP Wrappers</primary></indexterm>

    <title>TCP Wrappers</title>

    <para>Каждый, кто знаком с &man.inetd.8;, возможно когда-то слышал
      о <acronym>TCP</acronym> Wrappers.  Но немногие полностью
      понимают их полезность в сетевой среде: большинство
      используют брандмауэр.  Хотя его применимость очень широка,
      есть вещи, с которыми брандмауэр не может работать, такие
      как отправка текста обратно вызывающей стороне.  Программное
      обеспечение уровня <acronym>TCP</acronym> может делать это
      и многое другое.  В следующих нескольких разделах обсуждаются
      многие возможности <acronym>TCP</acronym> Wrappers, и, когда
      это необходимо, даются примеры настроек.</para>

    <para>Программное обеспечение <acronym>TCP</acronym> Wrappers
      расширяет возможность <command>inetd</command> по поддержке
      каждого даемона.  С ним становится возможным протоколирование,
      возврат сообщений вызывающей стороне, ограничение подключений
      внутренней сетью и т.п.  Хотя некоторые из этих возможностей
      могут быть реализованы брандмауэром, <acronym>TCP</acronym>
      Wrappers не только предоставляют дополнительный уровень защиты,
      но и дают больше контроля над системой, чем это возможно
      с брандмауэром.</para>

    <para>Расширенная функциональность обработчиков <acronym>TCP</acronym>
      не может заменить хороший сетевой экран.  Тем не менее, обработчики
      <acronym>TCP</acronym> могут использоваться совместно с сетевым экраном
      и другими средствами обеспечения информационной безопасности, обеспечивая
      тем самым дополнительный уровень защиты системы.</para>

    <para>Поскольку рассматривается расширение к настройкам
      <command>inetd</command>, предполагается, что читатель ознакомился
      с разделом о <link linkend="network-inetd">настройке
      inetd</link>.</para>

    <note>
      <para>Хотя программы, запускаемые из &man.inetd.8;, на самом деле не
	соответствуют термину <quote>даемоны</quote>, существует традиция
	называть их именно так.  Этот термин и используется в данном
	разделе.</para>
    </note>

    <sect2>
      <title>Начальная настройка</title>

      <para>Единственное требование для использования <acronym>TCP</acronym>
	Wrappers в &os; это наличие в <filename>rc.conf</filename>
	параметров запуска <command>inetd</command> <option>-Ww</option>;
	это настройки по умолчанию.  Конечно, ожидается также наличие
	правильной настройки <filename>/etc/hosts.allow</filename>,
	но &man.syslogd.8; отправит сообщения в системный протокол если
	что-то не так.</para>

      <note>
	<para>В отличие от других реализаций <acronym>TCP</acronym>
	  Wrappers, использование <filename>hosts.deny</filename> не
	  поддерживается.  Все параметры настройки должны быть помещены
	  в <filename>/etc/hosts.allow</filename>.</para>
      </note>

      <para>В простейшей конфигурации, политика подключения сводится к
	разрешению или блокированию в зависимости от параметров в
	<filename>/etc/hosts.allow</filename>.  Настройка в &os;
	по умолчанию заключается в разрешении подключения к любому
	даемону, запущенному из <command>inetd</command>.  Изменение
	этого поведения будет обсуждаться только после рассмотрения
	базовой настройки.</para>

      <para>Базовая настройка обычно принимает форму
	<literal>daemon : address : action</literal>, где
	<literal>daemon</literal> это имя даемона, который запускается
	<command>inetd</command>.  В поле <literal>address</literal>
	может находиться имя хоста, <acronym>IP</acronym> адрес, или
	IPv6 адрес, заключенный в квадратные скобки ([&nbsp;]).
	Поле action может принимать значения allow или deny,
	чтобы соответственно разрешать или запрещать доступ.
	Помните, что поиск правил производится до первого совпадения.
	При обнаружении совпадения применяется соответствующее правило
	и поиск прерывается.</para>

      <para>Существуют и другие параметры, но они будут описаны в следующих
	разделах.  Простая конфигурация может быть, например, такой:
	для разрешения соединений по протоколу <acronym>POP</acronym>3
	к даемону <filename role="package">mail/qpopper</filename>,
	в <filename>hosts.allow</filename> необходимо добавить следующие
	строки:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>После добавления этой строки, <command>inetd</command>
	необходимо перезапустить.  Это можно выполнить командой
	&man.kill.1; или скриптом <filename>/etc/rc.d/inetd</filename>
	с параметром <parameter>restart</parameter>.</para>
      </sect2>

      <sect2>
	<title>Расширенная конфигурация</title>

      <para>У <acronym>TCP</acronym> Wrappers имеются дополнительные
	параметры; они дают дополнительные возможности контроля над
	соединениями.  Иногда бывает полезно возвращать комментарий
	определенным хостам или при подключении к определенным
	даемонам.  В других случаях может быть необходимо добавить
	запись в лог файл, или отправить письмо администратору.
	В определенных ситуациях сервис должен использоваться
	только для локальных соединений.  Все это возможно с
	использованием параметров c шаблонами, символами подстановки
	и путем выполнения внешних команд.  Следующие два раздела
	посвящены этим типам настроек.</para>

      <sect3>
	<title>Внешние команды</title>

	<para>Предположим ситуацию, в которой соединение должно
	  быть запрещено, а о причине необходимо сообщить вызывающей
	  стороне.  Как это можно сделать?  Соответствующую
	  возможность предоставляет параметр <option>twist</option>.
	  При попытке подключения выполняется команда или скрипт,
	  заданный этим параметром.  Пример дан в файле
	  <filename>hosts.allow</filename>:</para>

	<programlisting># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>В этом примере сообщение,
	  <quote>You are not allowed to use <literal>daemon</literal>
	  from <literal>hostname</literal>.</quote> будет возвращено
	  от всех даемонов, которые не были предварительно настроены
	  в файле доступа.  Обратите внимание, что возвращаемое
	  сообщение <emphasis>должно</emphasis> быть заключено в
	  кавычки; из этого правила нет исключений.</para>

	<warning>
	  <para>Возможна реализация DoS атаки, когда группа
	    атакующих производит множество запросов на подключение.</para>
	</warning>

	<para>Возможно также использование параметра <option>spawn</option>.
	  Как и параметр <option>twist</option>, параметр
	  <option>spawn</option> подразумевает запрет соединения
	  и может использоваться для запуска команд или скриптов.
	  В отличие от <option>twist</option>, <option>spawn</option> не
	  отправляет ответ вызывающей стороне.  Например, следующая
	  конфигурация:</para>

	<programlisting># We do not allow connections from example.com:
ALL : .example.com \
        : spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
          /var/log/connections.log) \
        : deny</programlisting>

	<para>отклонит все попытки соединения из домена
	  <hostid role="fqdn">*.example.com</hostid>; имя хоста,
	  <acronym>IP</acronym> адрес и даемон протоколируются в файл
	  <filename>/var/log/connections.log</filename>.</para>

	<para>Помимо приведенных выше символов подстановки, например
	  %a, существует еще несколько символов.  Обратитесь к странице
	  &man.hosts.access.5; справочной системы за полным списком.</para>
      </sect3>

      <sect3>
	<title>Параметры &ndash; шаблоны</title>

	<para>До этого момента в примерах использовался шаблон
	  <literal>ALL</literal>.  Существуют и другие параметры,
	  функциональность которых в дальнейшем может быть расширена.
	  <literal>ALL</literal> соответствует любому даемону,
	  домену или <acronym>IP</acronym> адресу.  Другой доступный
	  шаблон это <literal>PARANOID</literal>, который соответствует
	  хосту, <acronym>IP</acronym> адрес которого может быть
	  подделан.  Другими словами, <literal>paranoid</literal>
	  может быть использован для определения действия с хостами,
	  <acronym>IP</acronym> адрес которых не соответствует имени
	  хоста.  Вот пример применения этого параметра:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>В этом примере все запросы на подключения к
	  <command>sendmail</command> от хостов, <acronym>IP</acronym>
	  адрес которых не соответствует имени хоста, будут
	  отклонены.</para>

	<caution>
	  <para>Использование <literal>PARANOID</literal> невозможно,
	    если у клиента или сервера неправильно настроен
	    <acronym>DNS</acronym>.  В таких случаях необходимо
	    вмешательство администратора.</para>
	</caution>

	<para>Более подробная информация о шаблонах и их возможностях
	  дана на странице &man.hosts.access.5; справочной
	  системы.</para>

	<para>Для того, чтобы любая выбранная конфигурация заработала,
	  в <filename>hosts.allow</filename> необходимо закомментировать
	  первую строку настройки.  В начале раздела об этом не
	  упоминалось.</para>
      </sect3>
    </sect2>
  </sect1>

<!--
  Разделы по Kerberos переведены не вполне корректно в связи с использованием
  следующих терминов: principal, ticket, realm, credentials.
  Возможно, требуется существенная переработка перевода.
-->

  <sect1 id="kerberosIV">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Dapoz</surname>
	  <contrib>Оригинальный текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>KerberosIV</application></title>

    <para>Kerberos это сетевая дополнительная система/протокол, которая
      делает возможной аутентификацию пользователей через сервисы на защищенном
      сервере.  Такие сервисы, как удаленный вход, удаленное копирование,
      защищенное копирование файлов между системами и другие задачи с
      высоким риском становятся допустимо безопасными и более
      контролируемыми.</para>

    <para>Последующие инструкции могут использоваться в качестве руководства
      по настройке поставляемого с &os; Kerberos.  Тем не менее, вам
      могут потребоваться страницы справочника полного дистрибутива.</para>

    <sect2>
      <title>Установка <application>KerberosIV</application></title>

      <indexterm><primary>MIT</primary></indexterm>

      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>установка</secondary>
      </indexterm>

      <para>Kerberos это опциональный компонент &os;.  Простейший способ
	установки этой программы это выбор <literal>krb4</literal> или
	<literal>krb5</literal> из <application>sysinstall</application>
	во время первой установки &os;.  Будет установлен
	<quote>eBones</quote> (KerberosIV) или <quote>Heimdal</quote>
	(Kerberos5) вариант Kerberos.  Включение этих реализаций объясняется
	тем, что они разработаны вне США/Канады и доступны вне этих стран,
	поскольку на них не влияют ограничения на экспорт криптографического
	кода из США.</para>

      <para>Кроме того, реализация MIT Kerberos доступна из Коллекции Портов
	в виде пакета
	<filename role="package">security/krb5</filename>.</para>
    </sect2>

    <sect2>
      <title>Создание базы данных</title>

      <para>Это необходимо сделать только на сервере Kerberos.  Во-первых,
	убедитесь что не осталось старой базы данных Kerberos.  Войдите
	в каталог <filename>/etc/kerberosIV</filename> и убедитесь, что в нем
	находятся только эти файлы:</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README	        krb.conf        krb.realms</screen>

      <para>Если присутствуют еще какие-то файлы (такие как
	<filename>principal.*</filename> или <filename>master_key</filename>),
	используйте команду <command>kdb_destroy</command> для удаления старой
	базы данных Kerberos, или, если Kerberos не запущен, просто удалите
	эти файлы.</para>

      <para>Затем отредактируйте файлы <filename>krb.conf</filename> и
	<filename>krb.realms</filename>, введя ваши данные.  В этом примере
	уникальный идентификатор <literal>EXAMPLE.COM</literal>, сервер
	<hostid role="fqdn">grunt.example.com</hostid>.  Отредактируем или
	создадим файл <filename>krb.conf</filename>:</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>В этом примере другие идентификаторы введены для иллюстрации
	настройки c несколькими хостами.  С целью упрощения
	настройки вы можете не включать их.</para>

      <para>Первая строка содержит идентификатор, под которым работает эта
	система.  Остальные строки связывают идентификаторы с именами хостов.
	Сначала указывается идентификатор, затем хост под этим
	идентификатором, работающий как <quote>центр распространения
	ключей</quote>.  Слова <literal>admin server</literal> с последующим
	именем хоста означают, что этот хост также является сервером
	администрирования базы данных.  За дальнейшей информацией об этих
	терминах обратитесь к страницам справочника по Kerberos.</para>

      <para>Мы добавили <hostid role="fqdn">grunt.example.com</hostid>
	к идентификатору <literal>EXAMPLE.COM</literal> и кроме того
	сопоставили всем хостам в домене
	<hostid role="domainname">.example.com</hostid> идентификатор
	<literal>EXAMPLE.COM</literal>.  Файл
	<filename>krb.realms</filename> будет выглядеть так:</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>Как и в предыдущем примере, другие идентификаторы добавлены только
	для примера.  С целью упрощения настройки вы можете не включать
	их.</para>

      <para>В первой строке <emphasis>определенная</emphasis> система
	сопоставляется с идентификатором.  В остальных строках показано,
	сопоставить идентификатору остальные системы определенного
	поддомена.</para>

      <para>Теперь мы готовы к созданию базы данных.  Потребуется всего лишь
	запустить сервер Kerberos (или центр распространения ключей).
	Используйте для этого <command>kdb_init</command>:</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

<prompt>Введите главный ключ Kerberos:</prompt> </screen>

      <para>Теперь мы должны сохранить ключ, чтобы сервера на локальных
	компьютерах могли его взять.  Используйте для этого команду
	<command>kstash</command>:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!</screen>

      <para>Этой командой зашифрованный главный пароль сохранен в
	<filename>/etc/kerberosIV/master_key</filename>.</para>
    </sect2>

    <sect2>
      <title>Запуск Kerberos</title>

      <indexterm>
	<primary>KerberosIV</primary>

	<secondary>первый запуск</secondary>
      </indexterm>

      <para>Для каждой системы, защищаемой Kerberos, в базу данных должны
	быть добавлены две записи.  Это <literal>kpasswd</literal> и
	<literal>rcmd</literal>.  Они добавляются вместе с именем
	системы.</para>

      <para>Эти даемоны, <application>kpasswd</application> и
	<application>rcmd</application> позволяют другим системам изменять
	пароли Kerberos и запускать такие команды как &man.rcp.1;,
	&man.rlogin.1;, &man.rsh.1;.</para>

      <para>Теперь добавим эти записи:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt> &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>		&lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt>           &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>         &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Создание файла настройки сервера</title>

      <para>Теперь необходимо создать все записи сервисов, которые были
	определены для каждого компьютера.  Используем для этого команду
	<command>ext_srvtab</command>.  Будет создан файл, который должен
	быть скопирован или перемещен <emphasis>безопасным способом</emphasis>
	в каталог <filename>/etc/kerberosIV</filename> каждого Kerberos
	клиента.  Этот файл должен присутствовать на каждом сервере и
	клиенте, он необходим для работы Kerberos.</para>

      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>
<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>Эта команда создаст временный файл, который должен быть
	переименован в <filename>srvtab</filename>, чтобы серверы смогли
	обратиться к нему.  Используйте команду &man.mv.1; для перемещения
	его в исходной системе:</para>

      <screen>&prompt.root; <userinput>mv grunt-new-srvtab srvtab</userinput></screen>

      <para>Если файл предназначен для клиентской системы, и сеть не
	безопасна, скопируйте
	<filename><replaceable>client</replaceable>-new-srvtab</filename>
	на съемный носитель и перенесите файл с его помощью.  Убедитесь, что
	переименовали его в <filename>srvtab</filename> в каталоге
	<filename>/etc/kerberosIV</filename> клиента, и что режим доступа к
	нему 600:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>Пополнение базы данных</title>

      <para>Теперь необходимо добавить в базу данных пользователей.
	Во-первых, создадим запись для пользователя <username>jane</username>.
	Используйте команду <command>kdb_edit</command>:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                &lt;---- enter a secure password here
Verifying password

<prompt>New Password:</prompt>                &lt;---- re-enter the password here
Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		   &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Тестирование всей системы</title>

      <para>Во-первых, запустите даемоны Kerberos.  При правильном
	редактировании файла <filename>/etc/rc.conf</filename> они запустятся
	автоматически при перезагрузке.  Это необходимо только на сервере
	Kerberos.  Клиенты Kerberos получат все необходимые данные из
	каталога <filename>/etc/kerberosIV</filename>.</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>Теперь для получения доступа через созданного пользователя
	<username>jane</username> используйте <command>kinit</command>:</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para>Попробуйте просмотреть имеющиеся данные с помощью
	<command>klist</command>:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>

      <para>Теперь попробуйте изменить пароль с помощью &man.passwd.1;,
	чтобы убедиться, что даемон <application>kpasswd</application>
	может получить информацию из базы данных Kerberos:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title>Включение <command>su</command></title>

      <para>Kerberos позволяет назначить <emphasis>каждому</emphasis>
	пользователю, который нуждается в привилегиях
	<username>root</username>, свой <emphasis>собственный</emphasis>
	пароль &man.su.1;.  Необходимо добавить учётную запись, которой
	разрешено получать <username>root</username> доступ через &man.su.1;.
	Это делается путем связывания учётной записи <username>root</username>
	с пользовательской учётной записью.  Создадим в базе данных Kerberos
	запись <literal>jane.root</literal> с помощью
	<command>kdb_edit</command>:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter a SECURE password here
Verifying password

<prompt>New Password:</prompt>    	 	 &lt;---- re-enter the password here

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- Keep this short!
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		         &lt;---- null entry here will cause an exit</screen>

      <para>Теперь проверим работоспособность этой записи:</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password:</prompt></screen>

      <para>Необходимо добавить пользователя к <username>root</username>
	файлу <filename>.klogin</filename>:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Теперь попробуйте выполнить &man.su.1;:</para>

      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt></screen>

      <para>и посмотрите на имеющиеся данные:</para>

      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>Использование других команд</title>

      <para>В примере выше мы создали запись (principal)
	<literal>jane</literal> с доступом к <literal>root</literal>
	(instance).  Она основана на пользователе с таким же именем, как
	и идентификатор, что принято Kerberos по умолчанию;
	<literal>&lt;principal&gt;.&lt;instance&gt;</literal> в форме
	<literal>&lt;username&gt;.</literal><username>root</username>
	позволяет использовать &man.su.1; для доступа к
	<username>root</username>, если соответствующие записи находятся
	в файле <filename>.klogin</filename> домашнего каталога
	<username>root</username>:

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Подобно этому, если в файле <filename>.klogin</filename>
	из домашнего каталога пользователя есть строки в форме:</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>

      <para>это позволит любому с идентификатором
	<literal>EXAMPLE.COM</literal>, кто аутентифицировался как
	<username>jane</username> или <username>jack</username>
	(с помощью команды <command>kinit</command>, см. выше)
	получить доступ к учётной записи пользователя <username>jane</username>
	или файлам этой системы (<hostid>grunt</hostid>) через
	&man.rlogin.1;, &man.rsh.1; или &man.rcp.1;.</para>

      <para>Например, <username>jane</username> может входить в другую систему
	используя Kerberos:</para>

	    <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>Или <username>jack</username> входит в учётную запись
	<username>jane</username>'s на этом же компьютере
	(файл <filename>.klogin</filename> <username>jane</username>
	настроен как показано выше, и в Kerberos настроена учётная
	запись <emphasis>jack</emphasis>):</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="kerberos5">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tillman</firstname>
	  <surname>Hodgson</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Оригинальный материал предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>Kerberos5</application></title>

    <para>Все релизы &os; после &os;-5.1 включают поддержку только
      <application>Kerberos5</application>.  Таким образом,
      <application>Kerberos5</application> это единственная включаемая в
      поставку версия и его конфигурация похожа на
      <application>KerberosIV</application> во многих аспектах.  Эта
      информация применима только к <application>Kerberos5</application>
      из релизов после &os;-5.0.  Пользователи, желающие использовать
      пакет <application>KerberosIV</application>, могут установить его из
      порта <filename role="package">security/krb4</filename>.</para>

    <para><application>Kerberos</application> это дополнительная сетевая
      система/протокол, позволяющая пользователям авторизоваться через
      защищенные сервисы на защищенном сервере.  Такие сервисы как
      удаленный вход, удаленное копирование, защищенное копирование файлов
      между системами и другие задачи с высоким риском становятся
      допустимо безопасными и более контролируемыми.</para>

    <para><application>Kerberos</application> может быть описана как
      прокси система идентификации-проверки.  Она также может быть описана
      как защищенная внешняя система аутентификации.
      <application>Kerberos</application> предоставляет только одну функцию
      &mdash; защищенную аутентификацию пользователей сети.
      Он не предоставляет функций авторизации (что разрешено делать
      пользователям) или функций аудита (какой пользователь что делает).
      После того, как клиент и сервер использовали
      <application>Kerberos</application> для идентификации, они могут
      зашифровать все соединения для гарантирования собственной безопасности и
      целостности данных.<!--as they go about their business--></para>

    <para>Следовательно крайне рекомендуется использовать
      <application>Kerberos</application> с другими методами безопасности,
      предоставляющими сервисы авторизации и аудита.</para>

    <para>Последующие инструкции могут использоваться в качестве руководства
      по настройке <application>Kerberos</application>, поставляемого с &os;.
      Тем не менее, вам потребуется обратиться к соответствующим страницам
      справочника за полным описанием.</para>

    <para>В целях демонстрации установки <application>Kerberos</application>,
      будут применены следующие обозначения:</para>

    <itemizedlist>
      <listitem>
	<para><acronym>DNS</acronym> домен (<quote>зона</quote>)
	  example.org.</para>
      </listitem>

      <listitem>
	<para>Уникальный идентификатор <application>Kerberos</application>
	  EXAMPLE.ORG.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Используйте действующие имена доменов при настройке
	<application>Kerberos</application> даже если вы будете использовать
	его во внутренней сети.  Это позволит избежать проблем с
	<acronym>DNS</acronym> и гарантирует возможность связи с
	<application>Kerberos</application> под другими
	идентификаторами.</para>
    </note>

    <sect2>
      <title>История</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>история</secondary>
      </indexterm>

      <para><application>Kerberos</application> был создан
	<acronym>MIT</acronym> в качестве решения проблем с безопасностью
	сети.  Протокол <application>Kerberos</application> использует
	стойкую криптографию, так что клиент может идентифицироваться на
	сервере (и обратно) через незащищенное сетевое соединение.</para>

      <para><application>Kerberos</application> это и имя сетевого протокола
	аутентификации и общий термин для описания программ, где он
	реализован (например, <application>Kerberos</application> telnet).
	Текущая версия протокола 5 описана в
	<acronym>RFC</acronym>&nbsp;1510.</para>

      <para>Доступно несколько свободных реализаций этого протокола,
	работающих на множестве операционных систем.  Massachusetts
	Institute of Technology (<acronym>MIT</acronym>), где
	<application>Kerberos</application> был первоначально разработан,
	продолжает разрабатывать собственный пакет
	<application>Kerberos</application>.  Он обычно использовался
	в <acronym>США</acronym> как криптографический продукт,
	и в этом качестве попадал под действие ограничений на экспорт.
	<acronym>MIT</acronym> <application>Kerberos</application>
	доступен в виде порта (<filename
	role="package">security/krb5</filename>).  Heimdal
	<application>Kerberos</application> это другая реализация версии
	5, которая разрабатывалась исключительно вне <acronym>США</acronym>
	для обхода экспортных ограничений (и поэтому часто включалась в
	некоммерческие реализации &unix;).  Heimdal
	<application>Kerberos</application> доступен в виде порта
	(<filename role="package">security/heimdal</filename>),
	его минимальный комплект включен в базовую установку &os;.</para>

    <para>В целях получения наибольшей аудитории, в этих инструкциях
	предполагается использование Heimdal включаемого в &os;.</para>

    </sect2>

    <sect2>
      <title>Настройка Heimdal <acronym>KDC</acronym></title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>центр распространения ключей</secondary>
      </indexterm>

      <para>Центр распространения ключей (Key Distribution Center,
	<acronym>KDC</acronym>) это централизованный сервис аутентификации,
	предоставляемый <application>Kerberos</application> &mdash;
	это компьютер, который предоставляет доступ через
	<application>Kerberos</application>.  <acronym>KDC</acronym>
	считается доверяемым всеми другими компьютерами с определенным
	идентификатором <application>Kerberos</application> и поэтому
	к нему предъявляются высокие требования безопасности.</para>

    <para>Имейте ввиду, что хотя работа сервера
	<application>Kerberos</application> требует очень немного
	вычислительных ресурсов, из соображений безопасности для него
	рекомендуется отдельный компьютер, работающий только в качестве
	<acronym>KDC</acronym>.</para>

    <para>Перед началом настройки <acronym>KDC</acronym>, убедитесь что в
	файле <filename>/etc/rc.conf</filename> содержатся правильные
	настройки для работы в качестве <acronym>KDC</acronym> (вам может
	потребоваться изменить пути в соответствии с собственной
	системой):</para>

    <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Затем приступим к редактированию файла настройки
	<application>Kerberos</application>,
	<filename>/etc/krb5.conf</filename>:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Обратите внимание что в файле <filename>/etc/krb5.conf</filename>
	подразумевается наличие у <acronym>KDC</acronym> полного имени
	<hostid role="fqdn">kerberos.example.org</hostid>.  Вам потребуется
	добавить CNAME (синоним) к файлу зоны, если у
	<acronym>KDC</acronym> другое имя.</para>

      <note>
	<para>Для больших сетей с правильно настроенным сервером
	  <acronym>BIND</acronym> <acronym>DNS</acronym> пример выше
	  может быть урезан до:</para>

	<programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>Со следующими строками, добавленными в файл зоны
	  <hostid role="fqdn">example.org</hostid>:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</programlisting></note>

      <note>
	<para>Чтобы клиенты могли найти сервисы
	  <application>Kerberos</application>,
	  <emphasis>необходимо</emphasis> наличие или полностью
	  настроенного <filename>/etc/krb5.conf</filename> или минимально
	  настроенного <filename>/etc/krb5.conf</filename>
	  <emphasis>и</emphasis> правильно настроенного DNS
	сервера.</para>
      </note>

      <para>Создадим теперь базу данных <application>Kerberos</application>.
	Эта база данных содержит ключи всех основных хостов, зашифрованных
	с помощью главного пароля.  Вам не требуется помнить этот пароль,
	он хранится в файле (<filename>/var/heimdal/m-key</filename>).
	Для создания главного ключа запустите <command>kstash</command>
	и введите пароль.</para>

      <para>Как только будет создан главный ключ, вы можете инициализировать
	базу данных с помощью программы <command>kadmin</command> с ключом
	<literal>-l</literal> (означающим <quote>local</quote>).  Этот
	ключ сообщает <command>kadmin</command> обращаться к файлам базы
	данных непосредственно вместо использования сетевого сервиса
	<command>kadmind</command>.  Это помогает решить <quote>проблему
	курицы и яйца</quote>, когда обращение идет к еще не созданной базе
	данных.  Как только вы увидите приглашение <command>kadmin</command>,
	используйте команду <command>init</command> для создания базы
	данных идентификаторов.</para>

      <para>Наконец, оставаясь в приглашении <command>kadmin</command>,
	создайте первую запись с помощью команды <command>add</command>.
	Оставьте неизменными параметры по умолчанию, вы всегда сможете
	изменить их позже с помощью команды <command>modify</command>.
	Обратите внимание, что вы всегда можете использовать команду
	<literal>?</literal> для просмотра доступных параметров.</para>

      <para>Пример создания базы данных показан ниже:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin> <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin> <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Теперь пришло время запустить сервисы <acronym>KDC</acronym>.
	Выполните команды <command>/etc/rc.d/kerberos start</command> и
	<command>/etc/rc.d/kadmind start</command> для запуска сервисов.
	Заметьте, что ни один из поддерживающих
	<application>Kerberos</application>
	даемонов на этот момент запущен не будет, но у вас должна быть
	возможность убедиться в том, что <acronym>KDC</acronym> функционирует
	путем получения списка доступа для пользователя, которого вы только
	что самостоятельно создали из командной строки самого
	<acronym>KDC</acronym>:</para>

      <screen>&prompt.user; <userinput>k5init <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>k5list</userinput>
Credentials cache: FILE:<filename>/tmp/krb5cc_500</filename>
        Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

      </sect2>

      <sect2>
	<title>Сервер <application>Kerberos</application> с сервисами
	  Heimdal</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>включение сервисов</secondary>
	</indexterm>

	<para>Для начала нам потребуется копия файла настройки
	  <application>Kerberos</application>,
	  <filename>/etc/krb5.conf</filename>.
	  Просто скопируйте его с <acronym>KDC</acronym> на клиентский
	  компьютер безопасным способом (используя сетевые утилиты, такие
	  как &man.scp.1;, или физически, с помощью дискеты).</para>

	<para>Затем вам понадобится файл <filename>/etc/krb5.keytab</filename>.
	  Это основное различие между сервером, поддерживающим
	  <application>Kerberos</application> и рабочими станциями &mdash;
	  на сервере должен быть файл <filename>keytab</filename>.
	  В этом файле находится центральный ключ сервера, который позволяет
	  <acronym>KDC</acronym> проверять все другие идентификаторы.  Он
	  должен быть помещен на сервер безопасным способом, поскольку
	  безопасность сервера может быть нарушена, если ключ станет
	  общедоступен.  Это означает, что его передача через прозрачный
	  канал, такой как <acronym>FTP</acronym> &mdash; очень плохая
	  идея.</para>

	<para>Обычно перенос файла <filename>keytab</filename> на сервер
	  производится с помощью программы <command>kadmin</command>.
	  Это удобно, поскольку вам потребуется также создать запись хоста
	  (<acronym>KDC</acronym> часть <filename>krb5.keytab</filename>)
	  с помощью <command>kadmin</command>.</para>

	<para>Обратите внимание, что должны быть уже зарегистрированы в
	  системе и необходимо наличие прав на использование интерфейса
	  <command>kadmin</command> в файле <filename>kadmind.acl</filename>.
	  Обратитесь к разделу <quote>Remote administration</quote> в info
	  страницах Heimdal (<command>info heimdal</command>) за деталями по
	  составлению списка доступа.  Если вы не хотите включать удаленный
	  доступ <command>kadmin</command>, можете просто подключиться к
	  <acronym>KDC</acronym> через защищенное соединение (локальную
	  консоль, &man.ssh.1; или <application>Kerberos</application>
	  &man.telnet.1;) и выполнять администрирование локально с помощью
	  <command>kadmin -l</command>.</para>

	<para>После добавления файла <filename>/etc/krb5.conf</filename>,
	  вы можете использовать <command>kadmin</command> с сервера
	  <application>Kerberos</application>.  Команда
	  <command>add --random-key</command> позволит вам добавить запись
	  для сервера, а команда <command>ext</command> позволит перенести
	  эту запись в собственный keytab файл сервера. Например:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin><userinput> ext host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para>Обратите внимание, что команда <command>ext</command>
	  (сокращение от <quote>extract</quote>) сохраняет полученный ключ в
	  файле <filename>/etc/krb5.keytab</filename> по умолчанию.</para>

	<para>Если на <acronym>KDC</acronym> не запущен
	  <command>kadmind</command> (возможно по соображениям безопасности)
	  и вы не можете получить доступ к <command>kadmin</command>
	  удаленно, возможно добавление записи хоста
	  (<username>host/myserver.EXAMPLE.ORG</username>) непосредственно
	  на <acronym>KDC</acronym> с последующим извлечением ее во временный
	  файл (и перезаписью <filename>/etc/krb5.keytab</filename> на
	  <acronym>KDC</acronym>) примерно так:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para>Затем вы можете скопировать keytab на сервер защищенным способом
	  (например, используя <command>scp</command> или дискету).
	  Убедитесь, что используемое имя keytab не совпадает с именем
	  по умолчанию во избежание перезаписывания  keytab на
	  <acronym>KDC</acronym>.</para>

	<para>Теперь ваш сервер может связываться с <acronym>KDC</acronym>
	  (добавлен файл <filename>krb5.conf</filename>) и идентифицировать
	  себя (добавлен файл <filename>krb5.keytab</filename>).  Теперь вы
	  готовы к включению некоторых сервисов
	  <application>Kerberos</application>.  В этом примере мы включим
	  сервис <command>telnet</command>, поместив в
	  <filename>/etc/inetd.conf</filename> нижеприведенную строку и
	  перезапустив сервис &man.inetd.8; командой
	  <command>/etc/rc.d/inetd restart</command>:</para>

	<programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

	<para>Очень важно установить ключ <command>-a</command> (тип
	  аутентификации) в user.  Обратитесь к странице справочника
	  &man.telnetd.8; за подробной информацией.</para>

      </sect2>

      <sect2>
	<title>Клиент <application>Kerberos</application> с Heimdal</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>настройка клиентов</secondary>
	</indexterm>

	<para>Настройка клиентского компьютера почти тривиально проста.
	  Как только настройка <application>Kerberos</application> закончена,
	  вам потребуется только файл настройки
	  <application>Kerberos</application>,
	  <filename>/etc/krb5.conf</filename>.  Просто скопируйте его
	  безопасным способом на клиентский компьютер с
	  <acronym>KDC</acronym>.</para>

	<para>Протестируйте клиентский компьютер, попытавшись использовать
	  <command>kinit</command>, <command>klist</command>, и
	  <command>kdestroy</command> для получения, отображения и удаления
	  списка доступа.  Соединитесь с <application>Kerberos</application>
	  севером используя клиент <application>Kerberos</application>, если
	  соединение не работает и получение доступа является проблемой,
	  это скорее всего проблема сервера, а не клиента или
	  <acronym>KDC</acronym>.</para>

	<para>При тестировании приложения вроде <command>telnet</command>,
	  попробуйте использовать программу перехвата пакетов (такую
	  как &man.tcpdump.1;), чтобы убедиться, что ваш пароль не передается
	  незашифрованным.  Попробуйте использовать <command>telnet</command>
	  с параметром <literal>-x</literal>, чтобы зашифровать весь поток
	  данных (подобно <command>ssh</command>).</para>

	<para>Основные клиентские приложения
	  <application>Kerberos</application> (традиционно называющиеся
	  <command>kinit</command>, <command>klist</command>,
	  <command>kdestroy</command>, и
	  <command>kpasswd</command>) находятся в базовой установке &os;.
	  Обратите внимание, что в &os; версий до 5.0 они были переименованы
	  в <command>k5init</command>, <command>k5list</command>,
	  <command>k5destroy</command>, <command>k5passwd</command>, и
	  <command>k5stash</command> (хотя их обычно использовали лишь
	  однократно).</para>

	<para>Различные неосновные клиентские приложения
	  <application>Kerberos</application> также устанавливаются по
	  умолчанию.  Здесь проявляется <quote>минимальность</quote>
	  базовой установки Heimdal: <command>telnet</command> это
	  единственное приложение, поддерживающее
	  <application>Kerberos</application>.</para>

	<para>Порт Heimdal добавляет некоторые отсутствующие клиентские
	  приложения: поддерживающие
	  <application>Kerberos</application> версии
	  <command>ftp</command>, <command>rsh</command>,
	  <command>rcp</command>, <command>rlogin</command>, и некоторые
	  другие реже используемые программы.  Порт <acronym>MIT</acronym>
	  также содержит полный пакет клиентских приложений
	  <application>Kerberos</application>.</para>

      </sect2>

      <sect2>
	<title>Пользовательские файлы настройки: <filename>.k5login</filename>
	  и <filename>.k5users</filename></title>

	<indexterm>
	  <primary><filename>.k5login</filename></primary>
	</indexterm>

	<indexterm>
	  <primary><filename>.k5users</filename></primary>
	</indexterm>

	<para>Учётные записи пользователя в
	  <application>Kerberos</application> (например
	  <username>tillman@EXAMPLE.ORG</username>) обычно связаны с
	  локальными учётными записями (например с локальной учётной записью6
	  <username>tillman</username>).  Клиентские приложения, такие как
	  <command>telnet</command>, обычно не требуют указания имени
	  пользователя или учётной записи.</para>

	<para>Тем не менее, время от времени вам может потребоваться дать
	  доступ к локальной учётной записи кому-то, у кого нет
	  соответствующей учётной записи <application>Kerberos</application>.
	  Например, пользователю <username>tillman@EXAMPLE.ORG</username>
	  может потребоваться доступ к локальной учётной записи
	  <username>webdevelopers</username>.  Другим учётным записям
	  также может потребоваться доступ к этой локальной учётной
	  записи.</para>

	<para>Файлы <filename>.k5login</filename> и
	  <filename>.k5users</filename>, помещенные в домашний каталог
	  пользователя, могут быть использованы подобно действенной
	  комбинации <filename>.hosts</filename> и
	  <filename>.rhosts</filename> для решения этой проблемы.
	  Например, файл <filename>.k5login</filename>
	  со следующим содержанием:</para>

	<screen>tillman@example.org
jdoe@example.org</screen>

	<para>помещен в домашний каталог локального пользователя
	  <username>webdevelopers</username>, то обе упомянутые учётные
	  записи получат доступ к этой учётной записи без необходимости
	  наличия общего пароля.</para>

	<para>Рекомендуется прочитать страницу справочника по этим командам.
	  Обратите внимание, что страница справочника о
	  <command>ksu</command> содержит информацию по
	  <filename>.k5users</filename>.</para>

      </sect2>

      <sect2>
	<title>Подсказки, советы и решение проблем с
	  <application>Kerberos</application></title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>решение проблем</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>При использовании портов как Heimdal так и
	      <acronym>MIT</acronym> <application>Kerberos</application>
	      убедитесь, что в <envar>PATH</envar> версии
	      <application>Kerberos</application> клиентов указаны перед
	      их версиями в базовой системе.</para>
	  </listitem>

	  <listitem>
	    <para>Все ли компьютеры в пределах данного realm
	      синхронизированы по времени?  Если нет, аутентификация может
	      завершиться неудачно.  <xref linkend="network-ntp"> описывает
	      как синхронизировать часы с использованием
	      <acronym>NTP</acronym>.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym> и Heimdal успешно взаимодействуют.
	      За исключением <command>kadmin</command>, протокол для которого
	      не стандартизован.</para>
	  </listitem>

	  <listitem>
	    <para>Если вы изменяете hostname, потребуется также изменить
	      учётную запись <username>host/</username> и обновить keytab.
	      Это также необходимо для специальных записей в keytab, таких
	      как <username>www/</username> запись модуля Apache
	      <filename role="package">www/mod_auth_kerb</filename>.</para>
	  </listitem>

	  <listitem>
	    <para>Все хосты под общим идентификатором должны разрешаться
	      <acronym>DNS</acronym> (прямое и обратное разрешение), или
	      как минимум через <filename>/etc/hosts</filename>. Записи
	      CNAME будут работать, но записи A и PTR должны быть корректны
	      и находиться на своем месте.  Сообщение об ошибке не всегда
	      интуитивно понятно:
	      <errorname>Kerberos5 refuses authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	  </listitem>

	  <listitem>
	    <para>Некоторые операционные системы, способные работать в качестве
	      клиентов <acronym>KDC</acronym> не устанавливают права
	      для <command>ksu</command> в setuid <username>root</username>.
	      Это означает, что <command>ksu</command> не работает, что хорошо
	      является хорошей идеей для безопасности, но неудобно.  Это не
	      ошибка <acronym>KDC</acronym>.</para>
	  </listitem>

	  <listitem>
	    <para>С <acronym>MIT</acronym>
	      <application>Kerberos</application>, если вы хотите продлить
	      действие доступа до значения большего, чем десять часов по
	      умолчанию, используйте команду
	      <command>modify_principal</command> в
	      <command>kadmin</command> для изменения maxlife доступа к самой
	      учётной записи и к учётной записи <username>krbtgt</username>.
	      Затем возможно использование <command>kinit</command>
	      с параметром <literal>-l</literal> для запроса доступа с большим
	      временем действия.</para>
	  </listitem>

	  <listitem>
	    <note><para>Если вы запускаете перехватчик пакетов на
	      <acronym>KDC</acronym> для разрешения проблем, а затем
	      запускаете <command>kinit</command> с рабочей станции, то
	      увидите, что <acronym>TGT</acronym> посылается непосредственно
	      при запуске <command>kinit</command> &mdash; даже до того, как
	      вы введете пароль!  Объяснение в том, что сервер
	      <application>Kerberos</application> свободно распространяет
	      <acronym>TGT</acronym> (Ticket Granting Ticket) на каждый
	      неавторизованный запрос; однако, каждый <acronym>TGT</acronym>
	      зашифрован ключом, полученным из пароля пользователя.
	      Следовательно, когда пользователь вводит свой пароль, он не
	      отправляется на <acronym>KDC</acronym>, а используется для
	      расшифровка <acronym>TGT</acronym>, который уже получен
	      <command>kinit</command>.  Если в процессе расшифровки
	      получается правильный билет с правильным значением времени,
	      у пользователя есть действующее <quote>удостоверение</quote>.
	      Это удостоверение содержит ключ сессии для установления
	      безопасного соединения с сервером
	      <application>Kerberos</application>, как и действующий
	      <acronym>TGT</acronym>, зашифрованный ключом сервера
	      <application>Kerberos</application>.  Второй уровень шифрования
	      недоступен пользователю, но позволяет серверу
	      <application>Kerberos</application> проверять правильность
	      каждого <acronym>TGT</acronym>.</para></note>
	  </listitem>

	  <listitem>
	    <para>Если вы хотите установить большое время жизни доступа
	      (например, неделю), и используете
	      <application>OpenSSH</application> для соединения с компьютером,
	      где хранится <quote>билет</quote>, убедитесь, что параметр
	      <application>Kerberos</application>
	      <option>TicketCleanup</option> установлен в
	      <literal>no</literal> в файле <filename>sshd_config</filename>,
	      или билеты будут уничтожены при выходе из сеанса.</para>
	  </listitem>

	  <listitem>
	    <para>Запомните, что время жизни билетов хостов больше.
	      Если время жизни билета для учётной записи пользователя
	      составляет неделю, а время жизни учётной записи хоста, к
	      которому вы подсоединяетесь девять часов, учётная запись хоста
	      в кэше устареет и кэш билетов будет работать не так, как
	      ожидается.</para>
	  </listitem>

	  <listitem>
	    <para>При настройке файла <filename>krb5.dict</filename> на
	    предотвращение использования определенных плохих паролей
	    (страница справочника для <command>kadmind</command> кратко
	    рассказывает об этом), запомните, что это применимо только
	    к учётным записям, для которых действует политика паролей.
	    Формат файла <filename>krb5.dict</filename> прост: одно слово
	    на строку.  Может помочь создание символической ссылки на
	    <filename>/usr/share/dict/words</filename>.</para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>Отличия от порта <acronym>MIT</acronym></title>

	<para>Основное различие между установками <acronym>MIT</acronym> и
	  Heimdal относится к программе <command>kadmin</command>,
	  которая имеет другой (но эквивалентный) набор команд и
	  использует другой протокол.  Если ваш <acronym>KDC</acronym>
	  работает на <acronym>MIT</acronym>, вы не сможете использовать
	  <command>kadmin</command> для удаленного администрирования
	  <acronym>KDC</acronym> (и наоборот, по этой же причине).</para>

	<para>Опции командной строки клиентов также могут немного отличаться
	  для одинаковых задач.  Рекомендуется следование инструкциям
	  на <acronym>MIT</acronym> <application>Kerberos</application>
	  Web-сайте (<ulink url="http://web.mit.edu/Kerberos/www/"></ulink>).
	  Будьте внимательны при определении <envar>PATH</envar>:
	  порт <acronym>MIT</acronym> устанавливается по умолчанию в
	  <filename>/usr/local/</filename>, и если в <envar>PATH</envar>
	  вначале указаны системные каталоги, вместо приложений
	  <acronym>MIT</acronym> могут быть запущены системные
	  приложения.</para>

	<note><para>С портом <acronym>MIT</acronym>
	  <filename role="package">security/krb5</filename>, предоставляемым
	  &os;, убедитесь что файл
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>
	  установлен портом, если вы хотите понять почему вход через
	  <command>telnetd</command> и <command>klogind</command>
	  иногда происходит так странно.  Наиболее важно, исправление
	  <quote>incorrect permissions on cache file</quote> требует
	  использования бинарного файла <command>login.krb5</command>
	  для аутентификации, чтобы права на переданное удостоверение
	  передавались правильно.</para></note>

      </sect2>

      <sect2>
	<title>Преодоление ограничений, обнаруженных в
	  <application>Kerberos</application></title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>ограничения и недостатки</secondary>
	</indexterm>

	<sect3>
	 <title><application>Kerberos</application> это все или ничего</title>

	  <para>Каждый сервис, работающий в сети, должен быть модифицирован
	    для работы с <application>Kerberos</application> (или другим
	    способом защищен от атак по сети) или удостоверения пользователей
	    могут быть украдены или использованы повторно.  В качестве примера
	    может быть приведено использование
	    <application>Kerberos</application> версий
	    оболочек для удаленной работы (например через
	    <command>rsh</command> и <command>telnet</command>), при
	    наличии <acronym>POP3</acronym> сервера, получающего пароли в
	    незашифрованном виде.</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application> предназначен для
	    однопользовательских рабочих станций</title>

	  <para>В многопользовательской среде
	    <application>Kerberos</application> менее безопасен.
	    Это потому, что он хранит билеты в каталоге
	    <filename>/tmp</filename>, которая доступна для чтения всем.
	    Если пользователь работает с несколькими другими пользователями
	    одновременно на одном компьютере (т.е. в многопользовательской
	    среде), возможна кража (копирование) билета другим
	    пользователем.</para>

	  <para>Решить проблему можно с помощью параметра командной
	    строки <literal>-c</literal> или (предпочтительно) с помощью
	    переменной окружения <envar>KRB5CCNAME</envar>, но это делается
	    редко.  Для преодоления ограничения достаточно сохранять билет
	    в домашнем каталоге пользователя и использовать простые
	    ограничения на доступ к файлам.</para>

	</sect3>

	<sect3>
	  <title>От KDC зависит вся система</title>

	  <para>Архитектура системы такова, что <acronym>KDC</acronym> должен
	    быть максимально защищен, поскольку главный пароль базы данных
	    содержится в нем.  На <acronym>KDC</acronym> не должно быть
	    запущено никаких других сервисов и он должен быть защищен
	    физически.  Опасность велика, поскольку
	    <application>Kerberos</application> хранит все пароли
	    зашифрованными одним ключом (<quote>главным</quote> ключом),
	    который хранится в файле на <acronym>KDC</acronym>.</para>

	  <para>Хорошей новостью является то, что кража главного ключа
	    не станет такой проблемой, как может показаться.  Главный ключ
	    используется только для шифрования базы данных
	    <application>Kerberos</application> и в качестве seed для
	    генератора случайных чисел.  Поскольку доступ к
	    <acronym>KDC</acronym> защищен, атакующий мало что сможет сделать
	    с главным ключом.</para>

	  <para>Кроме того, если <acronym>KDC</acronym> станет недоступен
	    (возможно по причине атак DoS или проблем в сети) сетевые сервисы
	    будет невозможно использовать, поскольку аутентификация не
	    может быть выполнена.<!-- recipe for a denial-of-service attack-->
	    Уменьшить последствия можно при наличии нескольких
	    <acronym>KDC</acronym> (один главный и один или несколько
	    резервных) и с аккуратно реализованной резервной аутентификацией
	    (отлично подойдет <acronym>PAM</acronym>).</para>

	</sect3>

	<sect3>
	  <title>Недостатки <application>Kerberos</application></title>

	  <para><application>Kerberos</application> позволяет пользователям,
	    хостам и сервисам производить аутентификацию друг друга.
	    В нем нет механизма аутентификации <acronym>KDC</acronym>
	    для пользователей, хостов или сервисов.  Это означает, что
	    поддельный <command>kinit</command> (например) может записывать
	    все имена пользователей и паролей.  Помочь решить проблему может
	    <filename role="package">security/tripwire</filename> или
	    другой инструмент проверки целостности файловой системы.</para>

	</sect3>
      </sect2>

      <sect2>
	<title>Ресурсы и информация для дальнейшего изучения</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>внешние ресурсы</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	  <para><ulink
	    url="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	    <application>Kerberos</application> FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://web.mit.edu/Kerberos/www/dialogue.html">Разработка
	    системы аутентификации: диалог в четырех сценах</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    <application>Kerberos</application> Network Authentication Service
	    (V5)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://web.mit.edu/Kerberos/www/">Домашняя страница
	    <acronym>MIT</acronym>
	    <application>Kerberos</application></ulink></para>
	</listitem>

	<listitem>
	<para><ulink
	  url="http://www.pdc.kth.se/heimdal/">Домашняя страница
	  Heimdal <application>Kerberos</application></ulink></para>
	</listitem>

	</itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Написал: </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>OpenSSL</title>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>

    <para>Одной из программ, требующих особого внимания пользователей,
      является набор программ <application>OpenSSL</application>,
      включенный в &os;.  <application>OpenSSL</application> предоставляет
      уровень шифрования поверх обычных уровней соединения; следовательно,
      он может быть использован многими сетевыми приложениями и
      сервисами.</para>

    <para><application>OpenSSL</application> может использоваться для
      шифрования соединений почтовых клиентов, транзакций через интернет,
      например для кредитных карт, и многого другого.  Многие порты,
      такие как <filename role="package">www/apache13-ssl</filename> и
      <filename role="package">mail/sylpheed-claws</filename> собираются
      с <application>OpenSSL</application>.</para>

    <note>
      <para>В большинстве случаев в Коллекции Портов будет сделана попытка
	построения порта <filename role="package">security/openssl</filename>,
	если только переменная <makevar>WITH_OPENSSL_BASE</makevar>
	не установлена явно в <quote>yes</quote>.</para>
    </note>

    <para>Версия <application>OpenSSL</application>, включаемая
      в &os;, поддерживает сетевые протоколы безопасности
      Secure Sockets Layer v2/v3 (SSLv2/SSLv3),
      Transport Layer Security v1 (TLSv1) и может быть использована
      в качестве основной криптографической библиотеки.</para>

    <note>
      <para>Хотя <application>OpenSSL</application> поддерживает алгоритм
	<acronym>IDEA</acronym>, по умолчанию он отключен из-за патентных
	ограничений Соединенных Штатов.  Для его использования необходимо
	ознакомиться с лицензией, и, если ограничения приемлемы,
	установить в <filename>make.conf</filename> переменную
	<makevar>MAKE_IDEA</makevar>.</para>
    </note>

    <para>Наиболее часто <application>OpenSSL</application>
      используется для создания сертификатов, используемых программными
      пакетами.  Эти сертификаты подтверждают, что данные компании
      или частного лица верны и не подделаны.  Если рассматриваемый
      сертификат не был проверен одним из нескольких сертификационных центров
      (<quote>Certificate Authorities</quote> - <acronym>CA</acronym>), обычно
      выводится предупреждение.  Центр сертификации представляет собой
      компанию, такую, как <ulink url="http://www.verisign.com">
      VeriSign</ulink>, которая подписывает сертификаты для подтверждения
      данных частных лиц или компаний.  Эта процедура не бесплатна
      и не является абсолютно необходимой для использования сертификатов;
      однако может успокоить некоторых особо осторожных
      пользователей.</para>

    <sect2>
      <title>Генерирование сертификатов</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>генерирование сертификатов</secondary>
      </indexterm>

      <para>Для генерирования сертификатов доступна следующая
	команда:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput><replaceable>SOME PASSWORD</replaceable></userinput>
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para>Ввод после приглашения <quote>Common Name</quote>
	содержит имя домена.  Здесь вводится имя сервера для
	верификации; помещение в это поле чего-либо кроме
	этого имени приведет к созданию бесполезного сертификата.
	Доступны и другие параметры, например срок действия,
	альтернативные алгоритмы шифрования и т.д.  Полный список
	находится на странице справочного руководства
	&man.openssl.1;.</para>

      <para>В текущем каталоге, из которого была вызвана вышеуказанная
	команда, должны появиться два файла.  Файл
	<filename>req.pem</filename> с запросом на сертификацию может быть
	послан в центр выдачи сертификатов, который проверит введённые вами
	подтверждающие данные, подпишет запрос и возвратит сертификат вам.
	Второй созданный файл будет иметь название
	<filename>cert.pem</filename> и содержать приватный сертификационный
	ключ, который необходимо тщательно защищать; если он попадёт в руки
	посторонних лиц, то может быть использован для имитации лично вас (или
	вашего сервера).</para>

      <para>Когда подпись <acronym>CA</acronym> не требуется, может
	быть создан самоподписанный сертификат.  Сначала создайте ключ
	<acronym>RSA</acronym>:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out <filename>myRSA.key</filename> 1024</userinput></screen>

      <para>Теперь создайте ключ <acronym>CA</acronym>:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out <filename>myca.key</filename> <filename>myRSA.key</filename></userinput></screen>

      <para>Используйте этот ключ при создании сертификата:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key <filename>myca.key</filename> -out <filename>new.crt</filename></userinput></screen>

      <para>В каталоге должно появиться два новых файла: подпись сертификата,
	<filename>myca.key</filename> и сам сертификат,
	<filename>new.crt</filename>.  Они должны быть помещены в каталог,
	доступный для чтения только <username>root</username>,
	желательно внутри <filename class="directory">/etc</filename>.
	Права на каталог можно изменить <command>chmod</command> с параметрами
	0700.</para>
    </sect2>

    <sect2>
      <title>Использование сертификатов, пример</title>

      <para>Итак, что могут сделать эти файлы?  Хорошим применением
	может стать шифрование соединений для
	<application>Sendmail</application> <acronym>MTA</acronym>.
	Это сделает ненужным использование простой текстовой
	аутентификации для тех, кто отправляет почту через
	локальный <acronym>MTA</acronym>.</para>

      <note>
	<para>Это не лучшее из возможных использований, поскольку
	  некоторые <acronym>MUA</acronym> выдадут ошибку, если
	  сертификат не установлен локально.  Обратитесь к
	  поставляемой с программой документации за информацией по
	  установке сертификата.</para>
      </note>

      <para>Следующие строки должны быть помещены в локальный файл
	<filename>.mc</filename>:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Где <filename class="directory">/etc/certs/</filename>
	это каталог для локального хранения сертификата и
	ключей.  После настройки необходимо собрать локальный
	файл <filename>.cf</filename>.  Это легко сделать,
	набрав <command>make</command> <parameter>install</parameter>
	в каталоге <filename class="directory">/etc/mail</filename>.
	Затем выполните команду <command>make</command>
	<parameter>restart</parameter>, которая должна запустить
	даемон <application>Sendmail</application>.</para>

      <para>Если все пройдет нормально, в файле
	<filename>/var/log/maillog</filename> не появятся сообщения
	об ошибках и запустится процесс
	<application>Sendmail</application>.</para>

      <para>Для проведения простого теста подключитесь к почтовому серверу
	программой &man.telnet.1;:</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to <hostid role="fqdn">example.com</hostid>.
Escape character is '^]'.
220 <hostid role="fqdn">example.com</hostid> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <hostid role="fqdn">example.com</hostid> closing connection
Connection closed by foreign host.</screen>

      <para>Если в выводе появилась строка <quote>STARTTLS</quote>,
	все работает правильно.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
	<author>
  	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
	  </affiliation>
	  <contrib>Написал </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>IPsec</primary>
    </indexterm>

    <title>VPN через IPsec</title>

    <para>Создание VPN между двумя сетями, соединенными через интернет,
      с использованием шлюзов FreeBSD.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Hiten M.</firstname>
	    <surname>Pandya</surname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Написал </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Принципы работы IPsec</title>

      <para>Этот раздел послужит вам руководством по настройке IPsec и его
	использованию в среде FreeBSD и <application>&microsoft.windows;
	2000/XP</application>, соединяемых безопасным способом.
	Для настройки IPsec необходимо ознакомиться с процессом
	сборки ядра (<xref linkend="kernelconfig">).</para>

      <para><emphasis>IPsec</emphasis> это протокол, расположенный поверх
	слоя Internet Protocol (IP).  Он позволяет двум или более хостам
	связываться защищенным способом (отсюда и название протокола).
	<quote>Сетевой стек</quote> FreeBSD IPsec основан на
	реализации <ulink url="http://www.kame.net/">KAME</ulink>,
	поддерживающей оба семейства протоколов, IPv4 и IPv6.</para>

      <note>
	<para>FreeBSD содержит <quote>аппаратно
	  поддерживаемый</quote> стек IPsec, известный как <quote>Fast
	  IPsec</quote>, заимствованный из OpenBSD.  Для оптимизации
	  производительности IPsec он задействует криптографическое
	  оборудование (когда оно доступно) через подсистему &man.crypto.4;.
	  Это новая подсистема и она не поддерживает всех возможностей,
	  доступных в KAME версии IPsec.  Для включения IPsec с аппаратной
	  поддержкой необходимо добавить в файл настройки ядра следующий
	  параметр:</para>

	<indexterm>
	  <primary>параметры ядра</primary>

	  <secondary>FAST_IPSEC</secondary>
	</indexterm>

	<screen>options	  FAST_IPSEC  # new IPsec (cannot define w/ IPSEC)</screen>

	<para>Обратите внимание, что на данный момент невозможно
	  использовать подсистему <quote>Fast IPsec</quote> вместе
	  с KAME реализацией IPsec.  Обратитесь к странице справочника
	  &man.fast.ipsec.4; за дальнейшей информацией.</para>
      </note>

      <note>
	<para>Для того, чтобы применять к туннелям &man.gif.4;
	  межсетевые экраны, вам потребуется включить в ядро опцию
	  <option>IPSEC_FILTERGIF</option>:</para>

	<screen>
options   IPSEC_FILTERGIF  #filter ipsec packets from a tunnel
	</screen>
       </note>
   
      <indexterm>
	<primary>IPsec</primary>

	<secondary>ESP</secondary>
      </indexterm>

      <indexterm>
	<primary>IPsec</primary>

	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec состоит из двух подпротоколов:</para>

      <itemizedlist>
	<listitem>
	  <para><emphasis>Encapsulated Security Payload
	    (ESP)</emphasis>, защищающей данные IP пакета от вмешательства
	    третьей стороны путем шифрования содержимого с помощью
	    симметричных криптографических алгоритмов (таких как
	    Blowfish,3DES).</para>
	</listitem>
	<listitem>
	  <para><emphasis>Authentication Header (AH)</emphasis>,
	    защищающий заголовок IP пакета от вмешательства третьей стороны
	    и подделки путем вычисления криптографической контрольной суммы
	    и хеширования полей заголовка IP пакета защищенной функцией
	    хеширования.  К пакету добавляется дополнительный заголовок
	    с хэшем, позволяющий аутентификацию информации пакета.</para>
	</listitem>
      </itemizedlist>

      <para><acronym>ESP</acronym> и <acronym>AH</acronym> могут быть
	использованы вместе или по отдельности, в зависимости от
	обстоятельств.</para>

      <indexterm>
	<primary>VPN</primary>
      </indexterm>

      <indexterm>
	<primary>виртуальная частная сеть</primary>

	<see>VPN</see>
      </indexterm>

      <para>IPsec может быть использован или для непосредственного шифрования
	трафика между двумя хостами (<emphasis>транспортный
	режим</emphasis>); или для построения <quote>виртуальных
	туннелей</quote> между двумя подсетями, которые могут быть
	использованы для защиты соединений между двумя корпоративными
	сетями (<emphasis>туннельный режим</emphasis>).  Последний обычно
	называют <emphasis>виртуальной частной сетью</emphasis>
	(Virtual Private Network, VPN).  За детальной информацией о
	подсистеме IPsec в FreeBSD обратитесь к странице справочника
	&man.ipsec.4;.</para>

      <para>Для включения поддержки IPsec в ядре, добавьте следующие
	параметры к файлу настройки ядра:</para>

      <indexterm>
	<primary>параметры ядра</primary>

	<secondary>IPSEC</secondary>
      </indexterm>

      <indexterm>
	<primary>параметры ядра</primary>

	<secondary>IPSEC_ESP</secondary>
      </indexterm>

      <screen>options   IPSEC        #IP security
options   IPSEC_ESP    #IP security (crypto; define w/ IPSEC)</screen>

      <indexterm>
	<primary>параметры ядра</primary>

	<secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>Если желательна поддержка отладки IPsec, должна быть также
	добавлена следующая строка:</para>

      <screen>
options   IPSEC_DEBUG  #debug for IP security
      </screen>
    </sect2>

    <sect2>
      <title>Проблема</title>

      <para>Не существует стандарта VPN.  Они могут быть реализованы
	множеством различных технологий, каждая из которых имеет свои
	сильные и слабые стороны.  Этот раздел представляет
	сценарий и стратегию реализации VPN для этого сценария.</para>
    </sect2>

    <sect2>
      <title>Сценарий: Две сети, подключенных к интернет, работающие как
	одна</title>

      <indexterm>
	<primary>VPN</primary>

	<secondary>создание</secondary>
      </indexterm>

      <para>Исходные условия таковы:</para>

      <itemizedlist>
	<listitem>
	  <para>Существует как минимум две сети</para>
	</listitem>
	<listitem>
	  <para>Внутри обеих сетей используется IP</para>
	</listitem>
	<listitem>
	  <para>Обе сети соединены через интернет через шлюз,
	    работающий на FreeBSD.</para>
	</listitem>
	<listitem>
	  <para>У шлюза каждой из сетей есть как минимум один публичный
	    IP адрес.</para>
	</listitem>
	<listitem>
	  <para>Внутренние IP адреса двух сетей могут быть публичными или
	    приватными, не имеет значения.  На шлюзе может работать
	    NAT, если это необходимо.</para>
	</listitem>
	<listitem>
	  <para>Внутренние IP адреса двух сетей <emphasis>не должны
	    пересекаться</emphasis>.  Хотя вероятно теоретически возможно
	    использование комбинации VPN технологии и NAT для настройки
	    такой конфигурации, эта конфигурация будет кошмарна.</para>
	</listitem>
      </itemizedlist>

      <para>Если две сети, которые вы пытаетесь соединить, используют один
	и тот же диапазон приватных адресов (например, обе используют
	<hostid role="ipaddr">192.168.1.x</hostid>), номера в одной из
	сетей необходимо изменить.</para>

      <para>Топология сети может выглядеть примерно так:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="security/ipsec-network" align="center">
	</imageobject>

	<textobject>
<literallayout class="monospaced">Сеть #1               [ Внутренние хосты ]    Приватная сеть, 192.168.1.2-254
	              [    Win9x/NT/2K   ]
	              [       UNIX       ]
	                       |
	                       |
	                .---[fxp1]---.        Приватный IP, 192.168.1.1
	                |   FreeBSD  |
	                `---[fxp0]---'        Публичный IP, A.B.C.D
	                       |
	                       |
	              -=-=- Интернет -=-=-
	                       |
	                       |
	                .---[fxp0]---.        Публичный IP, W.X.Y.Z
	                |   FreeBSD  |
	                `---[fxp1]---'        Приватный IP, 192.168.2.1
	                       |
	                       |
Сеть #2               [ Внутренние хосты ]
	              [    Win9x/NT/2K   ]    Приватная сеть, 192.168.2.2-254
	              [       UNIX       ]</literallayout>
	</textobject>
      </mediaobject>

      <para>Заметьте, что здесь присутствуют два публичных IP-адреса.  В
	дальнейшем для их обозначения
	будут использоваться буквы.  Если вы увидите эти буквы, замените
	их на свои публичные IP адреса.  Также обратите внимание, что
	у обеих шлюзов внутренний адрес заканчивается на .1 и диапазоны
	приватных адресов двух сетей различны (<hostid
	role="ipaddr">192.168.1.x</hostid> и <hostid
	role="ipaddr">192.168.2.x</hostid> соответственно).  Все компьютеры
	локальных сетей настроены на использование в качестве шлюза по
	умолчанию компьютера с адресом, оканчивающимся на
	<hostid role="ipaddr">.1</hostid>.</para>

      <para>С сетевой точки зрения замысел в том, чтобы каждая сеть
	видела компьютеры из другой сети так, как если бы они были
	непосредственно подключены к тому же самому маршрутизатору &mdash;
	хотя и немного медленному маршрутизатору, иногда теряющему
	пакеты.</para>

      <para>Это означает, что (например) компьютер <hostid
	role="ipaddr">192.168.1.20</hostid> может запустить</para>

      <programlisting>ping 192.168.2.34</programlisting>

      <para>и это будет прозрачно работать.  Компьютеры с &windows;
	должны видеть компьютеры в другой сети, просматривать сетевые
	ресурсы, и так далее, точно так же, как и для компьютеров в
	локальной сети.</para>

      <para>И все это безопасным способом.  Это означает, что трафик
	между сетями зашифрован.</para>

      <para>Создание VPN между этими двумя сетями это многошаговый
	процесс.  Этапы создания VPN таковы:</para>

      <orderedlist>
	<listitem>
	  <para>Создание <quote>виртуального</quote> сетевого подключения
	    между двумя сетями через интернет.  Тестирование подключения с
	    помощью таких инструментов как &man.ping.8;, чтобы убедиться, что
	    оно работает.</para>
	</listitem>

	<listitem>
	  <para>Применение политики безопасности чтобы убедиться, что трафик
	    между двумя сетями прозрачно шифруется и расшифровывается если
	    необходимо.  Тестирование с помощью таких инструментов как
	    &man.tcpdump.1;, чтобы убедиться, что трафик шифруется.</para>
	</listitem>

	<listitem>
	  <para>Настройка дополнительных программ на шлюзах &os;,
	    чтобы компьютеры &windows; из одной сети видели компьютеры
	    в другой через VPN.</para>
	</listitem>
      </orderedlist>

    <sect3>
      <title>Шаг 1: Создание и тестирование <quote>виртуального</quote>
	сетевого подключения</title>

      <para>Предположим, что вы работаете на шлюзе сети #1 (с публичным
	адресом <hostid role="ipaddr">A.B.C.D</hostid>, приватным
	адресом <hostid role="ipaddr">192.168.1.1</hostid>) и запускаете
	<command>ping 192.168.2.1</command>, т.е. на приватный адрес
	машины с IP адресом <hostid role="ipaddr">W.X.Y.Z</hostid>.
	Что должно произойти, чтобы это сработало?</para>

      <orderedlist>
	<listitem>
	  <para>Шлюз должен знать, как достичь <hostid
	    role="ipaddr">192.168.2.1</hostid>.  Другими словами, у него
	    должен быть маршрут к <hostid
	    role="ipaddr">192.168.2.1</hostid>.</para>
	</listitem>
	<listitem>
	  <para>Приватные IP адреса, такие как диапазон <hostid
	    role="ipaddr">192.168.x</hostid> не адресуются в
	    интернет.  Каждый пакет, отправляемый на
	    <hostid role="ipaddr">192.168.2.1</hostid> должен быть
	    <quote>завернут</quote> в другой пакет.  Исходным адресом пакета
	    должен быть <hostid role="ipaddr">A.B.C.D</hostid>,
	    а адресом назначения <hostid role="ipaddr">W.X.Y.Z</hostid>.
	    Этот процесс называется
	    <firstterm>инкапсуляцией</firstterm>.</para>
	</listitem>
	<listitem>
	  <para>Как только этот пакет достигнет <hostid
	    role="ipaddr">W.X.Y.Z</hostid>, необходимо будет
	    <quote>декапсулировать</quote> его и доставить к <hostid
	    role="ipaddr">192.168.2.1</hostid>.</para>
	</listitem>
      </orderedlist>

      <para>Как вы можете увидеть, это требует <quote>туннеля</quote>
	между двумя сетями.  Два конца <quote>туннеля</quote>
	это IP адреса <hostid role="ipaddr">A.B.C.D</hostid> и
	<hostid role="ipaddr">W.X.Y.Z</hostid>.  Туннель используется для
	передачи трафика с приватными IP адресами через интернет.</para>

      <para>В FreeBSD этот туннель создается с помощью устройства generic
	interface, или <devicename>gif</devicename>.  Как вы можете
	догадаться, интерфейс <devicename>gif</devicename> на каждом хосте
	должен быть настроен с четырьмя IP адресами; два для публичных
	IP адресов и два для приватных IP адресов.</para>

      <para>В ядро обеих компьютеров FreeBSD должна быть встроена
	поддержка устройства gif.  Вы можете сделать это, добавив
	строку:</para>

      <programlisting>device gif</programlisting>

      <para>к файлу настройки ядра на обеих компьютерах, с последующей
	компиляцией, установкой и перезагрузкой.</para>

      <para>Настройка туннеля это двухшаговый процесс.  Во-первых,
	необходимо задать сведения о внешнем (или публичном) IP адресе
	с помощью &man.ifconfig.8;.  Затем о приватном IP адресе, также
	с помощью &man.ifconfig.8;.</para>

      <para>На шлюзе сети #1 для настройки туннеля вам потребуется запустить
	следующие две команды.</para>

      <programlisting>ifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff
      </programlisting>

      <para>На другом шлюзе подобные команды, но с IP адресами в обратном
	порядке.</para>

      <programlisting>ifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff
      </programlisting>

      <para>Затем вы можете запустить:</para>

      <programlisting>ifconfig gif0</programlisting>

      <para>для просмотра настройки.  Например, на шлюзе сети #1
	вы увидите:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 --&gt; 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D --&gt; W.X.Y.Z
      </screen>

      <para>Как вы можете видеть, был создан туннель между физическими
	адресами <hostid role="ipaddr">A.B.C.D</hostid> и
	<hostid role="ipaddr">W.X.Y.Z</hostid>, для туннелирования разрешен
	трафик между <hostid
	role="ipaddr">192.168.1.1</hostid> и <hostid
	role="ipaddr">192.168.2.1</hostid>.</para>

      <para>Это также добавляет запись к таблице маршрутизации на обеих
	машинах, вы можете проверить запись командой <command>netstat
	-rn</command>.  Вот вывод этой команды на шлюзе сети #1.</para>

      <screen>&prompt.root; <userinput>netstat -rn</userinput>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...
      </screen>

      <para>Как показывает значение поля <quote>Flags</quote>, это маршрут
	к хосту, что означает, что каждый шлюз знает, как достичь другого
	шлюза, но не знает как достичь остальной части соответствующей сети.
	Эта проблема будет быстро решена.</para>

      <para>Вероятно, на обеих машинах запущен брандмауэр.  VPN
	должен обходить его.  Вы можете разрешить весь трафик между
	двумя сетями, или включить правила, защищающие каждый конец
	соединения от другого.</para>

      <para>Это сильно упрощает тестирование настройки брандмауэра,
	если вы разрешаете весь трафик через VPN.  Вы всегда можете
	Вы всегда можете усилить защиту позже.  Если вы используете
	на шлюзах &man.ipfw.8;, команда вроде этой</para>

      <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>

      <para>разрешит весь трафик между двумя концами VPN без влияния на
	другие правила брандмауэра.  Очевидно, вам потребуется
	запустить эту команду на обеих шлюзах.</para>

      <para>Этого достаточно для включения ping с одного шлюза на другой.
	На <hostid role="ipaddr">192.168.1.1</hostid>, вы сможете
	запустить</para>

      <programlisting>ping 192.168.2.1</programlisting>

      <para>и получить ответ, и аналогично на другом шлюзе.</para>

      <para>Однако, машины в другой сети пока недоступны.  Это из-за
	маршрутизации &mdash; хотя шлюзы знают, как связаться друг с
	другом, они не знают, как связаться с сетью за другим шлюзом.</para>

      <para>Для решения этой проблемы вы должны добавить статический маршрут
	на каждом шлюзе.  Команда на первом шлюзе будет выглядеть так:</para>

      <programlisting>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00
      </programlisting>

      <para>Она говорит <quote>Для достижения хостов в сети
	<hostid role="ipaddr">192.168.2.0</hostid>, отправляйте пакеты
	хосту <hostid role="ipaddr">192.168.2.1</hostid></quote>.  Вам
	потребуется запустить похожую команду на другом шлюзе, но с
	адресами <hostid role="ipaddr">192.168.1.x</hostid>.</para>

      <para>IP трафик с хостов в одной сети теперь может достичь хосты в
	другой сети.</para>

      <para>Теперь создано две трети VPN между двумя сетями, поскольку
	это <quote>виртуальная (virtual)</quote> <quote>сеть (network)</quote>.
	Она еще не приватная (private).  Вы можете протестировать ее
	с помощью &man.ping.8; и &man.tcpdump.1;.  Войдите на шлюз и
	запустите</para>

      <programlisting>tcpdump dst host 192.168.2.1</programlisting>

      <para>В другой сессии на этом же хосте запустите</para>

      <programlisting>ping 192.168.2.1</programlisting>

      <para>Вы увидите примерно такие строки:</para>

      <programlisting>
16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
      </programlisting>

      <para>Как вы видите, ICMP сообщения пересылаются вперед и назад
	незашифрованными.  Если вы использовали с &man.tcpdump.1; параметр
	<option>-s</option> для получения большего объема данных пакета,
	то увидите больше информации.</para>

      <para>Конечно же это неприемлемо.  В следующем разделе мы обсудим
	защиту соединения между двумя сетями, так что весь трафик будет
	автоматически шифроваться.</para>

      <itemizedlist>
	<title>Резюме:</title>
	<listitem>
	  <para>Настройте оба ядра с <quote>device gif</quote>.</para>
	</listitem>
	<listitem>
	  <para>Отредактируйте <filename>/etc/rc.conf</filename> на шлюзе
	    #1 и добавьте следующие строки (подставляя IP адреса где
	    необходимо).</para>
	  <programlisting>gifconfig_gif0="A.B.C.D W.X.Y.Z"
ifconfig_gif0="inet 192.168.1.1 192.168.2.1 netmask 0xffffffff"
static_routes="vpn"
route_vpn="192.168.2.0 192.168.2.1 netmask 0xffffff00"
	  </programlisting>
	</listitem>

	<listitem>
	  <para>Отредактируйте скрипт брандмауэра
	  (<filename>/etc/rc.firewall</filename>, или подобный) на обеих
	  хостах и добавьте</para>

	  <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
	</listitem>
	<listitem>
	  <para>Выполните соответствующие изменения в
	    <filename>/etc/rc.conf</filename> на шлюзе #2,
	    меняя порядок IP адресов.</para>
	</listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>Шаг 2: Защита соединения</title>

      <para>Для защиты соединения мы будем использовать IPsec.  IPsec
	предоставляет хостам механизм определения ключа для шифрования
	и для последующего использования этого ключа для шифрования
	данных между двумя хостами.</para>

      <para>Здесь будут рассмотрены два аспекта настройки.</para>

      <orderedlist>
	<listitem>
	  <para>У хостов должен быть способ согласования используемого
	    алгоритма шифрования.  Как только хосты договорятся об этом,
	    можно говорить об установленном между ними
	    <quote>безопасном соединении</quote>.</para>
	</listitem>
	<listitem>
	  <para>Должен быть механизм определения, какой трафик необходимо
	    шифровать.  Конечно, вам не требуется шифровать весь исходящий
	    трафик &mdash; достаточно шифровать только трафик, идущий
	    через VPN.  Правила, определяющие то, какой трафик необходимо
	    шифровать, называются <quote>политикой безопасности</quote>.</para>
	</listitem>
      </orderedlist>

      <para>Безопасное соединение и политика безопасности поддерживаются
	ядром, и могут быть изменены программами пользователя.  Однако
	перед тем, как вы сможете сделать это, необходимо настроить
	поддержку протоколов IPsec и Encapsulated Security Payload (ESP) в
	ядре.  Это делается добавлением в настройку ядра параметров:</para>

      <indexterm>
	<primary>параметры ядра</primary>

	<secondary>IPSEC</secondary>
      </indexterm>

      <programlisting>options IPSEC
options IPSEC_ESP</programlisting>

      <para>с последующим перекомпилированием, переустановкой и
	перезагрузкой.  Как и прежде вам потребуется сделать это с ядрами на
	обеих шлюзах.</para>

      <indexterm>
	<primary>IKE</primary>
      </indexterm>

      <para>При настройке параметров безопасности (security associations)
	у вас есть два варианта.  Вы можете настроить их вручную для обеих
	хостов, задав алгоритм шифрования, ключи для шифрования и так далее,
	или использовать даемоны, реализующие Internet Key Exchange protocol
	(IKE), который сделает это за вас.</para>

      <para>Рекомендуется последнее.  Помимо прочего, этот способ более
	прост.</para>

      <indexterm>
	<primary>IPsec</primary>

	<secondary>политики безопасности</secondary>
      </indexterm>

      <indexterm>
	<primary><command>setkey</command></primary>
      </indexterm>

      <para>Редактирование и отображение политики безопасности выполняется
	с помощью &man.setkey.8;.  По аналогии, <command>setkey</command>
	используется для настройки таблиц политики безопасности ядра так же,
	как &man.route.8; используется для настройки таблиц маршрутизации
	ядра.  <command>setkey</command> также может отображать текущие
	параметры безопасности, и продолжая аналогию дальше, это
	соответствует <command>netstat -r</command>.</para>

      <para>Существует множество даемонов для управления параметрами
	безопасности в FreeBSD.  Здесь будет описано использование одного из
	них, racoon&nbsp;&mdash; он доступен в составе порта <filename
	role="package">security/ipsec-tools</filename> в Коллекции
	Портов &os;.</para>

      <indexterm>
	<primary>racoon</primary>
      </indexterm>

      <para>Даемон <application>racoon</application>
	должен работать на обеих шлюзах.  На каждом из хостов
	он настраивается с IP адресом другого конца VPN, и секретным
	ключом (по вашему выбору, должен быть одним и тем же на обеих
	шлюзах).</para>

      <para>Эти два даемона подключаются друг к другу, подтверждают, что они
	именно те, за кого себя выдают (используя секретный ключ, заданный
	вами).  Затем даемоны генерируют новый секретный ключ и используют
	его для шифрования трафика через VPN.  Они периодически изменяют
	этот ключ, так что даже если атакующий сломает один из ключей
	(что теоретически почти невозможно) это не даст ему слишком много
	&mdash; он сломал ключ, который два даемона уже сменили на
	другой.</para>

      <para>Настройки racoon сохраняются в файле
	<filename>${PREFIX}/etc/racoon</filename>.  Этот файл не требует
	слишком больших изменений.  Другим компонентом настройки
	racoon, который потребуется изменить, является <quote>предварительный
	ключ</quote>.</para>

      <para>В настройке по умолчанию racoon ищет его в файле
	<filename>${PREFIX}/etc/racoon/psk.txt</filename>.  Необходимо
	отметить, что предварительный ключ <emphasis>не</emphasis>
	используется для шифрования трафика через VPN соединение
	это просто маркер, позволяющий управляющим ключами даемонам
	доверять друг другу.</para>

      <para><filename>psk.txt</filename> содержит строку для каждого
	удаленного сервера, с которым происходит соединение.  В этом примере
	два сервера, каждый файл <filename>psk.txt</filename> будет
	содержать одну строку (каждый конец VPN общается только с другим
	концом.</para>

       <para>На шлюзе #1 эта строка будет выглядеть примерно так:</para>

       <programlisting>W.X.Y.Z            secret</programlisting>

      <para>То есть <emphasis>публичный</emphasis> IP-адрес противоположной
	стороны, пробел и текстовая строка c секретной фразой.  Конечно, вам
	не стоит использовать в качестве ключевой фразы слово
	<quote>secret</quote> -- здесь применяются обычные правила
	выбора паролей.</para>

      <para>На шлюзе #2 строка будет выглядеть примерно так:</para>

      <programlisting>A.B.C.D            secret</programlisting>

      <para>То есть публичный IP адрес удаленной стороны и та же
	секретная фраза.  Перед запуском racoon режим доступа к файлу
	<filename>psk.txt</filename> должен быть установлен в
	<literal>0600</literal> (т.е. запись и чтение только для
	<username>root</username>).</para>

      <para>Вы должны запустить racoon на обоих шлюзах.  Вам также
	потребуется добавить правила для включения IKE трафика,
	передающегося по UDP через порт ISAKMP (Internet Security Association
	Key Management Protocol).  Опять же, они должны быть
	расположены насколько возможно ближе к началу набора правил.</para>

      <programlisting>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
      </programlisting>

      <para>Как только racoon будет запущен, вы можете попробовать
	выполнить ping с одного шлюза на другой.  Соединение все еще не
	зашифровано, но racoon установит параметры безопасности между
	двумя хостами &mdash; это может занять время и вы можете заметить
	небольшую задержку перед началом ответа команды ping.</para>

      <para>Как только параметры безопасности установлены, вы можете
	просмотреть их используя &man.setkey.8;.  Запустите</para>

      <programlisting>setkey -D</programlisting>

      <para>на любом из хостов для просмотра информации о параметрах
	безопасности.</para>

      <para>Это одна сторона проблемы.  Другая сторона это настройка
	политики безопасности.</para>

      <para>Для создания разумной политики безопасности давайте вспомним,
	что уже было настроено.  Это рассмотрение относится к обеим
	концам соединения.</para>

      <para>Каждый отправляемый IP пакет имеет заголовок, содержащий информацию
	о пакете.  Заголовок включает IP адреса источника и назначения.
	Как мы уже знаем, приватные IP адреса, такие как <hostid
	role="ipaddr">192.168.x.y</hostid>, не могут появиться в
	интернет.  Они должны быть сначала включены внутрь другого
	пакета.  В этом пакете приватные IP адреса источника и назначения
	заменяются публичными IP адресами.</para>

      <para>То есть исходящий пакет, который выглядит примерно так:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-out-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .----------------------------.
  | Src: 192.168.1.1           |
  | Dst: 192.168.2.1           |
  | &lt;другие данные заголовка&gt;  |
  +----------------------------+
  | &lt;данные пакета&gt;            |
  `----------------------------'</literallayout>
	  </textobject>
	</mediaobject>

      <para>будет инкапсулирован в другой пакет, выглядящий примерно
	так:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-encap-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .--------------------------------.
  | Src: A.B.C.D                   |
  | Dst: W.X.Y.Z                   |
  | &lt;другие данные заголовка&gt;      |
  +--------------------------------+
  | .----------------------------. |
  | | Src: 192.168.1.1           | |
  | | Dst: 192.168.2.1           | |
  | | &lt;другие данные заголовка&gt;  | |
  | +----------------------------+ |
  | | &lt;данные пакета&gt;            | |
  | `----------------------------' |
  `--------------------------------'</literallayout>
	  </textobject>
	</mediaobject>

      <para>Этой инкапсуляцией занимается устройство
	<devicename>gif</devicename>.  Как вы можете видеть, теперь
	у пакета есть реальный IP адрес, исходный пакет был включен
	в этот пакет в виде данных, которые передаются через
	интернет.</para>

      <para>Конечно, мы хотим зашифровать весь трафик между VPN.
	Вы можете сформулировать это на словах так:</para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">A.B.C.D</hostid>, и предназначен для <hostid
	role="ipaddr">W.X.Y.Z</hostid>, расшифровать его, используя
	необходимые параметры безопасности.</quote></para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">W.X.Y.Z</hostid>, и предназначен для <hostid
	role="ipaddr">A.B.C.D</hostid>, расшифровать его, используя
	необходимые параметры безопасности.</quote></para>

       <para>Это похоже на желаемое, но не совсем то.  Если вы сделаете
	это, весь трафик от и к <hostid role="ipaddr">W.X.Y.Z</hostid>,
	даже если он не является частью VPN, будет зашифрован.  Правильная
	политика такова:</para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">A.B.C.D</hostid>, в нем инкапсулирован другой пакет
	и адрес назначения <hostid role="ipaddr">W.X.Y.Z</hostid>,
	зашифровать его, используя необходимые параметры
	безопасности.</quote></para>

      <para><quote>Если пакет отправляется с <hostid
	role="ipaddr">W.X.Y.Z</hostid>, в нем инкапсулирован другой пакет
	и адрес назначения <hostid role="ipaddr">A.B.C.D</hostid>,
	зашифровать его, используя необходимые параметры
	безопасности.</quote></para>

      <para>Тонкое, но необходимое различие.</para>

      <para>Политика безопасности также устанавливается с использованием
	&man.setkey.8;.  В &man.setkey.8; предусмотрен язык определения
	политики &man.setkey.8;.  Вы можете или ввести инструкции
	по настройке со стандартного ввода, или использовать параметр
	<option>-f</option> для задания файла, содержащего эти
	инструкции.</para>

      <para>Настройка на шлюзе #1 (где есть публичный IP адрес
	<hostid role="ipaddr">A.B.C.D</hostid>) для включения шифрования
	всего предназначенного <hostid role="ipaddr">W.X.Y.Z</hostid>
	трафика:</para>

      <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;
      </programlisting>

      <para>Поместите эти команды в файл (например,
	<filename>/etc/ipsec.conf</filename>) и запустите</para>

      <screen>&prompt.root; <userinput>setkey -f /etc/ipsec.conf</userinput></screen>

      <para><option>spdadd</option> указывает &man.setkey.8; добавить
	правило к базе данных политики безопасности.  Остальная часть
	строки указывает какие пакеты будут соответствовать политике.
	<hostid role="ipaddr">A.B.C.D/32</hostid> и <hostid
	role="ipaddr">W.X.Y.Z/32</hostid> это IP адреса и сетевые маски,
	определяющие сети или хосты, к которым будет применяться данная
	политика.  В данном случае мы хотим применить их к трафику между
	этими двумя хостами.  Параметр <option>ipencap</option> сообщает
	ядру, что эта политика должна применяться только к пакетам,
	инкапсулирующим другие пакеты.  Параметр <option>-P out</option>
	сообщает, что эта политика применяется к исходящим пакетам, и
	<option>ipsec</option> &mdash; то, что пакеты будут
	зашифрованы.</para>

      <para>Оставшаяся часть строки определяет, как эти пакеты будут
	зашифрованы.  Будет использоваться протокол <option>esp</option>,
	а параметр <option>tunnel</option> показывает, что пакет в дальнейшем
	будет инкапсулирован в IPsec пакет.  Повторное использование
	<hostid role="ipaddr">A.B.C.D</hostid> и <hostid
	role="ipaddr">W.X.Y.Z</hostid> предназначено для выбора
	используемых параметров безопасности, и наконец параметр
	<option>require</option> разрешает шифрование пакетов, попадающих
	под это правило.</para>

      <para>Это правило соответствует только исходящим пакетам.  Вам
	потребуется похожее правило, соответствующее входящим пакетам.</para>

      <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</programlisting>

      <para>Обратите внимание, что вместо <option>in</option> используется
	 <option>out</option> и IP адреса переставлены.</para>

      <para>Другому шлюзу (с публичным IP адресом
	<hostid role="ipaddr">W.X.Y.Z</hostid>) потребуются похожие
	правила.</para>

      <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>

      <para>Наконец, вам потребуется добавить правила к брандмауэру
	для включения прохождения пакетов ESP и IPENCAP в обе стороны.
	На обеих хостах потребуется добавить следующие правила:</para>

      <programlisting>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
      </programlisting>

      <para>Поскольку правила симметричны, можно использовать их без
	изменения на обеих хостах

      <para>Исходящие пакеты теперь будут выглядеть примерно так:</para>

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-crypt-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .------------------------------.  --------------------------.
  | Src: A.B.C.D                 |                            |
  | Dst: W.X.Y.Z                 |                            |
  | &lt;other header info&gt;          |                            |  Encrypted
  +------------------------------+                            |  packet.
  | .--------------------------. |  -------------.            |  contents
  | | Src: A.B.C.D             | |               |            |  are
  | | Dst: W.X.Y.Z             | |               |            |  completely
  | | &lt;other header info&gt;      | |               |            |- secure
  | +--------------------------+ |               |  Encap'd   |  from third
  | | .----------------------. | |  -.           |  packet    |  party
  | | | Src: 192.168.1.1     | | |   |  Original |- with real |  snooping
  | | | Dst: 192.168.2.1     | | |   |  packet,  |  IP addr   |
  | | | &lt;other header info&gt;  | | |   |- private  |            |
  | | +----------------------+ | |   |  IP addr  |            |
  | | | &lt;packet data&gt;        | | |   |           |            |
  | | `----------------------' | |  -'           |            |
  | `--------------------------' |  -------------'            |
  `------------------------------'  --------------------------'
	    </literallayout>
	  </textobject>
	</mediaobject>

      <para>Когда эти пакеты будут получены на удаленном конце VPN
	соединения, они будут расшифрованы (используя параметры
	безопасности, о которых договорился racoon).  Затем они будут
	переданы интерфейсу <devicename>gif</devicename>, который
	<quote>развернет</quote> второй слой, оставив пакет с внутренними
	адресами, который сможет попасть во внутреннюю сеть.</para>

      <para>Вы можете проверить безопасность тем же &man.ping.8;, который
	использовался ранее.  Сначала войдите на шлюз <hostid
	role="ipaddr">A.B.C.D</hostid> и запустите:</para>

      <programlisting>tcpdump dst host 192.168.2.1</programlisting>

      <para>В другой сессии на том же хосте запустите</para>

      <programlisting>ping 192.168.2.1</programlisting>

      <para>В этот момент вы должны увидеть примерно это:</para>

      <programlisting>XXX tcpdump output</programlisting>

      <para>Теперь, как видите, &man.tcpdump.1; показывает ESP пакеты.  Если
	вы попытаетесь просмотреть их с параметром <option>-s</option>,
	то вероятно увидите  нечто непонятное, поскольку применяется
	шифрование.</para>

      <para>Поздравляем. Вы только что настроили VPN между двумя удаленными
	сетями.</para>

      <itemizedlist>
	<title>Резюме</title>

	<listitem>
	  <para>Настройте оба ядра с:</para>

	  <programlisting>options IPSEC
options IPSEC_ESP
	  </programlisting>
	</listitem>

	<listitem>
	  <para>Установите <filename
	    role="package">security/ipsec-tools</filename>.  Отредактируйте
	    <filename>${PREFIX}/etc/racoon/psk.txt</filename> на обеих
	    шлюзах, добавив запись для каждого IP адреса удаленного хоста
	    и секретный ключ, который будет известен им обеим.  Убедитесь,
	    что режим доступа к файлу 0600.</para>
	</listitem>
	<listitem>
	  <para>Добавьте к
	    <filename>/etc/rc.conf</filename> на каждом хосте следующие
	    строки:</para>

	  <programlisting>ipsec_enable="YES"
ipsec_file="/etc/ipsec.conf"
	  </programlisting>
	</listitem>
	<listitem>
	  <para>Создайте <filename>/etc/ipsec.conf</filename> на каждом
	    хосте с необходимыми строками spdadd.  На шлюзе #1 он будет
	    таким:</para>

	  <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
</programlisting>

	  <para>А на шлюзе #2 таким:</para>

<programlisting>
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
</programlisting>
	</listitem>
	<listitem>
	  <para>Добавьте правила к брандмауэрам обеих хостов для
	    включения IKE, ESP и IPENCAP трафика:</para>

	  <programlisting>
ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
	  </programlisting>
	</listitem>
      </itemizedlist>

      <para>Двух приведенных шагов должно быть достаточно для настройки
	и включения VPN.  Машины в каждой сети смогут обращаться друг к
	другу по IP адресам, и весь трафик через соединение будет
	автоматически надежно зашифрован.</para>
    </sect3>
    </sect2>
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Предоставил </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>безопасность</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> это набор сетевых инструментов,
      используемых для защищенного доступа к удаленным компьютерам.
      Он может быть использован в качестве непосредственной замены
      <command>rlogin</command>, <command>rsh</command>,
      <command>rcp</command> и <command>telnet</command>.
      Кроме того, через SSH могут быть безопасно туннелированы и/или
      перенаправлены произвольные TCP/IP соединения.
      <application>OpenSSH</application> шифрует весь трафик, эффективно
      предотвращая кражу данных, перехват соединения и другие сетевые
      атаки.</para>

    <para><application>OpenSSH</application> поддерживается проектом
      OpenBSD, он основан на SSH v1.2.12 со всеми последними исправлениями
      и обновлениями, совместим с протоколами SSH версий 1 и 2.</para>

    <sect2>
      <title>Преимущества использования OpenSSH</title>

      <para>Обычно при использовании &man.telnet.1; или &man.rlogin.1;
	данные пересылаются по сети в незашифрованной форме.  Перехватчик
	пакетов в любой точке сети между клиентом и сервером может
	похитить информацию о пользователе/пароле или данные, передаваемые
	через соединение.  Для предотвращения этого
	<application>OpenSSH</application> предлагает различные методы
	шифрования.</para>
    </sect2>

    <sect2>
      <title>Включение sshd</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>включение</secondary>
      </indexterm>

      <para>В &os; даемон <application>sshd</application> должен
	быть разрешен в процессе инсталляции.  За запуск ответственна
	следующая строка в файле <filename>rc.conf</filename>:</para>

      <screen>sshd_enable="YES"</screen>

      <para>При следующей загрузке системы будет запущен &man.sshd.8;, даемон для
	<application>OpenSSH</application>.  Вы можете также воспользоваться
	скриптом <filename>/etc/rc.d/sshd</filename> системы &man.rc.8;
	для запуска <application>OpenSSH</application>:</para>

	<programlisting>/etc/rc.d/sshd start</programlisting>
     </sect2>

    <sect2>
      <title>SSH клиент</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>клиент</secondary>
      </indexterm>

      <para>Утилита &man.ssh.1; работает подобно &man.rlogin.1;.</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>Вход продолжится так же, как если бы сессия была инициирована
	с использованием <command>rlogin</command> или
	<command>telnet</command>.  SSH использует систему опознавательных
	ключей для проверки подлинности сервера при подключении клиента.
	Пользователю предлагается <literal>yes</literal> только при первом
	подключении.  Дальнейшие попытки входа предваряются проверкой
	сохраненного ключа сервера.  SSH клиент сообщит вам, если сохраненный
	ключ будет отличаться от только что полученного.  Ключи серверов
	сохраняются в <filename>~/.ssh/known_hosts</filename>, или в
	<filename>~/.ssh/known_hosts2</filename> для SSH v2.</para>

      <para>По умолчанию современные серверы <application>OpenSSH</application>
	настроены на приём только соединений SSH v2.  Клиент будет
	использовать версию 2 там, где это возможно, а затем версию 1.
	Также, клиент можно заставить использовать конкретную версию при помощи
	опций <option>-1</option> и <option>-2</option> для указания
	соответствующей версии протокола.  Версия 1 поддерживается ради
	совместимости со старыми серверами.</para>
    </sect2>

    <sect2>
      <title>Безопасное копирование</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>безопасное копирование</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>Команда &man.scp.1; работает подобно &man.rcp.1;; она копирует
	файл с удаленного компьютера, но делает это безопасным
	способом.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735       00:00
&prompt.root;</screen>

      <para>Поскольку в предыдущем примере ключ сервера уже был сохранен,
	в этом примере он проверяется при использовании &man.scp.1;.</para>

      <para>Параметры, передаваемые &man.scp.1;, похожи на параметры
	&man.cp.1;, с файлом или файлами в качестве первого аргумента и
	приемником копирования во втором.  Поскольку файлы файлы передаются
	по сети через SSH, один или более аргументов принимают форму
	<option>user@host:&lt;path_to_remote_file&gt;</option>.</para>

    </sect2>

    <sect2>
      <title>Настройка</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>настройка</secondary>
      </indexterm>

      <para>Системные файлы настройки для даемона и клиента
	<application>OpenSSH</application> расположены в каталоге
	<filename>/etc/ssh</filename>.</para>

      <para>Файл <filename>ssh_config</filename> используется для настройки
	клиента, а <filename>sshd_config</filename> для даемона.</para>

      <para>Кроме того, параметры <option>sshd_program</option>
	(по умолчанию <filename>/usr/sbin/sshd</filename>), и
	<option>sshd_flags</option> <filename>rc.conf</filename>
	дают дополнительные возможности настройки.</para>
    </sect2>

    <sect2 id="ssh-keygen">
      <title>ssh-keygen</title>

      <para>Вместо использования паролей, с помощью &man.ssh-keygen.1;
	можно создать ключи DSA или RSA, которыми
	пользователи могут аутентифицироваться:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>dsa</replaceable></userinput>
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com
</screen>

      <para>&man.ssh-keygen.1; создаст пару публичного и приватного
	ключей, используемых для аутентификации.  Приватный ключ сохраняется
	в <filename>~/.ssh/id_dsa</filename> или
	<filename>~/.ssh/id_rsa</filename>, а публичный в
	<filename>~/.ssh/id_dsa.pub</filename> или
	<filename>~/.ssh/id_rsa.pub</filename> (для ключей DSA и RSA
	соответственно).  Для включения
	аутентификации по ключам публичный ключ должен
	быть помещен в файл <filename>~/.ssh/authorized_keys</filename>
	на удаленном компьютере.</para>

      <para>Это позволяет соединяться с удаленным компьютером с помощью
	SSH-ключей вместо паролей.</para>

      <para>Если при генерации ключей был использован пароль, каждый раз
	для при использовании приватного ключа он будет запрашиваться
	у пользователя.  Для того, чтобы избежать непрерывного набора
	кодовой фразы, можно использовать утилиту &man.ssh-agent.1;,
	как описано в разделе <xref linkend="security-ssh-agent">
	ниже.</para>

      <warning><para>Параметры и имена файлов могут различаться для разных
	версий <application>OpenSSH</application>, установленных в системе,
	для решения проблем обратитесь к странице справочника
	&man.ssh-keygen.1;.</para></warning>
    </sect2>

    <sect2 id="security-ssh-agent">
      <title>Утилиты ssh-agent и ssh-add</title>

      <para>Утилиты &man.ssh-agent.1; и &man.ssh-add.1; позволяют
	сохранять ключи <application>SSH</application> в памяти, чтобы
	не набирать кодовые фразы при каждом использовании ключа.</para>

      <para>Утилита &man.ssh-agent.1; обеспечивает процесс аутентификации
	загруженными в нее секретными ключами; для этого утилита
	&man.ssh-agent.1; должна запустить внешний процесс.  В самом простом
	случае это может быть шелл-процесс; в чуть более продвинутом &mdash;
	оконный менеджер.</para>

      <para>Для использования &man.ssh-agent.1; совместно с шеллом,
	&man.ssh-agent.1; должен быть запущен с именем этого шелла
	в качестве аргумента.  После этого в его память при помощи
	утилиты  &man.ssh-add.1; могут быть добавлены необходимые ключи;
	при этом будут запрошены соответствующие кодовые фразы.
	Добавленные ключи могут затем использоваться для &man.ssh.1;
	на машины, на которых установлены соответствующие публичные
	ключи:</para>

      <screen>&prompt.user; ssh-agent <replaceable>csh</replaceable>
&prompt.user; ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
&prompt.user;</screen>

      <para>Для того чтобы использовать &man.ssh-agent.1; в X11,
	вызов &man.ssh-agent.1;должен быть помещен в файл
	<filename>~/.xinitrc</filename>.  Это обеспечит поддержкой
	&man.ssh-agent.1; все программы, запущенные в X11.  Файл
	<filename>~/.xinitrc</filename> может выглядеть, например,
	так:</para>

      <programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

      <para>При этом будет запущен &man.ssh-agent.1;, который, в свою
	очередь, вызовет запуск <application>XFCE</application>, при каждом
	старте X11.  После запуска X11, выполните команду &man.ssh-add.1;
	для добавления ваших SSH-ключей.</para>
    </sect2>

    <sect2 id="security-ssh-tunneling">
      <title>Туннелирование SSH</title>

      <indexterm>
	<primary>OpenSSH</primary>

	<secondary>туннелирование</secondary>
      </indexterm>

      <para><application>OpenSSH</application> поддерживает возможность
	создания туннеля для пропуска соединения по другому протоколу
	через защищенную сессию.</para>

      <para>Следующая команда указывает &man.ssh.1; создать туннель для
	<application>telnet</application>:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>Команда <command>ssh</command> используется со следующими
	параметрами:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Указывает <command>ssh</command> использовать версию
	      2 протокола (не используйте этот параметр, если работаете
	      со старыми SSH серверами).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Означает использование в не-командном режиме, только для
	      туннелирования.  Если этот параметр опущен,
	      <command>ssh</command> запустит обычную сессию.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Указывает <command>ssh</command> запускаться в фоновом
	      режиме.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Означает локальный туннель в стиле
	      <replaceable>localport:remotehost:remoteport</replaceable>.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Удаленный сервер SSH.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


      <para>Туннель SSH создается путем создания прослушивающего сокета
	на определенном порту <hostid>localhost</hostid>.  Затем все
	принятые на локальном хосту/порту соединения переправляются на
	через SSH на определенный удаленный хост и порт.</para>

      <para>В этом примере, порт <replaceable>5023</replaceable> на
	<hostid>localhost</hostid> перенаправляется на порт
	<replaceable>23</replaceable> на <hostid>localhost</hostid>
	удаленного компьютера.  Поскольку <replaceable>23</replaceable>
	это порт <application>telnet</application>, будет создано защищенное
	соединение <application>telnet</application> через туннель
	SSH.</para>

      <para>Этот метод можно использовать для любого числа небезопасных
	протоколов, таких как SMTP, POP3, FTP, и так далее.</para>

      <example>
	<title>Использование SSH для создания защищенного туннеля на
	  SMTP</title>

	<screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

	<para>Этот метод можно использовать вместе с &man.ssh-keygen.1;
	  и дополнительными пользовательскими учётными записями для
	  создания более удобного автоматического SSH туннелирования.
	  Ключи могут быть использованы вместо паролей, и туннели
	  могут запускаться от отдельных пользователей.</para>
      </example>

      <sect3>
	<title>Практические примеры SSH туннелирования</title>

	<sect4>
	  <title>Защищенный доступ к серверу POP3</title>

	  <para>На работе находится SSH сервер, принимающий соединения
	    снаружи.  В этой же офисной сети находится почтовый сервер,
	    поддерживающий протокол POP3.  Сеть или сетевое соединение
	    между вашим домом и офисом могут быть или не быть полностью
	    доверяемыми.  По этой причине вам потребуется проверять
	    почту через защищенное соединение.  Решение состоит в создании
	    SSH соединения к офисному серверу SSH и туннелирование
	    через него к почтовому серверу.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Когда туннель включен и работает, вы можете настроить
	    почтовый клиент для отправки запросов POP3 на
	    <hostid>localhost</hostid>, порт 2110.  Соединение будет
	    безопасно переправлено через туннель на
	    <hostid>mail.example.com</hostid>.</para>
	</sect4>

	<sect4>
	  <title>Прохождение через Драконовский Брандмауэр</title>

	  <para>Некоторые сетевые администраторы устанавливают
	    на брандмауэрах драконовские правила,
	    фильтруя не только входящие соединения, но и исходящие.
	    Вам может быть разрешен доступ к удаленным компьютерам только
	    по портам 22 и 80, для SSH и просмотра сайтов.</para>

	  <para>Вам может потребоваться доступ к другому (возможно, не
	    относящемуся к работе) сервису, такому как Ogg Vorbis
	    для прослушивания музыки.  Если этот сервер Ogg Vorbis
	    выдает поток не с портов 22 или 80, вы не сможете получить
	    к нему доступ.</para>

	  <para>Решение состоит в создании SSH соединения с компьютером
	    вне брандмауэра и использование его для туннелирования
	    сервера Ogg Vorbis.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>Клиентскую программу теперь можно настроить на
	    <hostid>localhost</hostid> порт 8888, который будет перенаправлен
	    на <hostid>music.example.com</hostid> порт 8000, успешно
	    обойдя брандмауэр.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Параметр ограничения пользователей
	<varname>AllowUsers</varname></title>

      <para>Зачастую хорошие результаты даёт ограничение того, какие
	именно пользователи и откуда могут регистрироваться в системе.
	Задание параметра <literal>AllowUsers</literal> является хорошим
	способом добиться этого.  К примеру, для разрешения регистрации только
	пользователю <username>root</username> с машины <hostid
	role="ipaddr">192.168.1.32</hostid>, в файле
	<filename>/etc/ssh/sshd_config</filename> нужно указать нечто вроде
	следующего:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para>Для разрешения регистрации пользователя <username>admin</username>
	из любой точки, просто укажите имя пользователя:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Несколько пользователей должны перечислять в одной строке, как
	здесь:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
	<para>Важно, чтобы бы перечислили всех пользователей, которые должны
	  регистрироваться на этой машине; в противном случае они будут
	  заблокированы.</para>
      </note>

      <para>После внесения изменений в
	<filename>/etc/ssh/sshd_config</filename> вы должны указать
	&man.sshd.8; на повторную загрузку конфигурационных файлов, выполнив
	следующую команду:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>Дополнительная литература</title>

      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>

      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
	&man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5;</para>

      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5;</para>
    </sect2>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>ACL</primary>
    </indexterm>
    <title>Списки контроля доступа файловой системы (ACL)</title>

    <para>В дополнение к другим расширениям файловой системы, таким как
      снимки (snapshots), FreeBSD 5.0 и более поздние версии системы
      предлагают защиту с помощью списков контроля доступа файловой системы
      (File System Access Control Lists, <acronym>ACLs</acronym>).</para>

    <para>Списки контроля доступа расширяют стандартную модель прав &unix;
      высоко совместимым (&posix;.1e) способом.  Эта возможность позволяет
      администратору получить преимущество от использования более
      интеллектуальной модели безопасности.</para>

    <para>Для включения поддержки <acronym>ACL</acronym> в файловой
      системе <acronym>UFS</acronym>, следующая строка:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>должна быть добавлена в файл настройки ядра.  Если параметр не
      добавлен, при попытке монтирования систем, поддерживающих
      <acronym>ACL</acronym>, появится предупреждающее сообщение.
      Этот параметр включен в ядро <filename>GENERIC</filename>.
      <acronym>ACL</acronym> основывается на дополнительных атрибутах,
      встроенных в файловую систему.  Дополнительные атрибуты
      поддерживаются по умолчанию следующим поколением файловых систем
      &unix;, <acronym>UFS2</acronym>.</para>

    <note><para>Для включения дополнительных атрибутов в
      <acronym>UFS1</acronym> требуется больше усилий по сравнению с
      <acronym>UFS2</acronym>.  Производительность дополнительных
      атрибутов в <acronym>UFS2</acronym> также существенно выше.
      По этим причинам для работы с списками контроля доступа
      предпочтительно использование <acronym>UFS2</acronym></para></note>

    <para><acronym>ACL</acronym> включаются во время монтирования флагом
      <option>acls</option>, который добавляется к
      <filename>/etc/fstab</filename>.  Этот флаг также можно сделать
      постоянным с помощью &man.tunefs.8;, изменив флаг
      <acronym>ACL</acronym> в заголовке файловой системы.  Вообще говоря,
      использование флага в суперблоке предпочтительно по нескольким
      причинам:</para>

    <itemizedlist>
      <listitem>
	<para>Постоянный <acronym>ACL</acronym> флаг не может быть изменен
	  путем перемонтирования системы (&man.mount.8; <option>-u</option>),
	  а только через &man.umount.8; и &man.mount.8;.  Это означает,
	  что <acronym>ACL</acronym> нельзя включить на корневой файловой
	  системе после загрузки.  Это также означает, что вы не можете
	  изменить флаг на используемой файловой системе.</para>
      </listitem>

      <listitem>
	<para>Установка флага в суперблоке приводит к постоянному монтированию
	  файловой системы с включенным <acronym>ACL</acronym>, даже если
	  нет записи в <filename>fstab</filename> или при смене порядка
	  устройств.  Это предотвращает случайное монтирование файловой
	  системы без <acronym>ACL</acronym>, которое может повлечь за
	  собой проблемы с безопасностью.</para>
      </listitem>
    </itemizedlist>

    <note><para>Мы можем изменить поведение <acronym>ACL</acronym> для
	включения флага без полного перемонтирования, но считаем, что
	желательно исключить случайное монтирование без
	<acronym>ACL</acronym>, поскольку вы можете попасть в неприятную
	ситуацию, если включите <acronym>ACL</acronym>, затем выключите
	их, затем опять включите без сброса расширенных атрибутов.
	Обычно, как только вы включили <acronym>ACL</acronym> в файловой
	системе, они не должны быть выключены, поскольку получающаяся
	защита файлов может быть не совместима с той, что применяется
	пользователями системы, и повторное включение <acronym>ACL</acronym>
	может подключить предыдущие списки контроля доступа к файлам,
	права на которые изменены, что приведет к непредсказуемому
	поведению.</para></note>

    <para>Файловые системы с включенными <acronym>ACLs</acronym> показывают
      знак <literal>+</literal> при просмотре прав на файлы.
      Например:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Здесь мы видим, что каталоги <filename>directory1</filename>,
      <filename>directory2</filename>, и <filename>directory3</filename>
      используют преимущества <acronym>ACL</acronym>.  Каталог
      <filename>public_html</filename> их не использует.</para>

    <sect2>
      <title>Использование <acronym>ACL</acronym></title>

      <para><acronym>ACL</acronym> файловой системы можно просмотреть
	с помощью утилиты &man.getfacl.1;.  Например, для просмотра
	настроек <acronym>ACL</acronym> файла
	<filename>test</filename>, может использоваться команда:</para>

      <screen>&prompt.user; <userinput>getfacl <filename>test</filename></userinput>
        #file:test
        #owner:1001
        #group:1001
        user::rw-
        group::r--
        other::r--</screen>

      <para>Для изменения <acronym>ACL</acronym> этого файла,
	вызовите утилиту &man.setfacl.1;.  Выполните:</para>

      <screen>&prompt.user; <userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para>Параметр <option>-k</option> удалит все установленные
	на данный момент <acronym>ACL</acronym> из файла или файловой
	системы.  Более предпочтительный метод это использование
	параметра <option>-b</option>, который оставит необходимые
	для работы <acronym>ACL</acronym> поля.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,group:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>В вышеприведенной команде параметр <option>-m</option>
	использован для изменения записей <acronym>ACL</acronym>
	по умолчанию.  Поскольку предустановленных записей не было (они были
	удалены предыдущей командой), эта команда восстановит параметры
	по умолчанию и задаст приведенные параметры.  Имейте ввиду,
	при добавлении пользователя или группы, которых нет в системе,
	на <devicename>stdout</devicename> будет выведена ошибка
	<errorname>Invalid argument</errorname>.</para>
    </sect2>
  </sect1>

  <sect1 id="security-portaudit">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>

	  <surname>Родес</surname>

	  <contrib>Текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>Portaudit</primary>
    </indexterm>

    <title>Мониторинг вопросов безопасности в ПО сторонних
      разработчиков</title>

    <para>В последние годы в области информационной безопасности произошло
      много улучшений, касающихся выработки оценки уязвимости.  Угроза
      проникновения в систему увеличивается вместе с установкой и настройкой
      утилит сторонних разработчиков, какой бы современной операционной
      системы это ни касалось.</para>

    <para>Оценка уязвимости является ключевым фактором обеспечения защиты, и
      хотя для базового комплекта &os; выпускаются бюллетени безопасности, но
      делать это для каждой сторонней утилиты выше возможностей участников
      Проекта &os;.  Существует способ смягчения уязвимостей программного
      обеспечения сторонних разработчиков и предупреждения администраторов об
      известных проблемах с безопасностью.  Во &os; существует утилита под
      названием <application>Portaudit</application>, которая служит
      исключительно этой цели.</para>

    <para>Порт <filename role="port">security/portaudit</filename> обращается
      к базе данных, обновляемой и поддерживаемой Группой информационной
      безопасности &os; и разработчиками портов, для получения информации об
      известных проблемах с защитой.</para>

    <para>Для того, чтобы приступить к использованию
      <application>Portaudit</application>, необходимо установить его из
      Коллекции Портов:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/security/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>В процессе установки будут обновлены конфигурационные файлы для
      &man.periodic.8;, в которые будет добавлена выдача
      <application>Portaudit</application> при ежедневном её запуске.
      Проверьте, что ежедневные сообщения электронной почты, касающиеся
      безопасности, которые посылаются на адрес <username>root</username>,
      прочитываются.  Другой дополнительной настройки больше не
      понадобится.</para>

    <para>После установки администратор может обновить базу данных
      и посмотреть список известных уязвимостей в установленных пакетах
      при помощи команды</para>

    <screen>&prompt.root; <userinput>portaudit -Fda</userinput></screen>

    <note>
      <para>База данных будет автоматически обновлена при запуске
	&man.periodic.8;; таким образом, предыдущая команду можно полностью
	опустить.  Она требуется только для следующих примеров.</para>
    </note>

    <para>Для аудита утилит сторонних разработчиков, установленных как часть
      Коллекции Портов, администратору достаточно запускать только следующую
      команду:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para>Утилита <application>portaudit</application> выдаст примерно
      следующее:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Перейдя в Web-браузере по показанному <acronym>URL</acronym>,
      администратор может получить более подробную информацию о показанной
      уязвимости.  В неё войдёт перечисление версий, затронутых
      соответствующей версией порта &os;, а также другие Web-сайты, которые
      могут содержать бюллетени безопасности.</para>

    <para>Если описывать вкратце, то <application>Portaudit</application>
      является мощной и, при использовании вместе с портом
      <application>Portupgrade</application>, чрезвычайно полезной
      утилитой.</para>
  </sect1>

  <sect1 id="security-advisories">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>Сообщения безопасности FreeBSD</primary>
    </indexterm>
    <title>Сообщения безопасности &os;</title>

    <para>Как многие и высококачественные операционные системы, &os;
      публикует <quote>Сообщения безопасности</quote> (<quote>Security
      Advisories</quote>).  Эти сообщения обычно отправляются по почте
      в списки рассылки, посвященные безопасности и публикуются
      в списке проблем только после выхода исправлений к соответствующим
      релизам.  В этом разделе разъясняется, что такое сообщения безопасности,
      как их читать и какие меры принимать для исправления системы.</para>

    <sect2>
      <title>Как выглядит сообщение?</title>

      <para>Сообщение безопасности &os; выглядит подобно сообщению ниже,
	взятому из списка рассылки &a.security-notifications.name;.</para>

      <programlisting>=============================================================================
&os;-SA-XX:XX.UTIL                                     Security Advisory
                                                          The &os; Project

Topic:          denial of service due to some problem<co id="co-topic">

Category:       core<co id="co-category">
Module:         sys<co id="co-module">
Announced:      2003-09-23<co id="co-announce">
Credits:        Person@EMAIL-ADDRESS<co id="co-credit">
Affects:        All releases of &os;<co id="co-affects">
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co id="co-corrected">
<acronym>CVE</acronym> Name:   CVE-XXXX-XXXX<co id="co-cve">

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<co id="co-backround">


II.  Problem Description<co id="co-descript">


III. Impact<co id="co-impact">


IV.  Workaround<co id="co-workaround">


V.   Solution<co id="co-solution">


VI.  Correction details<co id="co-details">


VII. References<co id="co-ref"></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para>Поле <literal>Topic</literal> показывает в чем именно
	    заключается проблема.  Это обычно введение в сообщение
	    безопасности, упоминающее утилиту, в которой возникла
	    ошибка.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>Поле <literal>Category</literal> относится к затронутой части
	    системы и может быть выбрана из <literal>core</literal>,
	    <literal>contrib</literal>, или <literal>ports</literal>.
	    Категория <literal>core</literal> означает, что
	    уязвимость затрагивает основной компонент операционной системы
	    &os;.  Категория <literal>contrib</literal> означает, что
	    уязвимость затрагивает программы, предоставленные проекту
	    &os;, например <application>sendmail</application>.  Наконец,
	    категория <literal>ports</literal> означает, что уязвимость
	    затрагивает программное обеспечение, доступное из Коллекции
	    Портов.</para>
	</callout>

	<callout arearefs="co-module">
	  <para>Поле <literal>Module</literal> указывает на местоположение
	    компонента, например <literal>sys</literal>.  В этом примере
	    мы видим, что затронут модуль <literal>sys</literal>,
	    следовательно, эта уязвимость относится к компоненту,
	    используемому в ядре.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para>Поле <literal>Announced</literal> отражает дату публикации
	    сообщения безопасности, или его анонсирования.  Это означает,
	    что команда обеспечения безопасности убедилась, что проблема
	    существует и что патч помещён в хранилище исходных текстов
	    &os;.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para>Поле <literal>Credits</literal> упоминает частное лицо или
	    организацию, обнаружившую уязвимость и сообщившую о ней.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para>Поле <literal>Affects</literal> дает информацию о релизах
	    &os;, к которым относится данная уязвимость.  Для базовой
	    системы, просмотр вывода команды <command>ident</command>
	    для файлов, затронутых уязвимостью, поможет определить
	    ревизию.  Номер версии портов приведен после имени порта
	    в каталоге <filename>/var/db/pkg</filename>.  Если система
	    не синхронизируется с <acronym>CVS</acronym>-хранилищем
	    &os; и не пересобирается ежедневно, высок шанс, что
	    она затронута уязвимостью.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para>Поле <literal>Corrected</literal> показывает дату, время,
	    смещение во времени и релиз, в котором исправлена ошибка.</para>
	</callout>

	<callout arearefs="co-cve">
	  <para>Зарезервировано для идентификации уязвимости в общей базе
	    данных CVD (Common Vulnerabilities Database).</para>

	<callout arearefs="co-backround">
	  <para>Поле <literal>Background</literal> дает информацию именно
	    о той утилите, для которой выпущено сообщение.  Как правило
	    информация о том, зачем утилита присутствует в &os;, для
	    чего она используется, и немного информации о том, как
	    появилась эта утилита.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para>Поле <literal>Problem Description</literal> дает более
	    глубокие разъяснения возникшей проблемы.  Оно может включать
	    информацию об ошибочном коде, или даже о том, как утилита
	    может быть использована для создания бреши в системе
	    безопасности.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para>Поле <literal>Impact</literal> описывает тип воздействия,
	    который проблема может оказать на систему.  Это может быть
	    все, что угодно, от атаки на отказ в обслуживании до
	    получения пользователями дополнительных привилегий, или
	    даже получения атакующим прав суперпользователя.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para>Поле <literal>Workaround</literal> предлагает тем,
	    системным администраторам, которые не могут обновить систему,
	    обходной путь решения проблемы.  Он может пригодиться при
	    недостатке времени, отсутствии подключения к сети или по
	    массе других причин.  В любом случае, к безопасности нельзя
	    относиться несерьезно, и необходимо либо применить указанный
	    обходной путь, либо исправить систему.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para>Поле <literal>Solution</literal> предлагает инструкции по
	    исправлению затронутой системы.  Это пошаговое руководство,
	    протестированный метод восстановления безопасности системы.</para>
	</callout>

	<callout arearefs="co-details">
	  <para>Поле <literal>Correction Details</literal> показывает
	    ветвь <acronym>CVS</acronym> (имя релиза с точками, замененными
	    на символы подчеркивания).  Здесь также показан номер ревизии
	    каждого файла из каждой ветви.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para>Поле <literal>References</literal> обычно упоминает
	    другие источники информации.  Это могут быть Web-страницы,
	    книги, списки рассылки и группы новостей.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 id="security-accounting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>

	  <surname>Родес</surname>

	  <contrib>Текст предоставил </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>Учёт используемых ресурсов</primary>
    </indexterm>

    <title>Учёт используемых ресурсов</title>

    <para>Учёт используемых процессами ресурсов представляет собой метод
      защиты, при котором администратор может отслеживать использование
      системных ресурсов и их распределение между пользователями для нужд
      системного мониторинга и минимального отслеживания команд
      пользователей.</para>

    <para>На самом деле здесь есть свои положительный и отрицательные моменты.
      Положительной стороной является то, что проникновение может быть
      отслежено до первоначальной точки входа.  Отрицательной стороной
      является объём протоколов, который генерируется при мониторинге, и
      соответствующие требования к дисковому пространству.  В этом разделе
      администратору даются основы учёта ресурсов процессов.</para>

    <sect2>
      <title>Активация и использование учёта ресурсов</title>

      <para>Прежде чем использовать систему учёта ресурсов, её необходимо
	активировать.  Для этого выполните следующие команды:</para>

      <screen>&prompt.root; <userinput>touch <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>accton <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; <filename>/etc/rc.conf</filename></userinput></screen>

      <para>После активации система учёта ресурсов начнёт отслеживать
	статистику <acronym>CPU</acronym>, команд и так далее.  Все протоколы
	учёта ведутся в формате, недоступном для чтения человеком, и могут
	просматриваться при помощи утилиты &man.sa.8;.  Запущенная без
	параметров, <command>sa</command> выдаст информацию, относящуюся к
	количеству вызовов в расчёте на каждого пользователя, общее
	затраченное время в минутах, общее время <acronym>CPU</acronym> и
	пользователя в минутах, среднее количество операций ввода/вывода и
	так далее.</para>

      <para>Для просмотра информации о запущенных командах, необходимо
	воспользоваться утилитой &man.lastcomm.1;.  Команду
	<command>lastcomm</command> можно использовать, например, для выдачи
	списка директив, выданных пользователями определённого терминала
	&man.ttys.5;:</para>

      <screen>&prompt.root; <userinput>lastcomm ls <username>trhodes</username> ttyp1</userinput></screen>

      <para>Эта команда выдаст все зафиксированные использования команды
	<command>ls</command> пользователем <username>trhodes</username> на
	терминале ttyp1.</para>

      <para>Существует многие другие полезные параметры, которые описаны на
	соответствующих справочных страницах &man.lastcomm.1;, &man.acct.5; и
	&man.sa.8;.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
