<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/mac/chapter.sgml,v 1.17 2004/11/26 14:34:37 den Exp $

     Original revision: r22988
-->

<chapter id="mac">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Написал </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Денис</firstname>
	<surname>Пеплин</surname>
	<contrib>Перевод на русский язык: </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Принудительный контроль доступа (MAC)</title>

  <sect1 id="mac-synopsis">
    <title>Краткий обзор</title>

    <indexterm><primary>MAC</primary></indexterm>
    <indexterm><primary>Mandatory Access Control</primary></indexterm>
    <indexterm><primary>Принудительный контроль доступа</primary></indexterm>

    <para>&os;&nbsp;5.X представляет новые расширения системы безопасности
      от проекта TrustedBSD, основанные на документах &posix;.1e.
      Два из наиболее важных нововведений в механизмах безопасности это
      списки контроля доступа файловой системы (Access Control Lists,
      <acronym>ACLs</acronym>) и принудительный контроль доступа
      Mandatory Access Control, <acronym>MAC</acronym>).  Инфраструктура
      позволяет загружать новые модули контроля доступа,
      реализуя новые политики безопасности.  Некоторые из них предоставляют
      защиту ключевых подсистем, защищая определенный сервис, в то время
      как другие предоставляют исчерпывающую систему безопасности с метками
      на всех субъектах и объектах.  Контроль называется принудительным,
      поскольку применение контроля производится администраторами и
      системой, и не зависит от решения пользователей, как это происходит
      при обычном контроле доступа (Discretionary Access Control,
      <acronym>DAC</acronym>, стандартные файловые и System V IPC
      права в &os;).</para>

    <para>Вся эта глава фокусируется на инфраструктуре
      принудительного контроля доступа и настройке
      подключаемых модулей, реализующих различные политики
      безопасности.</para>

    <para>После прочтения этой главы вы узнаете:</para>

    <itemizedlist>
      <listitem>
	<para>Какие модули <acronym>MAC</acronym> включены в настоящее
	  время в &os;, какие политики с ними связаны.</para>
      </listitem>

      <listitem>
	<para>Что способны реализовать политики <acronym>MAC</acronym>,
	  различие между политиками с метками (label) и без
	  меток.</para>
      </listitem>

      <listitem>
	<para>Как эффективно настроить систему для использования
	  инфраструктуры <acronym>MAC</acronym>.</para>
      </listitem>

      <listitem>
	<para>Как настроить различные политики, используемые модулями
	  <acronym>MAC</acronym>.</para>
      </listitem>

      <listitem>
	<para>Как реализовать более защищенную среду, используя инфраструктуру
	  <acronym>MAC</acronym> и приведенные примеры.</para>
      </listitem>

      <listitem>
	<para>Как протестировать настройку <acronym>MAC</acronym>,
	  чтобы убедиться, что инфраструктура была реализована правильно.</para>
      </listitem>
    </itemizedlist>

    <para>Перед прочтением этой главы вам потребуется:</para>

    <itemizedlist>
      <listitem>
	<para>Понимание основ &unix; и &os;
	  (<xref linkend="basics">).</para>
      </listitem>

      <listitem>
	<para>Ознакомиться с основами
	  настройки/компилирования ядра
	  (<xref linkend="kernelconfig">).</para>
      </listitem>

      <listitem>
	<para>Иметь некоторые понятия о безопасности и как она
	  относится к &os; (<xref linkend="security">).</para>
      </listitem>
    </itemizedlist>

    <warning>
      <para>Неправильное использование информации этой главы
	может вызвать потерю доступа к системе, проблемы
	у пользователей, или невозможность запуска &xfree86;.
	Что более важно, <acronym>MAC</acronym>
	не должен восприниматься как полная защита системы.
	Инфраструктура <acronym>MAC</acronym> лишь усиливает
	имеющуюся систему безопасности:
	без применения методов защиты и регулярных проверок,
	система никогда не станет полностью защищенной.</para>

      <para>Необходимо также учесть, что примеры, приведенные в этой главе,
	это всего лишь примеры.  Не рекомендуется дублирование этих
	настроек для реальных задач.  Реализация политик безопасности требует
	вдумчивого планирования.  Тот, кто не понял полностью как все
	это на самом деле работает, может столкнуться с необходимостью
	повторной полной перенастройки системы безопасности для многих
	файлов и каталогов.</para>
    </warning>

    <sect2>
      <title>Что не будет затронуто</title>

      <para>В этой главе охвачен широкий спектр вопросов безопасности,
	относящихся к инфраструктуре <acronym>MAC</acronym>.  однако
	разработка политик <acronym>MAC</acronym> не
	будет затронута.  Несколько модулей, включенных в инфраструктуру
	<acronym>MAC</acronym>, имеют особые характеристики, которые
	предназначены для тестирования и разработки новых модулей.
	Это относится к модулям/политикам &man.mac.test.4;,
	&man.mac.stub.4; и &man.mac.none.4;.
	За дальнейшей информацией по этим модулям и различным
	предоставляемым ими механизмам, обратитесь к соответствующим
	страницам справочника.</para>
    </sect2>
  </sect1>

  <sect1 id="mac-inline-glossary">
    <title>Ключевые термины этой главы</title>

    <para>Перед чтением этой главы необходимо ознакомиться с некоторыми
      ключевыми терминами.  Это возможно разрешит возникающие вопросы
      и предотвратит перегрузку материала новыми терминами и
      информацией.</para>

    <itemizedlist>
      <listitem>
	<para><emphasis>отдел</emphasis> (compartment): Отдел это набор
	  программ и данных, которые необходимо отделить, и где
	  пользователи получают явный доступ к отдельным
	  компонентам системы.  Отдел представляет группирование, например
	  рабочую группу, департамент, проект или тему.  С использованием
	  отделов возможна реализация политики с явно определенным
	  доступом.</para>
      </listitem>

      <listitem>
	<para><emphasis>целостность</emphasis> (integrity): Целостность, как
	  ключевая концепция, это уровень доверия, который может быть
	  присвоен данным.  Поскольку целостность данных повышается,
	  это дает возможность доверять данным.</para>
      </listitem>

      <listitem>
	<para><emphasis>метка</emphasis> (label): Метка является инструментом
	  безопасности, она может быть применена к файлам, каталогам и другим
	  сущностям системы.  Ее можно представить как штамп
	  конфиденциальности; метка, помещенная на файл, описывает уровень
	  секретности данного файла и разрешит доступ только файлам,
	  пользователям, ресурсам и т.д. с теми же или меньшими установками
	  безопасности.  Некоторые из политик могут обрабатывать метки
	  различными способами; это будет обсуждаться в разделе политик
	  ниже.</para>
      </listitem>

      <listitem>
	<para><emphasis>multilabel</emphasis> (множественные метки):
	  свойство <option>multilabel</option>
	  это параметр файловой системы, который может быть установлен
	  в однопользовательском режиме с помощью утилиты
	  &man.tunefs.8;, во время загрузки через файл &man.fstab.5;,
	  или при создании новой файловой системы.  Этот параметр
	  позволяет администратору помещать различные метки
	  <acronym>MAC</acronym> на различные объекты.
	  разрешает помещение множественных <acronym>MAC</acronym> меток
	  на файлы и каталоги файловой системы.  Этот параметр
	  применим только к политикам с метками.</para>
      </listitem>

      <listitem>
	<para><emphasis>объект</emphasis> (object): Объект или
	  системный объект это сущность, через которую информация
	  проходит к <emphasis>субъекту</emphasis>.  Это могут быть
	  каталоги, файлы, поля, экраны, клавиатуры, память,
	  магнитные накопители, принтеры или любые другие устройства
	  хранения/перемещения данных.  В сущности это контейнер данных
	  или ресурс системы; доступ к <emphasis>объекту</emphasis>
	  фактически означает доступ к данным.</para>
      </listitem>

      <listitem>
	<para><emphasis>политика</emphasis> (policy): Набор правил,
	  определяющих как достичь объекта.  <emphasis>Политика</emphasis>
	  обычно документирует обращение с определенными элементами.
	  В этой главе <emphasis>политика</emphasis> будет означать
	  <emphasis>политику безопасности</emphasis>; т.е.
	  коллекцию правил, которые будут контролировать поток данных
	  и определять кто будет иметь доступ к этим данным.</para>
	  <!-- translation: data and information -> данные -->
      </listitem>

      <listitem>
	<para><emphasis>чувствительность</emphasis> (sensitivity):
	  Обычно используется при обсуждении <acronym>MLS</acronym>.
	  Уровень чувствительности это термин, используемый для описания
	  того, насколько важны или секретны данные.  Увеличение
	  уровня чувствительности означает важность данных.</para>
      </listitem>

      <listitem>
	<para><emphasis>одиночная метка</emphasis> (single label): означает,
	  что вся файловая система использует одну метку для
	  определения доступа всего потока данных.  Когда файловая система
	  использует эту установку, что происходит всегда, если не
	  установлен параметр <option>multilabel</option>,  ко всем
	  файлам будет применяться одна и та же установка метки.</para>
      </listitem>

      <listitem>
	<para><emphasis>субъект</emphasis> (subject): субъект это
	  любая активная сущность, вызывающая перемещение информации
	  между <emphasis>объектами</emphasis>; т.е. пользователь,
	  пользовательский обработчик, системный процесс и т.д.
	  В &os; это почти всегда поток, работающий в процессе или
	  представляющий пользователя.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="mac-initial">
    <title>Описание MAC</title>

    <para>Усвоив все эти термины, рассмотрим как <acronym>MAC</acronym>
      повышает безопасность системы в целом.  Различные политики,
      предоставляемые инфраструктурой <acronym>MAC</acronym>,
      могут быть использованы для защиты сети и файловых систем,
      блокирования доступа пользователей к определенным портам и
      сокетам, и так далее.  Возможно, наилучшее использование
      политик это сочетание их вместе путем загрузки нескольких модулей
      одновременно, для создания многослойной защищенной среды.  В
      многослойной среде безопасности несколько политик обеспечивают
      контролируемость защиты.  Это отличается от усиления защиты,
      когда обычно усиливаются элементы системы, используемой в
      определенных целях.  Единственным недостатком является
      дополнительная административная нагрузка в случае множественных
      меток файловой системы, установки сетевого доступа по пользователям,
      и т.д.</para>

    <para>Эти недостатки минимальны по сравнению с длительным эффектом
      функционирования инфраструктуры; например, возможность выбора
      политик, необходимых для определенных конфигураций, уменьшает
      потерю производительности.  Возможность удаления поддержки не
      используемых политик может увеличить общую производительность
      системы, а также дает гибкость выбора.  Хорошая реализация
      удовлетворит общие требования безопасности и будет эффективно
      использовать различные политики, предоставляемые инфраструктурой.</para>

    <para>Система, использующая возможности <acronym>MAC</acronym>,
      должна как минимум гарантировать, что пользователю не разрешается
      самостоятельно изменять атрибуты безопасности; все утилиты
      пользователя, программы и скрипты должны работать с ограничениями
      доступа, налагаемыми выбранной политикой; весь контроль правил
      доступа <acronym>MAC</acronym> находится в руках системного
      администратора.</para>

    <para>Право выбора правильных политик безопасности принадлежит только
      системному администратору.  В некоторых случаях может потребоваться
      ограничение доступа через сеть; для этого могут пригодиться
      &man.mac.portacl.4;, &man.mac.ifoff.4; и даже &man.mac.biba.4;.
      В других случаях может быть необходима строгая конфиденциальность
      объектов в файловой системе.
      Для этого существуют политики &man.mac.bsdextended.4; и
      &man.mac.mls.4;.</para>

    <para>Выбор политики может быть сделан на основе конфигурации сети.
      Возможно только определенным пользователям можно разрешить доступ
      через &man.ssh.1; к сети или интернет.  В таких ситуациях подойдет
      политика &man.mac.portacl.4;.  Но что необходимо сделать для файловых
      систем?  Должен ли доступ к определенным каталогам быть запрещен
      для других групп или определенных пользователей?  Или мы должны
      ограничить доступ пользователей или утилит к определенным файлам
      путем классификации определенных объектов?</para>

    <para>В случае файловой системы, доступ может считаться конфиденциальным
      для отдельных пользователей, но не для всех.  Например, большая
      команда разработчиков может быть разбита на небольшие группы.
      Разработчикам проекта A может быть не разрешен доступ к объектам,
      написанным разработчиками из проекта B.  Хотя им может понадобиться
      доступ к объектам, созданным разработчиками проекта C;
      это реально встречающаяся ситуация.  С помощью различных политик,
      предоставляемых инфраструктурой <acronym>MAC</acronym>, пользователи
      могут быть разделены на эти три группы и затем получить доступ
      к соответствующим областям без опасности утечки информации.</para>

    <para>Таким образом, каждая политика имеет уникальный способ
      взаимодействия с общей безопасностью системы.
      Выбор политики должен быть основан на
      хорошо продуманной политике безопасности.  Во многих случаях политика
      должна быть полностью пересмотрена и реализована заново для всей
      системы.  Понимание различных политик, предоставляемых инфраструктурой
      <acronym>MAC</acronym>, поможет администраторам выбрать лучшую политику
      в своей ситуации.</para>

    <para>Стандартное ядро &os; не включает параметр <acronym>MAC</acronym>;
      необходимо добавить следующий параметр ядра перед тем, как
      пробовать какие-либо из примеров или применять информацию этой
      главы:</para>

    <programlisting>options	MAC</programlisting>

    <para>Затем необходимо пересобрать и переустановить ядро.</para>

    <caution>
      <para>Хотя различные страницы справочника для модулей
	<acronym>MAC</acronym> сообщают, что они могут быть встроены в ядро,
	возможна блокировка доступа системы к сети и другие побочные эффекты.
	Включение <acronym>MAC</acronym> очень похоже на включение
	брандмауэра, но необходимо быть внимательным, чтобы полностью
	не заблокировать систему.  Необходимо предусмотреть возможность
	возврата к предыдущей конфигурации, а реализация
	<acronym>MAC</acronym> удаленно должна производиться с особой
	осторожностью.</para>
    </caution>
  </sect1>

  <sect1 id="mac-understandlabel">
    <title>Метки MAC</title>

    <para>Метка <acronym>MAC</acronym> это атрибут безопасности,
      который может быть применен к субъектам
      и объектам всей системы.</para>

    <para>При установке метки пользователь должен в точности понимать,
      что именно она делает.  Атрибуты, доступные для объекта,
      зависят от загруженной политики, а политики интерпретируют
      свои атрибуты совершенно различным образом.  Результатом
      недостаточного понимания настроек может стать их неправильная
      реализация, что может привести к неожиданному, и возможно
      нежелательному поведению системы.</para>

    <para>Метка безопасности на объекте используется политикой
      для определения правил доступа.  Для некоторых политик метка
      сама по себе содержит всю необходимую для этого информацию,
      в других моделях метки могут обрабатываться как часть
      большого набора правил, и т.д.</para>

    <para>Например, установка метки в <literal>biba/low</literal>
      на файле присвоит этому файлу метку, обрабатываемую политикой
      Biba со значением <quote>low</quote>.</para>

    <para>Несколько политик, поддерживающих метки в &os;,
      предоставляют три определенные предустановленные метки.
      Это низкая, высокая и равная метки.  Хотя они устанавливают контроль
      различными способами для каждой политики, вы можете быть уверены,
      что низкая метка задаст минимальные установки, равная метка
      означает отмену или недействительность, а высокая метка установит
      максимально возможные настройки в политиках Biba и
      <acronym>MLS</acronym>.</para>

    <para>При применении в файловой системе одиночной метки, только одна
      метка может быть использована для объектов.  Это вызовет установку
      одних и тех же прав доступа для всей системы, и во многих случаях
      это все, что необходимо.  Тем не менее, существует несколько ситуаций,
      в которых на объекты и субъекты файловой системы могут быть установлены
      множественные метки.  В этих ситуациях необходимо с помощью
      &man.tunefs.8; установить параметр <option>multilabel</option>.</para>

    <para>В случае Biba и <acronym>MLS</acronym> может быть установлена
      числовая метка
      для указания точного уровня иерархического контроля.  Этот числовой
      уровень используется для разделения или сортировки информации
      по различным группам классификации, разрешающей доступ только к
      этой группе или группе с более высоким уровнем.</para>

    <para>В большинстве случаев системный администратор использует только
      одну метку на всю файловую систему.</para>

    <para><emphasis>Постойте, но это же похоже на <acronym>DAC</acronym>!
      Я думал, что <acronym>MAC</acronym> дает контроль только
      администратору.</emphasis>  Это утверждение все еще верно,
      только <username>root</username> контролирует и настраивает
      политики, так что пользователи помещаются в соответствующие
      категории/уровни доступа.  Многие политики могут ограничить также
      и пользователя <username>root</username>.
      Базовый контроль над объектами затем
      передается группе, но пользователь <username>root</username>
      может отменить или изменить эти настройки в любое время.
      Данная иерархическая <!-- /clearance --> модель соответствует
      таким политикам как Biba и <acronym>MLS</acronym>.</para>

    <sect2>
      <title>Настройка меток</title>

      <para>Практически все действия по настройке политики с метками
	могут быть выполнены с использованием утилит базовой системы.
	Эти команды обеспечивают простой интерфейс для настройки
	объектов или субъектов, или для изменения и проверки
	настроек.</para>

      <para>Все настройки могут быть выполнены с использованием утилит
	&man.setfmac.8; и &man.setpmac.8;.  Команда
	<command>setfmac</command> используется для установки меток
	<acronym>MAC</acronym> на системные объекты, а команда
	<command>setpmac</command> используется для установки меток на
	системные субъекты.  Выполните:</para>

      <screen>&prompt.root; <userinput>setfmac biba/high test</userinput></screen>

      <para>Если не произойдет ошибок, будет возвращено приглашение командной
	строки, как и после команд &man.chmod.1; и &man.chown.8;.
	В некоторых случаях может появиться ошибка
	<errorname>Permission denied</errorname>, и она обычно появляется при
	установке или изменении метки на объект с ограничениями.
	<footnote><para>Есть и другие ситуации, в которых могут возникать
	различные ошибки.  Например, файл может не находиться во владении
	пользователя, пытающегося изменить метку на объекте, объект может
	не существовать или существовать только для чтения.  Политика может
	не позволить процессу изменить метку на файл, возможно в связи со
	свойствами файла, процесса, или нового значения метки.  Например:
	пользователь с низким уровнем доверия пытается изменить метку на
	файле с высоким уровнем доверия.  Или пользователь с низким уровнем
	доверия пытается изменить метку файла с низким уровнем доверия на
	метку высокого уровня.</para></footnote>
	Системный администратор для обхода этой проблемы может использовать
	следующие команды:</para>

      <screen>&prompt.root; <userinput>setfmac biba/high test</userinput>
<errorname>Permission denied</errorname>
&prompt.root; <userinput>setpmac biba/low setfmac biba/high test</userinput>
&prompt.root; <userinput>getfmac test</userinput>
test: biba/high</screen>

      <para>Как видно из примера выше, команда <command>setpmac</command>
	может быть
	использована для изменения установок политики путем присвоения
	иной метки вызывающему процессу.  Утилита <command>getpmac</command>
	обычно используется с существующим на данный момент процессом,
	таким как <application>sendmail</application>, хотя она принимает
	PID вместо команды, ее действие аналогично.  Если пользователи
	попытаются манипулировать файлами, к которым у них нет доступа
	в соответствии с правилами загруженных политик,
	функцией <function>mac_set_link</function> будет
	выдано сообщение об ошибке <errorname>Operation not
	permitted</errorname>.</para>

      <sect3>
	<title>Пользователи и установки меток</title>

	<para>Пользователям необходимо иметь метки, чтобы их файлы и
	  процессы могли правильно взаимодействовать с определенной
	  в системе политикой безопасности.  Это настраивается
	  через файл <filename>login.conf</filename> путем использования
	  классов.  Каждая политика, использующая метки, реализует установку
	  класса пользователя.</para>

	<para>Пример записи, содержащей все политики, приведенные
	  ниже:</para>

	<programlisting>default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/share/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac10[2]:</programlisting>

	<para>Параметр <literal>label</literal> используется для установки
	  метки <acronym>MAC</acronym> по умолчанию для класса пользователя.
	  Пользователи не смогут изменять это значение, поэтому его
	  можно признать не опциональным.  В реальной ситуации администратору
	  никогда не потребуется включать каждую политику.
	  Рекомендуется прочесть главу полностью перед реализацией любой
	  из этих настроек.</para>

	<note>
	  <para>Пользователи могут изменить свою метку после входа;
	    однако политика накладывает ограничение на это изменение.
	    В примере выше политике Biba указано, что минимальная
	    целостность процесса 5, максимальная 15, а эффективная
	    целостность по умолчанию 10.  Процесс будет работать на
	    уровне 10, пока метка не будет изменена, например если
	    пользователь использует команду setpmac, которую Biba
	    ограничит диапазоном, установленным при входе.</para>
	</note>

	<para>Во всех случаях после изменения
	  <filename>login.conf</filename>, база данных
	  <quote>login class capability</quote> должна быть пересобрана
	  с использованием команды <command>cap_mkdb</command>
	  и это будет отражено в каждом последующем примере главы.</para>

	<para>Полезно отметить, что количество пользователей, которым
	  требуются различные классы, во многих сетях может быть велико.
	  Необходимо тщательное планирование, поскольку управление такой
	  сетью может серьезно усложниться.</para>

	<para>В будущих версиях &os; появится новый способ связывания
	  пользователей с метками; однако, он будет доступен только через
	  некоторое время после выхода &os;&nbsp;5.3.</para>
      </sect3>

      <sect3>
	<title>Сетевые интерфейсы и установка меток</title>

	<para>Метки также могут быть установлены на сетевые интерфейсы,
	  для контроля потока данных в сети. Во всех случаях они
	  функционируют аналогично тому, как политики по отношению к
	  объектам.  Пользователи с высокими установками, например,
	  <literal>biba</literal>, не смогут получить доступ к сетевым
	  интерфейсам с низкими установками.</para>

	<para>Для установки <acronym>MAC</acronym> меток на сетевых
	  интерфейсах параметр <option>maclabel</option> может быть передан
	  <command>ifconfig</command>.  Например:</para>

	<screen>&prompt.root; <userinput>ifconfig bge0 maclabel biba/equal</userinput></screen>

	<para>установит <acronym>MAC</acronym> метку
	  <literal>biba/equal</literal> на интерфейс &man.bge.4;.
	  При использовании метки, подобной
	  <literal>biba/high(low-high)</literal> вся метка должна быть
	  взята в кавычки, иначе будет выдано сообщение об ошибке.</para>

	<para>Каждая политика, использующая метки, снабжена переменной
	  <command>sysctl</command>, которая может быть использована для
	  отключения <acronym>MAC</acronym> меток на сетевых интерфейсах.
	  Установка метки в <option>equal</option> будет иметь подобный
	  эффект.  Просмотрите вывод команды <command>sysctl</command>,
	  страницы справочника для политик, или дальнейшую информацию из
	  этой главы по этим переменным.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Одиночные или множественные метки?</title>

      <para>По умолчанию система будет использовать параметр
	<option>singlelabel</option>.  Но что это означает для
	администратора?  Существуют несколько различий между политиками,
	каждая из которых правильна сама по себе, но имеет свои доводы
	за и против относительно гибкости модели безопасности
	системы.</para>

      <para><option>singlelabel</option> (одиночная метка) разрешает
	использование только одной метки, например
	<literal>biba/high</literal>, для каждого объекта или субъекта.
	Ее преимущество в меньшей нагрузке на системного администратора,
	а недостаток в малой гибкости политик, поддерживающих метки.
	Многие администраторы в своих политиках безопасности могут
	предпочесть использование параметра
	<option>multilabel</option>.</para>

      <para>С параметром <option>multilabel</option> каждый субъект или
	объект может иметь собственную метку <acronym>MAC</acronym>,
	в то время как со стандартным параметром <option>singlelabel</option>
	возможна только одна метка на весь раздел.
	Параметры <option>multilabel</option> и <option>singlelabel</option>
	требуются только для политик, реализующих метки, включая
	Biba, Lomac, <acronym>MLS</acronym> и
	<acronym>SEBSD</acronym>.</para>

      <para>Во многих случаях <option>multilabel</option> может вообще не
	потребоваться.  Предположим следующую ситуацию и модель
	безопасности:</para>

      <itemizedlist>
	<listitem>
	  <para>&os; веб-сервер, использующий инфраструктуру
	    <acronym>MAC</acronym> и набор различных политик.</para>
	</listitem>

	<listitem>
	  <para>Этому компьютеру потребуется лишь одна метка,
	    <literal>biba/high</literal>, для всей системы.
	    Файловой системе не нужен параметр <option>multilabel</option>,
	    поскольку по умолчанию работает одиночная метка.</para>
	</listitem>

	<listitem>
	  <para>Но поскольку этот компьютер будет веб сервером, процесс
	    веб сервера должен быть запущен с <literal>biba/low</literal>
	    для предотвращения записи.  Политика Biba и то, как она
	    работает, будет обсуждаться позже, поэтому предыдущий комментарий
	    сложно интерпретировать; просто продолжайте чтение.
	    Сервер может использовать дисковый раздел с установленной
	    меткой <literal>biba/low</literal> для большинства, если
	    не для всех своих операций.  В этом примере отсутствуют многие
	    детали, такие как ограничения на данные, конфигурация системы
	    и установки пользователей; однако, это лишь предварительный
	    пример.</para>
	</listitem>
      </itemizedlist>

      <para>Если используется любая из политик, не поддерживающих метки,
	параметр <option>multilabel</option> не требуется.  Сюда включаются
	политики <literal>seeotheruids</literal>, <literal>portacl</literal>
	и <literal>partition</literal>.</para>

      <para>Необходимо также отметить, что использование параметра
	<option>multilabel</option> на разделе и установление модели
	безопасности, основанной на функциональности
	<option>multilabel</option>, может повлечь за собой
	множество дополнительной административной работы, поскольку всему в
	файловой системе должны быть присвоены метки.  Это включает каталоги,
	файлы, и даже файлы устройств.</para>

      <para>Следующая команда установит параметр <option>multilabel</option>
	на файловых системах.  Это может быть сделано только в
	однопользовательском режиме:</para>

      <screen>&prompt.root; <userinput>tunefs -l enable /</userinput></screen>

      <para>Это не требуется для файловой системы подкачки.</para>

      <note>
	<para>Некоторые пользователи сталкиваются с проблемами при
	  установке флага <option>multilabel</option> на корневой раздел.
	  В данном случае обратитесь к
	  <xref linkend="mac-troubleshoot">.</para>
      </note>
    </sect2>

    <sect2>
      <title>Настройка MAC переменными sysctl</title>

      <para>Независимо от загрузки модулей, существует несколько частей
	<acronym>MAC</acronym>, которые могут быть настроены с
	использованием интерфейса <command>sysctl</command>.  Эти
	переменные описаны ниже и во всех случаях значение 1
	означает включение, а 0 &mdash; отключение:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>security.mac.enforce_fs</literal> по умолчанию
	    установлена в 1 и включает политики
	    <acronym>MAC</acronym> на файловых системах.</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_kld</literal> по умолчанию
	    1 и включает линкование политик <acronym>MAC</acronym> в
	    ядре (см. &man.kld.4;).</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_network</literal> по умолчанию
	    1 и включает сетевые политики <acronym>MAC</acronym>.</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_pipe</literal> по умолчанию
	    1 и включает политики <acronym>MAC</acronym> для каналов
	    (pipe).</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_process</literal> по умолчанию
	    1 и включает политики <acronym>MAC</acronym> для процессов,
	    использующих средства межпроцессного взаимодействия.</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_socket</literal> по умолчанию
	    1 и включает политики <acronym>MAC</acronym> на сокетах
	    (см. страницу справочника &man.socket.2;).</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_system</literal> по умолчанию
            1 и включает политики <acronym>MAC</acronym> для действий системы,
	    таких как учет (accounting) и перезагрузка.</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_vm</literal> по умолчанию
            1 и включает политики <acronym>MAC</acronym> для системы
	    виртуальной памяти.</para>
	</listitem>
      </itemizedlist>

      <note>
	<para>Каждая политика <acronym>MAC</acronym> поддерживает
	  переменные <command>sysctl</command>.  Они обычно попадают в дерево
	  <literal>security.mac.&lt;policyname&gt;</literal>.
	  Для просмотра всех переменных <acronym>MAC</acronym>,
	  используйте следующую команду:</para>

	<screen>&prompt.root; <userinput>sysctl -da | grep mac</userinput></screen>
      </note>

      <para>Это должно быть интерпретировано так, что все основные
	политики <acronym>MAC</acronym> включены по умолчанию.
	Если модули встроены в ядро, система будет заблокирована, и скорее
	всего не сможет связаться с локальной сетью или с интернет, и т.д.
	Поэтому встраивание модулей в ядро не рекомендуется.  Не потому,
	что это ограничит возможность отключения командой
	<command>sysctl</command>, а потому, что включение политик в
	виде модулей позволит администратору переключать политики системы
	без необходимости пересборки и переустановки новой системы.</para>
    </sect2>
  </sect1>

  <sect1 id="mac-modules">
    <title>Настройка модулей</title>

    <para>Каждый модуль, включенный в инфраструктуру <acronym>MAC</acronym>,
      может быть или встроен в ядро, как упоминалось выше, или загружен
      в виде модуля ядра.  Рекомендуется добавление имени модуля в
      файл <filename>/boot/loader.conf</filename>, этот модуль будет
      активирован в самом начале загрузки.</para>

    <para>В последующих разделах будут обсуждаться различные модули
      <acronym>MAC</acronym> и их возможности.  Реализация этих
      возможностей в определенных ситуациях также будет обсуждаться
      в этой главе.  Некоторые модули поддерживают использование
      меток, которые контролируют доступ путем применения правил
      вида <quote>это разрешено, а это нет</quote>.  Настройка меток может
      контролировать доступ к файлам, сетевым коммуникациям и т.д.
      В предыдущем разделе было показано как флаг <option>multilabel</option>
      может быть установлен на файловые системы для включения контроля
      доступа по файлам или по разделам.</para>

    <para>Конфигурация с одной меткой не допускает применение нескольких
      меток в системе, поэтому параметр <command>tunefs</command>
      называется <option>multilabel</option>.</para>

    <sect2 id="mac-seeotheruids">
      <title>Модуль MAC seeotheruids</title>

      <indexterm>
	<primary>MAC See Other UIDs Policy</primary>
      </indexterm>
      <para>Имя модуля: <filename>mac_seeotheruids.ko</filename></para>

      <para>Строка в конфигурации ядра:
	<literal>options MAC_SEEOTHERUIDS</literal></para>

      <para>Параметр загрузки:
	<literal>mac_seeotheruids_load="YES"</literal></para>

      <para>Модуль &man.mac.seeotheruids.4; копирует и расширяет
	переменные <command>sysctl</command>
	<literal>security.bsd.see_other_uids</literal> и
	<literal>security.bsd.see_other_gids</literal>.  Он
	не требует установки меток и может прозрачно работать с
	другими модулями.</para>

      <para>После загрузки модуля, для управления им могут быть
	использованы следующие переменные <command>sysctl</command>:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>security.mac.seeotheruids.enabled</literal>
	    включит модуль с настройками по умолчанию.  Эти настройки
	    запрещают пользователям просмотр процессов и сокетов,
	    принадлежащих другим пользователям.</para>
	</listitem>

	<listitem>
	  <para>
	    <literal>security.mac.seeotheruids.specificgid_enabled</literal>
	    позволит исключить определенные группы из этой политики.
	    Для исключения определенной группы, используйте переменную
	    <command>sysctl</command>
	    <literal>security.mac.seeotheruids.specificgid=<replaceable>XXX</replaceable></literal>.
	    В примере выше необходимо заменить <replaceable>XXX</replaceable>
	    на числовой ID группы.</para>
	</listitem>

	<listitem>
	  <para>
	    <literal>security.mac.seeotheruids.primarygroup_enabled</literal>
	    используется для исключения определенной основной группы
	    из этой политики.  При использовании этой переменной
	    <literal>security.mac.seeotheruids.specificgid_enabled</literal>
	    может быть не установлена.</para>
	</listitem>
      </itemizedlist>

      <para>Необходимо отметить, что пользователь <username>root</username>
	не является исключением из этой политики.  Это одно из самых
	существенных различий между <acronym>MAC</acronym> версией
	и обычными переменными, существующими по умолчанию:
	<literal>security.bsd.seeotheruids</literal>.</para>
    </sect2>
  </sect1>

  <sect1 id="mac-bsdextended">
    <title>Модуль MAC bsdextended</title>

    <indexterm>
    <primary>MAC</primary>
      <secondary>File System Firewall Policy</secondary>
    </indexterm>
    <para>Имя модуля: <filename>mac_bsdextended.ko</filename></para>

    <para>Строка конфигурации ядра:
      <literal>options MAC_BSDEXTENDED</literal></para>

    <para>Параметр загрузки:
      <literal>mac_bsdextended_load="YES"</literal></para>

    <para>Модуль &man.mac.bsdextended.4; включает брандмауэр файловой
      системы.  Политика этого модуля является расширением стандартной
      модели разрешений файловой системы, позволяя администратору
      создавать набор правил для защиты файлов, утилит и каталогов
      иерархии файловой системы в стиле брандмауэра.</para>

    <para>Политика может быть создана с помощью утилиты, &man.ugidfw.8;,
      синтаксис которой похож на синтаксис &man.ipfw.8;.  Другие
      инструменты могут быть написаны с использованием функций библиотеки
      &man.libugidfw.3;.</para>

    <para>При работе с этим модулем необходимо соблюдать особую
      осторожность; некорректное его использование может заблокировать
      доступ к отдельным частям файловой системы.</para>

    <sect2>
      <title>Примеры</title>

      <para>После загрузки модуля &man.mac.bsdextended.4; для просмотра
	текущей настройки правил может быть использована следующая
	команда:</para>

      <screen>&prompt.root; <userinput>ugidfw list</userinput>
0 slots, 0 rules</screen>

      <para>Как и можно было ожидать, правила не определены.  Это
	означает, что доступ полностью открыт.  Для создания правила,
	которое заблокирует доступ всех пользователей, но не повлияет
	на <username>root</username>, просто запустите следующую
	команду:</para>

      <screen>&prompt.root; <userinput>ugidfw add subject not uid root new object not uid root mode n</userinput></screen>

      <note>
	<para>В релизах &os; до 5.3, параметр <parameter>add</parameter>
	  не существует.  Вместо него необходимо использовать
	  <parameter>set</parameter>.  Пример дан ниже.</para></note>

      <para>Это очень плохая идея, поскольку такое правило запретит
	пользователям использовать даже самые простые команды, такие
	как <command>ls</command>.  Более патриотический список правил
	может быть таким:</para>

      <screen>&prompt.root; <userinput>ugidfw set 2 subject uid <replaceable>user1</replaceable> object uid <replaceable>user2</replaceable> mode n</userinput>
&prompt.root; <userinput>ugidfw set 3 subject uid <replaceable>user1</replaceable> object gid <replaceable>user2</replaceable> mode n</userinput></screen>

      <para>Эти команды запретят весь и любой доступ пользователя
	<username>user1</username>, включая просмотр подкаталогов, к
	домашнему каталогу пользователя
	<username><replaceable>user2</replaceable></username>.</para>

      <para>Вместо <username>user1</username> может быть задано
	<option>not uid <replaceable>user2</replaceable></option>.
	Это включит те ограничения,
	о которых говорилось выше, для всех пользователей кроме
	одного.</para>

      <note>
	<para>На пользователя <username>root</username> эти изменения не
	  повлияют.</para>
      </note>

      <para>Материал выше должен дать общую идею как модуль
	&man.mac.bsdextended.4; может быть использован в качестве средства
	защиты файловой системы.  За дальнейшей информацией обращайтесь
	к страницам справочника &man.mac.bsdextended.4; и
	&man.ugidfw.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="mac-ifoff">
    <title>Модуль MAC ifoff</title>

    <indexterm>
      <primary>MAC Interface Silencing Policy</primary>
    </indexterm>
    <para>Имя модуля: <filename>mac_ifoff.ko</filename></para>

    <para>Строка конфигурации ядра:
      <literal>options MAC_IFOFF</literal></para>

    <para>Параметр загрузки: <literal>mac_ifoff_load="YES"</literal></para>

    <para>Модуль &man.mac.ifoff.4; существует только для отключения
      сетевых интерфейсов в работающей системе и удержания их от
      отправки пакетов во время начальной загрузки.  Это не требует
      установления в системе каких-либо меток, нет и зависимости от
      других модулей <acronym>MAC</acronym>.</para>

    <para>Большая часть управления может быть выполнена через
      переменные <command>sysctl</command>.</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.ifoff.lo_enabled</literal>
	  включает/выключает весь трафик на loopback (&man.lo.4;)
	  интерфейсе.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.ifoff.bpfrecv_enabled</literal>
	  включает/выключает весь трафик на интерфейсе Berkeley Packet
	  Filter (&man.bpf.4;).</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.ifoff.other_enabled</literal>
	  включает/выключает весь трафик на всех других интерфейсах.</para>
      </listitem>
    </itemizedlist>

    <para>Одно из наиболее частых использований &man.mac.ifoff.4; это
      сетевой мониторинг в среде, где сетевой трафик не должен быть
      разрешен во время загрузки.  Другое предлагаемое применение
      это написание скрипта, использующего
      <filename role="package">security/aide</filename> для автоматического
      блокирования сетевого трафика, если будут обнаружены новые или
      измененные файлы в защищаемых каталогах.</para>
  </sect1>

  <sect1 id="mac-portacl">
    <title>Модуль MAC portacl</title>

    <indexterm>
      <primary>MAC Port Access Control List Policy</primary>
    </indexterm>
    <para>Имя модуля: <filename>mac_portacl.ko</filename></para>

    <para>Строка конфигурации ядра:
      <literal>MAC_PORTACL</literal></para>

    <para>Параметр загрузки: <literal>mac_portacl_load="YES"</literal></para>

    <para>Модуль &man.mac.portacl.4; используется для ограничения привязки
      (binding) к локальным портам <acronym>TCP</acronym> и
      <acronym>UDP</acronym>, используя различные переменные
      <command>sysctl</command>.  По сути &man.mac.portacl.4;
      делает возможной привязку к привилегированным портам, т.е. к портам
      с номерами меньше 1024 для не-<username>root</username>
      пользователей.</para>

    <para>После загрузки этот модуль включит политику <acronym>MAC</acronym>
      на всех сокетах.  Доступны следующие переменные
      <command>sysctl</command>:</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.portacl.enabled</literal>
	  включает/отключает политику целиком.
	  <footnote><para>Вследствие ошибки
	  переменная <command>sysctl</command>
	  <literal>security.mac.portacl.enabled</literal> не будет работать
	  в  &os;&nbsp;5.2.1 или более ранних релизах.</para></footnote></para>
      </listitem>

      <listitem>
	<para><literal>security.mac.portacl.port_high</literal>
	  установит наибольший номер порта, для которого
	  &man.mac.portacl.4; включает защиту.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.portacl.suser_exempt</literal>,
	  если установлена в ненулевое значение, исключает пользователя
	  <username>root</username> из этой политики.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.portacl.rules</literal>
	  задает действующую политику mac_portacl: см. ниже.</para>
      </listitem>
    </itemizedlist>

    <para>Действующая политика <literal>mac_portacl</literal>,
      указанная в <literal>security.mac.portacl.rules</literal>,
      это текстовая строка в форме <literal>rule[,rule,...]</literal>
      с таким количеством правил, которое требуется.  Каждое правило
      задается в формате:
      <literal>idtype:id:protocol:port</literal>.  Параметр
      <parameter>idtype</parameter> может принимать значения
      <literal>uid</literal> или <literal>gid</literal> и используется
      для интерпретации параметра <parameter>id</parameter>,
      в качестве id пользователя или группы соответственно.
      Параметр <parameter>protocol</parameter> используется для
      определения применимости этого правила к протоколу
      <acronym>TCP</acronym> или <acronym>UDP</acronym>, он может
      принимать значения <literal>tcp</literal> или
      <literal>udp</literal>.  Последний параметр,
      <parameter>port</parameter>, задает номер порта, к которому
      разрешается привязка указанного пользователя или группы.</para>

    <note>
      <para>Поскольку набор правил интерпретируется непосредственно
	ядром, для ID пользователя, группы и номера порта могут быть
	использованы только числовые значения.  Т.е. имена пользователей,
	групп и сервисов портов не могут быть использованы.</para>
    </note>

    <para>По умолчанию в &unix;-подобных системах порты с номерами
      менее чем 1024 могут быть использованы только привилегированными
      процессами, т.е. теми, что запущены от <username>root</username>.
      С &man.mac.portacl.4; для разрешения привязки непривилегированных
      процессов к портам с номерами ниже 1024 эти стандартные ограничения
      &unix; должны быть отменены.  Это может быть выполнено путем
      установки переменных &man.sysctl.8;
      <literal>net.inet.ip.portrange.reservedlow</literal> и
      <literal>net.inet.ip.portrange.reservedhigh</literal>
      в ноль.</para>

    <para>Обратитесь к примерам ниже или к странице справочника
      &man.mac.portacl.4; за дальнейшей информацией.</para>

    <sect2>
      <title>Примеры</title>

      <para>Следующие примеры должны осветить обсуждение выше чуть
	лучше:</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.port_high=1023</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.portrange.reservedlow=0 net.inet.ip.portrange.reservedhigh=0</userinput></screen>

      <para>Сначала мы настраиваем &man.mac.portacl.4; для работы со
	стандартными привилегированными портами и отмены обычных
	ограничений &unix; на привязку.</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.suser_exempt=1</userinput></screen>

      <para>Пользователь <username>root</username> должен быть исключен
	из этой политики, для этого переменная
	<literal>security.mac.portacl.suser_exempt</literal>
	установлена в ненулевое значение.  Модуль &man.mac.portacl.4;
	теперь настроен на то поведение &unix;-подобных систем по
	умолчанию.</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.rules=uid:80:tcp:80</userinput></screen>

      <para>Разрешает пользователю с <acronym>UID</acronym> 80 (обычно
	это пользователь <username>www</username>) привязку к порту 80.
	Теперь пользователь <username>www</username> сможет запустить
	веб сервер даже без привилегии <username>root</username>.</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995</userinput></screen>

      <para>Разрешит пользователю с <acronym>UID</acronym>
	1001 привязку к <acronym>TCP</acronym> портам 110
	(<quote>pop3</quote>) и 995 (<quote>pop3s</quote>).
	Это позволит данному пользователю запустить сервер, принимающий
	соединения на портах 110 и 995.</para>
    </sect2>
  </sect1>

  <sect1 id="mac-labelingpolicies">
    <title>Политики MAC, использующие метки</title>

    <para>В следующих нескольких разделах будут обсуждаться политики
      <acronym>MAC</acronym>, использующие метки.</para>

    <para>С этого момента обсуждение будет сфокусировано на возможностях
      &man.mac.biba.4;, &man.mac.lomac.4;,
      &man.mac.partition.4;, и &man.mac.mls.4;.</para>

    <note>
      <para>Это лишь примерные настройки, они не должны использоваться
	непосредственно в реальных задачах.  Цель изложения в том, чтобы
	документировать и показать синтаксис, а также примеры
	реализации и тестирования.</para>
    </note>

    <para>Для правильной работы этих политик необходимо выполнить
      некоторые приготовления.</para>

    <sect2 id="mac-prep">
      <title>Приготовления к использованию политик с метками</title>

      <para>В файл <filename>login.conf</filename> необходимо
	внести следующие изменения:</para>

      <itemizedlist>
	<listitem>
	  <para>Должен быть добавлен класс <literal>insecure</literal>,
	    или другой подобный класс.  Наличие класса
	    <literal>insecure</literal> не обязательно, он приводится
	    здесь в качестве примера; другие конфигурации могут использовать
	    другое имя класса.</para>
	</listitem>

	<listitem>
	  <para>Класс <literal>insecure</literal> должен использовать
	    приведенные ниже настройки и определения.  Некоторые из них
	    могут быть изменены, но строка, определяющая метку по
	    умолчанию, необходима и должна быть оставлена.</para>

	  <programlisting>insecure:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/share/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/low:</programlisting>

	  <para>Перед тем, как переключать пользователей на новый класс,
	    необходимо запустить команду &man.cap.mkdb.1; на
	    &man.login.conf.5;.</para>

	  <para>Пользователю <username>root</username> также необходимо
	    присвоить класс; иначе, почти любой команде, выполняемой
	    от <username>root</username>, потребуется использование
	    <command>setpmac</command>.</para> 
<!-- why?
	  <warning>
	    <para>Rebuilding the <filename>login.conf</filename>
	      database may cause some errors later with the daemon
	      class.  Simply uncommenting the daemon account and
	      rebuilding the database should alleviate these
	      issues.</para>
	  </warning>
-->
	</listitem>

	<listitem>
	  <para>Убедитесь, что все разделы, на которых будут установлены
	    метки <acronym>MAC</acronym>, поддерживают параметр
	    <option>multilabel</option>.  Нам необходимо сделать это,
	    поскольку многие из примеров здесь содержат различные
	    метки в целях тестирования.  Просмотрите вывод команды
	    <command>mount</command> в качестве необходимой
	    предосторожности.</para>
	</listitem>

	<listitem>
	  <para>Переключите всех пользователей, которые будут использовать
	    новые механизмы безопасности, на этот класс.  Информация
	    по этой процедуре находится в &man.pw.8; или
	    &man.vipw.8;.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="mac-partition">
    <title>Модуль MAC partition</title>

    <indexterm>
      <primary>MAC Process Partition Policy</primary>
    </indexterm>
    <para>Имя модуля: <filename>mac_partition.ko</filename></para>

    <para>Строка настройки ядра:
      <literal>options MAC_PARTITION</literal></para>

    <para>Параметр загрузки:
      <literal>mac_partition_load="YES"</literal></para>

    <para>Политика &man.mac.partition.4; распределяет процессы по
      <quote>разделам</quote> на основе их <acronym>MAC</acronym>
      меток.  Это может быть представлено как особый тип
      &man.jail.8;, хотя такое сравнение едва ли подходит.</para>

    <para>Этот модуль должен быть добавлен в &man.loader.conf.5;,
      чтобы политика была загружена и включена при загрузке
      системы.</para>

    <para>Большая часть настройки этой политики выполняется с помощью
      утилиты &man.setpmac.8;, которая будет описана ниже.  Для
      данной политики имеется также следующая переменная
      <command>sysctl</command>:</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.partition.enabled</literal>
	  включит <acronym>MAC</acronym> разделение процессов.</para>
      </listitem>
    </itemizedlist>

    <para>Когда эта политика включена, пользователям разрешено
      просматривать только собственные процессы, но не разрешено
      пользоваться определенными утилитами.  Например, пользователю
      из класса <literal>insecure</literal> выше не будет разрешено
      использование команды <command>top</command>, а также многих
      других команд, которые должны порождать процесс.</para>

    <para>Для присвоения утилитам меток partition используйте
      утилиту <command>setpmac</command>:</para>

    <screen>&prompt.root; <userinput>setpmac partition/13 top</userinput></screen>

    <para>Команда <command>top</command> будет добавлена к метке,
      установленной для пользователей класса <literal>insecure</literal>.
      Обратите внимание, что все процессы, порожденные пользователями
      класса <literal>insecure</literal>, останутся с меткой
      <literal>partition/13</literal>.</para>

    <sect2>
      <title>Примеры</title>

      <para>Следующая команда покажет вашу метку раздела и список
	процессов:</para>

      <screen>&prompt.root; <userinput>ps Zax</userinput></screen>

      <para>Следующей командой можно просмотреть метку раздела
	процессов других пользователей и их запущенные процессы:</para>

      <screen>&prompt.root; <userinput>ps -ZU trhodes</userinput></screen>

      <note>
	<para>Пользователи могут могут увидеть процессы
	  <username>root</username>, если не загружена политика
	  &man.mac.seeotheruids.4;.</para>
      </note>

      <para>Действительно <quote>продвинутая</quote> реализация
	должна отключать все сервисы через
	<filename>/etc/rc.conf</filename> и запускать их через
	скрипт, который установит правильный набор меток.</para>

      <note>
	<para>Следующие политики поддерживают целочисленные установки
	  вместо трех меток по умолчанию.  Эти опции, включая их
	  ограничения, описываются более подробно в страницах
	  справочника модулей.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="mac-mls">
    <title>Модуль многоуровневой безопасности MAC (MLS)</title>

    <indexterm>
      <primary>Политика многоуровневой безопасности MAC</primary>
    </indexterm>
    <para>Имя модуля: <filename>mac_mls.ko</filename></para>

    <para>Строка конфигурации ядра:
      <literal>options MAC_MLS</literal></para>

    <para>Параметр загрузки: <literal>mac_mls_load="YES"</literal></para>

    <para>Политика &man.mac.mls.4; контролирует взаимодействие субъектов
      и объектов системы путем применения строгой политики
      к потоку информации.</para>

    <para>В среде <acronym>MLS</acronym>, для каждого субъекта или объекта
      внутри отдела (compartment) устанавливается <quote>уровень
      допуска</quote>.  Поскольку количество уровней допуска может
      превышать шесть тысяч, для любого системного администратора
      задача настройки каждого субъекта или объекта может быть
      слишком сложной.  К счастью, существуют <quote>постоянные</quote>
      метки, которые уже включены в эту политику.</para>

    <para>Эти метки <literal>mls/low</literal>,
      <literal>mls/equal</literal> и <literal>mls/high</literal>.
      Поскольку эти метки подробно описываются в справочнике,
      здесь мы дадим только краткое описание:</para>

    <itemizedlist>
      <listitem>
	<para>Метка <literal>mls/low</literal> содержит минимальную
	  настройку, что позволяет доминирование над ней всех других
	  объектов.  Все, что помечено с <literal>mls/low</literal>,
	  находится на низком уровне доступа и доступ к более высоким
	  уровням будет запрещен.  Кроме того, эта метка предотвратит
	  запись или передачу информации объектам с более высоким
	  уровнем доступа.</para>
      </listitem>

      <listitem>
	<para>Метка <literal>mls/equal</literal> должна быть помещена
	  на объекты, являющиеся исключением из политики.</para>
      </listitem>

      <listitem>
	<para>Метка <literal>mls/high</literal> это наибольший возможный
	  уровень доступа.  Объекты с этой меткой будут доминировать
	  над всеми другими объектами системы; однако, утечка информации
	  от них к объектам более низкого класса невозможна.</para>
      </listitem>
    </itemizedlist>

    <para><acronym>MLS</acronym> представляет собой:</para>

    <itemizedlist>
      <listitem>
	<para>Иерархические уровни безопасности с набором не
	  иерархических категорий;</para>
      </listitem>

      <listitem>
	<para>Фиксированные правила: нет чтения сверху, нет записи
	  вниз (субъект может иметь доступ на чтение объектов
	  собственного уровня или ниже, но не выше.  Аналогично,
	  субъект может иметь доступ на запись в объекты своего
	  уровня или выше, но не наоборот.);</para>
      </listitem>

      <listitem>
	<para>Секретность (предотвращение неавторизованного раскрытия
	  данных);</para>
      </listitem>

      <listitem>
	<para>Основа для разработки систем, одновременно работающих с
	  данными на нескольких уровнях секретности (без утечки
	  информации).<!--between secret and confidential--></para>
      </listitem>
    </itemizedlist>

    <para>Для настройки специальных сервисов и интерфейсов доступны
      следующие переменные <command>sysctl</command>:</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.mls.enabled</literal> используется
	  для включения/отключения политики <acronym>MLS</acronym>.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.mls.ptys_equal</literal> пометит
	  все устройства &man.pty.4; как <literal>mls/equal</literal>
	  во время создания.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.mls.revocation_enabled</literal>
	  используется для запрета доступа к объектам после того,
	  как их метка изменится в меньшую сторону.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.mls.max_compartments</literal>
	  используется для установки максимального количества
	  уровней отделов на объекты; обычно это максимальное
	  количество отделов, разрешенных в системе.</para>
      </listitem>
    </itemizedlist>

    <para>Для управления метками <acronym>MLS</acronym> существует команда
      &man.setfmac.8;.  Для присвоения метки объекту, выполните
      следующую команду:</para>

    <screen>&prompt.root; <userinput>setfmac mls/5 test</userinput></screen>

    <para>Для получения метки <acronym>MLS</acronym> файла
      <filename>test</filename>, выполните следующую команду:</para>

    <screen>&prompt.root; <userinput>getfmac test</userinput></screen>

    <para>Выше представлен краткий обзор возможностей политики
      <acronym>MLS</acronym>.  Существует метод, связанный с созданием
      основного файла политики в каталоге <filename
      class="directory">/etc</filename>, где будет определена
      необходимая для политики <acronym>MLS</acronym> информация, которая
      будет передана команде <command>setfmac</command>.  Этот метод будет
      описан после рассмотрения всех политик.</para>

    <para>Итоги: объект с низким уровнем доступа не может
      прочесть данные объекта с высоким уровнем доступа.  Базовая политика
      должна устанавливать <literal>mls/high</literal> на всем, что не должно
      быть прочитано, даже если туда необходимо записывать.  На всем, куда
      нельзя писать, должна быть установлена метка
      <literal>mls/low</literal>, даже если это необходимо читать.
      Наконец, на всем остальном установите <literal>mls/equal</literal>.
      Все пользователи, помеченные как <literal>insecure</literal>, должны
      иметь метку <literal>mls/low</literal>.</para>
  </sect1>

  <sect1 id="mac-biba">
    <title>Модуль MAC Biba</title>

    <indexterm>
      <primary>MAC Biba Integrity Policy</primary>
    </indexterm>
    <para>Имя модуля: <filename>mac_biba.ko</filename></para>

    <para>Строка конфигурации ядра: <literal>options MAC_BIBA</literal></para>

    <para>Параметр загрузки: <literal>mac_biba_load="YES"</literal></para>

    <para>Модуль &man.mac.biba.4; загружает <acronym>MAC</acronym>
      политику Biba.  Эта политика работает в основном так же, как и
      <acronym>MLS</acronym>, за исключением того, что правила потока
      информации изменены на противоположные.  Они предназначены для
      предотвращения передачи потока секретной информации вверх, в то
      время как политика <acronym>MLS</acronym> предотвращает передачу
      потока секретной информации вниз; таким образом, большая часть
      этого раздела применима к обеим политикам.</para>

    <para>В среде Biba, каждому субъекту или объекту присваивается
      метка <quote>целостности</quote>.  Эти метки состоят из
      иерархических уровней и не-иерархических компонентов.
      При возрастании уровня объекта или субъекта это повышает
      его целостность.</para>

    <para>Поддерживаемые метки <literal>biba/low</literal>,
      <literal>biba/equal</literal>, и <literal>biba/high</literal>;
      описаны ниже:</para>

    <itemizedlist>
      <listitem>
	<para>Метка <literal>biba/low</literal> обеспечивает наименьшую
	  целостность объекта или субъекта.  Установка ее на объект
	  или субъект заблокирует их доступ к объектам или субъектам,
	  имеющим более высокую метку.  Тем не менее, у них остается
	  доступ на чтение.</para>
      </listitem>

      <listitem>
	<para>Метка <literal>biba/equal</literal> должна помещаться только
	  на объекты, исключающиеся из политики.</para>
      </listitem>

      <listitem>
	<para>Метка <literal>biba/high</literal> разрешит запись в объекты
	  с более низкой меткой, но не разрешит чтение из этих
	  объектов.  Рекомендуется помещать такую метку на объекты,
	  влияющие на целостность всей системы.</para>
      </listitem>
    </itemizedlist>

    <para>Biba представляет собой:</para>

    <itemizedlist>
      <listitem>
	<para>Иерархические уровни целостности с набором не иерархических
	  категорий;</para>
      </listitem>

      <listitem>
	<para>Фиксированные правила: нет записи наверх, нет чтения снизу
	  (обратно <acronym>MLS</acronym>).  Субъект может иметь доступ на
	  запись к объектам своего уровня или ниже, но не выше.  Аналогично,
	  субъект может иметь доступ на чтение к объектам своего уровня
	  или выше, но не ниже;</para>
      </listitem>

      <listitem>
	<para>Целостность (предотвращение неавторизованного изменения
	  данных);</para>
      </listitem>

      <listitem>
	<para>Уровни целостности (вместо уровней секретности
	  MLS).</para>
      </listitem>
    </itemizedlist>

    <para>Для управления политикой Biba могут быть использованы
      следующие переменные <command>sysctl</command>:</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.biba.enabled</literal>
	  может использоваться для включения/выключения политики
	  Biba.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.biba.ptys_equal</literal>
	  может использоваться для отключения политики Biba
	  на устройствах &man.pty.4;.</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.biba.revocation_enabled</literal>
	  включит отмену доступа к объектам, если метка изменена
	  на более высокую, чем у субъекта.</para>
      </listitem>
    </itemizedlist>

    <para>Для выполнения настроек политики Biba на системных
      объектах, применяются команды <command>setfmac</command> и
      <command>getfmac</command>:</para>

    <screen>&prompt.root; <userinput>setfmac biba/low test</userinput>
&prompt.root; <userinput>getfmac test</userinput>
test: biba/low</screen>

    <para>Итоги: субъект с низким уровнем целостности не может писать
      в субъект с высоким уровнем целостности; субъект с высоким уровнем
      целостности не может читать из субъекта с низким уровнем
      целостности.</para>
  </sect1>

  <sect1 id="mac-lomac">
    <title>Модуль MAC LOMAC</title>

    <indexterm>
      <primary>MAC LOMAC</primary>
    </indexterm>
    <para>Имя модуля: <filename>mac_lomac.ko</filename></para>

    <para>Строка конфигурации ядра: <literal>options MAC_LOMAC</literal></para>
    <para>Параметр загрузки: <literal>mac_lomac_load="YES"</literal></para>

    <para>В отличие от политики <acronym>MAC</acronym> Biba, политика
      &man.mac.lomac.4; разрешает доступ к объектам с более низким уровнем
      целостности только после уменьшения уровня целостности, чтобы не
      нарушать каких-либо правил целостности.</para>

    <para><acronym>MAC</acronym> версия политики целостности Low-watermark,
      чтобы не пересекаться со старой реализацией  &man.lomac.4;,
      работает почти так же, как и Biba, за исключением использования
      плавающих меток для поддержки понижения метки субъекта через
      отдел для вспомогательной градации (auxiliary grade compartment).
      Этот вспомогательный отдел принимает вид <literal>[auxgrade]</literal>.
      При включении политики lomac с вспомогательной градацией
      метка должна выглядеть приблизительно так:
      <literal>lomac/10[2]</literal>, где номер 2 это вспомогательная
      градация.</para>

    <para>Политика <acronym>MAC</acronym> LOMAC основана на тотальной
      пометке всех системных объектов метками целостности, разрешая
      субъектам читать из объектов с более низкой степенью целостности
      и с уменьшением метки субъекта для предотвращения последующей
      записи в объекты с более высокой степенью целостности.
      Параметр <literal>[auxgrade]</literal> обсуждался выше, таким
      образом политика может быть более совместимой и требовать
      меньшей первоначальной настройки, чем Biba.</para>

    <sect2>
      <title>Примеры</title>

      <para>Как и для политик Biba и <acronym>MLS</acronym>, для
	установки меток на системные объекты и субъекты могут
	быть использованы утилиты <command>setfmac</command> и
	<command>setpmac</command>:</para>

      <screen>&prompt.root; <userinput>setfmac /usr/home/trhodes lomac/high[low]</userinput>
&prompt.root; <userinput>getfmac /usr/home/trhodes</userinput> lomac/high[low]</screen>

      <para>Обратите внимание, что вспомогательная градация здесь
	<literal>low</literal>, эта возможность предоставляется только
	политикой <acronym>MAC</acronym> LOMAC policy.</para>
    </sect2>
  </sect1>

  <sect1 id="mac-implementing">
    <title>Реализация защищенной среды с MAC</title>

    <indexterm>
      <primary>MAC Example Implementation</primary>
    </indexterm>
    <indexterm>
      <primary>MAC -- пример реализации</primary>
    </indexterm>

    <para>Нижеследующая демонстрация реализует защищенную среду
      с использованием различных <acronym>MAC</acronym> модулей
      с соответственно настроенными политиками.  Используйте
      этот пример только для тестирования, он не предназначен
      для удовлетворения всех требований к защите.  Реализация
      этих политик без понимания принципа их работы неприменима
      в реальных задачах.</para>

    <para>Перед началом процесса настройки, на каждую файловую
      систему необходимо установить параметр <literal>multilabel</literal>,
      который упоминался в начале этой главы.  Невыполнение
      этого требования приведет к ошибкам.</para>

    <sect2>
      <title>Создание insecure класса пользователя</title>

      <para>Начните процедуру добавлением следующего класса
	пользователя к файлу
	<filename>/etc/login.conf</filename>:</para>

      <programlisting>insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/share/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=partition/13,mls/5:</programlisting>

      <para>и добавлением следующей строки к default классу
	пользователя:</para>

      <programlisting>:label=mls/equal,biba/equal,partition/equal:</programlisting>

      <para>После завершения этих действий, для пересборки базы данных
	должна быть выполнена следующая команда:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
    </sect2>

    <sect2>
      <title>Загрузка с необходимыми модулями</title>

      <para>Добавьте к
	<filename>/boot/loader.conf</filename> следующие строки,
	чтобы необходимые модули были загружены при старте
	системы:</para>

      <programlisting>mac_biba_load="YES"
mac_mls_load="YES"
mac_seeotheruids_load="YES"
mac_partition_load="YES"</programlisting>
    </sect2>

    <sect2>
      <title>Установка всех пользователей в insecure</title>

      <para>Всем учетным записям, кроме <username>root</username>
	или системных пользователей теперь потребуется присвоить
	класс (login class).  При отсутствии класса пользователи
	не смогут получить доступа к обычным командам, таким как
	&man.vi.1;.  Следующий скрипт <command>sh</command>
	сделает все необходимое:</para>

      <screen>&prompt.root; <userinput>for x in `awk -F: '($3 >= 1001) && ($3 != 65534) { print $1 }' \</userinput>
	<userinput>/etc/passwd`; do pw usermod $x -L insecure; done;</userinput></screen>

      <para>После этого изменения необходимо запустить команду
	<command>cap_mkdb</command> на файле
	<filename>/etc/master.passwd</filename>.</para>
    </sect2>

    <sect2>
      <title>Завершение настройки</title>

      <para>Должен быть создан файл контекста; следующий пример
	взят из примера политики от Robert Watson, он может быть
	помещен в <filename>/etc/policy.contexts</filename>:</para>

      <programlisting># This is the default BIBA/MLS policy for this system.

.*                              biba/high,mls/high
/sbin/dhclient                  biba/high(low),mls/high(low)
/dev(/.*)?                      biba/equal,mls/equal
# This is not an exhaustive list of all "privileged" devices.
/dev/mdctl                      biba/high,mls/high
/dev/pci                        biba/high,mls/high
/dev/k?mem                      biba/high,mls/high
/dev/io                         biba/high,mls/high
/dev/agp.*                      biba/high,mls/high
(/var)?/tmp(/.*)?               biba/equal,mls/equal
/tmp/\.X11-unix                 biba/high(equal),mls/high(equal)
/tmp/\.X11-unix/.*              biba/equal,mls/equal
/proc(/.*)?                     biba/equal,mls/equal
/mnt.*                          biba/low,mls/low
(/usr)?/home                    biba/high(low),mls/high(low)
(/usr)?/home/.*                 biba/low,mls/low
/var/mail(/.*)?                 biba/low,mls/low
/var/spool/mqueue(/.*)?         biba/low,mls/low
(/mnt)?/cdrom(/.*)?             biba/high,mls/high
(/usr)?/home/(ftp|samba)(/.*)?  biba/high,mls/high
/var/log/sendmail\.st           biba/low,mls/low
/var/run/utmp                   biba/equal,mls/equal
/var/log/(lastlog|wtmp)         biba/equal,mls/equal</programlisting>

      <para>Эта политика обеспечит безопасность путем применения
	ограничений на нисходящий и восходящий потоки информации
	в применении к каталогам и утилитам, приведенным в левой
	части файла.</para>

      <para>Он может быть внесен в систему следующими
	командами:</para>

      <screen>&prompt.root; <userinput>setfsmac -ef /etc/policy.contexts /</userinput>
&prompt.root; <userinput>setfsmac -ef /etc/policy.contexts /usr</userinput></screen>

      <note>
	<para>Раскладка вышеприведенной файловой системы может быть
	  различной для разных систем.</para>
      </note>

      <para>Файл <filename>/etc/mac.conf</filename> требует
	следующих изменений в основном разделе:</para>

      <programlisting>default_labels file ?biba,?mls
default_labels ifnet ?biba,?mls
default_labels process ?biba,?mls,?partition
default_labels socket ?biba,?mls</programlisting>
    </sect2>

    <sect2>
      <title>Тестирование настройки</title>

      <indexterm>
	<primary>MAC Configuration Testing</primary>
      </indexterm>

      <para>Добавьте пользователя с помощью команды
	<command>adduser</command> и поместите его в класс
	<literal>insecure</literal> для этих тестов.</para>

      <para>В примерах ниже тестирование <username>root</username>
	и обычных пользователей будет смешиваться; форма
	приглашения поможет различить этих пользователей.</para>

      <sect3>
	<title>Основное тестирование меток</title>

	<screen>&prompt.user; <userinput>getpmac</userinput>
biba/15(15-15),mls/15(15-15),partition/15
&prompt.root; <userinput>setpmac partition/15,mls/equal top</userinput></screen>

	<note>
	  <para>Процесс top будет уничтожен перед тем, как мы запустим
	    другой процесс top.</para>
	</note>
      </sect3>

      <sect3>
	<title>Тестирование MAC seeotheruids</title>

	<screen>&prompt.user; <userinput>ps Zax</userinput>
biba/15(15-15),mls/15(15-15),partition/15  1096 #C:  S      0:00.03 -su (bash)
biba/15(15-15),mls/15(15-15),partition/15  1101 #C:  R+     0:00.01 ps Zax</screen>

	<para>Просмотр процессов всех других пользователей должен
	  быть запрещен.</para>
      </sect3>

      <sect3>
	<title>Тестирование MAC partition</title>

	<para>Отключите политику <acronym>MAC</acronym>
	  <literal>seeotheruids</literal> для остальных тестов:</para>

	<screen>&prompt.root; <userinput>sysctl security.mac.seeotheruids.enabled=0</userinput>
&prompt.user; <userinput>ps Zax</userinput>
LABEL                                                   PID  TT  STAT      TIME COMMAND
  biba/equal(low-high),mls/equal(low-high),partition/15  1122 #C:  S+     0:00.02 top
  biba/15(15-15),mls/15(15-15),partition/15              1096 #C:  S      0:00.05 -su (bash)
  biba/15(15-15),mls/15(15-15),partition/15              1123 #C:  R+     0:00.01 ps Zax</screen>

	<para>Все пользователи должны видеть каждый процесс в своем
	  разделе (partition).</para>
      </sect3>

      <sect3>
	<title>Тестирование меток Biba и MLS</title>

	<screen>&prompt.root; <userinput>setpmac partition/15,mls/equal,biba/high\(high-high\) top</userinput>
&prompt.user; <userinput>ps Zax</userinput>
LABEL                                                   PID  TT  STAT    TIME   COMMAND
  biba/high(high-high),mls/equal(low-high),partition/15   1251 #C:  S+     0:00.02 top
  biba/15(15-15),mls/15(15-15),partition/15               1096 #C:  S      0:00.06 -su (bash)
  biba/15(15-15),mls/15(15-15),partition/15               1157 #C:  R+     0:00.00 ps Zax</screen>

	<para>Политика Biba позволяет чтение объектов с более высокими
	  метками.</para>

	<screen>&prompt.root; <userinput>setpmac partition/15,mls/equal,biba/low top</userinput>
&prompt.user; <userinput>ps Zax</userinput>
LABEL                                       PID  TT  STAT      TIME COMMAND
  biba/15(15-15),mls/15(15-15),partition/15  1096 #C:  S      0:00.07 -su (bash)
  biba/15(15-15),mls/15(15-15),partition/15  1226 #C:  R+     0:00.01 ps Zax</screen>

	<para>Политика Biba не позволяет чтение объектов с более низкими
	  метками; тем не менее, <acronym>MLS</acronym> разрешает это.</para>

	<screen>&prompt.user; <userinput>ifconfig bge0 | grep maclabel</userinput>
maclabel biba/low(low-low),mls/low(low-low)
&prompt.user; <userinput>ping -c 1 192.0.34.166</userinput>
PING 192.0.34.166 (192.0.34.166): 56 data bytes
ping: sendto: Permission denied</screen>

	<para>Пользователи не могут выполнить ping на
	  <hostid role="domainname">example.com</hostid>, или на любой
	  домен по этой причине.</para>

	<para>Для устранения этой ошибки, запустите следующую
	  команду:</para>

	<screen>&prompt.root; <userinput>sysctl security.mac.biba.trust_all_interfaces=1</userinput></screen>

	<para>Она устанавливает метку интерфейса по умолчанию в
	  незащищенный режим, так что политика Biba по умолчанию не
	  будет применена.</para>

	<screen>&prompt.root; <userinput>ifconfig bge0 maclabel biba/equal\(low-high\),mls/equal\(low-high\)</userinput>
&prompt.user; <userinput>ping -c 1 192.0.34.166</userinput>
PING 192.0.34.166 (192.0.34.166): 56 data bytes
64 bytes from 192.0.34.166: icmp_seq=0 ttl=50 time=204.455 ms
--- 192.0.34.166 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max/stddev = 204.455/204.455/204.455/0.000 ms</screen>

	<para>Установив более корректную метку, мы можем использовать
	  <command>ping</command>.</para>

	<para>Теперь создадим файлы для процедуры тестирования чтения
	  и записи:</para>

	<screen>&prompt.root; <userinput>touch test1 test2 test3 test4 test5</userinput>
&prompt.root; <userinput>getfmac test1</userinput>
test1: biba/equal,mls/equal
&prompt.root; <userinput>setfmac biba/low test1 test2; setfmac biba/high test4 test5; \
  setfmac mls/low test1 test3; setfmac mls/high test2 test4</userinput>
&prompt.root; <userinput>setfmac mls/equal,biba/equal test3 && getfmac test?</userinput>
test1: biba/low,mls/low
test2: biba/low,mls/high
test3: biba/equal,mls/equal
test4: biba/high,mls/high
test5: biba/high,mls/equal
&prompt.root; <userinput>chown testuser:testuser test?</userinput></screen>

	<para>Все эти файлы должны принадлежать пользователю
	  <username>testuser</username>.  Тесты на чтение:</para>

	<screen>&prompt.user; <userinput>ls</userinput>
test1   test2   test3   test4   test5
&prompt.user; <userinput>ls test?</userinput>
ls: test1: Permission denied
ls: test2: Permission denied
ls: test4: Permission denied
test3   test5</screen>

	<para>Доступ на чтение не должен быть разрешен для пар:
	  <literal>(biba/low,mls/low)</literal>,
	  <literal>(biba/low,mls/high)</literal> и
	  <literal>(biba/high,mls/high)</literal>.
	  Теперь несколько тестов на запись:</para>

	<screen>&prompt.user; <userinput>for i in `echo test*`; do echo 1 > $i; done</userinput>
-su: test1: Permission denied
-su: test4: Permission denied
-su: test5: Permission denied</screen>

	<para>Подобно тестам на чтение, доступ на запись должен быть
	  запрещен для пар:
	  <literal>(biba/low,mls/high)</literal> и
	  <literal>(biba/equal,mls/equal)</literal>.</para>

	<screen>&prompt.user; <userinput>cat test?</userinput>
cat: test1: Permission denied
cat: test2: Permission denied
1
cat: test4: Permission denied</screen>

	<para>А теперь от <username>root</username>:</para>

	<screen>&prompt.root; <userinput>cat test2</userinput>
1</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="MAC-examplehttpd">
    <title>Другой пример: Использование MAC для защиты веб сервера</title>

      <para>Будет создано отдельное хранилище для веб данных,
	к которому пользователи должны иметь доступ.  Это позволит
	<literal>biba/high</literal> управлять доступом к веб
	данным.</para>

      <para>Начните с создания каталога для хранения веб
	данных:</para>

      <screen>&prompt.root; <userinput>mkdir /usr/home/cvs</userinput></screen>

      <para>Теперь инициализируйте его командой
	<command>cvs</command>:</para>

      <screen>&prompt.root; <userinput>cvs -d /usr/home/cvs init</userinput></screen>

      <para>Для начала необходимо включить политику <literal>biba</literal>,
	добавив  <literal>mac_biba_enable="YES"</literal> в
	<filename>/boot/loader.conf</filename>.  Предполагается, что
	ядро скомпилировано с поддержкой <acronym>MAC</acronym>.</para>

      <para>Далее установите метку <literal>biba/high</literal> для всей
	системы по умолчанию.</para>

      <para>В файл <filename>login.conf</filename>, класс default,
	необходимо внести следующие изменения:</para>

      <programlisting>:ignoretime@:\
	:umask=022:\
	:label=biba/high:</programlisting>

      <para>Каждого пользователя необходимо поместить в класс по
	умолчанию; такая команда:</para>

      <screen>&prompt.root; <userinput>for x in `awk -F: '($3 >= 1001) && ($3 != 65534) { print $1 }' \</userinput>
	<userinput>/etc/passwd`; do pw usermod $x -L default; done;</userinput></screen>

      <para>быстро решит эту задачу.</para>

      <para>Теперь создадим другой класс, web, копию класса default
	с меткой, установленной в <literal>biba/low</literal>.</para>

      <para>Создайте пользователя для работы с основными веб данными,
	хранящимися в репозитории <application>cvs</application>.
	Этого пользователя необходимо поместить в новый класс,
	<username>web</username>.</para>

      <para>Поскольку метка по умолчанию <literal>biba/high</literal>,
	на репозитории она будет той же.  Веб данные должны иметь
	ту же метку, чтобы у пользователей был доступ к ним на
	чтение/запись.  Веб сервер должен иметь доступ к тем же
	данным, к которым есть доступ у пользователей с меткой
	<literal>biba/high</literal>, для этого необходимо понизить
	метку данных.</para>

      <para>Все, что потребуется, это следующий &man.sh.1; скрипт,
	который может быть запущен из &man.cron.8;:</para>

      <programlisting>PATH=/bin:/usr/bin:/usr/local/bin; export PATH;
CVSROOT=/home/repo; export CVSROOT;
cd /home/web;
cvs -qR checkout -P htdocs;
exit;</programlisting>

      <note>
	<para>Во многих случаях в веб файлы <command>cvs</command>
	  необходимо поместить теги Id.</para>
      </note>

      <para>Этот скрипт теперь может быть помещен в домашний каталог
	каталог пользователя <username>web</username>,  необходимо
	также добавить следующую запись &man.crontab.1;:</para>

      <programlisting># Выполнять checkout web данных под меткой biba/low каждые 12 часов:
0       */12       *       *       *       web    /home/web/checkout.sh</programlisting>

      <para>Эта запись будет извлекать <acronym>HTML</acronym> страницы
	каждые двенадцать часов.</para>

      <para>Метод запуска веб сервера по умолчанию также должен быть
	изменен для запуска процесса с меткой <literal>biba/low</literal>.
	Это может быть сделано путем следующего изменения в скрипте
	<filename>/usr/local/etc/rc.d/apache.sh</filename>:</para>

      <programlisting>command="setpmac biba/low /usr/local/sbin/httpd"</programlisting>

      <para>Настройки <application>Apache</application> должны быть изменены
	для работы с политикой <literal>biba/low</literal>.  В этом
	случае необходимо указать для хранения лог файлов каталог с
	меткой <literal>biba/low</literal>, иначе будут возвращены
	ошибки <errorname>access denied</errorname>.</para>

      <note>
	<para>В этом примере необходимо указать в директиве
	  <literal>docroot</literal> каталог
	  <filename>/home/web/htdocs</filename>; или,
	  <application>Apache</application> не сможет
	  найти каталог с документами.</para>
      </note>

      <para>Необходимо также изменить другие параметры конфигурации,
	включая <acronym>PID</acronym> файл,
	<literal>Scoreboardfile</literal>,
	<literal>DocumentRoot</literal>, или любые другие
	настройки для каталогов, где необходим доступ на запись.
	При использовании <literal>biba</literal> будет запрещен
	доступ на запись во все каталоги сервера, на которых
	нет метки <literal>biba/low</literal>.</para>

<!--
PROBLEM: CAN THIS WORK?  OR SHOULD IT BE start_precmd?  More testing need here.
-->
  </sect1>

<!--
XXX

   <sect1 id="mac-examplesandbox">
     <title>An Example of a MAC Sandbox</title>
 
     <para>An example of placing users in a sandbox using
       <acronym>MAC</acronym> should go here.</para>
   </sect1>
-->

  <sect1 id="mac-troubleshoot">
    <title>Решение проблем с инфраструктурой MAC</title>

    <indexterm>
      <primary>MAC Troubleshooting</primary>
    </indexterm>

    <para>На стадии разработки несколько пользователей сообщали
      о проблемах при обычных настройках.  Некоторые из этих
      проблем приведены ниже:</para>

    <sect2>
      <title>Параметр <option>multilabel</option> не может быть включен на
	<filename>/</filename></title>

      <para>Параметр <option>multilabel</option> не включается на
	моем корневом (<filename>/</filename>) разделе!</para>

      <para>Похоже, что каждый пятидесятый пользователь сталкивается
	с этой проблемой; на самом деле, и у нас была эта проблема
	в первых настройках.  Дальнейшие наблюдения за этой так
	называемой <quote>ошибкой</quote> привели меня к мнению,
	что это результат или некорректной документации, или
	неправильной интерпретации этой документации.
	Независимо от того, почему это случилось, для решения этой
	проблемы могут быть предприняты следующие шаги:</para>

      <procedure>
	<step>
	  <para>Отредактируйте <filename>/etc/fstab</filename> и установите
	    для корневого раздела параметр только для чтения
	    (<option>ro</option>).</para>
	</step>

	<step>
	  <para>Перегрузитесь в однопользовательский режим.</para>
	</step>

	<step>
	  <para>Запустите команду <command>tunefs</command>
	    <option>-l enable</option> на <filename>/</filename>.</para>
	</step>

	<step>
	  <para>Перегрузите систему в нормальный режим.</para>
	</step>

	<step>
	  <para>Запустите <command>mount</command> <option>-urw</option>
	  <filename>/</filename> и измените параметр <option>ro</option>
	  обратно на <option>rw</option> в <filename>/etc/fstab</filename>;
	  перегрузите систему опять.</para>
	</step>

	<step>
	  <para>Дважды проверьте вывод
	  <command>mount</command>, чтобы убедиться, что параметр
	  <option>multilabel</option> был установлен на корневой
	  файловой системе.</para>
	</step>
     </procedure>
    </sect2>

    <sect2>
      <title>Не могу запустить &xfree86; после <acronym>MAC</acronym></title>

      <para>После настройки системы безопасности
	<acronym>MAC</acronym>, я больше не могу запускать
	&xfree86;!</para>

      <para>Это может быть вызвано политикой <acronym>MAC</acronym>
	<literal>partition</literal> или путем неправильной установки
	меток одной из политик <acronym>MAC</acronym>.  Для отладки
	попробуйте следующее:</para>

      <procedure>
	<step>
	  <para>Просмотрите сообщение об ошибке; если пользователь
	    находится в классе <literal>insecure</literal>, проблема
	    может быть в политике <literal>partition</literal>.
	    Попробуйте установить класс пользователя обратно в
	    <literal>default</literal> и пересобрать базу данных
	    командой <command>cap_mkdb</command>.  Если это не
	    решит проблемы, попробуйте шаг два.</para>
	</step>

	<step>
	  <para>Дважды проверьте политики с метками.  Убедитесь, что
	    политики настроены правильно для рассматриваемого пользователя,
	    приложения &xfree86;, и устройств в <filename
	    class="directory">/dev</filename>.</para>
	</step>

	<step>
	  <para>Если проблема не решена, отправьте сообщение об ошибке и
	    описание вашей системы в список рассылки TrustedBSD,
	    находящийся на веб сайте
	    <ulink url="http://www.TrustedBSD.org">TrustedBSD</ulink>
	    или в &a.questions;.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Error: &man..secure.path.3; cannot stat <filename>.login_conf</filename></title>

      <para>При попытке переключения от <username>root</username> на другого
	пользователя системы, появляется сообщение об ошибке
	<errorname>_secure_path: unable to state .login_conf</errorname>.</para>

      <para>Это сообщение обычно показывается, когда у пользователя более
	высокая метка, чем у пользователя, которым он пытается стать.
	Например, у пользователя системы <username>joe</username> метка по
	умолчанию <option>biba/low</option>.  Пользователь
	<username>root</username>, метка которого <option>biba/high</option>,
	не может просматривать домашний каталог пользователя
	<username>joe</username>.  Это не зависит от того, использует ли
	пользователь <username>root</username> команду <command>su</command>
	<username>joe</username> или нет.  В этом сценарии модель
	целостности Biba не позволит <username>root</username> просматривать
	объекты с низким уровнем целостности.</para>
    </sect2>

    <sect2>
      <title>Пользователя <username>root</username> нет!</title>

      <para>В нормальном или даже однопользовательском режиме
	<username>root</username> не обнаруживается.  Команда
	<command>whoami</command> возвращает 0 (нуль) и
	<command>su</command> возвращает <errorname>who are you?</errorname>.
	Что можно сделать?</para>

      <para>Это может произойти, если политика с метками была отключена,
	или через &man.sysctl.8;, или путем выгрузки модуля политики.
	Если политика была постоянно или временно отключена, базу данных
	login необходимо перенастроить.  Дважды проверьте
	<filename>login.conf</filename>, чтобы убедиться, что
	все параметры <option>label</option> были удалены и пересоберите
	базу данных командой <command>cap_mkdb</command>.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
