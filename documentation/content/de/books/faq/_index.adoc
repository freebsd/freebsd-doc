---
title: Häufig gestellte Fragen zu FreeBSD 11.X und 12.X
authors: 
  - author: The FreeBSD Documentation Project
copyright: 1995-2020 The FreeBSD Documentation Project
releaseinfo: "$FreeBSD$" 
trademarks: ["freebsd", "ibm", "ieee", "adobe", "intel", "linux", "microsoft", "opengroup", "sun", "netbsd", "general"] 
---

= Häufig gestellte Fragen zu FreeBSD {rel2-relx} und {rel-relx}
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnums:
:sectnumlevels: 6
:partnums:
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Inhaltsverzeichnis
:part-signifier: Teil
:chapter-signifier: Kapitel
:appendix-caption: Anhang
:table-caption: Tabelle
:figure-caption: Abbildung
:example-caption: Beispiel
:rel-numbranch: 3
:rel-head: 13-CURRENT
:rel-head-relx: 13.X
:rel-head-releng: head/
:rel-relx: 12.X
:rel-stable: 12-STABLE
:rel-releng: stable/12/
:rel-relengdate: December 2018
:rel2-relx: 11.X
:rel2-stable: 11-STABLE
:rel2-releng: stable/11/
:rel2-relengdate: October 2016

ifeval::["{backend}" == "html5"]
include::shared/mirrors.adoc[]
include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/de/mailing-lists.adoc[]
include::shared/de/teams.adoc[]
include::shared/de/urls.adoc[]
endif::[]

ifeval::["{backend}" == "pdf"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/de/mailing-lists.adoc[]
include::../../../../shared/de/teams.adoc[]
include::../../../../shared/de/urls.adoc[]
endif::[]

ifeval::["{backend}" == "epub3"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/de/mailing-lists.adoc[]
include::../../../../shared/de/teams.adoc[]
include::../../../../shared/de/urls.adoc[]
endif::[]

[.abstract-title]
Zusammenfassung

Dies ist die FAQ für die FreeBSD-Versionen {rel-relx} und {rel2-relx}. Es wurden große Anstrengungen unternommen, diese FAQ so informativ wie möglich zu gestalten. Wenn Sie Vorschläge haben, wie dieses Dokument verbessert werden kann, senden Sie eine Mail an die Mailingliste http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc['FreeBSD Documentation Project].

Die neueste Version dieses Dokuments ist immer auf der link:.[FreeBSD Webseite] verfügbar. Diese FAQ kann ebenfalls über HTTP als große link:.[HTML]-Datei, oder in verschiedenen anderen Formaten vom link:ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/de/[FreeBSD FTP Server] heruntergeladen werden.

'''

toc::[]

== Übersicht

=== Was ist FreeBSD

FreeBSD ist ein modernes Betriebssystem für Server, Desktops und eingebettete Systeme, das auf zahlreichen http://www.FreeBSD.org/de/platforms/[Plattformen] läuft.

Es basiert auf dem "4.4BSD-Lite"-Release der U.C. Berkeley, mit einigen Erweiterungen aus "4.4BSD-Lite2". Es basiert außerdem indirekt auf der von William Jolitz unter dem Namen "386BSD" herausgebrachten Portierung des "Net/2"-Releases für i386(TM) der U.C. Berkeley. Allerdings ist nur sehr wenig vom ursprünglichen 386BSD Code übrig geblieben.

Unternehmen, Internet Service Provider, Forscher, Computerfachleute, Studenten und Privatnutzer auf der ganzen Welt benutzen FreeBSD für die Arbeit, die Ausbildung oder in der Freizeit.

Ausführlichere Informationen zu FreeBSD, finden Sie im link:{handbook}[FreeBSD Handbuch].

[[FreeBSD-goals]]
=== Welches Ziel hat das FreeBSD Project?

Das Ziel des FreeBSD Projects ist es, ein stabiles und schnelles Betriebssystem zur Verfügung zu stellen, das Sie für jeden Zweck verwenden können, ohne dabei irgendwelche Bedingungen in Kauf nehmen zu müssen.

=== Beinhaltet die FreeBSD-Lizenz irgendwelche Einschränkungen?

Ja. Diese Einschränkungen regeln aber nicht, wie Sie mit dem Quellcode umgehen, sondern betreffen nur den Umgang mit dem FreeBSD Project an sich. Die Lizenz ist unter http://www.FreeBSD.org/copyright/freebsd-license/[http://www.FreeBSD.org/copyright/freebsd-license/] verfübar und lässt sich wie folgt zusammenfassen:

* Behaupten Sie nicht, Sie hätten es geschrieben.
* Verklagen Sie uns nicht, wenn etwas nicht funktioniert.
* Sie dürfen die Lizenz nicht entfernen oder verändern.

Viele von uns haben erheblich zur Erstellung des Codes (und zum Projekt) beigetragen und hätten jetzt oder in Zukunft sicherlich nichts gegen einen geringen finanziellen Ausgleich einzuwenden, aber wir beabsichtigen definitiv nicht, darauf zu bestehen. Wir sind der Meinung, dass unsere "Mission" zuerst und insbesondere darin besteht, allen und jedem Kommenden Code für welchen Zweck auch immer zur Verfügung zu stellen, damit der Code möglichst weit eingesetzt wird und den größtmöglichen Nutzen liefert. Das ist, so glauben wir, eines der fundamentalsten Ziele von freier Software und eines, das wir enthusiastisch unterstützen.

Der Code in unserem Quellbaum, der der http://www.FreeBSD.org/copyright/COPYING[GNU General Public License (GPL)] oder der http://www.FreeBSD.org/copyright/COPYING.LIB[GNU Library General Public License (LGPL)] unterliegt, ist mit zusätzlichen Bedingungen verknüpft, jedoch handelt es sich dabei lediglich um erzwungene Bereitstellung statt des sonst üblichen Gegenteils. Auf Grund der zusätzlichen Komplexität, die durch den kommerziellen Einsatz von GPL Software entstehen kann, bemühen wir uns jedoch, solche Software, wo möglich, durch solche, die der etwas lockereren http://www.FreeBSD.org/copyright/freebsd-license/[FreeBSD Lizenz] unterliegt, zu ersetzen.

=== Kann FreeBSD mein bisher verwendetes Betriebssystem ersetzen?

In den meisten Fällen lautet die Antwort: Ja! Allerdings ist diese Frage nicht ganz so einfach, wie sie scheint.

Die meisten Anwender benutzen kein Betriebssystem, sondern Anwendungen. Die Anwendungen sind es, die das Betriebssystem benutzen. FreeBSD wurde entworfen, Anwendungen eine stabile und funktionsreiche Umgebung zu bieten. Es unterstützt viele unterschiedliche Web-Browser, Büroanwendungen, E-Mail-Programme, Grafik-Programme, Entwicklungsumgebungen, Netzwerk-Server, und vieles mehr. Die meisten dieser Anwendungen sind in der http://www.FreeBSD.org/de/ports/[Ports-Sammlung] verfügbar.

Wenn Sie eine Anwendung benutzen müssen, die es nur für ein bestimmtes Betriebssystem gibt, dann kommen Sie an diesem Betriebssystem nicht vorbei. Allerdings stehen die Chancen nicht schlecht, dass es eine vergleichbare Anwendung für FreeBSD gibt.

Wenn Sie von einem anderen UNIX(TM) System zu FreeBSD wechseln, dürfte Ihnen vieles bekannt vorkommen. Wenn Ihr Hintergrund ein Betriebssystem wie Windows(TM) oder MacOS(TM)ist, sind Sie vielleicht an https://www.trueos.org/[TrueOS] interessiert, eine auf FreeBSD basierende Desktop-Distribution. Wenn Sie vorher noch nicht mit UNIX(TM) gearbeitet haben, werden Sie zusätzliche Zeit investieren müssen, um den UNIX(TM) Stil zu verstehen. Diese FAQ und das link:{handbook}[FreeBSD Handbuch] sind die besten Startpunkte.

=== Warum heißt es FreeBSD?

* Es darf kostenlos genutzt werden - sogar von kommerziellen Nutzern.
* Der komplette Quellcode für das Betriebssystem ist frei verfügbar und die Benutzung, Verbreitung und Einbindung in andere (kommerzielle und nicht-kommerzielle) Arbeiten sind mit den geringstmöglichen Einschränkungen versehen worden.
* Jedem ist es freigestellt, Code für Verbesserungen oder die Behebung von Fehlern einzusenden und ihn zum Quellbaum hinzufügen zu lassen (dies ist natürlich Gegenstand von ein oder zwei offensichtlichen Klauseln).

Es wird darauf hingewiesen, dass das englische Wort "free" hier in den Bedeutungen "umsonst" und "Sie können tun, was immer Sie möchten" genutzt wird. Abgesehen von ein oder zwei Dingen, die Sie mit dem FreeBSD-Code _nicht_ tun können (z.B. vorgeben, ihn geschrieben zu haben), können Sie damit tatsächlich tun, was auch immer Sie möchten.

=== Wie unterschieden sich FreeBSD, NetBSD, OpenBSD und andere Open-Source BSD-Systeme?

James Howards Artikel, genannt http://www.freebsdworld.gr/freebsd/bsd-family-tree.html[The BSD Family Tree,], beschreibt sehr gut die Geschichte und die Unterschiede der BSD-Varianten.

Die meisten der BSDs teilen auch heute noch Patches und Code. Außerdem haben alle BSDs eine gemeinsame Herkunft.

Die Ziele von FreeBSD sind in <<FreeBSD-goals>> beschrieben. Die Ziele der anderen bekannten BSDs können wie folgt zusammengefasst werden:

* OpenBSD strebt eine hohe Sicherheit des Betriebssystems an. Das OpenBSD-Team hat auch man:ssh[1] und man:pf[4] entwickelt, welche ebenfalls nach FreeBSD portiert wurden.
* NetBSD soll leicht auf andere Plattformen portierbar sein.
* DragonFlyBSD ist eine Abspaltung von FreeBSD 4.8 und hat seither viele interessante Funktionen entwickelt, einschließlich des HAMMER-Dateisystems und Unterstützung für User-Mode "vkernels".

=== Welches ist die aktuelle FreeBSD-Version?

Momentan gibt es zwei Entwicklungszweige, die für die Erstellung von Releases verwendet werden. Die 10._X_-RELEASEs werden auf dem _10-STABLE_-Zweig erstellt, die 9._X_-RELEASEs auf dem _9-STABLE_-Zweig.

Bis zur Veröffentlichung von FreeBSD 9.0 galt die 9._X_-Serie als _-STABLE_. Seit FreeBSD 11._X_ gibt es für den Zweig 9._X_ nur mehr eine "erweiterte Unterstützung" in der Form von Korrekturen von größeren Problemen, wie neu entdeckten Sicherheitsheitslücken.

Version link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/10.3-RELEASE/[10.3] ist das aktuelle Release des _10-STABLE_-Zweigs und ist im April 2016 erschienen. Version link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/9.3-RELEASE/[9.3] ist das aktuelle Release aus dem _9-STABLE_-Zweig und ist im Juli 2014 erschienen.

Releases werden <<release-freq,nur alle paar Monate>> erstellt. Viele Leute halten ihre Systeme aktueller (lesen Sie die Fragen zu <<current,FreeBSD-CURRENT>> und <<stable,FreeBSD-STABLE>>), aber das erfordert ein erhöhtes Engagement, da der Quellcode sich ständig verändern.

Weitere Informationen über FreeBSD-Releases finden Sie auf der http://www.FreeBSD.org/releng/#release-build[Release Engineering Seite] und in man:release[7].

=== Was ist FreeBSD-CURRENT?

link:{handbook}#current[FreeBSD-CURRENT] ist die Entwicklungsversion des Betriebssystems, aus der zu gegebener Zeit der FreeBSD-STABLE-Zweig entstehen wird. Als solche ist sie lediglich für Entwickler, die am System mitarbeiten und für unentwegte Bastler von Interesse. Details zum Betrieb von _-CURRENT_ finden Sie im link:{handbook}#current[entsprechenden Abschnitt] des link:{handbook}[Handbuchs].

Falls Sie mit FreeBSD nicht vertraut sind, sollten Sie FreeBSD-CURRENT nicht verwenden. Dieser Zweig entwickelt sich manchmal sehr schnell weiter und kann gelegentlich nicht installierbar sein. Von Personen, die FreeBSD-CURRENT verwenden, wird erwartet, dass Sie dazu in der Lage sind, Probleme zu erkennen, zu analysieren und diese an das Projekt zurückzumelden.

Jeden Monat wird der aktuelle Entwicklungsstand in den Zweigen -CURRENT und -STABLE in einer https://www.FreeBSD.org/snapshots/[Snapshot] Release festgehalten. Die Ziele dieser Snapshot Releases sind:

* Die aktuelle Version der Installationssoftware zu testen.
* Personen, die _-CURRENT_ oder _-STABLE_ benutzen möchten, aber nicht über die nötige Zeit oder Bandbreite verfügen, um tagesaktuell zu bleiben, soll eine bequeme Möglichkeit geboten werden, es auf ihr System zu bringen.
* Die Erhaltung von Referenzpunkten des fraglichen Codes, für den Fall, dass wir später einmal ernsthaften Schaden anrichten sollten - obwohl Subversion verhindern sollte, dass solche Situationen entstehen.
* Sicherzustellen, dass alle neuen Merkmale und Fehlerbehebungen zu möglichst vielen potentiellen Testern gelangen.

Von keinem _-CURRENT_ Snapshot kann "Produktionsqualität" für beliebige Zwecke erwartet werden. Wenn Sie eine stabile und ausgetestete Version benötigen, sollten Sie ein vollständiges Release verwenden.

Snapshot-Releases sind auf der https://www.FreeBSD.org/snapshots/[Snapshots-Seite] verfügbar.

Offizielle Snapshots werden in regelmäßigen Abständen für jeden aktiven Zweig erstellt.

=== Was ist das Konzept von FreeBSD-STABLE?

Zur der Zeit, als FreeBSD 2.0.5 herausgegeben wurde, wurde entschieden, die Entwicklung von FreeBSD zweizuteilen. Ein Zweig wurde link:{handbook}#stable[-STABLE], der andere link:{handbook}#current[-CURRENT] genannt. _FreeBSD-STABLE_ ist der Entwicklungszweig aus dem die Hauptversionen erstellt werden. In diesem Zweig gehen nur Änderungen ein, wenn sie zuvor sorgfältig in FreeBSD-CURRENT getestet wurden. Gelegentlich können die Quellen für FreeBSD-STABLE möglicherweise nicht für den allgemeinen Gebrauch geeignet sein, da es Fehler enthalten können, die noch nicht in FreeBSD-CURRENT gefunden wurden. Benutzer, die nicht über genügend Ressourcen verfügen um zu testen, sollten stattdessen die aktuelle Version von FreeBSD verwenden. _FreeBSD-CURRENT_ ist eine ununterbrochene Linie seitdem die Version 2.0 herausgegeben worden ist. Sie führt zu 11.0-RELEASE (und darüber hinaus). Weitere Informationen zu diesen Zweigen finden Sie unter "link:{releng}#rel-branch[FreeBSD Release Engineering: Creating the Release Branch]", der Status der Zweige und der Zeitplan zur anstehenden Veröffentlichung kann auf der Seite http://www.FreeBSD.org/releng[Release Engineering Information] gefunden werden.

11.0-STABLE ist der Zweig, auf den sich die Entwicklung von _-STABLE_ zur Zeit konzentriert. Das neueste Release aus dem 11.0-STABLE-Zweig ist 11.0-RELEASE und ist im Oktober 2016 erschienen.

Aus dem _11-CURRENT_-Zweig ist der aktiv entwickelte _CURRENT_-Zweig, aus dem die nächste FreeBSD-Generation entsteht. Weitere Informationen über diesen Zweig finden Sie unter <<current,Was ist FreeBSD-CURRENT?>>.

=== Wann werden FreeBSD-Releases erstellt?

In der Regel gibt das Release Engineering Team mailto:re@FreeBSD.org[re@FreeBSD.org] alle 18 Monate eine neue Hauptversion und etwa alle 8 Monate eine Unterversion frei. Das Erscheinungsdatum einer Version wird frühzeitig bekanntgegeben, damit die am System arbeitenden Personen wissen, bis wann ihre Projekte abgeschlossen und getestet werden müssen. Vor jedem Release gibt es eine Testperiode um sicherzustellen, dass die neu hinzugefügten Features nicht die Stabilität des Releases beeinträchtigen. Viele Benutzer halten dies für einen großen Vorteil von FreeBSD, obwohl es manchmal frustrierend sein kann, so lange auf die Verfügbarkeit der aktuellsten Funktionen zu warten.

Weitere Informationen über die Entwicklung von Releases, sowie eine Übersicht über kommende Releases, erhalten Sie auf den http://www.FreeBSD.org/releng/[Release Engineering] Seiten der FreeBSD Webseite.

Für diejenigen, die ein wenig mehr Spannung möchten, werden täglich Snapshots herausgegeben, wie oben beschrieben.

=== Wer ist für FreeBSD verantwortlich?

Schlüsseldiskussionen, die das FreeBSD Project betreffen, wie z.B. über die generelle Ausrichtung des Projekts und darüber, wem es erlaubt sein soll, Code zum Quellbaum hinzuzufügen, werden innerhalb eines https://www.FreeBSD.org/administration/#t-core[Core Teams] von 9 Personen geführt. Es gibt ein weitaus größeres Team von über 350 link:{contributors}#staff-committers[Committern], die dazu autorisiert sind, Änderungen am FreeBSD Quellbaum durchzuführen.

Jedoch werden die meisten nicht-trivialen Änderungen zuvor in den <<mailing,Mailinglisten>> diskutiert und es bestehen keinerlei Einschränkungen darüber, wer sich an diesen Diskussionen beteiligen darf.

=== Wie kann ich FreeBSD beziehen?

Jede bedeutende Ausgabe von FreeBSD ist per Anonymous-FTP vom link:ftp://ftp.FreeBSD.org/pub/FreeBSD/[FreeBSD FTP Server] erhältlich:

* Das aktuelle _10-STABLE_-Release, 10.3-RELEASE, finden Sie im link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/10.3-RELEASE/[Verzeichnis 10.3-RELEASE].
* https://www.FreeBSD.org/snapshots/[Snapshot]-Releases werden monatlich aus dem <<current,-CURRENT>>-Zweig sowie aus dem <<stable,-STABLE>>-Zweig erzeugt. Sie sollten aber nur von Entwicklern und sehr erfahrenen Testern verwendet werden.
* Das aktuelle _10-STABLE_-Release, 10.3-RELEASE, finden Sie im link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/10.3-RELEASE/[Verzeichnis 10.3-RELEASE].

Wo und wie Sie FreeBSD auf CD, DVD, und anderen Medien beziehen können, erfahren Sie im link:{handbook}#mirrors[Handbuch].

=== Wie greife ich auf die Datenbank mit Problemberichten zu?

Die Datenbank mit Problemberichten (PR, problem report) und Änderungsanfragen von Benutzern kann über die webbasierte https://bugs.FreeBSD.org/search/[PR-Abfrage-Schnittstelle] abgefragt werden.

Über die https://www.FreeBSD.org/support/bugreports/[webbasierte PR-Schnittstelle] können Sie Problemberichte über einen Webbrowser einreichen.

Bevor Sie einen Fehler melden, sollten Sie zuerst link:{problem-reports}[Writing FreeBSD Problem Reports] lesen, damit Sie wissen, wie Sie eine gute Fehlermeldung verfassen.

== Dokumentation und Unterstützung

=== Gibt es gute Bücher über FreeBSD?

Im Zuge des FreeBSD Projekts sind diverse gute Dokumente entstanden, die unter der folgenden URL abgerufen werden können: http://www.FreeBSD.org/docs/[http://www.FreeBSD.org/de/docs/]. Zusätzlich enthält <<bibliography,die Bibliographie>> am Ende dieser FAQ und link:{handbook}#bibliography[diejenige im Handbuch] Verweise auf weitere empfohlene Bücher.

=== Ist die Dokumentation auch in anderen Formaten verfügbar? Zum Beispiel als einfacher Text (ASCII) oder als PostScript?

Ja. Werfen Sie einen Blick auf das Verzeichnis link:ftp://ftp.de.FreeBSD.org/pub/FreeBSD/doc/[/pub/FreeBSD/doc/] auf dem FreeBSD FTP-Server. Dort finden Sie Dokumentation in vielen verschiedenen Formaten.

Die Dokumentation wurde nach verschiedenen Kriterien sortiert. Die Kriterien sind:

* Der Name des Dokumentes, z.B. `faq` oder `handbook`.
* Die Sprache und der Zeichensatz, die in dem Dokument verwendet werden. Diese entsprechen den Anpassungen, die Sie auf einem FreeBSD-System unter [.filename]#/usr/shared/locale# finden. Zurzeit werden die folgenden Sprachen und Zeichensätze benutzt:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Name
| Bedeutung

|`en_US.ISO8859-1`
|Englisch (Vereinigte Staaten)

|`bn_BD.ISO10646-1`
|Bengalisch oder Bangla (Bangladesh)

|`da_DK.ISO8859-1`
|Dänisch (Dänemark)

|`de_DE.ISO8859-1`
|Deutsch (Deutschland)

|`el_GR.ISO8859-7`
|Griechisch (Griechenland)

|`es_ES.ISO8859-1`
|Spanisch (Spanien)

|`fr_FR.ISO8859-1`
|Französisch (Frankreich)

|`hu_HU.ISO8859-2`
|Ungarisch (Ungarn)

|`it_IT.ISO8859-15`
|Italienisch (Italien)

|`ja_JP.eucJP`
|Japanisch (Japan, EUC-kodiert)

|`mn_MN.UTF-8`
|Mongolisch (Mongolei, UTF-8-kodiert)

|`nl_NL.ISO8859-1`
|Niederländisch (Holland)

|`no_NO.ISO8859-1`
|Norwegisch (Norwegen)

|`pl_PL.ISO8859-2`
|Polnisch (Polen)

|`pt_BR.ISO8859-1`
|Brasilianisches Portugiesisch (Brasilien)

|`ru_RU.KOI8-R`
|Russisch (Russland, KOI8-R-kodiert)

|`sr_YU.ISO8859-2`
|Serbisch (Serbien)

|`tr_TR.ISO8859-9`
|Türkisch (Türkei)

|`zh_CN.UTF-8`
|Vereinfachtes Chinesisch (China, UTF-8-kodiert)

|`zh_TW.UTF-8`
|Chinesisch (Taiwan, UTF-8-kodiert)
|===
+
[NOTE]
====
Einige Dokumente sind nicht in allen Sprachen verfügbar.
====

* Das Format des Dokumentes. Die Dokumentation wird in verschiedenen Formaten erzeugt, von denen jedes seine eigenen Vor- und Nachteile hat. Einige Formate lassen sich gut an einem Bildschirm lesen, während andere Formate dafür gedacht sind, ein ansprechendes Druckbild zu erzeugen. Das die Dokumentation in verschiedenen Formaten verfügbar ist, stellt sicher, dass unsere Leser die für sie relevanten Teile unabhängig vom Ausgabemedium (Bildschirm oder Papier) lesen können. Derzeit werden die folgenden Formate unterstützt:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Format
| Bedeutung

|`html-split`
|Viele kleine HTML-Dateien, die sich gegenseitig referenzieren.

|`html`
|Eine große HTML-Datei, die das komplette Dokument enthält.

|`pdf`
|Adobe's Portable Document Format

|`ps`
|PostScript(TM)

|`rtf`
|Microsoft(TM)'s Rich Text Format

|`txt`
|Normaler Text
|===
+
[NOTE]
====
Die Seitennummern werden nicht automatisch aktualisiert, wenn Sie das Rich Text Format in Word laden. Wenn Sie das Dokument geladen haben, müssen Sie  kbd:[Ctrl+A],  kbd:[Ctrl+End], kbd:[F9] eingeben, um die Seitennummern aktualisieren zu lassen.
====

* Das zur Komprimierung verwendete Programm.
.. Wenn die Dokumentation im Format `html-split` vorliegt, werden die Dateien mit man:tar[1] zusammengefasst. Die so entstandene [.filename]#.tar# Datei wird dann mit einer der unten genannten Methoden komprimiert.
.. Bei allen anderen Formaten existiert nur eine Datei mit dem Namen, z.B. [.filename]#article.pdf#, [.filename]#book.html#, und so weiter.
+ 
Diese Dateien werden entweder mit `zip` oder `bz2` komprimiert. Mit man:tar[1] können die Dateien wieder entpackt werden.
+ 
Die mit `bzip2` gepackte Version des Handbuchs im PostScript(TM)-Format hat den Namen [.filename]#book.ps.bz2# und ist im Verzeichnis [.filename]#handbook/# zu finden.

Nachdem Sie das Format und das Kompressionsverfahren ausgewählt haben, müssen Sie die komprimierten Dateien herunterladen, entpacken und an die richtigen Stellen kopieren.

Zum Beispiel finden Sie die mit man:bzip2[1] gepackte `split-html` Version der englischen FAQ in [.filename]#doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2#. Um diese Datei herunterzuladen und auszupacken, sind die folgenden Schritte notwendig:

[source,bash]
....
# fetch ftp://ftp.de.FreeBSD.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2
# tar xvf book.html-split.tar.bz2
....

Wenn die Datei komprimiert ist, wird tar automatisch das entsprechende Format erkennen und die Datei korrekt dekomprimieren. Danach haben Sie eine Sammlung vieler kleiner [.filename]#.html# Dateien. Die wichtigste Datei hat Namen [.filename]#index.html# und enthält das Inhaltsverzeichnis, eine Einleitung und Verweise auf die anderen Teile des Dokumentes.

=== Woher bekomme ich Informationen zu den FreeBSD Mailinglisten? Welche Newsgruppen existieren zu FreeBSD?

Lesen Sie den link:{handbook}#eresources-mail[Handbucheintrag über Mailinglisten] und den link:{handbook}#eresources-news/[Handbucheintrag zu Newsgruppen].

=== Gibt es FreeBSD IRC (Internet Relay Chat) Kanäle?

Ja, die meisten großen IRC Netze bieten einen FreeBSD Chat-Channel:

* Der Channel `#FreeBSDhelp` im http://www.efnet.org/index.php[EFNet] bietet Hilfe für FreeBSD Benutzer.
* Der Channel `#FreeBSD` auf http://freenode.net/[Freenode] bietet allgemeine Hilfe zu FreeBSD-Themen. Es sind immer viele Benutzer online. Zwar werden auch nicht-FreeBSD-spezifische Themen diskutiert, den Hauptteil der Diskussionen dreht sich aber um die Lösung der Probleme von FreeBSD-Anwendern. Die Teilnehmer dieses Channels helfen Ihnen auch bei Fragen zu elementaren Dingen und zeigen Ihnen auch, wo Sie die entsprechenden Erklärungen im FreeBSD-Handbuch oder anderen Ressourcen finden können. Obwohl die Teilnehmer des Channels über die ganze Welt verstreut sind, werden die Diskussionen auf Englisch geführt. Wollen Sie die Diskussion in Ihrer Sprache führen, sollten Sie Ihre Frage trotzdem auf Englisch stellen und danach gegebenenfalls einen neuen Channel in der Form `##freebsd-Ihre_Sprache` eröffnen.
* Der Channel `#FreeBSD` im http://www.dal.net/[DALNET] ist in den USA unter `irc.dal.net` und in Europa unter `irc.eu.dal.net verfügbar`.
* Der Channel `#FreeBSD` im http://www.undernet.org/[UNDERNET] ist in den USA unter `us.undernet.org` und in Europa unter `eu.undernet.org` verfügbar. Es handelt sich hierbei um einen Hilfe-Channel, man wird Sie daher auf Dokumente verweisen, die Sie selbst lesen müssen.
* Der Channel `#FreeBSD` im http://www.rusnet.org.ru/[RUSNET] ist ein russischsprachiger Channel, der sich der Unterstützung von FreeBSD-Anwendern verschrieben hat. Er ist auch ein guter Startpunkt für nichttechnische Diskussionen.
* Der Channel `#bsdchat` auf http://freenode.net/[Freenode] (Sprache: traditionelles Chinesisch, UTF-8-kodiert) hat sich der Unterstützung von FreeBSD-Anwendern verschrieben. Er ist auch ein guter Startpunkt für nichttechnische Diskussionen.

Das FreeBSD Wiki enthält eine http://wiki.freebsd.org/IrcChannels[Liste] mit IRC Kanälen.

Alle diese Kanäle unterscheiden sich voneinander und sind nicht miteinander verbunden. Ebenso unterscheiden sich die jeweiligen Chat-Stile, weshalb es sein kann, dass Sie zunächst alle Kanäle ausprobieren müssen, um den zu Ihrem Chat-Stil passenden zu finden.

=== Gibt es irgendwelche webbasierten Foren, in denen FreeBSD diskutiert wird?

Die offiziellen FreeBSD Foren befinden sich unter https://forums.FreeBSD.org/[https://forums.FreeBSD.org/].

=== Gibt es Firmen, die Training und Support für FreeBSD anbieten?

http://www.ixsystems.com[iXsystems, Inc.], die Muttergesellschaft der http://www.freebsdmall.com/[FreeBSD Mall], bietet kommerziellen http://www.ixsystems.com/support[Support] für FreeBSD und TrueOS sowie FreeBSD-spezifische Softwareentwicklung und Hilfe bei Optimierung Ihrer vorhandenen Installationen.

Die BSD Certification Group, Inc. bietet Zertifizierungen zur Systemadministration für DragonFly BSD, FreeBSD, NetBSD und OpenBSD. Besuchen Sie http://www.BSDCertification.org[deren Webseite] für weitere Informationen.

Wenn Ihre Firma oder Organisation ebenfalls Training und Support anbietet und hier genannt werden möchte, wenden Sie sich bitte an das FreeBSD Project.

== Installation

=== Welche Plattform soll ich herunterladen? Ich habe eine 64-Bit-fähige Intel CPU, aber ich sehe nur amd64.

Unter FreeBSD wird der Begriff amd64 für 64-Bit-kompatibel x86-Architekturen verwendet (auch als "x86-64" oder "x64" bekannt). Die meisten modernen Rechner sollten amd64 verwenden. Ältere Hardware sollte i386 verwenden. Wenn Sie FreeBSD auf einer nicht-x86-kompatible Architektur installieren, wählen Sie die Plattform, die am besten mit der verwendeten Hardware übereinstimmt.

=== Welche Datei muss ich herunterladen, um FreeBSD zu bekommen?

Auf der Seite http://www.freebsd.org/de/where/[Download FreeBSD] können Sie das `[iso]` für die entsprechende Hardware wählen.

Sie können eine der folgenden Dateien wählen:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Datei
| Beschreibung

|[.filename]#disc1.iso#
|Enthält die FreeBSD Installation und einen minimalen Satz an Paketen.

|[.filename]#dvd1.iso#
|Ähnlich wie [.filename]#disc1.iso#, aber mit zusätzlichen Paketen.

|[.filename]#memstick.img#
|Enthält ein bootfähiges Image, das Sie auf einem USB-Stick speichern können.

|[.filename]#bootonly.iso#
|Ein minimales Image, das für die Installation von FreeBSD Netzwerkzugriff benötigt.
|===

pc98-Benutzer benötigen drei Floppy-Images: [.filename]#floppies/boot.flp#, [.filename]#floppies/kern1.flp#, [.filename]#floppies/kern2.flp#, und [.filename]#floppies/mfsroot1.flp#. Diese Images müssen mit Hilfe von Werkzeugen wie man:dd[1] auf Disketten kopiert werden.

Eine vollständige Anleitung für dieses Vorgehen und weitere Informationen zur Installation finden Sie im link:{handbook}#bsdinstall[Handbucheintrag zur Installation von FreeBSD].

=== Was mache ich, wenn das Image nicht bootet?

Stellen Sie sicher, dass Sie das Image im _binary_-Modus herunterladen, wenn Sie FTP verwenden.

Einige FTP-Clients benutzen als Voreinstellung den _ascii_-Modus und versuchen, alle Zeilenendezeichen an das Zielsystem anzupassen. Dadurch wird das Boot-Image fast immer unbrauchbar. Überprüfen Sie daher die SHA-256 Prüfsumme des heruntergeladenen Boot-Images: wenn diese nicht _genau_ mit der Prüfsumme auf dem Server übereinstimmt, sollten Sie das Image verwerfen und den Download erneut versuchen.

Wenn Sie einen FTP-Client für die Kommandozeile benutzen, geben Sie am FTP-Prompt _binary_ ein, nachdem Sie sich mit dem Server verbunden haben und bevor Sie das Image herunterladen.

=== Wo befinden sich die Anweisungen zur Installation von FreeBSD?

Installationsanleitungen finden Sie im link:{handbook}#bsdinstall/[Handbucheintrag zur Installation von FreeBSD].

=== Was sind die Mindestanforderungen zum Betrieb von FreeBSD?

Der Betrieb von FreeBSD erfordert mindestens einen 486er Prozessor, 64 MB RAM sowie mindestens 1.1 GB an Festplattenspeicher.

=== Wie kann ich ein angepasstes Installationsmedium erstellen?

Individuelle FreeBSD Installationsmedien können über den Bau eines Releases erzeugt werden. Folgen Sie den Anweisungen im Artikel link:{releng}[Release Engineering].

=== Kann Windows neben FreeBSD existieren?

Ja, vorausgesetzt Sie installieren zuerst Windows(TM). Der Bootmanager von FreeBSD kann dann entweder Windows(TM) oder FreeBSD booten. Falls Sie Windows(TM) nach FreeBSD installieren, wird es, ohne zu fragen, den Bootmanager überschreiben. Lesen Sie den nächsten Abschnitt, falls das passieren sollte.

=== Ein anderes Betriebssystem hat meinen Bootmanager zerstört! Wie stelle ich ihn wieder her?

Das hängt vom Bootmanager ab. Der FreeBSD Bootmanager kann mit man:boot0cfg[8] neu installiert werden. Benutzen Sie bspw. folgendes Kommando, um den auf der Platte _ada0_ wiederherzustellen:

[source,bash]
....
# boot0cfg -B ada0
....

Der MBR Bootloader kann mit man:gpart[8] installiert werden:

[source,bash]
....
# gpart bootcode -b /boot/mbr ada0
....

Für anspruchsvollere Situationen, u. a. mit GPT partitionierte Platten, lesen Sie man:gpart[8].

=== Ich habe zur Installation von CD gebootet, aber das Installationsprogramm sagt mir, dass es kein CD-ROM gefunden hat. Wo ist es hin?

Dieses Problem wird üblicherweise durch ein falsch konfiguriertes CD-ROM verursacht. Bei vielen PCs ist das CD-ROM der Slave am zweiten IDE-Controller, ein Master ist nicht vorhanden. Laut ATAPI-Spezifikation ist diese Konfiguration ungültig, aber Windows(TM) verletzt die Spezifikation und das BIOS ignoriert sie, wenn es von einem CD-ROM booten soll. Daher konnten Sie zwar vom CD-ROM booten, während FreeBSD es nicht für die Installation benutzen kann.

Um dieses Problem zu lösen, müssen Sie entweder das CD-ROM als Master an den IDE-Controller anschließen oder dafür sorgen, dass an dem vom CD-ROM genutzten IDE-Controller das CD-ROM als Slave und ein anderes Gerät als Master angeschlossen ist.

=== Muss ich den vollständigen Quellcode installieren?

Im allgemeinen nicht. Es gibt keine Komponenten im Betriebssystem, welche das Vorhandensein des Quellcodes erfordern. Einge Ports, wie package:sysutils/lsof[], werden aber nicht bauen solange der Quellcode nicht installiert ist. Insbesondere dann, wenn der Port ein Kernel-Modul erzeugt oder direkt mit den Strukturen des Kernels arbeitet, müssen die Quellen installiert werden.

=== Muss ich einen Kernel erstellen?

Normalerweise nicht. Der `GENERIC`-Kernel enthält bereits die Treiber, die ein gewöhnlicher Rechner benötigt. man:freebsd-update[8], das Werkzeug zur binären Aktualisierung von FreeBSD, ist jedoch nicht in der Lage angepasste Kernel zu aktualisieren. Dies ist ein weiterer Grund, wenn möglich, den `GENERIC`-Kernel einzusetzen. Für Rechner mit wenig RAM, bspw. eingebettete Systeme, kann es sich lohnen einen kleinen, angepassten Kernel zu erstellen, der nur die erforderlichen Treiber enthält.

=== Soll ich DES, Blowfish oder MD5 zur Verschlüsselung der Passwörter benutzen?

FreeBSD 9 und neuere Versionen verwenden voreingestellt _SHA512_. Für die Abwärtskompatibilität mit älteren Betriebssystemen werden auch noch die weniger sicheren DES Passwörter unterstützt. FreeBSD unterstützt auch noch die Passwort-Formate Blowfish und MD5. Welches Format für neue Benutzer verwendet wird, wird mit `passwd_format` in [.filename]#/etc/login.conf# gesteuert. Mögliche Werte sind `des`, `blf` (falls verfügbar), oder `md5`. Weitere Informationen finden Sie in der Manualpage man:login.conf[5].

=== Wo liegen die Grenzen für FFS-Dateisysteme?

Für FFS Dateisysteme ist die Größe des Dateisystems durch den Arbeitsspeicher abhängig, der benötigt wird um das Dateisystem mit man:fsck[8] zu prüfen. man:fsck[8] benötigt pro Fragment ein Bit, was bei einer Fragmentgröße von 4 KB bis 32 MB Arbeitsspeicher pro Terrabyte Plattenspeicher entspricht. Das bedeutet, dass auf Architekturen, die Userland-Prozesse auf 2 GB beschränken (zum Beispiel bei i386(TM)), man:fsck[8] ein Dateisystem von ~ 60 TB prüfen kann.

Wenn es kein man:fsck[8] Limit gäbe, würde die maximale Größe eines Dateisystems 2 ^ 64 (Blöcke) * 32 KB => 16 Exa * 32 KB => 512 ZettaBytes betragen.

Die maximale Größer einer einzelnen FFS-Datei würde mit einer Standard-Blockgröße von 32 KB in etwa 2 Petabyte betragen. Jeder 32 KB-Block kann auf bis zu 4096 Blöcke verweisen. Mit dreifacher Indirektion ist die Berechnung 32 KB * 12 + 32 KB * 4096 + 32 KB * 4096 ^ 2 + 32 KB * 4096 ^ 3. Eine Erhöhung der Blockgröße auf 64 KB wird die maximale Dateigröße um den Faktor 16 erhöhen.

=== Wieso erhalte ich die Fehlermeldung readin.failed, nachdem ich einen neuen Kernel erstellt und gebootet habe?

Das System und der Kernel sind nicht synchron. Dies wird nicht unterstützt. Stellen Sie sicher, dass Sie `make buildworld` und `make buildkernel` zum Aktualisieren des Kernels benutzen.

Starten Sie das System und wählen Sie den Kernel während der zweiten Bootphase aus. Drücken Sie dazu eine beliebige Taste, wenn das Zeichen `|` erscheint und bevor der Loader gestartet wird.

=== Gibt es ein Programm, mit dem ich nach der Installation weitere Konfigurationen ausführen kann?

Ja. bsdconfig bietet eine einfache Oberfläche zur Konfiguration von FreeBSD.

== Hardware-Kompatibilität

[[compatibility-general]]
== Allgemeines

=== Ich will mir neue Hardware für mein FreeBSD-System zulegen. Welches Modell/Hersteller/Typ ist das Beste?

Diese Frage wird ständig auf den FreeBSD-Mailinglisten diskutiert. Da sich die Hardware ständig ändert, ist das allerdings keine Überraschung. Lesen Sie die Hardware-Informationen für FreeBSD http://www.FreeBSD.org/releases/11.0r/hardware/[11.0] oder http://www.FreeBSD.org/releases/10.3r/hardware/[10.3] und durchsuchen Sie die Mailinglisten-link:http://www.FreeBSD.org/search/#mailinglists[Archive], bevor Sie nach der neuesten/besten Hardware fragen. Oft gab es kurz zuvor eine Diskussion über genau die Hardware, die Sie sich zulegen wollen.

Befor Sie sich einen Laptop zulegen, sollten Sie einen Blick in das Archiv der http://lists.FreeBSD.org/mailman/listinfo/freebsd-mobile[Mailingliste FreeBSD laptop computer] werfen. Ansonsten empfiehlt sich ein Blick in das Archiv von http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions[FreeBSD general questions] oder auch einer spezialisierte Mailingliste für diese Art von Hardware.

=== Was sind die Grenzen für Arbeitsspeicher? Unterstützt FreeBSD mehr als 4 GB RAM? Mehr als 16 GB? Mehr als 48 GB?

Generell unterstützt FreeBSD als Betriebssystem so viel physischen Speicher (RAM), wie die Plattform auf der es läuft. Beachten Sie, dass verschiedene Plattformen unterschiedliche Speichergrenzen besitzen. So wird z.B. i386(TM) ohne PAE höchstens 4 GB Speicher (normalerweise weniger als das wegen des PCI-Adressraums), dagegen wird i386(TM) mit PAE höchstens 64 GB Speicher bereitstellen. Seit FreeBSD 10 können AMD64 Plattformen bis zu 4 TB physischen Speicher ansprechen.

=== Warum zeigt FreeBSD weniger als 4 GB Speicher an, wenn es auf einer i386 Maschine installiert wird?

Der Gesamtadressraum beträgt auf i386(TM) Maschinen 32-Bit, was bedeutet, dass maximal 4 GB Speicher adressiert (verwaltet) werden kann. Weiterhin sind viele Adressen in diesem Bereich von der Hardware für bestimmte Aufgaben reserviert, um z.B. PCI-Geräte zu benutzen und zu steuern, auf Videospeicher zuzugreifen und so weiter. Aus diesem Grund ist die Gesamtmenge an Speicher, die vom Betriebssystem für den Kernel und Anwendungen verwendet werden kann, auf wesentlich weniger als 4 GB begrenzt. Normalerweise sind 3.2 GB bis 3.7 GB das Maximum an verfügbarem Speicher in dieser Konfiguration.

Um auf mehr als 3.2 GB bis 3.7 GB des installierten Speichers (was bis zu 4 GB, aber aber auch mehr als 4 GB bedeuten kann) zuzugreifen, muss eine spezielle Manipulation, genannt PAE, benutzt werden. PAE steht für Physical Address Extension und ist eine Möglichkeit für 32-Bit x86-CPUs mehr als 4 GB Speicher zu addressieren. Es organisiert den Speicher, der andererseits wegen Adressreservierungen für Hardwaregeräte oberhalb der 4 GB Grenze liegt, um und benutzt diesen als zusätzlichen physischen Speicher (lesen Sie dazu man:pae[4]). Der Einsatz von PAE ist mit ein paar Nachteilen verbunden: diese Speicherzugriffsmethode ist ein bisschen langsamer als die normale Methode (ohne PAE) und ladbare Module (siehe man:kld[4]) werden nicht unterstützt. Das bedeutet, dass alle Treiber in den Kernel eingebaut sein müssen.

Die am häufigsten verwendete Vorgehensweise, PAE zu aktivieren ist die, einen neuen Kernel mit der speziell dafür vorgesehenen Kernelkonfigurationsdatei, [.filename]#PAE# genannt, zu bauen, die bereits so eingestellt ist, dass ein funktionierender Kernel erstellt wird. Beachten Sie, dass manche Einträge in dieser Kernelkonfigurationsdatei zu konservativ eingestellt sind und dass manche Treiber, die nicht für den Einsatz mit PAE vorgesehen sind, trotzdem funktionieren. Als Faustregel kann man sagen, dass wenn der Treiber auf 64-Bit Architekturen (like AMD64) läuft, er auch mit PAE lauffähig ist. Wenn Sie einen angepassten Kernel erstellen, können Sie PAE aktivieren, indem Sie die folgende Zeile in die Konfiguration hinzufügen:

[.programlisting]
....
options       PAE
....

PAE wird heutzutage nicht sehr häufig verwendet, da die Mehrzahl an neuer x86-Hardware auch den Betrieb im 64-Bit Modus erlaubt, auch als AMD64 oder Intel(TM) 64 bekannt. Es hat viel mehr Adressraum und benötigt solche Manipulationen nicht. FreeBSD unterstützt AMD64 und es wird empfohlen, diese FreeBSD Version anstatt der i386(TM) Version einzusetzen, wenn 4 GB oder mehr Speicher gebraucht werden.

[[compatibility-processors]]
== Architekturen und Prozessoren

=== Unterstützt FreeBSD neben x86 auch andere Architekturen?

Ja. FreeBSD teilt die Unterstützung in sogenannte Tiers auf. Tier-1 Architekturen, wie i386 oder amd64 werden vollständig unterstützt. Tier-2 und Tier-3 werden auf der "Best-Effort Basis" unterstützt. Eine vollständige Erklärung dieser Aufteilung finden Sie im link:{committers-guide}#archs[Committer's Guide].

Eine vollständige Liste der unterstützten Architekturen finden Sie auf der Seite http://www.FreeBSD.org/de/platforms/[Unterstützte Plattformen].

=== Unterstützt FreeBSD Symmetric-Multiproccessing (SMP)?

FreeBSD unterstützt Symmetric-Multiproccessing(SMP) auf allen nicht-Embedded-Plattformen (z.B. i386, amd64, etc.). SMP wird auch in ARM- und MIPS-Kernel unterstützt, obwohl einige CPUs dies vielleicht nicht unterstützen. FreeBSDs SMP-Implementierung verwendet präzises Locking und die Leistung skaliert nahezu linear mit der Anzahl der CPUs.

man:smp[4] enthält weitere Informationen.

=== Was ist Mikrocode ? Wie kann ich Intel CPU Microcode Updates installieren?

Mikrocode ist eine Methode um Anweisungen auf Hardware-Ebene programmatisch zu implementieren. Dies ermöglicht es, CPU-Fehler ohne Austausch des Chips zu beheben.

Installieren Sie package:sysutils/devcpu-data[] und fügen Sie:

[.programlisting]
....
microcode_update_enable="YES"
....

in [.filename]#/etc/rc.conf# ein.

[[compatibility-drives]]
== Festplatten, Bandlaufwerke, sowie CD- und DVD-Laufwerke

=== Welche Arten von Festplatten werden von FreeBSD unterstützt?

FreeBSD unterstützt EIDE-, SATA-, SCSI- und SAS-Laufwerke (mit kompatiblen Controllern - siehe folgenden Abschnitt), sowie alle Laufwerke, die die original "Western Digital"-Schnittstelle (MFM, RLL, ESDI und natürlich IDE) benutzen. Ein paar ESDI-Controller benutzen proprietäre Schnittstellen und laufen eventuell nicht: halten Sie sich an WD1002/3/6/7-Schnittstellen und Clones.

=== Welche SCSI- oder SAS-Controller werden unterstützt?

Sie finden eine vollständige und aktuelle Liste in den Hardware-Informationen zu FreeBSD http://www.FreeBSD.org/releases/11.0r/hardware/[11.0] oder http://www.FreeBSD.org/releases/9.3r/hardware/[9.3].

=== Welche Arten von Bandlaufwerken werden unterstützt?

FreeBSD unterstützt alle gängigen SCSI-Bandlaufwerke

=== Unterstützt FreeBSD Bandwechsler?

FreeBSD unterstützt SCSI-Bandwechsler über das Gerät man:ch[4] und das Kommando man:chio[1]. Details zum Betrieb des Wechslers finden Sie in man:chio[1].

Falls Sie nicht AMANDA oder ein anderes Produkt benutzen, das den Wechsler bereits kennt, bedenken Sie, dass die Programme nur wissen, wie sie ein Band von einem Punkt zu einem anderen bewegen müssen. Sie selbst müssen sich also merken, in welchem Einschub sich ein Band befindet und zu welchem Einschub das Band, das sich gerade im Laufwerk befindet, zurück muss.

=== Welche CD-ROM-Laufwerke werden von FreeBSD unterstützt?

Jedes an einem unterstützten Controller angeschlossene SCSI-Laufwerk wird unterstützt. Zudem werden die meisten ATAPI kompatiblen IDE CD-ROMs unterstützt.

FreeBSD unterstützt jedes ATAPI kompatible IDE CD-R- oder CD-RW-Laufwerk. Weitere Details finden Sie in der Manualpage man:burncd[8].

FreeBSD unterstützt zudem jedes SCSI CD-R- oder CD-RW-Laufwerk. Installieren Sie den Port oder das Paket package:sysutils/cdrtools[] und benutzen Sie dann `cdrecord`.

[[compatibility-kbd-mice]]
== Tastaturen und Mäuse

[[moused]]
=== Kann die Maus außerhalb des X Window Systems benutzt werden?

Falls Sie den Konsolentreiber man:syscons[4] benutzen, können Sie den Mauszeiger auf Textkonsolen zum Kopieren und Einfügen von Text verwenden. Starten Sie den Mausdaemon man:moused[8] und schalten Sie den Mauszeiger auf der virtuellen Konsole ein:

[source,bash]
....
# moused -p /dev/xxxx -t yyyy
# vidcontrol -m on
....

_xxxx_ ist der Gerätename der Maus und _yyyy_ ist das Protokoll. Der Mausdaemon erkennt die Protokolle der meisten Mäuse (mit Ausnahme alter serieller Mäuse) automatisch, wenn Sie `auto` für das Protokoll angeben. Falls das Protokoll nicht automatisch erkannt wird, finden Sie die unterstützten Protokolle in der man:moused[8] Manualpage.

Wenn Sie eine PS/2-Maus besitzen und diese beim Systemstart aktivieren wollen, fügen Sie `moused_enable="YES"` in [.filename]#/etc/rc.conf# ein. Falls Sie den Mausdaemon auf allen virtuellen Bildschirmen anstatt nur auf der Konsole benutzen wollen, tragen Sie außerdem `allscreens_flags="-m on"` in [.filename]#/etc/rc.conf# ein.

Während der Mausdaemon läuft, muss der Zugriff auf die Maus zwischen dem Mausdaemon und anderen Programmen, wie X Windows, koordiniert werden. Die FAQ<<x-and-moused,Warum funktioniert meine meine Maus unter X nicht?>> enthält weitere Details.

=== Wie funktioniert das Kopieren und Einfügen von Text mit der Maus auf einer Textkonsole?

Sobald der Mausdaemon ausgeführt, wie in der <<moused,vorherigen Frage>> beschrieben, ausgeführt wird, können Sie die linke Maustaste benutzen um Text zu kopieren. Drücken Sie dann die mittlere Maustaste, um den Text an der Cursorposition einzufügen. Mit der rechten Maustaste kann der markierte Bereich "erweitert" werden.

Wenn Sie keine 3-Tasten-Maus besitzen, können Sie die mittlere Maustaste mit einer Tastenkombination emulieren oder die Funktion der mittleren Taste auf eine andere Taste legen. Einzelheiten dazu enthält die Manualpage man:moused[8].

=== Meine Maus hat ein neumodisches Rad und mehr Knöpfe. Kann ich sie in FreeBSD benutzen?

Unglücklicherweise lautet die Antwort: "Vielleicht". Solche Mäuse mit zusätzlichen Extras erfordern in den meisten Fällen spezielle Treiber. Wenn der Gerätetreiber für die Maus oder das Anwendungsprogramm keine spezielle Unterstützung für die Maus bietet, wird sie sich wie eine gewöhnliche Maus mit zwei oder drei Knöpfen verhalten.

Ob und wie Sie das Rad unter X benutzen können, können Sie im <<x-and-wheel,passenden Abschnitt>> der FAQ erfahren.

=== Wie kann ich die Delete-Taste in der sh und csh einsetzen?

Für die Bourne Shell fügen Sie die folgende Zeile in [.filename]#.shrc# ein. Lesen Sie dazu auch die Manualpages man:sh[1] und man:editrc[5].

[.programlisting]
....
bind ^? ed-delete-next-char # for console
bind ^[[3~ ed-delete-next-char # for xterm
....

Für die C Shell nehmen Sie hingegen die folgende Zeile in [.filename]#.cshrc#. Lesen Sie dazu auch die Manualpage man:csh[1].

[.programlisting]
....
bindkey ^? delete-char # for console
bindkey ^[[3~ delete-char # for xterm
....

Weitere Informationen zu diesem Thema finden Sie auf http://www.ibb.net/\~anne/keyboard.html[dieser Seite].

[[compatibility-other]]
== Sonstige Hardware

=== Abhilfe für fehlenden Sound bei Verwendung des pcm4-Treibers?

Einige Soundkarten setzen die Lautstärke bei jedem Systemstart auf 0. In diesem Fall müssen Sie nach jedem Bootvorgang den folgenden Befehl ausführen:

[source,bash]
....
# mixer pcm 100 vol 100 cd 100
....

=== Unterstützt FreeBSD Power-Management auf meinem Laptop?

FreeBSD unterstützt die ACPI-Funktionen moderner Hardware. Weitere Informationen dazu finden Sie in man:acpi[4].

== Fehlerbehebung

=== Warum zeigt FreeBSD eine falsche Speichergröße auf i386 Hardware an?

Das liegt sehr wahrscheinlich an den Unterschieden zwischen physikalischen und virtuellen Speicheradressen.

Bei moderner PC-Hardware ist es üblich, den Speicherbereich zwischen 3,5 und 4 Gigabyte für spezielle Aufgaben (normalerweise für PCI) zu reservieren. Dieser Adressbereich wird dabei verwendet, um auf PCI-Hardware zuzugreifen. Dadurch kann in diesem Speicherbereich kein physikalischer Speicher verwaltet werden.

Was mit dem in diesen Bereich gehörenden physikalischen Speicher passiert, hängt von der eingesetzten Hardware ab. Unglücklicherweise gibt es noch immer Hardware, die hier gar nichts macht. In diesem Fall ist das System nicht in der Lage, auf diese 500 MB des RAMs zuzugreifen.

Ein Großteil der Hardware ist aber inzwischen in der Lage, diesen Speicherbereich in einen höheren Speicherbereich umzulenken, damit Sie weiterhin darauf zugreifen können. Allerdings kann es durch dieses Umlenken zu verwirrenden Meldungen während des Systemstarts kommen.

Unter 32-Bit-Versionen von FreeBSD scheint dieser Speicherbereich nicht verfügbar zu sein, da er in einen Bereich oberhalb von 4 Gigabyte übertragen wurde, auf den ein 32-Bit-Kernel allerdings nicht zugreifen kann. In diesem Fall müssen Sie die PAE-Unterstützung in den Kernel kompilieren. Lesen Sie dazu auch die entsprechenden Einträge über Speicherbegrenzungen und unterschiedliche Speicherbegrenzungen auf verschiedenen Plattformen.

Verwenden Sie hingegen eine 64-Bit-Version von FreeBSD oder einen 32-Bit-Kernel mit aktivierter PAE-Unterstützung, ist FreeBSD in der Lage, diesen Speicherbereich korrekt zu erkennen und umzulenken, damit Sie weiterhin darauf zugreifen können. Allerdings wird, aufgrund der beschriebenen Umbelegung, in diesem Fall beim Systemstart mehr Speicher angezeigt, als tatsächlich auf dem System vorhanden ist. Dies ist aber normal und wird nach dem Ende des Systemstarts automatisch korrigiert.

=== Wieso brechen meine Programme gelegentlich mit Signal 11-Fehlern ab?

Das Signal 11 wird generiert, wenn ein Prozess versucht, auf Speicher zuzugreifen, obwohl er vom Betriebssystem dazu nicht befugt wurde. Wenn das scheinbar zufällig immer wieder passiert, sollten Sie der Sache auf den Grund gehen.

Das Problem hat in der Regel eine der folgenden Ursachen:

. Wenn das Problem nur in einer bestimmten Anwendung auftritt, dann ist es wahrscheinlich ein Fehler im Quellcode.
. Wenn das Problem in einem Teil von FreeBSD auftritt, könnte es natürlich auch ein Fehler sein; aber in den meisten Fällen werden diese Probleme gefunden und behoben, bevor die typischen Leser der FAQ diese Teile des Codes benutzen können (dafür gibt es schließlich -CURRENT).

Wenn der Fehler auftritt, wenn Sie ein Programm kompilieren aber dabei immer wieder an anderer Stelle auftritt, dann ist das ein ganz eindeutiger Hinweis, dass das Problem nicht bei FreeBSD liegt.

Nehmen wir zum Beispiel an, dass Sie `make buildworld` ausführen und die Kompilierung von [.filename]#ls.c# in [.filename]#ls.o# abbricht. Wenn Sie nochmal `make buildworld` ausführen und die Kompilierung an der gleichen Stelle abbricht, handelt es sich um einen Fehler im Quellcode. Aktualisieren Sie den Code und versuchen Sie es noch einmal. Wenn der Fehler jedoch an einer anderen Stelle auftritt, liegt das Problem mit an Sicherheit grenzender Wahrscheinlichkeit bei der Hardware.

Im ersten Fall können Sie einen Debugger wie z.B. man:gdb[1] benutzen, um die Stelle im Programm zu finden, an der auf eine falsche Adresse zugegriffen wird und danach den Fehler beheben.

Im zweiten Fall müssen Sie sicherstellen, dass das Problem nicht von der Hardware verursacht wird.

Typische Ursachen dafür sind:

. Es könnte sein, dass die Festplatten zu warm werden: Überprüfen Sie, ob die Lüfter noch funktionieren, damit Festplatten und andere Hardware nicht heißlaufen.
. Der Prozessor überhitzt, weil er übertaktet wurde oder der CPU-Kühler ausgefallen ist. Sie müssen sicherstellen, dass Sie die Hardware unter den Bedingungen betreiben, für die sie spezifiziert ist, zumindest während Sie versuchen, das Problem zu lösen. Mit anderen Worten: Betreiben Sie Ihre CPU mit der normalen Taktfrequenz.
+ 
Wenn Sie übertakten, sollten Sie daran denken, dass ein langsames System deutlich billiger ist als ein defektes System. Zudem hat die Community wenig Mitgefühl bei Problemen mit übertakteten Systemen.
. Unzuverlässiger Speicher: Wenn im Rechner mehr als ein SIMM/DIMM installiert ist, sollten Sie sie alle ausbauen und die Maschine testweise mit jedem SIMM oder DIMM einzeln betreiben. So können Sie feststellen, ob die Ursache ein einzelnes SIMM/DIMM oder auch eine Kombination von Modulen ist.
. Zu optimistische Einstellung des Mainboards: In den Einstellungen des BIOS und mit den Jumpern auf dem Mainboard können Sie diverse Timings ändern. In den meisten Fällen reichen die Voreinstellungen aus, aber manchmal kann es durch zu wenig "wait states", die Einstellung "RAM Speed: Turbo" oder ähnliches zu merkwürdigen Problemen kommen. Ein möglicher Ansatz ist, die Voreinstellungen des BIOS zu laden. Hierbei ist es sinnvoll, vorher die aktuellen Einstellungen zu notieren
. Schlechte oder fehlerhafte Stromversorgung des Mainboards: Wenn Sie unbenutzte Steckkarten, Platten oder CD-ROMs in Ihrem System haben, sollten Sie sie testweise ausbauen oder die Stromversorgung abziehen. Dadurch können Sie prüfen, ob das Netzteil eventuell mit einer geringeren Last besser zurechtkommt. Sie können auch testweise ein anderes, am besten ein leistungsfähigeres, Netzteil ausprobieren. Wenn Sie zurzeit ein 250 W-Netzteil benutzen, sollten Sie testweise ein 300 W-Netzteil einbauen.

Lesen Sie den Abschnitt <<signal11,Signal 11>> für weitere Erklärungen. Es existiert eine ausführliche FAQ hierzu unter http://www.bitwizard.nl/sig11/[the SIG11 problem FAQ].

Wenn alle diese Schritte nicht helfen, ist es möglich, dass Sie einen Fehler in FreeBSD gefunden haben. Folgen Sie einfach <<access-pr,diesen Anweisungen>> für die Erstellung eines Problem Reports.

=== Mein System stürzt mit der Meldung Fatal trap 12: page fault in kernel mode oder panic: ab und gibt eine Menge zusätzlicher Informationen aus. Was kann ich tun?

Die Entwickler von FreeBSD interessieren sich für solchen Meldungen, allerdings brauchen Sie deutlich mehr Informationen als nur die Fehlermeldung. Kopieren Sie die kompletten Meldungen und lesen Sie anschließend den FAQ-Abschnitt über <<kernel-panic-troubleshooting,kernel panics>>. Erzeugen sie einen Kernel mit den zusätzlichen Daten zur Fehlersuche, und dann einen Backtrace. Das hört sich komplizierter an, als es ist. Sie brauchen keine Programmier-Erfahrung, Sie müssen einfach nur den Anweisungen folgen.

=== Was bedeutet die Fehlermeldung maxproc limit exceeded by uid %i, please see tuning(7) and login.conf(5)?

Der FreeBSD-Kernel beschränkt die Anzahl der gleichzeitig laufenden Prozesse. Die Anzahl errechnet sich aus dem Wert der `kern.maxusers` man:sysctl[8]-Variable. Auch andere Einstellungen wie die Anzahl der Puffer für Netzwerkoperationen werden durch `kern.maxusers` beeinflusst. Wenn das System stark belastet ist, sollten Sie den Wert von `kern.maxusers` erhöhen. Dadurch werden diverse Einstellungen des Systems angepasst und die maximale Anzahl gleichzeitig laufender Prozesse erhöht.

Um den Wert von `kern.maxusers` anzupassen, folgen Sie den Anweisungen im Abschnitt link:{handbook}#kern-maxfiles[Datei und Prozeß Limits] des Handbuchs. Dieser Abschnitt spricht zwar nur von Dateien, für Prozesse gelten aber die gleichen Beschränkungen.

Wenn das System nicht besonders stark ausgelastet ist und Sie einfach nur mehr gleichzeitig laufende Prozesse erlauben wollen, können Sie den Wert der Variable `kern.maxproc` in [.filename]#/boot/loader.conf# anpassen. Um die Änderung zu aktivieren, müssen Sie das System neu starten. Wollen Sie das System zusätzlich optimieren, sollten Sie man:loader.conf[5] lesen. Wenn diese Prozesse von einem einzigen Benutzer ausgeführt werden, müssen Sie den Wert von `kern.maxprocperuid` ebenfalls erhöhen. Dieser Wert muss immer mindestens um eins geringer sein als der Wert von `kern.maxproc`, weil ein Systemprogramm, man:init[8], immer ausgeführt werden muss.

=== Wieso funktionieren bildschirmorientierte Anwendungen beim Zugriff über ein Netzwerk nicht richtig?

Die entfernte Maschine scheint den Terminaltyp auf etwas anderes als den Typ `xterm`, der von FreeBSD verlangt wird, zu setzen. Vielleicht hat aber auch der Kernel falsche Werte für die Breite und Höhe des Terminals.

Überprüfen Sie, ob der Wert der `TERM`-Umgebungsvariable `xterm` ist. Wenn das entfernte Gerät dies nicht unterstützt, versuchen Sie `vt100`.

Führen Sie `stty -a` aus, um zu überprüfen, was der Kernel für Terminalaußmaße eingestellt hat. Wenn diese Werte falsch sind, können sie mit `stty rows _RR_ cols _CC_` geändert werden.

Falls package:x11/xterm[] installiert ist, können Sie alternativ auch `resize` ausführen, um die richtigen Einstellungen für das Terminal zu setzen.

=== Wieso dauert es so lange, bis eine Verbindung über ssh oder telnet aufgebaut wird?

Das Symptom: Nach dem Aufbau des TCP-Verbindung vergeht einige Zeit, bis endlich die Abfrage des Passwortes (bzw. der Login-Prompt bei man:telnet[1]) erscheint.

Das Problem: In den meisten Fällen versucht der Server die IP-Adresse des Clients in einen Rechnernamen zu übersetzen. Viele Server, darunter die Telnet und SSH-Server von FreeBSD, machen das, um den Hostnamen in eine Protokolldatei zu schreiben.

Die Lösung: wenn das Problem bei jedem Server auftritt, den Sie von dem Computer (dem Client) ansprechen, dann wird das Problem vom Client verursacht. Wenn das Problem aber nur auftritt, wenn jemand den Rechner (den Server) anspricht, dann liegt die Ursache beim Server.

Wenn das Problem vom Client verursacht wird, müssen Sie die Einträge im DNS korrigieren, damit der Server die IP-Adresse übersetzen kann. Wenn das Problem im lokalen Netzwerk auftritt, sollten Sie es als Problem des Servers behandeln und weiterlesen; wenn es allerdings im Internet auftritt, sollten Sie Ihren ISP kontaktieren.

Wenn das Problem vom Server im lokalen Netzwerk verursacht wird, dann müssen Sie den Server so konfigurieren, dass er die lokal genutzten IP-Adressen in Rechnernamen übersetzen kann. Weitere Informationen finden Sie in man:hosts[5] und man:named[8]. Wenn dieses Problem im Internet auftritt, könnte die Ursache auch darin liegen, dass die Namensauflösung auf dem Server nicht funktioniert. Versuchen Sie, einen anderen Hostnamen wie z.B. `www.yahoo.com` aufzulösen. Wenn das nicht funktioniert, ist das System nicht richtig konfiguriert.

Haben Sie FreeBSD gerade erst installiert, kann es auch sein, dass die Domänen- und Nameserverinformationen noch nicht in [.filename]#/etc/resolv.conf# vorhanden sind. Dadurch kommt es häufig zu Verzögerungen beim Einsatz von SSH, weil die Option `UseDNS` in [.filename]#/etc/ssh/sshd_config# in der Voreinstellung auf `yes` gesetzt ist. Wenn dies der Fall, müssen Sie entweder die fehlenden Informationen in [.filename]#/etc/resolv.conf# eintragen oder als temporäre Maßnahme `UseDNS` auf `no` setzen.

=== Warum sehe ich in der Ausgabe von dmesg8 häufig die Meldung file: table is full?

Diese Fehlermeldung besagt, dass die zur Verfügung stehenden Datei-Deskriptoren des Systems aufgebraucht sind. Was das genau bedeutet und wie Sie dieses Problem lösen können, steht im Abschnitt link:{handbook}#kern-maxfiles[kern.maxfiles] im Kapitel link:{handbook}#configtuning-kernel-limits/[Einstellungen von Kernel Limits] des Handbuchs.

=== Warum ist die Uhrzeit auf meinem Rechner immer falsch?

Der Rechner verfügt über mehr als eine Uhr und FreeBSD benutzt leider die falsche.

Starten Sie man:dmesg[8] und achten Sie auf die Zeilen, in denen das Wort `Timecounter` vorkommt. Die von FreeBSD benutzte Uhr findet sich in der Zeile mit dem höchsten quality-Wert.

[source,bash]
....
# dmesg | grep Timecounter
Timecounter "i8254" frequency 1193182 Hz quality 0
Timecounter "ACPI-fast" frequency 3579545 Hz quality 1000
Timecounter "TSC" frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec
....

Sie können das überprüfen, indem Sie den Wert der man:sysctl[3]-Variablen `kern.timecounter.hardware` abfragen.

[source,bash]
....
# sysctl kern.timecounter.hardware
kern.timecounter.hardware: ACPI-fast
....

Es kann sich um einen defekten ACPI-Timer handeln. Die einfachste Lösung besteht darin, den ACPI-Timer in [.filename]#/boot/loader.conf# zu deaktivieren:

[.programlisting]
....
debug.acpi.disabled="timer"
....

Es ist aber auch durchaus möglich, dass das BIOS die TSC-Uhr ändert, um beispielsweise den CPU-Takt zu während des Batteriebetrieb zu ändern, oder im Stromsparmodus; leider bemerkt FreeBSD diese Änderungen nicht und daher scheint die Uhr falsch zu gehen.

In diesem Beispiel ist die Uhr `i8254` ebenfalls verfügbar; um sie auszuwählen, muss ihr Name in die man:sysctl[3]-Variable `kern.timecounter.hardware` geschrieben werden.

[source,bash]
....
# sysctl kern.timecounter.hardware=i8254
kern.timecounter.hardware: TSC -> i8254
....

Die Uhrzeit des Rechners sollte nun genauer funktionieren.

Damit diese Änderung automatisch beim Start des Systems durchgeführt wird, müssen Sie die folgende Zeile in [.filename]#/etc/sysctl.conf# eintragen:

[.programlisting]
....
kern.timecounter.hardware=i8254
....

=== Was bedeutet die Meldung swap_pager: indefinite wait buffer:?

Ein Prozess wollte Speicher auf der Platte auslagern, und dieser Vorgang konnte nicht innerhalb von 20 Sekunden durchgeführt werden. Mögliche Gründe sind defekte Blöcke auf der Platte, falsche oder fehlerhafte Verkabelung sowie Probleme mit anderen Komponenten, die am Zugriff auf die Festplatte beteiligt sind. Wenn die Festplatte selbst fehlerhaft ist, sollten Sie entsprechende Meldungen in [.filename]#/var/log/messages# und der Ausgabe von `dmesg` finden. Andernfalls sollten Sie die Kabel und Verbindungen überprüfen.

=== Was ist ein lock order reversal?

Der FreeBSD-Kernel benutzt eine Reihe von Ressource-Locks, um den Zugriff auf Ressourcen zu regeln. Wenn verschiedene Kernel-Threads versuchen mehrere Ressource-Locks zu bekommen, besteht immer die Gefahr eines Deadlocks. Hierbei haben zwei Threads einen der Resource-Locks erhalten und blockieren sich nun gegenseitig, weil sie darauf warten, dass der jeweils andere Thread den Resource-Lock wieder freigibt. Diese Art von Locking-Problem kann vermieden werden, indem alle Threads die Locks in der gleichen Reihenfolge erhalten.

In FreeBSD-CURRENT (nicht in STABLE- oder RELEASE-Zweigen) befindet sich das Diagnose-System man:witness[4], das potentielle Deadlocks in verschiedenen Teilen des Kernels zur Laufzeit erkennt. Das man:witness[4]-System versucht die Probleme zu erkennen und gibt die Meldung `lock order reversal` (auch bekannt als LOR) auf der Konsole aus.

Weil man:witness[4] sehr konservativ vorgeht, ist es ist möglich, ein False Positive (Fehlalarm) zu erhalten. Eine Meldung bedeutet nicht zwangsläufig, dass das System einen Deadlock hat; Stattdessen sollte es als Warnung verstanden werden, dass hier ein Deadlock passiert sein könnte.

[NOTE]
====
Problematische LORs werden schnell behoben. Prüfen Sie daher http://lists.FreeBSD.org/mailman/listinfo/freebsd-current[FreeBSD-CURRENT mailing list] bevor Sie diese Mailingliste kontaktieren.
====

=== Was hat die Fehlermeldung Called ... with the following non-sleepable locks held zu bedeuten?

Diese Meldung erscheint, wenn eine Funktion, die sich im Ruhemodus befindet, aufgerufen wird, während ein Mutex oder eine andere (nicht in den Ruhemodus versetzbare) Sperre aktiv war.

Der Grund dafür ist, dass ein Mutex nicht für längere Zeitspannen aktiv sein soll, sondern nur für die Synchronisation von Gerätetreibern mit dem Rest des Kernels während eines Interrupts. Unter FreeBSD dürfen Interrupts nicht in den Ruhemodus versetzt werden. Daher ist es von entscheidender Bedeutung, dass während des Bestehens eines Mutex kein Kernelsubsystem für einen längeren Zeitraum blockiert ist.

Um solche Fehler abzufangen, können Sicherungen (Assertions) in den Kernel eingebaut werden, die danach mit dem man:witness[4]-Subsystem interagieren. Dadurch wird (in Abhängigkeit der Systemkonfiguration) eine Warnung oder eine Fehlermeldung ausgegeben, falls der Aufruf einer Funktion während des Bestehens eines Mutex zu einer Blockierung führen kann.

Zusammenfassend kann man sagen, dass diese Warnungen in der Regel zwar nicht bedrohlich sind. Unter bestimmten Umständen kann es aber dennoch zu unerwünschten Nebenwirkungen, angefangen von einer Erhöhung der Reaktionszeit bis hin zu einem kompletten Einfrieren des Systems kommen.

Weitere Informationen zum Locking unter FreeBSD finden Sie in man:locking[9].

=== Warum bricht buildworld/installworld mit der Meldung touch: not found ab?

Dieser Fehler bedeutet nicht, dass man:touch[1] nicht auf dem System vorhanden ist. Vielmehr sind Dateien die Ursache, deren Erzeugungsdatum in der Zukunft liegt. Wenn die CMOS-Uhr auf die lokale Zeit eingestellt ist, müssen Sie `adjkerntz -i` verwenden, um die Kerneluhr anzupassen, wenn Sie in den Single-User-Modus booten.

== Anwendungen

=== Wo finde ich die ganzen Anwendungen?

Informationen zu auf FreeBSD portierten Anwendungen finden Sie auf der https://www.FreeBSD.org/ports/[Ports-Seite]. Die Liste enthält circa 24.000 Pakete und es werden ständig mehr. Sie sollten diese Liste daher im Auge behalten, oder die http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce[FreeBSD announcements Mailingliste] abonnieren und regelmäßig auf neue Einträge prüfen.

Die meisten Ports sollten auf allen unterstützten FreeBSD Versionen lauffähig sein. Nicht funktionierende Ports sind als solche gekennzeichnet. Jedes mal, wenn ein FreeBSD Release erstellt wird, wird ein Snapshot der Ports-Sammlung in [.filename]#ports/# mitgeliefert.

FreeBSD unterstützt für die Installation komprimierte Binärpakete und Ports. Benutzen Sie man:pkg[7] um die Installation von Paketen zu steuern.

=== Wie lade ich die Ports-Sammlung herunter? Soll ich dafür SVN benutzen?

Die folgenden Methoden können verwendet werden:

* In den meisten Situationen sollten Sie portsnap benutzen. Der Abschnitt link:{handbook}#ports-using/[Benutzen der Ports-Sammlung] beschreibt die Verwendung dieses Werkzeugs.
* Verwenden Sie SVN, wenn Sie bestimmte Patches für den Portsbaum benötigen. Lesen Sie link:{handbook}#svn/[Benutzen von Subversion] für weitere Informationen.

=== Unterstützt FreeBSD Java?

Ja. Lesen Sie https://www.FreeBSD.org/java/[http://www.FreeBSD.org/java/] für weitere Informationen.

=== Warum kann ich manche Ports auf meiner 9.X oder 10.X-STABLE-Maschine nicht erstellen?

Wenn Sie eine FreeBSD-Version benutzen, die deutlich älter als das aktuelle _-CURRENT_ oder _-STABLE_ ist, könnte es sein, dass Sie zunächst die Ports-Sammlung aktualisieren müssen. Lesen Sie dazu link:{handbook}#ports-using/[Benutzen der Ports-Sammlung]. Ist die Ports-Sammlung aktuell, könnte es sein, dass jemand eine Änderung am Port durchgeführt hat, die für _-CURRENT_ funktioniert, den Port für _-STABLE_ aber unbrauchbar gemacht hat. Bitte senden Sie einen https://bugs.FreeBSD.org/submit/[Fehlerbericht]. Von der Ports-Sammlung wird nämlich erwartet, dass sie sowohl auf _-CURRENT_ als auch auf _-STABLE_ funktioniert.

=== Ich habe gerade versucht, INDEX mit make index zu bauen, und es hat nicht geklappt. Woran liegt das?

Stellen Sie zuerst sicher, dass die Ports-Sammlung aktuell ist. Fehler, die einen Bau von [.filename]#INDEX# aus einer aktuellen Ports-Sammlung verhindern, sind sofort sichtbar und werden daher fast immer umgehend behoben.

Es gibt seltene Fälle, in denen [.filename]#INDEX# nicht gebaut werden kann, wenn bestimmte `WITH__*_` oder `WITHOUT__*_` Variablen in [.filename]#make.conf# gesetzt sind. Wenn Sie dieses Problem haben, sollten Sie diese make-Variablen deaktivieren und [.filename]#INDEX# erneut bauen, bevor Sie das Problem an die http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports[FreeBSD Ports Mailingliste] melden.

=== Ich habe die Quellen aktualisiert, wie aktualisiere ich jetzt die installierten Ports?

FreeBSD enthält zwar kein Programm, das die installierten Ports aktualisiert, allerdings existieren diverse Programme, die diesen Prozess etwas vereinfachen. Weiterhin können Sie zusätzliche Programme installieren, die Sie dabei unterstützen. Lesen Sie das Kapitel link:{handbook}#ports-using/[Benutzen der Ports-Sammlung] im FreeBSD Handbuch.

=== Muss ich nach der Aktualisierung einer FreeBSD-Hauptversion jedes Mal alle Ports neu erstellen?

Ja! Obwohl ein aktuelles System mit Software für eine ältere Version funktionieren wird, werden Sie mit zufälligen Abstürzen und nicht funktionierenden Ports zurückbleiben, sobald Sie anfangen, andere Ports zu installieren oder diejenigen, die Sie bereits haben, aktualisieren möchten.

Wenn das System aktualisiert wird, werden verschiedene Shared-Libraries, ladbare Module und andere Systembestandteile durch neuere Versionen ersetzt. Anwendungen, die gegen die älteren Versionen gelinkt sind, werden nicht starten oder in anderen Fällen nicht korrekt funktionieren.

Für weitere Informationen lesen Sie den Abschnitt link:{handbook}#freebsdupdate-upgrade[FreeBSD-Update] im FreeBSD Handbuch.

=== Muss ich nach der Aktualisierung einer FreeBSD-Unterversion jedes Mal alle Ports neu erstellen?

Generell nicht. Die FreeBSD-Entwickler tun ihr möglichstes, um die Binärkompatibilität über alle Veröffentlichungen mit der gleichen Hauptversionsnummer zu garantieren. Ausnahmen werden in den Release Notes dokumentiert und die darin enthaltenen Hinweise sollten befolgt werden.

=== Warum ist /bin/sh so spartanisch? Warum benutzt FreeBSD nicht die bash oder eine andere Shell?

Viele Leute müssen Shell-Programme schreiben, die auf vielen verschiedenen Systemen nutzbar sein müssen. Aus diesem Grund enthält der POSIX(TM)-Standard eine sehr detaillierte Definition der Shell und der Hilfsprogramme. Die meisten Programme werden für die Bourne Shell (man:sh[1]) geschrieben; außerdem nutzen mehrere wichtige Schnittstellen (man:make[1], man:system[3], man:popen[3] und höhere Programmiersprachen wie Perl und Tcl) die Bourne Shell, um Befehle auszuführen. Da die Bourne Shell an so vielen Stellen und so häufig genutzt wird, muss sie die folgenden Anforderungen erfüllen: Schneller Start, ein klar definiertes Verhalten und ein geringer Speicherverbrauch.

Wir haben bei der vorliegenden Implementierung versucht, möglichst viele dieser Anforderungen zu erfüllen. Um `/bin/sh` nicht zu groß werden zu lassen, haben wir viele der Annehmlichkeiten der anderen Shells weggelassen. Aus diesem Grund gibt stehen die luxuriöseren Shells wie `bash`, `scsh`, man:tcsh[1] und `zsh` zur Verfügung. Vergleichen Sie den Speicherverbrauch der verschiedenen Shells, indem Sie `ps -u` aufrufen und sich die Angaben in den Spalten "VSZ" und "RSS" ansehen.

=== Wie erzeuge ich Audio-CDs aus MIDI-Dateien?

Installieren Sie zuerst den Port package:audio/timidity[]. Danach müssen Sie manuell die GUS-Patche von Eric A. Welsh von http://alleg.sourceforge.net/digmid.html[http://alleg.sourceforge.net/digmid.html]. installieren. Wenn TiMidity++ richtig installiert wurde, können Sie mit dem folgenden Kommando MIDI-Dateien in das WAV-Format konvertieren:

[source,bash]
....
% timidity -Ow -s 44100 -o /tmp/juke/01.wav 01.mid
....

Die WAV-Dateien können dann in andere Formate konvertiert werden oder (wie im link:{handbook}#creating-cds/[FreeBSD Handbuch]. beschrieben) auf Audio-CDs gebrannt werden.

== Kernelkonfiguration

[[make-kernel]]
=== Ich möchte meinen Kernel anpassen. Ist das schwierig?

Überhaupt nicht! Lesen Sie den link:{handbook}#kernelconfig/[Abschnitt zur Kernelkonfiguration im Handbuch].

[NOTE]
====
Der neue [.filename]#kernel# wird zusammen mit seinen Modulen im Verzeichnis [.filename]#/boot/kernel# installiert werden. Der alte Kernel und dessen Module wird in das Verzeichnis [.filename]#/boot/kernel.old# verschoben, damit Sie, wenn Sie einen Fehler in Ihrer Konfiguration haben, die vorherige Version des Kernels starten können.
====

=== Warum ist mein Kernel so groß?

FreeBSDs `GENERIC`-Kernels werden im _Debug-Modus_ erstellt. Ein Debug-Kernel enthält viele zusätzliche Informationen für die Fehlersuche. In FreeBSD 11.0 und neueren Versionen werden diese Debug-Dateien in [.filename]#/usr/lib/debug/boot/kernel# gespeichert. Ältere Versionen von FreeBSD speichern diese Dateien im selben Verzeichnis wie den Kernel, [.filename]#/boot/kernel#. Bitte beachten Sie, dass die Verwendung eines Debug-Kernels die Performance des Systems nicht oder nur minimal reduziert; außerdem ist es für den Fall einer system panic sehr praktisch, einen Debug-Kernel zur Hand zu haben.

Wenn Ihnen allerdings der Plattenplatz ausgeht, gibt es verschiedene Möglichkeiten die Größe von [.filename]#/boot/kernel/# und [.filename]#/usr/lib/debug/# zu reduzieren.

Um die Kernel-Symbole nicht zu installieren, nehmen Sie folgende Zeile in [.filename]#/etc/src.conf# auf:

[.programlisting]
....
WITHOUT_KERNEL_SYMBOLS=yes
....

Weitere Informationen finden Sie in man:src.conf[5].

Wenn Sie überhaupt keine Debug-Dateien erzeugen möchten, müssen Sie folgendes sicherstellen:

* Die folgende Zeile darf nicht in der Kernelkonfigurationsdatei enthalten sein:
+
[.programlisting]
....
makeoptions DEBUG=-g
....

* Rufen Sie nicht man:config[8] mit `-g` auf.

Jede der oben genannten Einstellungen bewirkt, dass der Kernel im Debug-Modus erstellt wird.

Um nur die angegebenen Module zu erstellen und zu installieren, nehmen Sie diese in [.filename]#/etc/make.conf# auf:

[.programlisting]
....
MODULES_OVERRIDE= accf_http ipfw
....

Ersetzen Sie _accf_httpd ipfw_ durch die gewünschten Module. Nur aufgelistete Module werden gebaut. Dies reduziert die Größe des Kernel-Verzeichnisses sowie die benötigte Zeit, um den Kernel zu übersetzen.

Um die Größe des Kernels weiter zu reduzieren, können nicht benötigte Geräte aus dem Kernel entfernt werden. <<make-kernel>> enthält weitere Informationen.

Um eine dieser Optionen in Kraft zu setzen, folgen Sie den Anweisungen zum link:{handbook}#kernelconfig-building/[Erstellen und Installieren] eines neuen Kernels.

Der FreeBSD 11 amd64 Kernel ([.filename]#/boot/kernel/kernel#) ist circa 25 MB groß.

=== Wieso kann ich nicht einmal den Standard-Kernel (GENERIC) bauen?

Es gibt eine Reihe von möglichen Ursachen für dieses Problem:

* Der Quellbaum unterscheidet sich von dem, der verwendet wird, um das aktuell laufende System zu erstellen. Wenn Sie ein Upgrade durchführen, lesen Sie [.filename]#/usr/src/UPDATING# und achten Sie besonders auf den Abschnitt "COMMON ITEMS" am Ende.
* Beim Kommando `make buildworld` sind Fehler aufgetreten. Um seine Arbeit erledigen zu können, benötigt `make buildkernel` Dateien, die von `make buildworld` erzeugt werden.
* Auch wenn Sie <<stable,FreeBSD-STABLE>> verwenden, ist es durchaus möglich, dass Sie die Quellen genau zum falschen Zeitpunkt aktualisiert haben: Während Sie gerade modifiziert wurden oder kurzzeitig fehlerhaft waren. Eine Garantie, dass Sie die Quellen übersetzen können, gibt es nur für die Releases, bei <<stable,FreeBSD-STABLE>> ist das nicht immer so. Versuchen Sie, die Quellen nochmals zu aktualisieren. Es ist denkbar, dass der von Ihnen genutzte Server zurzeit Probleme hat, benutzen Sie daher auch einmal einen anderen Server.

=== Wie kann ich prüfen, welchen Scheduler das System benutzt?

Der Name des aktuell verwendeten Schedulers steht in der sysctl-Variablen `kern.sched.name`:

[source,bash]
....
sysctl`kern.sched.name`
kern.sched.name: ULE
....

=== Was bedeutet kern.sched.quantum?

`kern.sched.quantum` ist die maximale Anzahl Ticks, die ein Prozess im 4BSD-Scheduler ununterbrochen laufen kann.

== Festplatten, Dateisysteme und Boot Loader

=== Wie kann ich meine neue Festplatte in mein FreeBSD-System einbinden?

Lesen Sie den Abschnitt link:{handbook}#disks-adding/[Hinzufügen von Laufwerken] im Handbuch.

=== Wie verschiebe ich mein System auf meine neue, große Platte?

Die beste Methode ist, das Betriebssystem auf der neuen Platte zu installieren und danach die Daten zu verschieben. Diese Methode ist sehr empfehlenswert, wenn Sie _-STABLE_ über ein Release hinaus genutzt haben oder ein Release aktualisiert haben. Sie können man:boot0cfg[8] auf beiden Platten installieren und die beiden Versionen so lange parallel betreiben, bis Ihnen die neue Konfiguration gefällt. Wenn Sie dies tun wollen, können Sie im übernächsten Absatz erfahren, wie sie Ihre Daten verschieben können.

Alternativ können Sie die neue Platte entweder mit man:sade[8] oder man:gpart[8] partitionieren und labeln. Wenn die Festplatten mit MBR formatiert sind, kann booteasy auf beiden Festplatten mit man:boot0cfg[8] installiert werden, damit der Rechner nach dem Kopieren das alte oder neue System booten kann.

Sobald die neue Festplatte eingerichtet ist, können die Daten nicht einfach kopiert werden. Verwenden Sie stattdessen Werkzeuge, die Gerätedateien und Dateiattribute verstehen, z. B. man:dump[8]. Obwohl empfohlen wird, die Daten im Einzelbenutzermodus zu verschieben, ist dies nicht zwingend erforderlich.

Wenn die Festplatten mit UFS formatiert sind, verwenden Sie ausschließlich man:dump[8] und man:restore[8], um das Root-Dateisystem zu verschieben. Diese Befehle sollten auch beim Verschieben einer einzelnen Partition in eine andere, leere Partition verwendet werden. Um die Daten einer UFS-Partition auf eine andere Partition zu verschieben, müssen Sie die folgenden Schritte ausführen:

[.procedure]
====
. Richten Sie in der neuen Partition mit `newfs` ein Dateisystem ein.
. `mount` en Sie die Partition temporär an einer geeigneten Stelle.
. Wechseln Sie mit `cd` in dieses Verzeichnis.
. Lesen Sie die alte Partition mit `dump` aus und lenken Sie die Ausgabe auf die neue Partition um.
====

Wenn Sie zum Beispiel das Root-Dateisystem auf [.filename]#/dev/ad1s1a# verschieben wollen und diese derzeit auf [.filename]#/mnt# gemountet ist, geben Sie folgendes ein:

[source,bash]
....
# newfs /dev/ada1s1a
# mount /dev/ada1s1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
....

Wenn Sie Partitionen mit `dump` umorganisieren wollen, bedeutet dies etwas mehr Arbeit. Wenn Sie eine Partition wie [.filename]#/var# in die übergeordnete Partition verschieben wollen, müssen Sie zunächst eine neue Partition erzeugen, die die beiden alten Partitionen aufnehmen kann. Der zweite Schritt ist, wie oben beschrieben die übergeordnete Partition in die neue Partition zu verschieben. Im dritten und letzten Schritt verschieben Sie dann die untergeordnete Partition in das leere Verzeichnis, das im zweiten Schritt entstanden ist:

[source,bash]
....
# newfs /dev/ada1s1a
# mount /dev/ada1s1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
# cd var
# dump 0af - /var | restore rf -
....

Wenn Sie ein Verzeichnis aus einer Partition herauslösen wollen, also z.B. [.filename]#/var# auf eine eigene Partition verlegen wollen, dann müssen Sie zunächst beide Partitionen anlegen. Danach müssen Sie die untergeordnete Partition im passenden Verzeichnis unterhalb des temporären mount points mounten und zum Abschluß die alte Partition verschieben:

[source,bash]
....
# newfs /dev/ada1s1a
# newfs /dev/ada1s1d
# mount /dev/ada1s1a /mnt
# mkdir /mnt/var
# mount /dev/ada1s1d /mnt/var
# cd /mnt
# dump 0af - / | restore rf -
....

Zum Verschieben von Benutzerdaten stehen Werkzeuge wie man:cpio[1] und man:pax[1] zur Verfügung. Allerdings sind diese Programme dafür bekannt, dass sie die erweiterten Dateiattribute nicht verstehen, daher sollten Sie bei ihrem Einsatz aufpassen.

=== Auf welchen Partitionen kann ich gefahrlos Soft Updates einsetzen? Ich habe gehört, dass der Einsatz von Soft Updates auf / Probleme verursachen kann. Was ist mit Journaled Soft Updates?

Die schnelle Antwort: Sie können Soft Updates bedenkenlos auf alle Partitionen benutzen.

Die ausführliche Antwort: Soft Updates besitzen zwei Eigenschaften, die auf bestimmten Partitionen unerwünscht sein können. Zum einen kann es bei einem Absturz des System auf einer Partition mit Soft Updates zum Datenverlust kommen. Die Partition ist zwar noch brauchbar, aber die Daten sind verloren. Weiterhin kann es durch Soft Updates zu einem zeitweisen Mangel an Plattenplatz kommen.

Bei der Benutzung von Soft Updates kann es bis zu dreißig Sekunden dauern, bis der Kernel Änderungen auf das physikalische Speichermedium schreibt. Wenn Sie eine große Datei löschen, ist diese Datei noch auf der Platte vorhanden, bis der Kernel die Löschoperation tatsächlich durchführt. Das kann zu einem sehr einfachen Problem führen: Stellen Sie sich vor, Sie löschen eine große Datei und legen gleich darauf eine andere große Datei an. Da die erste Datei noch nicht wirklich gelöscht wurde, ist eventuell nicht genug Platz für die zweite große Datei. Sie erhalten die Fehlermeldung, dass nicht genug freier Platz vorhanden ist, obwohl Sie gerade eben ausreichend Platz freigegeben haben. Ein paar Sekunden später funktioniert die Erstellung der Datei wie erwartet.

Wenn der Kernel ein Datenpaket annimmt und das System abstürzt, bevor die Daten auf die Platte geschrieben wurden, kann es zum Verlust oder zur Zerstörung von Daten kommen. Dieses Risiko ist nur sehr gering und normalerweise überschaubar.

Diese beiden Probleme betreffen alle Partitionen, die Soft Updates verwenden. Was bedeutet das für die Root-Partition?

Die wichtigen Daten auf der Root-Partition ändern sich nur sehr selten. Wenn das System in den 30 Sekunden nach einer solchen Änderung abstürzt, ist es möglich, das Daten verloren gehen. Dieses Risiko ist in den meisten Fällen unerheblich, aber es ist vorhanden. Wenn das zu viel Risiko ist, dann sollten Sie Soft Updates nicht auf der Root-Partition einsetzen.

[.filename]#/# war schon immer eine der kleinsten Partitionen. Wenn [.filename]#/tmp# direkt auf [.filename]#/# liegt, kann es zeitweise zu den oben beschriebenen Platzproblemen kommen. Um das Problem zu lösen, sollten sie einen symbolischen Link von [.filename]#/tmp# nach [.filename]#/var/tmp# legen.

Zudem sei noch angemerkt, dass man:dump[8] nicht im Live-Modus (-L) auf einem Dateisystem mit Journaled Soft Updates (SU+J) funktioniert.

=== Kann ich andere fremde Dateisysteme unter FreeBSD mounten?

FreeBSD unterstützt verschiedene fremde Dateisysteme:

UFS::
UFS-CD-ROMs können unter FreeBSD direkt gemountet werden. Das Mounten von Partitionen von Digital UNIX und anderen Systemen, die UFS unterstützen, könnte schwieriger sein, abhängig von den Details der Plattenpartitionierung des betreffenden Betriebssystems.

ext2/ext3::
FreeBSD unterstützt `ext2fs` und `ext3fs`-Partitionen. Unter man:ext2fs[5] finden Sie weitere Informationen.

NTFS::
FUSE basierte NTFS-Unterstützung ist über einen Port verfügbar (package:sysutils/fuse-ntfs[]). Weitere Informationen finden Sie unter http://www.tuxera.com/community/ntfs-3g-manual/[ntfs-3g].

FAT::
FreeBSD enthält ein FAT-Treiber, der Lese- und Schreibzugriffe ermöglicht. Weitere Informationen finden Sie in man:mount_msdosfs[8].

ZFS::
FreeBSD enthält eine Portierung von Sun(TM)s ZFS Treiber. Die aktuelle Empfehlung ist, es nur auf amd64 Plattformen mit ausreichend Hauptspeicher zu verwenden. Mehr Informationen finden Sie in man:zfs[8].

FreeBSD unterstützt auch das Netzwerk-Dateisystem NFS. Die FreeBSD Ports-Sammlung bietet zudem einige FUSE-Anwendungen um weitere Dateisysteme zu unterstützen.

=== Wie mounte ich eine erweiterte DOS-Partition?

Die erweiterten DOS-Partitionen befinden sich hinter _allen_ primären Partitionen. Wenn sich zum Beispiel eine Partition `E` als sekundäre DOS-Partition auf einem zweiten SCSI-Laufwerk befindet, wird eine Gerätedatei für `Slice 5` in [.filename]#/dev# erstellt. Um diese zu mounten:

[source,bash]
....
# mount -t msdosfs /dev/da1s5 /dos/e
....

=== Gibt es ein verschlüsselndes Dateisystem für FreeBSD?

Ja. man:gbde[8] und man:geli[8]. Lesen Sie dazu auch den Abschnitt link:{handbook}#disks-encrypting/[Partitionen verschlüsseln] im FreeBSD Handbuch.

=== Wie boote ich FreeBSD und Linux mit GRUB?

Um FreeBSD mit GRUB zu booten, müssen Sie die folgenden Zeilen in Abhängigkeit der verwendeten Linux(TM)-Distribution in [.filename]#/boot/grub/menu.lst# oder [.filename]#/boot/grub/grub.conf# aufnehmen.

[.programlisting]
....
title FreeBSD 9.1
	root (hd0,a)
	kernel /boot/loader
....

Dabei steht _hd0,a_ für die Root-Partition der ersten Festplatte. Benötigen Sie auch die Slice-Nummer, so verwenden Sie einen Eintrag der Form _hd0,2,a_. In der Voreinstellung ist die Angabe der Slice-Nummer aber nicht nötig, da GRUB automatisch das erste Slice (das die Bezeichnung `a` hat) nutzt.

=== Wie boote ich FreeBSD und Linux mit BootEasy?

Installieren Sie LILO am Anfang der Linux(TM)-Bootpartition, anstatt im Master Boot Record. Sie können LILO dann von BootEasy aus booten.

Wenn Sie Windows(TM) und Linux(TM) benutzen, wird dies ohnehin empfohlen, um es einfacher zu machen, Linux(TM) wieder zu booten, wenn es nötig werden sollte, dass Sie Windows(TM) neu installieren.

=== Wie kann ich das ??? des Boot-Managers durch etwas Sinnvolles ersetzen?

Ohne den Boot-Manager neu zu schreiben, gar nicht. Allerdings gibt es in der Kategorie [.filename]#sysutils# der Ports-Sammlung diverse Boot-Manager, die diese Funktionalität bieten.

=== Wie verwende ich einen neuen Wechseldatenträger?

Wenn auf dem Laufwerk bereits ein Dateisystem existiert, können Sie folgendes Kommando benutzen:

[source,bash]
....
# mount -t msdosfs /dev/da0s1 /mnt
....

Wenn das Laufwerk nur mit FreeBSD-Systemen verwendet wird, partitionieren Sie es mit UFS oder ZFS. Dies bietet Unterstützung für lange Dateinamen, eine verbesserte Leistung und Stabilität. Wenn das Laufwerk von anderen Betriebssystemen verwendet wird, ist bspw. msdosfs die bessere Wahl.

[source,bash]
....
# dd if=/dev/zero of=/dev/da0 count=2
# gpart create -s GPT /dev/da0
# gpart add -t freebsd-ufs /dev/da0
....

Anschließend erstellen Sie ein neues Dateisystem:

[source,bash]
....
# newfs /dev/da0p1
....

und mounten es:

[source,bash]
....
# mount /dev/da0s1 /mnt
....

Es ist eine gute Idee einen Eintrag in [.filename]#/etc/fstab# hinzuzufügen (siehe man:fstab[5]), sodass Sie in Zukunft einfach nur `mount /mnt` eingeben müssen:

[.programlisting]
....
/dev/da0p1 /mnt ufs rw,noauto 0 0
....

=== Wieso erhalte ich die Meldung Incorrect super block beim Mounten einer CD?

Sie müssen man:mount[8] mitteilen, was für ein Gerät Sie mounten wollen. Genauere Informationen dazu finden Sie im Abschnitt link:{handbook}#mounting-cd[Einhängen von Daten-CDs] des Handbuchs.

=== Wieso erhalte ich die Meldung Device not configured, wenn ich eine CD mounte?

Das bedeutet im allgemeinen, dass sich keine CD im Laufwerk befindet, oder dass das Laufwerk auf dem Bus nicht sichtbar ist. Dieses Problem wird im Kapitel link:{handbook}#mounting-cd[Einhängen von Daten-CDs] des Handbuchs ausführlich diskutiert.

=== Wieso werden alle Sonderzeichen in den Dateinamen auf meinen CDs durch ? ersetzt, wenn ich die CD unter FreeBSD benutze?

Wahrscheinlich werden auf der CD-ROM die "Joliet" Erweiterungen für die Speicherung von Datei- und Verzeichnisnamen benutzt. Werfen Sie einen Blick in das Kapitel link:{handbook}#mounting-cd[Einhängen von Daten-CDs] im Handbuch.

=== Ich habe eine CD mit FreeBSD gebrannt und kann sie nicht mit anderen Betriebssystemen lesen. Warum?

Sie haben wahrscheinlich eine Datei direkt auf CD geschrieben, statt ein ISO 9660-Dateisystem erzeugt zu haben. Werfen Sie einen Blick in das Kapitel link:{handbook}#mounting-cd[Einhängen von Daten-CDs] im Handbuch.

=== Wie kann ich ein Image einer Daten-CD erzeugen?

Diese Information finden Sie im Abschnitt link:{handbook}#mkisofs[Daten auf ein ISO-Dateisystem schreiben] des Handbuchs. Weitere Informationen über die Arbeit mit CD-ROMs finden Sie im Abschnitt link:{handbook}#creating-cds/[Erstellen und Verwenden von CDs] im Kapitel Speichermedien des Handbuchs.

=== Wieso kommt mount nicht mit einer Audio-CD zurecht?

Wenn Sie versuchen eine Audio-CD zu mounten, erhalten Sie die Meldung `cd9660: /dev/acd0c: Invalid argument`. Der Grund dafür ist, dass `mount` nur mit Dateisystemen arbeitet. Audio-CDs haben kein Dateisystem, sondern nur Daten. Wenn Sie eine Audio-CD auslesen wollen, brauchen Sie ein entsprechendes Programm wie z.B. den Port oder das Paket package:audio/xmcd[].

=== Wie mounte ich eine Multi-Session CD?

Standardmäßig benutzt man:mount[8] den letzten (aktuellsten) Daten-Track der CD. Wenn Sie eine ältere Session benutzen wollen, müssen Sie diese mit der Option `-s` definieren. Weitere Informationen und Beispiele finden Sie in man:mount_cd9660[8].

=== Wie lasse ich normale Benutzer Disketten, CD-ROMs und andere Wechseldatenträger mounten?

Setzen Sie als `root` die sysctl-Variable `vfs.usermount` auf `1`:

[source,bash]
....
# sysctl vfs.usermount=1
....

Fügen Sie den Eintrag `vfs.usermount=1` in [.filename]#/etc/sysctl.conf# hinzu, damit die Einstellung beim nächsten Systemstart erneut gesetzt wird.

Benutzer dürfen nur Geräte mounten, auf die sie Leserechte haben. Um es Benutzern zu gestatten Geräte zu mounten, müssen die entsprechenden Berechtigungen in [.filename]#/etc/sysctl.conf# gesetzt werden.

Wenn Sie zum Beispiel den Benutzern den Zugriff auf das erste USB-Laufwerk zu erlauben wollen:

[.programlisting]
....
# Allow all users to mount a USB drive.
	    own       /dev/da0       root:operator
	    perm      /dev/da0       0666
....

Alle Benutzer können nun Geräte, die sie lesen können, in ein Verzeichnis einbinden, das sie besitzen:

[source,bash]
....
% mkdir ~/my-mount-point
% mount -t msdosfs /dev/da0 ~/my-mount-point
....

Das Aushängen eines Gerätes ist einfach:

[source,bash]
....
% umount ~/my-mount-point
....

Die Aktivierung von `vfs.usermount` hat jedoch negative Auswirkungen auf Sicherheitsaspekte. Ein besserer Weg, um auf MS-DOS(TM)-formatierte Datenträger zuzugreifen, ist die Benutzung des Pakets oder Ports package:emulators/mtools[].

[NOTE]
====
Der Gerätename in diesen Beispielen muss an die Konfiguration angepasst werden.
====

=== Wieso geben die Befehle du und df unterschiedliche Werte für den freien Plattenplatz aus?

Der Grund liegt in der unterschiedlichen Funktionsweise der beiden Befehle. `du` durchläuft einen Dateibaum, ermittelt die Größe jeder einzelnen Datei, und gibt die Summe aus. `df` fragt lediglich das Dateisystem wie viel Platz noch frei ist. Das scheint zwar auf den ersten Blick sehr ähnlich zu sein; allerdings wird sich ein leeres Verzeichnis auf die Ausgabe von `df` auswirken, während es auf das Ergebnis von `du` keinen Einfluss hat.

Wenn Sie eine Datei löschen, während sie von einem Programm genutzt wird, wird diese Datei erst gelöscht, wenn sie vom Programm freigegeben wird. Allerdings wird die Datei sofort aus dem Verzeichnis entfernt. Sie können dieses Verhalten sehr einfach nachvollziehen. Dazu brauchen Sie nur eine Datei, die groß genug ist, um die Ausgabe von `du` und `df` zu beeinflussen. Bei der Größe aktueller Platten muss diese Datei schon sehr groß sein! Wenn Sie diese Datei löschen, während Sie sie sich in `more` anzeigen lassen, hat `more` kein Problem. Der Eintrag für die Datei wird lediglich aus dem Verzeichnis entfernt, damit kein anderes Programm mehr darauf zugreifen kann. Laut `du` ist die Datei verschwunden – es hat das Verzeichnis untersucht und die Datei nicht gefunden. Laut `df` ist die Datei aber vorhanden, da sie im Dateisystem immer noch Platz belegt. Sobald Sie `more` beenden, werden die Ergebnisse von `du` und `df` wieder übereinstimmen.

Die oben beschriebene Situation tritt sehr häufig auf Webservern auf. Viele Anwender installieren einen FreeBSD Webserver und vergessen die Rotation der Logdateien, bis irgendwann die Partition [.filename]#/var# überläuft. Der Administrator löscht die Datei, aber das System beschwert sich immer noch über fehlenden Plattenplatz. Die Datei wird erst freigegeben, wenn der Webserver beendet und neu gestartet wird; dadurch kann das System den Plattenplatz freigeben. Um dies zu verhindern, sollten Sie man:newsyslog[8] einsetzen.

Bitte beachten Sie, dass die Freigabe des Plattenplatzes durch Soft Updates um bis zu 30 Sekunden verzögert werden kann.

=== Wie kann ich den Swap-Bereich vergrößern?

Der Abschnitt link:{handbook}#adding-swap-space/[Hinzufügen von Swap-Bereichen] im Handbuch enthält hierzu eine Schritt-für-Schritt Anleitung.

=== Warum ist meine Festplatte unter FreeBSD kleiner, als sie laut Hersteller sein soll?

Festplattenhersteller definieren ein Gigabyte als eine Milliarde Bytes, für FreeBSD ist ein Gigabyte hingegen 1.073.741.824 Bytes groß. Aus diesem Grund wird für eine Platte, die laut Herstellerangaben 80 GB groß ist, während des Bootvorgangs eine Größe von 76.319 MB angezeigt.

Beachten Sie auch, dass FreeBSD (in der Voreinstellung) 8 % des Plattenplatzes für sich <<disk-more-than-full,reserviert>>.

=== Warum kann eine Partition zu mehr als 100% gefüllt sein?

Ein Teil jeder UFS Partition (8% in der Voreinstellung) ist für das Betriebssystem und den Benutzer `root` reserviert. man:df[1] rechnet diesen Teil bei der Ausgabe der Spalte `Capacity` nicht ein, so dass dort Werte über 100% angezeigt werden können. Die Anzahl der Blöcke in der Spalte `Blocks` ist ebenfalls um 8% größer als die Summe der benutzten und verfügbaren Blöcke (die Spalten `Used` und `Avail`).

Wie viel Platz reserviert wird, können Sie mit der Option `-m` von man:tunefs[8] einstellen.

=== Warum pausiert FreeBSD beim Booten so lange, wenn das System große Mengen RAM hat?

FreeBSD 10.1 und ältere Versionen führen zu Beginn des Bootens einen Speichertest aus. Wenn das System wenig Arbeitsspeicher hat, dauert dieser Test nur wenige Sekunden. Systeme mit zehn oder hunderten von Gigabytes Arbeitsspeicher benötigen mehrere Minuten. Durch Hinzufügen von `hw.memtest.tests=0` in [.filename]#/boot/loader.conf# können Sie diesen Test deaktivieren.

Für weitere Informationen, lesen Sie man:loader.conf[5].

== ZFS

=== Wieviel RAM wird mindestens benötigt, wenn ich ZFS einsetzen möchte?

Für eine komfortable Nutzung werden mindestens 4 GB RAM empfohlen. Dies ist jedoch auch von der individuellen Auslastung abhängig.

=== Was ist das ZIL und für was wird es benutzt?

Das ZIL (ZFS intent log) ist ein Schreib-Cache, der verwendet wird, um posix verpflichtende Schreib-Semantiken über Abstürze hinweg zu implementieren. Normalerweise werden Schreiboperationen in Transaktionsgruppen zusammengefasst und auf den Datenträger geschrieben ("Transaction Group Commit"). Systemaufrufe wie man:fsync[2] benötigen jedoch eine Bestätigung, dass die Daten auf den Datenträger geschrieben wurden, bevor sie weitermachen. Das ZIL wird für Schreibvorgänge verwendet, welche zwar als gespeichert bestätigt, jedoch noch nicht als Teil einer Transaktion auf die Festplatte geschrieben wurden. Im Fall eines Systemabsturzes wird der letzte gültige Zeitstempel ermittelt und die fehlenden Daten werden aus dem ZIL zusammengesetzt.

=== Benötige ich für den Einsatz von ZIL eine SSD?

In der Voreinstellung speichert ZFS das ZIL zusammen mit den anderen Daten innerhalb des Pools. Wenn eine Anwendung viele Schreiboperationen erzeugt, kann es die Gesamtleistung verbessern, wenn das ZIL auf einem separaten Gerät gespeichert wird, welches eine hohe Leistung bei synchronen, sequentiellen Schreibvorgängen erzielt. Bei geringerer Last bieten SSDs kaum eine Verbesserung.

=== Was ist der L2ARC?

Der L2ARC ist ein Lese-Cache, der auf einem schnellen Gerät, bspw. einer SSD, gespeichert wird. Die Daten in diesem Cache gehen bei einem Neustart verloren. Beachten Sie, dass primär RAM als Cache verwendet wird, und dass der L2ARC nur dann benötigt wird, wenn nicht genügend RAM verfügbar ist.

L2ARC benötigt Platz im ARC, um es zu indizieren. Ein Arbeitsbereich, der perfekt in den ARC passt, passt nicht mehr, wenn ein L2ARC verwendet wird, da ein Teil des ARC den L2ARC-Index beinhaltet und einen Teil des Arbeitsbereichs in den L2ARC schreibt, der langsamer als der RAM ist.

=== Ist es ratsam, Deduplizierung zu aktivieren?

Im Allgemeinen nicht.

Deduplizierung benötigt sehr viel RAM und kann die Lese- und Schreibzugriffe auf die Festplatte verringern. Wenn Sie keine Daten speichern, die sehr stark dupliziert sind, bspw. Abbilder von virtuellen Maschinen oder Backups von Benutzern, dann ist es eher wahrscheinlich, dass Deplizierung mehr Schaden als Nutzen bringt. Zudem ist es nicht möglich, den Status der Deduplizierung umzukehren. Wenn Daten bei aktivierter Deduplizierung geschrieben werden, werden diese nach einer Deaktivierung der Deduplizierung erst wieder repliziert, nachdem die nächste Änderung stattfindet.

Deduplizierung kann auch zu einigen unerwarteten Situationen führen. Insbesondere kann das Löschen von Dateien viel langsamer sein.

=== Ich kann in meinem ZFS Pool keine Dateien erstellen oder löschen. Wie kann ich das ändern?

Die könnte passieren, wenn der Pool zu 100% belegt ist. ZFS benötigt Platz auf der Festplatte, um Transaktionsmetadaten zu speichern. Um den Pool wieder benutzbar zu machen, kürzen Sie einfach die zu löschende Datei:

[source,bash]
....
% truncate -s 0 unimportant-file
....

Dies funktioniert, weil keine neue Transaktion gestartet wird, stattdessen werden neue Ersatzblöcke erzeugt.

[NOTE]
====
Auf Systemen mit zusätzlichen ZFS Optimierungen, wie Deduplizierung, steht der Speicherplatz vielleicht nicht sofort zur Verfügung.
====

=== Enthält ZFS TRIM-Unterstützung für Solid State Drives?

ZFS TRIM-Unterstützung wurde in FreeBSD 10-CURRENT mit Revision rlink:https://svnweb.freebsd.org/changeset/base/240868[r240868] hinzugefügt. In die FreeBSD-STABLE Zweige wurde die Unterstützung mit rlink:https://svnweb.freebsd.org/changeset/base/252162[r252162] und link:https://svnweb.freebsd.org/changeset/base/251419[r251419] hinzugefügt.

ZFS TRIM ist in der Voreinstellung aktiviert, kann aber mit dem folgenden Eintrag in [.filename]#/etc/sysctl.conf# deaktiviert werden:

[.programlisting]
....
vfs.zfs.trim_disable=1
....

[NOTE]
====
ZFS TRIM funktioniert möglicherweise nicht in allen Konfigurationen, beispielsweise mit einem ZFS-Dateisystem auf einer mit GELI verschlüsselten Festplatte.
====

== Systemadministration

=== Wo befinden sich die Konfigurationsdateien für den Systemstart?

[.filename]#/etc/defaults/rc.conf# (siehe man:rc.conf[5]) ist die primäre Konfigurationsdatei. Die Startskripten des Systems, wie [.filename]#/etc/rc# und [.filename]#/etc/rc.d# (siehe man:rc[8]) inkludieren diese Datei. _Ändern Sie diese Datei nicht!_ Wenn Sie den Wert einer der in [.filename]#/etc/defaults/rc.conf# gesetzten Variablen ändern wollen, kopieren Sie die entsprechende Zeile nach [.filename]#/etc/rc.conf# und ändern die Zeile dort.

Wenn Sie zum Beispiel den mitgelieferten DNS-Server man:named[8] aktivieren wollen, können Sie das folgende Kommando eingeben:

[source,bash]
....
# echo 'named_enable="YES"' >> /etc/rc.conf
....

Wenn Sie lokale Server starten wollen, müssen Sie die Shellskripten im Verzeichnis [.filename]#/usr/local/etc/rc.d/# ablegen. Die Dateien sollten als ausführbar markiert sein und die Dateiberechtigungen `555` besitzen.

=== Wie kann ich am Einfachsten einen Benutzer hinzufügen?

Benutzen Sie den Befehl man:adduser[8] und für kompliziertere Fälle den Befehl man:pw[8].

Um einen Benutzer wieder zu löschen, können Sie den Befehl man:rmuser[8] benutzen. Sie können, wenn nötig, auch man:pw[8] benutzen.

=== Warum erhalte ich Meldungen wie root: not found, nachdem ich /etc/crontab geändert habe?

Dies geschieht in der Regel, wenn sie die crontab des Systems verändern. Das ist aber nicht der richtige Weg, weil die crontab des Systems ein anderes Format hat, als die crontabs der Benutzer. Die crontab des Systems enthält ein zusätzliches Feld für den Benutzer, welcher das Kommando ausführt. man:cron[8] geht davon aus, das der Benutzername das auszuführenden Kommando ist. Da ein solches Kommando jedoch nicht existiert, wird diese Meldung angezeigt.

Geben Sie das folgende ein um die zusätzliche, fehlerhafte crontab zu löschen:

[source,bash]
....
# crontab -r
....

=== Wieso erhalte ich die Meldung you are not in the correct group to su root, wenn ich mit su zu root wechseln will?

Das ist ein Sicherheitsmerkmal Wenn Sie mit `su` zu `root` oder jedem anderen Account mit Super-User-Privilegien wechseln wollen, müssen Sie Mitglied der Gruppe `wheel` sein. Wenn es dieses Merkmal nicht gäbe, könnte jeder, der einen Account auf dem System hat und zufällig das Passwort für `root` erfährt, mit Super-User-Rechten auf das System zugreifen.

Um einem Benutzer zu erlauben, mit `su root` zu werden, müssen Sie ihn mit `pw` zur Gruppe `wheel` hinzufügen:

[source,bash]
....
# pw groupmod wheel -m lisa
....

Das obige Beispiel würde den Benutzer `lisa` zur Gruppe `wheel` hinzufügen.

=== Ich habe einen Fehler in der rc.conf oder einer der anderen Dateien für den Systemstart und jetzt kann ich sie nicht ändern, weil das Dateisystem read-only ist. Was kann ich tun?

Starten Sie das System mittels `boot -s` an der Loader-Eingabeaufforderung neu, um in den Single-User-Modus zu gelangen. Wenn Sie aufgefordert werden, den Pfadnamen der Shell einzugeben, drücken Sie einfach Enter. Geben Sie danach `mount -urw /` ein, um das Root-Dateisystem im Schreib/Lese-Modus zu mounten. Sie werden wahrscheinlich auch `mount -a -t ufs` ausführen müssen, um das Dateisystem mit Ihrem Lieblingseditor zu mounten. Wenn Ihr Lieblingseditor auf einem Netzwerklaufwerk liegt, müssen Sie entweder das Netzwerk von Hand konfigurieren oder einen Editor benutzen, der auf einem lokalen Laufwerk vorhanden ist, z.B. man:ed[1].

Wenn Sie einen bildschirmorientierten Editor wie zum Beispiel man:vi[1] oder man:emacs[1] benutzen wollen, werden Sie auch den Befehl `export TERM=xterm` ausführen müssen, damit diese Editoren die richtigen Einstellungen aus der Datenbank man:termcap[5] übernehmen.

Sobald Sie diese Schritte ausgeführt haben, können Sie den Fehler in [.filename]#/etc/rc.conf# ganz normal beheben. Die Fehlermeldungen, die unmittelbar nach den Startmeldungen des Kernels angezeigt wurden, sollten die Nummer der Zeile mit dem Fehler melden.

=== Wieso habe ich habe Probleme, meinen Drucker einzurichten?

Lesen Sie zur Problembehandlung das Kapitel link:{handbook}#printing/[Drucken] im Handbuch.

=== Wie kann ich die Tastaturbelegung meines Systems korrigieren?

Informationen dazu finden Sie im Kapitel link:{handbook}#using-localization/[Lokalisierung] des Handbuchs, insbesondere im Abschnitt link:{handbook}#setting-console[Einrichten der Konsole].

=== Wieso funktionieren die Benutzer-Quotas nicht richtig?

. Es kann sein, dass der Kernel nicht für den Einsatz von Quotas konfiguriert ist. In diesem Fall müssen Sie folgende Zeile in die Kernelkonfigurationsdatei aufnehmen und den Kernel neu bauen:
+
[.programlisting]
....
options QUOTA
....

+ 
Weitere Informationen zum Einsatz von Quotas finden Sie im Abschnitt link:{handbook}#quotas/[Disk Quotas] des Handbuchs.
. Benutzen Sie keine Quotas für [.filename]#/#.
. Erstellen Sie die Quotas-Datei in dem Dateisystem, für das die Quotas gelten sollen:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Dateisystem
| Quotas-Datei

|[.filename]#/usr#
|[.filename]#/usr/admin/quotas#

|[.filename]#/home#
|[.filename]#/home/admin/quotas#

|...
|...
|===

=== Unterstützt FreeBSD IPC-Grundfunktionen von System V?

Ja, FreeBSD unterstützt IPC im Stil von System V einschließlich gemeinsamen Speicher, Nachrichten und Semaphoren bereits mit dem [.filename]#GENERIC#-Kernel. Wenn Sie einen angepassten Kernel verwenden, können Sie die für Unterstützung die Kernelmodule [.filename]#sysvshm.ko#, [.filename]#sysvsem.ko# und [.filename]#sysvmsg.ko# laden. Alternativ können Sie die folgenden Zeilen in die Kernelkonfigurationsdatei aufnehmen:

[.programlisting]
....
options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging
....

Danach kompilieren und installieren Sie den neuen Kernel.

=== Welchen Mail-Server kann ich an Stelle von Sendmail benutzen?

Der http://www.sendmail.org/[Sendmail] Server ist der voreingestellte Mail-Server unter FreeBSD. Sie können ihn aber problemlos durch einen anderen MTA aus der Ports-Sammlung ersetzen, z.B. package:mail/exim[], package:mail/postfix[], oder package:mail/qmail[]. Diskussionen über die Vor- und Nachteile der einzelnen MTAs finden Sie auf den Mailinglisten.

=== Was kann ich machen, wenn ich das Passwort für root vergessen habe?

Keine Panik! Starten Sie das System neu und geben Sie `boot -s` an der Eingabeaufforderung `Boot:` ein, um in den Single-User-Modus zu gelangen. Bei der Frage, welche Shell benutzt werden soll, drücken Sie einfach kbd:[Enter]. Nun erscheint die Eingabeaufforderung `#`. Geben Sie `mount -urw /` ein, um das Root-Dateisystem für Lese- und Schreibzugriffe zu mounten und dann `mount -a` um alle Dateisysteme zu mounten. Mit `passwd root` können Sie das Passwort für `root` ändern und mit man:exit[1] können Sie mit dem Booten fortfahren.

[NOTE]
====
Wenn Sie immer noch dazu aufgefordert werden, das Passwort für `root` beim Betreten des Single-User-Modus einzugeben, bedeutet das, dass die Konsole in [.filename]#/etc/ttys# als `insecure` markiert wurde. In diesem Fall ist es notwendig, von einem FreeBSD Installationsmedium zu booten, die Option [.guimenuitem]#Live CD# oder [.guimenuitem]#Shell# auszuwählen und die oben beschriebenen Befehle einzugeben. Mounten Sie die entsprechende Partition und wechseln Sie mit `chroot` in die Partition. Ersetzen Sie bspw. `mount -urw /` durch `mount /dev/ada0p1 /mnt; chroot /mnt` falls eine solche Partition auf dem System existiert.
====

[NOTE]
====
Wenn Sie die Root-Partition im Single-User-Modus nicht mounten können, liegt es möglicherweise daran, dass die Partitionen verschlüsselt sind und es damit unmöglich ist, sie ohne die dazugehörigen Schlüssel zu mounten. Für weitere Informationen lesen Sie den Abschnitt über verschlüsselte Partitionen im FreeBSD link:{handbook}#disks-encrypting/[Handbuch].
====

=== Wie verhindere ich, dass das System mit StrgAltEntf rebootet werden kann?

Falls Sie man:syscons[4] (der Standard-Treiber für die Konsole) benutzen, fügen Sie folgende Zeile in die Kernelkonfigurationsdatei ein und bauen und installieren Sie einen neuen Kernel:

[.programlisting]
....
options SC_DISABLE_REBOOT
....

Alternativ kann die folgende man:sysctl[8]-Variable gesetzt werden, ohne dass Sie das System dazu neu starten oder einen angepassten Kernel erstellen müssen:

[source,bash]
....
# sysctl hw.syscons.kbd_reboot=0
....

[NOTE]
====
Die beiden oben genannten Methoden schließen sich gegenseitig aus: Diese man:sysctl[8]-Variable existiert nicht, wenn Sie einen Kernel mit der Option `SC_DISABLE_REBOOT` bauen.
====

=== Wie kann ich DOS-Textdateien unter UNIX verwenden?

Benutzen Sie diesen man:perl[1]-Befehl:

[source,bash]
....
% perl -i.bak -npe 's/\r\n/\n/g' file(s)
....

Wobei _file(s)_ eine oder mehrere zu verarbeitende(n) Datei(en) ist/sind. Die Änderungen erfolgen in der Originaldatei, die zuvor mit der Erweiterung [.filename]#.bak# gesichert wird.

Alternativ können Sie den Befehl man:tr[1] benutzen:

[source,bash]
....
% tr -d '\r' < dos-text-file > unix-file
....

_dos-text-file_ ist die Datei, die den Text im DOS-Format enthält und _unix-file_ wird die konvertierte Ausgabe enthalten. Diese Möglichkeit könnte etwas schneller sein, als die Benutzung von `perl`.

Die Verwendung von package:converters/dosunix[] aus der Ports-Sammlung stellt eine weitere Möglichkeit dar, DOS-Textdateien neu zu formatieren. Konsultieren Sie die Dokumentation für weitere Informationen.

=== Wie lade ich /etc/rc.conf und starte /etc/rc neu, ohne zu rebooten?

Gehen Sie in den Single-User-Modus und dann zurück in den Multi-User-Modus:

[source,bash]
....
# shutdown now
# return
# exit
....

=== Ich wollte auf das aktuelle -STABLE aktualisieren, und plötzlich läuft auf dem System ein -BETAx, -RC oder -PRERELEASE! Was ist passiert?

Kurze Antwort: Das ist nur ein anderer Name. _RC_ ist die Abkürzung für "Release Candidate". Es bedeutet, dass ein neues Release bevorsteht. PRERELEASE bedeutet bei FreeBSD, dass der Quellcode zur Vorbereitung auf ein Release "ingefroren" wurde (in einigen Releases wurde _-BETA_ anstelle von _-PRERELEASE_ verwendet).

Ausführliche Antwort: Bei FreeBSD gibt es zwei Quellen für Releases. Die Major Releases wie 9.0-RELEASE werden aus dem aktuellen Stand des Hauptzweiges der Entwicklung (besser bekannt als <<current,-CURRENT>>) erzeugt. Minor Releases wie 6.3-RELEASE oder 5.2-RELEASE stammen aus dem aktiven <<stable,-STABLE>> Zweig. Seit 4.3-RELEASE gibt es nun auch einen eigenen Zweig für jede Release, der für die Leute gedacht ist, die ein sehr konservativ weiterentwickeltes System benötigen (normalerweise nur Sicherheitsaktualisierungen).

Bevor in einem Zweig ein Release erfolgt, muss in diesem Zweig ein bestimmter Prozess ablaufen. Ein Teil dieses Prozesses ist der "code freeze", der Stop der Weiterentwicklung. Sobald dieser Schritt erfolgt ist, wird der Name des Zweiges geändert, um anzuzeigen, dass demnächst ein Release erfolgen wird. Wenn der Zweig zum Beispiel 6.2-STABLE genannt wurde, wird der Name in 6.3-PRERELEASE geändert, um dies zu verdeutlichen. Weiterhin ist das ein Zeichen, dass jetzt besonders intensiv getestet werden sollte. In dieser Phase können Fehler im Quellcode noch korrigiert werden. Wenn der Quellcode so weit "gereift" ist, dass ein Release erstellt werden kann, wird der Name in 6.3-RC geändert, um genau dies anzuzeigen. In dieser Phase können nur noch extrem wichtige Korrekturen aufgenommen werden. Sobald das Release (in diesem Beispiel 6.3-RELEASE) erfolgt ist, wird der Zweig in 6.3-STABLE umbenannt.

Weitere Informationen über Versionsnummern und die verschiedenen Entwicklungszweige enthält der Artikel link:{releng}[Release Engineering].

=== Als ich versucht habe, einen neuen Kernel zu installieren, ist chflags1 fehlgeschlagen. Was mache ich jetzt?

Kurze Antwort: die Sicherheitseinstellung (der securelevel) ist größer als 0. Sie müssen das System im Single-User-Modus starten, um den Kernel zu installieren.

Ausführliche Antwort: Wenn die Sicherheitseinstellung größer als 0 ist, erlaubt es FreeBSD nicht, die Systemeinstellungen zu ändern. Um den aktuellen Securelevel zu ermitteln, können Sie das folgende Kommando benutzen:

[source,bash]
....
# sysctl kern.securelevel
....

Sie können die Sicherheitseinstellung im Mehrbenutzer-Modus nicht verringern. Sie müssen das System im Single-User-Modus starten, um den Kernel zu installieren oder den Securelevel in [.filename]#/etc/rc.conf# zu ändern und anschließend das System neu starten. Lesen Sie Manualpage von man:init[8] für weitere Details zu `securelevel`. Zusätzliche Informationen zu [.filename]#/etc/rc.conf# finden Sie in [.filename]#/etc/defaults/rc.conf# und der Manualpage man:rc.conf[5].

=== Ich kann die Systemzeit nicht um mehr als eine Sekunde verstellen. Was mache ich jetzt?

Kurze Antwort: Die Sicherheitseinstellung (der securelevel) ist größer als 1. Sie müssen das System neu starten und die Systemzeit im Single-User-Modus verstellen.

Ausführliche Antwort: Wenn die Sicherheitseinstellung größer als 1 ist, erlaubt es FreeBSD nicht, die Systemzeit zu ändern. Um den aktuellen Securelevel zu ermitteln, können Sie das folgende Kommando benutzen:

[source,bash]
....
# sysctl kern.securelevel
....

Sie können die Sicherheitseinstellung im Mehrbenutzer-Modus nicht verringern. Sie müssen das System im Single-User-Modus starten, um die Systemzeit oder den Securelevel in [.filename]#/etc/rc.conf# zu ändern und anschließend das System neu starten. Lesen Sie Manualpage von man:init[8] für weitere Details zu `securelevel`. Zusätzliche Informationen zu [.filename]#/etc/rc.conf# finden Sie in [.filename]#/etc/defaults/rc.conf# und der Manualpage man:rc.conf[5].

=== Warum braucht rpc.statd 256 MB Speicher?

Nein, das Programm hat kein Speicherleck und es verbraucht auch nicht 256 MB Speicher. `rpc.statd` projiziert nur einen übertrieben großen Speicherbereich in seinen eigenen Adressraum. Von einem rein technischen Standpunkt aus ist das nichts verwerfliches, allerdings verwirrt es Programme wie man:top[1] und man:ps[1].

man:rpc.statd[8] projiziert seine Statusdatei (die in [.filename]#/var# liegt) in seinen Adressraum. Um die Probleme zu vermeiden, die bei einer Vergrößerung dieser Projektion entstehen könnten, wird gleich ein möglichst großer Speicherbereich benutzt. Dies kann man sehr schön im Quellcode sehen: Die Längenangabe beim Aufruf von man:mmap[2] ist `0x10000000`, ein sechzehntel des Adressraums bei IA32, oder genau 256 MB.

=== Warum kann ich das Dateiattribut schg nicht löschen?

Sie betreiben das System mit einer erhöhten Sicherheitsstufe. Senken Sie die Sicherheitsstufe und versuchen Sie es dann noch einmal. Weitere Informationen erhalten Sie im <<securelevel,FAQ Eintrag über Sicherheitsstufen>> und in der Manualpage man:init[8].

=== Was ist vnlru?

`vnlru` schreibt vnodes auf Platte und gibt sie wieder frei, falls das System den Grenzwert `kern.maxvnodes` erreicht. Dieser Thread des Kernel tut meistens gar nichts und wird nur aktiv, wenn Sie extrem viel RAM haben und gleichzeitig auf viele zehntausende kleine Dateien zugreifen.

=== Was bedeuten die Zustände, die top für Speicherseiten ausgibt?

* `Active`: Seiten, die vor Kurzem benutzt wurden.
* `Inactive`: Seiten, die länger nicht benutzt wurden.
* `Cache`: Meistens Seiten, die vorher im Zustand Inactive waren und noch gültige Daten enthalten. Diese Seiten können sofort in ihrem alten Kontext oder in einem neuen Kontext verwendet werden. Wenn eine Seite unverändert (clean) ist, kann ein Zustandswechsel direkt von `Active` nach `Cache` erfolgen. Ob dieser Zustandswechsel möglich ist, wird durch die Seitenersetzungsstrategie bestimmt, die der Entwickler des VM-Systems festgelegt hat.
* `Free`: Seiten, die keine Daten enthalten. Diese Seiten können sofort benutzt werden, wenn Seiten im Zustand Cache nicht benutzt werden können. Seiten im Zustand Free können auch während eines Interrupts angefordert werden.
* `Wired`: Seiten, die fest im Speicher liegen und nicht ausgelagert werden können. Normalerweise werden solche Seiten vom Kernel benutzt, manchmal werden Sie aber auch für spezielle Zwecke von Prozessen verwendet.

Seiten im Zustand Inactive werden oft auf Plattenspeicher geschrieben (sozusagen ein sync des VM-Systems). Wenn die CPU erkennen kann, das eine Seite unmodifiziert (clean) ist, kann auch eine Active-Seite auf den Plattenspeicher ausgeschrieben werden. In bestimmten Situationen ist es von Vorteil, wenn ein Block von VM-Seiten, unabhängig von seinem Zustand, ausgeschrieben werden kann. Die Inactive-Liste enthält wenig benutzte Seiten, die ausgeschrieben werden könnten. Seiten im Zustand Cached sind schon ausgeschrieben und stehen Prozessen für die Verwendung im alten oder in einem neuen Kontext zur Verfügung. Seiten im Zustand Cache sind nicht ausreichend geschützt und können während Unterbrechungen nicht benutzt werden.

Die eben beschriebene Behandlung von Speicherseiten kann durch weitere Zustände (wie das Busy-Flag) verändert werden.

=== Wie viel freien Speicher hat mein System?

Es gibt verschiedene Arten von "freiem Speicher". Eine Art ist die Speichermenge, die sofort, ohne etwas auszulagern, zur Verfügung steht. Dies ist ungefähr die kumulierte Größe von `Inactive` und `Free`. Der gesamte VM-Bereich ist eine weitere Art des "freien Speichers". Die Betrachtung ist komplex, hängt aber von der Größe des Swap-Bereichs und der Größe des Arbeitsspeichers ab. Es gibt weitere Definitionen für "freien Speicher", die aber alle relativ nutzlos sind. Wichtig ist hingegen, dass wenig Seiten ausgelagert werden (paging) und der Swap-Bereich ausreichend groß ist.

=== Was ist /var/empty?

Das Verzeichnis [.filename]#/var/empty# wird von man:sshd[8] benötigt, wenn es mit "Privilege Separation" ausgeführt wird. Das Verzeichnis [.filename]#/var/empty# ist leer, gehört `root` und ist durch das Dateiattribut `schg` geschützt.

=== Ich habe eben /etc/newsyslog.conf geändert. Wie kann ich das Ergebnis überprüfen?

Um zu sehen wie man:newsyslog[8] reagiert, verwenden Sie das folgende Kommando:

[source,bash]
....
% newsyslog -nrvv
....

=== Meine Systemuhr geht falsch. Wie kann ich die Zeitzone ändern?

Benutzen Sie man:tzsetup[8].

== Das X Window System und virtuelle Konsolen

=== Was ist das X Window System?

Das X Window System (oder auch nur `X11`) ist das am häufigsten verwendete Window System für UNIX(TM)- und UNIX(TM)-ähnliche Systeme, zu denen auch FreeBSD gehört. Der http://en.wikipedia.org/wiki/X_Window_System_core_protocol[X Protokollstandard] wird von der http://www.x.org/wiki/[X.Org Foundation] definiert und liegt aktuell in Version 11 Release 7.7 vor und wird häufig auch nur als `X11` bezeichnet.

Das X Window System wurde für viele verschiedene Architekturen und Betriebssysteme implementiert. Eine serverseitige Implementierung wird dabei als `X-Server` bezeichnet.

=== Ich möchte Xorg benutzen, was muss ich tun?

Sie können Xorg wie folgt installieren:

Benutzen Sie den Meta-Port package:x11/xorg[], der sämtliche Xorg Komponenten installiert.

Benutzen Sie package:x11/xorg-minimal[], der nur die benötigten Komponenten installiert.

Sie können Xorg auch als Paket installieren:

[source,bash]
....
 # pkg install xorg
....

Lesen Sie nach erfolgreicher Installation von Xorg den Abschnitt link:{handbook}#x-config/[X11 konfigurieren] im FreeBSD Handbuch.

=== Ich habe versucht, X zu starten, aber wenn ich startx eingebe, erhalte ich die Fehlermeldung No devices detected.. Was soll ich jetzt machen?

Das System läuft wahrscheinlich auf einer erhöhten Sicherheitsstufe (`securelevel`). X kann auf einer erhöhten Sicherheitsstufe nicht gestartet werden, weil X dazu Schreibzugriff auf man:io[4] benötigt. Lesen Sie dazu auch die Manualpage man:init[8].

Es gibt zwei Lösungen für dieses Problem: Setzen Sie die Sicherheitsstufe wieder zurück auf `0` oder starten Sie man:xdm[1] (oder einen alternativen Display Manager) während des Bootens, bevor die Sicherheitsstufe erhöht wird.

Der Abschnitt <<xdm-boot>> enthält Informationen darüber, wie Sie man:xdm[1] beim Systemstart aktivieren können.

=== Warum funktioniert meine Maus unter X nicht?

Wenn Sie den Standard-Konsolentreiber man:syscons[4] benutzen, können Sie FreeBSD so konfigurieren, dass auf jedem virtuellen Bildschirm ein Mauszeiger unterstützt wird. Um Konflikte mit X zu vermeiden, unterstützt man:syscons[4] ein virtuelles Gerät namens [.filename]#/dev/sysmouse#. Alle Mausbewegungen und Mausklicks werden über man:moused[8] in das man:sysmouse[4] Gerät. Falls Sie die Maus auf einer oder mehreren virtuellen Konsolen _und_ unter X benutzen wollen, sollten Sie zunächst <<moused>> lesen und man:moused[8] konfigurieren.

Stellen Sie anschließend sicher, dass die folgenden Einträge in [.filename]#etc/X11/xorg.conf# enthalten sind:

[.programlisting]
....
Section "InputDevice"
   Option          "Protocol" "SysMouse"
   Option          "Device" "/dev/sysmouse"
.....
....

Beginnend mit Xorg 7.4 werden Angaben im Abschnitt `InputDevice` von [.filename]#xorg.conf# ignoriert. Stattdessen wird auf die automatisch ermittelten Werte zurückgegriffen. Um das alte Verhalten zu reaktivieren, fügen Sie die folgende Zeile entweder in den Abschnitt `ServerLayout` oder `ServerFlags` ein:

[.programlisting]
....
Option "AutoAddDevices" "false"
....

Einige Leute ziehen es vor, unter X [.filename]#/dev/mouse# zu benutzen. Hierzu sollte [.filename]#/dev/mouse# nach [.filename]#/dev/sysmouse# (siehe man:sysmouse[4]) gelinkt werden, indem Sie die folgende Zeile in [.filename]#/etc/devfs.conf# (siehe man:devfs.conf[5]) hinzufügen:

[.programlisting]
....
link    sysmouse    mouse
....

Die Verknüpfung kann durch Neustart von man:devfs[5] über das folgende Kommando (als `root`) erzeugt werden:

[source,bash]
....
# service devfs restart
....

=== Kann ich meine Rad-Maus auch unter X benutzen?

Dazu müssen Sie X nur mitteilen, dass Sie eine Maus mit 5 Tasten haben. Dazu fügen Sie die Zeilen `Buttons 5` sowie `ZAxisMapping 4 5` in den Abschnitt "InputDevice" von [.filename]#/etc/X11/xorg.conf# ein. Das Beispiel zeigt, wie ein solcher Abschnitt aussehen könnte.

[.programlisting]
....
Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/sysmouse"
   Option          "Buttons" "5"
   Option          "ZAxisMapping" "4 5"
EndSection
....

Wenn Sie die Maus in Emacs benutzen wollen, fügen Sie auch die folgenden Zeilen in [.filename]#~/.emacs# ein:

[.programlisting]
....
;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)
....

=== Mein Laptop hat ein Synaptics Touchpad. Kann ich das unter X benutzen?

Ja, aber damit es funktioniert, müssen Sie ein paar Dinge konfigurieren.

Damit Sie den Xorg synaptics Treiber benutzen können, müssen Sie zuerst `moused_enable` aus [.filename]#/etc/rc.conf# entfernen.

Um synaptics zu aktivieren, fügen Sie die folgende Zeile in [.filename]#/boot/loader.conf# ein:

[.programlisting]
....
hw.psm.synaptics_support="1"
....

Fügen Sie die folgende Zeile in [.filename]#/etc/X11/xorg.conf# ein:

[.programlisting]
....
Section "InputDevice"
Identifier  "Touchpad0"
Driver      "synaptics"
Option      "Protocol" "psm"
Option      "Device" "/dev/psm0"
EndSection
....

Und fügen Sie die folgende Zeile in den Abschnitt "ServerLayout" hinzu:

[.programlisting]
....
InputDevice    "Touchpad0" "SendCoreEvents"
....

=== Wie verwende ich entfernte X-Displays?

Aus Sicherheitsgründen verbietet der X-Server in der Voreinstellung Verbindungen von entfernten Systemen.

Starten Sie den X mit der Option `-listen_tcp`, wenn Sie Verbindungen von entfernten Systemen erlauben wollen:

[source,bash]
....
% startx -listen_tcp
....

=== Was ist eine virtuelle Konsole und wie erstelle ich mehr davon?

Mit virtuellen Konsolen können Sie mehrere simultane Sitzungen auf einer Maschine laufen lassen, ohne so komplizierte Dinge wie die Einrichtung eines Netzwerkes oder die Benutzung von X zu benötigen.

Wenn das System startet, wird es nach der Anzeige aller Bootmeldungen eine Eingabeaufforderung auf dem Bildschirm anzeigen. Sie können dann auf der ersten virtuellen Konsole Ihren Benutzernamen und das Passwort eingeben und anfangen, zu arbeiten.

Um eine weitere Sitzung zu starten, vielleicht, um die Dokumentation zu einem Programm, das Sie gerade benutzen, einzusehen, oder, um Ihre Mails zu lesen, während Sie auf das Ende einer FTP-Übertragung warten. Drücken Sie kbd:[Alt]kbd:[F2] und Sie gelangen zur Anmelde-Aufforderung auf der zweiten virtuellen Konsole. Wenn Sie zurück zur ersten Sitzung möchten, drücken Sie  kbd:[Alt+F1].

Die Standardinstallation von FreeBSD bietet acht aktivierte virtuelle Konsolen. Mit  kbd:[Alt+F1],  kbd:[Alt+F2],  kbd:[Alt+F3] und so weiter wechseln Sie zwischen diesen virtuellen Konsolen.

Um weitere virtuelle Konsolen zu aktivieren, editieren Sie [.filename]#/etc/ttys# (man:ttys[5]) und fügen Einträge für [.filename]#ttyv8# bis zu [.filename]#ttyvc# nach dem Kommentar zu "Virtual terminals" ein:

[.programlisting]
....
# Edit the existing entry for ttyv8 in /etc/ttys and change
# "off" to "on".
ttyv8   "/usr/libexec/getty Pc"         xterm  on secure
ttyv9   "/usr/libexec/getty Pc"         xterm  on secure
ttyva   "/usr/libexec/getty Pc"         xterm  on secure
ttyvb   "/usr/libexec/getty Pc"         xterm  on secure
....

Benutzen Sie so wenig oder so viele, wie Sie möchten. Je mehr virtuelle Terminals Sie benutzen, desto mehr Ressourcen werden gebraucht; das kann wichtig sein, wenn Sie 8 MB RAM oder weniger besitzen. Sie können auch `secure` in `insecure` ändern.

[NOTE]
====
FreeBSD 9.0 und ältere Versionen verwenden den Terminaltyp "cons25" und nicht "xterm". Benutzen Sie beim Hinzufügen von neuen Einträgen in [.filename]#/etc/ttys# das Format der bereits bestehenden Einträge.
====

[IMPORTANT]
====
Wenn Sie einen X-Server benutzen möchten, müssen Sie mindestens ein virtuelles Terminal ausgeschaltet (`off`) lassen damit der Server es benutzen kann. Das heißt, dass Ihnen nur 11 Alt-Funktionstasten für virtuelle Konsolen zur Verfügung stehen, die letzte ist für den X-Server bestimmt.
====

Um beispielsweise X und elf virtuelle Konsolen auszuführen, sollte die Einstellung für das virtuelle Terminal 12 wie folgt sein:

[.programlisting]
....
ttyvb   "/usr/libexec/getty Pc"         xterm  off secure
....

Sie können das System neu starten, um die virtuellen Konsolen zu aktivieren.

=== Wie greife ich von X aus auf virtuelle Konsolen zu?

Benutzen Sie  kbd:[Strg+Alt+Fn] um auf eine virtuelle Konsole umzuschalten. Mit  kbd:[Strg+Alt+F1] schalten Sie zur ersten virtuellen Konsole.

Sobald Sie auf eine virtuelle Konsole umgeschaltet haben, können Sie  kbd:[Alt+Fn] benutzen, um zwischen den einzelnen virtuellen Konsolen umzuschalten.

Um zur X-Sitzung zurückzukehren, müssen Sie auf die virtuelle Konsole umschalten, auf der X läuft. Wenn Sie X über der Eingabeaufforderung mit `startx` gestartet haben, benutzt X die nächste freie virtuelle Konsole und nicht die Konsole, von der es gestartet wurde. Wenn Sie acht aktive virtuelle Konsolen haben, dann wird X die neunte benutzen und Sie können mit  kbd:[Alt+F9] umschalten.

[[xdm-boot]]
=== Wie starte ich XDM beim Booten?

Es gibt zwei Denkansätze, wie man:xdm[1] zu starten ist. Bei dem einen wird `xdm` unter Nutzung des mitgelieferten Beispiels über [.filename]#/etc/ttys# (siehe man:ttys[5]) gestartet, während beim zweiten Ansatz [.filename]#rc.local# (siehe man:rc[8]) oder das Skript [.filename]#X# aus [.filename]#/usr/local/etc/rc.d# verwendet wird. Beide Ansätze sind gleichwertig und der eine wird in Situationen funktionieren, in denen der andere es nicht tut. In beiden Fällen ist das Ergebnis das gleiche: X liefert eine graphische Anmeldeaufforderung.

Die man:ttys[5]-Methode hat den Vorteil, dass dokumentiert ist, auf welchem vty X gestartet wird und der Neustart des X-Servers beim Abmelden an man:init[8] übergeben wird. Die man:rc[8]-Methode erleichtert den Aufruf von `kill xdm`, falls Probleme beim Start des X-Servers auftreten sollten.

Beim Laden von man:rc[8], sollte `xdm` ohne irgendwelche Argumente (das heißt als Daemon) gestartet werden. `xdm` muss gestartet werden _nachdem_man:getty[8] läuft, andernfalls entsteht ein Konflikt zwischen `getty` und `xdm` und die Konsole bleibt gesperrt. Der beste Weg, um dies zu vermeiden, ist, das Skript für etwa zehn Sekunden anzuhalten und dann `xdm` zu starten.

Wenn Sie `xdm` durch einen Eintrag in [.filename]#/etc/ttys# starten lassen, kann es zu einem Konflikt zwischen `xdm` und man:getty[8] kommen. Um dieses Problem zu vermeiden, sollten Sie die Nummer des `vt` in [.filename]#/usr/local/lib/X11/xdm/Xservers# eintragen:

[.programlisting]
....
:0 local /usr/local/bin/X vt4
....

Diese Zeile führt dazu, dass der X Server [.filename]#/dev/ttyv3# nutzt. Die beiden Zahlen weichen voneinander ab: Der X-Server beginnt die Zählung der vty bei 1, während der FreeBSD-Kernel bei 0 beginnt.

=== Wieso erhalte ich die Meldung Couldn't open console, wenn ich xconsole starte?

Wenn X mit `startx` gestartet wird, werden die Zugriffsrechte für [.filename]#/dev/console#_nicht_ geändert, was dazu führt, dass Dinge wie `xterm -C` und `xconsole` nicht funktionieren.

Das hängt damit zusammen, wie die Zugriffsrechte für die Konsole standardmäßig gesetzt sind. Auf einem Mehrbenutzersystem möchte man nicht unbedingt, dass jeder Benutzer einfach auf die Systemkonsole schreiben kann. Für Benutzer, die sich auf einer Maschine direkt mit einem VTY anmelden, existiert die Datei man:fbtab[5], um derartige Probleme zu lösen.

In Kürze: sorgen Sie dafür, dass sich in der Datei [.filename]#/etc/fbtab# (siehe man:fbtab[5]) eine nicht auskommentierte Zeile der folgenden Art befindet:

[.programlisting]
....
/dev/ttyv0 0600 /dev/console
....

Das sorgt dafür, dass wer auch immer sich auf [.filename]#/dev/ttyv0# anmeldet, auch die Konsole besitzt.

=== Warum funktioniert meine PS/2-Maus nicht richtig?

Ihre Maus und der Maustreiber sind vielleicht aus der Synchronisation geraten. In seltenen Fällen kann auch der Treiber irrtümlicherweise Synchronisationsprobleme melden:

[.programlisting]
....
psmintr: out of sync (xxxx != yyyy)
....

Falls das passiert, deaktivieren Sie den Code zur Überprüfung der Synchronisation, indem Sie die Treiberangaben für den PS/2-Maustreiber auf `0x100` setzen. Dazu fügen Sie einfach `hint.psm.0.flags="0x100"` in [.filename]#/boot/loader.conf# ein und starten das System anschließend neu.

=== Wie vertausche ich die Maustasten?

Geben Sie `xmodmap -e "pointer = 3 2 1"` ein. Fügen Sie dieses Kommando in [.filename]#~/.xinitrc# oder [.filename]#~/.xsession# hinzu, damit dies automatisch geschieht.

=== Wie installiere ich einen Splash-Screen und wo finde ich sie?

Die detaillierte Antwort auf diese Frage finden Sie im Abschnitt link:{handbook}#boot-splash/[Willkommensbildschirme während des Bootvorgangs konfigurieren] des FreeBSD Handbuchs.

=== Kann ich die Windows-Tasten unter X benutzen?

Ja, Sie müssen lediglich mit man:xmodmap[1] festlegen, welche Aktion diese Tasten auslösen sollen.

Unter der Annahme, dass alle Windows-Tastaturen dem Standard entsprechen, lauten die Keycodes für die drei Tasten wie folgt:

* 115 - kbd:[Windows]-Taste zwischen den kbd:[Strg]- und kbd:[Alt]-Tasten auf der linken Seite
* 116 - kbd:[Windows]-Taste rechts von der kbd:[AltGr]-Taste
* 117 - kbd:[Menü]-Taste, links von der rechten kbd:[Strg]-Taste

Nach der folgenden Anweisung erzeugt die linke kbd:[Windows]-Taste ein Komma.

[source,bash]
....
# xmodmap -e "keycode 115 = comma"
....

Um die neue Belegung der Windows-Tasten automatisch bei jedem Start von X zu erhalten, könnten entsprechende `xmodmap` Anweisungen in [.filename]#~/.xinitrc# einfügt werden. Die bevorzugte Variante ist aber, eine Datei mit dem Namen [.filename]#~/.xmodmaprc# zu erzeugen, die nur die Parameter für den Aufruf von `xmodmap` enthält. Wenn Sie mehrere Tasten umdefinieren wollen, muss jede Definition in eine eigene Zeile gesetzt werden. Weiterhin müssen Sie in [.filename]#~/.xinitrc# die folgende Zeile einfügen:

[.programlisting]
....
xmodmap $HOME/.xmodmaprc
....

Sie könnten die drei Tasten zum Beispiel mit den Funktionen kbd:[F13], kbd:[F14], und kbd:[F15] belegen. Dadurch ist es sehr einfach, diese Tasten mit nützlichen Funktionen eines Programmes oder Desktops zu verknüpfen.

Um dies zu tun, fügen Sie die folgenden Zeilen in [.filename]#~/.xmodmaprc# ein.

[.programlisting]
....
keycode 115 = F13
keycode 116 = F14
keycode 117 = F15
....

Falls Sie zum Beispiel package:x11-wm/fvwm2[] benutzen, können Sie ihn so einstellen, dass kbd:[F13] das Fenster unter dem Mauszeiger minimiert bzw. maximiert. kbd:[F14] holt das Fenster unter dem Mauszeiger in den Vordergrund bzw. ganz nach hinten, wenn es bereits im Vordergrund ist. kbd:[F15] öffnet das Arbeitsplatz-Menü, auch wenn der Cursor nicht auf den Hintergrund zeigt. Dies ist extrem praktisch, wenn der gesamte Bildschirm von Fenster belegt wird.

Dieses Verhalten erhält man mit den folgenden Einträgen in [.filename]#~/.fvwmrc#:

[.programlisting]
....
Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop
....

=== Wird 3D Hardware Beschleunigung für OpenGL unterstützt?

Dies hängt davon ab, welche Version von Xorg und welche Grafikkarte Sie verwenden. Wenn Sie eine Karte mit nVidia-Chipsatz besitzen, benutzen Sie die binären Treiber für FreeBSD, indem Sie einen der folgenden Ports installieren:

Die aktuelle Version von nVidia-Karten wird durch den Port package:x11/nvidia-driver[] unterstützt.

Unterstützung für ältere Treiber finden Sie in package:x11/nvidia-driver-###[]

nVidia liefert detaillierte Informationen darüber, welche Karte von welchem Treiber unterstützt wird. Diese Information finden Sie auf der Website http://www.nvidia.com/object/IO_32667.html[http://www.nvidia.com/object/IO_32667.html].

Für Matrox G200/400 können Sie den Port package:x11-servers/mga_hal[] benutzen.

Bei ATI Rage 128 und Radeon lesen Sie man:ati[4], man:r128[4] und man:radeon[4].

== Netzwerke

=== Woher kann ich Informationen über Diskless Booting bekommen?

"Diskless Booting" bedeutet, dass die FreeBSD-Maschine über ein Netzwerk gebootet wird und die notwendigen Dateien von einem Server anstatt von der Festplatte liest. Vollständige Details finden Sie im link:{handbook}#network-diskless/[Handbucheintrag über den plattenlosen Betrieb].

=== Kann eine FreeBSD-Maschine als Netzwerkrouter genutzt werden?

Ja. Genaue Informationen zu diesem Thema finden Sie im Abschnitt link:{handbook}#network-routing/[Gateways und Routen] des Handbuchkapitels link:{handbook}#advanced-networking/[Weiterführende Netzwerkthemen].

=== Kann ich meine Windows-Maschine über FreeBSD ans Internet anbinden?

Personen, die diese Frage stellen, haben typischerweise zwei PCs zu Hause: einen mit FreeBSD und einen mit einer Windows(TM)-Variante. Die Idee ist, die FreeBSD-Maschine an das Internet anzubinden, um in der Lage zu sein, von der Windows(TM)-Maschine über die FreeBSD-Maschine auf das Internet zuzugreifen. Das ist tatsächlich nur ein Spezialfall der vorherigen Frage.

Wenn Sie eine Einwahlverbindung benutzen, müssen Sie `ppp` mit der Option `-nat` verwenden und in [.filename]#/etc/rc.conf# die Variable `gateway_enable` auf _YES_ setzen. Weitere Informationen erhalten Sie in man:ppp[8] oder im Abschnitt link:{handbook}#userppp/[User-PPP des Handbuchs].

Wenn die Verbindung zum Internet über Ethernet erstellt wurde, müssen Sie man:natd[8] benutzen. Weitere Informationen dazu finden Sie im Abschnitt link:{handbook}#network-natd[natd] des Handbuchs.

=== Unterstützt FreeBSD und PPP?

Ja. man:ppp[8] bietet Unterstützung für eingehende und ausgehende Verbindungen.

Weitere Informationen finden Sie im link:{handbook}#ppp-and-slip/[Kapitel PPP im Handbuch].

=== Unterstützt FreeBSD NAT oder Masquerading?

Ja. Wenn Sie NAT über eine User-PPP-Verbindung einsetzen wollen, lesen Sie den link:{handbook}#userppp/[Abschnitt PPP des Handbuchs]. Wollen Sie NAT über eine andere Verbindung einsetzen, lesen Sie bitte den Abschnitt link:{handbook}#network-natd/[NAT Konfiguration] im Handbuch.

=== Wie kann ich Ethernet-Aliase einrichten?

Wenn sich die zweite Adresse im gleichen Subnetz befindet wie eine der Adressen, die bereits auf der Schnittstelle konfiguriert sind, benutzen Sie `netmask 0xffffffff` wie in diesem Beispiel:

[source,bash]
....
# ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff
....

Andernfalls geben sie die Adresse und die Netzmaske wie gewohnt an:

[source,bash]
....
# ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00
....

Weitere Informationen finden Sie im FreeBSD link:{handbook}#configtuning-virtual-hosts/[Handbuch].

=== Warum kann ich per NFS nicht von einer Linux-Maschine mounten?

Einige Versionen des Linux(TM) NFS-Codes akzeptieren Mount-Anfragen nur von einem privilegierten Port. Versuchen Sie den folgenden Befehl:

[source,bash]
....
# mount -o -P linuxbox:/blah /mnt
....

=== Warum meldet mir mountd auf meinem FreeBSD NFS-Server ständig can't change attributes und bad exports list?

Die häufigste Ursache für dieses Problem ist, dass Sie den Aufbau der [.filename]#/etc/exports# nicht richtig verstanden haben. Lesen Sie man:exports[5] und das Kapitel link:{handbook}#network-nfs/[NFS] im Handbuch, speziell den Abschnitt link:{handbook}#configuring-nfs[Konfiguration von NFS].

=== Wie aktiviere ich die Unterstützung für IP-Multicast?

Installieren Sie das Paket oder den Port package:net/mrouted[] und fügen Sie `mrouted_enable="YES"` in [.filename]#/etc/rc.conf# hinzu, um den Dienst beim Booten zu starten.

=== Warum muss ich für Hosts auf meiner Site den FQDN benutzen?

Die Antwort hierzu finden Sie im FreeBSD link:{handbook}#mail-trouble[Handbuch].

=== Wieso erhalte ich bei allen Netzwerkoperationen die Meldung Permission denied?

Wenn der Kernel mit der Option `IPFIREWALL` kompiliert wurde, müssen Sie beachten, dass die Standardrichtlinie alle Pakete, die nicht explizit zulässig sind, verweigert.

Wenn die Firewall unabsichtlich falsch konfiguriert wurde, stellen Sie die Netzwerkfunktionalität wieder her, indem Sie Folgendes als `root` eingeben:

[source,bash]
....
# ipfw add 65534 allow all from any to any
....

Sie können in [.filename]#/etc/rc.conf# auch `firewall_type="open"` setzen.

Weitere Informationen über die Konfiguration dieser Firewall finden Sie im Kapitel link:{handbook}#firewalls-ipfw/[IPFW] des Handbuchs.

=== Warum kann ich mit ipfw einen Dienst nicht mit fwd auf eine andere Maschine umlenken?

Wahrscheinlich benötigen Sie Network Address Translation (NAT) und nicht die einfache Weiterleitung von Paketen. Die "fwd"-Regel leitet lediglich Pakete weiter; die Daten in den Paketen werden aber nicht verändert. Ein Beispiel:

[source,bash]
....
01000 fwd 10.0.0.1 from any to foo 21
....

Wenn ein Paket mit dem Ziel _foo_ die Maschine mit dieser Regel erreicht, wird das Paket an _10.0.0.1_ weitergeleitet; die Zieladresse im Paket lautet aber immer noch _foo_! Die Zieladresse wird nicht in _10.0.0.1_ geändert. Die meisten Rechner werden allerdings Pakete verwerfen, wenn die Zieladresse des Paketes nicht mit der Adresse des Rechners übereinstimmt. Das ist der Grund, warum eine "fwd" Regel oft nicht den Effekt hat, den der Benutzer wollte. Dieses Verhalten ist aber kein Fehler, sondern erwünscht.

Wenn Sie einen Dienst auf eine andere Maschine umleiten wollen, sollten Sie die <<service-redirect,FAQ über die Umleitung von Diensten>> und die Manualpage man:natd[8] lesen. Auch in der https://www.FreeBSD.org/ports/[Ports Sammlung] sind diverse Hilfsprogramme für diesen Zweck enthalten.

=== Wie kann ich Service-Anfragen von einer Maschine auf eine andere umleiten?

Sie können für FTP und andere Dienste mit dem Paket oder Port package:sysutils/socket[] umleiten. Ersetzen sie die Befehlszeile für den Dienst in [.filename]#/etc/inetd.conf# einfach so, dass stattdessen `socket` aufgerufen wird, wie in diesem Beispiel für ftpd zu sehen ist:

[.programlisting]
....
ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.example.com ftp
....

wobei _ftp.example.com_ und _ftp_ entsprechend der Host und der Port sind, wohin umgeleitet werden soll.

=== Woher kann ich ein Bandbreiten-Managementtool bekommen?

Für FreeBSD gibt es drei Bandbreiten-Managementtools. man:dummynet[4] ist als Teil von man:ipfw[4] in FreeBSD integriert. http://www.sonycsl.co.jp/person/kjc/programs.html[ALTQ] ist in FreeBSD Bestandteil von man:pf[4]. Beim Bandbreiten-Manager von http://www.etinc.com/[Emerging Technologies] handelt es sich hingegen um ein kommerzielles Produkt.

=== Warum erhalte ich die Meldung /dev/bpf0: device not configured?

Der Berkeley Paket Filter (man:bpf[4]) muss in den Kernel eingebunden werden, bevor er von einem Programm genutzt werden kann. Fügen Sie folgendes zur Kernelkonfigurationsdatei hinzu und erstellen Sie einen neuen Kernel:

[.programlisting]
....
device bpf        # Berkeley Packet Filter
....

=== Habe ich, analog zum smbmount von Linux, eine Möglichkeit, auf ein freigegebenes Laufwerk einer Windows-Maschine in meinem Netzwerk zuzugreifen?

Benutzen Sie die Programme aus dem Paket SMBFS. Es enthält einige Kernel-Erweiterungen und Benutzerprogramme. Die Programme und weitergehende Informationen sind unter man:mount_smbfs[8] im Basissystem verfügbar.

=== Was bedeutet die Meldung Limiting icmp/open port/closed port response in meinen Logdateien?

Diese Kernelmeldung deutet darauf hin, dass irgend jemand versucht, die Generierung von sehr vielen ICMP oder TCP reset (RST) Antworten zu provozieren. ICMP Antworten sind oft das Ergebnis von Verbindungsversuchen zu unbenutzten UDP Ports. TCP Resets werden generiert, wenn jemand versucht, eine Verbindung zu einem ungenutzten TCP Port aufzubauen. Die Meldungen können unter anderem durch die folgenden Ereignisse ausgelöst werden:

* Brute-force Denial of Service (DoS) Angriffe (im Gegensatz zu Angriffen mit einzelnen Paketen, welche gezielt eine Schwachstelle des Systems ausnutzen).
* Port Scans, bei denen versucht wird, Verbindungen zu einer großen Anzahl von Ports (und nicht nur einigen bekannten Ports) herzustellen.

Die erste Zahl gibt an, wie viele Pakete vom Kernel ohne das Limit versendet worden wären; die zweite Zahl gibt das Limit an. Sie können das Limit mit der sysctl-Variable `net.inet.icmp.icmplim` einstellen. Im Beispiel wird das Limit auf `300` Pakete pro Sekunde gesetzt:

[source,bash]
....
# sysctl net.inet.icmp.icmplim=300
....

Wenn Sie zwar die Begrenzung benutzen möchten, aber die Meldungen nicht in den Logdateien sehen möchten, können Sie die Meldungen mit der sysctl-Variable `net.inet.icmp.icmplim_output` abschalten:

[source,bash]
....
# sysctl net.inet.icmp.icmplim_output=0
....

Falls Sie die Begrenzung ganz abschalten wollen, können Sie die sysctl-Variable `net.inet.icmp.icmplim` auf `0`. Wir raten Ihnen aus den oben genannten Gründen dringend von diesem Schritt ab.

=== Was bedeutet die Meldung arp: unknown hardware address format?

Ein Gerät im lokalen Ethernet verwendet eine MAC-Adresse in einem Format, das FreeBSD nicht kennt. Der wahrscheinlichste Grund ist, dass jemand Experimente mit einer Ethernet-Karte anstellt. Die Meldung tritt sehr häufig in Netzwerken mit Cable Modems auf. Die Meldung ist harmlos und sollte die Leistung des Systems nicht negativ beeinflussen.

=== Warum sehe ich ständig Nachrichten wie: 192.168.0.10 is on fxp1 but got reply from 00:15:17:67:cf:82 on rl0, und wie stelle ich das ab?

Weil ein Paket unerwartet von außerhalb des Netzwerks empfangen wurde. Um die Nachrichten abzustellen, ändern Sie `net.link.ether.inet.log_arp_wrong_iface` auf `0`.

== Sicherheit

=== Was ist ein Sandkasten (sandbox)?

"Sandkasten" (sandbox) ist ein Ausdruck aus dem Bereich Sicherheit. Er hat zwei Bedeutungen:

* Ein Programm, das innerhalb virtueller Wände ausgeführt wird. Wenn ein Angreifer über eine Sicherheitslücke in diesen Programm einbricht, verhindern diese Wände ein tieferes Vordringen in das System.
+ 
Der Prozess kann innerhalb der Wände laufen, das heißt nichts, was der Prozess in Bezug auf die Ausführung von Code tut, kann die Wände durchbrechen. Es ist also keine detaillierte Revision des Codes erforderlich, um gewisse Aussagen über seine Sicherheit machen zu können.
+ 
Die Wände könnten z.B. eine Benutzerkennung sein. Dies ist die Definition, die in den Manualpages man:security[7] und man:named[8] benutzt wird.
+ 
Nehmen Sie zum Beispiel den Dienst `ntalk` (siehe man:inetd[8]). Dieser Dienst ist früher mit der Benutzerkennung `root` gelaufen; nun läuft er mit der Benutzerkennung `tty`. Der Benutzer `tty` ist ein Sandkasten, der dazu gedacht ist, es jemandem, der über `ntalk` erfolgreich in das System eingebrochen ist, schwer zu machen, über diese Benutzerkennung hinaus vorzudringen.
* Ein Prozess, der sich innerhalb einer simulierten Maschine befindet. Dies ist etwas fortgeschrittener; grundsätzlich bedeutet es, dass jemand, der in der Lage ist, in einen Prozess einzudringen, annehmen könnte, er könnte weiter in die Maschine eindringen, tatsächlich aber nur in eine Simulation der Maschine einbricht und keine echten Daten verändert.
+ 
Der gängigste Weg, dies zu erreichen, ist, in einem Unterverzeichnis eine simulierte Umgebung zu erstellen und den Prozess in diesem Verzeichnis mit chroot auszuführen (für diesen Prozess ist [.filename]#/# dieses Verzeichnis und nicht das echte [.filename]#/# des Systems).
+ 
Eine weitere gebräuchliche Anwendung ist, ein untergeordnetes Dateisystem nur mit Leserechten zu mounten, und dann darüber eine Dateisystemebene zu erstellen, die einem Prozess einen scheinbar schreibberechtigten Blick in das Dateisystem gibt. Der Prozess mag glauben, dass er in der Lage ist, diese Dateien zu verändern, aber nur der Prozess sieht diesen Effekt - andere Prozesse im System natürlich nicht.
+ 
Es wird versucht, diese Art von Sandkasten so transparent zu gestalten, dass der Benutzer (oder Hacker) nicht merkt, dass er sich in ihm befindet.

UNIX(TM) implementiert zwei Arten von Sandkästen - eine auf Prozessebene und die andere auf der Ebene der Benutzerkennung.

Jeder Prozess unter UNIX(TM) ist komplett von allen anderen Prozessen abgeschirmt. Ein Prozess kann den Adressraum eines anderen Prozesses nicht modifizieren.

Ein UNIX(TM) Prozess gehört einer bestimmten Benutzerkennung. Falls die Benutzerkennung nicht die von `root` ist, dient sie dazu, den Prozess von Prozessen anderer Benutzer abzuschirmen. Die Benutzerkennung wird außerdem dazu genutzt, Daten auf der Festplatte abzuschirmen.

=== Was sind die Sicherheitsstufen (securelevel)?

Sicherheitsstufen (`securelevel`) sind ein Sicherheitsmechanismus, der im Kernel implementiert ist. Wenn die Sicherheitsstufe einen positiven Wert hat, verhindert der Kernel die Ausführung bestimmter Tätigkeiten; nicht einmal der Super-User (`root`) darf sie durchführen. Zurzeit können über die Sicherheitsstufen unter anderem die folgenden Tätigkeiten geblockt werden:

* Zurücksetzen bestimmter Dateiattribute, wie zum Beispiel `schg` (das "system immutable" Attribut).
* Schreibender Zugriff auf die Speicherbereiche des Kernels mittels [.filename]#/dev/mem# und [.filename]#/dev/kmem#.
* Laden von Kernel-Modulen.
* Änderungen an den Firewall-Regeln.

Das folgende Kommando kann benutzt werden, um die eingestellte Sicherheitsstufe eines aktiven Systems abzufragen:

[source,bash]
....
# sysctl -n kern.securelevel
....

Die Ausgabe enthält den aktuellen Wert der Sicherheitsstufe. Wenn die Zahl positiv (größer als Null) ist, sind zumindest einige der Schutzmaßnahmen aktiviert.

Die Sicherheitsstufe eines laufenden Systems kann nicht verringert werden, da dies den Mechanismus nutzlos machen würde. Wenn Sie eine Tätigkeit ausführen müssen, bei der die Sicherheitsstufe nicht-positiv sein muss, dann müssen Sie die Variablen `kern_securelevel` und `kern_securelevel_enable` in [.filename]#/etc/rc.conf# ändern und das System neustarten.

Weitere Informationen über die Sicherheitsstufen und was die Einstellungen bewirken, können Sie man:init[8] entnehmen.

[WARNING]
====

Die Sicherheitsstufen sind kein magischer Zauberstab; es gibt viele bekannte Probleme. Und in der Mehrzahl der Fälle vermitteln sie ein falsches Gefühl von Sicherheit.

Eines der größten Probleme ist, dass alle für den Start des Systems benötigten Dateien geschützt sein müssen, damit die Sicherheitsstufe effektiv sein können. Wenn es ein Angreifer schafft, seine eigenen Programme ausführen zu lassen, bevor die Sicherheitsstufe gesetzt wird (was leider erst gegen Ende des Startvorgangs erfolgen kann, da viele der notwendigen Tätigkeiten für den Systemstart nicht mit einer gesetzten Sicherheitsstufe möglich wären), werden die Schutzmechanismen ausgehebelt. Es ist zwar nicht technisch unmöglich, alle beim Systemstart genutzten Dateien zu schützen; allerdings würde in einem so geschützten System die Administration zu einem Alptraum, da man das System neu starten oder in den Single-User-Modus bringen müsste, um eine Konfigurationsdatei ändern zu können.

Dieses und andere Probleme werden häufig auf den Mailinglisten diskutiert, speziell auf auf der http://lists.FreeBSD.org/mailman/listinfo/freebsd-security[Mailingliste FreeBSD security]. Das verfügbare https://www.FreeBSD.org/search/[Archiv] enthält ausgiebige Diskussionen. Einige Benutzer sind guter Hoffnung, dass das System der Sicherheitsstufen bald durch ein besser konfigurierbares System ersetzt wird.
====

=== Wieso wartet BIND (named) auf hohen Ports auf Anfragen?

BIND benutzt einen Port mit einer hohen, zufälligen Nummer für den Versand von Anfragen. Aktuelle Versionen wählen einen neuen, zufälligen UDP-Port für jede Anfrage. Das kann für manche Netzwerkkonfigurationen Probleme verursachen, besonders wenn eine Firewall eingehende UDP-Pakete auf bestimmten Ports blockiert. Wenn Sie durch eine solche Firewall wollen, können Sie die Optionen `avoid-v4-udp-ports` und `avoid-v6-udp-ports` ausprobieren, um ein zufälliges Auswählen von Portnummern innerhalb eines blockierten Bereiches zu verhindern.

[WARNING]
====

Wenn eine Portnummer (wie 53) über die Optionen `query-source` oder `query-source-v6` in [.filename]#/etc/namedb/named.conf# spezifiziert ist, wird zufällige Portauswahl nicht verwendet. Es wird dringend empfohlen, dass diese Optionen nicht für die Spezifikation von festen Portnummern verwendet wird.
====

Es ist eine sehr gute Angewohnheit, die Ausgaben von man:sockstat[1] durchzusehen und auf merkwürdige Dinge zu achten.

=== Wieso wartet der Sendmail-Dienst sowohl auf Port 587 als auch auf dem Standard-Port 25 auf Anfragen?

Aktuelle Versionen von Sendmail unterstützen eine Technik zur Einlieferung von Mails, die Port 587 nutzt. Diese Technik wird zwar noch nicht oft angewendet, erfreut sich aber ständig steigender Popularität.

=== Woher kommt dieser Benutzer toor mit UID 0? Ist mein System gehackt worden?

Keine Panik. `toor` ist ein "alternativer" Account für den Super-User (wenn man root rückwärts schreibt, erhält man toor). Dieser Account ist für die Verwendung mit einer alternativen Shell vorgesehen; damit ist es nicht mehr erforderlich, die Shell von `root` zu ändern. Dies ist wichtig, wenn eine Shell verwendet wird, die nicht zum Basissystem von FreeBSD gehört, zum Beispiel aus einem Port oder einem Paket. Diese Shells werden in der Regel in [.filename]#/usr/local/bin# installiert und dieses Verzeichnis liegt standardmäßig auf einem anderen Dateisystem. Wenn die Shell von `root` in [.filename]#/usr/local/bin# liegt und das Dateisystem, auf dem [.filename]#/usr/local/bin liegt# nicht gemountet werden kann, kann sich `root` nicht mehr einloggen, um das Problem zu beheben. Es ist allerdings möglich, das System zu rebooten und das Problem im Single-User-Modus zu lösen, da man hier gefragt wird, welche Shell benutzt werden soll.

Einige Anwender benutzen `toor` mit einer alternativen Shell für die tägliche Arbeit und benutzen `root` (mit der Standard-Shell) für den Single-User-Modus und für Notfälle. Standardmäßig kann man sich nicht als `toor` anmelden, da der Account kein gültiges Passwort hat; Sie müssen sich also als `root` anmelden und ein Passwort für `toor` setzen, wenn Sie diesen Account benutzen wollen.

== PPP

=== Ich bekomme ppp8 nicht zum Laufen. Was mache ich falsch?

Lesen Sie zuerst man:ppp[8] und den link:{handbook}#userppp[Abschnitt zu PPP im Handbuch]. Aktivieren Sie zur Fehlersuche die Protokollierung mit folgendem Befehl:

[.programlisting]
....
set log Phase Chat Connect Carrier lcp ipcp ccp command
....

Dieser Befehl kann an der Eingabeaufforderung von man:ppp[8] eingegeben, oder in den Abschnitt `default` der Konfigurationsdatei [.filename]#/etc/ppp/ppp.conf# eingetragen werden. Stellen Sie sicher, dass die Datei [.filename]#/etc/syslog.conf# die folgenden Zeilen enthält und die Datei [.filename]#/var/log/ppp.log# existiert:

[.programlisting]
....
!ppp
*.*        /var/log/ppp.log
....

Sie können nun in der Protokolldatei eine Menge darüber herausfinden, was geschieht. Es macht nichts, wenn die Einträge Ihnen gar nichts sagen. Wenn Sie jemandem um Hilfe bitten müssen, könnten sie für ihn von Nutzen sein.

=== Warum hängt sich ppp8 auf, wenn ich es benutze?

Das liegt meistens daran, dass der Rechnername nicht aufgelöst werden kann. Um dieses Problem zu lösen, müssen Sie sicherstellen, dass [.filename]#/etc/hosts# vom Resolver zuerst genutzt wird. Dazu muss in [.filename]#/etc/host.conf# der Eintrag `hosts` an die erste Stelle gesetzt werden. Erstellen Sie dann für den lokalen Rechner einen Eintrag in [.filename]#/etc/hosts#. Falls es kein lokales Netzwerk gibt, ändern Sie die `localhost`-Zeile:

[.programlisting]
....
127.0.0.1        foo.example.com foo localhost
....

Andernfalls fügen Sie einfach einen weiteren Eintrag für den lokalen Rechner hinzu. Weitere Informationen finden Sie in den entsprechenden Manualpages.

Wenn Sie fertig sind sollten Sie `ping -c1 hostname` erfolgreich ausführen können.

=== Warum wählt man:ppp[8] im -auto-Modus nicht?

Überprüfen Sie zunächst, ob eine Standardroute existiert. Das folgende Kommando sollte zwei Einträge anzeigen:

[.programlisting]
....
Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0
....

Wenn die Standardroute nicht erscheint, stellen Sie sicher, dass die Zeile `HISADDR` in [.filename]#/etc/ppp/ppp.conf# hinzugefügt wurde.

Ein weiterer Grund dafür, dass die Zeile für die Standardroute fehlt, könnte der sein, dass Sie eine Standardroute in [.filename]#/etc/rc.conf# eingetragen und die folgende Zeile in [.filename]#/etc/ppp/ppp.conf# ausgelassen haben:

[.programlisting]
....
delete ALL
....

Lesen Sie in diesem Fall den Abschnitt link:{handbook}#userppp-final[Abschließende Systemkonfiguration] des Handbuchs.

=== Was bedeutet No route to host?

Dieser Fehler beruht für gewöhnlich auf einem fehlenden Abschnitt in [.filename]#/etc/ppp/ppp.linkup#:

[.programlisting]
....
MYADDR:
  delete ALL
  add 0 0 HISADDR
....

Er ist nur notwendig, wenn Sie eine dynamische IP-Adresse besitzen oder die Adresse des Gateways nicht bekannt ist. Wenn Sie den interaktiven Modus benutzen, können Sie folgendes eingeben, nachdem Sie in den packet mode gelangt sind (den Paket Modus erkennen Sie an PPP im Prompt):

[.programlisting]
....
delete ALL
add 0 0 HISADDR
....

Weitere Informationen finden Sie im Abschnitt link:{handbook}#userppp-dynamicip[PPP und Dynamische IP-Adressen] des Handbuchs.

=== Wieso werden meine Verbindungen nach ca. drei Minuten beendet?

Der Standardtimeout für PPP beträgt drei Minuten. Er kann durch die folgende Zeile eingestellt werden:

[.programlisting]
....
set timeout NNN
....

_NNN_ gibt die Inaktivität in Sekunden an, bevor die Verbindung geschlossen wird. Falls _NNN_ Null ist, wird die Verbindung niemals aufgrund eines Timeouts geschlossen. Es ist möglich, diesen Befehl in [.filename]#ppp.conf# einzubinden, oder ihn an der Eingabeaufforderung im interaktiven Modus einzugeben. Durch eine Verbindung zum Server-Socket von ppp über man:telnet[1] oder man:pppctl[8] ist es auch möglich, den Timeout bei aktiver Verbindung anzupassen. Weitere Informationen finden Sie in der Manualpage man:ppp[8].

=== Wieso bricht meine Verbindung bei hoher Auslastung ab?

Falls Link-Quality-Reporting (LQR) konfiguriert wurde, ist es möglich, dass zu viele LQR-Pakete zwischen dem FreeBSD-System und dem verbundenen Rechner verloren gehen. man:ppp[8] folgert daraus, dass die Verbindung nicht in Ordnung ist und schließt sie. LQR ist standardmäßig deaktiviert und kann mit der folgenden Zeile aktiviert werden:

[.programlisting]
....
enable lqr
....

=== Warum bricht die Verbindung nach unbestimmter Zeit zusammen?

Wenn die Qualität der Telefonleitung zu schlecht oder beim Anschluss die Option Anklopfen aktiviert ist, kann es manchmal vorkommen, dass das Modem auflegt, weil es fälschlicherweise annimmt, dass es das Trägersignal verloren hat.

Bei den meisten Modems gibt es eine Einstellmöglichkeit, um anzugeben, wie tolerant es gegenüber vorübergehenden Verlusten des Trägersignals sein soll. Lesen Sie die Dokumentation des Modems für weitere Informationen.

=== Warum hängt meine Verbindung nach einer unbestimmten Zeit?

Viele Leute machen Erfahrungen mit hängenden Verbindungen ohne erkennbaren Grund. Als erstes muss festgestellt werden, auf welcher Seite die Verbindung hängt.

Wenn Sie ein externes Modem benutzen, können Sie versuchen, man:ping[8] zu benutzen, um zu sehen, ob die TD-Anzeige aufleuchtet, wenn Daten übertragen werden. Falls sie aufleuchtet (und die RD-Anzeige nicht), liegt das Problem am anderen Ende. Falls TD nicht aufleuchtet, handelt es sich um ein lokales Problem. Bei einem internen Modem müssen Sie den Befehl `set server` in [.filename]#ppp.conf# benutzen. Stellen Sie über man:pppctl[8] eine Verbindung zu man:ppp[8] her, wenn die Verbindung hängt. Falls die Netzwerkverbindung plötzlich wieder funktioniert (ppp wurde durch die Aktivität auf dem Diagnose-Socket wiederbelebt) oder Sie keine Verbindung bekommen (vorausgesetzt, der Befehl `set socket` wurde beim Start erfolgreich ausgeführt), handelt es sich um ein lokales Problem. Falls Sie eine Verbindung bekommen und die externe Verbindung weiterhin hängt, aktivieren Sie lokales asynchrones Logging mit `set log local async` und benutzen Sie man:ping[8] von einem anderen Fenster oder Bildschirm aus, um die externe Verbindung zu benutzen. Das asynchrone Logging zeigt, welche Daten über die Verbindung gesendet und empfangen werden. Falls Daten hinausgehen, aber nicht zurückkommen, handelt es sich um ein externes Problem.

Wenn Sie festgestellt haben, ob es sich um ein lokales oder um ein externes Problem handelt, haben Sie zwei Möglichkeiten:

* Wenn es ein externes Problem ist, lesen Sie bei <<ppp-remote-not-responding>> weiter.
* Handelt es sich um ein lokales Problem, lesen Sie bitte <<ppp-hung>>.

[[ppp-remote-not-responding]]
=== Was kann ich machen, wenn die Gegenstelle nicht antwortet?

Hier können Sie wenig tun. Die meisten ISPs werden ablehnen, Ihnen zu helfen, wenn Sie kein Betriebssystem von Microsoft(TM) benutzen. Sie können `enable lqr` in [.filename]#/etc/ppp/ppp.conf# angeben, wodurch man:ppp[8] ermöglicht wird, ein externes Versagen zu erkennen und aufzulegen. Jedoch ist diese Erkennung relativ langsam und deshalb nicht besonders nützlich.

Versuchen Sie zunächst, jegliche Datenkompression auszuschalten, indem Sie folgendes zur Konfiguration hinzufügen:

[.programlisting]
....
disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj
....

Stellen Sie nun wieder eine Verbindung her, um festzustellen, ob sich etwas geändert hat. Falls es nun besser läuft oder falls das Problem vollständig behoben ist, versuchen Sie durch schrittweises Ändern der Einstellungen festzustellen, welche Einstellung den Unterschied bewirkt. Hierdurch erhalten Sie schlüssige Fakten für ein Gespräch mit dem ISP. Andererseits wird hierdurch offensichtlich, dass Sie kein Microsoft(TM)-System benutzen.

Aktivieren Sie asynchrones Logging und warten Sie, bis die Verbindung wieder hängt, bevor Sie sich an den ISP wenden. Hierzu kann einiges an Plattenplatz nötig sein. Die Daten, die als letztes von dem Port gelesen wurden, könnten von Interesse sein. Für gewöhnlich handelt es sich um ASCII-Text, der sogar den Fehler beschreiben kann (`Memory fault`, `Core dumped`).

Falls der ISP hilfsbereit ist, sollte er in der Lage sein, an seinem Ende das Logging zu aktivieren und wenn das nächste Mal die Verbindung abbricht, könnte er Ihnen mitteilen, worin das Problem auf seiner Seite besteht.

[[ppp-hung]]
=== Was kann ich tun, wenn sich man:ppp[8] aufhängt?

In diesem Fall erstellen Sie am besten man:ppp[8] mit Debugging-Informationen neu und benutzen dann man:gdb[1], um von dem hängenden ppp-Prozess eine Aufzeichnung des Stacks zu erstellen. Um die ppp-Anwendung mit Debugging-Informationen zu übersetzen, geben Sie folgendes ein:

[source,bash]
....
# cd /usr/src/usr.sbin/ppp
# env DEBUG_FLAGS='-g' make clean
# env DEBUG_FLAGS='-g' make install
....

Anschließend starten Sie ppp neu und warten darauf, dass es wieder hängt. Wenn die Debug-Version von ppp hängt, starten Sie gdb für den steckengebliebenen Prozess, indem Sie folgendes eingeben:

[source,bash]
....
# gdb ppp `pgrep ppp`
....

An der Eingabeaufforderung von gdb können Sie die Befehle `bt` oder `where` benutzen, um eine Aufzeichnung des Stacks zu erhalten. Speichern Sie die Ausgabe der gdb-Sitzung und "trennen" Sie den laufenden Prozess mit `quit`.

=== Ich sehe ständig Fehlermeldungen über gleiche Magic Numbers Was heißt das?

Nach dem Aufbau einer Verbindung kann es sein, dass Sie in der Logdatei gelegentlich Meldungen mit dem Hinweis `magic is the same` sehen. Manchmal sind diese Meldungen harmlos und manchmal bricht die eine oder andere Seite die Verbindung ab. Die meisten Implementierungen von PPP können dieses Problem nicht handhaben und Sie werden wiederholte Konfigurationsanforderungen und -bestätigungen in der Logdatei finden, bis man:ppp[8] schließlich aufgibt und die Verbindung beendet.

Dies geschieht normalerweise auf Servern mit langsamen Festplatten, bei denen ein man:getty[8] auf dem Port ausgeführt und man:ppp[8] nach dem Einloggen von einem Login-Skript oder einem Programm aus gestartet wird. Es wurde auch schon berichtet, dass dies bei der Benutzung von slirp regelmäßig auftritt. Der Grund hierfür ist, dass das man:ppp[8] auf der Client-Seite in der Zeit, die benötigt wird, man:getty[8] zu beenden und man:ppp[8] zu starten, bereits beginnt, Line Control Protocol (LCP) Pakete zu senden. Da ECHO auf dem Serverport weiterhin eingeschaltet ist, werden diese Pakete zum man:ppp[8] auf der Client-Seite "reflektiert".

Ein Teil der LCP-Verhandlungen ist die Einrichtung einer "Magic Number" für jede Seite der Verbindung, damit "Echos" erkannt werden können. Das Protokoll besagt, dass, wenn der Partner versucht, die gleiche "Magic Number" auszuhandeln, ein NAK zurückgesendet und eine neue "Magic Number" gewählt werden soll. Während der Server das ECHO eingeschaltet hat, sendet der Client LCP Pakete, sieht die gleiche "Magic Number" im reflektierten Paket und erzeugt ein NAK. Er sieht auch das reflektierte NAK (was bedeutet, dass man:ppp[8] seine "Magic Number" ändern muss). Hierdurch wird eine Vielzahl von Änderungen der "Magic Number" hervorgerufen, die sich allesamt im tty-Puffer des Servers ansammeln. Sobald man:ppp[8] auf dem Server startet, wird es mit Änderungen der "Magic Number" überflutet und entscheidet, dass es sich zur Genüge mit den LCP-Verhandlungen beschäftigt hat und gibt auf. Und während sich der Client noch darüber freut, dass er keine weiteren Reflexionen sieht, wird ihm gemeldet, dass der Server auflegt.

Dies kann verhindert werden, indem dem Partner durch die folgende Zeile in [.filename]#ppp.conf# erlaubt wird, mit der Verhandlung zu beginnen:

[.programlisting]
....
set openmode passive
....

Hierdurch wird man:ppp[8] mitgeteilt, darauf zu warten, dass der Server mit den LCP-Verhandlungen beginnt. Einige Server starten jedoch nie mit der Verhandlungen; falls dies der Fall ist, können Sie folgendes tun:

[.programlisting]
....
set openmode active 3
....

Hierdurch bleibt man:ppp[8] für drei Sekunden passiv und fängt dann erst an, LCP-Anforderungen zu senden. Falls der Partner während dieser Zeit beginnt, Anforderungen zu senden, wird man:ppp[8] direkt antworten und nicht erst, nachdem die drei Sekunden abgelaufen sind.

=== Die LCP-Verhandlungen dauern an, bis die Verbindung geschlossen wird. Was mache ich falsch?

Es gibt derzeit eine Fehlfunktion in der Implementierung von man:ppp[8], die darin besteht, dass LCP-, CCP- und IPCP-Antworten nicht mit den ursprünglichen Anforderungen assoziiert werden. Für den Fall, dass eine Implementation von PPP mehr als sechs Sekunden langsamer ist, als die andere Seite, resultiert das darin, dass die andere Seite zwei weitere LCP-Konfigurationsanforderungen sendet, was fatale Auswirkungen hat.

Stellen Sie sich zwei Implementierungen `A` und `B` vor. `A` beginnt unmittelbar nach der Verbindung, LCP-Anforderungen zu senden und `B` benötigt sieben Sekunden, zu starten. Wenn `B` startet, hat `A` bereits drei LCP-Anforderungen gesendet. Wir nehmen an, dass ECHO ausgeschaltet ist; andernfalls würden wir Probleme mit der "Magic Number" beobachten, wie bereits im vorherigen Abschnitt beschrieben. `B` sendet eine Anforderung und anschließend eine Bestätigung der ersten Anforderung von `A`. Dies führt dazu, dass `A` in den Zustand OPENED übergeht und eine Bestätigung (die erste) zurück an `B` sendet. In der Zwischenzeit sendet `B` zwei weitere Bestätigungen als Antwort auf die zusätzlichen Anforderungen, die von `A` gesendet worden sind, bevor `B` gestartet ist. `B` empfängt dann die erste Bestätigung von `A` und geht in den Zustand OPENED über. `A` empfängt die zweite Bestätigung von `B`, geht zurück in den Zustand REQ-SENT und sendet eine weitere (vierte) Anforderung entsprechend dem RFC. `A` empfängt dann die dritte Bestätigung und geht in den Zustand OPENED über. In der Zwischenzeit empfängt `B` die vierte Anforderung von `A`, wechselt in den Zustand ACK-SENT und sendet eine weitere (zweite) Anforderung und (vierte) Bestätigung entsprechend dem RFC. `A` erhält die Anforderung, geht in den Zustand REQ-SENT über, sendet eine weitere Anforderung, erhält unverzüglich die nächste Bestätigung und geht in OPENED über.

Das geht so lange weiter, bis eine Seite erkennt, dass man zu keinem Ergebnis gelangt und aufgibt.

Am besten verhindert man solche Situationen, indem man eine Seite als `passiv` konfiguriert, also dafür sorgt, dass eine Seite darauf wartet, dass die andere mit den Verhandlungen beginnt. Das kann durch den folgenden Befehl geschehen:

[.programlisting]
....
set openmode passive
....

Diese Option sollten Sie mit Vorsicht genießen. Folgenden Befehl sollten Sie benutzen, um die Wartezeit auf den Beginn der Verhandlungen des Partners von man:ppp[8] zu begrenzen:

[.programlisting]
....
set stopped N
....

Alternativ kann der folgende Befehl (wobei _N_ die Wartezeit in Sekunden vor Beginn der Verhandlungen angibt) benutzt werden:

[.programlisting]
....
set openmode active N
....

Weitere Informationen finden Sie in der Manualpage.

=== Warum reagiert ppp8 nicht mehr, wenn ich es mit shell verlassen habe?

Wenn Sie den Befehl `shell` oder `!` benutzen, führt man:ppp[8] eine Shell aus (falls Sie Argumente übergeben haben, führt man:ppp[8] diese Argumente aus). Das Programm ppp wartet auf die Beendigung des Befehls, bevor es seine Arbeit fortsetzt. Falls Sie versuchen, die PPP-Verbindung während der Programmausführung zu benutzen, wird es so aussehen, als wäre die Verbindung eingefroren. Das liegt daran, dass man:ppp[8] auf die Beendigung des Befehls wartet.

Falls Sie solche Befehle verwenden möchten, benutzen Sie stattdessen den Befehl `!bg`. Hierdurch wird der angegebene Befehl im Hintergrund ausgeführt und man:ppp[8] kann fortfahren, die Verbindung zu bedienen.

=== Warum wird ppp8 niemals beendet, wenn es über ein Nullmodem-Kabel benutzt wird?

Es gibt keine Möglichkeit für man:ppp[8], automatisch festzustellen, ob eine direkte Verbindung beendet worden ist. Das liegt an den Leitungen, die bei einem seriellen Nullmodem-Kabel benutzt werden. Wenn Sie diese Art der Verbindung verwenden, sollte LQR immer mit der folgenden Zeile aktiviert werden:

[.programlisting]
....
enable lqr
....

LQR wird standardmäßig akzeptiert, wenn es vom Partner ausgehandelt wird.

=== Warum wählt ppp8 im Modus -auto ohne Grund?

Falls man:ppp[8] unerwartet wählt, müssen Sie den Grund herausfinden und Wählfilter (dfilters) einsetzen, um dies zu verhindern.

Benutzen Sie die folgende Zeile, um den Grund herauszufinden:

[.programlisting]
....
set log +tcp/ip
....

Dadurch wird jeglicher Verkehr über die Verbindung protokolliert. Wenn das nächste mal unerwartet eine Verbindung hergestellt wird, wird der Grund zusammen mit einer hilfreichen Zeitangabe in der Logdatei gespeichert.

Sie können nun das Wählen aufgrund dieser Bedingungen verhindern. Normalerweise wird diese Art von Problemen durch Anfragen an den DNS verursacht. Um zu verhindern, dass DNS-Anfragen den Aufbau der Verbindung hervorrufen (das verhindert _nicht_, dass Pakete über eine bestehende Verbindung gesendet werden), benutzen Sie die folgenden Zeilen:

[.programlisting]
....
set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0
....

Dies ist nicht immer brauchbar, weil es effektiv die Fähigkeit, auf Anforderung wählen zu können einschränkt - die meisten Programme müssen eine DNS-Anfrage durchführen, bevor Sie andere, das Netzwerk betreffenden Dinge tun können.

Im Fall von DNS sollten Sie versuchen, herauszufinden, welches Programm tatsächlich versucht, einen Hostnamen aufzulösen. Sehr oft handelt es sich hier um Sendmail. Sie sollten sicherstellen, dass Sie Sendmail in der Konfigurationsdatei sagen, dass es keine DNS-Anfragen durchführen soll. Weitere Details enthält der Abschnitt link:{handbook}#smtp-dialup/[E-Mail über Einwahl-Verbindungen] des Handbuchs. Sie könnten z.B. die folgende Zeile in die [.filename]#.mc#-Datei einfügen:

[.programlisting]
....
define(`confDELIVERY_MODE', `d')dnl
....

Das veranlasst Sendmail dazu, alles in eine Warteschlange einzureihen, bis die Warteschlange verarbeitet wird (normalerweise alle 30 Minuten) oder wenn `sendmail -q` ausgeführt wird (z.B. aus [.filename]#/etc/ppp/ppp.linkup# heraus).

=== Was bedeuten diese CCP-Fehler?

Ich sehe ständig folgende Fehler in meiner Logdatei:

[.programlisting]
....
CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)
....

Das liegt daran, dass man:ppp[8] versucht, die Komprimierung Predictor1 auszuhandeln und der Partner über keinerlei Komprimierung verhandeln will. Die Meldungen sind harmlos, aber wenn Sie sie beseitigen möchten, können Sie die Komprimierung auch lokal ausschalten:

[.programlisting]
....
disable pred1
....

=== Warum protokolliert ppp8 die Geschwindigkeit meiner Verbindung nicht?

Um alle Zeilen der Modemkonversation zu protokollieren, müssen Sie folgendes einstellen:

[.programlisting]
....
set log +connect
....

Dies veranlasst man:ppp[8] dazu, alles bis zur letzten angeforderten "expect"-Zeile zu protokollieren.

Falls Sie die Geschwindigkeit der Verbindung erfahren möchten und PAP oder CHAP nutzen, müssen Sie sicherstellen, dass Sie man:ppp[8] so konfigurieren, die gesamte CONNECT-Zeile zu erwarten, etwa so:

[.programlisting]
....
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"
....

Hier bekommen wir unser CONNECT, senden nichts, erwarten dann einen Line-Feed, der man:ppp[8] zwingt, die gesamte CONNECT-Antwort zu lesen.

=== Warum ignoriert ppp8 das Zeichen \ in meinem Chat-Skript?

Das Programm ppp analysiert jede Zeile seiner Konfigurationsdatei, damit es Zeichenketten wie z.B. `set phone "123 456 789"` korrekt interpretieren und zudem erkennen kann, dass es sich bei der Nummer tatsächlich nur um ein Argument handelt. Um das Zeichen `"` anzugeben, müssen Sie ihm einen Backslash (`\`) voranstellen.

Wenn der Chat-Interpreter jedes Argument analysiert, reinterpretiert er die Argumente, um irgendwelche speziellen Escape-Sequenzen wie z.B. `\P` oder `\T` zu finden. Das Ergebnis dieser Doppelanalyse ist, dass Sie daran denken müssen, die richtige Anzahl an Escape-Zeichen zu verwenden.

Falls Sie tatsächlich das Zeichen `\` senden möchten, benutzen Sie etwas wie:

[.programlisting]
....
set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"
....

Woraus sich folgende Zeichen ergeben:

[.programlisting]
....
ATZ
OK
AT\X
OK
....

Oder:

[.programlisting]
....
set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"
....

Woraus sich folgende Zeichen ergeben:

[.programlisting]
....
ATZ
OK
ATDT1234567
....

=== Was sind FCS-Fehler?

FCS steht für Frame Check Sequence. Jedes PPP-Paket besitzt eine Checksumme, um sicherzustellen, dass die empfangenen Daten dieselben sind, wie die versendeten. Falls die FCS eines ankommenden Paketes fehlerhaft ist, wird das Paket verworfen und der Zähler HDLC FCS wird erhöht. Der HDLC-Fehlerwert kann durch den Befehl `show hdlc` angezeigt werden.

Falls die Leitung schlecht ist, oder falls der serielle Treiber Pakete verwirft, werden gelegentliche FCS-Fehler generiert. Normalerweise lohnt es sich nicht, sich hierüber Gedanken zu machen, obwohl das Kompressionsprotokoll hierdurch wesentlich langsamer wird.

Falls die Leitung einfriert, sobald die Verbindung steht, und viele FCS-Fehler auftreten, müssen Sie sicherstellen, dass das Modem keinen Software-Flow-Control (XON/XOFF) verwendet. Falls die Datenschnittstelle Software-Flow-Control verwenden muss, benutzen Sie den Befehl `set accmap 0x000a0000`, um man:ppp[8] zu sagen, dass es die Zeichen `^Q` und `^S` maskieren soll.

Ein weiterer Grund dafür, dass zu viele FCS-Fehler auftreten, könnte der sein, dass das andere Ende aufgehört hat, PPP zu sprechen. Aktivieren Sie `async` Logging, um festzustellen, ob es sich bei den eingehenden Daten tatsächlich um einen login- oder Shell-Prompt handelt. Wenn Sie am anderen Ende einen Shell-Prompt haben, ist es möglich, durch den Befehl `close lcp` gefolgt von `term` zu benutzen, um man:ppp[8] zu beenden, ohne die Verbindung zu beenden und Sie wieder mit der Shell auf dem entfernten Rechner verbinden.

Falls nichts in der Logdatei darauf hindeutet, warum die Verbindung beendet wurde, sollten Sie den Administrator oder ISP des externen Rechners fragen, warum die Sitzung beendet worden ist.

=== Nichts von alledem hilft - ich bin verzweifelt! Was soll ich machen?

Falls alles andere fehlschlägt, senden Sie möglichst umfangreiche Informationen, einschließlich Ihrer Konfigurationsdateien, wie Sie man:ppp[8] starten, die relevanten Teile Ihrer Logdateien und die Ausgabe von `netstat -rn` (vor und nach Aufbau der Verbindung) an die http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions[FreeBSD general questions mailing list].

== Serielle Verbindungen

Dieses Kapitel beantwortet häufig gestellte Fragen zu seriellen Verbindungen mit FreeBSD. PPP wird im Abschnitt <<networking,Netzwerke>> behandelt.

=== Welche seriellen Multi-Port-Karten werden von FreeBSD unterstützt?

Es existiert eine Liste der unterstützten Karten im Abschnitt link:{handbook}#serial/[Serielle Datenübertragung] des Handbuchs.

Die meisten auf den 16550 basierten PCI Multi-Port-Karten werden mühelos unterstützt.

Von einigen NoName-Nachbauten ist ebenfalls bekannt, dass sie funktionieren, speziell von den AST-kompatiblen.

In man:uart[4] und man:sio[4] finden Sie weitere Informationen zur Konfiguration solcher Karten.

=== Wie kann ich den boot:-Prompt auf einer seriellen Konsole anzeigen lassen?

Lesen Sie link:{handbook}#serialconsole-setup/[diesen Abschnitt] des Handbuchs.

=== Wie kann ich feststellen, ob FreeBSD meine seriellen Schnittstellen oder Modemkarten gefunden hat?

Wenn der FreeBSD Kernel bootet, testet er die seriellen Schnittstellen, für die er konfiguriert wurde. Sie können entweder aufmerksam die Bootmeldungen verfolgen, oder Sie führen den folgenden Befehl aus, nachdem das System hochgefahren ist und läuft:

[source,bash]
....
% dmesg | grep -E "^sio[0-9]"
sio0: <16550A-compatible COM port> port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
sio0: type 16550A
sio1: <16550A-compatible COM port> port 0x2f8-0x2ff irq 3 on acpi0
sio1: type 16550A
....

Dieses Beispiel zeigt zwei serielle Schnittstellen. Die erste verwendet Port-Adresse `0x3f8`, IRQ4 und hat einen 16550A UART Chip. Die zweite benutzt ebenfalls einen 16550A UART, jedoch Port-Adresse `0x2f8` und IRQ3. Modemkarten werden wie serielle Schnittstellen behandelt. Der einzige Unterschied ist, dass an diesen Schnittstellen immer ein Modem angeschlossen ist.

Der [.filename]#GENERIC#-Kernel beinhaltet Unterstützung für zwei serielle Schnittstellen, die den im Beispiel genannten Port und IRQ verwenden. Wenn diese Einstellungen nicht richtig für das System sind, Sie Modemkarten hinzugefügt oder mehr serielle Schnittstellen haben als die Kernelkonfiguration zulässt, konfigurieren Sie den Kernel einfach neu. In dem Kapitel über die <<make-kernel,Kernelkonfiguration>> finden Sie mehr Details.

=== Wie kann ich unter FreeBSD auf die seriellen Schnittstellen zugreifen?

Die dritte serielle Schnittstelle, [.filename]#sio2# ([.filename]#COM3#), ist [.filename]#/dev/cuad2# für Geräte mit abgehenden Verbindungen und [.filename]#/dev/ttyd2# für Geräte mit eingehenden Verbindungen. Was ist der Unterschied zwischen den beiden Geräteklassen?

Wird [.filename]#/dev/ttydX# im blockierenden Modus geöffnet, wartet ein Prozess darauf, dass das entsprechende [.filename]#cuadX# Gerät inaktiv und der Empfangssignalpegel aktiv ist. Wird das [.filename]#cuadX# Gerät geöffnet, vergewissert es sich, dass die serielle Schnittstelle nicht bereits von dem [.filename]#ttydX# Gerät in Gebrauch ist. Sollte die Schnittstelle verfügbar sein, "stiehlt" es sie von dem [.filename]#ttydX# Gerät. Das [.filename]#cuadX# Gerät kümmert sich nicht um Trägersignalerkennung. Mit diesem Schema und einem automatisch antwortenden Modem, können sich Benutzer von aussen einloggen, Sie können weiterhin mit demselben Modem wählen und das System kümmert sich um die Konflikte.

=== Wie kann ich die Unterstützung für eine Karte mit mehreren seriellen Schnittstellen aktivieren?

Der Abschnitt über die Kernelkonfiguration bietet Informationen darüber, wie Sie den Kernel konfigurieren. Für eine Karte mit mehreren seriellen Schnittstellen, schreiben Sie eine man:sio[4] Zeile für jede serielle Schnittstelle auf der Karte in die Datei man:device.hints[5]. Aber achten Sie darauf, den IRQ nur in einem der Einträge zu platzieren. Alle seriellen Schnittstellen auf der Karte sollten sich einen IRQ teilen. Daher sollten Sie den IRQ nur beim letzten Eintrag angeben. Aktivieren Sie auch die folgende Option in der Kernelkonfigurationsdatei:

[.programlisting]
....
options COM_MULTIPORT
....

Das folgende [.filename]#/boot/device.hints# Beispiel ist geeignet für eine AST Karte mit 4 seriellen Schnittstellen, die IRQ 12 benutzt:

[.programlisting]
....
hint.sio.4.at="isa"
hint.sio.4.port="0x2a0"
hint.sio.4.flags="0x701"
hint.sio.5.at="isa"
hint.sio.5.port="0x2a8"
hint.sio.5.flags="0x701"
hint.sio.6.at="isa"
hint.sio.6.port="0x2b0"
hint.sio.6.flags="0x701"
hint.sio.7.at="isa"
hint.sio.7.port="0x2b8"
hint.sio.7.flags="0x701"
hint.sio.7.irq="12"
....

Die Flags zeigen an, dass die Master-Schnittstelle die Minor-Nummer `7` (`0x700`) hat und dass sich alle Schnittstellen einen IRQ (`0x001`) teilen.

=== Kann ich die vorgegebenen seriellen Parameter für eine Schnittstelle einstellen?

See the link:{handbook}#serial-hw-config[Serial Communications] section in the FreeBSD Handbook.

=== Wie kann ich Einwahl-Logins über mein Modem aktivieren?

Lesen Sie dazu den Abschnitt über link:{handbook}#dialup/[Einwählverbindungen] im FreeBSD Handbuch.

=== Wie kann ich ein Hardware-Terminal mit meiner FreeBSD Box verbinden?

Diese Information finden Sie im Abschnitt link:{handbook}#term/[Terminals] im FreeBSD Handbuch.

=== Warum kann ich tip oder cu nicht laufen lassen?

Die Programme man:tip[1] und man:cu[1] können auf das Verzeichnis [.filename]#/var/spool/lock# nur über den Benutzer `uucp` und die Gruppe `dialer` zugreifen. Benutzen Sie die Gruppe `dialer` um zu kontrollieren, wer Zugriff auf das Modem oder entfernte Systeme hat. Fügen Sie diese Benutzerkonten einfach selbst zur Gruppe `dialer` hinzu.

Alternativ können Sie jeden Benutzer auf dem System man:tip[1] und man:cu[1] verwenden lassen, dazu müssen Sie folgendes eingeben:

[source,bash]
....
# chmod 4511 /usr/bin/cu
# chmod 4511 /usr/bin/tip
....

== Verschiedene Fragen

=== Wieso benutzt FreeBSD so viel Swap-Speicher, obwohl noch freier Hauptspeicher verfügbar ist?

FreeBSD lagert vorbeugend vollkommen untätige, unbenutzte Seiten aus dem Hauptspeicher in den Swap-Bereich aus, um mehr Hauptspeicher für die aktive Nutzung zur Verfügung zu stellen. Die spürbar höhere Nutzung des Swap-Speichers wird durch die effizientere Nutzung des Hauptspeichers wieder ausgeglichen.

Beachten Sie, dass FreeBSD in dieser Hinsicht zwar vorbeugend arbeitet, es entscheidet jedoch nicht willkürlich, Seiten auszulagern, wenn das System vollkommen untätig ist. Sie können feststellen, dass nicht alle Seiten des Systems ausgelagert wurden, nachdem das System eine Nacht lang nicht benutzt worden ist.

=== Warum zeigt mir top so wenig freien Speicher an, obwohl nur wenige Programme laufen?

Die Antwort ist ganz einfach: Freier Speicher ist verschwendeter Speicher. Der FreeBSD Kernel verwendet den von den Programmen nicht genutzten Speicher automatisch für den Plattencache. Die in man:top[1] für `Inact`, `Cache` und `Buf` gemeldeten Werte stehen alle für zwischengespeicherte Daten mit unterschiedlichem Alter. Wenn das System wiederholt auf Daten zugreifen muss, braucht es nicht auf die langsame Platte zuzugreifen, da die Daten noch zwischengespeichert sind. Dadurch erhöht sich die Performance. Ganz generell ist es ein gutes Zeichen, wenn man:top[1] einen kleinen Wert bei `Free` anzeigt, solange der Wert nicht _extrem_ klein ist.

=== Warum ändert chmod die Zugriffsrechte auf symbolische Links nicht?

Für symbolische Links gibt es keine separaten Zugriffsrechte und standardmäßig folgt man:chmod[1] dem Link, wenn möglich; die Zugriffsrechte für die Datei, auf die der symbolische Link zeigt, werden also verändert. Wenn Sie eine Datei mit dem Namen [.filename]#foo# und einen auf diese Datei zeigenden symbolischen Link mit dem Namen [.filename]#bar# haben, wird das folgende Kommando niemals einen Fehler melden.

[source,bash]
....
% chmod g-w bar
....

Trotzdem werden die Zugriffsrechte für [.filename]#bar# nicht geändert.

Wenn Sie die Zugriffsrechte in der Dateihierarchie an der Wurzeldatei anstatt der Datei selbst ändern möchten, müssen Sie entweder `-H` oder `-L` zusammen mit der Option `-R` benutzen. Lesen Sie man:chmod[1] und man:symlink[7] für weitere Informationen.

[WARNING]
====

Die Option `-R` bewirkt ein _rekursives_man:chmod[1]. Seien Sie vorsichtig, wenn Sie bei man:chmod[1] Verzeichnisse oder symbolische Links zu Verzeichnissen angeben. Wenn Sie die Zugriffsrechte eines Verzeichnisses ändern möchten, das durch einen symbolischen Link referenziert wird, benutzen Sie man:chmod[1] ohne irgendwelche Optionen und folgen dem symbolischen Link durch einen abschließenden Schrägstrich ([.filename]#/#). Wenn bspw. [.filename]#foo# ein symbolischer Link zum Verzeichnis [.filename]#bar# ist und Sie die Zugriffsrechte von [.filename]#foo# (tatsächlich [.filename]#bar#) ändern möchten, dann benutzen Sie etwas ähnliches wie:

[source,bash]
....
% chmod 555 foo/
....

Durch den abschließenden Schrägstrich folgt man:chmod[1] dem symbolischen Link [.filename]#foo#, um die Zugriffsrechte für das Verzeichnis [.filename]#bar# zu ändern.
====

=== Kann ich DOS-Programme unter FreeBSD ausführen?

Ja. Sie können package:emulators/doscmd[] verwenden, das über die FreeBSD Ports-Sammlung verfügbar ist.

Falls doscmd nicht ausreicht, können Sie den Port package:emulators/pcemu[] verwenden, der einen 8088 und genug BIOS-Funktionen emuliert, um DOS-Textanwendungen laufen zu lassen. Der Port benötigt das X Window System.

Die Ports-Sammlung enthält auch package:emulators/dosbox[]. Das Hauptaugenmerk liegt bei dieser Anwendung auf der Emulation alter DOS Spiele, deren Dateien sich im lokalen Dateisystem befinden.

=== Was muss ich tun, um die FreeBSD-Dokumentation in meine Muttersprache zu übersetzen?

Lesen Sie die link:{fdp-primer}#translations/[Translation FAQ] im FreeBSD Documentation Project Primer.

=== Warum kommen alle meine Mails, die ich an FreeBSD.org schicke, wieder zurück?

Das Mailsystem von `FreeBSD.org` verwendet einige der strengeren Überprüfungen von Postfix für eingehende Mails. Mails, bei denen es Anzeichen für Konfigurationsprobleme oder Spam gibt, werden nicht akzeptiert. Es gibt einige spezielle Anforderungen:

* Die IP-Adresse des SMTP-Clients muss symbolisch in einen Hostnamen aufgelöst werden können.
* Der vollqualifizierte Rechnername, der im EHLO/HELO Teil der SMTP Kommunikation übergeben wird, muss zu einer IP-Adresse aufgelöst werden können.

Damit die Mail auch ihr Ziel erreicht, hier ein paar weitere Ratschläge:

* Mail sollte im Klartext gesendet werden. Nachrichten an eine Mailingliste sollten die Größe von 200KB nicht überschreiten.
* Vermeiden Sie übermäßiges Crossposting. Wählen Sie _eine_ für das Problem relevante Mailingliste und senden Sie die Mail dorthin.

Falls Sie immer noch Probleme mit der E-Mail-Infratruktur von `FreeBSD.org` haben, schicken Sie eine Nachricht mit den Details an mailto:postmaster@freebsd.org[postmaster@freebsd.org]. Fügen Sie Datum/Uhrzeit ein, damit die Logdateien überprüft werden können. Beachten Sie jedoch, dass die Mail-Logs nur eine Woche gespeichert werden. Vergewissern Sich sich auch, die Zeitzone oder einen Offset in UTC anzugeben.

=== Wo kann ich einen freien FreeBSD-Account bekommen?

Das FreeBSD Project bietet zwar keinen freien Zugang zu seinen Servern an; andere Firmen bieten jedoch frei zugängliche UNIX(TM) Systeme. Die Kosten variieren und es kann sein, dass nicht alle Dienste zur Verfügung stehen.

http://www.arbornet.org/[Arbornet, Inc], auch als _M-Net_ bekannt, bietet seit 1983 uneingeschränkten Zugang zu UNIX(TM) Systemen. Zunächst wurde eine Altos-Maschine mit System III benutzt, 1991 erfolgte dann der Wechsel zu BSD/OS. Im Juni 2000 erfolgte ein erneuter Wechsel, diesmal zu FreeBSD. _M-Net_ bietet Zugang mit telnet und SSH und den Zugang zur gesamten Software von FreeBSD. Allerdings ist der Zugriff auf das Netzwerk auf Mitglieder und Gönner beschränkt, die eine Spende an die nicht-kommerzielle Organisation geleistet haben. _M-Net_ stellt zusätzlich ein Mailbox-System und einen interaktiven Chat zur Verfügung.

=== Wie heißt das niedliche rote Kerlchen?

Er ist namenlos, es ist einfach "der BSD Daemon". Wenn Sie ihm unbedingt einen Namen geben wollen, nennen Sie ihn "beastie". Beachten Sie aber, dass "beastie" wie "BSD" ausgesprochen wird.

Weitere Informationen über den BSD daemon finden Sie auf seiner http://www.mckusick.com/beastie/index.html[Homepage].

=== Kann ich das Bild des BSD Daemon verwenden?

Eventuell. Der BSD Daemon unterliegt dem Copyright von Marshall Kirk McKusick. Lesen Sie sein http://www.mckusick.com/beastie/mainpage/copyright.html[Statement on the Use of the BSD Daemon Figure], wenn Sie genaue Informationen über die Einschränkungen bei der Nutzung brauchen.

Kurz gesagt, können Sie den BSD Daemon benutzen, solange es für einen privaten Zweck ist und die Nutzung geschmackvoll bleibt. Bevor Sie das Logo kommerziell nutzen, bitten Sie Kirk McKusick mailto:mckusick@FreeBSD.org[mckusick@FreeBSD.org] um Erlaubnis. Weitere Informationen erhalten Sie auf http://www.mckusick.com/beastie/index.html[BSD Daemon's home page]

=== Gibt es Bilder des BSD Daemon, die ich benutzen kann?

Einige Bilder in den Formaten Xfig und eps sind unter [.filename]#/usr/shared/examples/BSD_daemon/# verfügbar.

=== Ich habe in den Mailinglisten eine Abkürzung oder einen Begriff gesehen, den ich nicht kenne. Wo erhalte ich eine Erklärung dazu?

Sehen Sie im link:{handbook}#freebsd-glossary[FreeBSD-Glossar] nach.

=== Warum sollte mich die Farbe des Fahrradschuppens interessieren?

Die ganz, ganz kurze Antwort ist: Überhaupt nicht. Die etwas längere Antwort lautet: Nur weil Sie in der Lage sind, einen Fahrradschuppen zu bauen, müssen Sie noch lange nicht andere davon abhalten, nur weil Ihnen die Farbe nicht gefällt. Dies ist natürlich eine Metapher dafür, dass Sie nicht eine Diskussion über jede kleine Änderung beginnen sollen, nur weil Sie das können. Einige Leute behaupten sogar, dass die Anzahl der (nutzlosen) Kommentare über eine Änderung umgekehrt proportional zur Komplexität der Änderung ist.

Die noch längere und vollständigere Antwort ist, dass Poul-Henning Kamp mailto:phk@FreeBSD.org[phk@FreeBSD.org] nach einen langen Diskussion über das Thema "Soll man:sleep[1] Sekundenbruchteile als Parameter akzeptieren?" eine lange Mail mit dem Titel "link:http://www.bikeshed.com[A bike shed (any color will do) on greener grass...]" schrieb. Die einschlägigen Teile der Nachricht lauteten:

Poul-Henning Kamp mailto:phk@FreeBSD.org[phk@FreeBSD.org] in http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers[freebsd-hackers], 2.10.1999
Einige von Euch haben mich gefragt, "Was meinst Du mit dem Fahrradschuppen?"

Es ist eine lange oder eigentlich eher eine sehr alte und doch sehr kurze Geschichte. C. Northcote Parkinson schrieb in den frühen Sechzigern ein Buch mit dem Namen "Parkinson's Law", das viele Einblick in die Beziehungen innerhalb des Managements gibt.

_[ein paar Kommentare zum Buch gestrichen]_

In dem Beispiel mit dem Fahrradschuppen ist die andere wichtige Komponente ein Kernkraftwerk. Ich glaube, dass zeigt schon, wie alt dieses Buch ist.

Parkinson zeigte, dass man zum Vorstand gehen kann und die Genehmigung für ein mehrere Millionen oder sogar Milliarden Dollar teures Kernkraftwerk bekommt; wenn man aber einen Fahrradschuppen bauen will, wird man in endlose Diskussionen verwickelt.

Laut Parkinson liegt das daran, dass ein Kernkraftwerk so groß, so teuer und so kompliziert ist, dass die Leute es nicht verstehen. Und bevor sie versuchen, es zu verstehen, verlassen Sie sich lieber darauf, dass irgend jemand sicherlich die ganzen Details geprüft hat, bevor das Projekt bis zum Vorstand gekommen ist. Im Buch von Richard P. Feynmann finden sich einige interessante und sehr passende Beispiele aus dem Gebiet von Los Alamos.

Ein Fahrradschuppen ist was anderes. Jeder kann an seinem freien Wochenende einen bauen und hat trotzdem noch genug Zeit für die Sportschau. Daher ist es unwichtig, wie gut man sich vorbereitet und wie sinnvoll der eigene Vorschlag ist. Irgend jemand wird die Möglichkeit nutzen und zeigen, dass er seine Arbeit tut, dass er aufmerksam ist, dass er _da_ ist.

In Dänemark wird dieses Verhalten "Seine Fingerabdrücke hinterlassen" genannt. Es geht um persönlichen Stolz und Prestige; die Chance, auf irgend etwas zu zeigen und zu sagen zu können: "Da! Das habe _Ich_ getan." Politiker leiden sehr stark darunter, aber viele Leute verhalten sich so, wenn sie die Chance haben. Denken Sie einfach mal an Fußabdrücke in feuchtem Zement.

== Nicht ganz ernstgemeinte Fragen

=== Wie cool ist FreeBSD?

[qanda]
Hat irgend jemand Temperaturmessungen durchgeführt, während FreeBSD läuft? Ich weiß, dass Linux(TM) cooler läuft als DOS, habe aber niemals gesehen, dass FreeBSD erwähnt wurde. Es scheint sehr heiß zu laufen.::

Nein, aber wir haben zahlreiche Geschmackstests mit Freiwilligen mit verbundenen Augen durchgeführt, denen außerdem zuvor 250 Mikrogramm LSD-25 verabreicht wurden. 35% der Freiwilligen sagte, dass FreeBSD nach Orange schmeckte, Linux(TM) hingegen schmecke wie Purple Haze. Keine der Gruppen hat besondere Abweichungen der Temperatur erwähnt. Eventuell hätten wir sämtliche Ergebnisse dieser Untersuchung fortwerfen sollen, als wir festgestellt haben, dass zu viele der Freiwilligen den Raum während der Tests verlassen haben und dadurch die Ergebnisse verfälscht haben. Wir glauben, dass die meisten der Freiwilligen nun bei Apple sind und an ihrer neuen "scratch and sniff" Oberfläche arbeiten. Es ist ein lustiges, altes Geschäft, in dem wir uns befinden!

Ernsthaft, FreeBSD benutzt die Instruktion HLT (halt), wenn das System untätig ist, wodurch der Energieverbrauch und dadurch die produzierte Wärme reduziert wird. Falls Sie auch ACPI (Advanced Configuration and Power Interface) konfiguriert haben, kann FreeBSD die CPU auch in einen Low-Power-Modus bringen.

=== Wer kratzt in meinen Speicherbänken??

[qanda]
Gibt es irgend etwas "seltsames", das FreeBSD tut, wenn der Kernel kompiliert wird, das dazu führt, dass der Speicher ein kratzendes Geräusch macht? Bei der Kompilierung (und auch für einen kurzen Moment nach der Erkennung des Floppy-Laufwerks beim Hochfahren), kommt ein seltsames kratzendes Geräusch von etwas, das die Speicherbänke zu sein scheinen.::

Ja! In der BSD-Dokumentation finden Sie häufige Verweise auf "Daemons" und was die meisten Leute nicht wissen, ist, dass diese sich auf echte, nicht-körperlichen Wesen beziehen, die Besitz von Ihrem Computer ergriffen haben. Das kratzende Geräusch, das von Ihrem Speicher kommt, ist in Wirklichkeit hochtöniges Flüstern, das unter den Daemons ausgetauscht wird, während Sie entscheiden, wie Sie die verschiedenen Systemadministrationsaufgaben, am besten erledigen.

Wenn Sie das Geräusch stört, wird ein `fdisk /mbr` aus DOS sie vertreiben, aber wundern Sie sich nicht, wenn sie feindlich reagieren und versuchen, Sie aufzuhalten. Wenn Sie während der Ausführung zu irgendeinem Zeitpunkt die teuflische Stimme von Bill Gates aus dem eingebauten Lautsprecher kommen hören, laufen Sie weg und sehen Sie sich auf keinen Fall um! Befreit von dem ausgleichenden Einfluss der BSD Dämonen sind die beiden Dämonen von DOS und Windows(TM) oft dazu in der Lage, die totale Kontrolle über Ihre Maschine für die ewige Verdammung Ihrer Seele zurückzuerlangen. Da Sie jetzt die Wahrheit kennen, würden Sie es vorziehen, sich an die Geräusche zu gewöhnen, wenn Sie die Wahl hätten.

=== Wie viele FreeBSD-Hacker braucht man, um eine Glühbirne auszuwechseln?

Eintausendeinhundertundneunundsechzig:

Dreiundzwanzig, die sich bei -CURRENT beschweren, dass das Licht aus ist;

Vier, die behaupten, dass es sich um ein Konfigurationsproblem handelt und dass solche Dinge wirklich nach -questions gehören;

Drei, die PRs hierzu einreichen, einer von ihnen wird falsch unter doc abgelegt und fristet sein Dasein im Dunkeln;

Einen, der eine ungetestete Glühbirne einreicht, wonach buildworld nicht mehr funktioniert, und sie dann fünf Minuten später wieder herausnimmt;

Acht, die die PR-Erzeuger beschimpfen, weil sie zu ihren PRs keine Patche hinzugefügt haben;

Fünf, die sich darüber beschweren, dass buildworld nicht mehr funktioniert;

Einunddreißig, die antworten, dass es bei ihnen funktioniert und dass sie die Aktualisierung wohl zu einigem ungünstigen Zeitpunkt durchgeführt haben;

Einen, der einen Patch für eine neue Glühbirne an -hackers schickt;

Einen, der sich beschwert, dass es vor drei Jahren Patches hierfür hatte, aber als er sie nach -CURRENT schickte, sind sie einfach ignoriert worden und er hatte schlechte Erfahrungen mit dem PR-System; nebenbei ist die vorgeschlagene Glühbirne nicht reflexiv;

Siebenunddreißig, die schreien, dass Glühbirnen nicht in das Basissystem gehören, dass Committer nicht das Recht haben, solche Dinge durchzuführen, ohne die Gemeinschaft zu konsultieren und WAS GEDENKT -CORE HIER ZU TUN!?

Zweihundert, die sich über die Farbe des Fahrradschuppens beschweren;

Drei, die darauf hinweisen, dass der Patch nicht mit man:style[9] übereinstimmt;

Siebzehn, die sich beschweren, dass die vorgeschlagene neue Glühbirne der GPL unterliegt;

Fünfhundertundsechsundachtzig, die sich in einen Streit über die vergleichbaren Vorteile der GPL, der BSD-Lizenz, der MIT-Lizenz, der NPL und der persönlichen Hygiene nichtgenannter FSF-Gründer verwickeln;

Sieben, die unterschiedliche Teile des Threads nach -chat und -advocacy weiterleiten;

Einer, der die vorgeschlagene Glühbirne einbaut, obwohl sie dunkler leuchtet, als die alte;

Zwei, die sie wieder ausbauen, und in einer wütenden Nachricht argumentieren, dass FreeBSD besser ganz im Dunkeln dasteht, als mit einer dämmerigen Glühbirne;

Sechsundvierzig, die sich lärmend wegen des Wiederausbaus der dämmerigen Glühbirne streiten und eine Erklärung von -core verlangen;

Elf, die eine kleinere Glühbirne beantragen, damit sie in ihr Tamagotchi passt, falls wir irgendwann beschließen, FreeBSD auf diese Plattform zu portieren;

Dreiundsiebzig, die sich über die SNR auf -hackers und -chat beschweren und aus Protest abmelden;

Dreizehn, die "unsubscribe", "How do I unsubscribe?" oder "Please remove me from the list" gefolgt von der üblichen Fußzeile abschicken;

Einen, der eine funktionierende Glühbirne einbaut, während alle zu beschäftigt damit sind, mit jedem zu streiten, um es zu bemerken;

Einunddreißig, die herausstellen, dass die neue Glühbirne 0,364% heller leuchten würde, wenn sie mit TenDRA kompiliert werden würde (obwohl sie in einen Würfel umgeformt werden müsste) und dass FreeBSD deshalb nach TenDRA, anstatt nach GCC wechseln sollte;

Einen, der sich beschwert, dass bei der neuen Glühbirne die Verkleidung fehlt;

Neun (einschließlich der PR-Ersteller), die fragen "Was ist MFC?";

Siebenundfünfzig, die sich zwei Wochen, nachdem die Birne gewechselt worden ist, darüber beschweren, dass das Licht aus war.

_Nik Clayton_ mailto:nik@FreeBSD.org[nik@FreeBSD.org] hat hinzugefügt:

_Ich habe ziemlich hierüber gelacht._

_Und dann dachte ich: "Halt, sollte in dieser Liste nicht irgendwo 'Einer, der es dokumentiert' sein?"_

_Und dann wurde ich erleuchtet :-)_

_Thomas Abthorpe_ mailto:tabthorpe@FreeBSD.org[tabthorpe@FreeBSD.org] sagt: "Keine, _echte_ FreeBSD Hacker fürchten sich nicht vor der Dunkelheit!"

=== Was passiert mit den Daten, die nach /dev/null geschrieben werden?

Sie werden in einer speziellen Datensenke der CPU in Wärme umgewandelt, die dann über den Kühlkörper und den Lüfter abgeführt wird. Dies ist einer der Gründe für die Kühlung von CPUs; die Anwender gewöhnen sich an die schnelleren Prozessoren, gehen nicht mehr so sorgfältig mit Ihren Daten um und so landen immer mehr Daten in [.filename]#/dev/null#, was zur Überhitzung der CPU führt. Wenn Sie [.filename]#/dev/null# löschen (was die Datensenke ziemlich sicher abschaltet), wird Ihre CPU zwar nicht mehr so heiß, dafür wird Ihr System aber sehr schnell von den überzähligen Daten überladen und merkwürdige Effekte zeigen. Wenn Sie eine sehr schnell Netzwerkverbindung haben, können Sie Ihre CPU kühlen, indem sie Daten aus [.filename]#/dev/random# lesen und in die Weite des Netzwerkes schicken; allerdings besteht hier die Gefahr der Überhitzung von Netzwerk und [.filename]#/#. Außerdem dürfte Ihr ISP ziemlich wütend werden, da der größte Teil der Daten von seinen Geräten in Hitze umgewandelt werden wird; da ISPs aber über Klimaanlagen verfügen, sollte das kein großes Problem sein, solange Sie es nicht übertreiben.

_Paul Robinson fügt hinzu:_

Es gibt andere Mittel und Wege. Wie jeder gute Systemadministrator weiss, gehört es zum guten Ton, einigen Daten zum Bildschirm zu senden, damit die Leuchtkäferchen, die das Bild anzeigen, glücklich sind. Die Leuchtkäferchen werden nach der Farbe Ihrer Hüte (Rot, Grün, oder Blau) unterschieden und sie verstecken bzw. zeigen sich (wobei man die Farbe ihrer Hüte erkennen kann) bei jeder Nahrungsaufnahme. Grafikkarten wandeln Daten in Leuchkäfer-Nahrung um und schicken sie dann zu den Leuchtkäfern - teure Karten erzeugen bessere Nahrung und sorgen so für besseres Verhalten der Leuchtkäfer. Diese brauchen allerdings einen konstanten Stimulus - darum gibt es Bildschirmschoner.

Darum lautet mein Vorschlag, die zufälligen Daten einfach zum Bildschirm zu schicken, damit sie von den Leuchtkäfern verzehrt werden. Dabei entsteht keine Hitze, die Leuchtkäfer bleiben glücklich und man wird seine überflüssigen Daten sehr schnell los, auch wenn der Bildschirm etwas merkwürdig aussieht.

Übrigens: Als Ex-Admin eines großen ISPs, der so seine Probleme mit der Kühlung seines Rechenzentrums hatte, kann ich nur davon abraten, überflüssige Daten einfach in das Netzwerk zu schicken. Die Heinzelmännchen, die die Pakete verteilen und versenden, regen sich darüber ganz furchtbar auf.

=== Mein Kollege hängt zu viel vor dem Rechner, wie kann ich ihm einen Streich spielen?

Installieren Sie auf dem Rechner Ihres Kollegen package:games/sl[] und warten Sie, bis Ihr Kollege unbeabsichtigt `sl` für `ls` eingibt.

== Weiterführende Themen

=== Wie kann ich mehr über die Interna von FreeBSD erfahren?

Lesen Sie das link:{arch-handbook}[FreeBSD Architecture Handbook].

Allgemeines Wissen über UNIX(TM) kann allerdings in den meisten Fällen auf FreeBSD angewendet werden.

=== Wie kann ich bei der Entwicklung von FreeBSD mithelfen?

Genauere Informationen finden Sie im Artikel link:{contributing}[FreeBSD unterstützen]. Wir können Hilfe immer gut gebrauchen!

=== Was sind Snapshots und Releases?

Derzeit existieren drei aktive/halbaktive Zweige im FreeBSD http://svnweb.FreeBSD.org/base/[Subversion Repository]. In früheren Zweigen ändert sich wenig, daher gibt es nur drei aktive Entwicklungszweige:

* stable/9/ bzw. _9-STABLE_
* stable/10/ bzw. _10-STABLE_
* head/ bzw. _-CURRENT_ oder auch _11-CURRENT_

`HEAD` ist keine wirkliche Bezeichnung für einen Zweig. Es ist lediglich eine symbolische Konstante für den aktuellen, nicht verzweigten Entwicklungsstrom, auf den wir uns einfach als _-CURRENT_ beziehen.

Derzeit steht _-CURRENT_ für den 11._X_-Entwicklungsstrom. Der _10-STABLE_-Zweig (stable/10) wurde von _-CURRENT_ im Januar 2014 und der _9-STABLE_-Zweig (stable/9) im September 2011 von _-CURRENT_ abgespalten.

=== Ich habe eine Kernelerweiterung geschrieben. An wen sende ich sie?

Lesen Sie den Artikel link:{contributing}[FreeBSD unterstützen].

Und Danke, dass Sie darüber nachdenken!

=== Wie kann ich optimalen Nutzen aus einer kernel panic ziehen?

Hier ist eine typische Kernel-Panic:

[.programlisting]
....
Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault
....

Bei Meldungen wie dieser, reicht es nicht, sie einfach zu reproduzieren und sie einzusenden. Der Wert des Instruktionszeigers ist wichtig; leider ist er auch konfigurationsabhängig. Mit anderen Worten variieren die Werte abhängig von dem Kernel-Image, das Sie tatsächlich benutzen. Wenn Sie ein [.filename]#GENERIC# Kernelimage von einem der Snapshots benutzen, dann ist es für jemand anderen möglich, die fehlerhafte Instruktion herauszufinden, aber wenn Sie einen angepassten Kernel benutzen, können nur _Sie_ uns sagen, wo der Fehler auftrat.

Was Sie tun sollten, ist folgendes:

[.procedure]
====
. Notieren Sie sich den Wert des Instruktionszeigers. Beachten Sie, dass der Teil `0x8:` am Anfang in diesem Fall nicht von Bedeutung ist; der Teil `0xf0xxxxxx` ist der, den wir wollen.
. Tun Sie folgendes, wenn das System rebootet:
+
[source,bash]
....
% nm -n kernel.that.caused.the.panic | grep f0xxxxxx
....
+ 
wobei `0xf0xxxxxx` der Wert des Instruktionszeigers ist. Es besteht die Möglichkeit, dass Sie keinen exakten Treffer erzielen, weil die Symbole in der Symboltabelle des Kernels Funktionseinstiegspunkte sind und die Adresse des Instruktionszeigers irgendwo innerhalb einer Funktion liegen wird und nicht am Anfang. Falls sie keinen exakten Treffer erzielen, lassen Sie den letzten Teil des Werts des Instruktionszeigers weg und versuchen es noch einmal, z.B.:
+
[source,bash]
....
% nm -n kernel.that.caused.the.panic | grep f0xxxxx
....
+ 
Falls das kein Ergebnis liefert, hacken Sie eine weitere Ziffer ab. Wiederholen Sie die Schritte, bis Sie irgendeine Ausgabe erhalten. Das Ergebnis wird eine Liste möglicher Funktionen sein, die die Panik verursacht haben. Das ist zwar kein absolut genauer Mechanismus, um die Fehlerursache ausfindig zu machen, aber es ist besser als gar nichts.
====

Wie dem auch sei, der beste Weg, den Grund für eine Panik herauszufinden, ist der, einen Crash-Dump festzuhalten und dann man:kgdb[1] zu benutzen, um den Stack im Crash-Dump zurückzuverfolgen.

Jedenfalls funktioniert die Methode wie folgt:

[.procedure]
====
. Sorgen Sie dafür, dass die folgende Zeile in der Kernelkonfigurationsdatei enthalten ist:
+
[.programlisting]
....
makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols
....
+
. Wechseln Sie in das Verzeichnis [.filename]#/usr/src#:
+
[source,bash]
....
# cd /usr/src
....
+
. Erstellen Sie den Kernel:
+
[source,bash]
....
# make buildkernel KERNCONF=MYKERNEL
....
+
. Warten Sie, bis man:make[1] den Kernel fertig kompiliert hat.
+
[source,bash]
....
# make installkernel KERNCONF=MYKERNEL
....
+
. Starten Sie das System neu.
====

[NOTE]
====
Falls Sie `KERNCONF` nicht verwenden, wird ein [.filename]#GENERIC# Kernel gebaut und installiert.
====

Der man:make[1]-Prozess wird zwei Kernel erstellen: [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel# und [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel.debug#. [.filename]#kernel# wurde als [.filename]#/boot/kernel# installiert, während [.filename]#kernel.debug# als Quelle für Debuggersymbole für man:kgdb[1] benutzt werden kann.

Damit ein Crash-Dump erhalten bleibt, müssen Sie [.filename]#/etc/rc.config# editieren und `dumpdev` so setzen, dass es entweder auf die Swap-Partition, oder auf `AUTO` zeigt. Das bewirkt, dass die man:rc[8]-Skripte den Befehl man:dumpon[8] benutzen, um Crash-Dumps zu ermöglichen. Sie können den Befehl auch manuell ausführen. Nach einer Panik kann der Crash-Dump mit man:savecore[8] wiederhergestellt werden; wenn `dumpdev` in [.filename]#/etc/rc.conf# gesetzt ist, werden die man:rc[8]-Skripte man:savecore[8] automatisch ausführen und den Crash-Dump unter [.filename]#/var/crash# ablegen.

[NOTE]
====
FreeBSD Crash-Dumps sind für gewöhnlich genauso groß wie der physikalische Hauptspeicher des Rechners. Deshalb müssen Sie dafür sorgen, dass genügend Speicherplatz in [.filename]#/var/crash# zur Verfügung steht, um den Dump aufnehmen zu können. Alternativ führen Sie man:savecore[8] manuell aus und lassen es den Crash-Dump in einem anderen Verzeichnis mit mehr Platz wiederherstellen Es ist möglich, die Größe des Crash-Dumps zu begrenzen, indem `options MAXMEM=N`, wobei _N_ die Größe des verwendeten Kernelspeichers in KBs ist. Wenn Sie z.B. 1 GB RAM haben, können Sie die Speicherbenutzung des Kernels damit auf 128 MB begrenzen, so dass die Größe des Crash-Dumps 128 MB anstatt 1 GB betragen wird.
====

Sobald der Crash-Dump wiederhergestellt wurde, können Sie den Stack zurückverfolgen:

[source,bash]
....
% kgdb /usr/obj/usr/src/sys/MYKERNEL/kernel.debug /var/crash/vmcore.0
(kgdb) backtrace
....

Beachten Sie, dass es mehrere Seiten mit wertvollen Informationen geben könnte; idealerweise sollten Sie man:script[1] benutzen, um sie alle festzuhalten. Wenn Sie das vollständige Kernelimage mit allen Debugginginformationen benutzen, müssten Sie exakt die Zeile des Kernel-Quellcodes finden, wo die Panik aufgetreten ist. Für gewöhnlich müssen Sie den Stack von unten an zurückverfolgen, um die genaue Ereignisabfolge, die zum Crash führte, zurückzuverfolgen. Sie können man:kgdb[1] auch zum Ausdrucken der Inhalte verschiedener Variablen oder Strukturen benutzen, um den Systemstatus zum Zeitpunkt des Absturzes zu untersuchen.

[TIP]
====

Wenn Sie einen zweiten Rechner haben, können Sie man:kgdb[1] auch für entferntes Debugging konfigurieren, einschließlich dem Setzen von Haltepunkten und dem Bewegen in Einzelschritten durch den Kernelcode.
====

[NOTE]
====
Wenn Sie `DDB` aktiviert haben und der Kernel im Debugger landet, können Sie eine Panik und einen Crash-Dump erzwingen, indem Sie einfach `panic` am `ddb`-Prompt eingeben. Er könnte während der Panikphase wieder im Debugger stoppen. Falls er das tut, geben Sie `continue` ein, dann wird er den Crash-Dump beenden.
====

=== Wieso funktioniert dlsym() nicht mehr für ELF-Executables?

Die ELF-Werkzeuge machen die in einem Executable definierten Symbole dem dynamischen Linker nicht standardmäßig sichtbar. Konsequenterweise werden `dlsym()`-Suchen nach Handlern aus Aufrufen von `dlopen(NULL, flags)` diese Symbole nicht finden können.

Wenn Sie mit `dlsym()` nach im Hauptexecutable eines Prozesses vorhandenen Symbolen suchen wollen, müssen Sie das Executable mit der Option `--export-dynamic` von man:ld[1] linken.

=== Wie kann ich den Adressraum des Kernels auf i386 vergrössern oder verkleinern?

Standardmäßig beträgt der Adressraum des Kernels 1 GB (2 GB für PAE) auf i386. Wenn Sie einen netzwerkintensiven Server oder ZFS verwenden möchten, kann es sein, dass dies nicht ausreichend ist.

Fügen Sie die folgende Zeile zur Kernelkonfigurationsdatei hinzu, um den verfügbaren Speicher zu erhöhen und erstellen Sie dann einen neuen Kernel:

[.programlisting]
....
options KVA_PAGES=N
....

Um den richtigen Wert von _N_ zu bestimmen, teilen Sie den gewünschte Größe des Adressraumes (in Megabyte) durch vier (z.B. beträgt er `512` für 2 GB).

== Danksagung

Dieses kleine unschuldige Dokument mit Häufig gestellten Fragen wurde die letzten Jahrzehnte von Hunderten, wenn nicht Tausenden, geschrieben, neu geschrieben, überarbeitet, gefaltet, verdreht, durcheinander gebracht, wieder aufgebaut, verstümmelt, seziert, durchgekaut, überdacht, und wiederbelebt. Und das nicht nur einmal.

Wir möchten allen dafür Verantwortlichen danken und wir fordern auch Sie auf, link:{contributing}[dieser Gruppe beizutreten], um diese FAQ noch besser zu machen.

[bibliography]
[[bibliography]]
== Bibliographie

[biblio-unleashed] FreeBSD Unleashed. Michael Urban und Brian Tiemann. Sams. Erste Ausgabe. 992 Seiten. Oktober 2001. ISBN 0-67232-206-4.

[biblio-44sysman] 4.4BSD System Manager's Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 804 Seiten. ISBN 1-56592-080-5.

[biblio-44userman] 4.4BSD User's Reference Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 905 Seiten. ISBN 1-56592-075-9.

[biblio-44suppman] 4.4BSD User's Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 712 Seiten. ISBN 1-56592-076-7.

[biblio-44progman] 4.4BSD Programmer's Reference Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 866 Seiten. ISBN 1-56592-078-3.

[biblio-44progsupp] 4.4BSD Programmer's Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 596 Seiten. ISBN 1-56592-079-1.

[biblio-44kernel] The Design and Implementation of the 4.4BSD Operating System. M. K. McKusick, Kirk Marshall, Keith Bostic, Michael J Karels und John Quarterman. Addison-Wesley. Reading MA . 1996. ISBN 0-201-54979-4.

[biblio-freebsdkernel] The Design and Implementation of the FreeBSD Operating System. M. K. McKusick und George V. Neville-Neil. Addison-Wesley. Boston MA . 2004. ISBN 0-201-70245-2.

[biblio-nemeth3rd] Unix System Administration Handbook. Evi Nemeth, Garth Snyder, Scott Seebass, Trent R. Hein und John Quarterman. Prentice-Hall. Dritte Ausgabe. 2000. ISBN 0-13-020601-6.

[lehey3rd] The Complete FreeBSD. Greg Lehey. Walnut Creek. Dritte Ausgabe. Juni 1999. 773 Seiten. ISBN 1-57176-246-9.

[McKusick et al, 1994] Berkeley Software Architecture Manual, 4.4BSD Edition. M. K. McKusick, M. J. Karels, S. J. Leffler, W. N. Joy und R. S. Faber. 5:1-42.

[biblio-ja-fbsdpc98] FreeBSD for PC 98'ers (in Japanisch). SHUWA System Co, LTD.. ISBN 4-87966-468-5 C3055 P2900E.

[biblio-ja-fbsd] FreeBSD (in Japanisch). CUTT. ISBN 4-906391-22-2.

[biblio-ja-compintro] Complete Introduction to FreeBSD (in Japanisch). Shoeisha Co., Ltd. ISBN 4-88135-473-6 P3600E.

[biblio-ja-unixstarterkit] Personal UNIX Starter Kit FreeBSD (in Japanisch). ASCII. ISBN 4-7561-1733-3 P3000E.

[biblio-ja-fbsdhb] FreeBSD Handbook (Japanische Übersetzung). ASCII. ISBN 4-7561-1580-2 P3800E.

[biblio-ge-fbsdmitmeth] FreeBSD mit Methode (in Deutsch). Computer und Literature Verlag/Vertrieb Hanser. 1998. ISBN 3-932311-31-0.

[biblio-ja-fbsdinstandutil] FreeBSD install and Utilization Manual (in Japanisch). Mainichi Communications Inc..

[biblio-indo-intserv] Building Internet Server with FreeBSD (in Indonesisch). Elex Media Komputindo. Onno W Purbo, Dodi Maryanto, Syahrial Hubbany und Widjil Widodo.

[biblio-fbsdcorpnetguide] The FreeBSD Corporate Networker's Guide. Addison-Wesley.

[biblio-unixnutshell] UNIX in a Nutshell. O'Reilly & Associates, Inc.. 1990. ISBN 093717520X.

[biblio-cantfindadmin] What You Need To Know When You Can't Find Your Unix System Administrator. O'Reilly & Associates, Inc.. 1995. Linda Mui. ISBN 1-56592-104-6.

[biblio-ja-fbsdusrrefman] FreeBSD User's Reference Manual (Japanische Übersetzung). Mainichi Communications Inc.. Jpman Project, Japan FreeBSD Users Group. 1998. ISBN 4-8399-0088-4 P3800E.

[biblio-newcomeunix] http://unixhelp.ed.ac.uk/[Online Guide for newcomers to the UNIX environment]“. http://www.ed.ac.uk/[Edinburgh University].

[biblio-dnsandbind] DNS and BIND. O'Reilly & Associates, Inc. ISBN 1-56592-512-2. Paul Albitz Albitz und Cricket Liu. 1998. Dritte Ausgabe.

[biblio-sendmail] Sendmail. O'Reilly & Associates, Inc. 1997. Zweite Auflage. Brian Costales. ISBN 1-56592-222-0.

[biblio-esssysadmin] Essential System Administration. Æleen Frisch. Zweite Auflage. O'Reilly & Associates. 1995. ISBN 1-56592-127-5.

[biblio-tcpipnetworkadministration] TCP/IP Network Administration. Craig Hunt. Zweite Auflage. O'Reilly & Associates, Inc. 1997. ISBN 1-56592-322-7.

[biblio-managingnfsandnis] Managing NFS and NIS. Hal Stern. O'Reilly & Associates, Inc. 1991. ISBN 0-937175-75-7.

[biblio-jpmanprojectjfug] http://www.pc.mycom.co.jp/FreeBSD/sam.html[FreeBSD System Administration's Manual]. http://www.jp.freebsd.org/[Jpman Project, Japan FreeBSD Users Group]. http://www.pc.mycom.co.jp/[Mainichi Communications Inc.]. 1998. ISBN 4-8399-0109-0 P3300E.

[biblio-xwinsystoolkit] X Window System Toolkit. Digital Press. Paul Asente. ISBN 1-55558-051-3.

[biblio-carefman] C: A Reference Manual. Prentice Hall. 1995. Vierte Auflage. Samuel P. Harbison und Guy L. Jr. Steele. ISBN 0-13-326224-3.

[biblio-thecproglang] The C Programming Language. Prentice Hall. 1998. Brian Kernighan und Dennis Ritchie. ISBN 0-13-110362-9.

[biblio-portingunixsoft] Porting UNIX Software. Greg Lehey. O'Reilly & Associates, Inc.. 1995. ISBN 1-56592-126-7.

[biblio-thestandardclibrary] The Standard C Library. Prentice Hall. 1992. P. J. Plauger. ISBN 0-13-131509-9.

[biblio-advprogintheunixenv] Advanced Programming in the UNIX Environment. Addison-Wesley. 1992. W. Richard Stevens. ISBN 0-201-56317-7.

[biblio-unixnetprog] UNIX Network Programming. W. Richard Stevens. Prentice Hall. 1998. Zweite Auflage. ISBN 0-13-490012-X.

[biblio-writeserialdriverforunix] Writing Serial Drivers for UNIX. Bill Wells. Dezember 1994. Dr. Dobb's Journal. pp68-71, pp97-99.

[biblio-unixsysarch] UNIX System Architecture. Prentice-Hall, Inc. 1990. Prabhat K. Andleigh. ISBN 0-13-949843-5.

[biblio-portingunixtothe386] Porting UNIX to the 386. William Jolitz. Dr. Dobb's Journal. Januar 1991 - Juli 1992.

[biblio-tcpipillv1theprotocols] TCP/IP Illustrated, Volume 1: The Protocols. W. Richard Stevens. Addison-Wesley. 1996. ISBN 0-201-63346-9.

[biblio-unixsysformodrnarch] Unix Systems for Modern Architectures. Addison-Wesley. Curt Schimmel. 1994. ISBN 0-201-63338-8.

[biblio-tcpipillvol3] TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols. Addison-Wesley. 1996. W. Richard Stevens. ISBN 0-201-63495-3.

[biblio-unixinternthenewfrontiers] UNIX Internals -- The New Frontiers. Uresh Vahalia. Prentice Hall. 1996. ISBN 0-13-101908-2.

[biblio-tcpipillvol2theimplementation] TCP/IP Illustrated, Volume 2: The Implementation. Gary R. Wright und W. Richard Stevens. 1995. Addison-Wesley. ISBN 0-201-63354-X.

[biblio-firewallsandinternetsecurity] Firewalls and Internet Security: Repelling the Wily Hacker. William R. CHeswick und Steven M. Bellovin. Addison-Wesley. 1995. ISBN 0-201-63357-4.

[biblio-practicalunixsecurity] Practical UNIX Security. Simson Garfinkel und Gene Spafford. 1996. Zweite Auflage. O'Reilly & Associates, Inc. ISBN 1-56592-148-8.

[biblio-pgpprettygoodprivacy] PGP Pretty Good Privacy. Simson Garfinkel. O'Reilly & Associates, Inc. 1995. ISBN 1-56592-098-8.

[biblio-pentiumprocarch] Pentium Processor System Architecture. Don Anderson und Tom Shanley. Addison-Wesley. 1995. Zweite Auflage. ISBN 0-201-40992-5.

[biblio-progguidetothesvgacards] Programmer's Guide to the EGA, VGA, and Super VGA Cards. Richard F. Ferraro. Dritte Ausgabe. Addison-Wesley. 1995. ISBN 0-201-62490-7.

[biblio-80486] 80486 System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40994-1.

[biblio-isasysarch] ISA System Architecture. Tom Shanley. Addison-Wesley. Dritte Ausgabe. 1995. ISBN 0-201-40996-8.

[biblio-pcisysarch] PCI System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40993-3.

[biblio-theundocumentedpc] The Undocumented PC. Frank Van Gilluwe. Addison-Wesley. 1994. ISBN 0-201-62277-7.

[biblio-bellsystemtechnicaljournal] Bell System Technical Journal, Unix Time-Sharing System. American Telephone & Telegraph Company. Juli - August 1978. Vol 57, No 6, Part 2. ISSN0005-8580.

[biblio-commentaryonunix] Lion's Commentary on UNIX. John Lion. ITP Media Group. 1996. Sechste Ausgabe. ISBN 1573980137.

[biblio-newhackerdict] The New Hacker's Dictionary. Eric S. Raymond. MIT Press. 1996. Dritte Ausgabe. ISBN 0-262-68092-0.

[biblio-aqtrcentofunix] A quarter century of UNIX. Peter H. Salus. Addison-Wesley. 1994. ISBN 0-201-54777-5.

[biblio-unixhatershandbook] The UNIX-HATERS Handbook. Steven Strassman, Daniel Weise und Simon Garfinkel. IDG Books Worldwide, Inc. 1994. ISBN 1-56884-203-1.

[biblio-lifewithunix] Life with UNIX - special edition. Don Libes und Sandy Ressler. Prentice-Hall. 1989. ISBN 0-13-536657-7.

[biblio-bsdfamilytree] https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co[The BSD Family Tree]. 1997.

[absolutebsd] Absolute BSD. Michael Lucas. No Starch Press. Juni 2002. ISBN 1-886411-74-3.

[biblio-ccppusersjournal] The C/C++ Users Journal. R&D Publications Inc.. ISSN 1075-2838.

[biblio-sysadminthejournalforunixsysadmins] Sys Admin - The Journal for UNIX System Administrators. Miller Freeman, Inc. ISSN 1061-2688. 
