---
title: Kapitel 17. Speichermedien
part: Teil III. Systemadministration
prev: books/handbook/audit
next: books/handbook/geom
showBookMenu: true
weight: 21
path: "/books/handbook/disks/"
---

[[disks]]
= Speichermedien
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 17
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/disks/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[disks-synopsis]]
== Übersicht

Dieses Kapitel behandelt die Benutzung von Laufwerken unter FreeBSD. Hierzu zählen SCSI- und IDE-Geräte, CD- und DVD-Medien, speicherbasierte Laufwerke und USB-Geräte.

Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes wissen:

* Wie Sie zusätzliche Laufwerke zu einem FreeBSD-System hinzufügen.
* Wie Sie unter FreeBSD die Partition einer Festplatte vergrößern.
* Wie Sie FreeBSD zur Verwendung von USB-Speichermedien konfigurieren.
* Wie Sie CD- und DVD-Medien unter FreeBSD benutzen.
* Wie Sie die unter FreeBSD erhältlichen Backup-Programme benutzen.
* Wie Sie RAM-Disks einrichten.
* Was Dateisystem-Schnappschüsse sind und wie sie effizient eingesetzt werden.
* Wie Sie mit Quotas die Benutzung von Laufwerken einschränken.
* Wie Sie Festplatten und Swap verschlüsseln, um Daten vor Angreifern zu schützen.
* Wie Sie ein hochverfügbares Speichernetzwerk konfigurieren.

Bevor Sie dieses Kapitel lesen,

* sollten Sie wissen, wie Sie einen crossref:kernelconfig[kernelconfig,neuen FreeBSD-Kernel konfigurieren und installieren].

[[disks-adding]]
== Hinzufügen von Laufwerken

Dieser Abschnitt beschreibt, wie Sie ein neues SATA-Laufwerk zu einer Maschine hinzufügen, die momentan nur ein Laufwerk hat. Dazu schalten Sie zuerst den Rechner aus und installieren das Laufwerk entsprechend der Anleitungen Ihres Rechners, Ihres Controllers und des Laufwerkherstellers. Starten Sie das System neu und melden Sie sich als Benutzer `root` an.

Kontrollieren Sie [.filename]#/var/run/dmesg.boot#, um sicherzustellen, dass das neue Laufwerk gefunden wurde. In diesem Beispiel erscheint das neu hinzugefügte SATA-Laufwerk als [.filename]#ada1#.

In diesem Beispiel wird eine einzige große Partition auf der Festplatte erstellt. Verwendet wird das https://de.wikipedia.org/wiki/GUID_Partition_Table[ GPT]-Partitionsschema, welches gegenüber dem älteren und weniger vielseitigen MBR-Schema bevorzug wird.

[NOTE]
====
Wenn die hinzugefügte Festplatte nicht leer ist, können alte Partitionsinformationen mit `gpart delete` entfernt werden. Details finden Sie in man:gpart[8].
====

Zuerst wird das Partitionsschema erstellt und dann eine einzelne Partition angefügt. Zur Verbesserung der Leistung auf neueren Festplatten mit größeren Blockgrößen, wird die Partition an einer Megabyte-Grenze ausgerichtet:

[source,shell]
....
# gpart create -s GPT ada1
# gpart add -t freebsd-ufs -a 1M ada1
....

Je nach Anwendung kann es wünschenswert sein, mehrere kleinere Partitionen zu haben. In man:gpart[8] finden Sie Optionen zum Erstellen von kleineren Partitionen.

Informationen über die Partitionen der Festplatte werden mit `gpart show` angezeigt:

[source,shell]
....
% gpart show ada1
=>        34  1465146988  ada1  GPT  (699G)
          34        2014        - free -  (1.0M)
        2048  1465143296     1  freebsd-ufs  (699G)
  1465145344        1678        - free -  (839K)
....

Ein Dateisystem wird in der neuen Partition erstellt:

[source,shell]
....
# newfs -U /dev/ada1p1
....

Ein leeres Verzeichnis wird als Mountpunkt erstellt, also ein Speicherort für die Montage der neuen Festplatte im originalen Dateisystem:

[source,shell]
....
# mkdir /newdisk
....

Abschließend wird ein Eintrag in [.filename]#/etc/fstab# hinzugefügt, damit die neue Festplatte automatisch beim Start eingehängt wird:

[.programlisting]
....
/dev/ada1p1	/newdisk      ufs   rw	    2	  2
....

Die neue Festplatte kann manuell montiert werden, ohne das System neu zu starten:

[source,shell]
....
# mount /newdisk
....

[[disks-growing]]
== Partitionen vergrößern

Die Kapazität einer Festplatte kann sich ohne Änderungen an bereits vorhandenen Daten erhöhen. Dies geschieht üblicherweise mit virtuellen Maschinen, wenn sich herausstellt, dass die virtuelle Festplatte zu klein ist und vergrößert werden soll. Zuweilen wird auch ein Abbild einer Platte auf einen USB-Stick geschrieben, ohne dabei die volle Kapazität zu nutzen. Dieser Abschnitt beschreibt, wie man Platten vergrößert, bzw. _erweitert_, um die Vorteile der erhöhten Kapazität zu nutzen.

Überprüfen Sie [.filename]#/var/run/dmesg.boot#, um den Gerätenamen der Festplatte zu bestimmen, die vergrößert werden soll. In diesem Beispiel gibt es nur eine SATA-Festplatte im System, so dass die Platte als [.filename]#ada0# angezeigt wird.

Um die aktuelle Konfiguration der Partitionen auf der Festplatte anzuzeigen:

[source,shell]
....
# gpart show ada0
=>      34  83886013  ada0  GPT  (48G) [CORRUPT]
        34       128     1  freebsd-boot  (64k)
       162  79691648     2  freebsd-ufs  (38G)
  79691810   4194236     3  freebsd-swap  (2G)
  83886046         1        - free -  (512B)
....

[NOTE]
====
Wenn die Festplatte mit dem http://en.wikipedia.org/wiki/GUID_Partition_Table[ GPT]-Partitionsschema formatiert wurde kann es vorkommen, dass sie als "corrupted" angezeigt wird, weil sich die Sicherung der GPT-Partitionstabellen nicht mehr am Ende des Laufwerks befinden. Reparieren Sie in so einem Fall die Partitionstabelle mit `gpart`:

[source,shell]
....
# gpart recover ada0
ada0 recovered
....

====

Nun steht der zusätzliche Speicherplatz zur Verfügung und kann verwendet werden, um eine neue Partition anzulegen oder eine bestehende Partition zu erweitern:

[source,shell]
....
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
   79691810    4194236     3  freebsd-swap  (2G)
   83886046   18513921        - free -  (8.8G)
....

Partitionen können nur auf zusammenhängenden, freien Speicherplatz vergrößert werden. In diesem Beispiel wird die letzte Partition der Platte als Swap-Speicher genutzt, aber die zweite Partition ist die, dessen Größe verändert werden soll. Weil der Swap-Speicher nur temporäre Daten enthält, kann er gefahrlos ausgehangen, gelöscht und nachdem die zweite Partition vergrößert wurde, als dritte Partition neu erstellt werden.

Deaktivieren Sie Swap-Speicher Partition:

[source,shell]
....
# swapoff /dev/ada0p3
....

Löschen Sie die dritte Partition, angegeben mit dem Schalter `-i`, der Festplatte _ada0_:

[source,shell]
....
# gpart delete -i 3 ada0
ada0p3 deleted
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
	79691810   22708157        - free -  (10G)
....

[WARNING]
====

Es besteht die Gefahr von Datenverlust, wenn die Partitionstabelle eines eingehangenen Dateisystems verändert wird. Es empfiehlt sich daher, die folgenden Schritte auf einem ausgehangenen Dateisystem durchzuführen, während die Umsetzung über eine Live-CD-ROM oder von einem USB-Gerät erfolgt. Wenn es jedoch absolut notwendig ist, kann ein eingehangenes Dateisystem auch vergrößert werden, nachdem die Sicherheitsfunktionen von GEOM deaktiviert wurden:

[source,shell]
....
# sysctl kern.geom.debugflags=16
....

====

Vergrößern Sie die Partition und lassen Sie Platz, um die Swap-Partition in der gewünschten Größe neu erstellen zu können. Die zu ändernde Partition wird mit `-i` und die neue gewünschte Größe mit `-s` angegeben. Optional wird die Ausrichtung der Partition mit `-a` festgelegt. Dieser Schritt ändert nur die Größe der Partition. Das Dateisystem innerhalb der Partition wird in einem separaten Schritt erweitert.

[source,shell]
....
# gpart resize -i 2 -s 47G -a 4k ada0
ada0p2 resized
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661        - free -  (1.8G)
....

Erstellen Sie die Swap-Partition neu und aktivieren Sie sie:

[source,shell]
....
# gpart add -t freebsd-swap -a 4k ada0
ada0p3 added
# gpart show ada0
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661     3  freebsd-swap  (1.8G)
# swapon /dev/ada0p3
....

Erweitern Sie das UFS-Dateisystem, um die Kapazität der vergrößerten Partition zu nutzen:

[source,shell]
....
# growfs /dev/ada0p2
Device is mounted read-write; resizing will result in temporary write suspension for /.
It's strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432
....

Wenn das Dateisystem ZFS ist, wird die Größenänderung mit dem Unterkommando `online` und `-e` ausgelöst:

[source,shell]
....
# zfs online -e zroot /dev/ada0p2
....

Sowohl die Partition als auch das Dateisystem wurden jetzt vergrößert, um den neu zur Verfügung stehenden Speicherplatz zu nutzen.

[[usb-disks]]
== USB Speichermedien

Der Universal Serial Bus (USB) wird von vielen externen Speichern benutzt: Festplatten, USB-Thumbdrives sowie von CD- und DVD-Brennern. FreeBSD bietet Unterstützung für Geräte mit USB 1.x, 2.0 und 3.0.

[NOTE]
====
Die Unterstützung für USB 3.0 ist mit einiger Hardware, einschließlich Haswell (Lynx Point) Chipsätzen, nicht kompatibel. Wenn FreeBSD beim Booten mit dem Fehler `failed with error 19` abbricht, müssen Sie xHCI/USB3 im BIOS deaktivieren.
====

Unterstützung für USB-Massenspeicher ist im [.filename]#GENERIC#-Kernel enthalten. Für einen angepassten Kernel müssen die nachstehenden Zeilen in der Kernelkonfigurationsdatei enthalten sein:

[.programlisting]
....
device scbus    # SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners
....

FreeBSD benutzt den man:umass[4]-Treiber, der das SCSI-Subsystem verwendet um auf USB-Geräte zuzugreifen. Da alle USB-Geräte vom System als SCSI-Geräte erkannt werden, dürfen Sie _nicht_ `device atapicam` in die Kernelkonfigurationsdatei aufnehmen, wenn es sich bei dem Gerät um einen CD- oder DVD-Brenner handelt.

Der übrige Abschnitt beschreibt, wie Sie überprüfen können ob ein USB-Gerät von FreeBSD erkannt wird und wie Sie das Gerät so konfigurieren, dass es verwendet werden kann.

=== Konfiguration von Geräten

Um die USB-Konfiguration zu testen, schließen Sie das USB-Gerät an. Verwenden Sie `dmesg` um zu überprüfen, ob das Gerät in den Systemmeldungen erscheint. Dies sollte in etwa so aussehen:

[source,shell]
....
umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0
umass0:  SCSI over Bulk-Only; quirks = 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)
da0: quirks=0x2<NO_6_BYTE>
....

Fabrikat, Gerätedatei ([.filename]#da0#), Geschwindigkeit und Kapazität werden je nach Gerät unterschiedlich sein.

Da ein USB-Gerät als SCSI-Gerät erkannt wird, kann `camcontrol` benutzt werden, um die mit dem System verbundenen USB-Massenspeicher anzuzeigen:

[source,shell]
....
# camcontrol devlist
<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)
....

Alternativ kann `usbconfig` benutzt werden, um die Geräte aufzulisten. Weitere Informationen zu diesem Kommando finden Sie in man:usbconfig[8].

[source,shell]
....
# usbconfig
ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)
....

Wenn das Gerät noch nicht formatiert ist, finden Sie in <<disks-adding>> Informationen, wie Sie USB-Laufwerke formatieren und Partitionen einrichten. Wenn das Laufwerk bereits ein Dateisystem enthält, kann es von `root` nach den Anweisungen in crossref:basics[mount-unmount,“Anhängen und Abhängen von Dateisystemen”] eingehängt werden.

[WARNING]
====

Aus Sicherheitsgründen sollten Sie Benutzern, denen Sie nicht vertrauen, das Einhängen (z.B. durch die unten beschriebene Aktivierung von `vfs.usermount`) beliebiger Medien verbieten. Die meisten Dateisysteme wurden nicht entwickelt, um sich vor böswilligen Geräten zu schützen.
====

Um auch normalen Anwendern das Einhängen des Laufwerks zu gestatten, könnten Sie beispielsweise mit man:pw[8] alle potentiellen Benutzer dieser Gerätedateien in die Gruppe `operator` aufnehmen. Außerdem muss sichergestellt werden, dass `operator` Schreib- und Lesezugriff auf diese Gerätedateien haben. Hierfür werden die folgenden Zeilen in [.filename]#/etc/devfs.rules# hinzugefügt:

[.programlisting]
....
[localrules=5]
add path 'da*' mode 0660 group operator
....

[NOTE]
====
Verfügt das System über interne SCSI-Laufwerke, so verändern Sie die zweite Zeile wie folgt:

[.programlisting]
....
add path 'da[3-9]*' mode 0660 group operator
....

Dies wird die ersten drei SCSI-Laufwerke ([.filename]#da0# bis [.filename]#da2#) davon ausschließen, in die Gruppe `operator` aufgenommen zu werden. Ersetzen Sie `3` durch die Anzahl der SCSI-Laufwerke. Weitere Informationen zu dieser Datei finden Sie in man:devfs.rules[5].
====

Aktivieren Sie nun die Regeln in [.filename]#/etc/rc.conf#:

[.programlisting]
....
devfs_system_ruleset="localrules"
....

Als nächstes müssen Sie das System anweisen, auch normalen Benutzern das mounten von Dateisystemen zu erlauben, indem Sie die folgende Zeile in [.filename]#/etc/sysctl.conf# hinzufügen:

[.programlisting]
....
vfs.usermount=1
....

Da diese Einstellung erst nach einem Neustart wirksam wird, können Sie diese Variable mit `sysctl` auch direkt setzen:

[source,shell]
....
# sysctl vfs.usermount=1
vfs.usermount: 0 -> 1
....

Zuletzt müssen Sie noch ein Verzeichnis anlegen, in das das USB-Laufwerk eingehängt werden soll. Dieses Verzeichnis muss dem Benutzer gehören, der das USB-Laufwerk in den Verzeichnisbaum einhängen will. Dazu legen Sie als `root` ein Unterverzeichnis [.filename]#/mnt/username# an, wobei Sie _username_ durch den Login des jeweiligen Benutzers sowie _usergroup_ durch die primäre Gruppe des Benutzers ersetzen:

[source,shell]
....
# mkdir /mnt/username
# chown username:usergroup /mnt/username
....

Wenn Sie nun beispielsweise einen USB-Stick anschließen, wird automatisch die Gerätedatei [.filename]#/dev/da0s1# erzeugt. Ist das Gerät mit einem FAT-Dateisystem formatiert, kann es der Benutzer mit dem folgenden Befehl in den Verzeichnisbaum einhängen:

[source,shell]
....
% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username
....

Bevor das Gerät entfernt werden kann, _muss_ es abgehängt werden:

[source,shell]
....
# umount /mnt/username
....

Nach Entfernen des Geräts stehen in den Systemmeldungen Einträge, ähnlich der folgenden:

[source,shell]
....
umass0: at uhub3, port 2, addr 3 (disconnected)
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached
(da0:umass-sim0:0:0:0): Periph destroyed
....

=== Automatisches Einhängen von Wechselmedien

Damit USB-Geräte automatisch eingehängt werden, muss der Kommentar für folgende Zeile in [.filename]#/etc/auto_master# entfernt werden:

[source,shell]
....
/media		-media		-nosuid
....

Anschließend fügen Sie folgende Zeilen in [.filename]#/etc/devd.conf# hinzu:

[source,shell]
....
notify 100 {
	match "system" "GEOM";
	match "subsystem" "DEV";
	action "/usr/sbin/automount -c";
};
....

Falls man:autofs[5] und man:devd[8] bereits ausgeführt werden, müssen Sie die Konfiguration neu einlesen:

[source,shell]
....
# service automount restart
# service devd restart
....

man:autofs[5] wird beim Booten automatisch gestartet, wenn Sie folgende Zeile in [.filename]#/etc/rc.conf# hinzufügen:

[.programlisting]
....
autofs_enable="YES"
....

Damit man:autofs[5] funktioniert, muss man:devd[8] aktiviert sein, was aber in der Voreinstellung der Fall ist.

Starten Sie jetzt die Dienste:

[source,shell]
....
# service automount start
# service automountd start
# service autounmountd start
# service devd start
....

Jedes Dateisystem, das automatisch eingehängt werden kann, erscheint als ein Verzeichnis unterhalb von [.filename]#media#. Das Verzeichnis wird nach dem Dateisystemlabel benannt, bzw. nach dem Gerätenamen, falls kein Label existiert.

Das Dateisystem wird transparent beim ersten Zugriff in den Verzeichnisbaum eingehängt und auch nach gewisser Zeit der Inaktivität wieder ausgehängt. Laufwerke können auch manuell ausgehängt werden:

[source,shell]
....
# automount -fu
....

Diese Methode wird in der Regel bei Speicherkarten und USB-Sticks verwendet. Sie funktioniert aber mit allen Blockgeräten, einschließlich optischen Laufwerken und iSCSI-LUNs.

[[creating-cds]]
== Erstellen und Verwenden von CDs

CDs besitzen einige Eigenschaften, die sie von konventionellen Laufwerken unterscheiden. Sie wurden so entworfen, dass sie ununterbrochen, ohne Verzögerungen durch Kopfbewegungen zwischen den Spuren, gelesen werden können. CDs besitzen Spuren, aber damit ist der Teil Daten gemeint, der ununterbrochen gelesen wird, und nicht eine physikalische Eigenschaft der CD. Das ISO 9660-Dateisystem wurde entworfen, um mit diesen Unterschieden umzugehen.

Die FreeBSD Ports-Sammlung bietet einige Werkzeuge zum Brennen und Kopieren von Audio- und Daten-CDs. Dieses Kapitel beschreibt die Verwendung von mehreren Kommandozeilen-Werkzeugen. Wenn Sie eine graphische Oberfläche zum Brennen von CDs benutzen, können Sie package:sysutils/xcdroast[] oder package:sysutils/k3b[] installieren.

[[atapicam]]
=== Unterstützte Geräte

Der [.filename]#GENERIC#-Kernel enthält Unterstützung für SCSI, USB und ATAPICD Lesegeräte und Brenner. Wird ein angepasster Kernel erstellt, unterscheiden sich die Optionen für die Kernelkonfigurationsdatei je nach Art des Geräts.

Für einen SCSI-Brenner müssen folgende Optionen vorhanden sein:

[.programlisting]
....
device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners
....

Für einen USB-Brenner müssen folgende Optionen vorhanden sein:

[.programlisting]
....
device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd>	  # needed for CD and DVD burners
device uhci	  # provides USB 1.x support
device ohci	  # provides USB 1.x support
device ehci	  # provides USB 2.0 support
device xhci	  # provides USB 3.0 support
device usb	  # USB Bus (required)
device umass	  # Disks/Mass storage - Requires scbus and da
....

Für einen ATAPI-Brenner müssen folgende Optionen vorhanden sein:

[.programlisting]
....
device ata	  # Legacy ATA/SATA controllers
device scbus	  # SCSI bus (required for ATA/SCSI)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners
....

[NOTE]
====
Unter FreeBSD Versionen kleiner 10.x wird auch diese Option in der Kernelkonfigurationsdatei benötigt, falls der Brenner ein ATAPI-Gerät ist:

[.programlisting]
....
device atapicam
....

Alternativ kann folgende Zeile in [.filename]#/boot/loader.conf# hinzugefügt werden, um den Treiber beim Booten automatisch zu laden:

[.programlisting]
....
atapicam_load="YES"
....

Hierzu ist ein Neustart des Systems erforderlich, da dieser Treiber nur beim Booten geladen werden kann.
====

Mit `dmesg` können Sie prüfen, ob das Gerät von FreeBSD erkannt wurde. Unter FreeBSD Versionen kleiner 10.x lautet der Gerätename [.filename]#acd0# anstelle von [.filename]#cd0#.

[source,shell]
....
% dmesg | grep cd
cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed
....

[[cdrecord]]
=== Eine CD brennen

Unter FreeBSD kann `cdrecord` zum Brennen von CDs benutzt werden. Dieses Programm wird aus dem Port oder Paket package:sysutils/cdrtools[] installiert.

Obwohl `cdrecord` viele Optionen besitzt, ist die grundlegende Benutzung sehr einfach. Geben Sie den Namen der zu brennenden ISO-Datei an. Wenn das System über mehrere Brenner verfügt, müssen Sie auch den Namen des Gerätes angeben:

[source,shell]
....
# cdrecord dev=device imagefile.iso
....

Benutzen Sie `-scanbus` um den Gerätenamen des Brenners zu bestimmen. Die Ausgabe könnte wie folgt aussehen:

[source,shell]
....
# cdrecord -scanbus
ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling
Using libscg version 'schily-0.9'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *
....

Benutzen Sie die drei durch Kommas separierten Zahlen, die für den CD-Brenner angegeben sind, als Argument für `dev`. Im Beispiel ist das Yamaha-Gerät `1,5,0`, so dass die passende Eingabe `dev=1,5,0` ist. Einfachere Wege das Argument anzugeben, sowie Informationen über Audiospuren und das Einstellen der Geschwindigkeit, sind in der Manualpage von `cdrecord` beschrieben.

Alternativ können Sie den folgenden Befehl ausführen, um die Geräteadresse des Brenners zu ermitteln:

[source,shell]
....
# camcontrol devlist
<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)
....

Verwenden Sie die numerischen Werte für `scbus`, `target` und `lun`. Für dieses Beispiel wäre `1,0,0` als Gerätename zu verwenden.

[[mkisofs]]
=== Daten auf ISO-Dateisystem schreiben

Die Datendateien müssen vorbereitet sein, bevor sie auf eine CD gebrannt werden. In FreeBSD wird `mkisofs` vom Paket oder Port package:sysutils/cdrtools[] installiert. Dieses Programm kann aus einem UNIX(R) Verzeichnisbaum ein ISO 9660-Dateisystem erzeugen. Im einfachsten Fall müssen Sie lediglich den Namen der zu erzeugenden ISO-Datei und den Pfad zu den Dateien angeben, die auf dem ISO 9660-Dateisystem platziert werden:

[source,shell]
....
# mkisofs -o imagefile.iso /path/to/tree
....

Bei diesem Kommando werden die Dateinamen auf Namen abgebildet, die den Restriktionen des ISO 9660-Dateisystem entsprechen. Dateien, die diesem Standard nicht entsprechen bleiben unberücksichtigt.

Es gibt einige Optionen, um die Beschränkungen dieses Standards zu überwinden. Die unter UNIX(R) Systemen üblichen Rock-Ridge-Erweiterungen werden durch `-R` aktiviert und `-J` aktiviert die von Microsoft(R) Systemen benutzten Joliet-Erweiterungen.

Für CDs, die nur auf FreeBSD-Systemen verwendet werden sollen, kann `-U` genutzt werden, um alle Beschränkungen für Dateinamen aufzuheben. Zusammen mit `-R` wird ein Abbild des Dateisystems, identisch zu angegebenen FreeBSD-Dateibaum erstellt, selbst wenn dies den ISO 9660 Standard verletzt.

Die letzte übliche Option ist `-b`. Sie wird benutzt, um den Ort eines Bootimages einer "El Torito" bootbaren CD anzugeben. Das Argument zu dieser Option ist der Pfad zu einem Bootimage ausgehend von der Wurzel des Baumes, der auf die CD geschrieben werden soll. In der Voreinstellung erzeugt `mkisofs` ein ISO-Image im "Diskettenemulations"-Modus. Dabei muss das Image genau 1200, 1440 oder 2880 KB groß sein. Einige Bootloader, darunter der auf den FreeBSD Installationsmedien verwendete, kennen keinen Emulationsmodus. Daher sollte in diesen Fällen `-no-emul-boot` verwendet werden. Wenn [.filename]#/tmp/myboot# ein bootbares FreeBSD-System enthält, dessen Bootimage sich in [.filename]#/tmp/myboot/boot/cdboot# befindet, dann würde folgendes Kommando [.filename]#/tmp/bootable.iso# erstellen:

[source,shell]
....
# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot
....

Das resultierende ISO-Abbild kann als speicherbasiertes Laufwerk eingehängt werden:

[source,shell]
....
# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

Jetzt können Sie überprüfen, dass [.filename]#/mnt# und [.filename]#/tmp/myboot# identisch sind.

Sie können das Verhalten von `mkisofs` mit einer Vielzahl von Optionen beeinflussen. Details dazu entnehmen Sie bitte man:mkisofs[8].

[NOTE]
====
Es ist möglich eine Daten-CD in eine Datei zu kopieren, die einem Image entspricht, das mit `mkisofs` erstellt wurde. Verwenden Sie dazu `dd` mit dem Gerätenamen als Eingabedatei und den Namen der ISO als Ausgabedatei:

[source,shell]
....
# dd if=/dev/cd0 of=file.iso bs=2048
....

Das resultierende Abbild kann auf eine CD gebrannt werden, wie in <<cdrecord>> beschrieben.
====

[[mounting-cd]]
=== Einhängen von Daten-CDs

Sobald ein Abbild auf eine CD gebrannt wurde, kann es durch Angabe des Dateisystemtyp, des CD-Laufwerks und des Mountpunktes eingehangen werden:

[source,shell]
....
# mount -t cd9660 /dev/cd0 /mnt
....

Da `mount` davon ausgeht, dass ein Dateisystem vom Typ `ufs` ist, würde die Fehlermeldung `Incorrect super block` erscheinen, wenn Sie beim Einhängen einer Daten-CD auf die Angabe `-t cd9660` verzichten.

Auf diese Weise können Daten-CDs von jedem Hersteller verwendet werden. Es kann allerdings zu Problemen mit CDs kommen, die verschiedene ISO 9660-Erweiterungen benutzen. So speichern Joliet-CDs alle Dateinamen unter Verwendung von zwei Byte langen Unicode-Zeichen. Tauchen statt bestimmter Zeichen nur Fragezeichen auf, so muss über die Option `-C` der benötigte Zeichensatz angegeben werden. Weitere Informationen zu diesem Problem finden Sie in man:mount_cd9660[8].

[NOTE]
====
Damit der Kernel diese Zeichenkonvertierung (festgelegt durch die Option `-C`) erkennt, müssen Sie das Kernelmodul [.filename]#cd9660_iconv.ko# laden. Dazu fügen Sie folgende Zeile in [.filename]#loader.conf# ein:

[.programlisting]
....
cd9660_iconv_load="YES"
....

Danach müssen Sie allerdings Ihr System neu starten. Alternativ können Sie das Kernelmodul auch direkt über `kldload` laden.
====

Manchmal werden Sie die Meldung `Device not configured` erhalten, wenn Sie versuchen, eine Daten-CD einzuhängen. Für gewöhnlich liegt das daran, dass das Laufwerk keine CD erkannt hat, oder dass das Laufwerk auf dem Bus nicht erkannt wird. Es kann einige Sekunden dauern, bevor das Laufwerk die CD erkennt. Seien Sie also geduldig.

Manchmal wird ein SCSI-CD nicht erkannt, weil es keine Zeit hatte, auf das Zurücksetzen des Busses zu antworten. Um dieses Problem zu lösen, fügen Sie die folgende Zeile in die Kernelkonfiguration ein und erstellen Sie einen angepassten Kernel nach den Anweisungen in crossref:kernelconfig[kernelconfig-building,“Einen angepassten Kernel bauen und installieren”]:

[.programlisting]
....
options SCSI_DELAY=15000
....

Die Zeile bewirkt, dass nach dem Zurücksetzen des SCSI-Busses beim Booten 15 Sekunden gewartet wird, um dem CD-Laufwerk genügend Zeit zu geben, darauf zu antworten.

[NOTE]
====
Es ist möglich eine Datei auch direkt auf eine CD zu brennen, ohne vorher auf ihr ein ISO 9660-Dateisystem einzurichten. Man sagt auch, Daten werden roh auf die CD gebrannt. Einige Leute nutzen dies, um Datensicherungen durchzuführen.

Eine auf diese Weise gefertigte Daten-CD kann nicht in das Dateisystem eingehangen werden. Um auf die Daten einer solchen CD zuzugreifen, müssen die Daten vom rohen Gerät gelesen werden. Beispielsweise würde dieser Befehl eine komprimierte tar-Datei auf dem zweiten CD-Laufwerk in das aktuelle Verzeichnis extrahieren:

[source,shell]
....
# tar xzvf /dev/cd1
....

Um eine Daten-CD in das System einzuhängen, müssen die Daten mit `mkisofs` geschrieben werden.
====

[[duplicating-audiocds]]
=== Kopieren von Audio-CDs

Um eine Kopie einer Audio-CD zu erstellen, kopieren Sie die Stücke der CD in einzelne Dateien und brennen diese Dateien dann auf eine leere CD.

<<using-cdrecord>> beschreibt, wie eine Audio-CD kopiert und gebrannt wird. Wenn die Version älter als FreeBSD 10.0 ist und ein ATAPI-Gerät verwendet wird, muss zunächst das Modul `atapicam` nach den Anweisungen in <<atapicam>> geladen werden.
[[using-cdrecord]]
[.procedure]
.Procedure: Eine Audio-CD kopieren
. Der Port oder das Paket package:sysutils/cdrtools[] installiert `cdda2wav`. Mit diesem Kommando können Audiodaten in das aktuelle Verzeichnis extrahiert werden, wobei jede Datei in eine separate WAV-Datei geschrieben wird:
+

[source,shell]
....
% cdda2wav -vall -B -Owav
....

+ 
Wenn das System nur über ein CD-Laufwerk verfügt, muss der Gerätename nicht angegeben werden. Lesen Sie die Manualpage von `cdda2wav` für Anweisungen, wie ein Gerät spezifiziert wird und weitere verfügbare Optionen für dieses Kommando.
. Die erzeugten [.filename]#.wav# Dateien schreiben Sie mit `cdrecord` auf eine leere CD:
+

[source,shell]
....
% cdrecord -v dev=2,0 -dao -useinfo *.wav
....

+ 
Das Argument von `dev` gibt das verwendete Gerät an, das wie in <<cdrecord>> ermittelt werden kann.

[[creating-dvds]]
== DVDs benutzen

Nach der CD ist die DVD die nächste Generation optischer Speichermedien. Auf einer DVD können mehr Daten als auf einer CD gespeichert werden. DVDs werden als Standardmedium für Videos verwendet.

Für beschreibbare DVDs existieren fünf Medienformate:

* DVD-R: Dies war das erste verfügbare Format. Das Format wurde vom http://www.dvdforum.org/forum.shtml[DVD-Forum] festgelegt. Die Medien sind nur einmal beschreibbar.
* DVD-RW: Dies ist die wiederbeschreibbare Version des DVD-R Standards. Eine DVD-RW kann ungefähr 1000 Mal beschrieben werden.
* DVD-RAM: Dies ist ein wiederbeschreibbares Format, das wie ein Wechsellaufwerk betrachtet werden kann. Allerdings sind die Medien nicht kompatibel zu den meisten DVD-ROM-Laufwerken und DVD-Video-Spielern, da das DVD-RAM-Format nur von wenigen Brennern unterstützt wird. Informationen zur Nutzung von DVD-RAM finden Sie in <<creating-dvd-ram>>.
* DVD+RW: Ist ein wiederbeschreibbares Format, das von der https://de.wikipedia.org/wiki/DVD%2BRW_Alliance[ DVD+RW Alliance] festgelegt wurde. Eine DVD+RW kann ungefähr 1000 Mal beschrieben werden.
* DVD+R: Dieses Format ist die nur einmal beschreibbare Variante des DVD+RW Formats.

Auf einer einfach beschichteten DVD können 4.700.000.000 Bytes gespeichert werden. Das sind 4,38 GB oder 4485 MB (1 Kilobyte sind 1024 Bytes).

[NOTE]
====
Die physischen Medien sind unabhängig von der Anwendung. Ein DVD-Video ist eine spezielle Anordnung von Dateien, die auf irgendein Medium, beispielsweise DVD-R, DVD+R oder DVD-RW geschrieben werden kann. Bevor Sie ein Medium auswählen, müssen Sie sicherstellen, dass der Brenner und der DVD-Spieler mit dem Medium umgehen können.
====

=== Konfiguration

Benutzen Sie man:growisofs[1], um DVDs zu beschreiben. Das Kommando ist Bestandteil von package:sysutils/dvd+rw-tools[], und kann mit allen DVD-Medien umgehen.

Diese Werkzeuge verwenden das SCSI-Subsystem, um auf die Geräte zuzugreifen. Daher muss <<atapicam,ATAPI/CAM-Unterstützung>> geladen, oder statisch in den Kernel kompiliert werden. Sollte der Brenner jedoch die USB-Schnittstelle nutzen, wird diese Unterstützung nicht benötigt. Weitere Informationen zur Konfiguration von USB-Geräten finden Sie in <<usb-disks>>.

Für ATAPI-Geräte müssen ebenfalls DMA-Zugriffe aktiviert werden. Dazu wird die folgende Zeile in [.filename]#/boot/loader.conf# eingefügt:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

Bevor Sie dvd+rw-tools benutzen, lesen Sie bitte die Hardware-Informationen auf der Seite http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html[Hardware Compatibility Notes].

[NOTE]
====
Für eine grafische Oberfläche sollten Sie sich package:sysutils/k3b[] ansehen, das eine benutzerfreundliche Schnittstelle zu man:growisofs[1] und vielen anderen Werkzeugen bietet.
====

=== Daten-DVDs brennen

man:growisofs[1] erstellt mit dem Programm <<mkisofs,mkisofs>> das Dateisystem und brennt anschließend die DVD. Vor dem Brennen braucht daher kein Abbild der Daten erstellt zu werden.

Wenn Sie von den Daten im Verzeichnis [.filename]#/path/to/data# eine DVD+R oder eine DVD-R brennen wollen, benutzen Sie das nachstehende Kommando:

[source,shell]
....
# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data
....

In diesem Beispiel wird `-J -R` an man:mkisofs[8] durchgereicht und dient zum Erstellen des Dateisystems (hier: ein ISO-9660-Dateisystem mit Joliet- und Rock-Ridge-Erweiterungen). Weiteres entnehmen Sie bitte der Hilfeseite man:mkisofs[8].

Die Option `-Z` wird für die erste Aufnahme einer Single- oder Multisession benötigt. Ersetzen Sie _/dev/cd0_ mit dem Gerätenamen des DVD-Gerätes. Die Nutzung von `-dvd-compat` schließt das Medium, weitere Daten können danach nicht mehr angehängt werden. Dies sollte auch eine bessere Kompatibilität mit anderen DVD-ROM-Laufwerken bieten.

Um ein vorher erstelltes Abbild der Daten zu brennen, beispielsweise _imagefile.iso_, verwenden Sie:

[source,shell]
....
# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso
....

Die Schreibgeschwindigkeit hängt von den verwendeten Medium sowie dem verwendeten Gerät ab und sollte automatisch gesetzt werden. Um die Schreibgeschwindigkeit vorzugeben, verwenden Sie `-speed=`. Beispiele finden Sie in man:growisofs[1].

[NOTE]
====
Um größere Dateien als 4.38GB zu unterstützen, ist es notwendig ein UDF/ISO-9660 Hybrid-Dateisystem zu erstellen. Dieses Dateisystem muss mit zusätzlichen Parametern `-udf -iso-level 3` bei man:mkisofs[8] und allen relevanten Programmen, wie beispielsweise man:growisofs[1]) erzeugt werden. Dies ist nur notwendig, wenn Sie ein ISO-Image erstellen oder direkt auf eine DVD schreiben wollen. DVDs, die in dieser Weise hergestellt worden sind, müssen als UDF-Dateisystem mit man:mount_udf[8] eingehangen werden. Sie sind nur auf Betriebssystemen, die UDF unterstützen brauchbar, ansonsten sieht es so aus, als ob sie kaputte Dateien enthalten würden.

Um diese Art von ISO-Datei zu erstellen:

[source,shell]
....
% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data
....

Um Daten direkt auf eine DVD zu brennen, geben Sie den folgenden Befehl ein:

[source,shell]
....
# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data
....

Wenn ein ISO-Abbild bereits große Dateien enthält, sind keine weiteren Optionen für man:growisofs[1] notwendig, um das Abbild auf die DVD zu brennen.

Achten Sie darauf, eine aktuelle Version von package:sysutils/cdrtools[] zu verwenden, welche man:mkisofs[8] enthält, da ältere Versionen keinen Support für große Dateien enthalten. Falls die neueste Version nicht funktioniert, installieren Sie package:sysutils/cdrtools-devel[] und lesen Sie man:mkisofs[8].
====

=== DVD-Videos brennen

Ein DVD-Video ist eine spezielle Anordnung von Dateien, die auf den ISO-9660 und den micro-UDF (M-UDF) Spezifikationen beruht. Da DVD-Video auf eine bestimmte Datei-Hierarchie angewiesen ist, müssen DVDs mit speziellen Programmen wie package:multimedia/dvdauthor[] erstellt werden.

Ist bereits ein Abbild des Dateisystems eines DVD-Videos vorhanden, kann es auf die gleiche Weise wie jedes andere Abbild gebrannt werden. Wenn `dvdauthor` verwendet wurde, um die DVD zu erstellen und die Resultate in [.filename]#/path/to/video# liegen, kann das folgende Kommando verwendet werden, um ein DVD-Video zu brennen:

[source,shell]
....
# growisofs -Z /dev/cd0 -dvd-video /path/to/video
....

`-dvd-video` wird an man:mkisofs[8] weitergereicht, um die Datei-Hierarchie für ein DVD-Video zu erstellen. Weiterhin bewirkt diese Option, dass man:growisofs[1] mit `-dvd-compat` aufgerufen wird.

=== DVD+RW-Medien benutzen

Im Gegensatz zu CD-RW-Medien müssen DVD+RW-Medien erst formatiert werden, bevor sie benutzt werden können. Es wird _empfohlen_ man:growisofs[1] einzusetzen, da das Programm Medien automatisch formatiert, wenn es erforderlich ist. Es ist jedoch möglich, auch `dvd+rw-format` zu nutzen, um die DVD+RW zu formatieren:

[source,shell]
....
# dvd+rw-format /dev/cd0
....

Dieser Vorgang muss nur einmal durchgeführt werden. Denken Sie daran, dass nur neue DVD+RWs formatiert werden müssen. Anschließend können DVD+RWs, wie gewohnt gebrannt werden.

Wenn Sie auf einer DVD+RW ein neues Dateisystem erstellen wollen, brauchen Sie die DVD+RW vorher nicht zu löschen. Überschreiben Sie einfach das vorige Dateisystem indem Sie eine neue Session anlegen:

[source,shell]
....
# growisofs -Z /dev/cd0 -J -R /path/to/newdata
....

Das DVD+RW-Format erlaubt es, Daten an eine vorherige Aufnahme anzuhängen. Dazu wird eine neue Session mit der schon bestehenden zusammengeführt. Es wird keine Multi-Session geschrieben, sondern man:growisofs[1] _vergrößert_ das ISO-9660-Dateisystem auf dem Medium.

Das folgende Kommando fügt weitere Daten zu einer vorher erstellten DVD+RW hinzu:

[source,shell]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

Wenn Sie eine DVD+RW erweitern, verwenden Sie dieselben man:mkisofs[8]-Optionen wie beim Erstellen der DVD+RW.

[NOTE]
====
Verwenden Sie `-dvd-compat`, um bessere Kompatibilität mit DVD-ROM-Laufwerken zu gewährleisten. Zu einem DVD+RW-Medium können Sie mit dieser Option auch weiterhin Daten hinzufügen.
====

Um das Medium zu löschen, verwenden Sie:

[source,shell]
....
# growisofs -Z /dev/cd0=/dev/zero
....

=== DVD-RW-Medien benutzen

Eine DVD-RW kann mit zwei Methoden beschrieben werden: _Sequential-Recording_ oder _Restricted-Overwrite_. Voreingestellt ist Sequential-Recording.

Eine neue DVD-RW kann direkt beschrieben werden; sie muss nicht vorher formatiert werden. Allerdings muss eine DVD-RW, die mit Sequential-Recording aufgenommen wurde, zuerst gelöscht werden, bevor eine neue Session aufgenommen werden kann.

Der folgende Befehl löscht eine DVD-RW im Sequential-Recording-Modus:

[source,shell]
....
# dvd+rw-format -blank=full /dev/cd0
....

[NOTE]
====
Das vollständige Löschen mit `-blank=full` dauert mit einem 1x Medium ungefähr eine Stunde. Wenn die DVD-RW im Disk-At-Once-Modus (DAO) aufgenommen wurde, kann sie mit `-blank` schneller gelöscht werden. Um eine DVD-RW im DAO-Modus zu brennen, benutzen Sie das folgende Kommando:

[source,shell]
....
# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso
....

Die Option `-use-the-force-luke=dao` sollte nicht erforderlich sein, da man:growisofs[1] den DAO-Modus automatisch erkennt.

Der Restricted-Overwrite-Modus sollte mit jeder DVD-RW verwendet werden, da er flexibler als der voreingestellte Sequential-Recording-Modus ist.
====

Um Daten auf eine DVD-RW im Sequential-Recording-Modus zu schreiben, benutzen Sie dasselbe Kommando wie für die anderen DVD-Formate:

[source,shell]
....
# growisofs -Z /dev/cd0 -J -R /path/to/data
....

Um weitere Daten zu einer Aufnahme hinzuzufügen, benutzen Sie `-M` mit man:growisofs[1]. Werden die Daten im Sequential-Recording-Modus hinzugefügt, wird eine neue Session erstellt. Das Ergebnis ist ein Multi-Session-Medium.

Eine DVD-RW im Restricted-Overwrite-Modus muss nicht gelöscht werden, um eine neue Session aufzunehmen. Das Medium kann einfach mit `-Z` überschrieben werden. Mit `-M` kann das ISO-9660-Dateisystem, wie mit einer DVD+RW, vergrößert werden. Die DVD enthält danach eine Session.

Benutzen sie das nachstehende Kommando, um den Restricted-Overwrite-Modus einzustellen:

[source,shell]
....
# dvd+rw-format /dev/cd0
....

Das folgende Kommando stellt den Modus wieder auf Sequential-Recording zurück:

[source,shell]
....
# dvd+rw-format -blank=full /dev/cd0
....

=== Multi-Session

Nur wenige DVD-ROM-Laufwerke unterstützen Multi-Session-DVDs und lesen meist nur die erste Session. Mehrere Sessions werden von DVD+R, DVD-R und DVD-RW im Sequential-Recording-Modus unterstützt. Im Modus Restricted-Overwrite gibt nur eine Session.

Wenn das Medium noch nicht geschlossen ist, erstellt das nachstehende Kommando eine neue Session auf einer DVD+R, DVD-R oder DVD-RW im Sequential-Recording-Modus:

[source,shell]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

Wird dieses Kommando mit DVD+RW- oder DVD-RW-Medien im Restricted-Overwrite-Modus benutzt, werden die neuen Daten mit den Daten der bestehenden Session zusammengeführt. Das Medium enthält danach eine Session. Nutzen Sie diese Methode, um neue Daten zu einer bestehenden Session hinzuzufügen.

[NOTE]
====
Für den Anfang und das Ende einer Session wird auf dem Medium zusätzlicher Platz verbraucht. Um den Speicherplatz auf dem Medium optimal auszunutzen, sollten Sie daher Sessions mit vielen Daten hinzufügen. Auf ein DVD+R-Medium passen maximal 154 Sessions, 2000 Sessions auf ein DVD-R-Medium und 127 Sessions auf eine DVD+R Double Layer.
====

=== Weiterführendes

`dvd+rw-mediainfo _/dev/cd0_` zeigt Informationen über eine im Laufwerk liegende DVD an.

Weiteres zu dvd+rw-tools finden Sie in man:growisofs[1], auf der http://fy.chalmers.se/~appro/linux/DVD+RW/[ dvd+rw-tools Web-Seite] und in den Archiven der http://lists.debian.org/cdwrite/[ cdwrite-Mailingliste].

[NOTE]
====
Wenn Sie einen Problembericht zur Nutzung der dvd+rw-tools erstellen, fügen Sie immer die Ausgabe von `dvd+rw-mediainfo` hinzu.
====

[[creating-dvd-ram]]
=== DVD-RAM

DVD-RAM-fähige Brenner nutzten die SCSI- oder ATAPI-Schnittstelle. Für ATAPI-Geräte muss der DMA-Modus aktiviert werden, indem die folgende Zeile in [.filename]#/boot/loader.conf# hinzugefügt wird:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

Eine DVD-RAM kann mit einer Wechselplatte verglichen werden. Wie diese, muss auch eine DVD-RAM vor dem ersten Einsatz formatiert werden. In diesem Beispiel wird das gesamte Medium mit dem Standard-UFS2-Dateisystem formatiert:

[source,shell]
....
# dd if=/dev/zero of=/dev/acd0 bs=2k count=1
# bsdlabel -Bw acd0
# newfs /dev/acd0
....

Denken Sie dabei daran, dass Sie gegebenenfalls die Gerätedatei (hier [.filename]#acd0#) an Ihre Konfiguration anpassen müssen.

Nachdem die DVD-RAM formatiert ist, kann sie wie eine normale Festplatte gemountet werden:

[source,shell]
....
# mount /dev/acd0 /mnt
....

Danach kann schreibend und lesend auf das DVD-RAM Medium zugegriffen werden.

[[floppies]]
== Disketten benutzen

Dieser Abschnitt beschreibt die Formatierung von 3,5 Zoll Disketten in FreeBSD.

[.procedure]
====
.Procedure: Disketten formatieren

Bevor eine Diskette benutzt werden kann, muss sie (low-level) formatiert werden, was normalerweise der Hersteller schon gemacht hat. Sie können die Diskette allerdings noch einmal formatieren, um das Medium zu überprüfen. Benutzen Sie man:fdformat[1], um Disketten unter FreeBSD zu formatieren. Achten Sie dabei auf Fehlermeldungen, die schlechte Speichermedien anzeigen.

. Um eine Diskette zu formatieren, legen Sie eine 3,5 Zoll Diskette in das erste Diskettenlaufwerk ein und führen das folgende Kommando aus:
+
[source,shell]
....
# /usr/sbin/fdformat -f 1440 /dev/fd0
....

. Nach dem Formatieren muss auf der Diskette ein Disklabel erstellt werden, um die Größe und Geometrie der Diskette zu erkennen. Eine Liste der unterstützten Geometrien finden Sie in [.filename]#/etc/disktab#.
+ 
Erstellen Sie nun das Label mit man:bsdlabel[8]:
+
[source,shell]
....
# /sbin/bsdlabel -B -w /dev/fd0 fd1440
....

. Auf der Diskette kann nun ein Dateisystem erstellt werden (high-level Formatierung). Das Dateisystem der Diskette kann entweder UFS oder FAT sein, wobei FAT für Disketten in der Regel die bessere Wahl ist.
+ 
Um die Diskette mit FAT zu formatieren, geben Sie folgendes Kommando ein:
+
[source,shell]
....
# /sbin/newfs_msdos /dev/fd0
....
====

Die Diskette kann nun benutzt werden. Um die Diskette zu verwenden, kann sie mit man:mount_msdosfs[8] eingehängt werden. Man kann auch package:emulators/mtools[] aus der Ports-Sammlung installieren, um mit der Diskette zu arbeiten.

[[backup-basics]]
== Datensicherung

Die Planung und Umsetzung einer Backup-Strategie ist unerlässlich, um Daten in bestimmten Situationen wiederherstellen zu können, zum Beispiel bei Plattendefekten, versehentlichem Löschen von Dateien, willkürlicher Korrumpierung von Dateien oder der vollständigen Zerstörung des Systems und der Backups, die am gleichen Ort aufbewahrt werden.

Die Art und der Zeitplan des Backups kann variieren, abhängig von der Wichtigkeit der Daten, der benötigten Granularität zur Wiederherstellung von Dateien und der Dauer einer akzeptablen Ausfallzeit. Zu den möglichen Backup-Strategien gehören unter anderem:

* Die Archivierung des kompletten Systems auf externen Datenträgern. Dieser Ansatz schützt zwar vor allen oben aufgeführten Problemen, ist aber zeitaufwändig und unbequem bei der Wiederherstellung, insbesondere für nicht privilegierte Benutzer.
* Dateisystem-Snapshots sind nützlich bei der Wiederherstellung von gelöschten Dateien, bzw. früheren Versionen von Dateien.
* Kopien ganzer Dateisysteme oder Festplatten, die mit einem anderen System im Netzwerk mittels package:net/rsync[] synchronisiert werden.
* Hardware oder Software RAID, was im Falle von Plattendefekten die Ausfallzeit minimiert oder vermeidet.

Üblicherweise wird eine Mischung aus verschiedenen Strategien verwendet. Es kann zum Beispiel ein Sicherungsplan erstellt und automatisiert werden, um eine wöchentliche, vollständige Systemsicherung, ergänzt mit stündlichen ZFS-Snapshots, zu erstellen. Darüber hinaus könnte man eine manuelle Sicherung einzelner Verzeichnisse oder Dateien machen, bevor diese bearbeitet oder gelöscht werden.

Dieser Abschnitt beschreibt einige Programme, die zur Erstellung und Verwaltung von Sicherungen unter FreeBSD verwendet werden können.

=== Sicherung von Dateisystemen

Die traditionellen UNIX(R)-Programme zum Sichern und Wiederherstellen von Dateisystemen sind man:dump[8] und man:restore[8]. Diese Programme arbeiten auf der Block-Ebene der Festplatte, also unterhalb des Abstraktionslevels von Dateien, Links und Verzeichnissen, die die Grundlage des Dateisystemkonzepts bilden. Im Gegensatz zu anderen Backup-Programmen sichert `dump` ein ganzes Dateisystem und nicht nur einen Teil des Dateisystems, oder einen Verzeichnisbaum, der mehr als ein Dateisystem umfasst. Anstatt Dateien oder Verzeichnisse zu schreiben, schreibt `dump` die Blöcke, aus denen die Dateien und Verzeichnisse bestehen.

[NOTE]
====
Wird `dump` benutzt, um das Root-Verzeichnis zu sichern, werden [.filename]#/home#, [.filename]#/usr# und viele andere Verzeichnisse nicht gesichert, da dies normalerweise Mountpunkte für andere Dateisysteme oder symbolische Links zu diesen Dateisystemen sind.
====

Wenn `restore` zum Extrahieren von Daten verwendet wird, werden temporäre Dateien standardmäßig in [.filename]#/tmp# abgelegt. Wenn Sie von einer Platte mit einem kleinen [.filename]#/tmp#-Verzeichnis zurücksichern, setzen Sie die Umgebungsvariable `TMPDIR` auf ein Verzeichnis mit mehr freiem Speicherplatz, damit die Wiederherstellung gelingt.

Beachten Sie bei der Verwendung von `dump`, dass es einige Eigenarten aus den frühen Tagen der Version 6 von AT&T UNIX(R) (ca. 1975) beibehalten hat. Die Standardparameter gehen davon aus, dass auf einem 9-Spur-Band gesichert wird, und nicht auf ein anderes Medium oder auf Sicherungsbänder mit hoher Dichte. Diese Standardwerte müssen auf der Kommandozeile überschrieben werden.

Es ist möglich, das Dateisystem über das Netzwerk auf einem anderen Rechner zu sichern, oder auf einem Bandlaufwerk eines anderen Rechners. Obwohl die Programme man:rdump[8] und man:rrestore[8] für diese Zwecke benutzt werden können, gelten sie als nicht sicher.

Verwenden Sie stattdessen `dump` und `restore` in einer sichereren Weise über eine SSH-Verbindung. In diesem Beispiel wird eine vollständige, komprimierte Sicherung von [.filename]#/usr# erstellt, das anschließend an einen bestimmten Host über eine SSH-Verbindung gesendet wird.

.`dump` mit ssh benutzen
[example]
====

[source,shell]
....
# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
	  targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz
....

====

In diesem Beispiel wird `RSH` gesetzt, um über eine SSH-Verbindung eine Sicherung auf ein Bandlaufwerk eines entfernten Systems zu schreiben:

.`dump` über ssh mit gesetzter `RSH` benutzen
[example]
====

[source,shell]
....
# env RSH=/usr/bin/ssh /sbin/dump -0uan -f tatargetuser@targetmachine.example.com:/dev/sa0 /usr
....

====

=== Sicherung von Verzeichnissen

Einige integrierte Werkzeuge stehen zur Sicherung und Wiederherstellung von bestimmten Dateien und Verzeichnissen bei Bedarf zur Verfügung.

Wenn es um die Sicherung von Dateien in einem Verzeichnis geht, ist man:tar[1] eine gute Wahl. Dieses Werkzeug stammt aus Version 6 von AT&T UNIX(R) und erwartet standardmäßig eine rekursive Sicherung auf ein lokales Band. Es können jedoch Optionen angegeben werden, um den Namen einer Sicherungsdatei zu bestimmen.

In diesem Beispiel wird eine komprimierte Sicherung des aktuellen Verzeichnisses nach [.filename]#/tmp/mybackup.tgz# gespeichert. Achten Sie bei der Sicherungsdatei darauf, dass sie nicht in dem Verzeichnis gespeichert wird, welches gesichert werden soll.

.Das aktuelle Verzeichnis mit `tar` sichern
[example]
====

[source,shell]
....
# tar czvf /tmp/mybackup.tgz .
....

====

Um eine komplette Sicherung wiederherzustellen, wechseln Sie mit `cd` in das Verzeichnis, in dem Sie die Daten wiederherstellen möchten und geben Sie den Namen der Sicherungsdatei an. Beachten Sie, dass dabei alle Dateien in dem Verzeichnis überschrieben werden. Im Zweifel sichern Sie besser in einem temporären Verzeichnis, oder geben Sie den Verzeichnisnamen bei der Wiederherstellung an.

.Wiederherstellung mit `tar` in das aktuelle Verzeichnis
[example]
====

[source,shell]
....
# tar xzvf /tmp/mybackup.tgz
....

====

Es gibt dutzende Optionen, die in man:tar[1] beschrieben werden. Das Programm unterstützt auch die Verwendung von Ausschlußmustern, um bestimmte Dateien von der Sicherung oder Wiederherstellung von Verzeichnissen auszuschließen.

Um bestimmte, aufgelistete Dateien und Verzeichnisse zu sichern, ist man:cpio[1] eine gute Wahl. Im Gegensatz zu `tar` weiß `cpio` nicht wie ein Verzeichnisbaum durchlaufen wird. Daher ist es auf eine Liste von zu sichernden Dateien angewiesen.

So kann beispielsweise eine Liste von Dateien mit `ls` oder `find` erzeugt werden. Dieses Beispiel erstellt eine rekursive Liste des aktuellen Verzeichnisses, die dann über eine Pipe an `cpio` übergeben wird, um eine Sicherung namens [.filename]#/tmp/mybackup.cpio# zu erstellen.

.Rekursive Sicherung des aktuellen Verzeichnisses mit `ls` und `cpio`
[example]
====

[source,shell]
....
# ls -R | cpio -ovF /tmp/mybackup.cpio
....

====

man:pax[1] ist ein Programm, welches versucht die Funktionen von `tar` und `cpio` zu kombinieren. Über die Jahre hinweg sind die verschiedenen Versionen von `tar` und `cpio` leicht inkompatibel geworden. Daher hat POSIX(R) `pax` geschaffen, welches versucht viele der unterschiedlichen `cpio`- und `tar`-Formate zu lesen und zu schreiben, außerdem einige neue, eigene Formate.

Für die vorangegangenen Beispiele wäre ein äquivalenter Aufruf von `pax`:

.Das aktuelle Verzeichnis mit `pax` sichern
[example]
====

[source,shell]
....
# pax -wf /tmp/mybackup.pax .
....

====

[[backups-tapebackups]]
=== Bandmedien benutzen

Obwohl sich Bandmedien mit der Zeit weiterentwickelt haben, verwenden moderne Backup-Systeme in der Regel Offsite-Backups in Verbindung mit lokalen Wechseldatenträgern. FreeBSD unterstützt alle SCSI-Bandlaufwerke, wie etwa LTO und DAT. Zusätzlich gibt es begrenzte Unterstützung für SATA- und USB-Bandlaufwerke.

Für SCSI-Bandlaufwerke nutzt FreeBSD den man:sa[4] Treiber, der die Schnittstellen [.filename]#/dev/sa0#, [.filename]#/dev/nsa0# und [.filename]#/dev/esa0# bereitstellt. Der Name des physikalischen Geräts ist [.filename]#/dev/sa0#. Wird [.filename]#/dev/nsa0# benutzt, dann wird die Backup-Anwendung nach dem Schreibvorgang das Band nicht zurückspulen, was es ermöglicht, mehr als eine Datei auf das Band zu schreiben. Die Verwendung von [.filename]#/dev/esa0# wirft das Band aus, nachdem das Gerät geschlossen wurde.

FreeBSD nutzt `mt` für die Steuerung der Operationen des Bandlaufwerks, wie die Suche nach Dateien auf einem Band, oder um Kontrollmarkierungen auf ein Band zu schreiben. Beispielsweise können die ersten drei Dateien auf einem Band erhalten bleiben, indem sie übersprungen werden, bevor eine neue Datei auf das Band geschrieben wird

[source,shell]
....
# mt -f /dev/nsa0 fsf 3
....

Dieses Werkzeug unterstützt viele Operationen. Weitere Einzelheiten finden Sie in man:mt[1].

Um eine Datei mit `tar` auf ein Band zu schreiben, geben Sie den Namen des Bandlaufwerks und den Dateinamen an:

[source,shell]
....
# tar cvf /dev/sa0 file
....

Wiederherstellung von Dateien aus dem `tar`-Archiv von Band in das aktuelle Verzeichnis:

[source,shell]
....
# tar xvf /dev/sa0
....

Benutzen Sie `dump`, um ein UFS-Dateisystem zu sichern. Dieses Beispiel sichert [.filename]#/usr#, ohne danach das Band zurückzuspulen:

[source,shell]
....
# dump -0aL -b64 -f /dev/nsa0 /usr
....

Interaktive Wiederherstellung von Dateien aus einer man:dump[8]-Datei von Band in das aktuelle Verzeichnis:

[source,shell]
....
# restore -i -f /dev/nsa0
....

[[backups-programs-amanda]]
=== Backup-Software von Drittanbietern

Die FreeBSD Ports-Sammlung enthält viele Programme von Drittanbietern, die verwendet werden können um die zeitliche Erstellung von Sicherungen zu planen, zu vereinfachen und bequemer zu machen. Viele dieser Programme basieren auf dem Client-Server-Modell und können benutzt werden, um die Sicherung von einzelnen Systemen oder allen Rechnern in einem Netzwerk zu automatisieren.

Zu den bekannten Programmen gehören Amanda, Bacula, rsync und duplicity.

=== Die Wiederherstellung in einem Notfall

Zusätzlich zu den regelmäßigen Sicherungen empfiehlt es sich, die folgenden Schritte im Rahmen eines Notfallplans durchzuführen.

Erstellen Sie einen Ausdruck der Ausgabe der folgenden Kommandos:

* `gpart show`
* `more /etc/fstab`
* `dmesg`

Bewahren Sie diesen Ausdruck und eine Kopie des Installationsmediums an einem sicheren Ort auf. Im Falle einer Wiederherstellung im Notfall, starten Sie von dem Installationsmedium und wählen Sie `Live CD`, um eine Rettungs-Shell zu starten. Dieser Rettungsmodus kann verwendet werden, um den aktuellen Stand des Systems anzuzeigen, und wenn nötig, Festplatten zu formatieren und Daten aus den Sicherungen wiederherzustellen.

[NOTE]
====
Das Installationsmedium für FreeBSD/i386 {rel112-current}-RELEASE enthält keine Rettungs-Shell. Laden Sie für diese Version ein Abbild der Livefs CD von link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso].
====

Als nächstes testen Sie die Rettungs-Shell und die Sicherungen. Dokumentieren Sie diesen Ablauf. Bewahren Sie diese Notizen zusammen mit den Medien, den Ausdrucken und den Sicherungen auf. Diese Notizen können Ihnen im Notfall helfen eine versehentliche Zerstörung der Sicherungen zu verhindern, während Sie unter Stress eine Wiederherstellung durchführen.

Als zusätzliche Sicherheitsvorkehrung kann jeweils die letzte Sicherung an einem entfernten Standort aufbewahrt werden. Dieser Standort sollte räumlich von den Computern und Festplatten durch eine erhebliche Entfernung getrennt sein.

[[disks-virtual]]
== Speicherbasierte Laufwerke

Neben physikalischen Laufwerken unterstützt FreeBSD auch speicherbasierte Laufwerke. Eine mögliche Verwendung für ein speicherbasiertes Laufwerk ist der Zugriff auf ein ISO-Dateisystem, jedoch ohne vorher die Daten auf eine CD oder DVD zu brennen und dann das Medium einzuhängen.

FreeBSD verwendet den man:md[4] Treiber um Unterstützung für speicherbasierte Laufwerke bereitzustellen. Dieser Treiber ist bereits im [.filename]#GENERIC#-Kernel enthalten. Wenn Sie eine angepasste Kernelkonfigurationsdatei verwenden, stellen Sie sicher, dass folgende Zeile enthalten ist:

[.programlisting]
....
device md
....

[[disks-mdconfig]]
=== Ein- und Aushängen von bestehenden Abbildern

Um ein bestehendes Abbild eines Dateisystems einzuhängen, verwenden Sie `mdconfig` zusammen mit dem Namen der ISO-Datei und einer freien Gerätenummer. Benutzen Sie dann diese Gerätenummer, um das Abbild in einen existierenden Mountpunkt einzuhängen. Sobald dies erledigt ist, erscheinen die Dateien des Abbildes unterhalb des Mountpunktes. Dieses Beispiel wird [.filename]#diskimage.iso# an das speicherbasierte Laufwerk [.filename]#/dev/md0# binden und dann in [.filename]#/mnt# einhängen:

[source,shell]
....
# mdconfig -f diskimage.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

Beachten Sie, dass `-t cd9660` benutzt wurde, um ein ISO-Format einzuhängen. Wenn keine Gerätenummer mit `-u` angegeben ist, wird von man:md[4] automatisch eine ungenutzte Gerätenummer zugewiesen. Das zugewiesene Gerät wird auf der Standardausgabe ausgegeben (zum Beispiel [.filename]#md4#). Weitere Informationen zu diesem Kommando und dessen Optionen finden Sie in man:mdconfig[8].

Wenn ein speicherbasiertes Laufwerk nicht mehr in Gebrauch ist, sollten seine belegten Ressourcen wieder an das System zurückgegeben werden. Hängen Sie zuerst das Dateisystem aus, dann verwenden Sie `mdconfig`, um die Platte vom System zu trennen und die Ressourcen freizugeben.

[source,shell]
....
# umount /mnt
# mdconfig -d -u 0
....

Um festzustellen, ob noch irgendwelche speicherbasierten Laufwerke am System angeschlossen sind, benutzen Sie `mdconfig -l`.

[[disks-md-freebsd5]]
=== Ein datei- oder speicherbasiertes Laufwerk erzeugen

FreeBSD unterstützt auch speicherbasierte Laufwerke, bei denen der verwendete Speicher entweder einer Festplatte, oder einem Bereich im Arbeitsspeicher zugewiesen wird. Die erste Methode ist gemeinhin als dateibasiertes Dateisystem, die zweite als speicherbasiertes Dateisystem bekannt. Beide Typen können mit `mdconfig` erzeugt werden.

Um ein speicherbasiertes Dateisystem zu erstellen, geben Sie den Typ `swap` sowie die gewünschte Größe des Laufwerks an. Dieses Beispiel erzeugt ein 5 MB großes Laufwerk an der Gerätenummer `1`. Das Laufwerk wird mit dem UFS-Dateisystem formatiert, bevor es eingehängt wird:

[source,shell]
....
# mdconfig -a -t swap -s 5m -u 1
# newfs -U md1
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
# mount /dev/md1 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt
....

Um ein dateibasiertes Dateisystem zu erstellen, muss zunächst ein Stück Speicher auf der Festplatte reserviert werden. Dieses Beispiel erzeugt eine 5 MB große Datei namens [.filename]#newimage#:

[source,shell]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
....

Als nächstes muss diese Datei an ein speicherbasiertes Laufwerk gebunden, gelabelt und mit dem UFS-Dateisystem formatiert werden. Danach können Sie das Laufwerk einhängen und die Größe überprüfen:

[source,shell]
....
# mdconfig -f newimage -u 0
# bsdlabel -w md0 auto
# newfs -U md0a
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
# mount /dev/md0a /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt
....

Es benötigt mehrere Befehle, um ein datei- oder speicherbasiertes Dateisystem mit `mdconfig` zu erstellen. FreeBSD enthält auch `mdmfs`, das ein speicherbasiertes Laufwerk automatisch konfigurieren, formatieren und einhängen kann. Nachdem beispielsweise [.filename]#newimage# mit `dd` erstellt wurde, hätte auch der folgende Befehl benutzt werden können, anstelle der oben verwendeten Kommandos `bsdlabel`, `newfs` und `mount`:

[source,shell]
....
# mdmfs -F newimage -s 5m md0 /mnt
....

Um hingegen ein speicherbasiertes Laufwerk mit `mdmfs` zu erstellen, wird dieser Befehl benutzt:

[source,shell]
....
# mdmfs -s 5m md1 /mnt
....

Wenn die Gerätenummer nicht angegeben wird, wählt `mdmfs` automatisch ein ungenutztes Gerät aus. Weitere Einzelheiten über `mdmfs` finden Sie in man:mdmfs[8].

[[snapshots]]
== Schnappschüsse von Dateisystemen

Zusammen mit crossref:cutting-edge[soft-updates,Soft Updates] bietet FreeBSD eine weitere Funktion: Schnappschüsse von Dateisystemen.

UFS-Schnappschüsse sind Dateien, die ein Abbild eines Dateisystems enthalten und müssen auf dem jeweiligen Dateisystem erstellt werden. Pro Dateisystem darf es maximal 20 Schnappschüsse, die im Superblock vermerkt werden, geben. Schnappschüsse bleiben erhalten, wenn das Dateisystem abgehangen, neu eingehangen oder das System neu gestartet wird. Wenn ein Schnappschuss nicht mehr benötigt wird, kann er mit man:rm[1] gelöscht werden. Es ist egal, in welcher Reihenfolge Schnappschüsse gelöscht werden. Es kann allerdings vorkommen, dass nicht der gesamte Speicherplatz wieder freigegeben wird, da ein anderer Schnappschuss einen Teil der entfernten Blöcke für sich beanspruchen kann.

Das unveränderliche `Snapshot`-Dateiflag wird nach der Erstellung des Snapshots von man:mksnap_ffs[8] gesetzt. Durch die Verwendung von man:unlink[1] ist es allerdings möglich, einen Schnappschuss zu löschen.

Schnappschüsse werden mit man:mount[8] erstellt. Das folgende Kommando legt einen Schnappschuss von [.filename]#/var# in [.filename]#/var/snapshot/snap# ab:

[source,shell]
....
# mount -u -o snapshot /var/snapshot/snap /var
....

Alternativ kann der Schnappschuss auch mit man:mksnap_ffs[8] erstellt werden.

[source,shell]
....
# mksnap_ffs /var /var/snapshot/snap
....

Um Schnappschüsse auf einem Dateisystem, beispielsweise [.filename]#/var# zu finden, kann man man:find[1] verwenden:

[source,shell]
....
# find /var -flags snapshot
....

Nachdem ein Schnappschuss erstellt wurde, können Sie ihn für verschiedene Zwecke benutzen:

* Sie können den Schnappschuss für die Datensicherung benutzen und ihn auf eine CD oder ein Band schreiben.
* Die Integrität des Schnappschusses kann mit man:fsck[8] geprüft werden. Wenn das Dateisystem zum Zeitpunkt der Erstellung des Schnappschusses in Ordnung war, sollte man:fsck[8] immer erfolgreich durchlaufen.
* Sie können den Schnappschuss mit man:dump[8] sichern. Sie erhalten dann eine konsistente Sicherung des Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des Schnappschusses gegeben ist. Der Schalter `-L` von man:dump[8] erstellt für die Sicherung einen Schnappschuss und entfernt diesen am Ende der Sicherung wieder.
* Sie können einen Schnappschuss in den Verzeichnisbaum einhängen und sich dann den Zustand des Dateisystems zu dem Zeitpunkt ansehen, an dem der Schnappschuss erstellt wurde. Der folgende Befehl hängt den Schnappschuss [.filename]#/var/snapshot/snap# ein:
+

[source,shell]
....
# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4
# mount -r /dev/md4 /mnt
....

Der eingefrorene Stand des [.filename]#/var#-Dateisystems ist nun unterhalb von [.filename]#/mnt# verfügbar. Mit Ausnahme der früheren Schnappschüsse, die als leere Dateien auftauchen, wird zu Beginn alles so aussehen, wie zum Zeitpunkt der Erstellung des Schnappschusses. Der Schnappschuss kann wie folgt abgehängt werden:

[source,shell]
....
# umount /mnt
# mdconfig -d -u 4
....

Weitere Informationen über Soft Updates und Schnappschüsse von Dateisystemen sowie technische Artikel finden Sie auf der http://www.mckusick.com/[Webseite von Marshall Kirk McKusick].

[[quotas]]
== Disk Quotas

Disk Quotas erlauben dem Administrator, den Plattenplatz und/oder die Anzahl der Dateien eines Benutzers oder der Mitglieder einer Gruppe, auf Dateisystemebene zu beschränken. Dadurch wird verhindert, dass ein Benutzer oder eine Gruppe von Benutzern den ganzen verfügbaren Plattenplatz belegt.

Dieser Abschnitt beschreibt die Konfiguration von Disk Quotas für UFS-Dateisysteme. Lesen Sie crossref:zfs[zfs-zfs-quota,"Dataset-, Benutzer- und Gruppenquotas"], wenn Sie Disk Quotas auf einem ZFS-Dateisystem einrichten möchten.

=== Disk Quotas aktivieren

Prüfen Sie zunächst, ob der FreeBSD-Kernel Disk Quotas unterstützt:

[source,shell]
....
% sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1
....

In diesem Beispiel zeigt die `1` an, das Quotas unterstützt werden. Falls `0` ausgegeben wird, fügen Sie folgende Zeile in die Kernelkonfigurationsdatei ein, und folgen Sie den Anweisungen in crossref:kernelconfig[kernelconfig,Konfiguration des FreeBSD-Kernels] um den Kernel zu aktualisieren:

[.programlisting]
....
options QUOTA
....

Als nächstes aktivieren Sie Disk Quotas in [.filename]#/etc/rc.conf#:

[.programlisting]
....
quota_enable="YES"
....

Normalerweise wird beim Booten die Integrität der Quotas auf allen Dateisystemen mit man:quotacheck[8] überprüft. Dieses Programm stellt sicher, dass die Quota-Datenbank mit den Daten auf einem Dateisystem übereinstimmt. Dies ist allerdings ein zeitraubender Prozess, der die Zeit, die das System zum Booten braucht, signifikant beeinflusst. Eine Variable in [.filename]#/etc/rc.config# erlaubt es, diesen Schritt zu überspringen:

[.programlisting]
....
check_quotas="NO"
....

Zuletzt muss noch [.filename]#/etc/fstab# bearbeitet werden, um die Plattenquotas auf Dateisystemebene zu aktivieren. Um Quotas pro Benutzer für ein Dateisystem zu aktivieren, geben Sie für dieses Dateisystem `userquota` im Feld Optionen von [.filename]#/etc/fstab# an. Zum Beispiel:

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota 1 2
....

Um Quotas für Gruppen einzurichten, verwenden Sie `groupquota`. Um Quotas für Benutzer und Gruppen einzurichten, trennen Sie die Optionen durch Kommata:

[.programlisting]
....
/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2
....

Quota-Dateien werden standardmäßig im Rootverzeichnis des Dateisystems unter [.filename]#quota.user# und [.filename]#quota.group# abgelegt. Weitere Informationen finden Sie in man:fstab[5]. Es wird nicht empfohlen, Quota-Dateien an anderen Stellen zu speichern.

Sobald die Konfiguration abgeschlossen ist, starten Sie das System neu. [.filename]#/etc/rc# wird dann automatisch die richtigen Kommandos aufrufen, um die Quota-Dateien für alle in [.filename]#/etc/rc.conf# definierten Quotas anzulegen.

Normalerweise brauchen die Kommandos man:quotacheck[8], man:quotaon[8] oder man:quotaoff[8] nicht von Hand aufgerufen werden, obwohl man die entsprechenden Seiten im Manual lesen sollte, um sich mit ihnen vertraut zu machen.

=== Setzen von Quota-Limits

Stellen Sie sicher, dass Quotas auch tatsächlich aktiviert sind:

[source,shell]
....
# quota -v
....

Für jedes Dateisystem, auf dem Quotas aktiviert sind, sollte eine Zeile mit der Plattenauslastung und den aktuellen Quota-Limits zu sehen sein.

Mit `edquota` können nun Quota-Limits zugewiesen werden.

Mehrere Möglichkeiten stehen zur Verfügung, um Limits für den Plattenplatz, den ein Benutzer oder eine Gruppe verbrauchen kann, oder die Anzahl der Dateien, die angelegt werden dürfen, festzulegen. Die Limits können auf dem Plattenplatz (Block-Quotas), der Anzahl der Dateien (Inode-Quotas) oder einer Kombination von beiden basieren. Jedes Limit wird weiterhin in zwei Kategorien geteilt: Hardlimits und Softlimits.

Ein Hardlimit kann nicht überschritten werden. Hat der Benutzer einmal ein Hardlimit erreicht, so kann er auf dem betreffenden Dateisystem keinen weiteren Platz mehr beanspruchen. Hat ein Benutzer beispielsweise ein Hardlimit von 500 Kilobytes auf einem Dateisystem und benutzt davon 490 Kilobyte, so kann er nur noch 10 weitere Kilobytes beanspruchen. Der Versuch, weitere 11 Kilobytes zu beanspruchen, wird fehlschlagen.

Softlimits können für eine befristete Zeit überschritten werden. Diese Frist beträgt in der Grundeinstellung eine Woche. Hat der Benutzer das Softlimit über die Frist hinaus überschritten, so wird das Softlimit in ein Hardlimit umgewandelt und der Benutzer kann keinen weiteren Platz mehr beanspruchen. Wenn er einmal das Softlimit unterschreitet, wird die Frist wieder zurückgesetzt.

Im folgenden Beispiel wird das Quota des Benutzerkonto `test` bearbeitet. Wenn `edquota` aufgerufen wird, wird der in `EDITOR` definierte Editor aufgerufen, um die Quota-Limts zu konfigurieren. Der Standard-Editor ist vi.

[source,shell]
....
# edquota -u test

Quotas for user test:

/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)
....

Für jedes Dateisystem, auf dem Quotas aktiv sind, sind zwei Zeilen zu sehen. Eine repräsentiert die Block-Quotas und die andere die Inode-Quotas. Um ein Limit zu modifizieren, ändern Sie einfach den angezeigten Wert. Um beispielsweise das Blocklimit von [.filename]#/usr# auf ein Softlimit von `500` und ein Hardlimit von `600` zu erhöhen, ändern Sie die Zeile wie folgt:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 500, hard = 600)
....

Die neuen Limits sind wirksam, sobald der Editor verlassen wird.

Manchmal ist es wünschenswert, die Limits für eine Reihe von Benutzern zu setzen. Dazu weisen Sie zunächst einem Benutzer das gewünschte Quota-Limit zu. Anschließend benutzen Sie `-p`, um das Quota auf einen bestimmten Bereich von Benutzer-IDs (UID) zu duplizieren. Der folgende Befehl dupliziert die Quota-Limits auf die UIDs `10000` bis `19999`:

[source,shell]
....
# edquota -p test 10000-19999
....

Weitere Informationen finden Sie in man:edquota[8].

=== Überprüfen von Quota-Limits und Plattennutzung

Um die Limits oder die Plattennutzung individueller Benutzer und Gruppen zu überprüfen, kann man:quota[1] benutzt werden. Ein Benutzer kann nur die eigenen Quotas und die Quotas der Gruppe, der er angehört untersuchen. Nur der Superuser darf sich alle Limits ansehen. Mit man:repquota[8] erhalten Sie eine Zusammenfassung von allen Limits und der Plattenausnutzung für alle Dateisysteme, auf denen Quotas aktiv sind.

In der Ausgabe von man:quota[1] werden Dateisysteme, auf denen ein Benutzer keinen Platz verbraucht, nicht angezeigt, auch wenn diesem Quotas zugewiesen wurden. Benutzen Sie `-v` um solche Dateisysteme ebenfalls anzuzeigen. Das folgende Beispiel zeigt die Ausgabe von `quota -v` für einen Benutzer, der Quota-Limits auf zwei Dateisystemen besitzt:

[.programlisting]
....
Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60
....

Im Dateisystem [.filename]#/usr# liegt der Benutzer momentan 15 Kilobytes über dem Softlimit von 50 Kilobytes und hat noch 5 Tage seiner Frist übrig. Der Stern `*` zeigt an, dass der Benutzer sein Limit überschritten hat.

=== Quotas über NFS

Quotas werden von dem Quota-Subsystem auf dem NFS-Server erzwungen. Der man:rpc.rquotad[8] Daemon stellt `quota` die Quota Informationen auf dem NFS-Client zur Verfügung, so dass Benutzer auf diesen Systemen ihre Quotas abfragen können.

Sie aktivieren `rpc.rquotad` auf dem NFS-Server, indem Sie das Zeichen `#` auf folgender Zeile in [.filename]##/etc/inetd.conf## entfernen:

[.programlisting]
....
rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad
....

Anschließend starten Sie `inetd` neu:

[source,shell]
....
# service inetd restart
....

[[disks-encrypting]]
== Partitionen verschlüsseln

FreeBSD bietet ausgezeichnete Möglichkeiten, Daten vor unberechtigten Zugriffen zu schützen. Wenn das Betriebssystem läuft, schützen Zugriffsrechte und vorgeschriebene Zugriffskontrollen (MAC) (siehe crossref:mac[mac,Verbindliche Zugriffskontrolle]) die Daten. Die Zugriffskontrollen des Betriebssystems schützen allerdings nicht vor einem Angreifer, der Zugriff auf den Rechner hat. Der Angreifer kann eine Festplatte in ein anderes System einbauen und dort die Daten analysieren.

Die für FreeBSD verfügbaren kryptografischen Subsysteme, GEOM Based Disk Encryption (`gbde`) und `geli` sind in der Lage, Daten auf Dateisystemen auch vor hoch motivierten Angreifern zu schützen, die über erhebliche Mittel verfügen. Dieser Schutz ist unabhängig von der Art und Weise, durch die ein Angreifer Zugang zu einer Festplatte oder zu einem Rechner erlangt hat. Im Gegensatz zu anderen Verschlüsselungsmethoden, bei denen einzelne Dateien verschlüsselt werden, verschlüsseln gbde und `geli` transparent ganze Dateisysteme. Auf der Festplatte werden dabei keine Daten im Klartext gespeichert.

Dieses Kapitel zeigt, wie ein verschlüsseltes Dateisystem unter FreeBSD erstellt wird. Zunächst wird der Ablauf für gbde beschrieben und anschließend das gleiche Beispiel für geli.

=== Plattenverschlüsselung mit gbde

Das Ziel von man:gbde[4] ist es, einen Angreifer vor eine große Herausforderung zu stellen, um an die Daten einer Festplatte zu gelangen. Falls jedoch der Rechner kompromittiert wurde, während er im Betrieb war und das Speichergerät aktiv verbunden war, oder wenn der Angreifer eine gültige Passphrase kennt, bietet dieses System keinen Schutz für die Daten der Festplatte. Daher ist es wichtig, für die physische Sicherheit zu sorgen, während das System im Betrieb ist. Außerdem muss die Passphrase für den Verschlüsselungsmechanismus geschützt werden.

man:gbde[4] besitzt einige Funktionen um die Daten, die in einem Sektor gespeichert sind, zu schützen. Es benutzt 128-Bit AES im CBC-Modus, um die Daten eines Sektors zu verschlüsseln. Jeder Sektor einer Festplatte wird mit einem anderen AES-Schlüssel verschlüsselt. Weitere Informationen zum kryptographischen Design und wie die Schlüssel für einen Sektor aus der gegebenen Passphrase ermittelt werden, finden Sie in man:gbde[4].

FreeBSD enthält ein Kernelmodul für gbde, das wie folgt geladen werden kann:

[source,shell]
....
# kldload geom_bde
....

Wenn Sie einen angepassten Kernel verwenden, stellen Sie sicher, dass folgende Zeile in der Kernelkonfigurationsdatei enthalten ist:

`options GEOM_BDE`

Das folgende Beispiel beschreibt, wie eine Partition auf einer neuen Festplatte verschlüsselt wird. Die Partition wird in [.filename]#/private# eingehangen.

[.procedure]
.Procedure: Eine Partition mit gbde verschlüsseln
. Installieren der Festplatte
+ 
Installieren Sie die Festplatte wie in <<disks-adding>> beschrieben. Im Beispiel wird die Partition [.filename]#/dev/ad4s1c# verwendet. Die Gerätedateien [.filename]#/dev/ad0s1*# sind Standard-Partitionen des FreeBSD-Systems.
+
[source,shell]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4
....

. Verzeichnis für gbde-Lock-Dateien anlegen
+
[source,shell]
....
# mkdir /etc/gbde
....
+ 
Die Lock-Dateien sind für den Zugriff von gbde auf verschlüsselte Partitionen notwendig. Ohne die Lock-Dateien können die Daten nur mit erheblichem manuellen Aufwand wieder entschlüsselt werden (dies wird auch von der Software nicht unterstützt). Jede verschlüsselte Partition benötigt eine gesonderte Lock-Datei.
. Vorbereiten der gbde-Partition
+ 
Eine von gbde benutzte Partition muss einmalig initialisiert werden, bevor sie benutzt werden kann. Das Programm öffnet eine Vorlage im Standard-Editor, um verschiedene Optionen zu konfigurieren. Setzen Sie `sector_size` auf `2048`, wenn Sie UFS benutzen:
+
[source,shell]
....
# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock
$FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]
....
+ 
Sobald die Änderungen gespeichert werden, wird der Benutzer zweimal aufgefordert, die zum Schutz der Daten verwendete Passphrase einzugeben. Die Passphrase muss beide Mal gleich eingegeben werden. Die Sicherheit der Daten hängt allein von der Qualität der gewählten Passphrase ab. Die Auswahl einer sicheren und leicht zu merkenden Passphrase wird auf der Webseite http://world.std.com/~reinhold/diceware.html[ http://world.std.com/~reinhold/diceware.html] beschrieben.
+ 
Bei der Initialisierung wird eine Lock-Datei für die gbde-Partition erstellt. In diesem Beispiel [.filename]#/etc/gbde/ad4s1c.lock#. Lock-Dateien müssen die Dateiendung ".lock" aufweisen, damit sie von [.filename]#/etc/rc.d/gbde#, dem Startskript von gbde, erkannt werden.
+
[CAUTION]
====

Lock-Dateien müssen immer zusammen mit den verschlüsselten Dateisystemen gesichert werden. Ohne die Lock-Datei können Sie allerdings nicht auf die verschlüsselten Daten zugreifen.
====

. Einbinden der verschlüsselten Partition in den Kernel
+
[source,shell]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+ 
Dieses Kommando fragt die Passphrase ab, die bei der Initialisierung der verschlüsselten Partition eingegeben wurde. Das neue verschlüsselte Gerät erscheint danach in [.filename]#/dev# als [.filename]#/dev/device_name.bde#:
+
[source,shell]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde
....

. Dateisystem auf dem verschlüsselten Gerät anlegen
+ 
Nachdem die verschlüsselte Partition im Kernel eingebunden ist, kann ein Dateisystem erstellt werden. Dieses Beispiel erstellt ein UFS-Dateisystem mit aktivierten Soft Updates. Achten Sie darauf, die Partition mit der Erweiterung [.filename]#*.bde# zu benutzen:
+
[source,shell]
....
# newfs -U -O2 /dev/ad4s1c.bde
....

. Einhängen der verschlüsselten Partition
+ 
Legen Sie einen Mountpunkt für das verschlüsselte Dateisystem an. Hängen Sie anschließend das Dateisystem ein:
+
[source,shell]
....
# mkdir /private
# mount /dev/ad4s1c.bde /private
....

. Überprüfen des verschlüsselten Dateisystems
+ 
Das verschlüsselte Dateisystem sollte jetzt erkannt und benutzt werden können:
+
[source,shell]
....
% df -H
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private
....

Nach jedem Neustart müssen verschlüsselte Dateisysteme dem Kernel wieder bekannt gemacht werden, auf Fehler überprüft werden und eingehangen werden. Für die dazu nötigen Schritte fügen Sie folgende Zeilen in [.filename]#/etc/rc.conf# hinzu:

[.programlisting]
....
gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"
....

Durch diese Argumente muss beim Systemstart auf der Konsole die Passphrase eingegeben werden. Erst nach Eingabe der korrekten Passphrase wird die verschlüsselte Partition automatisch in den Verzeichnisbaum eingehängt. Weitere Bootoptionen von gbde finden Sie in man:rc.conf[5].

[NOTE]
====
sysinstall ist nicht kompatibel mit gbde-verschlüsselten Geräten. Bevor sysinstall gestartet wird, müssen alle [.filename]#*.bde# Geräte vom Kernel getrennt werden, da sonst der Kernel bei der ersten Suche nach Geräten abstürzt. Um das verschlüsselte Gerät aus dem Beispiel zu trennen, benutzen Sie das folgende Kommando:

[source,shell]
....
# gbde detach /dev/ad4s1c
....

====

[[disks-encrypting-geli]]
=== Plattenverschlüsselung mit `geli`

Mit `geli` steht eine alternative kryptografische GEOM-Klasse zur Verfügung. Dieses Werkzeug unterstützt unterschiedliche Fähigkeiten und verfolgt einen anderen Ansatz für die Verschlüsselung. geli bietet die folgenden Funktionen:

* Die Nutzung des man:crypto[9]-Frameworks. Wenn das System über kryptografische Hardware verfügt, wird diese von `geli` automatisch verwendet.
* Die Unterstützung verschiedener kryptografischer Algorithmen, wie AES, Blowfish, und 3DES.
* Die Möglichkeit, die root-Partition zu verschlüsseln. Um auf die verschlüsselte root-Partition zugreifen zu können, muss beim Systemstart die Passphrase eingegeben werden.
* Erlaubt den Einsatz von zwei voneinander unabhängigen Schlüsseln.
* Es ist durch einfache Sektor-zu-Sektor-Verschlüsselung sehr schnell.
* Die Möglichkeit, Master-Keys zu sichern und wiederherzustellen. Wenn ein Benutzer seinen Schlüssel zerstört, kann er über seinen zuvor gesicherten Schlüssel wieder auf seine Daten zugreifen.
* `geli` erlaubt es, Platten mit einem zufälligen Einmal-Schlüssel einzusetzen, was für Swap-Partitionen und temporäre Dateisysteme interessant ist.

Weitere Funktionen und Anwendungsbeispiele finden Sie in man:geli[8].

Das folgende Beispiel beschreibt, wie eine Schlüsseldatei erzeugt wird, die als Teil des Master-Keys für den Verschlüsselungs-Provider verwendet wird, der unter [.filename]#/private# in den Verzeichnisbaum eingehängt wird. Die Schlüsseldatei liefert zufällige Daten, die für die Verschlüsselung des Master-Keys benutzt werden. Zusätzlich wird der Master-Key durch eine Passphrase geschützt. Die Sektorgröße des Providers beträgt 4 KB. Das Beispiel beschreibt, wie Sie einen `geli`-Provider aktivieren, ein vom ihm verwaltetes Dateisystem erzeugen, es mounten, mit ihm arbeiten und wie Sie es schließlich wieder unmounten und den Provider deaktivieren.

[.procedure]
.Procedure: Eine Partition mit `geli` verschlüsseln
. Laden der `geli`-Unterstützung
+ 
Die Unterstützung für `geli` wird über ein ladbares Kernelmodul zur Verfügung gestellt. Damit das Modul automatisch beim Booten geladen wird, fügen Sie folgende Zeile in [.filename]#/boot/loader.conf# ein:
+
[.programlisting]
....
geom_eli_load="YES"
....
+ 
Um das Modul direkt zu laden:
+
[source,shell]
....
# kldload geom_eli
....
+ 
Stellen Sie bei einer angepassten Kernelkonfigurationsdatei sicher, dass diese Zeilen enthalten sind:
+
[.programlisting]
....
options GEOM_ELI
device crypto
....

. Erzeugen des Master-Keys
+ 
Die folgenden Befehle erzeugen einen Master-Key, mit dem alle Daten verschlüsselt werden. Dieser Schlüssel kann niemals geändert werden. Anstatt ihn direkt zu benutzen, wird er mit einem oder mehrere Schlüsseln verschlüsselt. Die Schlüssel bestehen aus einer optionalen Kombination von zufälligen Bytes aus einer Datei, [.filename]#/root/da2.key#, und/oder einer Passphrase. In diesem Fall ist die Datenquelle der Schlüsseldatei [.filename]#/dev/random#. Dieser Befehl konfiguriert auch die Sektorgröße des Providers ([.filename]#/dev/da2.eli#) mit 4 KB, um eine bessere Leistung zu erzielen:
+
[source,shell]
....
# dd if=/dev/random of=/root/da2.key bs=64 count=1
# geli init -K /root/da2.key -s 4096 /dev/da2
Enter new passphrase:
Reenter new passphrase:
....
+ 
Es ist nicht zwingend nötig, sowohl eine Passphrase als auch eine Schlüsseldatei zu verwenden. Die einzelnen Methoden können auch unabhängig voneinander eingesetzt werden.
+ 
Wird für die Schlüsseldatei "-" angegeben, wird dafür die Standardeingabe verwendet. Das folgende Kommando erzeugt beispielsweise drei Schlüsseldateien:
+
[source,shell]
....
# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2
....

. Aktivieren des Providers mit dem erzeugten Schlüssel
+ 
Um den Provider zu aktivieren, geben Sie die Schlüsseldatei, den Namen des Laufwerks und die Passphrase an:
+
[source,shell]
....
# geli attach -k /root/da2.key /dev/da2
Enter passphrase:
....
+ 
Dadurch wird ein neues Gerät mit der Erweiterung [.filename]#.eli# angelegt:
+
[source,shell]
....
# ls /dev/da2*
/dev/da2  /dev/da2.eli
....

. Das neue Dateisystem erzeugen
+ 
Als nächstes muss das Gerät mit dem UFS-Dateisystem formatiert und an einen vorhandenen Mountpunkt eingehängt werden:
+
[source,shell]
....
# dd if=/dev/random of=/dev/da2.eli bs=1m
# newfs /dev/da2.eli
# mount /dev/da2.eli /private
....
+ 
Das verschlüsselte Dateisystem sollte jetzt erkannt und benutzt werden können:
+
[source,shell]
....
# df -H
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private
....

Wenn Sie nicht mehr mit dem verschlüsselten Dateisystem arbeiten und die unter [.filename]#/private# eingehängte Partition daher nicht mehr benötigen, sollten Sie diese unmounten und den `geli`-Verschlüsselungs-Provider wieder deaktivieren:

[source,shell]
....
# umount /private
# geli detach da2.eli
....

FreeBSD verfügt über ein [.filename]#rc.d#-Skript, das dass Einhängen von verschlüsselten Geräten beim Booten deutlich vereinfacht. Für dieses Beispiel, fügen Sie folgende Zeilen in [.filename]#/etc/rc.conf# hinzu:

[.programlisting]
....
geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"
....

Dies konfiguriert [.filename]#/dev/da2# als `geli`-Provider mit dem Master-Key [.filename]#/root/da2.key#. Das System wird den Provider automatisch deaktivieren, bevor es heruntergefahren wird. Während des Startvorgangs fordert das Skript die Passphrase an, bevor der Provider aktiviert wird. Vor und nach der Eingabeaufforderung für die Passphrase werden noch weitere Kernelmeldungen angezeigt. Achten Sie sorgfältig auf die Eingabeaufforderung zwischen den anderen Meldungen, falls es zu Problemen beim Startvorgang kommt. Sobald die richtige Passphrase eingegeben wurde, wird der Provider aktiviert. Anschließend werden die Dateisysteme gemäß [.filename]#/etc/fstab# eingehängt. Lesen Sie crossref:basics[mount-unmount,“Anhängen und Abhängen von Dateisystemen”] wenn Sie wissen möchten, wie Sie ein Dateisystem konfigurieren, sodass es beim booten automatisch gestartet wird.

[[swap-encrypting]]
== Den Auslagerungsspeicher verschlüsseln

Wie die Verschlüsselung von Partitionen, wird auch der Auslagerungsspeicher verschlüsselt, um sensible Informationen zu schützen. Stellen Sie sich eine Anwendung vor, die mit Passwörtern umgeht. Solange sich diese Passwörter im Arbeitsspeicher befinden, werden sie nicht auf die Festplatte geschrieben und nach einem Neustart gelöscht. Falls FreeBSD jedoch damit beginnt Speicher auszulagern, um Platz für andere Anwendungen zu schaffen, können die Passwörter unverschlüsselt auf die Festplatte geschrieben werden. Die Verschlüsselung des Auslagerungsspeichers kann in solchen Situationen Abhilfe schaffen.

Dieser Abschnitt zeigt die Konfiguration eines verschlüsselten Auslagerungsspeichers mittels man:gbde[8] oder man:geli[8]. In den Beispielen repräsentiert [.filename]#/dev/ada0s1b# die Swap-Partition.

=== Konfiguration eines verschlüsselten Auslagerungsspeichers

Swap-Partitionen werden standardmäßig nicht verschlüsselt. Sie sollten daher alle sensiblen Daten im Auslagerungsspeicher löschen, bevor Sie fortfahren. Führen Sie folgenden Befehl aus, um die Swap-Partition mit Zufallsdaten zu überschreiben:

[source,shell]
....
# dd if=/dev/random of=/dev/ada0s1b bs=1m
....

Um den Auslagerungsspeicher mit man:gbde[8] zu verschlüsseln, fügen Sie in [.filename]#/etc/fstab# das Suffix `.bde` an den Gerätenamen der Swap-Partition hinzu:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.bde         none            swap    sw              0       0
....

Wenn Sie man:geli[8] benutzen, verwenden Sie stattdessen das Suffix `.eli`, um den Auslagerungsspeicher zu verschlüsseln:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.eli         none            swap    sw              0       0
....

In der Voreinstellung verschlüsselt man:geli[8] mit dem AES-Algorithmus und einer Schlüssellänge von 128 Bit. Diese Voreinstellungen sind in der Regel ausreichend, können jedoch im Options-Feld in [.filename]#/etc/fstab# angepasst werden. Mögliche Optionen sind:

aalgo::
Der Algorithmus für die Prüfung der Datenintegrität. Dieser wird benutzt um sicherzustellen, dass die verschlüsselten Daten nicht manipuliert wurden. Eine Liste der unterstützten Algorithmen finden Sie in man:geli[8].

ealgo::
Der Verschlüsselungsalgorithmus, der verwendet wird um die Daten zu schützen. Eine Liste der unterstützten Algorithmen finden Sie in man:geli[8].

keylen::
Die Länge des Schlüssels für den Verschlüsselungsalgorithmus. In man:geli[8] können Sie lesen, welche Schlüssellängen von welchem Algorithmus unterstützt werden.

sectorsize::
Die Größe, in der die Datenblöcke aufgeteilt werden, bevor sie verschlüsselt werden. Größere Blöcke erhöhen die Leistung auf Kosten des Speicherverbrauchs. Die empfohlene Größe beträgt 4096 Byte.

Dieses Beispiel konfiguriert eine verschlüsselte Swap-Partition mit dem Blowfish-Algorithmus, einer Schlüssellänge von 128 Bit und einer Sektorgröße von 4 KB:

[.programlisting]
....
# Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0
....

=== Überprüfung des verschlüsselten Auslagerungsspeichers

Nachdem das System neu gestartet wurde, kann die korrekte Funktion des verschlüsselten Auslagerungsspeichers mit `swapinfo` geprüft werden.

Wenn Sie man:gbde[8] einsetzen, erhalten Sie eine Meldung ähnlich der folgenden:

[source,shell]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde    542720        0   542720     0%
....

Wenn Sie man:geli[8] einsetzen, erhalten Sie hingegen eine Ausgabe ähnlich der folgenden:

[source,shell]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli    542720        0   542720     0%
....

[[disks-hast]]
== Highly Available Storage (HAST)

Hochverfügbarkeit ist eine der Hauptanforderungen von ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher ist eine Schlüsselkomponente in solchen Umgebungen. Highly Available STorage (HAST) ist ein Framework in FreeBSD, welches die transparente Speicherung der gleichen Daten über mehrere physikalisch getrennte Maschinen ermöglicht, die über ein TCP/IP-Netzwerk verbunden sind. HAST kann als ein netzbasiertes RAID1 (Spiegel) verstanden werden und ist dem DRBD(R)-Speichersystem der GNU/Linux(R)-Plattform ähnlich. In Kombination mit anderen Hochverfügbarkeitseigenschaften von FreeBSD wie CARP, ermöglicht es HAST, hochverfügbare Speichercluster zu bauen, die in der Lage sind, Hardwareausfällen zu widerstehen.

Die Hauptmerkmale von HAST sind:

* Es kann zur Maskierung von I/O-Fehlern auf lokalen Festplatten eingesetzt werden.
* Dateisystem-unabhängig, was es erlaubt, jedes von FreeBSD unterstützte Dateisystem zu verwenden.
* Effiziente und schnelle Resynchronisation: es werden nur die Blöcke synchronisiert, die während der Ausfallzeit eines Knotens geändert wurden.
* Es kann in einer bereits bestehenden Umgebung eingesetzt werden, um zusätzliche Redundanz zu erreichen.
* Zusammen mit CARP, Heartbeat, oder anderen Werkzeugen, ist es möglich, ein robustes und dauerhaftes Speichersystem zu bauen.

Nachdem Sie diesen Abschnitt gelesen haben, werden Sie folgendes wissen:

* Was HAST ist, wie es funktioniert und welche Eigenschaften es besitzt.
* Wie man HAST unter FreeBSD aufsetzt und verwendet.
* Wie man CARP und man:devd[8] kombiniert, um ein robustes Speichersystem zu bauen.

Bevor Sie diesen Abschnitt lesen, sollten Sie:

* die Grundlagen von UNIX(R) und FreeBSD verstanden haben (crossref:basics[basics,Grundlagen des FreeBSD Betriebssystems]).
* wissen, wie man Netzwerkschnittstellen und andere Kernsysteme von FreeBSD konfiguriert (crossref:config[config-tuning,Konfiguration und Tuning]).
* ein gutes Verständnis der FreeBSD-Netzwerkfunktionalität besitzen (crossref:partiv[network-communication,"Netzwerke"]).

Das HAST-Projekt wurde von der FreeBSD Foundation mit Unterstützung der http://www.omc.net/[ OMCnet Internet Service GmbH] und http://www.transip.nl/[TransIP BV] gesponsert.

=== HAST im Einsatz

HAST bietet eine synchrone Replikation auf Blockebene zwischen zwei Maschinen: einem `primary`, auch bekannt als `master` Knoten, sowie dem `secondary`, oder `slave` Knoten. Diese beiden Maschinen zusammen werden als Cluster bezeichnet.

Da HAST in einer primär-sekundär-Konfiguration funktioniert, ist immer nur ein Knoten des Clusters zu jeder Zeit aktiv. Der primäre Knoten, auch _active_ genannt, ist derjenige, der alle I/O-Anfragen verarbeitet, die an die HAST-Schnittstelle gesendet werden. Der sekundäre Knoten wird automatisch vom primären Knoten aus synchronisiert.

Die physischen Komponenten des HAST-Systems sind die lokale Platte am Primärknoten und die entfernte Platte am Sekundärknoten.

HAST arbeitet synchron auf Blockebene, was es für Dateisysteme und Anwendungen transparent macht. HAST stellt gewöhnliche GEOM-Provider in [.filename]#/dev/hast/# für die Verwendung durch andere Werkzeuge oder Anwendungen zur Verfügung. Es gibt keinen Unterschied zwischen dem Einsatz von HAST bereitgestellten Geräten und herkömmlichen Platten oder Partitionen.

Jede Schreib-, Lösch- oder Entleerungsoperation wird an die lokale und über TCP/IP zu der entfernt liegenden Platte gesendet. Jede Leseoperation wird von der lokalen Platte durchgeführt, es sei denn, die lokale Platte ist nicht aktuell oder es tritt ein I/O-Fehler auf. In solchen Fällen wird die Leseoperation an den Sekundärknoten geschickt.

HAST versucht, eine schnelle Fehlerbereinigung zu gewährleisten. Aus diesem Grund ist es wichtig, die Synchronisationszeit nach dem Ausfall eines Knotens zu reduzieren. Um eine schnelle Synchronisation zu ermöglichen, verwaltet HAST eine Bitmap von unsauberen Bereichen auf der Platte und synchronisiert nur diese während einer regulären Synchronisation (mit Ausnahme der initialen Synchronisation).

Es gibt viele Wege, diese Synchronisation zu behandeln. HAST implementiert mehrere Replikationsarten, um unterschiedliche Methoden der Synchronisation zu realisieren:

* _memsync_: Dieser Modus meldet Schreiboperationen als vollständig, wenn die lokale Schreiboperation beendet ist und der entfernt liegende Knoten die Ankunft der Daten bestätigt hat, jedoch bevor die Daten wirklich gespeichert wurden. Die Daten werden auf dem entfernt liegenden Knoten direkt nach dem Senden der Bestätigung gespeichert. Dieser Modus ist dafür gedacht, Latenzen zu verringern und zusätzlich eine gute Verlässlichkeit zu bieten. In der Voreinstellung wird dieser Modus benutzt.
* _fullsync_: Dieser Modus meldet Schreiboperationen als vollständig, wenn sowohl die lokale, als auch die entfernte Schreiboperation abgeschlossen wurde. Dies ist der sicherste und zugleich der langsamste Replikationsmodus.
* _async_: Dieser Modus meldet Schreiboperationen als vollständig, wenn lokale Schreibvorgänge abgeschlossen wurden. Dies ist der schnellste und gefährlichste Replikationsmodus. Er sollte nur verwendet werden, wenn die Latenz zu einem entfernten Knoten bei einer Replikation zu hoch ist für andere Modi.

=== HAST-Konfiguration

Das HAST-Framework besteht aus mehreren Komponenten:

* Dem man:hastd[8]-Daemon, welcher für Datensynchronisation verantwortlich ist. Wenn dieser Daemon gestartet wird, wird automatisch `geom_gate.ko` geladen.
* Dem man:hastctl[8] Management-Werkzeug.
* Der Konfigurationsdatei man:hast.conf[5]. Diese Datei muss vorhanden sein, bevor hastd gestartet wird.

Alternativ lässt sich die `GEOM_GATE`-Unterstützung in den Kernel statisch einbauen, indem folgende Zeile zur Kernelkonfigurationsdatei hinzugefügt wird. Anschließend muss der Kernel, wie in crossref:kernelconfig[kernelconfig,Konfiguration des FreeBSD-Kernels ] beschrieben, neu gebaut werden:

[.programlisting]
....
options	GEOM_GATE
....

Das folgende Beispiel beschreibt, wie man zwei Knoten als master-slave / primary-secondary mittels HAST konfiguriert, um Daten zwischen diesen beiden auszutauschen. Die Knoten werden als `hasta` mit der IP-Adresse `172.16.0.1` und `hastb` mit der IP-Adresse `172.16.0.2` bezeichnet. Beide Knoten besitzen eine dedizierte Festplatte [.filename]#/dev/ad6# mit der gleichen Größe für den HAST-Betrieb. Der HAST-Pool, manchmal auch Ressource genannt, oder der GEOM-Provider in [.filename]#/dev/hast/# wird als [.filename]#test# bezeichnet.

Die Konfiguration von HAST wird in [.filename]#/etc/hast.conf# vorgenommen. Diese Datei sollte auf beiden Knoten gleich sein. Die einfachste Konfiguration ist folgende:

[.programlisting]
....
resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}
....

Fortgeschrittene Konfigurationsmöglichkeiten finden Sie in man:hast.conf[5].

[TIP]
====

Es ist ebenfalls möglich, den Hostnamen in den `remote`-Anweisungen zu verwenden, falls die Rechner aufgelöst werden können und in [.filename]#/etc/hosts#, oder im lokalen DNS definiert sind.
====

Sobald die Konfiguration auf beiden Rechnern vorhanden ist, kann ein HAST-Pool erstellt werden. Lassen Sie diese Kommandos auf beiden Knoten ablaufen, um die initialen Metadaten auf die lokale Platte zu schreiben und starten Sie anschließend man:hastd[8]:

[source,shell]
....
# hastctl create test
# service hastd onestart
....

[NOTE]
====
Es ist _nicht_ möglich, GEOM-Provider mit einem bereits bestehenden Dateisystem zu verwenden, um beispielsweise einen bestehenden Speicher in einen von HAST verwalteten Pool zu konvertieren. Dieses Verfahren muss einige Metadaten auf den Provider schreiben und dafür würde nicht genug freier Platz zur Verfügung stehen.
====

Die Rolle eines HAST Knotens, `primary` oder `secondary`, wird vom einem Administrator, oder einer Software wie Heartbeat, mittels man:hastctl[8] festgelegt. Auf dem primären Knoten `hasta` geben Sie diesen Befehl ein:

[source,shell]
....
# hastctl role primary test
....

Geben Sie folgendes Kommando auf dem sekundären Knoten `hastb` ein:

[source,shell]
....
# hastctl role secondary test
....

Überprüfen Sie das Ergebnis mit `hastctl` auf beiden Knoten:

[source,shell]
....
# hastctl status test
....

Überprüfen Sie die `status`-Zeile. Wird hier `degraded` angezeigt, dann ist etwas mit der Konfigurationsdatei nicht in Ordnung. Auf jedem Konten sollte `complete` angezeigt werden, was bedeutet, dass die Synchronisation zwischen den beiden Knoten gestartet wurde. Die Synchronisierung ist abgeschlossen, wenn `hastctl status` meldet, dass die `dirty`-Bereiche 0 Bytes betragen.

Der nächste Schritt ist, ein Dateisystem auf dem GEOM-Provider anzulegen und dieses ins System einzuhängen. Dies muss auf dem `primary`-Knoten durchgeführt werden. Die Erstellung des Dateisystems kann ein paar Minuten dauern, abhängig von der Größe der Festplatte. Dieses Beispiel erstellt ein UFS-Dateisystem auf [.filename]#/dev/hast/test#:

[source,shell]
....
# newfs -U /dev/hast/test
# mkdir /hast/test
# mount /dev/hast/test /hast/test
....

Sobald das HAST-Framework richtig konfiguriert wurde, besteht der letzte Schritt nun darin, sicherzustellen, dass HAST während des Systemstarts automatisch gestartet wird. Fügen Sie diese Zeile in [.filename]#/etc/rc.conf# hinzu:

[.programlisting]
....
hastd_enable="YES"
....

==== Failover-Konfiguration

Das Ziel dieses Beispiels ist, ein robustes Speichersystem zu bauen, welches Fehlern auf einem beliebigen Knoten widerstehen kann. Wenn der `primary`-Knoten ausfällt, ist der `secondary`-Knoten da, um nahtlos einzuspringen, das Dateisystem zu prüfen, einzuhängen und mit der Arbeit fortzufahren, ohne dass auch nur ein einzelnes Bit an Daten verloren geht.

Um diese Aufgabe zu bewerkstelligen, wird das Common Address Redundancy Protocol (CARP) benutzt, welches ein automatisches Failover auf der IP-Schicht ermöglicht. CARP erlaubt es mehreren Rechnern im gleichen Netzsegment, die gleiche IP-Adresse zu verwenden. Setzen Sie CARP auf beiden Knoten des Clusters anhand der Dokumentation in crossref:advanced-networking[carp,“Common Address Redundancy Protocol (CARP)”] auf. In diesem Beispiel hat jeder Knoten seine eigene Management IP-Adresse und die geteilte IP-Adresse _172.16.0.254_. Der primäre HAST-Knoten des Clusters muss der CARP-Masterknoten sein.

Der HAST-Pool, welcher im vorherigen Abschnitt erstellt wurde, ist nun bereit für den Export über das Netzwerk auf den anderen Rechner. Dies kann durch den Export über NFS oder Samba erreicht werden, indem die geteilte IP-Adresse _172.16.0.254_ verwendet wird. Das einzige ungelöste Problem ist der automatische Failover, sollte der primäre Knoten einmal ausfallen.

Falls die CARP-Schnittstelle aktiviert oder deaktiviert wird, generiert das FreeBSD-Betriebssystem ein man:devd[8]-Ereignis, was es ermöglicht, Zustandsänderungen auf den CARP-Schnittstellen zu überwachen. Eine Zustandsänderung auf der CARP-Schnittstelle ist ein Indiz dafür, dass einer der Knoten gerade ausgefallen oder wieder verfügbar ist. Diese Zustandsänderungen machen es möglich, ein Skript zu starten, welches automatisch den HAST-Failover durchführt.

Um Zustandsänderungen auf der CARP-Schnittstelle abzufangen, müssen diese Zeilen in [.filename]#/etc/devd.conf# auf jedem Knoten hinzugefügt werden:

[.programlisting]
....
notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};
....

[NOTE]
====
Wenn auf dem System FreeBSD 10 oder höher eingesetzt wird, ersetzen Sie [.filename]#carp0# durch den Namen der konfigurierten Schnittstelle für CARP.
====

Starten Sie man:devd[8] auf beiden Knoten neu, um die neue Konfiguration wirksam werden zu lassen:

[source,shell]
....
# service devd restart
....

Wenn die Schnittstelle aktiviert oder deaktiviert wird, erzeugt das System eine Meldung, was es dem man:devd[8]-Subsystem ermöglicht, ein automatisches Failover-Skript zu starten, [.filename]#/usr/local/sbin/carp-hast-switch#. Weitere Informationen zu dieser Konfiguration finden Sie in man:devd.conf[5].

Es folgt ein Beispiel für ein automatisches Failover-Skript:

[.programlisting]
....
#!/bin/sh

# Original script by Freddie Cash <fjwcash@gmail.com>
# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>
# and Viktor Petersson <vpetersson@wireload.net>

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" > /dev/null 2>&1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] && break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."

		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2>&1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac
....

Im Kern führt das Skript die folgenden Aktionen durch, sobald ein Knoten zum Master wird:

* Es ernennt den HAST-Pool als den primären für einen gegebenen Knoten.
* Es prüft das Dateisystem, dass auf dem HAST-Pool erstellt wurde.
* Es hängt den Pool ins System ein.

Wenn ein Knoten zum Sekundären ernannt wird:

* Hängt es den HAST-Pool aus dem Dateisystem aus.
* Degradiert es den HAST-Pool zum sekundären.

[CAUTION]
====

Dieses Skript ist nur ein Beispiel für eine mögliche Lösung. Es behandelt nicht alle möglichen Szenarien, die auftreten können und sollte erweitert bzw. abgeändert werden, so dass z.B. benötigte Dienste gestartet oder gestoppt werden.
====

[TIP]
====

Für dieses Beispiel wurde ein UFS-Dateisystem verwendet. Um die Zeit für die Wiederherstellung zu verringern, kann ein UFS mit Journal oder ein ZFS-Dateisystem benutzt werden.
====

Weitere detaillierte Informationen mit zusätzlichen Beispielen können unter http://wiki.FreeBSD.org/HAST[ http://wiki.FreeBSD.org/HAST] abgerufen werden.

=== Fehlerbehebung

HAST sollte generell ohne Probleme funktionieren. Jedoch kann es, wie bei jeder anderen Software auch, zu gewissen Zeiten sein, dass sie sich nicht so verhält wie angegeben. Die Quelle dieser Probleme kann unterschiedlich sein, jedoch sollte als Faustregel gewährleistet werden, dass die Zeit für alle Knoten im Cluster synchron läuft.

Für die Fehlersuche bei HAST sollte die Anzahl an Debugging-Meldungen von man:hastd[8] erhöht werden. Dies kann durch das Starten von `hastd` mit `-d` erreicht werden. Diese Option kann mehrfach angegeben werden, um die Anzahl an Meldungen weiter zu erhöhen. Sie sollten ebenfalls die Verwendung von `-F` in Erwägung ziehen, was `hastd` im Vordergrund startet.

[[disks-hast-sb]]
==== Auflösung des Split-brain-Zustands

`split-brain` bezeichnet eine Situation, in der beide Knoten des Clusters nicht in der Lage sind, miteinander zu kommunizieren und dadurch beide als primäre Knoten fungieren. Dies ist ein gefährlicher Zustand, weil es beiden Knoten erlaubt ist, Änderungen an den Daten vorzunehmen, die miteinander nicht in Einklang gebracht werden können. Diese Situation muss vom Systemadministrator manuell bereinigt werden.

Der Administrator muss entscheiden, welcher Knoten die wichtigeren Änderungen besitzt, oder die Zusammenführung manuell durchführen. Anschließend kann HAST die volle Synchronisation mit dem Knoten durchführen, der die beschädigten Daten enthält. Um dies zu tun, geben Sie folgende Befehle auf dem Knoten ein, der neu synchronisiert werden muss:

[source,shell]
....
# hastctl role init test
# hastctl create test
# hastctl role secondary test
....
