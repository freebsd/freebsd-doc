---
title: Kapitel 26. Serielle Datenübertragung
part: Teil IV. Netzwerke
prev: books/handbook/partiv
next: books/handbook/ppp-and-slip
showBookMenu: true
weight: 31
path: "/books/handbook/serialcomms/"
---

[[serialcomms]]
= Serielle Datenübertragung
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 26
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/serialcomms/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[serial-synopsis]]
== Übersicht

UNIX(R) Systeme unterstützten schon immer die serielle Datenübertragung. Tatsächlich wurden Ein- und Ausgaben auf den ersten UNIX(R) Maschinen über serielle Leitungen durchgeführt. Seit der Zeit, in der ein durchschnittlicher Terminal aus einem seriellen Drucker mit 10 Zeichen/Sekunde und einer Tastatur bestand, hat sich viel verändert. Dieses Kapitel behandelt einige Möglichkeiten, serielle Datenübertragung unter FreeBSD zu verwenden.

Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes wissen:

* Wie Sie Terminals an ein FreeBSD-System anschließen.
* Wie Sie sich mit einem Modem auf entfernte Rechner einwählen.
* Wie Sie entfernten Benutzern erlauben, sich mit einem Modem in ein FreeBSD-System einzuwählen.
* Wie Sie ein FreeBSD-System über eine serielle Konsole booten.

Bevor Sie dieses Kapitel lesen, sollten Sie

* einen crossref:kernelconfig[kernelconfig,angepassten Kernel konfigurieren und installieren] können.
* crossref:basics[basics,Berechtigungen und Prozesse unter FreeBSD] verstehen.
* Zugriff auf die Handbücher der seriellen Komponenten haben, die mit FreeBSD verwendet werden sollen.

[[serial]]
== Begriffe und Hardware

Die folgenden Begriffe werden oft verwendet, wenn es um serielle Kommunikation geht:

bps::
Bits pro Sekunde  (bps) ist die Einheit für die Übertragungsgeschwindigkeit.

DEE (DTE)::
Eine Datenendeinrichtung (Data Terminal Equipment) ist einer der beiden Endpunkte bei der seriellen Kommunikation. Zum Beispiel ein Computer.

DÜE (DCE)::
Datenübertragungseinrichtung  (Data Communications Equipment) ist der andere Endpunkt bei der seriellen Kommunikation. Typischerweise ein Modem.

RS-232::
Der originale Standard, der serielle Datenübertragung definiert. Er wird heutzutage als TIA-232  bezeichnet.

In diesem Abschnitt wird der Begriff "Baud" nicht für Übertragungsgeschwindigkeiten gebraucht. Baud bezeichnet elektrische Zustandswechsel pro Zeiteinheit, die Taktfrequenz, während "bps" der _richtige_ Begriff für die Übertragungsgeschwindigkeit ist.

Um ein Modem oder einen Terminal an ein FreeBSD-System anzuschließen, muss der Computer über eine serielle Schnittstelle verfügen. Zusätzlich wird das passende Kabel benötigt, um das Gerät mit der Schnittstelle zu verbinden. Benutzer, die mit seriellen Geräten und den nötigen Kabeln schon vertraut sind, können diesen Abschnitt überspringen.

[[term-cables-null]]
=== Kabel und Schnittstellen

Es gibt verschiedene serielle Kabel. Die zwei häufigsten sind Nullmodemkabel und Standard-RS-232-Kabel. Die Dokumentation der Hardware sollte beschreiben, welcher Kabeltyp benötigt wird.

Ein Nullmodemkabel verbindet einige Signale, wie die Betriebserde, eins zu eins, andere Signale werden getauscht: Die Sende- und Empfangsleitungen werden zum Beispiel gekreuzt.

Nullmodemkabel für die Anbindung eines Terminals können auch selbst hergestellt werden. Die folgende Tabelle enthält die <<serialcomms-signal-names,Signalnamen>> von RS-232C sowie die Pinbelegung für einen Stecker vom Typ DB-25. Obwohl der Standard eine direkte Verbindung von Pin 1 zu Pin 1 (_Protective Ground_) vorschreibt, ist diese in vielen Fällen nicht vorhanden. Einige Terminals benötigen nur die Pins 2, 3 und 7 für eine korrekte Funktion, während andere eine unterschiedliche Konfiguration als die in den folgenden Beispielen gezeigte benötigen.

.Nullmodemkabel vom Typ DB-25-zu-DB-25
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Signal
<| Pin #
<| 
<| Pin #
<| Signal

|SG
|7
|verbunden mit
|7
|SG

|TD
|2
|verbunden mit
|3
|RD

|RD
|3
|verbunden mit
|2
|TD

|RTS
|4
|verbunden mit
|5
|CTS

|CTS
|5
|verbunden mit
|4
|RTS

|DTR
|20
|verbunden mit
|6
|DSR

|DTR
|20
|verbunden mit
|8
|DCD

|DSR
|6
|verbunden mit
|20
|DTR

|DCD
|8
|verbunden mit
|20
|DTR
|===

Die folgenden zwei Schemata werden heutzutage ebenfalls häufig eingesetzt:

.Nullmodemkabel vom Typ DB-9-zu-DB-9
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Signal
<| Pin #
<| 
<| Pin #
<| Signal

|RD
|2
|verbunden mit
|3
|TD

|TD
|3
|verbunden mit
|2
|RD

|DTR
|4
|verbunden mit
|6
|DSR

|DTR
|4
|verbunden mit
|1
|DCD

|SG
|5
|verbunden mit
|5
|SG

|DSR
|6
|verbunden mit
|4
|DTR

|DCD
|1
|verbunden mit
|4
|DTR

|RTS
|7
|verbunden mit
|8
|CTS

|CTS
|8
|verbunden mit
|7
|RTS
|===

.Nullmodemkabel vom Typ DB-9-zu-DB-25
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Signal
<| Pin #
<| 
<| Pin #
<| Signal

|RD
|2
|verbunden mit
|2
|TD

|TD
|3
|verbunden mit
|3
|RD

|DTR
|4
|verbunden mit
|6
|DSR

|DTR
|4
|verbunden mit
|8
|DCD

|SG
|5
|verbunden mit
|7
|SG

|DSR
|6
|verbunden mit
|20
|DTR

|DCD
|1
|verbunden mit
|20
|DTR

|RTS
|7
|verbunden mit
|5
|CTS

|CTS
|8
|verbunden mit
|4
|RTS
|===

[NOTE]
====
Wird ein Pin eines Kabels mit zwei Pins des anderen Kabels verbunden, werden dazu in der Regel zuerst die beiden Pins mit einem kurzem Draht verbunden. Danach wird dieser Draht mit dem Pin des anderen Endes verbunden.
====

Die eben besprochenen Schemata scheinen die beliebtesten zu sein. Weitere Varianten verbinden SG mit SG, TD mit RD, RTS und CTS mit DCD, DTR mit DSR, und umgekehrt.

Ein Standard-RS-232C-Kabel verbindet alle Signale direkt. Das Signal "Transmitted Data" wird mit dem Signal "Transmitted Data" der Gegenstelle verbunden. Dieses Kabel wird benötigt, um ein Modem mit einem FreeBSD-System zu verbinden. Manche Terminals benötigen dieses Kabel ebenfalls.

Über serielle Schnittstellen werden Daten zwischen dem FreeBSD-System und dem Terminal übertragen. Dieser Abschnitt beschreibt die verschiedenen Schnittstellen und wie sie unter FreeBSD angesprochen werden.

Da es verschiedene Schnittstellen gibt, sollte vor dem Kauf oder Selbstbau eines Kabels sichergestellt werden, dass dieses zu den Schnittstellen des Terminals und des FreeBSD-Systems passt.

Die meisten Terminals besitzen DB-25-Stecker. Personal Computer haben DB-25- oder DB-9-Stecker. Eine serielle Multiportkarte hat vielleicht RJ-12- oder RJ-45-Anschlüsse.

Die Dokumentation der Geräte sollte Aufschluss über den Typ der benötigten Anschlüsse geben. Oft hilft es, wenn Sie sich den Anschluss einfach ansehen.

Unter FreeBSD wird jede serielle Schnittstelle (Port) über einen Eintrag in [.filename]#/dev# angesprochen. Es gibt dort zwei verschiedene Einträge:

* Schnittstellen für eingehende Verbindungen werden [.filename]#/dev/ttyuN# genannt. Dabei ist _N_ die Nummer der Schnittstelle, deren Zählung bei Null beginnt. Allgemein wird diese Schnittstelle für Terminals benutzt. Diese Schnittstelle funktioniert nur, wenn ein "Data Carrier Detect" Signal (DCD) vorliegt.
* Für ausgehende Verbindungen wird in FreeBSD 8.X und neueren Versionen [.filename]#/dev/cuauN# verwendet. FreeBSD 7.X und ältere Versionen verwenden [.filename]#/dev/cuadN#. Dieser Port wird normalerweise nur von Modems genutzt. Er kann allerdings auch für Terminals benutzt werden, die das "Data Carrier Detect" Signal nicht unterstützen.

Wenn ein Terminal an die erste serielle Schnittstelle ([.filename]#COM1#) angeschlossen ist, wird er über [.filename]#/dev/ttyu0# angesprochen. Wenn er an der zweiten seriellen Schnittstelle (COM2) angeschlossen ist, verwenden Sie [.filename]#/dev/ttyu1#, usw.

=== Kernelkonfiguration

In der Voreinstellung benutzt FreeBSD vier serielle Schnittstellen, die unter MS-DOS(R) als [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3# und [.filename]#COM4# bekannt sind. Momentan unterstützt FreeBSD einfache Multiportkarten, wie bspw. die BocaBoard 1008 und 2016 und bessere wie die von Digiboard und Stallion Technologies. In der Voreinstellung sucht der Kernel allerdings nur nach den Standardanschlüssen.

Um zu überprüfen, ob der Kernel die seriellen Schnittstellen erkennt, achten Sie auf die Meldungen beim Booten, oder schauen sich diese später mit `/sbin/dmesg` an. Achten Sie auf Meldungen die mit `uart` beginnen:

[source,shell]
....
# /sbin/dmesg | grep 'uart'
....

Wenn der Kernel nicht alle seriellen Schnittstellen erkennt, müssen Sie [.filename]#/boot/device.hints# konfigurieren. Wenn Sie diese Datei editieren, können Sie die Einträge für Geräte, die auf dem System nicht vorhanden sind, auskommentieren oder komplett entfernen.

[NOTE]
====
`port IO_COM1` ist ein Ersatz für `port 0x3f8`, `IO_COM2` bedeutet `port 0x2f8`, `IO_COM3` bedeutet `port 0x3e8` und `IO_COM4` steht für `port 0x2e8`. Die angegebenen IO-Adressen sind genau wie die Interrupts 4, 3, 5 und 9 üblich für serielle Schnittstellen. Beachten Sie, dass sich normale serielle Schnittstellen auf ISA-Bussen _keine_ Interrupts teilen können. Multiportkarten besitzen zusätzliche Schaltkreise, die es allen 16550As auf der Karte erlauben, sich einen oder zwei Interrupts zu teilen.
====

=== Gerätedateien

Die meisten Geräte im Kernel werden durch Gerätedateien in [.filename]#/dev# angesprochen. Die [.filename]#sio# Geräte werden durch [.filename]#/dev/ttyuN# für eingehende Verbindungen und durch [.filename]#/dev/cuauN# für ausgehende Verbindungen angesprochen. Zum Initialisieren der Geräte stellt FreeBSD die Dateien [.filename]#/dev/ttyuN.init# und [.filename]#/dev/cuauN.init# zur Verfügung. Zusätzlich existieren Dateien für das Sperren von Gerätedateien (Locking). Dabei handelt es sich um die Dateien [.filename]#/dev/ttyuN.lock# und [.filename]#/dev/cuauN.lock#. Diese Dateien werden benutzt, um Kommunikationsparameter beim Öffnen eines Ports vorzugeben. Für Modems, die zur Flusskontrolle `RTS/CTS` benutzen, kann damit `crtscts` gesetzt werden. Die Geräte [.filename]#/dev/ttyldN# und [.filename]#/dev/cualaN# (locking devices) werden genutzt, um bestimmte Parameter festzuschreiben und vor Veränderungen zu schützen. Weitere Informationen zu Terminals finden Sie in man:termios[4], man:sio[4] erklärt die Dateien zum Initialisieren und Sperren der Geräte, man:stty[1] beschreibt schließlich Terminal-Einstellungen.

[[serial-hw-config]]
=== Konfiguration der seriellen Schnittstelle

Anwendungen benutzen normalerweise die Geräte [.filename]#ttyuN# oder [.filename]#cuauN#. Das Gerät besitzt einige Voreinstellungen für Terminal-I/O, wenn es von einem Prozess geöffnet wird. Mit dem folgenden Kommando können Sie sich diese Einstellungen ansehen:

[source,shell]
....
# stty -a -f /dev/ttyu1
....

Wenn diese Einstellungen verändert werden, bleiben sie nur solange wirksam, bis das Gerät geschlossen wird. Wenn das Gerät danach wieder geöffnet wird, sind die Voreinstellungen wieder wirksam. Um die Voreinstellungen dauerhaft zu ändern, öffnen Sie das Gerät, das zum Initialisieren dient und verändern dessen Einstellungen. Um beispielsweise für [.filename]#ttyu5# den `CLOCAL` Modus, 8-Bit Kommunikation und `XON/XOFF` Flusssteuerung einzuschalten, setzen Sie das folgende Kommando ab:

[source,shell]
....
# stty -f /dev/ttyu5.init clocal cs8 ixon ixoff
....

In [.filename]#/etc/rc.d/rc.serial# werden die systemweiten Voreinstellungen für serielle Geräte vorgenommen.

Um zu verhindern, dass Einstellungen von Anwendungen verändert werden, können Sie die Geräte zum Festschreiben von Einstellungen ("locking devices") benutzen. Wenn sie beispielsweise die Geschwindigkeit von [.filename]#ttyu5# auf 57600 bps festlegen wollen, benutzen Sie das folgende Kommando:

[source,shell]
....
# stty -f /dev/ttyld5 57600
....

Eine Anwendung, die [.filename]#ttyu5# öffnet, kann nun nicht mehr die Geschwindigkeit ändern und muss 57600 bps benutzen.

Die Geräte zum Initialisieren und Festschreiben von Einstellungen sollten selbstverständlich nur von `root` beschreibbar sein.

[[term]]
== Terminals

Wenn Sie sich nicht an der Konsole oder über ein Netzwerk an ein FreeBSD-System anmelden können, sind Terminals ein bequemer und kostengünstiger Weg, um auf ein System zuzugreifen. Dieser Abschnitt beschreibt wie Sie Terminals mit FreeBSD benutzen.

Das ursprüngliche UNIX(R) System besaß keine Konsolen. Zum Anmelden und Starten von Programmen wurden stattdessen Terminals benutzt, die an den seriellen Schnittstellen des Rechners angeschlossen waren.

Die Möglichkeit, über eine serielle Schnittstelle eine Anmeldesitzung herzustellen, existiert heute noch in fast jedem UNIX(R)-artigen Betriebssystem, einschließlich FreeBSD. Der Einsatz eines Terminals, das an einem freien seriellen Port angeschlossen ist, ermöglicht es dem Benutzer sich anzumelden und dort jedes Textprogramm zu starten, das normalerweise an der Konsole oder in einem `xterm` Fenster ausgeführt wird.

Viele Terminals können an einem FreeBSD-System angeschlossen werden. Ein alter Computer kann als Terminal an ein leistungsfähiges FreeBSD-System angeschlossen werden. Damit kann ein Einzelarbeitsplatz in ein leistungsfähiges Mehrbenutzersystem verwandelt werden.

FreeBSD unterstützt drei Arten von Anschlüssen:

Dumb-Terminals::
Dumb-Terminals (unintelligente Datenstationen) sind Geräte, die über die serielle Schnittstelle mit einem Rechner verbunden werden. Sie werden "unintelligent" genannt, weil sie nur Text senden und empfangen und keine Programme laufen lassen können. Alle benötigten Programme befinden sich auf dem Rechner, der mit dem Terminal verbunden ist.
+
Es gibt viele Dumb-Terminals, die von verschiedenen Herstellern produziert werden, und so gut wie jeder der verschiedenen Terminals sollte mit FreeBSD zusammenarbeiten. Manche High-End Geräte verfügen sogar über Grafikfähigkeiten, die allerdings nur von spezieller Software genutzt werden kann.
+
Dumb-Terminals sind in Umgebungen beliebt, in denen keine Grafikanwendungen benötigt werden.

Computer, die als Terminal fungieren::
Jeder Computer kann die Funktion eines Dumb-Terminals, der ja nur Text senden und empfangen kann, übernehmen. Dazu wird lediglich das richtige Kabel benötigt und eine _Terminalemulation_, die auf dem Computer läuft.
+
Diese Konfiguration ist sehr nützlich. Wenn ein Benutzer zum Beispiel gerade an der FreeBSD-Konsole arbeitet, kann ein anderer Benutzer einen weniger leistungsstarken Computer, der als Terminal mit dem FreeBSD-System verbunden ist, benutzen, um dort gleichzeitig im Textmodus zu arbeiten.
+
Bereits im Basissystem sind mindestens zwei Werkzeuge vorhanden, die Sie zur Arbeit über eine serielle Konsole einsetzen können: man:cu[1] sowie man:tip[1].
+
Um sich von einem FreeBSD-System aus über eine serielle Verbindung mit einem anderen System zu verbinden, geben Sie folgenden Befehl ein:
+

[source,shell]
....
# cu -l /dev/cuauN
....

+
Die Ports sind von Null beginnend nummeriert. Das bedeutet, dass [.filename]#COM1# dem Gerät [.filename]#/dev/cuau0# entspricht.
+
In der Ports-Sammlung finden sich weitere Programme, wie beispielsweise package:comms/minicom[], mit denen eine Verbindung über eine serielle Schnittstelle hergestellt werden kann.

X-Terminals::
X-Terminals sind die ausgereiftesten der verfügbaren Terminals. Sie werden nicht mit der seriellen Schnittstelle sondern mit einem Netzwerk, wie dem Ethernet, verbunden. Diese Terminals sind auch nicht auf den Textmodus beschränkt, sondern können jede Xorg-Anwendung darstellen.
+
Die Einrichtung und Verwendung von X-Terminals wird in diesem Abschnitt nicht beschrieben.

[[term-config]]
=== Konfiguration

Dieser Abschnitt beschreibt, wie Sie ein FreeBSD-System konfigurieren müssen, um sich an einem Terminal anzumelden. Dabei wird vorausgesetzt, dass der Kernel bereits die serielle Schnittstelle, die mit dem Terminal verbunden ist, unterstützt. Weiterhin sollte der Terminal schon angeschlossen sein.

Der `init` Prozess ist für das Initialisieren des Systems und den Start von Prozessen zum Zeitpunkt des Systemstarts verantwortlich. Unter anderem liest `init`[.filename]#/etc/ttys# ein und startet für jeden verfügbaren Terminal einen `getty` Prozess. `getty` wiederum fragt beim Anmelden den Benutzernamen ab und startet `login`.

Um Terminals auf einem FreeBSD-System einzurichten, führen Sie folgenden Schritte als `root` durch:

[.procedure]
. Fügen Sie einen Eintrag in [.filename]#/etc/ttys# für die serielle Schnittstelle aus [.filename]#/dev# ein, falls dieser nicht bereits vorhanden ist.
. Geben Sie `/usr/libexec/getty` als auszuführendes Programm an. Als Parameter für _getty_ geben Sie den passenden Verbindungstyp aus [.filename]#/etc/gettytab# an.
. Geben Sie den Terminaltyp an.
. Aktivieren Sie den Anschluss.
. Geben Sie die Sicherheit des Anschlusses an.
. Veranlassen Sie `init`[.filename]#/etc/ttys# erneut zu lesen.

Optional können Sie in [.filename]#/etc/gettytab# auch einen auf Ihre Zwecke angepassten Terminaltyp erstellen. man:gettytab[5] und man:getty[8] enthalten dazu weitere Informationen.

[[term-etcttys]]
==== Hinzufügen eines Eintrags in [.filename]#/etc/ttys#

In [.filename]#/etc/ttys# werden alle Terminals aufgeführt, an denen eine Anmeldung auf dem FreeBSD-System möglich ist. Hier findet sich zum Beispiel ein Eintrag für die erste virtuelle Konsole [.filename]#/dev/ttyv0#, der es Benutzern ermöglicht, sich dort anzumelden. Die Datei enthält weitere Einträge für andere virtuelle Konsolen, serielle Schnittstellen und Pseudoterminals. Um einen Terminal zu konfigurieren, fügen Sie einen Eintrag für den Namen des Gerätes aus [.filename]#/dev# ohne das Präfix [.filename]#/dev# hinzu. Zum Beispiel wird [.filename]#/dev/ttyv0# als `ttyv0` aufgeführt.

In der Voreinstellung enthält [.filename]#/etc/ttys# Einträge für die ersten vier seriellen Schnittstellen: [.filename]#ttyu0# bis [.filename]#ttyu3#. Wird an eine von diesen Schnittstellen ein Terminal angeschlossen, braucht in dieser Datei kein weiter Eintrag hinzugefügt werden.

[[ex-etc-ttys]]
.Einträge in [.filename]#/etc/ttys# hinzufügen
[example]
====
Dieses Beispiel konfiguriert zwei Terminals: Einen Wyse-50 und einen alten 286 IBM PC, der mit Procomm einen VT-100 Terminal emuliert. Der Wyse-Terminal ist mit der zweiten seriellen Schnittstelle verbunden und der 286 mit der sechsten seriellen Schnittstelle, einem Anschluss auf einer Multiportkarte. Die entsprechenden Einträge in [.filename]#/etc/ttys# würden dann wie folgt aussehen:

[.programlisting]
....
ttyu1  "/usr/libexec/getty std.38400"  wy50  on  insecure
ttyu5   "/usr/libexec/getty std.19200"  vt100  on  insecure
....

Das erste Feld gibt normalerweise den Namen der Gerätedatei aus [.filename]#/dev# an.

Im zweiten Feld wird das auszuführende Kommando, normal ist das man:getty[8], angegeben. `getty` initialisiert und öffnet die Verbindung, setzt die Geschwindigkeit und fragt den Benutzernamen ab. Danach führt es man:login[1] aus.

`getty` akzeptiert einen optionalen Parameter auf der Kommandozeile, den Verbindungstyp, der die Eigenschaften der Verbindung, wie die Geschwindigkeit und Parität, festlegt. Die Typen und die damit verbundenen Eigenschaften liest `getty` aus [.filename]#/etc/gettytab#.

[.filename]#/etc/gettytab# enthält viele Einträge sowohl für neue wie auch alte Terminalverbindungen. Die meisten Einträge, die mit `std` beginnen, sollten mit einem festverdrahteten Terminal funktionieren. Für jede Geschwindigkeit zwischen 110 bps und 115200 bps gibt es einen `std` Eintrag. Weitere Informationen dazu finden Sie in man:gettytab[5].

Wenn Sie den Verbindungstyp in [.filename]#/etc/ttys# eintragen, stellen Sie sicher, dass die Kommunikationseinstellungen auch mit denen des Terminals übereinstimmen.

In diesem Beispiel verwendet der Wyse-50 keine Parität und 38400 bps, der 286 PC benutzt ebenfalls keine Parität und arbeitet mit 19200 bps.

Das dritte Feld gibt den Terminaltyp an, der normalerweise mit diesem Anschluss verbunden ist. Für Einwählverbindungen wird oft `unknown` oder `dialup` benutzt, da sich die Benutzer praktisch mit beliebigen Terminals oder Emulatoren anmelden können. Bei festverdrahteten Terminals ändert sich der Typ nicht, so dass in diesem Feld ein richtiger Typ aus der man:termcap[5] Datenbank angegeben werden kann.In diesem Beispiel benutzt der Wyse-50 den entsprechenden Typ aus man:termcap[5], der 286 PC wird als VT-100, den er ja emuliert, angegeben.

Das vierte Feld gibt an, ob der Anschluss aktiviert werden soll. Ist das Feld auf `on` gesetzt, startet `init` das Programm, das im zweiten Feld angegeben ist. Normalerweise ist dies `getty`. Wenn das Feld auf `off` gesetzt wird, wird `getty` nicht ausgeführt und folglich kann sich niemand an dem betreffenden Terminal anmelden.

Das letzte Feld gibt die Sicherheit des Anschlusses an. Wenn hier `secure` angegeben wird, darf sich `root`, oder jeder Account mit der UID `0` über diese Verbindung anmelden. Wenn `insecure` angegeben wird, dürfen sich nur unprivilegierte Benutzer anmelden. Diese können später mit man:su[1] oder einem ähnlichen Mechanismus zu `root` wechseln.Es wird dringend empfohlen `insecure` zu verwenden, sogar für Terminals hinter verschlossenen Türen. Es ist ganz einfach sich mit `su` anzumelden, wenn Superuser-Rechte benötigt werden.
====

[[term-hup]]
==== `init` zwingen, [.filename]#/etc/ttys# erneut zu lesen

Nachdem Änderungen in [.filename]#/etc/ttys# vorgenommen wurden, schicken Sie `init` ein SIGHUP-Signal (hangup), um es zu veranlassen, seine Konfigurationsdatei neu zu lesen:

[source,shell]
....
# kill -HUP 1
....

[NOTE]
====
Da `init` immer der erste Prozess auf einem System ist, besitzt es immer die Prozess-ID `1`.
====

Wenn alles richtig eingerichtet ist, alle Kabel angeschlossen und die Terminals eingeschaltet sind, sollte für jeden Terminal ein `getty` Prozess laufen und auf jedem Terminal sollte eine Anmeldeaufforderung zu sehen sein.

[[term-debug]]
=== Fehlersuche

Selbst wenn Sie den Anweisungen akribisch gefolgt sind, kann es immer noch zu Fehlern beim Einrichten eines Terminals kommen. Hier eine Liste der häufigsten Symptome, sowie einige mögliche Lösungen:

Wenn kein Anmeldeprompt erscheint, stellen Sie sicher, dass der Terminal verbunden und eingeschaltet ist. Wenn ein PC als Terminal fungiert, überprüfen Sie, dass die Terminalemulation auf den richtigen Schnittstellen läuft.

Stellen Sie sicher, dass Sie das richtige Kabel verwenden und dass das Kabel fest mit dem Terminal und dem FreeBSD-Rechner verbunden ist.

Stellen Sie sicher, dass die Einstellungen für die Geschwindigkeit (bps) und Parität auf dem FreeBSD-System und dem Terminal gleich sind. Wenn der Terminal einen Bildschirm besitzt, überprüfen Sie die richtige Einstellung von Helligkeit und Kontrast. Wenn der Terminal druckt, stellen Sie die ausreichende Versorgung mit Papier und Tinte sicher.

Überprüfen Sie mit `ps`, dass der `getty` Prozess für den Terminal läuft:

[source,shell]
....
# ps -axww|grep getty
....

Für jeden Terminal sollte ein Eintrag vorhanden sein. Aus dem folgenden Beispiel ist zu erkennen, dass `getty` auf der zweiten seriellen Schnittstelle [.filename]#tyyd1# läuft und den Verbindungstyp `std.38400` aus [.filename]#/etc/gettytab# benutzt:

[source,shell]
....
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1
....

Wenn `getty` nicht läuft, überprüfen Sie, ob der Anschluss in [.filename]#/etc/ttys# aktiviert ist. Denken Sie daran `kill -HUP 1` auszuführen, nachdem [.filename]#/etc/ttys# geändert wurde.

Wenn `getty` läuft, aber der Terminal immer noch kein Anmeldeprompt ausgibt, oder am Anmeldeprompt nichts eingegeben werden kann, kann es sein, dass der Terminal oder Kabel keinen Hardware-Handshake unterstützt. Ändern Sie dann den Eintrag `std.38400` in [.filename]#/etc/ttys# zu `3wire.38400`. Nachdem Sie [.filename]#/etc/ttys# geändert haben, setzen Sie `kill -HUP 1` ab. Der Eintrag `3wire` besitzt ähnliche Eigenschaften wie der Eintrag `std`, ignoriert aber den Hardware-Handshake. Wenn Sie den Eintrag `3wire` verwenden, muss vielleicht die Geschwindigkeit verkleinert oder die Software-Flusssteuerung aktiviert werden, um Pufferüberläufe zu vermeiden.

Wenn nur unverständliche Zeichen erscheinen, stellen Sie sicher, dass die Einstellungen für die Geschwindigkeit (bps) und Parität auf dem FreeBSD-System und dem Terminal gleich sind. Kontrollieren Sie den `getty` Prozess und stellen Sie sicher, dass der richtige Verbindungstyp aus [.filename]#/etc/gettytab# benutzt wird. Wenn das nicht der Fall ist, editieren Sie [.filename]#/etc/ttys# und setzen das Kommando `kill-HUP 1` ab.

Wenn Zeichen doppelt und eingegebene Passwörter im Klartext erscheinen, stellen Sie den Terminal oder die Terminalemulation von "half duplex" oder "local echo" auf "full duplex" um.

[[dialup]]
== Einwählverbindungen

Das Einrichten von Einwählverbindungen auf FreeBSD-Systemen ähnelt dem Anschließen von Terminals, nur dass anstelle eines Terminals ein Modem verwendet wird. FreeBSD unterstützt sowohl externe als auch interne Modems.

Externe Modems sind für Einwählverbindungen besser geeignet, da sie die Konfiguration in nicht flüchtigem RAM speichern können. Zudem verfügen Sie über Leuchtanzeigen, die den Status wichtiger RS-232 Signale anzeigen.

Interne Modems verfügen normalerweise nicht über nicht flüchtiges RAM und lassen sich meist nur über DIP-Schalter konfigurieren. Selbst wenn ein internes Modem Leuchtanzeigen besitzt, sind diese meist schwer einzusehen, wenn das Modem eingebaut ist.

Mit einem externen Modem muss das passende Kabel verwendet werden. Ein Standard RS-232C Kabel, bei dem die folgenden Signale miteinander verbunden sind, sollte ausreichen:
[[serialcomms-signal-names]]
.Signalnamen
[cols="1,1", frame="none", options="header"]
|===
<| Abkürzung
<| Bedeutung

|RD
|Received Data

|TD
|Transmitted Data

|DTR
|Data Terminal Ready

|DSR
|Data Set Ready

|DCD
|Data Carrier Detect (dadurch erkennt RS-232 das Signal _Received Line_)

|SG
|Signal Ground

|RTS
|Request to Send

|CTS
|Clear to Send
|===

Ab Geschwindigkeiten von 2400 bps benötigt FreeBSD die Signale RTS und CTS für die Flusssteuerung. Das Signal CD zeigt an, ob ein Träger vorliegt, das heißt ob die Verbindung aufgebaut ist oder beendet wurde. DTR zeigt an, dass das Gerät betriebsbereit ist. Es gibt einige Kabel, bei denen nicht alle nötigen Signale verbunden sind. Wenn Probleme dieser Art auftreten, dass zum Beispiel die Sitzung nicht beendet wird, obwohl die Verbindung beendet wurde, kann das an einem solchen Kabel liegen.

Wie andere UNIX(R) Betriebssysteme auch, benutzt FreeBSD Hardwaresignale, um festzustellen, ob ein Anruf beantwortet wurde, eine Verbindung beendet wurde, oder um die Verbindung zu schließen und das Modem zurückzusetzen. FreeBSD vermeidet es, dem Modem Kommandos zu senden, oder den Statusreport des Modems abzufragen.

=== Schnittstellenbausteine

FreeBSD unterstützt EIA RS-232C (CCITT V.24) serielle Schnittstellen, die auf den NS8250, NS16450, NS16550 oder NS16550A Bausteinen basieren. Die Bausteine der Serie 16550 verfügen über einen 16 Byte großen Puffer, der als FIFO angelegt ist. Wegen Fehler in der FIFO-Logik kann der Puffer in einem 16550 Baustein allerdings nicht genutzt werden, das heißt der Baustein muss als 16450 betrieben werden. Bei allen Bausteinen ohne Puffer und dem 16550 Baustein muss jedes Byte einzeln von dem Betriebssystem verarbeitet werden, was Fehler bei hohen Geschwindigkeiten oder großer Systemlast erzeugt. Es sollten daher nach Möglichkeit serielle Schnittstellen, die auf 16550A Bausteinen basieren, eingesetzt werden.

=== Überblick

Wie bei Terminals auch, startet `init` für jede serielle Schnittstelle, die eine Einwählverbindung zur Verfügung stellt, einen `getty` Prozess. Wenn das Modem beispielsweise an [.filename]#/dev/ttyu0# angeschlossen ist, sollte in der Ausgabe von `ps ax` eine Zeile wie die folgende erscheinen:

[source,shell]
....
4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyu0
....

Wenn sich ein Benutzer einwählt und die Verbindung aufgebaut ist, zeigt das Modem dies durch das CD Signal (Carrier Detect) an. Der Kernel merkt, dass ein Signal anliegt und weist `getty` an, die Schnittstelle zu öffnen. Dann sendet `getty` das Anmeldeprompt mit der ersten für die Verbindung vereinbarten Geschwindigkeit und wartet auf eine Antwort. Wenn die Antwort unverständlich ist, weil zum Beispiel die Geschwindigkeit des Modems von ``getty``s Geschwindigkeit abweicht, versucht `getty` die Geschwindigkeit solange anzupassen, bis es eine verständliche Antwort erhält.

Nachdem der Benutzer seinen Benutzernamen eingegeben hat, führt `getty`[.filename]#/usr/bin/login# aus, welches das Passwort abfragt und danach die Shell des Benutzers startet.

=== Konfigurationsdateien

Drei Konfigurationsdateien in [.filename]#/etc# steuern, ob eine Einwahl in das FreeBSD-System möglich ist. [.filename]#/etc/gettytab#, konfiguriert den [.filename]#/usr/libexec/getty# Dæmon. In [.filename]#/etc/ttys# wird festgelegt, auf welchen Schnittstellen [.filename]#/sbin/init# einen `getty` Prozess startet. Schließlich bietet [.filename]#/etc/rc.d/serial# die Möglichkeit, Schnittstellen zu initialisieren.

Es gibt zwei Ansichten darüber, wie Modems für Einwählverbindungen unter UNIX(R) zu konfigurieren sind. Zum einen kann die Geschwindigkeit zwischen dem Modem und dem Computer fest eingestellt werden. Sie ist damit unabhängig von der Geschwindigkeit, mit der sich der entfernte Benutzer einwählt. Dies hat den Vorteil, dass der entfernte Benutzer das Anmeldeprompt sofort bekommt. Der Nachteil bei diesem Verfahren ist, dass das System die tatsächliche Geschwindigkeit der Verbindung nicht kennt. Damit können bildschirmorientierte Programme wie Emacs ihren Bildschirmaufbau nicht an langsame Verbindungen anpassen, um die Antwortzeiten zu verbessern.

Die andere Möglichkeit besteht darin, die Geschwindigkeit der RS-232 Schnittstelle des lokalen Modems an die Geschwindigkeit des entfernten Modems anzupassen. Bei einer V.32bis (14400 bps) Verbindung kann das lokale Modem die RS-232 Schnittstelle mit 19200 bps betreiben, während bei einer Verbindung mit 2400 bps die RS-232 Schnittstelle mit 2400 bps betrieben wird. Da `getty` die Verbindungsgeschwindigkeit des Modems nicht kennt, startet es den Anmeldevorgang mit der Ausgabe von `login:` und wartet auf eine Antwort. Wenn der Benutzer der Gegenstelle nun nur unverständliche Zeichen erhält, muss er solange kbd:[Enter] drücken, bis das Anmeldeprompt erscheint. Solange die Geschwindigkeiten nicht übereinstimmen, sind die Antworten der Gegenstelle für `getty` ebenfalls unverständlich. In diesem Fall wechselt `getty` zur nächsten Geschwindigkeit und gibt wieder `login:` aus. In aller Regel erhält der Benutzer der Gegenstelle nach ein bis zwei Tastendrücken eine erkennbare Anmeldeaufforderung. Diese Anmeldeprozedur sieht nicht so sauber wie die Methode mit einer festen Geschwindigkeit aus, bietet dem Benutzer einer langsamen Verbindung allerdings den Vorteil, dass sich bildschirmorientierte Programme an die Geschwindigkeit anpassen können.

Im Folgenden wird die Konfiguration für beide Methoden besprochen, doch die Methode der angepassten Geschwindigkeit wird bei der Diskussion bevorzugt.

==== [.filename]#/etc/gettytab#

Mit [.filename]#/etc/gettytab# wird man:getty[8] im Stil von man:termcap[5] konfiguriert. Das Format dieser Datei und die Bedeutung der Einträge wird in man:gettytab[5] beschrieben.

Wenn die Modemgeschwindigkeit vorgeben wird, sollten Anpassungen in [.filename]#/etc/gettytab# nicht erforderlich sein.

Wenn jedoch die Geschwindigkeit angepasst werden soll, erstellen Sie einen Eintrag in [.filename]#/etc/gettytab#, um `getty` die Geschwindigkeit für das Modem mitzuteilen. Für ein 2400 bps Modem kann der vorhandene `D2400` Eintrag benutzt werden.

[.programlisting]
....
#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:
....

Wird ein Modem mit einer höheren Geschwindigkeit eingesetzt, müssen weitere Einträge in [.filename]#/etc/gettytab# erstellt werden. Dieses Beispiel zeigt einen Eintrag für ein 14400 bps Modem mit einer Geschwindigkeit bis zu 19200 bps:

[.programlisting]
....
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

Die damit erzeugten Verbindungen verwenden 8 Bit und keine Parität.

Im obigen Beispiel startet die Geschwindigkeit bei 19200 bps (eine V.32bis Verbindung) und geht dann über 9600 bps (V.32), 400 bps, 1200 bps und 300 bps wieder zurück zu 19200 bps. Das Schlüsselwort `nx=` (next table) sorgt für das zyklische Durchlaufen der Geschwindigkeiten. Jede Zeile zieht zudem noch mit `tc=` (table continuation) die Vorgabewerte für die jeweilige Geschwindigkeit an.

Wenn Sie ein 28800 bps Modem besitzen und/oder Kompression mit einem 14400 bps Modem benutzen wollen, brauchen Sie höhere Geschwindigkeiten als 19200 bps. Das folgende Beispiel startet mit 57600 bps:

[.programlisting]
....
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57600 bps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

Wenn Sie eine langsame CPU oder ein stark ausgelastetes System besitzen und sich kein 16550A im System befindet, erhalten Sie bei 57600 bps vielleicht `sio` Fehlermeldungen der Form "silo overflow".

[[dialup-ttys]]
==== [.filename]#/etc/ttys#

[.filename]#/etc/ttys# wurde bereits in <<ex-etc-ttys>> besprochen. Die Konfiguration für Modems ist ähnlich, allerdings braucht `getty` ein anderes Argument und es muss ein anderer Terminaltyp angegeben werden. Der Eintrag für beide Methoden (feste und angepasste Geschwindigkeit) hat die folgende Form:

[.programlisting]
....
ttyu0   "/usr/libexec/getty xxx"   dialup on
....

Das erste Feld der obigen Zeile gibt die Gerätedatei für diesen Eintrag an. [.filename]#ttyu0# bedeutet, dass `getty` mit [.filename]#/dev/ttyu0# arbeitet. Das zweite Feld `"/usr/libexec/getty xxx"` gibt das Kommando an, das `init` für dieses Gerät startet (_xxx_ wird durch einen passenden Eintrag aus [.filename]#/etc/gettytab# ersetzt). Die Vorgabe für den Terminaltyp, hier `dialup`, wird im dritten Feld angegeben. Das vierte Feld, `on`, zeigt `init` an, dass die Schnittstelle aktiviert ist. Im fünften Feld könnte noch `secure` angegeben werden, um Anmeldungen von `root` zu erlauben, doch sollte das wirklich nur für physikalisch sichere Terminals, wie die Systemkonsole, aktiviert werden.

Die Vorgabe für den Terminaltyp, `dialup` im obigen Beispiel, hängt von lokalen Gegebenheiten ab. Traditionell wird `dialup` für Einwählverbindungen verwendet, so dass die Benutzer in ihren Anmeldeskripten den Terminaltyp auf ihren Terminal abstimmen können, wenn der Typ auf `dialup` gesetzt ist. Wenn Sie nur VT102 Terminals oder Emulatoren einsetzen, können Sie den Terminaltyp hier auch fest auf `vt102` setzen.

Nachdem [.filename]#/etc/ttys# geändert wurde, muss `init` ein HUP Signal schicken, damit es die Datei wieder einliest:

[source,shell]
....
# kill -HUP 1
....

Stellen Sie sicher, dass das Modem richtig konfiguriert und angeschlossen ist, bevor Sie das Signal an `init` schicken.

Das Argument von `getty` muss in diesem Fall eine feste Geschwindigkeit vorgeben. Der Eintrag für ein Modem, das fest auf 19200 bps eingestellt ist, könnte wie folgt aussehen:

[.programlisting]
....
ttyu0   "/usr/libexec/getty std.19200"   dialup on
....

Wenn das Modem auf eine andere Geschwindigkeit eingestellt ist, setzen Sie anstelle von `std.19200` einen passenden Eintrag der Form `std._speed_` ein. Stellen Sie sicher, dass dies auch ein gültiger Verbindungstyp aus [.filename]#/etc/gettytab# ist.

Das Argument von `getty` muss hier auf einen der Einträge aus [.filename]#/etc/gettytab# zeigen, der zu einer Kette von Einträgen gehört, die die zu probierenden Geschwindigkeiten beschreiben. Wenn Sie dem obigen Beispiel gefolgt sind und zusätzliche Einträge in [.filename]#/etc/gettytab# erzeugt haben, können Sie die folgende Zeile verwenden:

[.programlisting]
....
ttyu0   "/usr/libexec/getty V19200"   dialup on
....

==== [.filename]#/etc/rc.d/serial#

Modems, die höhere Geschwindigkeiten unterstützen, zum Beispiel V.32, V.32bis und V.34 Modems, benutzen Hardware-Flusssteuerung (`RTS/CTS`). Für die entsprechenden Schnittstellen können Sie die Flusssteuerung mit `stty` in [.filename]#/etc/rc.d/serial# einstellen.

Um beispielsweise die Hardware-Flusssteuerung für die Geräte zur Ein- und Auswahl der zweiten seriellen Schnittstelle ([.filename]#COM2#) zu aktivieren, benutzen Sie die Dateien zur Initialisierung der entsprechenden Geräte und fügen die folgenden Zeilen in [.filename]#/etc/rc.d/serial# hinzu:

[.programlisting]
....
# Serial port initial configuration
stty -f /dev/ttyu1.init crtscts
stty -f /dev/cuad1.init crtscts
....

=== Modemkonfiguration

Für ein Modem, das seine Konfiguration in nicht flüchtigem RAM speichert, wird ein Terminalprogramm wie Telix unter MS-DOS(R) oder `tip` unter FreeBSD benötigt, um die Parameter einzustellen. Verbinden Sie sich mit derselben Geschwindigkeit, die `getty` zuerst benutzen würde, mit dem Modem und treffen Sie folgende Einstellungen:

* DCD ist eingeschaltet, wenn das Trägersignal des entfernten Modems erkannt wird.
* Im Betrieb liegt DTR an. Bei einem Verlust von DTR legt das Modem auf und setzt sich zurück.
* CTS Flusssteuerung ist für ausgehende Daten aktiviert.
* XON/XOFF Flusssteuerung ist ausgeschaltet.
* RTS Flusssteuerung ist für eingehende Daten aktiviert.
* Keine Rückmeldungen ausgeben.
* Die Echo-Funktion ist deaktiviert.

Lesen Sie die Dokumentation für das Modem, um herauszufinden welche Befehle und/oder DIP-Schalterstellungen benötigt werden.

Für ein externes 14400 gelten zum Beispiel die folgenden Befehle:

[.programlisting]
....
ATZ
ATC1D2H1I0R2W
....

Bei dieser Gelegenheit können Sie auch gleich andere Einstellungen, zum Beispiel ob Sie V42.bis und/oder MNP5 Kompression benutzen wollen, an Ihrem Modem vornehmen.

Bei einem externen 14400 müssen Sie auch noch einige DIP-Schalter einstellen. Die folgenden Einstellungen können verwendet werden:

* Schalter 1: OBEN - DTR normal
* Schalter 2: N/A (Rückmeldungen als Text/numerische Rückmeldungen)
* Schalter 3: OBEN - Keine Rückmeldungen ausgeben
* Schalter 4: UNTEN - Echo-Funktion aus
* Schalter 5: OBEN - Rufannahme aktiviert
* Schalter 6: OBEN - Carrier Detect normal
* Schalter 7: OBEN - Einstellungen aus dem NVRAM laden
* Schalter 8: N/A (Smart Mode/Dumb Mode)

Für Einwählverbindungen sollten die Rückmeldungen deaktiviert sein, da sonst `getty` dem Modem das Anmeldeprompt `login:` schickt und das Modem im Kommandomodus das Prompt wieder ausgibt (Echo-Funktion) oder eine Rückmeldung gibt. Das führt dann zu einer länglichen und fruchtlosen Kommunikation zwischen dem Modem und `getty`.

Die Geschwindigkeit zwischen Modem und Computer muss auf einen festen Wert eingestellt werden. Mit einem externen 14400 Modem setzen die folgenden Kommandos die Geschwindigkeit auf den Wert der Datenendeinrichtung fest:

[.programlisting]
....
ATZ
ATB1W
....

In diesem Fall muss die Geschwindigkeit der seriellen Schnittstelle des Modems der eingehenden Geschwindigkeit angepasst werden. Für ein externes 14400 Modem erlauben die folgenden Befehle eine Anpassung der Geschwindigkeit der seriellen Schnittstelle für Verbindungen, die keine Fehlerkorrektur verwenden:

[.programlisting]
....
ATZ
ATB2W
....

Verbindungen mit Fehlerkorrektur (V.42, MNP) verwenden die Geschwindigkeit der Datenendeinrichtung.

==== Überprüfen der Modemkonfiguration

Die meisten Modems verfügen über Kommandos, die die Konfiguration des Modems in lesbarer Form ausgeben. Auf einem externen 14400 zeigt `ATI5` die Einstellungen im nicht flüchtigen RAM an. Um die wirklichen Einstellungen unter Berücksichtigung der DIP-Schalter zu sehen, benutzen Sie `ATZ` gefolgt von `ATI4`.

Wenn Sie ein anderes Modem benutzen, schauen Sie bitte in der Dokumentation des Modems nach, wie Sie die Konfiguration des Modems überprüfen können.

=== Fehlersuche

Bei Problemen können Sie die Einwählverbindung anhand der folgenden Punkte überprüfen:

Schließen Sie das Modem an das FreeBSD-System an und booten Sie das System. Wenn das Modem über Statusindikatoren verfügt, überprüfen Sie, ob der DTR Indikator leuchtet, wenn das Anmeldeprompt erscheint. Dies zeigt an, dass das FreeBSD-System einen `getty` Prozess auf der entsprechenden Schnittstelle gestartet hat und das Modem auf einkommende Verbindungen wartet.

Wenn der DTR-Indikator nicht leuchtet, melden Sie sich an dem FreeBSD-System an und überprüfen mit `ps ax`, ob FreeBSD einen `getty`-Prozess auf der entsprechenden Schnittstelle gestartet hat:

[source,shell]
....
  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu1
....

Wenn das Modem noch keinen Anruf entgegengenommen hat und Sie stattdessen die folgende Zeile sehen

[source,shell]
....
114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyu0
....

bedeutet dies, dass `getty` die Schnittstelle schon geöffnet hat und zeigt Kabelprobleme oder eine falsche Modemkonfiguration an, da `getty` die Schnittstelle erst dann öffnen kann, wenn das CD Signal (Carrier Detect) vom Modem anliegt.

Wenn Sie keine `getty`-Prozesse auf den gewünschten [.filename]#ttyuN# Ports finden, untersuchen Sie [.filename]#/etc/ttys# auf Fehler. Suchen Sie auch in [.filename]#/var/log/messages# nach Meldungen von `init` oder `getty`. Wenn Sie dort Meldungen finden, sollten Sie noch einmal die beiden Konfigurationsdateien [.filename]#/etc/ttys# und [.filename]#/etc/gettytab# nach Fehlern durchsehen. Überprüfen Sie auch, ob die Gerätedateien [.filename]#/dev/ttyuN# vorhanden sind.

Versuchen Sie als nächstes, sich in das System einzuwählen. Auf dem entfernten System stellen Sie bitte die folgenden Kommunikationsparameter ein: 8 Bit, keine Parität, ein Stop-Bit. Wenn kein Anmeldeprompt erscheint oder nur unleserliche Zeichen, drücken Sie mehrmals, in Abständen von ungefähr einer Sekunde, kbd:[Enter]. Wenn Sie immer noch nicht die `login:` Meldung sehen, schicken Sie ein `BREAK` Kommando. Wenn Sie zur Einwahl ein Highspeed-Modem benutzen, verwenden Sie eine feste Geschwindigkeit auf der seriellen Schnittstelle des Modems.

Wenn jetzt immer noch kein Anmeldeprompt erscheint, überprüfen Sie nochmals [.filename]#/etc/gettytab# und stellen sicher, dass:

* der Verbindungstyp in [.filename]#/etc/ttys# zu einem gültigen Eintrag in [.filename]#/etc/gettytab# gehört.
* jeder der `nx=` Einträge in [.filename]#gettytab# gültig ist und
* jeder `tc=` Eintrag auf einen gültigen Eintrag in [.filename]#gettytab# verweist.

Wenn das Modem am FreeBSD-System auf einen eingehenden Anruf nicht antwortet, stellen Sie sicher, dass das Modem so konfiguriert ist, dass es einen Anruf beantwortet, wenn DTR anliegt. Wenn das Modem Statusindikatoren besitzt, können Sie das Anliegen von DTR anhand der Leuchten überprüfen.

Wenn Sie alles schon mehrfach überprüft haben und es immer noch noch nicht funktioniert, versuchen Sie es zu einem späteren Zeitpunkt erneut. Wenn es immer noch nicht funktioniert, können Sie eine Mail an die Mailingliste schicken, in der Sie Ihr Modem und Ihr Problem beschreiben.

[[dialout]]
== Verbindungen nach Außen

Die folgenden Ratschläge beschreiben, wie Sie mit einem Modem eine Verbindung zu einem anderen Computer herstellen. Dies können Sie nutzen, um sich auf einem entfernten Computer anzumelden.

Weiterhin ist diese Art von Verbindungen nützlich, wenn PPP mal nicht funktioniert. Wenn Sie zum Beispiel eine Datei mit FTP übertragen wollen und das über PPP gerade nicht möglich ist, melden Sie sich auf dem entfernten Rechner an und führen dort die FTP-Sitzung durch. Die Dateien können danach mit zmodem auf den lokalen Rechner übertragen werden.

[[hayes-unsupported]]
=== Ein Hayes Modem benutzen

Es gibt einen eingebauten, allgemeinen Hayes Wähler in `tip`. Verwenden Sie `at=hayes` in [.filename]#/etc/remote#.

Der Hayes-Treiber ist nicht schlau genug, um ein paar der erweiterten Funktionen von neueren Modems, bspw. `BUSY`, `NO DIALTONE` oder `CONNECT 115200` zu nutzen. Schalten Sie diese Nachrichten mit Hilfe von `ATX0W` ab, wenn Sie `tip` benutzen.

Der Anwahl-Timeout von `tip` beträgt 60 Sekunden. Das Modem sollte weniger verwenden, oder `tip` denkt, dass ein Kommunikationsfehler vorliegt. Versuchen Sie es mit `ATS7=45W`.

[[direct-at]]
=== `AT`-Befehle benutzen

Erstellen Sie einen `direct` Eintrag in [.filename]#/etc/remote#. Wenn das Modem zum Beispiel an der ersten seriellen Schnittstelle, [.filename]#/dev/cuad0#, angeschlossen ist, dann fügen Sie die folgende Zeile hinzu:

[.programlisting]
....
cuad0:dv=/dev/cuad0:br#19200:pa=none
....

Verwenden Sie die höchste bps-Rate, die das Modem in der `br` Fähigkeit unterstützt. Geben Sie dann `tip cuad0` ein und Sie sind mit dem Modem verbunden.

Oder benutzen Sie `cu` als `root` mit dem folgenden Befehl:

[source,shell]
....
# cu -lline -sspeed
....

_line_ steht für die serielle Schnittstelle ([.filename]#/dev/cuad0#) und _speed_ für die Geschwindigkeit (`57600`). Wenn Sie mit dem Eingeben der AT Befehle fertig sind, beenden Sie mit `~.`.

[[gt-failure]]
=== Das `@` Zeichen funktioniert nicht

Das `@` Zeichen in der Telefonnummerfähigkeit sagt `tip`, dass es in [.filename]#/etc/phones# nach einer Nummer suchen soll. Aber `@` ist auch ein spezielles Zeichen in den Dateien, in denen Fähigkeiten beschrieben werden, wie [.filename]#/etc/remote#. Schreiben Sie es mit einem Backslash:

[.programlisting]
....
pn=\@
....

[[dial-command-line]]
=== Wie kann ich von der Kommandozeile eine Telefonnummer wählen?

Setzen Sie einen allgemeinen Eintrag in [.filename]#/etc/remote#. Zum Beispiel:

[.programlisting]
....
tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:
....

Folgendes sollte jetzt funktionieren:

[source,shell]
....
# tip -115200 5551234
....

Benutzer, die `cu` gegenüber `tip` bevorzugen, können einen allgemeinen `cu`-Eintrag verwenden:

[.programlisting]
....
cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:
....

und benutzen zum Wählen das Kommando:

[source,shell]
....
# cu 5551234 -s 115200
....

[[set-bps]]
=== Die bps-Rate angeben

Schreiben Sie einen `tip1200`- oder einen `cu1200`-Eintrag, aber geben Sie auch die bps-Rate an, die das Modem wirklich unterstützt. Leider denkt man:tip[1], dass 1200 bps ein guter Standardwert ist und deswegen sucht es nach einem `tip1200`-Eintrag. Natürlich müssen Sie nicht 1200 bps benutzen.

[[terminal-server]]
=== Über einen Terminal-Server auf verschiedene Rechner zugreifen

Sie müssen nicht warten bis Sie verbunden sind, und jedes Mal `CONNECT _Rechner_` eingeben, benutzen Sie ``tip``s `cm`-Fähigkeit. Sie können diese Einträge in [.filename]#/etc/remote# verwenden. Mit den Befehlen `tip pain` oder `tip muffin` können Sie eine Verbindungen zu den Rechnern `pain` oder `muffin` herstellen; mit `tip deep13` verbinden Sie sich mit dem Terminalserver.

[.programlisting]
....
pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

[[tip-multiline]]
=== Mehr als eine Verbindung mit `tip` benutzen

Das ist oft ein Problem, wenn eine Universität mehrere Telefonleitungen hat und viele tausend Studenten diese benutzen wollen.

Erstellen Sie einen Eintrag in [.filename]#/etc/remote# und benutzen Sie `@` für die `pn`-Fähigkeit:

[.programlisting]
....
big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:
....

Listen Sie dann die Telefonnummern in [.filename]#/etc/phones# auf:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

`tip` probiert jede der Nummern in der aufgelisteten Reihenfolge und gibt dann auf. Möchten Sie, dass `tip` beim Versuchen eine Verbindung herzustellen nicht aufgibt, lassen Sie es in einer `while`-Schleife laufen.

[[multi-controlp]]
=== Eine Übertragung erzwingen

kbd:[Ctrl+P] ist das voreingestellte Zeichen, mit dem eine Übertragung erzwungen werden kann und wird benutzt, um `tip` zu sagen, dass das nächste Zeichen direkt gesendet werden soll und nicht als Fluchtzeichen interpretiert werden soll. Mit Hilfe der Fluchtsequenz `~s`, mit der man Variablen setzen kann, können Sie jedes andere Zeichen als "force"-Zeichen definieren.

Geben Sie `~sforce=_Zeichen_` gefolgt von kbd:[Enter] ein. Für _Zeichen_ können Sie ein beliebiges einzelnes Zeichen einsetzen. Wenn Sie _Zeichen_ weglassen, ist das "force"-Zeichen "nul", das Sie mit kbd:[Ctrl+2] oder kbd:[Ctrl+Leertaste] eingeben können. Ein guter Wert für _Zeichen_ ist kbd:[Shift+Ctrl+6], welches nur auf wenigen Terminal Servern benutzt wird.

Sie können das "force"-Zeichen auch bestimmen, indem Sie in [.filename]#$HOME/.tiprc# das Folgende einstellen:

[.programlisting]
....
force=single-char
....

[[uppercase]]
=== Großbuchstaben

Dies passiert, wenn kbd:[Ctrl+A] eingegeben wurde, das "raise"-Zeichen von `tip`, das speziell für Leute mit defekten caps-lock Tasten eingerichtet wurde. Benutzen Sie `~s` wie oben und setzen Sie die Variable `raisechar` auf etwas, das Ihnen angemessen erscheint. Tatsächlich kann die Variable auf das gleiche Zeichen wie das "force"-Zeichen gesetzt werden, wenn diese Fähigkeiten niemals benutzt werden sollen.

Hier ist ein Muster der [.filename]#.tiprc# Datei für Emacs Benutzer, die kbd:[Ctrl+2] und kbd:[Ctrl+A] tippen müssen:

[.programlisting]
....
force=^^
raisechar=^^
....

Geben Sie für `^^` kbd:[Shift+Ctrl+6] ein.

[[tip-filetransfer]]
=== Dateien mit `tip` übertragen

Wenn Sie mit einem anderen UNIX(R) System kommunizieren, können Sie mit `~p` (put) und `~t` (take) Dateien senden und empfangen. Diese Befehle lassen `cat` und `echo` auf dem entfernten System laufen, um Dateien zu empfangen und zu senden. Die Syntax ist:

`~p` local-file [ remote-file ]

`~t` remote-file [ local-file ]

Es gibt keine Fehlerkontrolle, deshalb sollte besser ein anderes Protokoll, wie zmodem, benutzt werden.

[[zmodem-tip]]
=== zmodem mit `tip` benutzen

Um Dateien zu empfangen, starten Sie das Programm zum Senden auf dem entfernten Computer. Geben Sie dann `~C rz` ein, um die Dateien lokal zu empfangen.

Um Dateien zu senden, starten Sie das Programm zum Empfangen auf dem entfernten Computer. Geben Sie dann `~C sz _Dateien_` ein, um Dateien auf das entfernte System zu senden.

[[serialconsole-setup]]
== Einrichten der seriellen Konsole

FreeBSD kann ein System mit einem Dumb-Terminal (unintelligente Datenstation) an einer seriellen Schnittstelle als Konsole booten. Diese Konfiguration ist besonders nützlich für Systemadministratoren, die FreeBSD auf Systemen ohne Tastatur oder Monitor installieren wollen, und Entwickler, die den Kernel oder Gerätetreiber debuggen.

Wie in crossref:boot[boot,FreeBSDs Bootvorgang] beschrieben, besitzt FreeBSD drei Bootphasen. Der Code für die ersten beiden Bootphasen befindet sich im Bootsektor am Anfang der FreeBSD-Slice der Bootplatte. Dieser Bootblock lädt den Bootloader in Phase drei.

Um eine serielle Konsole einzurichten, muss der Bootblock, der Bootloader und der Kernel konfiguriert werden.

[[serialconsole-howto-fast]]
=== Schnelle Konfiguration der seriellen Konsole

Dieser Abschnitt bietet einen schnellen Überblick über die Einrichtung einer seriellen Konsolen. Es wird vorausgesetzt, dass die Voreinstellungen verwendet werden.

[.procedure]
. Verbinden Sie die serielle Konsole mit [.filename]#COM1# sowie dem Kontrollterminal.
. Um die Startmeldungen der seriellen Konsole zu sehen, geben Sie als `root` folgendes ein:
+

[source,shell]
....
....

. Ändern Sie in [.filename]#/etc/ttys# den Eintrag für [.filename]#ttyu0# von `off` auf `on`. Zusätzlich sollten Sie den Wert `dialup` auf `vt100` ändern. Nur so wird auf der seriellen Konsole eine Eingabeaufforderung mit einer Passwortabfrage aktiviert.
. Starten Sie nun das System neu, damit die serielle Konsole aktiviert wird.

Wenn Sie eine unterschiedliche Konfiguration benötigen, lesen Sie den nächsten Abschnitt für eine tiefer gehende Erklärung.

[[serialconsole-howto]]
=== Konfiguration der seriellen Konsole

[.procedure]
****
. Bereiten Sie ein serielles Kabel vor.
+ 
Sie benötigen entweder ein Nullmodemkabel oder ein serielles Standard Kabel mit einem Nullmodemkabel-Adapter. In <<term-cables-null>> werden serielle Kabel beschrieben.
. Trennen Sie die Tastatur vom Computer.
+ 
Viele PC Systeme suchen beim Power On Self Test (POST) nach einer Tastatur und geben eine Fehlermeldung aus, wenn sie keine finden. Einige Maschinen werden sich sogar weigern, ohne Tastatur zu booten.
+ 
Wenn der Rechner trotz einer Fehlermeldung normal weiterbootet, brauchen Sie weiter nichts zu tun.
+ 
Wenn das System ohne Tastatur nicht booten will, müssen Sie das BIOS so konfigurieren, dass es diesen Fehler ignoriert (wenn das möglich ist). Das Handbuch zum Motherboard sollte beschreiben, wie das zu bewerkstelligen ist.
+
[TIP]
====

Selbst wenn Sie im BIOS "Not installed" für die Tastatur einstellen, können Sie eine Tastatur angeschlossen haben und diese auch weiterhin benutzen, da sie mit dieser Anweisung das BIOS lediglich anweisen, nach dem Einschalten des Rechners nicht nach einer Tastatur zu suchen und den Rechner ohne entsprechende Fehlermeldung zu starten. Wenn die oben beschriebene Option nicht im BIOS vorhanden ist, halten Sie stattdessen Ausschau nach einer "Halt on Error" Option. Sie können den gleichen Effekt wie oben erzielen, wenn Sie diese Option auf "All but Keyboard" oder sogar "No Errors" setzen.
====
+
[NOTE]
====
Wenn das System über eine PS/2(R) Maus verfügt, müssen Sie diese wahrscheinlich auch abziehen. Da sich die PS/2(R) Maus und die Tastatur einige Hardwarekomponenten teilen, kann das dazu führen, dass die Hardwareerkennung fälschlicherweise eine Tastatur findet, wenn eine PS/2(R) Maus angeschlossen ist.
====

. Schließen Sie einen Dumb-Terminal an [.filename]#COM1# ([.filename]#sio0#) an.
+ 
Wenn Sie keinen Dumb-Terminal besitzen, können Sie einen alten Computer mit einem Terminalemulator oder die serielle Schnittstelle eines anderen UNIX(R) Rechners benutzen. Sie benötigen auf jeden Fall eine freie erste serielle Schnittstelle ([.filename]#COM1#). Zurzeit ist es nicht möglich, in den Bootblöcken eine andere Schnittstelle zu konfigurieren, ohne diese neu zu kompilieren. Wenn Sie [.filename]#COM1# bereits für ein anderes Gerät benutzen, müssen Sie dieses Gerät temporär entfernen und einen neuen Bootblock sowie Kernel installieren, wenn FreeBSD erst einmal installiert ist.
. Stellen Sie sicher, dass die Kernelkonfiguration die richtigen Optionen für [.filename]#COM1# ([.filename]#sio0#) enthält.
+ 
Relevante Optionen sind:
+
`0x10`:::
Aktiviert die Konsolenunterstützung für dieses Gerät. Zurzeit kann nur ein Gerät die Konsolenunterstützung aktiviert haben. Das erste, in der Konfigurationsdatei aufgeführte Gerät, mit dieser Option, verfügt über eine aktivierte Konsolenunterstützung. Beachten Sie, dass diese Option alleine nicht ausreicht, um die serielle Konsole zu aktivieren. Setzen Sie entweder noch die nachfolgend diskutierte Option oder verwenden Sie beim Booten, wie unten beschrieben, den Schalter `-h`.

`0x20`:::
Das erste Gerät in der Kernelkonfigurationsdatei mit dieser Option wird, unabhängig von dem unten diskutierten Schalter `-h`, zur Konsole. Die Option `0x20` muss zusammen mit `0x10` verwendet werden.

`0x40`:::
Reserviert dieses Gerät und sperrt es für normale Zugriffe. Sie sollten diese Option nicht auf dem Gerät setzen, das Sie als serielle Konsole verwenden wollen. Der Zweck dieser Option ist es, dieses Gerät für das Remote-Debuggen zu reservieren. Das extref:{developers-handbook}[FreeBSD Developers' Handbook] enthält dazu weitere Informationen.
+ 
Beispiel:
+
[.programlisting]
....
device sio0 at isa? port IO_COM1 tty flags 0x10 irq 4
....
+ 
Weitere Einzelheiten finden Sie in man:sio[4].
+ 
Wenn diese Optionen nicht gesetzt sind, müssen Sie auf einer anderen Konsole beim Booten UserConfig starten oder den Kernel neu kompilieren.
. Erstellen Sie [.filename]#boot.config# im Rootverzeichnis der `a`-Partition des Bootlaufwerks.
+ 
Der Code des Bootblocks entnimmt dieser Datei, wie Sie Ihr System booten möchten. Um die serielle Konsole zu aktivieren, müssen Sie hier eine oder mehrere Optionen (alle in derselben Zeile) angeben. Die folgenden Optionen stehen zur Auswahl der Konsole zur Verfügung:
+
`-h`:::
Schaltet zwischen der internen und der seriellen Konsole um. Wenn Sie beispielsweise von der internen Konsole (Bildschirm) booten, weist `-h` den Bootloader und den Kernel an, die serielle Schnittstelle als Konsole zu nehmen. Wenn die Konsole normal auf der seriellen Schnittstelle liegt, wählen Sie mit `-h` den Bildschirm aus.

`-D`:::
Schaltet zwischen Einzelkonsole und Dual-Konsole um. Die Einzelkonsole ist entweder die interne Konsole (der Bildschirm) oder die serielle Schnittstelle, je nach dem Stand von `-h`. Im Dual-Konsolen Betrieb ist die Konsole, unabhängig von `-h`, gleichzeitig der Bildschirm und die serielle Schnittstelle. Dies trifft aber nur zu, wenn der Bootblock ausgeführt wird. Sobald der Bootloader ausgeführt wird, wird die durch `-h` gegebene Konsole die alleinige Konsole.

`-P`:::
Veranlasst den Bootblock nach einer Tastatur zu suchen. Wenn keine Tastatur gefunden wird, werden `-D` und `-h` automatisch gesetzt.
+
[NOTE]
====
Wegen Platzbeschränkungen in den Bootblöcken kann `-P` nur erweiterte Tastaturen erkennen. Tastaturen mit weniger als 101 Tasten und ohne F11 und F12 Tasten werden wahrscheinlich, wie vielleicht auch die Tastaturen einiger Laptops, nicht erkannt. Wenn das der Fall ist, können Sie `-P` nicht verwenden, da es leider keine Abhilfe für dieses Problem gibt.
====
+ 
Benutzen Sie also entweder `-P`, um die Konsole automatisch zu setzen, oder `-h`, um die serielle Konsole zu verwenden.
+ 
Weitere Optionen werden in man:boot[8] beschrieben.
+ 
Mit Ausnahme von `-P` werden die Optionen an den Bootloader weitergegeben. Der Bootloader untersucht dann einzig `-h` um festzustellen, welches Gerät die Konsole wird. Wenn Sie also nur `-D` angegeben haben, können Sie die serielle Schnittstelle nur als Konsole verwenden während der Bootblock ausgeführt wird. Danach wird der Bootloader, da ja `-h` fehlt, den Bildschirm zur Konsole machen.
. Booten Sie die Maschine.
+ 
Wenn Sie das FreeBSD-System starten, werden die Bootblöcke den Inhalt von [.filename]#/boot.config# auf der Konsole ausgeben:
+
[source,shell]
....
/boot.config: -P
Keyboard: no
....
+ 
Die zweite Zeile sehen Sie nur, wenn Sie in [.filename]#/boot.config#`-P` angegeben haben. Sie zeigt an, ob eine Tastatur angeschlossen ist oder nicht. Die Meldungen gehen je nach den Einstellungen in [.filename]#/boot.config# auf die interne Konsole, die serielle Konsole, oder beide Konsolen.
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
<| Optionen
<| Meldungen erscheinen auf

|keine
|der internen Konsole

|`-h`
|der seriellen Konsole

|`-D`
|der seriellen und der internen Konsole

|`-Dh`
|der seriellen und der internen Konsole

|`-P`, mit Tastatur
|der internen Konsole

|`-P`, ohne Tastatur
|der seriellen Konsole
|===
+ 
Nach den oben gezeigten Meldungen gibt es eine kleine Verzögerung bevor die Bootblöcke den Bootloader laden und weitere Meldungen auf der Konsole erscheinen. Sie können die Ausführung der Bootblöcke unterbrechen, um zu überprüfen, ob auch alles richtig aufgesetzt ist, brauchen das aber unter normalen Umständen nicht zu tun.
+ 
Drücken Sie eine Taste außer kbd:[Enter] um den Bootvorgang zu unterbrechen. Sie erhalten dann ein Prompt, an dem Sie weitere Eingaben tätigen können:
+
[source,shell]
....
FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....
+ 
Je nach Inhalt von [.filename]#/boot.config# erscheint das Prompt auf der seriellen Konsole, der internen Konsole oder beiden Konsolen. Wenn die Meldung auf der richtigen Konsole erscheint, drücken Sie kbd:[Enter] um fortzufahren.
+ 
Wenn kein Prompt auf der seriellen Konsole erscheint, liegt ein Fehler in den Einstellungen vor. Als Abhilfe geben Sie an der momentanen Konsole `-h` ein, um den Bootblock und den Bootloader auf die serielle Konsole umzustellen. Führen Sie dann den Bootvorgang mit kbd:[Enter] weiter und wenn das System gebootet hat, können Sie die fehlerhaften Einstellungen korrigieren.
****

Während der dritten Bootphase können Sie immer noch zwischen der internen und der seriellen Konsole auswählen. Setzen Sie dazu, wie in <<serialconsole-loader>> beschrieben, die entsprechenden Variablen des Bootloaders.

[[serialconsole-summary]]
=== Zusammenfassung

Die folgende Tabelle bietet eine Zusammenfassung der verschiedenen Einstellungen, die in diesem Abschnitt diskutiert wurden:

.Fall 1: Option 0x10 für [.filename]#sio0#
[cols="1,1,1,1", frame="none", options="header"]
|===
<| Optionen in /boot.config
<| Konsole in den Bootblöcken
<| Konsole im Bootloader
<| Konsole im Kernel

|keine
|interne
|interne
|interne

|`-h`
|serielle
|serielle
|serielle

|`-D`
|serielle und interne
|interne
|interne

|`-Dh`
|serielle und interne
|serielle
|serielle

|`-P`, mit Tastatur
|interne
|interne
|interne

|`-P`, ohne Tastatur
|serielle und interne
|serielle
|serielle
|===

.Fall 2: Option 0x30 für [.filename]#sio0#
[cols="1,1,1,1", frame="none", options="header"]
|===
<| Optionen in /boot.config
<| Konsole in den Bootblöcken
<| Konsole im Bootloader
<| Konsole im Kernel

|keine
|interne
|interne
|serielle

|`-h`
|serielle
|serielle
|serielle

|`-D`
|serielle und interne
|interne
|serielle

|`-Dh`
|serielle und interne
|serielle
|serielle

|`-P`, mit Tastatur
|interne
|interne
|serielle

|`-P`, ohne Tastatur
|serielle und interne
|serielle
|serielle
|===

[[serialconsole-tips]]
=== Hinweise zur seriellen Konsole

==== Verwenden einer höheren Geschwindigkeit

Die Vorgabewerte für die Kommunikationsparameter der seriellen Schnittstelle sind: 9600 baud, 8 Bit, keine Parität und ein Stopp-Bit. Um die Standardgeschwindigkeit zu ändern, stehen folgende Möglichkeiten zur Verfügung:

* Geben Sie die neue Konsolengeschwindigkeit mit `BOOT_COMCONSOLE_SPEED` an und kompilieren Sie die Bootblöcke neu. Ausführliche Informationen zum Bau und zur Installation von neuen Bootblöcken finden Sie im <<serialconsole-com2>> des Handbuchs.
+ 
Wenn die serielle Konsole nicht mit der Option `-h` gestartet wird, oder wenn die verwendete serielle Konsole sich von der von den Bootblöcken verwendeten unterscheidet, müsssen Sie zusätzlich die folgende Option in die Kernelkonfigurationsdatei aufnehmen und den Kernel neu bauen:
+
[.programlisting]
....
options CONSPEED=19200
....

* Verwenden Sie die Option `-S`, um den Kernel zu booten. Eine Beschreibung dieses Vorgangs sowie eine Auflistung der von [.filename]#/boot.config# unterstützten Optionen finden Sie in man:boot[8].
* Aktivieren Sie die Option `comconsole_speed` in [.filename]#/boot/loader.conf#.
+ 
Diese Option setzt voraus, dass auch die Optionen `console`, `boot_serial`, sowie `boot_multicons` in [.filename]#/boot/loader.conf# gesetzt sind. Im Folgenden finden Sie ein Beispiel, in dem `comconsole_speed` verwendet wird, um die Geschwindigkeit der seriellen Konsole zu ändern:
+
[.programlisting]
....
boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"
....

[[serialconsole-com2]]
==== Eine andere Schnittstelle als [.filename]#sio0# benutzen

Wenn Sie, warum auch immer, ein anderes Gerät als [.filename]#sio0# für die serielle Konsole einsetzen wollen, kompilieren Sie bitte die Bootblöcke, den Bootloader und den Kernel nach dem folgenden Verfahren neu.

[.procedure]
. Installieren Sie die Kernelquellen wie im crossref:cutting-edge[updating-upgrading,FreeBSD aktualisieren] beschrieben.
. Setzen Sie in [.filename]#/etc/make.conf#`BOOT_COMCONSOLE_PORT` auf die Adresse der Schnittstelle (0x3F8, 0x2F8, 0x3E8 oder 0x2E8), die Sie benutzen möchten. Sie können nur [.filename]#sio0# bis [.filename]#sio3# ([.filename]#COM1# bis [.filename]#COM4#) benutzen, Multiportkarten können Sie nicht als Konsole benutzen. Interrupts müssen Sie hier nicht angeben.
. Erstellen Sie eine angepasste Kernelkonfiguration und geben Sie dort die richtigen Optionen für die Schnittstelle, die Sie benutzen möchten, an. Wenn Sie zum Beispiel [.filename]#sio1# ([.filename]#COM2#) zur Konsole machen wollen, geben Sie dort entweder
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 tty flags 0x10 irq 3
....
+ 
oder
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 tty flags 0x30 irq 3
....
+ 
an. Keine andere serielle Schnittstelle sollte als Konsole definiert werden.
. Übersetzen und installieren Sie die Bootblöcke und den Bootloader:
+

[source,shell]
....
# cd /sys/boot
# make clean
# make
# make install
....

. Bauen und installieren Sie einen neuen Kernel.
. Schreiben Sie die Bootblöcke mit man:bsdlabel[8] auf die Bootplatte und booten Sie den neuen Kernel.

[[serialconsole-ddb]]
==== DDB Debugger über die serielle Schnittstelle

Wenn Sie den Kerneldebugger über eine serielle Verbindung bedienen möchten, übersetzen Sie einen angepassten Kernel mit den folgenden Optionen. Das ist nützlich, kann aber gefährlich sein, wenn auf der Leitung falsche BREAK-Signale generiert werden.

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....

==== Benutzung der seriellen Konsole zum Anmelden

Da Sie schon die Bootmeldungen auf der Konsole verfolgen können und den Kerneldebugger über die Konsole bedienen können, wollen Sie sich vielleicht auch an der Konsole anmelden.

Öffnen Sie [.filename]#/etc/ttys# in einem Editor und suchen Sie nach den folgenden Zeilen:

[.programlisting]
....
ttyu0 "/usr/libexec/getty std.9600" unknown off secure
ttyu1 "/usr/libexec/getty std.9600" unknown off secure
ttyu2 "/usr/libexec/getty std.9600" unknown off secure
ttyu3 "/usr/libexec/getty std.9600" unknown off secure
....

[.filename]#ttyu0# bis [.filename]#ttyu3# entsprechen [.filename]#COM1# bis [.filename]#COM4#. Ändern Sie für die entsprechende Schnittstelle `off` zu `on`. Wenn Sie auch die Geschwindigkeit der seriellen Schnittstelle geändert haben, müssen Sie `std.9600` auf die momentane Geschwindigkeit anpassen.

Auch kann den Terminaltyp von `unknown` auf den tatsächlich verwendeten Terminal gesetzt werden.

Damit die Änderungen wirksam werden, müssen Sie noch `kill -HUP 1` absetzen.

[[serialconsole-loader]]
=== Die Konsole im Bootloader ändern

In den vorigen Abschnitten wurde beschrieben, wie Sie die serielle Konsole durch Änderungen im Bootblock aktivieren. Dieser Abschnitt zeigt, wie Sie mit Kommandos und Umgebungsvariablen die Konsole im Bootloader definieren. Da der Bootloader die dritte Phase im Bootvorgang ist und nach den Bootblöcken ausgeführt wird, überschreiben seine Einstellungen die des Bootblocks.

==== Festlegen der Konsole

Mit einer einzigen Zeile in [.filename]#/boot/loader.conf# können Sie den Bootloader und den Kernel anweisen, die serielle Schnittstelle zur Konsole zu machen:

[.programlisting]
....
console="comconsole"
....

Unabhängig von den Einstellungen im Bootblock legt dies die Konsole fest.

Die obige Zeile sollte die erste Zeile in [.filename]#/boot/loader.conf# sein, so dass die Bootmeldungen so früh wie möglich auf der Konsole zu sehen sind.

Analog können Sie die interne Konsole verwenden:

[.programlisting]
....
console="vidconsole"
....

Wenn die Umgebungsvariable `console` nicht gesetzt ist, bestimmt der Bootloader und damit auch der Kernel, die Konsole über die `-h` Option des Bootblocks.

Die Bootkonsole kann in [.filename]#/boot/loader.conf.local# oder [.filename]#/boot/loader.conf# angegeben werden.

Weitere Informationen erhalten Sie in man:loader.conf[5].

[NOTE]
====
Momentan gibt es im Bootloader nichts vergleichbares zu `-P` im Bootblock. Damit kann die Konsole nicht automatisch über das Vorhandensein einer Tastatur festgelegt werden.
====

==== Eine andere Schnittstelle als [.filename]#sio0# benutzen

Der Bootloader muss neu kompiliert werden, wenn eine andere Schnittstelle als [.filename]#sio0# benutzt werden soll. Folgen Sie der Anleitung aus <<serialconsole-com2>>.

[[serialconsole-caveats]]
=== Vorbehalte

Obwohl es die meisten Systeme erlauben, ohne Tastatur zu booten, gibt es nur wenige Systeme, die ohne eine Grafikkarte booten. Maschinen mit einem AMI BIOS können ohne Grafik booten, indem Sie den Grafikadapter im CMOS-Setup auf `Not installed` setzen.

Viele Maschinen unterstützen diese Option allerdings nicht. Damit diese Maschinen booten, müssen sie über eine Grafikkarte, auch wenn es nur eine alte Monochromkarte ist, verfügen. Allerdings brauchen Sie keinen Monitor an die Karte anzuschließen. Sie können natürlich auch versuchen, auf diesen Maschinen ein AMI BIOS zu installieren.
