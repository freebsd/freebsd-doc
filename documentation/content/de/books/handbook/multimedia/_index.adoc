---
title: Kapitel 7. Multimedia
part: Teil II. Oft benutzte Funktionen
prev: books/handbook/desktop
next: books/handbook/kernelconfig
---

[[multimedia]]
= Multimedia
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:table-caption: Tabelle
:figure-caption: Abbildung
:example-caption: Beispiel
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 7

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/de/mailing-lists.adoc[]
include::shared/de/teams.adoc[]
include::shared/de/urls.adoc[]

toc::[]

[[multimedia-synopsis]]
== Übersicht

FreeBSD unterstützt viele unterschiedliche Soundkarten, die Benutzern den Genuss von Highfidelity-Klängen auf dem Computer ermöglichen. Dazu gehört unter anderem die Möglichkeit, Tonquellen in den Formaten MPEG Audio Layer 3 (MP3), Waveform Audio File (WAV), Ogg Vorbis und vielen weiteren Formaten aufzunehmen und wiederzugeben. Darüber hinaus enthält die FreeBSD Ports-Sammlung Anwendungen, die das Bearbeiten von aufgenommenen Tonspuren, das Hinzufügen von Klangeffekten und die Kontrolle der angeschlossenen MIDI-Geräte erlauben.

FreeBSD unterstützt auch die Wiedergabe von Videos und DVDs. Die FreeBSD Ports-Sammlung enthält Anwendungen, um verschiedene Video-Medien wiederzugeben, zu kodieren und zu konvertieren.

Dieses Kapitel beschreibt die Einrichtung von Soundkarten, Video-Wiedergabe, TV-Tuner Karten und Scannern unter FreeBSD. Es werden auch einige Anwendungen beschrieben, die für die Verwendung dieser Geräte zur Verfügung stehen.

Dieses Kapitel behandelt die folgenden Punkte:

* Konfiguration einer Soundkarte in FreeBSD.
* Fehlersuche bei Sound Einstellungen.
* Wiedergabe und Kodierung von MP3s und anderen Audio-Formaten.
* Vorbereitung des Systems für die Wiedergabe von Videos.
* Wiedergabe von DVDs, [.filename]#.mpg#- und [.filename]#.avi#-Dateien.
* Rippen von CDs und DVDs.
* Konfiguration von TV-Karten.
* Installation und Konfiguration von MythTV.
* Konfiguration von Scannern
* Konfiguration von Bluetooth-Kopfhörern

Bevor Sie dieses Kapitel lesen, sollten Sie:

* Wissen, wie Sie Anwendungen installieren (crossref:ports[ports,Installieren von Anwendungen: Pakete und Ports]).

[[sound-setup]]
== Soundkarten einrichten

Bevor Sie die Konfiguration beginnen, sollten Sie in Erfahrung bringen welches Soundkartenmodell und welcher Chip benutzt wird. FreeBSD unterstützt eine Reihe Soundkarten. Die link:{u-rel120-hardware}[Hardware-Notes] zählen alle unterstützten Karten und deren Treiber für FreeBSD auf.

Um die Soundkarte benutzen zu können, muss der richtige Gerätetreiber geladen werden. Am einfachsten ist es, das Kernelmodul für die Soundkarte mit man:kldload[8] zu laden. Dieses Beispiel lädt den Treiber für einen integrierten Chipsatz, basierend auf der Intel Spezifikation:

[source,bash]
....
# kldload snd_hda
....

Um den Treiber automatisch beim Systemstart zu laden, fügen Sie folgende Zeile in [.filename]#/boot/loader.conf# ein:

[.programlisting]
....
snd_hda_load="YES"
....

Weitere ladbare Soundmodule sind in [.filename]#/boot/defaults/loader.conf# aufgeführt. Wenn Sie nicht sicher sind, welchen Gerätetreiber Sie laden müssen, laden Sie das Modul [.filename]#snd_driver#:

[source,bash]
....
# kldload snd_driver
....

Der Treiber [.filename]#snd_driver# ist ein Meta-Treiber, der alle gebräuchlichen Treiber lädt und die Suche nach dem richtigen Treiber vereinfacht. Durch Hinzufügen des Meta-Treibers in [.filename]#/boot/loader.conf# können alternativ alle Audio-Treiber geladen werden.

Um zu ermitteln, welcher Treiber für die Soundkarte vom Meta-Treiber [.filename]#snd_driver# geladen wurde, geben Sie `cat /dev/sndstat` ein.

=== Soundkarten in der Kernelkonfiguration einrichten

Die Unterstützung für die Soundkarte kann auch direkt in den Kernel kompiliert werden. Weitere Informationen über den Bau eines Kernels finden Sie im crossref:kernelconfig[kernelconfig,Konfiguration des FreeBSD-Kernels].

Bei der Verwendung eines eigenen Kernels müssen Sie sicherstellen, dass der Treiber für das Audio-Framework in der Kernelkonfigurationsdatei vorhanden ist:

[.programlisting]
....
device sound
....

Als Nächstes muss die Unterstützung für die Soundkarte hinzugefügt werden. Um das Beispiel mit dem integrierten Intel Audio-Chipsatz aus dem vorherigen Abschnitt fortzusetzen, verwenden Sie die folgende Zeile in der Kernelkonfigurationsdatei:

[.programlisting]
....
device snd_hda
....

Lesen Sie die Manualpage des Treibers, um den entsprechenden Gerätenamen herauszufinden.

Nicht PnP-fähige ISA-Soundkarten benötigen eventuell Einstellungen, wie IRQ und I/O-Port in [.filename]#/boot/device.hints#. Während des Systemstarts liest der man:loader[8] diese Datei und reicht die Einstellungen an den Kernel weiter. Für eine alte Creative SoundBlaster(R) 16 ISA-Karte, die sowohl den man:snd_sbc[4]- als auch den `snd_sb16`-Treiber benötigt, müssen die folgenden Zeilen in die Kernelkonfigurationsdatei eingetragen werden:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

Wenn die Karte den I/O-Port `0x220` und IRQ `5` benutzt, müssen folgende Zeilen zusätzlich in [.filename]#/boot/device.hints# hinzugefügt werden:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

Die Syntax für [.filename]#/boot/device.hints# wird in man:sound[4], sowie in der Manualpage des jeweiligen Treibers beschrieben.

Das Beispiel verwendet die vorgegebenen Werte. Falls die Karteneinstellungen andere Werte vorgeben, müssen die Werte in der Kernelkonfiguration angepasst werden. Weitere Informationen zu dieser Soundkarte finden Sie in man:snd_sbc[4].

[[sound-testing]]
=== Die Soundkarte testen

Nachdem Sie den neuen Kernel gestartet oder das erforderliche Modul geladen haben, sollte die Soundkarte erkannt werden. Führen Sie `dmesg | grep pcm` aus, um dies zu überprüfen. Diese Ausgabe stammt von einem System mit einem integrierten Conexant CX20590 Chipsatz:

[source,bash]
....
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 5 on hdaa0
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 6 on hdaa0
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> at nid 31,25 and 35,27 on hdaa1
....

Der Status der Karte kann auch mit diesem Kommando geprüft werden:

[source,bash]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm: 64bit 2009061500/amd64)
Installed devices:
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> (play/rec) default
....

Die Ausgabe kann für jede Soundkarte anders aussehen. Wenn das Gerät [.filename]#pcm# nicht erscheint, prüfen Sie die Kernelkonfigurationsdatei und stellen Sie sicher, dass der richtige Treiber geladen oder in den Kernel kompiliert wurde. Im nächsten Abschnitt werden häufig auftretende Probleme sowie deren Lösungen besprochen.

Jetzt sollte die Soundkarte unter FreeBSD funktionieren. Wenn ein CD- oder DVD-Laufwerk an die Soundkarte angeschlossen ist, können Sie jetzt mit man:cdcontrol[1] eine CD abspielen:

[source,bash]
....
% cdcontrol -f /dev/acd0 play 1
....

[WARNING]
====

Audio CDs besitzen eine spezielle Kodierung. Daher sollten sie nicht mit man:mount[8] in das Dateisystem eingehangen werden.
====

Es gibt viele Anwendungen, wie package:audio/workman[], die eine bessere Benutzerschnittstelle besitzen. Zur Wiedergabe von MP3-Audiodateien kann package:audio/mpg123[] installiert werden.

Eine weitere schnelle Möglichkeit die Karte zu prüfen, ist es, Daten an das Gerät [.filename]#/dev/dsp# zu senden:

[source,bash]
....
% cat Datei > /dev/dsp
....

Für [.filename]#Datei# kann eine beliebige Datei verwendet werden. Wenn Sie einige Geräusche hören, funktioniert die Soundkarte.

[NOTE]
====
Die Gerätedateien [.filename]#/dev/dsp*# werden automatisch erzeugt, wenn sie das erste Mal benötigt werden. Werden sie nicht verwendet, sind sie hingegen nicht vorhanden und tauchen daher auch nicht in der Ausgabe von man:ls[1] auf.
====

[[bluetooth-headset]]
=== Konfiguration von Bluetooth-Soundgeräten

Die Verbindung zu einem Bluetooth-Gerät wird in diesem Abschnitt nicht erläutert. Dazu finden Sie weitere Informationen in crossref:advanced-networking[network-bluetooth,“Bluetooth”].

Damit Bluetooth zusammen mit dem Soundsystem von FreeBSD funktioniert, müssen Benutzer zuerst package:audio/virtual_oss[] installieren:

[source,bash]
....
# pkg install virtual_oss
....

package:audio/virtual_oss[] setzt voraus, dass `cuse` in den Kernel geladen wird:

[source,bash]
....
# kldload cuse
....

Führen Sie folgenden Befehl aus, damit `cuse` beim Systemstart automatisch geladen wird:

[source,bash]
....
# sysrc -f /boot/loader.conf cuse_load=yes
....

Um Kopfhörer mit package:audio/virtual_oss[] zu benutzten, muss nach der Verbindung mit einem Bluetooth-Audiogerät ein virtuelles Gerät erstellt werden:

[source,bash]
....
# virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp
....

[NOTE]
====
`_headphones_` ist in diesem Beispiel ein Hostname aus [.filename]#/etc/bluetooth/hosts#. Stattdessen kann auch `BT_ADDR` verwendet werden.
====

Weitere Informationen finden Sie in man:virtual_oss[8].

[[troubleshooting]]
=== Fehlerbehebung

<<multimedia-sound-common-error-messages>> zeigt typische Fehlermeldungen sowie deren Lösungen:

[[multimedia-sound-common-error-messages]]
.Typische Fehlermeldungen
[cols="30%,70%", frame="none", options="header"]
|===
| Fehler
| Lösung

|`sb_dspwr(XX) timed out`
|

Der I/O-Port ist nicht korrekt angegeben.

|`bad irq XX`
|

Der IRQ ist falsch angegeben. Stellen Sie sicher, dass der angegebene IRQ mit dem Sound IRQ übereinstimmt.

|`xxx: gus pcm not attached, out of memory`
|

Es ist nicht genug Speicher verfügbar, um das Gerät zu betreiben.

|`xxx: can't open /dev/dsp!`
|

Überprüfen Sie mit `fstat | grep dsp` ob eine andere Anwendung das Gerät geöffnet hat. Häufige Störenfriede sind esound oder die Sound-Unterstützung von KDE.
|===

Moderne Grafikkarten beinhalten oft auch ihre eigenen Soundtreiber, um HDMI zu verwenden. Diese Audiogeräte werden manchmal vor der eigentlichen, separaten Soundkarte aufgeführt und dadurch nicht als das Standardgerät zum Abspielen von Tönen benutzt. Um zu prüfen, ob das der Fall ist, führen Sie dmesg aus und suchen Sie nach der Zeichenfolge `pcm`. Die Ausgabe sieht in etwa so aus:

[.programlisting]
....
...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 0 nid 1 on hdac0
pcm1: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 1 nid 1 on hdac0
pcm2: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 2 nid 1 on hdac0
pcm3: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: <HDA Realtek ALC889 PCM #0 Analog> at cad 2 nid 1 on hdac1
pcm5: <HDA Realtek ALC889 PCM #1 Analog> at cad 2 nid 1 on hdac1
pcm6: <HDA Realtek ALC889 PCM #2 Digital> at cad 2 nid 1 on hdac1
pcm7: <HDA Realtek ALC889 PCM #3 Digital> at cad 2 nid 1 on hdac1
...
....

In diesem Beispiel wurde die Grafikkarte (`NVidia`) vor der Soundkarte (`Realtek ALC889`) aufgeführt. Um die Soundkarte als Standardabspielgerät einzusetzen, ändern Sie `hw.snd.default_unit` auf die Einheit, welche für das Abspielen benutzt werden soll:

[source,bash]
....
# sysctl hw.snd.default_unit=n
....

Hier repräsentiert `n` die Nummer der Soundkarte, die verwendet werden soll, in diesem Beispiel also `4`. Sie können diese Änderung dauerhaft machen, indem Sie die folgende Zeile in [.filename]#/etc/sysctl.conf# hinzufügen:

[.programlisting]
....
hw.snd.default_unit=4
....

[[sound-multiple-sources]]
=== Mehrere Tonquellen abspielen

Oft sollen mehrere Tonquellen gleichzeitig abgespielt werden. FreeBSD verwendet dazu _virtuelle Tonkanäle_. Virtuelle Kanäle mischen die Tonquellen im Kernel, sodass mehrere Kanäle benutzt werden können, als von der Hardware unterstützt werden.

Drei man:sysctl[8] Optionen stehen zur Konfiguration der virtuellen Kanäle zur Verfügung:

[source,bash]
....
# sysctl dev.pcm.0.play.vchans=4
# sysctl dev.pcm.0.rec.vchans=4
# sysctl hw.snd.maxautovchans=4
....

Im Beispiel werden vier virtuelle Kanäle eingerichtet, eine im Normalfall ausreichende Anzahl. Sowohl `dev.pcm.0.play.vchans=4` und `dev.pcm.0.rec.vchans=4` sind die Anzahl der virtuellen Kanäle des Geräts [.filename]#pcm0#, die fürs Abspielen und Aufnehmen verwendet werden und sie können konfiguriert werden, sobald das Gerät existiert. Da das Modul [.filename]#pcm# unabhängig von den Hardware-Treibern geladen werden kann, gibt `hw.snd.maxautovchans` die Anzahl der virtuellen Kanäle an, die später eingerichtete Audiogeräte erhalten. Lesen Sie man:pcm[4] für weitere Informationen.

[NOTE]
====
Die Anzahl der virtuellen Kanäle kann nicht geändert werden, solange das Gerät genutzt wird. Schließen Sie daher zuerst alle Programme wie Musikabspielprogramme oder Sound-Daemonen, die auf dieses Gerät zugreifen.
====

Die korrekte [.filename]#pcm#-Gerätedatei wird automatisch zugeteilt, wenn ein Programm das Gerät [.filename]#/dev/dsp0# anfordert.

=== Den Mixer einstellen

Die Voreinstellungen des Mixers sind im Treiber man:pcm[4] fest kodiert. Es gibt zwar viele Anwendungen und Dienste, die den Mixer einstellen können und die eingestellten Werte bei jedem Start wieder setzen, am einfachsten ist es allerdings, die Standardwerte für den Mixer direkt im Treiber einzustellen. Der Mixer kann mit den entsprechenden Werten in [.filename]#/boot/device.hints# eingestellt werden:

[.programlisting]
....
hint.pcm.0.vol="50"
....

Die Zeile setzt die Lautstärke des Mixers beim Laden des Moduls man:pcm[4] auf den Wert `50`.

[[sound-mp3]]
== MP3-Audio

Dieser Abschnitt beschreibt einige unter FreeBSD verfügbare MP3-Player. Zudem wird beschrieben, wie Audio-CDs gerippt und MP3s kodiert und dekodiert werden.

[[mp3-players]]
=== MP3-Player

Ein beliebter graphischer MP3-Player ist Audacious, welcher WinAmp-Skins und zusätzliche Plugins unterstützt. Die Benutzerschnittstelle ist leicht zu erlernen und enthält eine Playlist, einen graphischen Equalizer und vieles mehr. Diejenigen, die bereits mit WinAmp vertraut sind, werden Audacious sehr leicht zu benutzen finden. Unter FreeBSD kann Audacious als Port oder Paket package:multimedia/audacious[] installiert werden. Audacious ist ein Ableger von XMMS.

Das Paket package:audio/mpg123[] ist ein alternativer, kommandozeilenorientierter MP3-Player. Nach der Installation kann die abzuspielende MP3-Datei auf der Kommandozeile angegeben werden. Geben Sie auch das entsprechende Soundkarte an, falls das System über mehrere Audiogeräte verfügt:

[source,bash]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3
        version 1.18.1; written and copyright by Michael Hipp and others
        free software (LGPL) without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

Weitere MP3-Player stehen in der FreeBSD Ports-Sammlung zur Verfügung.

[[rip-cd]]
=== CD-Audio Tracks rippen

Bevor eine ganze CD oder einen CD-Track in das MP3-Format umgewandelt werden kann, müssen die Audiodaten von der CD auf die Festplatte gerippt werden. Dabei werden die CDDA (CD Digital Audio) Rohdaten in WAV-Dateien kopiert.

Die Anwendung `cdda2wav`, die im package:sysutils/cdrtools[] Paket enthalten ist, kann zum Rippen der Audiodaten von CDs genutzt werden.

Wenn die Audio CD in dem Laufwerk liegt, kann der folgende Befehl als `root` ausgeführt werden, um eine ganze CD in einzelne WAV-Dateien zu rippen:

[source,bash]
....
# cdda2wav -D 0,1,0 -B
....

In diesem Beispiel bezieht sich der Schalter `-D _0,1,0_` auf das SCSI-Gerät [.filename]#0,1,0#, das die zu rippende CD enthält. Benutzen Sie `cdrecord -scanbus` um die richtigen Geräteparameter für das System zu bestimmen.

Um einzelne Tracks zu rippen, benutzen Sie `-t` wie folgt:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 7
....

Um mehrere Tracks zu rippen, zum Beispiel die Tracks eins bis sieben, können Sie wie folgt einen Bereich angeben:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 1+7
....

Wenn Sie von einem ATAPI (IDE) CD-ROM-Laufwerk rippen, geben Sie den Gerätenamen anstelle der SCSI-Gerätenummer an. Dieses Beispiel rippt Track 7 von einem IDE-Laufwerk:

[source,bash]
....
# cdda2wav -D /dev/acd0 -t 7
....

Alternativ können mit `dd` ebenfalls Audio-Stücke von ATAPI-Laufwerken kopiert werden. Dies wird in crossref:disks[duplicating-audiocds,“Kopieren von Audio-CDs”] erläutert.

[[mp3-encoding]]
=== MP3-Dateien kodieren und dekodieren

Lame ist ein weitverbreiteter MP3-Encoder, der als Port package:audio/lame[] installiert werden kann. Wegen Patentproblemen ist kein Paket verfügbar.

Der folgende Befehl konvertiert die gerippte WAV-Datei [.filename]#audio01.wav# in [.filename]#audio01.mp3# um:

[source,bash]
....
# lame -h -b 128 --tt "Foo Liedtietel" --ta "FooBar Künstler" --tl "FooBar Album" \
--ty "2014" --tc "Gerippt und kodiert von Foo" --tg "Musikrichtung" audio01.wav audio01.mp3
....

128 kbits ist die gewöhnliche MP3-Bitrate, wohingegen die Bitraten 160 und 192 kbits eine höhere Qualität bieten. Je höher die Bitrate ist, desto mehr Speicherplatz benötigt die resultierende MP3-Datei. Die Option `-h` verwendet den "higher quality but a little slower" (höhere Qualität, aber etwas langsamer) Modus. Die Schalter, die mit `--t` beginnen, sind ID3-Tags, die in der Regel Informationen über das Lied enthalten und in die MP3-Datei eingebettet sind. Weitere Optionen können in der Manualpage von lame nachgelesen werden.

Um aus MP3-Dateien eine Audio CD zu erstellen, müssen diese zuerst in ein nicht komprimiertes Format umgewandelt werden. Verwenden Sie XMMS um die Datei im WAV-Format zu schreiben und mpg123, um die MP3-Datei in rohe PCM-Audiodaten umzuwandeln.

Um [.filename]#audio01.mp3# mit mpg123 umzuwandeln, geben Sie den Namen der PCM-Datei an:

[source,bash]
....
# mpg123 -s audio01.mp3 > audio01.pcm
....

So verwenden Sie XMMS um eine MP3-Datei in das WAV-Format zu konvertieren:

[.procedure]
*Procedure: Mit XMMS in das WAV-Format konvertieren*
. Starten Sie XMMS.
. Klicken Sie mit der rechten Maustaste, um das XMMS-Menu zu öffnen.
. Wählen Sie `Preferences` im Untermenü `Options`.
. Ändern Sie das Output-Plugin in "Disk Writer Plugin".
. Drücken Sie `Configure`.
. Geben Sie ein Verzeichnis ein, in das Sie die unkomprimierte Datei schreiben wollen.
. Laden Sie die MP3-Datei wie gewohnt in XMMS mit einer Lautstärke von 100% und einem abgeschalteten EQ.
. Drücken Sie `Play` und es wird so aussehen, als spiele XMMS die MP3-Datei ab, aber keine Musik ist zu hören. Der Player überspielt die MP3-Datei in eine Datei.
. Vergessen Sie nicht, das Output-Plugin wieder in den Ausgangszustand zurückzusetzen um wieder MP3-Dateien anhören zu können.

cdrecord kann mit beiden Formaten Audio-CDs erstellen. Der Dateikopf von WAV-Dateien erzeugt am Anfang des Stücks ein Knacken. Der Dateikopf mit dem Port oder Paket package:audio/sox[] entfernt werden:

[source,bash]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

Lesen Sie crossref:disks[creating-cds,“Erstellen und Verwenden von CDs”], um mehr Informationen zur Benutzung von CD-Brennern mit FreeBSD zu erhalten.

[[video-playback]]
== Videos wiedergeben

Bevor Sie beginnen, sollten Sie das Modell und den benutzten Chip der Videokarte kennen. Obwohl Xorg viele Videokarten unterstützt, können nicht alle Karten Videos schnell genug wiedergeben. Eine Liste der Erweiterungen, die der Xorg-Server für eine Videokarte unterstützt, erhalten Sie unter laufendem Xorg mit `xdpyinfo`.

Halten Sie eine kurze MPEG-Datei bereit, mit der Sie Wiedergabeprogramme und deren Optionen testen können. Da einige DVD-Spieler in der Voreinstellung das DVD-Gerät mit [.filename]#/dev/dvd# ansprechen oder diesen Namen fest einkodiert haben, ist es vielleicht hilfreich symbolische Links auf die richtigen Geräte anzulegen:

[source,bash]
....
# ln -sf /dev/acd0 /dev/dvd
....

Aufgrund der Beschaffenheit man:devfs[5] gehen gesondert angelegte Links wie diese bei einem Neustart des Systems verloren. Damit die symbolischen Links automatisch beim Neustart des Systems angelegt werden, fügen Sie die folgende Zeile in [.filename]#/etc/devfs.conf# ein:

[.programlisting]
....
link acd0 dvd
....

Das Entschlüsseln von DVDs erfordert den Aufruf bestimmter Funktionen, sowie Schreibzugriff auf das DVD-Gerät.

Xorg benutzt Shared-Memory und es wird empfohlen, die nachstehenden man:sysctl[8]-Variablen auf die gezeigten Werte zu erhöhen:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== Video-Schnittstellen

Es gibt einige Möglichkeiten, Videos unter Xorg abzuspielen. Welche Möglichkeit funktioniert, hängt stark von der verwendeten Hardware ab.

Gebräuchliche Video-Schnittstellen sind:

. Xorg: normale Ausgabe über Shared-Memory.
. XVideo: Eine Erweiterung der Xorg-Schnittstelle, die Videos in jedem X11-Drawable anzeigen kann. Diese Erweiterung bietet auch auf leistungsschwachen Maschinen eine gute Qualität der Wiedergabe. Der nächste Abschnitt beschreibt, wie Sie feststellen, ob diese Erweiterung ausgeführt wird.
. SDL: Simple DirectMedia Layer ist eine portable Schnittstelle für verschiedene Betriebssysteme, mit denen Anwendungen plattformunabhängig und effizient Ton und Grafik benutzen können. SDL bietet eine hardwarenahe Schnittstelle, die manchmal schneller ist als die Xorg-Schnittstelle. Unter FreeBSD kann SDL über das Paket oder den Port package:devel/sdl20[] installiert werden.
. DGA: Direct Graphics Access ist eine Xorg-Erweiterung die es Anwendungen erlaubt, am Xorg-Server vorbei direkt in den Framebuffer zu schreiben. Da die Anwendung und der Xorg-Server auf gemeinsame Speicherbereiche zugreifen, müssen die Anwendungen unter dem Benutzer `root` laufen. Die DGA-Erweiterung kann mit man:dga[1] getestet werden. Wenn DGA ausgeführt wird, ändert sich die Farbe des Bildschrims, wenn eine Taste gedrückt wird. Drücken Sie zum Beenden kbd:[q].
. SVGAlib: Eine Schnittstelle zur Grafikausgabe auf der Konsole.

[[video-interface-xvideo]]
==== XVideo

Ob die Erweiterung läuft, entnehmen Sie der Ausgabe von `xvinfo`:

[source,bash]
....
% xvinfo
....

XVideo wird untertsützt, wenn die Ausgabe in etwa wie folgt aussieht:

[source,bash]
....
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

Einige der aufgeführten Formate, wie YUV2 oder YUV12 existieren in machen XVideo-Implementierungen nicht. Dies kann zu Problemen mit einigen Spielern führen.

XVideo wird wahrscheinlich von der Karte nicht unterstützt, wenn die Ausgabe wie folgt aussieht:

[source,bash]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

Wenn die XVideo-Erweiterung auf der Karte nicht läuft, wird es nur etwas schwieriger, die Anforderungen für die Wiedergabe von Videos zu erfüllen.

[[video-ports]]
=== Video-Anwendungen

Dieser Abschnitt behandelt Anwendungen aus der FreeBSD-Ports-Sammlung, die für die Wiedergabe von Videos genutzt werden können.

[[video-mplayer]]
==== MPlayer und MEncoder

MPlayer ist ein auf Geschwindigkeit und Flexibilität ausgelegter Video-Spieler für die Kommandozeile mit optionaler graphischer Oberfläche. Weitere graphische Oberflächen für MPlayer stehen in der FreeBSD Ports-Sammlung zur Verfügung.

MPlayer kann als Paket oder Port package:multimedia/mplayer[] installiert werden. Der Bau von MPlayer berücksichtigt die vorhandene Hardware und es können zahlreiche Optionen ausgewählt werden. Aus diesen Gründen ziehen es manche Benutzer vor, den Port zu übersetzen, anstatt das Paket zu installieren.

Die Optionen sollten beim Bau des Ports überprüft werden, um dem Umfang der Unterstützung, mit dem der Port gebaut wird, zu bestimmen. Wenn eine Option nicht ausgewählt wird, ist MPlayer nicht in der Lage, diese Art von Video-Format wiederzugeben. Mit den Pfeiltasten und der Leertaste können die erforderlichen Formate ausgewählt werden. Wenn Sie fertig sind, drücken Sie kbd:[Enter], um den Bau und die Installation fortzusetzen.

In der Voreinstellung wird das Paket oder der Port das `mplayer`-Kommandozeilenprogramm und das graphische Programm `gmplayer` bauen. Um Videos zu dekodieren, installieren Sie den Port package:multimedia/mencoder[]. Aus lizenzrechtlichen Gründen steht ein Paket von MEncoder nicht zur Verfügung.

MPlayer erstellt beim ersten Start [.filename]#~/.mplayer# im Heimatverzeichnis des Benutzers. Dieses Verzeichnis enthält die voreingestellten Konfigurationseinstellungen für den Benutzer.

Dieser Abschnitt beschreibt nur ein paar wenige Anwendungsmöglichkeiten. Eine vollständige Beschreibung der zahlreichen Möglichkeiten finden Sie in der Manualpage von mplayer(1).

Um die Datei [.filename]#testfile.avi# abzuspielen, geben Sie die Video-Schnittstelle mit `-vo` an:

[source,bash]
....
% mplayer -vo xv testfile.avi
....

[source,bash]
....
% mplayer -vo sdl testfile.avi
....

[source,bash]
....
% mplayer -vo x11 testfile.avi
....

[source,bash]
....
# mplayer -vo dga testfile.avi
....

[source,bash]
....
# mplayer -vo 'sdl:dga' testfile.avi
....

Es lohnt sich, alle Option zu testen. Die erzielte Geschwindigkeit hängt von vielen Faktoren ab und variiert beträchtlich je nach eingesetzter Hardware.

Wenn Sie eine DVD abspielen wollen, ersetzen Sie [.filename]#testfile.avi# durch `-dvd://__N Gerät__`. `_N_` ist die Nummer des Stücks, das Sie abspielen wollen und [.filename]#Gerät# gibt den Gerätenamen der DVD an. Das nachstehende Kommando spielt das dritte Stück von [.filename]#/dev/dvd#:

[source,bash]
....
# mplayer -vo dga -dvd://3 /dev/dvd
....

[NOTE]
====
Das standardmäßig verwendete DVD-Laufwerk kann beim Bau des MPlayer-Ports mit der Option `WITH_DVD_DEVICE=/pfad/zum/gerät` festgelegt werden. Die Voreinstellung verwendet das Gerät [.filename]#/dev/cd0#. Weitere Details finden Sie in [.filename]#Makefile.options# des Ports.
====

Die Tastenkombinationen zum Abbrechen, Anhalten und Weiterführen der Wiedergabe entnehmen Sie der Ausgabe von `mplayer -h` oder der mplayer(1) Manualpage.

Weitere nützliche Optionen für die Wiedergabe sind `-fs -zoom` zur Wiedergabe im Vollbild-Modus und `-framedrop` zur Steigerung der Geschwindigkeit.

Jeder Benutzer kann häufig verwendete Optionen in seine [.filename]#~/.mplayer/config# eintragen:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

`mplayer` kann verwendet werden, um DVD-Stücke in [.filename]#.vob#-Dateien zu rippen. Das zweite Stück einer DVD wandeln Sie wie folgt in eine Datei um:

[source,bash]
....
# mplayer -dumpstream -dumpfile out.vob -dvd://2 /dev/dvd
....

Die Ausgabedatei [.filename]#out.vob# wird im MPEG-Format abgespeichert.

Jeder Benutzer, der mehr Informationen über Video unter UNIX(R) sammeln möchte, sollte http://www.mplayerhq.hu/DOCS/[ mplayerhq.hu/DOCS] konsultieren, da es technisch sehr informativ ist. Diese Dokumentation sollte ebenfalls studiert werden, bevor Fehlerberichte eingereicht werden.

Vor der Verwendung von `mencoder` ist es hilfreich, sich mit den auf http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html[mplayerhq.hu/DOCS/HTML/en/mencoder.html] beschriebenen Optionen vertraut zu machen. Es gibt unzählige Möglichkeiten die Qualität zu verbessern, die Bitrate zu verringern und Formate zu konvertieren. Einige davon haben erhebliche Auswirkungen auf die Geschwindigkeit. Falsche Kombinationen von Kommandozeilenparametern ergeben eventuell Dateien, die selbst `mplayer` nicht mehr wiedergeben kann.

Hier ist ein Beispiel für eine einfache Kopie:

[source,bash]
....
% mencoder input.avi -oac copy -ovc copy -o output.avi
....

Wenn Sie in eine Datei rippen, benutzen Sie die Option `-dumpfile` von `mplayer`.

Um [.filename]#input.avi# nach MPEG4 mit MPEG3 für den Ton zu konvertieren, muss zunächst der Port package:audio/lame[] installiert werden. Aus lizenzrechtlichen Gründen ist ein Paket nicht verfügbar. Wenn der Port installiert ist, geben Sie ein:

[source,bash]
....
% mencoder input.avi -oac mp3lame -lameopts br=192 \
	  -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi
....

Die Ausgabedatei lässt sich mit Anwendungen wie `mplayer` oder `xine` abspielen.

[.filename]#input.avi# kann durch `-dvd://1 /dev/dvd` ersetzt und das Kommando als `root` ausgeführt werden, um ein DVD-Stück direkt zu konvertieren. Da vielleicht ein paar Versuche nötig sind, um das gewünschte Ergebnis zu erhalten, empfiehlt es sich das Stück zuerst in eine Datei zu schreiben und anschließend die Datei weiter zu bearbeiten.

[[video-xine]]
==== Der Video-Spieler xine

xine ist ein Video-Spieler mit einer wiederverwendbaren Bibliothek und ein Programm, das durch Plugins erweitert werden kann. Es kann als Paket oder Port package:multimedia/xine[] installiert werden.

Für einen reibungslosen Betrieb benötigt xine entweder eine schnelle CPU mit einer schnellen Grafikkarte, oder die XVideo-Erweiterung. Am schnellsten läuft xine mit der XVideo-Erweiterung.

In der Voreinstellung startet xine eine grafische Benutzeroberfläche. Über die Menüs können dann bestimmte Dateien geöffnet werden.

Alternativ kann xine auch über die Kommandozeile aufgerufen werden, um Dateien direkt wiederzugeben:

[source,bash]
....
% xine -g -p mymovie.avi
....

Weitere Informationen und Tipps zur Fehlerbehebung finden Sie unter http://www.xine-project.org/faq[xine-project.org/faq].

[[video-ports-transcode]]
==== Die Transcode-Werkzeuge

Transcode ist eine Sammlung von Werkzeugen zur Umwandlung von Video- und Audio-Dateien. Transcode mischt Video-Dateien und kann kaputte Video-Dateien reparieren. Die Werkzeuge werden als Filter verwendet, das heißt die Ein- und Ausgaben verwenden stdin/stdout.

Unter FreeBSD kann Transcode als Paket oder Port package:multimedia/transcode[] installiert werden. Viele Benutzer bevorzugen es den Port zu bauen, da er ein Menü bereitstellt, wo die entsprechenden Formate für den Bau ausgewählt werden können. Mit den Pfeiltasten und der Leertaste können die erforderlichen Formate ausgewählt werden. Wenn Sie fertig sind, drücken Sie kbd:[Enter], um den Bau und die Installation fortzusetzen.

Dieses Beispiel zeigt, wie eine DivX-Datei in eine PAL MPEG-1-Datei konvertiert wird:

[source,bash]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

Die daraus resultierende MPEG-Datei, [.filename]#output_vcd.mpg#, kann beispielsweise mit MPlayer abgespielt werden. Die Datei kann auch mit einem Programm wie package:multimedia/vcdimager[] oder package:sysutils/cdrdao[] als Video-CD auf eine CD-R gebrannt werden.

Zusätzlich zu der Manualpage von `transcode`, sollten Sie auch die Informationen und Beispiele im http://www.transcoding.org/cgi-bin/transcode[ transcoding.org/cgi-bin/transcode] lesen.

[[tvcard]]
== TV-Karten

Mit TV-Karten können Sie mit dem Rechner über Kabel oder Antenne fernsehen. Die meisten Karten besitzen einen RCA- oder S-Video-Eingang. Einige Karten haben auch einen FM-Radio-Empfänger.

Der man:bktr[4]-Treiber von FreeBSD unterstützt PCI-TV-Karten mit einem Brooktree Bt848/849/878/879 Chip. Dieser Teiber unterstützt die meisten Pinnacle PCTV Karten. Die Karte sollte einen der unterstützten Empfänger besitzen, die in man:bktr[4] aufgeführt sind.

=== Den Treiber laden

Um die Karte benutzen zu können, muss der man:bktr[4]-Treiber geladen werden. Damit dies beim Systemstart automatisch erfolgt, muss die folgende Zeile in [.filename]#/boot/loader.conf# hinzugefügt werden:

[.programlisting]
....
bktr_load="YES"
....

Alternativ kann der Treiber für die TV-Karte auch fest in den Kernel kompiliert werden. In diesem Fall müssen folgende Zeilen in die Kernelkonfigurationsdatei aufgenommen werden:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

Die zusätzlichen Treiber werden benötigt, da die Komponenten der Karte über einen I2C-Bus verbunden sind. Bauen und installieren Sie dann den neuen Kernel.

Um den Treiber zu testen, muss das System neu gestartet werden. Während des Neustarts sollte die TV-Karte erkannt werden:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

Abhängig von der verwendeten Hardware können die Meldungen natürlich anders aussehen. Die entdeckten Geräte lassen sich mit man:sysctl[8] oder in der Kernelkonfigurationsdatei überschreiben. Wenn Sie beispielsweise einen Philips-SECAM-Empfänger erzwingen wollen, fügen Sie die folgende Zeile zur Kernelkonfigurationsdatei hinzu:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

Alternativ können Sie man:sysctl[8] benutzen:

[source,bash]
....
# sysctl hw.bt848.tuner=6
....

Weitere Informationen zu den verschiedenen Kerneloptionen und man:sysctl[8]-Parametern finden Sie in man:bktr[4].

=== Nützliche Anwendungen

Um die TV-Karte zu benutzen, installieren Sie eine der nachstehenden Anwendungen:

* package:multimedia/fxtv[] lässt das Fernsehprogramm in einem Fenster laufen und kann Bilder, Audio und Video aufzeichnen.
* package:multimedia/xawtv[] eine weitere TV-Anwendung mit vergleichbaren Funktionen.
* Mit package:audio/xmradio[] lässt sich der FM-Radio-Empfänger, der sich auf TV-Karten befindet, benutzen.

Weitere Anwendungen finden Sie in der FreeBSD Ports-Sammlung.

=== Fehlersuche

Wenn Sie Probleme mit der TV-Karte haben, prüfen Sie zuerst, ob der Video-Capture-Chip und der Empfänger vom man:bktr[4]-Treiber unterstützt werden und ob Sie die richtigen Optionen verwenden. Weitere Hilfe zu unterstützten TV-Karten finden Sie auf der Mailingliste {freebsd-multimedia}.

[[mythtv]]
== MythTV

MythTV ist eine beliebte Open Source PVR-Anwendung. Dieser Abschnitt beschreibt die Installation und Konfiguration von MythTV unter FreeBSD. Weitere Informationen zur Benutzung von MythTV finden Sie unter http://www.mythtv.org/wiki/[mythtv.org/wiki].

MythTV benötigt ein Frontend und ein Backend. Diese Komponenten können entweder auf dem gleichen System, oder auf unterschiedlichen Maschinen installiert werden.

Das Frontend kann unter FreeBSD über den Port oder das Paket package:multimedia/mythtv-frontend[] installiert werden. Zudem muss Xorg, wie in crossref:x11[x11,Das X-Window-System] beschrieben, installiert und konfiguriert sein. Idealerweise besitzt das System auch eine Videokarte, die X-Video Motion Compensation (XvMC) unterstützt, sowie optional eine LIRC-kompatible Fernbedienung.

Benutzen Sie package:multimedia/mythtv[], um sowohl das Frontend als auch das Backend zu installieren. Ein MySQL(TM) Datenbank-Server ist ebenfalls erforderlich und sollte automatisch als Abhängigkeit installiert werden. Optional sollte das System einen Empfänger und ausreichend Speicherplatz haben, um die aufgezeichneten Daten speichern zu können.

=== Hardware

MythTV verwendet V4L um auf Videoeingabegeräte, wie Kodierer und Empfänger zuzugreifen. Unter FreeBSD funktioniert MythTV am besten mit USB DVB-S/C/T Karten, die von package:multimedia/webcamd[] unterstützt werden, da dies eine V4L-Anwendung zur Verfügung stellt, die als Benutzerprogramm läuft. Jede DVB-Karte, die von webcamd unterstützt wird, sollte mit MythTV funktionieren, jedoch gibt es eine Liste von Karten, die unter https://wiki.freebsd.org/WebcamCompat[ wiki.freebsd.org/WebcamCompat] abgerufen werden kann. Es existieren auch Treiber für Hauppauge-Karten in den folgenden Paketen: package:multimedia/pvr250[] und package:multimedia/pvrxxx[], allerdings liefern diese nur eine Treiberschnittstelle, die nicht dem Standard entspricht und die nicht mit MythTV-Versionen grösser als 0.23 funktionieren. Aus lizenzrechtlichen Gründen ist ein Paket nicht verfügbar, sodass die beiden Ports übersetzt werden müssen.

Die https://wiki.freebsd.org/HTPC[ wiki.freebsd.org/HTPC] enthält eine Liste von allen verfügbaren DVB-Treibern.

=== MythTV Backend einrichten

Geben Sie folgendes ein, um MythTV als Binärpaket zu installieren:

[source,bash]
....
# pkg install mythtv
....

Alternativ können Sie den Port installieren:

[source,bash]
....
# cd /usr/ports/multimedia/mythtv
# make install
....

Richten Sie anschließend die MythTV-Datenbank ein:

[source,bash]
....
# mysql -uroot -p < /usr/local/shared/mythtv/database/mc.sql
....

Konfigurieren Sie dann das Backend:

[source,bash]
....
# mythtv-setup
....

Zum Schluss starten Sie das Backend:

[source,bash]
....
# sysrc mythbackend_enable=yes
# service mythbackend start
....

[[scanners]]
== Scanner

Unter FreeBSD stellt SANE (Scanner Access Now Easy) aus der Ports-Sammlung eine einheitliche Schnittstelle (API) für den Zugriff auf Scanner bereit. SANE wiederum greift auf Scanner mithilfe einiger FreeBSD-Treiber zu.

FreeBSD unterstützt sowohl SCSI- als auch USB-Scanner. Abhängig von der Schnittstelle des Scanners, werden unterschiedliche Treiber benötigt. Prüfen Sie vor der Konfiguration mithilfe der http://www.sane-project.org/sane-supported-devices.html[Liste der unterstützten Geräte] ob der Scanner von SANE unterstützt wird.

Dieses Kapitel beschreibt, wie Sie feststellen können, ob der Scanner von FreeBSD erkannt wurde. Zudem enthält es einen Überblick über die Konfiguration und Verwendung von SANE unter FreeBSD.

[[scanners-kernel-usb]]
=== Den Scanner überprüfen

Im [.filename]#GENERIC#-Kernel sind schon alle, für einen USB-Scanner notwendigen Treiber enthalten. Benutzer mit einem angepassten Kernel sollten sicherstellen, dass die Kernelkonfiguration die nachstehenden Zeilen enthält:

[.programlisting]
....
device usb
device uhci
device ohci
device ehci
device xhci
....

Um zu überprüfen ob der Scanner erkannt wird, schließen Sie den USB-Scanner an. Prüfen Sie dann mit man:dmesg[8], ob der Scanner in den Systemmeldungen erscheint:

[source,bash]
....
ugen0.2: <EPSON> at usbus0
....

In diesem Beispiel wurde ein EPSON Perfection(R) 1650 USB-Scanner an [.filename]#/dev/ugen0.2# erkannt.

Wenn der Scanner eine SCSI-Schnittstelle besitzt, ist die Kernelkonfiguration abhängig vom verwendeten SCSI-Controller. Der [.filename]#GENERIC#-Kernel unterstützt die gebräuchlichen SCSI-Controller. Den richtigen Treiber finden Sie in [.filename]#/usr/src/sys/conf/NOTES#. Neben dem SCSI-Treiber muss die Kernelkonfiguration noch die nachstehenden Zeilen enthalten:

[.programlisting]
....
device scbus
device pass
....

Nachdem Sie einen Kernel gebaut und installiert haben, sollte der Scanner beim Neustart in den Systemmeldungen erscheinen:

[source,bash]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

Wenn der Scanner während des Systemstarts ausgeschaltet war, können Sie die Geräteerkennung erzwingen, indem Sie den SCSI-Bus erneut absuchen. Verwenden Sie dazu `camcontrol`:

[source,bash]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

Der Scanner sollte jetzt in der SCSI-Geräteliste erscheinen:

[source,bash]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

Weitere Informationen über SCSI-Geräte unter FreeBSD finden Sie in man:scsi[4] und man:camcontrol[8].

=== SANE konfigurieren

Das SANE-System ermöglicht den Zugriff auf den Scanner über Backends (package:graphics/sane-backends[]). Lesen Sie http://www.sane-project.org/sane-supported-devices.html[http://www.sane-project.org/sane-supported-devices.html] um herauszufinden, welches Backend welchen Scanner unterstützt. Eine graphische Oberfläche wird über Anwendungen von Drittanbietern wie Kooka (package:graphics/kooka[]) oder XSane (package:graphics/xsane[]) bereitgestellt. Die Backends von SANE reichen aus, um den Scanner zu testen.

Installieren Sie die Backends als Paket:

[source,bash]
....
# pkg install sane-backends
....

Alternativ können Sie die Backends aus der Ports-Sammlung installieren:

[source,bash]
....
# cd /usr/ports/graphics/sane-backends
# make install clean
....

Nachdem Sie den Port oder das Paket package:graphics/sane-backends[] installiert haben, können Sie mit dem Befehl `sane-find-scanner` prüfen, ob SANE den Scanner erkennt:

[source,bash]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

Die Ausgabe zeigt die Schnittstelle und die verwendete Gerätedatei des Scanners. Der Hersteller und das Modell können in der Ausgabe fehlen.

[NOTE]
====
Bei einigen USB-Scannern muss die Firmware geladen werden. Lesen Sie sane-find-scanner(1) und sane(7) für weitere Details.
====

Als nächstes müssen Sie prüfen, ob der Scanner vom Frontend erkannt wird. Die SANE-Backends werden mit dem Kommandozeilenwerkzeug `scanimage` geliefert. Mit diesem Werkzeug können Sie sich Scanner anzeigen lassen und den Scan-Prozess von der Kommandozeile starten. Die Option `-L` zeigt die Scanner an. Das erste Beispiel ist für einen SCSI-Scanner, das zweite ist für einen USB-Scanner:

[source,bash]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

Im zweiten Beispiel ist `epson2` der Backend-Name. `libusb:000:002` bedeutet, dass [.filename]#/dev/ugen0.2# die vom Scanner verwendete Gerätedatei ist.

Wenn `scanimage` den Scanner nicht erkennen kann, erscheint folgende Meldung:

[source,bash]
....
# scanimage -L

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

Wenn das passiert, müssen Sie in der Konfigurationsdatei des Backends unterhalb von [.filename]#/usr/local/etc/sane.d/# den verwendeten Scanner eintragen. Wenn der Scanner EPSON Perfection(R) 1650, der das Backend `epson2` benutzt, nicht erkannt wurde, muss [.filename]#/usr/local/etc/sane.d/epson2.conf# angepasst werden. Fügen Sie eine Zeile mit der Schnittstelle und dem Gerätenamen in die Datei ein. In diesem Beispiel wurde die nachstehende Zeile eingefügt:

[.programlisting]
....
usb /dev/ugen0.2
....

Speichern Sie die Änderungen und prüfen Sie, ob der Scanner mit dem richtigen Backend und Gerätenamen erkannt wird:

[source,bash]
....
# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

Wenn `scanimage -L` den Scanner erkannt hat, ist der Scanner eingerichtet und bereit, zu scannen.

Obwohl `scanimage` von der Kommandozeile scannen kann, ist eine graphische Anwendung zum Scannen besser geeignet. Bekannte Programme sind Koka oder XSane. Diese Frontends besitzten erweiterte Funktionen wie den Scan-Modus, Farbkorrektur und Batch-Scans. XSane lässt sich auch als GIMP-Plugin verwenden.

=== Berechtigungen für den Scanner

Wenn andere Benutzer den Scanner benutzen sollen, müssen sie Lese- und Schreibrechte auf die Gerätedatei des Scanners besitzen. Im vorherigen Beispiel wird die Datei [.filename]#/dev/ugen0.2# verwendet, die faktisch nur ein Symlink auf die echte Gerätedatei, [.filename]#/dev/usb/0.2.0# genannt, darstellt. Sowohl der Symlink als auch die Gerätedatei sind jeweils im Besitz der Gruppen `wheel` und `operator`. Damit ein Benutzer den Scanner benutzen kann, muss er Mitglied in einer der beiden Gruppen sein. Allerdings sollte aus Sicherheitsgründen genau überlegt werden, welche Benutzer zu welcher Gruppe hinzugefügt werden, besonders bei der Gruppe `wheel`. Eine bessere Lösung ist es, eine spezielle Gruppe für den Zugriff anzulegen und den Scanner für Mitglieder dieser Gruppe zugänglich zu machen.

Dieses Beispiel erstellt eine Gruppe namens `_usb_`:

[source,bash]
....
# pw groupadd usb
....

Anschließend muss der [.filename]#/dev/ugen0.2#-Symlink und der Gerätename [.filename]#/dev/usb/0.2.0# für die Gruppe `usb` mit den Schreibrechten `0660` oder `0664` ausgestattet werden. All dies kann durch das Hinzufügen der folgenden Zeilen in [.filename]#/etc/devfs.rules# erreicht werden:

[.programlisting]
....
[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb
....

[NOTE]
====
Es kommt vor, dass sich der Gerätename mit dem Hinzufügen oder Entfernen von Geräten ändert, so dass man stattdessen vielleicht allen USB-Geräten mit diesem Regelsatz Zugriff gewähren möchte:

[.programlisting]
....
[system=5]
add path 'ugen*' mode 0660 group usb
add path 'usb/*' mode 0666 group usb
....

====

Weitere Informationen zu dieser Datei finden Sie in man:devfs.rules[5].

Als nächstes aktivieren Sie den Regelsatz in [.filename]#/etc/rc.conf#:

[.programlisting]
....
devfs_system_ruleset="system"
....

Starten Sie anschließend das man:devfs[8]-System neu:

[source,bash]
....
# service devfs restart
....

Jetzt müssen nur noch Benutzer zur Gruppe `_usb_` hinzugefügt werden, um ihnen den Zugriff auf den Scanner zu erlauben:

[source,bash]
....
# pw groupmod usb -m joe
....

Weitere Details finden Sie in man:pw[8].
