---
title: Kapitel 23. FreeBSD aktualisieren
part: Teil III. Systemadministration
prev: books/handbook/l10n
next: books/handbook/dtrace
showBookMenu: true
weight: 27
path: "/books/handbook/cutting-edge/"
---

[[updating-upgrading]]
= FreeBSD aktualisieren
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 23
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/cutting-edge/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[updating-upgrading-synopsis]]
== Übersicht

FreeBSD wird zwischen einzelnen Releases ständig weiter entwickelt. Manche Leute bevorzugen die offiziellen Release-Versionen, während andere wiederum lieber auf dem aktuellen Stand der Entwicklung bleiben möchten. Wie dem auch sei, sogar offizielle Release-Versionen werden oft mit Sicherheitsaktualisierungen und anderen kritischen Fehlerbereinigungen versorgt. Unabhängig von der eingesetzten Version bringt FreeBSD alle nötigen Werkzeuge mit, um das System aktuell zu halten und es innerhalb verschiedener Versionen zu aktualisieren. Dieses Kapitel beschreibt, wie man einem Entwicklungssystem folgen kann, sowie die grundlegenden Werkzeuge um FreeBSD zu aktualisieren.

Nachdem Sie dieses Kapitel gelesen haben, werden Sie

* wissen, wie das System mit freebsd-update oder Subversion aktualisiert wird.
* wissen, wie man das aktuell installierte System mit einer ursprünglichen Version vergleicht.
* wissen, wie die installierte Dokumentation mit Subversion oder Dokumentations-Ports  aktualisiert wird.
* den Unterschied zwischen den beiden Entwicklungszweigen FreeBSD-STABLE und FreeBSD-CURRENT kennen.
* wissen, wie das komplette Basissystem neu gebaut und installiert wird.

Bevor Sie dieses Kapitel lesen, sollten Sie

* das Netzwerk richtig konfiguriert haben (crossref:advanced-networking[advanced-networking,Weiterführende Netzwerkthemen]).
* wissen, wie Software Dritter installiert wird (crossref:ports[ports,Installieren von Anwendungen: Pakete und Ports]).

[NOTE]
====
In diesem Kapitel wird `svnlite` benutzt, um die FreeBSD Quellen zu beziehen und zu aktualisieren. Alternativ kann auch der Port oder das Paket package:devel/subversion[] installiert werden.
====

[[updating-upgrading-freebsdupdate]]
== FreeBSD-Update

Das zeitnahe Einspielen von Sicherheitsaktualisierungen und die Aktualisierung des Betriebssystems sind wichtige Aspekte der Systemadministration. FreeBSD enthält das Werkzeug `freebsd-update`, mit dem Sie diese beiden Aufgaben erfüllen können.

Dieses Werkzeug ermöglicht die Anwendung von Sicherheitsaktualisierungen im Binärformat auf das FreeBSD Basissystem, ohne dieses neu zu übersetzen und zu installieren. Die Aktualisierungen im Binärformat sind für alle Architekturen und Versionen verfügbar, welche vom FreeBSD Sicherheitsteam unterstützt werden. Eine Liste der unterstützten Versionen und der End-of-Life-Daten ist unter https://www.FreeBSD.org/security/[https://www.FreeBSD.org/security/] aufgeführt.

`freebsd-update` unterstützt auch die Aktualisierung des Betriebssystems auf eine neuere Unterversion sowie eine Aktualisierung auf einen anderen Release-Zweig. Bevor Sie auf eine neue Version aktualisieren, sollten Sie die aktuellen Ankündigungen zu dem Release gelesen haben, da diese wichtige Informationen zu dem entsprechenden Release enthalten. Ankündigungen finden Sie unter https://www.FreeBSD.org/releases/[https://www.FreeBSD.org/releases/].

[NOTE]
====
Wenn eine `crontab` existiert, welche die Eigenschaften von man:freebsd-update[8] verwendet, muss diese deaktiviert werden, bevor das Betriebssystem aktualisiert wird.
====

Dieser Abschnitt beschreibt die Verwendung der Konfigurationsdatei von `freebsd-update`. Es wird gezeigt wie Sie Sicherheitsaktualisierungen einspielen, oder wie Sie das Betriebssystem auf neuere Haupt- und Unterversionen aktualisieren können.

[[freebsdupdate-config-file]]
=== Die Konfigurationsdatei

In der Regel muss die Konfigurationsdatei von `freebsd-update` nicht bearbeitet werden. Manche Benutzer möchten die Standard-Konfigurationsdatei [.filename]#/etc/freebsd-update.conf# trotzdem anpassen, um bessere Kontrolle über den gesamten Prozess zu besitzen. Die Kommentare in dieser Datei beschreiben die verfügbaren Optionen, jedoch benötigen die folgenden ein paar zusätzliche Erklärungen:

[.programlisting]
....
# Components of the base system which should be kept updated.
Components world kernel
....

Dieser Parameter kontrolliert, welche Teile von FreeBSD auf dem aktuellen Stand gehalten werden sollen. In der Voreinstellung wird das gesamte Basissystem sowie der Kernel aktualisiert. Es können auch einzelne Komponenten, wie `src/base` oder `src/sys`, angegeben werden. Die beste Einstellung ist, diese Option so zu belassen, da eine Änderung es bedingt, dass man als Benutzer jede Komponente auflisten muss, die aktualisiert werden soll. Dies könnte katastrophale Folgen nach sich ziehen, da der Quellcode und die Binärdateien dadurch nicht mehr synchron wären.

[.programlisting]
....
# Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints
....

Fügen Sie Pfade wie [.filename]#/bin# oder [.filename]#/sbin# hinzu, um diese speziellen Verzeichnisse während des Aktualisierungsprozesses unberührt zu lassen. Diese Option kann verwendet werden, um zu verhindern, dass `freebsd-update` lokale Änderungen überschreibt.

[.programlisting]
....
# Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile
....

Diese Option aktualisiert nur unmodifizierte Konfigurationsdateien in den angegebenen Verzeichnissen. Jede Änderung, die der Benutzer daran vorgenommen hat, wird die automatische Aktualisierung dieser Dateien verhindern. Es gibt eine weitere Option `KeepModifiedMetadata`, die `freebsd-update` instruiert, die Änderungen während der Zusammenführung zu speichern.

[.programlisting]
....
# When upgrading to a new FreeBSD release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints
....

Eine Liste von Verzeichnissen mit Konfigurationsdateien, in denen `freebsd-update` Zusammenführungen versuchen soll. Dieser Verschmelzungsprozess von Dateien ist eine Serie von man:diff[1]-Korrekturen, ähnlich wie man:mergemaster[8], aber mit weniger Optionen. Die Änderungen werden entweder akzeptiert, oder öffnen einen Editor, oder `freebsd-update` bricht ab. Im Zweifelsfall sichern Sie [.filename]#/etc# und akzeptieren einfach die Änderungen. Lesen Sie man:mergemaster[8], um Informationen über `mergemaster` zu erhalten.

[.programlisting]
....
# Directory in which to store downloaded updates and temporary
# files used by FreeBSD Update.
# WorkDir /var/db/freebsd-update
....

In diesem Verzeichnis werden alle Korrekturen und temporären Dateien abgelegt. Im Falle einer Versionsaktualisierung sollte diesem Verzeichnis mindestens ein Gigabyte Festplattenspeicher zur Verfügung stehen.

[.programlisting]
....
# When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which FreeBSD Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no
....

Wenn diese Option auf `yes` gesetzt ist, wird `freebsd-update` annehmen, dass die `Components`-Liste vollständig ist und nicht versuchen, Änderungen ausserhalb dieser Liste zu tätigen. Tatsächlich wird `freebsd-update` versuchen, jede Datei zu aktualisieren, die zu der `Components`-Liste gehört.

[[freebsdupdate-security-patches]]
=== Sicherheitskorrekturen anwenden

Das Einspielen von FreeBSD Sicherheitskorrekturen wurde dahingehend vereinfacht, dass der Administrator nun das gesamte System mit `freebsd-update` auf dem aktuellen Stand halten kann. Weitere Informationen zu FreeBSD Sicherheitshinweisen finden Sie in crossref:security[security-advisories,"FreeBSD Sicherheitshinweise"].

Sicherheitskorrekturen für FreeBSD können wie folgt heruntergeladen und installiert werden. Das erste Kommando prüft, ob noch ausstehende Korrekturen verfügbar sind, und wenn dass der Fall ist, zeigt es welche Dateien davon betroffen wären. Das zweite Kommando wird die Korrekturen auf das System anwenden.

[source,shell]
....
# freebsd-update fetch
# freebsd-update install
....

Wenn während der Aktualisierung Korrekturen am Kernel angewendet werden, muss das System neu gestartet werden, damit der korrigierte Kernel gebootet wird. Wenn die Korrekturen auf laufende Binärdateien angewendet werden, sollten die betroffenen Anwendungen neu gestartet werden, damit die korrigierte Version der Binärdatei geladen wird.

[NOTE]
====
Im Regelfall muss der Benutzer darauf vorbereitet sein, das System neu zu starten. Um herauszufinden, ob ein Neustart durch eine Aktualisierung des Kernels erforderlich ist, führen Sie die Befehle `freebsd-version -k` und `uname -r` aus. Ist die Ausgabe dieser Befehle unterschiedlich, ist ein Neustart des Systems erforderlich.
====

Mit dem folgenden Eintrag in [.filename]#/etc/crontab# wird das System einmal täglich nach Aktualisierungen suchen:

[.programlisting]
....
@daily                                  root    freebsd-update cron
....

Wenn Korrekturen existieren, werden diese automatisch heruntergeladen, aber nicht eingespielt. Der `root`-Benutzer bekommt eine Nachricht, damit die Korrekturen überprüft und mit `freebsd-update install` manuell installiert werden können.

Wenn etwas schief geht, kann `freebsd-update` den letzten Satz von Änderungen mit folgendem Befehl rückgängig machen:

[source,shell]
....
# freebsd-update rollback
Uninstalling updates... done.
....

Wie bereits erwähnt, sollte das System neu gestartet werden, wenn der Kernel oder ein Kernelmodul verändert wurde. Betroffene Anwendungen sollten neu gestartet werden, wenn Binärdateien verändert wurden.

Das `freebsd-update`-Werkzeug kann nur den [.filename]#GENERIC#-Kernel automatisch aktualisieren. Wenn ein angepasster Kernel verwendet wird, muss dieser neu erstellt und installiert werden, nachdem `freebsd-update` die Aktualisierungen durchgeführt hat. Der voreingestellte Kernel ist _GENERIC_. Benutzen Sie das Kommando man:uname[1] um dies zu überprüfen.

[NOTE]
====
Behalten Sie immer eine Kopie des [.filename]#GENERIC#-Kernels in [.filename]#/boot/GENERIC#. Das wird bei der Diagnose von verschiedenen Problemen sowie bei der Durchführung von Versionsaktualisierungen eine große Hilfe sein. Im <<freebsd-update-custom-kernel-9x>> wird beschrieben, wie Sie eine Kopie des [.filename]#GENERIC#-Kernels bekommen.
====

Solange die Standardkonfiguration in [.filename]#/etc/freebsd-update.conf# nicht geändert wurde, wird `freebsd-update` die aktualisierten Quellcodedateien des Kernels zusammen mit dem Rest der Neuerungen installieren. Die erneute Übersetzung und Installation eines neuen, angepassten Kernels kann dann auf die übliche Art und Weise durchgeführt werden.

Die Aktualisierungen, die über `freebsd-update` verteilt werden, betreffen nicht immer den Kernel. Es ist nicht notwendig, den angepassten Kernel neu zu erstellen, wenn die Kernelquellen nicht durch `freebsd-update install` geändert wurden. Allerdings wird `freebsd-update` immer [.filename]#/usr/src/sys/conf/newvers.sh# aktualisieren. Der aktuelle Patch-Level, der mit der `-p`-Nummer bei `uname -r` ausgegeben wird, wird aus dieser Datei ausgelesen. Die Neuinstallation des angepassten Kernels, selbst wenn sich daran nichts geändert hat, erlaubt es `uname`, den aktuellen Patch-Level des Systems korrekt wiederzugeben. Dies ist besonders hilfreich, wenn mehrere Systeme gewartet werden, da es eine schnelle Einschätzung der installierten Aktualisierungen in jedem einzelnen System ermöglicht.

[[freebsdupdate-upgrade]]
=== Aktualisierungen an Haupt- und Unterversionen

Aktualisierungen einer Unterversion von FreeBSD zur nächsten Version ist beispielsweise die Aktualisierung von FreeBSD 9.0 auf FreeBSD 9.1. Die Aktualisierung einer Hauptversion ist beispielsweise von FreeBSD 9.X auf FreeBSD 10.X. Beide Arten der Aktualisierungen können durchgeführt werden, indem man `freebsd-update` eine Release-Version als Ziel übergibt.

[NOTE]
====
Wenn auf dem System ein angepasster Kernel eingesetzt wird, stellen Sie sicher, dass eine Kopie des [.filename]#GENERIC#-Kernels in [.filename]#/boot/GENERIC# existiert. Im <<freebsd-update-custom-kernel-9x>> wird beschrieben, wie Sie eine Kopie des [.filename]#GENERIC#-Kernels bekommen.
====

Wenn Sie das folgende Kommando auf einem System mit FreeBSD 9.0 ausführen, wird das System auf FreeBSD 9.1 aktualisiert:

[source,shell]
....
# freebsd-update -r 9.1-RELEASE upgrade
....

Nach der Eingabe des Kommandos überprüft `freebsd-update` die Konfigurationsdatei und das aktuelle System, um die nötigen Informationen für die Systemaktualisierung zu sammeln. Eine Bildschirmausgabe wird anzeigen, welche Komponenten erkannt und welche nicht erkannt wurden. Zum Beispiel:

[source,shell]
....
Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y
....

An diesem Punkt wird `freebsd-update` versuchen, alle notwendigen Dateien für die Aktualisierung herunter zu laden. In manchen Fällen wird der Benutzer mit Fragen konfrontiert, um festzustellen, was installiert werden soll oder auf welche Art und Weise fortgesetzt werden soll.

Wenn ein angepasster Kernel benutzt wird, produziert der vorherige Schritt eine Warnung ähnlich zu der folgenden:

[source,shell]
....
WARNING: This system is running a "
MYKERNEL" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"
....

Diese Warnung kann an dieser Stelle problemlos ignoriert werden. Der aktualisierte [.filename]#GENERIC#-Kernel wird als ein Zwischenschritt im Aktualisierungsprozess verwendet.

Nachdem alle Korrekturen auf das lokale System heruntergeladen wurden, werden diese eingespielt. Dieser Prozess kann eine gewisse Zeit in Anspruch nehmen, abhängig von der Geschwindigkeit und Auslastung der Maschine. Konfigurationsdateien werden ebenfalls zusammengefügt. Dieser Teil der Prozedur verlangt einige Benutzereingaben, da eine Datei möglicherweise von Hand zusammengefasst werden muss oder ein Editor erscheint auf dem Bildschirm zum manuellen bearbeiten. Die Ergebnisse von jeder erfolgreichen Zusammenfassung werden dem Benutzer angezeigt, während der Prozess weiter läuft. Eine fehlgeschlagene oder ignorierte Zusammenfassung wird den Prozess sofort beenden. Benutzer sollten eine Sicherung von [.filename]#/etc# anlegen und wichtige Dateien später manuell vereinen, beispielsweise [.filename]#master.passwd# oder [.filename]#group#.

[NOTE]
====
Das System ist zu diesem Zeitpunkt noch nicht verändert worden, da alle Korrekturen und Vereinigungen in einem anderen Verzeichnis vorgenommen wurden. Wenn alle Korrekturen erfolgreich eingespielt, alle Konfigurationsdateien zusammengefügt wurden und es den Anschein hat, dass der Prozess problemlos verlaufen wird, müssen die Änderungen vom Anwender noch angewendet und auf die Platte geschrieben werden:

[source,shell]
....
# freebsd-update install
....

====

Der Kernel und die Module werden zuerst aktualisiert. Wenn das System einen angepassten Kernel verwendet, benutzen Sie man:nextboot[8], um den Kernel für den nächsten Neustart auf [.filename]#/boot/GENERIC# zu setzen:

[source,shell]
....
# nextboot -k GENERIC
....

[WARNING]
====

Bevor das System mit dem [.filename]#GENERIC#-Kernel neu gestartet wird, vergewissern Sie sich, dass für den Neustart alle benötigten Treiber enthalten sind. Falls auf die Maschine aus der Ferne zugegriffen wird, stellen Sie sicher, dass das System ordnungsgemäß an das Netzwerk angeschlossen ist. Achten Sie besonders darauf, dass wenn der angepasste Kernel Funktionalität beinhaltet, die normalerweise von Kernelmodulen zur Verfügung gestellt werden, dass diese temporär über [.filename]#/boot/loader.conf# in den [.filename]#GENERIC#-Kernel übernommen werden. Zudem wird empfohlen, nicht benötigte Dienste, eingehängte Platten und verbundene Netzlaufwerke zu deaktivieren, bis der Aktualisierungsprozess abgeschlossen ist.
====

Die Maschine sollte nun mit dem aktualisierten Kernel neu gestartet werden:

[source,shell]
....
# shutdown -r now
....

Sobald das System wieder hochgefahren ist, muss `freebsd-update` erneut gestartet werden. Da der Zustand des Prozesses zuvor gesichert wurde, wird `freebsd-update` nicht von vorne beginnen, sondern mit der nächsten Phase fortfahren und alle alten Bibliotheken und Objektdateien löschen.

[source,shell]
....
# freebsd-update install
....

[NOTE]
====
Abhängig davon, ob irgendwelche Bibliotheksversionen erhöht wurden, kann es sein, dass nur zwei Installationsphasen anstatt drei durchlaufen werden.
====

Die Aktualisierung ist nun abgeschlossen. Wenn es sich hierbei um eine Aktualisierung auf eine neue Hauptversion handelt, müssen alle Ports und Pakete neu installiert werden. Dieser Vorgang wird in <<freebsdupdate-portsrebuild>> beschrieben.

[[freebsd-update-custom-kernel-9x]]
==== Angepasste Kernel unter FreeBSD 9.X und später

Stellen Sie vor der ersten Benutzung von `freebsd-update` sicher, dass eine Kopie des [.filename]#GENERIC#-Kernels in [.filename]#/boot/GENERIC# existiert. Wenn ein angepasster Kernel erstmalig gebaut wurde, ist der Kernel in [.filename]#/boot/kernel.old# der [.filename]#GENERIC#-Kernel. Benennen Sie dieses Verzeichnis einfach in [.filename]#/boot/GENERIC# um.

Wenn bereits mehrfach ein angepasster Kernel gebaut wurde, oder nicht bekannt ist wie oft ein angepasster Kernel gebaut wurde, behalten Sie besser eine Kopie des [.filename]#GENERIC#-Kernels, welcher mit der aktuellen Version des Betriebssystems übereinstimmt. Wenn ein direkter Zugriff auf die Maschine möglich ist, kann eine Kopie des [.filename]#GENERIC#-Kernels von den Installationsmedien installiert werden:

[source,shell]
....
# mount /cdrom
# cd /cdrom/usr/freebsd-dist
# tar -C/ -xvf kernel.txz boot/kernel/kernel
....

Alternativ kann der [.filename]#GENERIC#-Kernel aus den Quellen neu gebaut und installiert werden:

[source,shell]
....
# cd /usr/src
# make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null
....

Damit dieser Kernel als [.filename]#GENERIC#-Kernel von `freebsd-update` erkannt wird, darf die [.filename]#GENERIC#-Konfigurationsdatei in keiner Weise geändert worden sein. Es wird ebenfalls empfohlen, dass dieser ohne irgendwelche speziellen Optionen erstellt wird.

Der Neustart in den [.filename]#GENERIC#-Kernel ist nicht notwendig, da `freebsd-update` lediglich [.filename]#/boot/GENERIC# benötigt.

[[freebsdupdate-portsrebuild]]
==== Aktualisierung der Pakete nach einem Upgrade auf eine Hauptversion

In der Regel funktionieren nach einer Aktualisierung einer Unterversion die installierten Anwendungen weiterhin problemlos. Neue Hauptversionen verwenden jedoch andere Binärschnittstellen (ABIs), was dazu führt, dass die meisten Anwendungen von Drittherstellern nicht mehr funktionieren. Nach der Aktualisierung auf eine Hauptversion, müssen alle installierten Ports und Pakete aktualisiert werden. Benutzen Sie `pkg upgrade` um Pakte zu aktualisieren. Installierte Ports können Sie mit einem Werkzeug wie package:ports-mgmt/portmaster[] aktualisiert werden.

Bei einer erzwungenen Aktualisierung aller installierten Pakete, werden diese durch eine neue Version aus dem Repository ersetzt, sogar dann, wenn sich die Versionsnummer nicht erhöht hat. Dieser Schritt ist erforderlich, da sich die ABI bei einer Aktualisierung der Hauptversion von FreeBSD verändert hat. Eine erzwungene Aktualisierung aller installierten Pakete geschieht wie folgt:

[source,shell]
....
# pkg-static upgrade -f
....

Ein Neubau der installierten Ports führen Sie mit diesem Kommando durch:

[source,shell]
....
# portmaster -af
....

Dieser Befehl wird die Konfigurationen für jede Anwendung anzeigen, und der Benutzer hat die Möglichkeit, die Optionen anzupassen. Wenn Sie ausschließlich die voreingestellten Optionen verwenden möchten, verwenden Sie mit dem obigen Befehl den Parameter `-G`.

Sobald dies abgeschlossen ist, beenden Sie den Aktualisierungsprozess mit einem letzten Aufruf von `freebsd-update`. Geben Sie den folgenden Befehl ein, um alle losen Enden des Aktualisierungsprozesses miteinander zu verknüpfen:

[source,shell]
....
# freebsd-update install
....

Wenn der [.filename]#GENERIC#-Kernel temporär Verwendung fand, ist dies der richtige Zeitpunkt, einen neuen, angepassten Kernel nach den Anweisungen in crossref:kernelconfig[kernelconfig,Konfiguration des FreeBSD-Kernels] zu bauen und zu installieren.

Booten Sie anschließend die Maschine in die neue FreeBSD-Version. Der Aktualisierungsprozess ist damit abgeschlossen.

[[freebsdupdate-system-comparison]]
=== Vergleich des Systemzustands

`freebsd-update IDS` kann verwendet werden, um den Zustand der installierten FreeBSD-Version gegenüber einer bekannten und funktionierenden Kopie zu vergleichen. Dieses Kommando vergleicht die aktuelle Version von Systemwerkzeugen, Bibliotheken sowie Konfigurationsdateien und kann als integriertes Intrusion Detection System (IDS) benutzt werden.

[WARNING]
====

Dieses Programm ist kein Ersatz für ein echtes IDS-System wie package:security/snort[]. Da `freebsd-update` Daten auf der Festplatte speichert, ist die Möglichkeit von Verfälschungen offensichtlich. Obwohl diese Möglichkeit durch die Verwendung von `kern.securelevel` oder die Speicherung von Daten auf einem Nur-Lese Dateisystem eingedämmt werden kann, besteht eine bessere Lösung darin, das System gegen ein gesichertes Medium, wie eine DVD oder einen externen, separat aufbewahrten USB-Plattenspeicher, zu vergleichen. Eine alternative Methode zur Bereitstellung von IDS-Funktionaliäten wird in crossref:security[security-ids,"Überprüfung von Binärdateien"] beschrieben.
====

Beginnen Sie den Vergleich, indem Sie das Programm starten und eine Ausgabedatei festlegen:

[source,shell]
....
# freebsd-update IDS >> outfile.ids
....

Das System wird nun überprüft. Dabei wird eine lange Liste von Dateien zusammen mit den SHA256-Hashwerten der Release-Version und den Werten des aktuell installierten Systems, in die angegebene Ausgabedatei geschrieben.

Die Zeilen in der Ausgabe sind extrem lang, aber das Ausgabeformat kann einfach verarbeitet werden. Um beispielsweise eine Liste von allen Dateien zu erhalten, die sich vom aktuellen Release unterscheiden, geben Sie das folgende Kommando ein:

[source,shell]
....
# cat outfile.ids | awk '{ print $1 }' | more
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf
....

Diese Beispielausgabe wurde abgeschnitten, da noch viele weitere Dateien vorhanden sind. Einige Dateien wurden auf natürliche Art verändert. [.filename]#/etc/passwd# wurde beispielsweise geändert, wenn Benutzer zum System hinzugefügt wurden. Kernelmodule können sich unterscheiden, wenn `freebsd-update` diese aktualisiert hat. Um bestimmte Dateien oder Verzeichnisse auszuschließen, fügen Sie diese an die `IDSIgnorePaths`-Option in [.filename]#/etc/freebsd-update.conf# an.

[[updating-upgrading-documentation]]
== Aktualisieren der Dokumentationssammlung

Dokumentation ein wichtiger Bestandteil des FreeBSD Betriebssystems. Obwohl eine aktuelle Version der FreeBSD Dokumentation jederzeit auf der FreeBSD Webseite (link:https://www.FreeBSD.org/doc/[ https://www.freebsd.org/doc/]) verfügbar ist, kann es nützlich sein, eine lokale Kopie der FreeBSD Webseite, Handbücher, FAQ und Artikel zu haben.

Dieser Abschnitt beschreibt, wie Sie die FreeBSD Dokumentation über die Quellen oder die FreeBSD Ports-Sammlung aktuell halten.

Informationen zum Bearbeiten und Einreichen von Korrekturen finden Sie in der link:/books/fdp-primer[Fibel für neue Mitarbeiter des FreeBSD-Dokumentationsprojekts].

[[updating-installed-documentation]]
=== Die FreeBSD-Dokumentation aus den Quellen installieren

Der Bau der FreeBSD Dokumentation aus den Quellen erfordert einige Werkzeuge, die nicht Teil des Basissystems sind. Die erforderlichen Werkzeuge können über den Port oder das Paket package:textproc/docproj[] installiert werden.

Benutzen Sie nach der Installation svnlite, um eine saubere Kopie der Dokumentationsquellen zu holen:

[source,shell]
....
# svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc
....

Es dauert eine Weile, bis die Quellen das allererste Mal heruntergeladen werden. Lassen Sie den Vorgang laufen, bis es fertig ist.

Zukünftige Aktualisierungen der Dokumentationsquellen können wie folgt durchgeführt werden:

[source,shell]
....
# svnlite update /usr/doc
....

Sobald ein aktueller Schnappschuss der Dokumentationsquellen nach [.filename]#/usr/doc# heruntergeladen wurde, ist alles bereit für eine Aktualisierung der bestehenden Dokumentation.

Eine komplette Aktualisierung aller Sprachen kann durch folgende Eingabe erreicht werden:

[source,shell]
....
# cd /usr/doc
# make install clean
....

Wenn nur eine Aktualisierung einer bestimmten Sprache gewünscht wird, kann `make` in einem sprachspezifischen Unterverzeichnis von [.filename]#/usr/doc# aufgerufen werden:

[source,shell]
....
# cd /usr/doc/en_US.ISO8859-1
# make install clean
....

Alternativ kann der folgende Befehl in [.filename]#/usr/doc# oder einem sprachspezifischen Unterverzeichnis abgesetzt werden, um die Dokumentation zu aktualisieren:

[source,shell]
....
# make update
....

Die zu installierenden Ausgabeformate können durch das Setzen von `FORMATS` angegeben werden:

[source,shell]
....
# cd /usr/doc
# make FORMATS='html html-split' install clean
....

Es existieren ein paar Optionen, welche den Prozess der Aktualisierung von Teilen der Dokumentation oder einer bestimmten Übersetzung erleichtern. Diese Optionen können entweder systemweit in [.filename]#/etc/make.conf# gesetzt, oder als Kommandozeilenoptionen an `make` übergeben werden.

Zu den Optionen gehören:

`DOC_LANG`::
Eine Liste von Sprachen und Kodierungen, die gebaut und installiert werden sollen, z.B. `en_US.ISO8859-1`, um nur die englische Dokumentation zu erhalten.

`FORMATS`::
Ein einzelnes Format oder eine Liste von Ausgabeformaten, das gebaut werden soll. Momentan werden `html`, `html-split`, `txt`, `ps` und `pdf` unterstützt.

`DOCDIR`::
Wohin die Dokumentation installiert werden soll. Der Standardpfad ist [.filename]#/usr/shared/doc#.

Für weitere `make`-Variablen, die als systemweite Optionen in FreeBSD unterstützt werden, lesen Sie man:make.conf[5].

[[doc-ports-install-package]]
=== Die Dokumentation aus den Ports aktualisieren

Im vorherigen Abschnitt wurde eine Methode gezeigt, wie die FreeBSD-Dokumentation aus den Quellen gebaut werden kann. Dieser Abschnitt beschreibt eine alternative Methode, in der die Ports-Sammlung verwendet wird und die es ermöglicht:

* vorgefertigte Schnappschüsse der Dokumentation zu installieren, ohne vorher die Werkzeugsammlung der Dokumentation installieren zu müssen.
* die Dokumentationsquellen durch das Ports-System erstellen zu lassen, was die Schritte zum Auschecken und Erstellen etwas erleichtert.

Diese Methoden der Aktualisierung der FreeBSD-Dokumentation werden durch eine Menge von Dokumentations-Ports und Paketen unterstützt, die von {doceng} monatlich aktualisiert wird. Diese sind in der FreeBSD Ports-Sammlung unter der Kategorie "docs" gelistet (http://www.freshports.org/docs/[ http://www.freshports.org/docs/]).

Die Dokumentations-Ports sind wie folgt organisiert:

* Das Paket oder der Port package:misc/freebsd-doc-en[] installiert die englische Dokumentation.
* Das Paket oder der Port package:misc/freebsd-doc-all[] installiert die komplette Dokumentation in allen verfügbaren Sprachen.
* Es gibt noch ein Paket oder einen Port für jede Übersetzung, beispielsweise package:misc/freebsd-doc-hu[] für die ungarische Dokumentation.

Wenn Sie Pakete benutzen, wird die FreeBSD-Dokumentation in allen verfügbaren Formaten der jeweiligen Sprache installiert. Das folgende Beispiel wird das aktuelle Paket der ungarischen Dokumentation installieren:

[source,shell]
....
# pkg install hu-freebsd-doc
....

[NOTE]
====
Pakete verwenden ein Format, welches sich von dem Namen des dazugehörigen Ports unterscheidet: `_lang_-freebsd-doc`. _lang_ entspricht hier der Kurzform des Sprachcodes, z.B. `hu` für Ungarisch, oder `zh_cn` für vereinfachtes Chinesisch.
====

Um das Format der Dokumentation zu bestimmen, muss anstelle des Pakets der Port gebaut werden. Das folgende Beispiel baut und installiert die englische Dokumentation:

[source,shell]
....
# cd /usr/ports/misc/freebsd-doc-en
# make install clean
....

Der Port enthält ein Konfigurationsmenü, in dem das Format ausgewählt werden kann. In der Voreinstellung sind `html-split` und `pdf` ausgewählt.

Alternativ können bei der Erstellung eines Dokumentations-Ports verschiedene `make`-Optionen angegeben werden. Dazu gehören:

`WITH_HTML`::
Erstellt das HTML-Format mit einer einzigen HTML-Datei pro Dokument. Die formatierte Dokumentation wird als Datei mit dem Namen [.filename]#article.html# oder [.filename]#book.html# gespeichert.

`WITH_PDF`::
Die formatierte Dokumentation wird als Datei mit dem Namen [.filename]#article.pdf# oder [.filename]#book.pdf# gespeichert.

`DOCBASE`::
Legt den Pfad fest, wohin die Dokumentation installiert werden soll. Die Voreinstellung ist [.filename]#/usr/local/shared/doc/freebsd#.

Dieses Beispiel verwendet Variablen, um die ungarische Dokumentation als PDF in ein bestimmtes Verzeichnis zu installieren:

[source,shell]
....
# cd /usr/ports/misc/freebsd-doc-hu
# make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean
....

Dokumentations-Ports oder -Pakete können nach den Anweisungen in crossref:ports[ports,Installieren von Anwendungen: Pakete und Ports ] aktualisiert werden. Beispielsweise aktualisiert das folgende Kommando die installierte ungarische Dokumentation mittels package:ports-mgmt/portmaster[] unter Verwendung von Paketen:

[source,shell]
....
# portmaster -PP hu-freebsd-doc
....

[[current-stable]]
== Einem Entwicklungszweig folgen

FreeBSD besitzt zwei Entwicklungszweige: FreeBSD-CURRENT und FreeBSD-STABLE.

Dieser Abschnitt beschreibt beide Zweige sowie deren Interessengruppen und erläutert, wie ein System auf dem aktuellen Stand eines jeweiligen Zweiges gehalten wird.

[[current]]
=== FreeBSD-CURRENT

FreeBSD-CURRENT ist die allerneueste Entwicklung von FreeBSD. Benutzer von FreeBSD-CURRENT sollten über sehr gute technische Fähigkeiten verfügen. Benutzer mit weniger technischen Fähigkeiten sollten stattdessen FreeBSD-STABLE benutzen, wenn sie einem Entwicklungszweig folgen möchten.

FreeBSD-CURRENT besteht aus den neuesten Quellen des FreeBSD-Systems und enthält Sachen, an denen gerade gearbeitet wird, experimentelle Änderungen und Übergangsmechanismen, die im nächsten offiziellen Release enthalten sein können oder nicht. Obwohl FreeBSD-CURRENT täglich von vielen Entwicklern gebaut wird, gibt es Zeiträume, in denen sich das System vielleicht nicht bauen lässt. Diese Probleme werden so schnell wie möglich behoben, aber ob Sie mit FreeBSD-CURRENT eine Katastrophe erleben oder neue Funktionen erhalten, kann von dem Zeitpunkt abhängen, an dem der Quelltext synchronisiert wurde.

FreeBSD-CURRENT wird hauptsächlich für drei Interessengruppen zur Verfügung gestellt:

. Mitglieder der FreeBSD Gemeinschaft, die aktiv an einem Teil des Quellbaums arbeiten.
. Mitglieder der FreeBSD Gemeinschaft, die aktive Tester sind. Diese Personen sind bereit, Zeit in das Lösen von Problemen zu investieren, Vorschläge zu Änderungen oder der generellen Entwicklung von FreeBSD zu machen und Fehlerkorrekturen einzureichen.
. Benutzer, die die Entwicklung im Auge behalten, oder die Quellen zu Referenzzwecken benutzen wollen. Diese Gruppe macht auch Vorschläge oder steuert Quellcode bei.

FreeBSD-CURRENT ist _nicht_ der schnellste Weg, neue Funktionen vor dem offiziellen Release auszuprobieren. Bedenken Sie, dass neue Funktionen noch nicht im vollen Umfang getestet wurden und daher höchstwahrscheinlich Fehler enthalten. Es ist auch nicht der schnellste Weg, um an Fehlerbehebungen (engl. bug fixes) zu kommen. Jede Fehlerbehebung führt mit gleicher Wahrscheinlichkeit neue Fehler ein, mit der sie alte behebt. FreeBSD-CURRENT wird in keiner Weise "offiziell unterstützt".

Um FreeBSD-CURRENT zu folgen:

. Lesen Sie die Mailinglisten {freebsd-current} und {svn-src-head}. Dies ist _notwendig_, um die Kommentare über den akutellen Status des Systems und wichtige Mitteilungen zum aktuellen Zustand von FreeBSD-CURRENT zu erfahren.
+ 
Die {svn-src-head} Mailingliste erfasst die Commit-Logs für jede Änderung und enthält alle relevanten Informationen zu möglichen Seiteneffekten.
+ 
Um diese Listen zu abonnieren, besuchen Sie {mailing-lists-url}, klicken Sie auf die gewünschte Liste und folgen Sie den Anweisungen. Wenn Sie die Änderungen am gesamten Quellbaum verfolgen möchten, abonnieren Sie die {svn-src-all} Liste.
. Synchronisieren Sie die Quellen für FreeBSD-CURRENT. In der Regel wird crossref:mirrors[svn,svnlite] benutzt, um die Quellen für -CURRENT aus dem Zweig `head` zu laden. Verwenden Sie dazu einen Subversion Spiegel aus crossref:mirrors[svn-mirrors,“Subversion Mirror Sites”].
. Aufgrund der Größe des Repositories ist es empfehlenswert, nur die gewünschten Teilbäume auszuchecken. Wenn Sie die Quellen einsetzen und nicht nur darin lesen wollen, laden Sie sich die _kompletten_ Quellen von FreeBSD-CURRENT und nicht nur ausgesuchte Teile.
+ 
Lesen Sie [.filename]#/usr/src/Makefile# sehr aufmerksam und folgen Sie den Anweisungen in <<makeworld>>. Lesen Sie die Mailingliste {freebsd-current} und [.filename]#/usr/src/UPDATING#, um über Änderungen im Installationsverfahren, die manchmal vor der Einführung eines neuen Releases notwendig sind, informiert zu sein.
. Seien Sie aktiv! Benutzer von FreeBSD-CURRENT werden aufgefordert ihre Verbesserungsvorschläge oder Fehlerbehebungen einzureichen. Verbesserungsvorschläge, die Code enthalten, sind jederzeit herzlich willkommen.

[[stable]]
=== FreeBSD-STABLE

FreeBSD-STABLE ist der Entwicklungszweig, auf dem Releases erstellt werden. Dieser Zweig ändert sich langsamer als FreeBSD-CURRENT und alle Änderungen sollten zuvor in FreeBSD-CURRENT ausgetestet sein. Beachten Sie, dass dies _immer noch_ ein Entwicklungszweig ist und daher zu jedem Zeitpunkt die Quellen von FreeBSD-STABLE verwendbar sein können oder eben auch nicht. FreeBSD-STABLE ist Teil des Entwicklungsprozesses und nicht für Endanwender gedacht. Benutzer, die nicht über die notwendigen Ressourcen zum Testen verfügen, sollten stattdessen ein aktuelles Release von FreeBSD benutzen.

Wer daran interessiert ist den Entwicklungsprozess von FreeBSD zu verfolgen oder dazu beizutragen, insbesondere im Hinblick auf das nächste Release, der sollte es in Erwägung ziehen FreeBSD-STABLE zu benutzen.

Obwohl wir versuchen sicherzustellen, dass sich FreeBSD-STABLE jederzeit übersetzen lässt und lauffähig ist, können wir dafür keine Garantie übernehmen. Auch wenn Neuentwicklungen in FreeBSD-CURRENT stattfinden, ist es jedoch so, dass mehr Leute FreeBSD-STABLE anstelle von FreeBSD-CURRENT benutzen und es daher unvermeidlich ist, dass Fehler und Grenzfälle erst in FreeBSD-STABLE auffallen. Aus diesen Gründen empfehlen wir, FreeBSD-STABLE _nicht_ blindlings zu benutzen.

Um FreeBSD-STABLE zu folgen:

. Lesen Sie die Mailingliste {freebsd-stable}, damit Sie über Abhängigkeiten beim Bau von FreeBSD-STABLE und Dinge, die besondere Aufmerksamkeit erfordern, informiert sind. Umstrittene Fehlerbehebungen oder Änderungen werden von den Entwicklern auf dieser Liste bekannt gegeben. Dies erlaubt es den Benutzern, Einwände gegen die vorgeschlagenen Änderungen vorzubringen.
+ 
Abonnieren Sie die passende svn-Liste für den jeweiligen Zweig, den Sie verfolgen. Wenn Sie beispielsweise den Zweig 9-STABLE verfolgen, lesen Sie {svn-src-stable-9}. Diese Liste enthält zu jeder Änderung das Commit-Log, das Informationen zu möglichen Seiteneffekten enthält.
+ 
Um diese Listen zu abonnieren, besuchen Sie die Seite {mailing-lists-url}. Klicken Sie auf die gewünschte Liste und folgen Sie den Anweisungen. Wenn Sie daran interessiert sind, Änderungen am gesamten Quellbaum zu verfolgen, abonnieren Sie {svn-src-all}.
. Wenn Sie ein neues System installieren und dazu einen der monatlich aus FreeBSD-STABLE erzeugten Snapshots verwenden wollen, sollten Sie zuerst link:https://www.FreeBSD.org/snapshots[www.freebsd.org/snapshots"] auf aktuelle Informationen überprüfen. Alternativ können Sie auch das neueste FreeBSD-STABLE-Release von den crossref:mirrors[mirrors,FreeBSD Spiegeln] beziehen.
+ 
Um ein bestehendes FreeBSD-System auf FreeBSD-STABLE zu aktualisieren, benutzen Sie crossref:mirrors[svn,svn] um den gewünschten Entwicklungs- oder Release-Zweig auszuchecken. Die Zweige, wie beispielsweise `stable/9`, sind unter link:https://www.FreeBSD.org/releng/[ www.freebsd.org/releng] aufgeführt.
. Lesen Sie [.filename]#/usr/src/Makefile# sehr aufmerksam bevor Sie FreeBSD-STABLE  aktualisieren und folgen Sie den Anweisungen in <<makeworld>>. Lesen Sie die Mailingliste {freebsd-stable} und [.filename]#/usr/src/UPDATING#, um über Änderungen im Installationsablauf, die manchmal vor der Einführung eines neuen Releases notwendig sind, informiert zu sein.

[[makeworld]]
== FreeBSD aus den Quellen aktualisieren

Das Aktualisieren von FreeBSD aus den Quellen bietet im Vergleich zu binären Updates mehrere Vorteile. Der Quellcode kann mit Optionen gebaut werden, um die Vorteile von spezifischer Hardware zu nutzen. Teile des Basissystems können mit veränderten Einstellungen gebaut, oder falls nicht gewünscht, auch ganz ausgelassen werden. Dieser Prozess dauert zwar länger als die Aktualisierung mit binären Updates, ermöglicht aber eine vollständige Anpassung, um eine individuelle Version von FreeBSD zu erstellen.

[[updating-src-quick-start]]
=== Schnellstartanleitung

Diese kurze Referenz zeigt die typischen Schritte um FreeBSD aus den Quellen zu aktualisieren. Spätere Abschnitte beschreiben die Prozedur im Detail.

[.procedure]
====
* Aktualisierung und Bauprozess*
+
[source,shell]
....
# svnlite update /usr/src  <.>
check /usr/src/UPDATING  <.>
# cd /usr/src          <.>
# make -j4 buildworld  <.>
# make -j4 kernel      <.>
# shutdown -r now      <.>
# cd /usr/src          <.>
# make installworld    <.>
# mergemaster -Ui      <.>
# shutdown -r now      <.>
....

<.> Holt die neueste Version der Quellen. <<updating-src-obtaining-src>> enthält weitere Informationen zum Aktualisieren und Bauen der Quellen.

<.> [.filename]#/usr/src/UPDATING# enthält Anweisungen für alle manuellen Schritte, die vor oder nach dem Bau der Quellen erforderlich sind.

<.> Wechsel in das Bauverzeichnis.

<.> Bau des Basissystems, mit Ausnahme des Kernels.

<.> Bau und Installation des Kernels. Dieser Schritt ist gleichbedeutend mit `make buildkernel installkernel`.

<.> Installation des Basissystems.

<.> Aktualisierung und Zusammenführung der Konfigurationsdateien in [.filename]#/etc#.

<.> Neustart des Systems mit dem neu erstellten Basissystem und Kernel.
====

[[updating-src-preparing]]
=== Vorbereitungen zum Aktualisieren aus den Quellen

Lesen Sie [.filename]#/usr/src/UPDATING#. Jeder manuelle Schritt, welcher vor oder nach der Aktualisierung erforderlich ist, wird in dieser Datei beschrieben.

[[updating-src-obtaining-src]]
=== Den Quellcode aktualisieren

Der Quellcode von FreeBSD befindet sich in [.filename]#/usr/src/#. Die bevorzugte Methode zur Aktualisierung dieser Quellen ist über das Versionskontrollsystem Subversion. Sie sollten sicherstellen, dass der Quellcode unter Versionskontrolle steht:

[source,shell]
....
# svnlite info /usr/src
Path: /usr/src
Working Copy Root Path: /usr/src
...
....

Dies ist ein Hinweis darauf, dass [.filename]#/usr/src/# unter Versionskontrolle steht und mit man:svnlite[1] aktualisiert werden kann.

[source,shell]
....
# svnlite update /usr/src
....

Dieser Vorgang kann einige Zeit in Anspruch nehmen, falls das Verzeichnis nicht zuletzt aktualisiert wurde. Nach Beendigung ist der Quellcode aktuell und der im nächsten Abschnitt beschriebene Bauprozess kann beginnen.

[NOTE]
====
*Synchronisation der Quellen*

Meldet die Ausgabe `'/usr/src' is not a working copy`, dann fehlen entweder Dateien, oder das Verzeichnis wurde mit einer anderen Methode aktualisiert. Ein erneuter Checkout der Quellen ist jetzt erforderlich.

[[updating-src-obtaining-src-repopath]]
.FreeBSD Versionen und Repository-Pfade
[cols="10%,10%,80%", options="header"]
|===
| Ausgabe von uname -r
| Repository-Pfad
| Beschreibung

|`_X.Y_-RELEASE`
|`base/releng/__X.Y__`
|Die Release-Version inklusive kritischer Sicherheits- und Bugfix-Patches. Dieser Zweig wird für die meisten Benutzer empfohlen.

|`_X.Y_-STABLE`
|`base/stable/__X__`
|

Die Release-Version und alle weitere Versionen auf diesem Zweig. _STABLE_ bezieht sich darauf, dass die Binärschnittstelle (ABI) sich nicht ändert, sodass Anwendungen welche auf älteren Versionen erstellt wurden weiterhin lauffähig sind. Eine Anwendung, welche für FreeBSD 10.1 übersetzt wurde, läuft auch auf FreeBSD 10-STABLE.

STABLE-Zweige haben gelegentlich Fehler und Inkompatibilitäten, welche den Benutzer beeinträchtigen könnten. In der Regel werden diese Fehler aber zügig behoben.

|`_X_-CURRENT`
|`base/head/`
|Die neueste unveröffentlichte Version von FreeBSD. Der CURRENT-Zweig kann viele Fehler und Inkompatibilitäten enthalten und wird daher nur für fortgeschrittene Benutzer empfohlen.
|===

Ermitteln Sie mit man:uname[1] die verwendete FreeBSD-Version:

[source,shell]
....
# uname -r
10.3-RELEASE
....

Basierend auf <<updating-src-obtaining-src-repopath>> ist `base/releng/10.3` der Repository-Pfad zur Aktualisierung von `10.3-RELEASE`. Dieser Pfad wird beim Auschecken der Quellen benutzt:

[source,shell]
....
# mv /usr/src /usr/src.bak  <.>
# svnlite checkout https://svn.freebsd.org/base/releng/10.3 /usr/src  <.>
....

<.> Verschiebt das alte Verzeichnis. Wenn es keine lokalen Änderungen in diesem Verzeichnis gibt, kann es gelöscht werden.

<.> Der Pfad aus <<updating-src-obtaining-src-repopath>> wird der Repository-URL hinzugefügt. Der dritte Parameter ist das lokale Zielverzeichnis für den Quellcode.
====

[[updating-src-building]]
=== Den Quellcode bauen

Die Welt, also das gesamte Basissystem mit Ausnahme des Kernels, wird zuerst übersetzt, um aktuelle Werkzeuge zum Erstellen des Kernels bereitzustellen. Anschließend wird der Kernel gebaut:

[source,shell]
....
# cd /usr/src
# make buildworld
# make buildkernel
....

Das Ergebnis wird in [.filename]#/usr/obj# abgelegt.

Dies sind die grundlegenden Schritte. Weitere Optionen zur Kontrolle des Bauprozesses sind nachfolgend beschrieben.

[[updating-src-building-clean-build]]
==== Umgebung für den Bauprozess säubern

Einige Versionen von FreeBSD hinterlassen bereits übersetzten Code im temporären Objektverzeichnis [.filename]#/usr/obj#. Dies kann nachfolgende Bauprozesse beschleunigen, da Code, der nicht verändert wurde, nicht neu übersetzt werden muss. Um eine saubere Umgebung für den Bauprozess zu schaffen, benutzen Sie `cleanworld` bevor Sie mit dem Bau beginnen.

[source,shell]
....
# make cleanworld
....

[[updating-src-building-jobs]]
==== Anzahl der Prozesse einstellen

Eine höhere Anzahl an Prozessen kann die Geschwindigkeit auf Mehrprozessor-Systemen verbessern. Die Anzahl der Kerne lässt sich mit `sysctl hw.cpu` bestimmen. Prozessoren variieren ebenso, wie die verschiedenen Build-Systeme von FreeBSD. Sie müssen daher mehrere Versuche starten um zu sehen, wie die Anzahl der Prozesse die Geschwindigkeit beeinflusst. Als Ausgangspunkt können Sie die halbe bis doppelte Anzahl der Kerne als Wert probieren. Die Anzahl der Prozesse wird mit `-j` angegeben.

[[updating-src-building-jobs-example]]
.Die Anzahl der Prozesse erhöhen
[example]
====
Das Basissystem und den Kernel mit vier Prozessen bauen:

[source,shell]
....
# make -j4 buildworld buildkernel
....

====

[[updating-src-building-only-kernel]]
==== Nur den Kernel erstellen

Wenn sich der Quellcode verändert hat, muss ein `buildworld` ausgeführt werden. Danach kann der Kernel mit `buildkernel` übersetzt werden. Um lediglich den Kernel zu übersetzen:

[source,shell]
....
# cd /usr/src
# make buildkernel
....

[[updating-src-building-custom-kernel]]
==== Einen angepassten Kernel erstellen

Der FreeBSD Standard-Kernel basiert auf einer _Konfigurationsdatei_ namens [.filename]#GENERIC#. Der [.filename]#GENERIC#-Kernel enthält die gängigsten Gerätetreiber und Optionen. Manchmal ist es aber sinnvoll oder gar notwendig, einen angepassten Kernel zu erstellen, um Gerätetreiber oder Optionen hinzuzufügen oder zu entfernen, um bestimmte Anforderungen zu erfüllen.

Zum Beispiel könnte jemand, der einen kleinen eingebetteten Rechner mit eingeschränktem RAM entwickelt, nicht benötigte Gerätetreiber oder Optionen entfernen, um den Kernel etwas kleiner zu machen.

Die Kernelkonfigurationsdateien befinden sich in [.filename]#/usr/src/sys/arch/conf/#, wobei _arch_ die Ausgabe von `uname -m` ist. Auf den meisten Rechnern ist dies `amd64`, demnach befinden sich die Konfigurationsdateien in [.filename]#/usr/src/sys/amd64/conf/#.

[TIP]
====

[.filename]#/usr/src# kann aus Versehen gelöscht oder neu erstellt werden. Daher ist es vorzuziehen, angepasste Kernelkonfigurationsdateien in einen separaten Verzeichnis, wie bspw. [.filename]#/root# zu speichern und diese in das [.filename]#conf#-Verzeichnis zu verlinken. Wenn dieses Verzeichnis gelöscht oder überschrieben wird, kann die Kernelkonfigurationsdatei einfach neu verknüpft werden.
====

Eine benutzerdefinierte Konfigurationsdatei kann durch Kopieren der [.filename]#GENERIC#-Konfigurationsdatei erstellt werden. In diesem Beispiel ist der neue Kernel für einen Speicherserver, heißt also [.filename]#STORAGESERVER#:

[source,shell]
....
# cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER
# cd /usr/src/sys/amd64/conf
# ln -s /root/STORAGESERVER .
....

Jetzt kann [.filename]#/root/STORAGESERVER# bearbeitet werden. Die Manualpage man:config[5] zeigt, wie Treiber und Optionen hinzugefügt oder entfernt werden.

Der angepasste Kernel wird mit der Variablen `KERNCONF`, die auf die Kernelkonfigurationsdatei verweist, übersetzt:

[source,shell]
....
# make buildkernel KERNCONF=STORAGESERVER
....

[[updating-src-installing]]
=== Installation des Codes

Nachdem die Schritte `buildworld` und `buildkernel` abgeschlossen sind, wird der neue Kernel und die Welt installiert:

[source,shell]
....
# cd /usr/src
# make installkernel
# shutdown -r now
# cd /usr/src
# make installworld
# shutdown -r now
....

Wenn ein angepasster Kernel erstellt wurde, muss zusätzlich die Variable `KERNCONF` gesetzt werden:

[source,shell]
....
# cd /usr/src
# make installkernel KERNCONF=STORAGESERVER
# shutdown -r now
# cd /usr/src
# make installworld
# shutdown -r now
....

[[updating-src-completing]]
=== Die Aktualisierung abschließen

Ein paar abschließende Aufgaben beenden die Aktualisierung. Alle Konfigurationsdateien werden mit den neuen Versionen zusammengeführt, veraltete Bibliotheken werden entfernt, dann wird das System neu gestartet.

[[updating-src-completing-merge-mergemaster]]
==== Konfigurationsdateien mit man:mergemaster[8] zusammenführen

man:mergemaster[8] bietet einen einfachen Weg, um die Konfigurationsdateien des Systems mit den neuen Versionen dieser Dateien zusammenzuführen.

Mit der Option `-Ui` aktualisiert man:mergemaster[8] automatisch Dateien, welche nicht vom Benutzer verändert wurden und installiert neue Dateien, die noch nicht vorhanden sind:

[source,shell]
....
# mergemaster -Ui
....

Wenn eine Datei manuell zusammengeführt werden muss, erlaubt eine interaktive Anzeige, zu wählen, welche Teile der Dateien beibehalten werden. Die Manualpage man:mergemaster[8] enthält weitere Informationen.

[[updating-src-completing-check-old]]
==== Veraltete Dateien und Bibliotheken entfernen

Nach einer Aktualisierung können sich immer noch veraltete Dateien und Verzeichnisse im System befinden. Diese lassen sich mit folgendem Kommando auflisten:

[source,shell]
....
# make check-old
....

und löschen:

[source,shell]
....
# make delete-old
....

Einige veraltete Bibliotheken können ebenfalls noch vorhanden sein. Diese werden mit folgenden Kommando aufgelistet:

[source,shell]
....
# make check-old-libs
....

und wie folgt gelöscht:

[source,shell]
....
# make delete-old-libs
....

Programme, die diese alten Bibliotheken noch verwenden, werden nicht mehr funktionieren, wenn die Bibliothek gelöscht wurde. Diese Programme müssen nach dem Löschen der alten Bibliotheken neu gebaut oder ersetzt werden.

[TIP]
====

Wenn Sie sich sicher sind, dass alle Dateien und Verzeichnisse gelöscht werden können, dann setzen Sie `BATCH_DELETE_OLD_FILES`, um nicht jede einzelne Datei mit kbd:[y] und kbd:[Enter] bestätigen zu müssen. Zum Beispiel:

[source,shell]
....
# make BATCH_DELETE_OLD_FILES=yes delete-old-libs
....

====

[[updating-src-completing-restart]]
==== Neustart des Systems

Zum Abschluss der Aktualisierung muss das System neu gestartet werden, damit alle Änderungen wirksam werden:

[source,shell]
....
# shutdown -r now
....

[[small-lan]]
== Installation mehrerer Maschinen

Wenn Sie mehrere Maschinen auf dem gleichen Stand halten wollen, ist es eine Verschwendung von Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu übersetzen. Die Lösung dazu ist, eine Maschine den Großteil der Arbeit durchführen zu lassen und den anderen Maschinen das Ergebnis mit NFS zur Verfügung zu stellen. Dieser Abschnitt zeigt eine Methode dies zu tun. Weitere Informationen zu NFS finden Sie in crossref:network-servers[network-nfs,"Network File System (NFS)"].

Stellen Sie zuerst eine Liste der Maschinen zusammen, die auf demselben Stand sein sollen. Wir nennen diese Maschinen die _Baugruppe_. Jede dieser Maschinen kann mit einem eigenen Kernel laufen, doch sind die Programme des Userlands auf allen Maschinen gleich. Wählen Sie aus der Baugruppe eine Maschine aus, auf der der Bau durchgeführt wird, den _Bau-Master_. Dies sollte eine Maschine sein, die über die nötigen CPU-Ressourcen für `make buildworld` und `make installworld` verfügt.

Sie brauchen auch eine _Testmaschine_, auf der Sie die Updates testen, bevor Sie sie in Produktion installieren. Dies _muss_ eine Maschine sein, die über einen längeren Zeitraum nicht zur Verfügung stehen kann.

Alle Maschinen der Baugruppe müssen [.filename]#/usr/obj# und [.filename]#/usr/src# über NFS vom Bau-Master an gleichem Ort einhängen. Wenn Sie mehrere Baugruppen haben, sollte sich [.filename]#/usr/src# auf einem Bau-Master befinden und über NFS für den Rest der Maschinen zur Verfügung gestellt werden.

Stellen Sie sicher, dass [.filename]#/etc/make.conf# und [.filename]#/etc/src.conf# auf allen Maschinen einer Baugruppe mit der Datei des Bau-Masters übereinstimmt. Der Bau-Master muss jeden Teil des Systems bauen, den irgendeine Maschine der Baugruppe benötigt. Auf dem Bau-Master müssen in [.filename]#/etc/make.conf# alle zu bauenden Kernel mit der Variablen `KERNCONF` bekannt gegeben werden. Geben Sie dabei den Kernel des Bau-Masters zuerst an. Für jeden zu bauenden Kernel muss auf dem Bau-Master die entsprechende Konfigurationsdatei unter [.filename]#/usr/src/sys/arch/conf# abgelegt werden.

Bauen Sie auf dem Bau-Master, wie in <<makeworld>> beschrieben, den Kernel und die Welt, installieren Sie aber nichts. Wechseln Sie auf die Testmaschine und installieren Sie den gerade gebauten Kernel. Hängen Sie auf der Testmaschine [.filename]#/usr/src# und [.filename]#/usr/obj# über NFS ein. Geben Sie dann `shutdown now` ein, um in den Single-User-Modus zu gelangen, von wo aus Sie den neuen Kernel und das System installieren. Lassen Sie anschließend `mergemaster` laufen. Wenn Sie fertig sind, booten Sie die Maschine wieder in den Mehrbenutzermodus.

Nachdem Sie sichergestellt haben, dass die Testmaschine einwandfrei funktioniert, wiederholen Sie diese Prozedur für jede Maschine in der Baugruppe.

Dasselbe Verfahren können Sie auch für die Ports-Sammlung anwenden. Zuerst müssen alle Maschinen einer Baugruppe [.filename]#/usr/ports# über NFS zur Verfügung gestellt bekommen. Setzen Sie ein Verzeichnis für die Quellen auf, das sich alle Maschinen teilen. Dieses Verzeichnis können Sie in [.filename]#/etc/make.conf# mit der Variablen `DISTDIR` angeben. Das Verzeichnis sollte für den Benutzer beschreibbar sein, auf den der Benutzer `root` vom NFS Subsystem abgebildet wird. Jede Maschine sollte noch `WRKDIRPREFIX` auf ein lokales Bauverzeichnis setzen. Wenn Sie vorhaben, Pakete zu bauen und zu verteilen, sollten Sie `PACKAGES` auf ein Verzeichnis mit den gleichen Eigenschaften wie `DISTDIR` setzen.
