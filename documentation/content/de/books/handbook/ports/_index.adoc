---
title: "Kapitel 4. Installieren von Anwendungen: Pakete und Ports"
part: Teil I. Erste Schritte
prev: books/handbook/basics
next: books/handbook/x11
showBookMenu: true
weight: 6
path: "/books/handbook/ports/"
---

[[ports]]
= Installieren von Anwendungen: Pakete und Ports
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Übersicht

FreeBSD enthält eine umfassende Sammlung von Systemwerkzeugen, die Teil des Basissystems sind. Darüber hinaus stellt FreeBSD zwei sich ergänzende Methoden zur Installation von Drittanbieter-Software zur Verfügung: Die Ports-Sammlung zur Installation aus dem Quellcode sowie Pakete zur Installation von vorkompilierten binären Softwarepaketen. Beide Methoden können benutzt werden, um Anwendungen von lokalen Medien oder über das Netzwerk zu installieren.

Dieses Kapitel behandelt die folgenden Themen:

* Den Unterschied zwischen binären Softwarepaketen und Ports.
* Wie man Drittanbieter-Software findet, die nach FreeBSD portiert wurde.
* Wie Binärpakete mit pkg verwaltet werden.
* Den Bau von Drittanbieter-Software aus dem Quellcode mithilfe der Ports-Sammlung.
* Wie man die Dateien findet, die zusammen mit der Anwendung installiert wurden.
* Was zu tun ist, wenn die Installation einer Software fehlschlägt.

[[ports-overview]]
== Installation von Software

Die typischen Schritte zur Installation von Drittanbieter-Software auf einem UNIX(R) System sind:

[.procedure]
. Download der Software, die als Quelltext oder im Binärformat vorliegen kann.
. Auspacken der Software. Dies ist typischerweise ein mit man:compress[1], man:gzip[1], man:bzip2[1] oder man:xz[1] komprimiertes Tar-Archiv.
. Durchsuchen der Dokumentation, die sich in [.filename]#INSTALL#, [.filename]#README# oder mehreren Dateien im Verzeichnis [.filename]#doc/# befindet, nach Anweisungen, wie die Software zu installieren ist.
. Kompilieren der Software, wenn sie als Quelltext vorliegt. Dazu muss vielleicht das [.filename]#Makefile# angepasst, oder `configure` ausgeführt werden.
. Testen und installieren der Software.

Ein FreeBSD-Port ist eine Sammlung von Dateien, die das Kompilieren der Quelltexte einer Anwendung automatisieren. Die Dateien, die ein Port umfasst enthalten alle notwendigen Informationen um die Anwendung herunterzuladen, zu extrahieren, anzupassen und zu installieren.

Wenn die Software nicht bereits für FreeBSD angepasst und getestet wurde, muss vielleicht sogar der Quelltext angepasst werden, damit die Software funktioniert.

Bislang wurden über link:https://www.FreeBSD.org/ports/[{numports}] Anwendungen von Drittanbietern nach FreeBSD portiert. Falls möglich, werden diese Anwendungen als vorkompilierte _Pakete_ zur Verfügung gestellt.

Pakete können mit FreeBSDs Paketverwaltungswerkzeugen manipuliert werden.

Pakete und Ports beachten Abhängigkeiten zwischen Anwendungen. Wenn ein Paket oder die Ports-Sammlung benutzt wird, um eine Anwendung zu installieren, dann werden fehlende Bibliotheken zuerst installiert, sofern sie nicht schon vorher installiert waren.

Ein FreeBSD-Paket enthält vorkompilierte Kopien aller Befehle für eine Anwendung, sowie zusätzliche Konfigurationsdateien und Dokumentation. Pakete können mit den man:pkg[8]-Befehlen, wie `pkg install`, manipuliert werden.

Obwohl beide Technologien gleichartig sind, so haben Pakete und Ports jeweils ihre eigenen Stärken. Welche Technologie eingesetzt wird, hängt letzten Endes von den Anforderungen ab, die an eine bestimmte Anwendung gestellt werden.

.Vorteile von Paketen
* Das komprimierte Paket einer Anwendung ist normalerweise kleiner als das komprimierte Archiv der Quelltexte.
* Pakete müssen nicht mehr kompiliert werden. Dies ist ein Vorteil, wenn große Pakete wie Mozilla, KDE oder GNOME auf langsamen Maschinen installiert werden.
* Wenn Sie Pakete verwenden, brauchen Sie nicht zu verstehen, wie Software unter FreeBSD kompiliert wird.

.Vorteile von Ports
* Da die Pakete auf möglichst vielen System laufen sollen, werden Optionen beim Übersetzen zurückhaltend gesetzt. Wird eine Anwendung über die Ports übersetzt, können die Optionen nach eigenen Bedürfnissen angepasst werden.
* Die Eigenschaften einiger Anwendungen werden über Optionen zum Zeitpunkt des Übersetzens festgelegt. Apache kann zum Beispiel über eine große Auswahl an eingebauten Optionen konfiguriert werden.
+ 
Für einige Fälle existieren verschiedene Pakete einer Anwendung, die beim Übersetzen unterschiedlich konfiguriert wurden. Für Ghostscript gibt es ein [.filename]#ghostscript#-Paket und ein [.filename]#ghostscript-nox11#-Paket, die sich durch die Xorg Unterstützung unterscheiden. Das Erstellen von verschiedenen Paketen wird aber schnell unhandlich, wenn eine Anwendung mehr als ein oder zwei Optionen zum Zeitpunkt des Übersetzens besitzt.
* Die Lizenzbestimmungen mancher Software verbietet ein Verbreiten in binärer Form. Diese Software muss als Quelltext, der durch den Benutzer kompiliert werden muss, ausgeliefert werden.
* Einige Leute trauen binären Distributionen nicht, oder sie ziehen es vor den Quelltext zu lesen, um diesen nach möglichen Problemen zu durchsuchen.
* Der Quellcode wird benötigt, um individuelle Anpassungen anzuwenden.

Wenn Sie über aktualisierte Ports informiert sein wollen, lesen Sie die Mailinglisten {freebsd-ports} und {freebsd-ports-bugs}.

[WARNING]
====

Bevor Sie eine Anwendung installieren, informieren Sie sich auf der Seite https://vuxml.FreeBSD.org/[] über mögliche Sicherheitsprobleme mit der Anwendung, oder führen Sie `pkg audit -F` aus, um alle installierten Pakete auf bekannte Sicherheitslücken zu überprüfen.
====

Der Rest dieses Kapitels beschreibt, wie man Software Dritter mit Paketen und Ports unter FreeBSD installiert und verwaltet.

[[ports-finding-applications]]
== Suchen einer Anwendung

Die Anzahl der nach FreeBSD portierten Anwendungen steigt ständig. Es gibt einige Wege, um nach Anwendungen zu suchen:

* Die FreeBSD-Webseite stellt unter link:https://www.FreeBSD.org/ports/[https://www.FreeBSD.org/ports/] eine aktuelle und durchsuchbare Liste aller Anwendungen zur Verfügung. Die Ports können nach dem Namen den Anwendung, oder über die Software-Kategorie durchsucht werden.
* Dan Langille verwaltet http://www.FreshPorts.org/[FreshPorts.org], das eine umfassende Suchfunktion bietet und Änderungen an den Anwendungen in der Ports-Sammlung verfolgt. Registrierte Benutzer können eine Merkliste erstellen, um automatisch eine E-Mail zu erhalten, sobald ein Port von dieser Liste aktualisiert wurde.
* Wenn Sie bei der Suche nach einer bestimmten Anwendung nicht weiter kommen, versuchen Sie eine Webseite wie http://www.sourceforge.net/[SourceForge.net] oder http://www.github.com/[GitHub.com]. Schauen Sie dann auf der link:https://www.FreeBSD.org/ports/[FreeBSD-Webseite] nach, ob die Anwendung portiert wurde.
* Das Paket Repository nach einer Anwendung durchsuchen:
+
[source,shell]
....
# pkg search subversion
git-subversion-1.9.2
java-subversion-1.8.8_2
p5-subversion-1.8.8_2
py27-hgsubversion-1.6
py27-subversion-1.8.8_2
ruby-subversion-1.8.8_2
subversion-1.8.8_2
subversion-book-4515
subversion-static-1.8.8_2
subversion16-1.6.23_4
subversion17-1.7.16_2
....
+ 
Die Paketnamen enthalten jeweils die Versionsnummer. Wenn ein Port von python abhängt, wird auch die Versionsnummer von python ausgegeben, mit der die Anwendung gebaut wurde. Für einige Ports stehen sogar mehrere Versionen zur Verfügung. Im Fall von Subversion gibt es drei verschiedene Versionen, mit unterschiedlichen Optionen. In diesem Fall wird die Version von Subversion statisch gelinkt. Wenn Sie ein Paket installieren, ist es am besten den Ursprung des Ports anzugeben, also den Pfad in der Ports-Sammlung. Wiederholen Sie `pkg search` mit `-o` um den Ursprung der Pakete anzuzeigen:
+
[source,shell]
....
# pkg search -o subversion
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static
....
+ 
Zudem unterstützt `pkg search` die Suche mit regulären Ausdrücken, nach exakten Treffern, nach der Beschreibung oder nach anderen Feldern in der Repository-Datenbank. Nach der Installation von package:ports-mgmt/pkg[] oder package:ports-mgmt/pkg-devel[], finden Sie in man:pkg-search[8] weitere Details.
* Wenn die Ports-Sammlung bereits installiert ist, gibt es mehrere Methoden, um die lokale Version dieser Port-Sammlung abzufragen. Verwenden Sie `whereis _Datei_` um herauszufinden, in welcher Kategorie ein Port ist, wobei _Datei_ der Name des Programms ist, das installiert werden soll:
+
[source,shell]
....
# whereis lsof
lsof: /usr/ports/sysutils/lsof
....
+ 
Alternativ kann der man:echo[1]-Befehl verwendet werden:
+
[source,shell]
....
# echo /usr/ports/*/*lsof*
/usr/ports/sysutils/lsof
....
+ 
Beachten Sie aber, dass dieser Befehl auch alle Dateien im Verzeichnis [.filename]#/usr/ports/distfiles# findet, auf die der angegebene Suchbegriff passt.
* Ein weiterer Weg nach Software zu suchen besteht darin, die eingebaute Suchfunktion der Ports-Sammlung zu benutzen. Wechseln Sie dazu in das Verzeichnis [.filename]#/usr/ports#, und rufen Sie `make search name=_Anwendungsname_` auf, wobei _Anwendungsname_ der Name der Software ist. Um zum Beispiel nach `lsof` zu suchen:
+
[source,shell]
....
# cd /usr/ports
# make search name=lsof
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps: 
....
+
[TIP]
====

Der integrierte Suchmechanismus verwendet eine Datei mit Index-Informationen. Erscheint eine Meldung, dass der [.filename]#INDEX# benötigt wird, führen Sie `make fetchindex` aus, um die aktuelle Index-Datei herunterzuladen. Mit einem vorhandenen [.filename]#INDEX# ist `make search` in der Lage, die gewünschte Suche durchzuführen.
====
+ 
Die "Path:"-Zeile zeigt an, wo der Port zu finden ist.
+ 
Um weniger Informationen zu erhalten, benutzen Sie die Funktion `quicksearch`:
+
[source,shell]
....
# cd /usr/ports
# make quicksearch name=lsof
Port:	lsof-4.88.d,8
Path:	/usr/ports/sysutils/lsof
Info:	Lists information about open files (similar to fstat(1))
....
+ 
Erweiterte Suchen führen Sie mit `make search key=_Text_` oder `make quicksearch key=_Text_` aus. Damit werden Portnamen, Kommentare, Beschreibungen und Abhängigkeiten nach _Text_ durchsucht. Dies kann sehr nützlich sein, wenn der Name des Programms nicht bekannt ist.
+ 
Bei der Verwendung von `search` und `quicksearch` wird Groß- und Kleinschreibung bei der Suche ignoriert. Die Suche nach "LSOF" wird dieselben Ergebnisse wie die Suche nach "lsof" liefern.

[[pkgng-intro]]
== Benutzen von pkg zur Verwaltung von Binärpaketen

pkg ist der Nachfolger für die traditionellen Paketverwaltungswerkzeuge von FreeBSD. Es bietet viele Funktionen, die den Umgang mit Binärpaketen schneller und einfacher machen.

Wenn Sie lediglich vorgefertigte Binärpakete von den FreeBSD Spiegeln benutzen möchten, ist pkg für die Verwaltung von Paketen ausreichend.

Falls Sie jedoch die Software aus dem Quellcode bauen oder eigene Repositories verwenden, benötigen Sie ein separates <<ports-upgrading-tools, Paketverwaltungswerkzeug>>.

pkg ist kein Ersatz für diese Werkzeuge. Während diese Werkzeuge Drittanbieter-Software sowohl aus Binärpaketen als auch aus der Ports-Sammlung installieren können, so installiert pkg ausschließlich Binärpakete.

[[pkgng-initial-setup]]
=== Erste Schritte mit pkg

FreeBSD enthält ein Bootstrap-Programm, welches pkg zusammen mit den Manualpages installiert. pkg wurde für FreeBSD Versionen ab 10._X_ entwickelt.

[NOTE]
====
Nicht alle FreeBSD Versionen unterstüzen den folgenden Bootstrap Prozess. Eine aktuelle Liste finden Sie unter https://pkg.FreeBSD.org/[]. Andernfalls muss pkg aus der Ports-Sammlung oder als Binärpaket installiert werden.
====

Um das Bootstrap Programm zu starten, geben Sie folgendes ein:

[source,shell]
....
# /usr/sbin/pkg
....

Sie müssen eine Internetverbindung haben, damit der Bootstrap Prozess funktioniert.

Um den Port zu installieren, geben Sie stattdessen folgendes ein:

[source,shell]
....
# cd /usr/ports/ports-mgmt/pkg
# make
# make install clean
....

Bei der Aktualisierung eines bestehenden Systems, welches ursprünglich die alten pkg_* Werkzeuge verwendet hat, muss die Datenbank in das neue Format konvertiert werden, damit die neuen Werkzeuge wissen, welche Pakete bereits installiert sind. Sobald pkg installiert ist, muss die Paketdatenbank mit dem folgenden Befehl vom traditionellen Format in das neue Format konvertiert werden:

[source,shell]
....
# pkg2ng
....

[NOTE]
====
Auf neu installieren Systemen, auf denen noch keine Software von Drittanbietern installiert wurde, kann dieser Schritt entfallen.
====

[IMPORTANT]
====
Die Konvertierung ist unwiderruflich. Sobald die Paketdatenbank in das Format von pkg umgewandelt wurde, sollten die traditionellen pkg_* Werkzeuge nicht mehr benutzt werden.
====

[NOTE]
====
Bei der Konvertierung der Paketdatenbank können Fehler ausgegeben werden, wenn die Inhalte auf die neue Version umgewandelt werden. Im Allgemeinen können diese Fehler ignoriert werden. Wenn pkg2ng fertig ist, wird eine Liste von Software ausgegeben, die nicht erfolgreich konvertiert werden konnte. Diese Anwendungen müssen manuell neu installiert werden.
====

Um sicherzustellen, dass die Ports-Sammlung neue Pakete mit pkg und nicht mit den traditionellen Formaten registriert, muss in FreeBSD 10._X_ und früheren Versionen folgende Zeile in [.filename]#/etc/make.conf# hinzugefügt werden:

[.programlisting]
....
WITH_PKGNG=     yes
....

In der Voreinstellung benutzt pkg die Pakete der FreeBSD-Spiegel (das _Repository_). Wenn Sie ein eigenes Paket-Repository erstellen möchten, lesen Sie <<ports-poudriere>>

Weitere Konfigurationsoptionen für pkg sind in man:pkg.conf[5] beschrieben.

Informationen zur Bedienung von pkg ist in man:pkg[8] verfügbar. Alternativ kann `pkg` ohne zusätzliche Argumente aufgerufen werden.

Jedes Argument von pkg ist in seiner spezifischen Manualpage dokumentiert. Um beispielsweise die Manualpage von `pkg install` zu lesen, geben Sie einen der folgenden Befehle ein:

[source,shell]
....
# pkg help install
....

[source,shell]
....
# man pkg-install
....

Der Rest dieses Abschnitts beschreibt die typischen Verwaltungsaufgaben für Binärpakete, die mit pkg erledigt werden können. Jedes gezeigte Kommando verfügt über Optionen, um das Verhalten anzupassen. Details und weitere Beispiele finden Sie in den Manualpages der einzelnen Kommandos.

[[quarterly-latest-branch]]
=== Die Port-Zweige _Quarterly_ und _Latest_

Der vierteljährliche Zweig (Quarterly) bietet eine besser vorhersehbare und stabilere Erfahrung bei der Installation und Aktualisierung von Ports und Paketen. Dies wird im Wesentlichen dadurch erreicht, das nur Aktualisierungen zugelassen werden, die nicht zum Funktionsumfang gehören. Der vierteljährliche Zweig zielt darauf ab, Sicherheitskorrekturen (Aktualisierungen und Rückportierungen von Commits), Fehlerbehebungen und Port-Konformität oder Framework-Änderungen zu erhalten. Der vierteljährliche Zweig wird zu Beginn eines jeden Quartals im Januar, April, Juli und Oktober von HEAD abgetrennt. Die Zweige werden nach dem Jahr (YYYY) und dem Quartal (Q1 - Q4) benannt, in dem sie erstellt wurden. Zum Beispiel wird der Zweig, der im Januar 2016 erstellt wurde, 2016Q1 genannt. Der neueste Zweig (Latest) stellt die aktuellsten Versionen der Pakete zur Verfügung.

Um vom Quarterly auf Latest zu wechseln, führen Sie die folgenden Befehle aus:

[source,shell]
....
# cp /etc/pkg/FreeBSD.conf /usr/local/etc/pkg/repos/FreeBSD.conf
....

Bearbeiten Sie die Datei [.filename]#/usr/local/etc/pkg/FreeBSD.conf# und ändern Sie in der `url:`-Zeile die Zeichenkette _quarterly_ in _latest_.

Das Ergebnis sollte wie folgt aussehen:

[.programlisting]
....
FreeBSD: {
  url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest",
  mirror_type: "srv",
  signature_type: "fingerprints",
  fingerprints: "/usr/shared/keys/pkg",
  enabled: yes
}
....

Führen Sie zuletzt diesen Befehl aus, um die neuen Repository-Metadaten zu aktualisieren:

[source,shell]
....
# pkg update -f
....

[[pkgng-pkg-info]]
=== Informationen über installierte Pakete anzeigen

Informationen über bereits installierte Pakete können mit `pkg info` angezeigt werden. Dabei wird, wenn keine weiteren Optionen angegeben werden, die Version und die Beschreibung aller Pakete oder eines einzelnen Pakets ausgegeben.

Um zu ermitteln welche Version von pkg installiert ist, geben Sie folgendes ein:

[source,shell]
....
# pkg info pkg
pkg-1.1.4_1
....

[[pkgng-installing-deinstalling]]
=== Installation und Deinstallation von Paketen

Ein Binärpaket installieren Sie mit dem folgenden Befehl, wobei _paketname_ der Name des zu installierenden Pakets ist:

[source,shell]
....
# pkg install paketname
....

Dieser Befehl verwendet Daten aus dem Repository um zu bestimmen, welche Version der Software und welche Abhängigkeiten installiert werden müssen. Um beispielsweise curl zu installieren:

[source,shell]
....
# pkg install curl
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 MB to be downloaded

Proceed with installing packages [y/N]: y
Checking integrity... done
[1/2] Installing ca_root_nss-3.15.1_1... done
[2/2] Installing curl-7.31.0_1... done
Cleaning up cache files...Done
....

Das neue Paket und jedes weitere Paket, das als Abhängigkeit installiert wurde, ist in der Liste der installierten Pakete zu sehen:

[source,shell]
....
# pkg info
ca_root_nss-3.15.1_1     The root certificate bundle from the Mozilla Project
curl-7.31.0_1     Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
pkg-1.1.4_6       New generation package manager
....

Wird ein Paket nicht mehr benötigt, kann es mit `pkg delete` entfernt werden. Zum Beispiel:

[source,shell]
....
# pkg delete curl
The following packages will be deleted:

      curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages [y/N]: y
[1/1] Deleting curl-7.31.0_1... done
....

[[pkgng-upgrading]]
=== Installierte Pakete aktualisieren

Installierte Pakete können mit diesem Kommando auf die neuesten Versionen aktualisiert werden:

[source,shell]
....
# pkg upgrade
....

Dieses Kommando vergleicht und aktualisiert die installierten Versionen der Pakete mit denen im Repository.

[[pkgng-auditing]]
=== Installierte Pakete auditieren

Regelmäßig werden Sicherheitslücken in Drittanbieter-Software entdeckt. pkg besitzt einen eingebauten Auditing-Mechanismus. Um die auf dem System installierte Software auf Sicherheitslücken zu prüfen, geben Sie folgenden Befehl ein:

[source,shell]
....
# pkg audit -F
....

[[pkgng-autoremove]]
=== Automatisches Entfernen unbenutzter Pakete

Das Entfernen eines Pakets kann möglicherweise Abhängigkeiten hinterlassen, die nicht mehr benötigt werden. Unnötige Pakete, die als Abhängigkeit von anderen Paketen installiert wurden, können automatisch erfasst und entfernt werden:

[source,shell]
....
# pkg autoremove
Packages to be removed:
    ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages [y/N]: y
Deinstalling ca_root_nss-3.15.1_1... done
....

Pakete, die als Abhängigkeiten installiert werden, bezeichnet man als _automatische_ Pakete. Nichtautomatische Pakete, also die Pakete, die explizit nicht als Abhängigkeit von einem anderen Paket installiert wurden, können wie folgt angezeigt werden:

[source,shell]
....
# pkg prime-list
nginx
openvpn
sudo
....

`pkg prime-list` ist ein Alias-Befehl, der in [.filename]#/usr/local/etc/pkg.conf# definiert ist. Es gibt noch weitere Befehle die Sie verwenden können, um die Paketdatenbank des Systems abzufragen. Beispielsweise kann der Befehl `pkg prime-origins` benutzt werden, um das ursprüngliche Portverzeichnis der oben gezeigten Liste zu erhalten:

[source,shell]
....
# pkg prime-origins
www/nginx
security/openvpn
security/sudo
....

Diese Liste kann verwendet werden, um alle auf einem System installierten Pakete mit Hilfe von Werkzeugen wie package:ports-mgmt/poudriere[] oder package:ports-mgmt/synth[] neu zu erstellen.

Um ein bereits installiertes Paket als automatisches Paket zu kennzeichnen, können Sie folgenden Befehl benutzen:

[source,shell]
....
# pkg set -A 1 devel/cmake
....

Sobald ein Paket nicht mehr genutzt wird und es als automatisch gekennzeichnet ist, wird es durch `pkg autoremove` erfasst.

Das kennzeichnen eines installierten Pakets als _nicht_ automatisch kann wie folgt gemacht werden:

[source,shell]
....
# pkg set -A 0 devel/cmake
....

[[pkgng-backup]]
=== Wiederherstellung der Paketdatenbank

Im Gegensatz zum alten Paketverwaltungssystem beinhaltet pkg einen eigenen Mechanismus zur Sicherung der Paketdatenbank. Diese Funktionalität ist standardmäßig aktiviert.

[TIP]
====

Um das Skript daran zu hindern, eine Sicherung der Paketdatenbank zu erstellen, muss in man:periodic.conf[5] `daily_backup_pkgdb_enable="NO"` gesetzt werden.
====

Um den Inhalt einer früheren Paketdatenbank wiederherzustellen, geben Sie folgendes Kommando ein und ersetzen Sie _/path/to/pkg.sql_ durch den Speicherort der gesicherten Datenbank:

[source,shell]
....
# pkg backup -r /path/to/pkg.sql
....

[NOTE]
====
Wenn Sie eine Sicherung wiederherstellen, die von einem `periodic` Skript erstellt wurde, müssen Sie diese zuerst dekomprimieren.
====

Um eine manuelle Sicherung der pkg Paketdatenbank zu erstellen, führen Sie den folgenden Befehl aus, und ersetzen Sie _/path/to/pkg.sql_ durch einen geeigneten Dateinamen:

[source,shell]
....
# pkg backup -d /path/to/pkg.sql
....

[[pkgng-clean]]
=== Alte Pakete entfernen

Standardmäßig speichert pkg Pakete in einem Cache-Verzeichnis, welches in man:pkg.conf[5] in der Variablen `PKG_CACHEDIR` definiert wird. Nur Kopien der neusten installierten Pakete werden beibehalten. Ältere Versionen von pkg haben alle Pakete aufbewahrt. Um diese veralteten Pakete zu entfernen, geben Sie folgendes ein:

[source,shell]
....
# pkg clean
....

Um alle Pakte aus dem Cache-Verzeichnis zu löschen, geben Sie ein:

[source,shell]
....
# pkg clean -a
....

[[pkgng-set]]
=== Manipulation der Paket-Metadaten

Bei Software aus der FreeBSD Ports-Sammlung kann es vorkommen, dass die Hauptversionsnummer geändert wird. Dafür hat pkg ein eingebautes Kommando, um die Quelle eines Pakets zu aktualisieren. Dies ist nützlich, wenn zum Beispiel package:lang/php5[] zu package:lang/php53[] umbenannt wurde, damit package:lang/php5[] jetzt die Version `5.4` integrieren kann.

Um die Quelle des Pakets für das obige Beispiel zu ändern, geben Sie folgendes ein:

[source,shell]
....
# pkg set -o lang/php5:lang/php53
....

Ein weiteres Beispiel: Um package:lang/ruby18[] auf package:lang/ruby19[] zu aktualisieren, geben Sie folgendes ein:

[source,shell]
....
# pkg set -o lang/ruby18:lang/ruby19
....

In diesem letzten Beispiel wird die Quelle der Bibliotheken von [.filename]#libglut# von package:graphics/libglut[] auf package:graphics/freeglut[] geändert:

[source,shell]
....
# pkg set -o graphics/libglut:graphics/freeglut
....

[NOTE]
====
Bei einem Wechsel der Paketquelle ist es notwendig, die Pakete neu zu installieren, welche von dem Paket abhängig sind, das seine Paketquelle geändert hat. Um eine Neuinstallation von abhängigen Paketen zu erzwingen, führen Sie folgenden Befehl aus:

[source,shell]
....
# pkg install -Rf graphics/freeglut
....

====

[[ports-using]]
== Benutzen der Ports-Sammlung

Die Ports-Sammlung ist eine Reihe von [.filename]##Makefile##s, Patches und Beschreibungen. Die Dateien für den Bau und die Installation von einzelnen Anwendungen unter FreeBSD werden als _Port_ bezeichnet.

In der Voreinstellung wird die Ports-Sammlung im Verzeichnis [.filename]#/usr/ports# gespeichert.

Bevor eine Anwendung aus den Ports erstellt werden kann, muss zuerst die Ports-Sammlung installiert werden. Wenn dies nicht bereits bei der Installation von FreeBSD geschehen ist, benutzen Sie eine der beiden Methoden um sie zu installieren:

[[ports-using-portsnap-method]]
[.procedure]
****
*Procedure: Installation mit Portsnap*

FreeBSDs Basissystem enthält mit Portsnap ein schnelles und benutzerfreundliches Werkzeug zur Installation der Ports-Sammlung und die bevorzugte Wahl für die meisten Benutzer, die noch nicht FreeBSD-CURRENT benutzen. Dieses Programm stellt eine Verbindung zu einem FreeBSD-Server her, überprüft den gesicherten Schlüssel und lädt eine aktuelle Kopie der Ports-Sammlung herunter. Der Schlüssel wird benötigt, um die Integrität der heruntergeladenen Dateien zu untersuchen.

. Laden Sie einen komprimierten Snapshot der Ports-Sammlung in [.filename]#/var/db/portsnap#:
+
[source,shell]
....
# portsnap fetch
....
+
. Wenn Sie Portsnap das erste Mal verwenden, müssen Sie den Snapshot nach [.filename]#/usr/ports# extrahieren:
+
[source,shell]
....
# portsnap extract
....
+
. Nach dem ersten Einsatz von Portsnap, kann [.filename]#/usr/ports# wie folgt aktualisiert werden:
+
[source,shell]
....
# portsnap fetch
# portsnap update
....
+ 
Bei der Verwendung von `fetch` können die `extract` oder `update` Operationen nacheinander ausgeführt werden, etwa so:
+
[source,shell]
....
# portsnap fetch update
....
****

[[ports-using-subversion-method]]
[.procedure]
****
*Procedure: Installation mit Subversion*

Wird mehr Kontrolle über die Ports-Sammlung benötigt, oder wenn die lokalen Änderungen beibehalten werden sollen, oder Sie FreeBSD-CURRENT benutzen, kann Subversion benutzt werden, um die Ports-Sammlung zu laden. Lesen Sie extref:{committers-guide}[den Subversion Primer, subversion-primer] für eine detaillierte Beschreibung von Subversion.

. Subversion muss installiert sein, bevor die Ports-Sammlung geladen werden kann. Ist eine lokale Kopie der Ports-Sammlung bereits vorhanden, installieren Sie Subversion wie folgt:
+
[source,shell]
....
# cd /usr/ports/devel/subversion
# make install clean
....
+ 
Wenn keine lokale Kopie der Ports-Sammlung vorhanden ist, oder pkg zur Verwaltung von Paketen benutzt wird, kann Subversion als Paket installiert werden:
+
[source,shell]
....
# pkg install subversion
....
+
. Laden Sie eine Kopie der Ports-Sammlung:
+
[source,shell]
....
# svn checkout https://svn.FreeBSD.org/ports/head /usr/ports
....
+
. Nach dem erstmaligen checkout mit Subversion kann [.filename]#/usr/ports# wie folgt aktualisiert werden:
+
[source,shell]
....
# svn update /usr/ports
....
****

Die Ports-Sammlung enthält eine Reihe von Verzeichnissen, die jeweils eine Softwarekategorie repräsentieren. Jede Kategorie hat für jede einzelne Anwendung ein weiteres Unterverzeichnis. Jedes Unterverzeichnis enthält Dateien, die FreeBSD sagen, wie ein Programm kompiliert und installiert werden muss. Diese Dateien werden auch Port-"Gerüst" genannt. Jedes Port-"Gerüst" beinhaltet die folgenden Dateien und Verzeichnisse:

* [.filename]#Makefile#: enthält Anweisungen, die spezifizieren, wie die Anwendung kompiliert wird und wohin die Komponenten installiert werden sollten.
* [.filename]#distinfo#: enthält die Namen und die Prüfsummen der Dateien, die heruntergeladen werden müssen, um den Port zu bauen.
* [.filename]#files#: dieses Verzeichnis enthält Patches, welche das Übersetzen und Installieren der Anwendung unter FreeBSD ermöglichen. Zudem können noch weitere Dateien, die für die Übersetzung des Ports verwendet werden, enthalten sein.
* [.filename]#pkg-descr#: enthält eine ausführlichere Beschreibung der Anwendung.
* [.filename]#pkg-plist#: eine Liste aller Dateien, die durch diesen Port installiert werden. Außerdem sind hier Informationen enthalten, die zum Entfernen des Ports benötigt werden.

Einige Ports beinhalten noch [.filename]#pkg-message# oder weitere Dateien, die vom Port-System benutzt werden, um spezielle Situationen zu handhaben. Wenn Sie mehr über diese Dateien oder das Port-System erfahren wollen, lesen Sie das extref:{porters-handbook}[FreeBSD Porter's Handbook].

Ein Port enthält nicht den eigentlichen Quellcode, der auch als "Distfile" bekannt ist. Der heruntergeladene Quellcode wird automatisch nach [.filename]#/usr/ports/distfiles# extrahiert.

[[ports-skeleton]]
=== Ports installieren

Dieser Abschnitt beschreibt die grundlegende Benutzung der Ports-Sammlung, um Software zu installieren oder zu deinstallieren. Eine ausführliche Beschreibung der einzelnen `make`-Targets finden Sie in man:ports[7].

[WARNING]
====

Stellen Sie sicher, dass die Ports-Sammlung aktuell ist, bevor Sie einen Port kompilieren. Informieren Sie sich vorher zusätzlich unter https://vuxml.FreeBSD.org/[] über mögliche Sicherheitsprobleme des zu installierenden Ports. Alternativ können Sie `pkg audit -F` ausführen, bevor Sie einen neuen Port installieren. Die täglich laufende Sicherheitsprüfung des Systems aktualisiert ebenfalls die Datenbank und prüft installierte Anwendungen auf vorhandene Sicherheitsprobleme. Weitere Informationen finden Sie in man:pkg-audit[8] und man:periodic[8].
====

Die Benutzung der Ports-Sammlung setzt eine funktionierende Internetverbindung und Superuser-Rechte voraus.

Um einen Port zu installieren, wechseln Sie in das Verzeichnis des Ports, den Sie installieren möchten. Geben Sie dann `make install` am Prompt ein:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make install
>> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.88
...
[Ausgabe des Auspackens weggelassen]
...
>> Checksum OK for lsof_4.88D.freebsd.tar.gz.
===>  Patching for lsof-4.88.d,8
===>  Applying FreeBSD patches for lsof-4.88.d,8
===>  Configuring for lsof-4.88.d,8
...
[configure-Ausgabe weggelassen]
...
===>  Building for lsof-4.88.d,8
...
[Ausgabe der Übersetzung weggelassen]
...
===>  Installing for lsof-4.88.d,8
...
[Ausgabe der Installation weggelassen]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.57
===>   Registering installation for lsof-4.57
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/bin/lsof
#
....

Da `lsof` eine Anwendung ist, die mit erhöhten Rechten läuft, wird nach der Installation eine Sicherheitswarnung angezeigt. Sobald die Installation abgeschlossen ist, erscheint wieder der Prompt.

Um die Suche nach Kommandos zu beschleunigen, speichern einige Shells eine Liste der verfügbaren Kommandos in den durch die Umgebungsvariable `PATH` gegebenen Verzeichnissen. Benutzer der `tcsh` müssen eventuell `rehash` eintippen, um die neu installierten Kommandos benutzen zu können, ohne den vollständigen Pfad anzugeben. Benutzer der Shell `sh` müssen stattdessen `hash -r` eintippen. Weitere Informationen finden Sie in der Dokumentation der jeweiligen Shell.

Bei der Installation wird ein Arbeitsverzeichnis erstellt, das alle temporären Dateien enthält, die während des Bauvorgangs benötigt werden. Wenn dieses Verzeichnis nach der Installation entfernt wird, spart dies Plattenplatz und minimiert mögliche Probleme bei der Aktualisierung des Ports auf eine neuere Version:

[source,shell]
....
# make clean
===>  Cleaning for lsof-4.88.d,8
#
....

[NOTE]
====
Sie können zwei Schritte sparen, wenn Sie bei der Kompilierung des Ports gleich `make install clean` eingeben.
====

==== Port Installation anpassen

Einige Ports bieten Optionen, mit denen zusätzliche Funktionen oder Sicherheitsoptionen eingestellt werden können. Beispiele dafür sind package:www/firefox[], package:security/gpgme[] und package:mail/sylpheed-claws[]. Wenn ein Port von anderen Ports abhängig ist und diese über zusätzliche Abhängigkeiten und Optionen verfügen, wird mehrmals ein Menü ausgegeben, wo der Benutzer verschiedene Optionen wählen kann. Um dies zu vermeiden und die Konfiguration in einem Stück zu erledigen, wechseln Sie in das Verzeichnis des Ports und geben Sie `make config-recursive` ein. Führen Sie danach `make install [clean]` aus, um den Port zu kompilieren und zu installieren.

[TIP]
====

Bei der Verwendung von `config-recursive` wird eine Liste von Ports, die konfiguriert werden, vom Target `all-depends-list` erstellt. Es wird empfohlen, `make config-recursive` so lange auszuführen, bis alle Optionen der abhängigen Ports definiert sind und keine Optionen und Menüs mehr erscheinen. Damit soll sichergestellt werden, dass alle Optionen konfiguriert wurden.
====

Es gibt diverse Möglichkeiten, dieses Menü nach dem Bau eines Ports erneut aufzurufen, um Optionen zu entfernen, hinzuzufügen oder anzupassen. Sie können beispielsweise mit `cd` in das Verzeichnis des Ports wechseln und dort `make config` eingeben. Eine andere Möglichkeit ist `make showconfig`. Eine weitere Alternative bietet `make rmconfig`, das alle ursprünglich gewählten Optionen zurücksetzt und es Ihnen dadurch ermöglicht, die Konfiguration erneut zu beginnen. Die eben erwähnten Optionen werden ausführlich in man:ports[7] beschrieben.

Die Ports-Sammlung benutzt zum Herunterladen von Dateien man:fetch[3], das diverse Umgebungsvariablen unterstützt. Die Variablen `FTP_PASSIVE_MODE`, `FTP_PROXY` und `FTP_PASSWORD` müssen unter Umständen gesetzt werden, wenn das FreeBSD-System hinter einer Firewall oder einem FTP/HTTP-Proxy arbeitet. Eine vollständige Liste der unterstützten Variablen finden Sie in man:fetch[1].

Benutzer ohne eine ständige Internet-Verbindung können `make fetch` im Verzeichnis [.filename]#/usr/ports# ausführen, um die benötigten Dateien herunterzuladen. Es ist auch möglich, `make fetch` nur in einem Teil des Baums, wie [.filename]#/usr/ports/net#, aufzurufen. Die Dateien von allen abhängigen Ports werden mit diesem Kommando allerdings nicht heruntergeladen. Wenn Sie diese Dateien ebenfalls herunterladen wollen, benutzen Sie stattdessen `make fetch-recursive`.

In einigen seltenen Fällen ist es erforderlich, die benötigten Dateien von einem anderen Ort als den im Port definierten `MASTER_SITES` herunterzuladen. Sie können `MASTER_SITES` mit dem folgenden Kommando überschreiben:

[source,shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch
....

Die Variablen `WRKDIRPREFIX` und `PREFIX` überschreiben das voreingestellte Bau- und Zielverzeichnis. Zum Beispiel:

[source,shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

Dieses Kommando baut den Port unter [.filename]#/usr/home/example/ports# und installiert ihn unter [.filename]#/usr/local#.

Die Variable `PREFIX` legt das Installations-Verzeichnis fest:

[source,shell]
....
# make PREFIX=/usr/home/example/local install
....

In diesem Beispiel wird der Port unter [.filename]#/usr/ports# gebaut und nach [.filename]#/usr/home/example/local# installiert.

Sie können beide Variablen auch zusammen benutzen:

[source,shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

Alternativ können diese Variablen auch als Umgebungsvariablen gesetzt werden. In der Manualpage Ihrer Shell finden Sie Anweisungen, wie Umgebungsvariablen gesetzt werden.

[[ports-removing]]
=== Entfernen installierter Ports

Installierte Ports können mit `pkg delete` wieder deinstalliert werden. Beispiele für dieses Kommando finden Sie in man:pkg-delete[8].

Alternativ kann `make deinstall` im Verzeichnis des Ports aufgerufen werden:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make deinstall
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

        lsof-4.88.d,8

Thee deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done
....

Es wird empfohlen die Nachrichten zu lesen, die ausgegeben werden, wenn ein Port deinstalliert wird. Wenn der Port noch Anwendungen hat, die von ihm abhängig sind, werdenn diese am Bildschirm angezeigt, aber die Deinstallation wird forgesetzt. In solchen Fällen ist es besser, die Anwendung neu zu installieren, um fehlende Abhängigkeiten zu vermeiden.

[[ports-upgrading]]
=== Ports aktualisieren

Im Laufe der Zeit stehen neuere Versionen der Software in der Ports-Sammlung zur Verfügung. In diesem Abschnitt wird beschrieben, wie Sie bestimmen, welche Software aktualisiert werden kann und wie das Upgrade durchzuführen ist.

Um festzustellen, ob neuere Versionen der installierten Ports verfügbar sind, stellen Sie sicher, dass die neueste Version der Ports-Sammlung installiert ist. Dies wird in <<ports-using-portsnap-method, "Installation mit Portsnap">> und <<ports-using-subversion-method, "Installation mit Subversion">> beschrieben. Führen Sie unter FreeBSD 10 und neueren Versionen, bzw. auf Systemen die bereits mit pkg arbeiten, den folgenden Befehl aus, um eine Liste der installierten Ports zu erhalten für die eine aktuelle Version existiert:

[source,shell]
....
# pkg version -l "<"
....

Mit FreeBSD 9.__X__ und älteren Versionen kann stattdessen dieser Befehl verwendet werden:

[source,shell]
....
# pkg_version -l "<"
....

[IMPORTANT]
====
Lesen Sie zuerst [.filename]#/usr/ports/UPDATING#, bevor Sie einen Port aktualisieren. In dieser Datei werden Probleme und zusätzlich durchzuführende Schritte bei der Aktualisierung einzelner Ports beschrieben. Dazu gehören solche Dinge wie geänderte Dateiformate, verschobene Konfigurationsdateien, aber auch Inkompatibilitäten zu einer Vorgängerversion. Notieren Sie sich alle Anweisungen der Ports, die aktualisiert werden müssen. Folgen Sie den Anweisungen, wenn Sie das Upgrade durchführen.
====

[[ports-upgrading-tools]]
==== Werkzeuge für die Aktualisierung und Verwaltung von Ports

Die Ports-Sammlung enthält mehrere Werkzeuge, um die eigentliche Aktualisierung durchzuführen. Jedes hat seine Stärken und Schwächen.

Historisch gesehen verwenden die meisten Installationen entweder Portmaster oder Portupgrade. Synth ist eine neuere Alternative.

[NOTE]
====
Es bleibt dem Systemadministrator überlassen, welches dieser Werkzeuge für ein bestimmtes System am besten geeignet ist. Es wird empfohlen, die Daten zu sichern, bevor Sie eines dieser Werkzeuge verwenden.
====

[[portmaster]]
==== Ports mit Portmaster aktualisieren

package:ports-mgmt/portmaster[] ist ein sehr kleines Werkzeug zum Aktualisieren von Ports. Es wurde entwickelt, um mit den Werkzeugen aus dem FreeBSD Basissystem zu arbeiten, ohne dabei von anderen Ports oder Datenbanken abhängig zu sein. Sie können das Programm aus der Ports-Sammlung installieren:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

Portmaster teilt Ports in vier Kategorien ein:

* Root Port: hat keine Abhängigkeiten und andere Ports sind nicht von diesem Port abhängig.
* Trunk Port: hat keine Abhängigkeiten, aber andere Ports sind von diesem Port abhängig.
* Branch Port: hat Abhängigkeiten und andere Ports sind von diesem Port abhängig.
* Leaf Port: hat Abhängigkeiten, aber andere Ports sind nicht von diesem Port abhängig.

Um eine Liste der installierten Ports anzuzeigen und nach neueren Versionen zu suchen, verwenden Sie:

[source,shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache22-2.2.3
        ===>>> New version available: apache22-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

Um alle installierten Ports zu aktualisieren, verwenden Sie folgenden Befehl:

[source,shell]
....
# portmaster -a
....

[NOTE]
====
In der Voreinstellung erzeugt Portmaster eine Sicherheitskopie, bevor ein installierter Port gelöscht wird. Ist die Installation der neuen Version erfolgreich, wird dieses Backup wieder gelöscht. Wollen Sie das Backup lieber manuell löschen, verwenden Sie die Option `-b` beim Aufruf von Portmaster. Durch die Verwendung von `-i` wird Portmaster im interaktiven Modus gestartet und fragt bei jedem zu aktualisierenden Port nach, wie weiter vorgegangen werden soll. Viele weitere Optionen stehen zur Verfügung. Lesen Sie die Manualpage von man:portmaster[8] für weitere Einzelheiten in Bezug auf ihre Nutzung.
====

Treten während der Aktualisierung Fehler auf, verwenden Sie die Option `-f`, um alle Ports zu aktualisieren beziehungsweise neu zu bauen:

[source,shell]
....
# portmaster -af
....

Portmaster ist auch in der Lage, neue Ports zu installieren, wobei zuvor alle abhängigen Ports aktualisiert werden. Um diese Funktion zu nutzen, geben Sie den Pfad des Ports in der Ports-Sammlung an:

[source,shell]
....
# portmaster shells/bash
....

Weitere Informationen über package:ports-mgmt/portmaster[] finden Sie in der Beschreibung [.filename]#pkg-descr#.

[[portupgrade]]
==== Ports mit Portupgrade aktualisieren

package:ports-mgmt/portupgrade[] ist ein weiteres Werkzeug zur Aktualisierung von Ports. Es installiert eine Reihe von Anwendungen, die für die Verwaltung von Ports verwendet werden können. Das Programm ist jedoch von Ruby abhängig. Um den Port zu installieren, geben Sie ein:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

Durchsuchen Sie vor jedem Update die Liste der installierten Ports mit `pkgdb -F` und beheben Sie alle gefundenen Probleme.

Benutzen Sie `portupgrade -a`, um automatisch alle veralteten Ports auf dem System zu aktualisieren. Verwenden Sie zusätzlich den Schalter `-i`, wenn Sie individuell entscheiden wollen, ob ein Port aktualisiert werden soll:

[source,shell]
....
# portupgrade -ai
....

Um nur eine spezifische Anwendung zu aktualisieren, verwenden Sie `portupgrade _Paketname_`. Es ist wichtig den Schalter `-R` zu benutzen, um zuvor alle Ports zu aktualisieren, die von dem gegebenen Anwendung abhängen.

[source,shell]
....
# portupgrade -R firefox
....

Um Pakete anstelle von Ports zu installieren, verwenden Sie den Schalter `-P`. Mit dieser Option durchsucht Portupgrade die in der Umgebungsvariablen `PKG_PATH` aufgeführten Verzeichnisse nach Paketen. Sind lokal keine Pakete vorhanden, versucht Portupgrade die Pakete über das Netz herunterzuladen. Gibt es die Pakete weder lokal noch auf entfernten Rechnern, werden die Ports verwendet. Um die Nutzung von Ports gänzlich zu verhindern, benutzen Sie die Option `-PP`. Portupgrade würde dann abbrechen, falls keine Pakete zur Verfügung stehen.

[source,shell]
....
# portupgrade -PP gnome3
....

Wenn Sie nur die Quelldateien des Ports, oder die Pakete mit `-P` herunterladen möchten, ohne die Anwendung zu bauen oder zu installieren, geben Sie den Schalter `-F` an. Weitere Informationen zu den verfügbaren Schaltern finden Sie in der Manualpage von man:portupgrade[1].

Weitere Informationen über package:ports-mgmt/portupgrade[] finden Sie in der Beschreibung [.filename]#pkg-descr#.

[[ports-disk-space]]
=== Platzbedarf von Ports

Die Nutzung der Ports-Sammlung wird im Laufe der Zeit viel Plattenplatz verschlingen. Nach dem Bau und der Installation eines Ports, wird `make clean` die temporären Arbeitsverzeichnisse [.filename]#work# aufräumen. Portmaster wird dieses Verzeichnis nach der Installation eines Ports automatisch entfernen (es sei denn, die Option `-K` wird verwendet). Wenn Portupgrade installiert ist, wird der folgende Befehl alle Arbeitsverzeichnisse der lokalen Ports-Sammlung entfernen:

[source,shell]
....
# portsclean -C
....

Zusätzlich werden sich im Laufe der Zeit zahlreiche veraltete Distfiles in [.filename]#/usr/ports/distfiles# ansammeln. Mit Portupgrade können alle Distfiles gelöscht werden, die vom keinem Port mehr benötigt werden:

[source,shell]
....
# portsclean -D
....

Portupgrade kann alle Distfiles löschen, die von keinem derzeit installierten Port benötigt werden:

[source,shell]
....
# portsclean -DD
....

Wenn Portmaster installiert ist, benutzen Sie diesen Befehl:

[source,shell]
....
# portmaster --clean-distfiles
....

In der Voreinstellung arbeitet dieses Programm interaktiv und fragt den Benutzer um Bestätigung, bevor ein Distfile gelöscht wird.

Zusätzlich zu diesen Kommandos gibt es noch package:port-mgmt/pkg_cutleaves[]. Dieses Werkzeug automatisiert die Deinstallation von installierten Ports, die nicht weiter benötigt werden.

[[ports-poudriere]]
== Pakete mit Poudriere bauen

Poudriere ist ein unter der BSD-Lizenz stehendes Werkzeug zum Erstellen und Testen von FreeBSD-Paketen. Dieses Programm nutzt FreeBSD Jails, um die Pakete in einer isolierten Umgebung zu bauen. Diese Jails können verwendet werden, um Pakete für andere Versionen von FreeBSD zu bauen, oder um auf einem amd64-System Pakete für i386 zu bauen. Sobald die Pakete gebaut sind, haben sie das gleiche Format wie auf den offiziellen Spiegeln. Die Pakete können dann mit man:pkg[8] oder anderen Paketverwaltungswerkzeugen benutzt werden.

Poudriere wird über das Paket oder den Port package:ports-mgmt/poudriere[] installiert. Die Installation beinhaltet eine Beispielkonfiguration in [.filename]#/usr/local/etc/poudriere.conf.sample#. Kopieren Sie diese Datei nach [.filename]#/usr/local/etc/poudriere.conf#. Bearbeiten Sie dann die kopierte Datei, um die Konfiguration anzupassen.

Obwohl ZFS für poudriere nicht zwingend erforderlich ist, so hat die Nutzung doch einige Vorteile. Wird ZFS eingesetzt, muss in [.filename]#/usr/local/etc/poudriere.conf# die Variable `ZPOOL` definiert, und die Variable `FREEBSD_HOST` auf einen nahe gelegenen Spiegel gesetzt werden. Die Definition von `CCACHE_DIR` erlaubt die Verwendung von package:devel/ccache[], um die Bauzeit für häufig kompilierten Code verkürzen. Es kann vorteilhaft sein, die poudriere-Datasets in einem separaten Verzeichnis auf [.filename]#/poudriere# einzuhängen. Die Werte der anderen Konfigurationsvariablen sind in der Regel angemessen und brauchen nicht geändert werden.

Die Anzahl der Kerne im Prozessor wird verwendet um zu bestimmen, wie viele Bauprozesse parallel ausgeführt werden. Stellen Sie ausreichend virtuellen Speicher bereit, entweder in Form von RAM oder als Swap-Speicher. Ist der virtuelle Speicher aufgebraucht, bricht der Bauprozess ab und die Jails stürzen ab, was zu seltsamen Fehlermeldungen führt.

[[poudriere-initialization]]
=== Jails und Ports-Sammlung initialisieren

Nach der Konfiguration muss poudriere initialisiert werden, damit es eine Jail mit der benötigten Ports-Sammlung startet. Geben Sie mit `-j` den Namen der Jail und mit `-v` die gewünschte FreeBSD-Version an. Auf FreeBSD/amd64-Systemen kann die Architektur mit dem Schalter `-a` und `i386` oder `amd64` gesetzt werden. Der voreingestellte Wert für die Architektur können Sie sich mit `uname` anzeigen lassen.

[source,shell]
....
# poudriere jail -c -j 11amd64 -v 11.4-RELEASE
[00:00:00] Creating 11amd64 fs at /poudriere/jails/11amd64... done
[00:00:00] Using pre-distributed MANIFEST for FreeBSD 11.4-RELEASE amd64
[00:00:00] Fetching base for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/base.txz              125 MB 4110 kBps    31s
[00:00:33] Extracting base... done
[00:00:54] Fetching src for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/src.txz               154 MB 4178 kBps    38s
[00:01:33] Extracting src... done
[00:02:31] Fetching lib32 for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
[00:02:38] Extracting lib32... done
[00:02:42] Cleaning up... done
[00:02:42] Recording filesystem state for clean... done
[00:02:42] Upgrading using ftp
/etc/resolv.conf -> /poudriere/jails/11amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... done.
Fetching metadata signature for 11.4-RELEASE from update4.freebsd.org... done.
Fetching metadata index... done.
Fetching 2 metadata files... done.
Inspecting system... done.
Preparing to download files... done.
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. done.
Applying patches... done.
Fetching 6 files... done.
The following files will be added as part of updating to
11.4-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
11.4-RELEASE-p1:
[…]
Installing updates...Scanning //usr/shared/certs/blacklisted for certificates...
Scanning //usr/shared/certs/trusted for certificates...
 done.
11.4-RELEASE-p1
[00:04:06] Recording filesystem state for clean... done
[00:04:07] Jail 11amd64 11.4-RELEASE-p1 amd64 is ready to be used
....

[source,shell]
....
# poudriere ports -c -p local -m svn+https
[00:00:00] Creating local fs at /poudriere/ports/local... done
[00:00:00] Checking out the ports tree... done
....

poudriere kann auf einem einzelnen Rechner Ports mit mehreren Konfigurationen bauen, in mehreren Jails und aus unterschiedlichen Ports-Sammlungen. Spezifische Konfigurationen für diese Kombinationen werden _Sets_ genannt. Lesen Sie den Abschnitt CUSTOMIZATION in man:poudriere[8] für weitere Einzelheiten nach der Installation von package:port-mgmt/poudriere[] oder package:ports-mgmt/poudriere-devel[].

Die hier gezeigte Konfiguration verwendet eine einzelne Jail-, Port- und Set-spezifische [.filename]#make.conf# in [.filename]#/usr/local/etc/poudriere.d#. Der verwendete Dateiname in diesem Beispiel wird aus einer Kombination von Jailnamen, Portnamen und Setnamen zusammen gesetzt: [.filename]#11amd64-local-workstation-make.conf#. Die [.filename]#make.conf# des Systems und diese neue Datei werden verwendet, um die [.filename]#make.conf# für die Jail zu erzeugen.

Die zu bauenden Pakete werden in [.filename]#11amd64-local-workstation-pkglist# eingetragen:

[.programlisting]
....
editors/emacs
devel/git
ports-mgmt/pkg
...
....

Die Optionen und Abhängigkeiten für die Ports werden wie folgt konfiguriert:

[source,shell]
....
# poudriere options -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist
....

Schließlich werden die Pakete gebaut und ein Paket-Repository erstellt:

[source,shell]
....
# poudriere bulk -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist
....

Während der Ausführung zeigt kbd:[Ctrl+t] den aktuellen Status des Baus an. Poudriere speichert zudem Dateien in [.filename]#/poudriere/logs/bulk/jailname#. Diese Dateien kann ein Webserver nutzen, um Informationen über den Bau anzuzeigen.

Nach der Fertigstellung stehen die Pakete im poudriere Repository für die Installation zur Verfügung.

Weitere Informationen zu poudriere finden Sie in man:poudriere[8] und unter https://github.com/freebsd/poudriere/wiki[].

=== Konfiguration des pkg-Clients für das Poudriere Repository

Obwohl es möglich ist ein eigenes Repository zusammen mit dem offiziellen Repository zu nutzen, ist es manchmal sinnvoll das offizielle Repository zu deaktivieren. Dazu wird eine Konfigurationsdatei erstellt, welche die offizielle Konfigurationsdatei überschreibt. Erzeugen Sie dazu [.filename]#/usr/local/etc/pkg/repos/FreeBSD.conf# mit dem folgenden Inhalt:

[.programlisting]
....
FreeBSD: {
        enabled: no
}
....

Am einfachsten ist es, das poudriere Repository über HTTP zur Verfügung zu stellen. Setzen Sie einen Webserver auf, der die Dateien des Paketverzeichnisses ausliefert, zum Beispiel [.filename]#/usr/local/poudriere/data/packages/11amd64#. [.filename]#11amd64# bezeichnet dabei den Namen des Baus.

Wenn die URL des Paket Repositories `http://pkg.example.com/11amd64` ist, dann sollte die Konfiguration des Repositories in [.filename]#/usr/local/etc/pkg/repos/custom.conf# wie folgt aussehen:

[.programlisting]
....
custom: {
	url: "http://pkg.example.com/11amd64",
	enabled: yes,
}
....

[[ports-nextsteps]]
== Nach der Installation

Unabhängig davon, ob die Software aus einem binären Paket oder aus einem Port installiert wird, benötigen die meisten Anwendungen von Drittanbietern ein gewisses Maß an Konfiguration, nachdem sie installiert wurden. Die folgenden Kommandos und Speicherorte helfen Ihnen dabei festzustellen, was mit der Anwendung zusammen installiert wurde.

* Die meisten Anwendungen installieren mindestens eine Konfigurationsdatei nach [.filename]#/usr/local/etc#. Falls die Anwendung viele Konfigurationsdateien enthält, wird ein Unterverzeichnis erstellt um die Dateien zu speichern. Oft werden die Konfigurationsdateien mit einem Suffix wie beispielsweise [.filename]#.sample# installiert. Die Konfigurationsdateien sollten überprüft und ggf. bearbeitet werden, um die Anforderungen des Systems zu erfüllen. Um eine Konfigurationsdatei zu bearbeiten, kopieren Sie diese zunächst ohne die Erweiterung [.filename]#.sample#.
* Wenn die Anwendung Dokumentation zur Verfügung stellt, wird diese nach [.filename]#/usr/local/shared/doc# installiert. Viele Anwendungen installieren auch Manualpages. Diese Dokumentation sollten Sie lesen, bevor Sie fortfahren.
* Einige Anwendungen laufen als Dienst und müssen vor dem ersten Start in [.filename]#/etc/rc.conf# eingetragen werden. Diese Anwendungen installieren meist ein Skript in [.filename]#/usr/local/etc/rc.d#. Weitere Informationen finden Sie im crossref:config[configtuning-starting-services,Start von Diensten].
+
[NOTE]
====
In der Voreinstellung führen Anwendungen weder ihr Startskript bei der Installation aus, noch führen sie ihr Stopskript während der Deinstallation aus. Diese Entscheidung bleibt dem einzelnen Systemadministrator überlassen.
====

* Benutzer der man:csh[1] sollten `rehash` ausführen, um die neu installierten Programme nutzen zu können.
* Benutzen Sie `pkg info`, um die Dateien, Manualpages und Binaries zu ermitteln, die mit der Anwendung installiert wurden.

[[ports-broken]]
== Kaputte Ports

Wenn sich ein Port nicht bauen oder installieren lässt, versuchen Sie folgendes:

. Stellen Sie fest, ob die link:https://www.FreeBSD.org/de/support/[Datenbank mit den Problemberichten] bereits einen Lösungsvorschlag enthält. Ist dies der Fall, kann die vorgeschlagene Lösung getestet werden.
. Bitten Sie den Betreuer des Ports um Hilfe. Geben Sie dazu `make maintainer` ein oder lesen Sie das [.filename]#Makefile# im Verzeichnis des Ports, um an die E-Mail-Adresse zu kommen. Vergessen Sie nicht die Zeile mit `$FreeBSD:` aus dem [.filename]#Makefile# und die Ausgabe bis zur Fehlermeldung mitzuschicken.
+
[NOTE]
====
Einige Ports werden nicht von einer Einzelperson, sondern von einer extref:{mailing-list-faq}[Mailingliste] betreut. Viele (aber nicht alle) dieser Adressen haben die Form mailto:freebsd-NameDerListe@FreeBSD.org[freebsd-NameDerListe@FreeBSD.org]. Denken Sie daran, wenn Sie Ihre Fragen formulieren.

Dies gilt insbesondere für Ports, die von mailto:ports@FreeBSD.org[ports@FreeBSD.org] betreut werden. Derartige Ports haben überhaupt keinen Betreuer. Korrekturen und Unterstützung kommen daher nur von Personen, die diese Mailingliste abonniert haben. Gerade in diesem Bereich werden jederzeit zusätzliche freiwillige Helfer benötigt!
====
+ 
Erhalten Sie auf Ihre Anfrage keine Antwort, benutzen Sie Bugzilla, um einen Problembericht zu erstellen. Bevor Sie einen solchen Bericht erstellen, lesen Sie den Artikel extref:{problem-reports}[Writing FreeBSD Problem Reports].
. Reparieren Sie ihn! Das extref:{porters-handbook}[FreeBSD Porter's Handbook] enthält eine detaillierte Beschreibung des Portsystems. Damit sind Sie in der Lage, einen zeitweilig kaputten Port zu reparieren oder einen eigenen Port zu erstellen.
. Installieren Sie das Paket anstelle des Ports. Anweisungen hierzu finden Sie in <<pkgng-intro>>.
