---
title: Kapitel 3. Grundlagen des FreeBSD Betriebssystems
part: Teil I. Erste Schritte
prev: books/handbook/bsdinstall
next: books/handbook/ports
---

[[basics]]
= Grundlagen des FreeBSD Betriebssystems
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:table-caption: Tabelle
:figure-caption: Abbildung
:example-caption: Beispiel
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 3

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/de/mailing-lists.adoc[]
include::shared/de/teams.adoc[]
include::shared/de/urls.adoc[]

toc::[]

[[basics-synopsis]]
== Übersicht

Dieses Kapitel umfasst die grundlegenden Kommandos und Funktionsweisen des FreeBSD-Betriebssystems. Viel von diesem Material gilt auch für jedes andere UNIX(R)-artige System. Neue Benutzer von FreeBSD sollten dieses Kapitel aufmerksam lesen.

Dieser Abschnitt behandelt die folgenden Themen:

* virtuelle Konsolen,
* Erstellung und Verwaltung von Benutzern und Gruppen in FreeBSD,
* Zugriffsrechte unter UNIX(R) sowie Datei-Flags unter FreeBSD,
* Zugriffskontrolllisten für Dateisysteme,
* die Verzeichnisstruktur von FreeBSD,
* Organisation von Dateisystemen unter FreeBSD,
* Ein- und Abhängen von Dateisystemen,
* Prozesse, Dämonen und Signale,
* Shells und die Login-Umgebung,
* Texteditoren,
* Geräte und Gerätedateien,
* wie Sie in den Manualpages nach weiteren Informationen suchen können.

[[consoles]]
== Virtuelle Konsolen und Terminals

Wenn das FreeBSD-System so konfiguriert wurde, dass es ohne eine grafische Benutzeroberfläche startet, wird das System nach dem Start einen Anmeldeprompt ausgeben, wie in diesem Beispiel zu sehen:

[source,bash]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

Die erste Zeile enthält einige Informationen über das System. `amd64` zeigt an, dass auf dem System in diesem Beispiel eine 64-Bit Version von FreeBSD läuft. Der Hostname ist `pc3.example.org` und [.filename]#ttyv0# gibt an, dass dies die "Systemkonsole" ist. Die zweite Zeile zeigt den Anmeldeprompt.

Da FreeBSD ein Mehrbenutzersystem ist, muss es die verschiedenen Benutzer voneinander unterscheiden können. Dies wird dadurch erreicht, dass sich jeder Benutzer zuerst am System anmelden muss, um Zugriff auf die Programme zu bekommen. Jeder Benutzer hat einen eindeutigen "Benutzernamen" und ein persönliches "Kennwort".

Um sich auf der Systemkonsole anzumelden, geben Sie den Benutzernamen ein, der während der Systeminstallation, wie in crossref:bsdinstall[bsdinstall-addusers,Benutzer hinzufügen] beschrieben, konfiguriert wurde und drücken Sie kbd:[Enter]. Geben Sie dann das zum Benutzernamen zugeordnete Passwort ein und drücken kbd:[Enter]. Das Passwort wird aus Sicherheitsgründen _nicht angezeigt_.

Sobald das richtige Passwort eingegeben wird, wird die Nachricht des Tages (MOTD) gefolgt von einer Eingabeaufforderung ausgegeben. In Abhängigkeit der verwendeten Shell des Benutzers wird der Prompt mit dem Zeichen `#`, `$` oder `%` dargestellt. Der Prompt zeigt an, dass der Benutzer jetzt an der FreeBSD Systemkonsole angemeldet ist und nun alle verfügbaren Befehle probieren kann.

[[consoles-virtual]]
=== Virtuelle Konsolen

Obwohl die Systemkonsole dazu verwendet werden kann, um mit dem System zu interagieren, wird sich ein Benutzer in der Regel an einer virtuellen Konsole im FreeBSD-System anmelden. Das liegt daran, dass die Systemmeldungen standardmäßig auf der Systemkonsole angezeigt werden und somit die Meldungen des Befehls oder einer Datei, die der Benutzer gerade bearbeitet, überschrieben werden.

In der Voreinstellung ist FreeBSD so konfiguriert, dass viele virtuelle Konsolen zur Eingabe von Befehlen zur Verfügung stehen. Jede virtuelle Konsole verfügt über einen eigenen Anmeldeprompt und eine Shell. Sie können ganz einfach zwischen den virtuellen Konsolen umschalten. Dies ist vergleichbar mit mehreren geöffneten Fenstern in einer graphischen Umgebung.

Die Tastenkombinationen kbd:[Alt+F1] bis kbd:[Alt+F8] sind in FreeBSD zum Umschalten zwischen virtuellen Konsolen reserviert. Verwenden Sie kbd:[Alt+F1] um auf die Systemkonsole ([.filename]#ttyv0#) zu wechseln, kbd:[Alt+F2] für die erste virtuelle Konsole ([.filename]#ttyv1#, kbd:[Alt+F3] für die zweite virtuelle Konsole ([.filename]#ttyv2#, und so weiter. Wenn Sie Xorg als graphische Oberfläche benutzen, können Sie mit kbd:[Strg]kbd:[Alt]kbd:[F1] zur virtuellen Konsole zurückkehren.

Beim Wechsel von einer Konsole zur nächsten wird die Bildschirmausgabe von FreeBSD verwaltet. Dies erzeugt die Illusion mehrerer Bildschirme und Tastaturen, an denen Kommandos abgesetzt werden können. Die Programme, die in einer virtuellen Konsole gestartet werden, laufen auch dann weiter, wenn der Benutzer auf eine andere virtuelle Konsole wechselt.

Lesen Sie man:kbdcontrol[1], man:vidcontrol[1], man:atkbd:[4], man:syscons[4] sowie man:vt[4] für eine recht technische Beschreibung der FreeBSD-Konsole und der Tastatur-Treiber.

In FreeBSD wird die Anzahl der verfügbaren virtuellen Konsolen in diesem Abschnitt von [.filename]#/etc/ttys# konfiguriert:

[.programlisting]
....
# name    getty                         type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Um eine virtuelle Konsole zu deaktivieren, setzen Sie ein Kommentarzeichen (`#` an den Anfang der Zeile für die entsprechende Konsole. Um bspw. die Anzahl der verfügbaren virtuellen Konsolen von acht auf vier zu reduzieren, setzen Sie ein `#` an den Anfang der letzten vier Zeilen, den virtuellen Konsolen [.filename]#ttyv5# bis [.filename]#ttyv8#. Kommentieren Sie nicht die Zeile für die Systemkonsole [.filename]#ttyv0# aus! Beachten Sie, dass die letzte virtuelle Konsole ([.filename]#ttyv8#) zum Wechsel auf die graphische Oberfläche gedacht ist, wenn Xorg wie im crossref:x11[x11,Das X-Window-System] installiert und konfiguriert ist.

man:ttys[5] enthält eine ausführliche Beschreibung der Spalten dieser Datei und der verfügbaren Optionen für virtuelle Konsolen.

[[consoles-singleuser]]
=== Single-User-Modus

Das FreeBSD Boot-Menü verfügt über eine Option "Boot Single User". Wird diese Option gewählt, bootet das System in einen speziellen Modus, der als "Single-User-Modus" bekannt ist. Dieser Modus wird normalerweise zur Reparatur des Systems verwendet, bspw. wenn das System nicht mehr startet, oder das `root`-Passwort zurückgesetzt werden muss. Im Single-User-Modus haben Sie keinen Zugriff auf das Netzwerk und es stehen Ihnen keine weiteren virtuellen Konsolen zur Verfügung. Allerdings haben Sie vollen Zugriff auf das System und in der Voreinstellung wird das `root`-Passwort nicht benötigt. Aus diesem Grund wird ein physischer Zugriff auf die Tastatur benötigt, um in diesem Modus zu booten. Zur Absicherung eines FreeBSD-Systems sollte ermittelt werden, welche Personen physischen Zugriff auf die Tastatur bekommen sollen.

Die Einstellungen für den Single-User-Modus befinden sich diesem Abschnitt von [.filename]#/etc/ttys#:

[.programlisting]
....
# name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

In der Voreinstellung ist der Status auf `secure` eingestellt. Das setzt voraus, dass der physische Zugriff auf die Tastatur entweder unwichtig ist, oder über eine Sicherheitsrichtlinie geregelt wird. Wenn der Status auf `insecure` eingestellt wird, wird davon ausgegangen, dass die Umgebung selbst unsicher ist, da jeder Zugriff auf die Tastatur hat. FreeBSD wird dann nach dem `root`-Passwort fragen, wenn ein Benutzer versucht in den Single-User-Modus zu booten.

[NOTE]
====
__Setzen Sie `insecure` nicht leichtfertig ein__! Wenn das `root`-Passwort vergessen wird, wird es schwierig in den Single-User-Modus zu gelangen, wenn man den Bootprozess von FreeBSD nicht genau versteht.
====

[[consoles-vidcontrol]]
=== Den Videomodus der Konsole anpassen

Der Standard-Videomodus der FreeBSD-Konsole kann auf jeden Modus eingestellt werden, der von der Grafikkarte und dem Monitor unterstützt wird (beispielsweise 1024x768 oder 1280x1024). Um eine andere Einstellung zu verwenden, muss das `VESA`-Modul geladen werden:

[source,bash]
....
# kldload vesa
....

Um festzustellen, welche Video-Modi von der Hardware unterstützt werden, nutzen Sie man:vidcontrol[1]. Um eine Liste aller unterstützten Modi zu sehen, verwenden Sie diesen Befehl:

[source,bash]
....
# vidcontrol -i mode
....

Die Ausgabe dieses Befehls listet alle Videomodi, die von der Hardware unterstützt werden. Um einen neuen Video-Modi zu wählen, wird der entsprechende Modus als `root`-Benutzer an man:vidcontrol[1] übergeben:

[source,bash]
....
# vidcontrol MODE_279
....

Um diese Einstellung dauerhaft zu speichern, muss folgende Zeile in [.filename]#/etc/rc.conf# hinzugefügt werden:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== Benutzer und grundlegende Account-Verwaltung

FreeBSD ermöglicht es mehreren Benutzern, den Computer zur selben Zeit zu benutzen. Es kann immer nur ein Benutzer vor der Konsole sitzen, aber es können sich beliebig viele Benutzer über das Netzwerk am System anmelden. Jeder Benutzer muss einen Account haben, um das System benutzen zu können.

Nachdem Sie dieses Kapitel gelesen haben, werden Sie

* die verschiedenen Account-Typen von FreeBSD kennen,
* wissen, wie Sie Accounts angelegen, verändern oder löschen,
* wissen, wie Sie Limits für einen Benutzer oder eine Gruppe setzen, um beispielsweise Ressourcen, wie Speicher oder CPU-Zeit einzuschränken,
* wissen, wie Sie Gruppen erstellen und Benutzer zu diesen Gruppen hinzufügen.

[[users-introduction]]
=== Account-Typen

Jeder Zugriff auf das FreeBSD-System geschieht über Accounts und alle Prozesse werden von Benutzern gestartet, also sind Benutzer- und Account-Verwaltung von wesentlicher Bedeutung.

Es gibt drei Haupttypen von Accounts: Systembenutzer, Benutzer-Accounts und der Superuser-Account.

[[users-system]]
==== Systembenutzer

Systembenutzer starten Dienste wie DNS, Mail-Server und Web-Server. Der Grund dafür ist die Sicherheit; wenn die Programme von dem Superuser gestartet werden, können Sie ohne Einschränkungen handeln.

Beispiele von Systembenutzern sind `daemon`, `operator`, `bind`, `news` und `www`.

[WARNING]
====

Bei der Verwendung der Gruppe `operator` ist Vorsicht geboten, da dem Benutzer unbeabsichtigt Privilegien gewährt werden könnten, beispielsweise zum Herunterfahren oder Neustarten des Systems, oder der Zugriff auf alle Geräte in [.filename]#/dev#.
====

`nobody` ist der generische unprivilegierte Systembenutzer. Bedenken Sie aber, dass je mehr Dienste `nobody` benutzen, desto mehr Dateien und Prozesse diesem Benutzer gehören und dieser Benutzer damit umso privilegierter wird.

[[users-user]]
==== Benutzer-Accounts

Benutzer-Accounts sind realen Personen zugeordnet und sind das primäre Mittel des Zugriffs das System. Jede Person, die Zugriff auf das System bekommt, sollte einen eindeutigen Benutzer-Account besitzen. Dies erlaubt es dem Administrator herauszufinden, wer was macht. Gleichzeitig werden die Benutzer daran gehindert, die Einstellungen anderer Benutzer zu zerstören.

Jeder Benutzer kann die eigene Umgebung anpassen, bspw. seine voreingestellte Shell, Editor, Tastenbelegungen und Spracheinstellungen.

Mit jedem Account eines FreeBSD-Systems sind bestimmte Informationen verknüpft:

Loginnamen::
Der Loginname wird am `login:` Prompt eingegeben. Jeder Benutzer muss einen eindeutigen Benutzernamen haben. Es gibt eine Reihe von Regeln für die Erstellung von gültigen Loginnamen, die in man:passwd[5] dokumentiert sind. Es wird aus Kompatibilitätsgründen empfohlen, Benutzernamen zu verwenden, die aus Kleinbuchstaben bestehen und bis zu acht Zeichen lang sind.

Passwort::
Jeder Account ist mit einem Passwort verknüpft.

User ID (UID)::
Die User ID (UID) ist eine Zahl, die verwendet wird, um die Benutzer auf dem FreeBSD-System eindeutig zu identifizieren. Programme, die einen Loginnamen akzeptieren, wandeln diesen zuerst in eine UID um. Es wird empfohlen, nur UIDs kleiner 65535 zu verwenden, da höhere Werte Kompatibilitätsprobleme mit einigen Anwendungen verursachen können.

Group ID (GID)::
Die Group ID (GID) ist eine Zahl, die verwendet wird, um die primäre Gruppe eines Benutzers eindeutig zu identifizieren. Gruppen sind ein Mechanismus zur Steuerung des Zugriffs auf Ressourcen über die GID eines Benutzers anstelle der UID. Dies kann die Größe einiger Konfigurationsdateien signifikant reduzieren und ermöglicht es Benutzern, Mitglied mehreren Gruppen zu sein. Es wird empfohlen, GIDs kleiner 65535 zu verwenden, da höhere Werte bei einigen Anwendungen große Probleme verursachen können.

Login-Klasse::
Login-Klassen erweitern das Gruppenkonzept. Sie erhöhen die Flexibilität des Systems in der Handhabung der verschiedenen Accounts. Login-Klassen werden auch im crossref:security[users-limiting,Login-Klassen konfigurieren] diskutiert.

Gültigkeit von Passwörtern::
In der Voreinstellung verfallen Passwörter nicht. Allerdings können Passwortwechsel nach einer gewissen Zeit auf Basis einzelner Accounts erzwungen werden.

Verfallszeit eines Accounts::
In der Voreinstellung verfallen unter FreeBSD keine Accounts. Wenn Sie Accounts einrichten, die nur für eine bestimmte Zeit gültig sein sollen, beispielsweise Accounts für Teilnehmer eines Praktikums, können Sie mit man:pw[8] die Gültigkeitsdauer des Accounts angeben. Nachdem die angegebene Zeitspanne verstrichen ist, kann dieser Account nicht mehr zum Anmelden verwendet werden, obwohl alle Verzeichnisse und Dateien, die diesem Account gehören, noch vorhanden sind.

vollständiger Benutzername::
FreeBSD identifiziert einen Account eindeutig über den Loginnamen, der aber keine Ähnlichkeit mit dem richtigen Namen des Benutzers haben muss. Ähnlich wie bei einem Kommentar, kann diese Information Leerzeichen, Großbuchstaben und mehr als 8 Zeichen enthalten.

Heimatverzeichnis::
Das Heimatverzeichnis gibt den vollständigen Pfad zu dem Verzeichnis an, in dem sich der Benutzer nach erfolgreicher Anmeldung befindet. Es ist üblich, alle Heimatverzeichnisse unter [.filename]#/home/Loginname# oder [.filename]#/usr/home/Loginname# anzulegen. Im Heimatverzeichnis oder in dort angelegten Verzeichnissen werden die Dateien eines Benutzers gespeichert.

Login-Shell::
Grundsätzlich ist die Shell, von denen es viele unterschiedliche gibt, eine Schnittstelle zum System. Die bevorzugte Shell eines Benutzers kann seinem Account zugeordnet werden.

[[users-superuser]]
==== Der Superuser-Account

Der Superuser-Account, normalerweise `root` genannt, ist vorkonfiguriert und erleichtert die Systemverwaltung, sollte aber nicht für alltägliche Aufgaben wie das Verschicken und Empfangen von Mails, Erforschen des Systems oder Programmierung benutzt werden.

Der Superuser kann, im Gegensatz zu normalen Benutzer-Accounts, ohne Beschränkungen operieren und die falsche Anwendung des Superuser-Accounts kann in spektakulären Katastrophen resultieren. Benutzer-Accounts sind nicht in der Lage, das System versehentlich zu zerstören, deswegen wird empfohlen, normale Benutzer-Accounts zu verwenden, solange nicht zusätzliche Privilegien benötigt werden.

Kommandos, die Sie als Superuser eingeben, sollten Sie immer doppelt und dreifach überprüfen, da ein zusätzliches Leerzeichen oder ein fehlender Buchstabe irreparablen Datenverlust bedeuten kann.

Es gibt mehrere Möglichkeiten Superuser-Rechte zu bekommen. Obwohl man sich direkt als `root` anmelden kann, wird von dieser Methode dringend abgeraten.

Verwenden Sie stattdessen man:su[1] um zum Superuser zu werden. Wenn Sie noch ein `-` eingeben, wird der Benutzer auch die Umgebung des Root-Benutzers erben. Der Benutzer, der diesen Befehl ausführt muss Mitglied der Gruppe `wheel` sein, oder der Befehl schlägt fehl. Zudem muss der Benutzer das Kennwort für den Benutzer-Account `root` kennen.

In diesem Beispiel wird der Benutzer nur zum Superuser, um `make install` auszuführen, da dieser Befehl Superuser-Rechte erfordert. Nachdem der Befehl ausgeführt wurde, kann der Benutzer `exit` eingeben, um den Superuser-Account zu verlassen und zu den Privilegien des Benutzer-Accounts zurückkehren.

.Ein Programm als Superuser installieren
[example]
====

[source,bash]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....

====

Das in FreeBSD enthaltene man:su[1] funktioniert gut für einzelne Systeme oder in kleineren Netzwerken, mit nur einem Administrator. Eine Alternative ist es, das Paket oder den Port package:security/sudo[] zu installieren. Diese Software bietet eine Protokollierung von Aktivitäten und ermöglicht es dem Administrator zu bestimmen, welche Benutzer welche Befehle als Superuser ausführen dürfen.

[[users-modifying]]
=== Accounts verändern

FreeBSD stellt eine Vielzahl an Programmen bereit, um Accounts zu verändern. Die gebräuchlichsten Kommandos sind in <<users-modifying-utilities>> gefolgt von einer detaillierten Beschreibung, zusammengefasst. Weitere Informationen und Anwendungsbeispiele finden Sie in der Manualpage des jeweiligen Programms.

[[users-modifying-utilities]]
.Programme zur Verwaltung von Benutzer-Accounts
[cols="10%,90%", frame="none", options="header"]
|===
| Programm
| Zusammenfassung

|man:adduser[8]
|Das empfohlene Werkzeug, um neue Accounts zu erstellen.

|man:rmuser[8]
|Das empfohlene Werkzeug, um Accounts zu löschen.

|man:chpass[1]
|Ein flexibles Werkzeug, um Informationen in der Account-Datenbank zu verändern.

|man:passwd[1]
|Ein Werkzeug, um Passwörter von Accounts zu ändern.

|man:pw[8]
|Ein mächtiges und flexibles Werkzeug um alle Informationen über Accounts zu ändern.
|===

[[users-adduser]]
==== `adduser`

Das empfohlene Programm zum Hinzufügen neuer Benutzer ist man:adduser[8]. Wenn ein neuer Benutzer hinzugefügt wird, aktualisiert das Programm automatisch [.filename]#/etc/passwd# und [.filename]#/etc/group#. Es erstellt auch das Heimatverzeichnis für den Benutzer, kopiert die Standardkonfigurationsdateien aus [.filename]#/usr/shared/skel# und kann optional eine ,,Willkommen``-Nachricht an den neuen Benutzer versenden. Das Programm muss als Superuser ausgeführt werden.

Das Werkzeug man:adduser[8] arbeitet interaktiv und führt durch die einzelnen Schritte, wenn ein neues Benutzerkonto erstellt wird. Wie in <<users-modifying-adduser>> zu sehen ist, müssen Sie entweder die benötigte Information eingeben oder kbd:[Return] drücken, um den Vorgabewert in eckigen Klammern zu akzeptieren. In diesem Beispiel wird der Benutzer in die Gruppe `wheel` aufgenommen, was es ihm erlaubt mit man:su[1] zum Superuser zu werden. Wenn Sie fertig sind, können Sie entweder einen weiteren Benutzer erstellen oder das Programm beenden.

[[users-modifying-adduser]]
.Einen Benutzer unter FreeBSD anlegen
[example]
====

[source,bash]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
#
....

====

[NOTE]
====
Wenn Sie das Passwort eingeben, werden weder Passwort noch Sternchen angezeigt. Passen Sie auf, dass Sie das Passwort korrekt eingeben.
====

[[users-rmuser]]
==== `rmuser`

Benutzen Sie man:rmuser[8] als Superuser, um einen Account vollständig aus dem System zu entfernen. Dieses Programm führt die folgenden Schritte durch:

[.procedure]
. Entfernt den man:crontab[1] Eintrag des Benutzers, wenn dieser existiert.
. Entfernt alle man:at[1] jobs, die dem Benutzer gehören.
. Schließt alle Prozesse des Benutzers.
. Entfernt den Benutzer aus der lokalen Passwort-Datei des Systems.
. Entfernt optional das Heimatverzeichnis des Benutzers, falls es dem Benutzer gehört.
. Entfernt eingegangene E-Mails des Benutzers aus [.filename]#/var/mail#.
. Entfernt alle Dateien des Benutzers aus temporären Dateispeicherbereichen wie [.filename]#/tmp#.
. Entfernt den Loginnamen von allen Gruppen, zu denen er gehört, aus [.filename]#/etc/group#. Wenn eine Gruppe leer wird und der Gruppenname mit dem Loginnamen identisch ist, wird die Gruppe entfernt. Das ergänzt sich mit den einzelnen Benutzer-Gruppen, die von man:adduser[8] für jeden neuen Benutzer erstellt werden.

Der Superuser-Account kann nicht mit man:rmuser[8] entfernt werden, da dies in den meisten Fällen das System unbrauchbar macht.

Als Vorgabe wird ein interaktiver Modus benutzt.

.Interaktives Löschen von Accounts mit `rmuser`
[example]
====

[source,bash]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#
....

====

[[users-chpass]]
==== `chpass`

Jeder Benutzer kann man:chpass[1] verwenden, um die Shell und persönliche Informationen des Benutzerkontos zu verändern. Der Superuser kann dieses Werkzeug benutzen, um zusätzliche Kontoinformationen für alle Benutzer zu ändern.

Werden neben dem optionalen Loginnamen keine weiteren Optionen angegeben, zeigt man:chpass[1] einen Editor mit Account-Informationen an. Wenn der Benutzer den Editor verlässt, wird die Account-Datenbank mit den neuen Informationen aktualisiert.

[NOTE]
====
Dieses Programm fragt nach dem Verlassen des Editors nach dem Passwort, es sei denn, man ist als Superuser angemeldet.
====

In <<users-modifying-chpass-su>> hat der Superuser `chpass jru` eingegeben. Es werden die Felder ausgegeben, die für diesen Benutzer geändert werden können. Wenn stattdessen `jru` diesen Befehl aufruft, werden nur die letzten sechs Felder ausgegeben. Dies ist in <<users-modifying-chpass-ru>> zu sehen.

[[users-modifying-chpass-su]]
.`chpass` als Superuser verwenden
[example]
====

[source,bash]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[[users-modifying-chpass-ru]]
.`chpass` als normaler Benutzer verwenden
[example]
====

[source,bash]
....
#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[NOTE]
====
Die Kommandos man:chfn[1] und man:chsh[1] sind nur Verweise auf man:chpass[1], genauso wie man:ypchpass[1], man:ypchfn[1] und man:ypchsh[1]. Da NIS automatisch unterstützt wird, ist es nicht notwendig das `yp` vor dem Kommando einzugeben. NIS wird später im crossref:network-servers[network-servers,Netzwerkserver] besprochen.
====

[[users-passwd]]
==== passwd

Jeder Benutzer kann mit man:passwd[1] einfach sein Passwort ändern. Um eine versehentliche oder unbefugte Änderung zu verhindern, muss bei einem Passwortwechsel zunächst das ursprüngliche Passwort eingegeben werden, bevor das neue Passwort festgelegt werden kann.

.Das eigene Passwort wechseln
[example]
====

[source,bash]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

Der Superuser kann jedes beliebige Passwort ändern, indem er den Benutzernamen an man:passwd[1] übergibt. Das Programm fordert den Superuser nicht dazu auf, das aktuelle Passwort des Benutzers einzugeben. Dadurch kann das Passwort geändert werden, falls der Benutzer sein ursprüngliches Passwort vergessen hat.

.Als Superuser das Passwort eines anderen Accounts verändern
[example]
====

[source,bash]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

[NOTE]
====
Wie bei man:chpass[1] ist man:yppasswd[1] nur ein Verweis auf man:passwd[1]. NIS wird von jedem dieser Kommandos unterstützt.
====

[[users-pw]]
==== `pw`

Mit dem Werkzeug man:pw[8] können Accounts und Gruppen erstellt, entfernt, verändert und angezeigt werden. Dieses Kommando dient als Schnittstelle zu den Benutzer- und Gruppendateien des Systems. man:pw[8] besitzt eine Reihe mächtiger Kommandozeilenschalter, die es für die Benutzung in Shell-Skripten geeignet machen, doch finden neue Benutzer die Bedienung des Kommandos komplizierter, als die der anderen hier vorgestellten Kommandos.

[[users-groups]]
=== Gruppen

Eine Gruppe ist einfach eine Zusammenfassung von Accounts. Gruppen werden durch den Gruppennamen und die GID identifiziert. Der Kernel von FreeBSD entscheidet anhand der UID und der Gruppenmitgliedschaft eines Prozesses, ob er dem Prozess etwas erlaubt oder nicht. Wenn jemand von der GID eines Benutzers oder Prozesses spricht, meint er damit meistens die erste Gruppe der Gruppenliste.

Die Zuordnung von Gruppennamen zur GID steht in [.filename]#/etc/group#, einer Textdatei mit vier durch Doppelpunkte getrennten Feldern. Im ersten Feld steht der Gruppenname, das zweite enthält ein verschlüsseltes Passwort, das dritte gibt die GID an und das vierte besteht aus einer Komma separierten Liste der Mitglieder der Gruppe. Eine ausführliche Beschreibung der Syntax dieser Datei finden Sie in man:group[5].

Wenn Sie [.filename]#/etc/group# nicht von Hand editieren möchten, können Sie man:pw[8] zum Editieren benutzen. Das folgende Beispiel zeigt das Hinzufügen einer Gruppe mit dem Namen `teamtwo`:

.Setzen der Mitgliederliste einer Gruppe mit man:pw[8]
[example]
====

[source,bash]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....

====

`1100` ist die GID der Gruppe `teamtwo`. Momentan hat `teamtwo` noch keine Mitglieder. Mit dem folgenden Kommando wird der Benutzer `jru` in die Gruppe `teamtwo` aufgenommen.

.Ein Gruppenmitglied mit man:pw[8] hinzufügen
[example]
====

[source,bash]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....

====

Als Argument von `-M` geben Sie eine Komma separierte Liste von Mitgliedern an, die in die Gruppe aufgenommen werden sollen. Aus den vorherigen Abschnitten ist bekannt, dass die Passwort-Datei ebenfalls eine Gruppe für jeden Benutzer enthält. Das System teilt dem Benutzer automatisch eine Gruppe zu, die aber vom `groupshow` Kommando von man:pw[8] nicht angezeigt wird. Diese Information wird allerdings von man:id[1] und ähnlichen Werkzeugen angezeigt. Das heißt, dass man:pw[8] nur [.filename]#/etc/group# manipuliert, es wird nicht versuchen, zusätzliche Informationen aus [.filename]#/etc/passwd# zu lesen.

.Hinzufügen eines neuen Gruppenmitglieds mittels man:pw[8]
[example]
====

[source,bash]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....

====

Die Argumente zur Option `-m` ist eine durch Komma getrennte Liste von Benutzern, die der Gruppe hinzugefügt werden sollen. Anders als im vorherigen Beispiel werden diese Benutzer in die Gruppe aufgenommen und ersetzen nicht die bestehenden Benutzer in der Gruppe.

.Mit `id` die Gruppenzugehörigkeit bestimmen
[example]
====

[source,bash]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....

====

In diesem Beispiel ist `jru` Mitglied von `jru` und `teamtwo`.

Weitere Informationen zu diesem Befehl und dem Format von [.filename]#/etc/group# finden Sie in man:pw[8] und man:group[5].

[[permissions]]
== Zugriffsrechte

In FreeBSD besitzt jede Datei und jedes Verzeichnis einen Satz von Zugriffsrechten. Es stehen mehrere Programme zum Anzeigen und Bearbeiten dieser Rechte zur Verfügung. Ein Verständnis für die Funktionsweise von Zugriffsrechten ist notwendig, um sicherzustellen, dass Benutzer nur auf die von ihnen benötigten Dateien zugreifen können und nicht auf die Dateien des Betriebssystems oder von anderen Benutzern.

In diesem Abschnitt werden die traditionellen Zugriffsrechte von UNIX(R) beschrieben. Informationen zu feingranularen Zugriffsrechten für Dateisysteme finden Sie im crossref:security[fs-acl,Zugriffskontrolllisten für Dateisysteme (ACL)].

In UNIX(R) werden die grundlegenden Zugriffsrechte in drei Typen unterteilt: Lesen, Schreiben und Ausführen. Diese Zugriffstypen werden verwendet, um den Dateizugriff für den Besitzer der Datei, die Gruppe und alle anderen zu bestimmen. Die Lese-, Schreib- und Ausführungsberechtigungen werden mit den Buchstaben `r`, `w` und `x` dargestellt. Alternativ können die Berechtigungen als binäre Zahlen dargestellt werden, da jede Berechtigung entweder aktiviert oder deaktiviert (`0`) ist. Wenn die Berechtigung als Zahl dargestellt wird, ist die Reihenfolge immer als `rwx` zu lesen, wobei `r` den Wert `4` hat, `w` den Wert `2` und `x` den Wert `1`.

In Tabelle 4.1 sind die einzelnen nummerischen und alphabetischen Möglichkeiten zusammengefasst. Das Zeichen `-` in der Spalte "Auflistung im Verzeichnis" besagt, dass eine Berechtigung deaktiviert ist.

.UNIX(R) Zugriffsrechte
[cols="10%,50%,40%", frame="none", options="header"]
|===
| Wert
| Zugriffsrechte
| Auflistung im Verzeichnis

|0
|Kein Lesen, Kein Schreiben, Kein Ausführen
|`---`

|1
|Kein Lesen, Kein Schreiben, Ausführen
|`--x`

|2
|Kein Lesen, Schreiben, Kein Ausführen
|`-w-`

|3
|Kein Lesen, Schreiben, Ausführen
|`-wx`

|4
|Lesen, Kein Schreiben, Kein Ausführen
|`r--`

|5
|Lesen, Kein Schreiben, Ausführen
|`r-x`

|6
|Lesen, Schreiben, Kein Ausführen
|`rw-`

|7
|Lesen, Schreiben, Ausführen
|`rwx`
|===

Benutzen Sie das Argument `-l` mit man:ls[1], um eine ausführliche Verzeichnisauflistung zu sehen, die in einer Spalte die Zugriffsrechte für den Besitzer, die Gruppe und alle anderen enthält. Die Ausgabe von `ls -l` könnte wie folgt aussehen:

[source,bash]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
....

Das erste Zeichen (ganz links) der ersten Spalte zeigt an, ob es sich um eine normale Datei, ein Verzeichnis, ein zeichenorientiertes Gerät, ein Socket oder irgendeine andere Pseudo-Datei handelt. In diesem Beispiel zeigt `-` eine normale Datei an. Die nächsten drei Zeichen, dargestellt als `rw-`, ergeben die Rechte für den Datei-Besitzer. Die drei Zeichen danach `r--` die Rechte der Gruppe, zu der die Datei gehört. Die letzten drei Zeichen, `r--`, geben die Rechte für den Rest der Welt an. Ein Minus bedeutet, dass das Recht nicht gegeben ist. In diesem Beispiel sind die Zugriffsrechte also: der Eigentümer kann die Datei lesen und schreiben, die Gruppe kann lesen und alle anderen können auch nur lesen. Entsprechend obiger Tabelle wären die Zugriffsrechte für diese Datei `644`, worin jede Ziffer die drei Teile der Zugriffsrechte dieser Datei verkörpert.

Wie kontrolliert das System die Rechte von Hardware-Geräten? FreeBSD behandelt die meisten Hardware-Geräte als Dateien, welche Programme öffnen, lesen und mit Daten beschreiben können. Diese speziellen Gerätedateien sind in [.filename]#/dev# gespeichert.

Verzeichnisse werden ebenfalls wie Dateien behandelt. Sie haben Lese-, Schreib- und Ausführ-Rechte. Das Ausführungs-Bit hat eine etwas andere Bedeutung für ein Verzeichnis als für eine Datei. Die Ausführbarkeit eines Verzeichnisses bedeutet, dass in das Verzeichnis, zum Beispiel mit man:cd[1], gewechselt werden kann. Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die Zugriffsrechte der Dateien lassen dies zu.

Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt des Verzeichnisses anzeigen zu lassen. Um eine Datei mit bekanntem Namen in einem Verzeichnis zu löschen, müssen auf dem Verzeichnis Schreib- _und_ Ausführ-Rechte gesetzt sein.

Es gibt noch mehr Rechte, aber die werden vor allem in speziellen Umständen benutzt, wie zum Beispiel bei SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit. Mehr über Zugriffsrechte von Dateien und wie sie gesetzt werden, finden Sie in man:chmod[1].

=== Symbolische Zugriffsrechte

Symbolische Zugriffsrechte verwenden Zeichen anstelle von oktalen Werten, um die Berechtigungen für Dateien oder Verzeichnisse festzulegen. Zugriffsrechte verwenden die Syntax _Wer_, _Aktion_ und _Berechtigung_. Die folgenden Werte stehen zur Auswahl:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Option
| Symbol
| Bedeutung

|_Wer_
|u
|Benutzer (user)

|_Wer_
|g
|Gruppe (group)

|_Wer_
|o
|Andere (other)

|_Wer_
|a
|Alle

|_Aktion_
|+
|Berechtigungen hinzufügen

|_Aktion_
|-
|Berechtigungen entziehen

|_Aktion_
|=
|Berechtigungen explizit setzen

|_Berechtigung_
|r
|lesen (read)

|_Berechtigung_
|w
|schreiben (write)

|_Berechtigung_
|x
|ausführen (execute)

|_Berechtigung_
|t
|Sticky-Bit

|_Berechtigung_
|s
|Set-UID oder Set-GID
|===

Diese symbolischen Werte werden zusammen mit man:chmod[1] verwendet. Beispielsweise würde der folgende Befehl den Zugriff auf _FILE_ für alle anderen Benutzer verbieten:

[source,bash]
....
% chmod go= FILE
....

Wenn Sie mehr als eine Änderung der Rechte einer Datei vornehmen wollen, können Sie eine durch Kommata getrennte Liste der Rechte angeben. Das folgende Beispiel entzieht der Gruppe und der Welt die Schreibberechtigung auf _FILE_ und fügt für jeden Ausführungsrechte hinzu:

[source,bash]
....
% chmod go-w,a+x FILE
....

=== FreeBSD Datei-Flags

Zusätzlich zu den Zugriffsrechten unterstützt FreeBSD auch die Nutzung von "Datei-Flags". Diese erhöhen die Sicherheit des Systems, indem sie eine verbesserte Kontrolle von Dateien erlauben. Verzeichnisse werden allerdings nicht unterstützt. Mit dem Einsatz von Datei-Flags kann sogar `root` daran gehindert werden, Dateien zu löschen oder zu verändern.

Datei-Flags werden mit man:chflags[1] verändert. Um beispielsweise auf der Datei [.filename]#file1# das "unlöschbar"-Flag zu aktivieren, geben Sie folgenden Befehl ein:

[source,bash]
....
# chflags sunlink file1
....

Um dieses Flag zu deaktivieren, setzen Sie ein "no" vor `sunlink`:

[source,bash]
....
# chflags nosunlink file1
....

Um die Flags einer Datei anzuzeigen, verwenden Sie man:ls[1] zusammen mit `-lo`:

[source,bash]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Einige Datei-Flags können nur vom `root`-Benutzer gesetzt oder gelöscht werden. Andere wiederum können auch vom Eigentümer der Datei gesetzt werden. Weitere Informationen hierzu finden sich in man:chflags[1] und man:chflags[2].

=== Die Berechtigungen `setuid`, `setgid`, und `sticky`

Anders als die Berechtigungen, die bereits angesprochen wurden, existieren drei weitere Einstellungen, über die alle Administratoren Bescheid wissen sollten. Dies sind die Berechtigungen `setuid`, `setgid` und `sticky`.

Diese Einstellungen sind wichtig für manche UNIX(R)-Operationen, da sie Funktionalitäten zur Verfügung stellen, die normalerweise nicht an gewöhnliche Anwender vergeben wird. Um diese zu verstehen, muss der Unterschied zwischen der realen und der effektiven Benutzer-ID erwähnt werden.

Die reale Benutzer-ID ist die UID, welche den Prozess besitzt oder gestartet hat. Die effektive UID ist diejenige, als die der Prozess läuft. Beispielsweise wird man:passwd[1] mit der realen ID des Benutzers ausgeführt, der sein Passwort ändert. Um jedoch die Passwortdatenbank zu bearbeiten, wird es effektiv als `root`-Benutzer ausgeführt. Das ermöglicht es normalen Benutzern, ihr Passwort zu ändern, ohne einen `Permission Denied`-Fehler angezeigt zu bekommen.

Die setuid-Berechtigung kann durch das Voranstellen bei einer Berechtigungsgruppe mit der Nummer Vier (4) gesetzt werden, wie im folgenden Beispiel gezeigt wird:

[source,bash]
....
# chmod 4755 suidexample.sh
....

Die Berechtigungen auf [.filename]#suidexample.sh# sehen jetzt wie folgt aus:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Beachten Sie, dass ein `s` jetzt Teil der Berechtigungen des Dateibesitzers geworden ist, welches das Ausführen-Bit ersetzt. Dies ermöglicht es Werkzeugen mit erhöhten Berechtigungen zu laufen, wie beispielsweise `passwd`.

[NOTE]
====
Die `nosuid` man:mount[8]-Option bewirkt, dass solche Anwendungen stillschweigend scheitern, ohne den Anwender darüber zu informieren. Diese Option ist nicht völlig zuverlässig, da ein `nosuid`-Wrapper in der Lage wäre, dies zu umgehen.
====

Um dies in Echtzeit zu beobachten, öffnen Sie zwei Terminals. Starten Sie auf einem `passwd` als normaler Benutzer. Während es auf die Passworteingabe wartet, überprüfen Sie die Prozesstabelle und sehen Sie sich die Informationen für man:passwd[1] an:

Im Terminal A:

[source,bash]
....
Changing local password for trhodes
Old Password:
....

Im Terminal B:

[source,bash]
....
# ps aux | grep passwd
....

[source,bash]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Obwohl man:passwd[1] als normaler Benutzer ausgeführt wird, benutzt es die effektive UID von `root`.

Die `setgid`-Berechtigung führt die gleiche Aktion wie die `setuid`-Berechtigung durch, allerdings verändert sie die Gruppenberechtigungen. Wenn eine Anwendung oder ein Werkzeug mit dieser Berechtigung ausgeführt wird, erhält es die Berechtigungen basierend auf der Gruppe, welche die Datei besitzt und nicht die des Benutzers, der den Prozess gestartet hat.

Um die `setgid`-Berechtigung auf einer Datei zu setzen, geben Sie man:chmod[1] eine führende Zwei (2) mit:

[source,bash]
....
# chmod 2755 sgidexample.sh
....

Beachten Sie in der folgenden Auflistung, dass das `s` sich jetzt in dem Feld befindet, das für die Berechtigungen der Gruppe bestimmt ist:

[source,bash]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
Obwohl es sich bei dem in diesen Beispielen gezeigten Shellskript um eine ausführbare Datei handelt, wird es nicht mit einer anderen EUID oder effektiven Benutzer-ID ausgeführt. Das ist so, weil Shellskripte keinen Zugriff auf man:setuid[2]-Systemaufrufe erhalten.
====

Die `setuid` und `setgid` Berechtigungs-Bits können die Systemsicherheit verringern, da sie erhöhte Rechte ermöglichen. Das dritte Berechtigungs-Bit, das `sticky bit` kann die Sicherheit eines Systems erhöhen.

Wenn das `sticky bit` auf einem Verzeichnis angewendet wird, erlaubt es das Löschen von Dateien nur durch den Besitzer der Datei. Dies ist nützlich, um die Löschung von Dateien in öffentlichen Verzeichnissen wie [.filename]#/tmp#, durch Benutzer denen diese Dateien nicht gehören, zu verhindern. Um diese Berechtigung anzuwenden, stellen Sie der Berechtigung eine Eins (1) voran:

[source,bash]
....
# chmod 1777 /tmp
....

Das `sticky bit` kann anhand des `t` ganz am Ende der Berechtigungen abgelesen werden.

[source,bash]
....
# ls -al / | grep tmp
....

[source,bash]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== Verzeichnis-Strukturen

Die FreeBSD-Verzeichnishierarchie ist die Grundlage, um ein umfassendes Verständnis des Systems zu erlangen. Das wichtigste Verzeichnis ist das Root-Verzeichnis "/". Dieses Verzeichnis ist das erste, das während des Bootens eingehangen wird. Es enthält das notwendige Basissystem, um das Betriebssystem in den Mehrbenutzerbetrieb zu bringen. Das Root-Verzeichnis enthält auch die Mountpunkte für Dateisysteme, die beim Wechsel in den Multiuser-Modus eingehängt werden.

Ein Mountpunkt ist ein Verzeichnis, in das zusätzliche Dateisysteme (in der Regel unterhalb des Wurzelverzeichnisses) eingehängt werden können. Dieser Vorgang wird in <<disk-organization>> ausführlich beschrieben. Standard-Mountpunkte sind [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt# sowie [.filename]#/cdrom#. Auf diese Verzeichnisse verweisen üblicherweise Einträge in [.filename]#/etc/fstab#. Diese Datei ist eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten, vom System gelesen werden. Die meisten der Dateisysteme in [.filename]#/etc/fstab# werden beim Booten automatisch durch das Skript man:rc[8] gemountet, wenn die zugehörigen Einträge nicht mit `noauto` versehen sind. Weitere Informationen zu diesem Thema finden Sie im <<disks-fstab>>.

Eine vollständige Beschreibung der Dateisystem-Hierarchie finden Sie in man:hier[7]. Die folgende Aufstellung gibt einen kurzen Überblick über die am häufigsten verwendeten Verzeichnisse:

[.informaltable]
[cols="20%,80%", frame="none", options="header"]
|===
| Verzeichnis
| Beschreibung

|[.filename]#/#
|Wurzelverzeichnis des Dateisystems.

|[.filename]#/bin/#
|Grundlegende Werkzeuge für den Single-User-Modus sowie den Mehrbenutzerbetrieb.

|[.filename]#/boot/#
|Programme und Konfigurationsdateien, die während des Bootens benutzt werden.

|[.filename]#/boot/defaults/#
|Vorgaben für die Boot-Konfiguration. Weitere Details finden Sie in man:loader.conf[5].

|[.filename]#/dev/#
|Gerätedateien. Weitere Details finden Sie in man:intro[4].

|[.filename]#/etc/#
|Konfigurationsdateien und Skripten des Systems.

|[.filename]#/etc/defaults/#
|Vorgaben für die System Konfigurationsdateien. Weitere Details finden Sie in man:rc[8].

|[.filename]#/etc/mail/#
|Konfigurationsdateien von MTAs wie man:sendmail[8].

|[.filename]#/etc/periodic/#
|Täglich, wöchentlich oder monatlich laufende Skripte, die von man:cron[8] gestartet werden. Weitere Details finden Sie in man:periodic[8].

|[.filename]#/etc/ppp/#
|Konfigurationsdateien von man:ppp[8].

|[.filename]#/mnt/#
|Ein leeres Verzeichnis, das von Systemadministratoren häufig als temporärer Mountpunkt genutzt wird.

|[.filename]#/proc/#
|Prozess Dateisystem. Weitere Details finden Sie in man:procfs[5] und man:mount_procfs[8].

|[.filename]#/rescue/#
|Statisch gelinkte Programme zur Wiederherstellung des Systems, wie in man:rescue[8] beschrieben.

|[.filename]#/root/#
|Home Verzeichnis von `root`.

|[.filename]#/sbin/#
|Systemprogramme und administrative Werkzeuge, die grundlegend für den Single-User-Modus und den Mehrbenutzerbetrieb sind.

|[.filename]#/tmp/#
|Temporäre Dateien, die für gewöhnlich bei einem Neustart des Systems verloren gehen. Häufig wird ein speicherbasiertes Dateisystem unter [.filename]#/tmp# eingehängt. Dieser Vorgang kann automatisiert werden, wenn tmpmfs-bezogene Variablen von man:rc.conf[5] verwendet werden, oder ein entsprechender Eintrag in [.filename]#/etc/fstab# existiert. Weitere Informationen finden Sie in man:mdmfs[8].

|[.filename]#/usr/#
|Der Großteil der Benutzerprogramme und Anwendungen.

|[.filename]#/usr/bin/#
|Gebräuchliche Werkzeuge, Programmierhilfen und Anwendungen.

|[.filename]#/usr/include/#
|Standard C include-Dateien.

|[.filename]#/usr/lib/#
|Bibliotheken.

|[.filename]#/usr/libdata/#
|Daten verschiedener Werkzeuge.

|[.filename]#/usr/libexec/#
|System-Dämonen und System-Werkzeuge, die von anderen Programmen ausgeführt werden.

|[.filename]#/usr/local/#
|Lokale Programme und Bibliotheken. Die Ports-Sammlung von FreeBSD benutzt dieses Verzeichnis als Zielverzeichnis für Anwendungen. Innerhalb von [.filename]#/usr/local# sollte das von man:hier[7] beschriebene Layout für [.filename]#/usr# benutzt werden. Das [.filename]#man# Verzeichnis wird direkt unter [.filename]#/usr/local# anstelle unter [.filename]#/usr/local/share# angelegt. Die Dokumentation der Ports findet sich in [.filename]#share/doc/port#.

|[.filename]#/usr/obj/#
|Von der Architektur abhängiger Verzeichnisbaum, der durch das Bauen von [.filename]#/usr/src# entsteht.

|[.filename]#/usr/ports/#
|Die FreeBSD-Ports-Sammlung (optional).

|[.filename]#/usr/sbin/#
|System-Dämonen und System-Werkzeuge, die von Benutzern ausgeführt werden.

|[.filename]#/usr/shared/#
|Von der Architektur unabhängige Dateien.

|[.filename]#/usr/src/#
|Quelldateien von BSD und/oder lokalen Ergänzungen.

|[.filename]#/var/#
|Wird für mehrere Zwecke genutzt und enthält Logdateien, temporäre Daten und Spooldateien. Manchmal wird ein speicherbasiertes Dateisystem unter [.filename]#/var# eingehängt. Dieser Vorgang kann automatisiert werden, wenn die varmfs-bezogenen Variablen von man:rc.conf[5] verwendet werden, oder ein entsprechender Eintrag in [.filename]#/etc/fstab# existiert. Weitere Informationen finden Sie in man:mdmfs[8].

|[.filename]#/var/log/#
|Verschiedene Logdateien des Systems.

|[.filename]#/var/mail/#
|Postfächer der Benutzer.

|[.filename]#/var/spool/#
|Verschiedene Spool-Verzeichnisse der Drucker- und Mailsysteme.

|[.filename]#/var/tmp/#
|Temporäre Dateien, die in der Regel auch bei einem Neustart des Systems erhalten bleiben, es sei denn, bei [.filename]#/var# handelt es sich um ein speicherbasiertes Dateisystem.

|[.filename]#/var/yp/#
|NIS maps.
|===

[[disk-organization]]
== Festplatten, Slices und Partitionen

FreeBSD identifiziert Dateien anhand eines Dateinamens. In Dateinamen wird zwischen Groß- und Kleinschreibung unterschieden: [.filename]#readme.txt# und [.filename]#README.TXT# bezeichnen daher zwei verschiedene Dateien. FreeBSD benutzt keine Dateiendungen, um den Typ der Datei zu bestimmen, egal ob es sich um ein Programm, ein Dokument oder um andere Daten handelt.

Dateien werden in Verzeichnissen gespeichert. In einem Verzeichnis können sich keine oder hunderte Dateien befinden. Ein Verzeichnis kann auch andere Verzeichnisse enthalten und so eine Hierarchie von Verzeichnissen aufbauen, die die Ablage von Daten erleichtert.

In Dateinamen werden Verzeichnisse durch einen Schrägstrich (`/`, Slash) getrennt. Wenn z.B. das Verzeichnis [.filename]#foo# ein Verzeichnis [.filename]#bar# enthält, in dem sich die Datei [.filename]#readme.txt# befindet, lautet der vollständige Name der Datei (oder der _Pfad_ zur Datei) [.filename]#foo/bar/readme.txt#. Beachten Sie, dass sich dies von Windows(R) unterscheidet, wo der `\` (Backslash für die Trennung von Datei- und Verzeichnisnamen verwendet wird. FreeBSD benutzt keine Laufwerkbuchstaben oder Laufwerknamen im Pfad. Beispielsweise würde man unter FreeBSD nicht [.filename]#c:\foo\bar\readme.txt# eingeben.

Verzeichnisse und Dateien werden in einem Dateisystem gespeichert. Jedes Dateisystem besitzt genau ein _Wurzelverzeichnis_, das so genannte Root-Directory. Dieses Wurzelverzeichnis kann weitere Verzeichnisse enthalten. Ein Dateisystem wird als Wurzeldateisystem festgelegt, und jedes weitere Dateisystem wird unter dem Wurzeldateisystem _eingehangen_. Daher scheint jedes Verzeichnis, unabhängig von der Anzahl der Platten, auf derselben Platte zu liegen.

Betrachten wir die drei Dateisysteme `A`, `B` und `C`. Jedes Dateisystem besitzt ein eigenes Wurzelverzeichnis, das zwei andere Verzeichnisse enthält: [.filename]#A1#, [.filename]#A2#, [.filename]#B1#, [.filename]#B2#, [.filename]#C1# und [.filename]#C2#.

Das Wurzeldateisystem soll `A` sein. man:ls[1] zeigt darin die beiden Verzeichnisse [.filename]#A1# und [.filename]#A2# an. Der Verzeichnisbaum sieht wie folgt aus:

image::../../../images/handbook/basics/example-dir1.png[]

Ein Dateisystem wird in einem Verzeichnis eines anderen Dateisystems eingehangen. Wir hängen nun das Dateisystem `B` in das Verzeichnis [.filename]#A1# ein. Das Wurzelverzeichnis von `B` ersetzt nun das Verzeichnis [.filename]#A1# und die Verzeichnisse des Dateisystems `B` werden sichtbar:

image::../../../images/handbook/basics/example-dir2.png[]

Jede Datei in den Verzeichnissen [.filename]#B1# oder [.filename]#B2# kann über den Pfad [.filename]#/A1/B1# oder [.filename]#/A1/B2# erreicht werden. Dateien aus dem Verzeichnis [.filename]#/A1# sind jetzt verborgen. Wenn das Dateisystem `B` wieder _abgehangen_ wird (umount), erscheinen die verborgenen Dateien wieder.

Wenn das Dateisystem `B` unter dem Verzeichnis [.filename]#A2# eingehangen würde, sähe der Verzeichnisbaum so aus:

image::../../../images/handbook/basics/example-dir3.png[]

Die Dateien des Dateisystems `B` wären unter den Pfaden [.filename]#/A2/B1# und [.filename]#/A2/B2# erreichbar.

Dateisysteme können übereinander eingehangen werden. Der folgende Baum entsteht, wenn im letzten Beispiel das Dateisystem `C` in das Verzeichnis [.filename]#B1# des Dateisystems `B` eingehangen wird:

image::../../../images/handbook/basics/example-dir4.png[]

`C` könnte auch im Verzeichnis [.filename]#A1# eingehangen werden:

image::../../../images/handbook/basics/example-dir5.png[]

Sie können sogar mit nur einem großen Dateisystem auskommen. Dies hat mehrere Nachteile und einen Vorteil.

.Vorteile mehrerer Dateisysteme
* Die Dateisysteme können mit unterschiedlichen Optionen (mount options) eingehangen werden. Beispielsweise kann das Wurzeldateisystem schreibgeschützt eingehangen werden, sodass es für Benutzer nicht möglich ist, versehentlich kritische Dateien zu editieren oder zu löschen. Von Benutzern beschreibbare Dateisysteme wie [.filename]#/home# können mit der Option _nosuid_ eingehangen werden, wenn sie von anderen Dateisystemen getrennt sind. Die _SUID_- und _GUID_-Bits verlieren auf solchen Dateisystemen ihre Wirkung und die Sicherheit des Systems kann dadurch erhöht werden.
* Die Lage von Dateien im Dateisystem wird, abhängig vom Gebrauch des Dateisystems, automatisch von FreeBSD optimiert. Ein Dateisystem mit vielen kleinen Dateien, die häufig geschrieben werden, wird anders behandelt als ein Dateisystem mit wenigen großen Dateien. Mit nur einem Dateisystem ist diese Optimierung unmöglich.
* In der Regel übersteht ein FreeBSD-Dateisystem auch einen Stromausfall. Allerdings kann ein Stromausfall zu einem kritischen Zeitpunkt das Dateisystem beschädigen. Wenn die Daten über mehrere Dateisysteme verteilt sind, lässt sich das System mit hoher Wahrscheinlichkeit noch starten. Dies erleichtert das Zurückspielen von Datensicherungen.

.Vorteil eines einzelnen Dateisystems
* Dateisysteme haben eine festgelegte Größe. Es kann passieren, dass Sie eine Partition vergrößern müssen. Dies ist nicht leicht: Sie müssen die Daten sichern, das Dateisystem vergrößert anlegen und die gesicherten Daten zurückspielen.
+
[IMPORTANT]
====
FreeBSD kennt den Befehl man:growfs[8], mit dem man Dateisysteme im laufenden Betrieb vergrößern kann.
====

Dateisysteme befinden sich in Partitionen (damit sind nicht die normalen MS-DOS(R)-Partitionen gemeint). Jede Partition wird mit einem Buchstaben von `a` bis `h` bezeichnet und kann nur ein Dateisystem enthalten. Dateisysteme können daher über ihren Mount-Point, den Punkt an dem sie eingehangen sind, oder den Buchstaben der Partition, in der sie liegen, identifiziert werden.

FreeBSD benutzt einen Teil der Platte für den _Swap-Bereich_, um _virtuellen Speicher_ zur Verfügung zu stellen. Dadurch kann der Rechner Anwendungen mehr Speicher zur Verfügung stellen als tatsächlich eingebaut ist. Wenn der Speicher knapp wird, kann FreeBSD nicht benutzte Daten in den Swap-Bereich auslagern. Die ausgelagerten Daten können später wieder in den Speicher geholt werden (dafür werden dann andere Daten ausgelagert).

Für einige Partitionen gelten besondere Konventionen:

[.informaltable]
[cols="30%,70%", frame="none", options="header"]
|===
| Partition
| Konvention

|`a`
|Enthält normalerweise das Wurzeldateisystem.

|`b`
|Enthält normalerweise den Swap-Bereich.

|`c`
|Ist normalerweise genauso groß wie die Slice in der die Partition liegt. Werkzeuge, die auf der kompletten Slice arbeiten, wie ein Bad-Block-Scanner, können so die `c`-Partition benutzen. Für gewöhnlich wird in dieser Partition kein Dateisystem angelegt.

|`d`
|Früher hatte die `d`-Partition eine besondere Bedeutung. Heute ist dies nicht mehr der Fall und die Partition `d` kann wie jede andere Partition auch verwendet werden.
|===

In FreeBSD werden Festplatten in Slices, welche in Windows(R) als Partitionen bekannt sind, aufgeteilt und von 1 bis 4 durchnummeriert. Diese werden dann in Partitionen unterteilt, welche wiederum Dateisysteme enthalten und mit Buchstaben benannt werden.

Die Slice-Nummern werden mit vorgestelltem `s` hinter den Gerätenamen gestellt: "da0__s1__" ist die erste Slice auf dem ersten SCSI-Laufwerk. Auf einer Festplatte gibt es höchstens vier Slices. In einer Slice des passenden Typs kann es weitere logische Slices geben. Diese erweiterten Slices werden ab fünf durchnummeriert: "ada0__s5__" ist die erste erweiterte Slice auf einer SATA-Platte. Diese Geräte werden von Dateisystemen benutzt, die sich in einer kompletten Slice befinden müssen.

Slices, "dangerously dedicated"-Festplatten und andere Platten enthalten Partitionen, die mit Buchstaben von `a` bis `h` bezeichnet werden. Der Buchstabe wird an den Gerätenamen gehangen: "da0__a__" ist die `a`-Partition des ersten `da`-Laufwerks. Dieses Laufwerk ist "dangerously dedicated". "ada1s3__e__" ist die fünfte Partition in der dritten Slice der zweiten SATA-Platte.

Schließlich wird noch jede Festplatte des Systems eindeutig bezeichnet. Der Name einer Festplatte beginnt mit einem Code, der den Typ der Platte bezeichnet. Es folgt eine Nummer, die angibt, um welche Festplatte es sich handelt. Anders als bei Slices werden Festplatten von Null beginnend durchnummeriert. Gängige Festplatten-Namen sind in <<disks-naming>> aufgeführt.

Wenn Sie eine Partition angeben, beinhaltet das den Plattennamen, `s`, die Slice-Nummer und den Buchstaben der Partition. Einige Beispiele finden Sie in <<basics-disk-slice-part>>.

Der Aufbau einer Festplatte wird in <<basics-concept-disk-model>> dargestellt.

Bei der Installation von FreeBSD legen Sie Slices auf der Festplatte an, erstellen Partitionen für FreeBSD innerhalb der Slice, erstellen ein Dateisystem oder Auslagerungsbereiche und entscheiden, welche Dateisysteme wo eingehangen werden.

[[disks-naming]]
.Laufwerk-Codes
[cols="1,1", frame="none", options="header"]
|===
| Laufwerkstyp
| Gerätename

|SATA- und IDE-Festplatten
|`ada` oder `ad`

|SCSI-Festplatten und USB-Speichermedien
|`da`

|SATA- und IDE-CD-ROM-Laufwerke
|`cd` oder `acd`

|SCSI-CD-ROM-Laufwerke
|`cd`

|Diskettenlaufwerke
|`fd`

|Verschiedene proprietäre CD-ROM-Laufwerke
|`mcd` für Mitsumi CD-ROM und `scd` für Sony CD-ROM

|SCSI-Bandlaufwerke
|`sa`

|IDE-Bandlaufwerke
|`ast`

|RAID-Laufwerke
|Beispiele sind `aacd` für Adaptec(R) AdvancedRAID, `mlxd` für Mylex(R), `amrd` für AMI MegaRAID(R), `idad` für Compaq Smart RAID, `twed` für 3ware(R) RAID.
|===

[[basics-disk-slice-part]]
.Namen von Platten, Slices und Partitionen
[example]
====

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Name
| Bedeutung

|[.filename]#ada0s1a#
|Die erste Partition (`a`) in der ersten Slice (`s1`) der ersten SATA-Festplatte (`ada0`).

|[.filename]#da1s2e#
|Die fünfte Partition (`e`) der zweiten Slice (`s2`) auf der zweiten SCSI-Festplatte (`da1`).
|===
====

[[basics-concept-disk-model]]
.Aufteilung einer Festplatte
[example]
====

Das folgende Diagramm zeigt die Sicht von FreeBSD auf die erste SATA-Festplatte des Systems. Die Platte soll 250 GB groß sein und eine 80 GB große Slice (MS-DOS(R)-Partitionen) sowie eine 170 GB große Slice enthalten. Die erste Slice enthält ein Windows(R) NTFS-Dateisystem ([.filename]#C:#), die zweite Slice enthält eine FreeBSD-Installation. Die FreeBSD-Installation in diesem Beispiel verwendet vier Datenpartitionen und einen Auslagerungsbereich.

Jede der vier Partitionen enthält ein Dateisystem. Das Wurzeldateisystem ist die `a`-Partition. In der `d`-Partition befindet sich [.filename]#/var# und in der `f`-Partition befindet sich [.filename]#/usr#. Die `c`-Partition bezieht sich auf die gesamte Slice und wird nicht für gewöhnliche Partitionen verwendet.

image::../../../images/handbook/basics/disk-layout.png[]

====

[[mount-unmount]]
== Anhängen und Abhängen von Dateisystemen

Ein Dateisystem wird am besten als ein Baum mit der Wurzel [.filename]#/# veranschaulicht. [.filename]#/dev#, [.filename]#/usr#, und die anderen Verzeichnisse im Rootverzeichnis sind Zweige, die wiederum eigene Zweige wie [.filename]#/usr/local# haben können.

Es gibt verschiedene Gründe, bestimmte dieser Verzeichnisse auf eigenen Dateisystemen anzulegen. [.filename]#/var# enthält [.filename]#log/#, [.filename]#spool/# sowie verschiedene andere temporäre Dateien und kann sich daher schnell füllen. Es empfiehlt sich, [.filename]#/var# von [.filename]#/# zu trennen, da es schlecht ist, wenn das Root-Dateisystem voll läuft.

Ein weiterer Grund bestimmte Verzeichnisbäume auf andere Dateisysteme zu legen, ist gegeben, wenn sich die Verzeichnisbäume auf gesonderten physikalischen oder virtuellen Platten, wie crossref:network-servers[network-nfs,Network File System] oder CD-ROM-Laufwerken, befinden.

[[disks-fstab]]
=== Die [.filename]#fstab# Datei

Während des Boot-Prozesses (crossref:boot[boot,FreeBSDs Bootvorgang]) werden in [.filename]#/etc/fstab# aufgeführte Verzeichnisse, sofern sie nicht mit der Option `noauto` versehen sind, automatisch angehangen. Diese Datei enthält Einträge in folgendem Format:

[.programlisting]
....
device	/mount-point	fstype	options	dumpfreq	passno
....

`device`::
Ein existierender Gerätename wie in <<disks-naming>> beschrieben.

`mount-point`::
Ein existierendes Verzeichnis, auf dem das Dateisystem gemountet wird.

`fstype`::
Der Typ des Dateisystems, der an man:mount[8] weitergegeben wird. FreeBSDs Standarddateisystem ist `ufs`.

`options`::
Entweder `rw` für beschreibbare Dateisysteme oder `ro` für schreibgeschützte Dateisysteme, gefolgt von weiteren benötigten Optionen. Eine häufig verwendete Option ist `noauto` für Dateisysteme, die während der normalen Bootsequenz nicht angehangen werden sollen. Weitere Optionen finden sich in man:mount[8].

`dumpfreq`::
Wird von man:dump[8] benutzt, um bestimmen zu können, welche Dateisysteme gesichert werden müssen. Fehlt der Wert, wird `0` angenommen.

`passno`::
Bestimmt die Reihenfolge, in der die Dateisysteme überprüft werden sollen. Für Dateisysteme, die übersprungen werden sollen, ist `passno` auf `0` zu setzen. Für das Root-Dateisystem, das vor allen anderen überprüft werden muss, sollte der Wert von `passno``1` betragen. Allen anderen Dateisystemen sollten Werte größer `1` zugewiesen werden. Wenn mehrere Dateisysteme den gleichen Wert besitzen, wird man:fsck[8] versuchen, diese parallel zu überprüfen.

Lesen Sie man:fstab[5] für weitere Informationen über das Format von [.filename]#/etc/fstab# und dessen Optionen.

[[disks-mount]]
=== Verwendung von man:mount[8]

Dateisysteme werden mit man:mount[8] eingehängt. In der grundlegenden Form wird es wie folgt benutzt:

[example]
====

[source,bash]
....
# mount device mountpoint
....

====

Dieser Befehl bietet viele Optionen, die in man:mount[8] beschrieben werden. Die am häufigsten verwendeten Optionen sind:

.Optionen von `mount`
`-a`::
Hängt alle Dateisysteme aus [.filename]#/etc/fstab# an. Davon ausgenommen sind Dateisysteme, die mit "noauto" markiert sind, die mit der Option `-t` ausgeschlossen wurden und Dateisysteme, die schon angehangen sind.

`-d`::
Führt alles bis auf den `mount`-Systemaufruf aus. Nützlich ist diese Option in Verbindung mit `-v`. Damit wird angezeigt, was man:mount[8] tatsächlich versuchen würde, um das Dateisystem anzuhängen.

`-f`::
Erzwingt das Anhängen eines unsauberen Dateisystems (riskant) oder die Rücknahme des Schreibzugriffs, wenn der Status des Dateisystems von beschreibbar auf schreibgeschützt geändert wird.

`-r`::
Hängt das Dateisystem schreibgeschützt ein. Dies kann auch durch Angabe von `-o ro` erreicht werden.

`-t`_fstype_::
Hängt das Dateisystem mit dem angegebenen Typ an, oder hängt nur Dateisysteme mit dem angegebenen Typ an, wenn `-a` angegeben wurde. "ufs" ist das Standarddateisystem.

`-u`::
Aktualisiert die Mountoptionen des Dateisystems.

`-v`::
Geschwätzig sein.

`-w`::
Hängt das Dateisystem beschreibbar an.

Die folgenden Optionen können durch eine Kommata separierte Liste an `-o` übergeben werden:

nosuid::
SetUID und SetGID Bits werden auf dem Dateisystem nicht beachtet. Dies ist eine nützliche Sicherheitsfunktion.

[[disks-umount]]
=== Verwendung von man:umount[8]

man:umount[8] hängt ein Dateisystem ab. Dieser Befehl akzeptiert als Parameter entweder einen Mountpoint, einen Gerätenamen, `-a` oder `-A`.

Jede Form akzeptiert `-f`, um das Abhängen zu erzwingen, und `-v`, um etwas geschwätziger zu sein. Seien Sie bitte vorsichtig mit `-f`, da der Computer abstürzen kann oder es können Daten auf dem Dateisystem beschädigt werden.

Um alle Dateisysteme abzuhängen, oder nur diejenigen, die mit `-t` gelistet werden, wird `-a` oder `-A` benutzt. Beachten Sie, dass `-a` das Root-Dateisystem nicht aushängt.

[[basics-processes]]
== Prozesse und Dämonen

FreeBSD ist ein Multitasking-Betriebssystem. Jedes Programm, das zu irgendeiner Zeit läuft wird als _Prozess_ bezeichnet. Jedes laufende Kommando startet mindestens einen neuen Prozess. Dazu gibt es eine Reihe von Systemprozessen, die von FreeBSD ausgeführt werden.

Jeder Prozess wird durch eine eindeutige Nummer identifiziert, die _Prozess-ID_ (_PID_) genannt wird. Prozesse haben ebenso wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche Dateien und Geräte der Prozess benutzen kann. Die meisten Prozesse haben auch einen Elternprozess, der sie gestartet hat. Beispielsweise ist die Shell ein Prozess. Jedes in Shell gestartete Kommando ist dann ein neuer Prozess, der die Shell als Elternprozess besitzt. Die Ausnahme hiervon ist ein spezieller Prozess namens man:init[8], der beim booten immer als erstes gestartet wird und der immer die PID`1` hat.

Manche Programme erwarten keine Eingaben vom Benutzer und lösen sich bei erster Gelegenheit von ihrem Terminal. Ein Webserver zum Beispiel antwortet auf Web-Anfragen und nicht auf Benutzereingaben. Mail-Server sind ein weiteres Beispiel für diesen Typ von Anwendungen. Diese Programme sind als _Dämonen_ bekannt. Der Begriff Dämon stammt aus der griechischen Mythologie und bezeichnet ein Wesen, das weder gut noch böse ist und welches unsichtbar nützliche Aufgaben verrichtet. Deshalb ist das BSD Maskottchen dieser fröhlich aussehende Dämon mit Turnschuhen und Dreizack.

Programme, die als Dämon laufen, werden entsprechend einer Konvention mit einem "d" am Ende benannt. BIND steht beispielsweise für Berkeley Internet Name Domain, das tatsächlich laufende Programm heißt aber `named`. Der Apache Webserver wird `httpd` genannt und der Druckerspool-Dämon heißt man:lpd[8]. Dies ist allerdings nur eine Konvention. Der Dämon der Anwendung Sendmail heißt beispielsweise `sendmail` und nicht `maild`.

=== Prozesse beobachten

Um die Prozesse auf dem System zu sehen, benutzen Sie man:ps[1] und man:top[1]. Eine statische Liste der laufenden Prozesse, deren PIDs, Speicherverbrauch und die Kommandozeile, mit der sie gestartet wurden, erhalten Sie mit man:ps[1]. Um alle laufenden Prozesse in einer Anzeige zu sehen, die alle paar Sekunden aktualisiert wird, so dass Sie interaktiv sehen können was der Computer macht, benutzen Sie man:top[1].

In der Voreinstellung zeigt man:ps[1] nur die laufenden Prozesse, die dem Benutzer gehören. Zum Beispiel:

[source,bash]
....
% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps
....

Die Ausgabe von man:ps[1] ist in einer Anzahl von Spalten organisiert. Die `PID` Spalte zeigt die Prozess-ID. PIDs werden von 1 beginnend bis 99999 zugewiesen und fangen wieder von vorne an. Ist eine PID bereits vergeben, wird diese allerdings nicht erneut vergeben. Die Spalte `TT` zeigt den Terminal, auf dem das Programm läuft. `STAT` zeigt den Status des Programms und `TIME` gibt die Zeit an, die das Programm auf der CPU gelaufen ist. Dies ist nicht unbedingt die Zeit, die seit dem Start des Programms vergangen ist, da die meisten Programme hauptsächlich auf bestimmte Dinge warten, bevor sie wirklich CPU-Zeit verbrauchen. Unter der Spalte `COMMAND` findet sich schließlich die Kommandozeile, mit der das Programm gestartet wurde.

man:ps[1] besitzt viele Optionen, um die angezeigten Informationen zu beeinflussen. Eine nützliche Kombination ist `auxww`. `a` zeigt Information über alle laufenden Prozesse aller Benutzer. Der Name des Besitzers des Prozesses, sowie Informationen über den Speicherverbrauch werden mit `u` angezeigt. `x` zeigt auch Dämonen-Prozesse an, und `ww` veranlasst man:ps[1] die komplette Kommandozeile für jeden Befehl anzuzeigen, anstatt sie abzuschneiden, wenn sie zu lang für die Bildschirmausgabe wird.

Die Ausgabe von man:top[1] sieht in etwa so aus:

[source,bash]
....
% top
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

Die Ausgabe ist in zwei Abschnitte geteilt. In den ersten fünf Kopfzeilen finden sich die zuletzt zugeteilte PID, die Systemauslastung (engl. load average), die Systemlaufzeit (die Zeit seit dem letzten Reboot) und die momentane Zeit. Die weiteren Zahlen im Kopf beschreiben wie viele Prozesse momentan laufen, wie viel Speicher und Swap verbraucht wurde und wie viel Zeit das System in den verschiedenen CPU-Modi verbringt. Wenn das ZFS-Kernelmodul geladen ist, dann zeigt die Zeile `ARC`, wie viele Daten aus dem Cache gelesen wurden.

Darunter befinden sich einige Spalten mit ähnlichen Informationen wie in der Ausgabe von man:ps[1], beispielsweise die PID, den Besitzer, die verbrauchte CPU-Zeit und das Kommando, das den Prozess gestartet hat. man:top[1] zeigt in zwei Spalten den Speicherverbrauch des Prozesses an. Die erste Spalte gibt den gesamten Speicherverbrauch des Prozesses an, in der zweiten Spalte wird der aktuelle Verbrauch angegeben.

Die Anzeige wird von man:top[1] automatisch alle zwei Sekunden aktualisiert. Ein anderer Intervall kann mit `-s` spezifiziert werden.

[[basics-daemons]]
=== Stoppen von Prozessen

Eine Möglichkeit mit einem laufenden Prozess zu kommunizieren, ist über das Versenden von _Signalen_ mittels man:kill[1]. Es gibt eine Reihe von verschiedenen Signalen. Manche haben eine feste Bedeutung, während andere in der Dokumentation der Anwendung beschrieben sind. Ein Benutzer kann ein Signal nur an einen Prozess senden, welcher ihm gehört. Wird versucht ein Signal an einen Prozess eines anderen Benutzers zu senden, resultiert dies in einem Zugriffsfehler mangels fehlender Berechtigungen. Die Ausnahme ist der `root`-Benutzer, welcher jedem Prozess Signale senden kann.

FreeBSD kann auch ein Signal an einen Prozess senden. Wenn eine Anwendung schlecht geschrieben ist und auf Speicher zugreift, auf den sie nicht zugreifen soll, so sendet FreeBSD dem Prozess das _Segmentation Violation_ Signal (`SIGSEGV`). Wenn eine Anwendung programmiert wurde, den man:alarm[3] Systemaufruf zu benutzen, um nach einiger Zeit benachrichtigt zu werden, bekommt sie das "Alarm"-Signal (`SIGALRM`) gesendet.

Zwei Signale können benutzt werden, um einen Prozess zu stoppen: `SIGTERM` und `SIGKILL`. `SIGTERM` fordert den Prozess höflich zum Beenden auf. Der Prozess kann das Signal abfangen und hat dann Gelegenheit Logdateien zu schließen und die Aktion, die er durchführte, abzuschließen. In manchen Situationen kann der Prozess `SIGTERM` ignorieren, wenn er eine Aktion durchführt, die nicht unterbrochen werden darf.

`SIGKILL` kann von keinem Prozess ignoriert werden. Wird einem Prozess `SIGKILL` geschickt, dann wird FreeBSD diesen sofort beenden.

Andere häufig verwendete Signale sind `SIGHUP`, `SIGUSR1` und `SIGUSR2`. Da diese Signale für allgemeine Zwecke vorgesehen sind, werden verschiedene Anwendungen unterschiedlich auf diese Signale reagieren.

Ändern Sie beispielsweise die Konfiguration eines Webservers, so muss dieser angewiesen werden, seine Konfiguration neu zu lesen. Ein Neustart von `httpd` würde dazu führen, dass der Server für kurze Zeit nicht erreichbar ist. Senden Sie dem Dämon stattdessen das `SIGHUP`-Signal. Es sei erwähnt, dass verschiedene Dämonen sich anders verhalten. Lesen Sie die Dokumentation des entsprechenden Dämonen um zu überprüfen, ob der Dämon bei einem `SIGHUP` die gewünschten Ergebnisse erzielt.

[.procedure]
****
.Procedure: Verschicken von Signalen

Das folgende Beispiel zeigt, wie Sie man:inetd[8] ein Signal schicken. Die Konfigurationsdatei von man:inetd[8] ist [.filename]#/etc/inetd.conf#. Diese Konfigurationsdatei liest man:inetd[8] ein, wenn er `SIGHUP` empfängt.

. Suchen Sie mit man:pgrep[1] die PID des Prozesses, dem Sie ein Signal schicken wollen. In diesem Beispiel ist die PID von man:inetd[8] 198:
+
[source,bash]
....
% pgrep -l inetd
198 inetd -wW
....

. Benutzen Sie man:kill[1], um ein Signal zu senden. Da man:inetd[8] dem Benutzer `root` gehört, müssen Sie zuerst mit man:su[1] `root` werden:
+
[source,bash]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
man:kill[1] wird, wie andere UNIX(R) Kommandos auch, keine Ausgabe erzeugen, wenn das Kommando erfolgreich war. Wird versucht, einem Prozess der nicht dem Benutzer gehört, ein Signal zu senden, dann wird die Meldung `kill: _PID_: Operation not permitted` ausgegeben. Ein Tippfehler bei der Eingabe der PID führt dazu, dass das Signal an einen falschen Prozess gesendet wird, was zu negativen Ergebnissen führen kann, oder das Signal wird an eine PID gesendet die derzeit nicht in Gebrauch ist, was zu dem Fehler `kill: _PID_: No such process` führt.

[NOTE]
.Warum sollte man `/bin/kill` benutzen?
====
Viele Shells stellen `kill` als internes Kommando zur Verfügung, das heißt die Shell sendet das Signal direkt, anstatt [.filename]#/bin/kill# zu starten. Beachten Sie, dass die unterschiedlichen Shells eine andere Syntax benutzen, um die Namen der Signale anzugeben. Anstatt jede Syntax zu lernen, kann es einfacher sein, `/bin/kill` direkt aufzurufen.
====
****

Beim Versenden von anderen Signalen, ersetzen Sie `TERM` oder `KILL` in der Kommandozeile mit dem Namen des Signals.

[IMPORTANT]
====
Das zufällige Beenden eines Prozesses kann gravierende Auswirkungen haben. Insbesondere man:init[8], mit der PID 1, ist ein Spezialfall. `/bin/kill -s KILL 1` ist ein schneller, jedoch nicht empfohlener Weg, das System herunterzufahren. Überprüfen Sie die Argumente von man:kill[1] _immer_ zweimal _bevor_ Sie kbd:[Return] drücken.
====

[[shells]]
== Shells

Eine _Shell_ stellt eine Kommandozeilen-Schnittstelle zur Interaktion mit dem Betriebssystem zur Verfügung. Sie empfängt Befehle von einem Eingabekanal und führt diese aus. Viele Shells bieten eingebaute Funktionen, die die tägliche Arbeit erleichtern, beispielsweise eine Dateiverwaltung, die Vervollständigung von Dateinamen (Globbing), Kommandozeilen-Editor, sowie Makros und Umgebungsvariablen. FreeBSD enthält einige Shells, darunter die Bourne Shell (man:sh[1]) und die verbesserte C-Shell (man:tcsh[1]). Weitere Shells, wie `zsh` oder `bash`, befinden sich in der Ports-Sammlung.

Die verwendete Shell ist letztlich eine Frage des Geschmacks. Ein C-Programmierer, findet vielleicht eine C-artige Shell wie man:tcsh[1] angenehmer. Ein Linux(R)-Benutzer bevorzugt vielleicht `bash`. Jede Shell hat ihre speziellen Eigenschaften, die mit der bevorzugten Arbeitsumgebung des Benutzers harmonieren kann oder nicht. Deshalb stehen mehrere Shells zur Auswahl.

Ein verbreitetes Merkmal in Shells ist die Dateinamen-Vervollständigung. Nachdem der Benutzer einige Buchstaben eines Kommandos oder eines Dateinamen eingeben hat, vervollständigt die Shell den Rest durch drücken der kbd:[Tab]-Taste. Angenommen, Sie haben zwei Dateien [.filename]#foobar# und [.filename]#football#. Um [.filename]#foobar# zu löschen, kann der Benutzer `rm foo` eingeben und kbd:[Tab] drücken um den Dateinamen zu vervollständigen.

Die Shell wird lediglich `rm foo` anzeigen. Sie konnte den Dateinamen nicht vervollständigen, da sowohl [.filename]#foobar# als auch [.filename]#football# mit `foo` anfangen. Einige Shells geben einen Signalton aus, oder zeigen alle Möglichkeiten an, wenn mehr als ein Name mit dem gegebenen Muster übereinstimmt. Der Benutzer muss dann weitere Zeichen eingeben, damit die Shell den gewünschten Dateinamen bestimmen kann. Durch Eingabe von `t` und erneutes Drücken von kbd:[Tab] ist die Shell in der Lage, den gewünschten Dateinamen zu vervollständigen.

Ein weiteres Merkmal der Shell ist der Gebrauch von Umgebungsvariablen. Dies sind veränderbare Schlüsselpaare im Umgebungsraum der Shell, die jedes von der Shell aufgerufene Programm lesen kann. Daher enthält der Umgebungsraum viele Konfigurationsdaten für Programme. <<shell-env-vars>> zeigt verbreitete Umgebungsvariablen und deren Bedeutung. Beachten Sie, dass die Namen der Umgebungsvariablen immer in Großbuchstaben geschrieben sind:

[[shell-env-vars]]
.Gebräuchliche Umgebungsvariablen
[cols="1,1", frame="none", options="header"]
|===
| Variable
| Beschreibung

|`USER`
|Name des angemeldeten Benutzers.

|`PATH`
|Liste mit Verzeichnissen (getrennt durch Doppelpunkt) zum Suchen nach Programmen.

|`DISPLAY`
|Der Name des Xorg-Bildschirms, auf dem Ausgaben erfolgen sollen.

|`SHELL`
|Die aktuelle Shell.

|`TERM`
|Name des Terminaltyps des Benutzers. Benutzt, um die Fähigkeiten des Terminals zu bestimmen.

|`TERMCAP`
|Datenbankeintrag der Terminal Escape Codes, benötigt um verschieden Terminalfunktionen auszuführen.

|`OSTYPE`
|Typ des Betriebssystems.

|`MACHTYPE`
|Die CPU-Architektur des Systems.

|`EDITOR`
|Vom Benutzer bevorzugter Text-Editor.

|`PAGER`
|Vom Benutzer bevorzugter Text-Betrachter.

|`MANPATH`
|Liste mit Verzeichnissen (getrennt durch Doppelpunkt) zum Suchen nach Manualpages.
|===

Das Setzen von Umgebungsvariablen unterscheidet sich von Shell zu Shell. In man:tcsh[1] und man:csh[1] wird dazu `setenv` benutzt. man:sh[1] und `bash` benutzen `export` um Umgebungsvariablen zu setzen. Dieses Beispiel für die man:tcsh[1]-Shell setzt die Variable `EDITOR` auf [.filename]#/usr/local/bin/emacs#:

[source,bash]
....
% setenv EDITOR /usr/local/bin/emacs
....

Der entsprechende Befehl für `bash` wäre:

[source,bash]
....
% export EDITOR="/usr/local/bin/emacs"
....

Um eine Umgebungsvariable zu expandieren, geben Sie in der Kommandozeile das Zeichen `$` vor dessen Namen ein. Zum Beispiel gibt `echo $TERM` den aktuellen Wert von`$TERM` aus.

Shells behandeln Spezialzeichen, so genannte Metazeichen, als besondere Darstellungen für Daten. Das häufigste Zeichen ist `\*`, das eine beliebige Anzahl Zeichen in einem Dateinamen repräsentiert. Metazeichen können zur Vervollständigung von Dateinamen (Globbing) benutzt werden. Beispielsweise liefert `echo *` nahezu das gleiche wie `ls`, da die Shell alle Dateinamen die mit `*` übereinstimmen, an `echo` weitergibt.

Um zu verhindern, dass die Shell ein Sonderzeichen interpretiert, schützt man es, indem man einen Backslash (`\`) voranstellt. Zum Beispiel zeigt `echo $TERM` die Einstellung des Terminals an, wohingegen `echo \$TERM` einfach die Zeichenfolge `$TERM` ausgibt.

[[changing-shells]]
=== Ändern der Shell

Der einfachste Weg die Standard Shell zu ändern, ist `chsh` zu benutzen. `chsh` startet den Editor, welcher durch die Umgebungsvariable `EDITOR` gesetzt ist. Standardmäßig ist dies man:vi[1]. Tragen Sie in die Zeile die mit `Shell:` beginnt, den absoluten Pfad der neuen Shell ein.

Alternativ setzt `chsh -s` die Shell, ohne dabei einen Editor aufzurufen. Um die Shell zum Beispiel auf `bash` zu ändern, geben Sie folgenden Befehl ein:

[source,bash]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
Die neue Shell _muss_ in [.filename]#/etc/shells# aufgeführt sein. Wurde die Shell aus der FreeBSD Ports-Sammlung installiert, so wie in crossref:ports[ports,Installieren von Anwendungen: Pakete und Ports] beschrieben, sollte sie automatisch zu dieser Datei hinzugefügt worden sein. Wenn der Eintrag fehlt, nutzen Sie folgenden Befehl, und ersetzen Sie den Pfad mit dem Pfad zur gewünschten Shell:

[source,bash]
....
# echo /usr/local/bin/bash >> /etc/shells
....

Danach kann man:chsh[1] erneut aufgerufen werden.
====

=== Fortgeschrittene Shell Techniken

Die UNIX(R)-Shell ist nicht nur ein Kommandozeileninterpreter, sie ist ein leistungsfähiges Werkzeug, das Benutzern die Ausführung von Befehlen ermöglicht. Es kann die Ein- und Ausgabe umleiten und Befehle miteinander verketten, um die finale Ausgabe zu verbessern. Diese Funktionalität, gepaart mit den eingebauten Befehlen, bietet dem Benutzer eine Umgebung, welche die Effizienz erheblich steigern kann.

Als Redirection bezeichnet man die Umleitung der Ein- oder Ausgabe in einen anderen Befehl oder Datei. Um beispielsweise die Ausgabe des Befehls man:ls[1] in eine Datei zu schreiben, muss die Ausgabe umgeleitet werden:

[source,bash]
....
% ls > Verzeichnis_Ausgabe.txt
....

Die Datei [.filename]#Verzeichnis_Ausgabe.txt# enthält nun den Verzeichnisinhalt. Einige Befehle, wie beispielsweise man:sort[1], können verwendet werden um von der Eingabe zu lesen. Wenn Sie die Ausgabe sortieren möchten, müssen Sie die Eingabe umleiten:

[source,bash]
....
% sort < Verzeichnis_Ausgabe.txt
....

Die Eingabe wird sortiert und auf dem Bildschirm ausgegeben. Um diese Ausgabe wiederum in eine Datei umzuleiten, kann die Ausgabe von man:sort[1] umgeleitet werden:

[source,bash]
....
% sort < Verzeichnis_Ausgabe.txt > Sortierte_Ausgabe.txt
....

In den bisherigen Beispielen wurden für die Umleitung Dateideskriptoren verwendet. Jedes UNIX(R)-System verfügt über drei Dateideskriptoren: Standardeingabe (stdin), Standardausgabe (stdout) und Stardardfehlerausgabe (stderr). Jeder Deskriptor hat einen bestimmten Zweck. Die Eingabe könnte von einer Tastatur, einer Maus oder einem anderen Eingabegerät stammen. Die Ausgabe könnte der Bildschirm oder ein Drucker sein. Die Standardfehlerausgabe wird zur Diagnose und für Fehlermeldungen verwendet. Alle drei Deskriptoren arbeiten I/O basiert und werden häufig als Streams bezeichnet.

Die Verwendung von Deskriptoren erlaubt es der Shell, die Ein- und Ausgabe von verschiedenen Kommandos umzuleiten und zu teilen. Eine weitere Möglichkeit zur Umleitung bietet der Pipe-Operator.

Der UNIX(R) Pipe-Operator "|" wird verwendet, um die Ausgabe eines Kommandos an ein anderes Programm zu übergeben. Grundsätzlich bedeutet dies, dass die Standardausgabe eines Programms als Standardeingabe für ein weiteres Programm verwendet wird. Ein Beispiel:

[source,bash]
....
% cat Verzeichnis_Auflistung.txt | sort | less
....

In diesem Beispiel wird der Inhalt von [.filename]#Verzeichnis_Auflistung.txt# sortiert und die Ausgabe an man:less[1] übergeben. Dies erlaubt es dem Benutzer, die Ausgabe Schritt für Schritt und im eigenen Tempo zu betrachten.

[[editors]]
== Text-Editoren

Die meiste Konfiguration unter FreeBSD wird durch das Editieren von Textdateien erledigt. Deshalb ist es eine gute Idee, mit einem Texteditor vertraut zu werden. FreeBSD hat ein paar davon im Basissystem und sehr viel mehr in der Ports-Sammlung.

Ein einfach zu erlernender Editor ist man:ee[1], was für easy editor steht. Um diesen Editor zu starten, gibt man in der Kommandozeile `ee _filename_` ein, wobei _filename_ den Namen der zu editierenden Datei darstellt. Einmal im Editor, finden sich alle Editor-Funktionen oben im Display aufgelistet. Das Einschaltungszeichen (`^`) steht für die kbd:[Ctrl] (oder kbd:[Strg]) Taste, mit `^e` ist also die Tastenkombination kbd:[Ctrl+e] gemeint. Um man:ee[1] zu verlassen, drücken Sie kbd:[Esc] und wählen dann im Hauptmenü `leave editor` aus. Der Editor fragt nach, ob Sie speichern möchten, wenn die Datei verändert wurde.

FreeBSD verfügt über leistungsfähigere Editoren wie man:vi[1] als Teil des Basissystems. Andere Editoren wie package:editors/emacs[] und package:editors/vim[] sind Teil der Ports-Sammlung. Diese Editoren bieten höhere Funktionalität, jedoch auf Kosten einer etwas schwierigeren Erlernbarkeit. Das Erlernen eines leistungsfähigeren Editors, wie vim oder Emacs, kann auf lange Sicht Zeit einsparen.

Viele Anwendungen, die Dateien verändern oder Texteingabe erwarten, werden automatisch einen Texteditor öffnen. Um den Standardeditor zu ändern, wird die Umgebungsvariable `EDITOR` gesetzt, wie im Abschnitt <<shells>> beschrieben.

[[basics-devices]]
== Geräte und Gerätedateien

Der Begriff Gerät wird meist in Verbindung mit Hardware wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht. Der Großteil der Meldungen, die beim Booten von FreeBSD angezeigt werden, beziehen sich auf gefundene Geräte. Eine Kopie dieser Bootmeldungen wird in [.filename]#/var/run/dmesg.boot# gespeichert.

Jedes Gerät verfügt über einen Gerätenamen und Gerätenummer. Zum Beispiel steht [.filename]#ada0# für die erste SATA Festplatte, während [.filename]#kbd0# die Tastatur repräsentiert.

Auf die meisten Geräte wird unter FreeBSD über spezielle Gerätedateien im [.filename]#/dev# Verzeichnis zugegriffen.

[[basics-more-information]]
== Manualpages

[[basics-man]]
=== Manualpages

Die umfassendste Dokumentation rund um FreeBSD gibt es in Form von Manualpages. Annähernd jedes Programm im System bringt eine kurze Referenzdokumentation mit, die die grundsätzliche Funktion und verschiedene Parameter erklärt. Diese Manuals können mit `man` eingesehen werden:

[source,bash]
....
% man Kommando
....

_Kommando_ ist der Name des Kommandos, über das man etwas erfahren will. Um beispielsweise mehr über das Kommando man:ls[1] zu erfahren, geben Sie ein:

[source,bash]
....
% man ls
....

Die Manualpages sind in nummerierte Sektionen unterteilt, die jeweils ein Thema darstellen. In FreeBSD sind die folgenden Sektionen verfügbar:

. Benutzerkommandos.
. Systemaufrufe und Fehlernummern.
. Funktionen der C Bibliothek.
. Gerätetreiber.
. Dateiformate.
. Spiele und andere Unterhaltung.
. Verschiedene Informationen.
. Systemverwaltung und -Kommandos.
. Kernel Schnittstellen.

In einigen Fällen kann dasselbe Thema in mehreren Sektionen auftauchen. Es gibt zum Beispiel ein `chmod` Benutzerkommando und einen `chmod()` Systemaufruf. Um man:man[1] mitzuteilen, aus welcher Sektion die Information angezeigt werden soll, kann die Sektionsnummer mit angeben werden:

[source,bash]
....
% man 1 chmod
....

Dies wird Ihnen die Manualpage für das Benutzerkommando man:chmod[1] zeigen. Verweise auf eine Sektion der Manualpages werden traditionell in Klammern gesetzt. So bezieht sich man:chmod[1] auf das Benutzerkommando und man:chmod[2] auf den Systemaufruf.

Wenn das Kommando nicht bekannt ist, kann `man -k` benutzt werden, um nach Schlüsselbegriffen in den Kommandobeschreibungen zu suchen:

[source,bash]
....
% man -k mail
....

Dieser Befehl zeigt eine Liste von Kommandos, deren Beschreibung das Schlüsselwort "mail" enthält. Die gleiche Funktionalität erhalten Sie auch, wenn Sie man:apropos[1] benutzen.

Um die Beschreibungen der Kommandos in [.filename]#/usr/bin# zu lesen, geben Sie ein:

[source,bash]
....
% cd /usr/bin
% man -f * | more
....

Dasselbe erreichen Sie durch Eingabe von:

[source,bash]
....
% cd /usr/bin
% whatis * | more
....

[[basics-info]]
=== GNU Info Dateien

FreeBSD enthält verschiedene Anwendungen und Utilities der Free Software Foundation (FSF). Zusätzlich zu den Manualpages können diese Programme Hypertext-Dokumente enthalten, die `info`-Seiten genannt werden. Diese Dokumente können mit man:info[1] ansehen kann. Wenn package:editors/emacs[] installiert ist, kann auch der info-Modus von emacs benutzt werden.

Um man:info[1] zu benutzen, geben Sie ein:

[source,bash]
....
% info
....

Eine kurze Einführung gibt es mit `h`; eine Befehlsreferenz erhalten Sie durch Eingabe von: `?`.
