---
title: Capitolo 7. Multimedia
part: Parte II. Compiti Ordinari
prev: books/handbook/desktop
next: books/handbook/kernelconfig
---

[[multimedia]]
= Multimedia
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Indice
:table-caption: Tabella
:figure-caption: Figura
:example-caption: Esempio
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 7

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/it/mailing-lists.adoc[]
include::shared/it/urls.adoc[]

toc::[]

[[multimedia-synopsis]]
== Sinossi

FreeBSD supporta una grande varietà di schede audio, permettendoti di apprezzare un output di alta fedeltà dal tuo computer. Questo include l'abilità di registrare e riprodurre suoni nei formati MPEG Audio Layer 3 (MP3), WAV, ed Ogg Vorbis così come in molti altri formati. La FreeBSD Ports Collection contiene inoltre applicazioni che ti permettono di modificare l'audio registrato, aggiungere effetti sonori, e controllare i dispositivi MIDI collegati.

Con un po' di sperimentazione, FreeBSD può supportare la riproduzione di file video e DVD. Il numero di applicazioni per codificare, convertire, e riprodurre i vari formati video è più limitato del numero delle applicazioni audio. Per esempio nel momento in cui sto scrivendo, non esiste nella FreeBSD Ports Collection una buona applicazione per ricodificare che potrebbe essere usata per la conversione tra diversi formati, come c'è con package:audio/sox[]. Tuttavia, il panorama software in quest'area sta rapidamente cambiando.

Questo capitolo descriverà i passi necessari per configurare la tua scheda audio. La configurazione e l'installazione di X11 (crossref:x11[x11,L'X Window System]) si sono già prese cura dei problemi hardware della tua scheda video, sebbene ci possano essere delle ottimizzazioni da applicare per una migliore riproduzione.

Dopo aver letto questo capitolo, saprai:

* Come configurare il sistema in modo che la scheda audio venga riconosciuta.
* Metodi per verificare che la tua scheda funzioni.
* Come risolvere i problemi di configurazione audio.
* Come riprodurre e codificare file MP3.
* Come sono supportate le applicazioni video dal server X.
* Alcuni port per riprodurre/codificare filmati che danno buoni risultati.
* Come riprodurre i DVD e i file [.filename]#.mpg# e [.filename]#.avi#.
* Come estrarre i contenuti da CD e DVD su file.
* Come configurare una scheda TV.
* Come configurare uno scanner di immagini.

Prima di leggere questo capitolo, dovresti:

* Sapere come configurare e installare un nuovo kernel (crossref:kernelconfig[kernelconfig,Configurazione del Kernel di FreeBSD]).

[WARNING]
====

Provare a montare CD audio con il comando man:mount[8] produrrà un errore, come minimo, o un _kernel panic_, alla peggio. Questi formati hanno codifiche particolari che differiscono dal comune file system ISO.
====

[[sound-setup]]
== Configurazione della Scheda Audio

[[sound-device]]
=== Configurare il Sistema

Prima di iniziare, dovresti conoscere il modello della scheda che possiedi, il chip che utilizza, e se è una scheda PCI o ISA. FreeBSD supporta diverse schede PCI e ISA. Verifica la lista dei dispositivi audio supportati nell' link:{u-rel120-hardware}[Hardware Notes] per vedere se la tua scheda è supportata. Inoltre tale documento ti indicherà quale driver supporta la tua scheda.

Per usare il tuo dispositivo audio, dovrai caricare i driver corretti. Il caricamento del driver del dispositivo può essere fatto in due modi. Il metodo più semplice consiste semplicemente nel caricare un modulo nel kernel per la tua scheda audio con man:kldload[8] che può essere fatto sia da linea di comando:

[source,bash]
....
# kldload snd_emu10k1
....

sia aggiungendo la riga appropriata al file [.filename]#/boot/defaults/loader.conf# come questa:

[.programlisting]
....
snd_emu10k1_load="YES"
....

Questi esempi sono per la scheda audio Creative SoundBlaster(R) Live!. Altri moduli sonori disponibili sono elencati in [.filename]#/boot/loader.conf#. Se hai dei dubbi su quale driver usare, potresti provare a caricare il modulo [.filename]#snd_driver#:

[source,bash]
....
# kldload snd_driver
....

Questo è un metadriver che carica i driver dei dispositivi audio più comuni in un solo colpo. Ciò permette di trovare velocemente il driver corretto. È anche possibile caricare tutti i driver audio attraverso il file [.filename]#/boot/loader.conf#.

Se desideri scoprire il driver selezionato per la tua scheda audio dopo aver caricato il metadriver [.filename]#snd_driver#, puoi verificare il file [.filename]#/dev/sndstat# con il comando `cat /dev/sndstat`.

Un altro metodo è quello di compilare staticamente il supporto per la tua scheda audio nel kernel. La sezione seguente fornisce le informazioni di cui hai bisogno per aggiungere il supporto al tuo hardware in questo metodo. Per informazioni aggiuntive su come ricompilare il kernel, guarda il crossref:kernelconfig[kernelconfig,Configurazione del Kernel di FreeBSD].

==== Configurare un Kernel Custom con il Supporto Audio

La prima cosa da fare è aggiungere al kernel il driver di framework audio man:sound[4]; per fare ciò devi aggiungere la seguente riga al tuo file di configurazione del kernel:

[.programlisting]
....
device sound
....

Poi, devi aggiungere il supporto per la tua scheda audio. Di conseguenza, devi conoscere quale driver supporta la scheda. Controlla la lista dei dispositivi audio supportati nell'link:{u-rel120-hardware}[Hardware Notes], per determinare il driver corretto per la tua scheda sonora. Per esempio, la scheda SoundBlaster(R) Live! della Creative è supportata dal driver man:snd_emu10k1[4]. Per aggiungere il supporto per questa scheda, usiamo la seguente riga:

[.programlisting]
....
device snd_emu10k1
....

Per conoscere la corretta sintassi da usare assicurati di leggere la pagina man del driver. La sintassi corretta per la configurazione del kernel di ogni driver audio supportato può essere trovata nel file [.filename]#/usr/src/sys/conf/NOTES#.

Schede ISA non-PnP possono obbligarti a fornire al kernel informazioni su alcuni settaggi della scheda audio (IRQ, porta di I/O, etc), tipico di tutte le scheda ISA non-PnP. Questo può essere realizzato attraverso il file [.filename]#/boot/device.hints#. All'avvio del sistema, il man:loader[8] leggerà questo file e passerà i settaggi al kernel. Per esempio, una vecchia scheda audio SoundBlaster(R) 16 ISA non-PnP della Creative userà il driver man:snd_sbc[4] in congiunzione con `snd_sb16`. Per questa scheda le seguenti linee devono essere aggiunte al file di configurazione del kernel:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

e queste nel [.filename]#/boot/device.hints#:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

In questo caso, la scheda usa la porta di I/O `0x220` e l'IRQ `5`.

La sintassi usata nel file [.filename]#/boot/device.hints# è spiegata nella pagina man di man:sound[4] e nella pagina man del driver in questione.

Il settaggi qui sopra sono quelli di default. In alcuni casi, potresti avere la necesità di modificare l'IRQ o altri parametri per far funzionare la tua scheda audio. Guarda la pagina man di man:snd_sbc[4] per maggiori dettagli su questo driver.

[[sound-testing]]
=== Collaudo della Scheda Audio

Dopo aver riavviato con il nuovo kernel, o dopo aver caricato il modulo richiesto, la scheda audio dovrebbe apparire nel tuo buffer dei messaggi (man:dmesg[8]) in modo simile a quanto segue:

[source,bash]
....
pcm0: <Intel ICH3 (82801CA)> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: <Cirrus Logic CS4205 AC97 Codec>
....

Lo stato della scheda audio può essere verificato leggendo il file [.filename]#/dev/sndstat#:

[source,bash]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: <Intel ICH3 (82801CA)> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)
....

L'output del tuo sistema potrebbe essere diverso. Se nessun dispositivo [.filename]#pcm# viene visualizzato, rivedi ciò che è stato fatto di recente. Ricontrolla ancora una volta il tuo file di configurazione del kernel e assicurati di aver scelto il driver corretto. Alcuni problemi comuni sono elencati nella <<troubleshooting>>.

Se tutto va bene, ora dovresti avere una scheda audio funzionante. Se i pin di audio-out del tuo drive CD-ROM o DVD-ROM sono collegati correttamente alla scheda audio, puoi inserire un CD nel drive e riprodurlo con man:cdcontrol[1]:

[source,bash]
....
% cdcontrol -f /dev/acd0 play 1
....

Varie applicazioni, come package:audio/workman[] possono offrire una migliore interfaccia. Potresti voler installare una applicazione come package:audio/mpg123[] per ascoltare i file audio MP3.

Un altro modo veloce per controllare se la scheda trasmette dati al nodo [.filename]#/dev/dsp# è questo:

[source,bash]
....
% cat filename > /dev/dsp
....

dove _filename_ può essere qualsiasi file. Questo comando dovrebbe produrre del rumore, confermando che la scheda sonora sta lavorando.

I livelli del mixer della scheda possono essere modificati attraverso il comando man:mixer[8]. Maggiori dettagli possono essere trovati nella pagina man man:mixer[8].

[[troubleshooting]]
==== Problemi Comuni

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Errore
| Soluzione

|`sb_dspwr(XX) timed out`
|

Non è stata impostata correttamente la porta di I/O.

|`bad irq XX`
|

È stato configurato erroneamente l'IRQ. Assicurati che l'IRQ impostato e quello della scheda siano gli stessi.

|`xxx: gus pcm not attached, out of memory`
|

Non c'è abbastanza memoria disponibile per usare il dispositivo.

|`xxx: can't open /dev/dsp!`
|

Controlla con `fstat \| grep dsp` se un'altra applicazione sta usando il dispositivo. Esound e il supporto audio di KDE sono famosi per creare problemi.
|===

[[sound-multiple-sources]]
=== Utilizzo di Sorgenti Audio Multiple

È spesso desiderabile avere più sorgenti di audio che siano in grado di suonare contemporaneamente, per esempio quando esound o artsd non supportano la condivisione del dispositivo audio con una certa applicazione.

FreeBSD ti permette di fare questo attraverso i _Virtual Sound Channels_, che possono essere abilitati con man:sysctl[8]. I canali virtuali permettono di multiplexare i canali di riproduzione della tua scheda audio mixando l'audio nel kernel.

Per impostare il numero dei canali virtuali, ci sono due variabili sysctl che, se sei l'utente `root`, possono essere impostate così:

[source,bash]
....
# sysctl hw.snd.pcm0.vchans=4
# sysctl hw.snd.maxautovchans=4
....

L'esempio qui sopra alloca quattro canali virtuali, che è un numero adatto all'uso di ogni giorno. `hw.snd.pcm0.vchans` è il numero dei canali virtuali che ha [.filename]#pcm0#, ed è configurabile una volta che il dispositivo è collegato. `hw.snd.maxautovchans` è il numero dei canali virtuali che vengono dati a un nuovo dispositivo audio quando viene collegato tramite man:kldload[8]. Visto che il modulo [.filename]#pcm# può essere caricato indipendentemente dai driver dell'hardware, `hw.snd.maxautovchans` può contenere tanti canali virtuali quanti ne verranno allocati successivamente ad ogni dispositivo collegato.

[NOTE]
====
Non puoi cambiare il numero di canali virtuali per un dispositivo mentre questo è in uso. Chiudi tutti i programmi che stanno usando quel dispositivo, come player di musica o demoni del suono.
====

Se non stai usando man:devfs[5], dovrai indirizzare la tua applicazione su [.filename]#/dev/dsp0#._x_, dove _x_ va da 0 a 3 se `hw.snd.pcm.0.vchans` è impostato a 4 come nel precedente esempio. Su un sistema che usa man:devfs[5], questo verrà fatto automaticamente in modo trasparente per un programma che richiede [.filename]#/dev/dsp0#.

=== Settare i Valori di Default per i Canali del Mixer

I valori di default per i diversi canali del mixer sono rigidamente codificati nel codice sorgente del driver man:pcm[4]. Ci sono svariate applicazioni e demoni che ti permettono di settare i valori del mixer memorizzandoli per le successive invocazioni, ma questa non è una soluzione pulita. È possibile settare valori di default del mixer a livello del driver - questo è realizzabile definendo i valori desiderati nel file [.filename]#/boot/device.hints#, per esempio:

[.programlisting]
....
hint.pcm.0.vol="50"
....

Questo imposterà il canale volume a un valore di default di 50 non appena il modulo man:pcm[4] sarà caricato.

[[sound-mp3]]
== Audio MP3

Il formato MP3 (Audio MPEG Livello 3) raggiunge una qualità audio vicina a quella dei CD, non lasciandoti motivi per non utilizzarlo sulla tua workstation FreeBSD.

[[mp3-players]]
=== Lettori MP3

Da tempo, il più famoso lettore MP3 per X11 è XMMS (X Multimedia System). Le skin per Winamp possono essere usate con XMMS visto che la GUI è praticamente identica a quella di Winamp della Nullsoft. XMMS ha inoltre supporto nativo ai plug-in.

XMMS può essere installato dal port o dal package package:multimedia/xmms[].

L'interfaccia di XMMS è intuitiva, comprende una lista di brani da eseguire, un equalizzatore grafico, ed altro. Coloro che sono familiari con Winamp troveranno XMMS semplice da usare.

Il port package:audio/mpg123[] è un lettore MP3 alternativo, da riga di comando.

mpg123 può essere eseguito specificando il dispositivo audio e il nome del file MP3 sulla riga di comando, come mostrato qui sotto:

[source,bash]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

`/dev/dsp1.0` deve essere sostituito con il dispositivo [.filename]#dsp# presente sul tuo sistema.

[[rip-cd]]
=== Estrazione delle Tracce Audio dei CD

Prima di codificare un CD o una traccia di CD in MP3, i dati audio sul CD devono essere estratti sul disco fisso. Questo avviene copiando direttamente i dati CDDA (CD Digital Audio) in file WAV.

Il tool `cdda2wav`, che fa parte della suite package:sysutils/cdrtools[], viene usato per estrarre le informazioni audio dai CD e i dati associati.

Mentre il CD audio è nel lettore, può essere eseguito il seguente comando (come `root`) per estrarre un intero CD in singoli (per traccia) file WAV:

[source,bash]
....
# cdda2wav -D 0,1,0 -B
....

cdda2wav supporta anche i lettori CDROM ATAPI (IDE). Per estrarre da un lettore IDE, specifica il nome del dispositivo al posto nel numero dell'unità SCSI. Ad esempio, per estrarre la traccia 7 dal lettore IDE:

[source,bash]
....
# cdda2wav -D /dev/acd0 -t 7
....

Il `-D _0,1,0_` indica il dispositivo SCSI [.filename]#0,1,0#, che corrisponde all'output di `cdrecord -scanbus`.

Per estrarre tracce singole, usa l'opzione `-t` come mostrato:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 7
....

Questo esempio estrae la settima traccia del CD audio. Per estrarre una serie di tracce, per esempio dalla traccia uno alla sette, specifica un intervallo:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 1+7
....

L'utility man:dd[1] può anche essere usata per estrarre le tracce audio dai drive ATAPI, leggi crossref:disks[duplicating-audiocds,Duplicating Audio CDs] per maggiori informazioni su questa possibilità.

[[mp3-encoding]]
=== Codifica in MP3

Al giorno d'oggi, il programma di codifica in mp3 da scegliere è lame. Lame può essere trovato in package:audio/lame[] nell'albero dei port.

Usando i file WAV estratti, il seguente comando convertirà [.filename]#audio01.wav# in [.filename]#audio01.mp3#:

[source,bash]
....
# lame -h -b 128 \
--tt "Titolo" \
--ta "Artista" \
--tl "Album" \
--ty "2002" \
--tc "Estratto e codificato da Blah" \
--tg "Genere" \
audio01.wav audio01.mp3
....

128 kbits sembra essere il bitrate standard in uso per gli MP3. Molti preferiscono la qualità maggiore dei 160, o 192. Più alto è il bitrate, più spazio consumerà l'MP3 risultante--ma la qualità sarà maggiore. L'opzione `-h` attiva il modo "qualità migliore ma un po' più lento"". Le opzioni che iniziano con `--t` indicano i tag ID3, che solitamente contengono le informazioni sulla canzone, da inserire all'interno del file MP3. Ulteriori opzioni di codifica possono essere trovate consultando la pagina man di lame.

[[mp3-decoding]]
=== Decodifica da MP3

Per masterizzare un CD audio partendo dagli MP3, questi ultimi devono essere convertiti in un formato WAV non compresso. Sia XMMS che mpg123 supportano l'output di un MP3 in un formato non compresso.

Scrittura su Disco con XMMS:

[.procedure]
====
. Avvia XMMS.
. Clicca con il tasto destro sulla finestra per far comparire il menu di XMMS.
. Seleziona `Preference` sotto `Options`.
. Cambia l'Output Plugin in "Disk Writer Plugin".
. Premi `Configure`.
. Inserisci (o scegli browse) la directory in cui salvare i file decompressi.
. Carica il file MP3 in XMMS come al solito, con il volume al 100% e le impostazioni dell'equalizzatore disattivate.
. Premi `Play` - XMMS apparirà come se stesse riproducendo l'MP3, ma non si sentirà nessuna musica. Sta riproducendo la musica su un file.
. Assicurati di reimpostare l'Output Plugin di default come prima per ascoltare nuovamente gli MP3.
====

Scrittura su stdout con mpg123:

[.procedure]
====
. Esegui `mpg123 -s audio01.mp3 > audio01.pcm`
====

XMMS scrive un file nel formato WAV, mentre mpg123 converte l'MP3 direttamente in dati audio PCM. Entrambi questi formati possono essere usati con cdrecord per creare CD audio. Devi utilizzare PCM con man:burncd[8]. Se usi file WAV, noterai un breve ticchettio all'inizio di ogni traccia, questo suono è l'intestazione del file WAV. Puoi semplicemente rimuovere l'intestazione del file WAV con l'utility SoX (può essere installata dal port o dal package package:audio/sox[]):

[source,bash]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

Leggi crossref:disks[creating-cds,Creating and Using Optical Media (CDs & DVDs)] per ulteriori informazioni su come usare un masterizzatore con FreeBSD.

[[video-playback]]
== Riproduzione Video

La riproduzione video è un'area applicativa molto recente e in rapido sviluppo. Sii paziente. Non tutto funzionerà così facilmente come è stato per l'audio.

Prima di iniziare, dovresti conoscere il modello della scheda video che possiedi e il chip che usa. Sebbene Xorg e XFree86(TM) supportino una vasta varietà di schede video, poche offrono buone prestazioni in riproduzione. Per ottenere una lista di estensioni supportate dall'X server con la tua scheda usa il comando man:xdpyinfo[1] mentre X11 sta girando.

È una buona idea avere un piccolo file MPEG che possa essere trattato come un file di test per la valutazione di vari riproduttori e opzioni. Visto che alcuni riproduttori di DVD cercheranno di default i DVD in [.filename]#/dev/dvd#, o hanno questo nome di dispositivo codificato permanentemente al loro interno, potresti trovare utile creare dei link simbolici al dispositivo corretto:

[source,bash]
....
# ln -sf /dev/acd0 /dev/dvd
# ln -sf /dev/acd0 /dev/rdvd
....

Nota che, data la natura del man:devfs[5], i collegamenti creati a mano come questi non rimarranno se riavvii il sistema. Per creare i collegamenti simbolici automaticamente quando avvii il sistema, aggiungi le seguenti righe in [.filename]#/etc/devfs.conf#:

[source,bash]
....
# ln -sf /dev/acd0c /dev/dvd
# ln -sf /dev/acd0c /dev/rdvd
....

In aggiunta, la decrittazione dei DVD, che richiede l'invocazione di speciali funzioni dei DVD-ROM, richiede il permesso in scrittura sui dispositivi DVD.

Per migliorare l'interfaccia della memoria condivisa di X11, è consigliabile incrementare i valori di alcune variabili man:sysctl[8]:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== Determinazione delle Capacità Video

Ci sono molti modi possibili per visualizzare immagini e filmati con X11. Quello che funzionerà meglio in pratica dipende in gran parte dal tuo hardware. Ogni metodo descritto qui sotto avrà una qualità variabile su hardware differente. In secondo luogo, il rendering video in X11 è un argomento che sta ricevendo un sacco di attenzione ultimamente, e con ogni nuova versione di Xorg, o di XFree86(TM) ci possono essere notevoli miglioramenti.

Una lista di interfacce video comuni:

. X11: normale output di X11 che usa la memoria condivisa.
. XVideo: un'estensione all'interfaccia X11 che supporta grafica e filmati in ogni oggetto X11 disegnabile.
. SDL: Simple Directmedia Layer.
. DGA: Direct Graphics Access.
. SVGAlib: interfaccia di basso livello per la grafica da console.

[[video-interface-xvideo]]
==== XVideo

Xorg e XFree86(TM) 4.X hanno un'estensione chiamata _XVideo_ (aka Xvideo, aka Xv, aka xv) che permette di visualizzare grafica e filmati direttamente negli oggetti disegnabili attraverso una speciale accelerazione. Questa estensione fornisce una riproduzione di ottima qualità anche su macchine poco potenti.

Per controllare se l'estensione sta girando, usa `xvinfo`:

[source,bash]
....
% xvinfo
....

XVideo è supportato dalla tua scheda se il risultato è simile a:

[source,bash]
....
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

Inoltre tieni presente che i formati elencati (YUV2, YUV12, ecc) non sono presenti in tutte le implementazioni di XVideo e la loro assenza può ostacolare alcuni programmi.

Se il risultato è:

[source,bash]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

Allora XVideo probabilmente non è supportato per la tua scheda.

Se XVideo non è supportato per la tua scheda, questo vuol dire solamente che sarà più difficile soddisfare le richieste computazionali per il rendering video. A seconda della tua scheda video e del tuo processore, comunque, potresti essere ancora in grado di avere un'esperienza soddisfacente. Dovrai probabilmente dare un occhio ai modi per migliorare le prestazioni nella lettura avanzata <<video-further-reading>>.

[[video-interface-SDL]]
==== Simple Directmedia Layer

Il Simple Directmedia Layer, SDL, vuole essere un'interfaccia di portabilità tra Microsoft(R) Windows, BeOS, e UNIX(R), che possa permettere di sviluppare applicazioni multi-piattaforma che facciano buon uso di suoni e grafica. L'interfaccia SDL fornisce una astrazione di basso livello all'hardware che può a volte essere più efficiente dell'interfaccia X11.

L'SDL può essere trovata in package:devel/sdl12[].

[[video-interface-DGA]]
==== Direct Graphics Access

Direct Graphics Access è un'estensione di X11 che permette a un programma di evitare il server X ed alterare direttamente il buffer video. Siccome si basa su una mappatura di memoria a basso livello per effettuare questa condivisione, i programmi che la usano devono essere avviati da `root`.

L'estensione DGA può essere testata con man:dga[1]. Quando `dga` è in esecuzione, cambia i colori del display ogni volta che viene premuto un tasto. Per uscire, premi kbd:[q].

[[video-ports]]
=== Port e Package che Riguardano il Video

In questa sezione si discuterà del software disponibile nella FreeBSD Port Collection che possono essere usati per la riproduzione video. La sezione software sulla riproduzione video è in continuo sviluppo, per cui le caratteristiche delle varie applicazioni sono destinate a differire dalla descrizione che segue.

In primo luogo, è importante sapere che molte delle applicazioni video che girano su FreeBSD sono stati sviluppate come applicazioni Linux. Molte di queste applicazioni sono ancora in fase beta. Alcuni dei problemi che puoi incontrare con i package video su FreeBSD comprendono:

. Un'applicazione non riesce a riprodurre un file generato da un'altra applicazione.
. Un'applicazione non riesce a riprodurre un file che lei stessa ha prodotto.
. Lo stesso applicativo posto su due computer diversi, ricompilato su ognuno dei due computer, riproduce lo stesso file in modo diverso.
. Da un filtro apparentemente banale quale il ridimensionamento di un'immagine si ottenga un pessimo risultato derivato da una routine di ridimensionamento bacata.
. Un'applicazione che genera frequentemente file "core".
. La documentazione non viene installata con il port e può essere trovata sul web o nella directory [.filename]#work# del port.

Molte di queste applicazioni possono anche esibire "Linuxismi". Ovvero, ci possono essere problemi risultanti dal modo in cui le librerie standard sono state implementate nelle distribuzioni Linux, o alcune modifiche al kernel di Linux che sono state apportate dagli autori delle applicazioni. Questi problemi possono non essere stati notati e aggirati dal mantainer del port, e possono portare comunque a problemi come questi:

. L'uso di [.filename]#/proc/cpuinfo# per riconoscere le caratteristiche del processore.
. Un uso errato dei thread che può portare un programma a bloccare la propria esecuzione piuttosto che terminare correttamente.
. Software non ancora presente nella collezione dei port di FreeBSD che è comunemente usato unitamente all'applicazione.

A questo punto, gli sviluppatori di queste applicazioni sono stati collaborativi con i maintainer dei port al fine di minimizzare la ricerca di soluzioni necessarie al processo di porting.

[[video-mplayer]]
==== MPlayer

MPlayer è stata sviluppata di recente ed è un player in rapida evoluzione. Gli obbiettivi degli sviluppatori di MPlayer sono la velocità e la flessibilità su Linux e le altre famiglie di UNIX(R). Il progetto è partito non appena il fondatore del gruppo si stancò delle prestazioni degli altri riproduttori. C'è chi dice che l'interfaccia grafica sia stata sacrificata per un design essenziale. Tuttavia, una volta che si sono imparate perfettamente le opzioni da riga di comando e le scorciatoie, funziona decisamente bene.

[[video-mplayer-building]]
===== Compilazione di MPlayer

MPlayer è reperibile sotto package:multimedia/mplayer[]. MPlayer effettua una serie di controlli sull'hardware durante il processo di compilazione, che ha come risultato un binario che non potrà essere considerato portabile da una piattaforma ad un'altra. Questo è il motivo per cui risulta importante compilarlo usando il port piuttosto che il pacchetto contenente il binario. Inoltre, ulteriori opzioni possono essere specificate nella riga di comando di `make`, come descritto nel [.filename]#Makefile# e all'inizio della compilazione.

[source,bash]
....
# cd /usr/ports/multimedia/mplayer
# make
N - O - T - E
Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
for example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
if you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html
....

Le opzioni di default del port dovrebbero essere sufficienti per la maggior parte degli utenti. Tuttavia, se hai bisogno del codec XviD, devi specificare l'opzione `WITH_XVID` nella riga di comando. Inoltre puoi definire il dispositivo DVD di default con l'opzione `WITH_DVD_DEVICE`, altrimenti sarà utilizzato di default [.filename]#/dev/acd0#.

Al momento, il port MPlayer creerà la sua documentazione in HTML e due eseguibili `mplayer`, e `mencoder`, che è uno strumento per la ri-codifica video.

La documentazione HTML di MPlayer è molto istruttiva. Qualora il lettore trovasse le informazioni sull'hardware e le interfacce video in questo capitolo scarne, la documentazione di MPlayer risulta essere un ottimo supplemento. Se si stanno cercando informazioni riguardo il supporto video sotto UNIX(R), sarebbe utile trovare il tempo di leggere in modo preciso la documentazione di MPlayer.

[[video-mplayer-using]]
===== Utilizzo di MPlayer

Ogni utente che voglia usare MPlayer deve creare la directory [.filename]#.mplayer# sotto la propria home. Per creare questa directory necessaria, puoi digitare il seguente comando:

[source,bash]
....
% cd /usr/ports/multimedia/mplayer
% make install-user
....

Le opzioni del comando `mplayer` sono elencate nella pagina del manuale. Per qualunque altro dettaglio consulta la documentazione HTML. In questa sezione, descriveremo solamente alcuni degli usi più comuni.

Per riprodurre un file, ad esempio [.filename]#testfile.avi#, usando una delle varie interfacce video usa l'opzione `-vo`:

[source,bash]
....
% mplayer -vo xv testfile.avi
....

[source,bash]
....
% mplayer -vo sdl testfile.avi
....

[source,bash]
....
% mplayer -vo x11 testfile.avi
....

[source,bash]
....
# mplayer -vo dga testfile.avi
....

[source,bash]
....
# mplayer -vo 'sdl:dga' testfile.avi
....

È utile provare tutte queste opzioni, considerando che le prestazioni dipendono da svariati fattori e variano in modo considerevole a seconda dell'hardware.

Per riprodurre un DVD, sostituisci [.filename]#testfile.avi# con l'opzione `dvd://_N_ -dvd-device _DISPOSITIVO_` dove _N_ corrisponde al numero del titolo da riprodurre e [.filename]#DISPOSITIVO# al dispositivo che identifica il DVD-ROM. Per esempio, per riprodurre il terzo titolo da [.filename]#/dev/dvd#:

[source,bash]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
Il dispositivo DVD di default può essere definito durante la compilazione del port MPlayer tramite l'opzione `WITH_DVD_DEVICE`. Di default, questo dispositivo è [.filename]#/dev/acd0#. Maggiori dettagli posso essere trovati nel [.filename]#Makefile# del port.
====

Per interrompere, mettere in pausa, andare avanti e così via, leggi l'elenco delle associazioni dei tasti, che vengono elencati eseguendo `mplayer -h` o consulta la pagina man.

Ulteriori opzioni utili per la riproduzione sono: `-fs -zoom` che abilita la modalità schermo intero e `-framedrop` che aiuta le prestazioni.

Perchè la riga di comando di mplayer non diventi eccessivamente lunga, l'utente può creare il file [.filename]#.mplayer/config# ed impostare lì i valori predefiniti:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

In ultimo, è possibile usare `mplayer` per estrarre una traccia DVD in un file [.filename]#.vob#. Per estrarre la seconda traccia dal DVD, digita questo:

[source,bash]
....
# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd
....

Il file ottenuto, [.filename]#out.vob#, sarà in formato MPEG e potrà manipolato da un'altro programma descritto in questa sezione.

[[video-mencoder]]
===== mencoder

Prima di usare `mencoder` è una buona idea familiarizzare con le opzioni contenute nella documentazione HTML. Esiste anche una pagina man, ma non è utile senza la documentazione HTML. Esiste un numero considerevole di modi per migliorare la qualità, un bitrate più basso, cambiare codifica ed alcuni di questi trucchi può fare la differenza tra prestazioni più o meno accettabili. Di seguito un paio di esempi per cominciare. Prima di tutto, una semplice copia:

[source,bash]
....
% mencoder input.avi -oac copy -ovc copy -o output.avi
....

Combinazioni errate di opzioni da riga di comando possono portare a file di output irriproducibili perfino con `mplayer`. Di conseguenza, se si vuole semplicemente estrarre una traccia, usare l'opzione `-dumpfile` eseguendo in `mplayer`.

Per convertire il file [.filename]#input.avi# in formato MPEG4 con l'audio codificato in MPEG3 (è necessario package:audio/lame[]):

[source,bash]
....
% mencoder input.avi -oac mp3lame -lameopts br=192 \
  -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi
....

Questo comando ha creato un file riproducibile con `mplayer` e `xine`.

Il parametro [.filename]#input.avi# può essere sostituito con `dvd://1 -dvd-device /dev/dvd` ed eseguire il comando come `root` per ricodificare il capitolo DVD direttamente. Poichè si sarà certamente poco soddisfatti del risultato la prima volta, è consigliato eseguire il dump del capitolo e lavorare direttamente sul file.

[[video-xine]]
==== Il Riproduttore Video xine

Il riproduttore video xine è un progetto dagli ampi obiettivi e non solo l'essere una soluzione unica per la riproduzione, ma anche una libreria di base riutilizzabile ed un eseguibile modulare che possa essere esteso con i plugin. È disponibile sia come pacchetto che come port, sotto package:multimedia/xine[].

xine è ancora un pò rozzo, ma è chiaramente un buon inizio. In pratica, xine necessita sia di una CPU veloce che di una scheda video veloce o il supporto per l'estensione XVideo. L'interfaccia grafica è utilizzabile, ma ancora mal disegnata.

Allo stato attuale, non ci sono moduli distribuiti con xine che possano riprodurre DVD codificati in CSS. Esistono distribuzioni di terze parti che hanno moduli di questo genere già compilati, ma nessuno di questi esiste nella FreeBSD Ports Collection.

Comparato con MPlayer, xine offre maggiori caratteristiche all'utente ma, allo stesso tempo, non rende disponibile all'utente un controllo più accurato. Il riproduttore video xine funziona molto meglio sulle interfacce XVideo.

Di default, xine si avvierà con un'interfaccia grafica. Si possono quindi usare i menu per aprire per aprire un file specifico:

[source,bash]
....
% xine
....

Alternativamente, può essere invocato per aprire direttamente un file senza l'interfaccia grafica, con il comando:

[source,bash]
....
% xine -g -p mymovie.avi
....

[[video-ports-transcode]]
==== Le Utility transcode

Il software transcode non è un riproduttore, piuttosto un insieme di strumenti per ricodificare file audio e video. Con transcode, si ha la possibilità di unire file video, riparare file corrotti ed utilizzare strumenti da riga di comando con interfaccie che utilizzano i flussi [.filename]#stdin/stdout#.

Durante la compilazione del port package:multimedia/transcode[] possono essere specificate diverse opzioni, noi ti consigliamo il comando seguente per compilare transcode:

[source,bash]
....
# make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes
....

I settaggi proposti dovrebbero essere sufficienti per la maggior parte degli utenti.

Per illustrare le capacità di `transcode`, viene dato un esempio che mostra come convertire un file DivX in un file PAL MPEG-1 (PAL VCD):

[source,bash]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

Il file MPEG risultante, [.filename]#output_vcd.mpg#, è pronto per essere letto con MPlayer. Puoi perfino masterizzare il file su un CD-R per creare un Video CD, e in questo caso necessiti di installare ed usare i programmi package:multimedia/vcdimager[] e package:sysutils/cdrdao[].

Esiste una pagina man per `transcode`, ma dovresti anche consultare il http://www.transcoding.org/cgi-bin/transcode[wiki di transcode] per ulteriori informazioni ed esempi.

[[video-further-reading]]
=== Ulteriori Letture

I vari package di applicazioni video per FreeBSD si stanno evolvendo rapidamente. È abbastanza possibile che in un futuro vicino molti dei problemi discussi qui saranno risolti. Nel frattempo, chiunque voglia ottenere il massimo dalle capacità A/V di FreeBSD, dovrà unire alla meglio la conoscenza che deriva dalle svariate FAQ e guide con l'uso di queste poche applicazioni. Questa sezione esiste per fornire al lettore indicazioni a queste informazioni aggiuntive.

La http://www.mplayerhq.hu/DOCS/[Documentazione di MPlayer] è molto istruttiva sul piano tecnico. Questa documentazione, probabilmente, dovrà essere consultata da chiunque voglia ottenere un alto grado di conoscenza del video sotto UNIX(R). La mailing list di MPlayer risulta abbastanza ostile a chiunque non si sia preoccupato di leggere la documentazione, se si ha intenzione di segnalar loro un bug, RTFM.

L'http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html[HOWTO di xine] contiene un capitolo su come aumentare le prestazioni che è comune a tutti i riproduttori.

In ultimo, ci sono alcuni applicativi promettenti che il lettore può provare:

* http://avifile.sourceforge.net/[Avifile] che è anche un port package:multimedia/avifile[].
* http://www.dtek.chalmers.se/groups/dvd/[Ogle] che è anche un port package:multimedia/ogle[].
* http://xtheater.sourceforge.net/[Xtheater]
* package:multimedia/dvdauthor[], un package open source per la creazione di DVD.

[[tvcard]]
== Configurazione delle Schede TV

=== Introduzione

Le schede TV permettono di visualizzare la TV via onde radio o via cavo sul tuo computer. La maggior parte di queste accettano in input video composito tramite connettori RCA o S-video e alcune di queste schede hanno un sintonizzatore radio FM.

FreeBSD fornisce supporto per le schede TV su bus PCI che usano un chip di acquisizione video Brooktree Bt848/849/878/879 o Conexant CN-878/Fusion 878a tramite il driver man:bktr[4]. Devi anche assicurarti che la scheda abbia un sintonizzatore supportato, consulta la pagina man di man:bktr[4] per una lista dei sintonizzatori supportati.

=== Aggiunta del Driver

Per usare la scheda, devi caricare il driver man:bktr[4], e questo può essere fatto aggiungendo la seguente riga al file [.filename]#/boot/loader.conf# in questo modo:

[.programlisting]
....
bktr_load="YES"
....

Alternativamente, puoi compilare staticamente il supporto per la scheda TV nel tuo kernel, in questo caso aggiungi le seguenti righe alla configurazione del tuo kernel:

[.programlisting]
....
device    bktr
device iicbus
device iicbb
device smbus
....

Questi driver aggiuntivi sono necessari poiché le componenti della scheda sono interconnesse tramite un bus I2C. Quindi compila ed installa un nuovo kernel.

Una volta che hai aggiunto il supporto al tuo sistema, devi riavviare la macchina. Durante il processo di avvio, la tua scheda TV dovrebbe apparire, come in questo esempio:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

Ovviamente questi messaggi possono differire a seconda dell'hardware. Tuttavia dovresti controllare se il sintonizzatore viene rilevato correttamente; è sempre possibile modificare alcuni dei parametri rilevati tramite le MIB di man:sysctl[8] e le opzioni nel file di configurazione del kernel. Ad esempio, se vuoi imporre che il sintonizzatore sia un Philips SECAM, dovresti aggiungere la riga seguente al file di configurazione del kernel:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

o puoi usare direttamente man:sysctl[8]:

[source,bash]
....
# sysctl hw.bt848.tuner=6
....

Guarda la pagina man di man:bktr[4] e il file [.filename]#/usr/src/sys/conf/NOTES# per maggiori dettagli sulle opzioni disponibili.

=== Applicazioni Utili

Per usare la tua scheda TV devi installare una delle seguenti applicazioni:

* package:multimedia/fxtv[] fornisce capacità di TV-in-una-finestra e acquisizione di immagini/audio/video.
* package:multimedia/xawtv[] è anch'esso un'applicazione TV, con le stesse caratteristiche di fxtv.
* package:misc/alevt[] decodifica e visualizza Videotext/Teletext.
* package:audio/xmradio[], un'applicazione per usare il sintonizzatore radio FM che hanno alcune schede TV.
* package:audio/wmtune[], un'applicazione desktop maneggevole per i sintonizzatori radio.

Altre applicazioni sono disponibili nella FreeBSD Ports Collection.

=== Risoluzione dei Problemi

Se incontri qualche problema con la tua scheda TV, dovresti verificare dapprima se il chip di acquisizione video e il sintonizzatore sono realmente supportati dal driver man:bktr[4] e se hai usato le corrette opzioni di configurazione. Per maggiore supporto e varie domande sulla tua scheda video potresti voler leggere ed usare gli archivi della mailing list {freebsd-multimedia}.

[[scanners]]
== Scanner di immagini

=== Introduzione

In FreeBSD, l'accesso agli scanner è fornito dalle API di SANE (Scanner Access Now Easy) disponibili nella collezione dei port di FreeBSD. SANE usa anche alcuni driver dei dispositivi di FreeBSD per accedere all'hardware dello scanner.

FreeBSD supporta sia scanner SCSI che USB. Verifica che il tuo scanner sia supportato da SANE prima di effettuare ogni configurazione. SANE ha una lista di http://www.sane-project.org/sane-supported-devices.html[dispositivi supportati], che può fornire informazioni riguardo il supporto per uno scanner ed il suo stato. La pagina man man:uscanner[4] fornisce una lista di scanner USB supportati.

=== Configurazione del Kernel

Come già menzionato, sono supportati sia scanner USB che SCSI. A seconda dell'interfaccia del tuo scanner, sono richiesti diversi driver dei dispositivi.

[[scanners-kernel-usb]]
==== Interfaccia USB

Il kernel [.filename]#GENERIC# di default include i driver dei dispositivi necessari per il funzionamento degli scanner USB. In caso tu voglia usare un kernel custom, accertati che le linee seguenti siano presenti nel tuo file di configurazione del kernel:

[.programlisting]
....
device usb
device uhci
device ohci
device uscanner
....

A seconda del tipo di chipset USB sulla tua scheda madre, hai bisogno solo di una fra le opzioni `device uhci` e `device ohci`, comunque avere entrambe le linee nel proprio file di configurazione del kernel non crea problemi.

Se non intendi ricompilare un kernel custom ed il tuo kernel non è il [.filename]#GENERIC#, puoi direttamente caricare il modulo del driver del dispositivo di man:uscanner[4] con il comando man:kldload[8]:

[source,bash]
....
# kldload uscanner
....

Per caricare il modulo ad ogni avvio di sistema, aggiungi la seguente linea al file [.filename]#/boot/loader.conf#:

[.programlisting]
....
uscanner_load="YES"
....

Dopo aver riavviato con il kernel corretto, o dopo aver caricato il modulo necessario, attacca il tuo scanner USB. Nel buffer dei messaggi di sistema (man:dmesg[8]) dovrebbe apparire una riga che mostra il riconoscimento dello scanner:

[source,bash]
....
uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2
....

Questo mostra che il nostro scanner usa il nodo del dispositivo [.filename]#/dev/uscanner0#.

==== Interfaccia SCSI

Se il tuo scanner possiede un'interfaccia SCSI, è importante sapere quale controller SCSI usi. A seconda del chipset SCSI usato, dovrai modificare il tuo file di configurazione del kernel. Il kernel [.filename]#GENERIC# supporta i più comuni controller SCSI. Accertati di leggere il file di [.filename]#NOTES# e aggiungi la linea corretta al tuo file di configurazione del kernel. Oltre al driver dell'interfaccia SCSI, devi avere le seguenti linee nel tuo file di configurazione del kernel:

[.programlisting]
....
device scbus
device pass
....

Una volta che il kernel è stato correttamente compilato ed installato, dovresti vedere i dispositivi nel buffer dei messaggi di sistema, al momento del boot:

[source,bash]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

Se il tuo scanner non era acceso al momento dell'avvio, è ancora possibile forzare manualmente il riconoscimento attraverso uno scan del bus SCSI con il comando man:camcontrol[8]:

[source,bash]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

A questo punto lo scanner apparirà nella lista dei device SCSI:

[source,bash]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

Ulteriori dettagli sui dispositivi SCSI sono disponibili nelle pagine man man:scsi[4] e man:camcontrol[8].

=== Configurazione di SANE

Il sistema SANE è diviso in due parti: il backend (package:graphics/sane-backends[]) ed il frontend (package:graphics/sane-frontends[]). La parte backend fornisce accesso allo scanner. La lista dei http://www.sane-project.org/sane-supported-devices.html[dispositivi supportati] da SANE specifica quale backend supporta il tuo scanner di immagini. È necessario determinare il corretto backend per il tuo scanner se intendi usare il tuo dispositivo. La parte frontend fornisce l'interfaccia grafica allo scanning (xscanimage).

La prima cosa da fare è installare il port o il pacchetto package:graphics/sane-backends[]. Quindi, usa il comando `sane-find-scanner` per verificare il riconoscimento dello scanner da parte del sistema SANE:

[source,bash]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

L'output mostrerà il tipo di interfaccia dello scanner ed il nodo del dispositivo usato per connettere lo scanner al sistema. La marca ed il nome del modello potrebbero non comparire, non è importante.

[NOTE]
====
Alcuni scanner USB richiedono il caricamento di un firmware, ciò è spiegato nella pagina man del backend. È utile anche leggere le pagine man di man:sane-find-scanner[1] e di man:linprocfs[7].
====

Adesso dobbiamo verificare se lo scanner sarà identificato da un frontend di scanning. Di default, il backend di SANE fornisce un programma da linea di comando chiamato man:sane[1]. Questo comando ti permette di elencare i dispositivi ed effettuare un'acquisizione di immagini da linea di comando. L'opzione `-L` è usata per ottenere una lista di scanner:

[source,bash]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
....

Nessun output o un messaggio che dice che nessuno scanner è stato identificato indica che man:sane[1] non è in grado di identificare lo scanner. Se ciò succede, dovrai editare il file di configurazione del backend ed indicare il driver del dispositivo usato dallo scanner. La directory [.filename]#/usr/local/etc/sane.d/# contiene tutti i file di configurazione del backend. Questo problema di identificazione avviene con alcuni scanner USB.

Ad esempio, usando <<scanners-kernel-usb>>, `sane-find-scanner` su uno scanner USB otteniamo la seguente informazione:

[source,bash]
....
# sane-find-scanner -q
found USB scanner (UNKNOWN vendor and product) at device
/dev/uscanner0
....

Lo scanner è stato riconosciuto correttamente, usa l'interfaccia USB ed è attaccato al nodo del dispositivo [.filename]#/dev/uscanner0#. Ora possiamo testare se lo scanner è correttamente identificato:

[source,bash]
....
# scanimage -L

Nessun scanner è stato identificato. Se ti aspettavi qualcosa di diverso,
verifica che lo scanner sia collegato, accendilo e avvia il tool di
riconoscimento degli scanner di sane (se adatto). Per cortesia leggi la
documentazione fornita con questo software (README, FAQ, pagine man).
....

Dato che lo scanner non è stato identificato, dovremo editare il file [.filename]#/usr/local/etc/sane.d/epson.conf#. Il modello di scanner usato è l'EPSON Perfection(R) 1650, così sappiamo che userà il backend `epson`. Accertati di leggere i commenti di aiuto nei file di configurazione del backend. Le modifiche alle linee sono abbastanza semplici: commenta tutte le linee che hanno un'interfaccia non adatta al tuo scanner (nel nostro caso, commenteremo tutte le linee che iniziano con la parola `scsi` dato che il nostro scanner usa l'interfaccia USB), quindi aggiungi alla fine del file una linea che specifica l'interfaccia ed il nodo di dispositivo usato. In questo caso, aggiungiamo la seguente linea:

[.programlisting]
....
usb /dev/uscanner0
....

Sei invitato a leggere i commenti presenti nel file di configurazione del backend così come le pagine man del backend per più dettagli e per la corretta sintassi da usare. Ora possiamo verificare se lo scanner è identificato:

[source,bash]
....
# scanimage -L
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner
....

Il nostro scanner USB è stato riconosciuto. Non è importante se la marca ed il modello non coincidono con il proprio scanner. Il punto principale a cui prestare attenzione è il campo `epson:/dev/uscanner0`, che ci dà il corretto nome del backend ed il corretto nodo del dispositvo.

Una volta che il comando `scanimage -L` è in grado di vedere lo scanner, la configurazione è completa. Il dispositivo ora è in grado di scannerizzare.

Mentre man:sane[1] ci permette di effettuare l'acquisizione di un'immagine dalla linea di comando, è preferibile usare un'interfaccia grafica per effettuare scansioni di immagini. SANE offre una semplice ma efficace interfaccia grafica: xscanimage (package:graphics/sane-frontends[]).

Xsane (package:graphics/xsane[]) è un altro comune frontend grafico di scanning. Questo frontend offre caratteristiche avanzate come varie tecniche di scanning (fotocopia, fax, etc.), correzione del colore, scans multipli, etc. Entrambe queste applicazioni sono fruibili come plugin di GIMP.

=== Permettere ad Altri Utenti l'Accesso allo Scanner

Tutte le operazioni precedenti sono state compiute con privilegi di `root`. Tuttavia potresti aver bisogno che altri utenti abbiano accesso allo scanner. L'utente necessiterà permessi di lettura e scrittura sul nodo di dispositivo usato dallo scanner. Per esempio, il nostro scanner USB usa il nodo di dispositivo [.filename]#/dev/uscanner0# che appartiene al gruppo `operator`. Aggiungendo l'utente `joe` al gruppo `operator` gli permetterà di usare lo scanner:

[source,bash]
....
# pw groupmod operator -m joe
....

Per maggiori informazioni consulta la pagina man di man:pw[8]. Inoltre devi settare corretamente i permessi di scrittura (0660 o 0664) per il nodo del dispositivo [.filename]#/dev/uscanner0#; di default il gruppo `operator` può solo leggere questo nodo di dispositivo. Tale operazione può essere realizzata aggiungendo la seguente riga al file [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[system=5]
add path uscanner0 mode 660
....

Quindi aggiungi la seguente riga al file [.filename]#/etc/rc.conf# e riavvia la macchina:

[.programlisting]
....
devfs_system_ruleset="system"
....

Ulteriori informazioni riguardo queste righe possono essere trovate nella pagina man di man:devfs[8].

[NOTE]
====
Chiaramente, per ragioni di sicurezza, dovresti pensarci due volte prima di aggiungere un utente a qualsiasi gruppo, specialmente al gruppo `operator`.
====
