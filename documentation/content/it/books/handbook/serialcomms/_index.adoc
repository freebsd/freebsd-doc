---
title: Capitolo 24. Comunicazioni Seriali
part: Parte IV. Comunicazione di Rete
prev: books/handbook/partiv
next: books/handbook/ppp-and-slip
showBookMenu: true
weight: 29
path: "/books/handbook/serialcomms/"
---

[[serialcomms]]
= Comunicazioni Seriali
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 24
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/serialcomms/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[serial-synopsis]]
== Sinossi

UNIX(R) ha sempre avuto un supporto per le comunicazioni seriali. In effetti, le prime vere macchine UNIX(R) si appoggiavano a linee seriali per l'input e l'output da e verso l'utente. Le cose sono cambiate molto dai giorni in cui un "terminale" consisteva in una stampante da 10 caratteri al secondo o in una tastiera. Questo capitolo coprirà alcuni dei modi nei quali FreeBSD usa le comunicazioni seriali.

Dopo aver letto questo capitolo, saprai:

* Come connettere terminali al tuo sistema FreeBSD.
* Come usare un modem per collegarti telefonicamente ad una macchina remota.
* Come permettere a utenti remoti di effettuare login sul tuo sistema via modem.
* Come avviare il tuo sistema da una console seriale.

Prima di leggere questo capitolo, dovresti:

* Sapere come configurare ed installare un nuovo kernel (crossref:kernelconfig[kernelconfig,Configurazione del Kernel di FreeBSD]).
* Comprendere i permessi ed i processi UNIX(R) (crossref:basics[basics,Basi di UNIX]).
* Avere accesso al manuale tecnico per l'hardware seriale (modem o scheda multiporta) che vuoi usare con FreeBSD.

[[serial]]
== Introduzione

[[serial-terminology]]
=== Terminologia

bps::
Bits per Second (Bit per Secondo) - la frequenza alla quale vengono trasmessi i dati

DTE::
Data Terminal Equipment (Attrezzatura per il Terminale Dati) - ad esempio, il tuo computer

DCE::
Data Communications Equipment (Attrezzatura per le Comunicazioni Dati) - il tuo modem

RS-232::
Standard EIA per le comunicazioni tra hardware seriale

Nel parlare della velocità di comunicazione, questa sezione non usa il termine "baud". Il baud si riferisce al numero di transizioni degli stati elettrici che possono essere effettuati in un periodo di tempo, mentre i "bps" (bit per secondo) sono il termine _corretto_ da usare (o almeno non sembra irritare troppo i perfezionisti).

[[serial-cables-ports]]
=== Cavi e Porte

Per collegare un modem o un terminale alla tua macchina FreeBSD, avrai bisogno di una porta seriale sul tuo computer e del cavo appropriato per il tuo dispositivo seriale. Se sei già pratico con l'hardware ed i cavi necessari, puoi saltare tranquillamente questa sezione.

[[term-cables]]
==== Cavi

Ci sono parecchi tipi diversi di cavi seriali. I due tipi più comuni per i nostri scopi sono i cavi null-modem ed i cavi standard ("dritti") RS-232. La documentazione per il tuo hardware dovrebbe descrivere il tipo di cavi necessari.

[[term-cables-null]]
===== Cavi null-modem

Un cavo null-modem porta segnali dritti, come il "Segnale di Massa", e segnali incrociati. Per esempio, il pin di "Trasmissione Dati" su un capo è il pin di "Ricezione Dati" sull'altro capo.

Puoi costruirti un cavo null-modem da usare con i terminali (es., se vuoi una migliore qualità). Questa tabella mostra i <<serialcomms-signal-names,segnali>> dell'RS-232C e i numeri dei pin su un connettore DB-25. Nota che lo standard richiede il segnale dritto sul pin 1 chiamato _Massa di Protezione_, anche se questo è spesso omesso. Alcuni terminali funzionano usando solo i pin 2, 3 e 7, mentre altri richiedono configurazioni diverse come mostrate negli esempi qui sotto.

.Cavo Null-Modem DB-25 / DB-25
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Segnale
<| Pin #
| 
<| Pin #
<| Segnale

|SG
|7
|si connette a
|7
|SG

|TD
|2
|si connette a
|3
|RD

|RD
|3
|si connette a
|2
|TD

|RTS
|4
|si connette a
|5
|CTS

|CTS
|5
|si connette a
|4
|RTS

|DTR
|20
|si connette a
|6
|DSR

|DTR
|20
|si connesso a
|8
|DCD

|DSR
|6
|si connette a
|20
|DTR

|DCD
|8
|si connette a
|20
|DTR
|===

Ecco altri due comuni schemi.

.Cavo Null-Modem DB-9 / DB-9
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Segnale
<| Pin #
| 
<| Pin #
<| Segnale

|RD
|2
|si connette a
|3
|TD

|TD
|3
|si connette a
|2
|RD

|DTR
|4
|si connette a
|6
|DSR

|DTR
|4
|si connette a
|1
|DCD

|SG
|5
|si connette a
|5
|SG

|DSR
|6
|si connette a
|4
|DTR

|DCD
|1
|si connette a
|4
|DTR

|RTS
|7
|si connette a
|8
|CTS

|CTS
|8
|si connette a
|7
|RTS
|===

.Cavo Null-Modem DB-9 / DB-25
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Segnale
<| Pin #
| 
<| Pin #
<| Segnale

|RD
|2
|si connette a
|2
|TD

|TD
|3
|si connette a
|3
|RD

|DTR
|4
|si connette a
|6
|DSR

|DTR
|4
|si connette a
|8
|DCD

|SG
|5
|si connette a
|7
|SG

|DSR
|6
|si connette a
|20
|DTR

|DCD
|1
|si connette a
|20
|DTR

|RTS
|7
|si connette a
|5
|CTS

|CTS
|8
|si connette a
|4
|RTS
|===

[NOTE]
====
Quando un pin di un capo si connette a una coppia di pin dell'altro capo, questo è solitamente fatto ponendo un cavetto tra la coppia di pin nel loro connettore e collegando questi con un altro cavo al singolo pin dell'altro capo.
====

Queste sembrano essere le implementazioni più popolari. In altre varianti (spiegate nel libro _RS-232 Made Easy_) SG è connesso a SG, TD a RD, RTS e CTS a DCD, DTR a DSR, e vice-versa.

[[term-cables-std]]
===== Cavi Standard RS-232C

Un cavo seriale standard ha tutti i segnali RS-232C diritti. Cioè, il pin di "Trasmissione Dati" su un capo del cavo va nel pin di "Trasmissione Dati" sull'altro capo. Questo è il tipo di cavo da usare per collegare un modem al tuo sistema FreeBSD, ed è anche appropriato per alcuni terminali.

[[term-ports]]
==== Porte

Le porte seriali sono i dispositivi attraverso i quali vengono trasferiti i dati tra il computer FreeBSD ed il terminale. Questa sezione descrive il tipo di porte che esistono e come vengono indicate in FreeBSD.

[[term-portkinds]]
===== Tipi di Porte

Esistono parecchi tipi di porte seriali. Prima di comprare o costruire un cavo, avrai bisogno di assicurarti che sia adatto alle porte sul terminale e sul sistema FreeBSD.

La maggior parte dei terminali avrà porte DB-25. I personal computer, compresi i PC con FreeBSD, avranno porte DB-25 o DB-9. Se hai una scheda seriale multiporta nel tuo PC, potresti avere porte RJ-12 o RJ-45.

Guarda la documentazione fornita con l'hardware per le specifiche del tipo di porta usata. Spesso basta anche un'ispezione visiva della porta.

[[term-portnames]]
===== Nomi delle Porte

In FreeBSD, si accede ad ogni porta seriale attraverso una voce nella directory [.filename]#/dev#. Ci sono due differenti tipi di voci:

* Le porte di ingresso vengono dette [.filename]#/dev/ttydN# dove _N_ è il numero di porta, cominciando da zero. Generalmente, puoi usare la porta di ingresso per i terminali. Le porte di ingresso richiedono che la linea fornisca un segnale detto data carrier detect (DCD) per funzionare correttamente.
* Le porte di uscita vengono dette [.filename]#/dev/cuadN#. In genere non si usano porte di uscita per i terminali, ma solo per i modem. Puoi usare la porta di uscita se il cavo seriale o il terminale non supportano il segnale di carrier detect.
+
[NOTE]
====
Le porte di uscita sono chiamate [.filename]#/dev/cuaaN# in FreeBSD 5.X e precedenti.
====

Se hai connesso un terminale sulla prima porta seriale ([.filename]#COM1# in MS-DOS(R)), allora userai [.filename]#/dev/ttyd0# per riferirti al terminale. Se il terminale è sulla seconda porta seriale (anche nota come [.filename]#COM2#), usa [.filename]#/dev/ttyd1#, e così via.

=== Configurazione del Kernel

FreeBSD supporta quattro porte seriali di default. Nel mondo MS-DOS(R), queste sono note come [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3#, e [.filename]#COM4#. FreeBSD attualmente supporta schede d'interfaccia seriale multiporta "stupide", come le BocaBoard 1008 e 2016, così come le schede multiporta intelligenti come quelle fatte dalla Digiboard e dalla Stallion Technologies. Ad ogni modo, il kernel di default usa solo le porte COM standard.

Per vedere se il tuo kernel riconosce una delle tue porte seriali, guarda i messaggi mentre il kernel viene avviato, o usa il comando `/sbin/dmesg` per far scorrere di nuovo i messaggi di avvio del kernel. In particolare, cerca dei messaggi che inizino con i caratteri `sio`.

[TIP]
====

Per vedere solo i messaggi che hanno la parola `sio`, usa il comando:

[source,shell]
....
# /sbin/dmesg | grep 'sio'
....

====

Ad esempio, su un sistema con quattro porte seriali, questi sono i messaggi dati dall'avvio del kernel specifici delle porte seriali:

[source,shell]
....
sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A
....

Se il tuo kernel non riconosce tutte le tue porte seriali, probabilmente devi configurare il kernel sistemando il file [.filename]#/boot/device.hints#. Inoltre puoi commentare o rimuovere completamente le righe dei dispositivi che non hai.

Su FreeBSD 4.X devi editare il tuo file di configurazione del kernel. Per informazioni dettagliate sulla configurazione del kernel, guarda crossref:kernelconfig[kernelconfig,Configurazione del Kernel di FreeBSD]. Le righe dei dispositivi interessati dovrebbero essere simili a queste:

[.programlisting]
....
device            sio0    at isa? port IO_COM1 irq 4
device          sio1    at isa? port IO_COM2 irq 3
device          sio2    at isa? port IO_COM3 irq 5
device          sio3    at isa? port IO_COM4 irq 9
....

Guarda la pagina man di man:sio[4] per informazioni aggiuntive sulla configurazione delle porte seriali e delle schede multiporta. Stai attento se stai usando un file di configurazione già usato per una versione differente di FreeBSD, poiché i flag dei dispositivi e la sintassi sono cambiati tra una versione e l'altra.

[NOTE]
====
`port IO_COM1` è una sostituzione per `port 0x3f8`, `IO_COM2` è `0x2f8`, `IO_COM3` è `0x3e8`, e `IO_COM4` è `0x2e8`, che sono indirizzi comuni per le rispettive porte seriali; gli interrupt 4, 3, 5, e 9 sono linee di richiesta di interrupt piuttosto comuni. Da notare anche che le normali porte seriali _non possono_ condividere degli interrupt sui bus ISA dei PC (le schede multiporta hanno dell'elettronica integrata che permette a tutte le 16550A sulla scheda di condividere uno o due linee di richiesta dell'interrupt).
====

=== File Speciali di Dispositivo

Alla maggior parte dei dispositivi nel kernel si accede attraverso "file speciali di dispositivo", che si trovano nella directory [.filename]#/dev#. Ai dispositivi [.filename]#sio# si accede attraverso i [.filename]#/dev/ttydN# (ingresso) e [.filename]#/dev/cuadN# (uscita). FreeBSD fornisce anche dei dispositivi di inizializzazione ([.filename]#/dev/ttydN.init# e [.filename]#/dev/cuadN.init# su FreeBSD 6.X, [.filename]#/dev/ttyidN# e [.filename]#/dev/cuaidN# su FreeBSD 5.X e precedenti) e dispositivi di blocco ([.filename]#/dev/ttydN.lock# e [.filename]#/dev/cuadN.lock# su FreeBSD 6.X, [.filename]#/dev/ttyldN# e [.filename]#/dev/cualdN# su FreeBSD 5.X e precedenti). I dispositivi di inizializzazione vengono usati per inizializzare i parametri delle porte di comunicazione ogni volta che una porta viene aperta, come `crtscts` per i modem che usano le segnalazioni `RTS/CTS` per il controllo di flusso. I dispositivi di blocco vengono usati per fissare i flag sulle porte ed evitare che altri utenti o programmi cambino certi parametri; guarda le pagine man di man:termios[4], man:sio[4], e man:stty[1] per maggiori informazioni sulle impostazioni dei terminali, sui dispositivi di blocco ed inizializzazione, e sull'impostazione delle opzioni del terminale, rispettivamente.

==== Creazione dei File Speciali di Dispositivo

[NOTE]
====
FreeBSD 5.0 include il file system man:devfs[5] che crea automaticamente nodi per i dispositivi necessari. Se stai usando una versione di FreeBSD con il `devfs` abilitato puoi saltare tranquillamente questa sezione.
====

Uno script di shell di nome `MAKEDEV` nella directory [.filename]#/dev# gestisce i file di dispositivo. Per usare `MAKEDEV` nella creazione del file di dispositivo per [.filename]#COM1# (porta 0), fai `cd` su [.filename]#/dev# e dai il comando `MAKEDEV ttyd0`. Allo stesso modo, per creare il file di dispositivo per [.filename]#COM2# (porta 1), usa `MAKEDEV ttyd1`.

`MAKEDEV` non crea solo i file speciali [.filename]#/dev/ttydN#, ma anche i nodi [.filename]#/dev/cuaaN#, [.filename]#/dev/cuaiaN#, [.filename]#/dev/cualaN#, [.filename]#/dev/ttyldN#, e [.filename]#/dev/ttyidN#.

Dopo aver creato i nuovi file di dispositivo, fa attenzione nel controllare i permessi sui file (specialmente sui file [.filename]#/dev/cua*#) per assicurarti che solo gli utenti che dovrebbero effettivamente avere accesso a questi dispositivi possano leggerli e scriverli - magari non vorrai permettere al tuo utente medio di usare il tuo modem per chiamare verso l'esterno. I permessi predefiniti su [.filename]#/dev/cua*# dovrebbero essere adatti:

[source,shell]
....
crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1
....

Questi permessi permettono all'utente `uucp` e agli utenti nel gruppo `dialer` di usare i dispositivi di uscita.

[[serial-hw-config]]
=== Configurazione della Porta Seriale

Il dispositivo [.filename]#ttydN# (o [.filename]#cuadN#) è il normale dispositivo che si apre per le proprie applicazioni. Quando un processo apre il dispositivo, avrà un insieme di impostazioni di I/O predefinite per il terminale. Puoi visualizzare queste impostazioni con il comando:

[source,shell]
....
# stty -a -f /dev/ttyd1
....

Quando cambi le impostazioni per questo dispositivo, queste rimangono efficaci finché il dispositivo non viene chiuso. Quando viene riaperto, ritorna all'insieme di default. Per effettuare dei cambiamenti all'insieme predefinito, modifica le impostazioni per il dispositivo di "stato iniziale". Ad esempio, per attivare di default modalità `CLOCAL`, comunicazione a 8 bit, e controllo di flusso `XON/XOFF` per [.filename]#ttyd5#, scrivi:

[source,shell]
....
# stty -f /dev/ttyd5.init clocal cs8 ixon ixoff
....

Le inizializzazioni di sistema per i dispositivi seriali sono controllate in [.filename]#/etc/rc.d/serial#. Questo file influisce sui valori predefiniti dei dispositivi seriali.

[NOTE]
====
Su FreeBSD 4.X, l'inizializzazione globale dei dispositivi seriali è controllata in [.filename]#/etc/rc.serial#.
====

Per evitare cambiamenti da parte di qualche applicazione, modifica il dispositivo di "blocco dello stato". Ad esempio, per bloccare la velocità di [.filename]#ttyd5# a 57600 bps, scrivi:

[source,shell]
....
# stty -f /dev/ttyd5.lock 57600
....

Ora, un applicazione che apra [.filename]#ttyd5# e cerchi di cambiare la velocità della porta resterà bloccata a 57600 bps.

Naturalmente, dovresti rendere i dispositivi di stato iniziale e stato di blocco scrivibili solo da `root`.

[[term]]
== Terminali

I terminali forniscono un sistema di accesso conveniente ed a basso costo al tuo sistema FreeBSD quando non sei davanti alla console del computer o connesso ad una rete. Questa sezione descrive l'uso dei terminali con FreeBSD.

[[term-uses]]
=== Uso e Tipi di Terminali

I sistemi UNIX(R) originali non avevano console. Invece, la gente effettuava il login ed avviava programmi attraverso terminali connessi alle porte seriali del computer. Ciò era abbastanza simile all'uso di modem e programmi terminale per collegarsi telefonicamente ad un sistema remoto e lavorare da riga di comando.

I PC di oggi hanno console capaci di grafica di alta qualità, ma l'abilità di stabilire una sessione di login su una porta seriale esiste ancora in quasi ogni sistema operativo in stile UNIX(R) di oggi; FreeBSD non fa eccezione. Usando un terminale attaccato ad una porta seriale inutilizzata, puoi effettuare il login ed eseguire qualsiasi programma testuale che potresti lanciare normalmente dalla console o da una finestra `xterm` in X Window.

Un utente aziendale può connettere molti terminali ad un sistema FreeBSD e porli sulle scrivanie dei propri impiegati. Un utente casalingo può usare qualcosa come un vecchio PC IBM o un Macintosh(R) come terminale connesso a un computer più potente che faccia girare FreeBSD. Puoi anche trasformare quello che sarebbe un computer singolo utente in un potente sistema per utenti multipli.

Per FreeBSD, esistono tre tipi di terminali:

* <<term-dumb,terminali "stupidi">>
* <<term-pcs,PC che interpretano terminali>>
* <<term-x,terminali X>>

Le sottosezioni rimanenti descrivono ognuno di questi tipi.

[[term-dumb]]
==== Terminali "Stupidi"

Questi terminali sono oggetti hardware specializzati che permettono di connettere dei computer tramite linee seriali. Essi vengono detti "stupidi" poiché hanno solo la potenza di calcolo necessaria per mostrare, inviare, e ricevere testo. Non potete eseguire nessun programma su di essi. È il computer al quale vi collegate che ha la potenza per eseguire editor di testo, compilatori, email, giochi, e così via.

Ci sono centinaia di tipi di terminali di questo tipo, venduti da molti produttori, incluso il VT-100 della Digital Equipment Corporation e il WY-75 della Wyse. Quasi tutti funzioneranno con FreeBSD. Alcuni terminali di alto livello possono anche mostrare della grafica, ma solo alcuni pacchetti software possono avvalersi di queste caratteristiche.

I terminali stupidi sono popolari negli ambienti di lavoro nei quali i lavoratori non hanno bisogno di accedere ad applicazioni grafiche come quelle fornite dal sistema X Window.

[[term-pcs]]
==== PC che Emulano Terminali

Se un <<term-dumb,terminale stupido>> ha appena le capacità per mostrare, inviare, e ricevere testo, allora di certo un qualunque personal computer può funzionare come un terminale stupido. Tutto ciò di cui hai bisogno è il cavo appropriato ed un qualche programma per l'_emulazione di terminale_ sul tuo computer.

Una simile configurazione è comune in molte case. Ad esempio, se il tuo coniuge sta lavorando alla console del sistema FreeBSD, tu puoi fare del lavoro testuale allo stesso momento da un PC meno potente connesso come terminale al sistema FreeBSD.

[[term-x]]
==== Terminali X

I terminali X sono i terminali più sofisticati tra quelli disponibili. Invece di collegarsi alla porta seriale, in genere ci si collega ad essi tramite un rete come Ethernet. Invece di essere relegati alle applicazioni testuali, essi possono mostrare applicazioni X.

Introduciamo i terminali X solo per una questione di completezza. Ad ogni modo, questo capitolo _non_ affronta in modo completo l'installazione, la configurazione, o l'uso dei terminali X.

[[term-config]]
=== Configurazione

Questa sezione descrive quello che hai bisogno di configurare sul tuo sistema FreeBSD per abilitare una sessione di login via terminale. Si assume che tu abbia già configurato il kernel con il supporto per la porta seriale alla quale è connesso il terminale - e che questo sia già connesso.

Dovresti ricordare dal crossref:boot[boot,La Procedura di Avvio] che il processo `init` è responsabile del controllo di tutti i processi e dell'inizializzazione del sistema all'avvio. Uno dei compiti svolti da `init` è la lettura del file [.filename]#/etc/ttys# e l'avvio di un processo `getty` sui terminali disponibili. Il processo `getty` è responsabile della lettura di un nome di login e dell'avvio del programma `login`.

Dunque, per configurare i terminali per il tuo sistema FreeBSD devono essere effettuati come `root` i seguenti passi:

[.procedure]
====
. Aggiungi una linea a [.filename]#/etc/ttys# relativa al file in [.filename]#/dev# per la porta seriale, se non è già presente.
. Specifica che `/usr/libexec/getty` deve essere eseguito sulla porta, e specifica il tipo appropriato di _getty_ dal file [.filename]#/etc/gettytab#.
. Specifica il tipo di terminale predefinito.
. Imposta la porta su "on".
. Specifica se la porta deve essere "sicura".
. Forza `init` alla rilettura del file [.filename]#/etc/ttys#.
====

Come passo opzionale, potresti desiderare di creare un tipo di _getty_ personale da usare nel secondo passo aggiungendo una linea in [.filename]#/etc/gettytab#. Questo capitolo non spiega come fare ciò; sei incoraggiato a leggere le pagine man di man:gettytab[5] e man:getty[8] per maggiori informazioni.

[[term-etcttys]]
==== Aggiunta di un Elemento in [.filename]#/etc/ttys#

Il file [.filename]#/etc/ttys# elenca tutte le porte del tuo sistema FreeBSD dalle quali vuoi permettere un login. Ad esempio, la prima console virtuale [.filename]#ttyv0# è elencata in questo file. Si può accedere al sistema dalla console grazie a questa voce. Questo file contiene anche delle voci per altre console virtuali, porte seriali, e pseudo-tty. Per un terminale connesso fisicamente, basta copiare l'elenco delle porte seriali in [.filename]#/dev# senza la parte [.filename]#/dev# (ad esempio, [.filename]#/dev/ttyv0# verrà scritta come [.filename]#ttyv0#).

Un'installazione predefinita di FreeBSD include un file [.filename]#/etc/ttys# con supporto per le prime quattro porte seriali: da [.filename]#ttyd0# a [.filename]#ttyd3#. Se vuoi collegare un terminale a una di queste porte, non hai bisogno di aggiungere un'altra voce.

[[ex-etc-ttys]]
.Aggiunta di Voci per Altri Terminali a [.filename]#/etc/ttys#
[example]
====
Supponiamo che si vogliano collegare due terminali ad un sistema: un Wyse-50 ed un vecchio PC IBM 286 con Procomm come programma di emulazione di terminale VT-100. Colleghiamo il Wyse alla seconda porta seriale ed il 286 alla sesta (una porta su scheda seriale multiporta). Le voci corrispondenti nel file [.filename]#/etc/ttys# apparirebbero così:

[.programlisting]
....
ttyd1  "/usr/libexec/getty std.38400"  wy50  on  insecure
ttyd5   "/usr/libexec/getty std.19200"  vt100  on  insecure
....

* Il primo campo in genere specifica il nome del file speciale per il terminale, come si trova in [.filename]#/dev#.
* Il secondo campo è il comando da eseguire per questa linea, generalmente man:getty[8]. `getty` inizializza ed apre la linea, imposta la velocità, richiede all'utente un nome di login e poi esegue il programma man:login[1].Il programma `getty` accetta un parametro (opzionale) da riga di comando, il tipo di _getty_. Un tipo di _getty_ configura le caratteristiche della linea del terminale, come la frequenza di bit per secondo e la parità. Il programma `getty` legge questa caratteristiche dal file [.filename]#/etc/gettytab#.Il file [.filename]#/etc/gettytab# contiene molte voci per le linee di terminale sia vecchie che nuove. In quasi tutti i casi, le voci che cominciano per `std` funzioneranno con i terminali connessi fisicamente. Queste voci ignorano la parità. C'è una voce `std` per ogni frequenza di bps da 110 a 115200. Naturalmente, puoi aggiungere le tue voci a questo file. La pagina man di man:gettytab[5] fornisce maggiori informazioni.Nell'impostare il tipo di _getty_ nel file [.filename]#/etc/ttys#, assicurati che le impostazioni di comunicazione sul terminale corrispondano.Nel nostro esempio, il Wyse-50 non usa parità e si connette a 38400 bps. Il PC 286 non usa parità e si connette a 19200 bps.
* Il terzo campo è il tipo di terminale generalmente collegato alla linea tty. Per le porte dial-up, viene usato tipicamente `unknown` o `dialup` poiché gli utenti possono collegarsi con praticamente qualunque tipo di terminale o programma. Per i terminali connessi direttamente, il tipo di terminale non cambia, quindi puoi mettere un vero tipo di terminale preso dal file database di man:termcap[5] in questo campo.Per il nostro esempio, il Wyse-50 usa il tipo per il vero terminale mentre il PC 286 con Procomm in esecuzione verrà impostato per emulare un VT-100.
* Il quarto campo specifica se la porta deve essere abilitata. Scrivere `on` qui farà sì che il processo `init` avvii il programma nel secondo campo, `getty`. Se metti `off` in questo campo, non ci sarà nessun `getty`, e dunque nessun login sulla porta.
* Il campo finale è usato per specificare se la porta è sicura. Segnare una porta come sicura significa confidare nel fatto che non ci sia rischio nel permettere all'account di `root` (o ad un altro con user ID uguale a 0) di effettuare il login da quella porta. Porte insicure non permettono il login a `root`. Su una porta insicura, gli utenti devono effettuare un login con accesso non privilegiato, e poi usare man:su[1] o un meccanismo simile per ottenere privilegi superiori.È fortemente consigliato l'uso di "insecure" anche per i terminali che si trovano dietro porte chiuse a chiave. È abbastanza semplice effettuare il login e usare `su` se si ha bisogno di privilegi da superutente.
====

[[term-hup]]
==== Come Forzare `init` a Rileggere [.filename]#/etc/ttys#

Dopo aver effettuato i cambiamenti necessari al file [.filename]#/etc/ttys# si deve mandare un segnale SIGHUP (hangup) al processo `init` affinché sia costretto a rileggere il suo file di configurazione. Ad esempio:

[source,shell]
....
# kill -HUP 1
....

[NOTE]
====
`init` è sempre il primo processo eseguito su un sistema dunque avrà sempre PID 1.
====

Se tutto è stato impostato correttamente, tutti i cavi sono collegati, ed i terminali sono accesi, allora un processo `getty` dovrebbe essere in esecuzione su ogni terminale e a questo punto dovresti vedere dei prompt per il login sui tuoi terminali.

[[term-debug]]
=== Risoluzione dei Problemi di Connessione

Anche con la più meticolosa attenzione ai dettagli, qualcosa potrebbe comunque andare storto nell'impostazione di un terminale. Questa è una lista dei sintomi e di alcuni suggerimenti per risolverli.

==== Non Appare Nessun Prompt per il Login

Assicurati che il terminale sia connesso e acceso. Se è un personal computer che funziona da terminale, assicurati che il programma di emulazione di terminale sia attivo sulla porta seriale giusta.

Assicurati che il cavo sia ben connesso sia al terminale che al computer FreeBSD. Assicurati che sia il giusto tipo di cavo.

Assicurati che il terminale e FreeBSD siano concordi sul valore di bps e sulle impostazioni di parità. Se hai un terminale con un display video, assicurati che il contrasto e la luminosità siano giusti. Se è un terminale di stampa, assicurati che ci siano carta e inchiostro sufficienti.

Assicurati che il processo `getty` sia attivo per quel terminale. Ad esempio, per avere una lista dei processi `getty` con `ps`, scrivi:

[source,shell]
....
# ps -axww | grep getty
....

dovresti vedere una voce per il terminale. Ad esempio, la schermata seguente mostra che `getty` è in esecuzione sulla seconda porta seriale `ttyd1` e sta usando la voce `std.38400` in [.filename]#/etc/gettytab#:

[source,shell]
....
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1
....

Se non c'è nessun processo `getty` in esecuzione, assicurati di aver abilitato la porta in [.filename]#/etc/ttys#. Ricordati anche di eseguire `kill -HUP 1` dopo aver modificato il file [.filename]#ttys#.

Se il processo `getty` è attivo ma il terminale non mostra ancora un prompt di login, o se mostra un prompt ma non ti permette di digitare nulla, il tuo terminale o il tuo cavo potrebbero non supportare la transazione hardware. Prova a cambiare il valore in [.filename]#/etc/ttys# da `std.38400` a `3wire.38400` (e ricordati di dare un `kill -HUP 1` dopo aver modificato [.filename]#/etc/ttys#). La voce `3wire` è simile a `std`, ma ignora l'handshake hardware. Potresti aver bisogno di ridurre i baud o di abilitare un controllo di flusso software usando `3wire` per evitare dei buffer overflow.

==== Compaiono Caratteri Strani Invece di un Prompt di Login

Assicurati che il terminale e FreeBSD siano concordi sui bps e sulle impostazioni di parità. Verifica i processi `getty` per assicurarti che sia in funzione il tipo corretto di _getty_. Se non è così, modifica [.filename]#/etc/ttys# ed esegui `kill -HUP 1`.

==== I Caratteri Appaiono Duplicati; la Password Viene Visualizzata Quando la Scrivo

Cambia l'impostazione del terminale (o del programma di emulazione) da "half duplex" o "local echo" a "full duplex".

[[dialup]]
== Servizio di Ricezione Chiamate

La configurazione del sistema FreeBSD per il servizio di ricezione chiamate è molto simile alla connessione di terminali tranne per il fatto che si ha a che fare con dei modem invece che con dei terminali.

=== Modem Esterni contro Modem Interni

I modem esterni sembrerebbero migliori per chiamare, poiché i modem esterni spesso possono essere configurati in maniera semipermanente tramite dei parametri immagazzinati in RAM non volatile e generalmente forniscono degli indicatori luminosi che mostrano lo stato degli importanti segnali RS-232. Le lucine lampeggianti impressionano gli ospiti, ma sono anche molto utili per vedere se un modem sta funzionando in maniera appropriata.

I modem interni in genere mancano della RAM non-volatile, quindi la loro configurazione può essere limitata solo impostando i DIP switch. Se il tuo modem interno ha delle luci indicatrici di segnale, probabilmente è difficile vederle quando il case del sistema è al suo posto.

==== Modem e Cavi

Se stai usando un modem esterno, allora avrai bisogno del cavo appropriato. Un cavo seriale standard RS-232C dovrebbe essere sufficiente, posto che tutti i normali segnali siano connessi:
[[serialcomms-signal-names]]
.Nomi dei Segnali
[cols="1,1", frame="none", options="header"]
|===
<| Acronimi
<| Nomi

|RD
|Ricezione Dati

|TD
|Trasmissione Dati

|DTR
|Terminale di Dati Disponibile

|DSR
|Pronto alla Trasmissione

|DCD
|Data Carrier Detect (scopre il Segnale di Linea di Ricezione di RS-232)

|SG
|Segnale di Massa

|RTS
|Richiesta alla Trasmissione

|CTS
|Disponibile all'Invio
|===

FreeBSD necessita dei segnali RTS e CTS per il controllo di flusso a velocità superiori a 2400 bps, del segnale CD per identificare quando c'è stata una risposta alla chiamata o quando una linea è stata scollegata, e del segnale DTR per dare il reset al modem dopo che una sessione è terminata. Alcuni cavi sono connessi senza alcuni dei segnali necessari, dunque se hai dei problemi, come una sessione di login che non scompare quando la linea è sconnessa, potresti avere un problema col cavo.

Come altri sistemi operativi UNIX(R), FreeBSD usa i segnali hardware per scoprire quando una chiamata è stata accettata o quando una linea è stata scollegata e per scollegare e resettare il modem dopo una chiamata. FreeBSD evita di mandare comandi al modem o di leggere i valori riportati dal modem. Se hai familiarità con la connessione dei modem a BBS di PC, questo potrebbe sembrarti scomodo.

=== Considerazioni sull'Interfaccia Seriale

FreeBSD supporta interfacce di comunicazione EIA RS-232C (CCITT V.24) basate su NS8250, NS16450, NS16550, e NS16550A. I dispositivi 8250 e 16450 hanno buffer di un singolo carattere. Il dispositivo 16550 fornisce un buffer di 16 caratteri, che permette prestazioni del sistema migliori. (Dei bug nel normale 16550 impediscono l'uso del buffer di 16 caratteri, quindi usate 16550A se possibile). A causa del buffer a singolo carattere questi dispositivi richiedono un lavoro maggiore da parte del sistema operativo rispetto ai dispositivi a 16 caratteri di buffer, le schede d'interfaccia seriale basate su 16550A sono preferibili. Se il sistema ha molte porte seriali attive o dovrà sopportare un grosso carico, le schede basate su 16550A sono migliori per comunicazioni a basso tasso d'errore.

=== Breve Panoramica

Come con i terminali, `init` lancia un processo `getty` per ogni porta seriale configurata per connessioni in ingresso. Ad esempio, se un modem è connesso a [.filename]#/dev/ttyd0#, il comando `ps ax` mostrerà questo:

[source,shell]
....
4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0
....

Quando un utente chiama la linea del modem e questo si collega, il modem riporterà la linea CD (Carrier Detect). Il kernel nota che la portante è stata rilevata e completa l'apertura della porta con `getty`. `getty` invia un prompt `login:` alla velocità iniziale di linea specificata. `getty` aspetta per verificare che vengano ricevuti caratteri legittimi, e, in una tipica configurazione, se trova dei caratteri strani (probabilmente perché la velocità del modem è differente da quella di `getty`), `getty` cerca di calibrare la velocità di linea fino a ricevere dei caratteri ragionevoli.

Dopo che l'utente ha inserito il suo nome di login, `getty` esegue [.filename]#/usr/bin/login#, che completa il login richiedendo la password per l'utente ed avviandone la shell.

=== File di Configurazione

Ci sono tre file di configurazione di sistema nella directory [.filename]#/etc# che avrai probabilmente bisogno di modificare per permettere chiamate in ingresso sul tuo sistema FreeBSD. Il primo, [.filename]#/etc/gettytab#, contiene le informazioni di configurazione per il demone [.filename]#/usr/libexec/getty#. Il secondo, [.filename]#/etc/ttys# contiene le informazioni che dicono a [.filename]#/sbin/init# quali dispositivi [.filename]#tty# devono avere processi `getty` in esecuzione. Infine, si possono mettere comandi di inizializzazione nello script [.filename]#/etc/rc.d/serial#.

Ci sono due scuole di pensiero riguardo i modem su UNIX(R). Un gruppo preferisce configurare i propri modem in maniera che qualunque sia la velocità con la quale un utente remoto si collega, l'interfaccia locale RS-232 computer-modem funzioni ad una velocità fissa. Il beneficio di questa configurazione è che l'utente remoto vede sempre un prompt di login immediato. Il lato negativo è che il sistema non sa quale sia la vera velocità di trasmissione dati di un utente, quindi programmi a tutto schermo come Emacs non modificheranno i loro metodi di rappresentazione dello schermo per ottimizzare la risposta su connessioni lente.

L'altra scuola di pensiero configura le proprie interfacce RS-232 verso il modem per variare la propria velocità rispetto a quella di connessione dell'utente remoto. Ad esempio, le connessioni V.32bis (14.4 Kbps) faranno sì che il modem faccia funzionare la propria interfaccia RS-232 a 19.2 Kbps, mentre le connessioni a 2400 bps faranno sì che funzioni a 2400 bps. Poiché `getty` non comprende nessun valore restituito dal modem riguardo la velocità di connessione, `getty` darà un messaggio `login:` ad una velocità iniziale fissata e aspetterà i caratteri in risposta. Se l'utente vede caratteri strani, si assume che sappia che dovrà premere Invio finché non vedrà un prompt riconoscibile. Se le frequenze di trasmissione non concordano, `getty` vedrà tutto ciò che l'utente preme come "spazzatura", cercherà di passare alla velocità seguente e invierà il prompt `login:` di nuovo. Questa procedura potrebbe continuare ad nauseam, ma normalmente ci vogliono solo una o due pressioni sui tasti prima che l'utente veda un buon prompt. Ovviamente, questa sequenza di login non è pulita come la precedente a "velocità fissata", ma un utente su una connessione a bassa velocità dovrebbe ricevere una risposta interattiva migliore da programmi a tutto schermo.

Questa sezione cercherà di fornire informazioni di configurazione bilanciate, ma è indirizzata verso l'approccio di avere la frequenza di trasmissione del modem che segue la velocità della connessione.

==== [.filename]#/etc/gettytab#

[.filename]#/etc/gettytab# è un file di configurazione sul modello di man:termcap[5] per man:getty[8]. Si prega di vedere la pagina man di man:gettytab[5] per le informazioni complete sul formato del file e la lista delle sue possibilità.

===== Configurazione a Velocità Fissa

Se stai fissando la frequenza di comunicazione del modem ad una velocità particolare, probabilmente non avrai bisogno di effettuare nessun cambiamento a [.filename]#/etc/gettytab#.

===== Configurazione a Velocità Concordata

C'è bisogno di impostare una voce in [.filename]#/etc/gettytab# per dare a `getty` le informazioni sulla velocità che si vuole usare per il modem. Se si possiede un modem a 2400 bps, probabilmente è possibile usare la voce `D2400` già esistente.

[.programlisting]
....
#
# Terminali chiamanti veloci, a rotazione 2400/1200/300
# (può impostarsi in tutti i modi)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:
....

Se si possiede un modem con velocità maggiore, probabilmente sarà necessario aggiungere una voce in [.filename]#/etc/gettytab#; qui c'è un esempio per modem a 14.4 Kbps modem con una velocità massima d'interfaccia di 19.2 Kbps:

[.programlisting]
....
#
# Aggiunte per un modem V.32bis
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

Questo risulterà in una connessione a 8-bit, senza parità.

L'esempio precedente avvia la comunicazione a 19.2 Kbps (per una connessione V.32bis), poi cicla tra 9600 bps (per V.32), 2400 bps, 1200 bps, 300 bps, e poi ancora a 19.2 Kbps. Il ciclo sulle frequenze di comunicazione è implementato con `nx=` ("next table"). Ogni linea usa una voce `tc=` ("table continuation") per continuare a leggere le impostazioni "standard" per una frequenza particolare.

Se hai un modem a 28.8 Kbps e/o vuoi avvantaggiarti della compressione su un modem a 14.4 Kbps, hai bisogno di usare una frequenza di comunicazione più alta di 19.2 Kbps. Qui c'è un esempio di voce per [.filename]#gettytab# che imposta la velocità a 57.6 Kbps:

[.programlisting]
....
#
# Aggiunte per modem  V.32bis o V.34 Modem
# Impostazione a 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

Se hai una CPU lenta o un carico di sistema pesante e non hai porte seriale 16550A, potresti ricevere errori `sio`"silo" a 57.6 Kbps.

[[dialup-ttys]]
==== [.filename]#/etc/ttys#

La configurazione del file [.filename]#/etc/ttys# è stata affrontata nella <<ex-etc-ttys>>. La configurazione dei modem è simile ma dobbiamo passare un argomento differente a `getty` e specificare un tipo di terminale differente. Il formato generale per la configurazione sia a velocità fissata che per quella concordata è:

[.programlisting]
....
ttyd0   "/usr/libexec/getty xxx"   dialup on
....

Il primo elemento nella linea precedente è il file di dispositivo per questa voce - `ttyd0` significa che [.filename]#/dev/ttyd0# è il file che verrà tenuto d'occhio da `getty`. Il secondo elemento, `"/usr/libexec/getty xxx"` (_xxx_ verrà rimpiazzato dalla capacità iniziale di [.filename]#gettytab#) è il processo che `init` eseguirà sul dispositivo. Il terzo elemento, `dialup`, è il tipo predefinito di terminale. Il quarto parametro, `on`, indica a `init` che quella linea è operativa. Potrebbe esserci un quinto parametro, `secure`, ma dovrebbe essere usato solo per i terminali che siano fisicamente sicuri (come la console di sistema).

Il tipo di terminale predefinito (`dialup` nell'esempio precedente) potrebbe dipendere dalle preferenze locali. `dialup` è il terminale tradizionale predefinito sulle linee di ingresso in maniera che gli utenti possano personalizzare i loro script di login per notare quando il terminale è `dialup` e modificare automaticamente il loro tipo di terminale. Ad ogni modo, l'autore ritiene più semplice specificare `vt102` come tipo di terminale predefinito, poiché l'utente può usare semplicemente un'emulazione VT102 sul suo sistema remoto.

Dopo aver effettuato i cambiamenti a [.filename]#/etc/ttys#, puoi inviare un segnale HUP a `init` per fargli rileggere il file. Puoi usare il comando 

[source,shell]
....
# kill -HUP 1
....

per inviare il segnale. Se questa è la prima volta che cambi le impostazioni del sistema, puoi aspettare finché il modem non sia configurato in maniera appropriata e connesso, prima di inviare il segnale a `init`.

===== Configurazione a Velocità Fissa

Per una configurazione a velocità fissa, la voce in [.filename]#ttys# ha bisogno di una voce che gestisca la velocità fissa anche per `getty`. Per un modem la cui velocità sulla porta sia bloccata a 19.2 Kbps, la voce in [.filename]#ttys# potrebbe essere così:

[.programlisting]
....
ttyd0   "/usr/libexec/getty std.19200"   dialup on
....

Se il tuo modem è bloccato su una frequenza di trasmissione differente, sostituisci il valore appropriato per `std.velocità` al posto di `std.19200`. Assicurati di usare un tipo valido elencato in [.filename]#/etc/gettytab#.

===== Configurazione a Velocità Concordata

In una configurazione a velocità concordata, la voce in [.filename]#ttys# deve fare riferimento alla voce iniziale "auto-baud" (sic) in [.filename]#/etc/gettytab#. Ad esempio, se hai aggiunto la riga suggerita precedentemente per un modem con velocità variabile che inizi a 19.2 Kbps (la riga in [.filename]#gettytab# contenente il punto d'avvio `V19200`), la riga in [.filename]#ttys# potrebbe essere questa:

[.programlisting]
....
ttyd0   "/usr/libexec/getty V19200"   dialup on
....

==== [.filename]#/etc/rc.d/serial#

I modem ad alta velocità, come i V.32, i V.32bis, e i V.34, necessitano di un controllo di flusso hardware (`RTS/CTS`). Puoi aggiungere dei comandi `stty` al file [.filename]#/etc/rc.d/serial# per impostare i flag di controllo di flusso nel kernel FreeBSD per le porte del modem.

Ad esempio per impostare il flag `termios``crtscts` sui dispositivi di inizializzazione di ingresso e uscita della porta seriale numero 1 ([.filename]#COM2#), si possono aggiungere le seguenti linee a [.filename]#/etc/rc.d/serial#:

[.programlisting]
....
# Configurazione iniziale della porta seriale
stty -f /dev/ttyd1.init crtscts
stty -f /dev/cuad1.init crtscts
....

=== Impostazioni del Modem

Se hai uno di quei modem i cui parametri possono essere impostati in maniera permanente in RAM non volatile, avrai bisogno di usare un programma terminale (come Telix su MS-DOS(R) o `tip` sotto FreeBSD) per impostare i parametri. Collegati al modem usando le stesse velocità iniziali e di comunicazione che userebbe `getty` e configura la RAM non volatile secondo queste necessità:

* CD attivo per la connessione
* DTR attivo per l'operazione; l'assenza del DTR porta allo scollegamento della linea e al reset del modem
* CTS controllo di flusso dei dati trasmessi
* Disabilita il controllo di flusso XON/XOFF
* RTS controllo di flusso dei dati ricevuti
* Modalità silenziosa (nessun codice di risposta)
* Nessun echo dei comandi

Leggi la documentazione del tuo modem per capire quali comandi e/o impostazioni per i DIP switch sia necessario fornirgli.

Ad esempio, per impostare i parametri precedenti su un U.S. Robotics(R) Sportster(R) 14.400 esterno, si potrebbero dare questi comandi al modem:

[.programlisting]
....
ATZ
AT&C1&D2&H1&I0&R2&W
....

Potresti anche sfruttare questa opportunità per raffinare le impostazioni del modem, ad esempio per decidere se dovrà usare V.42bis e/o la compressione MNP5.

Il modem esterno U.S. Robotics(R) Sportster(R) 14.400 ha anche dei DIP switch che devono essere impostati; per altri modem, forse potrai usare queste impostazioni come esempio:

* Switch 1: SU - DTR Normale
* Switch 2: N/D (Codici di Risposta Verbali/Codici di Risposta Numerici
* Switch 3: SU - Sopprime i Codici di Risposta
* Switch 4: GIÙ - Nessun echo, comandi offline 
* Switch 5: SU - Auto risposta
* Switch 6: SU - Carrier Detect Normale
* Switch 7: SU - Carica i valori predefiniti dall'NVRAM
* Switch 8: N/D (Modalità intelligente/modalità stupida)

I codici di risposta dovrebbero essere disabilitati/soppressi per i modem chiamanti per evitare i problemi che possono capitare se `getty` dà incidentalmente un prompt `login:` ad un modem che si trova in modalità di comando ed il modem restituisce l'eco del comando o un codice di risposta. Questa sequenza può portare ad una lunga, stupida conversazione tra `getty` ed il modem.

==== Configurazione a Velocità Fissa

Per una configurazione a velocità fissa, avrai bisogno di configurare il modem affinché mantenga una frequenza dati da modem a computer indipendente dalla frequenza di comunicazione. Su un modem esterno U.S. Robotics(R) Sportster(R) 14.400 questi comandi bloccheranno la velocità dati tra modem e computer alla velocità con la quale i comandi sono stati inviati:

[.programlisting]
....
ATZ
AT&B1&W
....

==== Configurazione a Velocità Concordata

Per una configurazione a velocità concordata, sarà necessario configurare il modem affinché modifichi la frequenza dei dati della porta seriale relativamente alla velocità di arrivo. Su un modem esterno U.S. Robotics(R) Sportster(R) 14.400, questi comandi causeranno il blocco della frequenza di trasmissione dati con correzione d'errore del modem sulla velocità con il quale è stato inviato il comando, ma permetteranno variazioni della velocità della porta seriale per le connessioni senza correzione d'errore:

[.programlisting]
....
ATZ
AT&B2&W
....

==== Verifica della Configurazione del Modem

La maggior parte dei modem ad alta velocità fornisce comandi per verificare i parametri funzionali usati dal modem in maniera più o meno comprensibile. Sui modem esterni U.S. Robotics(R) Sportster(R) 14.400, il comando `ATI5` mostra le impostazioni che sono immagazzinate nella RAM non volatile. Per vedere i veri parametri operativi del modem (così come vengono influenzati dai DIP switch del modem), usa i comandi `ATZ` e `ATI4`.

Se hai modem di marche differenti, verifica il manuale del tuo modem per vedere come sia possibile un ulteriore controllo sui parametri di configurazione del modem.

=== Risoluzione dei Problemi

Questi sono un po' di passi che è possibile seguire per verificare il funzionamento del modem sul tuo sistema.

==== Verifica del Sistema FreeBSD

Collega il modem al sistema FreeBSD, avvia il sistema, e, se il tuo modem ha luci di indicazione dello stato, guarda se la luce DTR del modem si accende quando appare il prompt `login:` sulla console del sistema - se si accende, dovrebbe significare che FreeBSD ha avviato un processo `getty` sulla porta di comunicazione appropriata e sta aspettando una chiamata dal modem.

Se l'indicatore DTR non lampeggia, effettua il login sul sistema FreeBSD dalla console e dai il comando `ps ax` per verificare se FreeBSD sta cercando di eseguire un processo `getty` sulla porta corretta. Dovresti vedere linee come queste tra i processi mostrati:

[source,shell]
....
114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1
....

Se vedi qualcosa di diverso, come questo:

[source,shell]
....
114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0
....

ed il modem non ha ancora accettato chiamate, ciò significa che `getty` ha completato l'apertura della porta di comunicazione. Questo potrebbe indicare un problema nei cavi o un modem mal configurato, poiché `getty` non dovrebbe completare l'apertura della porta fino al rilevamento del segnale CD (carrier detect).

Se non vedi nessun processo `getty` in attesa sulla porta [.filename]#ttydN# scelta, ricontrolla le voci in [.filename]#/etc/ttys# per vedere se ci sono errori lì. Inoltre, controlla il file di log [.filename]#/var/log/messages# per vedere se ci sono messaggi di `init` o `getty` riguardo i loro problemi. Se ci sono messaggi, ri-ricontrolla i file di configurazione [.filename]#/etc/ttys# e [.filename]#/etc/gettytab#, ed anche i file speciali di dispositivo [.filename]#/dev/ttydN#, cercando ogni errore, voce mancante, o file di dispositivo mancante.

==== Tentativo di Connessione in Ingresso

Cerca di collegarti dall'esterno al sistema; assicurati di usare 8 bit, nessuna parità, e 1 bit di stop sul sistema remoto. Se non ottieni un prompt, o vengono visualizzati caratteri strani, prova a premere Invio circa una volta per secondo. Se dopo un po' ancora non vedi un prompt `login:`, prova inviare un'`INTERRUZIONE`. Se stai usando un modem ad alta velocità per effettuare la chiamata, prova a richiamare dopo aver bloccato la velocità dell'interfaccia del modem (tramite `AT&B1` su un U.S. Robotics(R) Sportster(R), ad esempio).

Se ancora non ottieni alcun prompt `login:`, verifica [.filename]#/etc/gettytab# ancora e ricontrolla che:

* La capacità iniziale specificata in [.filename]#/etc/ttys# per quella linea corrisponda a quella in [.filename]#/etc/gettytab#
* Ogni campo `nx=` corrisponda ad un valore in [.filename]#gettytab#
* Ogni campo `tc=` corrisponda a un altro nome di capacità in [.filename]#gettytab#

Se chiami ma il modem su FreeBSD non risponde, assicurati che il modem sia configurato per rispondere alla chiamata quando viene fornito un segnale DTR. Se il modem sembra essere configurato correttamente, verifica che la linea DTR sia attiva controllando gli indicatori luminosi del modem (se ne ha).

Se hai già controllato tutto quanto più volte ed ancora non funziona, fai una pausa e riprova in seguito. Se ancora non funziona puoi provare a inviare un messaggio di posta elettronica alla {freebsd-questions} descrivendo il tuo modem ed il tuo problema, e i bravi ragazzi della lista cercheranno di darti una mano.

[[dialout]]
== Servizio di Effettuazione Chiamate

I seguenti sono consigli per far sì che la tua macchina sia in grado di connettersi tramite modem ad un altro computer. Questo è appropriato per stabilire una sessione terminale con un host remoto.

Questo è utile per collegarsi ad una BBS.

Questo tipo di connessione può essere estremamente utile per ottenere un file da Internet se hai problemi con il PPP. Se hai bisogno di usare l'FTP ed il PPP non funziona, usa la sessione terminale per eseguire l'FTP. Poi usa zmodem per trasferire il file sulla tua macchina.

=== Il Mio Modem Hayes Stock Non È Supportato, Cosa Posso Fare?

Effettivamente, la pagina man di `tip` è un po' datata. C'è un compositore Hayes generico già integrato. Usa semplicemente `at=hayes` nel tuo [.filename]#/etc/remote# file.

Il driver Hayes non è abbastanza intelligente da riconoscere alcune delle caratteristiche avanzate dei nuovi modem-messaggi come `BUSY`, `NO DIALTONE`, o `CONNECT 115200` lo confonderanno e basta. Dovrai disattivare questi messaggi quando usate `tip` (usando `ATX0&W`).

Inoltre, il timeout di composizione per `tip` è di 60 secondi. Il tuo modem dovrebbe usare qualcosa di meno, altrimenti tip penserà che ci sia un problema di comunicazione. Prova `ATS7=45&W`.

[NOTE]
====
Come viene fornito, `tip` non supporta ancora i modem Hayes completamente. La soluzione è modificare il file [.filename]#tipconf.h# nella directory [.filename]#/usr/src/usr.bin/tip/tip#. Ovviamente avrai bisogno della distribuzione con i sorgenti per fare ciò.

Modifica la linea `#define HAYES 0` a `#define HAYES 1`. Poi dai i comandi `make` e `make install`. Tutto funziona bene dopo aver fatto questo.
====

[[direct-at]]
=== Come Dovrei Inserire Questi Comandi AT?

Inserisci quella che viene definita una voce "diretta" nel file [.filename]#/etc/remote#. Ad esempio, se il tuo modem è collegato alla prima porta seriale, [.filename]#/dev/cuad0#, allora inserisci la riga seguente:

[.programlisting]
....
cuad0:dv=/dev/cuad0:br#19200:pa=none
....

Usa la frequenza di bps più alta supportata dal tuo modem per il valore di br. Poi, digita `tip cuad0` e verrai connesso al tuo modem.

O usa `cu` come `root` con il seguente comando:

[source,shell]
....
# cu -llinea -s velocità
....

_linea_ è la porta seriale (es. [.filename]#/dev/cuad0#) e _velocità_ è la velocità (es. `57600`). Quando hai finito di inserire i comandi AT premi kbd:[~.] per uscire.

=== Il Simbolo `@` per il Valore pn Non Funziona!

Il simbolo `@` come valore del numero telefonico dice a tip di andare a cercare un numero telefonico in [.filename]#/etc/phones#. Ma il segno `@` è anche un carattere speciale nei file come [.filename]#/etc/remote#. Devi farne l'escape con un backslash:

[.programlisting]
....
pn=\@
....

=== Come Posso Chiamare Un Numero Telefonico Da Riga di Comando?

Metti una cosiddetta voce "generica" in [.filename]#/etc/remote#. Ad Esempio:

[.programlisting]
....
tip115200|Chiama un qualunque numero a 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Chiama un qualunque numero a 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:
....

Poi puoi fare una cosa simile:

[source,shell]
....
# tip -115200 5551234
....

Se preferisci `cu` a `tip`, usa una voce generica per `cu`:

[.programlisting]
....
cu115200|Usa cu per chiamare un numero qualsiasi a 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:
....

e digita:

[source,shell]
....
# cu 5551234 -s 115200
....

=== Devo Digitare La Frequenza di bps Ogni Volta Che lo Faccio?

Metti una voce per `tip1200` o `cu1200`, ma vai avanti e inserisci una qualunque frequenza di bps appropriata per il valore di br. `tip` pensa che un buon valore predefinito sia 1200 bps, motivo per cui cerca una voce per `tip1200`. Non sei obbligato a usare 1200 bps, comunque.

=== Accedo ad un Grande Numero di Host attraverso un Server di Terminali

Invece di aspettare fino ad essere connesso e poi digitare `CONNECT <host>` ogni volta, usa la funzionalità `cm` di tip. Ad esempio, queste voci in [.filename]#/etc/remote#:

[.programlisting]
....
pain|pain.deep13.com|La macchina di Forrester:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|La macchina di Frank:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Server di terminali del Gizmonics Institute:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

ti permetteranno di digitare `tip pain` o `tip muffin` per collegarti agli host pain o muffin, e `tip deep13` per il server di terminali.

=== Tip Può Provare Più di una Linea per ogni Sito?

Questo è spesso un problema quando una università ha molte linee di modem e molte migliaia di studenti cercano di usarle.

Inserisci una voce per la tua università in [.filename]#/etc/remote# e usa `@` per il campo `pn`:

[.programlisting]
....
big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:
....

Poi, elenca i numeri di telefono dell'università in [.filename]#/etc/phones#:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

`tip` proverà ognuno di questi secondo l'ordine, poi smetterà. Se vuoi continuare a riprovare, esegui `tip` in un ciclo while.

=== Perché Devo Premere kbd:[Ctrl+P] Due Volte per Inviare Un Solo kbd:[Ctrl+P]?

kbd:[Ctrl+P] è il carattere predefinito per "forzare", usato per dire a `tip` che il prossimo carattere è un dato letterale. Puoi impostare il carattere per forzare a qualsiasi altro carattere con il comando di escape `~s`, che significa "imposta una variabile".

Digita `~sforce=singolo-carattere` seguito da un ritorno a capo. _singolo-carattere_ è un qualsiasi carattere singolo. Se non date nessun _singolo-carattere_, allora il carattere per forzare sarà il carattere nullo, che è possibile ottenere premendo kbd:[Ctrl+2] o kbd:[Ctrl+Spazio]. Un valore abbastanza buono per il _singolo-carattere_ è kbd:[Shift+Ctrl+6], che è usato solo da alcuni server di terminali.

Potete far sì che il carattere per forzare sia un qualsiasi carattere vogliate specificando la riga seguente nel file [.filename]#$HOME/.tiprc#:

[.programlisting]
....
force=<singolo-carattere>
....

=== Improvvisamente Tutto Quello che Digito È in Maiuscolo??

Devi aver premuto kbd:[Ctrl+A], il "raise character", di `tip` progettato specificamente per le persone con il tasto caps-lock rotto. Usa `~s` come mostrato prima per impostare la variabile `raisechar` a qualcosa di ragionevole. In pratica, puoi impostarla allo stesso valore del carattere per forzare, se pensi di non usare mai queste due caratteristiche.

Qui c'è un file .tiprc di esempio per gli utenti Emacs che hanno bisogno di premere kbd:[Ctrl+2] e kbd:[Ctrl+A] molto spesso:

[.programlisting]
....
force=^^
raisechar=^^
....

Il carattere ^^ è kbd:[Shift+Ctrl+6].

=== Come Posso Trasferire File con `tip`?

Se stai parlando ad altri sistemi UNIX(R), puoi mandare e ricevere file con `~p` (put) e `~t` (take). Questi comandi eseguono `cat` ed `echo` sul sistema remoto per accettare e inviare file. La sintassi è:

`~p` file-locale [ file-remoto ]

`~t` file-remoto [ file-locale ]

non c'è controllo d'errore, quindi probabilmente dovresti usare un altro protocollo, come zmodem.

=== Come Posso Eseguire zmodem con `tip`?

Per ricevere file, avvia il programma di invio sul lato remoto. Poi, digita `~C rz` per iniziare a ricevere in locale.

Per inviare file, avvia il programma di ricezione sul lato remoto. Poi, digita `~C sz files` per inviarli sul sistema remoto.

[[serialconsole-setup]]
== Impostazione della Console Seriale

[[serialconsole-intro]]
=== Introduzione

FreeBSD ha la capacità di avviare un sistema con soltanto un terminale stupido su porta seriale come console. Una configurazione simile dovrebbe essere utile per due tipi di persone: amministratori di sistema che desiderano installare FreeBSD su macchine che non hanno tastiera o monitor connesso, e sviluppatori che vogliono effettuare il debug del kernel o dei driver.

Come descritto nel crossref:boot[boot,La Procedura di Avvio], FreeBSD implementa un avviamento composto da tre stadi. I primi due stadi sono nel blocco di avvio che viene immagazzinato all'inizio della slice di FreeBSD sul disco d'avvio. Il blocco di avvio poi carica ed avvia il loader ([.filename]#/boot/loader#) come terzo stadio.

Per poter impostare la console seriale devi configurare il codice del blocco di avvio, il codice del loader ed il kernel.

[[serialconsole-howto-fast]]
=== Configurazione della Console Seriale, Versione Essenziale

Questa sezione presuppone che stai usando una configurazione di default e vuoi solamente una veloce panoramica su come abilitare una console seriale.

[.procedure]
====
. Connetti il cavo seriale alla COM1 e al terminale.
. Per vedere tutti i messaggi di boot sulla console seriale, dai il comando seguente mentre sei loggato come superuser:
+
[source,shell]
....
# echo 'console="comconsole"' >> /boot/loader.conf
....
+
. Modifica il file [.filename]#/etc/ttys# e cambia `off` in `on` e `dialup` in `vt100` per l'entry `ttyd0`. Altrimenti non verrà chiesta la password per connettersi via console seriale, con il risultato di creare un potenziale buco di sicurezza.
. Riavvia il sistema per vedere se i cambiamenti funzionano.
====

Se si necessita di una diversa configurazione, esiste una spiegazione maggiormente dettagliata nella sezione <<serialconsole-howto>>.

[[serialconsole-howto]]
=== Configurazione della Console Seriale

[.procedure]
====
. Preparazione di un cavo seriale.
+ 
Avrai bisogno di un cavo null-modem o di un cavo seriale standard ed un adattatore null-modem. Guarda <<serial-cables-ports>> per una discussione sui cavi seriali.
. Scollegamento della tastiera.
+ 
La maggior parte dei sistemi PC verifica la presenza di una tastiera durante il Power-On Self-Test (POST) e dà un errore se la tastiera non viene rilevata. Alcune macchine si lamentano parecchio per la mancanza della tastiera e non proseguono l'avvio finché non viene collegata.
+ 
Se il tuo computer si lamenta per questo errore, ma si avvia lo stesso, allora non devi fare nulla di speciale. (Alcune macchine con BIOS Phoenix semplicemente dicono `Keyboard failed` e continuano ad avviarsi normalmente).
+ 
Se il tuo computer rifiuta di avviarsi senza la tastiera allora dovrai configurare il BIOS affinché ignori questo errore (se possibile). Consulta il manuale della tua scheda madre per maggiori dettagli su come fare ciò.
+
[TIP]
======

Imposta la tastiera su "Non installata" nel setup del BIOS. Sarai ancora in grado di usare la tastiera. Tutto quel che fa è dire al BIOS di non verificare la presenza di una tastiera all'accensione. Il tuo BIOS non dovrebbe segnalare che la tastiera non è collegata. Puoi lasciare la tastiera collegata anche con questa opzione impostata a "Non installata" e la tastiera funzionerà lo stesso.
======
+
[NOTE]
======
Se il tuo sistema ha un mouse PS/2(R), le possibilità di dover scollegare il mouse allo stesso modo della tastiera sono alte. Questo perché i mouse PS/2(R) condividono dell'hardware con la tastiera e lasciando il mouse collegato potresti ingannare la verifica della tastiera facendogli credere che sia ancora presente. Si dice che il sistema Gateway 2000 Pentium 90 MHz con BIOS AMI funzioni così. In generale, questo non è un problema perché il mouse non è comunque particolarmente utile senza la tastiera.
======
+
. Collegamento di un terminale stupido alla [.filename]#COM1# ([.filename]#sio0#).
+ 
Se non possiedi un terminale stupido, puoi usare un vecchio PC/XT con un programma per modem, o la porta seriale di un altra macchina UNIX(R). Se non hai una [.filename]#COM1# ([.filename]#sio0#), trovane una. Attualmente, non c'è altro modo di scegliere una porta diversa dalla [.filename]#COM1# per i blocco di avvio senza doverlo ricompilare. Se stai già usando la [.filename]#COM1# per un altro dispositivo, dovrai rimuoverlo temporaneamente ed installare un nuovo blocco di avvio ed un nuovo kernel una volta che FreeBSD sia funzionante. (Si assume che la [.filename]#COM1# sia sempre disponibile su un server di file/calcolo/terminali; se davvero hai bisogno della [.filename]#COM1# per qualcos'altro (e non puoi passare quel qualcosa alla [.filename]#COM2# ([.filename]#sio1#)), allora probabilmente non dovresti nemmeno avere a che fare con tutto questo in primo luogo).
. Assicurati che il file di configurazione del tuo kernel abbia i parametri appropriati impostati per la [.filename]#COM1# ([.filename]#sio0#).
+ 
I parametri rilevanti sono:
+

`0x10`:::
Abilita il supporto alla console per questa unità. Gli altri parametri di console sono ignorati se non è fissato questo. Attualmente, al massimo un'unità può avere il supporto alla console; verrà preferita la prima (secondo l'ordine nel file di configurazione) con questo parametro. Questa opzione non renderà la porta seriale la console. Imposta il parametro seguente o usa l'opzione `-h` descritta più in basso, insieme a questa impostazione.

`0x20`:::
Forza questa unità ad essere la console (a meno che sia presente un'altra console con priorità più alta), trascurando l'opzione `-h` discussa precedentemente. Il parametro `0x20` deve essere usato insieme al `0x10`.

`0x40`:::
Riserva questa unità (insieme a `0x10`) e rende l'unità indisponibile per l'accesso normale. Non dovresti impostare questo parametro sull'unità della porta seriale che desideri usare come console seriale. L'unico uso di questo parametro è per designare l'unità per il debug remoto del kernel. Guarda il extref:{developers-handbook}[Developer's Handbook] per maggiori informazioni sul debugging remoto.
+
[NOTE]
======
In FreeBSD 4.0 o successivo, la semantica del parametro `0x40` è leggermente differente e c'è un altro parametro per specificare una porta seriale per il debug remoto.
======
+ 
Esempio:
+
[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x10 irq 4
....
+ 
Guarda la pagina man man:sio[4] per maggiori dettagli.
+ 
Se i parametri non sono stati impostati, sarà necessario eseguire UserConfig (su una console differente) o ricompilare il kernel.
. Creazione di [.filename]#boot.config# nella directory radice della partizione `a` nel disco di avvio.
+ 
Questo file istruirà il codice del blocco di avvio su come vuoi avviare il sistema. Per poter attivare la console seriale, avrai bisogno di una o più delle seguenti opzioni-se vuoi opzioni multiple, includile tutte sulla stessa linea:
+
`-h`:::
Passa dalla console interna a quella seriale. Puoi usarla per cambiare i dispositivi console. Ad esempio, se avvii dalla console interna (video), puoi usare `-h` per dirigere il loader ed il kernel in modo che usino la porta seriale come dispositivo per la console. Alternativamente, se avvii da porta seriale, puoi usare l'opzione `-h` per dire al loader ed al kernel di usare lo schermo come console.

`-D`:::
Passa da una configurazione singola a una duplice. Nella configurazione singola la console sarà o quella interna (il display video) o la porta seriale, a seconda dello stato dell'opzione `-h` già descritta. Nella configurazione duplice, sia il display video che la porta seriale diventeranno la console allo stesso momento, senza curarsi dello stato dell'opzione `-h`. Ad ogni modo, nota che questa configurazione duplice ha effetto solo durante l'esecuzione del blocco di avvio. Una volta che il loader ha assunto il controllo, la console specificata da `-h` diventa l'unica.

`-P`:::
Fa sì che il blocco di avvio verifichi la presenza della tastiera. Se non ne viene rilevata nessuna, le opzioni `-D` e `-h` vengono impostate automaticamente.
+
[NOTE]
======
A causa delle costrizioni relative allo spazio nelle versioni attuali del blocco di avvio, l'opzione `-P` è in grado di riconoscere solo le tastiere estese. Le tastiere con meno di 101 tasti (e senza i tasti F11 e F12) potrebbero non essere rilevate. Le tastiere su alcuni computer portatili potrebbero non essere rilevate a causa di questa limitazione. Se questo è il caso del tuo sistema, devi abbandonare l'opzione `-P`. Sfortunatamente non c'è nessun metodo per aggirare questo problema.
======
+ 
Usa l'opzione `-P` per selezionare la console automaticamente, o l'opzione `-h` per attivare la console seriale.
+ 
Puoi includere altre opzioni come descritte in man:boot[8].
+ 
Le opzioni, eccetto `-P`, verranno passate al loader ([.filename]#/boot/loader#). Il loader determinerà quale tra il video interno o la console seriale debba diventare la console esaminando lo stato dell'opzione `-h`. Ciò significa che se specifichi l'opzione `-D` ma non la `-h` in [.filename]#/boot.config#, puoi usare la porta seriale come console soltanto durante l'esecuzione del blocco di avvio; il loader userà il video interno come console.
. Avviamento della macchina.
+ 
Quando avvii la tua macchina FreeBSD, il blocco di avvio scriverà il contenuto di [.filename]#/boot.config# sulla console. Ad esempio:
+
[source,shell]
....
/boot.config: -P
Keyboard: no
....
+ 
La seconda linea appare solo se metti l'opzione `-P` in [.filename]#/boot.config# ed indichi la presenza/assenza della tastiera. Questo messaggio va alla console seriale o a quella interna, o a entrambe, a seconda dell'opzione in [.filename]#/boot.config#.
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
<| Opzioni
<| I messaggi vanno a

|nessuna
|console interna

|`-h`
|console seriale

|`-D`
|console seriale ed interna

|`-Dh`
|console seriale ed interna

|`-P`, tastiera presente
|console interna

|`-P`, tastiera assente
|console seriale
|===
+ 
Dopo i messaggi precedenti, ci sarà una piccola pausa prima che il blocco di avvio continui nel caricamento del loader e prima che ulteriori messaggi vengano scritti sulla console. In circostanze normali, non hai necessità di interrompere il blocco di avvio, ma potresti volerlo fare per verificare che tutto sia impostato correttamente.
+ 
Premi un tasto qualsiasi, differente da Invio, alla console per interrompere il processo di avvio. Il blocco di avvio aspetterà ulteriori azioni. Dovresti vedere qualcosa del genere:
+
[source,shell]
....
>> FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....
+ 
Verifica se il messaggio precedente appare sulla console seriale o su quella interna o su entrambe, secondo le opzioni poste in [.filename]#/boot.config#. Se il messaggio appare nella console corretta, premi Invio per continuare il processo di avvio.
+ 
Se vuoi la console seriale ma non riesci a vedere il prompt sul terminale seriale, qualcosa è sbagliato nelle tue impostazioni. Nel frattempo, scrivi `-h` e premi Invio (se possibile) per dire al blocco di avvio (e al loader e al kernel) di scegliere la porta seriale per la console. Una volta che il sistema è attivo, torna indietro e verifica cosa è andato storto.
====

Dopo che il loader è stato caricato e ti trovi nel terzo stadio del processo di avvio puoi ancora passare dalla console interna alla console seriale impostando le variabili d'ambiente appropriate nel loader. Guarda la <<serialconsole-loader>>.

[[serialconsole-summary]]
=== Sommario

Qui c'è il sommario delle varie impostazioni discusse in questa sezione e la console eventualmente selezionata.

==== Caso 1: Imposti il Flag 0x10 per [.filename]#sio0#

[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x10 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
<| Opzioni in /boot.config
<| Console durante i blocco di avvio
<| Console durante il loader
<| Console nel kernel

|niente
|interna
|interna
|interna

|`-h`
|seriale
|seriale
|seriale

|`-D`
|seriale ed interna
|interna
|interna

|`-Dh`
|seriale ed interna
|seriale
|seriale

|`-P`, tastiera presente
|interna
|interna
|interna

|`-P`, tastiera assente
|seriale ed interna
|seriale
|seriale
|===

==== Caso 2: Imposti il Flag 0x30 per sio0

[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x30 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
<| Opzioni in /boot.config
<| Console durante i blocco di avvio
<| Console durante il loader
<| Console nel kernel

|niente
|interna
|interna
|seriale

|`-h`
|seriale
|seriale
|seriale

|`-D`
|seriale ed interna
|interna
|seriale

|`-Dh`
|seriale ed interna
|seriale
|seriale

|`-P`, tastiera presente
|interna
|interna
|seriale

|`-P`, tastiera assente
|seriale ed interna
|seriale
|seriale
|===

[[serialconsole-tips]]
=== Consigli per una Console Seriale

==== Impostazione di una Velocità Maggiore della Porta Seriale

Di default, le impostazioni della porta seriale sono: 9600 baud, 8 bit, nessuna parità, ed 1 bit di stop. Se desideri cambiare la velocità, avrai bisogno di ricompilare almeno il blocco di avvio. Aggiungi la linea seguente a [.filename]#/etc/make.conf# e compila il nuovo blocco di avvio:

[.programlisting]
....
BOOT_COMCONSOLE_SPEED=19200
....

Guarda <<serialconsole-com2>> per istruzioni dettagliate su come costruire e installare nuovi blocchi di avvio.

Se la console seriale è configurata in qualche altra maniera invece di essere selezionata all'avvio con `-h`, o se la console seriale usata dal kernel è differente da quella usata dal blocco di avvio, allora dovrai aggiungere anche le opzioni seguenti al file di configurazione del kernel e compilare un nuovo kernel:

[.programlisting]
....
options CONSPEED=19200
....

[[serialconsole-com2]]
==== Utilizzo di una Porta Seriale Differente da [.filename]#sio0# per la Console

Usare una porta seriale differente da [.filename]#sio0# come console richiede un po' di ricompilazione. Se vuoi usare un'altra porta seriale per qualche motivo, ricompila il blocco di avvio, il loader ed il kernel come segue.

[.procedure]
====

. Ottieni i sorgenti del kernel. (Guarda il crossref:cutting-edge[cutting-edge,Lo Stato dell'Arte])
. Modifica [.filename]#/etc/make.conf# e imposta `BOOT_COMCONSOLE_PORT` all'indirizzo della porta che vuoi usare (0x3F8, 0x2F8, 0x3E8 o 0x2E8). Solo i dispositivi da [.filename]#sio0# a [.filename]#sio3# ([.filename]#COM1# a [.filename]#COM4#) possono essere usati; le schede seriali multiporta non funzioneranno. Non sono necessarie impostazioni per gli interrupt.
. Crea un file di configurazione del kernel personalizzato e aggiungi i flag appropriati per la porta seriale che intendi usare. Ad esempio, se vuoi fare di [.filename]#sio1# ([.filename]#COM2#) la console:
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 flags 0x10 irq 3
....
+ 
o
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 flags 0x30 irq 3
....
+ 
I flag di console per le altre porte seriali non dovrebbero essere impostati.
. Ricompila ed installa il blocco di avvio ed il loader:
+
[source,shell]
....
# cd /sys/boot
# make clean
# make
# make install
....
+
. Ricompila ed installa il kernel.
. Scrivi il blocco di avvio sul disco di avvio con man:disklabel[8] ed avvia con il nuovo kernel.
====

[[serialconsole-ddb]]
==== Accesso al Debugger DDB dalla Linea Seriale

Se desideri entrare nel debugger del kernel dalla console seriale (utile per diagnostiche remote, ma anche molto pericoloso se generi un BREAK spurio sulla porta seriale!) allora dovrai compilare il tuo kernel con le opzioni seguenti:

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....

==== Come Ottenere un Prompt di Login sulla Console Seriale

Anche se questo non è necessario, potresti desiderare un prompt di _login_ sulla linea seriale, ora che puoi vedere i messaggi di avvio e puoi accedere a sessioni di debug del kernel attraverso la console seriale. Qui è spiegato come fare.

Apri il file [.filename]#/etc/ttys# con un editor e trova queste linee:

[.programlisting]
....
ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure
....

I dispositivi da `ttyd0` a `ttyd3` corrispondono a [.filename]#COM1# fino a [.filename]#COM4#. Cambia `off` a `on` per la porta desiderata. Se hai cambiato la velocità della porta seriale, dovrai cambiare `std.9600` affinché corrisponda all'impostazione corrente, ad es. `std.19200`.

Potresti anche desiderare cambiare il tipo di terminale da `unknown` al tipo effettivo del tuo terminale seriale.

Dopo avere modificato il file, devi dare un `kill -HUP 1` affinché i cambiamenti abbiano effetto.

[[serialconsole-loader]]
=== Cambiamento della Console dal Loader

Le sezioni precedenti hanno descritto come impostare la console seriale lavorando sul blocco di avvio. Questa sezione mostra come specificare a console inserendo alcuni comandi ed alcune variabili di ambiente nel loader. Quando il loader verrà invocato al terzo stadio del processo di avvio, dopo il blocco di avvio, le impostazioni nel loader prenderanno il posto di quelle nel blocco di avvio.

==== Impostazione della Console Seriale

Puoi facilmente specificare al loader ed al kernel di usare la console seriale scrivendo una sola riga in [.filename]#/boot/loader.rc#:

[.programlisting]
....
set console="comconsole"
....

Ciò sarà efficace in ogni caso, qualunque siano le impostazioni nel blocco di avvio discusse nella sezione precedente.

Sarebbe meglio mettere la linea precedente come prima linea di [.filename]#/boot/loader.rc# in modo da vedere i messaggi sulla console seriale il prima possibile.

Altrimenti, puoi specificare la console interna come:

[.programlisting]
....
set console="vidconsole"
....

Se non imposti la variabile di ambiente `console` del loader, quest'ultimo, e conseguentemente anche il kernel, useranno una console qualunque indicata dall'opzione `-h` nel blocco di avvio.

Nelle versioni 3.2 o successive, è possibile specificare la console in [.filename]#/boot/loader.conf.local# o [.filename]#/boot/loader.conf#, piuttosto che in [.filename]#/boot/loader.rc#. Con questo metodo il tuo [.filename]#/boot/loader.rc# dovrebbe apparire così:

[.programlisting]
....
include /boot/loader.4th
start
....

Poi, crea [.filename]#/boot/loader.conf.local# ed aggiungi lì la linea seguente.

[.programlisting]
....
console=comconsole
....

o

[.programlisting]
....
console=vidconsole
....

Guarda man:loader.conf[5] per maggiori informazioni.

[NOTE]
====
Al momento il loader non ha un'opzione equivalente alla `-P` del blocco di avvio, e non c'è possibilità di scegliere automaticamente la console interna e la console seriale basandosi sulla presenza di una tastiera.
====

==== Utilizzo di una Porta Seriale Diversa da [.filename]#sio0# per la Console

Sarà necessario ricompilare il loader per usare una porta seriale differente da [.filename]#sio0# per la console seriale. Segui la procedura descritta nella <<serialconsole-com2>>.

[[serialconsole-caveats]]
=== Avvertimento

L'idea di tutto questo è di permettere alla gente di mettere su server dedicati che non abbiano bisogno di hardware grafico o di tastiere. Sfortunatamente, mentre la maggior parte dei sistemi ti permetteranno di avviare senza tastiera, ce ne sono alcuni che non ti permetteranno di partire senza un adattatore grafico. Le macchine con BIOS AMI possono essere configurate per partire senza adattatori grafici cambiando semplicemente il valore di "graphics adapter" nella configurazione CMOS a "Not installed".

Ad ogni modo, molte macchine non supportano questa opzione e si rifiuteranno di avviarsi se non si ha hardware grafico nel sistema. Con queste macchine, avrai bisogno di lasciare un qualche tipo di scheda grafica attaccata, (anche una scheda monocromatica di recupero) sebbene non avrai necessità di collegare un monitor. Potresti anche tentare di installare un BIOS AMI.
