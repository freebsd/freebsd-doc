---
title: Capitolo 8. Configurazione del Kernel di FreeBSD
part: Parte II. Compiti Ordinari
prev: books/handbook/multimedia
next: books/handbook/printing
showBookMenu: true
weight: 11
path: "/books/handbook/kernelconfig/"
---

[[kernelconfig]]
= Configurazione del Kernel di FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 8
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/kernelconfig/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[kernelconfig-synopsis]]
== Synopsis

Il kernel è una componente fondamentale del sistema operativo FreeBSD. È responsabile di gestire la memoria, applicare controlli di sicurezza, gestire la rete, accesso ai dischi e molto altro. Anche se sempre più parti di FreeBSD diventano configurabili dinamicamente, è ancora necessario talvolta riconfigurare e ricompilare il kernel.

Dopo aver letto questo capitolo, saprai:

* Perchè potresti aver bisogno di ricompilare un kernel.
* Come scrivere un file di configurazione del kernel, o come alterarne uno esistente.
* Come usare il file di configurazione del kernel per creare un nuovo kernel.
* Come installare il nuovo kernel.
* Come fare del troubleshooting se qualcosa va storto.

Tutti i comandi elencati in questo capitolo negli esempi dovrebbero essere eseguiti come `root` affinchè abbiano successo.

[[kernelconfig-custom-kernel]]
== Perchè creare un kernel custom?

Tradizionalmente, FreeBSD ha sempre avuto quello che si chiama un kernel "monolitico". Questo significa che il kernel era un programma di grandi dimensioni, supportava una lista fissa di device, e se tu avessi voluto cambiare il comportamento del kernel avresti dovuto compilarne uno nuovo, quindi fare il reboot del tuo computer per caricare il nuovo kernel.

Oggi come oggi, FreeBSD si sta muovendo rapidamente verso un modello dove gran parte delle funzionalità del kernel sono contenute in moduli che possono essere caricati e scaricati dal kernel a seconda delle necessità. Questo permette al kernel di adattarsi a nuovo hardware appena questo diventa disponibile (come ad esempio le carte PCMCIA in un laptop), oppure fa sì che nuove funzionalità siano portate nel kernel, funzionalità che non erano necessarie quando il kernel fu compilato inizialmente. Questo è noto come kernel modulare.

Nonostante questo, è ancora necessario portare avanti delle compilazioni statiche del kernel. In alcuni casi questo è necessario perchè la funzionalità è così legata al kernel che non può essere resa caricabile dinamicamente. In altri casi può essere necessario semplicemente perchè nessuno si è ancora preso il tempo di scrivere un modulo caricabile dinamicamente per quella funzionalità.

Compilare un kernel custom è uno dei più comuni riti di passaggio che quasi ogni utente BSD deve superare. Questo processo, anche se è dispendioso di tempo, offrirà molti benefici al tuo sistema FreeBSD. A differenza del kernel [.filename]#GENERIC#, che deve supportare un gran numero di dispositivi hardware, un kernel custom contiene supporto solo per l'hardware del _tuo_ PC. Questo presenta dei vantaggi, fra cui:

* Tempo di boot più veloce. Dato che il kernel cercherà di riconoscere solo l'hardware che hai sul tuo sistema, il tempo che ci vuole al tuo sistema per fare boot diminuirà drammaticamente.
* Minore uso della memoria. Un kernel custom spesso usa meno memoria del kernel [.filename]#GENERIC#, il che è importante dato che il kernel deve sempre essere presente nella memoria reale. Per questo motivo un kernel custom è particolarmente utile su sistemi con poca RAM.
* Supporto per hardware addizionale. Un kernel custom ti permette di aggiungere supporto per device che non sono presenti nel kernel [.filename]#GENERIC#, come ad esempio sound card.

[[kernelconfig-building]]
== Compilare ed installare un Kernel Custom

Per prima cosa, facciamo un breve giro nella directory di compilazione del kernel. Tutte le directory menzionate saranno relative alla directory principale [.filename]#/usr/src/sys#, che è accessibile attraverso il path [.filename]#/sys#. Ci sono un certo numero di sottodirectory qua che rappresentano parti differenti del kernel, ma la più importante per i nostri scopi è [.filename]#arch/conf#, dove editerai il tuo file di configurazione del kernel, e [.filename]#compile#, che è l'area di passaggio dove il tuo kernel sarè compilato. _arch_ rappresenta uno fra [.filename]#i386#, [.filename]#alpha#, [.filename]#amd64#, [.filename]#ia64#, [.filename]#powerpc#, [.filename]#sparc64#, o [.filename]#pc98# (un tipo di sviluppo alternativo di hardware PC in Giappone). Tutto ciò che è all'interno di particolare directory di architettura ha a che fare solo con quell'architettura; il resto è codice indipendente dalla macchina, comune a tutte le piattaforme sulle quali FreeBSD potrebbe potenzialmente essere portato. Nota l'organizzazione logica della struttura dele directory, con ogni device supportato, file system e opzioni nelle proprie sottodirectory.

Questo capitolo assume che tu stia usando la architettura i386 negli esempi. Se questo non è il caso, fai gli appropriati aggiustamenti per correggere i percorsi alla tua architettura.

[NOTE]
====
Se _non_ c'è una directory [.filename]#/usr/src/sys# sul tuo sistema, significa che i sorgenti del kernel non sono stati installati. Il modo più semplice per farlo è eseguire `sysinstall` come `root`, scegliendo [.guimenuitem]#Configure#, poi [.guimenuitem]#Distributions#, poi [.guimenuitem]#src#, poi [.guimenuitem]#base# e [.guimenuitem]#sys#. Se hai un'avversione verso sysinstall e hai accesso ad un CDROM "ufficiale" FreeBSD, allora puoi installare i sorgenti dalla linea di comando:

[source,shell]
....
# mount /cdrom
# mkdir -p /usr/src/sys
# ln -s /usr/src/sys /sys
# cat /cdrom/src/ssys.[a-d]* | tar -xzvf -
# cat /cdrom/src/sbase.[a-d]* | tar -xzvf -
....

====

Quindi, entra nella directory [.filename]#arch/conf# e copia il file di configurazione del kernel con il nome che vuoi dare al kernel. Ad esempio:

[source,shell]
....
# cd /usr/src/sys/i386/conf
# cp GENERIC MYKERNEL
....

Tradizionalmente, questo nome è tutto in lettere maiuscole e, se stai mantenendo molte macchine FreeBSD con hardware differente, è una buona idea dargli il nome della macchina. Noi lo chiamemeremo [.filename]#MYKERNEL# a titolo di esempio.

[TIP]
====

Conservare il tuo file di configurazione del kernel direttamente sotto [.filename]#/usr/src# può essere una cattiva idea. Se stai incontrando problemi puoi essere tentato di cancellare [.filename]#/usr/src# e partire da zero. Dopo averlo fatto, di solito ci vogliono pochi secondi per realizzare che hai appena cancellato il tuo file di configurazione del kernel. Inoltre, non editare [.filename]#GENERIC# direttamente, dato che potrebbe essere sovrascritto la prossima volta che crossref:cutting-edge[updating-upgrading,aggiorni i tuoi sorgenti], e le tue modifiche andranno perse.

Piuttosto tieni il tuo file di configurazione del kernel da qualche altra parte, e crea un link simbolico al file nella directory [.filename]#i386#.

Ad esempio:

[source,shell]
....
# cd /usr/src/sys/i386/conf
# mkdir /root/kernels
# cp GENERIC /root/kernels/MYKERNEL
# ln -s /root/kernels/MYKERNEL
....

====

Ora edita [.filename]#MYKERNEL# con il tuo editor favorito. Se stai partendo da zero, il solo editor disponibile sa` probabilmente vi, che è troppo complesso per essere spiegato in questa sede, ma è trattato estesamente in molti libri nella crossref:bibliography[bibliography,bibliografia]. Comunque, FreeBSD offre un semplice editor chiamato ee  che, se sei un principiante, dovrebbe essere il tuo editor favorito. Sentiti libero di cambiare le linee di commento in cima al file di configurazione per riflettere le tue configurazioni o i cambiamenti che hai fatto rispetto a [.filename]#GENERIC#.

Se hai compilato un kernel sotto SunOS(TM) o qualche altro sistema BSD, gran parte di questo file ti sarà noto. Se stai arrivando da qualche altro sistema operativo tipo DOS, d'altro canto, il file di configurazione [.filename]#GENERIC# ti potrebbe sembrare troppo complesso, così è meglio che segui le descrizioni della sezione <<kernelconfig-config,File di Configurazione>> attentamente.

[NOTE]
====
Se tu crossref:cutting-edge[updating-upgrading,sincronizzi il tuo albero dei sorgenti] con i più recenti sorgenti del progetto FreeBSD, accertati sempre di controllare il file [.filename]#/usr/src/UPDATING# prima di eseguire una qualsiasi operazione di aggiornamento. [.filename]#/usr/src/UPDATING# viene aggiornato con ogni versione dei sorgenti di FreeBSD, e quindi è più aggiornato di questo manuale.
====

A questo punto devi compilare i sorgenti del kernel.

[.procedure]
====
*Procedure: Compilare il Kernel*

. Entra nella directory [.filename]#/usr/src#:
+
[source,shell]
....
# cd /usr/src
....
+
. Compila il kernel:
+
[source,shell]
....
# make buildkernel KERNCONF=MYKERNEL
....
+
. Installa il nuovo kernel:
+
[source,shell]
....
# make installkernel KERNCONF=MYKERNEL
....
====

[NOTE]
====
Si richede la presenza dell'intera struttura dei sorgenti di FreeBSD per compilare il kernel. 
====

[TIP]
====

Di default, quando compili un kernel custom, anche _tutti_ i moduli del kernel sono ricompilati. Se vuoi aggiornare il kernel in modo spiccio o se vuoi compilare solo alcuni moduli, dovresti editare [.filename]#/etc/make.conf# prima di iniziare la compilazione del kernel:

[.programlisting]
....
MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs
....

Questa variabile contiene una lista dei moduli che saranno ricompilati.

[.programlisting]
....
WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs
....

Questa variabile contiene una lista dei moduli che saranno esclusi dal processo di compilazione. Per altre variabili che potresti trovare utili per il processo di compilazione del kernel, consulta la pagina man man:make.conf[5].
====

Il nuovo kernel sarà copiato nella directory [.filename]#/boot/kernel# come [.filename]#/boot/kernel/kernel# e il kernel precedente sarà copiato in [.filename]#/boot/kernel.old/kernel#. Ora, riavvia il sistema e riparti per usare il tuo nuovo kernel. Se qualcosa va storto, ci sono alcune istruzioni di <<kernelconfig-trouble,troubleshooting>> alla fine del capitolo che puoi trovare utili. Accertati di leggere la sezione in cui si spiega cosa fare in caso il tuo nuovo kernel <<kernelconfig-noboot,non faccia il boot>>.

[NOTE]
====
Altri file relativi al processo di boot, come il boot man:loader[8] e la configurazione sono conservati in [.filename]#/boot/#. Moduli di terze parti o custom possono essere piazzati in [.filename]#/boot/kernel/#, anche se gli utenti dovrebbero avere conoscenza del fatto che tenere i moduli sincronizzati col kernel compilato è molto importante. I moduli non creati per interagire col kernel compilato possono risultare in instabilità o comportamenti anomali.
====

[[kernelconfig-config]]
== Il File di Configurazione

Il formato generale di un file di configurazione è abbastanza semplice. Ogni linea contiene una parola chiave ed uno o più argomenti. Per semplicità, la maggior parte delle linee contiene solo un argomento. Tutto quello che segue un `#` è considerato un commento ed ignorato. Le seguenti sezioni descrivono ogni parola chiave, nell'ordine di presenza in [.filename]##GENERIC##. [[kernelconfig-options]]Per una lista esaustiva delle opzioni dipendenti dall'architettura e dei devices, leggi il file [.filename]##NOTES## nella stessa directory del file [.filename]##GENERIC##. Per opzioni indipendenti dall'architettura, leggi [.filename]##/usr/src/sys/conf/NOTES##.

[NOTE]
====
Per creare un file che contenga tutte le opzioni disponibili, ad esempio per usi di testing, esegui il seguente comando come `root`:

[source,shell]
....
# cd /usr/src/sys/i386/conf && make LINT
....

====

Il seguente è un esempio del file di configurazione del kernel [.filename]#GENERIC# con vari commenti addizionali ove necessari ai fini della chiarezza. Questo esempio dovrebbe corrispondere abbastanza da vicino alla tua copia in [.filename]#/usr/src/sys/i386/conf/GENERIC#. 

[.programlisting]
....
machine   i386
....

Questa è la architettura della macchina. Deve essere una fra `alpha`, `amd64`, `i386`, `ia64`, `pc98`, `powerpc`, o `sparc64`.

[.programlisting]
....
cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU
....

Quanto riportato sopra specifica il tipo di CPU che hai nella tua macchina. Puoi avere molte istanze di linee di CPU (se, per esempio, non sei sicuro se devi usare la `I586_CPU` o la `I686_CPU`), ma per un kernel custom è meglio specificare solo la CPU che hai. Se non sei sicuro di quale sia il tipo della tua CPU, controlla il file [.filename]#/var/run/dmesg.boot# per leggere i messaggi di boot.

[.programlisting]
....
ident          GENERIC
....

Questo è l'identificativo del kernel. Dovresti cambiarlo nel nome che hai dato al kernel, ad esempio `MYKERNEL` se hai seguito le istruzioni degli esempi precedenti. Il valore che poni nella stringa `ident`, sarà emesso a video quando fai il boot del kernel, così è utile dare al nuovo kernel un nome differente se vuoi tenerlo separato dal tuo kernel usuale (ad esempio se vuoi creare un kernel sperimentale).

[.programlisting]
....
#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.
....

L'opzione man:device.hints[5] è usato per configurare le opzioni dei device driver. La posizione di default che man:loader[8] cercherà al momento del boot è [.filename]#/boot/device.hints#. Usando l'opzione `hints` puoi compilare queste direttive direttamente nel kernel. Se fai così non c'è bisogno di creare un file [.filename]#device.hints# in [.filename]#/boot#.

[.programlisting]
....
makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols
....

Il processo normale di compilazione di FreeBSD include informazioni di debugging quando si compila il kernel con l'opzione `-g`, che abilita il debugging quando passato a man:gcc[1].

[.programlisting]
....
options          SCHED_4BSD         # 4BSD scheduler
....

Lo schedulatore tradizionale per FreeBSD. Tienilo. 

[.programlisting]
....
options          PREEMPTION         # Enable kernel thread preemption
....

Permette ai thread del kernel di essere interrotti da altri thread a priorità più alta. Aiuta con l'interattività e permette ai thread degli interrupt di essere eseguiti prima rispetto invece che attendere. 

[.programlisting]
....
options          INET              # InterNETworking
....

Supporto per la rete. Lascia questa opzione, anche se non intendi connettere il computer ad una rete. La maggior parte dei programmi richiedono almeno rete di loopback (ad esempio fare connessioni di rete dal tuo pc al tuo pc stesso), così questa opzione in sostanza è obbligatoria.

[.programlisting]
....
options          INET6             # IPv6 communications protocols
....

Questo abilita il protocollo di comunicazione IPv6.

[.programlisting]
....
options          FFS               # Berkeley Fast Filesystem
....

Questo è il file system di dischi di base. Lascialo nel kernel se fai il boot da hard disk.

[.programlisting]
....
options          SOFTUPDATES       # Enable FFS Soft Updates support
....

Questa opzione abilita le Soft Updates nel kernel, aiuterà a velocizzare accesso di scrittura ai dischi. Anche quando questa funzionalità è fornita dal kernel, deve essere attivata per dischi specifici. Rileggi l'output da man:mount[8] per vedere se Soft Updates sono abilitate per i tuoi dischi di sistema. Se non vedi l'opzione `soft-updates` potrai abilitarla usando man:tunefs[8] (per file system già esistenti) o man:newfs[8] (per nuovi file system).

[.programlisting]
....
options          UFS_ACL           # Support for access control lists
....

Questa opzione abilita supporto nel kernel per le liste di controllo di accesso. Questo poggia sull'uso degli attributi estesi e UFS2, questa opzione viene descritta in dettaglio in crossref:security[security,Sicurezza]. ACL sono abilitate di default e non dovrebbero essere disabilitate nel kernel se sono state usate precedentemente su un file system, dato che questo rimuoverà le liste di controllo di accesso, cambiando il modo in cui i file sono protetti in modo non predicibile.

[.programlisting]
....
options          UFS_DIRHASH       # Improve performance on big directories
....

Quest'opzione include funzionalità per accelerare operazioni sui dischi su larghe directory, a costo di uso di memoria. Lo dovresti tenere per un server molto trafficato o workstation interattive, e rimuoverlo se stai usando FreeBSD su piccoli sistemi dove la memoria è scarsa e l'accesso ai dischi è meno importante, come un firewall.

[.programlisting]
....
options          MD_ROOT           # MD is a potential root device
....

Questa opzione abilita il supporto per un disco virtuale basato sulla memoria da usare come device di root.

[.programlisting]
....
options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT
....

Il file system di rete. A meno che tu non intenda montare partizioni da un file server UNIX(R) sopra TCP/IP, puoi commentare queste righe.

[.programlisting]
....
options          MSDOSFS           # MSDOS Filesystem
....

Il filesystem MS-DOS(R). A meno che non intendi montare un disco formattato DOS al momento del boot, puoi tranquilamente commentare queste opzioni. Sarà automaticamente caricato la prima volta che monti una partizione DOS, come descritto in seguito. Inoltre, l'eccellente software package:emulators/mtools[] ti permette di accedere a floppy DOS senza dover montarli e smontarli (e non richiede assolutamente `MSDOSFS`).

[.programlisting]
....
options          CD9660            # ISO 9660 Filesystem
....

Il file system ISO 9660 per CDROM. Commentalo se non hai un drive CDROM o monti CD di dati solo occasionalmente (dato che sarà caricato dinamicamente la prima volta che monti un CD di dati). CD audio non necessitano di questo file system.

[.programlisting]
....
options          PROCFS            # Process filesystem (requires PSUEDOFS)
....

Il file system dei processi. Questo è un "fittizio" file system montato su [.filename]#/proc# che permette a programmi come man:ps[1] di darti maggiori informazioni su quali processi sono in esecuzione. L'uso di `PROCFS` non è richiesto nella maggior parte dei casi, dato che la maggior parte dei tool di debugging e di monitoring è stato adattato per funzionare senza `PROCFS`: la procedura di installazione non monterà questo file system di default.

[.programlisting]
....
options          PSEUDOFS          # Pseudo-filesystem framework
....

I kernel 6.X che fanno uso del filesystem `PROCFS` devono anche includere supporto per `PSEUDOFS`.

[.programlisting]
....
options          GEOM_GPT          # GUID Partition Tables.
....

Questa opzione fornisce la possibilità di avere un gran numero di partizioni su un singolo disco.

[.programlisting]
....
options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]
....

Compatibilità con 4.3BSD. Lasciala; alcuni programmi si comporteranno in maniera strana se la commenti.

[.programlisting]
....
options          COMPAT_FREEBSD4   # Compatible with FreeBSD4
....

Questa opzione è richiesta su FreeBSD 5.X su sistemi i386(TM) e Alpha per supportare applicazioni compilate su versioni precedenti di FreeBSD che usano vecchie interfacce di system call. Si raccomanda che questa opzione sia usata su tutte le i386(TM) ed Alpha che possano eseguire vecchie applicazioni; piattaforme che hanno ottenuto supporto solo dall 5.X, come ia64 e sparc64 non richiedono questa opzione.

[.programlisting]
....
options          COMPAT_FREEBSD5   # Compatible with FreeBSD5
....

Questa opzione è richiesta per FreeBSD 6.X e superiori per supportare applicazioni compilate su os; 5.X che fanno uso di chiamate di sistema di FreeBSD 5.X.

[.programlisting]
....
options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI
....

Questa opzione fa sì che il kernel faccia una pausa di 5 secondi prima di controllare ogni device SCSI sul tuo sistema. Se hai solo dischi IDE, puoi ignorarla, altrimenti potresti voler diminuire il numero per accelerare il boot. Ovviamente, se fai ciò e FreeBSD ha problemi a riconoscere i tuoi device SCSI, dovrai alzarla di nuovo.

[.programlisting]
....
options          KTRACE            # ktrace(1) support
....

Questo abilita il tracciamento dei processi nel kernel, che è utile per il debugging.

[.programlisting]
....
options          SYSVSHM           # SYSV-style shared memory
....

Questa opzione fornisce memoria condivisa di tipo System V. L'uso più comune di questa opzione è l'estensione XSHM in X, grazie alla quale molti programmi ad alta intensità grafica ne trarranno vantaggio per maggior velocità. Se usi X, vorrai sicuramente includere questa opzione. 

[.programlisting]
....
options          SYSVMSG           # SYSV-style message queues
....

Supporto per messaggi stile System V. Questa opzione aggiunge solo poche centinaia di byte al kernel.

[.programlisting]
....
options          SYSVSEM           # SYSV-style semaphores
....

Supporto per semafori stile System V. Usato meno di frequente ma aggiunge solo poche centinaia di byte al kernel.

[NOTE]
====
L'opzione `-p` del comando man:ipcs[1] mostrerà ogni processo che usa uno di queste opzione System V.
====

[.programlisting]
....
options        _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions
....

Estensioni real-time aggiunte al POSIX(R) 1993. Alcune applicazioni nella collezione dei Ports usano questa opzione (come StarOffice(TM)).

[.programlisting]
....
options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev
....

Questa opzione è relativa ala tastiera. Aggiunge una entry CDEV nella directory [.filename]#/dev#.

[.programlisting]
....
options          ADAPTIVE_GIANT    # Giant mutex is adaptive.
....

Giant è il nome di un meccanismo di esclusione reciproca (uno sleep mutex) che protegge gran parte delle risorse del kernel. Al giorno d'oggi è un inaccettabile rallentamento delle performance che si sta attivamente sostituendo con locks che proteggono risorse individuali. L'opzione `ADAPTIVE_GIANT` fa sì che Giant sia incluso nell'insieme dei mutex da scegliere. Cioè quando un thread vuole fare un lock sul mutex Giant, ma è già bloccato da un thread su un'altra CPU, il primo thread continuerà a girare ed aspetterà che il lock sia rilasciato. Normalmente invece, il thread tornerebbe a dormire e aspetterà la sua prossima occasione per girare. Se non sei sicuro, lascialo dentro.

[.programlisting]
....
device          apic               # I/O APIC
....

Il device apic abilita l'uso dell'APIC I/O per inviare gli interrupt. Il device apic può essere usato sia su kernel UP che su SMP, ma è richiesto per kernel SMP. Aggiungi `option SMP` per includere supporto per processori multipli.

[NOTE]
====
Il dispositivo apic esiste sono per l'architettura i386, questa riga di configurazione non deve essere usata per altre architetture.
====

[.programlisting]
....
device          eisa
....

Includilo se hai una motherboard EISA. Questo abilita supporto per l'auto-rilevazione e configurazione per tutti i device sul bus EISA.

[.programlisting]
....
device          pci
....

Includilo se hai una motherboard PCI. Questo abilita l'auto-rilevazione delle carte PCI e operazioni di gateway dal bus PCI al bus ISA.

[.programlisting]
....
# Floppy drives
device          fdc
....

Questo abilita il supporto al controller del floppy drive.

[.programlisting]
....
# ATA and ATAPI devices
device          ata
....

Questo driver supporta tutti i device ATA e ATAPI. Hai bisogno solo di una linea `device ata` per il kernel affinchè rilevi tutti i device PCI ATA/ATAPI su macchine moderne.

[.programlisting]
....
device          atadisk                 # ATA disk drives
....

Questo è necessario assieme a `device ata` per disk drive ATA.

[.programlisting]
....
device          ataraid                 # ATA RAID drives
....

Questo è necessario assieme a `device ata` per drive ATA RAID.

[.programlisting]
....

device          atapicd                 # ATAPI CDROM drives
....

Questo è necessario assieme a `device ata` per drive CDROM ATAPI.

[.programlisting]
....
device          atapifd                 # ATAPI floppy drives
....

Questo è necessario assieme a `device ata` per drive floppy ATAPI.

[.programlisting]
....
device          atapist                 # ATAPI tape drives
....

Questo è necessario assieme a `device ata` per drive tape ATAPI.

[.programlisting]
....
options         ATA_STATIC_ID           # Static device numbering
....

Questo rende il numero di controller statico; senza questo i numeri di device sono allocati dinamicamente.

[.programlisting]
....
# SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50
....

Controller SCSI. Commentali tutti se non ne hai nessuno sul tuo sistema. Se hai un sistema solo IDE, puoi rimuoverli tutti. Le righe `*_REG_PRETTY_PRINT` sono opzioni di debug per i loro rispettivi dispositivi.

[.programlisting]
....
# SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)
....

Periferiche SCSI. Ancora, commentali se non ne hai nessuna o se il tuo sistema è solo IDE.

[NOTE]
====
Il driver USB man:umass[4] e pochi altri driver usano il sottosistema SCSI anche se non sono veri device SCSI. Quindi accertati di non rimuovere il supporto a SCSI, se qualche driver del genere è incluso nella tua configurazione del kernel.
====

[.programlisting]
....
# RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID
....

Controller RAID supportati. Se non ne hai nessuno, puoi commentarli o rimuoverli.

[.programlisting]
....
# atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller
....

Il controller della tastiera (`atkbdc`) fornisce servizi I/O per la tastiera AT ed il device PS/2. Questo controller è richiesto dal driver della tastiera (`atkbd`) e dal driver del dispositivo di puntamento PS/2 (`psm`).

[.programlisting]
....
device          atkbd      # AT keyboard
....

Il driver `atkbd` assieme al controller `atkbdc`, fornisce accesso alla tastiera AT 84 o la tastiera AT migliorata che è connesso al controller della tastiera AT.

[.programlisting]
....
device          psm        # PS/2 mouse
....

Usa questo device se il tuo mouse si inserisce nella porta PS/2.

[.programlisting]
....
device          kbdmux        # keyboard multiplexer
....

Supporto base per il multiplexing della tastiera. Se non hai intenzione di usare più di una tastiera sul sistema, puoi tranquillamente rimuovere quella riga.

Supporto base per il multiplexing della tastiera.

[.programlisting]
....
device          vga        # VGA video card driver
....

Il driver della video card.

[.programlisting]
....
# splash screen/screen saver
device          splash     # Splash screen and screen saver support
....

Schermata slapsh all'avvio! Anche gli screensaver lo richiedono.

[.programlisting]
....
# syscons is the default console driver, resembling an SCO console
device          sc
....

`sc` è il driver di default della console, assomiglia ad una console SCO. Dato che molti programmi a schermo intero accedono alla console attraverso una libreria di database di terminali come [.filename]#termcap#, non dovrebbe fare differenza se usi questo o `vt`, il driver compatibile con una console `VT220`. Quando ti logghi, imposta la tua variabile d'ambiente `TERM` a `scoansi` se programmi a schermo intero hanno problemi a girare sotto questa console.

[.programlisting]
....
# Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor
....

Questo è un driver di console compatibile con VT-220, compatibile all'indietro con VT100/102. Funziona bene su alcuni laptop che hanno incompatibilità hardware con `sc`. Inoltre imposta la tua variabile `TERM` a `vt100` o `vt220` quando ti logghi. Questo driver può essere utile quando ci si connette ad un grande numero di macchine diverse sulla rete, dove le entry [.filename]#termcap# o [.filename]#terminfo# per il device `sc` spesso non sono disponibili - `vt100` dovrebbe essere disponibile virtualmente su ogni piattaforma.

[.programlisting]
....
device          agp
....

Includilo se hai una scheda AGP nel tuo sistema. Questo abiliterà il supporto per AGP, e AGP GART per le motherboard che hanno queste caratteristiche.

[.programlisting]
....
# Power management support (see NOTES for more options)
#device          apm
....

Supporto Advanced Power Management. Utile per laptop, anche se in FreeBSD 5.X e successivo questo è disabilitato in [.filename]#GENERIC# di default.

[.programlisting]
....
# Add suspend/resume support for the i8254.
device           pmtimer
....

Device driver per eventi di power management, come APM ed ACPI.

[.programlisting]
....
# PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus
....

Supporto PCMCIA. Includilo se usi un laptop.

[.programlisting]
....
# Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports
....

Queste sono le porte seriali chiamate [.filename]#COM# nel mondo MS-DOS(R)/Windows(R).

[NOTE]
====
Se hai un modem interno sulla [.filename]#COM4# ed una porta seriale sulla [.filename]#COM2#, dovrai cambiare l'IRQ del modem a 2 (per ragioni tecniche oscure IRQ 2=IRQ 9) affinchè tu ci possa accedere da FreeBSD. Se hai una carta seriale multiporta, controlla la pagina di manuale per man:sio[4] per maggiori informazioni sui valori corretti da aggiungere al tuo [.filename]#/boot/device.hints#. Alcune video card (in particolare quelle basate su chip S3) usano indirizzi IO della forma `0x*2e8` e dato che molte carte seriali non codificano l'intero spazio degli indirizzi IO a 16 bit, hanno conflitti con queste carte, rendendo la porta `COM4` praticamente non disponibile.

Ogni porta seriale deve avere un IRQ unico (a meno che non stia usando una delle carte multicard dove sono supportati interrupt condivisi), così gli IRQ di default per [.filename]#COM3# e [.filename]#COM4# non possono essere usati.
====

[.programlisting]
....
# Parallel port
device          ppc
....

Questo è l'interfaccia al bus ISA parallelo.

[.programlisting]
....
device          ppbus      # Parallel port bus (required)
....

Fornisce supporto per il bus della porta parallela.

[.programlisting]
....
device          lpt        # Printer
....

Supporto per la stampante a porta parallela.

[NOTE]
====
Tutte quest tre sono necessarie per abilitare supporto alla stampante parallela.
====

[.programlisting]
....
device          plip       # TCP/IP over parallel
....

Questo è il driver della interfaccia di rete parallela.

[.programlisting]
....
device          ppi        # Parallel port interface device
....

L'I/O a scopo generico ("geek port") + IEEE1284 I/O.

[.programlisting]
....
#device         vpo        # Requires scbus and da
....

Questo è per uno IOMEGA zip drive. Richiede supporto `scbus` e `da`. La migliore performance è raggiunta con porte in modo EPP 1.9.

[.programlisting]
....
#device         puc
....

Scommenta questo device se ha una seriale "dumb" o carta PCI parallela che è supportata dal driver glue man:puc[4].

[.programlisting]
....
# PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (Tulip)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (Typhoon)
device          vx         # 3Com 3c590, 3c595 (Vortex)
....

Vari driver di schede di rete PCI. Commentalo o rimuovilo se nessuno di questi è presente nel tuo sistema.

[.programlisting]
....
# PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support
....

Supporto bus MII è richiesto per alcune NIC Ethernet 10/100 PCI, in particolare quelle che usano transricevitori compatibili con MII o implementano interfacce di controllo che operano su MII. Aggiungere `device miibus` al kernel porta con sè il supporto per la generica API miibus e tutti i driver PHY, incluso un generico per PHY che non è specificamente gestito da driver individuali.

[.programlisting]
....
device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (Starfire)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x & SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 EPIC)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (Boomerang, Cyclone)
....

Driver che usano il codice del controller MII.

[.programlisting]
....
# ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le
....

Driver ISA Ethernet. Vedi [.filename]#/usr/src/sys/i386/conf/NOTES# per dettagli su quali carte siano supportate da quali driver.

[.programlisting]
....
# Wireless NIC cards
device          wlan            # 802.11 support
....

Supporto generico al 802.11. Questa riga è richiesta per la rete wireless.

[.programlisting]
....
device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support
....

Supporto di crittografia per i dispositivi 802.11. Queste righe sono necessarie se intenti usare la codificazione e i protocolli di sicurezza 802.11i.

[.programlisting]
....
device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.
....

Supporto per varie carte wireless.

[.programlisting]
....
# Pseudo devices
device   loop          # Network loopback
....

Questo è il generico device loopback per TCP/IP. Se fai telnet o FTP a `localhost` (anche conosciuto come `127.0.0.1`) la connessione ritornerà alla tua stessa macchina attraverso questo device. Questo è _obbligatorio_.

[.programlisting]
....
device   random        # Entropy device
....

Generatore casuale sicuro di numeri random.

[.programlisting]
....
device   ether         # Ethernet support
....

`ether` è necessario solo se hai una carta Ethernet. Include un codice di protocollo Ethernet.

[.programlisting]
....
device   sl            # Kernel SLIP
....

`sl` è per supporto slip. È stato interamente soppiantato da PPP, che è più semplice da installare, più adatto per connessioni modem-to-modem e più potente.

[.programlisting]
....
device   ppp           # Kernel PPP
....

Questo è per supporto kernel PPP per connessioni dial-up. C'è anche una versione di PPP implementata come applicazione userland che usa `tun` e offre più flessibilità e caratteristiche aggiuntive come dialing a domanda.

[.programlisting]
....
device   tun           # Packet tunnel.
....

Questo è usato per software userland PPP. Vedi la sezione crossref:ppp-and-slip[userppp,PPP] di questo libro per maggiori informazioni.

[.programlisting]
....

device   pty           # Pseudo-ttys (telnet etc)
....

Questo è uno "pseudo-terminal" o porta di login simulato. È usato da sessioni `telnet` e `rlogin`, xterm e qualche altra applicazione come Emacs.

[.programlisting]
....
device   md            # Memory disks
....

Pseudo-device di disco di memoria.

[.programlisting]
....
device   gif           # IPv6 and IPv4 tunneling
....

Questo implementa il tunneling IPv6 su IPv4, IPv4 su IPv6, IPv4 su IPv4 e IPv6 su IPv6. Il device `gif` è "autoclonante", e creerà gli altri node come richiesto. 

[.programlisting]
....
device   faith         # IPv6-to-IPv4 relaying (translation)
....

Questo pseudo-device cattura i pacchetti che sono inviati a lui e li distoglie verso il demone di traslazione IPv4/IPv6. 

[.programlisting]
....
# The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter
....

Questo è il Berkeley Packet Filter. Questo pseduo-device permette alle interfacce di rete di essere configurate in modo promiscuo, catturando ogni pacchetto su una rete broadcast (ad esempio una Ethernet). Questi pacchetti possono essere catturati su disco e o esaminati con il programma man:tcpdump[1].

[NOTE]
====
Il device man:bpf[4] è anche usato da man:dhclient[8] per ottenere l'indirizzo IP del default router (gateway) eccetera. Se usi DHCP, lascia questa riga scommentata.
====

[.programlisting]
....
# USB support
device          uhci          # UHCI PCI->USB interface
device          ohci          # OHCI PCI->USB interface
device          ehci          # EHCI PCI->USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # Human Interface Devices
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet
....

Supporto per vari device USB.

[.programlisting]
....
# FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)
....

Supporto per vari device FireWire.

Per maggiori informazioni e device addizionali supportati da FreeBSD, controlla [.filename]#/usr/src/sys/i386/conf/NOTES#.

=== Configurazioni a Memoria Estesa (PAE)

Macchine con configurazione a memoria estesa richiedono più di 4 gigabyte di limite nello spazio degli indirizzi Virtuale User+Kernel (KVA). A causa di questa limitazione, Intel ha aggiunto supporto per lo spazio degli indirizzi fisico a 36-bit nel Pentium(R) Pro e linee successive di CPU.

La caratteristica di Physical Address Extension (PAE) dell' Intel(R) Pentium(R) Pro e CPU successive permette configurazioni della memoria fino a 64 gigabyte. FreeBSD fornisce supporto per questa caratteristica attraverso l'opzione di configurazione del kernel `PAE`, disponibile in tutte le versioni correnti di FreeBSD. A causa della limitazione della architettura della memoria Intel, nessuna distinzione è fatta per memorie sopra o sotto i 4 gigabyte. Memoria allocata oltre i 4 gigabyte è semplicemente aggiunta al pool della memoria disponibile.

Per abilitare il supporto PAE nel kernel, aggiungi semplicemente la seguente linea nel tuo file di configurazione del kernel:

[.programlisting]
....
options       PAE
....

[NOTE]
====
Il supporto PAE in FreeBSD è disponibile solo per processori Intel(R) IA-32. Bisogna notare inoltre che il supporto PAE non ha ricevuto test esteso, e dovrebbe essere considerato di qualità beta rispetto alle altre carateristiche stabili di FreeBSD.
====

Il supporto per PAE in FreeBSD ha qualche limitazione:

* Un processo non è in grado di accedere a più di 4 gigabte di spazio VM.
* I moduli KLD non possono essere caricati in un kernel con abilitato PAE, a causa delle differenze nell'ambiente di compilazione di un modulo e del kernel.
* Device driver che non usano l'interfaccia man:bus_dma[9] causeranno corruzione dei dati in un kernel abilitato PAE, e non se ne raccomanda l'uso. Per questo motivo, viene fornito un file di configurazione del kernel [.filename]#PAE#, che esclude tutti i driver per i quali non è stato testato il funzionamento in un kernel abilitato PAE.
* Alcuni parametri che possono essere settati determinano l'uso delle risorse di memoria a partire dalla quantità di memoria fisica disponibile. Questi parametri possono allocare troppo spazio rispetto alle necessità a causa della dimensione della memoria di un sistema PAE. Un esempio simile è il sysctl `kern.maxvnodes`, che controlla il massimo numero di vnodes permessi nel kernel. È concesso di aggiustare questo ed altri parametri ad un valore ragionevole.
* Può essere necessario aumentare lo spazio degli indirizzi di memoria virtuale del kernel (KVA) o ridurre la quantità di risorse specifiche che sono pesantemente usate (vedi oltre) per evitare esaurimenti di KVA. L'opzione del kernel KVA_PAGES può essere usata per aumentare lo spazio KVA.

Per motivi di stabilità e di performance, si consiglia di consultare le pagine di manuale man:tuning[7]. La pagina di manuale man:pae[4] contiene informazioni aggiornate sul supporto PAE.

[[kernelconfig-trouble]]
== Se Qualcosa Va Male

Ci sono cinque categorie di problemi che si possono presentare quando si crea un nuovo kernel. Sono:

`config` fallisce:::
Se il comando man:config[8] fallisce quando gli passi la descrizione del tuo kernel, hai fatto probabilmente un semplice errore da qualche parte. Fortunatamente man:config[8] scriverà il numero della linea che ha dato errore, così puoi facilmente trovare la linea errata. Ad esempio, se vedi:
+
[source,shell]
....
config: line 17: syntax error
....
+
Accertati che la parola chiave sia scritta correttamente confrontandola con quella del kernel [.filename]#GENERIC# o un altro riferimento.

`make` fallisce:::
Se il comando `make` fallisce, di solito segnala un errore nella descrizione del kernel che non è abbastanza grave per man:config[8]. Ancora, controlla la tua configurazione e se ancora non riesci a risolvere il problema, invia una mail a {freebsd-questions} con la tua configurazione del kernel, e dovrebbe essere diagnosticato velocemente.

Il kernel non fa il boot:[[kernelconfig-noboot]]::
Se il tuo kernel non fa il boot, o fallisce nel riconoscimento dei tuoi device, non andare in panico! Fortunatamente FreeBSD ha un ottimo meccanismo per ricominciare in questo caso. Semplicemente scegli il kernel da cui vuoi fare il boot dal boot loader FreeBSD. Puoi accedere ad esso quando appare il menu del boot. Seleziona l'opzione "Escape to a loader prompt", la numero sei. Al prompt digita `unload kernel` e poi digita `boot /boot/kernel.old/kernel` o il nome del file di un altro kernel da cui puoi bootare correttamente. Quando configuri un kernel, è sempre una buona idea tenere un kernel che si sa che funzioni a portata di mano.
+
Dopo aver fatto il boot con un kernel funzionante puoi controllare il tuo file di configurazione e cercare di ricompilarlo. Una risorsa utile è il file [.filename]#/var/log/messages# che, fra le altre cose, registra tutti messaggi del kernel da ogni boot riuscito. Inoltre, il comando man:dmesg[8] scriverà i messaggi del kernel dall'ultimo boot.
+
[NOTE]
====
Se hai problemi a compilare un kernel, accertati di tenere un kernel [.filename]#GENERIC#, o qualche altro kernel che sai che funzioni a portata di mano,con un nome diverso cosichè non sia cancellato dalla successiva compilazione. Non puoi affidarti su [.filename]#kernel.old# perchè quando installi un nuovo kernel, [.filename]#kernel.old# viene cancellato dall'ultimo kernel installato, che poteva essere non funzionanante. Inoltre, appena possibile, sposta il kernel funzionanante nella directory corretta [.filename]#/boot/kernel# o comandi come man:ps[1] potrebbero non funzionare bene. Per farlo, semplicemente rinomina la directory contenente il kernel funzionante:

[source,shell]
....
# mv /boot/kernel /boot/kernel.bad
# mv /boot/kernel.good /boot/kernel
....

====

Il kernel funziona, ma man:ps[1] non funziona più.::
Se hai installato una versione del kernel differente da quella delle utilities di sistema, per esempio un kernel -CURRENT ed un sistema -RELEASE, molti comandi di stato del sistema come man:ps[1] e man:vmstat[8] non funzioneranno più. Dovresti crossref:cutting-edge[makeworld,ricompilare ed installare world] con la stessa versione dei sorgenti del tuo kernel. Questa è una ragione per non usare una versione del kernel diversa dal sistema operativo.
