---
title: 第14章 ストレージ
part: パートIII. システム管理
prev: books/handbook/security
next: books/handbook/l10n
showBookMenu: true
weight: 18
path: "/books/handbook/disks/"
---

[[disks]]
= ストレージ
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 14
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/audit/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[disks-synopsis]]
== この章では

この章では、FreeBSD におけるディスクの使用方法を説明します。 これにはメモリディスク、ネットワークに接続されたディスク、 および標準的な SCSI/IDE 記憶デバイスが含まれます。

この章では、以下の分野について説明します。

* 物理ディスク上のデータ構成 について記述するために FreeBSD が使用する用語 (パーティションおよびスライス) 
* システムにハードディスクを追加する方法
* メモリディスクのような仮想ファイルシステムを設定する方法
* 使用できるディスク容量を制限するためにクォータを設定する方法
* 攻撃者から保護するためにディスクを暗号化する方法
* FreeBSD で CD や DVD を作成する方法
* バックアップのためのさまざまな記憶メディアオプション
* FreeBSD で利用できるバックアッププログラムの使用方法
* フロッピーディスクにバックアップする方法
* スナップショットとは何か、そしてそれを効果的に使用する方法

[[disks-naming]]
== デバイス名

以下は、FreeBSD で対応している物理記憶デバイスとそれに対応するデバイス名のリストです。

[[disk-naming-physical-table]]
.物理ディスクへの名前付け
[cols="1,1", options="header"]
|===
| ドライブの種類
| ドライブのデバイス名

|IDE ハードドライブ
|`ad`

|IDE CD-ROM ドライブ
|`acd`

|SCSI ハードドライブおよび USB 大容量記憶デバイス
|`da`

|SCSI CD-ROM ドライブ
|`cd`

|その他の非標準的 CD-ROM ドライブ
|ミツミ CD-ROM は `mcd`, Sony CD-ROM は `scd`, 松下/パナソニック CD-ROM は `matcd`

|フロッピードライブ
|`fd`

|SCSI テープドライブ
|`sa`

|IDE テープドライブ
|`ast`

|フラッシュドライブ
|DiskOnChip(R) フラッシュデバイスは `fla`

|RAID ドライブ
|Adaptec(R) AdvancedRAID は `aacd`, Mylex(R) は `mlxd` および `mlyd`, AMI MegaRAID(R) は `amrd`, Compaq Smart RAID は `idad`, 3ware(R) RAID は``twed``
|===

[[disks-adding]]
== ディスクの追加

現在一つしかドライブがない計算機に新しく SCSI ディスクを追加したいとしましょう。まずコンピュータの電源を切り、 コンピュータやコントローラ、 ドライブの製造元の説明書に従ってドライブを取り付けます。 このあたりの手順は非常に多岐にわたるため、 詳細はこの文書の範囲外です。

`root` ユーザでログインします。 ドライブの取り付け後は [.filename]#/var/run/dmesg.boot# を調べて新しいディスクが見つかっていることを確認しておきます。 この例では、新しく付けたドライブは [.filename]#da1# で、 我々はそれを [.filename]#/1# にマウントしたいとしましょう (もし IDE ドライブを付けようとしているのなら、デバイス名は 4.0 以前のシステムでは [.filename]#wd1#, ほとんどの 4.x システムでは [.filename]#ad1# になるでしょう)。

FreeBSD は IBM-PC 互換のコンピュータで動くため、 PC BIOS のパーティションを考慮に入れる必要があります。 これは従来の BSD パーティションとは異なります。PC ディスクは 4 つまでの BIOS パーティションエントリを持つことができます。 もしそのディスクを本当に FreeBSD 専用にしたい場合には _専用_ モードで用いることもできます。 そうでない場合には、FreeBSD は PC BIOS パーティションのどれか一つの中に入れることになります。 FreeBSD では、従来の BSD パーティションと混乱しないように PC BIOS パーティションのことを__スライス__と呼びます。 また、別の OS がインストールされていたコンピュータで使われていたが FreeBSD 専用にするディスク上でもスライスを用いることができます。 これは、他の OS の `fdisk` ユーティリティを混乱させないためです。

スライスの場合、ドライブは [.filename]#/dev/da1s1e# として加えられるでしょう。これは、SCSI ディスクでユニット番号は 1 (二つめの SCSI ディスク), スライスは 1 (PC BIOS のパーティションが 1) で BSD パーティション [.filename]#e#, と読みます。 専用ディスクの場合だと単純に [.filename]#/dev/da1e# として加えられるでしょう。

=== man:sysinstall[8] の利用

[.procedure]
====
. sysinstall の操作
+ 
`sysinstall` の使い易いメニューを利用して、 新しいディスクのパーティション分けやラベル付けを行なうことができます。 `root` ユーザでログインするか `su` コマンドを用いるかして root 権限を取得します。 `/stand/sysinstall` を実行して `Configure` メニューに入ります。`FreeBSD Configuration Menu` の中でスクロールダウンして `Fdisk` の項目を選びます。
. fdisk パーティションエディタ
+ 
fdisk では、ディスク全体を FreeBSD で使うために `A` を入力します。 "remain cooperative with any future possible operating systems" と聞かれたら `YES` と答えます。 `W` で変更をディスクに書き込みます。ここで `q` と入力して FDISK エディタを抜けます。 次にマスタブートレコードについて聞かれます。 ここでは既に動いているシステムにディスクを追加しようとしているので `None` を選びます。
. ディスクラベルエディタ
+ 
次に sysinstall を終了し、 もう一度起動する必要があります。同じ手順を踏んで今度は `Label` オプションを選択し、 `Disk Label Editor` に入ります。 ここでは従来の BSD パーティションを作成します。 一つのディスクは `a` から `h` までのラベルがついた最大 8 つのパーティションを持つことができます。 いくつかのパーティションラベルは特別な用途に用いられます。 `a` パーティションはルートパーティション ([.filename]#/#) です。したがって、システムディスク (つまり起動ディスク) のみに `a` パーティションがあるべきです。`b` パーティションはスワップパーティションに用いられ、 複数のディスクにスワップパーティションを作ることができます。 `c` は専用モードにおけるディスク全体、 もしくはスライスモードにおけるスライス全体を指します。 他のパーティションは汎用的に用いられます。
+ 
sysinstall のラベルエディタ は、ルートパーティションでもスワップパーティションでもないパーティションには、`e` パーティションを採用しようとします。ラベルエディタでファイルシステムを作成するには `C` を入力してください。 FS (ファイルシステム) かスワップかを聞かれたら `FS` を選びマウントポイント (たとえば [.filename]#/mnt#) を入力します。 インストール後のモードでディスクを追加する場合、 sysinstall は [.filename]#/etc/fstab# にエントリを追加しないため、 ここで指定するマウントポイントはそれほど重要ではありません。
+ 
さて、ディスクに新しいラベルを書き込み、 そこにファイルシステムを作る準備が整いました。早速 `W` を叩いて実行しましょう。 sysinstall からの、 新しいパーティションをマウントできない、 というエラーは無視してください。Label Editor から抜け、 sysinstall を終了します。
. 終了
+ 
最後に [.filename]#/etc/fstab# を編集し、 新しいディスクのエントリを追加します。
====

=== コマンドラインユーティリティの利用

==== スライスの利用

このセットアップ方法では、 すでにコンピュータに他のオペレーティングシステムがインストールされていても 正しく協調動作することが可能で、他のオペレーティングシステムの `fdisk` ユーティリティを混乱させることもありません。 新しいディスクにインストールする場合は、 この方法を用いることが推奨されています。 後述する `専用モード` は、 そうしなければならない理由がある時にのみ、 利用するようにしてください。

[source,shell]
....
# dd if=/dev/zero of=/dev/da1 bs=1k count=1
# fdisk -BI da1 # 新しいディスクの初期化
# disklabel -B -w -r da1s1 auto # ディスクにラベルを付ける
# disklabel -e da1s1 # 作成したディスクラベルを編集し、パーティションを追加する
# mkdir -p /1
# newfs /dev/da1s1e # 作成したすべてのパーティションに対してこれを繰り返す
# mount /dev/da1s1e /1 # パーティションをマウントする
# vi /etc/fstab # /etc/fstab に適切なエントリを追加する
....

IDE ディスクを使う場合は [.filename]#da# の部分を [.filename]#ad# とします。4.X より前のシステムでは、 (訳注: [.filename]#ad# ではなく) [.filename]#wd# としてください。

==== 専用モード

新しいドライブを他の OS と共有しない場合には `専用` モードを用いることもできます。 このモードはマイクロソフトの OS を混乱させることを憶えておいてください (しかし、それらによって壊されることはありません)。 一方、IBM の OS/2(R) はどんなパーティションでも見つけたら理解できなくても "専有" します。

[source,shell]
....
# dd if=/dev/zero of=/dev/da1 bs=1k count=1
# disklabel -Brw da1 auto
# disklabel -e da1 # `e' パーティションの作成
# newfs -d0 /dev/da1e
# mkdir -p /1
# vi /etc/fstab # /dev/da1e エントリの追加
# mount /1
....

もう一つの方法は次の通り。

[source,shell]
....
# dd if=/dev/zero of=/dev/da1 count=2
# disklabel /dev/da1 | disklabel -BrR da1 /dev/stdin
# newfs /dev/da1e
# mkdir -p /1
# vi /etc/fstab # /dev/da1e エントリの追加
# mount /1
....

[NOTE]
====
FreeBSD 5.1-RELEASE から、従来の man:disklabel[8] プログラムは man:bsdlabel[8] ユーティリティに置き換えられました。man:bsdlabel[8] では、 使用されていない数多くのオプションやパラメタが削除されました。 たとえば `-r` オプションは man:bsdlabel[8] では取り除かれました。詳細については man:bsdlabel[8] のマニュアルページを参照してください。
====

[[raid]]
== RAID

[[raid-soft]]
=== ソフトウェア RAID

[[ccd]]
==== Concatenated Disk Driver (CCD) の設定

大容量記録に関する解決法を選択する際にもっとも重視すべき要素は、 速度、信頼性、そして費用です。 三つを同時にバランスよく実現することは稀です。 通常、速くて信頼性のある大容量記録装置は高価であり、 費用を抑えようとすると速度または信頼性のどちらかが犠牲になります。

ここで例にあげるシステムの設計においては、 費用が最も重要な要素として、次に速度、最後に信頼性が選択されています。 このシステムでのデータ転送速度は結局のところネットワークによって制限されます。 信頼性は大変重要です。ただし、以下で説明する CCD ドライブは、 データ自体はすでに CD-R に完全にバックアップしてあるもの (したがって交換は簡単にできます) の、オンラインデータの役割をさせています。

あなた自身の要求事項を決定することは、 大容量記録に関する解決法を選択することの最初の段階です。 もしあなたの要求事項が費用より速度または信頼性を優先するなら、 解決法はこのシステムとは違うものになるでしょう。

[[ccd-installhw]]
===== ハードウェアのインストール

IDE システムディスクに加えて、Western Digital 製の 30GB, 5400RPM の IDE ディスク三台を使って、 以下に説明されているような約 90GB のオンラインストレージとなる CCD ディスクを作成しました。各 IDE ディスクがそれぞれの IDE コントローラとケーブルをもっていることが理想的ですが、 費用を最低限にするために、 IDE コントローラを追加していません。その代わり、それぞれの IDE コントローラがマスタデバイスを一つ、 スレーブデバイスを一つ持つように、 ディスクはジャンパを使って設定されています。

再起動の際に、システム BIOS が接続されたディスクを自動的に検出するように設定されました。 より重要なことは、FreeBSD が再起動の際にそれらを検出することです。

[.programlisting]
....
ad0: 19574MB <WDC WD205BA> [39770/16/63] at ata0-master UDMA33
ad1: 29333MB <WDC WD307AA> [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB <WDC WD307AA> [59598/16/63] at ata1-master UDMA33
ad3: 29333MB <WDC WD307AA> [59598/16/63] at ata1-slave UDMA33
....

[NOTE]
====
FreeBSD がディスクをすべて検出しないときは、 ジャンパを正しく設定してあるか確認してください。多くの IDE ドライブは "ケーブルセレクト" ジャンパを持っています。 これはマスタ/スレーブの関係を設定するジャンパでは _ありません_。ドライブの文書を参照して、 正しいジャンパ設定を見つけてください。
====

次に、ファイルシステムの一部分として、 それらをどのように接続するのかを考慮します。man:vinum[8]  および man:ccd[4] の両方を検討すべきでしょう。この設定では、man:ccd[4] を選択しました。

[[ccd-setup]]
===== CCD の設定

man:ccd[4] ドライバは、いくつかの同じディスクを使って、 一つの論理的ファイルシステムに連結することができます。 man:ccd[4] を使用するためには、カーネルが man:ccd[4] に対応している必要があります。 次の行をカーネルコンフィギュレーションファイルに追加して、 カーネルを再構築し、再インストールしてください。

[.programlisting]
....
pseudo-device   ccd     4
....

5.X システムでは、 上記の代わりに次の行を追加しなければなりません。

[.programlisting]
....
device   ccd
....

[NOTE]
====
FreeBSD 5.X では man:ccd[4] デバイスの数を指定する必要はありません。man:ccd[4] デバイスドライバは自己複製するようになりました - 新しいデバイスインスタンスは、 必要に応じてその都度自動的に作成されます。
====

FreeBSD 3.0 以降では、 カーネルモジュールを読み込んで man:ccd[4] に対応することもできます。

man:ccd[4] を設定するために、まず man:disklabel[8] を使用してディスクにラベルを書き込まなくてはなりません。

[.programlisting]
....
disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto
....

このコマンドはディスク全体を示す [.filename]#ad1c#, [.filename]#ad2c# および [.filename]#ad3c# に対するディスクラベルを作成します。

[NOTE]
====
FreeBSD 5.1-RELEASE から、従来の man:disklabel[8] プログラムは man:bsdlabel[8] ユーティリティに置き換えられました。man:bsdlabel[8] では、 使用されていない数多くのオプションやパラメタが削除されました。 たとえば `-r` オプションは man:bsdlabel[8] では取り除かれました。詳細については man:bsdlabel[8] のマニュアルページを参照してください。
====

次に、ディスクラベルのタイプを変更します。 man:disklabel[8] を使用してディスクラベルを編集してください。

[.programlisting]
....
disklabel -e ad1
disklabel -e ad2
disklabel -e ad3
....

このコマンドは `EDITOR` 環境変数に設定されているエディタ (一般的には man:vi[1]) でそれぞれのディスクの現在のディスクラベルを開きます。

変更されていないディスクラベルは以下のようになります。

[.programlisting]
....
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
....

man:ccd[4] で使用する `e` パーティションを作成します。通常では `c` パーティションの行をコピーすれば良いでしょう。しかし、 `fstype` は `4.2BSD` でなければ _なりません_。 ディスクラベルは以下のようになるでしょう。

[.programlisting]
....
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)
....

[[ccd-buildingfs]]
===== ファイルシステムの構築

[.filename]#ccd0c# デバイスノードはまだ存在していないかも知れません。 そのときは、次のコマンドを実行して作成してください。

[.programlisting]
....
cd /dev
sh MAKEDEV ccd0
....

[NOTE]
====
FreeBSD 5.0 では man:devfs[5] が [.filename]#/dev# 以下のデバイスノードを自動的に管理するので、 ``MAKEDEV``を使用する必要はありません。
====

すべてのディスクにラベルを書き込んだので、 man:ccd[4] を構築してください。 これを行うためには、以下のようなオプションで man:ccdconfig[8] を使います。

[.programlisting]
....
ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e
....

各オプションの使用法と意味は以下の通りです。
* 一番目の引数は設定するデバイスです。この例の場合は [.filename]#/dev/ccd0c# です。 [.filename]#/dev/# の部分はオプションです。
* ファイルシステムに対するインタリーブです。インタリーブは、 ディスクブロック内のストライプサイズを定義します。 ディスクブロックは通常 512 バイトです。したがって 32 インタリーブは 16,384 バイトとなります。
* これは man:ccdconfig[8] に対するフラグです。 ドライブミラーリングを有効にしたい場合、 ここにフラグを指定します。 この設定では man:ccd[4] に対するミラーリングは提供しませんので、 0 (ゼロ) を指定しています。
* この man:ccdconfig[8] に対する最後の引数は、 アレイ内に置くデバイスです。 それぞれのデバイスに対する完全なパス名を使用します。

man:ccdconfig[8] を実行すると man:ccd[4] が設定されます。 これでファイルシステムをインストールすることが可能です。 オプションについて man:newfs[8] を参照するか、 次のように実行してください。

[.programlisting]
....
newfs /dev/ccd0c
....

[[ccd-auto]]
===== 自動的に設定する

一般的に、再起動するたびに man:ccd[4] をマウントしたいと思うでしょう。これを行うために、 まず設定をしなければなりません。次のコマンドを用いて、 現在の設定を [.filename]#/etc/ccd.conf# に書き出します。

[.programlisting]
....
ccdconfig -g > /etc/ccd.conf
....

[.filename]#/etc/ccd.conf# が存在すると、 再起動の際に `/etc/rc` スクリプトが `ccdconfig -C` を実行します。これにより、 man:ccd[4] は自動的に設定された後、マウントされます。

[NOTE]
====
シングルユーザモードで起動している場合には、 man:ccd[4] を man:mount[8] する前に、 アレイを設定するために次のコマンドを実行する必要があります。

[.programlisting]
....
ccdconfig -C
....

====

自動的に man:ccd[4] をマウントするには、 [.filename]#/etc/fstab# に man:ccd[4] のエントリ追加します。このように設定すると起動時にマウントされます。

[.programlisting]
....
/dev/ccd0c              /media       ufs     rw      2       2
....

[[vinum]]
==== Vinum ボリュームマネージャ

Vinum ボリュームマネージャは、 仮想ディスクドライブを実装したブロックデバイスドライバです。 Vinum は、ディスクハードウェアをブロックデバイスインタフェースから 分離し、データを配置します。 その結果、ディスク記憶装置を従来のスライスで扱うのと比較して、 柔軟性、性能および信頼性が向上しています。 man:vinum[8] は RAID-0, RAID-1 および RAID-5 モデル、 そしてそれぞれの組合せを実装しています。

man:vinum[8] の詳細については Vinum ボリュームマネジャ  を参照してください。

[[raid-hard]]
=== ハードウェア RAID

FreeBSD は、さまざまなハードウェア RAID コントローラにも対応しています。これらのデバイスはアレイを制御するための 特別なソフトウェアを FreeBSD で必要することなく、 RAID サブシステムを制御します。

カード上の BIOS を使用して、 カードはそれ自身でディスク操作のほとんどを制御します。以下は Promise IDE RAID コントローラを使用した設定の簡単な説明です。 このカードがインストールされ、システムが起動したときには、 情報の入力を促すプロンプトを表示します。 指示にしたがってカードの設定画面に進んでください。 接続されたドライブを組み合わせるように設定することができます。 設定後、ディスクは FreeBSD に対して単一のドライブのように見えます。 他の RAID レベルは適宜設定できます。

=== ATA RAID1 アレイの再構築

FreeBSD はアレイ内の障害ディスクを動作中に交換できます。 ただし、再起動前にそれを検知していることが必要です。

[.filename]#/var/log/messages# または man:dmesg[8] の出力に次のような行があるでしょう。

[.programlisting]
....
ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11) status=59 error=40
ar0: WARNING - mirror lost
....

man:atacontrol[8] を使用して詳細を調べてください。

[source,shell]
....
# atacontrol list
ATA channel 0:
	Master:      no device present
	Slave:   acd0 <HL-DT-ST CD-ROM GCR-8520B/1.00> ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
	Slave:       no device present

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED
....

[.procedure]
====

. ディスクを安全に取り外すために、 まずアレイから切り離します。
+
[source,shell]
....
# atacontrol detach 3
....
+
. ディスクを取り外します。
. スペアのディスクを取り付けます。
+
[source,shell]
....
# atacontrol attach 3
Master:  ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
Slave:   no device present
....
+
. アレイを再構築します。
+
[source,shell]
....
# atacontrol rebuild ar0
....
+
. 再構築コマンドは完了するまで他の操作を受け付けません。しかし、 もう一つ別のターミナルを (kbd:[Alt+Fn] を押して) 開き、 次のコマンドを実行すると進行状態を確認することができます。
+
[source,shell]
....
# dmesg | tail -10
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed
....
+
. 操作が完了するまでお待ちください。
====

[[creating-cds]]
== 光メディア (CD & DVD) の作成と使用

=== はじめに

CD は他の一般的なディスクと異なる様々な特徴を持っています。 そもそもユーザが書き込むことができません。 また遅延なしで連続的に読み出せるように、 トラック間をヘッドが移動しないですむようにデザインされています。 さらにこのサイズのメディアの中ではシステムをまたぐデータの 移動が比較的簡単でもあります。

CD はトラックの概念を持っていますが、 これはデータを連続的に読み出すためのものであってディスクの物理特性ではありません。 FreeBSD で CD を作成するには、まず CD のトラックとなるデータファイルを用意し、 そのトラックを CD に書き込みます。

ISO 9660 ファイルシステムはこの様な差異を扱うべく設計されました。 その結果、ファイルシステムは一般的に使用するのに差しつかえない程度に 制限されて標準化されています。幸いなことに、ISO 9660 ファイルシステムには拡張機構が提供されています。適切に書かれた CD は、 拡張機構に対応したシステムでは拡張を利用して、そうでないシステムでは 拡張機構を使用しない範囲で動作するようになっています。

package:sysutils/mkisofs[] プログラムは ISO 9660 ファイルシステムを含むデータファイルを作成するのに使われます。 これには様々な拡張をサポートするオプションがあり、 以下で説明します。 このソフトウェアは、ports の package:sysutils/mkisofs[] からインストールすることができます。

CD に書き込むためのツールは、お使いの CD ライタが ATAPI 接続か否かにも依存します。ATAPI CD ライタなら、ベースシステムの一部である `burncd` プログラムを使います。SCSI や USB の CD ライタなら、ports の package:sysutils/cdrecord[] をインストールして `cdrecord` プログラムを使うべきでしょう。

`burncd` が対応しているドライブは限定されています。 ドライブが対応されているかどうかを確認するには、 http://www.freebsd.dk/ata/[CD-R/RW supported drives] にある一覧を見てください。

[NOTE]
====
FreeBSD 5.X または FreeBSD 4.8-RELEASE 以降のバージョンを使用している場合、 <<atapicam,ATAPI/CAM モジュール>> を使用すると ATAPI ハードウェア上で SCSI ドライブ用の `cdrecord` および他のツールを使用できるようになります。
====

[[mkisofs]]
=== mkisofs

package:sysutils/mkisofs[] は UNIX(R) ファイルシステムの名前空間におけるディレクトリツリーのイメージとして ISO 9660 ファイルシステムを作成します。 最も簡単な使い方は以下の通りです。

[source,shell]
....
# mkisofs -o imagefile.iso /path/to/tree
....

このコマンドは _/path/to/tree_ 以下のディレクトリツリーのコピーである ISO 9660 ファイルシステムを含んだ _imagefile.iso_ ファイルを作成します。この過程において、ファイル名は標準的な ISO 9660 ファイルシステムの制限に適合するようなファイル名に対応づけられ、 ISO ファイルシステムでファイル名を文字化できないファイルは除外されます。

この制限を回避するために利用できるオプションはいくつもあります。 特に `-R` オプションは UNIX(R) システムで標準的な Rock Ridge 拡張を有効にします。`-J` オプションは Microsoft のシステムで標準的な Joliet 拡張を有効にし、 `-hfs` オプションは Mac OS(R) で使用されている HFS ファイルシステムを作成するために使われます。

FreeBSD でしか使わないのであれば、`-U` オプションを使用するとあらゆるファイル名制限を無効にできます。 さらに `-R` オプションとともに使うことで FreeBSD と同一のファイルシステムイメージを作成できますが、 これは ISO 9660 標準の多くを無視しています。

一般的に使われる最後のオプションは `-b` オプションです。 これは "El Torito" ブータブル CD を作成するのに使う起動イメージのありかを指定します。 このオプションは引数として起動イメージへのパスを、 CD に書き込まれるディレクトリツリーの頂点からの相対位置で取ります。 したがって [.filename]#/tmp/myboot# がブート可能な FreeBSD システムで [.filename]#/tmp/myboot/boot/cdboot# にブートイメージがあるならば、以下のようにすることで ISO 9660 ファイルシステムのイメージを [.filename]#/tmp/bootable.iso# に作成することができます。

[source,shell]
....
# mkisofs -U -R -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot
....

この後、カーネルで [.filename]#vn# (FreeBSD 4.X) または [.filename]#md# (FreeBSD 5.X) が設定されていれば、 ファイルシステムを以下のようにしてマウントすることができます。

[source,shell]
....
# vnconfig -e vn0c /tmp/bootable.iso
# mount -t cd9660 /dev/vn0c /mnt
....

FreeBSD 4.X および FreeBSD 5.X に対しては以下の通りです。

[source,shell]
....
# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

[.filename]#/mnt# と [.filename]#/tmp/myboot# が同一かどうか確認してください。

package:sysutils/mkisofs[] には挙動を細かく制御するために他にもたくさんのオプションがあります。 特に、ISO 9660 レイアウトの変更や Joliet および HFS ディスク作成などの 詳細は man:mkisofs[8] のマニュアルページをご覧ください。

[[burncd]]
=== burncd

あなたが持っているのが ATAPI CD ライタなら、CD に ISO イメージを書き込むために `burncd` コマンドが使えます。 `burncd` はベースシステムの一部で [.filename]#/usr/sbin/burncd# としてインストールされています。 使い方はとても単純でオプションも少ししかありません。

[source,shell]
....
# burncd -f cddevice data imagefile.iso fixate
....

以上のコマンドは _imagefile.iso_ のコピーを _cddevice_ に書き込みます。 デフォルトのデバイスは [.filename]#/dev/acd0c# です。 書き込み速度や操作完了後に CD を自動的に取り出す方法、 オーディオデータの書き込みなどのオプションについては man:burncd[8] を見てください。

[[cdrecord]]
=== cdrecord

あなたが持っている CD ライタが ATAPI ではなければ、 CD を書き込むのに `cdrecord` を使う必要があります。 `cdrecord` はベースシステムの一部ではなく、 package:sysutils/cdrtools[] の port または 適切な package を利用してインストールしなければなりません。 なお、ベースシステムを変更するとバイナリに矛盾が発生し、 "コースター" を作ってしまうおそれがあります。 したがって、システムをアップグレードする度にこの port も作り直すか、  あるいは FreeBSD の安定版を追いかけているのならば、 新しいバージョンが利用できるようになった時に ports をアップグレードする必要があります。

`cdrecord` にはたくさんのオプションがありますが、 基本的な使い方は `burncd` よりもさらに簡単です。 ISO 9660 イメージを書き込むには以下のようにします。

[source,shell]
....
# cdrecord dev=device imagefile.iso
....

`cdrecord` のトリッキーな部分は、使用する `dev` を見つけるところにあります。 適切な設定を見つけるためには `cdrecord` の `-scanbus` フラグを使います。 たとえば、以下のような結果が出力されるでしょう。

[source,shell]
....
# cdrecord -scanbus
Cdrecord 1.9 (i386-unknown-freebsd4.2) Copyright (C) 1995-2000 Jörg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *
....

リストにあるデバイスに対する適切な `dev` の値がここに示されています。あなたの CD ライタをこのリストから見つけ、 カンマで区切られた 3 つの数値を `dev` の値として使ってください。この例では CRW デバイスは 1,5,0 なので、適切な入力は `dev=1,5,0` となります。 値を明示するもっと簡単な方法もあります。詳細は man:cdrecord[1] を見てください。そこにはオーディオトラックを書き込む方法や、 書き込み速度その他を操作する方法も書かれています。

[[duplicating-audiocds]]
=== オーディオ CD の複製

CD からオーディオデータを連続したファイルに展開し、ブランク CD にこれらのファイルを書き込むことで、オーディオ CD を複製することができます。 この手順は ATAPI および SCSI ドライブの間で少し異なります。

[.procedure]
====
*Procedure: SCSI ドライブ*

. `cdda2wav` を使用してオーディオを展開します。
+
[source,shell]
....
% cdda2wav -v255 -D2,0 -B -Owav
....
+
. `cdrecord` を使用して [.filename]#.wav# ファイルに書き出します。
+
[source,shell]
....
% cdrecord -v dev=2,0 -dao -useinfo  *.wav
....
+ 
<<cdrecord>> に説明されているように _2.0_ が適切に指定されていることを確かめてください。
====

[.procedure]
====
*Procedure: ATAPI ドライブ*

. ATAPI CD ドライバでは、それぞれのトラックを [.filename]#/dev/acddtnn# のように利用できます。 ここで _d_ はドライブ番号であり、 _nn_ は二桁十進のトラック番号です。 一桁の場合 0 を前に付加する必要があります。 したがって、一番目のディスクの一番目のトラックは [.filename]#/dev/acd0t01#、二番目のトラックは [.filename]#/dev/acd0t02#、三番目のトラックは [.filename]#/dev/acd0t03# などとなります。
+ 
適切なデバイスファイルが [.filename]#/dev# に存在することを確かめてください。 存在しなければ、たとえば次のようにして作成します。
+
[source,shell]
....
# cd /dev
# sh MAKEDEV acd0t99
....
+
[NOTE]
======
FreeBSD 5.0 では man:devfs[5] が [.filename]#/dev# にエントリを自動的に作成、 管理するので、`MAKEDEV` を使用する必要はありません。
======
+
. man:dd[1] を使用して各トラックを展開します。 ファイルを展開する際、ブロックサイズを指定しなければなりません。
+
[source,shell]
....
# dd if=/dev/acd0t01 of=track1.cdr bs=2352
# dd if=/dev/acd0t02 of=track2.cdr bs=2352
...
....
+
. `burncd` を使用して、 展開したファイルをディスクに書き込みます。 これらがオーディオファイルであること、 そして書き込みが終了したときに `burncd` がディスクを固定 (fixate) することを明示しなければなりません。
+
[source,shell]
....
# burncd -f /dev/acd0c audio track1.cdr track2.cdr ... fixate
....
====

[[imaging-cd]]
=== データ CD の複製

データ CD を、package:sysutils/mkisofs[] を用いて作成されたイメージファイルと機能的に等価なイメージファイルにコピーできます。 これを使用して、すべてのデータ CD を複製することができます。 ここでの例は CDROM デバイスが [.filename]#acd0# であるとしています。あなたの CDROM デバイスに読み替えてください。 CDROM の場合には、パーティション全体またはディスク全体 を指定するために `c` をデバイス名の後に追加しなければなりません。

[source,shell]
....
# dd if=/dev/acd0c of=file.iso bs=2048
....

これでディスクイメージを取り出すことができました。 すでに説明した方法を用いて CD に書き込むことができます。

[[mounting-cd]]
=== データ CD の使用

さて、標準的なデータ CDROM を作成したので、 おそらく次はそれをマウントしてデータを読み出したいと思うでしょう。 デフォルトでは man:mount[8] は、ファイルシステムタイプを `ufs` としています。 次のように実行しようとすると、

[source,shell]
....
# mount /dev/cd0c /mnt
....

`Incorrect super block` というエラーが返されてマウントできないでしょう。 CDROM は `UFS` ファイルシステムではないために、 このような手順でマウントしようすると失敗します。 ファイルシステムのタイプが `ISO9660` であると man:mount[8] に教えさえすれば、すべてはうまく動作します。 man:mount[8] に `-t cd9660` オプションを指定することでこれを行います。 たとえば [.filename]#/dev/cd0c# の CDROM デバイスを [.filename]#/mnt# にマウントしたい場合は、 以下のように実行します。

[source,shell]
....
# mount -t cd9660 /dev/cd0c /mnt
....

使用している CDROM インタフェースによっては、 デバイス名 (この例では [.filename]#/dev/cd0c#) が異なるかもしれないことに注意してください。 また、`-t cd9660` オプションは、単に man:mount_cd9660[8] を実行します。 この例を以下のように短縮することもできます。

[source,shell]
....
# mount_cd9660 /dev/cd0c /mnt
....

一般的にこの方法では、すべてのメーカの データ CDROM を使用することができます。しかしながら、特定の ISO 9660 拡張が施されたディスクでは奇妙な動作をするかもしれません。 たとえば Joliet ディスクは、 すべてのファイル名を 2 バイトの Unicode 文字で格納します。 FreeBSD カーネルは (まだ) Unicode を理解できないので、 非英語文字はクエスチョンマークで表示されます (FreeBSD 4.3 以降を使用している場合、CD9660 ドライバには適切な Unicode 変換表を読み込むための急ごしらえのフックが含まれています。 いくつかの共通のエンコードに対するモジュールは package:sysutils/cd9660_unicode[] port から利用可能です)。

CDROM をマウントしようとする時に、 `Device not configured` と表示されるかもしれません。これは、ディスクがトレーにないと CDROM ドライブが判断しているか、 ドライブがバス上に認識できないことを通常意味します。 ディスクが挿入されたことを CDROM ドライブが認識するには数秒かかりますので、 辛抱強く待ってください。

バスのリセットに返答するためのタイムアウトが短いために、時々 SCSI CDROM は認識に失敗するかもしれません。SCSI CDROM を持っている場合は、 次のオプションをカーネルコンフィギュレーションファイルに追加して、 crossref:kernelconfig[kernelconfig-building,カーネルを再構築してください]。

[.programlisting]
....
options SCSI_DELAY=15000
....

これより、SCSI バスを起動時に 15 秒間停止させて、 CDROM ドライブがバスリセットに応答する機会を与えます。

[[rawdata-cd]]
=== Raw データ CD の書き込み

ISO 9660 ファイルシステムを作成すること無く、 ファイルを直接 CD に書き込むこともできます。 この方法をバックアップ目的に使用している人もいます。 これは、標準 CD を書き込むよりもさらに速く実行することができます。

[source,shell]
....
# burncd -f /dev/acd1c -s 12 data archive.tar.gz fixate
....

このように CD に書き込まれたデータを取得するには、 raw デバイスノードからデータを読み込まなくてはなりません。

[source,shell]
....
# tar xzvf /dev/acd1c
....

このディスクを通常の CDROM としてマウントすることはできません。 このような CDROM は FreeBSD を除いて、 他のすべてのオペレーティングシステムでは読み込むことはできません。 CD をマウントしたいか、 その他のオペレーティングシステムとデータを共有したい場合は、 上記に説明したように package:sysutils/mkisofs[] を使用しなくてはなりません。

[[atapicam]]
=== ATAPI/CAM ドライバの使用

このドライバは、ATAPI デバイス (CD-ROM, CD-RW, DVD ドライブなど) へ SCSI サブシステムを通じてアクセスすることを可能にします。 これにより、package:sysutils/cdrdao[] または man:cdrecord[1] のようなアプリケーションが使用できるようになります。

このドライバを使用するためには、 カーネルコンフィギュレーションファイルに次の行を追加する必要があります。

[.programlisting]
....
device atapicam
device scbus
device cd
device pass
....

次の行もカーネルコンフィギュレーションファイルに必要です。

[.programlisting]
....
device ata
device atapicd
....

両方がすでに存在しなければなりません。

それから再構築し、新しいカーネルをインストールし、 コンピュータを再起動します。 起動プロセス中にディスクライタは以下のように表示されるでしょう。

[source,shell]
....
acd0: CD-RW <MATSHITA CD-RW/DVD-ROM UJDA740> at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: <MATSHITA CDRW/DVD UJDA740 1.00> Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed
....

ドライブは [.filename]#/dev/cd0# デバイスを通じてアクセスすることが可能となります。 たとえば、次のようにして CD-ROM を [.filename]#/mnt# にマウントします。

[source,shell]
....
# mount -t cd9660 /dev/cd0c /mnt
....

`root` 権限で次のコマンドを実行して、 ライタの SCSI アドレスを得ることができます。

[source,shell]
....
# camcontrol devlist
<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (pass0,cd0)
....

したがって、`1,0,0` が man:cdrecord[1] およびその他の SCSI アプリケーションで使用する SCSI アドレスです。

ATAPI/CAM および SCSI システムの詳細は man:atapicam[4] および man:cam[4] マニュアルページを参照してください。

[[floppies]]
== フロッピーディスクの作成と使用

フロッピーディスクにデータを格納することはしばしば役にたちます。 たとえば、ある人が他のリムーバブル記録メディアを何も持っていないときや、 小さなデータを他のコンピュータに移動させる必要があるときです。

この節では、FreeBSD におけるフロッピーディスクの使用方法を説明します。 主に 3.5 インチの DOS フロッピーのフォーマットと操作方法を扱いますが、 他のフロッピーディスクの形式についても概念は似ています。

=== フロッピーのフォーマット

==== デバイス

他のデバイスと同様に、フロッピーディスクは [.filename]#/dev# にあるエントリを通じてアクセスされます。4.X およびそれ以前のリリースにおいて raw フロッピーディスクにアクセスするには [.filename]#/dev/fdN# または [.filename]#/dev/fdNX# を使用します。_N_ はドライブ番号を表し、 大抵は 0 です。_X_ は文字を表します。

5.0 およびそれ以降のリリースでは、単に [.filename]#/dev/fdN# を使用します。

===== 4.X およびそれ以前のリリースでのディスクサイズ

[.filename]#/dev/fdN.size# というデバイスもあります。 _size_ はフロッピーディスクのサイズをキロバイトで示したものです。 これらのエントリは低レベルフォーマットの際に、 ディスクサイズを決定するのに使用されます。 1440kB は以下の例で使用されるサイズです。

時々 [.filename]#/dev# 下のエントリは (再) 作成されなければなりません。次のコマンドでこれを行います。

[source,shell]
....
# cd /dev && ./MAKEDEV "fd*"
....

===== 5.X およびそれ以降のリリースでのディスクサイズ

FreeBSD 5.0 では man:devfs[5] が [.filename]#/dev# 内のエントリを自動的に管理するので、 ``MAKEDEV``を使用する必要はありません。

所望のディスクサイズは man:fdformat[1] に `-f` フラグを通して渡されます。対応しているサイズは man:fdcontrol[8] のマニュアルページに掲載されていますが、最良に動作するのは 1440kB だと助言しておきます。

==== フォーマット

フロッピーディスクは、 使用前に低レベルフォーマットをする必要があります。 通常、ベンダは低レベルフォーマット済みのディスクを出荷していますが、 フォーマットはメディアの品質を確認するよい方法です。 より大きな (または小さな) ディスクサイズにすることも可能ですが、 ほとんどのフロッピーディスクのサイズは 1440kB で動作するように設計されています。

フロッピーディスクを低レベルフォーマットするには man:fdformat[1] を使用する必要があります。 このユーティリティは引数としてデバイス名を指定します。

ディスクが良好かあるいは不良であるかを決定するのに役立つので、 エラーメッセージをすべてメモに取っておいてください。

===== 4.X 以前のリリースでのフォーマット

[.filename]#/dev/fdN.size# デバイスを使ってフロッピーをフォーマットします。 新しい 3.5 インチフロッピーディスクをドライブに挿入し、 以下のコマンドを実行してください。

[source,shell]
....
# /usr/sbin/fdformat /dev/fd0.1440
....

===== 5.0 以降のリリースでのフォーマット

[.filename]#/dev/fdN# デバイスを使用してフロッピーをフォーマットします。 新しい 3.5 インチフロッピーディスクをドライブに挿入し、 以下のコマンドを実行してください。

[source,shell]
....
# /usr/sbin/fdformat -f 1440 /dev/fd0
....

=== ディスクラベル

ディスクを低レベルフォーマットしたら、 次にディスクラベルを作成する必要があります。 ディスクラベルは後で破棄されますが、 システムがディスクのサイズとジオメトリを決定するのに必要になります。

新しいディスクラベルはディスク全体を引き継ぎ、 フロッピーのジオメトリに関する適切な情報のすべてが含まれます。 ディスクラベルに対するジオメトリの値は [.filename]#/etc/disktab# に掲載されています。

次のように man:disklabel[8] を実行できます。

[source,shell]
....
# /sbin/disklabel -B -r -w /dev/fd0 fd1440
....

[NOTE]
====
FreeBSD 5.1-RELEASE から、従来の man:disklabel[8] プログラムは man:bsdlabel[8] ユーティリティに置き換えられました。man:bsdlabel[8] では、 使用されていないオプションおよびパラメタの数多くが削除されました。 たとえば `-r` オプションは man:bsdlabel[8] では取り除かれました。詳細については man:bsdlabel[8] マニュアルページを参照してください。
====

=== ファイルシステム

これでフロッピーを高レベルフォーマットする準備ができました。これは FreeBSD がディスクを読み書きする新しいファイルシステムを作成します。 新しいファイルシステムを作成するとディスクラベルは破棄されます。 したがって、ディスクを再フォーマットするときには、 ディスクラベルを再作成しなくてはなりません。

フロッピーのファイルシステムには UFS または FAT を使用できます。 フロッピーに対しては FAT が一般的によりよい選択です。

フロッピー上に新しいファイルシステムを作成するには次のようにします。

[source,shell]
....
# /sbin/newfs_msdos /dev/fd0
....

これでディスクが使用できるようになりました。

=== フロッピーの使用

フロッピーを使用するために、man:mount_msdos[8] (4.X 以前のリリース) または man:mount_msdosfs[8] (5.0 以後のリリース) を用いてマウントします。 Ports Collection から package:emulators/mtools[] を使用することもできます。

[[backups-tapebackups]]
== データテープの作成と使用

一般的なテープメディアには 4mm, 8mm, QIC, ミニカートリッジ、 DLT があります。

[[backups-tapebackups-4mm]]
=== 4mm (DDS: Digital Data Storage)

4mm テープはワークステーションのバックアップメディアとして QIC に取って代わりつつあります。この傾向は QIC ドライブの主要なメーカであった Archive を Conner が買収し QIC ドライブの製造を中止したことで加速しました。 4mm ドライブは小型で静かですが 8mm ドライブが持っている信頼性ほど、その評判は良くありません。 また、4mm カートリッジは 8mm カートリッジよりも安価で小型 (3 x 2 x 0.5 インチ、76 x 51 x 12 mm) になっています。 ただし、8mm と同様に、4mm のヘッドはヘリカルスキャン方式 (訳注: VTR と同様の回転ヘッドを使う方式) を採用しているため、比較的寿命が短いです。

ドライブのデータスループットは、150 kB/s から 最大で 500 kB/s 程度です。 データ容量は 1.3 GB から 2.0 GB です。 ドライブのほとんどで利用可能なハードウェア圧縮を使用すると、 容量が約 2 倍になります。 マルチドライブテープライブラリユニットは 1 つの筐体に 6 つのドライブを収容可能で、自動的にテープの交換ができます。 ライブラリの容量は 240 GB に達します。

現在の DDS-3 標準は 12 GB (圧縮時 24 GB) までのテープ容量に対応しています。

8mm ドライブと同様に 4mm ドライブはヘリカルスキャンを使用します。 ヘリカルスキャン方式の利点および欠点はすべて 4mm および 8mm ドライブの両方に当てはまります。

テープは 2,000 回のパスあるいは 100 回フルバックアップした後には交換するべきです。

[[backups-tapebackups-8mm]]
=== 8mm (Exabyte)

8mm テープは SCSI テープドライブとして最もよく使われているもので、 データ交換用として最良の選択です。ほとんどのサイトには Exabyte 2 GB 8mm テープドライブがあるでしょう。8mm ドライブは信頼性が高く、使いやすく、静かです。 カートリッジは安価で小型です (4.8 x 3.3 x 0.6 インチ、122 x 84 x 15 mm)。8mm テープの欠点は、テープとヘッドの相対的な速度が高速なために、 比較的ヘッドとテープの寿命が短いことです。

データスループットは 250 kB/s から 500 kB/s 程度です。データ容量は 300 MB から 7 GB です。 ほとんどのドライブで利用可能なハードウェア圧縮を利用すると、 容量が約 2 倍になります。 これらのドライブは、単一のユニットから 6 つのドライブと 120 本のテープを一つの筐体に収容したマルチドライブテープライブラリまで利用可能です。 テープはユニットによって自動的に取り換えられます。 ライブラリの容量は 840 GB 以上に達します。

Exabyte の "Mammoth" モデルはテープ 1 本あたり 12 GB (圧縮時 24 GB) に対応し、 従来のテープドライブと比べ費用は約 2 倍になります。

データはヘリカルスキャンを用いてテープに記録されます。 ヘッダはメディアに対してある傾き (約 6 度) に配置されます。 テープはヘッドのある円筒の周の 270 度にわたって接触します。 テープが円筒面を走行する間、円筒は回転しています。 この結果、高密度のデータのつまったトラックは、 狭い間隔でテープの上端と下端の間を斜めに横切ります。

[[backups-tapebackups-qic]]
=== QIC

QIC-150 テープとドライブは、 おそらく最も一般的に使われているドライブとメディアでしょう。 QIC テープドライブは "現実的な" バックアップドライブとしては最も高価でないものです。 欠点はメディアのコストです。QIC テープは 8mm や 4mm テープと比較して GB あたりのデータの保存で 5 倍ほど高価です。 しかし、あなたの必要とする量が半ダース程のテープで十分であれば、 QIC は正しい選択かもしれません。QIC は __最も__一般的なテープドライブです。 すべてのサイトに QIC ドライブのどれかの容量のものがあります。問題は、 QIC は同じようなテープ (まったく同じ場合もある) に多様な記録密度があることです。QIC ドライブは静かではありません。 これらのドライブはデータ記録を開始する前に音をたててシークしますし、 リード、ライト、シークの時にはっきりと聞こえる音を出します。 QIC テープの大きさは (6 x 4 x 0.7 インチ、152 x 102 x 17 mm) です。 1/4 インチ幅のテープも使用している <<backups-tapebackups-mini,ミニカートリッジ>> は別に議論します。テープライブラリやチェンジャはありません。

データスループットは ~1500 kB/s から ~5000 kB/s 程度です。データ容量は 400 MB から 150 GB です。 ハードウェア圧縮が最近のドライブの多くで利用できます。 QIC ドライブは DAT ドライブに置き換えられつつあり、 あまり頻繁には使用されなくなっています。

データは複数のトラックに分かれてテープに記録されます。 トラックはテープメディアの長さ方向の一端からもう一方の端までです (訳注: 1 トラックの read/write が終わるとテープの走行方向を反転させ 次のトラックの read/write を行います)。トラックの数と、 それに対応するトラックの幅はテープの容量によって変わります。 すべてではありませんが、 最近のドライブはほとんど、少なくとも読み出しについては (場合によっては書き込みも) 下位互換性があります。 QIC はデータの安全性についてはよいといわれています (ヘリカルスキャンドライブに比べて機構は単純でより丈夫です)。

テープは 5000 回のバックアップで寿命となるでしょう。

[[backups-tapebackups-mini]]
=== XXX* ミニカートリッジ

[[backups-tapebackups-dlt]]
=== DLT

DLT はここに示したドライブのタイプの中で最高速のデータ転送レートを発揮します。 1/2 インチ (12.5mm) テープが単リールのカートリッジ (4 x 4 x 1 インチ、100 x 100 x 25 mm) に入っています。 カートリッジのひとつの側面全体がスイングゲートになっています。 ドライブの機構がこのゲートを開け、テープリーダを引き出します。 テープリーダには楕円形の穴があり、 ドライブがテープを "引っ掛ける" のに使います。 巻き取りのためのリールはドライブの中にあります。 ここに挙げた他のカートリッジはすべて (9 トラックテープは唯一の例外です) 送り出しリールと巻き取りリールの両方がカートリッジの中にあります。

データスループットは約 1.5 MB/s で、4mm, 8mm, QIC テープドライブの 3 倍です。データ容量は単一のドライブで 10 GB から 20 GB の範囲です。マルチテープチェンジャ、 マルチテープドライブ、5 から 900 巻のテープを 1 から 20 ドライブで扱うマルチドライブテープライブラリがあり、 50 GB から 9 TB の容量が得られます。

圧縮によって、DLT Type IV フォーマットは 70 GB までの容量に対応しています。

データは (QICテープのように) テープの走行方向と平行に複数あるトラックへ記録されます。 2 つのトラックに同時書き込みを行います。 read/write ヘッドの寿命は比較的長いと言えます。 テープの走行が止まればヘッドとテープの間の相対運動は無いからです。

=== AIT

AIT は、Sony が発表した新しいフォーマットで、 テープ 1 本あたり 50 GB (圧縮時) まで格納できます。 テープにはメモリチップが搭載されており、 テープの内容の索引情報を保持しています。 他のテープではテープ上のファイルの位置を把握するのに数分必要とするのですが、 このテープドライブでは索引情報を読んで直ちに決定することができます。 SAMS:Alexandria のようなソフトウェアは、40 を超える ATI テープライブラリを操作できるのはもちろんのこと、 テープのメモリチップと直接通信して、スクリーンに内容を表示し、 どのファイルがどのテープにバックアップされたかを調べて、 正しいテープを見つけ、読み込み、 テープからデータを復元することができます。

このようなライブラリは大体 $20,000 くらいするので、 愛好家が購入できる価格帯からは外れてしまいます。

=== 新品のテープを初めて使う場合

全く新品の空テープを読もうとしたり書き込もうとすると、 処理は失敗するでしょう。 次のようなメッセージがコンソールに出力されるでしょう。

[source,shell]
....
sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready
....

テープに識別ブロック (Identifier Block:block number 0) がありません。QIC-525 標準を採用したすべての QIC テープドライブは識別ブロックをテープに書き込みます。 2 つの解決方法があります。

* `mt fsf 1` によりテープドライブはテープに識別ブロックを書き込みます。
* フロントパネルのボタンを押してテープを取り出します。
+ 
再びテープを挿入し、データをテープに `dump` します。
+ 
`dump` は `DUMP: End of tape detected` と報告し、 コンソールには `HARDWARE FAILURE info:280 asc:80,96` と表示されるでしょう。
+ 
`mt rewind` を使ってテープを巻戻します。
+ 
次からはテープの操作はうまくいくでしょう。

[[backups-floppybackups]]
== フロッピーディスクへのバックアップ

[[floppies-using]]
=== データをバックアップするのにフロッピーは使えますか?

フロッピーディスクは以下の理由によって、 実際にバックアップをつくるための適切なメディアではありません。

* メディアの信頼性が (特に長期間の場合) 低い。
* バックアップとリストアがとても遅い。
* 容量が非常に小さい (1 ダースかそこらのフロッピーディスクに ハードディスク全体をバックアップしていた時代は、 はるか遠くに過ぎ去りました)。

しかしながら、データをバックアップする他の手段がないのなら、 バックアップを取らないよりもフロッピーディスクを使う方がましでしょう。

フロッピーディスクを使用せざるを得ないときは、 品質のよいディスクを使用してください。 事務所のその辺に数年転がっていたフロッピーは使わない方が良いでしょう。 評判のよいメーカの新しいディスクを使用することが理想です。

[[floppies-creating]]
=== それではどうやってデータをフロッピーにバックアップするのですか?

フロッピーにバックアップする最もよい方法は、 `-M` (マルチボリューム) オプション付きで man:tar[1] コマンドを使用することです。これで、 複数のフロッピーにわたってバックアップすることが可能になります。

カレントディレクトリとサブディレクトリ内のすべてのファイルをバックアップするには、 以下のコマンドを (`root` 権限で) 使用します。

[source,shell]
....
# tar Mcvf /dev/fd0 *
....

1 枚目のフロッピーが一杯になると、 man:tar[1] は次のボリュームを挿入するように要求します (man:tar[1] はさまざまなメディアを扱えるので、 ボリュームと表示します。この文脈ではフロッピーディスクのことです)。

[source,shell]
....
Prepare volume 2 for /dev/fd0 and hit return:
....

指定したファイルがすべて保存されるまで (ボリューム番号を増やしながら) これが繰り返されます。

[[floppies-compress]]
=== バックアップを圧縮することはできませんか?

残念なことに man:tar[1] はマルチボリュームアーカイブに対して、 `-z` オプションを使うことができません。 もちろん、すべてのファイルを man:gzip[1] で圧縮し、 それらを man:tar[1] を用いてフロッピーに保存して、 それから再び man:gunzip[1] することはできます。

[[floppies-restoring]]
=== どのようにしてバックアップをリストアしたらいいのでしょうか?

すべてのアーカイブをリストアするには以下のようにします。

[source,shell]
....
# tar Mxvf /dev/fd0
....

特定のファイルだけをリストアするには 2 つの方法があります。 1 つ目は、1 枚目のフロッピーを用いて以下のようにするものです。

[source,shell]
....
# tar Mxvf /dev/fd0 filename
....

man:tar[1] ユーティリティは、 必要なファイルを見つけるまで次のディスクを挿入するように要求します。

もう 1 つは、 必要なファイルがどのフロッピーに保存されているか分かっている場合、 そのフロッピーを挿入して上記と同じコマンドを使用するだけでもよいです。 あるフロッピー上にある 1 番目のファイルが、 その前のフロッピーから続いている場合は、 そのファイルのリストアを要求していなくても man:tar[1] はそれをリストアできないと警告することに注意してください!

[[backup-basics]]
== バックアップの基本

主なバックアッププログラムは man:dump[8], man:tar[1], man:cpio[1] の三つです。

=== ダンプとリストア

伝統的な UNIX(R) のバックアッププログラムは `dump` と `restore` です。 これらはファイルシステムによって作成されるファイル、リンク、 ディレクトリといった抽象の下位にある、 ディスクブロックの集合としてドライブを操作します。 `dump` はデバイス上のファイルシステム全体をバックアップします。 ファイルシステムの一部分だけ、 または二つ以上のファイルシステムにわたるディレクトリツリーをバックアップすることはできません。 `dump` はファイルおよびディレクトリをテープに書き込まずに、 ファイルおよびディレクトリを含んだ raw データブロックを書き込みます。

[NOTE]
====
ルートディレクトリで `dump` を使った場合、 [.filename]#/home#, [.filename]#/usr# など、他の多くのディレクトリはバックアップされません。 これらのディレクトリは通常、 他のファイルシステムへのマウントポイントであったり、 シンボリックリンクとなっているためです。
====

`dump` には AT&T UNIX のバージョン 6 (およそ 1975 年) の初期から残っている癖があります。 デフォルトのパラメタは、現在利用可能な高密度メディア (最大 62,182 ftpi) ではなく、9 トラックテープ (6250 bpi) に最適な値となっています。 現在のテープドライブの容量を利用するために、 これらのデフォルト値をコマンドラインで上書きしなければなりません。

`rdump` と `rrestore` を用いて他のコンピュータに接続されているテープドライブにネットワーク経由でデータをバックアップすることも可能です。 どちらのプログラムもリモートのテープドライブにアクセスするために `rcmd` および `ruserok` に依存しています。 したがって、バックアップを実行するユーザがリモートコンピュータの [.filename]#.rhosts# ファイルに書かれていなければなりません。 `rdump` および `rrestore` の引数はリモートコンピュータに適切なものを用いなければなりません。 FreeBSD コンピュータから `komodo` と呼ばれる Sun に接続されている Exabyte テープへ `rdump` するには以下のようにします。

[source,shell]
....
# /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&1
....

注意: [.filename]#.rhosts# 認証を許可することには、セキュリティに関する暗黙の仮定があります。 あなたの置かれている状況を注意深く調べてください。

`ssh` 越しに `dump` と `restore` をより安全な形で使うこともできます。

.ssh 越しの `dump` の利用
[example]
====

[source,shell]
....
# /sbin/dump -0uan -f - /usr | gzip -2 | ssh1 -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz
....

====

または、環境変数 `RSH` を設定して、 `dump` の組み込み機能を利用する。

.`RSH` を設定した ssh 越しの `dump` を利用
[example]
====

[source,shell]
....
# RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0
....

====

=== `tar`

man:tar[1] は AT&T UNIX の バージョン 6 (1975 年ごろ) にまで遡ることができます。`tar` はファイルシステムと協調して動作し、 ファイルとディレクトリをテープに書き込みます。`tar` は man:cpio[1] で使用可能なフルレンジのオプションには対応していませんが、 `tar` には `cpio` が使用するような奇妙なコマンドパイプラインは必要ありません。

`tar` の多くの版はネットワーク経由のバックアップには対応していません。 FreeBSD が使用している GNU 版の `tar` は、 `rdump` と同じ構文でリモートデバイスに対応しています。 `komodo` と呼ばれる Sun に接続された Exabyte テープドライブに対して `tar` を実行するには以下のようにします。

[source,shell]
....
# /usr/bin/tar cf komodo:/dev/nsa8 . 2>&1
....

リモートデバイスに対応していない版に対しては、パイプラインと `rsh` を使用してリモートテープドライブにデータを送ることができます。

[source,shell]
....
# tar cf - . | rsh hostname dd of=tape-device obs=20b
....

ネットワークを越えたバックアップのセキュリティを懸念しているなら、 `rsh` の代わりに `ssh` を使うべきです。

=== `cpio`

man:cpio[1] は本来 UNIX(R) ファイルを磁気メディアで交換するためのプログラムです。 `cpio` はバイトスワッピング、 多くの異なるアーカイブフォーマットの書き込みオプションがあり (それ以外にも多数のオプションがあります)、 パイプで他のプログラムにデータを渡すこともできます。 この最後にあげた特徴が、`cpio` をインストールメディアとしては優れた選択肢にしています。 `cpio` はディレクトリツリーの探索の機能はなく、ファイルリストは [.filename]#stdin# からの入力でなくてはなりません。

`cpio` はネットワーク経由のバックアップには対応していません。 以下のようにパイプラインと `rsh` を用いてリモートテープドライブにデータを送ることができます。

[source,shell]
....
# for f in directory_list; do
find $f >> backup.list
done
# cpio -v -o --format=newc < backup.list | ssh user@host "cat > backup_device"
....

_directory_list_ はバックアップしたいディレクトリのリストで、 _user_@_host_ はバックアップを実行したいユーザとホスト名の組であり、 _backup_device_ はバックアップを書き込みたいデバイスです (たとえば [.filename]#/dev/nsa0#)。

=== `pax`

man:pax[1] は `tar` と `cpio` に対する IEEE/POSIX(R) の回答です。長年の間、さまざまな版の `tar` と `cpio` は互いにわずかに非互換になってきていました。 それらをしらみ潰しに標準化する代わりに、POSIX(R) は新しいアーカイブユーティリティを作りました。 `pax` は、いくつもの `cpio` や `tar` のフォーマットの読み書きに対応しようと試みているほか、 専用に新しいフォーマットを開発しました。 コマンド群は `tar` よりも `cpio` の方にいくぶん似ています。

[[backups-programs-amanda]]
=== Amanda

Amanda (Advanced Maryland Network Disk Archiver) は単一のプログラムではなく、 クライアント/サーバ型のバックアップシステムです。 Amanda サーバは、 Amanda クライアントを有する ネットワークに接続されたコンピュータからデータを受け取り、 備え付けられたテープドライブにバックアップします。 いくつもの大容量ディスクを備えたサイトでの共通の問題は、 データディレクトリをテープにバックアップするのに時間がかかりすぎることです。 Amanda はこの問題を解決します。 Amanda は "ホールディングディスク" を使用して、 同時に複数のファイルシステムのバックアップを行うことができます。 Amanda の設定ファイルにかかれたすべてのファイルシステムのフルバックアップを特定の間隔でとるために "アーカイブセット" と呼ばれるテープグループを作成します。 "アーカイブセット" には 夜間に作成されるすべてのファイルシステムの増分 (または差分) のバックアップも含まれます。 障害が起きたファイルシステムのリストアには、 最も新しいフルバックアップと増分のバックアップが必要です。

設定ファイルでは、バックアップの制御と Amanda によるネットワークトラフィック量を設定します。 Amanda は上記のバックアッププログラムのいずれかを使ってデータをテープに書き込みます。 Amanda は port または package として利用可能です。デフォルトではインストールされていません。

=== 何もしない

"何もしない" というのはコンピュータのプログラムではありませんが、 バックアップの戦略として最も広く採用されています。 これには初期投資が必要ありません。 従わなければならないバックアップスケジュールもありません。 ただ何もしないだけです。データに何か起きたら苦笑いして耐えてください!

あなたにとって時間やデータの価値が少ないか、 あるいはまったくないのであれば "何もしない" のはあなたのコンピュータに最も適したバックアッププログラムでしょう。 しかし注意してください。UNIX(R) は便利なツールです。 6 ヶ月も使用していれば、 あなたにとって価値のあるファイルの山が出来上がっているでしょう。

"何もしない" ことはコンピュータが同じものをもう一度作り直すことのできる [.filename]#/usr/obj# やその他のディレクトリツリーについては適切なバックアップ方法です。 一例として、このハンドブックの HTML 版 または PostScript(R) 版を構成するファイルがあります。 これらの文書形式は SGML ファイルから作成されたものです。 HTML または PostScript(R) ファイルのバックアップは必要ありません。 SGML ファイルは定期的にバックアップされています。

=== どのバックアッププログラムが最適ですか?

man:dump[8] です。_以上。_ Elizabeth D. Zwicky はここで検討したプログラムすべてについて拷問的なテストを行いました。 すべてのデータと UNIX(R) ファイルシステムの状態すべてを保存するのに最適なのは、明らかに `dump` です。 Elizabeth は多種多様の特異な状態 (いくつかはあまり珍しくないものもあります) を含むファイルシステムを作成し、 それらのファイルシステムのバックアップとリストアを行って、 それぞれのプログラムのテストを行いました。特異な状態とは、 ホールがあるファイル、ホールとヌルブロックがあるファイル、 奇妙な文字をファイル名に持つファイル、読み取り不可、 書き込み不可のファイル、デバイスファイル、 バックアップ中のファイルのサイズ変更、 バックアップ中のファイルの作成および削除、などです。 彼女は 1991 年 10 月の LISA V で結果を発表しています。 http://berdmann.dyndns.org/zwicky/testdump.doc.html[torture-testing Backup and Archive Programs] を参照してください。

=== 緊急時のリストア手順

==== 惨事が起きる前に

発生する可能性があるどのような惨事に対しても、 備えるのに必要な手順は以下の 4 ステップだけです。

最初に、 各ディスクのディスクラベルとファイルシステムテーブル ([.filename]#/etc/fstab#)、 ブートメッセージ全体をそれぞれ 2 枚ずつ印刷します (たとえば `disklabel da0 | lpr`)。

2 番目に、ブートフロッピーと fix-it フロッピー ([.filename]#boot.flp# および [.filename]#fixit.flp#) にそのシステムのデバイスがすべて含まれているか確認します。 最も簡単に確認する方法は、フロッピーをドライブに入れてマシンをリブートしてブートメッセージを確認することです。 あなたのシステムのデバイスのすべてが含まれ、 機能していれば 3 番目の手順に進んでください。

さもなければ、 そのシステムのすべてのディスクをマウントでき、 テープドライブにもアクセスできるカーネルを備えた カスタムブートフロッピーを 2 枚作成する必要があります。 これらのフロッピーディスクには `fdisk`, `disklabel`, `newfs`, `mount` と、利用するバックアッププログラムが入っていなければなりません。 これらのプログラムはスタティックリンクされていなければなりません。 `dump` を使用するのなら、このフロッピーには `restore` も含まれていなければなりません。

3 番目に、定期的にバックアップテープを作成します。 最後のバックアップの後で行われた変更は、回復できずに失われます。 バックアップテープにライトプロテクトを施してください。

4 番目に、フロッピーディスク ([.filename]#boot.flp# と [.filename]#fixit.flp#、 か、第 2 段階で作成した 2 枚のカスタムブートフロッピーディスクのどちらか) およびバックアップテープのテストをします。 手順のメモを作りましょう。 このメモはブートフロッピー、印刷した紙、 バックアップテープと一緒に保存しておきます。 リストアを行うときには、 このメモがバックアップテープを壊すのを防ぐくらい取り乱しているかもしれません (どのように? `tar xvf /dev/sa0` の代わりに、うっかり `tar cvf /dev/sa0` と入力してバックアップテープを上書きしてしまうかもしれません)。

.訳注
[NOTE]
====
上書きはライトプロテクトをしておけば防げますが、 何らかの原因でプロテクトがはずれているかもしれません。 ちなみに訳者の経験から言えば、 上のようなミスタイプは結構起きます。
====

安全性を増すために、毎回、 ブートフロッピーを作成し、 2 巻のバックアップテープを取ります。 一方を離れた場所に保管します。 離れた場所は同じ事務所の建物の地下室ではいけません。 世界貿易センタービルにあった数多くの会社は、 苦い経験によりこの教訓を得ました。離れた場所とは、 コンピュータやディスクドライブから十分な距離を取って 物理的に分離されていなければなりません。

.ブートフロッピーを作成するスクリプト
[example]
====
[.programlisting]
....
#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo "Bad floppy, please use a new one"
	 exit 1
fi

# place boot blocks on the floppy
#
disklabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat << EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI - A kernel to get FreeBSD onto a disk.
#
machine         "i386"
cpu             "I486_CPU"
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device          npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out's
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init > /mnt/sbin/init
gzip -c -best /sbin/fsck > /mnt/sbin/fsck
gzip -c -best /sbin/mount > /mnt/sbin/mount
gzip -c -best /sbin/halt > /mnt/sbin/halt
gzip -c -best /sbin/restore > /mnt/sbin/restore

gzip -c -best /bin/sh > /mnt/bin/sh
gzip -c -best /bin/sync > /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat &gt; /mnt/etc/fstab &lt;&lt;EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat > /mnt/etc/passwd <<EOM
root:*:0:0:Charlie &:/root:/bin/sh
EOM

cat > /mnt/etc/master.passwd <<EOM
root::0:0::0:0:Charlie &:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo "The floppy has been unmounted and is now ready."
....

====

==== 惨事の後は

重要な問題は、ハードウェアが生き残ったかどうかです。 定期的にバックアップを取っていれば、 ソフトウェアについて心配する必要はありません。

ハードウェアに障害があれば、 コンピュータを使用する前にその部品を交換してください。

ハードウェアに問題が無ければ、フロッピーを確認してください。 カスタムブートフロッピーディスクを使用しているのであれば、 シングルユーザモードでブートして (`boot:` プロンプトで `-s` を入力します)、 次の段落は飛ばしてください。

[.filename]#boot.flp# と [.filename]#fixit.flp# を使用しているのであればこのまま読み進めてください。 [.filename]#boot.flp# フロッピーをフロッピードライブに入れて、 コンピュータを起動してください。 本来のインストールメニューが画面に表示されます。 `Fixit--Repair mode with CDROM or floppy.` オプションを選択します。指示された通り [.filename]#fixit.flp# をいれてください。 `restore` とその他必要となるプログラムは [.filename]#/mnt2/stand# にあります。

そして、ファイルシステムを一つずつ回復します。

最初のディスクのルートパーティションを `mount` してみてください (たとえば `mount /dev/da0a /mnt`)。 ディスクラベルが破壊されている場合は、`disklabel` を用いてあらかじめ印刷して保存しておいた通りにパーティションを作り直し、ディスクラベルを作成してください。 `newfs` を使用してファイルシステムを作り直します。 ルートパーティションを読み書き可能にマウントし直します (`mount -u -o rw /mnt`)。 バックアッププログラムとバックアップテープを使用して、 このファイルシステムのデータを回復します (たとえば `restore vrf /dev/sa0`)。 ファイルシステムをアンマウントします (たとえば `umount /mnt`)。 障害を受けたファイルシステムそれぞれについて繰り返してください。

システムが動き出したら、 新しいテープにデータをバックアップしてください。 どのような理由で再び事故が起きたり、データが失われるかわかりません。 これに数時間を費すことで、後々の災難から救われます。

[[disks-virtual]]
== ネットワーク、メモリ、そしてファイルベースのファイルシステム

FreeBSD にはフロッピーや CD, ハードディスクなどの手元の計算機に取り付けたディスクの他に、 別の形態のディスク、_仮想ディスク_、もあります。

これには、crossref:advanced-networking[network-nfs,Network File System] のようなネットワークファイルシステムや Coda, メモリベースのファイルシステムおよびファイルベースのファイルシステムがあります。

稼働させている FreeBSD のバージョンによって、 ファイルベースおよびメモリベースのファイルシステムを作成したり操作するために、異なるツールを使用しなければならないでしょう。

[NOTE]
====
FreeBSD 4.X の使用者は必要なデバイスを作成するために man:MAKEDEV[8] を使用しなければならないでしょう。FreeBSD 5.0 以降では、man:devfs[5] がデバイスノードを自動的に割り当ててくれるので、 使用者が意識する必要はありません。
====

[[disks-vnconfig]]
=== FreeBSD 4.X でファイル中に構築されるファイルシステム

man:vnconfig[8] ユーティリティを使えば擬似ディスクデバイスを設定し、 有効にすることができます。 _vnode_ とはファイルの内部的な表現方法であり、 ファイルに関する操作の中心となるものです。つまり、man:vnconfig[8] はファイルシステムを生成したり操作したりするためにファイルを用いるのです。 一つ例を挙げると、 ファイルに収められたフロッピーや CD-ROM のイメージをマウントするために用いることができます。

man:vnconfig[8] を使用するためには、 カーネルが man:vn[4] デバイスに対応している必要があります。 そうでなければ、カーネルコンフィギュレーションファイルに 次の行を追加してカーネルを再構築し、システムを再起動してください。

[.programlisting]
....
pseudo-device vn
....

既にあるファイルシステムイメージのマウント

.FreeBSD 4.X での vnconfig を用いた既存のファイルシステムイメージのマウント
[example]
====

[source,shell]
....
# vnconfig vn0 diskimage
# mount /dev/vn0c /mnt
....

====

man:vnconfig[8] を用いたファイルシステムイメージの新規作成

.`vnconfig` を用いたファイルベースディスクの新規作成
[example]
====

[source,shell]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# vnconfig -s labels -c vn0 newimage
# disklabel -r -w vn0 auto
# newfs vn0c
Warning: 2048 sector(s) in last cylinder unallocated
/dev/vn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
# mount /dev/vn0c /mnt
# df /mnt
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt
....

====

[[disks-mdconfig]]
=== FreeBSD 5.X でファイル中に構築されるファイルシステム

man:mdconfig[8] ユーティリティは FreeBSD 5.X において メモリディスク (man:md[4]) を設定し、有効にするために使用されます。 man:mdconfig[8] を使用するためには man:md[4] モジュールを読み込むか、 カーネルコンフィギュレーションファイルに man:md[4] デバイスを追加してカーネルを再構築し、システムを再起動してください。

[.programlisting]
....
device md
....

man:mdconfig[8] コマンドは、 三つのタイプのメモリベース仮想ディスクに対応しています。 man:malloc[9] を用いて割り当てられたメモリディスク、 ファイルをベースにしたメモリディスク、 およびスワップ領域をベースにしたメモリディスクです。 想定される使用法は、ファイル内に保持されたフロッピーイメージまたは CD イメージをマウントすることです。

既にあるファイルシステムイメージのマウント

.FreeBSD 5.X での `mdconfig` を用いた既存のファイルシステムイメージのマウント
[example]
====

[source,shell]
....
# mdconfig -a -t vnode -f diskimage -u 0
# mount /dev/md0c /mnt
....

====

man:mdconfig[8] を用いたファイルシステムイメージの新規作成

.`mdconfig` を用いたファイルシステムイメージの新規作成
[example]
====

[source,shell]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# mdconfig -a -t vnode -f newimage -u 0
# disklabel -r -w md0 auto
# newfs md0c
/dev/md0c: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
# mount /dev/md0c /mnt
# df /mnt
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4846        2     4458     0%    /mnt
....

====

`-u` オプションを用いて ユニット番号を指定しない場合、man:mdconfig[8] は未使用のデバイスを自動的に選択するために man:md[4] デバイスの auto-unit 機能を使用します。 割り当てられたユニットの名前は [.filename]#md4# のように標準出力に出力されます。man:mdconfig[8] の詳細についてはマニュアルページを参照してください。

[NOTE]
====
FreeBSD 5.1-RELEASE から、従来の man:disklabel[8] プログラムは man:bsdlabel[8] ユーティリティに置き換えられました。man:bsdlabel[8] では、 使用されていないオプションおよびパラメタの数多くが削除されました。 たとえば `-r` オプションは man:bsdlabel[8] では取り除かれました。詳細については man:bsdlabel[8] マニュアルページを参照してください。
====

man:mdconfig[8] ユーティリティは大変役に立ちますが、 ファイルベースのファイルシステムを作成するために、 多くのコマンドの入力が必要となります。FreeBSD 5.0 では man:mdmfs[8] と呼ばれるツールも用意されています。このプログラムは man:mdconfig[8] を用いて man:md[4] ディスクを設定し、man:newfs[8] を用いて UFS ファイルシステムを作成し、man:mount[8] を用いてマウントします。たとえば、上記と同じファイルシステムを作成し、 マウントしたい場合は、下記のように入力するだけです。

.`mdmfs` を用いたファイルベースディスクの設定とマウント
[example]
====

[source,shell]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# mdmfs -F newimage -s 5m md0 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4846    2  4458     0%    /mnt
....

====

ユニット番号を指定せずに `md` オプションを使用した場合、man:mdmfs[8] は未使用のデバイスを自動的に選択するために man:md[4] デバイスの auto-unit 機能を使用します。man:mdmfs[8] についての詳細はマニュアルページを参照してください。

[[disks-md-freebsd4]]
=== FreeBSD 4.X でのメモリベースのファイルシステム

man:md[4] ドライバは FreeBSD 4.X においてメモリファイルシステムを作成するために単純で効果的な手段です。 メモリを割り当てるために man:malloc[9] 関数が使用されます。

man:vnconfig[8] を用いて作成したファイルシステムを例に取ると、 以下のようにします。

.FreeBSD 4.X での md メモリディスク
[example]
====

[source,shell]
....
# dd if=newimage of=/dev/md0
5120+0 records in
5120+0 records out
# mount /dev/md0c /mnt
# df /mnt
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt
....

====

詳細については man:md[4] マニュアルページを参照してください。

[[disks-md-freebsd5]]
=== FreeBSD 5.X でのメモリベースのファイルシステム

メモリベースおよびファイルベースのファイルシステムに対しても 同じツール (man:mdconfig[8] または man:mdmfs[8]) を使用できます。 メモリベースのファイルシステムに対する記憶領域は man:malloc[9] 関数を用いて割り当てられます。

.`mdconfig` を用いたメモリベースディスクの新規作成
[example]
====

[source,shell]
....
# mdconfig -a -t malloc -s 5m -u 1
# newfs -U md1
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
	with soft updates
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
# mount /dev/md1 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4846    2  4458     0%    /mnt
....

====

.`mdmfs` を用いたメモリベースディスクの新規作成
[example]
====

[source,shell]
....
# mdmfs -M -s 5m md2 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt
....

====

man:mdconfig[8] のコマンドラインの `malloc` を `swap` に置き換えることで、man:malloc[9] 関数によるファイルシステムを使用する代わりに スワップ領域を使用することが可能です。デフォルトでは man:mdmfs[8] ユーティリティはスワップベースのディスクを作成します (`-M` なし)。詳細は man:mdconfig[8] および man:mdmfs[8] マニュアルページを参照してください。

=== システムからメモリディスクを切り離す

メモリベースまたはファイルベースのファイルシステムが使用されていない場合、 すべてのリソースをシステムに開放するべきです。 はじめにファイルシステムをアンマウントします。 次にシステムからディスクを切り離し、リソースを開放するために man:mdconfig[8] を使用します。

たとえば [.filename]#/dev/md4# によって使用されたすべてのリソースを切り離し、開放するには以下のようにします。

[source,shell]
....
# mdconfig -d -u 4
....

`mdconfig -l` コマンドを使用することによって、 設定された man:md[4] デバイスについての情報を表示することが可能です。

FreeBSD 4.X では man:vnconfig[8] はデバイスを切り離すのに使用されます。たとえば [.filename]#/dev/vn4# によって使用されたすべてのリソースを切り離し、開放するには以下のようにします。

[source,shell]
....
# vnconfig -u vn4
....

[[snapshots]]
== ファイルシステムのスナップショット

FreeBSD 5.0 は Soft Updates  と協調するファイルシステムスナップショットという新しい機能を提供します。

スナップショットは指定したファイルシステムのイメージを作成し、 また、ファイルとして扱うことができるようになります。 スナップショットファイルはアクションが実行されるファイルシステム内で作成されなければなりません。 また、ユーザは一つのファイルシステムあたり 20 までスナップショットを作成することができます。 有効なスナップショットはスーパーブロック内に記録されるので、 リブートしてから永続的にアンマウントおよびリマウントを記録します。 スナップショットが必要無くなったときは、 標準の man:rm[1] コマンドを用いて削除することができます。 スナップショットはどんな順番で削除してもよいのですが、 その他のスナップショットが開放されたブロックのうちいくらかをおそらく必要とするので、 使用されていたすべてのスペースを得られるとは限りません。

初めてスナップショットを作成すると、`root` でさえも書き込めないように `schg` フラグ (man:chflags[1] のマニュアルページを参照) が設定されます。 man:unlink[1] コマンドは、スナップショットに `schg` フラグが設定されていてもそれらを削除することのできる例外です。 したがって、スナップショットファイルを削除する前に、 `schg` フラグをクリアする必要はありません。

スナップショットは man:mount[8] コマンドを用いて作成されます。 [.filename]#/var# のスナップショットを [.filename]#/var/snapshot/snap# に作成したいときは、 以下のコマンドを使用します。

[source,shell]
....
# mount -u -o snapshot /var/snapshot/snap /var
....

また、スナップショットを作成するのに man:mksnap_ffs[8] も使えます。

[source,shell]
....
# mksnap_ffs /var /var/snapshot/snap
....

スナップショットにはいくつかの利用法があります。

* スナップショットをバックアップ目的に使用する管理者もいます。 なぜならスナップショットは CD やテープに転送できるからです。
* ファイルの完全性を検証するために、 man:fsck[8] をスナップショットに実行してもよいでしょう。 スナップショットをマウントしたときにそのファイルシステムがクリーンであったとすると、 そのスナップショットをマウントするときはいつでもクリーンな (そして変更のない) 結果を得るでしょう。 これは本質的には バックグラウンド man:fsck[8] が行うことです。
* スナップショット上で man:dump[8] ユーティリティを実行すると、 スナップショットのファイルシステムとタイムスタンプが一致するダンプが返されるでしょう。 man:dump[8] は `-L` オプションを使用することで、 一つのコマンドでスナップショットをとり、ダンプイメージを作成して、スナップショットを削除することが可能です。
* ファイルシステムの "凍結された" イメージとしてスナップショットを man:mount[8] します。 [.filename]#/var/snapshot/snap# のスナップショットを man:mount[8] するには以下のようにします。
+
[source,shell]
....
# mdconfig -a -t vnode -f /var/snapshot/snap -u 4
# mount -r /dev/md4 /mnt
....

これで [.filename]#/mnt# にマウントした 凍結状態の [.filename]#/var# ファイルシステム構造を探索できます。 すべてがスナップショットが作成された時と同じ状態になるはずです。ただし、 以前に作成されたスナップショットがサイズ 0 のファイルとして現れることが唯一の例外です。 スナップショットの使用を終えた場合、以下のようにアンマウントできます。

[source,shell]
....
# umount /mnt
# mdconfig -d -u 4
....

`softupdates` およびファイルシステムスナップショットに関する詳細については、 http://www.mckusick.com/[http://www.mckusick.com/] にある Marshall Kirk McKusick のウェブサイトを参照してください。 ここには技術的な論文もあります。

[[quotas]]
== ファイルシステムクォータ

クォータは OS の持っているオプショナルな機能であり、 ファイルシステム毎にユーザやグループのメンバが使用するディスク容量やファイルの数を制限することができます。 この機能は、あるユーザやグループに割り当てられるリソースの量を制限することが望ましいようなタイムシェアリングシステムにおいてよく用いられます。 この機能を用いることによって使用可能なディスク容量の全てを一人のユーザやユーザのグループが使ってしまうことを防ぐことができます。

=== ディスククォータを使うためのシステム設定

ディスククォータの設定を始める前に、 まずはカーネルにクォータが組み込まれていることを確認しましょう。 カーネルのコンフィグレーションファイルに次の行を入れます。

[.programlisting]
....
options QUOTA
....

標準の [.filename]#GENERIC# カーネルでは、 この機能は有効になっていませんので、 ディスククォータを利用するためには上記を設定後カーネルを構築しなおし、 作成されたカスタムカーネルをインストールしなければいけません。 カーネルのコンフィグレーションに関しては crossref:kernelconfig[kernelconfig,FreeBSD カーネルのコンフィグレーション] をご覧ください。

次に [.filename]#/etc/rc.conf# でディスククォータを有効にする必要があります。 次の行を加えましょう。

[.programlisting]
....
enable_quotas="YES"
....

起動時の動作をさらに細かくコントロールするためにもう一つ設定用の変数があります。 通常、起動時には man:quotacheck[8] によりそれぞれのファイルシステムのクォータの整合性がチェックされます。 man:quotacheck[8] の役割は、 クォータデータベースのデータが正しくファイルシステム上のデータを反映しているか確認することです。 これはかなり時間を食う処理であり、 起動にかかる時間に大きな影響を及ぼします。 このステップをとばしたい人のために [.filename]#/etc/rc.conf# に次の変数が用意されています。

[.programlisting]
....
check_quotas="NO"
....

もし 3.2-RELEASE よりも前の FreeBSD を使っているならば設定はもっと単純で、一つの変数のみです。 次の行を [.filename]#/etc/rc.conf# で設定してください。

[.programlisting]
....
check_quotas="YES"
....

最後に、ファイルシステム毎にディスククォータを有効にするために [.filename]#/etc/fstab# を編集する必要があります。 ここでユーザもしくはグループ、 あるいはその両方にクォータを設定することができるのです。

あるファイルシステム上にユーザ毎のクォータを有効にする場合には、 [.filename]#/etc/fstab# 中でクォータを有効にしたいファイルシステムエントリのオプション部に `userquota` を加えます。 例えば次のようになります。

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota 1 2
....

同様に、グループクォータを有効にするには `userquota` キーワードの代わりに `groupquota` を用います。 ユーザとグループの両方のクォータを有効にするには次のようにします。

[.programlisting]
....
/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2
....

デフォルトでは、 クォータファイルはそのファイルシステムのルートディレクトリに ユーザ用、グループ用それぞれ [.filename]#quota.user#, [.filename]#quota.group# という名前で置かれます。さらに詳しい情報は man:fstab[5] をご覧ください。man:fstab[5] マニュアルには別の場所を指定することができると書いてはありますが、 あまり勧められません。なぜなら、 様々なクォータ関係のユーティリティがそれにうまく対処できるようにないためです。

この時点で、 一度システムを再起動して新しいカーネルで立ち上げましょう。 [.filename]#/etc/rc# が自動的に適当なコマンドを実行し、 [.filename]#/etc/fstab# で有効にした全てのクォータ用に初期ファイルを作ってくれます。 従って、空のクォータファイルを手で作る必要は一切ありません。

通常の運用では man:quotacheck[8] や man:quotaon[8], man:quotaoff[8] といったコマンドを手で動かす必要はないのですが、 慣れるためにもこれらのマニュアルは読んでおきましょう。

=== クォータリミットの設定

一旦クォータを有効にしたら本当に有効になっているのか確認しておきましょう。簡単な方法は次のコマンドを実行することです。

[source,shell]
....
# quota -v
....

ディスクの使用状況と、クォータが有効になっているファイルシステムのクォータリミットが一行にまとめて出力されるでしょう。

さあ、man:edquota[8] でクォータリミットを設定する準備ができました。

ユーザやグループが使用できるディスク容量や作成できるファイルの数に制限をかけるにはいくつかのオプションがあります。割り当てディスク容量を制限 (ブロッククォータ) することもファイル数を制限 (inode クォータ) することも、両者を組み合わせることもできるのです。 これらの制限はそれぞれさらに二つのカテゴリ、 ハードリミットとソフトリミット、に分けることができます。

ハードリミットを越えることはできません。 あるユーザが一旦ハードリミットにたっした場合、 そのファイルシステムではそれ以上の割り当ては望めません。 例えばあるファイルシステム上に 500 ブロックのハードリミットが設定されており現在 490 ブロックを使用している場合、さらに 10 ブロックしか使えないのです。 11 ブロックを使おうとすると失敗します。

一方、 ソフトリミットはある限られた時間内であれば越えることができます。 この時間は猶予期間として知られており、デフォルトでは 1 週間です。 あるユーザが自分のソフトリミットを猶予期間よりも長い間越えているとソフトリミットはハードリミットに変わり、それ以上使用することはできなくなります。 ユーザがソフトリミットよりも減らせば猶予期間はリセットされます。

以下は man:edquota[8] コマンドを実行した時に見ることになるであろう例です。 man:edquota[8] コマンドが起動されると環境変数 `EDITOR` で指定されるエディタに入ります。 `EDITOR` が設定されていない場合には vi が起動されます。 ここでクォータリミットを編集します。

[source,shell]
....
# edquota -u test
....

[.programlisting]
....
Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)
....

通常、クォータが有効になっているファイルシステム毎に 2 行あります。 一つはブロックリミット用でもう一つは inode リミット用です。 クォータリミットを変更したいところを書き変えるだけでかまいません。 たとえばこのユーザのブロックリミットを、ソフトリミットは 50 から 500 へ、ハードリミットは 75 から 600 に変更する場合、

[.programlisting]
....
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
....

から

[.programlisting]
....
 /usr: blocks in use: 65, limits (soft = 500, hard = 600)
....

へ書き換えます。新しいクォータリミットはエディタを終了すれば設定されます。

ある範囲の UID に対してクォータリミットを設定したい場合がありますが、このような時には man:edquota[8] コマンドの `-p` オプションを使うといいでしょう。まず、 あるユーザに割り当てたいクォータリミットを設定し、次に `edquota -p protouser startuid-enduid` を実行するのです。例えばユーザ `test` にお望みのクォータリミットが付いているとしましょう。 次のコマンドにより 10,000 から 19,999 の間の UID に対して同じクォータリミットを付けることができるのです。

[source,shell]
....
# edquota -p test 10000-19999
....

さらに詳しいことは man:edquota[8] のマニュアルページをご覧ください。

=== クォータリミットとディスク使用状況のチェック

man:quota[1] または man:repquota[8] といったコマンドを使ってクォータリミットやディスクの利用状況を確認することができます。 man:quota[1] コマンドは個々のユーザやグループのクォータやディスク利用状況を確認するのに使えます。 ユーザは自身のクォータ、そして所属するグループのグループのみ確認することができます。 スーパーユーザのみが他のユーザや所属していないグループのクォータと利用状況を見ることができます。 man:repquota[8] コマンドを使うと、クォータが有効になっているファイルシステム用の全てのクォータやディスク容量のサマリを得ることができます。

以下は二つのファイルシステムにクォータ制限がかけられているユーザに対する``quota -v`` コマンドの出力例です。

[.programlisting]
....
Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60
....

上の例で、[.filename]#/usr# ファイルシステム上ではこのユーザは現在 50 ブロックというソフトリミットを 15 ブロックオーバーし 5 日間の猶予期間が残っています。アスタリスク `*` はクォータリミットを越えているユーザを示していることに注意してください。

通常、そのユーザが全く使っていないファイルシステムは、 クォータリミットが付けられているとしても man:quota[1] コマンドの出力には現われません。 `-v` オプションを用いればそのようなファイルシステム、 上の例では [.filename]#/usr/var#、 を表示することができます。

=== NFS 上の クォータ

クォータは NFS サーバ上のクォータサブシステムにより実行されます。 man:rpc.rquotad[8] デーモンにより、NFS クライアント上の man:quota[1] コマンドは情報を得ることができ、クライアントマシン上のユーザが自分のクォータの統計を見ることができます。

[.filename]#/etc/inetd.conf# において以下のように `rpc.rquotad` を有効にしましょう。

[.programlisting]
....
rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad
....

そして以下のように `inetd` を再起動します。

[source,shell]
....
# kill -HUP `cat /var/run/inetd.pid`
....

[[disks-encrypting]]
== ディスクパーティションの暗号化

FreeBSD は無許可のデータアクセスに対する優れたオンライン保護機能を提供します。 ファイルのパーミッションおよび強制的アクセスコントロール (MAC: Mandatory Access Control) (Mandatory Access Control (MAC) を参照)  は、コンピュータが動作中で、OS が実行中であるときに、 無許可の第三者がデータにアクセスするのを防ぐことに役立ちます。 しかしながら、攻撃者がコンピュータに物理的にアクセスし、 機密データをコピーし分析するためにコンピュータのハードドライブを別のシステムに移動させることができれば、 OS によって強化された許可属性は意味をなさなくなります。

攻撃者が電源の落ちたコンピュータや ハードドライブを手にいれる手段にかかわらず、 GEOM ベースのディスク暗号化 (gbde: GEOM Based Disk Encryption) は、著しい資源を持ち本気で攻撃を仕掛けるつもりでやってきた攻撃者からさえもコンピュータのファイルシステム上にあるデータを保護することができます。 個々のファイルだけを暗号化する煩わしい方法と異なり、 gbde は全ファイルシステムを透過的に暗号化します。 平文テキストは決してハードドライブのプラッタに関係しません。

=== カーネルで gbde を有効にする

[.procedure]
====

. `root` になる
+ 
gbde の設定をするにはスーパユーザの権限が必要になります。 以下のコマンドを実行して、 `root` になってください。
+
[source,shell]
....
% su -
Password:
....
+
. オペレーティングシステムのバージョンを確かめる
+ 
man:gbde[4] が動作するには FreeBSD 5.0 以降が必要です。 以下のコマンドを実行して、 オペレーティングシステムのバージョンを確認してください。
+
[source,shell]
....
# uname -r
5.0-RELEASE
....
+
. カーネルコンフィギュレーションファイルに man:gbde[4] 対応を追加する
+ 
お好みのテキストエディタを使用して、 以下の行をカーネルコンフィギュレーションファイルに加えます。
+ 
`options GEOM_BDE`
+ 
FreeBSD カーネルを設定、再コンパイル、インストールします。 この手順は crossref:kernelconfig[kernelconfig,FreeBSD カーネルのコンフィグレーション] で説明されています。
+ 
新しいカーネルで再起動します。
====

=== 暗号化されたハードドライブの準備

以下の例では、システムに新しいハードディスクを追加しようとしています。このシステムは単一の暗号化されたパーティションを保持することになります。 このパーティションは [.filename]#/private# としてマウントされます。gbde は [.filename]#/home# および [.filename]#/var/mail# を暗号化するのにも使用できますが、 より複雑な指示を必要となるのでこの解説の範疇を越えています。

[.procedure]
====

. 新しいハードドライブを追加する
+ 
<<disks-adding>> で説明されている通りに新しいドライブをシステムに設置します。 この例では、新しいハードドライブは [.filename]#/dev/ad4s1c# パーティションに 加えられたものとします。 [.filename]#/dev/ad0s1*# デバイスは、この例のシステム上に存在する標準的な FreeBSD パーティションを表します。
+
[source,shell]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4
....
+
. gbde ロックファイルを保持するディレクトリを作成する
+
[source,shell]
....
# mkdir /etc/gbde
....
+ 
gbde ロックファイルには、 暗号化されたパーティションにアクセスするのに必要となる情報が格納されています。 ロックファイルにアクセスしない場合、 gbde は 膨大な手動による介在なしには (ソフトウェアは対応していません)、暗号化されたパーティションに含まれるデータを解読することはできないでしょう。 それぞれの暗号化されたパーティションは別々のロックファイルを使用します。
. gbde パーティションを初期化する
+ 
gbde パーティションは使用する前に初期化されなければなりません。 この初期化は一度だけ実行される必要があります。
+
[source,shell]
....
# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c
....
+ 
エディタが開くので、 テンプレートをもとにさまざまなオプションを設定してください。 UFS1 または UFS2 で使用するには、sector_size を 2048 に設定してください。
+
[.programlisting]
....
$FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]
....
+ 
man:gbde[8] はデータを保護するのに使用するパスフレーズを二度尋ます。 パスフレーズはそれぞれ同じでなければなりません。 データを保護する gbde の能力は、 あなたが選択したパスフレーズの品質に完全に依存します。 
+ 
`gbde init` コマンドは gbde パーティションに対するロックファイルを作成します。この例では [.filename]#/etc/gbde/ad4s1c# に格納されます。
+
[CAUTION]
======

gbde ロックファイルは、 すべての暗号化されたパーティションの内容とともにバックアップされなければ _なりません_。 ロックファイルだけを削除している間、 ロックファイルなしでは信念の固い攻撃者が gbde パーティションを解読することを防ぐことができない一方で、 正当な所有者は、man:gbde[8] およびこの設計者にまったく支持されない膨大な量の作業なしには、 暗号化されたパーティション上のデータにアクセスすることができないでしょう。
======
+
. カーネルに暗号化されたパーティションを接続する
+
[source,shell]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c
....
+ 
暗号化されたパーティションを初期化する際に選択したパスフレーズを入力するように求められます。 新しい暗号化デバイスは [.filename]#/dev# に [.filename]#/dev/device_name.bde# として現れます。
+
[source,shell]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde
....
+
. 暗号化デバイス上にファイルシステムを作成する
+ 
カーネルに暗号化デバイスが接続されると、 デバイス上にファイルシステムを作成できます。 暗号化デバイス上にファイルシステムを作成するには man:newfs[8] を使用します。従来の UFS1 ファイルシステムで初期化するより、 新しい UFS2 ファイルシステムで初期化した方が高速なので、 `-O2` オプションとともに man:newfs[8] を使用することが推奨されています。
+
[NOTE]
======
FreeBSD 5.1-RELEASE 以降では、`-O2` オプションはデフォルトです。
======
+
[source,shell]
....
# newfs -U -O2 /dev/ad4s1c.bde
....
+
[NOTE]
======
man:newfs[8] は、デバイス名に [.filename]#*.bde# 拡張子によって認識される、 接続された gbde パーティションに対して実行されなければなりません。
======
+
. 暗号化パーティションをマウントする
+ 
暗号化ファイルシステムに対するマウントポイントを作成します。
+
[source,shell]
....
# mkdir /private
....
+ 
暗号化ファイルシステムをマウントします。
+
[source,shell]
....
# mount /dev/ad4s1c.bde /private
....
+
. 暗号化ファイルシステムが利用可能か確かめる
+ 
これで暗号化ファイルシステムは man:df[1] で見ることができ、 利用する準備ができました。
+
[source,shell]
....
% df -H
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private
....
====

=== 存在する暗号化ファイルシステムをマウントする

システムを起動する度に、すべての暗号化ファイルシステムは 使用前にカーネルに接続し、 エラーの有無をチェックし、マウントする必要があります。 必要なコマンドは `root` ユーザとして実行されなければなりません。

[.procedure]
====

. カーネルに gbde パーティションを接続する
+
[source,shell]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c
....
+ 
パーティションの暗号化を初期化する際に選択したパスフレーズを入力するように求められるでしょう。
. ファイルシステムのエラーをチェックする
+ 
暗号化ファイルシステムを自動的にマウントするために [.filename]#/etc/fstab# に設定を掲載することはまだできないため、 マウントする前に man:fsck[8] を実行して、 ファイルシステムのエラーをチェックしなければなりません。
+
[source,shell]
....
# fsck -p -t ffs /dev/ad4s1c.bde
....
+
. 暗号化ファイルをマウントする
+
[source,shell]
....
# mount /dev/ad4s1c.bde /private
....
+ 
これで暗号化ファイルシステムが利用できるようになりました。
====

==== 暗号化パーティションを自動的にマウントする

スクリプトを作成して、暗号化パーティションを自動的に接続、 チェック、マウントすることは可能です。しかしながら、 安全上の理由によりスクリプトに man:gbde[8] パスワードを含めるべきではありません。その代わりに、コンソールまたは man:ssh[1] による接続からパスワードを入力するようなスクリプトが手動で実行されることが推奨されます。

=== gbde が採用した暗号の保護

man:gbde[8] は 128bit AES の CBC モードを使用してセクタペイロードを暗号化します。 ディスク上のそれぞれのセクタは異なる AES 鍵で暗号化されます。 セクタ鍵がユーザが入力したパスフレーズからどのように導き出されるかを含め、 gbde の暗号手法の設計についての詳細は、 man:gbde[4] を参照してください。

=== 互換性に関する問題

man:sysinstall[8] は gbde 暗号化デバイスと互換性がありません。 man:sysinstall[8] を実行する前に [.filename]#*.bde# デバイスはすべてカーネルから切断されなければなりません。 そうしないと、man:sysinstall[8] が初めにデバイスを走査する際にクラッシュしてしまうでしょう。 暗号化デバイスを切断するには、以下のコマンドを使用します。

[source,shell]
....
# gbde detach /dev/ad4s1c
....
