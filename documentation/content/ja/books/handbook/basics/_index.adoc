---
title: 第3章 FreeBSD の基礎知識
part: パートI. 導入
prev: books/handbook/bsdinstall
next: books/handbook/ports
description: FreeBSD オペレーティングシステムの基本的なコマンドと機能について
tags: ["basics", "virtual consoles", "users", "management", "permissions", "directory structure", "disk organization", "mounting", "processes", "daemons", "shell", "editor", "manual pages", "devices"]
showBookMenu: true
weight: 5
path: "/books/handbook/"
aliases: ["/ja/books/handbook/consoles/","/ja/books/handbook/users-synopsis/","/ja/books/handbook/permissions/","/ja/books/handbook/dirstructure/","/ja/books/handbook/disk-organization/","/ja/books/handbook/mount-unmount/","/ja/books/handbook/basics-processes/","/ja/books/handbook/shells/","/ja/books/handbook/editors/","/ja/books/handbook/basics-devices/","/ja/books/handbook/basics-more-information/"]
---

[[basics]]
= FreeBSD の基礎知識
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 3
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== この章では

この章では FreeBSD オペレーティングシステムの基本的なコマンドと機能について記述しています。
ここに書かれてあることのほとんどは、どんな UNIX(R) -like なオペレーティングシステムにもあてはまります。
FreeBSD の初心者であれば、この章を読んでおいた方がきっといいはずです。

この章を読んで分かることは、次のようなことです。

* 仮想コンソールの使い方と設定方法
* FreeBSD システム上でユーザやグループを作成し管理する方法
* UNIX(R) のファイルの許可属性の仕組みと FreeBSD のファイルフラグについて
* FreeBSD のファイルシステムの構成
* FreeBSD のディスク構成
* ファイルシステムをマウント、アンマウントする方法
* プロセス、デーモンとシグナルとはなにか
* シェルとはなにか。 また、デフォルトのログイン環境を変える方法
* テキストエディタの基本的な使い方
* デバイスおよびデバイスノードとはなにか
* さらに詳しい情報を得るためのマニュアルページの読み方

[[consoles]]
== 仮想コンソールと端末

起動時に自動的にグラフィカルな環境が起動するように FreeBSD を設定していなければ、システムが起動すると、以下のようなコマンドラインのログインプロンプトが表示されます。

[source,shell]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

最初の行はシステムの情報です。
`amd64` は、このシステム上で 64 ビット版の FreeBSD が動作していることを示しています。
ホスト名は `pc3.example.org`、`ttyv0` は "システムコンソール" であることを示しています。
次の行はログインプロンプトです。

FreeBSD はマルチユーザシステムなので、ユーザを区別する何がしかの手段が必要です。
システム上のプログラムを実行できるようになるには、すべてのユーザに対してシステムにログインすることが義務付けられています。
すべてのユーザは、一意な "ユーザ名" と "パスワード" を持っています。

システムコンソールにログインするには、システムのインストール時に crossref:bsdinstall[bsdinstall-addusers,ユーザの追加] で追加したユーザ名を入力して、kbd:[Enter] を押してください。
次にそのユーザのパスワードを入力して、kbd:[Enter] を押してください。
セキュリティの観点から、パスワードは _表示されません_。

パスワードを正確に入力したら、日々のメッセージ (MOTD) が表示され、
コマンドプロンプトが表示されます。
ユーザ作成時に選択したシェルに依存しますが、このプロンプトは `+#+`, `$` または `%` といった記号です。
プロンプトはユーザが FreeBSD のシステムコンソールへログインし、利用可能なコマンドを実行する準備ができていることを示しています。

[[consoles-virtual]]
=== 仮想コンソール

システムコンソールからシステムに対話的にコマンドを実行できますが、FreeBSD システム上でキーボードによりコマンドラインから利用しているユーザは、通常代わりに仮想コンソールにログインします。
デフォルトではシステムからのメッセージはシステムコンソールに出力され、これらのメッセージが、ユーザが作業しているコマンドまたはファイル上に表示されるため、ユーザが現在の作業に集中できなくなるためです。

デフォルトでは FreeBSD は、複数の仮想コンソールを表示してコマンドを入力できるように設定されています。
各仮想コンソールは、個別のログインプロンプトおよびシェルを持っており、簡単に仮想コンソール間の切り替えができます。
これにより、グラフィカルな環境において同時に複数のウィンドウを開いてコマンドラインの環境を提供できます。

FreeBSD では kbd:[Alt+F1] から kbd:[Alt+F8] までのキーの組み合わせが、仮想コンソール間の切り替えに予約されています。
システムコンソール (`ttyv0`) に切り替えるには、kbd:[Alt+F1] を使ってください。
最初の仮想コンソール (`ttyv1`) にアクセスするには kbd:[Alt+F2]、2 番目の仮想コンソール (`ttyv2`) にアクセスするには kbd:[Alt+F3]、といったように使ってください。
Xorg をグラフィカルなコンソールとして使用しているときには、kbd:[Ctrl+Alt+F1] の組み合わせを使用すると、テキストベースの仮想コンソールへ戻ります。

あるコンソールから他に切り替えるのに応じて、FreeBSD は画面への出力を管理します。
結果として、FreeBSD で動かすコマンドを入力するのに使える複数の画面とキーボードを仮想的に実現できるのです。
ある仮想コンソールで実行したプログラムは、ユーザが別の仮想コンソールに切り替えても実行を停止しません。

FreeBSD のコンソールおよびキーボードドライバに関するさらなる技術的な説明については、man:kbdcontrol[1], man:vidcontrol[1], man:atkbd[4], man:syscons[4] および man:vt[4] を参照してください。

FreeBSD では以下の `/etc/ttys` のセクションのように複数の利用可能な仮想コンソールが設定されています。

[.programlisting]
....
# name    getty                         type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

仮想コンソールを無効にするには、無効にしたい仮想コンソールの行をコメント記号 (`+#+`) から始まるように設定してください。
たとえば、利用可能な仮想コンソールを 8 つから 4 つに減らす場合には、`ttyv5` から `ttyv8` までの仮想コンソールを表す最後の 4 行の先頭に `+#+` を挿入してください。
システムコンソールを表す `ttyv0` から始まる行はコメントアウト _しないでください。_
最後の仮想コンソール (`ttyv8`) は、 crossref:x11[x11,X Window System] で説明されているように Xrog がインストールされて設定されている場合に、グラフィカル環境にアクセスするために使用されます。

このファイルのそれぞれのカラムと仮想コンソールに設定可能なオプションの詳しい説明は、man:ttys[5] のマニュアルを参照してください。

[[consoles-singleuser]]
=== シングルユーザモード

FreeBSD のブートメニューでは、"シングルユーザモード" と表示されているオプションが提供されています。
このオプションを選択すると、システムは "シングルユーザモード" と呼ばれる特別なモードで起動します。
このモードは、システムが起動しない場合に修正のため、または `root` のパスワードが分からなくなってしまいリセットするときなど、特別な状況で利用されます。
シングルユーザモードで動かしている場合は、ネットワークや他の仮想コンソールは利用できません。
しかし、システムへの完全な `root` 権限を利用でき、デフォルトの設定では `root` のパスワードは必要ありません。
このような理由のため、このモードで起動する場合には物理的なキーボードへのアクセスが必要であり、FreeBSD システムの安全性の観点からキーボードに物理的にアクセスできる人を決めておく事が必要です。
シングルユーザモードを管理する設定は、`/etc/ttys` ファイルの以下のセクションにあります。

[.programlisting]
....
# name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

デフォルトでは、status は `secure` に設定されています。
これは、キーボードへアクセスできるかユーザが誰であるかが重要ではない、もしくはアクセスできるユーザについては物理的なセキュリティポリシーでコントロールされていることが前提となっています。
この設定を `insecure` に変更するケースとしては、システムは安全ではなく、誰でもキーボードにアクセスできる環境が想定されます。
この行を `insecure` に変更すると、FreeBSD がシングルユーザモードで起動した場合に `root` のパスワードが要求されます。

[NOTE]
====
__ `insecure` に変更する場合は十分注意してください! __
`root` のパスワードを忘れてしまうと、シングルユーザモードで起動することはできますが、FreeBSD の起動のプロセスに詳しくない人が起動できるようにするのは難しいかも知れません。
====

[[consoles-vidcontrol]]
=== コンソールのビデオモードの変更

FreeBSD のデフォルトのビデオモードは 1024x768 や 1280x1024 など、グラフィックチップおよびディスプレイが対応しているサイズに調整されます。
別のビデオモードを使うには、`VESA` モジュールをロードしてください。

[source,shell]
....
# kldload vesa
....

その後、ハードウェアが対応しているビデオモードを man:vidcontrol[1] を使って確認してください。
以下を実行すると、対応しているビデオモードを調べることができます。

[source,shell]
....
# vidcontrol -i mode
....

このコマンドは、使用しているハードウェアが対応しているビデオモードの一覧を表示します。
その後、man:vidcontrol[1] を `root` ユーザで実行して、新しく使用するビデオモードを選択してください。

[source,shell]
....
# vidcontrol MODE_279
....

このビデオモードで良ければ、起動時に自動的に設定されるように `/etc/rc.conf` に以下のように追加してください。

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== ユーザと基本的なアカウント管理

FreeBSD は、複数のユーザが同時にコンピュータを使えるようにします。 スクリーンとキーボードの前に一度に座れるのはその中の一人だけですが ユーザは何人でもネットワークを通してログインできます。 システムを使うためには、 どのユーザもアカウントがなければなりません。

この章では、以下のことを説明します。

* FreeBSD システムにおけるさまざまな種類のユーザアカウントについて
* ユーザアカウントを追加、削除および変更する方法
* ユーザやグループが利用できるリソースの上限を制御する方法
* グループの作成、 およびグループにユーザをメンバとして追加する方法

[[users-introduction]]
=== アカウントの種類

FreeBSD システムへアクセスするには、 かならずアカウントが使われ、 また、プロセスもすべてユーザによって実行されるので、 ユーザとアカウントの管理は、重要なものです。 

アカウントには大きく分けて三種類あります。 システムアカウント (system accounts)、ユーザアカウント (user accounts)、 そしてスーパーユーザ (superuser) です。

[[users-system]]
==== システムアカウント

システムアカウントは、DNS、メール、 ウェブサーバといった各種サービスを運用するために使われます。 この目的は、セキュリティを確保するためです。 もしすべてのサービスがスーパーユーザで実行されていると、 それらのサービスはどんな動作でも可能となり、 適切な制限を適用することができません。

システムアカウントの具体例は、 `daemon`, `operator`, `bind`, `news` および `www` といったものです。

`nobody` は通常の特権を持たないシステムアカウントです。 しかし、`nobody` を利用するサービスが増えれば増えるほど、 それに所属するファイルやプロセスも増え、 その特権も大きくなるということを忘れないようにしてください。

[[users-user]]
==== ユーザアカウント

ユーザアカウントは、 主に現実のユーザがシステムにアクセスする手段として用いられるものです。 システムにアクセスするすべてのユーザは、 それぞれ唯一のユーザアカウントを持つべきです。 こうすることで管理者は誰が何を行なっているかがわかりますし、 他の人の設定を壊してしまうようなことを避けることができます。

それぞれのユーザは快適にシステムを利用するため、 シェル、エディタ、キー設定、言語など、 各自の環境をセットアップすることができます。

FreeBSD システム上のどのアカウントにも、 以下のような情報がなにかしら結び付けられています。

ユーザ名::
`login:` プロンプトに対して入力するユーザの名前です。
各ユーザは一意なユーザ名を持つ必要があります。
有効なユーザ名を作成するには man:passwd[5] に記載されているいくつもの規則があります。
アプリケーションの上位互換性を保つために、8 文字以下の小文字からなるユーザ名を使うことが推奨されています。

パスワード::
各アカウントにはパスワードがあります。

ユーザ ID (UID)::
ユーザ ID (UID) は、 FreeBSD システムがユーザを一意に識別するための数値です。 ユーザ名を指定できるコマンドは、 ユーザ名を UID に変換してから扱っています。
65535 より大きな UID は、ソフトウェアによっては互換性の問題を引き起こす可能性があるので、65535 以下の UID を使用することが推奨されています。

グループ ID (GID)::
グループ ID (GID) は、 ユーザが属する第一グループを一意に識別するための数値です。 グループは、UID ではなく、 ユーザの GID に基づいて資源へのアクセスを制御する仕組みです。 これは、ある種の設定ファイルのサイズを大幅に小さくします。 ユーザは、複数のグループに所属できます。 65535 より大きな GID は、ソフトウェアに問題を引き起こす可能性があるので、 65535 以下の GID を使うことを推奨します。

ログインクラス::
ログインクラスはグループの仕組みを拡張したもので、 別々のユーザに対してシステムを調整する時に、 さらなる柔軟性を提供します。ログインクラスの詳細については、 <<users-limiting>> で説明します。

パスワードの有効期限::
デフォルトでは、パスワードに有効期限は設定されていません。
しかしながら、パスワードの有効期限をユーザごとに設定し、一部またはすべてのユーザに、一定の時間がたったらパスワードを強制的に変更させることができます。

アカウント失効時間::
デフォルトでは、FreeBSD はアカウントを失効させません。 たとえば学校で生徒のアカウントがある場合など、 限られた期間だけのアカウントを作成するなら、 そのアカウントがいつ失効するか man:pw[8] を使って指定できます。 有効期間が経過したら、 そのアカウントのディレクトリやファイルは残っていますが、 システムへのログインはできなくなります。

ユーザの氏名::
FreeBSD ではユーザ名でアカウントを一意に識別しますが、 必ずしもユーザの本名を反映したものではありません。 この情報をアカウントに関連付けることもできます。 この情報は、コメントのように、空白、大文字、および 8 字以上で記載できます。

ホームディレクトリ::
ホームディレクトリは、システム中のディレクトリへのフルパスです。
これはユーザがログインした時に作業を開始するディレクトリです。
一般的な慣習は、すべてのユーザのホームディレクトリを `/home/username` か `/usr/home/username` の下に置くことです。
各ユーザは、個人のファイルやサブディレクトリを、ユーザのホームディレクトリに保存します。

ユーザシェル::
シェルは、 ユーザがシステムと対話するデフォルトの環境を提供します。 いろいろな種類のシェルがあり、 経験を積んだユーザはそれぞれ好みがあり、 それをアカウントの設定に反映できます。

[[users-superuser]]
==== スーパーユーザアカウント

スーパーユーザアカウントは通常 `root` と呼ばれ、 システム管理を行なうために使われ、権限に制限がありません。 そのため、このアカウントはメールのやりとり、システムの調査、 プログラミングといった日常的な作業を行なうために使われるべきものではありません。

その理由は、スーパーユーザが通常のユーザアカウントと異なり、 操作にまったく制限を受けないことによります。 そのためスーパーユーザアカウントで操作を間違えると、 システムに重大な影響を与えてしまう恐れがあるのです。 ユーザアカウントでは、 仮に操作を間違えてもシステムを壊してしまうようなことはできないようになっています。 そのため、ユーザアカウントでログインし、 高い権限が必要なコマンドを実行するときだけスーパーユーザになることが推奨されています。

スーパーユーザで実行するコマンドはいつでも、 二回、三回と確認してください。 なぜならスペースが多かったり、文字が欠けていたりするだけで、 取り返しのつかないデータの破壊につながる可能性があるからです。

スーパーユーザの権限を得るには、さまざまな方法があります。 `root` ユーザとしてログインする方法もありますが、 これはまったくお勧めできません。

スーパーユーザの権限を手に入れるには、かわりに man:su[1] を使って下さい。 `-` オプションをつけて実行すると、 実行したユーザに root ユーザの環境が設定されます。 このコマンドは `wheel` グループに入ってるユーザのみが実行でき、他のユーザは実行出来ません。 また、実行時には `root` ユーザのパスワードを必要とします。

以下の例では、`make install` を行うときにスーパーユーザの権限が必要なので、 このコマンドを実行する時だけユーザはスーパーユーザになります。 コマンドを実行したら、ユーザは `exit` を実行してスーパーユーザからログアウトし、 通常のユーザアカウントの権限に戻ります。

.スーパーユーザ権限でプログラムをインストールする
[example]
====
[source,shell]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....
====

1 人の管理者が一台のマシン、 もしくは小規模なネットワークを管理する場合には、 man:su[1] のフレームワークはうまく機能するでしょう。 この代わりとなるのは、 package:security/sudo[] package または port です。これはログ機能や、 スーパーユーザの権限で実行できるユーザやコマンドを設定できます。

[[users-modifying]]
=== アカウント情報の管理

FreeBSD は、ユーザアカウントを操作するためにさまざまなコマンドを用意しています。
もっとも一般的なコマンドが <<users-modifying-utilities>> にまとめられています。
その後で、各コマンドについて詳しい使用例を示します。
各ユーティリティの詳細や使用例についてはマニュアルページを参照してください。

[[users-modifying-utilities]]
.ユーザアカウントを管理するためのユーティティ
[cols="25h,~"]
|===
| コマンド
| 要約

|man:adduser[8]
|コマンドラインからユーザを追加するための推奨アプリケーション

|man:rmuser[8]
|コマンドラインからユーザを削除するための推奨アプリケーション

|man:chpass[1]
|ユーザデータベースの情報を変更するための柔軟なツール

|man:passwd[1]
|ユーザのパスワードを変更するコマンドラインツール

|man:pw[8]
|ユーザアカウントのあらゆる箇所を変更する強力で柔軟なツール

|man:bsdconfig[8]
|システムの設定のためのユーティリティ。アカウント管理に対応しています。
|===

[[users-adduser]]
==== ユーザの追加

新しいユーザの登録に推奨されるプログラムは man:adduser[8] です。
ユーザを追加すると、このプログラムは、`/etc/passwd` と `/etc/group` を自動的に更新します。
また、新規ユーザのホームディレクトリを作成し、`/usr/share/skel` から、デフォルトで使用される設定ファイルをコピーします。
また、新しく作成されたユーザに対して、ウェルカムメッセージをメールで送信することも可能です。
このユーティリティは、スーパーユーザ権限で実行する必要があります。

man:adduser[8] は、新しいユーザアカウントを対話的に段階的に作成するユーティリティです。
<<users-modifying-adduser>> で示されているように、必要な情報を入力するか、括弧内に示されているデフォルトの値を kbd:[Return] を押して承認してください。
この例では、ユーザは man:su[1] によってスーパユーザ権限を取得することが可能となる `wheel` グループに所属します。
操作が終了すると、ユーティリティは別のユーザを追加するか、終了するかを尋ねてきます。

[[users-modifying-adduser]]
.FreeBSD におけるユーザの追加
[example]
====
[source,shell]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
....
====

[NOTE]
====
入力したパスワードは画面に表示されませんので、 ユーザアカウントを作成する際には、 パスワードを間違えて入力してしまわないように注意してください。
====

[[users-rmuser]]
==== ユーザの削除

システムから完全にユーザを削除するには、スーパーユーザ権限で man:rmuser[8] を実行してください。
このコマンドは、次の手順を実行します。

[.procedure]
====
. 指定されたユーザの man:crontab[1] エントリが存在する場合には削除。
. 指定されたユーザの man:at[1] ジョブをすべて削除。
. 指定されたユーザが所有するすべてのプロセスに対して SIGKILL シグナルを送信。
. ローカルパスワードファイルから、 指定されたユーザのエントリを削除。
. 指定されたユーザのホームディレクトリを削除 (ディレクトリの所有者が指定されたユーザのものだった場合)。実際のホームディレクトリへのシンボリックリンクの削除も含まれます。
. `/var/mail` から、指定されたユーザの到着メールファイルを削除。
. `/tmp`, `/var/tmp`, および `/var/tmp/vi.recover` から、指定されたユーザの所有するファイルを削除。
. `/etc/group` にある すべてのグループから、指定されたユーザを削除します
(指定されたユーザと同じ名前のグループで、そのユーザが削除されると空のグループとなる場合は、そのグループ自体が削除されます。
これは man:adduser[8] によってユーザごとに作成される、ユニークなグループに対応するものです)。
. 指定されたユーザが所有するすべてのメッセージキュー、共通メモリセグメントおよびセマフォを削除
====

スーパユーザアカウントの削除に man:rmuser[8] を利用することはできません。 スーパユーザアカウントの削除はほとんどすべての場合、 大規模なシステムの破壊を意味するからです。

デフォルトでは、以下の例のような対話モードが使われます。

.`rmuser` による対話的なアカウントの削除
[example]
====
[source,shell]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
....
====

[[users-chpass]]
==== ユーザ情報の変更

すべてのユーザは、man:chpass[1] を用いてデフォルトシェルやユーザアカウントに関連した個人情報を変更できます。
スーパユーザ権限に限り、このユーティリティを用いて他のユーザのアカウント情報も変更できます。

ユーザ名の他にオプションを指定しないと、 man:chpass[1] はユーザ情報を編集するエディタを表示します。 ユーザがエディタを終了すると、 ユーザデータベースが新しい情報に更新されます。

[NOTE]
====
スーパユーザ権限以外でこのユーティリティを実行した場合は、 エディタを抜けた後にユーザのパスワードを聞かれます。
====

<<users-modifying-chpass-su>> では、スーパーユーザは `chpass jru` と入力し、このユーザに対して変更可能なフィールドが表示されています。
`jru` がこのコマンドを実行すると、最後の 6 フィールドのみが表示され編集が可能です。
この場合については、<<users-modifying-chpass-ru>> で示されています。

[[users-modifying-chpass-su]]
.スーパユーザによる `chpass` の使用
[example]
====
[source,shell]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[[users-modifying-chpass-ru]]
.通常のユーザによる `chpass` の使用
[example]
====
[source,shell]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[NOTE]
====
man:chfn[1] および man:chsh[1] コマンドはいずれも、man:chpass[1] へのリンクです。
また、man:ypchpass[1], man:ypchfn[1] および man:ypchsh[1] も同様です。
NIS のサポートは自動的に行なわれますの、 コマンドの先頭に `yp` をつける必要はありません。
NIS の設定については、ネットワークサーバの章で説明されています。
====

[[users-passwd]]
==== ユーザのパスワードの変更

いかなるユーザも man:passwd[1] を使って簡単に自身のパスワードを変更できます。
誤って、または不正なパスワードの変更を避けるため、新しいパスワードを設定する前に、もとのパスワードの入力が求められます。

.自分のパスワードの変更
[example]
====
[source,shell]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....
====

スーパーユーザは、man:passwd[1] をユーザ名を指定して実行することにより、いかなるユーザのパスワードを変更できます。
スーパーユーザの権限でこのユーティリティを実行する際には、もとのパスワードを入力する必要はありません。
そのため、ユーザが元のパスワードを忘れてしまっても、パスワードを変更できます。

.スーパーユーザ権限での他のユーザのパスワード変更
[example]
====
[source,shell]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....
====

[NOTE]
====
man:chpass[1] 同様、man:yppasswd[1] は、 man:passwd[1] へのリンクになっていますので、 NIS はどちらのコマンドでも動作します。
====

[[users-pw]]
==== システムユーザおよびグループの作成、削除、変更および表示

man:pw[8] は、ユーザやグループの作成、削除、変更および表示を行なうコマンドラインのユーティリティです。
これは、システムユーザファイルやシステムグループファイルのフロントエンドとして働きます。
man:pw[8] はとても強力な一連のコマンドラインオプションを有しており、シェルスクリプトで使うのに向いていますが、新しいユーザは、この章で紹介されている他のコマンドに比べて難しいと感じるかもしれません。

[[users-groups]]
=== グループの管理

グループとは、ユーザを羅列したものです。 グループは、グループ名と GID で識別されます。 FreeBSD では、 あるプロセスが何かするのを許可するかどうかをカーネルが判断する際に、 プロセスの UID とそのユーザが所属するグループの一覧を利用します。 ほとんどの場合、ユーザもしくはプロセスの GID は一覧の最初のグループを指しています。

グループ名から GID への写像は `/etc/group` にあります。
これは、コロンで区切られた 4 項目からなるテキストファイルです。
1 番目の項目はグループ名、2 番目は暗号化されたパスワード、3 番目が GID、4 番目がカンマで区切られたメンバの一覧です。
文法についての完全な説明は、man:group[5] をご覧ください。

スーパーユーザは、`/etc/group` をテキストエディタで編集できます。
ただし、よくある間違いを見つけてくれる man:vigr[8] を用いてグループファイルを編集することが好ましいです。
もしくは、man:pw[8] を使ってグループの追加や編集をできます。
たとえば、`teamtwo` というグループを追加して、その存在を確認するには、次のように使います。

[WARNING]
====
operator グループを使う時には、意図しないスーパーユーザへのアクセス権を与える可能性があるため注意が必要です。
シャットダウン、リブートおよびこのグループが所有する `/dev` のすべてにアクセスできるといったことが可能になってしまいます。
====

.man:pw[8] によるグループの追加
[example]
====
[source,shell]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....
====

この例では、`1100` という番号は、 `teamtwo` の GID です。 この時点では、`teamtwo` にメンバはいません。 以下のコマンドは、 `jru` を `teamtwo` のメンバに追加します。

.man:pw[8] により新しいグループにメンバを追加する
[example]
====
[source,shell]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....
====

`-M` の引数は、カンマで区切られた新しい (空の) グループに追加するもしくは存在するグループのメンバを置き換えるユーザの一覧です。
ユーザにとっては、このグループのメンバーシップはパスワードファイルに記載されているプライマリのグループとは異なります。
man:pw[8] の `groupshow` コマンドを使った時は、そのユーザはグループの一員として表示されませんが、man:id[1] などのツールを使って情報を問い合わせれば、その情報を引き出せます。
ユーザをグループに追加をする際に、man:pw[8] は `/etc/group` しか扱わず、 `/etc/passwd` から追加のデータを読んだりはしません。

.man:pw[8] によるグループへのユーザ追加
[example]
====
[source,shell]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....
====

この例では、`-m` の引数は、 カンマで区切られたグループに追加するユーザの一覧です。
前の例と異なり、これらのユーザはグループに追加され、既存のグループのユーザを置き換えることはありません。

.グループに所属しているユーザを調べるための man:id[1] の使い方
[example]
====
[source,shell]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....
====

この例では、`jru` は `jru` グループと `teamtwo` グループのメンバです。

このコマンドや `/etc/group` のフォーマットの詳細については、 man:pw[8] および man:group[5] をご覧ください。

[[permissions]]
== 許可属性

FreeBSD では、すべてのファイルおよびディレクトリは一組の許可属性を持っています。
これらの許可属性は、ユーティリティを使って確認したり変更できます。
許可属性がどのように機能するかを知ることで、ユーザが必要とするファイルにアクセスできるかどうか、オペレーティングシステムが使用しているファイルや他のユーザが所有するファイルにアクセスできないことを理解できるようになります。

この節では、FreeBSD で使用される伝統的な UNIX(R) の許可属性について説明します。
より細かいファイルシステムのアクセス制御に関しては、crossref:security[fs-acl,アクセス制御リスト] をご覧ください。

UNIX(R) では、基本の許可属性は 3 つのアクセスタイプ (読み・書き・実行) を使って割り当てられます。
これらのアクセスタイプを使って、ファイルの所有者 (owner)、グループ (group) その他 (others) に対するファイルアクセスを設定します。
読み、書き、実行に関する許可属性は、それぞれ `r`, `w`, および `x` 文字で表されます。
これらの許可属性を表す際に、オンかオフ (`0`) による 2 進数表記も使われます。
数字で表現する場合には、 `r` は `4`、`w` は `2` そして `x` は `1` の値を持つよう、`rwx` の順番で表されます。

以下は、許可属性を表す際に用いられる数字およびアルファベットをまとめた表です。
"ディレクトリの表示" カラムでは、`-` は許可属性がオフに設定されていることを表します。

.UNIX(R) 許可属性
[cols="1,1,1", frame="none", options="header"]
|===
| 値
| 許可属性
| ディレクトリの表示

|0
|読み込み不可、書き込み不可、実行不可
|`---`

|1
|読み込み不可、書き込み不可、実行可能
|`--x`

|2
|読み込み不可、書き込み可能、実行不可
|`-w-`

|3
|読み込み不可、書き込み可能、実行可能
|`-wx`

|4
|読み込み可能、書き込み不可、実行不可
|`r--`

|5
|読み込み可能、書き込み不可、実行可能
|`r-x`

|6
|読み込み可能、書き込み可能、実行不可
|`rw-`

|7
|読み込み可能、書き込み可能、実行可能
|`rwx`
|===

コマンドライン引数 `-l` とともに man:ls[1] を使うと、詳細なディレクトリリストを見ることができ、ファイルの所有者、グループ、その他への許可属性を示す欄があるのがわかります。
例えば、`ls -l` を実行して、 適当なディレクトリを表示させると以下のようになります。

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
....

`myfile` が含まれている行の一番目の列の最初の `(一番左の)` 文字は、そのファイルが普通のファイルなのか、ディレクトリなのか、キャラクタ型のデバイス特殊ファイルなのか、ソケットなのか、その他の特殊な疑似ファイルデバイスなのかといった種類を示す特別な文字です。
この例において、`-` という文字は、普通のファイルであることを示します。
その次に来る `rw-` と書かれた 3 文字は、そのファイルの所有者に許可を与えるものです。
その次の `r--` の 3 文字は、そのファイルが所属しているグループに許可を与えます。
最後の `r--` の 3 文字は、 システムに存在するその他のユーザに許可を与えます。
"-" は許可が与えられていないことを示します。
この例では、ファイルの所有者はこのファイルを読み書きでき、ファイルの所属しているグループに属するユーザはファイルを読むことだけでき、そのどちらでもないユーザは、 このファイルを読むだけできるように許可属性が与えられています。
上の表によれば、このファイルに与えられた許可属性は `644` となります。
ここで各数字は、このファイルの許可属性の 3 つの部分を表しています。

デバイスの場合の許可属性はどのようにコントロールされているのでしょうか?
FreeBSD は、大部分のハードウェアをファイルとして取り扱います。
そのため、プログラムからは普通のファイルとまったく同じようにオープンし、 データの読み書きができるようになっています。
これらのデバイス特殊ファイルは `/dev/` に収められています。

ディレクトリもまた、ファイルと同様に扱われます。
それは読み込み/書き込み/実行の許可属性を持ちます。
ディレクトリの実行ビットはファイルのそれとは少し違った意味を持ちます。
ディレクトリが実行可能になっているとき、man:cd[1] を使ってそのディレクトリに移動することができます。 
これは、そのディレクトリにあるファイルにアクセスできることを意味しています (ファイル自体の許可属性によります)。

ディレクトリの中の一覧を表示するには、そのディレクトリに読み込み属性が設定されていなければなりません。
名前が分かっているファイルを削除するには、そのファイルが含まれているディレクトリに 書き込み属性 _と_ 実行属性 の両方が必要です。

この他にも許可属性ビットはありますが、いずれも setuid バイナリや sticky ディレクトリなどといった特殊な状況で使われます。
ファイルの許可属性そのものについて、また、それらの設定方法に関する詳しい情報は、 man:chmod[1] マニュアルページを参照してください。

=== シンボリック表記

シンボリック表記と呼ばれる許可属性を表す方法では、ファイルやディレクトリの許可属性を、8 進数ではなく記号を用いて設定します。
シンボリック表記による許可属性を表す方法では、(who), (action), (permissions) という書式が用いられます。
利用できる値は以下の通りです。

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| オプション
| 文字
| 意味

|(who)
|u
|ユーザ

|(who)
|g
|ファイルを所持しているグループ

|(who)
|o
|その他

|(who)
|a
|すべて ("world")

|(action)
|+
|許可属性を与える

|(action)
|-
|許可属性を取り除く

|(action)
|=
|許可属性を指定したものにする

|(permissions)
|r
|読み込み

|(permissions)
|w
|書き込み

|(permissions)
|x
|実行

|(permissions)
|t
|Sticky ビット

|(permissions)
|s
|UID または GID を設定する
|===

これらの値は、これまでと同様に man:chmod[1] で用いますが、数字ではなく文字で指定します。
たとえば、_FILE_ に対して _FILE_ のグループメンバーおよび自分以外のすべてのユーザからアクセスを一切受け付けたくない、というときには以下のコマンドを実行してください。

[source,shell]
....
% chmod go= FILE
....

カンマ区切りで設定することで、ファイルの属性を一度に 2 つ以上変更できます。
以下の例では、_FILE_ に対して自分以外のユーザから書き込みの権限を取り上げ、かわりにすべてのユーザが _FILE_ を実行できるようにします。

[source,shell]
....
% chmod go-w,a+x FILE
....

=== FreeBSD のファイルフラグ

ファイルの許可属性に加え、FreeBSD では "ファイルフラグ" を使えます。
これはファイルにセキュリティや管理上の属性を追加するものですが、ディレクトリには追加しません。
ファイルフラグにより、`root` ユーザでさえ誤ってファイルを消去、変更してしまうことを防ぐことができます。

ファイルフラグは、man:chflags[1] を使って、簡単なインタフェースで設定できます。
例えば、`file1` というファイルにシステムレベルで消去不可のフラグを設定するには、以下のコマンドを実行してください。

[source,shell]
....
# chflags sunlink file1
....

消去不可のフラグを削除するには、以下のように `sunlink` の前に "no" をつけて実行してください。

[source,shell]
....
# chflags nosunlink file1
....

ファイルに設定されているフラグを確認するには、`-lo` と一緒に man:ls[1] を実行してください。

[source,shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

いくつかのファイルフラグの追加、削除は `root` ユーザしかできません。
他のフラグは、ファイルの所有者が変更できます。
man:chflags[1] と man:chflags[2] から、より詳細な情報を得ることをおすすめします。

=== setuid, setgid および sticky 許可属性

これまでに説明した許可属性のほかに、
すべての管理者が知っておくべき特別な設定が 3 つあります。
それは `setuid`, `setgid` および `sticky` 許可属性です。

これらの設定は、通常のユーザには許可されていない機能を提供するので、UNIX(R) の操作において重要となることがあります。
これらの許可属性を理解するためには、実ユーザ ID と実効ユーザ ID の違いに注意してください。

実ユーザ ID は、所有したりプロセスを開始する UID です。
実効 UID は、プロセスを実行するユーザ ID です。
たとえば、ユーザがパスワードを変更するときに利用する man:passwd[1] は、実ユーザ ID で起動します。
しかしながら、パスワードデータベースのアップデートの際は、実効 ID の `root` ユーザの権限で実行されます。
この仕組みにより、`Permission Denied` エラーが表示されることなく、ユーザはパスワードを変更できます。

setuid 許可属性は、以下の例で示されているように、ユーザに対して `s` の許可属性をつけることで設定できます。
 
[source,shell]
....
# chmod u+s suidexample.sh
....

setuid 許可属性は、以下の例で示されているように、指定する許可属性に数字の 4 をつけることでも設定できます。

[source,shell]
....
# chmod 4755 suidexample.sh
....

これで `suidexample.sh` の許可属性は以下のように設定されます。

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

`s` は、許可属性のファイル所有者の実行可能ビットに置き換わって反映されます。
この設定により、man:passwd[1] といったユーティリティが権限を昇格することができます。

[NOTE]
====
`nosuid` man:mount[8] オプションを使うと、このようなバイナリがユーザへの警告なしに権限を昇格できないように設定できます。
ただし `nosuid` ラッパにより回避できるため、このオプションを完全には信頼できません。
====

リアルタイムに確認するために、2 つのターミナルを開いてください。
1 つのターミナル上で、通常のユーザ権限で `passwd` と入力してください。
パスワードの入力を待つ間に、もう一つのターミナル上で、プロセステーブルおよび man:passwd[1] のユーザ情報を確認してください。

ターミナル A:

[source,shell]
....
Changing local password for trhodes
Old Password:
....

ターミナル B:

[source,shell]
....
# ps aux | grep passwd
....

[source,shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

通常のユーザ権限で man:passwd[1] を実行したにもかかわらず、実効 UID の `root` が使われています。

`setgid` 許可属性は `setuid` 許可属性と同様の機能を提供しますが、この許可属性はグループの設定を変更します。
この設定を行った上でアプリケーションまたはユーティリティを実行すると、プロセスを開始するユーザではなく、ファイルを所有するグループに対してこの許可属性を与えます。

記号を用いてファイルに `setgid` 許可属性を設定するには、man:chmod[1] で設定するグループに `s` の許可属性をつけて実行してください。

[source,shell]
....
# chmod g+s sgidexample.sh
....
 
または、man:chmod[1] で設定する許可属性の先頭に 2 をつけて実行してください。

[source,shell]
....
# chmod 2755 sgidexample.sh
....

以下に示されるように、`s` がグループの許可属性に指定されています。

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
上記の例において、対象としているシェルスクリプトが実行可能なファイルであっても、シェルスクリプトは man:setuid[2] システムコールにアクセスできないため、実効ユーザ ID では実行されません。

====

`setuid` および `setgid` 許可属性ビットは、権限の昇格を許可するので、システムのセキュリティレベルを下げます。
一方 3 番目の特殊な許可属性 `sticky bit` は、システムのセキュリティを強化します。

ディレクトリに `sticky bit` を設定すると、ファイルの所有者のみがファイルを削除できるようになります。
`/tmp` といった共有のディレクトリにおいて、ファイルの所有者以外のユーザがファイルを削除できなくなるので有用です。
この許可属性を有効にするには、ファイルに対して `t` モードを追加してください。

[source,shell]
....
# chmod +t /tmp
....

または、許可属性に 1 をつけて設定してください。

[source,shell]
....
# chmod 1777 /tmp
....

`sticky bit` が設定されていると、許可属性の最後に `t` が表示されます。

[source,shell]
....
# ls -al / | grep tmp
....

[source,shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== ディレクトリ構造

FreeBSD のディレクトリ構造は、システム全体を理解するに当たって重要です。
最も重要なディレクトリは、ルートまたは "/" です。
このディレクトリは起動時に一番最初にマウントされ、オペレーティングシステムをマルチユーザで動作させるために必要なベースシステムが含まれています。
また、ルートディレクトリには、マルチユーザへの移行中に他のファイルシステムをマウントするためのマウントポイントも含まれます。

マウントポイントとは、追加するファイルシステムを接続する先の親のファイルシステム (普通はルートファイルシステム) のディレクトリのことです。
より詳細な説明は <<disk-organization>> の節にあります。
標準的なマウントポイントには `/usr/`, `/var/`, `/tmp/`, `/mnt/` および `/cdrom/` があります。
通常これらのディレクトリについては、`/etc/fstab` というファイル中のエントリが参照されます。
このファイルは、さまざまなファイルシステムとマウントポイントの表であり、システムが参照します。
`/etc/fstab` に書かれたファイルシステムは `noauto` オプションが指定されていなければ、起動時に man:rc[8] スクリプトによって自動的にマウントされます。
詳細は <<disks-fstab>> の節をご覧ください。

ファイルシステム構造を網羅した説明は man:hier[7] に書かれています。
以下の表は、もっともよく使われるディレクトリの簡単な概要です。

[cols="25h,~"]
|===
| ディレクトリ
| 説明

|`/`
|ファイルシステムのルートディレクトリ

|`/bin/`
|シングルユーザ環境とマルチユーザ環境の両方で重要な ユーザユーティリティ

|`/boot/`
|オペレーティングシステムの起動時に使われるプログラムと設定ファイル

|`/boot/defaults/`
|デフォルトの起動設定ファイル; man:loader.conf[5] 参照

|`/dev/`
|man:devfs[4] により管理されるデバイスファイル

|`/etc/`
|システム設定ファイルとスクリプト

|`/etc/defaults/`
|デフォルトのシステム設定ファイル; 詳細については man:rc[8] 参照

|`/etc/periodic/`
|man:cron[8] 経由で毎日・毎週・毎月実行されるスクリプト; 詳細については man:periodic[8] 参照

|`/lib/`
|`/bin` および `/sbin` にあるバイナリで必要とされる重要なシステムライブラリ

|`/libexec/`
|重要なシステムファイル

|`/media/`
|CD, USB ドライブおよびフロッピーディスクなどのリムーバブルメディアのマウントポイントとして使用されるサブディレクトリを含むディレクトリ

|`/mnt/`
|システム管理者が一時的なマウントポイントとしてよく使う空のディレクトリ

|`/net/`
|自動マウント NFS 共有。man:auto_master[5] を参照

|`/proc/`
|プロセスファイルシステム; 詳細については man:procfs[5] と man:mount_procfs[8] 参照

|`/rescue/`
|man:rescue[8] で説明されている緊急時のために静的にリンクされているプログラム

|`/root/`
|`root` アカウントのホームディレクトリ

|`/sbin/`
|シングルユーザ環境とマルチユーザ環境の両方で重要なシステムプログラムと管理ユーティリティ

|`/tmp/`
|システムの再起動では通常保存 _されない_ 一時的なファイル。
メモリファイルシステムはよく `/tmp` にマウントされます。
これは man:rc.conf[5] の tmpmfs 関係の変数を使うか、`/etc/fstab` に設定項目を記入することで自動化できます。
詳しくは man:mdmfs[8] を参照して下さい。

|`/usr/`
|大部分のユーザユーティリティとアプリケーション

|`/usr/bin/`
|よく使うユーティリティとプログラミングツールとアプリケーション

|`/usr/include/`
|C の標準ヘッダファイル

|`/usr/lib/`
|ライブラリ

|`/usr/libdata/`
|いろいろなユーティリティのデータファイル

|`/usr/libexec/`
|他のプログラムから実行されるシステムデーモンとシステムユーティリティ

|`/usr/local/`
|ローカルのプログラムやライブラリなど。
FreeBSD ports フレームワークのデフォルトインストール先としても使われます。
`/usr/local` 内では、 man:hier[7] に書かれている `/usr` のための一般構造が使われます。
例外は man ディレクトリで、`/usr/local/share` の下ではなく `/usr/local` の下に直接置かれ、ports 関係文書は `share/doc/port` に置かれます。

|`/usr/ports/`
|FreeBSD Ports Collection (オプション)。

|`/usr/sbin/`
|ユーザにより実行されるシステムデーモンおよびシステムユーティリティ

|`/usr/share/`
|アーキテクチャに依存しないファイル

|`/usr/src/`
|BSD のソースファイルまたはローカルのソースファイル、あるいは両方

|`/var/`
|さまざまな用途のログ・一時的なファイル・スプールファイル。

|`/var/log/`
|いろいろなシステムログファイル

|`/var/tmp/`
|一時的なファイル。通常の設定では、ここにあるファイルはシステムが再起動しても失われません。
|===

[[disk-organization]]
== ディスク構成

ファイルを見つけるために FreeBSD が使用する構成の一番小さな単位はファイル名です。
ファイル名は、大文字と小文字を区別します。
このことは `readme.txt` および `README.TXT` が異なる二つのファイルであることを意味します。
FreeBSD はそのファイルがプログラム、または文書、あるいはその他の形式かどうかを決定するために拡張子を使用しません。

ファイルはディレクトリ内に格納されます。
ディレクトリはファイルを一つも含んでいないかもしれせんし、または数百のファイルを含んでいるかもしれません。
ディレクトリはまた別のディレクトリを含むことができるので、
データを体系づけるディレクトリの階層構造を構築できます。

ファイルおよびディレクトリは、必要な他のディレクトリ名とスラッシュ (`/`) を後に続けてファイル名またはディレクトリ名を与えることによって参照されます。
たとえば、`foo` ディレクトリがあって、その中に `bar` ディレクトリがあるとします。
そして、その中に `readme.txt` があるとすると、ファイルへのフルネーム、または _パス_ は `foo/bar/readme.txt` となります。
ファイルとディレクトリ名を分けるために `\` を使う Windows(R) とは違うことに注意してください。
FreeBSD は、パスの中にドライブレターまたは他のドライブ名を使いません。
たとえば、FreeBSD では `c:\foo\bar\readme.txt` とは書きません。

[[disks-file-systems]]
=== ファイルシステム

ディレクトリおよびファイルはファイルシステム内に格納されます。
どのファイルシステムも、そのファイルシステムのための _ルートディレクトリ_ とよばれる、まさに頂点の位置にちょうど一つのディレクトリを含んでいます。
このルートディレクトリは他のディレクトリを含むことができます。
一つのファイルシステムは _ルートファイルシステム_ または `/` として設計されています。
すべてのファイルシステムは、ルートファイルシステム以下に _マウント_ されます。
FreeBSD システムでどんなに多くのディスクを使用しても、すべてのディレクトリは、同じディスクの一部であるように見えるので問題ありません。

`A`, `B` および `C` と呼ばれる三つのファイルシステムがあるケースを考えます。
それぞれのファイルファイルシステムには一つのルートディレクトリがあり、`A1`, `A2` と呼ばれている二つの他のディレクトリを含んでいます (同様に `B1`, `B2` および `C1`, `C2` があります)。

`A` をルートファイルシステムとします。
このディレクトリになにが含まれているか見るために man:ls[1] コマンドを使うと、`A1` および `A2` の二つのサブディレクトリが表示されるでしょう。
ディレクトリツリーは以下のようになります。

image::example-dir1.png[ルートディレクトリおよび 2 つのサブツリーを持つディレクトリツリー]

ファイルシステムはマウント先のファイルシステム内のディレクトリにマウントしなければいけません。
それでは、`A1` ディレクトリに `B` ファイルシステムをマウントすると仮定します。
`B` のルートディレクトリは `A1` に置き換えられ、そして `B` 内のディレクトリがそれに応じて現れます。

image::example-dir2.png[ルートディレクトリおよび 2 つのサブツリーを持つディレクトリツリー。さらに B1 および B2 サブディレクトリが  A1 にぶら下がっています]

`B1` または `B2` 内にあるどんなファイルも、必要なときに `/A1/B1` または `/A1/B2` で到達できます。
`/A1` にあったすべてのファイルは一時的に隠されました。
それらは `B` が `A` から _アンマウント_ されたら再び現れるでしょう。

もし `B` が `A2` にマウントされていたら、この図のようになります。

image::example-dir3.png[ルートディレクトリおよび 2 つのサブツリーを持つディレクトリツリー。さらに B1 および B2 サブディレクトリが  A2 にぶら下がっています]

そして、パスはそれぞれ `/A2/B1` および `/A2/B2` となるでしょう。

ファイルシステムは互いのファイルシステム上にもマウントできます。
上記の最後の例に続けて、`C` ファイルシステム は `B` ファイルシステム内の `B1` ディレクトリ上にマウントできます。
次の図のようになります。

image::example-dir4.png[複雑なディレクトリツリー。さまざまなサブディレクトリがルート以下にぶら下がっています。]

または `C` を `A` ファイルシステムの `A1` ディレクトリの下に直接マウントできます。

image::example-dir5.png[複雑なディレクトリツリー。さまざまなサブディレクトリがルート以下にぶら下がっています。]

一つの大きなルートファイルシステムを用意し、他のファイルシステムを作成する必要としないことはまったくもって可能です。
この方法にはいくつかの短所と一つの利点があります。

.マルチファイルシステムの利点
* 異なったファイルシステムは異なった _マウントオプション_ を使用できます。
たとえば、ルートファイルシステムを読みだし専用でマウントして、不注意によってユーザが重大なファイルを削除、または編集できないようにすることができます。
また、`/home` のようなユーザが書き込み可能なファイルシステムを他のファイルシステムと分けることによって、 _nosuid_ でマウントすることが可能になります。
このオプションは、ファイルシステムに記録されている _suid_/_guid_ の実行可能ビットを有効にしないので、安全性を高めることができるでしょう。
* FreeBSD はファイルシステムがどのように使われているかによって、自動的にファイルシステム上のファイルの配置を最適化します。 したがって、連続的に書き込まれた多くの小さなファイルが含まれているファイルシステムは、より大きく少ないファイルが含まれているファイルシステムと異なる最適化をするでしょう。 一つの大きなファイルシステムを作成すると、この最適化は成り立たなくなります。
* FreeBSD のファイルシステムはトラブルが起きても強固です。 しかしながら臨界点でのトラブルは、ファイルシステムの構造にまだ損害を与えるかもしれません。 マルチファイルシステムへデータを分割しておくことで、 必要なときにバックアップからレストアすることをより容易にして、まだシステムが回復するかもしれません。

.シングルファイルシステムの利点
* ファイルシステムは固定サイズです。 FreeBSD をインストールするときにファイルシステムを作成して、 固定サイズを割りあてたなら、 後になってそのパーティションをより大きくする必要があると気づくかもしれません。 パーティションのサイズを変更するには、 バックアップ、新しいサイズを指定したファイルシステムの再作成、 バックアップしたデータをリストアする作業が必要となるでしょう。
+
[IMPORTANT]
====
FreeBSD には、 man:growfs[8] コマンドがあります。
このコマンドは、この制限を取り除いて、ファイルシステムのファイルを直ちに増加させることを可能にします。 
ファイルシステムは、そのファイルシステムのあるパーティションの空いている領域に対してのみ拡張できます。
パーティションを分割した後、空いている領域があれば、man:gpart[8] を用いてパーティションを拡張できます。
仮想ディスクの最後のパーティションであれば、ディスクを大きくすると、パーティションを拡張できます。
====

[[disks-partitions]]
=== ディスクパーティション

ファイルシステムは _パーティション_ 内に含まれています。
ディスクは 1 つのパーティションスキーム (<<bsdinstall-part-manual>>) を用いてパーティションに分割されます。
新しいスキームは GPT で、古い BIOS-ベースのコンピュータは MBR を使用します。
GPT は、サイズ、オフセットおよびタイプによるディスクのパーティション分割に対応しています。
多くのパーティションおよびパーティションタイプに対応しているため、GPT が利用できる場合はこのパーティションスキームを使用することが推奨されます。
GPT パーティションは、接尾語 `p1` が最初のパーティション、接尾語 `p2` が 2 番目のパーティションといったような接尾語を使います。
一方 MBR パーティションは少ない数のパーティションにのみ対応しています。
MBR パーティションは、FreeBSD では `スライス` として知られています。
スライスは他のオペレーティングシステムでも使うことができます。
FreeBSD のスライスはさらに、BSD ラベル (man:bsdlabel[8] 参照) を用いてパーディションに分割できます。

スライス番号は 1 から始まり `s` を前につけられて、デバイス名の後に続きます。
したがって、"da0__s1__" は一番目の SCSI ドライブ上の一番目のスライスです。
ディスク上に存在できる物理スライスは、4 つまでですが、適切な種類の物理スライス内に論理スライスを作成できます。
これらの拡張されたスライス番号は 5 から始まります。
したがって、 "ada0__s5__" は、一番目の SATA ディスク上の一番目の拡張スライスです。
これらのデバイスは、スライスを占有することを予期するファイルシステムによって使用されます。

GPT または BSD の各パーティションは、一つのファイルシステムだけを含むことができます。
このことは、ファイルシステムがファイルシステムの階層上の典型的なマウントポイント、または含まれているパーティション名によって記述されることを意味します。

FreeBSD は _スワップ領域_ にもまたディスク領域を使用します。
スワップ領域は FreeBSD に _仮想メモリ_ を提供します。
これはあなたのコンピュータが、 実際に搭載している以上のメモリがあるかのように振舞います。
FreeBSD がメモリを使い果たしたときに、現在使用されていないデータのいくつかをスワップ領域に移動し、そのデータが必要となったときに (その他のデータをスワップ領域に移動させてから) メモリ内に移動しなおします。
これは _ページング_ と呼ばれます。

いくつかの BSD パーティションはある慣習と関係づけられています。

[cols="25h,~"]
|===
| パーティション
| 慣習

|`a`
|通常、ルートパーティションを含みます。

|`b`
|通常、スワップ領域を含みます。

|`c`
|通常、スライス全体と同じサイズです。
これは、スライス全体にアクセス必要のあるユーティリティ (たとえば、ひどいブロックスキャナ) が、 `c` パーティションにアクセスすることを可能にします。
通常、このパーティション内にファイルシステムは作成されません。

|`d`
|`d` パーティションは、 それに関連づけられた特別な意味を持っていましたが、 今は無いので、普通のパーティションとして動作するでしょう。
|===

スライスおよび "危険な専用" の物理ドライブ、 そして他のドライブは `a` から `h` までの文字として表される BSD パーティションを含んでいます。
この文字はデバイス名に追加されます。
したがって、 "da0__a__" は一番目の "危険な専用" `da` ドライブ上の `a` パーティションです。
"ada1s3__e__" は、 二番目の SATA ディスク上の 三番目のスライス内にある五番目のパーティションです。

最後に、システム上のそれぞれのディスクは識別されます。
ディスク名はどの種類のディスクであるかを示す記号ではじまり、どのディスクかを示す数字が続きます。
パーティションやスライスとは異なり、ディスクの番号づけは 0 から始まります。
共通の記号は <<disks-naming>> に示されます。

スライスにあるパーティションを参照するときには、ディスク名、`s`、スライス番号、そしてパーティション文字を含めてください。
<<basics-disk-slice-part>> に例があります。
GPT パーディションはディスク名、`p` そしてパーティション番号が含まれます。

<<basics-concept-disk-model>> は、MBR スライスを用いたディスク構成の概念のモデルを示します。

FreeBSD をインストールする際には、MBR を使用する場合にはディスクスライスを設定し、次に FreeBSD に用いるスライス内のパーティションを作成します。
GPT を使用する場合には、各ファイルシステムにパーティションを設定します。
どちらのケースでも、それぞれのパーティション内にファイルシステムまたはスワップ領域を作成し、ファイルシステムがどこにマウントされるか決定してください。
パーティションの操作についての詳細は man:gpart[8] をご覧ください。

[[disks-naming]]
.ディスクデバイス名
[cols="1,1", frame="none", options="header"]
|===
| ドライブタイプ
| ドライブデバイス名

|SATA および IDE ハードドライブ
|`ada`

|SCSI ハードドライブおよび USB ストレージデバイス
|`da`

|NVMe ストレージ
|`nvd` または `nda`

|SATA および IDE CD-ROM ドライブ
|`cd`

|SCSI CD-ROM ドライブ
|`cd`

|フロッピードライブ
|`fd`

|SCSI テープドライブ
|`sa`

|RAID ドライバ
|`aacd` (Adaptec(R) AdvancedRAID), `mlxd` および `mlyd` (Mylex(R)), `amrd` (AMI MegaRAID(R)), `idad` (Compaq Smart RAID), `twed` (3ware(R) RAID) など
|===

[example]
====
[[basics-disk-slice-part]]
.ディスク名、スライス名、パーティション名のサンプル
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 名前
| 意味

|`ada0s1a`
|一番目の SATA ディスク (`ada0`) 上の一番目のスライス (`s1`) 内の一番目のパーティション (`a`)。

|`da1s2e`
|二番目の SCSI ディスク (`da1`) 上の二番目のスライス (`s2`) 内の五番目のパーティション (`e`)。
|===
====

[[basics-concept-disk-model]]
.ディスクの概念的構成
[example]
====
これはシステムに接続された一番目の SATA ディスクの FreeBSD から見た図を示します。
ディスクサイズは 250 GB と仮定し、80 GB のスライス (MS-DOS(R) でいうパーティション) および 170 GB のスライスがあるとします。
一番目のスライスは Windows(R) NTFS ファイルシステム `C:` を含んでいます。
そして、二番目のスライスは FreeBSD のディスクを含んでいます。
これは FreeBSD インストーラが四つのデータパーティションと一つのスワップパーティションを作成した例です。

四つのパーティションはそれぞれファイルシステムを含んでいます。
パティション `a` はルートファイルシステム、`d` は `/var`, `e` は `/usr`、そして `f` は `/usr` に使用されています。
パーティション `c` はスライス全体を示しており、通常のパーティションとは異なる使われ方をします。

image::disk-layout.png[Windows と FreeBSD を 1 つのドライブに共存させたレイアウト]
====

[[mount-unmount]]
== ファイルシステムのマウントとアンマウント

ファイルシステムは `/` をルート (根) とする木構造として考えると視覚的に理解しやすいでしょう。
ルートディレクトリにある `/dev` や `/usr`、その他のディレクトリは枝に相当し、それらには、`/usr/local` などのように、さらに枝分かれすることができます。

さまざまな理由がありますが、 ディレクトリをいくつかの異なるファイルシステム上に構築するのが良いでしょう。
たとえば `/var` には、 `log/` や `spool/` など、さまざまな種類の一時ファイルを置くディレクトリがあるため、あふれてしまう可能性があります。
ルートファイルシステムをあふれさせるのは得策ではありませんので、普通は `/var` を `/` から分離します。

また、次のような場合も、ディレクトリツリーを別のファイルシステムに置く理由として良くあげられます。
それは、たとえば物理的に別のディスクにディレクトリツリーを置く場合、 crossref:advanced-networking[network-nfs, 「ネットワークファイルシステム (NFS)」] で説明されているようにネットワークファイルシステムをマウントしたり、CDROM ドライブのような別の仮想ディスクに置くという場合です。

[[disks-fstab]]
=== fstab ファイル

`/etc/fstab` に書かれているファイルシステムは、`noauto` オプション指定されているエントリを除いて crossref:boot[boot,起動プロセス] の途中で自動的にマウントされます。
このファイルは、 次のような書式で書かれたエントリを含んでいます。

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
デバイス名。crossref:disks[disks-naming,「デバイス名」] に説明があります。

`mount-point`::
ファイルシステムがマウントするディレクトリ。

`fstype`::
man:mount[8] に渡されるファイルシステムタイプ。 FreeBSD ファイルシステムのデフォルトは `ufs` です。

`options`::
読み書きするファイルシステムには `rw`、読み込み専用のファイルシステムには `ro` を、必要な他のオプションの前に指定します。 よく使われるオプションは `noauto` で、 起動時にはマウントされないファイルシステムに使います。 その他のオプションは man:mount[8] マニュアルページに載っています。

`dumpfreq`::
これは man:dump[8] が使うもので、 どのファイルシステムにダンプが必要なのかを決めます。 この項目がなければ、0 であるものとみなされます。

`passno`::
これは再起動後に man:fsck[8] がチェックする UFS ファイルシステムの順番を決めます。
ファイルシステムチェックを飛ばしたいファイルシステムには、`passno` を 0 に設定してください。
ルートファイルシステムはどれよりも先にチェックする必要があり、`passno` は 1 に設定してください。 他のファイルシステムの `passno` は 1 以上に設定してください。 同じ `passno` のファイルシステムがあった場合、 man:fsck[8] は可能であれば並行してファイルシステムのチェック を行なおうとします。

`/etc/fstab` の書式やオプションに関しての詳細は、 man:fstab[5] をご覧ください。

[[disks-mount]]
=== man:mount[8] の使い方

ファイルシステムは man:mount[8] を用いてマウントされます。
基本な構文は以下のようになります。

[example]
====
[source,shell]
....
# mount device mountpoint
....
====

`/etc/fstab` に記載されているファイルシステムについても、マウントポイントを指定することでマウントできます。

man:mount[8] で説明されているように、このコマンドはたくさんのオプションを提供します。
最もよく使われるのは次のものです。

.マウントオプション
`-a`::
`/etc/fstab` にある全てのファイルシステムをマウントします。 例外は "noauto" の印がついているものと、 `-t` フラグで除外されたものと、 すでにマウントされているファイルシステムです。

`-d`::
実際にマウントシステムコールする以外のすべてのことをします。 このオプションは `-v` フラグと組み合わせて使い、 man:mount[8] が実際なにをしようとしているのか調べるのに便利です。

`-f`::
クリーンでないファイルシステムを強制的にマウントします (危険です)。もしくは、ファイルシステムのマウント状態を 読み書き可能から読み込みのみに変更するとき、 書き込みアクセスを強制的に取り消します。

`-r`::
ファイルシステムを読み込み専用でマウントします。
`-o ro` を使うのと同じです。

``-t _fstype_``::
指定のファイルシステムタイプでマウントします。 または、`-a` を使った場合、 指定したタイプのファイルシステムのみマウントします。
デフォルトのファイルシステムタイプは "ufs" です。

`-u`::
ファイルシステムのマウントオプションを更新します。

`-v`::
詳細な出力にします。

`-w`::
ファイルシステムを読み書き可能にマウントします。

`-o` には、 次のようなオプションを複数カンマで区切って指定できます。

nosuid::
そのファイルシステム上の setuid や setgid フラグを解釈しません。 これもセキュリティのために有用なオプションです。

[[disks-umount]]
=== man:umount[8] の使い方

ファイルシステムをアンマウントするには、man:umount[8] を使ってください。
このコマンドは、パラメータとしてマウントポイントの一つ、 デバイス名、もしくは `-a` や `-A` といったオプションを取ります。

いずれの形式でも `-f` で強制的なアンマウントを行ない、 `-v` で詳細な出力を出します。
ただしほとんどの場合、`-f` は使わないほうがよいでしょう。
計算機がクラッシュしたりファイルシステム上部のデータが破壊されたりする恐れがあります。


マウントされているファイルシステムすべてをアンマウントするには、`-a` と `-A` を使ってください。
`-t` にファイルシステムタイプを指定すると、指定されたものだけがアンマウントされます。
`-A` を使うとルートファイルシステムはアンマウントしません。

[[basics-processes]]
== プロセスおよびデーモン

FreeBSD はマルチタスクのオペレーティングシステムです。
動作中のプログラムはそれぞれ _プロセス_ と呼ばれます。
すべてのコマンドは実行すると、最低でも 1 つの新しいプロセスを開始します。
FreeBSD により実行されているシステムプロセスもたくさんあります。

各プロセスは _プロセス ID_ (PID) と呼ばれる数字でただ一つに識別されます。
ファイルのように各プロセスには所有者とグループがあり、
所有者とグループの許可属性は、そのプロセスが開けるファイルやデバイスを決定するために使われます。
多くのプロセスには親プロセスもあります。
親プロセスとは、そのプロセスをスタートさせたプロセスのことです。
例えば、シェルがプロセスで、シェルから起動されるコマンドは、シェルを親プロセスとするプロセスとなります。
例外は man:init[8] という特別なプロセスです。
`init` は FreeBSD がスタートするときに起動される最初のプロセスで、PID は常に `1` です。

ユーザから始終入力があるように設計されていないプログラムがあり、そういったプログラムは最初から端末と切り離されています。
例えば、ウェブサーバはユーザからの入力ではなくウェブのリクエストを処理します。
メールサーバも、 こういった種類のアプリケーションの一例です。
このような種類のプログラムは、 _デーモン_ と呼ばれます。
デーモンはギリシャ神話から来ており、目に見えないように役立つことをしてくれる善でも悪でもない実体を表します。
このため、BSD のマスコットはスニーカーをはいてフォークを携えたかわいらしい姿のデーモンなのです。

通常デーモンとして動作するプログラムには末尾に "d" を持った名前をつける慣習があります。
例えば、BIND は Berkeley Internet Name Domain ですが、 実際実行されるプログラムは `named` です。
また、Apache ウェブサーバのプログラムは `httpd`、ラインプリンタスプーリングデーモンは `lpd` です。
これは単なる命名に関する慣習です。
例えば、Sendmail アプリケーションの主なメールデーモンは `sendmail` で、`maild` ではありません。

=== プロセスを確認する

システム上で実行中のプロセスを確認するには、man:ps[1] または man:top[1] を使ってください。
現在動作中のプロセスのリスト、プロセスの PID やプロセスが使っているメモリの量、どういうコマンドラインで起動されたのかなどを表示させるには、man:ps[1] を使ってください。
man:top[1] を使用すると、動作中の全てのプロセスを表示できます。
数秒ごとに表示を更新するので、計算機が何をしているのかインタラクティブに知ることができます。

デフォルトでは、man:ps[1] はユーザにより動作中かつ所有のコマンドのみを表示します。
例えば:

[source,shell]
....
% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps
....

man:ps[1] の出力はいくつかの列に整形されています。
`PID` の列はプロセス ID を表示します。
PID は 1 から順に 99999 まで割り当てられ、その後足りなくなると最初に戻って使い回されます。ただし、使用中の PID には割り当てられません。
`TT` の列はプログラムが動いている tty を示し、`STAT` はプログラムの状態を示します。
`TIME` はプログラムがその CPU 上で動いている時間の長さです。
通常はプログラムをスタートさせたときからの経過時間ではありません。
多くのプログラムは、CPU 上で時間を使う必要があるまでかなりの時間を費すためです。
最後に、`COMMAND` はそのプログラムを起動するのに使われたコマンドとなります。

表示する情報を変更するオプションが用意されています。
いちばん便利なのは `auxww` でしょう。
`a` はすべてのユーザの動作中のプロセス全部についての情報を表示します。
`u` はプロセスの所有者のユーザ名とメモリ使用量を表示します。
`x` はデーモンプロセスについての情報を表示し、`ww` で、スクリーンに入りきらないほど長くなったコマンドラインでも省略せず、man:ps[1] に各プロセスの全コマンドラインを表示させます。

man:top[1] の出力も同様です。

[source,shell]
....
% top
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

出力は2つのセクションに分かれています。
ヘッダ (最初の 5 または 6 行) は動作している最新のプロセスの PID、システムの平均負荷 (システムがどれくらい忙しいかの指標)、システムの稼働時間 (最後の再起動からの時間) と現在の時刻を示します。
ヘッダの中の他の数字は動作中のプロセスの数、使われているメモリとスワップ領域の量、そしてシステムが異なる CPU 状態に消費した時間と関係します。
ZFS ファイルシステムのモジュールをロードしている場合には、`ARC` 行にはディスクではなくメモリキャッシュから読み込んだデータ量が表示されます。

ヘッダの下には、PID、ユーザ名、消費 CPU 時間とプロセスを起動したコマンドといった man:ps[1] の出力と同じような情報を持った行が続きます。
man:top[1] を使うとデフォルトでプロセスが使っているメモリ容量を表示します。
メモリ使用量の欄は 2 項目に分かれており、 一方は合計使用量、 そしてもう一方は実使用量です。
合計使用量はアプリケーションが必要としているメモリ量で、実使用量はその時点で実際に使われているメモリ量です。

man:top[1] は自動的に 2 秒ごとに画面を更新します。
`-s` 使うと更新間隔を変更することができます。

[[basics-daemons]]
=== プロセスの終了

動作中のプロセスもしくはデーモンと通信する一つの方法は、man:kill[1] を用いて _シグナル_ を送信する方法です。
送信可能なシグナルはたくさんあります。
特別な意味があるものもあれば、アプリケーションの文章に説明されているものもあります。
ユーザは自分が所有者となっているプロセスにのみシグナルを送ることができます。
他人のプロセスにシグナルを送ると、permission denied というエラーになるでしょう。
この例外は `root` ユーザで、 ルートユーザは誰のプロセスに対してもシグナルを送ることができます。

オペレーティングシステムもプロセスにシグナルを送ることができます。
アプリケーションを下手に書いてしまい、予想外のメモリにアクセスしようとすると、FreeBSD はプロセスに "セグメンテーション違反" シグナル (`SIGSEGV`) を送ります。
ある程度の時間が経ったら man:alarm[3] システムコールを使って警告してもらうように書かれているアプリケーションには、"警告" シグナル (`SIGALRM`) が送信されます。

プロセスを止めるためには2つのシグナル、`SIGTERM` か `SIGKILL` を使います。
`SIGTERM` は穏かにプロセスを終了させる方法です。
プロセスはシグナルを受け取ることができ、開いているすべてのログファイルを閉じ、終了前にしていたことを終えるように試みることができます。
中断できない処理の途中だと、`SIGTERM` をプロセスが無視することもあるかもしれません。

プロセスは `SIGKILL` を無視することができません。
プロセスに `SIGKILL` を送ると、プロセスは通常その時点で止まります。

他に良く使われるシグナルには、`SIGHUP`、`SIGUSR1` と `SIGUSR2` があります。
これらは一般的な用途のシグナルなので、このシグナルが送信されたときの応答は、アプリケーション毎に異なります。

例として、ウェブサーバの設定ファイルを変更後、ウェブサーバに設定を再読み込みさせる必要があります。
`httpd` を再起動するとウェブサーバは一瞬ながら停止してしまいます。
その代わりに `SIGHUP` シグナルを送りましょう。
デーモンごとに行動が違うので、`SIGHUP` が期待する結果となるように、そのデーモンの文書を読んで確認してください。

[IMPORTANT]
====
システム上のランダムプロセスを終了させるのはよくありません。
特に、PID が 1 の man:init[8] は特別です。
`/bin/kill -s KILL 1` は推奨されていませんが、実行するといとも簡単にシステムをシャットダウンさせることができます。
kbd:[Return] を押す _前_ に man:kill[1] を実行する引数を二重にチェックする _癖_ をつけてください。
====

[[shells]]
== シェル

_シェル_ は、オペレーティングシステムを利用するためのコマンドラインインタフェースを提供します。
シェルは入力チャンネルからコマンドを受け取り、それらを実行します。
大部分のシェルは、日々の作業、ファイル管理やファイル名の展開、コマンドライン編集、コマンドマクロ、環境変数といった組み込みの機能を持ってます。
FreeBSD には Bourne Shell (man:sh[1]) や 高機能 C-shell (man:tcsh[1]) が含まれています。
また、これ以外にも `zsh` や `bash` などのシェルが FreeBSD Ports Collection から利用可能です。

どのシェルを使うかは、まったく趣味の問題です。
あなたが C のプログラマだったとすれば、man:tcsh[1] のような C 風のシェルの方が落ち着くかもしれません。
Linux(R) ユーザであれば、`bash` を好まれるでしょう。
それぞれのシェルは、 ユーザの好みの作業環境で利用できる (もしくはできない) 独自の機能を持っているということ、そして、どのシェルを使うことにするかを決めるのはユーザ自身ということです。

シェルの一般的な機能の一つに、ファイル名の補完があります。
コマンドやファイル名の最初の数文字を入力して kbd:[Tab] を押すと、シェルにコマンドやファイル名の残りの部分を補完させることができます。
例として、`foobar` および `footbar` という二つのファイルがあるとします。
`foobar` を削除するために `rm foo` と入力し、kbd:[Tab] を押してファイル名を補完しようとします。

しかしシェルは `rm foo` とだけ出力します。
`foobar` および `football` のファイル名は、両方とも `foo` から始まるため、ファイル名の補完を完全には行なえませんでした。
一つ以上のファイル名にマッチした場合、ビープ音をらすシェルもあれば、選択できるすべてのファイル名を表示するシェルもあります。
この場合、希望するファイル名を同定するために、ユーザはさらに文字を入力する必要があります。
`t` を入力してもう一度 kbd:[Tab] を押すと、シェルはファイル名を確定でき、ファイル名の残りの部分が補完されます。

もう一つあげられるシェルの特徴として、環境変数があります。
環境変数とは、シェルの環境変数におけるキーと値とのペアです。
この環境変数は、そのシェルから起動されたプログラムから参照でき、それを利用してプログラムの設定を保存するのに利用されます。
<<shell-env-vars>> は、一般的な環境変数とその意味の一覧です。
環境変数の名前は常に大文字です。

[[shell-env-vars]]
.一般的な環境変数
[cols="25h,~"]
|===
| 変数名
| 意味

|`USER`
|現在のログインユーザのユーザ名。

|`PATH`
|コロンで区切られた実行ファイル探索のための ディレクトリのリスト。

|`DISPLAY`
|接続する Xorg ディスプレイのネットワーク名 (存在する場合のみ)。

|`SHELL`
|現在のシェル。

|`TERM`
|ユーザの端末種名。 端末のケーパビリティを決定するのに使われる。

|`TERMCAP`
|種々の端末の機能を実現する端末のエスケープコードの データベースのエントリ。

|`OSTYPE`
|オペレーティングシステムの種別。

|`MACHTYPE`
|システムの CPU アーキテクチャ。

|`EDITOR`
|ユーザの選んだテキストエディタ。

|`PAGER`
|ユーザの選んだ画面上でテキストを見るためのユーティリティ。

|`MANPATH`
|コロンで区切られたマニュアルページ探索のための ディレクトリのリスト。
|===

環境変数を設定する方法は、シェルごとに多少異なります。
man:tcsh[1] や man:csh[1] では `setenv` を使います。
man:sh[1] や `bash` 等の Bourne シェルでは、`export` を使って現在の環境変数を設定します。
以下の例では、`tcsh` シェルでデフォルトの `EDITOR` を `/usr/local/bin/emacs` に設定します。

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

`bash` では次のようになります。

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

現在の設定を確認するために、コマンドライン中の変数名の前に `$` 文字を置くことで、環境変数を展開させることができます。
たとえば、`echo $TERM` は `$TERM` が セットされている内容を表示します。

シェルは特殊文字を、特別なデータを表すものとして扱います。
その特殊文字はメタキャラクタと呼ばれます。
もっとも一般的なメタキャラクタは `\*` で、これはファイル名に含まれる、あらゆる文字を表します。
メタキャラクタはファイル名の展開に使われます。
たとえば、`echo *` と入力すると `ls` と入力したのとほとんど同じ結果を得られます。
これはシェルが `*` とマッチするすべてのファイルを受け取って `echo` はコマンドラインでそれらを表示するからです。

特殊文字をシェルに解釈させないようにするため、特殊文字の前にバックスラッシュ文字 (`\`) を置いてエスケープしてください。
例えば `echo $TERM` は端末の設定を表示し、`echo \$TERM` は `$TERM` とそのまま表示します。

[[changing-shells]]
=== シェルの変更

デフォルトのシェルを変更する一番簡単な方法は `chsh` を使うことです。
このコマンドを実行すると、環境変数 `EDITOR` で示されたエディタ (デフォルトでは man:vi[1] が設定されている) が立ち上がります。
`Shell:` の行を変更するシェルの絶対パスに変更してください。

代わりに `chsh -s` を使うと、エディタを起動せずにシェルを変更できます。
たとえば、シェルを `bash` に変えたいなら、次のようにしてください。 

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

プロンプトに対してパスワードを入力し、kbd:[Return] を押すと、シェルが変更されます。
新しいシェルを使うには、一度ログオフしてから再ログインしてください。

[NOTE]
====
使おうと思っているシェルは__必ず__ `/etc/shells` 中に書かれていなければなりません。
シェルを crossref:ports[ports,アプリケーションのインストール - packages と ports] で説明されている FreeBSD の Ports Collection からインストールしたのであれば、自動的にこのファイルに追加されています。
もし書かれていなければ、以下のコマンドで、パスをシェルのパスに置き換えて使って追加してください。

[source,shell]
....
# echo /usr/local/bin/bash >> /etc/shells
....

その後 man:chsh[1] を実行してください。
====

=== 高度なシェルの機能

UNIX(R) のシェルは単なるコマンドインタプリタではなく、ユーザが実行したコマンドの出力をリダイレクトしたり、入力をリダイレクトすることによりコマンドをお互いに繋げることで、最終的なコマンドの出力結果を改良できます。
この機能をビルトインコマンドとともに用いることで、ユーザは最大化された効率の環境を入手できます。

シェルのリダイレクト機能を使うことで、コマンドの出力や入力を別のコマンドに送ったり、ファイルに送ることができます。
たとえば、 man:ls[1] コマンドの出力をキャプチャするには、
出力をファイルにリダイレクトしてください。
以下はその例です。

[source,shell]
....
% ls > directory_listing.txt
....

実行すると、現在の作業ディレクトリにあるファイルの一覧が `directory_listing.txt` に出力されます。
man:sort[1] のようなコマンドは、入力を読み込むことができます。
先ほど得たファイルの一覧をソートするには、入力元をファイルにリダイレクトしてください。

[source,shell]
....
% sort < directory_listing.txt
....

入力された内容はソートされ画面に出力されます。
この出力を他のファイルにリダイレクトするには、リダイレクトの向きを混ぜるように man:sort[1] の出力をリダイレクトしてください。

[source,shell]
....
% sort < directory_listing.txt > sorted.txt
....

これまでの例では、ファイルディスクリプタを用いてコマンドに対しリダイレクトを行っています。
すべての UNIX(R) システムは標準入力 (stdin)、標準出力 (stdout) および標準エラー (stderr) といったファイルディスクリプタを持っています。
それぞれに対象があり、
入力はキーボードまたはマウスなどの入力を提供するものが対象、出力はスクリーンであったりプリンタ用紙が対象です。
また、エラーは診断やエラーメッセージに用いられるものが対象です。
これらは、I/O ベースのファイルディスクリプタ、時にはストリームと考えられます。

これらのディスクリプタを使用することで、シェルは出力と入力についてさまざまなコマンドを経由させ、また、ファイルに対して出力し、もしくはファイルから読み込むようにリダイレクトできます。
リダイレクトの他の方法は、パイプの機能です。

UNIX(R) のパイプ記号 "|" は、コマンドの出力を他のプログラムに直接渡します。
基本的には、パイプはコマンドの標準出力を他のコマンドの標準出力に渡します。
以下はその例です。

[source,shell]
....
% cat directory_listing.txt | sort | less
....

この例では、`directory_listing.txt` の内容がソートされ、その結果が man:less[1] に渡されます。
このコマンドを実行すると、出力がスクロールして画面から見えなくなることをさけることができて、ユーザは出力を自分のペースでスクロールできます。

[[editors]]
== テキストエディタ

FreeBSD の設定の多くは、テキストファイルの編集で行われます。
そのため、テキストエディタの扱いに慣れると良いでしょう。
FreeBSD には、基本システムの一部として二、三提供されるものと、Ports Collection から利用できる、たくさんのテキストエディタが用意されています。 

学習が簡単なエディタは、 easy editor の略で man:ee[1] と呼ばれるものです。
このエディタを立ち上げるには、`ee _filename_` と入力してください。
ここで _filename_ は、 編集しようとしているファイルの名前です。
一旦このコマンドの中に入れば、 エディタの機能を操作するコマンドはすべてディスプレイの上部に表示されています。
キャレット (`^`) は kbd:[Ctrl] を意味するので、`^e` は kbd:[Ctrl+e] を押すという意味になります。
man:ee[1] を終了するには kbd:[Esc] を押し、そしてメインメニューから "leave editor" オプションを選択してください。
ファイルが更新されていたときは、エディタは変更をセーブするかどうかプロンプトを出します。

FreeBSD には、ベースシステムの一部として man:vi[1] といったより強力なテキストエディタが用意されています。
package:editors/emacs[] および package:editors/vim[] といった他のエディタは Ports Collection の一部として用意されています。
これらのエディタはやや学習が複雑ですが、より高い機能性を提供します。
しかし、あなたが多量のテキストを編集することを考えているなら、 vim や Emacs といった強力なエディタを習得することは、 より多くの時間を節約することでしょう。

ファイルを編集したり、文字入力を必要とするようなアプリケーションの多くは、自動的にテキストエディタを起動します。
<<shells>> の節で説明したように、デフォルトのエディタを変更するには `EDITOR` 環境変数に希望するエディタを設定してください。

[[basics-devices]]
== デバイスとデバイスノード

デバイスとはシステム上のハードウェアに関するものに対してよく使われる用語で、ディスクやプリンタ、グラフィックカードやキーボードが含まれます。
FreeBSD が起動するとき、ブートメッセージの大部分は検出されたデバイスについてのものです。
ブートメッセージは `/var/run/dmesg.boot` に保存されています。

各デバイスはデバイス名と番号を持ちます。
例えば、`ada0` は最初の SATA CD-ROM ドライブで、`kbd0` はキーボードを表します。

FreeBSD におけるほとんどのデバイス、デバイスノードと呼ばれる `/dev` にあるスペシャルファイルを通してアクセスしなければなりません。

[[basics-more-information]]
== マニュアルページ

FreeBSD についてのもっとも包括的な文書は、 マニュアルページの形式になっているものです。
FreeBSD システム上のほとんどすべてのプログラムには、基本的な操作方法と利用可能な引数を説明しているリファレンスマニュアルが添付されています。
これらのマニュアルは `man` を使って見ることができます。

[source,shell]
....
% man コマンド名
....

ここで `コマンド名` のところには、知りたいコマンドの名前を入れます。
たとえば man:ls[1] について知りたい場合には、次のように入力します。

[source,shell]
....
% man ls
....

マニュアルは、トピックごとにセクション番号で分類されています。
FreeBSD では、以下のセクションがあります。

. ユーザコマンド
. システムコールとエラー番号
. C のライブラリ関数
. デバイスドライバ
. ファイル形式
. ゲームや娯楽
. さまざまな情報
. システムの管理と操作のためのコマンド
. システムカーネルインタフェース

時折、 同じトピックがオンラインマニュアルの複数のセクションに記載されている場合があります。
たとえば、`chmod` ユーザコマンドと `chmod()` システムコールの場合がそれに該当します。
man:man[1] にセクション番号を与えることで、 表示したいセクションを指定できます。

[source,shell]
....
% man 1 chmod
....

上のようにすれば、ユーザコマンド man:chmod[1] のマニュアルページが表示されます。
オンラインマニュアルの特定セクションへの参照は、慣習的に書かれている文書で括弧の中に示されます。
すなわち、man:chmod[1] はユーザコマンドを、man:chmod[2] はシステムコールの方を示しています。

マニュアルページの名前を知らない場合には、`man -k` を使ってマニュアルページの解説 (description) からキーワードを検索してください。

[source,shell]
....
% man -k mail
....

このコマンドは、"mail" というキーワードをコマンド解説に含むコマンドの一覧を表示します。
これは man:apropos[1] と同等の機能です。

`/usr/sbin` にあるすべてのコマンドの説明を読むには、以下のように実行してください。

[source,shell]
....
% cd /usr/sbin
% man -f * | more
....

または、以下を実行してください。

[source,shell]
....
% cd /usr/sbin
% whatis * |more
....

[[basics-info]]
=== GNU の Info ファイル

FreeBSD には Free Software Foundation (FSF) によるアプリケーションやユーティリティが含まれています。
これらのプログラムには、マニュアルページに加えて `info` ファイルと呼ばれるハイパーテキスト形式の文書が付属しています。
この文書は man:info[1]、あるいは package:editors/emacs[] をインストールしているなら emacs の info モードで読むことができます。

man:info[1] を使うには、次のように入力してください。

[source,shell]
....
% info
....

`h` と入力すると、 簡単な手引きを読むことができます。 クイックコマンドリファレンスは `?` を入力してください。
