---
title: 第3章 UNIX の基礎知識
part: パートI. 導入
prev: books/handbook/bsdinstall
next: books/handbook/ports
showBookMenu: true
weight: 5
path: "/books/handbook/"
---

[[basics]]
= UNIX の基礎知識
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 3
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== この章では

この章では FreeBSD オペレーティングシステムの基本的なコマンドと機能について記述しています。
ここに書かれてあることのほとんどは、どんな UNIX(R) -like なオペレーティングシステムにもあてはまります。
FreeBSD の初心者であれば、この章を読んでおいた方がきっといいはずです。

この章を読んで分かることは、次のようなことです。

* 仮想コンソールの使い方と設定方法
* FreeBSD システム上でユーザやグループを作成し管理する方法
* UNIX(R) のファイルの許可属性の仕組みと FreeBSD のファイルフラグについて
* FreeBSD のファイルシステムの構成
* FreeBSD のディスク構成
* ファイルシステムをマウント、アンマウントする方法
* プロセス、デーモンとシグナルとはなにか
* シェルとはなにか。 また、デフォルトのログイン環境を変える方法
* テキストエディタの基本的な使い方
* デバイスおよびデバイスノードとはなにか
* さらに詳しい情報を得るためのマニュアルページの読み方

[[consoles]]
== 仮想コンソールと端末

起動時に自動的にグラフィカルな環境が起動するように FreeBSD を設定していなければ、システムが起動すると、以下のようなコマンドラインのログインプロンプトが表示されます。

[source,shell]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

最初の行はシステムの情報です。
`amd64` は、このシステム上で 64 ビット版の FreeBSD が動作していることを示しています。
ホスト名は `pc3.example.org`、[.filename]#ttyv0# は "システムコンソール" であることを示しています。
次の行はログインプロンプトです。

FreeBSD はマルチユーザシステムなので、ユーザを区別する何がしかの手段が必要です。
システム上のプログラムを実行できるようになるには、すべてのユーザに対してシステムにログインすることが義務付けられています。
すべてのユーザは、一意な名前である "ユーザ名" と "パスワード" を持っています。

システムコンソールにログインするには、システムのインストール時に crossref:bsdinstall[bsdinstall-addusers,ユーザの追加] で追加したユーザ名を入力して、kbd:[Enter] を押してください。
次にそのユーザのパスワードを入力して、kbd:[Enter] を押してください。
セキュリティの観点から、パスワードは _表示されません_。

パスワードを正確に入力したら、日々のメッセージ (MOTD) が表示され、
コマンドプロンプトが表示されます。
ユーザ作成時に選択したシェルに依存しますが、このプロンプトは `#`, `$` または `%` といった記号です。 
プロンプトはユーザが FreeBSD のシステムコンソールへログインし、利用可能なコマンドを実行する準備ができていることを示しています。

[[consoles-virtual]]
=== 仮想コンソール

システムコンソールからシステムに対話的にコマンドを実行できますが、FreeBSD システム上でキーボードによりコマンドラインから利用しているユーザは、通常代わりに仮想コンソールにログインします。
デフォルトではシステムからのメッセージはシステムコンソールに出力され、これらのメッセージが、ユーザが作業しているコマンドまたはファイル上に表示されるため、ユーザが現在の作業に集中できなくなるためです。

デフォルトでは FreeBSD は、複数の仮想コンソールを表示してコマンドを入力できるように設定されています。
各仮想コンソールは、個別のログインプロンプトおよびシェルを持っており、簡単に仮想コンソール間の切り替えができます。
これにより、グラフィカルな環境において同時に複数のウィンドウを開いてコマンドラインの環境を提供できます。

FreeBSD では kbd:[Alt+F1] から kbd:[Alt+F8] までのキーの組み合わせが、仮想コンソール間の切り替えに予約されています。
システムコンソール ([.filename]#ttyv0#) に切り替えるには、kbd:[Alt+F1] を使ってください。
最初の仮想コンソール ([.filename]#ttyv1#) にアクセスするには kbd:[Alt+F2]、2 番目の仮想コンソール ([.filename]#ttyv2#) にアクセスするには kbd:[Alt+F3]、といったように使ってください。

あるコンソールから他に切り替えるのに応じて、FreeBSD は画面への出力を管理します。
結果として、FreeBSD で動かすコマンドを入力するのに使える複数の画面とキーボードを仮想的に実現できるのです。
ある仮想コンソールで実行したプログラムは、ユーザが別の仮想コンソールに切り替えても実行を停止しません。

FreeBSD のコンソールおよびキーボードドライバに関するさらなる技術的な説明については、man:syscons[4], man:atkbd[4], man:vidcontrol[1] および man:kbdcontrol[1]  を参照してください。

FreeBSD では以下の [.filename]#/etc/ttys# のように複数の利用可能な仮想コンソールが設定されています。

[.programlisting]
....
# name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

仮想コンソールを無効にするには、無効にしたい仮想コンソールの行をコメント記号 (`\#`) から始まるように設定してください。
たとえば、利用可能な仮想コンソールを 8 つから 4 つに減らす場合には、 [.filename]##ttyv5## から [.filename]##ttyv8## までの仮想コンソールを表す最後の 4 行の先頭に `#` を挿入してください。
システムコンソールを表す [.filename]##ttyv0## から始まる行はコメントアウト _しないでください。_
最後の仮想コンソール ([.filename]##ttyv8##) は、Xrog がインストールされ crossref:x11[x11,X Window System] で説明されているように設定されている場合に、グラフィカル環境にアクセスするために使用されます。

このファイルのそれぞれのカラムと仮想コンソールに設定可能なオプションの詳しい説明は、man:ttys[5] のマニュアルを参照してください。

[[consoles-singleuser]]
=== シングルユーザモード

FreeBSD のブートメニューでは、"シングルユーザモード" と表示されているオプションが提供されています。
このオプションを選択すると、システムは "シングルユーザモード" と呼ばれる特別なモードで起動します。
このモードは、システムが起動しない場合に修正のため、または `root` のパスワードが分からなくなってしまいリセットするときなど、特別な状況で利用されます。
シングルユーザモードで動かしている場合は、ネットワークや他の仮想コンソールは利用できません。
しかし、システムへの完全な `root` 権限を利用でき、デフォルトの設定では `root` のパスワードは必要ありません。
このような理由のため、このモードで起動する場合には物理的なキーボードへのアクセスが必要であり、FreeBSD システムの安全性の観点からキーボードに物理的にアクセスできる人を決めておく事が必要です。
シングルユーザモードを管理する設定は、[.filename]#/etc/ttys# ファイルの以下のセクションにあります。

[.programlisting]
....
# name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

デフォルトでは、status は `secure` に設定されています。
これは、キーボードへアクセスできるかユーザが誰であるかが重要ではない、もしくはアクセスできるユーザについては物理的なセキュリティポリシーでコントロールされていることが前提となっています。
この設定を `insecure` に変更するケースとしては、システムは安全ではなく、誰でもキーボードにアクセスできる環境が想定されます。
この行を `insecure` に変更すると、FreeBSD がシングルユーザモードで起動した場合に `root` のパスワードが要求されます。

[NOTE]
====
__ `insecure` に変更する場合は十分注意してください! __
`root` のパスワードを忘れてしまうと、シングルユーザモードで起動することはできますが、FreeBSD の起動のプロセスに詳しくない人が起動できるようにするのは難しいかも知れません。
====

[[consoles-vidcontrol]]
=== コンソールのビデオモードの変更

FreeBSD のデフォルトのビデオモードは 1024x768 や 1280x1024 など、グラフィックチップおよびディスプレイが対応しているサイズに調整されます。
別のビデオモードを使うには、`VESA` モジュールをロードしてください。

[.programlisting]
....
# kldload vesa
....

その後、ハードウェアが対応しているビデオモードを man:vidcontrol[1] を使って確認してください。
以下を実行すると、対応しているビデオモードを調べることができます。

[source,shell]
....
# vidcontrol -i mode
....

このコマンドは、使用しているハードウェアが対応しているビデオモードの一覧を表示します。
その後、man:vidcontrol[1] を `root` ユーザで実行して、新しく使用するビデオモードを選択してください。

[source,shell]
....
# vidcontrol MODE_279
....

このビデオモードで良ければ、起動時に自動的に設定されるように [.filename]#/etc/rc.conf# に以下のように追加してください。

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== ユーザと基本的なアカウント管理

FreeBSD は、複数のユーザが同時にコンピュータを使えるようにします。 スクリーンとキーボードの前に一度に座れるのはその中の一人だけですが ユーザは何人でもネットワークを通してログインできます。 システムを使うためには、 どのユーザもアカウントがなければなりません。

この章では、以下のことを説明します。

* FreeBSD システムにおけるさまざまな種類のユーザアカウントについて
* ユーザアカウントを追加、削除および変更する方法
* ユーザやグループが利用できるリソースの上限を制御する方法
* グループの作成、 およびグループにユーザをメンバとして追加する方法

[[users-introduction]]
=== アカウントの種類

FreeBSD システムへアクセスするには、 かならずアカウントが使われ、 また、プロセスもすべてユーザによって実行されるので、 ユーザとアカウントの管理は、重要なものです。 

アカウントには大きく分けて三種類あります。 システムアカウント (system accounts)、ユーザアカウント (user accounts)、 そしてスーパーユーザ (superuser) です。

[[users-system]]
==== システムアカウント

システムアカウントは、DNS、メール、 ウェブサーバといった各種サービスを運用するために使われます。 この目的は、セキュリティを確保するためです。 もしすべてのサービスがスーパーユーザで実行されていると、 それらのサービスはどんな動作でも可能となり、 適切な制限を適用することができません。

システムアカウントの具体例は、 `daemon`, `operator`, `bind`, `news` および `www` といったものです。

`nobody` は通常の特権を持たないシステムアカウントです。 しかし、`nobody` を利用するサービスが増えれば増えるほど、 それに所属するファイルやプロセスも増え、 その特権も大きくなるということを忘れないようにしてください。

[[users-user]]
==== ユーザアカウント

ユーザアカウントは、 主に現実のユーザがシステムにアクセスする手段として用いられるものです。 システムにアクセスするすべてのユーザは、 それぞれ唯一のユーザアカウントを持つべきです。 こうすることで管理者は誰が何を行なっているかがわかりますし、 他の人の設定を壊してしまうようなことを避けることができます。

それぞれのユーザは快適にシステムを利用するため、 シェル、エディタ、キー設定、言語など、 各自の環境をセットアップすることができます。

FreeBSD システム上のどのアカウントにも、 以下のような情報がなにかしら結び付けられています。

ユーザ名::
`login:` プロンプトに対して入力するユーザの名前です。 ユーザ名はそのシステムで一意でなければならず、 2 名のユーザに同じユーザ名をつけることはできません。 有効なユーザ名を作成するには man:passwd[5] に記載されているいくつもの規則があります。 アプリケーションの上位互換性を保つために、 8 文字以下の小文字からなるユーザ名を使うことが推奨されています。

パスワード::
それぞれのユーザアカウントにはパスワードがあります。 パスワードは空白にもできますが、 行うべきではありません。

ユーザ ID (UID)::
ユーザ ID (UID) は、 FreeBSD システムがユーザを一意に識別するための数値です。 ユーザ名を指定できるコマンドは、 ユーザ名を UID に変換してから扱っています。 65535 より大きな UID は、32 ビット以上の整数に対応していないソフトウェアにおいて互換性の問題を引き起こす可能性があるので、 65535 以下の UID を使用することが推奨されています。

グループ ID (GID)::
グループ ID (GID) は、 ユーザが属する第一グループを一意に識別するための数値です。 グループは、UID ではなく、 ユーザの GID に基づいて資源へのアクセスを制御する仕組みです。 これは、ある種の設定ファイルのサイズを大幅に小さくします。 ユーザは、複数のグループに所属できます。 65535 より大きな GID は、ソフトウェアに問題を引き起こす可能性があるので、 65535 以下の GID を使うことを推奨します。

ログインクラス::
ログインクラスはグループの仕組みを拡張したもので、 別々のユーザに対してシステムを調整する時に、 さらなる柔軟性を提供します。ログインクラスの詳細については、 <<users-limiting>> で説明します。

パスワード変更時間::
デフォルトでは、FreeBSD は定期的にパスワードを変更することをユーザに強制しません。 これを man:pw[8] を使用してユーザごとに設定し、 一部またはすべてのユーザに、 一定の時間がたったらパスワードを強制的に変更させることができます。

アカウント失効時間::
デフォルトでは、FreeBSD はアカウントを失効させません。 たとえば学校で生徒のアカウントがある場合など、 限られた期間だけのアカウントを作成するなら、 そのアカウントがいつ失効するか man:pw[8] を使って指定できます。 有効期間が経過したら、 そのアカウントのディレクトリやファイルは残っていますが、 システムへのログインはできなくなります。

ユーザの氏名::
FreeBSD ではユーザ名でアカウントを一意に識別しますが、 必ずしもユーザの本名を反映したものではありません。 この情報をアカウントに関連付けることもできます。 この情報は、コメントのように、空白、大文字、および 8 字以上で記載できます。

ホームディレクトリ::
ホームディレクトリは、システム中のディレクトリへのフルパスです。 これはユーザがログインした時に作業を開始するディレクトリです。 一般的な慣習は、すべてのユーザのホームディレクトリを [.filename]#/home/username# か [.filename]#/usr/home/username# の下に置くことです。 各ユーザは、個人のファイルやサブディレクトリを、 ユーザのホームディレクトリに保存します。

ユーザシェル::
シェルは、 ユーザがシステムと対話するデフォルトの環境を提供します。 いろいろな種類のシェルがあり、 経験を積んだユーザはそれぞれ好みがあり、 それをアカウントの設定に反映できます。

[[users-superuser]]
==== スーパーユーザアカウント

スーパーユーザアカウントは通常 `root` と呼ばれ、 システム管理を行なうために使われ、権限に制限がありません。 そのため、このアカウントはメールのやりとり、システムの調査、 プログラミングといった日常的な作業を行なうために使われるべきものではありません。

その理由は、スーパーユーザが通常のユーザアカウントと異なり、 操作にまったく制限を受けないことによります。 そのためスーパーユーザアカウントで操作を間違えると、 システムに重大な影響を与えてしまう恐れがあるのです。 ユーザアカウントでは、 仮に操作を間違えてもシステムを壊してしまうようなことはできないようになっています。 そのため、ユーザアカウントでログインし、 高い権限が必要なコマンドを実行するときだけスーパーユーザになることが推奨されています。

スーパーユーザで実行するコマンドはいつでも、 二回、三回と確認してください。 なぜならスペースが多かったり、文字が欠けていたりするだけで、 取り返しのつかないデータの破壊につながる可能性があるからです。

スーパーユーザの権限を得るには、さまざまな方法があります。 `root` ユーザとしてログインする方法もありますが、 これはまったくお勧めできません。

スーパーユーザの権限を手に入れるには、かわりに man:su[1] を使って下さい。 `-` オプションをつけて実行すると、 実行したユーザに root ユーザの環境が設定されます。 このコマンドは `wheel` グループに入ってるユーザのみが実行でき、他のユーザは実行出来ません。 また、実行時には `root` ユーザのパスワードを必要とします。

以下の例では、`make install` を行うときにスーパーユーザの権限が必要なので、 このコマンドを実行する時だけユーザはスーパーユーザになります。 コマンドを実行したら、ユーザは `exit` を実行してスーパーユーザからログアウトし、 通常のユーザアカウントの権限に戻ります。

.スーパーユーザ権限でプログラムをインストールする
[example]
====

[source,shell]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....

====

1 人の管理者が一台のマシン、 もしくは小規模なネットワークを管理する場合には、 man:su[1] のフレームワークはうまく機能するでしょう。 この代わりとなるのは、 package:security/sudo[] package または port です。これはログ機能や、 スーパーユーザの権限で実行できるユーザやコマンドを設定できます。

[[users-modifying]]
=== アカウント情報の管理

FreeBSD には、 ユーザアカウントを操作するのにさまざまなコマンドが用意されています。 もっとも一般的なコマンドを以下に示し、 それに続いて詳しい使用例を示します。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| コマンド
| 要約

|man:adduser[8]
|コマンドラインからユーザを追加するための推奨アプリケーション

|man:rmuser[8]
|コマンドラインからユーザを削除するための推奨アプリケーション

|man:chpass[1]
|ユーザデータベースの情報を変更するための柔軟なツール

|man:passwd[1]
|ユーザのパスワードを変更する簡単なコマンドラインツール

|man:pw[8]
|ユーザアカウントのあらゆる箇所を変更する強力で柔軟なツール
|===

[[users-adduser]]
==== `adduser`

man:adduser[8] は、 新しいユーザを登録するためのシンプルなプログラムです。 ユーザを追加すると、 このプログラムは、[.filename]#/etc/passwd# と [.filename]#/etc/group# を自動的に更新します。 また、新規ユーザのホームディレクトリを作成し、 [.filename]#/usr/shared/skel# から、デフォルトで使用される設定ファイルをコピーします。 また、新しく作成されたユーザに対して、 ウェルカムメッセージをメールで送信することも可能です。

.FreeBSD におけるユーザの追加
[example]
====

[source,shell]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
#
....

====

[NOTE]
====
入力したパスワードは画面に表示されませんので、 ユーザアカウントを作成する際には、 パスワードを間違えて入力してしまわないように注意してください。
====

[[users-rmuser]]
==== `rmuser`

システムから完全にユーザを削除するには、 man:rmuser[8] を使います。 このコマンドは、次の手順を実行します。

[.procedure]
====
. 指定されたユーザの man:crontab[1] エントリが存在する場合には削除。
. 指定されたユーザの man:at[1] ジョブをすべて削除。
. 指定されたユーザが所有するすべてのプロセスを強制終了。
. ローカルパスワードファイルから、 指定されたユーザのエントリを削除。
. 指定されたユーザのホームディレクトリを削除 (ディレクトリの所有者が指定されたユーザのものだった場合)。
. [.filename]#/var/mail# から、指定されたユーザの到着メールファイルを削除。
. [.filename]#/tmp# のような一時ファイル保存領域から、 指定されたユーザの所有するファイルを削除。
. そして最後に、 [.filename]#/etc/group# にある すべてのグループから、指定されたユーザを削除します。
+
[NOTE]
======
指定されたユーザと同じ名前のグループで、 そのユーザが削除されると空のグループとなる場合は、 そのグループ自体が削除されます。 これは man:adduser[8] によってユーザごとに作成される、 ユニークなグループに対応するものです。
======
====

スーパユーザアカウントの削除に man:rmuser[8] を利用することはできません。 スーパユーザアカウントの削除はほとんどすべての場合、 大規模なシステムの破壊を意味するからです。

デフォルトでは、以下の例のような対話モードが使われます。

.`rmuser` による対話的なアカウントの削除
[example]
====

[source,shell]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
#
....

====

[[users-chpass]]
==== `chpass`

man:chpass[1] を用いて、 パスワード、シェル、その他の個人情報といった、 ユーザデータベース情報を変更できます。

スーパユーザ権限に限り、 man:chpass[1] を用い、 他のユーザの情報やパスワードを変更できます。

ユーザ名の他にオプションを指定しないと、 man:chpass[1] はユーザ情報を編集するエディタを表示します。 ユーザがエディタを終了すると、 ユーザデータベースが新しい情報に更新されます。

[NOTE]
====
スーパユーザでない場合は、 エディタを抜けた後にパスワードを聞かれます。
====

.スーパユーザによる対話的な `chpass`
[example]
====

[source,shell]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

ユーザは、この情報の限られた部分のみ変更が可能です。 また、変更できるのはそのユーザ自身のアカウント情報のみです。 

.通常のユーザによる対話的な `chpass`
[example]
====

[source,shell]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[NOTE]
====
man:chfn[1] および man:chsh[1] はいずれも、 man:chpass[1] へのリンクです。 また、man:ypchpass[1], man:ypchfn[1] および man:ypchsh[1] も同様です。 NIS のサポートは自動的に行なわれますので、 コマンドの先頭に `yp` をつける必要はありません。 NIS の設定については、  で説明されています。
====

[[users-passwd]]
==== `passwd`

man:passwd[1] は、 ユーザが自分のパスワードを変更する通常の方法です。 スーパユーザ権限では、 他のユーザのパスワードを変更するのに使われます。

[NOTE]
====
誤って、または不正なパスワードの変更を避けるため、 新しいパスワードを設定する前に、 もとのパスワードを入力しなければなりません。 スーパーユーザの権限でユーザのパスワードを変更する際には、 もとのパスワードを入力する必要はありません。
====

.自分のパスワードの変更
[example]
====

[source,shell]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

.スーパーユーザ権限での他のユーザのパスワード変更
[example]
====

[source,shell]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

[NOTE]
====
man:chpass[1] 同様、man:yppasswd[1] は、 man:passwd[1] へのリンクになっていますので、 NIS はどちらのコマンドでも動作します。
====

[[users-pw]]
==== `pw`

man:pw[8] は、ユーザやグループの作成、削除、 変更および表示を行なうコマンドラインのユーティリティです。 これは、システムユーザファイルやシステムグループファイルの フロントエンドとして働きます。man:pw[8] はとても強力な一連のコマンドラインオプションを有しており、 シェルスクリプトで使うのに向いていますが、新しいユーザは、 この章で紹介されている他のコマンドに比べて難しいと感じるかもしれません。

[[users-limiting]]
=== ユーザへの制限

FreeBSD は、 個々のユーザが利用できるシステム資源の量を管理者が制限できる方法をいくつも用意しています。 その種の制限は、ディスククォータ (quota) とその他の資源の制限の 2 つの章で説明します。

ディスククォータは、ユーザが利用できるディスク容量を制限し、 その都度計算しなくてもディスク使用量を簡単に確認できる手段も提供しています。 クォータについては、crossref:disks[quotas,「ファイルシステムクォータ」] で解説しています。

その他のリソースの制限とは、ユーザが消費できる CPU、メモリなどのリソースを制限する手段のことです。 これはログインクラスを用いて定義されているもので、 この後で解説しています。

ログインクラスは [.filename]#/etc/login.conf# で定義します。詳細な説明は man:login.conf[5] に詳しく記載されています。 各ユーザアカウントにはログインクラスが割り当てられていて (デフォルトでは `default` です)、 それぞれのログインクラスにはログインケーパビリティの集合が割り当てられています。 ログインケーパビリティとは、 `名称=値` の組のことで、_名称_ は周知の識別子、_値_ は、_名称_ に応じて処理される任意の文字列です。 ログインクラスとケーパビリティを設定するのはどちらかといえば簡単なことで、 man:login.conf[5] でも説明されています。

[NOTE]
====
FreeBSD は通常、直接 [.filename]#/etc/login.conf# から設定を読み込まず、 より速く検索できる [.filename]#/etc/login.conf.db# データベースから読み込みます。[.filename]#/etc/login.conf# を編集する時には [.filename]#/etc/login.conf.db# を次のコマンドを実行してアップデートする必要があります。

[source,shell]
....
# cap_mkdb /etc/login.conf
....

====

リソースの制限は、 2 つの点で標準的なログインケーパビリティと異なっています。 第一に、どの制限についても、ソフト (現在の) リミットとハードリミットがあります。 ソフトリミットは、ユーザやアプリケーションが調整できますが、 ハードリミットを超えることはできません。 ユーザはハードリミットを下げることはできますが、 上げることはスーパユーザのみができます。 第二に、ほとんどのリソースの制限は特定のユーザに対してプロセス毎に適用されるもので、 そのユーザが利用するリソースの総量を制限するものではありません。 ただし、この違いは制限を特別扱いすることで実現されるものであり、 ログインケーパビリティフレームワークの実装によるものではありません。

以下が最もよく使われるリソースの制限になります。 残りは、他のすべてのログインケーパビリティと並んで man:login.conf[5] に書かれています。

`coredumpsize`::
プログラムが生成する core ファイルのサイズにかかる制限は、 `filesize` やディスククォータなどの、 ほかのディスク使用に関する制限に従属します。 この制限は、ディスク領域の消費を制御するあまり厳しくない手段としてよく使われています。 ユーザは core ファイルを自分で生成するわけではなく、 削除しないことも多いので、 これを設定すれば大きなプログラムが異常終了してもディスクの空きがなくならずに済みます。

`cputime`::
そのユーザのプロセスが消費できる CPU 時間 の上限です。 これを超えたプロセスは、カーネルにより終了されます。
+

[NOTE]
====
これは、消費される CPU _時間_ についての制限であって、man:top[1] や man:ps[1] のフィールドで表示される CPU の割合に関するものではありません。
====

`filesize`::
ユーザが所有できるファイルの大きさの上限です。crossref:disks[quotas,ディスククォータ] と違い、 この制限はユーザのファイルをすべてまとめた集合にではなく、 個々のファイルにかかります。

`maxproc`::
ユーザが実行できるプロセス数の上限です。 フォアグラウンドプロセスとバックグラウンドプロセスの両方を扱います。 この上限は、man:sysctl[8] 変数 `kern.maxproc` で指定されたシステムの制限を超えることはできません。 同時に複数ログインすることや、 パイプライン実行することは便利なことが多いので、 この値をあまり小さな値に設定すると、 そのユーザの生産性が悪化する可能性があります。 大きなプログラムをコンパイルする場合のように、 タスクによっては複数のプロセスやプリプロセッサが実行されます。

`memorylocked`::
これは、1 つのプロセスが man:mlock[2] によりメインメモリにロックされることを要求できるメモリの最大容量です。 man:amd[8] のようなシステムで重要なプログラムは、 メインメモリへロックして、システムがスワップする際に、 ディスクのスラッシングを引き起こさないようにします。

`memoryuse`::
これは、どの時点かを問わず、 あるプロセスが消費できる最大のメモリ容量です。 これは、メインメモリとスワップの使用量を合わせたものです。 メモリ消費を抑えるための包括的な制限ではありませんが、 手始めにはよいでしょう。

`openfiles`::
これは、あるプロセスが開いておける最大のファイル数です。 FreeBSD では、ファイルはまた、ソケットや IPC チャンネルを表わすのにも使われています。 ですから、あまり低い値に設定しないよう注意してください。 これに対応するシステム全体の制限は man:sysctl[8] `kern.maxfiles` で定義されています。

`sbsize`::
これは、あるユーザが消費できるネットワークメモリ (つまり mbuf) の上限の量です。ユーザは、 ネットワーク通信を制限するのに使えます。

`stacksize`::
これは、プロセスのスタックサイズの上限です。 あるプログラムが使用しうるメモリの量を制限するには、 これだけでは十分ではありません。 したがって、他の制限と組み合わせて使わなければなりません。

リソースの制限を設定するにあたり、 ほかにもいくつか覚えておかなければならないことがあります。 以下は、一般的なこつやお勧め、さまざまなコメントになります。

* システム起動時に [.filename]#/etc/rc# から起動されたプロセスは、`daemon` ログインクラスに割り当てられます。
* システムに付属していた [.filename]#/etc/login.conf# はほとんどの制限について妥当な値になっていますが、 すべてのシステムにおいてふさわしいというわけではありません。 制限をあまり緩くするとシステムを悪用しやすくしてしまいますし、 厳しくしすぎると生産性を悪化させてしまいます。
* Xorg のユーザには、 他のユーザより多くのリソースを与えるべきかもしれません。 Xorg そのものが多くのリソースを使うだけでなく、 より多くのプログラムを並行して使うことをユーザに促します。
* 多くの制限は個々のプロセスにかかるもので、 一人のユーザにまとめてかかるものではありません。 例えば、`openfiles` を 50 に設定することは、 ユーザが動かすそれぞれのプロセスが最大 50 個のファイルを開けるということです。 あるユーザが開けるファイルの総数は、 `openfiles` の値に `maxproc` をかけたものになります。 同じことがメモリ消費量にもあてはまります。

リソースの制限と、ログインクラス、 ログインケーパビリティ一般についての詳しい情報は、 man:cap.mkdb[1], man:getrlimit[2] および man:login.conf[5] をご覧ください。

[[users-groups]]
=== グループの管理

グループとは、ユーザを羅列したものです。 グループは、グループ名と GID で識別されます。 FreeBSD では、 あるプロセスが何かするのを許可するかどうかをカーネルが判断する際に、 プロセスの UID とそのユーザが所属するグループの一覧を利用します。 ほとんどの場合、ユーザもしくはプロセスの GID は一覧の最初のグループを指しています。

グループ名から GID への写像は [.filename]#/etc/group# にあります。 これは、コロンで区切られた 4 項目からなるテキストファイルです。 1 番目の項目はグループ名、 2 番目は暗号化されたパスワード、 3 番目が GID、 4 番目がカンマで区切られたメンバの一覧です。 文法についての完全な説明は、man:group[5] をご覧ください。

スーパーユーザは、[.filename]#/etc/group# をテキストエディタで編集できます。 もしくは、man:pw[8] を使ってグループの追加や編集をできます。 たとえば、`teamtwo` というグループを追加して、その存在を確認するには、 次のように使います。

.man:pw[8] によるグループの追加
[example]
====

[source,shell]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....

====

この例では、`1100` という番号は、 `teamtwo` の GID です。 この時点では、`teamtwo` にメンバはいません。 以下のコマンドは、 `jru` を `teamtwo` のメンバに追加します。

.man:pw[8] により新しいグループにメンバを追加する
[example]
====

[source,shell]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....

====

`-M` の引数は、 カンマで区切られた新しい (空の) グループに追加するもしくは存在するグループのメンバを置き換えるユーザの一覧です。 ユーザにとっては、このグループのメンバーシップはパスワードファイルに記載されているプライマリのグループとは異なります。 man:pw[8] の `groupshow` コマンドを使った時は、 そのユーザはグループの一員として表示されませんが、man:id[1] などのツールを使って情報を問い合わせれば、 その情報を引き出せます。ユーザをグループに追加をする際に、man:pw[8] は [.filename]#/etc/group# しか扱わず、 [.filename]#/etc/passwd# から追加のデータを読んだりはしません。

.man:pw[8] によるグループへのユーザ追加
[example]
====

[source,shell]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....

====

この例では、`-m` の引数は、 カンマで区切られたグループに追加するユーザの一覧です。 前の例と異なり、これらのユーザはグループ一覧に追加され、 グループのユーザ一覧を置き換えることはありません。

.グループに所属しているユーザを調べるための man:id[1] の使い方
[example]
====

[source,shell]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....

====

この例では、`jru` は `jru` グループと `teamtwo` グループのメンバです。

このコマンドや [.filename]#/etc/group# のフォーマットの詳細については、 man:pw[8] および man:group[5] をご覧ください。

[[permissions]]
== 許可属性

FreeBSD では、すべてのファイルおよびディレクトリは一組の許可属性を持っています。
これらの許可属性は、ユーティリティを使って確認したり変更できます。
許可属性がどのように機能するかを知ることで、ユーザが必要とするファイルにアクセスできるかどうか、オペレーティングシステムが使用しているファイルや他のユーザが所有するファイルにアクセスできないことを理解できるようになります。

この節では、FreeBSD で使用される伝統的な UNIX(R) の許可属性について説明します。
より細かいファイルシステムのアクセス制御に関しては、crossref:security[fs-acl,“アクセス制御リスト”] をご覧ください。

UNIX(R) では、基本の許可属性は 3 つのアクセスタイプ (読み・書き・実行) を使って割り当てられます。
これらのアクセスタイプを使って、ファイルの所有者 (owner)、グループ (group) その他 (others) に対するファイルアクセスを設定します。
読み、書き、実行に関する許可属性は、それぞれ `r`, `w`, および `x` 文字で表されます。
これらの許可属性を表す際に、オンかオフ (`0`) による 2 進数表記も使われます。
数字で表現する場合には、 `r` は `4`、`w` は `2` そして `x` は `1` の値を持つよう、`rwx` の順番で表されます。

以下は、許可属性を表す際に用いられる数字およびアルファベットをまとめた表です。
"ディレクトリの表示" カラムでは、`-` は許可属性がオフに設定されていることを表します。

.UNIX(R) 許可属性
[cols="1,1,1", frame="none", options="header"]
|===
| 値
| 許可属性
| ディレクトリの表示

|0
|読み込み不可、書き込み不可、実行不可
|`---`

|1
|読み込み不可、書き込み不可、実行可能
|`--x`

|2
|読み込み不可、書き込み可能、実行不可
|`-w-`

|3
|読み込み不可、書き込み可能、実行可能
|`-wx`

|4
|読み込み可能、書き込み不可、実行不可
|`r--`

|5
|読み込み可能、書き込み不可、実行可能
|`r-x`

|6
|読み込み可能、書き込み可能、実行不可
|`rw-`

|7
|読み込み可能、書き込み可能、実行可能
|`rwx`
|===

man:ls[1] に対してコマンドライン引数 `-l` を使うと、詳細なディレクトリリストを見ることができ、ファイルの所有者、グループ、その他への許可属性を示す欄があるのがわかります。
例えば、`ls -l` を実行して、 適当なディレクトリを表示させると以下のようになります。

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...
....

一番目の列の最初の (一番左の) 文字は、そのファイルが普通のファイルなのか、ディレクトリなのか、キャラクタ型のデバイス特殊ファイルなのか、ソケットなのか、その他の特殊な疑似ファイルデバイスなのかといった種類を示す特別な文字です。
この例において、`-` という文字は、普通のファイルであることを示します。
その次に来る `rw-` と書かれた 3 文字は、そのファイルの所有者に許可を与えるものです。
その次の `r--` の 3 文字は、そのファイルが所属しているグループに許可を与えます。
最後の `r--` の 3 文字は、 システムに存在するその他のユーザに許可を与えます。
"-" は許可が与えられていないことを示します。
この例では、ファイルの所有者はこのファイルを読み書きでき、ファイルの所属しているグループに属するユーザはファイルを読むことだけでき、そのどちらでもないユーザは、 このファイルを読むだけできるように許可属性が与えられています。
上の表によれば、このファイルに与えられた許可属性は `644` となります。
ここで各数字は、このファイルの許可属性の 3 つの部分を表しています。

デバイスの場合の許可属性はどのようにコントロールされているのでしょうか?
FreeBSD は、大部分のハードウェアをファイルとして取り扱います。
そのため、プログラムからは普通のファイルとまったく同じようにオープンし、 データの読み書きができるようになっています。
これらのデバイス特殊ファイルは [.filename]#/dev/# に収められています。

ディレクトリもまた、ファイルと同様に扱われます。
それは読み込み/書き込み/実行の許可属性を持ちます。
ディレクトリの実行ビットはファイルのそれとは少し違った意味を持ちます。
ディレクトリが実行可能になっているとき、man:cd[1] を使ってそのディレクトリに移動することができます。 
これは、そのディレクトリにあるファイルにアクセスできることを意味しています (ファイル自体の許可属性によります)。

ディレクトリの中の一覧を表示するには、そのディレクトリに読み込み属性が設定されていなければなりません。
名前が分かっているファイルを削除するには、そのファイルが含まれているディレクトリに 書き込み属性 _と_ 実行属性 の両方が必要です。

この他にも許可属性ビットはありますが、いずれも setuid バイナリや sticky ディレクトリなどといった特殊な状況で使われます。
ファイルの許可属性そのものについて、また、それらの設定方法に関する詳しい情報は、 man:chmod[1] マニュアルページを参照してください。

=== シンボリック表記

シンボリック表記と呼ばれる許可属性を表す方法では、ファイルやディレクトリの許可属性を、8 進数ではなく記号を用いて設定します。
シンボリック表記による許可属性を表す方法では、(who), (action), (permissions) という書式が用いられます。
利用できる値は以下の通りです。

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| オプション
| 文字
| 意味

|(who)
|u
|ユーザ

|(who)
|g
|ファイルを所持しているグループ

|(who)
|o
|その他

|(who)
|a
|すべて ("world")

|(action)
|+
|許可属性を与える

|(action)
|-
|許可属性を取り除く

|(action)
|=
|許可属性を指定したものにする

|(permissions)
|r
|読み込み

|(permissions)
|w
|書き込み

|(permissions)
|x
|実行

|(permissions)
|t
|Sticky ビット

|(permissions)
|s
|UID または GID を設定する
|===

これらの値は、これまでと同様に man:chmod[1] で用いますが、数字ではなく文字で指定します。
たとえば、_FILE_ に対して自分以外のユーザからアクセスを一切受け付けたくない、というときには以下のコマンドを実行してください。

[source,shell]
....
% chmod go= FILE
....

カンマ区切りで設定することで、ファイルの属性を一度に 2 つ以上変更できます。
以下の例では、_FILE_ に対して自分以外のユーザから書き込みの権限を取り上げ、かわりにすべてのユーザが _FILE_ を実行できるようにします。

[source,shell]
....
% chmod go-w,a+x FILE
....

=== FreeBSD のファイルフラグ

ファイルの許可属性に加え、FreeBSD では "ファイルフラグ" を使えます。
これはファイルにセキュリティや管理上の属性を追加するものですが、ディレクトリには追加しません。
ファイルフラグにより、`root` ユーザでさえ誤ってファイルを消去、変更してしまうことを防ぐことができます。

ファイルフラグは、man:chflags[1] を使って、簡単なインタフェースで設定できます。
例えば、[.filename]#file1# というファイルにシステムレベルで消去不可のフラグを設定するには、以下のコマンドを実行してください。

[source,shell]
....
# chflags sunlink file1
....

消去不可のフラグを削除するには、以下のように `sunlink` の前に "no" をつけて実行してください。

[source,shell]
....
# chflags nosunlink file1
....

ファイルに設定されているフラグを確認するには、`-lo` と一緒に man:ls[1] を実行してください。

[source,shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

いくつかのファイルフラグの追加、削除は `root` ユーザしかできません。
他のフラグは、ファイルの所有者が変更できます。
man:chflags[1] と man:chflags[2] から、より詳細な情報を得ることをおすすめします。

=== `setuid`, `setgid` および `sticky` 許可属性

これまでに説明した許可属性のほかに、
すべての管理者が知っておくべき特別な設定が 3 つあります。
それは `setuid`, `setgid` および `sticky` 許可属性です。

これらの設定は、通常のユーザには許可されていない機能を提供するので、UNIX(R) の操作において重要となることがあります。
これらの許可属性を理解するためには、実ユーザ ID と実効ユーザ ID の違いに注意してください。

実ユーザ ID は、所有したりプロセスを開始する UID です。
実効 UID は、プロセスを実行するユーザ ID です。
たとえば、ユーザがパスワードを変更するときに利用する man:passwd[1] は、実ユーザ ID で起動します。
しかしながら、パスワードデータベースのアップデートの際は、実効 ID の `root` ユーザの権限で実行されます。
この仕組みにより、`Permission Denied` エラーが表示されることなく、ユーザはパスワードを変更できます。

setuid 許可属性は、以下の例で示されているように、指定する許可属性に数字の 4 をつけて設定します。

[source,shell]
....
# chmod 4755 suidexample.sh
....

これで [.filename]#suidexample.sh# の許可属性は以下のように設定されます。

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

`s` は、許可属性のファイル所有者の実行可能ビットに置き換わって反映されます。
この設定により、man:passwd[1] といったユーティリティが権限を昇格することができます。

[NOTE]
====
`nosuid` man:mount[8] オプションを使うと、このようなバイナリがユーザへの警告なしに権限を昇格できないように設定できます。
ただし `nosuid` ラッパにより回避できるため、このオプションを完全には信頼できません。
====

リアルタイムに確認するために、2 つのターミナルを開いてください。
1 つのターミナル上で、通常のユーザ権限で `passwd` と入力してください。
パスワードの入力を待つ間に、もう一つのターミナル上で、プロセステーブルおよび man:passwd[1] のユーザ情報を確認してください。

ターミナル A:

[source,shell]
....
Changing local password for trhodes
Old Password:
....

ターミナル B:

[source,shell]
....
# ps aux | grep passwd
....

[source,shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

通常のユーザ権限で man:passwd[1] を実行したにもかかわらず、実効 UID の `root` が使われています。

`setgid` 許可属性は `setuid` 許可属性と同様の機能を提供しますが、この許可属性はグループの設定を変更します。
この設定を行った上でアプリケーションまたはユーティリティを実行すると、プロセスを開始するユーザではなく、ファイルを所有するグループに対してこの許可属性を与えます。

ファイルに `setgid` 許可属性を設定するには、man:chmod[1] で設定する許可属性の先頭に 2 をつけて実行してください。

[source,shell]
....
# chmod 2755 sgidexample.sh
....

以下に示されるように、`s` がグループの許可属性に指定されています。

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
上記の例において、対象としているシェルスクリプトが実行可能なファイルであっても、シェルスクリプトは man:setuid[2] システムコールにアクセスできないため、実効ユーザ ID では実行されません。

====

`setuid` および `setgid` 許可属性ビットは、権限の昇格を許可するので、システムのセキュリティレベルを下げます。
一方 3 番目の特殊な許可属性 `sticky bit` は、システムのセキュリティを強化します。

ディレクトリに `sticky bit` を設定すると、ファイルの所有者のみがファイルを削除できるようになります。
[.filename]#/tmp# といった共有のディレクトリにおいて、ファイルの所有者以外のユーザがファイルを削除できなくなるので有用です、
この許可属性を有効にするには、許可属性に 1 をつけて設定してください。

[source,shell]
....
# chmod 1777 /tmp
....

`sticky bit` が設定されていると、許可属性の最後に `t` が表示されます。

[source,shell]
....
# ls -al / | grep tmp
....

[source,shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== ディレクトリ構造

FreeBSD のディレクトリ構造は、システム全体を理解するに当たって重要です。
最も重要なディレクトリは、ルートまたは "/" です。
このディレクトリは起動時に一番最初にマウントされ、オペレーティングシステムをマルチユーザで動作させるために必要なベースシステムが含まれています。
また、ルートディレクトリには、マルチユーザへの移行中に他のファイルシステムをマウントするためのマウントポイントも含まれます。

マウントポイントとは、追加するファイルシステムを接続する先の親のファイルシステム (普通はルートファイルシステム) のディレクトリのことです。
より詳細な説明は <<disk-organization>> の節にあります。
標準的なマウントポイントには [.filename]#/usr/#, [.filename]#/var/#, [.filename]#/tmp/#, [.filename]#/mnt/# および [.filename]#/cdrom/# があります。
通常これらのディレクトリについては、 [.filename]#/etc/fstab# というファイル中のエントリが参照されます。
このファイルは、さまざまなファイルシステムとマウントポイントの表であり、システムが参照します。
[.filename]#/etc/fstab# に書かれたファイルシステムは `noauto` オプションが指定されていなければ、起動時に man:rc[8] スクリプトによって自動的にマウントされます。
詳細は <<disks-fstab>> の節をご覧ください。

ファイルシステム構造を網羅した説明は man:hier[7] に書かれています。
以下の表は、もっともよく使われるディレクトリの簡単な概要です。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| ディレクトリ
| 説明

|[.filename]#/#
|ファイルシステムのルートディレクトリ

|[.filename]#/bin/#
|シングルユーザ環境とマルチユーザ環境の両方で重要な ユーザユーティリティ

|[.filename]#/boot/#
|オペレーティングシステムの起動時に使われるプログラムと設定ファイル

|[.filename]#/boot/defaults/#
|デフォルトの起動設定ファイル; man:loader.conf[5] 参照

|[.filename]#/dev/#
|デバイスノード; man:intro[4] 参照

|[.filename]#/etc/#
|システム設定ファイルとスクリプト

|[.filename]#/etc/defaults/#
|デフォルトのシステム設定ファイル; 詳細については man:rc[8] 参照

|[.filename]#/etc/mail/#
|man:sendmail[8] のようなメール転送エージェントの設定ファイル

|[.filename]#/etc/namedb/#
|`named` 設定ファイル;  詳細な説明は man:named[8] 参照

|[.filename]#/etc/periodic/#
|man:cron[8] 経由で毎日・毎週・毎月実行されるスクリプト; 詳細については man:periodic[8] 参照

|[.filename]#/etc/ppp/#
|man:ppp[8] の設定ファイル

|[.filename]#/mnt/#
|システム管理者が一時的なマウントポイントとしてよく使う空のディレクトリ

|[.filename]#/proc/#
|プロセスファイルシステム; 詳細については man:procfs[5] と man:mount_procfs[8] 参照

|[.filename]#/rescue/#
|man:rescue[8] で説明されている緊急時のために静的にリンクされているプログラム

|[.filename]#/root/#
|`root` アカウントのホームディレクトリ

|[.filename]#/sbin/#
|シングルユーザ環境とマルチユーザ環境の両方で重要なシステムプログラムと管理ユーティリティ

|[.filename]#/tmp/#
|システムの再起動では通常保存 _されない_ 一時的なファイル。
メモリファイルシステムはよく [.filename]#/tmp# にマウントされます。
これは man:rc.conf[5] の tmpmfs 関係の変数を使うか、 [.filename]#/etc/fstab# に設定項目を記入することで自動化できます。
詳しくは man:mdmfs[8] を参照して下さい。

|[.filename]#/usr/#
|大部分のユーザユーティリティとアプリケーション

|[.filename]#/usr/bin/#
|よく使うユーティリティとプログラミングツールとアプリケーション

|[.filename]#/usr/include/#
|C の標準ヘッダファイル

|[.filename]#/usr/lib/#
|ライブラリ

|[.filename]#/usr/libdata/#
|いろいろなユーティリティのデータファイル

|[.filename]#/usr/libexec/#
|他のプログラムから実行されるシステムデーモンとシステムユーティリティ

|[.filename]#/usr/local/#
|ローカルのプログラムやライブラリなど。
FreeBSD ports フレームワークのデフォルトインストール先としても使われます。
[.filename]#/usr/local# 内では、 man:hier[7] に書かれている [.filename]#/usr# のための一般構造が使われます。
例外は man ディレクトリで、 [.filename]#/usr/local/share# の下ではなく [.filename]#/usr/local# の下に直接置かれ、ports 関係文書は [.filename]#share/doc/port# に置かれます。

|[.filename]#/usr/obj/#
|[.filename]#/usr/src# ツリーのビルドで作られるアーキテクチャ依存のターゲットツリー

|[.filename]#/usr/ports/#
|FreeBSD Ports Collection (オプション)。

|[.filename]#/usr/sbin/#
|ユーザにより実行されるシステムデーモンおよびシステムユーティリティ

|[.filename]#/usr/shared/#
|アーキテクチャに依存しないファイル

|[.filename]#/usr/src/#
|BSD のソースファイルまたはローカルのソースファイル、あるいは両方

|[.filename]#/var/#
|さまざまな用途のログ・一時的なファイル・スプールファイル。メモリファイルシステムは時々 [.filename]#/var# にマウントされます。 これは man:rc.conf[5] の varmfs 関係の変数を使うか、 [.filename]#/etc/fstab# に設定項目を記入することで自動化できます。 詳しくは man:mdmfs[8] を参照して下さい。

|[.filename]#/var/log/#
|いろいろなシステムログファイル

|[.filename]#/var/mail/#
|ユーザのメールボックスファイル

|[.filename]#/var/spool/#
|プリンタとメールシステムのスプールディレクトリなどなど

|[.filename]#/var/tmp/#
|一時的なファイル。 [.filename]#/var# がメモリファイルシステムでなければ、 ここにあるファイルはシステムが再起動しても失われません。

|[.filename]#/var/yp/#
|NIS のマップ
|===

[[disk-organization]]
== ディスク構成

ファイルを見つけるために FreeBSD が使用する構成の一番小さな単位はファイル名です。
ファイル名は、大文字と小文字を区別します。
このことは [.filename]#readme.txt# および [.filename]#README.TXT# が異なる二つのファイルであることを意味します。
FreeBSD はそのファイルがプログラム、または文書、あるいはその他の形式かどうかを決定するために拡張子を使用しません。

ファイルはディレクトリ内に格納されます。
ディレクトリはファイルを一つも含んでいないかもしれせんし、または数百のファイルを含んでいるかもしれません。
ディレクトリはまた別のディレクトリを含むことができるので、
データを体系づけるディレクトリの階層構造を構築できます。

ファイルおよびディレクトリは、必要な他のディレクトリ名とスラッシュ (`/`) を後に続けてファイル名またはディレクトリ名を与えることによって参照されます。
たとえば、[.filename]#foo# ディレクトリがあって、その中に [.filename]#bar# ディレクトリがあるとします。
そして、その中に [.filename]#readme.txt# があるとすると、ファイルへのフルネーム、または _パス_ は [.filename]#foo/bar/readme.txt# となります。
ファイルとディレクトリ名を分けるために `\` を使う Windows(R) とは違うことに注意してください。
FreeBSD は、パスの中にドライブレターまたは他のドライブ名を使いません。
たとえば、FreeBSD では [.filename]#c:\foo\bar\readme.txt# とは書きません。

ディレクトリおよびファイルはファイルシステム内に格納されます。
どのファイルシステムも、そのファイルシステムのための _ルートディレクトリ_ とよばれる、まさに頂点の位置にちょうど一つのディレクトリを含んでいます。
このルートディレクトリは他のディレクトリを含むことができます。
一つのファイルシステムは _ルートファイルシステム_ または `/` として設計されています。
すべてのファイルシステムは、ルートファイルシステム以下に _マウント_ されます。
FreeBSD システムでどんなに多くのディスクを使用しても、すべてのディレクトリは、同じディスクの一部であるように見えるので問題ありません。

`A`, `B` および `C` と呼ばれる三つのファイルシステムがあるケースを考えます。
それぞれのファイルファイルシステムには一つのルートディレクトリがあり、`A1`, `A2` と呼ばれている二つの他のディレクトリを含んでいます (同様に `B1`, `B2` および `C1`, `C2` があります)。

`A` をルートファイルシステムとします。
このディレクトリになにが含まれているか見るために man:ls[1] コマンドを使うと、`A1` および `A2` の二つのサブディレクトリが表示されるでしょう。
ディレクトリツリーは以下のようになります。

image::example-dir1.png[]

ファイルシステムはマウント先のファイルシステム内のディレクトリにマウントしなければいけません。
それでは、`A1` ディレクトリに `B` ファイルシステムをマウントすると仮定します。
`B` のルートディレクトリは `A1` に置き換えられ、そして `B` 内のディレクトリがそれに応じて現れます。

image::example-dir2.png[]

`B1` または `B2` 内にあるどんなファイルも、必要なときに [.filename]#/A1/B1# または [.filename]#/A1/B2# で到達できます。
[.filename]#/A1# にあったすべてのファイルは一時的に隠されました。
それらは `B` が `A` から _アンマウント_ されたら再び現れるでしょう。

もし `B` が `A2` にマウントされていたら、この図のようになります。

image::example-dir3.png[]

そして、パスはそれぞれ [.filename]#/A2/B1# および [.filename]#/A2/B2# となるでしょう。

ファイルシステムは互いのファイルシステム上にもマウントできます。
上記の最後の例に続けて、`C` ファイルシステム は `B` ファイルシステム内の `B1` ディレクトリ上にマウントできます。
次の図のようになります。

image::example-dir4.png[]

または `C` を `A` ファイルシステムの `A1` ディレクトリの下に直接マウントできます。

image::example-dir5.png[]

一つの大きなルートファイルシステムを用意し、他のファイルシステムを作成する必要としないことはまったくもって可能です。
この方法にはいくつかの短所と一つの利点があります。

.マルチファイルシステムの利点
* 異なったファイルシステムは異なった _マウントオプション_ を使用できます。
たとえば、ルートファイルシステムを読みだし専用でマウントして、不注意によってユーザが重大なファイルを削除、または編集できないようにすることができます。
また、[.filename]#/home# のようなユーザが書き込み可能なファイルシステムを他のファイルシステムと分けることによって、 _nosuid_ でマウントすることが可能になります。
このオプションは、ファイルシステムに記録されている _suid_/_guid_ の実行可能ビットを有効にしないので、安全性を高めることができるでしょう。
* FreeBSD はファイルシステムがどのように使われているかによって、自動的にファイルシステム上のファイルの配置を最適化します。 したがって、連続的に書き込まれた多くの小さなファイルが含まれているファイルシステムは、より大きく少ないファイルが含まれているファイルシステムと異なる最適化をするでしょう。 一つの大きなファイルシステムを作成すると、この最適化は成り立たなくなります。
* FreeBSD のファイルシステムはトラブルが起きても強固です。 しかしながら臨界点でのトラブルは、ファイルシステムの構造にまだ損害を与えるかもしれません。 マルチファイルシステムへデータを分割しておくことで、 必要なときにバックアップからレストアすることをより容易にして、まだシステムが回復するかもしれません。

.シングルファイルシステムの利点
* ファイルシステムは固定サイズです。 FreeBSD をインストールするときにファイルシステムを作成して、 固定サイズを割りあてたなら、 後になってそのパーティションをより大きくする必要があると気づくかもしれません。 パーティションのサイズを変更するには、 バックアップ、新しいサイズを指定したファイルシステムの再作成、 バックアップしたデータをリストアする作業が必要となるでしょう。
+
[IMPORTANT]
====
FreeBSD には、 man:growfs[8] コマンドがあります。 このコマンドは、この制限を取り除いて、 ファイルシステムのファイルを直ちに増加させることを可能にします。 
====

ファイルシステムはパーティション内に含まれています。 FreeBSD の UNIX(R) 遺産のために、 これは普段使われるパーティション (例えば MS-DOS(R) パーティション) という用語の意味とは違う意味を持っています。 それぞれのパーティションは `a` から `h` までの文字で区別されます。 それぞれのパーティションは、 一つのファイルシステムだけを含むことができます。 このことは、ファイルシステムがファイルシステムの階層上の典型的なマウントポイント、 または含まれているパーティションの文字によって記述されることを意味します。

FreeBSD は _スワップ領域_ にもまたディスク領域を使用します。
スワップ領域は FreeBSD に _仮想メモリ_ を提供します。
これはあなたのコンピュータが、 実際に搭載している以上のメモリがあるかのように振舞います。
FreeBSD がメモリを使い果たしたときに、現在使用されていないデータのいくつかをスワップ領域に移動し、そのデータが必要となったときに (その他のデータをスワップ領域に移動させてから) メモリ内に移動しなおします。

いくつかのパーティションはある慣習と関係づけられています。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| パーティション
| 慣習

|`a`
|通常、ルートパーティションを含みます。

|`b`
|通常、スワップ領域を含みます。

|`c`
|通常、スライス全体と同じサイズです。
これは、スライス全体にアクセス必要のあるユーティリティ (たとえば、ひどいブロックスキャナ) が、 `c` パーティションにアクセスすることを可能にします。
通常、このパーティション内にファイルシステムは作成されません。

|`d`
|`d` パーティションは、 それに関連づけられた特別な意味を持っていましたが、 今は無いので、普通のパーティションとして動作するでしょう。
|===

FreeBSD のディスクはスライスに分けられます。
Windows(R) ではパーティションと呼ばれるもので、
スライスには 1 から 4 までの番号がつけられます。
これらのスライスは、ファイルシステムを含むパーティションに分けられます。
パーティションは文字で表されます。

スライス番号は 1 から始まり `s` を前につけられて、デバイス名の後に続きます。
したがって、"da0__s1__" は一番目の SCSI ドライブ上の 一番目のスライスです。
ディスク上に存在できる物理スライスは、4 つまでですが、適切な種類の物理スライス内に論理スライスを作成できます。
これらの拡張されたスライス番号は 5 から始まります。
したがって、 "ad0__s5__" は、一番目の IDE ディスク上の一番目の拡張スライスです。
これらのデバイスは、 スライスを占有することを予期するファイルシステムによって使用されます。

スライスや "危険な専用" の物理ドライブ、 そして他のドライブは `a` から `h` までの文字として表される _パーティション_ を含んでいます。
この文字はデバイス名に追加されます。
したがって、 "da0__a__" は一番目の "危険な専用" `da` ドライブ上の `a` パーティションです。
"ad1s3__e__" は、 二番目の IDE ディスク上の 三番目のスライス内にある五番目のパーティションです。

最後に、システム上のそれぞれのディスクは識別されます。
ディスク名はどの種類のディスクであるかを示す記号ではじまり、どのディスクかを示す数字が続きます。
スライスとは違いディスクの番号づけは 0 から始まります。
共通の記号は <<basics-dev-codes>> に示されます。

パーティションを参照するときには、 ディスク名、`s`、スライス番号、 そしてパーティション文字を含めてください。
<<basics-disk-slice-part>> に例があります。

<<basics-concept-disk-model>> は、ディスク構成の概念のモデルを示します。

FreeBSD をインストールする際には、ディスクスライスの設定し、次に FreeBSD に用いるスライス内のパーティションを作成し、それからそれぞれのパーティション内にファイルシステムまたはスワップ領域を作成し、 ファイルシステムがどこにマウントされるか決定しなければいけません。

[[basics-dev-codes]]
.ディスクデバイス記号
[cols="1,1", frame="none", options="header"]
|===
| 記号
| 意味

|[.filename]#ad#
|ATAPI (IDE) ディスク

|[.filename]#da#
|SCSI ダイレクトアクセスディスク

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|フロッピーディスク
|===

[[basics-disk-slice-part]]
.ディスク名、スライス名、パーティション名のサンプル
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 名前
| 意味

|`ad0s1a`
|一番目の IDE ディスク (`ad0`) 上の一番目のスライス (`s1`) 内の一番目のパーティション (`a`)。

|`da1s2e`
|二番目の SCSI ディスク (`da1`) 上の二番目のスライス (`s2`) 内の五番目のパーティション (`e`)。
|===
====

[[basics-concept-disk-model]]
.ディスクの概念的構成
[example]
====
これはシステムに接続された一番目の IDE ディスクの FreeBSD から見た図を示します。 ディスクサイズは 4 GB と仮定し、 2 GB のスライス (MS-DOS(R) でいうパーティション) が二つあるとします。 一番目のスライスは MS-DOS(R) ディスクの [.filename]#C:# を含んでいます。 そして、二番目のスライスは FreeBSD のディスクを含んでいます。 これは FreeBSD インストーラが三つのデータパーティションと一つのスワップパーティションを作成した例です。

三つのパーティションはそれぞれファイルシステムを含んでいます。 `a` パーティションはルートファイルシステムに使用され、 `e` パーティションは [.filename]#/var# ディレクトリ階層に、 `f` パーティションは [.filename]#/usr# ディレクトリ階層に使用されるでしょう。

image::disk-layout.png[]

====

[[mount-unmount]]
== ファイルシステムのマウントとアンマウント

ファイルシステムは [.filename]#/# をルート (根) とする木構造として考えると視覚的に理解しやすいでしょう。
ルートディレクトリにある [.filename]#/dev# や [.filename]#/usr#、その他のディレクトリは枝に相当し、それらには、[.filename]#/usr/local# などのように、さらに枝分かれすることができます。

さまざまな理由がありますが、 ディレクトリをいくつかの異なるファイルシステム上に構築するのが良いでしょう。
たとえば [.filename]#/var# には、 [.filename]#log/# や [.filename]#spool/# など、さまざまな種類の一時ファイルを置くディレクトリがあるため、あふれてしまう可能性があります。
ルートファイルシステムをあふれさせるのは得策ではありませんので、普通は [.filename]#/var# を [.filename]#/# から分離します。

また、次のような場合も、ディレクトリツリーを別のファイルシステムに置く理由として良くあげられます。
それは、たとえば物理的に別のディスクにディレクトリツリーを置く場合、 crossref:advanced-networking[network-nfs, 「ネットワークファイルシステム (NFS)」] で説明されているようにネットワークファイルシステムをマウントしたり、CDROM ドライブのような別の仮想ディスクに置くという場合です。

[[disks-fstab]]
=== [.filename]#fstab# ファイル

[.filename]#/etc/fstab# に書かれているファイルシステムは、`noauto` オプション指定されているエントリを除いて crossref:boot[boot,起動プロセス] の途中で自動的にマウントされます。
このファイルは、 次のような書式で書かれたエントリを含んでいます。

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
デバイス名。crossref:disks[disks-naming,「デバイス名」] に説明があります。

`mount-point`::
ファイルシステムがマウントするディレクトリ。

`fstype`::
man:mount[8] に渡されるファイルシステムタイプ。 FreeBSD ファイルシステムのデフォルトは `ufs` です。

`options`::
読み書きするファイルシステムには `rw`、読み込み専用のファイルシステムには `ro` を、必要な他のオプションの前に指定します。 よく使われるオプションは `noauto` で、 起動時にはマウントされないファイルシステムに使います。 その他のオプションは man:mount[8] マニュアルページに載っています。

`dumpfreq`::
これは man:dump[8] が使うもので、 どのファイルシステムにダンプが必要なのかを決めます。 この項目がなければ、0 であるものとみなされます。

`passno`::
これはファイルシステムをチェックする順番を決めます。
ファイルシステムチェックを飛ばしたいファイルシステムには、`passno` を 0 に設定してください。 ルートファイルシステムはどれよりも先にチェックする必要があり、`passno` は 1 に設定してください。 他のファイルシステムの `passno` は 1 以上に設定してください。 同じ `passno` のファイルシステムがあった場合、 man:fsck[8] は可能であれば並行してファイルシステムのチェック を行なおうとします。

[.filename]#/etc/fstab# の書式やオプションに関しての詳細は、 man:fstab[5] をご覧ください。

[[disks-mount]]
=== man:mount[8] の使い方

ファイルシステムは man:mount[8] を用いてマウントされます。
基本な構文は以下のようになります。

[source,shell]
....
# mount device mountpoint
....

man:mount[8] で説明されているように、このコマンドはたくさんのオプションを提供しますが、最もよく使われるのは次のものです。

.マウントオプション
`-a`::
[.filename]#/etc/fstab# にある全てのファイルシステムをマウントします。 例外は "noauto" の印がついているものと、 `-t` フラグで除外されたものと、 すでにマウントされているファイルシステムです。

`-d`::
実際にマウントシステムコールする以外のすべてのことをします。 このオプションは `-v` フラグと組み合わせて使い、 man:mount[8] が実際なにをしようとしているのか調べるのに便利です。

`-f`::
クリーンでないファイルシステムを強制的にマウントします (危険です)。もしくは、ファイルシステムのマウント状態を 読み書き可能から読み込みのみに変更するとき、 書き込みアクセスを強制的に取り消します。

`-r`::
ファイルシステムを読み込み専用でマウントします。
`-o ro` を使うのと同じです。

`-t` _fstype_::
指定のファイルシステムタイプでマウントします。 または、`-a` を使った場合、 指定したタイプのファイルシステムのみマウントします。
デフォルトのファイルシステムタイプは "ufs" です。

`-u`::
ファイルシステムのマウントオプションを更新します。

`-v`::
詳細な出力にします。

`-w`::
ファイルシステムを読み書き可能にマウントします。

`-o` には、 次のようなオプションを複数カンマで区切って指定できます。

nosuid::
そのファイルシステム上の setuid や setgid フラグを解釈しません。 これもセキュリティのために有用なオプションです。

[[disks-umount]]
=== man:umount[8] の使い方

ファイルシステムをアンマウントするには、man:umount[8] を使ってください。
このコマンドは、パラメータとしてマウントポイントの一つ、 デバイス名、もしくは `-a` や `-A` といったオプションを取ります。

いずれの形式でも `-f` で強制的なアンマウントを行ない、 `-v` で詳細な出力を出します。
ただしほとんどの場合、`-f` は使わないほうがよいでしょう。
計算機がクラッシュしたりファイルシステム上部のデータが破壊されたりする恐れがあります。


マウントされているファイルシステムすべてをアンマウントするには、`-a` と `-A` を使ってください。
`-t` にファイルシステムタイプを指定すると、指定されたものだけがアンマウントされます。
`-A` を使うとルートファイルシステムはアンマウントしません。

[[basics-processes]]
== プロセスおよびデーモン

FreeBSD はマルチタスクのオペレーティングシステムです。
動作中のプログラムはそれぞれ _プロセス_ と呼ばれます。
すべてのコマンドは実行すると、最低でも 1 つの新しいプロセスを開始します。
FreeBSD により実行されているシステムプロセスもたくさんあります。

各プロセスは _プロセス ID_ (PID) と呼ばれる数字でただ一つに識別されます。
ファイルのように各プロセスには所有者とグループがあり、
所有者とグループの許可属性は、そのプロセスが開けるファイルやデバイスを決定するために使われます。
多くのプロセスには親プロセスもあります。
親プロセスとは、そのプロセスをスタートさせたプロセスのことです。
例えば、シェルがプロセスで、シェルから起動されるコマンドは、シェルを親プロセスとするプロセスとなります。
例外は man:init[8] という特別なプロセスです。
`init` は FreeBSD がスタートするときに起動される最初のプロセスで、PID は常に `1` です。

ユーザから始終入力があるように設計されていないプログラムがあり、そういったプログラムは最初から端末と切り離されています。
例えば、ウェブサーバはユーザからの入力ではなくウェブのリクエストを処理します。
メールサーバも、 こういった種類のアプリケーションの一例です。
このような種類のプログラムは、 _デーモン_ と呼ばれます。
デーモンはギリシャ神話から来ており、目に見えないように役立つことをしてくれる善でも悪でもない実体を表します。
このため、BSD のマスコットはスニーカーをはいてフォークを携えたかわいらしい姿のデーモンなのです。

通常デーモンとして動作するプログラムには末尾に "d" を持った名前をつける慣習があります。
例えば、BIND は Berkeley Internet Name Domain ですが、 実際実行されるプログラムは `named` です。
また、Apache ウェブサーバのプログラムは `httpd`、ラインプリンタスプーリングデーモンは `lpd` です。
これは単なる命名に関する慣習です。
例えば、Sendmail アプリケーションの主なメールデーモンは `sendmail` で、`maild` ではありません。

=== プロセスを確認する

システム上で実行中のプロセスを確認するには、man:ps[1] または man:top[1] を使ってください。
現在動作中のプロセスのリスト、プロセスの PID やプロセスが使っているメモリの量、どういうコマンドラインで起動されたのかなどを表示させるには、man:ps[1] を使ってください。
man:top[1] を使用すると、動作中の全てのプロセスを表示できます。
数秒ごとに表示を更新するので、計算機が何をしているのかインタラクティブに知ることができます。

デフォルトでは、man:ps[1] はユーザにより動作中かつ所有のコマンドのみを表示します。
例えば:

[source,shell]
....
% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps</screen>
....

man:ps[1] の出力はいくつかの列に整形されています。
`PID` の列はプロセス ID を表示します。
PID は 1 から順に 99999 まで割り当てられ、その後足りなくなると最初に戻って使い回されます。ただし、使用中の PID には割り当てられません。
`TT` の列はプログラムが動いている tty を示し、`STAT` はプログラムの状態を示します。
`TIME` はプログラムがその CPU 上で動いている時間の長さです。
通常はプログラムをスタートさせたときからの経過時間ではありません。
多くのプログラムは、CPU 上で時間を使う必要があるまでかなりの時間を費すためです。
最後に、`COMMAND` はそのプログラムを起動するのに使われたコマンドとなります。

表示する情報を変更するオプションが用意されています。
いちばん便利なのは `auxww` でしょう。
`a` はすべてのユーザの動作中のプロセス全部についての情報を表示します。
`u` はプロセスの所有者のユーザ名とメモリ使用量を表示します。
`x` はデーモンプロセスについての情報を表示し、`ww` で、スクリーンに入りきらないほど長くなったコマンドラインでも省略せず、man:ps[1] に各プロセスの全コマンドラインを表示させます。

man:top[1] の出力も同様です。

[source,shell]
....
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

出力は2つのセクションに分かれています。
ヘッダ (最初の 5 または 6 行) は動作している最新のプロセスの PID、システムの平均負荷 (システムがどれくらい忙しいかの指標)、システムの稼働時間 (最後の再起動からの時間) と現在の時刻を示します。
ヘッダの中の他の数字は動作中のプロセスの数、使われているメモリとスワップ領域の量、そしてシステムが異なる CPU 状態に消費した時間と関係します。
ZFS ファイルシステムモジュールをロードしている場合には、`ARC` 行にはディスクではなくメモリキャッシュから読み込んだデータ量が表示されます。

ヘッダの下には、PID、ユーザ名、消費 CPU 時間とプロセスを起動したコマンドといった man:ps[1] の出力と同じような情報を持った行が続きます。
man:top[1] を使うとデフォルトでプロセスが使っているメモリ容量を表示します。
メモリ使用量の欄は 2 項目に分かれており、 一方は合計使用量、 そしてもう一方は実使用量です。
合計使用量はアプリケーションが必要としているメモリ量で、実使用量はその時点で実際に使われているメモリ量です。

man:top[1] は自動的に 2 秒ごとに画面を更新します。
`-s` 使うと更新間隔を変更することができます。

[[basics-daemons]]
=== プロセスの終了

動作中のプロセスもしくはデーモンと通信する一つの方法は、man:kill[1] を用いて _シグナル_ を送信する方法です。
送信可能なシグナルはたくさんあります。
特別な意味があるものもあれば、アプリケーションの文章に説明されているものもあります。
ユーザは自分が所有者となっているプロセスにのみシグナルを送ることができます。
他人のプロセスにシグナルを送ると、permission denied というエラーになるでしょう。
この例外は `root` ユーザで、 ルートユーザは誰のプロセスに対してもシグナルを送ることができます。

オペレーティングシステムもプロセスにシグナルを送ることができます。
アプリケーションを下手に書いてしまい、予想外のメモリにアクセスしようとすると、FreeBSD はプロセスに "セグメンテーション違反" シグナル (`SIGSEGV`) を送ります。
ある程度の時間が経ったら man:alarm[3] システムコールを使って警告してもらうように書かれているアプリケーションには、"警告" シグナル (`SIGALRM`) が送信されます。

プロセスを止めるためには2つのシグナル、`SIGTERM` か `SIGKILL` を使います。
`SIGTERM` は穏かにプロセスを終了させる方法です。
プロセスはシグナルを受け取ることができ、開いているすべてのログファイルを閉じ、終了前にしていたことを終えるように試みることができます。
中断できない処理の途中だと、`SIGTERM` をプロセスが無視することもあるかもしれません。

プロセスは `SIGKILL` を無視することができません。
プロセスに `SIGKILL` を送ると、プロセスは通常その時点で止まります。

他に良く使われるシグナルには、`SIGHUP`、`SIGUSR1` と `SIGUSR2` があります。
これらは一般的な用途のシグナルなので、このシグナルが送信されたときの応答は、アプリケーション毎に異なります。

例として、ウェブサーバの設定ファイルを変更後、ウェブサーバに設定を再読み込みさせる必要があります。
`httpd` を再起動するとウェブサーバは一瞬ながら停止してしまいます。
その代わりに `SIGHUP` シグナルを送りましょう。
デーモンごとに行動が違うので、`SIGHUP` が期待する結果となるように、そのデーモンの文書を読んで確認してください。

[.procedure]
====
*Procedure: プロセスにシグナルを送る*

この例では、man:inetd[8] にシグナルを送る方法を示します。
man:inetd[8] の設定ファイルは [.filename]#/etc/inetd.conf# で、man:inetd[8] は `SIGHUP` が送信されるとこの設定ファイルを再読み込みします。

. man:pgrep[1] を使ってシグナルを送りたいプロセスの PID を調べます。
この例では man:inetd[8] の PID は 198 です。
+
[source,shell]
....
% pgrep -l inetd
198  inetd
....
+ 
. man:kill[1] を使ってシグナルを送ります。 man:inetd[8] は `root` が所有しているため、まず man:su[1] を使って `root` になってください。
+
[source,shell]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
大部分の UNIX(R) コマンドと同じく、 成功したら man:kill[1] は何の出力も表示しません。
ユーザが所有していないプロセスにシグナルを送ると、`kill: _PID_: Operation not permitted` といったメッセージが表示されます。
PID を打ち間違えると、間違ったプロセスにシグナルを送ってしまい悪い結果になってしまったり、その時点で使われていない PID にシグナルを送ったことになり、`kill: _PID_: No such process` とエラーが表示されます。

[NOTE]
.なぜ `/bin/kill` を使うんでしょう?
======
多くのシェルは `kill` を組み込みコマンドとして備えています。
つまり、[.filename]#/bin/kill# を実行するのではなく、シェルが直接シグナルを送ります。
シェルが違うと送るシグナルの名前の指定の仕方が違うことに注意してください。
シェルによって異なるシグナルの指定の仕方を全部覚えようとはせずに、 `/bin/kill` を直接使うほうが簡単です。
======
====

他のシグナルを送る場合は、コマンドラインの `TERM` や `KILL` を必要に応じて置き換えてください。

[IMPORTANT]
====
システム上のランダムプロセスを終了させるのはよくありません。
特に、PID が 1 の man:init[8] は特別です。
`/bin/kill -s KILL 1` は推奨されていませんが、実行するといとも簡単にシステムをシャットダウンさせることができます。
kbd:[Return] を押す _前_ に man:kill[1] を実行する引数を二重にチェックする _癖_ をつけてください。
====

[[shells]]
== シェル

_シェル_ は、オペレーティングシステムを利用するためのコマンドラインインタフェースを提供します。
シェルは入力チャンネルからコマンドを受け取り、それらを実行します。
大部分のシェルは、日々の作業、ファイル管理やファイル名の展開、コマンドライン編集、コマンドマクロ、環境変数といった組み込みの機能を持ってます。
FreeBSD には Bourne Shell (man:sh[1]) や 高機能 C-shell (man:tcsh[1]) が含まれています。
また、これ以外にも `zsh` や `bash` などのシェルが FreeBSD Ports Collection から利用可能です。

どのシェルを使うかは、まったく趣味の問題です。
あなたが C のプログラマだったとすれば、man:tcsh[1] のような C 風のシェルの方が落ち着くかもしれません。
Linux(R) ユーザであれば、`bash` を好まれるでしょう。
それぞれのシェルは、 ユーザの好みの作業環境で利用できる (もしくはできない) 独自の機能を持っているということ、そして、どのシェルを使うことにするかを決めるのはyユーザ自身ということです。

シェルの一般的な機能の一つに、ファイル名の補完があります。
コマンドやファイル名の最初の数文字を入力し、kbd:[Tab] を押すことで、シェルにコマンドやファイル名の残りの部分を自動的に補完させることができます。
例として、二つのファイル [.filename]#foobar#, [.filename]#foo.bar# が あったとします。
ここで [.filename]#foo.bar# の方を削除するには、 `rm fo[Tab].[Tab]` と入力します。

するとシェルは `rm foo[BEEP].bar` と出力するでしょう。

[BEEP] のところはコンソールのベル (訳注: 通常はビープ音が鳴ります) です。
複数のファイルがマッチしたため、ファイル名の補完を完全には行なえなかったことを示しています。
[.filename]#foobar# と [.filename]#foo.bar# は両方とも `fo` ではじまります。
`.` を入力して kbd:[Tab] を押すと、シェルはファイル名の残りの部分を補完できます。

もう一つあげられるシェルの特徴として、環境変数があります。
環境変数とは、シェルの環境変数におけるキーと値とのペアです。
この環境変数は、そのシェルから起動されたプログラムから参照でき、それを利用してプログラムの設定を保存するのに利用されます。
以下は、一般的な環境変数とその意味の一覧です。
環境変数の名前は常に大文字です。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 変数名
| 意味

|`USER`
|現在のログインユーザのユーザ名。

|`PATH`
|コロンで区切られた実行ファイル探索のための ディレクトリのリスト。

|`DISPLAY`
|接続する Xorg ディスプレイのネットワーク名 (存在する場合のみ)。

|`SHELL`
|現在のシェル。

|`TERM`
|ユーザの端末種名。 端末のケーパビリティを決定するのに使われる。

|`TERMCAP`
|種々の端末の機能を実現する端末のエスケープコードの データベースのエントリ。

|`OSTYPE`
|オペレーティングシステムの種別。

|`MACHTYPE`
|システムの CPU アーキテクチャ。

|`EDITOR`
|ユーザの選んだテキストエディタ。

|`PAGER`
|ユーザの選んだ画面上でテキストを見るためのユーティリティ。

|`MANPATH`
|コロンで区切られたマニュアルページ探索のための ディレクトリのリスト。
|===

環境変数を設定する方法は、シェルごとに多少異なります。
man:tcsh[1] や man:csh[1] では `setenv` を使います。
man:sh[1] や `bash` 等の Bourne シェルでは、`export` を使って現在の環境変数を設定します。
以下の例では、`tcsh` シェルでデフォルトの `EDITOR` を [.filename]#/usr/local/bin/emacs# に設定します。

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

`bash` では次のようになります。

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

現在の設定を確認するために、コマンドライン中の変数名の前に `$` 文字を置くことで、環境変数を展開させることができます。
たとえば、`echo $TERM` は `$TERM` が セットされている内容を表示します。

シェルは特殊文字を、特別なデータを表すものとして扱います。
その特殊文字はメタキャラクタと呼ばれます。
もっとも一般的なメタキャラクタは `\*` で、これはファイル名に含まれる、あらゆる文字を表します。
メタキャラクタはファイル名の展開に使われます。
たとえば、`echo *` と入力すると `ls` と入力したのとほとんど同じ結果を得られます。
これはシェルが `*` とマッチするすべてのファイルを受け取って `echo` はコマンドラインでそれらを表示するからです。

特殊文字をシェルに解釈させないようにするため、特殊文字の前にバックスラッシュ文字 (`\`) を置いてエスケープしてください。
例えば `echo $TERM` は端末の設定を表示し、`echo \$TERM` は `$TERM` とそのまま表示します。

[[changing-shells]]
=== シェルの変更

デフォルトのシェルを変更する一番簡単な方法は `chsh` を使うことです。
このコマンドを実行すると、環境変数 `EDITOR` で示されたエディタ (デフォルトでは man:vi[1] が設定されている) が立ち上がります。
`Shell:` の行を変更するシェルの絶対パスに変更してください。

代わりに `chsh -s` を使うと、エディタを起動せずにシェルを変更できます。
たとえば、シェルを `bash` に変えたいなら、次のようにしてください。 

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
使おうと思っているシェルは__必ず__[.filename]##/etc/shells## 中に書かれていなければなりません。
シェルを crossref:ports[ports,アプリケーションのインストール - packages と ports] で説明されている FreeBSD の Ports Collection からインストールしたのであれば、自動的にこのファイルに追加されています。
もし書かれていなければ、以下のコマンドで、パスをシェルのパスに置き換えて使って追加してください。

[source,shell]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

その後 man:chsh[1] を実行してください。
====

[[editors]]
== テキストエディタ

多くの FreeBSD の設定は、テキストファイルを編集することで行われます。
そのため、テキストエディタの扱いに慣れると良いでしょう。
FreeBSD には、基本システムの一部として二、三提供されるものと、Ports Collection から利用できる、たくさんのテキストエディタが用意されています。 

学習が簡単なエディタは、 easy editor の略で man:ee[1] と呼ばれるものです。
このエディタを立ち上げるには、`ee _filename_` と入力してください。
ここで _filename_ は、 編集しようとしているファイルの名前です。
一旦このコマンドの中に入れば、 エディタの機能を操作するコマンドはすべてディスプレイの上部に表示されています。
キャレット (`^`) は kbd:[Ctrl] を意味するので、`^e` は kbd:[Ctrl+e] を押すという意味になります。
man:ee[1] を終了するには kbd:[Esc] を押し、そしてメインメニューから "leave editor" オプションを選択してください。
ファイルが更新されていたときは、エディタは変更をセーブするかどうかプロンプトを出します。

FreeBSD には、ベースシステムの一部として man:vi[1] といったより強力なテキストエディタが用意されています。
package:editors/emacs[] および package:editors/vim[] といった他のエディタは Ports Collection の一部として用意されています。
これらのエディタはやや学習が複雑ですが、より高い機能性を提供します。
しかし、あなたが多量のテキストを編集することを考えているなら、 vim や Emacs といった強力なエディタを習得することは、 より多くの時間を節約することでしょう。

ファイルを編集したり、文字入力を必要とするようなアプリケーションの多くは、自動的にテキストエディタを起動します。
<<shells>> の節で説明したように、デフォルトのエディタを変更するには `EDITOR` 環境変数に希望するエディタを設定してください。

[[basics-devices]]
== デバイスとデバイスノード

デバイスとはシステム上のハードウェアに関するものに対してよく使われる用語で、ディスクやプリンタ、グラフィックカードやキーボードが含まれます。
FreeBSD が起動するとき、ブートメッセージの大部分は検出されたデバイスについてのものです。
ブートメッセージは [.filename]#/var/run/dmesg.boot# に保存されています。

各デバイスはデバイス名と番号を持ちます。
例えば、[.filename]#acd0# は最初の IDE CD-ROM ドライブで、[.filename]#kbd0# はキーボードを表します。

FreeBSD におけるほとんどのデバイス、デバイスノードと呼ばれる [.filename]#/dev# にあるスペシャルファイルを通してアクセスしなければなりません。

[[basics-more-information]]
== マニュアルページ

[[basics-man]]
=== オンラインマニュアル

FreeBSD についてのもっとも包括的な文書は、 マニュアルページの形式になっているものです。
FreeBSD システム上のほとんどすべてのプログラムには、基本的な操作方法と利用可能な引数を説明しているリファレンスマニュアルが添付されています。
これらのマニュアルは `man` を使って見ることができます。

[source,shell]
....
% man コマンド名
....

ここで `コマンド名` のところには、知りたいコマンドの名前を入れます。
たとえば man:ls[1] について知りたい場合には、次のように入力します。

[source,shell]
....
% man ls
....

マニュアルは、トピックごとにセクション番号で分類されています。
FreeBSD では、以下のセクションがあります。

. ユーザコマンド
. システムコールとエラー番号
. C のライブラリ関数
. デバイスドライバ
. ファイル形式
. ゲームや娯楽
. さまざまな情報
. システムの管理と操作のためのコマンド
. システムカーネルインタフェース

時折、 同じトピックがオンラインマニュアルの複数のセクションに記載されている場合があります。
たとえば、`chmod` ユーザコマンドと `chmod()` システムコールの場合がそれに該当します。
man:man[1] にセクション番号を与えることで、 表示したいセクションを指定できます。

[source,shell]
....
% man 1 chmod
....

上のようにすれば、ユーザコマンド man:chmod[1] のマニュアルページが表示されます。
オンラインマニュアルの特定セクションへの参照は、慣習的に書かれている文書で括弧の中に示されます。
すなわち、man:chmod[1] はユーザコマンドを、man:chmod[2] はシステムコールの方を示しています。

マニュアルページの名前を知らない場合には、`man -k` を使ってマニュアルページの解説 (description) からキーワードを検索してください。

[source,shell]
....
% man -k mail
....

このコマンドは、"mail" というキーワードをコマンド解説に含むコマンドの一覧を表示します。
これは man:apropos[1] と同等の機能です。

[.filename]#/usr/bin# にあるコマンドの説明を読むには、以下のように実行してください。

[source,shell]
....
% cd /usr/bin
% man -f * | more
....

または、以下を実行してください。

[source,shell]
....
% cd /usr/bin
% whatis * |more
....

[[basics-info]]
=== GNU の Info ファイル

FreeBSD には Free Software Foundation (FSF) によるアプリケーションや ユーティリティがたくさん含まれています。
これらのプログラムには、マニュアルページに加えて `info` ファイルと呼ばれるハイパーテキスト形式の文書が付属しています。
この文書は man:info[1]、あるいは package:editors/emacs[] をインストールしているなら emacs の info モードで読むことができます。

man:info[1] を使うには、次のように入力してください。

[source,shell]
....
% info
....

`h` と入力すると、 簡単な手引きを読むことができます。 クイックコマンドリファレンスは `?` を入力してください。
