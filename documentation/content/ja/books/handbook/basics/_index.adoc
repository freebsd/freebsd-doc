---
title: 第3章 UNIX の基礎知識
part: パートI. 導入
prev: books/handbook/bsdinstall
next: books/handbook/ports
showBookMenu: true
weight: 5
path: "/books/handbook/"
---

[[basics]]
= UNIX の基礎知識
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 3
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== この章では

この章では FreeBSD オペレーティングシステムの基本的なコマンドと機能について記述しています。
ここに書かれてあることのほとんどは、どんな UNIX(R) -like なオペレーティングシステムにもあてはまります。
FreeBSD の初心者であれば、この章を読んでおいた方がきっといいはずです。

この章を読んで分かることは、次のようなことです。

* FreeBSD の "仮想コンソール" の使い方
* UNIX(R) のファイルの許可属性の仕組みと FreeBSD のファイルフラグについて
* FreeBSD のファイルシステムの構成
* FreeBSD のディスク構成
* ファイルシステムをマウント、アンマウントする方法
* プロセス、デーモンとシグナルとはなにか
* シェルとはなにか。 また、デフォルトのログイン環境を変える方法
* テキストエディタの基本的な使い方
* デバイスおよびデバイスノードとはなにか
* さらに詳しい情報を得るためのマニュアルページの読み方

[[consoles]]
== 仮想コンソールと端末

FreeBSD は様々な使い方ができます。
その中の一つが、テキスト端末でコマンドを入力することです。
この方法で FreeBSD を使えば、 UNIX(R) オペレーティングシステムの能力と柔軟性を手にすることができます。
この節では、"コンソール" と "端末" はどのようなもので、FreeBSD でどう使うかを 説明します。

[[consoles-intro]]
=== コンソール

起動時に自動的にグラフィカルな環境が起動するように FreeBSD を設定していなければ、システムが起動すると、以下のようなコマンドラインのログインプロンプトが表示されます。

[source,shell]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

最初の行はシステムの情報です。
`amd64` は、このシステム上で 64 ビット版の FreeBSD が動作していることを示しています。
ホスト名は `pc3.example.org`、[.filename]#ttyv0# はシステムコンソールであることを示しています。

次の行はログインプロンプトです。
このプロンプトから FreeBSD にログインする方法を次の節で説明します。

[[consoles-login]]
=== FreeBSD にログインする

FreeBSD は、マルチユーザ、マルチプロセスなシステムです。 これは、1 台のマシンで何人もの人が交互に多くのプログラムを 動かせるシステムに与えられる正式な説明です。

あらゆるマルチユーザシステムには、ある "ユーザ" を他のユーザと区別する何がしかの手段が必要です。 FreeBSD (とすべての UNIX(R) like なオペレーティングシステム) では、 すべてのユーザに対してプログラムの実行を可能にするのに、システムに "ログイン" することを義務付けてこれを実現しています。 どのユーザにも、一意な名前 ("ユーザ名") と個人的な秘密の鍵 ("パスワード") があります。 FreeBSD はユーザにプログラムの実行を許可する前に、 この 2 つの入力を要求します。

FreeBSD が起動すると、システムを準備したり、システム起動時に開始すべきサービスを起動するように、スタートアップスクリプトが自動的に実行されます。
そして、プロンプトを表示して有効なユーザ名の入力を促します。

[source,shell]
....
login:
....

システムのインストール時に、crossref:bsdinstall[bsdinstall-addusers,ユーザの追加] で追加したユーザ名を入力して、kbd:[Enter] を押してください。
次にそのユーザのパスワードを入力して、kbd:[Enter] を押してください。
セキュリティの観点から、パスワードは _表示されません_。

パスワードを正確に入力したら、日々のメッセージ (MOTD) が表示され、
コマンドプロンプト (`#`, `$` または `%` 記号) が表示されます。
これで FreeBSD コンソールへのログインが行われ、利用可能なコマンドを実行する準備ができました。

[[consoles-virtual]]
=== 仮想コンソール

FreeBSD は、複数の仮想コンソールを表示してコマンドを入力できるように設定できます。
各仮想コンソールは、個別のログインプロンプトおよび出力チャンネルを持っており、FreeBSD は仮想コンソール間の切り替えに応じて、キーボード入力とモニター出力を適切につなぎ直します。

FreeBSD は、コンソールを切り替えるために、特別なキーの組合せを予約しています。
FreeBSD では kbd:[Alt+F1], kbd:[Alt+F2] から kbd:[Alt+F8] までを、別の仮想コンソールへの切り替えに使えます。

あるコンソールから他に切り替えるのに応じて、FreeBSD は画面への出力を保存して戻します。
結果として、FreeBSD で動かすコマンドを入力するのに使える複数の画面とキーボードを "仮想的に" 実現できるのです。
ある仮想コンソールで実行したプログラムは、別の仮想コンソールに切り替えて、そのコンソールが見えなくなっている時も実行を停止しません。

FreeBSD のコンソールおよびキーボードドライバに関するさらなる技術的な説明については、man:kbdcontrol[1], man:vidcontrol[1], man:atkbd[4], man:syscons[4] および man:vt[4] を参照してください。

[[consoles-ttys]]
=== [.filename]#/etc/ttys# ファイル

初期設定では、FreeBSD は 8 つの仮想コンソールを立ち上げるように設定されています。
この設定については、より多く、またはより少ない数の仮想コンソールを起動するように、カスタマイズできます。
仮想コンソールの数を変更するには、[.filename]#/etc/ttys# ファイルを編集してください。

[.filename]#/etc/ttys# ファイルの中で、コメントアウトされていない (`#` 文字で始まっていない) 行には、一つの端末または仮想コンソールの設定が含まれています。
FreeBSD の初期設定では、 仮想コンソールを 9 つ設定し、そのうち 8 つを有効にしています。
`ttyv` で始まる行が関連する行です。

[.programlisting]
....
# name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

このファイルのそれぞれのカラムと仮想コンソールに設定可能なオプションの詳しい説明は、man:ttys[5] のマニュアルを参照してください。

[[consoles-singleuser]]
=== シングルユーザモードのコンソール

"シングルユーザモード" についての詳しい説明は、 crossref:boot[boot-singleuser,「シングルユーザモード」] にあります。
FreeBSD をシングルユーザモードで動かしている場合は、コンソールは一つしかなく、他の仮想コンソールは利用できません。
シングルユーザモードの設定は、[.filename]#/etc/ttys# ファイルの以下のセクションにあります。

[.programlisting]
....
# name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

[NOTE]
====
`console` 行の上記のコメントが示すように、`secure` を `insecure` に変更すると、 FreeBSD がシングルユーザモードで起動した場合に `root` のパスワードが要求されます。
デフォルトの設定では、パスワードが要求されることなくシングルユーザモードで起動します。

_`insecure` に 変更する場合は十分注意してください!_ 
`root` のパスワードを忘れてしまうと、シングルユーザモードで起動することはできますが、FreeBSD の起動のプロセスに詳しくない人が起動できるようにするに難しいかも知れません。
====

[[consoles-vidcontrol]]
=== コンソールのビデオモードの変更

FreeBSD のデフォルトのビデオモードは 1024x768 や 1280x1024 など、グラフィックチップおよびディスプレイが対応しているサイズに調整されます。
別のビデオモードを使うには、`VESA` モジュールをロードしてください。

[.programlisting]
....
# kldload vesa
....

その後、ハードウェアが対応しているビデオモードを man:vidcontrol[1] を使って確認してください。
以下を実行すると、対応しているビデオモードを調べることができます。

[source,shell]
....
# vidcontrol -i mode
....

このコマンドは、使用しているハードウェアが対応しているビデオモードの一覧を表示します。
その後、man:vidcontrol[1] を `root` ユーザで実行して、新しく使用するビデオモードを選択してください。

[source,shell]
....
# vidcontrol MODE_279
....

このビデオモードで良ければ、起動時に自動的に設定されるように [.filename]#/etc/rc.conf# に以下のように追加してください。

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[permissions]]
== 許可属性

FreeBSD は BSD UNIX(R) の直系の子孫であり、 いくつかの鍵となる UNIX(R) 思想にもとづいています。
まず最も際だった特徴として最初に言えるのは、FreeBSD がマルチユーザのオペレーティングシステムだということです。FreeBSD は同時に働いている複数のユーザすべてを、 完全に分離したタスク上で処理する能力を持っています。
また FreeBSD は、ハードウェアデバイス、周辺装置、メモリ、CPU 時間等への要求を、各ユーザが平等に利用できるように適切に共有し、管理する役割を担っています。

ユーザアカウントについての詳細は、crossref:users[users-synopsis,「アカウント」] の章をご覧ください。
コンピュータを使用する各ユーザに対して、ユーザ名とパスワードが与えられている必要であることを理解しておいてください。
コンピュータを使用しているユーザの把握には、ユーザ名をベースに行われます。
同じプロジェクトのために作業をしている複数のユーザに対し、UNIX(R) はグループによる管理を提供しています。
複数のユーザは、同じグループに所属できます。

システムがマルチユーザをサポートしているため、システムが管理する資源はすべて、誰がその資源を読み・書き・実行できるかを支配する、一組の許可属性を持っています。
これらの許可属性は 3 つの部分からなる 3 桁の 8 進数の形で格納されています。
それはそのファイルの所有者 (owner) に対するもの、そのファイルが所属するグループ (group) に対するもの、 その他 (others) に対するものの 3 つです。
これを数字を使って表現すると、次のようになります。

[NOTE]
====
この節では、伝統的な UNIX(R) の許可属性について説明します。
より細かいファイルシステムのアクセス制御に関しては、crossref:security[fs-acl,“アクセス制御リスト”] をご覧ください。
====

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| 値
| 許可属性
| ディレクトリの表示

|0
|読み込み不可、書き込み不可、実行不可
|`---`

|1
|読み込み不可、書き込み不可、実行可能
|`--x`

|2
|読み込み不可、書き込み可能、実行不可
|`-w-`

|3
|読み込み不可、書き込み可能、実行可能
|`-wx`

|4
|読み込み可能、書き込み不可、実行不可
|`r--`

|5
|読み込み可能、書き込み不可、実行可能
|`r-x`

|6
|読み込み可能、書き込み可能、実行不可
|`rw-`

|7
|読み込み可能、書き込み可能、実行可能
|`rwx`
|===

man:ls[1] に対してコマンドライン引数 `-l` を使うと、詳細なディレクトリリストを見ることができ、ファイルの所有者、グループ、その他への許可属性を示す欄があるのがわかります。
例えば、`ls -l` を実行して、 適当なディレクトリを表示させると以下のようになります。

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...
....

一番目の列の最初の (一番左の) 文字は、そのファイルが普通のファイルなのか、ディレクトリなのか、キャラクタ型のデバイス特殊ファイルなのか、ソケットなのか、その他の特殊な疑似ファイルデバイスなのかといった種類を示す特別な文字です。
この例において、`-` という文字は、普通のファイルであることを示します。
その次に来る `rw-` と書かれた 3 文字は、そのファイルの所有者に許可を与えるものです。
その次の `r--` の 3 文字は、そのファイルが所属しているグループに許可を与えます。
最後の `r--` の 3 文字は、 システムに存在するその他のユーザに許可を与えます。
"-" は許可が与えられていないことを示します。
この例では、ファイルの所有者はこのファイルを読み書きでき、ファイルの所属しているグループに属するユーザはファイルを読むことだけでき、そのどちらでもないユーザは、 このファイルを読むだけできるように許可属性が与えられています。
上の表によれば、このファイルに与えられた許可属性は `644` となります。
ここで各数字は、このファイルの許可属性の 3 つの部分を表しています。

デバイスの場合の許可属性はどのようにコントロールされているのでしょうか?
FreeBSD は、大部分のハードウェアをファイルとして取り扱います。
そのため、プログラムからは普通のファイルとまったく同じようにオープンし、 データの読み書きができるようになっています。
これらのデバイス特殊ファイルは [.filename]#/dev/# に収められています。

ディレクトリもまた、ファイルと同様に扱われます。
それは読み込み/書き込み/実行の許可属性を持ちます。
ディレクトリの実行ビットはファイルのそれとは少し違った意味を持ちます。
ディレクトリが実行可能になっているとき、man:cd[1] を使ってそのディレクトリに移動することができます。 
これは、そのディレクトリにあるファイルにアクセスできることを意味しています (ファイル自体の許可属性によります)。

ディレクトリの中の一覧を表示するには、そのディレクトリに読み込み属性が設定されていなければなりません。
名前が分かっているファイルを削除するには、そのファイルが含まれているディレクトリに 書き込み属性 _と_ 実行属性 の両方が必要です。

この他にも許可属性ビットはありますが、いずれも setuid バイナリや sticky ディレクトリなどといった特殊な状況で使われます。
ファイルの許可属性そのものについて、また、それらの設定方法に関する詳しい情報は、 man:chmod[1] マニュアルページを参照してください。

=== シンボリック表記

シンボリック表記と呼ばれる許可属性を表す方法では、ファイルやディレクトリの許可属性を、8 進数ではなく記号を用いて設定します。
シンボリック表記による許可属性を表す方法では、(who), (action), (permissions) という書式が用いられます。
利用できる値は以下の通りです。

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| オプション
| 文字
| 意味

|(who)
|u
|ユーザ

|(who)
|g
|ファイルを所持しているグループ

|(who)
|o
|その他

|(who)
|a
|すべて ("world")

|(action)
|+
|許可属性を与える

|(action)
|-
|許可属性を取り除く

|(action)
|=
|許可属性を指定したものにする

|(permissions)
|r
|読み込み

|(permissions)
|w
|書き込み

|(permissions)
|x
|実行

|(permissions)
|t
|Sticky ビット

|(permissions)
|s
|UID または GID を設定する
|===

これらの値は、これまでと同様に man:chmod[1] で用いますが、数字ではなく文字で指定します。
たとえば、_FILE_ に対して自分以外のユーザからアクセスを一切受け付けたくない、というときには以下のコマンドを実行してください。

[source,shell]
....
% chmod go= FILE
....

カンマ区切りで設定することで、ファイルの属性を一度に 2 つ以上変更できます。
以下の例では、_FILE_ に対して自分以外のユーザから書き込みの権限を取り上げ、かわりにすべてのユーザが _FILE_ を実行できるようにします。

[source,shell]
....
% chmod go-w,a+x FILE
....

=== FreeBSD のファイルフラグ

ファイルの許可属性に加え、FreeBSD では "ファイルフラグ" を使えます。
これはファイルにセキュリティや管理上の属性を追加するものですが、ディレクトリには追加しません。
ファイルフラグにより、`root` ユーザでさえ誤ってファイルを消去、変更してしまうことを防ぐことができます。

ファイルフラグは、man:chflags[1] を使って、簡単なインタフェースで設定できます。
例えば、[.filename]#file1# というファイルにシステムレベルで消去不可のフラグを設定するには、以下のコマンドを実行してください。

[source,shell]
....
# chflags sunlink file1
....

消去不可のフラグを削除するには、以下のように `sunlink` の前に "no" をつけて実行してください。

[source,shell]
....
# chflags nosunlink file1
....

ファイルに設定されているフラグを確認するには、`-lo` と一緒に man:ls[1] を実行してください。

[source,shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

いくつかのファイルフラグの追加、削除は `root` ユーザしかできません。
他のフラグは、ファイルの所有者が変更できます。
man:chflags[1] と man:chflags[2] から、より詳細な情報を得ることをおすすめします。

=== `setuid`, `setgid` および `sticky` 許可属性

これまでに説明した許可属性のほかに、
すべての管理者が知っておくべき特別な設定が 3 つあります。
それは `setuid`, `setgid` および `sticky` 許可属性です。

これらの設定は、通常のユーザには許可されていない機能を提供するので、UNIX(R) の操作において重要となることがあります。
これらの許可属性を理解するためには、実ユーザ ID と実効ユーザ ID の違いに注意してください。

実ユーザ ID は、所有したりプロセスを開始する UID です。
実効 UID は、プロセスを実行するユーザ ID です。
たとえば、ユーザがパスワードを変更するときに利用する man:passwd[1] は、実ユーザ ID で起動します。
しかしながら、パスワードデータベースのアップデートの際は、実効 ID の `root` ユーザの権限で実行されます。
この仕組みにより、`Permission Denied` エラーが表示されることなく、ユーザはパスワードを変更できます。

setuid 許可属性は、以下の例で示されているように、指定する許可属性に数字の 4 をつけて設定します。

[source,shell]
....
# chmod 4755 suidexample.sh
....

これで [.filename]#suidexample.sh# の許可属性は以下のように設定されます。

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

`s` は、許可属性のファイル所有者の実行可能ビットに置き換わって反映されます。
この設定により、man:passwd[1] といったユーティリティが権限を昇格することができます。

[NOTE]
====
`nosuid` man:mount[8] オプションを使うと、このようなバイナリがユーザへの警告なしに権限を昇格できないように設定できます。
ただし `nosuid` ラッパにより回避できるため、このオプションを完全には信頼できません。
====

リアルタイムに確認するために、2 つのターミナルを開いてください。
1 つのターミナル上で、通常のユーザ権限で `passwd` と入力してください。
パスワードの入力を待つ間に、もう一つのターミナル上で、プロセステーブルおよび man:passwd[1] のユーザ情報を確認してください。

ターミナル A:

[source,shell]
....
Changing local password for trhodes
Old Password:
....

ターミナル B:

[source,shell]
....
# ps aux | grep passwd
....

[source,shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

通常のユーザ権限で man:passwd[1] を実行したにもかかわらず、実効 UID の `root` が使われています。

`setgid` 許可属性は `setuid` 許可属性と同様の機能を提供しますが、この許可属性はグループの設定を変更します。
この設定を行った上でアプリケーションまたはユーティリティを実行すると、プロセスを開始するユーザではなく、ファイルを所有するグループに対してこの許可属性を与えます。

ファイルに `setgid` 許可属性を設定するには、man:chmod[1] で設定する許可属性の先頭に 2 をつけて実行してください。

[source,shell]
....
# chmod 2755 sgidexample.sh
....

以下に示されるように、`s` がグループの許可属性に指定されています。

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
上記の例において、対象としているシェルスクリプトが実行可能なファイルであっても、シェルスクリプトは man:setuid[2] システムコールにアクセスできないため、実効ユーザ ID では実行されません。

====

`setuid` および `setgid` 許可属性ビットは、権限の昇格を許可するので、システムのセキュリティレベルを下げます。
一方 3 番目の特殊な許可属性 `sticky bit` は、システムのセキュリティを強化します。

ディレクトリに `sticky bit` を設定すると、ファイルの所有者のみがファイルを削除できるようになります。
[.filename]#/tmp# といった共有のディレクトリにおいて、ファイルの所有者以外のユーザがファイルを削除できなくなるので有用です、
この許可属性を有効にするには、許可属性に 1 をつけて設定してください。

[source,shell]
....
# chmod 1777 /tmp
....

`sticky bit` が設定されていると、許可属性の最後に `t` が表示されます。

[source,shell]
....
# ls -al / | grep tmp
....

[source,shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== ディレクトリ構造

FreeBSD のディレクトリ構造は、システム全体を理解するに当たって重要です。
最も重要なディレクトリは、ルートまたは "/" です。
このディレクトリは起動時に一番最初にマウントされ、オペレーティングシステムをマルチユーザで動作させるために必要なベースシステムが含まれています。
また、ルートディレクトリには、マルチユーザへの移行中に他のファイルシステムをマウントするためのマウントポイントも含まれます。

マウントポイントとは、追加するファイルシステムを接続する先の親のファイルシステム (普通はルートファイルシステム) のディレクトリのことです。
より詳細な説明は <<disk-organization>> の節にあります。
標準的なマウントポイントには [.filename]#/usr/#, [.filename]#/var/#, [.filename]#/tmp/#, [.filename]#/mnt/# および [.filename]#/cdrom/# があります。
通常これらのディレクトリについては、 [.filename]#/etc/fstab# というファイル中のエントリが参照されます。
このファイルは、さまざまなファイルシステムとマウントポイントの表であり、システムが参照します。
[.filename]#/etc/fstab# に書かれたファイルシステムは `noauto` オプションが指定されていなければ、起動時に man:rc[8] スクリプトによって自動的にマウントされます。
詳細は <<disks-fstab>> の節をご覧ください。

ファイルシステム構造を網羅した説明は man:hier[7] に書かれています。
以下の表は、もっともよく使われるディレクトリの簡単な概要です。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| ディレクトリ
| 説明

|[.filename]#/#
|ファイルシステムのルートディレクトリ

|[.filename]#/bin/#
|シングルユーザ環境とマルチユーザ環境の両方で重要な ユーザユーティリティ

|[.filename]#/boot/#
|オペレーティングシステムの起動時に使われるプログラムと設定ファイル

|[.filename]#/boot/defaults/#
|デフォルトの起動設定ファイル; man:loader.conf[5] 参照

|[.filename]#/dev/#
|デバイスノード; man:intro[4] 参照

|[.filename]#/etc/#
|システム設定ファイルとスクリプト

|[.filename]#/etc/defaults/#
|デフォルトのシステム設定ファイル; 詳細については man:rc[8] 参照

|[.filename]#/etc/mail/#
|man:sendmail[8] のようなメール転送エージェントの設定ファイル

|[.filename]#/etc/namedb/#
|`named` 設定ファイル;  詳細な説明は man:named[8] 参照

|[.filename]#/etc/periodic/#
|man:cron[8] 経由で毎日・毎週・毎月実行されるスクリプト; 詳細については man:periodic[8] 参照

|[.filename]#/etc/ppp/#
|man:ppp[8] の設定ファイル

|[.filename]#/mnt/#
|システム管理者が一時的なマウントポイントとしてよく使う空のディレクトリ

|[.filename]#/proc/#
|プロセスファイルシステム; 詳細については man:procfs[5] と man:mount_procfs[8] 参照

|[.filename]#/rescue/#
|man:rescue[8] で説明されている緊急時のために静的にリンクされているプログラム

|[.filename]#/root/#
|`root` アカウントのホームディレクトリ

|[.filename]#/sbin/#
|シングルユーザ環境とマルチユーザ環境の両方で重要なシステムプログラムと管理ユーティリティ

|[.filename]#/tmp/#
|システムの再起動では通常保存 _されない_ 一時的なファイル。
メモリファイルシステムはよく [.filename]#/tmp# にマウントされます。
これは man:rc.conf[5] の tmpmfs 関係の変数を使うか、 [.filename]#/etc/fstab# に設定項目を記入することで自動化できます。
詳しくは man:mdmfs[8] を参照して下さい。

|[.filename]#/usr/#
|大部分のユーザユーティリティとアプリケーション

|[.filename]#/usr/bin/#
|よく使うユーティリティとプログラミングツールとアプリケーション

|[.filename]#/usr/include/#
|C の標準ヘッダファイル

|[.filename]#/usr/lib/#
|ライブラリ

|[.filename]#/usr/libdata/#
|いろいろなユーティリティのデータファイル

|[.filename]#/usr/libexec/#
|他のプログラムから実行されるシステムデーモンとシステムユーティリティ

|[.filename]#/usr/local/#
|ローカルのプログラムやライブラリなど。
FreeBSD ports フレームワークのデフォルトインストール先としても使われます。
[.filename]#/usr/local# 内では、 man:hier[7] に書かれている [.filename]#/usr# のための一般構造が使われます。
例外は man ディレクトリで、 [.filename]#/usr/local/share# の下ではなく [.filename]#/usr/local# の下に直接置かれ、ports 関係文書は [.filename]#share/doc/port# に置かれます。

|[.filename]#/usr/obj/#
|[.filename]#/usr/src# ツリーのビルドで作られるアーキテクチャ依存のターゲットツリー

|[.filename]#/usr/ports/#
|FreeBSD Ports Collection (オプション)。

|[.filename]#/usr/sbin/#
|ユーザにより実行されるシステムデーモンおよびシステムユーティリティ

|[.filename]#/usr/shared/#
|アーキテクチャに依存しないファイル

|[.filename]#/usr/src/#
|BSD のソースファイルまたはローカルのソースファイル、あるいは両方

|[.filename]#/var/#
|さまざまな用途のログ・一時的なファイル・スプールファイル。メモリファイルシステムは時々 [.filename]#/var# にマウントされます。 これは man:rc.conf[5] の varmfs 関係の変数を使うか、 [.filename]#/etc/fstab# に設定項目を記入することで自動化できます。 詳しくは man:mdmfs[8] を参照して下さい。

|[.filename]#/var/log/#
|いろいろなシステムログファイル

|[.filename]#/var/mail/#
|ユーザのメールボックスファイル

|[.filename]#/var/spool/#
|プリンタとメールシステムのスプールディレクトリなどなど

|[.filename]#/var/tmp/#
|一時的なファイル。 [.filename]#/var# がメモリファイルシステムでなければ、 ここにあるファイルはシステムが再起動しても失われません。

|[.filename]#/var/yp/#
|NIS のマップ
|===

[[disk-organization]]
== ディスク構成

ファイルを見つけるために FreeBSD が使用する構成の一番小さな単位はファイル名です。
ファイル名は、大文字と小文字を区別します。
このことは [.filename]#readme.txt# および [.filename]#README.TXT# が異なる二つのファイルであることを意味します。
FreeBSD はそのファイルがプログラム、または文書、あるいはその他の形式かどうかを決定するために拡張子を使用しません。

ファイルはディレクトリ内に格納されます。
ディレクトリはファイルを一つも含んでいないかもしれせんし、または数百のファイルを含んでいるかもしれません。
ディレクトリはまた別のディレクトリを含むことができるので、
データを体系づけるディレクトリの階層構造を構築できます。

ファイルおよびディレクトリは、必要な他のディレクトリ名とスラッシュ (`/`) を後に続けてファイル名またはディレクトリ名を与えることによって参照されます。
たとえば、[.filename]#foo# ディレクトリがあって、その中に [.filename]#bar# ディレクトリがあるとします。
そして、その中に [.filename]#readme.txt# があるとすると、ファイルへのフルネーム、または _パス_ は [.filename]#foo/bar/readme.txt# となります。
ファイルとディレクトリ名を分けるために `\` を使う Windows(R) とは違うことに注意してください。
FreeBSD は、パスの中にドライブレターまたは他のドライブ名を使いません。
たとえば、FreeBSD では [.filename]#c:\foo\bar\readme.txt# とは書きません。

ディレクトリおよびファイルはファイルシステム内に格納されます。
どのファイルシステムも、そのファイルシステムのための _ルートディレクトリ_ とよばれる、まさに頂点の位置にちょうど一つのディレクトリを含んでいます。
このルートディレクトリは他のディレクトリを含むことができます。
一つのファイルシステムは _ルートファイルシステム_ または `/` として設計されています。
すべてのファイルシステムは、ルートファイルシステム以下に _マウント_ されます。
FreeBSD システムでどんなに多くのディスクを使用しても、すべてのディレクトリは、同じディスクの一部であるように見えるので問題ありません。

`A`, `B` および `C` と呼ばれる三つのファイルシステムがあるケースを考えます。
それぞれのファイルファイルシステムには一つのルートディレクトリがあり、`A1`, `A2` と呼ばれている二つの他のディレクトリを含んでいます (同様に `B1`, `B2` および `C1`, `C2` があります)。

`A` をルートファイルシステムとします。
このディレクトリになにが含まれているか見るために man:ls[1] コマンドを使うと、`A1` および `A2` の二つのサブディレクトリが表示されるでしょう。
ディレクトリツリーは以下のようになります。

image::example-dir1.png[]

ファイルシステムはマウント先のファイルシステム内のディレクトリにマウントしなければいけません。
それでは、`A1` ディレクトリに `B` ファイルシステムをマウントすると仮定します。
`B` のルートディレクトリは `A1` に置き換えられ、そして `B` 内のディレクトリがそれに応じて現れます。

image::example-dir2.png[]

`B1` または `B2` 内にあるどんなファイルも、必要なときに [.filename]#/A1/B1# または [.filename]#/A1/B2# で到達できます。
[.filename]#/A1# にあったすべてのファイルは一時的に隠されました。
それらは `B` が `A` から _アンマウント_ されたら再び現れるでしょう。

もし `B` が `A2` にマウントされていたら、この図のようになります。

image::example-dir3.png[]

そして、パスはそれぞれ [.filename]#/A2/B1# および [.filename]#/A2/B2# となるでしょう。

ファイルシステムは互いのファイルシステム上にもマウントできます。
上記の最後の例に続けて、`C` ファイルシステム は `B` ファイルシステム内の `B1` ディレクトリ上にマウントできます。
次の図のようになります。

image::example-dir4.png[]

または `C` を `A` ファイルシステムの `A1` ディレクトリの下に直接マウントできます。

image::example-dir5.png[]

一つの大きなルートファイルシステムを用意し、他のファイルシステムを作成する必要としないことはまったくもって可能です。
この方法にはいくつかの短所と一つの利点があります。

.マルチファイルシステムの利点
* 異なったファイルシステムは異なった _マウントオプション_ を使用できます。
たとえば、ルートファイルシステムを読みだし専用でマウントして、不注意によってユーザが重大なファイルを削除、または編集できないようにすることができます。
また、[.filename]#/home# のようなユーザが書き込み可能なファイルシステムを他のファイルシステムと分けることによって、 _nosuid_ でマウントすることが可能になります。
このオプションは、ファイルシステムに記録されている _suid_/_guid_ の実行可能ビットを有効にしないので、安全性を高めることができるでしょう。
* FreeBSD はファイルシステムがどのように使われているかによって、自動的にファイルシステム上のファイルの配置を最適化します。 したがって、連続的に書き込まれた多くの小さなファイルが含まれているファイルシステムは、より大きく少ないファイルが含まれているファイルシステムと異なる最適化をするでしょう。 一つの大きなファイルシステムを作成すると、この最適化は成り立たなくなります。
* FreeBSD のファイルシステムはトラブルが起きても強固です。 しかしながら臨界点でのトラブルは、ファイルシステムの構造にまだ損害を与えるかもしれません。 マルチファイルシステムへデータを分割しておくことで、 必要なときにバックアップからレストアすることをより容易にして、まだシステムが回復するかもしれません。

.シングルファイルシステムの利点
* ファイルシステムは固定サイズです。 FreeBSD をインストールするときにファイルシステムを作成して、 固定サイズを割りあてたなら、 後になってそのパーティションをより大きくする必要があると気づくかもしれません。 パーティションのサイズを変更するには、 バックアップ、新しいサイズを指定したファイルシステムの再作成、 バックアップしたデータをリストアする作業が必要となるでしょう。
+
[IMPORTANT]
====
FreeBSD には、 man:growfs[8] コマンドがあります。 このコマンドは、この制限を取り除いて、 ファイルシステムのファイルを直ちに増加させることを可能にします。 
====

ファイルシステムはパーティション内に含まれています。 FreeBSD の UNIX(R) 遺産のために、 これは普段使われるパーティション (例えば MS-DOS(R) パーティション) という用語の意味とは違う意味を持っています。 それぞれのパーティションは `a` から `h` までの文字で区別されます。 それぞれのパーティションは、 一つのファイルシステムだけを含むことができます。 このことは、ファイルシステムがファイルシステムの階層上の典型的なマウントポイント、 または含まれているパーティションの文字によって記述されることを意味します。

FreeBSD は _スワップ領域_ にもまたディスク領域を使用します。
スワップ領域は FreeBSD に _仮想メモリ_ を提供します。
これはあなたのコンピュータが、 実際に搭載している以上のメモリがあるかのように振舞います。
FreeBSD がメモリを使い果たしたときに、現在使用されていないデータのいくつかをスワップ領域に移動し、そのデータが必要となったときに (その他のデータをスワップ領域に移動させてから) メモリ内に移動しなおします。

いくつかのパーティションはある慣習と関係づけられています。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| パーティション
| 慣習

|`a`
|通常、ルートパーティションを含みます。

|`b`
|通常、スワップ領域を含みます。

|`c`
|通常、スライス全体と同じサイズです。
これは、スライス全体にアクセス必要のあるユーティリティ (たとえば、ひどいブロックスキャナ) が、 `c` パーティションにアクセスすることを可能にします。
通常、このパーティション内にファイルシステムは作成されません。

|`d`
|`d` パーティションは、 それに関連づけられた特別な意味を持っていましたが、 今は無いので、普通のパーティションとして動作するでしょう。
|===

FreeBSD のディスクはスライスに分けられます。
Windows(R) ではパーティションと呼ばれるもので、
スライスには 1 から 4 までの番号がつけられます。
スライスは、ファイルシステムを含むパーティションに分けられます。
パーティションは文字で表されます。

スライス番号は 1 から始まり `s` を前につけられて、デバイス名の後に続きます。
したがって、"da0__s1__" は一番目の SCSI ドライブ上の 一番目のスライスです。
ディスク上に存在できる物理スライスは、4 つまでですが、適切な種類の物理スライス内に論理スライスを作成できます。
これらの拡張されたスライス番号は 5 から始まります。
したがって、 "ad0__s5__" は、一番目の IDE ディスク上の一番目の拡張スライスです。
これらのデバイスは、 スライスを占有することを予期するファイルシステムによって使用されます。

スライスや "危険な専用" の物理ドライブ、 そして他のドライブは `a` から `h` までの文字として表される _パーティション_ を含んでいます。
この文字はデバイス名に追加されます。
したがって、 "da0__a__" は一番目の "危険な専用" `da` ドライブ上の `a` パーティションです。
"ad1s3__e__" は、 二番目の IDE ディスク上の 三番目のスライス内にある五番目のパーティションです。

最後に、システム上のそれぞれのディスクは識別されます。
ディスク名はどの種類のディスクであるかを示す記号ではじまり、どのディスクかを示す数字が続きます。
スライスとは違いディスクの番号づけは 0 から始まります。
共通の記号は <<basics-dev-codes>> に示されます。

パーティションを参照するときには、 ディスク名、`s`、スライス番号、 そしてパーティション文字を含めてください。
<<basics-disk-slice-part>> に例があります。

<<basics-concept-disk-model>> は、ディスク構成の概念のモデルを示します。

FreeBSD をインストールする際には、ディスクスライスの設定し、次に FreeBSD に用いるスライス内のパーティションを作成し、それからそれぞれのパーティション内にファイルシステムまたはスワップ領域を作成し、 ファイルシステムがどこにマウントされるか決定しなければいけません。

[[basics-dev-codes]]
.ディスクデバイス記号
[cols="1,1", frame="none", options="header"]
|===
| 記号
| 意味

|[.filename]#ad#
|ATAPI (IDE) ディスク

|[.filename]#da#
|SCSI ダイレクトアクセスディスク

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|フロッピーディスク
|===

[[basics-disk-slice-part]]
.ディスク名、スライス名、パーティション名のサンプル
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 名前
| 意味

|`ad0s1a`
|一番目の IDE ディスク (`ad0`) 上の一番目のスライス (`s1`) 内の一番目のパーティション (`a`)。

|`da1s2e`
|二番目の SCSI ディスク (`da1`) 上の二番目のスライス (`s2`) 内の五番目のパーティション (`e`)。
|===
====

[[basics-concept-disk-model]]
.ディスクの概念的構成
[example]
====
これはシステムに接続された一番目の IDE ディスクの FreeBSD から見た図を示します。 ディスクサイズは 4 GB と仮定し、 2 GB のスライス (MS-DOS(R) でいうパーティション) が二つあるとします。 一番目のスライスは MS-DOS(R) ディスクの [.filename]#C:# を含んでいます。 そして、二番目のスライスは FreeBSD のディスクを含んでいます。 これは FreeBSD インストーラが三つのデータパーティションと一つのスワップパーティションを作成した例です。

三つのパーティションはそれぞれファイルシステムを含んでいます。 `a` パーティションはルートファイルシステムに使用され、 `e` パーティションは [.filename]#/var# ディレクトリ階層に、 `f` パーティションは [.filename]#/usr# ディレクトリ階層に使用されるでしょう。

image::disk-layout.png[]

====

[[mount-unmount]]
== ファイルシステムのマウントとアンマウント

ファイルシステムは [.filename]#/# をルート (根) とする木構造として考えると視覚的に理解しやすいでしょう。
ルートディレクトリにある [.filename]#/dev# や [.filename]#/usr#、その他のディレクトリは枝に相当し、それらには、[.filename]#/usr/local# などのように、さらに枝分かれすることができます。

さまざまな理由がありますが、 ディレクトリをいくつかの異なるファイルシステム上に構築するのが良いでしょう。
たとえば [.filename]#/var# には、 [.filename]#log/# や [.filename]#spool/# など、さまざまな種類の一時ファイルを置くディレクトリがあるため、あふれてしまう可能性があります。
ルートファイルシステムをあふれさせるのは得策ではありませんので、普通は [.filename]#/var# を [.filename]#/# から分離します。

また、次のような場合も、ディレクトリツリーを別のファイルシステムに置く理由として良くあげられます。
それは、たとえば物理的に別のディスクにディレクトリツリーを置く場合、 crossref:advanced-networking[network-nfs, 「ネットワークファイルシステム (NFS)」] で説明されているようにネットワークファイルシステムをマウントしたり、CDROM ドライブのような別の仮想ディスクに置くという場合です。

[[disks-fstab]]
=== [.filename]#fstab# ファイル

[.filename]#/etc/fstab# に書かれているファイルシステムは、`noauto` オプション指定されているエントリを除いて crossref:boot[boot,起動プロセス] の途中で自動的にマウントされます。
このファイルは、 次のような書式で書かれたエントリを含んでいます。

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
デバイス名。crossref:disks[disks-naming,「デバイス名」] に説明があります。

`mount-point`::
ファイルシステムがマウントするディレクトリ。

`fstype`::
man:mount[8] に渡されるファイルシステムタイプ。 FreeBSD ファイルシステムのデフォルトは `ufs` です。

`options`::
読み書きするファイルシステムには `rw`、読み込み専用のファイルシステムには `ro` を、必要な他のオプションの前に指定します。 よく使われるオプションは `noauto` で、 起動時にはマウントされないファイルシステムに使います。 その他のオプションは man:mount[8] マニュアルページに載っています。

`dumpfreq`::
これは man:dump[8] が使うもので、 どのファイルシステムにダンプが必要なのかを決めます。 この項目がなければ、0 であるものとみなされます。

`passno`::
これはファイルシステムをチェックする順番を決めます。
ファイルシステムチェックを飛ばしたいファイルシステムには、`passno` を 0 に設定してください。 ルートファイルシステムはどれよりも先にチェックする必要があり、`passno` は 1 に設定してください。 他のファイルシステムの `passno` は 1 以上に設定してください。 同じ `passno` のファイルシステムがあった場合、 man:fsck[8] は可能であれば並行してファイルシステムのチェック を行なおうとします。

[.filename]#/etc/fstab# の書式やオプションに関しての詳細は、 man:fstab[5] をご覧ください。

[[disks-mount]]
=== man:mount[8] の使い方

ファイルシステムは man:mount[8] を用いてマウントされます。
基本な構文は以下のようになります。

[source,shell]
....
# mount device mountpoint
....

man:mount[8] で説明されているように、このコマンドはたくさんのオプションを提供しますが、最もよく使われるのは次のものです。

.マウントオプション
`-a`::
[.filename]#/etc/fstab# にある全てのファイルシステムをマウントします。 例外は "noauto" の印がついているものと、 `-t` フラグで除外されたものと、 すでにマウントされているファイルシステムです。

`-d`::
実際にマウントシステムコールする以外のすべてのことをします。 このオプションは `-v` フラグと組み合わせて使い、 man:mount[8] が実際なにをしようとしているのか調べるのに便利です。

`-f`::
クリーンでないファイルシステムを強制的にマウントします (危険です)。もしくは、ファイルシステムのマウント状態を 読み書き可能から読み込みのみに変更するとき、 書き込みアクセスを強制的に取り消します。

`-r`::
ファイルシステムを読み込み専用でマウントします。
`-o ro` を使うのと同じです。

`-t` _fstype_::
指定のファイルシステムタイプでマウントします。 または、`-a` を使った場合、 指定したタイプのファイルシステムのみマウントします。
デフォルトのファイルシステムタイプは "ufs" です。

`-u`::
ファイルシステムのマウントオプションを更新します。

`-v`::
詳細な出力にします。

`-w`::
ファイルシステムを読み書き可能にマウントします。

`-o` には、 次のようなオプションを複数カンマで区切って指定できます。

nosuid::
そのファイルシステム上の setuid や setgid フラグを解釈しません。 これもセキュリティのために有用なオプションです。

[[disks-umount]]
=== man:umount[8] の使い方

ファイルシステムをアンマウントするには、man:umount[8] を使ってください。
このコマンドは、パラメータとしてマウントポイントの一つ、 デバイス名、もしくは `-a` や `-A` といったオプションを取ります。

いずれの形式でも `-f` で強制的なアンマウントを行ない、 `-v` で詳細な出力を出します。
ただしほとんどの場合、`-f` は使わないほうがよいでしょう。
計算機がクラッシュしたりファイルシステム上部のデータが破壊されたりする恐れがあります。


マウントされているファイルシステムすべてをアンマウントするには、`-a` と `-A` を使ってください。
`-t` にファイルシステムタイプを指定すると、指定されたものだけがアンマウントされます。
`-A` を使うとルートファイルシステムはアンマウントしません。

[[basics-processes]]
== プロセス

FreeBSD はマルチタスクのオペレーティングシステムです。
動作中のプログラムはそれぞれ _プロセス_ と呼ばれます。
すべてのコマンドは実行すると、最低でも 1 つの新しいプロセスを開始します。
FreeBSD により実行されているシステムプロセスもたくさんあります。

各プロセスは _プロセス ID_ (PID) と呼ばれる数字でただ一つに識別されます。
ファイルのように各プロセスには所有者とグループがあり、
所有者とグループの許可属性は、そのプロセスが開けるファイルやデバイスを決定するために使われます。
多くのプロセスには親プロセスもあります。
親プロセスとは、そのプロセスをスタートさせたプロセスのことです。
例えば、シェルがプロセスで、シェルから起動されるコマンドは、シェルを親プロセスとするプロセスとなります。
例外は man:init[8] という特別なプロセスです。
`init` は FreeBSD がスタートするときに起動される最初のプロセスで、PID は常に 1 です。

システム上のプロセスを確認するには、man:ps[1] および man:top[1] を使ってください。
現在動作中のプロセスのリスト、プロセスの PID やプロセスが使っているメモリの量、どういうコマンドラインで起動されたのかなどを表示させるには、man:ps[1] を使ってください。
man:top[1] を使用すると、動作中の全てのプロセスを表示できます。
数秒ごとに表示を更新するので、計算機が何をしているのかインタラクティブに知ることができます。

デフォルトでは、man:ps[1] はユーザにより動作中かつ所有のコマンドのみを表示します。
例えば:

[source,shell]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

man:ps[1] の出力はいくつかの列に整形されています。
`PID` の列はプロセス ID を表示します。
PID は 1 から順に 99999 まで割り当てられ、その後足りなくなると最初に戻って使い回されます。ただし、使用中の PID には割り当てられません。
`TT` の列はプログラムが動いている tty を示し、`STAT` はプログラムの状態を示します。
`TIME` はプログラムがその CPU 上で動いている時間の長さです。
通常はプログラムをスタートさせたときからの経過時間ではありません。
多くのプログラムは、CPU 上で時間を使う必要があるまでかなりの時間を費すためです。
最後に、`COMMAND` はそのプログラムを起動するのに使われたコマンドとなります。

man:ps[1] は表示する情報を変えるためのオプションをたくさんサポートしています。 
いちばん便利なのは `auxww` でしょう。
`a` はすべてのユーザの動作中のプロセス全部についての情報を表示します。
`u` はプロセスの所有者の名前をメモリ使用量と同様に表示します。
`x` はデーモンプロセスについての情報を表示し、`ww` で、スクリーンに入りきらないほど長くなったコマンドラインでも省略せず、man:ps[1] に各プロセスの全コマンドラインを表示させます。

man:top[1] の出力も同様です。 例は以下の通りです。

[source,shell]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

出力は2つのセクションに分かれています。
ヘッダ (最初の 5 行です) は動作している最新のプロセスの PID、システムの平均負荷 (システムがどれくらい忙しいかの指標)、システムの稼働時間 (最後の再起動からの時間) と現在の時刻を示します。
ヘッダの中の他の数字は動作中のプロセスの数 (この場合 47 ですね)、使われているメモリとスワップ領域の量、そしてシステムが異なる CPU 状態に消費した時間と関係します。

ヘッダの下には、PID、ユーザ名、消費 CPU 時間とプロセスを起動したコマンドといった man:ps[1] の出力と同じような情報を持った行が続きます。
man:top[1] を使うとデフォルトでプロセスが使っているメモリ容量を表示します。
メモリ使用量の欄は 2 項目に分かれており、 一方は合計使用量、 そしてもう一方は実使用量です。
合計使用量はアプリケーションが必要としているメモリ量で、実使用量はその時点で実際に使われているメモリ量です。
この例では、mutt がだいたい 8 MB の RAM を必要としていますが、 いまのところ 5 MB しか使っていないことが分かります。

man:top[1] は自動的に 2 秒ごとに画面を更新します。
`-s` 使うと更新間隔を変更することができます。

[[basics-daemons]]
== デーモン、シグナルとプロセス終了

エディタを使っている場合、エディタを操作してファイルを開くのは簡単です。
このように操作できるのは、エディタにそういった機能があり、 かつエディタが _端末_ に関連づけられているからです。
一方、ユーザから始終入力があるように設計されていないプログラムもあり、そういったプログラムは最初から端末と切り離されます。
例えば、ウェブサーバはユーザからの入力ではなくウェブのリクエストを処理します。
メールサーバも、 こういった種類のアプリケーションの一例です。

このようなプログラムは、 _デーモン_ と呼ばれます。
デーモンはギリシャ神話から来ており、目に見えないように役立つことをしてくれる善でも悪でもない実体を表します。
このため、BSD のマスコットはスニーカーをはいてフォークを携えたかわいらしい姿のデーモンなのです。

通常デーモンとして動作するプログラムには末尾に "d" を持った名前をつける慣習があります。
BIND は Berkeley Internet Name Domain ですが、 実際実行されるプログラムは man:named[8] です。
また、Apache ウェブサーバのプログラムは `httpd`、 ラインプリンタスプーリングデーモンは man:lpd[8] です。
これは単なる命名に関する慣習です。
例えば、Sendmail アプリケーションの主なメールデーモンは man:sendmail[8] で、`maild` ではありません。

デーモンや動作中のプロセスと通信する一つの方法は、man:kill[1] を用いて _シグナル_ を送信する方法です。
送信可能なシグナルはたくさんあります。
特別な意味があるものもあれば、アプリケーションの文章に説明されているものもあります。
ユーザは自分が所有者となっているプロセスにのみシグナルを送ることができます。
他人のプロセスにシグナルを送ると、permission denied というエラーになるでしょう。
この例外は `root` ユーザで、 ルートユーザは誰のプロセスに対してもシグナルを送ることができます。

FreeBSD もプロセスにシグナルを送ることができます。
アプリケーションを下手に書いてしまい、予想外のメモリにアクセスしようとすると、FreeBSD はプロセスに _セグメンテーション違反_ シグナル (`SIGSEGV`) を送ります。
ある程度の時間が経ったら man:alarm[3] システムコールを使って警告してもらうようなアプリケーションには、警告シグナル (`SIGALRM`) が送信されます。

プロセスを止めるためには2つのシグナル、`SIGTERM` か `SIGKILL` を使います。
`SIGTERM` は穏かにプロセスを終了させる方法です。
プロセスはシグナルを受け取ることができ、開いているすべてのログファイルを閉じ、終了前にしていたことを終えるように試みることができます。
中断できない処理の途中だと、`SIGTERM` をプロセスが無視することもあるかもしれません。

プロセスは `SIGKILL` を無視することができません。
これは、"なにをしていようが構わないから今すぐ止まれ" というシグナルです。
プロセスに `SIGKILL` を送ると、プロセスは通常その時点で止まります。

他に良く使われるシグナルには、`SIGHUP`、`SIGUSR1` と `SIGUSR2` があります。
これらは一般的な用途のシグナルで、このシグナルが送信されたときの応答は、アプリケーション毎に異なります。

例として、ウェブサーバの設定ファイルを変更後、ウェブサーバに設定を再読み込みさせる必要があります。
`httpd` を再起動するとウェブサーバは一瞬ながら停止してしまいます。
その代わりに `SIGHUP` シグナルを送りましょう。
デーモンごとに行動が違うので、`SIGHUP` が期待する結果となるように、そのデーモンの文書を読んで確認してください。

[.procedure]
====
*Procedure: プロセスにシグナルを送る*

この例では、man:inetd[8] にシグナルを送る方法を示します。
man:inetd[8] の設定ファイルは [.filename]#/etc/inetd.conf# で、man:inetd[8] は `SIGHUP` が送信されるとこの設定ファイルを再読み込みします。

. man:pgrep[1] を使ってシグナルを送りたいプロセスの PID を調べます。
この例では man:inetd[8] の PID は 198 です。
+
[source,shell]
....
% pgrep -l inetd
198  inetd
....
+ 
. man:kill[1] を使ってシグナルを送ります。 man:inetd[8] は `root` が所有しているため、まず man:su[1] を使って `root` になってください。
+
[source,shell]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
大部分の UNIX(R) コマンドと同じく、 成功したら man:kill[1] は何の出力も表示しません。
ユーザが所有していないプロセスにシグナルを送ると、`kill: _PID_: Operation not permitted` といったメッセージが表示されます。
PID を打ち間違えると、間違ったプロセスにシグナルを送ってしまい悪い結果になってしまったり、その時点で使われていない PID にシグナルを送ったことになり、`kill: _PID_: No such process` とエラーが表示されます。

[NOTE]
.なぜ `/bin/kill` を使うんでしょう?
======
多くのシェルは `kill` を組み込みコマンドとして備えています。
つまり、[.filename]#/bin/kill# を実行するのではなく、シェルが直接シグナルを送ります。
シェルが違うと送るシグナルの名前の指定の仕方が違うことに注意してください。
シェルによって異なるシグナルの指定の仕方を全部覚えようとはせずに、 `/bin/kill ...` コマンドを直接使うほうが簡単です。
======
====

他のシグナルを送る場合は、コマンドラインの `TERM` や `KILL` を必要に応じて置き換えてください。

[IMPORTANT]
====
システム上のランダムプロセスを終了させるのはよくありません。
特に、PID が 1 の man:init[8] は特別です。
`/bin/kill -s KILL 1` は推奨されていませんが、実行するといとも簡単にシステムをシャットダウンさせることができます。
kbd:[Return] を押す _前_ に man:kill[1] を実行する引数を二重にチェックする _癖_ をつけてください。
====

[[shells]]
== シェル

FreeBSD は「シェル」と呼ばれるコマンドラインインタフェースを提供します。
シェルは入力チャンネルからコマンドを受け取り、それらを実行します。
大部分のシェルは、日々の作業、ファイル管理やファイル名の展開、コマンドライン編集、コマンドマクロ、環境変数といった組み込みの機能を持ってます。
FreeBSD には Bourne Shell (man:sh[1]) や 高機能 C-shell (man:tcsh[1]) が含まれています。
また、これ以外にも `zsh` や `bash` などのシェルが FreeBSD Ports Collection から利用可能です。

どのシェルを使うかは、まったく趣味の問題です。
あなたが C のプログラマだったとすれば、man:tcsh[1] のような C 風のシェルの方が落ち着くかもしれません。
Linux(R) ユーザであれば、`bash` を好まれるでしょう。
それぞれのシェルは、 ユーザの好みの作業環境で利用できる (もしくはできない) 独自の機能を持っているということ、そして、どのシェルを使うことにするかを決めるのはyユーザ自身ということです。

シェルの一般的な機能の一つに、ファイル名の補完があります。
コマンドやファイル名の最初の数文字を入力し、kbd:[Tab] を押すことで、シェルにコマンドやファイル名の残りの部分を自動的に補完させることができます。
例として、二つのファイル [.filename]#foobar#, [.filename]#foo.bar# が あったとします。
ここで [.filename]#foo.bar# の方を削除するには、 `rm fo[Tab].[Tab]` と入力します。

するとシェルは `rm foo[BEEP].bar` と出力するでしょう。

[BEEP] のところはコンソールのベル (訳注: 通常はビープ音が鳴ります) です。
複数のファイルがマッチしたため、ファイル名の補完を完全に行なえなかったことをしています。
[.filename]#foobar# と [.filename]#foo.bar# は両方とも `fo` ではじまります。
`.` を入力して kbd:[Tab] を押すと、 シェルはファイル名の残りの部分を補完できます。

もう一つあげられるシェルの特徴として、環境変数があります。
環境変数とは、シェルの環境変数におけるキーと値とのペアです。
この環境変数は、そのシェルから起動されたプログラムから参照でき、それを利用してプログラムの設定を保存するのに利用されます。
以下は、一般的な環境変数とその意味の一覧です。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 変数名
| 意味

|`USER`
|現在のログインユーザのユーザ名。

|`PATH`
|コロンで区切られた実行ファイル探索のための ディレクトリのリスト。

|`DISPLAY`
|接続する Xorg ディスプレイのネットワーク名 (存在する場合のみ)。

|`SHELL`
|現在のシェル。

|`TERM`
|ユーザの端末種名。 端末のケーパビリティを決定するのに使われる。

|`TERMCAP`
|種々の端末の機能を実現する端末のエスケープコードの データベースのエントリ。

|`OSTYPE`
|オペレーティングシステムの種別。

|`MACHTYPE`
|システムの CPU アーキテクチャ。

|`EDITOR`
|ユーザの選んだテキストエディタ。

|`PAGER`
|ユーザの選んだテキストページャ。

|`MANPATH`
|コロンで区切られたマニュアルページ探索のための ディレクトリのリスト。
|===

環境変数を設定する方法は、シェルごとに多少異なります。
man:tcsh[1] や man:csh[1] では `setenv` を使います。
man:sh[1] や `bash` 等の Bourne シェルでは、`export` を使って現在の環境変数を設定します。
以下の例では、`tcsh` シェルでデフォルトの `EDITOR` を [.filename]#/usr/local/bin/emacs# に設定します。

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

`bash` では次のようになります。

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

現在の設定を確認するために、コマンドライン中の変数名の前に `$` 文字を置くことで、環境変数を展開させることができます。
たとえば、`echo $TERM` は `$TERM` が セットされている内容を表示します。

シェルは特殊文字を、特別なデータを表すものとして扱います。
その特殊文字はメタキャラクタと呼ばれます。
もっとも一般的なメタキャラクタは `\*` で、これはファイル名に含まれる、あらゆる文字を表します。
メタキャラクタはファイル名の展開に使われます。
たとえば、`echo *` と入力すると man:ls[1] と入力したのとほとんど同じ結果を得られます。
これはシェルが `*` とマッチするすべてのファイルを受け取って man:echo[1] はコマンドラインでそれらを表示するからです。

特殊文字をシェルに解釈させないようにするため、特殊文字の前にバックスラッシュ文字 (`\`) を置いてエスケープしてください。
例えば `echo $TERM` は端末の設定を表示し、`echo \$TERM` は `$TERM` とそのまま表示します。

[[changing-shells]]
=== シェルの変更

デフォルトのシェルを変更する一番簡単な方法は `chsh` を使うことです。
このコマンドを実行すると、環境変数 `EDITOR` で示されたエディタ (デフォルトでは man:vi[1] が設定されている) が立ち上がります。
"Shell:" の行を変更するシェルの絶対パスに変更してください。

代わりに `chsh -s` を使うと、エディタを起動せずにシェルを変更できます。
たとえば、シェルを `bash` に変えたいなら、次のようにしてください。 

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
使おうと思っているシェルは__必ず__[.filename]##/etc/shells## 中に書かれていなければなりません。
シェルを crossref:ports[ports,アプリケーションのインストール - packages と ports] で説明されている FreeBSD の Ports Collection からインストールしたのであれば、自動的にこのファイルに追加されています。
もし書かれていなければ、以下のコマンドで、パスをシェルのパスに置き換えて使って追加してください。

[source,shell]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

そして man:chsh[1] を実行してください。
====

[[editors]]
== テキストエディタ

多くの FreeBSD の設定は、テキストファイルを編集することで行われます。
そのため、テキストエディタの扱いに慣れると良いでしょう。
FreeBSD には、基本システムの一部として二、三提供されるものと、Ports Collection から利用できる、たくさんのテキストエディタが用意されています。 

学習が簡単なエディタは、 easy editor の略で man:ee[1] と呼ばれるものです。
このエディタを立ち上げるには、`ee _filename_` と入力してください。
ここで _filename_ は、 編集しようとしているファイルの名前です。
一旦このコマンドの中に入れば、 エディタの機能を操作するコマンドはすべてディスプレイの上部に表示されています。
キャレット `^` は kbd:[Ctrl] を意味するので、`^e` は kbd:[Ctrl+e] を押すという意味になります。
man:ee[1] を終了するには kbd:[Esc] を押し、そしてメインメニューから "leave editor" オプションを選択してください。
ファイルが更新されていたときは、エディタは変更をセーブするかどうかプロンプトを出します。

FreeBSD には、ベースシステムの一部として man:vi[1] といったより強力なテキストエディタが用意されています。
package:editors/emacs[] および package:editors/vim[] といった他のエディタは Ports Collection の一部として用意されています。
これらのエディタはやや学習が複雑ですが、より高い機能性を提供します。
しかし、あなたが多量のテキストを編集することを考えているなら、 vim や Emacs といった強力なエディタを習得することは、 より多くの時間を節約することでしょう。

ファイルを編集したり、文字入力を必要とするようなアプリケーションの多くは、自動的にテキストエディタを起動します。
<<shells>> の節で説明したように、デフォルトのエディタを変更するには `EDITOR` 環境変数に希望するエディタを設定してください。

[[basics-devices]]
== デバイスとデバイスノード

デバイスとはシステム上のハードウェアに関するものに対してよく使われる用語で、ディスクやプリンタ、グラフィックカードやキーボードが含まれます。
FreeBSD が起動するとき、ブートメッセージの大部分は検出されたデバイスについてのものです。
ブートメッセージは [.filename]#/var/run/dmesg.boot# に保存されています。

各デバイスはデバイス名と番号を持ちます。
例えば、[.filename]#acd0# は最初の IDE CD-ROM ドライブで、[.filename]#kbd0# はキーボードを表します。

FreeBSD におけるほとんどのデバイス、デバイスノードと呼ばれる [.filename]#/dev# にあるスペシャルファイルを通してアクセスしなければなりません。

[[basics-more-information]]
== さらに詳しい情報を得るには...

[[basics-man]]
=== オンラインマニュアル

FreeBSD についてのもっとも包括的な文書は、 マニュアルページの形式になっているものです。
FreeBSD システム上のほとんどすべてのプログラムには、基本的な操作方法と利用可能な引数を説明しているリファレンスマニュアルが添付されています。
これらのマニュアルは `man` を使って見ることができます。

[source,shell]
....
% man コマンド名
....

ここで `コマンド名` のところには、知りたいコマンドの名前を入れます。
たとえば man:ls[1] について知りたい場合には、次のように入力します。

[source,shell]
....
% man ls
....

オンラインマニュアルは、セクション番号で分類されています。

. ユーザコマンド
. システムコールとエラー番号
. C のライブラリ関数
. デバイスドライバ
. ファイル形式
. ゲームや娯楽
. さまざまな情報
. システムの管理と操作のためのコマンド
. カーネル開発者のための情報

時折、 同じトピックがオンラインマニュアルの複数のセクションに記載されている場合があります。
たとえば、man:chmod[1] ユーザコマンドと `chmod()` システムコールの場合がそれに該当します。
man:man[1] にセクション番号を与えることで、 表示したいセクションを指定できます。

[source,shell]
....
% man 1 chmod
....

上のようにすれば、ユーザコマンド man:chmod[1] のマニュアルページが表示されます。
オンラインマニュアルの特定セクションへの参照は、慣習的に書かれている文書で括弧の中に示されます。
すなわち、man:chmod[1] はユーザコマンドを、man:chmod[2] はシステムコールの方を示しています。

コマンドの名前を知らない場合には、
`man -k` を使ってコマンド解説 (description) の文章からキーワードを検索してください。

[source,shell]
....
% man -k mail
....

このコマンドは、"mail" というキーワードをコマンド解説に含むコマンドの一覧を表示します。
これは man:apropos[1] と同等の機能です。

[.filename]#/usr/bin# にあるコマンドが実際にどう働くのかを調べるには、以下のように実行してください。

[source,shell]
....
% cd /usr/bin
% man -f *
....

または、以下を実行してください。

[source,shell]
....
% cd /usr/bin
% whatis *
....

[[basics-info]]
=== GNU の Info ファイル

FreeBSD には Free Software Foundation (FSF) によるアプリケーションや ユーティリティがたくさん含まれています。
これらのプログラムには、マニュアルページに加えて `info` ファイルと呼ばれるハイパーテキスト形式の文書が付属しています。
この文書は man:info[1]、あるいは package:editors/emacs[] をインストールしているなら emacs の info モードで読むことができます。

man:info[1] を使うには、次のように入力してください。

[source,shell]
....
% info
....

`h` と入力すると、 簡単な手引きを読むことができます。 クイックコマンドリファレンスは `?` を入力してください。
