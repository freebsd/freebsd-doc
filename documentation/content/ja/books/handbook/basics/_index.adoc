---
title: 第3章 UNIX の基礎知識
part: パートI. 導入
prev: books/handbook/bsdinstall
next: books/handbook/ports
---

[[basics]]
= UNIX の基礎知識
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: 目次
:table-caption: 表
:figure-caption: 図
:example-caption: 例 
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 3

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ja/mailing-lists.adoc[]
include::shared/ja/teams.adoc[]
include::shared/ja/urls.adoc[]

toc::[]

[[basics-synopsis]]
== この章では

この章では FreeBSD オペレーティングシステムの基本的なコマンドと機能について記述しています。 ここに書かれてあることのほとんどは、 どんな UNIX(R) オペレーティングシステムにもあてはまります。 この章に書いてあることに馴染みがあるなら、 この章は気軽に流し読みしてください。 あなたが FreeBSD の初心者なら、 何か質問する前にこの章を読んでおいた方がきっといいはずです。

この章を読んで分かることは、次のようなことです。

* FreeBSD の "仮想コンソール" の使い方
* UNIX(R) のファイルの許可属性の仕組みと FreeBSD のファイルフラグについて
* FreeBSD のファイルシステムの構成
* FreeBSD のディスク構成
* ファイルシステムをマウント、アンマウントする方法
* プロセス、デーモンとシグナルとはなにか
* シェルとはなにか。 また、デフォルトのログイン環境を変える方法
* テキストエディタの基本的な使い方
* デバイスおよびデバイスノードとはなにか
* さらに詳しい情報を得るためのマニュアルページの読み方

[[consoles]]
== 仮想コンソールと端末

FreeBSD は様々な使い方ができます。その中の一つが、 テキスト端末でコマンドを入力することです。この方法で FreeBSD を使えば、 UNIX(R) オペレーティングシステムの能力と柔軟性を手にすることができます。 この節では、"コンソール" と "端末" はどのようなもので、FreeBSD でどう使うかを 説明します。

[[consoles-intro]]
=== コンソール

起動時に自動的にグラフィカルな環境が起動するように FreeBSD を設定していなければ、システムが起動してスタートアップ スクリプトが実行されると、すぐにログインプロンプトが出てくるでしょう。 次のようものが表示されるはずです。

[source,bash]
....
Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:
....

あなたのシステムではメッセージが多少異なるかもしれませんが、 似たようなものが見られるはずです。 最後の 2 行が、今関心を向けているものです。 最後から 2 行目は、以下のようになっています。

[.programlisting]
....
FreeBSD/i386 (pc3.example.org) (ttyv0)
....

この行には、 起動したばかりのシステムについていくばくかの情報があります。 あなたは、x86 アーキテクチャ上の Intel または その互換プロセッサ上で動作している "FreeBSD" の コンソールを目にしているのです。このマシンの名称 (どの UNIX(R) 機にも名前がついて います) は `pc3.example.org` で、 あなたはそのシステムコンソール、[.filename]#ttyv0# 端末に向かっています。

最後の行は、常に以下のものになります。

[.programlisting]
....
login:
....

ここは、FreeBSD にログインするために "ユーザ名" を入力するところです。次の節でどうするか説明します。

[[consoles-login]]
=== FreeBSD にログインする

FreeBSD は、マルチユーザ、マルチプロセスなシステムです。 これは、1 台のマシンで何人もの人が交互に多くのプログラムを 動かせるシステムに与えられる正式な説明です。

あらゆるマルチユーザシステムには、ある "ユーザ" を他のユーザと区別する何がしかの手段が必要です。 FreeBSD (とすべての UNIX(R) like なオペレーティングシステム) では、 すべてのユーザに対してプログラムの実行を可能にするのに、システムに "ログイン" することを義務付けてこれを実現しています。 どのユーザにも、一意な名前 ("ユーザ名") と個人的な秘密の鍵 ("パスワード") があります。 FreeBSD はユーザにプログラムの実行を許可する前に、 この 2 つの入力を要求します。

FreeBSD が起動してスタートアップスクリプトを実行し終わった 直後に、プロンプトを表示して有効なユーザ名の入力を促します。

[source,bash]
....
login:
....

この例では `john` というユーザ名を使う ことにしましょう。このプロンプトに対して `john` と入力して、kbd:[Enter] を 押してください。そうすると、 次のような"パスワード"の入力を要求するプロンプトが 表示されます。

[source,bash]
....
login: john
Password:
....

それでは `john` のパスワードを入力して kbd:[Enter] を押してください。パスワードは _表示されません_。これについては、当面は 気にする必要はありません。セキュリティのためといえば十分でしょう。

パスワードを正確に入力したら、FreeBSD にログインして 利用可能なすべてのコマンドを試せるようになっているはずです。

MOTD、もしくはコマンドプロンプト (`#`, `$` または `%`) に表示されるメッセージを読むようにしましょう。 これは FreeBSD へのログインに成功したときに表示されます。

[[consoles-virtual]]
=== 多数のコンソール

一つのコンソールで UNIX(R) コマンドを動かすのは結構なことですが、 FreeBSD は多くのプログラムを一度に動かせます。 コマンドを入力できるコンソールが一つというのは、 FreeBSD のようにいくつものプログラムを同時に動かせる オペレーティングシステムの場合は少しもったいないことです。 ここで、"仮想コンソール" が非常に役に立ちます。

FreeBSD は、異なる仮想コンソールを複数 表示するように設定できます。キーボード上である組合せのキーを押せば、 その中の一つから他の仮想コンソールのどれかに切り替えられます。 それぞれのコンソールは、個別の出力チャンネルを持っており、 また FreeBSD はある仮想コンソールから次に切り替えるのに応じて、 キーボード入力とモニター出力を適切につなぎ直します。

FreeBSD は、コンソールを切り替えるために、 特別なキーの組合せを予約しています。FreeBSD では kbd:[Alt+F1], kbd:[Alt+F2] から kbd:[Alt+F8] までを、 別の仮想コンソールに切り替えるのに使えます。

あるコンソールから他に切り替えるのに応じて、FreeBSD は画面 への出力を保存して戻します。結果として、FreeBSD で動かすコマン ドを入力するのに使える複数の画面とキーボードを "仮想的に" 実現できるのです。 ある仮想コンソールで実行したプログラムは、 そのコンソールが見えなくなっている時も実行を停止しません。 別の仮想コンソールに切り替えても動き続けます。

[[consoles-ttys]]
=== [.filename]#/etc/ttys# ファイル

初期設定では、FreeBSD は 8 つの仮想コンソールを立ち上げます。 この設定はもともと埋め込まれているわけではなく、 インストールしたものが、もっと多いまたは少ない数の仮想コンソールで 起動するように、容易にカスタマイズできます。仮想コンソールの数と 設定は [.filename]#/etc/ttys# ファイルに書かれています。

FreeBSD の仮想コンソールを設定するには [.filename]#/etc/ttys# ファイルを利用します。 このファイルのコメントアウトされていない (`#` 文字で始まっていない) 行は、一つの端末または仮想コンソールの 設定があります。FreeBSD の初期設定では、 仮想コンソールを 9 つ設定し、そのうち 8 つを有効にしています。 `ttyv` で始まる行がそれです。

[.programlisting]
....
# name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

このファイルのそれぞれのカラムと仮想コンソールに設定可能な 全オプションの詳しい説明は、man:ttys[5] のマニュアルを 参照してください。

[[consoles-singleuser]]
=== シングルユーザモードのコンソール

"シングルユーザモード" とは何かという詳しい説明は、 crossref:boot[boot-singleuser,「シングルユーザモード」] にあります。FreeBSD を シングルユーザモードで動かしている場合は一つしかコンソールが ないということは注意しておくに値するでしょう。仮想コンソールは 利用できません。シングルユーザモードのコンソールの設定は、同じく [.filename]#/etc/ttys# ファイルにあります。 `console` で始まる行を探してください。

[.programlisting]
....
# name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure
....

[NOTE]
====
`console` 行の上のコメントが示すように、 この行を編集して `secure` を `insecure` に変更できます。そうすると、 FreeBSD がシングルユーザモードで起動した場合にも `root` のパスワードを要求します。

_これを `_insecure_` に 変更する場合は十分注意してください。_`root` のパスワードを忘れてしまったら、 シングルユーザモードで起動するのは少しややこしくなります。 できることはできますが、FreeBSD の起動の過程とそれに関わる プログラムにあまり親しんでいない人には少し難しいかも知れません。
====

[[consoles-vidcontrol]]
=== コンソールのビデオモードの変更

FreeBSD のデフォルトのビデオモードは 1024x768 や 1280x1024 など、 グラフィックカードとディスプレイが対応しているサイズに調整されます。 別のビデオモードを使うには、以下の 2 つのオプションを有効にしてカーネルを再コンパイルする必要があります。

[.programlisting]
....
options VESA
options SC_PIXEL_MODE
....

1 度このオプションを有効にしてカーネルを再コンパイルしたら、 あなたのハードウェアがどのビデオモードに対応しているか、 man:vidcontrol[1] を用いて知ることができます。 以下を実行すると、どのビデオモードに対応しているかを知ることができます。

[source,bash]
....
# vidcontrol -i mode
....

このコマンドの出力結果があなたのハードウェアが対応しているビデオモードです。 その後 `root` ユーザで man:vidcontrol[1] を実行することで、 新しくどのビデオモードを使うかを選択できます。

[source,bash]
....
# vidcontrol MODE_279
....

このビデオモードで良いと思ったら、起動時に自動的に設定されるように [.filename]#/etc/rc.conf# ファイルに以下のように設定してください。

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[permissions]]
== 許可属性

FreeBSD は BSD UNIX(R) の直系の子孫であり、 いくつかの鍵となる UNIX(R) 思想にもとづいています。 まず最も際だった特徴として最初に言えるのは、FreeBSD がマルチユーザのオペレーティングシステムだということです。 FreeBSD は同時に働いている複数のユーザすべてを、 完全に分離したタスク上で処理する能力を持っています。 また FreeBSD は、ハードウェアデバイス、周辺装置、メモリ、 CPU 時間等への要求を、各ユーザが平等に利用できるように適切に共有し、 管理する役割を担っています。

システムがマルチユーザをサポートしているため、 システムが管理する資源はすべて、 誰がその資源を読み・書き・実行できるかを支配する、 一組の許可属性を持っています。 これらの許可属性は 3 つの部分からなる 3 桁の 8 進数の形で格納されています。 それはそのファイルの所有者 (owner) に対するもの、 そのファイルが所属するグループ (group) に対するもの、 その他 (others) に対するものの 3 つです。 これを数字を使って表現すると、次のようになります。

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| 値
| 許可属性
| ディレクトリの表示

|0
|読み込み不可、書き込み不可、実行不可
|`---`

|1
|読み込み不可、書き込み不可、実行可能
|`--x`

|2
|読み込み不可、書き込み可能、実行不可
|`-w-`

|3
|読み込み不可、書き込み可能、実行可能
|`-wx`

|4
|読み込み可能、書き込み不可、実行不可
|`r--`

|5
|読み込み可能、書き込み不可、実行可能
|`r-x`

|6
|読み込み可能、書き込み可能、実行不可
|`rw-`

|7
|読み込み可能、書き込み可能、実行可能
|`rwx`
|===

man:ls[1] に対してコマンドライン引数 `-l` を使うと、 詳細なディレクトリリストを見ることができ、 ファイルの所有者、グループ、その他への許可属性を示す欄があるのがわかります。 例えば、`ls -l` を実行して、 適当なディレクトリを表示させると以下のようになります。

[source,bash]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...
....

以下に示すのは、 `ls -l` の最初の行を抜き出したものです。

[source,bash]
....
-rw-r--r--
....

最初の (一番左の) 文字は、それが 普通のファイルなのか、ディレクトリなのか、 キャラクタ型のデバイス特殊ファイルなのか、 ソケットなのか、 その他の特殊な疑似ファイルデバイスなのかといった種類を示す特別な文字です。 この場合、`-` という文字は、 普通のファイルであることを示します。 この例でその次に来る `rw-` と書かれた 3 文字は、 そのファイルの所有者に許可を与えるものです。 その次の `r--` の 3 文字は、 そのファイルが所属しているグループに許可を与えます。 最後の `r--` の 3 文字は、 システムに存在するその他のユーザに許可を与えます。 "-" は許可が与えられていないことを示します。 このファイルの例では、ファイルの所有者はこのファイルを読み書きでき、 ファイルの所属しているグループに属するユーザはファイルを読むことだけでき、 そのどちらでもないユーザは、 このファイルを読むだけできるように許可属性が与えられています。 上の表によれば、このファイルに与えられた許可属性は `644` となります。 ここで各数字は、このファイルの許可属性の 3 つの部分を表しています。

ファイルについてはここまでの説明で十分です。 しかし、 デバイスの場合の許可属性はどのようにコントロールされているのでしょうか? FreeBSD は、大部分のハードウェアをファイルとして取り扱います。 そのため、プログラムからは普通のファイルとまったく同じようにオープンし、 データの読み書きができるようになっています。 これらのデバイス特殊ファイルは [.filename]#/dev# ディレクトリに収められています。

ディレクトリもまた、ファイルと同様に扱われます。 それは読み込み/書き込み/実行の許可属性を持ちます。 ディレクトリの実行ビットはファイルのそれとは少し違った意味を持ちます。 ディレクトリが実行可能になっているとき、 そのディレクトリに移動することができます。 つまり、そのディレクトリに "cd" (change directory) することが可能です。 また、実行可能属性がついているディレクトリでは、 名前が分かっているファイルにアクセスすることもできます (もちろんそのファイル自体の許可属性によります)。 

特に、ディレクトリの中の一覧を表示するには、 そのディレクトリに読み込み属性が設定されていなければなりません。 一方、名前が分かっているファイルを削除するには、 そのファイルが含まれているディレクトリに 書き込み属性_と_実行属性 の両方が必要です。

この他にも許可属性ビットはありますが、いずれも setuid バイナリや sticky ディレクトリなどといった特殊な状況で使われます。 ファイルの許可属性そのものについて、 また、それらの設定のしかたに関する詳しい情報は、 man:chmod[1] マニュアルページを参照してください。

=== シンボリック表記

シンボリック表記と呼ばれる許可属性を表す方法では、 ファイルやディレクトリの許可属性を、 8 進数ではなく記号を用いて設定します。 シンボリック表記では、(who), (action), (permissions) という書式が用いられます。 利用できる値は以下の通りです。

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| オプション
| 文字
| 意味

|(who)
|u
|ユーザ

|(who)
|g
|ファイルを所持しているグループ

|(who)
|o
|その他

|(who)
|a
|すべて ("world")

|(action)
|+
|許可属性を与える

|(action)
|-
|許可属性を取り除く

|(action)
|=
|許可属性を指定したものにする

|(permissions)
|r
|読み込み

|(permissions)
|w
|書き込み

|(permissions)
|x
|実行

|(permissions)
|t
|Sticky ビット

|(permissions)
|s
|UID または GID を設定する
|===

これらの値は、これまでと同様に man:chmod[1] コマンドで用いますが、文字で指定します。 たとえば、_FILE_ に対して自分以外のユーザからアクセスを一切受け付けたくない、 というときには以下のコマンドを実行してください。

[source,bash]
....
% chmod go= FILE
....

カンマ区切りで設定することで、 ファイルの属性を一度に 2 つ以上変更できます。 以下の例では、_FILE_ に対して自分以外のユーザから書き込みの権限を取り上げ、 かわりにすべてのユーザが _FILE_ を実行できるようにします。

[source,bash]
....
% chmod go-w,a+x FILE
....

=== FreeBSD のファイルフラグ

先ほど説明したファイルの許可属性に加え、 FreeBSD では "ファイルフラグ" を使えます。 これはファイルにセキュリティや管理上の属性を追加するものですが、 ディレクトリには追加しません。

これらのファイルフラグはファイルに管理上の属性を追加し、 `root` ユーザでさえ誤ってファイルを消去、変更してしまうことを防ぎます。

ファイルフラグは、man:chflags[1] を使って、簡単なインタフェースで設定できます。 例えば、[.filename]#file1# というファイルにシステムレベルで消去不可のフラグを設定するには、 以下のコマンドを実行してください。

[source,bash]
....
# chflags sunlink file1
....

また、消去不可のフラグを削除するには、 以下のように先ほどのコマンドの `sunlink` の前に "no" をつけるだけです。

[source,bash]
....
# chflags nosunlink file1
....

ファイルにどのフラグが設定されているのかを見るには、man:ls[1] コマンドを `-lo` オプションと一緒に使ってください。

[source,bash]
....
# ls -lo file1
....

出力は以下のようになります。

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

いくつかのフラグの追加、削除は `root` ユーザしかできません。 他のフラグは、ファイルの所有者が変更できます。 システム管理者は man:chflags[1] と man:chflags[2] から、 より詳細な情報を得ることをおすすめします。

[[dirstructure]]
== ディレクトリ構造

FreeBSD のディレクトリ構造は、 システム全体を理解するに当たって重要です。 把握しておくべき最も重要なものは、"/" ディレクトリです。 このディレクトリは起動時に一番最初にマウントされ、 オペレーティングシステムをマルチユーザで動作させるために 必要な基本システムが含まれています。 また、ルートディレクトリには、 マルチユーザへの移行中に他のファイルシステムをマウントするためのマウントポイントも含まれます。

マウントポイントとは、 追加のファイルシステムと接続するためのディレクトリのことです (普通はルートファイルシステムにあります) 。 より詳細な説明は <<disk-organization>> の節にあります。 標準的なマウントポイントには [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt#, [.filename]#/cdrom# があります。 通常これらのディレクトリについては、 [.filename]#/etc/fstab# というファイル中のエントリが参照されます。 [.filename]#/etc/fstab# はさまざまなファイルシステムとマウントポイントの表であり、 システムが参照します。 [.filename]#/etc/fstab# に書かれたファイルシステムは `noauto` オプションが指定されていなければ、 起動時に man:rc[8] スクリプトによって自動的にマウントされます。 詳細は <<disks-fstab>> をご覧ください。

ファイルシステム構造を網羅した説明は man:hier[7] に書かれています。 ここでは、もっともよく使われるディレクトリについて簡単に 見るだけで十分でしょう。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| ディレクトリ
| 説明

|[.filename]#/#
|ファイルシステムのルートディレクトリ

|[.filename]#/bin/#
|シングルユーザ環境とマルチユーザ環境の両方で重要な ユーザユーティリティ

|[.filename]#/boot/#
|オペレーティングシステムの起動時に使われるプログラムと設定ファイル

|[.filename]#/boot/defaults/#
|デフォルトの起動設定ファイル; man:loader.conf[5] 参照

|[.filename]#/dev/#
|デバイスノード; man:intro[4] 参照

|[.filename]#/etc/#
|システム設定ファイルとスクリプト

|[.filename]#/etc/defaults/#
|デフォルトのシステム設定ファイル; man:rc[8] 参照

|[.filename]#/etc/mail/#
|man:sendmail[8] のようなメール転送エージェントの設定ファイル

|[.filename]#/etc/namedb/#
|`named` 設定ファイル; man:named[8] 参照

|[.filename]#/etc/periodic/#
|man:cron[8] 経由で毎日・毎週・毎月実行されるスクリプト; man:periodic[8] 参照

|[.filename]#/etc/ppp/#
|`ppp` 設定ファイル; man:ppp[8] 参照

|[.filename]#/mnt/#
|システム管理者が一時的なマウントポイントとしてよく使う 空のディレクトリ

|[.filename]#/proc/#
|プロセスファイルシステム; man:procfs[5] と man:mount_procfs[8] 参照

|[.filename]#/rescue/#
|緊急時のために静的にリンクされているプログラム; 詳しくは man:rescue[8] 参照

|[.filename]#/root/#
|`root` アカウントのホームディレクトリ

|[.filename]#/sbin/#
|シングルユーザ環境とマルチユーザ環境の両方で重要な システムプログラムと管理ユーティリティ

|[.filename]#/tmp/#
|一時的なファイル。 通常、[.filename]#/tmp# の内容はシステムの再起動で失われます。 メモリファイルシステムはよく [.filename]#/tmp# にマウントされます。 これは man:rc.conf[5] の tmpmfs 関係の変数を使うか、 [.filename]#/etc/fstab# に設定項目を記入することで自動化できます。 詳しくは man:mdmfs[8] を参照して下さい。

|[.filename]#/usr/#
|大部分のユーザユーティリティとアプリケーション

|[.filename]#/usr/bin/#
|よく使うユーティリティとプログラミングツールとアプリケーション

|[.filename]#/usr/include/#
|C の標準ヘッダファイル

|[.filename]#/usr/lib/#
|ライブラリ

|[.filename]#/usr/libdata/#
|いろいろなユーティリティのデータファイル

|[.filename]#/usr/libexec/#
|システムデーモンとシステムユーティリティ (他のプログラムから実行される)

|[.filename]#/usr/local/#
|ローカルのプログラムやライブラリなど。 FreeBSD ports 構成のデフォルトインストール先としても使われます。 [.filename]#/usr/local# 内では、 man:hier[7] に書かれている [.filename]#/usr# のための一般構造が使われます。 例外は man ディレクトリで、 [.filename]#/usr/local/share# の下ではなく [.filename]#/usr/local# の下に直接置かれ、 ports 関係文書は [.filename]#share/doc/port# にあります。 

|[.filename]#/usr/obj/#
|[.filename]#/usr/src# ツリーのビルドで作られる アーキテクチャ依存のターゲットツリー

|[.filename]#/usr/ports#
|FreeBSD Ports Collection (インストールしなくてもよい)。

|[.filename]#/usr/sbin/#
|(ユーザが実行する) システムデーモンとシステムユーティリティ

|[.filename]#/usr/shared/#
|アーキテクチャに依存しないファイル

|[.filename]#/usr/src/#
|BSD のソースファイルまたはローカルのソースファイル、 あるいは両方

|[.filename]#/usr/X11R6/#
|X11R6 のプログラム、ライブラリなど (インストールしなくてもよい)

|[.filename]#/var/#
|ログ・一時的なファイル・スプールファイルなどいろいろな用途。 メモリファイルシステムは時々 [.filename]#/var# にマウントされます。 これは man:rc.conf[5] の varmfs 関係の変数を使うか、 [.filename]#/etc/fstab# に設定項目を記入することで自動化できます。 詳しくは man:mdmfs[8] を参照して下さい。

|[.filename]#/var/log/#
|いろいろなシステムログファイル

|[.filename]#/var/mail/#
|ユーザのメールボックスファイル

|[.filename]#/var/spool/#
|プリンタとメールシステムのスプールディレクトリなどなど

|[.filename]#/var/tmp/#
|一時的なファイル。 [.filename]#/var# がメモリファイルシステムでなければ、 ここにあるファイルはシステムが再起動しても失われません。

|[.filename]#/var/yp#
|NIS のマップ
|===

[[disk-organization]]
== ディスク構成

ファイルを見つけるために FreeBSD が使用する構成の一番小さな単位はファイル名です。 ファイル名は、大文字と小文字を区別します。 このことは [.filename]#readme.txt# および [.filename]#README.TXT# が異なる二つのファイルであることを意味します。 FreeBSD はそのファイルがプログラム、または文書、 あるいはその他の形式かどうかを決定するために拡張子を使用しません。

ファイルはディレクトリ内に格納されます。 ディレクトリはファイルを一つも含んでいないかもしれせんし、 または数百のファイルを含んでいるかもしれません。 ディレクトリはまた別のディレクトリを含むことができます。 つまり、ディレクトリの階層構造を構築することができます。 このことにより、データ構造がはるかに簡単になります。

ファイルおよびディレクトリは、 必要な他のディレクトリ名とスラッシュ (`/`) を後に続けて ファイル名またはディレクトリ名を与えることによって参照されます。 [.filename]#foo# ディレクトリがあって、その中に [.filename]#bar# ディレクトリがあるとします。 そして、その中に [.filename]#readme.txt# があるとすると、 ファイルへのフルネーム、または_パス_は [.filename]#foo/bar/readme.txt# となります。

ディレクトリおよびファイルはファイルシステム内に格納されます。 どのファイルシステムは、そのファイルシステムのための _ルートディレクトリ_ とよばれる、 まさに頂点の位置にちょうど一つのディレクトリを含んでいます。 このルートディレクトリは他のディレクトリを含むことができます。

これまでのところ、これはあなたの使ったことのある他の OS とおそらく似ているかもしれません。少し違いがあります。 たとえば、MS-DOS(R) ではファイル名とディレクトリ名を分けるのに `\` を使います。 一方、Mac OS(R) では `:` を使います。

FreeBSD はパス内にドライブレターまたは他のドライブ名を使いません。 あなたは FreeBSD で [.filename]#c:/foo/bar/readme.txt# とは書かないでしょう。

その代わり、一つのファイルシステムは _ルートファイルシステム_として設計されています。 ルートファイルシステムのルートディレクトリは `/` として参照されます。それから、他のすべてのファイルシステムは、 ルートファイルシステム以下に _マウント_ されます。 あなたが FreeBSD システムでどんなに多くのディスクを使用しても、 すべてのディレクトリは、 同じディスクの一部であるように見えるので問題ありません。

`A`,`B` および `C` と呼ばれる三つのファイルシステムがあると仮定しましょう。 それぞれのファイルファイルシステムには一つのルートディレクトリがあり、 `A1`, `A2` と呼ばれている二つの他のディレクトリを含んでいます (同様に `B1`, `B2` および `C1`, `C2` があります)。

`A` をルートファイルシステムとします。 このディレクトリになにが含まれているか見るために `ls` コマンドを使うと、 `A1` および `A2` の二つのサブディレクトリが現れるでしょう。 ディレクトリツリーは以下のようになります。

image::example-dir1.png[]

ファイルシステムはファイルシステム内のディレクトリにマウントしなければいけません。 それでは、`A1` ディレクトリに `B` ファイルシステムをマウントすると仮定します。 `B` のルートディレクトリは `A1` に置き換えられ、 そして `B` 内のディレクトリがそれに応じて現れます。

image::example-dir2.png[]

`B1` または `B2` 内にあるどんなファイルも、必要なときに [.filename]#/A1/B1# または [.filename]#/A1/B2# で到達できます。 [.filename]#/A1# にあったすべてのファイルは一時的に隠されました。 それらは `B` が A から_アンマウント_されたら再び現れるでしょう。

もし `B` が `A2` にマウントされていたら、この図のようになります。

image::example-dir3.png[]

そして、パスはそれぞれ [.filename]#/A2/B1# および [.filename]#/A2/B2# となるでしょう。

ファイルシステムは互いのファイルシステム上にもマウントできます。 上記の最後の例に続けて、`C` ファイルシステム は `B` ファイルシステム内の `B1` ディレクトリ上にマウントできます。 次の図のようになります。

image::example-dir4.png[]

または `C` は `A1` の下の `A` ファイルシステムに直接マウントできます。

image::example-dir5.png[]

もしあなたが MS-DOS(R) を使いなれているなら、 まったく同じではありませんが、これは `join` コマンドと 似ています。

これは、通常あなた自身が心配する必要のあるものではありません。 一般的に、FreeBSD をインストールするときにファイルシステムを作成し、 どこにマウントするか決定します。そして、 新しいディスクを追加しなければそれらを変更することはありません。

一つの大きなファイルシステムを用意し、 他のファイルシステムを作成する必要としないことはまったくもって可能です。 この方法にはいくつかの短所と一つの利点があります。

.マルチファイルシステムの利点
* 異なったファイルシステムは異なった _マウントオプション_ を使用できます。 たとえば、注意深い考えなのですが、 ルートファイルシステムを読みだし専用でマウントして、 不注意によって重大なファイルを削除、 または編集できないようににすることができます。 また、[.filename]#/home# のようなユーザが書き込み可能なファイルシステムを他のファイルシステムと分けることによって、 _nosuid_ でマウントすることも可能になります。 このオプションは、ファイルシステムに記録されている _suid_/_guid_ の実行可能ビットを有効にしないので、安全性を高めることができるでしょう。
* FreeBSD はファイルシステムがどのように使われているかによって、 自動的にファイルシステム上のファイルの配置を最適化します。 したがって、連続的に書き込まれた多くの小さなファイルが含まれているファイルシステムは、 より大きく少ないファイルが含まれているファイルシステムと異なる最適化をするでしょう。 一つの大きなファイルシステムを作成すると、 この最適化は成り立たなくなります。
* FreeBSD のファイルシステムはトラブルが起きてもとても強固です。 しかしながら臨界点でのトラブルは、 ファイルシステムの構造にまだ損害を与えるかもしれません。 マルチファイルシステムへデータを分割しておくことで、 必要なときにバックアップからレストアすることをより容易にして、 まだシステムが回復するかもしれません。

.シングルファイルシステムの利点
* ファイルシステムは固定サイズです。 FreeBSD をインストールするときにファイルシステムを作成して、 固定サイズを割りあてたなら、 後になってそのパーティションをより大きくする必要があると気づくかもしれません。 パーティションのサイズを変更するには、 バックアップ、新しいサイズを指定したファイルシステムの再作成、 バックアップしたデータをリストアする作業が必要となるでしょう。
+
[IMPORTANT]
====
FreeBSD には、 man:growfs[8] コマンドがあります。 このコマンドは、この制限を取り除いて、 ファイルシステムのファイルを直ちに増加させることを可能にします。 
====

ファイルシステムはパーティション内に含まれています。 FreeBSD の UNIX(R) 遺産のために、 これは普段使われるパーティション (例えば MS-DOS(R) パーティション) という用語の意味とは違う意味を持っています。 それぞれのパーティションは `a` から `h` までの文字で区別されます。 それぞれのパーティションは、 一つのファイルシステムだけを含むことができます。 このことは、ファイルシステムがファイルシステムの階層上の典型的なマウントポイント、 または含まれているパーティションの文字によって記述されることを意味します。

FreeBSD は _スワップ領域_ にもまたディスク領域を使用します。 スワップ領域は FreeBSD に _仮想メモリ_ を提供します。 これはあなたのコンピュータが、 実際に搭載している以上のメモリがあるかのように振舞います。 FreeBSD がメモリを使い果たしたときに、 現在使用されていないデータのいくつかをスワップ領域に移動し、 そのデータが必要となったときに (その他のデータをスワップ領域に移動させてから) メモリ内に移動しなおします。

いくつかのパーティションはある慣習と関係づけられています。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| パーティション
| 慣習

|`a`
|通常、ルートパーティションを含みます。

|`b`
|通常、スワップ領域を含みます。

|`c`
|通常、スライス全体と同じサイズです。 これは、スライス全体にアクセス必要のあるユーティリティ (たとえば、ひどいブロックスキャナ) が、 `c` パーティションにアクセスすることを可能にします。通常、 このパーティション内にファイルシステムを作成しないでしょう。

|`d`
|`d` パーティションは、 それに関連づけられた特別な意味を持っていましたが、 今は無いので、普通のパーティションとして動作するでしょう。
|===

ファイルシステムを含んだそれぞれのパーティションは、FreeBSD が _スライス_ と呼ぶものの中に格納されます。 スライスは FreeBSD の用語で、 普通はパーティションと呼ばれるものです。 もう一度言及しますが、これは FreeBSD の UNIX(R) 背景によるものです。 スライスは 1 から 4 までの番号がつけられます。

スライス番号は 1 から始まり `s` を前につけられて、デバイス名の後に続きます。 したがって、"da0_s1_" は一番目の SCSI ドライブ上の 一番目のスライスです。 ディスク上に四つの物理スライスだけが存在できます。しかし、 適切な種類の物理スライス内に論理スライスをもつことができます。 これらの拡張されたスライス番号は 5 から始まります。したがって、 "ad0_s5_" は、一番目の IDE ディスク上の一番目の拡張スライスです。 これらのデバイスは、 スライスを占有することを予期するファイルシステムによって使用されます。

スライスや "危険な専用" の物理ドライブ、 そして他のドライブは `a` から `h` までの文字として表される _パーティション_ を含んでいます。 この文字はデバイス名に追加されます。したがって、 "da0_a_" は一番目の "危険な専用" da ドライブ上の a パーティションです。 "ad1s3_e_" は、 二番目の IDE ディスク上の 三番目のスライス内にある五番目のパーティションです。

最後に、システム上のそれぞれのディスクは識別されます。 ディスク名はどの種類のディスクであるかを示す記号ではじまり、 どのディスクかを示す数字が続きます。 スライスとは違いディスクの番号づけは 0 から始まります。 共通の記号は <<basics-dev-codes>> に示されます。

パーティションを参照するときには、 FreeBSD はパーティションを含むスライスおよびパーティションも指定することを必要とします。 そしてスライスを参照するときはディスク名も参照しないといけません。 したがって、ディスク名、`s`、スライス番号、 そしてパーティション文字を並べることによってパーティションを参照します。 <<basics-disk-slice-part>>に例があります。

<<basics-concept-disk-model>> は理解をより明らかにすることを助けるための、 ディスク構成の概念のモデルを示します。

FreeBSD をインストールするために、 まずはじめにディスクスライスの設定をし、 次に FreeBSD に用いるスライス内のパーティションを作成し、 それからそれぞれのパーティション内にファイルシステム (またはスワップ領域) を作成し、 ファイルシステムがどこにマウントされるか決定しなければいけません。

[[basics-dev-codes]]
.ディスクデバイス記号
[cols="1,1", frame="none", options="header"]
|===
| 記号
| 意味

|[.filename]#ad#
|ATAPI (IDE) ディスク

|[.filename]#da#
|SCSI ダイレクトアクセスディスク

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|フロッピーディスク
|===

[[basics-disk-slice-part]]
.ディスク名、スライス名、パーティション名のサンプル
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 記号
| 意味

|`ad0s1a`
|一番目の IDE ディスク (`ad0`) 上の一番目のスライス (`s1`) 内の一番目のパーティション (`a`)。

|`da1s2e`
|二番目の SCSI ディスク (`da1`) 上の二番目のスライス (`s2`) 内の五番目のパーティション (`e`)。
|===
====

[[basics-concept-disk-model]]
.ディスクの概念的構成
[example]
====
これはシステムに接続された一番目の IDE ディスクの FreeBSD から見た図を示します。 ディスクサイズは 4 GB と仮定し、 2 GB のスライス (MS-DOS(R) でいうパーティション) が二つあるとします。 一番目のスライスは MS-DOS(R) ディスクの [.filename]#C:# を含んでいます。 そして、二番目のスライスは FreeBSD のディスクを含んでいます。 これは FreeBSD インストーラが三つのデータパーティションと一つのスワップパーティションを作成した例です。

三つのパーティションはそれぞれファイルシステムを含んでいます。 `a` パーティションはルートファイルシステムに使用され、 `e` パーティションは [.filename]#/var# ディレクトリ階層に、 `f` パーティションは [.filename]#/usr# ディレクトリ階層に使用されるでしょう。

image::disk-layout.png[]

====

[[mount-unmount]]
== ファイルシステムのマウントとアンマウント

ファイルシステムは [.filename]#/# をルート (根) とする木構造として考えると視覚的に理解しやすいでしょう。 ルートディレクトリにある [.filename]#/dev# や [.filename]#/usr#、 その他のディレクトリは枝に相当し、 それらには、[.filename]#/usr/local# などのように、さらに枝分かれすることができます。

さまざまな理由がありますが、 ディレクトリをいくつかの異なるファイルシステム上に構築するのが良いでしょう。 たとえば [.filename]#/var# には、 [.filename]#log/# や [.filename]#spool/# など、さまざまな種類の一時ファイルを置くディレクトリがあるため、 あふれてしまう可能性があります。 ルートファイルシステムをあふれさせるのは得策ではありませんので、 普通は [.filename]#/var# を [.filename]#/# から分離します。

また、次のような場合も、ディレクトリツリーを 別のファイルシステムに置く理由として良くあげられます。 それは、たとえば物理的に別のディスクにディレクトリツリーを置く場合、 crossref:advanced-networking[network-nfs,ネットワークファイルシステム (Network File System)] や CDROM ドライブのような別の仮想ディスクに置くという場合です。

[[disks-fstab]]
=== [.filename]#fstab# ファイル

[.filename]#/etc/fstab# に書かれているファイルシステムは (`noauto` オプションがなければ) crossref:boot[boot,起動プロセス]の途中で 自動的にマウントされます。

[.filename]#/etc/fstab# ファイルは、 次のような書式で書かれた行のリストになっています。

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
デバイスの名前 (存在していなければなりません)。 crossref:disks[disks-naming,「デバイス名」] に説明があります。

`mount-point`::
ファイルシステムがマウントするディレクトリの名前 (存在していなければなりません)。

`fstype`::
man:mount[8] に渡されるファイルシステムタイプ。 FreeBSD ファイルシステムのデフォルトは `ufs` です。

`options`::
読み書きするファイルシステムには `rw`、読み込み専用のファイルシステムには `ro` を、必要な他のオプションの前に指定します。 よく使われるオプションは `noauto` で、 起動時にはマウントされないファイルシステムに使います。 その他のオプションは man:mount[8] マニュアルページに載っています。

`dumpfreq`::
これは man:dump[8] が使うもので、 どのファイルシステムにダンプが必要なのかを決めます。 この項目がなければ、0 であるものとみなされます。

`passno`::
これはファイルシステムをチェックする順番を決めます。 ファイルシステムチェックを飛ばしたいファイルシステムには、 `passno` を 0 に設定してください。 ルートファイルシステム (どれよりも先にチェックしなければなりません) は `passno` を 1 に設定してください。 他のファイルシステムの `passno` は 1 以上に設定してください。 同じ `passno` のファイルシステムがあった場合、 man:fsck[8] は可能であれば並行してファイルシステムのチェック を行なおうとします。

[.filename]#/etc/fstab# ファイルの書式やオプションに関しての詳細は、 man:fstab[5] をご覧ください。

[[disks-mount]]
=== `mount` コマンド

man:mount[8] コマンドは、 ファイルシステムをマウントするために使われるものです。

基本的には、次のように使います。

[source,bash]
....
# mount device mountpoint
....

man:mount[8] マニュアルページにはたくさんのオプションが書かれていますが、 いちばんよく使われるのは次のものです。

.マウントオプション
`-a`::
[.filename]#/etc/fstab# にある全てのファイルシステムをマウントします。 例外は "noauto" の印がついているものと、 `-t` フラグで除外されたものと、 すでにマウントされているファイルシステムです。

`-d`::
実際にマウントシステムコールする以外のすべてのことをします。 このオプションは `-v` フラグと組み合わせて使い、 man:mount[8] が実際なにをしようとしているのか調べるのに便利です。

`-f`::
クリーンでないファイルシステムを強制的にマウントします (危険です)。もしくは、ファイルシステムのマウント状態を 読み書き可能から読み込みのみに変更するとき、 書き込みアクセスを強制的に取り消します。

`-r`::
ファイルシステムを読み込み専用でマウントします。 これは `ro` (5.2 より前の FreeBSD では `rdonly` です) 引数を `-o` オプションに使うのと同じです。

`-t` _fstype_::
ファイルシステムを指定のファイルシステムタイプでマウントします。 または、`-a` を使った場合、 指定したタイプのファイルシステムのみマウントします。
+
デフォルトのファイルシステムタイプは "ufs" です。

`-u`::
ファイルシステムのマウントオプションを更新します。

`-v`::
詳細な出力にします。

`-w`::
ファイルシステムを読み書き可能にマウントします。

`-o` には、 次のようなオプションを複数カンマで区切って指定します。 以下に挙げるのはその一部です。

noexec::
そのファイルシステム上のバイナリの実行を禁止します。 セキュリティのために有用なオプションです。

nosuid::
そのファイルシステム上の setuid や setgid フラグを解釈しません。 これもセキュリティのために有用なオプションです。

[[disks-umount]]
=== `umount` コマンド

man:umount[8] コマンドは、パラメータとしてマウントポイントの一つ、 デバイス名、もしくは `-a` や `-A` といったオプションを取ります。

いずれの形式でも `-f` で強制的なアンマウントを行ない、 `-v` で詳細な出力を出します。 ただしほとんどの場合、`-f` は使わないほうがよいでしょう。 強制的にファイルシステムをアンマウントすると、 計算機がクラッシュしたりファイルシステム上部のデータが 破壊されたりする恐れがあるためです。

オプション `-a` と `-A` はマウントされているファイルシステムすべてをアンマウントするのに使います。 `-t` にファイルシステムタイプを指定すると、 指定されたものだけがアンマウントされます。 また、`-A` を使うとルートファイルシステムはアンマウントしません。

[[basics-processes]]
== プロセス

FreeBSD はマルチタスクのオペレーティングシステムです。 つまり、1つ以上のプログラムがあたかも同時に動いているかのように見える、 ということです。動作中のプログラムはそれぞれ _プロセス_ と呼ばれます。 コマンドを実行すると、最低でも1つの新しいプロセスがスタートします。 システムを正常に機能させるために常に動作しているシステムプロセスもたくさんあります。

各プロセスは_プロセス ID_、もしくは _PID_ と呼ばれる数字でただ一つに識別されます。 また、ファイルのように各プロセスには所有者とグループがあります。 所有者とグループの情報は、 これまでに見たファイル許可属性を用い、 そのプロセスが開けるファイルやデバイスを決定するために使われます。 多くのプロセスには親プロセスもあります。 親プロセスとは、そのプロセスをスタートさせたプロセスのことです。 例えば、シェルにコマンドを打ち込んでいるときはシェルがプロセスで、 動かすコマンドもまたどれもプロセスです。 このようにして起動するプロセスはそれぞれシェルが親プロセスになります。 これの例外は man:init[8] という特別なプロセスです。 `init` は常に最初のプロセスなので、 PID は必ず 1 になります。 `init` は FreeBSD がスタートするときカーネルによって自動的に起動されます。

man:ps[1] と man:top[1] という2つのコマンドが システム上のプロセスを確認するために特に便利です。 `ps` コマンドは現在動作中のプロセスのリストを見るために使い、 PID やプロセスが使っているメモリの量、 どういうコマンドラインで起動されたのか、 などを表示させることができます。 `top` コマンドは動作中の全てのプロセスを表示し、 数秒ごとに表示を更新するので、 計算機がなにをしているのかインタラクティブに知ることができます。

デフォルトでは、`ps` は動作中かつ所有者が自分のコマンドのみを表示します。 例えば:

[source,bash]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

この例で分かるとおり、 man:ps[1] の出力はいくつかの行に整形されています。 `PID` は先ほど見たプロセス ID です。 PID は 1 から順に 99999 まで割り当てられ、 足りなくなると最初に戻って使い回されます (使用中の PID は割り当てられません) 。 `TT` の列はプログラムが動いている tty を示します。 差し当たって無視してもかまわないでしょう。 `STAT` はプログラムの状態を示しますが、 これもまた無視してよいでしょう。 `TIME` はプログラムがその CPU 上で動いている時間の長さです- 通常はプログラムをスタートさせたときからの経過時間ではありません。 CPU 上で時間を使う必要があるまでかなりの時間を費すようなプログラムもあるからです。 最後に、`COMMAND` はそのプログラムを起動するのに使われたコマンドラインとなります。

man:ps[1] は表示する情報を変えるためのオプションをたくさんサポートしています。 いちばん便利なのは `auxww` でしょう。 `a` は自分のプロセスだけではなく、 動作中のプロセス全部についての情報を表示します。 `u` はプロセスの所有者の名前をメモリ使用量と同様に表示します。 `x` はデーモンプロセスについての情報を表示し、 `ww` で、スクリーンに入りきらないほど長くなったコマンドラインでも省略せず、 man:ps[1] に各プロセスの全コマンドラインを表示させます。

man:top[1] の出力も同様です。 例は以下の通りです。

[source,bash]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

出力は2つのセクションに分かれています。 ヘッダ (最初の 5 行です) は動作している最新のプロセスの PID、 システムの平均負荷 (システムがどれくらい忙しいかの指標)、 システムの稼働時間 (最後の再起動からの時間) と現在の時刻を示します。 ヘッダの中の他の数字は動作中のプロセスの数 (この場合 47 ですね)、 使われているメモリとスワップ領域の量、 そしてシステムが異なる CPU 状態に消費した時間と関係します。

その下には man:ps[1] の出力と同じような情報を持った行が続きます。 前と同様 PID にユーザ名、消費 CPU 時間と実行中のコマンドを知ることができます。 man:top[1] を使うとデフォルトでプロセスが使っているメモリ容量も分かります。 メモリ使用量の欄は2項目に分かれており、 一方は合計使用量、 そしてもう一方は実使用量です-合計使用量はアプリケーションが必要としているメモリ量で、 実使用量はその時点で実際に使われているメモリ量です。 この例では、man:getenv[3] がだいたい 30 MB の RAM を必要としていますが、 いまのところ 9 MB しか使っていないことが分かります。

man:top[1] は自動的に2秒ごとに画面を更新します。 `s` オプションを使えば更新間隔を変更することができます。

[[basics-daemons]]
== デーモン、シグナルとプロセス終了

エディタを使っている場合、エディタを操作するのは簡単です。 ファイルを開く、などと動かせばよいのです。 このように操作できるのは、エディタにそういった機能があり、 かつエディタが_端末_に関連づけられているからです。 一方、ユーザから始終入力があるように設計されていないプログラムもあり、 そういったプログラムは最初から端末と切り離されます。 例えば、ウェブサーバは一日中ウェブのリクエストばかり処理するので、 通常全く入力を必要としません。 サイトからサイトへとメールを転送するプログラムも、 こういった種類のアプリケーションの一例です。

このようなプログラムは、_デーモン_と呼ばれます。 デーモンはギリシャ神話の登場人物で、 善でも悪でもなく、大雑把にいうと、 人間のために役立つことをしてくれる小さな妖精さんです。 今日の便利なウェブサーバやメールサーバととてもよく似ていますね。 このため、長い間 BSD のマスコットはスニーカーをはいてフォークを携えた かわいらしい姿のデーモンなのです。

通常デーモンとして動作するプログラムには末尾に "d" を持った名前をつける慣習があります。 BIND は Berkeley Internet Name Domain ですが、 実際実行されるプログラムは `named` という名前です。 Apache ウェブサーバのプログラムは `httpd` と呼ばれ、 ラインプリンタスプーリングデーモンは `lpd`、 などなどです。 これは単なる慣習で、しっかりがっちりとしたルールではありません。 例えば、Sendmail アプリケーションの主なメールデーモンは `sendmail` という名前で、 連想しそうな `maild` ではありません。

時々、デーモンプロセスと通信したいときがあります。 一つの方法として、それ (に限らずどんな動作中のプロセスでも) に _シグナル_と呼ばれるものを送信する方法です。 送信可能なシグナルはたくさんあります-特別な意味があるものもあれば、 アプリケーションによって解釈されるものもありますし、 アプリケーションがシグナルをどう解釈するかは そのアプリケーションの文章を読めば分かるでしょう。 自分が持っているプロセスにしかシグナルを送ることはできません。 他人のプロセスに man:kill[1] や man:kill[2] を使ってシグナルを送っても、許可されないでしょう。 これの例外は `root` ユーザで、 ルートユーザは誰のプロセスでもシグナルを送ることができます。

FreeBSD もアプリケーションにシグナルを送ることがあります。 アプリケーションを下手に書くと、 予想外のメモリにアクセスしようとするので、 FreeBSD がプロセスに _セグメンテーション違反_ シグナル (`SIGSEGV`) を送ります。 ある程度の時間が経ったら man:alarm[3] システムコールを使って警告してもらうようなアプリケーションには、 警告シグナル (`SIGALRM`) が送信される、 などです。

プロセスを止めるためには2つのシグナル、 `SIGTERM` か `SIGKILL` を使います。 `SIGTERM` は穏かにプロセスを終了させる方法です。 プロセスはシグナルを_受け取る_ことができ、 終了させたいのだなということを理解し、 開いているログファイルを全部を閉じ、 一般的に終了前にしていたことを終えることができます。 中断できない処理の途中だと、`SIGTERM` をプロセスが無視することもあるかもしれません。

プロセスは `SIGKILL` を無視することができません。 これは、"なにをしていようが構わないから今すぐ止まれ" というシグナルです。 プロセスに `SIGKILL` を送ると、 FreeBSD はそのプロセスをそこで止めます。

使う可能性のあるシグナルは、他に `SIGHUP`、`SIGUSR1`、と `SIGUSR2` があります。 これらは一般的な用途のシグナルで、 このシグナルが送信されたときアプリケーションによって別のことをします。

ウェブサーバの設定ファイルを変更したとしましょう-ウェブサーバに新しい設定を再読み込みさせたいですね。 `httpd` を止めて再起動することもできますが、 そうするとウェブサーバは一瞬ながら停止してしまいますし、 ちょっとでも止まってほしくないこともあるでしょう。 ほとんどのデーモンは `SIGHUP` シグナルに対して設定ファイルを再読み込みする反応を返すよう書かれています。 従って、`httpd` を止めて再起動する代わりに、 `SIGHUP` シグナルを送りましょう。 これらのシグナルへの標準的な反応というものがないために、 デーモンごとに行動が違うので、 疑問があれば必ずそのデーモンの文書を読んでください。

man:kill[1] コマンドを使って送るシグナルはこの例をご覧ください。

[.procedure]
====
*Procedure: プロセスにシグナルを送る*

この例では、man:inetd[8] にシグナルを送る方法を示します。 `inetd` の設定ファイルは [.filename]#/etc/inetd.conf# で、 `inetd` は `SIGHUP` が送信されるとこの設定ファイルを再読み込みします。

. シグナルを送りたいプロセスのプロセス ID を探します。 それには man:ps[1] と man:grep[1] を使います。 man:grep[1] コマンドは出力を検索するために使い、 指定した文字列を探します。 このコマンドは一般ユーザで実行しますが、 man:inetd[8] は `root` で実行されているので、 man:ps[1] には `ax` オプションを与える必要があります。
+
[source,bash]
....
% ps -ax | grep inetd
198  ??  IWs    0:00.00 inetd -wW
....
+ 
ということで、man:inetd[8] の PID は 198 です。 `grep inetd` コマンドがこの出力に出てくる場合もあります。 それは、man:ps[1] が動作中のプロセスのリストを見つける方法によります。
. man:kill[1] を使ってシグナルを送ります。 man:inetd[8] は `root` で起動されているために、 まず man:su[1] を使って `root` にならなければなりません。
+
[source,bash]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
大部分の UNIX(R) コマンドと同じく、 成功したら man:kill[1] は何の出力も表示しません。 自分のものではないプロセスにシグナルを送ると、 `kill: _PID_: Operation not permitted` と表示されます。 PID を打ち間違えると、 悪いことに間違ったプロセスにシグナルを送ってしまうか、 もしくは運がよければその時点で使われていない PID にシグナルを送ったことになり、`kill: _PID_: No such process` と表示されます。

[NOTE]
.なぜ `/bin/kill` を使うんでしょう?
======
多くのシェルは `kill` コマンドを組み込みコマンドとして備えています。 つまり、[.filename]#/bin/kill# を実行するのではなく、 シェルが直接シグナルを送ります。 これはとても便利なのですが、 シェルが違うと送るシグナルの名前の指定の仕方が違います。 シェルによって異なるシグナルの指定の仕方を全部覚えようとはせずに、 `/bin/kill ...` コマンドを直接使うほうが簡単です。
======
====

他のシグナルの送り方はほとんど同じで、 コマンドラインの `TERM` や `KILL` を必要に応じて変えるだけです。

[IMPORTANT]
====
システム上のランダムプロセスを終了させるのはよくありません。 特に、プロセス ID が 1 の man:init[8] は特別です。 `/bin/kill -s KILL 1` を使うといとも簡単にシステムをシャットダウンさせることができます。 kbd:[Return] を押す_前_に man:kill[1] を実行する引数を二重にチェックする_癖_をつけてください。
====

[[shells]]
== シェル

FreeBSD では日々の作業のほとんどは、 「シェル」と呼ばれるコマンドラインインタフェイスを通して行われます。 シェルの主な仕事はコマンドを入力チャンネルから受け取り、 そしてそれらを実行することです。 大部分のシェルはさらに組み込みの機能を持っていて、日々の作業、 ファイル管理やファイル名の展開、コマンドライン編集、 コマンドマクロ、環境変数などに便利です。 FreeBSD には `sh` (Bourne Shell) や `tcsh` (高機能 C-shell) が含まれています。 また、 これ以外にも `zsh` や `bash` などたくさんのシェルが FreeBSD Ports Collection から利用可能です。

「あなたは、どのシェルを使いますか?」という質問は、 まったく趣味の問題です。 あなたが C のプログラマだったとすれば、 `tcsh` のような C 風のシェルの方が落ち着くかもしれません。 Linux から来た人や UNIX(R) のコマンドラインインタフェイスになじみがなければ、 `bash` を試すのも良いでしょう。 ポイントは、それぞれのシェルは、 あなたの好みの作業環境で利用できる (もしくはできない) 独自の機能を持っているということ、 そして、どのシェルを使うことにするかを決めるのはあなた自身だということです。

シェルの一般的な機能の一つに、ファイル名の補完があります。 コマンドやファイル名の最初の数文字を与えて kbd:[Tab] キーを押すことで、 シェルにコマンドやファイル名の残りの部分を自動的に補完させることができます。 例をあげましょう。 二つのファイル [.filename]#foobar#, [.filename]#foo.bar# が あったとします。 ここで [.filename]#foo.bar# の方を削除するには、 `rm fo[Tab].[Tab]` と入力します。

するとシェルは `rm foo[BEEP].bar` と出力するでしょう。

[BEEP] のところはコンソールのベル (訳注: 通常はビープ音が鳴ります) です。 これは複数のファイルがマッチしたため、 ファイル名の補完を完全に行なえなかったことを伝えています。 [.filename]#foobar# と [.filename]#foo.bar# は 両方とも `fo` ではじまるため、 補完できるのは `foo` までです。 ここで `.` を入力して kbd:[Tab] を押せば、 シェルはファイル名の残りの部分を補完できます。

もう一つあげられるシェルの特徴として、環境変数があります。 環境変数とは、シェルの環境変数空間におけるキーと値とのペアです。 この変数空間は、そのシェルから起動されたプログラムから参照でき、 それを利用してプログラムの設定を保存するのに利用されます。 下の表は、一般的な環境変数とその意味を示したものです。

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 変数名
| 意味

|`USER`
|現在のログインユーザのユーザ名。

|`PATH`
|コロンで区切られた実行ファイル探索のための ディレクトリのリスト。

|`DISPLAY`
|接続する X11 ディスプレイのネットワーク名 (存在する場合のみ)。

|`SHELL`
|現在のシェル。

|`TERM`
|ユーザの端末種名。 端末のケーパビリティを決定するのに使われる。

|`TERMCAP`
|種々の端末の機能を実現する端末のエスケープコードの データベースのエントリ。

|`OSTYPE`
|オペレーティングシステムの種別。 たとえば FreeBSD。

|`MACHTYPE`
|システムが動作している CPU のアーキテクチャ。

|`EDITOR`
|ユーザの選んだテキストエディタ。

|`PAGER`
|ユーザの選んだテキストページャ。

|`MANPATH`
|コロンで区切られたマニュアルページ探索のための ディレクトリのリスト。
|===

環境変数をセットする方法は、 それぞれのシェルごとに多少異なります。 たとえば、`tcsh` や `csh` 等の C シェルでは `setenv` を使います。 `sh` や `bash` 等の Bourne シェルでは `set` と `export` を使います。 たとえば `csh` か `tcsh` で `EDITOR` 環境変数の値を [.filename]#/usr/local/bin/emacs# に セットするか変更するには、次のようにします。

[source,bash]
....
% setenv EDITOR /usr/local/bin/emacs
....

Bourne シェルでは次のようになります。

[source,bash]
....
% export EDITOR="/usr/local/bin/emacs"
....

ほとんどのシェルでは、 コマンドライン中の変数名の前に `$` 文字を置くことで、 環境変数を展開させることができます。 たとえば、 `echo $TERM` は `$TERM` が セットされている内容を表示します。 それはシェルが `$TERM` を展開して `echo` に渡しているからです。

シェルはさまざまな特殊文字を、特別なデータを表すものとして扱います。 その特殊文字はメタキャラクタと呼ばれます。 もっとも一般的なものは `\*` で、 これはファイル名に含まれる、あらゆる文字を表します。 これらの特殊なメタキャラクタはファイル名の展開に使われます。 たとえば、`echo *` と入力すると `ls` と入力したのとほとんど同じ結果を得られます。 これはシェルが `*` とマッチするすべてのファイルを 受け取って `echo` のコマンドラインに渡し、表示するからです。

これらの特殊文字をシェルに解釈させないようにするため、 特殊文字の前にバックスラッシュ文字 (`\`) を置くことができます。 `echo $TERM` は、 あなたの端末が何にセットされているかを表示します。 `echo \$TERM` は `$TERM` と そのまま表示します。

[[changing-shells]]
=== シェルの変更

シェルを変更する一番簡単な方法は `chsh` コマンドを使うことです。 `chsh` を実行すると 環境変数 `EDITOR` で示されたエディタが立ち上がります。 環境変数をセットしていなかった時は `vi` が立ち上がります。 "Shell:" の行を適宜変更してください。

`chsh` に `-s` オプションをつけると、 エディタを起動せずにシェルを変更することが可能です。 たとえば、シェルを `bash` に変えたいなら、次のようにしてください。 

[source,bash]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
使おうと思っているシェルは__必ず__[.filename]##/etc/shells## 中に書かれているものでなければなりません。 シェルを crossref:ports[ports,Ports Collection] からインストールしていたのであれば、すでにそれは行なわれていますが、 手動でインストールした場合は、それを忘れずに行ってください。

たとえば、`bash` を手動で [.filename]#/usr/local/bin# にインストールした場合 以下のようにする必要があります。

[source,bash]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

そして `chsh` を実行してください。
====

[[editors]]
== テキストエディタ

さまざまな FreeBSD の設定は、テキストファイルを編集することで行われます。 そのため、テキストエディタの扱いに慣れると良いでしょう。 FreeBSD には、基本システムの一部として二、三提供されるものと、 Ports Collection から利用できる、たくさんのテキストエディタが用意されています。 

最も学習が簡単なエディタは、 easy editor の略で ee と呼ばれるものです。 ee を立ち上げるには、コマンドラインから `ee _filename_` と入力します。 ここで _filename_ は、 編集しようとしているファイルの名前です。 たとえば、[.filename]#/etc/rc.conf# を編集するには `ee /etc/rc.conf` と入力します。 一旦 `ee` の中に入れば、 エディタの機能を操作するコマンドはすべてディスプレイの上部に 表示されています。キャレット `^` 文字は キーボードの kbd:[Ctrl] キーを意味しますので、 `^e` はキーのコンビネーション kbd:[Ctrl+e] を押すという意味になります。 ee を終了するには kbd:[Esc] キーを押し、 そして leave editor を選びます。 ファイルが更新されていたときは、 エディタは変更をセーブするかどうかプロンプトを出します。

FreeBSD には、基本システムの一部として vi、 一方 Emacs や vim といった他のエディタは Ports Collection の一部として、 より強力なテキストエディタが用意されています ([.filename]#editors/emacs#, [.filename]#editors/vim#)。 これらのエディタはやや学習が複雑ですが、より強力で高い機能性を提供します。 しかし、あなたが多量のテキストを編集することを考えているなら、 vim や Emacs といった強力なエディタを習得することは、 より多くの時間を節約することでしょう。

[[basics-devices]]
== デバイスとデバイスノード

デバイスとはシステム上のハードウェアに関するものに対してよく使われる用語で、 ディスクやプリンタ、グラフィックカードやキーボードが含まれます。 FreeBSD が起動するとき、FreeBSD が表示しているものの大部分は検出されたデバイスです。 [.filename]#/var/run/dmesg.boot# を眺めれば起動メッセージを読み直すことができます。

例えば、[.filename]#acd0# は最初の IDE CDROM ドライブで、[.filename]#kbd0# はキーボードを表します。

UNIX(R) オペレーティングシステムにおけるデバイスのほとんどは、 デバイスノードと呼ばれる [.filename]#/dev# ディレクトリにあるスペシャルファイルを通してアクセスしなければなりません。

=== デバイスノードを作成する

新しいデバイスをシステムにつけ足したり、 追加デバイスのサポートをコンパイルして加えたりするときは、 デバイスノードを作成しなければなりません。

==== `DEVFS` (デバイスファイルシステム: Device File System)

デバイスファイルシステム `DEVFS` は、 グローバルファイルシステム名前空間の中のカーネルデバイス名前空間へのアクセスを提供します。 デバイスノードを作成したり変更したりするのではなく、 `DEVFS` がこの特別なファイルシステムを管理するのです。

詳しくは man:devfs[5] マニュアルページをご覧ください。

[[basics-more-information]]
== さらに詳しい情報を得るには...

[[basics-man]]
=== オンラインマニュアル

FreeBSD についてのもっとも包括的な文書は、 マニュアルページの形式になっているものです。 FreeBSD システム上のほとんどすべてのプログラムには、 基本的な操作方法とさまざまな引数を説明しているリファレンスマニュアルが添付されています。 これらのマニュアルは `man` コマンドで見ることができます。`man` コマンドの使い方は簡単です。

[source,bash]
....
% man コマンド名
....

`コマンド名` のところには、知りたいコマンドの名前を入れます。 たとえば `ls` コマンドについて知りたい場合には、 次のように入力します。

[source,bash]
....
% man ls
....

オンラインマニュアルは、 セクション番号で分類されています。

. ユーザコマンド
. システムコールとエラー番号
. C のライブラリ関数
. デバイスドライバ
. ファイル形式
. ゲームや娯楽
. さまざまな情報
. システムの管理と操作のためのコマンド
. カーネル開発者のための情報

時折、 同じトピックがオンラインマニュアルの複数のセクションに記載されている場合があります。 たとえば、`chmod` ユーザコマンドと `chmod()` システムコールの場合がそれに該当します。 この場合、`man` コマンドにセクション番号を与えることで、 どちらを参照したいかを指定することができます。

[source,bash]
....
% man 1 chmod
....

上のようにすれば、 ユーザコマンド `chmod` のマニュアルページが表示されます。 オンラインマニュアルの特定セクションへの参照は、 慣習的に書かれている文書で括弧の中に示されます。 すなわち、man:chmod[1] は `chmod` ユーザコマンドを、man:chmod[2] はシステムコールの方を示しています。

コマンドの名前を知っていて、 単純にその使い方を知りたい場合はここまでの説明で十分でしょう。 しかし、 もしコマンドの名前を思い出せない場合にはどうしたら良いのでしょうか? `man` に `-k` スイッチをつければ、 コマンド解説 (description) の文章から、 指定したキーワードを検索することができます。

[source,bash]
....
% man -k mail
....

このコマンドにより、 "mail" というキーワードをコマンド解説に含むコマンドの一覧が表示されます。 実際には、これは `apropos` コマンドを使う場合と同等の機能です。

それでは、[.filename]#/usr/bin# にあるさまざまなコマンドすべてを見ていて、 それらが実際にどう働くのかが、まったく見当もつかないときには どうしたら良いでしょう? そのときは単純に、

[source,bash]
....
% cd /usr/bin
% man -f *
....

とするか、あるいは同じ働きをする

[source,bash]
....
% cd /usr/bin
% whatis *
....

としてください。

[[basics-info]]
=== GNU の Info ファイル

FreeBSD には Free Software Foundation (FSF) によるアプリケーションや ユーティリティがたくさん含まれています。 これらのプログラムには、マニュアルページに加えて `info` ファイルと呼ばれる ハイパーテキスト形式の文書が付属しています。 この文書は `info` コマンド、 あるいは emacs をインストールしているなら emacs の info モードで読むことができます。

man:info[1] コマンドを使うには、単に次のように入力します。

[source,bash]
....
% info
....

`h` と入力すると、 簡単な手引きを読むことができます。 クイックコマンドリファレンスは `?` を入力してください。
