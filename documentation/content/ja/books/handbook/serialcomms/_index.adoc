---
title: 第17章 シリアル通信
part: パートIV. ネットワーク通信
prev: books/handbook/partiv
next: books/handbook/ppp-and-slip
showBookMenu: true
weight: 22
path: "/books/handbook/serialcomms/"
---

[[serialcomms]]
= シリアル通信
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 17
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/serialcomms/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[serial-synopsis]]
== この章では

Unix は現在に至るまで、常にシリアル通信機能をサポートしていました。 実際、本当に初期の Unix マシンは、ユーザとの入出力にシリアル通信を使っていました。 10 文字毎秒のシリアルプリンタ、 キーボードから構成された "端末(terminal)" が広く使われていた当時とは、 何もかもがすっかり変わっています。この章では、FreeBSD でシリアル通信を行なういくつかの方法について説明しています。 

この章を読むと、以下のことがわかります。

* FreeBSD システムへの端末の接続方法
* リモートホストへダイヤルするためのモデムの使い方
* リモートのユーザがモデムでシステムにログインできるようにする方法
* シリアルコンソールからのシステム起動方法

この章を読む前に、以下のことを行っておくべきです。

* 新しいカーネルを構成してインストールする方法を覚える (crossref:kernelconfig[kernelconfig,FreeBSD カーネルのコンフィグレーション])。
* Unix のパーミッションとプロセスについて理解する (crossref:basics[basics,UNIX の基礎知識])。
* FreeBSD で使おうとしているシリアルハードウェア (モデムまたはマルチポートカード) のテクニカルマニュアルを読めるようにする。

[[serial]]
== はじめに

[[serial-terminology]]
=== 用語解説

bps::
Bits per Second の略で、 データの転送速度を表す単位。

DTE::
Data Terminal Equipment の略。 たとえばコンピュータ本体のこと

DCE::
Data Communications Equipment の略で、具体的にはモデムのこと。

RS-232::
EIA (米電気産業協会) のハードウェアシリアル通信の標準規格

通信におけるデータ転送速度に関して、 このセクションでは "ボー" (baud) という用語は使いません。 ボーというのは一定時間に生じうる電気的状態の変化の数を表すにすぎず、 "bps" (bits per second) という単位の方が__正しい__からです (少なくとも、こういう表現をしておけば、 意地の悪い人に怒られることもないのではないかと思います)。

[[serial-cables-ports]]
=== ケーブルとポート

モデムまたはシリアル端末を FreeBSD システムに接続するためには、 コンピュータ上のシリアルポートと、 シリアルデバイスに接続する適切なケーブルが必要です。 ハードウェアとそれが必要とするケーブルについてよく理解しているなら、 この節は飛ばしても問題ありません。

[[term-cables]]
==== ケーブル

シリアルケーブルにはさまざまな種類があります。 我々の目的にあうもっとも一般的な 2 種類は、 ヌルモデムケーブル と、スタンダード (ストレート) RS-232 ケーブルです ハードウェアの説明文書に必要なケーブルの種類が記載されているはずです。

[[term-cables-null]]
===== ヌルモデムケーブル

ヌルモデムケーブル (またはリバースケーブルあるいはクロ スケーブル) は、たとえば "signal ground" 信号のように、いくつかの信 号はそのまま通しますが、 他の信号は途中で入れ替えて通します。たとえば、"send data" 信号のピンは、反対側のコネクタの "receive data" 信号の ピンと繋がっています。

自分で使うケーブルは自分で作りたいということであれば、 端末で使うヌルモデムケーブルを作成できます。この表では、 RS-232C の信号線の名前と、DB-25 コネクタ上のピンの番 号を示しています。

[.informaltable]
[cols="1,1,1,1,1", frame="none", options="header"]
|===
| Signal
| Pin #
| 
| Pin #
| Signal

|TxD
|2
|connects to
|3
|RxD

|RxD
|3
|connects to
|2
|TxD

|DTR
|20
|connects to
|6
|DSR

|DSR
|6
|connects to
|20
|DTR

|SG
|7
|connects to
|7
|SG

|DCD
|8
|connects to
|4
|RTS

|RTS
|4
|
|5
|CTS

|CTS
|5
|connects to
|8
|DCD
|===

[NOTE]
====
DCD と RST では、コネクタ内部でピン4を5に接続し、 そして逆側のコネクタのピン8と接続します。
====

[[term-cables-std]]
===== スタンダード RS-232C ケーブル

スタンダードシリアルケーブル (またはストレートケーブル) の場合は、すべての RS-232C 信号をそのまま通します。つまり、片方の "send data" 信号のピンは、逆側の "send data" 信号のピンと繋がっています。モデムを FreeBSD に接続するときや、一部の端末を接続するときにこのタイプの ケーブルを使用します。

[[term-ports]]
==== ポート

シリアルポートは、FreeBSDが動作しているホスト コンピュータと端 末の間でデータのやりとりを行うために用いるデバイスです。 ここでは、現在存在するポートの種類と FreeBSD でのポートのアクセス方法について解 説します。

[[term-portkinds]]
===== ポートの種類

シリアルポートには何種類かのものがあります。 ケーブルを購 入したり自作したりする前に、 そのケーブルのコネクタの形状が端末および FreeBSD システムのポートの形状と一致していることを 確認してください。

ほとんどの端末は DB25 ポートを搭載しています。 FreeBSDが動作しているも のを含めて、PCは DB25 または DB9 ポートを搭載しています。マルチポート のシリアルカードの場合は、RJ-12 や RJ-45 のポートを搭載しているかもし れません。

利用されているポートの種類に関しては、 ハードウェアについてきたドキュメントを参照してください。 また、多くの場合、ポートの形状から判断することもできるでしょう。

[[term-portnames]]
===== ポートの名前

FreeBSDでは、[.filename]#/dev# ディレクトリ内のエントリを介 してシリアルポートへのアクセスがおこなわれます。 2種類の異なったエン トリがあります。

* 着信用のポートの名前は、 [.filename]#/dev/ttydN# (_N_ は 0から始まるポート番号) となっています。一般に端末の接続には 着信用ポートを用います。着信用のポートでは、 シリアルラインのデータ キャリア検出 (DCD) 信号がオンになっている必要があります。
* 発信用のポートの名前は、 [.filename]#/dev/cuaaN# となっています。 発信用のポートは普通モデムの接続に用い、端末の接続には 利用しません。ただ、 ケーブルまたは端末がキャリア検出信号を使えない タイプのものの場合は、 発信用のポートを使うとよいでしょう。

たとえば、端末を一つ目のシリアルポート (MS-DOS でいうところの [.filename]#COM1#) に接 続したとすると、[.filename]#/dev/ttyd0# がこの端末を指すことになります。また、 二つ目のシリアルポート ([.filename]#COM2#) ならば [.filename]#/dev/ttyd1# となり、 以下この形式のデバイスエントリを使います。

=== カーネルの設定

デフォルトでは、FreeBSD は 4 つのシリアルポートに対応しています。MS-DOS の世界では、 [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3# および [.filename]#COM4# と呼ばれています。 FreeBSD では、現在のところ BocaBoard の 1008 や 2016 などの、 "単純な"マルチポートシリアルインタフェースや、 Digiboard や Stallion Technologies が製造しているよりインテリジェントなマルチポートカードにも対応しています。 しかしながら、デフォルトのカーネルは、標準の COM ポートしか見ません。

搭載されているシリアルポートのいずれかを、 カーネルが認識しているかどうか確認したい場合は、 カーネルの起動時のメッセージを注意深く見るか、あるいは `/sbin/dmesg` コマンドを使って、 起動時の出力メッセージを確認してください。特に、 `sio` で始まるメッセージをよく見てください。

[TIP]
====

以下のコマンドで `sio` という文字列を含むメッセージだけを表示できます。

[source,shell]
....
# /sbin/dmesg | grep 'sio'
....

====

たとえば、シリアルポートを四つ持つシステムの場合は、 以下のようなシリアルポートに関するメッセージがカーネルによって表示されます。

[source,shell]
....
sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A
....

もし、カーネルに正常に認識されないポートがある場合は、 おそらくカスタマイズした FreeBSD カーネルを構築する必要があるでしょう。 カーネルコンフィグレーションの詳細については crossref:kernelconfig[kernelconfig,FreeBSD カーネルのコンフィグレーション] をご覧ください。

カーネルコンフィグレーションの該当するデバイス行は、 次のようになります。

[.programlisting]
....
device		sio0	at isa? port "IO_COM1" tty irq 4 vector siointr
device		sio1	at isa? port "IO_COM2" tty irq 3 vector siointr
device		sio2	at isa? port "IO_COM3" tty irq 5 vector siointr
device		sio3	at isa? port "IO_COM4" tty irq 9 vector siointr
....

システムに搭載されていないデバイスに関する記述は、 コメントアウトまたは削除してしまってかまいません。 man:sio[4] のマニュアルを見て、 マルチポートのボードのためのコンフィグレーションファイルの記述の仕方を確認してください。 デバイスのフラグの指定方法がバージョンによって異なりますので、 別のバージョンの FreeBSD で利用していたコンフィグレーションファイルを流用する場合には十分注意してください。

[NOTE]
====
なお、`port "IO_COM1"`, `IO_COM2`, `IO_COM3` および `IO_COM4` は、 それぞれのポートの一般的なアドレスである `0x3f8`, `0x2f8`, `0x3e8` および `0x2e8` を表します。また、割り込み番号 4, 3, 5 と 9 は、それぞれ [.filename]#COM1:# から [.filename]#COM4:# のポートで一般的に使用される IRQ です。また、ISA バスのコンピュータの場合、 一般的なシリアルポートは複数のポートで一つの IRQ を共有することが __できません__ので注意が必要です (マルチポートのシリアルボードの場合は、複数の 16550A ベースのポートで一つまたは二つの IRQ を共有するための機構を備えています)。
====

=== デバイススペシャルファイル

カーネルに組み込まれているほとんどのデバイスは、 [.filename]#/dev# ディレクトリにある、 "デバイススペシャルファイル"を介してアクセスされます。 [.filename]#sio# デバイスの場合は、着信用の [.filename]#/dev/ttydN# および、発信用の [.filename]#/dev/cuaaN# が利用されます。さらに、FreeBSD は、初期化デバイス ([.filename]#/dev/ttyidN# と [.filename]#/dev/cuai0N#) およびロッキングデバイス ([.filename]#/dev/ttyldN# と [.filename]#/dev/cual0N#) も用意しています。 初期化デバイスは、通信ポートがオープンされる度に、 そのポートの初期設定を行うために使われます。たとえば、 `RTS/CTS` によるフロー制御を行うモデムが接続されている場合の `crtscts` などのパラメータの初期化が行われます。 ロッキングデバイスは、ポートの設定をロックし、 他のユーザやプログラムにこれらを変更されることのないようにするために利用されます。 通信ポートの設定、デバイスのロックと初期化および設定の変更に関しては、 それぞれ man:termios[4], man:sio[4] と man:stty[1] のマニュアルをご覧ください。

==== デバイススペシャルファイルの作成

[NOTE]
====
FreeBSD 5.0 には、 必要に応じてデバイスノードを自動的に作成する `devfs` ファイルシステムがあります。 `devfs` が有効になっているバージョンの FreeBSD を動かしているなら、 この節は飛ばしてかまいません。
====

デバイススペシャルファイルの管理は、ディレクトリ [.filename]#/dev# にあるシェルスクリプト `MAKEDEV` で行います。 `MAKEDEV` を使って、 [.filename]#COM1# (ポート 0) をダイアルアップのポートとして利用するための デバイススペシャルファイルを作るには、 [.filename]#/dev# に `cd` してから、 `MAKEDEV ttyd0` と実行してください。 同様に、`MAKEDEV ttyd1` とすることで、 [.filename]#COM2# (ポート 1) 用のデバイススペシャルファイルを作成できます。

`MAKEDEV` は、 [.filename]#/dev/ttydN# のデバイススペシャルファイルだけでなく、 [.filename]#/dev/cuaaN#, [.filename]#/dev/cuaiaN#, [.filename]#/dev/cualaN#, [.filename]#/dev/ttyldN# および [.filename]#/dev/ttyidN# ノードも作成します。

デバイススペシャルファイルの作成後、 これらのファイルの許可属性が適切に設定されていて、 これらのデバイスを利用してもよいユーザのみが読み書きできるようになっていることを確認してください (特に [.filename]#/dev/cua*# の許可属性には注意を払ってください)。 この確認を怠ると、 一般のユーザがあなたのモデムを使うことができるようなことになりかねません。 デフォルトの [.filename]#/dev/cua*# の許可属性は、以下のようになっていて、 たいていの場合適切なものだと思います。

[source,shell]
....
crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1
....

上の設定では、ユーザ `uucp` と、グループ `dialer` に属するユーザが発信用のデバイスを利用できます。

[[serial-hw-config]]
=== シリアルポートの設定

[.filename]#ttydN# (または [.filename]#cuaaN#) デバイスは、 アプリケーション上でシリアルポートをオープンする時に使用する、 標準的なデバイスです。プロセスがデバイスをオープンする際、端末 I/O 設定のデフォルトセットが適用されます。これらの設定内容は、 次のコマンドで確認することができます。

[source,shell]
....
# stty -a -f /dev/ttyd1
....

このデバイスの設定を変更した場合、 その設定はデバイスがクローズされるまで有効です。 デバイスが再びオープンされる時、デフォルトの設定値に戻ります。 デフォルトの設定を変更するためには、"初期状態" を設定したいデバイスをオープンして調節できます。 たとえば、[.filename]#ttyd5# というデバイスに対して、デフォルトで `CLOCAL` モード, 8 bits, `XON/XOFF` フロー制御を設定したい場合は、 次のように入力してください。

[source,shell]
....
# stty -f /dev/ttyid5 clocal cs8 ixon ixoff
....

システム全体のシリアルデバイス初期化は [.filename]#/etc/rc.serial# で制御されています。 このファイルは、シリアルデバイスのデフォルトの設定を決めます。

また、"ロック状態"のデバイスに調節を加えることで、 アプリケーションがある種の設定を変更してしまうことを防げます。 たとえば、[.filename]#ttyd5# の速度を 57600 bps に固定したい場合には、次のように入力してください。

[source,shell]
....
# stty -f /dev/ttyld5 57600
....

これで、[.filename]#ttyd5# をオープンして、 シリアルポートの転送スピードを変更しようとするアプリケーションは 57600 bps で頭打ちになります。

本来、初期状態やロックされているデバイスに書き込めるのは `root` アカウントだけにすべきです。

[[term]]
== シリアル端末

シリアル端末を利用することで、 コンピュータのコンソールのそばにいないときや、 手近にネットワーク接続されているコンピュータがないときでも、 FreeBSD の機能を便利に、かつ安価に利用することができます。 ここでは、FreeBSD にシリアル端末を接続する方法を解説します。

[[term-uses]]
=== 端末の種類と利用方法

もともと Unix システムにはコンソールがありませんでした。 ユーザはコンピュータのシリアルポートに接続された端末からログインしてプログラムを利用していました。 ちょうどモデムと通信ソフトを使ってリモートのコンピュータにログインし、 テキストベースのプログラムを利用するのとよく似ています。

最近の PC は、 高品質の画像を表示できるコンソールを搭載していますが、 ほとんどすべての Unix 系 OS には未だにシリアルポートを使ってログインするための機能があり、 FreeBSD でもこの機能がサポートされています。 現在使用されていないシリアルポートに端末を接続することでシステムにログインし、 通常はコンソールや X ウィンドウシステムの `xterm` のウィンドウ上で起動しているテキストベースのプログラムであれば何でも利用できます。

職場での利用ということで考えるならば、FreeBSD が動作しているコンピュータに接続された何台ものシリアル端末を各社員の机に配置するというようなことが可能です。 また、家庭での利用方法としては、余っている古い IBM PC や Macintosh を FreeBSD が動いているパワフルなコンピュータの端末として利用できます。 普通ならシングルユーザのコンピュータを、 パワフルなマルチユーザのシステムに変えることができるのです。

FreeBSD では、以下に挙げる 3 種類の端末が利用できます。

* <<term-dumb,ダム (dumb) 端末>>
* <<term-pcs,PCを利用した端末>>
* <<term-x,X 端末>>

以下は、それぞれについての解説です。

[[term-dumb]]
==== ダム端末

ダム端末は、 シリアルライン経由でのコンピュータとの接続専用のハードウェアです。 ダム端末は、テキストの送受信および表示ができる程度の計算能力しかもっていないので、 "dumb" (間抜け) というように呼ばれています。 この端末上でプログラムを実行することはできません。 テキストエディタ、コンパイラ、E-mail、 ゲームなどなどのプログラムを実行するのは、 ダム端末を接続しているコンピュータの方です。

Digital Equipment 社の VT-100 や、Wyse 社の WY-75 を初めとして、多くのメーカが何百種類ものダム端末を作っています。 ほとんどどんな種類のダム端末でも FreeBSD に接続して使用できます。さらに、 高性能の端末の中には画像を取り扱えるものもありますが、 限られた数のソフトウェアパッケージしかこういった機能には対応していません。

ダム端末は、 X ウィンドウシステムで提供されるようなグラフィックアプリケーションを必要としない職場で広く用いられています。

[[term-pcs]]
==== PC を端末として利用する

<<term-dumb,ダム端末>> がテキストの表示および送受信の機能をそなえただけのものならば、 言うまでもなく、どんな PC もダム端末になり得ます。 必要なものは適切なケーブルと、その PC の上で動作する__端末エミュレーション__ を行うソフトウェアのみです。

このような環境は、家庭においてよく利用されます。 たとえば、あなたの同居人が FreeBSD のコンソールを専有している時などに、 あまりパワーのないコンピュータを FreeBSD システムにシリアル端末として接続し、 その端末上でテキストだけを用いる作業をおこなうことができます。

[[term-x]]
==== X 端末

X 端末は、 既存のものの中で最も洗練された種類の端末といえます。 X 端末は、たいていの場合シリアルポートではなく、 イーサネットのようなネットワークを利用した接続をおこないます。 また、アプリケーションの利用においても、 テキストベースのものだけでなく、 X アプリケーションの利用が可能です。

ここでは、参考までに端末について紹介しただけで、 X 端末の設定や利用についての解説は _おこないません_。

[[term-config]]
=== 設定

ここでは、端末からのログインを可能にするために必要な FreeBSD 側の設定について解説します。 既に端末を接続するポートが利用できるように kernel の設定をおこない、端末が接続されているものと考えて、解説を進め ます。

crossref:boot[boot,FreeBSD の起動のプロセス] で述べたように `init` プロセスは、 システム起動時にすべてのプロセス管理や初期化をおこなっています。 `init` が行っている仕事の一つは、 [.filename]#/etc/ttys# ファイルを読んで、利用可能な端末上で `getty` プロセスを起動することです。 `getty` プロセスは、 ログイン名を読み込み `login` プログラムを起動します。

したがって、FreeBSD の端末を設定するには、 `root` で次の手順を踏まなければなりません。

[.procedure]
====
. 端末を接続するポートの [.filename]#/dev# のエントリが含ま れている行がまだ存在しなければ、これを [.filename]#/etc/ttys# に追加してく ださい。
. `/usr/libexec/getty` が対象となるポートに対して 実行されるように指定してください。また、 [.filename]#/etc/gettytab# ファイ ル内の適切な _getty_ タイプのエントリを指定してください。
. デフォルトのターミナルタイプを指定してください。
. 対象となるポートを "on" に設定してください。
. そのポートが "secure" であるかどうかを指定してください。
. `init` に [.filename]#/etc/ttys# を読み込みなおさせてく ださい。
====

また、必要に応じて [.filename]#/etc/gettytab# を変更し、上の 2で使用する _getty_ のエントリを追加してください。 この章ではこの方法については特に解説しませんので、man:gettytab[5] および man:getty[8] のマニュアルをご覧ください。

[[term-etcttys]]
==== [.filename]#/etc/ttys# へのエントリの追加

[.filename]#/etc/ttys# には、 FreeBSDシステム上のログインを許可するすべての ポートを記述します。たとえば、一つ目の仮想コンソール [.filename]#ttyv0# のエン トリもこのファイルにあります。このエントリのおかげで、 コンソールからの ログインが可能になっています。 このファイルには、他の仮想コンソール、シ リアルポートおよび仮想端末のエントリも含まれています。 端末を接続する場合は、そのポートの [.filename]#/dev# のエントリを、 [.filename]#/dev# の部分を省略して記述します (たとえば [.filename]#/dev/ttyv0# については、 [.filename]#ttyv0# として記述します)。

FreeBSD のデフォルトのインストール状態では、 [.filename]#ttyd0# から [.filename]#ttyd3# までの、初めの 4 つのシリアルポートに対応した [.filename]#/etc/ttys# ファイルが置かれています。 これらのポートのいずれかに端末を接続する場合は、 新たにエントリを追加する必要はありません。

[[ex-etc-ttys]]
.端末の項目を [.filename]#/etc/ttys# に追加する
[example]
====
システムに 2 台の端末、Wyse-50 と、VT-100 端末をエミュレートしている Procomm 端末ソフトウェアを動かしている古い 286 IBM PC をシステムに接続しようとしていると考えてください。 Wyse は 2 番目のシリアルポートに、286 は 6 番目のシリアルポート (マルチポートシリアルカード上のポート) に接続します。 [.filename]#/etc/ttys# 内の対応する項目は次のようになります。

[.programlisting]
....
ttyd1  "/usr/libexec/getty std.38400"  wy50  on  insecure
ttyd5   "/usr/libexec/getty std.19200"  vt100  on  insecure
....

* 最初のフィールドには、通常 [.filename]#/dev# にある端末のスペシャルファイル名を指定します。
* 2 番目のフィールドは、 この回線に対して実行するコマンドで、通常は man:getty[8] です。`getty` は、回線を初期化して開き、速度を設定して、 ユーザ名を入力するプロンプトを出して man:login[1] プログラムを実行します。`getty` プログラムは、 コマンドラインから (省略可能な) パラメータ _getty_ タイプを受け取ります。 _getty_ タイプは、 bps レートやパリティのような端末回線の特性を示します。 `getty` プログラムは、 これらの特性を [.filename]#/etc/gettytab# ファイルから読み込みます。[.filename]#/etc/gettytab# ファイルには、 端末回線について新旧多くの項目があります。 ほとんどの場合、`std` で始まる項目は、ケーブルで接続された端末に働きます。 これらの項目はパリティを無視します。110 から 115200 までの間の bps レートそれぞれに対して一つ `std` 項目があります。もちろん、 このファイルに独自の項目を加えてもかまいません。 man:gettytab[5] のマニュアルに詳しい情報が載っています。[.filename]#/etc/ttys# ファイルに _getty_ タイプを設定する時は、 端末の通信設定が対応していることを確かめましょう。たとえば、Wyse-50 はパリティなしで、38400 bps で接続します。286 PC はパリティなしで、19200 bps で接続します。
* 第 3 フィールドは、その tty 回線に通常つながる端末の種別です。 ダイアルアップポートでは、実際、 ユーザがどんな種類の端末やソフトウェアで接続してくることもありうるので、 このフィールドには `unknown` または `dialup` がよく使われています。 ケーブルで配線された端末については、 端末種別は変わりませんので、man:termcap[5] データベースファイルから実際の端末種別を、 このフィールドに記入できます。我々の例では、Wyse-50 には実際の端末種別を使っていますが、 Procomm を動かしている 286 PC は、VT-100 をエミュレートするように設定します。
* 4 番目のフィールドは、 ポートを有効にすべきかどうかを指定します。 ここに `on` と記入すると、 `init` プロセスが 2 番目のフィールドに記載されているプログラム、 `getty` を起動します。 このフィールドを `off` にすると、 `getty` は動かず、 そのポートからはログインできません。
* 最後のフィールドは、 そのポートが安全かどうか指定します。 あるポートが安全だということは、そのポートから `root` (またはその他の UID が 0 の) アカウントのログインを許可してよいと信頼しているということです。 安全でないポートからは、`root` のログインは許可されません。安全でないポートでは、 ユーザは特権を持たないアカウントでログインした後に、 man:su[1] や類似の仕組みを使ってスーパユーザ特権を獲得します。鍵のかかる部屋にある端末であっても、"insecure" にしておくことが強く推奨されます。 スーパユーザ特権が必要なら、ログインしてから `su` を使うのは十分簡単です。
====

[[term-hup]]
==== `init` にファイル [.filename]#/etc/ttys# の再読み込みをさせる

必要な変更を [.filename]#/etc/ttys# ファイルに加えたら、SIGHUP (ハングアップ) シグナルを `init` プロセスに送って設定ファイルを強制的に再読み込みさせます。 たとえば

[source,shell]
....
# kill -HUP 1
....

[NOTE]
====
`init` は、システムで最初に起動するプロセスなので、 PID は常に 1 です。
====

すべての設定が正しくおこなわれ、 すべてのケーブルがただしく接続されていて、 かつ端末の電源が入っていれば、この時点で各端末で `getty` プロセスが動いていて、 ログインプロンプトが表示されているはずです。

[[term-debug]]
=== 接続のトラブルシューティング

細心の注意を払って設定をおこなっても、 ときには端末の接続がう まくいかない場合があるでしょう。以下に、 よく見られる問題とその解決方法 を示します。

==== ログインプロンプトが表示されない

端末の電源が接続され、 スイッチが入っていることを確認してください。もし、PC を端末として利用している場合は、 通信ソフトが適切なシリアルポー トを利用する設定になっているかどうか確かめてください。 

ケーブルがしっかりと端末と FreeBSDが動作しているコンピュータの両方に接続され ていることを確認してください。また、 正しい種類のケーブルを利用している か確かめてください。

端末と FreeBSD の間の通信速度とパリティの設定が一致していることを確認 してください。 出力をモニタに表示するタイプの端末の場合は、モニタ のコントラストと明るさの設定を確認してください。また、 出力が印刷 されるタイプの端末の場合は、 紙とインクが十分にあるかどうかを確かめてく ださい。

`getty` が動いていて、 端末を認識していることを確認してください。 たとえば、動作中の `getty` プロセスの一覧を `ps` で取得するには、以下のように入力してください。

[source,shell]
....
# ps -axww|grep getty
....

その端末に対応する項目が表示されるはずです。 たとえば、以下の表示例は、`getty` は 2 番目のシリアルポート (`ttyd1`) に対して [.filename]#/etc/gettytab# 中の `std.38400` エントリを使って動作しているということを示しています。

[source,shell]
....
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1
....

もし、`getty` プロセスが一つも動いていないようであれば、 [.filename]#/etc/ttys# の中で、 そのポートを利用可能にする設定をしたかどうか確かめてください。 また、[.filename]#ttys# ファイルを変更したら、`kill -HUP 1` を実行するのを忘れないでください。

==== ログインプロンプトの代わりにゴミが表示される

端末と FreeBSD の間の通信速度およびパリティの設定が一致していることを確 かめてください。また、`getty` プロセスの情報を調べて、適切な _getty_ のタイプが使用されていることを確認してください。間違った _getty_ タイプが使用されている場合は、 [.filename]#/etc/ttys# を修正し てから、 `kill -HUP 1` を実行してください。

==== 文字が重複して表示される、入力したパスワードが表示される

端末または通信ソフトの設定で、"半二重 (half duplex)" あるいは "ローカ ルエコー" となっているところを、"全二重 (full duplex)" に変更してください。

[[dialup]]
== ダイアルインサービス

_訳: . 6 September 1996._

FreeBSD システムをダイアルインサービス用に設定することは、 端末の代わりにモデムを扱うこと以外は、 端末の接続によく似ています。

=== 外づけモデムと内蔵モデムについて

ダイアルアップのサービスに関していえば、 外づけのモデムの方が適している ようです。これは、 多くの外づけのモデムは設定を不揮発ラムに書き込んで半 永久的に保存することができますし、また RS-232 に関する重要な情報を知る ための点滅するライトによるインディケータが 搭載されているからです。点滅 するライトは、 システムを見に来た訪問者に強い印象を与えるという効果だけ でなく、モデムが適切に動作しているかどうかを知るためにも 有効です。

一方、たいていの内蔵型のモデムには 不揮発性ラムが搭載されていないため、ディップ スイッチの変更以外に設定を保存する方法がありません。また、も しインディケータがついていても、おそらくコンピュータのケース カバーが 外されていなければその状態を確認するのは 難しいでしょう。

==== モデムとケーブル

外付けモデムを使用しているなら、 それにあったケーブルが必要です。 通常の信号が全て接続されている限り、標準的な RS-232C ケーブルで十分でしょう。

* Transmitted Data (SD)
* Received Data (RD)
* Request to Send (RTS)
* Clear to Send (CTS)
* Data Set Ready (DSR)
* Data Terminal Ready (DTR)
* Carrier Detect (CD)
* Signal Ground (SG)

FreeBSD で 2400bps 以上の転送速度を利用する場合には、 フロー制御のため に RTS 信号と CTS 信号が必要です。また、 接続の確立と回線の切 断を検出するために CD 信号を利用します。さらに、 DTR 信号を使っ て回線切断後のモデムのリセットを行います。ケーブルの中には、 総ての必要 な信号線が接続されていないものもありますので、 たとえば、回線切断後でも ログイン セッションが残ってしまうといった問題が発生した場合などには、 ケーブルに問題がある可能性もあります。

FreeBSD も他の Unix 系 OS と同様、回線の接続およ び切断の検出や回線の切断および回線切断後の モデムの初期化にハードウェア シグナルを利用します。FreeBSD は、モデムに対するコマンドの送信やモデ ムの状態の監視を行いません。パソコンで運用されている BBS への接続に慣 れている方にとっては、 ちょっとめんどうかもしれませんね。

=== シリアル インタフェースについて

FreeBSD では、NS8250-、NS16450-、NS16550- および NS16550A- に基づ いた EIA RS-232C (CCITT V.24) 規格のシリアル インタフェースをサポート しています。8250 および 16450 ベースのディバイスには1文字のキャラクタ バッファが搭載されています。また、16550 系のディバイスには、 16文字分 のバッファが搭載されていて、 はるかによいパフォーマンスを得られます (ただし、無印の 16550 では、バグがあって 16 文字バッファが利用できませ んので、可能であれば 16550A 系のディバイスを利用してください)。1文字 のバッファの物は、 16550 系のものと比べて OS にかける負荷が大きいので、16550A 系ディバイスの利用を強く推奨します。多数のシリアル ポートを利 用する場合や、負荷の高いシステムにおいては、 16550A 系ディバイスを使う ことで、 エラー発生率を低く押さえることができます。

=== 概要

端末に関しては、 ダイアルイン接続に割り当てられたそれぞれのシリアルポートに対して、 `init` が `getty` を起動します。たとえば、モデムが [.filename]#/dev/ttyd0# に割り当てられていたら、`ps ax` コマンドを実行すると、以下のような出力が得られるはずです。

[source,shell]
....
4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0
....

ユーザがモデムに電話をかけ、モデム同士が接続されると、 モデムの CD (Carrier Detect) が検出されます。その結果、 kernel がキャリア信号を検出して、`getty` によるポートのオープンの処理が終了します。 `getty` は、`login:` プロンプトを指定されている初期回線速度で送信します。 `getty` は、 正常に文字列を受信できるかどうか監視し、通常の設定では、 もし異常な文字列を検出した場合 (理由としては、 `getty` の速度とモデ ムの接続速度が異なっているような場合が考えられます)、 正常に文字列が 受信できるまで、`getty` は速度を変え続けます。

ユーザがログイン名を入力すると、 `getty` は [.filename]#/usr/bin/login# を起動して、 パスワードの入力を要求し、その 後ユーザのシェルを起動します。

=== 設定ファイル

FreeBSD のシステムへのダイアルアップによるアクセスを実現するために編集が必要と思われる設定ファイルが、 [.filename]#/etc# ディレクトリに 3 つあります。まず、 [.filename]#/etc/gettytab# には、 [.filename]#/usr/libexec/getty# デーモンの設定を記述します。つぎに、 [.filename]#/etc/ttys# に保存されている情報から、 [.filename]#/sbin/init# はどの [.filename]#tty# デバイスに対して `getty` のプロセスを実行するべきか判断します。 最後に、[.filename]#/etc/rc.serial# スクリプトに、 シリアルポートの初期化のためのコマンドを記述することができます。

Unix にダイアルアップモデムを接続する方法には、 二つの考え方があります。一つの方法は、 ダイアルインしてくるユーザの接続速度に関係なく、 常にモデムとローカルのコンピュータの RS-232 インタフェースの接続速度を一定に保つように設定する方法です。 この設定の長所は、ユーザがダイアルインして接続されると、 即座にシステムからのログインプロンプトが送信されるということです。 短所は、システムが実際のモデム間の速度を知ることができないために、 Emacs のようなフルスクリーンのプログラムが、 端末との接続速度が遅い場合でも、 そのような場合に効果的な方法で画面出力を行わない点です。

もう一つは、モデムの RS-232 インタフェースとコンピュータの接続速度を、 モデム間の接続速度に応じて変化させるような設定です。たとえば、 モデム間 の接続が V.32bis (14.4 Kbps) ならば、 モデムとコンピュータの間の接続を 19.2 Kbps とし、 モデム間の接続が 2400 bps の時には、モデムとコンピュータ間も 2400 bps で接続するような設定をします。この場合、 `getty` は、モデムが返すリザルトコードからモデムとコンピュータの接続速度を認識することができませんので、 `getty` は、まず初期速度で `login:` という文字列を送信して、それに対する応答の文字列を監視します。 ここで、ユーザ側の端末に無意味な文字列が表示された場合、 ユーザは意味のある文字列を受信するまで Enter キーを繰り返し押さなければならないということを知っていると仮定しています。 もし接続速度が間違っている場合、`getty` は、 ユーザから送られた文字を無意味な文字列として扱い、 次の速度を試します。そして、ここで再度 `login:` プロンプトを送信します。 この一連の動作が異常な回数繰り返されることも考えられますが、 普通は 1 度か 2 度のキー入力があれば、 ユーザはまともなプロンプトを受信できます。 このログインの動作が前者の固定速度による方法に比べて美しくないのは明らかですが、 この方法では、低速度で接続しているユーザに対するフルスクリーンのプログラムからのレスポンスが改善されます。

このセクションでは、両方の設定方法について解説しますが、 どちらかというとモデム間の速度に応じて RS-232 インタフェースの速度が変化するような 設定の方に偏った説明になってしまうと思います。

==== [.filename]#/etc/gettytab#

[.filename]#/etc/gettytab# は、man:getty[8] の設定ファイルで、man:termcap[5] と同様の形式で記述されます。ファイルのフォーマットや定 義できる機能についての詳細については、man:gettytab[5] のマニュアルを ご覧ください。

===== 固定速度の設定

モデムとコンピュータ間の通信速度を固定して使う場合、 おそらく [.filename]#/etc/gettytab# に特に変更を加える必要はないはずです。

===== 可変速度の設定

`getty` が利用するモデムとコンピュータの接続速度に関する情報を [.filename]#/etc/gettytab# に記述する必要があります。もし、2400 bps のモ デムをお使いになるのであれば、既存の `D2400` のエントリがそのまま利 用できるでしょう。

[.programlisting]
....
#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:
....

高速モデムをお使いの場合は、おそらく [.filename]#/etc/gettytab# に新たなエントリを追加する必要があります。 以下の例は、14.4 Kbps のモデムを、 最大インタフェース速度を 19.2 Kbps として利用するためのエントリです。

[.programlisting]
....
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

上記の例を利用した場合、 パリティなし、8ビットの接続が行われます。

上記の例では、まず 19.2 Kbps (V.32bis) によるモデムとコンピュータ間の接続を試み、続いて 9600 bps (V.32)、2400 bps、1200 bps、300 bpsと順に試み、再び 19.2 Kbps による接続を試みるという循環に入ります。 この接続速度の循環は、`nx=`("next table") の機能で実現されています。また、 各行はそれぞれ `tc=`("table continuation") の機能を使って、 その他の接続速度に依存した "標準的な" 設定を取り込んでいます。

もし、お使いのモデムが 28.8 Kbps であったり、14.4 Kbps の圧縮転送の機能を有効に利用したい場合は、19.2 Kbps よりも速い速度を利用するように設定する必要があります。 以下に 57.6 Kbps から接続を試みる [.filename]#gettytab# の設定例を示しておきます。

[.programlisting]
....
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

もし、お使いの CPU が低速のものであったり、CPU に対する負荷が高い場合で、16550A 系のシリアルポートをお使いでない場合、 57.6 Kbps の接続において、`sio` の "silo" エラーが発生するかもしれません。

[[dialup-ttys]]
==== [.filename]#/etc/ttys#

[.filename]#/etc/ttys# ファイルの設定は、<<ex-etc-ttys>> で扱われています。 モデムの設定も似たようなものですが、`getty` に異なる引数を渡して、異なる端末種別を指定しなければなりません。 固定速度および可変速度両方に共通する形式は次のようになります。

[.programlisting]
....
ttyd0   "/usr/libexec/getty xxx"   dialup on
....

1 番目の項目は、このエントリで対象とするデバイススペシャルファイルです。 上の例では `ttyd0` として、 [.filename]#/dev/ttyd0# を `getty` に監視させることを表しています。2 番目の項目 `"/usr/libexec/getty xxx"` (_xxx_ は初期段階で使われる [.filename]#gettytab# のエントリに置き換えてください) が、`init` がこのディバイスに対して起動するプロセスです。3 番目の `dialup` は、デフォルトのターミナルタイプです。 4 番目の `on` は、 この行が有効であることを `init` に対して示しています。5 番目の項目に `secure` を指定することもできますが、これは、 たとえばシステムのコンソールのように、 物理的に安全な端末に対してのみ指定するようにしてください。

デフォルトのターミナルタイプ (上記の例では `dialup`) は、ローカルのユーザの好みによって異なってきます。 ユーザがログインスクリプトをカスタマイズして、ターミナルタイプが `dialup` の時には自動的に他のターミナルタイプを設定できるように、 ダイアルアップのポートのデフォルトのターミナルタイプには `dialup` が伝統的に用いられています。 しかし、筆者のサイトでは、ほとんどのユーザが VT102 エミュレーションを使っているので、 ダイアルアップのポートのデフォルトターミナルタイプとして `vt102` を指定しています。

[.filename]#/etc/ttys# の修正がすんだら、 以下のようなコマンドを使って `init` プロセスに HUP シグナルを送り、[.filename]#/etc/ttys# を読み込み直させてください。 

[source,shell]
....
# kill -HUP 1
....

ただ、もし初めてシステムを設定しているのであれば、 モデムが適切に設定されて接続されるまでは、 `init` に対してシグナルを送らない方がいいかもしれません。

===== 固定速度の設定

速度を固定する設定では、[.filename]#/etc/ttys# の中で、`getty` に対し て固定速度のエントリを指定する必要があります。たとえば、 以下の例はポートのスピードが 19.2 Kbps に固定されたモデムのための [.filename]#ttys# のエントリです。

[.programlisting]
....
ttyd0   "/usr/libexec/getty std.19200"   dialup on
....

モデムが異なる速度で固定されている場合は、 `std.19200` のかわりに `std.speed` を適切な値に置き換えたものにしてください。 [.filename]#/etc/gettytab# に挙がっている適切な種類を使うようにしてください。

===== 可変速度の設定

可変速度の設定では、[.filename]#ttys# のエントリが、[.filename]#/etc/gettytab# の中の適切な "自動速度調整" の初期設定のエントリを参照していなければな りません。 たとえば、もし前述の 19.2 Kbps から接続を試みる可変速度の設定例 (`V19200` の [.filename]#gettytab# エントリ)をそのまま _ttys_ に追加したのであれば、 [.filename]#ttys# エントリは以下のようになります。

[.programlisting]
....
ttyd0   "/usr/libexec/getty V19200"   dialup on
....

==== [.filename]#/etc/rc.serial#

V.32、V.32bis または V.34 モデムのような高速モデムを利用する場合、ハードウェア ([.filename]#RTS/CTS#) フロー制御を行う必要があります。FreeBSD kernel のモデムポートにハードウェアフロー制御のフラグを設定するための `stty` コマンドを、 [.filename]#/etc/rc.serial# に記述できます。

たとえば、シリアルポート 1 番 ([.filename]#COM2#) のダイヤルインおよびダイヤルアウト初期化デバイスに `termios` フラグ `crtscts` を設定するには、次の行を [.filename]#/etc/rc.serial# に追加するとよいでしょう。

[.programlisting]
....
# Serial port initial configuration
stty -f /dev/ttyid1 crtscts
stty -f /dev/cuai01 crtscts
....

=== モデムの設定

もし、あなたのモデムがパラメータを不揮発ラムに 保存できるタイプならば、MS-DOS 上の Telix や FreeBSD 上の `tip` などのような通信プログラム を使って、 パラメータを設定してください。`getty` が利用する初期速度でモデムに接続して、以下の条件を満たすよ うに不揮発ラムの設定を変更してください。

* 接続時に CD 信号がオンになる
* 接続時に DTR がオンになり、  オフで回線を切断しモ デムをリセットする。
* 送信時フロー制御には CTS を利用。
* XON/XOFF によるフロー制御を行わない。
* 受信時のフロー制御は RTS を使用。
* Quiet mode (リザルト コードを返さない)
* コマンド エコーを返さない。

これらを実現するためのコマンドやディップ スイッチの設定に関しては、モ デムのマニュアルを参照してください。

以下に、USRobotics Sportster の 14,400 bps の外づけモデムの設定例を示 しておきます。

[.programlisting]
....
ATZ
ATC1D2H1I0R2W
....

ことのついでに、たとえば、V42.bis や MNP5 のデータ圧縮を使用するかど うかなどのモデムの他の設定について確認、 調整しておくのもよいかもしれま せん。

さらに、USRobotics Sportster の 14,400 bps の外づけモデムでは、以下の ようなディップ スイッチの設定も必要です。他のモデムをお使いの方も、以 下の例を設定の参考にしてください。

* スイッチ 1: UP - DTR 標準
* スイッチ 2: N/A (リザルトコードを単語形式にするか数値形式にするか)
* スイッチ 3: UP - リザルトコードを返さない
* スイッチ 4: DOWN - コマンドエコーを返さない
* スイッチ 5: UP - 自動着信
* スイッチ 6: UP - CD 標準
* スイッチ 7: UP - 不揮発ラムからデフォルト値をロードする
* スイッチ 8: N/A (Smart Mode/Dumb Mode)

リザルト コードを返さないように設定しておかないと、 `getty` が誤っ て `login:` プロンプトをコマンド モードのモデムに送信してしまった場 合に、 モデムがこの入力をエコーしたり、この入力に対するリザルト コード を返してしまったりすることになります。この結果として、 モデムと `getty` の間で延々と無意味なやりとりが続いてしまう可能性があります。

==== 固定速度の設定

固定速度の設定では、 モデムとコンピュータ間の通信速度をモデムとモデム間 の接続速度に関係なく、常に一定に保つように、 モデムを設定する必要があり ます。USRobotics Sportster の 14,400 bps 外づけモデムの場合、以下のコ マンドで、 モデムとコンピュータ間の速度が、コマンド送信時の速度に固定さ れます。

[.programlisting]
....
ATZ
ATB1W
....

==== 可変速度の設定

可変速度の設定では、シリアル ポートの速度が、 着信速度に応じて変化する ように設定しなければいけません。 USRobotics Sporster の 14,400 bps 外 づけモデムの場合、 以下のコマンドで、エラー訂正機能を利用した通信の場合 は、 コマンドを送信した時の通信速度にシリアル ポートの速度を固定し、エ ラー訂正機能を利用しない接続では、 シリアル ポートの速度が変化するよう に設定されます。

[.programlisting]
....
ATZ
ATB2W
....

==== モデムの設定の確認

ほとんどの高速モデムには、 現在の設定をある程度人間にも理解できる形式に して表示させるコマンドがあります。USRobotics Sporster の 14,400 bps 外づけモデムの場合は、`ATI5` コマンドで、現在の不揮発ラムの設定を 表示することができます。 さらに、ディップ スイッチの設定も含めた現在の 設定を確認するためには、`ATZ` コマンドを送信してから、`ATI4` コマンドを送信してください。

他のメーカーのモデムをお使いの場合は、 モデムのマニュアルで設定値の確認 方法を確認してください。

=== トラブルシューティング

以下の手順でダイアル アップ モデムの動作を確認することができます。

==== FreeBSD システムの動作確認

モデムを FreeBSD システムに接続し、 システムをブートします。あなたのモ デムにモデムの状態を確認するためのインジケータがあれば、 DTR のイ ンジケータの状態に注目してください。もし、 システムのコンソールに `login:` プロンプトが表示された時に、DTR のインジケータが点灯 すれば、FreeBSD が適切なポートに対して `getty` を起動し、モデムへ の着信を待っている状態であることを意味しています。

もし DTR のインジケータが点灯しない場合は、システムのコンソールから FreeBSD にログインして、`ps ax` を実行し、 FreeBSD が適切なポートに対して``getty`` プロセスを起動しようとしているのかどうか確認してください。 プロセスに関する情報の中に、 以下のような行が表示されるはずです。

[source,shell]
....
  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1
....

モデムにまだ着信がない状態の時に、 以下のように上とは異なる出力があった 場合、`getty` は既にモデム ポートのオープンを終了したということに なります。 

[source,shell]
....
  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0
....

`getty` は、CD (carrier detect) 信号がオンの状態になるまで、 ポートのオープンを完了することはできませんので、 この場合は接続に問題が あるか、あるいはモデムの設定に問題があることが考えられます。 

もし、期待した [.filename]#ttydN# ポートをオープンしようとしている `getty` が見あたらない場合は、再度 [.filename]#/etc/ttys# の内容を確認し、 書式などに誤りがないか 調べてみてください。また、ログ ファイル [.filename]#/var/log/messages# に `init` および `getty` から何か出力がないかどうかも確認してみてく ださい。 もし何かメッセージが記録されていたら、再度 [.filename]#/etc/ttys#、 [.filename]#/etc/gettytab# の二つの設定ファイルと、 ディバイス スペシャルファイル [.filename]#/dev/ttydN# を確認し、 記述に誤りがないか、足りないエントリがないか、 足りないディバイス スペシャルファイルがないかといった 点について調べてみてください。

==== モデムで接続してみる

実際にモデムを使って別のコンピュータから 接続してみてください。この時、8 ビット、パリティなし、 1 ストップビットで接続するようにしてください。 接続後すぐにプロンプトが返ってこない場合や、 無意味な文字列が表示される 場合は、1秒に1回くらいの割合で Enter キーを押してみてください。 しばらくたって、なおも `login:` プロンプトが現れない場合 は、`BREAK` 信号を送信してみてください。この時、端末側で使って いるモデムが高速モデムならば、 このモデムのインタフェースの接続速度を固 定してから、 再度ダイアル インしてみてください。(たとえば、USRobotics Sportster の場合は、`ATB1`)

それでもまだ `login:` プロンプトが表示されない場合は、 [.filename]#/etc/gettytab# の以下の点について再度確認してみてください。

* [.filename]#/etc/ttys# の対応する行の 2番目の項目で、[.filename]#/etc/gettytab# の中で定義されているエントリが指定されているか
* 各 `nx=` で [.filename]#/etc/gettytab# の中で定義されているもの が指定されているか
* 各 `tc=` で [.filename]#/etc/gettytab# の中で定義されているもの が指定されているか

もしダイアル インしても、FreeBSD システム側のモデムが応答しない場合は、FreeBSD 側のモデムが DTR がオンになった時に電話にでるように設定さ れているかを確認してください。 もしモデムの設定に問題がなさそうならば、 モデムのインジケータ (がもしあれば) で、 DTR がオンになっているか を確認してください。

この確認のステップを数回繰り返しても うまくいかない場合は、一度休憩して、 しばらくたってから挑戦してみましょう。それでもだめなら、 おそらく {freebsd-questions} にあなたのモデムについての情報と問題を書いたメールを送れ ば、 メーリング リストのメンバーが問題の解決を助けるべく努力してくれる でしょう。

[[dialout]]
== ダイアルアウトサービス

以下はモデムを利用して他のコンピュータと 接続する方法を説明しています。 これはリモートホストとターミナル接続を確立するための 適切な方法です。

これは BBS に接続するときによく使います。

この種の接続は PPP 接続に問題がある場合、Internet 上にあるファイルを 転送するのに非常に役に立ちます。FTP で何らかのファイルを転送したいのに PPP 接続を確立できない場合は、ファイルを FTP 転送するためにターミナルセッション を利用します。そして ZMODEM を利用してファイルを転送します。

=== 私の Hayes モデムはサポートされていません、 どうすればよいでしょう?

実際、`tip` の マニュアルページは古くなっています。既に Hayes ダイアラが組み込まれています。[.filename]#/etc/remote# ファイル中で `at=hayes` を使ってください。

Hayes ドライバは、最近のモデムの新しい機能である ``BUSY``、``NO DIALTONE``、 ``CONNECT 115200``などのメッセージを 認識できるほど賢くはなく、単に混乱を起こすだけです。 ``tip``を使う場合には、 (``ATX0W`` とするなどして) これらの メッセージを表示させないようにしなくてはいけません。

また、`tip` のダイアルのタイムアウトは 60秒です。モデムの タイムアウト設定はそれより短くすべきであり、 そうしないと `tip` は通信に問題があると判断するでしょう。 `ATS7=45W` を実行してください。

[NOTE]
====
デフォルトの `tip` は、 Hayes モデムに完全に対応しているわけではありません。解決方法は [.filename]#/usr/src/usr.bin/tip/tip# の下の [.filename]#tipconf.h# を変更することです。 もちろんこれにはソース配布ファイルが必要です。

`#define HAYES 0` と記述されている行を `#define HAYES 1` と変更し、そして `make`, `make install` を実行します。これでうまく動作するでしょう。
====

[[direct-at]]
=== これらの AT コマンドを入力するには?

[.filename]#/etc/remote# ファイルの中で "direct" エントリを作ります。たとえばモデムが 1番目のシリアルポートである [.filename]#/dev/cuaa0# に接続されている場合、次のようにします:

[.programlisting]
....
cuaa0:dv=/dev/cuaa0:br#19200:pa=none
....

モデムがサポートする最大の bps レートを br フィールドに使います。そして `tip cuaa0` を実行すると、モデムが利用できるようになります。

[.filename]#/dev/cuaa0# がシステムに存在しない場合は、次のようにします:

[source,shell]
....
# cd /dev
# sh MAKEDEV cuaa0
....

または `root` になって以下のように `cu` コマンドを実行します:

[source,shell]
....
# cu -lline -sspeed
....

_line_ にはシリアルポートを指定します (例えば [.filename]#/dev/cuaa0#)。そして _speed_ には接続する速度を指定します (例えば `57600`)。その後 AT コマンドを実行したら、kbd:[~.] と入力すれば終了します。

=== pn 機能の `@` 記号が使えません!

電話番号 (pn) 機能の中での `@` 記号は、 tip に [.filename]#/etc/phone# にある電話番号を参照するように伝えます。しかし `@` の文字は [.filename]#/etc/remote# のような 設定ファイルの中では特殊文字となります。 バックスラッシュを使ってエスケープをおこないます:

[.programlisting]
....
pn=\@
....

=== コマンドラインから電話番号を指定するには?

"generic" エントリと呼ばれるものを [.filename]#/etc/remote# に追加します。 例えば次のようにします:

[.programlisting]
....
tip115200|Dial any phone number at 115200 bps:\
	    :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600bps:\
	    :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:
....

そして 

[source,shell]
....
# tip -115200 5551234
....

のように利用できます。 `tip` より `cu` を使いたい場合、 `cu` の generic エントリを使います。

[.programlisting]
....
cu115200|Use cu to dial any number at 115200bps:\
	:dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:
....

そして

[source,shell]
....
# cu 5551234 -s 115200
....

 と実行します。

=== 毎回 bps レートを入力しなければいけませんか?

`tip1200` や `cu1200` 用のエントリを記述し、適切な通信速度を br フィールドに設定します。`tip` は 1200 bps が正しいデフォルト値であるとみなすので、 `tip1200` エントリを参照します。もちろん 1200 bps を使わなければならないわけではありません。

=== ターミナルサーバを経由して複数のホストへアクセスしたいです

毎回接続されるのを待って `CONNECT host` と入力する かわりに、tip の `cm` 機能を使います。 例えば、[.filename]#/etc/remote# に次のようなエントリを追加します: 
[.programlisting]
....
pain|pain.deep13.com|Forrester's machine:\
	:cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
	:cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
	:dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

これで、`tip pain` や `tip muffin` と実行すると pain や muffin のホストに接続することができ、 `tip deep13` を実行するとターミナルサーバに接続します。

=== tip を使ってそれぞれのサイトの 複数の回線に接続できますか?

これは大学に電話回線がいくつかあって 数千人の学生が接続しようとする 場合によくある問題です。

あなたの大学のエントリを [.filename]#/etc/remote# ファイルに作成して、`pn` のフィールドには `@` を使います:

[.programlisting]
....
big-university:\
	:pn=\@:tc=dialout
dialout:\
	:dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:
....

そして [.filename]#/etc/phone# ファイルに大学の電話番号の一覧を書きます:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

`tip` は一連の電話番号を試みて、 最終的に接続できなければあきらめます。 リトライを続けさせたい場合は、`tip` を while ループに入れて 実行します。

=== kbd:[Ctrl+P] を 1 回送るために kbd:[Ctrl+P] を 2 度押す必要があるのはなぜ?

kbd:[Ctrl+P] はデフォルトの "force (強制)" 文字であり、 `tip` に次の文字が リテラルデータであることを伝えます。force 文字は "変数の設定" を意味する `~s` エスケープによって他の文字にすることができます。

`~sforce=single-char` と入力して改行します。_single-char_ は、任意の 1 バイト文字です。 _single-char_ を省略すると NUL 文字になり、これは kbd:[Ctrl+2] や kbd:[Ctrl+Space] を押しても入力できます。また、 _single-char_ に kbd:[Shift+Ctrl+6] を割り当てる方法を使っているターミナルサーバもあります。

[.filename]#$HOME/.tiprc# に次のように定義することで、任意の文字を force 文字として利用できます:

[.programlisting]
....
force=single-char
....

=== 打ち込んだ文字が突然すべて大文字になりました??

kbd:[Ctrl+A] を押してしまい、caps-lock キーが壊れている場合のために設計された `tip` の "raise character" モードに入ったのでしょう。 既に述べたように `~s` を使って、 `raisechar` をより適切な値に 変更してください。もしこれら両方の機能を使用しないのであれば、 force 文字と同じ設定にすることもできます。

以下は kbd:[Ctrl+2] や kbd:[Ctrl+A] などを頻繁に使う必要のある Emacs ユーザにうってつけの .tiprc ファイルのサンプルです。

[.programlisting]
....
force=^^
raisechar=^^
....

^^ は kbd:[Shift+Ctrl+6] です。

=== `tip` でファイルを転送するには?

もし他の Unix のシステムと接続しているなら、 `~p`(put) や `~t`(take) でファイルの送受信ができます。これらのコマンドは 相手のシステムの上で `cat` や `echo` を実行することで 送受信をします。 書式は以下のようになります:
`~p` ローカルのファイル名 [ リモートのファイル名 ]
`~t` リモートのファイル名 [ ローカルのファイル名 ]

この方法ではエラーチェックをおこないませんので、zmodem などの他のプロトコルを使った方がよいでしょう。

=== `tip` から zmodem を実行するには?

ファイルを受信するには、 リモート側で送信プログラムを起動します。そして `~C rz` と入力すると、ローカル側へのファイルの受信が 始まります。

ファイルを送信するには、 リモート側で受信プログラムを起動します。そして `~C sz files` と入力すると、 リモート側への ファイルの送信が始まります。

[[serialconsole-setup]]
== シリアルコンソールの設定

[[serialconsole-intro]]
=== 導入

FreeBSD は、 コンソールとしてシリアルポート上のダム端末しか持たないシステムでも起動します。 この様な構成はきっと次のような二種類の人達に便利でしょう。それは、 キーボードやモニタのないマシンに FreeBSD をインストールしたいシステム管理者と、 カーネルやデバイスドライバをデバッグしたい開発者です。

crossref:boot[boot,FreeBSD の起動のプロセス] で説明されているように、 FreeBSD は 3 ステージ構成のブートストラップを用いています。 最初の 2 つのステージは、 ブートディスクにある FreeBSD スライスの最初に格納されている、 ブートブロックのコードが行います。 それからブートブロックは、第 3 ステージのコードとしてブートローダ ([.filename]#/boot/loader#) を読み込み、実行します。

シリアルコンソールを設定するためには、ブートブロックコード、 ブートローダコード、カーネルを設定する必要があります。

[[serialconsole-howto]]
=== シリアルコンソールの設定

[.procedure]
====

. シリアルケーブルを用意してください。
+ 
ヌルモデムケーブル、 もしくは標準シリアルケーブルとヌルモデムアダプタが必要となります。 シリアルケーブルについては <<serial-cables-ports>> をご覧ください。
. キーボードをはずして下さい。
+ 
たいていの PC システムは Power-On Self-Test (POST) の間にキーボードを検出し、もし見つからなければエラーと なります。また、キーボードがないことを大きな音で知らせ、 キーボードが接続されるまでは起動を中断するようなマシンもあります。
+ 
コンピュータがエラーを表示していても、 とにかく起動するなら特別な対応は必要ありません (Phoenix BIOS を搭載しているマシンには、 `Keyboard failed` と表示されても、正常に起動するものがあります)。
+ 
あなたのコンピュータがキーボードを接続していない状態で 起動しないようなら、(もし可能ならば) エラーを無視するように BIOS を設定する必要があります。設定方法の詳細については、 マザーボードのマニュアルを調べてください。
+
[TIP]
======

BIOS の設定でキーボードを "Not installed" にするということは、キーボードを使えないということを 意味しているわけでは__ありません__。これは、BIOS がキーボードがなくても文句を言わないように、電源投入時には キーボードを探すな、と指示するだけです。このフラグを "Not installed" にしていてもキーボードを 接続したままにできますし、ちゃんと動作します。
======
+
[NOTE]
======
あなたのシステムが PS/2 マウスを使っているなら、 おそらくマウスもキーボード同様にはずす必要があるでしょう。 というのは、PS/2 マウスは部分的にキーボードとハードウェアを 共有しており、マウスを接続したままにしていると、 キーボードも存在する、と誤って検出してしまう可能性があるからです。 AMI BIOS を持つ Gateway 2000 Pentium 90MHz システム はこれに該当すると言われています。 一般的にこれは問題ではありません。なぜなら、どっちにしても マウスはキーボードなしではたいして役に立たないからです。
======
+
. [.filename]#COM1# ([.filename]#sio0#) にダム端末を接続してください。
+ 
ダム端末がなければ、かわりに古い PC/XT でモデム プログラムを走らせて使ったり、シリアルポートに他の Unix マシンを繋いだりできます。もしも [.filename]#COM1# ([.filename]#sio0#) がなければ、作成してください。 今のところ、[.filename]#COM1# 以外のポートを 選択するためにはブートブロックの再コンパイルが必要です。 すでに [.filename]#COM1# を他の装置に 使っていた場合は、一時的にその装置をはずして いったん FreeBSD がうまく動作してから、 新しいブートブロックとカーネルをインストールしてください。 (上記はとにかくファイル/演算/端末サーバの [.filename]#COM1# が利用可能であると仮定して います。あなたが本当に何かのために [.filename]#COM1# が必要 (で、なおかつその何かを [.filename]#COM2# ([.filename]#sio1#) に付け替えることができない) ならば、多分、そもそも 悩んでる場合ではありません。)
. カーネルコンフィグファイルの [.filename]#COM1# ([.filename]#sio0#) に適切なフラグを 設定していることを確認してください。
+ 
関連するフラグ:
+
`0x10`:::
このポートのコンソールサポートを有効にします。 このフラグが設定されない場合、他のフラグは無視されます。 現在のところ、一つのポートしかコンソールサポートを有効に できません。(config ファイルに書かれた順番で) 最初にこのフラグを 指定されたポートが選択されます。 なお、このオプションを指定するだけでシリアルポートが コンソールとして使えるわけではありません。 このフラグと一緒に、以下のフラグも指定するかもしくは `-h` オプションも使ってください。

`0x20`:::
後述される `-h` オプション を無視して、(他に優先度の高いコンソールがない限り) このポートをコンソールとして指定します。 このフラグは FreeBSD バージョン 2._X_ の `COMCONSOLE` オプションに対応するものです。 フラグ `0x20` は必ず フラグ `0x10` と一緒に指定されなければなりません。

`0x40`:::
(`0x10` と組み合わせることで) このポートを予約し、通常のアクセスができない ようにします。 このフラグは、シリアルコンソールとして使いたいポートに 指定すべきではありません。 唯一の使い道は、ユニットがカーネルのリモートデバッグ用 であることを指定することです。 リモートデバッグの詳細については extref:{developers-handbook}[The Developer's Handbook] を参照してください。
+
[NOTE]
======
FreeBSD 4.0 以降では、 フラグ `0x40` の意味が若干異なり、 シリアルポートにリモートデバッグを指定するためには、 別のフラグを使います。
======
+ 
例:
+
[.programlisting]
....
device sio0 at isa? port "IO_COM1" tty flags 0x10 irq 4
....
+ 
詳細については man:sio[4] のマニュアルを参照してください。
+ 
もしこれらのフラグがセットされていなければ、(別のコンソールで) UserConfig を実行するか、 カーネルを再コンパイルする必要があります。
. ブートドライブの `a` パーティションの ルートディレクトリに [.filename]#boot.config# を作成してください。
+ 
このファイルは、ブートブロックコードに対してどのように システムを起動したいかを教えます。 シリアルコンソールを活かすためには、以下のオプションを幾つか - 複数の場合も一行で、設定する必要があります:
+
`-h`:::
内蔵コンソールとシリアルコンソールの切替えを行います。 これを使用してコンソールデバイスを変更できます。 例えば、内蔵 (ビデオ) コンソールからブートした場合、 カーネルとブートローダがコンソールデバイスとして シリアルポートを使用するようにするため、 `-h` を使って指示できます。 反対に、シリアルポートからブートした場合、 ブートローダとカーネルがコンソールとして代わりに ビデオディスプレイを使用するようにするため、 `-h` を使用できます。

`-D`:::
シングルとデュアルのコンソール設定を切り替えます。 シングル設定では、上記の `-h` オプションの状態によって、コンソールは内蔵コンソール (ビデオディスプレイ)かシリアルポートのいずれかになります。 デュアルコンソール設定では、ビデオディスプレイと シリアルポートの両方が、`-h` オプションの状態によらず、同時にコンソールになります。 しかし、デュアルコンソール設定は、ブートブロックが 実行されている間でしか効果を持ちません。 一旦ブートローダに制御が移ると、`-h` オプションによって指定されたコンソールが 唯一のコンソールになります。

`-P`:::
ブートブロックがキーボードを検出するようにします。 キーボードが発見できなかった場合には、 `-D` と `-h` オプションが自動的にセットされます。
+
[NOTE]
======
現バージョンのブートブロックでは容量の制限により、 `-P` オプションは拡張キーボードしか 検出できません。キーが 101 個より少ない (そして F11 と F12 がない) キーボードは検出されない可能性があります。 この制限から、いくつかのラップトップコンピュータの キーボードは正しく検出されないでしょう。 もし、あなたのシステムがこのようなキーボードを使っているのであれば、 `-P` オプションを外してください。 残念ながら、この問題の回避策はありません。
======
+ 
`-P` オプションを使ってコンソールを 自動的に選ぶか、`-h` オプションを使って シリアルコンソールを有効にしてください。
+ 
さらに man:boot[8] で説明されている他のオプションも使う ことができます。
+ 
`-P` 以外のオプションはブートローダ ([.filename]#/boot/loader#) に渡されます。 ブートローダは、`-h` オプションだけの状態を 調べることで内蔵ビデオとシリアルポートのどちらがコンソールに なるのか決めます。 つまり、[.filename]#/boot.config# の中で `-D` オプションを指定して `-h` オプションを指定しなかった場合、 ブートブロック実行中でのみシリアルポートをコンソールとして 使うことができます。ブートローダは内蔵ビデオディスプレイを コンソールとして使います。
. マシンを起動する。
+ 
FreeBSD を起動したとき、ブートブロックは [.filename]#/boot.config# の内容をコンソールに表示 します。例えば、
+
[source,shell]
....
/boot.config: -P
Keyboard: no
....
+ 
行の二番目は、 [.filename]#/boot.config# にオプション `-P` が指定してあるときだけ表示され、 キーボードが存在するかどうかを表します。 これらのメッセージは、シリアルか内蔵のいずれか、 あるいはその両方のコンソールに表示されます。 どちらに表示されるかは、 [.filename]#/boot.config# の設定によって変わります。
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| オプション指定
| メッセージの表示される場所

|なし
|内蔵

|`-h`
|シリアル

|`-D`
|シリアルと内蔵の両方

|`-Dh`
|シリアルと内蔵の両方

|`-P`、キーボードが存在する場合
|内蔵

|`-P`、キーボードが存在しない場合
|シリアル
|===
+ 
このメッセージが表示された後、 ブートブロックがブートローダのロードを再開し、 他の全てのメッセージがコンソールに表示されるまで、 若干時間がかかります。通常の環境では、ブートブロックに 割り込みをかける必要はありませんが、 ちゃんとセットアップされているかどうか確かめるために、 割り込みをかけることができるようになっています。
+ 
ブートプロセスに割り込みをかけるには、 コンソールの (Enter 以外の) キーをたたいて下さい。 ブートブロックはその時、操作を指定するためのプロンプトを表示します。 こんな風に表示されるでしょう。 
+
[source,shell]
....
>> FreeBSD/i386 BOOT
Default: 0:wd(0,a)/boot/loader
boot:
....
+ 
上に示したメッセージが、シリアルか内蔵、 あるいはその両方といった、[.filename]#/boot.config# で指定したとおりのコンソールに表示されることを確認して下さい。 メッセージが正しいコンソールに表示されたら、 Enter キーを押してブートプロセスを継続してください。 
+ 
もし、シリアルコンソールを利用するように設定しているのに シリアル端末にプロンプトが出てこない場合は、 設定のどこかに間違いがあります。 ブートブロック(とブートローダ、カーネル)に対して シリアルポートをコンソールに使うことを伝えるため、 割り込みをかけた時に `-h` を入力し、 (可能ならば) Enter/Return キーを押して下さい。そして、 一度システムを起動させてから、どこが悪いのかをチェックして下さい。
====

ブートローダがロードされ、ブートプロセスの第三ステージに いる時には、まだ内蔵コンソールとシリアルコンソールを切り替えることができます。 それにはブートローダの環境変数を適切に設定すれは良いのですが、 詳細については <<serialconsole-loader>> を参照してください。

[[serialconsole-summary]]
=== まとめ

このセクションで扱ったさまざまな設定と、 最終的に選択されるコンソールに関するまとめです。

==== Case 1: [.filename]#sio0# の flags に 0x10 をセットした場合

[.programlisting]
....
device sio0 at isa? port "IO_COM1" tty flags 0x10 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
| /boot.config 内のオプション
| ブートブロック実行中のコンソール
| ブートローダ実行中のコンソール
| カーネルのコンソール

|なし
|内蔵
|内蔵
|内蔵

|`-h`
|シリアル
|シリアル
|シリアル

|`-D`
|内蔵、シリアルの両方
|内蔵
|内蔵

|`-Dh`
|内蔵、シリアルの両方
|シリアル
|シリアル

|`-P`、キーボードが存在する場合
|内蔵
|内蔵
|内蔵

|`-P`、キーボードが存在しない場合
|内蔵、シリアルの両方
|シリアル
|シリアル
|===

==== Case 2: sio0 の flags に 0x30 をセットした場合

[.programlisting]
....
device sio0 at isa? port "IO_COM1" tty flags 0x30 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
| /boot.config 内のオプション
| ブートブロック実行中のコンソール
| ブートローダ実行中のコンソール
| カーネルのコンソール

|なし
|内蔵
|内蔵
|シリアル

|`-h`
|シリアル
|シリアル
|シリアル

|`-D`
|内蔵、シリアルの両方
|内蔵
|シリアル

|`-Dh`
|内蔵、シリアルの両方
|シリアル
|シリアル

|`-P`、キーボードが存在する場合
|内蔵
|内蔵
|シリアル

|`-P`、キーボードが存在しない場合
|内蔵、シリアルの両方
|シリアル
|シリアル
|===

[[serialconsole-tips]]
=== シリアルコンソールを利用する上で役に立つ情報

==== シリアルポートの通信速度をもっと速いものに設定するには

デフォルトのシリアルポート通信速度は、9600 ボー、 8 ビット、パリティなし、ストップビット 1 です。 通信速度を変更したい場合には、少なくとも ブートブロックの再コンパイルが必要になります。 [.filename]#/etc/make.conf# に次のような行を追加して、 新しくブートブロックをコンパイルして下さい。

[.programlisting]
....
BOOT_COMCONSOLE_SPEED=19200
....

もし、シリアルコンソールがブート時の `-h` オプション以外の方法で設定されていたり、 カーネルが利用するシリアルコンソールが ブートブロック実行中のものと異なる場合には、 カーネルコンフィグレーションファイルに次のオプションを追加して、 新しくカーネルをコンパイルしなければなりません。

[.programlisting]
....
options CONSPEED=19200
....

[[serialconsole-com2]]
==== [.filename]#sio0# 以外のシリアルポートを コンソールとして使うには

[.filename]#sio0# 以外のポートをコンソールとして使うには、再コンパイルが必要です。 それがどんな理由であれ、他のポートを使用する場合には ブートブロック、ブートローダ、カーネルを 次のようにして再コンパイルして下さい。

[.procedure]
====

. カーネルソースを取得する (crossref:cutting-edge[updating-upgrading,FreeBSD のアップデートとアップグレード] をご覧ください)。
. [.filename]#/etc/make.conf# を編集し、 `BOOT_COMCONSOLE_PORT` に 使用したいポートのアドレス(0x3F8、0x2F8、0x3E8 or 0x2E8)を 設定してください。使用可能なのは [.filename]#sio0# から [.filename]#sio3# ([.filename]#COM1# から [.filename]#COM4#) までで、 マルチポートシリアルカードは使えません。 また、ここで割り込みの設定をする必要はありません。
. 設定を変更するために新たなカーネルコンフィグレーションファイルを作成し、 使いたいシリアルポートのフラグを適切に設定します。 例えば、[.filename]#sio1# ([.filename]#COM2#) をコンソールにしたければ、
+
[.programlisting]
....
device sio1 at isa? port "IO_COM2" tty flags 0x10 irq 3
....
+ 
または、
+
[.programlisting]
....
device sio1 at isa? port "IO_COM2" tty flags 0x30 irq 3
....
+ 
とします。その際、 他のシリアルポートにコンソールフラグをつけてはいけません。
. ブートブロックを再コンパイルし、インストールする。
+
[source,shell]
....
# cd /sys/boot/i386/boot2
# make
# make install
....
+
. ブートローダを再コンパイルし、インストールする。
+
[source,shell]
....
# cd /sys/boot/i386/loader
# make
# make install
....
+
. カーネルを再構築し、インストールする。
. man:disklabel[8] を使ってブートブロックをブートディスクに書き込み、 新しいカーネルから起動する。
====

==== シリアルポートから DDB デバッガを起動するには

シリアルコンソールからカーネルデバッガを起動したい(これは リモートで診断する際に便利ですが、もしおかしな BREAK 信号がシリアルポートに送られるような場合には危険です!) 場合には、次のオプションを使ってカーネルをコンパイルして下さい。 

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....

==== シリアルコンソールにログインプロンプトを表示させるには

シリアルコンソールからブートメッセージを確認したり、 シリアルコンソールを経由してカーネルデバッグセッションに入ることが できるので、これは必要がないかもしれませんが、 _login_ プロンプトをシリアルポートに 出力するように設定することもできます。 これには、次のようにします。

エディタで [.filename]#/etc/ttys# というファイルを開き、 次に示す行に移動して下さい。

[.programlisting]
....
ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure
....

`ttyd0` から `ttyd3` は、 [.filename]#COM1# から [.filename]#COM4# に対応しています。 設定したいポートの `off` を `on` に変更して下さい。 また、もしシリアルポートの通信速度を変更しているなら、 `std.9600` が実際の通信速度になるように、 例えば `std.19200` のように変更して下さい。

さらに、実際のシリアル端末に合わせて、 端末タイプを `unknown` から変更することも可能です。 

ファイルの編集が終了したら、 変更を有効化するために `kill -HUP 1` を実行しなければなりません。

[[serialconsole-loader]]
=== ブートローダからコンソールを変更するには

前セクションは、ブートブロックの設定を変更することでシリアルコンソールを セットアップする方法について解説していました。 このセクションでは、ブートローダへのコマンド入力と環境変数設定で コンソールの指定を行なう方法を紹介します。 ブートローダがブートブロックの後、 ブートプロセスの第三ステージで呼び出されたとき、 ブートローダの設定には、ブートブロックの設定がそのまま使われます。 

==== シリアルコンソールをセットアップする

ブートローダとカーネルに対して シリアルコンソールを使用するように設定するには、 単に [.filename]#/boot/loader.rc# のファイルに、次のような一行を書くだけで実現できます。

[.programlisting]
....
set console=comconsole
....

これは、前セクションで扱ったブートブロックの設定に 全く関係なく機能します。

上に示した行は、 [.filename]#/boot/loader.rc# の最初の行に書き込まなくてはいけません。 これはできるだけ早く、ブートメッセージをシリアルコンソールに 出力させるために必要なことです。

同様にして、次のように内蔵コンソールを指定することもできます。

[.programlisting]
....
set console=vidconsole
....

もし、ブートローダの環境変数 `console` が設定されていない場合、 ブートローダ、そしてその次に起動するカーネルは ブートブロックで指定された `-h` オプションに 示されたコンソールを使用します。 

3.2 以降のバージョンにおいては [.filename]#/boot/loader.rc# ではなく、 [.filename]#/boot/loader.conf.local# や [.filename]#/boot/loader.conf# にコンソール指定を書き込みます。 その場合、 [.filename]#/boot/loader.rc# は次のようになっていなければなりません。 

[.programlisting]
....
include /boot/loader.4th
start
....

それから、[.filename]#/boot/loader.conf.local# を作成して、次の行をそこに追加して下さい。 

[.programlisting]
....
console=comconsole
....

か、もしくは

[.programlisting]
....
console=vidconsole
....

です。詳細については、man:loader.conf[5] を参照して下さい。

[NOTE]
====
その際、ブートローダはオプション指定なし (ブートブロックに `-P` オプションが指定されたのと等価)になり、 キーボードの存在を調べて 内蔵コンソールとシリアルコンソールを自動的に選択する機能は働きません。
====

==== [.filename]#sio0# 以外のシリアルポートを コンソールとして使うには

[.filename]#sio0# 以外のシリアルポートを コンソールとして使うには、ブートローダを再コンパイルする必要があります。 それには、 <<serialconsole-com2>> に書かれている説明にしたがって下さい。

[[serialconsole-caveats]]
=== 注意

シリアルコンソールというアイデアは、 グラフィック出力用のハードウェアやキーボードが接続されていない 専用サーバのセットアップを可能にするためのものです。 ほとんどのシステムはキーボードなしで起動できますが、 不幸にも、グラフィックアダプタなしでは起動できないシステムはたくさんあります。 AMI BIOS を採用しているマシンでは、CMOS 設定の `graphics adapter` を `Not Installed` にするだけで、 グラフィックアダプタがなくとも起動できるように設定することができます。

しかしながら、多くのマシンはこのようなオプションを持っていませんし、 ディスプレイハードウェアがシステムに存在しないと起動しないように なっています。そのようなマシンでは、 モニタを接続する必要がなかったとしても、 適当なグラフィックカード(モノクロのジャンク品でも構いません)を 挿入したままにしておく必要があるでしょう。 また、AMI BIOS をインストールする、という手もあります。
