---
title: 第5章 X Window System
part: パートI. 導入
prev: books/handbook/ports
next: books/handbook/partii
description: この章では、グラフィカル環境で使われるオープンソースの X Window System を提供する Xorg のインストールおよび設定方法について説明します。
tags: ["X11", "Xorg", "TrueType", "DE", "KDE", "Plasma", "Xfce", "Gnome", "XDM", "SDDM", "GDM", "KMS", "Intel", "AMD", "NVIDIA", "Anti-Aliased"]
showBookMenu: true
weight: 7
path: "/books/handbook/"
---

[[x11]]
= X Window System
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 5
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/x11/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[x11-synopsis]]
== この章では

bsdinstall を用いた FreeBSD のインストールでは、 グラフィカルユーザインタフェースは自動的にはインストールされません。 この章では、グラフィカル環境で使われるオープンソースの X Window System を提供する Xorg のインストールおよび設定方法について説明します。 その後、 デスクトップ環境およびウィンドウマネージャの探し方およびインストール方法について説明します。

[NOTE]
====
Xorg を自動的に設定するインストール方法を希望するユーザは、link:https://ghostbsd.org[GhostBSD], link:https://www.midnightbsd.org[MidnightBSD] または link:https://nomadbsd.org/[NomadBSD] を参照してください。
====

Xorg が対応するビデオハードウェアについてのより多くの情報は、 link:http://www.x.org/[x.org] のウェブサイトをご覧ください。

この章を読めば以下のことがわかります。

* X Window System のさまざまなコンポーネントと、 それらが互いにどのように連携しているか。
* Xorg のインストールおよび設定方法
* さまざまなウィンドウマネージャおよびデスクトップ環境のインストールおよび設定方法
* Xorg での TrueType(R) フォントの使い方
* GUI ログイン (XDM) の設定方法

この章を読み始める前に以下のことを理解しておく必要があります。

* crossref:ports[ports,アプリケーションのインストール - packages と ports] で説明されているサードパーティ製ソフトウェアのインストール方法

[[x-understanding]]
== 用語の説明

X Window System のさまざまなコンポーネントについての詳細や、 それらがどのようにやり取りするかについてすべて理解する必要はありませんが、 これらのコンポーネントについて基本的なことを知っていると、 強力な武器になるでしょう。

X サーバ::
X は最初からネットワークを意識してデザインされており、 "クライアント - サーバ" モデルを採用しています。 このモデルでは、"X サーバ" はキーボードやモニタ、 マウスが接続されたコンピュータ上で動きます。 このサーバはディスプレイの表示を管理したり、キーボード、 マウスからの入力を処理したり、 タブレットやビデオプロジェクタ等の他の装置からの入出力を処理します。 これは、ある人々を混乱させることがあります。 X での用語は彼らが想定するものとは正反対だからです。 彼らは "X サーバ" は地下にある大きなパワフルなマシンであり、 "X クライアント" が自分たちのデスク上にあると想像するのです。

X クライアント::
XTerm や Firefox などの各 X アプリケーションは、 "クライアント" になります。 クライアントは "この座標にウィンドウを描いてください" といったメッセージをサーバへ送り、サーバは "ユーザが OK ボタンを押しました" といったメッセージを送り返します。
+
家庭や小さなオフィスのような環境では、X サーバと X クライアントは通常同じコンピュータ上で動いています。 X サーバを非力なコンピュータで動かし、 X アプリケーションをより高性能なマシンで動かすことも可能です。 この場合、 X のクライアントとサーバの通信はネットワーク越しに行なわれます。

ウィンドウマネージャ::
X はスクリーン上でウィンドウがどのように見えるべきか、 マウスでそれらをどうやって動かすか、 ウィンドウ間を移動するのにどういうキーストロークを使うべきか、 各ウィンドウのタイトルバーはどのように見えるべきか、 クローズボタンを持つべきかどうか、 といったことは規定しません。そのかわりに、X ではそういったことを "ウィンドウマネージャ" と呼ばれるアプリケーションに任せます。link:http://www.xwinman.org/[ウィンドウマネージャはたくさん] あります。 これらのウィンドウマネージャの見た目や使い勝手はそれぞれ異なっています。 バーチャルデスクトップをサポートしているものもありますし、 デスクトップを操作するキーストロークをカスタマイズできたり、 "スタート" ボタンやそれに類するものを持っているものもあります。 テーマに対応しており、 デスクトップの見た目や使い勝手を完全に変えられるものもあります。 ウィンドウマネージャは Ports Collection の [.filename]#x11-wm# カテゴリに用意されています。
+
それぞれのウィンドウマネージャは異なる設定機構を備えています。 手で設定ファイルを編集しなければならないものや、 設定作業のほとんどを GUI ツールで行うことができるものもあります。

デスクトップ環境::
KDE や GNOME は、デスクトップ環境です。 これらは、共通のデスクトップのタスクを実行するための完全なアプリケーションスイートを含んでいます。 オフィススイート、ウェブブラウザやゲームを含んでいるものもあります。

フォーカスポリシ::
ウィンドウマネージャは、 マウスのフォーカスポリシに責任を持ちます。 このポリシは、どのウィンドウがアクティブにキーストロークを 受け付けるようにするための方法を提供し、 そして、どのウィンドウがアクティブなのかを示します。
+
よく知られているフォーカスポリシは "click-to-focus" と呼ばれるものです。 このポリシは、 あるウィンドウ内でマウスをクリックすればそのウィンドウがアクティブになる、 というものです。 "focus-follows-mouse" ポリシでは、 マウスポインタの下にいるウィンドウがフォーカスされるというものです。 フォーカスを変えるには他のウィンドウにマウスポインタを動かすだけです。 マウスがルートウィンドウに移動した時には、 このウィンドウがフォーカスされます。 "sloppy-focus" モデルでは、 マウスがルートウィンドウに移動した時には、 直前に使われていたウィンドウがフォーカスされています。 sloppy-focus では、 ポインタが別のウィンドウに移った時のみフォーカスが変わり、 現在のウィンドウから出ただけでは変わりません。 "click-to-focus" ポリシでは、 マウスクリックによりアクティブなウィンドウが選択されます。 ウィンドウは前面に表示され、他のすべてのウィンドウの前にきます。 ポインタが別のウィンドウ上に移動した時でも、 すべてのキーストロークがこのウィンドウに届きます。
+
それぞれのウィンドウマネージャは、 それぞれのフォーカスポリシに対応しています。 すべてのものは click-to-focus をサポートしていますし、 多くのものは他の方法もサポートしています。 どのフォーカスモデルを利用可能かどうかについては、 ウィンドウマネージャのドキュメントをご覧ください。

ウィジェット::
ウィジェットはクリック可能であったり、 他の方法で操作可能なすべてのユーザインタフェース用アイテムを指す用語です。 ボタンやチェックボックス、ラジオボタン、アイコン、リスト、などがそうです。 ウィジェットツールキットはグラフィカルアプリケーションを作成するために使われます。 KDE で使われている Qt や GNOME プロジェクトで使われている GTK+ といった有名なウィジェットセットがあります。 そのため、アプリケーションのルックアンドフィールは、 アプリケーションを作成するのに使われたウィジェットツールキットに依存し、 異なります。

[[x-install]]
== Xorg のインストール

FreeBSD では、Xorg を package または port からインストールできます。

バイナリ package を使うと早くインストールできますが、 カスタマイズのためのオプションは少なくなります。

[source,shell]
....
# pkg install xorg
....

Ports Collection からビルドしてインストールするには、 以下のように実行してください。

[source,shell]
....
# cd /usr/ports/x11/xorg
# make install clean
....

どちらの方法でも、完全な Xorg システムがインストールされます。 バイナリ package を用いる方法が、 ほとんどのユーザにとってはベストな選択となります。

経験のあるユーザ向けの最小の X システムは、[.filename]#x11/xorg-minimal# です。 ほとんどのドキュメント、 ライブラリおよびアプリケーションはインストールされません。 アプリケーションによってはこれらの追加の要素が機能する上で必要となります。

[[x-config]]
== Xorg の設定

[[x-config-quick-start]]
=== クィックスタート

Xorg は、 標準的なほとんどのビデオカード、 キーボード、ポインティングデバイスに対応しています。

[TIP]
====
ビデオカード、キーボード、入力デバイスは、 自動的に検出されるので、手動の設定は必要ありません。 自動認識に失敗したとき以外は、[.filename]#xorg.conf# を作成したり、`-configure` プロセスの実行は行わないでください。
====

[.procedure]
====
. もし、使用しているコンピュータですでに Xorg が使われているのであれば、 コンフィグレーションファイルを移動するか、削除してください。
+
[source,shell]
....
# mv /etc/X11/xorg.conf ~/xorg.conf.etc
# mv /usr/local/etc/X11/xorg.conf ~/xorg.conf.localetc
....

. 3D アクセラレータを利用できるシステムでは、 Xorg を実行するユーザを `video` または `wheel` グループに追加して、使用できるようにしてください。 ユーザ _jru_ をどちらのグループでも利用できるようにするには以下のように実行してください。
+
[source,shell]
....
# pw groupmod video -m jru || pw groupmod wheel -m jru
....

. デフォルトでは twm ウィンドウマネージャがインストールされています。 Xorg が起動すると、 このウィンドウマネージャが立ち上がります。
+
[source,shell]
....
% startx
....

. 古いバージョンの FreeBSD では、 テキストコンソールに戻れるようにするために、 システムコンソールは man:vt[4] に設定する必要があります。 <<x-config-kms>> を参照してください。
====

[[x-config-user-group]]
=== Accelerated Video のためのユーザグループ

ビデオカードの 3D アクセラレータを有効にするには、 [.filename]#/dev/dri# へのアクセスが必要となります。 通常は、X を実行するユーザを `video` または `wheel` グループに追加するするだけです。 ここでは、man:pw[8] を使ってユーザ _slurms_ を `video` グループ、または `video` グループが存在しない時に、 `wheel` グループに追加しています。

[source,shell]
....
# pw groupmod video -m slurms || pw groupmod wheel -m slurms
....

[[x-config-kms]]
=== Kernel Mode Setting (KMS)

コンピュータが、コンソールの表示から、 X 用の高解像度の表示へと切り替える時には、 ビデオの出力 _mode_ が設定されている必要があります。 最近の Xorg では、 カーネル内部のシステムを使って効率的にこれらのモードの変換をしています。 古いバージョンの FreeBSD では、 KMS システムを用いない man:sc[4] が使用されています。 X を閉じた後、システムコンソールは動作をしていても、 表示に黒になります。 新しい man:vt[4] コンソールではこの問題は起こりません。

以下の行を [.filename]#/boot/loader.conf# に追加して man:vt[4] を有効にしてください。

[.programlisting]
....
kern.vty=vt
....

[[x-config-files]]
=== コンフィグレーションファイル

通常、この節で説明する手動の設定は必要ありません。 自動認識に失敗したとき以外は、 手動で設定ファイルを作成しないでください。

[[x-config-files-directory]]
==== ディレクトリ

Xorg は、 複数のディレクトリから設定ファイルを探します。 FreeBSD において、設定ファイルのディレクトリは、 [.filename]#/usr/local/etc/X11/# が推奨されます。 このディレクトリを使うことで、 アプリケーションのファイルをオペレーティングシステムとは区別する事になります。

昔のコンフィグレーションファイルの置き場である [.filename]#/etc/X11/# も機能します。 しかしながら、この場所に置くと、アプリケーションファイルと FreeBSD システムのファイルが混ざってしまうため、推奨されません。

[[x-config-files-single-or-multi]]
==== 単一または複数ファイル

複数のファイルを用いて、 各ファイルが特定の部分を設定するようにすると、 古い単一の [.filename]#xorg.conf# を用いるよりも設定が簡単になります。 これらのファイルは、 メインのコンフィグレーションファイルのディレクトリの [.filename]#xorg.conf.d/# サブディレクトリに置かれます。 フルパスは、一般的に [.filename]#/usr/local/etc/X11/xorg.conf.d/# となります。

これらのファイルの例は、この節の後半で説明します。

古い単一の [.filename]#xorg.conf# も機能しますが、 [.filename]#xorg.conf.d/# サブディレクトリに複数のファイルで設定する形式に比べると、 柔軟ではなく、わかりにくいものとなります。

[[x-config-video-cards]]
=== ビデオカード

Ports のフレームワークは、X11 が最近のハードウェア上で動作するために必要となる drm グラフィックドライバを提供します。
そのようなドライバとしては、package:graphics/drm-kmod[] で提供されるドライバがあります。
これらのドライバは、通常プライベートなカーネルのインタフェースを使用するため、`PORTS_MODULES` 変数を利用して ports システムのドライバを構築することが強く推奨されています。
`PORTS_MODULES` に設定されたカーネルモジュールを含む port は、カーネルを構築するたびに、アップデートされたソースに対応するよう再構築されます。
これにより、カーネルモジュールはカーネルと同期することが保証されます。
カーネルと ports ツリーは最大限に互換性を持つように共にアップデートされる必要があります。
[.filename]#/etc/make.conf# ファイルで `PORTS_MODULES` を設定することで、カーネルを構築する際に、設定されたモジュールも再構築されるようになります。
上級のユーザの中には、カーネルコンフィグレーションファイルに `makeoptions` ディレクティブで追加するユーザもいます。
GENERIC を走らせていて、freebsd-update を使用している場合には、`freebsd-update install` 実行後に [.filename]#graphics/drm-kmod# または [.filename]#x11/nvidia-driver# port を構築してください。

[example]
====
[.filename]#/etc/make.conf#

[.programlisting]
....
SYSDIR=path/to/src/sys
PORTS_MODULES=graphics/drm-kmod x11/nvidia-driver
....
この設定はすべてを再構築します。
使用している GPU /グラフィックカードに応じて、ひとつだけ選択したり、別のドライバを選択できます。
====

[[x-config-video-cards-ports]]
Intel KMS driver::
Intel(R) が提供しているほとんどの Intel KMS driver グラフィックカードは、2D および 3D アクセラレーションに対応しています。
+
ドライバ名: `i915kms`
+
AMD(R) が提供している古い Radeon KMS driver グラフィックカードのほとんどは、2D および 3D アクセラレーションに対応しています。
+
ドライバ名: `radeonkms`
+
AMD(R) が提供している新しい Radeon KMS driver グラフィックカードのほとんどは、2D および 3D アクセラレーションに対応しています。
+
ドライバ名: `amdgpu`
+
参考として、対応している GPU 一覧を link:https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units[] または link:https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units[] でご覧ください。

[[x-config-video-cards-intel]]
Intel(R)::
Iron Lake (HD Graphics) および Sandy Bridge (HD Graphics 2000) を含む Ivy Bridge (HD Graphics 2500, 4000, および P4000) までのほとんどの Intel(R) グラフィックスは、3D acceleration に対応しています。
+
ドライバ名: `intel`
+
参考情報については link:https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units[] をご覧ください。

[[x-config-video-cards-radeon]]
AMD(R) Radeon::
ATI/Radeon: 2D および 3D acceleration は、 HD6000 シリーズまでのほとんどの Radeon カードで対応しています。
+
ドライバ名: `radeon`
+
参考情報については link:https://en.wikipedia.org/wiki/List_of_AMD_graphics_processing_units[] をご覧ください。

[[x-config-video-cards-nvidia]]
NVIDIA::
NVIDIA: いくつかの NVIDIA ドライバが Ports Collection の [.filename]#x11# カテゴリから利用できます。 ビデオカードのモデルに対応するドライバをインストールしてください。
+
参考情報については link:https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units[] をご覧ください。
+
NVIDIA カードに対応しているカーネルは [.filename]#x11/nvidia-driver# port または [.filename]#x11/nvidia-driver-xxx# port にあります。
最新のカードは、前者の port を使います。
古いカードは、-xxx ports を使うことになります。
ここで xxx はドライバのバージョンを表す 304, 340 または 390 のどれかです。
これらのドライバを使うには、 http://download.nvidia.com/XFree86/FreeBSD-x86_64/465.19.01/README/[対応している NVIDIA GPU プロトコル] ページを参照して、`-xxx` の部分を埋めてください。
このページには、ドライバの各バージョンが対応しているデバイスの一覧があります。
昔のドライバは i386 および amd64 で動作します。
現在のドライバは amd64 のみに対応しています。
詳細については、 http://download.nvidia.com/XFree86/FreeBSD-x86_64/465.19.01/README/[NVIDIAドライバのインストールおよび設定] を参照してください。
ドライバが最大限に安全に動作するように、カーネルを再構築すたびにドライバを再構築することが推奨されていますが、このドライバはプライベートのカーネルインタフェースをほとんど使わないため、通常はカーネルがアップデートしても安全に使用できます。

[[x-config-video-cards-hybrid]]
ハイブリッドグラフィックス::
ノートブックコンピュータによっては、 チップセットまたはプロセッサに組み込まれているグラフィックプロセッサユニットの他に、 追加でそれらを持つものがあります。 _Optimus_ は、 Intel(R) と NVIDIA ハードウェアを組み合わせています。 _Switchable Graphics_ または、 _Hybrid Graphics_ は、 Intel(R) または AMD(R) プロセッサと AMD(R) Radeon GPU を組み合わせています。
+
これらのハイブリッドなグラフィックシステムの実装は、 システムごとに異なるので、 FreeBSD の Xorg は、 これらのすべてのバージョンについて対応しているわけではありません。
+
コンピュータによっては、 片方のグラフィックアダプタを無効にしたり、 標準のビデオカードドライバの一つとともに使われる _discrete_ モードを選択できるような BIOS オプションを提供しています。 たとえば、Optimus システムでは、NVIDIA GPU を無効にできるものがあります。 その後、Intel(R) ビデオカードは、 Intel(R) ドライバで利用できます。
+
BIOS の設定は、 コンピュータのモデルに依存します。 システムによっては、両方の GPU を有効にできますが、 そのようなシステムの機能を利用するには、 `Device` セッションにおいて、 メインの GPU のみを使用するようなコンフィグレーションファイルを作成ことで十分です。

[[x-config-video-cards-other]]
他のビデオカード::
Ports Collection の [.filename]#x11-drivers# ディレクトリには、 あまり使用されないようなドライバも用意されています。
+
特定のドライバによりサポートされていないようなカードでも、 package:x11-drivers/xf86-video-vesa[] で使用できるかもしれません。 このドライバは、package:x11/xorg[] によりインストールされます。 手動でインストールするには、 package:x11-drivers/xf86-video-vesa[] としてインストールしてください。 ビデオカードに対して、特定のドライバが見つからない場合には、 Xorg はこのドライバを使うことを試みます。
+
package:x11-drivers/xf86-video-scfb[] も同様に、多くの UEFI および ARM(R) コンピュータで動くような、 使用するカードを特定していないビデオドライバです。

[[x-config-video-cards-file]]
ファイルでビデオドライバを設定する。::
コンフィグレーションファイルにおいて Intel(R) ドライバを設定するには、以下のようにしてください。
+
[[x-config-video-cards-file-intel]]
.ファイルにおいて Intel(R) ビデオドライバを選択する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/driver-intel.conf#

[.programlisting]
....
Section "Device"
	Identifier "Card0"
	Driver     "intel"
	# BusID    "PCI:1:0:0"
EndSection
....

１つ以上のビデオカードが存在する場合には、 `BusID` 行のコメントを外し、 希望するカードを選択するように設定できます。 ビデオカードバス ID は、 `pciconf -lv | grep -B3 display` で表示できます。
====
+
コンフィグレーションファイルで、Radeon ドライバを設定するには以下のようにしてください。
+
[[x-config-video-cards-file-radeon]]
.ファイルにおいて Radeon ビデオドライバを設定する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/driver-radeon.conf#

[.programlisting]
....
Section "Device"
	Identifier "Card0"
	Driver     "radeon"
EndSection
....

====
+
コンフィグレーションファイルで VESA ドライバを設定するには、以下のようにしてください。
+
[[x-config-video-cards-file-vesa]]
.ファイルで VESA ビデオドライバを設定する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/driver-vesa.conf#

[.programlisting]
....
Section "Device"
	Identifier "Card0"
	Driver     "vesa"
EndSection
....

====
+
UEFI または ARM(R) コンピュータを使うために `scfb` ドライバを設定するには、以下のように設定してください。
+
[[x-config-video-cards-file-scfb]]
.ファイルの中で `scfb` ビデオドライバを選択する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/driver-scfb.conf#

[.programlisting]
....
Section "Device"
	Identifier "Card0"
	Driver     "scfb"
EndSection
....

====

[[x-config-monitors]]
=== モニタ

ほとんどすべてのモニタは、Extended Display Identification Data standard (EDID) に対応しています。 Xorg は EDID を使ってモニタと通信し、 対応している解像度とリフレッシュレートを検出します。 そのため、モニタを使用するのに最も適切な設定が選択されます。

モニタにより対応している他の解像度は、 コンフィグレーションファイルに希望する解像度を設定する、 または X サーバを起動後、man:xrandr[1] により選択が可能となります。

[[x-config-monitors-xrandr]]
man:xrandr[1] の使用::
パラメータを与えずに man:xrandr[1] を実行すると、 ビデオ出力と検出されているモニタのモードを確認できます。
+
[source,shell]
....
% xrandr
Screen 0: minimum 320 x 200, current 3000 x 1920, maximum 8192 x 8192
DVI-0 connected primary 1920x1200+1080+0 (normal left inverted right x axis y axis) 495mm x 310mm
   1920x1200     59.95*+
   1600x1200     60.00
   1280x1024     85.02    75.02    60.02
   1280x960      60.00
   1152x864      75.00
   1024x768      85.00    75.08    70.07    60.00
   832x624       74.55
   800x600       75.00    60.32
   640x480       75.00    60.00
   720x400       70.08
DisplayPort-0 disconnected (normal left inverted right x axis y axis)
HDMI-0 disconnected (normal left inverted right x axis y axis)
....
+
この出力からは、リフレッシュレート約 60 Hz で、 スクリーン解像度 1920x1200 ピクセルの表示に `DVI-0` 出力が使用されていることが分かります。 また、`DisplayPort-0` および `HDMI-0` インタフェースには、 モニタは接続されていません。
+
man:xrandr[1] を使用して、 他のディスプレイモードを選択できます。 たとえば、60 Hz で、1280x1024 の表示に変更するには、 以下のように実行してください。
+
[source,shell]
....
% xrandr --output DVI-0 --mode 1280x1024 --rate 60
....
+
ノートブックコンピュータの外部出力を使用して、 ビデオプロジェクタに接続することがよく行われます。
+
出力端子のタイプおよび番号は、デバイスごとに異なります。 また、各端子の名前もドライバごとに異なります。 あるドライバが `HDMI-1` と呼ぶ出力が、 別のドライバでは `HDMI1` と呼ばれることもあります。 そのため、最初に man:xrandr[1] を実行して、 利用可能な出力のすべての一覧を表示してください。
+
[source,shell]
....
% xrandr
Screen 0: minimum 320 x 200, current 1366 x 768, maximum 8192 x 8192
LVDS1 connected 1366x768+0+0 (normal left inverted right x axis y axis) 344mm x 193mm
   1366x768      60.04*+
   1024x768      60.00
   800x600       60.32    56.25
   640x480       59.94
VGA1 connected (normal left inverted right x axis y axis)
   1280x1024     60.02 +  75.02
   1280x960      60.00
   1152x864      75.00
   1024x768      75.08    70.07    60.00
   832x624       74.55
   800x600       72.19    75.00    60.32    56.25
   640x480       75.00    72.81    66.67    60.00
   720x400       70.08
HDMI1 disconnected (normal left inverted right x axis y axis)
DP1 disconnected (normal left inverted right x axis y axis)
....
+
この出力からは、組み込みパネルの `LVDS1`, 外部出力の `VGA1`, `HDMI1`, そして `DP1` 端子の 4 つの出力を確認できます。
+
プロジェクタは `VGA1` 出力に接続されています。 情報を得られたので、man:xrandr[1] を使ってプロジェクタの標準の解像度に設定し、 デスクトップの右側にスペースを追加できます。
+
[source,shell]
....
% xrandr --output VGA1 --auto --right-of LVDS1
....
+
この設定において、`--auto` は、 EDID により検出された解像度とリフレッシュレートを選択します。 解像度を正しく検出できていない場合には、 `--auto` のかわりに、 `--mode` を使うことで、 解像度を固定値を与えることにより設定できます。 たとえば、ほとんどのプロジェクタでは 1024x768 の解像度で使用できるので、 この場合には、`--mode 1024x768` のように設定できます。
+
man:xrandr[1] は、X を起動する際に、 適切なモードを設定するように、しばしば [.filename]#.xinitrc# から実行されます。

[[x-config-monitors-files]]
モニタ解像度をファイルで設定する。::
コンフィグレーションファイルでスクリーンの解像度を 1024x768 と設定するには以下のようにしてください。
+
.スクリーンの解像度をファイルで設定する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/screen-resolution.conf#

[.programlisting]
....
Section "Screen"
	Identifier "Screen0"
	Device     "Card0"
	SubSection "Display"
	Modes      "1024x768"
	EndSubSection
EndSection
....

====
+
EDID を持っていないモニタもあります。その場合には、 モニタが対応している周波数の範囲を、 `HorizSync` および `VertRefresh` で、指定することで設定できます。
+
.手動でモニタの周波数を設定する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/monitor0-freq.conf#

[.programlisting]
....
Section "Monitor"
	Identifier   "Monitor0"
	HorizSync    30-83   # kHz
	VertRefresh  50-76   # Hz
EndSection
....

====

[[x-config-input]]
=== 入力デバイス

[[x-config-input-keyboard]]
==== キーボード

[[x-config-input-keyboard-layout]]
キーボードレイアウト::
キーボード上の標準化されたキーの位置を _レイアウト_ と呼びます。 レイアウトと他の調整可能なパラメータについては、 man:xkeyboard-config[7] にまとめられています。
+
アメリカ合衆国のレイアウトがデフォルトです。 他のレイアウトを選択するには、 `InputClass` で、 `XkbLayout` および `XkbVariant` オプションを設定してください。 クラスに対応するすべての入力デバイスに適用できます。
+
以下の例では、 フランス語のキーボードレイアウトを選択しています。
+
.キーボードレイアウトを選択する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/keyboard-fr.conf#

[.programlisting]
....
Section	"InputClass"
	Identifier	"KeyboardDefaults"
	MatchIsKeyboard	"on"
	Option		"XkbLayout" "fr"
EndSection
....

====
+
.複数のキーボードレイアウトを選択する。
[example]
====
アメリカ合衆国、スペイン、 ウクライナのキーボードレイアウトを、 kbd:[Alt+Shift] によって切り替えるようにするには以下のように設定します。 レイアウトスイッチングコントロールや現在のレイアウトインディケータを改良するには、 package:x11/xxkb[] または、 package:x11/sbxkb[] を使ってください。

[.filename]#/usr/local/etc/X11/xorg.conf.d/kbd-layout-multi.conf#

[.programlisting]
....
Section	"InputClass"
	Identifier	"All Keyboards"
	MatchIsKeyboard	"yes"
	Option		"XkbLayout" "us, es, ua"
EndSection
....

====
[[x-config-input-keyboard-zap]]
キーボードから Xorg を終了する。::
X をキーの組み合わせで終了できるように設定できます。 デフォルトでは、幾つかのアプリケーションで、 キーボードコマンドと衝突してしまう可能性があるため、 このキーの組み合わせは設定されていません。 このオプションを有効にするには、 キーボードの `InputDevice` セクションを変更してください。
+
.キーボードからの X の終了を有効にする。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/keyboard-zap.conf#

[.programlisting]
....
Section	"InputClass"
	Identifier	"KeyboardDefaults"
	MatchIsKeyboard	"on"
	Option		"XkbOptions" "terminate:ctrl_alt_bksp"
EndSection
....

====

[[x11-input-mice]]
==== マウスおよびポインティングデバイス

[IMPORTANT]
====
もし FreeBSD {rel121-current} において、 man:moused[8] を使わず、 package:xorg-server[] 1.20.8 以降を使用しているのであれば、 [.filename]#/etc/sysctl.conf# に、 `kern.evdev.rcpt_mask=12` を追加してください。
====

コンフィグレーションオプションにより、 多くのマウスパラメータを調整できます。 すべての一覧については、man:mousedrv[4] をご覧ください。

[[x11-input-mice-buttons]]
マウスボタン::
[.filename]#xorg.conf# のマウス `InputDevice` セクションで、 マウスのボタンの数を設定できます。 ボタンの数を 7 に設定するには、 以下のように設定してください。
+
.マウスボタンの数を設定する。
[example]
====
[.filename]#/usr/local/etc/X11/xorg.conf.d/mouse0-buttons.conf#

[.programlisting]
....
Section "InputDevice"
	Identifier  "Mouse0"
	Option      "Buttons" "7"
EndSection
....

====

[[x-config-manual-configuration]]
=== 手動による設定

ハードウェアによっては、Xorg の自動設定で適切な設定が行われなかったり、 自動設定とは別の設定にしたいときがあります。 そのような場合のため、 カスタムコンフィグレーションファイルを作成できます。

[WARNING]
====
自動認識に失敗したとき以外は、 手動で設定ファイルを作成しないでください。 不必要な手動の設定を行った結果、 適切に動作しなくなるということがあります。
====

検出されたハードウェアをベースとした、 Xorg のコンフィグレーションファイルを作成できます。 このファイルは、 カスタムコンフィグレーションファイルの最初の出発点として有用です。

以下のようにすると [.filename]#xorg.conf# が生成されます。

[source,shell]
....
# Xorg -configure
....

このコンフィグレーションファイルは、 [.filename]#/root/xorg.conf.new# として保存されます。 必要となる変更を行った後、このファイルを (バックグラウンドが表示されるように `-retro` を使って) テストしてください。

[source,shell]
....
# Xorg -retro -config /root/xorg.conf.new
....

新しい設定を調整してテストしたら、 ファイルに分割して、標準の場所である、 [.filename]#/usr/local/etc/X11/xorg.conf.d/# に置いてください。

[[x-fonts]]
== Xorg でのフォントの使用

[[type1]]
=== Type1 フォント

Xorg に付いてくるデフォルトのフォントは、 通常のデスクトップパブリッシングアプリケーションにとっては理想的とは言えない程度のものです。 文字を大きくするとジャギーになりプロフェッショナルとは言えないようなものになりますし、 小さなフォントは頭が悪そうに見えます。 しかし、世の中には質の高い Type1 (PostScript(R)) フォントがいくつかあり、 Xorg ではそれらを簡単に利用することができます。 例えば、URW フォントコレクション (package:x11-fonts/urwfonts[]) には高品質の Type1 フォント (Times Roman(TM), Helvetica(TM), Palatino(TM) など) が含まれています。freefont コレクション (package:x11-fonts/freefonts[]) にはもっとたくさんのフォントが含まれていますが、 それらは Gimp のようなグラフィックソフトウェアで使用するためのものであり、 スクリーンフォントとしては十分ではありません。 さらに、Xorg は簡単に TrueType(R) フォントを使うように設定することも可能です。 詳しくは、man:X[7] のマニュアルページか <<truetype>> を参照してください。

上記の Type1 フォントコレクションをバイナリ package からインストールする場合には、次のコマンドを実行してください。

[source,shell]
....
# pkg install urwfonts
....

あるいは、Ports Collection から構築してインストールするには次のコマンドを実行してください。

[source,shell]
....
# cd /usr/ports/x11-fonts/urwfonts
# make install clean
....

freefont や他のコレクションでも同じようにします。 X サーバがこれらのフォントを検出できるようにするには X サーバ設定ファイル ([.filename]#/etc/X11/xorg.conf#) の適切な場所に次のような行を加えます。

[.programlisting]
....
FontPath "/usr/local/share/fonts/urwfonts/"
....

別の方法としては、 X のセッション中に次のようなコマンドラインを実行します。

[source,shell]
....
% xset fp+ /usr/local/share/fonts/urwfonts
% xset fp rehash
....

これは動くのですが、X のセッションが終了すると消えてしまいます。 消えないようにするには X の起動時に読み込まれるファイル (通常の `startx` セッションの場合は [.filename]#~/.xinitrc#, XDM のようなグラフィカルなログインマネージャを通してログインする時は [.filename]#~/.xsession#) に加えておきます。 三番目の方法は新しい [.filename]#/usr/local/etc/fonts/local.conf# ファイルを使うことです。 これに関しては <<antialias>> をご覧ください。

[[truetype]]
=== TrueType(R) フォント

Xorg には、 TrueType(R) フォントのレンダリング機能が組み込まれています。 この機能を実現するために 2 つの異なるモジュールがあります。 ここでは、freetype の方が他のフォントレンダリングバックエンドと整合性が高いので、 このモジュールを使うことにします。 freetype モジュールを使うためには [.filename]#/etc/X11/xorg.conf# ファイルの `"Module"` セクションに以下の行を追加するだけです。

[.programlisting]
....
Load  "freetype"
....

さて、まずは TrueType(R) フォント用のディレクトリ (例えば [.filename]#/usr/local/share/fonts/TrueType#) を作り、そこに TrueType(R) フォントをすべて放り込みましょう。 Apple(R) Mac(R) の TrueType(R) フォントは、そのままでは使うことができませんので注意してください。 Xorg で使うには UNIX(R)/MS-DOS(R)/Windows(R) 用のフォーマットでなければなりません。 ファイルを置いたら mkfontscale を使って [.filename]#fonts.dir# ファイルを作り、 X のフォントレンダラが新しいファイルがイントールされたことを分かるようにしてください。 `mkfontscale` は package からインストールできます。

[source,shell]
....
# pkg install mkfontscale
....

その後、ディレクトリに X フォントファイルのインデックスを作成してください。

[source,shell]
....
# cd /usr/local/share/fonts/TrueType
# mkfontscale
....

次に TrueType(R) フォントのディレクトリをフォントパスに追加します。 <<type1>> の場合と同じように、

[source,shell]
....
% xset fp+ /usr/local/share/fonts/TrueType
% xset fp rehash
....

とするか、もしくは [.filename]#xorg.conf# ファイルに `FontPath` 行を追加します。

これで Gimp や LibreOffice といったすべての X アプリケーションから TrueType(R) フォントを使うことができます。 (高解像度なディスプレイで見るウェブページ上のテキストみたいな) とても小さなフォントや (LibreOffice にあるような) 非常に大きなフォントもかなり綺麗に見えるようになることでしょう。

[[antialias]]
=== フォントのアンチエイリアス

[.filename]#/usr/local/share/fonts/# と [.filename]#~/.fonts/# にあるすべての Xorg のフォントが、Xft に対応しているアプリケーションで自動的にアンチエイリアス表示できるようになりました。 KDE, GNOME および Firefox のような最新のアプリケーションは、Xft に対応しています。

どのフォントがアンチエイリアスされるかを制御するため、 もしくはアンチエイリアスの特性を設定するために、 [.filename]#/usr/local/etc/fonts/local.conf# ファイルを作成 (すでに存在しているのなら編集) します。 多くの Xft フォントシステムの高度な機能をこのファイルを使って調整できます。 この節ではいくつか簡単なところだけを紹介します。 詳しくは、man:fonts-conf[5] をご覧ください。

このファイルは XML 形式でなければなりません。 大文字小文字の区別に注意を払い、 すべてのタグが正しく閉じられているか確認してください。 ファイルは一般的な XML ヘッダで始まり、DOCTYPE 定義と `<fontconfig>` タグがその後にきます。

[.programlisting]
....
<?xml version="1.0"?>
        <!DOCTYPE fontconfig SYSTEM "fonts.dtd">
        <fontconfig>
....

すでに説明したように、 [.filename]#/usr/local/share/fonts/# と [.filename]#~/.fonts/# にあるすべてのフォントは Xft 対応のアプリケーションで利用できます。 これら 2 つのディレクトリ以外に別のディレクトリを追加したいなら、 [.filename]#/usr/local/etc/fonts/local.conf# に以下のような行を追加してください。

[.programlisting]
....
<dir>/path/to/my/fonts</dir>
....

新しいフォント、 特に新しいフォントディレクトリを追加したら、 フォントキャッシュを再構築してください。

[source,shell]
....
# fc-cache -f
....

アンチエイリアスをかけることによって境界が少しぼやけ、 そのためにとても小さなテキストはさらに読みやすくなり、 大きなフォントでは "ギザギザ" が消えるのです。 しかし、普通のテキストにかけた場合には目が疲れてしまうこともあります。 14 ポイント以下のサイズのフォントについて、 アンチエイリアスをかけないようにするには次の行を加えます。

[.programlisting]
....
        <match target="font">
            <test name="size" compare="less">
                <double>14</double>
            </test>
            <edit name="antialias" mode="assign">
                <bool>false</bool>
            </edit>
        </match>
        <match target="font">
            <test name="pixelsize" compare="less" qual="any">
                <double>14</double>
            </test>
            <edit mode="assign" name="antialias">
                <bool>false</bool>
            </edit>
        </match>
....

いくつかの等幅フォントは、 アンチエイリアスをかけるとスペーシングがうまくいかなくなる場合があります。 特に KDE でその傾向があるようです。 解決策の一つとして、そういったフォントのスペーシングを 100 に設定する方法があります。 そうするためには次の行を加えてください。

[.programlisting]
....
	<match target="pattern" name="family">
            <test qual="any" name="family">
                <string>fixed</string>
            </test>
            <edit name="family" mode="assign">
                <string>mono</string>
            </edit>
        </match>
        <match target="pattern" name="family">
            <test qual="any" name="family">
                <string>console</string>
            </test>
            <edit name="family" mode="assign">
                <string>mono</string>
            </edit>
        </match>
....

(これは固定サイズのフォントに `"mono"` という一般的な別名をつけます) そして以下を追加します。

[.programlisting]
....
        <match target="pattern" name="family">
            <test qual="any" name="family">
                <string>mono</string>
            </test>
            <edit name="spacing" mode="assign">
                <int>100</int>
            </edit>
        </match>
....

Helvetica の様なある種のフォントは、 アンチエイリアスすると問題が起こるでしょう。 たいてい、フォントが縦に半分に切られて表示されます。 最悪の場合、アプリケーションがクラッシュします。 これを回避するには、以下を [.filename]#local.conf# に追加します。

[.programlisting]
....
        <match target="pattern" name="family">
            <test qual="any" name="family">
                <string>Helvetica</string>
            </test>
            <edit name="family" mode="assign">
                <string>sans-serif</string>
            </edit>
        </match>
....

[.filename]#local.conf# の編集を終えたら、 ファイルの末尾が `</fontconfig>` タグで終わるようにしてください。 これを行わなければ、変更は無視されるでしょう。

ユーザは自分だけの設定を各自の [.filename]#~/.config/fontconfig/fonts.conf# に追加できます。 このファイルもこれまでの説明と同じく XML 形式を使います。

最後に一つ。LCD スクリーンではサブピクセルサンプリングが必要な場合があります。 これは、基本的には (水平方向に分かれている) 赤、緑、 青の各コンポーネントを別々に扱うことによって水平方向の解像度を良くするというもので、 劇的な結果が得られます。 これを有効にするには [.filename]#local.conf# ファイルに次の行を加えます。

[.programlisting]
....
	 <match target="font">
            <test qual="all" name="rgba">
                <const>unknown</const>
            </test>
            <edit name="rgba" mode="assign">
                <const>rgb</const>
            </edit>
        </match>
....

[NOTE]
====
ディスプレイの種類にもよりますが、 `rgb` ではなく `bgr` や `vrgb`、もしくは `vbgr` の場合もあるので、 試してみて最も良いものを使ってください。
====

[[x-xdm]]
== X ディスプレイマネージャ

Xorg は、 ログインセッションの管理に用いることのできる X ディスプレイマネージャ XDM を提供しています。XDM はどのディスプレイサーバに接続するかを選択でき、 ログイン名とパスワードの組み合わせなど認証情報を入力できるグラフィカルなインタフェースを提供しています。

この章では、FreeBSD 上での X ディスプレイマネージャの設定方法について説明します。 デスクトップ環境によっては、 各環境独自のグラフィカルログインマネージャを提供しています。 GNOME ディスプレイマネージャの設定方法については、<<x11-wm-gnome>> を参照してください。 また、KDE ディスプレイマネージャの設定方法については、<<x11-wm-kde>> を参照してください。

=== XDM の設定

XDM をインストールするには、 package:x11/xdm[] package または port を使ってください。
インストール後、コンピュータの起動時に、XDM を起動するように設定するには、[.filename]#/etc/rc.conf# に以下の行を追加してください。

[.programlisting]
....
xdm_enable="YES"
....

デフォルトでは、XDM は 9 番目の仮想端末で起動します。

XDM の設定用ディレクトリは [.filename]#/usr/local/etc/X11/xdm# です。
このディレクトリには XDM の振る舞いや見た目を変更するために用いられるファイルや、XDM の動作中にデスクトップを設定するためのスクリプトやプログラムがあります。
<<xdm-config-files>> には、これらのフィアルの機能についてまとめられています。
これらのファイルの正確な文法や使用方法については、man:xdm[8] に記述されています。

[[xdm-config-files]]
.XDM 設定ファイル
[cols="1,1", frame="none", options="header"]
|===
| ファイル
| 説明

|[.filename]#Xaccess#
|XDM に接続するためのプロトコルは X Display Manager Connection Protocol (XDMCP) と呼ばれます。 このファイルにはリモートのマシンからの XDMCP 接続をコントロールするためのルールセットが書かれます。 デフォルトでは、どのクライアントからの接続も拒否します。

|[.filename]#Xresources#
|このファイルは、XDM ディスプレイの chooser およびログインスクリーンを設定します。 デフォルトの設定は、シンプルな長方形のログインウィンドウで、 コンピュータのホスト名がログインウィンドウの上部に大きなフォントで表示され、 その下に "Login:" および "Password:" のプロンプトが表示されます。 このファイルのフォーマットは Xorg のドキュメントで記述されている app-defaults ファイルのものと同じです。

|[.filename]#Xservers#
|これは、chooser がログインの選択肢として提供するローカルおよびリモートのディスプレイの一覧です。

|[.filename]#Xsession#
|ユーザのログイン時に XDM により実行されるデフォルトのセッションスクリプトです。 [.filename]#~/.xsession# に置かれているカスタマイズされたセッションスクリプトが優先されます。

|[.filename]#Xsetup_#*
|これらは chooser やログインインタフェースが表示される前に自動的に実行されるアプリケーションです。 それぞれのディスプレイに対して、[.filename]#Xsetup_*# (`*` はローカルのディスプレイ番号) という名前のついたスクリプトがあります。 典型的な使い方は `xconsole` のようなバックグラウンドで動かすプログラムを一つか二つ起動することです。

|[.filename]#xdm-config#
|このマシンで動いているすべてのディスプレイのグローバルな設定

|[.filename]#xdm-errors#
|このファイルにはサーバプログラムからのエラーが書き出されます。 XDM が起動しようとしているディスプレイがなんらかの理由でハングした場合、 このファイルのエラーメッセージを見てください。 これらのメッセージは各ユーザの [.filename]#~/.xsession-errors# ファイルにもセッション毎に書き出されます。

|[.filename]#xdm-pid#
|現在動いている XDM のプロセス ID。
|===

=== リモートアクセスの設定

デフォルトでは、XDM を使ってログインできるのは、同じシステムのユーザのみです。 あるディスプレイサーバに他のシステムのユーザが接続できるようにするためには、 アクセスコントロールのルールを編集し、 コネクションリスナを有効にする必要があります。

XDM が他のリモートコネクションを待ち受けるようにするためには、 [.filename]#/usr/local/etc/X11/xdm/xdm-config# の `DisplayManager.requestPort` 行を、行頭に `!` を置くことでコメントアウトしてください。

[source,shell]
....
! SECURITY: do not listen for XDMCP or Chooser requests
! Comment out this line if you want to manage X terminals with xdm
DisplayManager.requestPort:     0
....

変更点を保存して、XDM を再起動してください。
リモートアクセスを制限するには、[.filename]#/usr/local/etc/X11/xdm/Xaccess# にある例を参考にしたり、詳細について man:xdm[8] を参照してください。

[[x11-wm]]
== デスクトップ環境

この節では、良く使われている 3 つのデスクトップ環境を FreeBSD 上でにインストールする方法について解説します。 デスクトップ環境とは、 単なるウィンドウマネージャから完全なデスクトップアプリケーションスイートまでカバーします。 Ports Collection の [.filename]#x11-wm# カテゴリには、 100 を超えるデスクトップ環境が用意されています。

[[x11-wm-gnome]]
=== GNOME

GNOME はユーザフレンドリなデスクトップ環境です。 アプリケーションを起動したりステータスを表示するパネル、 デスクトップ、ツールおよびアプリケーション群、 そしてアプリケーションが互いにうまくやり取りできるような仕組みが含まれています。 FreeBSD 上の GNOME に関するもっと詳しい情報は、link:https://www.FreeBSD.org/gnome[https://www.FreeBSD.org/gnome] で見ることができます。 このウェブサイトには、FreeBSD での GNOME のインストール、設定、管理に関する多くの情報があります。

このデスクトップ環境は、package からインストールできます。

[source,shell]
....
# pkg install gnome3
....

ports から GNOME を構築するには、以下のコマンドを実行してください。 GNOME は大きなアプリケーションなので、 コンパイルには高速のコンピュータでも時間がかかります。

[source,shell]
....
# cd /usr/ports/x11/gnome3
# make install clean
....

GNOME を使用するには、 [.filename]#/proc# ファイルシステムをマウントする必要があります。 以下を [.filename]#/etc/fstab# に追加して、 システムの起動中にこのファイルシステムをマウントするように設定してください。

[.programlisting]
....
proc           /proc       procfs  rw  0   0
....

GNOME は、メッセージバスおよびハードウェアアブストラクションに D-Bus を使います。
これらのアプリケーションは、GNOME の依存として自動的にインストールされます。
[.filename]#/etc/rc.conf# の中で、システムの起動時にスタートするように有効にしてください。

[.programlisting]
....
dbus_enable="YES"
....

インストール後、 GNOME を起動するように Xorg を設定してください。 最も簡単な方法は、GNOME ディスプレイマネージャ GDM を使うことです。 GDM は、 GNOME package または port の一部としてインストールされます。 有効にするには、以下の行を [.filename]#/etc/rc.conf# に追加してください。

[.programlisting]
....
gdm_enable="YES"
....

GNOME のすべてのサービスを、 起動するようにしておくと良いでしょう。 このように設定するには、以下の行を [.filename]#/etc/rc.conf# に追加してください。

[.programlisting]
....
gnome_enable="YES"
....

システムを再起動すると、GDM が自動的に起動します。

GNOME を起動するもう一つの方法は、 [.filename]#.xinitrc# を適切に設定した後で、 コマンドラインから `startx` と入力する方法です。 [.filename]#.xinitrc# が既にある場合には、 ウィンドウマネージャを起動する行を [.filename]#/usr/local/bin/gnome-session# を起動するように変更してください。 このファイルが存在しなければ、 次のコマンドで作成してください。

[source,shell]
....
% echo "exec /usr/local/bin/gnome-session" > ~/.xinitrc
....

3 つめの方法は、XDM をディスプレイマネージャとして使う方法です。 この場合は、実行可能な [.filename]#.xsession# というファイルを作成してください。

[source,shell]
....
% echo "exec /usr/local/bin/gnome-session" > ~/.xsession
....

[[x11-wm-kde]]
=== KDE

KDE はもう一つの使いやすいデスクトップ環境です。 このデスクトップは、統一されたルックアンドフィール、 標準化されたメニューおよびツールバー、 キーバインディング、カラースキーム、国際化、 一元化されたダイアログベースのデスクトップ設定とともに、 アプリケーションのスイートを提供します。 KDE の詳細については link:http://www.kde.org/[http://www.kde.org/] をご覧ください。 KDE に関する FreeBSD 特有の情報については、link:http://freebsd.kde.org/[http://freebsd.kde.org] をご覧ください。

KDE package をインストールするには以下のように実行してください。

[source,shell]
....
# pkg install x11/kde5
....

KDE port を構築するには、以下のコマンドを使ってください。 port のインストールでは、 インストールするアプリケーションを選択するためのメニューが表示されます。 KDE は大きなアプリケーションなので、 高速のコンピュータでもコンパイルには時間がかかります。

[source,shell]
....
# cd /usr/ports/x11/kde5
# make install clean
....

KDE では、 [.filename]#/proc# ファイルシステムをマウントする必要があります。 以下の行を [.filename]#/etc/fstab# に追加して、 システム起動時にこのファイルシステムが自動的にマウントされるように設定してください。

[.programlisting]
....
proc           /proc       procfs  rw  0   0
....

KDE は、 メッセージバスおよびハードウェアアブストラクションに D-Bus を使います。
これらのアプリケーションは、KDE の依存として自動的にインストールされます。
[.filename]#/etc/rc.conf# の中で、システムの起動時にスタートするように有効にしてください。

[.programlisting]
....
dbus_enable="YES"
....

KDE Plasma 5 から KDE のディスプレイマネージャ KDM の開発は終了しました。 かわりに推奨されているのが SDDM です。 インストールするには、以下を実行してください。

[source,shell]
....
# pkg install x11/sddm
....

その後、以下の行を [.filename]#/etc/rc.conf# に追加してください。

[.programlisting]
....
sddm_enable="YES"
....

KDE Plasma を起動するもう一つの方法は、 コマンドラインから `startx` を実行する方法です。 このコマンドを実行するには、[.filename]#~/.xinitrc# に以下の行を追加してください。

[.programlisting]
....
exec ck-launch-session startplasma-x11
....

KDE Plasma を起動する 3 つめの方法は、 XDM を利用する方法です。 この方法を使うには、以下のようにして実行可能な [.filename]#~/.xsession# を作成してください。

[source,shell]
....
% echo "exec ck-launch-session startplasma-x11" > ~/.xsession
....

KDE Plasma を起動した後は、 ビルトインヘルプシステムから、 さまざまなメニューおよびアプリケーションの使用方法などのより詳しい情報を参照できます。

[[x11-wm-xfce]]
=== Xfce

Xfce は GNOME で使われている GTK+ ツールキットをベースにしたデスクトップ環境ですが、より軽量、 シンプルでかつ効率的でありながら使いやすいデスクトップ環境です。 すべての設定が可能で、メニュー、 アプレットおよびアプリケーションランチャを含むメインパネル、 ファイルマネージャ、サウンドマネージャを提供し、 テーマに対応しています。 速くて軽く、効率的なため、古いマシンや遅いマシン、 メモリの限られたマシンに向いています。 Xfce に関する詳しい情報は link:http://www.xfce.org/[http://www.xfce.org] で得られます。

Xfce package をインストールするには、次のように実行してください。

[source,shell]
....
# pkg install xfce
....

また、port を構築するには以下のようにしてください。

[source,shell]
....
# cd /usr/ports/x11-wm/xfce4
# make install clean
....

Xfce は、 メッセージバスに D-Bus を使います。 これらのアプリケーションは Xfce の依存として自動的にインストールされます。 [.filename]#/etc/rc.conf# において、 システム起動時に起動するように有効にしてください。

[.programlisting]
....
dbus_enable="YES"
....

GNOME や KDE とは異なり、 Xfce は、 ログインマネージャを提供していません。 コマンドラインから `startx` を実行して Xfce を起動するには、 以下のコマンドを使って、 [.filename]#~/.xinitrc# を作成してください。

[source,shell]
....
% echo ". /usr/local/etc/xdg/xfce4/xinitrc" > ~/.xinitrc
....

もう一つの方法は XDM を用いる方法です。この方法を使うには、 実行可能な [.filename]#.xsession# を作成してください。

[source,shell]
....
% echo ". /usr/local/etc/xdg/xfce4/xinitrc" > ~/.xsession
....

[[x-compiz-fusion]]
== Compiz Fusion のインストール

魅力的な 3D 効果を使うと、 デスクトップコンピュータを使う楽しさがさらに増えることでしょう。

Compiz Fusion のインストールは簡単ですが、設定の際には、port の文書には記載されていないような作業が必要となることがあります。

[[x-compiz-video-card]]
=== FreeBSD nVidia ドライバの設定

デスクトップ効果は、 グラフィックカードに極めて高い負荷をかけることがあります。 nVidia ベースのグラフィックカードにおいて、 良いパフォーマンスを出すには、 プロプリエタリなドライバが必要となります。 他のグラフィックカードを使っているユーザは、この節を飛ばし、 [.filename]#xorg.conf# の設定に進んでください。

必要となる nVidia ドライバについては、 extref:{faq}[この問題に関する FAQ, idp59950544] を参照して決めてください。

使用しているカードに対する適切なドライバが決まれば、 インストール作業は他の package をインストールするのと同じように簡単です。

たとえば、 最新のドライバをインストールするには以下のように実行してください。

[source,shell]
....
# pkg install x11/nvidia-driver
....

このドライバはカーネルモジュールを作成するので、このモジュールをシステムの起動時に読み込むように設定する必要があります。
man:sysrc[8] を使用して起動時にモジュールを読み込むようにしてください。

[source,shell]
....
# sysrc kld_list+="nvidia"
....

または、以下の行を [.filename]#/boot/loader.conf# に追加してください。

[.programlisting]
....
nvidia_load="YES"
....

[NOTE]
====
動作しているカーネルに、 カーネルモジュールを今すぐ読み込ませるには、 `kldload nvidia` のようなコマンドを実行してください。 しかしながら、Xorg のバージョンによっては、 起動時にドライバが読み込まれていないと正しく動かないもありますので、 注意してください。[.filename]#/boot/loader.conf# を編集後は、再起動してください。
[.filename]#/boot/loader.conf# を間違って設定してしまうと、システムは適切に起動しない可能性があります。
====

読み込まれたカーネルモジュールを使うには、 通常は、[.filename]#xorg.conf# ファイルの一つの行をプロプリエタリなドライバを使うように変更するだけです。

[.filename]#/etc/X11/xorg.conf# において、 以下の行を探し出してください。

[.programlisting]
....
Driver      "nv"
....

この行を以下のように変更してください。

[.programlisting]
....
Driver      "nvidia"
....

いつものように GUI を起動すると、nVidia のスプラッシュが表示されます。 すべてはこれまで通りに動作するはずです。

[[xorg-configuration]]
=== デスクトップ効果のための `xorg.conf` の設定

Compiz Fusion を有効にするには [.filename]#/etc/X11/xorg.conf# を変更する必要があります。

コンポジット効果を有効にするには、 以下のセクションを追加してください。

[.programlisting]
....
Section "Extensions"
    Option         "Composite" "Enable"
EndSection
....

以下のような "Screen" セクションの場所を見つけてください。

[.programlisting]
....
Section "Screen"
    Identifier     "Screen0"
    Device         "Card0"
    Monitor        "Monitor0"
    ...
....

("Monitor" の後に) 次の二つの行を追加してください。

[.programlisting]
....
DefaultDepth    24
Option         "AddARGBGLXVisuals" "True"
....

あなたが使用したいと考えているスクリーン解像度に対応する "Subsection" を探してください。 たとえば、1280x1024 を使用する予定であれば、 次のようなセクションを探してください。 もし希望の解像度の subsection がなければ、 手動でそのエントリを追加してください。

[.programlisting]
....
SubSection     "Display"
    Viewport    0 0
    Modes      "1280x1024"
EndSubSection
....

デスクトップコンポジットで 24 ビットのカラーが必要であれば、上述の subsection を以下のように変更してください。

[.programlisting]
....
SubSection     "Display"
    Viewport    0 0
    Depth       24
    Modes      "1280x1024"
EndSubSection
....

最後に、"Module" セクションに "glx" および "extmod" モジュールが読み込まれるように設定されていることを確認してください。

[.programlisting]
....
Section "Module"
    Load           "extmod"
    Load           "glx"
    ...
....

前述の設定は、 package:x11/nvidia-xconfig[] を (`root` 権限で) 実行することで自動的に設定できます。

[source,shell]
....
# nvidia-xconfig --add-argb-glx-visuals
# nvidia-xconfig --composite
# nvidia-xconfig --depth=24
....


[[compiz-fusion]]
=== Compiz Fusion のインストールおよび設定

Compiz Fusion のインストールは、 他の package と同様に簡単です。

[source,shell]
....
# pkg install x11-wm/compiz-fusion
....

インストールが終了したら、グラフィックデスクトップを起動して、 端末から以下のコマンドを通常のユーザで実行してください。

[source,shell]
....
% compiz --replace --sm-disable --ignore-desktop-hints ccp &
% emerald --replace &
....

使っているウィンドウマネージャ (GNOME では、Metacity) が、 Compiz Fusion に置き換えられるため、 画面は数秒間ちらつきます。 Emerald がウィンドウデコレーション (たとえば、閉じる、最小化、最大化ボタンタイトルバーなど) を取り扱います。

このコマンドをスクリプトに変換して、 (たとえば GNOME デスクトップの "Sessions" に追加して) 起動時に自動的に実行されるようにすることもできます。

[.programlisting]
....
#! /bin/sh
compiz --replace --sm-disable --ignore-desktop-hints ccp &
emerald --replace &
....

これを、たとえば [.filename]#start-compiz# という名前でホームディレクトリに保存して、 以下のように実行可能にしてください。

[source,shell]
....
% chmod +x ~/start-compiz
....

GUI を使って、このスクリプトを (GNOME デスクトップの [.guimenuitem]#System#, [.guimenuitem]#Preferences#, [.guimenuitem]#Sessions# にある) [.guimenuitem]#Startup Programs# に追加してください。

すべての希望する効果と設定を選択するには、 (もう一度通常のユーザで) Compiz Config Settings Manager を実行してください。

[source,shell]
....
% ccsm
....

[NOTE]
====
GNOME では、 [.guimenuitem]#System#, [.guimenuitem]#Preferences# メニューから選択することも出来ます。
====

ビルドの際に "gconf support" を選択していたのであれば、 `gconf-editor` を使って `apps/compiz` 以下を見ることで、 これらの設定を確認することも出来ます。

[[x11-troubleshooting]]
== トラブルシューティング

もしマウスが動作しなければ、 先へ進む前にマウスの設定を行う必要があります。 最近の Xorg では、デバイスの自動認識のため、 [.filename]#xorg.conf# の `InputDevice` セクションは無視されます。 古い設定の記述を利用するには、 このファイルの `ServerLayout` もしくは、 `ServerFlags` セクションに以下の行を追加してください。

[.programlisting]
....
Option "AutoAddDevices" "false"
....

これで、以前のバージョンのように、入力デバイスを (キーボードレイアウトの変更のように) 必要なオプションを用いて設定できるようになります。

[NOTE]
====
[WARNING]
=====
この章には部分的に古くなった情報が含まれています。
FreeBSD のデスクトップ設定に HAL デーモン (hald) はもう使われません。
=====
すでに説明したように、デフォルトで hald デーモンがキーボードを自動的に認識します。 キーボードレイアウトやモデルを正しく認識しない場合でも、 GNOME, KDE もしくは Xfce のようなデスクトップ環境が、 キーボードの設定ツールを提供しています。 しかしながら、 man:setxkbmap[1] ユーティリティや hald の設定ルールを利用することで、 キーボードのプロパティを直接設定できます。

たとえば、フランス語のレイアウトの PC 102 キーボードを使いたい場合には、 hald のキーボード設定ファイル [.filename]#x11-input.fdi# を作成し、 [.filename]#/usr/local/etc/hal/fdi/policy# ディレクトリに保存してください。 このファイルは以下を含んでいる必要があります。

[.programlisting]
....
<?xml version="1.0" encoding="utf-8"?>
<deviceinfo version="0.2">
  <device>
    <match key="info.capabilities" contains="input.keyboard">
	  <merge key="input.x11_options.XkbModel" type="string">pc102</merge>
	  <merge key="input.x11_options.XkbLayout" type="string">fr</merge>
    </match>
  </device>
</deviceinfo>
....

このファイルがすでに存在する場合には、 キーボードの設定に関する部分をただ単にコピーし、 ファイルに追加してください。

hald がこのファイルを読み込むように、 コンピュータを再起動してください。

X 端末やスクリプトから以下のコマンドラインを実行することでも、 同様に設定できます。

[source,shell]
....
% setxkbmap -model pc102 -layout fr
....

[.filename]#/usr/local/share/X11/xkb/rules/base.lst# には、利用可能なキーボード、 レイアウトおよびオプションの一覧があります。
====

[.filename]#xorg.conf.new# 設定ファイルを好みに合うように調整できます。 man:emacs[1] や man:ee[1] のようなテキストエディタでファイルを開いてください。 古いモニタや、通常とは異なるモデルで、 同期周波数の自動認識に対応していない場合には、 以下のような設定を [.filename]#xorg.conf.new# の `"Monitor"` セクションの下に加えてください。

[.programlisting]
....
Section "Monitor"
        Identifier   "Monitor0"
        VendorName   "Monitor Vendor"
        ModelName    "Monitor Model"
        HorizSync    30-107
        VertRefresh  48-120
EndSection
....

ほとんどのモニタは同期周波数の自動認識に対応しているので、 これらの値を手動で入力する必要はありません。 自動認識に対応していないモニタでは、 ダメージの可能性を避けるため、 メーカーが提供している値のみを入力してください。

X はモニタが対応していれば DPMS (Energy Star) 機能を使うことができます。 man:xset[1] プログラムでタイムアウトをコントロールしたり、 強制的にスタンバイ、サスペンドや電源オフにすることができます。 モニタの DPMS 機能を有効にしたい場合は、 `"Monitor"` セクションに次の行を加えてください。

[.programlisting]
....
Option       "DPMS"
....

[.filename]#xorg.conf.new# 設定ファイルはエディタで開いたままにしておき、 デフォルトの解像度と色数を好みで選んでください。 `"Screen"` セクションで定義されます。

[.programlisting]
....
Section "Screen"
        Identifier "Screen0"
        Device     "Card0"
        Monitor    "Monitor0"
        DefaultDepth 24
        SubSection "Display"
                Viewport  0 0
                Depth     24
                Modes     "1024x768"
        EndSubSection
EndSection
....

`DefaultDepth` というキーワードは 実行時のデフォルトの色数について記述するためのものです。 man:Xorg[1] のコマンドラインスイッチ `-depth` が使用された場合はそちらが優先されます。 `Modes` というキーワードは、 与えられた色数におけるデフォルトの解像度を記述しておくためのものです。 ターゲットのシステムのグラフィックハードウェアによって定義されている、 VESA スタンダードモードのみがサポートされていることに注意してください。 上の例ではデフォルトの色数はピクセルあたり 24 ビットであり、 この色数での解像度は 1024 ピクセル× 768 ピクセルです。

最後に、設定ファイルを保存し、 上の例にあるようにテストしてみてください。

[NOTE]
====
トラブルシューティングの過程で助けとなるツールのひとつに Xorg のログファイルがあります。 これには、Xorg サーバが検知したデバイスそれぞれについての情報があります。 Xorg のログファイル名は [.filename]#/var/log/Xorg.0.log# という形式です。実際のログファイル名は [.filename]#Xorg.0.log# から [.filename]#Xorg.8.log# のように変わります。
====

すべてうまくいったなら、設定ファイルを man:Xorg[1] が見つけることができる共通の場所に置きます。 これは、通常は [.filename]#/etc/X11/xorg.conf# や [.filename]#/usr/local/etc/X11/xorg.conf# です。

[source,shell]
....
# cp xorg.conf.new /etc/X11/xorg.conf
....

これで Xorg の設定は完了です。
man:startx[1] ユーティリティで Xorg を起動できます。
man:xdm[8] を使って Xorg サーバを起動することもできます。

=== Intel(R) `i810` グラフィックチップセットの設定

Intel(R) i810 統合チップセットを設定するには、 Xorg にカードを制御させるために AGP プログラミングインタフェースである [.filename]#agpgart# が必要になります。 詳しくは、man:agp[4] ドライバのマニュアルページをご覧ください。

このドライバを用いることで、 他のグラフィックボードと同様に設定を行うことができるようになります。 カーネルに man:agp[4] ドライバが組み込まれていないシステムでは、 このモジュールを man:kldload[8] を使って読み込もうとしても動作しないことに注意してください。 このドライバは、 起動時にカーネル内に存在するようにカーネル内部に組み込むか、 [.filename]#/boot/loader.conf# を使わなければなりません。

=== ワイドスクリーンフラットパネルの追加

この節では、設定に関する幾分高度な知識を必要とします。 これまでに述べた標準ツールを使って設定に失敗する場合は、 ログファイルを参照してください。 ログファイルには、 設定のために有用な情報が十分含まれています。 テキストエディタを使用する必要があるでしょう。

現在のワイドスクリーン (WSXGA, WSXGA+, WUXGA, WXGA, WXGA+ など) は、 16:10 や 10:9 形式、または (問題を含む可能性のある) 他のアスペクト比に対応しています。 以下は、16:10 アスペクト比のスクリーン解像度の例です。

* 2560x1600
* 1920x1200
* 1680x1050
* 1440x900
* 1280x800

これらの解像度のひとつを以下のように `"Screen" セクション` の 可能な `Mode` に追加してください。

[.programlisting]
....
Section "Screen"
Identifier "Screen0"
Device     "Card0"
Monitor    "Monitor0"
DefaultDepth 24
SubSection "Display"
	Viewport  0 0
	Depth     24
	Modes     "1680x1050"
EndSubSection
EndSection
....

Xorg は、I2C/DDC 情報を通してワイドスクリーンの解像度に関する情報を取得できるので、 モニタの周波数や解像度の範囲を把握しています。

もし、これらの `ModeLines` がドライバに存在しないのであれば、 Xorg にヒントを与えなけれならないでしょう。 `ModeLine` を手動で設定するのに十分な情報を [.filename]#/var/log/Xorg.0.log# から得ることができます。 以下のような情報を探してください。

[.programlisting]
....
(II) MGA(0): Supported additional Video Mode:
(II) MGA(0): clock: 146.2 MHz   Image Size:  433 x 271 mm
(II) MGA(0): h_active: 1680  h_sync: 1784  h_sync_end 1960 h_blank_end 2240 h_border: 0
(II) MGA(0): v_active: 1050  v_sync: 1053  v_sync_end 1059 v_blanking: 1089 v_border: 0
(II) MGA(0): Ranges: V min: 48  V max: 85 Hz, H min: 30  H max: 94 kHz, PixClock max 170 MHz
....

これは EDID と呼ばれる情報です。 この情報を用いて `ModeLine` を作成するには、 正しい順番に数字を入力するだけです。 

[.programlisting]
....
 ModeLine <name> <clock> <4 horiz. timings> <4 vert. timings>
....

この例では `Monitor セクション` の `ModeLine` は以下のようになります。

[.programlisting]
....
Section "Monitor"
Identifier      "Monitor1"
VendorName      "Bigname"
ModelName       "BestModel"
ModeLine        "1680x1050" 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option          "DPMS"
EndSection
....

以上の簡単な編集作業が終わったら、 新しいワイドスクリーンモニタ上で X が動作するでしょう。

[[compiz-troubleshooting]]
=== Compiz Fusion 使用時のトラブルシューティング

==== Compiz Fusion をインストールし、説明されたようにコマンドを実行すると、 ウィンドウのタイトルバーやボタンが表示されません。 何が問題でしょうか？

おそらく [.filename]#/etc/X11/xorg.conf# の設定が行われていていないのでしょう。 このファイルを詳細に確認してください。特に `DefaultDepth` および `AddARGBGLXVisuals` ディレクティブを確認してください。

==== Compiz Fusion を起動するコマンドを実行すると、X サーバがクラッシュし、 コンソールに戻ります。何が問題でしょうか？

[.filename]#/var/log/Xorg.0.log# ファイルを確認すると、 X の起動時のエラーメッセージを探し出すことができます。 多くの場合は、以下のようなものです。

[source,shell]
....
(EE) NVIDIA(0):     Failed to initialize the GLX module; please check in your X
(EE) NVIDIA(0):     log file that the GLX module has been loaded in your X
(EE) NVIDIA(0):     server, and that the module is the NVIDIA GLX module.  If
(EE) NVIDIA(0):     you continue to encounter problems, Please try
(EE) NVIDIA(0):     reinstalling the NVIDIA driver.
....

これは通常 Xorg をアップグレードした時に起きる現象です。 package:x11/nvidia-driver[] package をインストールして glx を再構築してください。
