---
title: Perguntas freqüentes para o FreeBSD 11.X e 12.X
authors: 
releaseinfo: "$FreeBSD$" 
trademarks: [] 
---

= Perguntas freqüentes para o FreeBSD {rel2-relx} e {rel-relx}
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnums:
:sectnumlevels: 6
:partnums:
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Índice
:part-signifier: Parte
:chapter-signifier: Capítulo
:appendix-caption: Apêndice
:table-caption: Tabela
:figure-caption: Figura
:example-caption: Exemplo
:rel-numbranch: 3
:rel-head: 13-CURRENT
:rel-head-relx: 13.X
:rel-head-releng: head/
:rel-relx: 12.X
:rel-stable: 12-STABLE
:rel-releng: stable/12/
:rel-relengdate: December 2018
:rel2-relx: 11.X
:rel2-stable: 11-STABLE
:rel2-releng: stable/11/
:rel2-relengdate: October 2016

ifeval::["{backend}" == "html5"]
include::shared/mirrors.adoc[]
include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/pt-br/mailing-lists.adoc[]
include::shared/pt-br/teams.adoc[]
include::shared/pt-br/urls.adoc[]
endif::[]

ifeval::["{backend}" == "pdf"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/pt-br/mailing-lists.adoc[]
include::../../../../shared/pt-br/teams.adoc[]
include::../../../../shared/pt-br/urls.adoc[]
endif::[]

ifeval::["{backend}" == "epub3"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/pt-br/mailing-lists.adoc[]
include::../../../../shared/pt-br/teams.adoc[]
include::../../../../shared/pt-br/urls.adoc[]
endif::[]

[.abstract-title]
Resumo

Estas são as Perguntas Mais Frequentes (FAQ) para as versões do FreeBSD {rel-relx} e {rel2-relx}. Todos os esforços foram feitos para tornar este FAQ o mais informativo possível; Se você tiver alguma sugestão de como ele pode ser melhorado, envie-a para a http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc[lista de discussão do projeto de documentação do FreeBSD].

A versão mais recente deste documento está sempre disponível no link:{faq}[website do FreeBSD]. Ela também pode ser baixada como um grande arquivo link:.[HTML] por HTTP ou em uma grande variedade de outros formatos a partir do https://download.freebsd.org/ftp/doc/[servidor de FTP do projeto FreeBSD].

'''

toc::[]

== Introdução

=== O que é o FreeBSD?

O FreeBSD é um sistema operacional moderno para desktops, laptops, servidores e sistemas embarcados, com suporte para um grande número de https://www.FreeBSD.org/platforms/[plataformas].

Ele é baseado no sistema "4.4BSD-Lite" da U.C. de Berkeley, com algumas melhorias oriundas do "4.4BSD-Lite2". Ele também se baseia indiretamente no port para i386(TM) feito por William Jolitz do sistema "Net/2" da U.C. Berkeley, conhecido como "386BSD", embora muito pouco do código original do 386BSD ainda esteja presente.

O FreeBSD é usado por empresas, provedores de serviços de Internet, pesquisadores, profissionais da computação, estudantes e usuários domésticos em todo o mundo em seu trabalho, educação e recreação.

Para informações mais detalhadas sobre o FreeBSD, consulte o link:{handbook}[Manual do FreeBSD].

[[FreeBSD-goals]]
=== Qual é o objetivo do projeto FreeBSD?

O objetivo do Projeto FreeBSD é fornecer um sistema operacional de propósito geral estável e rápido que possa ser usado para qualquer propósito sem restrições.

=== A licença do FreeBSD tem alguma restrição?

Sim. Essas restrições não controlam como o código é usado, mas como tratar o próprio projeto FreeBSD. A licença em si está disponível em https://www.FreeBSD.org/copyright/freebsd-license/[licença] e pode ser resumida da seguinte forma:

* Não reivindique que você escreveu o sistema.
* Não nos processe se ele quebrar.
* Não remova ou modifique a licença.

Muitos de nós têm um investimento significativo no projeto e certamente não nos importaríamos com uma pequena compensação financeira de vez em quando, mas nós definitivamente não insistimos nisso. Acreditamos que a nossa primeira e principal "missão" é fornecer código a todos os participantes, e para qualquer finalidade, para que o código obtenha o maior uso possível e forneça o maior benefício possível. Este, acreditamos, é um dos objetivos mais fundamentais do Software Livre e um dos que apoiamos entusiasticamente.

O código em nosso repositório de código-fonte que se enquadra na https://www.FreeBSD.org/copyright/COPYING[Licença Pública Geral GNU (GPL)] ou na https://www.FreeBSD.org/copyright/COPYING.LIB[Licença Pública Geral da Biblioteca GNU (LGPL)] vem com algumas restrições adicionais, ainda que sejam no sentido de forçar o acesso, em vez do habitual oposto. Devido às complexidades adicionais que podem surgir no uso comercial de um software GPL, nós nos esforçamos para substituir tais softwares por outros sob a https://www.FreeBSD.org/copyright/freebsd-license/[Licença FreeBSD] que é menos restritiva, sempre que possível.

=== O FreeBSD pode substituir meu sistema operacional atual?

Para a maioria das pessoas, sim. Mas esta questão não é assim tão simples.

A maioria das pessoas não usa um sistema operacional. Elas usam aplicativos. São os aplicativos que realmente usam o sistema operacional. O FreeBSD é projetado para fornecer um ambiente robusto e completo para aplicativos. Ele suporta uma grande variedade de navegadores da web, pacotes de escritório, leitores de e-mail, programas gráficos, ambientes de programação, servidores de rede e muito mais. A maioria destes aplicativos pode ser gerenciada através da https://www.FreeBSD.org/ports/[Coleção de Ports].

Se um aplicativo estiver disponível apenas para um determinado sistema operacional, esse sistema operacional não poderá ser substituído. No entanto é provável que exista um aplicativo muito semelhante no FreeBSD. Seja como um sólido servidor corporativo, um servidor de Internet ou ainda uma confiável estação de trabalho, o FreeBSD quase certamente fará tudo o que você precisa. Muitos usuários de computador ao redor do mundo, incluindo novatos e experientes administradores UNIX(TM), usam o FreeBSD como seu único sistema operacional de desktop.

Os usuários que migrarem para o FreeBSD vindos de outro ambiente UNIX(TM)-like irão achar o FreeBSD bastante similar. Os usuários de Windows(TM) e do Mac OS(TM) podem se interessar em usar o https://www.furybsd.org/[FuryBSD], https://ghostbsd.org/[GhostBSD] ou https://www.midnightbsd.org/[MidnightBSD], três distribuições desktop baseadas no FreeBSD. Os usuários que não estão habituados ao uso de sistemas UNIX(TM) devem investir algum tempo adicional aprendendo a maneira de fazer as coisas no UNIX(TM). Este FAQ e o link:{handbook}[Manual do FreeBSD ] são excelentes lugares para iniciar.

=== Por que ele é chamado de FreeBSD?

* Pode ser usado gratuitamente, até mesmo por usuários comerciais.
* O código fonte completo do sistema operacional está disponível gratuitamente, e foram colocadas restrições mínimas sobre seu uso, distribuição e incorporação em outro trabalho (comercial ou não comercial).
* Qualquer pessoa que tenha uma melhoria ou correção de bug está livre para enviar seu código e para adicioná-lo ao repositório de código-fonte (sujeito a uma ou duas provisões óbvias).

Vale ressaltar que a palavra "free" está sendo usada de duas formas aqui: uma que significa "sem custo" (grátis) e a outra que significa "faça o que quiser" (Livre). Fora uma ou duas coisas que você _não pode_ fazer com o código do FreeBSD, por exemplo, fingir que você o escreveu, você pode realmente fazer o que quiser com ele.

=== Quais são as diferenças entre o FreeBSD, o NetBSD, o OpenBSD e os outros sistemas operacionais BSD de código aberto?

O James Howard escreveu uma boa explicação da história e das diferenças entre os vários projetos BSD, chamada https://jameshoward.us/archive/the-bsd-family-tree/[A árvore genealógica do BSD], a qual é uma boa forma de responder a esta pergunta. Algumas das informações estão desatualizadas, mas a parte da história em particular permanece precisa.

A maioria dos BSDs compartilha patches e códigos, até hoje. Todos os BSDs descendem dos mesmos ancestrais.

Os objetivos de design do FreeBSD estão descritos em <<FreeBSD-goals>>, acima. Os objetivos de design dos outros BSDs mais populares podem ser resumidos da seguinte forma:

* O OpenBSD visa a segurança do sistema operacional acima de tudo. A equipe do OpenBSD escreveu o man:ssh[1] e o man:pf[4], os quais foram portados para o FreeBSD.
* O NetBSD pretende ser facilmente portado para outras plataformas de hardware.
* O DragonFly BSD é um fork do FreeBSD 4.8 o qual desenvolveu muitas características interessantes ao longo dos anos, incluindo o sistema de arquivos HAMMER e o suporte para "vkernels" no modo de usuário.

=== Qual é a última versão do FreeBSD?

A qualquer momento no desenvolvimento do FreeBSD, podem existir vários branches paralelos. As releases 12._X_ são geradas a partir da branch _12-STABLE_ e as releases 11._X_ são geradas a partir do branch _11-STABLE_.

Até o lançamento da versão 12.0, a série 11._X_ era a conhecida como _-STABLE_. No entanto, a partir da 13._X_, a branch 11._X_ será designada para um status de "suporte estendido" e passará a receber apenas correções para problemas maiores, como as correções relacionadas à segurança.

As releases são liberadas a <<release-freq,cada poucos meses>>. Embora muitas pessoas se mantenham mais que isso por meio do código fonte do FreeBSD (veja as perguntas em <<current,FreeBSD-CURRENT>> e <<stable,FreeBSD-STABLE>> ), esta periodicidade está mais para um compromisso, já que o código fonte é um alvo em movimento.

Mais informações sobre as releases do FreeBSD podem ser encontradas na https://www.FreeBSD.org/releng/#release-build[página de Engenharia de Releases] e em man:release[7].

=== O que é o FreeBSD-CURRENT?

O link:{handbook}#current[FreeBSD-CURRENT] é a versão de desenvolvimento do sistema operacional, que no devido tempo se tornará o novo branch FreeBSD-STABLE. Como tal, ele é recomendado apenas para os desenvolvedores que trabalham no sistema e usuários amadores obstinados. Consulte a link:{handbook}#current[seção relevante] no link:{handbook}[Handbook] para detalhes sobre como executar o _-CURRENT_.

Usuários não familiarizados com o FreeBSD não devem usar o FreeBSD-CURRENT. Este branch às vezes evolui muito rapidamente e, devido a um erro, pode ser difícil de compilá-lo às vezes. Espera-se que as pessoas que usam o FreeBSD-CURRENT possam analisar, depurar e reportar problemas.

=== Qual é o conceito do FreeBSD-STABLE?

O _FreeBSD-STABLE_ é o branch de desenvolvimento a partir do qual os releases principais são feitos. Mudanças entram nesta branch em um ritmo mais lento e com a suposição geral de que eles foram testados primeiro no FreeBSD-CURRENT. No entanto, a qualquer momento, o código fonte para o FreeBSD-STABLE pode ou não ser adequado para uso geral, devido a descoberta de bugs e/ou outros casos específicos que ainda não foram encontrados no FreeBSD-CURRENT. Usuários que não possuem recursos para realizar testes devem, ao invés dessa, executar a release mais recente do FreeBSD. O _FreeBSD-CURRENT_, por outro lado, tem sido uma linha ininterrupta desde que o 2.0 foi lançado.

Para obter informações mais detalhadas sobre as branches, consulte "link:{releng}#rel-branch[Engenharia de Releases do FreeBSD: Criando uma Release Branch]", o status dos branches e o cronograma para releases futuros podem ser encontrados na página https://www.FreeBSD.org/releng[Release Engineering Information].

A versão https://download.FreeBSD.org/ftp/releases/amd64/amd64/12.1-RELEASE/[12.1] é a última release da branch _12-STABLE_; ela foi lançada em Novembro de 2019. A versão https://download.FreeBSD.org/ftp/releases/amd64/amd64/11.3-RELEASE/[11.3] é a release mais recente da branch _11-STABLE_; e foi lançada em Julho de 2019.

=== Quando são realizados os lançamentos de novas versões do FreeBSD?

A Equipe de Engenharia de Releases (Release Engineering Team) mailto:re@FreeBSD.org[re@FreeBSD.org] lança uma nova versão principal do FreeBSD a cada 18 meses e uma nova versão secundária a cada 8 meses, em média. As datas de lançamento são anunciadas com bastante antecedência, para que as pessoas que trabalham no sistema saibam quando seus projetos precisam ser finalizados e testados. Um período de teste precede cada lançamento, para garantir que a adição de novos recursos não comprometa a estabilidade do lançamento. Muitos usuários consideram este cuidado como uma das melhores coisas do FreeBSD, apesar de que a espera para que todas as novidades mais recentes sejam disponibilizadas no _-STABLE_ possa ser um pouco frustrante.

Maiores informações sobre o processo de engenharia de releases (incluindo a programação das releases futuros) podem ser encontradas na página https://www.FreeBSD.org/releng/[engenharia de release] no site do FreeBSD.

Para aquelas pessoas que precisam ou querem um pouco mais de emoção, os snapshots binários são disponibilizados semanalmente, como discutido acima.

=== Quando são feitos os snapshots do FreeBSD?

As https://www.FreeBSD.org/snapshots/[snapshot] releases do FreeBSD são disponibilizadas com base no estado atual das branchs _-CURRENT_ e _-STABLE_. Os objetivos por trás de cada release de snapshot são:

* Testar a versão mais recente do software de instalação.
* Para que as pessoas que gostariam de executar o _-CURRENT_ ou o _-STABLE_ mas que não têm tempo ou largura de banda para acompanhá-lo no dia-a-dia tenham uma maneira fácil de instalá-las em seus sistemas.
* Para preservar um ponto de referência fixo para o código em questão, apenas no caso de quebrarmos algo de forma muito seria depois. (Embora o Subversion normalmente previna que uma coisa horrível como esta ocorra.)
* Para garantir que todos os novos recursos e correções que precisam de testes tenham contato o maior número possível de testadores em potencial.

Não temos a pretensão de que qualquer snapshot _-CURRENT_ possa ser considerado com "qualidade de produção" para qualquer finalidade. Se você necessita de um sistema estável e totalmente testado, limite-se ao uso das releases completas.

As snapshots releases estão disponíveis em https://www.FreeBSD.org/snapshots/[snapshot].

Os snapshots oficiais são gerados regularmente para todas as branchs ativamente desenvolvidas.

=== Quem é responsável pelo FreeBSD?

As principais decisões relativas ao projeto FreeBSD, tais como a direção geral do projeto e quem tem permissão para adicionar código ao repositório de código fonte, são feitas por meio de um https://www.FreeBSD.org/administration/#t-core[core team] de 9 pessoas. Existe uma equipe muito maior, com mais de 350 link:{contributors}#staff-committers[committers] que estão autorizados a fazer alterações diretamente na árvore de fontes do FreeBSD.

No entanto, a maioria das alterações não-triviais é discutida com antecedência nas <<mailing,listas de discussão>>, e não há restrições sobre quem pode participar da discussão.

=== Onde posso obter o FreeBSD?

Todas releases importantes do FreeBSD estão disponíveis via FTP anônimo no https://download.FreeBSD.org/ftp/releases/[site FTP do FreeBSD]:

* O último release da série _12-STABLE_, o 12.1-RELEASE, pode ser encontrado no https://download.FreeBSD.org/ftp/releases/amd64/amd64/12.1-RELEASE/[diretório 12.1-RELEASE].
* Mensalmente são produzidos https://www.FreeBSD.org/snapshots/[snapshot] releases para as branchs <<current,-CURRENT>> e <<stable,-STABLE>>, as quais destinam-se primariamente ao uso por parte dos desenvolvedores e testadores.
* O último release da série _11-STABLE_, o 11.3-RELEASE, pode ser encontrado no https://download.FreeBSD.org/ftp/releases/amd64/amd64/11.3-RELEASE/[diretório 11.3-RELEASE].

Informações sobre como obter o FreeBSD em CD, DVD e outras mídias podem ser encontradas no link:{handbook}#mirrors[Handbook].

=== Como acesso o banco de dados dos Relatórios de Problemas?

O banco de dados com os Relatórios de Problemas contendo todas as solicitações de mudança enviadas pelos nossos usuários pode ser consultado usando nossa interface web de https://bugs.FreeBSD.org/search/[consulta] de PRs.

A https://www.FreeBSD.org/support/bugreports/[interface web de envio de relatórios de problemas] pode ser usada para enviar relatórios de problemas através de um navegador.

Antes de enviar um relatório de problema, leia link:{problem-reports}[Escrevendo Relatórios de Problemas do FreeBSD], um artigo sobre como escrever bons relatórios de problemas.

== Documentação e Suporte

=== Quais os livros existentes sobre o FreeBSD?

O projeto produz uma ampla gama de documentação, disponível on-line a partir deste link: https://www.FreeBSD.org/docs/[https://www.FreeBSD.org/docs].

=== A documentação está disponível em outros formatos, tais como texto simples (ASCII) ou PDF?

Sim. A documentação está disponível em vários formatos diferentes e esquemas de compressão no site FTP do FreeBSD, no diretório https://download.freebsd.org/ftp/doc/[/ftp/doc/].

A documentação é categorizada de várias maneiras diferentes. Que incluem:

* O nome do documento, tais como como `faq` ou `handbook`.
* A linguagem e codificação do documento. Estes são baseados nos nomes de local encontrados sob o diretório [.filename]#/usr/shared/locale# em um sistema FreeBSD. Os idiomas e codificações atuais são os seguintes:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Nome
| Significado

|`en_US.ISO8859-1`
|Inglês (Estados Unidos)

|`bn_BD.ISO10646-1`
|Bengali ou Bangla (Bangladesh)

|`da_DK.ISO8859-1`
|Dinamarquês (Dinamarca)

|`de_DE.ISO8859-1`
|Alemão (Alemanha)

|`el_GR.ISO8859-7`
|Grego (Grécia)

|`es_ES.ISO8859-1`
|Espanhol (Espanha)

|`fr_FR.ISO8859-1`
|Francês (França)

|`hu_HU.ISO8859-2`
|Húngaro (Hungria)

|`it_IT.ISO8859-15`
|Italiano (Itália)

|`ja_JP.eucJP`
|Japonês (Japão, codificação EUC)

|`ko_KR.UTF-8`
|Coreano (Coreia, codificação UTF-8)

|`mn_MN.UTF-8`
|Mongol (Mongólia, codificação UTF-8)

|`nl_NL.ISO8859-1`
|Holandês (Holanda)

|`pl_PL.ISO8859-2`
|Polonês (Polônia)

|`pt_BR.ISO8859-1`
|Português (Brasil)

|`ru_RU.KOI8-R`
|Russo (Rússia, codificação KOI8-R)

|`tr_TR.ISO8859-9`
|Turco (Turquia)

|`zh_CN.UTF-8`
|Chinês Simplificado (China, codificação UTF-8)

|`zh_TW.UTF-8`
|Chinês Tradicional (Taiwan, codificação UTF-8)
|===
+
[NOTE]
====
Alguns documentos podem não estar disponíveis em todos os idiomas.
====

* O formato do documento. Produzimos a documentação em vários formatos de saída diferentes. Cada formato tem suas próprias vantagens e desvantagens. Alguns formatos são mais adequados para leitura on-line, enquanto outros estão formatados para serem esteticamente agradáveis quando impressos em papel. A disponibilização da documentação em diversos formatos garante que os nossos leitores possam ler as partes nas quais estão interessados, seja em seu monitor ou em papel após imprimi-los documentos. Os formatos disponíveis atualmente são:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Formato
| Significado

|`html-split`
|Uma coleção de pequenos arquivos HTML vinculados.

|`html`
|Um grande arquivo HTML contendo o documento inteiro

|`pdf`
|Formato de documento portátil da Adobe

|`txt`
|Texto simples
|===

* O esquema de compactação e empacotamento.
.. Onde o formato é `html-split`, os arquivos são agrupados usando man:tar[1]. O arquivo resultante [.filename]#.tar# é então compactado usando os esquemas de compactação detalhados no próximo passo.
.. Todos os outros formatos geram um único arquivo. Por exemplo, [.filename]#article.pdf#, [.filename]#book.html# e assim por diante.
+ 
Esses arquivos são então compactados usando os esquemas de compactação `zip` ou `bz2`. O comando man:tar[1] pode ser usado para descompactar esses arquivos.
+ 
Portanto, a versão PDF do Handbook, compactada usando `bzip2` será armazenada em um arquivo chamado [.filename]#book.ps.bz2# no diretório [.filename]#handbook/#.

Depois de escolher o formato e o mecanismo de compactação, baixe os arquivos compactados, descompacte-os e copie os documentos para um lugar apropriado.

Por exemplo, a versão split HTML do FAQ, compactada usando man:bzip2[1], pode ser encontrada em [.filename]#doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2# Para baixar e descompactar esse arquivo, digite:

[source,bash]
....
# fetch https://download.freebsd.org/ftp/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2
# tar xvf book.html-split.tar.bz2
....

Se o arquivo estiver compactado, o tar detectará automaticamente o formato apropriado e o descompactará corretamente, resultando em uma coleção de arquivos [.filename]#.html#. O principal deles é chamado [.filename]#index.html#, que conterá o sumário, o material introdutório e os links para as outras partes do documento.

=== Onde encontro informações sobre as listas de discussão do FreeBSD? Quais grupos de notícias do FreeBSD estão disponíveis?

Consulte as seções do Handbook sobre as link:{handbook}#eresources-mail[listas de discussão] e sobre os link:{handbook}#eresources-news[grupos de notícias].

=== Existem canais de IRC (Internet Relay Chat) sobre o FreeBSD?

Sim, a maioria das redes de IRC hospedam um canal de chat do FreeBSD:

* Canal `#FreeBSDhelp` na http://www.efnet.org/index.php[EFNet] é um canal dedicado a ajudar usuários do FreeBSD.
* Canal `#FreeBSD` na http://freenode.net/[Freenode] é um canal de ajuda geral com muitos usuários a qualquer horário. É de conhecimento que conversas off-topic acontecem em alguns momentos, mas a prioridade é dada aos usuários com perguntas sobre o FreeBSD. Outros usuários podem ajudar com o básico, consultando o Handbook sempre que possível e fornecendo links para ajudá-lo a aprender mais sobre um determinado tópico. Este é um canal em que a comunicação ocorre primariamente em inglês, embora seja frequentado por usuários de todo o mundo. As pessoas que não são falantes nativas do inglês devem tentar fazer as suas perguntas primeiro em inglês e, em seguida, tentar nos canais `## freebsd-lang` conforme apropriado.
* Canal `#FreeBSD` na http://www.dal.net/[DALNET] está disponível em `irc.dal.net` nos EUA e `irc.eu.dal.net` na Europa.
* O canal `#FreeBSD` na http://www.undernet.org/[UNDERNET] está disponível em `us.undernet.org` nos EUA e `eu.undernet.org` na Europa. Como é um canal de ajuda, prepare-se para ler os documentos aos quais você for direcionado.
* O canal `#FreeBSD` na http://www.rusnet.org.ru/[RUSNET] é um canal de língua russa dedicado a ajudar os usuários do FreeBSD. Este também é um bom lugar para discussões não técnicas.
* O canal `#bsdchat` na http://freenode.net/[Freenode] é um canal de idioma chinês tradicional (codificação UTF-8) dedicado a ajudar os usuários do FreeBSD. Este também é um bom lugar para discussões não técnicas.

A wiki do FreeBSD tem uma https://wiki.freebsd.org/IRC/Channels[boa lista] dos canais de IRC.

Cada um destes canais são distintos e não estão conectados entre si. Como os estilos de bate-papo diferem, experimente cada um deles para encontrar um adequado ao seu estilo de bate-papo.

=== Existem fóruns na web para discutir o FreeBSD?

Os fóruns oficiais do FreeBSD estão localizados em https://forums.FreeBSD.org/[https://forums.FreeBSD.org/].

=== Onde posso obter treinamento e suporte comercial para o FreeBSD?

A http://www.ixsystems.com[ iXsystems, Inc. ], empresa controladora do http://www.freebsdmall.com/[FreeBSD Mall], fornece http://www.ixsystems.com/support[supporte] comercial para o FreeBSD e TrueOS, e também soluções de desenvolvimento e customização para o FreeBSD.

A BSD Certification Group, Inc. fornece certificações de administração do sistema para o DragonFly BSD, FreeBSD, NetBSD e OpenBSD. Consulte http://www.BSDCertification.org[seu site] para maiores informações.

Quaisquer outras organizações que forneçam treinamento e suporte devem entrar em contato com o Projeto FreeBSD para serem listadas aqui.

== Instalação

=== Qual plataforma devo baixar? Eu tenho uma CPU compatível com 64 bits Intel, mas eu só encontro amd64.

amd64 é o termo que o FreeBSD usa para arquiteturas x86 compatíveis com 64 bits (também conhecidas como "x86-64" ou "x64"). Para a maioria dos computadores modernos você deve usar a opção amd64. Para hardware mais antigo você deve usar o i386. Ao instalar em uma arquitetura não compatível com x86, selecione a plataforma que melhor corresponda ao hardware.

=== Qual arquivo eu baixo para ter o FreeBSD?

Na página https://www.freebsd.org/where/[Como obter o FreeBSD], selecione `[iso]` ao lado da arquitetura que corresponde ao seu hardware.

Qualquer um dos itens a seguir pode ser usado:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| arquivo
| descrição

|[.filename]#disc1.iso#
|Contém o suficiente para instalar o FreeBSD e um conjunto mínimo de pacotes.

|[.filename]#dvd1.iso#
|Semelhante ao [.filename]#disc1.iso#, mas com pacotes adicionais.

|[.filename]#memstick.img#
|Uma imagem inicializável para se gravar em um pendrive.

|[.filename]#bootonly.iso#
|Uma imagem mínima e que requer acesso à rede durante a instalação para que possa instalar completamente o FreeBSD.
|===

Instruções completas sobre este procedimento e um pouco mais sobre problemas de instalação em geral podem ser encontradas na seção do Handbook link:{handbook}#bsdinstall[sobre instalação do FreeBSD].

=== O que eu faço se a imagem de instalação não inicializar?

Isso pode ocorrer caso você não tenha baixado a imagem no modo _binário_ ao usar o FTP.

Alguns clientes FTP padronizam seu modo de transferência para _ascii_ e tentam alterar quaisquer caracteres de end-of-line recebidos para corresponder às convenções usadas pelo sistema do cliente. Isso quase invariavelmente corromperá a imagem de inicialização. Verifique checksum SHA-256 da imagem de inicialização baixada: se não estiver _exatamente_ como no servidor, o processo de download pode ter corrompido o arquivo.

Ao usar um cliente FTP de linha de comando, digite _binary_ no prompt de comando FTP depois de se conectar ao servidor e antes de iniciar o download da imagem.

=== Onde estão as instruções para instalar o FreeBSD?

As instruções para instalação podem ser encontradas na seção do Handbook link:{handbook}#bsdinstall[sobre instalação do FreeBSD].

=== Como posso criar minha própria versão personalizada ou disco de instalação?

Uma mídia customizada de instalação do FreeBSD pode ser criada através da construção de uma release personalizada. Siga as instruções do artigo link:{releng}[Release Engineering].

=== O Windows pode coexistir com o FreeBSD? (específico de x86)

Se o Windows(TM) for instalado primeiro, então sim. O gerenciador de boot do FreeBSD irá então inicializar o Windows(TM) e o FreeBSD. Se o Windows(TM) for instalado posteriormente, ela sobrescreverá o gerenciador de inicialização. Se isso acontecer, veja a próxima seção.

=== Outro sistema operacional destruiu meu Gerenciador de Inicialização. Como faço para recuperá-lo? (específico de x86)

Isso depende do gerenciador de inicialização. O menu de seleção de inicialização do FreeBSD pode ser reinstalado usando man:boot0cfg[8]. Por exemplo, para restaurar o menu de inicialização no disco _ada0_:

[source,bash]
....
# boot0cfg -B ada0
....

O gerenciador de inicialização MBR não interativo pode ser instalado usando man:gpart[8]:

[source,bash]
....
# gpart bootcode -b /boot/mbr ada0
....

Para situações mais complexas, incluindo discos GPT, consulte man:gpart[8].

=== Preciso instalar o código fonte?

Em geral, não. Não há nada no sistema base que exija a presença do código fonte para operar. Alguns ports, como o package:sysutils/lsof[], não serão compilados a menos que o código fonte esteja instalado. Em particular, se o port compila um módulo de kernel ou opera diretamente em estruturas de kernel, o código fonte deve ser instalado.

=== Eu preciso compilar um kernel?

Geralmente não. O kernel `GENERIC` fornecido contém todos os drivers que um computador comum precisará. O man:freebsd-update[8], a ferramenta de atualização binária do FreeBSD, não pode atualizar kernels customizados, o que é uma outra razão para se manter com o kernel `GENERIC` sempre que possível. Para computadores com uma quantidade de memória RAM muito limitada, como sistemas embarcados, pode valer a pena compilar um kernel customizado menor contendo apenas os drivers necessários.

=== Devo usar senhas DES, Blowfish ou MD5 e como eu específico qual tipo meus usuários irão receber?

O FreeBSD usa _SHA512_ por padrão. Senhas DES ainda estão disponíveis para compatibilidade com sistemas operacionais que ainda usam um formato de senha menos seguro. O FreeBSD também suporta os formatos de senha Blowfish e MD5. O formato de senha que será usado para novas senhas é controlado pelo recurso de login `passwd_format` no arquivo [.filename]#/etc/login.conf#, que recebe valores de `des`, `blf` (se estiverem disponíveis) ou `md5`. Veja a página de manual man:login.conf[5] para maiores informações sobre as capacidades de login.

=== Quais são os limites para sistemas de arquivos FFS?

Para os sistemas de arquivos FFS, o tamanho máximo é praticamente limitado pela quantidade de memória necessária para executar o man:fsck[8] no sistema de arquivo. O man:fsck[8] requer um bit por fragmento, que com o tamanho de fragmento padrão de 4 KB equivale a 32 MB de memória por TB de disco. Isso significa que nas arquiteturas que limitam os processos userland a 2 GB (por exemplo, i386(TM)), o tamanho máximo do sistema de arquivos que o man:fsck[8] permite operar é de ~ 60 TB.

Se não houvesse um limite de memória para o man:fsck[8], o tamanho máximo do sistema de arquivos seria 2 ^ 64 (blocks) * 32 KB => 16 Exa * 32 KB => 512 ZettaBytes.

O tamanho máximo de um único arquivo FFS é de aproximadamente 2 PB com o tamanho de bloco padrão de 32 KB. Cada bloco de 32 KB pode apontar para 4096 blocos. Com blocos triplo indiretos, o cálculo é 32 KB * 12 + 32 KB * 4096 + 32 KB * 4096 ^ 2 + 32 KB * 4096 ^ 3. Aumentar o tamanho do bloco para 64 KB aumentará o tamanho máximo do arquivo por um fator de 16.

=== Por que recebo uma mensagem de erro, readin failed depois de compilar e inicializar um novo kernel?

O world (aplicativos e bicliotecas do userland)e o kernel estão fora de sincronia. Isso não é suportado. Certifique-se de usar `make buildworld` e `make build-kernel` para atualizar o kernel.

Inicialize o sistema especificando o kernel diretamente no segundo estágio, pressionando qualquer tecla quando o `|` aparecer antes que o utilitário de carga (loader) seja iniciado.

=== Existe uma ferramenta para realizar tarefas de configuração pós-instalação?

Sim. O bsdconfig fornece uma boa interface para configurar o FreeBSD na pós-instalação.

== Compatibilidade de Hardware

[[compatibility-general]]
=== Geral

==== Eu quero obter um componente de hardware para o meu sistema FreeBSD. Qual modelo/marca/tipo é o melhor?

Isso é discutido continuamente nas listas de discussão do FreeBSD, mas isto é de se esperar, já que o hardware muda tão rapidamente. Leia as Notas de Hardware do FreeBSD https://www.FreeBSD.org/releases/12.1r/hardware/[12.1] ou https://www.FreeBSD.org/releases/11.3r/hardware/[11.3] e pesquise os https://www.FreeBSD.org/search/#mailinglists[arquivos] da lista de discussão antes de perguntar sobre o hardware mais recente e melhor. As chances são de que uma discussão sobre esse tipo de hardware tenha acontecido na semana passada.

Antes de comprar um laptop, verifique os arquivos da http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions[lista de discussão de questões gerais do FreeBSD], ou possivelmente uma lista de discussão específica para um tipo específico de hardware.

==== Quais são os limites para a memória?

O FreeBSD como sistema operacional geralmente suporta tanta memória física (RAM) quanto a disponível na plataforma em que está rodando. Tenha em mente que plataformas diferentes têm limites diferentes para a memória; por exemplo i386(TM) sem PAE suporta no máximo 4 GB de memória (e geralmente menos que isso por causa do espaço de endereçamento PCI) e i386(TM) com PAE suporta no máximo 64 GB de memória. A partir do FreeBSD 10, as plataformas AMD64 suportam até 4 TB de memória física.

==== Por que o FreeBSD reporta menos de 4 GB de memória quando instalado em uma máquina i386?

O espaço total de endereços nas máquinas i386(TM) é de 32 bits, o que significa que no máximo 4 GB de memória são endereçáveis (podem ser acessados). Além disso, alguns endereços nesse intervalo são reservados por hardware para diferentes finalidades, por exemplo, para usar e controlar dispositivos PCI, para acessar a memória de vídeo e assim por diante. Portanto, a quantidade total de memória utilizável pelo sistema operacional para o seu kernel e aplicativos é limitada a significativamente menos de 4 GB. Normalmente, temos de 3,2 GB a 3,7 GB de memória física máxima utilizável nessa configuração.

Para acessar mais de 3,2 GB a 3,7 GB de memória instalada (ou seja, até 4 GB, mas também mais de 4 GB), um ajuste especial chamado PAE deve ser usado. PAE significa Physical Address Extension e é uma maneira das CPUs x86 de 32 bits endereçarem mais de 4 GB de memória. Ele remapeia a memória que de outra forma seria sobreposta pelas reservas de endereço para dispositivos de hardware acima do intervalo de 4 GB e a usa como memória física adicional (veja man:pae[4]). Usar o PAE tem alguns inconvenientes; este modo de acesso à memória é um pouco mais lento que o modo normal (sem PAE) e módulos carregáveis (veja man:kld[4]) não são suportados. Isso significa que todos os drivers devem ser compilados estaticamente no kernel.

A maneira mais comum de ativar o PAE é compilar um novo kernel com o arquivo especial de configuração do kernel, chamado [.filename]#PAE#, que já está configurado para compilar um kernel seguro. Observe que algumas entradas neste arquivo de configuração do kernel são muito conservadoras e alguns drivers marcados como não prontos para serem usados com o PAE na verdade são possíveis de serem utilizados. Uma regra básica é que, se o driver for utilizável em arquiteturas de 64 bits (como o AMD64), ele também poderá ser usado com o PAE. Ao criar um arquivo de configuração de kernel personalizado, o suporte ao PAE pode ser ativada adicionando a seguinte linha:

[.programlisting]
....
options       PAE
....

O PAE não é muito usado atualmente porque a maioria dos novos hardwares x86 também suporta a execução no modo de 64 bits, conhecido como AMD64 ou Intel(TM)64. Ele tem um espaço de endereçamento muito maior e não precisa tais ajustes. O FreeBSD suporta o AMD64 e é recomendado que esta versão do FreeBSD seja usada no lugar da versão i386(TM) se forem necessários 4 GB ou mais de memória.

[[compatibility-processors]]
=== Arquiteturas e Processadores

==== O FreeBSD suporta arquiteturas diferentes do x86?

Sim. O FreeBSD divide o suporte em vários níveis. Arquiteturas de Tier 1, como i386 ou amd64; são totalmente suportados. Tiers 2 e 3 são suportados com base no melhor esforço. Uma explicação completa do sistema de tiers está disponível no link:{committers-guide}#archs[Guia dos Committers.]

Uma lista completa de arquiteturas suportadas pode ser encontrada na https://www.FreeBSD.org/platforms/[páginas de plataformas.]

==== O FreeBSD suporta o Multiprocessamento Simétrico (SMP)?

O FreeBSD suporta multiprocessadores simétricos (SMP) em todas as plataformas não-embarcadas (por exemplo, i386, amd64, etc.). O SMP também é suportado em kernels arm e MIPS, embora algumas CPUs possam não suportar isso. A implementação do SMP do FreeBSD usa o bloqueio refinado, e o desempenho escala quase linearmente com o número de CPUs.

A página de manual do man:smp[4] tem maiores detalhes.

==== O que é microcódigo? Como eu instalo as atualizações de microcódigo da Intel?

Microcódigo é um método de implementar programaticamente instruções de nível de hardware. Isso permite que os bugs da CPU sejam corrigidos sem a necessidade de substituir fisicamente o chip.

Instale o package:sysutils/devcpu-data[] e adicione:

[.programlisting]
....
microcode_update_enable="YES"
....

no [.filename]#/etc/rc.conf#

[[compatibility-peripherals]]
=== Periféricos

==== Que tipo de periféricos o FreeBSD suporta?

Veja a lista completa nas Notas de Hardware para o FreeBSD https://www.FreeBSD.org/releases/12.1r/hardware[12.1] ou https://www.FreeBSD.org/releases/11.3r/hardware[11.3].

[[compatibility-kbd-mice]]
=== Teclados e Mouses

[[moused]]
==== É possível usar um mouse fora do sistema X Window?

O driver de console padrão, man:vt[4], fornece a capacidade de usar um ponteiro de mouse em consoles de texto para cortar & colar o texto. Execute o daemon do mouse, man:moused[8] e ative o ponteiro do mouse no console virtual:

[source,bash]
....
# moused -p /dev/xxxx -t yyyy
# vidcontrol -m on
....

No qual _xxxx_ é o nome do dispositivo de mouse e _yyyy_ é o tipo de protocolo para o mouse. O daemon do mouse pode determinar automaticamente o tipo de protocolo da maioria dos mouses, exceto antigos mouses seriais. Especifique o protocolo `auto` para invocar a detecção automática. Se a detecção automática não funcionar, consulte a página de manual man:moused[8] para obter uma lista dos tipos de protocolos suportados.

Para um mouse PS/2, adicione `moused_enable="YES"` ao arquivo [.filename]#/etc/rc.conf# para iniciar o daemon do mouse no momento da inicialização. Além disso, para usar o daemon do mouse em todos os terminais virtuais em vez de apenas no console, adicione `allscreens_flags="-m on"` ao arquivo [.filename]#/etc/rc.conf#.

Quando o daemon do mouse está em execução, o acesso ao mouse deve ser coordenado entre o daemon do mouse e outros programas, tais como o X Windows. Consulte o FAQ<<x-and-moused, Por que meu mouse não funciona com o X?>> para obter mais detalhes sobre esse problema.

==== Como faço para cortar e colar texto com um mouse no console de texto?

Não é possível remover (cortar) dados usando o mouse. No entanto, é possível copiar e colar. Quando o daemon do mouse estiver em execução, conforme descrito na <<moused,pergunta anterior>>, mantenha pressionado o botão 1 (botão esquerdo) e mova o mouse para selecionar uma região do texto. Em seguida, pressione o botão 2 (botão do meio) para colar no cursor de texto. Pressionar o botão 3 (botão direito) irá " estender " a região selecionada do texto.

Se o mouse não tiver um botão do meio, é possível emular um ou remapear os botões usando as opções do daemon do mouse. Consulte a página de manual man:moused[8] para obter detalhes.

==== Meu mouse tem uma roda e botões extravagantes. Posso usá-los no FreeBSD?

A resposta é, infelizmente, "Depende". Esses mouses com recursos adicionais exigem um driver especializado na maioria dos casos. A menos que o driver do dispositivo do mouse ou o programa do usuário tenha suporte específico para o mouse, ele funcionará exatamente como um mouse padrão de dois ou três botões.

Para o possível uso de rodas do mouse no ambiente X Window, consulte <<x-and-wheel,essa seção>>.

==== Como eu uso a minha tecla de delete no sh e csh?

Para o Bourne Shell, inclua as seguintes linhas no arquivo [.filename]#~/.shrc#. Veja man:sh[1] e man:editrc[5].

[.programlisting]
....
bind ^[[3~ ed-delete-next-char # para o xterm
....

Para o C Shell, adicione as seguintes linhas ao [.filename]#~/.cshrc#. Veja man:csh[1].

[.programlisting]
....
bindkey ^[[3~ delete-char # para o xterm
....

[[compatibility-other]]
=== Outro hardware

==== Algum workaround para o problema de não sair nenhum som da minha placa de som pcm4?

Algumas placas de som definem seu volume de saída como 0 em cada inicialização. Execute o seguinte comando toda vez que a máquina inicializar:

[source,bash]
....
# mixer pcm 100 vol 100 cd 100
....

==== O FreeBSD suporta o gerenciamento de energia no meu laptop?

O FreeBSD suporta os recursos ACPI encontrados em componentes modernos de hardware. Maiores informações podem ser encontradas em man:acpi[4].

== Solução de problemas

=== Por que o FreeBSD está encontrando a quantidade errada de memória no hardware i386?

O motivo mais provável é a diferença entre endereços de memória física e endereços virtuais.

A convenção para a maioria dos hardwares de PC é usar a área de memória entre 3,5 GB e 4 GB para uma finalidade especial (geralmente para PCI). Este espaço de endereço é usado para acessar o hardware PCI. Como resultado real, a memória física não pode ser acessada por esse espaço de endereço.

O que acontece com a memória que deveria aparecer nesse local depende do hardware. Infelizmente, alguns hardwares não fazem nada e a capacidade de usar estes últimos 500 MB de RAM é totalmente perdida.

Felizmente, a maioria dos hardwares faz o remapeamento da memória para um local mais alto, para que ela ainda possa ser usada. No entanto, isso pode causar alguma confusão ao observar as mensagens de inicialização.

Em uma versão de 32 bits do FreeBSD, a memória parece perdida, uma vez que ela será remapeada acima de 4 GB, uma área a qual um kernel de 32 bits não consegue acessar. Neste caso, a solução é construir um kernel habilitado para PAE. Veja a seção sobre os limites de memória para mais informações.

Em uma versão de 64 bits do FreeBSD, ou quando o kernel estiver habilitado para PAE, o FreeBSD irá corretamente detectar e remapear a memória para que ela seja utilizável. Durante a inicialização, no entanto, pode parecer que o FreeBSD está detectando mais memória do que o sistema realmente possui, devido ao remapeamento descrito. Isso é normal e a memória disponível será corrigida conforme o processo de inicialização for concluído.

=== Por que meus programas morrem ocasionalmente com erros Signal 11 ?

Os erros de sinal 11 são causados quando um processo tentou acessar a memória à qual o sistema operacional não concedeu acesso. Se algo assim está acontecendo em intervalos aparentemente aleatórios, comece a investigar a causa.

Esses problemas geralmente podem ser atribuídos a:

. Se o problema está ocorrendo apenas em um aplicativo customizado específico, é provavelmente um bug no código.
. Se é um problema com parte do sistema base do FreeBSD, também pode ser resultado de um código com bugs, mas na maioria das vezes esses problemas são encontrados e corrigidos muito antes que o publico em geral e que normalmente lê o  FAQ  usem essas partes do código (é para isso que -CURRENT existe).

Provavelmente não é um erro do FreeBSD se o problema ocorrer na compilação de um programa, mas sim da atividade que o compilador está realizando e que muda a cada vez.

Por exemplo, se `make buildworld` falhar ao tentar compilar [.filename]#ls.c# para [.filename]#ls.o# e, quando executado novamente, ele falhar no mesmo lugar, significa que o código está quebrado. Tente atualizar o código fonte e tente compilar novamente. Se a compilação falhar em outro lugar, é quase certo que a causa é um problema de hardware.

No primeiro caso, use um depurador como o man:gdb[1] para localizar o ponto no programa que está tentando acessar um endereço falso e corrija-o.

No segundo caso, verifique qual peça de hardware está com defeito.

As causas comuns disso incluem:

. Os discos rígidos podem estar superaquecidos: Verifique se os ventiladores ainda estão funcionando, pois o disco e outros componentes de hardware podem estar superaquecendo.
. O processador está superaquecendo: pode ser porque o processador sofreu overclock ou o ventilador do processador pode ter parado de funcionar. Em ambos os casos, certifique-se de que o hardware esteja sendo utilizado de acordo com as condições especificadas pelo fabricante, pelo menos ao tentar resolver esse problema. Se não estiver, volte o clock para as configurações padrão.)
+ 
Em relação ao overclocking, é muito mais barato ter um sistema lento do que um sistema frito que precisa ser substituído! Além disso, a comunidade não é simpática a problemas em sistemas com overclock.
. Memória Errática: se vários módulos de memórias SIMMS/DIMMS estiverem instalados, retire-os e tente executar a máquina instalando cada SIMM ou DIMM individualmente para encontrar o modulo DIMM/SIMM problemático ou até mesmo encontrar uma combinação de módulos com problema.
. Configurações over-otimizadas da placa-mãe: as configurações da BIOS e alguns jumpers da placa-mãe oferecem opções para definir vários intervalos de tempo. Os valores padrões geralmente são suficientes, mas, às vezes, a configuração dos estados de espera na RAM para valores muito baixos, ou a configuração da opção "RAM Speed: Turbo" causará um comportamento estranho. Uma ideia válida é restaurar a configuração padrão da BIOS, depois é claro de anotar as configurações atuais.
. Fonte com potência insuficiente para energizar a placa-mãe: Remova qualquer placa de I/O não utilizada, discos rígidos ou CD-ROMs, desconectando o cabo de alimentação deles para ver se a fonte de alimentação pode gerenciar uma carga menor. Ou utilize outra fonte de alimentação, de preferência uma com um pouco mais de potência. Por exemplo, se a fonte de alimentação atual é recomendada para uma carga de 250 Watts, tente uma que seja recomendada para uma carga de 300 Watts.

Leia a seção sobre o <<signal11,Signal 11>> para obter maiores explicações e a discussão sobre como um software ou hardware de teste de memória ainda pode deixar passar uma memória defeituosa. Existe uma extensa FAQ sobre o problema do SIG11 disponível http://www.bitwizard.nl/sig11/[neste link].

Por fim, se nada disso ajudou, trata-se possivelmente de um bug no FreeBSD. Siga <<access-pr,estas instruções>> para enviar um relatório de problemas.

=== Meu sistema trava com Fatal trap 12: page fault in kernel mode ou panic:, e mostra um monte de informações. O que devo fazer?

Os desenvolvedores do FreeBSD estão interessados ​​nesses erros, mas precisam de mais informações do que apenas a mensagem de erro. Copie a mensagem completa da falha. Em seguida, consulte a seção FAQ em <<kernel-panic-troubleshooting,kernel panics>>, compile um kernel de depuração e obtenha um backtrace. Isso pode parecer difícil, mas não requer nenhuma habilidade de programação. Apenas siga as instruções.

=== Qual é o significado do erro maxproc limit exceeded by uid %i, please see tuning(7) and login.conf(5)?

O kernel do FreeBSD permitirá que apenas um certo número de processos exista ao mesmo tempo. O número é baseado na variável `kern.maxusers` do man:sysctl[8]. O valor da variável `kern.maxusers` também afeta vários outros limites dentro do kernel, como por exemplo os buffers de rede. Se a máquina estiver muito carregada, aumente o `kern.maxusers`. Isso aumentará esses outros limites do sistema além do número máximo de processos.

Para ajustar o valor da variável `kern.maxusers`, consulte a seção link:{handbook}#kern-maxfiles[Limites de Arquivos / Processos] do Handbook. Apesar desta seção se referir a arquivos abertos, os mesmos limites se aplicam aos processos.

Se a máquina estiver levemente carregada, mas executando um número muito grande de processos, ajuste o valor do `kern.maxproc` definindo-o no arquivo [.filename]#/boot/loader.conf#. O ajuste não terá efeito até que o sistema seja reinicializado. Para mais informações sobre o tuning de variáveis, consulte o manual do man:loader.conf[5]. Se esses processos estiverem sendo executados por um único usuário, ajuste o `kern.maxprocperuid` para que fique menor em 1 unidade do novo valor do `kern.maxproc`. Ele deve ser pelo menos uma unidade menor porque o programa do sistema, man:init[8], deve estar sempre em execução.

=== Por que aplicativos de tela cheia em máquinas remotas se comportam de forma errática?

A máquina remota pode estar configurando o tipo de terminal para algo diferente de `xterm`, que é o tipo requerido pelo console do FreeBSD. Alternativamente, o kernel pode ter valores errados para a largura e a altura do terminal.

Verifique se o valor da variável de ambiente `TERM` é `xterm`. Se a máquina remota não suportar isso, tente `vt100`.

Execute o `stty -a` para verificar o que o kernel acha que são as dimensões do terminal. Se estiverem incorretos, eles podem ser alterados executando `stty rows_RR_cols_CC_`.

Alternativamente, se a máquina do cliente tiver o package:x11/xterm[] instalado, a execução do `resize` consultará o terminal para as dimensões corretas e as definirá.

=== Por que demora tanto para conectar ao meu computador via ssh ou telnet?

O sintoma: há um longo atraso entre o momento em que a conexão TCP é estabelecida e a hora em que o software cliente solicita uma senha (ou, no caso do man:telnet[1], quando um prompt de login aparece).

O problema: mais provável do que não, o atraso é causado pelo software do servidor tentando resolver o endereço IP do cliente em um nome de host. Muitos servidores, incluindo os servidores Telnet e SSH que vêm com o FreeBSD, fazem isso para armazenar o nome do host em um arquivo de log para referência futura pelo administrador.

A solução: se o problema ocorrer sempre, independente do servidor ao que o computador cliente se conecta, o problema está no cliente. Se o problema ocorrer apenas quando o computador cliente se conecta a um determinado servidor, o problema está no servidor.

Se o problema for com o cliente, a única solução é corrigir o DNS para que o servidor possa resolvê-lo. Se isso estiver ocorrendo em uma rede local, considere um problema no servidor e continue lendo. Se isso estiver ocorrendo na Internet, entre em contato com seu ISP.

Se o problema for com um servidor em uma rede local, configure o servidor para resolver as consultas de endereço para nome de host para o intervalo de endereços da rede local. Veja as páginas de manual para o man:hosts[5] e o man:named[8] para maiores informações. Se o problema for com um servidor na Internet, o problema pode ser que o resolver local do servidor não está funcionando corretamente. Para verificar se é isto, tente procurar outro host, como `www.yahoo.com`. Se isso não funcionar, este é o problema.

Após uma nova instalação do FreeBSD, também é possível que as informações do domínio e do servidor de nomes estejam faltando no [.filename]#/etc/resolv.conf#. Isso geralmente causará um atraso no SSH, já que a opção `UseDNS` é definida como `yes` por padrão no [.filename]#/etc/ssh/sshd_config#. Se isso estiver causando o problema, preencha as informações ausentes no arquivo [.filename]#/etc/resolv.conf# ou configure a opção `UseDNS` para `no` no arquivo [.filename]#sshd_config# como uma solução temporária.

=== Por que a mensagem file: table is full aparece repetidamente no dmesg8?

Essa mensagem de erro indica que o número de file descriptors disponíveis no sistema esgotaram. Consulte a informação sobre a variável link:{handbook}#kern-maxfiles[kern.maxfiles] na seção link:{handbook}#configtuning-kernel-limits[ Ajustando os Limites do Kernel ] do Handbook para uma discussão e solução.

=== Por que o relógio do meu computador mantém-se com o horário incorreto?

O computador tem dois ou mais relógios e o FreeBSD escolheu usar o errado.

Execute o comando man:dmesg[8] e verifique as linhas que contêm a palavra `Timecounter`. Aquele com o maior valor de quality é o que o FreeBSD escolheu.

[source,bash]
....
# dmesg | grep Timecounter
Timecounter "i8254" frequency 1193182 Hz quality 0
Timecounter "ACPI-fast" frequency 3579545 Hz quality 1000
Timecounter "TSC" frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec
....

Confirme isso verificando o valor da variável `kern.timecounter.hardware` no man:sysctl[3].

[source,bash]
....
# sysctl kern.timecounter.hardware
kern.timecounter.hardware: ACPI-fast
....

Pode ser um timer ACPI quebrado. A solução mais simples é desabilitar o timer ACPI no arquivo [.filename]#/boot/loader.conf#:

[.programlisting]
....
debug.acpi.disabled="timer"
....

Ou a BIOS poderá modificar o relógio TSC - talvez para mudar a velocidade do processador quando estiver funcionando a partir de baterias, ou quando estiver entrando em modo de economia de energia, mas o FreeBSD não tem conhecimento desses ajustes e parece ganhar ou perder tempo.

Neste exemplo, o relógio `i8254` também está disponível e pode ser selecionado alterando-se a variável `kern.timecounter.hardware` do man:sysctl[3].

[source,bash]
....
# sysctl kern.timecounter.hardware=i8254
kern.timecounter.hardware: TSC -> i8254
....

O computador agora deve começar a manter seu relógio mais preciso.

Para que essa mudança seja executada automaticamente no momento da inicialização, adicione a seguinte linha ao arquivo [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
kern.timecounter.hardware=i8254
....

=== O que significa o erro swap_pager: indefinite wait buffer:?

Isso significa que um processo está tentando armazenar em memória RAM a memória do disco (swap), e que o processo foi interrompido depois de tentar sem sucesso acessar o disco por mais de 20 segundos. Isso pode ser causado por blocos defeituosos na unidade de disco, fiação de disco defeituosa, cabos ou qualquer outro hardware relacionado a I/O de disco. Se a própria unidade estiver com problemas, erros de disco aparecerão em [.filename]#/var/log/messages# e na saída do comando `dmesg`. Caso contrário, verifique os cabos e conexões.

=== O que é um lock order reversal (inversão de ordem de bloqueio)?

O kernel do FreeBSD usa vários locks de recursos para arbitrar a contenção de certos recursos. Quando várias threads do kernel tentam obter vários locks de recursos, há sempre o potencial para um impasse (deadlock), em que duas threads obtiveram cada uma um dos locks e trava para sempre esperando que a outra thread libere um dos outros locks. Esse tipo de problema de locking pode ser evitado se todas as threads obtiverem os locks na mesma ordem.

Um sistema de diagnóstico lock em tempo de execução chamado man:witness[4], ativado no FreeBSD-CURRENT e desabilitado por padrão para a branch stable e releases, detecta o potencial para deadlocks devido a erros de locking, incluindo erros causados ​​pela obtenção de vários locks de recursos com uma ordem diferente de partes diferentes do kernel. O framework man:witness[4] tenta detectar esse problema quando ele ocorre e relata isso imprimindo uma mensagem no console do sistema sobre um `lock order reversal` (geralmente também chamado de LOR).

É possível obter falsos positivos, uma vez que o man:witness[4] é conservador. Um relatório positivo verdadeiro _não_ significa que um sistema está travado; em vez disso, deve ser entendido como um aviso de que um deadlock poderia ter acontecido.

[NOTE]
====
Os problemas de LOR tendem a ser consertados rapidamente, então verifique a lista de discussão do http://lists.FreeBSD.org/mailman/listinfo/freebsd-current[FreeBSD-CURRENT] antes de postar sobre um.
====

=== O que significa o erro Called ... with the following non-sleepable locks held?

Isso significa que uma função que pode dormir foi chamada enquanto um lock mutex (ou outro unsleepable) era mantido.

A razão pela qual isso é um erro é porque os mutexes não devem ser mantidos por longos períodos de tempo; eles deveriam existir apenas para manter curtos períodos de sincronização. Este contrato de programação permite que os drivers de dispositivos usem mutexes para sincronizar com o resto do kernel durante as interrupções. As interrupções (no FreeBSD) podem não dormir. Por isso, é imperativo que nenhum subsistema bloqueie o kernel por um longo período mantendo um mutex ativo.

Para capturar tais erros, asserções podem ser adicionadas ao kernel que interage com o subsistema man:witness[4] para emitir um aviso ou erro fatal (dependendo a configuração do sistema) quando uma chamada potencialmente de bloqueio é feita enquanto um mutex estiver sendo mantido.

Em resumo, tais avisos não são fatais, no entanto, com um timing infeliz, podem causar efeitos indesejáveis, desde um pequeno erro na capacidade de resposta do sistema até o seu travamento completo.

Para obter informações adicionais sobre locking no FreeBSD, consulte man:locking[9].

=== Por que o buildworld / installworld morre com a mensagem touch: not found?

Este erro não significa que o utilitário man:touch[1] esteja ausente. O erro é provavelmente devido às datas dos arquivos que estão sendo definidos em algum momento no futuro. Se o relógio do CMOS estiver configurado para a hora local, execute `adjkerntz -i` para ajustar o relógio do kernel ao inicializar no modo de usuário único.

== Aplicativos do Usuário

=== Onde estão todas as aplicações de usuário?

Consulte https://www.FreeBSD.org/ports/[a página dos ports] para informações sobre pacotes de software portados para o FreeBSD.

A maioria dos ports deve funcionar em todas as versões suportadas do FreeBSD. Aqueles que não funcionam, estão especificamente sinalizados como tal. Cada vez que uma release do FreeBSD é construída, um snapshot da coleção de ports no momento da construção também é incluída no diretório [.filename]#ports/#.

O FreeBSD suporta pacotes binários compactados para facilitar a instalação e desinstalação dos ports. Use o comando man:pkg[7] para controlar a instalação de pacotes.

=== Como faço para baixar a coleção de ports? Eu deveria estar usando o Subversion?

Qualquer um dos métodos listados aqui funciona:

* Use o portsnap para a maioria dos casos de uso. Consulte a seção link:{handbook}#ports-using[Usando a coleção de ports] para obter instruções sobre como usar essa ferramenta .
* Use o Subversion se for necessário a aplicação de patches customizados na árvore de ports ou se estiver rodando FreeBSD-CURRENT. Consulte a seção link:{handbook}#svn[Usando o Subversion] para obter detalhes.

=== Por que não posso compilar esse port na minha máquina 11.X - ou 12.X -STABLE?

Se a versão do FreeBSD instalada estiver significativamente atrás do _-CURRENT_ ou do _-STABLE_, atualize a coleção de ports usando as instruções disponíveis na seção link:{handbook}#ports-using[Usando a coleção de ports]. Se o sistema estiver atualizado, alguém pode ter feito uma alteração no port que funciona para _-CURRENT_ mas que quebrou o port para o _-STABLE_. https://bugs.FreeBSD.org/submit/[Envie] um relatório de bug, já que a Coleção de Ports deve funcionar tanto para o branch _-CURRENT_ e quanto o _-STABLE_.

=== Acabei de tentar compilar o INDEX usando o comando make index, e ele falhou. Por quê?

Primeiro, certifique-se de que a Coleção de Ports esteja atualizada. Erros que afetam a compilação do [.filename]#INDEX# a partir de uma cópia atualizada da coleção de ports são de alta visibilidade e, portanto, quase sempre são corrigidos imediatamente.

Existem casos raros em que o [.filename]#INDEX# não será compilado devido a casos estranhos envolvendo a variável `OPTIONS_SET` sendo definida em [.filename]#make.conf#. Se você suspeitar que este é o caso, tente fazer o [.filename]#INDEX# com estas variáveis desativadas antes de reportar o erro para a http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports[Lista de discussão de ports do FreeBSD].

=== Eu atualizei os fontes, agora como faço para atualizar meus ports instalados?

O FreeBSD não inclui uma ferramenta de atualização de ports, mas possui algumas ferramentas para facilitar o processo de atualização. Ferramentas adicionais estão disponíveis para simplificar o manuseio dos ports e são descritas na seção link:{handbook}#ports-using[Atualizando Ports] no Handbook do FreeBSD .

=== Preciso recompilar todos os ports sempre que realizo uma atualização de versão principal?

Sim! Apesar de um sistema recente ser capaz de executar os softwares compilados em uma versão mais antiga, as coisas irão falhar aleatoriamente e deixar de funcionar quando outros ports forem instalados ou atualizados.

Quando o sistema é atualizado, várias bibliotecas compartilhadas, módulos carregáveis ​​e outras partes do sistema serão substituídas por versões mais recentes. Os aplicativos vinculados às versões mais antigas podem não iniciar ou, em outros casos, não funcionar corretamente.

Para obter maiores informações, consulte a link:{handbook}#freebsdupdate-upgrade[seção sobre atualizações] no Handbook do FreeBSD.

=== Preciso recompilar cada port toda vez que faço uma atualização de versão secundária?

Em geral, não. Os desenvolvedores do FreeBSD fazem o máximo para garantir compatibilidade binária em todos os releases com o mesmo número de versão principal. Quaisquer exceções serão documentadas nas Release Notes, e os conselhos dados lá devem ser seguidos.

=== Por que o /bin/sh é tão pequeno? Por que o FreeBSD não usa o bash ou outro shell?

Muitas pessoas precisam escrever shell scripts que serão portados para muitos sistemas. É por isso que o POSIX(TM) especifica os comandos shell e utilitários em grande detalhe. A maioria dos scripts são escritos em Bourne shell (man:sh[1]) e porque várias interfaces de programação importantes (man:make[1], man:system[3], man:popen[3] e análogos em linguagens de script de alto nível como Perl e Tcl) são especificados para usar o Bourne shell para interpretar comandos. Como o Bourne shell é usado com tanta frequência e em larga escala, é importante que ele seja iniciado rapidamente, que seja determinístico em seu comportamento e que ocupe o menor espaço possível na memória.

A implementação existente é resultado do nosso melhor esforço para atender simultaneamente o quanto pudermos desses requisitos. Para manter o `/bin/sh` pequeno, não fornecemos muitos dos recursos de conveniência que os outros shells possuem. É por isso que outras shells com mais recursos, como o `bash`, o `scsh`, o man:tcsh[1], e o `zsh` estão disponíveis. Compare a utilização de memória desses shells observando as colunas " VSZ " e " RSS " em uma listagem gerada com o comando `ps -u`.

== Configuração do Kernel

[[make-kernel]]
=== Eu gostaria de customizar meu kernel. É difícil?

De modo nenhum! Confira a seção link:{handbook}#kernelconfig[configuração do kernel do Handbook].

[NOTE]
====
O novo [.filename]#kernel# será instalado no diretório [.filename]#/boot/kernel# junto com os seus módulos, enquanto o kernel antigo e seus módulos serão movidos para o diretório [.filename]#/boot/kernel.old#. Se um erro for cometido na configuração, basta inicializar utilizando a versão anterior do kernel.
====

=== Por que meu kernel é tão grande?

Os kernels `GENERIC` enviados com o FreeBSD são compilados com o _modo de depuração_ habilitado. Kernels compilados no modo de depuração contêm dados de depuração em arquivos separados que são usados ​​para depuração. Versões do FreeBSD anteriores a 11.0 armazenam esses arquivos de depuração no mesmo diretório que o próprio kernel, [.filename]#/boot/kernel/#. No FreeBSD 11.0 e posterior, os arquivos de depuração são armazenados em [.filename]#/usr/lib/debug/boot/kernel/#. Observe que haverá pouca ou nenhuma perda de desempenho ao executar um kernel com o modo de depuração habilitado, e é útil manter um por perto em caso de panic no sistema.

Quando estiver com pouco espaço em disco, existem diferentes opções para reduzir o tamanho de [.filename]#/boot/kernel/# e [.filename]#/usr/lib/debug/#.

Para não instalar os arquivos de símbolos, certifique-se que a seguinte linha existe em [.filename]#/etc/src.conf#:

[.programlisting]
....
WITHOUT_KERNEL_SYMBOLS=yes
....

Para mais informações veja man:src.conf[5].

Se você quiser evitar completamente a criação de arquivos de depuração, certifique-se de que ambos os itens a seguir sejam verdadeiros:

* Esta linha não existe no arquivo de configuração do kernel:
+
[.programlisting]
....
makeoptions DEBUG=-g
....

* Não execute o comando man:config[8] com a opção `-g`.

Qualquer uma das configurações acima fará com que o kernel seja construído com suporte ao modo de depuração.

Para construir e instalar somente os módulos desejados, liste-os em [.filename]#/etc/make.conf#:

[.programlisting]
....
MODULES_OVERRIDE= accf_http ipfw
....

Substitua _accf_httpd ipfw_ com a lista dos módulos que precisa. Apenas os módulos listados serão compilados. Isso reduz o tamanho do diretório do kernel e diminui o tempo necessário para compilar o kernel. Para mais informações, leia [.filename]#/usr/shared/examples/etc/make.conf#.

Dispositivos desnecessários podem ser removidos do kernel para reduzir ainda mais o tamanho. Veja <<make-kernel>> para mais informações.

Para colocar qualquer uma dessas opções em vigor, siga as instruções para link:{handbook}#kernelconfig-building[compilar e instalar] um novo kernel.

Para referência, o kernel amd64 do FreeBSD 11 ([.filename]#/boot/kernel/kernel#) é de aproximadamente 25 MB.

=== Por que todo kernel que eu tento construir falha ao compilar, até mesmo o GENERIC?

Há várias causas possíveis para esse problema:

* A o código fonte de origem é diferente do usado para construir o sistema atualmente em execução. Ao tentar uma atualização, leia o arquivo [.filename]#/usr/src/UPDATING#, prestando atenção especial à seção "ITENS COMUNS" no final.
* O comando `make buildkernel` não foi concluído com sucesso. O comando `make buildkernel` depende dos arquivos gerados pelo comando `make buildworld` para concluir seu trabalho corretamente.
* Mesmo quando estiver compilando o <<stable,FreeBSD-STABLE>>, é possível que o código fonte tenha sido obtido em um momento em que estava sendo modificado ou em que estava quebrado. Somente os releases possuem a garantia de que podem ser compilados, apesar do <<stable,FreeBSD-STABLE>> compilar corretamente na maioria das vezes. Tente atualizar novamente o código fonte e veja se o problema desaparece. Tente usar um servidor de distribuição diferente, caso o anterior esteja com problemas.

=== Qual agendador está em uso em um sistema em execução?

O nome do agendador que atualmente sendo usado está diretamente disponível como o valor da variavel `kern.sched.name` do sysctl:

[source,bash]
....
% sysctl kern.sched.name
kern.sched.name: ULE
....

=== O que é o kern.sched.quantum?

A variável `kern.sched.quantum` define o número máximo de pulsos que um processo pode executar sem ser "preempted" no scheduler 4BSD.

== Discos, sistemas de arquivos e boot loaders

=== Como posso adicionar o meu novo disco rígido ao meu sistema FreeBSD?

Veja a seção link:{handbook}#disks-adding[Adicionando Discos] no Handbook do FreeBSD.

=== Como faço para mover meu sistema para o meu novo disco enorme?

A melhor maneira é reinstalar o sistema operacional no novo disco e depois passar os dados do usuário. Isto é altamente recomendado ao seguir o _-STABLE_ por mais de uma release ou ao atualizar uma release ao invés de instalar uma nova. Instale o booteasy em ambos os discos com man:boot0cfg[8] e use a opção de dual boot até que esteja satisfeito com a nova configuração. Pule o próximo parágrafo para descobrir como mover os dados depois de fazer isso.

Alternativamente, particione e rotule o novo disco utilizando o man:sade[8] ou o man:gpart[8]. Se os discos forem formatados com MBR, o booteasy pode ser instalado em ambos os discos utilizando-se o man:boot0cfg[8] para que o computador possa inicializar dualmente com o antigo ou novo sistema após a conclusão da cópia.

Depois que o novo disco estiver configurado, os dados não podem ser simplesmente copiados. Em vez disso, use ferramentas que entendam device files e system flags, tais como o man:dump[8]. Embora seja recomendado que você mova os dados com o sistema em modo single user, isto não é necessário.

Quando os discos estiverem formatados com UFS, nunca use nada além do man:dump[8] e do man:restore[8] para mover o sistema de arquivos raiz. Esses comandos também devem ser usados para mover uma única partição para uma outra partição vazia. A seqüência de etapas para usar o comando `dump` para mover os dados de uma partição UFS para uma nova partição é:

[.procedure]
====
. Execute o `newfs` na nova partição.
. Utilize o `mount` para disponibilizá-la em um ponto de montagem temporário.
. Vá para o diretório desejado utilizando o comando `cd`.
. Faça o `dump` da partição antiga e redirecione a saída para a nova.
====

Por exemplo, para mover [.filename]#/dev/ada1s1a# tendo [.filename]#/mnt# como o ponto de montagem temporário, digite:

[source,bash]
....
# newfs /dev/ada1s1a
# mount /dev/ada1s1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
....

Reorganizar as partições com o comando `dump` requer um pouco mais de trabalho. Para mesclar uma partição como [.filename]#/var# com a partição pai, crie uma nova partição grande o suficiente para conter ambas, mova a partição pai conforme descrito acima e mova a partição filha para o diretório vazio criado pela primeira movimentação:

[source,bash]
....
# newfs /dev/ada1s1a
# mount /dev/ada1s1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
# cd var
# dump 0af - /var | restore rf -
....

Para separar um diretório do seu pai, digamos colocar [.filename]#/var# em sua própria partição quando não era antes, crie as duas partições, monte a partição filho no diretório apropriado no ponto de montagem temporário e mova a antiga partição única:

[source,bash]
....
# newfs /dev/ada1s1a
# newfs /dev/ada1s1d
# mount /dev/ada1s1a /mnt
# mkdir /mnt/var
# mount /dev/ada1s1d /mnt/var
# cd /mnt
# dump 0af - / | restore rf -
....

Os utilitários man:cpio[1] e man:pax[1] também estão disponíveis para mover dados do usuário. Estes comandos são conhecidos por perder as flags com as informações dos arquivo, portanto, use-os com cuidado.

=== Quais partições podem usar com segurança o Soft Updates? Ouvi dizer que o uso de Soft Updates no / pode causar problemas. E quanto ao Journaled Soft Updates?

Resposta curta: Soft Updates geralmente podem ser usados ​​com segurança em todas as partições.

Resposta longa: o Soft Updates possui duas características que podem ser indesejáveis ​​em determinadas partições. Primeiro, uma partição com Soft Updates tem uma pequena chance de perder dados durante uma falha do sistema. A partição não será corrompida, pois os dados serão simplesmente perdidos. Em segundo lugar, o uso de Soft Updates pode causar escassez temporária de espaço.

Ao usar o Soft Updates, o kernel pode levar até trinta segundos para gravar alterações no disco físico. Quando um arquivo grande é excluído, o arquivo ainda reside no disco até que o kernel execute a exclusão. Isso pode causar uma "race condition" muito simples. Suponha que um arquivo grande seja excluído e outro arquivo grande seja criado imediatamente. O primeiro arquivo grande ainda não foi removido do disco físico, portanto, o disco pode não ter espaço suficiente para o segundo arquivo grande. Isso produzirá um erro de que a partição não tem espaço suficiente, mesmo que um grande espaço tenha acabado de ser liberado. Alguns segundos depois, a criação do arquivo funciona conforme o esperado.

Se um sistema travar depois que o kernel tiver aceito um bloco de dados para gravar no disco, mas antes que os dados sejam realmente gravados, os dados poderão ser perdidos. Esse risco é extremamente pequeno, e geralmente gerenciável.

Esses problemas afetam todas as partições usando as Soft Updates. Então, o que isso significa para a partição raiz?

Informações vitais sobre a partição raiz mudam muito raramente. Se o sistema travar dentro da janela de 30 segundos depois de uma alteração ter sido feita, é possível que os dados possam ser perdidos. Esse risco é insignificante para a maioria dos aplicativos, mas esteja ciente de que existe. Se o seu sistema não puder tolerar este risco, não use as Soft Updates no sistema de arquivos raiz!

O [.filename]#/# é tradicionalmente uma das menores partições. Se o [.filename]#/tmp# estiver localizado dentro do [.filename]#/#, pode haver problemas intermitentes de falta de espaço. A criação de um link simbólico apontando o [.filename]#/tmp# para [.filename]#/var/tmp# resolverá esse problema.

Por fim, o man:dump[8] não funciona no modo live (-L) em um sistema de arquivos, com Journaled Soft Updates (SU + J).

=== Posso acessar outros sistemas de arquivos não-nativos do FreeBSD?

O FreeBSD suporta uma variedade de outros sistemas de arquivos.

UFS::
Os CD-ROMs UFS podem ser montados diretamente no FreeBSD. Montar partições de disco do Digital UNIX e de outros sistemas que suportam o UFS pode ser mais complexo, dependendo dos detalhes do particionamento do disco para o sistema operacional em questão.

ext2/ext3::
O FreeBSD suporta partições `ext2fs` e `ext3fs`. Veja man:ext2fs[5] para mais informações.

NTFS::
O suporte ao NTFS baseia-se no FUSE está disponível como um port (package:sysutils/fusefs-ntfs[]). Para mais informações, consulte http://www.tuxera.com/community/ntfs-3g-manual/[ntfs-3g].

FAT::
O FreeBSD inclui um driver FAT de leitura-gravação. Para obter mais informações, consulte man:mount_msdosfs[8].

ZFS::
O FreeBSD inclui um port do driver ZFS da Sun(TM). A recomendação atual é usá-lo apenas em plataformas amd64 com memória suficiente. Para obter mais informações, consulte man:zfs[8].

O FreeBSD inclui o sistema de arquivos de rede NFS e a Coleção de Ports do FreeBSD fornece vários aplicativos FUSE para suportar muitos outros sistemas de arquivos.

=== Como faço para montar uma partição secundária do DOS?

As partições secundárias do DOS são encontradas depois de _todas_ as partições primárias. Por exemplo, se `E` for a segunda partição DOS na segunda unidade SCSI, haverá um arquivo de dispositivo para a "slice 5" em [.filename]#/dev#. Para montá-lo:

[source,bash]
....
# mount -t msdosfs /dev/da1s5 /dos/e
....

=== Existe um sistema de arquivos criptográficos para o FreeBSD?

Sim, o man:gbde[8] e o man:geli[8]. Consulte a seção link:{handbook}#disks-encrypting[Partições de Disco com Criptografia] do Handbook do FreeBSD.

=== Como inicializo o FreeBSD e o Linux utilizando o GRUB?

Para inicializar o FreeBSD usando o GRUB, adicione o seguinte ao [.filename]#/boot/grub/menu.lst# ou ao [.filename]#/boot/grub/grub.conf#, dependendo de qual é usado pela sua distribuição  Linux (TM).

[.programlisting]
....
title FreeBSD 9.1
	root (hd0,a)
	kernel /boot/loader
....

No qual _hd0,a_ aponta para a partição raiz no primeiro disco. Para especificar o número da slice, use algo como isto _(hd0,2,a)_. Por padrão, se o número da slice for omitido, o GRUB pesquisará a primeira slice que tiver a partição `a`.

=== Como inicializo o FreeBSD e o Linux usando o BootEasy?

Instale o LILO no início da partição de inicialização Linux(TM) em vez de no Master Boot Record. Em seguida, inicialize o LILO a partir do BootEasy.

Isto é recomendado ao executar o Windows(TM) e o Linux(TM), pois torna mais fácil fazer o Linux(TM) inicializar novamente se o Windows(TM) for reinstalado.

=== Como faço para alterar o prompt de inicialização de ??? para algo mais significativo?

Isso não pode ser feito com o gerenciador de inicialização padrão sem reescrevê-lo. Há vários outros gerenciadores de inicialização na categoria [.filename]#sysutils# da coleção de ports.

=== Como faço para usar uma nova unidade removível?

Se a unidade já tiver um sistema de arquivos, use um comando como este:

[source,bash]
....
# mount -t msdosfs /dev/da0s1 /mnt
....

Se a unidade só for usada com sistemas FreeBSD, particione-a com UFS ou ZFS. Isso fornecerá suporte a nomes longos de arquivo, melhoria no desempenho e na estabilidade. Se a unidade for usada por outros sistemas operacionais, uma escolha mais portátil, como por exemplo o msdosfs, será mais apropriada.

[source,bash]
....
# dd if=/dev/zero of=/dev/da0 count=2
# gpart create -s GPT /dev/da0
# gpart add -t freebsd-ufs /dev/da0
....

Finalmente, crie um novo sistema de arquivos:

[source,bash]
....
# newfs /dev/da0p1
....

e monte-o:

[source,bash]
....
# mount /dev/da0s1 /mnt
....

É uma boa ideia adicionar uma linha ao [.filename]#/etc/fstab# (veja man:fstab[5]) para que você possa digitar apenas `mount /mnt` no futuro:

[.programlisting]
....
/dev/da0p1 /mnt ufs rw,noauto 0 0
....

=== Por que recebo o erro Incorrect super block ao montar um CD?

O tipo de dispositivo a ser montado deve ser especificado. Isso está descrito no Handbook na seção link:{handbook}#mounting-cd[ Usando CDs de Dados].

=== Por que recebo o erro Device not configured ao montar um CD?

Isso geralmente significa que não há CD na unidade ou a unidade não está visível no barramento. Consulte a seção link:{handbook}#mounting-cd[ Usando CDs de Dados] do Handbook para uma discussão detalhada desta questão.

=== Por que todos os caracteres não-ingleses em nomes de arquivos aparecem como ? em meus CDs quando montados no FreeBSD?

O CD provavelmente usa a extensão "Joliet" para armazenar informações sobre arquivos e diretórios. Isso é discutido na seção link:{handbook}#mounting-cd[Usando CD-ROMs de Dados] do Handbook.

=== Um CD gravado no FreeBSD não pode ser lido sob nenhum outro sistema operacional. Por quê?

Isso significa que um raw file foi gravado no CD, em vez de criar um sistema de arquivos ISO 9660. Dê uma olhada na seção link:{handbook}#mounting-cd[Usando CDs de Dados].

=== Como posso criar uma imagem de um CD de dados?

Isso é discutido na seção Handbook sobre link:{handbook}#mkisofs[como gravar dados em um sistema de arquivos ISO ]. Para mais informações sobre como trabalhar com CD-ROMs, consulte a link:{handbook}#creating-cds[ Seção Criando CDs ] no capítulo sobre Armazenamento do Handbook.

=== Por que não consigo usar o comando mount com um CD de áudio?

Tentar montar um CD de áudio produzirá um erro do tipo `cd9660: /dev/cd0: Invalid argument`. Isso ocorre porque o comando `mount` só funciona em sistemas de arquivos. CDs de áudio não possuem sistemas de arquivos; eles têm apenas dados. Em vez disso, use um programa que leia CDs de áudio, como o pacote ou port package:audio/xmcd[].

=== Como eu faço para usar o comando mount com um CD multi-sessão?

Por padrão, o man:mount[8] tentará montar a última trilha de dados (sessão) de um CD. Para carregar uma sessão anterior, use o argumento de linha de comando `-s`. Consulte man:mount_cd9660[8] para exemplos específicos.

=== Como posso permitir que usuários não privilegiados montem CD-ROMs, DVDs, unidades USB e outras mídias removíveis?

Como `root`, defina a variável `vfs.usermount` do sysctl como `1`.

[source,bash]
....
# sysctl vfs.usermount=1
....

Para tornar o ajuste permanente, adicione a linha `vfs.usermount=1` ao arquivo [.filename]#/etc/sysctl.conf# para que a variável seja redefinids no momento da inicialização do sistema.

Os usuários só podem montar dispositivos para os quais tenham permissões de leitura. Para permitir que os usuários montem um dispositivo, as permissões devem ser definidas em [.filename]#/etc/devfs.conf#.

Por exemplo, para permitir que os usuários montem a primeira unidade USB, adicione:

[.programlisting]
....
# Allow all users to mount a USB drive.
	    own       /dev/da0       root:operator
	    perm      /dev/da0       0666
....

Todos os usuários agora podem montar dispositivos que eles podem ler em um diretório que eles possuem:

[source,bash]
....
% mkdir ~/my-mount-point
% mount -t msdosfs /dev/da0 ~/my-mount-point
....

Desmontar o dispositivo é simples:

[source,bash]
....
% umount ~/my-mount-point
....

Ativar a variável `vfs.usermount`, no entanto, tem implicações negativas de segurança. Uma maneira melhor de acessar uma mídia formatada para o MS-DOS(TM) é usar o pacote package:emulators/mtools[] da Coleção de Ports.

[NOTE]
====
O nome do dispositivo usado nos exemplos anteriores deve ser alterado de acordo com a configuração.
====

=== Os comandos du e df mostram informações diferentes sobre a quantia disponível de espaço em disco. O que está acontecendo?

Isso se deve ao modo como esses comandos realmente funcionam. O `du` passa pela árvore de diretórios, ele mede o tamanho de cada arquivo e apresenta os totais. O `df` apenas pergunta ao sistema de arquivos quanto espaço ainda resta. Eles parecem ser a mesma coisa, mas um arquivo sem uma entrada de diretório afetará `df` mas não `du`.

Quando um programa está usando um arquivo e o arquivo é excluído, o arquivo não é realmente removido do sistema de arquivos até que o programa pare de usá-lo. O arquivo é imediatamente excluído da listagem do diretório, no entanto. Como exemplo, considere um arquivo grande o suficiente para afetar a saída de `du` e `df`. Um arquivo sendo visualizado com `more` pode ser excluído sem causar um erro. A entrada é removida do diretório para que nenhum outro programa ou usuário possa acessá-la. No entanto, o `du` mostra que ele desapareceu, já que percorreu a árvore de diretórios e o arquivo não está mais listado. Já o `df` mostra que ele ainda está lá, pois o sistema de arquivos sabe que o comando `more` ainda está usando esse espaço. Quando a sessão do `more` terminar, o `du` e `df` apresentarão o mesmo resultado.

Essa situação é comum em servidores web. Muitas pessoas configuram um servidor web no FreeBSD e esquecem de rotacionar os arquivos de log. O log de acesso enche o [.filename]#/var#. O administrador novato exclui o arquivo, mas o sistema ainda reclama que a partição está cheia. Parar e reiniciar o programa do servidor Web liberaria o arquivo, permitindo que o sistema liberasse o espaço em disco. Para evitar que isso aconteça, configure o man:newsyslog[8].

Observe que o Soft Updates pode atrasar a liberação de espaço em disco e pode levar até 30 segundos para que a alteração fique visível.

=== Como posso adicionar mais espaço de swap?

Esta seção link:{handbook}#adding-swap-space[do Handbook] descreve como fazer isso.

=== Por que o FreeBSD vê meu disco como sendo menor do que o fabricante diz que ele é?

Os fabricantes de discos calculam gigabytes como um bilhão de bytes cada, enquanto o FreeBSD os calcula como 1.073.741.824 bytes cada. Isso explica por que, por exemplo, as mensagens de boot do FreeBSD reportarão um disco que supostamente tem 80 GB como contendo 76.319 MB.

Observe também que o FreeBSD irá (por padrão) <<disk-more-than-full,reservar>> cerca de 8% do espaço em disco.

=== Como é possível que uma partição esteja com mais de 100% de ocupação?

Uma parte de cada partição UFS (8%, por padrão) é reservada para uso pelo sistema operacional e pelo usuário `root`. O man:df[1] não contabiliza esse espaço ao calcular a coluna `Capacity`, portanto, ela pode exceder 100%. Observe que a coluna `Blocks` é sempre maior que a soma das colunas `Used` e `Avail`, geralmente por um fator de 8%.

Para mais detalhes, procure prls opção `-m` em man:tunefs[8].

== ZFS

=== Qual é a quantidade mínima de RAM que um usuário deve ter para utilizar o ZFS?

É necessário um mínimo de 4 GB de RAM para uso confortável, mas as cargas de trabalho individuais podem variar muito.

=== O que é o ZIL e quando ele é usado?

O ZIL (log de intenção do  ZFS ) é um log de gravação usado para implementar semânticas de compromisso de escrita posix entre travamentos. Normalmente, as gravações são agrupadas em grupos de transações e gravadas no disco quando preenchidas ("Transaction Group Commit "). No entanto, syscalls como man:fsync[2] requerem um compromisso de que os dados são gravados no armazenamento estável antes de retornar. O ZIL é necessário para gravações que foram reconhecidas como gravadas, mas que ainda não estão no disco como parte de uma transação. Os grupos de transações contam com registro de data e hora. No caso de uma falha, o último registro de data e hora válido é encontrado e os dados ausentes são mesclados a partir do ZIL.

=== Preciso de um SSD para o ZIL?

Por padrão, o ZFS armazena o ZIL no pool com todos os demais dados. Se um aplicativo tiver uma carga de gravação pesada, o armazenamento do ZIL em um dispositivo separado e que tenha um desempenho de gravação sequencial síncrono muito rápido pode melhorar a performance do sistema de uma forma geral. Para outras cargas de trabalho, é improvável que um SSD consiga uma melhoria significativa.

=== O que é o L2ARC?

O L2ARC é um cache de leitura armazenado em um dispositivo rápido, como um SSD. Esse cache não é persistente nas reinicializações. Observe que a RAM é usada como a primeira camada de cache e o L2ARC só é necessário se a quantidade de memória RAM for insuficiente.

O L2ARC precisa de espaço no ARC para indexá-lo. Então, perversamente, um conjunto de trabalho que se encaixa perfeitamente no ARC não se encaixará mais perfeitamente se um L2ARC for usado porque parte do ARC estará mantendo o índice L2ARC, empurrando parte do conjunto de trabalho para o L2ARC que é mais lento que a RAM.

=== A ativação da funcionalidade de desduplicação é recomendável?

De um modo geral, não.

A deduplicação ocupa uma quantidade significativa de RAM e pode tornar mais lento os tempos de acesso ao disco para leitura e gravação. A menos que um esteja armazenando dados muito duplicados, como imagens de máquinas virtuais ou backups de usuários, é possível que a deduplicação faça mais mal do que bem. Outra consideração é a incapacidade de reverter o status da deduplicação. Se os dados forem gravados quando a deduplicação estiver ativada, desabilitar a deduplicação não fará com que os blocos deduplicados sejam replicados até que sejam modificados em novamente.

A deduplicação também pode levar há algumas situações inesperadas. Em particular, a exclusão de arquivos pode se tornar muito mais lenta.

=== Não consigo excluir ou criar arquivos no meu pool do ZFS. Como posso consertar isso?

Isso pode acontecer porque o pool está 100% cheio. O ZFS requer espaço no disco para gravar metadados de transação. Para restaurar o pool para um estado utilizável, primeiro faça o truncate do arquivo que irá excluir:

[source,bash]
....
% truncate -s 0 unimportant-file
....

O truncamento de arquivo funciona porque uma nova transação não é iniciada, novos blocos de reserva são criados.

[NOTE]
====
Em sistemas que utilizam o ZFS com um dataset customizado, por exemplo com a funcionalidade de deduplicação ativada, o espaço pode não ficar disponível imediatamente
====

=== O ZFS suporta TRIM para unidades de estado sólido?

O suporte ao ZFS TRIM foi adicionado ao FreeBSD 10-CURRENT com revisão rlink:https://svnweb.freebsd.org/changeset/base/240868[r240868]. O suporte ao ZFS TRIM foi adicionado a todas as branchs do FreeBSD-STABLE na revisão rlink:https://svnweb.freebsd.org/changeset/base/252162[r252162] e rlink:https://svnweb.freebsd.org/changeset/base/251419[r251419], respectivamente.

O ZFS TRIM é ativado por padrão e pode ser desativado adicionando-se esta linha ao arquivo [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
vfs.zfs.trim.enabled=0
....

[NOTE]
====
O suporte ao ZFS TRIM foi adicionado ao GELI em rlink:https://svnweb.freebsd.org/changeset/base/286444[r286444]. Por favor, veja man:geli[8] e a opção `-T`.
====

== Administração do Sistema

=== Onde estão os arquivos de configuração de inicialização do sistema?

O arquivo de configuração principal é o [.filename]#/etc/defaults/rc.conf#, o qual está descrito em man:rc.conf[5]. Os scripts de inicialização do sistema, tais como [.filename]#/etc/rc# e [.filename]#/etc/rc.d#, que são descritos em man:rc[8], incluem este arquivo. _Não edite este arquivo!_ Em vez disso, para editar uma entrada do [.filename]#/etc/default/rc.conf#, copie a linha para o arquivo [.filename]#/etc/rc.conf# e altere-a lá.

Por exemplo, se para iniciar man:named[8], o servidor DNS incluído:

[source,bash]
....
# echo 'named_enable="YES"' >> /etc/rc.conf
....

Para iniciar serviços locais, coloque seus shell scripts no diretório [.filename]#/usr/local/etc/rc.d#. Estes shell scripts devem estar definidos como executáveis, o modo de arquivo padrão é `555`.

=== Como eu adiciono um usuário facilmente?

Use o comando man:adduser[8], para as situações mais complexas utilize o comando man:pw[8].

Para remover o usuário, use o comando man:rmuser[8] ou, se necessário, o comando man:pw[8].

=== Por que eu continuo recebendo mensagens como root: not found depois de editar o arquivo /etc/crontab?

Isto normalmente é causado pela edição do crontab do sistema. Esta não é a maneira correta de fazer as coisas, pois o crontab do sistema tem um formato diferente dos crontabs por usuário. O crontab do sistema possui um campo extra, especificando qual usuário irá executar o comando. O man:cron[8] assume que este usuário é a primeira palavra do comando a ser executado. Como esse comando não existe, essa mensagem de erro é exibida.

Para excluir o crontab extra incorreto:

[source,bash]
....
# crontab -r
....

=== Por que eu recebo o erro, you are not in the correct group to su root quando tento executar o comando su para o usuário root ?

Este é um recurso de segurança. Para executar `su` para `root`, ou qualquer outra conta com privilégios de superusuário, a conta do usuário deve ser um membro do grupo `wheel`. Se este recurso não estivesse lá, qualquer pessoa com uma conta em um sistema e que também descobrisse a senha do `root` seria capaz de obter acesso de nível de superusuário ao sistema.

Para permitir que alguém execute o comando `su  root`, coloque-os no grupo `wheel` usando o comando `pw`:

[source,bash]
....
# pw groupmod wheel -m lisa
....

O exemplo acima adicionará o usuário `lisa` ao grupo `wheel`.

=== Cometi um erro no rc.conf, ou outro arquivo de inicialização, e agora não posso editá-lo porque o sistema de arquivos está montado somente leitura. O que devo fazer?

Reinicie o sistema usando `boot -s` no prompt do loader para entrar no modo single user. Quando o sistema solicitar o caminho do shell, apenas pressione kbd:[Enter] e execute `mount -urw /` para remontar novamente o sistema de arquivos raiz no modo de leitura e gravação. Você também pode precisar executar o comando `mount -a -t ufs` para montar o sistema de arquivos no qual seu editor favorito é mantido. Se esse editor estiver em um sistema de arquivos de rede, configure a rede manualmente antes de montar os sistemas de arquivos de rede ou use um editor que resida em um sistema de arquivos local, tal como o man:ed[1].

Para usar um editor de tela inteira, tal como o man:vi[1] ou man:emacs[1], execute `export TERM=xterm` para que esses editores possam carregar os dados corretos do banco de dados do man:termcap[5].

Depois de executar estas etapas, edite o arquivo [.filename]#/etc/rc.conf# para corrigir o erro de sintaxe. A mensagem de erro exibida imediatamente após as mensagens de inicialização do kernel deve indicar o número da linha no arquivo que está com erro.

=== Por que estou tendo problemas para configurar minha impressora?

Consulte a seção sobre link:{handbook}#printing[impressão] no Handbook do FreeBSD para dicas de soluções de problemas.

=== Como posso corrigir os mapeamentos de teclado para o meu sistema?

Consulte a seção link:{handbook}#using-localization[usando localização] do Handbook, mais especificamente a seção sobre a link:{handbook}#setting-console[ configuração do console ].

=== Por que não consigo colocar as quotas de usuários para funcionar corretamente?

. É possível que o kernel não esteja configurado para usar quotas. Neste caso, adicione a seguinte linha ao arquivo de configuração do kernel e recompile o kernel:
+
[.programlisting]
....
options QUOTA
....

+ 
Consulte a link:{handbook}#quotas[ seção do Handbook sobre quotas] para obter detalhes completos.
. Não ative o uso de quotas na partição [.filename]#/#.
. Coloque o arquivo de quotas no sistema de arquivos para o qual quotas precisam ser aplicadas:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Sistema de arquivo
| Arquivo de quota

|[.filename]#/usr#
|[.filename]#/usr/admin/quotas#

|[.filename]#/home#
|[.filename]#/home/admin/quotas#

|...
|...
|===

=== O FreeBSD suporta System V IPC primitives?

Sim, o FreeBSD suporta o IPC no estilo do System V, incluindo memória compartilhada, mensagens e semáforos, no kernel [.filename]#GENERIC#. Em um kernel personalizado, o suporte pode ser por meio do carregamento dos módulos de kernel [.filename]#sysvshm.ko#, [.filename]#sysvsem.ko# e [.filename]#sysvmsg.ko#, ou habilitado de forma estática no kernel personalizado adicionando as seguintes linhas ao arquivo de configuração do mesmo:

[.programlisting]
....
options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging
....

Recompile e instale o kernel.

=== Qual outro software de servidor de correio posso usar em substituição ao Sendmail?

O servidor http://www.sendmail.org/[Sendmail ] é o software de servidor de email padrão do FreeBSD, mas pode ser substituído por outro MTA instalado a partir da coleção de ports. Os ports disponíveis incluem o package:mail/exim[], o package:mail/postfix[] e o package:mail/qmail[]. Procure informações nas listas de discussão sobre as vantagens e desvantagens dos MTAs disponíveis.

=== Esqueci a senha do root! O que eu faço?

Não entre em pânico! Reinicie o sistema, digite `boot -s` no prompt `Boot:` para entrar no modo single user. Na pergunta sobre o shell a ser usado, pressione kbd:[Enter], que será exibido um prompt `#`. Insira o comando `mount -urw /` para remontar o sistema de arquivos raiz no modo de leitura e gravação e, em seguida, execute o comando `mount -a` para remontar todos os sistemas de arquivos. Execute o comando `passwd root` para alterar a senha do usuário `root` e então execute o comando man:exit[1] para continuar a inicialização.

[NOTE]
====
Se você ainda for solicitado a entrar com a senha do usuário `root` ao entrar no modo single user único, isso significa que o console foi configurado como `inseguro` no arquivo [.filename]#/etc/ttys#. Neste caso, será necessário inicializar a partir de um disco de instalação do FreeBSD, escolher o [.guimenuitem]#Live CD# ou [.guimenuitem]#Shell# no início do processo de instalação e executar os comandos mencionados acima. Monte a partição específica neste caso e, em seguida, execute o chroot para ela. Por exemplo, substitua `mount -urw /` por `mount /dev/ada0p1 /mnt; chroot /mnt` para um sistema em instalado em _ada0p1_.
====

[NOTE]
====
Se a partição raiz não puder ser montada a partir do modo de usuário único, é possível que as partições estejam criptografadas e será impossível montá-las sem as chaves de acesso. Para obter mais informações, consulte a seção sobre discos criptografados no link:{handbook}#disks-encrypting[Handbook] do FreeBSD.
====

=== Como evito que a combinação de teclas ControlAltDelete reinicialize o sistema?

Ao usar man:vt[4], o driver de console padrão, isso pode ser feito configurando o seguinte sysctl man:sysctl[8]:

[source,bash]
....
# sysctl kern.vt.kbd_reboot=0
....

=== Como faço para converter arquivos de texto do DOS para UNIX?

Use este comando man:perl[1]:

[source,bash]
....
% perl -i.bak -npe 's/\r\n/\n/g' file(s)
....

no qual _files(s)_ trata-se de um ou mais arquivos que desejamos processar. A modificação é feita in-place, o arquivo original é preservado com uma extensão [.filename]#.bak#.

Alternativamente, use o man:tr[1]:

[source,bash]
....
% tr -d '\r' < dos-text-file > unix-file
....

O _dos-text-file_ é o arquivo que contém o texto no formato DOS, enquanto o _unix-file_ contém a saída convertida. Esta opção pode ser um pouco mais rápida do que usar o `perl`.

Uma outra maneira de reformatar arquivos de texto do DOS é usar o port package:converters/dosunix[] da Coleção de Ports. Consulte a sua documentação para maiores detalhes.

=== Como faço para reler o arquivo /etc/rc.conf e reiniciar o /etc/rc sem dar boot?

Entre no modo single user e retorne ao modo multi usuário:

[source,bash]
....
# shutdown now
# return
# exit
....

=== Tentei atualizar o meu sistema para a versão -STABLE mais recente, mas obtive a -BETAx, -RC ou -PRERELEASE! O que está acontecendo?

Resposta curta: é apenas um nome. _RC_ significa "Release Candidate". Isso significa que uma nova release é iminente. No FreeBSD, _-PRERELEASE_ é tipicamente sinônimo do congelamento de código antes de uma release. (Para algumas versões, o rótulo _-BETA_ foi usado da mesma forma que o _-PRERELEASE_.)

Resposta longa: o FreeBSD deriva suas releases de um de dois lugares. Releases principais (major) ponto-zero, como a 9.0-RELEASE são derivadas a partir do branch principal de desenvolvimento, comumente referida como <<current,-CURRENT>>. Releases secundárias (minor), como a 6.3-RELEASE ou a 5.2-RELEASE, foram snapshots da branch <<stable,-STABLE>> ativa. A partir do 4.3-RELEASE, cada release também tem sua própria branch, a qual pode ser seguida por pessoas que exigem uma taxa extremamente conservadora de desenvolvimento (geralmente apenas avisos de segurança).

Quando um release está prestes a ser feito, o branch do qual ele será derivado tem que passar por um determinado processo. Parte desse processo é um congelamento de código. Quando um congelamento de código é iniciado, o nome da branch é alterado para refletir que está prestes a se tornar uma release. Por exemplo, se a ramificação costumava ser chamada de 6.2-STABLE, seu nome será alterado para 6.3-PRERELEASE para indicar o congelamento de código e indicar que testes extras de pré-release devem estar acontecendo. Correções de bugs ainda podem ser adicionadas ao repositório de código fonte para fazer parte da release. Quando o código-fonte estiver estabilizado para a release, o nome será alterado para 6.3-RC para indicar que uma release está prestes a ser feita a partir dele. Uma vez no estágio RC, somente os bugs mais críticos que forem encontrados podem ser corrigidos. Uma vez que o release (6.3-RELEASE neste exemplo) e o branch de release foram feitos, o branch será renomeado para 6.3-STABLE.

Para mais informações sobre números de versão e as várias branches do Subversion, consulte o artigo link:{releng}[Release Engineering].

=== Tentei instalar um novo kernel, e o chflags1 falhou. Como faço para contornar isso?

Resposta curta: o nível de segurança é maior que 0. Reinicialize diretamente para o modo de single user para instalar o kernel.

Resposta longa: O FreeBSD não permite alterar os flags do sistema em níveis de segurança superiores a 0. Para verificar o nível de segurança atual:

[source,bash]
....
# sysctl kern.securelevel
....

O nível de segurança não pode ser diminuído no modo multiusuário, portanto, inicialize no modo single user para instalar o kernel ou altere o nível de segurança em [.filename]#/etc/rc.conf# e reinicialize. Veja a página de manual man:init[8] para detalhes sobre o `securelevel`, e veja [.filename]#/etc/defaults/rc .conf# e a página de manual man:rc.conf[5] para mais informações sobre o [.filename]#rc.conf#.

=== Não consigo alterar a hora no meu sistema em mais de um segundo! Como faço para contornar isso?

Resposta curta: o sistema está em um nível de segurança maior que 1. Reinicialize diretamente para o modo de single user para alterar a data.

Resposta longa: O FreeBSD proíbe a alteração do tempo em mais de um segundo em níveis de segurança superiores a 1. Para verificar o nível de segurança:

[source,bash]
....
# sysctl kern.securelevel
....

O nível de segurança não pode ser diminuído no modo multiusuário. Inicialize no modo single user para alterar a data ou altere o nível de segurança no arquivo [.filename]#/etc/rc.conf# e reinicialize. Veja a página de manual man:init[8] para detalhes sobre o `securelevel`, e veja [.filename]#/etc/defaults/rc .conf# e a página de manual man:rc.conf[5] para mais informações sobre o [.filename]#rc.conf#.

=== Por que o rpc.statd está usando 256 MB de memória?

Não, não há vazamento de memória e ele não está usando 256 MB de memória. Por conveniência, o `rpc.statd` mapeia uma quantidade obscena de memória em seu espaço de endereço. Não há nada terrivelmente errado com isso do ponto de vista técnico; mas isso confunde o man:top[1] e o man:ps[1].

O man:rpc.statd[8] mapeia seu arquivo de status (residente no [.filename]#/var#) em seu espaço de endereçamento; para evitar se preocupar com o remapeamento do arquivo de status mais tarde quando ele precisar crescer, ele mapeia o arquivo de status com um tamanho generoso. Isso é muito evidente no código-fonte, onde é possível ver que o argumento length para o man:mmap[2] é `0x10000000` , ou décima sexta parte do espaço de endereço em um IA32, ou seja, exatamente 256 MB.

=== Por que não posso dar unset na flag schg de um arquivo?

O sistema está sendo executado em um nível de segurança maior que 0. Reduza o nível de segurança e tente novamente. Para obter mais informações, consulte <<securelevel, a entrada do FAQ referente ao securelevel>> e a página de manual do man:init[8].

=== O que é vnlru?

O `vnlru` descarrega e libera vnodes quando o sistema atinge o limite de `kern.maxvnodes`. Essa thread do kernel fica ociosa na maior parte do tempo e só é ativada quando existe uma quantidade enorme de RAM e os usuários estiverem acessando dezenas de milhares de arquivos minúsculos.

=== O que os vários estados de memória exibidos pelo top significam?

* `Active`: são páginas usadas recentemente.
* `Inactive`: são páginas que não foram utilizadas recentemente.
* `Laundry`: páginas recentemente não utilizadas estatisticamente, mas conhecidas por estarem sujas, ou seja, cujo conteúdo precisa ser paginado antes que possa ser reutilizado.
* `Free`: páginas sem conteúdo, que podem ser reutilizadas imediatamente.
* `Wired`: são páginas que estão fixadas na memória, geralmente para propósitos do kernel, mas também para uso especial em processos.

As páginas geralmente são gravadas em disco (um tipo de sincronização de VM) quando elas estão no estado laundry, mas as páginas ativas ou inativas também podem ser sincronizadas. Isso depende do rastreamento da CPU do bit modificado estar disponível e, em determinadas situações pode haver uma vantagem para um bloco de páginas da VM serem sincronizadas, independentemente da fila a que pertencem. Na maioria dos casos, é melhor pensar na fila laundry como uma fila de páginas relativamente não usadas que podem ou não estar no processo de serem gravadas no disco. A fila inativa contém uma mistura de páginas limpas e sujas; as páginas limpas próximas ao início da fila são recuperadas imediatamente para aliviar a falta de páginas livres e as páginas sujas são movidas para a fila laundry para processamento posterior.

Existem alguns outros flags (por exemplo, flag de ocupado ou de contagem ocupada) que podem modificar algumas das regras descritas.

=== Quanta memória livre está disponível?

Existem alguns tipos de "memória livre". O mais comum é a quantidade de memória disponível imediatamente, sem recuperar a memória já em uso. Esse é o tamanho da fila de páginas livres mais algumas outras páginas reservadas. Esse valor é exportado pelo `vm.stats.vm.v_free_count` man:sysctl[8], mostrado, por exemplo, pelo man:top[1]. Outro tipo de "memória livre" é a quantidade total de memória virtual disponível para os processos da área de usuário, que depende da soma do espaço de swap e da memória utilizável. Outros tipos de descrições de "memória livre" também são possíveis, mas é relativamente inútil defini-las, mas é importante garantir que a taxa de paginação seja mantida baixa e evitar ficar sem espaço de swap.

=== O que é o /var/empty?

O [.filename]#/var/empty# é um diretório que o programa man:sshd[8] utiliza ao executar a separação de privilégios. O diretório [.filename]#/var/empty# está vazio, pertence ao usuário `root` e possui as flags `schg` definidas. Este diretório não deve ser excluído.

=== Acabei de alterar o /etc/newsyslog.conf . Como posso verificar se ele faz o que eu espero?

Para ver o que man:newsyslog[8] vai fazer, use o seguinte:

[source,bash]
....
% newsyslog -nrvv
....

=== Minha hora está errada, como posso mudar o fuso horário?

Use o man:tzsetup[8].

== O sistema X Window e consoles virtuais

=== O que é o sistema X Window?

O sistema de janelas X (comumente chamado de `X11`) é o sistema de janelas mais amplamente disponível capaz de executar em Sistemas UNIX(TM) e sistemas UNIX(TM)-Like, incluindo o FreeBSD. A http://www.x.org/wiki/[Fundação X.Org] administra os http://en.wikipedia.org/wiki/X_Window_System_core_protocol[ padrões de protocolo X], sendo que a implementação de referência atual é a versão 11 release 7.7, então as referências são frequentemente encurtadas para `X11`.

Muitas implementações estão disponíveis para diferentes arquiteturas e sistemas operacionais. Uma implementação do código do lado do servidor é conhecida como um `Servidor X`.

=== Eu quero rodar o Xorg, como faço para isso?

Para instalar o Xorg, siga um destes procedimentos:

Use o meta-port package:x11/xorg[], que constrói e instala todos os componentes do Xorg.

Use package:x11/xorg-minimal[], que constrói e instala apenas os componentes Xorg necessários.

Instale o Xorg a partir de pacotes do FreeBSD:

[source,bash]
....
 # pkg install xorg
....

Após a instalação do Xorg, siga as instruções da seção link:{handbook}#x-config[Configuração X11] do Handbook do FreeBSD.

=== Eu tentei executar o X, mas eu recebo um erro No devices detected. quando eu digito startx. O que eu faço agora?

O sistema provavelmente está sendo executado em um `securelevel` alto. Não é possível iniciar o X em `securelevel` alto porque o X requer acesso de ao man:io[4]. Para obter mais informações, consulte a página de manual do man:init[8].

Existem duas soluções para o problema: definir o `securelevel` novamente a zero ou executar man:xdm[1] (ou um gerenciador de exibição alternativo) no momento da inicialização antes que o `securelevel` seja elevado.

Veja <<xdm-boot>> para mais informações sobre como executar o man:xdm[1] no momento da inicialização.

=== Por que meu mouse não funciona com o X?

Ao usar man:vt[4], o driver de console padrão, o FreeBSD pode ser configurado para suportar um ponteiro de mouse em cada tela virtual. Para evitar conflito com o X, o man:vt[4] suporta um dispositivo virtual chamado [.filename]#/dev/sysmouse#. Todos os eventos de mouse recebidos do dispositivo de mouse real são gravados no dispositivo via man:sysmouse[4]man:moused[8]. Para usar o mouse em um ou mais consoles virtuais, _e_ usar X, veja <<moused>> e configure o man:moused[8].

Em seguida, edite o arquivo [.filename]#/etc/X11/xorg.conf# e verifique se as seguintes linhas existem:

[.programlisting]
....
Section "InputDevice"
   Option          "Protocol" "SysMouse"
   Option          "Device" "/dev/sysmouse"
.....
....

Começando com a versão 7.4 do Xorg, as seções `InputDevice` no [.filename]#xorg.conf# são ignoradas em favor dos dispositivos autodetectados. Para restaurar o comportamento antigo, adicione a seguinte linha à seção `ServerLayout` ou `ServerFlags`:

[.programlisting]
....
Option "AutoAddDevices" "false"
....

Algumas pessoas preferem usar o [.filename]#/dev/mouse# com o X. Para fazer esse trabalho, [.filename]#/dev/mouse# deve estar vinculado a [.filename]#/dev/sysmouse# (veja man:sysmouse[4]) adicionando a seguinte linha ao [.filename]#/etc/devfs.conf# (veja man:devfs.conf[5]):

[.programlisting]
....
link    sysmouse    mouse
....

Este link pode ser criado reiniciando o man:devfs[5] com o seguinte comando (executado como `root`):

[source,bash]
....
# service devfs restart
....

=== Meu mouse tem uma fancy wheel. Posso usá-lo no X?

Sim, se o X estiver configurado para um mouse de 5 botões. Para fazer isso, adicione as linhas `Buttons 5` e `ZAxisMapping 4 5` na seção "InputDevice" do arquivo [.filename]#/etc/X11/xorg.conf#, como visto neste exemplo:

[.programlisting]
....
Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/sysmouse"
   Option          "Buttons" "5"
   Option          "ZAxisMapping" "4 5"
EndSection
....

O mouse pode ser habilitado no Emacs adicionando estas linhas ao [.filename]#~/.emacs#:

[.programlisting]
....
;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)
....

=== Meu laptop tem um touchpad Synaptics. Posso usá-lo no X?

Sim, depois de configurar algumas coisas para que funcione.

Para usar o driver synaptics do Xorg, primeiro remova `moused_enable` do [.filename]#rc.conf#.

Para habilitar a synaptics, adicione a seguinte linha ao [.filename]#/boot/loader.conf#:

[.programlisting]
....
hw.psm.synaptics_support="1"
....

Adicione o seguinte ao [.filename]#/etc/X11/xorg.conf#:

[.programlisting]
....
Section "InputDevice"
Identifier  "Touchpad0"
Driver      "synaptics"
Option      "Protocol" "psm"
Option      "Device" "/dev/psm0"
EndSection
....

E não se esqueça de adicionar o seguinte na seção "ServerLayout":

[.programlisting]
....
InputDevice    "Touchpad0" "SendCoreEvents"
....

=== Como eu uso displays X remotos?

Por motivos de segurança, a configuração padrão é não permitir que uma máquina abra remotamente uma janela.

Para ativar esse recurso, inicie o  X  com o argumento opcional `-listen_tcp`:

[source,bash]
....
% startx -listen_tcp
....

=== O que é um console virtual e como faço outros?

Os consoles virtuais fornecem várias sessões simultâneas na mesma máquina sem fazer nada complicado, como configurar uma rede ou executar o X.

Quando o sistema iniciar, ele exibirá um prompt de login no monitor depois de exibir todas as mensagens de inicialização. Digite seu nome de login e senha para começar a trabalhar no primeiro console virtual.

Para iniciar outra sessão, talvez para examinar a documentação de um programa ou para ler mensagens enquanto aguarda a conclusão de uma transferência por FTP, pressione kbd:[Alt] e pressione kbd:[F2]. Isso exibirá o prompt de login do segundo console virtual. Para voltar à sessão original, pressione kbd:[Alt+F1].

A instalação padrão do FreeBSD possui oito consoles virtuais habilitados. A combinação de teclas kbd:[ Alt + F1 ], kbd:[ Alt + F2 ], kbd:[ Alt + F3 ], e assim por diante alternará entre esses consoles virtuais.

Para habilitar mais consoles virtuais, edite [.filename]#/etc/ttys# (veja man:ttys[5]) e adicione entradas do [.filename]#ttyv8# até o [.filename]#ttyvc#, após os comentários na seção "Virtual terminals":

[.programlisting]
....
# Edit the existing entry for ttyv8 in /etc/ttys and change
# "off" to "on".
ttyv8   "/usr/libexec/getty Pc"         xterm  on secure
ttyv9   "/usr/libexec/getty Pc"         xterm  on secure
ttyva   "/usr/libexec/getty Pc"         xterm  on secure
ttyvb   "/usr/libexec/getty Pc"         xterm  on secure
....

Quanto mais terminais virtuais estiverem ativos, mais recursos serão usados. Isso pode ser um problema em sistemas com 8 MB de RAM ou menos. Considere mudar a opção `secure` para `insecure`.

[IMPORTANT]
====
Para executar um servidor X, pelo menos um terminal virtual deverá ser deixado como `off` para ele usar. Isso significa que apenas onze das teclas de função Alt podem ser usadas como consoles virtuais, de modo que uma deverá ser deixada livre para uso do servidor X.
====

Por exemplo, para executar o X e onze consoles virtuais, a configuração para o terminal virtual 12 deve ser:

[.programlisting]
....
ttyvb   "/usr/libexec/getty Pc"         xterm  off secure
....

A maneira mais fácil de ativar os consoles virtuais é reinicializar.

=== Como eu acesso os consoles virtuais a partir do X?

Utilize kbd:[Ctrl+Alt+Fn] para voltar a um console virtual. Pressione kbd:[ Ctrl + Alt + F1 ] para retornar ao primeiro console virtual.

Uma vez em um console de texto, use kbd:[ Alt + F  n  ] para mover-se entre eles.

Para retornar à sessão X, mude para o console virtual que está executando o X. Se o X foi iniciado a partir da linha de comando usando `startx`, a sessão X será anexada ao próximo console virtual não utilizado, e não ao console de texto no qual foi invocado. Para oito terminais virtuais ativos, o X será executado no nono, portanto use kbd:[ Alt + F9 ].

[[xdm-boot]]
=== Como faço para carregar o XDM na inicialização?

Existem duas escolas de pensamento sobre como iniciar o man:xdm[1]. Uma escola inicia o `xdm` a partir do [.filename]#/etc/ttys# (veja man:ttys[5]) usando o exemplo fornecido, enquanto o outro executa o `xdm` a partir do [.filename]#rc.local# (veja man:rc[8]) ou de um script [.filename]#X# localizado em [.filename]#/usr/local/etc/rc.d#. Ambos são igualmente válidos, e um pode funcionar em situações em que o outro não funciona. Em ambos os casos, o resultado é o mesmo: O X mostrará um prompt de login gráfico.

O método man:ttys[5] tem a vantagem de documentar qual vty X iniciará e passando a responsabilidade de reiniciar o servidor X no logout para o man:init[8]. O método man:rc[8] facilita o `kill xdm` se houver um problema ao iniciar o servidor X.

Se carregado pelo man:rc[8], o `xdm` deve ser iniciado sem nenhum argumento. `xdm` deve iniciar _após_ o man:getty[8] ser executado, ou então `getty` e `xdm` entrarão em conflito, bloqueando o console. A melhor maneira de contornar isso é fazer com que o script espere 10 segundos ou mais e, em seguida, iniciar o `xdm`.

Ao iniciar o `xdm` pelo [.filename]#/etc/ttys#, ainda há uma chance de conflito entre `xdm` e man:getty[8]. Uma maneira de evitar isso é adicionar o número `vt` no arquivo [.filename]#/usr/local/lib/X11/xdm/Xservers#:

[.programlisting]
....
:0 local /usr/local/bin/X vt4
....

O exemplo acima irá direcionar o servidor X para ser executado em [.filename]#/dev/ttyv3#. Observe que o número é compensado por um. O servidor X conta a vty a partir de 1, enquanto o kernel do FreeBSD numera a vty a partir de zero.

=== Por que eu obtenho o erro Couldn't open console quando executo o xconsole?

Quando o X é iniciado com o comando `startx`, as permissões em [.filename]#/dev/console#_não_ serão alteradas, o que resultará um comportamento errático de algumas coisas tais como o não funcionamento do `xterm -C` e do `xconsole`.

Isso ocorre devido à maneira como as permissões do console são definidas por padrão. Em um sistema multiusuário, não é necessário que qualquer usuário possa escrever no console do sistema. Para os usuários que estão logando diretamente em uma máquina com um VTY, existe o arquivo man:fbtab[] para resolver tais problemas.

Em poucas palavras, certifique-se de que uma linha não comentada do formulário esteja no [.filename]#/etc/fbtab# (veja man:fbtab[5]):

[.programlisting]
....
/dev/ttyv0 0600 /dev/console
....

Ele irá garantir que quem fizer o login em [.filename]#/dev/ttyv0# será o dono do console.

=== Por que meu mouse PS/2 não funciona direito no X?

O mouse e o driver do mouse podem estar fora de sincronização. Em casos raros, o driver também pode relatar erroneamente erros de sincronização:

[.programlisting]
....
psmintr: out of sync (xxxx != yyyy)
....

Se isso acontecer, desative o código de verificação de sincronização definindo as flags de driver para o driver de mouse PS/2 como `0x100`. Isto pode ser mais facilmente alcançado adicionando `hint.psm.0.flags="0x100"` ao arquivo [.filename]#/boot/loader.conf# e reiniciando.

=== Como eu inverto os botões do mouse?

Digite `xmodmap -e "pointer = 3 2 1"`. Adicione este comando ao [.filename]#~/.xinitrc# ou [.filename]#~/.xsession# para que isso aconteça automaticamente.

=== Como faço para instalar uma splash screen e onde posso encontrá-las?

A resposta detalhada para essa pergunta pode ser encontrada na seção link:{handbook}#boot-splash[Telas de inicialização do tempo de inicialização] do FreeBSD Handbook.

=== Posso usar as teclas do Windows do meu teclado no X?

Sim. Use o man:xmodmap[1] para definir quais funções as teclas devem executar.

Supondo que todos os teclados Windows sigam um padrão, os códigos de teclas para essas três teclas são os seguintes:

* 115 - tecla kbd:[ Windows ], entre as teclas kbd:[ Ctrl ] e kbd:[ Alt ] do lado esquerdo
* 116 - tecla kbd:[ Windows ], à direita de kbd:[ AltGr ]
* 117 - kbd:[ Menu ], à esquerda da tecla kbd:[Ctrl] da direita

Para que a tecla kbd:[ Windows ] da esquerda imprima uma vírgula, tente isto.

[source,bash]
....
# xmodmap -e "keycode 115 = comma"
....

Para que os mapeamentos de teclas kbd:[Windows] sejam ativados automaticamente toda vez que X for iniciado, coloque os comandos `xmodmap` em [.filename]#~/.xinitrc# ou, preferencialmente, crie um [.filename]#~/.xmodmaprc# e inclua as opções `xmodmap`, uma por linha, e adicione a seguinte linha ao [.filename]#~/.xinitrc#:

[.programlisting]
....
xmodmap $HOME/.xmodmaprc
....

Por exemplo, para mapear as 3 chaves para serem kbd:[F13], kbd:[F14] e kbd:[F15], respectivamente. Isso facilitaria mapeá-los para funções úteis em aplicativos ou no gerenciador de janelas.

Para fazer isto, coloque o seguinte em [.filename]#~/.xmodmaprc#.

[.programlisting]
....
keycode 115 = F13
keycode 116 = F14
keycode 117 = F15
....

Para o gerenciador da área de trabalho package:x11-wm/fvwm2[], pode-se mapear as chaves para que kbd:[F13] seja minimizada a janela em que o cursor está ou a maximize, kbd:[F14] traz a janela em que o cursor está para a frente ou, se já estiver na frente, a coloca em background kbd:[F15] aparece no menu principal do Workplace mesmo que o cursor não esteja a área de trabalho, o que é útil quando nenhuma parte da área de trabalho está visível.

As seguintes entradas em [.filename]#~/.fvwmrc# implementam a configuração acima mencionada:

[.programlisting]
....
Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop
....

=== Como posso obter aceleração de hardware 3D para o OpenGL ?

A disponibilidade da aceleração 3D depende da versão do Xorg e do tipo de chip de vídeo. Para um chip da nVidia, use os drivers binários fornecidos para o FreeBSD instalando um dos seguintes ports:

As versões mais recentes das placas nVidia são suportadas pelo port package:x11/nvidia-driver[].

Drivers mais antigos estão disponíveis como package:x11/nvidia-driver-###[]

A nVidia fornece informações detalhadas sobre qual placa é suportada por qual driver em seu site: http://www.nvidia.com/object/IO_32667.html[http://www.nvidia.com /object/IO_32667.html].

Para a Matrox G200/G400, verifique o port package:x11-drivers/xf86-video-mga[].

Para a ATI Rage 128 e Radeon, consulte man:ati[4], man:r128[4] and man:radeon[4].

== Networking

=== Onde posso obter informações sobre a inicialização sem disco?

"Inicialização sem disco" significa que o sistema FreeBSD é inicializado através de uma rede e lê os arquivos necessários de um servidor ao invés de seu disco rígido. Para maiores detalhes, consulte a entrada do Handbook link:{handbook}#network-diskless[Inicialização sem disco].

=== Uma maquina FreeBSD pode ser usada como um roteador de rede dedicado?

Sim. Consulte a entrada do Manual em link:{handbook}#advanced-networking[rede avançada], especificamente a seção sobre link:{handbook}#network-routing[roteamento e gateways].

=== O FreeBSD suporta NAT ou Mascaramento de IPs?

Sim. Para obter instruções sobre como usar o NAT em uma conexão PPP, consulte a seção do link:{handbook}#userppp[PPP] no manual. Para usar o NAT em algum outro tipo de conexão de rede, consulte a seção link:{handbook}#network-natd[natd] do manual.

=== Como posso configurar aliases de Ethernet?

Se o alias estiver na mesma sub-rede que um endereço já configurado na interface, adicione `netmask 0xffffffff` a este comando:

[source,bash]
....
# ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff
....

Caso contrário, especifique o endereço de rede e a máscara de rede como de costume:

[source,bash]
....
# ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00
....

Mais informações podem ser encontradas link:{handbook}#configtuning-virtual-hosts[Handbook] do FreeBSD.

=== Por que não posso montar o NFS de uma máquina Linux?

Algumas versões do código NFS do Linux(TM) aceitam somente solicitações de montagem vindas de uma porta privilegiada; tente executar o seguinte comando:

[source,bash]
....
# mount -o -P linuxbox:/blah /mnt
....

=== Por que o comando mountd continua me dizendo que ele can't change attributes (não pode alterar os atributos) e que eu tenho uma bad exports list (lista de exports ruins) no meu servidor NFS do FreeBSD?

O problema mais freqüente é não entender o formato correto de [.filename]#/etc/exports#. Revise man:exports[5] e o link:{handbook}#network-nfs[NFS] no manual, especialmente na seção link:{handbook}#configuring-nfs[configurando o NFS].

=== Como faço para ativar o suporte a multicast IP?

Instale o pacote ou port package:net/mrouted[] e adicione `mrouted_enable="YES"` ao [.filename]#/etc/rc.conf# para que o FreeBSD inicie este serviço no momento da inicialização.

=== Por que preciso usar o FQDN para hosts na minha rede?

Veja a resposta no link:{handbook}#mail-trouble[Handbook] do FreeBSD.

=== Por que recebo oerro, Permission denied, para todas as operações de rede?

Se o kernel é compilado com a opção `IPFIREWALL`, esteja ciente de que a política padrão é negar todos os pacotes que não são explicitamente permitidos.

Se o firewall foi inadvertidamente configurado de forma errada, restaure a operacionalidade da rede digitando o seguinte comando como `root`:

[source,bash]
....
# ipfw add 65534 allow all from any to any
....

Considere configurar a opção `firewall_type="open"` no [.filename]#/etc/rc.conf#.

Para obter mais informações sobre como configurar seu firewall, consulte o link:{handbook}#firewalls-ipfw[Handbook].

=== Por que minha regra ipfw fwd para redirecionar um serviço para outra máquina que não está funcionando?

Possivelmente porque você precisa utilizar a conversão de endereços de rede (NAT) em vez de apenas encaminhar os pacotes. Uma regra "fwd" apenas encaminha os pacotes, ela não altera os dados dentro do pacote. Considere esta regra:

[source,bash]
....
01000 fwd 10.0.0.1 from any to foo 21
....

Quando um pacote com um endereço de destino _foo_ chega à máquina com esta regra, o pacote é encaminhado para _10.0.0.1_, mas ainda tem o endereço de destino _foo_. O endereço de destino do pacote não é alterado para _10.0.0.1_. A maioria das máquinas provavelmente descartaria um pacote que recebesse com um endereço de destino que não fosse o seu. Portanto, usar uma regra "fwd" geralmente não funciona da maneira esperada pelo usuário. Esse comportamento é um recurso e não um bug.

Veja o <<service-redirect,FAQ sobre redirecionamento de serviços>>, o manual do man:natd[8], ou um dos vários utilitários de redirecionamento de porta na https://www.FreeBSD.org/ports/[Coleção de Portas] para uma maneira correta de fazer isso.

=== Como posso redirecionar as solicitações de serviço de uma máquina para outra?

FTP e outras solicitações de serviço podem ser redirecionadas com o pacote ou port package:sysutils/socket[]. Substitua a entrada para o serviço em [.filename]#/etc/inetd.conf# para chamar `socket`, conforme visto neste exemplo para ftpd:

[.programlisting]
....
ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.example.com ftp
....

na qual _ftp.example.com_ e _ftp_ são o host e a porta de destino do redirecionamento, respectivamente.

=== Onde posso obter uma ferramenta de gerenciamento de largura de banda?

Existem três ferramentas de gerenciamento de largura de banda disponíveis para o FreeBSD. man:dummynet[4] é integrado ao FreeBSD como parte do man:ipfw[4]. http://www.sonycsl.co.jp/person/kjc/programs.html[ALTQ] foi integrado ao FreeBSD como parte do man:pf[4]. O Bandwidth Manager das http://www.etinc.com/[ Tecnologias Emergentes ] é um produto comercial.

=== Por que estou recebendo o erro /dev/bpf0: device not configured?

O aplicativo em execução requer o Packet Filter da Berkeley (man:bpf[4]), mas ele foi removido de um kernel personalizado. Adicione isto ao arquivo de configuração do kernel e construa um novo kernel:

[.programlisting]
....
device bpf        # Berkeley Packet Filter
....

=== Como faço para montar um disco de uma máquina Windows que esteja na minha rede, tal como o smbmount no Linux?

Use o conjunto de ferramentas SMBFS. Ele inclui um conjunto de modificações do kernel e um conjunto de programas da área de usuário. Os programas e as informações necessárias estão disponíveis como man:mount_smbfs[8] no sistema base.

=== O que são essas mensagens sobre: ​​Limiting icmp/open port/closed port response em meus arquivos de log?

Esta mensagem do kernel indica que alguma atividade está provocando o envio de uma grande quantidade de respostas de reset de ICMP ou TCP (RST). As respostas ICMP são frequentemente geradas como resultado de tentativas de conexão a portas UDP não utilizadas. Os resets TCP são geradas como resultado de tentativas de conexão a portas TCP não abertas. Entre outros, esses são os tipos de atividades que podem causar essas mensagens:

* Ataques de negação de serviço (DoS) de força bruta (em oposição a ataques de pacote único que exploram uma vulnerabilidade específica).
* Varreduras de porta que tentam se conectar a um grande número de portas (em oposição a apenas tentar algumas portas conhecidas).

O primeiro número na mensagem indica quantos pacotes o kernel teria enviado se o limite não estivesse no lugar e o segundo indica o limite. Este limite é controlado usando `net.inet.icmp.icmplim`. Este exemplo define o limite para `300` pacotes por segundo:

[source,bash]
....
# sysctl net.inet.icmp.icmplim=300
....

Para desativar essas mensagens sem desativar a limitação de resposta, use o `net.inet.icmp.icmplim_output` para desativar a saída:

[source,bash]
....
# sysctl net.inet.icmp.icmplim_output=0
....

Finalmente, para desabilitar completamente a limitação de resposta, configure `net.inet.icmp.icmplim` para `0`. Desabilitar a limitação de resposta é desencorajado pelos motivos listados acima.

=== O que são essas mensagens de erro arp: unknown hardware address format?

Isso significa que algum dispositivo na Ethernet local está usando um endereço MAC em um formato que o FreeBSD não reconhece. Isso provavelmente é causado por alguém que está experimentando uma placa Ethernet em algum outro lugar da rede. Isso é mais comumente visto em redes de modem a cabo. É inofensivo e não deve afetar o desempenho do sistema FreeBSD.

=== Por que eu continuo vendo mensagens como: 192.168.0.10 is on fxp1 but got reply from 00:15:17:67:cf:82 on rl0, e como desabilitá-lo?

Porque um pacote está vindo de fora da rede inesperadamente. Para desativá-los, defina `net.link.ether.inet.log_arp_wrong_iface` como `0`.

=== Como faço para compilar um kernel com suporte somente ao IPv6?

Configure seu kernel com estas configurações: 

[source,bash]
....
include GENERIC
ident GENERIC-IPV6ONLY
makeoptions MKMODULESENV+="WITHOUT_INET_SUPPORT="
nooptions INET
nodevice gre
....

== Segurança

=== O que é uma caixa de areia (sandbox)?

"Sandbox" é um termo de segurança. Isso pode significar duas coisas:

* Um processo que é colocado dentro de um conjunto de paredes virtuais que são projetadas para impedir que alguém que interrompa o processo seja capaz de invadir o sistema mais amplo.
+ 
O processo só é capaz de correr dentro das barreiras. Desde que nada que o processo faça em relação à execução de código seja capaz de violar as barreiras, uma auditoria detalhada de seu código não é necessária para poder dizer certas coisas sobre sua segurança.
+ 
As barreiras podem ser um ID do usuário, por exemplo. Esta é a definição usada nas páginas de manual de man:security[7] e man:named[8].
+ 
Veja o serviço `ntalk`, por exemplo (veja man:inetd[8]). Este serviço costumava rodar como ID de usuário `root`. Agora ele é executado como ID do usuário `tty`. O usuário `tty` é um sandbox projetado para tornar mais difícil para alguém que invadiu o sistema com sucesso através do `ntalk` ser capaz de hackear além do seu ID de usuário.
* Um processo que é colocado dentro de uma simulação da máquina. Isso significa que alguém que é capaz de entrar no processo pode acreditar que ele pode invadir a máquina mais ampla, mas está, na verdade, apenas invadindo uma simulação dessa máquina e não modificando nenhum dado real.
+ 
A maneira mais comum de fazer isso é construir um ambiente simulado em um subdiretório e então executar os processos nesse diretório chrooted para que o diretório [.filename]#/# para esse processo seja este, não o diretório [.filename]#/# real do sistema).
+ 
Outro uso comum é montar um sistema de arquivos subjacente somente leitura e, em seguida, criar uma camada do sistema de arquivos sobre ele, o que dá a um processo uma visualização aparentemente gravável nesse sistema de arquivos. O processo pode acreditar que é capaz de escrever nesses arquivos, mas o processo apenas vê os efeitos - outros processos no sistema não, necessariamente.
+ 
Foi feita uma tentativa de tornar esse tipo de sandbox tão transparente que o usuário (ou hacker) não percebe que está dentro dele.

O UNIX(TM) implementa dois sandboxes principais. Um está no nível do processo e o outro está no nível do usuário.

Todo processo UNIX(TM) é completamente protegido contra qualquer outro processo UNIX(TM). Um processo não pode modificar o espaço de endereço de outro.

Um processo UNIX(TM) é de propriedade de um determinado ID de usuário. Se o ID de usuário não for o usuário `root`, ele servirá para proteger o processo contra processos pertencentes a outros usuários. O ID do usuário também é usado para proteger os dados no disco.

=== O que é securelevel?

`securelevel` é um mecanismo de segurança implementado no kernel. Quando o nível de segurança é positivo, o kernel restringe certas tarefas; nem mesmo o superusuário (`root`) pode executá-los. O mecanismo de securelevel limita a capacidade de:

* Desativar determinados flags de arquivo, tais como `schg` (o flag de sistema imutável).
* Escrever na memória do kernel através de [.filename]#/dev/mem# e [.filename]#/dev/kmem#.
* Carregar módulos do kernel.
* Alterar as regras do firewall.

Para verificar o status do securelevel em um sistema em execução:

[source,bash]
....
# sysctl -n kern.securelevel
....

A saída contém o valor atual do nível de segurança. Se for maior que 0, pelo menos algumas das proteções do securelevel são ativadas.

O securelevel de um sistema em execução não pode ser reduzido, pois isso invalidaria seu propósito. Se uma tarefa exigir que o securelevel seja não-positivo, altere as variáveis ​​`kern_securelevel` e `kern_securelevel_enable` em [.filename]#/etc/rc.conf# e reinicialize.

Para obter mais informações sobre o securelevel e as coisas específicas que todos os níveis fazem, consulte man:init[8].

[WARNING]
====

O securelevel não é uma bala de prata; tem muitas deficiências conhecidas. Mais frequentemente do que não, fornece uma falsa sensação de segurança.

Um dos seus maiores problemas é que, para que seja eficaz, todos os arquivos usados ​​no processo de inicialização até que o nível de segurança seja definido devem ser protegidos. Se um invasor puder fazer o sistema executar seu código antes do nível de segurança que está sendo definido (o que acontece muito tarde no processo de inicialização, pois algumas coisas que o sistema deve fazer na inicialização não podem ser feitas em um nível elevado), suas proteções são invalidadas . Embora essa tarefa de proteger todos os arquivos usados ​​no processo de inicialização não seja tecnicamente impossível, se for obtida, a manutenção do sistema se tornará um pesadelo, já que seria necessário desativar o sistema, pelo menos no modo de usuário único, para modificar um arquivo de configuração.

Este ponto e outros são frequentemente discutidos nas listas de discussão, particularmente na http://lists.FreeBSD.org/mailman/listinfo/freebsd-security[lista de discussão de segurança do FreeBSD]. Pesquise nos arquivos https://www.FreeBSD.org/search/[aqui] para uma discussão extensa. Um mecanismo mais refinado é o preferido.
====

=== O que é essa conta UID 0 toor? Eu fui comprometido?

Não se preocupe. `toor` é uma conta de superusuário "alternativa", onde toor é root soletrada para ao contrário. Ele deve ser usado com um shell não padrão, portanto, o shell padrão para `root` não precisa ser alterado. Isto é importante porque os shells que não fazem parte da distribuição base, mas que são instalados a partir de ports ou packages, são instalados em [.filename]#/usr/local/bin# que, por padrão, reside em um sistema de arquivos diferente . Se o shell do `root` estiver localizado em [.filename]#/usr/local/bin# e o sistema de arquivos contendo [.filename]#/usr/local/bin#) não está montado, `root` não poderá efetuar login para corrigir um problema e terá que reinicializar no modo de usuário único para inserir o caminho para um shell.

Algumas pessoas usam `toor` para tarefas do dia-a-dia do `root` com um shell não padrão, deixando o `root`, com um shell padrão, para o modo de usuário único ou emergências. Por padrão, um usuário não pode logar usando `toor` porque ele não tem uma senha, então efetue login como `root` e defina um senha para `toor` antes de usá-lo para efetuar login.

== Comunicações Seriais

Esta seção responde a perguntas comuns sobre comunicação serial com o FreeBSD.

=== Como obtenho o prompt de boot: em um console serial?

Veja link:{handbook}#serialconsole-setup[ esta seção do Handbook].

=== Como sei se o FreeBSD encontrou minhas portas seriais ou placas de modem?

Quando o kernel do FreeBSD for inicializado, ele irá sondar as portas seriais para as quais o kernel está configurado. Observe atentamente as mensagens de inicialização ou execute este comando após o sistema estar ativo e em execução:

[source,bash]
....
% grep -E '^(sio|uart)[0-9]' < /var/run/dmesg.boot
sio0: <16550A-compatible COM port> port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
sio0: type 16550A
sio1: <16550A-compatible COM port> port 0x2f8-0x2ff irq 3 on acpi0
sio1: type 16550A
....

Este exemplo mostra duas portas seriais. O primeiro está no IRQ4, endereço de porta `0x3f8`, e possui um chip UART tipo 16550A. O segundo usa o mesmo tipo de chip, mas está no IRQ3 e está no endereço de porta `0x2f8`. As placas de modem internas são tratadas como portas seriais, exceto pelo fato de sempre terem um modem conectado à porta.

O kernel [.filename]#GENERIC# inclui suporte para duas portas seriais usando as mesmas configurações de IRQ e endereço de porta no exemplo acima. Se estas configurações não forem adequadas para o sistema, ou se houver mais placas de modem ou portas seriais do que o kernel está configurado, reconfigure usando as instruções em <<make-kernel,construindo um kernel>> para mais detalhes.

=== Como eu acesso as portas seriais no FreeBSD? (específico de x86)

A terceira porta serial, [.filename]#sio2#, ou [.filename]#COM3#, está em [.filename]#/dev/cuad2# para dispositivos dial-out e em [.filename]#/dev/ttyd2# para dispositivos dial-in. Qual é a diferença entre essas duas classes de dispositivos?

Ao abrir [.filename]#/dev/ttydX# no modo de bloqueio, um processo aguardará o dispositivo [.filename]#cuadX# correspondente ficar inativo e, em seguida, aguardar a ativação da linha de detecção. Quando o dispositivo [.filename]#cuadX# é aberto, ele garante que a porta serial não esteja em uso pelo dispositivo [.filename]#ttydX#. Se a porta estiver disponível, ela a rouba do dispositivo [.filename]#ttydX#. Além disso, o dispositivo [.filename]#cuadX# não se importa com a detecção da portadora. Com este esquema e um modem de resposta automática, os usuários remotos podem efetuar login e os usuários locais ainda podem discar com o mesmo modem e o sistema cuidará de todos os conflitos.

=== Como habilitar o suporte para uma placa serial com várias portas?

A seção sobre configuração do kernel fornece informações sobre como configurar o kernel. Para uma placa serial com várias portas, coloque uma linha man:sio[4] para cada porta serial na placa no man:device.hints[5]. Mas coloque os especificadores de IRQ em apenas uma das entradas. Todas as portas no cartão devem compartilhar um IRQ. Para consistência, use a última porta serial para especificar o IRQ. Além disso, especifique a seguinte opção no arquivo de configuração do kernel:

[.programlisting]
....
options COM_MULTIPORT
....

O exemplo a seguir [.filename]#/boot/device.hints# é para uma placa serial AST de 4 portas no IRQ 12:

[.programlisting]
....
hint.sio.4.at="isa"
hint.sio.4.port="0x2a0"
hint.sio.4.flags="0x701"
hint.sio.5.at="isa"
hint.sio.5.port="0x2a8"
hint.sio.5.flags="0x701"
hint.sio.6.at="isa"
hint.sio.6.port="0x2b0"
hint.sio.6.flags="0x701"
hint.sio.7.at="isa"
hint.sio.7.port="0x2b8"
hint.sio.7.flags="0x701"
hint.sio.7.irq="12"
....

Os flags indicam que a porta principal possui um número menor `7` (`0x700`) e todas as portas compartilham um IRQ (`0x001`).

=== Posso definir os parâmetros seriais padrões para uma porta?

Veja a seção link:{handbook}#serial-hw-config[ Comunicações Seriais ] no Handbook do FreeBSD .

=== Por que não consigo executar o comando tip ou o cu?

Os utilitários man:tip[1] and man:cu[1] só podem acessar o diretório [.filename]#/var/spool/lock# via usuário `uucp` e grupo `dialer` . Use o grupo `dialer` para controlar quem tem acesso ao modem ou sistemas remotos adicionando contas de usuário ao `dialer`.

Como alternativa, todos podem ser configurados para executar man:tip[1] e man:cu[1] digitando:

[source,bash]
....
# chmod 4511 /usr/bin/cu
# chmod 4511 /usr/bin/tip
....

== Perguntas Diversas

=== O FreeBSD usa muito espaço de swap mesmo quando o computador tem memória livre sobrando. Por quê?

O FreeBSD irá proativamente mover páginas ociosas e não usadas da memória principal para swap, a fim de disponibilizar mais memória principal para uso ativo. Esse uso pesado de swap é balanceado usando a memória extra livre para armazenamento em cache.

Note que enquanto o FreeBSD é proativo a esse respeito, ele não decide arbitrariamente trocar páginas quando o sistema está realmente inativo. Assim, o sistema não será todo paginado depois de deixá-lo ocioso durante a noite.

=== Por que top mostra pouca memória livre mesmo quando tenho poucos programas em execução?

A resposta simples é que a memória livre é uma memória desperdiçada. Qualquer memória que os programas não aloquem ativamente é usada pelo kernel do FreeBSD como cache de disco. Os valores mostrados por man:top[1] rotulados como `Inactivo` e `Laundry` são todos os dados armazenados em cache em diferentes níveis de envelhecimento. Esses dados em cache significam que o sistema não precisa acessar um disco lento novamente para os dados que acessou recentemente, aumentando assim o desempenho geral. Em geral, um valor baixo mostrado para a memória `Free` no man:top[1] é considerado bom, desde que não seja _muito_ baixo.

=== Por que o chmod não altera as permissões nos links simbólicos?

Os links simbólicos não têm permissões e, por padrão, man:chmod[1] seguirá links simbólicos para alterar as permissões no arquivo de origem, se possível. Para o arquivo, [.filename]#foo# com um link simbólico chamado [.filename]#bar#, este comando será sempre bem-sucedido.

[source,bash]
....
% chmod g-w bar
....

No entanto, as permissões no arquivo [.filename]#bar# não serão alteradas.

Ao alterar os modos das hierarquias de arquivos do usuario root em vez dos próprios arquivos, use `-H` ou `-L` junto com `-R` para este trabalho. Veja man:chmod[1] e man:symlink[7] para mais em formação.

[WARNING]
====

`-R` faz um man:chmod[1] recursivo. Tenha cuidado ao especificar diretórios ou links simbólicos para diretórios para o man:chmod[1]. Para alterar as permissões de um diretório referenciado por um link simbólico, use man:chmod[1] sem nenhuma opção e siga o link simbólico com uma barra à direita ([.filename]#/#). Por exemplo, se [.filename]#foo# for um link simbólico para o diretório [.filename]#bar#, para alterar as permissões de [.filename]#foo# (na verdade [.filename]#bar#) faça algo como:

[source,bash]
....
% chmod 555 foo/
....

Com a barra final, man:chmod[1] seguirá o link simbólico, [.filename]#foo#, para alterar as permissões do diretório, [.filename]#bar#.
====

=== Posso executar binários do DOS no FreeBSD?

Sim. Um programa de emulação DOS, package:emulators/doscmd[], está disponível na Coleção de Ports do FreeBSD.

Se o doscmd não for suficiente, o package:emulators/pcemu[] emulará um 8088 e serviços de BIOS suficientes para executar muitos aplicativos em modo texto do DOS. Requer o sistema de janelas X.

A coleção de ports também tem o package:emulators/dosbox[]. O foco principal deste aplicativo é emular antigos jogos do DOS usando o sistema de arquivos local para os arquivos.

=== O que eu preciso fazer para traduzir um documento do FreeBSD para minha língua nativa?

Veja a link:{fdp-primer}#translations[ FAQ de traduções ] na Documentação do Primer Project do FreeBSD.

=== Por que os meus emails destinados a qualquer endereço no dominio FreeBSD.org são sempre rejeitados?

O sistema de mensagens do `FreeBSD.org` implementa algumas verificações do Postfix nos e-mails recebidos e rejeita e-mails que são de retransmissões mal configurados ou que parecem ser spam. Alguns dos requisitos específicos são:

* O endereço IP do cliente SMTP deve possuir um registro de DNS reverso para encaminhar hostnames confirmados.
* O nome completo do host fornecido na conversação SMTP (HELO ou EHLO) deve ser resolvido para o endereço IP do cliente.

Outros conselhos para ajudar suas mensagens a chegar ao seu destino incluem:

* O email deve ser enviado em texto simples, e as mensagens enviadas para as listas de discussão geralmente não devem ter mais de 200 KB.
* Evite postagem cruzadas excessivas. Escolha _uma_ lista de discussão que pareça mais relevante e envie-a para lá.

Se você ainda tiver problemas com a infra-estrutura de e-mail no `FreeBSD.org`, envie uma observação com os detalhes para mailto:postmaster@freebsd.org[postmaster@freebsd.org]; Inclua um intervalo de data/hora para que os registros possam ser revisados ​​-- e observe que apenas mantemos uma semana de registros de e-mail. (Certifique-se de especificar o fuso horário ou o deslocamento de UTC.)

=== Onde posso conseguir uma conta gratuita FreeBSD?

Embora o FreeBSD não forneça acesso aberto a nenhum de seus servidores, outros fornecem sistemas UNIX(TM) de acesso aberto. A taxa varia e serviços limitados podem estar disponíveis.

http://www.arbornet.org/[ A Arbornet, Inc ], também conhecida como _M-Net_, oferece acesso livre a sistemas UNIX(TM) desde 1983. Começando num Altos rodando o System III, o site mudou para o BSD/OS em 1991. Em junho de 2000, o site mudou novamente para o FreeBSD. _M-Net_ pode ser acessado via telnet e SSH e fornece acesso básico a todo o pacote de software FreeBSD. No entanto, o acesso à rede é limitado a membros e usuários que doam para o sistema, que é executado como uma organização sem fins lucrativos. O _M-Net_ também oferece um sistema de quadro de avisos e um bate-papo interativo.

=== Qual é o nome do mascotinho vermelho?

Ele não tem um, e é chamado apenas de "o daemon BSD". Se você insistir em usar um nome, chame-o de "beastie". Note que "beastie" é pronunciado "BSD".

Mais informações sobre o daemon BSD estão disponíveis em sua http://www.mckusick.com/beastie/index.html[home page].

=== Posso usar a imagem do daemon do BSD?

Possivelmente. O daemon BSD tem copyright de Marshall Kirk McKusick. Verifique sua http://www.mckusick.com/beastie/mainpage/copyright.html[ Declaração sobre o Uso da Figura do Daemon do BSD] para termos de uso detalhados.

Em resumo, a imagem pode ser usada com bom gosto, para uso pessoal, desde que seja dado o crédito apropriado. Antes de usar o logotipo comercialmente, entre em contato com Kirk McKusick mailto:mckusick@FreeBSD.org[mckusick@FreeBSD.org] para obter permissão. Mais detalhes estão disponíveis na http://www.mckusick.com/beastie/index.html[ Home page do BSD Daemon].

=== Vocês tem alguma imagem BSD daemon que eu poderia usar?

Desenhos Xfig e eps estão disponíveis em [.filename]#/usr/shared/examples/BSD_daemon/#.

=== Eu vi um acrônimo ou outro termo nas listas de discussão e não entendo o que isso significa. Onde devo procurar?

Consulte o link:{handbook}#freebsd-glossary[Glossário do FreeBSD].

=== Por que eu deveria me importar com a cor da bikeshed?

A resposta realmente curta é que você não deveria. A resposta um pouco mais longa é que só porque você é capaz de construir um bikeshed não significa que você deve impedir os outros de construir um só porque você não gosta da cor na qual eles planejam pintá-lo. Esta é uma metáfora indicando que você não precisa discutir sobre cada pequena característica apenas porque você sabe o suficiente para fazê-lo. Algumas pessoas comentaram que a quantidade de ruído gerada por uma mudança é inversamente proporcional à complexidade da mudança.

A resposta mais longa e completa é que depois de uma longa discussão sobre se man:sleep[1] deve receber argumentos secundários fracionários, Poul-Henning Kamp mailto:phk@FreeBSD.org[phk@FreeBSD.org] publicou uma longa mensagem intitulada "link:http://www.bikeshed.com[ Um galpão de bicicleta (qualquer cor serve) na grama mais verde...]"As partes apropriadas dessa mensagem são citadas abaixo.

Poul-Henning Kamp mailto:phk@FreeBSD.org[phk@FreeBSD.org] em http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers[freebsd-hackers] 2 de outubro de 1999
"O que acontece com esse bicicletário? " Alguns de vocês me perguntaram.

É uma longa história, ou melhor, é uma história antiga, mas na verdade é bem curta. C. Northcote Parkinson escreveu um livro no início dos anos 1960, chamado "Lei de Parkinson", que contém muitas informações sobre a dinâmica da administração.

_[recorte um pouco o comentário sobre o livro]_

No exemplo específico envolvendo o bicicletário, o outro componente vital é uma usina atômica, acho que isso ilustra a idade do livro.

Parkinson mostra como você pode entrar na diretoria e obter aprovação para a construção de uma usina de energia atômica multimilionária ou mesmo bilionária, mas se você quiser construir um galpão de bicicleta, você ficará envolvido em discussões intermináveis.

Parkinson explica que isso ocorre porque uma usina atômica é tão vasta, tão cara e tão complicada que as pessoas não conseguem entendê-la e, em vez de tentar, recuam supondo que alguém tenha verificado todos os detalhes antes de chegar tão longe. Richard P. Feynmann dá alguns exemplos interessantes, e muito importantes, relacionados a Los Alamos em seus livros.

Uma bicicletário por outro lado. Qualquer um pode construir um desses em um fim de semana e ainda ter tempo de assistir ao jogo na TV. Portanto, não importa o quão bem preparado, não importa o quão razoável você é com a sua proposta, alguém vai aproveitar a chance de mostrar que ele está fazendo o seu trabalho, que ele está prestando atenção, que ele está _aqui_.

Na Dinamarca, chamamos de "definindo sua identidade". É sobre orgulho pessoal e prestígio, é sobre poder apontar para algum lugar e dizer "Lá! _Eu_ fiz aquilo. " É um traço forte nos políticos, mas presente na maioria das pessoas que têm chance. Basta pensar em passos em cimento molhado.

== Coisas legais do FreeBSD

=== Quão legal é o FreeBSD?

[qanda]
Alguém fez algum teste de temperatura durante a execução do FreeBSD? Eu sei que o Linux(TM) é mais legal que o DOS, mas nunca vi uma menção ao FreeBSD. Parece ser muito rápido.::

Não, mas fizemos numerosos testes de gostos em voluntários vendados que também receberam 250 microgramas de LSD-25 administrados antecipadamente. 35% dos voluntários disseram que o FreeBSD tinha um gosto de um tipo de laranja, enquanto o Linux(TM) tinha gosto de névoa roxa. Nenhum dos grupos mencionou variações significativas na temperatura. Eventualmente nós tivemos que lançar os resultados desta pesquisa completamente de qualquer maneira quando descobrimos que muitos voluntários estavam vagando fora da sala durante os testes, assim distorcendo os resultados. Nós achamos que a maioria dos voluntários está na Apple agora, trabalhando em sua nova GUI "risca e arrisca". É um negócio antigo e engraçado em que estamos!

Sério, o FreeBSD usa a instrução HLT (halt) quando o sistema está ocioso, reduzindo assim seu consumo de energia e, portanto, o calor gerado. Além disso, se você tiver ACPI (Configuração Avançada e Interface de Energia) configurado, então o FreeBSD também pode colocar a CPU em um modo de baixa energia.

=== Quem está coçando nos meus bancos de memória??

[qanda]
Existe alguma coisa "estranha" que o FreeBSD faz ao compilar o kernel que faria com que a memória fizesse um som de algo coçando? Ao compilar (e por um breve momento depois de reconhecer o drive de disquete na inicialização também), um estranho som de algo coçando emana do que parecem ser os bancos de memória.::

Sim! Você verá referências freqüentes a "daemons" na documentação do BSD, e o que a maioria das pessoas não sabe é que isso se refere a entidades genuínas e não corporais que agora possuem seu computador. O som áspero vindo de sua memória é, na verdade, um sussurro agudo entre os daemons, pois eles decidem como lidar com várias tarefas de administração do sistema.

Se o ruído chegar até você, um bom `fdisk/mbr` do DOS irá se livrar deles, mas não fique surpreso se eles reagirem negativamente e tentarem pará-lo. Na verdade, se em algum momento durante o exercício você ouvir a voz satânica de Bill Gates vindo do alto-falante embutido, saia correndo e não olhe para trás! Livres da influência contrabalançadora dos daemons BSD, os demônios gêmeos do DOS e Windows(TM) são frequentemente capazes de reafirmar o controle total sobre sua máquina para a danação eterna de sua alma. Agora que você sabe, dada uma escolha, você provavelmente preferiria se acostumar com os ruídos ásperos, não?

=== Quantos hackers do FreeBSD são necessários para trocar uma lâmpada?

Mil, cento e sessenta e nove:

Vinte e três para reclamar com -CURRENT sobre as luzes estarem apagadas;

Quatro para afirmar que trata-se de um problema de configuração e que tais questões realmente pertencem a -questions;

Três para enviar PRs sobre o assunto, uma das quais está arquivada sob doc e consiste apenas da declaração "está escuro";

Um para cometer uma lâmpada não testada que quebra o buildworld, e depois retorna cinco minutos depois;

Oito para chamar os remetentes de RP por não incluir patches em seus PRs;

Cinco para reclamar sobre o buildworld sendo quebrado;

Trinta e um para responder que funciona para eles, e eles devem ter atualizado em um momento ruim;

Um para postar um patch para uma nova luz para -hackers;

Um para reclamar que ele tinha patches para isso há três anos, mas quando ele os enviou para -CURRENT eles foram ignorados, e ele teve más experiências com o sistema de PRs; além disso, a nova luz proposta não é reflexiva;

Trinta e sete para gritar que essa luz não pertencem ao sistema básico, que os committers não têm o direito de fazer coisas assim sem consultar a Comunidade, e O QUE O -CORE ESTÁ FAZENDO SOBRE ISSO!?

Duzentos para reclamar da cor do bicicletário;

Três para salientar que o patch quebra o man:style[9];

Dezessete para reclamar que a nova luz proposta está sob a GPL;

Quinhentos e oitenta e seis para iniciar uma guerra contra as vantagens comparativas da GPL, da licença da BSD, da licença do MIT, da NPL e da higiene pessoal dos fundadores da FSF, que não são nomeados;

Sete para mover várias partes do segmento para -chat e -vocacy;

Um para comitar a luz sugerida, mesmo que ela seja mais escura que a antiga;

Dois para recuar com uma chama furiosa de uma mensagem de commit, argumentando que o FreeBSD está melhor no escuro do que com uma lâmpada fraca;

Quarenta e seis para argumentar veementemente sobre o apoio da luz fraca e exigir uma declaração do alto desempenho;

Onze para solicitar uma lâmpada menor para que ela caiba em seu Tamagotchi se decidirmos portar o FreeBSD para essa plataforma;

Setenta e três para reclamar sobre o SNR em -chackers e -chat e cancelar a inscrição em protesto;

Treze para postar "cancelar a inscrição", " Como posso cancelar a inscrição? ", ou "Por favor, remova-me da lista", seguido do rodapé habitual;

Um para comitar uma lâmpada de trabalho enquanto todos estão ocupados demais chamando a atenção de todos os outros para esse commit;

Trinta e um para salientar que a nova lâmpada iria brilhar 0,364% a mais se compilada com TenDRA (embora tenha que ser reformulada em um cubo), e que o FreeBSD deve, portanto, mudar para TenDRA ao invés de GCC;

Um para reclamar que a nova lâmpada não tem carenagem;

Nove (incluindo os criadores de PRs) para perguntar "o que é o MFC?";

Cinquenta e sete para se queixar das luzes apagadas duas semanas depois de a lâmpada ter sido trocada.

_Nik Clayton_ mailto:nik@FreeBSD.org[nik@FreeBSD.org] acrescenta: 

_Eu estava rindo bastante disso._

_E então eu pensei, " Espere, não deveria haver '1 para documentar isso.' nessa lista em algum lugar? "_

_E então eu fui iluminado :-)_

_Thomas Abthorpe_ mailto:tabthorpe@FreeBSD.org[tabthorpe@FreeBSD.org] diz: " Nenhum, um hacker _real_ do FreeBSD não têm medo do escuro! "

=== Onde os dados gravados em /dev/null vão parar?

Ele entra em um coletor de dados especial na CPU, onde é convertido em calor que é ventilado através do conjunto do dissipador de calor / ventilador. É por isso que o resfriamento da CPU é cada vez mais importante; À medida que as pessoas se acostumam com processadores mais rápidos, elas se tornam descuidadas com seus dados e mais e mais delas acabam no [.filename]#/dev/null#, superaquecendo suas CPUs. Se você apagar [.filename]#/dev/null# (o que efetivamente desativa o dissipador de dados da CPU) sua CPU pode ficar mais fria, mas seu sistema rapidamente ficará constipado com todos esses dados em excesso e começará a se comportar de maneira irregular. Se você tem uma conexão de rede rápida, pode resfriar sua CPU lendo dados de [.filename]#/dev/random# e enviá-los para algum lugar; No entanto, você corre o risco de superaquecer sua conexão de rede e [.filename]#/# ou irritar seu ISP, pois a maioria dos dados acabará sendo convertida em calor pelo equipamento, mas eles geralmente têm um bom resfriamento, então se você não exagere você deve estar bem.

_Paul Robinson acrescenta:_

Existem outros métodos. Como todo bom administrador de sistemas sabe, é parte da prática padrão enviar dados para a tela de variedade interessante para manter todos os pixies que compõem sua imagem felizes. Os duendes de tela (comumente com erros de digitação ou renomeados como "pixels") são categorizados pelo tipo de chapéu que usam (vermelho, verde ou azul) e serão ocultados ou exibidos (mostrando a cor do chapéu ) sempre que recebem um pequeno pedaço de comida. Placas de vídeo transformam dados em comida de duende, e então os enviam para os duendes - quanto mais cara a carta, melhor a comida, então é melhor que os pixies se comportem melhor. Eles também precisam de estímulo constante - é por isso que existem proteções de tela.

Para levar suas sugestões adiante, você poderia simplesmente jogar os dados aleatórios no console, permitindo que os duendes os consumam. Isso faz com que nenhum calor seja produzido, mantém os pixies felizes e se livra de seus dados rapidamente, mesmo que isso faça as coisas parecerem um pouco confusas na sua tela.

Incidentalmente, como um ex-administrador de um grande ISP que teve muitos problemas ao tentar manter uma temperatura estável em uma sala de servidores, eu desencorajaria fortemente as pessoas que enviam os dados que não querem para a rede. As fadas que fazem a troca e o encaminhamento de pacotes também se irritam com isso.

=== Minha colega fica muito no computador, como eu posso brincar com ela?

Instale o package:games/sl[] e espere ela digitar `sl` para `ls`.

== Tópicos Avançados

=== Como posso aprender mais sobre os componentes internos do FreeBSD?

Veja o link:{arch-handbook}[ Handbook de Arquitetura do FreeBSD ].

Além disso, muito do conhecimento geral sobre o UNIX(TM) é diretamente aplicável ao FreeBSD.

=== Como posso contribuir para o FreeBSD? O que posso fazer para ajudar?

Nós aceitamos todos os tipos de contribuições: documentação, código e até mesmo arte. Veja o artigo link:{contributing}[Contribuindo com o FreeBSD] para obter maiores informações sobre como fazer isso.

E obrigado por considerar nos ajudar!

=== O que são Snapshots e Releases?

Atualmente existem 3 branches ativas/semi-ativas no http://svnweb.FreeBSD.org/base/[Repositório Subversion] do FreeBSD. (Os branches anteriores são alterados muito raramente, e é por isso que existem apenas 3 branches ativas de desenvolvimento):

* stable/11/ AKA _11-STABLE_
* stable/12/ AKA _12-STABLE_
* head/ AKA _-CURRENT_ AKA _13-CURRENT_

`HEAD` não é uma tag de branch real. É uma constante simbólica para o fluxo de desenvolvimento atual, não ramificado, conhecido como _-CURRENT_.

No momento, o _-CURRENT_ é o fluxo de desenvolvimento 13._X_; o branch _12-STABLE_, stable/12/, derivou do _-CURRENT_ em Dezembro de 2018 e o branch ​​_11-STABLE_,stable/11/, derivou do _-CURRENT_ em Outubro de 2016.

=== Como posso aproveitar ao máximo os dados que vejo quando meu kernel entra em panic?

Aqui está um panic típico do kernel:

[.programlisting]
....
Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault
....

Esta mensagem não é suficiente. Embora o valor do ponteiro de instrução seja importante, ele também depende da configuração, pois varia dependendo da imagem do kernel. Se for uma imagem de kernel [.filename]#GENERIC# de um dos snapshots, é possível que alguém rastreie a função problemática, mas para um kernel personalizado, somente você pode nos dizer onde a falha ocorreu.

Para prosseguir:

[.procedure]
====
. Anote o valor do ponteiro de instrução. Note que a parte `0x8:` no começo não é relevante neste caso: é a parte `0xf0xxxxxx` que nós queremos.
. Quando o sistema for reinicializado, faça o seguinte:
+
[source,bash]
....
% nm -n kernel.that.caused.the.panic | grep f0xxxxxx
....
+ 
no qual `f0xxxxxx` é o valor do ponteiro de instrução. As probabilidades são de que você não obterá uma correspondência exata, pois os símbolos na tabela de símbolos do kernel são para os pontos de entrada das funções e o endereço do ponteiro de instrução estará em algum lugar dentro de uma função, não no início. Se você não obtiver uma correspondência exata, omita o último dígito do valor do ponteiro de instrução e tente novamente:
+
[source,bash]
....
% nm -n kernel.that.caused.the.panic | grep f0xxxxx
....
+ 
Se isso não produzir nenhum resultado, corte outro dígito. Repita até que haja algum tipo de saída. O resultado será uma possível lista das funções que causaram o panic. Este é um mecanismo menos do que exato para rastrear o ponto de falha, mas é melhor do que nada.
====

No entanto, a melhor maneira de rastrear a causa de um panic é capturar um despejo de memória e usar o man:kgdb[1] para gerar um rastreamento de pilha no despejo de memória.

Em qualquer caso, o método é este:

[.procedure]
====

. Certifique-se de que a seguinte linha esteja incluída no arquivo de configuração do kernel:
+
[.programlisting]
....
makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols
....
+
. Mude para o diretório [.filename]#/usr/src#:
+
[source,bash]
....
# cd /usr/src
....
+
. Compile o kernel:
+
[source,bash]
....
# make buildkernel KERNCONF=MYKERNEL
....
+
. Aguarde até o man:make[1] terminar a compilação.
+
[source,bash]
....
# make installkernel KERNCONF=MYKERNEL
....
+
. Reinicie.
====

[NOTE]
====
Se a variável `KERNCONF` não for informada na linha de comando, o kernel [.filename]#GENERIC# será compilado e instalado.
====

O processo man:make[1] terá compilado dois kernels. O [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel# e o [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel.debug#. O [.filename]#kernel# foi instalado como [.filename]#/boot/kernel/kernel#, enquanto o [.filename]#kernel.debug# pode ser usado como fonte de símbolos de depuração para o man:kgdb[1].

Para capturar um despejo de memória, edite o [.filename]#/etc/rc.conf# e defina o `dumpdev` para apontar para a partição de swap ou para `AUTO`. Isso fará com que os scripts man:rc[8] usem o comando man:dumpon[8] para ativar os despejos de memória. Este comando também pode ser executado manualmente. Após um panic, o despejo de memória pode ser recuperado usando o man:savecore[8]; se o `dumpdev` estiver configurado em [.filename]#/etc/rc.conf#, os scripts man:rc[8] executarão o man:savecore[8] automaticamente e colocarão o despejo de memória em [.filename]#/var/crash#.

[NOTE]
====
Os despejos de memória do FreeBSD são geralmente do mesmo tamanho que a RAM física. Portanto, verifique se há espaço suficiente em [.filename]#/var/crash# para manter o despejo. Como alternativa, execute man:savecore[8] manualmente e faça com que recupere o despejo de memória para outro diretório com mais espaço. É possível limitar o tamanho do despejo de memória usando `options MAXMEM=N` onde _N_ é o tamanho da memória utilizada do kernel em KBs. Por exemplo, para 1 GB de RAM, limite o uso de memória pelo kernel a 128 MB, para que o tamanho do despejo de memória seja de 128 MB em vez de 1 GB.
====

Depois que o despejo de memória for recuperado, obtenha um rastreamento de pilha da seguinte maneira:

[source,bash]
....
% kgdb /usr/obj/usr/src/sys/MYKERNEL/kernel.debug /var/crash/vmcore.0
(kgdb) backtrace
....

Note que pode haver várias telas de informação valiosa. Idealmente, use man:script[1] para capturar todas elas. Usar a imagem do kernel unstripped com todos os símbolos de depuração deve mostrar a linha exata do código fonte do kernel onde o panic ocorreu. O rastreamento de pilha geralmente é lido de baixo para cima para rastrear a sequência exata de eventos que levam à falha. O man:kgdb[1] também pode ser usado para imprimir o conteúdo de várias variáveis ​​ou estruturas para examinar o estado do sistema no momento da falha.

[TIP]
====

Se um segundo computador estiver disponível, o man:kgdb[1] pode ser configurado para fazer uma depuração remota, incluindo pontos de interrupção de configuração e passos únicos através do código do kernel.
====

[NOTE]
====
Se o `DDB` estiver habilitado e o kernel cair no depurador, um panic e um despejo de memória podem ser forçados digitando `panic` no prompt do `ddb`. O processo pode parar no depurador novamente durante a fase de panic. Se isso acontecer, digite `continue` e ele concluirá o despejo de memória.
====

=== Por que dlsym() parou de funcionar para executáveis ​​ELF?

A toolchain ELF não faz, por padrão, os símbolos definidos em um executável visíveis para o vinculador dinâmico. Consequentemente, a busca da função `dlsym()` por identificadores obtidos de chamadas para `dlopen(NULL, flags)` não conseguirá encontrar tais símbolos.

Para pesquisar, usando a função `dlsym()`, os símbolos presentes no executável principal de um processo, vincule o executável usando a opção `- export-dynamic` ao vinculador ELF (man:ld[1]).

=== Como posso aumentar ou reduzir o espaço de endereçamento do kernel em uma máquina i386?

Por padrão, o espaço de endereço do kernel é de 1 GB (2 GB para PAE) para a arquitetura i386. Se você estiver executando um servidor com uso intensivo de rede ou utilizando o ZFS, isso provavelmente não será suficiente.

Adicione a seguinte linha ao arquivo de configuração do kernel para aumentar o espaço disponível e recompile o kernel:

[.programlisting]
....
options KVA_PAGES=N
....

Para encontrar o valor correto de _N_, divida o tamanho do espaço de endereço desejado (em megabytes) por quatro. (Por exemplo, é `512` para 2 GB.)

== Agradecimentos

Este inocente documento de Perguntas Frequentes foi escrito, reescrito, editado, dobrado, fustigado, mutilado, eviscerado, contemplado, desconcertado, cogitado, regurgitado, reconstruído, castigado e revigorado na última década, por um elenco de centenas, se não milhares de voluntários. Repetidamente.

Gostaríamos de agradecer a cada uma das pessoas responsáveis, e nós o encorajamos a link:{contributing}[se juntar a eles] para tornar este FAQ  ainda melhor.
