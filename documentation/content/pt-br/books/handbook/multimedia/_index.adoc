---
title: Capítulo 7. Multimídia
part: Parte II. Tarefas comuns
prev: books/handbook/desktop
next: books/handbook/kernelconfig
---

[[multimedia]]
= Multimídia
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Índice
:table-caption: Tabela
:figure-caption: Figura
:example-caption: Exemplo
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 7

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/pt-br/mailing-lists.adoc[]
include::shared/pt-br/teams.adoc[]
include::shared/pt-br/urls.adoc[]

toc::[]

[[multimedia-synopsis]]
== Sinopse

O FreeBSD suporta uma ampla variedade de placas de som, permitindo que os usuários aproveitem a saída de alta fidelidade de um sistema FreeBSD. Isso inclui a capacidade de gravar e reproduzir áudio MPEG Layer 3 (MP3), arquivo de áudio Waveform (WAV), Ogg Vorbis e outros formatos. A coleção de Ports do FreeBSD contém muitas aplicações para editar áudio gravado, adicionar efeitos sonoros e controlar dispositivos MIDI conectados.

O FreeBSD também suporta a reprodução de arquivos de vídeo e DVDs. A coleção de Ports do FreeBSD contém aplicativos para codificar, converter e reproduzir várias mídias de vídeo.

Este capítulo descreve como configurar placas de som, reprodução de vídeo, placas sintonizadoras de TV e scanners no FreeBSD. Também descreve algumas das aplicações que estão disponíveis para usar esses dispositivos.

Depois de ler este capítulo, você irá saber como:

* Configurar uma placa de som no FreeBSD.
* Solucionar problemas de configuração de som.
* Reproduzir e codificar MP3 e outros áudios.
* Preparar um sistema FreeBSD para reprodução de vídeo.
* Reproduzir DVDs, arquivos [.filename]#.mpg# e [.filename]#.avi#.
* Copiar o conteúdo de um CD ou DVD em arquivos arquivos.
* Configurar uma placa de TV.
* Instale e configure o MythTV no FreeBSD
* Configurar um scanner de imagem.
* Configurar um headset Bluetooth.

Antes de ler este capítulo, você deve:

* Saber como instalar aplicativos conforme descrito em crossref:ports[ports, Instalando Aplicativos. Pacotes e Ports].

[[sound-setup]]
== Configurando a Placa de Som

Antes de iniciar a configuração, determine o modelo da placa de som e o chip usado. O FreeBSD suporta uma ampla variedade de placas de som. Verifique a lista de dispositivos de áudio compatíveis nas https://www.FreeBSD.org/releases/12.0r/hardware/[Notas de Hardware], para ver se a placa de som é suportada e quais drivers do FreeBSD que ela usa.

Para usar um dispositivo de som, seu driver deve ser carregado. A maneira mais fácil é carregar o módulo do kernel para a placa de som com o man:kldload[8]. Este exemplo carrega o driver para um chipset de áudio integrado baseado na especificação Intel:

[source,bash]
....
# kldload snd_hda
....

Para automatizar o carregamento desse driver no momento da inicialização, faça edição adicionando a seguinte linha ao arquivo [.filename]#/boot/loader.conf#:

[.programlisting]
....
snd_hda_load="YES"
....

Outros módulos de som disponíveis estão listados no arquivo [.filename]#/boot/defaults/loader.conf#. Quando não tiver certeza de qual driver usar, carregue o módulo [.filename]#snd_driver#:

[source,bash]
....
# kldload snd_driver
....

Este é um metadriver que carrega todos os drivers de som mais comuns e pode ser usado para acelerar a busca pelo driver correto. Também é possível carregar todos os drivers de som adicionando o metadriver no arquivo [.filename]#/boot/loader.conf#.

Para determinar qual driver foi selecionado para a placa de som após carregar o metadriver [.filename]#snd_driver#, digite, `cat /dev/sndstat`.

=== Configurando um kernel Personalizado com Suporte de Som

Esta seção é para usuários que preferem compilar estaticamente em suporte para a placa de som em um kernel personalizado. Para mais informações sobre como recompilar um kernel, consulte crossref:kernelconfig[kernelconfig, Configurando o kernel do FreeBSD].

Ao usar um kernel personalizado para fornecer suporte ao som, verifique se o driver do framework de áudio existe no arquivo de configuração do kernel personalizado:

[.programlisting]
....
device sound
....

Em seguida, adicione suporte para a placa de som. Para continuar o exemplo do chipset de áudio integrado baseado na especificação Intel da seção anterior, use a seguinte linha no arquivo de configuração do kernel personalizado:

[.programlisting]
....
device snd_hda
....

Certifique-se de ler a página de manual do driver para o nome do dispositivo a ser usado pelo driver.

Placas de som ISA não-PnP podem requerer que as configurações de porta IRQ e I/O da placa sejam adicionadas ao arquivo [.filename]#/boot/device.hints#. Durante o processo de inicialização, o man:loader[8] lê este arquivo e passa as configurações para o kernel. Por exemplo, uma placa antiga ISA não-PnP da Creative SoundBlaster(TM) usará o driver man:snd_sbc[4] em conjunto com `snd_sb16`. Para esta placa, as seguintes linhas devem ser adicionadas ao arquivo de configuração do kernel:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

Se a placa usar a porta de I/O `0x220` e a IRQ `5`, essas linhas também deverão ser adicionadas ao arquivo [.filename]#/boot/device.hints#:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

A sintaxe usada no arquivo [.filename]#/boot/device.hints# é descrita em man:sound[4] e na página de manual do driver da placa de som.

As configurações mostradas acima são os padrões. Em alguns casos, a IRQ ou outras configurações podem precisar ser alterados para corresponder à placa. Consulte man:snd_sbc[4] para obter mais informações sobre esta placa.

[[sound-testing]]
=== Testando o Som

Depois de carregar o módulo necessário ou reinicializar no kernel personalizado, a placa de som deve ser detectada. Para confirmar, execute `dmesg | grep pcm`. Este exemplo é de um sistema com um chipset integrado Conexant CX20590:

[source,bash]
....
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 5 on hdaa0
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 6 on hdaa0
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> at nid 31,25 and 35,27 on hdaa1
....

O status da placa de som também pode ser verificado usando este comando:

[source,bash]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm: 64bit 2009061500/amd64)
Installed devices:
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> (play/rec) default
....

A saída irá variar dependendo da placa de som. Se nenhum dispositivo [.filename]#pcm# estiver listado, verifique se o driver de dispositivo correto foi carregado ou compilado no kernel. A próxima seção lista alguns problemas comuns e suas soluções.

Se tudo correr bem, a placa de som deverá funcionar no FreeBSD. Se a unidade de CD ou DVD estiver corretamente conectada à placa de som, é possível inserir um CD de áudio na unidade e reproduzi-lo com man:cdcontrol[1]:

[source,bash]
....
% cdcontrol -f /dev/acd0 play 1
....

[WARNING]
====

CD de audio têm codificações especializadas, o que significa que não devem ser montados usando man:mount[8].
====

Várias aplicações, como package:audio/workman[], fornecem uma interface mais amigável. O Port package:audio/mpg123[] pode ser instalado para ouvir arquivos de áudio MP3.

Outra maneira rápida de testar a placa é enviar dados para [.filename]#/dev/dsp#:

[source,bash]
....
% cat filename > /dev/dsp
....

onde [.filename]#filename# pode ser qualquer tipo de arquivo. Este comando deve produzir algum ruído, confirmando que a placa de som está funcionando.

[NOTE]
====
Os nós de dispositivo [.filename]#/dev/dsp*# serão criados automaticamente conforme necessário. Quando não estão em uso, eles não existem e não aparecerão na saída de man:ls[1].
====

[[bluetooth-headset]]
=== Configurando Dispositivos de Som Bluetooth

Conectar a um dispositivo Bluetooth está fora do escopo deste capítulo. Consulte a crossref:advanced-networking[network-bluetooth,Bluetooth] para mais informações.

Para que o dispositivo Bluetooth funcione com o sistema de som do FreeBSD, os usuários precisam primeiramente instalar o package:audio/virtual_oss[]:

[source,bash]
....
# pkg install virtual_oss
....

package:audio/virtual_oss[] requer `cuse` para ser carregado no kernel:

[source,bash]
....
# kldload cuse
....

Para carregar o `cuse` durante a inicialização do sistema, execute o comando:

[source,bash]
....
# sysrc -f /boot/loader.conf cuse_load=yes
....

Para usar fones de ouvido como reprodutor de som com package:audio/virtual_oss[], os usuários precisam criar um dispositivo virtual depois de se conectarem a um dispositivo de áudio Bluetooth:

[source,bash]
....
# virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp
....

[NOTE]
====
_headphones_ neste exemplo é o nome de host de [.filename]#/etc/bluetooth/hosts#. `BT_ADDR` também poderia ser usado.
====

Consulte man:virtual_oss[8] para mais informações.

[[troubleshooting]]
=== Solução de Problemas de Som

<<multimedia-sound-common-error-messages>> lista algumas mensagens de erros comuns e suas soluções:

[[multimedia-sound-common-error-messages]]
.Mensagens de Erros Comuns
[cols="1,1", frame="none", options="header"]
|===
| Erro
| Solução

|`sb_dspwr(XX) timed out`
|

A porta de I/O não está configurada corretamente.

|`bad irq XX`
|

A IRQ está definida incorretamente. Certifique-se de que a IRQ definido e a IRQ do som são as mesmas.

|`xxx: gus pcm not attached, out of memory`
|

Não há memória disponível suficiente para usar o dispositivo.

|`xxx: can't open /dev/dsp!`
|

Digite `fstat \| grep dsp` para verificar se outro aplicativo está mantendo o dispositivo aberto. Os causadores de problemas notáveis são o suporte a som do esound e do KDE.
|===

Placas gráficas modernas geralmente vêm com seu próprio driver de som para uso com HDMI. Às vezes, esse dispositivo de som é enumerado antes da placa de som, o que significa que a placa de som não será usada como o dispositivo de reprodução padrão. Para verificar se este é o caso, execute dmesg e procure por `pcm`. A saída é algo como isto:

[.programlisting]
....
...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 0 nid 1 on hdac0
pcm1: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 1 nid 1 on hdac0
pcm2: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 2 nid 1 on hdac0
pcm3: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: <HDA Realtek ALC889 PCM #0 Analog> at cad 2 nid 1 on hdac1
pcm5: <HDA Realtek ALC889 PCM #1 Analog> at cad 2 nid 1 on hdac1
pcm6: <HDA Realtek ALC889 PCM #2 Digital> at cad 2 nid 1 on hdac1
pcm7: <HDA Realtek ALC889 PCM #3 Digital> at cad 2 nid 1 on hdac1
...
....

Neste exemplo, a placa gráfica (`NVidia`) foi enumerada antes da placa de som (`Realtek ALC889`). Para usar a placa de som como o dispositivo de reprodução padrão, altere a variável `hw.snd.default_unit` para a unidade que deve ser usada para reprodução:

[source,bash]
....
# sysctl hw.snd.default_unit=n
....

onde `n` é o número do dispositivo de som a ser usado. Neste exemplo, deve ser `4`. Deixe esta mudança permanente adicionando a seguinte linha ao arquivo [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
hw.snd.default_unit=4
....

[[sound-multiple-sources]]
=== Utilizando Múltiplas Fontes de Som

Muitas vezes é desejável ter várias fontes de som capazes de tocar simultaneamente. O FreeBSD usa "Canais de Som Virtuais" para multiplexar a reprodução da placa de som mixando o som no kernel.

Três variáveis no man:sysctl[8] estão disponíveis para configurar canais virtuais:

[source,bash]
....
# sysctl dev.pcm.0.play.vchans=4
# sysctl dev.pcm.0.rec.vchans=4
# sysctl hw.snd.maxautovchans=4

....

Este exemplo aloca quatro canais virtuais, que é um número prático para o uso diário. Ambos `dev.pcm.0.play.vchans=4` e `dev.pcm.0.rec.vchans=4` são configuráveis depois que um dispositivo foi anexado e representa o número de canais virtuais [.filename]#pcm0# para reprodução e gravação. Como o módulo [.filename]#pcm# pode ser carregado independentemente dos drivers de hardware, `hw.snd.maxautovchans` indica quantos canais virtuais serão dados a um dispositivo de áudio quando ele estiver conectado. Consulte man:pcm[4] para obter mais informações.

[NOTE]
====
O número de canais virtuais para um dispositivo não pode ser alterado enquanto estiver em uso. Primeiramente, feche todos os programas usando o dispositivo, como players de música ou daemons de som.
====

O dispositivo [.filename]#pcm# correto será automaticamente alocado de forma transparente para um programa que solicite [.filename]#/dev/dsp0#.

=== Configurando Valores Padrões para Canais de Mixer

Os valores padrões para os diferentes canais do mixer são codificados permanentemente no código-fonte do driver man:pcm[4]. Embora os níveis do mixer da placa de som possam ser alterados usando man:mixer[8] ou aplicativos e daemons de terceiros, essa não é uma solução permanente. Para definir os valores padrões do mixer no nível do driver, defina os valores apropriados no arquivo [.filename]#/boot/device.hints#, conforme mostrado neste exemplo:

[.programlisting]
....
hint.pcm.0.vol="50"
....

Isso definirá o canal de volume como um valor padrão de `50` quando o módulo man:pcm[4] for carregado.

[[sound-mp3]]
== Áudio MP3

Esta seção descreve alguns players MP3 disponíveis para o FreeBSD, como ripar trilhas de CD de áudio e como codificar e decodificar MP3.

[[mp3-players]]
=== Players de MP3

Um popular reprodutor gráfico de MP3 é o Audacious. Ele suporta skins do Winamp e plugins adicionais. A interface é intuitiva, com uma lista de reprodução, equalizador gráfico e muito mais. Para aqueles que estão familiarizados com o Winamp, acharão o Audacious simples de usar. No FreeBSD, o Audacious pode ser instalado a partir de pacotes ou coleção de Ports package:multimedia/audacious[]. Audacious é descendente do XMMS.

O pacote ou Port package:audio/mpg123[] fornece um reprodutor de MP3 alternativo em linha de comando. Uma vez instalado, especifique o arquivo MP3 para reproduzir na linha de comando. Se o sistema tiver vários dispositivos de áudio, o dispositivo de som também pode ser especificado:

[source,bash]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layers 1, 2 and 3
        version 1.18.1; written and copyright by Michael Hipp and others
        free software (LGPL) without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

Outros players MP3 estão disponíveis na Coleção de Ports do FreeBSD.

[[rip-cd]]
=== Copiando Trilhas de CD de Áudio

Antes de codificar um CD ou CD para MP3, os dados de áudio no CD devem ser copiados para o disco rígido. Isso é feito copiando os dados brutos do CD Digital Audio (CDDA) como arquivos WAV.

A ferramenta `cdda2wav`, que é instalada com o suite de programas package:sysutils/cdrtools[], pode ser usada para extrair informações de áudio do CD.

Com o CD de áudio na unidade, o seguinte comando pode ser executado como `root` para ripar um CD inteiro em arquivos WAV, por trilhas:

[source,bash]
....
# cdda2wav -D 0,1,0 -B
....

Neste exemplo, o `-D _0,1,0_` indica o dispositivo SCSI [.filename]#0,1,0# contendo o CD para ripar. Use o comando `cdrecord -scanbus` para determinar os parâmetros corretos do dispositivo para o sistema.

Para ripar trilhas individuais, use a opção `-t` para especificar a trilha:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 7
....

Para extrair um intervalo de trilhas, como as trilhas de um a sete, especifique um intervalo:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 1+7
....

Para extrair de uma unidade ATAPI(IDE) CDROM, especifique o nome do dispositivo no lugar dos números da unidade SCSI. Por exemplo, para extrair a trilha 7 de uma unidade IDE:

[source,bash]
....
# cdda2wav -D /dev/acd0 -t 7
....

Alternativamente, o comando `dd` pode ser usado para extrair trilhas de áudio em unidades ATAPI, conforme descrito em crossref:disks[duplicating-audiocds,Duplicando CDs de Áudio].

[[mp3-encoding]]
=== Codificação e Decodificação de MP3

Lame é um codificador popular para MP3 que pode ser instalado a partir do port package:audio/lame[]. Devido a problemas de patente, o pacote não está disponível.

O comando a seguir converterá o arquivo WAV [.filename]#audio01.wav# para [.filename]#audio01.mp3#:

[source,bash]
....
# lame -h -b 128 --tt "Foo Song Title" --ta "FooBar Artist" --tl "FooBar Album" \
--ty "2014" --tc "Ripped and encoded by Foo" --tg "Genre" audio01.wav audio01.mp3
....

Os 128 kbits especificados são uma taxa de bits padrão para MP3, enquanto as taxas de bits 160 e 192 fornecem maior qualidade. Quanto maior a taxa de bits, maior o tamanho do arquivo MP3 resultante. A opção `-h` ativa o modo " de maior qualidade, mas um pouco mais lento ". As opções que começam com `--t` indicam as tags ID3, que geralmente contêm informações sobre músicas, para serem incorporadas no arquivo MP3. Opções adicionais de codificação podem ser encontradas na página de manual do lame.

Para gravar um CD de áudio usando arquivos MP3, primeiro estes devem ser convertidos em um formato de arquivo não compactado. O XMMS pode ser usado para converter para o formato WAV, enquanto o mpg123 pode ser usado para converter para o formato de dados de áudio bruto, Pulse Code Modulation (PCM).

Para converter o arquivo [.filename]#audio01.mp3# usando mpg123, especifique o nome do arquivo PCM:

[source,bash]
....
# mpg123 -s audio01.mp3 > audio01.pcm
....

Para usar XMMS para converter um arquivo MP3 para WAV, use esses passos:

[.procedure]
====
*Procedure: Convertendo para o Formato WAV no XMMS*

. Inicie o XMMS.
. Clique com o botão direito do mouse na janela para abrir o menu XMMS.
. Selecione `Preferences` abaixo de `Options`.
. Altere o Plugin de Saída para "Disk Writer Plugin".
. Pressione `Configure`.
. Digite ou procure um diretório para gravar os arquivos descompactados.
. Carregue o arquivo MP3 no XMMS como de costume, com o volume em 100% e as configurações de EQ desativadas.
. Pressione `Play`. O XMMS aparecerá como se estivesse tocando o MP3, mas nenhuma música será ouvida. Na verdade, está tocando o MP3 para um arquivo.
. Quando terminar, certifique-se de ajustar o Plugin de Saída padrão de volta ao que era antes para ouvir MP3 novamente.
====

Os formatos WAV e PCM podem ser usados com cdrecord. Ao usar arquivos WAV, haverá um pequeno som no início de cada trilha. Este som é o cabeçalho do arquivo WAV. O pacote binário ou port package:audio/sox[] pode ser usado para remover o cabeçalho:

[source,bash]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

Consulte crossref:disks[creating-cds,Criando e Usando Mídia em CD] para mais informações sobre o uso de um gravador de CD no FreeBSD.

[[video-playback]]
== Reprodução de Vídeo

Antes de configurar a reprodução de vídeo, determine o modelo e o chipset da placa de vídeo. Embora o Xorg suporte uma ampla variedade de placas de vídeo, nem todas oferecem um bom desempenho de reprodução. Para obter uma lista de extensões suportadas pelo servidor Xorg usando a placa, execute `xdpyinfo` enquanto o Xorg está sendo executado.

É interessante ter um arquivo de teste MPEG pequeno para avaliar vários players e opções. Como alguns aplicativos de DVD procuram por mídia DVD em [.filename]#/dev/dvd# por padrão, ou possuem esse nome de dispositivo codificado neles, pode ser útil fazer um link simbólico para o dispositivo adequado:

[source,bash]
....
# ln -sf /dev/cd0 /dev/dvd
....

Devido à natureza do man:devfs[5], os links criados manualmente não persistirão após a reinicialização do sistema. Para recriar o link simbólico automaticamente quando o sistema inicializar, adicione a seguinte linha ao arquivo [.filename]#/etc/devfs.conf#:

[.programlisting]
....
link cd0 dvd
....

A decriptografia do DVD invoca certas funções que exigem permissão de gravação para o dispositivo DVD.

Para melhorar a interface de memória compartilhada do Xorg, recomenda-se aumentar os valores dessas variáveis man:sysctl[8]:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== Determinando os Recursos de Vídeo

Existem várias maneiras possíveis de exibir vídeo no Xorg e o que funciona é, em grande parte, dependente de hardware. Cada método descrito abaixo terá qualidade variável em diferentes hardwares.

Interfaces de vídeo comuns incluem:

. Xorg: saída normal usando memória compartilhada.
. XVideo: uma extensão para a interface Xorg que permite que o vídeo seja exibido diretamente em objetos que podem ser desenhados através de uma aceleração especial. Esta extensão oferece reprodução de boa qualidade, mesmo em máquinas de baixo custo. A próxima seção descreve como determinar se esta extensão está sendo executada.
. SDL: Simple Directmedia Layer é uma camada de portabilidade para muitos sistemas operacionais, permitindo o desenvolvimento de aplicativos multiplataforma que fazem uso eficiente de som e gráficos. O SDL fornece uma abstração de baixo nível para o hardware, que às vezes pode ser mais eficiente que a interface do Xorg. No FreeBSD, o SDL pode ser instalado usando o pacote ou port package:devel/sdl20[].
. DGA: Direct Graphics Access é uma extensão do Xorg que permite que um programa contorne o servidor Xorg e altere diretamente o quadro de buffer. Como ele depende de um mapeamento de memória de baixo nível, os programas que o utilizam devem ser executados como `root`. A extensão DGA pode ser testada e comparada usando man:dga[1]. Quando o `dga` está em execução, ele altera as cores do display sempre que uma tecla é pressionada. Para sair, pressione kbd:[q].
. SVGAlib: uma camada gráfica de console de baixo nível.

[[video-interface-xvideo]]
==== XVideo

Para verificar se esta extensão está em execução, use `xvinfo`:

[source,bash]
....
% xvinfo
....

O XVideo é suportado pela placa de vídeo se o resultado for semelhante a:

[source,bash]
....
X-Video Extension version 2.2
  screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

Os formatos listados, como YUV2 e YUV12, não estão presentes em todas as implementações do XVideo e sua ausência pode atrapalhar alguns players.

Se o resultado, ao invés disso, se parecer com:

[source,bash]
....
X-Video Extension version 2.2
screen 0
no adaptors present
....

O XVideo provavelmente não é compatível com a placa. Isso significa que será mais difícil para o monitor atender às demandas computacionais de renderização de vídeo, dependendo da placa de vídeo e do processador.

[[video-ports]]
=== Ports e Pacotes Lidando com Vídeo

Esta seção apresenta alguns dos softwares disponíveis na Coleção de Ports do FreeBSD, que podem ser usados para reprodução de vídeo.

[[video-mplayer]]
==== MPlayer e MEncoder

O MPlayer é um reprodutor de vídeo em linha de comando com uma interface gráfica opcional que visa oferecer velocidade e flexibilidade. Outros front-ends gráficos para o MPlayer estão disponíveis na Coleção de Ports do FreeBSD.

O MPlayer pode ser instalado usando o pacote ou port package:multimedia/mplayer[]. Várias opções de compilação estão disponíveis e uma variedade de verificações de hardware ocorre durante o processo de compilação. Por esses motivos, alguns usuários preferem compilar um port ao invés de instalar o pacote.

Ao compilar o port, as opções do menu devem ser revisadas para determinar o tipo de suporte a ser compilado no port. Se uma opção não estiver selecionada, o MPlayer não poderá exibir esse tipo de formato de vídeo. Use as setas e a barra de espaço para selecionar os formatos necessários. Quando terminar, pressione kbd:[Enter] para continuar a compilação e instalação do port.

Por padrão, o pacote ou port construirá o utilitário de linha de comando `mplayer` e o utilitário gráfico `gmplayer`. Para codificar vídeos, compile o port package:multimedia/mencoder[]. Devido a restrições de licenciamento, um pacote não está disponível para o MEncoder.

A primeira vez que o MPlayer for executado, ele criará um arquivo [.filename]#~/.mplayer# no diretório pessoal do usuário. Esse subdiretório contém versões padrões dos arquivos de configurações específicos do usuário.

Esta seção descreve apenas alguns usos comuns. Consulte o mplayer(1) para uma descrição completa de suas inúmeras opções.

Para reproduzir o arquivo [.filename]#testfile.avi#, especifique as interfaces de vídeo com `-vo`, conforme mostrado nos exemplos a seguir:

[source,bash]
....
% mplayer -vo xv testfile.avi
....

[source,bash]
....
% mplayer -vo sdl testfile.avi
....

[source,bash]
....
% mplayer -vo x11 testfile.avi
....

[source,bash]
....
# mplayer -vo dga testfile.avi
....

[source,bash]
....
# mplayer -vo 'sdl:dga' testfile.avi
....

Vale a pena tentar todas essas opções, pois seu relativo desempenho depende de muitos fatores e varia significativamente com o hardware.

Para reproduzir um DVD, substitua [.filename]#testfile.avi# por `dvd://_N_ -dvd-device _DEVICE_`, em que _N_ é o número do título a ser reproduzido e _DEVICE_ é o nó do dispositivo para o DVD. Por exemplo, para reproduzir o filme 3 de [.filename]#/dev/dvd#:

[source,bash]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
O dispositivo padrão de DVD pode ser definido durante a construção do port MPlayer incluindo a opção `WITH_DVD_DEVICE=/path/to/desired/device`. Por padrão, o dispositivo é [.filename]#/dev/cd0#. Mais detalhes podem ser encontrados no [.filename]#Makefile.options# do port.
====

Para parar, pausar, avançar e assim por diante, use uma tecla de atalho. Para ver a lista de atalhos de teclado, execute `mplayer -h` ou leia o mplayer (1).

Opções de reprodução adicionais incluem `-fs -zoom`, que ativa o modo de tela cheia e `-framedrop`, o que ajuda no desempenho.

Cada usuário pode adicionar opções comumente usadas ao seu [.filename]#~/.mplayer/config# assim:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

O `mplayer` pode ser usado para copiar um filme de DVD para um arquivo [.filename]#.vob#. Para gravar o filme em um segundo DVD:

[source,bash]
....
# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd
....

O arquivo de saída, [.filename]#out.vob#, estará no formato MPEG.

Qualquer pessoa que deseje obter um alto nível de experiência com vídeo UNIX(TM) deve consultar http://www.mplayerhq.hu/DOCS/[mplayerhq.hu/DOCS]. Como é tecnicamente informativa, esta documentação deve ser considerada como leitura obrigatória antes de enviar qualquer relatório de bug.

Antes de usar o `mencoder`, é interessante familiarizar-se com as opções descritas em http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html[mplayerhq.hu/DOCS/HTML/en/mencoder.html]. Existem inúmeras maneiras de melhorar a qualidade, diminuir a taxa de bits e alterar os formatos, e algumas dessas opções podem fazer a diferença entre bom ou mau desempenho. Combinações impróprias de opções de linha de comando podem produzir arquivos de saída que não podem ser reproduzidos até mesmo por `mplayer`.

Aqui está um exemplo de uma cópia simples:

[source,bash]
....
% mencoder input.avi -oac copy -ovc copy -o output.avi
....

Para copiar para um arquivo, use `-dumpfile` com o `mplayer`.

Para converter [.filename]#input.avi# para o codec MPEG4 com codificação de áudio MPEG3, primeiro instale o port package:audio/lame[]. Devido a restrições de licenciamento, um pacote não está disponível. Uma vez instalado, digite:

[source,bash]
....
% mencoder input.avi -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi
....

Isso produzirá uma saída reproduzível por aplicativos como `mplayer` e `xine`.

[.filename]#input.avi# pode ser substituído por `dvd://1 -dvd-device /dev/dvd` e executado como `root` para recodificar um filme de DVD diretamente. Como pode levar algumas tentativas para obter o resultado desejado, recomenda-se gravar o arquivo de um filme e trabalhar nele.

[[video-xine]]
==== O Player (reprodutor) de Vídeo xine

O xine é um reprodutor de vídeo com uma biblioteca base reutilizável e um executável modular que pode ser estendido com plug-ins. Pode ser instalado usando o pacote ou port package:multimedia/xine[].

Na prática, o xine requer uma CPU rápida com uma placa de vídeo rápida ou suporte para a extensão XVideo. O player de vídeo xine apresenta melhor desempenho nas interfaces XVideo.

Por padrão, o player xine inicia uma interface gráfica com o usuário. Os menus podem então ser usados para abrir um arquivo específico.

Alternativamente, o xine pode ser executado a partir da linha de comando, especificando o nome do arquivo a ser reproduzido:

[source,bash]
....
% xine -g -p mymovie.avi
....

Consulte http://www.xine-project.org/faq[xine-project.org/faq] para mais informações e dicas de solução de problemas.

[[video-ports-transcode]]
==== As Utilidades do Transcode

O Transcode fornece um conjunto de ferramentas para recodificar arquivos de vídeo e áudio. O Transcode pode ser usado para mesclar arquivos de vídeo ou reparar arquivos quebrados usando ferramentas de linha de comando com interfaces de fluxo stdin/stdout.

No FreeBSD, o Transcode pode ser instalado usando o pacote ou port package:multimedia/transcode[]. Muitos usuários preferem compilar o port, pois fornece um menu de opções de compilação para especificar o suporte e os codecs a serem compilados. Se uma opção não for selecionada, o Transcode não poderá codificar esse formato. Use as setas e a barra de espaço para selecionar os formatos necessários. Quando terminar, pressione kbd:[Enter] para continuar a compilação e instalação do port.

Este exemplo demonstra como converter um arquivo DivX em um arquivo PAL MPEG-1 (PAL VCD):

[source,bash]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

O arquivo MPEG resultante, [.filename]#output_vcd.mpg#, está pronto para ser executado com o MPlayer. O arquivo pode ser gravado em uma mídia (CD), para criar um CD de vídeo usando um utilitário como package:multimedia/vcdimager[] ou package:sysutils/cdrdao[].

Além da página de manual do `transcode`, consulte http://www.transcoding.org/cgi-bin/transcode[transcoding.org/cgi-bin/transcode] para mais informações e exemplos.

[[tvcard]]
== Placas de TV

As placas de TV podem ser usadas para assistir à transmissão ou à TV a cabo em um computador. A maioria das placas aceitam vídeo composto por meio de uma entrada RCA ou S-video e algumas placas incluem um sintonizador de rádio FM.

O FreeBSD fornece suporte para placas de TV baseadas em PCI usando um chip de captura de vídeo Brooktree Bt848/849/878/879 com o driver man:bktr[4]. Este driver suporta a maioria das placas de vídeo Pinnacle PCTV. Antes de comprar uma placa de TV, consulte man:bktr[4] para obter uma lista dos sintonizadores suportados.

=== Carregando o Driver

Para usar a placa, o driver man:bktr[4] deve ser carregado. Para automatizar isso no momento da inicialização, adicione a seguinte linha ao arquivo [.filename]#/boot/loader.conf#:

[.programlisting]
....
bktr_load="YES"
....

Como alternativa, pode-se compilar estaticamente o suporte para a placa de TV em um kernel personalizado. Nesse caso, adicione as seguintes linhas ao arquivo de configuração do kernel personalizado:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

Esses dispositivos adicionais são necessários, pois os componentes da placa são interconectados por meio de um barramento I2C. Em seguida, crie e instale um novo kernel.

Para testar se o sintonizador foi detectado corretamente, reinicialize o sistema. A placa de TV deve aparecer nas mensagens de inicialização, conforme mostrado neste exemplo:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

As mensagens serão diferentes de acordo com o hardware. Se necessário, é possível substituir alguns dos parâmetros detectados usando man:sysctl[8] ou opções de configuração de kernel personalizadas. Por exemplo, para forçar o sintonizador a usar um sintonizador SECAM da Philips, adicione a seguinte linha a um arquivo de configuração de kernel personalizado:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

ou, use man:sysctl[8]:

[source,bash]
....
# sysctl hw.bt848.tuner=6
....

Consulte man:bktr[4] para obter uma descrição disponível dos parâmetros do man:sysctl[8] e opções do kernel.

=== Aplicações Úteis

Para usar a placa de TV, instale um dos seguintes aplicativos:

* package:multimedia/fxtv[] oferece recursos de captura de imagem/áudio/vídeo numa transmissão de TV no monitor do computador.
* O package:multimedia/xawtv[] é outro aplicativo de TV com recursos semelhantes.
* O package:audio/xmradio[] fornece uma aplicação para usar o sintonizador de rádio FM de uma placa de TV.

Mais aplicações estão disponíveis na Coleção de Ports do FreeBSD.

=== Solução de problemas

Se forem encontrados problemas com a placa de TV, verifique se o chip de captura de vídeo e o sintonizador são compatíveis com man:bktr[4] e que as opções corretas de configuração foram usadas. Para obter mais suporte ou para fazer perguntas sobre as placas de TV suportadas, consulte a lista de discussão http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia[freebsd-multimedia].

[[mythtv]]
== MythTV

MythTV é um popular aplicativo de gravação de vídeo pessoal (PVR). Esta seção demonstra como instalar e configurar o MythTV no FreeBSD. Consulte http://www.mythtv.org/wiki/[mythtv.org/wiki] para mais informações sobre como usar o MythTV.

MythTV requer um frontend e um backend. Esses componentes podem ser instalados no mesmo sistema ou em máquinas diferentes.

O frontend pode ser instalado no FreeBSD usando o pacote ou port package:multimedia/mythtv-frontend[]. O Xorg também deve ser instalado e configurado conforme descrito em crossref:x11[x11, O sistema X Window]. Idealmente, este sistema tem uma placa de vídeo que suporta Compensação de Movimento de X-Vídeo (XvMC) e, opcionalmente, um controle remoto compatível com o Controle Remoto Infravermelho do Linux (LIRC).

Para instalar o backend e o frontend no FreeBSD, use o pacote ou port package:multimedia/mythtv[]. Um servidor de banco de dados MySQL(TM) também é necessário e deve ser instalado automaticamente como uma dependência. Opcionalmente, este sistema deve ter uma placa sintonizadora e armazenamento suficiente para armazenar os dados gravados.

=== Hardware

O MythTV usa o Video for Linux (V4L) para acessar dispositivos de entrada de vídeo, como codificadores e sintonizadores. No FreeBSD, o MythTV funciona melhor com placas USB DVB-S/C/T, pois são bem suportadas pelo pacote package:multimedia/webcamd[] ou pelo port que forneça uma aplicação V4L userland. Qualquer placa de transmissão de vídeo digital (DVB) suportada pelo webcamd deve funcionar com o MythTV. Uma lista de placas suportadas conhecidas pode ser encontrada em https://wiki.freebsd.org/WebcamCompat[ wiki.freebsd.org/WebcamCompat]. Drivers também estão disponíveis para placas Hauppauge nos ports package:multimedia/pvr250[] e package:multimedia/pvrxxx[], mas eles fornecem uma interface de driver não padronizados que não funcionam com versões do MythTV posteriores à 0.23. Devido a restrições de licenciamento, nenhum pacote está disponível e esses dois ports devem ser compilados.

A página https://wiki.freebsd.org/HTPC[wiki.freebsd.org/HTPC] contém uma lista de todos os drivers DVB disponíveis.

=== Configurando o Backend MythTV

Para instalar o MythTV usando pacotes binários:

[source,bash]
....
# pkg install mythtv
....

Como alternativa, para instalar a partir da Coleção de Ports:

[source,bash]
....
# cd /usr/ports/multimedia/mythtv
# make install
....

Uma vez instalado, configure o banco de dados do MythTV:

[source,bash]
....
# mysql -uroot -p < /usr/local/shared/mythtv/database/mc.sql
....

Em seguida, configure o backend:

[source,bash]
....
# mythtv-setup
....

Finalmente, inicie o backend:

[source,bash]
....
# sysrc mythbackend_enable=yes
# service mythbackend start
....

[[scanners]]
== Scanners de Imagem

No FreeBSD, o acesso aos scanners de imagens é fornecido pelo SANE (Scanner Access Now Easy), que está disponível na Coleção de Ports do FreeBSD. O SANE também usará alguns drivers de dispositivos do FreeBSD para fornecer acesso ao hardware do scanner.

O FreeBSD suporta os scanners SCSI e USB. Dependendo da interface do scanner, são necessários drivers de dispositivos diferentes. Certifique-se de que o scanner seja suportado pelo SANE antes de executar qualquer configuração. Consulte http://www.sane-project.org/sane-supported-devices.html[http://www.sane-project.org/sane-supported-devices.html] para obter mais informações sobre os scanners suportados.

Este capítulo descreve como determinar se o scanner foi detectado pelo FreeBSD. Em seguida, ele fornece uma visão geral de como configurar e usar o SANE em um sistema FreeBSD.

[[scanners-kernel-usb]]
=== Verificando o Scanner

O kernel [.filename]#GENERIC# inclui os drivers de dispositivos necessários para suportar scanners USB. Usuários com um kernel personalizado devem garantir que as seguintes linhas estejam presentes no arquivo de configuração do kernel personalizado:

[.programlisting]
....
device usb
device uhci
device ohci
device ehci
device xhci
....

Para verificar se o scanner USB foi detectado, conecte-o e execute o comando `dmesg`, sendo então possível ver se o scanner aparece no buffer de mensagens do sistema. Em caso afirmativo, deve ser exibida uma mensagem semelhante a esta:

[source,bash]
....
ugen0.2: <EPSON> at usbus0
....

Neste exemplo, um scanner EPSON Perfection(TM) 1650 USB foi detectado em [.filename]#/dev/ugen0.2#.

Se o scanner usar uma interface SCSI, é importante saber qual placa controladora SCSI será usada. Dependendo do chipset SCSI, um arquivo de configuração do kernel personalizado pode ser necessário. O kernel [.filename]#GENERIC# suporta os controladores SCSI mais comuns. Consulte [.filename]#/usr/src/sys/conf/NOTES# para determinar a linha correta a ser adicionada a um arquivo de configuração de kernel personalizado. Além do driver de adaptador SCSI, as seguintes linhas são necessárias em um arquivo de configuração de kernel personalizado:

[.programlisting]
....
device scbus
device pass
....

Verifique se o dispositivo é exibido no buffer de mensagens do sistema:

[source,bash]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

Se o scanner não foi ligado na inicialização do sistema, ainda é possível forçar manualmente a detecção executando uma varredura de barramento SCSI com o comando `camcontrol`:

[source,bash]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

O scanner deve agora aparecer na lista de dispositivos SCSI:

[source,bash]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

Consulte man:scsi[4] e man:camcontrol[8] para mais detalhes sobre dispositivos SCSI no FreeBSD.

=== Configuração do SANE

O sistma SANE provê o acesso ao scanner via backends (package:graphics/sane-backends[]). Consulte http://www.sane-project.org/sane-supported-devices.html[http://www.sane-project.org/sane-supported-devices.html] para determinar qual backend suporta o scanner. Uma interface gráfica é fornecida por aplicações terceiras como Kooka (package:graphics/kooka[]) ou XSane (package:graphics/xsane[]). Os backends do SANE são suficientes para testar o scanner.

Para instalar os backends do pacote binário:

[source,bash]
....
# pkg install sane-backends
....

Alternativamente, para instalar a partir da Coleção de Ports

[source,bash]
....
# cd /usr/ports/graphics/sane-backends
# make install clean
....

Depois de instalar o pacote ou port package:graphics/sane-backends[], use o comando `sane-find-scanner` para verificar a detecção do scanner pelo sistema SANE:

[source,bash]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

A saída deve mostrar o tipo de interface do scanner e o nó do dispositivo usado para conectar o scanner ao sistema. O fornecedor e o modelo do produto podem ou não aparecer.

[NOTE]
====
Alguns scanners USB exigem que o firmware seja carregado. Consulte sane-find-scanner(1) e sane(7) para mais detalhes.
====

Em seguida, verifique se o scanner será identificado por uma interface de digitalização. Os backends SANE incluem o comando `scanimage`, que pode ser usado para listar os dispositivos e realizar uma aquisição de imagens. Use a opção `-L` para listar os dispositivos do scanner. O primeiro exemplo é para um scanner SCSI e o segundo é para um scanner USB:

[source,bash]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

Neste segundo exemplo,`epson2` é o nome do backend e `libusb:000:002` significa que `/dev/ugen0.2` é o dispositivo usado pelo scanner.

Se o comando `scanimage` não conseguir identificar o scanner, esta mensagem será exibida:

[source,bash]
....
# scanimage -L

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

Se isso acontecer, edite o arquivo de configuração de backend em [.filename]#/usr/local/etc/sane.d/# e defina o dispositivo de scanner usado. Por exemplo, se o modelo de scanner não detectado for um EPSON Perfection(TM) 1650 e usar o backend `epson2`, edite o arquivo [.filename]#/usr/ local/etc/sane.d/epson2.conf#. Ao editar, adicione uma linha especificando a interface e o nó do dispositivo usado. Nesse caso, adicione a seguinte linha:

[.programlisting]
....
usb /dev/ugen0.2
....

Salve as edições e verifique se o scanner está identificado com o nome do back-end correto e com o nó do dispositivo:

[source,bash]
....
# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

Depois que o comando `scanimage -L` identificar o scanner, a configuração estará completa e o scanner estará pronto para ser usado.

Embora o `scanimage` possa ser usado para realizar uma digitalização de imagem a partir da linha de comando, muitas vezes é preferível usar uma interface gráfica para executar o escaneamento. Aplicações como Kooka ou XSane são interfaces de digitalização populares. Eles oferecem recursos avançados, como vários modos de digitalização, correção de cores e digitalizações em lote. O XSane também pode ser usado como um plugin GIMP.

=== Permissões do Scanner

Para ter acesso ao scanner, o usuário precisa ler e gravar as permissões no nó do dispositivo usado pelo scanner. No exemplo anterior, o scanner USB usa o nó do dispositivo [.filename]#/dev/ugen0.2# que é realmente um link simbólico para o nó do dispositivo real [.filename]#/dev/usb/0.2.0#. O link simbólico e o nó do dispositivo pertencem, respectivamente, aos grupos `wheel` e `operator`. Adicionando o usuário a esses grupos, será permitido o acesso ao scanner, considera-se inseguro adicionar um usuário a `wheel`. Uma solução melhor é criar um grupo e tornar o dispositivo de scanner acessível aos membros desse grupo.

Este exemplo cria um grupo chamado `_usb_`:

[source,bash]
....
# pw groupadd usb
....

Então, crie um link simbólico para [.filename]#/dev/ugen0.2# e o nó do dispositivo [.filename]#/dev/usb/0.2.0# para ficarem acessíveis ao grupo `usb` com permissões de gravação `0660` ou `0664` adicionando as seguintes linhas ao [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb
....

[NOTE]
====
Acontece do nó do dispositivo mudar com a adição ou remoção de dispositivos, então você pode querer dar acesso a todos os dispositivos USB usando esse conjunto de regas:

[.programlisting]
....
[system=5]
add path 'ugen*' mode 0660 group usb
add path 'usb/*' mode 0666 group usb
....

====

Finalmente, adicione os usuários a `_usb_` para permitir acesso ao scanner:

[source,bash]
....
# pw groupmod usb -m joe
....

Para mais detalhes, consulte man:pw[8].
