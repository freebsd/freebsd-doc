---
title: Capítulo 26. Comunicações Seriais
part: Parte IV. Comunicação de rede
prev: books/handbook/partiv
next: books/handbook/ppp-and-slip
showBookMenu: true
weight: 31
path: "/books/handbook/serialcomms/"
---

[[serialcomms]]
= Comunicações Seriais
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 26
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/serialcomms/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[serial-synopsis]]
== Sinopse

O UNIX(TM) sempre teve suporte para comunicação serial, pois as primeiras máquinas UNIX(TM) dependiam de linhas seriais para entrada e saída do usuário. As coisas mudaram muito desde os dias em que o terminal médio consistia de uma impressora serial de 10 caracteres por segundo e um teclado. Este capítulo aborda algumas das maneiras pelas quais as comunicações seriais podem ser usadas no FreeBSD.

Depois de ler este capítulo, você saberá:

* Como conectar terminais a um sistema FreeBSD.
* Como usar um modem para discar para hosts remotos.
* Como permitir que usuários remotos efetuem login em um sistema FreeBSD com um modem.
* Como inicializar um sistema FreeBSD a partir de uma console serial.

Antes de ler este capítulo, você deve:

* Saiba como crossref:kernelconfig[kernelconfig,configurar e instalar um kernel personalizado].
* Entenda crossref:basics[basics,permissões e processos do FreeBSD].
* Tenha acesso ao manual técnico para o hardware serial a ser usado com o FreeBSD.

[[serial]]
== Terminologia serial e hardware

Os termos a seguir são frequentemente usados em comunicações seriais:

bps::
Bits por Segundo  (bps) é a taxa na qual os dados são transmitidos.

DTE::
Equipamento Terminal de Dados  (DTE) é um dos dois terminais em uma comunicação serial. Um exemplo seria um computador.

DCE::
Equipamento de Comunicações de Dados  (DTE) é o outro terminal em uma comunicação serial. Normalmente, é um modem ou terminal serial.

RS-232::
O padrão original que definiu as comunicações seriais de hardware. Desde então, foi renomeado para TIA-232.

Ao se referir a taxas de dados de comunicação, esta seção não usa o termo _baud_. Baud refere-se ao número de transições de estado elétrico feitas em um período de tempo, enquanto bps é o termo correto a ser usado.

Para conectar um terminal serial a um sistema FreeBSD, são necessárias uma porta serial no computador e o cabo adequado para conectar ao dispositivo serial. Os usuários que já estão familiarizados com hardware serial e cabeamento podem pular esta seção com segurança.

[[term-cables-null]]
=== Cabos Serial e Portas

Existem vários tipos diferentes de cabos seriais. Os dois tipos mais comuns são cabo null-modem e cabo padrão RS-232. A documentação do hardware deve descrever o tipo de cabo necessário.

Estes dois tipos de cabos diferem em como os fios são conectados ao conector. Cada fio representa um sinal, com os sinais definidos resumidos em <<serialcomms-signal-names>>. Um cabo serial padrão passa todos os sinais RS-232C diretamente. Por exemplo, o pino "Transmitted Data" em uma extremidade do cabo vai para o pino "Transmitted Data" na outra extremidade. Este é o tipo de cabo usado para conectar um modem ao sistema FreeBSD e também é apropriado para alguns terminais.

Um cabo de modem nulo alterna o pino "Transmitted Data" do conector em uma extremidade com o pino "Received Data" na outra extremidade. O conector pode ser um DB-25 ou um DB-9.

Um cabo de modem nulo pode ser construído usando as conexões de pinos resumidas em <<nullmodem-db25>>, <<nullmodem-db9>> e <<nullmodem-db9-25>>. Enquanto o padrão exige um pino direto 1 para fixar uma linha "Protective Ground", ele é freqüentemente omitido. Alguns terminais funcionam usando apenas os pinos 2, 3 e 7, enquanto outros exigem configurações diferentes. Em caso de dúvida, consulte a documentação do hardware.

[[serialcomms-signal-names]]
.RS-232C Nomes dos Sinais
[cols="1,1", frame="none", options="header"]
|===
<| Siglas
<| Nomes

|RD
|Received Data

|TD
|Transmitted Data

|DTR
|Data Terminal Ready

|DSR
|Data Set Ready

|DCD
|Data Carrier Detect

|SG
|Signal Ground

|RTS
|Request to Send

|CTS
|Clear to Send
|===

[[nullmodem-db25]]
.Cabo Null-Modem DB-25 para DB-25
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Sinal
<| Pin #
| 
<| Pin #
<| Sinal

|SG
|7
|conecta-se a
|7
|SG

|TD
|2
|conecta-se a
|3
|RD

|RD
|3
|conecta-se a
|2
|TD

|RTS
|4
|conecta-se a
|5
|CTS

|CTS
|5
|conecta-se a
|4
|RTS

|DTR
|20
|conecta-se a
|6
|DSR

|DTR
|20
|conecta-se a
|8
|DCD

|DSR
|6
|conecta-se a
|20
|DTR

|DCD
|8
|conecta-se a
|20
|DTR
|===

[[nullmodem-db9]]
.Cabo DB-9 para DB-9 Null-Modem
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Sinal
<| Pin #
| 
<| Pin #
<| Sinal

|RD
|2
|conecta-se a
|3
|TD

|TD
|3
|conecta-se a
|2
|RD

|DTR
|4
|conecta-se a
|6
|DSR

|DTR
|4
|conecta-se a
|1
|DCD

|SG
|5
|conecta-se a
|5
|SG

|DSR
|6
|conecta-se a
|4
|DTR

|DCD
|1
|conecta-se a
|4
|DTR

|RTS
|7
|conecta-se a
|8
|CTS

|CTS
|8
|conecta-se a
|7
|RTS
|===

[[nullmodem-db9-25]]
.Cabo DB-9 para DB-25 Null-Modem
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Sinal
<| Pin #
| 
<| Pin #
<| Sinal

|RD
|2
|conecta-se a
|2
|TD

|TD
|3
|conecta-se a
|3
|RD

|DTR
|4
|conecta-se a
|6
|DSR

|DTR
|4
|conecta-se a
|8
|DCD

|SG
|5
|conecta-se a
|7
|SG

|DSR
|6
|conecta-se a
|20
|DTR

|DCD
|1
|conecta-se a
|20
|DTR

|RTS
|7
|conecta-se a
|5
|CTS

|CTS
|8
|conecta-se a
|4
|RTS
|===

[NOTE]
====
Quando um pino em uma extremidade se conecta a um par de pinos na outra extremidade, geralmente é implementado com um fio curto entre o par de pinos em seu conector e um fio longo no outro pino único.
====

As portas seriais são os dispositivos através dos quais os dados são transferidos entre o computador host do FreeBSD e o terminal. Vários tipos de portas seriais existem. Antes de comprar ou construir um cabo, verifique se ele irá se encaixar nas portas do terminal e no sistema FreeBSD.

A maioria dos terminais tem portas DB-25. Os computadores pessoais podem ter portas DB-25 ou DB-9. Um cartão serial multiportas pode ter portas RJ-12 ou RJ-45/. Consulte a documentação que acompanha o hardware para especificações sobre o tipo de porta ou verifique visualmente o tipo de porta.

No FreeBSD, cada porta serial é acessada através de uma entrada em [.filename]#/dev#. Existem dois tipos diferentes de entradas:

* As portas de chamada são nomeadas [.filename]#/dev/ttyuN# onde _N_ é o número da porta, começando do zero. Se um terminal estiver conectado a primeira porta serial ([.filename]#COM1#), use [.filename]#/dev/ttyu0# para se referir ao terminal. Se o terminal estiver na segunda porta serial ([.filename]#COM2#), use [.filename]#/dev/ttyu1# e assim por diante. Geralmente, a porta de chamada é usada para terminais. As portas de chamada requerem que a linha serial declare o sinal "Data Carrier Detect" para funcionar corretamente.
* As portas de chamadas de saida são nomeadas [.filename]#/dev/cuauN# nas versões 8.X e superiores do FreeBSD e [.filename]#/dev/cuadN# nas versões 7.X e inferiores do FreeBSD. As portas de chamada de saida geralmente não são usadas para terminais, mas são usadas para modems. A porta de evocação pode ser usada se o cabo serial ou o terminal não suportar o sinal "Data Carrier Detect".

O FreeBSD também fornece dispositivos de inicialização ([.filename]#/dev/ttyuN.init# e [.filename]#/dev/cuauN.init# ou [.filename]#/dev/cuadN.init#) e dispositivos de bloqueio ([.filename]#/dev/ttyuN.lock# e [.filename]#/dev/cuauN.lock# ou [.filename]#/dev/cuadN.lock#). Os dispositivos de inicialização são utilizados para inicializar os parâmetros da porta de comunicações de cada vez que uma porta é aberta, tal como o `crtscts` para modems que usam `RTS/CTS` sinalização para controle de fluxo. Os dispositivos de bloqueio são usados para bloquear sinalizadores nas portas para impedir que usuários ou programas alterem determinados parâmetros. Consulte man:termios[4], man:sio[4], e man:stty[1] para obter informações sobre configurações de terminal, bloqueio e inicialização de dispositivos e configuração de opções de terminal, respectivamente.

[[serial-hw-config]]
=== Configuração de Porta Serial

Por padrão, o FreeBSD suporta quatro portas seriais que são comumente conhecidas como [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3# e [.filename]#COM4#. O FreeBSD também suporta placas de interfaces seriais multi-port, como o BocaBoard 1008 e 2016, bem como placas multi-port mais inteligentes, como as feitas pela Digiboard. No entanto, o kernel padrão procura apenas as portas padrão [.filename]#COM#.

Para ver se o sistema reconhece as portas seriais, procure por mensagens de inicialização do sistema que começam com `uart`:

[source,shell]
....
# grep uart /var/run/dmesg.boot
....

Se o sistema não reconhecer todas as portas seriais necessárias, entradas adicionais podem ser adicionadas ao [.filename]#/boot/device.hints#. Este arquivo já contém entradas `hint.uart.0.\*` para entradas [.filename]#COM1# e `hint.uart.1.*` para [.filename]#COM2#. Ao adicionar uma entrada de porta para [.filename]#COM3# use `0x3E8` e para [.filename]#COM4# use `0x2E8`. Endereços comuns de IRQ são `5` para [.filename]#COM3# e `9` para [.filename]#COM4#.

Para determinar o conjunto padrão de configurações de terminal E/S usadas pela porta, especifique o nome do dispositivo. Este exemplo determina as configurações para a porta de chamada em [.filename]#COM2#:

[source,shell]
....
# stty -a -f /dev/ttyu1
....

A inicialização de dispositivos seriais em todo o sistema é controlada por [.filename]#/etc/rc.d/serial#. Este arquivo afeta as configurações padrão dos dispositivos seriais. Para alterar as configurações de um dispositivo, use `stty`. Por padrão, as configurações alteradas estão em vigor até que o dispositivo seja fechado e, quando o dispositivo for reaberto, volte para o conjunto padrão. Para alterar permanentemente o conjunto padrão, abra e ajuste as configurações do dispositivo de inicialização. Por exemplo, para ativar o modo `CLOCAL`, comunicação de 8 bits e controle de fluxo `XON/XOFF` para [.filename]#ttyu5#, digite:

[source,shell]
....
# stty -f /dev/ttyu5.init clocal cs8 ixon ixoff
....

Para impedir que determinadas configurações sejam alteradas por um aplicativo, faça ajustes no dispositivo de bloqueio. Por exemplo, para bloquear a velocidade de [.filename]#ttyu5# para 57600 bps, digite:

[source,shell]
....
# stty -f /dev/ttyu5.lock 57600
....

Agora, qualquer aplicativo que abra [.filename]#ttyu5# e tente alterar a velocidade da porta será bloqueado com 57600 bps.

[[term]]
== Terminais

Os terminais fornecem uma maneira conveniente e barata de acessar um sistema FreeBSD quando não estão no console do computador ou em uma rede conectada. Esta seção descreve como usar terminais com o FreeBSD.

Os sistemas originais UNIX(TM) não tinham consoles. Em vez disso, os usuários efetuaram login e executaram programas por meio de terminais conectados as portas seriais do computador.

A capacidade de estabelecer uma sessão de login em uma porta serial ainda existe em quase todos os sistemas operacionais do tipo UNIX(TM) hoje, incluindo o FreeBSD. Usando um terminal conectado a uma porta serial não usada, um usuário pode efetuar login e executar qualquer programa de texto que possa ser executado normalmente no console ou em uma janela `xterm`.

Muitos terminais podem ser conectados a um sistema FreeBSD. Um computador sobressalente mais antigo pode ser usado como um terminal conectado a um computador mais potente executando o FreeBSD. Isso pode transformar o que poderia ser um computador de usuário único em um poderoso sistema de múltiplos usuários.

O FreeBSD suporta três tipos de terminais:

Terminais Burros::
Terminais burro são um hardware especializado que se conecta a computadores através de linhas seriais. Eles são chamados de "dumb" porque eles possuem apenas poder computacional suficiente para exibir, enviar e receber texto. Nenhum programa pode ser executado nesses dispositivos. Em vez disso, os terminais burros se conectam a um computador que executa os programas necessários.
+
Existem centenas de tipos de terminais burro feitos por muitos fabricantes, e praticamente qualquer tipo funciona com o FreeBSD. Alguns terminais high-end podem até exibir gráficos, mas apenas determinados pacotes de software podem aproveitar esses recursos avançados.
+
Terminais burro são populares em ambientes de trabalho onde os trabalhadores não precisam de acesso a aplicativos gráficos.

Computadores Atuando como Terminais::
Como um terminal burro tem capacidade suficiente para exibir, enviar e receber texto, qualquer computador de reserva pode ser um terminal burro. Tudo o que é necessário é o cabo adequado e algum software de _terminal emulation_ para ser executado no computador.
+
Esta configuração pode ser útil. Por exemplo, se um usuário está ocupado trabalhando no console do sistema FreeBSD, outro usuário pode fazer algum trabalho somente de texto ao mesmo tempo de um computador pessoal menos potente ligado como um terminal ao sistema FreeBSD.
+
Existem pelo menos dois utilitários no sistema base do FreeBSD que podem ser usados para trabalhar através de uma conexão serial: man:cu[1] e man:tip[1].
+
Por exemplo, para conectar-se de um sistema cliente que executa o FreeBSD para a conexão serial de outro sistema:
+
[source,shell]
....
# cu -l /dev/cuauN
....
+
Portas são numeradas a partir de zero. Isso significa que [.filename]#COM1# é [.filename]#/dev/cuau0#.
+
Programas adicionais estão disponíveis através da coleção de ports, como package:comms/minicom[].

Terminais X::
Os terminais X são o tipo de terminal mais sofisticado disponível. Em vez de se conectar a uma porta serial, eles geralmente se conectam a uma rede como a Ethernet. Em vez de serem relegados a aplicativos somente de texto, eles podem exibir qualquer aplicativo Xorg.
+
Este capítulo não cobre a configuração ou uso de terminais X.

[[term-config]]
=== Configuração do Terminal

Esta seção descreve como configurar um sistema FreeBSD para ativar uma sessão de login em um terminal serial. Assume-se que o sistema reconhece a porta serial a qual o terminal está conectado e que o terminal está conectado com o cabo correto.

No FreeBSD, o `init` lê o [.filename]#/etc/ttys# e inicia um processo `getty` nos terminais disponíveis. O processo `getty` é responsável por ler um nome de login e iniciar o programa `login`. As portas no sistema FreeBSD que permitem logins estão listadas em [.filename]#/etc/ttys#. Por exemplo, o primeiro console virtual, [.filename]#ttyv0#, possui uma entrada nesse arquivo, permitindo logins no console. Este arquivo também contém entradas para os outros consoles virtuais, portas seriais e pseudo-ttys. Para um terminal com fio, a entrada [.filename]#/dev# da porta serial é listada sem a parte `/dev`. Por exemplo, [.filename]#/dev/ttyv0# está listado como `ttyv0`.

Por padrão o [.filename]#/etc/ttys# configura o suporte para as quatro primeiras portas seriais, [.filename]#ttyu0# até [.filename]#ttyu3#:

[.programlisting]
....
ttyu0   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu1   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu2   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu3   "/usr/libexec/getty std.9600"   dialup  off secure
....

Ao conectar um terminal a uma destas portas, modifique a entrada padrão para definir a velocidade e o tipo de terminal necessários, para ligar o dispositivo `on` e, se necessário, para alterar o `secure` da porta. Se o terminal estiver conectado a outra porta, adicione uma entrada para a porta.

<<ex-etc-ttys>> configura dois terminais em [.filename]#/etc/ttys#. A primeira entrada configura um Wyse-50 conectado ao [.filename]#COM2#. A segunda entrada configura um computador antigo executando o software do terminal Procomm emulando um terminal VT-100. O computador está conectado à sexta porta serial em uma placa serial com várias portas.

[[ex-etc-ttys]]
.Configurando Entradas de Terminal
[example]
====
[.programlisting]
....
ttyu1  "/usr/libexec/getty std.38400"  wy50  on  insecure
ttyu5   "/usr/libexec/getty std.19200"  vt100  on insecure
....

* O primeiro campo especifica o nome do dispositivo do terminal serial.
* O segundo campo informa ao `getty` para inicializar e abrir a linha, definir a velocidade da linha, solicitar um nome de usuário e, em seguida, executar o programa `login`. O tipo de _getty type_ configura características na linha do terminal, como taxa e paridade bps. Os tipos de getty disponíveis estão listados em [.filename]#/etc/gettytab#. Em quase todos os casos, os tipos de getty que começam com `std` funcionarão para terminais conectados, já que essas entradas ignoram a paridade. Há uma entrada `std` para cada taxa de bps de 110 a 115200. Consulte man:gettytab[5] para mais informações.Ao definir o tipo de getty, certifique-se de coincidir com as configurações de comunicação usadas pelo terminal. Para este exemplo, o Wyse-50 não usa paridade e se conecta a 38400 bps. O computador não usa paridade e se conecta a 19200 bps.
* O terceiro campo é o tipo de terminal. Para portas dial-up, `unknown` ou `dialup` é normalmente usado, pois os usuários podem discar praticamente com qualquer tipo de terminal ou software. Como o tipo de terminal não muda para terminais com fio, um tipo de terminal real de [.filename]#/etc/termcap# pode ser especificado. Para este exemplo, o Wyse-50 usa o tipo de terminal real enquanto o computador executando o Procomm está configurado para emular um VT-100.
* O quarto campo especifica se a porta deve estar ativada. Para ativar logins nessa porta, este campo deve ser definido como `on`.
* O campo final é usado para especificar se a porta é segura. Marcar uma porta como `secure` significa que ela é confiável o suficiente para permitir que `root` faça login a partir dessa porta. As portas inseguras não permitem logins `root`. Em uma porta insegura, os usuários devem efetuar login de contas não privilegiadas e, em seguida, usar o `su` ou um mecanismo semelhante para obter privilégios de superusuário, conforme descrito em crossref:basics[users-superuser,A conta de superusuário]. Por razões de segurança, recomenda-se alterar esta configuração para `insecure`.
====

Depois de fazer qualquer alteração em [.filename]#/etc/ttys#, envie um sinal SIGHUP (hangup) para o processo `init` para forçá-lo a reler seu arquivo de configuração:

[source,shell]
....
# kill -HUP 1
....

Como o `init` é sempre o primeiro processo executado em um sistema, ele sempre tem um processo ID de `1`.

Se tudo estiver configurado corretamente, todos os cabos estiverem no lugar e os terminais ligados, um processo `getty` deverá estar em execução em cada terminal e as solicitações de login deverão estar disponíveis em cada terminal.

[[term-debug]]
=== Solução de Problemas da Conexão

Mesmo com a mais meticulosa atenção aos detalhes, algo poderia dar errado ao configurar um terminal. Aqui está uma lista de sintomas comuns e algumas correções sugeridas.

Se nenhum prompt de login aparecer, verifique se o terminal está conectado e ligado. Se for um computador pessoal atuando como um terminal, verifique se ele está executando o software de emulação de terminal na porta serial correta.

Certifique-se de que o cabo esteja conectado firmemente ao terminal e ao computador do FreeBSD. Certifique-se de que é o tipo certo de cabo.

Certifique-se de que o terminal e o FreeBSD concordem com as configurações de taxa e paridade de bps. Para um terminal de exibição de vídeo, verifique se os controles de contraste e brilho estão ativados. Se for um terminal de impressão, verifique se o papel e a tinta estão em bom estado.

Use `ps` para certificar-se de que um processo `getty` esteja em execução e atendendo ao terminal. Por exemplo, a listagem a seguir mostra que um `getty` está sendo executado na segunda porta serial, [.filename]#ttyu1#, e está usando a entrada `std.38400` em [.filename]#/etc/gettytab#:

[source,shell]
....
# ps -axww|grep ttyu
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1
....

Se nenhum processo `getty` estiver em execução, certifique-se de que a porta esteja ativada em [.filename]#/etc/ttys#. Lembre-se de executar `kill -HUP 1` após modificar [.filename]#/etc/ttys#.

Se o processo `getty` estiver em execução, mas o terminal ainda não exibir um prompt de login ou se exibir um prompt, mas não aceitar entrada digitada, o terminal ou cabo poderá não suportar handshaking de hardware. Tente alterar a entrada em [.filename]#/etc/ttys# de `std.38400` para `3wire.38400` e, em seguida, execute `kill -HUP 1` depois de modificar o [.filename]#/etc/ttys#. A entrada `3wire` é semelhante a `std`, mas ignora handshaking de hardware. Pode ser necessário reduzir a taxa de transmissão ou ativar o controle de fluxo de software ao usar `3wire` para evitar buffer overflows.

Se aparecer lixo em vez de um prompt de login, certifique-se de que o terminal e o FreeBSD concordem com as configurações de taxa e paridade de bps. Verifique os processos `getty` para certificar-se de que o tipo correto _getty_ esteja em uso. Se não, edite [.filename]#/etc/ttys# e execute `kill -HUP 1`.

Se os caracteres aparecerem duplicados e a senha aparecer quando digitada, alterne o terminal ou o software de emulação de terminal de "half duplex" ou "local echo" para "full duplex."

[[dialup]]
== Serviço Dial-in

Configurar um sistema FreeBSD para serviço de discagem é semelhante a configurar terminais, exceto que os modens são usados em vez de dispositivos terminais. O FreeBSD suporta modens externos e internos.

Os modems externos são mais convenientes, pois geralmente podem ser configurados por meio de parâmetros armazenados em RAM não voláteis e geralmente fornecem indicadores luminosos que exibem o estado dos sinais RS-232 importantes, indicando se o modem está funcionando corretamente.

Normalmente, os modems internos não possuem RAM não volátil, portanto, sua configuração pode ser limitada à configuração de switches DIP. Se o modem interno tiver luzes indicadoras de sinal, elas serão difíceis de visualizar quando a tampa do sistema estiver no lugar.

Ao usar um modem externo, é necessário um cabo adequado. Um cabo serial padrão de RS-232C deve ser suficiente.

O FreeBSD precisa dos sinais RTS e CTS para controle de fluxo em velocidades acima de 2400 bps, o sinal CD para detectar quando uma chamada foi atendida ou a linha foi desligada e o sinal DTR para redefinir o modem após a conclusão de uma sessão. Alguns cabos são conectados sem todos os sinais necessários, portanto, se uma sessão de login não desaparecer quando a linha for desligada, pode haver um problema com o cabo. Consulte <<term-cables-null>> para mais informações sobre esses sinais.

Como outros sistemas operacionais similares ao UNIX(TM)-like, o FreeBSD usa os sinais de hardware para descobrir quando uma chamada foi atendida ou uma linha foi desconectada e para desligar e reinicializar o modem após uma chamada. O FreeBSD evita enviar comandos para o modem ou observar relatórios de status do modem.

O FreeBSD suporta interfaces de comunicação NS8250, NS16450, NS16550 e NS16550A baseado em RS-232C (CCITT V.24). Os dispositivos 8250 e 16450 possuem buffers de caractere único. O dispositivo 16550 fornece um buffer de 16 caracteres, o que permite um melhor desempenho do sistema. Bugs em dispositivos simples 16550 impedem o uso do buffer de 16 caracteres, portanto, use dispositivos 16550A, se possível. Como os dispositivos de buffer de caractere único requerem mais trabalho pelo sistema operacional do que os dispositivos de buffer de 16 caracteres, as placas de interface serial baseadas no 16550A são preferidas. Se o sistema tiver muitas portas seriais ativas ou tiver uma carga pesada, as placas baseadas em 16550A são melhores para comunicações com baixa taxa de erro.

O restante desta seção demonstra como configurar um modem para receber conexões de entrada, como se comunicar com o modem e oferece algumas dicas de solução de problemas.

[[dialup-ttys]]
=== Configuração de Modem

Como nos terminais, o `init` gera um processo `getty` para cada porta serial configurada usada para conexões de dial-in. Quando um usuário disca a linha do modem e os modems se conectam, o sinal "Carrier Detect" é informado pelo modem. O kernel percebe que a portadora foi detectada e instrui o `getty` a abrir a porta e exibir um prompt `login:` na velocidade da linha inicial especificada. Em uma configuração típica, se caracteres de lixo forem recebidos, geralmente devido à velocidade de conexão do modem ser diferente da velocidade configurada, o `getty` tenta ajustar as velocidades de linha até receber caracteres razoáveis. Depois que o usuário digita seu nome de login, o `getty` executa o `login`, que conclui o processo de login solicitando a senha do usuário e iniciando o shell do usuário.

Existem duas escolas de pensamento sobre modems dial-up. Um método de configuração é definir os modems e sistemas de modo que, independentemente da velocidade em que um usuário remoto disca, a interface de discagem RS-232 seja executada em uma velocidade travada. O benefício dessa configuração é que o usuário remoto sempre vê um prompt de login do sistema imediatamente. A desvantagem é que o sistema não sabe qual é a verdadeira taxa de dados do usuário, portanto, programas em tela cheia como o Emacs não ajustam seus métodos de tela para melhorar a resposta para conexões mais lentas.

O segundo método é configurar a interface RS-232 para variar sua velocidade com base na velocidade de conexão do usuário remoto. Como o `getty` não compreende o relatório de velocidade de conexão de nenhum modem em particular, ele fornece uma mensagem `login:` em uma velocidade inicial e observa os caracteres que retornam em resposta. Se o usuário vê lixo, eles devem pressionar kbd:[Enter] até que um prompt reconhecível seja exibido. Se as taxas de dados não corresponderem, `getty` verá qualquer coisa que o usuário digita como lixo, e tentará a próxima velocidade e informará novamente o prompt `login:`. Esse procedimento normalmente leva apenas um pressionamento de tecla ou dois antes que o usuário veja um bom prompt. Essa seqüência de login não parece tão limpa quanto o método de velocidade travada, mas um usuário em uma conexão de baixa velocidade deve receber uma melhor resposta interativa de programas em tela cheia.

Ao travar a taxa de comunicação de dados de um modem a uma velocidade específica, nenhuma alteração em [.filename]#/etc/gettytab# deve ser necessária. No entanto, para uma configuração de velocidade compatível, entradas adicionais podem ser necessárias para definir as velocidades a serem usadas para o modem. Este exemplo configura um modem de 14,4 Kbps com uma velocidade de interface superior de 19,2 Kbps usando conexões de 8 bits sem paridade. Ele configura o `getty` para iniciar a taxa de comunicação para uma conexão V.32bis a 19,2 Kbps, passando por 9600 bps, 2400 bps, 1200 bps, 300 bps e de volta para 19,2 Kbps. O ciclo de taxa de comunicação é implementado com o recurso `nx=` (proxima tabela). Cada linha usa uma entrada `tc=` (continuação de tabela) para selecionar o restante das configurações para uma taxa de dados específica.

[.programlisting]
....
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

Para um modem de 28,8 Kbps ou para aproveitar a compactação em um modem de 14,4 Kbps, use uma taxa de comunicação mais alta, conforme mostrado neste exemplo:

[.programlisting]
....
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

Para uma CPU lenta ou um sistema altamente carregado sem portas seriais baseadas no 16550A, esta configuração pode produzir erros `sio` "silo" a 57,6 Kbps.

A configuração do [.filename]#/etc/ttys# é similar a <<ex-etc-ttys>>, mas um argumento diferente é passado para o `getty` e `dialup` é usado para o tipo de terminal. Substitua _xxx_ pelo processo `init` que será executado no dispositivo:

[.programlisting]
....
ttyu0   "/usr/libexec/getty xxx"   dialup on
....

O tipo de terminal `dialup` pode ser alterado. Por exemplo, definir `vt102` como o tipo de terminal padrão permite que os usuários usem a emulação VT102 em seus sistemas remotos.

Para uma configuração de velocidade travada, especifique a velocidade com um tipo válido listado em [.filename]#/etc/gettytab#. Este exemplo é para um modem cuja velocidade de porta está travada em 19,2 Kbps:

[.programlisting]
....
ttyu0   "/usr/libexec/getty std.19200"   dialup on
....

Em uma configuração de velocidade correspondente, a entrada precisa referenciar a entrada inicial apropriada "auto-baud" em [.filename]#/etc/gettytab#. Para continuar o exemplo de um modem com velocidade correspondente que começa em 19,2 Kbps, use esta entrada:

[.programlisting]
....
ttyu0   "/usr/libexec/getty V19200"   dialup on
....

Depois de editar o [.filename]#/etc/ttys#, espere até que o modem esteja devidamente configurado e conectado antes de sinalizar o `init`:

[source,shell]
....
# kill -HUP 1
....

Modems de alta velocidade, como os modems V.32, V.32bis e V.34, usam hardware (`RTS/CTS`) para controle de fluxo. Use o `stty` para definir a flag de controle de fluxo de hardware para a porta do modem. Este exemplo define a flag `crtscts` na inicialização dos dispositivos [.filename]#COM2# de dial-in e de dial-out:

[source,shell]
....
# stty -f /dev/ttyu1.init crtscts
# stty -f /dev/cuau1.init crtscts
....

=== Solução de problemas

Esta seção fornece algumas dicas para solucionar problemas de um modem dial-up que não se conecta há um sistema FreeBSD.

Conecte o modem ao sistema FreeBSD e inicialize o sistema. Se o modem tiver luzes de indicação de status, observe se o indicador DTR do modem acende quando o prompt `login:` é exibido no console do sistema. Se acender, isso deve significar que o FreeBSD iniciou um processo `getty` na porta de comunicação apropriada e está aguardando o modem aceitar uma chamada.

Se o indicador DTR não acender, faça o login no sistema FreeBSD através do console e digite `ps ax` para ver se o FreeBSD está executando um processo `getty` na porta correta:

[source,shell]
....
114 ??  I      0:00.10 /usr/libexec/getty V19200`ttyu0`
....

Se a segunda coluna contiver um `d0` em vez de um `??` e o modem ainda não aceitou uma chamada, isso significa que o `getty` completou sua chamada na porta de comunicações. Isso pode indicar um problema com o cabeamento ou com um modem configurado incorretamente porque o `getty` não deve conseguir abrir a porta de comunicação até que o sinal de detecção da portadora tenha sido declarado pelo modem.

Se nenhum processo `getty` estiver aguardando para abrir a porta, verifique se a entrada da porta está correta no [.filename]#/etc/ttys#. Além disso, verifique o [.filename]#/var/log/messages# para ver se há alguma mensagem de log do `init` ou do `getty`.

Em seguida, tente discar para o sistema. Certifique-se de usar 8 bits, sem paridade e 1 bit de stop no sistema remoto. Se um prompt não aparecer imediatamente ou o prompt mostrar lixo, tente pressionar kbd:[Enter] uma vez por segundo durante alguns segundos. Se ainda não houver nenhum prompt de `login:`, tente enviar um `BREAK`. Ao usar um modem de alta velocidade, tente discar novamente após travar a velocidade da interface do modem de discagem.

Se ainda não houver o prompt `login:`, verifique novamente o [.filename]#/etc/gettytab# e faça um double-check:

* O nome do recurso inicial especificado na entrada em [.filename]#/etc/ttys# corresponde ao nome de um recurso em [.filename]#/etc/gettytab#.
* Cada entrada `nx=` corresponde a outro nome de recurso [.filename]#gettytab#.
* Cada entrada `tc=` corresponde a outro nome de recurso [.filename]#gettytab#.

Se o modem no sistema FreeBSD não responder, verifique se o modem está configurado para atender o telefone quando o DTR é ativado. Se o modem parece estar configurado corretamente, verifique se a linha DTR é ativada, verificando as luzes indicadoras do modem.

Se ainda assim não funcionar, tente enviar um e-mail para a http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions[lista de discussão de perguntas gerais do FreeBSD] descrevendo o modem e o problema.

[[dialout]]
== Serviço de Dial-in

A seguir, dicas para fazer com que o host conecte-se através do modem a outro computador. Isto é apropriado para estabelecer uma sessão de terminal com um host remoto.

Esse tipo de conexão pode ser útil para obter um arquivo na Internet, caso haja problemas no uso do PPP. Se o PPP não estiver funcionando, use a sessão do terminal para enviar por FTP o arquivo necessário. Em seguida, use o zmodem para transferi-lo para a máquina.

[[hayes-unsupported]]
=== Usando um Modem Stock Hayes

Um dialer Hayes genérico está incorporado no `tip`. Use `at=hayes` em [.filename]#/etc/remote#.

O driver Hayes não é inteligente o suficiente para reconhecer alguns dos recursos avançados de mensagens de modems mais recentes como `BUSY`, `NO DIALTONE` ou `CONNECT 115200`. Desative essas mensagens ao usar o `tip` com o `ATX0&W`.

O tempo limite de discagem para o `tip` é de 60 segundos. O modem deve usar algo menor, ou então o `tip` irá achar que existe um problema de comunicação. Tente usar `ATS7=45&W`.

[[direct-at]]
=== Usando comandos `AT`

Crie uma entrada "direct" em [.filename]#/etc/remote#. Por exemplo, se o modem estiver conectado à primeira porta serial, [.filename]#/dev/cuau0#, use a seguinte linha:

[.programlisting]
....
cuau0:dv=/dev/cuau0:br#19200:pa=none
....

Use a taxa mais alta de bps que o modem suporta no recurso `br`. Em seguida, digite `tip cuau0` para conectar-se ao modem.

Ou use `cu` como `root` com o seguinte comando:

[source,shell]
....
# cu -lline -sspeed
....

_line_ é a porta serial, tal como [.filename]#/dev/cuau0#, e _speed_ é a velocidade, tal como `57600` . Quando terminar de digitar os comandos AT, digite `~.` para sair.

[[gt-failure]]
=== O Sinal `@` Não Funciona

O `@` na capability do número de telefone diz ao `tip` para procurar em [.filename]#/etc/phones# um número de telefone. Mas, o sinal. `@` também é um caractere especial em arquivos de capablity como o [.filename]#/etc/remote#, então ele precisa ser escapado com uma barra invertida:

[.programlisting]
....
pn=\@
....

[[dial-command-line]]
=== Discando a Partir da Linha de Comando

Coloque uma entrada "genérica" em [.filename]#/etc/remote#. Por exemplo:

[.programlisting]
....
tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:
....

Isto deve funcionar agora:

[source,shell]
....
# tip -115200 5551234
....

Usuários que preferem comando `cu` ao `tip`, podem usar uma entrada `cu` genérica:

[.programlisting]
....
cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:
....

e digite:

[source,shell]
....
# cu 5551234 -s 115200
....

[[set-bps]]
=== Definindo a Taxa de bps

Coloque uma entrada para `tip1200` ou `cu1200`, mas vá em frente e use qualquer taxa bps apropriada com o capability `br`. O `tip` acha que um bom padrão é de 1200 bps, e é por isso que ele procura por uma entrada `tip1200`. No entanto, 1200 bps não precisa ser usado.

[[terminal-server]]
=== Acessando um Conjunto de Hosts por Meio de um Servidor de Terminal

Em vez de esperar até conectar-se e digitar `CONNECT_host_` a cada vez, use o recurso `cm` do `tip`. Por exemplo, estas entradas no [.filename]#/etc/remote# permitirão que você digite `tip pain` ou `tip muffin` para conectar-se aos hosts `pain` ou `muffin` e `tip deep13` para conectar ao servidor de terminal.

[.programlisting]
....
pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

[[tip-multiline]]
=== Usando Mais de Uma Linha com `tip`

Isto geralmente é um problema em que uma universidade tem várias linhas de modems e vários milhares de estudantes tentando usá-las.

Faça uma entrada em [.filename]#/etc/remote# e use `@` para o recurso `pn`:

[.programlisting]
....
big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:
....

Em seguida, liste os números de telefone em [.filename]#/etc/phones#:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

O `tip` tentará cada número na ordem listada, depois desistirá. Para continuar tentando, execute o `tip` em um loop `while`.

[[multi-controlp]]
=== Usando o Caractere de Force

O kbd:[Ctrl+P] é o caracter "force" padrão, usado para dizer ao `tip` que o próximo caractere é um dado literal. O caractere force pode ser definido para qualquer outro caractere com o escape `~s`, o que significa "definir uma variável."

Digite `~sforce=_single-char_` seguido por uma nova linha. Onde _single-char_ é qualquer caractere único. Se o _single-char_ for omitido, o caractere force será o caractere nulo, que é acessado digitando-se kbd:[Ctrl+2] ou kbd:[Ctrl+Espace]. Um valor muito bom para _single-char_ é o kbd:[Shift+Ctrl+6], que é usado apenas em alguns servidores de terminal.

Para alterar o caractere force, especifique o seguinte em [.filename]#~/.tiprc#:

[.programlisting]
....
force=single-char
....

[[uppercase]]
=== Caracteres Maiúsculos

Isso acontece quando o kbd:[Ctrl+A] é pressionado, o qual corresponde ao `tip` "raise character", especialmente concebido para pessoas coma tecla de caps-lock quebrada. Use `~s` para definir `raisechar` para algo razoável. Ele pode ser configurado para ser o mesmo que o caractere de force, se nenhum recurso for usado.

Aqui está um exemplo do [.filename]#~/.tiprc# para os usuários do Emacs que precisam digitar kbd:[Ctrl+2] e kbd:[Ctrl+A]:

[.programlisting]
....
force=^^
raisechar=^^
....

O `^^` é kbd:[Shift+Ctrl+6].

[[tip-filetransfer]]
=== Transferências de Arquivos com `tip`

Ao falar com outro sistema operacional semelhante ao UNIX(TM), os arquivos podem ser enviados e recebidos usando `~p` (put) e `~t` (take). Esses comandos executam `cat` e `echo` no sistema remoto para aceitar e enviar arquivos. A sintaxe é:

`~p` local-file [ remote-file ]

`~t` remote-file [ local-file ]

Não há verificação de erros, então outro protocolo, como zmodem, provavelmente deveria ser usado.

[[zmodem-tip]]
=== Usando o zmodem com o `tip`?

Para receber arquivos, inicie o programa de envio no terminal remoto. Em seguida, digite `~C rz` para começar a recebê-los localmente.

Para enviar arquivos, inicie o programa de recebimento no terminal remoto. Em seguida, digite `~C sz _files_` para enviá-los ao sistema remoto.

[[serialconsole-setup]]
== Configurando o Console Serial

O FreeBSD tem a capacidade de inicializar um sistema com um terminal burro em uma porta serial como um console. Esta configuração é útil para administradores de sistemas que desejam instalar o FreeBSD em máquinas que não possuem teclado ou monitor conectados, e desenvolvedores que desejam depurar o kernel ou drivers de dispositivos.

Como descrito em crossref:boot[boot, O processo de inicialização do FreeBSD], o FreeBSD emprega um bootstrap de três estágios. Os dois primeiros estágios estão no código do bloco de inicialização que é armazenado no início da slice do FreeBSD no disco de inicialização. O bloco de inicialização, em seguida, carrega e executa o carregador de boot como o código do terceiro estágio.

Para configurar a inicialização a partir de um console serial, o código do bloco de inicialização, o código do carregador de inicialização e o kernel precisam ser configurados.

[[serialconsole-howto-fast]]
=== Configuração Rápida do Console Serial

Esta seção fornece uma visão geral rápida da configuração do console serial. Este procedimento pode ser usado quando o terminal burro é conectado ao [.filename]#COM1#.

[.procedure]
====
*Procedure: Configurando um Console Serial no [.filename]#COM1#*

. Conecte o cabo serial ao [.filename]#COM1# e ao terminal de controle.
. Para configurar mensagens de inicialização para exibição no console serial, emita o seguinte comando como o superusuário:
+
[source,shell]
....
# echo 'console="comconsole"' >> /boot/loader.conf
....
+
. Edite [.filename]#/etc/ttys# e mude `off` para `on` e `dialup` para `vt100` para a entrada [.filename]#ttyu0#. Caso contrário, uma senha não será necessária para conectar-se através do console serial, resultando em uma potencial brecha de segurança.
. Reinicialize o sistema para ver se as alterações entraram em vigor.
====

Se uma configuração diferente for necessária, consulte a próxima seção para obter uma explicação de configuração mais detalhada.

[[serialconsole-howto]]
=== Configuração do console serial em profundidade

Esta seção fornece uma explicação mais detalhada das etapas necessárias para configurar um console serial no FreeBSD.

[.procedure]
====
*Procedure: Configurando um Console Serial*

. Prepare um cabo serial.
+ 
Use um cabo de null-modem ou um cabo serial padrão e um adaptador de null-modem. Veja <<term-cables-null>> para uma discussão sobre cabos seriais.
. Desconecte o teclado.
+ 
Muitos sistemas detectam o teclado durante o Power-On Self-Test (POST) e geram um erro se o teclado não for detectado. Algumas máquinas recusarão a inicialização até que o teclado esteja conectado.
+ 
Se o computador reclamar do erro, mas inicializar de qualquer maneira, nenhuma outra configuração será necessária.
+ 
Se o computador se recusar a inicializar sem um teclado conectado, configure o BIOS para que ele ignore este erro. Consulte o manual da placa-mãe para obter detalhes sobre como fazer isso.
+
[TIP]
======

Tente configurar o teclado para "Not installed" no BIOS. Esta configuração diz ao BIOS para não detectar um teclado ao ligar, então ele não deve reclamar se o teclado estiver ausente. Se essa opção não estiver presente no BIOS, procure uma opção "Halt on Error". Configurando isto para "All but Keyboard" ou para "No Errors" terá o mesmo efeito.
======
+ 
Se o sistema tiver um mouse PS/2(TM), desconecte-o também. Os mouses PS/2(TM) compartilham algum hardware com o teclado e, deixar o mouse conectado, pode enganar o sistema e faze-lo pensar que o teclado ainda está lá.
+
[NOTE]
======
Embora a maioria dos sistemas inicialize sem um teclado, alguns não inicializarão sem um adaptador gráfico. Alguns sistemas podem ser configurados para inicializar sem nenhum adaptador gráfico alterando a configuração do "graphics adapter" na configuração BIOS para "Not installed". Outros sistemas não suportam esta opção e recusarão a inicialização se não houver hardware de exibição no sistema. Com estas máquinas, deixe algum tipo de placa gráfica ligada, mesmo que seja apenas uma placa mono lixo. Um monitor não precisa ser conectado.
======
+
. Conecte um terminal burro, um computador antigo com um programa de modem ou a porta serial de outra máquina UNIX(TM) na porta serial da máquina freebsd.
. Adicione as entradas `hint.sio.*` apropriadas para o [.filename]#/boot/device.hints# para a porta serial. Algumas placas com várias portas também exigem opções de configuração do kernel. Consulte man:sio[4] para obter as opções necessárias e os device hints para cada porta serial suportada.
. Crie o [.filename]#boot.config# no diretório raiz da partição `a` na unidade de inicialização.
+ 
Este arquivo instrui o código do bloco de inicialização como inicializar o sistema. Para ativar o console serial, uma ou mais das seguintes opções são necessárias. Ao usar várias opções, inclua todas elas na mesma linha:
+
`-h`:::
Alterna entre os consoles interno e serial. Use isso para alternar dispositivos do console. Por exemplo, para inicializar a partir do console (vídeo) interno, use `-h` para direcionar o carregador de boot e o kernel para usar a porta serial como seu dispositivo de console. Alternativamente, para inicializar a partir da porta serial, use `-h` para dizer ao gerenciador de inicialização e ao kernel para usar a exibição de vídeo como o console.

`-D`:::
Alterna entre as configurações de console única e dupla. Na configuração única, o console será o console interno (exibição de vídeo) ou a porta serial, dependendo do estado de `-h`. Na configuração do console duplo, a exibição de vídeo e a porta serial se tornarão o console ao mesmo tempo, independentemente do estado de `-h`. No entanto, a configuração do console duplo entrará em vigor somente enquanto o bloco de inicialização estiver em execução. Depois que o gerenciador de boot obtiver controle, o console especificado por `-h` se tornará o único console.

`-P`:::
Faz com que o bloco de inicialização avalie o teclado. Se nenhum teclado for encontrado, as opções `-D` e `-h` serão automaticamente definidas.
+
[NOTE]
======
Devido a restrições de espaço na versão atual dos blocos de inicialização, `-P` é capaz de detectar somente teclados estendidos. Teclados com menos de 101 teclas e sem as teclas F11 e F12 podem não ser detectados. Teclados em alguns laptops podem não ser encontrados corretamente devido a essa limitação. Se este for o caso, não use `-P`.
======
+ 
Use `-P` para selecionar o console automaticamente ou `-h` para ativar o console serial. Consulte man:boot[8] e man:boot.config[5] para maiores detalhes.
+ 
As opções, exceto para `-P`, são passadas para o carregador de boot. O gerenciador de boot determinará se o vídeo interno ou a porta serial deve se tornar o console examinando o estado de `-h`. Isto significa que se `-D` for especificado mas `-h` não estiver especificado no [.filename]#/boot.config#, a porta serial pode ser usada como console somente durante o bloco de inicialização, pois o gerenciador de inicialização usará a exibição de vídeo interna como o console.
. Inicialize a máquina.
+ 
Quando o FreeBSD inicia, os blocos de inicialização mostram o conteúdo do [.filename]#/boot.config# para o console. Por exemplo:
+
[source,shell]
....
/boot.config: -P
Keyboard: no
....
+ 
A segunda linha aparece somente se `-P` aparecer no [.filename]#/boot.config# e indica a presença ou ausência do teclado. Estas mensagens vão para o console serial ou interno, ou ambos, dependendo da opção em [.filename]#/boot.config#:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
<| Opções
<| Mensagem vai para

|nenhum
|console interno

|`-h`
|console serial

|`-D`
|consoles seriais e internos

|`-Dh`
|consoles seriais e internos

|`-P`, teclado presente
|console interno

|`-P`, teclado ausente
|console serial
|===
+ 
Após a mensagem, haverá uma pequena pausa antes que os blocos de inicialização continuem carregando o carregador de boot e antes que qualquer outra mensagem seja impressa no console. Em circunstâncias normais, não há necessidade de interromper os blocos de inicialização, mas pode-se fazê-lo para garantir que as coisas sejam configuradas corretamente.
+ 
Pressione qualquer tecla, exceto kbd:[Enter], no console para interromper o processo de inicialização. Os blocos de inicialização então solicitarão mais ações:
+
[source,shell]
....
>> FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....
+ 
Verifique se a mensagem acima aparece no console serial ou interno, ou em [.filename]#/boot.config#. Se a mensagem aparecer no console correto, pressione kbd:[Enter] para continuar o processo de inicialização.
+ 
Se não houver nenhum prompt no terminal serial, algo está errado com as configurações. Digite `-h` e depois kbd:[Enter] ou kbd:[Return] para informar o bloco de inicialização (e depois o carregador de inicialização e o kernel) para escolher a porta serial para o console. Quando o sistema estiver ativo, volte e verifique o que deu errado.
====

Durante o terceiro estágio do processo de inicialização, ainda é possível alternar entre o console interno e o console serial definindo as variáveis de ambiente apropriadas no carregador de inicialização. Veja man:loader[8] para obter maiores informações.

[NOTE]
====
Esta linha no [.filename]#/boot/loader.conf# ou [.filename]#/boot/loader.conf.local# configura o carregador de inicialização e o kernel para enviar suas mensagens de inicialização para o console serial, independentemente das opções no [.filename]#/boot.config#:

[.programlisting]
....
console="comconsole"
....

Esta linha deve ser a primeira linha do [.filename]#/boot/loader.conf# para que as mensagens de boot sejam exibidas no console serial o mais cedo possível.

Se essa linha não existir, ou se estiver definida como `console="vidconsole"`, o carregador de inicialização e o kernel usarão qualquer console indicado por `-h` no bloco de inicialização. Veja man:loader.conf[5] para maiores informações.

No momento, o carregador de boot não tem nenhuma opção equivalente a `-P` no bloco de inicialização, e não há provisão para selecionar automaticamente o console interno e o console serial com base na presença do teclado.
====

[TIP]
====

Embora não seja obrigatório, é possível fornecer um prompt `login` na linha serial. Para configurar isto, edite a entrada para a porta serial em [.filename]#/etc/ttys# usando as instruções em <<term-config>>. Se a velocidade da porta serial tiver sido alterada, altere `std.9600` para corresponder à nova configuração.
====

=== Defina uma velocidade de porta serial mais rápida

Por padrão, as configurações da porta serial são 9600 baud, 8 bits, sem paridade e 1 bit de parada. Para alterar a velocidade do console padrão, use uma das seguintes opções:

* Edite o [.filename]#/etc/make.conf# e configure o `BOOT_COMCONSOLE_SPEED` para a nova velocidade do console. Em seguida, recompile e instale os blocos de inicialização e o carregador de boot:
+
[source,shell]
....
# cd /sys/boot
# make clean
# make
# make install
....
+ 
Se o console serial estiver configurado de alguma outra maneira que não seja inicializando com `-h`, ou se o console serial usado pelo kernel for diferente daquele usado pelos blocos de inicialização, adicione a seguinte opção, com a velocidade desejada, em um arquivo de configuração de kernel personalizado e compile um novo kernel:
+
[.programlisting]
....
options CONSPEED=19200
....

* Acrescente a opção de inicialização `-S_19200_` ao [.filename]#/boot.config#, substituindo _19200_ pela velocidade a ser utilizada.
* Adicione as seguintes opções ao [.filename]#/boot/loader.conf#. Substitua _115200_ pela velocidade de uso.
+
[.programlisting]
....
boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"
....

[[serialconsole-ddb]]
=== Entrando no Depurador DDB da Linha Serial

Para configurar a capacidade de inserir o depurador de kernel no console serial, inclua as seguintes opções em um arquivo de configuração de kernel personalizado e compile o kernel usando as instruções em crossref:kernelconfig[kernelconfig, Configurando o kernel do FreeBSD]. Observe que, embora isso seja útil para diagnósticos remotos, também é perigoso se um BREAK espúrio for gerado na porta serial. Consulte man:ddb[4] e man:ddb[8] para mais informações sobre o depurador do kernel.

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....
