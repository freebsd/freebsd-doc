---
title: Capítulo 3. Fundamentos do FreeBSD
part: Parte I. Primeiros Passos
prev: books/handbook/bsdinstall
next: books/handbook/ports
---

[[basics]]
= Fundamentos do FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Índice
:table-caption: Tabela
:figure-caption: Figura
:example-caption: Exemplo
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 3

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/pt-br/mailing-lists.adoc[]
include::shared/pt-br/teams.adoc[]
include::shared/pt-br/urls.adoc[]

toc::[]

[[basics-synopsis]]
== Sinopse

Este capítulo cobre os comandos básicos e as funcionalidades do sistema operacional FreeBSD. Grande parte deste material é relevante para qualquer sistema operacional do tipo UNIX(TM). Novos usuários do FreeBSD são encorajados a ler este capítulo cuidadosamente.

Depois de ler este capítulo, você saberá:

* Como usar e configurar consoles virtuais.
* Como criar e gerenciar usuários e grupos no FreeBSD.
* Como funcionam as permissões de arquivo UNIX(TM) e as flags de arquivos do FreeBSD.
* O layout padrão do sistema de arquivos do FreeBSD.
* A organização do disco no FreeBSD.
* Como montar e desmontar sistemas de arquivos.
* O que são processos, daemons e sinais.
* O que é um shell e como alterar o ambiente de login padrão.
* Como usar editores de texto básicos.
* O que são devices e device nodes.
* Como ler páginas de manual para obter maiores informações.

[[consoles]]
== Consoles e Terminais Virtuais

A menos que o FreeBSD tenha sido configurado para iniciar automaticamente um ambiente gráfico durante a inicialização, o sistema inicializará em um prompt de login da linha de comando, como visto neste exemplo:

[source,bash]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

A primeira linha contém algumas informações sobre o sistema. O `amd64` indica que o sistema neste exemplo está executando uma versão de 64 bits do FreeBSD. O nome do host é `pc3.example.org`, e [.filename]#ttyv0# indica que este é o "console do sistema". A segunda linha é o prompt de login.

Como o FreeBSD é um sistema multiusuário, ele precisa de alguma maneira distinguir entre usuários diferentes. Isso é feito exigindo que todos os usuários façam login no sistema antes de obter acesso aos programas no sistema. Cada usuário tem um "nome de usuário" único e uma "senha" pessoal.

Para efetuar login no console do sistema, digite o nome de usuário que foi configurado durante a instalação do sistema, conforme descrito em crossref:bsdinstall[bsdinstall-addusers,Adicione usuários] e pressione kbd:[Enter]. Em seguida, insira a senha associada ao nome de usuário e pressione kbd:[Enter]. A senha não é _ecoada_ por razões de segurança.

Uma vez que a senha correta é inserida, a mensagem do dia (MOTD) será exibida, seguida de um prompt de comando. Dependendo do shell que foi selecionado quando o usuário foi criado, este prompt será um caractere `#`, `$` ou `%`. O prompt indica que o usuário está logado no console do sistema FreeBSD e pronto para testar os comandos disponíveis.

[[consoles-virtual]]
=== Consoles Virtuais

Enquanto o console do sistema pode ser usado para interagir com o sistema, um usuário trabalhando a partir da linha de comando no teclado de um sistema FreeBSD normalmente irá efetuar login em um console virtual. Isso ocorre porque as mensagens do sistema são configuradas por padrão para serem exibidas no console do sistema. Essas mensagens serão exibidas por cima do comando ou arquivo em que o usuário estiver trabalhando, dificultando a concentração no trabalho em questão.

Por padrão, o FreeBSD é configurado para fornecer vários consoles virtuais para a entrada de comandos. Cada console virtual tem seu próprio prompt de login e shell e é fácil alternar entre os consoles virtuais. Isso essencialmente fornece a linha de comando equivalente a ter várias janelas abertas ao mesmo tempo em um ambiente gráfico.

As combinações de teclas kbd:[Alt+F1] até a kbd:[Alt+F8] foram reservadas pelo FreeBSD para alternar entre os consoles virtuais. Use kbd:[Alt+F1] para alternar para o console do sistema ([.filename]#ttyv0#), kbd:[Alt+F2] para acessar o primeiro console virtual ([.filename]#ttyv1#), kbd:[Alt+F3] para acessar o segundo console virtual ([.filename]#ttyv2#) e assim por diante. Ao usar o Xorg como um console gráfico, a combinação kbd:[Ctrl+Alt+F1] é utilizada para retornar para um console virtual baseado em texto.

Ao mudar de um console para o próximo, o FreeBSD gerencia a saída da tela. O resultado é uma ilusão de ter várias telas virtuais e teclados que podem ser usados para digitar comandos para o FreeBSD rodar. Os programas executados em um console virtual não param de ser executados quando o usuário alterna para um console virtual diferente.

Consulte man:kbdcontrol[1], man:vidcontrol[1], man:atkbd:[4], man:syscons[4], e man:vt[4] para uma descrição mais técnica do console do FreeBSD e seus drivers de teclado.

No FreeBSD, o número de consoles virtuais disponíveis é configurado nesta seção do [.filename]#/etc/ttys#:

[.programlisting]
....
# name    getty                         type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Para desativar um console virtual, coloque um símbolo de comentário (`#`) no início da linha que representa esse console virtual. Por exemplo, para reduzir o número de consoles virtuais disponíveis de oito para quatro, coloque um `#` na frente das últimas quatro linhas que representam os consoles virtuais de [.filename]#ttyv5# até [.filename]#ttyv8#. _Não_ comente a linha do console do sistema [.filename]#ttyv0#. Note que o último console virtual ([.filename]#ttyv8#) é usado para acessar o ambiente gráfico se o Xorg tiver sido instalado e configurado conforme descrito em crossref:x11[x11, O sistema X Window].

Para uma descrição detalhada de cada coluna neste arquivo e as opções disponíveis para os consoles virtuais, consulte man:ttys[5].

[[consoles-singleuser]]
=== Modo "Single User"

O menu de inicialização do FreeBSD fornece uma opção chamada "Boot Single User". Se esta opção for selecionada, o sistema inicializará em um modo especial conhecido como "single user mode". Esse modo é normalmente usado para reparar um sistema que não inicializa ou para redefinir a senha de `root` quando ela é desconhecida. Quando em modo single user, a rede e outros consoles virtuais não estão disponíveis. No entanto, haverá acesso completo de `root` ao sistema e, por padrão, a senha de `root` não é necessária. Por estas razões, o acesso físico ao teclado é necessário para iniciar neste modo e determinar quem tem acesso físico ao teclado é algo a considerar ao proteger um sistema FreeBSD.

As configurações que controlam o modo de single user são encontradas nesta seção do [.filename]#/etc/ttys#:

[.programlisting]
....
# name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

Por padrão, o status é definido como `secure`. Isso pressupõe que quem tem acesso físico ao teclado não é importante ou é controlado por uma política de segurança física. Se essa configuração for alterada para `insecure`, a suposição é que o ambiente em si é inseguro porque qualquer pessoa pode acessar o teclado. Quando esta linha é alterada para `insecure`, o FreeBSD irá solicitar a senha do `root` quando um usuário selecionar inicializar no modo single user.

[NOTE]
====
__Tenha cuidado ao alterar esta configuração para ``inseguro``__! Se a senha do `root` for esquecida, a inicialização no modo single user ainda é possível, mas pode ser difícil para alguém que não esteja familiarizado com o processo de inicialização do FreeBSD.
====

[[consoles-vidcontrol]]
=== Alterar os modos de vídeo do console

O modo de vídeo padrão do console do FreeBSD pode ser ajustado para 1024x768, 1280x1024 ou qualquer outro tamanho suportado pelo chip gráfico e monitor. Para usar um modo de vídeo diferente, carregue o módulo `VESA`:

[source,bash]
....
# kldload vesa
....

Para determinar quais modos de vídeo são suportados pelo hardware, use man:vidcontrol[1]. Para obter uma lista de modos de vídeo suportados, execute o seguinte:

[source,bash]
....
# vidcontrol -i mode
....

A saída deste comando lista os modos de vídeo suportados pelo hardware. Para selecionar um novo modo de vídeo, especifique o modo usando man:vidcontrol[1] como o usuário `root` :

[source,bash]
....
# vidcontrol MODE_279
....

Se o novo modo de vídeo for aceitável, ele pode ser definido permanentemente na inicialização, adicionando-o ao [.filename]#/etc/rc.conf#:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== Usuários e Gerenciamento Básico de Contas

O FreeBSD permite que múltiplos usuários usem o computador ao mesmo tempo. Enquanto apenas um usuário pode se sentar em frente à tela e usar o teclado a qualquer momento, qualquer número de usuários pode efetuar o login no sistema através da rede. Para usar o sistema, cada usuário deve ter sua própria conta de usuário.

Este capítulo descreve:

* Os diferentes tipos de contas de usuários em um sistema FreeBSD.
* Como adicionar, remover e modificar contas de usuários.
* Como definir limites para controlar os recursos que usuários e grupos podem acessar.
* Como criar grupos e adicionar usuários como membros de um grupo.

[[users-introduction]]
=== Tipos de conta

Como todo acesso ao sistema FreeBSD é obtido usando contas e todos os processos são executados por usuários, o gerenciamento de usuários e contas é importante.

Existem três tipos principais de contas: contas do sistema, contas de usuário e a conta de superusuário.

[[users-system]]
==== Contas do sistema

As contas do sistema são usadas para executar serviços como DNS, correio e servidores web. A razão para isso é a segurança; se todos os serviços fossem executados como superusuário, eles poderiam agir sem restrições.

Exemplos de contas do sistema são `daemon`, `operador`, `bind`, `news`, e `www`.

[WARNING]
====

É necessário ter cuidado ao usar o grupo operator, pois privilégios de acesso como o de superusuário podem ser concedidos, incluindo e não limitado a, desligamento, reinicialização e acesso a todos os itens em [.filename]#/dev# para o grupo.
====

A `nobody` é uma conta genérica sem privilégios do sistema. No entanto, quanto mais serviços usarem `nobody`, a mais arquivos e processos esse usuário será associado e, portanto, mais privilegiado esse usuário se tornará.

[[users-user]]
==== Contas de usuário

As contas de usuários são atribuídas a pessoas reais e são usadas para efetuar login e usar o sistema. Todas as pessoas que acessam o sistema devem ter uma conta de usuário exclusiva. Isso permite que o administrador descubra quem está fazendo o que e impede que usuários alterem as configurações de outros usuários.

Cada usuário pode configurar seu próprio ambiente para adequar o sistema ao seu uso, utilizando suas opções padrão para o shell, editor, atalhos de teclado e idioma.

Cada conta de usuário em um sistema FreeBSD tem certas informações associadas:

Nome de usuário::
O nome do usuário é digitado no prompt `login:`. Cada usuário deve ter um nome de usuário exclusivo. Existem diversas regras para criar nomes de usuário válidos que estão documentadas em man:passwd[5]. Recomenda-se usar nomes de usuário que tenham oito ou menos caracteres, todos os caracteres devem ser minúsculos para manter a compatibilidade com aplicativos legados.

Senha::
Cada conta tem uma senha associada.

ID do usuário (UID)::
O ID do Usuário (UID) é um número usado para identificar unicamente o usuário no sistema FreeBSD. Comandos que permitem que um nome de usuário seja especificado o converterão para o UID. Recomenda-se usar um UID menor que 65535, já que valores mais altos podem causar problemas de compatibilidade com alguns softwares.

ID do grupo (GID)::
O ID do grupo (GID) é um número usado para identificar unicamente o grupo principal ao qual o usuário pertence. Os grupos são um mecanismo para controlar o acesso a recursos com base no GID de um usuário, em vez de no seu UID. Isso pode reduzir significativamente o tamanho de alguns arquivos de configuração e permite que os usuários sejam membros de mais de um grupo. Recomenda-se usar um GID de 65535 ou inferior, pois GIDs mais altos podem não funcionar com alguns softwares.

Classe de login::
As classes de login são uma extensão do mecanismo de grupo que fornece flexibilidade adicional ao configurar o sistema para diferentes usuários. As classes de login são discutidas em crossref:security[users-limiting,Configurando Classes de Login].

Tempo para mudança de senha::
Por padrão as senhas não expiram. No entanto, a expiração de senha pode ser ativada por usuário, forçando alguns ou todos os usuários a alterar suas senhas após um determinado período de tempo.

Tempo de expiração da conta::
Por padrão o FreeBSD não expira contas. Ao criar contas que precisam de uma vida útil limitada, como contas de alunos em uma escola, especifique a data de expiração da conta usando o man:pw[8]. Após o tempo de expiração, a conta não poderá ser usada para efetuar login no sistema, embora os diretórios e arquivos da conta permaneçam no servidor.

Nome completo do usuário::
O nome de usuário identifica a conta de forma única para o FreeBSD, mas não reflete necessariamente o nome real do usuário. Semelhante a um comentário, essas informações podem conter espaços, caracteres maiúsculos e ter mais de oito caracteres.

Diretório Inicial (home)::
O diretório "home" é um caminho completo para um diretório no sistema. Este é o diretório inicial do usuário quando o usuário faz o login. Uma convenção comum é colocar todos os diretórios home dos usuários em [.filename]#/home/username# ou [.filename]#/usr/home/username#. Cada usuário armazena seus arquivos e subdiretórios pessoais em seu próprio diretório home.

Shell do usuário::
O shell fornece o ambiente padrão do usuário para interagir com o sistema. Existem muitos tipos diferentes de shells e usuários experientes terão suas próprias preferências, que podem ser refletidas nas suas configurações da conta.

[[users-superuser]]
==== A conta de superusuário

A conta de superusuário, geralmente chamada de `root`, é usada para gerenciar o sistema sem limitações de privilégios. Por este motivo, não deve ser usado para tarefas do dia-a-dia, como enviar e receber e-mail, exploração geral do sistema ou programação.

O superusuário, ao contrário de outras contas de usuário, pode operar sem limites, e o uso indevido da conta de superusuário pode resultar em desastres espetaculares. As contas de usuário não podem destruir o sistema operacional por engano, por isso é recomendável fazer o login como uma conta de usuário e se tornar o superusuário somente quando um comando exigir privilégios extras.

Sempre cheque duas ou três vezes todos os comandos emitidos como superusuário, pois um espaço extra ou um caractere ausente pode causar uma perda de dados irreparável.

Existem várias maneiras de obter privilégios de superusuário. Embora seja possível efetuar login como `root`, isso é altamente desencorajado.

Em vez disso, use man:su[1] para se tornar o superusuário. Se `-` for especificado ao executar este comando, o usuário também herdará o ambiente do usuário root. O usuário que executa este comando deve estar no grupo `wheel` ou o comando falhará. O usuário também deve saber a senha da conta de usuário `root`.

Neste exemplo, o usuário só se torna superusuário para executar `make install`, pois isso requer privilégios de superusuário. Quando o comando é concluído, o usuário digita `exit` para deixar a conta de superusuário e retornar à sua conta de usuário.

.Instalar um programa como superusuário
[example]
====

[source,bash]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....

====

O framework integrado man:su[1] funciona bem para sistemas isolados ou redes pequenas com apenas um administrador. Uma alternativa é instalar o pacote ou port package:security/sudo[]. Este software fornece registro de atividades e permite ao administrador configurar quais usuários podem executar quais comandos como superusuário.

[[users-modifying]]
=== Gerenciando Contas

O FreeBSD fornece uma variedade de diferentes comandos para gerenciar contas de usuários. Os comandos mais comuns são descritos em <<users-modifying-utilities>>, seguidos por alguns exemplos de seu uso. Veja a página de manual para cada utilitário para maiores detalhes e exemplos de uso.

[[users-modifying-utilities]]
.Utilitários para gerenciar contas de usuários
[cols="1,1", frame="none", options="header"]
|===
| Comando
| Resumo

|man:adduser[8]
|Aplicativo de linha de comando recomendado para adicionar novos usuários.

|man:rmuser[8]
|Aplicativo de linha de comando recomendado para remover usuários.

|man:chpass[1]
|Uma ferramenta flexível para alterar as informações do usuário.

|man:passwd[1]
|Ferramenta de linha de comando para alterar senhas de usuários.

|man:pw[8]
|Uma ferramenta poderosa e flexível para modificar todos os aspectos das contas de usuário.
|===

[[users-adduser]]
==== `adduser`

O programa recomendado para adicionar novos usuários é o man:adduser[8]. Quando um novo usuário é adicionado, este programa atualiza automaticamente o [.filename]#/etc/passwd# e o [.filename]#/etc/group#. Ele também cria um diretório inicial para o novo usuário, copia os arquivos de configuração padrão de [.filename]#/usr/shared/skel# e pode, opcionalmente, enviar uma nova mensagem de boas-vindas ao novo usuário. Este utilitário deve ser executado como o superusuário.

O utilitário man:adduser[8] é interativo e percorre as etapas para criar uma nova conta de usuário. Como visto em <<users-modifying-adduser>>, insira as informações necessárias ou pressione kbd:[Enter] para aceitar o valor padrão mostrado entre colchetes. Neste exemplo, o usuário foi convidado para o grupo `wheel`, permitindo que ele se tornasse o superusuário com o uso do man:su[1]. Quando terminar, o utilitário perguntará se deseja criar outro usuário ou finalizar o comando.

[[users-modifying-adduser]]
.Adicionando um usuário no FreeBSD
[example]
====

[source,bash]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
#
....

====

[NOTE]
====
Como a senha não é mostrada quando digitada, tenha cuidado para não digitar a senha incorretamente ao criar a conta do usuário.
====

[[users-rmuser]]
==== `rmuser`

Para remover completamente um usuário do sistema, execute o man:rmuser[8] como o superusuário. Este comando executa as seguintes etapas:

[.procedure]
====
. Remove a entrada man:crontab[1] do usuário, se existir.
. Remove todas as tarefas man:at[1] pertencentes ao usuário.
. Elimina todos os processos pertencentes ao usuário.
. Remove o usuário do arquivo de senhas do sistema.
. Opcionalmente, remove o diretório pessoal do usuário, se ele for de propriedade do usuário.
. Remove os arquivos de mensagens recebidas pertencentes ao usuário de [.filename]#/var/mail#.
. Remove todos os arquivos pertencentes ao usuário das áreas de armazenamento de arquivos temporários, como [.filename]#/tmp#.
. Finalmente, remove o nome de usuário de todos os grupos aos quais ele pertence em [.filename]#/etc/group#. Se um grupo ficar vazio e o nome do grupo for o mesmo que o nome de usuário, o grupo será removido. Isso complementa os grupos exclusivos por usuário criados por man:adduser[8].
====

O man:rmuser[8] não pode ser usado para remover contas de superusuário, pois isso quase sempre ocasiona uma de destruição em massa.

Por padrão, um modo interativo é usado, conforme mostrado no exemplo a seguir.

.Remoção de contas interativas com o `rmuser`
[example]
====

[source,bash]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#
....

====

[[users-chpass]]
==== `chpass`

Qualquer usuário pode usar o man:chpass[1] para alterar seu shell padrão e informações pessoais associadas à sua conta de usuário. O superusuário pode usar esse utilitário para alterar informações adicionais da conta de qualquer usuário.

Quando não há opções, além de um nome de usuário opcional, o man:chpass[1] exibe um editor contendo informações do usuário. Quando o usuário sai do editor, o banco de dados do usuário é atualizado com as novas informações.

[NOTE]
====
Este utilitário solicitará a senha do usuário ao sair do editor, a menos que o utilitário seja executado como superusuário.
====

Em <<users-modifying-chpass-su>>, o superusuário digitou `chpass jru` e agora está visualizando os campos que podem ser alterados para este usuário. Se `jru` executar este comando, apenas os últimos seis campos serão exibidos e estarão disponíveis para edição. Isso é mostrado em <<users-modifying-chpass-ru>>.

[[users-modifying-chpass-su]]
.Usando o `chpass` como superusuário
[example]
====

[source,bash]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[[users-modifying-chpass-ru]]
.Usando o `chpass` como usuário regular
[example]
====

[source,bash]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[NOTE]
====
Os comandos man:chfn[1] e man:chsh[1] são links para man:chpass[1], como são man:ypchpass[1], man:ypchfn[1]eman:ypchsh[1]. Já que o suporte ao NIS é automático, colocar o `yp` antes do comando não é necessário. Os procedimentos para configurar o NIS está documentado em crossref:network-servers[network-servers, Servidores de Rede].
====

[[users-passwd]]
==== `passwd`

Qualquer usuário pode alterar facilmente sua senha usando o man:passwd[1]. Para prevenir alterações acidentais ou não autorizadas, este comando irá solicitar a senha atual ao usuário antes de configurar uma nova senha:

.Alterando Sua Senha
[example]
====

[source,bash]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

O superusuário pode alterar a senha de qualquer usuário especificando o nome de usuário ao executar o man:passwd[1]. Quando este utilitário é executado como superusuário, ele não solicita a senha atual do usuário. Isso permite que a senha seja alterada quando um usuário não consegue lembrar a senha original.

.Mudando a senha de outro usuário como superusuário
[example]
====

[source,bash]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

[NOTE]
====
Como com o man:chpass[1], o man:yppasswd[1] é um link para man:passwd[1], então o NIS funciona com ambos os comandos.
====

[[users-pw]]
==== `pw`

O utilitário man:pw[8] pode criar, remover, modificar e exibir usuários e grupos. Funciona como um front-end para o usuário do sistema e para os arquivos de grupo. O man:pw[8] tem um conjunto muito poderoso de opções de linha de comando que o torna adequado para uso em shell scripts, mas novos usuários podem achar isso mais complicado que os outros comandos apresentados nesta seção.

[[users-groups]]
=== Gerenciando Grupos

Um grupo é uma lista de usuários. Um grupo é identificado pelo nome do grupo e pelo GID. No FreeBSD, o kernel usa o UID de um processo, e a lista de grupos a que pertence, para determinar o que o processo pode fazer. Na maioria das vezes, o GID de um usuário ou processo geralmente significa o primeiro grupo na lista.

O mapeamento do nome do grupo para o GID está listado em [.filename]#/etc/group#. Este é um arquivo de texto simples com quatro campos delimitados por dois pontos. O primeiro campo é o nome do grupo, o segundo é a senha criptografada, o terceiro é o GID e o quarto é a lista de membros delimitados por vírgulas. Para uma descrição mais completa da sintaxe, consulte man:group[5].

O superusuário pode modificar o [.filename]#/etc/group# usando um editor de texto. Alternativamente, o man:pw[8] pode ser usado para adicionar e editar grupos. Por exemplo, para adicionar um grupo chamado `teamtwo` e confirmar se ele existe:

.Adicionando um grupo usando o man:pw[8]
[example]
====

[source,bash]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....

====

Neste exemplo, `1100` é o GID de `teamtwo`. No momento, `teamtwo` não possui membros. Este comando adicionará `jru` como um membro de `teamtwo`.

.Adicionando contas de usuários a um novo grupo usando o man:pw[8]
[example]
====

[source,bash]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....

====

O argumento para a opção `-M` é uma lista de usuários, delimitada por vírgulas, a serem adicionados a um novo grupo (vazio) ou para substituir os membros de um grupo existente. Para o usuário, essa associação ao grupo é diferente (e adicional ao) do grupo principal do usuário listado no arquivo de senha. Isso significa que o usuário não aparecerá como membro ao usar a opção `groupshow` com o man:pw[8], mas mostrará quando a informação é consultada via man:id[1] ou uma ferramenta similar. Quando o man:pw[8] é usado para adicionar um usuário a um grupo, ele apenas manipula o [.filename]#/etc/group# e não tenta ler dados adicionais do [.filename]#/etc/passwd#.

.Adicionando um novo membro a um grupo usando o man:pw[8]
[example]
====

[source,bash]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....

====

Neste exemplo, o argumento para `-m` é uma lista delimitada por vírgulas de usuários que devem ser adicionados ao grupo. Ao contrário do exemplo anterior, esses usuários são adicionados ao grupo e não substituem usuários existentes no grupo.

.Usando o man:id[1] para determinar a associação ao grupo
[example]
====

[source,bash]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....

====

Neste exemplo, `jru` é um membro dos grupos `jru` e `teamtwo`.

Para obter mais informações sobre este comando e o formato do [.filename]#/etc/group#, consulte man:pw[8] e man:group[5].

[[permissions]]
== Permissões

No FreeBSD, todo arquivo e diretório tem um conjunto associado de permissões e vários utilitários estão disponíveis para visualizar e modificar essas permissões. É necessário entender como as permissões funcionam para garantir que os usuários consigam acessar os arquivos que precisam e não consigam acessar os arquivos usados pelo sistema operacional ou de propriedade de outros usuários.

Esta seção discute as permissões UNIX(TM) tradicionais usadas no FreeBSD. Para um controle de acesso ao sistema de arquivos mais refinado, consulte crossref:security[fs-acl,Listas de Controle de Acesso].

No UNIX(TM), as permissões básicas são atribuídas usando três tipos de acesso: ler, escrever e executar. Esses tipos de acesso são usados para determinar o acesso do arquivo ao proprietário, ao grupo e a outros usuários do arquivo (todos os outros). As permissões de leitura, gravação e execução podem ser representadas como as letras `r`, `w` e `x`. Elas também podem ser representados como números binários, pois cada permissão está ativada ou desativada (`0`). Quando representada como um número, a ordem é sempre lida como `rwx`, onde `r` é ativado com o valor `4`, `w` é ativado com o valor `2` e `x` é ativado com o valor `1`.

A Tabela 4.1 resume as possíveis possibilidades numéricas e alfabéticas. Ao ler a coluna "Listagem do Diretório", um `-` é usado para representar uma permissão que está desativada.

.Permissões UNIX(TM)
[cols="1,1,1", frame="none", options="header"]
|===
| Valor
| Permissão
| Listagem de diretório

|0
|Sem leitura, sem escrita, sem execução
|`---`

|1
|Sem leitura, sem escrita, execução
|`--x`

|2
|Sem leitura, escrita, sem execução
|`-w-`

|3
|Sem leitura, escrita, execução
|`-wx`

|4
|Leitura, sem escrita, sem execução
|`r--`

|5
|Leitura, sem escrita, execução
|`r-x`

|6
|Leitura, escrita, sem execução
|`rw-`

|7
|Leitura, escrita, execução
|`rwx`
|===

Use o argumento `-l` com o man:ls[1] para exibir uma lista longa de diretórios que inclua uma coluna de informações sobre um permissões do arquivo para o proprietário, grupo e outros. Por exemplo, um `ls -l` em um diretório arbitrário pode mostrar:

[source,bash]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
....

O primeiro caractere (mais à esquerda) da primeira coluna indica se esse arquivo é um arquivo normal, um diretório, um dispositivo de caractere especial, um soquete ou qualquer outro dispositivo especial de pseudo-arquivo. Neste exemplo, o `-` indica um arquivo regular. Os próximos três caracteres, `rw-` neste exemplo, fornecem as permissões para o proprietário do arquivo. Os próximos três caracteres, `r--`, fornecem as permissões para o grupo ao qual o arquivo pertence. Os três últimos caracteres, `r--`, dão as permissões para o resto do mundo. Um traço significa que a permissão está desativada. Neste exemplo, as permissões são definidas para que o proprietário possa ler e gravar no arquivo, o grupo possa ler o arquivo e o resto do mundo só possa ler o arquivo. De acordo com a tabela acima, as permissões para este arquivo seriam `644`, onde cada dígito representa uma das três partes da permissão do arquivo.

Como o sistema controla as permissões nos dispositivos? O FreeBSD trata a maioria dos dispositivos de hardware como um arquivo nos quais os programas podem abrir, ler e gravar dados. Esses arquivos de dispositivos especiais são armazenados em [.filename]#/dev/#.

Diretórios também são tratados como arquivos. Eles tem permissões de leitura, gravação e execução. O bit executável de um diretório tem um significado ligeiramente diferente que nos arquivos. Quando um diretório é marcado como executável, isso significa que é possível mudar para esse diretório usando man:cd[1]. Isso também significa que é possível acessar os arquivos dentro desse diretório, sujeito às permissões dos próprios arquivos.

Para executar uma listagem de diretórios, a permissão de leitura deve estar ativada no diretório. Para deletar um arquivo que se conhece o nome, é necessário ter permissões de escrita _e_ execução no diretório que contém o arquivo.

Há mais bits de permissão, mas eles são usados principalmente em circunstâncias especiais, como binários setuid e diretórios fixos. Para obter mais informações sobre permissões de arquivos e como configurá-las, consulte man:chmod[1].

=== Permissões simbólicas

Permissões simbólicas usam caracteres em vez de valores octais para atribuir permissões a arquivos ou diretórios. Permissões simbólicas usam a sintaxe de (quem) (ação) (permissões), onde os seguintes valores estão disponíveis:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Opção
| Letra
| Representa

|(quem)
|u
|Usuário

|(quem)
|g
|Grupo

|(quem)
|o
|Outros

|(quem)
|a
|Todos ("resto do mundo")

|(açao)
|+
|Adiciona permissões

|(açao)
|-
|Remove permissões

|(açao)
|=
|Permissões definidas explicitamente

|(permissões)
|r
|Leitura

|(permissões)
|w
|Escrita

|(permissões)
|x
|Execução

|(permissões)
|t
|bit fixador

|(permissões)
|s
|Set UID ou GID
|===

Esses valores são usados com o man:chmod[1], mas com letras em vez de números. Por exemplo, o comando a seguir impediria que outros usuários acessassem _FILE_:

[source,bash]
....
% chmod go= FILE
....

Uma lista separada por vírgula pode ser fornecida quando mais de um conjunto de alterações em um arquivo precisar ser feito. Por exemplo, o comando a seguir remove as permissões de gravação do grupo e "resto do mundo" no _FILE_ e adiciona as permissões de execução para todos:

[source,bash]
....
% chmod go-w,a+x FILE
....

=== Flags de arquivos no FreeBSD

Além das permissões de arquivo, o FreeBSD suporta o uso de "flags de arquivo". Esses sinalizadores adicionam um nível a mais de segurança e controle sobre os arquivos, mas não nos diretórios. Com flags de arquivos, mesmo o `root` pode ser impedido de remover ou alterar arquivos.

Os sinalizadores de arquivo são modificados usando o man:chflags[1]. Por exemplo, para ativar o sinalizador undeletable do sistema no arquivo [.filename]#file1#, use o seguinte comando:

[source,bash]
....
# chflags sunlink file1
....

Para desabilitar o sinalizador undeletable do sistema, coloque um "no" na frente do `sunlink`:

[source,bash]
....
# chflags nosunlink file1
....

Para visualizar os sinalizadores de um arquivo, use `-lo` com o man:ls[1]:

[source,bash]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r-- 1 trhodes trhodes sunlnk 0 Mar 1 05:54 file1
....

Vários flags de arquivo só podem ser adicionados ou removidos pelo usuário `root`. Em outros casos, o proprietário do arquivo pode definir seus sinalizadores. Consulte man:chflags[1] e man:chflags[2] para maiores informações.

=== As permissões `setuid`, `setgid` e `sticky`

Além das permissões já discutidas, existem três outras configurações específicas que todos os administradores devem conhecer. Eles são as permissões `setuid`, `setgid` e `sticky`.

Essas configurações são importantes para algumas operações UNIX(TM), pois fornecem funcionalidades normalmente não concedidas a usuários normais. Para compreendê-los, a diferença entre o ID real de usuário e o ID efetivo de usuário deve ser explicada.

O ID de usuário real é o UID que inicia ou é o dono do processo. O ID de usuário efetivo é o UID do usuário com o qual o processo é executado. Por exemplo, o man:passwd[1] é executado com o ID do usuário real quando um usuário altera sua senha. No entanto, para atualizar o banco de dados de senhas, o comando é executado como o ID efetivo do usuário `root`. Isso permite que os usuários alterem suas senhas sem ver um erro `Permission Denied`.

A permissão setuid pode ser definida prefixando um conjunto de permissões com o número quatro (4), conforme mostrado no exemplo a seguir:

[source,bash]
....
# chmod 4755 suidexample.sh
....

As permissões em [.filename]#suidexample.sh# agora se parecem com o seguinte:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Observe que um `s` agora faz parte do conjunto de permissões designado para o proprietário do arquivo, substituindo o bit executável. Isso viabiliza utilitários que precisam de permissões elevadas, como o man:passwd[1].

[NOTE]
====
A opção `nosuid` man:mount[8] fará com que esses binários falhem silenciosamente sem alertar o usuário. Essa opção não é totalmente confiável, já que um wrapper `nosuid` pode contorná-la.
====

Para ver isso em tempo real, abra dois terminais. Em um deles, digite `passwd` como um usuário normal. Enquanto aguarda uma nova senha, verifique a tabela de processos e observe as informações de usuário do man:passwd[1]:

No terminal A:

[source,bash]
....
Changing local password for trhodes
Old Password:
....

No terminal B:

[source,bash]
....
# ps aux | grep passwd
....

[source,bash]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Embora man:passwd[1] seja executado como um usuário normal, ele está usando o UID do `root`.

A permissão `setgid` executa a mesma função que a permissão `setuid`; exceto que altera as configurações do grupo. Quando um aplicativo ou utilitário é executado com essa configuração, ele recebe as permissões com base no grupo do arquivo, não no usuário que iniciou o processo.

Para definir a permissão `setgid` em um arquivo, execute o man:chmod[1] com dois (2) no início:

[source,bash]
....
# chmod 2755 sgidexample.sh
....

Na listagem a seguir, observe que o `s` está agora no campo designado para as configurações de permissão do grupo:

[source,bash]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
Nestes exemplos, mesmo que o shell script em questão seja um arquivo executável, ele não será executado com um EUID diferente ou um ID de usuário efetivo. Isso ocorre porque os shell scripts podem não acessar as chamadas de sistema man:setuid[2].
====

Os bits de permissão `setuid` e `setgid` podem diminuir a segurança do sistema, permitindo permissões elevadas. A terceira permissão especial, o `sticky bit`, pode fortalecer a segurança de um sistema.

Quando o `sticky bit` é definido em um diretório, ele permite a exclusão de arquivos apenas pelo proprietário do arquivo. Isso é útil para impedir a exclusão de arquivos em diretórios públicos, como [.filename]#/tmp#, por usuários que não possuem o arquivo. Para utilizar essa permissão, use o um (1) no início das permissões:

[source,bash]
....
# chmod 1777 /tmp
....

A permissão `sticky bit` será exibida como um `t` no final do conjunto de permissões:

[source,bash]
....
# ls -al / | grep tmp
....

[source,bash]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== Estrutura de Diretórios

Entender a hierarquia de diretórios do FreeBSD é fundamental para obter uma compreensão geral do sistema. O diretório mais importante é o root ou raiz ou "/". Esse diretório é o primeiro montado no momento da inicialização e contém a base do sistema necessária para preparar o sistema operacional para a operação multi-usuário. O diretório raiz também contém pontos de montagem para outros sistemas de arquivos que são montados durante a transição para a operação multi-usuário.

Um ponto de montagem é um diretório no qual sistemas de arquivos adicionais podem ser disponibilizados em um sistema de arquivos principal (geralmente o sistema de arquivos raiz). Isso é descrito em <<disk-organization>>. Os pontos de montagem padrão incluem [.filename]#/usr/#, [.filename]#/var/#, [.filename]#/tmp/#, [.filename]#/mnt/# e [.filename]#/cdrom/#. Esses diretórios são geralmente associados a entradas em [.filename]#/etc/fstab#. Este arquivo é uma tabela de vários sistemas de arquivos e pontos de montagem e é lido pelo sistema. A maioria dos sistemas de arquivos em [.filename]#/etc/fstab# é montada automaticamente no momento da inicialização do script man:rc[8] a não ser que haja a opção `noauto`. Maiores detalhes em <<disks-fstab>>.

Uma descrição completa da hierarquia do sistema de arquivos está disponível em man:hier[7]. A tabela a seguir fornece uma visão geral dos diretórios mais comuns.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Diretório
| Descrição

|[.filename]#/#
|Diretório raiz do sistema de arquivos.

|[.filename]#/bin/#
|Utilitários de usuário fundamentais para ambientes mono e multi-usuário.

|[.filename]#/boot/#
|Programas e arquivos de configuração usados durante o bootstrap do sistema operacional.

|[.filename]#/boot/defaults/#
|Arquivos de configuração de inicialização padrão. Consulte man:loader.conf[5] para maiores detalhes.

|[.filename]#/dev/#
|Nós de dispositivo (device nodes). Consulte man:intro[4] para detalhes.

|[.filename]#/etc/#
|Arquivos de configuração do sistema e scripts.

|[.filename]#/etc/defaults/#
|Arquivos padrão de configuração do sistema. Consulte man:rc[8] para maiores detalhes.

|[.filename]#/etc/mail/#
|Arquivos de configuração para agentes de transporte de mensagens, como o man:sendmail[8].

|[.filename]#/etc/periodic/#
|Scripts que são executados diariamente, semanalmente e mensalmente, por meio do man:cron[8]. Consulte man:periodic[8] para maiores detalhes.

|[.filename]#/etc/ppp/#
|Arquivos de configuração do man:ppp[8].

|[.filename]#/mnt/#
|Diretório vazio comumente usado pelos administradores do sistema como um ponto de montagem temporário.

|[.filename]#/proc/#
|Sistema de arquivos de processos. Consulte man:procfs[5], man:mount_procfs[8] para detalhes.

|[.filename]#/rescue/#
|Programas vinculados estaticamente para recuperação de emergência, conforme descrito em man:rescue[8].

|[.filename]#/root/#
|Diretório da conta `root`.

|[.filename]#/sbin/#
|Programas do sistema e utilitários de administração fundamentais para ambientes mono e multi-usuário.

|[.filename]#/tmp/#
|Arquivos temporários que normalmente _não_ são preservados em uma reinicialização do sistema. Um sistema de arquivos baseado em memória é frequentemente montado em [.filename]#/tmp#. Isso pode ser automatizado usando as variáveis relacionadas ao tmpmfs do man:rc.conf[5] ou com uma entrada em [.filename]#/etc/fstab#; consulte man:mdmfs[8] para maiores detalhes.

|[.filename]#/usr/#
|A maioria dos utilitários e aplicativos do usuário.

|[.filename]#/usr/bin/#
|Utilitários comuns, ferramentas de programação e aplicativos.

|[.filename]#/usr/include/#
|Arquivos para "include" do C padrão.

|[.filename]#/usr/lib/#
|Arquivos de biblioteca.

|[.filename]#/usr/libdata/#
|Diversos arquivos de dados de utilitários.

|[.filename]#/usr/libexec/#
|Daemons do sistema e utilitários do sistema executados por outros programas.

|[.filename]#/usr/local/#
|Executáveis e bibliotecas locais. Também é usado como o destino padrão para o framework do ports do FreeBSD. Dentro do [.filename]#/usr/local#, o layout geral esboçado por man:hier[7] para [.filename]#/usr# deve ser usado. Exceções são o diretório man, que está diretamente sob [.filename]#/usr/local# em vez de sob [.filename]#/usr/local/share#, e a documentação do ports está em [.filename]#share/doc/port#.

|[.filename]#/usr/obj/#
|Árvore de destino específica da arquitetura produzida pela construção da árvore [.filename]#/usr/src#.

|[.filename]#/usr/ports/#
|A Coleção de Ports do FreeBSD (opcional).

|[.filename]#/usr/sbin/#
|Daemons do sistema e utilitários do sistema executados pelos usuários.

|[.filename]#/usr/shared/#
|Arquivos independentes de arquitetura.

|[.filename]#/usr/src/#
|Arquivos do código-fonte do BSD.

|[.filename]#/var/#
|Arquivos de log de múltiplos propósitos, temporários, transientes e de spool. Um sistema de arquivos baseado em memória às vezes é montado em [.filename]#/var#. Isso pode ser automatizado usando as variáveis relacionadas ao varmfs em man:rc.conf[5] ou com uma entrada em [.filename]#/etc/fstab#; consulte man:mdmfs[8] para maiores detalhes.

|[.filename]#/var/log/#
|Diversos arquivos de log do sistema.

|[.filename]#/var/mail/#
|Arquivos de caixa de correio do usuário.

|[.filename]#/var/spool/#
|Diretórios de spooling de impressoras e sistemas de email.

|[.filename]#/var/tmp/#
|Arquivos temporários que geralmente são preservados em uma reinicialização do sistema, a menos que [.filename]#/var# seja um sistema de arquivos baseado em memória.

|[.filename]#/var/yp/#
|Mapas de NIS.
|===

[[disk-organization]]
== Organização dos Discos

A menor unidade de organização que o FreeBSD usa para encontrar arquivos é o nome do arquivo. Os nomes dos arquivos diferenciam maiúsculas de minúsculas, o que significa que [.filename]#readme.txt# e [.filename]#README.TXT# são dois arquivos distintos. O FreeBSD não usa a extensão de um arquivo para determinar se é um programa, documento ou alguma outra forma de dados.

Os arquivos são armazenados em diretórios. Um diretório pode não conter arquivos ou pode conter centenas deles. Um diretório também pode conter outros diretórios, permitindo uma hierarquia de diretórios entre si para organizar os dados.

Arquivos e diretórios são referenciados por meio de um nome, seguido por uma barra, `/`, seguido por qualquer outro nome de diretório que seja necessário. Por exemplo, se o diretório [.filename]#foo# contiver um diretório [.filename]#bar# que contenha o arquivo [.filename]#readme.txt#, o nome completo ou _caminho_, para o arquivo é [.filename]#foo/bar/readme.txt#. Observe que isso é diferente do Windows(TM) que usa `\` para separar nomes de arquivos e diretórios. O FreeBSD não usa letras de unidades ou outros nomes de unidades no caminho. Por exemplo, não se deve digitar [.filename]#c:\foo\bar\readme.txt# no FreeBSD.

Diretórios e arquivos são armazenados em um sistema de arquivos. Cada sistema de arquivos contém exatamente um diretório no nível superior, chamado de _diretório raiz_ para esse sistema de arquivos. Este diretório raiz pode conter outros diretórios. Um sistema de arquivos é designado como _sistema de arquivos raiz_ ou `/`. Todos os outros sistemas de arquivos são _montados_ no sistema de arquivos raiz. Não importa quantos discos estejam no sistema FreeBSD, cada diretório parece fazer parte do mesmo disco.

Considere três sistemas de arquivos, chamados `A`, `B` e `C`. Cada sistema de arquivos tem um diretório raiz, que contém dois outros diretórios, chamados `A1`, `A2` (e da mesma forma `B1`, `B2` e `C1`, `C2`).

Chame `A` de sistema de arquivos raiz. Se man:ls[1] for usado para visualizar o conteúdo deste diretório, ele mostrará dois subdiretórios, `A1` e `A2`. A árvore de diretórios tem esta aparência:

image::example-dir1.png[]

Um sistema de arquivos deve ser montado em um diretório em outro sistema de arquivos. Ao montar o sistema de arquivos `B` no diretório `A1`, o diretório raiz de `B` substitui `A1` e os diretórios em `B` aparecem de acordo:

image::example-dir2.png[]

Todos os arquivos que estão nos diretórios `B1` ou `B2` podem ser alcançados com o caminho [.filename]#/A1/B1# ou [.filename]#/A1/B2#, conforme necessário. Todos os arquivos que estavam em [.filename]#/A1# foram temporariamente ocultados. Eles reaparecerão se `B` for _desmontado_ de `A`.

Se `B` tivesse sido montado em `A2`, o diagrama ficaria assim:

image::example-dir3.png[]

e os caminhos seriam [.filename]#/A2/B1# e [.filename]#/A2/B2# respectivamente.

Os sistemas de arquivos podem ser montados uns em cima dos outros. Continuando o último exemplo, o sistema de arquivos `C` pode ser montado no topo do diretório `B1` no sistema de arquivos `B`, levando a esta disposição:

image::example-dir4.png[]

Ou `C` poderia ser montado diretamente no sistema de arquivos `A`, sob o diretório `A1`:

image::example-dir5.png[]

É perfeitamente possível ter um sistema de arquivos raiz grande e não precisar criar nenhum outro. Existem algumas desvantagens nessa abordagem e uma vantagem.

.Benefícios de vários sistemas de arquivos
* Sistemas de arquivos diferentes podem ter diferentes _opções de montagem_. Por exemplo, o sistema de arquivos raiz pode ser montado somente para leitura, impossibilitando que os usuários excluam ou editem inadvertidamente um arquivo crítico. Separar sistemas de arquivos graváveis pelo usuário, como [.filename]#/home#, de outros sistemas de arquivos permite que eles sejam montados como _nosuid_. Essa opção impede que os bits _suid_/_guid_ dos executáveis armazenados no sistema de arquivos entrem em vigor, possivelmente melhorando a segurança.
* O FreeBSD otimiza automaticamente o layout dos arquivos em um sistema de arquivos, dependendo de como o sistema de arquivos está sendo usado. Portanto, um sistema de arquivos que contém muitos arquivos pequenos que são gravados com freqüência terá uma otimização diferente para um que contenha menos arquivos maiores. Ao ter um sistema de arquivos maior, essa otimização é quebrada.
* Os sistemas de arquivos do FreeBSD são robustos se a energia for perdida. No entanto, uma perda de energia em um ponto crítico ainda pode danificar a estrutura do sistema de arquivos. Ao dividir dados em vários sistemas de arquivos, é mais provável que o sistema ainda inicialize, facilitando a restauração do backup conforme necessário.

.Benefício de um sistema de arquivos único
* Os sistemas de arquivos são de tamanho fixo. Se você cria um sistema de arquivos quando instala o FreeBSD e dá a ele um tamanho específico, você pode descobrir mais tarde que precisa aumentar a partição. Isso não é facilmente realizado sem um backup, recriando o sistema de arquivos com o novo tamanho e, em seguida, restaurando os dados de backup.
+
[IMPORTANT]
====
O FreeBSD possui o comando man:growfs[8], que torna possível aumentar o tamanho do sistema de arquivos enquanto montado, removendo essa limitação.
====

Os sistemas de arquivos estão contidos em partições. Isto não tem o mesmo significado que o uso comum do termo partição (por exemplo, a partição MS-DOS(TM)), por causa da herança UNIX(TM) do FreeBSD. Cada partição é identificada por uma letra de `a` até `h`. Cada partição pode conter apenas um sistema de arquivos, o que significa que os sistemas de arquivos geralmente são descritos por seu ponto de montagem típico na hierarquia do sistema de arquivos ou pela letra da partição em que estão contidos.

O FreeBSD também usa espaço em disco para _espaço de swap_ para fornecer _memória virtual_. Isso permite que o seu computador se comporte como se tivesse muito mais memória do que realmente tem. Quando o FreeBSD fica sem memória, ele move alguns dos dados que não estão sendo usados atualmente para o espaço de swap, e os move de volta (removendo alguma outra coisa) quando precisa.

Algumas partições possuem certas convenções associadas a elas.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Partição
| Convenção

|`a`
|Normalmente contém o sistema de arquivos raiz.

|`b`
|Normalmente contém espaço de swap.

|`c`
|Normalmente o mesmo tamanho da slice que a envolve. Isso permite que os programas que precisem trabalhar na slice inteira, como um scanner de bloco defeituoso, trabalhem na partição `c`. Um sistema de arquivos normalmente não seria criado nessa partição.

|`d`
|A partição `d` costumava ter um significado especial associado a ela, mas isso foi descontinuado e `d` pode funcionar como qualquer partição normal.
|===

Os discos no FreeBSD são divididos em slices, referidas no Windows(TM) como partições, numeradas de 1 a 4. Estas são então divididas em partições, que contêm sistemas de arquivos, e são rotuladas usando letras.

Os números das slices seguem o nome do dispositivo, prefixado com um `s`, começando em 1. Então "da0__s1__" é a primeira slice na primeira unidade SCSI. Pode haver apenas quatro slices físicas em um disco, mas pode haver slices lógicas dentro de slices físicas do tipo apropriado. Essas slices estendidas são numeradas a partir de 5, então "ada0__s5__" é a primeira slice estendida no primeiro disco SATA. Esses dispositivos são usados por sistemas de arquivos que esperam ocupar uma slice.

Slices, unidades físicas "perigosamente dedicadas" e outras unidades contêm _partições_, que são representadas como letras de `a` até `h`. Esta letra é adicionada ao nome do dispositivo, então "da0__a__" é a partição `a` na primeira unidade `da`, que é "perigosamente dedicada". A "ada1s3__e__" é a quinta partição na terceira slice da segunda unidade de disco SATA.

Finalmente, cada disco no sistema é identificado. Um nome de disco começa com um código que indica o tipo de disco e, em seguida, um número, indicando qual é o disco. Ao contrário das slices, a numeração de discos começa em 0. Códigos usuais são listados em <<disks-naming>>.

Ao se referir a uma partição, inclua o nome do disco, `s`, o número da slice, em seguida, a letra da partição. Exemplos são mostrados em <<basics-disk-slice-part>>.

<<basics-concept-disk-model>> mostra um modelo conceitual de um layout de disco.

Ao instalar o FreeBSD, configure as slices de disco, crie partições dentro da slice a ser usada para o FreeBSD, crie um sistema de arquivos ou espaço de swap em cada partição e decida onde cada sistema de arquivos será montado.

[[disks-naming]]
.Nomes de dispositivos de disco
[cols="1,1", frame="none", options="header"]
|===
| Tipo de drive
| Nome do drive

|discos rígidos SATA e IDE
|`ada` ou `ad`

|Discos rígidos SCSI e dispositivos de armazenamento USB
|`da`

|drives de CD-ROMSATA e IDE
|`cd` ou `acd`

|Unidades SCSICD-ROM
|`cd`

|Unidades de disquete
|`fd`

|Unidades de CD-ROM não-padrão variadas
|`mcd` para CD-ROM Mitsumi e `scd` para dispositivos de CD-ROM Sony

|Unidades de fita SCSI
|`sa`

|Unidades de fita IDE
|`ast`

|Drives RAID
|Exemplos incluem `aacd` para Adaptec(TM) AdvancedRAID, `mlxd` e `mlyd` para Mylex(TM), `amrd` para AMI MegaRAID(TM), `idad` para Compaq Smart RAID, `twed` para 3ware(TM) RAID.
|===

[[basics-disk-slice-part]]
.Exemplo de Nomes de Disco, Slice e Partição
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Nome
| Significado

|`ada0s1a`
|A primeira partição (`a`) na primeira slice (`s1`) no primeiro disco SATA (`ada0`).

|`da1s2e`
|A quinta partição (`e`) na segunda slice (`s2`) no segundo disco SCSI (`da1`).
|===
====

[[basics-concept-disk-model]]
.Modelo conceitual de um disco
[example]
====
Este diagrama mostra a visão do FreeBSD do primeiro disco SATA conectado ao sistema. Suponha que o disco tenha 250 GB de tamanho e contenha uma slice de 80 GB e uma slice de 170 GB (partições MS-DOS(TM)). A primeira slice contém um sistema de arquivos Windows(TM)NTFS, [.filename]#C:#, e a segunda fatia contém uma instalação do FreeBSD. Este exemplo de instalação do FreeBSD possui quatro partições de dados e uma partição swap.

Cada uma das quatro partições contém um sistema de arquivos. A partição `a` é usada para o sistema de arquivos raiz, `d` para [.filename]#/var/#, `e` para [.filename]#/tmp/# e `f` para [.filename]#/usr/#. A letra de partição `c` refere-se à fatia inteira e, portanto, não é usada para partições comuns.

image::disk-layout.png[]

====

[[mount-unmount]]
== Montando e Desmontando Sistemas de Arquivos

O sistema de arquivos é melhor visualizado como uma árvore, enraizada, por assim dizer, em [.filename]#/#. O [.filename]#/dev#, [.filename]#/usr#, e os outros diretórios no diretório raiz são ramos, que podem ter suas próprias ramificações, como [.filename]#/usr/local# e assim por diante.

Existem várias razões para abrigar alguns desses diretórios em sistemas de arquivos separados. O [.filename]#/var# contém os diretórios [.filename]#log/#, [.filename]#spool/# e vários tipos de arquivos temporários e, como tal, podem encher. Encher completamente o sistema de arquivos raiz não é uma boa ideia, então separar o [.filename]#/var# do [.filename]#/# geralmente é vantajoso.

Outro motivo comum para colocar determinadas árvores de diretório em outros sistemas de arquivos é se elas forem ser armazenadas em discos físicos separados ou se são discos virtuais separados, tal como montagens de NFS (Network File System), descritas em crossref:network-servers[network-nfs,Network File System (NFS)] ou unidades de CD-ROM.

[[disks-fstab]]
=== O arquivo [.filename]#fstab#

Durante o processo de inicialização (crossref:boot[boot, O processo de inicialização do FreeBSD]), os sistemas de arquivos listados em [.filename]#/etc/fstab# são automaticamente montados, exceto pelas entradas que contêm `noauto`. Este arquivo contém entradas no seguinte formato:

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
Um nome de dispositivo existente, conforme explicado em <<disks-naming>>.

`mount-point`::
Um diretório existente no qual montar o sistema de arquivos.

`fstype`::
O tipo de sistema de arquivos para passar para o man:mount[8]. O sistema de arquivos padrão do FreeBSD é o `ufs`.

`options`::
`rw` para sistemas de arquivos de leitura/gravação, ou `ro` para sistemas de arquivos somente de leitura, seguidos por quaisquer outras opções que possam ser necessárias. Uma opção comum é `noauto` para sistemas de arquivos normalmente não montados durante a seqüência de inicialização. Outras opções estão listadas em man:mount[8].

`dumpfreq`::
Usado pelo man:dump[8] para determinar quais sistemas de arquivos requerem o dump. Se o campo estiver faltando, um valor zero será assumido.

`passno`::
Determina a ordem em que os sistemas de arquivos devem ser verificados. Os sistemas de arquivos que devem ser ignorados devem ter seu `passno` definido como zero. O sistema de arquivos raiz precisa ser verificado antes de todo o restante e deve ter seu `passno` definido como um. Os outros sistemas de arquivos devem ser configurados para valores maiores que um. Se mais de um sistema de arquivos tiver o mesmo `passno`, o man:fsck[8] tentará verificar os sistemas de arquivos em paralelo, se possível.

Consulte man:fstab[5] para obter maiores informações sobre o formato do [.filename]#/etc/fstab# e suas opções.

[[disks-mount]]
=== Usando o man:mount[8]

Os sistemas de arquivos são montados usando o comando man:mount[8]. A sintaxe mais básica é a seguinte:

[source,bash]
....
# mount device mountpoint
....

Este comando fornece muitas opções que são descritas em man:mount[8]. As opções mais usadas incluem:

.Opções de montagem
`-a`::
Monte todos os sistemas de arquivos listados em [.filename]#/etc/fstab#, exceto aqueles marcados como "noauto", excluídos pela opção `-t`, ou aqueles que já estão montados.

`-d`::
Faz tudo, exceto a chamada real do sistema de montagem. Esta opção é útil em conjunto com a opção `-v` para determinar o que o man:mount[8] está realmente tentando fazer.

`-f`::
Força a montagem de um sistema de arquivos sujo (perigoso) ou a revogação do acesso de gravação ao fazer o downgrade do status de montagem de um sistema de arquivos de leitura/gravação para somente leitura.

`-r`::
Monta o sistema de arquivos somente para leitura. Isso é idêntico ao uso de `-o ro`.

`-t` _fstype_::
Monta o tipo de sistema de arquivos especificado ou monta somente sistemas de arquivos do tipo especificado, se ``-a``estiver incluído. "ufs" é o tipo de sistema de arquivos padrão.

`-u`::
Atualiza as opções de montagem no sistema de arquivos.

`-v`::
Fica verboso (mostra mais informações).

`-w`::
Monta o sistema de arquivos para leitura/gravação.

As seguintes opções podem ser passadas para `-o` como uma lista separada por vírgula:

nosuid::
Não interprete flags setuid ou setgid no sistema de arquivos. Essa também é uma opção de segurança útil.

[[disks-umount]]
=== Usando o man:umount[8]

Para desmontar um sistema de arquivos use man:umount[8]. Esse comando usa um parâmetro que pode ser um ponto de montagem, um nome do dispositivo, `-a` ou `-A`.

Todos os usos aceitam `-f` para forçar a desmontagem e `-v` para ver mais informações. Atenção, em geral `-f` não é uma boa opção, pois pode travar o computador ou danificar os dados no sistema de arquivos.

Para desmontar todos os sistemas de arquivos montados, ou apenas os tipos de sistema de arquivos listados após `-t`, use `-a` ou `-A`. Note que `-A` não tenta desmontar o sistema de arquivos raiz.

[[basics-processes]]
== Processos e Daemons

O FreeBSD é um sistema operacional multitarefa. Cada programa em execução a qualquer momento é chamado de _processo_. Todo comando em execução inicia pelo menos um novo processo e há vários processos de sistema que são executados pelo FreeBSD.

Cada processo é identificado exclusivamente por um número chamado _ID do processo_ (PID). Semelhante aos arquivos, cada processo tem um proprietário e um grupo, e as permissões de proprietário e grupo são usadas para determinar quais arquivos e dispositivos o processo pode abrir. A maioria dos processos também possui um processo pai que os iniciou. Por exemplo, o shell é um processo e qualquer comando iniciado no shell é um processo que tem o shell como seu processo pai. A exceção é um processo especial chamado man:init[8] que é sempre o primeiro processo a rodar na inicialização e que sempre possui um PID de `1`.

Alguns programas não são projetados para serem executados com a entrada contínua do usuário e desconectam do terminal na primeira oportunidade. Por exemplo, um servidor da Web responde a solicitações da Web, em vez de entradas do usuário. Servidores de email são outro exemplo desse tipo de aplicativo. Esses tipos de programas são conhecidos como _daemons_. O termo daemon vem da mitologia grega e representa uma entidade que não é boa nem má, e que invisivelmente realiza tarefas úteis. É por isso que o mascote do BSD é o daemon de aparência alegre com tênis e um tridente.

Existe uma convenção para nomear programas que normalmente são executados como daemons com um "d" à direita. Por exemplo, BIND é o Berkeley Internet Name Domain, mas o programa real que é executado é `named`. O programa do servidor da web Apache é o `httpd` e o daemon de spooling da impressora de linha é o `lpd`. Esta é apenas uma convenção de nomenclatura. Por exemplo, o daemon de correio principal para o aplicativo Sendmail é o `sendmail` e não `maild`.

=== Visualizando Processos

Para ver os processos em execução no sistema, use o man:ps[1] ou o man:top[1]. Para exibir uma lista estática dos processos em execução no momento, seus PIDs, quanta memória eles estão usando e o comando com o qual eles foram iniciados, use o man:ps[1]. Para exibir todos os processos em execução e atualizar a exibição a cada poucos segundos para ver interativamente o que o computador está fazendo, use o man:top[1].

Por padrão, o man:ps[1] mostra apenas os comandos que estão em execução e que são de propriedade do usuário. Por exemplo:

[source,bash]
....
% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps
....

A saída do man:ps[1] é organizada em várias colunas. A coluna `PID` exibe o ID do processo. Os PIDs são atribuídos a partir de 1, vão até 99999, e depois retornam ao início. No entanto, um PID não é reatribuído se já estiver em uso. A coluna `TT` mostra o tty em que o programa está sendo executado e `STAT` mostra o estado do programa. `TIME` é a quantidade de tempo que o programa foi executado na CPU. Normalmente, esse não é o tempo decorrido desde que o programa foi iniciado, pois a maioria dos programas gasta muito tempo esperando que as coisas aconteçam antes que precisem gastar tempo na CPU. Finalmente, `COMMAND` é o comando que foi usado para iniciar o programa.

Várias opções diferentes estão disponíveis para alterar as informações exibidas. Um dos conjuntos mais úteis é `auxww`, onde `a` exibe informações sobre todos os processos em execução de todos os usuários, `u` exibe o nome de usuário e o uso de memória do proprietário do processo, `x` exibe informações sobre os processos do daemon e `ww` faz com que o man:ps[1] exiba a linha de comando completa para cada processo, em vez de truncá-la para caber na tela quando é muito longa.

A saída do man:top[1] é semelhante a abaixo:

[source,bash]
....
% top
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

A saída é dividida em duas seções. O cabeçalho (as primeiras cinco ou seis linhas) mostra o PID do último processo executado, as médias de carga do sistema (que são uma medida de quão ocupado o sistema está), o tempo de atividade do sistema desde a última reinicialização) e a hora atual. As outras informações no cabeçalho se relacionam com quantos processos estão sendo executados, quanta memória e swap estão em uso e quanto tempo o sistema está gastando em diferentes estados da CPU. Se o módulo do sistema de arquivos ZFS foi carregado, uma linha `ARC` indica a quantidade de dados que foram lidos do cache de memória, e não do disco.

Abaixo do cabeçalho há uma série de colunas contendo informações semelhantes à saída do man:ps[1], como o PID, nome de usuário, quantidade de tempo de CPU e o comando que iniciou o processo. Por padrão, o man:top[1] também exibe a quantidade de espaço de memória ocupada pelo processo. Isso é dividido em duas colunas: uma para o tamanho total e outra para o tamanho do residente. O tamanho total é a quantidade de memória que o aplicativo precisa e o tamanho de residente é o quanto ele está realmente usando agora.

O man:top[1] atualiza automaticamente a exibição a cada dois segundos. Um intervalo diferente pode ser especificado com `-s`.

[[basics-daemons]]
=== Matando Processos

Uma maneira de se comunicar com qualquer processo ou daemon em execução é enviar um _sinal_ usando o man:kill[1]. Existem vários sinais diferentes; alguns têm um significado específico, enquanto outros são descritos na documentação do comando. Um usuário só pode enviar um sinal para um processo que seja seu. Enviar um sinal para o processo de outra pessoa resultará em um erro de permissão negada. A exceção é o usuário `root`, que pode enviar sinais para os processos de qualquer pessoa.

O sistema operacional também pode enviar um sinal para um processo. Se um aplicativo estiver mal escrito e tentar acessar a memória que não deveria, o FreeBSD enviará ao processo o sinal de "Segmentation Violation" (`SIGSEGV`). Se uma aplicação foi escrita para usar a chamada de sistema man:alarm[3] para ser alertada após um período de tempo, será enviado o sinal "Alarm" (`SIGALRM`).

Dois sinais podem ser usados para interromper um processo: `SIGTERM` e `SIGKILL`. `SIGTERM` é a maneira educada de eliminar um processo, pois o processo pode ler o sinal, fechar quaisquer arquivos de log que possam estar abertos e tentar terminar o que está fazendo antes de desligar. Em alguns casos, um processo pode ignorar `SIGTERM` se estiver no meio de alguma tarefa que não pode ser interrompida.

`SIGKILL` não pode ser ignorado por um processo. Enviar um `SIGKILL` para um processo geralmente interromperá esse processo de uma vez por todas. .

Outros sinais comumente usados são `SIGHUP`, `SIGUSR1` e `SIGUSR2`. Como esses são sinais de finalidade geral, diferentes aplicativos responderão de maneira diferente.

Por exemplo, depois de alterar o arquivo de configuração de um servidor da Web, o servidor da Web precisa ser instruído a reler sua configuração. Reiniciar o `httpd` resultaria em um breve período de interrupção no servidor da web. Em vez disso, envie ao daemon o sinal `SIGHUP`. Esteja ciente de que diferentes daemons terão um comportamento diferente, então consulte a documentação do daemon para determinar se `SIGHUP` terá os resultados desejados.

[.procedure]
====
*Procedure: Enviando um sinal para um processo*

Este exemplo mostra como enviar um sinal para o man:inetd[8]. O arquivo de configuração do man:inetd[8] é o [.filename]#/etc/inetd.conf# e o man:inetd[8] irá reler este arquivo de configuração quando for enviado um `SIGHUP`.

. Encontre o PID do processo para enviar o sinal usando man:pgrep[1]. Neste exemplo, o PID do man:inetd[8] é 198:
+
[source,bash]
....
% pgrep -l inetd
198  inetd -wW
....
+
. Use o man:kill[1] para enviar o sinal. Como o man:inetd[8] é de propriedade do `root`, use o man:su[1] para se tornar `root` primeiro.
+
[source,bash]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
Como a maioria dos comandos UNIX(TM), o man:kill[1] não imprimirá nenhuma saída se for bem-sucedido. Se um sinal for enviado para um processo que não pertence ao usuário, a mensagem `kill: _PID_: Operation not permitted` será exibida. Errar o PID irá enviar o sinal para o processo errado, o que poderia ter resultados negativos, ou enviará o sinal para um PID que não esteja em uso no momento, resultando em o erro `kill: _PID_: No such process`.
+
[NOTE]
.Por que usar o `/bin/kill`?
======
Muitos shells fornecem o `kill` como um comando interno, o que significa que o shell enviará o sinal diretamente, em vez de executar o [.filename]#/bin/kill#. Esteja ciente de que diferentes shells possuem uma sintaxe diferente para especificar o nome do sinal a ser enviado. Em vez de tentar aprender todos eles, pode ser mais simples especificar explicitamente o uso do `/bin/kill`.
======
====

Ao enviar outros sinais, substitua `TERM` ou `KILL` pelo nome do sinal.

[IMPORTANT]
====
Matar um processo aleatório no sistema é uma má ideia. Em particular, o man:init[8], PID 1, é especial. Executar `/bin/kill -s KILL 1` é uma maneira rápida e não recomendada de desligar o sistema. _Sempre_ verifique os argumentos do man:kill[1]_antes_ de pressionar a tecla kbd:[Enter].
====

[[shells]]
== Shells

Um _shell_ fornece uma interface de linha de comandos para interagir com o sistema operacional. Um shell recebe comandos do canal de entrada e os executa. Muitos shells fornecem funções incorporadas para ajudar nas tarefas diárias, como gerenciamento de arquivos, referenciamento de arquivos, edição de linha de comando, macros de comando e variáveis de ambiente. O FreeBSD vem com vários shells, incluindo o shell Bourne (man:sh[1]) e o shell C estendido (man:tcsh[1]). Outros shells estão disponíveis na Coleção de Ports do FreeBSD, como o `zsh` e o `bash`.

O shell usado é realmente uma questão de gosto. Um programador C pode se sentir mais confortável com um shell semelhante ao C, como o man:tcsh[1]. Um usuário Linux(TM) pode preferir o `bash`. Cada shell tem propriedades únicas que podem ou não funcionar com o ambiente de trabalho preferido de um usuário, e é por isso que existe a opção de qual shell usar.

Um recurso de shell comum é a conclusão do nome do arquivo. Depois que um usuário digita as primeiras letras de um comando ou nome de arquivo e pressiona a tecla kbd:[Tab], o shell completa o restante do comando ou nome do arquivo. Considere dois arquivos chamados [.filename]#foobar# e [.filename]#football#. Para excluir [.filename]#foobar#, o usuário pode digitar `rm foo` e pressionar a tecla kbd:[Tab] para completar o nome do arquivo.

Mas se o shell mostrar apenas `rm foo`. Não foi possível completar o nome do arquivo porque ambos [.filename]#foobar# e [.filename]#football# começam com `foo`. Algumas shells emitem um sinal sonoro ou mostram todas as opções se houver mais de um nome. O usuário deve digitar mais caracteres para identificar o nome do arquivo desejado. Digitar um `t` e pressionar a tecla kbd:[Tab] novamente é suficiente para permitir que o shell determine qual nome de arquivo é desejado e preencha o resto.

Outra característica do shell é o uso de variáveis de ambiente. As variáveis de ambiente são um par de variável/chave armazenado no ambiente do shell. Esse ambiente pode ser lido por qualquer programa chamado pela shell e, portanto, contém muitas configurações de programas. <<shell-env-vars>> fornece uma lista de variáveis de ambiente comuns e seus significados. Observe que os nomes das variáveis de ambiente estão sempre em maiúsculas.
[[shell-env-vars]]
.Variáveis de Ambiente Comuns
[cols="1,1", frame="none", options="header"]
|===
| Variável
| Descrição

|`USER`
|Nome do usuário atual.

|`PATH`
|Lista de diretórios separados por dois pontos para pesquisa de binários (progamas).

|`DISPLAY`
|Nome de rede do display do Xorg para conexão, se disponível.

|`SHELL`
|O shell atual.

|`TERM`
|O nome do tipo de terminal do usuário. Usado para determinar os recursos do terminal.

|`TERMCAP`
|Acesso à base de dados dos códigos de escape do terminal para executar várias funções do terminal.

|`OSTYPE`
|Tipo de sistema operacional.

|`MACHTYPE`
|A arquitetura da CPU do sistema.

|`EDITOR`
|O editor de texto preferencial do usuário.

|`PAGER`
|O utilitário preferencial do usuário para visualização de texto página à página.

|`MANPATH`
|Lista de diretórios separados por dois pontos para pesquisar páginas de manual.
|===

O processo para definir uma variável de ambiente difere entre as shells. Em man:tcsh[1] e man:csh[1], use `setenv` para definir variáveis de ambiente. Em man:sh[1] e no `bash`, use `export` para definir as variáveis de ambiente atuais. Este exemplo define o `EDITOR` padrão para [.filename]#/usr/local/bin/emacs# para a shell man:tcsh[1]:

[source,bash]
....
% setenv EDITOR /usr/local/bin/emacs
....

O comando equivalente para `bash` seria:

[source,bash]
....
% export EDITOR="/usr/local/bin/emacs"
....

Para expandir uma variável de ambiente para ver sua configuração atual, digite um caracter `$` na frente de seu nome na linha de comando. Por exemplo, `echo $TERM` exibe a configuração atual do `$TERM`.

Shells tratam caracteres especiais, conhecidos como meta-caracteres, como representações especiais de dados. O meta-caracter mais comum é `\*`, que representa qualquer número de caracteres em um nome de arquivo. Meta-caracteres podem ser usados para executar a globalização de nomes de arquivos. Por exemplo, `echo *` é equivalente a `ls` porque a shell pega todos os arquivos que correspondem ao `*` e `echo` os lista na linha de comando.

Para evitar que a shell interprete um caractere especial, escape-o a partir da shell, iniciando-o com uma barra invertida (`\`). Por exemplo, `echo $TERM` imprime a configuração do terminal, enquanto `echo \$TERM` imprime literalmente a string `$TERM`.

[[changing-shells]]
=== Alterando a Shell

A maneira mais fácil de alterar permanentemente a shell padrão é usar o `chsh`. A execução desse comando abrirá o editor que está configurado na variável de ambiente `EDITOR`, que por padrão é definido como o man:vi[1]. Altere a linha `Shell:` para o caminho completo da nova shell.

Como alternativa, use `chsh -s`, que irá definir a shell especificada sem abrir um editor. Por exemplo, para alterar a shell para `bash`:

[source,bash]
....

% chsh -s /usr/local/bin/bash
....

[NOTE]
====
A nova shell _deve_ estar presente no arquivo [.filename]#/etc/shells#. Se a shell foi instalada a partir da coleção de ports do FreeBSD, como descrito em crossref:ports[ports, Instalando Aplicativos. Pacotes e Ports], ela deve ser adicionada automaticamente a este arquivo. Se estiver faltando, adicione-a usando este comando, substituindo o caminho pelo caminho da shell:

[source,bash]
....

# echo /usr/local/bin/bash >> /etc/shells
....

Em seguida, execute novamente o man:chsh[1].
====

=== Técnicas Avançadas de Shell

A shell UNIX(TM) não é apenas um interpretador de comandos, ela atua como uma ferramenta poderosa que permite aos usuários executar comandos, redirecionar sua saída, redirecionar sua entrada e encadear comandos para melhorar o resultado final. Quando essa funcionalidade é mesclada com comandos incorporados, é fornecido ao usuário um ambiente que pode maximizar a eficiência.

O redirecionamento de shell é a ação de enviar a saída ou a entrada de um comando para outro comando ou para um arquivo. Para capturar a saída do comando man:ls[1], por exemplo, em um arquivo, redirecione a saída:

[source,bash]
....
% ls > directory_listing.txt
....

O conteúdo do diretório agora será listado em [.filename]#directory_listing.txt#. Alguns comandos podem ser usados para ler entradas, como man:sort[1]. Para classificar esta listagem, redirecione a entrada:

[source,bash]
....
% sort < directory_listing.txt
....

A entrada será classificada e colocada na tela. Para redirecionar essa entrada para outro arquivo, pode-se redirecionar a saída de man:sort[1] misturando a direção:

[source,bash]
....
% sort < directory_listing.txt > sorted.txt
....

Em todos os exemplos anteriores, os comandos estão executando o redirecionamento usando descritores de arquivos. Todo sistema UNIX(TM) possui descritores de arquivos, que incluem entrada padrão (stdin), saída padrão (stdout) e erro padrão (stderr). Cada um tem um propósito, onde a entrada pode ser um teclado ou um mouse, algo que fornece entrada. A saída pode ser uma tela ou papel em uma impressora. E erro seria tudo o que pode ser usado para mensagens de diagnóstico ou erro. Todos os três são considerados descritores de arquivos baseados em I/O e, às vezes, considerados fluxos.

Através do uso desses descritores, a shell permite que a saída e a entrada sejam passadas por vários comandos e redirecionadas para/ou a partir de um arquivo. Outro método de redirecionamento é o operador de pipe.

O operador pipe UNIX(TM), "|" permite que a saída de um comando seja transmitida diretamente ou direcionada para outro programa. Basicamente, um pipe permite que a saída padrão de um comando seja passada como entrada padrão para outro comando, por exemplo:

[source,bash]
....
% cat directory_listing.txt | sort | less
....

Nesse exemplo, o conteúdo de [.filename]#directory_listing.txt# será classificado e a saída será transmitida para man:less[1]. Isso permite que o usuário role pela saída em seu próprio ritmo e evite que ela role para fora da tela.

[[editors]]
== Editores de Texto

A maioria das configurações do FreeBSD é feita através da edição de arquivos de texto. Por isso, é uma boa ideia familiarizar-se com um editor de texto. O FreeBSD vem com alguns como parte do sistema base, e muitos outros estão disponíveis na coleção do ports.

Um editor simples para aprender é o man:ee[1], que significa editor fácil (Ease Editor). Para iniciar este editor, digite `ee _filename_` em que _filename_ é o nome do arquivo a ser editado. Uma vez dentro do editor, todos os comandos para manipular as funções do editor são listados no topo da tela. O cursor (`^`) representa kbd:[Ctrl], então `^e` expande para kbd:[Ctrl+e]. Para sair do man:ee[1], pressione kbd:[Esc] e escolha a opção "leave editor" no menu principal. O editor pedirá para salvar as alterações, caso o arquivo tenha sido modificado.

O FreeBSD também vem com editores de texto mais poderosos, como o man:vi[1], como parte do sistema base. Outros editores, como package:editors/emacs[] e package:editors/vim[], fazem parte da coleção do ports do FreeBSD. Esses editores oferecem mais funcionalidade às custas de serem mais complicados de aprender. Aprender um editor mais poderoso como o vim ou o Emacs pode economizar mais tempo a longo prazo.

Muitos aplicativos que modificam arquivos ou exigem entrada digitada abrirão automaticamente um editor de texto. Para alterar o editor padrão, defina a variável de ambiente `EDITOR` conforme descrito em <<shells>>.

[[basics-devices]]
== Dispositivos e nós de dispositivos

Um dispositivo é um termo usado principalmente para atividades relacionadas a hardware em um sistema, incluindo discos, impressoras, placas gráficas e teclados. Quando o FreeBSD inicializa, a maioria das mensagens de inicialização se refere aos dispositivos sendo detectados. Uma cópia das mensagens de inicialização é salva em [.filename]#/var/run/dmesg.boot#.

Cada dispositivo tem um nome e um número de dispositivo. Por exemplo, [.filename]#ada0# é o primeiro disco rígido SATA, enquanto [.filename]#kbd0# representa o teclado.

A maioria dos dispositivos no FreeBSD deve ser acessada através de arquivos especiais chamados nós de dispositivos (device nodes), que estão localizados em [.filename]#/dev#.

[[basics-more-information]]
== Páginas de Manual

A documentação mais abrangente sobre o FreeBSD está na forma de páginas de manual. Quase todos os programas do sistema vêm com um breve manual de referência explicando a operação básica e os argumentos disponíveis. Estes manuais podem ser visualizados usando o `man`:

[source,bash]
....
% man command
....

onde _command_ é o nome do comando para aprender. Por exemplo, para saber mais sobre o man:ls[1], digite:

[source,bash]
....
% man ls
....

As páginas de manual são divididas em seções que representam o tipo de tópico. No FreeBSD, as seguintes seções estão disponíveis:

. Comandos de usuário.
. Chamadas do sistema e números de erro.
. Funções nas bibliotecas C.
. Drivers de dispositivos.
. Formatos de arquivo.
. Jogos e outras diversões.
. Informações diversas.
. Comandos de manutenção e operação do sistema.
. Interfaces do kernel do sistema.

Em alguns casos, o mesmo tópico pode aparecer em mais de uma seção do manual online. Por exemplo, existe um comando de usuário `chmod` e uma chamada de sistema `chmod()`. Para informar ao man:man[1] qual seção exibir, especifique o número da seção:

[source,bash]
....
% man 1 chmod
....

Isto irá mostrar a página de manual do comando man:chmod[1]. Referências a uma seção em particular do manual online são tradicionalmente colocadas entre parênteses na documentação escrita, então man:chmod[1] refere-se ao comando do usuário e man:chmod[2] refere-se à chamada do sistema.

Se o nome da página de manual for desconhecido, use `man -k` para procurar por palavras-chave nas descrições da página de manual:

[source,bash]
....
% man -k mail
....

Este comando exibe uma lista de comandos que possuem a palavra-chave "mail" em suas descrições. Isso é equivalente a usar o man:apropos[1].

Para ler as descrições de todos os comandos em [.filename]#/usr/bin#, digite:

[source,bash]
....
% cd /usr/bin
% man -f * | more
....

ou

[source,bash]
....
% cd /usr/bin
% whatis * |more
....

[[basics-info]]
=== Arquivos GNU Info

O FreeBSD inclui vários aplicativos e utilitários produzidos pela Free Software Foundation (FSF). Além das páginas de manual, esses programas podem incluir documentos de hipertexto chamados arquivos `info`. Elas podem ser visualizadas usando man:info[1] ou, se o package:editors/emacs[] estiver instalado, o modo info do emacs.

Para usar o man:info[1], digite:

[source,bash]
....
% info
....

Para uma breve introdução, digite `h`. Para uma referência rápida de comandos, digite `?`.
