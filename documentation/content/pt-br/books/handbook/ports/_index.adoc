---
title: "Capítulo 4. Instalando Aplicativos: Pacotes e Ports"
part: Parte I. Primeiros Passos
prev: books/handbook/basics
next: books/handbook/x11
showBookMenu: true
weight: 6
path: "/books/handbook/ports/"
---

[[ports]]
= Instalando Aplicativos: Pacotes e Ports
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Sinopse

O FreeBSD tem uma grande coleção de ferramentas dentro do sistema base. Além disso, o FreeBSD fornece duas ferramentas complementares para a instalação de software de terceiros: o a Coleção de Ports do FreeBSD, para instalação a partir do código-fonte, e pacotes, para instalação de binários pré-compilados. Qualquer um dos métodos pode ser usado para instalar um software de uma mídia local ou da rede.

Depois de ler este capítulo, você saberá:

* A diferença entre pacotes binários e ports.
* Como encontrar softwares de terceiros que tenham sido portados para o FreeBSD.
* Como gerenciar pacotes binários usando o pkg.
* Como compilar software de terceiros a partir do código-fonte usando a coleção de ports.
* Como encontrar os arquivos instalados do aplicativo para configuração pós-instalação.
* O que fazer se a instalação do software falhar.

[[ports-overview]]
== Visão geral sobre a Instalação de Software

As etapas típicas para instalar um software de terceiros em um sistema UNIX(TM) incluem:

[.procedure]
====
. Encontre e baixe o software, que pode ser distribuído no formato de código-fonte ou como um binário.
. Desempacote o software a partir do seu formato de distribuição. Tipicamente é um arquivo tarball compactado com um programa como man:compress[1],man:gzip[1], man:bzip2[1] ou man:xz[1].
. Localize a documentação em [.filename]#INSTALL#, [.filename]#README# ou algum arquivo em um subdiretório [.filename]#doc/# e leia sobre como instalar o software.
. Se o software foi distribuído como código-fonte, compile-o. Isso pode envolver a edição de um [.filename]#Makefile# ou a execução de um script `configure`.
. Teste e instale o software.
====

Um _port_ do FreeBSD é uma coleção de arquivos projetados para automatizar o processo de compilação de um aplicativo a partir do código-fonte. Os arquivos que compõem um port contêm todas as informações necessárias para baixar, extrair, corrigir, compilar e instalar automaticamente o aplicativo.

Se o software ainda não foi adaptado e testado no FreeBSD, o código-fonte pode precisar ser editado para que seja instalado e executado corretamente.

No entanto, mais de https://www.FreeBSD.org/ports/[24.000] aplicativos de terceiros já foram portados para o FreeBSD. Quando possível, esses aplicativos são disponibilizados para download como _pacotes_ pré-compilados.

Pacotes podem ser manipulados com os comandos de gerenciamento de pacotes do FreeBSD.

Ambos, pacotes e ports, entendem dependências. Se um pacote ou port for usado para instalar um aplicativo, e uma biblioteca dependente ainda não estiver instalada, a biblioteca será instalada automaticamente primeiro.

Um pacote do FreeBSD contém cópias pré-compiladas de todos os comandos para uma aplicação, assim como quaisquer arquivos de configuração e documentação. Um pacote pode ser manipulado com os comandos man:pkg[8], como `pkg install`.

Mesmo as duas tecnologias sendo semelhantes, os pacotes e os ports têm seus próprios pontos fortes. Selecione a tecnologia que melhor atenda aos seus requisitos para instalar um aplicativo específico.

.Benefícios dos Pacotes
* Um tarball compactado de um pacote geralmente é menor que o tarball compactado que contém o código-fonte do aplicativo.
* Pacotes não requerem tempo de compilação. Para aplicativos grandes, como o Mozilla, KDE ou GNOME, isso pode ser importante em um sistema lento.
* Pacotes não requerem nenhum entendimento do processo envolvido na compilação de software no FreeBSD.

.Benefícios dos Ports
* Os pacotes são normalmente compilados com opções conservadoras porque eles precisam ser executados no número máximo de sistemas. Ao compilar a partir do port, podem-se alterar as opções de compilação.
* Alguns aplicativos têm opções em tempo de compilação relacionadas a quais recursos estão instalados. Por exemplo, o Apache pode ser configurado com uma ampla variedade de diferentes opções internas.
+ 
Em alguns casos, vários pacotes existirão para o mesmo aplicativo para especificar determinadas configurações. Por exemplo, o Ghostscript está disponível como um pacote [.filename]#ghostscript# e um pacote [.filename]#ghostscript-nox11#, dependendo se o Xorg está instalado ou não. Criar vários pacotes rapidamente se torna impossível se um aplicativo tiver mais de uma ou duas opções diferentes de tempo de compilação.
* As condições de licenciamento de alguns softwares proíbem sua distribuição em binário. Tais softwares devem ser distribuídos como código-fonte o qual deve ser compilado pelo usuário final.
* Algumas pessoas não confiam em distribuições binárias ou preferem ler o código-fonte para procurar possíveis problemas.
* O código-fonte é necessário para aplicar patches personalizados.

Para acompanhar a atualização dos ports, inscreva-se na http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports[lista de discussão dos ports do FreeBSD ] e no link http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports-bugs[Lista de discussão de bugs no FreeBSD].

[WARNING]
====

Antes de instalar qualquer aplicativo, verifique https://vuxml.freebsd.org/[] para questões de segurança relacionadas ao aplicativo ou digite `pkg audit -F` para verificar todas as instâncias instaladas aplicativos para vulnerabilidades conhecidas.
====

O restante deste capítulo explica como usar pacotes e ports para instalar e gerenciar software de terceiros no FreeBSD.

[[ports-finding-applications]]
== Encontrando Software

A lista de aplicativos disponíveis do FreeBSD está crescendo o tempo todo. Existem várias maneiras de encontrar softwares para instalar:

* O site do FreeBSD mantém uma lista atualizada e pesquisável de todos os aplicativos disponíveis, em https://www.FreeBSD.org/ports/[https://www.FreeBSD.org/ports/]. Os ports podem ser pesquisados por nome do aplicativo ou por categoria de software.
* Dan Langille mantém o http://www.FreshPorts.org/[FreshPorts.org], que fornece um utilitário de pesquisa abrangente e também rastreia alterações nos aplicativos da Coleção de Ports. Os usuários registrados podem criar uma lista de observação personalizada para receber um e-mail automatizado quando seus ports sendo monitorados forem atualizados.
* Se encontrar um aplicativo específico se tornar desafiador, tente pesquisar um site como http://www.sourceforge.net/[SourceForge.net] ou http://www.github.com/[GitHub.com] então volte no https://www.FreeBSD.org/ports/[site do FreeBSD] para ver se o aplicativo foi portado.
* Para pesquisar o repositório de pacotes binários por um aplicativo:
+
[source,shell]
....
# pkg search subversion
git-subversion-1.9.2
java-subversion-1.8.8_2
p5-subversion-1.8.8_2
py27-hgsubversion-1.6
py27-subversion-1.8.8_2
ruby-subversion-1.8.8_2
subversion-1.8.8_2
subversion-book-4515
subversion-static-1.8.8_2
subversion16-1.6.23_4
subversion17-1.7.16_2
....
+ 
Os nomes dos pacotes incluem o número da versão e, no caso de ports baseados em python, o número da versão do pacote python sobre o qual o pacote foi compilado. Alguns ports também possuem várias versões disponíveis. No caso do Subversion, existem diferentes versões disponíveis, bem como diferentes opções de compilação. Neste caso, a versão estaticamente vinculada do Subversion. Ao indicar qual pacote instalar, é melhor especificar o aplicativo pela origem do port, que é o caminho na árvore de ports. Repita o `pkg search` com `-o` para listar a origem de cada pacote:
+
[source,shell]
....
# pkg search -o subversion
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static
....
+ 
Pesquisar por shell globs, expressões regulares, correspondência exata, por descrição ou qualquer outro campo no banco de dados do repositório também é suportado pelo `pkg search`. Depois de instalar o package:ports-mgmt/pkg[] ou o package:ports-mgmt/pkg-devel[], veja man:pkg-search[8] para maiores detalhes.
* Se a Coleção de Ports já estiver instalada, existem vários métodos para consultar a versão local da árvore de ports. Para descobrir em qual categoria um port está, digite `whereis__file__`, onde __file__ é o programa a ser instalado:
+
[source,shell]
....
# whereis lsof
lsof: /usr/ports/sysutils/lsof
....
+ 
Como alternativa, uma declaração man:echo[1] pode ser usada:
+
[source,shell]
....
# echo /usr/ports/*/*lsof*
/usr/ports/sysutils/lsof
....
+ 
Observe que isso também retornará todos os arquivos correspondentes baixados no diretório [.filename]#/usr/ports/distfiles#.
* Outra maneira de encontrar software é usando o mecanismo de pesquisa integrado da Coleção de Ports. Para usar o recurso de pesquisa, cd para [.filename]#/usr/ports#, execute `make search name=program-name` onde _program-name_ é o nome do software. Por exemplo, para procurar por `lsof`:
+
[source,shell]
....
# cd /usr/ports
# make search name=lsof
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps: 
....
+
[TIP]
====

O mecanismo de pesquisa interna usa um arquivo de informações de índice. Se uma mensagem indicar que o [.filename]#INDEX# é necessário, execute `make fetchindex` para baixar o arquivo de índice atual. Com o [.filename]#INDEX# presente, o `make search` poderá realizar a pesquisa solicitada.
====
+ 
A linha "Path:" indica onde encontrar o port.
+ 
Para receber menos informações, use o recurso `quicksearch`:
+
[source,shell]
....
# cd /usr/ports
# make quicksearch name=lsof
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
....
+ 
Para uma busca mais aprofundada, use o `make search key=_string_` ou o `make quicksearch key=_string_`, onde _string_ é algum texto para procurar. O texto pode estar em comentários, descrições ou dependências para encontrar ports relacionados a um assunto em particular quando o nome do programa é desconhecido.
+ 
Ao usar `pesquisa` ou `pesquisa rápida`, a cadeia de pesquisa não diferencia maiúsculas de minúsculas. Procurar por "LSOF" produzirá os mesmos resultados que procurar por "lsof".

[[pkgng-intro]]
== Usando o pkg para o gerenciamento de pacotes binários

O pkg é o substituto da próxima geração para as tradicionais ferramentas de gerenciamento de pacotes do FreeBSD, oferecendo muitos recursos que tornam o processamento de pacotes binários mais rápido e fácil.

Para sites que desejam apenas usar pacotes binários pré-construídos a partir dos espelhos do FreeBSD, o gerenciamento de pacotes com pkg pode ser suficiente.

No entanto, para aqueles que optarem por compilar suas aplicações a partir do código-fonte ou que utilizarem seus próprios repositórios, será necessária uma <<ports-upgrading-tools,ferramenta de gerenciamento de ports>> separada.

Como o pkg só funciona com pacotes binários, ele não é um substituto para tais ferramentas. Estas ferramentas podem ser usadas para instalar o software a partir de pacotes binários e da Coleção do Ports, enquanto o pkg instala apenas pacotes binários.

[[pkgng-initial-setup]]
=== Introdução ao pkg

O FreeBSD inclui um utilitário de bootstrap que pode ser usado para baixar e instalar o pkg e suas páginas de manual. Este utilitário foi projetado para funcionar com versões do FreeBSD começando com 10._X_.

[NOTE]
====
Nem todas as versões e arquiteturas do FreeBSD suportam este processo de bootstrap. A lista atual está em https://pkg.freebsd.org/[]. Para outros casos, o pkg deve ser instalado a partir da coleção de ports ou como um pacote binário.
====

Para inicializar o sistema, execute:

[source,shell]
....
# /usr/sbin/pkg
....

Você deve ter uma conexão com a Internet para que o processo de inicialização seja bem-sucedido.

Caso contrário, para instalar o port, execute:

[source,shell]
....
# cd /usr/ports/ports-mgmt/pkg
# make
# make install clean
....

Ao atualizar um sistema existente que usava originalmente as ferramentas pkg_* mais antigas, o banco de dados deve ser convertido para o novo formato, para que as novas ferramentas estejam cientes dos pacotes já instalados. Uma vez que o pkg tenha sido instalado, o banco de dados de pacotes deve ser convertido do formato tradicional para o novo formato, executando este comando:

[source,shell]
....
# pkg2ng
....

[NOTE]
====
Esta etapa não é necessária para novas instalações que ainda não possuem nenhum software de terceiros instalado.
====

[IMPORTANT]
====
Este passo não é reversível. Uma vez que o banco de dados de pacotes tenha sido convertido para o formato pkg, as ferramentas tradicionais `pkg_*` não devem mais ser usadas.
====

[NOTE]
====
A conversão do banco de dados de pacotes pode emitir erros conforme o conteúdo é convertido para a nova versão. Geralmente, esses erros podem ser ignorados com segurança. No entanto, uma lista com os softwares que não foram convertidos com sucesso é mostrada após o `pkg2ng` terminar. Esses aplicativos devem ser reinstalados manualmente.
====

Para garantir que a Coleção de Ports registre novos softwares com o pkg ao invés do tradicional banco de dados de pacotes, versões do FreeBSD anteriores a 10._X_ requerem esta linha em [.filename]#/etc/make.conf#:

[.programlisting]
....
WITH_PKGNG=	yes
....

Por padrão, o pkg usa os pacotes binários dos espelhos de pacotes do FreeBSD (o _repositório_). Para obter informações sobre como criar um repositório de pacotes personalizados, consulte <<ports-poudriere>>.

Opções adicionais de configuração do pkg são descritas em man:pkg.conf[5].

As informações de uso do pkg estão disponíveis na página de manual man:pkg[8] ou executando o `pkg` sem argumentos adicionais.

Cada argumento do comando pkg é documentado em uma página de manual específica do comando. Para ler a página de manual do `pkg install`, por exemplo, execute um destes comandos:

[source,shell]
....
# pkg help install
....

[source,shell]
....
# man pkg-install
....

O restante desta seção demonstra tarefas comuns de gerenciamento de pacotes binários que podem ser executadas usando o pkg. Cada comando demonstrado fornece muitos switches para personalizar seu uso. Consulte a ajuda de um comando ou a página do manual para obter detalhes e mais exemplos.

[[quarterly-latest-branch]]
=== Branches Ports Trimestrais e Mais Recentes

As branches `Quarterly`(trimestrais) provê aos usuários uma experiência mais estável e previsível para instalação e upgrade de ports e pacotes. Isto é feito essencialmente permitindo apenas atualizações que não contém novas features (non-features updates). Branches trimestrais visam receber correções se segurança (que talvez sejam atualizações de versão, ou commits de backports), correções de bugs e compliance de ports ou alterações de frameworks. A branch trimestral é baseada (anualmente) na HEAD no início de Janeiro, Abril, Julho e Outubro. As branches são nomeadas de acordo com o ano (YYYY) e o quarter (Q1-4) em que são criadas. Por exemplo, a branch trimestral criada em Janeiro de 2016, é nomeada 2016Q1. E a branch `Latest` provê as últimas versões dos pacotes para os usuários.

Para alternar de trimestral para latest execute os seguintes comandos:

[source,shell]
....
# cp /etc/pkg/FreeBSD.conf /usr/local/etc/pkg/repos/FreeBSD.conf
....

Edite o arquivo [.filename]#/usr/local/etc/pkg/repos/FreeBSD.conf# and change the string _quarterly_ to _latest_ in the `url:` line.

O resultado deve ser semelhante ao seguinte:

[.programlisting]
....
FreeBSD: {
  url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest",
  mirror_type: "srv",
  signature_type: "fingerprints",
  fingerprints: "/usr/share/keys/pkg",
  enabled: yes
}
....

E finalmente rode este comando para atualizar do novo (ultimo) meta dado do repositório.

[source,shell]
....
# pkg update -f
....

[[pkgng-pkg-info]]
=== Obtendo informações sobre os pacotes instalados

Informações sobre os pacotes instalados em um sistema podem ser visualizadas executando `pkg info` que, quando executado sem qualquer opção, listará a versão do pacote para todos os pacotes instalados ou para o pacote especificado.

Por exemplo, para ver qual versão do pkg está instalada, execute:

[source,shell]
....
# pkg info pkg
pkg-1.1.4_1
....

[[pkgng-installing-deinstalling]]
=== Instalando e removendo pacotes

Para instalar um pacote binário, use o seguinte comando, em que _packagename_ é o nome do pacote a ser instalado:

[source,shell]
....
# pkg install packagename
....

Esse comando usa os dados do repositório para determinar qual versão do software instalar e se ele possui alguma dependência faltando. Por exemplo, para instalar o curl:

[source,shell]
....
# pkg install curl
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages [y/N]: y
Checking integrity... done
[1/2] Installing ca_root_nss-3.15.1_1... done
[2/2] Installing curl-7.31.0_1... done
Cleaning up cache files...Done
....

O novo pacote e quaisquer pacotes adicionais que foram instalados como dependências podem ser vistos na lista de pacotes instalados:

[source,shell]
....
# pkg info
ca_root_nss-3.15.1_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1	Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
pkg-1.1.4_6	New generation package manager
....

Pacotes que não são mais necessários podem ser removidos com `pkg delete`. Por exemplo:

[source,shell]
....
# pkg delete curl
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages [y/N]: y
[1/1] Deleting curl-7.31.0_1... done
....

[[pkgng-upgrading]]
=== Atualizando os Pacotes Instalados

Os pacotes instalados podem ser atualizados para as versões mais recentes executando:

[source,shell]
....
# pkg upgrade
....

Este comando irá comparar as versões instaladas com as disponíveis no catálogo do repositório e atualizá-las a partir do repositório.

[[pkgng-auditing]]
=== Auditando os Pacotes Instalados

Vulnerabilidades de software são regularmente descobertas em aplicativos de terceiros. Para resolver isso, o pkg inclui um mecanismo de auditoria integrado. Para determinar se há alguma vulnerabilidade conhecida para o software instalado no sistema, execute:

[source,shell]
....
# pkg audit -F
....

[[pkgng-autoremove]]
=== Removendo Pacotes Não Utilizados Automaticamente

Remover um pacote pode deixar dependências que não são mais necessárias. Pacotes desnecessários que foram instalados como dependências podem ser automaticamente detectados e removidos usando:

[source,shell]
....
# pkg autoremove
Packages to be autoremoved:
	ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages [y/N]: y
Deinstalling ca_root_nss-3.15.1_1... done
....

Os pacotes instalados como dependências são chamados de pacotes _automáticos_. Pacotes não automáticos, ou seja, os pacotes que não foram instalados como uma dependência para outro pacote, podem ser listados usando:

[source,shell]
....
# pkg prime-list
nginx
openvpn
sudo
....

O `pkg prime-list` é um alias de comando declarado no [.filename]#/usr/local/etc/pkg.conf#. Existem muitos outros que podem ser usados para consultar o banco de dados de pacotes do sistema. Por exemplo, o comando `pkg prime-origins` pode ser usado para obter o diretório de origem dos ports da lista mencionada acima:

[source,shell]
....
# pkg prime-origins
www/nginx
security/openvpn
security/sudo
....

Esta lista pode ser usada para recompilar todos os pacotes instalados em um sistema usando ferramentas de compilação como o package:ports-mgmt/poudriere[] ou o package:ports-mgmt/synth[].

Marcar um pacote instalado como automático pode ser feito usando:

[source,shell]
....
# pkg set -A 1 devel/cmake
....

Uma vez que um pacote é um pacote orfão e está marcado como automático, ele será selecionado por `pkg autoremove`.

Marcar um pacote instalado como _não_ automático pode ser feito usando:

[source,shell]
....
# pkg set -A 0 devel/cmake
....

[[pkgng-backup]]
=== Restaurando o banco de dados de pacotes

Ao contrário do sistema tradicional de gerenciamento de pacotes, o pkg inclui seu próprio mecanismo de backup de banco de dados de pacotes. Essa funcionalidade é habilitada por padrão.

[TIP]
====

Para desabilitar o script que faz o backup periódico do banco de dados de pacotes, defina `daily_backup_pkgdb_enable="NO"` no man:periodic.conf[5].
====

Para restaurar o conteúdo de um backup anterior do banco de dados de pacotes, execute o seguinte comando substituindo _/path/to/pkg.sql_ pelo local do backup:

[source,shell]
....
# pkg backup -r /path/to/pkg.sql
....

[NOTE]
====
Se estiver restaurando um backup feito pelo script periódico, ele deve ser descompactado antes de ser restaurado.
====

Para executar um backup manual do banco de dados pkg, execute o seguinte comando, substituindo _/path/to/pkg.sql_ por um nome de arquivo e local adequados:

[source,shell]
....
# pkg backup -d /path/to/pkg.sql
....

[[pkgng-clean]]
=== Removendo Pacotes Obsoletos

Por padrão, o pkg armazena pacotes binários em um diretório de cache definido por `PKG_CACHEDIR` no man:pkg.conf[5]. Somente cópias dos últimos pacotes instalados são mantidas. Versões mais antigas do pkg mantinham todos os pacotes anteriores. Para remover esses pacotes binários desatualizados, execute:

[source,shell]
....
# pkg clean
....

O cache inteiro pode ser limpo executando:

[source,shell]
....
# pkg clean -a
....

[[pkgng-set]]
=== Modificando Metadados de Pacotes

Os softwares dentro da Coleção de Ports do FreeBSD podem passar por grandes mudanças no número de versão. Para resolver isso, o pkg possui um comando interno para atualizar as origens do pacote. Isto pode ser útil, por exemplo, se package:lang/php5[] for renomeado para package:lang/php53[] para que package:lang/php5[] possa agora representar a versão `5.4`.

Para alterar a origem do pacote para o exemplo acima, execute:

[source,shell]
....
# pkg set -o lang/php5:lang/php53
....

Como outro exemplo, para atualizar package:lang/ruby18[] para package:lang/ruby19[], execute:

[source,shell]
....
# pkg set -o lang/ruby18:lang/ruby19
....

Como um exemplo final, para alterar a origem das bibliotecas compartilhadas [.filename]#libglut# de package:graphics/libglut[] para package:graphics/freeglut[], execute:

[source,shell]
....
# pkg install -Rf graphics/freeglut
....

[NOTE]
====
Ao alterar as origens do pacote, é importante reinstalar os pacotes que dependem do pacote com a origem modificada. Para forçar uma reinstalação dos pacotes dependentes, execute:

[source,shell]
....
# pkg install -Rf graphics/freeglut
....

====

[[ports-using]]
== Usando a Coleção de Ports

A Coleção de Ports é um conjunto de arquivos [.filename]##Makefiles##s, patches e arquivos de descrição. Cada conjunto desses arquivos é usado para compilar e instalar um aplicativo individual no FreeBSD, e é chamado de _port_.

Por padrão, a própria coleção de ports é armazenada como um subdiretório de [.filename]#/usr/ports#.

[WARNING]
====
Before installing and using the Ports Collection, please be aware that it is generally ill-advised to use the Ports Collection in conjunction with the binary packages provided via pkg to install software. pkg, by default, tracks quarterly branch-releases of the ports tree and not HEAD. Dependencies could be different for a port in HEAD compared to its counterpart in a quarterly branch release and this could result in conflicts between dependencies installed by pkg and those from the Ports Collection. If the Ports Collection and pkg must be used in conjunction, then be sure that your Ports Collection and pkg are on the same branch release of the ports tree.
====

Antes que um aplicativo possa ser compilado usando um port, a Coleção de Ports deve primeiro ser instalada. Se ela não foi instalada durante a instalação do FreeBSD, use um dos seguintes métodos para instalá-la:

[[ports-using-portsnap-method]]
[.procedure]
====
*Procedure: Método Portsnap*

O sistema base do FreeBSD inclui o Portsnap. Esta é uma ferramenta rápida e de fácil utilização para obter a Coleção de Ports e é a escolha recomendada para a maioria dos usuários que não estão executando o FreeBSD-CURRENT. Este utilitário se conecta a um site do FreeBSD, verifica a chave segura e faz o download de uma nova cópia da Coleção de Ports. A chave é usada para verificar a integridade de todos os arquivos baixados.

. Para baixar um snapshot compactado da coleção de ports em [.filename]#/var/db/portsnap#:
+
[source,shell]
....
# portsnap fetch
....
+
. Ao executar o Portsnap pela primeira vez, extraia o snapshot em [.filename]#/usr/ports#:
+
[source,shell]
....
# portsnap extract
....
+
. Após o primeiro uso do Portsnap ter sido concluído, como mostrado acima, o [.filename]#/usr/ports# pode ser atualizado conforme necessário executando:
+
[source,shell]
....
# portsnap fetch
# portsnap update
....
+ 
Ao usar `fetch`, a operação `extract` ou `update` pode ser executada consecutivamente, da seguinte forma:
+
[source,shell]
....
# portsnap fetch update
....
====

[[ports-using-subversion-method]]
[.procedure]
====
*Procedure: Método Subversion*

Se for necessário mais controle sobre a árvore de ports ou se as mudanças locais precisarem ser mantidas, ou se estiver executando o FreeBSD-CURRENT, o Subversion pode ser usado para obter a coleção de ports. Consulte extref:{committers-guide}[O Subversion Primer, subversion-primer] para uma descrição detalhada do Subversion.

. O Subversion deve ser instalado antes de poder ser usado para fazer o check-out da árvore de ports. Se uma cópia da árvore de ports já estiver presente, instale o Subversion desta forma:
+
[source,shell]
....
# cd /usr/ports/devel/subversion
# make install clean
....
+ 
Se a árvore de ports não estiver disponível, ou o pkg estiver sendo usado para gerenciar pacotes, o Subversion poderá ser instalado como um pacote:
+
[source,shell]
....
# pkg install subversion
....
+
. Check out a copy of the HEAD branch of the ports tree:
+
[source,shell]
....
# svn checkout https://svn.FreeBSD.org/ports/head /usr/ports
....
+
. Or, check out a copy of a quarterly branch:
+
[source,shell]
....
# svn checkout https://svn.FreeBSD.org/ports/branches/2020Q3 /usr/ports
....
+
. Conforme necessário, atualize o [.filename]#/usr/ports# após o check out inicial do Subversion:
+
[source,shell]
....
# svn update /usr/ports
....
+
. As needed, switch [.filename]#/usr/ports# to a different quarterly branch:
+
[source,shell]
....
# svn switch http://svn.freebsd.org/ports/branches/2020Q4/ /usr/ports
....

====

A coleção de ports contém diretórios para categorias de software. Dentro de cada categoria estão subdiretórios para aplicativos individuais. Cada subdiretório de aplicativo contém um conjunto de arquivos que informa ao FreeBSD como compilar e instalar esse programa, chamado de _esqueleto do ports_. Cada esqueleto de port inclui esses arquivos e diretórios:

* [.filename]#Makefile#: contém instruções que especificam como o aplicativo deve ser compilado e onde seus componentes devem ser instalados.
* [.filename]#distinfo#: contém os nomes e checksums dos arquivos que devem ser baixados para compilar o port.
* [.filename]#files/#: este diretório contém quaisquer patches necessários para o programa compilar e instalar no FreeBSD. Esse diretório também pode conter outros arquivos usados para compilar o port.
* [.filename]#pkg-descr#: fornece uma descrição mais detalhada do programa.
* [.filename]#pkg-plist#: uma lista de todos os arquivos que serão instalados pelo port. Ele também informa ao sistema de ports quais arquivos devem ser removidos após a desinstalação.

Alguns ports incluem [.filename]#pkg-message# ou outros arquivos para lidar com situações especiais. Para obter mais detalhes sobre esses arquivos e sobre os ports em geral, consulte o extref:{porters-handbook}[FreeBSD Porter's Manual].

O port não inclui o código-fonte real, também conhecido como [.filename]#distfile#. A etapa de extração da compilação de um port salvará automaticamente o código-fonte transferido por download para [.filename]#/usr/ports/distfiles#.

[[ports-skeleton]]
=== Instalando Ports

Esta seção fornece instruções básicas sobre o uso da Coleção de Ports para instalar ou remover software. A descrição detalhada dos targets disponíveis do `make` e das variáveis de ambiente está disponível em man:ports[7].

[WARNING]
====

Antes de compilar qualquer port, certifique-se de atualizar a Coleção de Ports conforme descrito na seção anterior. Como a instalação de qualquer software de terceiros pode introduzir vulnerabilidades de segurança, recomenda-se primeiro verificar https://vuxml.freebsd.org/[] para problemas de segurança conhecidos relacionados ao port. Alternativamente, execute `pkg -f` antes de instalar um novo port. Esse comando pode ser configurado para executar automaticamente uma auditoria de segurança e uma atualização do banco de dados de vulnerabilidades durante a verificação diária do sistema de segurança. Para obter maiores informações, consulte man:pkg-audit[8] e man:periodic[8].
====

O uso da coleção de ports pressupõe uma conexão de Internet ativa. Também requer privilégios de superusuário.

Para compilar e instalar o port, mude para o diretório do port a ser instalado e, em seguida, digite `make install` no prompt. Mensagens indicarão o progresso:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make install
>> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.88
...
[extraction output snipped]
...
>> Checksum OK for lsof_4.88D.freebsd.tar.gz.
===>  Patching for lsof-4.88.d,8
===>  Applying FreeBSD patches for lsof-4.88.d,8
===>  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===>  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===>  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.88.d,8
===>   Registering installation for lsof-4.88.d,8
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#
....

Como o `lsof` é um programa que é executado com privilégios aumentados, um aviso de segurança é exibido quando é instalado. Quando a instalação estiver concluída, o prompt será retornado.

Algumas shells mantêm um cache dos comandos que estão disponíveis nos diretórios listados na variável de ambiente `PATH`, para acelerar as operações de pesquisa do arquivo executável desses comandos. Os usuários do shell `tcsh` devem digitar `rehash` para que um comando recém-instalado possa ser usado sem especificar seu caminho completo. Use `hash -r` para o shell `sh`. Consulte a documentação do shell para mais informações.

Durante a instalação, é criado um subdiretório de trabalho que contém todos os arquivos temporários usados durante a compilação. A remoção desse diretório economiza espaço em disco e minimiza a possibilidade de problemas mais tarde ao atualizar para a versão mais recente do port:

[source,shell]
....
# make clean
===>  Cleaning for lsof-88.d,8
#
....

[NOTE]
====
Para evitar esta etapa extra, use `make install clean` ao compilar o port.
====

==== Personalizando a instalação de ports

Alguns ports fornecem opções de compilação que podem ser usadas para habilitar ou desabilitar componentes do aplicativo, fornecer opções de segurança ou permitir outras personalizações. Os exemplos incluem o package:www/firefox[], package:security/gpgme[], e package:mail/sylpheed-claws[]. Se o port depender de outros ports que tenham opções configuráveis, ela poderá pausar várias vezes para interação do usuário, pois o comportamento padrão é solicitar ao usuário que selecione opções de um menu. Para evitar isso e fazer toda a configuração em um lote, execute `make config-recursive` dentro do diretório do port. Em seguida, execute `make install [clean]` para compilar e instalar o port.

[TIP]
====

Ao usar `config-recursive`, a lista de ports a serem configurados é reunida pelo target `all-depends-list`. É recomendado executar o `make config-recursive` até que todas as opções dos ports dependentes tenham sido definidas, e as telas de opções de ports não apareçam mais, para ter certeza de que todas as opções das dependência foram configuradas.
====

Há várias maneiras de revisitar o menu de opções de compilação de um port para adicionar, remover ou alterar essas opções após a compilação de um port. Um método é efetuar `cd` no diretório que contém o port e digitar `make config`. Outra opção é usar o `make showconfig`. Outra opção é executar `make rmconfig`, o que removerá todas as opções selecionadas e permitirá que você comece de novo. Todas essas opções, e outras, são explicadas detalhadamente em man:ports[7].

O sistema de ports usa o man:fetch[1] para fazer o download dos arquivos com o código-fonte, que suportam várias variáveis de ambiente. As variáveis `FTP_PASSIVE_MODE`, `FTP_PROXY` e `FTP_PASSWORD` podem precisar ser definidas se o sistema FreeBSD estiver por trás de um firewall ou proxy FTP/HTTP. Veja man:fetch[3] para a lista completa de variáveis suportadas.

Para usuários que não podem estar conectados à Internet o tempo todo, o `make fetch` pode ser executado dentro do [.filename]#/usr/ports#, para buscar todos os distfiles, ou dentro de uma categoria, como [.filename]#/usr/ports/net#, ou dentro do diretório de um port especifico. Observe que, se um port tiver alguma dependência, executar este comando em uma categoria ou diretório de um port especifico _não_ buscará os distfiles de ports de outra categoria. Em vez disso, use `make fetch-recursive` para também buscar os distfiles para todas as dependências de um port.

Em casos raros, como quando uma organização tem um repositório local de distfiles, a variável `MASTER_SITES` pode ser usada para substituir os locais de download especificados no [.filename]#Makefile#. Ao usar, especifique o local alternativo:

[source,shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch
....

As variáveis `WRKDIRPREFIX` e `PREFIX` podem substituir os diretórios de trabalho e de destino padrão. Por exemplo:

[source,shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

irá compilar o port em [.filename]#/usr/home/example/ports# e instalar tudo sob [.filename]#/usr/local#.

[source,shell]
....
# make PREFIX=/usr/home/example/local install
....

irá compilar o port em [.filename]#/usr/ports# e instalá-lo em [.filename]#/usr/home/example/local#. E:

[source,shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

vai combinar os dois.

Estes também podem ser definidos como variáveis ambientais. Consulte a página de manual do seu shell para obter instruções sobre como definir uma variável de ambiente.

[[ports-removing]]
=== Removendo Ports Instalados

Ports instalados podem ser desinstalados usando `pkg delete`. Exemplos para usar este comando podem ser encontrados na página de manual man:pkg-delete[8].

Alternativamente, o `make deinstall` pode ser executado no diretório do port:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make deinstall
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done
....

Recomenda-se ler as mensagens quando o port for desinstalado. Se o port tiver algum aplicativo que dependa dele, essas informações serão exibidas, mas a desinstalação continuará. Nesses casos, talvez seja melhor reinstalar o aplicativo para evitar dependências quebradas.

[[ports-upgrading]]
=== Atualizando os Ports

Com o tempo, novas versões de software ficam disponíveis na coleção de ports. Esta seção descreve como determinar qual software pode ser atualizado e como executar a atualização.

Para determinar se versões mais recentes dos ports instalados estão disponíveis, verifique se a versão mais recente da árvore de ports está instalada, usando o comando de atualização descrito em <<ports-using-portsnap-method,Método Portsnap>> ou <<ports-using-subversion-method,Método Subversion>>. No FreeBSD 10 e posterior, ou se o sistema foi convertido para pkg, o seguinte comando listará os ports instalados que estão desatualizadas:

[source,shell]
....
# pkg version -l "<"
....

Para o FreeBSD 9._X_ e menor, o seguinte comando listará os ports instalados que estão desatualizados:

[source,shell]
....
# pkg_version -l "<"
....

[IMPORTANT]
====
Antes de tentar uma atualização, leia o [.filename]#/usr/ports/UPDATING# da parte superior do arquivo até a data mais próxima da última vez em que os ports foram atualizados ou o sistema foi instalado. Este arquivo descreve vários problemas e etapas adicionais que os usuários podem encontrar e precisar executar ao atualizar um port, incluindo coisas como alterações de formato de arquivo, alterações nos locais de arquivos de configuração ou incompatibilidades com versões anteriores. Anote quaisquer instruções que correspondam a qualquer um dos ports que precisam de atualização e siga estas instruções ao executar a atualização.
====

[[ports-upgrading-tools]]
==== Ferramentas para atualizar e gerenciar ports

A coleção de ports contém vários utilitários para executar a atualização real. Cada um tem seus pontos fortes e fracos.

Historicamente, a maioria das instalações usava o Portmaster ou o Portupgrade. O Synth é uma alternativa mais recente.

[NOTE]
====
A escolha da melhor ferramenta para um determinado sistema depende do administrador do sistema. Recomenda-se a prática de fazer backup de seus dados antes de usar qualquer uma dessas ferramentas.
====

[[portmaster]]
==== Atualizando Ports Usando o Portmaster

O package:ports-mgmt/portmaster[] é um utilitário muito pequeno para atualizar os ports instalados. Ele é projetado para usar as ferramentas instaladas com o sistema base do FreeBSD sem depender de outros ports ou bancos de dados. Para instalar este utilitário como um port:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

O Portmaster define quatro categorias de ports:

* Port Root: não tem dependências e não é uma dependência de outros ports.
* Port Trunk: não tem dependências, mas outros ports dependem dele.
* Port Branch: tem dependências e outros ports dependem dele.
* Port Leaf: tem dependências, mas nenhum outro port depende dele.

Para listar essas categorias e procurar atualizações:

[source,shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache22-2.2.3
        ===>>> New version available: apache22-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

Este comando é usado para atualizar todos os ports desatualizados:

[source,shell]
....
# portmaster -a
....

[NOTE]
====
Por padrão, o Portmaster faz um backup do pacote antes de excluir o port existente. Se a instalação da nova versão for bem-sucedida, o Portmaster excluirá o backup. O uso de `-b` instrui o Portmaster a não excluir automaticamente o backup. Adicionar `-i` inicia o Portmaster no modo interativo, solicitando a confirmação antes de atualizar cada port. Muitas outras opções estão disponíveis. Leia a página de manual para o man:portmaster[8] para obter detalhes sobre seu uso.
====

Se forem encontrados erros durante o processo de atualização, adicione `-f` para atualizar e recompilar todos os ports:

[source,shell]
....
# portmaster -af
....

O Portmaster também pode ser usado para instalar novos ports no sistema, atualizando todas as dependências antes de compilar e instalar o novo port. Para usar essa função, especifique o local do port na coleção de ports:

[source,shell]
....
# portmaster shells/bash
....

Maiores informações sobre package:ports-mgmt/portmaster[] podem ser encontradas no [.filename]#pkg-descr#.

[[portupgrade]]
==== Atualizando Ports Usando o Portupgrade

O package:ports-mgmt/portupgrade[] é outro utilitário que pode ser usado para atualizar ports. Ele instala um conjunto de aplicativos que podem ser usados para gerenciar ports. No entanto, ele depende do Ruby. Para instalar o port:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

Antes de executar uma atualização usando esse utilitário, é recomendável verificar a lista de ports instalados usando o `pkgdb -F` e corrigir todas as inconsistências relatadas.

Para atualizar todos os ports desatualizados instalados no sistema, use o `portupgrade -a`. Como alternativa, inclua `-i` para ser solicitado da confirmação de cada atualização individual:

[source,shell]
....
# portupgrade -ai
....

Para atualizar apenas um aplicativo especifico em vez de todos os ports disponíveis, use `portupgrade _pkgname_`. É muito importante incluir `-R` para primeiro atualizar todos os ports requeridos pelo aplicativo fornecido:

[source,shell]
....
# portupgrade -R firefox
....

Se `-P` estiver incluído, o Portupgrade procura pacotes disponíveis nos diretórios locais listados em `PKG_PATH`. Se nenhum estiver disponível localmente, ele buscará pacotes de um site remoto. Se os pacotes não puderem ser encontrados localmente ou buscados remotamente, o Portupgrade utilizará os ports. Para evitar completamente o uso do ports, especifique `-PP`. Este último conjunto de opções diz ao Portupgrade para cancelar se nenhum pacote estiver disponível:

[source,shell]
....
# portupgrade -PP gnome3
....

Para obter apenas os distfiles do port, ou pacotes, se `-P` for especificado, sem compilar ou instalar nada, use `-F`. Para mais informações sobre todas as opções disponíveis, consulte a página de manual do `portupgrade`.

Maiores informações sobre o package:ports-mgmt/portupgrade[] podem ser encontradas no [.filename]#pkg-descr#.

[[ports-disk-space]]
=== Ports e o Espaço em Disco

A utilização da coleção de ports irá ocupar espaço em disco ao longo do tempo. Depois de compilar e instalar um port, executar `make clean` dentro do diretório de um port limpará o diretório temporário de [.filename]#trabalho#. Se o Portmaster for usado para instalar um port, ele removerá automaticamente esse diretório, a menos que `-K` seja especificado. Se o Portupgrade estiver instalado, este comando removerá todos os diretórios de [.filename]#trabalho# encontrados na cópia local da coleção de ports:

[source,shell]
....
# portsclean -C
....

Além disso, arquivos de distribuição de código-fonte desatualizados se acumulam no [.filename]#/usr/ports/distfiles# ao longo do tempo. Para usar Portupgrade para excluir todos os distfiles que não são mais referenciados por nenhum port:

[source,shell]
....
# portsclean -D
....

O Portupgrade pode remover todos os distfiles não referenciados por qualquer port atualmente instalado no sistema:

[source,shell]
....
# portsclean -DD
....

Se o Portmaster estiver instalado, use:

[source,shell]
....
# portmaster --clean-distfiles
....

Por padrão, esse comando é interativo e solicita que o usuário confirme se um distfile deve ser excluído.

Além desses comandos, o package:ports-mgmt/pkg_cutleaves[] automatiza a tarefa de remover os ports instalados que não são mais necessários.

[[ports-poudriere]]
== Compilando Pacotes com o Poudriere

O Poudriere é um utilitário licenciado sob a licença BSD para criar e testar pacotes do FreeBSD. Ele usa o jails do FreeBSD para configurar ambientes de compilação isolados. Esses jails podem ser usados para compilar pacotes para versões do FreeBSD que são diferentes do sistema no qual ele está instalado, e também para construir pacotes para o i386 se o host for um sistema amd64. Uma vez que os pacotes são compilados, eles estão em um layout idêntico aos espelhos oficiais. Esses pacotes podem ser usados pelo man:pkg[8] e por outras ferramentas de gerenciamento de pacotes.

O Poudriere é instalado usando o pacote ou port package:ports-mgmt/poudriere[]. A instalação inclui um arquivo de configuração de exemplo, [.filename]#/usr/local/etc/poudriere.conf.sample#. Copie este arquivo para [.filename]#/usr/local/etc/poudriere.conf#. Edite o arquivo copiado de acordo com a configuração local.

Embora o ZFS não seja necessário no sistema que executa o poudriere, o seu uso é benéfico. Quando o ZFS é usado, o `ZPOOL` deve ser especificado em [.filename]#/usr/local/etc/poudriere.conf# e o `FREEBSD_HOST` deve ser definido para um espelho próximo. A definição de `CCACHE_DIR` permite o uso de package:devel/ccache[] para armazenar em cache a compilação e reduzir os tempos de compilação para o código compilado com freqüência. Pode ser conveniente colocar os conjuntos de dados do poudriere em uma árvore isolada montada em [.filename]#/poudriere#. Os valores padrões para as outras variáveis de configuração são adequados.

O número de núcleos do processador detectados é usado para definir quantas compilações serão executadas em paralelo. Forneça memória virtual suficiente, seja por meio de RAM ou espaço de swap. Se a memória virtual se esgotar, as jails de compilação serão interrompidas e desativadas, resultando em mensagens de erro estranhas.

[[poudriere-initialization]]
=== Inicializar o Jails e o Port Trees

Após a configuração, inicialize o poudriere para que ele instale um jail com a árvore do FreeBSD requerida e uma árvore de ports. Especifique um nome para o jail usando `-j` e a versão do FreeBSD com `-v`. Em sistemas que executam o FreeBSD/amd64, a arquitetura pode ser definida com `-a` para `i386` ou `amd64`. O padrão é a arquitetura mostrada pelo `uname`.

[source,shell]
....
# poudriere jail -c -j 11amd64 -v 11.4-RELEASE
[00:00:00] Creating 11amd64 fs at /poudriere/jails/11amd64... done
[00:00:00] Using pre-distributed MANIFEST for FreeBSD 11.4-RELEASE amd64
[00:00:00] Fetching base for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/base.txz              125 MB 4110 kBps    31s
[00:00:33] Extracting base... done
[00:00:54] Fetching src for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/src.txz               154 MB 4178 kBps    38s
[00:01:33] Extracting src... done
[00:02:31] Fetching lib32 for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
[00:02:38] Extracting lib32... done
[00:02:42] Cleaning up... done
[00:02:42] Recording filesystem state for clean... done
[00:02:42] Upgrading using ftp
/etc/resolv.conf -> /poudriere/jails/11amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... done.
Fetching metadata signature for 11.4-RELEASE from update4.freebsd.org... done.
Fetching metadata index... done.
Fetching 2 metadata files... done.
Inspecting system... done.
Preparing to download files... done.
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. done.
Applying patches... done.
Fetching 6 files... done.
The following files will be added as part of updating to
11.4-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
11.4-RELEASE-p1:
[…]
Installing updates...Scanning //usr/share/certs/blacklisted for certificates...
Scanning //usr/share/certs/trusted for certificates...
 done.
11.4-RELEASE-p1
[00:04:06] Recording filesystem state for clean... done
[00:04:07] Jail 11amd64 11.4-RELEASE-p1 amd64 is ready to be used
....

[source,shell]
....
# poudriere ports -c -p local -m svn+https
[00:00:00] Creating local fs at /poudriere/ports/local... done
[00:00:00] Checking out the ports tree... done
....

Em um único computador, o poudriere pode construir ports com várias configurações, em vários jails e de diferentes árvores de ports. Configurações customizadas para estas combinações são chamadas de _sets_. Veja a seção CUSTOMIZAÇÃO do man:poudriere[8] para detalhes depois que o package:ports-mgmt/poudriere[] ou o package:ports-mgmt/poudriere-devel[] estiver instalado.

A configuração básica mostrada aqui coloca um único jail-, port-, e um set específico [.filename]#make.conf# em [.filename]#/usr/local/etc/poudriere.d#. O nome do arquivo neste exemplo é criado combinando o nome do jail, o nome do port e o nome do set: [.filename]#11amd64-local-workstation-make.conf#. O sistema [.filename]#make.conf# e este novo arquivo são combinados em tempo de compilação para criar o [.filename]#make.conf# usado pela jail de compilação.

Os pacotes a serem criados são inseridos em [.filename]#11amd64-local-workstation-pkglist#:

[.programlisting]
....
editors/emacs
devel/git
ports-mgmt/pkg
...
....

Opções e dependências para os ports especificados são configuradas:

[source,shell]
....
# poudriere options -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist
....

Finalmente, os pacotes são compilados e um repositório de pacotes é criado:

[source,shell]
....
# poudriere bulk -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist
....

Durante a execução, pressionar kbd:[Ctrl+t] exibe o estado atual da compilação. O Poudriere também cria arquivos em [.filename]#/poudriere/logs/bulk/jailname# que podem ser usados com um servidor da Web para exibir informações de compilação.

Após a conclusão, os novos pacotes estão agora disponíveis para instalação a partir do repositório poudriere.

Para obter maiores informações sobre o uso do poudriere, consulte man:poudriere[8] e o site principal, https://github.com/freebsd/poudriere/wiki[].

=== Configurando Clientes do pkg para usar um repositório de Poudriere

Embora seja possível usar um repositório personalizado ao lado do repositório oficial, às vezes é útil desativar o repositório oficial. Isso é feito criando um arquivo de configuração que substitui e desativa o arquivo de configuração oficial. Crie o [.filename]#/usr/local/etc/pkg/repos/FreeBSD.conf# que deverá conter o seguinte:

[.programlisting]
....
FreeBSD: {
	enabled: no
}
....

Geralmente é mais fácil disponibilizar um repositório poudriere para as máquinas clientes via HTTP. Configure um servidor web para disponibilizar o diretório de pacotes, por exemplo: [.filename]#/usr/local/poudriere/data/packages/11amd64#, onde [.filename]#11amd64# é o nome da compilação.

Se a URL para o repositório de pacotes for: `http://pkg.example.com/11amd64`, o arquivo de configuração do repositório em [.filename]#/usr/local/etc/pkg/repos/custom.conf# ficaria assim:

[.programlisting]
....
custom: {
	url: "http://pkg.example.com/11amd64",
	enabled: yes,
}
....

[[ports-nextsteps]]
== Considerações pós-instalação

Independentemente do software ter sido instalado a partir de um pacote binário ou de um port, a maioria dos aplicativos de terceiros requer algum nível de configuração após a instalação. Os seguintes comandos e locais podem ser usados para ajudar a determinar o que foi instalado com o aplicativo.

* A maioria dos aplicativos instala pelo menos um arquivo de configuração padrão em [.filename]#/usr/local/etc#. Nos casos em que um aplicativo possui um grande número de arquivos de configuração, um subdiretório será criado para mantê-los. Geralmente, os arquivos de configuração de exemplo são instalados e terminam com um sufixo, como [.filename]#.sample#. Os arquivos de configuração devem ser revisados e possivelmente editados para atender às necessidades do sistema. Para editar um arquivo de amostra, primeiro copie-o sem a extensão [.filename]#.sample#.
* As aplicações que fornecem documentação irão instalá-la em [.filename]#/usr/local/shared/doc# e muitos aplicativos também instalam páginas de manual. Esta documentação deve ser consultada antes de continuar.
* Alguns aplicativos executam serviços que devem ser adicionados ao [.filename]#/etc/rc.conf# antes de iniciar o aplicativo. Esses aplicativos geralmente instalam um script de inicialização em [.filename]#/usr/local/etc/rc.d#. Veja crossref:config[configtuning-starting-services, Iniciando Serviços] para maiores informações.
+
[NOTE]
====
Por padrão, os aplicativos não executam o script de inicialização durante a instalação, nem executam o script de parada após a desinstalação ou atualização. Essa decisão é deixada para o administrador do sistema.
====

* Os usuários de man:csh[1] devem executar `rehash` para reconstruir a lista dos binários conhecidos nos shells `PATH`.
* Use `pkg info` para determinar quais arquivos, páginas man e binários foram instalados com o aplicativo.

[[ports-broken]]
== Lidando com ports quebrados

Quando um port não é compilado ou instalado, tente o seguinte:

. Procure para ver se há uma correção pendente para o port no https://www.FreeBSD.org/support/[Banco de Dados do Relatório de Problemas]. Nesse caso, implementar a correção proposta pode corrigir o problema.
. Peça ajuda ao mantenedor do port. Digite `make maintainer` no diretório do port ou leia o [.filename]#Makefile# do port para encontrar o endereço de e-mail do mantenedor. Lembre-se de incluir a linha `$FreeBSD:` do [.filename]#Makefile# do port e a saída que leva ao erro no e-mail para o mantenedor.
+
[NOTE]
====
Alguns ports não são mantidos por um indivíduo, mas sim por um grupo de mantenedores representado por uma extref:{mailing-list-faq}[lista de discussão]. Muitos, mas não todos, esses endereços se parecem com mailto:freebsd-listname@FreeBSD.org[freebsd-listname@FreeBSD.org]. Por favor, leve isso em consideração ao enviar um email.

Em particular, os ports mantidos por mailto:ports@FreeBSD.org[ports@FreeBSD.org] não são mantidos por um indivíduo específico. Em vez disso, quaisquer correções e suporte vêm da comunidade geral que se inscreve nessa lista de discussão. Mais voluntários são sempre necessários!
====
+ 
Se não houver resposta ao email, use o Bugzilla para enviar um relatório de bug usando as instruções em extref:{problem-reports}[Escrevendo Relatórios de Problemas do FreeBSD].
. Conserte-o! O extref:{porters-handbook}[Porters Handbook] inclui informações detalhadas sobre a infra-estrutura da arvore de ports para que você possa corrigir possiveis erros na compilacao de um ports que quebrou ou ocasionou um erro de compilacao ou até mesmo submeta seu próprio projeto!
. Instale o pacote em vez do port usando as instruções em <<pkgng-intro>>.
