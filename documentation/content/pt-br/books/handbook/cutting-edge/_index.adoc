---
title: Capítulo 23. Atualização e Upgrade do FreeBSD
part: Parte III. Administração do Sistema
prev: books/handbook/l10n
next: books/handbook/dtrace
showBookMenu: true
weight: 27
path: "/books/handbook/cutting-edge/"
---

[[updating-upgrading]]
= Atualização e Upgrade do FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 23
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/cutting-edge/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[updating-upgrading-synopsis]]
== Sinopse

O FreeBSD está em constante desenvolvimento entre os releases. Algumas pessoas preferem usar as versões lançadas oficialmente, enquanto outras preferem se manter em sincronia com os últimos desenvolvimentos. No entanto, até mesmo versões oficiais são atualizadas com patches de segurança e outras correções críticas. Independentemente da versão usada, o FreeBSD fornece todas as ferramentas necessárias para manter o sistema atualizado e permite atualizações fáceis entre as versões. Este capítulo descreve como acompanhar o sistema de desenvolvimento e o uso das ferramentas básicas para manter um sistema FreeBSD atualizado.

Depois de ler este capítulo, você saberá:

* Como manter um sistema FreeBSD atualizado com o freebsd-update ou com o Subversion.
* Como comparar o estado de um sistema instalado com uma cópia original.
* Como manter a documentação instalada atualizada com o Subversion ou com o port da documentação.
* A diferença entre os dois ramos de desenvolvimento: FreeBSD-STABLE e FreeBSD-CURRENT.
* Como recompilar e reinstalar todo o sistema básico.

Antes de ler este capítulo, você deve:

* Configurar corretamente a conexão de rede (crossref:advanced-networking[advanced-networking, Rede Avançada]).
* Saber como instalar software adicional de terceiros (crossref:ports[ports, Instalando Aplicativos. Pacotes e Ports]).

[NOTE]
====
Ao longo deste capítulo, o `svnlite` é usado para obter e atualizar o código fonte do FreeBSD. Opcionalmente, o port ou pacote package:devel/subversion[] pode ser usado.
====

[[updating-upgrading-freebsdupdate]]
== Atualização do FreeBSD

A aplicação de patches de segurança em tempo hábil e a atualização para uma versão mais recente de um sistema operacional são aspectos importantes da administração contínua do sistema. O FreeBSD inclui um utilitário chamado `freebsd-update` o qual pode ser usado para executar ambas as tarefas.

Este utilitário suporta atualizações binárias de segurança e de erratas para o FreeBSD, sem a necessidade de compilar e instalar manualmente o patch ou um novo kernel. Atualizações binárias estão disponíveis para todas as arquiteturas e versões atualmente suportadas pela equipe de segurança. A lista de versões suportadas e suas datas estimadas de fim de vida estão listadas em https://www.FreeBSD.org/security/[https://www.FreeBSD.org/security/].

Este utilitário também suporta upgrades do sistema operacional para releases menores (ponto x), bem como atualizações para outro ramo de release. Antes de atualizar para uma nova versão, revise o seu anúncio de lançamento, pois ele contém informações importantes pertinentes ao release. Os anúncios de lançamento estão disponíveis em https://www.FreeBSD.org/releases/[https://www.FreeBSD.org/releases/].

[NOTE]
====
Se um `crontab` utilizando os recursos do man:freebsd-update[8] existir, ele deve ser desativado antes de atualizar o sistema operacional .
====

Esta seção descreve o arquivo de configuração usado pelo `freebsd-update`, demonstra como aplicar um patch de segurança e como atualizar para um release menor ou principal do sistema operacional e discute algumas das considerações ao atualizar o sistema operacional .

[[freebsdupdate-config-file]]
=== O Arquivo de Configuração

O arquivo de configuração padrão do `freebsd-update` funciona como está. Alguns usuários podem querer ajustar a configuração padrão no [.filename]#/etc/freebsd-update.conf#, permitindo um melhor controle do processo. Os comentários neste arquivo explicam as opções disponíveis, mas os seguintes podem exigir um pouco mais de explicação:

[.programlisting]
....
# Componentes do sistema base que devem ser mantidos atualizados.
Components world kernel
....

Este parâmetro controla quais partes do FreeBSD serão mantidas atualizadas. O padrão é atualizar todo o sistema básico e o kernel. Componentes individuais podem ser especificados, como `src/base` ou `src/sys`. No entanto, a melhor opção é deixar isso no padrão, pois alterá-lo para incluir itens específicos requer que todos os itens necessários sejam listados. Com o tempo, isso pode ter consequências desastrosas, pois o código-fonte e os binários podem ficar fora de sincronia.

[.programlisting]
....
# Caminhos que começam com qualquer coisa que corresponda a uma entrada em uma 
# declaração IgnorePaths será ignorada.
IgnorePaths /boot/kernel/linker.hints
....

Para deixar diretórios especificados, como [.filename]#/bin# ou [.filename]#/sbin#, intocados durante o processo de atualização, adicione seus caminhos a esta instrução. Esta opção pode ser usada para evitar que o `freebsd-update` substitua as modificações locais.

[.programlisting]
....
# Caminhos que começam com qualquer coisa que corresponda a uma entrada em uma declaração  
# UpdateIfUnmodified só será atualizada se o conteúdo do arquivo não tiver sido
# modificado pelo usuário (a menos que as alterações sejam mescladas; veja abaixo).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile
....

Esta opção atualizará apenas os arquivos de configuração não modificados nos diretórios especificados. Quaisquer alterações feitas pelo usuário impedirão a atualização automática desses arquivos. Existe outra opção, `KeepModifiedMetadata`, que instruirá o `freebsd-update` para salvar as alterações durante a mesclagem.

[.programlisting]
....
# Ao fazer o upgrade para uma nova versão do FreeBSD, os arquivos que forem especificados no MergeChanges
# terão quaisquer alterações locais mescladas na versão da nova release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints
....

Lista de diretórios com arquivos de configuração que o `freebsd-update` deve tentar mesclar. O processo de mesclagem de arquivos é uma série de patches man:diff[1] semelhantes a man:mergemaster[8], mas com menos opções. As mesclagens são aceitas, abrem um editor ou fazem com que o `freebsd-update` aborte. Em caso de dúvida, faça backup do [.filename]#/etc# e apenas aceite as mesclagens. Veja man:mergemaster[8] para maiores informações sobre o `mergemaster`.

[.programlisting]
....
# Diretório no qual armazenar atualizações baixadas e arquivos 
# temporários usados pelo FreeBSD Update.
# WorkDir /var/db/freebsd-update
....

Este diretório é onde todos os patches e arquivos temporários são colocados. Nos casos em que o usuário estiver fazendo uma atualização de versão, esse local deverá ter pelo menos um gigabyte de espaço em disco disponível.

[.programlisting]
....
# Ao atualizar entre releases, a lista de Componentes deve ser lida de forma estrita (StrictComponents yes)
# ou meramente como uma lista de componentes que *podem* ser instalados de quais atualizações do 
# FreeBSD devem ser instaladas e atualizadas (StrictComponents no)?
# StrictComponents no
....

Quando esta opção estiver definida como `yes`, o `freebsd-update` assumirá que a lista `Componentes` está completa e não tentará fazer alterações fora da lista. Efetivamente, o `freebsd-update` tentará atualizar todos os arquivos que pertencem à lista `Componentes`.

[[freebsdupdate-security-patches]]
=== Aplicando Patches de Segurança

O processo de aplicação de patches de segurança do FreeBSD foi simplificado, permitindo que um administrador mantenha um sistema totalmente corrigido usando o `freebsd-update`. Maiores informações sobre os avisos de segurança do FreeBSD podem ser encontradas em crossref:security[security-advisories,Avisos de Segurança do FreeBSD].

Patches de segurança do FreeBSD podem ser baixados e instalados usando os seguintes comandos. O primeiro comando determinará se algum patch pendente está disponível e, em caso afirmativo, listará os arquivos que serão modificados se os patches forem aplicados. O segundo comando aplicará os patches.

[source,shell]
....
# freebsd-update fetch
# freebsd-update install
....

Se a atualização aplicar alguma correção de kernel, o sistema precisará de uma reinicialização para inicializar no kernel corrigido. Se o patch for aplicado a qualquer binário em execução, os aplicativos afetados devem ser reiniciados para que a versão corrigida do binário seja usada.

[NOTE]
====
Normalmente, o usuário precisa estar preparado para reiniciar o sistema. Para saber se uma reinicialização é necessária por uma atualização do kernel, execute os comandos `freebsd-version -k` e `uname -r` e se eles forem diferentes, é necessário reiniciar.
====

O sistema pode ser configurado para verificar automaticamente as atualizações uma vez por dia, adicionando esta entrada ao [.filename]#/etc/crontab#:

[.programlisting]
....
@daily                                  root    freebsd-update cron
....

Se houver patches, eles serão automaticamente baixados, mas não serão aplicados. O usuário `root` receberá um email para que os patches possam ser revisados e instalados manualmente com o `freebsd-update install`.

Se algo der errado, o `freebsd-update` terá a capacidade de reverter o último conjunto de alterações com o seguinte comando:

[source,shell]
....
# freebsd-update rollback
Uninstalling updates... done.
....

Novamente, o sistema deve ser reiniciado se o kernel ou qualquer módulo do kernel for modificado e quaisquer binários afetados devem ser reiniciados.

Apenas o kernel [.filename]#GENERIC# pode ser atualizado automaticamente pelo `freebsd-update`. Se um kernel personalizado estiver instalado, ele terá que ser recompilado e reinstalado depois que o `freebsd-update` terminar de instalar as atualizações. No entanto, o `freebsd-update` detectará e atualizará o kernel _GENERIC_ se [.filename]#/boot/GENERIC# existir, mesmo que não seja o kernel atual em execução no sistema. Para verificar detalhes desta instalação utilize o comando man:uname[1].

[NOTE]
====
Sempre mantenha uma cópia do kernel [.filename]#GENERIC# em [.filename]#/boot/GENERIC#. Será útil no diagnóstico de vários problemas e na execução de atualizações de versão. Consulte <<freebsd-update-custom-kernel-9x>> para obter instruções sobre como obter uma cópia do kernel [.filename]#GENERIC#.
====

A menos que a configuração padrão em [.filename]#/etc/freebsd-update.conf# tenha sido alterada, o `freebsd-update` instalará o código fonte atualizado do kernel juntamente com o restante das atualizações. O processo de recompilação e reinstalação de um novo kernel personalizado poderá ser executado da maneira usual.

As atualizações distribuídas pelo `freebsd-update` nem sempre envolvem o kernel. Não é necessário recompilar um kernel personalizado se o código fonte do kernel não tiverem sido modificado pelo `freebsd-update install`. No entanto, o `freebsd-update` sempre atualizará o [.filename]#/usr/src/sys/conf/newvers.sh#. O nível de patch atual, conforme indicado pelo número `-p` relatado pelo `uname -r`, é obtido desse arquivo. Recompilar um kernel personalizado, mesmo que nada mais tenha sido alterado, permite que o `uname` relate com precisão o nível de patch atual do sistema. Isso é particularmente útil ao manter vários sistemas, pois permite uma avaliação rápida das atualizações instaladas em cada um deles.

[[freebsdupdate-upgrade]]
=== Realizando Upgrades de Versão Principais e Menores

Atualizações de uma versão menor do FreeBSD para outra, como do FreeBSD 9.0 para o FreeBSD 9.1, são chamadas de upgrades de _versão menor_. Atualizações de _versões principais_ ocorrem quando o FreeBSD é atualizado de uma versão principal para outra, como do FreeBSD 9.X para o FreeBSD 10.X. Ambos os tipos de atualizações podem ser executados fornecendo um target de versão de release para o `freebsd-update`.

[NOTE]
====
Se o sistema estiver executando um kernel personalizado, certifique-se de que uma cópia do kernel [.filename]#GENERIC# exista em [.filename]#/boot/GENERIC# antes de iniciar o upgrade. Consulte <<freebsd-update-custom-kernel-9x>> para obter instruções sobre como obter uma cópia do kernel [.filename]#GENERIC#.
====

O seguinte comando, quando executado em um sistema FreeBSD 9.0, irá atualizá-lo para o FreeBSD 9.1:

[source,shell]
....
# freebsd-update -r 9.1-RELEASE upgrade
....

Depois que o comando for recebido, o `freebsd-update` avaliará o arquivo de configuração e o sistema atual na tentativa de reunir as informações necessárias para executar a atualização. Uma listagem de tela exibirá quais componentes foram e quais não foram detectados. Por exemplo:

[source,shell]
....
Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y
....

Neste ponto, o `freebsd-update` tentará baixar todos os arquivos necessários para a atualização. Em alguns casos, o usuário pode ser questionado sobre o que instalar ou como proceder.

Ao usar um kernel personalizado, a etapa acima produzirá um aviso semelhante ao seguinte:

[source,shell]
....
WARNING: This system is running a "MYKERNEL" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"
....

Este aviso pode ser ignorado com segurança neste momento. O kernel [.filename]#GENERIC# atualizado será usado como uma etapa intermediária no processo de atualização.

Depois que todos os patches tiverem sido baixados para o sistema local, eles serão aplicados. Esse processo pode demorar um pouco, dependendo da velocidade e da carga de trabalho da máquina. Os arquivos de configuração serão então mesclados. O processo de mesclagem requer alguma intervenção do usuário, pois um arquivo pode ser mesclado ou um editor pode aparecer na tela para uma mesclagem manual. Os resultados de cada mesclagem bem-sucedida serão mostrados para o usuário enquanto o processo continua. Um merge falho ou ignorado fará com que o processo seja abortado. Os usuários podem desejar fazer um backup de [.filename]#/etc# e mesclar manualmente os arquivos importantes, como o [.filename]#master.passwd# ou o [.filename]#group# posteriormente.

[NOTE]
====
O sistema não está sendo alterado, já que todos os patches e merges estão acontecendo em outro diretório. Uma vez que todas as correções tenham sido aplicadas com sucesso, e todos os arquivos de configuração foram mesclados e tudo indicar que o processo ocorrerá sem problemas, as alterações poderão ser confirmadas pelo usuário usando o seguinte comando:

[source,shell]
....
# freebsd-update install
....

====

O kernel e os módulos do kernel serão atualizados primeiro. Se o sistema estiver sendo executado com um kernel personalizado, use o man:nextboot[8] para definir que o kernel para a próxima inicialização será o [.filename]#/boot/GENERIC#:

[source,shell]
....
# nextboot -k GENERIC
....

[WARNING]
====

Antes de reinicializar com o kernel [.filename]#GENERIC#, verifique se ele contém todos os drivers necessários para o sistema inicializar corretamente e se conectar à rede, se a máquina que está sendo atualizada for acessada remotamente. Em particular, se o kernel customizado em execução contiver funcionalidades internas normalmente fornecidas pelos módulos do kernel, certifique-se de carregar temporariamente estes módulos no kernel [.filename]#GENERIC# usando o [.filename]#/boot/loader.conf#. Recomenda-se desabilitar os serviços não essenciais, bem como todas as montagens de disco e de rede, até que o processo de atualização seja concluído.
====

A máquina agora deve ser reiniciada com o kernel atualizado:

[source,shell]
....
# shutdown -r now
....

Quando o sistema estiver on-line, reinicie o `freebsd-update` usando o comando a seguir. Como o estado do processo foi salvo, o `freebsd-update` não será iniciado desde o início, mas passará para a próxima fase e removerá todas as bibliotecas compartilhadas e os arquivos de objetos antigos.

[source,shell]
....
# freebsd-update install
....

[NOTE]
====
Dependendo se os números de versão de uma biblioteca foram incrementados ou não, pode haver apenas duas fases de instalação em vez de três.
====

A atualização está completa agora. Se esta for uma atualização de versão principal, reinstale todas os ports e pacotes conforme descrito em <<freebsdupdate-portsrebuild>>.

[[freebsd-update-custom-kernel-9x]]
==== Kernels personalizados com o FreeBSD 9.X e posteriores

Antes de usar o `freebsd-update`, assegure-se de que uma cópia do kernel [.filename]#GENERIC# exista em [.filename]#/boot/GENERIC#. Se um kernel personalizado foi compilado apenas uma vez, o kernel em [.filename]#/boot/kernel.old# é o kernel `GENERIC`. Simplesmente renomeie este diretório para [.filename]#/boot/GENERIC#.

Se um kernel personalizado foi compilado mais de uma vez ou se é desconhecido quantas vezes o kernel personalizado foi compilado, obtenha uma cópia do kernel `GENERIC` que corresponda à versão atual do sistema operacional. Se o acesso físico ao sistema estiver disponível, uma cópia do kernel `GENERIC` pode ser instalada a partir da mídia de instalação:

[source,shell]
....
# mount /cdrom
# cd /cdrom/usr/freebsd-dist
# tar -C/ -xvf kernel.txz boot/kernel/kernel
....

Como alternativa, o kernel `GENERIC` pode ser recriado e instalado a partir da do código fonte:

[source,shell]
....
# cd /usr/src
# make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null
....

Para que este kernel seja identificado como o kernel `GENERIC` pelo `freebsd-update`, o arquivo de configuração [.filename]#GENERIC# não deve ter sido modificado de forma alguma. Também é sugerido que o kernel seja compilado sem outras opções especiais.

A reinicialização no kernel [.filename]#GENERIC# não é necessária, pois o `freebsd-update` só precisa que o [.filename]#/boot/GENERIC# exista.

[[freebsdupdate-portsrebuild]]
==== Atualizando pacotes após atualizar para uma versão principal (Major Release)

Geralmente, os aplicativos instalados continuarão funcionando sem problemas após atualizações de versões menores. As versões principais usam diferentes interfaces binárias de aplicativos (ABIs), que quebram a maioria dos aplicativos de terceiros. Após uma atualização de versão principal, todos os pacotes e ports instalados precisam ser atualizados. Pacotes podem ser atualizados usando `pkg upgrade`. Para atualizar os ports instalados, use um utilitário como o package:ports-mgmt/portmaster[].

Uma atualização forçada de todos os pacotes instalados substituirá os pacotes por novas versões a partir do repositório, mesmo que o número da versão não tenha aumentado. Isso é necessário por causa da alteração da versão do ABI que ocorre ao atualizar entre versões principais do FreeBSD. A atualização forçada pode ser realizada executando:

[source,shell]
....
# pkg-static upgrade -f
....

Uma recompilação de todos os aplicativos instalados pode ser realizada com este comando:

[source,shell]
....
# portmaster -af
....

Este comando exibirá as telas de configuração de cada aplicativo que possui opções configuráveis e aguardará que o usuário interaja com estas telas. Para evitar esse comportamento e usar apenas as opções padrões, inclua `-G` no comando acima.

Quando as atualizações de software estiverem concluídas, conclua o processo de atualização com uma chamada final para o `freebsd-update` para amarrar todas as pontas soltas no processo de atualização:

[source,shell]
....
# freebsd-update install
....

Se o kernel [.filename]#GENERIC# foi usado temporariamente, este é o momento de construir e instalar um novo kernel personalizado usando as instruções do crossref:kernelconfig[kernelconfig, Configurando o kernel do FreeBSD].

Reinicialize a máquina na nova versão do FreeBSD. O processo de atualização está concluído agora.

[[freebsdupdate-system-comparison]]
=== Comparação do estado do sistema

O estado da versão instalada do FreeBSD em relação a uma boa cópia conhecida pode ser testado usando o `freebsd-update IDS`. Este comando avalia a versão atual dos utilitários do sistema, bibliotecas e arquivos de configuração e pode ser usado como um Sistema de Detecção de Intrusão embutido (IDS).

[WARNING]
====

Este comando não é um substituto para um IDS real como o package:security/snort[]. Como o `freebsd-update` armazena dados no disco, a possibilidade de adulteração é evidente. Embora esta possibilidade possa ser reduzida usando o `kern.securelevel` e armazenando os dados do `freebsd-update` em um sistema de arquivos read-only quando não estiver em uso, uma solução melhor seria comparar o sistema com um disco seguro, como um DVD ou dispositivo de disco externo USB armazenado em segurança. Um método alternativo para fornecer a funcionalidade de IDS usando um utilitário interno é descrito em crossref:security[security-ids,Verificação Binária]
====

Para começar a comparação, especifique um arquivo de saída para salvar os resultados:

[source,shell]
....
# freebsd-update IDS >> outfile.ids
....

O sistema agora será inspecionado e uma longa lista de arquivos, junto com os valores de hash SHA256 tanto para o valor conhecido na release e como na instalação atual, será enviada para o arquivo de saída especificado.

As entradas na listagem são extremamente longas, mas o formato de saída pode ser facilmente analisado. Por exemplo, para obter uma lista de todos os arquivos que diferem daqueles na release, execute o seguinte comando:

[source,shell]
....
# cat outfile.ids | awk '{ print $1 }' | more
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf
....

Este exemplo de saída foi truncado, pois existem muito mais arquivos. Alguns arquivos possuem modificações naturais. Por exemplo, o [.filename]#/etc/passwd# será modificado se usuários tiverem sido adicionados ao sistema. Módulos de kernel podem diferir pois o `freebsd-update` pode tê-los atualizado. Para excluir arquivos ou diretórios específicos, adicione-os à opção `IDSIgnorePaths` em [.filename]#/etc/freebsd-update.conf#.

[[updating-upgrading-documentation]]
== Atualizando o Conjunto de Documentação

A documentação é parte integrante do sistema operacional FreeBSD. Enquanto uma versão atualizada da documentação do FreeBSD está sempre disponível no site do FreeBSD (https://www.FreeBSD.org/doc/[https://www.freebsd.org/doc/]), pode ser útil ter uma cópia local atualizada do site do FreeBSD, manuais, FAQ e artigos.

Esta seção descreve como usar os fontes ou a Coleção de Ports do FreeBSD para manter uma cópia local da documentação do FreeBSD atualizada.

Para obter informações sobre como editar e enviar correções para a documentação, consulte o Primer do Projeto de Documentação do FreeBSD para Novos Colaboradores (extref:{fdp-primer}[Primer do Projeto de Documentação do FreeBSD]).

[[updating-installed-documentation]]
=== Atualizando a documentação a partir do código-fonte

Recompilar a documentação do FreeBSD a partir do código-fonte requer uma coleção de ferramentas que não fazem parte do sistema básico do FreeBSD. As ferramentas necessárias podem ser instaladas a partir do pacote package:textproc/docproj[] ou do port desenvolvido pelo Projeto de Documentação do FreeBSD.

Uma vez instalado, use o svnlite para buscar uma cópia limpa dos fontes da documentação:

[source,shell]
....
# svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc
....

O download inicial dos fontes da documentação pode demorar um pouco. Deixe executar até completar.

Futuras atualizações dos fontes da documentação podem ser obtidas executando:

[source,shell]
....
# svnlite update /usr/doc
....

Depois que um snapshot atualizado dos fontes da documentação for obtido e disponibilizado em [.filename]#/usr/doc#, tudo estará pronto para uma atualização da documentação instalada.

Uma atualização completa de todos os idiomas disponíveis pode ser realizada digitando:

[source,shell]
....
# cd /usr/doc
# make install clean
....

Se uma atualização de apenas um idioma específico for desejada, o `make` pode ser executado em um subdiretório específico de idioma do [.filename]#/usr/doc#:

[source,shell]
....
# cd /usr/doc/en_US.ISO8859-1
# make install clean
....

Uma maneira alternativa de atualizar a documentação é executar este comando a partir do [.filename]#/usr/doc# ou do subdiretório específico do idioma desejado:

[source,shell]
....
# make update
....

Os formatos de saída que serão instalados podem ser especificados definindo o parâmetro `FORMATS`:

[source,shell]
....
# cd /usr/doc
# make FORMATS='html html-split' install clean
....

Várias opções estão disponíveis para facilitar o processo de atualização de apenas partes da documentação ou a construção de traduções específicas. Estas opções podem ser configuradas como opções de todo o sistema no [.filename]#/etc/make.conf#, ou como opções de linha de comando passadas para o `make`.

As opções incluem:

`DOC_LANG`::
A lista de idiomas e codificações para compilar e instalar, como `en_US.ISO8859-1` para documentação em inglês.

`FORMATS`::
Um formato único ou uma lista de formatos de saída a serem criados. Atualmente os formatos suportados são, `html`, `html-split`, `txt`, `ps`, e `pdf`.

`DOCDIR`::
Onde instalar a documentação. O padrão é [.filename]#/usr/shared/doc#.

Para mais variáveis do `make` suportadas como opções system-wide no FreeBSD, consulte man:make.conf[5].

[[doc-ports-install-package]]
=== Atualizando a documentação a partir do ports

A seção anterior apresentou um método para atualizar a documentação do FreeBSD a partir do código fonte. Esta seção descreve um método alternativo que usa a Coleção de Ports e possibilita:

* Instalar pacotes pré-compilados da documentação, sem precisar compilar nada localmente ou instalar o conjunto de ferramentas de documentação.
* Compilar o código fonte da documentação por meio do framework de ports, facilitando o check-out e as etapas de compilação.

Este método de atualização da documentação do FreeBSD é suportado por um conjunto de ports e pacotes de documentação que são atualizados mensalmente pela Equipe de Engenharia da Documentação mailto:doceng@FreeBSD.org[doceng@FreeBSD.org]. Eles estão listados na Coleção de Ports do FreeBSD, na categoria docs (http://www.freshports.org/docs/[http://www.freshports.org/docs/]).

A organização dos ports de documentação é a seguinte:

* O pacote ou port package:misc/freebsd-doc-en[] instala toda a documentação em inglês.
* O meta-pacote ou port do pacote package:misc/freebsd-doc-all[] instala toda a documentação em todos os idiomas disponíveis.
* Existe um pacote e um port para cada tradução, como package:misc/freebsd-doc-hu[] para a documentação húngara.

Quando pacotes binários são usados, a documentação do FreeBSD será instalada em todos os formatos disponíveis para o idioma especificado. Por exemplo, o comando a seguir instalará o pacote mais recente da documentação em húngaro:

[source,shell]
....
# pkg install hu-freebsd-doc
....

[NOTE]
====
Os pacotes usam um formato que difere do nome do port correspondente: `_lang_-freebsd-doc`, onde _lang_ é o formato abreviado do código de idioma, como `hu` para húngaro, ou `zh_cn` para chinês simplificado.
====

Para especificar o formato da documentação, compile o port em vez de instalar o pacote. Por exemplo, para compilar e instalar a documentação em inglês:

[source,shell]
....
# cd /usr/ports/misc/freebsd-doc-en
# make install clean
....

O port fornece um menu de configuração no qual o formato para compilar e instalar pode ser especificado. Por padrão, o  HTML dividido, semelhante ao formato usado em http://www.FreeBSD.org[http://www.FreeBSD.org] e o PDF estão selecionados.

Alternativamente, várias opções `make` podem ser especificadas ao compilar um port de documentação, incluindo:

`WITH_HTML`::
Cria o formato HTML com um único arquivo HTML por documento. A documentação formatada é salva em um arquivo chamado [.filename]#article.html# ou [.filename]#book.html#.

`WITH_PDF`::
A documentação formatada é salva em um arquivo chamado [.filename]#article.pd# ou [.filename]#book.pdf#.

`DOCBASE`::
Especifica onde instalar a documentação. O padrão é [.filename]#/usr/local/shared/doc/freebsd#.

Este exemplo usa variáveis para instalar a documentação húngara como um arquivo PDF no diretório especificado:

[source,shell]
....
# cd /usr/ports/misc/freebsd-doc-hu
# make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean
....

Pacotes ou ports de documentação podem ser atualizados usando as instruções em crossref:ports[ports, Instalando Aplicativos. Pacotes e Ports]. Por exemplo, o seguinte comando atualiza a documentação húngara instalada usando package:ports-mgmt/portmaster[] através do uso apenas de pacotes:

[source,shell]
....
# portmaster -PP hu-freebsd-doc
....

[[current-stable]]
== Acompanhando um ramo de desenvolvimento

O FreeBSD possui duas ramificações de desenvolvimento: FreeBSD-CURRENT e FreeBSD-STABLE.

Esta seção fornece uma explicação sobre cada ramo e seu público-alvo, bem como manter um sistema atualizado com cada ramo respectivo.

[[current]]
=== Usando o FreeBSD-CURRENT

O FreeBSD-CURRENT é o desenvolvimento "bleeding edge" do FreeBSD e espera-se que os usuários do FreeBSD-CURRENT tenham um alto grau de habilidade técnica. Usuários menos técnicos que desejam acompanhar um ramo de desenvolvimento devem acompanhar o FreeBSD-STABLE.

O FreeBSD-CURRENT é o código-fonte mais recente do FreeBSD e inclui trabalhos em andamento, mudanças experimentais e mecanismos de transição que podem ou não estar presentes na próxima versão oficial. Enquanto muitos desenvolvedores do FreeBSD compilam o código-fonte do FreeBSD-CURRENT diariamente, há curtos períodos de tempo em que o código fonte pode não ser compilável. Esses problemas são resolvidos o mais rápidamente possível, mas se o FreeBSD-CURRENT traz ou não uma nova funcionalidade pode ser uma questão de quando o código-fonte foi sincronizado.

O FreeBSD-CURRENT é disponibilizado para três grupos de interesse principais:

. Membros da comunidade do FreeBSD que estão trabalhando ativamente em alguma parte da árvore de códigos fontes.
. Membros da comunidade FreeBSD que são testadores ativos. Eles estão dispostos a gastar tempo resolvendo problemas, fazendo sugestões sobre mudanças e sobre a direção geral do FreeBSD, e enviando correções.
. Usuários que desejam ficar de olho nas coisas, usam o código fonte atual para fins de referência ou fazem comentários ocasionais ou contribuições de código.

O FreeBSD-CURRENT _não_ deve ser considerado um fast-track para obter novos recursos antes do próximo release, já que os recursos de pré-release ainda não foram totalmente testados e provavelmente contêm bugs. Não é uma maneira rápida de obter correções de bugs, pois qualquer commit é tão provável de introduzir novos bugs quanto consertar os existentes. O FreeBSD-CURRENT não é de nenhuma maneira "oficialmente suportado".

Para acompanhar o FreeBSD-CURRENT:

. Junte-se as listas http://lists.FreeBSD.org/mailman/listinfo/freebsd-current[freebsd-current] e http://lists.FreeBSD.org/mailman/listinfo/svn-src-head[svn-src-head]. Isto é _essencial_ para ver os comentários que as pessoas estão fazendo sobre o estado atual do sistema e para receber importantes boletins sobre o estado atual do FreeBSD-CURRENT.
+ 
A lista http://lists.FreeBSD.org/mailman/listinfo/svn-src-head[svn-src-head] registra a entrada de log de commit para cada alteração assim que ela é feita, juntamente com qualquer informação pertinente sobre possíveis efeitos colaterais.
+ 
Para juntar-se a estas listas, vá para http://lists.FreeBSD.org/mailman/listinfo[http://lists.FreeBSD.org/mailman/listinfo], clique na lista para se inscrever e siga as instruções. A fim de rastrear mudanças em toda a árvore de código-fonte, não apenas as mudanças no FreeBSD-CURRENT, inscreva-se na lista http://lists.FreeBSD.org/mailman/listinfo/svn-src-all[svn-src-all].
. Sincronize com o código-fonte do FreeBSD-CURRENT. Normalmente, o crossref:mirrors[svn,svnlite] é usado para obter o código -CURRENT da ramificação `head` de um dos sites espelhos do Subversion listados em crossref:mirrors[svn-mirrors,Sites Espelho do Subversion].
. Devido ao tamanho do repositório, alguns usuários escolhem sincronizar apenas as seções do código-fonte que lhes interessam ou para as quais estão contribuindo com correções. No entanto, os usuários que planejam compilar o sistema operacional a partir do código-fonte devem baixar _tudo_ do FreeBSD-CURRENT, não apenas as partes selecionadas.
+ 
Antes de compilar o FreeBSD-CURRENT , leia o [.filename]#/usr/src/Makefile# com muito cuidado e siga as instruções em <<makeworld>>. Leia a http://lists.FreeBSD.org/mailman/listinfo/freebsd-current[lista de discussão do FreeBSD-CURRENT] e o [.filename]#/usr/src/UPDATING# para manter-se atualizado sobre outros procedimentos de bootstrapping que algumas vezes se tornam necessários no caminho para a próxima versão.
. Ser ativo! Usuários do FreeBSD-CURRENT são encorajados a enviar suas sugestões para melhorias ou correções de bugs. Sugestões acompanhadas de código são sempre bem vindas.

[[stable]]
=== Usando o FreeBSD-STABLE

O FreeBSD-STABLE é o ramo de desenvolvimento a partir do qual as releases principais são feitas. Mudanças entram neste ramo em um ritmo mais lento e com a suposição geral de que elas foram testadas primeiro no FreeBSD-CURRENT. Ele _ainda_ é um ramo de desenvolvimento e, a qualquer momento, as fontes para o FreeBSD-STABLE podem ou não ser adequadas para uso geral. É simplesmente outra trilha de desenvolvimento de engenharia, não um recurso para usuários finais. Usuários que não possuem recursos para realizar testes devem, ao invés disso, executar a release mais recente do FreeBSD.

Os interessados em acompanhar ou contribuir para o processo de desenvolvimento do FreeBSD, especialmente no que se refere à próxima versão do FreeBSD, devem considerar seguir o FreeBSD-STABLE.

Embora seja esperado que o ramo FreeBSD-STABLE compile e execute o tempo todo, isso não pode ser garantido. Uma vez que mais pessoas executam o FreeBSD-STABLE do que o FreeBSD-CURRENT, é inevitável que bugs e problemas mais raros às vezes sejam encontrados no FreeBSD-STABLE os quais não foram detectados no FreeBSD-CURRENT. Por esta razão, não se deve seguir cegamente o FreeBSD-STABLE. É particularmente importante _não_ atualizar quaisquer servidores de produção para o FreeBSD-STABLE sem testar completamente o código em um ambiente de desenvolvimento ou de teste.

Para acompanhar o FreeBSD-STABLE:

. Junte-se à lista http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable[freebsd-stable] para se manter informado sobre as dependências de compilação que podem aparecer no FreeBSD-STABLE ou qualquer outro problema que requeira atenção especial. Os desenvolvedores também farão anúncios nesta lista de e-mails quando estiverem contemplando alguma correção ou atualização controversa, dando aos usuários uma chance de responder se tiverem alguma questão a ser levantada sobre a alteração proposta.
+ 
Junte-se à lista svn relevante para o ramo que está sendo acompanhado. Por exemplo, os usuários que acompanham o ramo 9-STABLE devem se juntar a lista http://lists.FreeBSD.org/mailman/listinfo/svn-src-stable-9[svn-src-stable-9]. Esta lista registra a entrada do log de commit para cada alteração à medida que ela é feita, junto com qualquer informação pertinente sobre os possíveis efeitos colaterais.
+ 
Para se juntar a estas listas, vá para http://lists.FreeBSD.org/mailman/listinfo[http://lists.FreeBSD.org/mailman/listinfo], clique na lista para se inscrever e siga as instruções. Se desejar acompanhar as mudanças para toda a árvore de código-fonte, inscreva-se na http://lists.FreeBSD.org/mailman/listinfo/svn-src-all[svn-src-all] .
. Para instalar um novo sistema FreeBSD-STABLE, instale a versão mais recente do FreeBSD-STABLE a partir de um dos crossref:mirrors[mirrors,sites espelho do FreeBSD] ou use um snapshot mensal criado a partir do FreeBSD-STABLE. Consulte https://www.FreeBSD.org/snapshots/[www.freebsd.org/snapshots] para maiores informações sobre snapshots.
+ 
Para compilar ou atualizar um sistema FreeBSD existente para o FreeBSD-STABLE, use o crossref:mirrors[svn,svnlite] para obter o código-fonte da ramificação desejada. Os nomes das ramificações, como `stable/9`, estão listados em https://www.FreeBSD.org/releng/[www.freebsd.org/releng].
. Antes de compilar ou atualizar para o FreeBSD-STABLE , leia o [.filename]#/usr/src/Makefile# cuidadosamente e siga as instruções em <<makeworld>>. Leia a http://lists.FreeBSD.org/mailman/listinfo/freebsd-stable[lista de discussão FreeBSD-STABLE] e o [.filename]#/usr/src/UPDATING# para manter-se atualizado sobre outros procedimentos de bootstrapping que às vezes se tornam necessários no caminho para o próximo release.

[[makeworld]]
== Atualizando o FreeBSD a partir do código fonte

A atualização do FreeBSD através da compilação a partir do código-fonte oferece várias vantagens sobre as atualizações binárias. O código pode ser compilado com opções para aproveitar o hardware específico. Partes do sistema base podem ser compiladas com configurações não padrões, ou deixadas de fora somente onde não são necessárias ou desejadas. O processo de compilação leva mais tempo para atualizar um sistema do que apenas instalar atualizações binárias, mas permite customização completa para produzir uma versão do FreeBSD adaptada as suas necessidades.

[[updating-src-quick-start]]
=== Inicio Rápido

Esta é uma referência rápida para as etapas típicas usadas para atualizar o FreeBSD compilando-o a partir do código fonte. As seções posteriores descrevem o processo com mais detalhes.

[.procedure]
====

. Atualizar e Compilar
+
[source,shell]
....
# svnlite update /usr/src  <.>
check /usr/src/UPDATING  <.>
# cd /usr/src          <.>
# make -j4 buildworld  <.>
# make -j4 kernel      <.>
# shutdown -r now      <.>
# cd /usr/src          <.>
# make installworld    <.>
# mergemaster -Ui      <.>
# shutdown -r now      <.>
....
<.> Obtenha a versão mais recente do código fonte. Veja <<updating-src-obtaining-src>> para maiores informações sobre como obter e atualizar o código fonte.
<.> Verifique o [.filename]#/usr/src/UPDATING# para quaisquer etapas manuais necessárias antes ou depois de compilar a partir do código fonte.
<.> Vá para o diretório de origem.
<.> Compile o mundo, tudo exceto o kernel.
<.> Compile e instale o kernel. Isso é equivalente a `make installkernel installkernel`.
<.> Reinicialize o sistema com o novo kernel.
<.> Vá para o diretório de origem.
<.> Instale o mundo.
<.> Atualize e mescle os arquivos de configuração em [.filename]#/etc/#.
<.> Reinicie o sistema para usar o mundo e o kernel recém-compilados.
====

[[updating-src-preparing]]
=== Preparando-se para uma atualização a partir do código fonte

Leia o [.filename]#/usr/src/UPDATING#. Quaisquer etapas manuais que devem ser executadas antes ou depois de uma atualização são descritas neste arquivo.

[[updating-src-obtaining-src]]
=== Atualizando o código fonte

O código fonte do FreeBSD está localizado em [.filename]#/usr/src/#. O método preferido para atualizar os fontes é através do sistema de controle de versão do Subversion. Verifique se o código-fonte está sob controle de versão:

[source,shell]
....
# svnlite info /usr/src
Path: /usr/src
Working Copy Root Path: /usr/src
...
....

Isto indica que o [.filename]#/usr/src/# está sob controle de versão e pode ser atualizado com o man:svnlite[1]:

[source,shell]
....
# svnlite update /usr/src
....

O processo de atualização pode levar algum tempo se o diretório não tiver sido atualizado recentemente. Após a conclusão, o código-fonte estará atualizado e o processo de compilação descrito na próxima seção poderá começar.

[NOTE]
.Obtendo o código fonte
====
Se a saída disser que `'/usr/src' is not a working copy`, estão faltando arquivos no diretório ou eles foram instalados com um método diferente. Um novo checkout da fonte é necessário.

[[updating-src-obtaining-src-repopath]]
.Versões do FreeBSD e Caminhos do Repositório
[cols="1,1,1", options="header"]
|===
| Saída do uname -r
| Caminho do Repositório
| Descrição

|`_X.Y_-RELEASE`
|``base/releng/``_X.Y_
|A versão do release mais apenas correções críticas de segurança e correção de erros. Este ramo é recomendado para a maioria dos usuários.

|`_X.Y_-STABLE`
|``base/stable/``_X_
|

A versão de Release mais todos os desenvolvimentos adicionais nesse ramo. O _STABLE_ refere-se à interface binária de aplicativos (ABI) não sendo alterada, portanto, o software compilado para versões anteriores ainda é executado. Por exemplo, o software compilado para rodar no FreeBSD 10.1 ainda rodará no FreeBSD 10-STABLE compilado posteriormente.

Os ramos STABLE ocasionalmente possuem bugs ou incompatibilidades que podem afetar os usuários, embora sejam normalmente corrigidos rapidamente.

|`_X_-CURRENT`
|`base/head/`
|A mais recente versão de desenvolvimento do FreeBSD. A ramificação CURRENT pode ter grandes erros ou incompatibilidades e é recomendada apenas para usuários avançados.
|===

Determine qual versão do FreeBSD está sendo usada com man:uname[1]:

[source,shell]
....
# uname -r
10.3-RELEASE
....

Baseado em <<updating-src-obtaining-src-repopath>>, a fonte usada para atualizar `10.3-RELEASE` tem como caminho de repositório `base/releng/10.3`. Este caminho é usado ao verificar a fonte:

[source,shell]
....
# mv /usr/src /usr/src.bak <.>
# svnlite checkout https://svn.freebsd.org/base/releng/10.3 /usr/src <.>
....

<.> Mova o diretório antigo para fora do caminho. Se não houver modificações locais nesse diretório, ele poderá ser excluído.
<.> O caminho da <<updating-src-obtaining-src-repopath>> é adicionado a URL repositório . O terceiro parâmetro é o diretório de destino do código-fonte no sistema local.
====

[[updating-src-building]]
=== Compilando a partir do código-fonte

O _world_, ou todo o sistema operacional, exceto o kernel, é compilado. Isso é feito primeiro para fornecer ferramentas atualizadas para construir o kernel. Então o próprio kernel é construído:

[source,shell]
....
# cd /usr/src
# make buildworld
# make buildkernel
....

O código compilado é escrito em [.filename]#/usr/obj#.

Estes são os passos básicos. Opções adicionais para controlar a compilação são descritas abaixo.

[[updating-src-building-clean-build]]
==== Executando uma compilação limpa

Algumas versões do sistema de compilação do FreeBSD deixam o código previamente compilado no diretório de objetos temporários, [.filename]#/usr/obj#. Isso pode acelerar as compilações posteriores, evitando recompilar o código que não foi alterado. Para forçar uma reconstrução limpa de tudo, use `cleanworld` antes de iniciar uma construção:

[source,shell]
....
# make cleanworld
....

[[updating-src-building-jobs]]
==== Definindo o Número de Jobs

Aumentar o número de jobs de compilação em processadores com vários núcleos pode melhorar a velocidade de construção. Determine o número de núcleos com `sysctl hw.ncpu`. Os processadores variam, assim como os sistemas de compilação usados com diferentes versões do FreeBSD, portanto, o teste é o único método seguro para determinar como um número diferente de tarefas afeta a velocidade de compilação. Como ponto de partida, considere valores entre metade e o dobro do número de núcleos. O número de jobs é especificado com a opção `-j`.

[[updating-src-building-jobs-example]]
.Aumentando o número de jobs de compilação
[example]
====
Compilando o mundo e o kernel com quatro jobs:

[source,shell]
....
# make -j4 buildworld buildkernel
....

====

[[updating-src-building-only-kernel]]
==== Compilando Apenas o Kernel

Um `buildworld` deve ser completado se o código-fonte for alterado. Depois disso, um `buildkernel` para compilar um kernel pode ser executado a qualquer momento. Para compilar apenas o kernel:

[source,shell]
....
# cd /usr/src
# make buildkernel
....

[[updating-src-building-custom-kernel]]
==== Compilando um Kernel Customizado

O kernel padrão do FreeBSD é baseado em um _arquivo de configuração do kernel_ chamado [.filename]#GENERIC#. O kernel [.filename]#GENERIC# inclui os drivers e opções de dispositivos mais comumente necessários. Às vezes, é útil ou necessário criar um kernel personalizado, adicionando ou removendo drivers de dispositivo ou opções para atender a uma necessidade específica.

Por exemplo, alguém que desenvolve um pequeno computador embarcado com RAM severamente limitada pode remover drivers de dispositivo desnecessários ou opções para tornar o kernel um pouco menor.

Os arquivos de configuração do Kernel estão localizados em [.filename]#/usr/src/sys/arch/conf/#, onde _arch_ é a saída do `uname - m`. Na maioria dos computadores, a saida será `amd64`, resultando no diretório de arquivos de configuração [.filename]#/usr/src/sys/amd64/conf/#.

[TIP]
====

O [.filename]#/usr/src# pode ser deletado ou recriado, então é preferível manter os arquivos de configuração do kernel em um diretório separado, como por exemplo em [.filename]#/root#. Vincule o arquivo de configuração do kernel ao diretório [.filename]#conf#. Se esse diretório for excluído ou sobrescrito, a configuração do kernel pode ser vinculada novamente ao novo.
====

Um arquivo de configuração personalizado pode ser criado copiando o arquivo de configuração [.filename]#GENERIC#. Neste exemplo, o novo kernel personalizado é para um servidor de armazenamento, portanto, é denominado [.filename]#STORAGESERVER#:

[source,shell]
....
# cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER
# cd /usr/src/sys/amd64/conf
# ln -s /root/STORAGESERVER .
....

O [.filename]#/root/STORAGESERVER# é então editado, adicionando ou removendo dispositivos ou opções como mostrado em man:config[5].

O kernel personalizado é compilado pela configuração `KERNCONF` no arquivo de configuração do kernel na linha de comando:

[source,shell]
....
# make buildkernel KERNCONF=STORAGESERVER
....

[[updating-src-installing]]
=== Instalando o código compilado

Depois que as etapas `buildworld` e `buildkernel` forem concluídas, o novo kernel e o restante do sistema base serão instalados:

[source,shell]
....
# cd /usr/src
# make installkernel
# shutdown -r now
# cd /usr/src
# make installworld
# shutdown -r now
....

Se um kernel customizado foi compilado, `KERNCONF` também deve ser configurado para usar o novo kernel customizado:

[source,shell]
....
# cd /usr/src
# make installkernel KERNCONF=STORAGESERVER
# shutdown -r now
# cd /usr/src
# make installworld
# shutdown -r now
....

[[updating-src-completing]]
=== Concluindo a atualização

Algumas tarefas finais completam a atualização. Quaisquer arquivos de configuração que tenham sido modificados serão mesclado com as novas versões, as bibliotecas desatualizadas são localizadas e removidas e, em seguida, o sistema é reiniciado.

[[updating-src-completing-merge-mergemaster]]
==== Mesclando arquivos de configuração com o man:mergemaster[8]

O man:mergemaster[8] fornece uma maneira fácil de mesclar as alterações feitas nos arquivos de configuração do sistema com novas versões desses arquivos.

Com a opção `-Ui`, o man:mergemaster[8] atualizará automaticamente os arquivos que não foram modificados pelo usuário e instalará os novos arquivos que ainda não estiverem presentes:

[source,shell]
....
# mergemaster -Ui
....

Se um arquivo precisar ser mesclado manualmente, uma exibição interativa permitirá que o usuário escolha quais partes dos arquivos serão mantidas. Veja man:mergemaster[8] para maiores informações.

[[updating-src-completing-check-old]]
==== Verificando Arquivos e Bibliotecas Desatualizados

Alguns arquivos ou diretórios obsoletos podem permanecer após uma atualização. Esses arquivos podem ser localizados:

[source,shell]
....
# make check-old
....

e excluído:

[source,shell]
....
# make delete-old
....

Algumas bibliotecas obsoletas também podem permanecer. Estes podem ser detectados com:

[source,shell]
....
# make check-old-libs
....

e deletado com

[source,shell]
....
# make delete-old-libs
....

Os programas que ainda estavam usando estas bibliotecas antigas deixarão de funcionar quando a biblioteca for excluída. Estes programas devem ser recompilados ou substituídos após a exclusão das bibliotecas antigas.

[TIP]
====

Quando todos os arquivos ou diretórios antigos forem considerados seguros para serem excluídos, a ação de pressionar kbd:[y] e kbd:[Enter] para excluir cada arquivo poderá ser evitada configurando a variável `BATCH_DELETE_OLD_FILES` no comando. Por exemplo:

[source,shell]
....
# make BATCH_DELETE_OLD_FILES=yes delete-old-libs
....

====

[[updating-src-completing-restart]]
==== Reiniciando após a atualização

A última etapa após a atualização é reiniciar o computador para que todas as alterações entrem em vigor:

[source,shell]
....
# shutdown -r now
....

[[small-lan]]
== Atualização de várias máquinas

Quando várias máquinas precisam rastrear a mesma árvore de código-fonte, é um desperdício de espaço em disco, largura de banda de rede e ciclos de CPU se cada sistema tiver que baixar o código-fonte e recompilar tudo. A solução é ter uma máquina fazendo a maior parte do trabalho, enquanto o resto das máquinas montam esse trabalho via NFS. Esta seção descreve um método para fazer isso. Para maiores informações sobre o uso de NFS, consulte crossref:network-servers[network-nfs,Network File System (NFS)].

Primeiro, identifique um conjunto de máquinas que executará o mesmo conjunto de binários, conhecido como _conjunto de compilação_. Cada máquina pode ter um kernel customizado, mas executará os mesmos binários do userland. A partir desse conjunto, escolha uma máquina para ser a _máquina de compilação_ em que o sistema base e o kernel serão compilados. Idealmente, esta deverá ser uma máquina rápida que tenha CPU suficiente disponível para executar o `make buildworld` e o `make buildkernel`.

Selecione uma máquina para ser a _máquina de teste_, que testará as atualizações de software antes de serem colocadas em produção. Esta _deve_ ser uma máquina que você possa se dar ao luxo de ficar inativa por um longo período de tempo. Pode ser a máquina de compilação, mas não precisa ser.

Todas as máquinas neste conjunto de compilação precisam montar o [.filename]#/usr/obj# e o [.filename]#/usr/src# da máquina de compilação através do NFS. Para vários conjuntos de compilação, o [.filename]#/usr/src# deve ser um sistema de arquivos local na máquina de compilação e um sistema montado por NFS nas demais.

Certifique-se de que o [.filename]#/etc/make.conf# e o [.filename]#/etc/src.conf# em todas as máquinas no conjunto de compilação concordem com a máquina de compilação. Isso significa que a máquina de compilação deve compilar todas as partes do sistema base que qualquer máquina no conjunto de compilação irá instalar. Além disso, cada máquina de compilação deve ter seu nome de kernel definido com `KERNCONF` em [.filename]#/etc/make.conf#, e a máquina de compilação deve listá-los todos em seu `KERNCONF`, listando seu próprio kernel primeiro. A máquina de compilação deve ter os arquivos de configuração do kernel para cada máquina em seu [.filename]#/usr/src/sys/arch/conf#.

Na máquina de compilação, compile o kernel e o mundo conforme descrito em <<makeworld>>, mas não instale nada na máquina de compilação. Em vez disso, instale o kernel compilado na máquina de teste. Na máquina de teste, monte [.filename]#/usr/src# e o [.filename]#/usr/obj# via NFS. Em seguida, execute `shutdown now` para ir para o modo de usuário único para instalar o novo kernel e o restante do sistema base e execute o `mergemaster` como de costume. Quando terminar, reinicialize para retornar às operações multiusuário normais.

Depois de verificar se tudo na máquina de teste está funcionando corretamente, use o mesmo procedimento para instalar o novo software em cada uma das outras máquinas no conjunto de compilação.

A mesma metodologia pode ser usada para a árvore de ports. O primeiro passo é compartilhar o [.filename]#/usr/ports# via NFS para todas as máquinas no conjunto de compilação. Para configurar o [.filename]#/etc/make.conf# para compartilhar os distfiles, configure o `DISTDIR` para um diretório compartilhado que possa ser escrito por qualquer usuário `root` mapeado pela montagem NFS. Cada máquina deve definir o `WRKDIRPREFIX` para um diretório de compilação local, se os ports precisarem ser compilados localmente. Como alternativa, se o sistema de compilação tiver que compilar e distribuir pacotes para as máquinas no conjunto de compilação, configure o `PACKAGES` no sistema de compilação para um diretório semelhante ao `DISTDIR`.
