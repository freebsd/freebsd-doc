# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Kyung-tak, Yoo <stonegaze@me.com>, 2023.
# "Kyung-tak, Yoo" <stonegaze@me.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2023-04-20 20:56-0300\n"
"PO-Revision-Date: 2023-04-27 22:35+0000\n"
"Last-Translator: \"Kyung-tak, Yoo\" <stonegaze@me.com>\n"
"Language-Team: Korean <https://translate-dev.freebsd.org/projects/"
"documentation/bookshandbookadvanced-networking_index/ko/>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, no-wrap
msgid "Advanced networking in FreeBSD:  basics of gateways and routes, CARP, how to configure multiple VLANs on FreeBSD, etc"
msgstr "FreeBSD의 고급 네트워킹: 게이트웨이와 라우팅의 기본, CARP, FreeBSD에서 다중 "
"VLAN을 구성하는 방법 등"

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, no-wrap
msgid "IV. Network Communication"
msgstr "IV. 네트워크 통신"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, no-wrap
msgid "Chapter 33. Advanced Networking"
msgstr "33장. 고급 네트워킹"

#. type: Title =
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:14
#, no-wrap
msgid "Advanced Networking"
msgstr "고급 네트워킹"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "요약"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:55
msgid "This chapter covers a number of advanced networking topics."
msgstr "이 장에서는 여러 가지 고급 네트워킹 주제를 다룹니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:57
msgid "After reading this chapter, you will know:"
msgstr "이 챕터를 읽고 나면, 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:59
msgid "The basics of gateways and routes."
msgstr "게이트웨이와 라우팅의 기본."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:60
msgid "How to set up USB tethering."
msgstr "USB 테더링 설정 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:61
msgid "How to set up IEEE(R) 802.11 and Bluetooth(R) devices."
msgstr "IEEE(R) 802.11 및 Bluetooth(R) 장치를 설정하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:62
msgid "How to make FreeBSD act as a bridge."
msgstr "FreeBSD를 브릿지로 작동시키는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:63
msgid "How to set up network PXE booting."
msgstr "네트워크 PXE 부팅을 설정하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:64
msgid "How to set up IPv6 on a FreeBSD machine."
msgstr "FreeBSD 머신에서 IPv6를 설정하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:65
msgid ""
"How to enable and utilize the features of the Common Address Redundancy "
"Protocol (CARP) in FreeBSD."
msgstr ""
"FreeBSD에서 공통 주소 중복 프로토콜(Common Address Redundancy Protocol, CARP)"
"의 기능을 활성화하고 활용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:66
msgid "How to configure multiple VLANs on FreeBSD."
msgstr "FreeBSD에서 다중 VLAN을 구성하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:67
msgid "Configure bluetooth headset."
msgstr "블루투스 헤드셋 구성."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:69
msgid "Before reading this chapter, you should:"
msgstr "이 챕터를 읽기 전에 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:71
msgid "Understand the basics of the [.filename]#/etc/rc# scripts."
msgstr "[.filename]#/etc/rc# 스크립트의 기초를 알고 있어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:72
msgid "Be familiar with basic network terminology."
msgstr "네트워크 용어에 익숙해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:73
msgid ""
"Know how to configure and install a new FreeBSD kernel (crossref:"
"kernelconfig[kernelconfig,Configuring the FreeBSD Kernel])."
msgstr ""
"새 FreeBSD 커널을 구성하고 설치하는 방법을 알고 있어야 "
"합니다(crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel])."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:74
msgid ""
"Know how to install additional third-party software (crossref:ports[ports,"
"Installing Applications: Packages and Ports])."
msgstr ""
"타사 소프트웨어를 추가로 설치하는 방법을 알고 있어야 합니다(crossref:ports["
"ports,Installing Applications: Packages and Ports])."

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:76
#, no-wrap
msgid "Gateways and Routes"
msgstr "게이트웨이와 라우트"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:85
msgid ""
"_Routing_ is the mechanism that allows a system to find the network path to "
"another system.  A _route_ is a defined pair of addresses which represent "
"the \"destination\" and a \"gateway\".  The route indicates that when trying "
"to get to the specified destination, send the packets through the specified "
"gateway.  There are three types of destinations: individual hosts, subnets, "
"and \"default\".  The \"default route\" is used if no other routes apply.  "
"There are also three types of gateways: individual hosts, interfaces, also "
"called links, and Ethernet hardware (MAC) addresses.  Known routes are "
"stored in a routing table."
msgstr ""
"_라우팅_은 시스템이 다른 시스템에 대한 네트워크 경로를 찾을 수 있도록 하는 "
"메커니즘입니다.  _라우팅_은 \"목적지\"와 \"게이트웨이\"를 나타내는 정의된 "
"주소 쌍입니다.  라우팅은 지정된 목적지에 도달하려고 할 때 지정된 "
"게이트웨이를 통해 패킷을 보내도록 지시합니다.  목적지에는 개별 호스트, "
"서브넷 및 \"기본값(default)\"의 세 가지 유형이 있습니다.  다른 경로가 "
"적용되지 않는 경우 \"기본 경로\"가 사용됩니다.  게이트웨이에는 개별 호스트, "
"인터페이스라고도 하는 링크, 이더넷 하드웨어(MAC) 주소의 세 가지 유형도 "
"있습니다.  알려진 경로는 라우팅 테이블에 저장됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:88
msgid ""
"This section provides an overview of routing basics.  It then demonstrates "
"how to configure a FreeBSD system as a router and offers some "
"troubleshooting tips."
msgstr ""
"이 섹션에서는 라우팅 기본 사항에 대한 개요를 제공합니다.  그런 다음 FreeBSD "
"시스템을 라우터로 구성하는 방법을 시연하고 몇 가지 문제 해결 팁을 제공합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:90
#, no-wrap
msgid "Routing Basics"
msgstr "라우팅 기초"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:93
msgid "To view the routing table of a FreeBSD system, use man:netstat[1]:"
msgstr "FreeBSD 시스템의 라우팅 테이블을 보려면 man:netstat[1]을 사용하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:98
#, no-wrap
msgid ""
"% netstat -r\n"
"Routing tables\n"
msgstr ""
"% netstat -r\n"
"Routing tables\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:110
#, no-wrap
msgid ""
"Internet:\n"
"Destination      Gateway            Flags     Refs     Use     Netif Expire\n"
"default          outside-gw         UGS        37      418       em0\n"
"localhost        localhost          UH          0      181       lo0\n"
"test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77\n"
"10.20.30.255     link#1             UHLW        1     2421\n"
"example.com      link#1             UC          0        0\n"
"host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0\n"
"host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>\n"
"host2.example.com link#1            UC          0        0\n"
"224              link#1             UC          0        0\n"
msgstr ""
"Internet:\n"
"Destination      Gateway            Flags     Refs     Use     Netif Expire\n"
"default          outside-gw         UGS        37      418       em0\n"
"localhost        localhost          UH          0      181       lo0\n"
"test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77\n"
"10.20.30.255     link#1             UHLW        1     2421\n"
"example.com      link#1             UC          0        0\n"
"host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0\n"
"host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>\n"
"host2.example.com link#1            UC          0        0\n"
"224              link#1             UC          0        0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:113
msgid "The entries in this example are as follows:"
msgstr "이 예의 항목은 다음과 같습니다:"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:114
#, no-wrap
msgid "default"
msgstr "default"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:118
msgid ""
"The first route in this table specifies the `default` route.  When the local "
"system needs to make a connection to a remote host, it checks the routing "
"table to determine if a known path exists.  If the remote host matches an "
"entry in the table, the system checks to see if it can connect using the "
"interface specified in that entry."
msgstr ""
"이 표의 첫 번째 경로는 `default` 경로를 지정합니다.  로컬 시스템이 원격 "
"호스트에 연결해야 할 때 라우팅 테이블을 확인하여 알려진 경로가 존재하는지 "
"확인합니다.  원격 호스트가 테이블의 항목과 일치하면 시스템은 해당 항목에 "
"지정된 인터페이스를 사용하여 연결할 수 있는지 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:122
msgid ""
"If the destination does not match an entry, or if all known paths fail, the "
"system uses the entry for the default route.  For hosts on a local area "
"network, the `Gateway` field in the default route is set to the system which "
"has a direct connection to the Internet.  When reading this entry, verify "
"that the `Flags` column indicates that the gateway is usable (`UG`)."
msgstr ""
"목적지가 항목과 일치하지 않거나 알려진 모든 경로가 실패하면 시스템은 기본 "
"경로의 항목을 사용합니다.  로컬 영역 네트워크에 있는 호스트의 경우 기본 "
"경로의 `Gateway` 필드는 인터넷에 직접 연결되어 있는 시스템으로 설정됩니다.  "
"이 항목을 읽을 때 `Flags` 열에 게이트웨이가 사용 가능(`UG`)함을 나타내는지 "
"확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:124
msgid ""
"The default route for a machine which itself is functioning as the gateway "
"to the outside world will be the gateway machine at the Internet Service "
"Provider (ISP)."
msgstr "외부 세계로 향하는 게이트웨이 역할을 하는 머신의 기본 경로는 인터넷 서비스 "
"제공업체(ISP)의 게이트웨이 머신이 됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:125
#, no-wrap
msgid "localhost"
msgstr "localhost"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:129
msgid ""
"The second route is the `localhost` route.  The interface specified in the "
"`Netif` column for `localhost` is [.filename]#lo0#, also known as the "
"loopback device.  This indicates that all traffic for this destination "
"should be internal, rather than sending it out over the network."
msgstr ""
"두 번째 경로는 `localhost` 경로입니다.  `localhost`의 `Netif` 열에 지정된 "
"인터페이스는 루프백 장치라고도 하는 [.filename]#lo0#입니다.  이는 이 대상에 "
"대한 모든 트래픽이 네트워크를 통해 전송되지 않고 내부에 있어야 함을 "
"나타냅니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:130
#, no-wrap
msgid "MAC address"
msgstr "MAC address"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:136
msgid ""
"The addresses beginning with `0:e0:` are MAC addresses.  FreeBSD will "
"automatically identify any hosts, `test0` in the example, on the local "
"Ethernet and add a route for that host over the Ethernet interface, [."
"filename]#re0#.  This type of route has a timeout, seen in the `Expire` "
"column, which is used if the host does not respond in a specific amount of "
"time.  When this happens, the route to this host will be automatically "
"deleted.  These hosts are identified using the Routing Information Protocol "
"(RIP), which calculates routes to local hosts based upon a shortest path "
"determination."
msgstr ""
"`0:e0:`로 시작하는 주소는 MAC 어드레스입니다.  FreeBSD는 로컬 이더넷에 있는 "
"호스트(예제에서는 `test0`)를 자동으로 식별하고 이더넷 인터페이스를 통해 해당 "
"호스트에 대한 경로인 [.filename]#re0#을 추가합니다.  이 유형의 경로에는 "
"`Expire` 열에 표시된 시간 제한이 있으며, 호스트가 특정 시간 내에 응답하지 "
"않는 경우에 사용됩니다.  이 경우 이 호스트에 대한 경로가 자동으로 "
"삭제됩니다.  이러한 호스트는 최단 경로 결정을 기반으로 로컬 호스트에 대한 "
"경로를 계산하는 RIP(라우팅 정보 프로토콜)를 사용하여 식별됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:137
#, no-wrap
msgid "subnet"
msgstr "subnet"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:141
msgid ""
"FreeBSD will automatically add subnet routes for the local subnet.  In this "
"example, `10.20.30.255` is the broadcast address for the subnet `10.20.30` "
"and `example.com` is the domain name associated with that subnet.  The "
"designation `link#1` refers to the first Ethernet card in the machine."
msgstr ""
"FreeBSD는 로컬 서브넷에 대한 서브넷 경로를 자동으로 추가합니다.  이 예에서 "
"`10.20.30.255`는 서브넷 `10.20.30`의 브로드캐스트 주소이고 `example.com`은 "
"해당 서브넷과 연결된 도메인 이름입니다.  `link#1`은 머신의 첫 번째 이더넷 "
"카드를 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:144
msgid ""
"Local network hosts and local subnets have their routes automatically "
"configured by a daemon called man:routed[8].  If it is not running, only "
"routes which are statically defined by the administrator will exist."
msgstr ""
"로컬 네트워크 호스트와 로컬 서브넷은 man:routed[8]라는 데몬에 의해 경로가 "
"자동으로 구성됩니다.  이 데몬이 실행되지 않으면 관리자가 정적으로 정의한 "
"경로만 존재합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:145
#, no-wrap
msgid "host"
msgstr "host"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:148
msgid ""
"The `host1` line refers to the host by its Ethernet address.  Since it is "
"the sending host, FreeBSD knows to use the loopback interface ([."
"filename]#lo0#) rather than the Ethernet interface."
msgstr ""
"`host1` 줄은 이더넷 주소로 호스트를 나타냅니다.  이 호스트는 보내는 "
"호스트이므로, FreeBSD는 이더넷 인터페이스가 아닌 루프백 인터페이스([."
"filename]#lo0#)를 사용한다는 것을 알고 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:152
msgid ""
"The two `host2` lines represent aliases which were created using man:"
"ifconfig[8].  The `=>` symbol after the [.filename]#lo0# interface says that "
"an alias has been set in addition to the loopback address.  Such routes only "
"show up on the host that supports the alias and all other hosts on the local "
"network will have a `link#1` line for such routes."
msgstr ""
"두 개의 `host2` 줄은 man:ifconfig[8]을 사용하여 생성된 별칭(alias)을 "
"나타냅니다.  [.filename]#lo0# 인터페이스 뒤의 `=>` 기호는 루프백 주소 외에 "
"별칭이 설정되었음을 나타냅니다.  이러한 경로는 별칭을 지원하는 호스트에만 "
"표시되며 로컬 네트워크의 다른 모든 호스트에는 해당 경로에 대한 `link#1` 줄이 "
"있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:153
#, no-wrap
msgid "224"
msgstr "224"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:155
msgid "The final line (destination subnet `224`) deals with multicasting."
msgstr "마지막 줄(destination subnet `224`)은 멀티캐스팅을 처리합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:158
msgid ""
"Various attributes of each route can be seen in the `Flags` column.  "
"<<routeflags>> summarizes some of these flags and their meanings:"
msgstr ""
"각 경로의 다양한 속성은 `Flags` 열에서 확인할 수 있습니다.  "
"<<routeflags>>에는 이러한 플래그 중 일부와 그 의미가 요약되어 있습니다:"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:160
#, no-wrap
msgid "Commonly Seen Routing Table Flags"
msgstr "흔히 볼 수 있는 라우팅 테이블 플래그"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:164
#, no-wrap
msgid "Flag"
msgstr "플래그"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:166
#, no-wrap
msgid "Purpose"
msgstr "목적"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:167
#, no-wrap
msgid "U"
msgstr "U"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:169
#, no-wrap
msgid "The route is active (up)."
msgstr "경로가 활성화되었습니다(up)."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:170
#, no-wrap
msgid "H"
msgstr "H"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:172
#, no-wrap
msgid "The route destination is a single host."
msgstr "라우팅 대상은 단일 호스트입니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:173
#, no-wrap
msgid "G"
msgstr "G"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:175
#, no-wrap
msgid "Send anything for this destination on to this gateway, which will figure out from there where to send it."
msgstr "이 대상에 대한 모든 것을 이 게이트웨이로 보내면 게이트웨이가 어디로 보낼지 "
"알아서 결정합니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:176
#, no-wrap
msgid "S"
msgstr "S"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:178
#, no-wrap
msgid "This route was statically configured."
msgstr "이 경로는 정적으로 구성되어 있습니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:179
#, no-wrap
msgid "C"
msgstr "C"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:181
#, no-wrap
msgid "Clones a new route based upon this route for machines to connect to. This type of route is normally used for local networks."
msgstr ""
"이 경로를 기반으로 새 경로를 복제하여 머신이 연결할 수 있도록 합니다. 이 "
"유형의 경로는 일반적으로 로컬 네트워크에 사용됩니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:182
#, no-wrap
msgid "W"
msgstr "W"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:184
#, no-wrap
msgid "The route was auto-configured based upon a local area network (clone) route."
msgstr "경로는 로컬 영역 네트워크(클론) 경로를 기반으로 자동 구성되었습니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:185
#, no-wrap
msgid "L"
msgstr "L"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:186
#, no-wrap
msgid "Route involves references to Ethernet (link) hardware."
msgstr "라우트에는 이더넷(링크) 하드웨어에 대한 참조가 포함됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:189
msgid ""
"On a FreeBSD system, the default route can defined in [.filename]#/etc/rc."
"conf# by specifying the IP address of the default gateway:"
msgstr ""
"FreeBSD 시스템에서는 기본 게이트웨이의 IP 주소를 지정하여 [.filename]#/etc/rc"
".conf#에서 기본 경로를 정의할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:193
#, no-wrap
msgid "defaultrouter=\"10.20.30.1\"\n"
msgstr "defaultrouter=\"10.20.30.1\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:196
msgid "It is also possible to manually add the route using `route`:"
msgstr "`route`를 사용하여 수동으로 경로를 추가할 수도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:200
#, no-wrap
msgid "# route add default 10.20.30.1\n"
msgstr "# route add default 10.20.30.1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:204
msgid ""
"Note that manually added routes will not survive a reboot.  For more "
"information on manual manipulation of network routing tables, refer to man:"
"route[8]."
msgstr ""
"수동으로 추가한 경로는 재부팅 후에 살아남지 못한다는 점에 유의하세요.  "
"네트워크 라우팅 테이블의 수동 조작에 대한 자세한 내용은 man:route[8]을 "
"참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:206
#, no-wrap
msgid "Configuring a Router with Static Routes"
msgstr "정적 경로로 라우터 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:211
msgid ""
"A FreeBSD system can be configured as the default gateway, or router, for a "
"network if it is a dual-homed system.  A dual-homed system is a host which "
"resides on at least two different networks.  Typically, each network is "
"connected to a separate network interface, though IP aliasing can be used to "
"bind multiple addresses, each on a different subnet, to one physical "
"interface."
msgstr ""
"듀얼 홈 시스템인 경우 FreeBSD 시스템을 네트워크의 기본 게이트웨이 또는 "
"라우터로 구성할 수 있습니다.  듀얼 홈 시스템은 적어도 두 개의 다른 "
"네트워크에 상주하는 호스트입니다.  일반적으로 각 네트워크는 별도의 네트워크 "
"인터페이스에 연결되지만, IP 앨리어싱을 사용하여 각각 다른 서브넷에 있는 여러 "
"주소를 하나의 물리적 인터페이스에 바인딩할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:214
msgid ""
"In order for the system to forward packets between interfaces, FreeBSD must "
"be configured as a router.  Internet standards and good engineering practice "
"prevent the FreeBSD Project from enabling this feature by default, but it "
"can be configured to start at boot by adding this line to [.filename]#/etc/"
"rc.conf#:"
msgstr ""
"시스템이 인터페이스 간 패킷을 전달하기 위해서는 FreeBSD를 라우터로 구성해야 "
"합니다.  인터넷 표준과 좋은 엔지니어링 관행으로 인해 FreeBSD 프로젝트는 이 "
"기능을 기본적으로 활성화하지 않지만, [.filename]#/etc/rc.conf#에 다음 줄을 "
"추가하여 부팅 시 시작되도록 구성할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:218
#, no-wrap
msgid "gateway_enable=\"YES\"          # Set to YES if this host will be a gateway\n"
msgstr ""
"gateway_enable=\"YES\"          # Set to YES if this host will be a gateway\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:222
msgid ""
"To enable routing now, set the man:sysctl[8] variable `net.inet.ip."
"forwarding` to `1`.  To stop routing, reset this variable to `0`."
msgstr ""
"지금 라우팅을 활성화하려면 man:sysctl[8] 변수 `net.inet.ip.forwarding`을 `1`"
"로 설정합니다.  라우팅을 중지하려면 이 변수를 `0`으로 재설정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:226
msgid ""
"The routing table of a router needs additional routes so it knows how to "
"reach other networks.  Routes can be either added manually using static "
"routes or routes can be automatically learned using a routing protocol.  "
"Static routes are appropriate for small networks and this section describes "
"how to add a static routing entry for a small network."
msgstr ""
"라우터의 라우팅 테이블에는 다른 네트워크에 연결하는 방법을 알 수 있도록 추가 "
"경로가 필요합니다.  경로는 정적 경로를 사용하여 수동으로 추가하거나 라우팅 "
"프로토콜을 사용하여 경로를 자동으로 학습할 수 있습니다.  정적 경로는 소규모 "
"네트워크에 적합하며, 이 섹션에서는 소규모 네트워크에 정적 라우팅 항목을 "
"추가하는 방법을 설명합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:232
msgid ""
"For large networks, static routes quickly become unscalable.  FreeBSD comes "
"with the standard BSD routing daemon man:routed[8], which provides the "
"routing protocols RIP, versions 1 and 2, and IRDP.  Support for the BGP and "
"OSPF routing protocols can be installed using the package:net/quagga[] "
"package or port."
msgstr ""
"대규모 네트워크의 경우, 정적 경로는 빠르게 확장할 수 없게 됩니다.  FreeBSD는 "
"라우팅 프로토콜인 RIP, 버전 1과 2, 그리고 IRDP를 제공하는 표준 BSD 라우팅 "
"데몬 man:routed[8]와 함께 제공됩니다.  BGP 및 OSPF 라우팅 프로토콜에 대한 "
"지원은 package:net/quagga[] 패키지 또는 포트를 사용하여 설치할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:235
msgid "Consider the following network:"
msgstr "다음 네트워크를 생각해 보세요:"

#. type: Target for macro image
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:236
#, no-wrap
msgid "static-routes.png"
msgstr "static-routes.png"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:241
msgid ""
"In this scenario, `RouterA` is a FreeBSD machine that is acting as a router "
"to the rest of the Internet.  It has a default route set to `10.0.0.1` which "
"allows it to connect with the outside world.  `RouterB` is already "
"configured to use `192.168.1.1` as its default gateway."
msgstr ""
"이 시나리오에서 `RouterA`는 나머지 인터넷에 대한 라우터 역할을 하는 FreeBSD "
"머신입니다.  기본 경로는 외부와 연결할 수 있도록 `10.0.0.1`로 설정되어 "
"있습니다.  `RouterB`는 이미 `192.168.1.1`을 기본 게이트웨이로 사용하도록 "
"구성되어 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:243
msgid ""
"Before adding any static routes, the routing table on `RouterA` looks like "
"this:"
msgstr "정적 경로를 추가하기 전 `RouterA`의 라우팅 테이블은 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:248
#, no-wrap
msgid ""
"% netstat -nr\n"
"Routing tables\n"
msgstr ""
"% netstat -nr\n"
"Routing tables\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:255
#, no-wrap
msgid ""
"Internet:\n"
"Destination        Gateway            Flags    Refs      Use  Netif  Expire\n"
"default            10.0.0.1           UGS         0    49378    xl0\n"
"127.0.0.1          127.0.0.1          UH          0        6    lo0\n"
"10.0.0.0/24        link#1             UC          0        0    xl0\n"
"192.168.1.0/24     link#2             UC          0        0    xl1\n"
msgstr ""
"Internet:\n"
"Destination        Gateway            Flags    Refs      Use  Netif  Expire\n"
"default            10.0.0.1           UGS         0    49378    xl0\n"
"127.0.0.1          127.0.0.1          UH          0        6    lo0\n"
"10.0.0.0/24        link#1             UC          0        0    xl0\n"
"192.168.1.0/24     link#2             UC          0        0    xl1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:259
msgid ""
"With the current routing table, `RouterA` does not have a route to the "
"`192.168.2.0/24` network.  The following command adds the `Internal Net 2` "
"network to ``RouterA``'s routing table using `192.168.1.2` as the next hop:"
msgstr ""
"현재 라우팅 테이블을 사용하면 `RouterA`에 `192.168.2.0/24` 네트워크에 대한 "
"경로가 없습니다.  다음 명령은 `192.168.1.2`를 다음 홉으로 사용하여 "
"``RouterA``의 라우팅 테이블에 `Internal Net 2` 네트워크를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:263
#, no-wrap
msgid "# route add -net 192.168.2.0/24 192.168.1.2\n"
msgstr "# route add -net 192.168.2.0/24 192.168.1.2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:268
msgid ""
"Now, `RouterA` can reach any host on the `192.168.2.0/24` network.  However, "
"the routing information will not persist if the FreeBSD system reboots.  If "
"a static route needs to be persistent, add it to [.filename]#/etc/rc.conf#:"
msgstr ""
"이제 `RouterA`는 `192.168.2.0/24` 네트워크의 모든 호스트에 연결할 수 "
"있습니다.  그러나, 라우팅 정보는 FreeBSD 시스템이 재부팅되면 지속되지 "
"않습니다.  정적 경로를 영구적으로 유지해야 하는 경우 [.filename]#/etc/rc."
"conf#에 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:274
#, no-wrap
msgid ""
"# Add Internal Net 2 as a persistent static route\n"
"static_routes=\"internalnet2\"\n"
"route_internalnet2=\"-net 192.168.2.0/24 192.168.1.2\"\n"
msgstr ""
"# Add Internal Net 2 as a persistent static route\n"
"static_routes=\"internalnet2\"\n"
"route_internalnet2=\"-net 192.168.2.0/24 192.168.1.2\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:278
msgid ""
"The `static_routes` configuration variable is a list of strings separated by "
"a space, where each string references a route name.  The variable "
"`route_internalnet2` contains the static route for that route name."
msgstr ""
"`static_routes` 구성 변수는 공백으로 구분된 문자열 목록으로, 각 문자열은 "
"경로 이름을 참조합니다.  `route_internalnet2` 변수는 해당 경로 이름에 대한 "
"정적 경로를 포함합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:281
msgid ""
"Using more than one string in `static_routes` creates multiple static "
"routes.  The following shows an example of adding static routes for the "
"`192.168.0.0/24` and `192.168.1.0/24` networks:"
msgstr ""
"`static_routes`에 둘 이상의 문자열을 사용하면 여러 개의 고정 경로가 "
"생성됩니다.  다음은 `192.168.0.0/24` 및 `192.168.1.0/24` 네트워크에 대한 "
"정적 경로를 추가하는 예제입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:287
#, no-wrap
msgid ""
"static_routes=\"net1 net2\"\n"
"route_net1=\"-net 192.168.0.0/24 192.168.0.1\"\n"
"route_net2=\"-net 192.168.1.0/24 192.168.1.1\"\n"
msgstr ""
"static_routes=\"net1 net2\"\n"
"route_net1=\"-net 192.168.0.0/24 192.168.0.1\"\n"
"route_net2=\"-net 192.168.1.0/24 192.168.1.1\"\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:290
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1366
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1881
#, no-wrap
msgid "Troubleshooting"
msgstr "문제 해결"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:294
msgid ""
"When an address space is assigned to a network, the service provider "
"configures their routing tables so that all traffic for the network will be "
"sent to the link for the site.  But how do external sites know to send their "
"packets to the network's ISP?"
msgstr ""
"주소 공간이 네트워크에 할당되면 서비스 제공업체는 네트워크의 모든 트래픽이 "
"해당 사이트의 링크로 전송되도록 라우팅 테이블을 구성합니다.  하지만 외부 "
"사이트는 어떻게 네트워크의 ISP로 패킷을 전송할지 알 수 있을까요?"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:297
msgid ""
"There is a system that keeps track of all assigned address spaces and "
"defines their point of connection to the Internet backbone, or the main "
"trunk lines that carry Internet traffic across the country and around the "
"world.  Each backbone machine has a copy of a master set of tables, which "
"direct traffic for a particular network to a specific backbone carrier, and "
"from there down the chain of service providers until it reaches a particular "
"network."
msgstr ""
"할당된 모든 주소 공간을 추적하고 인터넷 백본 또는 전국 및 전 세계로 인터넷 "
"트래픽을 전송하는 주요 간선 회선에 대한 연결 지점을 정의하는 시스템이 "
"있습니다.  각 백본 머신에는 특정 네트워크의 트래픽을 특정 백본 캐리어로, "
"그리고 특정 네트워크에 도달할 때까지 서비스 제공업체의 체인을 따라 내려가는 "
"마스터 테이블 세트의 사본이 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:300
msgid ""
"It is the task of the service provider to advertise to the backbone sites "
"that they are the point of connection, and thus the path inward, for a "
"site.  This is known as route propagation."
msgstr ""
"서비스 제공업체는 백본 사이트가 사이트의 연결 지점, 즉 내부 경로임을 백본 "
"사이트에 알리는 역할을 합니다.  이를 경로 전파(route propagation)라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:304
msgid ""
"Sometimes, there is a problem with route propagation and some sites are "
"unable to connect.  Perhaps the most useful command for trying to figure out "
"where routing is breaking down is `traceroute`.  It is useful when `ping` "
"fails."
msgstr ""
"때때로 경로 전파에 문제가 발생하여 일부 사이트에 연결할 수 없는 경우가 "
"있습니다.  라우팅이 고장난 위치를 파악하는 데 가장 유용한 명령은 아마도 "
"`traceroute`일 것입니다.  `ping`이 실패할 때 유용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:308
msgid ""
"When using `traceroute`, include the address of the remote host to connect "
"to.  The output will show the gateway hosts along the path of the attempt, "
"eventually either reaching the target host, or terminating because of a lack "
"of connection.  For more information, refer to man:traceroute[8]."
msgstr ""
"`traceroute`를 사용할 때는 연결할 원격 호스트의 주소를 포함시키세요.  "
"출력에는 시도 경로를 따라 게이트웨이 호스트가 표시되며, 결국 대상 호스트에 "
"도달하거나 연결 부족으로 인해 종료됩니다.  자세한 내용은 man:traceroute[8]를 "
"참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:310
#, no-wrap
msgid "Multicast Considerations"
msgstr "멀티캐스트 고려사항"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:315
msgid ""
"FreeBSD natively supports both multicast applications and multicast "
"routing.  Multicast applications do not require any special configuration in "
"order to run on FreeBSD.  Support for multicast routing requires that the "
"following option be compiled into a custom kernel:"
msgstr ""
"FreeBSD는 기본적으로 멀티캐스트 애플리케이션과 멀티캐스트 라우팅을 모두 "
"지원합니다.  멀티캐스트 애플리케이션은 FreeBSD에서 실행하기 위해 특별한 "
"구성이 필요하지 않습니다.  멀티캐스트 라우팅을 지원하려면 다음 옵션을 커스텀 "
"커널에 컴파일해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:319
#, no-wrap
msgid "options MROUTING\n"
msgstr "options MROUTING\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:325
msgid ""
"The multicast routing daemon, mrouted can be installed using the package:net/"
"mrouted[] package or port.  This daemon implements the DVMRP multicast "
"routing protocol and is configured by editing [.filename]#/usr/local/etc/"
"mrouted.conf# in order to set up the tunnels and DVMRP.  The installation of "
"mrouted also installs map-mbone and mrinfo, as well as their associated man "
"pages.  Refer to these for configuration examples."
msgstr ""
"멀티캐스트 라우팅 데몬인 mrouted는 package:net/mrouted[] 패키지 또는 포트를 "
"사용하여 설치할 수 있습니다.  이 데몬은 DVMRP 멀티캐스트 라우팅 프로토콜을 "
"구현하며, 터널과 DVMRP를 설정하기 위해 [.filename]#/usr/local/etc/mrouted."
"conf#을 편집하여 구성합니다.  mrouted를 설치하면 map-mbone 및 mrinfo와 관련 "
"매뉴얼 페이지도 설치됩니다.  구성 예제는 이를 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:330
msgid ""
"DVMRP has largely been replaced by the PIM protocol in many multicast "
"installations.  Refer to man:pim[4] for more information."
msgstr "많은 멀티캐스트 설치에서 DVMRP는 대부분 PIM 프로토콜로 대체되었습니다.  "
"자세한 내용은 man:pim[4]을 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:333
#, no-wrap
msgid "Wireless Networking"
msgstr "무선 네트워킹"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:335
#, no-wrap
msgid "Wireless Networking Basics"
msgstr "무선 네트워킹 기초"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:339
msgid ""
"Most wireless networks are based on the IEEE(R) 802.11 standards.  A basic "
"wireless network consists of multiple stations communicating with radios "
"that broadcast in either the 2.4GHz or 5GHz band, though this varies "
"according to the locale and is also changing to enable communication in the "
"2.3GHz and 4.9GHz ranges."
msgstr ""
"대부분의 무선 네트워크는 IEEE(R) 802.11 표준을 기반으로 합니다.  기본 무선 "
"네트워크는 2.4GHz 또는 5GHz 대역에서 브로드캐스팅하는 라디오와 통신하는 여러 "
"개의 스테이션으로 구성되지만, 지역에 따라 다르며 2.3GHz 및 4.9GHz 범위에서도 "
"통신할 수 있도록 변경되고 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:345
msgid ""
"802.11 networks are organized in two ways.  In _infrastructure mode_, one "
"station acts as a master with all the other stations associating to it, the "
"network is known as a BSS, and the master station is termed an access point "
"(AP).  In a BSS, all communication passes through the AP; even when one "
"station wants to communicate with another wireless station, messages must go "
"through the AP.  In the second form of network, there is no master and "
"stations communicate directly.  This form of network is termed an IBSS and "
"is commonly known as an _ad-hoc network_."
msgstr ""
"802.11 네트워크는 두 가지 방식으로 구성됩니다.  _infrastructure mode_에서는 "
"한 스테이션이 다른 모든 스테이션을 연결하는 마스터 역할을 하며, 이 "
"네트워크를 BSS라고 하고, 마스터 스테이션을 액세스 포인트(AP)라고 합니다.  "
"BSS에서는 모든 통신이 AP를 통과하며, 한 스테이션이 다른 무선 스테이션과 "
"통신하려는 경우에도 메시지는 AP를 거쳐야 합니다.  두 번째 형태의 "
"네트워크에서는 마스터가 없으며 스테이션이 직접 통신합니다.  이러한 형태의 "
"네트워크를 IBSS라고 하며 일반적으로 _ad-hoc network_라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:350
msgid ""
"802.11 networks were first deployed in the 2.4GHz band using protocols "
"defined by the IEEE(R) 802.11 and 802.11b standard.  These specifications "
"include the operating frequencies and the MAC layer characteristics, "
"including framing and transmission rates, as communication can occur at "
"various rates.  Later, the 802.11a standard defined operation in the 5GHz "
"band, including different signaling mechanisms and higher transmission "
"rates.  Still later, the 802.11g standard defined the use of 802.11a "
"signaling and transmission mechanisms in the 2.4GHz band in such a way as to "
"be backwards compatible with 802.11b networks."
msgstr ""
"802.11 네트워크는 IEEE(R) 802.11 및 802.11b 표준에 정의된 프로토콜을 "
"사용하여 2.4GHz 대역에 처음 배포되었습니다.  이러한 사양에는 다양한 속도로 "
"통신이 이루어질 수 있으므로 작동 주파수와 프레이밍 및 전송 속도를 포함한 MAC "
"계층 특성이 포함됩니다.  이후 802.11a 표준은 다양한 신호 메커니즘과 더 높은 "
"전송 속도를 포함하여 5GHz 대역에서의 작동을 정의했습니다.  그 후 802.11g "
"표준에서는 802.11b 네트워크와 역호환이 가능하도록 2.4GHz 대역에서 802.11a "
"신호 및 전송 메커니즘을 사용하도록 정의했습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:363
msgid ""
"Separate from the underlying transmission techniques, 802.11 networks have a "
"variety of security mechanisms.  The original 802.11 specifications defined "
"a simple security protocol called WEP.  This protocol uses a fixed pre-"
"shared key and the RC4 cryptographic cipher to encode data transmitted on a "
"network.  Stations must all agree on the fixed key in order to communicate.  "
"This scheme was shown to be easily broken and is now rarely used except to "
"discourage transient users from joining networks.  Current security practice "
"is given by the IEEE(R) 802.11i specification that defines new cryptographic "
"ciphers and an additional protocol to authenticate stations to an access "
"point and exchange keys for data communication.  Cryptographic keys are "
"periodically refreshed and there are mechanisms for detecting and countering "
"intrusion attempts.  Another security protocol specification commonly used "
"in wireless networks is termed WPA, which was a precursor to 802.11i.  WPA "
"specifies a subset of the requirements found in 802.11i and is designed for "
"implementation on legacy hardware.  Specifically, WPA requires only the TKIP "
"cipher that is derived from the original WEP cipher.  802.11i permits use of "
"TKIP but also requires support for a stronger cipher, AES-CCM, for "
"encrypting data.  The AES cipher was not required in WPA because it was "
"deemed too computationally costly to be implemented on legacy hardware."
msgstr ""
"기본 전송 기술과는 별개로 802.11 네트워크에는 다양한 보안 메커니즘이 "
"있습니다.  원래 802.11 사양은 WEP라는 간단한 보안 프로토콜을 정의했습니다.  "
"이 프로토콜은 미리 공유된 고정 키와 RC4 암호화 암호를 사용하여 네트워크에서 "
"전송되는 데이터를 인코딩합니다.  통신을 위해서는 모든 스테이션이 고정 키에 "
"동의해야 합니다.  이 방식은 쉽게 깨질 수 있는 것으로 밝혀져 현재는 일시적인 "
"사용자의 네트워크 참여를 막는 경우를 제외하고는 거의 사용되지 않습니다.  "
"현재 보안 관행은 새로운 암호화 암호와 액세스 포인트에 대한 스테이션 인증 및 "
"데이터 통신을 위한 키 교환을 위한 추가 프로토콜을 정의하는 IEEE(R) 802.11i "
"사양에 의해 제공됩니다.  암호화 키는 주기적으로 새로 고쳐지며 침입 시도를 "
"감지하고 대응하는 메커니즘이 있습니다.  무선 네트워크에서 일반적으로 "
"사용되는 또 다른 보안 프로토콜 사양은 802.11i의 전신인 WPA라고 합니다.  "
"WPA는 802.11i에서 발견되는 요구 사항의 하위 집합을 지정하며 레거시 "
"하드웨어에서 구현하도록 설계되었습니다.  특히, WPA는 원래 WEP 암호에서 "
"파생된 TKIP 암호만 필요합니다.  802.11i는 TKIP 사용을 허용하지만 데이터 "
"암호화를 위해 더 강력한 암호인 AES-CCM에 대한 지원도 필요합니다.  AES 암호는 "
"레거시 하드웨어에서 구현하기에는 계산 비용이 너무 많이 드는 것으로 "
"간주되었기 때문에 WPA에서는 요구되지 않았습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:368
msgid ""
"The other standard to be aware of is 802.11e. It defines protocols for "
"deploying multimedia applications, such as streaming video and voice over IP "
"(VoIP), in an 802.11 network.  Like 802.11i, 802.11e also has a precursor "
"specification termed WME (later renamed WMM) that has been defined by an "
"industry group as a subset of 802.11e that can be deployed now to enable "
"multimedia applications while waiting for the final ratification of "
"802.11e.  The most important thing to know about 802.11e and WME/WMM is that "
"it enables prioritized traffic over a wireless network through Quality of "
"Service (QoS) protocols and enhanced media access protocols.  Proper "
"implementation of these protocols enables high speed bursting of data and "
"prioritized traffic flow."
msgstr ""
"알아두어야 할 또 다른 표준은 802.11e입니다. 이 표준은 802.11 네트워크에서 "
"스트리밍 비디오 및 VoIP(Voice over IP)와 같은 멀티미디어 애플리케이션을 "
"배포하기 위한 프로토콜을 정의합니다.  802.11i와 마찬가지로 802.11e에는 "
"802.11e의 최종 승인을 기다리는 동안 멀티미디어 애플리케이션을 활성화하기 "
"위해 지금 배포할 수 있는 802.11e의 하위 집합으로 업계 그룹에서 정의한 WME("
"나중에 WMM으로 이름 변경)라는 전구 사양도 있습니다.  802.11e와 WME/WMM에 "
"대해 알아야 할 가장 중요한 점은 서비스 품질(QoS) 프로토콜과 향상된 미디어 "
"액세스 프로토콜을 통해 무선 네트워크에서 트래픽의 우선순위를 지정할 수 "
"있다는 것입니다.  이러한 프로토콜을 올바르게 구현하면 데이터의 고속 버스팅과 "
"트래픽 흐름의 우선순위를 지정할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:371
msgid ""
"FreeBSD supports networks that operate using 802.11a, 802.11b, and 802.11g.  "
"The WPA and 802.11i security protocols are likewise supported (in "
"conjunction with any of 11a, 11b, and 11g) and QoS and traffic "
"prioritization required by the WME/WMM protocols are supported for a limited "
"set of wireless devices."
msgstr ""
"FreeBSD는 802.11a, 802.11b 및 802.11g를 사용하여 작동하는 네트워크를 "
"지원합니다.  WPA 및 802.11i 보안 프로토콜도 마찬가지로 지원되며(11a, 11b, "
"11g 중 하나와 함께), WME/WMM 프로토콜에 필요한 QoS 및 트래픽 우선 순위 "
"지정은 제한된 무선 장치 세트에 대해 지원됩니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:373
#, no-wrap
msgid "Quick Start"
msgstr "빠른 시작"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:377
msgid ""
"Connecting a computer to an existing wireless network is a very common "
"situation.  This procedure shows the steps required."
msgstr "컴퓨터를 기존 무선 네트워크에 연결하는 것은 매우 일반적인 상황입니다.  이 "
"절차는 필요한 단계를 보여줍니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:380
msgid ""
"Obtain the SSID (Service Set Identifier) and PSK (Pre-Shared Key) for the "
"wireless network from the network administrator."
msgstr "네트워크 관리자로부터 무선 네트워크의 SSID(Service Set Identifier) 및 PSK("
"사전 공유 키)를 받습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:382
msgid ""
"Identify the wireless adapter. The FreeBSD [.filename]#GENERIC# kernel "
"includes drivers for many common wireless adapters.  If the wireless adapter "
"is one of those models, it will be listed in the man:sysctl[8] `net.wlan."
"devices` variable:"
msgstr ""
"무선 어댑터를 확인합니다. FreeBSD [.filename]#GENERIC# 커널에는 많은 "
"일반적인 무선 어댑터용 드라이버가 포함되어 있습니다.  무선 어댑터가 이러한 "
"모델 중 하나인 경우, man:sysctl[8] `net.wlan.devices` 변수에 나열됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:386
#, no-wrap
msgid "% sysctl net.wlan.devices\n"
msgstr "% sysctl net.wlan.devices\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:389
msgid ""
"If a wireless adapter is not listed, an additional kernel module might be "
"required, or it might be a model not supported by FreeBSD."
msgstr "무선 어댑터가 목록에 없다면, 추가 커널 모듈이 필요하거나 FreeBSD에서 "
"지원하지 않는 모델일 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:391
msgid "This example shows the Atheros `ath0` wireless adapter."
msgstr "이 예는 Atheros `ath0` 무선 어댑터를 보여줍니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:392
msgid ""
"Add an entry for this network to [.filename]#/etc/wpa_supplicant.conf#. If "
"the file does not exist, create it. Replace _myssid_ and _mypsk_ with the "
"SSID and PSK provided by the network administrator."
msgstr ""
"이 네트워크에 대한 항목을 [.filename]#/etc/wpa_supplicant.conf#에 "
"추가합니다. 파일이 없는 경우 파일을 생성합니다. _myssid_ 및 _mypsk_를 "
"네트워크 관리자가 제공한 SSID 및 PSK로 바꿉니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:399
#, no-wrap
msgid ""
"network={\n"
"\tssid=\"myssid\"\n"
"\tpsk=\"mypsk\"\n"
"}\n"
msgstr ""
"network={\n"
"\tssid=\"myssid\"\n"
"\tpsk=\"mypsk\"\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:402
msgid ""
"Add entries to [.filename]#/etc/rc.conf# to configure the network on startup:"
msgstr "시작 시 네트워크를 구성하려면 [.filename]#/etc/rc.conf#에 항목을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:407
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA SYNCDHCP\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA SYNCDHCP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:410
msgid ""
"Restart the computer, or restart the network service to connect to the "
"network:"
msgstr "컴퓨터를 다시 시작하거나 네트워크 서비스를 다시 시작하여 네트워크에 "
"연결합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:414
#, no-wrap
msgid "# service netif restart\n"
msgstr "# service netif restart\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:417
#, no-wrap
msgid "Basic Setup"
msgstr "기본 설정"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:419
#, no-wrap
msgid "Kernel Configuration"
msgstr "커널 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:423
msgid ""
"To use wireless networking, a wireless networking card is needed and the "
"kernel needs to be configured with the appropriate wireless networking "
"support.  The kernel is separated into multiple modules so that only the "
"required support needs to be configured."
msgstr ""
"무선 네트워킹을 사용하려면 무선 네트워킹 카드가 필요하며 커널을 적절한 무선 "
"네트워킹 지원으로 구성해야 합니다.  커널은 여러 모듈로 분리되어 있으므로 "
"필요한 지원만 구성하면 됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:426
msgid ""
"The most commonly used wireless devices are those that use parts made by "
"Atheros.  These devices are supported by man:ath[4] and require the "
"following line to be added to [.filename]#/boot/loader.conf#:"
msgstr ""
"가장 일반적으로 사용되는 무선 장치는 Atheros에서 만든 부품을 사용하는 "
"장치입니다.  이러한 장치는 man:ath[4]에서 지원되며 [.filename]#/boot/loader."
"conf#에 다음 줄을 추가해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:430
#, no-wrap
msgid "if_ath_load=\"YES\"\n"
msgstr "if_ath_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:436
msgid ""
"The Atheros driver is split up into three separate pieces: the driver (man:"
"ath[4]), the hardware support layer that handles chip-specific functions "
"(man:ath_hal[4]), and an algorithm for selecting the rate for transmitting "
"frames.  When this support is loaded as kernel modules, any dependencies are "
"automatically handled.  To load support for a different type of wireless "
"device, specify the module for that device.  This example is for devices "
"based on the Intersil Prism parts (man:wi[4]) driver:"
msgstr ""
"Atheros 드라이버는 드라이버(man:ath[4]), 칩별 기능을 처리하는 하드웨어 지원 "
"계층(man:ath_hal[4]), 프레임 전송 속도를 선택하는 알고리즘의 세 부분으로 "
"나뉘어져 있습니다.  이 지원이 커널 모듈로 로드되면 모든 종속성이 자동으로 "
"처리됩니다.  다른 유형의 무선 장치에 대한 지원을 로드하려면 해당 장치에 대한 "
"모듈을 지정합니다.  이 예는 Intersil Prism 부품(man:wi[4]) 드라이버를 "
"기반으로 하는 장치에 대한 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:440
#, no-wrap
msgid "if_wi_load=\"YES\"\n"
msgstr "if_wi_load=\"YES\"\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:447
msgid ""
"The examples in this section use an man:ath[4] device and the device name in "
"the examples must be changed according to the configuration.  A list of "
"available wireless drivers and supported adapters can be found in the "
"FreeBSD Hardware Notes, available on the https://www.FreeBSD.org/releases/"
"[Release Information] page of the FreeBSD website.  If a native FreeBSD "
"driver for the wireless device does not exist, it may be possible to use the "
"Windows(R) driver with the help of the crossref:config[config-network-ndis,"
"NDIS] driver wrapper."
msgstr ""
"이 섹션의 예제에서는 man:ath[4] 장치를 사용하며, 예제에서 장치 이름은 구성에 "
"따라 변경해야 합니다.  사용 가능한 무선 드라이버 및 지원되는 어댑터 목록은 "
"FreeBSD 웹 사이트의 https://www.FreeBSD.org/releases/[릴리즈 정보] "
"페이지에서 제공되는 FreeBSD 하드웨어 노트에서 찾을 수 있습니다.  무선 장치에 "
"대한 기본 FreeBSD 드라이버가 없는 경우, crossref:config[config-network-"
"ndis,NDIS] 드라이버 래퍼를 사용하여 Windows(R) 드라이버를 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:455
msgid ""
"In addition, the modules that implement cryptographic support for the "
"security protocols to use must be loaded.  These are intended to be "
"dynamically loaded on demand by the man:wlan[4] module, but for now they "
"must be manually configured.  The following modules are available: man:"
"wlan_wep[4], man:wlan_ccmp[4], and man:wlan_tkip[4].  The man:wlan_ccmp[4] "
"and man:wlan_tkip[4] drivers are only needed when using the WPA or 802.11i "
"security protocols.  If the network does not use encryption, man:wlan_wep[4] "
"support is not needed.  To load these modules at boot time, add the "
"following lines to [.filename]#/boot/loader.conf#:"
msgstr ""
"또한 사용할 보안 프로토콜에 대한 암호화 지원을 구현하는 모듈을 로드해야 "
"합니다.  이러한 모듈은 man:wlan[4] 모듈에 의해 요청 시 동적으로 로드되도록 "
"설계되었지만 현재로서는 수동으로 구성해야 합니다.  다음 모듈을 사용할 수 "
"있습니다: man:wlan_wep[4], man:wlan_ccmp[4], man:wlan_tkip[4].  "
"man:wlan_ccmp[4] 및 man:wlan_tkip[4] 드라이버는 WPA 또는 802.11i 보안 "
"프로토콜을 사용할 때만 필요합니다.  네트워크에서 암호화를 사용하지 않는 경우 "
"man:wlan_wep[4] 지원이 필요하지 않습니다.  부팅 시 이러한 모듈을 로드하려면 ["
".filename]#/boot/loader.conf#에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:461
#, no-wrap
msgid ""
"wlan_wep_load=\"YES\"\n"
"wlan_ccmp_load=\"YES\"\n"
"wlan_tkip_load=\"YES\"\n"
msgstr ""
"wlan_wep_load=\"YES\"\n"
"wlan_ccmp_load=\"YES\"\n"
"wlan_tkip_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:465
msgid ""
"Once this information has been added to [.filename]#/boot/loader.conf#, "
"reboot the FreeBSD box.  Alternately, load the modules by hand using man:"
"kldload[8]."
msgstr ""
"이 정보를 [.filename]#/boot/loader.conf#에 추가한 후, FreeBSD 박스를 "
"재부팅합니다.  또는 man:kldload[8]를 사용하여 수동으로 모듈을 로드합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:469
msgid ""
"For users who do not want to use modules, it is possible to compile these "
"drivers into the kernel by adding the following lines to a custom kernel "
"configuration file:"
msgstr ""
"모듈을 사용하지 않으려는 사용자의 경우 커스텀 커널 구성 파일에 다음 줄을 "
"추가하여 이러한 드라이버를 커널에 컴파일할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:481
#, no-wrap
msgid ""
"device wlan                 # 802.11 support\n"
"device wlan_wep             # 802.11 WEP support\n"
"device wlan_ccmp            # 802.11 CCMP support\n"
"device wlan_tkip            # 802.11 TKIP support\n"
"device wlan_amrr            # AMRR transmit rate control algorithm\n"
"device ath                  # Atheros pci/cardbus NIC's\n"
"device ath_hal              # pci/cardbus chip support\n"
"options AH_SUPPORT_AR5416   # enable AR5416 tx/rx descriptors\n"
"device ath_rate_sample      # SampleRate tx rate control for ath\n"
msgstr ""
"device wlan                 # 802.11 support\n"
"device wlan_wep             # 802.11 WEP support\n"
"device wlan_ccmp            # 802.11 CCMP support\n"
"device wlan_tkip            # 802.11 TKIP support\n"
"device wlan_amrr            # AMRR transmit rate control algorithm\n"
"device ath                  # Atheros pci/cardbus NIC's\n"
"device ath_hal              # pci/cardbus chip support\n"
"options AH_SUPPORT_AR5416   # enable AR5416 tx/rx descriptors\n"
"device ath_rate_sample      # SampleRate tx rate control for ath\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:484
msgid ""
"With this information in the kernel configuration file, recompile the kernel "
"and reboot the FreeBSD machine."
msgstr "커널 구성 파일에 있는 이 정보를 사용하여 커널을 다시 컴파일하고 FreeBSD "
"머신을 재부팅합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:487
msgid ""
"Information about the wireless device should appear in the boot messages, "
"like this:"
msgstr "부팅 메시지에 다음과 같이 무선 장치에 대한 정보가 표시되어야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:493
#, no-wrap
msgid ""
"ath0: <Atheros 5212> mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1\n"
"ath0: [ITHREAD]\n"
"ath0: AR2413 mac 7.9 RF2413 phy 4.5\n"
msgstr ""
"ath0: <Atheros 5212> mem 0x88000000-0x8800ffff irq 11 at device 0.0 on "
"cardbus1\n"
"ath0: [ITHREAD]\n"
"ath0: AR2413 mac 7.9 RF2413 phy 4.5\n"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:495
#, no-wrap
msgid "Setting the Correct Region"
msgstr "올바른 지역 설정하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:498
msgid ""
"Since the regulatory situation is different in various parts of the world, "
"it is necessary to correctly set the domains that apply to your location to "
"have the correct information about what channels can be used."
msgstr ""
"전 세계 여러 지역의 규제 상황이 다르기 때문에 사용할 수 있는 채널에 대한 "
"정확한 정보를 얻으려면 해당 지역에 적용되는 도메인을 올바르게 설정해야 "
"합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:501
msgid ""
"The available region definitions can be found in [.filename]#/etc/regdomain."
"xml#.  To set the data at runtime, use `ifconfig`:"
msgstr ""
"사용 가능한 지역 정의는 [.filename]#/etc/regdomain.xml#에서 찾을 수 "
"있습니다.  런타임에 데이터를 설정하려면 `ifconfig`를 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:505
#, no-wrap
msgid "# ifconfig wlan0 regdomain ETSI country AT\n"
msgstr "# ifconfig wlan0 regdomain ETSI country AT\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:508
msgid "To persist the settings, add it to [.filename]#/etc/rc.conf#:"
msgstr "설정을 유지하려면 [.filename]#/etc/rc.conf#에 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:512
#, no-wrap
msgid "# sysrc create_args_wlan0=\"country AT regdomain ETSI\"\n"
msgstr "# sysrc create_args_wlan0=\"country AT regdomain ETSI\"\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:514
#, no-wrap
msgid "Infrastructure Mode"
msgstr "Infrastructure 모드"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:520
msgid ""
"Infrastructure (BSS) mode is the mode that is typically used.  In this mode, "
"a number of wireless access points are connected to a wired network.  Each "
"wireless network has its own name, called the SSID.  Wireless clients "
"connect to the wireless access points."
msgstr ""
"Infrastructure(BSS) 모드는 일반적으로 사용되는 모드입니다.  이 모드에서는 "
"여러 무선 액세스 포인트가 유선 네트워크에 연결됩니다.  각 무선 네트워크에는 "
"SSID라고 하는 고유한 이름이 있습니다.  무선 클라이언트는 무선 액세스 "
"포인트에 연결합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:521
#, no-wrap
msgid "FreeBSD Clients"
msgstr "FreeBSD 클라이언트"

#. type: Title =====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:523
#, no-wrap
msgid "How to Find Access Points"
msgstr "액세스 포인트 찾는 방법"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:528
msgid ""
"To scan for available networks, use man:ifconfig[8].  This request may take "
"a few moments to complete as it requires the system to switch to each "
"available wireless frequency and probe for available access points.  Only "
"the superuser can initiate a scan:"
msgstr ""
"사용 가능한 네트워크를 검색하려면 man:ifconfig[8]를 사용합니다.  이 요청은 "
"시스템이 사용 가능한 각 무선 주파수로 전환하여 사용 가능한 액세스 포인트를 "
"검색해야 하므로 완료하는 데 몇 분 정도 걸릴 수 있습니다.  수퍼유저만 스캔을 "
"시작할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:537
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up\n"
"# ifconfig wlan0 scan\n"
"SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up\n"
"# ifconfig wlan0 scan\n"
"SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:543
msgid ""
"The interface must be `up` before it can scan.  Subsequent scan requests do "
"not require the interface to be marked as up again."
msgstr "스캔하려면 인터페이스가 `up`상태여야 합니다.  이후 스캔 요청 시 인터페이스를 "
"다시 `up`으로 표시할 필요가 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:548
msgid ""
"The output of a scan request lists each BSS/IBSS network found.  Besides "
"listing the name of the network, the `SSID`, the output also shows the "
"`BSSID`, which is the MAC address of the access point.  The `CAPS` field "
"identifies the type of each network and the capabilities of the stations "
"operating there (see the definition of `list scan` in man:ifconfig[8] for "
"more details)."
msgstr ""
"스캔 요청의 출력에는 발견된 각 BSS/IBSS 네트워크가 나열됩니다.  출력에는 "
"네트워크 이름인 `SSID` 외에도 액세스 포인트의 MAC 주소인 `BSSID`도 "
"표시됩니다.  `CAPS` 필드는 각 네트워크의 유형과 해당 네트워크에서 작동하는 "
"스테이션의 기능을 식별합니다(자세한 내용은 man:ifconfig[8]에서 `list scan`의 "
"정의를 참조하세요)."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:550
msgid "One can also display the current list of known networks with:"
msgstr "알려진 네트워크의 현재 목록을 표시할 수도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:554
#, no-wrap
msgid "# ifconfig wlan0 list scan\n"
msgstr "# ifconfig wlan0 list scan\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:558
msgid ""
"This information may be updated automatically by the adapter or manually "
"with a `scan` request.  Old data is automatically removed from the cache, so "
"over time this list may shrink unless more scans are done."
msgstr ""
"이 정보는 어댑터에 의해 자동으로 업데이트되거나 `scan` 요청을 통해 수동으로 "
"업데이트될 수 있습니다.  오래된 데이터는 캐시에서 자동으로 제거되므로 시간이 "
"지남에 따라 더 많은 스캔을 수행하지 않으면 이 목록이 줄어들 수 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:559
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1137
#, no-wrap
msgid "Basic Settings"
msgstr "기본 설정"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:563
msgid ""
"This section provides a simple example of how to make the wireless network "
"adapter work in FreeBSD without encryption.  Once familiar with these "
"concepts, it is strongly recommend to use <<network-wireless-wpa,WPA>> to "
"set up the wireless network."
msgstr ""
"이 섹션에서는 암호화 없이 FreeBSD에서 무선 네트워크 어댑터를 작동시키는 "
"방법에 대한 간단한 예를 제공합니다.  이러한 개념에 익숙해지면, <<network-"
"wireless-wpa,WPA>>를 사용하여 무선 네트워크를 설정할 것을 강력히 권장합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:566
msgid ""
"There are three basic steps to configure a wireless network: select an "
"access point, authenticate the station, and configure an IP address.  The "
"following sections discuss each step."
msgstr ""
"무선 네트워크를 구성하는 데는 액세스 포인트 선택, 스테이션 인증, IP 주소 "
"구성의 세 가지 기본 단계가 있습니다.  다음 섹션에서는 각 단계에 대해 "
"설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:568
msgid "====== Selecting an Access Point"
msgstr "====== 액세스 포인트 선택하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:571
msgid ""
"Most of the time, it is sufficient to let the system choose an access point "
"using the builtin heuristics.  This is the default behavior when an "
"interface is marked as up or it is listed in [.filename]#/etc/rc.conf#:"
msgstr ""
"대부분의 경우 시스템이 내장된 휴리스틱을 사용하여 액세스 포인트를 선택하도록 "
"하는 것으로 충분합니다.  인터페이스가 위로 표시되어 있거나 [.filename]#/etc/"
"rc.conf#에 나열되어 있는 경우 기본 동작입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:576
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:646
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"DHCP\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"DHCP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:579
msgid ""
"If there are multiple access points, a specific one can be selected by its "
"SSID:"
msgstr "액세스 포인트가 여러 개 있는 경우, 해당 SSID로 특정 액세스 포인트를 선택할 "
"수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:584
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"ssid your_ssid_here DHCP\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"ssid your_ssid_here DHCP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:588
msgid ""
"In an environment where there are multiple access points with the same SSID, "
"which is often done to simplify roaming, it may be necessary to associate to "
"one specific device.  In this case, the BSSID of the access point can be "
"specified, with or without the SSID:"
msgstr ""
"로밍을 간소화하기 위해 동일한 SSID를 사용하는 액세스 포인트가 여러 개 있는 "
"환경에서는 하나의 특정 장치에 연결해야 할 수 있습니다.  이 경우 SSID를 "
"포함하거나 포함하지 않고 액세스 포인트의 BSSID를 지정할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:593
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:598
msgid ""
"There are other ways to constrain the choice of an access point, such as "
"limiting the set of frequencies the system will scan on.  This may be useful "
"for a multi-band wireless card as scanning all the possible channels can be "
"time-consuming.  To limit operation to a specific band, use the `mode` "
"parameter:"
msgstr ""
"시스템에서 스캔할 주파수 세트를 제한하는 등 액세스 포인트 선택을 제한하는 "
"다른 방법도 있습니다.  가능한 모든 채널을 스캔하는 데 시간이 많이 소요될 수 "
"있으므로 다중 대역 무선 카드에 유용할 수 있습니다.  특정 대역으로 작동을 "
"제한하려면 `mode` 매개변수를 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:603
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"mode 11g ssid your_ssid_here DHCP\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"mode 11g ssid your_ssid_here DHCP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:608
msgid ""
"This example will force the card to operate in 802.11g, which is defined "
"only for 2.4GHz frequencies so any 5GHz channels will not be considered.  "
"This can also be achieved with the `channel` parameter, which locks "
"operation to one specific frequency, and the `chanlist` parameter, to "
"specify a list of channels for scanning.  More information about these "
"parameters can be found in man:ifconfig[8]."
msgstr ""
"이 예에서는 카드가 2.4GHz 주파수로만 정의된 802.11g에서 작동하도록 "
"강제하므로 5GHz 채널은 고려되지 않습니다.  특정 주파수로 작동을 고정하는 "
"`channel` 매개변수와 스캔할 채널 목록을 지정하는 `chanlist` 매개변수를 "
"사용하여 이 작업을 수행할 수도 있습니다.  이러한 매개변수에 대한 자세한 "
"내용은 man:ifconfig[8]에서 확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:610
msgid "====== Authentication"
msgstr "====== 인증"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:618
msgid ""
"Once an access point is selected, the station needs to authenticate before "
"it can pass data.  Authentication can happen in several ways.  The most "
"common scheme, open authentication, allows any station to join the network "
"and communicate.  This is the authentication to use for test purposes the "
"first time a wireless network is setup.  Other schemes require cryptographic "
"handshakes to be completed before data traffic can flow, either using pre-"
"shared keys or secrets, or more complex schemes that involve backend "
"services such as RADIUS.  Open authentication is the default setting.  The "
"next most common setup is WPA-PSK, also known as WPA Personal, which is "
"described in <<network-wireless-wpa-wpa-psk>>."
msgstr ""
"액세스 포인트를 선택하면 스테이션이 데이터를 전달하기 전에 인증을 받아야 "
"합니다.  인증은 여러 가지 방법으로 이루어질 수 있습니다.  가장 일반적인 "
"방식인 개방형 인증은 모든 스테이션이 네트워크에 참여하여 통신할 수 있도록 "
"허용합니다.  이 인증은 무선 네트워크를 처음 설정할 때 테스트 목적으로 "
"사용하는 인증입니다.  다른 방식은 데이터 트래픽이 흐르기 전에 미리 공유된 키 "
"또는 비밀을 사용하거나 RADIUS와 같은 백엔드 서비스를 포함하는 더 복잡한 "
"방식을 사용하여 암호화 핸드셰이크를 완료해야 합니다.  기본 설정은 개방형 "
"인증입니다.  다음으로 가장 일반적인 설정은 <<network-wireless-wpa-wpa-"
"psk>>에 설명된 WPA 개인이라고도 하는 WPA-PSK입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:624
msgid ""
"If using an Apple(R) AirPort(R) Extreme base station for an access point, "
"shared-key authentication together with a WEP key needs to be configured.  "
"This can be configured in [.filename]#/etc/rc.conf# or by using man:"
"wpa_supplicant[8].  For a single AirPort(R) base station, access can be "
"configured with:"
msgstr ""
"Apple(R) AirPort(R) Extreme 베이스 스테이션을 액세스 포인트에 사용하는 경우, "
"WEP 키와 함께 공유 키 인증을 구성해야 합니다.  이 구성은 [.filename]#/etc/rc."
"conf#에서 구성하거나 man:wpa_supplicant[8]를 사용하여 구성할 수 있습니다.  "
"단일 AirPort(R) 베이스 스테이션의 경우 다음을 사용하여 액세스를 구성할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:629
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP\""
"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:634
msgid ""
"In general, shared key authentication should be avoided because it uses the "
"WEP key material in a highly-constrained manner, making it even easier to "
"crack the key.  If WEP must be used for compatibility with legacy devices, "
"it is better to use WEP with `open` authentication.  More information "
"regarding WEP can be found in <<network-wireless-wep>>."
msgstr ""
"일반적으로 공유 키 인증은 WEP 키 자료를 매우 제한적인 방식으로 사용하므로 "
"키를 더 쉽게 해독할 수 있으므로 피해야 합니다.  레거시 장치와의 호환성을 "
"위해 WEP를 사용해야 하는 경우 `open` 인증과 함께 WEP를 사용하는 것이 "
"좋습니다.  WEP에 대한 자세한 내용은 <<network-wireless-wep>>에서 확인할 수 "
"있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:637
msgid "====== Getting an IP Address with DHCP"
msgstr "====== DHCP로 IP 주소 얻기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:641
msgid ""
"Once an access point is selected and the authentication parameters are set, "
"an IP address must be obtained in order to communicate.  Most of the time, "
"the IP address is obtained via DHCP.  To achieve that, edit [.filename]#/etc/"
"rc.conf# and add `DHCP` to the configuration for the device:"
msgstr ""
"액세스 포인트를 선택하고 인증 매개변수를 설정한 후에는 통신을 위해 IP 주소를 "
"얻어야 합니다.  대부분의 경우 IP 주소는 DHCP를 통해 얻습니다.  이를 위해 [."
"filename]#/etc/rc.conf#를 편집하고 장치 구성에 `DHCP`를 추가합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:649
msgid "The wireless interface is now ready to bring up:"
msgstr "이제 무선 인터페이스를 불러올 준비가 되었습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:653
#, no-wrap
msgid "# service netif start\n"
msgstr "# service netif start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:656
msgid ""
"Once the interface is running, use man:ifconfig[8] to see the status of the "
"interface [.filename]#ath0#:"
msgstr "인터페이스가 실행 중이면 man:ifconfig[8]을 사용하여 인터페이스 [."
"filename]#ath0#의 상태를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:669
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"        ether 00:11:95:d5:43:62\n"
"        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255\n"
"        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g\n"
"        status: associated\n"
"        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76\n"
"        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7\n"
"        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7\n"
"        roam:rate 5 protmode CTS wme burst\n"
msgstr ""
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"        ether 00:11:95:d5:43:62\n"
"        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255\n"
"        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g\n"
"        status: associated\n"
"        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76\n"
"        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7\n"
"        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7\n"
"        roam:rate 5 protmode CTS wme burst\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:673
msgid ""
"The `status: associated` line means that it is connected to the wireless "
"network.  The `bssid 00:13:46:49:41:76` is the MAC address of the access "
"point and `authmode OPEN` indicates that the communication is not encrypted."
msgstr ""
"`status: associated` 줄은 무선 네트워크에 연결되어 있음을 의미합니다.  `"
"bssid 00:13:46:49:41:76`은 액세스 포인트의 MAC 주소이며, `authmode OPEN`은 "
"통신이 암호화되지 않았음을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:675
msgid "====== Static IP Address"
msgstr "====== 고정 IP 주소"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:679
msgid ""
"If an IP address cannot be obtained from a DHCP server, set a fixed IP "
"address.  Replace the `DHCP` keyword shown above with the address "
"information.  Be sure to retain any other parameters for selecting the "
"access point:"
msgstr ""
"DHCP 서버에서 IP 주소를 얻을 수 없는 경우 고정 IP 주소를 설정합니다.  위에 "
"표시된 `DHCP` 키워드를 주소 정보로 바꿉니다.  액세스 포인트 선택을 위한 다른 "
"매개변수는 그대로 유지하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:684
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"inet 192.168.1.100 netmask 255.255.255.0 ssid "
"your_ssid_here\"\n"

#. type: Title =====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:687
#, no-wrap
msgid "WPA"
msgstr "WPA"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:697
msgid ""
"Wi-Fi Protected Access (WPA) is a security protocol used together with "
"802.11 networks to address the lack of proper authentication and the "
"weakness of WEP.  WPA leverages the 802.1X authentication protocol and uses "
"one of several ciphers instead of WEP for data integrity.  The only cipher "
"required by WPA is the Temporary Key Integrity Protocol (TKIP).  TKIP is a "
"cipher that extends the basic RC4 cipher used by WEP by adding integrity "
"checking, tamper detection, and measures for responding to detected "
"intrusions.  TKIP is designed to work on legacy hardware with only software "
"modification.  It represents a compromise that improves security but is "
"still not entirely immune to attack.  WPA also specifies the AES-CCMP cipher "
"as an alternative to TKIP, and that is preferred when possible.  For this "
"specification, the term WPA2 or RSN is commonly used."
msgstr ""
"WPA(Wi-Fi Protected Access)는 802.11 네트워크와 함께 사용되는 보안 "
"프로토콜로, 적절한 인증이 부족하고 WEP의 취약점을 해결하기 위해 사용됩니다.  "
"WPA는 802.1X 인증 프로토콜을 활용하며 데이터 무결성을 위해 WEP 대신 여러 "
"암호 중 하나를 사용합니다.  WPA에서 요구하는 유일한 암호는 임시 키 무결성 "
"프로토콜(Temporary Key Integrity Protocol, TKIP)입니다.  TKIP는 무결성 검사, "
"변조 감지 및 감지된 침입에 대응하기 위한 조치를 추가하여 WEP에서 사용하는 "
"기본 RC4 암호를 확장한 암호입니다.  TKIP는 소프트웨어 수정만으로 레거시 "
"하드웨어에서 작동하도록 설계되었습니다.  이는 보안을 개선하기 위한 "
"절충안이지만 여전히 공격으로부터 완전히 자유롭지는 않습니다.  WPA는 또한 "
"TKIP의 대안으로 AES-CCMP 암호를 지정하고 있으며, 가능한 경우 이 암호를 "
"선호합니다.  이 사양에서는 WPA2 또는 RSN이라는 용어가 일반적으로 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:702
msgid ""
"WPA defines authentication and encryption protocols.  Authentication is most "
"commonly done using one of two techniques: by 802.1X and a backend "
"authentication service such as RADIUS, or by a minimal handshake between the "
"station and the access point using a pre-shared secret.  The former is "
"commonly termed WPA Enterprise and the latter is known as WPA Personal.  "
"Since most people will not set up a RADIUS backend server for their wireless "
"network, WPA-PSK is by far the most commonly encountered configuration for "
"WPA."
msgstr ""
"WPA는 인증 및 암호화 프로토콜을 정의합니다.  인증은 802.1X 및 RADIUS와 같은 "
"백엔드 인증 서비스 또는 미리 공유한 암호를 사용하여 스테이션과 액세스 포인트 "
"간 최소한의 핸드셰이크를 사용하는 두 가지 기술 중 하나를 사용하여 "
"수행됩니다.  전자는 일반적으로 WPA 엔터프라이즈라고 하고 후자는 WPA "
"개인이라고 합니다.  대부분의 사람들이 무선 네트워크에 RADIUS 백엔드 서버를 "
"설정하지 않기 때문에 WPA-PSK가 가장 일반적으로 사용되는 WPA 구성입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:706
msgid ""
"The control of the wireless connection and the key negotiation or "
"authentication with a server is done using man:wpa_supplicant[8].  This "
"program requires a configuration file, [.filename]#/etc/wpa_supplicant."
"conf#, to run.  More information regarding this file can be found in man:"
"wpa_supplicant.conf[5]."
msgstr ""
"무선 연결 제어와 서버와의 키 협상 또는 인증은 man:wpa_supplicant[8]를 "
"사용하여 수행합니다.  이 프로그램을 실행하려면 구성 파일인 [.filename]#/etc/"
"wpa_supplicant.conf#가 필요합니다.  이 파일에 대한 자세한 정보는 "
"man:wpa_supplicant.conf[5]에서 확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:709
msgid "====== WPA-PSK"
msgstr "====== WPA-PSK"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:713
msgid ""
"WPA-PSK, also known as WPA Personal, is based on a pre-shared key (PSK) "
"which is generated from a given password and used as the master key in the "
"wireless network.  This means every wireless user will share the same key.  "
"WPA-PSK is intended for small networks where the use of an authentication "
"server is not possible or desired."
msgstr ""
"WPA 개인이라고도 하는 WPA-PSK는 주어진 비밀번호로 생성되어 무선 네트워크에서 "
"마스터 키로 사용되는 사전 공유 키(PSK)를 기반으로 합니다.  즉, 모든 무선 "
"사용자가 동일한 키를 공유하게 됩니다.  WPA-PSK는 인증 서버를 사용할 수 "
"없거나 원치 않는 소규모 네트워크를 위한 것입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:717
msgid ""
"Always use strong passwords that are sufficiently long and made from a rich "
"alphabet so that they will not be easily guessed or attacked."
msgstr "항상 충분히 길고 다양한 알파벳으로 구성된 강력한 비밀번호를 사용하여 쉽게 "
"추측하거나 공격당하지 않도록 하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:720
msgid ""
"The first step is the configuration of [.filename]#/etc/wpa_supplicant.conf# "
"with the SSID and the pre-shared key of the network:"
msgstr ""
"첫 번째 단계는 네트워크의 SSID와 미리 공유한 키를 사용하여 [.filename]#/etc/"
"wpa_supplicant.conf#을 구성하는 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:727
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  psk=\"freebsdmall\"\n"
"}\n"
msgstr ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  psk=\"freebsdmall\"\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:730
msgid ""
"Then, in [.filename]#/etc/rc.conf#, indicate that the wireless device "
"configuration will be done with WPA and the IP address will be obtained with "
"DHCP:"
msgstr ""
"그리고 나서 [.filename]#/etc/rc.conf#에서 무선 장치 구성은 WPA로, IP 주소는 "
"DHCP로 가져올 것을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:735
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:872
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:934
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1005
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA DHCP\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA DHCP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:738
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1008
msgid "Then, bring up the interface:"
msgstr "이제 인터페이스를 불러옵니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:759
#, no-wrap
msgid ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5\n"
"DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6\n"
"DHCPOFFER from 192.168.0.1\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67\n"
"DHCPACK from 192.168.0.1\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5\n"
"DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6\n"
"DHCPOFFER from 192.168.0.1\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67\n"
"DHCPACK from 192.168.0.1\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:762
msgid ""
"Or, try to configure the interface manually using the information in [."
"filename]#/etc/wpa_supplicant.conf#:"
msgstr "또는 [.filename]#/etc/wpa_supplicant.conf#의 정보를 사용하여 인터페이스를 "
"수동으로 구성해 보세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:770
#, no-wrap
msgid ""
"# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf\n"
"Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)\n"
"Associated with 00:11:95:c3:0d:ac\n"
"WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]\n"
"CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]\n"
msgstr ""
"# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf\n"
"Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)\n"
"Associated with 00:11:95:c3:0d:ac\n"
"WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]\n"
"CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) ["
"id=0 id_str=]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:773
msgid ""
"The next operation is to launch man:dhclient[8] to get the IP address from "
"the DHCP server:"
msgstr "다음 작업은 man:dhclient[8]를 실행하여 DHCP 서버에서 IP 주소를 가져오는 "
"것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:791
#, no-wrap
msgid ""
"# dhclient wlan0\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67\n"
"DHCPACK from 192.168.0.1\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""
"# dhclient wlan0\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67\n"
"DHCPACK from 192.168.0.1\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:796
msgid ""
"If [.filename]#/etc/rc.conf# has an `ifconfig_wlan0=\"DHCP\"` entry, man:"
"dhclient[8] will be launched automatically after man:wpa_supplicant[8] "
"associates with the access point."
msgstr ""
"[.filename]#/etc/rc.conf#에 `ifconfig_wlan0=\"DHCP\"` 항목이 있는 경우, "
"man:wpa_supplicant[8]가 액세스 포인트와 연결되면 man:dhclient[8]가 자동으로 "
"시작됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:799
msgid ""
"If DHCP is not possible or desired, set a static IP address after man:"
"wpa_supplicant[8] has authenticated the station:"
msgstr ""
"DHCP를 사용할 수 없거나 원하지 않는 경우, man:wpa_supplicant[8]가 스테이션을 "
"인증한 후 고정 IP 주소를 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:814
#, no-wrap
msgid ""
"# ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0\n"
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""
"# ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0\n"
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:817
msgid ""
"When DHCP is not used, the default gateway and the nameserver also have to "
"be manually set:"
msgstr "DHCP를 사용하지 않는 경우 기본 게이트웨이와 네임서버도 수동으로 설정해야 "
"합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:822
#, no-wrap
msgid ""
"# route add default your_default_router\n"
"# echo \"nameserver your_DNS_server\" >> /etc/resolv.conf\n"
msgstr ""
"# route add default your_default_router\n"
"# echo \"nameserver your_DNS_server\" >> /etc/resolv.conf\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:826
msgid "====== WPA with EAP-TLS"
msgstr "====== EAP-TLS를 사용한 WPA"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:830
msgid ""
"The second way to use WPA is with an 802.1X backend authentication server.  "
"In this case, WPA is called WPA Enterprise to differentiate it from the less "
"secure WPA Personal.  Authentication in WPA Enterprise is based on the "
"Extensible Authentication Protocol (EAP)."
msgstr ""
"두 번째 WPA 사용 방법은 802.1X 백엔드 인증 서버를 사용하는 것입니다.  이 "
"경우 보안 수준이 낮은 WPA 개인과 구분하기 위해 WPA를 WPA 엔터프라이즈라고 "
"합니다.  WPA Enterprise의 인증은 확장 가능한 인증 프로토콜(Extensible "
"Authentication Protocol, EAP)을 기반으로 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:834
msgid ""
"EAP does not come with an encryption method.  Instead, EAP is embedded "
"inside an encrypted tunnel.  There are many EAP authentication methods, but "
"EAP-TLS, EAP-TTLS, and EAP-PEAP are the most common."
msgstr ""
"EAP에는 암호화 방법이 제공되지 않습니다.  대신 EAP는 암호화된 터널 안에 "
"내장되어 있습니다.  EAP 인증 방법에는 여러 가지가 있지만 EAP-TLS, EAP-TTLS "
"및 EAP-PEAP가 가장 일반적입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:838
msgid ""
"EAP with Transport Layer Security (EAP-TLS) is a well-supported wireless "
"authentication protocol since it was the first EAP method to be certified by "
"the http://www.wi-fi.org/[Wi-Fi Alliance].  EAP-TLS requires three "
"certificates to run: the certificate of the Certificate Authority (CA) "
"installed on all machines, the server certificate for the authentication "
"server, and one client certificate for each wireless client.  In this EAP "
"method, both the authentication server and wireless client authenticate each "
"other by presenting their respective certificates, and then verify that "
"these certificates were signed by the organization's CA."
msgstr ""
"EAP-TLS(전송 계층 보안을 사용한 EAP)는 http://www.wi-fi.org/[Wi-Fi Alliance]"
"에서 인증한 최초의 EAP 방법이기 때문에 널리 지원되는 무선 인증 "
"프로토콜입니다.  EAP-TLS를 실행하려면 모든 컴퓨터에 설치된 CA(인증 기관)의 "
"인증서, 인증 서버에 대한 서버 인증서, 각 무선 클라이언트에 대한 클라이언트 "
"인증서 등 세 개의 인증서가 필요합니다.  이 EAP 방식에서는 인증 서버와 무선 "
"클라이언트가 각각의 인증서를 제시하여 서로를 인증한 다음, 이 인증서가 조직의 "
"CA에 의해 서명되었는지 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:840
msgid ""
"As previously, the configuration is done via [.filename]#/etc/wpa_supplicant."
"conf#:"
msgstr "이전과 마찬가지로 [.filename]#/etc/wpa_supplicant.conf#를 통해 구성을 "
"수행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:854
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\" <.>\n"
"  proto=RSN  <.>\n"
"  key_mgmt=WPA-EAP <.>\n"
"  eap=TLS <.>\n"
"  identity=\"loader\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  client_cert=\"/etc/certs/clientcert.pem\" <.>\n"
"  private_key=\"/etc/certs/clientkey.pem\" <.>\n"
"  private_key_passwd=\"freebsdmallclient\" <.>\n"
"}\n"
msgstr ""
"network={\n"
"  ssid=\"freebsdap\" <.>\n"
"  proto=RSN  <.>\n"
"  key_mgmt=WPA-EAP <.>\n"
"  eap=TLS <.>\n"
"  identity=\"loader\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  client_cert=\"/etc/certs/clientcert.pem\" <.>\n"
"  private_key=\"/etc/certs/clientkey.pem\" <.>\n"
"  private_key_passwd=\"freebsdmallclient\" <.>\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:857
msgid "This field indicates the network name (SSID)."
msgstr "이 필드는 네트워크 이름(SSID)을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:858
msgid "This example uses the RSN IEEE(R) 802.11i protocol, also known as WPA2."
msgstr "이 예에서는 WPA2라고도 하는 RSN IEEE(R) 802.11i 프로토콜을 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:859
msgid ""
"The `key_mgmt` line refers to the key management protocol to use. In this "
"example, it is WPA using EAP authentication."
msgstr "`key_mgmt` 줄은 사용할 키 관리 프로토콜을 나타냅니다. 이 예에서는 EAP 인증을 "
"사용하는 WPA입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:860
msgid "This field indicates the EAP method for the connection."
msgstr "이 필드는 EAP 연결방법을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:861
msgid "The `identity` field contains the identity string for EAP."
msgstr "`identity` 필드에는 EAP의 ID 문자열이 포함됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:862
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:926
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:996
msgid ""
"The `ca_cert` field indicates the pathname of the CA certificate file. This "
"file is needed to verify the server certificate."
msgstr "`ca_cert` 필드는 CA 인증서 파일의 경로명을 나타냅니다. 이 파일은 서버 "
"인증서를 확인하는 데 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:863
msgid ""
"The `client_cert` line gives the pathname to the client certificate file. "
"This certificate is unique to each wireless client of the network."
msgstr ""
"`client_cert` 줄은 클라이언트 인증서 파일의 경로명을 제공합니다. 이 인증서는 "
"네트워크의 각 무선 클라이언트마다 고유합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:864
msgid ""
"The `private_key` field is the pathname to the client certificate private "
"key file."
msgstr "`private_key 필드는 클라이언트 인증서 개인 키 파일의 경로 이름입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:865
msgid ""
"The `private_key_passwd` field contains the passphrase for the private key."
msgstr "`private_key_passwd` 필드에는 개인키의 비밀번호가 입력됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:867
msgid "Then, add the following lines to [.filename]#/etc/rc.conf#:"
msgstr "다음으로, [.filename]#/etc/rc.conf#에 다음 줄을 추가합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:875
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:937
msgid "The next step is to bring up the interface:"
msgstr "다음 단계는 인터페이스를 불러오는 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:894
#, no-wrap
msgid ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:897
msgid ""
"It is also possible to bring up the interface manually using man:"
"wpa_supplicant[8] and man:ifconfig[8]."
msgstr "man:wpa_supplicant[8] 및 man:ifconfig[8]를 사용하여 수동으로 인터페이스를 "
"불러올 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:900
msgid "====== WPA with EAP-TTLS"
msgstr "====== EAP-TTLS를 사용한 WPA"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:905
msgid ""
"With EAP-TLS, both the authentication server and the client need a "
"certificate.  With EAP-TTLS, a client certificate is optional.  This method "
"is similar to a web server which creates a secure SSL tunnel even if "
"visitors do not have client-side certificates.  EAP-TTLS uses an encrypted "
"TLS tunnel for safe transport of the authentication data."
msgstr ""
"EAP-TLS를 사용하면 인증 서버와 클라이언트 모두 인증서가 필요합니다.  EAP-"
"TTLS를 사용하면 클라이언트 인증서는 선택 사항입니다.  이 방법은 방문자에게 "
"클라이언트 측 인증서가 없는 경우에도 안전한 SSL 터널을 생성하는 웹 서버와 "
"유사합니다.  EAP-TTLS는 인증 데이터의 안전한 전송을 위해 암호화된 TLS 터널을 "
"사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:907
msgid ""
"The required configuration can be added to [.filename]#/etc/wpa_supplicant."
"conf#:"
msgstr "필요한 구성은 [.filename]#/etc/wpa_supplicant.conf#에 추가할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:920
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=TTLS <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase2=\"auth=MD5\" <.>\n"
"}\n"
msgstr ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=TTLS <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase2=\"auth=MD5\" <.>\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:923
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:993
msgid "This field specifies the EAP method for the connection."
msgstr "이 필드는 EAP에 대한 연결방법을 지정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:924
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:994
msgid ""
"The `identity` field contains the identity string for EAP authentication "
"inside the encrypted TLS tunnel."
msgstr "`identity` 필드에는 암호화된 TLS 터널 내부의 EAP 인증을 위한 ID 문자열이 "
"포함되어 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:925
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:995
msgid ""
"The `password` field contains the passphrase for the EAP authentication."
msgstr "`password` 필드에는 EAP 인증을 위한 비밀번호가 입력됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:927
msgid ""
"This field specifies the authentication method used in the encrypted TLS "
"tunnel. In this example, EAP with MD5-Challenge is used. The \"inner "
"authentication\" phase is often called \"phase2\"."
msgstr ""
"이 필드는 암호화된 TLS 터널에 사용되는 인증 방법을 지정합니다. 이 예에서는 "
"MD5-Challenge가 포함된 EAP가 사용됩니다. \"내부 인증(inner authentication)\" "
"단계는 종종 \"2 단계(phase 2)\"라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:929
msgid "Next, add the following lines to [.filename]#/etc/rc.conf#:"
msgstr "그런 다음 [.filename]#/etc/rc.conf#에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:957
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1028
#, no-wrap
msgid ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:961
msgid "====== WPA with EAP-PEAP"
msgstr "====== EAP-PEAP를 사용한 WPA"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:966
msgid ""
"PEAPv0/EAP-MSCHAPv2 is the most common PEAP method.  In this chapter, the "
"term PEAP is used to refer to that method."
msgstr ""
"PEAPv0/EAP-MSCHAPv2는 가장 일반적인 PEAP 방법입니다.  이 장에서는 PEAP라는 "
"용어를 사용하여 해당 방법을 지칭합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:970
msgid ""
"Protected EAP (PEAP) is designed as an alternative to EAP-TTLS and is the "
"most used EAP standard after EAP-TLS.  In a network with mixed operating "
"systems, PEAP should be the most supported standard after EAP-TLS."
msgstr ""
"PEAP(Protected EAP)은 EAP-TTLS의 대안으로 설계되었으며 EAP-TLS 다음으로 가장 "
"많이 사용되는 EAP 표준입니다.  운영 체제가 혼합된 네트워크에서는 PEAP이 EAP-"
"TLS 다음으로 가장 많이 지원되는 표준이어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:974
msgid ""
"PEAP is similar to EAP-TTLS as it uses a server-side certificate to "
"authenticate clients by creating an encrypted TLS tunnel between the client "
"and the authentication server, which protects the ensuing exchange of "
"authentication information.  PEAP authentication differs from EAP-TTLS as it "
"broadcasts the username in the clear and only the password is sent in the "
"encrypted TLS tunnel.  EAP-TTLS will use the TLS tunnel for both the "
"username and password."
msgstr ""
"PEAP은 서버 측 인증서를 사용하여 클라이언트와 인증 서버 사이에 암호화된 TLS "
"터널을 생성하여 클라이언트를 인증하고, 이후 인증 정보 교환을 보호한다는 "
"점에서 EAP-TTLS와 유사합니다.  PEAP 인증은 사용자 이름을 그대로 "
"브로드캐스트하고 암호화된 TLS 터널에서 비밀번호만 전송한다는 점에서 EAP-"
"TTLS와 다릅니다.  EAP-TTLS는 사용자 이름과 비밀번호 모두에 TLS 터널을 "
"사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:976
msgid ""
"Add the following lines to [.filename]#/etc/wpa_supplicant.conf# to "
"configure the EAP-PEAP related settings:"
msgstr ""
"[.filename]#/etc/wpa_supplicant.conf#에 다음 줄을 추가하여 EAP-PEAP 관련 "
"설정을 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:990
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=PEAP <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase1=\"peaplabel=0\" <.>\n"
"  phase2=\"auth=MSCHAPV2\" <.>\n"
"}\n"
msgstr ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=PEAP <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase1=\"peaplabel=0\" <.>\n"
"  phase2=\"auth=MSCHAPV2\" <.>\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:997
msgid ""
"This field contains the parameters for the first phase of authentication, "
"the TLS tunnel. According to the authentication server used, specify a "
"specific label for authentication. Most of the time, the label will be "
"\"client EAP encryption\" which is set by using `peaplabel=0`. More "
"information can be found in man:wpa_supplicant.conf[5]."
msgstr ""
"이 필드에는 인증의 첫 번째 단계인 TLS 터널에 대한 매개변수가 포함되어 "
"있습니다. 사용하는 인증 서버에 따라 인증에 사용할 특정 레이블을 지정합니다. "
"대부분의 경우 레이블은 `peaplabel=0`을 사용하여 설정하는 \"client EAP "
"encryption\"이 됩니다. 자세한 내용은 man:wpa_supplicant.conf[5]에서 확인할 "
"수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:998
msgid ""
"This field specifies the authentication protocol used in the encrypted TLS "
"tunnel. In the case of PEAP, it is `auth=MSCHAPV2`."
msgstr "이 필드는 암호화된 TLS 터널에서 사용되는 인증 프로토콜을 지정합니다. PEAP의 "
"경우 `auth=MSCHAPV2`입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1000
msgid "Add the following to [.filename]#/etc/rc.conf#:"
msgstr "[.filename]#/etc/rc.conf#에 다음을 추가합니다:"

#. type: Title =====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1031
#, no-wrap
msgid "WEP"
msgstr "WEP"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1035
msgid ""
"Wired Equivalent Privacy (WEP) is part of the original 802.11 standard.  "
"There is no authentication mechanism, only a weak form of access control "
"which is easily cracked."
msgstr ""
"WEP(Wired Equivalent Privacy)는 원래 802.11 표준의 일부입니다.  인증 "
"메커니즘이 없으며, 쉽게 뚫릴 수 있는 약한 형태의 액세스 제어만 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1037
msgid "WEP can be set up using man:ifconfig[8]:"
msgstr "WEP는 man:ifconfig[8]를 사용하여 설정할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1043
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \\\n"
"\t    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \\\n"
"\t    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1046
msgid ""
"The `weptxkey` specifies which WEP key will be used in the transmission. "
"This example uses the third key. This must match the setting on the access "
"point. When unsure which key is used by the access point, try `1` (the first "
"key) for this value."
msgstr ""
"`weptxkey`는 전송에 사용할 WEP 키를 지정합니다. 이 예에서는 세 번째 키를 "
"사용합니다. 이 키는 액세스 포인트의 설정과 일치해야 합니다. 액세스 "
"포인트에서 어떤 키를 사용하는지 확실하지 않은 경우 이 값에 `1`(첫 번째 키)을 "
"사용해 보십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1047
msgid ""
"The `wepkey` selects one of the WEP keys. It should be in the format _index:"
"key_. Key `1` is used by default; the index only needs to be set when using "
"a key other than the first key."
msgstr ""
"`wepkey`는 WEP 키 중 하나를 선택합니다. 색인은 _index:key_ 형식이어야 "
"합니다. 기본적으로 `1` 키가 사용되며, 첫 번째 키가 아닌 다른 키를 사용할 "
"때만 인덱스를 설정하면 됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1051
msgid ""
"Replace the `0x3456789012` with the key configured for use on the access "
"point."
msgstr "`0x3456789012`를 액세스 포인트에서 사용하도록 구성된 키로 바꿉니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1054
msgid "Refer to man:ifconfig[8] for further information."
msgstr "자세한 내용은 man:ifconfig[8]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1057
msgid ""
"The man:wpa_supplicant[8] facility can be used to configure a wireless "
"interface with WEP.  The example above can be set up by adding the following "
"lines to [.filename]#/etc/wpa_supplicant.conf#:"
msgstr ""
"man:wpa_supplicant[8] 기능을 사용하여 WEP로 무선 인터페이스를 구성할 수 "
"있습니다.  위의 예는 [.filename]#/etc/wpa_supplicant.conf#에 다음 줄을 "
"추가하여 설정할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1066
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"my_net\"\n"
"  key_mgmt=NONE\n"
"  wep_key3=3456789012\n"
"  wep_tx_keyidx=3\n"
"}\n"
msgstr ""
"network={\n"
"  ssid=\"my_net\"\n"
"  key_mgmt=NONE\n"
"  wep_key3=3456789012\n"
"  wep_tx_keyidx=3\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1069
msgid "Then:"
msgstr "다음으로:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1075
#, no-wrap
msgid ""
"# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf\n"
"Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)\n"
"Associated with 00:13:46:49:41:76\n"
msgstr ""
"# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf\n"
"Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)\n"
"Associated with 00:13:46:49:41:76\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1077
#, no-wrap
msgid "Ad-hoc Mode"
msgstr "Ad-hoc 모드"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1081
msgid ""
"IBSS mode, also called ad-hoc mode, is designed for point to point "
"connections.  For example, to establish an ad-hoc network between the "
"machines `A` and `B`, choose two IP addresses and a SSID."
msgstr ""
"ad-hoc 모드라고도 하는 IBSS 모드는 지점 간 연결을 위해 설계되었습니다.  예를 "
"들어, 머신 `A`와 `B` 사이에 ad-hoc 네트워크를 설정하려면 두 개의 IP 주소와 "
"하나의 SSID를 선택합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1083
msgid "On `A`:"
msgstr "`A`에서:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1097
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu "
"1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1100
msgid ""
"The `adhoc` parameter indicates that the interface is running in IBSS mode."
msgstr "`adhoc` 매개 변수는 인터페이스가 IBSS 모드에서 실행 중임을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1102
msgid "`B` should now be able to detect `A`:"
msgstr "이제 `B`는 `A`를 감지할 수 있어야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1109
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 up scan\n"
"  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 up scan\n"
"  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1113
msgid ""
"The `I` in the output confirms that `A` is in ad-hoc mode.  Now, configure "
"`B` with a different IP address:"
msgstr "출력의 `I`는 `A`가 ad-hoc 모드에 있음을 확인합니다.  이제 `B`를 다른 IP "
"주소로 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1126
#, no-wrap
msgid ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"
msgstr ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu "
"1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1129
msgid "Both `A` and `B` are now ready to exchange information."
msgstr "이제 `A`와 `B` 모두 정보를 교환할 준비가 되었습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1131
#, no-wrap
msgid "FreeBSD Host Access Points"
msgstr "FreeBSD 호스트 액세스 포인트"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1135
msgid ""
"FreeBSD can act as an Access Point (AP) which eliminates the need to buy a "
"hardware AP or run an ad-hoc network.  This can be particularly useful when "
"a FreeBSD machine is acting as a gateway to another network such as the "
"Internet."
msgstr ""
"FreeBSD는 하드웨어 AP를 구입하거나 ad-hoc 네트워크를 실행할 필요 없이 액세스 "
"포인트(AP) 역할을 할 수 있습니다.  이는 FreeBSD 머신이 인터넷과 같은 다른 "
"네트워크의 게이트웨이 역할을 할 때 특히 유용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1141
msgid ""
"Before configuring a FreeBSD machine as an AP, the kernel must be configured "
"with the appropriate networking support for the wireless card as well as the "
"security protocols being used.  For more details, see <<network-wireless-"
"basic>>."
msgstr ""
"FreeBSD 머신을 AP로 구성하기 전에, 커널은 무선 카드에 대한 적절한 네트워킹 "
"지원과 사용 중인 보안 프로토콜로 구성해야 합니다.  자세한 내용은 <<network-"
"wireless-basic>>을 참조하십시오."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1146
msgid ""
"The NDIS driver wrapper for Windows(R) drivers does not currently support AP "
"operation.  Only native FreeBSD wireless drivers support AP mode."
msgstr ""
"Windows(R) 드라이버용 NDIS 드라이버 래퍼는 현재 AP 작동을 지원하지 "
"않습니다.  네이티브 FreeBSD 무선 드라이버만 AP 모드를 지원합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1149
msgid ""
"Once wireless networking support is loaded, check if the wireless device "
"supports the host-based access point mode, also known as hostap mode:"
msgstr "무선 네트워킹 지원이 로드되면 무선 장치가 호스트 기반 액세스 포인트 모드("
"hostap 모드라고도 함)를 지원하는지 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1156
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 list caps\n"
"drivercaps=6f85edc1<STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG>\n"
"cryptocaps=1f<WEP,TKIP,AES,AES_CCM,TKIPMIC>\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 list caps\n"
"drivercaps=6f85edc1<STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE"
",MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG>\n"
"cryptocaps=1f<WEP,TKIP,AES,AES_CCM,TKIPMIC>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1162
msgid ""
"This output displays the card's capabilities.  The `HOSTAP` word confirms "
"that this wireless card can act as an AP.  Various supported ciphers are "
"also listed: WEP, TKIP, and AES.  This information indicates which security "
"protocols can be used on the AP."
msgstr ""
"이 출력은 카드의 기능을 표시합니다.  `HOSTAP` 단어는 이 무선 카드가 AP로 "
"작동할 수 있음을 확인합니다.  지원되는 다양한 암호도 나열됩니다: WEP, TKIP "
"및 AES.  이 정보는 AP에서 사용할 수 있는 보안 프로토콜을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1164
msgid ""
"The wireless device can only be put into hostap mode during the creation of "
"the network pseudo-device, so a previously created device must be destroyed "
"first:"
msgstr ""
"무선 디바이스는 네트워크 의사 디바이스를 생성하는 동안에만 hostap 모드로 "
"전환할 수 있으므로 이전에 생성한 디바이스를 먼저 삭제해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1168
#, no-wrap
msgid "# ifconfig wlan0 destroy\n"
msgstr "# ifconfig wlan0 destroy\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1171
msgid ""
"then regenerated with the correct option before setting the other parameters:"
msgstr "그리고 나서 다른 매개변수를 설정하기 전에 올바른 옵션으로 다시 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1176
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode hostap\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0 wlanmode hostap\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode "
"11g channel 1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1179
msgid ""
"Use man:ifconfig[8] again to see the status of the [.filename]#wlan0# "
"interface:"
msgstr "man:ifconfig[8]을 다시 사용하여 [.filename]#wlan0# 인터페이스의 상태를 "
"확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1191
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst dtimperiod 1 -dfs\n"
msgstr ""
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu "
"1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst dtimperiod 1 -dfs\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1194
msgid ""
"The `hostap` parameter indicates the interface is running in the host-based "
"access point mode."
msgstr "`hostap` 매개 변수는 인터페이스가 호스트 기반 액세스 포인트 모드에서 실행 "
"중임을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1196
msgid ""
"The interface configuration can be done automatically at boot time by adding "
"the following lines to [.filename]#/etc/rc.conf#:"
msgstr "인터페이스 구성은 [.filename]#/etc/rc.conf#에 다음 줄을 추가하여 부팅 시 "
"자동으로 수행할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1202
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"create_args_wlan0=\"wlanmode hostap\"\n"
"ifconfig_wlan0=\"inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1\"\n"
msgstr ""
"wlans_ath0=\"wlan0\"\n"
"create_args_wlan0=\"wlanmode hostap\"\n"
"ifconfig_wlan0=\"inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode "
"11g channel 1\"\n"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1204
#, no-wrap
msgid "Host-based Access Point Without Authentication or Encryption"
msgstr "인증 또는 암호화가 없는 호스트 기반 액세스 포인트"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1208
msgid ""
"Although it is not recommended to run an AP without any authentication or "
"encryption, this is a simple way to check if the AP is working.  This "
"configuration is also important for debugging client issues."
msgstr ""
"인증이나 암호화 없이 AP를 실행하는 것은 권장하지 않지만, AP가 작동하는지 "
"간단하게 확인할 수 있는 방법입니다.  이 구성은 클라이언트 문제를 디버깅하는 "
"데에도 중요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1210
msgid ""
"Once the AP is configured, initiate a scan from another wireless machine to "
"find the AP:"
msgstr "AP가 구성되면 다른 무선 기기에서 스캔을 시작하여 AP를 찾습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1217
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up scan\n"
"SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up scan\n"
"SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1220
msgid "The client machine found the AP and can be associated with it:"
msgstr "클라이언트 컴퓨터가 AP를 발견하여 연결할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1234
#, no-wrap
msgid ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g\n"
"\t  status: associated\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7\n"
"\t  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7\n"
"\t  roam:rate 5 protmode CTS wme burst\n"
msgstr ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu "
"1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g\n"
"\t  status: associated\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7\n"
"\t  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7\n"
"\t  roam:rate 5 protmode CTS wme burst\n"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1237
#, no-wrap
msgid "WPA2 Host-based Access Point"
msgstr "WPA2 호스트 기반 액세스 포인트"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1241
msgid ""
"This section focuses on setting up a FreeBSD access point using the WPA2 "
"security protocol.  More details regarding WPA and the configuration of WPA-"
"based wireless clients can be found in <<network-wireless-wpa>>."
msgstr ""
"이 섹션에서는 WPA2 보안 프로토콜을 사용하여 FreeBSD 액세스 포인트를 설정하는 "
"데 중점을 둡니다.  WPA와 WPA 기반 무선 클라이언트의 구성에 대한 자세한 "
"내용은 <<network-wireless-wpa>>에서 확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1243
msgid ""
"The man:hostapd[8] daemon is used to deal with client authentication and key "
"management on the WPA2-enabled AP."
msgstr "man:hostapd[8] 데몬은 WPA2 지원 AP에서 클라이언트 인증 및 키 관리를 처리하는 "
"데 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1246
msgid ""
"The following configuration operations are performed on the FreeBSD machine "
"acting as the AP.  Once the AP is correctly working, man:hostapd[8] can be "
"automatically started at boot with this line in [.filename]#/etc/rc.conf#:"
msgstr ""
"다음 구성 작업은 AP 역할을 하는 FreeBSD 머신에서 수행됩니다.  AP가 올바르게 "
"작동하면 부팅 시 [.filename]#/etc/rc.conf#에 있는 이 줄을 사용하여 "
"man:hostapd[8]를 자동으로 시작할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1250
#, no-wrap
msgid "hostapd_enable=\"YES\"\n"
msgstr "hostapd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1253
msgid ""
"Before trying to configure man:hostapd[8], first configure the basic "
"settings introduced in <<network-wireless-ap-basic>>."
msgstr ""
"man:hostapd[8]를 구성하기 전에 먼저 <<network-wireless-ap-basic>에 소개된 "
"기본 설정을 구성합니다."

#. type: Title =====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1254
#, no-wrap
msgid "WPA2-PSK"
msgstr "WPA2-PSK"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1257
msgid ""
"WPA2-PSK is intended for small networks where the use of a backend "
"authentication server is not possible or desired."
msgstr "WPA2-PSK는 백엔드 인증 서버를 사용할 수 없거나 원하지 않는 소규모 네트워크를 "
"위한 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1259
msgid "The configuration is done in [.filename]#/etc/hostapd.conf#:"
msgstr "구성은 [.filename]#/etc/hostapd.conf#에서 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1271
#, no-wrap
msgid ""
"interface=wlan0                  <.>\n"
"debug=1                          <.>\n"
"ctrl_interface=/var/run/hostapd  <.>\n"
"ctrl_interface_group=wheel       <.>\n"
"ssid=freebsdap                   <.>\n"
"wpa=2                            <.>\n"
"wpa_passphrase=freebsdmall       <.>\n"
"wpa_key_mgmt=WPA-PSK             <.>\n"
"wpa_pairwise=CCMP                <.>\n"
msgstr ""
"interface=wlan0                  <.>\n"
"debug=1                          <.>\n"
"ctrl_interface=/var/run/hostapd  <.>\n"
"ctrl_interface_group=wheel       <.>\n"
"ssid=freebsdap                   <.>\n"
"wpa=2                            <.>\n"
"wpa_passphrase=freebsdmall       <.>\n"
"wpa_key_mgmt=WPA-PSK             <.>\n"
"wpa_pairwise=CCMP                <.>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1274
msgid "Wireless interface used for the access point."
msgstr "액세스 포인트에 사용되는 무선 인터페이스."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1275
msgid ""
"Level of verbosity used during the execution of man:hostapd[8]. A value of "
"`1` represents the minimal level."
msgstr "man:hostapd[8]를 실행하는 동안 사용되는 상세도 수준입니다. 값이 `1`이면 최소 "
"수준을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1276
msgid ""
"Pathname of the directory used by man:hostapd[8] to store domain socket "
"files for communication with external programs such as man:hostapd_cli[8]. "
"The default value is used in this example."
msgstr ""
"man:hostapd_cli[8]와 같은 외부 프로그램과의 통신을 위해 도메인 소켓 파일을 "
"저장하는 데 man:hostapd[8]가 사용하는 디렉터리의 경로명입니다. 이 예제에서는 "
"기본값이 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1277
msgid "The group allowed to access the control interface files."
msgstr "제어 인터페이스 파일에 액세스할 수 있는 그룹."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1278
msgid "The wireless network name, or SSID, that will appear in wireless scans."
msgstr "무선 스캔에 표시되는 무선 네트워크 이름 또는 SSID입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1279
msgid ""
"Enable WPA and specify which WPA authentication protocol will be required. A "
"value of `2` configures the AP for WPA2 and is recommended. Set to `1` only "
"if the obsolete WPA is required."
msgstr ""
"WPA를 활성화하고 필요한 WPA 인증 프로토콜을 지정합니다. 값이 `2`이면 AP가 "
"WPA2를 사용하도록 구성되며 권장설정입니다. 더 이상 사용되지 않는 WPA가 "
"필요한 경우에만 `1`로 설정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1280
msgid "ASCII passphrase for WPA authentication."
msgstr "WPA 인증용 ASCII 암호 구문."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1281
msgid "The key management protocol to use. This example sets WPA-PSK."
msgstr "사용할 키 관리 프로토콜입니다. 이 예에서는 WPA-PSK를 설정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1282
msgid ""
"Encryption algorithms accepted by the access point. In this example, only "
"the CCMP (AES) cipher is accepted. CCMP is an alternative to TKIP and is "
"strongly preferred when possible. TKIP should be allowed only when there are "
"stations incapable of using CCMP."
msgstr ""
"액세스 포인트에서 허용하는 암호화 알고리즘으로 이 예에서는 CCMP(AES) 암호만 "
"허용됩니다. CCMP는 TKIP의 대안이며 가능한 경우 강력히 권장됩니다. CCMP를 "
"사용할 수 없는 스테이션이 있는 경우에만 TKIP를 허용해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1284
msgid "The next step is to start man:hostapd[8]:"
msgstr "다음 단계는 man:hostapd[8]를 실행하는 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1288
#, no-wrap
msgid "# service hostapd forcestart\n"
msgstr "# service hostapd forcestart\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1305
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"wlan0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\tether 04:f0:21:16:8e:10\n"
"\tinet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9\n"
"\tnd6 options=21<PERFORMNUD,AUTO_LINKLOCAL>\n"
"\tmedia: IEEE 802.11 Wireless Ethernet autoselect mode 11na <hostap>\n"
"\tstatus: running\n"
"\tssid No5ignal channel 36 (5180 MHz 11a ht/40+) bssid 04:f0:21:16:8e:10\n"
"\tcountry US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2\n"
"\tAES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6\n"
"\tscanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst\n"
"\tdtimperiod 1 -dfs\n"
"\tgroups: wlan\n"
msgstr ""
"# ifconfig wlan0\n"
"wlan0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> metric 0 "
"mtu 1500\n"
"\tether 04:f0:21:16:8e:10\n"
"\tinet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9\n"
"\tnd6 options=21<PERFORMNUD,AUTO_LINKLOCAL>\n"
"\tmedia: IEEE 802.11 Wireless Ethernet autoselect mode 11na <hostap>\n"
"\tstatus: running\n"
"\tssid No5ignal channel 36 (5180 MHz 11a ht/40+) bssid 04:f0:21:16:8e:10\n"
"\tcountry US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2\n"
"\tAES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6\n"
"\tscanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst\n"
"\tdtimperiod 1 -dfs\n"
"\tgroups: wlan\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1310
msgid ""
"Once the AP is running, the clients can associate with it.  See <<network-"
"wireless-wpa>> for more details.  It is possible to see the stations "
"associated with the AP using `ifconfig _wlan0_ list sta`."
msgstr ""
"AP가 실행되면 클라이언트가 AP에 연결할 수 있습니다.  자세한 내용은 <<network-"
"wireless-wpa>>을 참조하세요.  `ifconfig _wlan0_ list sta`를 사용하여 AP와 "
"연결된 스테이션을 확인할 수 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1311
#, no-wrap
msgid "WEP Host-based Access Point"
msgstr "WEP 호스트 기반 액세스 포인트"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1315
msgid ""
"It is not recommended to use WEP for setting up an AP since there is no "
"authentication mechanism and the encryption is easily cracked.  Some legacy "
"wireless cards only support WEP and these cards will only support an AP "
"without authentication or encryption."
msgstr ""
"인증 메커니즘이 없고 암호화가 쉽게 해독되므로 AP 설정에 WEP를 사용하는 것은 "
"권장하지 않습니다.  일부 레거시 무선 카드는 WEP만 지원하며 이러한 카드는 "
"인증이나 암호화 없는 AP만 지원합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1317
msgid ""
"The wireless device can now be put into hostap mode and configured with the "
"correct SSID and IP address:"
msgstr "이제 무선 장치를 호스트 모드로 전환하고 올바른 SSID 및 IP 주소로 구성할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1323
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode hostap\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \\\n"
"\tssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0 wlanmode hostap\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \\\n"
"\tssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1326
msgid ""
"The `weptxkey` indicates which WEP key will be used in the transmission. "
"This example uses the third key as key numbering starts with `1`. This "
"parameter must be specified in order to encrypt the data."
msgstr ""
"`weptxkey`는 전송에 사용할 WEP 키를 나타냅니다. 이 예에서는 키 번호가 `1`로 "
"시작하므로 세 번째 키를 사용합니다. 데이터를 암호화하려면 이 매개변수를 "
"지정해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1327
msgid ""
"The `wepkey` sets the selected WEP key. It should be in the format _index:"
"key_. If the index is not given, key `1` is set. The index needs to be set "
"when using keys other than the first key."
msgstr ""
"`wepkey`는 선택한 WEP 키를 설정합니다. _index:key_ 형식이어야 합니다. "
"인덱스가 지정되지 않으면 키 `1`이 설정됩니다. 첫 번째 키가 아닌 다른 키를 "
"사용할 때는 인덱스를 설정해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1329
msgid ""
"Use man:ifconfig[8] to see the status of the [.filename]#wlan0# interface:"
msgstr "man:ifconfig[8]을 사용하여 [.filename]#wlan0# 인터페이스의 상태를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1341
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit\n"
"\t  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs\n"
msgstr ""
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu "
"1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit\n"
"\t  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1344
msgid ""
"From another wireless machine, it is now possible to initiate a scan to find "
"the AP:"
msgstr "이제 다른 무선 기기에서 스캔을 시작하여 AP를 찾을 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1351
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up scan\n"
"SSID            BSSID              CHAN RATE  S:N   INT CAPS\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS\n"
msgstr ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up scan\n"
"SSID            BSSID              CHAN RATE  S:N   INT CAPS\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1355
msgid ""
"In this example, the client machine found the AP and can associate with it "
"using the correct parameters.  See <<network-wireless-wep>> for more details."
msgstr ""
"이 예제에서는 클라이언트 컴퓨터가 AP를 찾았고 올바른 매개변수를 사용하여 "
"AP와 연결할 수 있습니다.  자세한 내용은 <<network-wireless-wep>>을 "
"참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1356
#, no-wrap
msgid "Using Both Wired and Wireless Connections"
msgstr "유선 및 무선 연결 모두 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1360
msgid ""
"A wired connection provides better performance and reliability, while a "
"wireless connection provides flexibility and mobility.  Laptop users "
"typically want to roam seamlessly between the two types of connections."
msgstr ""
"유선 연결은 더 나은 성능과 안정성을 제공하는 반면, 무선 연결은 유연성과 "
"이동성을 제공합니다.  노트북 사용자는 일반적으로 두 가지 유형의 연결 사이를 "
"원활하게 이동하기를 원합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1363
msgid ""
"On FreeBSD, it is possible to combine two or even more network interfaces "
"together in a \"failover\" fashion.  This type of configuration uses the "
"most preferred and available connection from a group of network interfaces, "
"and the operating system switches automatically when the link state changes."
msgstr ""
"FreeBSD에서는 두 개 이상의 네트워크 인터페이스를 \"failover\" 방식으로 "
"결합할 수 있습니다.  이 유형의 구성은 네트워크 인터페이스 그룹에서 가장 "
"선호되고 사용 가능한 연결을 사용하며, 링크 상태가 변경되면 운영 체제가 "
"자동으로 전환됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1365
msgid ""
"Link aggregation and failover is covered in <<network-aggregation>> and an "
"example for using both wired and wireless connections is provided at "
"<<networking-lagg-wired-and-wireless>>."
msgstr ""
"링크 집계 및 장애 조치에 대해서는 <<network-aggregation>>에서 다루고 있으며, "
"유선 및 무선 연결을 모두 사용하는 예제는 <<networking-lagg-wired-and-"
"wireless>>에서 제공됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1369
msgid ""
"This section describes a number of steps to help troubleshoot common "
"wireless networking problems."
msgstr "이 섹션에서는 일반적인 무선 네트워킹 문제를 해결하는 데 도움이 되는 여러 "
"단계에 대해 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1371
msgid ""
"If the access point is not listed when scanning, check that the "
"configuration has not limited the wireless device to a limited set of "
"channels."
msgstr "스캔할 때 액세스 포인트가 나열되지 않으면 구성에서 무선 장치를 한정된 채널 "
"집합으로 제한하지 않았는지 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1372
msgid ""
"If the device cannot associate with an access point, verify that the "
"configuration matches the settings on the access point. This includes the "
"authentication scheme and any security protocols. Simplify the configuration "
"as much as possible. If using a security protocol such as WPA or WEP, "
"configure the access point for open authentication and no security to see if "
"traffic will pass."
msgstr ""
"장치가 액세스 포인트에 연결할 수 없는 경우 구성이 액세스 포인트의 설정과 "
"일치하는지 확인합니다. 여기에는 인증 체계 및 모든 보안 프로토콜이 "
"포함됩니다. 가능한 한 구성을 단순화하세요. WPA 또는 WEP와 같은 보안 "
"프로토콜을 사용하는 경우, 액세스 포인트를 개방형 인증 및 보안 없음으로 "
"구성하여 트래픽이 통과되는지 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1374
msgid ""
"Debugging support is provided by man:wpa_supplicant[8]. Try running this "
"utility manually with `-dd` and look at the system logs."
msgstr ""
"디버깅 지원은 man:wpa_supplicant[8]에서 제공합니다. 이 유틸리티를 `-dd`로 "
"수동 실행하고 시스템 로그를 살펴보세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1375
msgid ""
"Once the system can associate with the access point, diagnose the network "
"configuration using tools like man:ping[8]."
msgstr "시스템이 액세스 포인트에 연결할 수 있으면 man:ping[8]과 같은 도구를 사용하여 "
"네트워크 구성을 진단합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1376
msgid ""
"There are many lower-level debugging tools. Debugging messages can be "
"enabled in the 802.11 protocol support layer using man:wlandebug[8]. For "
"example, to enable console messages related to scanning for access points "
"and the 802.11 protocol handshakes required to arrange communication:"
msgstr ""
"더 낮은 수준의 디버깅 도구가 많이 있습니다. 802.11 프로토콜 지원 계층에서 "
"man:wlandebug[8]를 사용하여 디버깅 메시지를 활성화할 수 있습니다. 예를 들어, "
"액세스 포인트 검색과 관련된 콘솔 메시지 및 통신을 준비하는 데 필요한 802.11 "
"프로토콜 핸드셰이크와 관련된 메시지를 활성화할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1381
#, no-wrap
msgid ""
"# wlandebug -i wlan0 +scan+auth+debug+assoc\n"
"  net.wlan.0.debug: 0 => 0xc80000<assoc,auth,scan>\n"
msgstr ""
"# wlandebug -i wlan0 +scan+auth+debug+assoc\n"
"  net.wlan.0.debug: 0 => 0xc80000<assoc,auth,scan>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1387
msgid ""
"Many useful statistics are maintained by the 802.11 layer and `wlanstats`, "
"found in [.filename]#/usr/src/tools/tools/net80211#, will dump this "
"information.  These statistics should display all errors identified by the "
"802.11 layer.  However, some errors are identified in the device drivers "
"that lie below the 802.11 layer so they may not show up.  To diagnose device-"
"specific problems, refer to the driver documentation."
msgstr ""
"802.11 계층에서 많은 유용한 통계를 유지 관리하며, [.filename]#/usr/src/tools/"
"tools/net80211#에 있는 `wlanstats`가 이 정보를 덤프합니다.  이 통계에는 "
"802.11 계층에서 식별된 모든 오류가 표시되어야 합니다.  그러나 일부 오류는 "
"802.11 계층 아래에 있는 장치 드라이버에서 식별되므로 표시되지 않을 수 "
"있습니다.  디바이스별 문제를 진단하려면 드라이버 설명서를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1389
msgid ""
"If the above information does not help to clarify the problem, submit a "
"problem report and include output from the above tools."
msgstr "위의 정보로 문제를 명확히 파악하는 데 도움이 되지 않는 경우 문제 보고서를 "
"제출하고 위의 도구에서 출력한 내용을 포함하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1391
#, no-wrap
msgid "USB Tethering"
msgstr "USB 테더링"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1395
msgid ""
"Many cellphones provide the option to share their data connection over USB "
"(often called \"tethering\").  This feature uses one of RNDIS, CDC, or a "
"custom Apple(R) iPhone(R)/iPad(R) protocol."
msgstr ""
"대부분의 휴대폰은 USB를 통해 데이터 연결을 공유하는 옵션을 제공합니다("
"\"테더링\"이라고도 함).  이 기능은 RNDIS, CDC 또는 사용자 지정 Apple(R) "
"iPhone(R)/iPad(R) 프로토콜 중 하나를 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1397
msgid "Android(TM) devices generally use the man:urndis[4] driver."
msgstr "Android(TM) 장치는 일반적으로 man:urndis[4] 드라이버를 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1398
msgid "Apple(R) devices use the man:ipheth[4] driver."
msgstr "Apple(R) 장치는 man:ipheth[4] 드라이버를 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1399
msgid "Older devices will often use the man:cdce[4] driver."
msgstr "구형 디바이스에서는 man:cdce[4] 드라이버를 사용하는 경우가 많습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1401
msgid "Before attaching a device, load the appropriate driver into the kernel:"
msgstr "장치를 연결하기 전에 적절한 드라이버를 커널에 로드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1407
#, no-wrap
msgid ""
"# kldload if_urndis\n"
"# kldload if_cdce\n"
"# kldload if_ipheth\n"
msgstr ""
"# kldload if_urndis\n"
"# kldload if_cdce\n"
"# kldload if_ipheth\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1411
msgid ""
"Once the device is attached ``ue``_0_ will be available for use like a "
"normal network device.  Be sure that the \"USB tethering\" option is enabled "
"on the device."
msgstr ""
"장치가 연결되면 ``ue``_0_을 일반 네트워크 장치처럼 사용할 수 있습니다.  "
"장치에서 'USB 테더링' 옵션이 활성화되어 있는지 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1413
msgid ""
"To make this change permanent and load the driver as a module at boot time, "
"place the appropriate line of the following in [.filename]#/boot/loader."
"conf#:"
msgstr ""
"이 변경 사항을 영구적으로 적용하고 부팅 시 드라이버를 모듈로 로드하려면 [."
"filename]#/boot/loader.conf#에 다음 중 적절한 줄을 배치합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1419
#, no-wrap
msgid ""
"if_urndis_load=\"YES\"\n"
"if_cdce_load=\"YES\"\n"
"if_ipheth_load=\"YES\"\n"
msgstr ""
"if_urndis_load=\"YES\"\n"
"if_cdce_load=\"YES\"\n"
"if_ipheth_load=\"YES\"\n"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1422
#, no-wrap
msgid "Bluetooth"
msgstr "블루투스"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1427
msgid ""
"Bluetooth is a wireless technology for creating personal networks operating "
"in the 2.4 GHz unlicensed band, with a range of 10 meters.  Networks are "
"usually formed ad-hoc from portable devices such as cellular phones, "
"handhelds, and laptops.  Unlike Wi-Fi wireless technology, Bluetooth offers "
"higher level service profiles, such as FTP-like file servers, file pushing, "
"voice transport, serial line emulation, and more."
msgstr ""
"블루투스는 2.4GHz 비면허 대역에서 작동하는 10미터 범위의 개인 네트워크를 "
"생성하기 위한 무선 기술입니다.  네트워크는 일반적으로 휴대폰, 핸드헬드, "
"랩톱과 같은 휴대용 장치에서 임시로 형성됩니다.  Wi-Fi 무선 기술과 달리 "
"Bluetooth는 FTP와 같은 파일 서버, 파일 푸시, 음성 전송, 직렬 회선 에뮬레이션 "
"등과 같은 더 높은 수준의 서비스 프로필을 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1430
msgid ""
"This section describes the use of a USB Bluetooth dongle on a FreeBSD "
"system.  It then describes the various Bluetooth protocols and utilities."
msgstr ""
"이 섹션에서는 FreeBSD 시스템에서 USB 블루투스 동글을 사용하는 방법을 "
"설명합니다.  그런 다음 다양한 블루투스 프로토콜과 유틸리티에 대해 설명합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1431
#, no-wrap
msgid "Loading Bluetooth Support"
msgstr "블루투스 지원을 로딩하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1438
msgid ""
"The Bluetooth stack in FreeBSD is implemented using the man:netgraph[4] "
"framework.  A broad variety of Bluetooth USB dongles is supported by man:"
"ng_ubt[4].  Broadcom BCM2033 based Bluetooth devices are supported by the "
"man:ubtbcmfw[4] and man:ng_ubt[4] drivers.  The 3Com Bluetooth PC Card "
"3CRWB60-A is supported by the man:ng_bt3c[4] driver.  Serial and UART based "
"Bluetooth devices are supported by man:sio[4], man:ng_h4[4], and man:"
"hcseriald[8]."
msgstr ""
"FreeBSD의 블루투스 스택은 man:netgraph[4] 프레임워크를 사용하여 구현됩니다.  "
"다양한 블루투스 USB 동글은 man:ng_ubt[4]에 의해 지원됩니다.  브로드컴 "
"BCM2033 기반 블루투스 장치는 man:ubtbcmfw[4] 및 man:ng_ubt[4] 드라이버에 "
"의해 지원됩니다.  3Com Bluetooth PC 카드 3CRWB60-A는 man:ng_bt3c[4] "
"드라이버에 의해 지원됩니다.  직렬 및 UART 기반 블루투스 장치는 man:sio[4], "
"man:ng_h4[4], man:hcseriald[8]에서 지원됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1441
msgid ""
"Before attaching a device, determine which of the above drivers it uses, "
"then load the driver.  For example, if the device uses the man:ng_ubt[4] "
"driver:"
msgstr ""
"장치를 연결하기 전에 위의 드라이버 중 어떤 드라이버를 사용하는지 확인한 다음 "
"해당 드라이버를 로드합니다.  예를 들어 장치가 man:ng_ubt[4] 드라이버를 "
"사용하는 경우:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1445
#, no-wrap
msgid "# kldload ng_ubt\n"
msgstr "# kldload ng_ubt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1448
msgid ""
"If the Bluetooth device will be attached to the system during system "
"startup, the system can be configured to load the module at boot time by "
"adding the driver to [.filename]#/boot/loader.conf#:"
msgstr ""
"시스템 시작 시 Bluetooth 장치가 시스템에 연결되는 경우, [.filename]#/boot/"
"loader.conf#에 드라이버를 추가하여 부팅 시 모듈을 로드하도록 시스템을 구성할 "
"수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1452
#, no-wrap
msgid "ng_ubt_load=\"YES\"\n"
msgstr "ng_ubt_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1456
msgid ""
"Once the driver is loaded, plug in the USB dongle.  If the driver load was "
"successful, output similar to the following should appear on the console and "
"in [.filename]#/var/log/messages#:"
msgstr ""
"드라이버가 로드되면 USB 동글을 연결합니다.  드라이버 로드에 성공하면 콘솔과 ["
".filename]#/var/log/messages#에 다음과 유사한 출력이 나타납니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1463
#, no-wrap
msgid ""
"ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2\n"
"ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2\n"
"ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,\n"
"      wMaxPacketSize=49, nframes=6, buffer size=294\n"
msgstr ""
"ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2\n"
"ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2\n"
"ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,\n"
"      wMaxPacketSize=49, nframes=6, buffer size=294\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1468
msgid ""
"To start and stop the Bluetooth stack, use its startup script. It is a good "
"idea to stop the stack before unplugging the device.  Starting the bluetooth "
"stack might require man:hcsecd[8] to be started.  When starting the stack, "
"the output should be similar to the following:"
msgstr ""
"Bluetooth 스택을 시작 및 중지하려면 시작 스크립트를 사용합니다. 장치의 "
"플러그를 뽑기 전에 스택을 중지하는 것이 좋습니다.  블루투스 스택을 "
"시작하려면 man:hcsecd[8]를 시작해야 할 수 있습니다.  스택을 시작할 때 출력은 "
"다음과 비슷해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1483
#, no-wrap
msgid ""
"# service bluetooth start ubt0\n"
"BD_ADDR: 00:02:72:00:d4:1a\n"
"Features: 0xff 0xff 0xf 00 00 00 00 00\n"
"<3-Slot> <5-Slot> <Encryption> <Slot offset>\n"
"<Timing accuracy> <Switch> <Hold mode> <Sniff mode>\n"
"<Park mode> <RSSI> <Channel quality> <SCO link>\n"
"<HV2 packets> <HV3 packets> <u-law log> <A-law log> <CVSD>\n"
"<Paging scheme> <Power control> <Transparent SCO data>\n"
"Max. ACL packet size: 192 bytes\n"
"Number of ACL packets: 8\n"
"Max. SCO packet size: 64 bytes\n"
"Number of SCO packets: 8\n"
msgstr ""
"# service bluetooth start ubt0\n"
"BD_ADDR: 00:02:72:00:d4:1a\n"
"Features: 0xff 0xff 0xf 00 00 00 00 00\n"
"<3-Slot> <5-Slot> <Encryption> <Slot offset>\n"
"<Timing accuracy> <Switch> <Hold mode> <Sniff mode>\n"
"<Park mode> <RSSI> <Channel quality> <SCO link>\n"
"<HV2 packets> <HV3 packets> <u-law log> <A-law log> <CVSD>\n"
"<Paging scheme> <Power control> <Transparent SCO data>\n"
"Max. ACL packet size: 192 bytes\n"
"Number of ACL packets: 8\n"
"Max. SCO packet size: 64 bytes\n"
"Number of SCO packets: 8\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1485
#, no-wrap
msgid "Finding Other Bluetooth Devices"
msgstr "다른 Bluetooth 장치 찾기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1490
msgid ""
"The Host Controller Interface (HCI) provides a uniform method for accessing "
"Bluetooth baseband capabilities.  In FreeBSD, a netgraph HCI node is created "
"for each Bluetooth device.  For more details, refer to man:ng_hci[4]."
msgstr ""
"호스트 컨트롤러 인터페이스(HCI)는 블루투스 베이스밴드 기능에 액세스하기 위한 "
"통일된 방법을 제공합니다.  FreeBSD에서는 각 블루투스 장치에 대해 netgraph "
"HCI 노드가 생성됩니다.  자세한 내용은 man:ng_hci[4]를 참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1497
msgid ""
"One of the most common tasks is discovery of Bluetooth devices within RF "
"proximity.  This operation is called _inquiry_.  Inquiry and other HCI "
"related operations are done using man:hccontrol[8].  The example below shows "
"how to find out which Bluetooth devices are in range.  The list of devices "
"should be displayed in a few seconds.  Note that a remote device will only "
"answer the inquiry if it is set to _discoverable_ mode."
msgstr ""
"가장 일반적인 작업 중 하나는 RF 근접 거리 내에서 Bluetooth 장치를 검색하는 "
"것입니다.  이 작업을 _inquiry_라고 합니다.  조회 및 기타 HCI 관련 작업은 "
"man:hccontrol[8]을 사용하여 수행됩니다.  아래 예는 범위 내에 있는 블루투스 "
"장치를 찾는 방법을 보여줍니다.  몇 초 후에 장치 목록이 표시됩니다.  원격 "
"장치가 _discoverable_ 모드로 설정된 경우에만 문의에 응답한다는 점에 "
"유의하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1510
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci inquiry\n"
"Inquiry result, num_responses=1\n"
"Inquiry result #0\n"
"       BD_ADDR: 00:80:37:29:19:a4\n"
"       Page Scan Rep. Mode: 0x1\n"
"       Page Scan Period Mode: 00\n"
"       Page Scan Mode: 00\n"
"       Class: 52:02:04\n"
"       Clock offset: 0x78ef\n"
"Inquiry complete. Status: No error [00]\n"
msgstr ""
"% hccontrol -n ubt0hci inquiry\n"
"Inquiry result, num_responses=1\n"
"Inquiry result #0\n"
"       BD_ADDR: 00:80:37:29:19:a4\n"
"       Page Scan Rep. Mode: 0x1\n"
"       Page Scan Period Mode: 00\n"
"       Page Scan Mode: 00\n"
"       Class: 52:02:04\n"
"       Clock offset: 0x78ef\n"
"Inquiry complete. Status: No error [00]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1516
msgid ""
"The `BD_ADDR` is the unique address of a Bluetooth device, similar to the "
"MAC address of a network card.  This address is needed for further "
"communication with a device and it is possible to assign a human readable "
"name to a `BD_ADDR`.  Information regarding the known Bluetooth hosts is "
"contained in [.filename]#/etc/bluetooth/hosts#.  The following example shows "
"how to obtain the human readable name that was assigned to the remote device:"
msgstr ""
"`BD_ADDR`은 네트워크 카드의 MAC 주소와 유사한 블루투스 장치의 고유 "
"주소입니다.  이 주소는 장치와의 추가 통신에 필요하며 사람이 읽을 수 있는 "
"이름을 `BD_ADDR`에 할당할 수 있습니다.  알려진 블루투스 호스트에 관한 정보는 "
"[.filename]#/etc/bluetooth/hosts#에 포함되어 있습니다.  다음 예는 원격 "
"장치에 할당된 사람이 읽을 수 있는 이름을 얻는 방법을 보여줍니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1522
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4\n"
"BD_ADDR: 00:80:37:29:19:a4\n"
"Name: Pav's T39\n"
msgstr ""
"% hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4\n"
"BD_ADDR: 00:80:37:29:19:a4\n"
"Name: Pav's T39\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1526
msgid ""
"If an inquiry is performed on a remote Bluetooth device, it will find the "
"computer as \"your.host.name (ubt0)\".  The name assigned to the local "
"device can be changed at any time."
msgstr ""
"원격 Bluetooth 장치에서 조회를 수행하면 해당 컴퓨터가 \"your.host.name (ubt0)"
"\"으로 검색됩니다.  로컬 장치에 할당된 이름은 언제든지 변경할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1529
msgid ""
"Remote devices can be assigned aliases in [.filename]#/etc/bluetooth/"
"hosts#.  More information about [.filename]#/etc/bluetooth/hosts# file might "
"be found in man:bluetooth.hosts[5]."
msgstr ""
"원격 장치에 별칭을 지정할 수 있는 위치는 [.filename]#/etc/bluetooth/hosts#"
"입니다.  [.filename]#/etc/bluetooth/hosts# 파일에 대한 자세한 정보는 "
"man:bluetooth.hosts[5]에서 확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1532
msgid ""
"The Bluetooth system provides a point-to-point connection between two "
"Bluetooth units, or a point-to-multipoint connection which is shared among "
"several Bluetooth devices.  The following example shows how to create a "
"connection to a remote device:"
msgstr ""
"블루투스 시스템은 두 개의 블루투스 장치 간의 지점 간 연결 또는 여러 블루투스 "
"장치 간에 공유되는 지점 간 다중 지점 연결을 제공합니다.  다음 예는 원격 "
"장치에 대한 연결을 만드는 방법을 보여줍니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1536
#, no-wrap
msgid "% hccontrol -n ubt0hci create_connection BT_ADDR\n"
msgstr "% hccontrol -n ubt0hci create_connection BT_ADDR\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1539
msgid ""
"`create_connection` accepts `BT_ADDR` as well as host aliases in [."
"filename]#/etc/bluetooth/hosts#."
msgstr ""
"`create_connection`은 `BT_ADDR`과 [.filename]#/etc/bluetooth/hosts#의 호스트 "
"별칭을 허용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1541
msgid ""
"The following example shows how to obtain the list of active baseband "
"connections for the local device:"
msgstr "다음 예는 로컬 디바이스에 대한 활성 베이스밴드 연결 목록을 가져오는 방법을 "
"보여줍니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1547
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci read_connection_list\n"
"Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State\n"
"00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN\n"
msgstr ""
"% hccontrol -n ubt0hci read_connection_list\n"
"Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State\n"
"00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1551
msgid ""
"A _connection handle_ is useful when termination of the baseband connection "
"is required, though it is normally not required to do this by hand.  The "
"stack will automatically terminate inactive baseband connections."
msgstr ""
"_connection handle_은 베이스밴드 연결을 종료해야 할 때 유용하지만, "
"일반적으로는 직접 종료할 필요는 없습니다.  스택은 비활성 베이스밴드 연결을 "
"자동으로 종료합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1557
#, no-wrap
msgid ""
"# hccontrol -n ubt0hci disconnect 41\n"
"Connection handle: 41\n"
"Reason: Connection terminated by local host [0x16]\n"
msgstr ""
"# hccontrol -n ubt0hci disconnect 41\n"
"Connection handle: 41\n"
"Reason: Connection terminated by local host [0x16]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1561
msgid ""
"Type `hccontrol help` for a complete listing of available HCI commands.  "
"Most of the HCI commands do not require superuser privileges."
msgstr ""
"사용 가능한 HCI 명령의 전체 목록을 보려면 `hccontrol help`를 입력하세요.  "
"대부분의 HCI 명령에는 수퍼유저 권한이 필요하지 않습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1562
#, no-wrap
msgid "Device Pairing"
msgstr "디바이스 페어링"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1573
msgid ""
"By default, Bluetooth communication is not authenticated, and any device can "
"talk to any other device.  A Bluetooth device, such as a cellular phone, may "
"choose to require authentication to provide a particular service.  Bluetooth "
"authentication is normally done with a _PIN code_, an ASCII string up to 16 "
"characters in length.  The user is required to enter the same PIN code on "
"both devices.  Once the user has entered the PIN code, both devices will "
"generate a _link key_.  After that, the link key can be stored either in the "
"devices or in a persistent storage.  Next time, both devices will use the "
"previously generated link key.  This procedure is called _pairing_.  Note "
"that if the link key is lost by either device, the pairing must be repeated."
msgstr ""
"기본적으로 Bluetooth 통신은 인증되지 않으며, 어떤 장치든 다른 장치와 통신할 "
"수 있습니다.  휴대폰과 같은 블루투스 장치는 특정 서비스를 제공하기 위해 "
"인증이 필요하도록 선택할 수 있습니다.  블루투스 인증은 일반적으로 최대 16자 "
"길이의 아스키 문자열인 _PIN 코드_를 사용하여 수행됩니다.  사용자는 두 장치에 "
"동일한 PIN 코드를 입력해야 합니다.  사용자가 PIN 코드를 입력하면 두 장치 "
"모두 _link key_를 생성합니다.  그 후 링크 키는 장치 또는 영구 저장소에 "
"저장할 수 있습니다.  다음 번에는 두 장치 모두 이전에 생성된 링크 키를 "
"사용합니다.  이 절차를 _페어링_이라고 합니다.  어느 한 쪽 장치에서 링크 키를 "
"분실하면 페어링을 반복해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1577
msgid ""
"The man:hcsecd[8] daemon is responsible for handling Bluetooth "
"authentication requests.  The default configuration file is [.filename]#/etc/"
"bluetooth/hcsecd.conf#.  An example section for a cellular phone with the "
"PIN code set to `1234` is shown below:"
msgstr ""
"man:hcsecd[8] 데몬은 블루투스 인증 요청 처리를 담당합니다.  기본 구성 파일은 "
"[.filename]#/etc/bluetooth/hcsecd.conf#입니다.  PIN 코드가 `1234`로 설정된 "
"휴대폰에 대한 예제 섹션은 아래와 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1586
#, no-wrap
msgid ""
"device {\n"
"        bdaddr  00:80:37:29:19:a4;\n"
"        name    \"Pav's T39\";\n"
"        key     nokey;\n"
"        pin     \"1234\";\n"
"      }\n"
msgstr ""
"device {\n"
"        bdaddr  00:80:37:29:19:a4;\n"
"        name    \"Pav's T39\";\n"
"        key     nokey;\n"
"        pin     \"1234\";\n"
"      }\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1596
msgid ""
"The only limitation on PIN codes is length.  Some devices, such as Bluetooth "
"headsets, may have a fixed PIN code built in.  The `-d` switch forces man:"
"hcsecd[8] to stay in the foreground, so it is easy to see what is "
"happening.  Set the remote device to receive pairing and initiate the "
"Bluetooth connection to the remote device.  The remote device should "
"indicate that pairing was accepted and request the PIN code.  Enter the same "
"PIN code listed in [.filename]#hcsecd.conf#.  Now the computer and the "
"remote device are paired.  Alternatively, pairing can be initiated on the "
"remote device."
msgstr ""
"PIN 코드에 대한 유일한 제한은 길이입니다.  블루투스 헤드셋과 같은 일부 "
"장치에는 고정 PIN 코드가 내장되어 있을 수 있습니다.  `-d` 스위치를 사용하면 "
"man:hcsecd[8]가 전면에 표시되므로 무슨 일이 일어나고 있는지 쉽게 확인할 수 "
"있습니다.  원격 장치가 페어링을 수신하도록 설정하고 원격 장치에 대한 "
"블루투스 연결을 시작합니다.  원격 장치에서 페어링이 수락되었음을 표시하고 "
"PIN 코드를 요청해야 합니다.  [.filename]#hcsecd.conf#에 나열된 것과 동일한 "
"PIN 코드를 입력합니다.  이제 컴퓨터와 원격 장치가 페어링되었습니다.  또는 "
"원격 장치에서 페어링을 시작할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1598
msgid ""
"The following line can be added to [.filename]#/etc/rc.conf# to configure "
"man:hcsecd[8] to start automatically on system start:"
msgstr ""
"다음 줄을 [.filename]#/etc/rc.conf#에 추가하여 시스템 시작 시 man:hcsecd[8]"
"가 자동으로 시작되도록 구성할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1602
#, no-wrap
msgid "hcsecd_enable=\"YES\"\n"
msgstr "hcsecd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1605
msgid "The following is a sample of the man:hcsecd[8] daemon output:"
msgstr "다음은 man:hcsecd[8] 데몬 출력의 샘플입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1614
#, no-wrap
msgid ""
"hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist\n"
"hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists\n"
"hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4\n"
msgstr ""
"hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr "
"0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name "
"'Pav's T39', link key doesn't exist\n"
"hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote "
"bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr "
"0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name "
"'Pav's T39', PIN code exists\n"
"hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr "
"0:80:37:29:19:a4\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1616
#, no-wrap
msgid "Network Access with PPP Profiles"
msgstr "PPP 프로필을 통한 네트워크 액세스"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1620
msgid ""
"A Dial-Up Networking (DUN) profile can be used to configure a cellular phone "
"as a wireless modem for connecting to a dial-up Internet access server.  It "
"can also be used to configure a computer to receive data calls from a "
"cellular phone."
msgstr ""
"전화 접속 네트워킹(DUN) 프로필을 사용하여 휴대폰을 전화 접속 인터넷 액세스 "
"서버에 연결하기 위한 무선 모뎀으로 구성할 수 있습니다.  또한 휴대폰에서 "
"데이터 전화를 수신하도록 컴퓨터를 구성하는 데 사용할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1623
msgid ""
"Network access with a PPP profile can be used to provide LAN access for a "
"single Bluetooth device or multiple Bluetooth devices.  It can also provide "
"PC to PC connection using PPP networking over serial cable emulation."
msgstr ""
"PPP 프로필을 통한 네트워크 액세스는 단일 Bluetooth 장치 또는 여러 Bluetooth "
"장치에 대한 LAN 액세스를 제공하는 데 사용할 수 있습니다.  또한 직렬 케이블 "
"에뮬레이션을 통해 PPP 네트워킹을 사용하여 PC 간 연결을 제공할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1627
msgid ""
"In FreeBSD, these profiles are implemented with man:ppp[8] and the man:"
"rfcomm_pppd[8] wrapper which converts a Bluetooth connection into something "
"PPP can use.  Before a profile can be used, a new PPP label must be created "
"in [.filename]#/etc/ppp/ppp.conf#.  Consult man:rfcomm_pppd[8] for examples."
msgstr ""
"FreeBSD에서, 이러한 프로파일은 블루투스 연결을 PPP가 사용할 수 있는 것으로 "
"변환하는 man:ppp[8] 및 man:rfcomm_pppd[8] 래퍼를 사용하여 구현됩니다.  "
"프로파일을 사용하려면 [.filename]#/etc/ppp/ppp.conf#에 새 PPP 레이블을 "
"만들어야 합니다.  예제는 man:rfcomm_pppd[8]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1629
msgid ""
"In this example, man:rfcomm_pppd[8] is used to open a connection to a remote "
"device with a `BD_ADDR` of `00:80:37:29:19:a4` on a DUNRFCOMM channel:"
msgstr ""
"이 예제에서는 man:rfcomm_pppd[8]을 사용하여 `BD_ADDR`이 `00:80:37:29:19:a4`"
"인 DUNRFCOMM 채널에서 원격 장치에 대한 연결을 엽니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1633
#, no-wrap
msgid "# rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup\n"
msgstr "# rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1638
msgid ""
"The actual channel number will be obtained from the remote device using the "
"SDP protocol.  It is possible to specify the RFCOMM channel by hand, and in "
"this case man:rfcomm_pppd[8] will not perform the SDP query.  Use man:"
"sdpcontrol[8] to find out the RFCOMM channel on the remote device."
msgstr ""
"실제 채널 번호는 SDP 프로토콜을 사용하여 원격 장치에서 얻습니다.  수동으로 "
"RFCOMM 채널을 지정할 수 있으며, 이 경우 man:rfcomm_pppd[8]는 SDP 쿼리를 "
"수행하지 않습니다.  원격 장치에서 RFCOMM 채널을 찾으려면 man:sdpcontrol[8]을 "
"사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1644
msgid ""
"In order to provide network access with the PPPLAN service, man:sdpd[8] must "
"be running and a new entry for LAN clients must be created in [.filename]#/"
"etc/ppp/ppp.conf#.  Consult man:rfcomm_pppd[8] for examples.  Finally, start "
"the RFCOMMPPP server on a valid RFCOMM channel number.  The RFCOMMPPP server "
"will automatically register the Bluetooth LAN service with the local SDP "
"daemon.  The example below shows how to start the RFCOMMPPP server."
msgstr ""
"PPPLAN 서비스로 네트워크 액세스를 제공하려면 man:sdpd[8]가 실행 중이어야 "
"하고 [.filename]#/etc/ppp/ppp.conf#에 LAN 클라이언트를 위한 새 항목을 "
"만들어야 합니다.  예제는 man:rfcomm_pppd[8]을 참조하세요.  마지막으로, "
"유효한 RFCOMM 채널 번호에서 RFCOMMPPP 서버를 시작합니다.  RFCOMMPPP 서버는 "
"로컬 SDP 데몬에 블루투스 LAN 서비스를 자동으로 등록합니다.  아래 예제는 "
"RFCOMMPPP 서버를 시작하는 방법을 보여줍니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1648
#, no-wrap
msgid "# rfcomm_pppd -s -C 7 -l rfcomm-server\n"
msgstr "# rfcomm_pppd -s -C 7 -l rfcomm-server\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1650
#, no-wrap
msgid "Bluetooth Protocols"
msgstr "블루투스 프로토콜"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1653
msgid ""
"This section provides an overview of the various Bluetooth protocols, their "
"function, and associated utilities."
msgstr "이 섹션에서는 다양한 Bluetooth 프로토콜, 해당 기능 및 관련 유틸리티에 대한 "
"개요를 제공합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1654
#, no-wrap
msgid "Logical Link Control and Adaptation Protocol (L2CAP)"
msgstr ""
"논리적 링크 제어 및 적응 프로토콜(Logical Link Control and Adaptation "
"Protocol, L2CAP)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1658
msgid ""
"The Logical Link Control and Adaptation Protocol (L2CAP) provides connection-"
"oriented and connectionless data services to upper layer protocols.  L2CAP "
"permits higher level protocols and applications to transmit and receive "
"L2CAP data packets up to 64 kilobytes in length."
msgstr ""
"L2CAP(Logical Link Control and Adaptation Protocol)은 상위 계층 프로토콜에 "
"연결 지향적이고 연결이 필요 없는 데이터 서비스를 제공합니다.  L2CAP를 "
"사용하면 상위 계층 프로토콜과 애플리케이션이 최대 64킬로바이트 길이의 L2CAP "
"데이터 패킷을 송수신할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1664
msgid ""
"L2CAP is based around the concept of _channels_.  A channel is a logical "
"connection on top of a baseband connection, where each channel is bound to a "
"single protocol in a many-to-one fashion.  Multiple channels can be bound to "
"the same protocol, but a channel cannot be bound to multiple protocols.  "
"Each L2CAP packet received on a channel is directed to the appropriate "
"higher level protocol.  Multiple channels can share the same baseband "
"connection."
msgstr ""
"L2CAP은 _채널_이라는 개념을 기반으로 합니다.  채널은 베이스밴드 연결 위에 "
"있는 논리적 연결로, 각 채널은 다대일 방식으로 단일 프로토콜에 바인딩됩니다.  "
"여러 채널이 동일한 프로토콜에 바인딩될 수는 있지만, 하나의 채널이 여러 "
"프로토콜에 바인딩될 수는 없습니다.  채널에서 수신되는 각 L2CAP 패킷은 적절한 "
"상위 레벨 프로토콜로 전달됩니다.  여러 채널이 동일한 베이스밴드 연결을 "
"공유할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1669
msgid ""
"In FreeBSD, a netgraph L2CAP node is created for each Bluetooth device.  "
"This node is normally connected to the downstream Bluetooth HCI node and "
"upstream Bluetooth socket nodes.  The default name for the L2CAP node is "
"\"devicel2cap\".  For more details refer to man:ng_l2cap[4]."
msgstr ""
"FreeBSD에서는 각 블루투스 장치에 대해 netgraph L2CAP 노드가 생성됩니다.  이 "
"노드는 일반적으로 다운스트림 블루투스 HCI 노드 및 업스트림 블루투스 소켓 "
"노드에 연결됩니다.  L2CAP 노드의 기본 이름은 \"devicel2cap\"입니다.  자세한 "
"내용은 man:ng_l2cap[4]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1672
msgid ""
"A useful command is man:l2ping[8], which can be used to ping other devices.  "
"Some Bluetooth implementations might not return all of the data sent to "
"them, so `0 bytes` in the following example is normal."
msgstr ""
"유용한 명령은 man:l2ping[8]으로, 다른 장치를 핑하는 데 사용할 수 있습니다.  "
"일부 블루투스 구현은 전송된 모든 데이터를 반환하지 않을 수 있으므로 다음 "
"예제에서 `0 bytes`는 정상입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1680
#, no-wrap
msgid ""
"# l2ping -a 00:80:37:29:19:a4\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0\n"
msgstr ""
"# l2ping -a 00:80:37:29:19:a4\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1684
msgid ""
"The man:l2control[8] utility is used to perform various operations on L2CAP "
"nodes.  This example shows how to obtain the list of logical connections "
"(channels) and the list of baseband connections for the local device:"
msgstr ""
"man:l2control[8] 유틸리티는 L2CAP 노드에서 다양한 작업을 수행하는 데 "
"사용됩니다.  이 예는 로컬 장치에 대한 논리적 연결(채널) 목록과 베이스밴드 "
"연결 목록을 가져오는 방법을 보여줍니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1695
#, no-wrap
msgid ""
"% l2control -a 00:02:72:00:d4:1a read_channel_list\n"
"L2CAP channels:\n"
"Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State\n"
"00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN\n"
"% l2control -a 00:02:72:00:d4:1a read_connection_list\n"
"L2CAP connections:\n"
"Remote BD_ADDR    Handle Flags Pending State\n"
"00:07:e0:00:0b:ca     41 O           0 OPEN\n"
msgstr ""
"% l2control -a 00:02:72:00:d4:1a read_channel_list\n"
"L2CAP channels:\n"
"Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State\n"
"00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN\n"
"% l2control -a 00:02:72:00:d4:1a read_connection_list\n"
"L2CAP connections:\n"
"Remote BD_ADDR    Handle Flags Pending State\n"
"00:07:e0:00:0b:ca     41 O           0 OPEN\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1700
msgid ""
"Another diagnostic tool is man:btsockstat[1].  It is similar to man:"
"netstat[1], but for Bluetooth network-related data structures.  The example "
"below shows the same logical connection as man:l2control[8] above."
msgstr ""
"또 다른 진단 도구는 man:btsockstat[1]입니다.  man:netstat[1]과 유사하지만 "
"블루투스 네트워크 관련 데이터 구조에 대한 것입니다.  아래 예는 위의 "
"man:l2control[8]과 동일한 논리적 연결을 보여줍니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1713
#, no-wrap
msgid ""
"% btsockstat\n"
"Active L2CAP sockets\n"
"PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State\n"
"c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN\n"
"Active RFCOMM sessions\n"
"L2PCB    PCB      Flag MTU   Out-Q DLCs State\n"
"c2afe900 c2b53380 1    127   0     Yes  OPEN\n"
"Active RFCOMM sockets\n"
"PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State\n"
"c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN\n"
msgstr ""
"% btsockstat\n"
"Active L2CAP sockets\n"
"PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   "
"State\n"
"c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN\n"
"Active RFCOMM sessions\n"
"L2PCB    PCB      Flag MTU   Out-Q DLCs State\n"
"c2afe900 c2b53380 1    127   0     Yes  OPEN\n"
"Active RFCOMM sockets\n"
"PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State\n"
"c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN\n"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1715
#, no-wrap
msgid "Radio Frequency Communication (RFCOMM)"
msgstr "무선 주파수 통신(RFCOMM)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1720
msgid ""
"The RFCOMM protocol provides emulation of serial ports over the L2CAP "
"protocol.  RFCOMM is a simple transport protocol, with additional provisions "
"for emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports.  It "
"supports up to 60 simultaneous connections (RFCOMM channels) between two "
"Bluetooth devices."
msgstr ""
"RFCOMM 프로토콜은 L2CAP 프로토콜을 통해 직렬 포트 에뮬레이션을 제공합니다.  "
"RFCOMM은 간단한 전송 프로토콜로, RS-232(EIATIA-232-E) 직렬 포트의 9개 회로를 "
"에뮬레이션하기 위한 추가 조항이 있습니다.  두 개의 Bluetooth 장치 간에 최대 "
"60개의 동시 연결(RFCOMM 채널)을 지원합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1724
msgid ""
"For the purposes of RFCOMM, a complete communication path involves two "
"applications running on the communication endpoints with a communication "
"segment between them.  RFCOMM is intended to cover applications that make "
"use of the serial ports of the devices in which they reside.  The "
"communication segment is a direct connect Bluetooth link from one device to "
"another."
msgstr ""
"RFCOMM의 목적상, 완전한 통신 경로에는 통신 엔드포인트에서 실행되는 두 개의 "
"애플리케이션과 그 사이에 통신 세그먼트가 포함됩니다.  RFCOMM은 해당 "
"애플리케이션이 상주하는 장치의 직렬 포트를 사용하는 애플리케이션을 다루기 "
"위한 것입니다.  통신 세그먼트는 한 장치에서 다른 장치로 직접 연결되는 "
"Bluetooth 링크입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1727
msgid ""
"RFCOMM is only concerned with the connection between the devices in the "
"direct connect case, or between the device and a modem in the network case.  "
"RFCOMM can support other configurations, such as modules that communicate "
"via Bluetooth wireless technology on one side and provide a wired interface "
"on the other side."
msgstr ""
"RFCOMM은 직접 연결 케이스의 장치 간 연결 또는 네트워크 케이스의 장치와 모뎀 "
"간 연결에만 관련됩니다.  RFCOMM은 한쪽에서는 블루투스 무선 기술을 통해 "
"통신하고 다른 쪽에서는 유선 인터페이스를 제공하는 모듈과 같은 다른 구성을 "
"지원할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1729
msgid "In FreeBSD, RFCOMM is implemented at the Bluetooth sockets layer."
msgstr "FreeBSD에서 RFCOMM은 블루투스 소켓 계층에서 구현됩니다."

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1730
#, no-wrap
msgid "Service Discovery Protocol (SDP)"
msgstr "서비스 검색 프로토콜 (Service Discovery Protocol, SDP)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1734
msgid ""
"The Service Discovery Protocol (SDP) provides the means for client "
"applications to discover the existence of services provided by server "
"applications as well as the attributes of those services.  The attributes of "
"a service include the type or class of service offered and the mechanism or "
"protocol information needed to utilize the service."
msgstr ""
"서비스 검색 프로토콜(SDP)은 클라이언트 애플리케이션이 서버 애플리케이션이 "
"제공하는 서비스의 존재와 해당 서비스의 속성을 검색할 수 있는 수단을 "
"제공합니다.  서비스의 속성에는 제공되는 서비스의 유형 또는 클래스, 서비스를 "
"활용하는 데 필요한 메커니즘 또는 프로토콜 정보가 포함됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1741
msgid ""
"SDP involves communication between a SDP server and a SDP client.  The "
"server maintains a list of service records that describe the characteristics "
"of services associated with the server.  Each service record contains "
"information about a single service.  A client may retrieve information from "
"a service record maintained by the SDP server by issuing a SDP request.  If "
"the client, or an application associated with the client, decides to use a "
"service, it must open a separate connection to the service provider in order "
"to utilize the service.  SDP provides a mechanism for discovering services "
"and their attributes, but it does not provide a mechanism for utilizing "
"those services."
msgstr ""
"SDP는 SDP 서버와 SDP 클라이언트 간의 통신을 포함합니다.  서버는 서버와 "
"관련된 서비스의 특성을 설명하는 서비스 레코드 목록을 유지 관리합니다.  각 "
"서비스 레코드에는 단일 서비스에 대한 정보가 포함되어 있습니다.  클라이언트는 "
"SDP 요청을 실행하여 SDP 서버가 유지 관리하는 서비스 레코드에서 정보를 검색할 "
"수 있습니다.  클라이언트 또는 클라이언트와 연결된 애플리케이션이 서비스를 "
"이용하고자 하는 경우, 해당 서비스를 이용하기 위해서는 서비스 제공업체에 "
"별도의 연결을 개설해야 합니다.  SDP는 서비스 및 해당 속성을 검색하는 "
"메커니즘을 제공하지만 해당 서비스를 활용하는 메커니즘은 제공하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1745
msgid ""
"Normally, a SDP client searches for services based on some desired "
"characteristics of the services.  However, there are times when it is "
"desirable to discover which types of services are described by an SDP "
"server's service records without any prior information about the services.  "
"This process of looking for any offered services is called _browsing_."
msgstr ""
"일반적으로 SDP 클라이언트는 원하는 서비스 특성을 기반으로 서비스를 "
"검색합니다.  그러나 서비스에 대한 사전 정보 없이 SDP 서버의 서비스 레코드에 "
"기술된 서비스 유형을 검색하는 것이 바람직한 경우가 있습니다.  제공되는 "
"서비스를 찾는 이 과정을 _브라우징_이라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1748
msgid ""
"The Bluetooth SDP server, man:sdpd[8], and command line client, man:"
"sdpcontrol[8], are included in the standard FreeBSD installation.  The "
"following example shows how to perform a SDP browse query."
msgstr ""
"블루투스 SDP 서버인 man:sdpd[8]와 명령줄 클라이언트인 man:sdpcontrol[8]은 "
"표준 FreeBSD 설치에 포함되어 있습니다.  다음 예제는 SDP 찾아보기 쿼리를 "
"수행하는 방법을 보여줍니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1759
#, no-wrap
msgid ""
"% sdpcontrol -a 00:01:03:fc:6e:ec browse\n"
"Record Handle: 00000000\n"
"Service Class ID List:\n"
"        Service Discovery Server (0x1000)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"                Protocol specific parameter #1: u/int/uuid16 1\n"
"                Protocol specific parameter #2: u/int/uuid16 1\n"
msgstr ""
"% sdpcontrol -a 00:01:03:fc:6e:ec browse\n"
"Record Handle: 00000000\n"
"Service Class ID List:\n"
"        Service Discovery Server (0x1000)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"                Protocol specific parameter #1: u/int/uuid16 1\n"
"                Protocol specific parameter #2: u/int/uuid16 1\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1763
#, no-wrap
msgid ""
"Record Handle: 0x00000001\n"
"Service Class ID List:\n"
"        Browse Group Descriptor (0x1001)\n"
msgstr ""
"Record Handle: 0x00000001\n"
"Service Class ID List:\n"
"        Browse Group Descriptor (0x1001)\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1773
#, no-wrap
msgid ""
"Record Handle: 0x00000002\n"
"Service Class ID List:\n"
"        LAN Access Using PPP (0x1102)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"        RFCOMM (0x0003)\n"
"                Protocol specific parameter #1: u/int8/bool 1\n"
"Bluetooth Profile Descriptor List:\n"
"        LAN Access Using PPP (0x1102) ver. 1.0\n"
msgstr ""
"Record Handle: 0x00000002\n"
"Service Class ID List:\n"
"        LAN Access Using PPP (0x1102)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"        RFCOMM (0x0003)\n"
"                Protocol specific parameter #1: u/int8/bool 1\n"
"Bluetooth Profile Descriptor List:\n"
"        LAN Access Using PPP (0x1102) ver. 1.0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1780
msgid ""
"Note that each service has a list of attributes, such as the RFCOMM "
"channel.  Depending on the service, the user might need to make note of some "
"of the attributes.  Some Bluetooth implementations do not support service "
"browsing and may return an empty list.  In this case, it is possible to "
"search for the specific service.  The example below shows how to search for "
"the OBEX Object Push (OPUSH) service:"
msgstr ""
"각 서비스에는 RFCOMM 채널과 같은 속성 목록이 있다는 점에 유의하세요.  "
"서비스에 따라 사용자가 일부 속성을 메모해 두어야 할 수도 있습니다.  일부 "
"블루투스 구현은 서비스 검색을 지원하지 않으며 빈 목록을 반환할 수 있습니다.  "
"이 경우 특정 서비스를 검색할 수 있습니다.  아래 예는 OBEX 객체 푸시(OPUSH) "
"서비스를 검색하는 방법을 보여줍니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1784
#, no-wrap
msgid "% sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH\n"
msgstr "% sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1788
msgid ""
"Offering services on FreeBSD to Bluetooth clients is done with the man:"
"sdpd[8] server.  The following line can be added to [.filename]#/etc/rc."
"conf#:"
msgstr ""
"FreeBSD에서 블루투스 클라이언트에 서비스를 제공하는 것은 man:sdpd[8] 서버를 "
"사용하여 수행합니다.  다음 줄을 [.filename]#/etc/rc.conf#에 추가할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1792
#, no-wrap
msgid "sdpd_enable=\"YES\"\n"
msgstr "sdpd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1795
msgid "Then the man:sdpd[8] daemon can be started with:"
msgstr "이제 다음 명령으로 man:sdpd[8] 데몬을 시작할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1799
#, no-wrap
msgid "# service sdpd start\n"
msgstr "# service sdpd start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1804
msgid ""
"The local server application that wants to provide a Bluetooth service to "
"remote clients will register the service with the local SDP daemon.  An "
"example of such an application is man:rfcomm_pppd[8].  Once started, it will "
"register the Bluetooth LAN service with the local SDP daemon."
msgstr ""
"원격 클라이언트에 블루투스 서비스를 제공하려는 로컬 서버 애플리케이션은 로컬 "
"SDP 데몬에 서비스를 등록합니다.  이러한 애플리케이션의 예는 "
"man:rfcomm_pppd[8]입니다.  일단 시작되면 로컬 SDP 데몬에 블루투스 LAN "
"서비스를 등록합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1806
msgid ""
"The list of services registered with the local SDP server can be obtained by "
"issuing a SDP browse query via the local control channel:"
msgstr "로컬 SDP 서버에 등록된 서비스 목록은 로컬 제어 채널을 통해 SDP 찾아보기 "
"쿼리를 실행하여 얻을 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1810
#, no-wrap
msgid "# sdpcontrol -l browse\n"
msgstr "# sdpcontrol -l browse\n"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1812
#, no-wrap
msgid "OBEX Object Push (OPUSH)"
msgstr "OBEX Object Push (OPUSH)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1816
msgid ""
"Object Exchange (OBEX) is a widely used protocol for simple file transfers "
"between mobile devices.  Its main use is in infrared communication, where it "
"is used for generic file transfers between notebooks or PDAs, and for "
"sending business cards or calendar entries between cellular phones and other "
"devices with Personal Information Manager (PIM) applications."
msgstr ""
"OBEX(Object Exchange)는 모바일 장치 간의 간단한 파일 전송을 위해 널리 "
"사용되는 프로토콜입니다.  주로 적외선 통신에 사용되며, 노트북이나 PDA 간의 "
"일반적인 파일 전송과 개인 정보 관리자(PIM) 애플리케이션이 설치된 휴대폰과 "
"기타 장치 간에 명함이나 캘린더 항목을 전송하는 데 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1818
msgid ""
"The OBEX server and client are implemented by obexapp, which can be "
"installed using the package:comms/obexapp[] package or port."
msgstr ""
"OBEX 서버와 클라이언트는 obexapp에 의해 구현되며, package:comms/obexapp[] "
"패키지 또는 포트를 사용하여 설치할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1826
msgid ""
"The OBEX client is used to push and/or pull objects from the OBEX server.  "
"An example object is a business card or an appointment.  The OBEX client can "
"obtain the RFCOMM channel number from the remote device via SDP.  This can "
"be done by specifying the service name instead of the RFCOMM channel "
"number.  Supported service names are: `IrMC`, `FTRN`, and `OPUSH`.  It is "
"also possible to specify the RFCOMM channel as a number.  Below is an "
"example of an OBEX session where the device information object is pulled "
"from the cellular phone, and a new object, the business card, is pushed into "
"the phone's directory."
msgstr ""
"OBEX 클라이언트는 OBEX 서버에서 개체를 푸시 및/또는 풀링하는 데 사용됩니다.  "
"객체의 예로는 명함이나 약속이 있습니다.  OBEX 클라이언트는 SDP를 통해 원격 "
"장치에서 RFCOMM 채널 번호를 가져올 수 있습니다.  이 작업은 RFCOMM 채널 번호 "
"대신 서비스 이름을 지정하여 수행할 수 있습니다.  지원되는 서비스 이름은 "
"다음과 같습니다: `IrMC`, `FTRN`, `OPUSH`입니다.  RFCOMM 채널을 숫자로 지정할 "
"수도 있습니다.  아래는 휴대폰에서 장치 정보 개체를 가져오고 새 개체인 명함을 "
"휴대폰의 디렉토리에 푸시하는 OBEX 세션의 예시입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1836
#, no-wrap
msgid ""
"% obexapp -a 00:80:37:29:19:a4 -C IrMC\n"
"obex> get telecom/devinfo.txt devinfo-t39.txt\n"
"Success, response: OK, Success (0x20)\n"
"obex> put new.vcf\n"
"Success, response: OK, Success (0x20)\n"
"obex> di\n"
"Success, response: OK, Success (0x20)\n"
msgstr ""
"% obexapp -a 00:80:37:29:19:a4 -C IrMC\n"
"obex> get telecom/devinfo.txt devinfo-t39.txt\n"
"Success, response: OK, Success (0x20)\n"
"obex> put new.vcf\n"
"Success, response: OK, Success (0x20)\n"
"obex> di\n"
"Success, response: OK, Success (0x20)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1843
msgid ""
"In order to provide the OPUSH service, man:sdpd[8] must be running and a "
"root folder, where all incoming objects will be stored, must be created.  "
"The default path to the root folder is [.filename]#/var/spool/obex#.  "
"Finally, start the OBEX server on a valid RFCOMM channel number.  The OBEX "
"server will automatically register the OPUSH service with the local SDP "
"daemon.  The example below shows how to start the OBEX server."
msgstr ""
"OPUSH 서비스를 제공하려면 man:sdpd[8]를 실행하고 들어오는 모든 오브젝트가 "
"저장될 루트 폴더를 만들어야 합니다.  루트 폴더의 기본 경로는 [.filename]#/"
"var/spool/obex#입니다.  마지막으로 유효한 RFCOMM 채널 번호에서 OBEX 서버를 "
"시작합니다.  OBEX 서버는 로컬 SDP 데몬에 OPUSH 서비스를 자동으로 "
"등록합니다.  아래 예시는 OBEX 서버를 시작하는 방법을 보여줍니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1847
#, no-wrap
msgid "# obexapp -s -C 10\n"
msgstr "# obexapp -s -C 10\n"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1849
#, no-wrap
msgid "Serial Port Profile (SPP)"
msgstr "Serial Port Profile (SPP)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1853
msgid ""
"The Serial Port Profile (SPP) allows Bluetooth devices to perform serial "
"cable emulation.  This profile allows legacy applications to use Bluetooth "
"as a cable replacement, through a virtual serial port abstraction."
msgstr ""
"직렬 포트 프로파일(SPP)을 사용하면 Bluetooth 장치에서 직렬 케이블 "
"에뮬레이션을 수행할 수 있습니다.  이 프로파일을 사용하면 레거시 "
"애플리케이션에서 가상 직렬 포트 추상화를 통해 케이블을 대체하는 방식으로 "
"Bluetooth를 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1858
msgid ""
"In FreeBSD, man:rfcomm_sppd[1] implements SPP and a pseudo tty is used as a "
"virtual serial port abstraction.  The example below shows how to connect to "
"a remote device's serial port service.  A RFCOMM channel does not have to be "
"specified as man:rfcomm_sppd[1] can obtain it from the remote device via "
"SDP.  To override this, specify a RFCOMM channel on the command line."
msgstr ""
"FreeBSD에서는 man:rfcomm_sppd[1]가 SPP를 구현하고 가상 직렬 포트 추상화로 "
"의사 tty가 사용됩니다.  아래 예제는 원격 장치의 직렬 포트 서비스에 연결하는 "
"방법을 보여줍니다.  man:rfcomm_sppd[1]가 SDP를 통해 원격 장치에서 가져올 수 "
"있으므로 RFCOMM 채널을 지정할 필요가 없습니다.  이를 재정의하려면 명령줄에서 "
"RFCOMM 채널을 지정하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1864
#, no-wrap
msgid ""
"# rfcomm_sppd -a 00:07:E0:00:0B:CA -t\n"
"rfcomm_sppd[94692]: Starting on /dev/pts/6...\n"
"/dev/pts/6\n"
msgstr ""
"# rfcomm_sppd -a 00:07:E0:00:0B:CA -t\n"
"rfcomm_sppd[94692]: Starting on /dev/pts/6...\n"
"/dev/pts/6\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1867
msgid "Once connected, the pseudo tty can be used as serial port:"
msgstr "연결되면 의사 tty를 직렬 포트로 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1871
#, no-wrap
msgid "# cu -l /dev/pts/6\n"
msgstr "# cu -l /dev/pts/6\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1874
msgid "The pseudo tty is printed on stdout and can be read by wrapper scripts:"
msgstr "의사 tty는 stdout에 출력되며 래퍼 스크립트에서 읽을 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1879
#, no-wrap
msgid ""
"PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`\n"
"cu -l $PTS\n"
msgstr ""
"PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`\n"
"cu -l $PTS\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1887
msgid ""
"By default, when FreeBSD is accepting a new connection, it tries to perform "
"a role switch and become master.  Some older Bluetooth devices which do not "
"support role switching will not be able to connect.  Since role switching is "
"performed when a new connection is being established, it is not possible to "
"ask the remote device if it supports role switching.  However, there is a "
"HCI option to disable role switching on the local side:"
msgstr ""
"기본적으로 FreeBSD는 새 연결을 수락할 때 역할 전환(role switch)을 수행하여 "
"마스터가 되려고 시도합니다.  역할 전환을 지원하지 않는 일부 구형 Bluetooth "
"장치는 연결할 수 없습니다.  역할 전환은 새 연결이 설정될 때 수행되므로 원격 "
"장치에 역할 전환을 지원하는지 여부를 물어볼 수 없습니다.  그러나 로컬 측에서 "
"역할 전환을 비활성화하는 HCI 옵션이 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1891
#, no-wrap
msgid "# hccontrol -n ubt0hci write_node_role_switch 0\n"
msgstr "# hccontrol -n ubt0hci write_node_role_switch 0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1895
msgid ""
"To display Bluetooth packets, use the third-party package hcidump, which can "
"be installed using the package:comms/hcidump[] package or port.  This "
"utility is similar to man:tcpdump[1] and can be used to display the contents "
"of Bluetooth packets on the terminal and to dump the Bluetooth packets to a "
"file."
msgstr ""
"블루투스 패킷을 표시하려면 package:comms/hcidump[] 패키지 또는 포트를 "
"사용하여 설치할 수 있는 타사 패키지 hcidump를 사용합니다.  이 유틸리티는 "
"man:tcpdump[1]와 유사하며 터미널에 블루투스 패킷의 내용을 표시하고 블루투스 "
"패킷을 파일로 덤프하는 데 사용할 수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1897
#, no-wrap
msgid "Bridging"
msgstr "브릿징"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1901
msgid ""
"It is sometimes useful to divide a network, such as an Ethernet segment, "
"into network segments without having to create IP subnets and use a router "
"to connect the segments together.  A device that connects two networks "
"together in this fashion is called a \"bridge\"."
msgstr ""
"이더넷 세그먼트와 같은 네트워크를 IP 서브넷을 생성하지 않고도 네트워크 "
"세그먼트로 나누고 라우터를 사용하여 세그먼트를 서로 연결하는 것이 유용할 "
"때가 있습니다.  이러한 방식으로 두 네트워크를 함께 연결하는 장치를 \"브리지"
"\"라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1906
msgid ""
"A bridge works by learning the MAC addresses of the devices on each of its "
"network interfaces.  It forwards traffic between networks only when the "
"source and destination MAC addresses are on different networks.  In many "
"respects, a bridge is like an Ethernet switch with very few ports.  A "
"FreeBSD system with multiple network interfaces can be configured to act as "
"a bridge."
msgstr ""
"브리지는 각 네트워크 인터페이스에 있는 장치의 MAC 주소를 학습하여 "
"작동합니다.  브릿지는 소스 및 대상 MAC 주소가 서로 다른 네트워크에 있는 "
"경우에만 네트워크 간 트래픽을 전달합니다.  여러 측면에서 브리지는 포트 수가 "
"매우 적은 이더넷 스위치와 같습니다.  여러 네트워크 인터페이스가 있는 FreeBSD "
"시스템은 브리지 역할을 하도록 구성할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1908
msgid "Bridging can be useful in the following situations:"
msgstr "브리징은 다음과 같은 상황에서 유용할 수 있습니다:"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1909
#, no-wrap
msgid "Connecting Networks"
msgstr "네트워크 연결하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1913
msgid ""
"The basic operation of a bridge is to join two or more network segments.  "
"There are many reasons to use a host-based bridge instead of networking "
"equipment, such as cabling constraints or firewalling.  A bridge can also "
"connect a wireless interface running in hostap mode to a wired network and "
"act as an access point."
msgstr ""
"브리지의 기본 작동은 두 개 이상의 네트워크 세그먼트를 연결하는 것입니다.  "
"케이블 연결 제약이나 방화벽과 같이 네트워킹 장비 대신 호스트 기반 브리지를 "
"사용하는 데는 여러 가지 이유가 있습니다.  브리지는 호스트 모드에서 실행되는 "
"무선 인터페이스를 유선 네트워크에 연결하여 액세스 포인트 역할을 할 수도 "
"있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1914
#, no-wrap
msgid "Filtering/Traffic Shaping Firewall"
msgstr "필터링/트래픽 셰이핑 방화벽"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1916
msgid ""
"A bridge can be used when firewall functionality is needed without routing "
"or Network Address Translation (NAT)."
msgstr "라우팅이나 NAT(네트워크 주소 변환) 없이 방화벽 기능이 필요한 경우 브리지를 "
"사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1921
msgid ""
"An example is a small company that is connected via DSL or ISDN to an ISP.  "
"There are thirteen public IP addresses from the ISP and ten computers on the "
"network.  In this situation, using a router-based firewall is difficult "
"because of subnetting issues.  A bridge-based firewall can be configured "
"without any IP addressing issues."
msgstr ""
"예를 들어 DSL 또는 ISDN을 통해 ISP에 연결된 소규모 회사가 있습니다.  "
"네트워크에는 ISP의 13개의 공용 IP 주소와 10대의 컴퓨터가 있습니다.  이 경우 "
"라우터 기반 방화벽은 서브넷 문제 때문에 사용하기 어렵습니다.  브리지 기반 "
"방화벽은 IP 주소 지정 문제 없이 구성할 수 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1922
#, no-wrap
msgid "Network Tap"
msgstr "네트워크 탭"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1924
msgid ""
"A bridge can join two network segments in order to inspect all Ethernet "
"frames that pass between them using man:bpf[4] and man:tcpdump[1] on the "
"bridge interface, or by sending a copy of all frames out on an additional "
"interface known as a span port."
msgstr ""
"브리지는 두 네트워크 세그먼트를 연결하여 브리지 인터페이스에서 man:bpf[4] 및 "
"man:tcpdump[1]를 사용하거나 span port라는 추가 인터페이스로 모든 프레임의 "
"복사본을 전송하여 그 사이를 통과하는 모든 이더넷 프레임을 검사할 수 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1925
#, no-wrap
msgid "Layer 2 VPN"
msgstr "Layer 2 VPN"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1927
msgid ""
"Two Ethernet networks can be joined across an IP link by bridging the "
"networks to an EtherIP tunnel or a man:tap[4] based solution such as OpenVPN."
msgstr ""
"두 개의 이더넷 네트워크는 EtherIP 터널 또는 OpenVPN과 같은 man:tap[4] 기반 "
"솔루션으로 네트워크를 연결하여 IP 링크를 통해 연결할 수 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1928
#, no-wrap
msgid "Layer 2 Redundancy"
msgstr "Layer 2 Redundancy"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1930
msgid ""
"A network can be connected together with multiple links and use the Spanning "
"Tree Protocol (STP) to block redundant paths."
msgstr ""
"네트워크를 여러 개의 링크로 연결하고 스패닝 트리 프로토콜(Spanning Tree "
"Protocol, STP)을 사용하여 중복 경로를 차단할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1933
msgid ""
"This section describes how to configure a FreeBSD system as a bridge using "
"man:if_bridge[4].  A netgraph bridging driver is also available, and is "
"described in man:ng_bridge[4]."
msgstr ""
"이 섹션에서는 man:if_bridge[4]를 사용하여 FreeBSD 시스템을 브리지로 구성하는 "
"방법을 설명합니다.  netgraph bridging driver도 사용할 수 있으며, "
"man:ng_bridge[4]에 설명되어 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1938
msgid ""
"Packet filtering can be used with any firewall package that hooks into the "
"man:pfil[9] framework.  The bridge can be used as a traffic shaper with man:"
"altq[4] or man:dummynet[4]."
msgstr ""
"패킷 필터링은 man:pfil[9] 프레임워크에 연결되는 모든 방화벽 패키지와 함께 "
"사용할 수 있습니다.  브리지는 man:altq[4] 또는 man:dummynet[4]과 함께 트래픽 "
"셰이퍼로 사용할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1940
#, no-wrap
msgid "Enabling the Bridge"
msgstr "브리지 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1944
msgid ""
"In FreeBSD, man:if_bridge[4] is a kernel module which is automatically "
"loaded by man:ifconfig[8] when creating a bridge interface.  It is also "
"possible to compile bridge support into a custom kernel by adding `device "
"if_bridge` to the custom kernel configuration file."
msgstr ""
"FreeBSD에서, man:if_bridge[4]는 커널 모듈로, 브리지 인터페이스를 만들 때 "
"man:ifconfig[8]에 의해 자동으로 로드됩니다.  커스텀 커널 구성 파일에 `device "
"if_bridge`를 추가하여 커스텀 커널에 브리지 지원을 컴파일할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1947
msgid ""
"The bridge is created using interface cloning.  To create the bridge "
"interface:"
msgstr "브리지는 인터페이스 복제를 사용하여 만들어집니다.  브리지 인터페이스를 "
"만들려면 다음과 같이 하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1958
#, no-wrap
msgid ""
"# ifconfig bridge create\n"
"bridge0\n"
"# ifconfig bridge0\n"
"bridge0: flags=8802<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0\n"
msgstr ""
"# ifconfig bridge create\n"
"bridge0\n"
"# ifconfig bridge0\n"
"bridge0: flags=8802<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1963
msgid ""
"When a bridge interface is created, it is automatically assigned a randomly "
"generated Ethernet address.  The `maxaddr` and `timeout` parameters control "
"how many MAC addresses the bridge will keep in its forwarding table and how "
"many seconds before each entry is removed after it is last seen.  The other "
"parameters control how STP operates."
msgstr ""
"브리지 인터페이스가 생성되면 무작위로 생성된 이더넷 주소가 자동으로 "
"할당됩니다.  `maxaddr` 및 `timeout`` 매개 변수는 브리지가 포워딩 테이블에 "
"보관할 MAC 주소의 수와 각 항목이 마지막으로 표시된 후 제거되기까지의 시간(초)"
"을 제어합니다.  다른 매개변수는 STP 작동 방식을 제어합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1966
msgid ""
"Next, specify which network interfaces to add as members of the bridge.  For "
"the bridge to forward packets, all member interfaces and the bridge need to "
"be up:"
msgstr ""
"다음으로 브리지의 멤버로 추가할 네트워크 인터페이스를 지정합니다.  브리지가 "
"패킷을 전달하려면 모든 멤버 인터페이스와 브리지가 가동 중이어야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1972
#, no-wrap
msgid ""
"# ifconfig bridge0 addm fxp0 addm fxp1 up\n"
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
msgstr ""
"# ifconfig bridge0 addm fxp0 addm fxp1 up\n"
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1976
msgid ""
"The bridge can now forward Ethernet frames between [.filename]#fxp0# and [."
"filename]#fxp1#.  Add the following lines to [.filename]#/etc/rc.conf# so "
"the bridge is created at startup:"
msgstr ""
"이제 브리지가 [.filename]#fxp0#와 [.filename]#fxp1# 간에 이더넷 프레임을 "
"전달할 수 있습니다.  부팅 시 브리지가 생성되도록 [.filename]#/etc/rc.conf#에 "
"다음 줄을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1983
#, no-wrap
msgid ""
"cloned_interfaces=\"bridge0\"\n"
"ifconfig_bridge0=\"addm fxp0 addm fxp1 up\"\n"
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
msgstr ""
"cloned_interfaces=\"bridge0\"\n"
"ifconfig_bridge0=\"addm fxp0 addm fxp1 up\"\n"
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1988
msgid ""
"If the bridge host needs an IP address, set it on the bridge interface, not "
"on the member interfaces.  The address can be set statically or via DHCP.  "
"This example sets a static IP address:"
msgstr ""
"브리지 호스트에 IP 주소가 필요한 경우 구성원 인터페이스가 아닌 브리지 "
"인터페이스에서 설정하세요.  주소는 정적으로 또는 DHCP를 통해 설정할 수 "
"있습니다.  이 예에서는 고정 IP 주소를 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1992
#, no-wrap
msgid "# ifconfig bridge0 inet 192.168.0.1/24\n"
msgstr "# ifconfig bridge0 inet 192.168.0.1/24\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1996
msgid ""
"It is also possible to assign an IPv6 address to a bridge interface.  To "
"make the changes permanent, add the addressing information to [.filename]#/"
"etc/rc.conf#."
msgstr ""
"브리지 인터페이스에 IPv6 주소를 할당할 수도 있습니다.  변경 사항을 "
"영구적으로 적용하려면 [.filename]#/etc/rc.conf#에 주소 지정 정보를 "
"추가하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2002
msgid ""
"When packet filtering is enabled, bridged packets will pass through the "
"filter inbound on the originating interface on the bridge interface, and "
"outbound on the appropriate interfaces.  Either stage can be disabled.  When "
"direction of the packet flow is important, it is best to firewall on the "
"member interfaces rather than the bridge itself."
msgstr ""
"패킷 필터링이 활성화되면 브리지 패킷은 브리지 인터페이스의 원본 "
"인터페이스에서 인바운드 필터를 통과하고 해당 인터페이스에서 아웃바운드 "
"필터를 통과합니다.  어느 단계든 비활성화할 수 있습니다.  패킷 흐름의 방향이 "
"중요한 경우 브리지 자체보다는 멤버 인터페이스에서 방화벽을 사용하는 것이 "
"가장 좋습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2005
msgid ""
"The bridge has several configurable settings for passing non-IP and IP "
"packets, and layer2 firewalling with man:ipfw[8].  See man:if_bridge[4] for "
"more information."
msgstr ""
"브리지에는 non-IP 및 IP 패킷을 전달하기 위한 몇 가지 구성 가능한 설정과 "
"man:ipfw[8]로 레이어2 방화벽을 설정할 수 있습니다.  자세한 내용은 "
"man:if_bridge[4]를 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2007
#, no-wrap
msgid "Enabling Spanning Tree"
msgstr "Spanning Tree 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2012
msgid ""
"For an Ethernet network to function properly, only one active path can exist "
"between two devices.  The STP protocol detects loops and puts redundant "
"links into a blocked state.  Should one of the active links fail, STP "
"calculates a different tree and enables one of the blocked paths to restore "
"connectivity to all points in the network."
msgstr ""
"이더넷 네트워크가 제대로 작동하려면 두 장치 사이에 활성 경로가 하나만 "
"존재해야 할 수 있습니다.  STP 프로토콜은 루프를 감지하고 중복 링크를 차단 "
"상태로 전환합니다.  활성 링크 중 하나에 장애가 발생하면 STP는 다른 트리를 "
"계산하고 차단된 경로 중 하나를 활성화하여 네트워크의 모든 지점에 대한 연결을 "
"복원합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2016
msgid ""
"The Rapid Spanning Tree Protocol (RSTP or 802.1w) provides backwards "
"compatibility with legacy STP.  RSTP provides faster convergence and "
"exchanges information with neighboring switches to quickly transition to "
"forwarding mode without creating loops.  FreeBSD supports RSTP and STP as "
"operating modes, with RSTP being the default mode."
msgstr ""
"RSTP(Rapid Spanning Tree Protocol 또는 802.1w)는 레거시 STP와의 역호환성을 "
"제공합니다.  RSTP는 더 빠른 컨버전스를 제공하고 인접 스위치와 정보를 "
"교환하여 루프를 만들지 않고 포워딩 모드로 빠르게 전환합니다.  FreeBSD는 "
"RSTP와 STP를 작동 모드로 지원하며, 기본 모드는 RSTP입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2019
msgid ""
"STP can be enabled on member interfaces using man:ifconfig[8].  For a bridge "
"with [.filename]#fxp0# and [.filename]#fxp1# as the current interfaces, "
"enable STP with:"
msgstr ""
"man:ifconfig[8]을 사용하여 멤버 인터페이스에서 STP를 활성화할 수 있습니다.  "
"현재 인터페이스가 [.filename]#fxp0# 및 [.filename]#fxp1#인 브리지의 경우, "
"STP를 다음으로 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2034
#, no-wrap
msgid ""
"# ifconfig bridge0 stp fxp0 stp fxp1\n"
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether d6:cf:d5:a0:94:6d\n"
"        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 3 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
msgstr ""
"# ifconfig bridge0 stp fxp0 stp fxp1\n"
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu "
"1500\n"
"        ether d6:cf:d5:a0:94:6d\n"
"        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 3 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2038
msgid ""
"This bridge has a spanning tree ID of `00:01:02:4b:d4:50` and a priority of "
"`32768`.  As the `root id` is the same, it indicates that this is the root "
"bridge for the tree."
msgstr ""
"이 브리지의 스패닝 트리 ID는 `00:01:02:4b:d4:50`이고 우선 순위는 `32768`"
"입니다.  `root id`가 동일하므로 이 브리지가 트리의 루트 브리지임을 "
"나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2040
msgid "Another bridge on the network also has STP enabled:"
msgstr "네트워크의 다른 브리지에도 STP가 활성화되어 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2054
#, no-wrap
msgid ""
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role root state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 5 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
msgstr ""
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu "
"1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role root state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 5 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2058
msgid ""
"The line `root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` "
"shows that the root bridge is `00:01:02:4b:d4:50` and has a path cost of "
"`400000` from this bridge.  The path to the root bridge is via `port 4` "
"which is [.filename]#fxp0#."
msgstr ""
"`root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` 줄은 루트 "
"브리지가 `00:01:02:4B:D4:50`이고 이 브리지의 경로 비용이 `400000`임을 "
"보여줍니다.  루트 브리지로의 경로는 `port 4`인 [.filename]#fxp0#를 "
"경유합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2059
#, no-wrap
msgid "Bridge Interface Parameters"
msgstr "브리지 인터페이스 매개변수"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2064
msgid ""
"Several `ifconfig` parameters are unique to bridge interfaces.  This section "
"summarizes some common uses for these parameters.  The complete list of "
"available parameters is described in man:ifconfig[8]."
msgstr ""
"브리지 인터페이스에는 몇 가지 `ifconfig` 고유한 매개변수가 있습니다.  이 "
"섹션에서는 이러한 매개 변수의 일반적인 용도를 요약합니다.  사용 가능한 "
"매개변수의 전체 목록은 man:ifconfig[8]에 설명되어 있습니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2065
#, no-wrap
msgid "private"
msgstr "private"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2069
msgid ""
"A private interface does not forward any traffic to any other port that is "
"also designated as a private interface.  The traffic is blocked "
"unconditionally so no Ethernet frames will be forwarded, including ARP "
"packets.  If traffic needs to be selectively blocked, a firewall should be "
"used instead."
msgstr ""
"Private 인터페이스는 private 인터페이스로 지정된 다른 포트로 트래픽을 "
"전달하지 않습니다.  트래픽은 무조건 차단되므로 ARP 패킷을 포함한 이더넷 "
"프레임이 전달되지 않습니다.  트래픽을 선택적으로 차단해야 하는 경우 방화벽을 "
"대신 사용해야 합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2070
#, no-wrap
msgid "span"
msgstr "span"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2075
msgid ""
"A span port transmits a copy of every Ethernet frame received by the "
"bridge.  The number of span ports configured on a bridge is unlimited, but "
"if an interface is designated as a span port, it cannot also be used as a "
"regular bridge port.  This is most useful for snooping a bridged network "
"passively on another host connected to one of the span ports of the bridge.  "
"For example, to send a copy of all frames out the interface named [."
"filename]#fxp4#:"
msgstr ""
"Span 포트는 브리지에서 수신한 모든 이더넷 프레임의 복사본을 전송합니다.  "
"브리지에 구성된 span 포트의 수는 무제한이지만 인터페이스가 span 포트로 "
"지정되면 일반 브리지 포트로도 사용할 수 없습니다.  이 기능은 브리지의 span "
"포트 중 하나에 연결된 다른 호스트에서 브리지 네트워크를 수동적으로 "
"스누핑하는 데 가장 유용합니다.  예를 들어 모든 프레임의 복사본을 [."
"filename]#fxp4#라는 인터페이스로 보내려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2079
#, no-wrap
msgid "# ifconfig bridge0 span fxp4\n"
msgstr "# ifconfig bridge0 span fxp4\n"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2081
#, no-wrap
msgid "sticky"
msgstr "sticky"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2086
msgid ""
"If a bridge member interface is marked as sticky, dynamically learned "
"address entries are treated as static entries in the forwarding cache.  "
"Sticky entries are never aged out of the cache or replaced, even if the "
"address is seen on a different interface.  This gives the benefit of static "
"address entries without the need to pre-populate the forwarding table.  "
"Clients learned on a particular segment of the bridge cannot roam to another "
"segment."
msgstr ""
"브리지 멤버 인터페이스가 sticky로 표시된 경우 동적으로 학습된 주소 항목은 "
"전달 캐시에서 정적 항목으로 취급됩니다.  고정 항목은 주소가 다른 "
"인터페이스에 표시되더라도 캐시에서 에이징되거나 교체되지 않습니다.  따라서 "
"전달 테이블을 미리 채울 필요 없이 정적 주소 항목의 이점을 누릴 수 있습니다.  "
"브리지의 특정 세그먼트에서 학습한 클라이언트는 다른 세그먼트로 로밍할 수 "
"없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2089
msgid ""
"An example of using sticky addresses is to combine the bridge with VLANs in "
"order to isolate customer networks without wasting IP address space.  "
"Consider that `CustomerA` is on `vlan100`, `CustomerB` is on `vlan101`, and "
"the bridge has the address `192.168.0.1`:"
msgstr ""
"Sticky 주소를 사용하는 한 가지 예는 IP 주소 공간을 낭비하지 않고 고객 "
"네트워크를 분리하기 위해 브리지를 VLAN과 결합하는 것입니다.  `CustomerA`는 "
"`vlan100`에, `CustomerB`는 `vlan101`에 있으며 브리지의 주소는 `192.168.0.1`"
"이라고 가정해 보겠습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2094
#, no-wrap
msgid ""
"# ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101\n"
"# ifconfig bridge0 inet 192.168.0.1/24\n"
msgstr ""
"# ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101\n"
"# ifconfig bridge0 inet 192.168.0.1/24\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2098
msgid ""
"In this example, both clients see `192.168.0.1` as their default gateway.  "
"Since the bridge cache is sticky, one host cannot spoof the MAC address of "
"the other customer in order to intercept their traffic."
msgstr ""
"이 예제에서는 두 클라이언트 모두 `192.168.0.1`을 기본 게이트웨이로 "
"인식합니다.  브리지 캐시는 고정되어 있으므로 한 호스트가 다른 고객의 "
"트래픽을 가로채기 위해 다른 고객의 MAC 주소를 스푸핑할 수 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2100
msgid ""
"Any communication between the VLANs can be blocked using a firewall or, as "
"seen in this example, private interfaces:"
msgstr "방화벽을 사용하거나 이 예제에서 볼 수 있듯 사설 인터페이스를 사용하여 VLAN "
"간의 모든 통신을 차단할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2104
#, no-wrap
msgid "# ifconfig bridge0 private vlan100 private vlan101\n"
msgstr "# ifconfig bridge0 private vlan100 private vlan101\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2107
msgid ""
"The customers are completely isolated from each other and the full `/24` "
"address range can be allocated without subnetting."
msgstr "고객은 서로 완전히 격리되어 있으며 서브넷 없이 전체 `/24` 주소 범위를 할당할 "
"수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2110
msgid ""
"The number of unique source MAC addresses behind an interface can be "
"limited.  Once the limit is reached, packets with unknown source addresses "
"are dropped until an existing host cache entry expires or is removed."
msgstr ""
"인터페이스 뒤에 있는 고유 소스 MAC 주소의 수는 제한될 수 있습니다.  제한에 "
"도달하면 소스 주소를 알 수 없는 패킷은 기존 호스트 캐시 항목이 만료되거나 "
"제거될 때까지 삭제됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2112
msgid ""
"The following example sets the maximum number of Ethernet devices for "
"`CustomerA` on `vlan100` to 10:"
msgstr "다음 예에서는 `vlan100`에서 `CustomerA`의 이더넷 장치 최대 수를 10개로 "
"설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2116
#, no-wrap
msgid "# ifconfig bridge0 ifmaxaddr vlan100 10\n"
msgstr "# ifconfig bridge0 ifmaxaddr vlan100 10\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2122
msgid ""
"Bridge interfaces also support monitor mode, where the packets are discarded "
"after man:bpf[4] processing and are not processed or forwarded further.  "
"This can be used to multiplex the input of two or more interfaces into a "
"single man:bpf[4] stream.  This is useful for reconstructing the traffic for "
"network taps that transmit the RX/TX signals out through two separate "
"interfaces.  For example, to read the input from four network interfaces as "
"one stream:"
msgstr ""
"브리지 인터페이스는 man:bpf[4] 처리 후 패킷이 폐기되고 더 이상 처리되거나 "
"전달되지 않는 모니터 모드도 지원합니다.  이 모드는 두 개 이상의 인터페이스 "
"입력을 단일 man:bpf[4] 스트림으로 멀티플렉싱하는 데 사용할 수 있습니다.  "
"이는 두 개의 개별 인터페이스를 통해 RX/TX 신호를 전송하는 네트워크 탭의 "
"트래픽을 재구성하는 데 유용합니다.  예를 들어, 4개의 네트워크 인터페이스에서 "
"하나의 스트림으로 입력을 읽을 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2127
#, no-wrap
msgid ""
"# ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up\n"
"# tcpdump -i bridge0\n"
msgstr ""
"# ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up\n"
"# tcpdump -i bridge0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2129
#, no-wrap
msgid "SNMP Monitoring"
msgstr "SNMP 모니터링"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2133
msgid ""
"The bridge interface and STP parameters can be monitored via man:bsnmpd[1] "
"which is included in the FreeBSD base system.  The exported bridge MIBs "
"conform to IETF standards so any SNMP client or monitoring package can be "
"used to retrieve the data."
msgstr ""
"브리지 인터페이스와 STP 매개변수는 FreeBSD 기본 시스템에 포함된 man:bsnmpd[1]"
"를 통해 모니터링할 수 있습니다.  내보낸 브리지 MIB는 IETF 표준을 준수하므로 "
"모든 SNMP 클라이언트 또는 모니터링 패키지를 사용하여 데이터를 검색할 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2135
msgid ""
"To enable monitoring on the bridge, uncomment this line in [.filename]#/etc/"
"snmpd.config# by removing the beginning `+#+` symbol:"
msgstr ""
"브리지에서 모니터링을 사용하려면 [.filename]#/etc/snmpd.config#에서 앞부분의 "
"`+#+` 기호를 제거하여 이 줄의 주석을 해제합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2139
#, no-wrap
msgid "begemotSnmpdModulePath.\"bridge\" = \"/usr/lib/snmp_bridge.so\"\n"
msgstr "begemotSnmpdModulePath.\"bridge\" = \"/usr/lib/snmp_bridge.so\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2144
msgid ""
"Other configuration settings, such as community names and access lists, may "
"need to be modified in this file.  See man:bsnmpd[1] and man:snmp_bridge[3] "
"for more information.  Once these edits are saved, add this line to [."
"filename]#/etc/rc.conf#:"
msgstr ""
"커뮤니티 이름 및 액세스 목록과 같은 다른 구성 설정은 이 파일에서 수정해야 할 "
"수 있습니다.  자세한 내용은 man:bsnmpd[1] 및 man:snmp_bridge[3]를 "
"참조하세요.  이러한 편집 내용을 저장한 후 [.filename]#/etc/rc.conf#에 다음 "
"줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2148
#, no-wrap
msgid "bsnmpd_enable=\"YES\"\n"
msgstr "bsnmpd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2151
msgid "Then, start man:bsnmpd[1]:"
msgstr "그리고 나서, man:bsnmpd[1]를 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2155
#, no-wrap
msgid "# service bsnmpd start\n"
msgstr "# service bsnmpd start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2160
msgid ""
"The following examples use the Net-SNMP software (package:net-mgmt/net-"
"snmp[]) to query a bridge from a client system.  The package:net-mgmt/"
"bsnmptools[] port can also be used.  From the SNMP client which is running "
"Net-SNMP, add the following lines to [.filename]#$HOME/.snmp/snmp.conf# in "
"order to import the bridge MIB definitions:"
msgstr ""
"다음 예는 클라이언트 시스템에서 브리지를 쿼리하기 위해 Net-SNMP "
"소프트웨어(package:net-mgmt/net-snmp[])를 사용합니다.  package:net-mgmt/"
"bsnmptools[] 포트도 사용할 수 있습니다.  Net-SNMP를 실행하는 SNMP "
"클라이언트에서 [.filename]#$HOME/.snmp/snmp.conf#에 다음 줄을 추가하여 "
"브리지 MIB 정의를 가져옵니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2165
#, no-wrap
msgid ""
"mibdirs +/usr/share/snmp/mibs\n"
"mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB\n"
msgstr ""
"mibdirs +/usr/share/snmp/mibs\n"
"mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2168
msgid "To monitor a single bridge using the IETF BRIDGE-MIB (RFC4188):"
msgstr "IETF BRIDGE-MIB(RFC4188)를 사용하여 단일 브리지를 모니터링 하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2187
#, no-wrap
msgid ""
"% snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge\n"
"BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44\n"
"BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports\n"
"BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds\n"
"BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2\n"
"BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"...\n"
"BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)\n"
"BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)\n"
"BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000\n"
"BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0\n"
"BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80\n"
"BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1\n"
"RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)\n"
msgstr ""
"% snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge\n"
"BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44\n"
"BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports\n"
"BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:"
"39.59 centi-seconds\n"
"BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2\n"
"BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"...\n"
"BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)\n"
"BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)\n"
"BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000\n"
"BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 "
"50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0\n"
"BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B "
"D4 50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80\n"
"BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1\n"
"RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2192
msgid ""
"The `dot1dStpTopChanges.0` value is two, indicating that the STP bridge "
"topology has changed twice.  A topology change means that one or more links "
"in the network have changed or failed and a new tree has been calculated.  "
"The `dot1dStpTimeSinceTopologyChange.0` value will show when this happened."
msgstr ""
"`dot1dStpTopChanges.0` 값은 2로, STP 브리지 토폴로지가 두 번 변경되었음을 "
"나타냅니다.  토폴로지 변경은 네트워크에서 하나 이상의 링크가 변경되거나 "
"실패하여 새 트리가 계산되었음을 의미합니다.  토폴로지 변경이 발생한 시점은 "
"`dot1dStpTimeSinceTopologyChange.0` 값에 표시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2194
msgid ""
"To monitor multiple bridge interfaces, the private BEGEMOT-BRIDGE-MIB can be "
"used:"
msgstr "여러 브리지 인터페이스를 모니터링하려면 비공개 BEGEMOT-BRIDGE-MIB를 사용할 "
"수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2212
#, no-wrap
msgid ""
"% snmpwalk -v 2c -c public bridge1.example.com\n"
"enterprises.fokus.begemot.begemotBridge\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge0\" = STRING: bridge0\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge2\" = STRING: bridge2\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge0\" = STRING: e:ce:3b:5a:9e:13\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge2\" = STRING: 12:5e:4d:74:d:fc\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge0\" = INTEGER: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge2\" = INTEGER: 1\n"
"...\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge0\" = Timeticks: (116927) 0:19:29.27 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge2\" = Timeticks: (82773) 0:13:47.73 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge0\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge2\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge0\" = Hex-STRING: 80 00 00 40 95 30 5E 31\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge2\" = Hex-STRING: 80 00 00 50 8B B8 C6 A9\n"
msgstr ""
"% snmpwalk -v 2c -c public bridge1.example.com\n"
"enterprises.fokus.begemot.begemotBridge\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge0\" = STRING: bridge0\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge2\" = STRING: bridge2\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge0\" = STRING: "
"e:ce:3b:5a:9e:13\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge2\" = STRING: "
"12:5e:4d:74:d:fc\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge0\" = INTEGER: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge2\" = INTEGER: 1\n"
"...\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge0\" = "
"Timeticks: (116927) 0:19:29.27 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge2\" = "
"Timeticks: (82773) 0:13:47.73 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge0\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge2\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge0\" = Hex-STRING: "
"80 00 00 40 95 30 5E 31\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge2\" = Hex-STRING: "
"80 00 00 50 8B B8 C6 A9\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2215
msgid ""
"To change the bridge interface being monitored via the `mib-2.dot1dBridge` "
"subtree:"
msgstr "`mib-2.dot1dBridge` 서브트리를 통해 모니터링 중인 브리지 인터페이스를 "
"변경하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2220
#, no-wrap
msgid ""
"% snmpset -v 2c -c private bridge1.example.com\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2\n"
msgstr ""
"% snmpset -v 2c -c private bridge1.example.com\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2\n"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2223
#, no-wrap
msgid "Link Aggregation and Failover"
msgstr "링크 집계 및 장애 조치"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2228
msgid ""
"FreeBSD provides the man:lagg[4] interface which can be used to aggregate "
"multiple network interfaces into one virtual interface in order to provide "
"failover and link aggregation.  Failover allows traffic to continue to flow "
"as long as at least one aggregated network interface has an established "
"link.  Link aggregation works best on switches which support LACP, as this "
"protocol distributes traffic bi-directionally while responding to the "
"failure of individual links."
msgstr ""
"FreeBSD는 장애 조치 및 링크 집계를 제공하기 위해 여러 네트워크 인터페이스를 "
"하나의 가상 인터페이스로 집계하는 데 사용할 수 있는 man:lagg[4] 인터페이스를 "
"제공합니다.  장애 조치를 통해 하나 이상의 집계된 네트워크 인터페이스에 "
"링크가 설정되어 있는 한 트래픽이 계속 흐르도록 할 수 있습니다.  이 "
"프로토콜은 개별 링크의 장애에 대응하면서 트래픽을 양방향으로 분산하므로 링크 "
"집계는 LACP를 지원하는 스위치에서 가장 잘 작동합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2231
msgid ""
"The aggregation protocols supported by the lagg interface determine which "
"ports are used for outgoing traffic and whether or not a specific port "
"accepts incoming traffic.  The following protocols are supported by man:"
"lagg[4]:"
msgstr ""
"Lagg 인터페이스에서 지원하는 집계 프로토콜은, 나가는 트래픽에 사용되는 "
"포트와 특정 포트가 들어오는 트래픽을 허용할지 여부를 결정합니다.  다음 "
"프로토콜은 man:lagg[4]에서 지원됩니다:"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2232
#, no-wrap
msgid "failover"
msgstr "failover"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2237
msgid ""
"This mode sends and receives traffic only through the master port.  If the "
"master port becomes unavailable, the next active port is used.  The first "
"interface added to the virtual interface is the master port and all "
"subsequently added interfaces are used as failover devices.  If failover to "
"a non-master port occurs, the original port becomes master once it becomes "
"available again."
msgstr ""
"이 모드는 마스터 포트를 통해서만 트래픽을 송수신합니다.  마스터 포트를 "
"사용할 수 없게 되면 다음 활성 포트가 사용됩니다.  가상 인터페이스에 추가된 "
"첫 번째 인터페이스가 마스터 포트이며 이후에 추가된 모든 인터페이스가 장애 "
"조치 장치로 사용됩니다.  마스터 포트가 아닌 포트에 대한 장애 조치가 발생하면 "
"원래 포트를 다시 사용할 수 있게 될 때까지 원래 포트가 마스터 포트가 됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2238
#, no-wrap
msgid "loadbalance"
msgstr "loadbalance"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2241
msgid ""
"This provides a static setup and does not negotiate aggregation with the "
"peer or exchange frames to monitor the link.  If the switch supports LACP, "
"that should be used instead."
msgstr ""
"이 설정은 정적 설정을 제공하며 피어와 집계를 협상하거나 링크를 모니터링하기 "
"위해 프레임을 교환하지 않습니다.  스위치가 LACP를 지원하는 경우 이를 대신 "
"사용해야 합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2242
#, no-wrap
msgid "lacp"
msgstr "lacp"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2247
msgid ""
"The IEEE(R) 802.3ad Link Aggregation Control Protocol (LACP) negotiates a "
"set of aggregable links with the peer into one or more Link Aggregated "
"Groups (LAGs).  Each LAG is composed of ports of the same speed, set to full-"
"duplex operation, and traffic is balanced across the ports in the LAG with "
"the greatest total speed.  Typically, there is only one LAG which contains "
"all the ports.  In the event of changes in physical connectivity, LACP will "
"quickly converge to a new configuration."
msgstr ""
"IEEE(R) 802.3ad 링크 집계 제어 프로토콜(Link Aggregation Control Protocol, "
"LACP)은 피어와 집계 가능한 링크 집합을 하나 이상의 링크 집계 그룹(LAG)으로 "
"협상합니다.  각 LAG는 풀 듀플렉스 작동으로 설정된 동일한 속도의 포트로 "
"구성되며, 트래픽은 총 속도가 가장 빠른 LAG의 포트 간에 균형을 이룹니다.  "
"일반적으로 모든 포트를 포함하는 LAG는 하나뿐입니다.  물리적 연결이 변경되는 "
"경우 LACP는 새로운 구성으로 빠르게 수렴합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2250
msgid ""
"LACP balances outgoing traffic across the active ports based on hashed "
"protocol header information and accepts incoming traffic from any active "
"port.  The hash includes the Ethernet source and destination address and, if "
"available, the VLAN tag, and the IPv4 or IPv6 source and destination address."
msgstr ""
"LACP는 해시된 프로토콜 헤더 정보를 기반으로 활성 포트에서 나가는 트래픽의 "
"균형을 맞추고 모든 활성 포트에서 들어오는 트래픽을 허용합니다.  해시에는 "
"이더넷 소스 및 대상 주소, 사용 가능한 경우 VLAN 태그, IPv4 또는 IPv6 소스 및 "
"대상 주소가 포함됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2251
#, no-wrap
msgid "roundrobin"
msgstr "roundrobin"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2254
msgid ""
"This mode distributes outgoing traffic using a round-robin scheduler through "
"all active ports and accepts incoming traffic from any active port.  Since "
"this mode violates Ethernet frame ordering, it should be used with caution."
msgstr ""
"이 모드는 모든 활성 포트를 통해 라운드 로빈 스케줄러를 사용하여 나가는 "
"트래픽을 분배하고 모든 활성 포트에서 들어오는 트래픽을 허용합니다.  이 "
"모드는 이더넷 프레임 순서를 위반하므로 주의해서 사용해야 합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2255
#, no-wrap
msgid "broadcast"
msgstr "broadcast"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2257
msgid ""
"This mode sends outgoing traffic to all ports configured on the lagg "
"interface, and receives frames on any port."
msgstr "이 모드는 지연 인터페이스에 구성된 모든 포트에 발신 트래픽을 보내고 모든 "
"포트에서 프레임을 수신합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2258
#, no-wrap
msgid "Configuration Examples"
msgstr "구성 예시"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2262
msgid ""
"This section demonstrates how to configure a Cisco(R) switch and a FreeBSD "
"system for LACP load balancing.  It then shows how to configure two Ethernet "
"interfaces in failover mode as well as how to configure failover mode "
"between an Ethernet and a wireless interface."
msgstr ""
"이 섹션에서는 LACP 로드 밸런싱을 위해 Cisco(R) 스위치와 FreeBSD 시스템을 "
"구성하는 방법을 설명합니다.  그런 다음 두 개의 이더넷 인터페이스를 페일오버 "
"모드로 구성하는 방법과 이더넷과 무선 인터페이스 간에 페일오버 모드를 "
"구성하는 방법을 보여 줍니다."

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2264
#, no-wrap
msgid "LACP Aggregation with a Cisco(R) Switch"
msgstr "Cisco(R) 스위치를 사용한 LACP 통합"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2270
msgid ""
"This example connects two man:fxp[4] Ethernet interfaces on a FreeBSD "
"machine to the first two Ethernet ports on a Cisco(R) switch as a single "
"load balanced and fault tolerant link.  More interfaces can be added to "
"increase throughput and fault tolerance.  Replace the names of the Cisco(R) "
"ports, Ethernet devices, channel group number, and IP address shown in the "
"example to match the local configuration."
msgstr ""
"이 예는 FreeBSD 머신에 두 개의 man:fxp[4] 이더넷 인터페이스를 Cisco(R) "
"스위치의 처음 두 이더넷 포트에 단일 로드 밸런싱 및 내결함성 링크로 "
"연결합니다.  처리량과 내결함성을 높이기 위해 더 많은 인터페이스를 추가할 수 "
"있습니다.  예제에 표시된 Cisco(R) 포트, 이더넷 장치, 채널 그룹 번호 및 IP "
"주소의 이름을 로컬 구성과 일치하도록 바꾸십시오."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2273
msgid ""
"Frame ordering is mandatory on Ethernet links and any traffic between two "
"stations always flows over the same physical link, limiting the maximum "
"speed to that of one interface.  The transmit algorithm attempts to use as "
"much information as it can to distinguish different traffic flows and "
"balance the flows across the available interfaces."
msgstr ""
"이더넷 링크에서는 프레임 순서가 필수이며 두 스테이션 간의 모든 트래픽은 항상 "
"동일한 물리적 링크를 통해 흐르기 때문에 최대 속도가 한 인터페이스의 속도로 "
"제한됩니다.  전송 알고리즘은 가능한 한 많은 정보를 사용하여 서로 다른 트래픽 "
"흐름을 구분하고 사용 가능한 인터페이스 간에 흐름의 균형을 맞추려고 "
"시도합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2275
msgid ""
"On the Cisco(R) switch, add the _FastEthernet0/1_ and _FastEthernet0/2_ "
"interfaces to channel group _1_:"
msgstr ""
"Cisco(R) 스위치에서 채널 그룹 _1_에 _FastEthernet0/1_ 및 _FastEthernet0/2_ "
"인터페이스를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2285
#, no-wrap
msgid ""
"interface FastEthernet0/1\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"
"!\n"
"interface FastEthernet0/2\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"
msgstr ""
"interface FastEthernet0/1\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"
"!\n"
"interface FastEthernet0/2\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2288
msgid ""
"On the FreeBSD system, create the man:lagg[4] interface using the physical "
"interfaces _fxp0_ and _fxp1_ and bring the interfaces up with an IP address "
"of _10.0.0.3/24_:"
msgstr ""
"FreeBSD 시스템에서 물리적 인터페이스 _fxp0_ 및 _fxp1_을 사용하여 man:lagg[4] "
"인터페이스를 생성하고 IP 주소 _10.0.0.3/24_로 인터페이스를 가져옵니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2295
#, no-wrap
msgid ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\n"
msgstr ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2298
msgid "Next, verify the status of the virtual interface:"
msgstr "다음으로 가상 인터페이스의 상태를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2311
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto lacp\n"
"        laggport: fxp1 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"
"        laggport: fxp0 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"
msgstr ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto lacp\n"
"        laggport: fxp1 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"
"        laggport: fxp0 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2316
msgid ""
"Ports marked as `ACTIVE` are part of the LAG that has been negotiated with "
"the remote switch.  Traffic will be transmitted and received through these "
"active ports.  Add `-v` to the above command to view the LAG identifiers."
msgstr ""
"`ACTIVE`으로 표시된 포트는 원격 스위치와 협상된 LAG의 일부입니다.  트래픽은 "
"이러한 활성 포트를 통해 송수신됩니다.  위의 명령에 `-v`를 추가하면 LAG "
"식별자를 볼 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2318
msgid "To see the port status on the Cisco(R) switch:"
msgstr "Cisco(R) 스위치의 포트 상태를 확인하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2325
#, no-wrap
msgid ""
"switch# show lacp neighbor\n"
"Flags:  S - Device is requesting Slow LACPDUs\n"
"        F - Device is requesting Fast LACPDUs\n"
"        A - Device is in Active mode       P - Device is in Passive mode\n"
msgstr ""
"switch# show lacp neighbor\n"
"Flags:  S - Device is requesting Slow LACPDUs\n"
"        F - Device is requesting Fast LACPDUs\n"
"        A - Device is in Active mode       P - Device is in Passive mode\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2327
#, no-wrap
msgid "Channel group 1 neighbors\n"
msgstr "Channel group 1 neighbors\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2329
#, no-wrap
msgid "Partner's information:\n"
msgstr "Partner's information:\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2334
#, no-wrap
msgid ""
"                  LACP port                        Oper    Port     Port\n"
"Port      Flags   Priority  Dev ID         Age     Key     Number   State\n"
"Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D\n"
"Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D\n"
msgstr ""
"                  LACP port                        Oper    Port     Port\n"
"Port      Flags   Priority  Dev ID         Age     Key     Number   State\n"
"Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D\n"
"Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2337
msgid "For more detail, type `show lacp neighbor detail`."
msgstr "자세한 내용을 보려면 `show lacp neighbor detail`를 입력합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2339
msgid ""
"To retain this configuration across reboots, add the following entries to [."
"filename]#/etc/rc.conf# on the FreeBSD system:"
msgstr ""
"재부팅 시에도 이 구성을 유지하려면 FreeBSD 시스템에서 [.filename]#/etc/rc."
"conf#에 다음 항목을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2346
#, no-wrap
msgid ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\"\n"
msgstr ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\"\n"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2351
#, no-wrap
msgid "Failover Mode"
msgstr "장애 조치 모드 (Failover Mode)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2358
msgid ""
"Failover mode can be used to switch over to a secondary interface if the "
"link is lost on the master interface.  To configure failover, make sure that "
"the underlying physical interfaces are up, then create the man:lagg[4] "
"interface.  In this example, _fxp0_ is the master interface, _fxp1_ is the "
"secondary interface, and the virtual interface is assigned an IP address of "
"_10.0.0.15/24_:"
msgstr ""
"장애 조치 모드는 마스터 인터페이스에서 링크가 끊어진 경우 보조 인터페이스로 "
"전환하는 데 사용할 수 있습니다.  장애 조치를 구성하려면 기본 물리적 "
"인터페이스가 가동 중인지 확인한 다음 man:lagg[4] 인터페이스를 만듭니다.  이 "
"예제에서 _fxp0_은 마스터 인터페이스, _fxp1_은 보조 인터페이스이며 가상 "
"인터페이스에는 _10.0.0.15/24_의 IP 주소가 할당됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2365
#, no-wrap
msgid ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24\n"
msgstr ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/"
"24\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2368
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2469
msgid "The virtual interface should look something like this:"
msgstr "가상 인터페이스는 다음과 같이 표시되어야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2381
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto failover\n"
"        laggport: fxp1 flags=0<>\n"
"        laggport: fxp0 flags=5<MASTER,ACTIVE>\n"
msgstr ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto failover\n"
"        laggport: fxp1 flags=0<>\n"
"        laggport: fxp0 flags=5<MASTER,ACTIVE>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2386
msgid ""
"Traffic will be transmitted and received on _fxp0_.  If the link is lost on "
"_fxp0_, _fxp1_ will become the active link.  If the link is restored on the "
"master interface, it will once again become the active link."
msgstr ""
"트래픽은 _fxp0_에서 송수신됩니다.  _fxp0_에서 링크가 끊어지면 _fxp1_이 활성 "
"링크가 됩니다.  마스터 인터페이스에서 링크가 복원되면 다시 한 번 활성 링크가 "
"됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2388
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2492
msgid ""
"To retain this configuration across reboots, add the following entries to [."
"filename]#/etc/rc.conf#:"
msgstr "재부팅 시에도 이 구성을 유지하려면 [.filename]#/etc/rc.conf#에 다음 항목을 "
"추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2395
#, no-wrap
msgid ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24\"\n"
msgstr ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/"
"24\"\n"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2400
#, no-wrap
msgid "Failover Mode Between Ethernet and Wireless Interfaces"
msgstr "이더넷과 무선 인터페이스 간 장애 조치 모드"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2406
msgid ""
"For laptop users, it is usually desirable to configure the wireless device "
"as a secondary which is only used when the Ethernet connection is not "
"available.  With man:lagg[4], it is possible to configure a failover which "
"prefers the Ethernet connection for both performance and security reasons, "
"while maintaining the ability to transfer data over the wireless connection."
msgstr ""
"노트북 사용자의 경우 일반적으로 이더넷 연결을 사용할 수 없을 때만 무선 "
"장치를 구성하는 것이 바람직합니다.  man:lagg[4]를 사용하면 무선 연결을 통해 "
"데이터를 전송하는 기능을 유지하면서 성능 및 보안상의 이유로 이더넷 연결을 "
"선호하는 장애 조치를 구성할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2408
msgid ""
"This is achieved by overriding the Ethernet interface's MAC address with "
"that of the wireless interface."
msgstr "이는 이더넷 인터페이스의 MAC 주소를 무선 인터페이스의 MAC 주소로 재정의하면 "
"됩니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2414
msgid ""
"In theory, either the Ethernet or wireless MAC address can be changed to "
"match the other.  However, some popular wireless interfaces lack support for "
"overriding the MAC address.  We therefore recommend overriding the Ethernet "
"MAC address for this purpose."
msgstr ""
"이론적으로는 이더넷 또는 무선 MAC 주소를 서로 일치하도록 변경할 수 "
"있습니다.  하지만 일부 인기 있는 무선 인터페이스는 MAC 주소 재정의 기능을 "
"지원하지 않습니다.  따라서 이더넷 MAC 주소를 재정의하는 것이 좋습니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2421
msgid ""
"If the driver for the wireless interface is not loaded in the `GENERIC` or "
"custom kernel, and the computer is running FreeBSD {rel121-current}, load "
"the corresponding [.filename]#.ko# in [.filename]#/boot/loader.conf# by "
"adding `*driver_load=\"YES\"*` to that file and rebooting.  Another, better "
"way is to load the driver in [.filename]#/etc/rc.conf# by adding it to "
"`kld_list` (see man:rc.conf[5] for details) in that file and rebooting.  "
"This is needed because otherwise the driver is not loaded yet at the time "
"the man:lagg[4] interface is set up."
msgstr ""
"무선 인터페이스용 드라이버가 `GENERIC` 또는 커스텀 커널에 로드되어 있지 않고 "
"컴퓨터가 FreeBSD {rel121-current}를 실행 중인 경우, 해당 파일에 "
"`*driver_load=\"YES\"*`를 추가하고 재부팅하여 [.filename]#/boot/loader.conf#"
"에 해당 [.filename]#.ko#를 로드합니다.  또 다른 더 좋은 방법은 해당 파일의 "
"`kld_list`(자세한 내용은 man:rc.conf[5] 참조)에 드라이버를 추가하고 "
"재부팅하여 [.filename]#/etc/rc.conf#에 드라이버를 로드하는 것입니다.  그렇지 "
"않으면 man:lagg[4] 인터페이스가 설정될 때 드라이버가 아직 로드되지 않기 "
"때문에 이 작업이 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2427
msgid ""
"In this example, the Ethernet interface, _re0_, is the master and the "
"wireless interface, _wlan0_, is the failover.  The _wlan0_ interface was "
"created from the _ath0_ physical wireless interface, and the Ethernet "
"interface will be configured with the MAC address of the wireless "
"interface.  First, bring the wireless interface up (replacing _FR_ with your "
"own 2-letter country code), but do not set an IP address.  Replace _wlan0_ "
"to match the system's wireless interface name:"
msgstr ""
"이 예제에서는 이더넷 인터페이스 _re0_가 마스터이고 무선 인터페이스 _wlan0_이 "
"페일오버입니다.  _wlan0_ 인터페이스는 _ath0_ 물리적 무선 인터페이스로부터 "
"생성되었으며, 이더넷 인터페이스는 무선 인터페이스의 MAC 주소로 구성됩니다.  "
"먼저 무선 인터페이스를 불러오되(_FR_을 자신의 2글자 국가 코드로 바꾸세요), "
"IP 주소는 설정하지 마세요.  시스템의 무선 인터페이스 이름과 일치하도록 "
"_wlan0_을 바꿉니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2431
#, no-wrap
msgid "# ifconfig wlan0 create wlandev ath0 country FR ssid my_router up\n"
msgstr "# ifconfig wlan0 create wlandev ath0 country FR ssid my_router up\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2434
msgid "Now you can determine the MAC address of the wireless interface:"
msgstr "이제 무선 인터페이스의 MAC 주소를 확인할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2449
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\tether b8:ee:65:5b:32:59\n"
"\tgroups: wlan\n"
"\tssid Bbox-A3BD2403 channel 6 (2437 MHz 11g ht/20) bssid 00:37:b7:56:4b:60\n"
"\tregdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON\n"
"\tdeftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60\n"
"\tprotmode CTS ampdulimit 64k ampdudensity 8 shortgi -stbctx stbcrx\n"
"\t-ldpc wme burst roaming MANUAL\n"
"\tmedia: IEEE 802.11 Wireless Ethernet MCS mode 11ng\n"
"\tstatus: associated\n"
"\tnd6 options=29<PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL>\n"
msgstr ""
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\tether b8:ee:65:5b:32:59\n"
"\tgroups: wlan\n"
"\tssid Bbox-A3BD2403 channel 6 (2437 MHz 11g ht/20) bssid 00:37:b7:56:4b:60\n"
"\tregdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON\n"
"\tdeftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60\n"
"\tprotmode CTS ampdulimit 64k ampdudensity 8 shortgi -stbctx stbcrx\n"
"\t-ldpc wme burst roaming MANUAL\n"
"\tmedia: IEEE 802.11 Wireless Ethernet MCS mode 11ng\n"
"\tstatus: associated\n"
"\tnd6 options=29<PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2453
msgid ""
"The `ether` line will contain the MAC address of the specified interface.  "
"Now, change the MAC address of the Ethernet interface to match:"
msgstr ""
"`ether` 줄에는 지정된 인터페이스의 MAC 주소가 포함됩니다.  이제 이더넷 "
"인터페이스의 MAC 주소를 일치하도록 변경합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2457
#, no-wrap
msgid "# ifconfig re0 ether b8:ee:65:5b:32:59\n"
msgstr "# ifconfig re0 ether b8:ee:65:5b:32:59\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2460
msgid ""
"Make sure the _re0_ interface is up, then create the man:lagg[4] interface "
"with _re0_ as master with failover to _wlan0_:"
msgstr ""
"_re0_ 인터페이스가 가동 중인지 확인한 다음, _wlan0_로 장애 조치하고 _re0_를 "
"마스터로 하여 man:lagg[4] 인터페이스를 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2466
#, no-wrap
msgid ""
"# ifconfig re0 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0\n"
msgstr ""
"# ifconfig re0 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2482
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether b8:ee:65:5b:32:59\n"
"        laggproto failover lagghash l2,l3,l4\n"
"        laggport: re0 flags=5<MASTER,ACTIVE>\n"
"        laggport: wlan0 flags=0<>\n"
"        groups: lagg\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
msgstr ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether b8:ee:65:5b:32:59\n"
"        laggproto failover lagghash l2,l3,l4\n"
"        laggport: re0 flags=5<MASTER,ACTIVE>\n"
"        laggport: wlan0 flags=0<>\n"
"        groups: lagg\n"
"        media: Ethernet autoselect\n"
"        status: active\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2485
msgid "Then, start the DHCP client to obtain an IP address:"
msgstr "그런 다음 DHCP 클라이언트를 시작하여 IP 주소를 얻습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2489
#, no-wrap
msgid "# dhclient lagg0\n"
msgstr "# dhclient lagg0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2501
#, no-wrap
msgid ""
"ifconfig_re0=\"ether b8:ee:65:5b:32:59\"\n"
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA\"\n"
"create_args_wlan0=\"country FR\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"up laggproto failover laggport re0 laggport wlan0 DHCP\"\n"
msgstr ""
"ifconfig_re0=\"ether b8:ee:65:5b:32:59\"\n"
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA\"\n"
"create_args_wlan0=\"country FR\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"up laggproto failover laggport re0 laggport wlan0 DHCP\"\n"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2506
#, no-wrap
msgid "Diskless Operation with PXE"
msgstr "PXE를 사용한 무 디스크 운영"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2512
msgid ""
"The Intel(R) Preboot eXecution Environment (PXE) allows an operating system "
"to boot over the network.  For example, a FreeBSD system can boot over the "
"network and operate without a local disk, using file systems mounted from an "
"NFS server.  PXE support is usually available in the BIOS.  To use PXE when "
"the machine starts, select the `Boot from network` option in the BIOS setup "
"or type a function key during system initialization."
msgstr ""
"인텔(R) 사전 부팅 실행 환경(Preboot eXecution Environment, PXE)을 사용하면 "
"네트워크를 통해 운영 체제를 부팅할 수 있습니다.  예를 들어, FreeBSD 시스템은 "
"네트워크를 통해 부팅하고 로컬 디스크 없이 NFS 서버에서 마운트된 파일 "
"시스템을 사용하여 작동할 수 있습니다.  PXE 지원은 일반적으로 BIOS에서 사용할 "
"수 있습니다.  시스템을 시작할 때 PXE를 사용하려면 BIOS 설정에서 `Boot from "
"network` 옵션을 선택하거나 시스템 초기화 중에 기능 키를 입력합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2514
msgid ""
"In order to provide the files needed for an operating system to boot over "
"the network, a PXE setup also requires properly configured DHCP, TFTP, and "
"NFS servers, where:"
msgstr ""
"운영 체제가 네트워크를 통해 부팅하는 데 필요한 파일을 제공하기 위해 PXE "
"설정에는 DHCP, TFTP 및 NFS 서버가 올바르게 구성되어 있어야 합니다:"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2516
msgid ""
"Initial parameters, such as an IP address, executable boot filename and "
"location, server name, and root path are obtained from the DHCP server."
msgstr ""
"IP 주소, 실행 가능한 부팅 파일 이름 및 위치, 서버 이름 및 루트 경로와 같은 "
"초기 매개 변수는 DHCP 서버에서 가져옵니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2517
msgid "The operating system loader file is booted using TFTP."
msgstr "운영 체제 로더 파일은 TFTP를 사용하여 부팅됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2518
msgid "The file systems are loaded using NFS."
msgstr "파일 시스템은 NFS를 사용하여 로드됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2523
msgid ""
"When a computer PXE boots, it receives information over DHCP about where to "
"obtain the initial boot loader file.  After the host computer receives this "
"information, it downloads the boot loader via TFTP and then executes the "
"boot loader.  In FreeBSD, the boot loader file is [.filename]#/boot/"
"pxeboot#.  After [.filename]#/boot/pxeboot# executes, the FreeBSD kernel is "
"loaded and the rest of the FreeBSD bootup sequence proceeds, as described in "
"crossref:boot[boot,The FreeBSD Booting Process]."
msgstr ""
"컴퓨터 PXE가 부팅되면 DHCP를 통해 초기 부트 로더 파일을 얻을 수 있는 위치에 "
"대한 정보를 수신합니다.  호스트 컴퓨터는 이 정보를 수신한 후 TFTP를 통해 "
"부트 로더를 다운로드한 다음 부트 로더를 실행합니다.  FreeBSD에서 부트 로더 "
"파일은 [.filename]#/boot/pxeboot#입니다.  [.filename]#/boot/pxeboot#이 "
"실행되고 나면 FreeBSD 커널이 로드되고 나머지 FreeBSD 부팅 시퀀스는 "
"crossref:boot[boot,The FreeBSD Booting Process]에 설명된 대로 진행됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2526
msgid ""
"This section describes how to configure these services on a FreeBSD system "
"so that other systems can PXE boot into FreeBSD.  Refer to man:diskless[8] "
"for more information."
msgstr ""
"이 섹션에서는 다른 시스템이 FreeBSD로 PXE 부팅할 수 있도록 FreeBSD "
"시스템에서 이러한 서비스를 구성하는 방법을 설명합니다.  자세한 내용은 "
"man:diskless[8]를 참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2531
msgid ""
"As described, the system providing these services is insecure.  It should "
"live in a protected area of a network and be untrusted by other hosts."
msgstr ""
"설명한 대로 이러한 서비스를 제공하는 시스템은 안전하지 않습니다.  네트워크의 "
"보호된 영역에 있어야 하며 다른 호스트가 신뢰하지 않아야 합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2534
#, no-wrap
msgid "Setting Up the PXE Environment"
msgstr "PXE 환경 설정하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2540
msgid ""
"The steps shown in this section configure the built-in NFS and TFTP "
"servers.  The next section demonstrates how to install and configure the "
"DHCP server.  In this example, the directory which will contain the files "
"used by PXE users is [.filename]#/b/tftpboot/FreeBSD/install#.  It is "
"important that this directory exists and that the same directory name is set "
"in both [.filename]#/etc/inetd.conf# and [.filename]#/usr/local/etc/dhcpd."
"conf#."
msgstr ""
"이 섹션에 표시된 단계는 기본 제공 NFS 및 TFTP 서버를 구성합니다.  다음 "
"섹션에서는 DHCP 서버를 설치하고 구성하는 방법을 설명합니다.  이 예에서 PXE "
"사용자가 사용하는 파일이 들어 있는 디렉터리는 [.filename]#/b/tftpboot/"
"FreeBSD/install#입니다.  이 디렉터리가 존재해야 하며 [.filename]#/etc/inetd."
"conf#와 [.filename]#/usr/local/etc/dhcpd.conf#에 동일한 디렉터리 이름이 "
"설정되어 있어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2545
msgid ""
"The command examples below assume use of the man:sh[1] shell.  man:csh[1] "
"and man:tcsh[1] users will need to start a man:sh[1] shell or adapt the "
"commands to man:csh[1] syntax."
msgstr ""
"아래 명령 예제는 man:sh[1] 셸을 사용한다고 가정합니다. man:csh[1] 및 "
"man:tcsh[1] 사용자는 man:sh[1] 셸을 시작하거나 명령을 man:csh[1] 구문에 맞게 "
"조정해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2549
msgid ""
"Create the root directory which will contain a FreeBSD installation to be "
"NFS mounted:"
msgstr "NFS를 마운트할 FreeBSD 설치가 포함될 루트 디렉터리를 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2554
#, no-wrap
msgid ""
"# export NFSROOTDIR=/b/tftpboot/FreeBSD/install\n"
"# mkdir -p ${NFSROOTDIR}\n"
msgstr ""
"# export NFSROOTDIR=/b/tftpboot/FreeBSD/install\n"
"# mkdir -p ${NFSROOTDIR}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2557
msgid "Enable the NFS server by adding this line to [.filename]#/etc/rc.conf#:"
msgstr "이 줄을 [.filename]#/etc/rc.conf#에 추가하여 NFS 서버를 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2561
#, no-wrap
msgid "nfs_server_enable=\"YES\"\n"
msgstr "nfs_server_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2564
msgid ""
"Export the diskless root directory via NFS by adding the following to [."
"filename]#/etc/exports#:"
msgstr "[.filename]#/etc/exports#에 다음을 추가하여 NFS를 통해 디스크 없는 루트 "
"디렉터리를 내보냅니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2568
#, no-wrap
msgid "/b -ro -alldirs -maproot=root\n"
msgstr "/b -ro -alldirs -maproot=root\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2571
msgid "Start the NFS server:"
msgstr "NFS server를 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2575
#, no-wrap
msgid "# service nfsd start\n"
msgstr "# service nfsd start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2578
msgid ""
"Enable man:inetd[8] by adding the following line to [.filename]#/etc/rc."
"conf#:"
msgstr "[.filename]#/etc/rc.conf#에 다음 줄을 추가하여 man:inetd[8]을 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2582
#, no-wrap
msgid "inetd_enable=\"YES\"\n"
msgstr "inetd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2585
msgid ""
"Uncomment the following line in [.filename]#/etc/inetd.conf# by making sure "
"it does not start with a `+#+` symbol:"
msgstr ""
"[.filename]#/etc/inetd.conf#의 다음 줄이 `+#+` 기호로 시작하지 않는지 "
"확인하여 주석 처리를 해제합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2589
#, no-wrap
msgid "tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot\n"
msgstr "tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2595
msgid ""
"Some PXE versions require the TCP version of TFTP.  In this case, uncomment "
"the second `tftp` line which contains `stream tcp`."
msgstr ""
"일부 PXE 버전은 TFTP의 TCP 버전이 필요합니다.  이 경우 `stream tcp`가 포함된 "
"두 번째 `tftp` 줄의 주석 처리를 해제합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2598
msgid "Start man:inetd[8]:"
msgstr "man:inetd[8]를 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2602
#, no-wrap
msgid "# service inetd start\n"
msgstr "# service inetd start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2605
msgid ""
"Install the base system into [.filename]#${NFSROOTDIR}#, either by "
"decompressing the official archives or by rebuilding the FreeBSD kernel and "
"userland (refer to crossref:cutting-edge[makeworld,“Updating FreeBSD from "
"Source”] for more detailed instructions, but do not forget to add `DESTDIR=_"
"${NFSROOTDIR}_` when running the `make installkernel` and `make "
"installworld` commands."
msgstr ""
"공식 아카이브의 압축을 풀거나 FreeBSD 커널과 사용자 공간을 다시 빌드하여 [."
"filename]#${NFSROOTDIR}#에 기본 시스템을 설치합니다(자세한 지침은 crossref"
":cutting-edge[makeworld,“Updating FreeBSD from Source”]를 참고하되, `make "
"installkernel` 및 `make installworld` 명령을 실행할 때 "
"`DESTDIR=_${NFSROOTDIR}_`를 추가하는 것을 잊지 마세요)."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2606
msgid ""
"Test that the TFTP server works and can download the boot loader which will "
"be obtained via PXE:"
msgstr "TFTP 서버가 작동하고 PXE를 통해 얻을 수 있는 부트 로더를 다운로드할 수 "
"있는지 테스트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2612
#, no-wrap
msgid ""
"# tftp localhost\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"
msgstr ""
"# tftp localhost\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2615
msgid ""
"Edit [.filename]#${NFSROOTDIR}/etc/fstab# and create an entry to mount the "
"root file system over NFS:"
msgstr ""
"[.filename]#${NFSROOTDIR}/etc/fstab#을 편집하고 NFS를 통해 루트 파일 "
"시스템을 마운트하는 항목을 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2620
#, no-wrap
msgid ""
"# Device                                         Mountpoint    FSType   Options  Dump Pass\n"
"myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0\n"
msgstr ""
"# Device                                         Mountpoint    FSType   "
"Options  Dump Pass\n"
"myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      "
"ro        0    0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2624
msgid ""
"Replace _myhost.example.com_ with the hostname or IP address of the NFS "
"server.  In this example, the root file system is mounted read-only in order "
"to prevent NFS clients from potentially deleting the contents of the root "
"file system."
msgstr ""
"_myhost.example.com_을 NFS 서버의 호스트 이름 또는 IP 주소로 바꿉니다.  이 "
"예제에서는 루트 파일 시스템을 읽기 전용으로 마운트하여 NFS 클라이언트가 루트 "
"파일 시스템의 내용을 삭제할 가능성을 방지합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2625
msgid ""
"Set the root password in the PXE environment for client machines which are "
"PXE booting :"
msgstr "PXE 부팅 중인 클라이언트 머신의 PXE 환경에서 루트 암호를 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2630
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# passwd\n"
msgstr ""
"# chroot ${NFSROOTDIR}\n"
"# passwd\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2633
msgid ""
"If needed, enable man:ssh[1] root logins for client machines which are PXE "
"booting by editing [.filename]#${NFSROOTDIR}/etc/ssh/sshd_config# and "
"enabling `PermitRootLogin`. This option is documented in man:sshd_config[5]."
msgstr ""
"필요한 경우 [.filename]#${NFSROOTDIR}/etc/ssh/sshd_config#를 편집하고 "
"`PermitRootLogin`을 활성화하여 PXE 부팅 중인 클라이언트 시스템에 대해 "
"man:ssh[1] 루트 로그인을 사용하도록 설정합니다. 이 옵션은 man:sshd_config[5]"
"에 문서화되어 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2634
msgid ""
"Perform any other needed customizations of the PXE environment in [."
"filename]#${NFSROOTDIR}#. These customizations could include things like "
"installing packages or editing the password file with man:vipw[8]."
msgstr ""
"[.filename]#${NFSROOTDIR}#에서 필요한 기타 PXE 환경 사용자 지정을 "
"수행합니다. 이러한 사용자 지정에는 패키지 설치 또는 man:vipw[8]를 사용한 "
"비밀번호 파일 편집 등이 포함될 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2637
msgid ""
"When booting from an NFS root volume, [.filename]#/etc/rc# detects the NFS "
"boot and runs [.filename]#/etc/rc.initdiskless#.  In this case, [.filename]#/"
"etc# and [.filename]#/var# need to be memory backed file systems so that "
"these directories are writable but the NFS root directory is read-only:"
msgstr ""
"NFS 루트 볼륨에서 부팅할 때 [.filename]#/etc/rc#는 NFS 부팅을 감지하고 [."
"filename]#/etc/rc.initdiskless#를 실행합니다.  이 경우 [.filename]#/etc# 및 ["
".filename]#/var#는 메모리 백업 파일 시스템이어야 하므로 이러한 디렉터리는 "
"쓰기 가능하지만 NFS 루트 디렉터리는 읽기 전용이 됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2644
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# mkdir -p conf/base\n"
"# tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc\n"
"# tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var\n"
msgstr ""
"# chroot ${NFSROOTDIR}\n"
"# mkdir -p conf/base\n"
"# tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc\n"
"# tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2649
msgid ""
"When the system boots, memory file systems for [.filename]#/etc# and [."
"filename]#/var# will be created and mounted and the contents of the [."
"filename]#cpio.gz# files will be copied into them.  By default, these file "
"systems have a maximum capacity of 5 megabytes.  If your archives do not "
"fit, which is usually the case for [.filename]#/var# when binary packages "
"have been installed, request a larger size by putting the number of 512 byte "
"sectors needed (e.g., 5 megabytes is 10240 sectors) in [.filename]#"
"${NFSROOTDIR}/conf/base/etc/md_size# and [.filename]#${NFSROOTDIR}/conf/base/"
"var/md_size# files for [.filename]#/etc# and [.filename]#/var# file systems "
"respectively."
msgstr ""
"시스템이 부팅되면 [.filename]#/etc# 및 [.filename]#/var#에 대한 메모리 파일 "
"시스템이 생성되어 마운트되고 [.filename]#cpio.gz# 파일의 내용이 여기에 "
"복사됩니다.  기본적으로 이러한 파일 시스템의 최대 용량은 5메가바이트입니다.  "
"바이너리 패키지가 설치된 [.filename]#/var#의 경우처럼 아카이브가 맞지 않는 "
"경우, 필요한 512바이트 섹터 수를 입력하여 더 큰 크기를 요청하세요(예, "
"5메가바이트는 10240개의 섹터)  [.filename]#/etc# 및 [.filename]#/var# 파일 "
"시스템에 대해 각각 [.filename]#${NFSROOTDIR}/conf/base/etc/md_size# 및 [."
"filename]#${NFSROOTDIR}/conf/base/var/md_size# 파일에 넣어서 요청하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2651
#, no-wrap
msgid "Configuring the DHCP Server"
msgstr "DHCP 서버 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2654
msgid ""
"The DHCP server does not need to be the same machine as the TFTP and NFS "
"server, but it needs to be accessible in the network."
msgstr "DHCP 서버는 TFTP 및 NFS 서버와 동일한 컴퓨터일 필요는 없지만 네트워크에서 "
"액세스할 수 있어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2656
msgid ""
"DHCP is not part of the FreeBSD base system but can be installed using the "
"package:net/isc-dhcp44-server[] port or package."
msgstr ""
"DHCP는 FreeBSD 기본 시스템의 일부가 아니지만 package:net/isc-dhcp44-server[] "
"포트 또는 패키지를 사용하여 설치할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2659
msgid ""
"Once installed, edit the configuration file, [.filename]#/usr/local/etc/"
"dhcpd.conf#.  Configure the `next-server`, `filename`, and `root-path` "
"settings as seen in this example:"
msgstr ""
"설치가 완료되면 구성 파일인 [.filename]#/usr/local/etc/dhcpd.conf#를 "
"편집합니다.  이 예제와 같이 `next-server`, `filename`, `root-path` 설정을 "
"구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2669
#, no-wrap
msgid ""
"subnet 192.168.0.0 netmask 255.255.255.0 {\n"
"   range 192.168.0.2 192.168.0.3 ;\n"
"   option subnet-mask 255.255.255.0 ;\n"
"   option routers 192.168.0.1 ;\n"
"   option broadcast-address 192.168.0.255 ;\n"
"   option domain-name-servers 192.168.35.35, 192.168.35.36 ;\n"
"   option domain-name \"example.com\";\n"
msgstr ""
"subnet 192.168.0.0 netmask 255.255.255.0 {\n"
"   range 192.168.0.2 192.168.0.3 ;\n"
"   option subnet-mask 255.255.255.0 ;\n"
"   option routers 192.168.0.1 ;\n"
"   option broadcast-address 192.168.0.255 ;\n"
"   option domain-name-servers 192.168.35.35, 192.168.35.36 ;\n"
"   option domain-name \"example.com\";\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2672
#, no-wrap
msgid ""
"   # IP address of TFTP server\n"
"   next-server 192.168.0.1 ;\n"
msgstr ""
"   # IP address of TFTP server\n"
"   next-server 192.168.0.1 ;\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2675
#, no-wrap
msgid ""
"   # path of boot loader obtained via tftp\n"
"   filename \"FreeBSD/install/boot/pxeboot\" ;\n"
msgstr ""
"   # path of boot loader obtained via tftp\n"
"   filename \"FreeBSD/install/boot/pxeboot\" ;\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2678
#, no-wrap
msgid ""
"   # pxeboot boot loader will try to NFS mount this directory for root FS\n"
"   option root-path \"192.168.0.1:/b/tftpboot/FreeBSD/install/\" ;\n"
msgstr ""
"   # pxeboot boot loader will try to NFS mount this directory for root FS\n"
"   option root-path \"192.168.0.1:/b/tftpboot/FreeBSD/install/\" ;\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2680
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2683
msgid ""
"The `next-server` directive is used to specify the IP address of the TFTP "
"server."
msgstr "`next-server` 지시어는 TFTP 서버의 IP 주소를 지정하는 데 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2686
msgid ""
"The `filename` directive defines the path to [.filename]#/boot/pxeboot#.  A "
"relative filename is used, meaning that [.filename]#/b/tftpboot# is not "
"included in the path."
msgstr ""
"`filename` 지시어는 [.filename]#/boot/pxeboot# 경로를 정의합니다.  상대 "
"파일명이 사용되므로 [.filename]#/b/tftpboot#는 경로에 포함되지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2688
msgid "The `root-path` option defines the path to the NFS root file system."
msgstr "`root-path` 옵션은 NFS 루트 파일 시스템의 경로를 정의합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2690
msgid ""
"Once the edits are saved, enable DHCP at boot time by adding the following "
"line to [.filename]#/etc/rc.conf#:"
msgstr ""
"편집 내용을 저장한 후 [.filename]#/etc/rc.conf#에 다음 줄을 추가하여 부팅 시 "
"DHCP를 사용하도록 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2694
#, no-wrap
msgid "dhcpd_enable=\"YES\"\n"
msgstr "dhcpd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2697
msgid "Then start the DHCP service:"
msgstr "그런 다음 DHCP 서비스를 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2701
#, no-wrap
msgid "# service isc-dhcpd start\n"
msgstr "# service isc-dhcpd start\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2703
#, no-wrap
msgid "Debugging PXE Problems"
msgstr "PXE 문제 디버깅하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2707
msgid ""
"Once all of the services are configured and started, PXE clients should be "
"able to automatically load FreeBSD over the network.  If a particular client "
"is unable to connect, when that client machine boots up, enter the BIOS "
"configuration menu and confirm that it is set to boot from the network."
msgstr ""
"모든 서비스가 구성되고 시작되면, PXE 클라이언트가 네트워크를 통해 자동으로 "
"FreeBSD를 로드할 수 있어야 합니다.  특정 클라이언트가 연결할 수 없는 경우, "
"해당 클라이언트 머신이 부팅될 때 BIOS 구성 메뉴로 들어가서 네트워크에서 "
"부팅하도록 설정되어 있는지 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2709
msgid ""
"This section describes some troubleshooting tips for isolating the source of "
"the configuration problem should no clients be able to PXE boot."
msgstr ""
"이 섹션에서는 클라이언트가 PXE 부팅할 수 없는 경우 구성 문제의 원인을 "
"격리하기 위한 몇 가지 문제 해결 팁에 대해 설명합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2713
msgid ""
"Use the package:net/wireshark[] package or port to debug the network traffic "
"involved during the PXE booting process, which is illustrated in the diagram "
"below."
msgstr ""
"package:net/wireshark[] 패키지 또는 포트를 사용하여 아래 그림과 같이 PXE "
"부팅 프로세스 중에 관련된 네트워크 트래픽을 디버깅합니다."

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2714
#, no-wrap
msgid "PXE Booting Process with NFS Root Mount"
msgstr "NFS 루트 마운트를 사용한 PXE 부팅 프로세스"

#. type: Target for macro image
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2715
#, no-wrap
msgid "pxe-nfs.png"
msgstr "pxe-nfs.png"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2718
msgid "Client broadcasts a DHCPDISCOVER message."
msgstr "클라이언트가 DHCPDISCOVER 메시지를 브로드캐스트합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2720
msgid ""
"The DHCP server responds with the IP address, next-server, filename, and "
"root-path values."
msgstr "DHCP 서버는 IP 주소, 다음 서버, 파일 이름 및 루트 경로 값으로 응답합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2722
msgid ""
"The client sends a TFTP request to next-server, asking to retrieve filename."
msgstr "클라이언트는 다음 서버에 파일 이름 검색을 요청하는 TFTP 요청을 보냅니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2724
msgid "The TFTP server responds and sends filename to client."
msgstr "TFTP 서버가 응답하여 파일 이름을 클라이언트로 보냅니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2726
msgid ""
"The client executes filename, which is pxeboot(8), which then loads the "
"kernel. When the kernel executes, the root file system specified by root-"
"path is mounted over NFS."
msgstr ""
"클라이언트는 파일 이름(pxeboot(8))을 실행한 다음 커널을 로드합니다. 커널이 "
"실행되면 root-path로 지정된 루트 파일 시스템이 NFS를 통해 마운트됩니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2728
msgid ""
"On the TFTP server, read [.filename]#/var/log/xferlog# to ensure that [."
"filename]#pxeboot# is being retrieved from the correct location. To test "
"this example configuration:"
msgstr ""
"TFTP 서버에서 [.filename]#/var/log/xferlog#를 읽어 [.filename]#pxeboot#가 "
"올바른 위치에서 검색되고 있는지 확인합니다. 이 예제 구성을 테스트하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2734
#, no-wrap
msgid ""
"# tftp 192.168.0.1\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"
msgstr ""
"# tftp 192.168.0.1\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2737
msgid ""
"The `BUGS` sections in man:tftpd[8] and man:tftp[1] document some "
"limitations with TFTP."
msgstr "man:tftpd[8] 및 man:tftp[1]의 `BUGS` 섹션은 TFTP의 몇 가지 제한 사항을 "
"설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2738
msgid ""
"Make sure that the root file system can be mounted via NFS. To test this "
"example configuration:"
msgstr "루트 파일 시스템을 NFS를 통해 마운트할 수 있는지 확인합니다. 이 예제 구성을 "
"테스트하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2742
#, no-wrap
msgid "# mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt\n"
msgstr "# mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt\n"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2746
#, no-wrap
msgid "IPv6"
msgstr "IPv6"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2750
msgid ""
"IPv6 is the new version of the well known IP protocol, also known as IPv4.  "
"IPv6 provides several advantages over IPv4 as well as many new features:"
msgstr ""
"IPv6는 IPv4로 잘 알려진 IP 프로토콜의 새로운 버전입니다.  IPv6는 IPv4에 비해 "
"여러 가지 장점과 새로운 기능을 제공합니다:"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2752
msgid ""
"Its 128-bit address space allows for "
"340,282,366,920,938,463,463,374,607,431,768,211,456 addresses. This "
"addresses the IPv4 address shortage and eventual IPv4 address exhaustion."
msgstr ""
"128비트 주소 공간은 340,282,366,920,938,463,463,374,607,431,768,211,456개의 "
"주소를 허용합니다. 이를 통해 IPv4 주소 부족과 궁극적인 IPv4 주소 고갈 문제를 "
"해결할 수 있습니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2753
msgid ""
"Routers only store network aggregation addresses in their routing tables, "
"thus reducing the average space of a routing table to 8192 entries. This "
"addresses the scalability issues associated with IPv4, which required every "
"allocated block of IPv4 addresses to be exchanged between Internet routers, "
"causing their routing tables to become too large to allow efficient routing."
msgstr ""
"라우터는 라우팅 테이블에 네트워크 집계 주소만 저장하므로 라우팅 테이블의 "
"평균 공간을 8192개 항목으로 줄일 수 있습니다. 이는 할당된 모든 IPv4 주소 "
"블록을 인터넷 라우터 간에 교환해야 하므로 라우팅 테이블이 너무 커져 효율적인 "
"라우팅이 불가능했던 IPv4와 관련된 확장성 문제를 해결합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2755
msgid ""
"Address autoconfiguration (http://www.ietf.org/rfc/rfc2462.txt[RFC2462])."
msgstr "주소 자동 구성(http://www.ietf.org/rfc/rfc2462.txt[RFC2462])."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2756
msgid "Mandatory multicast addresses."
msgstr "필수 멀티캐스트 주소."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2757
msgid "Built-in IPsec (IP security)."
msgstr "내장형 IPsec(IP 보안)."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2758
msgid "Simplified header structure."
msgstr "간소화된 헤더 구조."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2759
msgid "Support for mobile IP."
msgstr "모바일 IP 지원."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2760
msgid "IPv6-to-IPv4 transition mechanisms."
msgstr "IPv6에서 IPv4로의 전환 메커니즘."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2763
msgid ""
"FreeBSD includes the http://www.kame.net/[http://www.kame.net/] IPv6 "
"reference implementation and comes with everything needed to use IPv6.  This "
"section focuses on getting IPv6 configured and running."
msgstr ""
"FreeBSD에는 http://www.kame.net/[http://www.kame.net/] IPv6 레퍼런스 구현이 "
"포함되어 있으며, IPv6를 사용하는 데 필요한 모든 것을 함께 제공합니다.  이 "
"섹션에서는 IPv6를 구성하고 실행하는 데 중점을 둡니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2764
#, no-wrap
msgid "Background on IPv6 Addresses"
msgstr "IPv6 주소의 배경"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2767
msgid "There are three different types of IPv6 addresses:"
msgstr "IPv6 주소에는 세 가지 유형이 있습니다:"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2768
#, no-wrap
msgid "Unicast"
msgstr "Unicast"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2770
msgid ""
"A packet sent to a unicast address arrives at the interface belonging to the "
"address."
msgstr "유니캐스트 주소로 전송된 패킷은 해당 주소에 속한 인터페이스에 도착합니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2771
#, no-wrap
msgid "Anycast"
msgstr "Anycast"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2775
msgid ""
"These addresses are syntactically indistinguishable from unicast addresses "
"but they address a group of interfaces.  The packet destined for an anycast "
"address will arrive at the nearest router interface.  Anycast addresses are "
"only used by routers."
msgstr ""
"이러한 주소는 구문상 유니캐스트 주소와 구별할 수 없지만 인터페이스 그룹을 "
"주소로 지정합니다.  애니캐스트 주소로 향하는 패킷은 가장 가까운 라우터 "
"인터페이스에 도착합니다.  애니캐스트 주소는 라우터에서만 사용됩니다."

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2776
#, no-wrap
msgid "Multicast"
msgstr "Multicast"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2780
msgid ""
"These addresses identify a group of interfaces.  A packet destined for a "
"multicast address will arrive at all interfaces belonging to the multicast "
"group.  The IPv4 broadcast address, usually `xxx.xxx.xxx.255`, is expressed "
"by multicast addresses in IPv6."
msgstr ""
"이러한 주소는 인터페이스 그룹을 식별합니다.  멀티캐스트 주소로 향하는 패킷은 "
"멀티캐스트 그룹에 속한 모든 인터페이스에 도착합니다.  IPv4 브로드캐스트 주소("
"일반적으로 `xxx.xxx.xxx.255`)는 IPv6에서 멀티캐스트 주소로 표현됩니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2783
msgid ""
"When reading an IPv6 address, the canonical form is represented as `x:x:x:x:"
"x:x:x:x`, where each `x` represents a 16 bit hex value.  An example is `FEBC:"
"A574:382B:23C1:AA49:4592:4EFE:9982`."
msgstr ""
"IPv6 주소를 읽을 때 표준 형식은 `x:x:x:x:x:x:x:x:x`로 표시되며, 여기서 각 `x`"
"는 16비트 16진수 값을 나타냅니다.  예를 들어 "
"`FEBC:A574:382B:23C1:AA49:4592:4EFE:9982`가 있습니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2788
msgid ""
"Often, an address will have long substrings of all zeros.  A `::` (double "
"colon) can be used to replace one substring per address.  Also, up to three "
"leading ``0``s per hex value can be omitted.  For example, `fe80::1` "
"corresponds to the canonical form `fe80:0000:0000:0000:0000:0000:0000:0001`."
msgstr ""
"주소에 0이 모두 포함된 긴 하위 문자열이 있는 경우가 많습니다.  `::`(이중 "
"콜론)을 사용하여 주소당 하나의 하위 문자열을 대체할 수 있습니다.  또한 "
"16진수 값당 선행 ``0``을 최대 3개까지 생략할 수 있습니다.  예를 들어 "
"`fe80::1`은 표준 형식인 `fe80:0000:0000:0000:0000:0000:0000:0000:0001`에 "
"해당합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2791
msgid ""
"A third form is to write the last 32 bits using the well known IPv4 "
"notation.  For example, `2002::10.0.0.1` corresponds to the hexadecimal "
"canonical representation `2002:0000:0000:0000:0000:0000:0a00:0001`, which in "
"turn is equivalent to `2002::a00:1`."
msgstr ""
"세 번째 형식은 잘 알려진 IPv4 표기법을 사용하여 마지막 32비트를 작성하는 "
"것입니다.  예를 들어, `2002::10.0.0.1`은 16진수 정식 표현인 "
"`2002:0000:0000:0000:0000:0000:0a00:0001`에 해당하며, 이는 다시 `2002::a00:1`"
"과 동일합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2793
msgid "To view a FreeBSD system's IPv6 address, use man:ifconfig[8]:"
msgstr "FreeBSD 시스템의 IPv6 주소를 보려면, man:ifconfig[8]을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2797
#, no-wrap
msgid "# ifconfig\n"
msgstr "# ifconfig\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2807
#, no-wrap
msgid ""
"rl0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500\n"
"         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255\n"
"         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1\n"
"         ether 00:00:21:03:08:e1\n"
"         media: Ethernet autoselect (100baseTX )\n"
"         status: active\n"
msgstr ""
"rl0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500\n"
"         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255\n"
"         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1\n"
"         ether 00:00:21:03:08:e1\n"
"         media: Ethernet autoselect (100baseTX )\n"
"         status: active\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2810
msgid ""
"In this example, the [.filename]#rl0# interface is using `fe80::200:21ff:"
"fe03:8e1%rl0`, an auto-configured link-local address which was automatically "
"generated from the MAC address."
msgstr ""
"이 예제에서 [.filename]#rl0# 인터페이스는 MAC 주소에서 자동으로 생성된 자동 "
"구성된 링크-로컬 주소인 `fe80::200:21ff:fe03:8e1%rl0`을 사용하고 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2813
msgid ""
"Some IPv6 addresses are reserved.  A summary of these reserved addresses is "
"seen in <<reservedip6>>:"
msgstr "일부 IPv6 주소는 예약되어 있습니다.  이러한 예약된 주소의 요약은 "
"<<reservedip6>>에서 확인할 수 있습니다:"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2815
#, no-wrap
msgid "Reserved IPv6 Addresses"
msgstr "예약된 IPv6 주소"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2819
#, no-wrap
msgid "IPv6 address"
msgstr "IPv6 주소"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2820
#, no-wrap
msgid "Prefixlength (Bits)"
msgstr "접두사 길이(비트)"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2821
#, no-wrap
msgid "Description"
msgstr "설명"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2823
#, no-wrap
msgid "Notes"
msgstr "참고"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2824
#, no-wrap
msgid "`::`"
msgstr "`::`"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2825
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2830
#, no-wrap
msgid "128 bits"
msgstr "128 bits"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2826
#, no-wrap
msgid "unspecified"
msgstr "unspecified"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2828
#, no-wrap
msgid "Equivalent to `0.0.0.0` in IPv4."
msgstr "IPv4에서 '0.0.0.0'에 해당."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2829
#, no-wrap
msgid "`::1`"
msgstr "`::1`"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2831
#, no-wrap
msgid "loopback address"
msgstr "loopback address"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2833
#, no-wrap
msgid "Equivalent to `127.0.0.1` in IPv4."
msgstr "IPv4에서 `127.0.0.1`에 해당."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2834
#, no-wrap
msgid "`::00:xx:xx:xx:xx`"
msgstr "`::00:xx:xx:xx:xx`"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2835
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2840
#, no-wrap
msgid "96 bits"
msgstr "96 bits"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2836
#, no-wrap
msgid "embedded IPv4"
msgstr "임베디드 IPv4"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2838
#, no-wrap
msgid "The lower 32 bits are the compatible IPv4 address."
msgstr "하위 32비트는 호환 가능한 IPv4 주소입니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2839
#, no-wrap
msgid "`::ff:xx:xx:xx:xx`"
msgstr "`::ff:xx:xx:xx:xx`"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2841
#, no-wrap
msgid "IPv4 mapped IPv6 address"
msgstr "IPv4 매핑된 IPv6 주소"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2843
#, no-wrap
msgid "The lower 32 bits are the IPv4 address for hosts which do not support IPv6."
msgstr "아래쪽 32비트는 IPv6를 지원하지 않는 호스트의 IPv4 주소입니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2844
#, no-wrap
msgid "`fe80::/10`"
msgstr "`fe80::/10`"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2845
#, no-wrap
msgid "10 bits"
msgstr "10 bits"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2846
#, no-wrap
msgid "link-local"
msgstr "link-local"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2848
#, no-wrap
msgid "Equivalent to 169.254.0.0/16 in IPv4."
msgstr "IPv4에서 169.254.0.0/16에 해당."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2849
#, no-wrap
msgid "`fc00::/7`"
msgstr "`fc00::/7`"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2850
#, no-wrap
msgid "7 bits"
msgstr "7 bits"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2851
#, no-wrap
msgid "unique-local"
msgstr "unique-local"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2853
#, no-wrap
msgid "Unique local addresses are intended for local communication and are only routable within a set of cooperating sites."
msgstr "고유 로컬 주소는 로컬 통신을 위한 것으로, 협력 사이트 집합 내에서만 라우팅할 "
"수 있습니다."

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2854
#, no-wrap
msgid "`ff00::`"
msgstr "`ff00::`"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2855
#, no-wrap
msgid "8 bits"
msgstr "8 bits"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2856
#, no-wrap
msgid "multicast"
msgstr "multicast"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2859
#, no-wrap
msgid "``2000::-3fff::``"
msgstr "``2000::-3fff::``"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2860
#, no-wrap
msgid "3 bits"
msgstr "3 bits"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2861
#, no-wrap
msgid "global unicast"
msgstr "global unicast"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2862
#, no-wrap
msgid "All global unicast addresses are assigned from this pool. The first 3 bits are `001`."
msgstr "모든 글로벌 유니캐스트 주소는 이 풀에서 할당됩니다. 처음 3비트는 `001`입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2865
msgid ""
"For further information on the structure of IPv6 addresses, refer to http://"
"www.ietf.org/rfc/rfc3513.txt[RFC3513]."
msgstr ""
"IPv6 주소의 구조에 대한 자세한 내용은 http://www.ietf.org/rfc/rfc3513."
"txt[RFC3513]을 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2866
#, no-wrap
msgid "Configuring IPv6"
msgstr "IPv6 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2869
msgid ""
"To configure a FreeBSD system as an IPv6 client, add these two lines to [."
"filename]#rc.conf#:"
msgstr "FreeBSD 시스템을 IPv6 클라이언트로 구성하려면 [.filename]#rc.conf#에 다음 두 "
"줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2874
#, no-wrap
msgid ""
"ifconfig_rl0_ipv6=\"inet6 accept_rtadv\"\n"
"rtsold_enable=\"YES\"\n"
msgstr ""
"ifconfig_rl0_ipv6=\"inet6 accept_rtadv\"\n"
"rtsold_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2878
msgid ""
"The first line enables the specified interface to receive router "
"advertisement messages.  The second line enables the router solicitation "
"daemon, man:rtsol[8]."
msgstr ""
"첫 번째 줄은 지정된 인터페이스가 라우터 광고 메시지를 수신할 수 있도록 "
"합니다.  두 번째 줄은 라우터 요청 데몬인 man:rtsol[8]을 활성화합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2880
msgid ""
"If the interface needs a statically assigned IPv6 address, add an entry to "
"specify the static address and associated prefix length:"
msgstr "인터페이스에 정적으로 할당된 IPv6 주소가 필요한 경우 항목을 추가하여 정적 "
"주소 및 관련 접두사 길이를 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2884
#, no-wrap
msgid "ifconfig_rl0_ipv6=\"inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64\"\n"
msgstr ""
"ifconfig_rl0_ipv6=\"inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen "
"64\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2887
msgid "To assign a default router, specify its address:"
msgstr "기본 라우터를 지정하려면 주소를 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2891
#, no-wrap
msgid "ipv6_defaultrouter=\"2001:db8:4672:6565::1\"\n"
msgstr "ipv6_defaultrouter=\"2001:db8:4672:6565::1\"\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2893
#, no-wrap
msgid "Connecting to a Provider"
msgstr "서비스 공급업체에 연결하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2896
msgid ""
"In order to connect to other IPv6 networks, one must have a provider or a "
"tunnel that supports IPv6:"
msgstr "다른 IPv6 네트워크에 연결하려면 IPv6를 지원하는 공급자 또는 터널이 있어야 "
"합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2898
msgid "Contact an Internet Service Provider to see if they offer IPv6."
msgstr "인터넷 서비스 제공업체에 문의하여 IPv6를 제공하는지 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2899
msgid ""
"http://www.tunnelbroker.net[Hurricane Electric] offers tunnels with end-"
"points all around the globe."
msgstr ""
"http://www.tunnelbroker.net[Hurricane Electric]은 전 세계 곳곳에 "
"엔드포인트가 있는 터널을 제공합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2903
msgid ""
"Install the package:net/freenet6[] package or port for a dial-up connection."
msgstr "package:net/freenet6[] 패키지 또는 전화 접속 연결을 위한 포트를 설치합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2906
msgid ""
"This section demonstrates how to take the directions from a tunnel provider "
"and convert them into [.filename]#/etc/rc.conf# settings that will persist "
"through reboots."
msgstr ""
"이 섹션에서는 터널 제공업체의 지침을 가져와 재부팅 시에도 유지되는 [."
"filename]#/etc/rc.conf# 설정으로 변환하는 방법을 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2908
msgid ""
"The first [.filename]#/etc/rc.conf# entry creates the generic tunneling "
"interface [.filename]#gif0#:"
msgstr ""
"첫 번째 [.filename]#/etc/rc.conf# 항목은 일반 터널링 인터페이스 [."
"filename]#gif0#을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2912
#, no-wrap
msgid "cloned_interfaces=\"gif0\"\n"
msgstr "cloned_interfaces=\"gif0\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2916
msgid ""
"Next, configure that interface with the IPv4 addresses of the local and "
"remote endpoints.  Replace `_MY_IPv4_ADDR_` and `_REMOTE_IPv4_ADDR_` with "
"the actual IPv4 addresses:"
msgstr ""
"다음으로, 로컬 및 원격 엔드포인트의 IPv4 주소로 해당 인터페이스를 "
"구성합니다.  `_MY_IPv4_ADDR_` 및 `_REMOTE_IPv4_ADDR_`을 실제 IPv4 주소로 "
"바꿉니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2920
#, no-wrap
msgid "create_args_gif0=\"tunnel MY_IPv4_ADDR REMOTE_IPv4_ADDR\"\n"
msgstr "create_args_gif0=\"tunnel MY_IPv4_ADDR REMOTE_IPv4_ADDR\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2923
msgid ""
"To apply the IPv6 address that has been assigned for use as the IPv6 tunnel "
"endpoint, add this line, replacing `_MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR_` "
"with the assigned address:"
msgstr ""
"IPv6 터널 엔드포인트로 사용하도록 할당된 IPv6 주소를 적용하려면 이 줄을 "
"추가하고 `_MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR_`을 할당된 주소로 바꿉니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2927
#, no-wrap
msgid "ifconfig_gif0_ipv6=\"inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR\"\n"
msgstr "ifconfig_gif0_ipv6=\"inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2931
msgid ""
"Then, set the default route for the other side of the IPv6 tunnel.  Replace "
"`_MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR_` with the default gateway address "
"assigned by the provider:"
msgstr ""
"그런 다음 IPv6 터널의 반대편에 대한 기본 경로를 설정합니다.  "
"`_MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR_`을 공급자가 지정한 기본 게이트웨이 "
"주소로 바꿉니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2935
#, no-wrap
msgid "ipv6_defaultrouter=\"MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR\"\n"
msgstr "ipv6_defaultrouter=\"MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2938
msgid ""
"If the FreeBSD system will route IPv6 packets between the rest of the "
"network and the world, enable the gateway using this line:"
msgstr ""
"FreeBSD 시스템이 나머지 네트워크와 전 세계 간에 IPv6 패킷을 라우팅하는 경우, "
"이 회선을 사용하여 게이트웨이를 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2942
#, no-wrap
msgid "ipv6_gateway_enable=\"YES\"\n"
msgstr "ipv6_gateway_enable=\"YES\"\n"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2944
#, no-wrap
msgid "Router Advertisement and Host Auto Configuration"
msgstr "라우터 광고 및 호스트 자동 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2947
msgid ""
"This section demonstrates how to setup man:rtadvd[8] to advertise the IPv6 "
"default route."
msgstr "이 섹션에서는 IPv6 기본 경로를 알리기 위해 man:rtadvd[8]를 설정하는 방법을 "
"설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2949
msgid ""
"To enable man:rtadvd[8], add the following to [.filename]#/etc/rc.conf#:"
msgstr "man:rtadvd[8]를 활성화하려면 [.filename]#/etc/rc.conf#에 다음을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2953
#, no-wrap
msgid "rtadvd_enable=\"YES\"\n"
msgstr "rtadvd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2957
msgid ""
"It is important to specify the interface on which to do IPv6 router "
"advertisement.  For example, to tell man:rtadvd[8] to use [.filename]#rl0#:"
msgstr ""
"IPv6 라우터 광고를 수행할 인터페이스를 지정하는 것이 중요합니다.  예를 들어, "
"man:rtadvd[8]에 [.filename]#rl0#을 사용하도록 지시합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2961
#, no-wrap
msgid "rtadvd_interfaces=\"rl0\"\n"
msgstr "rtadvd_interfaces=\"rl0\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2964
msgid ""
"Next, create the configuration file, [.filename]#/etc/rtadvd.conf# as seen "
"in this example:"
msgstr "그런 다음, 이 예시와 같이 구성 파일인 [.filename]#/etc/rtadvd.conf#를 "
"만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2969
#, no-wrap
msgid ""
"rl0:\\\n"
"\t:addrs#1:addr=\"2001:db8:1f11:246::\":prefixlen#64:tc=ether:\n"
msgstr ""
"rl0:\\\n"
"\t:addrs#1:addr=\"2001:db8:1f11:246::\":prefixlen#64:tc=ether:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2972
msgid ""
"Replace [.filename]#rl0# with the interface to be used and `2001:"
"db8:1f11:246::` with the prefix of the allocation."
msgstr "사용할 인터페이스를 [.filename]#rl0#으로 바꾸고 `2001:db8:1f11:246::`을 할당 "
"접두사로 바꿉니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2975
msgid ""
"For a dedicated `/64` subnet, nothing else needs to be changed.  Otherwise, "
"change the `prefixlen#` to the correct value."
msgstr ""
"전용 `/64` 서브넷의 경우 다른 것은 변경할 필요가 없습니다.  그렇지 않으면 "
"`prefixlen#`을 올바른 값으로 변경하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2976
#, no-wrap
msgid "IPv6 and IPv4 Address Mapping"
msgstr "IPv6 및 IPv4 주소 매핑"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2981
msgid ""
"When IPv6 is enabled on a server, there may be a need to enable IPv4 mapped "
"IPv6 address communication.  This compatibility option allows for IPv4 "
"addresses to be represented as IPv6 addresses.  Permitting IPv6 applications "
"to communicate with IPv4 and vice versa may be a security issue."
msgstr ""
"서버에서 IPv6를 사용하도록 설정한 경우, IPv4 매핑된 IPv6 주소 통신을 "
"사용하도록 설정해야 할 수 있습니다.  이 호환성 옵션을 사용하면 IPv4 주소가 "
"IPv6 주소로 표시될 수 있습니다.  IPv6 애플리케이션이 IPv4와 통신하거나 그 "
"반대로 통신하도록 허용하면 보안 문제가 발생할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2986
msgid ""
"This option may not be required in most cases and is available only for "
"compatibility.  This option will allow IPv6-only applications to work with "
"IPv4 in a dual stack environment.  This is most useful for third party "
"applications which may not support an IPv6-only environment.  To enable this "
"feature, add the following to [.filename]#/etc/rc.conf#:"
msgstr ""
"이 옵션은 대부분의 경우 필요하지 않을 수 있으며 호환성을 위해서만 사용할 수 "
"있습니다.  이 옵션을 선택하면 IPv6 전용 애플리케이션이 듀얼 스택 환경에서 "
"IPv4와 함께 작동할 수 있습니다.  이 옵션은 IPv6 전용 환경을 지원하지 않을 수 "
"있는 타사 애플리케이션에 가장 유용합니다.  이 기능을 사용하려면 [.filename]#/"
"etc/rc.conf#에 다음을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2990
#, no-wrap
msgid "ipv6_ipv4mapping=\"YES\"\n"
msgstr "ipv6_ipv4mapping=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2993
msgid ""
"Reviewing the information in RFC 3493, section 3.6 and 3.7 as well as RFC "
"4038 section 4.2 may be useful to some administrators."
msgstr ""
"RFC 3493, 섹션 3.6 및 3.7과 RFC 4038 섹션 4.2의 정보를 검토하는 것이 일부 "
"관리자에게 유용할 수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2995
#, no-wrap
msgid "Common Address Redundancy Protocol (CARP)"
msgstr "공통 주소 중복 프로토콜(Common Address Redundancy Protocol, CARP)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2999
msgid ""
"The Common Address Redundancy Protocol (CARP) allows multiple hosts to share "
"the same IP address and Virtual Host ID (VHID) in order to provide _high "
"availability_ for one or more services.  This means that one or more hosts "
"can fail, and the other hosts will transparently take over so that users do "
"not see a service failure."
msgstr ""
"Common Address Redundancy Protocol (CARP)을 사용하면 여러 호스트가 동일한 IP "
"주소와 가상 호스트 ID(VHID)를 공유하여 하나 이상의 서비스에 대해 고가용성을 "
"제공할 수 있습니다.  즉, 하나 이상의 호스트에 장애가 발생해도 다른 호스트가 "
"투명하게 인계하여 사용자에게 서비스 장애가 표시되지 않도록 할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3003
msgid ""
"In addition to the shared IP address, each host has its own IP address for "
"management and configuration.  All of the machines that share an IP address "
"have the same VHID.  The VHID for each virtual IP address must be unique "
"across the broadcast domain of the network interface."
msgstr ""
"공유 IP 주소 외에도 각 호스트에는 관리 및 구성을 위한 자체 IP 주소가 "
"있습니다.  IP 주소를 공유하는 모든 머신은 동일한 VHID를 갖습니다.  각 가상 "
"IP 주소의 VHID는 네트워크 인터페이스의 브로드캐스트 도메인 전체에서 고유해야 "
"합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3006
msgid ""
"High availability using CARP is built into FreeBSD, though the steps to "
"configure it vary slightly depending upon the FreeBSD version.  This section "
"provides the same example configuration for versions before and equal to or "
"after FreeBSD 10."
msgstr ""
"CARP를 사용하는 고가용성은 FreeBSD에 기본 제공되지만 구성 단계는 FreeBSD "
"버전에 따라 약간 다릅니다.  이 섹션에서는 FreeBSD 10 이전 버전과 동일하거나 "
"그 이후 버전에 대해 동일한 구성 예제를 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3009
msgid ""
"This example configures failover support with three hosts, all with unique "
"IP addresses, but providing the same web content.  It has two different "
"masters named `hosta.example.org` and `hostb.example.org`, with a shared "
"backup named `hostc.example.org`."
msgstr ""
"이 예에서는 모두 고유한 IP 주소를 가지고 있지만 동일한 웹 콘텐츠를 제공하는 "
"세 개의 호스트로 장애 조치 지원을 구성합니다.  이 예제에는 `hosta.example."
"org` 및 `hostb.example.org`라는 두 개의 서로 다른 마스터와 `hostc.example."
"org`라는 공유 백업이 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3016
msgid ""
"These machines are load balanced with a Round Robin DNS configuration.  The "
"master and backup machines are configured identically except for their "
"hostnames and management IP addresses.  These servers must have the same "
"configuration and run the same services.  When the failover occurs, requests "
"to the service on the shared IP address can only be answered correctly if "
"the backup server has access to the same content.  The backup machine has "
"two additional CARP interfaces, one for each of the master content server's "
"IP addresses.  When a failure occurs, the backup server will pick up the "
"failed master machine's IP address."
msgstr ""
"이러한 머신은 라운드 로빈 DNS 구성으로 로드 밸런싱됩니다.  마스터 머신과 "
"백업 머신은 호스트 이름과 관리 IP 주소를 제외하고 동일하게 구성됩니다.  "
"이러한 서버는 동일한 구성을 가져야 하며 동일한 서비스를 실행해야 합니다.  "
"장애 조치 발생 시 백업 서버가 동일한 콘텐츠에 액세스할 수 있는 경우에만 공유 "
"IP 주소의 서비스에 대한 요청에 올바르게 응답할 수 있습니다.  백업 머신에는 "
"마스터 콘텐츠 서버의 각 IP 주소에 대해 하나씩 두 개의 추가 CARP 인터페이스가 "
"있습니다.  장애가 발생하면 백업 서버는 장애가 발생한 마스터 머신의 IP 주소를 "
"선택합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3018
#, no-wrap
msgid "Using CARP on FreeBSD 10 and Later"
msgstr "FreeBSD 10 이상에서 CARP 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3021
msgid ""
"Enable boot-time support for CARP by adding an entry for the [."
"filename]#carp.ko# kernel module in [.filename]#/boot/loader.conf#:"
msgstr ""
"[.filename]#/boot/loader.conf#에 [.filename]#carp.ko# 커널 모듈 항목을 "
"추가하여 CARP에 대한 부팅 시 지원을 사용하도록 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3025
#, no-wrap
msgid "carp_load=\"YES\"\n"
msgstr "carp_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3028
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3109
msgid "To load the module now without rebooting:"
msgstr "재부팅하지 않고 지금 모듈을 로드하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3032
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3113
#, no-wrap
msgid "# kldload carp\n"
msgstr "# kldload carp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3035
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3116
msgid ""
"For users who prefer to use a custom kernel, include the following line in "
"the custom kernel configuration file and compile the kernel as described in "
"crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]:"
msgstr ""
"커스텀 커널을 사용하려는 사용자의 경우 커스텀 커널 구성 파일에 다음 줄을 "
"포함시키고 crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]"
"에 설명된 대로 커널을 컴파일하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3039
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3120
#, no-wrap
msgid "device\tcarp\n"
msgstr "device\tcarp\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3042
msgid ""
"The hostname, management IP address and subnet mask, shared IP address, and "
"VHID are all set by adding entries to [.filename]#/etc/rc.conf#. This "
"example is for `hosta.example.org`:"
msgstr ""
"호스트 이름, 관리 IP 주소 및 서브넷 마스크, 공유 IP 주소, VHID는 모두 [."
"filename]#/etc/rc.conf#에 항목을 추가하여 설정할 수 있습니다. 이 예는 `hosta."
"example.org`에 대한 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3048
#, no-wrap
msgid ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 pass testpass alias 192.168.1.50/32\"\n"
msgstr ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 pass testpass alias 192.168.1.50/32\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3053
msgid ""
"The next set of entries are for `hostb.example.org`.  Since it represents a "
"second master, it uses a different shared IP address and VHID.  However, the "
"passwords specified with `pass` must be identical as CARP will only listen "
"to and accept advertisements from machines with the correct password."
msgstr ""
"다음 항목 세트는 `hostb.example.org`에 대한 항목입니다.  두 번째 마스터를 "
"나타내므로 다른 공유 IP 주소와 VHID를 사용합니다.  그러나 `pass`로 지정된 "
"비밀번호는 동일해야 하며, CARP는 올바른 비밀번호를 가진 컴퓨터의 광고만 "
"수신하고 수락하기 때문입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3059
#, no-wrap
msgid ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 2 pass testpass alias 192.168.1.51/32\"\n"
msgstr ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 2 pass testpass alias 192.168.1.51/32\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3064
msgid ""
"The third machine, `hostc.example.org`, is configured to handle failover "
"from either master.  This machine is configured with two CARPVHIDs, one to "
"handle the virtual IP address for each of the master hosts.  The CARP "
"advertising skew, `advskew`, is set to ensure that the backup host "
"advertises later than the master, since `advskew` controls the order of "
"precedence when there are multiple backup servers."
msgstr ""
"세 번째 머신인 `hostc.example.org`는 두 마스터 중 하나에서 장애 조치를 "
"처리하도록 구성됩니다.  이 머신은 각 마스터 호스트의 가상 IP 주소를 처리하기 "
"위해 두 개의 CARPVHID로 구성됩니다.  백업 서버가 여러 대일 때 우선 순위를 "
"제어하는 `advskew`는 백업 호스트가 마스터 호스트보다 늦게 광고를 하도록 "
"설정되어 있습니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3071
#, no-wrap
msgid ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32\"\n"
"ifconfig_em0_alias1=\"inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32\"\n"
msgstr ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 advskew 100 pass testpass alias 192.168.1."
"50/32\"\n"
"ifconfig_em0_alias1=\"inet vhid 2 advskew 100 pass testpass alias 192.168.1."
"51/32\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3075
msgid ""
"Having two CARPVHIDs configured means that `hostc.example.org` will notice "
"if either of the master servers becomes unavailable.  If a master fails to "
"advertise before the backup server, the backup server will pick up the "
"shared IP address until the master becomes available again."
msgstr ""
"두 개의 CARPVHID를 구성하면 마스터 서버 중 하나를 사용할 수 없게 되면 `hostc."
"example.org`가 이를 알 수 있습니다.  마스터 서버가 백업 서버보다 먼저 알리는 "
"데 실패하면 마스터 서버가 다시 사용할 수 있게 될 때까지 백업 서버가 공유 IP "
"주소를 선택합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3082
msgid ""
"If the original master server becomes available again, `hostc.example.org` "
"will not release the virtual IP address back to it automatically.  For this "
"to happen, preemption has to be enabled.  The feature is disabled by "
"default, it is controlled via the man:sysctl[8] variable `net.inet.carp."
"preempt`.  The administrator can force the backup server to return the IP "
"address to the master:"
msgstr ""
"원래 마스터 서버를 다시 사용할 수 있게 되면 `hostc.example.org`는 가상 IP "
"주소를 자동으로 다시 해제하지 않습니다.  이렇게 하려면 선점 기능을 "
"활성화해야 합니다.  이 기능은 기본적으로 비활성화되어 있으며, man:sysctl[8] "
"변수 `net.inet.carp.preempt`를 통해 제어됩니다.  관리자는 백업 서버가 "
"마스터에게 IP 주소를 반환하도록 강제할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3086
#, no-wrap
msgid "# ifconfig em0 vhid 1 state backup\n"
msgstr "# ifconfig em0 vhid 1 state backup\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3092
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3178
msgid ""
"Once the configuration is complete, either restart networking or reboot each "
"system.  High availability is now enabled."
msgstr "구성이 완료되면 네트워킹을 다시 시작하거나 각 시스템을 재부팅합니다.  이제 "
"고가용성이 활성화되었습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3095
msgid ""
"CARP functionality can be controlled via several man:sysctl[8] variables "
"documented in the man:carp[4] manual pages.  Other actions can be triggered "
"from CARP events by using man:devd[8]."
msgstr ""
"CARP 기능은 man:carp[4] 매뉴얼 페이지에 설명된 여러 man:sysctl[8] 변수를 "
"통해 제어할 수 있습니다.  man:devd[8]를 사용하여 CARP 이벤트에서 다른 작업을 "
"트리거할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3097
#, no-wrap
msgid "Using CARP on FreeBSD 9 and Earlier"
msgstr "FreeBSD 9 및 이전 버전에서 CARP 사용하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3100
msgid ""
"The configuration for these versions of FreeBSD is similar to the one "
"described in the previous section, except that a CARP device must first be "
"created and referred to in the configuration."
msgstr ""
"이러한 버전의 FreeBSD에 대한 구성은 이전 섹션에서 설명한 구성과 유사하지만, "
"먼저 CARP 장치를 생성하고 구성에서 참조해야 한다는 점이 다릅니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3102
msgid ""
"Enable boot-time support for CARP by loading the [.filename]#if_carp.ko# "
"kernel module in [.filename]#/boot/loader.conf#:"
msgstr ""
"[.filename]#/boot/loader.conf#에 [.filename]#if_carp.ko# 커널 모듈을 "
"로드하여 CARP에 대한 부팅 시간 지원을 사용하도록 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3106
#, no-wrap
msgid "if_carp_load=\"YES\"\n"
msgstr "if_carp_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3123
msgid "Next, on each host, create a CARP device:"
msgstr "그런 다음 각 호스트에서 CARP 장치를 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3127
#, no-wrap
msgid "# ifconfig carp0 create\n"
msgstr "# ifconfig carp0 create\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3132
msgid ""
"Set the hostname, management IP address, the shared IP address, and VHID by "
"adding the required lines to [.filename]#/etc/rc.conf#.  Since a virtual "
"CARP device is used instead of an alias, the actual subnet mask of `/24` is "
"used instead of `/32`.  Here are the entries for `hosta.example.org`:"
msgstr ""
"[.filename]#/etc/rc.conf#에 필요한 줄을 추가하여 호스트 이름, 관리 IP 주소, "
"공유 IP 주소 및 VHID를 설정합니다.  별칭 대신 가상 CARP 장치가 사용되므로 "
"실제 서브넷 마스크는 `/32` 대신 `/24`가 사용됩니다.  다음은 `hosta.example."
"org`에 대한 항목입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3139
#, no-wrap
msgid ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 1 pass testpass 192.168.1.50/24\"\n"
msgstr ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 1 pass testpass 192.168.1.50/24\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3142
msgid "On `hostb.example.org`:"
msgstr "`hostb.example.org`에서:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3149
#, no-wrap
msgid ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 2 pass testpass 192.168.1.51/24\"\n"
msgstr ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 2 pass testpass 192.168.1.51/24\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3152
msgid ""
"The third machine, `hostc.example.org`, is configured to handle failover "
"from either of the master hosts:"
msgstr "세 번째 머신인 `hostc.example.org`는 마스터 호스트 중 하나에서 장애 조치를 "
"처리하도록 구성되어 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3160
#, no-wrap
msgid ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0 carp1\"\n"
"ifconfig_carp0=\"vhid 1 advskew 100 pass testpass 192.168.1.50/24\"\n"
"ifconfig_carp1=\"vhid 2 advskew 100 pass testpass 192.168.1.51/24\"\n"
msgstr ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0 carp1\"\n"
"ifconfig_carp0=\"vhid 1 advskew 100 pass testpass 192.168.1.50/24\"\n"
"ifconfig_carp1=\"vhid 2 advskew 100 pass testpass 192.168.1.51/24\"\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3167
msgid ""
"Preemption is disabled in the [.filename]#GENERIC# FreeBSD kernel.  If "
"preemption has been enabled with a custom kernel, `hostc.example.org` may "
"not release the IP address back to the original content server.  The "
"administrator can force the backup server to return the IP address to the "
"master with the command:"
msgstr ""
"[.filename]#GENERIC# FreeBSD 커널에서는 선점 기능이 비활성화되어 있습니다.  "
"사용자 정의 커널에서 선점을 사용하도록 설정한 경우 `hostc.example.org`가 IP "
"주소를 원래 콘텐츠 서버로 다시 릴리스하지 못할 수 있습니다.  관리자는 명령을 "
"사용하여 백업 서버가 IP 주소를 마스터에게 반환하도록 강제할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3171
#, no-wrap
msgid "# ifconfig carp0 down && ifconfig carp0 up\n"
msgstr "# ifconfig carp0 down && ifconfig carp0 up\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3174
msgid ""
"This should be done on the [.filename]#carp# interface which corresponds to "
"the correct host."
msgstr "이 작업은 올바른 호스트에 해당하는 [.filename]#carp# 인터페이스에서 수행해야 "
"합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3180
#, no-wrap
msgid "VLANs"
msgstr "VLANs"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3184
msgid ""
"VLANs are a way of virtually dividing up a network into many different "
"subnetworks, also referred to as segmenting.  Each segment will have its own "
"broadcast domain and be isolated from other VLANs."
msgstr ""
"VLAN은 네트워크를 가상으로 여러 개의 하위 네트워크로 분할하는 방법으로, "
"세그멘테이션이라고도 합니다.  각 세그먼트는 자체 브로드캐스트 도메인을 "
"가지며 다른 VLAN으로부터 격리됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3187
msgid ""
"On FreeBSD, VLANs must be supported by the network card driver.  To see "
"which drivers support vlans, refer to the man:vlan[4] manual page."
msgstr ""
"FreeBSD에서는 네트워크 카드 드라이버가 VLAN을 지원해야 합니다.  어떤 "
"드라이버가 VLAN을 지원하는지 확인하려면 man:vlan[4] 매뉴얼 페이지를 "
"참조하십시오."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3190
msgid ""
"When configuring a VLAN, a couple pieces of information must be known.  "
"First, which network interface? Second, what is the VLAN tag?"
msgstr ""
"VLAN을 구성할 때 몇 가지 정보를 알아야 합니다.  첫째, 어떤 네트워크 "
"인터페이스인가요? 둘째, VLAN 태그는 무엇인가요?"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3192
msgid ""
"To configure VLANs at run time, with a NIC of `em0` and a VLAN tag of `5` "
"the command would look like this:"
msgstr "런타임에 NIC가 `em0`이고 VLAN 태그가 `5`인 VLAN을 구성하려면 명령은 다음과 "
"같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3196
#, no-wrap
msgid "# ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24\n"
msgstr "# ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3201
msgid ""
"See how the interface name includes the NIC driver name and the VLAN tag, "
"separated by a period? This is a best practice to make maintaining the VLAN "
"configuration easy when many VLANs are present on a machine."
msgstr ""
"인터페이스 이름에 마침표로 구분된 NIC 드라이버 이름과 VLAN 태그가 어떻게 "
"포함되는지 보셨나요? 이는 한 머신에 많은 VLAN이 있을 때 VLAN 구성을 쉽게 "
"유지 관리할 수 있는 모범 사례입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3205
msgid ""
"To configure VLANs at boot time, [.filename]#/etc/rc.conf# must be updated.  "
"To duplicate the configuration above, the following will need to be added:"
msgstr ""
"부팅 시 VLAN을 구성하려면 [.filename]#/etc/rc.conf#을 업데이트해야 합니다.  "
"위의 구성을 복제하려면 다음을 추가해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3210
#, no-wrap
msgid ""
"vlans_em0=\"5\"\n"
"ifconfig_em0_5=\"inet 192.168.20.20/24\"\n"
msgstr ""
"vlans_em0=\"5\"\n"
"ifconfig_em0_5=\"inet 192.168.20.20/24\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3213
msgid ""
"Additional VLANs may be added, by simply adding the tag to the `vlans_em0` "
"field and adding an additional line configuring the network on that VLAN "
"tag's interface."
msgstr ""
"`vlans_em0` 필드에 태그를 추가하고 해당 VLAN 태그의 인터페이스에 네트워크를 "
"구성하는 추가 줄을 추가하면 추가 VLAN을 추가할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3217
msgid ""
"It is useful to assign a symbolic name to an interface so that when the "
"associated hardware is changed, only a few configuration variables need to "
"be updated.  For example, security cameras need to be run over VLAN 1 on "
"`em0`.  Later, if the `em0` card is replaced with a card that uses the man:"
"ixgb[4] driver, all references to `em0.1` will not have to change to "
"`ixgb0.1`."
msgstr ""
"인터페이스에 기호 이름을 할당하면 관련 하드웨어가 변경될 때 몇 가지 구성 "
"변수만 업데이트하면 됩니다.  예를 들어, 보안 카메라는 `em0`에서 VLAN 1을 "
"통해 실행되어야 합니다.  나중에 `em0` 카드가 man:ixgb[4] 드라이버를 사용하는 "
"카드로 교체되면 `em0.1`에 대한 모든 참조를 `ixgb0.1`로 변경할 필요가 "
"없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3219
msgid ""
"To configure VLAN `5`, on the NIC `em0`, assign the interface name "
"`cameras`, and assign the interface an IP address of `_192.168.20.20_` with "
"a `24`-bit prefix, use this command:"
msgstr ""
"VLAN `5`를 구성하려면 NIC `em0`에서 인터페이스 이름 `cameras`를 할당하고 "
"인터페이스에 `24`비트 접두사가 있는 `_192.168.20.20_`의 IP 주소를 할당하고 "
"이 명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3223
#, no-wrap
msgid "# ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24\n"
msgstr ""
"# ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/"
"24\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3226
msgid "For an interface named `video`, use the following:"
msgstr "`video`라는 이름의 인터페이스의 경우 다음을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3230
#, no-wrap
msgid "# ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24\n"
msgstr ""
"# ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20."
"20/24\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3233
msgid ""
"To apply the changes at boot time, add the following lines to [.filename]#/"
"etc/rc.conf#:"
msgstr "부팅 시 변경 사항을 적용하려면 [.filename]#/etc/rc.conf#에 다음 줄을 "
"추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:3239
#, no-wrap
msgid ""
"vlans_video=\"cameras\"\n"
"create_args_cameras=\"vlan 5\"\n"
"ifconfig_cameras=\"inet 192.168.20.20/24\"\n"
msgstr ""
"vlans_video=\"cameras\"\n"
"create_args_cameras=\"vlan 5\"\n"
"ifconfig_cameras=\"inet 192.168.20.20/24\"\n"

#, no-wrap
#~ msgid "Command"
#~ msgstr "명령어"
