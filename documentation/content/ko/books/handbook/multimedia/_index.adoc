---
description: 'FreeBSD는 다양한 사운드 카드를 지원하므로 사용자는 FreeBSD 시스템에서 고음질 출력을 즐길 수 있습니다'
next: books/handbook/kernelconfig
part: '파트 II. 일반적인 작업'
path: /books/handbook/
prev: books/handbook/desktop
showBookMenu: 'true'
tags: ["multimedia", "sound card", "MP3", "MythTV", "scanner", "SANE"]
title: '8장. 멀티미디어'
weight: 11
---

[[multimedia]]
= 멀티미디어
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 8
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/multimedia/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[multimedia-synopsis]]
== 요약

FreeBSD는 다양한 사운드 카드를 지원하므로, 사용자는 FreeBSD 시스템에서 고음질 출력을 즐길 수 있습니다. 여기에는 MPEG 오디오 레이어 3(`MP3`), 웨이브 오디오 파일(`WAV`), Ogg Vorbis 및 기타 형식의 오디오를 녹음하고 재생하는 기능이 포함됩니다. FreeBSD 포트 컬렉션에는 녹음된 오디오를 편집하고, 사운드 효과를 추가하고, 연결된 미디 장치를 제어하기 위한 많은 애플리케이션이 포함되어 있습니다.

FreeBSD는 비디오 파일과 ``DVD``의 재생도 지원합니다. FreeBSD 포트 컬렉션에는 다양한 비디오 미디어를 인코딩, 변환 및 재생하는 애플리케이션이 포함되어 있습니다.

이 장에서는 FreeBSD에서 사운드 카드, 비디오 재생, TV 튜너 카드 및 스캐너를 구성하는 방법을 설명합니다. 또한 이러한 장치를 사용할 수 있는 몇 가지 애플리케이션에 대해서도 설명합니다.

이 장을 읽고 나면 다음을 알게 됩니다:

* FreeBSD에서 사운드 카드 구성.
* 사운드 설정 문제 해결.
* MP3 및 기타 오디오의 재생과 인코딩.
* 동영상 재생을 위한 FreeBSD 시스템 준비.
* 'DVD', [.filename]#.mpg# 및 [.filename]#.avi# 파일을 재생.
* `CD` 및 `DVD` 콘텐츠의 파일 추출.
* TV 카드의 구성방법.
* FreeBSD에 MythTV 설치 및 설정
* 이미지 스캐너 구성.
* Bluetooth 헤드셋을 구성.

이 챕터를 읽기 전에 여러분은 다음 사항을 알고 있어야 합니다:

* crossref:ports[ports,Installing Applications: Packages and Ports]에 설명된 대로 애플리케이션을 설치하는 방법을 알고 있어야 합니다.

[[sound-setup]]
== 사운드 카드 설정하기

구성을 시작하기 전에 사운드 카드의 모델과 사용하는 칩을 확인합니다. FreeBSD는 다양한 사운드 카드를 지원합니다. link:{u-rel120-hardware}[Hardware Notes]의 지원되는 오디오 장치 목록을 확인하여 해당 카드가 지원되는지, 어떤 FreeBSD 드라이버를 사용하는지 확인합니다.

사운드 장치를 사용하려면 해당 장치 드라이버를 로드해야 합니다. 가장 쉬운 방법은 man:kldload[8]로 사운드 카드용 커널 모듈을 로드하는 것입니다. 이 예제는 인텔 사양에 따라 내장 오디오 칩셋용 드라이버를 로드합니다:

[source, shell]
....
# kldload snd_hda
....

부팅시 이 드라이버를 자동으로 로딩하려면 [.filename]#/boot/loader.conf#에 드라이버를 추가하세요. 이 명령줄은 다음과 같습니다:

[.programlisting]
....
snd_hda_load="YES"
....

사용 가능한 다른 사운드 모듈은 [.filename]#/boot/defaults/loader.conf#에 나열되어 있습니다. 사용할 드라이버가 확실하지 않은 경우 [.filename]#snd_driver# 모듈을 로드하세요:

[source, shell]
....
# kldload snd_driver
....

이것은 가장 일반적인 사운드 드라이버를 모두 로드하는 메타드라이버로, 올바른 드라이버를 빠르게 검색하는 데 사용할 수 있습니다. 메타드라이버를 [.filename]#/boot/loader.conf#에 추가하여 모든 사운드 드라이버를 로드할 수도 있습니다.

[.filename]#snd_driver# 메타드라이버를 로드한 후 사운드 카드에 대해 어떤 드라이버가 선택되었는지 확인하려면 `cat /dev/sndstat`을 입력합니다.

=== 사운드가 지원되는 커스텀 커널 구성하기

이 섹션은 커스텀 커널에서 사운드 카드를 지원하도록 정적으로 컴파일하는 것을 선호하는 사용자를 위한 것입니다. 커널 재컴파일에 대한 자세한 내용은 [kernelconfig,Configuring the FreeBSD Kernel]를 참조하십시오.

사용자 지정 커널을 사용하여 사운드를 지원하는 경우 오디오 프레임워크 드라이버가 사용자 지정 커널 구성 파일에 있는지 확인하세요:

[.programlisting]
....
device sound
....

다음으로 사운드 카드에 대한 지원을 추가합니다. 이전 섹션의 인텔 사양에 기반한 내장 오디오 칩셋의 예제를 계속하려면 사용자 지정 커널 구성 파일에서 다음 줄을 추가합니다:

[.programlisting]
....
device snd_hda
....

드라이버에 사용할 장치 이름은 드라이버의 설명서 페이지를 참조하세요.

Non-PnP ISA 사운드 카드는 카드의 IRQ 및 I/O 포트 설정을 [.filename]#/boot/device.hints#에 추가해야 할 수 있습니다. 부팅 프로세스 중에 man:loader[8]가 이 파일을 읽고 설정을 커널에 전달합니다. 예를 들어, 구형 Creative SoundBlaster(R) 16 ISA non-PnP 카드는 `snd_sb16`과 함께 man:snd_sbc[4] 드라이버를 사용합니다. 이 카드의 경우 커널 구성 파일에 다음 줄을 추가해야 합니다:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

카드가 `0x220` I/O 포트와 IRQ `5`를 사용하는 경우, 다음 내용도 [.filename]#/boot/device.hints#에 추가해야 합니다:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

[.filename]#/boot/device.hints#에 사용되는 구문은 man:sound[4] 및 사운드 카드 드라이버 설명서 페이지에 설명되어 있습니다.

위에 표시된 설정이 기본값입니다. 경우에 따라 카드에 맞게 IRQ 또는 기타 설정을 변경해야 할 수도 있습니다. 이 카드에 대한 자세한 내용은 man:snd_sbc[4]를 참조하세요.

[[sound-testing]]
=== 사운드 테스트하기

필요한 모듈을 로드하거나 사용자 지정 커널로 재부팅한 후 사운드 카드가 감지되어야 합니다. 확인하려면 `dmesg | grep pcm`을 실행합니다. 이 예는 내장된 Conexant CX20590 칩셋을 시스템에서 가져온 것입니다:

[source, shell]
....
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 5 on hdaa0
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 6 on hdaa0
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> at nid 31,25 and 35,27 on hdaa1
....

다음 명령을 사용하여 사운드 카드의 상태도 확인할 수 있습니다:

[source, shell]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm: 64bit 2009061500/amd64)
Installed devices:
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> (play/rec) default
....

출력은 사운드 카드에 따라 달라집니다. [.filename]#pcm# 장치가 나열되지 않으면 올바른 장치 드라이버가 커널에 로드되었거나 컴파일되었는지 다시 확인하세요. 다음 섹션에는 몇 가지 일반적인 문제와 해결 방법이 나열되어 있습니다.

모든 것이 잘 되었다면, 이제 사운드 카드가 FreeBSD에서 작동할 것입니다. `CD` 또는 `DVD` 드라이브가 사운드 카드에 제대로 연결되어 있다면, 드라이브에 오디오 `CD`를 삽입하고 man:cdcontrol[1]로 재생할 수 있습니다:

[source, shell]
....
% cdcontrol -f /dev/acd0 play 1
....

[WARNING]
====
오디오 ``CD``에는 특수 인코딩이 있으므로 man:mount[8]를 사용하여 마운트해서는 안 됩니다.
====

package:audio/workman[] 등 다양한 애플리케이션은 보다 친숙한 인터페이스를 제공합니다. package:audio/mpg123[]을 포트로 설치하면 MP3 오디오 파일을 들을 수 있습니다.

카드를 테스트하는 또 다른 빠른 방법은 [.filename]#/dev/dsp#로 데이터를 전송하는 것입니다:

[source, shell]
....
% cat filename > /dev/dsp
....

여기서 [.filename]#filename#은 모든 유형의 파일일 수 있습니다. 이 명령을 실행하면 약간의 소음이 발생하여 사운드 카드가 작동 중임을 확인할 수 있습니다.

[NOTE]
====
[.filename]#/dev/dsp*# 디바이스 노드는 필요에 따라 자동으로 생성됩니다. 사용하지 않을 때는 존재하지 않으며 man:ls[1]의 출력에 나타나지 않습니다.
====

[[bluetooth-headset]]
=== 블루투스 사운드 장치 설정하기

블루투스 장치에 연결하는 것은 이 장의 범위를 벗어납니다. 자세한 내용은 crossref:advanced-networking[network-bluetooth,“Bluetooth”]를 참조하세요.

블루투스 사운드 싱크가 FreeBSD의 사운드 시스템과 함께 작동하게 하려면, 사용자는 먼저 package:audio/virtual_oss[]를 설치해야 합니다:

[source, shell]
....
# pkg install virtual_oss
....

package:audio/virtual_oss[]는 커널에 `cuse`를 로드해야 합니다:

[source, shell]
....
# kldload cuse
....

시스템 시작 중에 `cuse`를 로드하려면 다음 명령을 실행합니다:

[source, shell]
....
# echo 'cuse_load=yes' >> /boot/loader.conf
....

헤드폰을 package:audio/virtual_oss[]를 사용하여 사운드 싱크로 사용하려면 블루투스 오디오 장치에 연결한 후 가상 장치를 만들어야 합니다:

[source, shell]
....
# virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp
....

[NOTE]
====
이 예에서 _headphones_은 [.filename]#/etc/bluetooth/hosts#의 호스트 이름입니다. 대신 `BT_ADDR`을 사용할 수 있습니다.
====

자세한 내용은 man:virtual_oss[8]을 참조하세요.

[[troubleshooting]]
=== 사운드 문제 해결

<<multimedia-sound-common-error-messages>>에는 몇 가지 일반적인 오류 메시지와 해결 방법이 나와 있습니다:

[[multimedia-sound-common-error-messages]]
.일반적인 오류 메시지
[cols="1,1", frame="none", options="header"]
|===
| Error
| Solution

|`sb_dspwr(XX) timed out`
|

The I/O port is not set correctly.

|`bad irq XX`
|

The IRQ is set incorrectly. Make sure that the set IRQ and the sound IRQ are the same.

|`xxx: gus pcm not attached, out of memory`
|

There is not enough available memory to use the device.

|`xxx: can't open /dev/dsp!`
|

Type `fstat \| grep dsp` to check if another application is holding the device open. Noteworthy troublemakers are esound and KDE's sound support.
|===

최신 그래픽 카드에는 'HDMI'와 함께 사용할 수 있는 자체 사운드 드라이버가 함께 제공되는 경우가 많습니다. 이 사운드 장치가 사운드 카드 앞에 열거되는 경우가 있는데, 이는 사운드 카드가 기본 재생 장치로 사용되지 않음을 의미합니다. 이 경우 dmesg를 실행하고 `pcm`을 찾습니다. 출력은 다음과 같이 표시됩니다:

[.programlisting]
....
...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 0 nid 1 on hdac0
pcm1: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 1 nid 1 on hdac0
pcm2: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 2 nid 1 on hdac0
pcm3: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: <HDA Realtek ALC889 PCM #0 Analog> at cad 2 nid 1 on hdac1
pcm5: <HDA Realtek ALC889 PCM #1 Analog> at cad 2 nid 1 on hdac1
pcm6: <HDA Realtek ALC889 PCM #2 Digital> at cad 2 nid 1 on hdac1
pcm7: <HDA Realtek ALC889 PCM #3 Digital> at cad 2 nid 1 on hdac1
...
....

이 예제에서는 그래픽 카드(`NVidia`)가 사운드 카드(`Realtek ALC889`) 앞에 열거되어 있습니다. 사운드 카드를 기본 재생 장치로 사용하려면 `hw.snd.default_unit`을 재생용 장치로 변경합니다:

[source, shell]
....
# sysctl hw.snd.default_unit=n
....

여기서 `n`은 사용할 사운드 장치의 번호입니다. 이 예에서는 `4`가 되어야 합니다. 이 변경 사항을 영구적으로 적용하려면 [.filename]#/etc/sysctl.conf#에 다음 줄을 추가합니다:

[.programlisting]
....
hw.snd.default_unit=4
....

package:audio/pulseaudio[]를 사용하는 프로그램은 `hw.snd.default_unit`의 변경 사항을 적용하기 위해 package:audio/pulseaudio[] 데몬을 다시 시작해야 할 수 있습니다. 또는 package:audio/pulseaudio[] 설정을 즉석에서 변경할 수도 있습니다. man:pacmd[1]은 package:audio/pulseaudio[] 데몬에 대한 명령줄 연결을 엽니다:

[source, shell]
....
# pacmd
Welcome to PulseAudio 14.2! Use "help" for usage information.
>>>
....

다음 명령은 이전 예제에서와 같이 기본 싱크를 카드 번호 4로 변경합니다:

[.programlisting]
....
set-default-sink 4
....

[WARNING]
====
명령줄 인터페이스를 종료할 때 `exit` 명령을 사용하지 마세요. package:audio/pulseaudio[] 데몬이 종료됩니다. 대신 kbd:[Ctrl+D]를 사용하세요.
====

[[sound-multiple-sources]]
=== 여러 음원 활용하기

동시에 재생할 수 있는 여러 사운드 소스를 갖는 것이 바람직한 경우가 많습니다. FreeBSD는 "가상 사운드 채널"을 사용하여 커널에서 사운드를 믹싱하여 사운드 카드의 재생을 멀티플렉싱합니다.

가상 채널을 구성하는 데는 3개의 man:sysctl[8] 놉(knob)를 사용할 수 있습니다:

[source, shell]
....
# sysctl dev.pcm.0.play.vchans=4
# sysctl dev.pcm.0.rec.vchans=4
# sysctl hw.snd.maxautovchans=4
....

이번 예제에서는 일상적으로 사용할 수 있는 실제 수인 4개의 가상 채널을 할당합니다. `dev.pcm.0.play.vchans=4`와 `dev.pcm.0.rec.vchans=4`는 모두 장치를 연결한 후 구성할 수 있으며, [.filename]#pcm0#이 재생 및 녹화를 위해 가지고 있는 가상 채널의 개수를 나타냅니다. 하드웨어 드라이버와는 별개로 [.filename]#pcm# 모듈을 로드할 수 있으므로 `hw.snd.maxautovchans`는 오디오 장치가 연결될 때 오디오 장치에 할당되는 가상 채널 수를 나타냅니다. 자세한 내용은 man:pcm[4]를 참조하세요.

[NOTE]
====
디바이스가 사용 중인 동안에는 디바이스의 가상 채널 수를 변경할 수 없습니다. 먼저 음악 플레이어나 사운드 데몬 등 디바이스를 사용하는 모든 프로그램을 닫습니다.
====

올바른 [.filename]#pcm# 장치는 [.filename]#/dev/dsp0#을 요청하는 프로그램에 자동으로 할당됩니다.

=== 믹서 채널의 기본값 설정하기

다양한 믹서 채널의 기본값은 man:pcm[4] 드라이버의 소스 코드에 하드코딩되어 있습니다. 사운드 카드 믹서 레벨은 man:mixer[8] 또는 타사 응용 프로그램 및 데몬을 사용하여 변경할 수 있지만 이는 영구적인 해결책이 아닙니다. 대신 드라이버 수준에서 기본 믹서 값을 설정하려면 이 예제에서와 같이 [.filename]#/boot/device.hints#에 적절한 값을 정의합니다:

[.programlisting]
....
hint.pcm.0.vol="50"
....

이렇게 하면 man:pcm[4] 모듈이 로드될 때 볼륨 채널이 기본값인 `50`으로 설정됩니다.

[[sound-mp3]]
== MP3 오디오

이 섹션에서는 FreeBSD에서 사용할 수 있는 몇 가지 `MP3` 플레이어, 오디오 `CD` 트랙을 추출하는 방법, 그리고 `MP3`를 인코딩하고 디코딩하는 방법에 대해 설명합니다.

[[mp3-players]]
=== MP3 플레이어

인기있는 그래픽 'MP3'플레이어는 Audacious입니다. Winamp 스킨과 추가 플러그인을 지원합니다. 인터페이스는 직관적이며 재생 목록, 그래픽 이퀄라이저 등이 있습니다. Winamp에 익숙하신 분들은 Audacious가 사용하기 쉽다는 것을 알게 될 것입니다. FreeBSD에서는 package:multimedia/audacious[]포트 또는 패키지에서 Audacious를 설치할 수 있습니다. Audacious는 XMMS의 후손입니다.

Package:audio/mpg123[] 패키지 또는 포트는 대체 명령줄 `MP3` 플레이어를 제공합니다. 설치가 완료되면 명령줄에서 재생할 `MP3` 파일을 지정합니다. 시스템에 여러 오디오 장치가 있는 경우 사운드 장치를 지정할 수도 있습니다:

[source, shell]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layers 1, 2 and 3
        version 1.18.1; written and copyright by Michael Hipp and others
        free software (LGPL) without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

다른 `MP3` 플레이어들은 FreeBSD 포트 컬렉션에서 사용할 수 있습니다.

[[rip-cd]]
=== 오디오 `CD` 트랙 리핑

`CD` 또는 `CD` 트랙을 `MP3`로 인코딩하기 전에 `CD`의 오디오 데이터를 하드 드라이브로 리핑해야 합니다. 이 작업은 원시 `CD` 디지털 오디오(`CDDA`) 데이터를 `WAV` 파일로 복사하는 방식으로 수행됩니다.

패키지:sysutils/cdrtools[] 제품군과 함께 설치되는 `cdda2wav` 도구는 ``CD``에서 오디오 정보를 추출하는 데 사용할 수 있습니다.

드라이브에 오디오 'CD'가 있는 경우, 다음 명령을 'root'로 실행하여 전체 'CD'를 트랙별로 개별 'WAV' 파일로 추출할 수 있습니다:

[source, shell]
....
# cdda2wav -D 0,1,0 -B
....

이 예에서 `-D _0,1,0_`는 추출할 `CD`가 포함된 `SCSI` 장치 [.filename]#0,1,0#을 나타냅니다. 시스템에 맞는 올바른 장치 매개변수를 확인하려면 `cdrecord -scanbus`를 사용합니다.

개별 트랙을 추출하려면 `-t`를 사용하여 트랙을 지정합니다:

[source, shell]
....
# cdda2wav -D 0,1,0 -t 7
....

트랙 1부터 7까지와 같이 특정 트랙을 추출하려면 범위를 지정합니다:

[source, shell]
....
# cdda2wav -D 0,1,0 -t 1+7
....

`ATAPI` (`IDE`) `CDROM` 드라이브에서 추출하려면 `SCSI` 단위 번호 대신 장치 이름을 지정합니다. 예를 들어, IDE 드라이브에서 트랙 7을 추출하려면:

[source, shell]
....
# cdda2wav -D /dev/acd0 -t 7
....

또는 `dd`를 사용하여 `ATAPI` 드라이브에서 오디오 트랙을 추출할 수 있습니다(crossref:disks[duplicating-audiocds,“Duplicating Audio CDs”]설명 참조).

[[mp3-encoding]]
=== MP3 인코딩 및 디코딩

Lame은 package:audio/lame[] 포트에서 설치할 수 있는 인기 있는 `MP3` 인코더입니다. 특허 문제로 인해 패키지를 사용할 수 없습니다.

다음 명령은 리핑된 `WAV` 파일 [.filename]#audio01.wav#을 [.filename]#audio01.mp3#로 변환합니다:

[source, shell]
....
# lame -h -b 128 --tt "Foo Song Title" --ta "FooBar Artist" --tl "FooBar Album" \
--ty "2014" --tc "Ripped and encoded by Foo" --tg "Genre" audio01.wav audio01.mp3
....

지정된 128 비트는 표준 'MP3' 비트레이트이며 160 및 192 비트레이트는 더 높은 품질을 제공합니다. 비트 전송률이 높을수록 결과물인 `MP3`의 크기가 커집니다. `-h`는 "더 높은 품질이지만 약간 느린" 모드를 켭니다. `—t`로 시작하는 옵션은 일반적으로 노래 정보를 포함하는 `ID3` 태그를 `MP3` 파일에 포함하도록 지정합니다. 추가 인코딩 옵션은 lame 매뉴얼 페이지에서 찾을 수 있습니다.

``MP3``에서 오디오 ``CD``를 구우려면 먼저 비압축 파일 형식으로 변환해야 합니다. XMMS를 사용하여 `WAV` 형식으로 변환할 수 있으며, mpg123을 사용하여 원시 펄스 코드 변조(`PCM`) 오디오 데이터 형식으로 변환할 수 있습니다.

Mpg123을 사용하여 [.filename]#audio01.mp3#를 변환하려면 `PCM` 파일의 이름을 지정합니다:

[source, shell]
....
# mpg123 -s audio01.mp3 > audio01.pcm
....

XMMS를 사용하여 'MP3'를 'WAV' 형식으로 변환하려면 다음 단계를 따르세요:

[.procedure]
.절차: XMMS에서 `WAV` 형식으로 변환하기
. XMMS를 시작합니다.
. 창을 마우스 오른쪽 버튼으로 클릭하여 XMMS 메뉴를 불러옵니다.
. `Options`에서 `Preferences`을 선택합니다.
. 출력 플러그인을 “Disk Writer Plugin”으로 변경합니다.
. `Configure`을 누릅니다.
. 압축되지 않은 파일을 쓸 디렉터리를 입력하거나 찾아봅니다.
. 평소와 같이 볼륨을 100%로 설정하고 EQ 설정을 끈 상태에서 `MP3` 파일을 XMMS에 로드합니다.
. `Play`을 누릅니다. XMMS가 `MP3`를 재생하는 것처럼 표시되지만 음악은 들리지 않습니다. 실제로는 `MP3`를 파일로 재생하고 있습니다.
. 완료된 후 ``MP3``를 다시 들으려면 기본 출력 플러그인을 이전으로 다시 설정해야 합니다.

`WAV` 및 `PCM` 형식 모두 cdrecord와 함께 사용할 수 있습니다. `WAV` 파일을 사용할 때 각 트랙의 시작 부분에 작은 똑딱 소리가 납니다. 이 소리가 `WAV` 파일의 헤더입니다. package:audio/sox[]포트 또는 패키지를 사용하여 헤더를 제거할 수 있습니다:

[source, shell]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

FreeBSD에서 `CD` 버너를 사용하는 방법에 대한 자세한 내용은 crossref:disks[creating-cds,“Creating and Using CD Media”]를 참고하세요.

[[video-playback]]
== 비디오 재생

비디오 재생을 구성하기 전에 비디오 카드의 모델과 칩셋을 결정하세요. Xorg는 다양한 비디오 카드를 지원하지만 모든 비디오 카드가 좋은 재생 성능을 제공하는 것은 아닙니다. 해당 카드를 사용하여 Xorg 서버에서 지원하는 확장 목록을 확인하려면 Xorg가 실행되는 동안 `xdpyinfo`를 실행하세요.

다양한 플레이어와 옵션을 평가하기 위해 짧은 MPEG 테스트 파일을 준비하는 것이 좋습니다. 일부 `DVD`애플리케이션은 기본적으로 [.filename]#/dev/dvd#에서 `DVD` 미디어를 찾거나 이 장치 이름이 하드코딩되어 있으므로, 적절한 장치에 대한 심볼릭 링크를 만드는 것이 유용할 수 있습니다:

[source, shell]
....
# ln -sf /dev/cd0 /dev/dvd
....

Man:devfs[5]의 특성상 수동으로 생성한 링크는 시스템 재부팅 후에도 지속되지 않습니다. 시스템 부팅 시 심볼릭 링크를 자동으로 다시 생성하려면 [.filename]#/etc/devfs.conf#에 다음 줄을 추가하세요:

[.programlisting]
....
link cd0 dvd
....

`DVD` 복호화는 `DVD` 장치에 대한 쓰기 권한이 필요한 특정 기능을 호출합니다.

공유 메모리 Xorg 인터페이스를 향상시키려면 이 man:sysctl[8] 변수의 값을 늘리는 것이 좋습니다:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== 비디오 성능 결정

Xorg에서 동영상을 표시하는 방법에는 여러 가지가 있으며, 작동하는 방법은 하드웨어에 따라 크게 달라집니다. 아래에 설명된 각 방법은 하드웨어에 따라 품질이 달라질 수 있습니다.

일반적인 비디오 인터페이스는 다음과 같습니다:

. Xorg: 공유 메모리를 사용하는 일반 출력입니다.
. XVideo: 특수 가속을 통해 비디오를 그리기 가능한 개체에 직접 표시할 수 있는 Xorg 인터페이스의 확장 기능입니다. 이 확장 기능은 저사양 컴퓨터에서도 좋은 품질의 재생을 제공합니다. 다음 섹션에서는 이 확장 기능이 실행 중인지 확인하는 방법에 대해 설명합니다.
. `SDL`: 단순 다이렉트미디어 레이어는 여러 운영 체제를 위한 포팅 레이어로, 사운드와 그래픽을 효율적으로 사용하는 크로스 플랫폼 애플리케이션을 개발할 수 있게 해줍니다. `SDL`은 하드웨어에 낮은 수준의 추상화를 제공하여 때때로 Xorg 인터페이스보다 더 효율적일 수 있습니다. FreeBSD에서 `SDL`은 package:dev/sdl20[] 패키지 또는 포트를 사용하여 설치할 수 있습니다.
. `DGA`: 직접 그래픽 액세스(Direct Graphics Access)는 프로그램이 Xorg 서버를 우회하여 프레임버퍼를 직접 변경할 수 있도록 하는 Xorg 확장입니다. 저수준 메모리 매핑에 의존하기 때문에 이를 사용하는 프로그램은 `root`로 실행해야 합니다. `DGA` 확장은 man:dga[1]를 사용하여 테스트하고 벤치마크할 수 있습니다. `DGA`가 실행 중이면 키를 누를 때마다 디스플레이의 색상이 변경됩니다. 종료하려면 kbd:[q]를 누릅니다.
. SVGAlib: 로우 레벨 콘솔 그래픽 레이어입니다.

[[video-interface-xvideo]]
==== XVideo

이 확장 프로그램이 실행 중인지 확인하려면 `xvinfo`를 사용하세요:

[source, shell]
....
% xvinfo
....

결과가 다음과 유사한 경우 카드에 XVideo가 지원됩니다:

[source, shell]
....
X-Video Extension version 2.2
  screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

YUV2 및 YUV12와 같이 나열된 형식은 XVideo의 모든 구현에 있는 것은 아니며, 일부 플레이어는 이러한 형식이 없을 경우 불편을 겪을 수 있습니다.

대신 결과가 다음과 같이 표시되는 경우:

[source, shell]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

해당 카드에서 XVideo가 지원되지 않을 수 있습니다. 즉, 비디오 카드 및 프로세서에 따라 디스플레이가 비디오 렌더링에 필요한 연산 요구 사항을 충족하기가 더 어려워질 수 있습니다.

[[video-ports]]
=== 비디오를 다루는 포트 및 패키지

이 섹션에서는 비디오 재생에 사용할 수 있는 FreeBSD 포트 컬렉션에서 사용할 수 있는 몇 가지 소프트웨어를 소개합니다.

[[video-mplayer]]
==== MPlayer 및 MEncoder

MPlayer는 속도와 유연성을 제공하는 것을 목표로 하는 그래픽 인터페이스 옵션을 갖춘 명령줄 비디오 플레이어입니다. MPlayer에 대한 다른 그래픽 프런트 엔드는 FreeBSD 포트 컬렉션에서 사용할 수 있습니다.

MPlayer는 package:multimedia/mplayer[] 패키지 또는 포트를 사용하여 설치할 수 있습니다. 여러 컴파일 옵션을 사용할 수 있으며 빌드 프로세스 중에 다양한 하드웨어 검사가 수행됩니다. 이러한 이유로 일부 사용자는 패키지 설치보다는 포트 빌드를 선호합니다.

포트를 컴파일할 때 메뉴 옵션을 검토하여 포트에 컴파일할 지원 유형을 결정해야 합니다. 옵션을 선택하지 않으면 MPlayer에서 해당 유형의 비디오 형식을 표시할 수 없습니다. 화살표 키와 스페이스바를 사용하여 필요한 형식을 선택합니다. 완료되면 kbd:[Enter]를 눌러 포트 컴파일 및 설치를 계속합니다.

기본적으로 패키지 또는 포트는 `mplayer` 명령줄 유틸리티와 `gmplayer` 그래픽 유틸리티를 빌드합니다. 동영상을 인코딩하려면 package:multimedia/mencoder[] 포트를 컴파일하세요. 라이선스 제한으로 인해 MEncoder용 패키지는 사용할 수 없습니다.

MPlayer를 처음 실행하면 사용자의 홈 디렉토리에 [.filename]#~/.mplayer#을 생성합니다. 이 하위 디렉터리에는 사용자별 구성 파일의 기본 버전이 들어 있습니다.

이 섹션에서는 몇 가지 일반적인 용도만 설명합니다. 다양한 옵션에 대한 자세한 설명은 mplayer(1)을 참조하세요.

[.filename]#testfile.avi# 파일을 재생하려면 다음 예시와 같이 `-vo`로 비디오 인터페이스를 지정합니다:

[source, shell]
....
% mplayer -vo xv testfile.avi
....

[source, shell]
....
% mplayer -vo sdl testfile.avi
....

[source, shell]
....
% mplayer -vo x11 testfile.avi
....

[source, shell]
....
# mplayer -vo dga testfile.avi
....

[source, shell]
....
# mplayer -vo 'sdl:dga' testfile.avi
....

상대적인 성능은 여러 요인에 따라 달라지고 하드웨어에 따라 크게 달라질 수 있으므로 이러한 옵션을 모두 사용해 볼 가치가 있습니다.

`DVD`를 재생하려면 [.filename]#testfile.avi#를 `dvd://_N_ -dvd-device _DEVICE_`로 바꾸세요. 여기서 _N_은 재생할 타이틀 번호이고 _DEVICE_는 `DVD`의 장치 노드입니다. 예를 들어, [.filename]#/dev/dvd#에서 타이틀 3을 재생해봅니다:

[source, shell]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
기본 `DVD` 장치는 MPlayer 포트 빌드 중에 `WITH_DVD_DEVICE=/path/to/desired/device` 옵션을 포함시켜 정의할 수 있습니다. 기본적으로 장치 이름은 [.filename]#/dev/cd0#입니다. 자세한 내용은 포트의 [.filename]#Makefile.options#에서 확인할 수 있습니다.
====

중지, 일시정지, 진행 등을 하려면 키 바인딩(단축키라고 생각하세요)을 사용합니다. 키 바인딩 목록을 보려면 `mplayer -h`를 실행하거나 mplayer(1)을 읽어보세요.

추가 재생 옵션으로는 전체 화면 모드를 활성화하는 `-fs -zoom`과 성능에 도움이 되는 `-framedrop`이 있습니다.

각 사용자는 [.filename]#~/.mplayer/config#에 다음과 같이 자주 사용하는 옵션을 추가할 수 있습니다:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

`mplayer`를 사용하여 `DVD` 타이틀을 [.filename]#.vob#로 추출할 수 있습니다. `DVD`에서 두 번째 타이틀을 덤프하려면:

[source, shell]
....
# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd
....

출력 파일인 [.filename]#out.vob#은 `MPEG` 형식이 됩니다.

UNIX(R) 비디오에 대한 높은 수준의 전문 지식을 얻고자 하는 사람은 기술자료인 http://www.mplayerhq.hu/DOCS/[mplayerhq.hu/DOCS]를 참조하시기 바랍니다. 이 문서는 버그 리포트를 제출하기 전에 반드시 읽어야 하는 필수 문서로 생각해야 합니다.

`mencoder`를 사용하기 전에 http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html[mplayerhq.hu/DOCS/HTML/en/mencoder.html]에 설명된 옵션을 숙지하는 것이 좋습니다. 화질을 개선하고, 비트 전송률을 낮추고, 형식을 변경하는 방법은 무수히 많으며, 이러한 옵션 중 일부는 성능의 좋고 나쁨을 결정할 수 있습니다. 명령줄 옵션을 잘못 조합하면 `mplayer`로도 재생할 수 없는 출력 파일이 생성될 수 있습니다.

다음은 간단한 예입니다:

[source, shell]
....
% mencoder input.avi -oac copy -ovc copy -o output.avi
....

파일로 추출하려면 `mplayer`에서 `-dumpfile` 옵션을 사용합니다.

MPEG3 오디오 인코딩을 사용하여 [.filename]#input.avi#를 MPEG4 코덱으로 변환하려면 먼저 package:audio/lame[]을 포트로 설치하세요. 라이선스 제한으로 인해 패키지를 사용할 수 없습니다. 설치가 완료되면 다음을 입력합니다:

[source, shell]
....
% mencoder input.avi -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi
....

이렇게 하면 `mplayer` 및 `xine`과 같은 애플리케이션에서 재생할 수 있는 출력이 생성됩니다.

[.filename]#input.avi#를 `dvd://1 -dvd-device /dev/dvd`로 바꾸고 `root`로 실행하여 `DVD` 타이틀을 직접 다시 인코딩할 수 있습니다. 원하는 결과를 얻으려면 몇 번의 시도가 필요할 수 있으므로 제목을 파일에 덤프하고 파일에서 작업하는 것이 좋습니다.

[[video-xine]]
==== Xine 비디오 플레이어

Xine은 재사용 가능한 기본 라이브러리와 플러그인으로 확장할 수 있는, 모듈식 실행 파일을 갖춘 비디오 플레이어입니다. package:multimedia/xine[] 패키지 또는 포트를 사용하여 설치할 수 있습니다.

실제로 Xine을 사용하려면 빠른 비디오 카드가 장착된 빠른 CPU 또는 XVideo 확장을 지원해야 합니다. Xine 동영상 플레이어는 XVideo 인터페이스에서 가장 잘 작동합니다.

기본적으로 Xine 플레이어는 그래픽 사용자 인터페이스를 시작합니다. 그런 다음 메뉴를 사용하여 특정 파일을 열 수 있습니다.

또는 명령줄에서 재생할 파일 이름을 지정하여 Xine을 호출할 수도 있습니다:

[source, shell]
....
% xine -g -p mymovie.avi
....

자세한 정보 및 문제 해결 팁은 http://www.xine-project.org/faq[xine-project.org/faq]를 참조하세요.

[[video-ports-transcode]]
==== 트랜스코드 유틸리티

Transcode(트랜스코드)는 비디오 및 오디오 파일을 다시 인코딩하기 위한 도구 모음을 제공합니다. 트랜스코드는 명령줄 도구를 사용하여 비디오 파일을 병합하거나 손상된 파일을 복구하는 데 사용할 수 있으며, 스트림 인터페이스는 stdin/stdout을 사용합니다.

FreeBSD에서는 package:multimedia/transcode[] 패키지 또는 포트를 사용하여 트랜스코드를 설치할 수 있습니다. 트랜스코드는 컴파일할 지원 및 코덱을 지정할 수 있는 컴파일 옵션 메뉴가 제공되므로 많은 사용자가 포트를 컴파일하는 것을 선호합니다. 옵션을 선택하지 않으면 트랜스코드는 해당 형식을 인코딩할 수 없습니다. 화살표 키와 스페이스바를 사용하여 필요한 형식을 선택합니다. 완료되면 kbd:[Enter]를 눌러 포트 컴파일 및 설치를 계속합니다.

이 예에서는 DivX 파일을 PAL MPEG-1 파일(PAL VCD)로 변환하는 방법을 설명합니다:

[source, shell]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

결과 `MPEG` 파일인 [.filename]#output_vcd.mpg#은 MPlayer로 재생할 수 있습니다. 이 파일을 `CD` 미디어에 구워 package:multimedia/vcdimager[] 또는 package:sysutils/cdrdao[] 등의 유틸리티를 사용하여 비디오 `CD`를 만들 수 있습니다.

'트랜스코드'에 대한 매뉴얼 페이지 외에도 http://www.transcoding.org/cgi-bin/transcode[transcoding.org/cgi-bin/transcode]에서 자세한 정보와 예제를 참조할 수 있습니다.

[[tvcard]]
== TV 카드

TV 카드는 컴퓨터에서 방송 또는 케이블 TV를 시청하는 데 사용할 수 있습니다. 대부분의 카드는 'RCA' 또는 S-비디오 입력을 통해 컴포지트 비디오를 수신하며, 일부 카드에는 'FM' 라디오 튜너가 포함되어 있습니다.

FreeBSD는 man:bktr[4] 드라이버를 통해 Brooktree Bt848/849/878/879 비디오 캡처 칩을 사용하는 PCI 기반 TV 카드를 지원합니다. 이 드라이버는 대부분의 피나클 PCTV 비디오 카드를 지원합니다. TV 카드를 구입하기 전에 지원되는 튜너 목록은 man:bktr[4]를 참조하십시오.

=== 드라이버 로딩하기

카드를 사용하려면 man:bktr[4] 드라이버를 로드해야 합니다. 부팅 시 이 작업을 자동화하려면 [.filename]#/boot/loader.conf#에 다음 내용을 추가하세요:

[.programlisting]
....
bktr_load="YES"
....

또는 TV 카드에 대한 지원을 사용자 정의 커널에 정적으로 컴파일할 수도 있습니다. 이 경우 커스텀 커널 구성 파일에 다음 줄을 추가합니다:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

카드 구성 요소가 I2C 버스를 통해 상호 연결되므로 위와 같은 추가장치의 포함이 필요합니다. 그런 다음 새 커널을 빌드하고 설치합니다.

튜너가 올바르게 감지되는지 테스트하려면 시스템을 재부팅합니다. 다음 예와 같이 부팅 메시지에 TV 카드가 나타나야 합니다:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

메시지는 하드웨어에 따라 달라집니다. 필요한 경우 man:sysctl[8] 또는 사용자 지정 커널 구성 옵션을 사용하여 감지된 매개변수 중 일부를 재정의할 수 있습니다. 예를 들어, 튜너를 필립스 SECAM 튜너로 강제 설정하려면 사용자 지정 커널 구성 파일에 다음 줄을 추가합니다:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

또는 man:sysctl[8]을 사용합니다:

[source, shell]
....
# sysctl hw.bt848.tuner=6
....

사용 가능한 man:sysctl[8] 매개변수 및 커널 옵션에 대한 설명은 man:bktr[4]를 참조하세요.

=== 유용한 애플리케이션

TV 카드를 사용하려면 다음 애플리케이션 중 하나를 설치하세요:

* package:multimedia/fxtv[]는 윈도우 내 TV 및 이미지/오디오/비디오 캡처 기능을 제공합니다.
* package:multimedia/xawtv[]는 비슷한 기능을 가진 또 다른 TV 애플리케이션입니다.
* package:audio/xmradio[]는 TV 카드의 FM 라디오 튜너를 사용하기 위한 애플리케이션을 제공합니다.

더 많은 애플리케이션은 FreeBSD 포트 컬렉션에서 찾아 볼 수 있습니다.

=== 문제 해결

TV 카드에 문제가 발생하면 비디오 캡처 칩과 튜너가 man:bktr[4]에서 지원되는지, 올바른 구성 옵션이 사용되었는지 확인하세요. 추가 지원을 받거나 지원되는 TV 카드에 대해 질문하려면 {freebsd-multimedia} 메일링 리스트를 참조하세요.

[[mythtv]]
== MythTV

MythTV는 인기 있는 오픈 소스 개인용 비디오 녹화기(`PVR`) 애플리케이션입니다. 이 섹션에서는 FreeBSD에 MythTV를 설치하고 설정하는 방법을 설명합니다. MythTV 사용 방법에 대한 자세한 내용은 http://www.mythtv.org/wiki/[mythtv.org/wiki]를 참조하세요.

MythTV에는 프론트엔드와 백엔드가 필요합니다. 이러한 구성 요소는 동일한 시스템에 설치하거나 다른 시스템에 설치할 수 있습니다.

프론트엔드는 package:multimedia/mythtv-frontend[] 패키지 또는 포트를 사용하여 FreeBSD에 설치할 수 있습니다. 또한 crossref:x11[x11,The X Window System]에 설명된 대로 Xorg를 설치 및 구성해야 합니다. 이 시스템에는 X 비디오 모션 보정(`XvMC`)을 지원하는 비디오 카드와 리눅스 적외선 리모컨(`LIRC`)과 호환되는 리모컨(선택 사항)이 있는 것이 이상적입니다.

FreeBSD에 백엔드와 프론트엔드를 모두 설치하려면 package:multimedia/mythtv[] 패키지 또는 포트를 사용합니다. MySQL(TM) 데이터베이스 서버도 필요하며 종속성으로 자동 설치되어야 합니다. 선택 사항으로, 이 시스템에는 튜너 카드와 녹화된 데이터를 저장할 수 있는 충분한 스토리지가 있어야 합니다.

=== 하드웨어

MythTV는 리눅스용 비디오(`V4L`)를 사용하여 인코더나 튜너와 같은 비디오 입력 장치에 접속합니다. FreeBSD에서 MythTV는 `USB` DVB-S/C/T 카드와 가장 잘 작동하는데, 이는 `V4L` 유저랜드 애플리케이션을 제공하는 package:multimedia/webcamd[] 패키지 또는 포트에서 잘 지원되기 때문입니다. Webcamd에서 지원하는 모든 디지털 비디오 방송(`DVB`) 카드는 MythTV와 함께 작동해야 합니다. 알려진 작동 카드 목록은 https://wiki.freebsd.org/WebcamCompat[wiki.freebsd.org/WebcamCompat]에서 확인할 수 있습니다. package:multimedia/pvr250[] 및 package:multimedia/pvrxxx[] 포트의 하퍼지(Hauppauge, TV수신카드) 카드용 드라이버도 사용할 수 있지만, 0.23 이상의 MythTV 버전에서는 작동하지 않는 비표준 드라이버 인터페이스를 제공합니다. 라이선스 제한으로 인해 사용할 수 있는 패키지가 없으며 이 두 포트는 컴파일해야 합니다.

https://wiki.freebsd.org/HTPC[wiki.freebsd.org/HTPC] 페이지에는 사용 가능한 모든 `DVB` 드라이버 목록이 포함되어 있습니다.

=== MythTV 백엔드 설정하기

바이너리 패키지를 사용하여 MythTV를 설치하려면:

[source, shell]
....
# pkg install mythtv
....

또는 포트 컬렉션으로 설치할 수 있습니다:

[source, shell]
....
# cd /usr/ports/multimedia/mythtv
# make install
....

설치가 완료되면 MythTV 데이터베이스를 설정합니다:

[source, shell]
....
# mysql -uroot -p < /usr/local/share/mythtv/database/mc.sql
....

그런 다음 백엔드를 구성합니다:

[source, shell]
....
# mythtv-setup
....

마지막으로 백엔드를 시작합니다:

[source, shell]
....
# sysrc mythbackend_enable=yes
# service mythbackend start
....

[[scanners]]
== 이미지 스캐너

FreeBSD에서 이미지 스캐너에 대한 액세스는 포트 컬렉션에서 SANE(Scanner Access Now Easy)을 받아 할 수 있습니다. SANE은 스캐너 하드웨어에 대한 액세스를 제공하기 위해 일부 FreeBSD 장치 드라이버를 사용하기도 합니다.

FreeBSD는 `SCSI`와 `USB` 스캐너를 모두 지원합니다. 스캐너 인터페이스에 따라 다른 장치 드라이버가 필요합니다. 구성을 수행하기 전에 스캐너가 SANE에서 지원되는지 확인하십시오. 지원되는 스캐너에 대한 자세한 내용은 http://www.sane-project.org/sane-supported-devices.html[http://www.sane-project.org/sane-supported-devices.html]를 참조하십시오.

이 장에서는 스캐너가 FreeBSD에 의해 인식되었는지 확인하는 방법을 설명합니다. 그런 다음, FreeBSD 시스템에서 SANE를 구성하고 사용하는 방법에 대한 개요를 제공합니다.

[[scanners-kernel-usb]]
=== 스캐너 확인하기

[.filename]#GENERIC# 커널에는 `USB` 스캐너를 지원하는 데 필요한 장치 드라이버가 포함되어 있습니다. 사용자 지정 커널을 사용하는 사용자는 사용자 지정 커널 구성 파일에 다음 줄이 있는지 확인해야 합니다:

[.programlisting]
....
device usb
device uhci
device ohci
device ehci
device xhci
....

`USB` 스캐너가 감지되었는지 확인하려면 스캐너를 연결하고 `dmesg`를 사용하여 스캐너가 시스템 메시지 버퍼에 표시되는지 확인합니다. 스캐너가 표시되면 다음과 유사한 메시지가 표시됩니다:

[source, shell]
....
ugen0.2: <EPSON> at usbus0
....

이 예에서는 [.filename]#/dev/ugen0.2#에서 EPSON Perfection(R) 1650 `USB` 스캐너가 확인되었습니다.

스캐너가 `SCSI` 인터페이스를 사용하는 경우, 어떤 `SCSI` 컨트롤러 보드를 사용할 것인지 아는 것이 중요합니다. `SCSI` 칩셋에 따라 사용자 지정 커널 구성 파일이 필요할 수 있습니다. [.filename]#GENERIC# 커널은 가장 일반적인 `SCSI` 컨트롤러를 지원합니다. 사용자 지정 커널 구성 파일에 추가할 올바른 줄을 확인하려면 [.filename]#/usr/src/sys/conf/NOTES#를 참조하세요. 사용자 지정 커널 구성 파일에는 `SCSI` 어댑터 드라이버 외에도 다음 줄이 필요합니다:

[.programlisting]
....
device scbus
device pass
....

장치가 시스템 메시지 버퍼에 표시되는지 확인합니다:

[source, shell]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

시스템 부팅 시 스캐너의 전원이 켜지지 않은 경우에도 `camcontrol`을 사용하여 `SCSI` 버스 스캔을 수행하여 수동으로 강제감지를 할 수 있습니다:

[source, shell]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

이제 스캐너가 `SCSI` 장치 목록에 나타납니다:

[source, shell]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

FreeBSD의 `SCSI` 장치에 대한 자세한 내용은 man:scsi[4] 및 man:camcontrol[8]을 참고하세요.

=== SANE 구성

SANE 시스템은 백엔드를 통해 스캐너에 대한 액세스를 제공합니다(package:graphics/sane-backends[]). 스캐너를 지원하는 백엔드를 확인하려면 http://www.sane-project.org/sane-supported-devices.html[http://www.sane-project.org/sane-supported-devices.html]를 참조하세요. 그래픽 스캐닝 인터페이스는 Kooka(package:graphics/kooka[]) 또는 XSane(package:graphics/xsane[])과 같은 타사 애플리케이션에서 제공합니다. SANE의 백엔드는 스캐너를 테스트하기에 충분합니다.

바이너리 패키지에서 백엔드를 설치하려면:

[source, shell]
....
# pkg install sane-backends
....

또는 포트 컬렉션에서 설치하려면 다음과 같이 하세요

[source, shell]
....
# cd /usr/ports/graphics/sane-backends
# make install clean
....

package:graphics/sane-backends[] 포트 또는 패키지를 설치한 후 `sane-find-scanner`를 사용하여 SANE 시스템에서 스캐너 감지를 확인합니다:

[source, shell]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

출력에는 스캐너의 인터페이스 유형과 스캐너를 시스템에 연결하는 데 사용되는 장치 노드가 표시되어야 합니다. 공급업체와 제품 모델이 표시되거나 표시되지 않을 수 있습니다.

[NOTE]
====
일부 'USB' 스캐너는 펌웨어를 로드해야 합니다. 자세한 내용은 sane-find-scanner(1) 및 sane(7)을 참조하세요.
====

다음으로 스캔 프론트엔드에서 스캐너를 식별할 수 있는지 확인합니다. SANE 백엔드에는 장치를 나열하고 이미지 획득을 수행하는 데 사용할 수 있는 `scanimage`가 포함되어 있습니다. 스캐너 장치를 나열하려면 `-L`을 사용합니다. 첫 번째 예는 `SCSI` 스캐너에 대한 것이고 두 번째 예는 `USB` 스캐너에 대한 것입니다:

[source, shell]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner

# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

이 두 번째 예에서 `epson2`는 백엔드 이름이고 `libusb:000:002`는 [.filename]#/dev/ugen0.2#가 스캐너에서 사용하는 디바이스 노드라는 의미입니다.

`scanimage`가 스캐너를 식별할 수 없는 경우 아래의 메시지가 표시됩니다:

[source, shell]
....
# scanimage -L
No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

이 경우 [.filename]#/usr/local/etc/sane.d/#에서 백엔드 구성 파일을 편집하고 사용되는 스캐너 장치를 정의합니다. 예를 들어, 감지되지 않은 스캐너 모델이 EPSON Perfection(R) 1650이고 `epson2` 백엔드를 사용하는 경우 [.filename]#/usr/local/etc/sane.d/epson2.conf#를 편집합니다. 편집할 때 인터페이스와 사용된 장치 노드를 지정하는 줄을 추가합니다. 이 경우 다음 줄을 추가합니다:

[.programlisting]
....
usb /dev/ugen0.2
....

편집 내용을 저장하고 스캐너가 올바른 백엔드 이름과 장치 노드로 인식되는지 확인합니다:

[source, shell]
....
# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

`scanimage -L`가 스캐너를 인식하면 구성이 완료되고 이제 스캐너를 사용할 준비가 된 것입니다.

`scanimage`를 사용하여 명령줄에서 이미지 획득을 수행할 수 있지만, 이미지 스캔을 수행하려면 그래픽 인터페이스를 사용하는 것이 더 좋습니다. Kooka 또는 XSane과 같은 애플리케이션은 널리 사용되는 스캔용 프론트엔드입니다. 이런 애플리케이션은 다양한 스캔 모드, 색상 보정, 배치 스캔과 같은 고급 기능을 제공합니다. XSane은 GIMP 플러그인으로도 사용할 수 있습니다.

=== 스캐너 권한

스캐너에 액세스하려면 사용자는 스캐너가 사용하는 장치 노드에 대한 읽기 및 쓰기 권한이 필요합니다. 이전 예제에서 `USB` 스캐너는 실제 장치 노드 [.filename]#/dev/ugen0.2#에 대한 심볼릭 링크인 장치 노드 [.filename]#/dev/usb/0.2.0#을 사용했습니다. 심볼릭 링크와 디바이스 노드는 각각 'wheel'과 'operator' 그룹이 소유합니다. 이 그룹에 사용자를 추가하면 스캐너에 대한 액세스가 허용되지만 `wheel`에 사용자를 추가하는 것은 안전하지 않은 방법입니다. 더 나은 해결책은 새로운 그룹을 생성하고 이 그룹의 구성원만 스캐너 장치에 액세스할 수 있도록 하는 것입니다.

이 예제에서는 `_usb_`라는 그룹을 만듭니다:

[source, shell]
....
# pw groupadd usb
....

그런 다음 [.filename]#/dev/ugen0.2# 심볼릭 링크와 [.filename]#/dev/usb/0.2.0# 장치 노드에, `usb` 그룹이 액세스할 수 있도록 [.filename]#/etc/devfs.rules#에 쓰기 권한 `0660` 또는 `0664`를 추가합니다:

[.programlisting]
....
[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb
....

[NOTE]
====
장치를 추가하거나 제거하면 장치 노드가 변경되므로 대신 규칙 집합(ruleset)을 사용하여 모든 USB 장치에 대한 액세스 권한을 부여할 수 있습니다:

[.programlisting]
....
[system=5]
add path 'ugen*' mode 0660 group usb
add path 'usb/*' mode 0666 group usb
....

====

이 파일에 대한 자세한 내용은 man:devfs.rules[5]를 참조하세요.

그런 다음 /etc/rc.conf에서 규칙 집합을 활성화합니다:

[.programlisting]
....
devfs_system_ruleset="system"
....

그리고 man:devfs[8] 시스템을 다시 시작합니다:

[source, shell]
....
# service devfs restart
....

마지막으로, 스캐너에 대한 액세스를 허용하기 위해 사용자를 `_usb_`그룹에 추가합니다:

[source, shell]
....
# pw groupmod usb -m joe
....

자세한 내용은 man:pw[8]을 참조하세요.
