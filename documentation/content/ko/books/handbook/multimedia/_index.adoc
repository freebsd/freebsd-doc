---
description: 'FreeBSD는 다양한 사운드 카드를 지원하므로 사용자는 FreeBSD 시스템에서 고음질 출력을 즐길 수 있습니다'
next: books/handbook/kernelconfig
part: '파트 II. 일반적인 작업'
path: /books/handbook/
prev: books/handbook/desktop
showBookMenu: 'true'
tags: ["multimedia", "sound card", "MP3", "MythTV", "scanner", "SANE"]
title: '8장. 멀티미디어'
weight: 11
---

[[multimedia]]
= 멀티미디어
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 8
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/multimedia/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[multimedia-synopsis]]
== 요약

FreeBSD supports a wide variety of sound cards, allowing users to enjoy high fidelity output from a FreeBSD system. This includes the ability to record and play back audio in the MPEG Audio Layer 3 (`MP3`), Waveform Audio File (`WAV`), Ogg Vorbis, and other formats. The FreeBSD Ports Collection contains many applications for editing recorded audio, adding sound effects, and controlling attached MIDI devices.

FreeBSD also supports the playback of video files and ``DVD``s. The FreeBSD Ports Collection contains applications to encode, convert, and playback various video media.

This chapter describes how to configure sound cards, video playback, TV tuner cards, and scanners on FreeBSD. It also describes some of the applications which are available for using these devices.

이 장을 읽고 나면 다음을 알게 됩니다:

* FreeBSD에서 사운드 카드 구성.
* 사운드 설정 문제 해결.
* MP3 및 기타 오디오의 재생과 인코딩.
* 동영상 재생을 위한 FreeBSD 시스템 준비.
* 'DVD', [.filename]#.mpg# 및 [.filename]#.avi# 파일을 재생.
* `CD` 및 `DVD` 콘텐츠의 파일 추출.
* TV 카드의 구성방법.
* FreeBSD에 MythTV 설치 및 설정
* 이미지 스캐너 구성.
* Bluetooth 헤드셋을 구성.

이 챕터를 읽기 전에 여러분은 다음 사항을 알고 있어야 합니다:

* crossref:ports[ports,Installing Applications: Packages and Ports]에 설명된 대로 애플리케이션을 설치하는 방법을 알고 있어야 합니다.

[[sound-setup]]
== 사운드 카드 설정하기

Before beginning the configuration, determine the model of the sound card and the chip it uses. FreeBSD supports a wide variety of sound cards. Check the supported audio devices list of the link:{u-rel120-hardware}[Hardware Notes] to see if the card is supported and which FreeBSD driver it uses.

In order to use the sound device, its device driver must be loaded. The easiest way is to load a kernel module for the sound card with man:kldload[8]. This example loads the driver for a built-in audio chipset based on the Intel specification:

[source, shell]
....
# kldload snd_hda
....

To automate the loading of this driver at boot time, add the driver to [.filename]#/boot/loader.conf#. The line for this driver is:

[.programlisting]
....
snd_hda_load="YES"
....

Other available sound modules are listed in [.filename]#/boot/defaults/loader.conf#. When unsure which driver to use, load the [.filename]#snd_driver# module:

[source, shell]
....
# kldload snd_driver
....

This is a metadriver which loads all of the most common sound drivers and can be used to speed up the search for the correct driver. It is also possible to load all sound drivers by adding the metadriver to [.filename]#/boot/loader.conf#.

[.filename]#snd_driver# 메타드라이버를 로드한 후 사운드 카드에 대해 어떤 드라이버가 선택되었는지 확인하려면 `cat /dev/sndstat`을 입력합니다.

=== 사운드가 지원되는 커스텀 커널 구성하기

This section is for users who prefer to statically compile in support for the sound card in a custom kernel. For more information about recompiling a kernel, refer to crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel].

사용자 지정 커널을 사용하여 사운드를 지원하는 경우 오디오 프레임워크 드라이버가 사용자 지정 커널 구성 파일에 있는지 확인하세요:

[.programlisting]
....
device sound
....

Next, add support for the sound card. To continue the example of the built-in audio chipset based on the Intel specification from the previous section, use the following line in the custom kernel configuration file:

[.programlisting]
....
device snd_hda
....

드라이버에 사용할 장치 이름은 드라이버의 설명서 페이지를 참조하세요.

Non-PnP ISA sound cards may require the IRQ and I/O port settings of the card to be added to [.filename]#/boot/device.hints#. During the boot process, man:loader[8] reads this file and passes the settings to the kernel. For example, an old Creative SoundBlaster(R) 16 ISA non-PnP card will use the man:snd_sbc[4] driver in conjunction with `snd_sb16`. For this card, the following lines must be added to the kernel configuration file:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

카드가 `0x220` I/O 포트와 IRQ `5`를 사용하는 경우, 다음 내용도 [.filename]#/boot/device.hints#에 추가해야 합니다:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

[.filename]#/boot/device.hints#에 사용되는 구문은 man:sound[4] 및 사운드 카드 드라이버 설명서 페이지에 설명되어 있습니다.

The settings shown above are the defaults. In some cases, the IRQ or other settings may need to be changed to match the card. Refer to man:snd_sbc[4] for more information about this card.

[[sound-testing]]
=== 사운드 테스트하기

After loading the required module or rebooting into the custom kernel, the sound card should be detected. To confirm, run `dmesg | grep pcm`. This example is from a system with a built-in Conexant CX20590 chipset:

[source, shell]
....
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 5 on hdaa0
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> at nid 6 on hdaa0
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> at nid 31,25 and 35,27 on hdaa1
....

다음 명령을 사용하여 사운드 카드의 상태도 확인할 수 있습니다:

[source, shell]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm: 64bit 2009061500/amd64)
Installed devices:
pcm0: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm1: <NVIDIA (0x001c) (HDMI/DP 8ch)> (play)
pcm2: <Conexant CX20590 (Analog 2.0+HP/2.0)> (play/rec) default
....

The output will vary depending upon the sound card. If no [.filename]#pcm# devices are listed, double-check that the correct device driver was loaded or compiled into the kernel. The next section lists some common problems and their solutions.

If all goes well, the sound card should now work in FreeBSD. If the `CD` or `DVD` drive is properly connected to the sound card, one can insert an audio `CD` in the drive and play it with man:cdcontrol[1]:

[source, shell]
....
% cdcontrol -f /dev/acd0 play 1
....

[WARNING]
====
오디오 ``CD``에는 특수 인코딩이 있으므로 man:mount[8]를 사용하여 마운트해서는 안 됩니다.
====

Various applications, such as package:audio/workman[], provide a friendlier interface. The package:audio/mpg123[] port can be installed to listen to MP3 audio files.

카드를 테스트하는 또 다른 빠른 방법은 [.filename]#/dev/dsp#로 데이터를 전송하는 것입니다:

[source, shell]
....
% cat filename > /dev/dsp
....

where [.filename]#filename# can be any type of file. This command should produce some noise, confirming that the sound card is working.

[NOTE]
====
The [.filename]#/dev/dsp*# device nodes will be created automatically as needed. When not in use, they do not exist and will not appear in the output of man:ls[1].
====

[[bluetooth-headset]]
=== 블루투스 사운드 장치 설정하기

Connecting to a Bluetooth device is out of scope for this chapter. Refer to crossref:advanced-networking[network-bluetooth,“Bluetooth”] for more information.

블루투스 사운드 싱크가 FreeBSD의 사운드 시스템과 함께 작동하게 하려면, 사용자는 먼저 package:audio/virtual_oss[]를 설치해야 합니다:

[source, shell]
....
# pkg install virtual_oss
....

package:audio/virtual_oss[]는 커널에 `cuse`를 로드해야 합니다:

[source, shell]
....
# kldload cuse
....

시스템 시작 중에 `cuse`를 로드하려면 다음 명령을 실행합니다:

[source, shell]
....
# echo 'cuse_load=yes' >> /boot/loader.conf
....

헤드폰을 package:audio/virtual_oss[]를 사용하여 사운드 싱크로 사용하려면 블루투스 오디오 장치에 연결한 후 가상 장치를 만들어야 합니다:

[source, shell]
....
# virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/headphones -d dsp
....

[NOTE]
====
_headphones_ in this example is a hostname from [.filename]#/etc/bluetooth/hosts#. `BT_ADDR` could be used instead.
====

자세한 내용은 man:virtual_oss[8]을 참조하세요.

[[troubleshooting]]
=== 사운드 문제 해결

<<multimedia-sound-common-error-messages>>에는 몇 가지 일반적인 오류 메시지와 해결 방법이 나와 있습니다:

[[multimedia-sound-common-error-messages]]
.일반적인 오류 메시지
[cols="1,1", frame="none", options="header"]
|===
| Error
| Solution

|`sb_dspwr(XX) timed out`
|

The I/O port is not set correctly.

|`bad irq XX`
|

The IRQ is set incorrectly. Make sure that the set IRQ and the sound IRQ are the same.

|`xxx: gus pcm not attached, out of memory`
|

There is not enough available memory to use the device.

|`xxx: can't open /dev/dsp!`
|

Type `fstat \| grep dsp` to check if another application is holding the device open. Noteworthy troublemakers are esound and KDE's sound support.
|===

Modern graphics cards often come with their own sound driver for use with `HDMI`. This sound device is sometimes enumerated before the sound card meaning that the sound card will not be used as the default playback device. To check if this is the case, run dmesg and look for `pcm`. The output looks something like this:

[.programlisting]
....
...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 0 nid 1 on hdac0
pcm1: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 1 nid 1 on hdac0
pcm2: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 2 nid 1 on hdac0
pcm3: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: <HDA Realtek ALC889 PCM #0 Analog> at cad 2 nid 1 on hdac1
pcm5: <HDA Realtek ALC889 PCM #1 Analog> at cad 2 nid 1 on hdac1
pcm6: <HDA Realtek ALC889 PCM #2 Digital> at cad 2 nid 1 on hdac1
pcm7: <HDA Realtek ALC889 PCM #3 Digital> at cad 2 nid 1 on hdac1
...
....

In this example, the graphics card (`NVidia`) has been enumerated before the sound card (`Realtek ALC889`). To use the sound card as the default playback device, change `hw.snd.default_unit` to the unit that should be used for playback:

[source, shell]
....
# sysctl hw.snd.default_unit=n
....

where `n` is the number of the sound device to use. In this example, it should be `4`. Make this change permanent by adding the following line to [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
hw.snd.default_unit=4
....

Programs using package:audio/pulseaudio[] might need to restart the package:audio/pulseaudio[] daemon for the changes in `hw.snd.default_unit` to take effect. Alternatively, package:audio/pulseaudio[] settings can be changed on the fly. man:pacmd[1] opens a command line connection to the package:audio/pulseaudio[] daemon:

[source, shell]
....
# pacmd
Welcome to PulseAudio 14.2! Use "help" for usage information.
>>>
....

다음 명령은 이전 예제에서와 같이 기본 싱크를 카드 번호 4로 변경합니다:

[.programlisting]
....
set-default-sink 4
....

[WARNING]
====
명령줄 인터페이스를 종료할 때 `exit` 명령을 사용하지 마세요. package:audio/pulseaudio[] 데몬이 종료됩니다. 대신 kbd:[Ctrl+D]를 사용하세요.
====

[[sound-multiple-sources]]
=== 여러 음원 활용하기

It is often desirable to have multiple sources of sound that are able to play simultaneously. FreeBSD uses "Virtual Sound Channels" to multiplex the sound card's playback by mixing sound in the kernel.

가상 채널을 구성하는 데는 3개의 man:sysctl[8] 놉(knob)를 사용할 수 있습니다:

[source, shell]
....
# sysctl dev.pcm.0.play.vchans=4
# sysctl dev.pcm.0.rec.vchans=4
# sysctl hw.snd.maxautovchans=4
....

This example allocates four virtual channels, which is a practical number for everyday use. Both `dev.pcm.0.play.vchans=4` and `dev.pcm.0.rec.vchans=4` are configurable after a device has been attached and represent the number of virtual channels [.filename]#pcm0# has for playback and recording. Since the [.filename]#pcm# module can be loaded independently of the hardware drivers, `hw.snd.maxautovchans` indicates how many virtual channels will be given to an audio device when it is attached. Refer to man:pcm[4] for more information.

[NOTE]
====
The number of virtual channels for a device cannot be changed while it is in use. First, close any programs using the device, such as music players or sound daemons.
====

올바른 [.filename]#pcm# 장치는 [.filename]#/dev/dsp0#을 요청하는 프로그램에 자동으로 할당됩니다.

=== 믹서 채널의 기본값 설정하기

The default values for the different mixer channels are hardcoded in the source code of the man:pcm[4] driver. While sound card mixer levels can be changed using man:mixer[8] or third-party applications and daemons, this is not a permanent solution. To instead set default mixer values at the driver level, define the appropriate values in [.filename]#/boot/device.hints#, as seen in this example:

[.programlisting]
....
hint.pcm.0.vol="50"
....

이렇게 하면 man:pcm[4] 모듈이 로드될 때 볼륨 채널이 기본값인 `50`으로 설정됩니다.

[[sound-mp3]]
== MP3 오디오

이 섹션에서는 FreeBSD에서 사용할 수 있는 몇 가지 `MP3` 플레이어, 오디오 `CD` 트랙을 추출하는 방법, 그리고 `MP3`를 인코딩하고 디코딩하는 방법에 대해 설명합니다.

[[mp3-players]]
=== MP3 플레이어

A popular graphical `MP3` player is Audacious. It supports Winamp skins and additional plugins. The interface is intuitive, with a playlist, graphic equalizer, and more. Those familiar with Winamp will find Audacious simple to use. On FreeBSD, Audacious can be installed from the package:multimedia/audacious[] port or package. Audacious is a descendant of XMMS.

The package:audio/mpg123[] package or port provides an alternative, command-line `MP3` player. Once installed, specify the `MP3` file to play on the command line. If the system has multiple audio devices, the sound device can also be specified:

[source, shell]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layers 1, 2 and 3
        version 1.18.1; written and copyright by Michael Hipp and others
        free software (LGPL) without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

다른 `MP3` 플레이어들은 FreeBSD 포트 컬렉션에서 사용할 수 있습니다.

[[rip-cd]]
=== 오디오 `CD` 트랙 리핑

Before encoding a `CD` or `CD` track to `MP3`, the audio data on the `CD` must be ripped to the hard drive. This is done by copying the raw `CD` Digital Audio (`CDDA`) data to `WAV` files.

패키지:sysutils/cdrtools[] 제품군과 함께 설치되는 `cdda2wav` 도구는 ``CD``에서 오디오 정보를 추출하는 데 사용할 수 있습니다.

드라이브에 오디오 'CD'가 있는 경우, 다음 명령을 'root'로 실행하여 전체 'CD'를 트랙별로 개별 'WAV' 파일로 추출할 수 있습니다:

[source, shell]
....
# cdda2wav -D 0,1,0 -B
....

In this example, the `-D _0,1,0_` indicates the `SCSI` device [.filename]#0,1,0# containing the `CD` to rip. Use `cdrecord -scanbus` to determine the correct device parameters for the system.

개별 트랙을 추출하려면 `-t`를 사용하여 트랙을 지정합니다:

[source, shell]
....
# cdda2wav -D 0,1,0 -t 7
....

트랙 1부터 7까지와 같이 특정 트랙을 추출하려면 범위를 지정합니다:

[source, shell]
....
# cdda2wav -D 0,1,0 -t 1+7
....

To rip from an `ATAPI` (`IDE`) `CDROM` drive, specify the device name in place of the `SCSI` unit numbers. For example, to rip track 7 from an IDE drive:

[source, shell]
....
# cdda2wav -D /dev/acd0 -t 7
....

또는 `dd`를 사용하여 `ATAPI` 드라이브에서 오디오 트랙을 추출할 수 있습니다(crossref:disks[duplicating-audiocds,“Duplicating Audio CDs”]설명 참조).

[[mp3-encoding]]
=== MP3 인코딩 및 디코딩

Lame is a popular `MP3` encoder which can be installed from the package:audio/lame[] port. Due to patent issues, a package is not available.

다음 명령은 리핑된 `WAV` 파일 [.filename]#audio01.wav#을 [.filename]#audio01.mp3#로 변환합니다:

[source, shell]
....
# lame -h -b 128 --tt "Foo Song Title" --ta "FooBar Artist" --tl "FooBar Album" \
--ty "2014" --tc "Ripped and encoded by Foo" --tg "Genre" audio01.wav audio01.mp3
....

The specified 128 kbits is a standard `MP3` bitrate while the 160 and 192 bitrates provide higher quality. The higher the bitrate, the larger the size of the resulting `MP3`. The `-h` turns on the "higher quality but a little slower" mode. The options beginning with `--t` indicate `ID3` tags, which usually contain song information, to be embedded within the `MP3` file. Additional encoding options can be found in the lame manual page.

In order to burn an audio `CD` from ``MP3``s, they must first be converted to a non-compressed file format. XMMS can be used to convert to the `WAV` format, while mpg123 can be used to convert to the raw Pulse-Code Modulation (`PCM`) audio data format.

Mpg123을 사용하여 [.filename]#audio01.mp3#를 변환하려면 `PCM` 파일의 이름을 지정합니다:

[source, shell]
....
# mpg123 -s audio01.mp3 > audio01.pcm
....

XMMS를 사용하여 'MP3'를 'WAV' 형식으로 변환하려면 다음 단계를 따르세요:

[.procedure]
.절차: XMMS에서 `WAV` 형식으로 변환하기
. XMMS를 시작합니다.
. 창을 마우스 오른쪽 버튼으로 클릭하여 XMMS 메뉴를 불러옵니다.
. `Options`에서 `Preferences`을 선택합니다.
. 출력 플러그인을 “Disk Writer Plugin”으로 변경합니다.
. `Configure`을 누릅니다.
. 압축되지 않은 파일을 쓸 디렉터리를 입력하거나 찾아봅니다.
. 평소와 같이 볼륨을 100%로 설정하고 EQ 설정을 끈 상태에서 `MP3` 파일을 XMMS에 로드합니다.
. `Play`을 누릅니다. XMMS가 `MP3`를 재생하는 것처럼 표시되지만 음악은 들리지 않습니다. 실제로는 `MP3`를 파일로 재생하고 있습니다.
. 완료된 후 ``MP3``를 다시 들으려면 기본 출력 플러그인을 이전으로 다시 설정해야 합니다.

Both the `WAV` and `PCM` formats can be used with cdrecord. When using `WAV` files, there will be a small tick sound at the beginning of each track. This sound is the header of the `WAV` file. The package:audio/sox[] port or package can be used to remove the header:

[source, shell]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

FreeBSD에서 `CD` 버너를 사용하는 방법에 대한 자세한 내용은 crossref:disks[creating-cds,“Creating and Using CD Media”]를 참고하세요.

[[video-playback]]
== 비디오 재생

Before configuring video playback, determine the model and chipset of the video card. While Xorg supports a wide variety of video cards, not all provide good playback performance. To obtain a list of extensions supported by the Xorg server using the card, run `xdpyinfo` while Xorg is running.

It is a good idea to have a short MPEG test file for evaluating various players and options. Since some `DVD` applications look for `DVD` media in [.filename]#/dev/dvd# by default, or have this device name hardcoded in them, it might be useful to make a symbolic link to the proper device:

[source, shell]
....
# ln -sf /dev/cd0 /dev/dvd
....

Due to the nature of man:devfs[5], manually created links will not persist after a system reboot. In order to recreate the symbolic link automatically when the system boots, add the following line to [.filename]#/etc/devfs.conf#:

[.programlisting]
....
link cd0 dvd
....

`DVD` 복호화는 `DVD` 장치에 대한 쓰기 권한이 필요한 특정 기능을 호출합니다.

공유 메모리 Xorg 인터페이스를 향상시키려면 이 man:sysctl[8] 변수의 값을 늘리는 것이 좋습니다:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== 비디오 성능 결정

There are several possible ways to display video under Xorg and what works is largely hardware dependent. Each method described below will have varying quality across different hardware.

일반적인 비디오 인터페이스는 다음과 같습니다:

. Xorg: 공유 메모리를 사용하는 일반 출력입니다.
. XVideo: 특수 가속을 통해 비디오를 그리기 가능한 개체에 직접 표시할 수 있는 Xorg 인터페이스의 확장 기능입니다. 이 확장 기능은 저사양 컴퓨터에서도 좋은 품질의 재생을 제공합니다. 다음 섹션에서는 이 확장 기능이 실행 중인지 확인하는 방법에 대해 설명합니다.
. `SDL`: 단순 다이렉트미디어 레이어는 여러 운영 체제를 위한 포팅 레이어로, 사운드와 그래픽을 효율적으로 사용하는 크로스 플랫폼 애플리케이션을 개발할 수 있게 해줍니다. `SDL`은 하드웨어에 낮은 수준의 추상화를 제공하여 때때로 Xorg 인터페이스보다 더 효율적일 수 있습니다. FreeBSD에서 `SDL`은 package:dev/sdl20[] 패키지 또는 포트를 사용하여 설치할 수 있습니다.
. `DGA`: 직접 그래픽 액세스(Direct Graphics Access)는 프로그램이 Xorg 서버를 우회하여 프레임버퍼를 직접 변경할 수 있도록 하는 Xorg 확장입니다. 저수준 메모리 매핑에 의존하기 때문에 이를 사용하는 프로그램은 `root`로 실행해야 합니다. `DGA` 확장은 man:dga[1]를 사용하여 테스트하고 벤치마크할 수 있습니다. `DGA`가 실행 중이면 키를 누를 때마다 디스플레이의 색상이 변경됩니다. 종료하려면 kbd:[q]를 누릅니다.
. SVGAlib: 로우 레벨 콘솔 그래픽 레이어입니다.

[[video-interface-xvideo]]
==== XVideo

이 확장 프로그램이 실행 중인지 확인하려면 `xvinfo`를 사용하세요:

[source, shell]
....
% xvinfo
....

결과가 다음과 유사한 경우 카드에 XVideo가 지원됩니다:

[source, shell]
....
X-Video Extension version 2.2
  screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

YUV2 및 YUV12와 같이 나열된 형식은 XVideo의 모든 구현에 있는 것은 아니며, 일부 플레이어는 이러한 형식이 없을 경우 불편을 겪을 수 있습니다.

대신 결과가 다음과 같이 표시되는 경우:

[source, shell]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

XVideo is probably not supported for the card. This means that it will be more difficult for the display to meet the computational demands of rendering video, depending on the video card and processor.

[[video-ports]]
=== 비디오를 다루는 포트 및 패키지

이 섹션에서는 비디오 재생에 사용할 수 있는 FreeBSD 포트 컬렉션에서 사용할 수 있는 몇 가지 소프트웨어를 소개합니다.

[[video-mplayer]]
==== MPlayer 및 MEncoder

MPlayer is a command-line video player with an optional graphical interface which aims to provide speed and flexibility. Other graphical front-ends to MPlayer are available from the FreeBSD Ports Collection.

MPlayer can be installed using the package:multimedia/mplayer[] package or port. Several compile options are available and a variety of hardware checks occur during the build process. For these reasons, some users prefer to build the port rather than install the package.

When compiling the port, the menu options should be reviewed to determine the type of support to compile into the port. If an option is not selected, MPlayer will not be able to display that type of video format. Use the arrow keys and spacebar to select the required formats. When finished, press kbd:[Enter] to continue the port compile and installation.

By default, the package or port will build the `mplayer` command line utility and the `gmplayer` graphical utility. To encode videos, compile the package:multimedia/mencoder[] port. Due to licensing restrictions, a package is not available for MEncoder.

The first time MPlayer is run, it will create [.filename]#~/.mplayer# in the user's home directory. This subdirectory contains default versions of the user-specific configuration files.

This section describes only a few common uses. Refer to mplayer(1) for a complete description of its numerous options.

[.filename]#testfile.avi# 파일을 재생하려면 다음 예시와 같이 `-vo`로 비디오 인터페이스를 지정합니다:

[source, shell]
....
% mplayer -vo xv testfile.avi
....

[source, shell]
....
% mplayer -vo sdl testfile.avi
....

[source, shell]
....
% mplayer -vo x11 testfile.avi
....

[source, shell]
....
# mplayer -vo dga testfile.avi
....

[source, shell]
....
# mplayer -vo 'sdl:dga' testfile.avi
....

상대적인 성능은 여러 요인에 따라 달라지고 하드웨어에 따라 크게 달라질 수 있으므로 이러한 옵션을 모두 사용해 볼 가치가 있습니다.

To play a `DVD`, replace [.filename]#testfile.avi# with `dvd://_N_ -dvd-device _DEVICE_`, where _N_ is the title number to play and _DEVICE_ is the device node for the `DVD`. For example, to play title 3 from [.filename]#/dev/dvd#:

[source, shell]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
The default `DVD` device can be defined during the build of the MPlayer port by including the `WITH_DVD_DEVICE=/path/to/desired/device` option. By default, the device is [.filename]#/dev/cd0#. More details can be found in the port's [.filename]#Makefile.options#.
====

To stop, pause, advance, and so on, use a keybinding. To see the list of keybindings, run `mplayer -h` or read mplayer(1).

추가 재생 옵션으로는 전체 화면 모드를 활성화하는 `-fs -zoom`과 성능에 도움이 되는 `-framedrop`이 있습니다.

각 사용자는 [.filename]#~/.mplayer/config#에 다음과 같이 자주 사용하는 옵션을 추가할 수 있습니다:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

`mplayer` can be used to rip a `DVD` title to a [.filename]#.vob#. To dump the second title from a `DVD`:

[source, shell]
....
# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd
....

출력 파일인 [.filename]#out.vob#은 `MPEG` 형식이 됩니다.

Anyone wishing to obtain a high level of expertise with UNIX(R) video should consult http://www.mplayerhq.hu/DOCS/[mplayerhq.hu/DOCS] as it is technically informative. This documentation should be considered as required reading before submitting any bug reports.

Before using `mencoder`, it is a good idea to become familiar with the options described at http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html[mplayerhq.hu/DOCS/HTML/en/mencoder.html]. There are innumerable ways to improve quality, lower bitrate, and change formats, and some of these options may make the difference between good or bad performance. Improper combinations of command line options can yield output files that are unplayable even by `mplayer`.

다음은 간단한 예입니다:

[source, shell]
....
% mencoder input.avi -oac copy -ovc copy -o output.avi
....

파일로 추출하려면 `mplayer`에서 `-dumpfile` 옵션을 사용합니다.

To convert [.filename]#input.avi# to the MPEG4 codec with MPEG3 audio encoding, first install the package:audio/lame[] port. Due to licensing restrictions, a package is not available. Once installed, type:

[source, shell]
....
% mencoder input.avi -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi
....

이렇게 하면 `mplayer` 및 `xine`과 같은 애플리케이션에서 재생할 수 있는 출력이 생성됩니다.

[.filename]#input.avi# can be replaced with `dvd://1 -dvd-device /dev/dvd` and run as `root` to re-encode a `DVD` title directly. Since it may take a few tries to get the desired result, it is recommended to instead dump the title to a file and to work on the file.

[[video-xine]]
==== Xine 비디오 플레이어

xine is a video player with a reusable base library and a modular executable which can be extended with plugins. It can be installed using the package:multimedia/xine[] package or port.

In practice, xine requires either a fast CPU with a fast video card, or support for the XVideo extension. The xine video player performs best on XVideo interfaces.

By default, the xine player starts a graphical user interface. The menus can then be used to open a specific file.

또는 명령줄에서 재생할 파일 이름을 지정하여 Xine을 호출할 수도 있습니다:

[source, shell]
....
% xine -g -p mymovie.avi
....

자세한 정보 및 문제 해결 팁은 http://www.xine-project.org/faq[xine-project.org/faq]를 참조하세요.

[[video-ports-transcode]]
==== 트랜스코드 유틸리티

Transcode provides a suite of tools for re-encoding video and audio files. Transcode can be used to merge video files or repair broken files using command line tools with stdin/stdout stream interfaces.

In FreeBSD, Transcode can be installed using the package:multimedia/transcode[] package or port. Many users prefer to compile the port as it provides a menu of compile options for specifying the support and codecs to compile in. If an option is not selected, Transcode will not be able to encode that format. Use the arrow keys and spacebar to select the required formats. When finished, press kbd:[Enter] to continue the port compile and installation.

이 예에서는 DivX 파일을 PAL MPEG-1 파일(PAL VCD)로 변환하는 방법을 설명합니다:

[source, shell]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

The resulting `MPEG` file, [.filename]#output_vcd.mpg#, is ready to be played with MPlayer. The file can be burned on a `CD` media to create a video `CD` using a utility such as package:multimedia/vcdimager[] or package:sysutils/cdrdao[].

'트랜스코드'에 대한 매뉴얼 페이지 외에도 http://www.transcoding.org/cgi-bin/transcode[transcoding.org/cgi-bin/transcode]에서 자세한 정보와 예제를 참조할 수 있습니다.

[[tvcard]]
== TV 카드

TV cards can be used to watch broadcast or cable TV on a computer. Most cards accept composite video via an `RCA` or S-video input and some cards include a `FM` radio tuner.

FreeBSD provides support for PCI-based TV cards using a Brooktree Bt848/849/878/879 video capture chip with the man:bktr[4] driver. This driver supports most Pinnacle PCTV video cards. Before purchasing a TV card, consult man:bktr[4] for a list of supported tuners.

=== 드라이버 로딩하기

In order to use the card, the man:bktr[4] driver must be loaded. To automate this at boot time, add the following line to [.filename]#/boot/loader.conf#:

[.programlisting]
....
bktr_load="YES"
....

Alternatively, one can statically compile support for the TV card into a custom kernel. In that case, add the following lines to the custom kernel configuration file:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

These additional devices are necessary as the card components are interconnected via an I2C bus. Then, build and install a new kernel.

To test that the tuner is correctly detected, reboot the system. The TV card should appear in the boot messages, as seen in this example:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

The messages will differ according to the hardware. If necessary, it is possible to override some of the detected parameters using man:sysctl[8] or custom kernel configuration options. For example, to force the tuner to a Philips SECAM tuner, add the following line to a custom kernel configuration file:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

또는 man:sysctl[8]을 사용합니다:

[source, shell]
....
# sysctl hw.bt848.tuner=6
....

사용 가능한 man:sysctl[8] 매개변수 및 커널 옵션에 대한 설명은 man:bktr[4]를 참조하세요.

=== 유용한 애플리케이션

TV 카드를 사용하려면 다음 애플리케이션 중 하나를 설치하세요:

* package:multimedia/fxtv[]는 윈도우 내 TV 및 이미지/오디오/비디오 캡처 기능을 제공합니다.
* package:multimedia/xawtv[]는 비슷한 기능을 가진 또 다른 TV 애플리케이션입니다.
* package:audio/xmradio[]는 TV 카드의 FM 라디오 튜너를 사용하기 위한 애플리케이션을 제공합니다.

더 많은 애플리케이션은 FreeBSD 포트 컬렉션에서 찾아 볼 수 있습니다.

=== 문제 해결

If any problems are encountered with the TV card, check that the video capture chip and the tuner are supported by man:bktr[4] and that the right configuration options were used. For more support or to ask questions about supported TV cards, refer to the {freebsd-multimedia} mailing list.

[[mythtv]]
== MythTV

MythTV is a popular, open source Personal Video Recorder (`PVR`) application. This section demonstrates how to install and setup MythTV on FreeBSD. Refer to http://www.mythtv.org/wiki/[mythtv.org/wiki] for more information on how to use MythTV.

MythTV requires a frontend and a backend. These components can either be installed on the same system or on different machines.

The frontend can be installed on FreeBSD using the package:multimedia/mythtv-frontend[] package or port. Xorg must also be installed and configured as described in crossref:x11[x11,The X Window System]. Ideally, this system has a video card that supports X-Video Motion Compensation (`XvMC`) and, optionally, a Linux Infrared Remote Control (`LIRC`)-compatible remote.

To install both the backend and the frontend on FreeBSD, use the package:multimedia/mythtv[] package or port. A MySQL(TM) database server is also required and should automatically be installed as a dependency. Optionally, this system should have a tuner card and sufficient storage to hold recorded data.

=== 하드웨어

MythTV uses Video for Linux (`V4L`) to access video input devices such as encoders and tuners. In FreeBSD, MythTV works best with `USB` DVB-S/C/T cards as they are well supported by the package:multimedia/webcamd[] package or port which provides a `V4L` userland application. Any Digital Video Broadcasting (`DVB`) card supported by webcamd should work with MythTV. A list of known working cards can be found at https://wiki.freebsd.org/WebcamCompat[wiki.freebsd.org/WebcamCompat]. Drivers are also available for Hauppauge cards in the package:multimedia/pvr250[] and package:multimedia/pvrxxx[] ports, but they provide a non-standard driver interface that does not work with versions of MythTV greater than 0.23. Due to licensing restrictions, no packages are available and these two ports must be compiled.

https://wiki.freebsd.org/HTPC[wiki.freebsd.org/HTPC] 페이지에는 사용 가능한 모든 `DVB` 드라이버 목록이 포함되어 있습니다.

=== MythTV 백엔드 설정하기

바이너리 패키지를 사용하여 MythTV를 설치하려면:

[source, shell]
....
# pkg install mythtv
....

또는 포트 컬렉션으로 설치할 수 있습니다:

[source, shell]
....
# cd /usr/ports/multimedia/mythtv
# make install
....

설치가 완료되면 MythTV 데이터베이스를 설정합니다:

[source, shell]
....
# mysql -uroot -p < /usr/local/share/mythtv/database/mc.sql
....

그런 다음 백엔드를 구성합니다:

[source, shell]
....
# mythtv-setup
....

마지막으로 백엔드를 시작합니다:

[source, shell]
....
# sysrc mythbackend_enable=yes
# service mythbackend start
....

[[scanners]]
== 이미지 스캐너

In FreeBSD, access to image scanners is provided by SANE (Scanner Access Now Easy), which is available in the FreeBSD Ports Collection. SANE will also use some FreeBSD device drivers to provide access to the scanner hardware.

FreeBSD supports both `SCSI` and `USB` scanners. Depending upon the scanner interface, different device drivers are required. Be sure the scanner is supported by SANE prior to performing any configuration. Refer to http://www.sane-project.org/sane-supported-devices.html[http://www.sane-project.org/sane-supported-devices.html] for more information about supported scanners.

This chapter describes how to determine if the scanner has been detected by FreeBSD. It then provides an overview of how to configure and use SANE on a FreeBSD system.

[[scanners-kernel-usb]]
=== 스캐너 확인하기

The [.filename]#GENERIC# kernel includes the device drivers needed to support `USB` scanners. Users with a custom kernel should ensure that the following lines are present in the custom kernel configuration file:

[.programlisting]
....
device usb
device uhci
device ohci
device ehci
device xhci
....

To determine if the `USB` scanner is detected, plug it in and use `dmesg` to determine whether the scanner appears in the system message buffer. If it does, it should display a message similar to this:

[source, shell]
....
ugen0.2: <EPSON> at usbus0
....

이 예에서는 [.filename]#/dev/ugen0.2#에서 EPSON Perfection(R) 1650 `USB` 스캐너가 확인되었습니다.

If the scanner uses a `SCSI` interface, it is important to know which `SCSI` controller board it will use. Depending upon the `SCSI` chipset, a custom kernel configuration file may be needed. The [.filename]#GENERIC# kernel supports the most common `SCSI` controllers. Refer to [.filename]#/usr/src/sys/conf/NOTES# to determine the correct line to add to a custom kernel configuration file. In addition to the `SCSI` adapter driver, the following lines are needed in a custom kernel configuration file:

[.programlisting]
....
device scbus
device pass
....

장치가 시스템 메시지 버퍼에 표시되는지 확인합니다:

[source, shell]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

시스템 부팅 시 스캐너의 전원이 켜지지 않은 경우에도 `camcontrol`을 사용하여 `SCSI` 버스 스캔을 수행하여 수동으로 강제감지를 할 수 있습니다:

[source, shell]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

이제 스캐너가 `SCSI` 장치 목록에 나타납니다:

[source, shell]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

FreeBSD의 `SCSI` 장치에 대한 자세한 내용은 man:scsi[4] 및 man:camcontrol[8]을 참고하세요.

=== SANE 구성

The SANE system provides the access to the scanner via backends (package:graphics/sane-backends[]). Refer to http://www.sane-project.org/sane-supported-devices.html[http://www.sane-project.org/sane-supported-devices.html] to determine which backend supports the scanner. A graphical scanning interface is provided by third party applications like Kooka (package:graphics/kooka[]) or XSane (package:graphics/xsane[]). SANE's backends are enough to test the scanner.

바이너리 패키지에서 백엔드를 설치하려면:

[source, shell]
....
# pkg install sane-backends
....

또는 포트 컬렉션에서 설치하려면 다음과 같이 하세요

[source, shell]
....
# cd /usr/ports/graphics/sane-backends
# make install clean
....

package:graphics/sane-backends[] 포트 또는 패키지를 설치한 후 `sane-find-scanner`를 사용하여 SANE 시스템에서 스캐너 감지를 확인합니다:

[source, shell]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

The output should show the interface type of the scanner and the device node used to attach the scanner to the system. The vendor and the product model may or may not appear.

[NOTE]
====
Some `USB` scanners require firmware to be loaded. Refer to sane-find-scanner(1) and sane(7) for details.
====

Next, check if the scanner will be identified by a scanning frontend. The SANE backends include `scanimage` which can be used to list the devices and perform an image acquisition. Use `-L` to list the scanner devices. The first example is for a `SCSI` scanner and the second is for a `USB` scanner:

[source, shell]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner

# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

이 두 번째 예에서 `epson2`는 백엔드 이름이고 `libusb:000:002`는 [.filename]#/dev/ugen0.2#가 스캐너에서 사용하는 디바이스 노드라는 의미입니다.

`scanimage`가 스캐너를 식별할 수 없는 경우 아래의 메시지가 표시됩니다:

[source, shell]
....
# scanimage -L
No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

If this happens, edit the backend configuration file in [.filename]#/usr/local/etc/sane.d/# and define the scanner device used. For example, if the undetected scanner model is an EPSON Perfection(R) 1650 and it uses the `epson2` backend, edit [.filename]#/usr/local/etc/sane.d/epson2.conf#. When editing, add a line specifying the interface and the device node used. In this case, add the following line:

[.programlisting]
....
usb /dev/ugen0.2
....

편집 내용을 저장하고 스캐너가 올바른 백엔드 이름과 장치 노드로 인식되는지 확인합니다:

[source, shell]
....
# scanimage -L
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner
....

`scanimage -L`가 스캐너를 인식하면 구성이 완료되고 이제 스캐너를 사용할 준비가 된 것입니다.

While `scanimage` can be used to perform an image acquisition from the command line, it is often preferable to use a graphical interface to perform image scanning. Applications like Kooka or XSane are popular scanning frontends. They offer advanced features such as various scanning modes, color correction, and batch scans. XSane is also usable as a GIMP plugin.

=== 스캐너 권한

In order to have access to the scanner, a user needs read and write permissions to the device node used by the scanner. In the previous example, the `USB` scanner uses the device node [.filename]#/dev/ugen0.2# which is really a symlink to the real device node [.filename]#/dev/usb/0.2.0#. The symlink and the device node are owned, respectively, by the `wheel` and `operator` groups. While adding the user to these groups will allow access to the scanner, it is considered insecure to add a user to `wheel`. A better solution is to create a group and make the scanner device accessible to members of this group.

이 예제에서는 `_usb_`라는 그룹을 만듭니다:

[source, shell]
....
# pw groupadd usb
....

그런 다음 [.filename]#/dev/ugen0.2# 심볼릭 링크와 [.filename]#/dev/usb/0.2.0# 장치 노드에, `usb` 그룹이 액세스할 수 있도록 [.filename]#/etc/devfs.rules#에 쓰기 권한 `0660` 또는 `0664`를 추가합니다:

[.programlisting]
....
[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb
....

[NOTE]
====
장치를 추가하거나 제거하면 장치 노드가 변경되므로 대신 규칙 집합(ruleset)을 사용하여 모든 USB 장치에 대한 액세스 권한을 부여할 수 있습니다:

[.programlisting]
....
[system=5]
add path 'ugen*' mode 0660 group usb
add path 'usb/*' mode 0666 group usb
....

====

이 파일에 대한 자세한 내용은 man:devfs.rules[5]를 참조하세요.

그런 다음 /etc/rc.conf에서 규칙 집합을 활성화합니다:

[.programlisting]
....
devfs_system_ruleset="system"
....

그리고 man:devfs[8] 시스템을 다시 시작합니다:

[source, shell]
....
# service devfs restart
....

마지막으로, 스캐너에 대한 액세스를 허용하기 위해 사용자를 `_usb_`그룹에 추가합니다:

[source, shell]
....
# pw groupmod usb -m joe
....

자세한 내용은 man:pw[8]을 참조하세요.
