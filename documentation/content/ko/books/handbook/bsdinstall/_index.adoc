---
description: 'FreeBSD 설치방법, 하드웨어 최소사양과 지원 아키텍처, 그리고 미디어 설치방법등의 가이드'
next: books/handbook/basics
part: '파트 I. 시작하기'
path: /books/handbook/
prev: books/handbook/introduction
showBookMenu: 'true'
tags: ["bsdinstall", "installing FreeBSD", "requirements", "tutorial", "guide"]
title: '챕터 2. FreeBSD 설치하기'
weight: 4
---

[[bsdinstall]]
= FreeBSD 설치하기
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 2
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/bsdinstall/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[bsdinstall-synopsis]]
== 요약

FreeBSD는 ARM64, ARM(R), RISC-V(R), and PowerPC(R)와 같은 다양한 아키텍처를 지원합니다. 아키텍처와 플랫폼에 맞은 이미지는 link:https://www.freebsd.org/where/[downloaded] 에서 다운받을 수 있으며 바로 FreeBSD를 실행해 보거나 설치할 수 있습니다.

이미지 유형은 다음과 같습니다:

* `qcow2`, `vmdk`, `vhd` 및 원시 장치 이미지(raw device image)와 같은 가상머신 미스크 이미지. 이러한 이미지는 설치 이미지가 아니라 FreeBSD가 사전 설치되어 설치 후 바로 사용할 수 있는 이미지입니다. 가상 머신 이미지는 클라우드 환경에서도 흔하게 사용됩니다.
* 라즈베리 파이와 같은 임베디드 시스템용 SD 카드 이미지. 이러한 파일은 압축되지 않은 원시 이미지로 SD 카드에 기록해야 하며, 해당 보드가 이것으로 부팅될 것입니다.
* ISO 또는 USB 장치에서 부팅하여 일반적인 데스크톱, 노트북 또는 서버 시스템용 드라이브에 FreeBSD를 설치할 수 있는 설치 이미지.

이 장의 나머지 부분에서는 세 번째 경우에 대해 설명하며, bsdinstall이라는 텍스트 기반 설치 프로그램을 사용하여 FreeBSD를 설치하는 방법을 설명합니다. 설치 프로그램과 여기에 표시된 것 사이에는 약간의 차이가 있을 수 있으므로 이 장은 일반적인 지침으로 사용하십시오.

이 챕터를 읽고 나면, 여러분은:

* FreeBSD 이미지를 구하고 FreeBSD 설치 미디어를 생성하는 방법.
* bsdinstall을 시작하는 방법.
* bsdinstall이 묻는 질문, 질문의 의미 및 답변 방법.
* 설치 실패 문제를 해결하는 방법.
* 설치를 하기 전에 FreeBSD의 라이브 버전에 액세스하는 방법.

[[bsdinstall-hardware]]
== 최소 하드웨어 요구 사항

FreeBSD를 설치하기 위한 하드웨어 요구 사항은 아키텍처와 버전에 따라 다릅니다. FreeBSD 릴리스에서 지원하는 하드웨어 아키텍처 및 장치는 link:https://www.FreeBSD.org/releases/[FreeBSD Release Information] 페이지에 나와 있습니다. link:https://www.FreeBSD.org/where/[FreeBSD download page]에는 다양한 아키텍처에 적합한 이미지를 선택하기 위한 권장 사항도 있습니다.

[[bsdinstall-pre]]
== 설치 전 작업

시스템이 FreeBSD 설치를 위한 최소 하드웨어 요구 사항을 충족한다고 판단되면, 설치 파일을 다운로드하고 설치 미디어를 준비해야 합니다. 이 작업을 수행하기 전에 이 체크리스트의 항목을 확인하여 시스템이 설치 준비가 되었는지 확인하세요:

[.procedure]
====
. *중요 데이터 백업*
+
운영 체제를 설치하기 전에 모든 중요한 데이터를 *항상* 먼저 백업하세요. 백업을 설치 중인 시스템에 저장하지 마세요. 대신 USB 드라이브, 네트워크의 다른 시스템 또는 온라인 백업 서비스와 같은 이동식 디스크에 데이터를 저장하세요. 설치를 시작하기 전에 백업을 테스트하여 필요한 파일이 모두 포함되어 있는지 확인합니다. 인스톨러가 시스템 디스크를 포맷하면 해당 디스크에 저장된 모든 데이터가 손실됩니다.
. *FreeBSD 설치 위치 결정*
+
FreeBSD가 설치된 유일한 운영체제인 경우 이 단계를 건너뛸 수 있습니다. 하지만 다른 운영체제와 디스크를 공유할 경우, 어떤 디스크 또는 파티션을 FreeBSD에 사용할지 결정하세요.
+
i386 및 amd64 아키텍처에서 디스크는 두 가지 파티셔닝 방식 중 하나를 사용하여 여러 파티션으로 나눌 수 있습니다. 전통적인 _마스터 부트 레코드_(MBR)는 최대 4개의 _기본 파티션_을 정의하는 파티션 테이블을 보유합니다. 역사적인 이유로, FreeBSD는 이러한 기본 파티션을 _슬라이스_라고 부릅니다. 이러한 기본 파티션 중 하나는 여러 개의 _논리적 파티션_을 포함하는 _확장 파티션_으로 만들 수 있습니다. _GUID 파티션 테이블_(GPT)은 디스크를 파티셔닝하는 더 새롭고 간단한 방법입니다. 일반적인 GPT 구현은 디스크당 최대 128개의 파티션을 허용하므로 논리적 파티션이 필요하지 않습니다.
+
FreeBSD 부트 로더에는 기본 파티션 또는 GPT 파티션이 필요합니다. 기본 파티션 또는 GPT 파티션이 모두 이미 사용 중이라면 FreeBSD를 위해 파티션을 하나 비워야 합니다. 기존 데이터를 삭제하지 않고 파티션을 생성하려면 파티션 크기 조정 도구를 사용하여 기존 파티션을 축소하고 확보된 공간을 사용하여 새 파티션을 생성합니다.
+
다양한 무료 및 상용 파티션 크기 조정 도구는 link:https://en.wikipedia.org/wiki/List_of_disk_partitioning_software[List of disk partitioning software wikipedia entry]에 나와 있습니다. link:https://gparted.org/livecd.php[GParted Live]는 GParted 파티션 편집기가 포함된 무료 라이브 CD입니다.
+
[WARNING]
======
디스크 축소 유틸리티를 올바르게 사용하면 새 파티션을 만들기 위한 공간을 안전하게 만들 수 있습니다. 잘못된 파티션을 선택할 가능성이 있으므로 디스크 파티션을 수정하기 전에 항상 중요한 데이터를 백업하고 백업의 무결성을 확인하시기 바랍니다.
======
+
서로 다른 운영 체제가 포함된 디스크 파티션을 사용하면 한 대의 컴퓨터에 여러 운영 체제를 설치할 수 있습니다. 다른 방법은 디스크 파티션을 수정하지 않고도 여러 운영 체제를 동시에 실행할 수 있는 가상화(crossref:virtualization[virtualization,Virtualization])를 사용하는 것입니다.
. *네트워크 정보 수집*
+
일부 FreeBSD 설치 방법은 설치 파일을 다운로드하기 위해 네트워크 연결이 필요합니다. 설치가 완료되면 설치 관리자가 시스템의 네트워크 인터페이스를 설정하도록 제안합니다.
+
네트워크에 DHCP 서버가 있는 경우 이를 사용하여 자동 네트워크 구성을 제공할 수 있습니다. DHCP를 사용할 수 없는 경우 로컬 네트워크 관리자 또는 인터넷 서비스 제공업체로부터 시스템에 대한 다음 네트워크 정보를 얻어야 합니다:
+
[[bsdinstall-collect-network-information]]
필수 네트워크 정보

.. IP주소
.. 서브넷 마스크
.. 기본 게이트웨이의 IP 주소
.. 네트워크의 도메인 이름
.. 네트워크 DNS 서버의 IP 주소

. *FreeBSD 정오표 확인*
+
FreeBSD 프로젝트는 FreeBSD의 각 릴리스가 가능한 한 안정적이 되도록 노력하지만, 때때로 버그가 끼어들기도 합니다. 아주 드물게 이러한 버그가 설치 프로세스에 영향을 미치는 경우가 있습니다. 이러한 문제가 발견되고 수정되면 각 버전의 FreeBSD 정오표 페이지에 표시됩니다. 설치하기 전에 정오표를 확인하여 설치에 영향을 줄 수 있는 문제가 없는지 확인하세요.
+
모든 릴리스에 대한 정보 및 오류는 link:https://www.FreeBSD.org/releases/[FreeBSD Release Information] 페이지에서 확인할 수 있습니다.
====

[[bsdinstall-installation-media]]
=== 설치 미디어 준비

FreeBSD 설치 프로그램은 다른 운영 체제 내에서 실행할 수 있는 애플리케이션이 아닙니다. 대신 FreeBSD 설치 파일을 다운로드하여 해당 파일 유형 및 크기에 맞는 미디어(CD, DVD 또는 USB)에 구운 다음 시스템을 부팅하여 삽입된 미디어에서 설치하세요.

FreeBSD 설치 파일은 link:https://www.FreeBSD.org/where/[FreeBSD download page]에서 다운로드할 수 있습니다. 각 설치 파일의 이름에는 FreeBSD의 릴리스 버전, 아키텍처 및 파일 유형이 포함되어 있습니다.

설치 파일은 man:xz[1]로 압축되거나 압축되지 않은 여러 가지 형식으로 제공됩니다. 형식은 컴퓨터 아키텍처와 미디어 유형에 따라 다릅니다.

설치 파일 유형:

* `*-bootonly.iso*`: 이 파일은 인스톨러만 포함하므로 가장 작은 설치 파일입니다. 설치 프로그램이 FreeBSD 설치를 완료하는 데 필요한 파일을 다운로드하므로 설치하는 동안 인터넷 연결이 필요합니다. 이 파일은 광 미디어에 구워야 합니다.
* `*-disc1.iso*`: 이 파일에는 FreeBSD, 소스 및 포트(Port) 컬렉션을 설치하는 데 필요한 모든 파일이 포함되어 있습니다. 이 파일은 광 미디어에 구워야 합니다.
* `*-dvd1.iso*`: 이 파일에는 FreeBSD, 소스 및 포트 컬렉션을 설치하는 데 필요한 모든 파일이 포함되어 있습니다. 또한 인터넷에 연결하지 않고도 미디어에서 전체 시스템을 설치할 수 있도록 윈도우 매니저와 일부 애플리케이션을 설치하기 위한 인기 있는 바이너리 패키지 세트가 포함되어 있습니다. 이 파일은 광 미디어에 구워야 합니다.
* `*-memstick.img*`: 이 파일에는 FreeBSD, 소스 및 포트 컬렉션을 설치하는 데 필요한 모든 파일이 들어 있습니다. <<bsdinstall-usb>>에 설명된 대로 이 파일을 USB 스틱에 저장합니다.
* `*-mini-memstick.img*`:’ *-bootonly.iso*'와 마찬가지로 설치 파일은 포함하지 않지만 필요에 따라 다운로드합니다. 설치하는 동안 인터넷 연결이 필요합니다. <<bsdinstall-usb>>와 같이 USB 스틱에 기록해야 합니다.

이미지 파일을 다운로드한 후 같은 디렉터리에서 _checksum_ 파일을 하나 이상 다운로드합니다. 릴리스 번호와 아키텍처 이름을 따서 명명된 두 개의 _checksum_ 파일을 사용할 수 있습니다. 예: `CHECKSUM.SHA256-FreeBSD-13.1-RELEASE-amd64` 및 `CHECKSUM.SHA512-FreeBSD-13.1-RELEASE-amd64`.

파일 중 하나(또는 두 파일 모두)를 다운로드한 후 이미지 파일의 _checksum_을 확인하고 _checksum_ 파일에 표시된 값과 비교합니다. SHA256과 SHA512라는 두 개의 서로 다른 알고리즘에 대응하므로 확인된 _checksum_을 올바른 파일과 비교해야 한다는 점을 유의하세요. FreeBSD는 _checksum_을 계산하는 데 사용할 수 있는 man:sha256[1] 및 man:sha512[1]을 제공합니다. 다른 운영 체제에도 유사한 프로그램이 있습니다.

FreeBSD에서 _checksum_의 확인은 man:sha256sum[1](및 man:sha512sum[1])을 실행하여 자동으로 수행할 수 있습니다:

[source, shell]
....
% sha256sum -c CHECKSUM.SHA256-FreeBSD-13.1-RELEASE-amd64 FreeBSD-13.1-RELEASE-amd64-dvd1.iso
FreeBSD-13.1-RELEASE-amd64-dvd1.iso: OK
....

체크섬은 정확히 일치해야 합니다. 체크섬이 일치하지 않으면 이미지 파일이 손상된 것이므로 다시 다운로드해야 합니다.

[[bsdinstall-usb]]
==== USB에 이미지 파일 쓰기

`\*memstick.img` 파일은 메모리 스틱의 전체 내용을 담은 _이미지_입니다. 대상 장치에 단순히 복사해서는 안됩니다. USB 스틱에 `*.img`를 쓰기 위해서는 여러 가지 애플리케이션을 사용할 수 있습니다. 이 섹션에서는 이러한 유틸리티 중 두 가지에 대해 설명합니다.

[IMPORTANT]
====
계속 진행하기 전에 USB 스틱에 있는 중요한 데이터를 백업하세요. 이 절차를 수행하면 메모리 스틱에 있는 기존 데이터가 지워집니다.
====

[[bsdinstall-usb-dd]]
[.procedure]
====
*절차. DD`를 사용하여 이미지 쓰기* +

[WARNING]
======
이 예에서는 이미지가 기록될 대상 장치로 `/dev/da0`을 사용합니다. 이 명령은 지정된 대상 장치의 기존 데이터를 파괴하므로 올바른 장치를 사용하도록 *매우 주의*해야 합니다.
======

. 명령줄 유틸리티는 BSD, Linux(R) 및 Mac OS(R) 시스템에서 사용할 수 있습니다. `dd`를 사용하여 이미지를 구우려면 USB 스틱을 삽입하고 해당 장치 이름을 확인합니다. 그런 다음 다운로드한 설치 파일의 이름과 USB 스틱의 장치 이름을 지정합니다. 이 예에서는 기존 FreeBSD 시스템의 첫 번째 USB 장치에 amd64 설치 이미지를 굽습니다.
+
[source, shell]
....
# dd if=FreeBSD-13.0-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync
....
+
이 명령이 실패하면 USB 스틱이 마운트되지 않았는지, 장치 이름이 파티션이 아닌 디스크용인지 확인합니다.
+
일부 운영 체제에서는 이 명령을 man:sudo[8]와 함께 실행해야 할 수 있습니다. Man:dd[1] 구문은 플랫폼에 따라 약간씩 다릅니다. 예를 들어, Mac OS(R)에서는 `bs=1m`을 소문자로 써야 합니다. Linux(R)와 같은 시스템은 쓰기를 버퍼링할 수 있습니다. 모든 쓰기를 강제로 완료하려면 man:sync[8]를 사용합니다.
====

[.procedure]
====
*절차. Windows(R)를 사용하여 이미지 쓰기* +

[WARNING]
======
지정된 드라이브의 기존 데이터는 덮어쓰고 삭제되므로 올바른 드라이브 문자를 입력해야 합니다.
======

. *Windows(R)용 이미지 라이터 얻기*
+
Windows(R)용 Image Writer는 메모리 스틱에 이미지 파일을 올바르게 쓸 수 있는 무료 애플리케이션입니다. https://sourceforge.net/projects/win32diskimager/[win32diskimager home page]에서 다운로드하여 폴더에 압축을 풉니다.

. *Image Writer로 이미지 작성*
+
Win32DiskImager 아이콘을 더블 클릭하여 프로그램을 시작합니다. '장치' 아래에 표시된 드라이브 문자가 메모리 스틱이 있는 드라이브인지 확인합니다. 폴더 아이콘을 클릭하고 메모리 스틱에 기록할 이미지를 선택합니다. btn:[Save]을 클릭하여 이미지 파일 이름을 수락합니다. 모든 것이 올바른지, 메모리 스틱의 폴더가 다른 창에서 열려 있지 않은지 확인합니다. 모든 준비가 완료되면 btn:[Write]를 클릭하여 메모리 스틱에 이미지 파일을 씁니다.
====

[[bsdinstall-start]]
== 설치 시작

[IMPORTANT]
====
기본적으로 설치 시 다음 메시지가 표시되기 전에는 디스크가 변경되지 않습니다:

[.programlisting]
....
Your changes will now be written to disk. If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?
....

이 경고가 표시되기 전에 언제든지 설치를 종료할 수 있습니다. 구성이 잘못되었다고 우려되는 경우 이 시점 전에 컴퓨터를 끄면 시스템 디스크가 변경되지 않습니다.
====

이 섹션에서는 <<bsdinstall-installation-media>>의 지침에 따라 준비된 설치 미디어에서 시스템을 부팅하는 방법을 설명합니다. 부팅 가능한 USB 스틱을 사용하는 경우 컴퓨터를 켜기 전에 USB 스틱을 연결하세요. CD 또는 DVD로 부팅할 때는 컴퓨터를 켜고 처음에 미디어를 삽입합니다. 삽입된 미디어에서 부팅하도록 시스템을 구성하는 방법은 아키텍처에 따라 다릅니다.

[[bsdinstall-view-probe]]
=== FreeBSD 부팅 메뉴

설치 미디어에서 시스템이 부팅되면 다음과 유사한 메뉴가 표시됩니다:

[[bsdinstall-newboot-loader-menu]]
.FreeBSD 부트 로더 메뉴
image::bsdinstall-newboot-loader-menu.png["FreeBSD 부트 로더 메뉴"]

기본적으로 메뉴는 사용자 입력을 10초간 기다린 후 FreeBSD 인스톨러로 부팅하거나, FreeBSD가 이미 설치되어 있는 경우 FreeBSD로 부팅합니다. 선택 항목을 검토하기 위해 부팅 타이머를 일시 중지하려면 kbd:[Space]를 누릅니다. 옵션을 선택하려면 강조 표시된 숫자, 문자 또는 키를 누릅니다. 다음 옵션을 사용할 수 있습니다.

* `Boot Multi User`: FreeBSD 부팅 프로세스가 계속됩니다. 부팅 타이머가 일시 중지된 경우, kbd:[1], 대문자 또는 소문자 kbd:[B] 또는 kbd:[Enter]를 누릅니다.
* `Boot Single User`: 이 모드는 crossref:boot[boot-singleuser,“Single-User Mode”]에 설명된 대로 기존 FreeBSD 설치를 수정하는 데 사용할 수 있습니다. 이 모드로 들어가려면 kbd:[2] 또는 대문자 또는 소문자 kbd:[S]를 누릅니다.
* `Escape to loader prompt`: 이 항목은 제한된 수의 저수준 명령이 포함된 복구 프롬프트로 시스템이 부팅됩니다. 이 프롬프트는 crossref:boot[boot-loader,“Stage Three”]에 설명되어 있습니다. 이 프롬프트로 부팅하려면 kbd:[3] 또는 kbd:[Esc]를 누르세요.
* `Reboot`: 시스템을 재부팅합니다.
* `Cons`: 비디오`, `직렬`, `이중(직렬 기본)` 또는 `이중(비디오 기본)`으로 설치를 계속하도록 허용합니다
* `Kernel`: 다른 커널을 로드합니다.
* `Boot Options`: <<bsdinstall-boot-options-menu>> 아래에 설명된 메뉴를 엽니다.

[[bsdinstall-boot-options-menu]]
.FreeBSD 부트 옵션 메뉴
image::bsdinstall-boot-options-menu.png["지원되는 다양한 부팅 옵션을 보여주는 메뉴"]

부팅 옵션 메뉴는 두 섹션으로 나뉩니다. 첫 번째 섹션은 기본 부팅 메뉴로 돌아가거나 전환된 옵션을 기본값으로 재설정하는 데 사용할 수 있습니다.

다음 섹션에서는 옵션의 강조 표시된 숫자나 문자를 눌러 사용 가능한 옵션을 '켜기' 또는 '끄기'로 전환할 수 있습니다. 이 옵션은 수정할 때까지 항상 해당 옵션의 설정을 사용하여 부팅됩니다. 이 메뉴를 사용하여 여러 옵션을 전환할 수 있습니다:

* `ACPI Support`: 부팅 중에 시스템이 멈추는 경우, 이 옵션을 '끄기'로 전환해 보세요.
* `Safe Mode`: `ACPI Support`을 `끄기`로 설정해도 부팅 중에 시스템이 멈추는 경우, 이 옵션을 `켜기`로 설정해 보세요.
* `Single User`: 이 옵션을 `켜기`로 전환하면 crossref:boot[boot-singleuser,“Single-User Mode”]에 설명된 대로 기존 FreeBSD 설치를 수정할 수 있습니다. 문제가 해결되면 다시 `Off`로 설정합니다.
* `Verbose`: 부팅 프로세스 중에 더 자세한 메시지를 보려면 이 옵션을 `켜기`로 전환합니다. 하드웨어 문제를 해결할 때 유용할 수 있습니다.

필요한 선택을 한 후 kbd:[1] 또는 kbd:[Backspace]를 눌러 기본 부팅 메뉴로 돌아간 다음, kbd:[Enter]를 눌러 FreeBSD로 부팅을 계속합니다. 하드웨어 장치 검색을 수행하고 설치 프로그램을 로드하는 동안 일련의 부팅 메시지가 나타납니다. 부팅이 완료되면 <<bsdinstall-choose-mode>>에 표시된 시작 메뉴가 표시됩니다.

[[bsdinstall-choose-mode]]
.환영 메뉴
image::bsdinstall-choose-mode.png["FreeBSD 설치 시작 메뉴"]

kbd:[Enter]를 눌러 기본값인 btn:[Install]를 선택하여 설치 프로그램으로 들어갑니다. 이 장의 나머지 부분에서는 이 설치 프로그램을 사용하는 방법을 설명합니다. 그렇지 않으면 오른쪽 또는 왼쪽 화살표 또는 색상이 지정된 문자를 사용하여 원하는 메뉴 항목을 선택합니다. btn:[Shell]은 설치 전에 명령줄 유틸리티를 사용하여 디스크를 준비하기 위해 FreeBSD 셸에 액세스하는 데 사용할 수 있습니다. btn:[Live CD] 옵션은 설치하기 전에 FreeBSD를 시험해 볼 수 있습니다. 라이브 버전은 <<using-live-cd>>에 설명되어 있습니다.

[TIP]
====
하드웨어 장치 검색을 포함한 부팅 메시지를 검토하려면 대문자 또는 소문자 kbd:[S]를 누른 다음 kbd:[Enter]를 눌러 셸에 액세스합니다. 셸 프롬프트에서 `more /var/run/dmesg.boot`를 입력한 다음 스페이스바를 사용하여 메시지를 스크롤합니다. 완료되면 `exit`를 입력하여 시작 메뉴로 돌아갑니다.
====

[[using-bsdinstall]]
== bsdinstall 사용

이 섹션에서는 시스템을 설치하기 전에 bsdinstall 메뉴의 순서와 입력할 정보 유형을 보여 줍니다. 화살표 키를 사용하여 메뉴 옵션을 강조 표시한 다음 kbd:[Space]를 눌러 해당 메뉴 항목을 선택하거나 선택 또는 취소합니다. 완료되면 kbd:[Enter]를 눌러 선택 내용을 저장하고 다음 화면으로 이동합니다.

[[bsdinstall-keymap]]
=== 키맵 메뉴 선택

프로세스를 시작하기 전에 <<bsdinstall-keymap-loading>>에서 보여준 것과 같이 bsdinstall이 키맵 파일을 로드합니다.

[[bsdinstall-keymap-loading]]
.키맵 로드
image::bsdinstall-keymap-loading.png["키맵 로드"]

키맵이 로드되면 bsdinstall은 <<bsdinstall-keymap-10>>에 표시된 메뉴를 표시합니다. 위쪽 및 아래쪽 화살표를 사용하여 시스템에 연결된 키보드의 매핑을 가장 잘 나타내는 키맵을 선택합니다. kbd:[Enter]를 눌러 선택 사항을 저장합니다.

[[bsdinstall-keymap-10]]
.키맵 선택 메뉴
image::bsdinstall-keymap-10.png["지원되는 모든 키보드를 보여주는 키맵 선택 메뉴"]

[NOTE]
====
kbd:[Esc]를 누르면 이 메뉴가 종료되고 기본 키맵이 사용됩니다. 키맵 선택이 명확하지 않은 경우 [.guimenuitem]#United States of America ISO-8859-1#을 사용하는 것도 안전한 방법입니다.
====

그 외의 키맵을 선택할 경우 <<bsdinstall-keymap-testing>>와 같이 사용자가 키맵을 테스트하고 제대로 나타나는지 확인한 후 계속 진행할 수 있습니다.

[[bsdinstall-keymap-testing]]
.키맵 테스트 메뉴
image::bsdinstall-keymap-testing.png["키맵 테스트 메뉴"]

[[bsdinstall-hostname]]
=== 호스트네임 설정

다음 bsdinstall 메뉴는 새로 설치된 시스템의 호스트 이름을 설정하는 데 사용됩니다.

[[bsdinstall-config-hostname]]
.호스트네임 설정
image::bsdinstall-config-hostname.png["호스트네임 설정"]

네트워크에 고유한 호스트 이름을 입력합니다. `machine3.example.com`과 같이 정규화된 호스트 이름이어야 합니다.

[[bsdinstall-components]]
=== 설치할 구성 요소 선택

다음으로, bsdinstall은 설치할 선택적 구성 요소를 선택하라는 메시지를 표시합니다.

[[bsdinstall-config-components]]
.설치할 구성 요소 선택
image::bsdinstall-config-components.png["설치할 수 있는 다양한 컴포넌트. 예: base-dbg", lib32, ports, etc.]

설치할 구성 요소를 결정하는 것은 시스템의 용도와 사용 가능한 디스크 공간의 양에 따라 크게 달라집니다. _베이스 시스템_으로 통칭되는 FreeBSD 커널과 유저랜드는 항상 설치됩니다. 아키텍처에 따라 이러한 구성 요소 중 일부는 나타나지 않을 수 있습니다:

* `base-dbg` - 디버그 기호가 활성화된 cat, ls 등의 기본 도구가 있습니다.
* `kernel-dbg` - 디버그 심볼이 활성화된 커널 및 모듈.
* `lib32-dbg` - 디버그 심볼이 활성화된 64비트 버전의 FreeBSD에서 32비트 애플리케이션을 실행하기 위한 호환성 라이브러리입니다.
* `lib32` - 64비트 버전의 FreeBSD에서 32비트 애플리케이션을 실행하기 위한 호환성 라이브러리입니다.
* `ports` - FreeBSD 포트 컬렉션은 타사 소프트웨어 패키지의 다운로드, 컴파일 및 설치를 자동화하는 파일 모음입니다. crossref:ports[ports,Installing Applications: Packages and Ports]에서 포트 컬렉션을 사용하는 방법에 대해 설명합니다.
+
[WARNING]
====
설치 프로그램은 디스크 공간이 충분한지 확인하지 않습니다. 충분한 하드 디스크 공간을 사용할 수 있는 경우에만 이 옵션을 선택하십시오. FreeBSD 포트 컬렉션은 약 {ports-size}의 디스크 공간을 차지합니다.
====

* `src` - 커널과 유저랜드 모두에 대한 완전한 FreeBSD 소스 코드. 대부분의 애플리케이션에는 필요하지 않지만, 장치 드라이버, 커널 모듈 또는 포트 컬렉션의 일부 애플리케이션을 빌드하는 데 필요할 수 있습니다. 또한 FreeBSD 자체를 개발하는 데에도 사용됩니다. 전체 소스 트리에는 1GB의 디스크 공간이 필요하며 전체 FreeBSD 시스템을 재컴파일하려면 추가로 5GB의 공간이 필요합니다.
* `tests` - FreeBSD 테스트 스위트.

[[bsdinstall-netinstall]]
=== 네트워크에서 설치하기

<<bsdinstall-netinstall-notify>>에 표시된 메뉴는 이 설치 미디어에 설치 파일의 사본이 포함되어 있지 않으므로 `-bootonly.iso` 또는 `-mini-memstick.img`에서 설치하는 경우에만 나타납니다. 설치 파일은 네트워크 연결을 통해 검색해야 하므로 이 메뉴는 네트워크 인터페이스를 먼저 구성해야 함을 뜻합니다. 프로세스의 어느 단계에서든 이 메뉴가 표시되면 <<bsdinstall-config-network-dev>>의 지침을 따르는 것을 잊지 마세요.

[[bsdinstall-netinstall-notify]]
.네트워크에서 설치하기
image::bsdinstall-netinstall-files.png["특정 구성 요소를 찾지 못했으며 네트워크를 사용하여 다운로드할 것임을 나타냅니다."]

[[bsdinstall-partitioning]]
== 디스크 공간 할당

다음 메뉴는 디스크 공간을 할당하는 방법을 결정하는 데 사용됩니다.

[[bsdinstall-zfs-partmenu]]
.파티셔닝 선택 사항
image::bsdinstall-zfs-partmenu.png["다양한 파티션 옵션을 표시합니다. 예시: 매뉴얼", Shell, etc.]

bsdinstall은 사용자에게 디스크 공간을 할당하는 네 가지 방법을 제공합니다:

* `Auto (ZFS)` 파티션은 _부팅 환경_에 대한 선택적 GELI 암호화를 지원하는 root-on-ZFS 시스템을 생성합니다.
* `Auto (UFS)` 파티션은 `UFS` 파일 시스템을 사용하여 디스크 파티션을 자동으로 설정합니다.
* `Manual` 파티션을 사용하면 고급 사용자가 메뉴 옵션에서 사용자 지정 파티션을 만들 수 있습니다.
* `Shell`은 고급 사용자가 man:gpart[8], man:fdisk[8], man:bsdlabel[8]과 같은 명령줄 유틸리티를 사용하여 사용자 지정 파티션을 생성할 수 있는 셸 프롬프트를 엽니다.

이 섹션에서는 디스크 파티션을 배치할 때 고려해야 할 사항을 설명합니다. 그런 다음 다양한 파티셔닝 방법을 보여줍니다.

[[configtuning-initial]]
=== 파티션 레이아웃 디자인하기

파일 시스템의 기본 파티션 레이아웃은 전체 시스템에 대해 하나의 파일 시스템을 포함합니다. `UFS`를 사용할 때 디스크 공간이 충분하거나 디스크가 여러 개인 경우 여러 파일 시스템 사용을 고려할 수 있습니다. 파일 시스템을 배치할 때 하드 드라이브는 바깥쪽 트랙에서 안쪽 트랙으로 데이터를 더 빠르게 전송한다는 점을 기억하세요. 따라서 더 작고 액세스 빈도가 높은 파일 시스템은 드라이브 바깥쪽에 더 가깝게 배치하고, `/usr`과 같은 큰 파티션은 디스크 안쪽을 향해 배치해야 합니다. 다음과 비슷한 순서로 파티션을 생성하는 것이 좋습니다: `/`, swap, `/var`, 그리고 `/usr`와 비슷한 순서로 파티션을 만드는 것이 좋습니다.

`/var` 파티션의 크기는 사용하려는 컴퓨터의 용도를 반영합니다. 이 파티션은 사서함, 로그 파일 및 프린터 스풀을 보관하는 데 사용됩니다. 사서함과 로그 파일은 사용자 수와 로그 파일의 보관 기간에 따라 예기치 않은 크기로 커질 수 있습니다. 평균적으로 대부분의 사용자는 `/var`에 약 1기가바이트 이상의 디스크 여유 공간이 필요하지 않습니다.

[NOTE]
====
때때로 `/var/tmp`에 많은 디스크 공간이 필요할 수 있습니다. 새 소프트웨어가 설치되면 패키징 도구는 `/var/tmp`에 패키지의 임시 복사본을 추출합니다. Firefox나 LibreOffice와 같은 대용량 소프트웨어 패키지는 `/var/tmp`에 디스크 공간이 충분하지 않으면 설치가 까다로울 수 있습니다.
====

`/usr` 파티션에는 FreeBSD 포트 컬렉션과 시스템 소스 코드를 포함하여 시스템을 지원하는 많은 파일이 저장됩니다. 이 파티션에는 최소 2 기가바이트의 공간이 권장됩니다. 또한 사용자의 홈 디렉토리는 기본적으로 `/usr/home`에 위치하지만 다른 파티션에 위치할 수 있습니다. 기본적으로 `/home`은 `/usr/home`에 대한 심볼릭 링크입니다.

파티션 크기를 선택할 때는 공간 요구 사항을 염두에 두세요. 한 파티션은 거의 사용하지 않는데 다른 파티션의 공간이 부족하면 번거로운 일이 발생할 수 있습니다.

경험상 스왑 파티션은 실제 메모리(RAM) 크기의 약 2배가 되어야 합니다. RAM이 최소인 시스템(대용량 메모리 구성의 경우 더 적음)은 더 많은 스왑으로 더 나은 성능을 발휘할 수 있습니다. 스왑을 너무 적게 구성하면 VM 페이지 스캔 코드의 비효율성을 초래할 수 있으며 나중에 메모리를 더 추가할 경우 문제가 발생할 수 있습니다.

여러 개의 SCSI 디스크 또는 여러 개의 IDE 디스크가 서로 다른 컨트롤러에서 작동하는 대규모 시스템에서는 각 드라이브에 최대 4개의 드라이브까지 스왑을 구성하는 것이 좋습니다. 스왑 파티션은 거의 같은 크기여야 합니다. 커널은 임의의 크기를 처리할 수 있지만 내부 데이터 구조는 가장 큰 스왑 파티션의 4배까지 확장됩니다. 스왑 파티션을 거의 같은 크기로 유지하면 커널이 디스크에서 스왑 공간을 최적으로 스트라이핑할 수 있습니다. 스왑 크기가 크면 구성된 총 스왑에 대한 커널 경고 메시지가 표시될 수 있습니다. 경고 메시지의 지시에 따라 스왑 할당을 추적하는 데 허용되는 메모리 양을 늘리면 제한이 높아집니다. 강제로 재부팅하기 전에 runaway 프로그램으로 복구하는 것이 더 쉬울 수 있습니다.

시스템을 적절하게 파티셔닝하면 쓰기 작업이 많은 작은 파티션에서 발생한 파일의 조각화가 읽기 작업이 많은 파티션으로 번지지 않습니다. 쓰기가 많은 파티션을 디스크 바깥쪽에 더 가깝게 유지하면 쓰기 작업이 가장 많이 발생하는 파티션의 I/O 성능이 향상됩니다. 더 큰 파티션의 I/O 성능이 필요할 수 있지만, 파티션을 디스크 바깥쪽으로 더 이동한다고 해서 `/var`를 디크스 바깥쪽으로 이동하는 것보다 성능이 크게 향상되지는 않습니다.

[[bsdinstall-part-guided]]
=== UFS를 사용한 가이드 파티셔닝

이 방법을 선택하면 메뉴에 사용 가능한 디스크가 표시됩니다. 여러 개의 디스크가 연결되어 있는 경우 FreeBSD를 설치할 디스크를 선택합니다.

[[bsdinstall-part-guided-disk]]
.여러 디스크에서 선택
image::bsdinstall-part-guided-disk.png["FreeBSD를 설치할 수 있는 디스크 목록을 표시합니다"]

디스크를 선택하면 다음 메뉴에서 전체 디스크에 설치하거나 여유 공간을 사용하여 파티션을 만들지 묻는 메시지가 표시됩니다. btn:[Entire Disk]를 선택하면 전체 디스크를 채우는 일반 파티션 레이아웃이 자동으로 생성됩니다. btn:[Partition]을 선택하면 디스크의 빈 공간에서 파티션 레이아웃이 생성됩니다.

[[bsdinstall-part-entire-part]]
.전체 디스크 또는 파티션 선택
image::bsdinstall-part-entire-part.png["사용자에게 디스크의 사용 가능한 공간을 모두 사용할 것인지 아니면 파티션을 만들 것인지 묻는 메뉴입니다"]

btn:[Entire Disk] 옵션을 선택하면 bsdinstall는 디스크가 삭제될 것이라는 대화 상자를 표시합니다.

[[bsdinstall-ufs-warning]]
.확인
image::bsdinstall-ufs-warning.png["사용자에게 디스크의 모든 데이터가 삭제될 것임을 알리고 확인을 요청하는 메뉴"]

다음 메뉴에는 사용 가능한 파티션 구성표 유형 목록이 표시됩니다. 일반적으로 amd64 컴퓨터에는 GPT가 가장 적합한 선택입니다. GPT와 호환되지 않는 구형 컴퓨터는 MBR을 사용해야 합니다. 다른 파티션 구성표는 일반적으로 일반적이지 않거나 오래된 컴퓨터에 사용됩니다. 자세한 정보는 <<partition-schemes>>에서 확인할 수 있습니다.

[[bsdinstall-ufs-scheme]]
.파티션 구성표 선택
image::bsdinstall-part-manual-partscheme.png["사용자에게 존재하는 다양한 유형의 파티션을 표시하고 그중 하나를 요청하는 메뉴"]

파티션 레이아웃을 생성한 후에는 설치 요구 사항을 충족하는지 검토합니다. btn:[Revert]를 선택하면 파티션이 원래 값으로 재설정됩니다. btn:[Auto]을 누르면 자동 FreeBSD 파티션이 다시 생성됩니다. 파티션을 수동으로 생성, 수정 또는 삭제할 수도 있습니다. 파티션 분할이 올바르면 btn:[Finish]을 선택하여 설치를 계속 진행합니다.

[[bsdinstall-part-review]]
.생성된 파티션 검토
image::bsdinstall-part-review.png["생성된 파티션을 보여주는 메뉴"]

디스크 구성이 완료되면 다음 메뉴에서 선택한 드라이브를 포맷하기 전에 마지막으로 변경할 수 있는 기회를 제공합니다. 변경이 필요한 경우 btn:[Back]를 선택하여 기본 파티셔닝 메뉴로 돌아갑니다. btn:[Revert & Exit]는 드라이브를 변경하지 않고 설치 관리자를 종료합니다. 그렇지 않으면 btn:[Commit]을 선택하여 설치 프로세스를 시작합니다.

[[bsdinstall-ufs-final-confirmation]]
.최종 확인
image::bsdinstall-final-confirmation.png["모든 변경 사항이 디스크에 기록될 것임을 사용자에게 알리고 계속 진행하기로 결정하면 기존 데이터가 영구 삭제됨을 알리는 메뉴입니다."]

설치 프로세스를 계속 진행하려면 <<bsdinstall-fetching-distribution>>로 이동하세요.

[[bsdinstall-part-manual]]
=== 수동 파티셔닝

이 방법을 선택하면 파티션 편집기가 열립니다:

[[bsdinstall-part-manual-create]]
.수동으로 파티션 생성
image::bsdinstall-part-manual-create.png["파티션 편집기를 보여주는 메뉴입니다."]

설치할 드라이브(이 예에서는 `ada0`)를 강조 표시하고 btn:[Create]를 선택하면 사용 가능한 파티션 구성표 메뉴가 표시됩니다:

[[bsdinstall-part-manual-partscheme]]
.수동으로 파티션 생성
image::bsdinstall-part-manual-partscheme.png["다양한 종류의 파티션 구성표를 보여주는 메뉴"]

GPT는 일반적으로 amd64 컴퓨터에 가장 적합합니다. GPT와 호환되지 않는 구형 컴퓨터는 MBR을 사용해야 합니다. 다른 파티션 체계는 일반적으로 일반적이지 않거나 구형 컴퓨터에 사용됩니다.

[[partition-schemes]]
.파티션 스키마
[cols="25h,~", frame="none", options="header"]
|===
<| Abbreviation
<| Description

|APM
|Apple Partition Map, used by PowerPC(R).

|BSD
|BSD label without an MBR, sometimes called _dangerously dedicated mode_ as non-BSD disk utilities may not recognize it.

|GPT
|link:https://en.wikipedia.org/wiki/GUID_Partition_Table[GUID Partition Table].

|MBR
|link:https://en.wikipedia.org/wiki/Master_boot_record[Master Boot Record].
|===

파티셔닝 체계를 선택하고 생성한 후 btn:[Create]를 다시 선택하여 파티션을 생성합니다. kbd:[Tab] 키는 필드 간에 커서를 이동하는 데 사용됩니다.

[[bsdinstall-part-manual-addpart]]
.수동으로 파티션 생성
image::bsdinstall-part-manual-addpart.png["메뉴 요청 유형", size, mountpoint and label for the new partition.]

표준 FreeBSD GPT 설치는 UFS 또는 ZFS를 포함하여 최소 3개의 파티션을 사용합니다:

* `freebsd-boot` or `efi` - FreeBSD 부팅 코드를 보유합니다.
* `freebsd-ufs` - FreeBSD UFS 파일 시스템.
* `freebsd-zfs` - FreeBSD ZFS 파일 시스템. ZFS에 대한 자세한 정보는 crossref:zfs[zfs,The Z File System (ZFS)]에서 확인할 수 있습니다.
* `freebsd-swap` - FreeBSD 스왑 공간.

사용 가능한 GPT 파티션 유형에 대한 설명은 man:gpart[8]를 참조하세요.

여러 파일 시스템 파티션을 만들 수 있습니다. 어떤 사람들은 `/`, `/var`, `/tmp` 및 `/usr`에 대해 별도의 파티션이 있는 기존 레이아웃을 선호합니다.

[TIP]
====
메모리가 충분한 시스템에서는 나중에 `/tmp`를 메모리 기반 파일 시스템(man:tmpfs[5])으로 추가할 수 있다는 점에 유의하세요.
====

이에대한 예는 <<bsdinstall-part-manual-splitfs>>을 참조하세요.

`Size`는 일반적인 약어로 입력할 수 있습니다: _K_는 킬로바이트, _M_은 메가바이트, _G_는 기가바이트를 뜻합니다.

[TIP]
====
적절한 섹터 정렬은 최상의 성능을 제공하며, 파티션 크기를 4K 바이트의 짝수 배수로 만들면 512바이트 또는 4K 바이트 섹터가 있는 드라이브에서 정렬을 보장하는 데 도움이 됩니다. 일반적으로 모든 파티션이 4K의 짝수 배수로 시작하도록 하는 가장 쉬운 방법은 1M 또는 1G의 짝수 배수인 파티션 크기를 사용하는 것입니다. 한 가지 예외가 있는데, 현재 부트 코드 제한으로 인해 _freebsd-boot_ 파티션은 512K보다 크지 않아야 합니다.
====

파티션에 파일 시스템이 포함될 경우 `Mountpoint(마운팅 포인트)`가 필요합니다. 단일 UFS 파티션만 생성할 경우 마운트 지점은 `/`여야 합니다.

`Label`은 파티션을 알릴 수 있는 이름입니다. 드라이브가 다른 컨트롤러나 포트에 연결된 경우 드라이브 이름이나 번호는 변경될 수 있지만 파티션 레이블은 변경되지 않습니다. `etc/fstab`과 같은 파일에서 드라이브 이름과 파티션 번호 대신 레이블을 참조하면 시스템이 하드웨어 변경에 더 잘 견딜 수 있습니다. GPT 레이블은 디스크가 연결되면 `/dev/gpt/`에 표시됩니다. 다른 파티셔닝 방식은 레이블 기능이 다르며, 해당 레이블은 `/dev/`의 다른 디렉터리에 표시됩니다.

[TIP]
====
모든 파티션에 고유한 레이블을 사용하여 동일한 레이블로 인한 충돌을 방지하세요. 컴퓨터의 이름, 용도 또는 위치에서 몇 글자를 레이블에 추가할 수 있습니다. 예를 들어, `lab`이라는 컴퓨터의 UFS 루트 파티션에는 `labroot` 또는 `rootfslab`을 사용합니다.
====

[[bsdinstall-part-manual-splitfs]]
.전통적인 분할 파일 시스템 파티션 만들기
[example]
====
`/`, `/var`, `/tmp`, 및 `/usr` 디렉터리가 자체 파티션에 별도의 파일 시스템인 기존 파티션 레이아웃의 경우 GPT 파티셔닝 체계를 만든 다음 그림과 같이 파티션을 생성합니다. 표시된 파티션 크기는 20G 대상 디스크의 일반적인 크기입니다. 대상 디스크에 더 많은 공간을 사용할 수 있는 경우 더 큰 스왑 또는 `/var` 파티션이 유용할 수 있습니다. 여기에 표시된 레이블 앞에는 "예시"를 나타내는 `ex`가 붙지만, 위에서 설명한 대로 다른 고유 레이블 값을 사용해야 합니다.

기본적으로 FreeBSD의 `gptboot`는 첫 번째 UFS 파티션이 `/` 파티션이 될 것으로 예상합니다.

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
| Partition Type
| Size
| Mountpoint
| Label

|`freebsd-boot`
|`512K`
|
|

|`freebsd-ufs`
|`2G`
|`/`
|`exrootfs`

|`freebsd-swap`
|`4G`
|
|`exswap`

|`freebsd-ufs`
|`2G`
|`/var`
|`exvarfs`

|`freebsd-ufs`
|`1G`
|`/tmp`
|`extmpfs`

|`freebsd-ufs`
|accept the default (remainder of the disk)
|`/usr`
|`exusrfs`
|===
====

사용자 지정 파티션이 생성되면 btn:[Finish]을 선택하여 설치를 계속하고 <<bsdinstall-fetching-distribution>>로 이동합니다.

[[bsdinstall-part-zfs]]
=== Root-on-ZFS를 사용한 가이드 파티셔닝

이 파티셔닝 모드는 전체 디스크에서만 작동하며 전체 디스크의 내용을 지웁니다. 기본 ZFS 구성 메뉴에는 풀 생성을 제어할 수 있는 여러 가지 옵션이 있습니다.

[[bsdinstall-zfs-menu]]
.ZFS 파티셔닝 메뉴
image::bsdinstall-zfs-menu.png["ZFS 풀을 구성하는 다양한 옵션을 보여주는 메뉴"]

다음은 이 메뉴의 옵션에 대한 요약입니다:

* `Install` - 선택한 옵션으로 설치를 진행합니다.
* `Pool Type/Disks` - `풀 유형`과 풀을 구성할 디스크를 구성합니다. 자동 ZFS 설치 관리자는 현재 스트라이프 모드를 제외하고 단일 최상위 레벨 vdev 생성만 지원합니다. 보다 복잡한 풀을 생성하려면 <<bsdinstall-part-shell>>의 지침에 따라 풀을 생성하세요.
* `Rescan Devices` - 사용 가능한 디스크 목록을 다시 채웁니다.
* `Disk Info` - 이 메뉴는 파티션 테이블과 장치 모델 번호 및 일련 번호와 같은 다양한 기타 정보(가능한 경우)를 포함하여 각 디스크를 검사하는 데 사용할 수 있습니다.
* `Pool Name` - 풀의 이름을 설정합니다. 기본 이름은 _zroot_입니다.
* `Force 4K Sectors?`- 4K 섹터를 강제로 사용합니다. 기본적으로 설치 관리자는 4K 경계에 맞춰 파티션을 자동으로 생성하고 ZFS가 4K 섹터를 사용하도록 강제합니다. 이 옵션은 512바이트 섹터 디스크에서도 안전하며, 512바이트 디스크에 생성된 풀에 향후 추가 저장 공간 또는 고장난 디스크의 대체용으로 4K 섹터 디스크를 추가할 수 있다는 이점이 있습니다. 활성화 여부를 선택하려면 kbd:[Enter] 키를 누릅니다.
* `Encrypt Disks?`- 디스크 암호화를 통해 사용자는 GELI를 사용하여 디스크를 암호화할 수 있습니다. 디스크 암호화에 대한 자세한 내용은 crossref:disks[disks-encrypting-geli,“Disk Encryption with geli”]에서 확인할 수 있습니다. 활성화 여부를 선택하려면 kbd:[Enter] 키를 누릅니다.
* `Partition Scheme` - 파티션 스키마를 선택합니다. 대부분의 경우 GPT가 권장 옵션입니다. 다른 옵션 중에서 선택하려면 kbd:[Enter] 키를 누릅니다.
* `Swap Size` - 스왑 공간의 크기를 설정합니다.
* `Mirror Swap?` - 디스크 간 스왑을 미러링할지 여부입니다. 미러 스왑을 활성화하면 크래시 덤프가 중단될 수 있습니다. 활성화하려면 kbd:[Enter] 키를 누르세요.
* `Encrypt Swap?` - 스왑을 암호화할지 여부입니다. 시스템이 부팅될 때마다 임시 키로 스왑을 암호화하고 재부팅 시 삭제합니다. 활성화 여부를 선택하려면 kbd:[Enter] 키를 누릅니다. 스왑 암호화에 대한 자세한 내용은 crossref:disks[swap-encrypting,“Encrypting Swap”]에서 확인할 수 있습니다.

kbd:[T]를 선택하여 '풀 유형'과 풀을 구성할 디스크를 구성합니다.

[[bsdinstall-zfs-vdev_type]]
.ZFS 풀 유형
image::bsdinstall-zfs-vdev_type.png["가상 장치 유형을 요청하는 메뉴. 예: 스트라이프(Stripe)", mirror, raidz1]

다음은 이 메뉴에서 선택할 수 있는 '풀 유형'에 대한 요약입니다:

* `stripe` - 스트라이핑은 연결된 모든 장치에 최대 저장 공간을 제공하지만 중복성은 제공하지 않습니다. 하나의 디스크에 장애가 발생하면 풀의 데이터는 돌이킬 수 없이 손실됩니다.
* `mirror` - 미러링은 모든 디스크에 모든 데이터의 전체 복사본을 저장합니다. 미러링은 모든 디스크에서 데이터를 병렬로 읽기 때문에 읽기 성능이 우수합니다. 풀의 모든 디스크에 데이터를 써야 하므로 쓰기 성능이 느립니다. 하나의 디스크를 제외한 모든 디스크에 장애가 발생할 수 있습니다. 이 옵션을 사용하려면 디스크가 2개 이상 필요합니다.
* `raid10` - Striped mirrors. 최고의 성능을 제공하지만 저장 공간이 가장 적습니다. 이 옵션을 사용하려면 짝수 이상의 디스크와 최소 4개의 디스크가 필요합니다.
* `raidz1` - 단일 중복 RAID. 하나의 디스크에 동시에 장애가 발생하도록 허용합니다. 이 옵션을 사용하려면 최소 3개의 디스크가 필요합니다.
* `raidz2` - Double Redundant RAID. 두 개의 디스크에 동시에 장애가 발생할 수 있습니다. 이 옵션을 사용하려면 최소 4개의 디스크가 필요합니다.
* `raidz3` - Triple Redundant RAID. 세 개의 디스크에 동시에 장애가 발생할 수 있습니다. 이 옵션을 사용하려면 최소 5개의 디스크가 필요합니다.

풀 유형`을 선택하면 사용 가능한 디스크 목록이 표시되고 풀을 구성할 디스크를 하나 이상 선택하라는 메시지가 표시됩니다. 그런 다음 충분한 디스크가 선택되었는지 확인하기 위해 구성의 유효성을 검사합니다. 유효성 검사에 실패하면 btn:[<Change Selection>]을 선택하여 디스크 목록으로 돌아가거나 btn:[<Back>]을 선택하여 `풀 유형`을 변경합니다.

[[bsdinstall-zfs-disk_select]]
.디스크 선택
image::bsdinstall-zfs-disk_select.png["풀에 추가할 디스크 수를 요청하는 메뉴"]

[[bsdinstall-zfs-vdev_invalid]]
.잘못된 선택
image::bsdinstall-zfs-vdev_invalid.png["디스크가 충분히 선택되지 않았음을 나타내는 메뉴."]

목록에서 하나 이상의 디스크가 누락되었거나 설치 프로그램이 시작된 후에 디스크가 연결된 경우, btn:[- Rescan Devices]을 선택하여 사용 가능한 디스크 목록을 다시 채웁니다.

[[bsdinstall-zfs-rescan-devices]]
.장치 재검색
image::bsdinstall-zfs-rescan-devices.png["장치 재검색"]

실수로 잘못된 디스크를 지우는 것을 방지하기 위해 btn:[- Disk Info] 메뉴를 사용하여, 사용 가능한 경우 각 디스크의 파티션 테이블과 장치 모델 번호 및 일련 번호와 같은 다양한 기타 정보를 검사할 수 있습니다.

[[bsdinstall-zfs-disk_info]]
.디스크 분석
image::bsdinstall-zfs-disk_info.png["파티션 정보를 표시하는 메뉴."]

kbd:[N]을 선택해 '풀 이름'을 설정합니다. 원하는 이름을 입력한 후 btn:[<OK>]을 선택해 설정하거나 btn:[<Cancel>]을 선택해 메인 메뉴로 돌아가서 기본 이름을 그대로 둡니다.

[[bsdinstall-zfs-pool-name]]
.풀 이름
image::bsdinstall-zfs-pool-name.png["풀의 이름을 요청하는 메뉴."]

kbd:[S]를 선택하여 스왑 크기를 설정합니다. 원하는 크기를 입력한 다음 btn:[<OK>]를 선택해 설정하거나 btn:[<Cancel>]를 선택해 기본 크기를 그대로 두고 메인 메뉴로 돌아갑니다.

[[bsdinstall-zfs-swap-amount]]
.스왑 크기
image::bsdinstall-zfs-swap-amount.png["스왑 메모리 크기를 요청하는 메뉴"]

모든 옵션을 원하는 값으로 설정했으면 메뉴 상단에서 btn:[>>> Install] 옵션을 선택합니다. 그러면 설치 관리자가 선택한 드라이브의 콘텐츠가 삭제되어 ZFS 풀이 생성되기 전에 마지막으로 취소할 수 있는 기회를 제공합니다.

[[bsdinstall-zfs-warning]]
.마지막 기회
image::bsdinstall-zfs-warning.png["사용자에게 데이터가 손실될 것임을 알리는 메뉴"]

GELI 디스크 암호화가 활성화된 경우, 설치 관리자는 디스크 암호화에 사용할 암호를 입력하라는 메시지를 두 번 표시합니다. 그러면 암호화 초기화가 시작됩니다.

[[bsdinstall-zfs-geli_password]]
.디스크 암호화 암호
image::bsdinstall-zfs-geli_password.png["디바이스 암호화를 위한 비밀번호를 요청하는 메뉴."]

[[bsdinstall-zfs-init-encription]]
.암호화 초기화
image::bsdinstall-zfs-init-encription.png["암호화가 초기화 중임을 표시하는 메뉴."]

설치가 정상적으로 진행됩니다. 설치를 계속하려면 <<bsdinstall-fetching-distribution>>로 이동하세요.

[[bsdinstall-part-shell]]
=== 셸 모드 파티셔닝

고급 설치를 생성할 때, bsdinstall 파티셔닝 메뉴는 필요한 수준의 유연성을 제공하지 못할 수 있습니다. 고급 사용자는 파티셔닝 메뉴에서 btn:[Shell] 옵션을 선택하여 드라이브를 수동으로 파티셔닝하고, 파일 시스템을 생성하고, `/tmp/bsdinstall_etc/fstab`을 채우고, `/mnt` 아래에 파일 시스템을 마운트할 수 있습니다. 이 작업이 완료되면 `exit`를 입력하여 bsdinstall으로 돌아가 설치를 계속합니다.

[[bsdinstall-fetching-distribution]]
== 배포 파일 가져오기

설치 시간은 선택한 배포판, 설치 미디어 및 컴퓨터 속도에 따라 달라집니다. 일련의 메시지가 진행 상황을 알려줍니다.

먼저 설치 프로그램이 선택한 디스크를 포맷하고 파티션을 초기화합니다. 다음으로, `bootonly media` 또는 `mini memstick`의 경우 선택한 구성 요소를 다운로드합니다:

[[bsdinstall-distfile-fetching]]
.배포 파일 가져오기
image::bsdinstall-distfile-fetching.png["다양한 구성 요소의 다운로드를 보여주는 메뉴."]

다음으로 배포 파일의 무결성을 확인하여 다운로드 중에 파일이 손상되었거나 설치 미디어에서 잘못 읽히지 않았는지 확인합니다:

[[bsdinstall-distfile-verify]]
.배포 파일 확인
image::bsdinstall-distfile-verifying.png["다양한 구성 요소의 확인을 보여주는 메뉴."]

마지막으로 확인된 배포 파일이 디스크에 추출됩니다:

[[bsdinstall-distfile-extract]]
.배포 파일 추출
image::bsdinstall-distfile-extracting.png["다양한 구성 요소의 추출을 보여주는 메뉴."]

요청된 모든 배포 파일이 추출되면 bsdinstall은 첫 번째 설치 후 구성 화면을 표시합니다. 사용 가능한 설치후 구성 옵션은 다음 섹션에서 설명합니다.

[[bsdinstall-post]]
== 네트워크 인터페이스, 계정, 시간대, 서비스 및 강화

[[bsdinstall-post-root]]
=== `root` 비밀번호 설정

먼저 `root` 비밀번호를 설정해야 합니다. 비밀번호를 입력하는 동안에는 입력 중인 문자가 화면에 표시되지 않습니다. 입력 오류를 방지하기 위해 비밀번호를 두 번 입력해야 합니다.

[[bsdinstall-post-set-root-passwd]]
.`root` 비밀번호 설정
image::bsdinstall-post-root-passwd.png["루트 사용자의 비밀번호를 요청하는 메뉴."]

[[bsdinstall-config-network-dev]]
=== 네트워크 인터페이스 구성

다음으로 컴퓨터에서 찾을 수 있는 네트워크 인터페이스 목록이 표시됩니다. 구성할 인터페이스를 선택합니다.

[[bsdinstall-configure-net-interface]]
.네트워크 인터페이스 선택
image::bsdinstall-configure-network-interface.png["구성할 다양한 네트워크 인터페이스를 보여주는 메뉴."]

이더넷(Ethernet) 인터페이스를 선택한 경우, 설치 프로그램은 <<bsdinstall-configure-net-ipv4>>에 표시된 메뉴로 건너뜁니다. 무선 네트워크 인터페이스를 선택했다면 시스템이 대신 무선 액세스 포인트를 검색합니다:

[[bsdinstall-wireless-scan]]
.무선 액세스 포인트 검색
image::bsdinstall-configure-wireless-scan.png["무선 네트워크 스캔을 보여주는 메뉴입니다."]

무선 네트워크는 각 네트워크에 부여된 짧고 고유한 이름인 SSID(서비스 세트 식별자)로 식별됩니다. 스캔 중에 발견된 SSID가 나열되고 해당 네트워크에 사용할 수 있는 암호화 유형에 대한 설명이 이어집니다. 원하는 SSID가 목록에 나타나지 않으면 btn:[Rescan]을 선택하여 다시 스캔합니다. 원하는 네트워크가 여전히 나타나지 않으면 안테나 연결에 문제가 있는지 확인하거나 컴퓨터를 액세스 포인트에 더 가까이 이동해 보세요. 변경할 때마다 다시 스캔하세요.

[[bsdinstall-wireless-accesspoints]]
.무선 네트워크 선택
image::bsdinstall-configure-wireless-accesspoints.png["연결할 수 있는 다양한 무선 네트워크를 보여주는 메뉴."]

다음으로 선택한 무선 네트워크에 연결하기 위한 암호화 정보를 입력합니다. 보안이 취약한 WEP와 같은 이전 암호화 유형보다 WPA2 암호화를 강력히 권장합니다. 네트워크에서 WPA2를 사용하는 경우 PSK(사전 공유 키)라고도 하는 비밀번호를 입력합니다. 보안상의 이유로 입력 상자에 입력한 문자는 별표로 표시됩니다.

[[bsdinstall-wireless-wpa2]]
.WPA2 설정
image::bsdinstall-configure-wireless-wpa2setup.png["무선 네트워크 비밀번호를 요청하는 메뉴."]

그런 다음 이더넷 또는 무선 인터페이스에서 IPv4 주소를 구성할지 여부를 선택합니다:

[[bsdinstall-configure-net-ipv4]]
.IPv4 네트워킹 선택
image::bsdinstall-configure-network-interface-ipv4.png["선택한 인터페이스에 IPv4를 구성할지 여부를 나타내는 메뉴."]

IPv4 구성 방법에는 두 가지가 있습니다. DHCP는 네트워크 인터페이스를 자동으로 올바르게 구성하므로 네트워크에서 DHCP 서버를 제공하는 경우 이 방법을 사용해야 합니다. 그렇지 않으면 주소지정 정보를 정적구성으로 수동입력해야 합니다.

[NOTE]
====
임의의 네트워크 정보는 작동하지 않으므로 입력하지 마세요. DHCP 서버를 사용할 수 없는 경우 네트워크 관리자 또는 인터넷 서비스 제공업체로부터 <<bsdinstall-collect-network-information, Required Network Information>>에 나열된 정보를 얻으세요.
====

DHCP 서버를 사용할 수 있는 경우, 다음 메뉴에서 btn:[Yes]를 선택하면 네트워크 인터페이스가 자동으로 구성됩니다. 설치 프로그램이 DHCP 서버를 찾고 시스템의 주소지정 정보를 가져오는 동안 잠시 멈추는 것처럼 보입니다.

[[bsdinstall-net-ipv4-dhcp]]
.IPv4 DHCP 구성 선택
image::bsdinstall-configure-network-interface-ipv4-dhcp.png["선택한 인터페이스에 대해 DHCP를 구성할지 여부를 나타내는 메뉴."]

DHCP 서버를 사용할 수 없는 경우, btn:[No]를 선택하고 이 메뉴에 다음 주소 지정 정보를 입력합니다:

[[bsdinstall-net-ipv4-static]]
.IPv4 정적 구성
image::bsdinstall-configure-network-interface-ipv4-static.png["IPv4 네트워크 구성을 위한 데이터를 요청하는 메뉴."]

* `IP Address` - 이 컴퓨터에 할당된 IPv4 주소입니다. 이 주소는 고유해야 하며 로컬 네트워크의 다른 장치에서 이미 사용 중이 아니어야 합니다.
* `Subnet Mask` - 네트워크의 서브넷 마스크입니다.
* `Default Router` - 네트워크의 기본 게이트웨이의 IP 주소입니다.

다음 화면에서 인터페이스를 IPv6에 맞게 구성해야 하는지 묻습니다. IPv6를 사용할 수 있고 원하는 경우 btn:[Yes]를 선택하여 선택합니다.

[[bsdinstall-net-ipv6]]
.IPv6 네트워킹 선택
image::bsdinstall-configure-network-interface-ipv6.png["선택한 인터페이스에 IPv6를 구성할지 여부를 나타내는 메뉴."]

IPv6 역시 두 가지 구성 방법이 있습니다. SLAAC(StateLess Address AutoConfiguration)는 로컬 라우터에 올바른 구성 정보를 자동으로 요청합니다. 자세한 내용은 http://tools.ietf.org/html/rfc4862[rfc4862]를 참조하세요. 정적 구성은 네트워크 정보를 수동으로 입력해야 합니다.

IPv6 라우터를 사용할 수 있는 경우 다음 메뉴에서 btn:[Yes]를 선택하면 네트워크 인터페이스가 자동으로 구성됩니다. 라우터를 찾고 시스템의 주소 지정 정보를 가져오는 동안 설치 프로그램이 1분 정도 일시 정지하는 것처럼 보입니다.

[[bsdinstall-net-ipv6-slaac]]
.IPv6 SLAAC 구성 선택
image::bsdinstall-configure-network-interface-slaac.png["선택한 인터페이스에 대해 SLAAC을 구성할지 여부를 나타내는 메뉴."]

IPv6 라우터를 사용할 수 없는 경우, btn:[No]를 선택하고 이 메뉴에 다음 주소 지정 정보를 입력합니다:

[[bsdinstall-net-ipv6-static]]
.IPv6 정적 구성
image::bsdinstall-configure-network-interface-ipv6-static.png["IPv6 네트워크 구성을 위한 데이터를 요청하는 메뉴."]

* `IPv6 Address` - 이 컴퓨터에 할당된 IPv6 주소입니다. 이 주소는 고유해야 하며 로컬 네트워크의 다른 장치에서 이미 사용 중이 아니어야 합니다.
* `Default Router` - 네트워크의 기본 게이트웨이의 IPv6 주소입니다.

마지막 네트워크 구성 메뉴는 호스트 이름을 네트워크 주소로 변환하는 DNS(도메인 이름 시스템) 확인자를 구성하는 데 사용됩니다. 네트워크 인터페이스를 자동 구성하는데 DHCP 또는 SLAAC를 사용했다면 `Resolver Configuration` 값이 이미 입력되어 있을 수 있습니다. 그렇지 않은 경우 `Search` 필드에 로컬 네트워크의 도메인 이름을 입력합니다. `DNS #1` 및 `DNS #2`는 DNS 서버의 IPv4 및/또는 IPv6 주소입니다. 하나 이상의 DNS 서버가 필요합니다.

[[bsdinstall-net-dns-config]]
.DNS 구성
image::bsdinstall-configure-network-ipv4-dns.png["네트워크의 DNS를 구성하기 위한 데이터를 요청하는 메뉴."]

인터페이스가 구성되면, FreeBSD를 설치하는 컴퓨터와 같은 지역에 위치한 미러 사이트를 선택합니다. 미러가 대상 컴퓨터와 가까우면 파일을 더 빨리 검색할 수 있으므로 설치 시간이 단축됩니다.

[TIP]
====
`ftp://ftp.freebsd.org (메인 사이트)`를 선택하면 가장 가까운 미러로 자동 연결됩니다.
====

[[bsdinstall-netinstall-mirror]]
.미러 선택
image::bsdinstall-netinstall-mirrorselect.png["네트워크 미러를 요청하는 메뉴."]

[[bsdinstall-timezone]]
=== 표준 시간대 설정

다음 일련의 메뉴는 지역, 국가 및 시간대를 선택하여 정확한 현지 시간을 결정하는 데 사용됩니다. 표준 시간대를 설정하면 시스템이 서머타임과 같은 지역 시간 변경 사항을 자동으로 수정하고 다른 표준 시간대 관련 기능을 올바르게 수행할 수 있습니다.

여기에 표시된 예는 유럽 스페인 본토 표준 시간대에 위치한 기계에 대한 예입니다. 선택 항목은 지리적 위치에 따라 달라질 수 있습니다.

[[bsdinstall-timezone-region]]
.지역 선택
image::bsdinstall-timezone-region.png["시간대 지역을 요청하는 메뉴."]

화살표 키를 사용하여 적절한 영역을 선택한 다음 kbd:[Enter]를 누릅니다.

[[bsdinstall-timezone-country]]
.국가 선택
image::bsdinstall-timezone-country.png["표준 시간대 국가를 요청하는 메뉴."]

화살표 키를 사용하여 적절한 국가를 선택하고 kbd:[Enter]를 누릅니다.

[[bsdinstall-timezone-zone]]
.표준 시간대 선택
image::bsdinstall-timezone-zone.png["표준 시간대를 요청하는 메뉴."]

화살표 키를 사용하여 적절한 시간대를 선택하고 kbd:[Enter]를 누릅니다.

[[bsdinstall-timezone-confirmation]]
.시간대 확인
image::bsdinstall-timezone-confirm.png["선택한 시간대 확인을 요청하는 메뉴."]

표준 시간대의 약어가 올바른지 확인합니다.

[[bsdinstall-timezone-date]]
.날짜 선택
image::bsdinstall-timezone-date.png["시스템 날짜를 요청하는 메뉴."]

화살표 키를 사용하여 적절한 날짜를 선택한 다음 btn:[Set Date]을 누릅니다. 그렇지 않으면 btn:[Skip]를 눌러 날짜 선택을 건너뛸 수 있습니다.

[[bsdinstall-timezone-time]]
.시간 선택
image::bsdinstall-timezone-time.png["시스템 시간을 요청하는 메뉴."]

화살표 키를 사용하여 적절한 시간을 선택한 다음 btn:[Set Time]을 누릅니다. 그렇지 않으면 btn:[Skip]를 눌러 시간 선택을 건너뛸 수 있습니다.

[[bsdinstall-sysconf]]
=== 서비스 활성화하기

다음 메뉴는 시스템이 부팅될 때마다 시작할 시스템 서비스를 구성하는 데 사용됩니다. 이 모든 서비스는 선택 사항입니다. 시스템 작동에 필요한 서비스만 시작하세요.

[[bsdinstall-config-serv]]
.사용하도록 설정할 추가 서비스 선택
image::bsdinstall-config-services.png["사용 가능한 다양한 서비스를 보여주는 메뉴."]

다음은 이 메뉴에서 사용 설정할 수 있는 서비스에 대한 요약입니다:

* `local_unbound` - DNS 로컬 언바인딩을 활성화합니다. 이 설정은 로컬 캐싱 포워딩 확인자(local caching forwarding resolver)로만 사용하기 위한 구성이라는 점을 명심해야 합니다. 전체 네트워크에 대한 확인자를 설정하는 것이 목적이라면 package:dns/unbound[]를 설치하세요.
* `sshd` - 보안 셸(SSH) 데몬은 암호화된 연결을 통해 시스템에 원격으로 액세스하는 데 사용됩니다. 시스템을 원격 로그인에 사용할 수 있어야 하는 경우에만 이 서비스를 활성화합니다.
* `moused` - 명령줄 시스템 콘솔에서 마우스를 사용할 경우 이 서비스를 활성화합니다.
* `ntpdate` - 부팅 시 자동 시계 동기화를 활성화합니다. 이 프로그램의 기능은 이제 man:ntpd[8] 데몬에서 사용할 수 있으며 man:ntpdate[8] 유틸리티는 곧 폐기될 예정입니다.
* `ntpd` - 자동 시계 동기화를 위한 네트워크 시간 프로토콜(NTP) 데몬입니다. 시스템 시계를 원격 시간서버 또는 풀과 동기화하려면 이 서비스를 활성화하세요.
* `powerd` - 전원 제어 및 에너지 절약을 위한 시스템 전원 제어 유틸리티입니다.
* `dumpdev` - 크래시 덤프는 시스템 문제를 디버깅할 때 유용하므로 사용자는 이 기능을 활성화하는 것이 좋습니다.

[[bsdinstall-hardening]]
=== 보안 옵션 강화하기

다음 메뉴는 활성화할 보안 옵션을 구성하는 데 사용됩니다. 모든 옵션은 선택 사항입니다. 하지만 사용을 권장합니다.

[[bsdinstall-hardening-options]]
.보안 강화 옵션 선택
image::bsdinstall-hardening.png["다양한 보안 강화 옵션을 제공하는 메뉴."]

다음은 이 메뉴에서 활성화할 수 있는 옵션의 요약입니다:

* `hide_uids` - 다른 사용자(UID)가 실행 중인 프로세스를 숨깁니다. 이렇게 하면 권한이 없는 사용자가 다른 사용자의 실행 중인 프로세스를 볼 수 없습니다.
* `hide_gids` - 다른 그룹(GID)에서 실행 중인 프로세스를 숨깁니다. 이렇게 하면 권한이 없는 사용자가 다른 그룹에서 실행 중인 프로세스를 볼 수 없습니다.
* `hide_jail` - jail에서 실행 중인 프로세스를 숨깁니다. 이렇게 하면 권한이 없는 사용자는 jail 내부에서 실행 중인 프로세스를 볼 수 없습니다.
* `read_msgbuf` - 권한이 없는 사용자의 커널 메시지 버퍼 읽기를 비활성화합니다. 권한이 없는 사용자가 man:dmesg[8]를 사용하여 커널의 로그버퍼에서 메시지를 볼 수 없도록 합니다.
* `proc_debug` - 권한이 없는 사용자에 대한 프로세스 디버깅 기능을 비활성화합니다. 일부 procfs 기능, `ptrace()` 및 `ktrace()`를 포함한 다양한 권한 없는 프로세스 간 디버깅 서비스를 비활성화합니다. 이렇게 하면 man:lldb[1], man:truss[1], man:procstat[1]과 같은 디버깅 도구와 PHP와 같은 특정 스크립팅 언어에 내장된 일부 디버깅 기능도 사용할 수 없습니다.
* `random_pid` - 프로세스의 PID를 랜덤화합니다.
* `clear_tmp` - 시스템이 시작될 때 `/tmp`를 지웁니다.
* `disable_syslogd` - syslogd 네트워크 소켓을 열지 않습니다. 기본적으로 FreeBSD는 `-s`를 사용하여 보안 방식으로 syslogd를 실행합니다. 이렇게 하면 데몬이 포트 514에서 들어오는 UDP 요청을 수신 대기하지 않습니다. 이 옵션을 활성화하면, 대신 `-ss`로 실행되어 syslogd가 포트를 열지 못하도록 합니다. 자세한 내용은 man:syslogd[8]을 참조하십시오.
* `disable_sendmail` - sendmail 메일 전송 에이전트를 비활성화합니다.
* `secure_console` - 단일 사용자 모드로 전환할 때 명령 프롬프트에서 `root` 비밀번호를 요청하도록 합니다.
* `disable_ddtrace` - 실행 중인 커널에 영향을 미치는 모드에서 DTrace를 실행할 수 있습니다. 명시적으로 활성화하지 않으면 파괴적인 동작을 사용할 수 없습니다. DTrace를 사용할 때 이 옵션을 활성화하려면 `-w`를 사용합니다. 자세한 내용은 man:dtrace[1]를 참조하세요.
* `enable_aslr` - 주소 레이아웃 무작위화를 활성화합니다. 주소 레이아웃 무작위화에 대한 자세한 내용은 link:https://en.wikipedia.org/wiki/Address_space_layout_randomization[위키백과 항목]를 참조하세요.

[[bsdinstall-addusers]]
=== 사용자 추가

다음 메뉴에서 하나 이상의 사용자 계정을 만들라는 메시지가 표시됩니다. `root`가 아닌 사용자 계정을 사용하여 시스템에 로그인하는 것이 좋습니다. `root`로 로그인하면 기본적으로 수행할 수 있는 작업에 대한 제한이나 보호가 없습니다. 일반 사용자로 로그인하는 것이 더 안전합니다.

새 사용자를 추가하려면 btn:[Yes]를 선택합니다.

[[bsdinstall-add-user1]]
.사용자 계정 추가
image::bsdinstall-adduser1.png["사용자를 시스템에 추가할지 여부를 요청하는 메뉴."]

메시지에 따라 사용자 계정에 대해 요청된 정보를 입력합니다. <<bsdinstall-add-user2>>에 표시된 예는 `asample` 사용자 계정을 생성합니다.

[[bsdinstall-add-user2]]
.사용자 정보 입력
image::bsdinstall-adduser2.png["새 사용자에게 다른 정보를 요청하는 메뉴입니다."]

다음은 입력할 정보를 요약한 것입니다:

* `Username` - 사용자가 로그인할 때 입력하는 이름입니다. 일반적인 규칙은 각 사용자 이름이 시스템에서 고유한 경우 이름 첫 글자와 성을 결합하여 사용하는 것입니다. 사용자 이름은 대소문자를 구분하며 공백을 포함하지 않아야 합니다.
* `Full name` - 사용자의 전체 이름입니다. 공백을 포함할 수 있으며 사용자 계정에 대한 설명으로 사용됩니다.
* `Uid` - 사용자 ID. 일반적으로 비워두면 시스템에서 자동으로 값을 할당합니다.
* `Login group` - 사용자의 그룹입니다. 일반적으로 기본값으로 사용하려면 비워 두는 것이 좋습니다.
* `Invite _user_ into other groups?` - 사용자를 멤버로 추가할 추가 그룹입니다. 사용자에게 관리 액세스 권한이 필요한 경우 여기에 `wheel`을 입력합니다.
* `Login class` - 일반적으로 기본값으로 비워둡니다.
* `Shell` - 나열된 값 중 하나를 입력하여 사용자에 대한 대화형 셸을 설정합니다. 셸에 대한 자세한 내용은 crossref:basics[shells,Shells]을 참조하세요.
* `Home directory` - 사용자의 홈 디렉토리입니다. 기본값이 일반적으로 정확합니다.
* `Home directory permissions` - 사용자의 홈 디렉터리에 대한 권한입니다. 기본값이 일반적으로 올바릅니다.
* `Use password-based authentication?` - 일반적으로 '예'로 설정하여 로그인 시 비밀번호를 입력하라는 메시지를 표시합니다.
* `Use an empty password?` - 빈 비밀번호나 공란 비밀번호는 안전하지 않으므로 일반적으로 '아니요'입니다.
* `Use a random password?` - 일반적으로 '아니요'를 선택하면 다음 프롬프트에서 사용자가 직접 비밀번호를 설정할 수 있습니다.
* `Enter password` - 이 사용자의 비밀번호입니다. 입력한 문자는 화면에 표시되지 않습니다.
* `Enter password again` - 확인을 위해 비밀번호를 다시 입력해야 합니다.
* `Lock out the account after creation?` - 일반적으로 사용자가 로그인할 수 있도록 '아니요'로 설정합니다.

모든 세부 정보를 입력하면 검토할 수 있는 요약이 표시됩니다. 실수가 있는 경우 `no`를 입력하여 수정합니다. 모든 것이 정확하면 `예`를 입력하여 새 사용자를 만듭니다.

[[bsdinstall-add-user3]]
.사용자 및 그룹 관리 종료(Exit User and Group Management)
image::bsdinstall-adduser3.png["새 사용자의 정보를 표시하고 모든 것이 올바른지 확인하는 메뉴."]

추가할 사용자가 더 있으면 `Add another user?` 질문에 `yes`로 대답합니다. `no`를 입력하면 사용자 추가를 완료하고 설치를 계속합니다.

사용자 추가 및 사용자 관리에 대한 자세한 내용은 crossref:basics[users-synopsis,Users and Basic Account Management]를 참조하세요.

[[bsdinstall-final-conf]]
=== 최종 구성

모든 설치 및 구성이 완료되면 마지막으로 설정을 수정할 수 있는 기회가 제공됩니다.

[[bsdinstall-final-config]]
.최종 구성
image::bsdinstall-finalconfiguration.png["설치를 완료하기 전에 수행해야 할 다양한 옵션을 보여주는 메뉴입니다. 예: 사용자 추가", Time Zone, etc.]

설치를 완료하기 전에 이 메뉴를 사용하여 변경하거나 추가 구성을 수행합니다.

* `Add User` - <<bsdinstall-addusers>>에 설명되어 있습니다.
* `Root Password` - <<bsdinstall-post-root>>에 설명되어 있습니다.
* `Hostname` - <<bsdinstall-hostname>>에 설명되어 있습니다.
* `Network` - <<bsdinstall-config-network-dev>>에 설명되어 있습니다.
* `Services` - <<bsdinstall-sysconf>>에 설명되어 있습니다.
* `System Hardening` - <<bsdinstall-hardening>>에 설명되어 있습니다.
* `Time Zone` - <<bsdinstall-timezone>>에 설명되어 있습니다.
* `Handbook` - FreeBSD 핸드북을 다운로드하여 설치합니다.

구성이 완료되면 btn:[Exit]를 선택합니다.

[[bsdinstall-final-modification-shell]]
.수동 구성
image::bsdinstall-final-modification-shell.png["설치가 완료되었음을 알리는 메뉴가 표시됩니다. 수동으로 변경하기 위해 셸을 열 것인지 묻는 메시지가 표시됨."]

bsdinstall은 새 시스템으로 재부팅하기 전에 수행해야 하는 추가구성이 있는지 묻는 메시지를 표시합니다. 새 시스템 내의 셸로 종료하려면 btn:[Yes]를 선택하고, 설치의 마지막 단계로 진행하려면 btn:[No]를 선택합니다.

[[bsdinstall-final-main]]
.설치 완료
image::bsdinstall-mainexit.png["설치가 완료되었음을 표시하고 시스템을 재부팅할지 라이브 CD에 액세스할지 묻는 메뉴."]

추가 구성이나 특별한 설정이 필요한 경우, btn:[Live CD]를 선택하여 설치 미디어를 라이브 CD 모드로 부팅합니다.

설치가 완료되면 btn:[Reboot]을 선택해 컴퓨터를 재부팅하고 새 FreeBSD 시스템을 시작합니다. FreeBSD 설치 미디어를 제거하지 않으면 설치 미디어로 부팅될 수 있으므로 잊지 마세요.

FreeBSD가 부팅되면 정보 메시지가 표시됩니다. 시스템 부팅이 완료되면 로그인 프롬프트가 표시됩니다. `login:` 프롬프트에서 설치 중에 추가한 사용자 이름을 입력합니다. `root` 로 로그인하지 마세요. 관리 액세스 권한이 필요한 경우 수퍼유저가 되는 방법에 대한 지침은 crossref:basics[users-superuser,The Superuser Account]을 참조하세요.

부팅 중에 표시되는 메시지는 kbd:[Scroll-Lock]을 눌러 스크롤백 버퍼를 켜서 검토할 수 있습니다. kbd:[PgUp], kbd:[PgDn] 및 화살표 키를 사용하여 메시지를 뒤로 스크롤할 수 있습니다. 완료했으면 kbd:[Scroll-Lock]을 다시 눌러 디스플레이의 잠금을 해제하고 콘솔로 돌아갑니다. 시스템을 가동한 후 부팅 메시지를 검토하려면 명령 프롬프트에서 `less /var/run/dmesg.boot`를 입력합니다. 확인 후 명령줄로 돌아가려면 kbd:[q]를 누릅니다.

<<bsdinstall-config-serv>>에서 sshd를 활성화한 경우, 시스템이 SSH 호스트 키를 생성하는 동안 첫 번째 부팅이 약간 느려질 수 있습니다. 이후 부팅은 더 빨라집니다. 그러면 다음 예와 같이 키 핑거프린트가 표시됩니다:

[source, shell]
....
Generating public/private rsa1 key pair.
Your identification has been saved in /etc/ssh/ssh_host_key.
Your public key has been saved in /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key's randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key's randomart image is:
+--[ DSA 1024]----+
|       ..     . .|
|      o  .   . + |
|     . ..   . E .|
|    . .  o o . . |
|     +  S = .    |
|    +  . = o     |
|     +  . * .    |
|    . .  o .     |
|      .o. .      |
+-----------------+
Starting sshd.
....

지문 및 SSH에 대한 자세한 내용은 crossref:security[openssh,"OpenSSH"]를 참조하세요.

FreeBSD는 기본적으로 그래픽 환경을 설치하지 않습니다. 그래픽 창 관리자 설치 및 구성에 대한 자세한 내용은 crossref:x11[x11,The X Window System]을 참조하세요.

FreeBSD 컴퓨터를 올바르게 종료하면 데이터와 하드웨어가 손상되지 않도록 보호할 수 있습니다. _시스템이 제대로 종료되기 전에 전원을 끄지 마세요!_ 사용자가 `wheel` 그룹의 구성원인 경우, 명령줄에 `su`를 입력하고 `root` 암호를 입력하여 수퍼유저가 되세요. 그런 다음 `shutdown -p now`를 입력하면 시스템이 깨끗하게 종료되고 하드웨어가 이를 지원하는 경우 자동으로 꺼집니다.

[[bsdinstall-install-trouble]]
== 문제 해결

이 섹션에서는 사람들이 보고한 일반적인 문제와 같은 기본적인 설치시 문제 해결 방법을 다룹니다.

링크에 나열된 하드웨어 노트( link:https://www.FreeBSD.org/releases/[FreeBSD Release Information] ) 페이지에서 하드웨어가 지원하는 버전의 FreeBSD를 확인하세요.

[NOTE]
====
다양한 하드웨어 구성 요소, 특히 메인보드의 펌웨어를 업데이트하면 일부 설치 문제를 피하거나 완화할 수 있습니다. 메인보드 펌웨어는 일반적으로 BIOS라고 합니다. 대부분의 메인보드 및 컴퓨터 제조업체는 업그레이드 및 업그레이드 정보를 제공하는 웹사이트를 운영하고 있습니다.

제조업체는 일반적으로 중요한 업데이트와 같은 정당한 사유가 없는 한 메인보드 BIOS를 업그레이드하지 말 것을 권장합니다. 업그레이드 프로세스가 잘못되어 BIOS가 불안정해지고 컴퓨터가 작동하지 않을 수 있습니다.
====

부팅시 하드웨어를 검사하는 동안 시스템이 멈추거나 설치 과정에서 이상하게 동작하는 경우, ACPI가 원인일 수 있습니다. FreeBSD는 부팅 중에 시스템 ACPI가 감지되면, 시스템 구성을 돕기 위해 i386 및 amd64 플랫폼에서 시스템 ACPI 서비스를 광범위하게 사용합니다. 안타깝게도 ACPI 드라이버와 시스템 메인보드 및 BIOS 펌웨어 모두에 여전히 일부 버그가 존재합니다. ACPI는 부트 로더의 세번째 단계에서 `hint.acpi.0.disabled`를 설정하여 비활성화할 수 있습니다:

[source, shell]
....
set hint.acpi.0.disabled="1"
....

이는 시스템을 부팅할 때마다 재설정되므로 `hint.acpi.0.disabled="1"`을 `/boot/loader.conf` 파일에 추가해야 합니다. 부트 로더에 대한 자세한 내용은 crossref:boot[boot-synopsis,“Synopsis”]에서 확인할 수 있습니다.

[[using-live-cd]]
== 라이브 CD 사용

<<bsdinstall-choose-mode>>에 표시된 bsdinstall의 시작 메뉴에는 btn:[Live CD] 옵션이 있습니다. 이 옵션은 FreeBSD가 자신에게 적합한 운영체제인지 궁금하고 설치하기 전에 몇 가지 기능을 테스트하고 싶은 분들에게 유용합니다.

btn:[Live CD]를 사용하기 전에 다음 사항에 유의해야 합니다:

* 시스템에 액세스하려면 인증이 필요합니다. 사용자 이름은 'root'이고 비밀번호는 공백입니다.
* 시스템이 설치 미디어에서 직접 실행되므로 하드 디스크에 설치된 시스템보다 현저히 느려집니다.
* 이 옵션은 그래픽 인터페이스가 아닌 명령 프롬프트만 제공합니다.
