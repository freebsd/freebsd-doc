# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Kyung-tak, Yoo <stonegaze@me.com>, 2023.
# "Kyung-tak, Yoo" <stonegaze@me.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2023-04-20 20:56-0300\n"
"PO-Revision-Date: 2023-04-27 23:17+0000\n"
"Last-Translator: \"Kyung-tak, Yoo\" <stonegaze@me.com>\n"
"Language-Team: Korean <https://translate-dev.freebsd.org/projects/"
"documentation/bookshandbookdisks_index/ko/>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "This chapter covers the use of disks and storage media in FreeBSD. This includes SCSI and IDE disks, CD and DVD media, memory-backed disks, and USB storage devices."
msgstr ""
"이 장에서는 FreeBSD에서 디스크와 저장 매체의 사용에 대해 다룹니다. 여기에는 "
"SCSI 및 IDE 디스크, CD 및 DVD 미디어, 메모리 지원 디스크, USB 저장 장치가 "
"포함됩니다."

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "파트 III. 시스템 관리"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/disks/_index.adoc:1
#, no-wrap
msgid "Chapter 19. Storage"
msgstr "19장. 스토리지"

#. type: Title =
#: documentation/content/en/books/handbook/disks/_index.adoc:14
#, no-wrap
msgid "Storage"
msgstr "스토리지"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "요약"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:56
msgid ""
"This chapter covers the use of disks and storage media in FreeBSD.  This "
"includes SCSI and IDE disks, CD and DVD media, memory-backed disks, and USB "
"storage devices."
msgstr ""
"이 장에서는 FreeBSD에서 디스크와 저장 매체의 사용에 대해 다룹니다.  여기에는 "
"SCSI 및 IDE 디스크, CD 및 DVD 미디어, 메모리 지원 디스크, USB 저장 장치가 "
"포함됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:58
msgid "After reading this chapter, you will know:"
msgstr "이 챕터를 읽고 나면, 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:60
msgid "How to add additional hard disks to a FreeBSD system."
msgstr "FreeBSD 시스템에 하드디스크를 추가하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:61
msgid "How to grow the size of a disk's partition on FreeBSD."
msgstr "FreeBSD에서 디스크 파티션의 크기를 늘리는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:62
msgid "How to configure FreeBSD to use USB storage devices."
msgstr "USB 저장 장치를 사용하도록 FreeBSD를 구성하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:63
msgid "How to use CD and DVD media on a FreeBSD system."
msgstr "FreeBSD 시스템에서 CD 및 DVD 미디어를 사용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:64
msgid "How to use the backup programs available under FreeBSD."
msgstr "FreeBSD에서 제공되는 백업 프로그램을 사용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:65
msgid "How to set up memory disks."
msgstr "메모리 디스크를 설정하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:66
msgid "What file system snapshots are and how to use them efficiently."
msgstr "파일 시스템 스냅샷의 정의와 효율적인 사용 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:67
msgid "How to use quotas to limit disk space usage."
msgstr "할당량을 사용하여 디스크 공간 사용량을 제한하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:68
msgid "How to encrypt disks and swap to secure them against attackers."
msgstr "디스크를 암호화하고 스왑하여 공격자로부터 보호하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:69
msgid "How to configure a highly available storage network."
msgstr "고가용성 스토리지 네트워크를 구성하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:71
msgid "Before reading this chapter, you should:"
msgstr "이 챕터를 읽기 전에 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:73
msgid ""
"Know how to crossref:kernelconfig[kernelconfig,configure and install a new "
"FreeBSD kernel]."
msgstr ""
"crossref:kernelconfig[kernelconfig,configure and install a new FreeBSD "
"kernel] 방법을 알아야 합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:75
#, no-wrap
msgid "Adding Disks"
msgstr "디스크 추가하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:80
msgid ""
"This section describes how to add a new SATA disk to a machine that "
"currently only has a single drive.  First, turn off the computer and install "
"the drive in the computer following the instructions of the computer, "
"controller, and drive manufacturers.  Reboot the system and become `root`."
msgstr ""
"이 섹션에서는 현재 드라이브가 하나만 있는 컴퓨터에 새 SATA 디스크를 추가하는 "
"방법을 설명합니다.  먼저 컴퓨터를 끄고 컴퓨터, 컨트롤러 및 드라이브 "
"제조업체의 지침에 따라 컴퓨터에 드라이브를 설치합니다.  시스템을 재부팅하고 "
"`root`가 됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:83
msgid ""
"Inspect [.filename]#/var/run/dmesg.boot# to ensure the new disk was found.  "
"In this example, the newly added SATA drive will appear as [.filename]#ada1#."
msgstr ""
"[.filename]#/var/run/dmesg.boot#를 검사하여 새 디스크가 발견되었는지 "
"확인합니다.  이 예제에서는 새로 추가된 SATA 드라이브가 [.filename]#ada1#으로 "
"표시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:86
msgid ""
"For this example, a single large partition will be created on the new disk.  "
"The http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] partitioning "
"scheme will be used in preference to the older and less versatile MBR scheme."
msgstr ""
"이 예에서는 새 디스크에 하나의 큰 파티션이 만들어집니다.  더 오래되고 "
"활용도가 낮은 MBR 스키마 대신, http://en.wikipedia.org/wiki/"
"GUID_Partition_Table[GPT] 파티셔닝 스키마를 우선적으로 사용할 것입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:91
msgid ""
"If the disk to be added is not blank, old partition information can be "
"removed with `gpart delete`.  See man:gpart[8] for details."
msgstr ""
"추가할 디스크가 비어있지 않으면 `gpart delete`로 이전 파티션 정보를 제거할 "
"수 있습니다.  자세한 내용은 man:gpart[8]를 참고하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:95
msgid ""
"The partition scheme is created, and then a single partition is added.  To "
"improve performance on newer disks with larger hardware block sizes, the "
"partition is aligned to one megabyte boundaries:"
msgstr ""
"파티션 스키마가 생성된 다음 단일 파티션이 추가됩니다.  하드웨어 블록 크기가 "
"더 큰 최신 디스크에서 성능을 향상시키기 위해 파티션은 1메가바이트 경계에 "
"맞춰 정렬됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:100
#, no-wrap
msgid ""
"# gpart create -s GPT ada1\n"
"# gpart add -t freebsd-ufs -a 1M ada1\n"
msgstr ""
"# gpart create -s GPT ada1\n"
"# gpart add -t freebsd-ufs -a 1M ada1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:104
msgid ""
"Depending on use, several smaller partitions may be desired.  See man:"
"gpart[8] for options to create partitions smaller than a whole disk."
msgstr ""
"용도에 따라 여러 개의 작은 파티션이 필요할 수 있습니다.  전체 디스크보다 "
"작은 파티션을 만드는 옵션은 man:gpart[8]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:106
msgid "The disk partition information can be viewed with `gpart show`:"
msgstr "디스크 파티션 정보는 `gpart show`로 확인할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:114
#, no-wrap
msgid ""
"% gpart show ada1\n"
"=>        34  1465146988  ada1  GPT  (699G)\n"
"          34        2014        - free -  (1.0M)\n"
"        2048  1465143296     1  freebsd-ufs  (699G)\n"
"  1465145344        1678        - free -  (839K)\n"
msgstr ""
"% gpart show ada1\n"
"=>        34  1465146988  ada1  GPT  (699G)\n"
"          34        2014        - free -  (1.0M)\n"
"        2048  1465143296     1  freebsd-ufs  (699G)\n"
"  1465145344        1678        - free -  (839K)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:117
msgid "A file system is created in the new partition on the new disk:"
msgstr "새 디스크의 새 파티션에 파일 시스템이 만들어집니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:121
#, no-wrap
msgid "# newfs -U /dev/ada1p1\n"
msgstr "# newfs -U /dev/ada1p1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:124
msgid ""
"An empty directory is created as a _mountpoint_, a location for mounting the "
"new disk in the original disk's file system:"
msgstr "원본 디스크의 파일 시스템에서 새 디스크를 마운트하기 위해, _마운트 포인트_로 "
"사용할 빈 디렉터리를 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:128
#, no-wrap
msgid "# mkdir /newdisk\n"
msgstr "# mkdir /newdisk\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:131
msgid ""
"Finally, an entry is added to [.filename]#/etc/fstab# so the new disk will "
"be mounted automatically at startup:"
msgstr "마지막으로 [.filename]#/etc/fstab#에 항목을 추가하여 시작 시 새 디스크가 "
"자동으로 마운트되도록 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:135
#, no-wrap
msgid "/dev/ada1p1\t/newdisk\tufs\trw\t2\t2\n"
msgstr "/dev/ada1p1\t/newdisk\tufs\trw\t2\t2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:138
msgid "The new disk can be mounted manually, without restarting the system:"
msgstr "새 디스크는 시스템을 다시 시작하지 않고도 수동으로 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:142
#, no-wrap
msgid "# mount /newdisk\n"
msgstr "# mount /newdisk\n"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:145
#, no-wrap
msgid "Resizing and Growing Disks"
msgstr "디스크 크기 조정 및 크기 늘리기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:151
msgid ""
"A disk's capacity can increase without any changes to the data already "
"present.  This happens commonly with virtual machines, when the virtual disk "
"turns out to be too small and is enlarged.  Sometimes a disk image is "
"written to a USB memory stick, but does not use the full capacity.  Here we "
"describe how to resize or _grow_ disk contents to take advantage of "
"increased capacity."
msgstr ""
"디스크의 용량은 이미 존재하는 데이터를 변경하지 않고도 증가시킬 수 "
"있습니다.  이는 가상 머신에서 가상 디스크가 너무 작은 것으로 판명되어 확대할 "
"때 주로 발생합니다.  때때로 디스크 이미지가 USB 메모리 스틱에 기록되지만 "
"전체 용량을 사용하지 않는 경우가 있습니다.  여기에서는 늘어난 용량을 "
"활용하기 위해 디스크 콘텐츠의 크기를 조정하거나 _늘리는_ 방법을 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:154
msgid ""
"Determine the device name of the disk to be resized by inspecting [."
"filename]#/var/run/dmesg.boot#.  In this example, there is only one SATA "
"disk in the system, so the drive will appear as [.filename]#ada0#."
msgstr ""
"[.filename]#/var/run/dmesg.boot#을 검사하여 크기를 조정할 디스크의 장치 "
"이름을 확인합니다.  이 예제에서는 시스템에 SATA 디스크가 하나만 있으므로 "
"드라이브가 [.filename]#ada0#로 표시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:156
msgid "List the partitions on the disk to see the current configuration:"
msgstr "디스크의 파티션을 나열하여 현재 구성을 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:165
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>      34  83886013  ada0  GPT  (48G) [CORRUPT]\n"
"        34       128     1  freebsd-boot  (64k)\n"
"       162  79691648     2  freebsd-ufs  (38G)\n"
"  79691810   4194236     3  freebsd-swap  (2G)\n"
"  83886046         1        - free -  (512B)\n"
msgstr ""
"# gpart show ada0\n"
"=>      34  83886013  ada0  GPT  (48G) [CORRUPT]\n"
"        34       128     1  freebsd-boot  (64k)\n"
"       162  79691648     2  freebsd-ufs  (38G)\n"
"  79691810   4194236     3  freebsd-swap  (2G)\n"
"  83886046         1        - free -  (512B)\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:171
msgid ""
"If the disk was formatted with the http://en.wikipedia.org/wiki/"
"GUID_Partition_Table[GPT] partitioning scheme, it may show as \"corrupted\" "
"because the GPT backup partition table is no longer at the end of the "
"drive.  Fix the backup partition table with `gpart`:"
msgstr ""
"디스크가 http://en.wikipedia.org/wiki/GUID_Partition_Table[GPT] 파티셔닝 "
"스키마로 포맷된 경우 GPT 백업 파티션 테이블이 더 이상 드라이브의 끝에 있지 "
"않기 때문에 \"corrupted\"으로 표시될 수 있습니다.  `gpart`로 백업 파티션 "
"테이블을 수정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:176
#, no-wrap
msgid ""
"# gpart recover ada0\n"
"ada0 recovered\n"
msgstr ""
"# gpart recover ada0\n"
"ada0 recovered\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:181
msgid ""
"Now the additional space on the disk is available for use by a new "
"partition, or an existing partition can be expanded:"
msgstr "이제 디스크의 추가 공간을 새 파티션에서 사용하거나 기존 파티션을 확장할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:190
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810    4194236     3  freebsd-swap  (2G)\n"
"   83886046   18513921        - free -  (8.8G)\n"
msgstr ""
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810    4194236     3  freebsd-swap  (2G)\n"
"   83886046   18513921        - free -  (8.8G)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:195
msgid ""
"Partitions can only be resized into contiguous free space.  Here, the last "
"partition on the disk is the swap partition, but the second partition is the "
"one that needs to be resized.  Swap partitions only contain temporary data, "
"so it can safely be unmounted, deleted, and then recreate the third "
"partition after resizing the second partition."
msgstr ""
"파티션은 인접한 여유 공간으로만 크기를 조정할 수 있습니다.  여기서 디스크의 "
"마지막 파티션은 스왑 파티션이지만 크기를 조정해야 하는 파티션은 두 번째 "
"파티션입니다.  스왑 파티션은 임시 데이터만 포함하므로 안전하게 마운트 "
"해제하고 삭제한 다음 두 번째 파티션의 크기를 조정한 후 세 번째 파티션을 다시 "
"만들 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:197
msgid "Disable the swap partition:"
msgstr "스왑 파티션을 비활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:201
#, no-wrap
msgid "# swapoff /dev/ada0p3\n"
msgstr "# swapoff /dev/ada0p3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:204
msgid ""
"Delete the third partition, specified by the `-i` flag, from the disk _ada0_."
msgstr "`-i` 플래그로 지정된 세 번째 파티션을 _ada0_ 디스크에서 삭제합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:214
#, no-wrap
msgid ""
"# gpart delete -i 3 ada0\n"
"ada0p3 deleted\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810   22708157        - free -  (10G)\n"
msgstr ""
"# gpart delete -i 3 ada0\n"
"ada0p3 deleted\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   79691648     2  freebsd-ufs  (38G)\n"
"   79691810   22708157        - free -  (10G)\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:222
msgid ""
"There is risk of data loss when modifying the partition table of a mounted "
"file system.  It is best to perform the following steps on an unmounted file "
"system while running from a live CD-ROM or USB device.  However, if "
"absolutely necessary, a mounted file system can be resized after disabling "
"GEOM safety features:"
msgstr ""
"마운트된 파일 시스템의 파티션 테이블을 수정하면 데이터가 손실될 위험이 "
"있습니다.  라이브 CD-ROM 또는 USB 장치에서 실행하는 동안 마운트되지 않은 "
"파일 시스템에서 다음 단계를 수행하는 것이 가장 좋습니다.  그러나 꼭 필요한 "
"경우 GEOM 안전 기능을 비활성화한 후 마운트된 파일 시스템의 크기를 조정할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:226
#, no-wrap
msgid "# sysctl kern.geom.debugflags=16\n"
msgstr "# sysctl kern.geom.debugflags=16\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:235
msgid ""
"Resize the partition, leaving room to recreate a swap partition of the "
"desired size.  The partition to resize is specified with `-i`, and the new "
"desired size with `-s`.  Optionally, alignment of the partition is "
"controlled with `-a`.  This only modifies the size of the partition.  The "
"file system in the partition will be expanded in a separate step."
msgstr ""
"파티션 크기를 조정하여 원하는 크기의 스왑 파티션을 다시 만들 수 있는 공간을 "
"남겨 둡니다.  크기를 조정할 파티션은 `-i`로 지정하고 새로 원하는 크기는 `-s`"
"로 지정합니다.  선택적으로 파티션 정렬은 `-a`로 제어합니다.  이것은 파티션의 "
"크기만 수정합니다.  파티션의 파일 시스템은 별도의 단계에서 확장됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:245
#, no-wrap
msgid ""
"# gpart resize -i 2 -s 47G -a 4k ada0\n"
"ada0p2 resized\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661        - free -  (1.8G)\n"
msgstr ""
"# gpart resize -i 2 -s 47G -a 4k ada0\n"
"ada0p2 resized\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661        - free -  (1.8G)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:249
msgid ""
"Recreate the swap partition and activate it.  If no size is specified with `-"
"s`, all remaining space is used:"
msgstr "스왑 파티션을 다시 생성하고 활성화합니다.  `-s`로 크기를 지정하지 않으면 "
"남은 공간이 모두 사용됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:260
#, no-wrap
msgid ""
"# gpart add -t freebsd-swap -a 4k ada0\n"
"ada0p3 added\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661     3  freebsd-swap  (1.8G)\n"
"# swapon /dev/ada0p3\n"
msgstr ""
"# gpart add -t freebsd-swap -a 4k ada0\n"
"ada0p3 added\n"
"# gpart show ada0\n"
"=>       34  102399933  ada0  GPT  (48G)\n"
"         34        128     1  freebsd-boot  (64k)\n"
"        162   98566144     2  freebsd-ufs  (47G)\n"
"   98566306    3833661     3  freebsd-swap  (1.8G)\n"
"# swapon /dev/ada0p3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:263
msgid ""
"Grow the UFS file system to use the new capacity of the resized partition:"
msgstr "크기가 조정된 파티션의 새 용량을 사용하도록 UFS 파일 시스템을 확장합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:273
#, no-wrap
msgid ""
"# growfs /dev/ada0p2\n"
"Device is mounted read-write; resizing will result in temporary write suspension for /.\n"
"It's strongly recommended to make a backup before growing the file system.\n"
"OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes\n"
"super-block backups (for fsck -b #) at:\n"
" 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,\n"
" 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432\n"
msgstr ""
"# growfs /dev/ada0p2\n"
"Device is mounted read-write; resizing will result in temporary write "
"suspension for /.\n"
"It's strongly recommended to make a backup before growing the file system.\n"
"OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/"
"No] Yes\n"
"super-block backups (for fsck -b #) at:\n"
" 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,\n"
" 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:276
msgid ""
"If the file system is ZFS, the resize is triggered by running the `online` "
"subcommand with `-e`:"
msgstr "파일 시스템이 ZFS인 경우, `-e`와 함께 `online` 하위 명령을 실행하면 크기 "
"조정이 트리거됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:280
#, no-wrap
msgid "# zpool online -e zroot /dev/ada0p2\n"
msgstr "# zpool online -e zroot /dev/ada0p2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:283
msgid ""
"Both the partition and the file system on it have now been resized to use "
"the newly-available disk space."
msgstr "이제 파티션과 그 안의 파일 시스템 모두 새로운 디스크 공간을 사용하도록 "
"크기가 조정되었습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:285
#, no-wrap
msgid "USB Storage Devices"
msgstr "USB 저장 장치"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:289
msgid ""
"Many external storage solutions, such as hard drives, USB thumbdrives, and "
"CD and DVD burners, use the Universal Serial Bus (USB).  FreeBSD provides "
"support for USB 1.x, 2.0, and 3.0 devices."
msgstr ""
"하드 드라이브, USB 썸드라이브, CD 및 DVD 버너와 같은 많은 외장 스토리지 "
"솔루션은 USB(범용 직렬 버스)를 사용합니다.  FreeBSD는 USB 1.x, 2.0 및 3.0 "
"장치를 지원합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:294
msgid ""
"USB 3.0 support is not compatible with some hardware, including Haswell "
"(Lynx point) chipsets.  If FreeBSD boots with a `failed with error 19` "
"message, disable xHCI/USB3 in the system BIOS."
msgstr ""
"USB 3.0 지원은 하스웰(Lynx 포인트) 칩셋을 포함한 일부 하드웨어와 호환되지 "
"않습니다.  `failed with error 19`라는 메시지와 함께 FreeBSD가 부팅되는 경우, "
"시스템 BIOS에서 xHCI/USB3를 비활성화하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:298
msgid ""
"Support for USB storage devices is built into the [.filename]#GENERIC# "
"kernel.  For a custom kernel, be sure that the following lines are present "
"in the kernel configuration file:"
msgstr ""
"USB 저장 장치에 대한 지원은 [.filename]#GENERIC# 커널에 내장되어 있습니다.  "
"사용자 지정 커널의 경우 커널 구성 파일에 다음 줄이 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:311
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:315
msgid ""
"FreeBSD uses the man:umass[4] driver which uses the SCSI subsystem to access "
"USB storage devices.  Since any USB device will be seen as a SCSI device by "
"the system, if the USB device is a CD or DVD burner, do _not_ include "
"`device atapicam` in a custom kernel configuration file."
msgstr ""
"FreeBSD는 SCSI 서브 시스템을 사용하여 USB 저장 장치에 액세스하는 man:umass[4]"
" 드라이버를 사용합니다.  모든 USB 장치는 시스템에서 SCSI 장치로 간주되므로, "
"USB 장치가 CD나 DVD 버너인 경우 커스텀 커널 구성 파일에 `device atapicam`을 "
"_포함시키지_ 마세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:317
msgid ""
"The rest of this section demonstrates how to verify that a USB storage "
"device is recognized by FreeBSD and how to configure the device so that it "
"can be used."
msgstr ""
"이 섹션의 나머지 부분에서는 USB 저장 장치가 FreeBSD에서 인식되는지 확인하는 "
"방법과 장치를 사용할 수 있도록 구성하는 방법을 설명합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:318
#, no-wrap
msgid "Device Configuration"
msgstr "장치 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:323
msgid ""
"To test the USB configuration, plug in the USB device.  Use `dmesg` to "
"confirm that the drive appears in the system message buffer.  It should look "
"something like this:"
msgstr ""
"USB 구성을 테스트하려면 USB 장치를 연결합니다.  `dmesg`를 사용하여 "
"드라이브가 시스템 메시지 버퍼에 나타나는지 확인합니다.  다음과 같이 "
"표시되어야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:335
#, no-wrap
msgid ""
"umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0\n"
"umass0:  SCSI over Bulk-Only; quirks = 0x0100\n"
"umass0:4:0:-1: Attached to scbus4\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device\n"
"da0: Serial Number WD-WXE508CAN263\n"
"da0: 40.000MB/s transfers\n"
"da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)\n"
"da0: quirks=0x2<NO_6_BYTE>\n"
msgstr ""
"umass0: <STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3> on usbus0\n"
"umass0:  SCSI over Bulk-Only; quirks = 0x0100\n"
"umass0:4:0:-1: Attached to scbus4\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> Fixed Direct Access SCSI-4 device\n"
"da0: Serial Number WD-WXE508CAN263\n"
"da0: 40.000MB/s transfers\n"
"da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)\n"
"da0: quirks=0x2<NO_6_BYTE>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:338
msgid ""
"The brand, device node ([.filename]#da0#), speed, and size will differ "
"according to the device."
msgstr "브랜드, 디바이스 노드([.filename]#da0#), 속도, 크기는 디바이스에 따라 "
"달라집니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:340
msgid ""
"Since the USB device is seen as a SCSI one, `camcontrol` can be used to list "
"the USB storage devices attached to the system:"
msgstr ""
"USB 장치는 SCSI 장치로 간주되므로 `camcontrol`을 사용하여 시스템에 연결된 "
"USB 저장 장치를 나열할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:345
#, no-wrap
msgid ""
"# camcontrol devlist\n"
"<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)\n"
msgstr ""
"# camcontrol devlist\n"
"<STECH Simple Drive 1.04>          at scbus4 target 0 lun 0 (pass3,da0)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:349
msgid ""
"Alternately, `usbconfig` can be used to list the device.  Refer to man:"
"usbconfig[8] for more information about this command."
msgstr ""
"다른 방법으로 `usbconfig`를 사용하여 장치를 나열할 수 있습니다.  이 명령에 "
"대한 자세한 내용은 man:usbconfig[8]을 참조하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:354
#, no-wrap
msgid ""
"# usbconfig\n"
"ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)\n"
msgstr ""
"# usbconfig\n"
"ugen0.3: <Simple Drive STECH> at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) "
"pwr=ON (2mA)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:358
msgid ""
"If the device has not been formatted, refer to <<disks-adding>> for "
"instructions on how to format and create partitions on the USB drive.  If "
"the drive comes with a file system, it can be mounted by `root` using the "
"instructions in crossref:basics[mount-unmount,“Mounting and Unmounting File "
"Systems”]."
msgstr ""
"장치를 포맷하지 않은 경우, <<disks-adding>>에서 USB 드라이브의 포맷 및 "
"파티션 생성 방법을 참조하세요.  드라이브에 파일 시스템이 함께 제공된 경우, "
"crossref:basics[mount-unmount,“Mounting and Unmounting File Systems”]의 "
"지침에 따라 `root`로 마운트할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:363
msgid ""
"Allowing untrusted users to mount arbitrary media, by enabling `vfs."
"usermount` as described below, should not be considered safe from a security "
"point of view.  Most file systems were not built to safeguard against "
"malicious devices."
msgstr ""
"아래 설명된 대로 `vfs.usermount`를 활성화하여 신뢰할 수 없는 사용자가 임의의 "
"미디어를 마운트할 수 있도록 허용하는 것은 보안 관점에서 안전하다고 볼 수 "
"없습니다.  대부분의 파일 시스템은 악성 디바이스로부터 보호하도록 설계되지 "
"않았습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:367
msgid ""
"To make the device mountable as a normal user, one solution is to make all "
"users of the device a member of the `operator` group using man:pw[8].  Next, "
"ensure that `operator` is able to read and write the device by adding these "
"lines to [.filename]#/etc/devfs.rules#:"
msgstr ""
"일반 사용자로 장치를 마운트할 수 있게 하려면 man:pw[8]을 사용하여 장치의 "
"모든 사용자를 `operator` 그룹의 멤버로 만드는 것이 한 가지 해결책입니다.  "
"그런 다음 [.filename]#/etc/devfs.rules#에 다음을 추가하여 `operator`가 "
"장치를 읽고 쓸 수 있는지 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:372
#, no-wrap
msgid ""
"[localrules=5]\n"
"add path 'da*' mode 0660 group operator\n"
msgstr ""
"[localrules=5]\n"
"add path 'da*' mode 0660 group operator\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:377
msgid ""
"If internal SCSI disks are also installed in the system, change the second "
"line as follows:"
msgstr "시스템에 내부 SCSI 디스크도 설치되어 있는 경우 두 번째 줄을 다음과 같이 "
"변경합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:381
#, no-wrap
msgid "add path 'da[3-9]*' mode 0660 group operator\n"
msgstr "add path 'da[3-9]*' mode 0660 group operator\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:386
msgid ""
"This will exclude the first three SCSI disks ([.filename]#da0# to [."
"filename]#da2#) from belonging to the `operator` group.  Replace _3_ with "
"the number of internal SCSI disks.  Refer to man:devfs.rules[5] for more "
"information about this file."
msgstr ""
"이렇게 하면 처음 세 개의 SCSI 디스크([.filename]#da0# ~ [.filename]#da2#)가 "
"`operator` 그룹에 속하지 않게 됩니다.  _3_을 내부 SCSI 디스크의 수로 "
"바꿉니다.  이 파일에 대한 자세한 내용은 man:devfs.rules[5]를 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:389
msgid "Next, enable the ruleset in [.filename]#/etc/rc.conf#:"
msgstr "그런 다음 [.filename]#/etc/rc.conf#에 규칙 집합을 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:393
#, no-wrap
msgid "devfs_system_ruleset=\"localrules\"\n"
msgstr "devfs_system_ruleset=\"localrules\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:396
msgid ""
"Then, instruct the system to allow regular users to mount file systems by "
"adding the following line to [.filename]#/etc/sysctl.conf#:"
msgstr ""
"그리고 나서 [.filename]#/etc/sysctl.conf#에 다음 줄을 추가하여 일반 사용자가 "
"파일 시스템을 마운트할 수 있도록 시스템에 지시합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:400
#, no-wrap
msgid "vfs.usermount=1\n"
msgstr "vfs.usermount=1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:403
msgid ""
"Since this only takes effect after the next reboot, use `sysctl` to set this "
"variable now:"
msgstr "이 변수는 다음 재부팅 후에만 적용되므로 지금 `sysctl`을 사용하여 이 변수를 "
"설정하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:408
#, no-wrap
msgid ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"
msgstr ""
"# sysctl vfs.usermount=1\n"
"vfs.usermount: 0 -> 1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:414
msgid ""
"The final step is to create a directory where the file system is to be "
"mounted.  This directory needs to be owned by the user that is to mount the "
"file system.  One way to do that is for `root` to create a subdirectory "
"owned by that user as [.filename]#/mnt/username#.  In the following example, "
"replace _username_ with the login name of the user and _usergroup_ with the "
"user's primary group:"
msgstr ""
"마지막 단계는 파일 시스템을 마운트할 디렉터리를 만드는 것입니다.  이 "
"디렉터리는 파일 시스템을 마운트할 사용자가 소유해야 합니다.  이를 위한 한 "
"가지 방법은 'root'가 해당 사용자가 소유한 하위 디렉터리를 [.filename]#/mnt/"
"username#으로 만드는 것입니다.  다음 예제에서는 _username_을 사용자의 로그인 "
"이름으로 바꾸고 _usergroup_을 사용자의 기본 그룹으로 바꿉니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:419
#, no-wrap
msgid ""
"# mkdir /mnt/username\n"
"# chown username:usergroup /mnt/username\n"
msgstr ""
"# mkdir /mnt/username\n"
"# chown username:usergroup /mnt/username\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:423
msgid ""
"Suppose a USB thumbdrive is plugged in, and a device [.filename]#/dev/da0s1# "
"appears.  If the device is formatted with a FAT file system, the user can "
"mount it using:"
msgstr ""
"USB 썸드라이브가 연결되어 있고 [.filename]#/dev/da0s1# 장치가 표시된다고 "
"가정합니다.  장치가 FAT 파일 시스템으로 포맷된 경우 사용자는 다음을 사용하여 "
"마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:427
#, no-wrap
msgid "% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username\n"
msgstr "% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:430
msgid "Before the device can be unplugged, it _must_ be unmounted first:"
msgstr "장치의 플러그를 뽑기 전에 먼저 마운트를 해제해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:434
#, no-wrap
msgid "% umount /mnt/username\n"
msgstr "% umount /mnt/username\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:437
msgid ""
"After device removal, the system message buffer will show messages similar "
"to the following:"
msgstr "장치를 제거한 후 시스템 메시지 버퍼에 다음과 유사한 메시지가 표시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:444
#, no-wrap
msgid ""
"umass0: at uhub3, port 2, addr 3 (disconnected)\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached\n"
"(da0:umass-sim0:0:0:0): Periph destroyed\n"
msgstr ""
"umass0: at uhub3, port 2, addr 3 (disconnected)\n"
"da0 at umass-sim0 bus 0 scbus4 target 0 lun 0\n"
"da0: <STECH Simple Drive 1.04> s/n WD-WXE508CAN263          detached\n"
"(da0:umass-sim0:0:0:0): Periph destroyed\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:446
#, no-wrap
msgid "Automounting Removable Media"
msgstr "이동식 미디어 자동 마운트"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:449
msgid ""
"USB devices can be automatically mounted by uncommenting this line in [."
"filename]#/etc/auto_master#:"
msgstr "USB 장치는 [.filename]#/etc/auto_master#에서 다음 줄을 주석 처리하면 "
"자동으로 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:453
#, no-wrap
msgid "/media\t\t-media\t\t-nosuid\n"
msgstr "/media\t\t-media\t\t-nosuid\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:456
msgid "Then add these lines to [.filename]#/etc/devd.conf#:"
msgstr "그런 다음 [.filename]#/etc/devd.conf#에 이 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:464
#, no-wrap
msgid ""
"notify 100 {\n"
"\tmatch \"system\" \"GEOM\";\n"
"\tmatch \"subsystem\" \"DEV\";\n"
"\taction \"/usr/sbin/automount -c\";\n"
"};\n"
msgstr ""
"notify 100 {\n"
"\tmatch \"system\" \"GEOM\";\n"
"\tmatch \"subsystem\" \"DEV\";\n"
"\taction \"/usr/sbin/automount -c\";\n"
"};\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:467
msgid ""
"Reload the configuration if man:autofs[5] and man:devd[8] are already "
"running:"
msgstr "man:autofs[5] 및 man:devd[8]가 이미 실행 중이면 구성을 다시 로드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:472
#, no-wrap
msgid ""
"# service automount restart\n"
"# service devd restart\n"
msgstr ""
"# service automount restart\n"
"# service devd restart\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:475
msgid ""
"man:autofs[5] can be set to start at boot by adding this line to [."
"filename]#/etc/rc.conf#:"
msgstr ""
"man:autofs[5]가 부팅 시 시작되도록 설정하려면 [.filename]#/etc/rc.conf#에 이 "
"줄을 추가하면 됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:479
#, no-wrap
msgid "autofs_enable=\"YES\"\n"
msgstr "autofs_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:482
msgid "man:autofs[5] requires man:devd[8] to be enabled, as it is by default."
msgstr "man:autofs[5]를 사용하려면 기본적으로 man:devd[8]가 활성화되어 있어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:484
msgid "Start the services immediately with:"
msgstr "즉시 서비스를 시작하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:491
#, no-wrap
msgid ""
"# service automount start\n"
"# service automountd start\n"
"# service autounmountd start\n"
"# service devd start\n"
msgstr ""
"# service automount start\n"
"# service automountd start\n"
"# service autounmountd start\n"
"# service devd start\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:496
msgid ""
"Each file system that can be automatically mounted appears as a directory in "
"[.filename]#/media/#.  The directory is named after the file system label.  "
"If the label is missing, the directory is named after the device node."
msgstr ""
"자동으로 마운트할 수 있는 각 파일 시스템은 [.filename]#/media/#에 디렉터리로 "
"나타납니다.  디렉터리는 파일 시스템 레이블의 이름을 따서 명명됩니다.  "
"레이블이 없는 경우 디렉터리는 장치 노드의 이름을 따서 명명됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:499
msgid ""
"The file system is transparently mounted on the first access, and unmounted "
"after a period of inactivity.  Automounted drives can also be unmounted "
"manually:"
msgstr ""
"파일 시스템은 처음 액세스할 때 투명하게 마운트되고 일정 시간 동안 사용하지 "
"않으면 마운트 해제됩니다.  자동 마운트된 드라이브는 수동으로 마운트 해제할 "
"수도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:503
#, no-wrap
msgid "# automount -fu\n"
msgstr "# automount -fu\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:507
msgid ""
"This mechanism is typically used for memory cards and USB memory sticks.  It "
"can be used with any block device, including optical drives or iSCSILUNs."
msgstr ""
"이 메커니즘은 일반적으로 메모리 카드와 USB 메모리 스틱에 사용됩니다.  광학 "
"드라이브나 iSCSILUN을 포함한 모든 블록 장치와 함께 사용할 수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:509
#, no-wrap
msgid "Creating and Using CD Media"
msgstr "CD 미디어 만들기 및 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:515
msgid ""
"Compact Disc (CD) media provide a number of features that differentiate them "
"from conventional disks.  They are designed so that they can be read "
"continuously without delays to move the head between tracks.  While CD media "
"do have tracks, these refer to a section of data to be read continuously, "
"and not a physical property of the disk.  The ISO 9660 file system was "
"designed to deal with these differences."
msgstr ""
"CD(컴팩트 디스크) 미디어는 기존 디스크와 차별화되는 여러 가지 기능을 "
"제공합니다.  트랙 간에 헤드를 이동하는 데 지연 없이 연속적으로 읽을 수 "
"있도록 설계되었습니다.  CD 미디어에도 트랙이 있지만 이는 디스크의 물리적 "
"특성이 아니라 연속적으로 읽을 수 있는 데이터 섹션을 의미합니다.  ISO 9660 "
"파일 시스템은 이러한 차이점을 처리하도록 설계되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:519
msgid ""
"The FreeBSD Ports Collection provides several utilities for burning and "
"duplicating audio and data CDs.  This chapter demonstrates the use of "
"several command line utilities.  For CD burning software with a graphical "
"utility, consider installing the package:sysutils/xcdroast[] or package:"
"sysutils/k3b[] packages or ports."
msgstr ""
"FreeBSD 포트 컬렉션은 오디오 및 데이터 CD를 굽고 복제하기 위한 여러 "
"유틸리티를 제공합니다.  이 장에서는 몇 가지 명령줄 유틸리티의 사용법을 "
"설명합니다.  그래픽 유틸리티가 있는 CD 굽기 소프트웨어의 경우, package:"
"sysutils/xcdroast[] 또는 package:sysutils/k3b[] 패키지 또는 포트를 설치하는 "
"것을 고려하십시오."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:521
#, no-wrap
msgid "Supported Devices"
msgstr "지원되는 장치"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:525
msgid ""
"The [.filename]#GENERIC# kernel provides support for SCSI, USB, and ATAPICD "
"readers and burners.  If a custom kernel is used, the options that need to "
"be present in the kernel configuration file vary by the type of device."
msgstr ""
"[.filename]#GENERIC# 커널은 SCSI, USB, ATAPICD 리더 및 버너를 지원합니다.  "
"사용자 지정 커널을 사용하는 경우 커널 구성 파일에 있어야 하는 옵션은 장치 "
"유형에 따라 다릅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:527
msgid "For a SCSI burner, make sure these options are present:"
msgstr "SCSI 버너의 경우 이러한 옵션이 있는지 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:534
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:537
msgid "For a USB burner, make sure these options are present:"
msgstr "USB 버너의 경우 이러한 옵션이 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:550
#, no-wrap
msgid ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"
msgstr ""
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device da\t# Direct Access (disks)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
"device uhci\t# provides USB 1.x support\n"
"device ohci\t# provides USB 1.x support\n"
"device ehci\t# provides USB 2.0 support\n"
"device xhci\t# provides USB 3.0 support\n"
"device usb\t# USB Bus (required)\n"
"device umass\t# Disks/Mass storage - Requires scbus and da\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:553
msgid "For an ATAPI burner, make sure these options are present:"
msgstr "ATAPI 버너의 경우 이러한 옵션이 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:560
#, no-wrap
msgid ""
"device ata\t# Legacy ATA/SATA controllers\n"
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"
msgstr ""
"device ata\t# Legacy ATA/SATA controllers\n"
"device scbus\t# SCSI bus (required for ATA/SCSI)\n"
"device pass\t# Passthrough device (direct ATA/SCSI access)\n"
"device cd\t# needed for CD and DVD burners\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:565
msgid ""
"On FreeBSD versions prior to 10.x, this line is also needed in the kernel "
"configuration file if the burner is an ATAPI device:"
msgstr "10.x 이전 FreeBSD 버전에서는 버너가 ATAPI 장치인 경우 커널 구성 파일에 다음 "
"내용이 필요합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:569
#, no-wrap
msgid "device atapicam\n"
msgstr "device atapicam\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:572
msgid ""
"Alternately, this driver can be loaded at boot time by adding the following "
"line to [.filename]#/boot/loader.conf#:"
msgstr "또는 [.filename]#/boot/loader.conf#에 다음 줄을 추가하여 부팅 시 이 "
"드라이버를 로드할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:576
#, no-wrap
msgid "atapicam_load=\"YES\"\n"
msgstr "atapicam_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:579
msgid ""
"This will require a reboot of the system as this driver can only be loaded "
"at boot time."
msgstr "이 드라이버는 부팅 시에만 로드할 수 있으므로 시스템을 재부팅해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:583
msgid ""
"To verify that FreeBSD recognizes the device, run `dmesg` and look for an "
"entry for the device.  On systems prior to 10.x, the device name in the "
"first line of the output will be [.filename]#acd0# instead of [."
"filename]#cd0#."
msgstr ""
"FreeBSD가 장치를 인식하는지 확인하려면 `dmesg`를 실행하고 장치에 대한 항목을 "
"찾습니다.  10.x 이전 시스템에서는 출력 첫 줄의 장치 이름이 [.filename]#cd0#"
"이 아닌 [.filename]#acd0#이 됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:592
#, no-wrap
msgid ""
"% dmesg | grep cd\n"
"cd0 at ahcich1 bus 0 scbus1 target 0 lun 0\n"
"cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device\n"
"cd0: Serial Number M3OD3S34152\n"
"cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)\n"
"cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed\n"
msgstr ""
"% dmesg | grep cd\n"
"cd0 at ahcich1 bus 0 scbus1 target 0 lun 0\n"
"cd0: <HL-DT-ST DVDRAM GU70N LT20> Removable CD-ROM SCSI-0 device\n"
"cd0: Serial Number M3OD3S34152\n"
"cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)\n"
"cd0: Attempt to query device size failed: NOT READY, Medium not present - "
"tray closed\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:595
#, no-wrap
msgid "Burning a CD"
msgstr "CD 굽기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:599
msgid ""
"In FreeBSD, `cdrecord` can be used to burn CDs.  This command is installed "
"with the package:sysutils/cdrtools[] package or port."
msgstr ""
"FreeBSD에서는 `cdrecord`를 사용하여 CD를 구울 수 있습니다.  이 명령은 "
"package:sysutils/cdrtools[] 패키지 또는 포트와 함께 설치됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:602
msgid ""
"While `cdrecord` has many options, basic usage is simple.  Specify the name "
"of the ISO file to burn and, if the system has multiple burner devices, "
"specify the name of the device to use:"
msgstr ""
"`cdrecord`에는 많은 옵션이 있지만 기본 사용법은 간단합니다.  레코딩할 ISO "
"파일의 이름을 지정하고, 시스템에 여러 개의 버너 장치가 있는 경우 사용할 "
"장치의 이름을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:606
#, no-wrap
msgid "# cdrecord dev=device imagefile.iso\n"
msgstr "# cdrecord dev=device imagefile.iso\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:609
msgid ""
"To determine the device name of the burner, use `-scanbus` which might "
"produce results like this:"
msgstr "버너의 장치 이름을 확인하기 위해 `-scanbus`를 사용하면 다음과 같은 결과가 "
"나올 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:633
#, no-wrap
msgid ""
"# cdrecord -scanbus\n"
"ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling\n"
"Using libscg version 'schily-0.9'\n"
"scsibus0:\n"
"        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk\n"
"        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk\n"
"        0,2,0     2) *\n"
"        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk\n"
"        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM\n"
"        0,5,0     5) *\n"
"        0,6,0     6) *\n"
"        0,7,0     7) *\n"
"scsibus1:\n"
"        1,0,0   100) *\n"
"        1,1,0   101) *\n"
"        1,2,0   102) *\n"
"        1,3,0   103) *\n"
"        1,4,0   104) *\n"
"        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM\n"
"        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner\n"
"        1,7,0   107) *\n"
msgstr ""
"# cdrecord -scanbus\n"
"ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 "
"Jörg Schilling\n"
"Using libscg version 'schily-0.9'\n"
"scsibus0:\n"
"        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk\n"
"        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk\n"
"        0,2,0     2) *\n"
"        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk\n"
"        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM\n"
"        0,5,0     5) *\n"
"        0,6,0     6) *\n"
"        0,7,0     7) *\n"
"scsibus1:\n"
"        1,0,0   100) *\n"
"        1,1,0   101) *\n"
"        1,2,0   102) *\n"
"        1,3,0   103) *\n"
"        1,4,0   104) *\n"
"        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM\n"
"        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner\n"
"        1,7,0   107) *\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:638
msgid ""
"Locate the entry for the CD burner and use the three numbers separated by "
"commas as the value for `dev`.  In this case, the Yamaha burner device is "
"`1,5,0`, so the appropriate input to specify that device is `dev=1,5,0`.  "
"Refer to the manual page for `cdrecord` for other ways to specify this value "
"and for information on writing audio tracks and controlling the write speed."
msgstr ""
"CD 버너에 대한 항목을 찾아보면 쉼표로 구분된 세 개의 숫자를 `dev`의 값으로 "
"사용하고 있습니다.  이 경우 Yamaha 버너 장치는 `1,5,0`이므로 해당 장치를 "
"지정하는 데 적합한 입력은 `dev=1,5,0`입니다.  이 값을 지정하는 다른 방법과 "
"오디오 트랙 쓰기 및 쓰기 속도 제어에 대한 정보는 `cdrecord`의 설명서 "
"페이지를 참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:640
msgid ""
"Alternately, run the following command to get the device address of the "
"burner:"
msgstr "또는 다음 명령을 실행하여 버너의 장치 주소를 가져옵니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:645
#, no-wrap
msgid ""
"# camcontrol devlist\n"
"<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)\n"
msgstr ""
"# camcontrol devlist\n"
"<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (cd0,pass0)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:649
msgid ""
"Use the numeric values for `scbus`, `target`, and `lun`.  For this example, "
"`1,0,0` is the device name to use."
msgstr "`scbus`, `target` 및 `lun`에 숫자 값을 사용합니다.  이 예제에서 `1,0,0`은 "
"사용할 장치 이름입니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:651
#, no-wrap
msgid "Writing Data to an ISO File System"
msgstr "ISO 파일 시스템에 데이터 쓰기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:656
msgid ""
"In order to produce a data CD, the data files that are going to make up the "
"tracks on the CD must be prepared before they can be burned to the CD.  In "
"FreeBSD, package:sysutils/cdrtools[] installs `mkisofs`, which can be used "
"to produce an ISO 9660 file system that is an image of a directory tree "
"within a UNIX(R) file system.  The simplest usage is to specify the name of "
"the ISO file to create and the path to the files to place into the ISO 9660 "
"file system:"
msgstr ""
"데이터 CD를 제작하려면, CD의 트랙을 구성할 데이터 파일을 CD에 구울 수 있도록 "
"먼저 준비해야 합니다.  FreeBSD에서, package:sysutils/cdrtools[]는 `mkisofs`"
"를 설치하는데, 이는 UNIX(R) 파일 시스템 내의 디렉토리 트리 이미지인 ISO 9660 "
"파일 시스템을 생성하는 데 사용할 수 있습니다.  가장 간단한 사용법은 생성할 "
"ISO 파일의 이름과 ISO 9660 파일 시스템에 배치할 파일 경로를 지정하는 "
"것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:660
#, no-wrap
msgid "# mkisofs -o imagefile.iso /path/to/tree\n"
msgstr "# mkisofs -o imagefile.iso /path/to/tree\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:663
msgid ""
"This command maps the file names in the specified path to names that fit the "
"limitations of the standard ISO 9660 file system, and will exclude files "
"that do not meet the standard for ISO file systems."
msgstr ""
"이 명령은 지정된 경로의 파일 이름을 표준 ISO 9660 파일 시스템의 제한에 맞는 "
"이름으로 매핑하고 ISO 파일 시스템 표준에 맞지 않는 파일은 제외합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:666
msgid ""
"A number of options are available to overcome the restrictions imposed by "
"the standard.  In particular, `-R` enables the Rock Ridge extensions common "
"to UNIX(R) systems and `-J` enables Joliet extensions used by Microsoft(R) "
"systems."
msgstr ""
"표준에 의해 부과된 제한을 극복하기 위해 여러 가지 옵션을 사용할 수 "
"있습니다.  특히 `-R`은 UNIX(R) 시스템에 공통적으로 사용되는 Rock Ridge "
"확장을 활성화하고 `-J`는 Microsoft(R) 시스템에서 사용되는 Joliet 확장을 "
"활성화합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:669
msgid ""
"For CDs that are going to be used only on FreeBSD systems, `-U` can be used "
"to disable all filename restrictions.  When used with `-R`, it produces a "
"file system image that is identical to the specified FreeBSD tree, even if "
"it violates the ISO 9660 standard."
msgstr ""
"FreeBSD 시스템에서만 사용하려는 CD의 경우, `-U`를 사용하여 모든 파일 이름 "
"제한을 비활성화할 수 있습니다.  `-R`과 함께 사용하면 ISO 9660 표준을 "
"위반하더라도 지정된 FreeBSD 트리와 동일한 파일 시스템 이미지를 생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:677
msgid ""
"The last option of general use is `-b`.  This is used to specify the "
"location of a boot image for use in producing an \"El Torito\" bootable CD.  "
"This option takes an argument which is the path to a boot image from the top "
"of the tree being written to the CD.  By default, `mkisofs` creates an ISO "
"image in \"floppy disk emulation\" mode, and thus expects the boot image to "
"be exactly 1200, 1440 or 2880 KB in size.  Some boot loaders, like the one "
"used by the FreeBSD distribution media, do not use emulation mode.  In this "
"case, `-no-emul-boot` should be used.  So, if [.filename]#/tmp/myboot# holds "
"a bootable FreeBSD system with the boot image in [.filename]#/tmp/myboot/"
"boot/cdboot#, this command would produce [.filename]#/tmp/bootable.iso#:"
msgstr ""
"일반적으로 사용되는 마지막 옵션은 `-b`입니다.  이 옵션은 \"El Torito\" 부팅 "
"가능한 CD를 생성할 때 사용할 부팅 이미지의 위치를 지정하는 데 사용됩니다.  "
"이 옵션은 CD에 기록되는 트리의 맨 위에 있는 부팅 이미지의 경로인 인수를 "
"받습니다.  기본적으로 `mkisofs`는 \"플로피 디스크 에뮬레이션\" 모드에서 ISO "
"이미지를 생성하므로 부팅 이미지의 크기는 정확히 1200, 1440 또는 2880KB가 될 "
"것으로 예상합니다.  FreeBSD 배포 미디어에서 사용하는 것과 같은 일부 부트 "
"로더는 에뮬레이션 모드를 사용하지 않습니다.  이 경우 `-no-emul-boot`를 "
"사용해야 합니다.  따라서 [.filename]#/tmp/myboot#에 부팅 이미지가 있는 부팅 "
"가능한 FreeBSD 시스템이 [.filename]#/tmp/myboot/boot/cdboot#에 있는 경우, 이 "
"명령은 [.filename]#/tmp/bootable.iso#를 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:681
#, no-wrap
msgid "# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot\n"
msgstr ""
"# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:684
msgid "The resulting ISO image can be mounted as a memory disk with:"
msgstr "결과 ISO 이미지는 다음을 사용하여 메모리 디스크로 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:689
#, no-wrap
msgid ""
"# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"
msgstr ""
"# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:692
msgid ""
"One can then verify that [.filename]#/mnt# and [.filename]#/tmp/myboot# are "
"identical."
msgstr "그런 다음 [.filename]#/mnt#와 [.filename]#/tmp/myboot#가 동일한지 확인할 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:695
msgid ""
"There are many other options available for `mkisofs` to fine-tune its "
"behavior.  Refer to man:mkisofs[8] for details."
msgstr ""
"다른 많은 옵션을 사용하여 `mkisofs`의 동작을 세부조정할 수 있습니다.  자세한 "
"내용은 man:mkisofs[8]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:700
msgid ""
"It is possible to copy a data CD to an image file that is functionally "
"equivalent to the image file created with `mkisofs`.  To do so, use [."
"filename]#dd# with the device name as the input file and the name of the ISO "
"to create as the output file:"
msgstr ""
"데이터 CD를 `mkisofs`로 생성한 이미지 파일과 기능적으로 동일한 이미지 파일로 "
"복사할 수 있습니다.  이렇게 하려면 [.filename]#dd#를 장치 이름과 함께 입력 "
"파일로 사용하고 생성할 ISO의 이름을 출력 파일로 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:704
#, no-wrap
msgid "# dd if=/dev/cd0 of=file.iso bs=2048\n"
msgstr "# dd if=/dev/cd0 of=file.iso bs=2048\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:707
msgid ""
"The resulting image file can be burned to CD as described in <<cdrecord>>."
msgstr "결과 이미지 파일은 <<cdrecord>>에 설명된 대로 CD에 구울 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:710
#, no-wrap
msgid "Using Data CDs"
msgstr "데이터 CD 사용"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:713
msgid ""
"Once an ISO has been burned to a CD, it can be mounted by specifying the "
"file system type, the name of the device containing the CD, and an existing "
"mount point:"
msgstr ""
"ISO를 CD에 구운 후에는 파일 시스템 유형, CD가 들어 있는 장치 이름, 기존 "
"마운트 지점을 지정하여 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:717
#, no-wrap
msgid "# mount -t cd9660 /dev/cd0 /mnt\n"
msgstr "# mount -t cd9660 /dev/cd0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:720
msgid ""
"Since `mount` assumes that a file system is of type `ufs`, an `Incorrect "
"super block` error will occur if `-t cd9660` is not included when mounting a "
"data CD."
msgstr ""
"`mount`는 파일 시스템이 `ufs` 유형이라고 가정하기 때문에 데이터 CD를 "
"마운트할 때 `-t cd9660`이 포함되지 않으면 `Incorrect super block` 오류가 "
"발생합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:725
msgid ""
"While any data CD can be mounted this way, disks with certain ISO 9660 "
"extensions might behave oddly.  For example, Joliet disks store all "
"filenames in two-byte Unicode characters.  If some non-English characters "
"show up as question marks, specify the local charset with `-C`.  For more "
"information, refer to man:mount_cd9660[8]."
msgstr ""
"모든 데이터 CD를 이 방법으로 마운트할 수 있지만, 특정 ISO 9660 확장자를 가진 "
"디스크는 이상하게 작동할 수 있습니다.  예를 들어, Joliet 디스크는 모든 파일 "
"이름을 2바이트 유니코드 문자로 저장합니다.  영어가 아닌 일부 문자가 물음표로 "
"표시되는 경우 `-C`로 로컬 문자 집합을 지정합니다.  자세한 내용은 "
"man:mount_cd9660[8]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:730
msgid ""
"In order to do this character conversion with the help of `-C`, the kernel "
"requires the [.filename]#cd9660_iconv.ko# module to be loaded.  This can be "
"done either by adding this line to [.filename]#loader.conf#:"
msgstr ""
"`-C`를 사용하여 이 문자 변환을 수행하려면 커널에 [.filename]#cd9660_iconv.ko#"
" 모듈이 로드되어야 합니다.  이 작업은 [.filename]#loader.conf#에 다음 줄을 "
"추가하여 수행할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:734
#, no-wrap
msgid "cd9660_iconv_load=\"YES\"\n"
msgstr "cd9660_iconv_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:737
msgid ""
"and then rebooting the machine, or by directly loading the module with "
"`kldload`."
msgstr "그리고 나서 머신을 재부팅하거나 `kldload`를 사용하여 모듈을 직접 로드합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:742
msgid ""
"Occasionally, `Device not configured` will be displayed when trying to mount "
"a data CD.  This usually means that the CD drive has not detected a disk in "
"the tray, or that the drive is not visible on the bus.  It can take a couple "
"of seconds for a CD drive to detect media, so be patient."
msgstr ""
"데이터 CD를 마운트하려고 할 때 `Device not configured`이 표시되는 경우가 "
"있습니다.  이는 일반적으로 CD 드라이브가 트레이에 있는 디스크를 감지하지 "
"못했거나 드라이브가 버스에 표시되지 않는다는 의미입니다.  CD 드라이브가 "
"미디어를 감지하는 데 몇 초 정도 걸릴 수 있으므로 조금만 기다려주세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:746
msgid ""
"Sometimes, a SCSICD drive may be missed because it did not have enough time "
"to answer the bus reset.  To resolve this, a custom kernel can be created "
"which increases the default SCSI delay.  Add the following option to the "
"custom kernel configuration file and rebuild the kernel using the "
"instructions in crossref:kernelconfig[kernelconfig-building,“Building and "
"Installing a Custom Kernel”]:"
msgstr ""
"때때로 버스 재설정에 응답할 시간이 충분하지 않아 SCSICD 드라이브가 누락될 수 "
"있습니다.  이 문제를 해결하기 위해 사용자 지정 커널을 생성하여 기본 SCSI "
"지연을 늘릴 수 있습니다.  사용자 지정 커널 구성 파일에 다음 옵션을 추가하고  "
"crossref:kernelconfig[kernelconfig-building,“Building and Installing a "
"Custom Kernel”]의 지침에 따라 커널을 다시 빌드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:750
#, no-wrap
msgid "options SCSI_DELAY=15000\n"
msgstr "options SCSI_DELAY=15000\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:753
msgid ""
"This tells the SCSI bus to pause 15 seconds during boot, to give the CD "
"drive every possible chance to answer the bus reset."
msgstr ""
"이렇게 하면 부팅하는 동안 SCSI 버스가 15초 동안 일시 중지되어 CD 드라이브가 "
"버스 재설정에 응답할 수 있는 기회를 갖도록 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:758
msgid ""
"It is possible to burn a file directly to CD, without creating an ISO 9660 "
"file system.  This is known as burning a raw data CD and some people do this "
"for backup purposes."
msgstr ""
"ISO 9660 파일 시스템을 만들지 않고도 파일을 CD에 직접 구울 수 있습니다.  "
"이를 원시 데이터(raw data ) CD 굽기라고 하며 일부 사람들은 백업 목적으로 이 "
"작업을 수행합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:762
msgid ""
"This type of disk can not be mounted as a normal data CD.  In order to "
"retrieve the data burned to such a CD, the data must be read from the raw "
"device node.  For example, this command will extract a compressed tar file "
"located on the second CD device into the current working directory:"
msgstr ""
"이 유형의 디스크는 일반 데이터 CD로 마운트할 수 없습니다.  이러한 CD에 구운 "
"데이터를 검색하려면 원시 장치 노드에서 데이터를 읽어야 합니다.  예를 들어, "
"이 명령은 두 번째 CD 장치에 있는 압축된 tar 파일을 현재 작업 디렉터리로 "
"추출합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:766
#, no-wrap
msgid "# tar xzvf /dev/cd1\n"
msgstr "# tar xzvf /dev/cd1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:769
msgid "In order to mount a data CD, the data must be written using `mkisofs`."
msgstr "데이터 CD를 마운트하려면 `mkisofs`를 사용하여 데이터를 작성해야 합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:772
#, no-wrap
msgid "Duplicating Audio CDs"
msgstr "오디오 CD 복제하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:775
msgid ""
"To duplicate an audio CD, extract the audio data from the CD to a series of "
"files, then write these files to a blank CD."
msgstr "오디오 CD를 복제하려면 CD에서 오디오 데이터를 일련의 파일로 추출한 다음 이 "
"파일을 빈 CD에 씁니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:778
msgid ""
"<<using-cdrecord>> describes how to duplicate and burn an audio CD.  If the "
"FreeBSD version is less than 10.0 and the device is ATAPI, the `atapicam` "
"module must be first loaded using the instructions in <<atapicam>>."
msgstr ""
"<<using-cdrecord>>에서 오디오 CD를 복제하고 굽는 방법을 설명합니다.  FreeBSD "
"버전이 10.0 미만이고 장치가 ATAPI인 경우, <<atapicam>>의 지침에 따라 "
"`atapicam` 모듈을 먼저 로드해야 합니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:781
#, no-wrap
msgid "Procedure: Duplicating an Audio CD"
msgstr "절차: 오디오 CD 복제하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:783
msgid ""
"The package:sysutils/cdrtools[] package or port installs `cdda2wav`. This "
"command can be used to extract all of the audio tracks, with each track "
"written to a separate WAV file in the current working directory:"
msgstr ""
"package:sysutils/cdrtools[] 패키지 또는 포트는 `cdda2wav`를 설치합니다. 이 "
"명령은 모든 오디오 트랙을 추출하는 데 사용할 수 있으며, 각 트랙은 현재 작업 "
"디렉터리에 별도의 WAV 파일로 기록됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:787
#, no-wrap
msgid "% cdda2wav -vall -B -Owav\n"
msgstr "% cdda2wav -vall -B -Owav\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:791
msgid ""
"A device name does not need to be specified if there is only one CD device "
"on the system.  Refer to the `cdda2wav` manual page for instructions on how "
"to specify a device and to learn more about the other options available for "
"this command."
msgstr ""
"시스템에 CD 장치가 하나만 있는 경우 장치 이름을 지정할 필요가 없습니다.  "
"장치를 지정하는 방법에 대한 지침과 이 명령에 사용할 수 있는 다른 옵션에 대해 "
"자세히 알아보려면 `cdda2wav` 매뉴얼 페이지를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:792
msgid "Use `cdrecord` to write the [.filename]#.wav# files:"
msgstr "`cdrecord`를 사용하여 [.filename]#.wav# 파일을 작성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:796
#, no-wrap
msgid "% cdrecord -v dev=2,0 -dao -useinfo  *.wav\n"
msgstr "% cdrecord -v dev=2,0 -dao -useinfo  *.wav\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:799
msgid ""
"Make sure that _2,0_ is set appropriately, as described in <<cdrecord>>."
msgstr "<<cdrecord>>에서 설명된 대로 _2,0_이 적절하게 설정되었는지 확인합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:801
#, no-wrap
msgid "Creating and Using DVD Media"
msgstr "DVD 미디어 만들기 및 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:805
msgid ""
"Compared to the CD, the DVD is the next generation of optical media storage "
"technology.  The DVD can hold more data than any CD and is the standard for "
"video publishing."
msgstr ""
"CD에 비해 DVD는 차세대 광학 미디어 저장 기술입니다.  DVD는 어떤 CD보다 더 "
"많은 데이터를 저장할 수 있으며 비디오 퍼블리싱의 표준입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:807
msgid "Five physical recordable formats can be defined for a recordable DVD:"
msgstr "레코딩 가능한 DVD에는 5가지 물리적 레코딩 형식을 정의할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:809
msgid ""
"DVD-R: This was the first DVD recordable format available. The DVD-R "
"standard is defined by the http://www.dvdforum.org/forum.shtml[DVD Forum]. "
"This format is write once."
msgstr ""
"DVD-R: 최초의 DVD 기록 가능 포맷입니다. DVD-R 표준은 http://www.dvdforum.org/"
"forum.shtml[DVD 포럼]에서 정의합니다. 이 형식은 한 번만 기록할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:810
msgid ""
"DVD-RW: This is the rewritable version of the DVD-R standard. A DVD-RW can "
"be rewritten about 1000 times."
msgstr "DVD-RW: DVD-R 표준의 재기록 가능 버전입니다. DVD-RW는 약 1000번 다시 쓸 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:811
msgid ""
"DVD-RAM: This is a rewritable format which can be seen as a removable hard "
"drive. However, this media is not compatible with most DVD-ROM drives and "
"DVD-Video players as only a few DVD writers support the DVD-RAM format. "
"Refer to <<creating-dvd-ram>> for more information on DVD-RAM use."
msgstr ""
"DVD-RAM: 이동식 하드 드라이브로 볼 수 있는 재기록 가능한 형식입니다. 그러나 "
"이 미디어는 일부 DVD 라이터만 DVD-RAM 포맷을 지원하므로 대부분의 DVD-ROM "
"드라이브 및 DVD-Video 플레이어와 호환되지 않습니다. DVD-RAM 사용에 대한 "
"자세한 내용은 <<creating-dvd-ram>>을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:812
msgid ""
"DVD+RW: This is a rewritable format defined by the https://en.wikipedia.org/"
"wiki/DVD%2BRW_Alliance[DVD+RW Alliance]. A DVD+RW can be rewritten about "
"1000 times."
msgstr ""
"DVD+RW: https://en.wikipedia.org/wiki/DVD%2BRW_Alliance[DVD+RW 얼라이언스]"
"에서 정의한 재기록 가능 포맷입니다. DVD+RW는 약 1000번 다시 쓸 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:813
msgid "DVD+R: This format is the write once variation of the DVD+RW format."
msgstr "DVD+R: 이 형식은 DVD+RW 형식의 한 번 쓰기 변형입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:815
msgid ""
"A single layer recordable DVD can hold up to 4,700,000,000 bytes which is "
"actually 4.38 GB or 4485 MB as 1 kilobyte is 1024 bytes."
msgstr ""
"단일 레이어 기록 가능 DVD는 최대 4,700,000,000바이트를 저장할 수 있으며, "
"1킬로바이트는 1024바이트이므로 실제로는 4.38GB 또는 4485MB에 해당합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:821
msgid ""
"A distinction must be made between the physical media and the application.  "
"For example, a DVD-Video is a specific file layout that can be written on "
"any recordable DVD physical media such as DVD-R, DVD+R, or DVD-RW.  Before "
"choosing the type of media, ensure that both the burner and the DVD-Video "
"player are compatible with the media under consideration."
msgstr ""
"물리적 미디어와 애플리케이션을 구분해야 합니다.  예를 들어, DVD-Video는 DVD-"
"R, DVD+R 또는 DVD-RW와 같은 기록 가능한 DVD 물리적 미디어에 기록할 수 있는 "
"특정 파일 레이아웃입니다.  미디어 유형을 선택하기 전에 버너와 DVD-비디오 "
"플레이어 모두, 고려 중인 미디어와 호환되는지 확인하십시오."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:823
#, no-wrap
msgid "Configuration"
msgstr "구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:827
msgid ""
"To perform DVD recording, use man:growisofs[1].  This command is part of the "
"package:sysutils/dvd+rw-tools[] utilities which support all DVD media types."
msgstr ""
"DVD 레코딩을 수행하려면 man:growisofs[1]를 사용합니다.  이 명령은 모든 DVD "
"미디어 유형을 지원하는 package:sysutils/dvd+rw-tools[] 유틸리티의 일부입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:831
msgid ""
"These tools use the SCSI subsystem to access the devices, therefore "
"<<atapicam,ATAPI/CAM support>> must be loaded or statically compiled into "
"the kernel.  This support is not needed if the burner uses the USB "
"interface.  Refer to <<usb-disks>> for more details on USB device "
"configuration."
msgstr ""
"이러한 도구는 SCSI 하위 시스템을 사용하여 장치에 액세스하므로 <<atapicam,"
"ATAPI/CAM support>>이 커널에 로드되거나 정적으로 컴파일되어야 합니다.  "
"버너가 USB 인터페이스를 사용하는 경우 이 지원은 필요하지 않습니다.  USB 장치 "
"구성에 대한 자세한 내용은 <<usb-disks>>를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:833
msgid ""
"DMA access must also be enabled for ATAPI devices, by adding the following "
"line to [.filename]#/boot/loader.conf#:"
msgstr ""
"DMA는 [.filename]#/boot/loader.conf#에 다음 줄을 추가하여 ATAPI 장치에 대한 "
"액세스 활성화를 해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:837
#: documentation/content/en/books/handbook/disks/_index.adoc:1070
#, no-wrap
msgid "hw.ata.atapi_dma=\"1\"\n"
msgstr "hw.ata.atapi_dma=\"1\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:840
msgid ""
"Before attempting to use dvd+rw-tools, consult the http://fy.chalmers.se/"
"~appro/linux/DVD+RW/hcn.html[Hardware Compatibility Notes]."
msgstr ""
"dvd+rw-tools를 사용하기 전에 http://fy.chalmers.se/~appro/linux/DVD+RW/hcn."
"html[하드웨어 호환성 참고 사항]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:844
msgid ""
"For a graphical user interface, consider using package:sysutils/k3b[] which "
"provides a user friendly interface to man:growisofs[1] and many other "
"burning tools."
msgstr ""
"그래픽 사용자 인터페이스의 경우, man:growisofs[1] 및 기타 여러 굽기 도구에 "
"사용자 친화적인 인터페이스를 제공하는 package:sysutils/k3b[]를 사용하는 것이 "
"좋습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:846
#, no-wrap
msgid "Burning Data DVDs"
msgstr "데이터 DVD 굽기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:850
msgid ""
"Since man:growisofs[1] is a front-end to <<mkisofs,mkisofs>>, it will invoke "
"man:mkisofs[8] to create the file system layout and perform the write on the "
"DVD.  This means that an image of the data does not need to be created "
"before the burning process."
msgstr ""
"man:growisofs[1]는 <<mkisofs,mkisofs>>에 대한 프런트 엔드이므로, "
"man:mkisofs[8]을 호출하여 파일 시스템 레이아웃을 생성하고 DVD에 쓰기를 "
"수행합니다.  즉, 굽기 프로세스 전에 데이터 이미지를 만들 필요가 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:852
msgid ""
"To burn to a DVD+R or a DVD-R the data in [.filename]#/path/to/data#, use "
"the following command:"
msgstr "[.filename]#/path/to/data#에 있는 데이터를 DVD+R 또는 DVD-R로 구우려면 다음 "
"명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:856
#, no-wrap
msgid "# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:860
msgid ""
"In this example, `-J -R` is passed to man:mkisofs[8] to create an ISO 9660 "
"file system with Joliet and Rock Ridge extensions.  Refer to man:mkisofs[8] "
"for more details."
msgstr ""
"이 예제에서는 `-J -R`을 man:mkisofs[8]에 전달하여 Joliet 및 Rock Ridge "
"확장자를 가진 ISO 9660 파일 시스템을 생성합니다.  자세한 내용은 "
"man:mkisofs[8]을 참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:865
msgid ""
"For the initial session recording, `-Z` is used for both single and multiple "
"sessions.  Replace _/dev/cd0_, with the name of the DVD device.  Using `-dvd-"
"compat` indicates that the disk will be closed and that the recording will "
"be unappendable.  This should also provide better media compatibility with "
"DVD-ROM drives."
msgstr ""
"초기 세션 녹화의 경우 단일 세션과 다중 세션 모두에 `-Z`가 사용됩니다.  _/dev/"
"cd0_를 DVD 장치의 이름으로 바꿉니다.  `-dvd-compat`을 사용하면 디스크가 "
"닫히고 레코딩을 추가할 수 없음을 나타냅니다.  이렇게 하면 DVD-ROM "
"드라이브와의 미디어 호환성이 향상됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:867
msgid "To burn a pre-mastered image, such as _imagefile.iso_, use:"
msgstr "_imagefile.iso_와 같이 미리 마스터링된 이미지를 구우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:871
#, no-wrap
msgid "# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso\n"
msgstr "# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:875
msgid ""
"The write speed should be detected and automatically set according to the "
"media and the drive being used.  To force the write speed, use `-speed=`. "
"Refer to man:growisofs[1] for example usage."
msgstr ""
"쓰기 속도는 사용 중인 미디어와 드라이브에 따라 감지되고 자동으로 설정되어야 "
"합니다.  쓰기 속도를 강제로 설정하려면 `-speed=`를 사용합니다. 예제 사용법은 "
"man:growisofs[1]을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:882
msgid ""
"In order to support working files larger than 4.38GB, an UDF/ISO-9660 hybrid "
"file system must be created by passing `-udf -iso-level 3` to man:mkisofs[8] "
"and all related programs, such as man:growisofs[1].  This is required only "
"when creating an ISO image file or when writing files directly to a disk.  "
"Since a disk created this way must be mounted as an UDF file system with man:"
"mount_udf[8], it will be usable only on an UDF aware operating system.  "
"Otherwise it will look as if it contains corrupted files."
msgstr ""
"4.38GB보다 큰 작업 파일을 지원하려면 `-udf -iso-level 3`을 man:mkisofs[8] 및 "
"man:growisofs[1]와 같은 모든 관련 프로그램에 전달하여 UDF/ISO-9660 "
"하이브리드 파일 시스템을 만들어야 합니다.  이 옵션은 ISO 이미지 파일을 "
"만들거나 디스크에 직접 파일을 쓸 때만 필요합니다.  이렇게 만든 디스크는 "
"man:mount_udf[8]를 사용하여 UDF 파일 시스템으로 마운트해야 하므로, UDF를 "
"인식하는 운영 체제에서만 사용할 수 있습니다.  그렇지 않으면 손상된 파일이 "
"포함된 것처럼 보입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:884
msgid "To create this type of ISO file:"
msgstr "이 유형의 ISO 파일을 만들려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:888
#, no-wrap
msgid "% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data\n"
msgstr "% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:891
msgid "To burn files directly to a disk:"
msgstr "디스크에 직접 파일을 구우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:895
#, no-wrap
msgid "# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data\n"
msgstr ""
"# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:898
msgid ""
"When an ISO image already contains large files, no additional options are "
"required for man:growisofs[1] to burn that image on a disk."
msgstr ""
"ISO 이미지에 이미 대용량 파일이 포함되어 있는 경우, man:growisofs[1]가 해당 "
"이미지를 디스크에 구울 때 추가 옵션이 필요하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:901
msgid ""
"Be sure to use an up-to-date version of package:sysutils/cdrtools[], which "
"contains man:mkisofs[8], as an older version may not contain large files "
"support.  If the latest version does not work, install package:sysutils/"
"cdrtools-devel[] and read its man:mkisofs[8]."
msgstr ""
"이전 버전에는 대용량 파일을 지원하지 않을 수 있으므로 man:mkisofs[8]가 "
"포함된 최신 버전의 package:sysutils/cdrtools[]를 사용해야 합니다.  최신 "
"버전이 작동하지 않는 경우 package:sysutils/cdrtools-devel[]을 설치하고 "
"man:mkisofs[8]을 읽어보세요."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:903
#, no-wrap
msgid "Burning a DVD-Video"
msgstr "DVD-비디오 굽기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:907
msgid ""
"A DVD-Video is a specific file layout based on the ISO 9660 and micro-UDF (M-"
"UDF) specifications.  Since DVD-Video presents a specific data structure "
"hierarchy, a particular program such as package:multimedia/dvdauthor[] is "
"needed to author the DVD."
msgstr ""
"DVD-비디오는 ISO 9660 및 micro-UDF (M-UDF) 사양에 기반한 파일 "
"레이아웃입니다.  DVD-Video는 특징적인 데이터 구조 계층 구조를 제공하므로 "
"DVD를 제작하려면 package:multimedia/dvdauthor[]와 같은 프로그램이 필요합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:910
msgid ""
"If an image of the DVD-Video file system already exists, it can be burned in "
"the same way as any other image.  If `dvdauthor` was used to make the DVD "
"and the result is in [.filename]#/path/to/video#, the following command "
"should be used to burn the DVD-Video:"
msgstr ""
"DVD-Video 파일 시스템의 이미지가 이미 존재하는 경우 다른 이미지와 동일한 "
"방법으로 구울 수 있습니다.  DVD를 만드는 데 `dvdauthor`를 사용했고 그 결과가 "
"[.filename]#/path/to/video#에 있는 경우, 다음 명령을 사용하여 DVD-Video를 "
"구워야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:914
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -dvd-video /path/to/video\n"
msgstr "# growisofs -Z /dev/cd0 -dvd-video /path/to/video\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:918
msgid ""
"`-dvd-video` is passed to man:mkisofs[8] to instruct it to create a DVD-"
"Video file system layout.  This option implies the `-dvd-compat` man:"
"growisofs[1] option."
msgstr ""
"`-dvd-video`는 DVD-Video 파일 시스템 레이아웃을 만들도록 man:mkisofs[8]에 "
"지시하는 옵션입니다.  이 옵션은 `-dvd-compat` man:growisofs[1] 옵션을 "
"뜻합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:919
#, no-wrap
msgid "Using a DVD+RW"
msgstr "DVD+RW 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:924
msgid ""
"Unlike CD-RW, a virgin DVD+RW needs to be formatted before first use.  It is "
"_recommended_ to let man:growisofs[1] take care of this automatically "
"whenever appropriate.  However, it is possible to use `dvd+rw-format` to "
"format the DVD+RW:"
msgstr ""
"CD-RW와 달리 비어있는 DVD+RW는 처음 사용하기 전에 포맷해야 합니다.  가능하면 "
"man:growisofs[1]가 이 작업을 자동으로 처리하도록 하는 것을 _권장_합니다.  "
"그러나 `dvd+rw-format`을 사용하여 DVD+RW를 포맷할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:928
#: documentation/content/en/books/handbook/disks/_index.adoc:1018
#, no-wrap
msgid "# dvd+rw-format /dev/cd0\n"
msgstr "# dvd+rw-format /dev/cd0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:932
msgid ""
"Only perform this operation once and keep in mind that only virgin DVD+RW "
"medias need to be formatted.  Once formatted, the DVD+RW can be burned as "
"usual."
msgstr ""
"이 작업은 한 번만 수행하고 비어있는 DVD+RW 미디어만 포맷해야 한다는 점에 "
"유의하세요.  포맷이 완료되면 DVD+RW는 평소와 같이 구울 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:935
msgid ""
"To burn a totally new file system and not just append some data onto a DVD"
"+RW, the media does not need to be blanked first.  Instead, write over the "
"previous recording like this:"
msgstr ""
"DVD+RW에 일부 데이터를 추가하는 것이 아니라 완전히 새로운 파일 시스템을 "
"구우려면 먼저 미디어를 비울 필요가 없습니다.  다음과 같이 이전 레코딩을 "
"덮어쓰면 됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:939
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -J -R /path/to/newdata\n"
msgstr "# growisofs -Z /dev/cd0 -J -R /path/to/newdata\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:944
msgid ""
"The DVD+RW format supports appending data to a previous recording.  This "
"operation consists of merging a new session to the existing one as it is not "
"considered to be multi-session writing.  man:growisofs[1] will _grow_ the "
"ISO 9660 file system present on the media."
msgstr ""
"DVD+RW 포맷은 이전 기록에 데이터를 추가하는 기능을 지원합니다.  이 작업은 "
"다중 세션 쓰기로 간주되지 않으므로 새 세션을 기존 세션에 병합하는 것으로 "
"구성됩니다. man:growisofs[1]은 미디어에 있는 ISO 9660 파일 시스템을 "
"_성장_시킵니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:946
msgid "For example, to append data to a DVD+RW, use the following:"
msgstr "예를 들어 DVD+RW에 데이터를 추가하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:950
#: documentation/content/en/books/handbook/disks/_index.adoc:1038
#, no-wrap
msgid "# growisofs -M /dev/cd0 -J -R /path/to/nextdata\n"
msgstr "# growisofs -M /dev/cd0 -J -R /path/to/nextdata\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:953
msgid ""
"The same man:mkisofs[8] options used to burn the initial session should be "
"used during next writes."
msgstr "다음 쓰기 시에는 초기 세션을 구울 때 사용한 것과 동일한 man:mkisofs[8] "
"옵션을 사용해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:958
msgid ""
"Use `-dvd-compat` for better media compatibility with DVD-ROM drives.  When "
"using DVD+RW, this option will not prevent the addition of data."
msgstr ""
"DVD-ROM 드라이브와의 미디어 호환성을 높이려면 `-dvd-compat`을 사용하세요.  "
"DVD+RW를 사용하는 경우 이 옵션은 데이터 추가를 막지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:961
msgid "To blank the media, use:"
msgstr "미디어를 비우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:965
#, no-wrap
msgid "# growisofs -Z /dev/cd0=/dev/zero\n"
msgstr "# growisofs -Z /dev/cd0=/dev/zero\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:967
#, no-wrap
msgid "Using a DVD-RW"
msgstr "DVD-RW 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:971
msgid ""
"A DVD-RW accepts two disc formats: incremental sequential and restricted "
"overwrite.  By default, DVD-RW discs are in sequential format."
msgstr ""
"DVD-RW는 두 가지 디스크 포맷을 지원합니다: 증분 순차 덮어쓰기와 제한 "
"덮어쓰기입니다.  기본적으로 DVD-RW 디스크는 순차 포맷입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:974
msgid ""
"A virgin DVD-RW can be directly written without being formatted.  However, a "
"non-virgin DVD-RW in sequential format needs to be blanked before writing a "
"new initial session."
msgstr ""
"비어있는 DVD-RW는 포맷하지 않고 직접 기록할 수 있습니다.  그러나 순차 포맷이 "
"아닌 공 DVD-RW는 새 초기 세션을 쓰기 전에 한차례 삭제해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:976
msgid "To blank a DVD-RW in sequential mode:"
msgstr "순차 모드에서 DVD-RW를 비우려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:980
#: documentation/content/en/books/handbook/disks/_index.adoc:1025
#, no-wrap
msgid "# dvd+rw-format -blank=full /dev/cd0\n"
msgstr "# dvd+rw-format -blank=full /dev/cd0\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:987
msgid ""
"A full blanking using `-blank=full` will take about one hour on a 1x media.  "
"A fast blanking can be performed using `-blank`, if the DVD-RW will be "
"recorded in Disk-At-Once (DAO) mode.  To burn the DVD-RW in DAO mode, use "
"the command:"
msgstr ""
"`-blank=full`를 사용한 전체 블랭크는 1x 미디어에서 약 1시간이 소요됩니다.  "
"DVD-RW를 한번에 디스크 기록(DAO) 모드로 기록할 경우 `-blank`를 사용하여 빠른 "
"삭제를 수행할 수 있습니다.  DAO 모드에서 DVD-RW를 구우려면 다음 명령을 "
"사용하십시오:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:991
#, no-wrap
msgid "# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso\n"
msgstr "# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:994
msgid ""
"Since man:growisofs[1] automatically attempts to detect fast blanked media "
"and engage DAO write, `-use-the-force-luke=dao` should not be required."
msgstr ""
"man:growisofs[1]는 자동으로 빠르게 비워진 미디어를 감지하고 DAO 쓰기를 "
"시도하므로 `-use-the-force-luke=dao` 옵션이 필요하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:996
msgid ""
"One should instead use restricted overwrite mode with any DVD-RW as this "
"format is more flexible than the default of incremental sequential."
msgstr "이 형식은 기본값인 증분 순차보다 유연성이 뛰어나므로 DVD-RW에 제한 덮어쓰기 "
"모드를 사용하는 것이 좋습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:999
msgid ""
"To write data on a sequential DVD-RW, use the same instructions as for the "
"other DVD formats:"
msgstr "순차모드로 DVD-RW에 데이터를 기록하려면 다른 DVD 포맷과 동일한 지침을 "
"따르세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1003
#, no-wrap
msgid "# growisofs -Z /dev/cd0 -J -R /path/to/data\n"
msgstr "# growisofs -Z /dev/cd0 -J -R /path/to/data\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1007
msgid ""
"To append some data to a previous recording, use `-M` with man:"
"growisofs[1].  However, if data is appended on a DVD-RW in incremental "
"sequential mode, a new session will be created on the disc and the result "
"will be a multi-session disc."
msgstr ""
"이전 레코딩에 일부 데이터를 추가하려면 `-M`과 함께 man:growisofs[1]을 "
"사용합니다.  그러나 DVD-RW에 데이터를 증분 순차 모드로 추가하면 디스크에 새 "
"세션이 생성되고 그 결과 멀티 세션 디스크가 됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1012
msgid ""
"A DVD-RW in restricted overwrite format does not need to be blanked before a "
"new initial session.  Instead, overwrite the disc with `-Z`.  It is also "
"possible to grow an existing ISO 9660 file system written on the disc with `-"
"M`.  The result will be a one-session DVD."
msgstr ""
"제한된 덮어쓰기 형식의 DVD-RW는 새로운 초기 세션 전에 디스크를 비울 필요가 "
"없습니다.  대신 `-Z`로 디스크를 덮어씁니다.  디스크에 기록된 기존 ISO 9660 "
"파일 시스템을 `-M`으로 성장시킬 수도 있습니다.  결과적으로 싱글 세션 DVD가 "
"됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1014
msgid ""
"To put a DVD-RW in restricted overwrite format, the following command must "
"be used:"
msgstr "DVD-RW를 제한된 덮어쓰기 포맷으로 설정하려면 다음 명령을 사용해야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1021
msgid "To change back to sequential format, use:"
msgstr "순차 형식으로 다시 변경하려면 다음을 사용합니다:"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1027
#, no-wrap
msgid "Multi-Session"
msgstr "멀티 세션"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1032
msgid ""
"Few DVD-ROM drives support multi-session DVDs and most of the time only read "
"the first session.  DVD+R, DVD-R and DVD-RW in sequential format can accept "
"multiple sessions.  The notion of multiple sessions does not exist for the "
"DVD+RW and the DVD-RW restricted overwrite formats."
msgstr ""
"멀티 세션 DVD를 지원하는 DVD-ROM 드라이브는 거의 없으며 대부분의 경우 첫 "
"번째 세션만 읽습니다.  순차 형식의 DVD+R, DVD-R 및 DVD-RW는 여러 세션을 "
"수용할 수 있습니다.  DVD+RW 및 덮어쓰기 제한 형식의 DVD-RW에는 다중 "
"세션이라는 개념이 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1034
msgid ""
"Using the following command after an initial non-closed session on a DVD+R, "
"DVD-R, or DVD-RW in sequential format, will add a new session to the disc:"
msgstr ""
"DVD+R, DVD-R 또는 DVD-RW에서 순차적으로 닫히지 않은 초기 세션이 끝난 후 다음 "
"명령을 사용하면 디스크에 새 세션이 추가됩니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1043
msgid ""
"Using this command with a DVD+RW or a DVD-RW in restricted overwrite mode "
"will append data while merging the new session to the existing one.  The "
"result will be a single-session disc.  Use this method to add data after an "
"initial write on these types of media."
msgstr ""
"이 명령을 제한된 덮어쓰기 모드에서 DVD+RW 또는 DVD-RW와 함께 사용하면 새 "
"세션을 기존 세션에 병합하면서 데이터를 추가할 수 있습니다.  결과는 단일 세션 "
"디스크가 됩니다.  이러한 유형의 미디어에 처음 쓴 후 데이터를 추가하려면 다음 "
"방법을 사용하십시오."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1048
msgid ""
"Since some space on the media is used between each session to mark the end "
"and start of sessions, one should add sessions with a large amount of data "
"to optimize media space.  The number of sessions is limited to 154 for a DVD"
"+R, about 2000 for a DVD-R, and 127 for a DVD+R Double Layer."
msgstr ""
"각 세션 사이에는 세션의 끝과 시작을 표시하기 위해 미디어의 일부 공간이 "
"사용되므로 미디어 공간을 최적화하려면 데이터 용량이 큰 세션을 추가해야 "
"합니다.  세션 수는 DVD+R의 경우 154개, DVD-R의 경우 약 2000개, DVD+R 더블 "
"레이어의 경우 127개로 제한됩니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1050
#, no-wrap
msgid "For More Information"
msgstr "추가정보"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1053
msgid ""
"To obtain more information about a DVD, use `dvd+rw-mediainfo _/dev/cd0_` "
"while the disc in the specified drive."
msgstr ""
"DVD에 대한 자세한 정보를 얻으려면 지정된 드라이브에 디스크가 있는 상태에서 "
"`dvd+rw-mediainfo _/dev/cd0_`를 사용하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1055
msgid ""
"More information about dvd+rw-tools can be found in man:growisofs[1], on the "
"http://fy.chalmers.se/~appro/linux/DVD+RW/[dvd+rw-tools web site], and in "
"the http://lists.debian.org/cdwrite/[cdwrite mailing list] archives."
msgstr ""
"dvd+rw-tools에 대한 자세한 내용은 man:growisofs[1], http://fy.chalmers.se/~"
"appro/linux/DVD+RW/[dvd+rw-tools 웹 사이트] 및 http://lists.debian.org/"
"cdwrite/[cdwrite 메일링 리스트] 아카이브에서 확인할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1059
msgid ""
"When creating a problem report related to the use of dvd+rw-tools, always "
"include the output of `dvd+rw-mediainfo`."
msgstr "DVD+RW 도구 사용과 관련된 문제 보고서를 작성할 때는 항상 `dvd+rw-mediainfo`"
"의 출력을 포함하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1062
#, no-wrap
msgid "Using a DVD-RAM"
msgstr "DVD-RAM 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1066
msgid ""
"DVD-RAM writers can use either a SCSI or ATAPI interface.  For ATAPI "
"devices, DMA access has to be enabled by adding the following line to [."
"filename]#/boot/loader.conf#:"
msgstr ""
"DVD-RAM 라이터는 SCSI 또는 ATAPI 인터페이스를 사용할 수 있습니다.  ATAPI "
"장치의 경우 [.filename]#/boot/loader.conf#에 다음 줄을 추가하여 DMA 액세스를 "
"활성화해야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1075
msgid ""
"A DVD-RAM can be seen as a removable hard drive.  Like any other hard drive, "
"the DVD-RAM must be formatted before it can be used.  In this example, the "
"whole disk space will be formatted with a standard UFS2 file system:"
msgstr ""
"DVD-RAM은 이동식 하드 드라이브로 볼 수 있습니다.  다른 하드 드라이브와 "
"마찬가지로 DVD-RAM을 사용하려면 먼저 포맷해야 합니다.  이 예에서는 전체 "
"디스크 공간이 표준 UFS2 파일 시스템으로 포맷됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1081
#, no-wrap
msgid ""
"# dd if=/dev/zero of=/dev/acd0 bs=2k count=1\n"
"# bsdlabel -Bw acd0\n"
"# newfs /dev/acd0\n"
msgstr ""
"# dd if=/dev/zero of=/dev/acd0 bs=2k count=1\n"
"# bsdlabel -Bw acd0\n"
"# newfs /dev/acd0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1084
msgid ""
"The DVD device, [.filename]#acd0#, must be changed according to the "
"configuration."
msgstr "DVD 장치인 [.filename]#acd0#은 반드시 구성을 이용해 변경해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1086
msgid ""
"Once the DVD-RAM has been formatted, it can be mounted as a normal hard "
"drive:"
msgstr "DVD-RAM을 포맷한 후에는 일반 하드 드라이브처럼 마운트 할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1090
#, no-wrap
msgid "# mount /dev/acd0 /mnt\n"
msgstr "# mount /dev/acd0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1093
msgid "Once mounted, the DVD-RAM will be both readable and writeable."
msgstr "마운트가 완료되면 DVD-RAM은 읽기 및 쓰기가 모두 가능합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1095
#, no-wrap
msgid "Creating and Using Floppy Disks"
msgstr "플로피 디스크 만들기 및 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1098
msgid "This section explains how to format a 3.5 inch floppy disk in FreeBSD."
msgstr "이 섹션에서는 FreeBSD에서 3.5인치 플로피 디스크를 포맷하는 방법을 설명합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1102
#, no-wrap
msgid "*Procedure: Steps to Format a Floppy*\n"
msgstr "*절차: 플로피 포맷 단계*\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1107
msgid ""
"A floppy disk needs to be low-level formatted before it can be used.  This "
"is usually done by the vendor, but formatting is a good way to check media "
"integrity.  To low-level format the floppy disk on FreeBSD, use man:"
"fdformat[1].  When using this utility, make note of any error messages, as "
"these can help determine if the disk is good or bad."
msgstr ""
"플로피 디스크를 사용하려면 먼저 로우 레벨 포맷을 해야 합니다.  이 작업은 "
"일반적으로 공급업체에서 수행하지만, 포맷은 미디어 무결성을 확인하는 좋은 "
"방법입니다.  FreeBSD에서 플로피 디스크를 로우레벨 포맷하려면 man:fdformat[1]"
"을 사용합니다.  이 유틸리티를 사용할 때는 디스크의 양호 여부를 판단하는 데 "
"도움이 될 수 있으므로 오류 메시지를 기록해 두세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1109
msgid ""
"To format the floppy, insert a new 3.5 inch floppy disk into the first "
"floppy drive and issue:"
msgstr "플로피를 포맷하려면 새 3.5인치 플로피 디스크를 첫 번째 플로피 드라이브에 "
"삽입하고:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1113
#, no-wrap
msgid "# /usr/sbin/fdformat -f 1440 /dev/fd0\n"
msgstr "# /usr/sbin/fdformat -f 1440 /dev/fd0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1116
msgid ""
"After low-level formatting the disk, create a disk label as it is needed by "
"the system to determine the size of the disk and its geometry. The supported "
"geometry values are listed in [.filename]#/etc/disktab#."
msgstr ""
"디스크를 로우레벨 포맷한 후 시스템에서 디스크의 크기와 지오메트리를 결정하는 "
"데 필요한 디스크 레이블을 생성합니다. 지원되는 지오메트리 값은 [.filename]#/"
"etc/disktab#에 나열됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1118
msgid "To write the disk label, use man:bsdlabel[8]:"
msgstr "디스크 레이블을 작성하려면 man:bsdlabel[8]을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1122
#, no-wrap
msgid "# /sbin/bsdlabel -B -w /dev/fd0 fd1440\n"
msgstr "# /sbin/bsdlabel -B -w /dev/fd0 fd1440\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1125
msgid ""
"The floppy is now ready to be high-level formatted with a file system. The "
"floppy's file system can be either UFS or FAT, where FAT is generally a "
"better choice for floppies."
msgstr ""
"이제 플로피에 파일 시스템을 사용하여 높은 수준의 포맷을 할 준비가 "
"되었습니다. 플로피의 파일 시스템은 UFS 또는 FAT 중 하나를 선택할 수 있으며, "
"일반적으로 플로피에는 FAT가 더 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1127
msgid "To format the floppy with FAT, issue:"
msgstr "FAT로 플로피를 포맷하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1131
#, no-wrap
msgid "# /sbin/newfs_msdos /dev/fd0\n"
msgstr "# /sbin/newfs_msdos /dev/fd0\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1137
msgid ""
"The disk is now ready for use.  To use the floppy, mount it with man:"
"mount_msdosfs[8].  One can also install and use package:emulators/mtools[] "
"from the Ports Collection."
msgstr ""
"이제 디스크를 사용할 준비가 되었습니다.  플로피를 사용하려면 "
"man:mount_msdosfs[8]로 마운트합니다.  포트 컬렉션에서 package:emulators/"
"mtools[]를 설치하여 사용할 수도 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1139
#, no-wrap
msgid "Using NTFS Disks"
msgstr "NTFS 디스크 사용하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1142
msgid "This section explains how to mount NTFS disks in FreeBSD."
msgstr "이 섹션에서는 FreeBSD에서 NTFS 디스크를 마운트하는 방법을 설명합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1147
msgid ""
"NTFS (New Technology File System) is a proprietary journaling file system "
"developed by Microsoft(R).  It has been the default file system in Microsoft "
"Windows(R) for many years.  FreeBSD can mount NTFS volumes using a FUSE file "
"system.  These file systems are implemented as user space programs which "
"interact with the man:fusefs[5] kernel module via a well defined interface."
msgstr ""
"NTFS (New Technology File System)는 Microsoft(R)에서 개발한 독점적인 저널링 "
"파일 시스템입니다.  수년 동안 마이크로소프트 윈도우(R)의 기본 파일 "
"시스템으로 사용되어 왔습니다.  FreeBSD는 FUSE 파일 시스템을 사용하여 NTFS "
"볼륨을 마운트할 수 있습니다.  이 파일 시스템은 잘 정의된 인터페이스를 통해 "
"man:fusefs[5] 커널 모듈과 상호 작용하는 사용자 공간 프로그램으로 구현됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1151
#, no-wrap
msgid "*Procedure: Steps to Mount a NTFS Disk*\n"
msgstr "*절차: NTFS 디스크를 마운트하는 단계*\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1154
msgid ""
"Before using a FUSE file system we need to load the man:fusefs[5] kernel "
"module:"
msgstr "FUSE 파일 시스템을 사용하기 전에 man:fusefs[5] 커널 모듈을 로드해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1158
#, no-wrap
msgid "# kldload fusefs\n"
msgstr "# kldload fusefs\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1161
msgid "Use man:sysrc[8] to load the module at startup:"
msgstr "시작 시 모듈을 로드하려면 man:sysrc[8]를 사용하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1165
#, no-wrap
msgid "# sysrc kld_list+=fusefs\n"
msgstr "# sysrc kld_list+=fusefs\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1168
msgid ""
"Install the actual NTFS file system from packages as in the example (see "
"crossref:ports[pkgng-intro,Using pkg for Binary Package Management]) or from "
"ports (see crossref:ports[ports-using,Using the Ports Collection]):"
msgstr ""
"예제에서와 같이 패키지(crossref:ports[pkgng-intro,Using pkg for Binary "
"Package Management] 참조) 또는 포트(crossref:ports[ports-using,Using the "
"Ports Collection] 참조)에서 실제 NTFS 파일 시스템을 설치합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1172
#, no-wrap
msgid "# pkg install fusefs-ntfs\n"
msgstr "# pkg install fusefs-ntfs\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1175
msgid ""
"Last we need to create a directory where the file system will be mounted:"
msgstr "마지막으로 파일 시스템을 마운트할 디렉터리를 만들어야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1179
#, no-wrap
msgid "# mkdir /mnt/usb\n"
msgstr "# mkdir /mnt/usb\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1182
msgid ""
"Suppose a USB disk is plugged in.  The disk partition information can be "
"viewed with man:gpart[8]:"
msgstr "USB 디스크가 연결되어 있다고 가정합니다.  디스크 파티션 정보는 man:gpart[8]"
"로 볼 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1188
#, no-wrap
msgid ""
"# gpart show da0\n"
"=>\t  63  1953525105  da0 MBR   (932G)\n"
"\t  63  1953525105    1 ntfs  (932G)\n"
msgstr ""
"# gpart show da0\n"
"=>\t  63  1953525105  da0 MBR   (932G)\n"
"\t  63  1953525105    1 ntfs  (932G)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1191
msgid "We can mount the disk using the following command:"
msgstr "다음 명령을 사용하여 디스크를 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1195
#, no-wrap
msgid "# ntfs-3g /dev/da0s1 /mnt/usb/\n"
msgstr "# ntfs-3g /dev/da0s1 /mnt/usb/\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1197
msgid "The disk is now ready to use."
msgstr "이제 디스크를 사용할 준비가 되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1199
msgid "Additionally, an entry can be added to /etc/fstab:"
msgstr "또한 /etc/fstab에 항목을 추가할 수도 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1203
#, no-wrap
msgid "/dev/da0s1  /mnt/usb\tntfs mountprog=/usr/local/bin/ntfs-3g,noauto,rw  0 0\n"
msgstr ""
"/dev/da0s1  /mnt/usb\tntfs mountprog=/usr/local/bin/ntfs-3g,noauto,rw  0 0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1206
msgid "Now the disk can be now mounted with:"
msgstr "이제 디스크를 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1210
#, no-wrap
msgid "# mount /mnt/usb\n"
msgstr "# mount /mnt/usb\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1213
msgid "The disk can be unmounted with:"
msgstr "디스크를 마운트 해제할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1217
#, no-wrap
msgid "# umount /mnt/usb/\n"
msgstr "# umount /mnt/usb/\n"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1221
#, no-wrap
msgid "Backup Basics"
msgstr "백업의 기초"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1224
msgid ""
"Implementing a backup plan is essential in order to have the ability to "
"recover from disk failure, accidental file deletion, random file corruption, "
"or complete machine destruction, including destruction of on-site backups."
msgstr ""
"디스크 장애, 우발적인 파일 삭제, 무작위 파일 손상 또는 온사이트 백업의 "
"파괴를 포함한 완전한 시스템 파괴로부터 복구할 수 있는 능력을 갖추려면 백업 "
"계획을 실행하는 것이 필수적입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1227
msgid ""
"The backup type and schedule will vary, depending upon the importance of the "
"data, the granularity needed for file restores, and the amount of acceptable "
"downtime.  Some possible backup techniques include:"
msgstr ""
"백업 유형과 일정은 데이터의 중요도, 파일 복원에 필요한 세부 수준, 허용 "
"가능한 다운타임의 양에 따라 달라집니다.  몇 가지 가능한 백업 기술은 다음과 "
"같습니다:"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1229
msgid ""
"Archives of the whole system, backed up onto permanent, off-site media. This "
"provides protection against all of the problems listed above, but is slow "
"and inconvenient to restore from, especially for non-privileged users."
msgstr ""
"영구적인 오프사이트 미디어에 백업된 전체 시스템 아카이브. 이 방법은 위에 "
"나열된 모든 문제에 대한 보호 기능을 제공하지만, 특히 권한이 없는 사용자의 "
"경우 복원 속도가 느리고 불편합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1230
msgid ""
"File system snapshots, which are useful for restoring deleted files or "
"previous versions of files."
msgstr "파일 시스템 스냅샷은 삭제된 파일이나 이전 버전의 파일을 복원하는 데 "
"유용합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1231
msgid ""
"Copies of whole file systems or disks which are synchronized with another "
"system on the network using a scheduled package:net/rsync[]."
msgstr ""
"예약된 package:net/rsync[]를 사용하여 네트워크의 다른 시스템과 동기화되는 "
"전체 파일 시스템 또는 디스크의 복사본입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1232
msgid ""
"Hardware or software RAID, which minimizes or avoids downtime when a disk "
"fails."
msgstr "디스크 장애 시 다운타임을 최소화하거나 방지하는 하드웨어 또는 소프트웨어 "
"RAID입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1236
msgid ""
"Typically, a mix of backup techniques is used.  For example, one could "
"create a schedule to automate a weekly, full system backup that is stored "
"off-site and to supplement this backup with hourly ZFS snapshots.  In "
"addition, one could make a manual backup of individual directories or files "
"before making file edits or deletions."
msgstr ""
"일반적으로 여러 백업 기술이 혼합되어 사용됩니다.  예를 들어, 매주 "
"오프사이트에 저장되는 전체 시스템 백업을 자동화하고 이 백업을 시간별 ZFS "
"스냅샷으로 보완하는 일정을 만들 수 있습니다.  또한 파일을 편집하거나 "
"삭제하기 전에 개별 디렉터리 또는 파일을 수동으로 백업할 수도 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1238
msgid ""
"This section describes some of the utilities which can be used to create and "
"manage backups on a FreeBSD system."
msgstr "이 섹션에서는 FreeBSD 시스템에서 백업을 생성하고 관리하는 데 사용할 수 있는 "
"몇 가지 유틸리티에 대해 설명합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1239
#, no-wrap
msgid "File System Backups"
msgstr "파일 시스템 백업"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1245
msgid ""
"The traditional UNIX(R) programs for backing up a file system are man:"
"dump[8], which creates the backup, and man:restore[8], which restores the "
"backup.  These utilities work at the disk block level, below the "
"abstractions of the files, links, and directories that are created by file "
"systems.  Unlike other backup software, `dump` backs up an entire file "
"system and is unable to backup only part of a file system or a directory "
"tree that spans multiple file systems.  Instead of writing files and "
"directories, `dump` writes the raw data blocks that comprise files and "
"directories."
msgstr ""
"파일 시스템을 백업하는 전통적인 UNIX(R) 프로그램은 백업을 생성하는 "
"man:dump[8]와 백업을 복원하는 man:restore[8]입니다.  이러한 유틸리티는 파일 "
"시스템에서 생성되는 파일, 링크 및 디렉터리의 추상화 아래인 디스크 블록 "
"수준에서 작동합니다.  다른 백업 소프트웨어와 달리 `dump`는 전체 파일 "
"시스템을 백업하며 파일 시스템의 일부만 백업하거나 여러 파일 시스템에 걸쳐 "
"있는 디렉토리 트리를 백업할 수 없습니다.  `dump`는 파일과 디렉터리를 쓰는 "
"대신 파일과 디렉터리를 구성하는 원시 데이터 블록을 기록합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1249
msgid ""
"If `dump` is used on the root directory, it will not back up [.filename]#/"
"home#, [.filename]#/usr# or many other directories since these are typically "
"mount points for other file systems or symbolic links into those file "
"systems."
msgstr ""
"루트 디렉터리에 `dump`를 사용하면 일반적으로 다른 파일 시스템의 마운트 지점 "
"또는 해당 파일 시스템에 대한 심볼릭 링크로 구성된 [.filename]#/home#, [."
"filename]#/usr# 또는 다른 대부분의 디렉터리를 백업하지 않습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1253
msgid ""
"When used to restore data, `restore` stores temporary files in [.filename]#/"
"tmp/# by default.  When using a recovery disk with a small [.filename]#/"
"tmp#, set `TMPDIR` to a directory with more free space in order for the "
"restore to succeed."
msgstr ""
"데이터를 복원하는 데 사용하는 경우 `restore`는 기본적으로 임시 파일을 [."
"filename]#/tmp/#에 저장합니다.  작은 [.filename]#/tmp#의 복구 디스크를 "
"사용하는 경우 복원이 성공하려면 여유 공간이 더 많은 디렉터리로 `TMPDIR`을 "
"설정하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1257
msgid ""
"When using `dump`, be aware that some quirks remain from its early days in "
"Version 6 of AT&T UNIX(R),circa 1975.  The default parameters assume a "
"backup to a 9-track tape, rather than to another type of media or to the "
"high-density tapes available today.  These defaults must be overridden on "
"the command line."
msgstr ""
"`dump`를 사용할 때는 1975년경 AT&T UNIX(R) 버전 6 초기의 몇 가지 특이한 점이 "
"남아 있다는 점에 유의하세요.  기본 매개변수는 다른 유형의 미디어나 현재 사용 "
"가능한 고밀도 테이프가 아닌 9트랙 테이프에 백업한다고 가정합니다.  이러한 "
"기본값은 명령줄에서 재정의해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1260
msgid ""
"It is possible to backup a file system across the network to a another "
"system or to a tape drive attached to another computer.  While the man:"
"rdump[8] and man:rrestore[8] utilities can be used for this purpose, they "
"are not considered to be secure."
msgstr ""
"네트워크를 통해 파일 시스템을 다른 시스템이나 다른 컴퓨터에 연결된 테이프 "
"드라이브에 백업할 수 있습니다.  man:rdump[8] 및 man:rrestore[8] 유틸리티를 "
"이 용도로 사용할 수 있지만, 이 유틸리티는 안전하지 않은 것으로 간주됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1263
msgid ""
"Instead, one can use `dump` and `restore` in a more secure fashion over an "
"SSH connection.  This example creates a full, compressed backup of [."
"filename]#/usr# and sends the backup file to the specified host over a SSH "
"connection."
msgstr ""
"대신, `dump`와 `restore`을 사용하여 SSH 연결을 통해 보다 안전한 방식으로 "
"백업할 수 있습니다.  이 예에서는 [.filename]#/usr#의 전체 압축 백업을 만들고 "
"SSH 연결을 통해 지정된 호스트로 백업 파일을 보냅니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1264
#, no-wrap
msgid "Using `dump` over ssh"
msgstr "ssh에서`dump` 사용하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1271
#, no-wrap
msgid ""
"# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \\\n"
"          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz\n"
msgstr ""
"# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \\\n"
"          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0."
"gz\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1275
msgid ""
"This example sets `RSH` in order to write the backup to a tape drive on a "
"remote system over a SSH connection:"
msgstr "이 예에서는 SSH 연결을 통해 원격 시스템의 테이프 드라이브에 백업을 쓰기 위해 "
"`RSH`를 설정합니다:"

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1276
#, no-wrap
msgid "Using `dump` over ssh with `RSH` Set"
msgstr "ssh에 `dump`를 `RSH` 설정으로 사용하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1282
#, no-wrap
msgid "# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr\n"
msgstr ""
"# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example."
"com:/dev/sa0 /usr\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1285
#, no-wrap
msgid "Directory Backups"
msgstr "디렉터리 백업"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1288
msgid ""
"Several built-in utilities are available for backing up and restoring "
"specified files and directories as needed."
msgstr "필요에 따라 지정된 파일과 디렉터리를 백업하고 복원할 수 있는 여러 가지 기본 "
"제공 유틸리티를 사용할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1292
msgid ""
"A good choice for making a backup of all of the files in a directory is man:"
"tar[1].  This utility dates back to Version 6 of AT&T UNIX(R) and by default "
"assumes a recursive backup to a local tape device.  Switches can be used to "
"instead specify the name of a backup file."
msgstr ""
"디렉터리에 있는 모든 파일을 백업하는 데는 man:tar[1]를 사용하는 것이 "
"좋습니다.  이 유틸리티는 AT&T UNIX(R) 버전 6으로 거슬러 올라가며 기본적으로 "
"로컬 테이프 장치에 대한 재귀 백업을 가정합니다.  스위치를 사용하여 백업 "
"파일의 이름을 대신 지정할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1295
msgid ""
"This example creates a compressed backup of the current directory and saves "
"it to [.filename]#/tmp/mybackup.tgz#.  When creating a backup file, make "
"sure that the backup is not saved to the same directory that is being backed "
"up."
msgstr ""
"이 예에서는 현재 디렉터리의 압축 백업을 만들어 [.filename]#/tmp/mybackup.tgz#"
"에 저장합니다.  백업 파일을 만들 때 백업이 백업 중인 디렉터리와 동일한 "
"디렉터리에 저장되지 않도록 하세요."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1296
#, no-wrap
msgid "Backing Up the Current Directory with `tar`"
msgstr "`tar`로 현재 디렉토리 백업하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1302
#, no-wrap
msgid "# tar czvf /tmp/mybackup.tgz .\n"
msgstr "# tar czvf /tmp/mybackup.tgz .\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1308
msgid ""
"To restore the entire backup, `cd` into the directory to restore into and "
"specify the name of the backup.  Note that this will overwrite any newer "
"versions of files in the restore directory.  When in doubt, restore to a "
"temporary directory or specify the name of the file within the backup to "
"restore."
msgstr ""
"전체 백업을 복원하려면 복원할 디렉터리에 `cd`를 입력하고 백업 이름을 "
"지정합니다.  이렇게 하면 복원 디렉터리에 있는 최신 버전의 파일을 덮어쓰게 "
"됩니다.  확실하지 않은 경우 임시 디렉터리로 복원하거나 복원할 백업 내의 파일 "
"이름을 지정하세요."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1309
#, no-wrap
msgid "Restoring Up the Current Directory with `tar`"
msgstr "`tar`로 현재 디렉토리 복원하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1315
#, no-wrap
msgid "# tar xzvf /tmp/mybackup.tgz\n"
msgstr "# tar xzvf /tmp/mybackup.tgz\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1320
msgid ""
"There are dozens of available switches which are described in man:tar[1].  "
"This utility also supports the use of exclude patterns to specify which "
"files should not be included when backing up the specified directory or "
"restoring files from a backup."
msgstr ""
"man:tar[1]에 설명된 수십 가지 스위치를 사용할 수 있습니다.  이 유틸리티는 "
"지정한 디렉터리를 백업하거나 백업에서 파일을 복원할 때 포함하지 말아야 할 "
"파일을 지정하는 제외 패턴 사용도 지원합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1323
msgid ""
"To create a backup using a specified list of files and directories, man:"
"cpio[1] is a good choice.  Unlike `tar`, `cpio` does not know how to walk "
"the directory tree and it must be provided the list of files to backup."
msgstr ""
"지정된 파일 및 디렉터리 목록을 사용하여 백업을 생성하려면 man:cpio[1]를 "
"사용하는 것이 좋습니다.  `tar`와 달리 `cpio`는 디렉토리 트리를 탐색하는 "
"방법을 모르기 때문에 백업할 파일 목록을 제공해야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1326
msgid ""
"For example, a list of files can be created using `ls` or `find`.  This "
"example creates a recursive listing of the current directory which is then "
"piped to `cpio` in order to create an output backup file named [.filename]#/"
"tmp/mybackup.cpio#."
msgstr ""
"예를 들어, `ls` 또는 `find`를 사용하여 파일 목록을 만들 수 있습니다.  이 "
"예에서는 현재 디렉터리의 재귀 목록을 생성한 다음 `cpio`로 파이프하여 [."
"filename]#/tmp/mybackup.cpio#라는 이름의 출력 백업 파일을 생성합니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1327
#, no-wrap
msgid "Using `ls` and `cpio` to Make a Recursive Backup of the Current Directory"
msgstr "`ls` 및 `cpio`를 사용하여 현재 디렉토리의 재귀적 백업 만들기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1333
#, no-wrap
msgid "# ls -R | cpio -ovF /tmp/mybackup.cpio\n"
msgstr "# ls -R | cpio -ovF /tmp/mybackup.cpio\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1339
msgid ""
"A backup utility which tries to bridge the features provided by `tar` and "
"`cpio` is man:pax[1].  Over the years, the various versions of `tar` and "
"`cpio` became slightly incompatible.  POSIX(R) created `pax` which attempts "
"to read and write many of the various `cpio` and `tar` formats, plus new "
"formats of its own."
msgstr ""
"`tar`와 `cpio`가 제공하는 기능을 연결하는 백업 유틸리티는 man:pax[1]입니다.  "
"수년에 걸쳐, `tar`와 `cpio`의 다양한 버전은 약간 호환되지 않게 되었습니다.  "
"POSIX(R)는 다양한 `cpio`와 `tar` 포맷과 새로운 포맷을 읽고 쓰도록 시도하는 "
"`pax`를 만들었습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1341
msgid "The `pax` equivalent to the previous examples would be:"
msgstr "이전 예제에 해당하는 'pax'는 다음과 같습니다:"

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1342
#, no-wrap
msgid "Backing Up the Current Directory with `pax`"
msgstr "`pax`로 현재 디렉토리 백업하기"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1348
#, no-wrap
msgid "# pax -wf /tmp/mybackup.pax .\n"
msgstr "# pax -wf /tmp/mybackup.pax .\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1352
#, no-wrap
msgid "Using Data Tapes for Backups"
msgstr "백업에 데이터 테이프 사용하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1357
msgid ""
"While tape technology has continued to evolve, modern backup systems tend to "
"combine off-site backups with local removable media.  FreeBSD supports any "
"tape drive that uses SCSI, such as LTO or DAT.  There is limited support for "
"SATA and USB tape drives."
msgstr ""
"테이프 기술은 계속 발전해 왔지만, 최신 백업 시스템은 오프사이트 백업과 로컬 "
"이동식 미디어를 결합하는 경향이 있습니다.  FreeBSD는 LTO 또는 DAT와 같은 "
"SCSI를 사용하는 모든 테이프 드라이브를 지원합니다.  SATA 및 USB 테이프 "
"드라이브에 대한 지원은 제한적입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1361
msgid ""
"For SCSI tape devices, FreeBSD uses the man:sa[4] driver and the [."
"filename]#/dev/sa0#, [.filename]#/dev/nsa0#, and [.filename]#/dev/esa0# "
"devices.  The physical device name is [.filename]#/dev/sa0#. When [."
"filename]#/dev/nsa0# is used, the backup application will not rewind the "
"tape after writing a file, which allows writing more than one file to a "
"tape.  Using [.filename]#/dev/esa0# ejects the tape after the device is "
"closed."
msgstr ""
"SCSI 테이프 장치의 경우, FreeBSD는 man:sa[4] 드라이버와 [.filename]#/dev/sa0#"
", [.filename]#/dev/nsa0# 및 [.filename]#/dev/esa0# 장치를 사용합니다.  실제 "
"장치 이름은 [.filename]#/dev/sa0#입니다. 파일 이름]#/dev/nsa0#을 사용하면 "
"백업 애플리케이션이 파일 쓰기 후 테이프를 되감지 않으므로 테이프에 두 개 "
"이상의 파일을 쓸 수 있습니다.  [.filename]#/dev/esa0#을 사용하면 장치를 닫은 "
"후 테이프가 배출됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1364
msgid ""
"In FreeBSD, `mt` is used to control operations of the tape drive, such as "
"seeking through files on a tape or writing tape control marks to the tape.  "
"For example, the first three files on a tape can be preserved by skipping "
"past them before writing a new file:"
msgstr ""
"FreeBSD에서 `mt`는 테이프에 있는 파일을 찾거나 테이프에 테이프 제어 표시를 "
"쓰는 등 테이프 드라이브의 작업을 제어하는 데 사용됩니다.  예를 들어, "
"테이프에 있는 처음 세 개의 파일은 새 파일을 쓰기 전에 건너뛰어서 보존할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1368
#, no-wrap
msgid "# mt -f /dev/nsa0 fsf 3\n"
msgstr "# mt -f /dev/nsa0 fsf 3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1371
msgid "This utility supports many operations. Refer to man:mt[1] for details."
msgstr "이 유틸리티는 다양한 작업을 지원합니다. 자세한 내용은 man:mt[1]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1373
msgid ""
"To write a single file to tape using `tar`, specify the name of the tape "
"device and the file to backup:"
msgstr "`tar`를 사용하여 단일 파일을 테이프에 기록하려면 테이프 장치의 이름과 백업할 "
"파일을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1377
#, no-wrap
msgid "# tar cvf /dev/sa0 file\n"
msgstr "# tar cvf /dev/sa0 file\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1380
msgid ""
"To recover files from a `tar` archive on tape into the current directory:"
msgstr "테이프의 'tar' 아카이브에서 현재 디렉토리로 파일을 복구하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1384
#, no-wrap
msgid "# tar xvf /dev/sa0\n"
msgstr "# tar xvf /dev/sa0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1388
msgid ""
"To backup a UFS file system, use `dump`.  This examples backs up [."
"filename]#/usr# without rewinding the tape when finished:"
msgstr ""
"UFS 파일 시스템을 백업하려면 `dump`를 사용합니다.  이 예제는 완료되면 "
"테이프를 되감지 않고 [.filename]#/usr#을 백업합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1392
#, no-wrap
msgid "# dump -0aL -b64 -f /dev/nsa0 /usr\n"
msgstr "# dump -0aL -b64 -f /dev/nsa0 /usr\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1395
msgid ""
"To interactively restore files from a `dump` file on tape into the current "
"directory:"
msgstr "테이프의 `dump` 파일에서 현재 디렉토리로 파일을 대화형으로 복원합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1399
#, no-wrap
msgid "# restore -i -f /dev/nsa0\n"
msgstr "# restore -i -f /dev/nsa0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1402
#, no-wrap
msgid "Third-Party Backup Utilities"
msgstr "타사 백업 유틸리티"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1406
msgid ""
"The FreeBSD Ports Collection provides many third-party utilities which can "
"be used to schedule the creation of backups, simplify tape backup, and make "
"backups easier and more convenient.  Many of these applications are client/"
"server based and can be used to automate the backups of a single system or "
"all of the computers in a network."
msgstr ""
"FreeBSD 포트 컬렉션은 백업 생성을 예약하고, 테이프 백업을 단순화하며, 백업을 "
"더 쉽고 편리하게 만드는 데 사용할 수 있는 많은 타사 유틸리티를 제공합니다.  "
"이러한 애플리케이션 중 다수는 클라이언트/서버 기반이며 단일 시스템 또는 "
"네트워크에 있는 모든 컴퓨터의 백업을 자동화하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1408
msgid "Popular utilities include Amanda, Bacula, rsync, and duplicity."
msgstr "인기 있는 유틸리티로는 Amanda, Bacula, rsync, duplicity 등이 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1409
#, no-wrap
msgid "Emergency Recovery"
msgstr "긴급 복구"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1412
msgid ""
"In addition to regular backups, it is recommended to perform the following "
"steps as part of an emergency preparedness plan."
msgstr "정기 백업 외에도 비상 대비 계획의 일환으로 다음 단계를 수행하는 것이 "
"좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1414
msgid "Create a print copy of the output of the following commands:"
msgstr "다음 명령 출력의 인쇄 사본을 만듭니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1416
msgid "`gpart show`"
msgstr "`gpart show`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1417
msgid "`more /etc/fstab`"
msgstr "`more /etc/fstab`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1418
msgid "`dmesg`"
msgstr "`dmesg`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1422
msgid ""
"Store this printout and a copy of the installation media in a secure "
"location.  Should an emergency restore be needed, boot into the installation "
"media and select `Live CD` to access a rescue shell.  This rescue mode can "
"be used to view the current state of the system, and if needed, to reformat "
"disks and restore data from backups."
msgstr ""
"이 출력물과 설치 미디어 사본을 안전한 장소에 보관하세요.  긴급 복원이 필요한 "
"경우, 설치 미디어로 부팅하고 `Live CD`를 선택하여 복구 셸에 액세스합니다.  "
"이 복구 모드에서는 시스템의 현재 상태를 확인하고 필요한 경우 디스크를 다시 "
"포맷하고 백업에서 데이터를 복원하는 데 사용할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1427
msgid ""
"The installation media for FreeBSD/i386 {rel112-current}-RELEASE does not "
"include a rescue shell.  For this version, instead download and burn a "
"Livefs CD image from link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/"
"ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs."
"iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-"
"current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso]."
msgstr ""
"FreeBSD/i386 {rel112-current}-RELEASE용 설치 미디어에는 복구 셸이 포함되어 "
"있지 않습니다.  이 버전의 경우, 대신 ftp://ftp.FreeBSD.org/pub/FreeBSD/"
"releases/i386/ISO-IMAGES/"
"{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso[ftp://ftp."
"FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/"
"{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso] 링크에서 "
"Livefs CD 이미지를 다운로드하여 구우세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1433
msgid ""
"Next, test the rescue shell and the backups.  Make notes of the procedure.  "
"Store these notes with the media, the printouts, and the backups.  These "
"notes may prevent the inadvertent destruction of the backups while under the "
"stress of performing an emergency recovery."
msgstr ""
"다음으로, 복구 셸과 백업을 테스트합니다.  절차를 메모합니다.  이 메모를 "
"미디어, 출력물, 백업과 함께 보관하세요.  이러한 메모는 긴급 복구를 수행해야 "
"하는 상황에서 백업이 실수로 파괴되는 것을 방지할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1435
msgid ""
"For an added measure of security, store the latest backup at a remote "
"location which is physically separated from the computers and disk drives by "
"a significant distance."
msgstr "보안을 강화하려면 컴퓨터 및 디스크 드라이브와 물리적으로 멀리 떨어진 원격 "
"위치에 최신 백업을 저장하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1437
#, no-wrap
msgid "Memory Disks"
msgstr "메모리 디스크"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1441
msgid ""
"In addition to physical disks, FreeBSD also supports the creation and use of "
"memory disks.  One possible use for a memory disk is to access the contents "
"of an ISO file system without the overhead of first burning it to a CD or "
"DVD, then mounting the CD/DVD media."
msgstr ""
"물리 디스크 외에도, FreeBSD는 메모리 디스크의 생성과 사용도 지원합니다.  "
"메모리 디스크의 용도 중 하나는 ISO 파일 시스템의 콘텐츠에 액세스하기 위해 "
"CD나 DVD로 구운 다음 CD/DVD 미디어를 마운트하는 번거로움 없이 액세스하는 "
"것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1445
msgid ""
"In FreeBSD, the man:md[4] driver is used to provide support for memory "
"disks.  The [.filename]#GENERIC# kernel includes this driver.  When using a "
"custom kernel configuration file, ensure it includes this line:"
msgstr ""
"FreeBSD에서는 man:md[4] 드라이버가 메모리 디스크에 대한 지원을 제공하는 데 "
"사용됩니다.  이 드라이버는 [.filename]#GENERIC# 커널에 포함되어 있습니다.  "
"사용자 정의 커널 구성 파일을 사용하는 경우 이 줄이 포함되어 있는지 "
"확인하십시오:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1449
#, no-wrap
msgid "device md\n"
msgstr "device md\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1452
#, no-wrap
msgid "Attaching and Detaching Existing Images"
msgstr "기존 이미지 연결 및 분리하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1458
msgid ""
"To mount an existing file system image, use `mdconfig` to specify the name "
"of the ISO file and a free unit number.  Then, refer to that unit number to "
"mount it on an existing mount point.  Once mounted, the files in the ISO "
"will appear in the mount point.  This example attaches _diskimage.iso_ to "
"the memory device [.filename]#/dev/md0# then mounts that memory device on [."
"filename]#/mnt#:"
msgstr ""
"기존 파일 시스템 이미지를 마운트하려면 `mdconfig`를 사용하여 ISO 파일의 "
"이름과 사용 가능한 단위 번호를 지정합니다.  그런 다음 해당 단위 번호를 "
"참조하여 기존 마운트 지점에 마운트합니다.  마운트되면 ISO의 파일이 마운트 "
"지점에 나타납니다.  이 예제에서는 메모리 장치 [.filename]#/dev/md0#에 "
"_diskimage.iso_를 첨부한 다음 해당 메모리 장치를 [.filename]#/mnt#에 "
"마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1463
#, no-wrap
msgid ""
"# mdconfig -f diskimage.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"
msgstr ""
"# mdconfig -f diskimage.iso -u 0\n"
"# mount -t cd9660 /dev/md0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1468
msgid ""
"Notice that `-t cd9660` was used to mount an ISO format.  If a unit number "
"is not specified with `-u`, `mdconfig` will automatically allocate an unused "
"memory device and output the name of the allocated unit, such as [."
"filename]#md4#.  Refer to man:mdconfig[8] for more details about this "
"command and its options."
msgstr ""
"ISO 포맷을 마운트하기 위해 `-t cd9660`이 사용되었음을 알 수 있습니다.  유닛 "
"번호를 `-u`로 지정하지 않으면 `mdconfig`는 사용하지 않는 메모리 장치를 "
"자동으로 할당하고 할당된 유닛의 이름(예: [.filename]#md4#)을 출력합니다.  이 "
"명령과 옵션에 대한 자세한 내용은 man:mdconfig[8]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1472
msgid ""
"When a memory disk is no longer in use, its resources should be released "
"back to the system.  First, unmount the file system, then use `mdconfig` to "
"detach the disk from the system and release its resources.  To continue this "
"example:"
msgstr ""
"메모리 디스크를 더 이상 사용하지 않을 때는 해당 리소스를 시스템에 다시 "
"릴리스해야 합니다.  먼저 파일 시스템을 마운트 해제하고 `mdconfig`를 사용하여 "
"시스템에서 디스크를 분리하고 해당 리소스를 해제합니다.  이 예제를 계속 "
"진행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1477
#, no-wrap
msgid ""
"# umount /mnt\n"
"# mdconfig -d -u 0\n"
msgstr ""
"# umount /mnt\n"
"# mdconfig -d -u 0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1480
msgid ""
"To determine if any memory disks are still attached to the system, type "
"`mdconfig -l`."
msgstr "메모리 디스크가 아직 시스템에 연결되어 있는지 확인하려면 `mdconfig -l`을 "
"입력합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1482
#, no-wrap
msgid "Creating a File- or Memory-Backed Memory Disk"
msgstr "파일 또는 메모리-백업 메모리 디스크 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1487
msgid ""
"FreeBSD also supports memory disks where the storage to use is allocated "
"from either a hard disk or an area of memory.  The first method is commonly "
"referred to as a file-backed file system and the second method as a memory-"
"backed file system.  Both types can be created using `mdconfig`."
msgstr ""
"FreeBSD는 하드 디스크 또는 메모리 영역에서 사용할 스토리지를 할당하는 메모리 "
"디스크도 지원합니다.  첫 번째 방법을 일반적으로 파일-백업 파일 시스템이라고 "
"하고 두 번째 방법을 메모리-백업 파일 시스템이라고 합니다.  두 가지 유형 모두 "
"`mdconfig`를 사용하여 만들 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1492
msgid ""
"To create a new memory-backed file system, specify a type of `swap` and the "
"size of the memory disk to create.  Then, format the memory disk with a file "
"system and mount as usual.  This example creates a 5M memory disk on unit "
"`1`.  That memory disk is then formatted with the UFS file system before it "
"is mounted:"
msgstr ""
"새 메모리-백업 파일 시스템을 만들려면 `swap` 유형과 만들 메모리 디스크의 "
"크기를 지정합니다.  그런 다음 메모리 디스크를 파일 시스템으로 포맷하고 "
"평소와 같이 마운트합니다.  이 예에서는 유닛 `1`에 5M 메모리 디스크를 "
"생성합니다.  그런 다음 해당 메모리 디스크를 UFS 파일 시스템으로 포맷한 후 "
"마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1506
#, no-wrap
msgid ""
"# mdconfig -a -t swap -s 5m -u 1\n"
"# newfs -U md1\n"
"/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.\n"
"        with soft updates\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2752, 5344, 7936\n"
"# mount /dev/md1 /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md1        4718    4  4338     0%    /mnt\n"
msgstr ""
"# mdconfig -a -t swap -s 5m -u 1\n"
"# newfs -U md1\n"
"/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.\n"
"        with soft updates\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2752, 5344, 7936\n"
"# mount /dev/md1 /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md1        4718    4  4338     0%    /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1510
msgid ""
"To create a new file-backed memory disk, first allocate an area of disk to "
"use.  This example creates an empty 5MB file named [.filename]#newimage#:"
msgstr ""
"새 파일-백업 메모리 디스크를 만들려면 먼저 사용할 디스크 영역을 할당합니다.  "
"이 예에서는 [.filename]#newimage#라는 이름의 빈 5MB 파일을 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1516
#, no-wrap
msgid ""
"# dd if=/dev/zero of=newimage bs=1k count=5k\n"
"5120+0 records in\n"
"5120+0 records out\n"
msgstr ""
"# dd if=/dev/zero of=newimage bs=1k count=5k\n"
"5120+0 records in\n"
"5120+0 records out\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1519
msgid ""
"Next, attach that file to a memory disk, label the memory disk and format it "
"with the UFS file system, mount the memory disk, and verify the size of the "
"file-backed disk:"
msgstr ""
"그런 다음 해당 파일을 메모리 디스크에 첨부하고, 메모리 디스크에 레이블을 "
"지정하고, UFS 파일 시스템으로 포맷한 다음, 메모리 디스크를 마운트하고, 파일 "
"백업 디스크의 크기를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1533
#, no-wrap
msgid ""
"# mdconfig -f newimage -u 0\n"
"# bsdlabel -w md0 auto\n"
"# newfs -U md0a\n"
"/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2720, 5280, 7840\n"
"# mount /dev/md0a /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md0a       4710    4  4330     0%    /mnt\n"
msgstr ""
"# mdconfig -f newimage -u 0\n"
"# bsdlabel -w md0 auto\n"
"# newfs -U md0a\n"
"/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048\n"
"        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.\n"
"super-block backups (for fsck -b #) at:\n"
" 160, 2720, 5280, 7840\n"
"# mount /dev/md0a /mnt\n"
"# df /mnt\n"
"Filesystem 1K-blocks Used Avail Capacity  Mounted on\n"
"/dev/md0a       4710    4  4330     0%    /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1538
msgid ""
"It takes several commands to create a file- or memory-backed file system "
"using `mdconfig`.  FreeBSD also comes with `mdmfs` which automatically "
"configures a memory disk, formats it with the UFS file system, and mounts "
"it.  For example, after creating _newimage_ with `dd`, this one command is "
"equivalent to running the `bsdlabel`, `newfs`, and `mount` commands shown "
"above:"
msgstr ""
"`mdconfig`를 사용하여 파일- 또는 메모리-백업 파일 시스템을 만들려면 몇 가지 "
"명령이 필요합니다.  FreeBSD에는 메모리 디스크를 자동으로 구성하고, UFS 파일 "
"시스템으로 포맷한 후 마운트하는 `mdmfs`도 함께 제공됩니다.  예를 들어, `dd`"
"로 _newimage_를 생성한 후 다음 명령 하나로 위에 표시된 `bsdlabel`, `newfs`, "
"`mount` 명령을 실행하는 것과 동일한 결과를 얻을 수 있습니다.:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1542
#, no-wrap
msgid "# mdmfs -F newimage -s 5m md0 /mnt\n"
msgstr "# mdmfs -F newimage -s 5m md0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1545
msgid ""
"To instead create a new memory-based memory disk with `mdmfs`, use this one "
"command:"
msgstr "대신 `mdmfs`를 사용하여 새 메모리-기반 메모리 디스크를 만들려면 다음 "
"명령어를 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1549
#, no-wrap
msgid "# mdmfs -s 5m md1 /mnt\n"
msgstr "# mdmfs -s 5m md1 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1553
msgid ""
"If the unit number is not specified, `mdmfs` will automatically select an "
"unused memory device.  For more details about `mdmfs`, refer to man:mdmfs[8]."
msgstr ""
"단위 번호를 지정하지 않으면 `mdmfs`가 사용하지 않는 메모리 장치를 자동으로 "
"선택합니다.  `mdmfs`에 대한 자세한 내용은 man:mdmfs[8]을 참고하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1555
#, no-wrap
msgid "File System Snapshots"
msgstr "파일 시스템 스냅샷"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1558
msgid ""
"FreeBSD offers a feature in conjunction with crossref:config[soft-updates,"
"Soft Updates]: file system snapshots."
msgstr ""
"FreeBSD는 crossref:config[soft-updates,Soft Updates]와 함께 파일 시스템 "
"스냅샷이라는 기능을 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1564
msgid ""
"UFS snapshots allow a user to create images of specified file systems, and "
"treat them as a file.  Snapshot files must be created in the file system "
"that the action is performed on, and a user may create no more than 20 "
"snapshots per file system.  Active snapshots are recorded in the superblock "
"so they are persistent across unmount and remount operations along with "
"system reboots.  When a snapshot is no longer required, it can be removed "
"using man:rm[1].  While snapshots may be removed in any order, all the used "
"space may not be acquired because another snapshot will possibly claim some "
"of the released blocks."
msgstr ""
"UFS 스냅샷을 사용하면 지정된 파일 시스템의 이미지를 생성하고 이를 파일로 "
"취급할 수 있습니다.  스냅샷 파일은 작업이 수행되는 파일 시스템에 만들어야 "
"하며, 사용자는 파일 시스템당 20개 이하의 스냅샷을 만들 수 있습니다.  활성 "
"스냅샷은 슈퍼블록에 기록되므로 마운트 해제 및 재마운트 작업과 시스템 재부팅 "
"시에도 영구적으로 유지됩니다.  스냅샷이 더 이상 필요하지 않은 경우 man:rm[1]"
"을 사용하여 제거할 수 있습니다.  스냅샷은 어떤 순서로든 제거할 수 있지만, "
"다른 스냅샷이 해제된 블록 중 일부를 차지할 가능성이 있으므로 사용된 공간을 "
"모두 확보하지 못할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1567
msgid ""
"The un-alterable `snapshot` file flag is set by man:mksnap_ffs[8] after "
"initial creation of a snapshot file.  man:unlink[1] makes an exception for "
"snapshot files since it allows them to be removed."
msgstr ""
"변경할 수 없는 `snapshot` 파일 플래그는 스냅샷 파일을 처음 생성한 후 "
"man:mksnap_ffs[8]에 의해 설정됩니다.  man:unlink[1]는 스냅샷 파일을 제거할 "
"수 있으므로 스냅샷 파일에 대해 예외를 만듭니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1570
msgid ""
"Snapshots are created using man:mount[8].  To place a snapshot of [."
"filename]#/var# in the file [.filename]#/var/snapshot/snap#, use the "
"following command:"
msgstr ""
"스냅샷은 man:mount[8]를 사용하여 만듭니다.  [.filename]#/var# 파일에 [."
"filename]#/var/snapshot/snap#의 스냅샷을 배치하려면 다음 명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1574
#, no-wrap
msgid "# mount -u -o snapshot /var/snapshot/snap /var\n"
msgstr "# mount -u -o snapshot /var/snapshot/snap /var\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1577
msgid "Alternatively, use man:mksnap_ffs[8] to create the snapshot:"
msgstr "또는 man:mksnap_ffs[8]을 사용하여 스냅샷을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1581
#, no-wrap
msgid "# mksnap_ffs /var /var/snapshot/snap\n"
msgstr "# mksnap_ffs /var /var/snapshot/snap\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1584
msgid ""
"One can find snapshot files on a file system, such as [.filename]#/var#, "
"using man:find[1]:"
msgstr "man:find[1]를 사용하여 [.filename]#/var#과 같은 파일 시스템에서 스냅샷 "
"파일을 찾을 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1588
#, no-wrap
msgid "# find /var -flags snapshot\n"
msgstr "# find /var -flags snapshot\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1591
msgid "Once a snapshot has been created, it has several uses:"
msgstr "스냅샷이 생성되면 여러가지 용도로 사용할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1593
msgid ""
"Some administrators will use a snapshot file for backup purposes, because "
"the snapshot can be transferred to CDs or tape."
msgstr "일부 관리자는 스냅샷을 CD나 테이프로 전송할 수 있기 때문에 백업 목적으로 "
"스냅샷 파일을 사용하기도 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1594
msgid ""
"The file system integrity checker, man:fsck[8], may be run on the snapshot. "
"Assuming that the file system was clean when it was mounted, this should "
"always provide a clean and unchanging result."
msgstr ""
"파일 시스템 무결성 검사기인 man:fsck[8]를 스냅샷에서 실행할 수 있습니다. "
"파일 시스템이 마운트될 때 깨끗한 상태였다고 가정하면 항상 깨끗하고 변경되지 "
"않은 결과를 제공해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1595
msgid ""
"Running man:dump[8] on the snapshot will produce a dump file that is "
"consistent with the file system and the timestamp of the snapshot. man:"
"dump[8] can also take a snapshot, create a dump image, and then remove the "
"snapshot in one command by using `-L`."
msgstr ""
"man:dump[8]를 스냅샷에 실행하면 파일 시스템 및 스냅샷의 타임스탬프와 "
"일치하는 덤프 파일이 생성됩니다. 또한 `-L`을 사용하여 하나의 명령으로 "
"스냅샷을 생성하고 덤프 이미지를 생성한 다음 스냅샷을 제거할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1596
msgid ""
"The snapshot can be mounted as a frozen image of the file system. To man:"
"mount[8] the snapshot [.filename]#/var/snapshot/snap# run:"
msgstr ""
"스냅샷은 파일 시스템의 고정 이미지로 마운트할 수 있습니다. man:mount[8]으로 "
"스냅샷 [.filename]#/var/snapshot/snap#을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1601
#, no-wrap
msgid ""
"# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4\n"
"# mount -r /dev/md4 /mnt\n"
msgstr ""
"# mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4\n"
"# mount -r /dev/md4 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1607
msgid ""
"The frozen [.filename]#/var# is now available through [.filename]#/mnt#.  "
"Everything will initially be in the same state it was during the snapshot "
"creation time.  The only exception is that any earlier snapshots will appear "
"as zero length files.  To unmount the snapshot, use:"
msgstr ""
"고정된 [.filename]#/var#는 이제 [.filename]#/mnt#을 통해 사용할 수 "
"있습니다.  처음에는 모든 것이 스냅샷 생성 시와 동일한 상태로 유지됩니다.  "
"유일한 예외는 이전 스냅샷이 길이가 0인 파일로 표시된다는 점입니다.  스냅샷을 "
"마운트 해제하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1612
#, no-wrap
msgid ""
"# umount /mnt\n"
"# mdconfig -d -u 4\n"
msgstr ""
"# umount /mnt\n"
"# mdconfig -d -u 4\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1615
msgid ""
"For more information about `softupdates` and file system snapshots, "
"including technical papers, visit Marshall Kirk McKusick's website at http://"
"www.mckusick.com/[http://www.mckusick.com/]."
msgstr ""
"기술 문서를 포함하여 `softupdates` 및 파일 시스템 스냅샷에 대한 자세한 "
"내용은 Marshall Kirk McKusick의 웹사이트(http://www.mckusick.com/[http://www."
"mckusick.com/]를 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1617
#, no-wrap
msgid "Disk Quotas"
msgstr "디스크 할당량"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1621
msgid ""
"Disk quotas can be used to limit the amount of disk space or the number of "
"files a user or members of a group may allocate on a per-file system basis.  "
"This prevents one user or group of users from consuming all of the available "
"disk space."
msgstr ""
"디스크 할당량을 사용하여 사용자 또는 그룹 구성원이 파일 시스템별로 할당할 수 "
"있는 디스크 공간의 양이나 파일 수를 제한할 수 있습니다.  이렇게 하면 한 "
"사용자 또는 사용자 그룹이 사용 가능한 디스크 공간을 모두 소비하는 것을 "
"방지할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1624
msgid ""
"This section describes how to configure disk quotas for the UFS file "
"system.  To configure quotas on the ZFS file system, refer to crossref:"
"zfs[zfs-zfs-quota,\"Dataset, User, and Group Quotas\"]"
msgstr ""
"이 섹션에서는 UFS 파일 시스템에 대한 디스크 할당량을 구성하는 방법에 대해 "
"설명합니다.  ZFS 파일 시스템에서 할당량을 구성하려면 crossref:zfs[zfs-zfs-"
"quota,\"Dataset, User, and Group Quotas\"]을 참조하세요"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1625
#, no-wrap
msgid "Enabling Disk Quotas"
msgstr "디스크 할당량 활성화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1628
msgid "To determine if the FreeBSD kernel provides support for disk quotas:"
msgstr "FreeBSD 커널이 디스크 할당량을 지원하는지 확인하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1633
#, no-wrap
msgid ""
"% sysctl kern.features.ufs_quota\n"
"kern.features.ufs_quota: 1\n"
msgstr ""
"% sysctl kern.features.ufs_quota\n"
"kern.features.ufs_quota: 1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1637
msgid ""
"In this example, the `1` indicates quota support.  If the value is instead "
"`0`, add the following line to a custom kernel configuration file and "
"rebuild the kernel using the instructions in crossref:"
"kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]:"
msgstr ""
"이 예에서 `1`은 할당량 지원을 나타냅니다.  값이 대신 `0`이면 커스텀 커널 "
"구성 파일에 다음 줄을 추가하고 crossref:kernelconfig["
"kernelconfig,Configuring the FreeBSD Kernel]의 지침을 사용하여 커널을 다시 "
"빌드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1641
#, no-wrap
msgid "options QUOTA\n"
msgstr "options QUOTA\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1644
msgid "Next, enable disk quotas in [.filename]#/etc/rc.conf#:"
msgstr "다음으로, [.filename]#/etc/rc.conf#에서 디스크 할당량을 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1648
#, no-wrap
msgid "quota_enable=\"YES\"\n"
msgstr "quota_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1654
msgid ""
"Normally on bootup, the quota integrity of each file system is checked by "
"man:quotacheck[8].  This program insures that the data in the quota database "
"properly reflects the data on the file system.  This is a time consuming "
"process that will significantly affect the time the system takes to boot.  "
"To skip this step, add this variable to [.filename]#/etc/rc.conf#:"
msgstr ""
"일반적으로 부팅 시 각 파일 시스템의 할당량 무결성은 man:quotacheck[8]에 의해 "
"확인됩니다.  이 프로그램은 할당량 데이터베이스의 데이터가 파일 시스템의 "
"데이터를 올바르게 반영하는지 확인합니다.  이 과정은 시간이 오래 걸리므로 "
"시스템 부팅에 상당한 영향을 미칩니다.  이 단계를 건너뛰려면 [.filename]#/etc/"
"rc.conf#에 다음 변수를 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1658
#, no-wrap
msgid "check_quotas=\"NO\"\n"
msgstr "check_quotas=\"NO\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1663
msgid ""
"Finally, edit [.filename]#/etc/fstab# to enable disk quotas on a per-file "
"system basis.  To enable per-user quotas on a file system, add `userquota` "
"to the options field in the [.filename]#/etc/fstab# entry for the file "
"system to enable quotas on.  For example:"
msgstr ""
"마지막으로 [.filename]#/etc/fstab#을 편집하여 파일 시스템 단위로 디스크 "
"할당량을 사용하도록 설정합니다.  파일 시스템에서 사용자별 할당량을 "
"설정하려면 할당량을 사용 설정할 파일 시스템의 [.filename]#/etc/fstab# 항목에 "
"있는 옵션 필드에 `userquota`를 추가합니다.  예를 들어:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1667
#, no-wrap
msgid "/dev/da1s2g   /home    ufs rw,userquota 1 2\n"
msgstr "/dev/da1s2g   /home    ufs rw,userquota 1 2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1671
msgid ""
"To enable group quotas, use `groupquota` instead.  To enable both user and "
"group quotas, separate the options with a comma:"
msgstr ""
"그룹 할당량을 사용하려면 대신 `groupquota`를 사용합니다.  사용자 할당량과 "
"그룹 할당량을 모두 사용하려면 쉼표로 옵션을 구분합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1675
#, no-wrap
msgid "/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2\n"
msgstr "/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1680
msgid ""
"By default, quota files are stored in the root directory of the file system "
"as [.filename]#quota.user# and [.filename]#quota.group#.  Refer to man:"
"fstab[5] for more information.  Specifying an alternate location for the "
"quota files is not recommended."
msgstr ""
"기본적으로 할당량 파일은 파일 시스템의 루트 디렉터리에 [.filename]#quota."
"user# 및 [.filename]#quota.group#으로 저장됩니다.  자세한 내용은 man:fstab[5]"
"을 참조하세요.  할당량 파일의 대체 위치를 지정하는 것은 권장하지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1682
msgid ""
"Once the configuration is complete, reboot the system and [.filename]#/etc/"
"rc# will automatically run the appropriate commands to create the initial "
"quota files for all of the quotas enabled in [.filename]#/etc/fstab#."
msgstr ""
"구성을 완료하고 시스템을 재부팅하면 [.filename]#/etc/rc#가 자동으로 적절한 "
"명령을 실행하여 [.filename]#/etc/fstab#에서 활성화된 모든 할당량에 대한 초기 "
"할당량 파일을 생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1685
msgid ""
"In the normal course of operations, there should be no need to manually run "
"man:quotacheck[8], man:quotaon[8], or man:quotaoff[8].  However, one should "
"read these manual pages to be familiar with their operation."
msgstr ""
"일반적인 작업 과정에서는 man:quotacheck[8], man:quotaon[8] 또는 "
"man:quotaoff[8]를 수동으로 실행할 필요가 없습니다.  그러나 설명서 페이지를 "
"읽고 작동법을 숙지해야 합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1686
#, no-wrap
msgid "Setting Quota Limits"
msgstr "할당량 한도 설정하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1689
msgid "To verify that quotas are enabled, run:"
msgstr "할당량이 활성화되어 있는지 확인하려면 다음을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1693
#, no-wrap
msgid "# quota -v\n"
msgstr "# quota -v\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1696
msgid ""
"There should be a one line summary of disk usage and current quota limits "
"for each file system that quotas are enabled on."
msgstr "할당량이 활성화된 각 파일 시스템에 대해 디스크 사용량과 현재 할당량 제한에 "
"대한 한 줄 요약이 있어야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1698
msgid "The system is now ready to be assigned quota limits with `edquota`."
msgstr "이제 시스템에 `edquota`을 사용하여 할당량 한도를 지정할 준비가 되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1702
msgid ""
"Several options are available to enforce limits on the amount of disk space "
"a user or group may allocate, and how many files they may create.  "
"Allocations can be limited based on disk space (block quotas), number of "
"files (inode quotas), or a combination of both.  Each limit is further "
"broken down into two categories: hard and soft limits."
msgstr ""
"사용자 또는 그룹이 할당할 수 있는 디스크 공간의 양과 생성할 수 있는 파일 "
"수에 제한을 적용하는 데는 여러 가지 옵션이 있습니다.  디스크 공간(블록 "
"할당량), 파일 수(이노드 할당량) 또는 이 두 가지의 조합을 기준으로 할당을 "
"제한할 수 있습니다.  각 제한은 하드 제한과 소프트 제한의 두 가지 범주로 더 "
"세분화됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1707
msgid ""
"A hard limit may not be exceeded.  Once a user reaches a hard limit, no "
"further allocations can be made on that file system by that user.  For "
"example, if the user has a hard limit of 500 kbytes on a file system and is "
"currently using 490 kbytes, the user can only allocate an additional 10 "
"kbytes.  Attempting to allocate an additional 11 kbytes will fail."
msgstr ""
"하드 제한은 초과할 수 없습니다.  사용자가 하드 제한에 도달하면 해당 사용자는 "
"해당 파일 시스템에 더 이상 할당할 수 없습니다.  예를 들어, 사용자가 파일 "
"시스템의 하드 제한이 500KB이고 현재 490KB를 사용 중인 경우, 사용자는 추가로 "
"10KB만 할당할 수 있습니다.  추가로 11바이트를 할당하려고 시도하면 실패합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1711
msgid ""
"Soft limits can be exceeded for a limited amount of time, known as the grace "
"period, which is one week by default.  If a user stays over their limit "
"longer than the grace period, the soft limit turns into a hard limit and no "
"further allocations are allowed.  When the user drops back below the soft "
"limit, the grace period is reset."
msgstr ""
"소프트 제한은 유예 기간이라고 하는 제한된 시간 동안 초과할 수 있으며, 이 "
"기간은 기본적으로 1주일입니다.  사용자가 유예 기간보다 더 오래 한도를 "
"초과하면 소프트 제한이 하드 제한으로 바뀌고 더 이상 할당이 허용되지 "
"않습니다.  사용자가 소프트 제한 아래로 다시 떨어지면 유예 기간이 "
"초기화됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1715
msgid ""
"In the following example, the quota for the `test` account is being edited.  "
"When `edquota` is invoked, the editor specified by `EDITOR` is opened in "
"order to edit the quota limits.  The default editor is set to vi."
msgstr ""
"다음 예에서는 `test` 계정의 할당량을 편집하고 있습니다.  `edquota`가 "
"호출되면 할당량 한도를 편집하기 위해 `EDITOR`로 지정된 편집기가 열립니다.  "
"기본 편집기는 vi로 설정되어 있습니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1724
#, no-wrap
msgid ""
"# edquota -u test\n"
"Quotas for user test:\n"
"/usr: kbytes in use: 65, limits (soft = 50, hard = 75)\n"
"        inodes in use: 7, limits (soft = 50, hard = 60)\n"
"/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)\n"
"        inodes in use: 0, limits (soft = 50, hard = 60)\n"
msgstr ""
"# edquota -u test\n"
"Quotas for user test:\n"
"/usr: kbytes in use: 65, limits (soft = 50, hard = 75)\n"
"        inodes in use: 7, limits (soft = 50, hard = 60)\n"
"/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)\n"
"        inodes in use: 0, limits (soft = 50, hard = 60)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1730
msgid ""
"There are normally two lines for each file system that has quotas enabled.  "
"One line represents the block limits and the other represents the inode "
"limits.  Change the value to modify the quota limit.  For example, to raise "
"the block limit on [.filename]#/usr# to a soft limit of `500` and a hard "
"limit of `600`, change the values in that line as follows:"
msgstr ""
"할당량이 활성화된 각 파일 시스템에는 일반적으로 두 줄이 표시됩니다.  한 줄은 "
"블록 제한을 나타내고 다른 줄은 이노드 제한을 나타냅니다.  할당량 제한을 "
"수정하려면 값을 변경합니다.  예를 들어 [.filename]#/usr#의 블록 제한을 "
"소프트 제한 '500'과 하드 제한 '600'으로 높이려면 해당 줄의 값을 다음과 같이 "
"변경합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1734
#, no-wrap
msgid "/usr: kbytes in use: 65, limits (soft = 500, hard = 600)\n"
msgstr "/usr: kbytes in use: 65, limits (soft = 500, hard = 600)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1737
msgid "The new quota limits take effect upon exiting the editor."
msgstr "새로운 할당량 제한은 편집기를 종료할 때 적용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1742
msgid ""
"Sometimes it is desirable to set quota limits on a range of users.  This can "
"be done by first assigning the desired quota limit to a user.  Then, use `-"
"p` to duplicate that quota to a specified range of user IDs (UIDs).  The "
"following command will duplicate those quota limits for UIDs `10,000` "
"through `19,999`:"
msgstr ""
"여러 사용자에 대해 할당량 제한을 설정하는 것이 바람직한 경우도 있습니다.  "
"먼저 원하는 할당량 제한을 사용자에게 할당하기 위해 이 작업을 수행할 수 "
"있습니다.  그런 다음 `-p`를 사용하여 해당 할당량을 지정된 범위의 사용자 "
"ID(UID)에 복제합니다.  다음 명령은 UID `10,000`부터 `19,999`까지 해당 할당량 "
"제한을 복제합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1746
#, no-wrap
msgid "# edquota -p test 10000-19999\n"
msgstr "# edquota -p test 10000-19999\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1749
msgid "For more information, refer to man:edquota[8]."
msgstr "자세한 내용은 man:edquota[8]를 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1750
#, no-wrap
msgid "Checking Quota Limits and Disk Usage"
msgstr "할당량 제한 및 디스크 사용량 확인하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1756
msgid ""
"To check individual user or group quotas and disk usage, use man:quota[1].  "
"A user may only examine their own quota and the quota of a group they are a "
"member of.  Only the superuser may view all user and group quotas.  To get a "
"summary of all quotas and disk usage for file systems with quotas enabled, "
"use man:repquota[8]."
msgstr ""
"개별 사용자 또는 그룹 할당량과 디스크 사용량을 확인하려면 man:quota[1]를 "
"사용하세요.  사용자는 자신의 할당량과 자신이 속한 그룹의 할당량만 확인할 수 "
"있습니다.  수퍼유저만 모든 사용자 및 그룹 할당량을 볼 수 있습니다.  할당량이 "
"활성화된 파일 시스템에 대한 모든 할당량 및 디스크 사용량 요약을 보려면 "
"man:repquota[8]를 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1760
msgid ""
"Normally, file systems that the user is not using any disk space on will not "
"show in the output of `quota`, even if the user has a quota limit assigned "
"for that file system.  Use `-v` to display those file systems.  The "
"following is sample output from `quota -v` for a user that has quota limits "
"on two file systems."
msgstr ""
"일반적으로 사용자가 디스크 공간을 사용하지 않은 파일 시스템은, 사용자가 해당 "
"파일 시스템에 할당된 할당량 제한이 있더라도 `quota` 출력에 표시되지 "
"않습니다.  이러한 파일 시스템을 표시하려면 `-v`를 사용하십시오.  다음은 두 "
"파일 시스템에 할당량 제한이 있는 사용자에 대해 `quota -v`의 샘플 출력입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1767
#, no-wrap
msgid ""
"Disk quotas for user test (uid 1002):\n"
"     Filesystem  usage    quota   limit   grace   files   quota   limit   grace\n"
"           /usr      65*     50      75   5days       7      50      60\n"
"       /usr/var       0      50      75               0      50      60\n"
msgstr ""
"Disk quotas for user test (uid 1002):\n"
"     Filesystem  usage    quota   limit   grace   files   quota   limit   "
"grace\n"
"           /usr      65*     50      75   5days       7      50      60\n"
"       /usr/var       0      50      75               0      50      60\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1771
msgid ""
"In this example, the user is currently 15 kbytes over the soft limit of 50 "
"kbytes on [.filename]#/usr# and has 5 days of grace period left.  The "
"asterisk `*` indicates that the user is currently over the quota limit."
msgstr ""
"이 예에서는 사용자가 현재 [.filename]#/usr#에서 소프트 한도인 50KB를 15KB "
"초과하고 있으며 유예 기간이 5일 남았습니다.  별표 `*`는 사용자가 현재 할당량 "
"제한을 초과했음을 나타냅니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1772
#, no-wrap
msgid "Quotas over NFS"
msgstr "NFS를 통한 할당량"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1776
msgid ""
"Quotas are enforced by the quota subsystem on the NFS server.  The man:rpc."
"rquotad[8] daemon makes quota information available to `quota` on NFS "
"clients, allowing users on those machines to see their quota statistics."
msgstr ""
"할당량은 NFS 서버의 할당량 하위 시스템에 의해 적용됩니다.  man:rpc.rquotad[8]"
" 데몬은 NFS 클라이언트의 `quota`가 할당량 정보를 사용할 수 있도록 하여 해당 "
"시스템의 사용자가 할당량 통계를 볼 수 있도록 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1778
msgid ""
"On the NFS server, enable `rpc.rquotad` by removing the `+#+` from this line "
"in [.filename]*/etc/inetd.conf*:"
msgstr ""
"NFS 서버에서 [.filename]*/etc/inetd.conf*의 줄에서 `+#+`를 제거하여 `rpc."
"rquotad`를 활성화합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1782
#, no-wrap
msgid "rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad\n"
msgstr ""
"rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1785
msgid "Then, restart `inetd`:"
msgstr "그런 다음 `inetd`를 다시 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1789
#, no-wrap
msgid "# service inetd restart\n"
msgstr "# service inetd restart\n"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:1792
#, no-wrap
msgid "Encrypting Disk Partitions"
msgstr "디스크 파티션 암호화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1797
msgid ""
"FreeBSD offers excellent online protections against unauthorized data "
"access.  File permissions and crossref:mac[mac,Mandatory Access Control] "
"(MAC) help prevent unauthorized users from accessing data while the "
"operating system is active and the computer is powered up.  However, the "
"permissions enforced by the operating system are irrelevant if an attacker "
"has physical access to a computer and can move the computer's hard drive to "
"another system to copy and analyze the data."
msgstr ""
"FreeBSD는 무단 데이터 액세스에 대한 탁월한 온라인 보호 기능을 제공합니다.  "
"파일 권한과 crossref:mac[mac,Mandatory Access Control](MAC)은 운영 체제가 "
"활성화되고 컴퓨터 전원이 켜져 있는 동안 권한이 없는 사용자가 데이터에 "
"액세스하는 것을 방지합니다.  그러나 공격자가 컴퓨터에 물리적으로 액세스할 수 "
"있고 컴퓨터의 하드 드라이브를 다른 시스템으로 이동하여 데이터를 복사하고 "
"분석할 수 있는 경우 운영 체제에서 시행하는 권한은 무의미합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1801
msgid ""
"Regardless of how an attacker may have come into possession of a hard drive "
"or powered-down computer, the GEOM-based cryptographic subsystems built into "
"FreeBSD are able to protect the data on the computer's file systems against "
"even highly-motivated attackers with significant resources.  Unlike "
"encryption methods that encrypt individual files, the built-in `gbde` and "
"`geli` utilities can be used to transparently encrypt entire file systems.  "
"No cleartext ever touches the hard drive's platter."
msgstr ""
"공격자가 하드 드라이브나 전원이 꺼진 컴퓨터를 어떻게 점유했는지에 상관없이, "
"FreeBSD에 내장된 GEOM 기반 암호화 서브 시스템은 상당한 자원을 가진 강력한 "
"공격자로부터 컴퓨터의 파일 시스템에 있는 데이터를 보호할 수 있습니다.  개별 "
"파일을 암호화하는 암호화 방법과 달리, 내장된 `gbde` 및 `geli` 유틸리티를 "
"사용하여 전체 파일 시스템을 투명하게 암호화할 수 있습니다.  클리어 텍스트는 "
"하드 드라이브의 플래터에 절대 닿지 않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1804
msgid ""
"This chapter demonstrates how to create an encrypted file system on "
"FreeBSD.  It first demonstrates the process using `gbde` and then "
"demonstrates the same example using `geli`."
msgstr ""
"이 장에서는 FreeBSD에서 암호화된 파일 시스템을 만드는 방법을 설명합니다.  "
"먼저 `gbde`를 사용하여 프로세스를 보여준 다음 `geli`를 사용하여 동일한 "
"예제를 보여줍니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1805
#, no-wrap
msgid "Disk Encryption with gbde"
msgstr "gbde를 사용한 디스크 암호화"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1810
msgid ""
"The objective of the man:gbde[4] facility is to provide a formidable "
"challenge for an attacker to gain access to the contents of a _cold_ storage "
"device.  However, if the computer is compromised while up and running and "
"the storage device is actively attached, or the attacker has access to a "
"valid passphrase, it offers no protection to the contents of the storage "
"device.  Thus, it is important to provide physical security while the system "
"is running and to protect the passphrase used by the encryption mechanism."
msgstr ""
"man:gbde[4] 기능의 목적은 공격자가 _콜드_ 저장 장치의 콘텐츠에 액세스하는 "
"것을 어렵게 만드는 것입니다.  그러나 컴퓨터가 실행 중이고 저장 장치가 활성 "
"상태로 연결되어 있거나 공격자가 유효한 암호에 액세스할 수 있는 경우 저장 "
"장치의 콘텐츠에 대한 보호 기능을 제공하지 않습니다.  따라서 시스템이 "
"실행되는 동안 물리적 보안을 제공하고 암호화 메커니즘에서 사용하는 암호 "
"구문을 보호하는 것이 중요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1815
msgid ""
"This facility provides several barriers to protect the data stored in each "
"disk sector.  It encrypts the contents of a disk sector using 128-bit AES in "
"CBC mode.  Each sector on the disk is encrypted with a different AES key.  "
"For more information on the cryptographic design, including how the sector "
"keys are derived from the user-supplied passphrase, refer to man:gbde[4]."
msgstr ""
"이 기능은 각 디스크 섹터에 저장된 데이터를 보호하기 위해 몇 가지 배리어를 "
"제공합니다.  CBC 모드에서 128비트 AES를 사용하여 디스크 섹터의 내용을 "
"암호화합니다.  디스크의 각 섹터는 서로 다른 AES 키로 암호화됩니다.  사용자가 "
"제공한 암호문에서 섹터 키가 파생되는 방법을 포함하여 암호화 설계에 대한 "
"자세한 내용은 man:gbde[4]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1817
msgid ""
"FreeBSD provides a kernel module for gbde which can be loaded with this "
"command:"
msgstr "FreeBSD는 이 명령으로 로드할 수 있는 gbde용 커널 모듈을 제공합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1821
#, no-wrap
msgid "# kldload geom_bde\n"
msgstr "# kldload geom_bde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1824
msgid ""
"If using a custom kernel configuration file, ensure it contains this line:"
msgstr "사용자 정의 커널 구성 파일을 사용하는 경우 다음 내용이 포함되어 있는지 "
"확인하세요:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1826
msgid "`options GEOM_BDE`"
msgstr "`options GEOM_BDE`"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1828
msgid ""
"The following example demonstrates adding a new hard drive to a system that "
"will hold a single encrypted partition that will be mounted as [.filename]#/"
"private#."
msgstr ""
"다음 예제에서는 [.filename]#/private#으로 마운트할 단일 암호화된 파티션을 "
"보관할 새 하드 드라이브를 시스템에 추가하는 방법을 보여 줍니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1830
#, no-wrap
msgid "Procedure: Encrypting a Partition with gbde"
msgstr "절차: gbde로 파티션 암호화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1832
msgid "Add the New Hard Drive"
msgstr "새 하드 드라이브 추가"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1835
msgid ""
"Install the new drive to the system as explained in <<disks-adding>>.  For "
"the purposes of this example, a new hard drive partition has been added as [."
"filename]#/dev/ad4s1c# and [.filename]#/dev/ad0s1*# represents the existing "
"standard FreeBSD partitions."
msgstr ""
"<<disks-adding>>에 설명된 대로 시스템에 새 드라이브를 설치합니다.  이 "
"예제에서는 [.filename]#/dev/ad4s1c#로 새 하드 드라이브 파티션이 추가되었으며 "
"[.filename]#/dev/ad0s1*#은 기존 표준 FreeBSD 파티션을 나타냅니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1842
#, no-wrap
msgid ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4\n"
msgstr ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1845
msgid "Create a Directory to Hold `gbde` Lock Files"
msgstr "`gbde` 잠금 파일을 보관할 디렉터리 생성"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1849
#, no-wrap
msgid "# mkdir /etc/gbde\n"
msgstr "# mkdir /etc/gbde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1854
msgid ""
"The gbde lock file contains information that gbde requires to access "
"encrypted partitions.  Without access to the lock file, gbde will not be "
"able to decrypt the data contained in the encrypted partition without "
"significant manual intervention which is not supported by the software.  "
"Each encrypted partition uses a separate lock file."
msgstr ""
"gbde 잠금 파일에는 gbde가 암호화된 파티션에 액세스하는 데 필요한 정보가 "
"포함되어 있습니다.  잠금 파일에 액세스할 수 없으면 소프트웨어에서 지원하지 "
"않는 상당한 수동 개입 없이는 암호화된 파티션에 포함된 데이터의 암호를 해독할 "
"수 없습니다.  암호화된 각 파티션은 별도의 잠금 파일을 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1855
msgid "Initialize the `gbde` Partition"
msgstr "`gbde` 파티션 초기화"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1860
msgid ""
"A gbde partition must be initialized before it can be used.  This "
"initialization needs to be performed only once.  This command will open the "
"default editor, in order to set various configuration options in a "
"template.  For use with the UFS file system, set the sector_size to 2048:"
msgstr ""
"gbde 파티션을 사용하려면 먼저 초기화해야 합니다.  이 초기화는 한 번만 "
"수행하면 됩니다.  템플릿에서 다양한 구성 옵션을 설정하기 위해 기본 편집기를 "
"엽니다.  UFS 파일 시스템과 함께 사용하려면 sector_size를 2048로 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1873
#, no-wrap
msgid ""
"# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock\n"
"# $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $\n"
"#\n"
"# Sector size is the smallest unit of data which can be read or written.\n"
"# Making it too small decreases performance and decreases available space.\n"
"# Making it too large may prevent filesystems from working.  512 is the\n"
"# minimum and always safe.  For UFS, use the fragment size\n"
"#\n"
"sector_size\t=\t2048\n"
"[...]\n"
msgstr ""
"# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock\n"
"# $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 "
"kensmith Exp $\n"
"#\n"
"# Sector size is the smallest unit of data which can be read or written.\n"
"# Making it too small decreases performance and decreases available space.\n"
"# Making it too large may prevent filesystems from working.  512 is the\n"
"# minimum and always safe.  For UFS, use the fragment size\n"
"#\n"
"sector_size\t=\t2048\n"
"[...]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1879
msgid ""
"Once the edit is saved, the user will be asked twice to type the passphrase "
"used to secure the data.  The passphrase must be the same both times.  The "
"ability of gbde to protect data depends entirely on the quality of the "
"passphrase.  For tips on how to select a secure passphrase that is easy to "
"remember, see http://world.std.com/\\~reinhold/diceware.html[http://world."
"std.com/~reinhold/diceware.htm]."
msgstr ""
"편집 내용이 저장되면 데이터 보안에 사용되는 비밀번호를 입력하라는 메시지가 "
"두 번 표시됩니다.  암호는 두 번 모두 동일해야 합니다.  데이터를 보호하는 "
"gbde의 기능은 전적으로 암호의 품질에 달려 있습니다.  기억하기 쉬운 보안 "
"암호를 선택하는 방법에 대한 팁은 http://world.std.com/\\~reinhold/diceware."
"html[http://world.std.com/~reinhold/diceware.htm]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1883
msgid ""
"This initialization creates a lock file for the gbde partition.  In this "
"example, it is stored as [.filename]#/etc/gbde/ad4s1c.lock#.  Lock files "
"must end in \".lock\" in order to be correctly detected by the [.filename]#/"
"etc/rc.d/gbde# start up script."
msgstr ""
"이 초기화는 gbde 파티션에 대한 잠금 파일을 생성합니다.  이 예제에서는 [."
"filename]#/etc/gbde/ad4s1c.lock#으로 저장됩니다.  잠금 파일은 \".lock\"으로 "
"끝나야 [.filename]#/etc/rc.d/gbde# 시작 스크립트에서 올바르게 감지할 수 "
"있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1888
msgid ""
"Lock files _must_ be backed up together with the contents of any encrypted "
"partitions.  Without the lock file, the legitimate owner will be unable to "
"access the data on the encrypted partition."
msgstr ""
"잠금 파일은 암호화된 파티션의 콘텐츠와 함께 _반드시_ 백업해야 합니다.  잠금 "
"파일이 없으면 정당한 소유자도 암호화된 파티션의 데이터에 액세스할 수 "
"없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1891
msgid "Attach the Encrypted Partition to the Kernel"
msgstr "암호화된 파티션을 커널에 연결"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1895
#, no-wrap
msgid "# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock\n"
msgstr "# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1899
msgid ""
"This command will prompt to input the passphrase that was selected during "
"the initialization of the encrypted partition.  The new encrypted device "
"will appear in [.filename]#/dev# as [.filename]#/dev/device_name.bde#:"
msgstr ""
"이 명령은 암호화된 파티션을 초기화할 때 선택한 암호를 입력하라는 메시지를 "
"표시합니다.  암호화된 새 장치가 [.filename]#/dev#에 [.filename]#/dev/"
"device_name.bde#로 표시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1906
#, no-wrap
msgid ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde\n"
msgstr ""
"# ls /dev/ad*\n"
"/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1\n"
"/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c\n"
"/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1909
msgid "Create a File System on the Encrypted Device"
msgstr "암호화된 장치에 파일 시스템 생성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1913
msgid ""
"Once the encrypted device has been attached to the kernel, a file system can "
"be created on the device.  This example creates a UFS file system with soft "
"updates enabled.  Be sure to specify the partition which has a [.filename]#*."
"bde# extension:"
msgstr ""
"암호화된 디바이스가 커널에 연결되면 디바이스에 파일 시스템을 만들 수 "
"있습니다.  이 예에서는 소프트 업데이트가 활성화된 UFS 파일 시스템을 "
"생성합니다.  확장자가 [.filename]#*.bde#인 파티션을 지정해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1917
#, no-wrap
msgid "# newfs -U /dev/ad4s1c.bde\n"
msgstr "# newfs -U /dev/ad4s1c.bde\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1920
msgid "Mount the Encrypted Partition"
msgstr "암호화된 파티션 마운트"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1922
msgid "Create a mount point and mount the encrypted file system:"
msgstr "마운트 지점을 생성하고 암호화된 파일 시스템을 마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1927
#, no-wrap
msgid ""
"# mkdir /private\n"
"# mount /dev/ad4s1c.bde /private\n"
msgstr ""
"# mkdir /private\n"
"# mount /dev/ad4s1c.bde /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1930
msgid "Verify That the Encrypted File System is Available"
msgstr "암호화된 파일 시스템을 사용할 수 있는지 확인"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1932
msgid "The encrypted file system should now be visible and available for use:"
msgstr "이제 암호화된 파일 시스템이 표시되고 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1943
#, no-wrap
msgid ""
"% df -H\n"
"Filesystem        Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a      1037M    72M   883M     8%    /\n"
"/devfs            1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f       8.1G    55K   7.5G     0%    /home\n"
"/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp\n"
"/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr\n"
"/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private\n"
msgstr ""
"% df -H\n"
"Filesystem        Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a      1037M    72M   883M     8%    /\n"
"/devfs            1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f       8.1G    55K   7.5G     0%    /home\n"
"/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp\n"
"/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr\n"
"/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1947
msgid ""
"After each boot, any encrypted file systems must be manually re-attached to "
"the kernel, checked for errors, and mounted, before the file systems can be "
"used.  To configure these steps, add the following lines to [.filename]#/etc/"
"rc.conf#:"
msgstr ""
"부팅할 때마다 암호화된 파일 시스템을 커널에 수동으로 다시 연결하고 오류를 "
"확인한 후 마운트해야 파일 시스템을 사용할 수 있습니다.  이러한 단계를 "
"구성하려면 [.filename]#/etc/rc.conf#에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1953
#, no-wrap
msgid ""
"gbde_autoattach_all=\"YES\"\n"
"gbde_devices=\"ad4s1c\"\n"
"gbde_lockdir=\"/etc/gbde\"\n"
msgstr ""
"gbde_autoattach_all=\"YES\"\n"
"gbde_devices=\"ad4s1c\"\n"
"gbde_lockdir=\"/etc/gbde\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:1958
msgid ""
"This requires that the passphrase be entered at the console at boot time.  "
"After typing the correct passphrase, the encrypted partition will be mounted "
"automatically.  Additional gbde boot options are available and listed in man:"
"rc.conf[5]."
msgstr ""
"이를 위해서는 부팅 시 콘솔에서 암호 구문을 입력해야 합니다.  올바른 암호 "
"구문을 입력하면 암호화된 파티션이 자동으로 마운트됩니다.  추가 gbde 부팅 "
"옵션을 사용할 수 있으며 man:rc.conf[5]에 나열되어 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1964
msgid ""
"sysinstall is incompatible with gbde-encrypted devices.  All [.filename]#*."
"bde# devices must be detached from the kernel before starting sysinstall or "
"it will crash during its initial probing for devices.  To detach the "
"encrypted device used in the example, use the following command:"
msgstr ""
"sysinstall은 gbde-암호화 장치와 호환되지 않습니다.  모든 [.filename]#*.bde# "
"디바이스를 커널에서 분리한 후 sysinstall을 시작해야 하며, 그렇지 않으면 "
"디바이스를 처음 검색하는 동안 충돌이 발생합니다.  예제에서 사용된 암호화된 "
"장치를 분리하려면 다음 명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1968
#, no-wrap
msgid "# gbde detach /dev/ad4s1c\n"
msgstr "# gbde detach /dev/ad4s1c\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:1972
#, no-wrap
msgid "Disk Encryption with `geli`"
msgstr "`geli`를 사용한 디스크 암호화"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1977
msgid ""
"An alternative cryptographic GEOM class is available using `geli`.  This "
"control utility adds some features and uses a different scheme for doing "
"cryptographic work.  It provides the following features:"
msgstr ""
"`geli`를 사용하면 대체 암호화 GEOM 클래스를 사용할 수 있습니다.  이 제어 "
"유틸리티는 몇 가지 기능을 추가하고 암호화 작업을 수행하기 위해 다른 체계를 "
"사용합니다.  다음과 같은 기능을 제공합니다:"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1979
msgid ""
"Utilizes the man:crypto[9] framework and automatically uses cryptographic "
"hardware when it is available."
msgstr "man:crypto[9] 프레임워크를 활용하고 암호화 하드웨어를 사용할 수 있는 경우 "
"자동으로 사용합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1980
msgid ""
"Supports multiple cryptographic algorithms such as AES, Blowfish, and 3DES."
msgstr "AES, 블로우피시, 3DES 등 여러 암호화 알고리즘을 지원합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1981
msgid ""
"Allows the root partition to be encrypted. The passphrase used to access the "
"encrypted root partition will be requested during system boot."
msgstr "루트 파티션을 암호화하도록 허용합니다. 암호화된 루트 파티션에 액세스하는 데 "
"사용되는 암호는 시스템 부팅 중에 요청됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1982
msgid "Allows the use of two independent keys."
msgstr "두 개의 독립적인 키를 사용할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1983
msgid "It is fast as it performs simple sector-to-sector encryption."
msgstr "간단한 섹터 간 암호화를 수행하기 때문에 빠릅니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1984
msgid ""
"Allows backup and restore of master keys. If a user destroys their keys, it "
"is still possible to get access to the data by restoring keys from the "
"backup."
msgstr "마스터 키의 백업 및 복원을 허용합니다. 사용자가 키를 파기하더라도 백업에서 "
"키를 복원하여 데이터에 액세스할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1985
msgid ""
"Allows a disk to attach with a random, one-time key which is useful for swap "
"partitions and temporary file systems."
msgstr "스왑 파티션 및 임시 파일 시스템에 유용한 임의의 일회용 키로 디스크를 연결할 "
"수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1987
msgid "More features and usage examples can be found in man:geli[8]."
msgstr "더 많은 기능과 사용 예제는 man:geli[8]에서 확인할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1993
msgid ""
"The following example describes how to generate a key file which will be "
"used as part of the master key for the encrypted provider mounted under [."
"filename]#/private#.  The key file will provide some random data used to "
"encrypt the master key.  The master key will also be protected by a "
"passphrase.  The provider's sector size will be 4kB.  The example describes "
"how to attach to the `geli` provider, create a file system on it, mount it, "
"work with it, and finally, how to detach it."
msgstr ""
"다음 예에서는 [.filename]#/private# 아래에 마운트된 암호화된 공급자의 마스터 "
"키의 일부로 사용되는 키 파일을 생성하는 방법을 설명합니다.  키 파일은 마스터 "
"키를 암호화하는 데 사용되는 임의의 데이터를 제공합니다.  마스터 키는 또한 "
"암호로 보호됩니다.  공급자의 섹터 크기는 4kB입니다.  이 예에서는 `geli` "
"공급자에 연결하고, 파일 시스템을 생성하고, 마운트하고, 작업하고, 마지막으로 "
"분리하는 방법을 설명합니다."

#. type: Block title
#: documentation/content/en/books/handbook/disks/_index.adoc:1995
#, no-wrap
msgid "Procedure: Encrypting a Partition with `geli`"
msgstr "절차: `geli`로 파티션 암호화하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1997
msgid "Load `geli` Support"
msgstr "`geli` 지원 로드"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:1999
msgid ""
"Support for `geli` is available as a loadable kernel module. To configure "
"the system to automatically load the module at boot time, add the following "
"line to [.filename]#/boot/loader.conf#:"
msgstr ""
"`geli`에 대한 지원은 로드 가능한 커널 모듈로 제공됩니다. 부팅 시 모듈을 "
"자동으로 로드하도록 시스템을 구성하려면 [.filename]#/boot/loader.conf#에 "
"다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2003
#, no-wrap
msgid "geom_eli_load=\"YES\"\n"
msgstr "geom_eli_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2006
msgid "To load the kernel module now:"
msgstr "지금 커널 모듈을 로드하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2010
#, no-wrap
msgid "# kldload geom_eli\n"
msgstr "# kldload geom_eli\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2013
msgid ""
"For a custom kernel, ensure the kernel configuration file contains these "
"lines:"
msgstr "커스텀 커널의 경우 커널 구성 파일에 다음 줄이 포함되어 있는지 확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2018
#, no-wrap
msgid ""
"options GEOM_ELI\n"
"device crypto\n"
msgstr ""
"options GEOM_ELI\n"
"device crypto\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2021
msgid "Generate the Master Key"
msgstr "마스터 키 생성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2028
msgid ""
"The following commands generate a master key that all data will be encrypted "
"with.  This key can never be changed.  Rather than using it directly, it is "
"encrypted with one or more user keys.  The user keys are made up of an "
"optional combination of random bytes from a file, [.filename]#/root/da2."
"key#, and/or a passphrase.  In this case, the data source for the key file "
"is [.filename]#/dev/random#.  This command also configures the sector size "
"of the provider ([.filename]#/dev/da2.eli#) as 4kB, for better performance:"
msgstr ""
"다음 명령은 모든 데이터를 암호화할 마스터 키를 생성합니다.  이 키는 절대 "
"변경할 수 없습니다.  이 키를 직접 사용하는 대신 하나 이상의 사용자 키로 "
"암호화됩니다.  사용자 키는 파일에서 임의의 바이트, [.filename]#/root/da2.key#"
" 및/또는 암호 구문(선택 사항)의 조합으로 구성됩니다.  이 경우 키 파일의 "
"데이터 소스는 [.filename]#/dev/random#입니다.  이 명령은 또한 성능 향상을 "
"위해 공급자([.filename]#/dev/da2.eli#)의 섹터 크기를 4kB로 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2035
#, no-wrap
msgid ""
"# dd if=/dev/random of=/root/da2.key bs=64 count=1\n"
"# geli init -K /root/da2.key -s 4096 /dev/da2\n"
"Enter new passphrase:\n"
"Reenter new passphrase:\n"
msgstr ""
"# dd if=/dev/random of=/root/da2.key bs=64 count=1\n"
"# geli init -K /root/da2.key -s 4096 /dev/da2\n"
"Enter new passphrase:\n"
"Reenter new passphrase:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2038
msgid ""
"It is not mandatory to use both a passphrase and a key file as either method "
"of securing the master key can be used in isolation."
msgstr ""
"마스터키를 보호하는 두 가지 방법 중 하나를 단독으로 사용할 수 있으므로 "
"비밀번호와 키 파일을 모두 사용해야 하는 것은 아닙니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2041
msgid ""
"If the key file is given as \"-\", standard input will be used.  For "
"example, this command generates three key files:"
msgstr "키 파일을 \"-\"로 지정하면 표준 입력이 사용됩니다.  예를 들어, 이 명령은 "
"3개의 키 파일을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2045
#, no-wrap
msgid "# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2\n"
msgstr "# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2048
msgid "Attach the Provider with the Generated Key"
msgstr "생성된 키로 공급자를 연결"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2050
msgid ""
"To attach the provider, specify the key file, the name of the disk, and the "
"passphrase:"
msgstr "공급자를 연결하려면 키 파일, 디스크 이름 및 암호를 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2055
#, no-wrap
msgid ""
"# geli attach -k /root/da2.key /dev/da2\n"
"Enter passphrase:\n"
msgstr ""
"# geli attach -k /root/da2.key /dev/da2\n"
"Enter passphrase:\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2058
msgid "This creates a new device with an [.filename]#.eli# extension:"
msgstr "이렇게 하면 확장자가 [.filename]#.eli#인 새 장치가 만들어집니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2063
#, no-wrap
msgid ""
"# ls /dev/da2*\n"
"/dev/da2  /dev/da2.eli\n"
msgstr ""
"# ls /dev/da2*\n"
"/dev/da2  /dev/da2.eli\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2066
msgid "Create the New File System"
msgstr "새 파일 시스템 생성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2068
msgid ""
"Next, format the device with the UFS file system and mount it on an existing "
"mount point:"
msgstr "다음으로, UFS 파일 시스템으로 장치를 포맷하고 기존 마운트 지점에 "
"마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2074
#, no-wrap
msgid ""
"# dd if=/dev/random of=/dev/da2.eli bs=1m\n"
"# newfs /dev/da2.eli\n"
"# mount /dev/da2.eli /private\n"
msgstr ""
"# dd if=/dev/random of=/dev/da2.eli bs=1m\n"
"# newfs /dev/da2.eli\n"
"# mount /dev/da2.eli /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2077
msgid "The encrypted file system should now be available for use:"
msgstr "이제 암호화된 파일 시스템을 사용할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2088
#, no-wrap
msgid ""
"# df -H\n"
"Filesystem     Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a    248M    89M   139M    38%    /\n"
"/devfs         1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr\n"
"/dev/ad0s1d    989M   1.5M   909M     0%    /tmp\n"
"/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var\n"
"/dev/da2.eli   150G   4.1K   138G     0%    /private\n"
msgstr ""
"# df -H\n"
"Filesystem     Size   Used  Avail Capacity  Mounted on\n"
"/dev/ad0s1a    248M    89M   139M    38%    /\n"
"/devfs         1.0K   1.0K     0B   100%    /dev\n"
"/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr\n"
"/dev/ad0s1d    989M   1.5M   909M     0%    /tmp\n"
"/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var\n"
"/dev/da2.eli   150G   4.1K   138G     0%    /private\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2091
msgid ""
"Once the work on the encrypted partition is done, and the [.filename]#/"
"private# partition is no longer needed, it is prudent to put the device into "
"cold storage by unmounting and detaching the `geli` encrypted partition from "
"the kernel:"
msgstr ""
"암호화된 파티션에 대한 작업이 완료되고 [.filename]#/private# 파티션이 더 "
"이상 필요하지 않게 되면, 커널에서 `geli` 암호화된 파티션을 마운트 해제하고 "
"분리하여 장치를 콜드 스토리지에 넣는 것이 현명합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2096
#, no-wrap
msgid ""
"# umount /private\n"
"# geli detach da2.eli\n"
msgstr ""
"# umount /private\n"
"# geli detach da2.eli\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2099
msgid ""
"An [.filename]#rc.d# script is provided to simplify the mounting of `geli`-"
"encrypted devices at boot time. For this example, add these lines to [."
"filename]#/etc/rc.conf#:"
msgstr ""
"부팅 시 `geli`로 암호화된 디바이스의 마운팅을 간소화하기 위해 [.filename]#rc."
"d# 스크립트가 제공됩니다. 이 예제에서는 [.filename]#/etc/rc.conf#에 다음 "
"줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2104
#, no-wrap
msgid ""
"geli_devices=\"da2\"\n"
"geli_da2_flags=\"-k /root/da2.key\"\n"
msgstr ""
"geli_devices=\"da2\"\n"
"geli_da2_flags=\"-k /root/da2.key\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2114
msgid ""
"This configures [.filename]#/dev/da2# as a `geli` provider with a master key "
"of [.filename]#/root/da2.key#.  The system will automatically detach the "
"provider from the kernel before the system shuts down.  During the startup "
"process, the script will prompt for the passphrase before attaching the "
"provider.  Other kernel messages might be shown before and after the "
"password prompt.  If the boot process seems to stall, look carefully for the "
"password prompt among the other messages.  Once the correct passphrase is "
"entered, the provider is attached.  The file system is then mounted, "
"typically by an entry in [.filename]#/etc/fstab#.  Refer to crossref:"
"basics[mount-unmount,“Mounting and Unmounting File Systems”] for "
"instructions on how to configure a file system to mount at boot time."
msgstr ""
"이렇게 하면 [.filename]#/dev/da2#의 마스터 키가 [.filename]#/root/da2.key#인 "
"`geli` 공급자로 구성됩니다.  시스템이 종료되기 전에 커널에서 프로바이더가 "
"자동으로 분리됩니다.  시작 프로세스 중에 스크립트는 공급자를 연결하기 전에 "
"암호를 입력하라는 메시지를 표시합니다.  비밀번호 프롬프트 전후에 다른 커널 "
"메시지가 표시될 수도 있습니다.  부팅 프로세스가 멈추는 것 같으면 다른 메시지 "
"중에서 비밀번호 프롬프트가 있는지 주의 깊게 살펴보세요.  올바른 암호를 "
"입력하면 공급자가 연결됩니다.  그런 다음 파일 시스템이 마운트되며, "
"일반적으로 [.filename]#/etc/fstab#의 항목에 의해 마운트됩니다.  부팅 시 "
"마운트하도록 파일 시스템을 구성하는 방법에 대한 지침은 crossref:basics[mount-"
"unmount,“Mounting and Unmounting File Systems”]를 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:2116
#, no-wrap
msgid "Encrypting Swap"
msgstr "스왑 암호화하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2123
msgid ""
"Like the encryption of disk partitions, encryption of swap space is used to "
"protect sensitive information.  Consider an application that deals with "
"passwords.  As long as these passwords stay in physical memory, they are not "
"written to disk and will be cleared after a reboot.  However, if FreeBSD "
"starts swapping out memory pages to free space, the passwords may be written "
"to the disk unencrypted.  Encrypting swap space can be a solution for this "
"scenario."
msgstr ""
"디스크 파티션 암호화와 마찬가지로 스왑 공간 암호화는 중요한 정보를 보호하는 "
"데 사용됩니다.  비밀번호를 다루는 애플리케이션을 생각해 보세요.  이러한 "
"암호가 물리적 메모리에 남아 있는 한, 암호는 디스크에 기록되지 않으며 재부팅 "
"후 지워집니다.  그러나 FreeBSD가 메모리 페이지를 여유 공간으로 스왑하기 "
"시작하면 암호가 암호화되지 않은 상태로 디스크에 기록될 수 있습니다.  스왑 "
"공간을 암호화하는 것이 이 시나리오에 대한 해결책이 될 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2126
msgid ""
"This section demonstrates how to configure an encrypted swap partition using "
"man:gbde[8] or man:geli[8] encryption.  It assumes that [.filename]#/dev/"
"ada0s1b# is the swap partition."
msgstr ""
"이 섹션에서는 man:gbde[8] 또는 man:geli[8] 암호화를 사용하여 암호화된 스왑 "
"파티션을 구성하는 방법을 설명합니다.  여기서는 [.filename]#/dev/ada0s1b#이 "
"스왑 파티션이라고 가정합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2127
#, no-wrap
msgid "Configuring Encrypted Swap"
msgstr "암호화된 스왑 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2131
msgid ""
"Swap partitions are not encrypted by default and should be cleared of any "
"sensitive data before continuing.  To overwrite the current swap partition "
"with random garbage, execute the following command:"
msgstr ""
"스왑 파티션은 기본적으로 암호화되지 않으므로 계속하기 전에 중요한 데이터를 "
"모두 지워야 합니다.  현재 스왑 파티션을 임의의 가비지로 덮어쓰려면 다음 "
"명령을 실행하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2135
#, no-wrap
msgid "# dd if=/dev/random of=/dev/ada0s1b bs=1m\n"
msgstr "# dd if=/dev/random of=/dev/ada0s1b bs=1m\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2138
msgid ""
"To encrypt the swap partition using man:gbde[8], add the `.bde` suffix to "
"the swap line in [.filename]#/etc/fstab#:"
msgstr ""
"man:gbde[8]를 사용하여 스왑 파티션을 암호화하려면 [.filename]#/etc/fstab#의 "
"스왑 줄에 접미사 '.bde'를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2143
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.bde\tnone\t\tswap\tsw\t\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.bde\tnone\t\tswap\tsw\t\t0\t0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2146
msgid ""
"To instead encrypt the swap partition using man:geli[8], use the `.eli` "
"suffix:"
msgstr "대신 man:geli[8]를 사용하여 스왑 파티션을 암호화하려면 `.eli` 접미사를 "
"사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2151
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw\t\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw\t\t0\t0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2156
msgid ""
"By default, man:geli[8] uses the AES algorithm with a key length of 128 "
"bits.  Normally the default settings will suffice.  If desired, these "
"defaults can be altered in the options field in [.filename]#/etc/fstab#. The "
"possible flags are:"
msgstr ""
"기본적으로 man:geli[8]는 키 길이가 128비트인 AES 알고리즘을 사용합니다.  "
"보통은 기본 설정으로 충분합니다.  원하는 경우 [.filename]#/etc/fstab#의 옵션 "
"필드에서 이러한 기본값을 변경할 수 있습니다. 가능한 플래그는 다음과 같습니다:"

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2157
#, no-wrap
msgid "aalgo"
msgstr "aalgo"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2160
msgid ""
"Data integrity verification algorithm used to ensure that the encrypted data "
"has not been tampered with.  See man:geli[8] for a list of supported "
"algorithms."
msgstr ""
"암호화된 데이터가 변조되지 않았는지 확인하는 데 사용되는 데이터 무결성 검증 "
"알고리즘입니다.  지원되는 알고리즘 목록은 man:geli[8]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2161
#, no-wrap
msgid "ealgo"
msgstr "ealgo"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2164
msgid ""
"Encryption algorithm used to protect the data.  See man:geli[8] for a list "
"of supported algorithms."
msgstr "데이터를 보호하는 데 사용되는 암호화 알고리즘입니다.  지원되는 알고리즘 "
"목록은 man:geli[8]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2165
#, no-wrap
msgid "keylen"
msgstr "keylen"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2168
msgid ""
"The length of the key used for the encryption algorithm.  See man:geli[8] "
"for the key lengths that are supported by each encryption algorithm."
msgstr "암호화 알고리즘에 사용되는 키의 길이입니다.  각 암호화 알고리즘에서 지원하는 "
"키 길이는 man:geli[8]를 참조하세요."

#. type: Labeled list
#: documentation/content/en/books/handbook/disks/_index.adoc:2169
#, no-wrap
msgid "sectorsize"
msgstr "sectorsize"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2173
msgid ""
"The size of the blocks data is broken into before it is encrypted.  Larger "
"sector sizes increase performance at the cost of higher storage overhead.  "
"The recommended size is 4096 bytes."
msgstr ""
"블록의 크기는 데이터가 암호화되기 전에 분할되는 크기입니다.  섹터 크기가 "
"클수록 스토리지 오버헤드가 증가하지만 성능이 향상됩니다.  권장 크기는 "
"4096바이트입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2175
msgid ""
"This example configures an encrypted swap partition using the Blowfish "
"algorithm with a key length of 128 bits and a sectorsize of 4 kilobytes:"
msgstr ""
"이 예에서는 키 길이가 128비트이고 섹터 크기가 4KB인 Blowfish 알고리즘을 "
"사용하여 암호화된 스왑 파티션을 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2180
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\t\t\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw,ealgo=blowfish,keylen=128,sectorsize=4096\t0\t0\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\t\t\t\tDump\tPass#\n"
"/dev/ada0s1b.eli\tnone\t\tswap\tsw,ealgo=blowfish,keylen=128,sectorsize="
"4096\t0\t0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2182
#, no-wrap
msgid "Encrypted Swap Verification"
msgstr "암호화된 스왑 확인"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2185
msgid ""
"Once the system has rebooted, proper operation of the encrypted swap can be "
"verified using `swapinfo`."
msgstr "시스템이 재부팅되면 `swapinfo`를 사용하여 암호화된 스왑이 제대로 작동하는지 "
"확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2187
msgid "If man:gbde[8] is being used:"
msgstr "man:gbde[8]가 사용 중인 경우:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2193
#, no-wrap
msgid ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.bde   542720        0   542720     0\n"
msgstr ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.bde   542720        0   542720     0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2196
msgid "If man:geli[8] is being used:"
msgstr "man:geli[8]가 사용 중인 경우:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2202
#, no-wrap
msgid ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.eli   542720        0   542720     0\n"
msgstr ""
"% swapinfo\n"
"Device          1K-blocks     Used    Avail Capacity\n"
"/dev/ada0s1b.eli   542720        0   542720     0\n"

#. type: Title ==
#: documentation/content/en/books/handbook/disks/_index.adoc:2205
#, no-wrap
msgid "Highly Available Storage (HAST)"
msgstr "고가용성 스토리지(HAST)"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2211
msgid ""
"High availability is one of the main requirements in serious business "
"applications and highly-available storage is a key component in such "
"environments.  In FreeBSD, the Highly Available STorage (HAST) framework "
"allows transparent storage of the same data across several physically "
"separated machines connected by a TCP/IP network.  HAST can be understood as "
"a network-based RAID1 (mirror), and is similar to the DRBD(R) storage system "
"used in the GNU/Linux(R) platform.  In combination with other high-"
"availability features of FreeBSD like CARP, HAST makes it possible to build "
"a highly-available storage cluster that is resistant to hardware failures."
msgstr ""
"고가용성은 중요한 비즈니스 애플리케이션의 주요 요구 사항 중 하나이며, "
"고가용성 스토리지는 이러한 환경에서 핵심 구성 요소입니다.  FreeBSD의 "
"고가용성 스토리지(HAST) 프레임워크는 물리적으로 분리된 여러 머신에 동일한 "
"데이터를 TCP/IP 네트워크로 연결하여 투명하게 저장할 수 있습니다.  HAST는 "
"네트워크 기반 RAID1(미러)로 이해할 수 있으며, GNU/Linux(R) 플랫폼에서 "
"사용되는 DRBD(R) 스토리지 시스템과 유사합니다.  CARP와 같은 FreeBSD의 다른 "
"고가용성 기능과 결합하면 하드웨어 장애에 강한 고가용성 스토리지 클러스터를 "
"구축할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2213
msgid "The following are the main features of HAST:"
msgstr "다음은 HAST의 주요 기능입니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2215
msgid "Can be used to mask I/O errors on local hard drives."
msgstr "로컬 하드 드라이브의 I/O 오류를 마스킹하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2216
msgid ""
"File system agnostic as it works with any file system supported by FreeBSD."
msgstr "파일 시스템에 구애받지 않으므로 FreeBSD에서 지원하는 모든 파일 시스템에서 "
"작동합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2217
msgid ""
"Efficient and quick resynchronization as only the blocks that were modified "
"during the downtime of a node are synchronized."
msgstr "노드의 다운타임 동안 수정된 블록만 동기화되므로 효율적이고 빠르게 재동기화할 "
"수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2218
msgid ""
"Can be used in an already deployed environment to add additional redundancy."
msgstr "이미 배포된 환경에서 여분의 중복성을 추가하는 데 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2219
msgid ""
"Together with CARP, Heartbeat, or other tools, it can be used to build a "
"robust and durable storage system."
msgstr "CARP, Heartbeat 또는 기타 도구와 함께 사용하면 견고하고 내구성 있는 스토리지 "
"시스템을 구축할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2221
msgid "After reading this section, you will know:"
msgstr "이 섹션을 읽고 나면 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2223
msgid "What HAST is, how it works, and which features it provides."
msgstr "HAST가 무엇인지, 어떻게 작동하는지, 어떤 기능을 제공하는지."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2224
msgid "How to set up and use HAST on FreeBSD."
msgstr "FreeBSD에서 HAST를 설정하고 사용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2225
msgid "How to integrate CARP and man:devd[8] to build a robust storage system."
msgstr "강력한 스토리지 시스템을 구축하기 위해 CARP와 man:devd[8]를 통합하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2227
msgid "Before reading this section, you should:"
msgstr "이 섹션을 읽기 전에 다음을 알아야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2229
msgid ""
"Understand UNIX(R) and FreeBSD basics (crossref:basics[basics,FreeBSD "
"Basics])."
msgstr "UNIX(R) 및 FreeBSD 기본 사항을 이해합니다(crossref:basics[basics,FreeBSD "
"Basics])."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2230
msgid ""
"Know how to configure network interfaces and other core FreeBSD subsystems "
"(crossref:config[config-tuning,Configuration and Tuning])."
msgstr ""
"네트워크 인터페이스 및 기타 핵심 FreeBSD 하위 시스템을 구성하는 방법을 "
"알아야 합니다(crossref:config[config-tuning,Configuration and Tuning])."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2231
msgid ""
"Have a good understanding of FreeBSD networking (crossref:partiv[network-"
"communication,\"Network Communication\"])."
msgstr ""
"FreeBSD 네트워킹을 잘 이해해야 합니다(crossref:partiv[network-communication,"
"\"Network Communication\"])."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2233
msgid ""
"The HAST project was sponsored by The FreeBSD Foundation with support from "
"http://www.omc.net/[http://www.omc.net/] and http://www.transip.nl/[http://"
"www.transip.nl/]."
msgstr ""
"HAST 프로젝트는 http://www.omc.net/[http://www.omc.net/] 및 http://www."
"transip.nl/[http://www.transip.nl/]의 지원으로 FreeBSD 재단의 후원을 "
"받았습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2234
#, no-wrap
msgid "HAST Operation"
msgstr "HAST 작업"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2238
msgid ""
"HAST provides synchronous block-level replication between two physical "
"machines: the _primary_ node and the _secondary_ node.  These two machines "
"together are referred to as a cluster."
msgstr ""
"HAST는 두 개의 물리적 머신, 즉 _primary_ 노드와 _secondary_ 노드 간에 동기식 "
"블록 레벨 복제를 제공합니다.  이 두 시스템을 함께 클러스터라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2242
msgid ""
"Since HAST works in a primary-secondary configuration, it allows only one of "
"the cluster nodes to be active at any given time.  The primary node, also "
"called _active_, is the one which will handle all the I/O requests to HAST-"
"managed devices.  The secondary node is automatically synchronized from the "
"primary node."
msgstr ""
"HAST는 일차-이차 구성으로 작동하기 때문에, 클러스터 노드 중 하나만 언제든지 "
"활성화됩니다.  _액티브_라고도 하는 일차 노드는 HAST 관리 장치에 대한 모든 I/"
"O 요청을 처리하는 노드입니다.  이차 노드는 일차 노드에서 자동으로 "
"동기화됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2244
msgid ""
"The physical components of the HAST system are the local disk on primary "
"node, and the disk on the remote, secondary node."
msgstr "HAST 시스템의 물리적 구성 요소는 일차 노드의 로컬 디스크와 원격의 이차 "
"노드에 있는 디스크입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2248
msgid ""
"HAST operates synchronously on a block level, making it transparent to file "
"systems and applications.  HAST provides regular GEOM providers in [."
"filename]#/dev/hast/# for use by other tools or applications.  There is no "
"difference between using HAST-provided devices and raw disks or partitions."
msgstr ""
"HAST는 블록 수준에서 동기적으로 작동하므로 파일 시스템과 애플리케이션에 "
"투명합니다.  HAST는 다른 도구나 애플리케이션에서 사용할 수 있도록 [."
"filename]#/dev/hast/#에 일반 GEOM 공급자를 제공합니다.  HAST 제공 장치와 "
"원시 디스크 또는 파티션을 사용하는 것 사이에는 차이가 없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2252
msgid ""
"Each write, delete, or flush operation is sent to both the local disk and to "
"the remote disk over TCP/IP.  Each read operation is served from the local "
"disk, unless the local disk is not up-to-date or an I/O error occurs.  In "
"such cases, the read operation is sent to the secondary node."
msgstr ""
"각각의 쓰기, 삭제 또는 플러시 작업은 TCP/IP를 통해 로컬 디스크와 원격 디스크 "
"모두에 전송됩니다.  로컬 디스크가 최신 상태가 아니거나 I/O 오류가 발생하지 "
"않는 한, 각 읽기 작업은 로컬 디스크에서 제공됩니다.  문제가 발생한 경우, "
"읽기 작업은 이차 노드로 전송됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2256
msgid ""
"HAST tries to provide fast failure recovery.  For this reason, it is "
"important to reduce synchronization time after a node's outage.  To provide "
"fast synchronization, HAST manages an on-disk bitmap of dirty extents and "
"only synchronizes those during a regular synchronization, with an exception "
"of the initial sync."
msgstr ""
"HAST는 빠른 장애 복구를 제공하기 위해 노력합니다.  따라서 노드 중단 후 "
"동기화 시간을 줄이는 것이 중요합니다.  빠른 동기화를 제공하기 위해 HAST는 "
"더티 익스텐트의 온디스크 비트맵을 관리하고 초기 동기화를 제외한 정기 동기화 "
"중에만 동기화합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2259
msgid ""
"There are many ways to handle synchronization.  HAST implements several "
"replication modes to handle different synchronization methods:"
msgstr ""
"동기화를 처리하는 방법에는 여러 가지가 있습니다.  HAST는 다양한 동기화 "
"방법을 처리하기 위해 여러 가지 복제 모드를 구현합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2261
msgid ""
"_memsync_: This mode reports a write operation as completed when the local "
"write operation is finished and when the remote node acknowledges data "
"arrival, but before actually storing the data. The data on the remote node "
"will be stored directly after sending the acknowledgement. This mode is "
"intended to reduce latency, but still provides good reliability. This mode "
"is the default."
msgstr ""
"_memsync_: 이 모드는 로컬 쓰기 작업이 완료되고 원격 노드가 데이터 도착을 "
"확인하지만 실제로 데이터를 저장하기 전일 때 쓰기 작업이 완료된 것으로 "
"보고합니다. 원격 노드(이차 노드)의 데이터는 승인 전송 후 바로 저장됩니다. 이 "
"모드는 지연 시간을 줄이기 위한 것이지만 여전히 우수한 안정성을 제공합니다. "
"이 모드가 기본값입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2262
msgid ""
"_fullsync_: This mode reports a write operation as completed when both the "
"local write and the remote write complete. This is the safest and the "
"slowest replication mode."
msgstr ""
"_fullsync_: 이 모드는 로컬 쓰기와 원격 쓰기가 모두 완료되면 쓰기 작업이 "
"완료된 것으로 보고합니다. 가장 안전하면서도 가장 느린 복제 모드입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2263
msgid ""
"_async_: This mode reports a write operation as completed when the local "
"write completes. This is the fastest and the most dangerous replication "
"mode. It should only be used when replicating to a distant node where "
"latency is too high for other modes."
msgstr ""
"_async_: 이 모드는 로컬 쓰기가 완료되면 쓰기 작업이 완료된 것으로 "
"보고합니다. 가장 빠르지만 가장 위험한 복제 모드입니다. 다른 모드를 "
"사용하기에는 지연 시간이 너무 길어 멀리 떨어진 노드로 복제할 때만 사용해야 "
"합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2264
#, no-wrap
msgid "HAST Configuration"
msgstr "HAST 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2267
msgid "The HAST framework consists of several components:"
msgstr "HAST 프레임워크는 여러 구성 요소로 이루어져 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2269
msgid ""
"The man:hastd[8] daemon which provides data synchronization. When this "
"daemon is started, it will automatically load `geom_gate.ko`."
msgstr ""
"데이터 동기화를 제공하는 man:hastd[8] 데몬입니다. 이 데몬이 시작되면 "
"`geom_gate.ko`를 자동으로 로드합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2270
msgid "The userland management utility, man:hastctl[8]."
msgstr "사용자 공간 관리 유틸리티, man:hastctl[8]."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2271
msgid ""
"The man:hast.conf[5] configuration file. This file must exist before "
"starting hastd."
msgstr "man:hast.conf[5] 구성 파일. 이 파일은 hastd를 시작하기 전에 존재해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2273
msgid ""
"Users who prefer to statically build `GEOM_GATE` support into the kernel "
"should add this line to the custom kernel configuration file, then rebuild "
"the kernel using the instructions in crossref:kernelconfig[kernelconfig,"
"Configuring the FreeBSD Kernel]:"
msgstr ""
"커널에 `GEOM_GATE` 지원을 정적으로 빌드하고 싶은 사용자는 커스텀 커널 구성 "
"파일에 이 줄을 추가한 다음 crossref:kernelconfig[kernelconfig,Configuring "
"the FreeBSD Kernel]의 지침에 따라 커널을 다시 빌드해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2277
#, no-wrap
msgid "options\tGEOM_GATE\n"
msgstr "options\tGEOM_GATE\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2283
msgid ""
"The following example describes how to configure two nodes in primary-"
"secondary operation using HAST to replicate the data between the two.  The "
"nodes will be called `hasta`, with an IP address of `172.16.0.1`, and "
"`hastb`, with an IP address of `172.16.0.2`.  Both nodes will have a "
"dedicated hard drive [.filename]#/dev/ad6# of the same size for HAST "
"operation.  The HAST pool, sometimes referred to as a resource or the GEOM "
"provider in [.filename]#/dev/hast/#, will be called `test`."
msgstr ""
"다음 예제는 HAST를 사용하여 두 노드 간 데이터를 복제하는 일차-이차 작업에서 "
"두 노드를 구성하는 방법을 설명합니다.  노드는 `172.16.0.1`의 IP 주소를 가진 "
"`hasta`와 `172.16.0.2`의 IP 주소를 가진 `hastb`로 불립니다.  두 노드 모두 "
"HAST 작동을 위해 동일한 크기의 전용 하드 드라이브 [.filename]#/dev/ad6#을 "
"갖게 됩니다.  HAST 풀은 리소스 또는 [.filename]#/dev/hast/#의 GEOM "
"제공자라고도 하며, `test`라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2287
msgid ""
"Configuration of HAST is done using [.filename]#/etc/hast.conf#.  This file "
"should be identical on both nodes.  The simplest configuration is:"
msgstr ""
"HAST의 구성은 [.filename]#/etc/hast.conf#를 사용하여 수행됩니다.  이 파일은 "
"두 노드에서 동일해야 합니다.  가장 간단한 구성은:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2300
#, no-wrap
msgid ""
"resource test {\n"
"\ton hasta {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.2\n"
"\t}\n"
"\ton hastb {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.1\n"
"\t}\n"
"}\n"
msgstr ""
"resource test {\n"
"\ton hasta {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.2\n"
"\t}\n"
"\ton hastb {\n"
"\t\tlocal /dev/ad6\n"
"\t\tremote 172.16.0.1\n"
"\t}\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2303
msgid "For more advanced configuration, refer to man:hast.conf[5]."
msgstr "고급 구성은 man:hast.conf[5]를 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2307
msgid ""
"It is also possible to use host names in the `remote` statements if the "
"hosts are resolvable and defined either in [.filename]#/etc/hosts# or in the "
"local DNS."
msgstr ""
"호스트가 [.filename]#/etc/hosts# 또는 로컬 DNS에 정의되어 있고 확인 가능한 "
"경우 `remote` 문에 호스트 이름을 사용할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2311
msgid ""
"Once the configuration exists on both nodes, the HAST pool can be created.  "
"Run these commands on both nodes to place the initial metadata onto the "
"local disk and to start man:hastd[8]:"
msgstr ""
"구성파일이 두 노드에 모두 존재하면 HAST 풀을 생성할 수 있습니다.  두 "
"노드에서 다음 명령을 실행하여 초기 메타데이터를 로컬 디스크에 배치하고 "
"man:hastd[8]를 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2316
#, no-wrap
msgid ""
"# hastctl create test\n"
"# service hastd onestart\n"
msgstr ""
"# hastctl create test\n"
"# service hastd onestart\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2322
msgid ""
"It is _not_ possible to use GEOM providers with an existing file system or "
"to convert an existing storage to a HAST-managed pool.  This procedure needs "
"to store some metadata on the provider and there will not be enough required "
"space available on an existing provider."
msgstr ""
"기존 파일 시스템과 함께 GEOM 공급자를 사용하거나 기존 저장소를 HAST 관리 "
"풀로 변환하는 것은 _불가능합니다_.  이 절차는 일부 메타데이터를 제공자에 "
"저장해야 하며 기존 제공자에는 필요한 공간이 충분하지 않을 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2326
msgid ""
"A HAST node's `primary` or `secondary` role is selected by an administrator, "
"or software like Heartbeat, using man:hastctl[8].  On the primary node, "
"`hasta`, issue this command:"
msgstr ""
"HAST 노드의 `일차` 또는 `이차` 역할은 관리자 또는 Heartbeat와 같은 "
"소프트웨어가 man:hastctl[8]을 사용하여 선택합니다.  일차 노드인 `hasta`에서 "
"이 명령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2330
#, no-wrap
msgid "# hastctl role primary test\n"
msgstr "# hastctl role primary test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2333
msgid "Run this command on the secondary node, `hastb`:"
msgstr "이차 노드인 `hastb`에서 이 명령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2337
#, no-wrap
msgid "# hastctl role secondary test\n"
msgstr "# hastctl role secondary test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2340
msgid "Verify the result by running `hastctl` on each node:"
msgstr "각 노드에서 `hastctl`을 실행하여 결과를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2344
#, no-wrap
msgid "# hastctl status test\n"
msgstr "# hastctl status test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2350
msgid ""
"Check the `status` line in the output.  If it says `degraded`, something is "
"wrong with the configuration file.  It should say `complete` on each node, "
"meaning that the synchronization between the nodes has started.  The "
"synchronization completes when `hastctl status` reports 0 bytes of `dirty` "
"extents."
msgstr ""
"출력에서 `status` 줄을 확인하세요.  `degraded`이라고 표시되면 구성 파일에 "
"문제가 있는 것입니다.  각 노드에 `complete` 라고 표시되어야 하며, 이는 노드 "
"간 동기화가 시작되었음을 의미합니다.  `hastctl status`가 0바이트의 `dirty` "
"익스텐트를 보고하면 동기화가 완료됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2355
msgid ""
"The next step is to create a file system on the GEOM provider and mount it.  "
"This must be done on the `primary` node.  Creating the file system can take "
"a few minutes, depending on the size of the hard drive.  This example "
"creates a UFS file system on [.filename]#/dev/hast/test#:"
msgstr ""
"다음 단계는 GEOM 공급자에 파일 시스템을 생성하고 마운트하는 것입니다.  이 "
"작업은 '일차' 노드에서 수행해야 합니다.  파일 시스템을 생성하는 데에는 하드 "
"드라이브의 크기에 따라 몇 분 정도 걸릴 수 있습니다.  이 예제에서는 [."
"filename]#/dev/hast/test#에 UFS 파일 시스템을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2361
#, no-wrap
msgid ""
"# newfs -U /dev/hast/test\n"
"# mkdir /hast/test\n"
"# mount /dev/hast/test /hast/test\n"
msgstr ""
"# newfs -U /dev/hast/test\n"
"# mkdir /hast/test\n"
"# mount /dev/hast/test /hast/test\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2365
msgid ""
"Once the HAST framework is configured properly, the final step is to make "
"sure that HAST is started automatically during system boot.  Add this line "
"to [.filename]#/etc/rc.conf#:"
msgstr ""
"HAST 프레임워크가 올바르게 구성되면, 마지막 단계는 시스템 부팅 중에 HAST가 "
"자동으로 시작되도록 하는 것입니다.  이 줄을 [.filename]#/etc/rc.conf#에 "
"추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2369
#, no-wrap
msgid "hastd_enable=\"YES\"\n"
msgstr "hastd_enable=\"YES\"\n"

#. type: Title ====
#: documentation/content/en/books/handbook/disks/_index.adoc:2371
#, no-wrap
msgid "Failover Configuration"
msgstr "장애 조치 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2375
msgid ""
"The goal of this example is to build a robust storage system which is "
"resistant to the failure of any given node.  If the primary node fails, the "
"secondary node is there to take over seamlessly, check and mount the file "
"system, and continue to work without missing a single bit of data."
msgstr ""
"이 예제의 목표는 특정 노드의 장애에 견딜 수 있는 강력한 스토리지 시스템을 "
"구축하는 것입니다.  일차 노드에 장애가 발생하면 이차 노드가 원활하게 "
"인계받아 파일 시스템을 확인하고 마운트하여 단 하나의 비트 데이터도 놓치지 "
"않고 계속 작업할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2381
msgid ""
"To accomplish this task, the Common Address Redundancy Protocol (CARP) is "
"used to provide for automatic failover at the IP layer.  CARP allows "
"multiple hosts on the same network segment to share an IP address.  Set up "
"CARP on both nodes of the cluster according to the documentation available "
"in crossref:advanced-networking[carp,“Common Address Redundancy Protocol "
"(CARP)”].  In this example, each node will have its own management IP "
"address and a shared IP address of _172.16.0.254_.  The primary HAST node of "
"the cluster must be the primary CARP node."
msgstr ""
"이 작업을 수행하기 위해 공통 주소 중복 프로토콜(Common Address Redundancy "
"Protocol, CARP)을 사용하여 IP 계층에서 자동 장애조치를 제공합니다.  CARP를 "
"사용하면 동일한 네트워크 세그먼트에 있는 여러 호스트가 하나의 IP 주소를 "
"공유할 수 있습니다.  crossref:advanced-networking[carp,“Common Address "
"Redundancy Protocol (CARP)”] 문서에 나와 있는 설명서에 따라 클러스터의 두 "
"노드에서 CARP를 설정합니다.  이 예제에서 각 노드는 자체 관리 IP 주소와 "
"_172.16.0.254_의 공유 IP 주소를 갖습니다.  클러스터의 일차 HAST 노드는 일차 "
"CARP 노드여야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2385
msgid ""
"The HAST pool created in the previous section is now ready to be exported to "
"the other hosts on the network.  This can be accomplished by exporting it "
"through NFS or Samba, using the shared IP address _172.16.0.254_.  The only "
"problem which remains unresolved is an automatic failover should the primary "
"node fail."
msgstr ""
"이제 이전 섹션에서 생성한 HAST 풀을 네트워크의 다른 호스트로 내보낼 준비가 "
"되었습니다.  공유 IP 주소 _172.16.0.254_를 사용하여 NFS 또는 Samba를 통해 "
"내보내면 됩니다.  아직 해결되지 않은 유일한 문제는 기본 노드에 장애가 발생할 "
"경우 자동 장애조치입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2389
msgid ""
"In the event of CARP interfaces going up or down, the FreeBSD operating "
"system generates a man:devd[8] event, making it possible to watch for state "
"changes on the CARP interfaces.  A state change on the CARP interface is an "
"indication that one of the nodes failed or came back online.  These state "
"change events make it possible to run a script which will automatically "
"handle the HAST failover."
msgstr ""
"CARP 인터페이스가 올라가거나 내려가는 경우, FreeBSD 운영체제는 man:devd[8] "
"이벤트를 생성하여 CARP 인터페이스의 상태 변화를 관찰할 수 있게 합니다.  CARP "
"인터페이스의 상태 변경은 노드 중 하나가 실패했거나 다시 온라인 상태가 "
"되었음을 나타냅니다.  이러한 상태 변경 이벤트를 통해 HAST 장애 조치를 "
"자동으로 처리하는 스크립트를 실행할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2391
msgid ""
"To catch state changes on the CARP interfaces, add this configuration to [."
"filename]#/etc/devd.conf# on each node:"
msgstr ""
"CARP 인터페이스의 상태 변경을 포착하려면 각 노드의 [.filename]#/etc/devd."
"conf#에 다음 구성을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2400
#, no-wrap
msgid ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_UP\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch primary\";\n"
"};\n"
msgstr ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_UP\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch primary\";\n"
"};\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2407
#, no-wrap
msgid ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_DOWN\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch secondary\";\n"
"};\n"
msgstr ""
"notify 30 {\n"
"\tmatch \"system\" \"IFNET\";\n"
"\tmatch \"subsystem\" \"carp0\";\n"
"\tmatch \"type\" \"LINK_DOWN\";\n"
"\taction \"/usr/local/sbin/carp-hast-switch secondary\";\n"
"};\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2412
msgid ""
"If the systems are running FreeBSD 10 or higher, replace [.filename]#carp0# "
"with the name of the CARP-configured interface."
msgstr ""
"시스템이 FreeBSD 10 이상을 실행하는 경우 [.filename]#carp0#을 CARP로 구성된 "
"인터페이스의 이름으로 바꿉니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2415
msgid ""
"Restart man:devd[8] on both nodes to put the new configuration into effect:"
msgstr "두 노드 모두에서 man:devd[8]를 재시작하여 새 구성을 적용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2419
#, no-wrap
msgid "# service devd restart\n"
msgstr "# service devd restart\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2423
msgid ""
"When the specified interface state changes by going up or down , the system "
"generates a notification, allowing the man:devd[8] subsystem to run the "
"specified automatic failover script, [.filename]#/usr/local/sbin/carp-hast-"
"switch#.  For further clarification about this configuration, refer to man:"
"devd.conf[5]."
msgstr ""
"지정된 인터페이스 상태가 위 또는 아래로 이동하여 변경되면 시스템은 알림을 "
"생성하여 man:devd[8] 서브시스템이 지정된 자동 장애조치 스크립트인 [."
"filename]#/usr/local/sbin/carp-hast-switch#를 실행할 수 있도록 합니다.  이 "
"구성에 대한 자세한 설명은 man:devd.conf[5]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2425
msgid "Here is an example of an automated failover script:"
msgstr "다음은 자동화된 장애 조치 스크립트의 예입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2429
#, no-wrap
msgid "#!/bin/sh\n"
msgstr "#!/bin/sh\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2433
#, no-wrap
msgid ""
"# Original script by Freddie Cash <fjwcash@gmail.com>\n"
"# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>\n"
"# and Viktor Petersson <vpetersson@wireload.net>\n"
msgstr ""
"# Original script by Freddie Cash <fjwcash@gmail.com>\n"
"# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>\n"
"# and Viktor Petersson <vpetersson@wireload.net>\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2436
#, no-wrap
msgid ""
"# The names of the HAST resources, as listed in /etc/hast.conf\n"
"resources=\"test\"\n"
msgstr ""
"# The names of the HAST resources, as listed in /etc/hast.conf\n"
"resources=\"test\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2440
#, no-wrap
msgid ""
"# delay in mounting HAST resource after becoming primary\n"
"# make your best guess\n"
"delay=3\n"
msgstr ""
"# delay in mounting HAST resource after becoming primary\n"
"# make your best guess\n"
"delay=3\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2444
#, no-wrap
msgid ""
"# logging\n"
"log=\"local0.debug\"\n"
"name=\"carp-hast\"\n"
msgstr ""
"# logging\n"
"log=\"local0.debug\"\n"
"name=\"carp-hast\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2446
#, no-wrap
msgid "# end of user configurable stuff\n"
msgstr "# end of user configurable stuff\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2451
#, no-wrap
msgid ""
"case \"$1\" in\n"
"\tprimary)\n"
"\t\tlogger -p $log -t $name \"Switching to primary provider for ${resources}.\"\n"
"\t\tsleep ${delay}\n"
msgstr ""
"case \"$1\" in\n"
"\tprimary)\n"
"\t\tlogger -p $log -t $name \"Switching to primary provider for ${resources}."
"\"\n"
"\t\tsleep ${delay}\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2457
#, no-wrap
msgid ""
"\t\t# Wait for any \"hastd secondary\" processes to stop\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\twhile $( pgrep -lf \"hastd: ${disk} \\(secondary\\)\" > /dev/null 2>&1 ); do\n"
"\t\t\t\tsleep 1\n"
"\t\t\tdone\n"
msgstr ""
"\t\t# Wait for any \"hastd secondary\" processes to stop\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\twhile $( pgrep -lf \"hastd: ${disk} \\(secondary\\)\" > /dev/null 2>&1 "
"); do\n"
"\t\t\t\tsleep 1\n"
"\t\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2465
#, no-wrap
msgid ""
"\t\t\t# Switch role for each disk\n"
"\t\t\thastctl role primary ${disk}\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to change role to primary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"
msgstr ""
"\t\t\t# Switch role for each disk\n"
"\t\t\thastctl role primary ${disk}\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to change role to primary for "
"resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2472
#, no-wrap
msgid ""
"\t\t# Wait for the /dev/hast/* devices to appear\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tfor I in $( jot 60 ); do\n"
"\t\t\t\t[ -c \"/dev/hast/${disk}\" ] && break\n"
"\t\t\t\tsleep 0.5\n"
"\t\t\tdone\n"
msgstr ""
"\t\t# Wait for the /dev/hast/* devices to appear\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tfor I in $( jot 60 ); do\n"
"\t\t\t\t[ -c \"/dev/hast/${disk}\" ] && break\n"
"\t\t\t\tsleep 0.5\n"
"\t\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2478
#, no-wrap
msgid ""
"\t\t\tif [ ! -c \"/dev/hast/${disk}\" ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"GEOM provider /dev/hast/${disk} did not appear.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"
msgstr ""
"\t\t\tif [ ! -c \"/dev/hast/${disk}\" ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"GEOM provider /dev/hast/${disk} did not "
"appear.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2480
#, no-wrap
msgid "\t\tlogger -p $log -t $name \"Role for HAST resources ${resources} switched to primary.\"\n"
msgstr ""
"\t\tlogger -p $log -t $name \"Role for HAST resources ${resources} switched "
"to primary.\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2487
#, no-wrap
msgid ""
"\t\tlogger -p $log -t $name \"Mounting disks.\"\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tmkdir -p /hast/${disk}\n"
"\t\t\tfsck -p -y -t ufs /dev/hast/${disk}\n"
"\t\t\tmount /dev/hast/${disk} /hast/${disk}\n"
"\t\tdone\n"
msgstr ""
"\t\tlogger -p $log -t $name \"Mounting disks.\"\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tmkdir -p /hast/${disk}\n"
"\t\t\tfsck -p -y -t ufs /dev/hast/${disk}\n"
"\t\t\tmount /dev/hast/${disk} /hast/${disk}\n"
"\t\tdone\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2489
#, no-wrap
msgid "\t;;\n"
msgstr "\t;;\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2492
#, no-wrap
msgid ""
"\tsecondary)\n"
"\t\tlogger -p $log -t $name \"Switching to secondary provider for ${resources}.\"\n"
msgstr ""
"\tsecondary)\n"
"\t\tlogger -p $log -t $name \"Switching to secondary provider for "
"${resources}.\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2510
#, no-wrap
msgid ""
"\t\t# Switch roles for the HAST resources\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tif ! mount | grep -q \"^/dev/hast/${disk} on \"\n"
"\t\t\tthen\n"
"\t\t\telse\n"
"\t\t\t\tumount -f /hast/${disk}\n"
"\t\t\tfi\n"
"\t\t\tsleep $delay\n"
"\t\t\thastctl role secondary ${disk} 2>&1\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to switch role to secondary for resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\t\tlogger -p $log -t $name \"Role switched to secondary for resource ${disk}.\"\n"
"\t\tdone\n"
"\t;;\n"
"esac\n"
msgstr ""
"\t\t# Switch roles for the HAST resources\n"
"\t\tfor disk in ${resources}; do\n"
"\t\t\tif ! mount | grep -q \"^/dev/hast/${disk} on \"\n"
"\t\t\tthen\n"
"\t\t\telse\n"
"\t\t\t\tumount -f /hast/${disk}\n"
"\t\t\tfi\n"
"\t\t\tsleep $delay\n"
"\t\t\thastctl role secondary ${disk} 2>&1\n"
"\t\t\tif [ $? -ne 0 ]; then\n"
"\t\t\t\tlogger -p $log -t $name \"Unable to switch role to secondary for "
"resource ${disk}.\"\n"
"\t\t\t\texit 1\n"
"\t\t\tfi\n"
"\t\t\tlogger -p $log -t $name \"Role switched to secondary for resource "
"${disk}.\"\n"
"\t\tdone\n"
"\t;;\n"
"esac\n"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2513
msgid ""
"In a nutshell, the script takes these actions when a node becomes primary:"
msgstr "간단히 말해, 스크립트는 노드가 일차 노드가 될 때 이러한 작업을 수행합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2515
msgid "Promotes the HAST pool to primary on the other node."
msgstr "다른 노드에서 HAST 풀을 일차 노드(Primary)로 승격합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2516
msgid "Checks the file system under the HAST pool."
msgstr "HAST 풀 아래의 파일 시스템을 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2517
msgid "Mounts the pool."
msgstr "풀을 마운트합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2519
msgid "When a node becomes secondary:"
msgstr "노드가 이차 노드(Secondary Node)가 되는 경우:"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2521
msgid "Unmounts the HAST pool."
msgstr "HAST 풀을 마운트 해제합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2522
msgid "Degrades the HAST pool to secondary."
msgstr "HAST 풀을 이차 노드로 강등합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2527
msgid ""
"This is just an example script which serves as a proof of concept.  It does "
"not handle all the possible scenarios and can be extended or altered in any "
"way, for example, to start or stop required services."
msgstr ""
"이것은 개념 증명을 위한 예시 스크립트일 뿐입니다.  가능한 모든 시나리오를 "
"처리하는 것은 아니며 필요한 서비스를 시작하거나 중지하는 등 어떤 방식으로든 "
"확장하거나 변경할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2533
msgid ""
"For this example, a standard UFS file system was used.  To reduce the time "
"needed for recovery, a journal-enabled UFS or ZFS file system can be used "
"instead."
msgstr ""
"이 예에서는 표준 UFS 파일 시스템을 사용했습니다.  복구에 필요한 시간을 "
"줄이려면 저널이 활성화된 UFS 또는 ZFS 파일 시스템을 대신 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2536
msgid ""
"More detailed information with additional examples can be found at http://"
"wiki.FreeBSD.org/HAST[http://wiki.FreeBSD.org/HAST]."
msgstr ""
"추가 예시와 함께 더 자세한 정보는 http://wiki.FreeBSD.org/HAST[http://wiki."
"FreeBSD.org/HAST]에서 확인할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/disks/_index.adoc:2537
#, no-wrap
msgid "Troubleshooting"
msgstr "문제 해결"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2542
msgid ""
"HAST should generally work without issues.  However, as with any other "
"software product, there may be times when it does not work as supposed.  The "
"sources of the problems may be different, but the rule of thumb is to ensure "
"that the time is synchronized between the nodes of the cluster."
msgstr ""
"HAST는 일반적으로 문제 없이 작동합니다.  그러나 다른 소프트웨어 제품과 "
"마찬가지로 예상대로 작동하지 않는 경우가 있을 수 있습니다.  문제의 원인은 "
"다양할 수 있지만, 일반적으로 클러스터의 노드 간에 시간이 동기화되어 있는지 "
"확인하는 것이 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2546
msgid ""
"When troubleshooting HAST, the debugging level of man:hastd[8] should be "
"increased by starting `hastd` with `-d`.  This argument may be specified "
"multiple times to further increase the debugging level.  Consider also using "
"`-F`, which starts `hastd` in the foreground."
msgstr ""
"HAST 문제를 해결할 때, `hastd`를 `-d`로 시작하여 man:hastd[8]의 디버깅 "
"레벨을 높여야 합니다.  이 인자는 디버깅 수준을 더 높이기 위해 여러 번 지정할 "
"수 있습니다.  또한 `hastd`를 포어 그라운드에서 시작하는 `-F`를 사용하는 것도 "
"고려하십시오."

#. type: Title ====
#: documentation/content/en/books/handbook/disks/_index.adoc:2548
#, no-wrap
msgid "Recovering from the Split-brain Condition"
msgstr "Split-brain 상태에서 복구하기"

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2553
msgid ""
"_Split-brain_ occurs when the nodes of the cluster are unable to communicate "
"with each other, and both are configured as primary.  This is a dangerous "
"condition because it allows both nodes to make incompatible changes to the "
"data.  This problem must be corrected manually by the system administrator."
msgstr ""
"_Split-brain_는 클러스터의 노드가 서로 통신할 수 없고 둘 다 일차 노드로 "
"구성되어 있을 때 발생합니다.  이 경우 두 노드 모두 데이터를 호환되지 않는 "
"방식으로 변경할 수 있으므로 위험한 상태입니다.  이 문제는 시스템 관리자가 "
"수동으로 수정해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/disks/_index.adoc:2557
msgid ""
"The administrator must either decide which node has more important changes, "
"or perform the merge manually.  Then, let HAST perform full synchronization "
"of the node which has the broken data.  To do this, issue these commands on "
"the node which needs to be resynchronized:"
msgstr ""
"관리자는 어느 노드에 더 중요한 변경 사항이 있는지 결정하거나 수동으로 병합을 "
"수행해야 합니다.  그런 다음 HAST가 손상된 데이터가 있는 노드에 대해 전체 "
"동기화를 수행하도록 합니다.  이렇게 하려면 다시 동기화해야 하는 노드에서 "
"다음 명령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/disks/_index.adoc:2563
#, no-wrap
msgid ""
"# hastctl role init test\n"
"# hastctl create test\n"
"# hastctl role secondary test\n"
msgstr ""
"# hastctl role init test\n"
"# hastctl create test\n"
"# hastctl role secondary test\n"
