---
description: 'FreeBSD 운영체제의 기능과 기본명령'
next: books/handbook/ports
part: '파트 I. 시작하기'
path: /books/handbook/
prev: books/handbook/bsdinstall
showBookMenu: 'true'
tags: ["basics", "virtual consoles", "users", "management", "permissions", "directory structure", "disk organization", "mounting", "processes", "daemons", "shell", "editor", "manual pages", "devices"]
title: '챕터 3. FreeBSD 기초'
weight: 5
---

[[basics]]
= FreeBSD 기초
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 3
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== 요약

이 챕터는 FreeBSD의 기능과 기본 명령어에 대해 설명합니다. 내용의 많은 부분이 UNIX(R)-like 운영체제와 연관되어 있습니다. FreeBSD를 처음 사용하는 사용자분들은 이 챕터를 주의깊게 읽어주세요.

이 챕터를 읽고 나면, 여러분은:

* 가상 콘솔을 설정하고 사용하는 법.
* FreeBSD에서 사용자 및 그룹을 생성하고 관리하는 법.
* UNIX(R) 파일 권한 및 FreeBSD에서의 파일 권한.
* FreeBSD의 기본 파일 시스템의 구조.
* FreeBSD 디스크 구성.
* 파일 시스템을 마운트하거나 언마운트하는 법.
* 프로세스와 데몬, 그리고 시그널(signal)의 의미.
* 셸(Shell)이 무엇인지와 기본 로그인 환경을 바꾸는 방법.
* 기본 텍스트 에디터를 사용하는 방법.
* 디바이스가 무엇이고 디바이스 노드는 무엇인지.
* 추가적인 정보를 위해 매뉴얼 페이지를 읽는 법.

[[consoles]]
== 가상 콘솔과 터미널

FreeBSD는 그래픽 환경으로 자동시작이 설정되어 있지 않은 경우, 이 예에서 보듯이 시스템은 명령줄 인터페이스(CLI, Command line interface)로 부팅됩니다:

[source, shell]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

첫 번째 줄에는 시스템에 대한 일부 정보가 포함되어 있습니다. 이 예시에서 'amd64'는 시스템이 64비트 버전의 FreeBSD를 실행하고 있음을 나타냅니다. 호스트 이름은 'pc3.example.org'이고 'ttyv0'는 현재 "시스템 콘솔"임을 나타냅니다. 두 번째 줄은 로그인 프롬프트입니다.

FreeBSD는 다중 사용자 시스템이므로 사용자를 구별할 수 있는 방법이 필요합니다. 이 방법으로 모든 사용자는 시스템의 프로그램에 액세스하기 전에 로그인을 해야 합니다. 모든 사용자는 고유한 "사용자 이름"과 개인 "비밀번호"를 가집니다.

시스템 콘솔에 로그인하려면 crossref:bsdinstall[bsdinstall-addusers, Add Users]의 설명에 따라 시스템 설치 중 설정한 사용자 이름을 입력하고 kbd:[Enter]를 칩니다. 그런 다음 사용자 이름과 연결된 암호를 입력하고 kbd:[Enter]를 칩니다. 보안상의 이유로 _암호는 보여지지 않습니다_.

올바른 암호를 입력 했다면 명령 프롬프트에 오늘의 메시지(MOTD)가 표시됩니다. 사용자가 생성될 때 선택한 셸에 따라 프롬프트에 `+#+`, `$`, 또는 `%` 문자가 표시됩니다. 이 프롬프트는 이제 사용자가 FreeBSD에 로그인했으며 명령어를 사용할 준비가 되었다는 뜻입니다.

[[consoles-virtual]]
=== 가상 콘솔

시스템 콘솔이 시스템과 상호작용을 하는 동안, 사용자는 일반적으로 가상 콘솔에 로그인하여 FreeBSD 시스템에 키보드로 명령을 입력하며 사용합니다. 기본적으로 이것은 시스템 메시지가 시스템 콘솔에 표시되도록 설정되어 있기 때문입니다. 이러한 메시지는 사용자가 작업중인 명령이나 파일의 위에 나타나므로 작업에 집중하기가 어렵습니다.

기본적으로 FreeBSD는 명령어 입력을 위해 위한 다수의 가상 콘솔을 제공하도록 설정되어 있습니다. 각 가상 콘솔에는 고유한 로그인 프롬프트와 셸이 있으며 가상 콘솔 간에 쉽게 전환할 수 있습니다. 이런 방식은 사용자에게 그래픽 환경 하에서 동시에 여러 개의 창을 열고 작업하는 것과 동등한 환경을 제공합니다.

가상 콘솔간의 전환을 위해 FreeBSD에서는 kbd:[Alt+F1]에서 kbd:[Alt+F8]까지의 키 조합을 미리 예약해 두었습니다. kbd:[Alt+F1]을 누르면 시스템 콘솔(`ttyv0`), kbd:[Alt+F2]는 `ttyv1`, kbd:[Alt+F3]은 `ttyv2`등으로 전환이 가능합니다. 그래픽 콘솔로 Xorg를 사용할 때에는, kbd:[Ctrl+Alt+F1]을 누르면 텍스트 기반의 가상 콘솔로 돌아갈 수 있습니다.

한 콘솔에서 다른 콘솔로 전환을 하면 FreeBSD는 화면을 바꿔서 표시해 줍니다. 그 결과 FreeBSD에서 작업을 할 때 마치 여러 화면과 키보드가 있는 것처럼 느껴지게 됩니다. 한 가상 콘솔에서 실행중인 프로그램은 사용자가 다른 가상 콘솔로 전환해도 실행이 중지되지 않습니다.

FreeBSD 콘솔의 보다 기술적인 부분과 키보드 드라이버 정보가 필요하시다면 man:kbdcontrol[1], man:vidcontrol[1], man:atkbd[4], man:syscons[4], 그리고 man:vt[4]를 참조해 주세요.

FreeBSD에서 사용 가능한 콘솔의 수는 `/etc/ttys`에서 설정할 수 있습니다:

[.programlisting]
....
# name    getty                         type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

가상 콘솔을 사용하지 않도록 설정하려면 설정의 가상 콘솔을 나타내는 줄 시작 부분에 `+#+`를 입력합니다. 예를 들어 사용 가능한 가상 콘솔의 수를 8개에서 4개로 줄이려면, 가상 콘솔 `ttyv5`에서 `ttyv8`을 나타내는 마지막 네 줄의 앞에 `+#+`를 붙입니다. 절대로 시스템 콘솔 `ttyv0`의 행을 _주석 처리하지_ 마십시오. crossref:x11[x11, The X Window System]에 설명된 대로 Xorg를 설치한 경우 마지막 가상 콘솔(`ttyv8`)은 그래픽 환경에 액세스하는 데 사용됩니다.

가상 콘솔의 사용가능한 옵션과 파일의 각각의 의미에 대한 추가적인 설명은 man:ttys[5]를 참조하세요.

[[consoles-singleuser]]
=== 단일 사용자 모드(Single User Mode)

FreeBSD 부팅 메뉴에는 “Boot Single User”이라고 표시된 옵션이 있습니다. 이 옵션을 선택하면 시스템이 "단일 사용자 모드"로 알려진 특수 모드로 부팅됩니다. 이 모드는 일반적으로 부팅되지 않는 시스템을 복구하거나 `root` 암호를 알 수 없을 때 암호를 재설정하기 위해 사용됩니다. 단일 사용자 모드에서는 네트워킹 및 기타 가상 콘솔을 사용할 수 없습니다. 그러나 시스템에 대한 전체 `root` 액세스는 가능하며 기본적으로 `root` 암호는 필요하지 않습니다. 이러한 이유로, 이 모드로 부팅하려면 물리적 키보드를 직접 사용할 수 있어야 하며, 누가 이 키보드에 접근할 수 있는지를 결정하는 것은 FreeBSD 시스템의 보안에서 반드시 고려해야 할 사항입니다.

단일 사용자 모드를 제어하는 설정은 `/etc/ttys`의 섹션에서 찾을 수 있습니다:

[.programlisting]
....
# name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

기본적으로 상태는 `secure`로 설정되어 있습니다. 이는 키보드에 물리적으로 액세스할 수 있는 사람이 중요하지 않거나 물리적 보안 정책에 의해 관리되고 있다고 가정합니다. 이 설정을 `insecure`로 변경하면 누구나 키보드에 액세스할 수 있으므로 안전하지 않은 환경이라고 가정합니다. 이 줄을 `insecure`로 변경하면, 사용자가 단일 사용자 모드로 부팅하도록 선택했을때 FreeBSD는 `root` 암호를 묻는 메시지를 표시합니다.

[NOTE]
====
_이 설정을 `insecure`로 변경할 때 주의하세요!_ `root` 암호를 잊어버린 경우에도 단일 사용자 모드로 부팅할 수 있지만, FreeBSD 부팅 프로세스에 익숙하지 않은 사람에게는 어려울 수 있습니다.
====

[[consoles-vidcontrol]]
=== 콘솔을 비디오 모드로 변경하기

FreeBSD 콘솔의 기본 비디오 모드는 1024x768, 1280x1024 또는 그래픽 칩과 모니터에서 지원하는 다른 해상도로 조정됩니다. 이 외의 비디오 모드를 사용하려면 `VESA` 모듈을 로드합니다:

[source, shell]
....
# kldload vesa
....

하드웨어에서 지원되는 비디오 모드를 확인하려면 man:vidcontrol[1]을 사용하세요. 지원되는 비디오 모드 목록을 얻으려면 다음을 실행합니다:

[source, shell]
....
# vidcontrol -i mode
....

이 명령은 하드웨어에서 지원하는 비디오 모드를 출력합니다. 새 비디오 모드를 선택하려면 `root` 사용자로 man:vidcontrol[1]을 사용하여 모드를 지정합니다:

[source, shell]
....
# vidcontrol MODE_279
....

새 비디오 모드를 사용할 수 있는 경우 `/etc/rc.conf`에 추가하여 부팅 시 영구적으로 변경할 수 있습니다:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== 사용자와 기본적인 계정관리

FreeBSD에서는 여러 사용자가 동시에 컴퓨터를 사용할 수 있습니다. 한 번에 한 명의 사용자만 화면 앞에 앉아 키보드를 사용할 수 있지만, 네트워크를 통해 얼마든지 많은 사용자가 시스템에 로그인할 수 있습니다. 시스템을 사용하려면 각각 사용자는 고유한 사용자 계정을 가지고 있어야 합니다.

이 챕터는 다음을 설명합니다:

* FreeBSD 시스템의 다양한 사용자 계정 유형.
* 사용자 계정을 추가, 삭제, 수정하는 방법.
* 사용자 및 그룹이 사용할 수 있는 리소스를 제한하기 위한 설정방법.
* 그룹을 생성하는 방법과 그룹에 사용자를 추가하는 방법.

[[users-introduction]]
=== 계정 유형

FreeBSD시스템에 대한 모든 액세스는 계정을 통해 이루어지고 모든 프로세스는 사용자에 의해 실행되기 때문에, 사용자 및 계정 관리가 중요합니다.

계정에는 시스템 계정(system accounts), 사용자 계정(user accounts), 수퍼유저 계정(superuser account)의 세 가지 유형이 있습니다.

[[users-system]]
==== 시스템 계정

시스템 계정은 DNS, 메일, 웹 서버와 같은 서비스를 실행하는 데 사용됩니다. 만약 모든 서비스가 수퍼유저로 실행되면 아무 제한 없이 동작할 수 있기 때문에 보안상의 이유로 계정이 존재합니다.

시스템 계정의 예로는 `daemon`,`operator`,`bind`,`news`,`www`가 있습니다.

`nobody`는 권한이 없는 일반적인(제너릭) 시스템 계정입니다. 그러나 `nobody` 계정을 사용하는 서비스가 많아질수록 `nobody` 사용자가 관여하는 파일과 프로세스가 많아지므로, 해당 사용자(`nobody`)는 더 많은 권한을 획득하게 됩니다.

[[users-user]]
==== 사용자 계정

사용자 계정은 실제 사람에게 할당되며 시스템에 로그인하고 사용하는 데 사용됩니다. 시스템에 액세스하는 모든 사람은 고유한 사용자 계정을 가져야 합니다. 이를 통해 관리자는 누가 어떤 작업을 하는지 파악할 수 있고 사용자가 다른 사용자의 설정을 변경하는 것을 방지할 수 있습니다.

각 사용자는 기본 쉘, 편집기, 단축기(key binding) 및 언어 설정을 구성하여 자신에게 맞게 시스템 환경을 설정할 수 있습니다.

FreeBSD의 모든 사용자 계정은 다음의 정보를 가지고 있습니다:

사용자 이름(User name)::
사용자 이름은 `login:` 프롬프트에 입력합니다. 각 사용자는 고유한 사용자 이름을 가져야 합니다. 유효한 사용자 이름을 만들기 위한 여러 가지 규칙이 있으며, 이 규칙은 man:passwd[5]에 문서화되어 있습니다. 애플리케이션과의 이전 버전과의 호환성을 유지하려면 모두 소문자로 구성된 8자 이하의 사용자 이름을 사용하는 것이 좋습니다.

Password::
각 계정은 암호를 가져야 합니다.

User ID (UID)::
사용자 ID(User ID, UID)는 FreeBSD 시스템에서 사용자를 고유하게 식별하는 데 사용되는 숫자입니다. 사용자 이름을 설정하는 명령은 가장먼저 사용자 이름을 UID로 변환합니다. UID의 값이 크면 일부 소프트웨어와 호환성 문제가 발생할 수 있으므로 65535 미만의 UID를 사용하는 것이 좋습니다.

Group ID (GID)::
그룹 ID(Group ID, GID)는 사용자가 속한 기본 그룹을 식별하는 데 사용되는 고유번호입니다. 그룹은 사용자의 UID가 아닌 GID를 기반으로 리소스에 대한 액세스를 제어하기 위한 메커니즘입니다. 이를 통해 일부 구성 파일의 크기를 크게 줄일 수 있으며, 사용자는 둘 이상의 그룹 멤버가 될 수 있습니다. GID역시 그 값이 너무 크면 일부 소프트웨어에서 문제가 발생할 수 있으므로 65535 이하의 GID를 사용하는 것이 좋습니다.

Login class::
로그인 클래스(Login class)는 그룹 메커니즘의 확장으로, 다양한 사용자에 맞게 시스템을 조정할 때 추가적인 유연성을 제공합니다. 로그인 클래스에 대한 자세한 내용은 crossref:security[사용자-제한,로그인 클래스 구성]에서 확인할 수 있습니다.

패스워드 변경 시기(Password change time)::
기본적으로 비밀번호는 만료시기가 없습니다. 그러나 사용자별 비밀번호 만료시기를 설정하면 일정 시간이 경과했을 때, 일부 또는 모든 사용자가 비밀번호를 변경하도록 할 수 있습니다.

계정 만료 시기(Account expiration time)::
기본적으로 FreeBSD는 계정의 만료시기가 없습니다. 하지만 학교의 학생 계정과 같이 수명을 제한해야 하는 계정을 만들 때는 man:pw[8]을 사용하여 계정 만료 시기를 지정할 수 있습니다. 만료 시기가 지나면 계정의 디렉터리와 파일은 남아있지만 시스템에 로그인하거나 계정을 사용할 수 없습니다.

사용자 성명(User's full name)::
FreeBSD의 사용자 이름(user name)은 사용자를 식별하는데 사용되지만, 사용자의 실명을 의미하지는 않습니다. 이 정보는 추가정보와 마찬가지로 공백과 대문자를 포함할 수 있으며 8자 이상이어야 합니다.

홈 디렉터리::
홈 디렉터리는 시스템에서 디렉터리의 전체 경로입니다. 이것은 로그인을 했을때 사용자가 접근하는 시작 디렉터리입니다. 일반적인 규칙은 모든 사용자 홈 디렉터리를 `/home/username` 또는 `/usr/home/username` 아래에 배치하는 것입니다. 각 사용자는 자신의 홈 디렉터리에 개인 파일과 하위 디렉터리를 저장합니다.

사용자 쉘(User shell)::
쉘은 시스템과 상호 작용하기 위한 사용자의 기본 환경을 제공합니다. 쉘에는 다양한 종류가 있으며 숙련된 사용자는 계정 설정에 반영할 수 있는 자신만의 기본 설정을 할 수 있습니다.

[[users-superuser]]
==== 수퍼유저 계정(Superuser Account)

일반적으로 `root`로 알려진 수퍼유저 계정은 권한에 제한 없이 시스템을 관리하는 데 사용됩니다. 따라서 메일 송수신, 시스템의 일반적인 탐색 또는 프로그래밍과 같은 일상적인 작업에는 사용해서는 안 됩니다.

다른 사용자 계정과 달리 수퍼유저는 어떤 제한도 없으며, 수퍼유저 계정을 오용하면 큰 재앙을 초래할 수 있습니다. 사용자 계정은 실수로라도 운영 체제를 파괴할 수 없으므로 평상시에는 사용자 계정으로 로그인하고 추가 권한이 필요한 명령에 대해서만 수퍼유저를 사용하는 것을 권장합니다.

단순한 공백이나 문자의 누락으로도 복구할 수 없는 데이터 손실이 발생할 수 있으므로 수퍼유저로서 실행하는 모든 명령은 항상 두 번, 세 번 확인합니다.

수퍼유저 권한을 얻는 방법에는 여러 가지가 있습니다. `root`로 로그인할 수도 있지만 좋은 방법은 아닙니다.

대신 man:su[1]를 사용하여 수퍼유저가 될 수 있습니다. 이 명령을 실행할 때 `-`를 지정하면 해당 사용자는 루트 사용자의 환경도 상속받습니다. 이 명령을 실행하는 사용자는 `wheel` 그룹에 속해야 하며 그렇지 않으면 명령이 실패합니다. 또한 사용자는 `root` 사용자 계정의 비밀번호를 알고 있어야 합니다.

이 예에서는 `make install`을 실행하기 위해 수퍼유저 권한이 필요하므로 사용자는 이 명령을 실행할 때만 수퍼유저가 됩니다. 명령이 완료되면 사용자는 `exit`를 입력하여 수퍼유저 계정을 종료하고 사용자 계정의 권한으로 돌아갑니다.

.수퍼유저로 프로그램 설치하기
[example]
====
[source, shell]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....
====

기본 제공되는 man:su[1] 프레임워크는 시스템 관리자가 한 명뿐인 단일 시스템 또는 소규모 네트워크에 적합합니다. 다른 방법으로는 package:security/sudo[] 패키지 또는 포트(port)를 설치하는 것입니다. 이 소프트웨어는 활동 로그(Activity log)를 제공하고 관리자가 수퍼유저로서 어떤 사용자가 어떤 명령을 실행할 수 있는지 구성할 수 있습니다.

[[users-modifying]]
=== 계정 관리하기

FreeBSD는 사용자 계정을 관리하기 위한 다양한 명령어를 제공합니다. 가장 일반적인 명령은 <<users-modifying-utilities>>에 요약되어 있고, 몇 가지 사용 예가 나와 있습니다. 자세한 내용과 사용 예는 각 유틸리티의 매뉴얼 페이지를 참조하십시오.

[[users-modifying-utilities]]
.사용자 계정 관리를 위한 유틸리티
[cols="25h,~"]
|===
| Command
| Summary

|man:adduser[8]
|The recommended command-line application for adding new users.

|man:rmuser[8]
|The recommended command-line application for removing users.

|man:chpass[1]
|A flexible tool for changing user database information.

|man:passwd[1]
|The command-line tool to change user passwords.

|man:pw[8]
|A powerful and flexible tool for modifying all aspects of user accounts.

|man:bsdconfig[8]
|A system configuration utility with account management support.
|===

[[users-adduser]]
==== 사용자 추가하기

새 사용자를 추가하는 데 권장되는 프로그램은 man:adduser[8]입니다. 새 사용자가 추가되면 이 프로그램은 자동으로 `/etc/passwd`와 `/etc/group`을 업데이트합니다. 또한 새 사용자를 위한 홈 디렉터리를 생성하고, `/usr/share/skel`의 기본 구성 파일을 복사하며, 경우에 따라 새 사용자에게 환영 메시지를 메일로 보낼 수 있습니다. 이 유틸리티는 수퍼유저로 실행해야 합니다.

Man:adduser[8]는 대화형 유틸리티이며 새 사용자 계정을 만드는 단계를 안내합니다. <<users-modifying-adduser>>에서 볼 수 있듯이 필요한 정보를 직접 입력하거나 kbd:[Return]을 눌러 대괄호 안에 표시된 기본값을 입력합니다. 이 예제에서는 사용자가 'wheel' 그룹에 초대되어 man:su[1]를 가진 수퍼유저가 될 수 있습니다. 완료되면 유틸리티는 또 다른 사용자를 만들지 종료할지 묻습니다.

[[users-modifying-adduser]]
.FreeBSD에서 사용자 추가하기
[example]
====
[source, shell]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
....
====

[NOTE]
====
비밀번호를 입력할 때는 화면에 아무것도 출력되지 않으므로, 사용자 계정을 만들 때 비밀번호를 잘못 입력하지 않도록 주의해야 합니다.
====

[[users-rmuser]]
==== 사용자 삭제하기

시스템에서 사용자를 완전히 삭제하려면 수퍼유저로 man:rmuser[8]를 실행합니다. 이 명령은 다음 단계를 수행합니다:

[.procedure]
====
. 사용자의 man:crontab[1] 항목이 있는 경우 해당 항목을 제거합니다.
. 사용자에 속한 모든 man:at[1] 작업을 제거합니다.
. 사용자가 소유한 모든 프로세스에 SIGKILL 신호를 보냅니다.
. 시스템의 로컬 비밀번호 파일에서 사용자를 삭제합니다.
. 실제 홈 디렉터리 경로를 나타내는 심볼릭 링크 뿐만 아니라 사용자의 홈 디렉터리(사용자가 소유하고 있는 경우)를 삭제합니다.
. `/var/mail`에서 사용자 소유의 받은 메일 파일을 제거합니다.
. 사용자가 소유하고 있는 `tmp`, `/var/tmp` 및 `/var/tmp/vi.recover`의 모든 파일을 삭제합니다.
. `/etc/group`에 있는 모든 그룹에서 사용자 이름을 삭제합니다. (만약 이 과정으로 그룹이 비게 되거나 그룹의 이름이 사용자 이름과 같으면 그룹 자체가 삭제되며, 이는 man:adduser[8]로 고유 그룹을 가진 단일 사용자 문제를 보완합니다.)
. 사용자가 소유한 모든 메시지 큐(message queue), 공유 메모리 세그먼트 및 세마포어(semaphore)를 제거합니다.
====

man:rmuser[8]를 사용하여 수퍼유저 계정을 제거할 수는 없는데, 이것은 거의 항상 대규모 파괴를 의미하기 때문입니다.

기본적으로 다음 예시와 같이 대화형 모드가 사용됩니다.

.`rmuser`대화형 계정삭제
[example]
====
[source, shell]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user’s home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
....
====

[[users-chpass]]
==== 사용자 정보 변경하기

모든 사용자는 man:chpass[1]를 사용하여 기본 셸과 사용자 계정과 관련된 개인 정보를 변경할 수 있습니다. 수퍼유저는 이 유틸리티를 사용하여 모든 사용자의 추가 계정 정보를 변경할 수 있습니다.

사용자 이름(username) 외에 다른 옵션을 전달하지 않으면 man:chpass[1]는 사용자 정보가 포함된 편집기를 표시합니다. 사용자가 편집기를 종료하면 사용자 데이터베이스가 새 정보로 업데이트됩니다.

[NOTE]
====
이 유틸리티는 수퍼유저로 실행하지 않는 한 편집기를 종료할 때 사용자의 비밀번호를 묻는 메시지가 나타납니다.
====

<<users-modifying-chpass-su>>에서 수퍼유저가 `chpass jru`를 입력했으면 이제 이 사용자에 대해 변경할 수 있는 필드를 볼 수 있습니다. 만약 `jru`가 이 명령을 대신 실행하면 마지막 6개 필드만 표시되고 편집이 가능해집니다. 이는 <<users-modifying-chpass-ru>>에서 설명합니다.

[[users-modifying-chpass-su]]
.수퍼유저로 `chpass` 사용
[example]
====
[source, shell]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[[users-modifying-chpass-ru]]
.일반 사용자로 `chpass` 사용
[example]
====
[source, shell]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[NOTE]
====
Man:chfn[1] 및 man:chsh[1] 명령은 man:ypchpass[1], man:ypchfn[1] 및 man:ypchsh[1]와 마찬가지로 man:chpass[1]에 대한 링크입니다. NIS 지원은 자동으로 이루어지므로 명령 앞에 `yp`를 지정할 필요가 없습니다. NIS를 구성하는 방법은 crossref:network-servers[network-servers,Network Servers]에 설명되어 있습니다.
====

[[users-passwd]]
==== 사용자 비밀번호 변경

모든 사용자는 man:passwd[1]를 사용하여 쉽게 비밀번호를 변경할 수 있습니다. 실수나 무단 변경을 방지하기 위해 이 명령은 새 비밀번호를 설정하기 전에 사용자의 기존 비밀번호를 묻는 메시지를 표시합니다:

.비밀번호 변경하기
[example]
====
[source, shell]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database…
passwd: done
....
====

수퍼유저는 man:passwd[1]를 실행할 때 사용자 아이디를 지정하여 모든 사용자의 비밀번호를 변경할 수 있습니다. 이 유틸리티가 수퍼유저로 실행되면 사용자의 현재 비밀번호를 묻는 메시지가 표시되지 않습니다. 따라서 사용자가 원래 비밀번호를 기억하지 못할 때 비밀번호를 변경할 수 있습니다.

.수퍼유저로 다른 사용자의 비밀번호 변경하기
[example]
====
[source, shell]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database…
passwd: done
....
====

[NOTE]
====
Man:chpass[1]과 마찬가지로 man:yppasswd[1]는 man:passwd[1]에 대한 링크이므로 NIS는 두 명령 모두에서 작동합니다.
====

[[users-pw]]
==== 시스템 사용자 및 그룹의 생성, 삭제, 수정 및 표시

Man:pw[8] 유틸리티는 사용자와 그룹을 생성, 삭제, 수정 및 표시할 수 있습니다. 이 유틸리티는 시스템 사용자 및 그룹 파일에 대한 프런트 엔드 역할을 합니다. man:pw[8]에는 셸 스크립트에서 사용하기에 적합한 매우 강력한 명령줄 옵션이 있지만 신규 사용자는 이 섹션에 제시된 다른 명령보다 더 복잡하다고 느낄 수 있습니다.

[[users-groups]]
=== 그룹 관리하기

그룹은 사용자의 목록입니다. 그룹은 그룹 이름과 GID로 식별됩니다. FreeBSD에서 커널은 프로세스의 UID와 프로세스가 속한 그룹 목록을 사용하여 프로세스가 수행할 수 있는 작업을 결정합니다. 대부분의 경우, 사용자나 프로세스의 GID는 일반적으로 목록에서 나열된 첫 번째 그룹을 의미합니다.

GID에 대한 그룹 이름의 매핑은 `/etc/group`에 기록되어 있습니다. 이 파일은 콜론으로 구분된 4개의 필드가 있는 일반 텍스트 파일입니다. 첫 번째 필드는 그룹 이름, 두 번째 필드는 암호화된 비밀번호, 세 번째 필드는 GID, 네 번째 필드는 쉼표로 구분된 멤버 목록입니다. 이 문법에 대한 자세한 설명은 man:group[5]을 참조하세요.

수퍼유저는 텍스트 편집기를 사용하여 `/etc/group`을 수정할 수 있지만, 일반적인 실수를 확인 받을 수 있으므로 man:vigr[8]을 사용하여 그룹 파일을 편집하는 것이 좋습니다. 다른 방법으로는 man:pw[8]를 사용하여 그룹을 추가하고 편집할 수 있습니다. 예를 들어, `teamtwo`라는 그룹을 추가한 다음 그룹이 있는지 확인합니다:

[WARNING]
====
Operator 그룹을 사용할 때는 의도하지 않은 수퍼유저 수준의 접근 권한이 부여될 수 있으므로 주의해야 하며, 여기에는 종료, 재부팅, 그룹내 `/dev`에 있는 모든 항목에 대한 접근 권한이 포함될 수 있습니다.
====

.Man:pw[8]를 사용하여 그룹 추가하기
[example]
====
[source, shell]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....
====

이 예에서 `1100`은 `teamtwo`의 GID입니다. 현재 `teamtwo`에는 멤버가 없습니다. 다음 명령은 `jru`를 `teamtwo`의 멤버로 추가합니다.

.Man:pw[8]을 사용하여 새 그룹에 사용자 계정 추가하기
[example]
====
[source, shell]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....
====

`-M` 인수는 새로운(비어 있는) 그룹에 사용자를 추가하거나 추가하거나 기존 그룹의 구성원을 바꿀때 쉼표로 구분된 사용자 목록과 함께 사용합니다. 사용자에게 이 그룹 멤버십은 비밀번호 파일에 기록된 사용자의 기본 그룹과 다릅니다. 즉, man:pw[8]과 함께 `groupshow`를 사용할 때는 사용자가 멤버로 표시되지 않지만, man:id[1] 또는 유사한 도구를 통해 정보를 쿼리할 때는 표시됩니다. Man:pw[8]는 그룹에 사용자를 추가할 때, `/etc/group`만 조작하고 `/etc/passwd`에서 추가 데이터를 읽으려고 시도하지 않습니다.

.Man:pw[8]를 사용하여 그룹에 새 멤버 추가하기
[example]
====
[source, shell]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....
====

이 예에서 `-m`의 인수는 그룹에 추가할 사용자를 쉼표로 구분하여 작성합니다. 이전 예와 달리 이러한 사용자는 그룹에 추가만 되며 그룹의 기존 사용자를 대체하지 않습니다.

.Man:id[1]를 사용하여 그룹 멤버십 결정하기
[example]
====
[source, shell]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....
====

이 예에서 `jru`는 그룹 `jru` 및 `teamtwo`의 구성원입니다.

이 명령과 `/etc/group`의 형식에 대한 자세한 내용은 man:pw[8] 및 man:group[5]을 참조하세요.

[[permissions]]
== 권한

FreeBSD에서는 모든 파일과 디렉터리에는 관련된 권한 집합이 있으며, 이러한 권한을 보고 수정하는 데 사용할 수 있는 여러 유틸리티가 있습니다. 사용자가 자신이 필요한 파일에 액세스할 수 있고 운영 체제에서 사용하거나 다른 사용자가 소유한 파일에 부적절하게 액세스할 수 없도록 하려면 권한이 어떻게 작동하는지 이해하는 것이 필요합니다.

이 섹션에서는 FreeBSD에서 사용되는 전통적인 UNIX(R) 권한에 대해 설명합니다. 더 세분화된 파일 시스템 접근 제어에 대해서는 crossref:security[fs-acl,Access Control Lists]을 참조하세요.

UNIX(R)에서는 읽기, 쓰기, 실행의 세 가지 액세스 유형을 사용하여 기본 권한이 할당됩니다. 이러한 액세스 유형은 파일의 소유자, 그룹 및 기타(다른 모든 사람)에 대한 파일 액세스를 결정하는 데 사용됩니다. 읽기, 쓰기 및 실행 권한은 문자 `r`, `w` 및 `x`로 표시할 수 있습니다. 각 권한이 켜져 있거나 꺼져 있는 것(`0`)은 이진 숫자로도 나타낼 수 있습니다. 숫자로 표현할 때 순서는 항상 `rwx`로 읽으며, 여기서 `r`은 켜짐 값 `4`, `w`는 켜짐 값 `2`, `x`는 켜짐 값 `1`을 갖습니다.

표 4.1은 가능한 숫자 및 알파벳 조합을 요약한 것입니다. "디렉터리 목록”의 열을 읽을 때 `-`는 꺼짐으로 설정된 권한을 나타내는 데 사용됩니다.

.UNIX(R) 권한
[cols="1,1,1", frame="none", options="header"]
|===
| Value
| Permission
| Directory Listing

|0
|No read, no write, no execute
|`---`

|1
|No read, no write, execute
|`--x`

|2
|No read, write, no execute
|`-w-`

|3
|No read, write, execute
|`-wx`

|4
|Read, no write, no execute
|`r--`

|5
|Read, no write, execute
|`r-x`

|6
|Read, write, no execute
|`rw-`

|7
|Read, write, execute
|`rwx`
|===

Man:ls[1]과 함께 `-l` 인수를 사용하면 소유자, 그룹 및 다른 모든 사용자에 대한 파일의 권한에 대한 정보 열이 포함된 긴 디렉터리 목록을 볼 수 있습니다. 예를 들어 임의의 디렉터리에서 `ls -l`을 사용하면:

[source, shell]
....
% ls -l
total 530
-rw-r—r—  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r—r—  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r—r—  1 root  wheel    7680 Sep  5 12:31 email.txt
....

`myfile` 줄의 첫 번째 `(가장 왼쪽)` 문자는 이 파일이 일반 파일인지, 디렉토리인지, 특수 문자 장치인지, 소켓인지, 그외의 특수 의사-파일 장치인지를 나타냅니다. 이 예에서 `-`는 일반 파일을 나타냅니다. 이 예의 다음 세 문자 `rw-`는 파일 소유자에 대한 권한을 보여줍니다. 다음 세 문자 `r--`은 파일이 속한 그룹에 대한 권한을 보여줍니다. 마지막 세 문자 `r--`은 나머지 모든 사용자에 대한 권한을 보여줍니다. “-“는 해당 권한이 꺼져 있음을 의미합니다. 이 예에서는 소유자는 파일을 읽고 쓸 수 있고, 그룹은 파일을 읽을 수 있으며, 나머지 사용자들은 파일을 읽기만 할 수 있도록 권한이 설정되어 있습니다. 위의 표에 따르면 이 파일의 권한은 '644'이며, 각 숫자는 파일 권한의 세 부분을 나타냅니다.

시스템은 장치에 대한 권한을 어떻게 제어할까요? FreeBSD는 거의 모든 하드웨어 장치를 프로그램이 데이터를 열고, 읽고, 쓸 수 있는 파일로 취급합니다. 이러한 특수 장치 파일은 `/dev/`에 저장됩니다.

디렉터리도 파일로 취급됩니다. 디렉터리에는 읽기, 쓰기, 실행 권한이 있습니다. 디렉토리의 실행 가능 비트(“x”)는 파일과 약간 다른 의미를 가집니다. 디렉터리가 실행 가능으로 표시되면 man:cd[1]를 사용하여 해당 디렉터리로 이동할 수 있다는 뜻입니다. 이는 또한 파일 자체(디렉터리를 말함)에 대한 권한에 따라 해당 디렉터리 내의 파일에 액세스할 수 있음을 의미합니다.

디렉터리내의 목록을 확인하려면 해당 디렉터리에 읽기 권한이 설정되어 있어야 합니다. 또한 이름을 알고 있는 파일을 삭제하려면 해당 파일이 포함된 디렉터리에 대한 쓰기 권한과 실행 권한이 있어야 합니다.

더 많은 권한 비트방식이 있지만 주로 setuid 바이너리 및 고정 디렉터리(sticky directory)와 같은 특수한 상황에서 사용됩니다. 파일 권한 및 설정 방법에 대한 자세한 내용은 man:chmod[1]를 참조하세요.

=== 심볼릭 권한

심볼릭 권한은 8진수 값 대신 문자를 사용하여 파일 또는 디렉터리에 권한을 할당합니다. 기호 권한은 (who) (action) (permissions) 구문을 사용하여 명령을 작성합니다:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Option
| Letter
| Represents

|(who)
|u
|User

|(who)
|g
|Group owner

|(who)
|o
|Other

|(who)
|a
|All ("world")

|(action)
|+
|Adding permissions

|(action)
|-
|Removing permissions

|(action)
|=
|Explicitly set permissions

|(permissions)
|r
|Read

|(permissions)
|w
|Write

|(permissions)
|x
|Execute

|(permissions)
|t
|Sticky bit

|(permissions)
|s
|Set UID or GID
|===

이 값은 man:chmod[1]와 함께 사용되지만 숫자 대신 문자를 사용합니다. 예를 들어, 다음 명령은 _FILE_과 연결된 그룹의 구성원과 다른 모든 사용자가 _FILE_에 액세스하지 못하도록 차단합니다:

[source, shell]
....
% chmod go= FILE
....

파일을 두 개 이상 변경해야 하는 경우 쉼표로 구분된 목록을 사용할 수 있습니다. 예를 들어 다음 명령은 _FILE_에 대한 그룹 구성원 및 다른 모두의 쓰기 권한을 제거하고 모든 사용자에 대한 실행 권한을 추가합니다:

[source, shell]
....
% chmod go-w,a+x FILE
....

=== FreeBSD 파일 플래그

파일 권한 외에도 FreeBSD는 "파일 플래그" 기능을 지원합니다. 이 플래그는 디렉토리를 제외한 파일에 대한 보안과 제어 수준을 추가합니다. 파일 플래그를 사용하면 `root`도 파일을 제거하거나 변경하지 못하게 할 수 있습니다.

파일 플래그는 man:chflags[1]을 사용하여 수정합니다. 예를 들어, `file1` 파일에 시스템 삭제 불가 플래그를 활성화하려면 다음 명령을 실행합니다:

[source, shell]
....
# chflags sunlink file1
....

시스템 삭제 불가 플래그를 비활성화하려면 `sunlink` 앞에 “no”를 추가합니다:

[source, shell]
....
# chflags nosunlink file1
....

파일의 플래그를 보려면 man:ls[1]와 함께 `-lo`를 사용합니다:

[source, shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r—r—  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

몇몇 파일 플래그는 `root` 사용자만 추가하거나 제거할 수 있습니다. 그 외의 경우에는 파일 소유자가 파일 플래그를 설정할 수 있습니다. 자세한 내용은 man:chflags[1] 와 man:chflags[2]를 참조하세요.

=== Setuid, setgid 및 sticky 권한

이미 설명한 권한 외에도 모든 관리자가 알아야 할 세 가지 특수 설정이 있습니다. `setuid`, `setgid`, `sticky` 권한이 바로 그것입니다.

이러한 설정은 일반 사용자에게 일반적으로 부여되지 않는 기능을 제공하므로 몇가지 UNIX(R) 작업에서 중요합니다. 이를 이해하려면 실제 사용자 ID와 유효 사용자 ID의 차이점을 알아야 합니다.

실제 사용자 ID는 프로세스를 소유하거나 시작하는 UID입니다. 유효 UID는 프로세스가 실행되는 사용자 ID입니다. 예를 들어, 사용자가 비밀번호를 변경할 때 man:passwd[1]는 실제 사용자 ID로 실행됩니다. 그러나 비밀번호 데이터베이스를 업데이트하기 위해 이 명령은 `root` 사용자의 유효 ID로 실행됩니다. 따라서 사용자는 `Permission Denied` 오류를 보지 않고 비밀번호를 변경할 수 있습니다.

다음 예제에서와 같이 사용자에 대한 `s` 권한을 추가하여 상징적으로 setuid 권한을 추가할 수 있습니다:
 
[source, shell]
....
# chmod u+s suidexample.sh
....

다음 예와 같이 권한 집합 앞에 숫자 4를 붙여서 setuid 권한을 설정할 수도 있습니다:

[source, shell]
....
# chmod 4755 suidexample.sh
....

이제 `suidexample.sh`에 대한 권한은 다음과 같이 표시됩니다:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

이제 `s`가 파일 소유자에게 지정된 권한 집합의 일부가 되어 실행 비트를 대체합니다. 이제 man:passwd[1]와 같이 상승된 권한이 필요한 유틸리티를 사용할 수 있습니다.

[NOTE]
====
`nosuid` man:mount[8] 옵션을 사용하면 이러한 바이너리가 사용자에게 표시되지 않고 자동으로 실패합니다. 이 옵션은 `nosuid` 래퍼가 이를 우회할 수 있으므로 완전히 신뢰할 수 없습니다.
====

이를 실시간으로 보려면 두 개의 터미널을 엽니다. 한 터미널에서 일반 사용자로 `passwd`를 입력합니다. 새 비밀번호를 기다리는 동안 다른 터미널에서 프로세스 테이블을 확인하여 man:passwd[1]에 대한 사용자 정보를 확인합니다:

터미널 A:

[source, shell]
....
Changing local password for trhodes
Old Password:
....

터미널 B:

[source, shell]
....
# ps aux | grep passwd
....

[source, shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Man:passwd[1]는 일반 사용자로 실행되었지만, `root`의 유효 UID를 사용하고 있는 것을 알 수 있습니다.

`setgid` 권한은 그룹의 권한설정을 변경한다는 점을 제외하면 `setuid` 권한과 동일한 기능을 수행합니다. 이 설정으로 애플리케이션 또는 유틸리티를 실행하면 프로세스를 시작한 사용자가 아닌 파일을 소유한 그룹에 맞춰 권한이 부여됩니다.

파일에 `setgid` 권한을 상징적으로 설정하려면 man:chmod[1]로 그룹에 대한 `s` 권한을 추가합니다:

[source, shell]
....
# chmod g+s sgidexample.sh
....
 
또는 man:chmod[1]에 앞의 두 개(2)를 입력합니다:

[source, shell]
....
# chmod 2755 sgidexample.sh
....

다음 목록에서 이제 그룹 권한 필드에 's'가 있는 것을 확인할 수 있습니다:

[source, shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
이 예제에서는 문제의 셸 스크립트가 실행 파일이지만 다른 EUID 또는 유효 사용자 ID로 실행되지 않습니다. 이는 셸 스크립트가 man:setuid[2] 시스템 호출에 액세스할 수 없기 때문입니다.
====

`setuid` 및 `setgid` 권한 비트는 높은 수준의 권한을 허용하여 시스템 보안을 낮출 수 있습니다. 세 번째 특수 권한인 `sticky bit`는 시스템 보안을 강화할 수 있습니다.

디렉터리에 `sticky bit`가 설정되어 있으면 파일 소유자만 파일을 삭제할 수 있습니다. 이는 파일을 소유하지 않은 사용자가 `/tmp`와 같은 공용 디렉터리에서 파일을 삭제하는 것을 방지하는 데 유용합니다. 이 권한을 사용하려면 파일에 `t` 모드를 추가합니다:

[source, shell]
....
# chmod +t /tmp
....

또는 권한 집합 앞에 숫자 1(1)을 붙입니다:

[source, shell]
....
# chmod 1777 /tmp
....

`sticky bit` 권한은 권한 집합의 맨 끝에 't'로 표시됩니다:

[source, shell]
....
# ls -al / | grep tmp
....

[source, shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== 디렉터리 구조

FreeBSD 디렉터리 계층 구조는 시스템에 대한 전반적인 이해를 얻기 위한 기본입니다. 가장 중요한 디렉터리는 루트 또는 "/"입니다. 이 디렉터리는 부팅 시 가장 먼저 마운트되는 디렉터리로, 다중 사용자 환경을 위해 운영 체제를 준비하는 데 필요한 기본 시스템을 포함합니다. 루트 디렉터리에는 다중 사용자 환경으로 전환하는 동안 마운트되는 다른 파일 시스템에 대한 마운트 지점도 포함되어 있습니다.

마운트 지점은 상위 파일 시스템(일반적으로 루트 파일 시스템)에 추가 파일 시스템을 연결할 수 있는 디렉터리입니다. 이에 대한 자세한 설명은 <<disk-organization>>에서 확인할 수 있습니다. 표준 마운트 포인트에는 `/usr/`, `/var/`, `/tmp/`, `/mnt/` 및 `/cdrom/`이 포함됩니다. 이러한 디렉터리는 일반적으로 `/etc/fstab`의 항목을 참조합니다. 이 파일은 다양한 파일 시스템과 마운트 지점을 정리한 표이며 시스템에서 읽어들입니다. `/etc/fstab`에 있는 대부분의 파일 시스템은 `noauto`를 포함하지 않는 한 부팅 시 man:rc[8] 스크립트에 의해 자동으로 마운트됩니다. 자세한 내용은 <<disks-fstab>>에서 확인할 수 있습니다.

파일 시스템 계층 구조에 대한 자세한 설명은 man:hier[7]에서 확인할 수 있습니다. 다음 표는 가장 일반적인 디렉터리에 대한 간략한 개요를 제공합니다.

[cols="25h,~"]
|===
| Directory
| Description

|`/`
|Root directory of the file system.

|`/bin/`
|User utilities fundamental to both single-user and multi-user environments.

|`/boot/`
|Programs and configuration files used during operating system bootstrap.

|`/boot/defaults/`
|Default boot configuration files. Refer to man:loader.conf[5] for details.

|`/dev/`
|Device special files managed by man:devfs[5]

|`/etc/`
|System configuration files and scripts.

|`/etc/defaults/`
|Default system configuration files. Refer to man:rc[8] for details.

|`/etc/periodic/`
|Scripts that run daily, weekly, and monthly, via man:cron[8]. Refer to man:periodic[8] for details.

|`/lib/`
|Critical system libraries needed for binaries in `/bin` and `/sbin`

|`/libexec/`
|Critical system files

|`/media/`
|Contains subdirectories to be used as mount points for removable media such as CDs, USB drives, and floppy disks

|`/mnt/`
|Empty directory commonly used by system administrators as a temporary mount point.

|`/net/`
|Automounted NFS shares; see man:auto_master[5]

|`/proc/`
|Process file system. Refer to man:procfs[5], man:mount_procfs[8] for details.

|`/rescue/`
|Statically linked programs for emergency recovery as described in man:rescue[8].

|`/root/`
|Home directory for the `root` account.

|`/sbin/`
|System programs and administration utilities fundamental to both single-user and multi-user environments.

|`/tmp/`
|Temporary files which are usually _not_ preserved across a system reboot. A memory-based file system is often mounted at `/tmp`. This can be automated using the tmpmfs-related variables of man:rc.conf[5] or with an entry in `/etc/fstab`; refer to man:mdmfs[8] for details.

|`/usr/`
|The majority of user utilities and applications.

|`/usr/bin/`
|Common utilities, programming tools, and applications.

|`/usr/include/`
|Standard C include files.

|`/usr/lib/`
|Archive libraries.

|`/usr/libdata/`
|Miscellaneous utility data files.

|`/usr/libexec/`
|System daemons and system utilities executed by other programs.

|`/usr/local/`
|Local executables and libraries. Also used as the default destination for the FreeBSD ports framework. Within `/usr/local`, the general layout sketched out by man:hier[7] for `/usr` should be used. Exceptions are the man directory, which is directly under `/usr/local` rather than under `/usr/local/share`, and the ports documentation is in `share/doc/port`.

|`/usr/ports/`
|The FreeBSD Ports Collection (optional).

|`/usr/sbin/`
|System daemons and system utilities executed by users.

|`/usr/share/`
|Architecture-independent files.

|`/usr/src/`
|BSD and/or local source files.

|`/var/`
|Multi-purpose log, temporary, transient, and spool files.

|`/var/log/`
|Miscellaneous system log files.

|`/var/tmp/`
|Temporary files which are usually preserved across a system reboot.

|===

[[disk-organization]]
== 디스크 구성

FreeBSD가 파일을 찾을 때 사용하는 가장 작은 단위는 파일 이름입니다. 파일 이름은 대소문자를 구분하므로, `readme.txt`와 `README.txt`는 별개의 파일로 취급됩니다. FreeBSD는 파일의 확장자를 사용하여 파일이 프로그램인지, 문서인지 또는 다른 형태의 데이터인지 판단하지 않습니다.

파일은 디렉터리에 저장됩니다. 디렉터리에는 파일이 하나도 없을 수도 있고 수백 개의 파일이 포함될 수도 있습니다. 또한 디렉터리는 다른 디렉터리를 포함할 수 있으므로 데이터를 정리하기 위해 여러 디렉터리를 계층화할 수 있습니다.

파일 및 디렉터리는 파일 또는 디렉터리 이름 뒤에 슬래시 `/`를 붙이고 그 뒤에 다른 디렉터리 이름을 붙여서 참조합니다. 예를 들어 `foo` 디렉터리에 `bar` 디렉터리가 있고 그 안에 `readme.txt` 파일이 있는 경우, 파일의 전체 이름 또는 _path_는 `foo/bar/readme.txt`가 됩니다. 파일과 디렉토리 이름을 구분하기 위해 `\`를 사용하는 Windows(R)와 다르다는 점에 유의하십시오. FreeBSD는 경로에 드라이브 문자나 다른 드라이브 이름을 사용하지 않습니다. 예를 들어, FreeBSD에서는 `c:\foo\bar\readme.txt`를 사용하지 않습니다.

[[disks-file-systems]]
=== 파일 시스템

디렉터리와 파일은 파일 시스템에 저장됩니다. 각 파일 시스템에는 해당 파일 시스템의 _루트 디렉터리_ 라고 하는 최상위 레벨에 정확히 하나의 디렉터리를 가집니다. 이 루트 디렉터리에는 다른 디렉터리가 포함될 수 있습니다. 하나의 파일 시스템은 _루트 파일 시스템_ 또는 `/`로 지정됩니다. 다른 모든 파일 시스템은 루트 파일 시스템 아래에 _마운트_됩니다. FreeBSD 시스템에는 디스크가 몇 개 있든 상관없이 모든 디렉토리는 동일한 디스크의 일부로 나타냅니다.

가령 `A`, `B`, `C`라고 하는 세 개의 파일 시스템을 생각해 봅시다. 각 파일 시스템에는 하나의 루트 디렉터리가 있으며, 이 루트 디렉터리에는 `A1`, `A2`(그리고 마찬가지로 `B1`, `B2` 및 `C1`, `C2`)라는 두 개의 다른 디렉터리가 있습니다.

루트 파일 시스템 `A`를 호출합니다. Man:ls[1]을 사용하여 이 디렉터리의 내용을 보면 `A1`과 `A2`라는 두 개의 하위 디렉터리가 표시됩니다. 디렉토리 트리는 다음과 같이 보입니다:

image::example-dir1.png["루트 디렉터리와 두 개의 하위 디렉터리가 있는 디렉터리 트리", A1 and A2]

하나의 파일 시스템은 반드시 다른 파일 시스템의 디렉토리에 마운트해야 합니다. 예를 들어 파일 시스템 `B`를 `A1` 디렉터리에 마운트하면 `B`의 루트 디렉터리가 `A1`을 대체하고 `B`의 디렉터리들이 그 하위에 나타납니다:

image::example-dir2.png["루트 디렉터리와 두 개의 하위 디렉터리가 있는 디렉터리 트리", A1 and A2. And more subdirectories, B1 and B2 hanging from A1]

`B1` 또는 `B2` 디렉터리에 있는 모든 파일은 필요에 따라 `/A1/B1` 또는 `/A1/B2` 경로로 접근할 수 있습니다. `A1`에 있던 모든 파일은 일시적으로 숨겨져 있습니다. 이 파일들은 `B`가 `A`에서 _언마운트_되면 다시 나타납니다.

만약 'B'가 'A2'에 마운트되었다면 다이어그램은 다음과 같이 보일 것입니다:

image::example-dir3.png["루트 디렉터리와 두 개의 하위 디렉터리가 있는 디렉터리 트리", A1 and A2. And more subdirectories, B1 and B2 hanging from A2]

그리고 경로는 각각 `/A2/B1`과 `/A2/B2`가 됩니다.

파일 시스템은 또다른 파일 시스템의 최상위 디렉터리에 마운트할 수도 있습니다. 지난 예제에 이어서 `C` 파일 시스템을 `B` 파일 시스템의 `B1` 디렉터리 위에 마운트하여 다음의 형태를 만들 수 있습니다:

image::example-dir4.png["복잡한 디렉터리 트리. 루트에 다른 하위 디렉터리가 연결되어 있습니다."]

또는 `C`를 `A1` 디렉토리 아래의 `A` 파일 시스템에 직접 마운트할 수도 있습니다:

image::example-dir5.png["복잡한 디렉터리 트리. 루트에 다른 하위 디렉터리가 연결되어 있습니다."]

이런 방식으로 단 하나의 거대한 루트 파일 시스템을 만들 수 있으며 또 다른 루트 파일 시스템을 만들 필요가 없습니다. 이러한 접근 방식에는 몇 가지 단점과 한 가지 장점이 있습니다.

.다중 파일 시스템의 이점
* 파일 시스템마다 _마운트 옵션_이 다를 수 있습니다. 예를 들어 루트 파일 시스템을 읽기 전용으로 마운트하면 사용자가 실수로 중요한 파일을 삭제하거나 편집할 수 없게 됩니다. `/home`과 같이 사용자가 쓰기 가능한 파일 시스템을 다른 파일 시스템과 분리하면 _nosuid_로 마운트할 수 있습니다. 이 옵션을 사용하면 파일 시스템에 저장된 실행 파일의 _suid_/_guid_ 비트가 적용되지 않으므로 보안을 향상시킬 수 있습니다.
* FreeBSD는 파일 시스템의 사용 방식에 따라 파일 시스템의 파일 레이아웃을 자동으로 최적화합니다. 따라서 쓰기가 자주 일어나는, 작은 파일들이 많이 포함된 파일 시스템은 쓰기가 덜 발생하고 큰 파일이 저장된 파일 시스템과 다른 최적화가 이루어집니다. 하나의 큰 파일 시스템을 사용하면 이러한 최적화가 무너집니다.
* FreeBSD의 파일 시스템은 전원이 끊겨도 견고하게 유지됩니다. 하지만 핵심적인 순간에 전원이 끊기면 파일 시스템의 구조가 손상될 수 있습니다. 여러 파일 시스템에 데이터를 분할해 두면 시스템이 계속 가동될 가능성이 높아지며 필요시 백업에서의 복원이 더 쉬워집니다.

.단일 파일 시스템의 이점
* 파일 시스템은 크기가 고정되어 있습니다. FreeBSD를 설치할 때 파일 시스템을 생성하고 특정 크기로 지정하고 나면, 나중에 파티션을 더 크게 만들어야 할 필요가 생깁니다. 이 작업은 백업하고 새 크기로 파일 시스템을 다시 만든 다음 백업된 데이터를 복원하지 않고는 쉽게 수행할 수 없습니다.
+
[IMPORTANT]
====
FreeBSD에는 파일 시스템의 크기를 즉시 늘릴 수 있는 man:growfs[8] 명령이 있어 이 제한을 없앨 수 있습니다. 다만 파일 시스템은 해당 파일 시스템이 있는 파티션의 여유 공간으로 만큼만 확장할 수 있습니다. 파티션 뒤에 공간이 있는 경우 man:gpart[8]로 파티션을 확장할 수 있습니다. 만약 파티션이 가상 디스크의 마지막 파티션이고 디스크를 추가한 경우 파티션을 확장할 수 있습니다.
====

[[disks-partitions]]
=== 디스크 파티션

파일 시스템은 _파티션_에 포함되어 있습니다. 디스크는 여러 파티션 유형중 하나를 사용하여 각각의 파티션으로 나뉩니다; 이에 대해서는 <<bsdinstall-part-manual>>을 참조하세요. 최신 파티션 유형은 GPT이며, 구형 BIOS 기반 컴퓨터는 MBR을 사용합니다. GPT는 디스크를 사이즈, 오프셋 및 타입으로 파티션으로 분할하는 것을 지원합니다. 이 방식은 많은 수의 파티션과 파티션 유형을 지원하므로 사용이 가능한 경우 항상 권장됩니다. GPT 파티션은 접미사가 붙은 디스크 이름을 사용하며, 여기서 접미사는 첫 번째 파티션의 경우 `p1`, 두 번째 파티션의 경우 `p2`와 같은 식으로 붙습니다. 그러나 MBR은 적은 수의 파티션만 지원합니다. FreeBSD에서 MBR 파티션은 `slices`라고 부릅니다. 슬라이스는 다른 운영체제에서도 사용할 수 있습니다. FreeBSD 슬라이스는 BSD 레이블을 사용하여 여러 파티션으로 세분화됩니다 (man:bsdlabel[8] 참조).
 
슬라이스 번호는 장치 이름 뒤에 `s`가 붙고, 1부터 시작합니다. 따라서 "da0__s1__"는 첫 번째 SCSI 드라이브의 첫 번째 슬라이스입니다. 디스크에는 4개의 물리적 슬라이스만 있을 수 있지만, 적절한 유형의 물리적 슬라이스 내부에 여러개의 논리 슬라이스가 있을 수 있습니다. 이러한 확장 슬라이스는 5부터 번호가 매겨지므로 "ada0__s5__"는 첫 번째 SATA 디스크의 첫 번째 확장 슬라이스입니다. 이러한 장치는 슬라이스를 사용할 것으로 예상되는 파일 시스템에서 사용됩니다.

각각의 GPT 또는 BSD 파티션은 하나의 파일 시스템만 포함할 수 있기 때문에, 파일 시스템은 파일 시스템 계층 구조에서 일상적인 마운트 지점 또는 파일 시스템이 포함된 파티션의 이름으로 부르는 경우가 많습니다.

FreeBSD는 또한 디스크 공간을 _스왑 공간_으로 사용하여 _가상 메모리_로 제공합니다. 이를 통해 컴퓨터는 실제보다 훨씬 더 많은 메모리가 있는 것처럼 동작할 수 있습니다. FreeBSD는 메모리가 부족하면 현재 사용되지 않는 일부 데이터를 스왑 공간으로 옮기고, 필요할 때 다시 스왑 공간에서 꺼냅니다(대신 다른 것을 안으로 옮깁니다). 이것을 _페이징(paging)_이라고 합니다.

일부 BSD 파티션에는 관련된 특정 규칙이 있습니다.

[cols="25h,~"]
|===
| Partition
| Convention

|`a`
|Normally contains the root file system.

|`b`
|Normally contains swap space.

|`c`
|Normally the same size as the enclosing slice. This allows utilities that need to work on the entire slice, such as a bad block scanner, to work on the `c` partition. A file system would not normally be created on this partition.

|`d`
|Partition `d` used to have a special meaning associated with it, although that is now gone and `d` may work as any normal partition.
|===

슬라이스 및 "위험 전용" 물리 드라이브에는 `a`에서 `h`까지의 문자로 표시되는 BSD 파티션이 포함되어 있습니다. 이 문자는 장치 이름에 추가되므로 "da0__a__"는 "위험 전용"인 첫 번째 `da` 드라이브의 `a` 파티션입니다. "ada1s3__e__"는 두 번째 SATA 디스크 드라이브의 세 번째 슬라이스에 있는 다섯 번째 파티션입니다.

마지막으로 시스템의 각 디스크는 구분이 가능합니다. 디스크 이름은 디스크 유형을 나타내는 코드로 시작한 다음 어느 디스크인지 나타내는 숫자가 붙습니다. 파티션 및 슬라이스와 달리 디스크 번호는 0부터 시작합니다. 일반적인 코드는 <<disks-naming>>에 정리되어 있습니다.

슬라이스에서 파티션을 참조할 때는 디스크 이름, `s`, 슬라이스 번호, 그리고 파티션 문자를 사용합니다. 이와 관련된 예시는 <<basics-disk-slice-part>>에 나와 있습니다. GPT 파티션은 디스크 이름, `p`, 그리고 파티션 번호를 사용합니다.

<<basics-concept-disk-model>>은 MBR 슬라이스를 사용하는 디스크 레이아웃의 개념적 모델을 보여줍니다.

FreeBSD를 설치할 때 MBR을 사용하는 경우 디스크 슬라이스를 구성하고 슬라이스 내에 FreeBSD에 사용할 파티션을 생성합니다. GPT를 사용하는 경우, 각 파일 시스템에 대한 파티션을 구성합니다. 두 경우 모두 각 파티션에 파일 시스템 또는 스왑 공간을 생성하고 각 파일 시스템을 마운트할 위치를 결정합니다. 파티션 조작에 대한 정보는 man:gpart[8]를 참고하세요.

[[disks-naming]]
.디스크 디바이스 이름
[cols="1,1", frame="none", options="header"]
|===
| Drive Type
| Drive Device Name

|SATA and IDE hard drives
|`ada`

|SCSI hard drives and USB storage devices
|`da`

|NVMe storage
|`nvd` or `nda`

|SATA and IDE CD-ROM drives
|`cd`

|SCSI CD-ROM drives
|`cd`

|Floppy drives
|`fd`

|SCSI tape drives
|`sa`

|RAID drives
|Examples include `aacd` for Adaptec(R) AdvancedRAID, `mlxd` and `mlyd` for Mylex(R), `amrd` for AMI MegaRAID(R), `idad` for Compaq Smart RAID, `twed` for 3ware(R) RAID.
|===

[example]
====
[[basics-disk-slice-part]]
.디스크, 슬라이스 및 파티션 이름의 예시
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Name
| Meaning

|`ada0s1a`
|The first partition (`a`) on the first slice (`s1`) on the first SATA disk (`ada0`).

|`da1s2e`
|The fifth partition (`e`) on the second slice (`s2`) on the second SCSI disk (`da1`).
|===
====

[[basics-concept-disk-model]]
.디스크의 개념적 모델
[example]
====
이 다이어그램은 시스템에 연결된 첫 번째 SATA 디스크에 대한 FreeBSD를 보여줍니다. 디스크의 크기가 250GB이고 80GB 슬라이스와 170GB 슬라이스(MS-DOS(R) 파티션)가 포함되어 있다고 가정합시다. 첫 번째 슬라이스에는 Windows(R) NTFS 파일 시스템인 `C:`가 포함되어 있고 두 번째 슬라이스에는 FreeBSD가 설치되어 있습니다. 이 예시에서 FreeBSD는 4개의 데이터 파티션과 스왑 파티션을 가집니다.

4개의 파티션은 각각의 파일 시스템을 가집니다. 파티션 `a`는 루트 파일 시스템에, `d`는 `/var/`에, `e`는 `/tmp/`에, `f`는 `/usr/`에 사용됩니다. 파티션 문자 `c`는 전체 슬라이스를 나타내므로 일반 파티션에는 사용되지 않습니다.

image::disk-layout.png["Windows와 FreeBSD 간의 공유 드라이브 레이아웃"]
====

[[mount-unmount]]
== 파일 시스템 마운트 및 마운트 해제

파일 시스템은 `/`에 뿌리를 둔 트리로 시각화하는 것이 가장 좋습니다. `/dev`, `/usr` 및 다른 디렉터리는 루트 디렉터리의 브랜치이며, `/usr/local` 등과 같은 자체 브랜치를 가질 수 있습니다.

이러한 디렉터리 중 일부를 별도의 파일 시스템에 보관하는 데에는 여러 가지 이유가 있습니다. `/var` 에는 `log/`, `spool/` 디렉터리와 다양한 유형의 임시 파일이 포함되어 있으므로 가득 찰 수 있습니다. 루트 파일 시스템을 가득 채우는 것은 좋은 생각이 아니므로 `/var`를 `/`에서 분리하는 것이 유리한 경우가 많습니다.

특정 디렉터리 트리를 다른 파일 시스템에 두는 또 다른 일반적인 이유는, 해당 디렉터리 트리를 별도의 물리적 디스크에 보관하는 경우나, crossref:network-servers[network-nfs,“Network File System (NFS)”]에 설명된 네트워크 파일 시스템 또는 CDROM 드라이브와 같이 별도의 가상 디스크에 보관해야 하는 경우입니다.

[[disks-fstab]]
=== fstab 파일

부팅 프로세스(crossref:boot[boot,The FreeBSD Booting Process]) 동안 `/etc/fstab`에 나열된 파일 시스템은 `noauto`가 포함된 항목을 제외하고 자동으로 마운트됩니다. 이 파일에는 다음 형식의 항목이 포함되어 있습니다:

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
<<disks-naming>>에 설명된 기존 장치 이름.

`mount-point`::
파일 시스템에 마운트할 기존 디렉터리.

`fstype`::
Man:mount[8]에 전달할 파일 시스템 유형. 기본 FreeBSD 파일 시스템은 `ufs`입니다.

`options`::
읽기-쓰기 파일 시스템의 경우 `rw`, 읽기 전용 파일 시스템의 경우 `ro` 및 기타 필요한 다른 옵션들. 일반적인 옵션은 부팅 시퀀스 중에 자동으로 마운트하지 않는 파일 시스템에 대한 `noauto`입니다. 다른 옵션은 man:mount[8]에 설명되어 있습니다.

`dumpfreq`::
Man:dump[8]에서 dumping이 필요한 파일 시스템인지를 결정하는 데 사용됩니다. 필드가 비어 있으면 0으로 가정합니다.

`passno`::
재부팅 후 man:fsck[8]가 UFS 파일 시스템을 검사할 순서를 결정합니다. 건너뛰어야 하는 파일 시스템은 `passno`가 0으로 설정되어 있어야 합니다. 루트 파일 시스템은 다른 모든 파일 시스템보다 먼저 검사해야 하며 `passno`가 1로 설정되어 있어야 합니다. 다른 파일 시스템은 1보다 큰 값으로 설정해야 합니다. 만약 둘 이상의 파일 시스템에 동일한 `passno` 숫자가 들어 있는 경우, man:fsck[8]은 가능하면 해당 파일 시스템들을 병렬로 검사하려고 시도합니다.

`/etc/fstab`의 형식과 옵션에 대한 자세한 내용은 man:fstab[5]을 참조하세요.

[[disks-mount]]
=== Man:mount[8] 사용하기

파일 시스템은 man:mount[8]를 사용하여 마운트합니다. 가장 기본적인 구문은 다음과 같습니다:

[example]
====
[source, shell]
....
# mount device mountpoint
....
====

`/etc/fstab`에 나열된 파일 시스템도 마운트 포인트만 제공하면 마운트할 수 있습니다.

이 명령은 man:mount[8]에 설명된 많은 옵션을 제공합니다. 가장 일반적으로 사용되는 옵션은 다음과 같습니다:

.마운트 옵션
`-a`::
`/etc/fstab`에 나열된 모든 파일 시스템(`-t` 플래그로 제외되었거나 "noauto"로 표시된 파일 시스템, 또는 이미 마운트된 파일 시스템은 제외)을 마운트합니다.

`-d`::
실제 마운트 시스템 호출을 제외한 모든 작업을 수행합니다. 이 옵션은 `-v` 플래그와 함께 사용하면 man:mount[8]가 실제로 수행하려는 작업을 확인하는 데 유용합니다.

`-f`::
깨끗하지 않은(위험한) 파일 시스템을 강제로 마운트하거나, 파일 시스템을 읽기-쓰기에서 읽기 전용으로 다운그레이드하려고 할 때 쓰기 액세스 권한을 강제로 취소합니다.

`-r`::
파일 시스템을 읽기 전용으로 마운트합니다. 이는 `-o ro`를 사용하는 것과 동일합니다.

``-t _fstype_``::
지정된 파일 시스템 유형을 마운트하거나 `-a`가 포함된, 지정 유형의 파일 시스템만 마운트합니다. 기본 파일 시스템 유형은 "ufs"입니다.

`-u`::
파일 시스템의 마운트 옵션을 업데이트합니다.

`-v`::
자세한 설명(verbose).

`-w`::
파일 시스템 읽기-쓰기를 마운트합니다.

다음 옵션은 쉼표로 구분하여 `-o`에 추가할 수 있습니다:

nosuid::
파일 시스템에서 setuid 또는 setgid 플래그를 해석하지 말라는 뜻입니다. 이는 유용한 보안 옵션이기도 합니다.

[[disks-umount]]
=== man:umount[8]하기

파일 시스템을 마운트 해제하려면 man:umount[8]를 사용합니다. 이 명령은 마운트 지점, 장치 이름, `-a` 또는 `-A`가 될 수 있는 하나의 매개 변수를 필요로 합니다.

모든 명령은 `-f`를 사용하여 마운트를 강제로 해제하거나 `-v`를 사용하여 자세한 설명을 요구할 수 있습니다. 일반적으로 `-f`는 컴퓨터를 충돌시키거나 파일 시스템의 데이터에 손상을 입힐 수 있으므로 사용하지 않는 것이 좋습니다.

마운트된 모든 파일 시스템을 해제하거나 뒤에 나열된 특정 파일 시스템 유형만 해제하려면 `-a`, `-A`, 또는 `-t`를 사용합니다. `-A` 옵션을 사용해도 루트 파일 시스템을 마운트 해제하려고 시도하지는 않습니다.

[[basics-processes]]
== 프로세스와 데몬

FreeBSD는 멀티태스킹 운영체제입니다. 동시에 실행되고 있는 각각의 프로그램을 우리는 _프로세스_라고 부릅니다. 실행 중인 모든 명령은 적어도 하나의 새로운 프로세스로 시작되며, FreeBSD에서는 시스템에 의해 실행되는 다양한 프로세스가 있습니다.

각각의 프로세스는 _process ID_(PID)라는 고유번호로 식별할 수 있습니다. 파일과 마찬가지로 각각의 프로세스에는 하나의 소유자와 그룹이 있으며, 이 소유자 및 그룹 권한은 프로세스가 열 수 있는 파일과 장치를 결정하는 데 사용됩니다. 대부분의 프로세스에는 해당 프로세스를 실행시킨 상위 프로세스가 존재합니다. 예를 들어 셸은 하나의 프로세스이며 셸에서 시작된 모든 명령어는 셸을 부모 프로세스로 갖는 프로세스입니다. 예외로는 부팅 시 항상 가장 먼저 시작되는 man:init[8] 프로세스이며 항상 PID가 '1'인 특수 프로세스입니다.

일부 프로그램은 지속적인 사용자 입력에 의해 동작하도록 설계되지 않았으며 첫 순간에 터미널로부터 연결이 끊어집니다. 예를 들어 웹 서버는 사용자 입력이 아닌 웹 요청에만 응답합니다. 메일 서버는 이러한 유형의 애플리케이션의 또 다른 예입니다. 이러한 유형의 프로그램을 _데몬_이라고 합니다. 데몬이라는 용어는 그리스 신화에서 유래되었으며, 선하지도 악하지도 않은 존재로 눈에 보이지 않으며 유용한 작업을 수행하는 존재를 말합니다. 이것이 바로 BSD의 마스코트가 운동화를 신고 갈퀴를 든 쾌활한 모습의 데몬인 이유입니다.

일반적으로 데몬으로 실행되는 프로그램의 이름은 뒤에 "d"를 붙이는 관습이 있습니다. 예를 들어, BIND는 버클리 인터넷 네임 도메인이지만 실제로 실행되는 프로그램은 `named`입니다. 아파치 웹 서버 프로그램은 `httpd`이고 라인 프린터 스풀링 데몬은 `lpd`입니다. 이것은 명명 규칙일 뿐입니다. 예를 들어, Sendmail 애플리케이션의 기본 메일 데몬은 `maild`가 아니라 `sendmail`입니다.

=== 프로세스 보기

시스템에서 실행 중인 프로세스를 보려면 man:ps[1] 또는 man:top[1]을 사용합니다. 현재 실행 중인 프로세스의 정적 목록, 해당 프로세스의 PID, 사용 중인 메모리 양, 프로세스를 시작한 명령을 표시하려면 man:ps[1]을 사용합니다. 실행 중인 모든 프로세스를 표시하고 컴퓨터가 수행 중인 작업을 대화형으로 보기 위해 몇 초마다 디스플레이를 업데이트하려면 man:top[1]을 사용합니다.

기본적으로 man:ps[1]은 실행 중이고 사용자가 소유하고 있는 명령만을 표시합니다. 예를 들어:

[source, shell]
....
% ps
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps
....

Man:ps[1]의 출력은 여러 열로 구성됩니다. `PID` 열은 프로세스 ID를 표시합니다. PID는 1부터 시작하여 99999까지 할당된 다음 다시 처음으로 감싸집니다. 그러나 이미 사용 중인 PID는 다시 할당되지 않습니다. `TT` 열은 프로그램이 실행 중인 tty를 표시하고 `STAT`는 프로그램의 상태를 표시합니다. `TIME`은 프로그램이 CPU에서 실행된 시간입니다. 이 시간은 대부분의 프로그램이 CPU에서 처리되기 전 기다리는 데 많은 시간을 소비하기 때문에 일반적으로 프로그램이 시작된 후 경과된 시간이 아닙니다. 마지막으로 `COMMAND`는 프로그램을 시작하는 데 사용된 명령어입니다.

표시되는 정보를 변경하기 위해 다양한 옵션을 사용할 수 있습니다. 가장 유용한 집합 중 하나는 `auxww`로, `a`는 모든 사용자의 실행 중인 모든 프로세스에 대한 정보를 표시하고, `u`는 프로세스 소유자의 사용자 이름과 메모리 사용량을 표시하며, `x`는 데몬 프로세스에 대한 정보를 표시하고, `ww`는 man:ps[1]가 각 프로세스의 명령줄이 너무 길어 화면에 맞지 않을 때 잘리지 않고 전체 명령줄을 표시하도록 합니다.

Man:top[1]의 출력도 비슷합니다:

[source, shell]
....
% top
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

출력은 두 섹션으로 나뉩니다. 헤더(첫 5~6줄)에는 마지막으로 실행한 프로세스의 PID, 시스템 로드 평균(시스템 사용량 측정), 시스템 가동 시간(마지막 재부팅 이후 시간) 및 현재 시간이 표시됩니다. 헤더의 다른 수치는 실행 중인 프로세스 수, 사용된 메모리 및 스왑 공간의 양, 시스템이 다양한 CPU 상태에 따라 소모하는 시간등이 표시됩니다. ZFS 파일 시스템 모듈이 로드된 경우 `ARC` 줄은 디스크가 아닌 메모리 캐시에서 읽은 데이터의 양을 나타냅니다.

헤더 아래에는 man:ps[1]의 출력과 유사한 정보(예: PID, 사용자 이름, CPU 시간, 프로세스를 시작한 명령)가 포함된 일련의 열이 있습니다. 기본적으로 man:top[1]은 프로세스가 사용하고 있는 총 메모리 양도 표시합니다. 이는 총 크기와 상주 크기의 두 열로 나뉩니다. 총 크기는 애플리케이션이 요구한 메모리 양이며, 상주 크기는 애플리케이션이 현재 실제로 사용하고 있는 메모리 양입니다.

man:top[1]은 2초마다 화면을 자동으로 업데이트합니다. `-s` 옵션으로 업데이트 간격을 지정할 수 있습니다.

[[basics-daemons]]
=== 프로세스 종료하기(죽이기)

실행 중인 프로세스나 데몬과 통신하는 한 가지 방법은 man:kill[1] _시그널_을 보내는 것입니다. 실제로는 여러 가지 시그널이 있으며 일부는 특별한 의미가 있는 반면, 그 외의 것들은 해당 애플리케이션 문서에 설명되어 있습니다. 사용자는 자신이 소유한 프로세스에만 시그널을 보낼 수 있으며 다른 사람의 프로세스에 시그널을 보내면 권한 거부 오류가 발생합니다. 모든 프로세스에 신호를 보낼 수 있는 `root` 사용자는 예외입니다.

운영체제 역시 프로세스에 시그널을 보낼 수도 있습니다. 응용 프로그램이 메모리를 잘못 사용하거나 지원되지 않는 메모리 영역에 접근하려고 하면, FreeBSD는 프로세스에 "세그먼트 위반" 신호(`SIGSEGV`)를 보냅니다. 응용 프로그램이 일정 시간이 경과한 후 경고를 받게 man:alarm[3] 시스템 호출을 사용하도록 작성된 경우, "알람" 시그널(`SIGALRM`)이 전송됩니다.

프로세스를 중지하는 데 두 가지 시그널을 사용할 수 있는데 `SIGTERM`과 `SIGKILL`이 그것입니다. `SIGTERM`은 프로세스가 시그널을 읽고 열려 있는 모든 로그 파일을 닫은 후 종료하기 전에 수행 중인 작업을 완료하려고 시도할 수 있으므로 프로세스를 종료하는 정중한 방법입니다. 경우에 따라 프로세스가 중단할 수 없는 작업의 중간에 있는 경우, 프로세스는 `SIGTERM`을 무시할 수 있습니다.

`SIGKILL`은 프로세스에 의해 무시될 수 없습니다. 프로세스에 `SIGKILL`을 보내면 일반적으로 해당 프로세스가 바로 중지됩니다. footnote:[중단할 수 없는 몇 가지 작업이 있습니다. 예를 들어, 프로세스가 네트워크의 다른 컴퓨터에 있는 파일에서 읽으려고 하는데 다른 컴퓨터를 사용할 수 없는 경우 프로세스는 중단할 수 없다고 알립니다. 하지만 결과적으로 프로세스는 2분 후에 시간 초과가 발생하고, 이 시간 초과가 발생하면 프로세스가 종료됩니다].

일반적으로 사용되는 다른 시그널로는 `SIGHUP`, `SIGUSR1`, `SIGUSR2`가 있습니다. 이러한 시그널은 범용 시그널이므로 애플리케이션마다 다르게 응답합니다.

예를 들어 웹 서버의 구성 파일을 변경한 후에는 웹 서버에 구성을 다시 읽으라고 알려야 합니다. `httpd` 재시작 명령을 하면 웹 서버가 잠시 중단될 수 있습니다. 대신 데몬에 `SIGHUP` 시그널을 보내세요. 시그널은 데몬마다 시그널에 대한 동작 방식이 다르므로 해당 데몬의 설명서를 참조하여 `SIGHUP`으로 원하는 결과를 얻을 수 있는지 확인하세요.

[IMPORTANT]
====
시스템에서 임의의 프로세스를 종료(죽이는) 일은 나쁜 아이디어입니다. 특히 man:init[8], PID 1은 특별합니다. `/bin/kill -s KILL 1`을 실행하는 것은 시스템을 종료하는 빠르지만 절대 권장할 수 없는 방법입니다. _man:kill[1]을 적고 kbd:[Return]을 누르기 전에 항상 man:kill[1]의 인수를 다시 한번 확인하세요._
====

[[shells]]
== 셸(Shells)

셸은 운영체제와 상호작용할 수 있는 명령줄 인터페이스(CLI)를 제공합니다. 셸은 입력 채널에서 명령을 받아 실행합니다. 많은 셸은 파일 관리, 파일 글로빙, 명령줄 편집, 명령 매크로 및 환경 변수와 같은 일상적인 작업에 도움이 되는 내장 함수를 제공합니다. FreeBSD은 Bourne 셸(man:sh[1])과 Extended C 셸(man:tcsh[1])을 포함한 여러가지 셸을 함께 제공합니다. `zsh` 및 `bash`와 같은 셸은 FreeBSD 포트(Port) 컬렉션에서 다운받아 사용할 수 있습니다.

어떤 셸을 사용할지는 순전히 취향의 문제입니다. C 프로그래머는 man:tcsh[1]와 같은 C와 유사한 셸을 더 편하게 느낄 수 있습니다. Linux(R) 사용자는 `bash`를 선호할 수 있습니다. 각 셸에는 사용자가 선호하는 작업 환경에서 작동하거나 작동하지 않을 수 있는 고유한 속성이 있으므로 어떤 셸을 사용할지 선택해야 합니다.

일반적인 셸 기능 중 하나는 파일 이름 완성(filename completion)입니다. 사용자가 명령어 또는 파일 이름의 처음 몇 글자를 입력하고 kbd:[Tab]을 누르면 셸이 나머지 부분을 완성합니다. `foobar`와 `football`이라는 두 파일을 예로 들어 보겠습니다. 만약 사용자가 `foobar`를 삭제하고 싶다면 `rm foo`를 입력한 후 kbd:[Tab]을 눌러 파일 이름을 완성할 수 있습니다.

그러나 셸은 `rm foo`만 표시합니다. `foobar`와 `football` 모두 `foo`로 시작하기 때문에 파일 이름을 완성할 수 없습니다. 일부 셸은 둘 이상의 이름이 일치하는 경우 경고음을 울리거나 모든 선택 항목을 표시합니다. 그러면 사용자는 원하는 파일 이름을 식별하기 위해 더 많은 문자를 입력해야 합니다. `t`를 입력하고 kbd:[Tab]을 다시 누르면 셸이 원하는 파일 이름을 결정하고 나머지를 채우도록 할 수 있습니다.

셸의 또 다른 특징은 환경 변수를 사용한다는 것입니다. 환경 변수는 셸의 환경에 저장된 변수/키 쌍입니다. 이 환경은 쉘이 호출하는 모든 프로그램에서 읽을 수 있으며, 따라서 많은 프로그램의 설정을 포함합니다. <<shell-env-vars>>에서 일반적인 환경 변수의 목록과 그 의미를 확인할 수 있습니다. 환경 변수의 이름은 항상 대문자로 표기된다는 점에 유의하세요.

[[shell-env-vars]]
.일반적인 환경 변수
[cols="25h,~"]
|===
| Variable
| Description

|`USER`
|Current logged in user's name.

|`PATH`
|Colon-separated list of directories to search for binaries.

|`DISPLAY`
|Network name of the Xorg display to connect to, if available.

|`SHELL`
|The current shell.

|`TERM`
|The name of the user's type of terminal. Used to determine the capabilities of the terminal.

|`TERMCAP`
|Database entry of the terminal escape codes to perform various terminal functions.

|`OSTYPE`
|Type of operating system.

|`MACHTYPE`
|The system's CPU architecture.

|`EDITOR`
|The user's preferred text editor.

|`PAGER`
|The user's preferred utility for viewing text one page at a time.

|`MANPATH`
|Colon-separated list of directories to search for manual pages.
|===

환경 변수를 설정하는 방법은 셸마다 다릅니다. Man:tcsh[1] 및 man:csh[1]에서는 `setenv`를 사용하여 환경 변수를 설정합니다. Man:sh[1] 및 `bash`에서는 `export`를 사용하여 현재 환경 변수를 설정합니다. 이 예에서는 man:tcsh[1] 셸의 기본 `EDITOR`를 `/usr/local/bin/emacs`로 설정합니다:

[source, shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

`bash`에 해당하는 명령은 다음과 같습니다:

[source, shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

환경 변수를 확장하여 현재 설정을 확인하려면 명령줄에서 이름 앞에 `$` 문자를 입력합니다. 예를 들어 `echo $TERM`은 현재 `$TERM` 설정을 표시합니다.

셸은 메타 문자로 알려진 특수 문자를 데이터의 특수 표현으로 취급합니다. 가장 일반적인 메타 문자는 `\*`로, 파일 이름에 있는 문자 수를 나타냅니다. 메타 문자를 사용하여 파일 이름 글로빙을 수행할 수 있습니다. 예를 들어 `echo *`는 `echo`와 `*`에 일치하는 모든 파일을 셸이 가져오고 나열하기 때문에 `ls`와 동일합니다.

셸이 특수 문자를 해석하지 못하도록 하려면 백슬래시(`\`)로 시작하여 셸에서 명령을 끝냅니다. 예를 들어, `echo $TERM`은 터미널 설정을 출력하는 반면 `echo \$TERM`은 문자 그대로 문자열 `$TERM`을 출력합니다.

[[changing-shells]]
=== 셸 변경하기

기본 셸을 영구적으로 변경하는 가장 쉬운 방법은 `chsh`를 사용하는 것입니다. 이 명령을 실행하면 `EDITOR` 환경 변수에 구성된 편집기가 열리며, 이 환경 변수는 기본적으로 man:vi[1]로 설정되어 있습니다. `Shell:` 줄을 새 셸의 전체 경로로 변경합니다.

또는 편집기를 열지 않고도 지정된 셸을 설정하는 `chsh -s`를 사용할 수 있습니다. 예를 들어 셸을 `bash`로 변경합니다:

[source, shell]
....
% chsh -s /usr/local/bin/bash
....

프롬프트에 비밀번호를 입력하고 kbd:[Return]을 눌러 셸을 변경합니다. 새 셸을 사용하려면 로그오프했다가 다시 로그인합니다.

[NOTE]
====
새로 사용하려는 셸은 `/etc/shells`에 _반드시_ 존재해야 합니다. crossref:ports[ports,Installing Applications: Packages and Ports]에 설명된 대로 FreeBSD 포트 컬렉션에서 셸을 설치했다면, 이 파일에 자동으로 추가되어야 합니다. 누락된 경우 다음 명령을 사용하여 경로를 셸 경로로 바꾸어 추가합니다:

[source, shell]
....
# echo /usr/local/bin/bash >> /etc/shells
....

그런 다음 man:chsh[1]을 다시 실행합니다.
====

=== 고급 셸 기법

UNIX(R) 셸은 단순한 명령 인터프리터가 아니라 사용자가 명령을 실행하고, 출력을 리디렉션하고, 입력을 리디렉션하고, 명령을 함께 연결하여 최종 명령문의 출력을 개선할 수 있는 강력한 도구입니다. 이 기능을 내장 명령어와 함께 사용하면 효율성을 극대화할 수 있는 환경을 사용자에게 제공할 수 있습니다.

셸 리디렉션은 명령문의 출력 또는 입력을 다른 명령문이나 파일로 보내는 방법입니다. 예를 들어 man:ls[1] 명령의 출력을 파일로 캡처하려면 출력을 리디렉션합니다:

[source, shell]
....
% ls > directory_listing.txt
....

이제 디렉터리 내용이 `directory_listing.txt`에 나열됩니다. Man:sort[1]과 같은 일부 명령을 사용하여 입력을 읽을 수 있습니다. 이 목록을 정렬하려면 입력을 리디렉션합니다:

[source, shell]
....
% sort < directory_listing.txt
....

입력이 정렬되어 화면에 배치됩니다. 해당 입력을 다른 파일로 리디렉션하려면 방향을 혼합하여 man:sort[1]의 출력을 리디렉션할 수 있습니다:

[source, shell]
....
% sort < directory_listing.txt > sorted.txt
....

앞의 모든 예제에서 명령은 파일 해설자(file descriptor)를 사용하여 리디렉션을 수행합니다. 모든 UNIX(R) 시스템에는 표준 입력(stdin), 표준 출력(stdout) 및 표준 오류(stderr)를 포함하는 파일 해설자가 있습니다. 각각의 파일 해설자에는 용도가 있는데, input은 키보드나 마우스 등의 입력을 제공할 수 있습니다. Output은 화면이나 프린터의 용지 등이 될 수 있습니다. 그리고 Error는 진단 또는 오류 메시지에 사용되는 모든 것이 될 수 있습니다. 이 세 가지 모두 I/O 기반 파일 해설자로 간주되며, 스트림이라고도 합니다.

셸은 이러한 해설자를 사용하여 다양한 명령을 통해 출력과 입력을 전달하고 파일로, 또는 파일에서 리디렉션할 수 있습니다. 리디렉션의 또 다른 방법은 파이프 연산자입니다.

UNIX(R) 파이프 연산자 "|"를 사용하면 한 명령의 출력을 다른 프로그램으로 직접 전달하거나 지시할 수 있습니다. 기본적으로 파이프를 사용하면 명령의 표준 출력을 다른 명령에 표준 입력으로 전달할 수 있습니다. 예를들어:

[source, shell]
....
% cat directory_listing.txt | sort | less
....

이 예제에서는 `directory_listing.txt`의 내용이 정렬되고 출력이 man:less[1]로 전달됩니다. 이렇게 하면 사용자가 자신의 속도에 맞춰 출력을 스크롤할 수 있고 화면을 넘어 스크롤되는 것을 방지할 수 있습니다.

[[editors]]
== 텍스트 편집기

대부분의 FreeBSD 구성은 텍스트 파일을 편집하여 이루어지므로 텍스트 편집기에 익숙해지는 것이 좋습니다. FreeBSD는 기본 시스템의 일부로 몇 가지 텍스트 편집기를 제공하며, 포트(Port) 컬렉션에서 더 많은 것을 사용할 수 있습니다.

배우기 쉬운 편집기는 쉬운 편집기(Easy Editor)의 약자인 man:ee[1]입니다. 이 에디터를 시작하려면 `ee _파일명_`을 입력합니다. 여기서 _파일명_은 편집할 파일의 이름입니다. 편집기에 들어가면 편집기의 기능을 조작하기 위한 모든 명령이 디스플레이 상단에 나열됩니다. 캐럿(`^`)은 kbd:[Ctrl]을 나타내므로 `^e`는 kbd:[Ctrl+e]입니다. Man:ee[1]을 종료하려면 kbd:[Esc]를 누른 다음 주 메뉴에서 “leave editor”를 선택합니다. 파일이 수정된 경우 편집기에서 변경 사항을 저장할지 묻는 메시지가 표시됩니다.

FreeBSD는 또한 기본 시스템의 일부로 man:vi[1]와 같은 더 강력한 텍스트 편집기를 제공합니다. package:editors/emacs[] 및 package:editors/vim[]과 같은 다른 편집기는 FreeBSD 포트 컬렉션에서 다운 받을 수 있습니다. 이러한 편집기는 더 복잡한 대신 더 많은 기능을 제공합니다. Vim이나 Emacs와 같은 더 강력한 편집기를 배우면 장기적으로 더 많은 시간을 절약할 수 있습니다.

파일을 수정하거나 입력이 필요한 많은 응용 프로그램은 자동으로 텍스트 편집기를 엽니다. 기본 편집기를 변경하려면 <<shells>>에 설명된 대로 `EDITOR` 환경 변수를 설정하세요.

[[basics-devices]]
== 디바이스 및 디바이스 노드

디바이스(장치)는 주로 디스크, 프린터, 그래픽 카드, 키보드 등 시스템에서 하드웨어와 관련된 활동에 사용되는 용어입니다. FreeBSD가 부팅될 때, 부팅 메시지의 대부분은 감지되는 장치에 관한 것입니다. 부팅 메시지의 사본은 `/var/run/dmesg.boot`에 저장됩니다.

각 장치에는 장치 이름과 번호가 있습니다. 예를 들어, `ada0`은 첫 번째 SATA 하드 드라이브를 나타내고 `kbd0`는 키보드를 나타냅니다.

FreeBSD의 대부분의 장치는 `/dev`에 있는 디바이스 노드라는 특수 파일을 통해 액세스해야 합니다.

[[basics-more-information]]
== 매뉴얼 페이지

FreeBSD에 대한 가장 포괄적인 문서는 매뉴얼 페이지입니다. 시스템의 거의 모든 프로그램에는 기본 조작과 사용 가능한 인수를 설명하는 짧은 참조 설명서가 함께 제공됩니다. 이러한 매뉴얼은 `man`을 사용하여 볼 수 있습니다:

[source, shell]
....
% man command
....

여기서 _command_는 자세히 알아보려는 명령의 이름입니다. 예를 들어 man:ls[1]에 대해 자세히 알아보려면 다음과 같이 입력합니다:

[source, shell]
....
% man ls
....

매뉴얼 페이지는 주제 유형을 나타내는 섹션으로 나뉩니다. FreeBSD에서는 다음과 같은 섹션을 사용할 수 있습니다:

. 사용자 명령어.
. 시스템 호출 및 오류 번호.
. C 라이브러리의 함수.
. 디바이스 드라이버.
. 파일 형식.
. 게임 및 기분 전환.
. 기타 정보.
. 시스템 유지 관리 및 운영 명령어.
. 시스템 커널 인터페이스.

경우에 따라 동일한 주제가 온라인 설명서의 여러 섹션에 나타날 수 있습니다. 예를 들어 `chmod` 사용자 명령과 `chmod()` 시스템 호출이 있습니다. Man:man[1]에 표시할 섹션 번호를 지정해 주면 해당 섹션을 표시합니다:

[source, shell]
....
% man 1 chmod
....

그러면 사용자 명령 man:chmod[1]에 대한 설명서 페이지가 표시됩니다. 온라인 매뉴얼의 특정 섹션에 대한 참조는 일반적으로 서면 문서에서 괄호 안에 배치되므로 man:chmod[1]은 사용자 명령을, man:chmod[2]는 시스템 호출을 참조합니다.

매뉴얼 페이지의 이름을 모르는 경우 `man -k`를 사용하여 매뉴얼 페이지 설명에서 키워드를 검색하세요:

[source, shell]
....
% man -k mail
....

이 명령은 설명에 "mail" 키워드가 포함된 명령 목록을 표시합니다. 이는 man:apropos[1]을 사용하는 것과 동일합니다.

`usr/sbin`에 있는 모든 명령에 대한 설명을 읽으려면 다음과 같이 입력합니다:

[source, shell]
....
% cd /usr/sbin
% man -f * | more
....

또는

[source, shell]
....
% cd /usr/sbin
% whatis * |more
....

[[basics-info]]
=== GNU 정보 파일

FreeBSD에는 자유 소프트웨어 재단(FSF)에서 제작한 여러 애플리케이션과 유틸리티가 포함되어 있습니다. 이러한 프로그램에는 매뉴얼 페이지 외에도 `info` 파일이라는 하이퍼텍스트 문서가 포함될 수 있습니다. 이러한 파일은 man:info[1]를 사용하여 볼 수 있으며, package:editors/emacs[]가 설치된 경우 이맥스의 정보 모드를 사용하여 볼 수 있습니다.

Man:info[1]를 사용하려면 다음과 같이 입력합니다:

[source, shell]
....
% info
....

간단한 소개를 보려면 `h`를 입력합니다. 빠른 명령 참조를 보려면 `?`를 입력합니다.
