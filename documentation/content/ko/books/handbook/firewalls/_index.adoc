---
description: 'FreeBSD에는 기본 시스템에 세 가지 방화벽이 내장되어 있습니다: PF, IPFW, 그리고 IPFILTER입니다. 이 장에서는 패킷 필터링 규칙을 정의하는 방법, FreeBSD에 내장된 방화벽 간의 차이점 및 사용 방법을 다룹니다'
next: books/handbook/advanced-networking
part: 'IV. 네트워크 통신'
path: /books/handbook/
prev: books/handbook/network-servers
showBookMenu: 'true'
tags: ["firewall", "pf", "ipfw", "ipfilter", "blacklistd", "filtering"]
title: '32장. 방화벽'
weight: 37
---

[[firewalls]]
= 방화벽
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 32
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/firewalls/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[firewalls-intro]]
== 요약

방화벽을 사용하면 시스템을 통해 들어오고 나가는 트래픽을 필터링할 수 있습니다. 방화벽은 하나 이상의 “규칙” 세트를 사용하여 네트워크 연결에서 들어오고 나가는 네트워크 패킷을 검사하고 트래픽을 통과시키거나 차단할 수 있습니다. 방화벽의 규칙은 프로토콜 유형, 소스 또는 대상 호스트 주소, 소스 또는 대상 포트와 같은 패킷의 하나 이상의 특성을 검사할 수 있습니다.

방화벽은 호스트 또는 네트워크의 보안을 강화할 수 있습니다. 방화벽은 다음 중 하나 이상의 작업을 수행하는 데 사용할 수 있습니다:

* 공용 인터넷의 원치 않는 트래픽으로부터 내부 네트워크의 애플리케이션, 서비스, 머신을 보호하고 격리합니다.
* 내부 네트워크 호스트의 공용 인터넷 서비스에 대한 액세스를 제한하거나 비활성화합니다.
* 내부 네트워크에서 사설 IP 주소를 사용하고 단일 IP 주소 또는 자동으로 할당된 공용 주소의 공유 풀을 사용하여 공용 인터넷에 대한 단일 연결을 공유할 수 있는 네트워크 주소 변환(NAT)을 지원합니다.

FreeBSD에는 기본 시스템에 세 가지 방화벽이 내장되어 있습니다: PF, IPFW, 그리고 IPF라고도 알려진 IPFILTER입니다. FreeBSD는 또한 대역폭 사용량을 제어하기 위한 두 가지 트래픽 셰이퍼인 man:altq[4]와 man:dummynet[4]을 제공합니다. ALTQ는 전통적으로 PF와 밀접하게 연관되어 있고, dummynet은 IPFW와 밀접하게 연관되어 있습니다. 각 방화벽은 규칙을 사용하여 FreeBSD 시스템과 주고받는 패킷의 액세스를 제어하지만, 그 방식이 다르고 규칙 구문도 각각 다릅니다.

FreeBSD는 다양한 사용자들의 다양한 요구사항과 선호도를 충족시키기 위해 여러 방화벽을 제공합니다. 각 사용자는 자신의 필요에 가장 적합한 방화벽을 평가해야 합니다.

이 챕터를 읽고 나면, 여러분은:

* 패킷 필터링 규칙을 정의하는 방법.
* FreeBSD에 내장된 방화벽들 간의 차이점.
* PF 방화벽 사용 및 구성 방법.
* IPFW 방화벽 사용 및 구성 방법.
* IPFILTER 방화벽을 사용하고 구성하는 방법.

이 챕터를 읽기 전에 여러분은:

* 기본적인 FreeBSD 사용법 및 인터넷의 개념.

[NOTE]
====
모든 방화벽은 선택된 패킷 제어 필드의 값을 검사하는 것을 기반으로 하기 때문에 방화벽 규칙 집합을 만드는 사람은 TCP/IP의 작동 방식, 패킷 제어 필드의 다양한 값, 일반 세션 통신에서 이러한 값이 어떻게 사용되는지에 대해 이해해야 합니다. 이에 대한 자료로 http://www.ipprimer.com[Daryl's TCP/IP Primer]를 참고하세요.
====

[[firewalls-concepts]]
== 방화벽 개념

규칙 집합에는 패킷에 포함된 값에 따라 패킷을 통과시키거나 차단하는 규칙 그룹이 포함되어 있습니다. 호스트 간 패킷의 양방향 교환은 세션 통신으로 구성됩니다. 방화벽 룰셋은 공용 인터넷에서 도착하는 패킷과 이에 대한 응답으로 시스템에서 생성되는 패킷을 모두 처리합니다. 각 TCP/IP 서비스는 해당 프로토콜과 수신 포트로 미리 정의됩니다. 특정 서비스를 대상으로 하는 패킷은 권한이 없는 포트를 사용하여 소스 주소에서 출발하여 대상 주소의 특정 서비스 포트를 대상으로 합니다. 위의 모든 매개변수를 선택 기준으로 사용하여 서비스를 통과시키거나 차단할 규칙을 만들 수 있습니다.

알 수 없는 포트 번호를 조회하려면 [.filename]#/etc/services#를 참조하세요. 또는 http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers[http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers]를 방문하여 포트 번호 조회를 수행하여 특정 포트 번호의 용도를 찾을 수 있습니다.

http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php[트로이 목마가 사용하는 포트 번호]는 이 링크에서 확인하세요.

FTP에는 액티브 모드와 패시브 모드의 두 가지 모드가 있습니다. 데이터 채널을 획득하는 방식에 차이가 있습니다. 패시브 모드는 서수(ordinal) FTP 세션 요청자가 데이터 채널을 획득하므로 더 안전합니다. FTP 및 다양한 모드에 대한 자세한 설명은 http://www.slacksite.com/other/ftp.html[http://www.slacksite.com/other/ftp.html]를 참조하세요.

방화벽 규칙 집합은 “배타적”이거나 “포괄적”일 수 있습니다. 배타적 방화벽은 규칙 세트와 일치하는 트래픽을 제외한 모든 트래픽을 통과시킵니다. 포괄적 방화벽은 반대로 규칙과 일치하는 트래픽만 통과시키고 그 외의 모든 트래픽을 차단합니다.

포괄적인 방화벽은 아웃바운드 트래픽을 더 잘 제어할 수 있으므로 인터넷에 서비스를 제공하는 시스템에서 더 적합합니다. 또한 공용 인터넷에서 시작하여 사설 네트워크에 액세스할 수 있는 트래픽 유형도 제어합니다. 규칙과 일치하지 않는 모든 트래픽은 차단되고 기록됩니다. 포괄적 방화벽은 일반적으로 원치 않는 트래픽을 허용할 위험을 크게 줄이므로 배타적 방화벽보다 안전합니다.

[NOTE]
====
달리 명시되지 않는 한, 이 장의 모든 구성 및 예제 규칙 집합은 포괄적인 방화벽 규칙 집합을 생성합니다.
====

“상태분석형 방화벽(Stateful Firewall)”을 사용하여 보안을 더욱 강화할 수 있습니다. 이 유형의 방화벽은 열려 있는 연결을 추적하고 기존 연결과 일치하거나 허용된 새 연결을 여는 트래픽만 허용합니다.

상태분석형 필터링은 트래픽을, 세션을 구성하는 패킷의 양방향 교환으로 취급합니다. 매칭 규칙에 상태가 지정되면 방화벽은 세션 중에 교환될 것으로 예상되는 각 패킷에 대한 내부 규칙을 동적으로 생성합니다. 방화벽은 패킷이 세션에 유효한지 판단할 수 있는 충분한 매칭 기능을 갖추고 있습니다. 세션 템플릿에 제대로 맞지 않는 패킷은 자동으로 거부됩니다.

세션이 완료되면 동적 상태 테이블에서 세션이 제거됩니다.

상태분석형 필터링을 사용하면 새 세션을 차단/통과시키는 데 집중할 수 있습니다. 새 세션이 통과되면 그 이후의 모든 패킷이 자동으로 허용되고 모든 가짜 패킷은 자동으로 거부됩니다. 새 세션이 차단되면 그 이후의 패킷은 모두 허용되지 않습니다. 상태분석형 필터링은 공격자가 사용하는 다양한 공격 방법의 홍수를 방어할 수 있는 고급 매칭 기능을 제공합니다.

NAT는 _네트워크 주소 변환(Network Address Translation)_의 약자입니다. NAT 기능을 사용하면 방화벽 뒤에 있는 개인 LAN이 동적으로 할당된 주소라도 ISP에서 할당된 단일 IP 주소를 공유할 수 있습니다. NAT를 사용하면 여러 인터넷 계정이나 IP 주소에 대해 ISP에 비용을 지불하지 않고도 LAN의 각 컴퓨터가 인터넷에 액세스할 수 있습니다.

NAT는 패킷이 방화벽을 빠져나와 공용 인터넷으로 향할 때 LAN의 각 시스템에 대한 개인 LAN IP 주소를 단일 공용 IP 주소로 자동 변환합니다. 또한 패킷을 반환하기 위해 역변환도 수행합니다.

RFC 1918에 따르면 다음 IP 주소 범위는 공용 인터넷으로 직접 라우팅되지 않는 사설 네트워크용으로 예약되어 있으며, 따라서 NAT와 함께 사용할 수 있습니다:

* `10.0.0.0/8`.
* `172.16.0.0/12`.
* `192.168.0.0/16`.

[WARNING]
====
방화벽 규칙으로 작업할 때는 _매우 주의하세요_. 일부 구성은 관리자를 서버에서 _차단 할 수_ 있습니다. 안전을 위해 초기 방화벽 구성은 ssh를 통해 원격으로 수행하지 말고 로컬 콘솔에서 수행하는 것이 좋습니다.
====

[[firewalls-pf]]
== PF

FreeBSD 5.3부터, OpenBSD의 PF 방화벽의 포팅된 버전이 기본 시스템의 통합된 부분으로 포함되었습니다. PF는 완전한 기능을 갖춘 방화벽으로, 서비스 품질(QoS)을 제공하는 ALTQ(대체 큐잉)를 선택적으로 지원합니다.

OpenBSD 프로젝트는 http://www.openbsd.org/faq/pf/[PF FAQ]에서 PF에 대한 완전한 참고자료를 제공하고 있습니다. 피터 한스틴(Peter Hansteen)은 http://home.nuug.no/\~peter/pf/[http://home.nuug.no/~peter/pf/]에서 PF에 대한 자세한 튜토리얼을 관리하고 있습니다.

[WARNING]
====
http://www.openbsd.org/faq/pf/[PF FAQ]를 읽을 때, FreeBSD의 PF 버전은 수년에 걸쳐 업스트림 OpenBSD 버전과 상당히 달라졌다는 점을 염두에 두세요. 모든 기능이 FreeBSD에서 OpenBSD와 동일한 방식으로 작동하는 것은 아니며 그 반대의 경우도 마찬가지입니다.
====

{freebsd-pf}는 PF 방화벽 구성 및 실행에 관한 질문을 하기에 좋은 곳입니다. 이미 답변이 있을 수 있으므로 질문하기 전에 메일링 리스트 아카이브를 확인하시기 바랍니다.

핸드북의 이 섹션은 FreeBSD와 관련된 PF에 초점을 맞추고 있습니다. PF와 ALTQ를 활성화하는 방법을 설명합니다. 또한 FreeBSD 시스템에서 규칙 집합을 생성하기 위한 몇 가지 예제도 제공합니다.

=== PF 활성화하기

PF를 사용하려면 먼저 해당 커널 모듈을 로드해야 합니다. 이 섹션에서는 PF를 활성화하기 위해 [.filename]#/etc/rc.conf#에 추가할 수 있는 항목에 대해 설명합니다.

[.filename]#/etc/rc.conf#에 `pf_enable=yes`를 추가하여 시작하세요:

[source, shell]
....
# sysrc pf_enable=yes
....

man:pfctl[8]에 설명된 추가 옵션은 PF가 시작될 때 PF에 전달할 수 있습니다. 이 항목을 [.filename]#/etc/rc.conf#에서 추가하거나 변경하고 두 따옴표(`””`) 사이에 필요한 플래그를 지정하세요:

[.programlisting]
....
pf_flags=""                     # additional flags for pfctl startup
....

규칙 집합 구성 파일을 찾을 수 없으면 PF가 시작되지 않습니다. 기본적으로 FreeBSD는 규칙 집합을 함께 제공하지 않으며 [.filename]#/etc/pf.conf#가 없습니다. 규칙 집합의 예는 [.filename]#/usr/share/examples/pf/#에서 찾을 수 있습니다. 사용자 지정 규칙 집합이 다른 곳에 저장되어 있는 경우 [.filename]#/etc/rc.conf#에 파일의 전체 경로를 지정하는 한 줄을 추가하세요:

[.programlisting]
....
pf_rules="/path/to/pf.conf"
....

PF에 대한 로깅 지원은 man:pflog[4]에서 제공합니다. 로깅 지원을 활성화하려면 [.filename]#/etc/rc.conf#에 `pflog_enable=yes`를 추가합니다:

[source, shell]
....
# sysrc pflog_enable=yes
....

다음 줄을 추가하여 로그 파일의 기본 위치를 변경하거나 로그 파일이 시작될 때 man:pflog[4]에 전달할 추가 플래그를 지정할 수도 있습니다:

[.programlisting]
....
pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup
....

마지막으로 방화벽 뒤에 LAN이 있고 LAN에 있는 컴퓨터에 대해 패킷을 전달해야 하거나 NAT가 필요한 경우 다음 옵션을 사용하도록 설정합니다:

[.programlisting]
....
gateway_enable="YES"            # Enable as LAN gateway
....

필요한 편집 내용을 저장한 후 입력하면 로깅 지원을 통해 PF를 시작할 수 있습니다:

[source, shell]
....
# service pf start
# service pflog start
....

기본적으로 PF는 [.filename]#/etc/pf.conf#에서 구성 규칙을 읽고 이 파일에 지정된 규칙이나 정의에 따라 패킷을 수정, 드롭 또는 전달합니다. FreeBSD를 설치하면 [.filename]#/usr/share/examples/pf/#에 몇 가지 샘플 파일이 포함되어 있습니다. PF 규칙 집합에 대한 전체 내용은 http://www.openbsd.org/faq/pf/[PF FAQ]를 참조하세요.

PF를 제어하려면 `pfctl`을 사용합니다. <<pfctl>>에는 이 명령에 대한 몇 가지 유용한 옵션이 요약되어 있습니다. 사용 가능한 모든 옵션에 대한 설명은 man:pfctl[8]을 참조하십시오:
[[pfctl]]
.유용한 `pfctl` 옵션
[cols="1,1", frame="none", options="header"]
|===
| Command
| Purpose

|`pfctl -e`
|Enable PF.

|`pfctl -d`
|Disable PF.

|`pfctl -F all -f /etc/pf.conf`
|Flush all NAT, filter, state, and table rules and reload [.filename]#/etc/pf.conf#.

|`pfctl -s [ rules \| nat \| states ]`
|Report on the filter rules, NAT rules, or state table.

|`pfctl -vnf /etc/pf.conf`
|Check [.filename]#/etc/pf.conf# for errors, but do not load ruleset.
|===

[TIP]
====
package:security/sudo[]는 권한 상승이 필요한 `pfctl`과 같은 명령을 실행하는 데 유용합니다. 포트 컬렉션에서 설치할 수 있습니다.
====

PF 방화벽을 통과하는 트래픽을 주시하려면 package:sysutils/pftop[] 패키지 또는 포트를 설치하는 것이 좋습니다. 설치가 완료되면 pftop을 실행하여 man:top[1]과 유사한 형식으로 트래픽의 실행 중인 스냅샷을 볼 수 있습니다.

[[pf-tutorial]]
=== PF 규칙 집합

이 섹션에서는 사용자 정의 규칙 집합을 만드는 방법을 설명합니다. 가장 간단한 규칙 집합부터 시작하여 몇 가지 예제를 사용하여 개념을 바탕으로 PF의 다양한 기능을 실제로 사용하는 방법을 보여줍니다.

가장 간단한 규칙 집합은 서비스를 실행하지 않고 하나의 네트워크(인터넷일 수 있는)에 액세스해야 하는 단일 머신에 대한 것입니다. 이 최소한의 규칙 집합을 만들려면 [.filename]#/etc/pf.conf#을 다음과 같이 편집하세요:

[.programlisting]
....
block in all
pass out all keep state
....

첫 번째 규칙은 기본적으로 들어오는 모든 트래픽을 거부합니다. 두 번째 규칙은 이 시스템에서 생성된 연결은 해당 연결의 상태 정보를 유지하면서 전달할 수 있도록 허용합니다. 이 상태 정보를 통해 해당 연결에 대한 리턴 트래픽이 다시 전달될 수 있으며 신뢰할 수 있는 컴퓨터에서만 사용해야 합니다. 다음으로 규칙 집합을 로드할 수 있습니다:

[source, shell]
....
# pfctl -e ; pfctl -f /etc/pf.conf
....

PF는 상태 유지 외에도 규칙을 만들 때 사용할 수 있도록 정의할 수 있는 _목록_과 _매크로_를 제공합니다. 매크로는 목록을 포함할 수 있으며 사용하기 전에 정의해야 합니다. 예를 들어, 규칙 집합의 맨 위에 이 줄을 삽입하세요:

[.programlisting]
....
tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"
....

PF는 포트 이름이 [.filename]#/etc/services#에 나열되어 있는 한, 포트 번호뿐만 아니라 포트 이름도 이해합니다. 이 예제에서는 두 개의 매크로를 생성합니다. 첫 번째는 7개의 TCP 포트 이름 목록이고 두 번째는 하나의 UDP 포트 이름입니다. 매크로를 정의하면 규칙에서 사용할 수 있습니다. 이 예제에서는 지정된 7개의 TCP 서비스와 지정된 1개의 UDP 서비스에 대해 이 시스템에서 시작된 연결을 제외한 모든 트래픽이 차단됩니다:

[.programlisting]
....
tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state
....

UDP는 무상태 프로토콜로 간주되지만 PF는 일부 상태 정보를 추적할 수 있습니다. 예를 들어, 네임 서버에 도메인 이름을 묻는 UDP 요청이 전달되면 PF는 응답을 감시하여 이를 다시 전달합니다.

규칙 집합을 편집할 때마다 새 규칙을 로드해야 사용할 수 있습니다:

[source, shell]
....
# pfctl -f /etc/pf.conf
....

구문 오류가 없는 경우 `pfctl`은 규칙 로드 중에 메시지를 출력하지 않습니다. 규칙을 로드하기 전에 규칙을 테스트할 수도 있습니다:

[source, shell]
....
# pfctl -nf /etc/pf.conf
....

`-n`을 포함하면 규칙이 해석만 되고 로드되지 않습니다. 이렇게 하면 오류를 수정할 수 있습니다. 항상 PF가 비활성화되거나 새 규칙 집합이 로드될 때까지 PF는 마지막으로 로드된 _유효한_ 규칙 집합을 적용합니다.

[TIP]
====
`pfctl`에 `-v`를 추가하면 규칙 집합을 확인하거나 완전히 구문 분석된 규칙이 로드되는 방식 그대로 표시됩니다. 이 기능은 규칙을 디버깅할 때 매우 유용합니다.
====

[[pftut-gateway]]
==== NAT를 갖춘 간단한 게이트웨이

이 섹션에서는 PF를 실행하는 FreeBSD 시스템이 적어도 하나 이상의 다른 머신에 대한 게이트웨이 역할을 하도록 구성하는 방법을 보여줍니다. 게이트웨이에는 각각 별도의 네트워크에 연결된 두 개 이상의 네트워크 인터페이스가 필요합니다. 이 예제에서는 [.filename]#xl0#이 인터넷에 연결되어 있고 [.filename]#xl1#이 내부 네트워크에 연결되어 있습니다.

먼저, 게이트웨이가 한 인터페이스에서 수신한 네트워크 트래픽을 다른 인터페이스로 전달할 수 있도록 설정합니다. 이 sysctl 설정은 IPv4 패킷을 전달합니다:

[source, shell]
....
# sysctl net.inet.ip.forwarding=1
....

IPv6 트래픽을 전달하려면 다음을 사용합니다:

[source, shell]
....
# sysctl net.inet6.ip6.forwarding=1
....

시스템 부팅 시 이러한 설정을 활성화하려면 man:sysrc[8]을 사용하여 [.filename]#/etc/rc.conf#에 추가합니다:

[source, shell]
....
# sysrc gateway_enable=yes
# sysrc ipv6_gateway_enable=yes
....

`ifconfig`를 사용하여 두 인터페이스가 모두 실행 중인지 확인합니다.

다음으로, 게이트웨이가 트래픽을 통과하도록 허용하는 PF 규칙을 생성합니다. 다음 규칙은 내부 네트워크 호스트의 상태분석형 트래픽이 게이트웨이로 전달되는 것을 허용하지만, `to` 키워드가 소스에서 목적지까지 모든 경로를 보장하지는 않습니다:

[.programlisting]
....
pass in on xl1 from xl1:network to xl0:network port $ports keep state
....

이 규칙은 트래픽이 내부 인터페이스의 게이트웨이로만 통과하도록 허용합니다. 패킷을 더 멀리 보내려면 일치하는 규칙이 필요합니다:

[.programlisting]
....
pass out on xl0 from xl1:network to xl0:network port $ports keep state
....

위의 두 가지 규칙은 작동하지만, 이렇게 구체적인 규칙이 필요한 경우는 거의 없습니다. 바쁜 네트워크 관리자에게는 읽기 쉬운 규칙 집합이 더 안전한 규칙 집합입니다. 이 섹션의 나머지 부분에서는 가독성을 위해 규칙을 가능한 한 단순하게 유지하는 방법을 설명합니다. 예를 들어 두 개의 규칙을 하나의 규칙으로 대체할 수 있습니다:

[.programlisting]
....
pass from xl1:network to any port $ports keep state
....

`인터페이스:네트워크` 표기법을 매크로로 대체하여 규칙 집합을 더욱 읽기 쉽게 만들 수 있습니다. 예를 들어, `$localnet` 매크로는 내부 인터페이스에 직접 연결된 네트워크(`$xl1:network`)로 정의할 수 있습니다. 또는 `$localnet`의 정의를 _IP 주소/넷마스크_ 표기법으로 변경하여 사설 주소 서브넷의 경우 `192.168.100.1/24`와 같이 네트워크를 나타낼 수도 있습니다.

필요한 경우 `$localnet`을 네트워크 목록으로 정의할 수도 있습니다. 구체적인 요구 사항이 무엇이든, 다음과 같이 일반적인 통과 규칙에 합리적인 `$localnet` 정의를 사용할 수 있습니다:

[.programlisting]
....
pass from $localnet to any port $ports keep state
....

다음 샘플 규칙 세트는 내부 네트워크의 머신에서 시작된 모든 트래픽을 허용합니다. 먼저 게이트웨이의 외부 및 내부 3COM 인터페이스를 나타내는 두 개의 매크로를 정의합니다.

[NOTE]
====
전화 접속 사용자의 경우 외부 인터페이스는 [.filename]#tun0#을 사용합니다. ADSL 연결, 특히 PPPoE(PPP를 통한 이더넷)를 사용하는 연결의 경우 올바른 외부 인터페이스는 물리적 이더넷 인터페이스가 아닌 [.filename]#tun0#입니다.
====

[.programlisting]
....
ext_if = "xl0"	# macro for external interface - use tun0 for PPPoE
int_if = "xl1"	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -> ($ext_if)
block all
pass from { lo0, $localnet } to any keep state
....

이 규칙 집합은 내부 네트워크에서 내부 주소로 라우팅할 수 없는, 주소에서 외부 인터페이스에 할당된 IP 주소로 네트워크 주소 변환을 처리하는 데 사용되는 `nat` 규칙을 소개합니다. nat 규칙의 마지막 부분인 `($ext_if)`를 둘러싼 괄호는 외부 인터페이스의 IP 주소가 동적으로 할당될 때 포함됩니다. 외부 IP 주소가 변경되더라도 네트워크 트래픽이 심각한 중단 없이 실행되도록 보장합니다.

이 규칙 집합은 아마도 필요한 것보다 더 많은 트래픽이 네트워크 외부로 전달되도록 허용할 수 있습니다. 합리적인 설정으로 이 매크로를 만들 수 있습니다:

[.programlisting]
....
client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }"
....

메인 패스 규칙에 사용하려면:

[.programlisting]
....
pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state
....

몇 가지 다른 통과 규칙이 필요할 수 있습니다. 이 규칙은 외부 인터페이스에서 SSH를 사용하도록 설정합니다:

[.programlisting]
....
pass in inet proto tcp to $ext_if port ssh
....

이 매크로 정의 및 규칙은 내부 클라이언트에 대한 DNS 및 NTP를 허용합니다:

[.programlisting]
....
udp_services = "{ domain, ntp }"
pass quick inet proto { tcp, udp } to any port $udp_services keep state
....

이 규칙의 ‘quick’ 키워드에 주목하세요. 규칙 집합은 여러 규칙으로 구성되므로 규칙 집합의 규칙 간의 관계를 이해하는 것이 중요합니다. 규칙은 작성된 순서대로 위에서 아래로 평가됩니다. PF가 평가하는 각 패킷 또는 연결에 대해, 규칙 세트에서 마지막으로 일치하는 규칙이 적용됩니다. 그러나 패킷이 ‘quick’ 키워드가 포함된 규칙과 일치하면 규칙 처리가 중지되고 해당 규칙에 따라 패킷이 처리됩니다. 이 기능은 일반 규칙에 대한 예외가 필요할 때 매우 유용합니다.

[[pftut-ftp]]
==== FTP 프록시 생성하기

FTP 프로토콜의 특성으로 인해 동작중인 FTP 규칙을 구성하는 것은 문제가 될 수 있습니다. FTP는 방화벽보다 수십 년 전의 것으로, 설계상 안전하지 않습니다. FTP 사용에 반대하는 가장 일반적인 이유는 다음과 같습니다:

* 비밀번호가 투명하게 전송됩니다.
* 이 프로토콜은 별도의 포트에서 최소 두 개의 TCP 연결(제어 및 데이터)을 사용하도록 요구합니다.
* 세션이 설정되면 무작위로 선택된 포트를 사용하여 데이터가 통신됩니다.

클라이언트 또는 서버 소프트웨어의 잠재적인 보안 취약점을 고려하기 전에도 이러한 모든 점은 보안 문제를 야기합니다. 암호화된 연결을 통한 인증 및 데이터 전송 기능을 모두 갖춘 man:sftp[1] 또는 man:scp[1]와 같은 보다 안전한 파일 전송 대안이 존재합니다.

FTP가 필요한 상황을 위해, PF는 FreeBSD의 기본 시스템에 포함되어 있는 man:ftp-proxy[8]라는 작은 프록시 프로그램으로 FTP 트래픽을 리디렉션합니다. 프록시의 역할은 일련의 앵커를 사용하여 규칙 집합에 규칙을 동적으로 삽입 및 삭제하여 FTP 트래픽을 올바르게 처리하는 것입니다.

FTP 프록시를 사용하려면 [.filename]#/etc/rc.conf#에 이 줄을 추가합니다:

[.programlisting]
....
ftpproxy_enable="YES"
....

그런 다음 프록시를 실행하여 시작하세요:

[source, bash]
....
# service ftp-proxy start
....

기본 구성의 경우 [.filename]#/etc/pf.conf#에 세 가지 요소를 추가해야 합니다. 첫째, 프록시가 FTP 세션에 대해 생성하는 규칙을 삽입하는 데 사용할 앵커입니다:

[.programlisting]
....
nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"
....

둘째, 프록시로 들어오는 FTP 트래픽을 허용하려면 통과 규칙이 필요합니다.

셋째, 리디렉션 및 NAT 규칙은 필터링 규칙보다 먼저 정의해야 합니다. 이 `rdr` 규칙을 `nat` 규칙 바로 뒤에 삽입하세요:

[.programlisting]
....
rdr pass on $int_if proto tcp from any to any port ftp -> 127.0.0.1 port 8021
....

마지막으로 리디렉션된 트래픽이 통과할 수 있도록 허용합니다:

[.programlisting]
....
pass out proto tcp from $proxy to any port ftp
....

여기서 `$proxy`는 프록시 데몬이 바인딩된 주소로 확장됩니다.

[.filename]#/etc/pf.conf#을 저장하고 새 규칙을 로드한 다음 클라이언트에서 FTP 연결이 작동하는지 확인합니다:

[source, shell]
....
# pfctl -f /etc/pf.conf
....

이 예에서는 로컬 네트워크의 클라이언트가 다른 곳의 FTP 서버에 연결해야 하는 기본 설정에 대해 설명합니다. 이 기본 구성은 대부분의 FTP 클라이언트와 서버 조합에서 잘 작동합니다. man:ftp-proxy[8]에 표시된 것처럼 `ftpproxy_flags=` 줄에 옵션을 추가하여 프록시 동작을 다양한 방식으로 변경할 수 있습니다. 일부 클라이언트 또는 서버에는 구성에서 보완해야 하는 몇가지 단점이 있거나 특정 대기열에 FTP 트래픽을 할당하는 등, 특정 방식으로 프록시를 통합해야 할 필요가 있을 수 있습니다.

PF 및 man:ftp-proxy[8]로 보호되는 FTP 서버를 실행하는 방법은 자체 리디렉션 통과 규칙이 있는 별도의 포트에 `-R`을 사용하여 역방향 모드에서 별도의 `ftp-proxy`를 구성합니다.

[[pftut-icmp]]
==== ICMP 관리하기

TCP/IP 네트워크의 디버깅 또는 문제 해결에 사용되는 많은 도구는 디버깅을 염두에 두고 특별히 설계된 인터넷 제어 메시지 프로토콜(ICMP)에 의존합니다.

ICMP 프로토콜은 호스트와 게이트웨이 간에 _제어 메시지_를 송수신하며, 주로 대상 호스트로 전송되는 도중 비정상적이거나 어려운 조건에 대한 피드백을 발신자에게 제공하기 위해 사용됩니다. 라우터는 ICMP를 사용하여 패킷 크기 및 기타 전송 매개변수를 협상하는데, 이를 흔히 _경로 MTU 검색 (Path MTU discorvery)_이라고 합니다.

방화벽 관점에서 볼 때, 일부 ICMP 제어 메시지는 알려진 공격 벡터에 취약합니다. 또한 모든 진단 트래픽을 무조건 통과시키면 디버깅이 더 쉬워지지만 다른 사람이 네트워크에 대한 정보를 더 쉽게 추출할 수 있습니다. 이러한 이유로 다음 규칙은 최적이 아닐 수 있습니다:

[.programlisting]
....
pass inet proto icmp from any to any
....

한 가지 해결책은 로컬 네트워크의 모든 ICMP 트래픽을 통과시키면서 네트워크 외부의 모든 프로브를 차단하는 것입니다:

[.programlisting]
....
pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state
....

PF의 유연성을 보여주는 추가 옵션을 사용할 수 있습니다. 예를 들어, 모든 ICMP 메시지를 허용하는 대신 man:ping[8] 및 man:traceroute[8]에서 사용하는 메시지를 지정할 수 있습니다. 먼저 해당 메시지 유형에 대한 매크로를 정의합니다:

[.programlisting]
....
icmp_types = "echoreq"
....

그리고 매크로를 사용할 규칙을 지정합니다:

[.programlisting]
....
pass inet proto icmp all icmp-type $icmp_types keep state
....

다른 유형의 ICMP 패킷이 필요한 경우 `icmp_types`를 확장하여 해당 패킷 유형 목록을 표시합니다. `more /usr/src/sbin/pfctl/pfctl_parser.c`를 입력하면 PF에서 지원하는 ICMP 메시지 유형 목록을 볼 수 있습니다. 각 메시지 유형에 대한 설명은 http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml[http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml]를 참조하세요.

유닉스 `traceroute`는 기본적으로 UDP를 사용하므로 유닉스 `traceroute`를 허용하려면 다른 규칙이 필요합니다:

[.programlisting]
....
# allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 >< 33626 keep state
....

Microsoft Windows 시스템의 `TRACERT.EXE`는 ICMP 에코 요청 메시지를 사용하므로, 해당 시스템에서 네트워크 추적을 허용하려면 첫 번째 규칙만 필요합니다. 유닉스 `traceroute`는 다른 프로토콜도 사용하도록 지시할 수 있으며, `-I`가 사용되는 경우 ICMP 에코 요청 메시지를 사용합니다. 자세한 내용은 man:traceroute[8] 매뉴얼 페이지를 참조하세요.

[[pftut-pathmtudisc]]
===== 경로 MTU 검색 (Path MTU Discovery)

인터넷 프로토콜은 디바이스 독립적으로 설계되었으며, 디바이스 독립성의 결과는 특정 연결에 대한 최적의 패킷 크기를 항상 안정적으로 예측할 수 없다는 것입니다. 패킷 크기에 대한 주요 제약 조건은 인터페이스의 패킷 크기에 대한 상한을 설정하는 _최대 전송 단위_(Max Tranmission Unit, MTU)입니다. 시스템 네트워크 인터페이스의 MTU를 보려면 `ifconfig`를 입력하세요.

TCP/IP는 경로 MTU 검색이라는 프로세스를 사용하여 연결에 적합한 패킷 크기를 결정합니다. 이 프로세스는 상한에 도달하면 “type 3, code 4”의 ICMP 반환 패킷을 예상하여 “조각화 안 함(Do not fragment)” 플래그가 설정된 다양한 크기의 패킷을 전송합니다. Type 3는 “대상에 연결할 수 없음”을 의미하며 Code 4는 “조각화가 필요하지만 조각화 금지 플래그가 설정되어 있음”의 줄임말입니다. 다른 MTU에 대한 연결을 지원하기 위해 경로 MTU 검색을 허용하려면 ‘대상에 연결할 수 없음(destination unreachable)’ 유형을 `icmp_types` 매크로에 추가하세요:

[.programlisting]
....
icmp_types = "{ echoreq, unreach }"
....

통과 규칙은 이미 해당 매크로를 사용하고 있으므로 새 ICMP 유형을 지원하기 위해 수정할 필요가 없습니다:

[.programlisting]
....
pass inet proto icmp all icmp-type $icmp_types keep state
....

PF는 모든 변형 ICMP 유형과 코드에 대한 필터링을 허용합니다. 가능한 유형과 코드 목록은 man:icmp[4] 및 man:icmp6[4]에 문서화되어 있습니다.

[[pftut-tables]]
==== 테이블 사용하기

일부 데이터 유형은 특정 시점에 필터링 및 리디렉션과 관련이 있지만, 그 정의가 너무 길어 규칙 집합 파일에 포함하기에는 무리가 있습니다. PF는 전체 규칙 집합을 다시 로드할 필요 없이, 변경 및 빠른 조회를 제공하는 테이블 사용을 지원합니다. 테이블 이름은 항상 다음과 같이 `< >`로 묶습니다:

[.programlisting]
....
table <clients> { 192.168.2.0/24, !192.168.2.5 }
....

이 예에서 `192.168.2.0/24` 네트워크는 `!` 연산자를 사용하여 제외된 주소 `192.168.2.5`를 제외하고는 테이블의 일부입니다. 이 예제 [.filename]#/etc/clients#에서 볼 수 있듯이 각 항목이 별도의 줄에 있는 파일에서 테이블을 로드할 수도 있습니다:

[.programlisting]
....
192.168.2.0/24
!192.168.2.5
....

파일을 참조하려면 다음과 같이 테이블을 정의합니다:

[.programlisting]
....
table <clients> persist file "/etc/clients"
....

테이블이 정의되면 규칙에서 참조할 수 있습니다:

[.programlisting]
....
pass inet proto tcp from <clients> to any port $client_out flags S/SA keep state
....

테이블의 내용은 `pfctl`을 사용하여 실시간으로 조작할 수 있습니다. 이 예제는 테이블에 다른 네트워크를 추가합니다:

[source, shell]
....
# pfctl -t clients -T add 192.168.1.0/16
....

이 방법으로 변경한 내용은 지금 바로 적용되므로 테스트에 적합하지만 정전이나 재부팅 시에는 적용되지 않습니다. 변경 사항을 영구적으로 적용하려면 규칙 집합에서 테이블의 정의를 수정하거나 테이블이 참조하는 파일을 편집하세요. 정기적으로 테이블의 내용을 디스크에 덤프하는 man:cron[8] 작업을 사용하여 테이블의 복사본을 유지 관리할 수 있으며, `pfctl -t clients -T show >/etc/clients`와 같은 명령을 사용할 수도 있습니다. 또는 [.filename]#/etc/clients#를 인메모리 테이블 내용으로 업데이트할 수 있습니다:

[source, shell]
....
# pfctl -t clients -T replace -f /etc/clients
....

[[pftut-overload]]
==== 과부하 테이블(Overload Table)을 사용하여 SSH 보호하기

외부 인터페이스에서 SSH를 실행하는 사용자는 인증 로그에서 이와 같은 내용을 본 적이 있을 것입니다:

[.programlisting]
....
Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2
....

이는 누군가 또는 어떤 프로그램이 사용자 이름과 비밀번호를 알아내어 시스템에 침입하려는 무차별 대입 공격(Brute force attack)을 나타냅니다.

합법적인 사용자를 위해 외부 SSH 액세스가 필요한 경우, SSH에서 사용하는 기본 포트를 변경하면 어느 정도 보호할 수 있습니다. 하지만 PF는 보다 우아한 솔루션을 제공합니다. 패스 규칙에는 연결 호스트가 수행할 수 있는 작업에 대한 제한이 포함될 수 있으며, 이를 위반하는 호스트는 일부 또는 모든 액세스가 거부되는 주소 테이블로 추방될 수 있습니다. 심지어 한도를 초과하는 컴퓨터에서 기존 연결을 모두 끊을 수도 있습니다.

이를 구성하려면 규칙 집합의 테이블 섹션에서 다음 테이블을 만듭니다:

[.programlisting]
....
table <bruteforce> persist
....

그런 다음 규칙 집합의 앞부분 어딘가에 합법적인 액세스는 허용하면서 무차별 액세스를 차단하는 규칙을 추가하세요:

[.programlisting]
....
block quick from <bruteforce>
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload <bruteforce> flush global)
....

괄호 안의 부분은 한도를 정의하며 로컬 네트워크 요구사항에 맞게 숫자를 변경해야 합니다. 다음과 같이 읽을 수 있습니다:

`max-src-conn`은 한 호스트에서 허용되는 동시 연결 수입니다.

`max-src-conn-rate`는 초(_5_) 당 단일 호스트(_15_)에서 허용되는 새 연결의 비율입니다.

`overload <bruteforce>`는 이 제한을 초과하는 모든 호스트의 주소가 `bruteforce` 테이블에 추가됨을 의미합니다. 이 규칙 집합은 `bruteforce` 테이블에 있는 주소로부터의 모든 트래픽을 차단합니다.

마지막으로, `flush global`은 호스트가 한도에 도달하면 해당 호스트의 모든(‘global’) 연결이 종료(`flush`)되는 것을 말합니다.

[NOTE]
====
이 규칙은 http://home.nuug.no/\~peter/hailmary2013/[http://home.nuug.no/~peter/hailmary2013/]에 설명된 것처럼 느린 bruteforce 공격을 _차단하지_ 않습니다.
====

이 예제 규칙 집합은 주로 설명을 위한 것입니다. 예를 들어, 일반적으로 많은 수의 연결을 허용하고 싶지만 ssh에 대해서는 더 제한적으로 허용하고 싶은 경우 규칙 집합 앞부분에 위 규칙을 아래와 같이 보완합니다:

[.programlisting]
....
pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload <bruteforce> flush global)
....

[NOTE]
====
*모든 오버로드를 차단할 필요는 없을 수도 있습니다:* +

과부하 메커니즘은 SSH에만 적용되는 것이 아닌 일반적인 기술이며, 공격자의 모든 트래픽을 완전히 차단하는 것이 항상 최선은 아니라는 점에 유의할 필요가 있습니다.

예를 들어, 과부하 규칙을 사용하여 메일 서비스 또는 웹 서비스를 보호하고, 과부하 테이블을 규칙에 사용하여 최소 대역폭 할당으로 위반자를 대기열에 할당하거나 특정 웹 페이지로 리디렉션하는 데 사용할 수 있습니다.
====

시간이 지남에 따라 테이블은 과부하 규칙에 의해 채워지고 크기가 점점 커져 더 많은 메모리를 차지하게 됩니다. 차단된 IP 주소는 로컬 네트워크의 호스트와 통신할 정당한 이유가 있는 호스트에 할당된 동적으로 할당된 주소인 경우도 있습니다.

이와 같은 상황에서 pfctl은 테이블 항목을 만료하는 기능을 제공합니다. 예를 들어, 이 명령은 `86400`초 동안 참조되지 않은 `<bruteforce>` 테이블 항목을 제거합니다:

[source, shell]
....
# pfctl -t bruteforce -T expire 86400
....

지정된 기간 동안 액세스하지 않은 테이블 항목을 제거하는 package:security/expiretable[]도 비슷한 기능을 제공합니다.

설치가 완료되면 expiretable을 실행하여 지정된 기간보다 오래된 `<bruteforce>` 테이블 항목을 제거할 수 있습니다. 이 예에서는 24시간이 지난 모든 항목을 제거합니다:

[.programlisting]
....
/usr/local/sbin/expiretable -v -d -t 24h bruteforce
....

[[pftut-spamd]]
==== 스팸으로부터 보호하기

스팸어쌔신과 함께 번들로 제공되는 spamd 데몬과 혼동하지 않도록 패키지:mail/spamd[]를 PF로 구성하여 스팸에 대한 외부 방어 기능을 제공할 수 있습니다. 이 spamd는 일련의 리디렉션을 사용하여 PF 구성에 연결됩니다.

스팸 발송자는 대량의 메시지를 보내는 경향이 있으며, 스팸은 주로 스팸 발송자에게 우호적인 소수의 네트워크와 다수의 하이재킹된 컴퓨터에서 발송되기 때문에, 이 두 가지 모두 _차단 목록_에 상당히 빠르게 보고됩니다.

차단 목록에 있는 주소로부터 SMTP 연결이 수신되면 스팸 데몬(spamd)은 배너를 표시하고 즉시 한 번에 한 바이트씩 SMTP 트래픽에 응답하는 모드로 전환합니다. 스팸 발송자의 입장에서 최대한 많은 시간을 낭비하게 만드는 이 기법을 _타피팅(tarpitting)_이라고 합니다. 1바이트 SMTP 회신을 사용하는 특정 구현을 종종 _스터터링(stuttering)_이라고 합니다.

이 예는 자동으로 업데이트되는 차단 목록으로 스팸 차단을 설정하는 기본 절차를 보여 줍니다. 자세한 내용은 package:mail/spamd[]와 함께 설치되어 있는 매뉴얼 페이지를 참조하세요.

[.procedure]
****
.절차: spamd 구성하기
. package:mail/spamd[] 패키지 또는 포트를 설치합니다. spamd의 그레이리스트 기능을 사용하려면 man:fdescfs[5]를 [.filename]#/dev/fd#에 마운트해야 합니다. 다음 줄을 [.filename]#/etc/fstab#에 추가합니다:
+
[.programlisting]
....
 fdescfs /dev/fd fdescfs rw 0 0
....
+
그리고 나서 파일 시스템을 마운트합니다:
+
[.programlisting]
....
#  mount fdescfs
....

. 다음으로, PF 규칙세트에 아래의 내용을 추가합니다:
+
[.programlisting]
....
table <spamd> persist
table <spamd-white> persist
rdr pass on $ext_if inet proto tcp from <spamd> to \
    { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !<spamd-white> to \
    { $ext_if, $localnet } port smtp -> 127.0.0.1 port 8025
....
+
두 개의 테이블 `<spamd>`와 `<spamd-white>`는 필수입니다. `<spamd>`에 나열되어 있지만 `<spamd-white>`에 없는 주소로부터의 SMTP 트래픽은 포트 8025에서 수신 대기 중인 spamd 데몬으로 리디렉션됩니다.
. 다음 단계는 [.filename]#/usr/local/etc/spamd.conf#에서 spamd를 구성하고 [.filename]#rc.conf# 매개변수를 추가하는 것입니다.
+
package:mail/spamd[] 설치에는 샘플 구성 파일([.filename]#/usr/local/etc/spamd.conf.sample#)과 [.filename]#spamd.conf#에 대한 매뉴얼 페이지가 포함되어 있습니다. 이 예제에 표시된 것 외에 추가 구성 옵션은 여기를 참조하세요.
+
구성 파일의 첫 번째 줄 중 `+#+` 주석 기호로 시작하지 않는 줄에는 사용할 목록을 지정하는 `all` 목록을 정의하는 블록이 포함되어 있습니다:
+
[.programlisting]
....
all:\
    :traplist:allowlist:
....
+
이 항목은 콜론(`:`)으로 구분하여 원하는 차단 목록을 추가합니다. 허용 목록을 사용하여 차단 목록에서 주소를 빼려면 해당 차단 목록의 이름 뒤에 허용 목록의 이름을 _즉시_ 추가합니다. 예: `:차단목록:허용목록:`.
+
다음은 지정된 차단 목록의 정의입니다:
+
[.programlisting]
....
traplist:\
    :black:\
    :msg="SPAM. Your address %A has sent spam within the last 24 hours":\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz
....
+
여기서 첫 번째 줄은 차단 목록의 이름이고 두 번째 줄은 목록 유형을 지정합니다. `msg` 필드에는 SMTP 대화 중에 차단 목록에 있는 발신자에게 표시할 메시지가 포함됩니다. `method` 필드는 스팸 설정에서 목록 데이터를 가져오는 방법을 지정합니다. 지원되는 메서드는 `http`, `ftp`, 마운트된 파일 시스템의 `file`에서, 외부 프로그램의 `exec`을 통해 가져오는 방법이 있습니다. 마지막으로, `file` 필드는 spamd가 수신할 것으로 예상되는 파일의 이름을 지정합니다.
+
지정된 허용 목록의 정의는 비슷하지만 메시지가 필요하지 않으므로 `msg` 필드가 생략됩니다:
+
[.programlisting]
....
allowlist:\
    :white:\
    :method=file:\
    :file=/var/mail/allowlist.txt
....
+
[TIP]
====
*주의해서 원 자료를 선택하세요:* +

샘플 [.filename]#spamd.conf#에 있는 모든 차단 목록을 사용하면 대량의 인터넷 블록을 차단할 수 있습니다. 관리자는 파일을 편집하여 해당 데이터 소스를 사용하고 필요한 경우 사용자 지정 목록을 사용하는 최적의 구성을 만들어야 합니다.
====
+
그런 다음 [.filename]#/etc/rc.conf#에 다음 항목을 추가합니다. 추가 플래그는 주석으로 지정된 매뉴얼 페이지에 설명되어 있습니다:
+
[.programlisting]
....
spamd_flags="-v" # use "" and see spamd-setup(8) for flags
....
+
완료되면 규칙 집합을 다시 로드하고, `service obspamd start`를 입력하여 데몬을 시작한 후, `spamd-setup`을 사용하여 구성을 완료합니다. 마지막으로, `spamd-setup`을 호출하여 적절한 간격으로 테이블을 업데이트하는 man:cron[8] 작업을 생성합니다.
****

메일 서버 앞의 일반적인 게이트웨이에서는 호스트가 몇 초에서 몇 분 내에 걸리기 시작합니다.

PF는 _45n_ 코드가 포함된, 알 수 없는 호스트의 메시지를 일시적으로 거부하는 _그레이 리스트_ 기능도 지원합니다. 그레이 리스트에 등록된 호스트가 합리적인 시간 내에 다시 시도하는 메시지는 통과됩니다. RFC 1123 및 RFC 2821에 설정된 제한 내에서 동작하도록 설정된 발신자의 트래픽은 즉시 통과됩니다.

그레이 리스팅 기법에 대한 자세한 내용은 http://www.greylisting.org/[greylisting.org] 웹 사이트에서 확인할 수 있습니다. 그레이 리스팅의 가장 놀라운 점은 단순함을 제외하면 여전히 작동한다는 것입니다. 스팸 발송자와 멀웨어 작성자는 이 기법을 우회하는 데 매우 느리게 적응해 왔습니다.

그레이 리스팅을 구성하는 기본 절차는 다음과 같습니다:

[.procedure]
.절차: 그레이리스트 구성하기
. 이전 절차의 1단계에 설명된 대로 man:fdescfs[5]가 마운트되었는지 확인합니다.
. 그레이리스트 모드에서 spamd를 실행하려면 [.filename]#/etc/rc.conf#에 이 줄을 추가하세요:
+
[.programlisting]
....
spamd_grey="YES"  # use spamd greylisting if YES
....
+
기타 관련 매개변수에 대한 설명은 spamd 매뉴얼 페이지를 참조하세요.
. 그레이리스트 설정 완료하려면:
+
[.programlisting]
....
#  service obspamd restart
#  service obspamlogd start
....

배후에서 spamdb 데이터베이스 도구와 spamlogd 화이트리스트 업데이터는 그레이리스트 기능에 필수적인 기능을 수행합니다. spamdb는 [.filename]#/var/db/spamdb# 데이터베이스의 내용을 통해 차단, 그레이, 허용 목록을 관리하는 관리자의 기본 인터페이스입니다.

[[pftut-hygiene]]
==== 네트워크 위생

이 섹션에서는 규칙 집합이 정상적으로 작동하도록 하기 위해 `block-policy`, `scrub`, `antispoof`를 사용하는 방법에 대해 설명합니다.

`block-policy`은 리디렉션 및 필터링 규칙 앞에 있는 규칙 집합의 `options` 부분에서 설정할 수 있습니다. 이 옵션은 PF가 규칙에 의해 차단된 호스트에 어떤 피드백(있는 경우)을 보낼지 결정합니다. 이 옵션에는 두 가지 가능한 값이 있습니다: `drop`은 피드백 없이 차단된 패킷을 삭제하고 `return`은 `Connection refused`와 같은 상태 코드를 반환합니다.

설정하지 않으면 기본 정책은 `drop`입니다. `block-policy`을 변경하려면 원하는 값을 지정합니다:

[.programlisting]
....
set block-policy return
....

PF에서 `scrub`은 네트워크 패킷 정규화를 가능하게 하는 키워드입니다. 이 프로세스는 조각난 패킷을 재조립하고 잘못된 플래그 조합을 가진 TCP 패킷을 삭제합니다. `scrub`을 활성화하면 패킷 조각의 잘못된 처리를 기반으로 하는 특정 종류의 공격에 대한 보호 수단을 제공합니다. 여러 가지 옵션을 사용할 수 있지만 가장 간단한 형태가 대부분의 구성에 적합합니다:

[.programlisting]
....
scrub in all
....

NFS와 같은 일부 서비스에는 특정 조각 처리 옵션이 필요합니다. 자세한 내용은 https://home.nuug.no/\~peter/pf/en/scrub.html[https://home.nuug.no/~peter/pf/en/scrub.html]을 참조하세요.

이 예제에서는 조각을 재조립하고 “do not fragment” 비트를 지운 다음 최대 세그먼트 크기를 1440바이트로 설정합니다:

[.programlisting]
....
scrub in all fragment reassemble no-df max-mss 1440
....

`antispoof`메커니즘은 주로 논리적으로 불가능한 방향을 가리키는 패킷을 차단하여 스푸핑 또는 위조된 IP 주소의 활동을 방지합니다.

이러한 규칙은 로컬 네트워크에서 발생하는 스푸핑된 패킷뿐만 아니라 외부에서 들어오는 스푸핑된 트래픽을 걸러냅니다:

[.programlisting]
....
antispoof for $ext_if
antispoof for $int_if
....

[[pftut-unrouteables]]
==== 라우팅할 수 없는 주소 처리하기

네트워크 주소 변환을 처리하도록 게이트웨이를 올바르게 구성했더라도 사용자의 잘못된 구성을 보완해야 할 수 있습니다. 일반적인 잘못된 구성은 라우팅할 수 없는 주소를 가진 트래픽을 인터넷으로 내보내는 것입니다. 라우팅할 수 없는 주소의 트래픽은 여러 DoS 공격 기법의 일부가 될 수 있으므로 라우팅할 수 없는 주소의 트래픽이 외부 인터페이스를 통해 네트워크에 유입되지 않도록 명시적으로 차단하는 것이 좋습니다.

이 예에서는 라우팅할 수 없는 주소가 포함된 매크로를 정의한 다음 차단 규칙에 사용합니다. 이러한 주소로 들어오고 나가는 트래픽은 게이트웨이의 외부 인터페이스에서 조용히 차단됩니다.

[.programlisting]
....
martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }"

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians
....

=== ALTQ 활성화하기

FreeBSD에서 ALTQ는 PF와 함께 사용되어 서비스 품질(QOS)을 향상시킬 수 있습니다. ALTQ가 활성화되면, 아웃바운드 패킷의 처리 우선순위를 결정하는 큐를 규칙 집합에 정의할 수 있습니다.

ALTQ를 활성화하기 전에 man:altq[4]를 참조하여 시스템에 설치된 네트워크 카드의 드라이버가 이를 지원하는지 확인합니다.

ALTQ는 커널 모듈을 로드하는 방식으로 사용할 수 없습니다. 시스템 인터페이스가 ALTQ를 지원하는 경우 crossref:kernelconfig[kernelconfig,FreeBSD 커널 구성]의 지침을 사용하여 사용자 정의 커널을 생성하세요. 다음 커널 옵션을 사용할 수 있습니다. 첫 번째는 ALTQ를 활성화하는 데 필요합니다. 그리고 큐잉 스케줄러 알고리즘을 지정하려면 다른 옵션 중 하나 이상이 필요합니다:

[.programlisting]
....
options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)
....

사용할 수 있는 스케줄러 알고리즘은 다음과 같습니다:

CBQ::
클래스 기반 큐(Class Based Queuing, CBQ)는 연결의 대역폭을 여러 클래스 또는 큐로 나누어 필터 규칙에 따라 트래픽의 우선 순위를 지정하는 데 사용됩니다.

RED::
무작위 조기 감지(Random Early Detection, RED)는 대기열의 길이를 측정하고 대기열의 최소 및 최대 임계값과 비교하여 네트워크 혼잡을 방지하는 데 사용됩니다. 대기열이 최대 임계값을 초과하면 모든 새 패킷이 무작위로 삭제됩니다.

RIO::
무작위 조기 감지 입출력(Random Early Detection In and Out, RIO) 모드에서 RED는 각 QOS 수준에 대해 하나씩 여러 개의 평균 대기열 길이와 여러 임계값을 유지합니다.

HFSC::
계층적 공정 서비스 곡선 패킷 스케줄러(Hierarchical Fair Service Curve Packet Scheduler, HFSC)는 http://www-2.cs.cmu.edu/\~hzhang/HFSC/main.html[http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html]에 설명되어 있습니다.

PRIQ::
우선 순위 대기열(Priority Queuing, PRIQ)은 항상 대기열이 높은 트래픽을 먼저 통과시킵니다.

스케줄링 알고리즘 및 예제 규칙 집합에 대한 자세한 내용은 https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html[OpenBSD 웹 아카이브]에서 확인할 수 있습니다.

[[firewalls-ipfw]]
== IPFW

IPFW는 FreeBSD용으로 작성된 상태분석형 방화벽으로, IPv4와 IPv6를 모두 지원합니다. 커널 방화벽 필터 규칙 프로세서와 통합 패킷 어카운팅 기능, 로깅 기능, NAT, man:dummynet[4] 트래픽 셰이퍼, 포워드 기능, 브리지 기능, ipstealth 기능 등 여러 구성 요소로 이루어져 있습니다.

FreeBSD는 초보 사용자가 적절한 규칙 집합을 생성하는 데 도움이 되도록 일반적인 시나리오에 대한 몇 가지 방화벽 유형을 정의하는 샘플 규칙 집합을 [.filename]#/etc/rc.firewall#에 제공합니다. IPFW는 고급 사용자가 특정 환경의 보안 요구 사항을 충족하는 맞춤형 규칙 집합을 만드는 데 사용할 수 있는 강력한 구문을 제공합니다.

이 섹션에서는 IPFW를 사용 설정하는 방법을 설명하고, 규칙 구문에 대한 개요를 제공하며, 일반적인 구성 시나리오에 대한 몇 가지 규칙 집합을 보여 줍니다.

[[firewalls-ipfw-enable]]
=== IPFW 활성화하기

IPFW는 커널 로딩이 가능한 모듈 형태로 기본 FreeBSD 설치에 포함되어 있으므로, IPFW를 활성화하기 위해 커스텀 커널이 필요하지 않습니다.

IPFW 지원을 사용자 지정 커널에 정적으로 컴파일하려는 사용자의 경우 <<firewalls-ipfw-kernelconfig>>을 참조하세요.

부팅 시 IPFW를 사용하도록 시스템을 구성하려면 [.filename]#/etc/rc.conf#에 `firewall_enable=“YES”`를 추가합니다:

[source, shell]
....
# sysrc firewall_enable="YES"
....

FreeBSD에서 제공하는 기본 방화벽 유형 중 하나를 사용하려면 유형을 지정하는 내용을 추가합니다:

[source, shell]
....
# sysrc firewall_type="open"
....

사용 가능한 유형은:

* `open`: 모든 트래픽을 통과시킵니다.
* `client`: 이 장비만 보호합니다.
* `simple`: 전체 네트워크를 보호합니다.
* `closed`: 루프백 인터페이스를 제외한 IP 트래픽을 완전히 비활성화합니다.
* `workstation`: 상태분석형 규칙을 이용해 이 장비만 보호합니다.
* `UNKNOWN`: 방화벽 규칙의 로딩을 비활성화합니다.
* [.filename]#filename#: 방화벽 규칙 집합이 포함된 파일의 전체 경로입니다.

`firewall_type`이 `client` 또는 `simple`으로 설정된 경우, [.filename]#/etc/rc.firewall#에 있는 기본 규칙을 시스템 구성에 맞게 수정합니다.

`filename` 유형은 사용자 정의 규칙 집합을 로드하는 데 사용됩니다.

사용자 지정 규칙 집합을 로드하는 다른 방법은 `firewall_script` 변수를 IPFW 명령이 포함된 _실행 가능한 스크립트_의 절대 경로로 설정하는 것입니다. 이 섹션에 사용된 예제에서는 `firewall_script`가 [.filename]#/etc/ipfw.rules#로 설정되어 있다고 가정합니다:

[source, shell]
....
# sysrc firewall_script="/etc/ipfw.rules"
....

man:syslogd[8]를 통해 로깅을 활성화하려면 다음을 포함시키세요:

[source, shell]
....
# sysrc firewall_logging="YES"
....

[WARNING]
====
`log` 옵션이 있는 방화벽 규칙만 기록됩니다. 기본 규칙에는 이 옵션이 포함되어 있지 않으므로 수동으로 추가해야 합니다. 따라서 로깅을 위해 기본 규칙 집합을 편집하는 것이 좋습니다. 또한 로그가 별도의 파일에 저장되는 경우 로그 로테이션이 필요할 수 있습니다.
====

로깅 제한을 설정할 수 있는 [.filename]#/etc/rc.conf# 변수는 없습니다. 연결 시도당 규칙이 기록되는 횟수를 제한하려면 [.filename]#/etc/sysctl.conf#에서 다음 내용을 사용하여 횟수를 지정하세요:

[source, shell]
....
# echo "net.inet.ip.fw.verbose_limit=5" >> /etc/sysctl.conf
....

‘ipfw0’이라는 전용 인터페이스를 통해 로깅을 사용하려면 [.filename]#/etc/rc.conf#에 이 줄을 추가하세요:

[source, shell]
....
# sysrc firewall_logif="YES"
....

그런 다음 tcpdump를 사용하여 기록되는 내용을 확인합니다:

[source, shell]
....
# tcpdump -t -n -i ipfw0
....

[TIP]
====

tcpdump를 첨부하지 않는 한 로깅으로 인한 오버헤드는 없습니다.
====

필요한 내용을 편집, 저장한 후 방화벽을 시작합니다. 지금 로깅 제한을 사용하려면 위에 지정된 `sysctl` 값도 설정하세요:

[source, shell]
....
# service ipfw start
# sysctl net.inet.ip.fw.verbose_limit=5
....

[[firewalls-ipfw-rules]]
=== IPFW 규칙 문법

패킷이 IPFW 방화벽에 들어오면 규칙 세트의 첫 번째 규칙과 비교하여 한 번에 하나의 규칙을 순서대로 위에서 아래로 이동하면서 확인합니다. 패킷이 규칙의 선택 매개변수와 일치하면 규칙의 동작이 실행되고 해당 패킷에 대한 규칙 세트 검색이 종료됩니다. 이를 “첫 번째 일치 승리”라고 합니다. 패킷이 어떤 규칙과도 일치하지 않는 경우, 모든 패킷을 거부하고 자동으로 폐기하는 필수 IPFW 기본 규칙 번호 65535에 의해 패킷이 포착됩니다. 그러나 패킷이 `count`, `skipto` 또는 `tee` 키워드가 포함된 규칙과 일치하면 검색이 계속됩니다. 이러한 키워드가 규칙 처리에 미치는 영향에 대한 자세한 내용은 man:ipfw[8]을 참조하세요.

IPFW 규칙을 만들 때 키워드는 다음 순서로 작성해야 합니다. 일부 키워드는 필수이고 다른 키워드는 선택 사항입니다. 대문자로 표시된 단어는 변수를 나타내며 소문자로 표시된 단어는 그 뒤에 오는 변수 앞에 와야 합니다. ‘+##’ 기호는 댓글의 시작을 표시하는 데 사용되며 규칙의 끝이나 자체 줄에 표시할 수 있습니다. 빈 줄은 무시됩니다.

`_CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS_`

이 섹션에서는 이러한 키워드와 해당 옵션에 대한 개요를 제공합니다. 가능한 모든 옵션의 전체 목록은 아닙니다. IPFW 규칙을 만들 때 사용할 수 있는 규칙 구문에 대한 전체 설명은 man:ipfw[8]를 참조하세요.

CMD::
모든 규칙은 `ipfw add`로 시작해야 합니다.

RULE_NUMBER::
각 규칙은 `1`에서 `65534` 사이의 숫자와 연관되어 있습니다. 이 번호는 규칙 처리 순서를 나타내는 데 사용됩니다. 여러 규칙이 동일한 번호를 가질 수 있으며, 이 경우 규칙이 추가된 순서에 따라 적용됩니다.

SET_NUMBER::
각 규칙은 `0`에서 `31` 사이의 세트 번호와 연결됩니다. 세트는 개별적으로 비활성화하거나 활성화할 수 있으므로 규칙 집합을 빠르게 추가하거나 삭제할 수 있습니다. SET_NUMBER를 지정하지 않으면 규칙이 `0` 세트에 추가됩니다.

ACTION::
규칙은 다음 작업 중 하나와 연결할 수 있습니다. 패킷이 규칙의 선택 기준과 일치하면 지정된 작업이 실행됩니다.
+
`allow | accept | pass | permit`: 이 키워드는 동등한 키워드이며 규칙과 일치하는 패킷을 허용합니다.
+
`check-state`: 동적 상태 테이블에 대해 패킷을 확인합니다. 일치하는 항목이 발견되면 이 동적 규칙을 생성한 규칙과 관련된 작업을 실행하고, 그렇지 않으면 다음 규칙으로 이동합니다. `check-state` 규칙에는 선택 기준이 없습니다. 규칙 집합에 `check-state` 규칙이 없는 경우 동적 규칙 테이블은 첫 번째 `keep-state` 또는 `limit` 규칙에서 확인됩니다.
+
`count`: 규칙과 일치하는 모든 패킷에 대한 카운터를 업데이트합니다. 검색은 다음 규칙으로 계속됩니다.
+
`deny | drop`: 이 규칙과 일치하는 패킷은 조용히 폐기됩니다.
+
추가 작업을 사용할 수 있습니다. 자세한 내용은 man:ipfw[8]을 참조하세요.

LOG_AMOUNT::
패킷이 `log` 키워드가 있는 규칙과 일치하면, `SECURITY`라는 이름으로 man:syslogd[8]에 메시지가 기록됩니다. 로깅은 특정 규칙에 대해 기록된 패킷 수가 지정된 LOG_AMOUNT를 초과하지 않는 경우에만 발생합니다. LOG_AMOUNT를 지정하지 않으면 `net.inet.ip.fw.verbose_limit`의 값에서 제한을 가져옵니다. 값이 0이면 로깅 제한이 제거됩니다. 제한에 도달하면 `ipfw resetlog`를 사용하여 해당 규칙에 대한 로깅 카운터 또는 패킷 카운터를 지우면 로깅을 다시 활성화할 수 있습니다.
+
[NOTE]
====
로깅은 다른 모든 패킷 매칭 조건이 충족된 후 패킷에 대한 최종 작업을 수행하기 전에 수행됩니다. 관리자는 로그온을 활성화할 규칙을 결정합니다.
====

PROTO::
이 옵션은 [.filename]#/etc/protocols#에 있는 프로토콜 이름이나 번호를 지정하는 데 사용할 수 있습니다.

SRC::
`from` 키워드 뒤에는 소스 주소 또는 소스 주소를 나타내는 키워드가 와야 합니다. 주소는 `any`, `me`(이 시스템의 인터페이스에 구성된 모든 주소), `me6`(이 시스템의 인터페이스에 구성된 모든 IPv6 주소) 또는 주소 목록이 포함된 조회 테이블의 번호 뒤에 `table`로 나타낼 수 있습니다. IP 주소를 지정할 때 선택적으로 그 뒤에 CIDR 마스크 또는 서브넷 마스크를 붙일 수 있습니다. 예를 들어 `1.2.3.4/25` 또는 `1.2.3.4:255.255.255.128`입니다.

SRC_PORT::
추가적인 소스 포트는 [.filename]#/etc/services#의 포트 번호 또는 이름을 사용하여 지정할 수 있습니다.

DST::
‘to’ 키워드 뒤에는 목적지 주소 또는 목적지 주소를 나타내는 키워드가 와야 합니다. SRC 섹션에 설명된 것과 동일한 키워드와 주소를 사용하여 목적지를 설명할 수 있습니다.

DST_PORT::
선택적 대상 포트는 [.filename]#/etc/services#의 포트 번호 또는 이름을 사용하여 지정할 수 있습니다.

OPTIONS::
소스 및 목적지 뒤에 여러 키워드를 붙일 수 있습니다. 이름에서 알 수 있듯이 옵션은 선택 사항입니다. 일반적으로 사용되는 옵션으로는 패킷 흐름의 방향을 지정하는 `in` 또는 `out`, ICMP 메시지 유형이 뒤따르는 `icmptypes`, `keep-state`가 있습니다.
+
`keep-state` 규칙과 일치하면 방화벽은 동일한 프로토콜을 사용하는 원본과 대상 주소 및 포트 간의 양방향 트래픽을 일치시키는 동적 규칙을 생성합니다.
+
동적 규칙 기능은 수많은 동적 규칙을 열어주는 SYN-flood 공격으로 인한 리소스 고갈에 취약합니다. IPFW로 이러한 유형의 공격에 대응하려면 `limit`을 사용하십시오. 이 옵션은 열려 있는 동적 규칙을 확인하여 이 규칙과 IP 주소 조합이 발생한 횟수를 계산하여 동시 세션 수를 제한합니다. 이 횟수가 `limit`에 지정된 값보다 크면 패킷이 삭제됩니다.
+
수십 가지 옵션을 사용할 수 있습니다. 사용 가능한 각 옵션에 대한 설명은 man:ipfw[8]을 참조하세요.

=== 규칙 집합 예시

이 섹션에서는 [.filename]#/etc/ipfw.rules#라는 이름의 상태분석형 방화벽 규칙집합 스크립트를 만드는 방법을 설명합니다. 이 예제에서 모든 연결 규칙은 방향을 명확히 하기 위해 `in` 또는 `out`을 사용합니다. 또한 패킷이 이동하는 인터페이스를 지정하기 위해 `via` _interface-name_을 사용합니다.

[NOTE]
====
방화벽 규칙 집합을 처음 만들거나 테스트할 때는 이 튜너블을 임시로 설정하는 것이 좋습니다:

[.programlisting]
....
net.inet.ip.fw.default_to_accept="1"
....

이렇게 하면 man:ipfw[8]의 기본 정책이 기본값인 `deny ip from any to any`보다는 허용적으로 설정되어 재부팅 직후 접근이 차단될 가능성이 낮아집니다.
====

방화벽 스크립트는 본 셸 스크립트(Bourne shell script)라는 것을 나타내는 선언으로 시작하여 기존 규칙을 모두 플러시합니다. 그런 다음 `cmd` 변수를 생성하여 모든 규칙의 시작 부분에 `ipfw add`를 입력할 필요가 없도록 합니다. 또한 인터넷에 연결된 인터페이스의 이름을 나타내는 `pif` 변수를 정의합니다.

[.programlisting]
....
#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # interface name of NIC attached to Internet
....

처음 두 규칙은 신뢰할 수 있는 내부 인터페이스와 루프백 인터페이스의 모든 트래픽을 허용합니다:

[.programlisting]
....
# Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0
....

다음 규칙은 패킷이 동적 규칙 테이블의 기존 항목과 일치하는 경우 패킷의 통과를 허용합니다:

[.programlisting]
....
$cmd 00101 check-state
....

다음 규칙 세트는 내부 시스템이 인터넷의 호스트에 만들 수 있는 상태분석형 연결을 정의합니다:

[.programlisting]
....
# Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP's DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif
....

다음 규칙 세트는 인터넷 호스트에서 내부 네트워크로의 연결을 제어합니다. 일반적으로 공격과 관련된 패킷을 거부하는 것으로 시작한 다음 특정 유형의 연결을 명시적으로 허용합니다. 인터넷에서 시작되는 모든 승인된 서비스는 플러딩을 방지하기 위해 `limit`를 사용합니다.

[.programlisting]
....
# Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D & E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios services.
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP's DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif
....

마지막 규칙은 규칙 집합의 규칙 중 어떤 규칙과도 일치하지 않는 모든 패킷을 기록합니다:

[.programlisting]
....
# Everything else is denied and logged
$cmd 00999 deny log all from any to any
....

[[in-kernel-nat]]
=== In-Kernel NAT

FreeBSD의 IPFW 방화벽에는 두 가지 NAT 구현이 있습니다: 사용자 공간 구현인 man:natd[8]와 더 최근의 In-Kernel NAT 구현입니다. 둘 다 IPFW와 함께 작동하여 네트워크 주소 변환을 제공합니다. 이는 인터넷 연결 공유 솔루션을 제공하는 데 사용할 수 있으므로 여러 내부 컴퓨터가 단일 공용 IP 주소를 사용하여 인터넷에 연결할 수 있습니다.

이렇게 하려면 인터넷에 연결된 FreeBSD 머신이 게이트웨이 역할을 해야 합니다. 이 시스템에는 두 개의 NIC가 있어야 하며, 하나는 인터넷에 연결되고 다른 하나는 내부 LAN에 연결됩니다. LAN에 연결된 각 머신은 https://www.ietf.org/rfc/rfc1918.txt[RFC 1918]에 정의된 대로 개인 네트워크 공간에 IP 주소를 할당받아야 합니다.

IPFW의 In-Kernel NAT 기능을 활성화하려면 몇 가지 추가 구성이 필요합니다. 부팅 시 In-Kernel NAT 지원을 활성화하려면 [.filename]#/etc/rc.conf#에서 다음을 설정해야 합니다:

[.programlisting]
....
gateway_enable="YES"
firewall_enable="YES"
firewall_nat_enable="YES"
....

[NOTE]
====
`firewall_nat_enable`이 설정되어 있지만 `firewall_enable`이 설정되어 있지 않으면 아무 효과도 없고 아무 일도 하지 않습니다. 이는 커널 내 NAT 구현이 IPFW와만 호환되기 때문입니다.
====

규칙 집합에 상태 저장 규칙이 포함된 경우 NAT 규칙의 위치가 중요하며 `skipto` 액션이 사용됩니다. `skipto` 액션에는 어떤 규칙으로 건너뛸지 알 수 있도록 규칙 번호가 필요합니다. 아래 예제는 이전 섹션에 표시된 방화벽 규칙 집합을 기반으로 합니다. In-Kernel NAT에 대한 방화벽을 구성하기 위해 몇 가지 항목을 추가하고 기존 규칙을 일부 수정합니다. 먼저 skipto 규칙 번호, `keep-state` 옵션, 규칙 수를 줄이는 데 사용되는 TCP 포트 목록을 나타내는 몇 가지 변수를 추가합니다.

[.programlisting]
....
#!/bin/sh
ipfw -q -f flush
cmd="ipfw -q add"
skip="skipto 1000"
pif=dc0
ks="keep-state"
good_tcpo="22,25,37,53,80,443,110"
....

In-Kernel NAT를 사용하려면, IPFW에 In-Kernel NAT 기능을 제공하기 위해, 커널 모듈로 구현된 라이브러리인 man:libalias[3]의 아키텍처로 인해 TCP 세그먼트 오프로딩(TSO)을 비활성화해야 합니다. TSO는 man:ifconfig[8]를 사용하여 네트워크 인터페이스별로 비활성화하거나 man:sysctl[8]을 사용하여 시스템 전체에서 비활성화할 수 있습니다. 시스템 전체에서 TSO를 비활성화하려면 [.filename]#/etc/sysctl.conf#에 다음과 같이 설정해야 합니다:

[.programlisting]
....
net.inet.tcp.tso="0"
....

NAT 인스턴스도 구성합니다. 각각 고유한 구성으로 여러 개의 NAT 인스턴스를 가질 수 있습니다. 이 예제에서는 NAT 인스턴스 번호 1인 NAT 인스턴스 하나만 필요합니다. 구성에는 다음과 같은 몇 가지 옵션을 사용할 수 있습니다: 공용 인터페이스를 나타내는 `if`, 별칭 포트와 로컬 포트 번호가 동일하게 매핑되도록 하는 `same_ports`, 등록되지 않은(개인) 주소 공간만 NAT 인스턴스에서 처리하도록 하는 `unreg_only`, IPFW 머신의 공인 IP 주소가 변경되더라도 작동하는 NAT 인스턴스를 유지하는 데 도움이 되는 `reset` 등이 있습니다. 단일 NAT 인스턴스 구성에 전달할 수 있는 모든 가능한 옵션은 man:ipfw[8]을 참조하세요. 상태분석형 NAT 방화벽을 구성할 때는 추가 처리를 위해 변환된 패킷을 방화벽에 재주입할 수 있도록 허용해야 합니다. 이는 방화벽 스크립트 시작 시 `one_pass` 동작을 비활성화하면 됩니다.

[.programlisting]
....
ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset
....

인바운드 NAT 규칙은 신뢰할 수 있는 인터페이스와 루프백 인터페이스의 모든 트래픽을 허용하는 두 규칙의 _뒤에_ 삽입되지만 `check-state` 규칙의 _앞에_ 삽입됩니다. 이 NAT 규칙에 대해 선택한 규칙 번호(이 예제에서는 `100`)가 처음 세 규칙보다 높고 `check-state` 규칙보다 낮은 것이 중요합니다. 또한, In-Kernel NAT의 동작으로 인해 재조립 규칙은 첫 번째 NAT 규칙 바로 앞과 신뢰할 수 있는 인터페이스의 트래픽을 허용하는 규칙 뒤에 배치하는 것이 좋습니다. 일반적으로 IP 조각화는 발생하지 않아야 하지만 IPSEC/ESP/GRE 터널링 트래픽을 처리할 때는 조각화가 발생할 수 있으며, 전체 패킷을 In-Kernel NAT 기능으로 넘기기 전에 조각을 재조립해야 합니다.

[NOTE]
====
재조립 규칙은 사용자 공간 man:natd[8]에서는 필요하지 않은데, 이는 man:ipfw[8]에도 명시된 것처럼 IPFW `divert` 액션의 내부 동작이 이미 소켓으로 전달되기 전에 패킷 재조립을 처리하기 때문입니다.

이 예제에서 사용된 NAT 인스턴스 및 규칙 번호가 [.filename]#rc.firewall#에서 만든 기본 NAT 인스턴스 및 규칙 번호와 일치하지 않습니다. [.filename]#rc.firewall#은 FreeBSD에 있는 기본 방화벽 규칙을 설정하는 스크립트입니다.
====

[.programlisting]
....
$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassemble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state
....

아웃바운드 규칙은 규칙 `1000`에서 규칙 처리가 계속됨을 나타내는 `$skip` 변수로 `allow` 동작을 대체하도록 수정되었습니다. 7개의 `tcp` 규칙은 `$good_tcpo` 변수에 허용된 7개의 아웃바운드 포트가 포함되어 있으므로 규칙 `125`로 대체되었습니다.

[NOTE]
====
IPFW의 성능은 규칙 집합에 존재하는 규칙의 수에 따라 크게 결정된다는 점을 기억하세요.
====

[.programlisting]
....
# Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks
....

인바운드 규칙은 인바운드 및 아웃바운드 규칙을 모두 잡기 위해 `via $pif`를 제거하는 맨 마지막 규칙을 제외하고는 동일하게 유지됩니다. NAT 규칙은 이 마지막 아웃바운드 규칙을 따라야 하며, 마지막 규칙보다 번호가 높아야 하고, 규칙 번호는 `skipto` 액션에서 참조해야 합니다. 이 규칙 집합에서 규칙 번호 `1000`은 NAT 처리를 위해 구성된 인스턴스로 모든 패킷을 전달하여 처리합니다. 다음 규칙은 NAT 처리를 거친 모든 패킷을 통과하도록 허용합니다.

[.programlisting]
....
$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any
....

이 예에서 규칙 `100`, `101`, `125`, `1000` 및 `1001`은 아웃바운드 및 인바운드 패킷의 주소 변환을 제어하여 동적 상태 테이블의 항목에 항상 개인 LANIP 주소가 등록되도록 합니다.

포트 80을 통해 새로운 아웃바운드 HTTP 세션을 초기화하는 내부 웹 브라우저를 생각해 봅시다. 첫 번째 아웃바운드 패킷이 방화벽에 들어올 때, 이 패킷은 들어오는 방향이 아니라 나가는 방향이기 때문에 규칙 `100`과 일치하지 않습니다. 이 패킷은 첫 번째 패킷이고 아직 동적 상태 테이블에 게시되지 않았기 때문에 규칙 `101`을 통과합니다. 패킷은 허용된 포트에서 아웃바운드되고 내부 LAN의 소스 IP 주소를 가지고 있기 때문에 규칙 `125`와 최종적으로 일치합니다. 이 규칙과 일치하면 두 가지 작업이 수행됩니다. 먼저 `keep-state` 동작으로 동적 상태 테이블에 항목이 추가되고 지정된 동작인 `skipto rule 1000`이 실행됩니다. 다음으로 패킷이 NAT를 거쳐 인터넷으로 전송됩니다. 이 패킷은 대상 웹 서버로 이동하여 응답 패킷이 생성되어 다시 전송됩니다. 이 새 패킷은 규칙 세트의 맨 위에 들어갑니다. 이 패킷은 규칙 `100`과 일치하며 대상 IP 주소가 원래 내부 주소로 다시 매핑됩니다. 그런 다음 `check-state` 규칙에 의해 처리되고 테이블에서 기존 세션으로 발견되어 LAN으로 릴리스됩니다.

인바운드 측에서 규칙 집합은 잘못된 패킷을 거부하고 승인된 서비스만 허용해야 합니다. 인바운드 규칙과 일치하는 패킷은 동적 상태 테이블에 게시되고 패킷은 LAN으로 릴리스됩니다. 응답으로 생성된 패킷은 `check-state` 규칙에 의해 기존 세션에 속한 것으로 인식됩니다. 그런 다음 `1000` 규칙으로 전송되어 NAT를 거친 후 아웃바운드 인터페이스로 릴리스됩니다.

[NOTE]
====
사용자 공간의 man:natd[8]에서 in-Kernel NAT로 전환하는 것은 처음에는 매끄럽게 보일 수 있지만 작은 문제가 있습니다. 기본 커널(GENERIC kernel)을 사용할 때, [.filename]#/etc/rc.conf#에서 `firewall_nat_enable`이 활성화되면 IPFW는 [.filename]#libalias.ko# 커널 모듈을 로드합니다. [.filename]#libalias.ko# 커널 모듈은 기본 NAT 기능만 제공하는 반면, 사용자 공간 구현 man:natd[8]는 추가 구성 없이 사용자 공간 라이브러리에서 모든 NAT 기능을 사용할 수 있습니다. 모든 기능은 표준 [.filename]#libalias.ko# 커널 모듈 외에 필요할 때 추가로 로드할 수 있는 다음 커널 모듈을 참조합니다: [.filename]#alias_ftp.ko#, [.filename]#alias_bbt.ko#, [.filename]#skinny.ko#, [.filename]#irc.ko#, [.filename]#alias_pptp.ko# 및 [.filename]#alias_smedia.ko#를 [.filename]#/etc/rc.conf#에서 `kld_list` 지시어를 사용하여 로드합니다. 커스텀 커널을 사용하는 경우 커널에서 `options LIBALIAS`를 사용하여 사용자 공간 라이브러리의 전체 기능을 컴파일할 수 있습니다.
====

==== 포트 리디렉션

일반적으로 NAT의 단점은 인터넷에서 LAN 클라이언트에 액세스할 수 없다는 것입니다. LAN의 클라이언트는 밖으로 나가는 연결은 할 수 있지만 들어오는 연결은 받을 수 없습니다. 이는 LAN 클라이언트 컴퓨터 중 하나에서 인터넷 서비스를 실행하려고 할 때 문제가 됩니다. 이 문제를 해결하는 간단한 방법은 NAT 제공 머신에서 선택한 인터넷 포트를 LAN 클라이언트로 리디렉션하는 것입니다.

예를 들어, IRC 서버는 클라이언트 `A`에서 실행되고 웹 서버는 클라이언트 `B`에서 실행됩니다. 이 기능이 제대로 작동하려면 포트 6667(IRC)과 80(HTTP)에서 수신된 연결이 각 컴퓨터로 리디렉션되어야 합니다.

In-Kernel 를 사용하면 모든 구성이 NAT 인스턴스 구성에서 이루어집니다. In-Kernel NAT 인스턴스가 사용할 수 있는 전체 옵션 목록은 man:ipfw[8]를 참조하세요. IPFW 구문은 natd의 구문을 따릅니다. `redirect_port`의 구문은 다음과 같습니다:

[.programlisting]
....
redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]
....

위의 예제의 설정을 구성하려면 인수는 다음과 같아야 합니다:

[.programlisting]
....
redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80
....

위의 규칙 집합에서 NAT 인스턴스 1의 구성에 이러한 인수를 추가하면 TCP 포트가 IRC 및 HTTP 서비스를 실행하는 LAN 클라이언트 머신으로 포트 포워딩됩니다.

[.programlisting]
....
ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80
....

개별 포트에 대한 포트 범위는 `redirect_port`로 표시할 수 있습니다. 예를 들어 _tcp 192.168.0.2:2000-3000 2000-3000_은 포트 2000에서 3000으로 수신된 모든 연결을 클라이언트 `A`의 포트 2000에서 3000으로 리디렉션합니다.

==== 주소 리디렉션

주소 리디렉션은 둘 이상의 IP 주소를 사용할 수 있는 경우에 유용합니다. 각 LAN 클라이언트는 man:ipfw[8]를 통해 자체 외부 IP 주소를 할당할 수 있으며, 이를 통해 LAN 클라이언트에서 보내는 패킷을 적절한 외부 IP 주소로 다시 작성하고 특정 IP 주소로 들어오는 모든 트래픽을 특정 LAN 클라이언트로 리디렉션합니다. 이를 정적 NAT(static NAT)라고도 합니다. 예를 들어, `128.1.1.1`, `128.1.1.2`, `128.1.1.3` IP 주소를 사용할 수 있는 경우, `128.1.1.1`은 man:ipfw[8] 컴퓨터의 외부 IP 주소로 사용할 수 있고 `128.1.1.2`와 `128.1.1.3`은 LAN 클라이언트 `A`와 `B`로 다시 포워딩합니다.

`redirect_addr` 구문은 아래와 같으며, 여기서 `localIP`는 LAN 클라이언트의 내부 IP 주소, `publicIP`는 LAN 클라이언트에 해당하는 외부 IP 주소입니다.

[.programlisting]
....
redirect_addr localIP publicIP
....

이 예제에서 인수는 다음과 같습니다:

[.programlisting]
....
redirect_addr 192.168.0.2 128.1.1.2
redirect_addr 192.168.0.3 128.1.1.3
....

`redirect_port`와 마찬가지로 이러한 인수는 NAT 인스턴스 구성에 위치합니다. 주소 리디렉션을 사용하면 특정 IP 주소로 수신되는 모든 데이터가 리디렉션되므로 포트 리디렉션이 필요하지 않습니다.

man:ipfw[8] 머신의 외부 IP 주소는 활성 상태여야 하며 외부 인터페이스에 앨리어싱되어야 합니다. 자세한 내용은 man:rc.conf[5]를 참조하세요.

==== 사용자 공간 NAT

먼저 다음 문장부터 시작합시다: 사용자 공간 NAT 구현인 man:natd[8]는 In-kernel NAT보다 오버헤드가 더 많습니다. man:natd[8]가 패킷을 변환하려면 패킷을 커널에서 복사하고 다시 사용자 공간으로 복사해야 하므로 In-kernel NAT에는 없는 추가 오버헤드가 발생합니다.

부팅 시 사용자 공간 NAT 데몬 man:natd[8]를 활성화하려면 [.filename]#/etc/rc.conf#에 최소 다음과 같은 구성을 지정해야 합니다. 여기서 `natd_interface`는 인터넷에 연결된 NIC의 이름으로 설정됩니다. man:natd[8]의 man:rc[8] 스크립트는 동적 IP 주소가 사용되는지 자동으로 확인하고 이를 처리하도록 자체 구성합니다.

[.programlisting]
....
gateway_enable="YES"
natd_enable="YES"
natd_interface="rl0"
....

일반적으로, In-kernel NAT에 대해 설명한 위의 규칙 집합은 man:natd[8]와 함께 사용할 수도 있습니다. 예외는 In-kernel NAT 인스턴스 `(ipfw -q nat 1 config …)`의 구성인데, 이 기능은 `divert` 액션에 포함되어 있기 때문에 재조립 규칙 99와 함께 사용할 필요가 없습니다. 규칙 번호 100과 1000은 아래와 같이 조금씩 변경해야 합니다.

[.programlisting]
....
$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif
....

포트 또는 주소 리디렉션을 구성하려면 In-kernel NAT와 유사한 구문이 사용됩니다. 하지만 이제는 In-kernel NAT처럼 규칙 집합 스크립트에서 구성을 지정하는 대신 구성 파일에서 man:natd[8]를 구성하는 것이 가장 좋습니다. 이렇게 하려면 구성 파일의 경로를 지정하는 [.filename]#/etc/rc.conf#를 통해 추가 플래그를 전달해야 합니다.

[.programlisting]
....
natd_flags="-f /etc/natd.conf"
....

[NOTE]
====
지정된 파일에는 한 줄에 하나씩 구성 옵션 목록이 포함되어야 합니다. 구성 파일 및 사용 가능한 변수에 대한 자세한 내용은 man:natd[8]을 참조하세요. 다음은 한 줄에 하나씩 두 개의 예제 항목입니다:

[.programlisting]
....
redirect_port tcp 192.168.0.2:6667 6667
redirect_addr 192.168.0.3 128.1.1.3
....

====

[[firewalls-ipfw-cmd]]
=== IPFW 명령어

`ipfw`를 사용하여 활성 방화벽이 실행되는 동안 수동으로 단일 규칙을 추가하거나 삭제할 수 있습니다. 이 방법을 사용하면 시스템이 재부팅될 때 모든 변경 사항이 손실된다는 문제가 있습니다. 대신 모든 규칙을 파일에 작성하고 해당 파일을 사용하여 부팅 시 규칙을 로드하고 해당 파일이 변경될 때마다 현재 실행 중인 방화벽 규칙을 교체하는 것이 좋습니다.

`ipfw`는 실행 중인 방화벽 규칙을 콘솔 화면에 표시하는 유용한 방법입니다. IPFW 계정 기능은 각 규칙에 대한 카운터를 동적으로 생성하여 규칙과 일치하는 각 패킷을 계산합니다. 규칙을 테스트하는 과정에서 카운터와 함께 규칙을 나열하는 것은 규칙이 예상대로 작동하는지 확인하는 한 가지 방법입니다.

실행 중인 모든 규칙을 순서대로 나열하려면:

[source, shell]
....
# ipfw list
....

실행 중인 모든 규칙을 규칙이 마지막으로 일치한 시간의 타임스탬프와 함께 나열하려면:

[source, shell]
....
# ipfw -t list
....

다음 예제에는 일치하는 규칙에 대한 계정 정보 및 패킷 수가 규칙 자체와 함께 나열되어 있습니다. 첫 번째 열은 규칙 번호이고, 그 다음에는 일치하는 패킷 수와 바이트 수, 그 다음에는 규칙 자체입니다.

[source, shell]
....
# ipfw -a list
....

정적 규칙과 함께 동적 규칙을 나열하려면:

[source, shell]
....
# ipfw -d list
....

만료된 동적 규칙도 표시하려면:

[source, shell]
....
# ipfw -d -e list
....

카운터를 초기화하려면:

[source, shell]
....
# ipfw zero
....

숫자 _NUM_이 있는 규칙에 대해서만 카운터를 0으로 설정하려면:

[source, shell]
....
# ipfw zero NUM
....

==== 방화벽 메시지 기록하기

로깅 기능이 활성화되어 있어도 IPFW는 자체적으로 규칙 로그를 생성하지 않습니다. 방화벽 관리자는 규칙 집합에서 어떤 규칙을 기록할지 결정하고 해당 규칙에 `log` 키워드를 추가합니다. 일반적으로 거부 규칙만 기록됩니다. `log` 키워드를 규칙 집합의 마지막 규칙으로 포함되는 `ipfw default deny everything` 규칙에 복제하는 것이 일반적입니다. 이렇게 하면 규칙 집합의 규칙과 일치하지 않는 모든 패킷을 볼 수 있습니다.

로깅은 양날의 검입니다. 주의하지 않으면 로그 데이터가 지나치게 많거나 DoS 공격으로 인해 디스크가 로그 파일로 가득 찰 수 있습니다. 로그 메시지는 syslogd에 기록될 뿐만 아니라 루트 콘솔 화면에도 표시되어 곧 성가신 일이 됩니다.

`IPFIREWALL_VERBOSE_LIMIT=5` 커널 옵션은 지정된 규칙의 패킷 일치와 관련하여 man:syslogd[8]로 전송되는 연속 메시지 수를 제한합니다. 커널에서 이 옵션을 활성화하면 특정 규칙과 관련된 연속 메시지 수가 지정된 수로 제한됩니다. 200개의 동일한 로그 메시지로는 얻을 수 있는 것이 없습니다. 이 옵션을 5개로 설정하면 특정 규칙과 관련된 연속 메시지 5개가 syslogd에 기록되고 나머지 동일한 연속 메시지가 카운트되어 다음과 같은 문구와 함께 syslogd에 게시됩니다:

[.programlisting]
....
last message repeated 45 times
....

모든 로깅된 패킷 메시지는 기본적으로 [.filename]#/var/log/security#에 기록되며, 이는 [.filename]#/etc/syslog.conf#에 정의되어 있습니다.

[[firewalls-ipfw-rules-script]]
==== 규칙 스크립트 작성하기

대부분의 숙련된 IPFW 사용자는 규칙이 포함된 파일을 만들고 이를 스크립트로 실행할 수 있는 방식으로 코딩합니다. 이렇게 하면 방화벽 규칙을 활성화하기 위해 시스템을 재부팅할 필요 없이 방화벽 규칙을 대량으로 새로 고칠 수 있다는 것이 가장 큰 장점입니다. 이 방법은 필요한 만큼 절차를 실행할 수 있으므로 새 규칙을 테스트할 때 편리합니다. 스크립트이기 때문에 자주 사용하는 값을 변수로 치환할 수 있습니다.

이 예제 스크립트는 man:sh[1], man:csh[1] 및 man:tcsh[1] 셸에서 사용하는 구문과 호환됩니다. 변수 대체 필드 앞에는 달러 기호($)가 붙습니다. 변수 필드에는 $ 접두사가 없습니다. 변수 필드를 채울 값은 큰따옴표(“”)로 묶어야 합니다.

다음과 같이 규칙 파일을 시작하세요:

[.programlisting]
....
############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############
....

이 예제에서는 기호 대체 필드가 채워지는 방식에 중점을 두므로 내용 자체는 중요하지 않습니다.

위의 예가 [.filename]#/etc/ipfw.rules#에 있었다면 다음 명령으로 규칙을 다시 로드할 수 있습니다:

[source, shell]
....
# sh /etc/ipfw.rules
....

[.filename]#/etc/ipfw.rules#은 어디에나 위치할 수 있으며 파일 이름은 무엇이든 상관없습니다.

아래의 명령을 직접 실행해도 동일한 작업을 수행할 수 있습니다:

[source, shell]
....
# ipfw -q -f flush
# ipfw -q add check-state
# ipfw -q add deny all from any to any frag
# ipfw -q add deny tcp from any to any established
# ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state
# ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state
# ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state
....

[[firewalls-ipfw-kernelconfig]]
=== IPFW 커널옵션

커스텀 커널에 정적으로 IPFW 지원을 컴파일하려면 crossref:kernelconfig[kernelconfig,FreeBSD 커널 구성]의 지침을 참조하십시오. 커스텀 커널 구성 파일에 사용할 수 있는 옵션은 다음과 같습니다:

[.programlisting]
....
options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)
....

[NOTE]
====
위의 옵션은 기본적으로 모듈로 빌드되거나 튜너블을 사용하여 런타임에 설정할 수 있습니다.
====

[[firewalls-ipf]]
== IPFILTER (IPF)

IPF라고도 하는 IPFILTER는 크로스 플랫폼 오픈 소스 방화벽으로, FreeBSD, NetBSD, OpenBSD, Solaris(TM) 등 여러 운영 체제에 포팅되어 있습니다.

IPFILTER는 사용자 프로그램에서 제어 및 모니터링할 수 있는 커널 측 방화벽 및 NAT 메커니즘입니다. 방화벽 규칙은 ipf를 사용하여 설정하거나 삭제할 수 있고, NAT 규칙은 ipnat를 사용하여 설정하거나 삭제할 수 있으며, IPFILTER의 커널 부분에 대한 런타임 통계는 ipfstat를 사용하여 인쇄할 수 있고, ipmon을 사용하여 시스템 로그 파일에 IPFILTER 동작을 기록할 수 있습니다.

IPF는 원래 “마지막으로 일치하는 규칙이 승리”는 규칙 처리 로직을 사용하여 작성되었으며 상태 stateless 규칙만 사용했습니다. 그 이후로 IPF는 `quick` 및 `keep state` 옵션을 포함하도록 개선되었습니다.

IPF FAQ는 http://www.phildev.net/ipf/index.html[http://www.phildev.net/ipf/index.html]에서 확인할 수 있습니다. IPFilter 메일링 리스트의 검색 가능한 아카이브는 http://marc.info/?l=ipfilter[http://marc.info/?l=ipfilter]에서 확인할 수 있습니다.

핸드북의 이 섹션에서는 FreeBSD와 관련된 IPF에 초점을 맞춥니다. 여기서는 `quick` 및 `keep state` 옵션이 포함된 규칙의 예를 제공합니다.

=== IPF 활성화하기

IPF는 커널 로딩이 가능한 모듈로 기본 FreeBSD 설치에 포함되어 있으므로 IPF를 활성화하기 위해 커스텀 커널이 필요하지 않습니다.

커스텀 커널에 IPF 지원을 정적으로 컴파일하는 것을 선호하는 사용자는 crossref:kernelconfig[kernelconfig,FreeBSD 커널 구성하기]의 지침을 참조하십시오. 다음 커널 옵션을 사용할 수 있습니다:

[.programlisting]
....
options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK
....

여기서 `options IPFILTER`는 IPFILTER 지원을 활성화하고, `options IPFILTER_LOG`는 `log` 키워드가 있는 모든 규칙에 대해 [.filename]#ipl# 패킷 로깅 의사 장치를 사용하여 IPF 로깅을 활성화하며, `IPFILTER_LOOKUP`은 IP 조회 속도를 높이기 위해 IP 풀을 사용하고, `options IPFILTER_DEFAULT_BLOCK`은 방화벽 `pass` 규칙에 맞지 않는 모든 패킷이 차단되도록 기본 동작을 변경합니다.

부팅 시 IPF를 사용하도록 시스템을 구성하려면 [.filename]#/etc/rc.conf#에 다음 항목을 추가합니다. 이 항목은 로깅과 `default pass all`도 활성화합니다. 사용자 정의 커널을 컴파일하지 않고 기본 정책을 `block all`으로 변경하려면 규칙 집합 끝에 `block all` 규칙을 추가하는 것을 잊지 마세요.

[.programlisting]
....
ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
ipv6_ipfilter_rules="/etc/ipf6.rules" # loads rules definition text file for IPv6
ipmon_enable="YES"                # Start IP monitor log
ipmon_flags="-Ds"                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP & port to names
....

NAT 기능이 필요한 경우 다음 줄도 추가합니다:

[.programlisting]
....
gateway_enable="YES"              # Enable as LAN gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat
....

이제 IPF를 실행합니다:

[.programlisting]
....
#  service ipfilter start
....

방화벽 규칙을 로드하려면 `ipf`를 사용하여 규칙 집합 파일의 이름을 지정합니다. 다음 명령을 사용하여 현재 실행 중인 방화벽 규칙을 바꿀 수 있습니다:

[source, shell]
....
# ipf -Fa -f /etc/ipf.rules
....

여기서 `-Fa`는 모든 내부 규칙 테이블을 플러시하고 `-f`는 로드할 규칙이 포함된 파일을 지정합니다.

이렇게 하면 시스템을 재부팅하지 않고도 사용자 지정 규칙 집합을 변경하고 실행 중인 방화벽을 규칙의 새 복사본으로 업데이트할 수 있습니다. 이 방법은 필요한 만큼 얼마든지 절차를 실행할 수 있으므로 새 규칙을 테스트할 때 편리합니다.

이 명령으로 사용할 수 있는 다른 플래그에 대한 자세한 내용은 man:ipf[8]을 참조하세요.

=== IPF 규칙 문법

이 섹션에서는 상태분석형(Stateful) 규칙을 만드는 데 사용되는 IPF 규칙 구문에 대해 설명합니다. 규칙을 만들 때, 규칙에 ‘quick’ 키워드가 나타나지 않는 한, 모든 규칙은 순서대로 읽혀지며, _마지막에 매칭되는 규칙_이 적용되는 규칙이라는 점에 유의하세요. 즉, 패킷을 일치시키는 첫 번째 규칙이 `pass`라 하더라도 나중에 일치하는 규칙이 `block`인 경우 패킷이 삭제됩니다. 샘플 규칙 세트는 [.filename]#/usr/share/examples/ipfilter#에서 찾을 수 있습니다.

규칙을 만들 때 `+#+` 문자는 주석의 시작을 표시하는 데 사용되며, 규칙의 끝이나 해당 규칙의 기능을 설명하기 위해, 또는 그 자체 줄에 표시될 수 있습니다. 빈 줄은 무시됩니다.

규칙에 사용되는 키워드는 왼쪽에서 오른쪽으로 특정 순서로 작성해야 합니다. 일부 키워드는 필수인 반면 다른 키워드는 선택 사항입니다. 일부 키워드에는 키워드 자체가 될 수도 있고 더 많은 하위 옵션이 포함될 수도 있는 하위 옵션이 있습니다. 키워드 순서는 다음과 같으며, 대문자로 표시된 단어는 변수를 나타내고 소문자로 표시된 단어는 그 뒤에 오는 변수 앞에 와야 합니다:

`_ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG|ICMP_TYPE keep state STATE_`

이 섹션에서는 이러한 각 키워드와 해당 옵션에 대해 설명합니다. 가능한 모든 옵션의 전체 목록은 아닙니다. IPF 규칙을 만들 때 사용할 수 있는 규칙 구문과 각 키워드 사용 예제에 대한 자세한 설명은 man:ipf[5]를 참조하세요.

ACTION::
액션 키워드는 해당 규칙과 일치하는 패킷이 있을 경우 수행할 작업을 나타냅니다. 모든 규칙에는 반드시 액션이 있어야 합니다. 다음과 같은 액션이 인식됩니다:
+
`block`: 패킷을 폐기함.
+
`pass`: 패킹의 통과를 허용함.
+
`log`: 로그를 기록함.
+
`count`: 규칙이 얼마나 자주 사용되는지 지표로 사용할 수 있는 패킷과 바이트의 수를 계산함.
+
`auth`: 다른 프로그램에서 추가 처리를 위해 패킷을 대기열에 넣음.
+
`call`: 보다 복잡한 작업을 허용하는 IPF에 내장된 함수에 대한 액세스를 제공.
+
`decapsulate`: 패킷의 내용을 처리하기 위해 모든 헤더를 제거함.

DIRECTION::
다음으로, 각 규칙은 아래의 키워드 중 하나를 사용하여 트래픽의 방향을 명시적으로 지정해야 합니다:
+
`in`: 인바운드 패킷에 대해 규칙이 적용.
+
`out`: 아웃바운드 패킷에 대해 규칙이 적용.
+
`all`: 양방향 모두 규칙이 적용.
+
시스템에 여러 인터페이스가 있는 경우 방향과 함께 인터페이스를 지정할 수 있습니다. 예를 들어 `in on fxp0`이 있습니다.

OPTIONS::
옵션은 선택 사항입니다. 그러나 여러 옵션을 지정하는 경우 여기에 표시된 순서대로 사용해야 합니다.
+
`log`: 지정된 ACTION을 수행할 때 패킷 헤더의 내용이 man:ipl[4] 패킷 로그 의사 장치에 기록됩니다.
+
`quick`: 패킷이 이 규칙과 일치하면 규칙에 지정된 ACTION이 발생하고 이 패킷에 대해 다음 규칙의 추가 처리가 수행되지 않습니다.
+
`on`: 뒤에는 man:ifconfig[8]에 표시된 인터페이스 이름이 와야 합니다. 이 규칙은 패킷이 지정된 인터페이스를 지정된 방향으로 통과하는 경우에만 일치합니다.
+
`log` 키워드를 사용할 때는 다음 한정자를 순서대로 사용할 수 있습니다:
+
`body`: 패킷 내용의 첫 128바이트가 헤더 뒤에 기록됨을 나타냅니다.
+
`first`: `log` 키워드가 `keep state` 옵션과 함께 사용되는 경우 상태 분석형 연결과 일치하는 모든 패킷이 아니라, 트리거 패킷만 기록되도록 이 옵션을 사용하는 것이 좋습니다.
+
오류 반환 메시지를 지정하는 추가 옵션을 사용할 수 있습니다. 자세한 내용은 man:ipf[5]를 참조하세요.

PROTO_TYPE::
프로토콜 유형은 선택 사항입니다. 그러나 규칙이 프로토콜 유형을 정의하기 때문에 SRC_PORT 또는 DST_PORT를 지정해야 하는 경우 필수입니다. 프로토콜 유형을 지정할 때는 `proto` 키워드 뒤에 프로토콜 번호 또는 [.filename]#/etc/protocols#의 이름을 사용합니다. 프로토콜 이름의 예로는 `tcp`, `udp`, `icmp` 등이 있습니다. 만약 PROTO_TYPE이 지정되었지만 SRC_PORT 또는 DST_PORT가 지정되지 않은 경우, 해당 프로토콜에 대해 모든 포트 번호가 적용됩니다.

SRC_ADDR::
‘from` 키워드는 필수이며 그 뒤에 패킷의 소스를 나타내는 키워드가 이어집니다. 소스는 호스트 이름, IP 주소 뒤에 CIDR 마스크, 주소 풀 또는 키워드 `all`이 될 수 있습니다. 예제는 man:ipf[5]를 참조하세요.
+
점 숫자 형식이나 마스크 길이 표기법과 같이 쉽게 표현되지 않는 IP 주소 범위를 일치시킬 수 있는 방법은 지원되지 않습니다. package:net-mgmt/ipcalc[] 패키지 또는 포트를 사용하면 CIDR 마스크 계산을 쉽게 할 수 있습니다. 추가 정보는 유틸리티 웹 페이지(http://jodies.de/ipcalc[http://jodies.de/ipcalc])에서 확인할 수 있습니다.

SRC_PORT::
소스의 포트 번호는 선택 사항입니다. 그러나 포트 번호를 사용하는 경우 규칙에 PROTO_TYPE을 먼저 정의해야 합니다. 또한 포트 번호 앞에는 `proto` 키워드가 와야 합니다.
+
다양한 비교 연산자가 지원됩니다: `=`(같음), `!=`(같지 않음), `<`(보다 작음), `>`(보다 큼), `<=`(작거나 같음), `>=`(크거나 같음) 등 다양한 비교 연산자가 지원됩니다.
+
포트 범위를 지정하려면 두 포트 번호를 `<>`(보다 작거나 큰 ), `><`(보다 크거나 작은) 또는 `:`(보다 크거나 같은, 보다 작거나 같은) 사이에 넣습니다.

DST_ADDR::
`to` 키워드는 필수이며 그 뒤에 패킷의 목적지를 나타내는 키워드가 이어집니다. SRC_ADDR과 유사하게 호스트 이름, IP 주소 뒤에 CIDR 마스크, 주소 풀 또는 키워드 `all`을 사용할 수 있습니다.

DST_PORT::
SRC_PORT와 마찬가지로 목적지의 포트 번호는 선택 사항입니다. 그러나 이 포트 번호를 사용하는 경우 규칙에 PROTO_TYPE을 먼저 정의해야 합니다. 또한 포트 번호 앞에는 `proto` 키워드가 와야 합니다.

TCP_FLAG|ICMP_TYPE::
`tcp`가 PROTO_TYPE으로 지정되면 플래그를 문자로 지정할 수 있으며, 각 문자는 연결 상태를 결정하는 데 사용되는 가능한 TCP 플래그 중 하나를 나타냅니다. 가능한 값은 다음과 같습니다: `S`(SYN), `A`(ACK), `P`(PSH), `F`(FIN), `U`(URG), `R`(RST), `C`(CWN), `E`(ECN).
+
‘icmp’가 PROTO_TYPE으로 지정되면 일치할 ICMP 유형을 지정할 수 있습니다. 허용되는 유형은 man:ipf[5]를 참조하세요.

STATE::
`pass` 규칙이 `keep state`를 가지고 있는 IPF는 동적 상태 테이블에 항목을 추가하고 연결과 일치하는 후속 패킷을 허용합니다. IPF는 TCP, UDP 및 ICMP 세션의 상태를 추적할 수 있습니다. IPF가 활성 세션의 일부라고 확신할 수 있는 패킷은 프로토콜이 다르더라도 모두 허용됩니다.
+
IPF에서는 공용 인터넷에 연결된 인터페이스를 통해 나가려는 패킷을 먼저 동적 상태 테이블에서 확인합니다. 패킷이 활성 세션 대화를 구성한 다음 예상 패킷과 일치하면 방화벽을 종료하고 세션 대화 흐름의 상태가 동적 상태 테이블에서 업데이트됩니다. 이미 활성화된 세션에 속하지 않은 패킷은 아웃바운드 규칙 집합에 대해 확인됩니다. 공용 인터넷에 연결된 인터페이스에서 들어오는 패킷은 먼저 동적 상태 테이블을 이용해 확인합니다. 패킷이 활성 세션을 구성하는 다음 예상 패킷과 일치하면 방화벽을 종료하고 세션 대화 흐름의 상태가 동적 상태 테이블에서 업데이트됩니다. 이미 활성화된 세션에 속하지 않는 패킷은 인바운드 규칙 집합을 써서 확인합니다.
+
`keep state` 뒤에 여러 키워드를 추가할 수 있습니다. 키워드를 사용하면 연결 제한 또는 연결 기간 설정 등 상태 저장 필터링을 제어하는 다양한 옵션을 설정할 수 있습니다. 사용 가능한 옵션 목록과 설명은 man:ipf[5]를 참조하세요.

=== 규칙 집합 예시

이 섹션에서는 ‘pass’ 규칙과 일치하는 서비스만 허용하고 다른 모든 서비스는 차단하는 예제 규칙 집합을 만드는 방법을 설명합니다.

FreeBSD는 내부 통신을 위해 루프백 인터페이스([.filename]#lo0#)와 IP 주소 `127.0.0.1`을 사용합니다. 방화벽 규칙 집합에는 이러한 내부적으로 사용되는 패킷의 자유로운 이동을 허용하는 규칙이 포함되어야 합니다:

[.programlisting]
....
# no restrictions on loopback interface
pass in quick on lo0 all
pass out quick on lo0 all
....

인터넷에 연결된 공용 인터페이스는 모든 아웃바운드 및 인바운드 연결의 액세스를 승인하고 제어하는 데 사용됩니다. 하나 이상의 인터페이스가 개인 네트워크에 연결되어 있는 경우, 이러한 내부 인터페이스에는 LAN에서 시작된 패킷이 내부 네트워크 간 또는 인터넷에 연결된 인터페이스로 흐르도록 허용하는 규칙이 필요할 수 있습니다. 규칙 집합은 신뢰할 수 있는 내부 인터페이스, 공용 인터페이스를 통한 아웃바운드 연결, 공용 인터페이스를 통한 인바운드 연결의 세 가지 주요 섹션으로 구성되어야 합니다.

이 두 가지 규칙은 모든 트래픽이 [.filename]#xl0#이라는 신뢰할 수 있는 LAN 인터페이스를 통과하도록 허용합니다:

[.programlisting]
....
# no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all
....

공용 인터페이스의 아웃바운드 및 인바운드 섹션에 대한 규칙은 가장 자주 일치하는 규칙이 덜 자주 일치하는 규칙 앞에 배치되어야 하며, 섹션의 마지막 규칙이 해당 인터페이스 및 방향에 대한 모든 패킷을 차단하고 로깅해야 합니다.

이 규칙 집합은 [.filename]#dc0#이라는 공용 인터페이스의 아웃바운드 섹션을 정의합니다. 이러한 규칙은 내부 시스템이 공용 인터넷 액세스를 위해 승인된 특정 서비스를 식별하고 상태를 유지합니다. 모든 규칙은 ‘quick’을 사용하며 적절한 포트 번호와 해당되는 경우 대상 주소를 지정합니다.

[.programlisting]
....
# interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x.x with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x.x port = 53 flags S keep state
pass out quick on dc0 proto udp from any to x.x.x.x port = 53 keep state

# Allow access to ISP's specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all
....

퍼블릭 인터페이스의 인바운드 섹션에 대한 이 규칙 예시는 바람직하지 않은 패킷을 모두 먼저 차단합니다. 이렇게 하면 마지막 규칙에 의해 기록되는 패킷 수가 줄어듭니다.

[.programlisting]
....
# interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D & E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81
....

`log first` 옵션이 있는 규칙에 기록된 메시지가 있을 때마다 `ipfstat -hio`를 실행하여 규칙이 일치한 횟수를 평가합니다. 일치하는 횟수가 많으면 시스템이 공격을 받고 있음을 나타낼 수 있습니다.

인바운드 섹션의 나머지 규칙은 인터넷에서 시작할 수 있는 연결을 정의합니다. 마지막 규칙은 이 섹션의 이전 규칙에서 명시적으로 허용되지 않은 모든 연결을 거부합니다.

[.programlisting]
....
# Allow traffic in from ISP's DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all
....

=== NAT 구성하기

NAT를 사용하려면 [.filename]#/etc/rc.conf#에 다음 구문을 추가하고 NAT 규칙이 포함된 파일 이름을 지정합니다:

[.programlisting]
....
gateway_enable="YES"
ipnat_enable="YES"
ipnat_rules="/etc/ipnat.rules"
....

NAT 규칙은 유연하며 상업용 및 가정용 사용자 모두의 요구에 맞게 다양한 기능을 수행할 수 있습니다. 여기에 제시된 규칙 구문은 일반적인 사용법을 보여주기 위해 단순화되었습니다. 전체 규칙 구문에 대한 설명은 man:ipnat[5]를 참조하세요.

NAT 규칙의 기본 구문은 다음과 같으며, 여기서 `map`은 규칙을 시작하고 _IF_는 외부 인터페이스의 이름으로 대체해야 합니다:

[.programlisting]
....
map IF LAN_IP_RANGE -> PUBLIC_ADDRESS
....

_LAN_IP_RANGE_는 내부 클라이언트에서 사용하는 IP 주소의 범위입니다. 일반적으로 `192.168.1.0/24`와 같은 개인 주소 범위입니다. _PUBLIC_ADDRESS_는 정적 외부 IP 주소이거나 _IF_에 할당된 IP 주소를 나타내는 키워드 `0/32`일 수 있습니다.

IPF에서는 패킷이 공용 목적지를 가지고 LAN을 통해 방화벽에 도착하면, 먼저 방화벽 규칙 집합의 아웃바운드 규칙을 통과합니다. 그런 다음 패킷은 위에서 아래로 읽혀지는 NAT 규칙 집합으로 전달되며, 여기서 가장 먼저 일치하는 규칙이 승리합니다. IPF는 패킷의 인터페이스 이름과 소스 IP 주소에 대해 각 NAT 규칙을 테스트합니다. 패킷의 인터페이스 이름이 NAT 규칙과 일치하면, 개인 LAN에서 패킷의 소스 IP 주소가 _LAN_IP_RANGE_에 지정된 IP 주소 범위에 속하는지 확인합니다. 일치하는 경우 패킷의 소스 IP 주소는 _PUBLIC_ADDRESS_에 지정된 공용 IP 주소로 재작성됩니다. IPF는 패킷이 인터넷에서 반환될 때, 추가 처리를 위해 방화벽 규칙으로 전달되기 전에 원래의 개인 IP 주소로 다시 매핑될 수 있도록 내부 NAT 테이블에 항목을 게시합니다.

내부 시스템이 많거나 서브넷이 여러개인 네트워크의 경우, 모든 사설 IP 주소를 하나의 공용 IP 주소로 퍼널링하는 과정에서 리소스 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해 두 가지 방법을 사용할 수 있습니다.

첫 번째 방법은 소스 포트로 사용할 포트 범위를 지정하는 것입니다. `portmap` 키워드를 추가하면 NAT가 지정된 범위의 소스 포트만 사용하도록 지시할 수 있습니다:

[.programlisting]
....
map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp 20000:60000
....

또는 `auto` 키워드를 사용하여 NAT가 사용 가능한 포트를 결정하도록 지시합니다:

[.programlisting]
....
map dc0 192.168.1.0/24 -> 0/32 portmap tcp/udp auto
....

두 번째 방법은 공개 주소 풀을 사용하는 것입니다. 이 방법은 LAN 주소가 너무 많아서 하나의 공용 주소에 넣을 수 없고 공용 IP 주소 블록을 사용할 수 있는 경우에 유용합니다. 이러한 공용 주소는 패킷의 주소가 나가는 도중 매핑될 때 NAT가 IP 주소를 선택하는 풀로 사용할 수 있습니다.

공인 IP 주소의 범위는 넷마스크 또는 CIDR 표기법을 사용하여 지정할 수 있습니다. 이 두 규칙은 동일합니다:

[.programlisting]
....
map dc0 192.168.1.0/24 -> 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -> 204.134.75.0/24
....

공개적으로 액세스할 수 있는 웹 서버 또는 메일 서버는 내부 네트워크 세그먼트로 분리하는 것이 일반적입니다. 이러한 서버의 트래픽은 여전히 NAT를 거쳐야 하지만 인바운드 트래픽을 올바른 서버로 보내려면 포트 리디렉션이 필요합니다. 예를 들어 내부 주소 `10.0.10.25`를 사용하는 웹 서버를 공용 IP 주소인 `20.20.20.5`에 매핑하려면 이 규칙을 사용합니다:

[.programlisting]
....
rdr dc0 20.20.20.5/32 port 80 -> 10.0.10.25 port 80
....

유일한 웹 서버인 경우, 이 규칙은 모든 외부 HTTP 요청을 `10.0.10.25`로 리디렉션하므로 이 규칙도 작동합니다:

[.programlisting]
....
rdr dc0 0.0.0.0/0 port 80 -> 10.0.10.25 port 80
....

IPF에는 NAT와 함께 사용할 수 있는 FTP 프록시가 내장되어 있습니다. 이 프록시는 모든 아웃바운드 트래픽에서 액티브 또는 패시브 FTP 연결 요청을 모니터링하고 FTP 데이터 채널에서 사용하는 포트 번호가 포함된 임시 필터 규칙을 동적으로 생성합니다. 따라서 FTP 연결을 위해 높은 수준의 포트를 광범위하게 열 필요가 없습니다.

이 예에서 첫 번째 규칙은 내부 LAN에서 아웃바운드 FTP 트래픽에 대해 프록시를 호출합니다. 두 번째 규칙은 방화벽에서 인터넷으로 FTP 트래픽을 전달하고, 세 번째 규칙은 내부 LAN의 모든 비-FTP 트래픽을 처리합니다:

[.programlisting]
....
map dc0 10.0.10.0/29 -> 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -> 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -> 0/32
....

FTP `map` 규칙은 NAT 규칙보다 먼저 적용되므로 패킷이 FTP 규칙과 일치하면 FTP 프록시는 임시 필터 규칙을 생성하여 FTP 세션 패킷을 통과시키고 NAT를 거치게 합니다. FTP가 아닌 모든 LAN 패킷은 FTP 규칙과 일치하지 않지만 세 번째 규칙과 일치하는 경우 NAT를 거칩니다.

FTP 프록시가 없으면 대신 다음 방화벽 규칙이 필요합니다. 프록시가 없으면 `1024` 이상의 모든 포트를 허용해야 한다는 점에 유의하세요:

[.programlisting]
....
# Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port > 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state
....

NAT 규칙이 포함된 파일을 편집할 때마다 `-CF`와 함께 `ipnat`를 실행하여 현재 NAT 규칙을 삭제하고 동적 번역 테이블의 내용을 플러시합니다. `-f`를 포함하고 로드할 NAT 규칙 집합의 이름을 지정합니다:

[source, shell]
....
# ipnat -CF -f /etc/ipnat.rules
....

NAT 통계를 화면에 표시하려면:

[source, shell]
....
# ipnat -s
....

현재 NAT 매핑 테이블을 확인하려면:

[source, shell]
....
# ipnat -l
....

자세한 설명 모드를 켜고 규칙 처리, 활성 규칙 및 테이블 항목과 관련된 정보를 표시하려면:

[source, shell]
....
# ipnat -v
....

=== IPF 통계보기

IPF에는 방화벽을 통과할 때 패킷 일치 규칙으로 수집된 통계를 검색하고 표시하는 데 사용할 수 있는 man:ipfstat[8]이 포함되어 있습니다. 통계는 방화벽이 마지막으로 시작된 이후 또는 `ipf -Z`를 사용하여 가장 최근 0으로 재설정된 이후를 집계합니다.

기본 `ipfstat` 출력은 다음과 같이 표시됩니다:

[source, shell]
....
input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state(in): kept 0 lost 0
 fragment state(out): kept 0 lost 0
 packet state(in): kept 169364 lost 0
 packet state(out): kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits(in): 1215208 (out): 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP cksum fails(in): 0 (out): 0
 Packet log flags set: (0)
....

몇 가지 옵션을 사용할 수 있습니다. 인바운드의 경우 `-i`, 또는 아웃바운드의 경우 `-o`와 함께 사용하면 명령어는 현재 설치되어 커널에서 사용 중인 적절한 필터 규칙 목록을 검색하여 표시합니다. 규칙 번호도 보려면 `-n`을 포함하세요. 예를 들어 `ipfstat -on`은 규칙 번호와 함께 아웃바운드 규칙 테이블을 표시합니다:

[source, shell]
....
@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state
....

각 규칙 앞에 `-h`를 포함하면 규칙이 일치한 횟수를 계산하여 표시합니다. 예를 들어, `ipfstat -oh`는 아웃바운드 내부 규칙 테이블을 표시하며, 각 규칙 앞에 사용 횟수를 추가합니다:

[source, shell]
....
2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state
....

man:top[1]과 유사한 형식으로 상태 테이블을 표시하려면 `ipfstat -t`를 사용합니다. 방화벽이 공격을 받고 있는 경우 이 옵션을 사용하면 공격 패킷을 식별하고 확인할 수 있습니다. 선택적 하위 플래그를 사용하면 실시간으로 모니터링할 대상 또는 소스 IP, 포트 또는 프로토콜을 선택할 수 있습니다. 자세한 내용은 man:ipfstat[8]을 참조하세요.

=== IPF 로깅

IPF는 방화벽의 로깅 정보를 사람이 읽을 수 있는 형식으로 작성하는 데 사용할 수 있는 `ipmon`을 제공합니다. 이를 사용하려면 먼저 `options IPFILTER_LOG`를 crossref:kernelconfig[kernelconfig,FreeBSD 커널 구성]의 지침에 따라 커스텀 커널에 추가해야 합니다.

이 명령은 일반적으로 과거 이벤트의 로그를 검토할 수 있도록 지속적인 시스템 로그 파일을 제공하기 위해 데몬 모드에서 실행됩니다. FreeBSD에는 시스템 로그를 자동으로 순환하는 man:syslogd[8] 기능이 내장되어 있기 때문에, 기본 [.filename]#rc.conf#의 `ipmon_flags` 문은 `-Ds`를 사용합니다:

[.programlisting]
....
ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP & port to names
....

로깅은 어떤 패킷이 삭제되었는지, 어떤 주소에서 왔는지, 어디로 이동했는지 등의 정보를 사후에 검토할 수 있는 기능을 제공합니다. 이 정보는 공격자를 추적하는 데 유용합니다.

[.filename]#rc.conf#에서 로깅 기능을 활성화하고 `service ipmon start`로 시작하면, IPF는 `log` 키워드가 포함된 규칙만 로깅합니다. 방화벽 관리자는 규칙 집합에서 어떤 규칙을 기록할지 결정하며 일반적으로 거부 규칙만 기록합니다. 규칙 집합의 마지막 규칙에 `log` 키워드를 포함하는 것이 일반적입니다. 이렇게 하면 규칙 집합의 규칙과 일치하지 않는 모든 패킷을 볼 수 있습니다.

기본적으로 `ipmon -Ds` 모드는 `local0`을 로깅 도구로 사용합니다. 다음 로깅 수준을 사용하여 로깅된 데이터를 더 분리할 수 있습니다:

[source, shell]
....
LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header
....

모든 데이터를 [.filename]#/var/log/ipfilter.log#에 기록하도록 IPF를 설정하려면 먼저 빈 파일을 생성합니다:

[source, shell]
....
# touch /var/log/ipfilter.log
....

그런 다음 모든 로깅된 메시지를 지정된 파일에 쓰려면 [.filename]#/etc/syslog.conf#에 다음 명령을 추가합니다:

[.programlisting]
....
local0.* /var/log/ipfilter.log
....

변경 사항을 활성화하고 man:syslogd[8]가 수정된 [.filename]#/etc/syslog.conf#를 읽도록 지시하려면 `service syslogd reload`를 실행합니다.

새 로그 파일을 회전시키기 위해 [.filename]#/etc/newsyslog.conf#를 편집하는 것을 잊지 마세요.

`ipmon`에서 생성된 메시지는 공백으로 구분된 데이터 필드로 구성됩니다. 모든 메시지에 공통으로 사용되는 필드는 다음과 같습니다:

. The date of packet receipt.
. The time of packet receipt. 시간, 분, 초, 분초 단위의 HH:MM:SS.F 형식입니다.
. 패킷을 처리한 인터페이스의 이름.
. `@0:17` 형식으로 된 그룹과 규칙의 규칙번호.
. The action: `p`는 통과됨, `b`는 차단됨, `S`는 짧은 패킷, `n`은 규칙과 일치하지 않음, `L`은 로그 규칙.
. 쉼표로 구분된 소스 주소와 포트 -> 기호, 대상 주소와 포트의 세 가지 필드로 작성된 주소. 예: `209.53.17.22,80 -> 198.73.220.17,1722`.
. 프로토콜의 이름이나 번호 다음에 오는 `PR`. 예: `PR tcp`.
. 헤더 길이와 패킷의 총 길이 다음에 오는 `len`. 예: `len 20 40`.

패킷이 TCP 패킷인 경우, 하이픈으로 시작하는 추가 필드에 설정된 플래그에 해당하는 문자가 이어집니다. 문자와 해당 플래그 목록은 man:ipf[5]를 참조하세요.

패킷이 ICMP 패킷인 경우 마지막에 두 개의 필드가 있는데, 첫 번째는 항상 “icmp”이고 그 다음에는 슬래시로 구분된 ICMP 메시지 및 하위 메시지 유형이 있습니다. 예: 연결할 수 없는 포트 메시지의 경우 `icmp 3/3`.

[[firewalls-blacklistd]]
== Blacklistd

blacklistd는 소켓을 수신 대기하면서 다른 데몬으로부터 연결 시도가 실패했거나 성공했다는 알림을 받는 데몬입니다. 열린 포트에서 너무 많은 연결 시도를 차단하는 데 가장 널리 사용됩니다. 대표적인 예로 인터넷에서 실행되는 SSH가 비밀번호를 추측하고 액세스 권한을 얻으려는 봇이나 스크립트로부터 많은 요청을 받는 경우를 들 수 있습니다. blacklistd를 사용하면 데몬이 방화벽에 알림을 보내 여러 번 시도한 후 단일 소스에서 과도한 연결 시도를 차단하는 필터 규칙을 만들 수 있습니다. blacklistd는 NetBSD에서 처음 개발되어 버전 7에 등장했습니다. FreeBSD 11은 NetBSD에서 blacklistd를 가져왔습니다.

이 장에서는 blacklistd를 설정하고 구성하는 방법을 설명하고 사용 방법에 대한 예제를 제공합니다. 독자는 규칙과 같은 기본 방화벽 개념에 익숙해야 합니다. 자세한 내용은 방화벽 챕터를 참조하세요. 예제에서는 PF가 사용되었지만, FreeBSD에서 사용할 수 있는 다른 방화벽도 blacklistd와 함께 작동할 수 있어야 합니다.

=== blacklistd 활성화하기

blacklistd의 기본 구성은 man:blacklistd.conf[5]에 저장됩니다. blacklistd의 런타임 동작을 변경하기 위해 다양한 명령줄 옵션도 사용할 수 있습니다. 재부팅 시에도 지속되는 구성은 [.filename]#/etc/blacklistd.conf#에 저장해야 합니다. 시스템 부팅 시 데몬을 활성화하려면 다음과 같이 [.filename]#/etc/rc.conf#에 `blacklistd_enable` 줄을 추가합니다:

[source, shell]
....
# sysrc blacklistd_enable=yes
....

서비스를 수동으로 시작하려면 다음 명령을 실행합니다:

[source, shell]
....
# service blacklistd start
....

=== Blacklistd 규칙 집합 만들기

Blacklistd에 대한 규칙은 한 줄당 하나의 항목으로 man:blacklistd.conf[5]에 구성됩니다. 각 규칙은 공백 또는 탭으로 구분된 튜플을 포함합니다. 규칙은 `local` 또는 `remote`에 속하며, 각각 blacklistd가 실행 중인 머신 또는 외부 소스에 적용됩니다.

==== 로컬 규칙

로컬 규칙에 대한 blacklistd.conf 항목의 예는 다음과 같습니다:

[.programlisting]
....
[local]
ssh             stream  *       *               *       3       24h
....

`[local]` 섹션 뒤에 오는 모든 규칙은 로컬 규칙(기본값)으로 처리되어 로컬 머신에 적용됩니다. `[remote]` 섹션을 발견하면 그 뒤에 오는 모든 규칙은 원격 컴퓨터 규칙으로 처리됩니다.

탭 또는 공백으로 구분된 7개의 필드가 규칙을 정의합니다. 처음 4개의 필드는 차단 목록에 추가해야 하는 트래픽을 식별합니다. 그 뒤에 나오는 세 개의 필드는 backlistd의 동작을 정의합니다. 와일드카드는 별표(`*`)로 표시되며 이 필드에 있는 모든 항목과 일치합니다. 첫 번째 필드는 위치를 정의합니다. 로컬 규칙에서는 네트워크 포트입니다. 위치 필드의 구문은 다음과 같습니다:

[.programlisting]
....
[address|interface][/mask][:port]
....

주소는 숫자 형식의 IPv4 또는 대괄호 안의 IPv6로 지정할 수 있습니다. `_em0_`와 같은 인터페이스 이름도 사용할 수 있습니다.

소켓 유형은 두 번째 필드에 의해 정의됩니다. TCP 소켓은 `stream` 유형인 반면, UDP는 `dgram`으로 표시됩니다. 위의 예에서는 SSH가 해당 프로토콜을 사용하기 때문에 TCP를 사용합니다.

프로토콜은 blacklistd 규칙의 세 번째 필드에 사용할 수 있습니다. 다음 프로토콜을 사용할 수 있습니다: `tcp`, `udp`, `tcp6`, `udp6` 또는 숫자. 예제에서와 같이 와일드카드는 특정 프로토콜로 트래픽을 구분할 이유가 없는 한 일반적으로 모든 프로토콜을 일치시키는 데 사용됩니다.

네 번째 필드에는 이벤트를 보고하는 데몬 프로세스의 유효 사용자 또는 소유자가 정의됩니다. 여기에는 와일드카드뿐만 아니라 사용자 이름 또는 UID도 사용할 수 있습니다(위의 규칙 예시 참조).

패킷 필터 규칙 이름은 규칙의 동작 부분을 시작하는 다섯 번째 필드에서 선언됩니다. 기본적으로 blacklistd는 다음과 같이 모든 블록을 [.filename]#pf.conf#의 `blacklistd`라는 pf 앵커 아래에 배치합니다:

[.programlisting]
....
anchor "blacklistd/*" in on $ext_if
block in
pass out
....

별도의 차단 목록의 경우 이 필드에 앵커 이름을 사용할 수 있습니다. 다른 경우에는 와일드카드로 충분합니다. 이름이 하이픈(`-`)으로 시작하면 기본 규칙 이름이 앞에 붙은 앵커를 사용해야 한다는 의미입니다. 위의 예에서 하이픈을 사용하여 수정한 예는 다음과 같습니다:

[.programlisting]
....
ssh             stream  *       *               -ssh       3       24h
....

이러한 규칙을 사용하면 새 blocklist 규칙이 `blacklistd-ssh`라는 앵커에 추가됩니다.

단일 규칙 위반에 대해 전체 서브넷을 차단하려면 규칙 이름에 `/`를 사용할 수 있습니다. 이렇게 하면 이름의 나머지 부분이 규칙에 지정된 주소에 적용되는 마스크로 해석됩니다. 예를 들어, 이 규칙은 `/24`에 인접한 모든 주소를 차단합니다.

[.programlisting]
....
22              stream  tcp       *               */24    3       24h
....

[NOTE]
====
여기에 적절한 프로토콜을 지정하는 것이 중요합니다. IPv4와 IPv6는 /24를 다르게 처리하기 때문에 이 규칙의 세 번째 필드에 `*`를 사용할 수 없습니다.
====

이 규칙은 해당 네트워크의 호스트 중 하나라도 잘못 동작하면 해당 네트워크의 다른 모든 호스트도 차단되도록 정의합니다.

여섯 번째 필드인 ‘nfail’은 해당 원격 IP를 차단 목록에 올리는 데 필요한 로그인 실패 횟수를 설정합니다. 이 위치에 와일드카드를 사용하면 차단이 발생하지 않습니다. 위의 예제 규칙에서는 3번의 제한이 정의되어 있는데, 이는 한 연결에서 SSH 로그인을 세 번 시도하면 해당 IP가 차단된다는 의미입니다.

Blacklistd 규칙 정의의 마지막 필드는 호스트가 차단 목록에 포함되는 시간을 지정합니다. 기본 단위는 초이지만 `m`, `h`, `d`와 같은 접미사를 사용하여 각각 분, 시간, 일 단위로 지정할 수도 있습니다.

이 예제 규칙을 전체적으로 보면 SSH에 세 번 인증하면 해당 호스트에 대한 새로운 PF 차단 규칙이 적용됩니다. 규칙 일치는 먼저 로컬 규칙을 가장 구체적인 것부터 가장 덜 구체적인 것까지 차례로 확인하여 수행됩니다. 일치하는 규칙이 발생하면 `remote` 규칙이 적용되고 일치하는 `remote` 규칙에 의해 이름, `nfail` 및 비활성화 필드가 변경됩니다.

==== 원격 규칙

원격 규칙은 현재 평가 중인 원격 호스트에 따라 blacklistd가 동작방법을 변경하는데 사용됩니다. 원격 규칙의 각 필드는 로컬 규칙과 동일합니다. 유일한 차이점은 blacklistd가 이를 사용하는 방식입니다. 이를 설명하기 위해 다음 예제 규칙을 보세요:

[.programlisting]
....
[remote]
203.0.113.128/25 *      *       *               =/25    =       48h
....

주소 필드는 IP 주소(v4 또는 v6), 포트 또는 둘 다일 수 있습니다. 이를 통해 이 예제에서와 같이 특정 원격 주소 범위에 대한 특수 규칙을 설정할 수 있습니다. 소켓 유형, 프로토콜 및 소유자 필드는 로컬 규칙에서와 동일하게 해석됩니다.

이름 필드는 다르지만 원격 규칙의 등호(`=`)는 일치하는 로컬 규칙의 값을 사용하도록 blacklistd에 지시합니다. 즉, 방화벽 규칙 항목을 가져와서 `/25` 접두사(넷마스크 `255.255.255.128`)를 추가합니다. 해당 주소 범위의 연결이 차단 목록에 추가되면 전체 서브넷이 영향을 받습니다. 여기에 PF 앵커 이름을 사용할 수도 있으며, 이 경우 blacklistd는 해당 이름의 앵커에 이 주소 블록에 대한 규칙을 추가합니다. 와일드카드가 지정되면 기본 테이블이 사용됩니다.

`nfail` 열에 주소에 대한 사용자 지정 실패 횟수를 정의할 수 있습니다. 이는 특정 규칙에 대한 예외를 허용하거나 규칙을 덜 엄격하게 적용하거나 로그인 시도를 조금 더 관대하게 허용할 때 유용합니다. 이 여섯 번째 필드에 별표가 사용되면 차단이 비활성화됩니다.

원격 규칙을 사용하면 사무실과 같은 로컬 네트워크에서 발생하는 로그인 시도에 비해 로그인을 더 엄격하게 제한할 수 있습니다.

=== blacklistd 클라이언트 구성

FreeBSD에는 blacklistd의 기능을 활용할 수 있는 몇 가지 소프트웨어 패키지가 있습니다. 가장 눈에 띄는 두 패키지는 과도한 연결 시도를 차단하는 man:ftpd[8] 및 man:sshd[8]입니다. SSH 데몬에서 blacklistd를 활성화하려면 [.filename]#/etc/ssh/sshd_config#에 다음 줄을 추가합니다:

[.programlisting]
....
UseBlacklist yes
....

변경 사항을 적용하려면 나중에 sshd를 다시 시작하세요.

man:ftpd[8]에 대한 블랙리스트는 [.filename]#/etc/inetd.conf#에서 `-B`를 사용하거나 다음과 같이 [.filename]#/etc/rc.conf#에서 플래그로 사용합니다:

[.programlisting]
....
ftpd_flags="-B"
....

프로그램이 blacklistd와 통신하는 데 필요한 것은 이것뿐입니다.

=== blacklistd 관리

Blacklistd는 사용자에게 man:blacklistctl[8]이라는 관리 유틸리티를 제공합니다. 이 유틸리티는 man:blacklistd.conf[5]에 정의된 규칙에 따라 차단된 주소와 네트워크를 표시합니다. 현재 차단된 호스트 목록을 보려면 다음과 같이 `dump`와 `-b`를 결합하여 사용합니다.

[source, shell]
....
# blacklistctl dump -b
      address/ma:port id      nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19
....

이 예에서는 `213.0.123.128/25` 주소 범위에서 포트 22에 허용된 3번의 시도에 대해 6번의 시도가 있었음을 보여줍니다. 허용된 시도보다 더 많은 시도가 나열된 이유는 SSH를 사용하면 클라이언트가 단일 TCP 연결에서 여러 번 로그인을 시도할 수 있기 때문입니다. 현재 진행 중인 연결은 블랙리스트에 의해 중지되지 않습니다. 마지막 연결 시도는 출력의 `last access` 열에 나열됩니다.

이 호스트가 차단 목록에 남아있는 남은 시간을 확인하려면 이전 명령에 `-r`을 추가합니다.

[source, shell]
....
# blacklistctl dump -br
      address/ma:port id      nfail   remaining time
213.0.123.128/25:22   OK      6/3     36s
....

이 예에서는 이 호스트가 더 이상 차단되지 않을 때까지 36초가 남았습니다.

=== Block List에서 호스트 제거하기

남은 시간이 만료되기 전에 차단 목록에서 호스트를 제거해야 하는 경우가 있습니다. 안타깝게도 블랙리스트에는 이를 수행할 수 있는 기능이 없습니다. 그러나 pfctl을 사용하여 PF 테이블에서 주소를 제거할 수 있습니다. 차단된 각 포트에 대해 [.filename]#/etc/pf.conf#에 정의된 blacklistd 앵커 내부에 하위 앵커가 있습니다. 예를 들어, 포트 22를 차단하는 자식 앵커가 있으면 `blacklistd/22`라고 합니다. 해당 하위 앵커 내부에는 차단된 주소가 포함된 테이블이 있습니다. 이 테이블은 포트 뒤에 포트 번호가 붙습니다. 이 예제에서는 `port22`라고 합니다. 이 정보가 있으면 이제 man:pfctl[8]을 사용하여 이와 같이 나열된 모든 주소를 표시할 수 있습니다:

[source, shell]
....
# pfctl -a blacklistd/22 -t port22 -T show
...
213.0.123.128/25
...
....

목록에서 차단을 해제할 주소를 식별한 후 다음 명령을 실행하면 목록에서 해당 주소가 삭제됩니다:

[source, shell]
....
# pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25
....

이제 해당 주소는 PF에서 제거되었지만 PF에서 변경된 내용을 알지 못하므로 blacklistctl 목록에는 계속 표시됩니다. blacklistd의 데이터베이스 항목은 결국 만료되어 출력에서 제거됩니다. 호스트가 blacklistd의 차단 규칙 중 하나와 일치하는 경우 해당 항목이 다시 추가됩니다.
