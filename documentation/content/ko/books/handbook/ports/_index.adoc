---
description: 'FreeBSD는 타사 소프트웨어 설치를 위한 두 가지 상호 보완적인 기술을 제공합니다: 소스에서 설치하는 FreeBSD 포트 컬렉션과 미리 빌드된 바이너리에서 설치하는 패키지입니다'
next: books/handbook/x11
part: '파트 I. 시작하기'
path: /books/handbook/
prev: books/handbook/basics
showBookMenu: 'true'
tags: ["ports", "collection", "pkg", "poudriere", "management"]
title: '4장. 애플리케이션 설치하기: 패키지 및 포트'
weight: 6
---

[[ports]]
= 애플리케이션 설치하기: 패키지 및 포트
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== 요약

FreeBSD는 기본 시스템의 일부로 다양한 시스템 도구 모음과 함께 번들로 제공됩니다. 또한 FreeBSD는 타사 소프트웨어를 설치하기 위한 두 가지 보완 기술, 즉 소스에서 설치하는 FreeBSD 포트 컬렉션과 미리 빌드된 바이너리에서 설치하는 패키지를 제공합니다. 두 가지 방법 모두 로컬 미디어 또는 네트워크에서 소프트웨어를 설치하는 데 사용할 수 있습니다.

이 챕터를 읽고 나면, 여러분은:

* 바이너리 패키지와 포트의 차이점.
* FreeBSD로 포팅된 타사 소프트웨어를 찾는 방법.
* pkg를 사용하여 바이너리 패키지를 관리하는 방법.
* 포트 컬렉션을 사용하여 소스에서 타사 소프트웨어를 빌드하는 방법.
* 설치 후 구성을 위해 애플리케이션과 함께 설치된 파일을 찾는 방법.
* 소프트웨어 설치에 실패한 경우 어떻게 해야 하나요?

[[ports-overview]]
== 소프트웨어 설치 개요

FreeBSD _port_는 소스 코드에서 애플리케이션을 컴파일하는 과정을 자동화하기 위해 설계된 파일 모음입니다. 포트를 구성하는 파일에는 애플리케이션을 자동으로 다운로드, 추출, 패치, 컴파일 및 설치하는 데 필요한 모든 정보가 포함되어 있습니다.

소프트웨어가 아직 FreeBSD에 맞게 조정되고 테스트되지 않은 경우, 제대로 설치 및 실행되려면 소스 코드를 편집해야 할 수 있습니다.

그러나 link:https://www.FreeBSD.org/ports/[{numports}] 타사 애플리케이션은 이미 FreeBSD로 포팅되어 있습니다. 가능한 경우, 이러한 애플리케이션은 미리 컴파일된 _packages_로 다운로드할 수 있도록 제공됩니다.

패키지는 FreeBSD 패키지 관리 명령으로 조작할 수 있습니다.

패키지와 포트는 모두 종속성을 이해합니다. 패키지 또는 포트를 사용하여 애플리케이션을 설치하는 데 종속 라이브러리가 아직 설치되어 있지 않은 경우 먼저 라이브러리가 자동으로 설치됩니다.

FreeBSD 패키지에는 응용 프로그램에 대한 모든 명령의 미리 컴파일된 사본과 모든 구성 파일 및 설명서가 포함되어 있습니다. 패키지는 `pkg install`과 같은 man:pkg[8] 명령으로 조작할 수 있습니다.

두 기술은 비슷하지만 패키지와 포트는 각각 고유한 강점이 있습니다. 특정 애플리케이션을 설치하는 데 필요한 요구 사항을 충족하는 기술을 선택하세요.

.패키지의 장점
* 압축된 패키지 tarball은 일반적으로 애플리케이션의 소스 코드가 포함된 압축된 tarball보다 작습니다.
* 패키지는 컴파일 시간이 필요하지 않습니다. Firefox, KDE Plasma 또는 GNOME과 같은 대규모 애플리케이션의 경우 느린 시스템에서 이 점이 중요할 수 있습니다.
* 패키지를 사용하기 위해서는 FreeBSD에서 소프트웨어를 컴파일하는 과정에 대한 이해가 필요하지 않습니다.

.포트의 장점
* 패키지는 최대한 많은 시스템에서 실행되어야 하므로 일반적으로 보수적인 옵션으로 컴파일됩니다. 포트에서 컴파일하면 컴파일 옵션을 변경할 수 있습니다.
* 일부 애플리케이션에는 어떤 기능이 설치되는지와 관련된 컴파일 타임 옵션이 있습니다. 예를 들어, NGINX(R)는 다양한 기본 제공 옵션으로 구성할 수 있습니다.
+
경우에 따라 특정 설정을 지정하기 위해 동일한 애플리케이션에 대해 여러 패키지가 존재할 수 있습니다. 예를 들어, NGINX(R)는 Xorg 설치 여부에 따라 `nginx` 패키지와 `nginx-lite` 패키지로 사용할 수 있습니다. 애플리케이션에 컴파일 시기 옵션이 두 가지 이상이면 여러 패키지를 빠르게 생성하는 것이 불가능해집니다.
* 일부 소프트웨어의 라이선스 조건에 따라 바이너리 배포가 금지되어 있습니다. 이러한 소프트웨어는 최종 사용자가 스스로 컴파일해야 하는 소스 코드로 배포할 수밖에 없습니다.
* 어떤 사람들은 바이너리 배포를 신뢰하지 않거나 잠재적인 문제를 찾기 위해 소스 코드를 읽는 것을 선호합니다.
* 사용자 지정 패치를 적용하려면 소스 코드가 필요합니다.

업데이트된 포트를 추적하려면 {freebsd-ports} 및 {freebsd-ports-bugs}을 구독하세요.

[WARNING]
====
Before installing an application, check https://vuxml.freebsd.org/[] for security issues related to the application.

To check for known vulnerabilities of installed applications use use `pkg audit -F`.
====

이 장의 나머지 부분에서는 패키지와 포트를 사용하여 FreeBSD에 타사 소프트웨어를 설치하고 관리하는 방법을 설명합니다.

[[ports-finding-applications]]
== 소프트웨어 찾기

FreeBSD의 사용 가능한 애플리케이션 목록은 계속 늘어나고 있습니다. 설치할 소프트웨어를 찾는 방법에는 여러 가지가 있습니다:

* FreeBSD 웹 사이트는 link:https://www.FreeBSD.org/ports/[Ports Portal]에서 사용 가능한 모든 애플리케이션의 최신 검색 목록을 유지합니다. 포트는 애플리케이션 이름이나 소프트웨어 카테고리로 검색할 수 있습니다.
* Dan Langille은 종합적인 검색 유틸리티를 제공하고 포트 컬렉션에 있는 애플리케이션의 변경 사항을 추적하는 https://www.freshports.org/[FreshPorts]를 관리합니다. 등록된 사용자는 관심 포트가 업데이트될 때 자동 이메일을 받을 수 있도록 사용자 지정 관심 목록을 만들 수 있습니다.
* 특정 애플리케이션을 찾기 어려운 경우 https://sourceforge.net/[SourceForge] 또는 https://github.com/[GitHub]와 같은 사이트를 검색한 다음 link:https://www.FreeBSD.org/ports/[Ports Portal]에서 애플리케이션이 포팅되었는지 다시 확인하세요.
* Man:pkg[8] 명령을 사용하여 애플리케이션의 바이너리 패키지 리포지토리를 검색합니다

[[pkgng-intro]]
== 바이너리 패키지 관리를 위한 pkg 사용

man:pkg[8]은 패키지를 등록, 추가, 제거, 업그레이드하는 등 패키지를 조작하기 위한 인터페이스를 제공합니다.

FreeBSD 미러에서 미리 빌드된 바이너리 패키지만 사용하려는 경우, man:pkg[8]로 패키지를 관리하는 것으로 충분할 수 있습니다.

단, 소스로 구축하는 사이트의 경우 별도의 <<ports-upgrading-tools, port management tool>>가 필요합니다.

man:pkg[8]은 바이너리 패키지에서만 작동하므로, 이러한 도구를 대체할 수 없습니다. 이러한 도구는 바이너리 패키지와 포트 컬렉션 모두에서 소프트웨어를 설치하는 데 사용할 수 있지만, man:pkg[8]은 바이너리 패키지만 설치합니다.

[[pkgng-initial-setup]]
=== pkg 시작하기

이제 지원되는 모든 FreeBSD 버전에는 `/usr/sbin/pkg`, 일명 man:pkg[7]이 포함됩니다. 이것은 실제 man:pkg[8]을 설치하는 데 필요한 최소한의 기능만 있는 작은 이름표 같은 것 입니다.

[NOTE]
====
부트스트랩 프로세스가 성공하려면 인터넷 연결이 필요합니다.
====

Man:pkg[8] 명령줄을 실행합니다:

[source, shell]
....
# pkg
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
The package management tool is not yet installed on your system.
Do you want to fetch and install it not? [y/N]
....

man:pkg[7]이 명령을 가로채고, 그 의도를 확인했다면 man:pkg[8] tarball을 다운로드하여 man:pkg[8]을 설치하고 로컬 패키지 데이터베이스를 부트스트랩한 다음 원래 요청했던 명령을 실행합니다.

최신 버전의 man:pkg[7]는 `pkg -N`을 설치를 트리거하지 않고 man:pkg[8]이 설치되었는지 테스트하는 것으로 이해하고, 반대로 pkg 부트스트랩[-f]를 사용하여 다른 작업을 수행하지 않고 man:pkg[8]을 설치(또는 강제로 재설치)합니다.

pkg에 대한 사용 정보는 man:pkg[8] 매뉴얼 페이지에서 확인하거나 추가 인자 없이 `pkg`를 실행하여 확인할 수 있습니다. 추가 pkg 구성 옵션은 man:pkg.conf[5]에 설명되어 있습니다.

각 pkg 명령 인수는 명령별 매뉴얼 페이지에 문서화되어 있습니다.

예를 들어 'pkg install'에 대한 설명서 페이지를 읽으려면 다음 명령을 실행합니다:

[source, shell]
....
# pkg help install
....

이 섹션의 나머지 부분에서는 man:pkg[8]을 사용하여 수행할 수 있는 일반적인 바이너리 패키지 관리 작업을 설명합니다. 각 데모 명령은 사용자 정의할 수 있는 다양한 스위치를 제공합니다. 자세한 내용과 더 많은 예제는 명령의 도움말 또는 매뉴얼 페이지를 참조하세요.

[[quarterly-latest-branch]]
=== 분기별 및 최신 포트 지점

`Quarterly(분기별)` 브랜치는 사용자에게 포트 및 패키지 설치와 업그레이드에 대해 보다 예측 가능하고 안정적인 환경을 제공합니다. 이는 기본적으로 비 특성 업데이트(역자 주: 안정성 업데이트로 생각됨)만 허용하는 방식으로 이루어집니다. 분기별 브랜치는 보안 수정(버전 업데이트 또는 커밋의 백포트일 수 있음), 버그 수정, 포트 규정 준수 또는 프레임워크 변경을 목표로 합니다. 분기별 브랜치는 1월, 4월, 7월, 10월의 매(연간) 분기 초를 기준으로 합니다. 브랜치는 브랜치가 생성된 연도(YYYY)와 분기(Q1-4)에 따라 이름이 지정됩니다. 예를 들어 2023년 1월에 생성된 분기 브랜치의 이름은 2023Q1입니다. 이에반해 `Latest` 브랜치는 사용자에게 최신 버전의 패키지를 제공합니다.

To switch man:pkg[8] from Quarterly to Latest run the following commands:

[source, shell]
....
# mkdir -p /usr/local/etc/pkg/repos
# echo 'FreeBSD: { url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest" }' > /usr/local/etc/pkg/repos/FreeBSD.conf
....

Then run this command to update the local package repositories catalogues for the Latest branch:

[source, shell]
....
# pkg update -f
....

[[pkg-configuration]]
=== 패키지 구성하기

man:pkg.conf[5] is the system-wide configuration file used by the man:pkg[8] tools. The default location of this file is `/usr/local/etc/pkg.conf`.

[NOTE]
====
FreeBSD에는 `pkg.conf` 파일이 필요하지 않습니다. 대부분의 설치는 `pkg.conf`가 전혀 없거나 (주석 줄을 제외한) 빈 `pkg.conf`로도 잘 작동합니다.
====

파일에서 "#"으로 시작하는 줄은 주석이며 무시됩니다.

파일은 UCL 형식입니다. man:libucl[3]의 구문에 대한 자세한 내용은 link:https://github.com/vstakhov/libucl[official UCL website]를 참조하세요.

부울, 문자열 및 목록 옵션이 인식되는 옵션 유형은 다음과 같습니다.

부울 옵션은 구성 파일에 YES, TRUE, ON 중 하나의 값이 지정되면 활성화된 것으로 표시됩니다.

[[pkg-search]]
=== 패키지 검색하기

패키지를 검색하려면 man:pkg-search[8]를 사용합니다:

[source, shell]
....
# pkg search nginx
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
modsecurity3-nginx-1.0.3       Instruction detection and prevention engine / nginx Wrapper
nginx-1.22.1_2,3               Robust and small WWW server
nginx-devel-1.23.2_4           Robust and small WWW server
nginx-full-1.22.1_1,3          Robust and small WWW server (full package)
nginx-lite-1.22.1,3            Robust and small WWW server (lite package)
nginx-naxsi-1.22.1,3           Robust and small WWW server (plus NAXSI)
nginx-prometheus-exporter-0.10.0_7 Prometheus exporter for NGINX and NGINX Plus stats
nginx-ultimate-bad-bot-blocker-4.2020.03.2005_1 Nginx bad bot and other things blocker
nginx-vts-exporter-0.10.7_7    Server that scraps NGINX vts stats and export them via HTTP
p5-Nginx-ReadBody-0.07_1       Nginx embeded perl module to read and evaluate a request body
p5-Nginx-Simple-0.07_1         Perl 5 module for easy to use interface for Nginx Perl Module
p5-Test-Nginx-0.30             Testing modules for Nginx C module development
py39-certbot-nginx-2.0.0       NGINX plugin for Certbot
rubygem-passenger-nginx-6.0.15 Modules for running Ruby on Rails and Rack applications
....

[[pkg-installing-fetching]]
=== 패키지 가져오기 및 설치하기

바이너리 패키지를 설치하려면 man:pkg-install[8]을 사용합니다. 이 명령은 리포지토리 데이터를 사용하여 설치할 소프트웨어의 버전과 제거된 종속성이 있는지 확인합니다. 예를 들어 curl을 설치하려면:

[source, shell]
....
# pkg install curl
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following 9 package(s) will be affected (of 0 checked):

New packages to be INSTALLED:
        ca_root_nss: 3.83
        curl: 7.86.0
        gettext-runtime: 0.21
        indexinfo: 0.3.1
        libidn2: 2.3.3
        libnghttp2: 1.48.0
        libpsl: 0.21.1_4
        libssh2: 1.10.0.3
        libunistring: 1.0

Number of packages to be installed: 9

The process will require 11 MiB more space.
3 MiB to be downloaded

Proceed with this action? [y/N]
....

새 패키지와 종속성으로 설치된 모든 추가 패키지는 설치된 패키지 목록에서 확인할 수 있습니다:

[source, shell]
....
# pkg info
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
ca_root_nss-3.83               Root certificate bundle from the Mozilla Project
curl-7.86.0                    Command line tool and library for transferring data with URLs
gettext-runtime-0.21.1         GNU gettext runtime libraries and programs
indexinfo-0.3.1                Utility to regenerate the GNU info page index
libidn2-2.3.3                  Implementation of IDNA2008 internationalized domain names
libnghttp2-1.48.0              HTTP/2.0 C Library
libpsl-0.21.1_6                C library to handle the Public Suffix List
libssh2-1.10.0.3               Library implementing the SSH2 protocol
libunistring-1.0               Unicode string library
pkg-1.18.4                     Package manager
....

패키지를 가져와 나중에 또는 다른 위치에 설치하려면 man:pkg-fetch[8]을 사용합니다. 예를 들어, `nginx-lite`를 다운로드하려면:

[source, shell]
....
# pkg fetch -d -o /usr/home/user/packages/ nginx-lite
....

* `-d`: 모든 종속성을 가져오는 데 사용됩니다
* `-o`: 다운로드 디렉터리를 지정하는 데 사용됩니다

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following packages will be fetched:

New packages to be FETCHED:
        nginx-lite: 1.22.1,3 (342 KiB: 22.20% of the 2 MiB to download)
        pcre: 8.45_3 (1 MiB: 77.80% of the 2 MiB to download)

Number of packages to be fetched: 2

The process will require 2 MiB more space.
2 MiB to be downloaded.

Proceed with fetching packages? [y/N]:
....

다운로드한 패키지를 설치하려면 다음과 같이 man:pkg-install[8]을 사용합니다:

[source, shell]
....
# cd /usr/home/user/packages/
....

[source, shell]
....
# pkg install nginx-lite-1.22.1,3.pkg
....

[[pkgng-pkg-info]]
=== 설치된 패키지에 대한 정보 얻기

시스템에 설치된 패키지에 대한 정보는 man:pkg-info[8]를 실행하여 확인할 수 있으며, 스위치 없이 실행하면 설치된 모든 패키지 또는 지정된 패키지에 대한 패키지 버전이 나열됩니다.

예를 들어 설치된 pkg 버전을 확인하려면 다음을 실행합니다:

[source, shell]
....
# pkg info pkg
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
pkg-1.19.0
Name           : pkg
Version        : 1.19.0
Installed on   : Sat Dec 17 11:05:28 2022 CET
Origin         : ports-mgmt/pkg
Architecture   : FreeBSD:13:amd64
Prefix         : /usr/local
Categories     : ports-mgmt
Licenses       : BSD2CLAUSE
Maintainer     : pkg@FreeBSD.org
WWW            : https://github.com/freebsd/pkg
Comment        : Package manager
Options        :
        DOCS           : on
Shared Libs provided:
        libpkg.so.4
Annotations    :
        FreeBSD_version: 1301000
        repo_type      : binary
        repository     : FreeBSD
Flat size      : 33.2MiB
Description    :
Package management tool

WWW: https://github.com/freebsd/pkg
....

[[pkgng-upgrading]]
=== 설치된 패키지 업그레이드 하기

설치된 패키지는 man:pkg-upgrade[8]를 사용하여 최신 버전으로 업그레이드할 수 있습니다:

[source, shell]
....
# pkg upgrade
....

이 명령은 설치된 버전을 리포지토리 카탈로그에서 사용 가능한 버전과 비교하여 리포지토리에서 업그레이드합니다.

[[pkgng-auditing]]
=== 설치된 패키지 감사하기

소프트웨어 취약점은 타사 애플리케이션에서 정기적으로 발견됩니다. 이 문제를 해결하기 위해 pkg에는 감사 메커니즘이 내장되어 있습니다. 시스템에 설치된 소프트웨어에 알려진 취약점이 있는지 확인하려면 man:pkg-audit[8]을 사용하세요:

[source, shell]
....
# pkg audit -F
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
Fetching vuln.xml.xz: 100%  976 KiB 499.5kB/s    00:02    
chromium-108.0.5359.98 is vulnerable:
  chromium -- multiple vulnerabilities
  CVE: CVE-2022-4440
  CVE: CVE-2022-4439
  CVE: CVE-2022-4438
  CVE: CVE-2022-4437
  CVE: CVE-2022-4436
  WWW: https://vuxml.FreeBSD.org/freebsd/83eb9374-7b97-11ed-be8f-3065ec8fd3ec.html
....

[[pkg-delete]]
=== 패키지 제거하기

더 이상 필요하지 않은 패키지는 man:pkg-delete[8]로 제거할 수 있습니다.

예를 들면:

[source, shell]
....
# pkg delete curl
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages (of 0 packages in the universe):

Installed packages to be REMOVED:
        curl :7.86.0

Number of packages to be removed: 1

The operation will free 4 MiB.

Proceed with deinstallation packages? [y/N]: y
[1/1] Deinstalling curl-7.86.0...
[1/1] Deleting files for curl-7.86.0: 100%
....

[[pkgng-autoremove]]
=== 사용하지 않는 패키지 자동 제거하기

패키지를 제거하면 더 이상 필요하지 않은 의존성이 남을 수 있습니다. 종속성(leaf packages)으로 설치된 불필요한 패키지는 man:pkg-autoremove[8]를 사용하여 자동으로 감지하고 제거할 수 있습니다:

[source, shell]
....
# pkg autoremove
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages:

Installed packages to be REMOVED:
        ca_root_nss-3.83

Number of packages to be removed: 1

The operation will free 723 KiB.

Proceed with deinstalling packages? [y/N]: 
....

종속성으로 설치된 패키지를 _automatic_ 패키지라고 합니다. 비 자동 패키지, 즉 다른 패키지의 종속성이 아닌 명시적으로 설치된 패키지는 다음을 사용하여 나열할 수 있습니다:

[source, shell]
....
# pkg prime-list
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
nginx
openvpn
sudo
....

`pkg prime-list`는 `/usr/local/etc/pkg.conf`에 선언된 별칭 명령어(alias command)입니다. 시스템의 패키지 데이터베이스를 쿼리하는 데 사용할 수 있는 다른 많은 명령이 있습니다. 예를 들어, `pkg prime-origins` 명령은 위에서 언급한 목록의 오리진 포트 디렉터리를 가져오는 데 사용할 수 있습니다:

[source, shell]
....
# pkg prime-origins
....

출력은 다음과 비슷해야 합니다:

[.programlisting]
....
www/nginx
security/openvpn
security/sudo
....

이 목록은 package:ports-mgmt/poudriere[] 또는 package:ports-mgmt/synth[] 등의 빌드 툴을 사용하여 시스템에 설치된 모든 패키지를 다시 빌드하는 데 사용할 수 있습니다.

설치된 패키지를 자동으로 표시하는 것은 다음을 사용하여 수행할 수 있습니다:

[source, shell]
....
# pkg set -A 1 devel/cmake
....

패키지가 리프 패키지이고 자동으로 표시되면 `pkg autoremove`에 의해 선택됩니다.

설치된 패키지를 _비 자동_ 패키지로 표시하는 방법은 다음과 같습니다:

[source, shell]
....
# pkg set -A 0 devel/cmake
....

[[pkgng-backup]]
=== 패키지 데이터베이스 복원하기

기존 패키지 관리 시스템과 달리 pkg에는 자체 패키지 데이터베이스 백업 메커니즘이 포함되어 있습니다. 이 기능은 기본적으로 활성화되어 있습니다.

[TIP]
====
정기 스크립트가 패키지 데이터베이스를 백업하지 않도록 하려면 man:periodic.conf[5]에서 `daily_backup_pkgdb_enable="NO"`를 설정합니다.
====

이전 패키지 데이터베이스 백업의 내용을 복원하려면 _/path/to/pkg.sql_를 백업 위치로 바꾸어 다음 명령을 실행합니다:

[source, shell]
....
# pkg backup -r /path/to/pkg.sql
....

[NOTE]
====
정기 스크립트에 의해 수행된 백업을 복원하는 경우 복원하기 전에 압축을 풀어야 합니다.
====

pkg 데이터베이스의 수동 백업을 실행하려면 다음 명령을 실행하여 _/path/to/pkg.sql_를 적절한 파일 이름과 위치로 바꿉니다:

[source, shell]
....
# pkg backup -d /path/to/pkg.sql
....

[[pkgng-clean]]
=== 오래된 패키지 제거하기

기본적으로 pkg는 바이너리 패키지를 man:pkg.conf[5]의 `PKG_CACHEDIR`에 정의된 캐시 디렉터리에 저장합니다. 설치된 최신 패키지의 사본만 보관됩니다. 이전 버전의 pkg는 모든 이전 패키지를 유지합니다. 이러한 오래된 바이너리 패키지를 제거하려면 다음을 실행합니다:

[source, shell]
....
# pkg clean
....

다음을 실행하면 전체 캐시가 지워질 수 있습니다:

[source, shell]
....
# pkg clean -a
....

[[pkg-locking-unlocking]]
=== 패키지 잠금 및 잠금 해제

man:pkg-lock[8]은 패키지를 재설치, 수정 또는 삭제하지 못하도록 잠그는 데 사용됩니다. man:pkg-unlock[8]은 명명된 패키지의 잠금을 해제합니다. 두 형태 모두 현재 설치된 패키지에만 영향을 미칩니다. 따라서 잠긴 패키지를 업데이트하는 것이 아니라면 이 메커니즘을 사용하여 새 패키지의 설치를 차단하는 것은 불가능합니다.

예를 들어, `nginx-lite`를 잠급니다:

[source, shell]
....
# pkg lock nginx-lite
....

그리고 `nginx-lite`를 잠금 해제합니다:

[source, shell]
....
# pkg unlock nginx-lite
....

[[pkgng-set]]
=== 패키지 메타데이터 수정하기

FreeBSD 포트 컬렉션 내의 소프트웨어는 주요 버전 번호가 변경될 수 있습니다. 이 문제를 해결하기 위해, pkg에는 패키지 오리진을 업데이트하는 명령이 내장되어 있습니다. 예를 들어, package:lang/python3[]가 package:lang/python311[]로 이름이 변경되어 package:lang/python3[]이 이제 버전 `3.11`을 나타낼 수 있는 경우 유용할 수 있습니다.

위 예제의 패키지 오리진을 변경하려면 다음을 실행합니다:

[source, shell]
....
# pkg set -o lang/python3:lang/python311
....

다른 예로, package:lang/ruby31[]을 package:lang/ruby32[]로 업데이트하려면 다음을 실행합니다:

[source, shell]
....
# pkg set -o lang/ruby31:lang/ruby32
....

[NOTE]
====
패키지 오리진을 변경할 때는 변경된 오리진의 패키지에 종속된 패키지를 다시 설치하는 것이 중요합니다. 종속 패키지를 강제로 재설치하려면 다음을 실행하세요:

[source, shell]
....
# pkg install -Rf lang/ruby32
....
====

[[ports-using]]
== 포트 컬렉션 사용하기

포트 컬렉션은 `Makefiles`, 패치 및 설명 파일의 집합입니다. 이 파일들의 각 세트는 FreeBSD에서 개별 애플리케이션을 컴파일하고 설치하는 데 사용되며, _port_라고 불립니다.

기본적으로 포트 컬렉션 자체는 `/usr/ports`의 하위 디렉터리에 저장됩니다.

[WARNING]
====
포트 컬렉션을 설치하고 사용하기 전에, 일반적으로 소프트웨어를 설치하기 위해 pkg를 통해 제공되는 바이너리 패키지와 함께 포트 컬렉션을 사용하는 것은 바람직하지 않다는 점에 유의하세요. pkg는 기본적으로 HEAD가 아닌 포트 트리의 분기별 브랜치 릴리스를 추적합니다. HEAD의 포트와 분기별 브랜치 릴리스의 포트에 대한 종속성이 다를 수 있으며, 이로 인해 pkg에 의해 설치된 종속성과 포트 컬렉션의 종속성 간에 충돌이 발생할 수 있습니다. 포트 컬렉션과 pkg를 함께 사용해야 하는 경우 포트 컬렉션과 pkg가 포트 트리의 동일한 브랜치 릴리스에 있는지 확인해야 합니다.
====

포트 컬렉션에는 소프트웨어 카테고리에 대한 디렉토리가 포함되어 있습니다. 각 카테고리 안에는 개별 애플리케이션을 위한 하위 디렉터리가 있습니다. 각 애플리케이션의 하위 디렉터리에는 _ports skeleton_이라고 하는 프로그램을 컴파일하고 설치하는 방법을 FreeBSD에 알려주는 파일 집합이 포함되어 있습니다. 각 포트 스켈레톤에는 이러한 파일과 디렉토리가 포함되어 있습니다:

* *Makefile*: 애플리케이션을 컴파일하는 방법과 해당 컴포넌트를 설치하는 위치를 지정하는 명령문이 포함되어 있습니다.
* *distinfo*: 포트를 빌드하기 위해 다운로드해야 하는 파일의 이름과 체크섬이 포함되어 있습니다.
* *files/*: 이 디렉터리에는 프로그램이 FreeBSD에서 컴파일하고 설치하는 데 필요한 모든 패치가 포함되어 있습니다. 이 디렉터리에는 포트를 빌드하는 데 사용되는 다른 파일도 포함될 수 있습니다.
* *pkg-descr*: 프로그램에 대한 자세한 설명을 제공합니다.
* *pkg-plist*: 포트에 의해 설치될 모든 파일 목록입니다. 또한 제거 시 제거할 파일을 포트 시스템에 알려줍니다.

일부 포트에는 특수한 상황을 처리하기 위한 `pkg-message` 또는 기타 파일이 포함되어 있습니다. 이러한 파일과 일반적인 포트에 대한 자세한 내용은 extref:{porters-handbook}[FreeBSD Porter’s Handbook]을 참고하세요.

포트에는 실제 소스 코드가 포함되어 있지 않으며, `distfile`이라는 파일이 포함되어 있습니다. 포트 빌드의 추출 부분은 다운로드한 소스를 `/usr/ports/distfiles`에 자동으로 저장합니다.

[[ports-using-installation-methods]]
=== 포트 컬렉션 설치하기

포트를 사용하여 애플리케이션을 컴파일하기 전에 먼저 포트 컬렉션을 설치해야 합니다. FreeBSD를 설치할 때 설치되지 않은 경우 다음 방법 중 하나를 사용하여 설치합니다:

[[ports-using-git-method]]
[.procedure]
****
*절차: Git 방법*

포트 트리에 대한 더 많은 제어가 필요하거나 로컬 변경 사항을 유지 관리해야 하는 경우 또는 FreeBSD-CURRENT를 실행하는 경우, Git을 사용하여 포트 컬렉션을 얻을 수 있습니다. Git에 대한 자세한 설명은 extref:{committers-guide}[the Git Primer, git-primer]를 참조하세요.

. 포트 트리를 체크아웃하는 데 사용하려면 먼저 Git을 설치해야 합니다. 포트 트리의 복사본이 이미 있는 경우 다음과 같이 Git을 설치합니다:
+
[source, shell]
....
# cd /usr/ports/devel/git
# make install clean
....
+
포트 트리를 사용할 수 없거나 패키지를 관리하기 위해 pkg를 사용 중인 경우 git을 패키지 형태로 설치할 수 있습니다:
+
[source, shell]
....
# pkg install git
....
+
. 포트 트리의 HEAD 브랜치 사본을 확인하세요:
+
[source, shell]
....
# git clone https://git.FreeBSD.org/ports.git /usr/ports
....
+
. 또는 분기별 브랜치 사본을 확인하세요:
+
[source, shell]
....
# git clone https://git.FreeBSD.org/ports.git -b 2020Q3 /usr/ports
....
+
. 필요에 따라 초기 git 체크아웃 후 `/usr/ports`를 업데이트합니다:
+
[source, shell]
....
# git -C /usr/ports pull
....
+
. 필요에 따라 `/usr/ports`를 다른 분기별 브랜치로 전환합니다:
+
[source, shell]
....
# git -C /usr/ports switch 2020Q4
....
****

=== 포트 설치하기

이 섹션에서는 포트 컬렉션을 사용하여 소프트웨어를 설치하거나 제거하는 방법에 대한 기본 지침을 제공합니다. 사용 가능한 `make` 대상과 환경 변수에 대한 자세한 설명은 man:ports[7]에서 확인할 수 있습니다.

[WARNING]
====

포트를 컴파일하기 전에 이전 섹션에서 설명한 대로 포트 컬렉션을 업데이트해야 합니다. 타사 소프트웨어를 설치하면 보안 취약점이 발생할 수 있으므로 먼저 https://vuxml.freebsd.org/[]에서 해당 포트와 관련된 알려진 보안 문제를 확인하는 것이 좋습니다. 또는 새 포트를 설치하기 전에 `pkg audit -F`를 실행하세요. 이 명령은 매일 보안 시스템을 점검하는 동안 보안 감사 및 취약성 데이터베이스 업데이트를 자동으로 수행하도록 구성할 수 있습니다. 자세한 내용은 man:pkg-audit[8] 및 man:periodic[8]을 참조하세요.
====

포트 컬렉션을 사용하려면 인터넷 연결이 정상적으로 작동한다고 가정합니다. 또한 수퍼유저 권한이 필요합니다.

포트를 컴파일하고 설치하려면 설치할 포트의 디렉터리로 변경한 다음 프롬프트에서 `make install`을 입력합니다. 메시지가 진행 상황을 알려줍니다:

[source, shell]
....
# cd /usr/ports/sysutils/lsof
# make install
>> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.88
...
[extraction output snipped]
...
>> Checksum OK for lsof_4.88D.freebsd.tar.gz.
===>  Patching for lsof-4.88.d,8
===>  Applying FreeBSD patches for lsof-4.88.d,8
===>  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===>  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===>  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.88.d,8
===>   Registering installation for lsof-4.88.d,8
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#
....

`lsof`는 증가된 권한으로 실행되는 프로그램이므로 설치 시 보안 경고가 표시됩니다. 설치가 완료되면 프롬프트가 반환됩니다.

일부 셸은 이러한 명령의 실행 파일에 대한 조회 작업 속도를 높이기 위해 `PATH` 환경 변수에 나열된 디렉터리에서 사용할 수 있는 명령의 캐시를 유지합니다. `tcsh` 셸 사용자는 전체 경로를 지정하지 않고 새로 설치된 명령을 사용할 수 있도록 `rehash`를 입력해야 합니다. 대신 `sh` 셸의 경우 `hash -r`을 사용하세요. 자세한 내용은 해당 셸의 설명서를 참조하세요.

설치하는 동안 컴파일 중에 사용된 모든 임시 파일이 포함된 작업 하위 디렉터리가 생성됩니다. 이 디렉터리를 제거하면 디스크 공간을 절약하고 나중에 최신 버전의 포트로 업그레이드할 때 문제가 발생할 가능성을 최소화할 수 있습니다:

[source, shell]
....
# make clean
===>  Cleaning for lsof-88.d,8
#
....

[NOTE]
====
이 추가 단계를 줄이려면 대신 포트를 컴파일할 때 'make install clean'을 사용하세요.
====

==== 포트 설치시 사용자 지정하기

일부 포트는 애플리케이션 구성 요소를 활성화 또는 비활성화하고, 보안 옵션을 제공하거나, 기타 사용자 정의를 허용하는 데 사용할 수 있는 빌드 옵션을 제공합니다. 예를 들면 package:www/firefox[] 및 package:security/gpgme[] 등이 있습니다. 포트가 구성 가능한 옵션이 있는 다른 포트에 의존하는 경우 기본 동작은 사용자에게 메뉴에서 옵션을 선택하라는 메시지를 표시하는 것이므로 사용자 상호 작용을 위해 여러 번 일시 중지될 수 있습니다. 이를 방지하고 모든 구성을 한 번에 수행하려면 포트 스켈레톤 내에서 `make config-recursive`를 실행하세요. 그런 다음 `make install [clean]`을 실행하여 포트를 컴파일하고 설치합니다.

[TIP]
====
`config-recursive`를 사용할 때 구성할 포트 목록은 `all-depends-list` 대상에 의해 수집됩니다. 모든 종속 포트 옵션이 정의되고 포트 옵션 화면이 더 이상 나타나지 않을 때까지 모든 종속성 옵션이 구성되었는지 확인하기 위해 `make config-recursive`를 실행하는 것이 좋습니다.
====

포트가 빌드된 후 이러한 옵션을 추가, 제거 또는 변경하기 위해 포트의 빌드 옵션 메뉴를 다시 방문하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 포트가 포함된 디렉터리에 `cd`를 입력하고 `make config`를 입력하는 것입니다. 또 다른 옵션은 `make showconfig`를 사용하는 것입니다. 또 다른 옵션은 `make rmconfig`를 실행하여 선택한 모든 옵션을 제거하고 다시 시작할 수 있도록 하는 것입니다. 이 모든 옵션과 다른 옵션은 man:ports[7]에 자세히 설명되어 있습니다.

포트 시스템은 다양한 환경 변수를 지원하는 man:fetch[1]를 사용하여 소스 파일을 다운로드합니다. FreeBSD 시스템이 방화벽이나 FTP/HTTP 프록시 뒤에 있는 경우 `FTP_PASSIVE_MODE`, `FTP_PROXY`, `FTP_PASSWORD` 변수를 설정해야 할 수 있습니다. 지원되는 변수의 전체 목록은 man:fetch[3]를 참조하십시오.

인터넷에 항상 연결할 수 없는 사용자의 경우 `make fetch`를 `/usr/ports` 내에서 실행하여 모든 배포파일을 가져오거나, `/usr/ports/net`과 같은 카테고리 내에서 또는 특정 포트 스켈레톤 내에서 실행할 수 있습니다. 포트에 종속성이 있는 경우, 포트 스켈레톤에서 이 명령을 실행하면 해당 카테고리의 배포파일은 가져오지만 다른 카테고리에 속한 포트의 배포파일은 _가지고 오지 않는다_는 것을 기억하세요. 포트의 모든 종속성에 대한 배포파일도 가져오려면 `make fetch-recursive`를 사용하세요.

드물지만, 조직에 로컬 distfiles(배포파일) 리포지토리가 있는 경우와 같이 `MASTER_SITES` 변수를 사용하여 `Makefile`에 지정된 다운로드 위치를 재정의할 수 있습니다. 사용할 때는 대체 위치를 지정하세요:

[source, shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch
....

작업 디렉터리와 대상 디렉터리의 기본값을 `WRKDIRPREFIX` 및 `PREFIX` 변수로 재정의할 수 있습니다. 예를 들어:

[source, shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

는 `/usr/home/example/ports`에 포트를 컴파일하고 `/usr/local` 아래에 모든 것을 설치합니다.

[source, shell]
....
# make PREFIX=/usr/home/example/local install
....

는 `/usr/ports`에서 포트를 컴파일하고 `/usr/home/example/local`에 설치합니다. 그리고:

[source, shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

위 명령은 이 두 가지를 결합합니다.

이런 방식은 환경 변수로 설정할 수도 있습니다. 환경 변수를 설정하는 방법에 대한 지침은 셸의 매뉴얼 페이지를 참조하세요.

[[ports-removing]]
=== 설치된 포트 제거하기

설치된 포트는 `pkg delete`를 사용하여 제거할 수 있습니다. 이 명령의 사용 예는 man:pkg-delete[8] 매뉴얼 페이지에서 확인할 수 있습니다.

또는 포트의 디렉터리에서 `make deinstall`을 실행할 수 있습니다:

[source, shell]
....
# cd /usr/ports/sysutils/lsof
# make deinstall
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done
....

포트가 제거될 때 표시되는 메시지를 읽어보는 것이 좋습니다. 포트에 종속된 애플리케이션이 있는 경우 이 정보가 표시되지만 제거는 계속 진행됩니다. 이러한 경우 종속성이 깨지는 것을 방지하기 위해 애플리케이션을 다시 설치하는 것이 더 나을 수 있습니다.

[[ports-upgrading]]
=== 포트 업그레이드하기

시간이 지남에 따라 포트 컬렉션에서 최신 버전의 소프트웨어를 사용할 수 있게 됩니다. 이 섹션에서는 업그레이드할 수 있는 소프트웨어를 결정하는 방법과 업그레이드를 수행하는 방법에 대해 설명합니다.

설치된 포트의 최신 버전을 사용할 수 있는지 확인하려면 <<ports-using-git-method, “Git Method”>>에 설명된 업데이트 명령을 사용하여 포트 트리의 최신 버전이 설치되어 있는지 확인합니다. 다음 명령은 설치된 포트 중 오래된 포트를 나열합니다:

[source, shell]
....
# pkg version -l "<"
....

[IMPORTANT]
====
업그레이드를 시도하기 전에 파일 상단에서 `/usr/ports/UPDATING`을 읽어 포트를 마지막으로 업그레이드하거나 시스템을 설치한 날짜와 가장 가까운 날짜로 이동하세요. 이 파일에는 파일 형식 변경, 구성 파일 위치 변경, 이전 버전과의 비호환성 등 포트를 업데이트할 때 사용자가 직면할 수 있고 수행해야 하는 다양한 문제와 추가 단계에 대한 설명이 나와 있습니다. 업그레이드가 필요한 포트에 해당하는 지침을 메모해 두었다가 업그레이드를 수행할 때 이 지침을 따르세요.
====

[[ports-upgrading-tools]]
==== 포트 업그레이드 및 관리를 위한 도구

포트 컬렉션에는 실제 업그레이드를 수행할 수 있는 여러 유틸리티가 포함되어 있습니다. 각각 장단점이 있습니다.

이전에는 대부분의 설치에서 Portmaster 또는 Portupgrade를 사용했습니다. Synth는 새로운 대안입니다.

[NOTE]
====
특정 시스템에 가장 적합한 도구를 선택하는 것은 시스템 관리자의 몫입니다. 이러한 도구를 사용하기 전에 데이터를 백업하는 것이 좋습니다.
====

[[portmaster]]
==== 포트마스터를 사용하여 포트 업그레이드

package:ports-mgmt/portmaster[]는 설치된 포트를 업그레이드하기 위한 아주 작은 유틸리티입니다. 이 유틸리티는 다른 포트나 데이터베이스에 의존하지 않고 FreeBSD 기본 시스템과 함께 설치된 도구를 사용하도록 설계되었습니다. 이 유틸리티를 포트로 설치하려면:

[source, shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

포트마스터는 포트의 네 가지 범주를 정의합니다:

* Root port: 종속성이 없으며 다른 포트의 종속적이지 않습니다.
* Trunk port: 종속성은 없지만 다른 포트는 트렁크 포트에 종속됩니다.
* Branch port: 종속성이 있으며 다른 포트가 이 포트에 종속됩니다.
* Leaf port: 종속성은 있지만 다른 포트에 종속되지 않습니다.

이러한 카테고리를 나열하고 업데이트를 검색하려면 다음과 같이 합니다:

[source, shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache22-2.2.3
        ===>>> New version available: apache22-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

이 명령은 오래된 포트를 모두 업그레이드하는 데 사용됩니다:

[source, shell]
....
# portmaster -a
....

[NOTE]
====
기본적으로 포트마스터는 기존 포트를 삭제하기 전에 백업 패키지를 만듭니다. 새 버전 설치가 성공하면 Portmaster는 백업을 삭제합니다. `-b`를 사용하면 포트마스터가 백업을 자동으로 삭제하지 않도록 지시합니다. `-i`를 추가하면 각 포트를 업그레이드하기 전에 확인 메시지를 표시하는 대화형 모드에서 Portmaster가 시작됩니다. 다른 많은 옵션을 사용할 수 있습니다. 사용법에 대한 자세한 내용은 man:portmaster[8] 매뉴얼 페이지를 참조하십시오.
====

업그레이드 과정에서 오류가 발생하면 `-f`를 추가하여 모든 포트를 업그레이드하고 다시 빌드하세요:

[source, shell]
....
# portmaster -af
....

포트마스터를 사용하여 시스템에 새 포트를 설치할 수도 있으며, 새 포트를 빌드하고 설치하기 전에 모든 종속성을 업그레이드할 수 있습니다. 이 기능을 사용하려면 포트 컬렉션에서 포트의 위치를 지정합니다:

[source, shell]
....
# portmaster shells/bash
....

package:ports-mgmt/portmaster[]에 대한 자세한 정보는 `pkg-descr`에서 확인할 수 있습니다.

[[portupgrade]]
==== 포트 업그레이드를 사용하여 포트 업그레이드하기

package:ports-mgmt/portupgrade[]는 포트를 업그레이드하는 데 사용할 수 있는 또 다른 유틸리티입니다. 이 유틸리티는 포트를 관리하는 데 사용할 수 있는 애플리케이션 모음을 설치합니다. 그러나 이 유틸리티는 Ruby에 종속됩니다. 포트를 설치하려면 다음과 같이 하세요:

[source, shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

이 유틸리티를 사용하여 업그레이드를 수행하기 전에 `pkgdb -F`를 사용하여 설치된 포트 목록을 검사하고 보고된 모든 불일치를 수정하는 것이 좋습니다.

시스템에 설치된 모든 오래된 포트를 업그레이드하려면 `portupgrade -a`를 사용합니다. 또는 모든 개별 업그레이드에 대한 확인을 요청하려면 `-i`를 포함하세요:

[source, shell]
....
# portupgrade -ai
....

사용 가능한 모든 포트 대신 지정된 애플리케이션만 업그레이드하려면 `portupgrade _pkgname_`을 사용합니다. 지정된 애플리케이션에 필요한 모든 포트를 먼저 업그레이드하려면 `-R`을 포함시키는 것이 매우 중요합니다:

[source, shell]
....
# portupgrade -R firefox
....

만약 `-P`가 포함되어 있다면, 포트업그레이드는 `PKG_PATH`에 나열된 로컬 디렉터리에서 사용 가능한 패키지를 검색합니다. 로컬에서 사용할 수 있는 패키지가 없으면 원격 사이트에서 패키지를 가져옵니다. 로컬에서 패키지를 찾을 수 없거나 원격에서 패키지를 가져올 수 없는 경우 Portupgrade는 포트를 사용합니다. 포트를 완전히 사용하지 않으려면 `-PP`를 지정합니다. 이 마지막 옵션 세트는 사용 가능한 패키지가 없는 경우 Portupgrade가 중단하도록 지시합니다:

[source, shell]
....
# portupgrade -PP gnome3
....

아무것도 빌드하거나 설치하지 않고 포트 배포 파일 또는 패키지만 가져오려면 `-P`가 지정된 경우 `-F`를 사용합니다. 사용 가능한 모든 스위치에 대한 자세한 내용은 `portupgrade` 매뉴얼 페이지를 참조하세요.

package:ports-mgmt/portupgrade[]에 대한 자세한 내용은 `pkg-descr`에서 확인할 수 있습니다.

[[ports-disk-space]]
=== 포트와 디스크 공간

포트 컬렉션을 사용하면 시간이 지남에 따라 디스크 공간이 소모됩니다. 포트를 빌드하고 설치한 후, 포트 스켈레톤 내에서 `make clean`을 실행하면 임시 `work` 디렉터리가 정리됩니다. 포트 마스터를 사용하여 포트를 설치하는 경우 `-K`를 지정하지 않으면 이 디렉터리가 자동으로 제거됩니다. 포트업그레이드가 설치된 경우, 이 명령은 포트 컬렉션의 로컬 복사본에 있는 모든 `work` 디렉터리를 제거합니다:

[source, shell]
....
# portsclean -C
....

또한 오래된 소스 배포 파일은 시간이 지남에 따라 `/usr/ports/distfiles`에 누적됩니다. 포트업그레이드를 사용하여 더 이상 포트에서 참조하지 않는 모든 dist파일을 삭제할 수 있습니다:

[source, shell]
....
# portsclean -D
....

포트 업그레이드는 현재 시스템에 설치된 포트에서 참조하지 않는 모든 dist파일을 제거할 수 있습니다:

[source, shell]
....
# portsclean -DD
....

포트마스터가 설치되어 있는 경우 사용하세요:

[source, shell]
....
# portmaster --clean-distfiles
....

기본적으로 이 명령은 대화형이며 사용자에게 distfile을 삭제할지 확인하라는 메시지를 표시합니다.

이러한 명령 외에도 package:ports-mgmt/pkg_cutleaves[]는 더 이상 필요하지 않은 설치된 포트를 제거하는 작업을 자동화합니다.

[[ports-poudriere]]
== Poudriere(푸드리에)를 사용한 패키지 구축

Poudriere는 FreeBSD 패키지를 생성하고 테스트하기 위한 `BSD` 라이선스 유틸리티입니다. 이 유틸리티는 독립된 컴파일 환경을 설정하기 위해 FreeBSD jail을 사용합니다. 이 jail은 설치된 시스템과 다른 버전의 FreeBSD용 패키지를 빌드하는 데 사용할 수 있으며, 호스트가 amd64 시스템인 경우 i386용 패키지를 빌드하는 데에도 사용할 수 있습니다. 패키지가 빌드되면 공식 미러와 동일한 레이아웃에 배치됩니다. 이 패키지는 man:pkg[8] 및 기타 패키지 관리 도구에서 사용할 수 있습니다.

Poudriere는 package:ports-mgmt/poudriere[] 패키지 또는 포트를 사용하여 설치됩니다. 설치에는 샘플 구성 파일 `/usr/local/etc/poudriere.conf.sample`이 포함되어 있습니다. 이 파일을 `/usr/local/etc/poudriere.conf`에 복사합니다. 복사한 파일을 로컬 구성에 맞게 편집합니다.

Poudriere를 실행하는 시스템에서 `ZFS`가 반드시 필요한 것은 아니지만, 도움이 됩니다. `ZFS`를 사용하는 경우 `/usr/local/etc/poudriere.conf`에 `ZPOOL`을 지정하고 `FREEBSD_HOST`를 가까운 미러로 설정해야 합니다. `CCACHE_DIR`을 정의하면 package:dev/ccache[]를 사용하여 컴파일을 캐시하고 자주 컴파일하는 코드의 빌드 시간을 단축할 수 있습니다. Poudriere 데이터세트를 `/poudriere`에 마운트된 격리 트리에 넣는 것이 편리할 수 있습니다. 다른 구성 값은 기본값으로 충분합니다.

감지된 프로세서 코어 수는 병렬로 실행할 빌드 수를 정의하는 데 사용됩니다. `RAM` 또는 스왑 공간으로 충분한 가상 메모리를 제공하세요. 가상 메모리가 부족하면 컴파일 자일이 중지되고 해체되어 이상한 오류 메시지가 표시됩니다.

[[poudriere-initialization]]
=== Jail과 포트 트리 초기화

구성이 끝나면, 필요한 FreeBSD 트리와 포트 트리가 있는 Jail을 설치하도록 poudriere를 초기화합니다. `-j`를 사용하여 jail의 이름을 지정하고 `-v`로 FreeBSD 버전을 지정합니다. FreeBSD/amd64를 실행하는 시스템에서는 `-a`를 사용하여 아키텍처를 `i386` 또는 `amd64`로 설정할 수 있습니다. 기본값은 `uname`으로 표시된 아키텍처입니다.

[source, shell]
....
# poudriere jail -c -j 13amd64 -v 13.1-RELEASE
[00:00:00] Creating 13amd64 fs at /poudriere/jails/13amd64... done
[00:00:00] Using pre-distributed MANIFEST for FreeBSD 13.1-RELEASE amd64
[00:00:00] Fetching base for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/base.txz              125 MB 4110 kBps    31s
[00:00:33] Extracting base... done
[00:00:54] Fetching src for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/src.txz               154 MB 4178 kBps    38s
[00:01:33] Extracting src... done
[00:02:31] Fetching lib32 for FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
[00:02:38] Extracting lib32... done
[00:02:42] Cleaning up... done
[00:02:42] Recording filesystem state for clean... done
[00:02:42] Upgrading using ftp
/etc/resolv.conf -> /poudriere/jails/13amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... done.
Fetching metadata signature for 13.1-RELEASE from update4.freebsd.org... done.
Fetching metadata index... done.
Fetching 2 metadata files... done.
Inspecting system... done.
Preparing to download files... done.
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. done.
Applying patches... done.
Fetching 6 files... done.
The following files will be added as part of updating to
13.1-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
13.1-RELEASE-p1:
[…]
Installing updates...Scanning //usr/share/certs/blacklisted for certificates...
Scanning //usr/share/certs/trusted for certificates...
 done.
13.1-RELEASE-p1
[00:04:06] Recording filesystem state for clean... done
[00:04:07] Jail 13amd64 13.1-RELEASE-p1 amd64 is ready to be used
....

[source, shell]
....
# poudriere ports -c -p local -m git+https
[00:00:00] Creating local fs at /poudriere/ports/local... done
[00:00:00] Checking out the ports tree... done
....

한 대의 컴퓨터에서 poudriere는 여러 구성, 여러 Jail, 여러 포트 트리로 포트를 빌드할 수 있습니다. 이러한 조합에 대한 사용자 지정 구성을 _sets_라고 합니다. package:ports-mgmt/poudriere[]또는 package:ports-mgmt/poudriere-devel[]을 설치한 후 자세한 내용은 man:poudriere[8]의 CUSTOMIZATION 섹션을 참조하세요.

여기에 표시된 기본 구성은 `/usr/local/etc/poudriere.d`에 단일 jail, 포트 및 세트별 `make.conf`를 넣습니다. 이 예제에서 파일 이름은 jail 이름, 포트 이름 및 세트 이름을 결합하여 `13amd64-local-workstation-make.conf`로 생성됩니다. 빌드시 시스템 `make.conf`와 이 새 파일을 결합하여 Jail을 빌드 할 때 사용할 `make.conf`를 생성합니다.

빌드할 패키지는 `13amd64-local-workstation-pkglist`에 입력합니다:

[.programlisting]
....
editors/emacs
devel/git
ports-mgmt/pkg
...
....

지정된 포트에 대한 옵션 및 종속성이 구성됩니다:

[source, shell]
....
# poudriere options -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist
....

마지막으로 패키지가 빌드되고 패키지 리포지토리가 생성됩니다:

[source, shell]
....
# poudriere bulk -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist
....

실행 중 kbd:[Ctrl+t]를 누르면 빌드의 현재 상태가 표시됩니다. Poudriere는 `/poudriere/logs/bulk/jailname`에, 웹 서버에서 빌드 정보를 표시하기 위한 파일도 생성합니다.

완료 후 새 패키지는 이제 poudriere 리포지토리에서 설치할 수 있습니다.

Poudriere 사용에 대한 자세한 내용은 man:poudriere[8] 및 기본 웹 사이트 https://github.com/freebsd/poudriere/wiki[]를 참조하세요.

=== Poudriere 리포지토리를 사용하도록 pkg 클라이언트 구성하기

공식 리포지토리와 사용자 지정 리포지토리를 함께 사용할 수 있지만, 때로는 공식 리포지토리를 비활성화하는 것이 유용할 수 있습니다. 이 경우 공식 구성 파일을 재정의하고 비활성화하는 구성 파일을 생성하면 됩니다. 다음 내용이 포함된 `/usr/local/etc/pkg/repos/FreeBSD.conf`를 생성합니다:

[.programlisting]
....
FreeBSD: {
	enabled: no
}
....

일반적으로 HTTP를 통해 클라이언트 머신에 Poudriere 리포지토리를 제공하는 것이 가장 쉽습니다. 패키지 디렉터리를 제공하도록 웹서버를 설정합니다(예: `/usr/local/poudriere/data/packages/13amd64`, 여기서 `13amd64`는 빌드 이름입니다).

패키지 리포지토리의 URL이 `http://pkg.example.com/13amd64`인 경우 `/usr/local/etc/pkg/repos/custom.conf`에 있는 리포지토리 구성 파일은 다음과 같을 것입니다:

[.programlisting]
....
custom: {
	url: "http://pkg.example.com/13amd64",
	enabled: yes,
}
....

[[ports-nextsteps]]
== 설치 후 고려 사항

소프트웨어가 바이너리 패키지 또는 포트에서 설치되었는지 여부에 관계없이 대부분의 타사 애플리케이션은 설치 후 어느 정도 수준의 구성이 필요합니다. 다음 명령어와 파일 위치를 사용하여 애플리케이션과 함께 설치된 항목을 확인할 수 있습니다.

* 대부분의 애플리케이션은 `/usr/local/etc`에 하나 이상의 기본 구성 파일을 설치합니다. 애플리케이션에 많은 수의 구성 파일이 있는 경우 하위 디렉터리가 생성되어 해당 파일을 보관합니다. 종종 `.sample`과 같은 접미사로 끝나는 샘플 구성 파일이 설치됩니다. 구성 파일을 검토하고 시스템의 요구 사항을 충족하도록 편집해야 할 수도 있습니다. 샘플 파일을 편집하려면 먼저 `.sample` 확장자 없이 복사하세요.
* 설명서를 제공하는 애플리케이션은 `/usr/local/share/doc`에 설치하며, 많은 애플리케이션이 설명서 페이지도 동시에 설치합니다. 계속하기 전에 이 설명서도 참조하세요.
* 일부 애플리케이션은 애플리케이션을 시작하기 전에 `/etc/rc.conf`에 서비스를 반드시 추가해야 합니다. 이러한 애플리케이션은 일반적으로 `/usr/local/etc/rc.d`에 시작 스크립트를 설치합니다. 자세한 내용은 crossref:config[configtuning-starting-services,Starting Services]을 참조하세요.
+
[NOTE]
====
설계상 애플리케이션은 설치 시 시작 스크립트를 실행하지 않으며, 제거 또는 업그레이드 시에도 중지 스크립트를 실행하지 않습니다. 이 결정은 개별 시스템 관리자에게 맡겨져 있습니다.
====

* man:csh[1]의 사용자는 `rehash`를 실행하여 `PATH` 셸에서 알려진 바이너리 목록을 다시 빌드해야 합니다.
* `pkg info`를 사용하여 애플리케이션과 함께 설치된 파일, 매뉴얼 페이지 및 바이너리를 확인합니다.

[[ports-broken]]
== 손상된 포트 처리하기

포트가 빌드 또는 설치되지 않으면 다음을 시도해 보세요:

. link:https://www.FreeBSD.org/support/[Problem Report database]에서 해당 포트에 대해 보류 중인 수정 사항이 있는지 검색합니다. 그렇다면 제안된 수정 사항을 적용하면 문제가 해결될 수 있습니다.
. 포트의 관리자에게 도움을 요청하세요. 포트 스켈레톤에 `make maintainer`를 입력하거나 포트의 `Makefile`을 읽어 관리자의 이메일 주소를 찾습니다. 관리자에게 보내는 이메일에 오류의 원인이 되는 출력을 포함해야 한다는 것을 잊지 마세요.
+
[NOTE]
====
일부 포트는 개인이 관리하지 않고 extref:{mailing-list-faq}[mailing list]로 표시되는 그룹 관리자가 관리합니다. 이러한 주소의 대부분은 mailto:freebsd-listname@FreeBSD.org[freebsd-listname@FreeBSD.org]와 비슷하지만 전부는 아닙니다. 이메일을 보낼 때 이 점을 고려하시기 바랍니다.

mailto:ports@FreeBSD.org[ports@FreeBSD.org]에서 유지 관리하는 포트는 특정 개인이 유지 관리하는 것이 아닙니다. 대신, 모든 수정 및 지원은 해당 메일링 리스트에 가입한 일반 커뮤니티에서 이루어집니다. 더 많은 자원 봉사자가 항상 필요합니다!
====
+
이메일에 응답이 없는 경우, Bugzilla를 사용하여 extref:{problem-reports}[Writing FreeBSD Problem Reports]의 지침에 따라 버그 보고서를 제출하세요.
. 고치세요! extref:{porters-handbook}[Porter’s Handbook]에는 포트 인프라에 대한 자세한 정보가 포함되어 있으므로 가끔 손상된 포트를 고치거나 직접 제출할 수도 있습니다!
. <<pkgng-intro>>의 지침에 따라 포트 대신 패키지를 설치합니다.
