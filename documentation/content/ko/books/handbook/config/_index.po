# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# "Kyung-tak, Yoo" <stonegaze@me.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2023-04-20 20:56-0300\n"
"PO-Revision-Date: 2023-04-30 03:31+0000\n"
"Last-Translator: \"Kyung-tak, Yoo\" <stonegaze@me.com>\n"
"Language-Team: Korean <https://translate-dev.freebsd.org/projects/"
"documentation/bookshandbookconfig_index/ko/>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/config/_index.adoc:1
#, no-wrap
msgid "This chapter explains much of the FreeBSD configuration process, including some of the parameters which can be set to tune a FreeBSD system."
msgstr ""
"이 장에서는 FreeBSD 시스템을 튜닝하기 위해 설정할 수 있는 몇 가지 파라미터를 "
"포함하여 FreeBSD 구성 프로세스의 대부분을 설명합니다."

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/config/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "파트 III. 시스템 관리"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/config/_index.adoc:1
#, no-wrap
msgid "Chapter 13. Configuration and Tuning"
msgstr "13장. 구성 및 튜닝"

#. type: Title =
#: documentation/content/en/books/handbook/config/_index.adoc:14
#, no-wrap
msgid "Configuration and Tuning"
msgstr "구성 및 튜닝"

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "요약"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:56
msgid ""
"One of the important aspects of FreeBSD is proper system configuration.  "
"This chapter explains much of the FreeBSD configuration process, including "
"some of the parameters which can be set to tune a FreeBSD system."
msgstr ""
"FreeBSD의 중요한 측면 중 하나는 적절한 시스템 구성입니다.  이 장에서는 "
"FreeBSD 시스템을 튜닝하기 위해 설정할 수 있는 몇 가지 파라미터를 포함하여 "
"FreeBSD 구성 프로세스의 대부분을 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:58
msgid "After reading this chapter, you will know:"
msgstr "이 챕터를 읽고 나면, 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:60
msgid ""
"The basics of [.filename]#rc.conf# configuration and [.filename]#/usr/local/"
"etc/rc.d# startup scripts."
msgstr "[.filename]#rc.conf# 구성 및 [.filename]#/usr/local/etc/rc.d# 시작 "
"스크립트의 기본."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:61
msgid "How to configure and test a network card."
msgstr "네트워크 카드를 구성하고 테스트하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:62
msgid "How to configure virtual hosts on network devices."
msgstr "네트워크 장치에서 가상 호스트를 구성하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:63
msgid "How to use the various configuration files in [.filename]#/etc#."
msgstr "[.filename]#/etc#에 있는 다양한 설정 파일을 사용하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:64
msgid "How to tune FreeBSD using man:sysctl[8] variables."
msgstr "man:sysctl[8] 변수를 사용하여 FreeBSD를 튜닝하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:65
msgid "How to tune disk performance and modify kernel limitations."
msgstr "디스크 성능을 조정하고 커널 제한을 수정하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:67
msgid "Before reading this chapter, you should:"
msgstr "이 챕터를 읽기 전에 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:69
msgid ""
"Understand UNIX(R) and FreeBSD basics (crossref:basics[basics,FreeBSD "
"Basics])."
msgstr "UNIX(R) 및 FreeBSD 기본 사항을 이해합니다(crossref:basics[basics,FreeBSD "
"Basics])."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:70
msgid ""
"Be familiar with the basics of kernel configuration and compilation "
"(crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel])."
msgstr ""
"커널 구성 및 컴파일의 기본 사항에 익숙해야 합니다 (crossref:kernelconfig["
"kernelconfig,Configuring the FreeBSD Kernel])."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:72
#, no-wrap
msgid "Starting Services"
msgstr "서비스 시작하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:77
msgid ""
"Many users install third party software on FreeBSD from the Ports Collection "
"and require the installed services to be started upon system "
"initialization.  Services, such as package:mail/postfix[] or package:www/"
"apache22[] are just two of the many software packages which may be started "
"during system initialization.  This section explains the procedures "
"available for starting third party software."
msgstr ""
"많은 사용자가 포트 컬렉션에서 타사 소프트웨어를 FreeBSD에 설치하며, 시스템 "
"초기화 시 설치된 서비스가 시작되도록 요구합니다.  package:mail/postfix[] "
"또는 package:www/apache22[]와 같은 서비스는 시스템 초기화 중에 시작될 수 "
"있는 많은 소프트웨어 패키지 중 두 가지에 불과합니다.  이 섹션에서는 타사 "
"소프트웨어를 시작할 때 사용할 수 있는 절차에 대해 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:79
msgid ""
"In FreeBSD, most included services, such as man:cron[8], are started through "
"the system startup scripts."
msgstr "FreeBSD에서는 man:cron[8]과 같은 대부분의 기본 제공 서비스가 시스템 시작 "
"스크립트를 통해 시작됩니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:80
#, no-wrap
msgid "Extended Application Configuration"
msgstr "확장된 애플리케이션 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:85
msgid ""
"Now that FreeBSD includes [.filename]#rc.d#, configuration of application "
"startup is easier and provides more features.  Using the key words discussed "
"in <<configtuning-rcd>>, applications can be set to start after certain "
"other services and extra flags can be passed through [.filename]#/etc/rc."
"conf# in place of hard coded flags in the startup script.  A basic script "
"may look similar to the following:"
msgstr ""
"이제 FreeBSD에 [.filename]#rc.d#가 포함되었으므로, 애플리케이션 시작을 "
"구성하는 것이 더 쉬워지고 더 많은 기능을 제공합니다.  <<configtuning-rcd>>에 "
"설명된 키워드를 사용하여 애플리케이션이 특정 다른 서비스 이후에 시작되도록 "
"설정할 수 있으며, 시작 스크립트에서 하드 코딩된 플래그 대신 [.filename]#/etc/"
"rc.conf#을 통해 추가 플래그를 전달할 수 있습니다.  기본 스크립트는 다음과 "
"비슷하게 보일 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:93
#, no-wrap
msgid ""
"#!/bin/sh\n"
"#\n"
"# PROVIDE: utility\n"
"# REQUIRE: DAEMON\n"
"# KEYWORD: shutdown\n"
msgstr ""
"#!/bin/sh\n"
"#\n"
"# PROVIDE: utility\n"
"# REQUIRE: DAEMON\n"
"# KEYWORD: shutdown\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:95
#, no-wrap
msgid ". /etc/rc.subr\n"
msgstr ". /etc/rc.subr\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:98
#, no-wrap
msgid ""
"name=utility\n"
"rcvar=utility_enable\n"
msgstr ""
"name=utility\n"
"rcvar=utility_enable\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:100
#, no-wrap
msgid "command=\"/usr/local/sbin/utility\"\n"
msgstr "command=\"/usr/local/sbin/utility\"\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:102
#, no-wrap
msgid "load_rc_config $name\n"
msgstr "load_rc_config $name\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:109
#, no-wrap
msgid ""
"#\n"
"# DO NOT CHANGE THESE DEFAULT VALUES HERE\n"
"# SET THEM IN THE /etc/rc.conf FILE\n"
"#\n"
"utility_enable=${utility_enable-\"NO\"}\n"
"pidfile=${utility_pidfile-\"/var/run/utility.pid\"}\n"
msgstr ""
"#\n"
"# DO NOT CHANGE THESE DEFAULT VALUES HERE\n"
"# SET THEM IN THE /etc/rc.conf FILE\n"
"#\n"
"utility_enable=${utility_enable-\"NO\"}\n"
"pidfile=${utility_pidfile-\"/var/run/utility.pid\"}\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:111
#, no-wrap
msgid "run_rc_command \"$1\"\n"
msgstr "run_rc_command \"$1\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:115
msgid ""
"This script will ensure that the provided `utility` will be started after "
"the `DAEMON` pseudo-service.  It also provides a method for setting and "
"tracking the process ID (PID)."
msgstr ""
"이 스크립트는 제공된 `utility`가 `DAEMON` 의사 서비스 이후에 시작되도록 "
"합니다.  또한 프로세스 ID(PID)를 설정하고 추적하는 방법도 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:117
msgid ""
"This application could then have the following line placed in [.filename]#/"
"etc/rc.conf#:"
msgstr "그러면 이 애플리케이션은 [.filename]#/etc/rc.conf#에 다음 줄을 넣을 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:121
#, no-wrap
msgid "utility_enable=\"YES\"\n"
msgstr "utility_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:124
msgid ""
"This method allows for easier manipulation of command line arguments, "
"inclusion of the default functions provided in [.filename]#/etc/rc.subr#, "
"compatibility with man:rcorder[8], and provides for easier configuration via "
"[.filename]#rc.conf#."
msgstr ""
"이 방법을 사용하면 명령줄 인수를 더 쉽게 조작할 수 있고, [.filename]#/etc/rc."
"subr#에 제공되는 기본 함수를 포함할 수 있으며, man:rcorder[8]와 호환되고, [."
"filename]#rc.conf#를 통해 더 쉽게 구성할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:125
#, no-wrap
msgid "Using Services to Start Services"
msgstr "서비스를 사용하여 시작하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:129
msgid ""
"Other services can be started using man:inetd[8].  Working with man:inetd[8] "
"and its configuration is described in depth in crossref:network-"
"servers[network-inetd,“The inetd Super-Server”]."
msgstr ""
"다른 서비스는 man:inetd[8]을 사용하여 시작할 수 있습니다.  man:inetd[8] 및 "
"그 구성에 대한 작업은 crossref:network-servers[network-inetd,“The inetd "
"Super-Server”]에 자세히 설명되어 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:133
msgid ""
"In some cases, it may make more sense to use man:cron[8] to start system "
"services.  This approach has a number of advantages as man:cron[8] runs "
"these processes as the owner of the man:crontab[5].  This allows regular "
"users to start and maintain their own applications."
msgstr ""
"경우에 따라 man:cron[8]을 사용하여 시스템 서비스를 시작하는 것이 더 합리적일 "
"수 있습니다.  이 접근 방식은 man:crontab[5]의 소유자로서 이러한 프로세스를 "
"실행하기 때문에 여러 가지 장점이 있습니다.  이를 통해 일반 사용자가 자신의 "
"애플리케이션을 시작하고 유지 관리할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:136
msgid ""
"The `@reboot` feature of man:cron[8], may be used in place of the time "
"specification.  This causes the job to run when man:cron[8] is started, "
"normally during system initialization."
msgstr ""
"man:cron[8]의 `@reboot` 기능을 시간 지정 대신 사용할 수 있습니다.  이렇게 "
"하면 일반적으로 시스템 초기화 중에 man:cron[8]이 시작될 때 작업이 실행됩니다."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:138
#, no-wrap
msgid "Configuring man:cron[8]"
msgstr "man:cron[8] 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:144
msgid ""
"One of the most useful utilities in FreeBSD is cron.  This utility runs in "
"the background and regularly checks [.filename]#/etc/crontab# for tasks to "
"execute and searches [.filename]#/var/cron/tabs# for custom crontab files.  "
"These files are used to schedule tasks which cron runs at the specified "
"times.  Each entry in a crontab defines a task to run and is known as a "
"_cron job_."
msgstr ""
"FreeBSD에서 가장 유용한 유틸리티 중 하나는 cron입니다.  이 유틸리티는 "
"백그라운드에서 실행되며 [.filename]#/etc/crontab#에서 실행할 작업이 있는지 "
"정기적으로 확인하고 [.filename]#/var/cron/tabs#에서 사용자 지정 crontab "
"파일을 검색합니다.  이러한 파일은 지정된 시간에 cron이 실행할 작업을 "
"예약하는 데 사용됩니다.  crontab의 각 항목은 실행할 작업을 정의하며 이를 "
"_cron job_이라고 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:150
msgid ""
"Two different types of configuration files are used: the system crontab, "
"which should not be modified, and user crontabs, which can be created and "
"edited as needed.  The format used by these files is documented in man:"
"crontab[5].  The format of the system crontab, [.filename]#/etc/crontab# "
"includes a `who` column which does not exist in user crontabs.  In the "
"system crontab, cron runs the command as the user specified in this column.  "
"In a user crontab, all commands run as the user who created the crontab."
msgstr ""
"두 가지 유형의 구성 파일이 사용됩니다. 수정해서는 안 되는 system crontab과 "
"필요에 따라 생성하고 편집할 수 있는 user crontab이 그것입니다.  이러한 "
"파일에 사용되는 형식은 man:crontab[5]에 문서화되어 있습니다.  System "
"crontab의 형식인 [.filename]#/etc/crontab#에는 user crontab에는 없는 `who` "
"열이 포함되어 있습니다.  System crontab에서 cron은 이 열에 지정된 사용자로 "
"명령을 실행합니다.  User crontab에서는 모든 명령이 crontab을 생성한 사용자로 "
"실행됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:153
msgid ""
"User crontabs allow individual users to schedule their own tasks.  The "
"`root` user can also have a user [.filename]#crontab# which can be used to "
"schedule tasks that do not exist in the system [.filename]#crontab#."
msgstr ""
"User crontab을 사용하면 개별 사용자가 자신의 작업을 예약할 수 있습니다.  "
"`root` 사용자는 시스템 [.filename]#crontab#에 존재하지 않는 작업을 예약하는 "
"데 사용할 수 있는 사용자 [.filename]#crontab#을 가질 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:155
msgid ""
"Here is a sample entry from the system crontab, [.filename]#/etc/crontab#:"
msgstr "다음은 system crontab의 샘플 항목인 [.filename]#/etc/crontab#입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:168
#, no-wrap
msgid ""
"# /etc/crontab - root's crontab for FreeBSD\n"
"#\n"
"# $FreeBSD$\n"
"# <.>\n"
"SHELL=/bin/sh\n"
"PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>\n"
"#\n"
"#minute\thour\tmday\tmonth\twday\twho\tcommand <.>\n"
"#\n"
"*/5\t*\t*\t*\t*\troot\t/usr/libexec/atrun <.>\n"
msgstr ""
"# /etc/crontab - root's crontab for FreeBSD\n"
"#\n"
"# $FreeBSD$\n"
"# <.>\n"
"SHELL=/bin/sh\n"
"PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>\n"
"#\n"
"#minute\thour\tmday\tmonth\twday\twho\tcommand <.>\n"
"#\n"
"*/5\t*\t*\t*\t*\troot\t/usr/libexec/atrun <.>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:171
msgid ""
"Lines that begin with the `+#+` character are comments. A comment can be "
"placed in the file as a reminder of what and why a desired action is "
"performed. Comments cannot be on the same line as a command or else they "
"will be interpreted as part of the command; they must be on a new line. "
"Blank lines are ignored."
msgstr ""
"`+#+` 문자로 시작하는 줄은 주석입니다. 주석은 파일에 원하는 작업이 수행되는 "
"이유와 내용을 알려주는 알림으로 사용할 수 있습니다. 주석은 명령과 같은 줄에 "
"있으면 명령의 일부로 해석되므로 새 줄에 넣어야 합니다. 빈 줄은 무시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:173
msgid ""
"The equals (`=`) character is used to define any environment settings. In "
"this example, it is used to define the `SHELL` and `PATH`. If the `SHELL` is "
"omitted, cron will use the default Bourne shell. If the `PATH` is omitted, "
"the full path must be given to the command or script to run."
msgstr ""
"등호(`=`) 문자는 환경 설정을 정의하는 데 사용됩니다. 이 예제에서는 `SHELL`과 "
"`PATH`를 정의하는 데 사용됩니다. `SHELL`을 생략하면 cron은 기본 Bourne 셸을 "
"사용합니다. `PATH`가 생략된 경우 실행할 명령 또는 스크립트의 전체 경로를 "
"지정해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:175
msgid ""
"This line defines the seven fields used in a system crontab: `minute`, "
"`hour`, `mday`, `month`, `wday`, `who`, and `command`. The `minute` field is "
"the time in minutes when the specified command will be run, the `hour` is "
"the hour when the specified command will be run, the `mday` is the day of "
"the month, `month` is the month, and `wday` is the day of the week. These "
"fields must be numeric values, representing the twenty-four hour clock, or a "
"`*`, representing all values for that field. The `who` field only exists in "
"the system crontab and specifies which user the command should be run as. "
"The last field is the command to be executed."
msgstr ""
"이 줄은 시스템 크론탭에 사용되는 7개의 필드를 정의합니다: `minute`, `hour`, "
"`mday`, `month`, `wday`, `who`, `command` 입니다. `minute` 필드는 지정된 "
"명령이 실행될 시간(분), `hour`은 지정된 명령이 실행될 시간, `mday`은 그 달의 "
"날짜, `month`은 월, `wday`는 요일입니다. 이러한 필드는 24시간 시계를 "
"나타내는 숫자 값 또는 해당 필드의 모든 값을 나타내는 `*`여야 합니다. `who` "
"필드는 system crontab에만 존재하며 명령으로 어떤 사용자로 실행될지 "
"지정합니다. 마지막 필드는 실행할 명령입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:177
msgid ""
"This entry defines the values for this cron job. The `\\*/5`, followed by "
"several more `*` characters, specifies that `/usr/libexec/atrun` is invoked "
"by `root` every five minutes of every hour, of every day and day of the "
"week, of every month.Commands can include any number of switches. However, "
"commands which extend to multiple lines need to be broken with the backslash "
"\"\\\" continuation character."
msgstr ""
"이 항목은 이 cron job의 값을 정의합니다. `\\*/5` 뒤에 여러 개의 `*` 문자가 "
"이어지면 매시간, 매일, 요일, 매월 5분마다 `root`에 의해 `/usr/libexec/atrun`"
"이 호출되도록 지정되며, 명령에는 스위치 개수에 제한 없이 포함될 수 있습니다. "
"그러나 여러 줄로 확장되는 명령은 백슬래시 \"\\\" 연속 문자로 끊어야 합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:179
#, no-wrap
msgid "Creating a User Crontab"
msgstr "User Crontab 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:182
msgid "To create a user crontab, invoke `crontab` in editor mode:"
msgstr "User crontab을 만들려면 편집기 모드에서 `crontab`을 호출합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:186
#, no-wrap
msgid "% crontab -e\n"
msgstr "% crontab -e\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:191
msgid ""
"This will open the user's crontab using the default text editor.  The first "
"time a user runs this command, it will open an empty file.  Once a user "
"creates a crontab, this command will open that file for editing."
msgstr ""
"그러면 기본 텍스트 편집기를 사용하여 사용자의 crontab이 열립니다.  사용자가 "
"이 명령을 처음 실행하면 빈 파일이 열립니다.  사용자가 crontab을 만들면 이 "
"명령은 편집을 위해 해당 파일을 엽니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:193
msgid ""
"It is useful to add these lines to the top of the crontab file in order to "
"set the environment variables and to remember the meanings of the fields in "
"the crontab:"
msgstr ""
"환경 변수를 설정하고 crontab에 있는 필드의 의미를 기억하기 위해 crontab 파일 "
"상단에 이 줄을 추가하는 것이 유용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:200
#, no-wrap
msgid ""
"SHELL=/bin/sh\n"
"PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin\n"
"# Order of crontab fields\n"
"# minute\thour\tmday\tmonth\twday\tcommand\n"
msgstr ""
"SHELL=/bin/sh\n"
"PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin\n"
"# Order of crontab fields\n"
"# minute\thour\tmday\tmonth\twday\tcommand\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:205
msgid ""
"Then add a line for each command or script to run, specifying the time to "
"run the command.  This example runs the specified custom Bourne shell script "
"every day at two in the afternoon.  Since the path to the script is not "
"specified in `PATH`, the full path to the script is given:"
msgstr ""
"그런 다음 실행할 각 명령 또는 스크립트에 대해 한 줄을 추가하여 명령 실행 "
"시간을 지정합니다.  이 예에서는 매일 오후 2시에 지정된 사용자 지정 Bourne 셸 "
"스크립트를 실행합니다.  스크립트 경로가 `PATH`에 지정되지 않았으므로 "
"스크립트의 전체 경로가 제공됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:209
#, no-wrap
msgid "0\t14\t*\t*\t*\t/usr/home/dru/bin/mycustomscript.sh\n"
msgstr "0\t14\t*\t*\t*\t/usr/home/dru/bin/mycustomscript.sh\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:216
msgid ""
"Before using a custom script, make sure it is executable and test it with "
"the limited set of environment variables set by cron.  To replicate the "
"environment that would be used to run the above cron entry, use:"
msgstr ""
"사용자 지정 스크립트를 사용하기 전에 실행 가능한지 확인하고 cron에서 설정한 "
"제한된 환경 변수 집합으로 테스트하세요.  위의 cron 항목을 실행하는 데 "
"사용되는 환경을 복제하려면 다음을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:220
#, no-wrap
msgid "env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh\n"
msgstr ""
"env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru "
"LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:224
msgid ""
"The environment set by cron is discussed in man:crontab[5].  Checking that "
"scripts operate correctly in a cron environment is especially important if "
"they include any commands that delete files using wildcards."
msgstr ""
"Cron으로 설정한 환경은 man:crontab[5]에 설명되어 있습니다.  스크립트가 "
"와일드카드를 사용하여 파일을 삭제하는 명령이 포함된 경우 스크립트가 cron "
"환경에서 올바르게 작동하는지 확인하는 것이 특히 중요합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:229
msgid ""
"When finished editing the crontab, save the file.  It will automatically be "
"installed and cron will read the crontab and run its cron jobs at their "
"specified times.  To list the cron jobs in a crontab, use this command:"
msgstr ""
"Crontab 편집이 끝나면 파일을 저장합니다.  그러면 자동으로 설치되고 cron이 "
"crontab을 읽고 지정된 시간에 cron job을 실행합니다.  Crontab에 있는 cron "
"job을 나열하려면 다음 명령을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:234
#, no-wrap
msgid ""
"% crontab -l\n"
"0\t14\t*\t*\t*\t/usr/home/dru/bin/mycustomscript.sh\n"
msgstr ""
"% crontab -l\n"
"0\t14\t*\t*\t*\t/usr/home/dru/bin/mycustomscript.sh\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:237
msgid "To remove all of the cron jobs in a user crontab:"
msgstr "User crontab에서 모든 cron job을 제거하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:242
#, no-wrap
msgid ""
"% crontab -r\n"
"remove crontab for dru? y\n"
msgstr ""
"% crontab -r\n"
"remove crontab for dru? y\n"

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:245
#, no-wrap
msgid "Managing Services in FreeBSD"
msgstr "FreeBSD에서 서비스 관리하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:250
msgid ""
"FreeBSD uses the man:rc[8] system of startup scripts during system "
"initialization and for managing services.  The scripts listed in [."
"filename]#/etc/rc.d# provide basic services which can be controlled with the "
"`start`, `stop`, and `restart` options to man:service[8].  For instance, man:"
"sshd[8] can be restarted with the following command:"
msgstr ""
"FreeBSD는 시스템 초기화와 서비스 관리를 위해 man:rc[8] 시스템의 시작 "
"스크립트를 사용합니다.  [.filename]#/etc/rc.d#에 나열된 스크립트는 "
"man:service[8]에 `start`, `stop` 및 `restart` 옵션으로 제어할 수 있는 기본 "
"서비스를 제공합니다.  예를 들어, 다음 명령으로 man:sshd[8]를 재시작할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:254
#, no-wrap
msgid "# service sshd restart\n"
msgstr "# service sshd restart\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:259
msgid ""
"This procedure can be used to start services on a running system.  Services "
"will be started automatically at boot time as specified in man:rc.conf[5].  "
"For example, to enable man:natd[8] at system startup, add the following line "
"to [.filename]#/etc/rc.conf#:"
msgstr ""
"이 절차는 실행 중인 시스템에서 서비스를 시작하는 데 사용할 수 있습니다.  "
"서비스는 man:rc.conf[5]에 지정된 대로 부팅 시 자동으로 시작됩니다.  예를 "
"들어, 시스템 시작 시 man:natd[8]를 활성화하려면 [.filename]#/etc/rc.conf#에 "
"다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:263
#, no-wrap
msgid "natd_enable=\"YES\"\n"
msgstr "natd_enable=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:267
msgid ""
"If a `natd_enable=\"NO\"` line is already present, change the `NO` to "
"`YES`.  The man:rc[8] scripts will automatically load any dependent services "
"during the next boot, as described below."
msgstr ""
"`natd_enable=\"NO\"` 줄이 이미 있는 경우, `NO`를 `YES`로 변경합니다.  아래에 "
"설명된 대로 다음 부팅 시 man:rc[8] 스크립트가 종속 서비스를 자동으로 "
"로드합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:272
msgid ""
"Since the man:rc[8] system is primarily intended to start and stop services "
"at system startup and shutdown time, the `start`, `stop` and `restart` "
"options will only perform their action if the appropriate [.filename]#/etc/"
"rc.conf# variable is set.  For instance, `sshd restart` will only work if "
"`sshd_enable` is set to `YES` in [.filename]#/etc/rc.conf#.  To `start`, "
"`stop` or `restart` a service regardless of the settings in [.filename]#/etc/"
"rc.conf#, these commands should be prefixed with \"one\".  For instance, to "
"restart man:sshd[8] regardless of the current [.filename]#/etc/rc.conf# "
"setting, execute the following command:"
msgstr ""
"man:rc[8] 시스템은 주로 시스템 시작 및 종료 시 서비스를 시작하고 중지하기 "
"위한 것이므로, `start`, `stop` 및 `restart` 옵션은 적절한 [.filename]#/etc/rc"
".conf# 변수가 설정되어 있는 경우에만 동작을 수행합니다.  예를 들어, `sshd "
"restart`는 `sshd_enable`이 [.filename]#/etc/rc.conf#에서 `YES`로 설정된 "
"경우에만 작동합니다.  [.filename]#/etc/rc.conf#의 설정에 관계없이 서비스를 "
"`start`, `stop` 또는 `restart`하려면 이러한 명령 앞에 \"one\"을 붙여야 "
"합니다.  예를 들어, 현재 [.filename]#/etc/rc.conf# 설정에 관계없이 "
"man:sshd[8]을 다시 시작하려면 다음 명령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:276
#, no-wrap
msgid "# service sshd onerestart\n"
msgstr "# service sshd onerestart\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:280
msgid ""
"To check if a service is enabled in [.filename]#/etc/rc.conf#, run the "
"appropriate man:rc[8] script with `rcvar`.  This example checks to see if "
"man:sshd[8] is enabled in [.filename]#/etc/rc.conf#:"
msgstr ""
"[.filename]#/etc/rc.conf#에서 서비스가 활성화되어 있는지 확인하려면 `rcvar`"
"와 함께 적절한 man:rc[8] 스크립트를 실행합니다.  이 예에서는 [.filename]#/"
"etc/rc.conf#에서 man:sshd[8]이 활성화되어 있는지 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:288
#, no-wrap
msgid ""
"# service sshd rcvar\n"
"# sshd\n"
"#\n"
"sshd_enable=\"YES\"\n"
"#   (default: \"\")\n"
msgstr ""
"# service sshd rcvar\n"
"# sshd\n"
"#\n"
"sshd_enable=\"YES\"\n"
"#   (default: \"\")\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:293
msgid ""
"The `# sshd` line is output from the above command, not a `root` console."
msgstr "`root` 콘솔이 아닌 위 명령에서 `# sshd` 줄이 출력됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:297
msgid ""
"To determine whether or not a service is running, use `status`.  For "
"instance, to verify that man:sshd[8] is running:"
msgstr "서비스가 실행 중인지 확인하려면 `status`를 사용합니다.  예를 들어, "
"man:sshd[8]이 실행 중인지 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:302
#, no-wrap
msgid ""
"# service sshd status\n"
"sshd is running as pid 433.\n"
msgstr ""
"# service sshd status\n"
"sshd is running as pid 433.\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:308
msgid ""
"In some cases, it is also possible to `reload` a service.  This attempts to "
"send a signal to an individual service, forcing the service to reload its "
"configuration files.  In most cases, this means sending the service a "
"`SIGHUP` signal.  Support for this feature is not included for every service."
msgstr ""
"경우에 따라 서비스를 `reload`할 수도 있습니다.  이는 개별 서비스에 신호를 "
"전송하여 서비스가 구성 파일을 강제로 다시 로드하도록 시도합니다.  대부분의 "
"경우 이는 서비스에 `SIGHUP` 신호를 보내는 것을 의미합니다.  이 기능이 모든 "
"서비스에 지원되는 것은 아닙니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:311
msgid ""
"The man:rc[8] system is used for network services and it also contributes to "
"most of the system initialization.  For instance, when the [.filename]#/etc/"
"rc.d/bgfsck# script is executed, it prints out the following message:"
msgstr ""
"man:rc[8] 시스템은 네트워크 서비스에 사용되며 대부분의 시스템 초기화에도 "
"기여합니다.  예를 들어 [.filename]#/etc/rc.d/bgfsck# 스크립트가 실행되면 "
"다음과 같은 메시지가 출력됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:315
#, no-wrap
msgid "Starting background file system checks in 60 seconds.\n"
msgstr "60초 후에 백그라운드 파일 시스템 검사를 시작하기.\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:318
msgid ""
"This script is used for background file system checks, which occur only "
"during system initialization."
msgstr "이 스크립트는 시스템 초기화 중에만 발생하는 백그라운드 파일 시스템 검사에 "
"사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:323
msgid ""
"Many system services depend on other services to function properly.  For "
"example, man:yp[8] and other RPC-based services may fail to start until "
"after the man:rpcbind[8] service has started.  To resolve this issue, "
"information about dependencies and other meta-data is included in the "
"comments at the top of each startup script.  The man:rcorder[8] program is "
"used to parse these comments during system initialization to determine the "
"order in which system services should be invoked to satisfy the dependencies."
msgstr ""
"많은 시스템 서비스는 제대로 작동하기 위해 다른 서비스에 의존합니다.  예를 "
"들어, man:yp[8] 및 기타 RPC 기반 서비스는 man:rpcbind[8] 서비스가 시작될 "
"때까지 시작하지 못할 수 있습니다.  이 문제를 해결하기 위해 종속성 및 기타 "
"메타 데이터에 대한 정보가 각 시작 스크립트 상단의 주석에 포함되어 있습니다.  "
"man:rcorder[8] 프로그램은 시스템 초기화 중에 이러한 주석을 파싱하여 종속성을 "
"충족하기 위해 시스템 서비스를 호출해야 하는 순서를 결정하는 데 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:325
msgid ""
"The following key word must be included in all startup scripts as it is "
"required by man:rc.subr[8] to \"enable\" the startup script:"
msgstr ""
"다음 키워드는 시작 스크립트를 \"활성화\"하기 위해 man:rc.subr[8]에 "
"필요하므로 모든 시작 스크립트에 포함되어야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:327
msgid "`PROVIDE`: Specifies the services this file provides."
msgstr "`PROVIDE`: 이 파일이 제공하는 서비스를 지정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:330
msgid ""
"The following key words may be included at the top of each startup script.  "
"They are not strictly necessary, but are useful as hints to man:rcorder[8]:"
msgstr ""
"각 시작 스크립트 상단에 다음 키워드를 포함할 수 있습니다.  반드시 필요한 "
"것은 아니지만 man:rcorder[8]에 대한 힌트로 유용합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:332
msgid ""
"`REQUIRE`: Lists services which are required for this service. The script "
"containing this key word will run _after_ the specified services."
msgstr "`REQUIRE`: 이 서비스에 필요한 서비스를 나열합니다. 이 키워드가 포함된 "
"스크립트는 지정된 서비스 _후_에 실행됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:333
msgid ""
"`BEFORE`: Lists services which depend on this service. The script containing "
"this key word will run _before_ the specified services."
msgstr "`BEFORE`: 이 서비스에 종속된 서비스를 나열합니다. 이 키워드가 포함된 "
"스크립트는 지정된 서비스 _전에_ 실행됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:335
msgid ""
"By carefully setting these keywords for each startup script, an "
"administrator has a fine-grained level of control of the startup order of "
"the scripts, without the need for \"runlevels\" used by some UNIX(R) "
"operating systems."
msgstr ""
"각 시작 스크립트에 대해 이러한 키워드를 신중하게 설정하면 관리자는 일부 "
"UNIX(R) 운영 체제에서 사용하는 \"runlevels\"을 사용하지 않고도 스크립트의 "
"시작 순서를 세밀하게 제어할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:338
msgid ""
"Additional information can be found in man:rc[8] and man:rc.subr[8].  Refer "
"to extref:{rc-scripting}[this article] for instructions on how to create "
"custom man:rc[8] scripts."
msgstr ""
"추가 정보는 man:rc[8] 및 man:rc.subr[8]에서 확인할 수 있습니다.  사용자 지정 "
"man:rc[8] 스크립트를 만드는 방법에 대한 지침은 extref:{rc-scripting}[이 문서]"
"를 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:340
#, no-wrap
msgid "Managing System-Specific Configuration"
msgstr "시스템에 특화된 구성 관리하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:345
msgid ""
"The principal location for system configuration information is [.filename]#/"
"etc/rc.conf#.  This file contains a wide range of configuration information "
"and it is read at system startup to configure the system.  It provides the "
"configuration information for the [.filename]#rc*# files."
msgstr ""
"시스템 구성 정보의 주요 위치는 [.filename]#/etc/rc.conf#입니다.  이 파일에는 "
"다양한 구성 정보가 포함되어 있으며 시스템 시작 시 시스템을 구성하기 위해 "
"읽습니다.  이 파일은 [.filename]#rc*# 파일에 대한 구성 정보를 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:349
msgid ""
"The entries in [.filename]#/etc/rc.conf# override the default settings in [."
"filename]#/etc/defaults/rc.conf#.  The file containing the default settings "
"should not be edited.  Instead, all system-specific changes should be made "
"to [.filename]#/etc/rc.conf#."
msgstr ""
"[.filename]#/etc/rc.conf#의 항목은 [.filename]#/etc/defaults/rc.conf#의 기본 "
"설정을 재정의합니다.  기본 설정이 포함된 파일은 편집해서는 안 됩니다.  대신 "
"모든 시스템별 변경 사항은 [.filename]#/etc/rc.conf#에서 수행해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:353
msgid ""
"A number of strategies may be applied in clustered applications to separate "
"site-wide configuration from system-specific configuration in order to "
"reduce administration overhead.  The recommended approach is to place system-"
"specific configuration into [.filename]#/etc/rc.conf.local#.  For example, "
"these entries in [.filename]#/etc/rc.conf# apply to all systems:"
msgstr ""
"클러스터된 애플리케이션에서는 관리 오버헤드를 줄이기 위해 사이트 전체 구성과 "
"시스템별 구성을 분리하는 여러 가지 전략을 적용할 수 있습니다.  권장되는 접근 "
"방식은 시스템별 구성을 [.filename]#/etc/rc.conf.local#에 배치하는 것입니다.  "
"예를 들어 [.filename]#/etc/rc.conf#에 있는 이러한 항목은 모든 시스템에 "
"적용됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:359
#, no-wrap
msgid ""
"sshd_enable=\"YES\"\n"
"keyrate=\"fast\"\n"
"defaultrouter=\"10.1.1.254\"\n"
msgstr ""
"sshd_enable=\"YES\"\n"
"keyrate=\"fast\"\n"
"defaultrouter=\"10.1.1.254\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:362
msgid ""
"Whereas these entries in [.filename]#/etc/rc.conf.local# apply to this "
"system only:"
msgstr "반면 [.filename]#/etc/rc.conf.local#의 이러한 항목은 이 시스템에만 "
"적용됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:367
#, no-wrap
msgid ""
"hostname=\"node1.example.org\"\n"
"ifconfig_fxp0=\"inet 10.1.1.1/8\"\n"
msgstr ""
"hostname=\"node1.example.org\"\n"
"ifconfig_fxp0=\"inet 10.1.1.1/8\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:370
msgid ""
"Distribute [.filename]#/etc/rc.conf# to every system using an application "
"such as rsync or puppet, while [.filename]#/etc/rc.conf.local# remains "
"unique."
msgstr ""
"[.filename]#/etc/rc.conf#는 고유한 상태로 유지하면서, [.filename]#/etc/rc."
"conf.local#은 rsync 또는 puppet과 같은 애플리케이션을 사용하여 모든 시스템에 "
"배포하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:372
msgid ""
"Upgrading the system will not overwrite [.filename]#/etc/rc.conf#, so system "
"configuration information will not be lost."
msgstr ""
"시스템을 업그레이드해도 [.filename]#/etc/rc.conf#를 덮어쓰지는 않으므로 "
"시스템 구성 정보는 손실되지 않습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:379
msgid ""
"Both [.filename]#/etc/rc.conf# and [.filename]#/etc/rc.conf.local# are "
"parsed by man:sh[1].  This allows system operators to create complex "
"configuration scenarios.  Refer to man:rc.conf[5] for further information on "
"this topic."
msgstr ""
"[.filename]#/etc/rc.conf# 및 [.filename]#/etc/rc.conf.local#은 모두 man:sh[1]"
"로 파싱됩니다.  이를 통해 시스템 운영자는 복잡한 구성 시나리오를 만들 수 "
"있습니다.  이 주제에 대한 자세한 내용은 man:rc.conf[5]를 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:382
#, no-wrap
msgid "Setting Up Network Interface Cards"
msgstr "네트워크 인터페이스 카드 설정하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:385
msgid ""
"Adding and configuring a network interface card (NIC) is a common task for "
"any FreeBSD administrator."
msgstr "네트워크 인터페이스 카드(NIC)를 추가하고 구성하는 것은 모든 FreeBSD "
"관리자에게 일반적인 작업입니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:386
#, no-wrap
msgid "Locating the Correct Driver"
msgstr "올바른 드라이버 찾기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:391
msgid ""
"First, determine the model of the NIC and the chip it uses.  FreeBSD "
"supports a wide variety of NICs.  Check the Hardware Compatibility List for "
"the FreeBSD release to see if the NIC is supported."
msgstr ""
"먼저, NIC의 모델과 사용하는 칩을 결정합니다.  FreeBSD는 다양한 NIC를 "
"지원합니다.  해당 NIC가 지원되는지 확인하려면 FreeBSD 릴리즈의 하드웨어 "
"호환성 목록을 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:395
msgid ""
"If the NIC is supported, determine the name of the FreeBSD driver for the "
"NIC.  Refer to [.filename]#/usr/src/sys/conf/NOTES# and [.filename]#/usr/src/"
"sys/arch/conf/NOTES# for the list of NIC drivers with some information about "
"the supported chipsets.  When in doubt, read the manual page of the driver "
"as it will provide more information about the supported hardware and any "
"known limitations of the driver."
msgstr ""
"NIC가 지원되는 경우, NIC용 FreeBSD 드라이버의 이름을 결정합니다.  지원되는 "
"칩셋에 대한 정보가 포함된 NIC 드라이버 목록은 [.filename]#/usr/src/sys/conf/"
"NOTES# 및 [.filename]#/usr/src/sys/arch/conf/NOTES#를 참조하세요.  확실하지 "
"않은 경우 드라이버의 설명서 페이지에서 지원되는 하드웨어와 드라이버의 알려진 "
"제한 사항에 대한 자세한 정보를 확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:399
msgid ""
"The drivers for common NICs are already present in the [.filename]#GENERIC# "
"kernel, meaning the NIC should be probed during boot.  The system's boot "
"messages can be viewed by typing `more /var/run/dmesg.boot` and using the "
"spacebar to scroll through the text.  In this example, two Ethernet NICs "
"using the man:dc[4] driver are present on the system:"
msgstr ""
"일반 NIC용 드라이버는 [.filename]#GENERIC# 커널에 이미 존재하므로 부팅 중에 "
"NIC를 검색해야 합니다.  시스템의 부팅 메시지는 `more /var/run/dmesg.boot`를 "
"입력하고 스페이스바를 사용하여 텍스트를 스크롤하면 볼 수 있습니다.  이 "
"예제에서는 man:dc[4] 드라이버를 사용하는 두 개의 이더넷 NIC가 시스템에 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:416
#, no-wrap
msgid ""
"dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38\n"
"000ff irq 15 at device 11.0 on pci0\n"
"miibus0: <MII bus> on dc0\n"
"bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0\n"
"bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto\n"
"dc0: Ethernet address: 00:a0:cc:da:da:da\n"
"dc0: [ITHREAD]\n"
"dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30\n"
"000ff irq 11 at device 12.0 on pci0\n"
"miibus1: <MII bus> on dc1\n"
"bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1\n"
"bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto\n"
"dc1: Ethernet address: 00:a0:cc:da:da:db\n"
"dc1: [ITHREAD]\n"
msgstr ""
"dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38\n"
"000ff irq 15 at device 11.0 on pci0\n"
"miibus0: <MII bus> on dc0\n"
"bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0\n"
"bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto\n"
"dc0: Ethernet address: 00:a0:cc:da:da:da\n"
"dc0: [ITHREAD]\n"
"dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30\n"
"000ff irq 11 at device 12.0 on pci0\n"
"miibus1: <MII bus> on dc1\n"
"bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1\n"
"bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto\n"
"dc1: Ethernet address: 00:a0:cc:da:da:db\n"
"dc1: [ITHREAD]\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:420
msgid ""
"If the driver for the NIC is not present in [.filename]#GENERIC#, but a "
"driver is available, the driver will need to be loaded before the NIC can be "
"configured and used.  This may be accomplished in one of two ways:"
msgstr ""
"NIC용 드라이버가 [.filename]#GENERIC#에 없지만 드라이버를 사용할 수 있는 "
"경우, 드라이버를 로드해야 NIC를 구성하고 사용할 수 있습니다.  이 작업은 두 "
"가지 방법 중 하나로 수행할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:422
msgid ""
"The easiest way is to load a kernel module for the NIC using man:kldload[8]. "
"To also automatically load the driver at boot time, add the appropriate line "
"to [.filename]#/boot/loader.conf#. Not all NIC drivers are available as "
"modules."
msgstr ""
"가장 쉬운 방법은 man:kldload[8]를 사용하여 NIC용 커널 모듈을 로드하는 "
"것입니다. 부팅 시 드라이버를 자동으로 로드하려면 [.filename]#/boot/loader."
"conf#에 적절한 줄을 추가하세요. 모든 NIC 드라이버를 모듈로 사용할 수 있는 "
"것은 아닙니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:423
msgid ""
"Alternatively, statically compile support for the NIC into a custom kernel. "
"Refer to [.filename]#/usr/src/sys/conf/NOTES#, [.filename]#/usr/src/sys/arch/"
"conf/NOTES# and the manual page of the driver to determine which line to add "
"to the custom kernel configuration file. For more information about "
"recompiling the kernel, refer to crossref:kernelconfig[kernelconfig,"
"Configuring the FreeBSD Kernel]. If the NIC was detected at boot, the kernel "
"does not need to be recompiled."
msgstr ""
"또는 NIC에 대한 지원을 사용자 정의 커널에 정적으로 컴파일합니다. 사용자 지정 "
"커널 구성 파일에 추가할 줄을 결정하려면 [.filename]#/usr/src/sys/conf/NOTES#"
", [.filename]#/usr/src/sys/arch/conf/NOTES# 및 드라이버의 설명서 페이지를 "
"참조하세요. 커널을 다시 컴파일하는 방법에 대한 자세한 내용은 "
"crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]를 "
"참조하십시오. 부팅 시 NIC가 감지된 경우 커널을 다시 컴파일할 필요가 없습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:425
#, no-wrap
msgid "Using Windows(R) NDIS Drivers"
msgstr "Windows(R) NDIS 드라이버 사용하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:429
msgid ""
"Unfortunately, there are still many vendors that do not provide schematics "
"for their drivers to the open source community because they regard such "
"information as trade secrets.  Consequently, the developers of FreeBSD and "
"other operating systems are left with two choices: develop the drivers by a "
"long and pain-staking process of reverse engineering or using the existing "
"driver binaries available for Microsoft(R) Windows(R) platforms."
msgstr ""
"안타깝게도 이러한 정보를 영업 비밀로 간주하여 오픈 소스 커뮤니티에 "
"드라이버의 회로도를 제공하지 않는 공급업체가 여전히 많이 있습니다.  따라서 "
"FreeBSD 및 기타 운영 체제 개발자는 오랜 시간이 걸리는 리버스 엔지니어링 "
"프로세스를 통해 드라이버를 개발하거나 Microsoft(R) Windows(R) 플랫폼에서 "
"사용할 수 있는 기존 드라이버 바이너리를 사용하는 두 가지 선택지가 남습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:434
msgid ""
"FreeBSD provides \"native\" support for the Network Driver Interface "
"Specification (NDIS).  It includes man:ndisgen[8] which can be used to "
"convert a Windows(R) XP driver into a format that can be used on FreeBSD.  "
"As the man:ndis[4] driver uses a Windows(R) XP binary, it only runs on "
"i386(TM) and amd64 systems.  PCI, CardBus, PCMCIA, and USB devices are "
"supported."
msgstr ""
"FreeBSD는 네트워크 드라이버 인터페이스 사양(NDIS)에 대한 \"네이티브\" 지원을 "
"제공합니다.  여기에는 man:ndisgen[8]이 포함되어 있는데, 이는 Windows(R) XP "
"드라이버를 FreeBSD에서 사용할 수 있는 포맷으로 변환하는 데 사용할 수 "
"있습니다.  man:ndis[4] 드라이버는 Windows(R) XP 바이너리를 사용하므로, "
"i386(TM) 및 amd64 시스템에서만 실행됩니다.  PCI, CardBus, PCMCIA 및 USB "
"장치가 지원됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:436
msgid "To use man:ndisgen[8], three things are needed:"
msgstr "man:ndisgen[8]을 사용하려면 세 가지가 필요합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:438
msgid "FreeBSD kernel sources."
msgstr "FreeBSD 커널 소스."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:439
msgid "A Windows(R) XP driver binary with a [.filename]#.SYS# extension."
msgstr "확장자가 [.filename]#.SYS#인 Windows(R) XP 드라이버 바이너리입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:440
msgid ""
"A Windows(R) XP driver configuration file with a [.filename]#.INF# extension."
msgstr "확장자가 [.filename]#.INF#인 Windows(R) XP 드라이버 구성 파일입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:444
msgid ""
"Download the [.filename]#.SYS# and [.filename]#.INF# files for the specific "
"NIC.  Generally, these can be found on the driver CD or at the vendor's "
"website.  The following examples use [.filename]#W32DRIVER.SYS# and [."
"filename]#W32DRIVER.INF#."
msgstr ""
"특정 NIC에 대한 [.filename]#.SYS# 및 [.filename]#.INF# 파일을 "
"다운로드합니다.  일반적으로 드라이버 CD 또는 공급업체 웹사이트에서 찾을 수 "
"있습니다.  다음 예제에서는 [.filename]#W32DRIVER.SYS# 및 [."
"filename]#W32DRIVER.INF#를 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:448
msgid ""
"The driver bit width must match the version of FreeBSD.  For FreeBSD/i386, "
"use a Windows(R) 32-bit driver.  For FreeBSD/amd64, a Windows(R) 64-bit "
"driver is needed."
msgstr ""
"드라이버 비트 폭은 FreeBSD 버전과 일치해야 합니다.  FreeBSD/i386의 경우 "
"Windows(R) 32비트 드라이버를 사용합니다.  FreeBSD/amd64의 경우 Windows(R) "
"64비트 드라이버가 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:451
msgid ""
"The next step is to compile the driver binary into a loadable kernel "
"module.  As `root`, use man:ndisgen[8]:"
msgstr ""
"다음 단계는 드라이버 바이너리를 로드 가능한 커널 모듈로 컴파일하는 "
"것입니다.  `root`로 man:ndisgen[8]을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:455
#, no-wrap
msgid "# ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS\n"
msgstr "# ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:460
msgid ""
"This command is interactive and prompts for any extra information it "
"requires.  A new kernel module will be generated in the current directory.  "
"Use man:kldload[8] to load the new module:"
msgstr ""
"이 명령은 대화형이며 필요한 추가 정보를 묻는 메시지를 표시합니다.  현재 "
"디렉토리에 새 커널 모듈이 생성됩니다.  man:kldload[8]을 사용하여 새 모듈을 "
"로드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:464
#, no-wrap
msgid "# kldload ./W32DRIVER_SYS.ko\n"
msgstr "# kldload ./W32DRIVER_SYS.ko\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:469
msgid ""
"In addition to the generated kernel module, the [.filename]#ndis.ko# and [."
"filename]#if_ndis.ko# modules must be loaded.  This should happen "
"automatically when any module that depends on man:ndis[4] is loaded.  If "
"not, load them manually, using the following commands:"
msgstr ""
"생성된 커널 모듈 외에도 [.filename]#ndis.ko# 및 [.filename]#if_ndis.ko# "
"모듈을 로드해야 합니다.  이 작업은 man:ndis[4]에 의존하는 모듈이 로드될 때 "
"자동으로 수행되어야 합니다.  그렇지 않은 경우 다음 명령을 사용하여 수동으로 "
"로드하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:474
#, no-wrap
msgid ""
"# kldload ndis\n"
"# kldload if_ndis\n"
msgstr ""
"# kldload ndis\n"
"# kldload if_ndis\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:477
msgid ""
"The first command loads the man:ndis[4] miniport driver wrapper and the "
"second loads the generated NIC driver."
msgstr "첫 번째 명령은 man:ndis[4] 미니포트 드라이버 래퍼를 로드하고 두 번째 명령은 "
"생성된 NIC 드라이버를 로드합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:480
msgid ""
"Check man:dmesg[8] to see if there were any load errors.  If all went well, "
"the output should be similar to the following:"
msgstr ""
"man:dmesg[8]를 확인하여 로드 오류가 있는지 확인합니다.  모든 것이 정상적으로 "
"진행되었다면 출력은 다음과 비슷할 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:488
#, no-wrap
msgid ""
"ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1\n"
"ndis0: NDIS API version: 5.0\n"
"ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5\n"
"ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps\n"
"ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps\n"
msgstr ""
"ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device "
"8.0 on pci1\n"
"ndis0: NDIS API version: 5.0\n"
"ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5\n"
"ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps\n"
"ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:491
msgid "From here, [.filename]#ndis0# can be configured like any other NIC."
msgstr "여기에서 [.filename]#ndis0#은 다른 NIC와 마찬가지로 구성할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:494
msgid ""
"To configure the system to load the man:ndis[4] modules at boot time, copy "
"the generated module, [.filename]#W32DRIVER_SYS.ko#, to [.filename]#/boot/"
"modules#.  Then, add the following line to [.filename]#/boot/loader.conf#:"
msgstr ""
"부팅 시 man:ndis[4] 모듈을 로드하도록 시스템을 구성하려면 생성된 모듈인 [."
"filename]#W32DRIVER_SYS.ko#를 [.filename]#/boot/modules#에 복사합니다.  그런 "
"다음 [.filename]#/boot/loader.conf#에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:498
#, no-wrap
msgid "W32DRIVER_SYS_load=\"YES\"\n"
msgstr "W32DRIVER_SYS_load=\"YES\"\n"

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:500
#, no-wrap
msgid "Configuring the Network Card"
msgstr "네트워크 카드 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:504
msgid ""
"Once the right driver is loaded for the NIC, the card needs to be "
"configured.  It may have been configured at installation time by man:"
"bsdinstall[8]."
msgstr ""
"NIC에 적합한 드라이버가 로드되면 카드를 구성해야 합니다.  설치 시 "
"man:bsdinstall[8]에 의해 구성되었을 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:506
msgid "To display the NIC configuration, enter the following command:"
msgstr "NIC 구성을 표시하려면 다음 명령을 입력합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:528
#, no-wrap
msgid ""
"% ifconfig\n"
"dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=80008<VLAN_MTU,LINKSTATE>\n"
"        ether 00:a0:cc:da:da:da\n"
"        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255\n"
"        media: Ethernet autoselect (100baseTX <full-duplex>)\n"
"        status: active\n"
"dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=80008<VLAN_MTU,LINKSTATE>\n"
"        ether 00:a0:cc:da:da:db\n"
"        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet 10baseT/UTP\n"
"        status: no carrier\n"
"lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384\n"
"        options=3<RXCSUM,TXCSUM>\n"
"        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4\n"
"        inet6 ::1 prefixlen 128\n"
"        inet 127.0.0.1 netmask 0xff000000\n"
"        nd6 options=3<PERFORMNUD,ACCEPT_RTADV>\n"
msgstr ""
"% ifconfig\n"
"dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=80008<VLAN_MTU,LINKSTATE>\n"
"        ether 00:a0:cc:da:da:da\n"
"        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255\n"
"        media: Ethernet autoselect (100baseTX <full-duplex>)\n"
"        status: active\n"
"dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=80008<VLAN_MTU,LINKSTATE>\n"
"        ether 00:a0:cc:da:da:db\n"
"        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet 10baseT/UTP\n"
"        status: no carrier\n"
"lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384\n"
"        options=3<RXCSUM,TXCSUM>\n"
"        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4\n"
"        inet6 ::1 prefixlen 128\n"
"        inet 127.0.0.1 netmask 0xff000000\n"
"        nd6 options=3<PERFORMNUD,ACCEPT_RTADV>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:531
msgid "In this example, the following devices were displayed:"
msgstr "이 예제에서는 다음과 같은 장치가 표시되었습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:533
msgid "[.filename]#dc0#: The first Ethernet interface."
msgstr "[.filename]#dc0#: 첫번째 이더넷 인터페이스."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:534
msgid "[.filename]#dc1#: The second Ethernet interface."
msgstr "[.filename]#dc1#: 두 번째 이더넷 인터페이스."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:535
msgid "[.filename]#lo0#: The loopback device."
msgstr "[.filename]#lo0#: 루프백 장치."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:538
msgid ""
"FreeBSD uses the driver name followed by the order in which the card is "
"detected at boot to name the NIC.  For example, [.filename]#sis2# is the "
"third NIC on the system using the man:sis[4] driver."
msgstr ""
"FreeBSD는 드라이버 이름 뒤에 부팅 시 카드가 감지되는 순서를 사용하여 NIC의 "
"이름을 지정합니다.  예를 들어, [.filename]#sis2#는 man:sis[4] 드라이버를 "
"사용하는 시스템에서 세 번째 NIC입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:541
msgid ""
"In this example, [.filename]#dc0# is up and running.  The key indicators are:"
msgstr "이 예에서는 [.filename]#dc0#이 실행 중입니다.  주요 지표는 다음과 같습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:543
msgid "`UP` means that the card is configured and ready."
msgstr "`UP`은 카드가 구성되고 준비되었음을 의미합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:544
msgid "The card has an Internet (`inet`) address, `192.168.1.3`."
msgstr "카드의 인터넷(`inet`) 주소는 `192.168.1.3`입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:545
msgid ""
"It has a valid subnet mask (`netmask`), where `0xffffff00` is the same as "
"`255.255.255.0`."
msgstr "유효한 서브넷 마스크(`netmask`)가 있으며, 여기서 `0xffffff00`은 `255.255.255."
"0`과 동일합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:546
msgid "It has a valid broadcast address, `192.168.1.255`."
msgstr "유효한 브로드캐스트 주소는 `192.168.1.255`입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:547
msgid "The MAC address of the card (`ether`) is `00:a0:cc:da:da:da`."
msgstr "카드의 MAC 주소(`ether`)는 `00:a0:cc:da:da:da`입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:548
msgid ""
"The physical media selection is on autoselection mode (`media: Ethernet "
"autoselect (100baseTX <full-duplex>)`). In this example, [.filename]#dc1# is "
"configured to run with `10baseT/UTP` media. For more information on "
"available media types for a driver, refer to its manual page."
msgstr ""
"물리적 미디어 선택이 자동 선택 모드에 있습니다(`media: Ethernet autoselect ("
"100baseTX <full-duplex>)`). 이 예제에서는 [.filename]#dc1#이 `10baseT/UTP` "
"미디어로 실행되도록 구성되었습니다. 드라이버에 사용 가능한 미디어 유형에 "
"대한 자세한 내용은 해당 설명서 페이지를 참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:549
msgid ""
"The status of the link (`status`) is `active`, indicating that the carrier "
"signal is detected. For [.filename]#dc1#, the `status: no carrier` status is "
"normal when an Ethernet cable is not plugged into the card."
msgstr ""
"링크의 상태(`status`)는 `active`으로, 캐리어 신호가 감지되었음을 나타냅니다. "
"이더넷 케이블이 카드에 연결되어 있지 않은 경우 [.filename]#dc1#의 경우 "
"`status: no carrier` 상태는 정상입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:551
msgid "If the man:ifconfig[8] output had shown something similar to:"
msgstr "man:ifconfig[8] 출력에 다음과 비슷한 내용이 표시되었다면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:559
#, no-wrap
msgid ""
"dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\toptions=80008<VLAN_MTU,LINKSTATE>\n"
"\tether 00:a0:cc:da:da:da\n"
"\tmedia: Ethernet autoselect (100baseTX <full-duplex>)\n"
"\tstatus: active\n"
msgstr ""
"dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\toptions=80008<VLAN_MTU,LINKSTATE>\n"
"\tether 00:a0:cc:da:da:da\n"
"\tmedia: Ethernet autoselect (100baseTX <full-duplex>)\n"
"\tstatus: active\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:562
msgid "it would indicate the card has not been configured."
msgstr "로 나타나면, 카드가 구성되지 않았음을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:566
msgid ""
"The card must be configured as `root`.  The NIC configuration can be "
"performed from the command line with man:ifconfig[8] but will not persist "
"after a reboot unless the configuration is also added to [.filename]#/etc/rc."
"conf#.  If a DHCP server is present on the LAN, just add this line:"
msgstr ""
"카드는 `root`로 구성해야 합니다.  NIC 구성은 명령줄에서 man:ifconfig[8]을 "
"사용하여 수행할 수 있지만 [.filename]#/etc/rc.conf#에도 구성을 추가하지 "
"않으면 재부팅 후에도 지속되지 않습니다.  LAN에 DHCP 서버가 있는 경우 이 줄만 "
"추가하면 됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:570
#, no-wrap
msgid "ifconfig_dc0=\"DHCP\"\n"
msgstr "ifconfig_dc0=\"DHCP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:573
msgid "Replace _dc0_ with the correct value for the system."
msgstr "_dc0_를 시스템에 맞는 올바른 값으로 바꿉니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:575
msgid ""
"The line added, then, follow the instructions given in <<config-network-"
"testing>>."
msgstr "그런 다음 추가한 줄에 <<config-network-testing>>에 제공된 지침을 따릅니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:580
msgid ""
"If the network was configured during installation, some entries for the "
"NIC(s) may be already present.  Double check [.filename]#/etc/rc.conf# "
"before adding any lines."
msgstr ""
"설치 중에 네트워크를 구성한 경우, NIC에 대한 일부 항목이 이미 있을 수 "
"있습니다.  줄을 추가하기 전에 [.filename]#/etc/rc.conf#을 다시 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:584
msgid ""
"If there is no DHCP server, the NIC(s) must be configured manually.  Add a "
"line for each NIC present on the system, as seen in this example:"
msgstr ""
"DHCP 서버가 없는 경우 NIC를 수동으로 구성해야 합니다.  이 예와 같이 시스템에 "
"있는 각 NIC에 대해 한 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:589
#, no-wrap
msgid ""
"ifconfig_dc0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"ifconfig_dc1=\"inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP\"\n"
msgstr ""
"ifconfig_dc0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"ifconfig_dc1=\"inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:593
msgid ""
"Replace [.filename]#dc0# and [.filename]#dc1# and the IP address information "
"with the correct values for the system.  Refer to the man page for the "
"driver, man:ifconfig[8], and man:rc.conf[5] for more details about the "
"allowed options and the syntax of [.filename]#/etc/rc.conf#."
msgstr ""
"[.filename]#dc0# 및 [.filename]#dc1#과 IP 주소 정보를 시스템에 맞는 올바른 "
"값으로 바꿉니다.  허용되는 옵션과 [.filename]#/etc/rc.conf#의 구문에 대한 "
"자세한 내용은 드라이버의 매뉴얼 페이지, man:ifconfig[8] 및 man:rc.conf[5]를 "
"참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:596
msgid ""
"If the network is not using DNS, edit [.filename]#/etc/hosts# to add the "
"names and IP addresses of the hosts on the LAN, if they are not already "
"there.  For more information, refer to man:hosts[5] and to [.filename]#/usr/"
"share/examples/etc/hosts#."
msgstr ""
"네트워크에서 DNS를 사용하지 않는 경우, [.filename]#/etc/hosts#을 수정하여 "
"LAN에 호스트의 이름과 IP 주소가 없는 경우 추가하세요.  자세한 내용은 "
"man:hosts[5] 및 [.filename]#/usr/share/examples/etc/hosts#을 참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:600
msgid ""
"If there is no DHCP server and access to the Internet is needed, manually "
"configure the default gateway and the nameserver:"
msgstr "DHCP 서버가 없고 인터넷에 액세스해야 하는 경우 기본 게이트웨이와 네임서버를 "
"수동으로 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:605
#, no-wrap
msgid ""
"# sysrc defaultrouter=\"your_default_router\"\n"
"# echo 'nameserver your_DNS_server' >> /etc/resolv.conf\n"
msgstr ""
"# sysrc defaultrouter=\"your_default_router\"\n"
"# echo 'nameserver your_DNS_server' >> /etc/resolv.conf\n"

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:610
#, no-wrap
msgid "Testing and Troubleshooting"
msgstr "테스트 및 문제 해결"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:614
msgid ""
"Once the necessary changes to [.filename]#/etc/rc.conf# are saved, a reboot "
"can be used to test the network configuration and to verify that the system "
"restarts without any configuration errors.  Alternatively, apply the "
"settings to the networking system with this command:"
msgstr ""
"[.filename]#/etc/rc.conf#에 필요한 변경 사항을 저장한 후 재부팅하여 네트워크 "
"구성을 테스트하고 구성 오류 없이 시스템이 다시 시작되는지 확인할 수 "
"있습니다.  또는 이 명령을 사용하여 네트워킹 시스템에 설정을 적용할 수도 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:618
#, no-wrap
msgid "# service netif restart\n"
msgstr "# service netif restart\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:623
msgid ""
"If a default gateway has been set in [.filename]#/etc/rc.conf#, also issue "
"this command:"
msgstr "기본 게이트웨이가 [.filename]#/etc/rc.conf#에 설정되어 있는 경우에도 이 "
"명령을 실행하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:627
#, no-wrap
msgid "# service routing restart\n"
msgstr "# service routing restart\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:632
msgid "Once the networking system has been relaunched, test the NICs."
msgstr "네트워킹 시스템이 다시 시작되면 NIC를 테스트합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:633
#, no-wrap
msgid "Testing the Ethernet Card"
msgstr "이더넷 카드 테스트하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:636
msgid ""
"To verify that an Ethernet card is configured correctly, man:ping[8] the "
"interface itself, and then man:ping[8] another machine on the LAN:"
msgstr ""
"이더넷 카드가 올바르게 구성되었는지 확인하려면 인터페이스 자체를 man:ping[8]"
"한 다음 LAN에 있는 다른 머신을 man:ping[8]합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:646
#, no-wrap
msgid ""
"% ping -c5 192.168.1.3\n"
"PING 192.168.1.3 (192.168.1.3): 56 data bytes\n"
"64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms\n"
msgstr ""
"% ping -c5 192.168.1.3\n"
"PING 192.168.1.3 (192.168.1.3): 56 data bytes\n"
"64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms\n"
"64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:650
#, no-wrap
msgid ""
"--- 192.168.1.3 ping statistics ---\n"
"5 packets transmitted, 5 packets received, 0% packet loss\n"
"round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms\n"
msgstr ""
"--- 192.168.1.3 ping statistics ---\n"
"5 packets transmitted, 5 packets received, 0% packet loss\n"
"round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:661
#, no-wrap
msgid ""
"% ping -c5 192.168.1.2\n"
"PING 192.168.1.2 (192.168.1.2): 56 data bytes\n"
"64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms\n"
msgstr ""
"% ping -c5 192.168.1.2\n"
"PING 192.168.1.2 (192.168.1.2): 56 data bytes\n"
"64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms\n"
"64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:665
#, no-wrap
msgid ""
"--- 192.168.1.2 ping statistics ---\n"
"5 packets transmitted, 5 packets received, 0% packet loss\n"
"round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms\n"
msgstr ""
"--- 192.168.1.2 ping statistics ---\n"
"5 packets transmitted, 5 packets received, 0% packet loss\n"
"round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:671
msgid ""
"To test network resolution, use the host name instead of the IP address.  If "
"there is no DNS server on the network, [.filename]#/etc/hosts# must first be "
"configured.  To this purpose, edit [.filename]#/etc/hosts# to add the names "
"and IP addresses of the hosts on the LAN, if they are not already there.  "
"For more information, refer to man:hosts[5] and to [.filename]#/usr/share/"
"examples/etc/hosts#."
msgstr ""
"네트워크 확인을 테스트하려면 IP 주소 대신 호스트 이름을 사용하세요.  "
"네트워크에 DNS 서버가 없는 경우 먼저 [.filename]#/etc/hosts#을 구성해야 "
"합니다.  이를 위해 [.filename]#/etc/hosts#을 편집하여 LAN에 호스트의 이름과 "
"IP 주소가 없는 경우 추가합니다.  자세한 내용은 man:hosts[5] 및 [.filename]#/"
"usr/share/examples/etc/hosts#을 참조하세요."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:672
#, no-wrap
msgid "Troubleshooting"
msgstr "문제 해결"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:676
msgid ""
"When troubleshooting hardware and software configurations, check the simple "
"things first.  Is the network cable plugged in? Are the network services "
"properly configured? Is the firewall configured correctly? Is the NIC "
"supported by FreeBSD? Before sending a bug report, always check the Hardware "
"Notes, update the version of FreeBSD to the latest STABLE version, check the "
"mailing list archives, and search the Internet."
msgstr ""
"하드웨어 및 소프트웨어 구성 문제를 해결할 때는 간단한 사항을 먼저 "
"확인하세요.  네트워크 케이블이 연결되어 있나요? 네트워크 서비스가 올바르게 "
"구성되어 있나요? 방화벽이 올바르게 구성되어 있나요? NIC가 FreeBSD에서 "
"지원되나요? 버그 리포트를 보내기 전에 항상 하드웨어 노트를 확인하고, FreeBSD "
"버전을 최신 안정 버전으로 업데이트하고, 메일링 리스트 아카이브를 확인하고, "
"인터넷에서 검색하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:679
msgid ""
"If the card works, yet performance is poor, read through man:tuning[7].  "
"Also, check the network configuration as incorrect network settings can "
"cause slow connections."
msgstr ""
"카드가 작동하지만 성능이 좋지 않은 경우, man:tuning[7]을 읽어보세요.  또한 "
"네트워크 설정이 잘못되면 연결 속도가 느려질 수 있으므로 네트워크 구성을 "
"확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:684
msgid ""
"Some users experience one or two `device timeout` messages, which is normal "
"for some cards.  If they continue, or are bothersome, determine if the "
"device is conflicting with another device.  Double check the cable "
"connections.  Consider trying another card."
msgstr ""
"일부 사용자는 한두 번의 `device timeout` 메시지를 경험하는데, 이는 일부 "
"카드의 경우 정상입니다.  메시지가 계속 표시되거나 귀찮을 경우 장치가 다른 "
"장치와 충돌하는지 확인하세요.  케이블 연결을 다시 확인하세요.  다른 카드를 "
"사용해 보세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:689
msgid ""
"To resolve `watchdog timeout` errors, first check the network cable.  Many "
"cards require a PCI slot which supports bus mastering.  On some old "
"motherboards, only one PCI slot allows it, usually slot 0.  Check the NIC "
"and the motherboard documentation to determine if that may be the problem."
msgstr ""
"`watchdog timeout` 오류를 해결하려면 먼저 네트워크 케이블을 확인하세요.  "
"많은 카드에는 버스 마스터링을 지원하는 PCI 슬롯이 필요합니다.  일부 구형 "
"마더보드에서는 하나의 PCI 슬롯(보통 슬롯 0)만 허용합니다.  NIC와 마더보드 "
"설명서를 확인하여 해당 문제가 있는지 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:694
msgid ""
"`No route to host` messages occur if the system is unable to route a packet "
"to the destination host.  This can happen if no default route is specified "
"or if a cable is unplugged.  Check the output of `netstat -rn` and make sure "
"there is a valid route to the host.  If there is not, read crossref:advanced-"
"networking[network-routing,“Gateways and Routes”]."
msgstr ""
"시스템이 대상 호스트로 패킷을 라우팅할 수 없는 경우 `No route to host` "
"메시지가 표시됩니다.  기본 경로가 지정되지 않았거나 케이블이 분리된 경우 "
"발생할 수 있습니다.  `netstat -rn`의 출력을 확인하여 호스트에 대한 유효한 "
"경로가 있는지 확인하세요.  그렇지 않은 경우 crossref:advanced-networking"
"[network-routing,“Gateways and Routes”]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:698
msgid ""
"`ping: sendto: Permission denied` error messages are often caused by a "
"misconfigured firewall.  If a firewall is enabled on FreeBSD but no rules "
"have been defined, the default policy is to deny all traffic, even man:"
"ping[8].  Refer to crossref:firewalls[firewalls,Firewalls] for more "
"information."
msgstr ""
"`ping: sendto: Permission denied` 오류 메시지는 종종 잘못 구성된 방화벽으로 "
"인해 발생합니다.  방화벽이 FreeBSD에서 활성화되었지만 규칙이 정의되지 않은 "
"경우, 기본 정책은 모든 트래픽을 거부하는 것입니다(심지어 man:ping[8] 포함).  "
"자세한 내용은 crossref:firewalls[firewalls,Firewalls]을 참고하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:703
msgid ""
"Sometimes performance of the card is poor or below average.  In these cases, "
"try setting the media selection mode from `autoselect` to the correct media "
"selection.  While this works for most hardware, it may or may not resolve "
"the issue.  Again, check all the network settings, and refer to man:"
"tuning[7]."
msgstr ""
"때때로 카드의 성능이 좋지 않거나 평균 이하인 경우가 있습니다.  이러한 경우 "
"미디어 선택 모드를 `autoselect`에서 올바른 미디어 선택으로 설정해 보세요.  "
"이 방법은 대부분의 하드웨어에서 작동하지만, 문제가 해결될 수도 있고 해결되지 "
"않을 수도 있습니다.  다시 한 번 모든 네트워크 설정을 확인하고 man:tuning[7]"
"을 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:705
#, no-wrap
msgid "Virtual Hosts"
msgstr "가상 호스트"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:709
msgid ""
"A common use of FreeBSD is virtual site hosting, where one server appears to "
"the network as many servers.  This is achieved by assigning multiple network "
"addresses to a single interface."
msgstr ""
"하나의 서버가 네트워크에 여러 대의 서버로 표시되는 가상 사이트 호스팅은 "
"FreeBSD의 일반적인 용도입니다.  이는 단일 인터페이스에 여러 네트워크 주소를 "
"할당하여 이루어집니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:712
msgid ""
"A given network interface has one \"real\" address, and may have any number "
"of \"alias\" addresses.  These aliases are normally added by placing alias "
"entries in [.filename]#/etc/rc.conf#, as seen in this example:"
msgstr ""
"주어진 네트워크 인터페이스에는 하나의 \"실제\" 주소가 있으며, \"별칭\" "
"주소는 얼마든지 가질 수 있습니다.  이러한 별칭은 일반적으로 이 예제에서 볼 "
"수 있듯이 [.filename]#/etc/rc.conf#에 별칭 항목을 배치하여 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:716
#, no-wrap
msgid "ifconfig_fxp0_alias0=\"inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx\"\n"
msgstr "ifconfig_fxp0_alias0=\"inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:720
msgid ""
"Alias entries must start with `alias__0__` using a sequential number such as "
"`alias0`, `alias1`, and so on.  The configuration process will stop at the "
"first missing number."
msgstr ""
"별칭 항목은`alias0`, `alias1` 등과 같은 순차 번호를 사용하여 `alias__0__`"
"으로 시작해야 합니다.  구성 프로세스는 첫 번째 누락된 번호에서 중지됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:724
msgid ""
"The calculation of alias netmasks is important.  For a given interface, "
"there must be one address which correctly represents the network's netmask.  "
"Any other addresses which fall within this network must have a netmask of "
"all ``1``s, expressed as either `255.255.255.255` or `0xffffffff`."
msgstr ""
"별칭 넷마스크 계산은 중요합니다.  주어진 인터페이스에 대해 네트워크의 "
"넷마스크를 올바르게 나타내는 주소가 하나 있어야 합니다.  이 네트워크에 "
"속하는 다른 모든 주소는 `255.255.255.255` 또는 `0xffffffff`로 표현되는 모든 "
"``1``의 넷마스크를 가져야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:729
msgid ""
"For example, consider the case where the [.filename]#fxp0# interface is "
"connected to two networks: `10.1.1.0` with a netmask of `255.255.255.0` and "
"`202.0.75.16` with a netmask of `255.255.255.240`.  The system is to be "
"configured to appear in the ranges `10.1.1.1` through `10.1.1.5` and "
"`202.0.75.17` through `202.0.75.20`.  Only the first address in a given "
"network range should have a real netmask.  All the rest (`10.1.1.2` through "
"`10.1.1.5` and `202.0.75.18` through `202.0.75.20`) must be configured with "
"a netmask of `255.255.255.255`."
msgstr ""
"예를 들어, [.filename]#fxp0# 인터페이스가 두 개의 네트워크에 연결되어 있는 "
"경우를 생각해 보겠습니다: 넷마스크가 `255.255.255.0`인 `10.1.1.0`과 "
"넷마스크가 `255.255.255.240`인 `202.0.75.16`이죠.  시스템은 `10.1.1.1` ~ `10."
"1.1.5` 및 `202.0.75.17` ~ `202.0.75.20` 범위에 나타나도록 구성해야 합니다.  "
"주어진 네트워크 범위의 첫 번째 주소만 실제 넷마스크를 가져야 합니다.  나머지 "
"모든 주소(`10.1.1.2` ~ `10.1.1.5` 및 `202.0.75.18` ~ `202.0.75.20`)는 `255."
"255.255.255`의 넷마스크로 구성해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:731
msgid ""
"The following [.filename]#/etc/rc.conf# entries configure the adapter "
"correctly for this scenario:"
msgstr "다음 [.filename]#/etc/rc.conf# 항목은 이 시나리오에 맞게 어댑터를 올바르게 "
"구성한 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:743
#, no-wrap
msgid ""
"ifconfig_fxp0=\"inet 10.1.1.1 netmask 255.255.255.0\"\n"
"ifconfig_fxp0_alias0=\"inet 10.1.1.2 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias1=\"inet 10.1.1.3 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias2=\"inet 10.1.1.4 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias3=\"inet 10.1.1.5 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias4=\"inet 202.0.75.17 netmask 255.255.255.240\"\n"
"ifconfig_fxp0_alias5=\"inet 202.0.75.18 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias6=\"inet 202.0.75.19 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias7=\"inet 202.0.75.20 netmask 255.255.255.255\"\n"
msgstr ""
"ifconfig_fxp0=\"inet 10.1.1.1 netmask 255.255.255.0\"\n"
"ifconfig_fxp0_alias0=\"inet 10.1.1.2 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias1=\"inet 10.1.1.3 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias2=\"inet 10.1.1.4 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias3=\"inet 10.1.1.5 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias4=\"inet 202.0.75.17 netmask 255.255.255.240\"\n"
"ifconfig_fxp0_alias5=\"inet 202.0.75.18 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias6=\"inet 202.0.75.19 netmask 255.255.255.255\"\n"
"ifconfig_fxp0_alias7=\"inet 202.0.75.20 netmask 255.255.255.255\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:747
msgid ""
"A simpler way to express this is with a space-separated list of IP address "
"ranges.  The first address will be given the indicated subnet mask and the "
"additional addresses will have a subnet mask of `255.255.255.255`."
msgstr ""
"이를 더 간단하게 표현하는 방법은 공백으로 구분된 IP 주소 범위 목록을 "
"사용하는 것입니다.  첫 번째 주소에는 지정된 서브넷 마스크가 지정되고 추가 "
"주소에는 `255.255.255.255`의 서브넷 마스크가 지정됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:751
#, no-wrap
msgid "ifconfig_fxp0_aliases=\"inet 10.1.1.1-5/24 inet 202.0.75.17-20/28\"\n"
msgstr "ifconfig_fxp0_aliases=\"inet 10.1.1.1-5/24 inet 202.0.75.17-20/28\"\n"

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:754
#, no-wrap
msgid "Configuring System Logging"
msgstr "시스템 로깅 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:760
msgid ""
"Generating and reading system logs is an important aspect of system "
"administration.  The information in system logs can be used to detect "
"hardware and software issues as well as application and system configuration "
"errors.  This information also plays an important role in security auditing "
"and incident response.  Most system daemons and applications will generate "
"log entries."
msgstr ""
"시스템 로그를 생성하고 읽는 것은 시스템 관리의 중요한 측면입니다.  시스템 "
"로그의 정보는 하드웨어 및 소프트웨어 문제와 애플리케이션 및 시스템 구성 "
"오류를 감지하는 데 사용할 수 있습니다.  이 정보는 보안 감사 및 사고 대응에도 "
"중요한 역할을 합니다.  대부분의 시스템 데몬과 애플리케이션은 로그 항목을 "
"생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:766
msgid ""
"FreeBSD provides a system logger, syslogd, to manage logging.  By default, "
"syslogd is started when the system boots.  This is controlled by the "
"variable `syslogd_enable` in [.filename]#/etc/rc.conf#.  There are numerous "
"application arguments that can be set using `syslogd_flags` in [.filename]#/"
"etc/rc.conf#.  Refer to man:syslogd[8] for more information on the available "
"arguments."
msgstr ""
"FreeBSD는 로깅을 관리하기 위해 시스템 로거인 syslogd를 제공합니다.  "
"기본적으로 시스템이 부팅될 때 syslogd가 시작됩니다.  이것은 [.filename]#/etc/"
"rc.conf#의 `syslogd_enable` 변수에 의해 제어됩니다.  [.filename]#/etc/rc."
"conf#의 `syslogd_flags`를 사용하여 설정할 수 있는 애플리케이션 인수는 "
"다양합니다.  사용 가능한 인자에 대한 자세한 내용은 man:syslogd[8]을 "
"참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:768
msgid ""
"This section describes how to configure the FreeBSD system logger for both "
"local and remote logging and how to perform log rotation and log management."
msgstr ""
"이 섹션에서는 로컬 및 원격 로깅을 위해 FreeBSD 시스템 로거를 구성하는 방법과 "
"로그 로테이션 및 로그 관리를 수행하는 방법을 설명합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:769
#, no-wrap
msgid "Configuring Local Logging"
msgstr "로컬 로깅 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:776
msgid ""
"The configuration file, [.filename]#/etc/syslog.conf#, controls what syslogd "
"does with log entries as they are received.  There are several parameters to "
"control the handling of incoming events.  The _facility_ describes which "
"subsystem generated the message, such as the kernel or a daemon, and the "
"_level_ describes the severity of the event that occurred.  This makes it "
"possible to configure if and where a log message is logged, depending on the "
"facility and level.  It is also possible to take action depending on the "
"application that sent the message, and in the case of remote logging, the "
"hostname of the machine generating the logging event."
msgstr ""
"구성 파일인 [.filename]#/etc/syslog.conf#는 수신된 로그 항목에 대해 "
"syslogd가 수행하는 작업을 제어합니다.  들어오는 이벤트의 처리를 제어하는 몇 "
"가지 매개변수가 있습니다.  _facility_은 커널이나 데몬 등 메시지를 생성한 "
"하위 시스템을 설명하고, _level_은 발생한 이벤트의 심각도를 설명합니다.  이를 "
"통해 시설과 수준에 따라 로그 메시지의 기록 여부와 위치를 구성할 수 "
"있습니다.  또한 메시지를 전송한 애플리케이션과 원격 로깅의 경우 로깅 "
"이벤트를 생성하는 머신의 호스트 이름에 따라 조치를 취할 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:784
msgid ""
"This configuration file contains one line per action, where the syntax for "
"each line is a selector field followed by an action field.  The syntax of "
"the selector field is _facility.level_ which will match log messages from "
"_facility_ at level _level_ or higher.  It is also possible to add an "
"optional comparison flag before the level to specify more precisely what is "
"logged.  Multiple selector fields can be used for the same action, and are "
"separated with a semicolon (`;`).  Using `*` will match everything.  The "
"action field denotes where to send the log message, such as to a file or "
"remote log host.  As an example, here is the default [.filename]#syslog."
"conf# from FreeBSD:"
msgstr ""
"이 구성 파일에는 작업당 한 줄씩 추가되며, 각 줄의 구문은 선택기 필드 다음에 "
"작업 필드가 있습니다.  선택기 필드의 구문은 _facility.level_로, "
"_facility_에서 _level_ 이상의 로그 메시지와 일치합니다.  레벨 앞에 선택적 "
"비교 플래그를 추가하여 기록되는 내용을 보다 정확하게 지정할 수도 있습니다.  "
"동일한 작업에 여러 선택기 필드를 사용할 수 있으며 세미콜론(`;`)으로 "
"구분합니다.  `*`를 사용하면 모든 항목이 일치합니다.  작업 필드는 로그 "
"메시지를 보낼 위치(예: 파일 또는 원격 로그 호스트)를 나타냅니다.  예를 들어, "
"다음은 FreeBSD의 기본 [.filename]#syslog.conf#입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:822
#, no-wrap
msgid ""
"# $FreeBSD$\n"
"#\n"
"#       Spaces ARE valid field separators in this file. However,\n"
"#       other *nix-like systems still insist on using tabs as field\n"
"#       separators. If you are sharing this file between systems, you\n"
"#       may want to use only tabs as field separators here.\n"
"#       Consult the syslog.conf(5) manpage.\n"
"*.err;kern.warning;auth.notice;mail.crit                /dev/console\n"
"*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages\n"
"security.*                                      /var/log/security\n"
"auth.info;authpriv.info                         /var/log/auth.log\n"
"mail.info                                       /var/log/maillog\n"
"lpr.info                                        /var/log/lpd-errs\n"
"ftp.info                                        /var/log/xferlog\n"
"cron.*                                          /var/log/cron\n"
"!-devd\n"
"*.=debug                                        /var/log/debug.log\n"
"*.emerg                                         *\n"
"# uncomment this to log all writes to /dev/console to /var/log/console.log\n"
"#console.info                                   /var/log/console.log\n"
"# uncomment this to enable logging of all log messages to /var/log/all.log\n"
"# touch /var/log/all.log and chmod it to mode 600 before it will work\n"
"#*.*                                            /var/log/all.log\n"
"# uncomment this to enable logging to a remote loghost named loghost\n"
"#*.*                                            @loghost\n"
"# uncomment these if you're running inn\n"
"# news.crit                                     /var/log/news/news.crit\n"
"# news.err                                      /var/log/news/news.err\n"
"# news.notice                                   /var/log/news/news.notice\n"
"# Uncomment this if you wish to see messages produced by devd\n"
"# !devd\n"
"# *.>=info\n"
"!ppp\n"
"*.*                                             /var/log/ppp.log\n"
"!*\n"
msgstr ""
"# $FreeBSD$\n"
"#\n"
"#       Spaces ARE valid field separators in this file. However,\n"
"#       other *nix-like systems still insist on using tabs as field\n"
"#       separators. If you are sharing this file between systems, you\n"
"#       may want to use only tabs as field separators here.\n"
"#       Consult the syslog.conf(5) manpage.\n"
"*.err;kern.warning;auth.notice;mail.crit                /dev/console\n"
"*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/"
"messages\n"
"security.*                                      /var/log/security\n"
"auth.info;authpriv.info                         /var/log/auth.log\n"
"mail.info                                       /var/log/maillog\n"
"lpr.info                                        /var/log/lpd-errs\n"
"ftp.info                                        /var/log/xferlog\n"
"cron.*                                          /var/log/cron\n"
"!-devd\n"
"*.=debug                                        /var/log/debug.log\n"
"*.emerg                                         *\n"
"# uncomment this to log all writes to /dev/console to /var/log/console.log\n"
"#console.info                                   /var/log/console.log\n"
"# uncomment this to enable logging of all log messages to /var/log/all.log\n"
"# touch /var/log/all.log and chmod it to mode 600 before it will work\n"
"#*.*                                            /var/log/all.log\n"
"# uncomment this to enable logging to a remote loghost named loghost\n"
"#*.*                                            @loghost\n"
"# uncomment these if you're running inn\n"
"# news.crit                                     /var/log/news/news.crit\n"
"# news.err                                      /var/log/news/news.err\n"
"# news.notice                                   /var/log/news/news.notice\n"
"# Uncomment this if you wish to see messages produced by devd\n"
"# !devd\n"
"# *.>=info\n"
"!ppp\n"
"*.*                                             /var/log/ppp.log\n"
"!*\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:825
msgid "In this example:"
msgstr "이 예제에서는"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:827
msgid ""
"Line 8 matches all messages with a level of `err` or higher, as well as "
"`kern.warning`, `auth.notice` and `mail.crit`, and sends these log messages "
"to the console ([.filename]#/dev/console#)."
msgstr ""
"8행은 `err` 이상의 모든 메시지와 `kern.warning`, `auth.notice` 및 `mail.crit`"
"을 찾고 이러한 로그 메시지를 콘솔([.filename]#/dev/console#)로 보냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:828
msgid ""
"Line 12 matches all messages from the `mail` facility at level `info` or "
"above and logs the messages to [.filename]#/var/log/maillog#."
msgstr ""
"12줄은 `info` 레벨 이상의 `mail` 기능의 모든 메시지를 찾고 메시지를 [."
"filename]#/var/log/maillog#에 기록합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:829
msgid ""
"Line 17 uses a comparison flag (`=`) to only match messages at level `debug` "
"and logs them to [.filename]#/var/log/debug.log#."
msgstr ""
"17행은 비교 플래그(`=`)를 사용하여 `debug` 레벨의 메시지만 찾고 이를 [."
"filename]#/var/log/debug.log#에 기록합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:830
msgid ""
"Line 33 is an example usage of a program specification. This makes the rules "
"following it only valid for the specified program. In this case, only the "
"messages generated by ppp are logged to [.filename]#/var/log/ppp.log#."
msgstr ""
"33줄은 프로그램 사양의 사용 예시입니다. 따라서 그 뒤에 나오는 규칙은 지정된 "
"프로그램에 대해서만 유효합니다. 이 경우 ppp에서 생성된 메시지만 [.filename]#/"
"var/log/ppp.log#에 기록됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:832
msgid ""
"The available levels, in order from most to least critical are `emerg`, "
"`alert`, `crit`, `err`, `warning`, `notice`, `info`, and `debug`."
msgstr ""
"사용 가능한 레벨은 가장 심각한 것부터 가장 덜 심각한 것 순으로 `emerg`, "
"`alert`, `crit`, `err`, `warning`, `notice`, `info`, `debug`입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:835
msgid ""
"The facilities, in no particular order, are `auth`, `authpriv`, `console`, "
"`cron`, `daemon`, `ftp`, `kern`, `lpr`, `mail`, `mark`, `news`, `security`, "
"`syslog`, `user`, `uucp`, and `local0` through `local7`.  Be aware that "
"other operating systems might have different facilities."
msgstr ""
"특정 순서 없이 `auth`, `authpriv`, `console`, `cron`, `daemon`, `ftp`, `kern`"
", `lpr`, `mail`, `mark`, `news`, `security`, `syslog`, `user`, `uucp`, "
"`local0`~`local7`의 순서입니다.  다른 운영 체제에는 다른 기능이 있을 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:837
msgid ""
"To log everything of level `notice` and higher to [.filename]#/var/log/"
"daemon.log#, add the following entry:"
msgstr ""
"`notice` 레벨 이상의 모든 항목을 [.filename]#/var/log/daemon.log#에 "
"기록하려면 다음 항목을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:841
#, no-wrap
msgid "daemon.notice                                        /var/log/daemon.log\n"
msgstr ""
"daemon.notice                                        /var/log/daemon.log\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:845
msgid ""
"For more information about the different levels and facilities, refer to man:"
"syslog[3] and man:syslogd[8].  For more information about [.filename]#/etc/"
"syslog.conf#, its syntax, and more advanced usage examples, see man:syslog."
"conf[5]."
msgstr ""
"다양한 수준과 기능에 대한 자세한 내용은 man:syslog[3] 및 man:syslogd[8]를 "
"참조하세요.  [.filename]#/etc/syslog.conf#, 구문 및 고급 사용 예제에 대한 "
"자세한 내용은 man:syslog.conf[5]를 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:846
#, no-wrap
msgid "Log Management and Rotation"
msgstr "로그 관리 및 순환"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:855
msgid ""
"Log files can grow quickly, taking up disk space and making it more "
"difficult to locate useful information.  Log management attempts to mitigate "
"this.  In FreeBSD, newsyslog is used to manage log files.  This built-in "
"program periodically rotates and compresses log files, and optionally "
"creates missing log files and signals programs when log files are moved.  "
"The log files may be generated by syslogd or by any other program which "
"generates log files.  While newsyslog is normally run from man:cron[8], it "
"is not a system daemon.  In the default configuration, it runs every hour."
msgstr ""
"로그 파일은 빠르게 증가하여 디스크 공간을 차지하고 유용한 정보를 찾기가 더 "
"어려워질 수 있습니다.  로그 관리는 이를 완화하기 위해 사용됩니다.  "
"FreeBSD에서는 newsyslog를 사용하여 로그 파일을 관리합니다.  이 기본 제공 "
"프로그램은 주기적으로 로그 파일을 순환 및 압축하고, 선택적으로 누락된 로그 "
"파일을 생성하고 로그 파일이 이동될 때 프로그램에 신호를 보냅니다.  로그 "
"파일은 syslogd 또는 로그 파일을 생성하는 다른 프로그램에서 생성할 수 "
"있습니다.  newsyslog는 일반적으로 man:cron[8]에서 실행되지만 시스템 데몬은 "
"아닙니다.  기본 구성에서는 매시간 실행됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:860
msgid ""
"To know which actions to take, newsyslog reads its configuration file, [."
"filename]#/etc/newsyslog.conf#.  This file contains one line for each log "
"file that newsyslog manages.  Each line states the file owner, permissions, "
"when to rotate that file, optional flags that affect log rotation, such as "
"compression, and programs to signal when the log is rotated.  Here is the "
"default configuration in FreeBSD:"
msgstr ""
"어떤 조치를 취해야 하는지 알기 위해 newsyslog는 구성 파일인 [.filename]#/etc/"
"newsyslog.conf#를 읽습니다.  이 파일에는 newsyslog가 관리하는 각 로그 파일에 "
"대해 한 줄씩 포함되어 있습니다.  각 줄에는 파일 소유자, 권한, 해당 파일을 "
"회전할 시기, 압축과 같이 로그 회전에 영향을 주는 선택적 플래그, 로그가 "
"회전할 때 신호를 보내는 프로그램이 명시되어 있습니다.  다음은 FreeBSD의 기본 "
"구성입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:902
#, no-wrap
msgid ""
"# configuration file for newsyslog\n"
"# $FreeBSD$\n"
"#\n"
"# Entries which do not specify the '/pid_file' field will cause the\n"
"# syslogd process to be signalled when that log file is rotated.  This\n"
"# action is only appropriate for log files which are written to by the\n"
"# syslogd process (ie, files listed in /etc/syslog.conf).  If there\n"
"# is no process which needs to be signalled when a given log file is\n"
"# rotated, then the entry for that file should include the 'N' flag.\n"
"#\n"
"# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.\n"
"#\n"
"# Note: some sites will want to select more restrictive protections than the\n"
"# defaults.  In particular, it may be desirable to switch many of the 644\n"
"# entries to 640 or 600.  For example, some sites will consider the\n"
"# contents of maillog, messages, and lpd-errs to be confidential.  In the\n"
"# future, these defaults may change to more conservative ones.\n"
"#\n"
"# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]\n"
"/var/log/all.log                        600  7     *    @T00  J\n"
"/var/log/amd.log                        644  7     100  *     J\n"
"/var/log/auth.log                       600  7     100  @0101T JC\n"
"/var/log/console.log                    600  5     100  *     J\n"
"/var/log/cron                           600  3     100  *     JC\n"
"/var/log/daily.log                      640  7     *    @T00  JN\n"
"/var/log/debug.log                      600  7     100  *     JC\n"
"/var/log/kerberos.log                   600  7     100  *     J\n"
"/var/log/lpd-errs                       644  7     100  *     JC\n"
"/var/log/maillog                        640  7     *    @T00  JC\n"
"/var/log/messages                       644  5     100  @0101T JC\n"
"/var/log/monthly.log                    640  12    *    $M1D0 JN\n"
"/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid\n"
"/var/log/ppp.log        root:network    640  3     100  *     JC\n"
"/var/log/devd.log                       644  3     100  *     JC\n"
"/var/log/security                       600  10    100  *     JC\n"
"/var/log/sendmail.st                    640  10    *    168   B\n"
"/var/log/utx.log                        644  3     *    @01T05 B\n"
"/var/log/weekly.log                     640  5     1    $W6D0 JN\n"
"/var/log/xferlog                        600  7     100  *     JC\n"
msgstr ""
"# configuration file for newsyslog\n"
"# $FreeBSD$\n"
"#\n"
"# Entries which do not specify the '/pid_file' field will cause the\n"
"# syslogd process to be signalled when that log file is rotated.  This\n"
"# action is only appropriate for log files which are written to by the\n"
"# syslogd process (ie, files listed in /etc/syslog.conf).  If there\n"
"# is no process which needs to be signalled when a given log file is\n"
"# rotated, then the entry for that file should include the 'N' flag.\n"
"#\n"
"# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.\n"
"#\n"
"# Note: some sites will want to select more restrictive protections than "
"the\n"
"# defaults.  In particular, it may be desirable to switch many of the 644\n"
"# entries to 640 or 600.  For example, some sites will consider the\n"
"# contents of maillog, messages, and lpd-errs to be confidential.  In the\n"
"# future, these defaults may change to more conservative ones.\n"
"#\n"
"# logfilename          [owner:group]    mode count size when  flags "
"[/pid_file] [sig_num]\n"
"/var/log/all.log                        600  7     *    @T00  J\n"
"/var/log/amd.log                        644  7     100  *     J\n"
"/var/log/auth.log                       600  7     100  @0101T JC\n"
"/var/log/console.log                    600  5     100  *     J\n"
"/var/log/cron                           600  3     100  *     JC\n"
"/var/log/daily.log                      640  7     *    @T00  JN\n"
"/var/log/debug.log                      600  7     100  *     JC\n"
"/var/log/kerberos.log                   600  7     100  *     J\n"
"/var/log/lpd-errs                       644  7     100  *     JC\n"
"/var/log/maillog                        640  7     *    @T00  JC\n"
"/var/log/messages                       644  5     100  @0101T JC\n"
"/var/log/monthly.log                    640  12    *    $M1D0 JN\n"
"/var/log/pflog                          600  3     100  *     JB    /var/run/"
"pflogd.pid\n"
"/var/log/ppp.log        root:network    640  3     100  *     JC\n"
"/var/log/devd.log                       644  3     100  *     JC\n"
"/var/log/security                       600  10    100  *     JC\n"
"/var/log/sendmail.st                    640  10    *    168   B\n"
"/var/log/utx.log                        644  3     *    @01T05 B\n"
"/var/log/weekly.log                     640  5     1    $W6D0 JN\n"
"/var/log/xferlog                        600  7     100  *     JC\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:911
msgid ""
"Each line starts with the name of the log to be rotated, optionally followed "
"by an owner and group for both rotated and newly created files.  The `mode` "
"field sets the permissions on the log file and `count` denotes how many "
"rotated log files should be kept.  The `size` and `when` fields tell "
"newsyslog when to rotate the file.  A log file is rotated when either its "
"size is larger than the `size` field or when the time in the `when` field "
"has passed.  An asterisk (`*`) means that this field is ignored.  The "
"_flags_ field gives further instructions, such as how to compress the "
"rotated file or to create the log file if it is missing.  The last two "
"fields are optional and specify the name of the Process ID (PID) file of a "
"process and a signal number to send to that process when the file is rotated."
msgstr ""
"각 줄은 회전할 로그의 이름으로 시작하며, 선택적으로 회전된 파일과 새로 "
"생성된 파일 모두에 대한 소유자와 그룹이 뒤따릅니다.  `mode` 필드는 로그 "
"파일에 대한 권한을 설정하고 `count`는 보관해야 하는 회전된 로그 파일 수를 "
"나타냅니다.  `size` 및 `when` 필드는 파일을 회전할 시기를 newsyslog에 "
"알려줍니다.  로그 파일은 크기가 `size` 필드보다 크거나 `when` 필드의 시간이 "
"지나면 회전됩니다.  별표(`*`)는 이 필드가 무시됨을 의미합니다.  _flags_ "
"필드는 회전된 파일을 압축하는 방법이나 누락된 경우 로그 파일을 생성하는 "
"방법과 같은 추가 지침을 제공합니다.  마지막 두 필드는 선택 사항이며 "
"프로세스의 프로세스 ID(PID) 파일 이름과 파일이 회전될 때 해당 프로세스로 "
"전송할 신호 번호를 지정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:914
msgid ""
"For more information on all fields, valid flags, and how to specify the "
"rotation time, refer to man:newsyslog.conf[5].  Since newsyslog is run from "
"man:cron[8], it cannot rotate files more often than it is scheduled to run "
"from man:cron[8]."
msgstr ""
"모든 필드, 유효한 플래그 및 로테이션 시간을 지정하는 방법에 대한 자세한 "
"내용은 man:newsyslog.conf[5]를 참조하세요.  newsyslog는 man:cron[8]에서 "
"실행되기 때문에 man:cron[8]에서 실행되도록 예약된 것보다 더 자주 파일을 "
"회전시킬 수는 없습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:916
#, no-wrap
msgid "Configuring Remote Logging"
msgstr "원격 로깅 구성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:920
msgid ""
"Monitoring the log files of multiple hosts can become unwieldy as the number "
"of systems increases.  Configuring centralized logging can reduce some of "
"the administrative burden of log file administration."
msgstr ""
"시스템 수가 증가함에 따라 여러 호스트의 로그 파일을 모니터링하는 것이 "
"부담스러워질 수 있습니다.  중앙 집중식 로깅을 구성하면 로그 파일 관리의 관리 "
"부담을 일부 줄일 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:924
msgid ""
"In FreeBSD, centralized log file aggregation, merging, and rotation can be "
"configured using syslogd and newsyslog.  This section demonstrates an "
"example configuration, where host `A`, named `logserv.example.com`, will "
"collect logging information for the local network.  Host `B`, named "
"`logclient.example.com`, will be configured to pass logging information to "
"the logging server."
msgstr ""
"FreeBSD에서 중앙 집중식 로그 파일 집계, 병합 및 로테이션은 syslogd와 "
"newsyslog를 사용하여 구성할 수 있습니다.  이 섹션에서는 `logserv.example.com`"
"이라는 이름의 호스트 `A`가 로컬 네트워크에 대한 로깅 정보를 수집하는 구성 "
"예시를 보여줍니다.  호스트 `B`는 `logclient.example.com`이라는 이름으로 로깅 "
"정보를 로깅 서버로 전달하도록 구성됩니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:925
#, no-wrap
msgid "Log Server Configuration"
msgstr "로그 서버 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:929
msgid ""
"A log server is a system that has been configured to accept logging "
"information from other hosts.  Before configuring a log server, check the "
"following:"
msgstr "로그 서버는 다른 호스트의 로깅 정보를 받아들이도록 구성된 시스템입니다.  "
"로그 서버를 구성하기 전에 다음 사항을 확인하세요:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:931
msgid ""
"If there is a firewall between the logging server and any logging clients, "
"ensure that the firewall ruleset allows UDP port 514 for both the clients "
"and the server."
msgstr ""
"로깅 서버와 로깅 클라이언트 사이에 방화벽이 있는 경우 방화벽 규칙 집합이 "
"클라이언트와 서버 모두에 대해 UDP 포트 514를 허용하는지 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:932
msgid ""
"The logging server and all client machines must have forward and reverse "
"entries in the local DNS. If the network does not have a DNS server, create "
"entries in each system's [.filename]#/etc/hosts#. Proper name resolution is "
"required so that log entries are not rejected by the logging server."
msgstr ""
"로깅 서버와 모든 클라이언트 시스템에는 로컬 DNS에 정방향 및 역방향 항목이 "
"있어야 합니다. 네트워크에 DNS 서버가 없는 경우 각 시스템의 [.filename]#/etc/"
"hosts#에 항목을 만듭니다. 로그 항목이 로깅 서버에서 거부되지 않도록 올바른 "
"이름 확인이 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:935
msgid ""
"On the log server, edit [.filename]#/etc/syslog.conf# to specify the name of "
"the client to receive log entries from, the logging facility to be used, and "
"the name of the log to store the host's log entries.  This example adds the "
"hostname of `B`, logs all facilities, and stores the log entries in [."
"filename]#/var/log/logclient.log#."
msgstr ""
"로그 서버에서 [.filename]#/etc/syslog.conf#를 편집하여 로그 항목을 수신할 "
"클라이언트의 이름, 사용할 로깅 facility, 호스트의 로그 항목을 저장할 로그의 "
"이름을 지정합니다.  이 예제에서는 호스트 이름을 `B`로 추가하고 모든 "
"facility를 로깅한 후 로그 항목을 [.filename]#/var/log/logclient.log#에 "
"저장합니다."

#. type: Block title
#: documentation/content/en/books/handbook/config/_index.adoc:936
#, no-wrap
msgid "Sample Log Server Configuration"
msgstr "샘플 로그 서버 구성"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:944
#, no-wrap
msgid ""
"+logclient.example.com\n"
"*.*     /var/log/logclient.log\n"
msgstr ""
"+logclient.example.com\n"
"*.*     /var/log/logclient.log\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:950
msgid ""
"When adding multiple log clients, add a similar two-line entry for each "
"client.  More information about the available facilities may be found in man:"
"syslog.conf[5]."
msgstr ""
"여러 로그 클라이언트를 추가할 때는 각 클라이언트에 대해 비슷한 두 줄 항목을 "
"추가하세요.  사용 가능한 기능에 대한 자세한 내용은 man:syslog.conf[5]에서 "
"확인할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:952
msgid "Next, configure [.filename]#/etc/rc.conf#:"
msgstr "그런 다음 [.filename]#/etc/rc.conf#을 구성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:957
#, no-wrap
msgid ""
"syslogd_enable=\"YES\"\n"
"syslogd_flags=\"-a logclient.example.com -v -v\"\n"
msgstr ""
"syslogd_enable=\"YES\"\n"
"syslogd_flags=\"-a logclient.example.com -v -v\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:963
msgid ""
"The first entry starts syslogd at system boot.  The second entry allows log "
"entries from the specified client.  The `-v -v` increases the verbosity of "
"logged messages.  This is useful for tweaking facilities as administrators "
"are able to see what type of messages are being logged under each facility."
msgstr ""
"첫 번째 항목은 시스템 부팅 시 syslogd를 시작합니다.  두 번째 항목은 지정된 "
"클라이언트의 로그 항목을 허용합니다.  `-v -v`는 기록된 메시지의 상세도를 "
"높입니다.  관리자가 각 기능에서 어떤 유형의 메시지가 기록되고 있는지 확인할 "
"수 있으므로 기능을 조정하는 데 유용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:967
msgid ""
"Multiple `-a` options may be specified to allow logging from multiple "
"clients.  IP addresses and whole netblocks may also be specified.  Refer to "
"man:syslogd[8] for a full list of possible options."
msgstr ""
"여러 개의 `-a` 옵션을 지정하여 여러 클라이언트의 로깅을 허용할 수 있습니다.  "
"IP 주소와 전체 넷블록도 지정할 수 있습니다.  가능한 옵션의 전체 목록은 "
"man:syslogd[8]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:969
msgid "Finally, create the log file:"
msgstr "마지막으로 로그 파일을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:973
#, no-wrap
msgid "# touch /var/log/logclient.log\n"
msgstr "# touch /var/log/logclient.log\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:976
msgid "At this point, syslogd should be restarted and verified:"
msgstr "이 시점에서 syslogd를 다시 시작하고 확인해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:981
#, no-wrap
msgid ""
"# service syslogd restart\n"
"# pgrep syslog\n"
msgstr ""
"# service syslogd restart\n"
"# pgrep syslog\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:985
msgid ""
"If a PID is returned, the server restarted successfully, and client "
"configuration can begin.  If the server did not restart, consult [."
"filename]#/var/log/messages# for the error."
msgstr ""
"PID가 반환되면 서버가 성공적으로 재시작된 것이며 클라이언트 구성을 시작할 수 "
"있습니다.  서버가 다시 시작되지 않았다면 [.filename]#/var/log/messages#에서 "
"오류를 참조하세요."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:986
#, no-wrap
msgid "Log Client Configuration"
msgstr "로그 클라이언트 구성"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:990
msgid ""
"A logging client sends log entries to a logging server on the network.  The "
"client also keeps a local copy of its own logs."
msgstr "로깅 클라이언트는 로그 항목을 네트워크의 로깅 서버로 전송합니다.  "
"클라이언트는 자체 로그의 로컬 복사본도 보관합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:992
msgid ""
"Once a logging server has been configured, edit [.filename]#/etc/rc.conf# on "
"the logging client:"
msgstr "로깅 서버가 구성되면 로깅 클라이언트에서 [.filename]#/etc/rc.conf#를 "
"편집합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:997
#, no-wrap
msgid ""
"syslogd_enable=\"YES\"\n"
"syslogd_flags=\"-s -v -v\"\n"
msgstr ""
"syslogd_enable=\"YES\"\n"
"syslogd_flags=\"-s -v -v\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1001
msgid ""
"The first entry enables syslogd on boot up.  The second entry prevents logs "
"from being accepted by this client from other hosts (`-s`) and increases the "
"verbosity of logged messages."
msgstr ""
"첫 번째 항목은 부팅 시 syslogd를 활성화합니다.  두 번째 항목은 이 "
"클라이언트가 다른 호스트(`-s`)로부터 로그를 수신하지 못하도록 하고 기록된 "
"메시지의 상세도를 높입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1004
msgid ""
"Next, define the logging server in the client's [.filename]#/etc/syslog."
"conf#.  In this example, all logged facilities are sent to a remote system, "
"denoted by the `@` symbol, with the specified hostname:"
msgstr ""
"그런 다음 클라이언트의 [.filename]#/etc/syslog.conf#에서 로깅 서버를 "
"정의합니다.  이 예제에서는 모든 로깅된 시설이 지정된 호스트 이름으로 `@` "
"기호로 표시된 원격 시스템으로 전송됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1008
#, no-wrap
msgid "*.*\t\t@logserv.example.com\n"
msgstr "*.*\t\t@logserv.example.com\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1011
msgid "After saving the edit, restart syslogd for the changes to take effect:"
msgstr "편집 내용을 저장한 후 변경 내용을 적용하려면 syslogd를 다시 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1015
#: documentation/content/en/books/handbook/config/_index.adoc:1045
#, no-wrap
msgid "# service syslogd restart\n"
msgstr "# service syslogd restart\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1018
msgid ""
"To test that log messages are being sent across the network, use man:"
"logger[1] on the client to send a message to syslogd:"
msgstr ""
"로그 메시지가 네트워크를 통해 전송되고 있는지 테스트하려면 클라이언트에서 "
"man:logger[1]를 사용하여 syslogd로 메시지를 보내세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1022
#, no-wrap
msgid "# logger \"Test message from logclient\"\n"
msgstr "# logger \"Test message from logclient\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1025
msgid ""
"This message should now exist both in [.filename]#/var/log/messages# on the "
"client and [.filename]#/var/log/logclient.log# on the log server."
msgstr ""
"이제 이 메시지는 클라이언트의 [.filename]#/var/log/messages#와 로그 서버의 [."
"filename]#/var/log/logclient.log#에 모두 존재해야 합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1026
#, no-wrap
msgid "Debugging Log Servers"
msgstr "로그 서버 디버깅하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1032
msgid ""
"If no messages are being received on the log server, the cause is most "
"likely a network connectivity issue, a hostname resolution issue, or a typo "
"in a configuration file.  To isolate the cause, ensure that both the logging "
"server and the logging client are able to `ping` each other using the "
"hostname specified in their [.filename]#/etc/rc.conf#.  If this fails, check "
"the network cabling, the firewall ruleset, and the hostname entries in the "
"DNS server or [.filename]#/etc/hosts# on both the logging server and "
"clients.  Repeat until the `ping` is successful from both hosts."
msgstr ""
"로그 서버에 메시지가 수신되지 않는다면 네트워크 연결 문제, 호스트 이름 확인 "
"문제 또는 구성 파일의 오타가 원인일 가능성이 높습니다.  원인을 파악하려면 "
"로깅 서버와 로깅 클라이언트가 모두 [.filename]#/etc/rc.conf#에 지정된 "
"호스트명을 사용하여 서로를 `ping`할 수 있는지 확인하세요.  실패하면 네트워크 "
"케이블, 방화벽 규칙 집합, 로깅 서버와 클라이언트 모두의 DNS 서버 또는 [."
"filename]#/etc/hosts#에 있는 호스트 이름 항목을 확인하세요.  두 호스트 "
"모두에서 `ping`이 성공할 때까지 이 과정을 반복합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1036
msgid ""
"If the `ping` succeeds on both hosts but log messages are still not being "
"received, temporarily increase logging verbosity to narrow down the "
"configuration issue.  In the following example, [.filename]#/var/log/"
"logclient.log# on the logging server is empty and [.filename]#/var/log/"
"messages# on the logging client does not indicate a reason for the failure.  "
"To increase debugging output, edit the `syslogd_flags` entry on the logging "
"server and issue a restart:"
msgstr ""
"두 호스트 모두에서 `ping`이 성공했지만 로그 메시지가 여전히 수신되지 않는 "
"경우 일시적으로 로깅 상세도를 높여 구성 문제를 좁히세요.  다음 예제에서는 "
"로깅 서버의 [.filename]#/var/log/logclient.log#가 비어 있고 로깅 "
"클라이언트의 [.filename]#/var/log/messages#에 실패 사유가 표시되지 "
"않습니다.  디버깅 출력을 늘리려면 로깅 서버에서 `syslogd_flags` 항목을 "
"편집하고 다시 시작하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1040
#, no-wrap
msgid "syslogd_flags=\"-d -a logclient.example.com -v -v\"\n"
msgstr "syslogd_flags=\"-d -a logclient.example.com -v -v\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1048
msgid ""
"Debugging data similar to the following will flash on the console "
"immediately after the restart:"
msgstr "재시작 직후 콘솔에 다음과 유사한 디버깅 데이터가 깜박입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1059
#, no-wrap
msgid ""
"logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart\n"
"syslogd: restarted\n"
"logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel\n"
"Logging to FILE /var/log/messages\n"
"syslogd: kernel boot file is /boot/kernel/kernel\n"
"cvthname(192.168.1.10)\n"
"validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;\n"
"rejected in rule 0 due to name mismatch.\n"
msgstr ""
"logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart\n"
"syslogd: restarted\n"
"logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot "
"file is /boot/kernel/kernel\n"
"Logging to FILE /var/log/messages\n"
"syslogd: kernel boot file is /boot/kernel/kernel\n"
"cvthname(192.168.1.10)\n"
"validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;\n"
"rejected in rule 0 due to name mismatch.\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1064
msgid ""
"In this example, the log messages are being rejected due to a typo which "
"results in a hostname mismatch.  The client's hostname should be "
"`logclient`, not `logclien`.  Fix the typo, issue a restart, and verify the "
"results:"
msgstr ""
"이 예에서는 오타로 인해 호스트 이름 불일치가 발생하여 로그 메시지가 거부되고 "
"있습니다.  클라이언트의 호스트 이름은 `logclient`가 아니라 `logclien`이어야 "
"합니다.  오타를 수정하고 다시 시작한 후 결과를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1080
#, no-wrap
msgid ""
"# service syslogd restart\n"
"logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart\n"
"syslogd: restarted\n"
"logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel\n"
"syslogd: kernel boot file is /boot/kernel/kernel\n"
"logmsg: pri 166, flags 17, from logserv.example.com,\n"
"msg Dec 10 20:55:02 <syslog.err> logserv.example.com syslogd: exiting on signal 2\n"
"cvthname(192.168.1.10)\n"
"validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;\n"
"accepted in rule 0.\n"
"logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2\n"
"Logging to FILE /var/log/logclient.log\n"
"Logging to FILE /var/log/messages\n"
msgstr ""
"# service syslogd restart\n"
"logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart\n"
"syslogd: restarted\n"
"logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot "
"file is /boot/kernel/kernel\n"
"syslogd: kernel boot file is /boot/kernel/kernel\n"
"logmsg: pri 166, flags 17, from logserv.example.com,\n"
"msg Dec 10 20:55:02 <syslog.err> logserv.example.com syslogd: exiting on "
"signal 2\n"
"cvthname(192.168.1.10)\n"
"validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;\n"
"accepted in rule 0.\n"
"logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 "
"trhodes: Test message 2\n"
"Logging to FILE /var/log/logclient.log\n"
"Logging to FILE /var/log/messages\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1083
msgid ""
"At this point, the messages are being properly received and placed in the "
"correct file."
msgstr "이 시점에서는 메시지가 제대로 수신되어 올바른 파일에 저장되고 있는 것입니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1084
#, no-wrap
msgid "Security Considerations"
msgstr "보안 고려사항"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1090
msgid ""
"As with any network service, security requirements should be considered "
"before implementing a logging server.  Log files may contain sensitive data "
"about services enabled on the local host, user accounts, and configuration "
"data.  Network data sent from the client to the server will not be encrypted "
"or password protected.  If a need for encryption exists, consider using "
"package:security/stunnel[], which will transmit the logging data over an "
"encrypted tunnel."
msgstr ""
"다른 네트워크 서비스와 마찬가지로 로깅 서버를 구현하기 전에 보안 요구 사항을 "
"고려해야 합니다.  로그 파일에는 로컬 호스트에서 활성화된 서비스, 사용자 계정 "
"및 구성 데이터에 대한 민감한 데이터가 포함될 수 있습니다.  클라이언트에서 "
"서버로 전송되는 네트워크 데이터는 암호화되거나 비밀번호로 보호되지 "
"않습니다.  암호화가 필요한 경우, 암호화된 터널을 통해 로깅 데이터를 전송하는 "
"package:security/stunnel[] 사용을 고려하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1098
msgid ""
"Local security is also an issue.  Log files are not encrypted during use or "
"after log rotation.  Local users may access log files to gain additional "
"insight into system configuration.  Setting proper permissions on log files "
"is critical.  The built-in log rotator, newsyslog, supports setting "
"permissions on newly created and rotated log files.  Setting log files to "
"mode `600` should prevent unwanted access by local users.  Refer to man:"
"newsyslog.conf[5] for additional information."
msgstr ""
"로컬 보안도 문제입니다.  로그 파일은 사용 중 또는 로그 로테이션 후에 "
"암호화되지 않습니다.  로컬 사용자는 로그 파일에 액세스하여 시스템 구성에 "
"대한 추가 인사이트를 얻을 수 있습니다.  로그 파일에 대한 적절한 권한을 "
"설정하는 것이 중요합니다.  기본 제공 로그 로테이터인 newsyslog는 새로 생성 "
"및 로테이션되는 로그 파일에 대한 권한 설정을 지원합니다.  로그 파일을 `600` "
"모드로 설정하면 로컬 사용자의 원치 않는 액세스를 방지할 수 있습니다.  자세한 "
"내용은 man:newsyslog.conf[5]를 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:1100
#, no-wrap
msgid "Configuration Files"
msgstr "구성 파일"

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1102
#, no-wrap
msgid "[.filename]#/etc# Layout"
msgstr "[.filename]#/etc# 레이아웃"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1106
msgid ""
"There are a number of directories in which configuration information is "
"kept.  These include:"
msgstr "구성 정보가 저장되는 디렉터리에는 여러 가지가 있습니다.  여기에는 다음이 "
"포함됩니다:"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1112
#, no-wrap
msgid "[.filename]#/etc#"
msgstr "[.filename]#/etc#"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1114
#, no-wrap
msgid "Generic system-specific configuration information."
msgstr "일반적인 시스템별 구성 정보."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1115
#, no-wrap
msgid "[.filename]#/etc/defaults#"
msgstr "[.filename]#/etc/defaults#"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1117
#, no-wrap
msgid "Default versions of system configuration files."
msgstr "시스템 구성 파일의 기본 버전."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1118
#, no-wrap
msgid "[.filename]#/etc/mail#"
msgstr "[.filename]#/etc/mail#"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1120
#, no-wrap
msgid "Extra man:sendmail[8] configuration and other MTA configuration files."
msgstr "추가 man:sendmail[8] 구성 및 기타 MTA 구성 파일."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1121
#, no-wrap
msgid "[.filename]#/etc/ppp#"
msgstr "[.filename]#/etc/ppp#"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1123
#, no-wrap
msgid "Configuration for both user- and kernel-ppp programs."
msgstr "사용자 및 커널-ppp 프로그램 모두에 대한 구성."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1124
#, no-wrap
msgid "[.filename]#/usr/local/etc#"
msgstr "[.filename]#/usr/local/etc#"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1126
#, no-wrap
msgid "Configuration files for installed applications. May contain per-application subdirectories."
msgstr "설치된 애플리케이션의 구성 파일. 애플리케이션별 하위 디렉터리를 포함할 수 "
"있습니다."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1127
#, no-wrap
msgid "[.filename]#/usr/local/etc/rc.d#"
msgstr "[.filename]#/usr/local/etc/rc.d#"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1129
#, no-wrap
msgid "man:rc[8] scripts for installed applications."
msgstr "설치된 애플리케이션에 대한 man:rc[8] 스크립트."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1130
#, no-wrap
msgid "[.filename]#/var/db#"
msgstr "[.filename]#/var/db#"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1131
#, no-wrap
msgid "Automatically generated system-specific database files, such as the package database and the man:locate[1] database."
msgstr "패키지 데이터베이스 및 man:locate[1] 데이터베이스와 같은 시스템별 "
"데이터베이스 파일을 자동으로 생성합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1133
#, no-wrap
msgid "Hostnames"
msgstr "Hostnames"

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1135
#, no-wrap
msgid "[.filename]#/etc/resolv.conf#"
msgstr "[.filename]#/etc/resolv.conf#"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1138
msgid ""
"How a FreeBSD system accesses the Internet Domain Name System (DNS) is "
"controlled by man:resolv.conf[5]."
msgstr ""
"FreeBSD 시스템이 인터넷 도메인 네임 시스템(DNS)에 액세스하는 방법은 "
"man:resolv.conf[5]에 의해 제어됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1140
msgid "The most common entries to [.filename]#/etc/resolv.conf# are:"
msgstr "[.filename]#/etc/resolv.conf#의 가장 일반적인 항목은 다음과 같습니다:"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1146
#, no-wrap
msgid "`nameserver`"
msgstr "`nameserver`"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1148
#, no-wrap
msgid "The IP address of a name server the resolver should query. The servers are queried in the order listed with a maximum of three."
msgstr "확인자가 쿼리해야 하는 네임 서버의 IP 주소입니다. 서버는 나열된 순서대로 "
"쿼리되며 최대 3개까지 쿼리할 수 있습니다."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1149
#, no-wrap
msgid "`search`"
msgstr "`search`"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1151
#, no-wrap
msgid "Search list for hostname lookup. This is normally determined by the domain of the local hostname."
msgstr "호스트명 조회를 위한 검색 목록입니다. 이는 일반적으로 로컬 호스트명의 "
"도메인에 따라 결정됩니다."

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1152
#, no-wrap
msgid "`domain`"
msgstr "`domain`"

#. type: Table
#: documentation/content/en/books/handbook/config/_index.adoc:1153
#, no-wrap
msgid "The local domain name."
msgstr "로컬 도메인 네임."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1156
msgid "A typical [.filename]#/etc/resolv.conf# looks like this:"
msgstr "일반적인 [.filename]#/etc/resolv.conf#는 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1162
#, no-wrap
msgid ""
"search example.com\n"
"nameserver 147.11.1.11\n"
"nameserver 147.11.100.30\n"
msgstr ""
"search example.com\n"
"nameserver 147.11.1.11\n"
"nameserver 147.11.100.30\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1167
msgid "Only one of the `search` and `domain` options should be used."
msgstr "`search` 및 `domain` 옵션 중 하나만 사용해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1170
msgid ""
"When using DHCP, man:dhclient[8] usually rewrites [.filename]#/etc/resolv."
"conf# with information received from the DHCP server."
msgstr ""
"DHCP를 사용할 때 man:dhclient[8]는 일반적으로 DHCP 서버에서 받은 정보로 [."
"filename]#/etc/resolv.conf#를 다시 작성합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1171
#, no-wrap
msgid "[.filename]#/etc/hosts#"
msgstr "[.filename]#/etc/hosts#"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1176
msgid ""
"[.filename]#/etc/hosts# is a simple text database which works in conjunction "
"with DNS and NIS to provide host name to IP address mappings.  Entries for "
"local computers connected via a LAN can be added to this file for simplistic "
"naming purposes instead of setting up a man:named[8] server.  Additionally, "
"[.filename]#/etc/hosts# can be used to provide a local record of Internet "
"names, reducing the need to query external DNS servers for commonly accessed "
"names."
msgstr ""
"[.filename]#/etc/hosts#는 DNS 및 NIS와 함께 작동하여 호스트 이름과 IP 주소 "
"매핑을 제공하는 간단한 텍스트 데이터베이스입니다.  LAN을 통해 연결된 로컬 "
"컴퓨터에 대한 항목은 man:named[8] 서버를 설정하는 대신 간단한 명명 목적으로 "
"이 파일에 추가할 수 있습니다.  또한 [.filename]#/etc/hosts#을 사용하여 "
"인터넷 이름의 로컬 레코드를 제공할 수 있으므로 일반적으로 액세스하는 이름을 "
"외부 DNS 서버에 쿼리할 필요성을 줄일 수 있습니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1211
#, no-wrap
msgid ""
"# $FreeBSD$\n"
"#\n"
"#\n"
"# Host Database\n"
"#\n"
"# This file should contain the addresses and aliases for local hosts that\n"
"# share this file.  Replace 'my.domain' below with the domainname of your\n"
"# machine.\n"
"#\n"
"# In the presence of the domain name service or NIS, this file may\n"
"# not be consulted at all; see /etc/nsswitch.conf for the resolution order.\n"
"#\n"
"#\n"
"::1\t\t\tlocalhost localhost.my.domain\n"
"127.0.0.1\t\tlocalhost localhost.my.domain\n"
"#\n"
"# Imaginary network.\n"
"#10.0.0.2\t\tmyname.my.domain myname\n"
"#10.0.0.3\t\tmyfriend.my.domain myfriend\n"
"#\n"
"# According to RFC 1918, you can use the following IP networks for\n"
"# private nets which will never be connected to the Internet:\n"
"#\n"
"#\t10.0.0.0\t-   10.255.255.255\n"
"#\t172.16.0.0\t-   172.31.255.255\n"
"#\t192.168.0.0\t-   192.168.255.255\n"
"#\n"
"# In case you want to be able to connect to the Internet, you need\n"
"# real official assigned numbers.  Do not try to invent your own network\n"
"# numbers but instead get one from your network provider (if any) or\n"
"# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)\n"
"#\n"
msgstr ""
"# $FreeBSD$\n"
"#\n"
"#\n"
"# Host Database\n"
"#\n"
"# This file should contain the addresses and aliases for local hosts that\n"
"# share this file.  Replace 'my.domain' below with the domainname of your\n"
"# machine.\n"
"#\n"
"# In the presence of the domain name service or NIS, this file may\n"
"# not be consulted at all; see /etc/nsswitch.conf for the resolution order.\n"
"#\n"
"#\n"
"::1\t\t\tlocalhost localhost.my.domain\n"
"127.0.0.1\t\tlocalhost localhost.my.domain\n"
"#\n"
"# Imaginary network.\n"
"#10.0.0.2\t\tmyname.my.domain myname\n"
"#10.0.0.3\t\tmyfriend.my.domain myfriend\n"
"#\n"
"# According to RFC 1918, you can use the following IP networks for\n"
"# private nets which will never be connected to the Internet:\n"
"#\n"
"#\t10.0.0.0\t-   10.255.255.255\n"
"#\t172.16.0.0\t-   172.31.255.255\n"
"#\t192.168.0.0\t-   192.168.255.255\n"
"#\n"
"# In case you want to be able to connect to the Internet, you need\n"
"# real official assigned numbers.  Do not try to invent your own network\n"
"# numbers but instead get one from your network provider (if any) or\n"
"# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)\n"
"#\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1214
msgid "The format of [.filename]#/etc/hosts# is as follows:"
msgstr "[.filename]#/etc/hosts#의 형식은 다음과 같습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1218
#, no-wrap
msgid "[Internet address] [official hostname] [alias1] [alias2] ...\n"
msgstr "[Internet address] [official hostname] [alias1] [alias2] ...\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1221
msgid "For example:"
msgstr "예를 들어:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1225
#, no-wrap
msgid "10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2\n"
msgstr "10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1228
msgid "Consult man:hosts[5] for more information."
msgstr "자세한 내용은 man:hosts[5]를 참조하세요."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:1230
#, no-wrap
msgid "Tuning with man:sysctl[8]"
msgstr "man:sysctl[8]로 튜닝하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1235
msgid ""
"man:sysctl[8] is used to make changes to a running FreeBSD system.  This "
"includes many advanced options of the TCP/IP stack and virtual memory system "
"that can dramatically improve performance for an experienced system "
"administrator.  Over five hundred system variables can be read and set using "
"man:sysctl[8]."
msgstr ""
"man:sysctl[8]은 실행 중인 FreeBSD 시스템을 변경하는 데 사용됩니다.  여기에는 "
"숙련된 시스템 관리자의 성능을 크게 향상시킬 수 있는 TCP/IP 스택과 가상 "
"메모리 시스템의 많은 고급 옵션이 포함됩니다.  500개 이상의 시스템 변수를 "
"man:sysctl[8]을 사용하여 읽고 설정할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1237
msgid ""
"At its core, man:sysctl[8] serves two functions: to read and to modify "
"system settings."
msgstr "man:sysctl[8]은 기본적으로 시스템 설정을 읽고 수정하는 두 가지 기능을 "
"수행합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1239
msgid "To view all readable variables:"
msgstr "읽기 가능한 모든 변수를 보려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1243
#, no-wrap
msgid "% sysctl -a\n"
msgstr "% sysctl -a\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1246
msgid "To read a particular variable, specify its name:"
msgstr "특정 변수를 읽으려면 해당 이름을 지정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1251
#, no-wrap
msgid ""
"% sysctl kern.maxproc\n"
"kern.maxproc: 1044\n"
msgstr ""
"% sysctl kern.maxproc\n"
"kern.maxproc: 1044\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1254
msgid "To set a particular variable, use the _variable_=_value_ syntax:"
msgstr "특정 변수를 설정하려면 _variable_=_value_ 구문을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1259
#, no-wrap
msgid ""
"# sysctl kern.maxfiles=5000\n"
"kern.maxfiles: 2088 -> 5000\n"
msgstr ""
"# sysctl kern.maxfiles=5000\n"
"kern.maxfiles: 2088 -> 5000\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1262
msgid ""
"Settings of sysctl variables are usually either strings, numbers, or "
"booleans, where a boolean is `1` for yes or `0` for no."
msgstr ""
"sysctl 변수의 설정은 일반적으로 문자열, 숫자 또는 부울이며, 여기서 부울은 "
"'예'인 경우 `1`, '아니오'인 경우 `0`입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1265
msgid ""
"To automatically set some variables each time the machine boots, add them to "
"[.filename]#/etc/sysctl.conf#.  For more information, refer to man:sysctl."
"conf[5] and <<configtuning-sysctlconf>>."
msgstr ""
"머신이 부팅될 때마다 일부 변수를 자동으로 설정하려면 [.filename]#/etc/sysctl."
"conf#에 추가합니다.  자세한 내용은 man:sysctl.conf[5] 및 <<configtuning-"
"sysctlconf>>을 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1267
#, no-wrap
msgid "[.filename]#sysctl.conf#"
msgstr "[.filename]#sysctl.conf#"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1273
msgid ""
"The configuration file for man:sysctl[8], [.filename]#/etc/sysctl.conf#, "
"looks much like [.filename]#/etc/rc.conf#.  Values are set in a "
"`variable=value` form.  The specified values are set after the system goes "
"into multi-user mode.  Not all variables are settable in this mode."
msgstr ""
"man:sysctl[8]의 구성 파일인 [.filename]#/etc/sysctl.conf#는 [.filename]#/etc/"
"rc.conf#와 매우 유사합니다.  값은 `variable=value` 형식으로 설정됩니다.  "
"지정된 값은 시스템이 다중 사용자 모드로 전환된 후에 설정됩니다.  이 모드에서 "
"모든 변수를 설정할 수 있는 것은 아닙니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1275
msgid ""
"For example, to turn off logging of fatal signal exits and prevent users "
"from seeing processes started by other users, the following tunables can be "
"set in [.filename]#/etc/sysctl.conf#:"
msgstr ""
"예를 들어 치명적인 신호 종료 로깅을 끄고 다른 사용자가 시작한 프로세스가 "
"사용자에게 표시되지 않도록 하려면 [.filename]#/etc/sysctl.conf#에서 다음 "
"튜너블을 설정하면 됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1280
#, no-wrap
msgid ""
"# Do not log fatal signal exits (e.g., sig 11)\n"
"kern.logsigexit=0\n"
msgstr ""
"# Do not log fatal signal exits (e.g., sig 11)\n"
"kern.logsigexit=0\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1284
#, no-wrap
msgid ""
"# Prevent users from seeing information about processes that\n"
"# are being run under another UID.\n"
"security.bsd.see_other_uids=0\n"
msgstr ""
"# Prevent users from seeing information about processes that\n"
"# are being run under another UID.\n"
"security.bsd.see_other_uids=0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1287
#, no-wrap
msgid "man:sysctl[8] Read-only"
msgstr "man:sysctl[8] 읽기 전용"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1290
msgid ""
"In some cases it may be desirable to modify read-only man:sysctl[8] values, "
"which will require a reboot of the system."
msgstr "경우에 따라 시스템을 재부팅해야 하는 읽기 전용 man:sysctl[8] 값을 수정하는 "
"것이 바람직할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1292
msgid ""
"For instance, on some laptop models the man:cardbus[4] device will not probe "
"memory ranges and will fail with errors similar to:"
msgstr ""
"예를 들어, 일부 노트북 모델에서 man:cardbus[4] 장치는 메모리 범위를 조사하지 "
"않으며 다음과 유사한 오류로 실패합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1297
#, no-wrap
msgid ""
"cbb0: Could not map register memory\n"
"device_probe_and_attach: cbb0 attach returned 12\n"
msgstr ""
"cbb0: Could not map register memory\n"
"device_probe_and_attach: cbb0 attach returned 12\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1302
msgid ""
"The fix requires the modification of a read-only man:sysctl[8] setting.  Add "
"`hw.pci.allow_unsupported_io_range=1` to [.filename]#/boot/loader.conf# and "
"reboot.  Now man:cardbus[4] should work properly."
msgstr ""
"이 문제를 해결하려면 읽기 전용 man:sysctl[8] 설정을 수정해야 합니다.  [."
"filename]#/boot/loader.conf#에 `hw.pci.allow_unsupported_io_range=1`을 "
"추가하고 재부팅합니다.  이제 man:cardbus[4]가 제대로 작동합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:1304
#, no-wrap
msgid "Tuning Disks"
msgstr "디스크 튜닝"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1311
msgid ""
"The following section will discuss various tuning mechanisms and options "
"which may be applied to disk devices.  In many cases, disks with mechanical "
"parts, such as SCSI drives, will be the bottleneck driving down the overall "
"system performance.  While a solution is to install a drive without "
"mechanical parts, such as a solid state drive, mechanical drives are not "
"going away anytime in the near future.  When tuning disks, it is advisable "
"to utilize the features of the man:iostat[8] command to test various changes "
"to the system.  This command will allow the user to obtain valuable "
"information on system IO."
msgstr ""
"다음 섹션에서는 디스크 장치에 적용할 수 있는 다양한 튜닝 메커니즘과 옵션에 "
"대해 설명합니다.  대부분의 경우 SCSI 드라이브와 같은 기계적 부품이 포함된 "
"디스크는 전체 시스템 성능을 저하시키는 병목 현상을 유발합니다.  솔리드 "
"스테이트 드라이브와 같이 기계적 부품이 없는 드라이브를 설치하는 것이 "
"해결책이 될 수 있지만, 기계식 드라이브는 가까운 장래에 사라지지 않을 "
"것입니다.  디스크를 튜닝할 때는 man:iostat[8] 명령의 기능을 활용하여 "
"시스템에 대한 다양한 변경 사항을 테스트하는 것이 좋습니다.  이 명령을 통해 "
"사용자는 시스템 I/O에 대한 유용한 정보를 얻을 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1312
#, no-wrap
msgid "Sysctl Variables"
msgstr "Sysctl 변수"

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1314
#, no-wrap
msgid "`vfs.vmiodirenable`"
msgstr "`vfs.vmiodirenable`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1325
msgid ""
"The `vfs.vmiodirenable` man:sysctl[8] variable may be set to either `0` "
"(off) or `1` (on).  It is set to `1` by default. This variable controls how "
"directories are cached by the system.  Most directories are small, using "
"just a single fragment (typically 1 K) in the file system and typically 512 "
"bytes in the buffer cache.  With this variable turned off, the buffer cache "
"will only cache a fixed number of directories, even if the system has a huge "
"amount of memory.  When turned on, this man:sysctl[8] allows the buffer "
"cache to use the VM page cache to cache the directories, making all the "
"memory available for caching directories.  However, the minimum in-core "
"memory used to cache a directory is the physical page size (typically 4 K) "
"rather than 512 bytes.  Keeping this option enabled is recommended if the "
"system is running any services which manipulate large numbers of files.  "
"Such services can include web caches, large mail systems, and news systems.  "
"Keeping this option on will generally not reduce performance, even with the "
"wasted memory, but one should experiment to find out."
msgstr ""
"`vfs.vmiodirenable` man:sysctl[8] 변수는 `0`(꺼짐) 또는 `1`(켜짐)로 설정할 "
"수 있습니다.  기본적으로 `1`로 설정되어 있습니다. 이 변수는 시스템에서 "
"디렉터리를 캐시하는 방법을 제어합니다.  대부분의 디렉터리는 파일 시스템에서 "
"단일 조각(일반적으로 1K)만 사용하고 버퍼 캐시에서 일반적으로 512바이트를 "
"사용하는 작은 크기입니다.  이 변수를 끄면 시스템에 엄청난 양의 메모리가 "
"있더라도 버퍼 캐시는 정해진 수의 디렉터리만 캐시합니다.  이 man:sysctl[8]을 "
"켜면 버퍼 캐시가 VM 페이지 캐시를 사용하여 디렉터리를 캐시할 수 있으므로 "
"디렉터리를 캐시하는 데 모든 메모리를 사용할 수 있습니다.  그러나 디렉토리를 "
"캐시하는 데 사용되는 최소 인코어 메모리는 512바이트가 아닌 물리적 페이지 "
"크기(일반적으로 4K)입니다.  시스템에서 많은 수의 파일을 조작하는 서비스를 "
"실행하는 경우 이 옵션을 활성화하는 것이 좋습니다.  이러한 서비스에는 웹 "
"캐시, 대용량 메일 시스템 및 뉴스 시스템이 포함될 수 있습니다.  이 옵션을 "
"켜두면 일반적으로 메모리가 낭비되더라도 성능이 저하되지 않지만 실험을 통해 "
"확인해야 합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1326
#, no-wrap
msgid "`vfs.write_behind`"
msgstr "`vfs.write_behind`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1332
msgid ""
"The `vfs.write_behind` man:sysctl[8] variable defaults to `1` (on).  This "
"tells the file system to issue media writes as full clusters are collected, "
"which typically occurs when writing large sequential files.  This avoids "
"saturating the buffer cache with dirty buffers when it would not benefit I/O "
"performance.  However, this may stall processes and under certain "
"circumstances should be turned off."
msgstr ""
"`vfs.write_behind` man:sysctl[8] 변수의 기본값은 `1`(켜짐)입니다.  이는 "
"일반적으로 대용량 순차 파일을 쓸 때 발생하는 전체 클러스터가 수집될 때 "
"미디어 쓰기를 실행하도록 파일 시스템에 지시합니다.  이렇게 하면 I/O 성능에 "
"도움이 되지 않을 때 더티 버퍼로 버퍼 캐시가 포화되는 것을 방지할 수 "
"있습니다.  하지만 프로세스가 중단될 수 있으므로 특정 상황에서는 이 기능을 "
"해제해야 합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1333
#, no-wrap
msgid "`vfs.hirunningspace`"
msgstr "`vfs.hirunningspace`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1339
msgid ""
"The `vfs.hirunningspace` man:sysctl[8] variable determines how much "
"outstanding write I/O may be queued to disk controllers system-wide at any "
"given instance.  The default is usually sufficient, but on machines with "
"many disks, try bumping it up to four or five _megabytes_.  Setting too high "
"a value which exceeds the buffer cache's write threshold can lead to bad "
"clustering performance.  Do not set this value arbitrarily high as higher "
"write values may add latency to reads occurring at the same time."
msgstr ""
"`vfs.hirunningspace` man:sysctl[8] 변수는 특정 인스턴스에서 시스템 전체의 "
"디스크 컨트롤러 큐에 대기할 수 있는 미결 쓰기 I/O의 양을 결정합니다.  "
"기본값은 일반적으로 충분하지만 디스크가 많은 시스템에서는 4~5메가바이트까지 "
"늘려보세요.  버퍼 캐시의 쓰기 임계값을 초과하는 값을 너무 높게 설정하면 "
"클러스터링 성능이 저하될 수 있습니다.  쓰기 값이 높으면 동시에 발생하는 "
"읽기에 지연 시간이 추가될 수 있으므로 이 값을 임의로 높게 설정하지 마세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1342
msgid ""
"There are various other buffer cache and VM page cache related man:sysctl[8] "
"values.  Modifying these values is not recommended as the VM system does a "
"good job of automatically tuning itself."
msgstr ""
"그 외에도 버퍼 캐시 및 VM 페이지 캐시와 관련된 다양한 man:sysctl[8] 값이 "
"있습니다.  이러한 값은 VM 시스템에서 자동으로 잘 조정되므로 수정하지 않는 "
"것이 좋습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1343
#, no-wrap
msgid "`vm.swap_idle_enabled`"
msgstr "`vm.swap_idle_enabled`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1351
msgid ""
"The `vm.swap_idle_enabled` man:sysctl[8] variable is useful in large multi-"
"user systems with many active login users and lots of idle processes.  Such "
"systems tend to generate continuous pressure on free memory reserves.  "
"Turning this feature on and tweaking the swapout hysteresis (in idle "
"seconds) via `vm.swap_idle_threshold1` and `vm.swap_idle_threshold2` "
"depresses the priority of memory pages associated with idle processes more "
"quickly then the normal pageout algorithm.  This gives a helping hand to the "
"pageout daemon.  Only turn this option on if needed, because the tradeoff is "
"essentially pre-page memory sooner rather than later which eats more swap "
"and disk bandwidth.  In a small system this option will have a determinable "
"effect, but in a large system that is already doing moderate paging, this "
"option allows the VM system to stage whole processes into and out of memory "
"easily."
msgstr ""
"man:sysctl[8] 변수는 활성 로그인 사용자가 많고 유휴 프로세스가 많은 대규모 "
"다중 사용자 시스템에서 유용합니다.  이러한 시스템은 사용 가능한 메모리에 "
"지속적인 압박을 가하는 경향이 있습니다.  이 기능을 켜고 `vm."
"swap_idle_threshold1` 및 `vm.swap_idle_threshold2`를 통해 스왑아웃 "
"히스테리시스(유휴 초 단위)를 조정하면 일반 페이지아웃 알고리즘보다 유휴 "
"프로세스와 관련된 메모리 페이지의 우선 순위가 더 빨리 낮아집니다.  이는 "
"페이지아웃 데몬에 도움을 줍니다.  이 옵션은 기본적으로 메모리를 더 빨리 사전 "
"페이지화하여 더 많은 스왑 및 디스크 대역폭을 사용한다는 단점이 있으므로 "
"필요한 경우에만 이 옵션을 켜세요.  소규모 시스템에서는 이 옵션이 결정적인 "
"영향을 미치지만, 이미 중간 정도의 페이징을 수행하는 대규모 시스템에서는 이 "
"옵션을 사용하면 VM 시스템이 전체 프로세스를 메모리 안팎으로 쉽게 스테이징할 "
"수 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1352
#, no-wrap
msgid "`hw.ata.wc`"
msgstr "`hw.ata.wc`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1360
msgid ""
"Turning off IDE write caching reduces write bandwidth to IDE disks, but may "
"sometimes be necessary due to data consistency issues introduced by hard "
"drive vendors.  The problem is that some IDE drives lie about when a write "
"completes.  With IDE write caching turned on, IDE hard drives write data to "
"disk out of order and will sometimes delay writing some blocks indefinitely "
"when under heavy disk load.  A crash or power failure may cause serious file "
"system corruption.  Check the default on the system by observing the `hw.ata."
"wc` man:sysctl[8] variable.  If IDE write caching is turned off, one can set "
"this read-only variable to `1` in [.filename]#/boot/loader.conf# in order to "
"enable it at boot time."
msgstr ""
"IDE 쓰기 캐싱을 끄면 IDE 디스크에 대한 쓰기 대역폭이 줄어들지만, 하드 "
"드라이브 공급업체에서 도입한 데이터 일관성 문제를 해결하기위해 필요할 수도 "
"있습니다.  문제는 일부 IDE 드라이브가 쓰기 완료 시점에 대해 거짓말을 한다는 "
"것입니다.  IDE 쓰기 캐싱이 켜져 있으면 IDE 하드 드라이브는 디스크에 데이터를 "
"순서대로 쓰지 않고 디스크 부하가 많을 때 일부 블록 쓰기를 무기한 지연시킬 수 "
"있습니다.  충돌 또는 정전으로 인해 심각한 파일 시스템 손상이 발생할 수 "
"있습니다.  `hw.ata.wc` man:sysctl[8] 변수를 관찰하여 시스템의 기본값을 "
"확인하십시오.  IDE 쓰기 캐싱이 꺼져 있는 경우, 부팅 시 활성화하려면 [."
"filename]#/boot/loader.conf#에서 이 읽기 전용 변수를 `1`로 설정합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1362
msgid "For more information, refer to man:ata[4]."
msgstr "자세한 내용은 man:ata[4]를 참조하세요."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1363
#, no-wrap
msgid "`SCSI_DELAY` (`kern.cam.scsi_delay`)"
msgstr "`SCSI_DELAY` (`kern.cam.scsi_delay`)"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1370
msgid ""
"The `SCSI_DELAY` kernel configuration option may be used to reduce system "
"boot times.  The defaults are fairly high and can be responsible for `15` "
"seconds of delay in the boot process.  Reducing it to `5` seconds usually "
"works with modern drives.  The `kern.cam.scsi_delay` boot time tunable "
"should be used.  The tunable and kernel configuration option accept values "
"in terms of _milliseconds_ and _not seconds_."
msgstr ""
"시스템 부팅 시간을 줄이기 위해 `SCSI_DELAY` 커널 구성 옵션을 사용할 수 "
"있습니다.  기본값은 상당히 높으며 부팅 프로세스에서 `15`초의 지연을 초래할 "
"수 있습니다.  이를 `5`초로 줄여도 일반적인 최신 드라이브에서 잘 작동합니다.  "
"부팅 시간 튜너블인 `kern.cam.scsi_delay`를 사용해야 합니다.  튜너블 및 커널 "
"구성 옵션은 _초 단위_가 아닌, _밀리초(ms)_ 단위를 사용합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1372
#, no-wrap
msgid "Soft Updates"
msgstr "소프트 업데이트 (Soft Updates)"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1377
msgid ""
"To fine-tune a file system, use man:tunefs[8].  This program has many "
"different options.  To toggle Soft Updates on and off, use:"
msgstr ""
"파일 시스템을 미세 조정하려면 man:tunefs[8]를 사용하세요.  이 프로그램에는 "
"다양한 옵션이 있습니다.  소프트 업데이트를 켜고 끄려면 다음을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1382
#, no-wrap
msgid ""
"# tunefs -n enable /filesystem\n"
"# tunefs -n disable /filesystem\n"
msgstr ""
"# tunefs -n enable /filesystem\n"
"# tunefs -n disable /filesystem\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1386
msgid ""
"A file system cannot be modified with man:tunefs[8] while it is mounted.  A "
"good time to enable Soft Updates is before any partitions have been mounted, "
"in single-user mode."
msgstr ""
"파일 시스템이 마운트되어 있는 동안에는 man:tunefs[8]로 파일 시스템을 수정할 "
"수 없습니다.  단일 사용자 모드에서 파티션을 마운트하기 전에 소프트 "
"업데이트를 활성화하는 것이 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1393
msgid ""
"Soft Updates is recommended for UFS file systems as it drastically improves "
"meta-data performance, mainly file creation and deletion, through the use of "
"a memory cache.  There are two downsides to Soft Updates to be aware of.  "
"First, Soft Updates guarantee file system consistency in the case of a "
"crash, but could easily be several seconds or even a minute behind updating "
"the physical disk.  If the system crashes, unwritten data may be lost.  "
"Secondly, Soft Updates delay the freeing of file system blocks.  If the root "
"file system is almost full, performing a major update, such as `make "
"installworld`, can cause the file system to run out of space and the update "
"to fail."
msgstr ""
"소프트 업데이트는 메모리 캐시를 사용하여 주로 파일 생성 및 삭제와 같은 "
"메타데이터 성능을 크게 향상시키므로 UFS 파일 시스템에서 권장됩니다.  소프트 "
"업데이트에는 두 가지 단점이 있습니다.  첫째, 소프트 업데이트는 충돌이 발생할 "
"경우 파일 시스템 일관성을 보장하지만, 실제 디스크 업데이트보다 몇 초 또는 몇 "
"분 정도 늦어질 수 있습니다.  시스템이 충돌하면 기록되지 않은 데이터가 손실될 "
"수 있습니다.  둘째, 소프트 업데이트는 파일 시스템 블록의 해제 시간을 "
"지연시킵니다.  루트 파일 시스템이 거의 꽉 차 있는 경우 `make installworld`와 "
"같은 큰 규모의 업데이트를 수행하면 파일 시스템의 공간이 부족하여 업데이트가 "
"실패할 수 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1394
#, no-wrap
msgid "More Details About Soft Updates"
msgstr "소프트 업데이트에 대한 보다 자세한 정보"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1398
msgid ""
"Meta-data updates are updates to non-content data like inodes or "
"directories.  There are two traditional approaches to writing a file "
"system's meta-data back to disk."
msgstr ""
"메타데이터 업데이트는 이노드나 디렉터리와 같은 콘텐츠가 아닌 데이터에 대한 "
"업데이트입니다.  파일 시스템의 메타데이터를 디스크에 다시 쓰는 전통적인 접근 "
"방식에는 두 가지가 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1411
msgid ""
"Historically, the default behavior was to write out meta-data updates "
"synchronously.  If a directory changed, the system waited until the change "
"was actually written to disk.  The file data buffers (file contents) were "
"passed through the buffer cache and backed up to disk later on "
"asynchronously.  The advantage of this implementation is that it operates "
"safely.  If there is a failure during an update, meta-data is always in a "
"consistent state.  A file is either created completely or not at all.  If "
"the data blocks of a file did not find their way out of the buffer cache "
"onto the disk by the time of the crash, man:fsck[8] recognizes this and "
"repairs the file system by setting the file length to `0`.  Additionally, "
"the implementation is clear and simple.  The disadvantage is that meta-data "
"changes are slow.  For example, `rm -r` touches all the files in a directory "
"sequentially, but each directory change will be written synchronously to the "
"disk.  This includes updates to the directory itself, to the inode table, "
"and possibly to indirect blocks allocated by the file.  Similar "
"considerations apply for unrolling large hierarchies using `tar -x`."
msgstr ""
"역사적으로 메타데이터 업데이트를 동기식으로 기록하는 것이 기본 "
"동작이었습니다.  디렉터리가 변경되면 시스템은 변경 내용이 실제로 디스크에 "
"기록될 때까지 기다렸습니다.  파일 데이터 버퍼(파일 내용)는 버퍼 캐시를 "
"통과하여 나중에 비동기적으로 디스크에 백업되었습니다.  이 구현의 장점은 "
"안전하게 작동한다는 것입니다.  업데이트 중에 장애가 발생하더라도 "
"메타데이터는 항상 일관된 상태를 유지합니다.  파일은 완전히 생성되거나 전혀 "
"생성되지 않습니다.  파일의 데이터 블록이 크래시 시점까지 버퍼 캐시에서 "
"디스크로 이동하지 못한 경우, man:fsck[8]는 이를 인식하고 파일 길이를 `0`으로 "
"설정하여 파일 시스템을 복구합니다.  또한 구현이 명확하고 간단합니다.  단점은 "
"메타 데이터 변경이 느리다는 것입니다.  예를 들어 `rm -r`은 디렉터리의 모든 "
"파일을 순차적으로 변경하지만 각 디렉터리 변경 사항은 디스크에 동기적으로 "
"기록됩니다.  여기에는 디렉터리 자체, inode 테이블, 파일이 할당하는 간접 "
"블록에 대한 업데이트가 포함됩니다. `tar -x'를 사용하여 복잡한 계층 구조의 "
"압축을 풀 때도 비슷한 고려 사항이 적용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1422
msgid ""
"The second approach is to use asynchronous meta-data updates.  This is the "
"default for a UFS file system mounted with `mount -o async`.  Since all meta-"
"data updates are also passed through the buffer cache, they will be "
"intermixed with the updates of the file content data.  The advantage of this "
"implementation is there is no need to wait until each meta-data update has "
"been written to disk, so all operations which cause huge amounts of meta-"
"data updates work much faster than in the synchronous case.  This "
"implementation is still clear and simple, so there is a low risk for bugs "
"creeping into the code.  The disadvantage is that there is no guarantee for "
"a consistent state of the file system If there is a failure during an "
"operation that updated large amounts of meta-data, like a power failure or "
"someone pressing the reset button, the file system will be left in an "
"unpredictable state.  There is no opportunity to examine the state of the "
"file system when the system comes up again as the data blocks of a file "
"could already have been written to the disk while the updates of the inode "
"table or the associated directory were not.  It is impossible to implement a "
"man:fsck[8] which is able to clean up the resulting chaos because the "
"necessary information is not available on the disk.  If the file system has "
"been damaged beyond repair, the only choice is to reformat it and restore "
"from backup."
msgstr ""
"두 번째 접근 방식은 비동기 메타데이터 업데이트를 사용하는 것입니다.  이것은 `"
"mount -o async`로 마운트된 UFS 파일 시스템의 기본값입니다.  모든 메타데이터 "
"업데이트도 버퍼 캐시를 통해 전달되므로 파일 콘텐츠 데이터의 업데이트와 "
"혼합됩니다.  이 구현의 장점은 각 메타데이터 업데이트가 디스크에 기록될 "
"때까지 기다릴 필요가 없으므로 대량의 메타데이터 업데이트를 유발하는 모든 "
"작업이 동기식 경우보다 훨씬 빠르게 작동한다는 것입니다.  이 구현은 여전히 "
"명확하고 간단하므로 코드에 버그가 숨어 있을 위험이 낮습니다.  단점은 파일 "
"시스템의 일관된 상태를 보장할 수 없다는 것입니다. 대량의 메타데이터를 "
"업데이트하는 작업 중에 정전이나 누군가 리셋 버튼을 누르는 등의 장애가 "
"발생하면 파일 시스템이 예측할 수 없는 상태로 남게 됩니다.  파일의 데이터 "
"블록은 이미 디스크에 기록되었을 수 있지만, 이노드 테이블이나 관련 디렉터리의 "
"업데이트는 기록되지 않았을 수 있으므로 시스템이 다시 시작될 때 파일 시스템의 "
"상태를 검사할 기회가 없습니다.  디스크에서 필요한 정보를 사용할 수 없기 "
"때문에 그로 인한 혼돈을 정리할 수 있는 man:fsck[8]를 구현하는 것은 "
"불가능합니다.  파일 시스템이 복구할 수 없을 정도로 손상된 경우 유일한 선택은 "
"파일 시스템을 다시 포맷하고 백업에서 복원하는 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1430
msgid ""
"The usual solution for this problem is to implement _dirty region logging_, "
"which is also referred to as _journaling_.  Meta-data updates are still "
"written synchronously, but only into a small region of the disk.  Later on, "
"they are moved to their proper location.  Since the logging area is a small, "
"contiguous region on the disk, there are no long distances for the disk "
"heads to move, even during heavy operations, so these operations are quicker "
"than synchronous updates.  Additionally, the complexity of the "
"implementation is limited, so the risk of bugs being present is low.  A "
"disadvantage is that all meta-data is written twice, once into the logging "
"region and once to the proper location, so performance \"pessimization\" "
"might result.  On the other hand, in case of a crash, all pending meta-data "
"operations can be either quickly rolled back or completed from the logging "
"area after the system comes up again, resulting in a fast file system "
"startup."
msgstr ""
"이 문제에 대한 일반적인 해결책은 _저널링_이라고도 하는 _더티 영역 로깅_을 "
"구현하는 것입니다.  메타데이터 업데이트는 여전히 동기식으로 기록되지만 "
"디스크의 작은 영역에만 기록됩니다.  나중에 적절한 위치로 이동됩니다.  로깅 "
"영역은 디스크의 작고 인접한 영역이므로 작업이 많은 경우에도 디스크 헤드가 "
"이동해야 하는 거리가 길지 않으므로 이러한 작업이 동기식 업데이트보다 "
"빠릅니다.  또한 구현의 복잡성이 제한되어 있으므로 버그가 발생할 위험이 "
"낮습니다.  단점은 모든 메타데이터가 로깅 영역에 한 번, 적절한 위치에 한 번씩 "
"두 번 기록되므로 성능이 저하될 수 있다는 것입니다.  반면에 충돌이 발생하면 "
"보류 중인 모든 메타데이터 작업을 빠르게 롤백하거나 시스템이 다시 가동된 후 "
"로깅 영역에서 완료할 수 있으므로 파일 시스템을 빠르게 시작할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1446
msgid ""
"Kirk McKusick, the developer of Berkeley FFS, solved this problem with Soft "
"Updates.  All pending meta-data updates are kept in memory and written out "
"to disk in a sorted sequence (\"ordered meta-data updates\").  This has the "
"effect that, in case of heavy meta-data operations, later updates to an item "
"\"catch\" the earlier ones which are still in memory and have not already "
"been written to disk.  All operations are generally performed in memory "
"before the update is written to disk and the data blocks are sorted "
"according to their position so that they will not be on the disk ahead of "
"their meta-data.  If the system crashes, an implicit \"log rewind\" causes "
"all operations which were not written to the disk appear as if they never "
"happened.  A consistent file system state is maintained that appears to be "
"the one of 30 to 60 seconds earlier.  The algorithm used guarantees that all "
"resources in use are marked as such in their blocks and inodes.  After a "
"crash, the only resource allocation error that occurs is that resources are "
"marked as \"used\" which are actually \"free\".  man:fsck[8] recognizes this "
"situation, and frees the resources that are no longer used.  It is safe to "
"ignore the dirty state of the file system after a crash by forcibly mounting "
"it with `mount -f`.  In order to free resources that may be unused, man:"
"fsck[8] needs to be run at a later time.  This is the idea behind the "
"_background man:fsck[8]_: at system startup time, only a _snapshot_ of the "
"file system is recorded and man:fsck[8] is run afterwards.  All file systems "
"can then be mounted \"dirty\", so the system startup proceeds in multi-user "
"mode.  Then, background man:fsck[8] is scheduled for all file systems where "
"this is required, to free resources that may be unused.  File systems that "
"do not use Soft Updates still need the usual foreground man:fsck[8]."
msgstr ""
"버클리 FFS의 개발자 Kirk McKusick은 소프트 업데이트로 이 문제를 "
"해결했습니다.  보류 중인 모든 메타데이터 업데이트는 메모리에 보관되고 정렬된 "
"순서(\"정렬된 메타데이터 업데이트\")로 디스크에 기록됩니다.  이렇게 하면 "
"메타데이터 작업이 많은 경우 나중에 항목에 대한 업데이트가 아직 메모리에 남아 "
"있고 디스크에 아직 기록되지 않은 이전 업데이트를 \"포착\"하는 효과가 "
"있습니다.  모든 작업은 일반적으로 업데이트가 디스크에 기록되기 전에 "
"메모리에서 수행되며, 데이터 블록은 위치에 따라 정렬되어 메타 데이터보다 "
"디스크에 먼저 기록되지 않습니다.  시스템이 충돌하면 암시적 '로그 되감기'로 "
"인해 디스크에 기록되지 않은 모든 작업이 마치 발생한 적이 없는 것처럼 "
"표시됩니다.  30~60초 전의 파일 시스템 상태가 일관되게 유지됩니다.  사용된 "
"알고리즘은 사용 중인 모든 리소스가 해당 블록과 이노드에 표시되도록 "
"보장합니다.  크래시 후 발생하는 유일한 리소스 할당 오류는 실제로는 \"비었음"
"\"인 리소스가 \"사용 중\"으로 표시되는 것입니다. man:fsck[8]는 이 상황을 "
"인식하고 더 이상 사용되지 않는 리소스를 해제합니다.  `mount -f`로 강제 "
"마운트하여 크래시 후 파일 시스템의 더티 상태를 무시하는 것이 안전합니다.  "
"사용하지 않을 수 있는 리소스를 확보하려면 나중에 man:fsck[8]를 실행해야 "
"합니다.  이것이 바로 시스템 시작 시 파일 시스템의 _스냅샷_만 기록하고 나중에 "
"man:fsck[8]을 실행하는 _background man:fsck[8]_의 아이디어입니다.  그러면 "
"모든 파일 시스템을 \"더티\" 마운트할 수 있으므로 시스템 시작이 다중 사용자 "
"모드에서 진행됩니다.  그런 다음 백그라운드 man:fsck[8]가 필요한 모든 파일 "
"시스템에 대해 스케줄링되어 사용되지 않을 수 있는 리소스를 해제합니다.  "
"소프트 업데이트를 사용하지 않는 파일 시스템에는 여전히 일반적인 포그라운드 "
"man:fsck[8]가 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1453
msgid ""
"The advantage is that meta-data operations are nearly as fast as "
"asynchronous updates and are faster than _logging_, which has to write the "
"meta-data twice.  The disadvantages are the complexity of the code, a higher "
"memory consumption, and some idiosyncrasies.  After a crash, the state of "
"the file system appears to be somewhat \"older\".  In situations where the "
"standard synchronous approach would have caused some zero-length files to "
"remain after the man:fsck[8], these files do not exist at all with Soft "
"Updates because neither the meta-data nor the file contents have been "
"written to disk.  Disk space is not released until the updates have been "
"written to disk, which may take place some time after running man:rm[1].  "
"This may cause problems when installing large amounts of data on a file "
"system that does not have enough free space to hold all the files twice."
msgstr ""
"장점은 메타데이터 작업이 비동기 업데이트만큼 빠르며 메타데이터를 두 번 써야 "
"하는 _logging_보다 빠르다는 것입니다.  단점은 코드가 복잡하고 메모리를 더 "
"많이 사용하며 몇 가지 특이한 점이 있다는 것입니다.  충돌 후 파일 시스템의 "
"상태는 다소 \"오래된\" 것처럼 보입니다.  표준 동기식 접근 방식에서는 "
"man:fsck[8] 이후에도 길이가 0인 파일이 일부 남아있을 수 있지만, 소프트 "
"업데이트에서는 메타데이터나 파일 내용이 디스크에 기록되지 않았기 때문에 "
"이러한 파일이 전혀 존재하지 않습니다.  디스크 공간은 업데이트가 디스크에 "
"기록될 때까지 해제되지 않으며, 이는 man:rm[1]을 실행한 후 일정 시간이 지난 "
"후에 발생할 수 있습니다.  모든 파일을 두 번 저장할 수 있는 충분한 여유 "
"공간이 없는 파일 시스템에 많은 양의 데이터를 설치할 때 문제가 발생할 수 "
"있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:1455
#, no-wrap
msgid "Tuning Kernel Limits"
msgstr "커널 제한 튜닝하기"

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1458
#, no-wrap
msgid "File/Process Limits"
msgstr "파일/프로세스 제한"

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1461
#, no-wrap
msgid "`kern.maxfiles`"
msgstr "`kern.maxfiles`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1466
msgid ""
"The `kern.maxfiles` man:sysctl[8] variable can be raised or lowered based "
"upon system requirements.  This variable indicates the maximum number of "
"file descriptors on the system.  When the file descriptor table is full, "
"`file: table is full` will show up repeatedly in the system message buffer, "
"which can be viewed using man:dmesg[8]."
msgstr ""
"`kern.maxfiles` man:sysctl[8] 변수는 시스템 요구 사항에 따라 높이거나 낮출 "
"수 있습니다.  이 변수는 시스템에서 파일 기술자(descriptor)의 최대 수를 "
"나타냅니다.  파일 기술자 테이블이 가득 차면 시스템 메시지 버퍼에 `file: "
"table is full`이 반복적으로 표시되며, 이는 man:dmesg[8]을 사용하여 확인할 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1469
msgid ""
"Each open file, socket, or fifo uses one file descriptor.  A large-scale "
"production server may easily require many thousands of file descriptors, "
"depending on the kind and number of services running concurrently."
msgstr ""
"열려 있는 파일, 소켓 또는 fifo는 각각 하나의 파일 기술자를 사용합니다.  "
"대규모 프로덕션 서버에는 동시에 실행되는 서비스의 종류와 수에 따라 수천 개의 "
"파일 설명자가 필요할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1475
msgid ""
"In older FreeBSD releases, the default value of `kern.maxfiles` is derived "
"from `maxusers` in the kernel configuration file.  `kern.maxfiles` grows "
"proportionally to the value of `maxusers`.  When compiling a custom kernel, "
"consider setting this kernel configuration option according to the use of "
"the system.  From this number, the kernel is given most of its pre-defined "
"limits.  Even though a production machine may not have 256 concurrent users, "
"the resources needed may be similar to a high-scale web server."
msgstr ""
"이전 FreeBSD 릴리즈에서, `kern.maxfiles`의 기본값은 커널 구성 파일의 "
"`maxusers`에서 파생됩니다.  `kern.maxfiles는 `maxusers`의 값에 비례하여 "
"증가합니다.  커스텀 커널을 컴파일할 때 시스템 용도에 따라 이 커널 구성 "
"옵션을 설정하는 것을 고려하세요.  이 수치에서 커널은 대부분의 사전 정의된 "
"한계를 부여받습니다.  프로덕션 머신의 동시 사용자 수가 256명이 아닐지라도 "
"필요한 리소스는 대규모 웹 서버와 비슷할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1481
msgid ""
"The read-only man:sysctl[8] variable `kern.maxusers` is automatically sized "
"at boot based on the amount of memory available in the system, and may be "
"determined at run-time by inspecting the value of `kern.maxusers`.  Some "
"systems require larger or smaller values of `kern.maxusers` and values of "
"`64`, `128`, and `256` are not uncommon.  Going above `256` is not "
"recommended unless a huge number of file descriptors is needed.  Many of the "
"tunable values set to their defaults by `kern.maxusers` may be individually "
"overridden at boot-time or run-time in [.filename]#/boot/loader.conf#.  "
"Refer to man:loader.conf[5] and [.filename]#/boot/defaults/loader.conf# for "
"more details and some hints."
msgstr ""
"읽기 전용 man:sysctl[8] 변수 `kern.maxusers`는 시스템에서 사용 가능한 메모리 "
"양에 따라 부팅 시 자동으로 크기가 결정되며, 런타임에 `kern.maxusers`의 값을 "
"검사하여 결정될 수 있습니다.  일부 시스템에서는 더 크거나 작은 값을 필요로 "
"하며 `64`, `128`, `256`의 값은 드물지 않습니다.  많은 수의 파일 기술자가 "
"필요하지 않는 한 `256`을 초과하는 것은 권장하지 않습니다.  `kern.maxusers`에 "
"의해 기본값으로 설정된 많은 조정 가능한 값은 부팅 시간 또는 런타임에 [."
"filename]#/boot/loader.conf#에서 개별적으로 재정의할 수 있습니다.  자세한 "
"내용과 몇 가지 힌트는 man:loader.conf[5] 및 [.filename]#/boot/defaults/loader"
".conf#를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1489
msgid ""
"In older releases, the system will auto-tune `maxusers` if it is set to `0`. "
"footnote:[The auto-tuning algorithm sets maxusers equal to the amount of "
"memory in the system, with a minimum of 32, and a maximum of 384.].  When "
"setting this option, set `maxusers` to at least `4`, especially if the "
"system runs Xorg or is used to compile software.  The most important table "
"set by `maxusers` is the maximum number of processes, which is set to `20 + "
"16 * maxusers`.  If `maxusers` is set to `1`, there can only be `36` "
"simultaneous processes, including the `18` or so that the system starts up "
"at boot time and the `15` or so used by Xorg.  Even a simple task like "
"reading a manual page will start up nine processes to filter, decompress, "
"and view it.  Setting `maxusers` to `64` allows up to `1044` simultaneous "
"processes, which should be enough for nearly all uses.  If, however, the "
"error is displayed when trying to start another program, or a server is "
"running with a large number of simultaneous users, increase the number and "
"rebuild."
msgstr ""
"과거 릴리스에선 `maxusers`가 `0`으로 설정되어 있으면 자동 튜닝이 되었습니다. "
"footnote:[자동 튜닝 알고리즘은 최소 32에서 최대 384까지 시스템의 메모리 양과 "
"동일한 최대 사용자를 자동 튜닝합니다.]  이 옵션을 설정할 때, 특히 시스템이 "
"Xorg를 실행하거나 소프트웨어 컴파일에 사용되는 경우 `maxusers`를 최소 `4`로 "
"설정하세요.  `maxusers`로 설정되는 가장 중요한 테이블은 최대 프로세스 "
"수이며, `20 + 16 * maxusers`로 설정됩니다.  `maxusers`가 `1`로 설정되면 부팅 "
"시 시스템이 시작되는 `18`개와 Xorg가 사용하는 `15`개를 포함하여 총 `36`개의 "
"동시 프로세스만 있을 수 있습니다.  매뉴얼 페이지를 읽는 것과 같은 간단한 "
"작업도 필터링, 압축 해제 및 보기를 위해 9개의 프로세스가 시작됩니다.  "
"`maxusers`를 `64`로 설정하면 최대 `1044` 개의 프로세스를 동시에 처리할 수 "
"있으므로 거의 모든 용도에 충분합니다.  그러나 다른 프로그램을 시작하려고 할 "
"때 오류가 표시되거나 동시 사용자 수가 많은 서버를 실행 중인 경우 수를 늘린 "
"후 다시 빌드하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1494
msgid ""
"`maxusers` does _not_ limit the number of users which can log into the "
"machine.  It instead sets various table sizes to reasonable values "
"considering the maximum number of users on the system and how many processes "
"each user will be running."
msgstr ""
"`maxusers`는 시스템에 로그인할 수 있는 사용자 수를 제한하지 않습니다.  대신 "
"시스템의 최대 사용자 수와 각 사용자가 실행할 프로세스 수를 고려하여 다양한 "
"테이블 크기를 합리적인 값으로 설정합니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1496
#, no-wrap
msgid "`kern.ipc.soacceptqueue`"
msgstr "`kern.ipc.soacceptqueue`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1503
msgid ""
"The `kern.ipc.soacceptqueue` man:sysctl[8] variable limits the size of the "
"listen queue for accepting new `TCP` connections.  The default value of "
"`128` is typically too low for robust handling of new connections on a "
"heavily loaded web server.  For such environments, it is recommended to "
"increase this value to `1024` or higher.  A service such as man:sendmail[8], "
"or Apache may itself limit the listen queue size, but will often have a "
"directive in its configuration file to adjust the queue size.  Large listen "
"queues do a better job of avoiding Denial of Service (DoS) attacks."
msgstr ""
"`kern.ipc.soacceptqueue` man:sysctl[8] 변수는 새 `TCP` 연결을 수락하기 위한 "
"수신 대기열의 크기를 제한합니다.  기본값인 `128`은 일반적으로 부하가 많은 웹 "
"서버에서 새 연결을 안정적으로 처리하기에는 너무 낮습니다.  이러한 환경에서는 "
"이 값을 `1024` 이상으로 늘리는 것이 좋습니다.  man:sendmail[8]이나 아파치 "
"같은 서비스는 자체적으로 수신 대기열 크기를 제한할 수도 있지만, 구성 파일에 "
"대기열 크기를 조정하는 지시어가 있는 경우가 많습니다.  수신 대기열이 크면 "
"서비스 거부(DoS) 공격을 더 잘 피할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1505
#, no-wrap
msgid "Network Limits"
msgstr "네트워크 제한"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1516
msgid ""
"The `NMBCLUSTERS` kernel configuration option dictates the amount of network "
"Mbufs available to the system.  A heavily-trafficked server with a low "
"number of Mbufs will hinder performance.  Each cluster represents "
"approximately 2 K of memory, so a value of `1024` represents `2` megabytes "
"of kernel memory reserved for network buffers.  A simple calculation can be "
"done to figure out how many are needed.  A web server which maxes out at "
"`1000` simultaneous connections where each connection uses a 6 K receive and "
"16 K send buffer, requires approximately 32 MB worth of network buffers to "
"cover the web server.  A good rule of thumb is to multiply by `2`, so 2x32 "
"MB / 2 KB = 64 MB / 2 kB = `32768`.  Values between `4096` and `32768` are "
"recommended for machines with greater amounts of memory.  Never specify an "
"arbitrarily high value for this parameter as it could lead to a boot time "
"crash.  To observe network cluster usage, use `-m` with man:netstat[1]."
msgstr ""
"커널 구성 옵션인 `NMBCLUSTERS`는 시스템에서 사용할 수 있는 네트워크 Mbuf의 "
"양을 결정합니다.  트래픽이 많은 서버에서 Mbuf 수가 적으면 성능이 "
"저하됩니다.  각 클러스터는 약 2K의 메모리를 나타내므로 `1024` 값은 네트워크 "
"버퍼를 위해 예약된 커널 메모리의 `2` 메가바이트를 나타냅니다.  간단한 계산을 "
"통해 얼마나 많은 메모리가 필요한지 알아낼 수 있습니다.  각 연결이 6K 수신 및 "
"16K 전송 버퍼를 사용하는 동시 연결이 최대 '1000'인 웹 서버의 경우 웹 서버를 "
"처리하려면 약 32MB 상당의 네트워크 버퍼가 필요합니다.  경험상 `2`를 곱하는 "
"것이 좋으므로 2x32MB/2KB = 64MB/2kB = `32768`입니다.  `4096`에서 `32768` "
"사이의 값은 메모리 용량이 더 큰 컴퓨터에 권장됩니다.  이 매개변수에 임의로 "
"높은 값을 지정하면 부팅 시간 충돌이 발생할 수 있으므로 절대로 높은 값을 "
"지정하지 마십시오.  네트워크 클러스터 사용량을 관찰하려면 `-m`을 "
"man:netstat[1]과 함께 사용하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1519
msgid ""
"The `kern.ipc.nmbclusters` loader tunable should be used to tune this at "
"boot time.  Only older versions of FreeBSD will require the use of the "
"`NMBCLUSTERS` kernel man:config[8] option."
msgstr ""
"부팅할 때 `kern.ipc.nmbclusters` 로더 튜너블을 사용하여 이를 조정해야 "
"합니다.  이전 버전의 FreeBSD에서만 `NMBCLUSTERS` 커널 man:config[8] 옵션을 "
"사용해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1524
msgid ""
"For busy servers that make extensive use of the man:sendfile[2] system call, "
"it may be necessary to increase the number of man:sendfile[2] buffers via "
"the `NSFBUFS` kernel configuration option or by setting its value in [."
"filename]#/boot/loader.conf# (see man:loader[8] for details).  A common "
"indicator that this parameter needs to be adjusted is when processes are "
"seen in the `sfbufa` state.  The man:sysctl[8] variable `kern.ipc.nsfbufs` "
"is read-only.  This parameter nominally scales with `kern.maxusers`, however "
"it may be necessary to tune accordingly."
msgstr ""
"man:sendfile[2] 시스템 호출을 광범위하게 사용하는 바쁜 서버의 경우, `NSFBUFS`"
" 커널 구성 옵션을 통해 또는 [.filename]#/boot/loader.conf#에 값을 설정하여 "
"man:sendfile[2] 버퍼 수를 늘려야 할 수 있습니다(자세한 내용은 man:loader[8] "
"참고).  이 매개변수를 조정해야 하는 일반적인 지표는 프로세스가 `sfbufa` "
"상태로 표시되는 경우입니다.  man:sysctl[8] 변수 `kern.ipc.nsfbufs`는 읽기 "
"전용입니다.  이 매개변수는 명목상 `kern.maxusers`에 따라 스케일링되지만 직접 "
"조정해야 할 수도 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1528
msgid ""
"Even though a socket has been marked as non-blocking, calling man:"
"sendfile[2] on the non-blocking socket may result in the man:sendfile[2] "
"call blocking until enough ``struct sf_buf``'s are made available."
msgstr ""
"소켓이 비차단 소켓으로 표시되어 있더라도, 비차단 소켓에서 man:sendfile[2]을 "
"호출하면 충분한 ``struct sf_buf``를 사용할 수 있을 때까지 man:sendfile[2] "
"호출이 차단될 수 있습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1530
#, no-wrap
msgid "`net.inet.ip.portrange.*`"
msgstr "`net.inet.ip.portrange.*`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1542
msgid ""
"The `net.inet.ip.portrange.*` man:sysctl[8] variables control the port "
"number ranges automatically bound to `TCP` and `UDP` sockets.  There are "
"three ranges: a low range, a default range, and a high range.  Most network "
"programs use the default range which is controlled by `net.inet.ip.portrange."
"first` and `net.inet.ip.portrange.last`, which default to `1024` and `5000`, "
"respectively.  Bound port ranges are used for outgoing connections and it is "
"possible to run the system out of ports under certain circumstances.  This "
"most commonly occurs when running a heavily loaded web proxy.  The port "
"range is not an issue when running a server which handles mainly incoming "
"connections, such as a web server, or has a limited number of outgoing "
"connections, such as a mail relay.  For situations where there is a shortage "
"of ports, it is recommended to increase `net.inet.ip.portrange.last` "
"modestly.  A value of `10000`, `20000` or `30000` may be reasonable. "
"Consider firewall effects when changing the port range.  Some firewalls may "
"block large ranges of ports, usually low-numbered ports, and expect systems "
"to use higher ranges of ports for outgoing connections.  For this reason, it "
"is not recommended that the value of `net.inet.ip.portrange.first` be "
"lowered."
msgstr ""
"`net.inet.ip.portrange.*` man:sysctl[8] 변수는 `TCP` 및 `UDP` 소켓에 "
"자동으로 바인딩되는 포트 번호 범위를 제어합니다.  낮은 범위, 기본 범위, 높은 "
"범위의 세 가지 범위가 있습니다.  대부분의 네트워크 프로그램은 `net.inet.ip."
"portrange.first`와 `net.inet.ip.portrange.last`에 의해 제어되는 기본 범위를 "
"사용하며, 기본값은 각각 `1024`와 `5000`입니다.  바운드 포트 범위는 나가는 "
"연결에 사용되며 특정 상황에서는 포트가 부족하여 시스템이 고갈될 수 "
"있습니다.  이는 부하가 많은 웹 프록시를 실행할 때 가장 일반적으로 "
"발생합니다.  웹 서버와 같이 주로 들어오는 연결을 처리하거나 메일 릴레이와 "
"같이 나가는 연결 수가 제한되어 있는 서버를 실행할 때는 포트 범위가 문제가 "
"되지 않습니다.  포트가 부족한 상황에서는 `net.inet.ip.portrange.last`를 "
"적당히 늘리는 것이 좋습니다.  `10000`, `20000` 또는 `30000`의 값이 적당할 수 "
"있습니다. 포트 범위를 변경할 때는 방화벽 효과를 고려하세요.  일부 방화벽은 "
"넓은 범위의 포트(일반적으로 낮은 번호의 포트)를 차단하고 시스템이 나가는 "
"연결에 더 높은 범위의 포트를 사용하도록 기대할 수 있습니다.  따라서 `net.inet"
".ip.portrange.first`의 값을 낮추지 않는 것이 좋습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1543
#, no-wrap
msgid "Virtual Memory"
msgstr "가상 메모리"

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1545
#, no-wrap
msgid "`kern.maxvnodes`"
msgstr "`kern.maxvnodes`"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1552
msgid ""
"A vnode is the internal representation of a file or directory.  Increasing "
"the number of vnodes available to the operating system reduces disk I/O.  "
"Normally, this is handled by the operating system and does not need to be "
"changed.  In some cases where disk I/O is a bottleneck and the system is "
"running out of vnodes, this setting needs to be increased.  The amount of "
"inactive and free RAM will need to be taken into account."
msgstr ""
"vnode는 파일 또는 디렉터리의 내부 표현입니다.  운영 체제에서 사용할 수 있는 "
"vnode 수를 늘리면 디스크 I/O가 줄어듭니다.  일반적으로 이는 운영 체제에서 "
"처리하므로 변경할 필요가 없습니다.  디스크 I/O가 병목 현상이 발생하여 시스템 "
"vnode가 부족한 경우에는 이 설정을 늘려야 하는 경우도 있습니다.  비활성 및 "
"사용 가능한 RAM의 양을 고려해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1554
msgid "To see the current number of vnodes in use:"
msgstr "현재 사용 중인 vnode 수를 확인하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1559
#, no-wrap
msgid ""
"# sysctl vfs.numvnodes\n"
"vfs.numvnodes: 91349\n"
msgstr ""
"# sysctl vfs.numvnodes\n"
"vfs.numvnodes: 91349\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1562
msgid "To see the maximum vnodes:"
msgstr "최대 vnode 수를 확인하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1567
#, no-wrap
msgid ""
"# sysctl kern.maxvnodes\n"
"kern.maxvnodes: 100000\n"
msgstr ""
"# sysctl kern.maxvnodes\n"
"kern.maxvnodes: 100000\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1573
msgid ""
"If the current vnode usage is near the maximum, try increasing `kern."
"maxvnodes` by a value of `1000`.  Keep an eye on the number of `vfs."
"numvnodes`.  If it climbs up to the maximum again, `kern.maxvnodes` will "
"need to be increased further.  Otherwise, a shift in memory usage as "
"reported by man:top[1] should be visible and more memory should be active."
msgstr ""
"현재 vnode 사용량이 최대치에 가까우면 `kern.maxvnodes` 값을 `1000`만큼 "
"늘려보십시오.  `vfs.numvnodes`의 수를 주시합니다.  다시 최대치까지 "
"올라간다면 `kern.maxvnodes`를 더 늘려야 합니다.  그렇지 않으면, man:top[1]에 "
"보고된 메모리 사용량의 변화를 볼 수 있어야 하며 더 많은 메모리가 "
"활성화되어야 합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:1575
#, no-wrap
msgid "Adding Swap Space"
msgstr "스왑 공간 추가하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1579
msgid ""
"Sometimes a system requires more swap space.  This section describes two "
"methods to increase swap space: adding swap to an existing partition or new "
"hard drive, and creating a swap file on an existing partition."
msgstr ""
"시스템에 더 많은 스왑 공간이 필요한 경우가 있습니다.  이 섹션에서는 기존 "
"파티션 또는 새 하드 드라이브에 스왑을 추가하는 방법과 기존 파티션에 스왑 "
"파일을 만드는 두 가지 스왑 공간을 늘리는 방법에 대해 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1581
msgid ""
"For information on how to encrypt swap space, which options exist, and why "
"it should be done, refer to crossref:disks[swap-encrypting,“Encrypting "
"Swap”]."
msgstr ""
"스왑 공간을 암호화하는 방법, 어떤 옵션이 있는지, 왜 암호화해야 하는지에 대한 "
"자세한 내용은 crossref:disks[swap-encrypting,“Encrypting Swap”]를 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1583
#, no-wrap
msgid "Swap on a New Hard Drive or Existing Partition"
msgstr "새 하드 드라이브 또는 기존 파티션에서 스왑"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1587
msgid ""
"Adding a new hard drive for swap gives better performance than using a "
"partition on an existing drive.  Setting up partitions and hard drives is "
"explained in crossref:disks[disks-adding,“Adding Disks”] while crossref:"
"bsdinstall[configtuning-initial,“Designing the Partition Layout”] discusses "
"partition layouts and swap partition size considerations."
msgstr ""
"스왑을 위해 새 하드 드라이브를 추가하면 기존 드라이브의 파티션을 사용하는 "
"것보다 더 나은 성능을 제공합니다.  파티션 및 하드 드라이브 설정은 "
"crossref:disks[disks-adding,“Adding Disks”] 에 설명되어 있으며, "
"crossref:bsdinstall[configtuning-initial,“Designing the Partition Layout”]"
"에서는 파티션 레이아웃과 스왑 파티션 크기 고려 사항에 대해 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1590
msgid "Use `swapon` to add a swap partition to the system.  For example:"
msgstr "`swapon`을 사용하여 시스템에 스왑 파티션을 추가합니다.  예를 들어:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1594
#, no-wrap
msgid "# swapon /dev/ada1s1b\n"
msgstr "# swapon /dev/ada1s1b\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1602
msgid ""
"It is possible to use any partition not currently mounted, even if it "
"already contains data.  Using `swapon` on a partition that contains data "
"will overwrite and destroy that data.  Make sure that the partition to be "
"added as swap is really the intended partition before running `swapon`."
msgstr ""
"현재 마운트되지 않은 파티션은 이미 데이터가 포함되어 있더라도 사용할 수 "
"있습니다.  데이터가 있는 파티션에 `swapon`을 사용하면 해당 데이터를 덮어쓰고 "
"파괴합니다.  `swapon`을 실행하기 전에 스왑으로 추가할 파티션이 실제로 의도한 "
"파티션인지 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1605
msgid ""
"To automatically add this swap partition on boot, add an entry to [."
"filename]#/etc/fstab#:"
msgstr "부팅 시 이 스왑 파티션을 자동으로 추가하려면 [.filename]#/etc/fstab#에 "
"내용을 추가하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1609
#, no-wrap
msgid "/dev/ada1s1b\tnone\tswap\tsw\t0\t0\n"
msgstr "/dev/ada1s1b\tnone\tswap\tsw\t0\t0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1613
msgid ""
"See man:fstab[5] for an explanation of the entries in [.filename]#/etc/"
"fstab#.  More information about `swapon` can be found in man:swapon[8]."
msgstr ""
"[.filename]#/etc/fstab#의 항목에 대한 설명은 man:fstab[5]를 참조하세요.  "
"`swapon`에 대한 자세한 정보는 man:swapon[8]에서 확인할 수 있습니다."

#. type: Block title
#: documentation/content/en/books/handbook/config/_index.adoc:1615
#: documentation/content/en/books/handbook/config/_index.adoc:1623
#, no-wrap
msgid "Creating a Swap File"
msgstr "스왑 파일 생성하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1618
msgid ""
"These examples create a 512M swap file called [.filename]#/usr/swap0# "
"instead of using a partition."
msgstr "이 예제에서는 파티션을 사용하는 대신 [.filename]#/usr/swap0#이라는 512M 스왑 "
"파일을 생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1621
msgid ""
"Using swap files requires that the module needed by man:md[4] has either "
"been built into the kernel or has been loaded before swap is enabled.  See "
"crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel] for "
"information about building a custom kernel."
msgstr ""
"스왑 파일을 사용하려면 man:md[4]에 필요한 모듈이 커널에 빌드되었거나 스왑이 "
"활성화되기 전에 로드되어 있어야 합니다.  커스텀 커널을 빌드하는 방법에 대한 "
"정보는 crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]를 "
"참고하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1628
msgid "Create the swap file:"
msgstr "스왑 파일을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1632
#, no-wrap
msgid "# dd if=/dev/zero of=/usr/swap0 bs=1m count=512\n"
msgstr "# dd if=/dev/zero of=/usr/swap0 bs=1m count=512\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1635
msgid "Set the proper permissions on the new file:"
msgstr "새 파일에 적절한 권한을 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1639
#, no-wrap
msgid "# chmod 0600 /usr/swap0\n"
msgstr "# chmod 0600 /usr/swap0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1642
msgid ""
"Inform the system about the swap file by adding a line to [.filename]#/etc/"
"fstab#:"
msgstr "[.filename]#/etc/fstab#에 한 줄을 추가하여 스왑 파일에 대해 시스템에 "
"알립니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1646
#, no-wrap
msgid "md\tnone\tswap\tsw,file=/usr/swap0,late\t0\t0\n"
msgstr "md\tnone\tswap\tsw,file=/usr/swap0,late\t0\t0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1649
msgid ""
"Swap space will be added on system startup. To add swap space immediately, "
"use man:swapon[8]:"
msgstr "스왑 공간은 시스템 시작 시 추가됩니다. 스왑 공간을 즉시 추가하려면 "
"man:swapon[8]을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1653
#, no-wrap
msgid "# swapon -aL\n"
msgstr "# swapon -aL\n"

#. type: Title ==
#: documentation/content/en/books/handbook/config/_index.adoc:1658
#, no-wrap
msgid "Power and Resource Management"
msgstr "전원 및 리소스 관리"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1668
msgid ""
"It is important to utilize hardware resources in an efficient manner.  Power "
"and resource management allows the operating system to monitor system limits "
"and to possibly provide an alert if the system temperature increases "
"unexpectedly.  An early specification for providing power management was the "
"Advanced Power Management (APM) facility.  APM controls the power usage of a "
"system based on its activity.  However, it was difficult and inflexible for "
"operating systems to manage the power usage and thermal properties of a "
"system.  The hardware was managed by the BIOS and the user had limited "
"configurability and visibility into the power management settings.  The "
"APMBIOS is supplied by the vendor and is specific to the hardware platform.  "
"An APM driver in the operating system mediates access to the APM Software "
"Interface, which allows management of power levels."
msgstr ""
"하드웨어 리소스를 효율적으로 활용하는 것이 중요합니다.  전력 및 리소스 "
"관리를 통해 운영 체제는 시스템 한계를 모니터링하고 시스템 온도가 예기치 않게 "
"상승할 경우 경고를 제공할 수 있습니다.  전력 관리를 제공하기 위한 초기 "
"사양은 고급 전원 관리(APM) 기능이었습니다.  APM은 시스템 활동을 기반으로 "
"시스템의 전력 사용량을 제어합니다.  그러나 운영 체제가 시스템의 전력 "
"사용량과 열 속성을 관리하는 것은 어렵고 유연하지 않았습니다.  하드웨어는 "
"BIOS에 의해 관리되었고 사용자는 전원 관리 설정에 대한 구성 가능성과 가시성이 "
"제한적이었습니다.  APMBIOS는 공급업체에서 제공하며 하드웨어 플랫폼에 따라 "
"다릅니다.  운영 체제의 APM 드라이버는 전력 수준을 관리할 수 있는 APM "
"소프트웨어 인터페이스에 대한 액세스를 중개합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1676
msgid ""
"There are four major problems in APM.  First, power management is done by "
"the vendor-specific BIOS, separate from the operating system.  For example, "
"the user can set idle-time values for a hard drive in the APMBIOS so that, "
"when exceeded, the BIOS spins down the hard drive without the consent of the "
"operating system.  Second, the APM logic is embedded in the BIOS, and it "
"operates outside the scope of the operating system.  This means that users "
"can only fix problems in the APMBIOS by flashing a new one into the ROM, "
"which is a dangerous procedure with the potential to leave the system in an "
"unrecoverable state if it fails.  Third, APM is a vendor-specific "
"technology, meaning that there is a lot of duplication of efforts and bugs "
"found in one vendor's BIOS may not be solved in others.  Lastly, the APMBIOS "
"did not have enough room to implement a sophisticated power policy or one "
"that can adapt well to the purpose of the machine."
msgstr ""
"APM에는 네 가지 주요 문제가 있습니다.  첫째, 전원 관리가 운영 체제와 별도로 "
"공급업체별 BIOS에 의해 수행됩니다.  예를 들어, 사용자는 하드 드라이브의 유휴 "
"시간 값을 APMBIOS에서 설정하여 초과 시 운영 체제의 동의 없이 BIOS가 하드 "
"드라이브를 턴다운하도록 할 수 있습니다.  둘째, APM 로직은 BIOS에 내장되어 "
"있으며 운영 체제의 범위 밖에서 작동합니다.  즉, 사용자는 ROM에 새 펌웨어를 "
"플래시해야만 APMBIOS의 문제를 해결할 수 있으며, 이는 실패 시 시스템을 복구할 "
"수 없는 상태로 만들 수 있는 위험한 절차입니다.  셋째, APM은 공급업체별 "
"기술이기 때문에 중복되는 작업이 많고 한 공급업체의 BIOS에서 발견된 버그가 "
"다른 공급업체에서는 해결되지 않을 수 있습니다.  마지막으로, APMBIOS는 정교한 "
"전원 정책이나 기계의 목적에 맞게 잘 조정할 수 있는 정책을 구현할 여지가 "
"충분하지 않았습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1681
msgid ""
"The Plug and Play BIOS (PNPBIOS) was unreliable in many situations.  PNPBIOS "
"is 16-bit technology, so the operating system has to use 16-bit emulation in "
"order to interface with PNPBIOS methods.  FreeBSD provides an APM driver as "
"APM should still be used for systems manufactured at or before the year "
"2000.  The driver is documented in man:apm[4]."
msgstr ""
"Plug and Play BIOS(PNPBIOS)는 많은 상황에서 불안정했습니다.  PNPBIOS는 "
"16비트 기술이기 때문에 운영 체제가 16비트 에뮬레이션을 사용해야 PNPBIOS "
"방식과 인터페이스할 수 있습니다.  2000년 이전에 제조된 시스템에서는 여전히 "
"APM을 사용해야 하므로 FreeBSD는 APM 드라이버를 제공합니다.  드라이버는 "
"man:apm[4]에 문서화되어 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1685
msgid ""
"The successor to APM is the Advanced Configuration and Power Interface "
"(ACPI).  ACPI is a standard written by an alliance of vendors to provide an "
"interface for hardware resources and power management.  It is a key element "
"in _Operating System-directed configuration and Power Management_ as it "
"provides more control and flexibility to the operating system."
msgstr ""
"APM의 후속 버전은 고급 구성 및 전원 인터페이스(ACPI)입니다.  ACPI는 하드웨어 "
"리소스 및 전원 관리를 위한 인터페이스를 제공하기 위해 공급업체 연합에서 "
"작성한 표준입니다.  운영 체제에 더 많은 제어와 유연성을 제공하기 때문에 "
"_운영 체제 중심 구성 및 전원 관리_의 핵심 요소입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1688
msgid ""
"This chapter demonstrates how to configure ACPI on FreeBSD.  It then offers "
"some tips on how to debug ACPI and how to submit a problem report containing "
"debugging information so that developers can diagnosis and fix ACPI issues."
msgstr ""
"이 장에서는 FreeBSD에서 ACPI를 구성하는 방법을 설명합니다.  그런 다음 "
"개발자가 ACPI 문제를 진단하고 수정할 수 있도록 ACPI를 디버깅하는 방법과 "
"디버깅 정보가 포함된 문제 보고서를 제출하는 방법에 대한 몇 가지 팁을 "
"제공합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1690
#, no-wrap
msgid "Configuring ACPI"
msgstr "ACPI 구성하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1695
msgid ""
"In FreeBSD the man:acpi[4] driver is loaded by default at system boot and "
"should _not_ be compiled into the kernel.  This driver cannot be unloaded "
"after boot because the system bus uses it for various hardware "
"interactions.  However, if the system is experiencing problems, ACPI can be "
"disabled altogether by rebooting after setting `hint.acpi.0.disabled=\"1\"` "
"in [.filename]#/boot/loader.conf# or by setting this variable at the loader "
"prompt, as described in crossref:boot[boot-loader,“Stage Three”]."
msgstr ""
"FreeBSD에서는 시스템 부팅 시 man:acpi[4] 드라이버가 기본적으로 로드되며 "
"커널에 컴파일해서는 안됩니다.  이 드라이버는 시스템 버스가 다양한 하드웨어 "
"상호 작용에 사용하기 때문에 부팅 후 언로드할 수 없습니다.  그러나 시스템에 "
"문제가 있는 경우 [.filename]#/boot/loader.conf#에서 `hint.acpi.0.disabled=\"1"
"\"`을 설정한 후 재부팅하거나 crossref:boot[boot-loader,“Stage Three”]에 "
"설명된 대로 로더 프롬프트에서 이 변수를 설정하여 ACPI를 완전히 비활성화할 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1700
msgid ""
"ACPI and APM cannot coexist and should be used separately.  The last one to "
"load will terminate if the driver notices the other is running."
msgstr ""
"ACPI와 APM은 공존할 수 없으며 별도로 사용해야 합니다.  드라이버가 다른 "
"드라이버가 실행 중인 것을 감지하면 마지막으로 로드한 드라이버가 종료됩니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1705
msgid ""
"ACPI can be used to put the system into a sleep mode with `acpiconf`, the `-"
"s` flag, and a number from `1` to `5`.  Most users only need `1` (quick "
"suspend to RAM) or `3` (suspend to RAM).  Option `5` performs a soft-off "
"which is the same as running `halt -p`."
msgstr ""
"ACPI는 `acpiconf`, `-s` 플래그 및 `1`에서 `5` 사이의 숫자를 사용하여 "
"시스템을 절전 모드로 전환하는 데 사용할 수 있습니다.  대부분의 사용자는 `1`("
"RAM으로 빠른 일시 중단) 또는 `3`(RAM으로 일시 중단)만 필요합니다.  옵션 `5`"
"는 `halt -p`를 실행하는 것과 동일한 소프트 오프를 수행합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1710
msgid ""
"The man:acpi_video[4] driver uses link:https://uefi.org/specs/ACPI/6.4/"
"Apx_B_Video_Extensions/Apx_B_Video_Extensions.html[ACPI Video Extensions] to "
"control display switching and backlight brightness.  It must be loaded after "
"any of the DRM kernel modules.  After loading the driver, the kbd:[Fn] "
"brightness keys will change the brightness of the screen.  It is possible to "
"check the ACPI events by inspecting [.filename]#/var/run/devd.pipe#:"
msgstr ""
"man:acpi_video[4] 드라이버는 link:https://uefi.org/specs/ACPI/6.4/"
"Apx_B_Video_Extensions/Apx_B_Video_Extensions.html[ACPI 비디오 확장]을 "
"사용하여 디스플레이 전환 및 백라이트 밝기를 제어합니다.  이 드라이버는 DRM "
"커널 모듈 다음에 로드해야 합니다.  드라이버를 로드한 후 kbd:[Fn] 밝기 키로 "
"화면 밝기를 변경할 수 있습니다.  ACPI 이벤트는 [.filename]#/var/run/devd."
"pipe#를 검사하여 확인할 수 있습니다:"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1718
msgid ""
"...  # cat /var/run/devd.pipe !system=ACPI subsystem=Video type=brightness "
"notify=62 !system=ACPI subsystem=Video type=brightness notify=63 !"
"system=ACPI subsystem=Video type=brightness notify=64 ..."
msgstr ""
"...  # cat /var/run/devd.pipe !system=ACPI subsystem=Video type=brightness "
"notify=62 !system=ACPI subsystem=Video type=brightness notify=63 "
"!system=ACPI subsystem=Video type=brightness notify=64 ..."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1721
msgid ""
"Other options are available using `sysctl`.  Refer to man:acpi[4] and man:"
"acpiconf[8] for more information."
msgstr ""
"다른 옵션은 `sysctl`을 사용하여 사용할 수 있습니다.  자세한 내용은 "
"man:acpi[4] 및 man:acpiconf[8]을 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1723
#, no-wrap
msgid "Common Problems"
msgstr "일반적인 문제"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1730
msgid ""
"ACPI is present in all modern computers that conform to the ia32 (x86) and "
"amd64 (AMD) architectures.  The full standard has many features including "
"CPU performance management, power planes control, thermal zones, various "
"battery systems, embedded controllers, and bus enumeration.  Most systems "
"implement less than the full standard.  For instance, a desktop system "
"usually only implements bus enumeration while a laptop might have cooling "
"and battery management support as well.  Laptops also have suspend and "
"resume, with their own associated complexity."
msgstr ""
"ACPI는 ia32(x86) 및 amd64(AMD) 아키텍처를 준수하는 모든 최신 컴퓨터에 "
"존재합니다.  전체 표준에는 CPU 성능 관리, 전원면 제어, 열 영역, 다양한 "
"배터리 시스템, 임베디드 컨트롤러, 버스 열거 등 많은 기능이 포함되어 "
"있습니다.  대부분의 시스템은 전체 표준보다 적은 기능을 구현합니다.  예를 "
"들어 데스크톱 시스템은 일반적으로 버스 열거만 구현하는 반면 노트북은 냉각 및 "
"배터리 관리도 지원할 수 있습니다.  또한 노트북에는 일시 중단 및 재개 기능이 "
"있으며, 이와 관련된 복잡한 설정도 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1734
msgid ""
"An ACPI-compliant system has various components.  The BIOS and chipset "
"vendors provide various fixed tables, such as FADT, in memory that specify "
"things like the APIC map (used for SMP), config registers, and simple "
"configuration values.  Additionally, a bytecode table, the Differentiated "
"System Description Table DSDT, specifies a tree-like name space of devices "
"and methods."
msgstr ""
"ACPI 호환 시스템에는 다양한 구성 요소가 있습니다.  BIOS 및 칩셋 공급업체는 "
"APIC 맵(SMP에 사용됨), 구성 레지스터, 간단한 구성 값 등을 지정하는 FADT와 "
"같은 다양한 고정 테이블을 메모리에 제공합니다.  또한 바이트코드 테이블인 "
"차별화 시스템 설명 테이블 (Differentiated System Description Table, DSDT는 "
"장치 및 메서드의 트리와 같은 이름 공간을 지정합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1740
msgid ""
"The ACPI driver must parse the fixed tables, implement an interpreter for "
"the bytecode, and modify device drivers and the kernel to accept information "
"from the ACPI subsystem.  For FreeBSD, Intel(R) has provided an interpreter "
"(ACPI-CA) that is shared with Linux(R) and NetBSD.  The path to the ACPI-CA "
"source code is [.filename]#src/sys/contrib/dev/acpica#.  The glue code that "
"allows ACPI-CA to work on FreeBSD is in [.filename]#src/sys/dev/acpica/"
"Osd#.  Finally, drivers that implement various ACPI devices are found in [."
"filename]#src/sys/dev/acpica#."
msgstr ""
"ACPI 드라이버는 고정 테이블을 구문 분석하고, 바이트코드에 대한 인터프리터를 "
"구현하고, 장치 드라이버와 커널을 수정하여 ACPI 서브시스템의 정보를 "
"받아들여야 합니다.  FreeBSD의 경우, 인텔(R)은 Linux(R) 및 NetBSD와 공유되는 "
"인터프리터(ACPI-CA)를 제공했습니다.  ACPI-CA 소스 코드의 경로는 [.filename]#"
"src/sys/contrib/dev/acpica#입니다.  ACPI-CA가 FreeBSD에서 작동할 수 있도록 "
"하는 글루 코드는 [.filename]#src/sys/dev/acpica/Osd#에 있습니다.  "
"마지막으로, 다양한 ACPI 장치를 구현하는 드라이버는 [.filename]#src/sys/dev/"
"acpica#에서 찾을 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1744
msgid ""
"For ACPI to work correctly, all the parts have to work correctly.  Here are "
"some common problems, in order of frequency of appearance, and some possible "
"workarounds or fixes.  If a fix does not resolve the issue, refer to <<ACPI-"
"submitdebug>> for instructions on how to submit a bug report."
msgstr ""
"ACPI가 올바르게 작동하려면 모든 부품이 올바르게 작동해야 합니다.  다음은 "
"자주 발생하는 몇 가지 일반적인 문제와 가능한 해결 방법 또는 수정 사항을 빈도 "
"순으로 나열한 것입니다.  수정해도 문제가 해결되지 않으면 <<ACPI-"
"submitdebug>>에서 버그 리포트를 제출하는 방법에 대한 지침을 참조하세요."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1745
#, no-wrap
msgid "Mouse Issues"
msgstr "마우스 문제"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1749
msgid ""
"In some cases, resuming from a suspend operation will cause the mouse to "
"fail.  A known work around is to add `hint.psm.0.flags=\"0x3000\"` to [."
"filename]#/boot/loader.conf#."
msgstr ""
"경우에 따라 일시 중단된 작업에서 다시 시작하면 마우스가 실패할 수 있습니다.  "
"알려진 해결 방법은 `hint.psm.0.flags=\"0x3000\"`을 [.filename]#/boot/loader."
"conf#에 추가하는 것입니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1750
#, no-wrap
msgid "Suspend/Resume"
msgstr "일시 중단/재개"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1756
msgid ""
"ACPI has three suspend to RAM (STR) states, `S1`-`S3`, and one suspend to "
"disk state (STD), called `S4`.  STD can be implemented in two separate "
"ways.  The ``S4``BIOS is a BIOS-assisted suspend to disk and ``S4``OS is "
"implemented entirely by the operating system.  The normal state the system "
"is in when plugged in but not powered up is \"soft off\" (`S5`)."
msgstr ""
"ACPI에는 `S1`-`S3`의 세 가지 RAM 일시 중단(STR) 상태와 `S4`라는 하나의 "
"디스크 일시 중단(STD) 상태가 있습니다.  STD는 두 가지 방법으로 구현할 수 "
"있습니다.  ``S4`` BIOS는 BIOS가 지원하는 디스크 일시 중단이고 ``S4`` OS는 "
"운영 체제에서 전적으로 구현합니다.  전원이 연결되었지만 전원이 켜지지 않은 "
"상태의 정상적인 시스템은 \"소프트 오프\"(``S5``) 상태입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1759
msgid ""
"Use `sysctl hw.acpi` to check for the suspend-related items.  These example "
"results are from a Thinkpad:"
msgstr "`sysctl hw.acpi`를 사용하여 일시 중단 관련 항목을 확인합니다.  이 예제 "
"결과는 Thinkpad의 결과입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1764
#, no-wrap
msgid ""
"hw.acpi.supported_sleep_state: S3 S4 S5\n"
"hw.acpi.s4bios: 0\n"
msgstr ""
"hw.acpi.supported_sleep_state: S3 S4 S5\n"
"hw.acpi.s4bios: 0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1768
msgid ""
"Use `acpiconf -s` to test `S3`, `S4`, and `S5`.  An `s4bios` of one (`1`) "
"indicates ``S4``BIOS support instead of `S4` operating system support."
msgstr ""
"`acpiconf -s`를 사용하여 `S3`, `S4` 및 `S5`를 테스트합니다.  `s4bios`가 "
"1(`1`)이면 `S4` 운영 체제 지원 대신 `S4` BIOS를 지원함을 나타냅니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1774
msgid ""
"When testing suspend/resume, start with `S1`, if supported.  This state is "
"most likely to work since it does not require much driver support.  No one "
"has implemented `S2`, which is similar to `S1`.  Next, try `S3`.  This is "
"the deepest STR state and requires a lot of driver support to properly "
"reinitialize the hardware."
msgstr ""
"일시 중단/재개를 테스트할 때, 지원되는 경우 `S1`으로 시작합니다.  이 상태는 "
"많은 드라이버 지원이 필요하지 않으므로 작동할 가능성이 가장 높습니다.  `S1`"
"과 유사한 `S2`를 구현한 곳은 없습니다.  다음으로 `S3`을 시도해 보세요.  "
"이것은 가장 깊은 STR 상태이며 하드웨어를 올바르게 다시 초기화하기 위해 많은 "
"드라이버 지원이 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1777
msgid ""
"A common problem with suspend/resume is that many device drivers do not "
"save, restore, or reinitialize their firmware, registers, or device memory "
"properly.  As a first attempt at debugging the problem, try:"
msgstr ""
"일시 중단/재개와 관련된 일반적인 문제는 많은 장치 드라이버가 펌웨어, "
"레지스터 또는 장치 메모리를 제대로 저장, 복원 또는 다시 초기화하지 못한다는 "
"점입니다.  문제를 디버깅하기 위한 첫 번째 시도로 다음을 시도해 보세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1783
#, no-wrap
msgid ""
"# sysctl debug.bootverbose=1\n"
"# sysctl debug.acpi.suspend_bounce=1\n"
"# acpiconf -s 3\n"
msgstr ""
"# sysctl debug.bootverbose=1\n"
"# sysctl debug.acpi.suspend_bounce=1\n"
"# acpiconf -s 3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1788
msgid ""
"This test emulates the suspend/resume cycle of all device drivers without "
"actually going into `S3` state.  In some cases, problems such as losing "
"firmware state, device watchdog time out, and retrying forever, can be "
"captured with this method.  Note that the system will not really enter `S3` "
"state, which means devices may not lose power, and many will work fine even "
"if suspend/resume methods are totally missing, unlike real `S3` state."
msgstr ""
"이 테스트는 실제로 `S3` 상태가 되지 않고 모든 디바이스 드라이버의 일시 중단/"
"재개 주기를 에뮬레이션합니다.  경우에 따라 펌웨어 상태 손실, 장치 감시 시간 "
"초과, 영원히 재시도하는 등의 문제를 이 방법으로 캡처할 수 있습니다.  "
"시스템이 실제로 `S3`상태가 되지 않으므로 기기의 전원이 손실되지 않을 수 "
"있으며, 실제 `S3`상태와 달리 일시 중단/재시작 방법이 완전히 누락되더라도 "
"많은 기기가 정상적으로 작동한다는 점에 유의하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1790
msgid ""
"If the previous test worked, on a laptop it is possible to configure the "
"system to suspend into `S3` on lid close and resume when it is open back "
"again:"
msgstr ""
"이전 테스트가 작동했다면 노트북에서 뚜껑을 닫을 때 시스템이 `S3'로 일시 "
"중단되었다가 열면 다시 시작되도록 구성할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1794
#, no-wrap
msgid "# sysctl hw.acpi.lid_switch_state=S3\n"
msgstr "# sysctl hw.acpi.lid_switch_state=S3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1797
msgid "This change can be made persistent across reboots:"
msgstr "이 변경 사항은 재부팅 시에도 영구적으로 적용될 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1801
#, no-wrap
msgid "# echo 'hw.acpi.lid_switch_state=S3' >> /etc/sysctl.conf\n"
msgstr "# echo 'hw.acpi.lid_switch_state=S3' >> /etc/sysctl.conf\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1804
msgid ""
"Harder cases require additional hardware, such as a serial port and cable "
"for debugging through a serial console, a Firewire port and cable for using "
"man:dcons[4], and kernel debugging skills."
msgstr ""
"더 어려운 경우에는 직렬 콘솔을 통한 디버깅하기 위해 직렬 포트 및 케이블, "
"man:dcons[4] 실행을 위한 Firewire 포트 및 케이블, 커널 디버깅 기술 등의 추가 "
"하드웨어가 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1811
msgid ""
"To help isolate the problem, unload as many drivers as possible.  If it "
"works, narrow down which driver is the problem by loading drivers until it "
"fails again.  Typically, binary drivers like [.filename]#nvidia.ko#, display "
"drivers, and USB will have the most problems while Ethernet interfaces "
"usually work fine.  If drivers can be properly loaded and unloaded, automate "
"this by putting the appropriate commands in [.filename]#/etc/rc.suspend# and "
"[.filename]#/etc/rc.resume#.  Try setting `hw.acpi.reset_video` to `1` if "
"the display is messed up after resume.  Try setting longer or shorter values "
"for `hw.acpi.sleep_delay` to see if that helps."
msgstr ""
"문제를 분리하는 데 도움이 되도록 최대한 많은 드라이버를 언로드하세요.  "
"작동하면 다시 실패할 때까지 드라이버를 로드하여 어떤 드라이버가 문제인지 "
"좁혀보세요.  일반적으로 [.filename]#nvidia.ko#와 같은 바이너리 드라이버, "
"디스플레이 드라이버, USB에 가장 많은 문제가 발생하지만 이더넷 인터페이스는 "
"보통 정상 작동합니다.  드라이버를 제대로 로드 및 언로드할 수 있는 경우 [."
"filename]#/etc/rc.suspend# 및 [.filename]#/etc/rc.resume#에 적절한 명령을 "
"넣어 이 작업을 자동화하세요.  다시 시작한 후 디스플레이가 엉망인 경우 `hw."
"acpi.reset_video`를 `1`로 설정해 보세요.  `hw.acpi.sleep_delay`의 값을 더 "
"길게 또는 더 짧게 설정하여 도움이 되는지 확인하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1817
msgid ""
"Try loading a recent Linux(R) distribution to see if suspend/resume works on "
"the same hardware.  If it works on Linux(R), it is likely a FreeBSD driver "
"problem.  Narrowing down which driver causes the problem will assist "
"developers in fixing the problem.  Since the ACPI maintainers rarely "
"maintain other drivers, such as sound or ATA, any driver problems should "
"also be posted to the {freebsd-current} and mailed to the driver "
"maintainer.  Advanced users can include debugging man:printf[3]s in a "
"problematic driver to track down where in its resume function it hangs."
msgstr ""
"최신 Linux(R) 배포판을 로드하여 동일한 하드웨어에서 일시 중단/다시 시작이 "
"작동하는지 확인하세요.  Linux(R)에서 작동한다면 FreeBSD 드라이버 문제일 "
"가능성이 높습니다.  문제를 일으키는 드라이버를 좁히면 개발자가 문제를 "
"해결하는 데 도움이 됩니다.  ACPI 유지 관리자는 사운드나 ATA와 같은 다른 "
"드라이버는 거의 관리하지 않으므로, 드라이버 문제는 {freebsd-current}에 "
"게시하고 드라이버 유지 관리자에게 메일을 보내야 합니다.  고급 사용자는 "
"문제가 있는 드라이버에서 man:printf[3]를 디버깅하여 재개 기능의 어느 "
"부분에서 중단되는지 추적할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1821
msgid ""
"Finally, try disabling ACPI and enabling APM instead.  If suspend/resume "
"works with APM, stick with APM, especially on older hardware (pre-2000).  It "
"took vendors a while to get ACPI support correct and older hardware is more "
"likely to have BIOS problems with ACPI."
msgstr ""
"마지막으로 ACPI를 비활성화하고 대신 APM을 활성화해 보세요.  일시 중단/재개가 "
"APM과 함께 작동하는 경우, 특히 구형 하드웨어(2000년 이전)에서는 APM을 계속 "
"사용하세요.  공급업체가 ACPI를 올바르게 지원하는 데 시간이 걸렸고 구형 "
"하드웨어는 ACPI와 관련된 BIOS 문제가 있을 가능성이 더 높습니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1822
#, no-wrap
msgid "System Hangs"
msgstr "시스템 멈춤"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1826
msgid ""
"Most system hangs are a result of lost interrupts or an interrupt storm.  "
"Chipsets may have problems based on boot, how the BIOS configures interrupts "
"before correctness of the APIC (MADT) table, and routing of the System "
"Control Interrupt (SCI)."
msgstr ""
"대부분의 시스템 중단은 인터럽트 손실 또는 인터럽트 폭풍으로 인해 "
"발생합니다.  칩셋은 부팅, BIOS에서 인터럽트를 구성하는 방법, APIC(MADT) "
"테이블의 정확성, 시스템 제어 인터럽트(SCI)의 라우팅에 따라 문제가 발생할 수 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1830
msgid ""
"Interrupt storms can be distinguished from lost interrupts by checking the "
"output of `vmstat -i` and looking at the line that has `acpi0`.  If the "
"counter is increasing at more than a couple per second, there is an "
"interrupt storm.  If the system appears hung, try breaking to DDB (kbd:[CTRL"
"+ALT+ESC] on console) and type `show interrupts`."
msgstr ""
"인터럽트 폭풍은 `vmstat -i`의 출력을 확인하고 `acpi0`이 있는 줄을 확인하여 "
"손실된 인터럽트와 구별할 수 있습니다.  카운터가 초당 두 개 이상 증가하면 "
"인터럽트 폭풍이 발생한 것입니다.  시스템이 중단된 것처럼 보이면 DDB(콘솔에서 "
"kbd:[CTRL+ALT+ESC])로 이동하여 `show interrupts`를 입력해 보세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1832
msgid ""
"When dealing with interrupt problems, try disabling APIC support with `hint."
"apic.0.disabled=\"1\"` in [.filename]#/boot/loader.conf#."
msgstr ""
"인터럽트 문제를 해결할 때는 [.filename]#/boot/loader.conf#에서 `hint.apic.0."
"disabled=\"1\"`을 사용하여 APIC 지원을 비활성화해 보세요."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1833
#, no-wrap
msgid "Panics"
msgstr "패닉"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1840
msgid ""
"Panics are relatively rare for ACPI and are the top priority to be fixed.  "
"The first step is to isolate the steps to reproduce the panic, if possible, "
"and get a backtrace.  Follow the advice for enabling `options DDB` and "
"setting up a serial console in crossref:serialcomms[serialconsole-"
"ddb,“Entering the DDB Debugger from the Serial Line”] or setting up a dump "
"partition.  To get a backtrace in DDB, use `tr`.  When handwriting the "
"backtrace, get at least the last five and the top five lines in the trace."
msgstr ""
"패닉은 ACPI에서 비교적 드물게 발생하나 최우선적으로 해결해야 할 문제입니다.  "
"첫 번째 단계는 가능한 경우 패닉을 재현하는 단계를 분리하고 백트레이스를 "
"확보하는 것입니다.  crossref:serialcomms[serialconsole-ddb,“Entering the DDB "
"Debugger from the Serial Line”] 또는 덤프 파티션 설정에서 `options DDB`를 "
"활성화하고 시리얼 콘솔을 설정하는 방법에 대한 조언을 따르세요.  DDB에서 "
"백트레이스를 얻으려면 `tr`을 사용합니다.  백트레이스를 손으로 기록할 때는 "
"최소한 추적의 마지막 다섯 줄과 상위 다섯 줄을 가져와야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1844
msgid ""
"Then, try to isolate the problem by booting with ACPI disabled.  If that "
"works, isolate the ACPI subsystem by using various values of `debug.acpi."
"disable`.  See man:acpi[4] for some examples."
msgstr ""
"그런 다음 ACPI를 비활성화한 상태로 부팅하여 문제를 격리해 보세요.  문제가 "
"해결되면 `debug.acpi.disable`의 다양한 값을 사용하여 ACPI 하위 시스템을 "
"격리합니다.  몇 가지 예는 man:acpi[4]를 참조하세요."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1845
#, no-wrap
msgid "System Powers Up After Suspend or Shutdown"
msgstr "일시 중단 또는 종료 후 시스템 전원 켜짐"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1851
msgid ""
"First, try setting `hw.acpi.disable_on_poweroff=\"0\"` in [.filename]#/boot/"
"loader.conf#.  This keeps ACPI from disabling various events during the "
"shutdown process.  Some systems need this value set to `1` (the default) for "
"the same reason.  This usually fixes the problem of a system powering up "
"spontaneously after a suspend or poweroff."
msgstr ""
"먼저, [.filename]#/boot/loader.conf#에서 `hw.acpi.disable_on_poweroff=\"0\"`"
"을 설정해 보세요.  이렇게 하면 종료 프로세스 중에 ACPI가 다양한 이벤트를 "
"비활성화하지 않습니다.  일부 시스템에서는 같은 이유로 이 값을 `1`(기본값)로 "
"설정해야 합니다.  이렇게 하면 일반적으로 일시 중단 또는 전원 끄기 후 "
"시스템이 저절로 전원이 켜지는 문제가 해결됩니다."

#. type: Title ====
#: documentation/content/en/books/handbook/config/_index.adoc:1853
#, no-wrap
msgid "BIOS Contains Buggy Bytecode"
msgstr "버기 바이트코드가 포함된 BIOS"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1857
msgid ""
"Some BIOS vendors provide incorrect or buggy bytecode.  This is usually "
"manifested by kernel console messages like this:"
msgstr ""
"일부 BIOS 공급업체는 부정확하거나 버그가 있는 바이트코드를 제공합니다.  이는 "
"일반적으로 다음과 같은 커널 콘솔 메시지로 나타납니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1862
#, no-wrap
msgid ""
"ACPI-1287: *** Error: Method execution failed [\\\\_SB_.PCI0.LPC0.FIGD._STA] \\\\\n"
"(Node 0xc3f6d160), AE_NOT_FOUND\n"
msgstr ""
"ACPI-1287: *** Error: Method execution failed [\\\\_SB_.PCI0.LPC0.FIGD._STA] "
"\\\\\n"
"(Node 0xc3f6d160), AE_NOT_FOUND\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1866
msgid ""
"Often, these problems may be resolved by updating the BIOS to the latest "
"revision.  Most console messages are harmless, but if there are other "
"problems, like the battery status is not working, these messages are a good "
"place to start looking for problems."
msgstr ""
"대개 이러한 문제는 BIOS를 최신 버전으로 업데이트하면 해결될 수 있습니다.  "
"대부분의 콘솔 메시지는 무해하지만 배터리 상태가 작동하지 않는 등의 다른 "
"문제가 있는 경우 이러한 메시지를 통해 문제를 찾아보는 것이 좋습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1867
#, no-wrap
msgid "Overriding the Default AML"
msgstr "기본 AML 재정의하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1871
msgid ""
"The BIOS bytecode, known as ACPI Machine Language (AML), is compiled from a "
"source language called ACPI Source Language (ASL).  The AML is found in the "
"table known as the Differentiated System Description Table (DSDT)."
msgstr ""
"ACPI 기계어(AML)로 알려진 BIOS 바이트 코드는 ACPI 소스 언어(ASL)라는 소스 "
"언어에서 컴파일됩니다.  AML은 차별화 시스템 설명 테이블(Differentiated "
"System Description Table, DSDT)이라는 테이블에서 찾을 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1876
msgid ""
"The goal of FreeBSD is for everyone to have working ACPI without any user "
"intervention.  Workarounds are still being developed for common mistakes "
"made by BIOS vendors.  The Microsoft(R) interpreter ([.filename]#acpi.sys# "
"and [.filename]#acpiec.sys#) does not strictly check for adherence to the "
"standard, and thus many BIOS vendors who only test ACPI under Windows(R) "
"never fix their ASL.  FreeBSD developers continue to identify and document "
"which non-standard behavior is allowed by Microsoft(R)'s interpreter and "
"replicate it so that FreeBSD can work without forcing users to fix the ASL."
msgstr ""
"FreeBSD의 목표는 모든 사람이 사용자 개입 없이 작동하는 ACPI를 사용하는 "
"것입니다.  BIOS 공급업체가 흔히 저지르는 실수에 대한 해결 방법은 여전히 개발 "
"중입니다.  Microsoft(R) 인터프리터([.filename]#acpi.sys# 및 [."
"filename]#acpiec.sys#)는 표준 준수 여부를 엄격하게 검사하지 않기 때문에, "
"Windows(R)에서만 ACPI를 테스트하는 많은 BIOS 벤더들은 그들의 ASL을 수정하지 "
"않습니다.  FreeBSD 개발자들은 Microsoft(R)의 인터프리터가 허용하는 비표준 "
"동작을 지속적으로 식별하고 문서화하여 사용자가 ASL을 수정하지 않고도 "
"FreeBSD가 작동할 수 있도록 복제하고 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1879
msgid ""
"To help identify buggy behavior and possibly fix it manually, a copy can be "
"made of the system's ASL.  To copy the system's ASL to a specified file "
"name, use `acpidump` with `-t`, to show the contents of the fixed tables, "
"and `-d`, to disassemble the AML:"
msgstr ""
"버그가 있는 동작을 식별하고 수동으로 수정하는 데 도움이 되도록 시스템의 "
"ASL을 복사할 수 있습니다.  시스템의 ASL을 지정된 파일 이름으로 복사하려면 "
"`acpidump`에 고정 테이블의 내용을 표시하는 `-t`와 AML을 분해하는 `-d`를 함께 "
"사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1883
#, no-wrap
msgid "# acpidump -td > my.asl\n"
msgstr "# acpidump -td > my.asl\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1887
msgid ""
"Some AML versions assume the user is running Windows(R).  To override this, "
"set `hw.acpi.osname=_\"Windows 2009\"_` in [.filename]#/boot/loader.conf#, "
"using the most recent Windows(R) version listed in the ASL."
msgstr ""
"일부 AML 버전은 사용자가 Windows(R)를 실행하고 있다고 가정합니다.  이를 "
"재정의하려면 ASL에 나열된 가장 최신 Windows(R) 버전을 사용하여 [.filename]#/"
"boot/loader.conf#에 `hw.acpi.osname=_\"Windows 2009\"_`를 설정하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1891
msgid ""
"Other workarounds may require [.filename]#my.asl# to be customized.  If this "
"file is edited, compile the new ASL using the following command.  Warnings "
"can usually be ignored, but errors are bugs that will usually prevent ACPI "
"from working correctly."
msgstr ""
"다른 해결 방법을 사용하려면 [.filename]#my.asl#을 사용자 지정해야 할 수도 "
"있습니다.  이 파일을 편집한 경우 다음 명령을 사용하여 새 ASL을 "
"컴파일합니다.  경고는 일반적으로 무시할 수 있지만 오류는 일반적으로 ACPI가 "
"올바르게 작동하지 못하게 하는 버그입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1895
#, no-wrap
msgid "# iasl -f my.asl\n"
msgstr "# iasl -f my.asl\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1899
msgid ""
"Including `-f` forces creation of the AML, even if there are errors during "
"compilation.  Some errors, such as missing return statements, are "
"automatically worked around by the FreeBSD interpreter."
msgstr ""
"`-f`를 포함하면 컴파일 중에 오류가 있더라도 AML을 강제로 생성합니다.  누락된 "
"반환문과 같은 일부 오류는 FreeBSD 인터프리터가 자동으로 해결합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1902
msgid ""
"The default output filename for `iasl` is [.filename]#DSDT.aml#.  Load this "
"file instead of the BIOS's buggy copy, which is still present in flash "
"memory, by editing [.filename]#/boot/loader.conf# as follows:"
msgstr ""
"`iasl`의 기본 출력 파일 이름은 [.filename]#DSDT.aml#입니다.  플래시 메모리에 "
"여전히 존재하는 BIOS의 버그 복사본 대신 이 파일을 로드하려면 [.filename]#/"
"boot/loader.conf#를 다음과 같이 편집합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1907
#, no-wrap
msgid ""
"acpi_dsdt_load=\"YES\"\n"
"acpi_dsdt_name=\"/boot/DSDT.aml\"\n"
msgstr ""
"acpi_dsdt_load=\"YES\"\n"
"acpi_dsdt_name=\"/boot/DSDT.aml\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1911
msgid ""
"Be sure to copy [.filename]#DSDT.aml# to [.filename]#/boot#, then reboot the "
"system.  If this fixes the problem, send a man:diff[1] of the old and new "
"ASL to {freebsd-acpi} so that developers can work around the buggy behavior "
"in [.filename]#acpica#."
msgstr ""
"[.filename]#DSDT.aml#을 [.filename]#/boot#에 복사한 다음 시스템을 "
"재부팅하세요.  이렇게 해서 문제가 해결되면 개발자가 [.filename]#acpica#에서 "
"버그가 있는 동작을 해결할 수 있도록 이전 및 새 ASL의 man:diff[1]을 {freebsd-"
"acpi}로 보내세요."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1913
#, no-wrap
msgid "Getting and Submitting Debugging Info"
msgstr "디버깅 정보 얻기 및 제출하기"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1921
msgid ""
"The ACPI driver has a flexible debugging facility. A set of subsystems and "
"the level of verbosity can be specified.  The subsystems to debug are "
"specified as layers and are broken down into components "
"(`ACPI_ALL_COMPONENTS`) and ACPI hardware support (`ACPI_ALL_DRIVERS`).  The "
"verbosity of debugging output is specified as the level and ranges from just "
"report errors (`ACPI_LV_ERROR`) to everything (`ACPI_LV_VERBOSE`).  The "
"level is a bitmask so multiple options can be set at once, separated by "
"spaces.  In practice, a serial console should be used to log the output so "
"it is not lost as the console message buffer flushes.  A full list of the "
"individual layers and levels is found in man:acpi[4]."
msgstr ""
"ACPI 드라이버에는 유연한 디버깅 기능이 있습니다. 하위 시스템 세트와 상세 "
"수준을 지정할 수 있습니다.  디버깅할 서브시스템은 레이어로 지정되며 "
"컴포넌트(`ACPI_ALL_COMPONENTS`)와 ACPI 하드웨어 지원(`ACPI_ALL_DRIVERS`)으로 "
"구분됩니다.  디버깅 출력의 상세도는 레벨로 지정되며, 오류만 보고하는 "
"것(`ACPI_LV_ERROR`)부터 모든 것을 보고하는 것(`ACPI_LV_VERBOSE`)까지 "
"다양합니다.  레벨은 비트마스크이므로 공백으로 구분하여 여러 옵션을 한 번에 "
"설정할 수 있습니다.  실제로는 직렬 콘솔을 사용하여 출력을 기록해야 콘솔 "
"메시지 버퍼가 플러시될 때 손실되지 않습니다.  개별 레이어와 레벨의 전체 "
"목록은 man:acpi[4]에서 확인할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1925
msgid ""
"Debugging output is not enabled by default. To enable it, add `options "
"ACPI_DEBUG` to the custom kernel configuration file if ACPI is compiled into "
"the kernel.  Add `ACPI_DEBUG=1` to [.filename]#/etc/make.conf# to enable it "
"globally.  If a module is used instead of a custom kernel, recompile just "
"the [.filename]#acpi.ko# module as follows:"
msgstr ""
"디버깅 출력은 기본적으로 활성화되어 있지 않습니다. 활성화하려면 ACPI가 "
"커널로 컴파일된 경우 커스텀 커널 구성 파일에 `options ACPI_DEBUG`를 "
"추가합니다.  전역으로 활성화하려면 [.filename]#/etc/make.conf#에 "
"`ACPI_DEBUG=1`을 추가합니다.  커스텀 커널 대신 모듈을 사용하는 경우 다음과 "
"같이 [.filename]#acpi.ko# 모듈만 다시 컴파일하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1929
#, no-wrap
msgid "# cd /sys/modules/acpi/acpi && make clean && make ACPI_DEBUG=1\n"
msgstr "# cd /sys/modules/acpi/acpi && make clean && make ACPI_DEBUG=1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1933
msgid ""
"Copy the compiled [.filename]#acpi.ko# to [.filename]#/boot/kernel# and add "
"the desired level and layer to [.filename]#/boot/loader.conf#.  The entries "
"in this example enable debug messages for all ACPI components and hardware "
"drivers and output error messages at the least verbose level:"
msgstr ""
"컴파일된 [.filename]#acpi.ko#를 [.filename]#/boot/kernel#에 복사하고 원하는 "
"레벨과 레이어를 [.filename]#/boot/loader.conf#에 추가합니다.  이 예제의 "
"항목은 모든 ACPI 구성 요소 및 하드웨어 드라이버에 대한 디버그 메시지를 "
"활성화하고 최소 상세 수준에서 오류 메시지를 출력합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1938
#, no-wrap
msgid ""
"debug.acpi.layer=\"ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS\"\n"
"debug.acpi.level=\"ACPI_LV_ERROR\"\n"
msgstr ""
"debug.acpi.layer=\"ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS\"\n"
"debug.acpi.level=\"ACPI_LV_ERROR\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1943
msgid ""
"If the required information is triggered by a specific event, such as a "
"suspend and then resume, do not modify [.filename]#/boot/loader.conf#.  "
"Instead, use `sysctl` to specify the layer and level after booting and "
"preparing the system for the specific event.  The variables which can be set "
"using `sysctl` are named the same as the tunables in [.filename]#/boot/"
"loader.conf#."
msgstr ""
"일시 중단 후 재개와 같은 특정 이벤트에 의해 필요한 정보가 트리거되는 경우 [."
"filename]#/boot/loader.conf#를 수정하지 마세요.  대신, 부팅 후 특정 이벤트에 "
"대비하여 시스템을 준비한 후 `sysctl`을 사용하여 레이어와 레벨을 지정하세요.  "
"`sysctl`을 사용하여 설정할 수 있는 변수의 이름은 [.filename]#/boot/loader."
"conf#의 튜너블과 동일합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1945
msgid ""
"Once the debugging information is gathered, it can be sent to {freebsd-acpi} "
"so that it can be used by the FreeBSD ACPI maintainers to identify the root "
"cause of the problem and to develop a solution."
msgstr ""
"디버깅 정보가 수집되면 {freebsd-acpi}로 전송되어 FreeBSD ACPI 유지 관리자가 "
"문제의 근본 원인을 파악하고 해결책을 개발하는 데 사용할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/config/_index.adoc:1949
msgid ""
"Before submitting debugging information to this mailing list, ensure the "
"latest BIOS version is installed and, if available, the embedded controller "
"firmware version."
msgstr ""
"이 메일링 리스트에 디버깅 정보를 제출하기 전에 최신 BIOS 버전이 설치되어 "
"있는지, 가능한 경우 임베디드 컨트롤러 펌웨어 버전이 설치되어 있는지 "
"확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1952
msgid "When submitting a problem report, include the following information:"
msgstr "문제 보고서를 제출할 때는 다음 정보를 포함하세요:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1954
msgid ""
"Description of the buggy behavior, including system type, model, and "
"anything that causes the bug to appear. Note as accurately as possible when "
"the bug began occurring if it is new."
msgstr ""
"시스템 유형, 모델, 버그를 발생시킨 원인 등 버그가 발생한 동작에 대한 "
"설명입니다. 새로운 버그인 경우 버그가 언제 발생하기 시작했는지 가능한 한 "
"정확하게 기록하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1955
msgid ""
"The output of `dmesg` after running `boot -v`, including any error messages "
"generated by the bug."
msgstr "`boot -v`를 실행한 후 `dmesg`의 출력(버그로 인해 생성된 오류 메시지 포함)."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1956
msgid ""
"The `dmesg` output from `boot -v` with ACPI disabled, if disabling ACPI "
"helps to fix the problem."
msgstr ""
"ACPI를 비활성화하여 문제를 해결하는 데 도움이 되는 경우, ACPI를 비활성화한 "
"상태에서 `boot -v`의 `dmesg` 출력을 확인합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1957
msgid ""
"Output from `sysctl hw.acpi`. This lists which features the system offers."
msgstr "`sysctl hw.acpi`의 출력. 시스템이 제공하는 기능을 나열합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1958
msgid ""
"The URL to a pasted version of the system's ASL. Do _not_ send the ASL "
"directly to the list as it can be very large. Generate a copy of the ASL by "
"running this command:"
msgstr ""
"붙여넣은 버전의 시스템 ASL에 대한 URL. ASL은 매우 클 수 있으므로 목록에 직접 "
"보내지 마세요. 이 명령을 실행하여 ASL의 복사본을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/config/_index.adoc:1962
#, no-wrap
msgid "# acpidump -dt > name-system.asl\n"
msgstr "# acpidump -dt > name-system.asl\n"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1966
msgid ""
"Substitute the login name for _name_ and manufacturer/model for _system_.  "
"For example, use [.filename]#njl-FooCo6000.asl#."
msgstr ""
"로그인 이름을 _이름_으로, 제조사/모델을 _시스템_으로 대체합니다.  예를 들어 ["
".filename]#njl-FooCo6000.asl#을 사용합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1973
msgid ""
"Most FreeBSD developers watch the {freebsd-current}, but one should submit "
"problems to {freebsd-acpi} to be sure it is seen.  Be patient when waiting "
"for a response.  If the bug is not immediately apparent, submit a bug "
"report.  When entering a PR, include the same information as requested "
"above.  This helps developers to track the problem and resolve it.  Do not "
"send a PR without emailing {freebsd-acpi} first as it is likely that the "
"problem has been reported before."
msgstr ""
"대부분의 FreeBSD 개발자는 {freebsd-current}를 보지만, {freebsd-acpi}에 "
"문제를 제출해야 볼 수 있습니다.  응답을 기다릴 때는 인내심을 가지세요.  "
"버그가 즉시 드러나지 않는다면 버그 리포트를 제출하세요.  PR을 입력할 때 "
"위에서 요청한 것과 동일한 정보를 포함하세요.  이렇게 하면 개발자가 문제를 "
"추적하고 해결하는 데 도움이 됩니다.  이전에 문제가 보고되었을 가능성이 "
"높으므로 {freebsd-acpi}에 먼저 이메일을 보내지 않고 PR을 보내지 마세요."

#. type: Title ===
#: documentation/content/en/books/handbook/config/_index.adoc:1975
#, no-wrap
msgid "References"
msgstr "참고 자료"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1978
msgid "More information about ACPI may be found in the following locations:"
msgstr "ACPI에 대한 자세한 정보는 다음 위치에서 확인할 수 있습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1980
msgid ""
"The FreeBSD ACPI Mailing List Archives (https://lists.freebsd.org/pipermail/"
"freebsd-acpi/[https://lists.freebsd.org/pipermail/freebsd-acpi/])"
msgstr ""
"FreeBSD ACPI 메일링 리스트 아카이브(https://lists.freebsd.org/pipermail/"
"freebsd-acpi/[https://lists.freebsd.org/pipermail/freebsd-acpi/])"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1981
msgid ""
"The ACPI 2.0 Specification (http://acpi.info/spec.htm[http://acpi.info/spec."
"htm])"
msgstr "ACPI 2.0 사양 (http://acpi.info/spec.htm[http://acpi.info/spec.htm])"

#. type: Plain text
#: documentation/content/en/books/handbook/config/_index.adoc:1981
msgid ""
"man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], and man:"
"acpidb[8]"
msgstr ""
"man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], man:acpidb[8]"
